

Electronic Notes in Theoretical Computer Science 262 (2010) 157–171
www.elsevier.com/locate/entcs

Optimizing Conditional Logic Reasoning within CoLoSS
Daniel Hausmanna,1 Lutz Schro¨dera,b,2
a DFKI Bremen, SKS
b Department of Mathematics and Computer Science, Universita¨t Bremen, Germany

Abstract
The generic modal reasoner CoLoSS covers a wide variety of logics ranging from graded and probabilistic modal logic to coalition logic and conditional logics, being based on a broadly applicable coalgebraic seman- tics and an ensuing general treatment of modal sequent and tableau calculi. Here, we present research into optimisation of the reasoning strategies employed in CoLoSS. Specifically, we discuss strategies of mem- oisation and dynamic programming that are based on the observation that short sequents play a central role in many of the logics under study. These optimisations seem to be particularly useful for the case of conditional logics, for some of which dynamic programming even improves the theoretical complexity of the algorithm. These strategies have been implemented in CoLoSS; we give a detailed comparison of the different heuristics, observing that in the targeted domain of conditional logics, a substantial speed-up can be achieved.
Keywords: Coalgebraic modal logic, conditional logic, automated reasoning, optimisation, heuristics, memoizing, dynamic programming


Introduction
In recent decades, modal logic has seen a development towards semantic hetero- geneity, witnessed by an emergence of numerous logics that, while still of manifestly modal character, are not amenable to standard Kripke semantics. Examples include probabilistic modal logic [4], coalition logic [11], and conditional logic [2], to name just a few. The move beyond Kripke semantics, mirrored on the syntactical side by the failure of normality, entails additional challenges for tableau and sequent systems, as the correspondence between tableaux and models becomes looser — tableaux are still graphs, but models are generally more complex structures.
This problem is tackled on the theoretical side by introducing the semantic framework of coalgebraic modal logic [8,12], which covers all logics mentioned above

1 Email: Daniel.Hausmann@dfki.de
2 Email: Lutz.Schroeder@dfki.de

1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.04.012

and many more. It turns out that coalgebraic modal logic does allow the design of generic reasoning algorithms, including a generic tableau method originating from [15]; this generic method may in fact be separated from the semantics and developed purely syntactically, as carried out in [9,10].
Generic tableau algorithms for coalgebraic modal logics, in particular the algo- rithm described in [15], have been implemented in the reasoning tool CoLoSS [1] 3 .
As indicated above, it is a necessary feature of the generic tableau systems that they potentially generate multiple successor nodes for a given modal demand, so that in addition to the typical depth problem, proof search faces a rather noticeable problem of breadth. The search for optimisation strategies to increase the efficiency of reasoning thus becomes all the more urgent. Here we present one such strategy, which is generally applicable, but particularly efficient in reducing both depth and branching for the class of conditional logics. We exploit a notable feature of this class, namely that many of the relevant rules rely rather heavily on premises stat- ing equivalence between formulas; thus, conditional logics are a good candidate for memoising strategies, applied judiciously to short sequents. We describe the imple- mentation of memoising and dynamic programming strategies within CoLoSS, and discuss the outcome of various comparative experiments.

Generic Sequent Calculi for Coalgebraic Modal Logic
Coalgebraic modal logic, originally introduced as a specification language for coalge- bras, seen as generic reactive systems [8], has since evolved into a generic framework for modal logic beyond Kripke semantics [3]. The basic idea is to encapsulate the branching type of the systems relevant for the semantics of a particular modal logic, say probabilistic or game-theoretic branching, in the choice of a set functor, the sig- nature functor (e.g. the distribution functor and the games functor in the mentioned examples), and to capture the semantics of modal operators in terms of so-called predicate liftings. For the purposes of the present work, details of the semantics are less relevant than proof-theoretic aspects, which we shall recall presently. The range of logics covered by the coalgebraic approach is extremely broad, including, besides standard Kripke and neighbourhood semantics, e.g. graded modal logic [5], probabilistic modal logic [4], coalition logic [11], various conditional logics equipped with selection function semantics [2], and many more.
Syntactically, logics are parametrised by the choice of a modal similarity type Λ,
i.e. a set of modal operators with associated finite arities. This choice determines the set of formulas φ, ψ via the grammar
φ, ψ ::= p | φ ∧ ψ | ¬φ | ♥(φ1,..., φn)

where ♥ is an n-ary operator in Λ. Examples are Λ = {Lp | p ∈ [0, 1] ∩ Q}, the unary operators Lp of probabilistic modal logic read ‘with probability at least p’; Λ = { k | k ∈ N}, the operators  k of graded modal logic read ‘in more than k

3 available under http://www.informatik.uni-bremen.de/cofi/CoLoSS/

successors’; Λ = {[C] | C ⊆ N}, the operators [C] of coalition logic read ‘coalition C (a subset of the set N of agents) can jointly enforce that’; and, for our main example here, Λ = {⇒}, the binary modal operator ⇒ of conditional logic read e.g. ‘if . . . then normally . . . ’.
Coalgebraic modal logic was originally limited to so-called rank-1 logics axioma- tised by formulas with nesting depth of modal operators uniformly equal to 1 [12]. It has since been extended to the more general non-iterative logics [14] and to some degree to iterative logics, axiomatised by formulas with nested modalities [13]. The examples considered here all happen to be rank-1, so we focus on this case. In the rank-1 setting, it has been shown [12] that all logics can be axiomatised by one-step rules φ/ψ, where φ is purely propositional and ψ is a clause over formulas of the form ♥(a1,..., an), where the ai are propositional variables. In the context of a sequent calculus, this takes the following form [9].
Definition 2.1 If S is a set (of formulas or variables) then Λ(S) denotes the set
{♥(s1,..., sn) |♥∈ Λ is n-ary, s1,..., sn ∈ S} of formulas comprising exactly one application of a modality to elements of S. An S-sequent, or just a sequent in case that S is the set of all formulas, is a finite subset of S ∪{¬A | A ∈ S}. Then, a one- step rule Γ1,..., Γn/Γ0 over a set V of variables consists of V -sequents Γ1,..., Γn, the premises, and a Λ(S)-sequent Γ0, the conclusion. A goal is a set of sequents, typically arising as the set of instantiated premises of a rule application.
A given set of one-step rules then induces an instantiation of the generic sequent calculus [9] which is given by a set of rules Rsc consisting of the finishing and the
branching rules Rb  (i.e. rules with no premise or more than one premise), the
linear rules Rl  (i.e. rules with exactly one premise) and the modal rules Rm, i.e.
the given one-step rules. The finishing and the branching rules are presented in Figure 1 (where T = ¬⊥ and p is an atom), the linear rules are shown in Figure 2. So far, all these rules are purely propositional. As an example for a set of modal one-step rules, consider the modal rules Rm of the standard modal logic K as given
by Figure 3.


Fig. 1. The finishing and the branching sequent rules Rb


Fig. 2. The linear sequent rules Rl



Fig. 3. The modal rule of K
This calculus has been shown to be complete under suitable coherence assumptions on the rule set and the coalgebraic semantics, provided that the set of rules absorbs cut and contraction in a precise sense [9]. We say that a formula is provable if it can be derived in the relevant instance of the sequent calculus; the algorithms presented below are concerned with the provability problem, i.e. to decide whether a given sequent is provable. This is made possible by the fact that the calculus does not include a cut rule, and hence enables automatic proof search. For rank-1 logics, proof search can be performed in PSPACE under suitable assumptions on the representation of the rule set [15,9]. The corresponding algorithm has been implemented in the system CoLoSS [1] which remains under continuous develop- ment. Particular attention is being paid to finding heuristic optimisations to enable practically efficient proof search, as described here.
Our running example used in the presentation of our optimisation strategies below is conditional logic as mentioned above. The most basic conditional logic is CK [2] (we shall consider a slightly extended logic below), which is characterised by assuming normality of the right-hand argument of the non-monotonic conditional
⇒, but only replacement of equivalents in the left-hand arguments. Absorption of cut and contraction requires a unified rule set consisting of the rules depicted in Fig. 4 with A = C abbreviating the pair of sequents ¬A, C and ¬C, A. This illus-


Fig. 4. The modal rule of CK
trates two important points that play a role in the optimisation strategies described below. First, the rule has a large branching degree both existentially and univer- sally – we have to check that there exists a rule proving some sequent such that all its premises are provable, and hence we have to guess one of exponentially many subsequents to match the rule and then attempt to prove linearly many premises; compare this to linearly many rules and a constant number of premises per rule (namely, 1) in the case of K shown above. Secondly, many of the premises are short sequents. This will be exploited in our memoisation strategy. We note that labelled sequent calculi for conditional logics have been designed previously [7] and have been implemented in the CondLean prover [6]; contrastingly, our calculus is unlabelled, and turns out to be conceptually simpler. The comparison of the rela- tive efficiency of labelled and unlabelled calculi remains an open issue for the time

being.

The Algorithm
According to the framework introduced above, we now devise a generic algorithm to decide the provability of formulas, which is easily instantiated to a specific logic by just implementing the relevant modal rules.
Algorithm 1 makes use of the sequent rules in the following manner: In order to show the provability of a formula φ, the algorithm starts with the sequent {φ} and just keeps trying to apply all of the sequent rules in Rsc to it, giving precedence to the linear rules. Below, we refer to a sequent as open if it has not yet been checked for provability. Under suitable tractability assumptions on the rule set as in [15,9], this algorithm realises the theoretical upper bound PSPACE . It is the starting point of the proof search algorithms employed in CoLoSS, being essentially a sequent reformulation of the algorithm described in [1], where it is easily verified that
correctness and termination of the algorithm are preserved by this reformulation; optimisations of this algorithm are the subject of the present work.
Algorithm 1 (Decide provability of a sequent Γ)
	Try all possible applications of rules from Rsc to Γ, giving precedence to linear rules. For every such rule application, perform the following steps, and answer ‘provable’ in case these steps succeed for one of the rule applications.
Let Λ denote the set of premises arising from the rule application.
Check recursively that every sequent in Λ is provable.

The conditional logic instance
The genericity of the introduced sequent calculus allows us to easiliy create instan- tiations of Algorithm 1 for a large variety of modal logics:
For instance it has been shown in [10] that the complexity of CKCEM is coNP ,
using a dynamic programming approach in the spirit of [16]; in fact, this was the original motivation for exploring the optimisation strategies pursued here. Due to this reason, we restrict ourselves to the examplary conditional logic CKCEM for the remainder of this section; slightly adapted versions of the optimisation will work for other conditional logics. CKCEM is characterised by the additional axioms
of conditional excluded middle (A ⇒ B) ∨ (A ⇒ ¬B), which to absorb cut and
contraction is integrated in the rule for CK as shown in Figure 5.


Fig. 5. The modal rule CKCEM of conditional logic

In the following, we use the notions of conditional antecedent and conditional consequent to refer to the parameters of the modal operator of conditional logic.
In order to decide using Algorithm 1 whether there is an instance of the modal rule of conditional logic which can be applied to the actual current sequent, it is necessary to create a preliminary premise for each possible combination of equalities of all the premises of the modal operators in this sequent. This results in 2n − 1 new premises for a sequent with n top-level modal operators.
Example 3.1 For the sequent Γ = {(A0 ⇒ B0), (A1 ⇒ B1), (A2 ⇒ B2)}, there are 23 = 8 possible instances of the rule to be tried, corresponding to the non-empty subsequents of the goal; the premise to be checked for I ⊆ {1, 2, 3} consists of Ai = Aj for i, j ∈ I, and {Bi | i ∈ I}.
It seems to be a more intelligent approach to first partition the set of all antecedents of the top-level modal operators in the current sequent into equivalence classes with respect to logical equality. This partition allows for a significant reduction both of the number of rules to be tried and of the number of premises to be actually proved for each rule.
Example 3.2 Consider again the sequent from Example 3.1. By using the exam- plary knowledge that A0 = A1, A1 /= A2 and A0 /= A2, it is immediate that there are just two reasonable instations of the modal rule, leading to the two premises
{{B0, B1}} and {{B2}}. For the first of these two premises, note that it is not necessary to show the equivalence of A0 and A1 again.
In the case of conditional logic, observe the following: Since the modal antecedents that appear in a formula are not being changed by any rule of the sequent calculus, it is possible to extract all possibly relevant antecedents of a formula even before the actual sequent calculus is applied. This allows us to first compute the equivalence classes of all the relevant antecedents and then feed this knowledge into the actual sequent calculus, as illustrated next.
The Optimisation
Definition 4.1 A conditional antecedent of modal nesting depth i is a conditional antecedent which contains at least one antecedent of modal nesting depth i − 1 and which contains no antecedent of modal nesting depth greater than i − 1. A conditional antecedent of nesting depth 0 is an antecedent that does not contain any further modal operators. Let ai denote the set of all conditional antecedents of modal nesting depth i. Further, let prems(n) denote the set of all conditional

antecedents of modal nesting depth at most n (i.e. prems(n) = 
j=1..n
aj). Finally,

let depth(φ) denote the maximal modal nesting in the formula φ.
Definition 4.2 A set K of sequents together with a function eval : K→ {T, ⊥} is called a knowledge base.
We may now construct an optimized algorithm which allows us to decide provability (and satisfiability) of formulas more efficiently in some cases. The optimized algo-

rithm is constructed from two functions (namely from the actual proving function and from the so-called pre-proving function):
Algorithm 2 (Decide provability of φ using the knowledge base (K, eval ))
If Γ ∈ K, answer ‘provable’ if eval (Γ) = T, else ‘unprovable’. Otherwise:
	Try all possible applications of rules from Y0sc to Γ, giving precedence to linear rules, where Y0sc is an optimised set of rules taking into account the knowledge base, as explained below. For every such rule application, perform the following steps, and answer ‘provable’ in case these steps succeed for one of the rule applications.
Let Λ denote the set of premises arising from the rule application.
Check recursively that every sequent in Λ is provable.
Algorithm 2 is very similar to Algorithm 1 but relies on the knowledge base passed to it and moreover uses a modified set of rules Y0sc. The set of rules Y0sc makes appropriate use of the knowledge base. It is obtained from Ysc by replacing the modal rule from Figure 5 with the modified modal rule from Figure 6. The point is that the premises A0 = ··· = An are replaced by side conditions representing lookup in the knowledge base. This improves on standard memoising as embodied by the lookup operation in step 1 of the above algorithm in that existential branching over potentially applicable rules is reduced: the rule does not even match the target sequent unless the equivalence premises are already in the knowledge base. This is still a complete system due to the way memoising is organised, as explained below.


Fig. 6. The modified modal rule CKCEMm of conditional logic
The knowledge base used in Algorithm 2 is computed in Algorithm 3. The algorithm proceeds by dynamic programming with stages corresponding to modal nesting depth, in the spirit of [16]. Thus, in order to show the equivalence of two conditional antecedents of nesting depth at most i, we assume that the equivalences Ki between modal antecedents of nesting depth less than i have already been computed and the result is stored in evali; hence, two antecedents are equal, if their equivalence is provable by Algorithm 2 using only the knowledge base (Ki, evali).
Algorithm 3 Step 1: Take a formula φ as input. Set i = 0, K0 = ∅, eval 0 = ∅. Step 2: Generate the set premsi of all conditional antecedents of φ of nesting depth at most i. If i < depth(φ) continue with Step 3, else set K = Ki−1, eval = evali−1 and continue with Step 4.
Step 3:  Let eqi denote the set of all equalities Aa = Ab for different formulas
Aa, Ab ∈ premsi. Compute Algorithm 2 (ψ, (Ki, evali)) for all ψ ∈ eqi. Set Ki+1 =

eqi, set i = i + 1. For each equality ψ ∈ eqi, set evali+1(ψ) = T if the result of Algorithm 2 was ‘provable’ and evali+1(ψ) = ⊥ otherwise. Continue with Step 2. Step 4: Call Algorithm 2 (φ, (K, eval )) and return its return value as result.

Treatment of Requisite Equivalences Only
Since Algorithm 3 tries to show the logical equivalence of any combination of two conditional antecedents that appear in φ, it will have worse completion time than Algorithm 1 on many formulas:
Example 4.3 Consider the formula
φ = (((p0 ⇒ p1) ⇒ p2) ⇒ p4) ∨ (((p5 ⇒ p6) ⇒ p7) ⇒ p8).
Algorithm 3 will not only try to show the necessary equivalences between the pairs (((p0 ⇒ p1) ⇒ p2), ((p5 ⇒ p6) ⇒ p7)), ((p0 ⇒ p1), (p5 ⇒ p6)) and (p0, p5), but it will also try to show equivalences between any two conditional antecedents (e.g. (p0, (p5 ⇒ p6))), even though these equivalences will not be needed during the execution of Algorithm 2.
Based on this observation it is possible to define a set C of classes of so-called connected subformulas of a given formula φ. We require that each class ci ∈ C contains only formulas that are pairwise connected in φ. Given a formula φ, two subformulas of it are said to be connected in φ if they may both appear in the conclusion of the application of a modal rule during the course of a proof of φ. Two subformulas of φ are said to be independent in φ if they are not connected.
In the case of conditional logic with conditional excluded middle, two formu- las are connected if they appear at identical positions (modulo different choice of modal operator on each level) within φ. We use the notions of classes of connected antecedents (classes of connected consequents) to refer to the set of those classes which only contain antecedents (consequents, respectively).
Example 4.4 Considering again the formula from Example 4.3, φ has the following classes of connected antecedents:
c1 = {((p0 ⇒ p1) ⇒ p2, (p5 ⇒ p6) ⇒ p7)}, c2 = {(p0 ⇒ p1, p5 ⇒ p6)} and
c3 = {(p0, p5)}.
The classes of connected consequents in φ are as follows:
c4 = {(p4, p8)}, c5 = {(p2, p7)} and c6 = {(p1, p6)}.
Since two independent conditional antecedents will never appear in the scope of the same application of the modal rule, it is in no case necessary to show (or refute) the logical equivalence of independent conditional antecedents. Hence it suffices to focus our attention to the connected conditional antecedents. It is then obvious that any possibly requisite equivalence and its truth-value are allready included in (K, eval ) when the main proving is induced. On the other hand, we have to be aware that it may be the case, that we show equivalences of antecedents which are in fact not needed (since antecedents may indeed be connected and still it is possible

that they never appear together in an application of the modal rule - this is the case whenever two preceding antecedents are not logically equivalent).
As result of these considerations, we devise Algorithm 4, an improved version of Algorithm 3. The crucial difference is that before proving any equivalences, Algorithm 4 partitions the set of all relevant modal antecedents into the set of classes of connected antecedents. Then the algorithm treats equivalences between any two pairs in each of the classes. Hence independent pairs of antecedents remain untreated.
Algorithm 4 Step 1: Take a formula φ as input. Set i = 0, K0 = ∅, eval 0 = ∅. Step 2: Generate the set Ci of all classes of connected conditional antecedents of φ of nesting depth at most i. If i < depth(φ) continue with Step 3, else set K = Ki−1, eval = evali−1 and continue with Step 4.
Step 3: For each c ∈ Ci, let eqc denote the set of all equalities Aa = Ab for different
pairs of formulas Aa, Ab ∈ c. For each eqc, compute Algorithm 2 (ψ, (Ki, evali))
for all ψ ∈ eqc. Set Ki+1 =	eqc, set i = i + 1. For each equality ψ ∈ Ki+1,
set evali+1(ψ) = T if the result of Algorithm 2 was ‘provable’ and evali+1(ψ) = ⊥
otherwise. Continue with Step 2.
Step 4: Call Algorithm 2 (φ, (K, eval )) and return its return value as result.

Implementation
The proposed optimized algorithms have been implemented (using the program- ming language Haskell) as part of the generic coalgebraic modal logic satisfiability solver (CoLoSS 4 ). CoLoSS provides the general coalgebraic framework in which the generic sequent calculus is embedded. It is easily possible to instantiate this generic sequent calculus to specific modal logics, one particular example being conditional logic. The matching function for conditional logic in CoLoSS was hence adapted in order to realize the different optimisations (closely following Algorithms 1, 3 and 4), so that CoLoSS now provides an efficient algorithm for deciding the provability (and satisfiability) of conditional logic formulas.

Comparing the Proposed Algorithms
In order to show the relevance of the proposed optimisations, we devise several classes of conditional formulas. Each class has a characteristic general shape, defin- ing its complexity w.r.t. different parts of the algorithms and thus exhibiting specific advantages or disadvantages of each algorithm:
The formula bloat(i) is a full binary tree of depth i (containing 2i different atoms and 2i − 1 independent modal antecedents):
bloat(i) = (bloat(i − 1)) ⇒ (bloat(i − 1))
bloat(0) = prand

4 As already mentioned above, more information about CoLoSS, a web-interface to the tool and the tested benchmarking formulas can be found at http://www.informatik.uni-bremen.de/cofi/CoLoSS/

Formulas from this class should show the problematic performance of Algorithm 3 whenever a formula contains many modal antecedents which appear at different depths. A comparison of the different algorithms w.r.t. formulas bloat(i) is depicted in Figure 7. Since Algorithm 3 does not check whether pairs of modal antecedents are independent or connected, it performs considerably worse than Algorithm 4 which only attempts to prove the logical equivalence of formulas which are not independent. Algorithm 1 has the best performance in this extreme case, as it only has to consider pairs of modal antecedents which actually appear during the course of a proof. This is the (small) price to pay for the optimisation by dynamic programming.

Fig. 7. Results for bloat(i)

The formula conjunct(i) is just an i-fold conjunction of a specific formula A:
conjunct(i) = A1 ∧ ... ∧ Ai
A = (((p1 ∨p0) ⇒ p2)∨((p0 ∨p1) ⇒ p2))∨ч(((p0 ∨p1) ⇒ p2)∨((p1 ∨p0) ⇒ p2))) This class consists of formulas which contain logically (but not sytactically) equiv- alent antecedents. As i increases, so does the amount of appearances of identical modal antecedents in different positions of the considered formula. A comparison of the different algorithms w.r.t. formulas conjunct(i) is depicted in Figure 8. It is obvious that the optimized algorithms perform considerably better than the unoptimized Algorithm 1. The reason for this is that Algorithm 1 repeatedly proves equivalences between the same pairs of modal antecedents. The optimized algorithms on the other hand are equipped with knowledge about the modal an- tecedents, so that these equivalences have to be proved only once. However, even the runtime of the optimized algorithms is exponential in i, due to the exponen- tially increasing complexity of the underlying propositional formula. Note that the use of propositional tautologies (such as A ↔ (A ∧ A) in this case) would help to greatly reduce the computing time for conjunct(i). Optimisation of propositional reasoning is not the scope of this paper though, thus we devise the following examplary class of formulas (for which propositional tautologies would not help):



Fig. 8. Results for conjunct(i)
The formula explode(i) contains equivalent but not syntactically equal and in- terchangingly nested modal antecedents of depth at most i:
explode(i) = Xi ∨ ... ∨ Xi
1	i
Xi = (Ai ⇒ (... (Ai ⇒ (c1 ∧ ... ∧ ci)) .. .))
1	1	i

Xi = (Ai
⇒ (... (Ai
⇒ чcj) .. .))

j	j mod i	(j+(i−1)) mod i
Ai = pj mod i ∧ ... ∧ p(j+(i−1)) mod i
This class contains complex formulas for which the unoptimized algorithm should not be efficient any more: Only the combined knowledge about all appearing
modal antecedents Ai allows the proving algorithm to reach all modal conse-
quents cn, and only the combined sequent {(c1 ∧...∧ci), чc1,..., чci} (containing
every appearing consequent) is provable. For formulas from this class (specifically designed to show the advantages of optimization by dynamic programming), the optimized algorithms vastly outperform the unoptimized algorithm (see Figure 9).
The tests were conducted on a Linux PC (Dual Core AMD Opteron 2220S (2800MHZ), 16GB RAM). It is obvious that a significant increase of performance may be obtained through the proposed optimisations. In general, the performance of the implementation of the proposed algorithms in the generic reasoner CoLoSS is comparable to dedicated conditional logic provers such as CondLean; a direct comparison is presently made difficult by the fact that the benchmarking formulas used to evaluate CondLean are not listed explicitly in [6].

Generalized Optimisation
As previously mentioned, the demonstrated optimisation is not restricted to the case of conditional modal logics.
Definition 6.1 If Γ is a sequent, we denote the set of all arguments of top-level



Fig. 9. Results for explode(i)
modalities from Γ by arg(Γ). A short sequent is a sequent which consists of just one formula which itself is a propositional formula over a fixed maximal number of modal arguments from arg(Γ). In the following, we fix the maximal number of modal arguments in short sequents to be 2.
The general method of the optimisation then takes the following form: Let S1,..., Sn be short sequents and assume that there is a sound instance (w.r.t the logic at hand) of the generic rule depicted in Figure 10 (where S is any set of sequents).


Fig. 10. The general rule-scheme to which the optimisation may be applied

Then we devise a final version (Algorithm 5) of the optimized algorithm: Instead of considering only equivalences of conditional antecedents for pre-proving, we now extend our attention to any short sequents over any modal arguments.
This new Algorithm 5 may then be used to decide provability of formulas, where the employed rule set has to be extended by the generic modified rule given by Figure 11.
Example 6.2 The following two cases are instances of the generic optimisation:
(Classical modal Logics / Neighbourhood Semantics) Let Γ = { A =  B}, n = 1, S1 = {A = B} and S = ∅. Algorithm 5 may be then applied whenever the following congruence rule is sound in the logic at hand:

Algorithm 5 Step 1: Take a formula φ as input. Set i = 0, K0 = ∅, eval 0 = ∅. Step 2: Generate the set argsi of all modal arguments of φ which have nesting depth at most i. If i < depth(φ) continue with Step 3, else set K = Ki−1, eval = evali−1 and continue with Step 4.
Step 3: Let seqi denote the set of all short sequents of form Si (where Si is a sequent from the premise of rule (Opt)) over at most two formulas Aa, Ab ∈ argsi. Compute Algorithm 2 (ψ, (Ki, evali)) for all ψ ∈ seqi. Set Ki+1 = seqi, set i = i + 1. For each short sequent ψ ∈ seqi, set evali+1(ψ) = T if the result of Algorithm 2 was ‘provable’ and evali+1(ψ) = ⊥ otherwise. Continue with Step 2.
Step 4: Call Algorithm 2 (φ, (K, eval )) and return its return value as result.


Fig. 11. The general optimized rule



(OptCong
)	A = B
 A =  B

The according modified version of this rule is as follows:

m Cong


 A =  B

with the side-condition eval (A = B) = T.
(Monotone modal logics) By setting Γ = { A →  B}, n = 1, S1 = {A → B} and £ = ∅, we may instantiate the generic algorithm to the case of modal logics which are monotone w.r.t. their modal operator. So assume the following rule to be sound in the considered modal logic:

(OptMon
)	A → B
 A →  B

The according modified version of this rule is as follows:

(Optm
)
 A →  B

with the side-condition eval (A → B) = T.
In the case that (OptMon) is the only modal rule in the considered logic (i.e. the case of plain monotone modal logic), all the prove-work which is connected to the modal operator is shifted to the pre-proving process. In particular, matching with the modal rules Y0m becomes a mere lookup of the value of
eval . This means that all calls of the Algorithm 2 correspond in complexity
just to SAT-solving in propositional logic. Furthermore, Algorithm 2 will be called |φ| times. This observation may be generalized:

Remark 6.3 In the case that all modal rules of the considered logic are instances of the generic rule (Opt) with P = ∅ (as seen in Example 6.2), the optimisation

does not only allow for a reduction of computing time, but it also allows us to effectively reduce the sequent calculus to SAT-solving. Furthermore, the optimized algorithm will always be as efficient as the original one in this case (since every occurence of short sequents over arg(Γ) which accord to the current instantiation of the rule (Opt) will have to be shown or refuted even during the course of the original algorithm).
Conclusion
We presented (from a practical point of view) two optimisations for reasoning in conditional logic:
The first optimisation makes use of the concept of dynamic programming in order to separate the two tasks that showing validity of formulas in conditional logic consists of: The first task of proving equivalences of antecedents and the second task of ordinary sequent proving. The use of dynamic programming substantially decreases the branching breadth of the resulting sequent calculus.
The second proposed optimisation introduces a strategy to reduce the amount of pairs of antecedents whose equivalence has to be considered. This is achieved by distinguishing between connected and independent pairs of modal arguments.
When both optimisations are applied at the same time, a significant increase in performance of the sequent algorithm for conditional logic can be observed. This was shown in Section 5.1 by considering the results of benchmarking a Haskell implementation (in the framework of the generic reasoner CoLoSS) of the optimised algorithms.
It remains as an open question whether the gain in perfomance which is obtained by optimising the algorithm for conditional logic may be transferred to other logics by making use of the generic optimisation strategy as described in the last section.

References
G. Calin, R. Myers, D. Pattinson, and L. Schr¨oder. Coloss: The coalgebraic logic satisfiability solver (system description). In Methods for Modalities, M4M-5, vol. 231 of ENTCS, pp. 41–54. Elsevier, 2009.
B. Chellas. Modal Logic. Cambridge University Press, 1980.
C. Cirstea, A. Kurz, D. Pattinson, L. Schr¨oder, and Y. Venema. Modal logics are coalgebraic. The Computer Journal, 2009. In print.
R. Fagin and J. Y. Halpern. Reasoning about knowledge and probability. J. ACM, 41:340–367, 1994.
K. Fine. In so many possible worlds. Notre Dame J. Formal Logic, 13:516–520, 1972.
N. Olivetti and G. L. Pozzato. CondLean: A theorem prover for conditional logics. In Automated Reasoning with Analytic Tableaux and Related Methods, TABLEAUX 2003, vol. 2796 of LNCS, pp. 264–270. Springer, 2003.
N. Olivetti, G. L. Pozzato, and C. Schwind. A sequent calculus and a theorem prover for standard conditional logics. ACM Trans. Comput. Logic, 8(4:22):1–51, 2007.
D. Pattinson. Coalgebraic modal logic: Soundness, completeness and decidability of local consequence.
Theoret. Comput. Sci., 309:177–193, 2003.


D. Pattinson and L. Schr¨oder. Admissibility of cut in coalgebraic logics. In Coalgebraic Methods in Computer Science, CMCS 08, vol. 203 of ENTCS, pp. 221–241. Elsevier, 2008.
D. Pattinson and L. Schr¨oder. Generic modal cut elimination applied to conditional logics. In Automated Reasoning with Analytic Tableaux and Related Methods, TABLEAUX 2009, vol. 5607 of LNCS. Springer, 2009.
M. Pauly. A modal logic for coalitional power in games. J. Logic Comput., 12:149–166, 2002.
L. Schr¨oder. Expressivity of coalgebraic modal logic: The limits and beyond. Theoret. Comput. Sci., 390:230–247, 2008.
L. Schr¨oder and D. Pattinson. How many toes do I have? Parthood and number restrictions in description logics. In Principles of Knowledge Representation and Reasoning, KR 2008, pp. 307–218. AAAI Press, 2008.
L. Schr¨oder and D. Pattinson. Shallow models for non-iterative modal logics. In Advances in Artificial Intelligence, KI 2008, vol. 5243 of LNAI, pp. 324–331. Springer, 2008.
L. Schr¨oder and D. Pattinson. Pspace bounds for rank-1 modal logics. ACM Trans. Comput. Logic, 10(2:13):1–33, 2009.
M. Vardi. On the complexity of epistemic reasoning. In Logic in Computer Science, pp. 243–251. IEEE, 1989.
