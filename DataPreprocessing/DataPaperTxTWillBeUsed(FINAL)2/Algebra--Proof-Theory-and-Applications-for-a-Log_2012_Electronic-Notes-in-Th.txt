Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 286 (2012) 157–172
www.elsevier.com/locate/entcs

Algebra, Proof Theory and Applications for a Logic of Propositions, Actions
and Adjoint Modal Operators
Roy Dyckhoff a,1 Mehrnoosh Sadrzadehb,2,3 Julien Truffautb,3
a School of Computer Science University of St Andrews
St Andrews, Scotland, UK
b Department of Computer Science University of Oxford Oxford, England, UK

Abstract
We develop a cut-free (and hence analytic) nested sequent calculus for a modal logic of actions and proposi- tions. The actions act on propositions via a dynamic modality (the weakest precondition of program logics), whose left adjoint we refer to as ‘update’ (the strongest postcondition). Both logics are positive and have adjoint pairs of epistemic modalities: the left adjoints express agents’ uncertainties and the right adjoints express their beliefs. The rules for ‘update’ encode learning as a result of discarding uncertainty. We prove admissibility of Cut, and hence the completeness of the logic w.r.t. an algebraic semantics. We interpret the logic on epistemic scenarios with honest and dishonest communication actions, add assumption rules to encode them and prove that the extended calculus still has the admissibility results. We apply the calculus to encode and solve the classic epistemic puzzle of muddy children and a modern version of it with dishonest agents.
Keywords: Proof Theory, Cut-Admissibility, Algebra, Adjoint Modalities, Epistemic Scenarios


Introduction
Temporal and epistemic logics can express properties of programs [10] and dis- tributed system protocols [7]. The modalities of epistemic logics encode attitudes such as knowledge and belief, but dynamic changes to these attitudes, e.g. after announcements, have traditionally been formalised only in a semantic fashion. Dy- namic program logics are, on the other hand, developed for the specific purpose of syntactic reasoning about changes of properties. Adding epistemic modalities

1 Email: rd@st-andrews.ac.uk
2 M. Sadrzadeh acknowledges support by EPSRC grant EP/F042728/1.
3 Email: mehrs@cs.ox.ac.uk, truffaut.julien@gmail.com

1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.08.011

to dynamic logics led to logics [3,4] allowing reasoning about belief updates, both syntactically and semantically. But, lacking cut-admissibility, the calculus proposed in [3] is not a basis for automatic proof search. Here we develop a cut-free sequent calculus as basis for a proof search procedure for one such logic. The calculus is nested, in the sense of calculi studied in, e.g., [5,8,9,11,12,15,16,18].
The logic from [3] comprises a linear logic of actions Q and a logic of propo- sitions M . The former act on the latter via modalities, similar to the dynamic modality of PDL, known there as the weakest precondition, and its right adjoint, the strongest postcondition. We develop an algebraic semantics for these logics in terms of a residuated lattice-monoid of actions and its right lattice of propositions; their completions are referred to as “quantale-module pairs” and their application to program semantics has been studied in [1]. We endow both M and Q with families of epistemic adjoint operators. We present sequent calculi for the logics, such that the logic of actions admits a cut rule and that the logic of propositions admits two cut rules (and weakening and contraction rules). The calculi are thus complete w.r.t. the algebraic semantics. Finally, after [3], we interpret the actions Q as announcements (public or private, honest or dishonest), the operations of Q on M as the effects of the actions on propositions, the epistemic modalities in terms of agents’ uncertainties and beliefs, and distributivity properties involving the dy- namic modalities in terms of properties of belief update procedures. We add rules to allow encoding of epistemic scenarios and show that the admissibility results are unaffected. We apply this to encode the classic epistemic scenario of muddy children and new versions of it with dishonest agents. The calculus (with some optimisations) and some example scenarios are implemented in [19].
The sequent calculus of actions and adjoint modalities enriches the calculus of [12] with the two classical operators of ∨ and ∧. The rules for the logic of propositions include those of [17], together with new rules for the dynamic modali- ties, their distributivity interactions with epistemic modalities, and rules for action connectives in propositional contexts. The admissibility theorems are novel contri- butions. The algebraic semantics is a finite version of [3]; our formalisation allows for a completeness proof without lattice completions. Proving admissibility of the cut rules involves hundreds of cases, some already considered in [17]. Our solution of the muddy children puzzle is new; it does not rely on negation or the fix point operator of common knowledge, e.g. that in [10]. The sequent proof offers a uni- fied method of solving such puzzles and is a major improvement on the inductive algebraic proof in [3].
Detailed proofs are available in a long version available from the authors.

Syntax, Algebra and Semantics for Actions
We give here the syntax and the intended algebraic semantics of our action logic; in Section 3 we present a cut-free sequent calculus. In Sections 4 and 5 we add the syntax, an algebraic semantics and a sequent calculus for propositions, including those formed by the interaction of actions and propositions. In Section 6 we give a

soundness and completeness theorem.
Syntax and Algebra of Actions
The set Q of actions q of the action logic is generated over a set A of agents A and a set B of basic actions σ by the following grammar:
q ::= ⊥|T| 1 | σ | q ∧ q | q ∨ q | q • q | 2A q | ◆Aq
The binary connectives ∧ and ∨ will be interpreted as lattice operations of meet and join, with T and ⊥ as their units; • is a monoid multiplication with 1 as its unit, the modalities 2A and ◆A will be adjoint endo-operators on the lattice monoid. We make this more precise as follows:
Definition 2.1 Let A be a set, with elements called agents. A lattice monoid with adjoint modalities (an LMAM) over A is both a bounded lattice (Q, ∨, ∧, T, ⊥) and a unital monoid (Q, 1, •, ≤), where • preserves joins, with two A-indexed families
{◆A}A∈A : Q → Q and {2A}A∈A : Q → Q of order-preserving maps, each ◆A being left adjoint to 2A.
Thus, in addition to the lattice axioms, the following hold, for all q, qj, qjj ∈ Q
and all A ∈ A:
q • (qj ∨ qjj)= (q • qj) ∨ (q • qjj) and (qj ∨ qjj) • q = (qj • q) ∨ (qjj • q)   (1)
q • 1= q  and 1 • q = q	(2)
q ≤ qj implies ◆Aq ≤ ◆Aqj	(3)
q ≤ qj implies 2Aq ≤ 2Aqj	(4)
Aq ≤ qj	iff	q ≤ 2Aqj	(5)
Proposition 2.2 In any LMAM Q over A, the following hold:

Definition 2.3 An LMAM Q over A is multiplicative iff we have the following:
(16)	◆A(q • qj) ≤ (◆Aq) • (◆Aqj)	(17)	◆A1 ≤ 1
Proposition 2.4 In any multiplicative LMAM Q over A, the following hold:
(18)	(2Aq) • (2Aqj) ≤ 2A(q • qj)	(19)	1 ≤ 2A1
The qs are for interpretation of epistemic actions, such as announcements, which may change belief, and ≤ is the information order; hence ∨ is non-deterministic

choice and ⊥ is failure, • is sequential composition and 1 is skip (the null action),
Aq is the “uncertainty” of agent A about action q and 2Aq is the agent’s belief about it. As argued in [3], these epistemic operators allow encoding of various types of announcements such as public and private. Inequality (16) encodes a form of belief update, that the uncertainty about a composite action is derived from the composition of the uncertainties of the component actions.
Semantics of Actions
Let Q be a multiplicative LMAM over A. An interpretation in Q of the action logic (over A, and with set B of basic actions) is a map [−]] : B → Q. The interpretations of compound actions are obtained by induction: [q1 ∨ q2]] = [[q1]] ∨ [[q2]], [[q1 ∧ q2]] = [[q1]] ∧ [[q2]], [[q1 • q2]]= [[q1]] • [[q2]], [[◆Aq]] = ◆A[[q]], [[2Aq]] = 2A[[q]], [[T]] = T, [[⊥]] = ⊥ and [[1]] = 1.
Note that we use Q both for the set of actions of the logic and for the LMAM
interpreting them; the context will always make clear which is intended.
Sequent Calculus for Actions
Preliminaries
We have action items T and action contexts Θ generated by the following syntax:
T ::= q | ΘA   Θ ::= T list
where ΘA will be interpreted as ◆A(J Θ), for J Θ the sequential composition of the interpretations of elements in the list Θ. The use of lists rather than sets or multi-sets reflects the non-commutativity (and non-idempotence) of the composition of actions.
Thus, action contexts (abbreviated to a-contexts) are finite lists of action items, where action items (abbreviated to a-items) are either actions or agent-annotated action contexts. The term context is not in the sense of “having a gap waiting to be filled” but as a short name for the antecedent of a sequent, i.e. the context in which the succedent action is performed (or, when we discuss propositions, asserted). If one of the a-items inside an a-context is replaced by a “hole” [ ], we have an a-context with an a-hole. More precisely, we have the notions of an a-context-with-an-a-hole Σ and an a-item-with-an-a-hole R, defined using mutual recursion as follows:
Σ ::= Θ, R, Θj	R ::= [ ] | ΣA

Given an a-context-with-an-a-hole Σ and an a-context Θ, the result Σ[Θ] of applying the first to the second, i.e. replacing the hole [ ] in Σ by Θ, is an a-context, defined recursively (together with the application of an a-item-with-an-a-hole R to an a-context, to form an a-context) as follows:
(Θj, Rj, Θjj)[Θ] = Θj, Rj[Θ], Θjj	([ ])[Θ] = Θ	(ΣA)[Θ] = (Σ[Θ])A.

This notion of “context with a hole” allows, in the expression of the inference rules, a precise notation for replacement deep inside contexts. For example, with Σ= c, d, (e, [])1,f and Θ = a, b, we obtain Σ[Θ] = c, d, (e, a, b)1,f .
Given a-contexts-with-an-a-hole Σj, Σ, and an a-item-with-an-a-hole R, the com- binations Σj • Σ and R • Σ are defined to be a-contexts with a-holes, as follows, by mutual recursion on the structures of Σj and R:


(Θ, Rj, Θj) • Σ= Θ, (Rj • Σ), Θj	([ ]) • Σ=Σ	(ΣjjA) • Σ= (Σjj • Σ)A


and satisfy (Σj • Σ)[Θ] = Σj[Σ[Θ]] and (R • Σ)[Θ] = R[Σ[Θ]].




Sequents and their Interpretations

[Action] sequents consist of an a-context Θ (on the left), a turnstile and an action q
(on the right). We omit the list constructors, e.g. we write 1, σ, ⊥ ▶ σj rather than
⟨1, σ, ⊥⟩ ▶ σj; the empty list ⟨ ⟩ is often omitted.
The meanings of a-items and of a-contexts, given an interpretation, are obtained by mutual induction on their structure: [[ΘA]] = ◆A[[Θ]], [I1, ··· , In]]= [[I1]]•· · ·•[[In]] and [⟨ ⟩]]=1 
A sequent Θ ▶ q is true in an interpretation [−]] in Q iff [[Θ]] ≤ [[q]]; it is true in Q iff true in all interpretations in Q; it is valid iff true in every multiplicative LMAM. When checking validity of the rules, we use the easy fact that if Θ ≤ Θj then Σ[Θ] ≤ Σ[Θj].




Sequent Calculus

We have the following initial sequents (in which σ is restricted to being a basic action, i.e. is from B):

The rules for the lattice operations, composition and the modalities are:



We also have structural rules, i.e. rules not involving the algebraic operators:

The two indicated occurrences of σ in the Id rule are principal. Each right rule has its conclusion’s succedent as its principal action (but we will always just call it a principal formula); in addition, the ◆AR rule has ΘA as a principal item. Each left rule has a principal item: these are as usual.
The size of an action q is just the (weighted) number of operator occurrences, counting each operator ◆A and 2A as having weight 2; the size of an a-item ΘA is the size of Θ plus 1, and the size of an a-context Θ is the sum of the sizes of its items. The size of a sequent Θ ▶ q is just the sum of the sizes of Θ and q. Note that each premiss of a rule instance has lower size than the conclusion, except for the rule Dist, whose presence leads to non-termination of a naive implementation of the calculus.

Lemma 3.1 For every action q, the sequent q ▶ q is derivable.

Following this, in proofs and examples below, we shall allow the use of Id in the form q ▶ q even where the action q is not a basic action.
Lemma 3.2 The 1L, ∨L, •L, ◆AL, ∧R and 2AR rules are invertible.
Lemma 3.3 The rules TL— and ⊥R— are admissible:


Σ[T] ▶ q


Σ[Θ] ▶ q
TL—	Θ ▶⊥ 
Σ[Θ] ▶ q

⊥R—

As an example of a derivation, we show that a sequence of ◆A operations pre- serves composition and conjunction in one direction:

q ▶ q Id	q′ ▶ q′ Id

qB ▶ ◆B
BR
q
R
q′B ▶ ◆B
q′ ◆BR
R

(qB)A ▶ ◆A◆Bq	(q′B)A ▶ ◆A◆Bq′

(qB)A, (q′B)A ▶ ◆A◆Bq • ◆A◆B
q′	•R

(qB, q′B)A ▶ ◆A◆Bq • ◆A◆B
q′	Dist
q′′ ▶ q′′ Id

((q, q′)B)A ▶ ◆A◆B
q • ◆A◆B
q′ Dist
•L
q′′B ▶ ◆B
q′′ ◆BR
R

((q • q′)B)A ▶ ◆A◆B
q • ◆A◆Bq′
(q′′B )A ▶ ◆A◆B
q′′	A

(((q • q′) ∧ q′′)B)A ▶ ◆A◆B
q • ◆A◆B
q′ ∧L
(((q • q′) ∧ q′′)B)A ▶ ◆A◆B
q′′ ∧L

(((q • q′) ∧ q′′)B)A ▶ (◆A◆B
q • ◆A◆B
q′) ∧ ◆A◆B
q′′	∧R

◆B((q • q′) ∧ q′′)A ▶ (◆A◆B
q • ◆A◆B
q′) ∧ ◆A◆B
q′′ ◆BL

◆A◆B
((q • q′) ∧ q′′) ▶ (◆A◆B
q • ◆A◆B
q′) ∧ ◆A◆B
q′′ ◆AL




Admissibility of Cut
Theorem 3.4 The Cut rule is admissible
Θ ▶ q	Σj[q] ▶ qj
Σj[Θ] ▶ qj	Cut
Proof. Strong induction on the rank of the cut, where the rank is given by the pair (size of cut formula q, sum of heights of derivations of premisses). Full details are in the appendix of the long version.	2

Syntax and Algebra for Propositions
Syntax of propositions
Given sets A of agents A and B of basic actions σ, we have as above an action logic with a set Q of actions q. Now let At be a set of (propositional) atoms p; the set M of propositions m is generated by the following grammar:
m ::= ⊥|T| p | m ∧ m | m ∨ m | 2A m | ◆Am | m · q | [q]m

The last two binary connectives are mixed action-proposition connectives: the op- erator [q] is the dynamic modality operator, with [q]m read as “after action q, proposition m holds”; · q is its left adjoint, called update, with m· q read as “propo- sition m is updated by action q”. The difference is like that in ordinary logic between a → b and b ∧ a. ◆A is the left adjoint of 2A: the former expresses the uncertainty of an agent about a proposition, and the latter expresses his belief; 2Am is read as “A believes that m”.

Algebraic semantics for propositions

Definition 4.1 Let A be a set, with elements called agents. A DLAM over A is a bounded distributive lattice (M, ∧, ∨, T, ⊥) with two A-indexed families {◆A}A∈A : M → M and {2A}A∈A : M → M of order-preserving maps, with each ◆A left ad- joint to 2A, i.e. ◆A(l) ≤ lj iff l ≤ 2A(lj).
For a detailed list of derived properties of a DLAM, see [17].
Definition 4.2 A multiplicative LMAM Q acts on a DLAM M (over the same sets of agents) whenever we have a pointwise order-preserving map · : M ×Q → M , with each · q having a right adjoint [q] : M → M , s.t. the following hold, for all q, qj ∈ Q and all m ∈ M :
m · (q • qj) = (m · q) · qj	(20)
m · 1 = m	(21)
◆A(m · q) ≤ ◆Am · ◆Aq	(22)
Equations 20 and 21 are axioms for a Quantale-Module [1]; inequation 22 encodes a form of learning: the uncertainty of an “updated” proposition m · q is learnt from the update of the uncertainty of m by the uncertainty of q.
Proposition 4.3 Whenever a multiplicative LMAM Q acts on a DLAM M, the follow- ing hold, for all q, qj ∈ Q and m, mj ∈ M:


Let Q be a multiplicative LMAM acting on a DLAM M and [− ] an interpretation of the set of actions of the action logic (over a set B of basic actions) in Q, as defined and extended in subsection 2.2. An interpretation of the set of propositions of the propositional logic (over a set At of atoms) in M is given by a map [[−]] : At → M ; extension of the two interpretations to an interpretation of compound propositions is obtained by structural induction:

[[m1 ∨ m2]]= [[m1]] ∨ [[m2]],	[[m1 ∧ m2]]= [[m1]] ∧ [[m2]],
[[◆A(m)]] = ◆A([[m]]),	[[2Am]] = 2A[[m]],
[[T]] = T,	[[⊥]] = ⊥,
[[m · q]]= [[m]] · [[q]],	[[[q]m]]= [ [q]]][[m]] .
Sequent Calculus for Propositions
Preliminaries
As in the action logic, we have propositional contexts Γ and propositional items I
(abbreviated to p–contexts and p-items), generated by the following grammar:
Γ ::= I multiset	I ::= m | ΓA | ΓΘ.
The union of two multi-sets is indicated by a comma, as in Γ, Γj or (treating an item I as a one element multiset) as in Γ,I. A p-item I can be either a proposition or an agent-annotated p-context, as in [17]; but it can also be a p-context Γ annotated by an a-context Θ.
To express the rules correctly, we need, as in Section 3, some notion of p-context (or item) with a hole. There are now two kinds of hole, one for propositions and one for actions, both represented by [ ]; we use the notations Δ for a p-context-with- a-p-hole, J for a p-item-with-a-p-hole,Λ fora p-context-with-an-a-hole and K for a p-item-with-an-a-hole, defined, using mutual recursion, as follows:
Δ ::= Γ,J	J ::= [ ] | ΔA | ΔΘ	Λ ::= Γ,K	K ::= ΓΣ | ΛΘ
in which we recall from Section 3 that Σ indicates an a-context-with-an-a-hole. Various applications of something with an appropriate hole to p-contexts and p- items and combinations of these can be defined in a way similar to that presented in the action calculus.
Sequents for Propositions and their Interpretations
Our second sequent calculus (see Sub-section 5.3) allows reasoning about relation- ships between propositions. Sequents are now of the form Γ ▶ m. Given the meanings of action items and contexts in a multiplicative LMAM Q as defined above, and with the obvious notion of an interpretation of atomic propositions in a DLAM acted on by Q, extended as in Section 4.2 to compound propositions, the meanings of p-items and of p-contexts are obtained by mutual induction on their structure: [[ΓA]] = ◆A([[Γ]]), [[ΓΘ]] = [[Γ ] · [[Θ]], [I1, ··· , In]] = [[I1]] ∧ · · · ∧ [[In ] and [∅]] = T.
A sequent Γ ▶ m is true in an interpretation [−]] in M iff [[Γ]] ≤ [[m]]; it is true
in M iff true in all interpretations in M , and it is valid iff true in every DLAM M over any multiplicative LMAM Q. That the initial sequents of the following calculus are valid and that the rules preserve truth are proved using ideas familiar from the action calculus: if [[Γ]] ≤ [[Γj]] then [[Δ[Γ]]] ≤ [[Δ[Γj]]] and if [[Θ]] ≤ [[Θj]] then [[Λ[Θ]]] ≤ [[Λ[Θj]]].

Sequent Calculus

We have the following initial sequents (in which p is restricted to being an atom, i.e. in At):

The rules for the lattice operations and the modal operators are:

The rules for the dynamic operations are:

The structural rules are, with Γj in the first two to ensure admissibility of Wk:

As in the action logic, the two indicated occurrences of p in the Id rule are principal and each right rule has its conclusion’s succedent as its principal formula. But in addition, the ◆AR rule has ΓA as its principal item and Γj (which is there to ensure admissibility of Wk) as its parameter. Similarly, the ·R rule has ΓΘ as its principal item and Γj as its parameter. [More detailed definitions of such matters are in the long version.]
We also include all the four kinds of initial sequent and all the fifteen rules of the action logic, and all the variants of the L rules (including ⊥L, Dist and U nit) of the action logic obtained by replacing any Σ by Λ and the succedent action q by a proposition m. These rules are ⊥L, 1L, ∧L, ∨L, •L, ◆L, 2L, Dist and U nit; we thus obtain propositional variants:



The next four lemmas are provable by routine methods:
Lemma 5.1 All sequents Γ,m ▶ m are derivable.
Lemma 5.2 The following Weakening and Contraction rules are admissible:


Δ[Γ] ▶ m

Δ[Γ, Γj] ▶ m Wk 
Δ[Γ, Γ] ▶ m

Δ[Γ] ▶ m	Contr

Lemma 5.3 The rules ∧L, ∨L, ◆AL, 2AL, ·L, ∧R, 2AR and DyR are invertible.
Lemma 5.4 The rules ⊥R— and TL— are admissible:


 Γ ▶⊥ 
⊥R—	 Θ ▶⊥ 
Δ[T] ▶ m	Λ[T] ▶ m
⊥R—	TL—	TL—

Δ[Γ] ▶ q
Λ[Θ] ▶ q
Δ[Γ] ▶ m
Λ[Θ] ▶ m


Admissibility of DyCut and PrCut
Theorem 5.5 The following DyCut and PrCut rules are admissible:


Θ ▶ q	Λ[q] ▶ m
DyCut
Λ[Θ] ▶ m
Γ ▶ m	Δ[m] ▶ mj

Δ[Γ] ▶ mj	PrCut

Proof. Strong induction on the rank of the cut, where the rank is given by the pair: (size of cut formula m, sum of heights of derivations of premisses). Full details are in the long version.	2
Main Result
Theorem 6.1 (Soundness and Completeness) Any derivable sequent is valid; any valid sequent is derivable.
Proof. First, we show that the initial sequents of the sequent calculus of actions are valid and that the rules are truth-preserving. For the converse, we follow the Lindenbaum-Tarski proof method. As usual, cut-admissibility is essential for show- ing transitivity of ▶. Similar methods are followed for the calculus of propositions. Full details are in the long version.	2

Interpretation and Assumption Rules
The interpretations of propositional and action connectives are as usual [1]: ∧, ∨ for conjunction and disjunction on propositions and non-deterministic choice and parallel composition for actions, • (⊗ of linear logic) is the sequential composition of actions, 1 is the skip action. The dynamic connectives [q]m and m·q are the weakest precondition and strongest postcondition, with interpretations as explained above in Subsection 4.1. As for the epistemic modalities, ◆A expresses the appearance to agent A of, or uncertainty of agent A about, a proposition (or an action), and 2A expresses the belief of agent A about a proposition (or an action). The uncertainties are all the propositions (or actions) that appear to A as true (or as happening in case of actions) when the proposition m is indeed true (or the action q is indeed happening).
In a relational semantics, these assumptions are given by the accessibility rela- tion, e.g. that a state (or action) can access certain other states (or actions). In the case of actions, these enable us to express honest and dishonest public and private announcements. The Dist and DyDist rules allow for the uncertainty of a propo- sition updated by a composition of actions to be decomposed to the uncertainties of the actions and the uncertainties of the proposition. A belief after a sequential composition of actions can thus be derived from the belief before it.
Each epistemic scenario has assumptions about the basic actions and atomic propositions involved in the scenario. These are represented algebraically in [3] and we present them proof theoretically here. First, not every action is applicable to every proposition; we can represent the assumption, that a basic action σ is inapplicable when a proposition k holds, by the rule Ker(σ,k). Second, the facts of the world (i.e. atomic propositions p) are stable under basic actions such as announcements; so if a propositional atom p is true before a basic action σ, it will stay true after it; this is represented by the rule Stab(p,σ). Finally, each agent A has some uncertainty about each atomic proposition p (or basic action σ). So we have one or more assumptions of the form “appearance to agent A of atomic proposition p is proposition n” and “appearance to agent A of basic action σ is the action w”, represented by PrApp(A,p,n) and App(A,σ,w) respectively:

Lemma 7.1 The calculus with the assumption rules admits Wk and Contr.
Theorem 7.2 The calculus with the assumption rules admits DyCut and PrCut.
Proof. The Ker rules have σ basic; the Stab rule has p atomic and σ basic; similarly the PrApp and App rules have p atomic and (resp.) σ basic. So, no new principal cuts can be formed. The admissibility of the various forms of Cut is then just an

adaptation of the previous proof, with more permutations but no new principal cuts. A similar method is used in [14].	2

Application
A well-known epistemic scenario is that of the muddy children, as follows: n children are playing in the mud and k of them have muddy foreheads. Each child can see the other children’s foreheads, but cannot see his own. Father announces to them “At least one of you has a muddy forehead.” and then asks “Do you know it is you who has a muddy forehead?”. After k − 1 rounds of honest “no” answers by all the children, the muddy ones infer that they are muddy. We can also reason about variants with dishonesty. For instance, if the father falsely announces that at least one child is muddy, then all the children will wrongly believe that they are muddy. Or the muddy children are liars and after k − 1 honest answers they lie that they do not know that they are muddy; the clean children then wrongly infer that they are muddy.
For a formalization of the honest version, assume the children are enumerated and the first k are muddy. Consider the propositional atoms Di for “child i is muddy” and Ci for “child i is clean”. Since the actions of this scenario are all epis- temic, these propositional atoms are stable under all basic actions. Child i can see the other children’s foreheads: we capture this by PrApp(i,Dj,Dj ) and PrApp(i,Cj,Cj ) for i /= j. But he cannot see his own, so he is uncertain about himself being muddy or not, captured by PrApp(i,Di,DiVCi) and PrApp(i,Ci,DiVCi). We denote father’s initial announcement by basic action σ and children’s “no” replies by basic action σj. These actions are honest public announcements, so their appearance to any child i is identity, captured by App(i,σ,σ) and App(i,σ′,σ′). Father’s initial announcement cannot happen when there is no muddy child, and children’s “no” replies cannot

happen if any of them knows that he is muddy: these are captured by Ker(σ,Λn
Ci)

and Ker(σ′,Vn  2iDi), respectively.
Fig. 1 presents the proof tree for n = 3,k = 2 for the proposition that, after
father’s announcement and one round of “no” answers, a muddy child j =1 knows that he is muddy. Consider the first dishonest variant of the puzzle; we denote father’s lying action by the basic action σ, which appears (in the honest version of the puzzle) to a child i as his honest announcement σ; this is captured by the assumption rule App(i, σ, σ). The action σ cannot happen when a child is muddy; this is captured by the assumption rule Ker(σ, ∨iDi). Figure 2 presents the proof of the proposition that, when no child is muddy and after father’s lie that at least one child is muddy, child i = 2 believes that he is muddy. Assumption rule instances and the proof tree for the second dishonest variant are presented in the appendix of the long version.
Our calculus allows a proof procedure close to human reasoning. In Figure 1, the lowest four steps ∧L, DyR, •L and 21R rewrite the original statement into a normal form. Then DyDist and Dist apply the belief update procedure and decompose the uncertainty of child 1 about the updated proposition to the update of his propositional uncertainty by his action uncertainty. The forking rule ∨L



... 
C2 , C1 , C3 , (D1 , D2 , C3 )1 ▶ ∧3
Id

∧R
Ci
PrApp(1,C ,C )

D , (D ,C , (D ,D ,C )1 )σ ▶ D
C ,C , (D ,D ,C )1 ▶ ∧3 C	3 3

2	2  1
1  2  3
2 Stab
(D2 ,σ)
2  1	1  2  3
i=1 i Ker
(σ,∧3
Ci)

(D2 , C1 , (D1 , D2 , C3 )1 )σ ▶ D2
(C2 , C1 , (D1 , D2 , C3 )1 )σ ▶ D2
∨L
i=1

(D2 ∨ C2 , C1 , (D1 , D2 , C3 )1 )σ ▶ D2

Id	((C , (D , D , C )1 )2 )(σ2 ) ▶ D
PrApp(2,D2 ,D2 ∨C2 ) , App(2,σ,σ)

D ,Dσ' ▶ D
1  1	1 Stab
σ'

(D1 ,σ')
((C1 , (D1 , D2 , C3 )1 )σ )2 ▶ D2

DyDist
22 R

D1 ▶ D1
1 σ σ'	Wk 
(C1 , (D1 , D2 , C3 )1 )σ ▶ 22 D2
1 σ

∨R2

(D1 , (D1 , (D1 , D2 , C3 ) ) )
▶ D1 Stab
(C1 , (D1 , D2 , C3 ) )
▶ 21 D1 ∨ 22 D2 ∨ 23 D3 Ker ' 3

((D , (D , D , C )1 )σ )σ'
'
▶ D1
(D1 ,σ)
ReArr'
((C , (D , D , C )1 )σ )σ'
'
▶ D1

ReArr'
(σ ,∨i=1 2iDi)

(D1 , (D1 , D2 , C3 )1 )(σ,σ ) ▶ D1

(D ∨ C , (D , D , C )1 )(σ,σ') ▶ D
(C1 , (D1 , D2 , C3 )1 )(σ,σ ) ▶ D1
∨L

	 App(1,σ',σ')
(D ∨ C , (D ,D ,C )1 )(σ,σ'1 ) ▶ D

1	1	1
2  3
1 (σ1 ,σ'1 )
1 App
(1,σ,σ)

(D1 ∨ C1 , (D1 , D2 , C3 ) )
((D , D , C )1 )(σ1 ,σ'1
▶ D1 PrApp
) ▶ D1
(1,D1 ,D1 ∨C1 )

((D , D , C )1 )((σ,σ')1 ) ▶ D
((D , D , C )σ,σ' )1 ▶ D
Dist

DyDist

(D , D , C )σ,σ' ▶ 2 D
σ•σ'
21 R
•L

(D1 , D2 , C3 )	▶ 21 D1

D ,D ,C ▶ [σ • σ']2 D
DyR

1  2  3	1 1
∧L
D ∧ D ∧ C ▶ [σ • σ']2 D
1	2	3	1 1


Fig. 1. Proof tree for the honest muddy children puzzle.






... 
∧R
C ,C ,C ▶ C ∧ C ∧ C
2  1  3	1	2	3

(C ,C ,C )2 ,C ,C ,C ▶ C
Wk 
∧ C ∧ C

1  2  3
2  1  3
1	2	3
PrApp(2,C ,C )

(C ,C ,C )2 ,C ,C ▶ C
3  3
∧ C ∧ C

1  2  3
Id
2  1	1
3 PrApp(2,C ,C )


((C ,C ,C )2 ,D )σ,D ▶ D
(C ,C ,C )2 ,C ▶ C
1  1
∧ C ∧ C

1  2  3	2
2	2 Stab(D ,σ)
1  2  3
2	1	2
Ker(σ,∧C  )

((C ,C ,C )2 ,D )σ ▶ D	2	((C ,C ,C )2 ,C )σ ▶ D	i

1  2  3	2	2
1  2  3	2	2
∨L

((C1 , C2 , C3 )2 , D2 ∨ C2 )σ ▶ D2
	 App(2,σ,σ)
((C ,C ,C )2 ,D ∨ C )(σ2 ) ▶ D

1  2  3	2	2
2 PrApp(2,C ,D ∨C )

((C , C , C )2 )(σ2 ) ▶ D
2


DyDist
2  2  2

((C1 , C2 , C3 )σ )2 ▶ D2

(C1 , C2 , C3 )σ ▶ 22 D2 C1 , C2 , C3 ▶ [σ]22 D2 C1 ∧ C2 ∧ C3 ▶ [σ]22 D2
22 R
DyR
∧L



Fig. 2. Proof tree for the lying-father variant of the muddy children puzzle.



creates a case analysis for child 2: the left branch is the real world, and the right branch is when he is the only muddy child (but the applications of Ker show that this option is impossible). A similar pattern is followed in the second proof, where, at the forking rule, child 2’s possibilities are that either he is muddy, or that he is clean, but, since he has heard the announcement that at least one child is muddy, the case with no muddy children is impossible.

Decidability and Complexity
Our sequent calculus has a weak form of the sub-formula property (of a kind studied in [6]) adequate to allow the calculi to be called “analytic”; proof search is therefore effective (even if not efficient) and decidability is routine (since there are none of the issues from first-order logic of choosing terms).
A proof search procedure has been implemented in [19] using a loop-checking technique and variations of the Bounded Depth-First tree expansion strategy. These all have a polynomial space complexity (n log n), but the worst case time complexity of our optimal terminating strategy is O(bd) for b the branching factor and d the depth of the shortest proof.
Summary and future work
Our nested sequent calculus, for a positive logic of propositions and actions with ad- joint epistemic and dynamic modalities, admits cut, and is sound and complete with regard to an algebraic semantics inspired by [1,3]. With added assumption rules) the calculus is applicable to reasoning about dynamic epistemic scenarios. Exist- ing proof theoretic treatments of dynamic epistemic logics, e.g. [2,13], only consider specific actions of public announcements. The only other calculus [3] that allows for arbitrary announcements (public/private, honest/dishonest) lacks cut-admissibility. Our work shows that dynamic epistemic logics can be represented in terms of a cut- free sequent calculus, albeit one with rules admitting substantial non-determinism in root-first proof search. The implementation [19] of this sequent calculus provides an automated tool for encoding scenarios involving both epistemic operators and actions. Refinements of the calculus, addressing issues such as termination and backtracking, are yet to be developed.

References
Abramsky, S. and S. J. Vickers, Quantales, observational logic and process semantics, Mathematical Structures in Computer Science 3 (1993), pp. 161–227.
Balbiani, P., et al, Tableaux for public announcement logic, Journal of Logic and Computation 20
(2010), pp. 55–76.
Baltag, A., B. Coecke and M. Sadrzadeh, Epistemic actions as resources, Journal of Logic and Computation 17 (2007), pp. 555–585.
Baltag, A. and L.S. Moss, Logics for epistemic programs, Synthese 139 (2004), pp. 165–224.
Bru¨nnler, K., “Nested Sequents”, Habilitation thesis, Universit¨at Bern, 2010.
Bru¨nnler, K. and A. Guglielmi, A first order system with finite choice of premises, in: First-Order Logic Revisited, Logos Verlag Berlin (2004), pp. 59–74.
Fagin, R. et al., “Reasoning about Knowledge”, MIT Press 1995.
Fitting, M., Prefixed tableaus and nested sequents, Annals of Pure and Applied Logic 163 (2012),
pp. 291–313.
Gor´e, R. et al, On the correspondence between display postulates and deep inference in nested sequent calculi for tense logics, Logical Methods in Comp. Science 7 (2011), pp. 1–38.

Huth, M. and M. Ryan, “Logic in Computer Science”, Cambridge Univ. Press, 2000.
Kashima, R., Cut-free sequent calculi for some tense logics, Studia Logica 53 (1994), pp. 119–135.
Moortgat, M., Multimodal linguistic inference, Logic J. of the IGPL 3 (1995), pp. 371–401.
Negri, S. and P. Maffezioli, A proof theoretical perspective on public announcement logic, Logic and Philosophy of Science (2012 (to appear)).
Negri, S. and J. von Plato, Cut elimination in the presence of axioms, Bulletin of Symbolic Logic 4
(1998), pp. 418–435.
Poggiolesi, F., “Gentzen Calculi for Modal Propositional Logic”, Springer, 2010.
Restall, G., “An Introduction to Substructural Logics”, Routledge, 2000.
Sadrzadeh, M. and R. Dyckhoff, Positive logic with adjoint modalities: Proof theory, semantics and reasoning about information, Review of Symbolic Logic 3 (2010), pp. 351–373.
Strassburger, L., Nested sequents for intuitionistic modal logics, submitted January 2012
Truffaut, J., “Implementation and Improvements of a Cut-Free Sequent Calculus for Dynamic Epistemic Logic,” Department of Computer Science, University of Oxford, 2011.
