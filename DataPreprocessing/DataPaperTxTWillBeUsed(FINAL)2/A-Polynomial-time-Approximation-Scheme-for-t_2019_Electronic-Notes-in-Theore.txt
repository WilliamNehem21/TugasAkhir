Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 346 (2019) 699–710
www.elsevier.com/locate/entcs

A Polynomial-time Approximation Scheme for the MAXSPACE Advertisement Problem
Mauro R. C. da Silva1,2 Rafael C. S. Schouery1,3 Lehilton L. C. Pedrosa1,4
Institute of Computing University of Campinas Campinas, Brazil

Abstract
In the MAXSPACE problem, given a set of ads A, one wants to place a subset A′ ⊆ A into K slots B1,..., BK of size L. Each ad Ai ∈ A has a size si and a frequency wi. A schedule is feasible if the total size of ads in any slot is at most L, and each ad Ai ∈ A′ appears in exactly wi slots. The goal is to find a feasible schedule which maximizes the sum of the space occupied by all slots. We introduce a generalization, called MAXSPACE-RD, in which each ad Ai also has a release date ri ≥ 1 and a deadline di ≤ K, and may only appear in a slot Bj with ri ≤ j ≤ di. These parameters model situations where a subset of ads corresponds to a commercial campaign with an announcement date that may expire after some defined period. We present a polynomial-time approximation scheme for MAXSPACE-RD when K is bounded by a constant, i.e., for any ε > 0, we give a polynomial-time algorithm which returns a solution with value at least (1 − ε)Opt , where Opt is the optimal value. This is the best factor one can expect, since MAXSPACE
is NP-hard, even if K = 2.
Keywords: Approximation Algorithm, PTAS, Scheduling of Advertisements, MAXSPACE.

Introduction
Many websites (such as Google, Yahoo!, Facebook and others) offer free services while displaying advertisements, or simply ads, to users. Often, each website has a single strip of fixed height which is reserved for scheduling ads, and the set of displayed ads changes on a time basis. For such websites, the advertisement is the main source of revenue. Thus, it is important to find the best way to dispose the ads in the available time and space while maximizing the revenue [7].

1 This project was supported by S˜ao Paulo Research Foundation (FAPESP) grants #2015/11937-9, #2016/23552-7 and #2017/21297-2, and National Council for Scientific and Technological Develop- ment (CNPq) grants #425340/2016-3, #313026/2017-3, #308689/2017-8 and #425806/2018-9.
2 Email: maurorcsc@gmail.com
3 Email: rafael@ic.unicamp.br
4 Email: lehilton@ic.unicamp.br

https://doi.org/10.1016/j.entcs.2019.08.061
1571-0661/© 2019 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

The revenue from web advertising grew considerably in the 21st century. In 2013, the total revenue was US$42.78 billion, an increase of 17% from the previous year. It is estimated that the U.S. web advertising reached US$77 billion in 2016, and comprised 35% of all advertising spending, overtaking television advertising [7]. In 2016, ads in banners comprised 31,4% of internet advertising (considering banners and mobile platforms), which represents a revenue of US$22.7 billion [8]. Web advertising has created a multi-billionaire industry where algorithms for scheduling advertisements play an important role.
We consider the class of Scheduling of Advertisements Problems introduced by Adler et al. [1], where, given a set A = {A1, A2,..., An} of advertisements, the goal is to schedule a subset Aj ⊆A into a banner in K equal time-intervals. The set of ads scheduled to a particular time interval j, 1 ≤ j ≤ K, is represented by a set of ads Bj ⊆ Aj, which is called a slot. Each ad Ai has a size si and a frequency wi associated with it. The size si represents the amount of space Ai occupies in a slot and the frequency wi ≤ K represents the number of slots which should contain a copy of Ai. An ad Ai can be displayed at most once in a slot and Ai is said to be scheduled if wi copies of Ai appear in slots with at most one copy per slot [1, 4].
The main problems in that class are MINSPACE and MAXSPACE. In MINSPACE, all the ads are to be scheduled in the slots, and the goal is to minimize the height of the highest slot. In MAXSPACE, an upper bound L is specified which represents the size of each slot. A feasible solution for this problem is a schedule of a subset Aj ⊆A into slots B1, B2,..., BK, such that each Ai ∈ Aj is scheduled and the fullness of any slot does not exceed the upper bound L, that is, for each slot B ,		s ≤ L. The goal of MAXSPACE is to maximize the fullness of the slots, defined by		Ai∈A′ siwi. Both of these problems are strongly NP-hard [1, 4]. Dawande	et		al.	[4]	define	three	special	cases	of	MAXS- PACE: MAXw, MAXK|w and MAXs. In MAXw, every ad has the same frequency
w. In MAXK|w , every ad has the same frequency w and the number of slots K is a multiple of w. And, in MAXs, every ad has the same size s. In an analogous way, they define three special cases of MINSPACE: MINw, MINK|w and MINs.
Adler et al. [1] present a 1 -approximation called SUBSET-LSLF for MAXS- PACE when the ad sizes form a sequence s1 > s2 > s3 > . . ., such that for all i, si is a multiple of si+1. Dawande et al. [4] present three approximation algorithms, a ( 1 +  1 )-approximation for MAXSPACE, a 1 -approximation for MAXw and a 1 -
4	4K	3	2
approximation for MAXK|w . Freund and Naor [6] proposed a ( 1 − ε)-approximation for MAXSPACE and a ( 1 − ε)-approximation for the special case in which the size of ads are in the interval [L/2, L].
Adler et al. [1] present a 2-approximation called Largest-Size Least-Full (LSLF) for MINSPACE. The algorithm LSLF is also a ( 4 −   1  )-approximation to
3	3K/w
MINK|w [4]. Dawande et al. [4] present a 2-approximation for MINSPACE using
LP Rouding, and Dean and Goemans [5] present a 4 -approximation for MINSPACE
using Graham’s algorithm for schedule.
In practice, the time interval relative to each slot in scheduling advertising can represent minutes, seconds or long periods, such as days and weeks. Often, one

considers the idea of release dates and deadlines. An ad has a release date that indicates the beginning of its advertising campaign. Analogously, the deadline of an ad indicates the end of its advertising campaign. For example, ads for Christmas must be scheduled before December, 25th.
We introduce a MAXSPACE generalization called MAXSPACE-RD in which each ad Ai has two additional parameters, a release date ri ≥ 1 and a dead- line di ≤ K. The release date of ad Ai represents the first slot where a copy of Ai can be scheduled, that is, a copy of Ai cannot be scheduled in a slot Bj with j < ri. Similarly, the deadline of an ad Ai represents the last slot where we can schedule a copy of Ai, thus Ai cannot be scheduled in a slot Bj with j > di. We assume that the frequency of each ad Ai is compatible with its release date and deadline, that is, di − ri +1 ≥ wi.
Let Π be a maximization problem. A family of algorithms {Hε} is a Polynomial- Time Approximation Scheme (PTAS) for Π if, for every constant ε > 0, Hε is a (1 − ε)-approximation for Π [9]. A Fully Polynomial-Time Approximation Scheme (FPTAS) is a PTAS whose running time is also polynomial in 1/ε. In this work, we present a PTAS to MAXSPACE-RD when the number of slots is a constant. This approximation is the best one can expect, since MAXSPACE is NP-hard even when the number of slots is 2 [1, 4].
In Section 2 we define the notation and concepts used in this work. In Section 3 we present an algorithm to schedule small ads and in Section 4 we present a PTAS to the whole set of ads. In Section 5 we discuss the results and future works.
Preliminaries
In what follows, assume that the number of slots K is a constant, that L =1 and 0 < si ≤ 1 for each Ai ∈ A.
We partition the ads into two groups: large ads and small ads. For a con-

stant ε > 0, we say that Ai is a large ad if si
≥ ε/(22K 2KK), otherwise we say it

is a small ad. Then, let G = {Ai
∈A| si
≥ ε/(22K 2KK)} be the set of large ads

and P = A\ G be the set of small ads.
Let S denote a feasible solution Aj ⊆A scheduled into slots B1, B2,..., BK.
Then the fullness of a slot Bj is defined as f (Bj)= ΣAi∈Bj si. Also, the fullness
of solution S is f (S)= ΣK  f (Bj).
The type t of an ad Ai ∈ Aj with respect to a solution S is the subset of slots to which Ai is assigned, that is, Ai ∈ Bj if and only if j ∈ t. Let T be a set that contains all the subsets of slots, then T contains every possible type and |T | = 2K. Observe that two ads with the same type have the same frequency, and thus one can think of all ads with the same type as a single ad. For each t ∈T , the occupation ot of type t is the space the ads with this type occupy in each of its slots, i.e., let Aj
be subset of Aj composed of ads of type t, then ot = ΣA ∈A′ si.
A conﬁguration for a subset of ads Aj is a feasible solution which schedules
every ad in Aj. Lemma 2.1 states that if K is constant, then the number of possible configurations containing only large ads is polynomial in the number of large ads,

and can be enumerated by a brute-force algorithm.
Lemma 2.1 If K is constant, then the set of conﬁgurations for all subsets of G
can be listed in polynomial time.
Proof. Since each container has height 1, the number of large ads which can be scheduled into a single slot is at most 1/(ε/(22K 2KK)) = (22K 2KK)/ε. Then, a feasible solution can contain at most R = K(22K 2KK)/ε large ads. Select each subset of Gj ⊆ G with |Gj|≤ R. Observe that the number of such subsets is at
|G|
R
For each Gj, create a multiset M in which each ad Ai ∈ Gj appears wi times, and list every partition of M into sets B1, B2,..., BK. Since |M|≤ KR is bounded by a constant, the number of such partitions for each Gj is bounded by a constant. Now note that any feasible solution of Gj, if any, is a partition of M . This completes the lemma.	2
The so-called ﬁrst-ﬁt heuristic is the algorithm which iteratively schedules each copy of an ad in the first compatible slot (respecting release date and deadline restrictions and not exceeding the slot size) and stops as soon as an ad cannot be scheduled. Lemma 2.2 states that first-fit heuristic is optimal if the optimal value is less then 1/2. This result is used in Section 4.
Lemma 2.2 Let Opt be an optimal solution to A with f (Opt ) < 1/2. The ﬁrst-ﬁt heuristic schedules the whole set A.
Proof. First, note that for each Ai ∈ A, si < 1/2, since otherwise we could sched- ule only Ai to obtain a solution Sj such that f (Sj) ≥ 1/2 > f (Opt ), which is a contradiction.
For the sake of contradiction assume that there is an optimal solution Opt to A with f (Opt ) < 1/2 and the first-fit heuristic does not schedule the whole set A. Now, let S be the solution returned by the first-fit heuristic and let Aj be the set of ads scheduled by S. We claim that Aj = A. If not, then the algorithm must have stopped when trying to schedule an ad Ai. Since the algorithm respects the release date and the deadline, it must be the case that Ai could not be added to some slot Bj without exceeding capacity. Since in this case f (Bj)+ si > 1, and si < 1/2, it follows that f (Bj) > 1/2. But then again f (S) > 1/2 > f (Opt ), which is a contradiction.	2
An algorithm for small ads
Lemma 2.1 states that all configurations of large items can be listed in polynomial time, and thus one can guess the configuration of large ads induced by an optimal solution. This suggests that the hard part of MAXSPACE is obtaining a solution for small ads. In this section, we consider a variant of MAXSPACE which contains only small ads and present an almost optimal algorithm for this problem.
Formally,  let ε > 0 be a constant such that 1/ε  is an integer.   We







x	y













Am

Fig. 1. Example of flow graph to assign ads to types. In blue we have the set U and in green V .
define SMALL-MAXSPACE-RD as the problem of, given a set of ads P ,

where for each Ai
∈ P , si
< ε/(22K 2KK), and for each type t ∈T , and inte-

ger ct ∈ {0, 1,..., 1/ε}, one wants to find a subset Aj ⊆ P for each t ∈T such that the occupation ΣAi∈A′ si ≤ ctε, and which maximizes the fullness
Σ Σ |t|si.
t∈f Ai∈A′

The reasoning behind this problem is that we try to infer the space occupied by each type in any of its slots. Thus, for each type, we guess an integer multiple of ε as its capacity. Since a container’s height is L = 1, there are exactly 1/ε possible guesses for each type capacity. Also, since there are 2K types, if C is the set of capacity combinations, then the size of C is
 1 2K

For each combination c in C, we create an assignment of ads to types using a maximum flow algorithm. For this step, we create a graph H as follows. The vertices of H are a source vertex x, a sink vertex y, and sets U and V , where U contains a vertex for each ad, and V contains a vertex for each type. For each ad Ai ∈ P and each type t ∈ T we add an edge (Ai, t) with flow capacity ∞ if the slots in type t correspond to a valid schedule to ad Ai, that is, t contains exactly wi slots, and each slot of t respects the release date and the deadline of Ai. Furthermore, we add an edge (x, Ai) with flow capacity wisi for each Ai ∈ U , and an edge (t, y) with capacity |t|ct for each t ∈T . Figure 1 illustrates this graph.
Consider then a maximum xy-flow F in H, which can be obtained in polyno- mial time [2] and notice that F induces an assignment from ads to types. In this assignment, if the maximum flow is such that FAi,t units flow from ad Ai to type t, then we say that ad Ai is fractionally assigned to t by an amount of FAi,t/(wisi). Observe that this ratio is at most one. The set of all types t for which FAi,t > 0 is called the support of Ai and is denoted by Sup(Ai).
To eliminate fractional assignments, we group ads with the same support. Let W be a subset of types, and PW be the set of ads Ai with Sup(Ai)= W . In particular, each ad Ai ∈ PW is compatible with any type t ∈ W . For each type t ∈ W , we

define the total flow received by t from PW as


zt =
Ai∈PW
FAi,t.

By the fact that each ad in PW is fractionally assigned to types in W , we know that
Σ wisi ≥ Σ Σ FAi,t = Σ zt.

Ai∈PW
Ai∈PW t∈W
t∈W

In other words, the total size of PW given by  Ai∈PW wisi is not smaller than the flow received by types W from PW . Therefore, we can remove the fractional assignment of all ads in PW , and integrally reassign each ad in PW to types in W , discarding any remaining ad.
The process of rounding the fractional assignment is summarized in Algorithm 1, which receives as input a fractional assignment of ads to types W and returns an integer assignment.

Algorithm 1 Algorithm for rounding ad assignment.
1: procedure Rounding(F )
2:	for each Ai ∈ P and t ∈T do
Ai,t → 0
4:	for each W ⊆T do
5:	PW → all ads Ai with Sup(Ai)= W
6:	for each t ∈ W do
7:	zt →	Ai∈PW FAi,t
8:	Zt →∅ 
9:	for each Ai ∈ PW do
10:	if |t|f (Zt)+ wisi ≤ zt then
11:	Zt → Zt ∪ {Ai}

12:	Fj
i
→ wisi

13:	PW → PW \ {Ai}
14:	discard remaining ads in PW
15:	return Fj
We observe that Algorithm 1 is polynomial in the number of ads.
Lemma 3.1 Algorithm 1 runs in polynomial time.
Lemma 3.2 bounds the total size of ads discarded by Algorithm 1 in each itera- tion.
Lemma 3.2 Let W ⊆T and let PW be the set of ads with support W at the begin- ning of the algorithm. Then the total assignment of PW after the execution is

Ai,t ≥ Σ Σ FAi,t
— |W|ε/(22K 2K).

Ai∈PW t∈W	Ai∈PW t∈W

Proof. Let PW and zt be as in the algorithm, and recall that
Σ wisi ≥ Σ Σ FAi,t = Σ zt.

Ai∈PW
Ai∈PW t∈W
t∈W

If no ad in PW is discarded, then the lemma holds trivially. Thus, assume that there exists an ad Aj which was discarded in the iteration. Since Aj was discarded in every iteration of the Line 6, we know that for any type t,
|t|f (Zt)+ wjsj > zt.


Therefore,
Σ

Ai,t = Σ

Σ wisi = Σ |t|f (Zt)

Ai∈PW t∈W
t∈W Ai∈Zt
t∈W

> Σ(zt − wjsj)= Σ Σ FAi,t − |W|wjsj.

t∈W
Ai∈PW t∈W

Since A  is small, s  < ε/(22K 2KK), and since w  ≤ K, the lemma follows.	2
Corollary 3.3 is obtained from Lemma 3.2.
Corollary 3.3 The difference between the maximum fractional flow and modiﬁed flow is not larger than ε. That is,

j
Ai,t
Ai∈P t∈f
≥	FAi,t − ε.
Ai∈P t∈f

Proof. Consider the value of variables W and PW of Algorithm 1.	Using Lemma 3.2, we have that

Ai,t = Σ	Σ

j
Ai,t

Ai∈P t∈f	W ⊆f Ai∈PW t∈W

≥	, Σ




Σ FAi,t
— |W|ε/(22K 2K)⎞
⎠

≥	F
Ai∈P t∈f
Ai,t
—
W ⊆f
2K(ε/(22K 2K))

=	FAi,t − ε,
Ai∈P t∈f
where the last inequality holds because |W|≤ 2K, and the last equality holds be- cause there are 2|f | = 22K distinct choices for W .	2
The complete algorithm for small ads is presented in Algorithm 2. Given pa- rameter ε > 0, this algorithm receives as input a set of small ads P and a vector c which contains the capacity of each type. The algorithm returns a feasible schedule for Pj ⊆ P in K slots. Based on vector c, the algorithm creates a flow graph and ex- ecutes a maximum flow algorithm to assign ads to type. The Algorithm Rounding

transforms a fractional assignment into an integral assignment. Note that this as- signment can be easily converted into a solution for SMALL-MAXSPACE-RD.

Algorithm 2 Algorithm for small ads.
1: procedure AlgPε(P , c)
2:	H → create flow graph using values of c
3:	F → MaxFlow(H)
4:	Fj → Rouding(F )
5:	Create a solution Sj according to integral assignment Fj
6:	return Sj

In Lemma 3.4 and Lemma 3.5 we prove that Algorithm 2 is polynomial in the instance size, and that it discards at most ε of the space of an optimal schedule.
Lemma 3.4 Algorithm 2 executes in polynomial time.
Lemma 3.5 Let SP  be the solution Algorithm 2 returns and let Opt P be an optimal solution for SMALL-MAXSPACE-RD for a set P of ads. Then, f (SP ) ≥ f (Opt P ) − ε.
Proof. Let F be a maximum flow in H and Fj be the output of Rounding. Define
f (F )= Σ Σ FA ,t	and	f (F j)= Σ Σ Fj	.

i
Ai∈P t∈f

Ai∈P t∈f
Ai,t


Observe that Opt P induces a feasible flow for H with value f (Opt P ). This implies that f (F ) ≥ f (Opt P ), as F is a maximum flow. Also, note that f (SP )= f (F j), then using Corollary 3.3 we have
f (SP )= f (F j) ≥ f (F ) − ε ≥ f (Opt P ) − ε.	2
A PTAS for the general case
In the following, we derive a PTAS for the general case, which tackles both small and large ads. Consider an optimal solution Opt which schedules a subset of ads A∗ into slots B∗, B∗,.  , B∗ . Note that Opt induces a feasible configuration of large ads SG
1	2	K
into slots B1, B2,..., BK such that Bj = B∗ ∩ G. Since all candidate configurations
can be listed in polynomial time by Lemma 2.1, we may assume that we guessed the configuration SG of large ads induced by Opt . We are left with the residual problem of placing small ads.
For each slot j, 1 ≤ j ≤ k, the space which is unused by large ads is


uj =1 −
Ai∈Bj
si.

While these values do not completely specify the capacity ct for each type t, which is part of the input of SMALL-MAXSPACE-RD, the number of possible capacity possibilities is a constant defined by equation (1), and thus, again, we can guess the vector c. We say that a vector c is compatible with SG if, for each 1 ≤ j ≤ K,
ctε ≤ uj.
t∈T :
j∈t

Let o∗ be the occupation of small ads with type t in the solution Opt . Observe that the optimal solution induces a vector c which is compatible with SG and such that ctε ≥ o∗ − ε for each type t. Since we try each capacity vector, we may assume that we guessed c and solved the instance of SMALL-MAXSPACE-RD with c.
Given parameter ε > 0, Algorithm 3 receives as input a set of ads A and returns a feasible solution. First of all, the algorithm tries to schedule all ads with the first-fit heuristic and, if it is possible, the solution is returned. Otherwise, for each configuration of large ads SG and each capacity vector c compatible with SG, the algorithm calls the algorithm AlgPε and obtains a schedule for small ads SP . By combining the solution for large ads in SG and the solution for small ads in SP , it obtains a feasible solution S to the problem. The algorithm returns the best solution Smax found among all pair of configuration and capacity vector.

Algorithm 3 A PTAS for whole set of ads A.
1: procedure Alg(A, ε)
2:	Create a solution Smax using first-fit
3:	if Smax schedules the whole set A then
4:	return Smax
5:	G = {A ∈A| s ≥ ε/(22K 2KK)}
6:	P →A \ G
7:	R → enumerate the set of configurations for large ads as in Lemma 2.1
8:	for each SG ∈ R do
9:	C → enumerate the set of capacity vectors c compatible with SG
10:	for each c ∈ C do
11:	SP → AlgPε(P, c, ε)
12:	S → SG ∪ SP
13:	if f (S) > f (Smax ) then
14:	Smax → Sj
15:	return Smax
We show that Algorithm 3 is a PTAS. First, Lemma 4.1 shows Algorithm 3 runs in time polynomial in the size of the instance. Then, Lemma 4.2 highlights that the returned solution is feasible.
Lemma 4.1 Algorithm 3 executes in polynomial time when K is a constant.
Lemma 4.2 Algorithm 3 returns a feasible solution.

Proof. Since each configuration for large ads is feasible, SG respects release date and deadline restrictions. Solution SP returned by Algorithm AlgPε also respects the release date and deadline restrictions to small ads. Thus, it only remains to show that for the union of SG and SP , the capacity of each slot capacity is not exceeded. Indeed, consider 1 ≤ j ≤ K and let Bj be slot of large ads scheduled

by SG. Also, let Aj
be the set of small ads scheduled by SP with type t. The

occupation of slot j in the combined solution is then

Σ si + Σ
Σ si ≤ Σ
si + Σ ctε ≤ Σ

si + uj ≤ 1,

Ai∈Bj
t∈T : Ai∈A′ j∈t	t
Ai∈Bj
t∈T :
j∈t
Ai∈Bj


where the first inequality holds because SP is a feasible solution for SMALL- MAXSPACE-RD with vector c, and the second inequality holds because c is com- patible with SG.	2
Theorem 4.3 Algorithm 3 is a PTAS to MAXSPACE-RD with constant K.
Proof. By Lemma 4.1 and Lemma 4.2, the algorithm executes in polynomial time and returns a feasible solution.
Let Opt be an optimal schedule and let Smax be the schedule returned by Al- gorithm 3. If the first-fit heuristic schedules the whole set A, f (Smax )= f (Opt ) and the proof ends. Thus, assume the algorithm continues and, by Lemma 2.2, that f (Opt ) ≥ 1/2.

Denote by A∗ the set of ads scheduled by Opt and let Sj
and Sj
be the config-

urations of large and small ads induced by A∗ ∩ G and A∗ ∩ P , respectively, such
that f (Opt ) = f (Sj )+ f (Sj ). Also, let cj be the capacity vector such that for
G	P
each type t, cj is the largest integer with cj ε ≤ o∗, where o∗ is the occupation of ads
t	t	t	t
in A∗ ∩ P with type t. Clearly, cj is compatible with Sj . Therefore, the algorithm
t	G
constructs a solution Sj for the pair of configuration Sj and capacity vector cj.
Let Opt P be an optimal solution for SMALL-MAXSPACE-RD with ads P and vector cj. We claim that f (Opt P ) ≥ f (Sj ) − 2 · 2KKε. To prove this, for each type t, let Aj be a maximal subset of ads in A∗ ∩ P with type t and such that




Ai∈At
si ≤ cj ε.



Thus, the sets Aj
form a feasible solution Sjj
for SMALL-MAXSPACE-RD with

vector cj. Since Aj is maximal, either Aj contains all ads in A∗ ∩ P with type t
and Σ	′ si = o∗ ≥ cj ε, or there is a small ad Aj ∈ A∗ ∩ P with type t which
could not be added to Aj and Σ	′ si > cj ε − sj. In either case,


si
Ai∈At
> cj ε − ε/(22K 2KK).

This implies that the fullness of Opt P , which is at least the fullness of Sjj , is
f (Opt P ) ≥ f (Sjj )= Σ Σ |t|si
t∈f Ai∈A′
> Σ(|t|cj ε − |t|ε/(22K 2KK))
t∈f
∗	2K  K
t
t∈f
≥ f (Sj ) − 2KK(ε + ε/(22K 2KK)).
Therefore, indeed f (Opt P ) ≥ f (Sj ) − 2 · 2KKε.

If SP is the solution obtained by Algorithm
AlgPε for vector cj, then, by

Lemma 3.5, f (SP ) ≥ f (Opt P ) − ε. Let Sj be the solution considered by combin-

ing Sj
and SP . Since the algorithm returns the best found solution,
f (Smax ) ≥ f (Sj)= f (Sj )+ f (SP )
≥ f (Sj )+ f (Opt P ) − ε
≥ f (Sj )+ f (Sj ) − 2 · 2KKε − ε

G	P
≥ f (Opt ) − 3 · 2KKε
≥ f (Opt ) − 6 · 2KKε · f (Opt )
= (1 − 6 · 2KKε)f (Opt ),
where the fourth inequality holds because 2 · 2KK > 1, and the last inequality holds because f (Opt ) > 1/2.
For any εj > 0, by letting ε = εj/(6 · 2KK), the obtained solution has fullness at least (1 − εj)f (Opt ). Therefore, Algorithm 3 is a PTAS for MAXSPACE-RD.	2

5	Final remarks
This paper presented a PTAS for MAXSPACE-RD, which is a generalization of MAXSPACE that deals with release dates and deadlines. To our knowledge, this is the first approximation scheme to this MAXSPACE variant. When the number of bins is given in the input, we can show that MAXSPACE-RD is strongly NP- hard, and thus does not admit an FPTAS. We left open the question of whether the problem with a constant number of slots admits an FPTAS. In future works, we will consider the variant in which the value of an ad is given in the input, and may be unrelated to its size. This variant is a generalization of the Multiple Knapsack Problem [3], which is strongly NP-hard even for K = 2.
References
M. Adler, P. B. Gibbons, and Y. Matias. Scheduling space-sharing for internet advertising. Journal of Scheduling, 5(2):103–119, 2002.

R. K. Ahuja. Network flows: theory, algorithms, and applications. Pearson Education, 2017.
C. Chekuri and S. Khanna. A polynomial time approximation scheme for the multiple knapsack problem. SIAM Journal on Computing, 35(3):713–728, 2005.
M. Dawande, S. Kumar, and C. Sriskandarajah. Performance bounds of algo- rithms for scheduling advertisements on a web page. Journal of Scheduling, 6 (4):373–394, 2003.
B. C. Dean and M. X. Goemans. Improved approximation algorithms for minimum-space advertisement scheduling. In In Proceedings of International Colloquium on Automata, Languages, and Programming, pages 1138–1152, 2003.
A. Freund and J. S. Naor. Approximating the advertisement placement prob- lem. In Proceedings of International Conference on Integer Programming and Combinatorial Optimization, pages 415–424, 2002.
S. Kumar. Optimization Issues in Web and Mobile Advertising: Past and Future Trends. Springer, 2015.
D. Silverman. Iab internet advertising revenue report. In Proceedings of Inter- active Advertising Bureau. New York, page 26, 2010.
V. V. Vazirani. Approximation algorithms. Springer Science & Business Media, 2013.

A  Omitted proofs
Proof. [of Lemma 3.1] The loops of Lines 4 and 6 execute a constant number of iterations, since |T | = 2K and the number of subsets of T is 22K . The inner loop (Line 9) executes a polynomial number of iterations since |PW | is polynomial. Then, the algorithm executes in polynomial time.	2
Proof. [of Lemma 3.4] The maximum flow is solved in polynomial time in the size of graph H [2] and H is polynomial in the size of the instance since it has exactly one vertex per small ad and a constant number of vertices for types. The Rouding algorithm is also polynomial, by Lemma 3.1. Then, Algorithm 2 is polynomial in the instance size.	2
Proof. [of Lemma 4.1] The number of configurations for large ads is polynomial, by Lemma 2.1. Thus, the loop of Line 8 executes a polynomial number of iterations. Also, the number of capacity vectors which are compatible with each such configu- ration is at most a constant, by equation (1). Thus, the loop of Line 10 executes a polynomial number of iterations. The call to AlgPε also runs in polynomial time, by Lemma 3.4. Therefore, the algorithm runs in polynomial time.	2
