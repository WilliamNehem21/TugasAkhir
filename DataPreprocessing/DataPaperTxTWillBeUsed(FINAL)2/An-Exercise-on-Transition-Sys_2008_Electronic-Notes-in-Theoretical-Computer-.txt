	Electronic Notes in Theoretical Computer Science 207 (2008) 89–106	
www.elsevier.com/locate/entcs

An Exercise on Transition Systems
Paula R. Ribeiro1	L. S. Barbosa2
Department of Informatics Minho University, Portugal
Shuling Wang3
LMAM and Department of Informatics, School of Mathematical Sciences Peking University, Beijing, China

Abstract
Labelled transition systems admit different but equivalent characterizations either as relational structures or coalgebras for the powerset functor, each of them with their own merits. Notions of simulation and bisimulation, for example, are expressed in the pointfree relational calculus in a very concise and precise way. On the other hand, the coalgebraic perspective regards processes as inhabitants of a final universe and allows for an intuitive definition of the semantics of process’ combinators.
This paper is an exercise on such a dual characterisation. In particular, it discusses how a notion of weak bisimilarity can be lifted from the relational to the coalgebraic level, to become an effective reasoning tool on coinductively defined process algebras.
Keywords: process algebra, bisimularity, coalgebraic, relational.


Introduction
Recent approaches to process calculi semantics build on representations of labelled transition systems as coalgebras for (some combinations of) the powerset functor. Such coalgebraic characterizations not only provide a generic setting for fundamen- tal constructions (e.g., bisimulation regarded as equality in the final coalgebra), but also makes it easier to generalize typical transition systems concepts to broader classes of dynamic systems (e.g., probabilistic automata [12,2] or hybrid systems [11]).
In this context, references [6,7] introduced a denotational approach to the design
of process algebras in which processes are identified with inhabitants of a final

1 Email: priobom@gmail.pt
2 Email: lsb@di.uminho.pt
3 Email: joycy@math.pku.edu.cn

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.087

coalgebra and their combinators defined by coinductive extension (of ’one-step’ behaviour generator functions). The universality of such constructions entails both definitional and proof principles on top of which the development of the whole calculus is based. Combined with the pointfree ‘calculational’ style entailed by category theory, this leads to a generic way of reasoning about processes in which, in particular, proofs by bisimulation, which classicaly involve the explicit construction of such a relation [15], are replaced by equational reasoning 4 .
In this approach, transition systems over a set A of labels, classicaly specified as
binary relations


are given by coalgebras
α ←− : A × U ←− U	(1)
α : P(A × U) ←− U	(2)

for P(A × Id), where P and Id denote, respectively, the (finite) powerset and the identity functor. It is well-known that set-valued functions, such as coalgebra (2) are models of binary relations and, conversely, any such relation is uniquely transposed
into a set-valued function. The existence and uniqueness of such a transformation leads to the identification of a transpose operator Λ [8] characterized by an universal property which, for this particular case, becomes
α = Λ α ←−  ≡	α ←− = ∈ · α	(3)
Moreover, whenever P in (2) is restricted to the ﬁnite powerset, to enforce the existence of a final universe, equivalence (3) establishes again a bijective correspon- dence between the resulting coalgebras and image ﬁnite relations. In any case, the
fundamental observation is that, the transpose being an isomorphism, one may rea- son either in one side of equivalence (3) or in the other, whichever offers a richer setting for calculation.
This paper reports on such an exercise: seeking for a suitable definition of weak bisimulation within the coalgebraic setting mentioned above, we realized that such equivalences would be described in more intuitive way in a relational setting. Con- structions are then translated back to the coalgebraic level, where they add up to the coinductive, equational calculational toolkit. In a sense, as discussed elsewhere [17], the role of the powerset transpose is similar to that of the Laplace transform to reduce arbitrary expressions to a polynomial format. We believe this way of pro- ceeding is not unrelated to this workshop aim of harnessing theories for supporting software construction.
A subsidiary objective of this paper is to show that, irrespective of the (coal- gebraic or relational) level of expression, effective reasoning requires a ’concise and precise’ notation and an expressive calculus. In most cases this entails going point- free, thus replacing application by composition. For example, in the relational setting, keeping track of nested quantified variables quickly becomes a nightmare.

4 In the dual world of functional programming the role of such ’universals’ is the basis of a whole discipline of algorithm derivation and transformation, which can be traced back to the so-called Bird-Meertens formalism
[9] and the foundational work of T. Hagino [10].

Therefore the paper is formulated within the pointfree calculus of binary relations as developed in, e.g., [4] and the second part of [8].
The paper is organized as follows. Section 2, provides the basic backgound for the paper. In particular, it recalls the rudiments of the relational calculus, introduces notation and briefly reviews the calculational approach to process calculi introduced elsewhere by the first author. Section 3 revisits the relationship connecting the coalgebraic and the relational levels and provides a pointfree relational account of simulation and bisimulation. Characterizing the weak versions of such concepts is the purpose of section 4 which contains the main contribution of the paper. The proposed approach is illustrated by a number of examples. In particular, we show how process properties formulated in terms of weak bisimulation can still be proved in the equational, pointfree style used in [6] and popularised in the ’mathematics of program construction community’. Finally, section 5 summarizes what has been achieved and enumerates a few research questions for the future.

Background
Although the paper resorts to a quite standard mathematical notation to express sets, functions and relations, this section fixes some notation and reviews a few basic notions. Furthermore, it contains a brief introduction to the coinductive approach to process algebra design proposed in [6,7], which provides the context for this paper.
Relations
Let R : B ←− A denote a binary relation on (source) type A and (target) type B, and bRa stand for the representation of (b, a) ∈ R. The set of relations from A to B is ordered by inclusion ⊆, with relation equality being established by anti-symmetry. Fact R ⊆ S means that relation S is either more defined or less deterministic than R, that is, for all a and b of the appropriate types, bRa → bS a.
The algebra of relations is built on top of three basic operators: composition
(R · S ), meet (R ∩ S ) and converse (R◦). As expected, aR◦b iff bRa, meet corresponds to set-theorectical intersection and · generalizes functional composition: b(R · S )c holds iff there exists some a ∈ A such that bRa ∧ aS c.
Any function f can be seen as the relation given by its graph, which, in this
paper, is also denoted by f . Therefore bfa ≡ b = f a. In this setting functions enjoy a number of properties of which the following is singled out by its role in the pointwise to pointfree conversion:
b ( f ◦ · R · g) a ≡ ( f b) R (ga)	(4)
Conversely, any relation R : B ←− A can be uniquely transposed into a set-valued function Λ R : PB ←− A, where the transpose operator Λ satisfies the following uni- versal property: f = Λ R ≡ (bRa ≡ b ∈ ( f a)). The interplay between functions and relations is also captured by the so-called shunting laws [4], of which the following

will be used in the paper:
f · R ⊆ S · g ≡ R ⊆ f ◦ · S · g	(5) Several constructions in the relational calculus emerge as Galois connections [3],
C c Cj. Such is the case, for example, of the left and right division operators given, respectively by
·R c /R	and	R· c R\
References [8] and, mainly, [4], provide a detailed account of the calculus of binary relations, in a pointfree calculational style.

Processes
Technically, the coinductive reconstruction of classical process algebra proposed in [6,7] amounts to the systematic use of the universal property of coinductive
extension, i.e., the existence, for each arbitrary T-coalgebra (U, p : T U ›– U), of a unique morphism [(p)] to the final coalgebra ωT : T νT ›– νT satisfying
k = [(p)]T e ωT · k = T k · p	(6)
Such [(p)], which, in the tradition of [14] or [8] is referred to as the p anamorphism, represents the behaviour generated by p and comes equipped with a bunch of laws usefull in calculation 5 .
As explained in the previous section, in [6] processes are regarded as inhabitants of the final coalgebra ω : k(Act × ν) ›– ν, whose carrier is the set of possibly infinite labelled trees, finitely branched and quotiented by the greatest bisimulation
[1]. On top of it process combinators are defined. Typically, the so-called dynamic combinators, i.e., combinators which are ‘consumed’ on action occurrence, have a direct definition in terms of the available observations. For example, inaction is
represented as a constant nil : ν ›– 1 upon which no relevant observation can be made, i.e., ω · nil = θ. Prefix gives rise to an Act-indexed family of operators
a. : ν ›– ν, with a e A, whereas the possible actions of the non deterministic choice
of two processes p and q corresponds to the collection of all actions allowed for p
and q. Formally, ω · + = ∪ · (ω × ω) and ω · a. = sing · labela, where sing = λx . {x}
and labela = λx . (a, x).
On the other hand, static combinators, which persist over action occurrence, being recursive, are defined as anamorphisms. An example, used later in the paper, is interleaving : ν ›– ν × ν which represents an interaction-free form of parallel composition. The following definition captures the intuition that the observations
over the interleaving of two processes correspond to all possible interleavings of

5 The existence assertion underlying (6) (corresponding to the left to right implication) provides a definition principle for (circular) functions to the final coalgebra which amounts to equip their source with a coalgebraic structure — the gene — specifying the next-step dynamics. The uniqueness part, underlying right to left implication in (6), on the other hand, entails coinduction as a proof principle.

observations of their arguments. Thus,  = [(α )], where 6

α  = ν × ν   a  (ν × ν) × (ν × ν)   (ω×id)×(id×ω)  (k (Act × ν) × ν) × (ν × k(Act × ν))
 τr ×τl  k( Act × (ν × ν)) × k(Act × (ν × ν))   ∪  k( Act × (ν × ν))



The interested reader is refered to [6,7] for the full development of process calculi along the lines just sketeched.


Bisimulation Revisited
The Relational Transpose
The relational transpose (3) is the basic tool to swap from the coalgebraic into the relational setting, or vice-versa. In section 4 this will be applied to discuss weak bisimulation for coinductively defined processes For the moment, however, we shall revisit the notion of bisimulation speaking the language of relations. On the one hand this is necessary to pave the way to section 4; on the other it provides an interesting example of how equational pointfree reasoning style actually simplifies relational proofs.
Our first step is to show that transposition extends to morphisms. Recall that a morphism h : β ›– α from coalgebra α to β is a function between the corresponding state spaces preserving the dynamics of the source coalgebra, i.e., such that

k(id × h) · α = β · h	(7)
What is the relational counterpart of this equation? The answer is given by an easy calculation.

Lemma 3.1 A function h : V ›– U is a morphism relating two k(A × Id)- coalgebras, α and β, deﬁned over U and V, respectively, if and only if

(id × h) · α ›– =  β ›– · h	(8) whose formulation involves the corresponding transition systems α ›– and β ›– . Proof.


6  Morphisms τr : k(Act × (X × C)) ›– k(Act × X) × C and τl : k(Act × (C × X)) ›– C × k(Act × X) stand for, respectively, the right and left strength associated to functor k(Act × Id).

(id × h) · α ›– =	β ›– · h
≡	{ Λ is an isomorphism }
Λ((id × h) · α ›– )  =  Λ( β ›– · h)
≡		{ Λ( f · R) = k f · ΛR and Λ(R · f ) = ΛR · f } k(id × h) · Λ( α ›– ) = Λ( β ›– ) · h
≡	{ definition of α ›– }
k(id × h) · Λ(e · α)  =  Λ(e · β) · h
≡	{ Λ(R · f ) = ΛR · f }
k(id × h) · Λ(e) · α  =  Λ(e) · β · h
≡	{ Λ(e) = id }
k(id × h) · α  =  β · h
□




a
Representing α ›– as an A-indexed family of binary relations α ›– : U ›– U for
all a e A 7 , equation (8) reads


h · α ›–	=
›a– · h	(9)


For each a e A, (9) can be decomposed into the conjuntion of two inclusions:


h · α ›–	⊆
›a– · h	(10)

›a– · h ⊆ h ·
a
α ›–
(11)


which, once turned into predicates and made pointwise, adopt the more familiar form

j	a	j	a

∀u,ujeU . u
α ›– u  →  h u β ›– h u	(12)

j	a	j	a	j	j

∀ueU,vjeV . v
β ›– h u  →  ∃ujeU. u
α ›– u ∧ v
= h u 
(13)


Proof.



7 For notational convinenence the converse of this relation will be written as ( α ›– )  = –→α .

h · α ›– ⊆	β
›a– · h

≡	{ shunting rule (5) }
a	◦	a
α ›– ⊆  h · β ›– · h
≡	{ going pointwise }
j	a	j	◦	a

∀u,ujeU . u
α ›– u  →  u (h
· β ›– · h) u

≡	{ law (4) }
j	a	j	a


and
∀u,ujeU . u
α ›– u  →  h u β ›– h u 

›a– · h ⊆ h ·
a
α ›–

≡	{ going pointwise }
j	a	j	a
∀ueU,vjeV . v ( β ›– · h) u → v (h · α ›– ) u
≡	{ law (4) and relational composition }
j	a	j	a	j	j

∀ueU,vjeV . v
β ›– h u  →  EujeU. u
α ›– u ∧ v
= h u )
□




Taken jointly these equations express that, not only the dynamics of α (represented by transition system α ›– ) is preserved by h (10), but also the dynamics of β is reflected backwards through the same h (11). This leads us directly to bisimulations.

Simulation and Bisimulation
The classical definition of simulation, as given e.g. in [15], reads as follows:
Definition 3.2 Given transition systems α ›– : U × A ›– U and β ›– : V × A ›– V over the same label set A, a simulation of α ›– in β ›– is a relation S : V ›– U such that

j	a	j	a	j	j

∀aeA∀ueU,veV . vS u  →  (∀ujeU . u
α ›– u → (EvjeV . v
β ›– v ∧ v Su ))	(14)

This definition can be rephrased in a form in which the first order expression is turned into a purely algebraic expression:
Lemma 3.3 A relation S : V ›– U is a simulation of α ›– in β ›– iff, for all
a e A

S · –→a
a
α ⊆ –→
β · S	(15)

Proof.

j	a	j	a	j	j

∀aeA∀ueU,veV . vS u  →  (∀ujeU . u
α ›– u → (EvjeV . v
β ›– v ∧ v Su ))

≡	{ definition of relational composition }
a	j	a	j
∀aeA∀ueU,veV . vS u → (∀ujeU . u –→α u → v (–→β · S ) u
≡	{ definition of left relational division }
a	a
∀aeA∀ueU,veV . vS u → v ((–→β · S )/ –→α ) u
≡	{ going pointfree }
S ⊆ ( a	·S )	a
–→β	/ –→α
≡	{ Galois connection: (·R) c (/R) }

S · –→a
a
α ⊆ –→
β · S

□


Using equation (15) the proof of the following folklore result becomes rather concise: no more than 3 steps in each derivation.

Lemma 3.4 (1) The empty relation (⊥) and identity (id) are simulations. (2) The composition and (3) the union of two simulations is still a simulation.

Proof.
Let α ›– be a transition system over A and state space U. Then

⊥· –→a
a
α ⊆ –→
·⊥ ∧ id · –→a
a
α ⊆ –→
α · id

≡	{ ⊥ and id are, respectively the zero and identity element of · }
true

Consider, now, β ›– : V × A ›– V, γ ›– : Z × A ›– Z and α ›– : U × A ›– U, where simulations S : β ›– ›– γ ›– and R : γ ›– ›– α ›– are defined. Then,


(S · R) · –→a
a
α ⊆ –→
β · (S · R)

→	{ S · –→a  ⊆–→a	·S , R· –→a  ⊆–→a	·R, ·-assoc, monotony }

(S · R) · –→a
α ⊆ (S · R) · –→α

≡	{ trivial }
true

Consider, now, systems β ›– : V × A ›– V and α ›– : U × A ›– U connected by simulations S : β ›– ›– α ›– and R : β ›– ›– α ›– . Then,

(S ∪ R) · –→a
a
α ⊆ –→
β · (S ∪ R)

≡	{ (R·) and (·R) as lower adjoints preserve ∪ }

(S · –→a
∪ R · –→α
a
–→β
· S ∪ –→β
· R)

→	{ ∪ definition }

S · –→a
a
α ⊆ –→
· S  ∧ R · –→a
a
α ⊆ –→
β · R

≡	{ hypothesis }
true
□


The standard definition of bisimulation — a relation S such that S itself and its converse S ◦ are both simulations — can also be rephrased as follows:

Lemma 3.5 A relation S : V ›– U is a bisimulation between α ›– and β ›– iff


S · –→a
a
α ⊆ –→
β · S  ∧
›a– · S ⊆ S ·
a
α ›–
(16)


for all a e A.

Proof. The first conjunct is the definition of S as a simulation. For the second
S ◦  is a simulation
≡	{ defining equation (15) }

S ◦· –→a
a
β ⊆ –→
α · S ◦

a
–→γ
)◦ =
γ ›– }

S ◦ · (	a )◦
⊆ (	a )◦ · S ◦

≡	{ (R · S )◦ = S ◦ · R◦ }

( ›a– · S )◦ ⊆ (S ·
α ›– )◦

≡	{ converse is monotonic: R ⊆ S ≡ R◦ ⊆ S ◦ }

›a– · S ⊆ S ·
a
α ›–

□


Introducing variables, we quickly arrive at

›a– · S ⊆ S ·
a
α ›–

≡	{ Galois connection: (R·) c (R\ ) }

a
S ⊆  β ›– \
(S ·
a
α ›– )

≡	{ going pointwise }
a	a
∀veV,ueU . vS u → v ( β ›– \ (S · α ›– )) u
≡	{ pointwise definition of relational right division \ }
j	a	j	a	j
∀veV,ueU . vS u → (∀vjeV . v α ›– v → v ( β ›– · S ) u )
≡	{ pointwise definition of relational composition · }
j	a	j	a	j	j
∀veV,ueU . vS u → (∀vjeV . v α ›– v → (EujeU . u β ›– u ∧ v Su ))
which, in conjunction with (14), is the well-known expression used to define bisim- ulation in classical process algebra (cf., [18,15]).
A useful result whose proof becomes almost trivial using formulation (16) is that the existence of a coalgebra morphism between two coalgebras relates by a bisimulation the pairs of states it connects. Formally,
Lemma 3.6 The graph of a morphism h : β ›– α between coalgebras α and β is a bisimulation.
Proof. As a coalgebra morphism connecting α and β, h verifies inequations (10) and (11). The latter is equivalent to the second conjunct in (16). A similar corre- spondence holds between the first conjunct and (10):

h · α ›– ⊆  β
›a– · h

≡	{ law (4) }
a	◦	a
α ›– ⊆ h · β ›– · h
≡	{ converse is monotonic }

(	a	◦
◦	a	◦

α ›– )
⊆ (h · β ›– · h)

≡	{ converse definition }
a	◦	a
–→α ⊆ h · –→β · h
≡	{ law (4) }

h · –→a
α ⊆ –→β · h
□


Weak Bisimulation
Observational Reduction and Weak Bisimulations
Weak notions of equivalence, which abstract away specific subsets of actions consid- ered internal or non observable, have a fundamental role in process calculi. However

they are difficult to capture directly in a coalgebraic setting (but see [20], mentioned in section 5). In this section we approach a particular instance of the problem based on relational transposition. The starting point is the classical definition of weak bisimulation wrt a set Υ ⊆ A encoding internal actions. In Ccs, for example,
Υ = {τ}.
Definition 4.1 Given α ›– : A × U ›– U e β ›– : A × V ›– V over A and a subset Υ ⊆ A of non observable actions, a weak simulation of α ›– in β ›– is a relation S : V ›– U such that
j	a	j	a	j	j

∀ueU,veV . vS u → ∀aeA–Υ∀ujeU . u
α →= u → (EvjeV . v
β →= v ∧ v Su ) ∧

j	j	j	j
∀ujeU . u α →= u → (EvjeV . v β →= v ∧ v Su )

where
α →= is the union, for all τ e Υ, of the transitive, reflexive closure of
τ
α ›–
, denoted

by tr(
τ α ›–
). Relation
→a= is defined by abbreviation:

→a= a=bv
→= · ›a– · →=	(17)

for all a e A – Υ. A weak bisimulation is a weak simulation whose converse is still a weak simulation.
Clearly the union of all weak bisimulations, denoted by ≈, is a weak bisimulation and an equivalence relation. Our strategy consists of transforming each coalgebra α into another coalgebra ˆα such that a strict bisimulation over ˆα will correspond to
a weak one over the original α. Therefore, the standard procedure which seeks for a morphism to witness a bisimulation, remains valid once applied to ˆα, instead of α. The construction of ˆα is depicted in the following diagram:
α : k(A × U) ›– U 	e ·	  ›– : A × U ›– U



Formally,

ˆα : k(A × U) ›– U ¸, Λ	

α ~ : A
O
J 
× U ›– U

Definition 4.2 The observational reduction ˆα of a coalgebra α : k(A × U) ›– U, is defined by


where α ~
ˆα = Λ O (e · α) = Λ O ( α ›– ) = Λ α ~	(18)

(a, uj)	~ u	≡	uj	→a= u (if a g Υ)	(19)
(τ, uj) α ~ u	≡	uj α →= u (if τ e Υ)	(20)

Clearly, a weak bisimulation over two coalgebras coincides with a strict bisimulation between the corresponding observational reductions. By construction an observa-
tional reduction of γ encodes all of its γ →= and γ →= transitions. Therefore a morphism between them, which preserves and reflects transitions, entails a weak

bisimulation between the underlying coalgebras. Such a morphism is a coalgebra morphism, as shown in the previous section. Then, by lemma 3.6, it isa witness of a strict bisimulation between the corresponding observational reductions.
Example 4.3 Consider coalgebras α and β corresponding to transition systems:


α =	s1 ¸¸
a	 s2 
β =	t1   a  t2 

¸¸¸¸¸i
¸¸¸¸¸
zs3˛	a	 s4 ,¸j


For Υ = {i, j} their observable reductions are



ˆα  =


τ  s1¸¸¸
a
a	 s2 ,¸τ

ˆβ  =


τ ¸t1 , a  t2 ,¸τ


¸¸¸¸¸τ
¸¸¸¸
a
¸



Define a morphism h : {t1, t2} ›– {s1, s2, s3, s4} connecting states s1 and t1, initial in α and β, respectively, as follows: h s1 = h s3 = t1 and h s2 = h s4 = t2. The reader may easily check that ˆβ · h = k(id × h) · ˆα.
Example 4.4 As a second example, consider Ccs processes c · P and τ · τ · c · P, with τ standing for internal activity. The denotation of each process term P in the final coalgebra carrier is [P] e ν. The relevant fragments of ω are depicted as follows:


[c · nil] ¸τ,  [τ · c · nil] ¸τ,  [τ · τ · c · nil]
c
J 
nil]
[c · nil]
c
J 
nil]


The corresponding fragments in the observational reduction ωˆ of final coalgebra ω are:

τ



[c










τ
τ

]	[c · nil]
c
J 
nil]
τ


Morphism h : ωˆ ›– ˆω defined by h [τ · τ · c · nil] = h [τ · c · nil] = [c · nil] and as

the identity in all other elements of ν, establishes a strict bisimulation over ωˆ between the denotations of c · nil and τ · τ · c · nil. Therefore, c · nil ≈ τ · τ · c · nil.
The following lemma establishes that strict bisimilarity is contained in ≈.
Lemma 4.5 Any morphism h from α : k(Act × U) ›– U to β : k(Act × V) ›– V is also a morphism from ˆα to ˆβ.
Proof. Let h be such that β · h = k(id × h) · α. We show that ˆβ · h = k(id × h) · ˆα as follows
ˆβ · h = k(id × h) · ˆα
≡	{ definition 4.2 }
Λ · β ~ · h = k(id × h) · Λ · α ~
≡	{ Λ( f · R) = k f · ΛR }
Λ · β ~ · h = Λ · (id × h) · α ~
≡	{ Λ is an isomorphism }
β ~ ·h = (id × h) · α ~
a	a
To prove this last equality, let a g Υ and check that β ~ ·h = h · α ~ .
a  ·h
≡	{ definition of β ~ }
→= · ›a– · →= · h

≡	{
tr(
β →== tr(
τ
β ›– ) }
a	τ

β ›– ) · β ›– · tr( β ›– ) · h
≡	{ h : β ›– α is a morphism }

h · tr(
α ›– ) ·
›a– · tr(
α ›– )

≡	{ α
→== tr(
α ›– ) }

h ·	→= ·  ›a– ·  →=
≡	{ definition of β ~ }
h · α ~
□

Proving ≈-laws
Equipped with a suitable notion of weak bisimulation, which is moreover paramet- ric on a set of internal actions Υ, we may come back to our original motivation: rephrasing process algebras in a coalgebraic setting and reasoning coinductively in an equational style. The couple of examples in this section illustrate the kind of results we have in mind and the corresponding proof strategy.

Example 4.6 The first example is the law which in, Ccs, characterizes observational equivalence:
p ≈ τ · p	(21)
To show this we seek for a suitable morphism h : ωˆ ›– ωˆ. Let then
h(τ · p) = p  for all p e ν
h = id  otherwise
It remains to show that h, as defined, is actually a morphism, i.e., ˆω · h = k(id × h) · ωˆ
which, given the definition of h, reduces to ωˆ(τ · p) = ˆωp.
ωˆ(τ · p)
≡	{ definition 4.2 }
Λ ω ~ (τ · p)
≡	{ definition of ω ~ and transposition }
{(a, pj)| pj	→a= τ · p} ∪ {(τ, pj)| pj	→= τ · p}
≡	{ definition of ω →= }
{(a, pj)| pj	→a= p} ∪ {(τ, pj)| pj	→= p}
≡	{ definition of ω ~ and transposition }
Λ ω ~ p
≡	{ definition 4.2 }
ωˆ p
Example 4.7 Consider, now, the following conditional law:
p + q ≈ pj + qj	→  pj ≈ p ∧ qj ≈ q	(22)
Again we seek for a morphism h connecting the relevant terms such that
ωˆ · + · (h × h) = k(id × h) · ωˆ · +	(23)
This equation requires the definition of combinator + over ˆω. Recall that ω· + = ∪·(ω×ω), which, once combined with the definition of observable reduction in (18), leads to
ωˆ([p + q]) = ˆωp ∪ ˆωq ∪ {(τ, r)| r ω →= [p + q]}	(24)
Thus ˆω ([a · nil + b · nil]) = {(a, [nil]), (b, [nil]), (τ, [(a · nil + b · nil)])} whereas ωˆ([τ · a ·
nil + b · nil]) = {(a, [nil]), (b, [nil]), (τ, [(a · nil + b · nil)]), (τ, [a · nil])} although, as shown in the previous example, a · nil ≈ τ · a · nil. Therefore, equation (22) does not hold.



Example 4.8 Consider, finally, a congruence law for the interleaving combinator:
p  q ≈ pj  qj	→  pj ≈ p ∧ qj ≈ q	(25)

Suppose equivalences pj ≈ p and qj ≈ q are witnessed by morphisms f : ωˆ ›– ˆω and
g : ωˆ ›– ˆω, not necessarily coincidents. Define h : ν ›– ν such that

h ·  =  · ( f × g)	(26)

and is the identity in all other cases. Let us show that h is a morphism between the obser- vational reductions of ω, i.e.,

ωˆ · h = k(id × h) · ωˆ
(27)

Clearly, equation (27) holds for all arguments for which h is the identity. Therefore, the only case to be checked is the application to interleaving expressions (e.g., p q), reducing our task to prove
ˆω · h ·  = k(id × h) · ωˆ ·	(28)
By definition of h, ˆω · h ·  = ˆω ·  · ( f × g). But what can be said about term ωˆ · ? Note that diagram






generalizes to
ν,,
 
ν × ν
ω	 k( Act × ν)
,,
k(id× )
α	 k( Act × (ν × ν))

ν,,	ωˆ
 
αˆ
 k( Act × ν)
,,
k(id× )

ν × ν
	 k( Act × (ν × ν))

where αˆ = Λ	~ , just as ˆω = Λ ω ~ . Actually, by lemma 4.5, the latter diagram

is implied by the former. It is not difficult to find a direct definition for Λ α
~ : it is

enough to replace ω by ωˆ in the definition of α given in the end of section 2, and consider a τ-labelled transition from the pair of arguments to itself. For example, αˆ (τ · a · nil, b · nil)
is the union of singleton {(τ, ([τ · a · nil], [b · nil]))} with {(τ, ([a · nil], [b · nil])), (a, ([nil], [b ·
nil])), (b, ([a · nil], [nil]))}. Therefore,

ˆ =  ∪ · (α1 × α2)· a	(29)

where α1 = ∪ · (τr × τl) · ((ωˆ × id) × (id × ˆω)) · a and α2 = sing · labelτ. Now we check, for i = 1, 2, that

k(id ×  ) · αi · ( f × g) = k(id × h) · k(id ×  ) · αi	(30)

The case i = 1 is proved by

k(id ×  ) · α1 · ( f × g)
=	{ definition of α1 }
k(id × ) · ∪ · (τr × τl) · ((ωˆ × id) × (id × ˆω))· a ·( f × g)
=	{ a natural, × functor }
k(id × ) · ∪ · (τr × τl) · (((ωˆ · f ) × g) × ( f × (ωˆ · g)))· a
=	{ f and g are morphisms , × functor }
k(id × ) · ∪ · (τr × τl) · (((k(id × f ) × g) × ( f × k(id × g))) · ((ωˆ × id) × (id × ωˆ))· a
=	{ τr , τl and ∪ natural }
k(id × ) · k(id × ( f × g)) · ∪ · (τr × τl) · ((ωˆ × id) × (id × ˆω))· a
=	{ definition of α1 }
k(id ×  ) · k(id × ( f × g)) · α1
=	{ (26) }
k(id × h) · k(id ×  ) · α1
The proof of case i = 2 is similar. Finally, equation (28) is checked as follows,
ωˆ · h · 
=	{ (26) }
ωˆ ·  · ( f × g)
=		{  is a morphism for ωˆ } k(id ×  ) · αˆ · ( f × g)
=	{ definition of αˆ }
k(id ×  ) · ∪ · (α1 × α2)· a ·( f × g)
=	{ a and ∪ natural, × functor }
∪ · ((k(id ×  ) · α1 · ( f × g)) × (k(id ×  ) · α2 · ( f × g)))· a
=	{ both instances of equation (30) }
∪ · ((k(id × h) · k(id ×  ) · α1) × (k(id × h) · k(id ×  ) · α2))· a
=	{ ∪ natural }
k(id × h) · k(id ×  ) · ∪ · (α1 × α2)· a
=	{ definition of αˆ }
k(id × h) · k(id × ) · αˆ
=		{  is a morphism for ωˆ } k(id × h) · ωˆ · 


Conclusions and Future Work
Set as a simple exercise, this paper introduced a concrete notion of weak bisimula- tion for labelled transition systems, which is parametric on a definition of internal activity. As a ’by-product’, the paper illustrated how basic results in transition

systems theory admit intuitive and simple characterizations and proofs, when for- mulated in a pointfree style.
Lots of questions remain to be answered. The most proeminent asks to what extent this approach can be extended to broader classes of coalgebras. The quest for canonical ways of absracting from hidden transitions is still an open question in coalgebra research. Generalizing the approach sketeched here entails the need for new transposition operators possibly to categories different from Rel. A very simple case relates coalgebras for the maybe monad with a category of partial functions, but such is just a specialization of the case dealt in this paper. The interesting question would be to consider coalgebras expressing probabilistic behaviour or particular timing constraints, while retaining the simplicity and calculational flavour of our approach. Related work includes [19], which deals with Set functors for which a notion of natural accessor can be defined, and, more recently, [20]. The latter, rather generic although resorting to heavy (categorial) notation, is based on process traces factorised wrt a set of invisible actions. It should be stressed, however, that the motivation for this paper was somewhat different: we looked for a concrete notion of weak bisimulation to be used in effective and simple calculations with processes’ denotations.
Another question concerns the possible scalling up of this work to process alge- bras with mobility. However, we are still far from developing a coinductive, calcu- lational, account of the π-calculus [16] along the lines of [6], even if its (coalgebraic) semantics has already been tackled, at a foundational level, in e.g. [13,5]. We are currently working on this topic resorting to coalgebras over dependent types.

References
P. Aczel, Final universes of processes, Proc. Math. Foundations of Programming Semantics (Brooks et al, ed.), Springer Lect. Notes Comp. Sci. (802), 1993.
L. Alfaro, T. Henziger, and R. Jhala, Compositional methods for probabilistic systems, Proc. the 12th International Conference on Concurrency Theory, Springer Lect. Notes Comp. Sci. (2154), 2001,
pp. 351–365.
R. Backhouse, Galois connections and fixed point calculus, Algebraic and Coalgebraic Methods in the Mathematics of Program Constuction (R. Crole, R. Backhouse, and J. Gibbons, eds.), Springer Lect. Notes Comp. Sci. (2297), 2002, pp. 89–148.
R. C. Backhouse and P. F. Hoogendijk, Elements of a relational theory of datatypes, Formal Program Development (B. M¨oller, H. Partsch, and S. Schuman, eds.), Springer Lect. Notes Comp. Sci. (755), 1993, pp. 7–42.
M. Baldamus, Compositional constructor interpretation over coalgebraic models for the π-calculus, Proc. of CMCS’00 (H. Reichel, ed.), vol. 33, Elect. Notes in Theor. Comp. Sci., Elsevier, 2000.
L. S. Barbosa, Process calculi `a la Bird-Meertens, CMCS’01 (Genova), vol. 44.4, Elect. Notes in Theor. Comp. Sci., Elsevier, April 2001, pp. 47–66.
L. S. Barbosa and J. N. Oliveira, Coinductive interpreters for process calculi, Proc. of FLOPS’02, Springer Lect. Notes Comp. Sci. (2441), September 2002, pp. 183–197.
R. Bird and O. Moor, The algebra of programming, Series in Computer Science, Prentice-Hall International, 1997.
R. S. Bird and L. Meertens, Two exercises found in a book on algorithmics, Program Specification and Transformation (L. Meertens, ed.), North-Holland, 1987, pp. 451–458.


T. Hagino, A typed lambda calculus with categorical type constructors, Category Theory and Computer Science (D. H. Pitt, A. Poign´e, and D. E. Rydeheard, eds.), Springer Lect. Notes Comp. Sci. (283), 1987, pp. 140–157.
T. Henziger, Hybrid automata with finite bisimulations, Proc. the 22th Inter. Colloquium on Automata, Languages, and Programming (ICALP), Springer Lect. Notes Comp. Sci. (944), 1995, pp. 324–335.
K. Larsen and A. Skou, Bisimulation through probabilistic testing, Information and Computation (1991), no. 94, 1–28.
M. Lenisa, Themes in final semantics, Ph.D. thesis, Universita de Pisa-Udine, 1998.
E. Meijer, M. Fokkinga, and R. Paterson, Functional programming with bananas, lenses, envelopes and barbed wire, Proceedings of the 1991 ACM Conference on Functional Programming Languages and Computer Architecture (J. Hughes, ed.), Springer Lect. Notes Comp. Sci. (523), 1991, pp. 124–144.
R. Milner, Communication and concurrency, Series in Computer Science, Prentice-Hall International, 1989.
R. Milner, J. Parrow, and D. Walker, A calculus of mobile processes (parts I and II), Information and Computation 100 (1992), no. 1, 1–77.
J. N. Oliveira and C. J. Rodrigues, Transposing relations: From Maybe functions to hash tables, 7th International Conference on Mathematics of Program Construction (D. Kozen, ed.), Springer Lect. Notes Comp. Sci. (3125), July 2004, pp. 334–356.
D. Park, Concurrency and automata on infinite sequences, Springer Lect. Notes Comp. Sci. (104), 1981,
pp. 561–572.
J. Rothe and D. Masulovic, Towards weak bisimulation for coalgebras, Proc. Int. Workshop on Categorical Methods for Concurrency, Interaction, and Mobility (CMCIM’02) (A. Kurz, ed.), vol. 68, Elect. Notes in Theor. Comp. Sci., Elsevier, 2002.
A. Sokolova, E. de Vink, and H. Woracek, Weak bisimulation for action-type coalgebras, Proc. Int. Conf. on Category Theory and Computer Science (CTCS’04) (L. Birkedal, ed.), vol. 122, Elect. Notes in Theor. Comp. Sci., Elsevier, 2005, pp. 211–228.
