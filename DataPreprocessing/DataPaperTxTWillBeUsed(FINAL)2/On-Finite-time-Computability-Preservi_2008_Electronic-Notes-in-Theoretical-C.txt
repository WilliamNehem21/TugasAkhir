

Electronic Notes in Theoretical Computer Science 221 (2008) 299–308
www.elsevier.com/locate/entcs

On Finite-time Computability Preserving Conversions
Hideki Tsuiki1 ,2
Graduate School of Human and Environmental Studies Kyoto University
606-8501 Kyoto, Japan
Shuji Yamada3
Faculty of Science Kyoto Sangyo University 603-8555 Kyoto, Japan

Abstract
A finite-time computable function is a partial function from Σω to Σω whose value is constructed by applying
finite number of list operations ’cons’ωand ’head’ to the argument. A finite-time computability preserving
conversion α : X → Y for X, Y ⊂ Σ is a bijection which preserves finite-timωe computability. We show
that all the finite-time computability preserving conversions with the domain Σ are extended sliding block functions.
Keywords: Finite-time Computable Functions, Constant-time Computable Functions, Sliding Block Functions, Computable Analysis, Domain Theoryx.


Introduction

through a representation ϕ :⊂ Σω → A and a Type2 machine, which inputs and In Type2 theory of effectivity [6], computability of a function on a space A is defined outputs Σω sequences and defines the notion of computable functions on Σω. One
way of implementing infinite sequences in ’real’ programming languages is (lazy) infinite lists, and one can write computable functions on Σω with programming languages which support lazy lists, such as Haskell and ML.

1 The first author was partially supported by the Grant-in-Aid for Scientific Research (No.18500013 and No.19650029) from Japan Society for the Promotion of Science.
2 Email:tsuiki@i.h.kyoto-u.ac.jp
3 Email:yamada@cc.kyoto-su.ac.jp

1571-0661© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.025



4	4
3	3
2	2



1	1







0	0


0	0.25
0.5
0.75
1.0	0
0.25
0.5
0.75
1.0


Fig. 1. The Binary representation and Gray representation of [0, 1]. Here, line segments mean the corre- sponding digit is 1, and otherwise 0.

In such an implementation, the output infinite list is constructed from the input infinite list. In many cases, the whole output list is constructed with infinite number of cons operations. However, one can also construct the output list by applying finite number of list operations tail and cons to the argument. In other words, the output infinite list is constructed by concatenating a finite list and a suffix of the input, both of which are computed from the input infinite list. In this case, one can construct the output infinite list in a finite time when the input infinite list is given.
When a representation ϕ :⊂ Σω → A is given, we define a finite-time computable Therefore, we call such a partial function on Σω a finite-time computable function. (multi-valued partial) function on a set A as one which is realized by a finite-time
computable partial function on Σω.
tation to use. For example, on the closed unit interval I = [0, 1] and Σ = {0, 1}, we Note that the class of finite-time computable functions depends on the represen- consider, in addition to the binary representation δB : Σω → I, the Gray represen- tation δG : Σω → I [5]. It is the continuous function which satisfies the following,
δG(0 · x) = δG(x)/2, δG(1 · x) = 1 − δG(x)/2.
Note that the binary representation δB satisfies
δB(0 · x) = δB(x)/2,
δB(1 · x) = 1/2+ δB(x)/2.
Figure 1 shows the binary representation and the Gray representation. Gray rep-
resentation is based on binary reflected Gray-code, which is a coding of natural numbers different from the ordinary binary code [3].
The two representations have the relation
δB = δG ◦ G	(1)

for G : Σω → Σω the Gray-code conversion function defined as G(x)n = xn ⊕ xn−1. Here, a⊕b is the exclusive-OR of a and b, xn is the n-th digit of x, and x−1 is defined to be 0. In Section 2, some examples of finite-time computable functions with re-
spect to these representations are given. As we will show, a finite-time computable functions with respect to binary representation is finite-time computable with re- spect to Gray representation, but not vice versa. More generally, if ϕ and ϕ' are two representations of a set and ϕ' is the composition of ϕ with G as (1), then all the finite-time computable functions with respect to ϕ' are finite-time computable with respect to ϕ. Therefore, we can consider it a property of the conversion function G,
and we define that a computable conversion function α : X → Y for X, Y ⊂ Σω is finite-time computability preserving if α ◦ f ◦ α−1 is finite-time computable for any finite-time computable partial function f . Gray-code conversion is a special case
of a sliding block function [1]. In this paper, we will define a more general class of functions, called extended sliding block functions for the case X = Σω.
With this preparation, we show our main theorem. It says that all the finite- time computability preserving conversions from Σω to Y are extended sliding block functions. We first show that, in this case, a finite-time computability preserving conversion satisfies some recursive equation and it coincides with the minimal fixed- point. Then, we show that it is an extended sliding block function.
One of the properties of a finite-time computability preserving conversion is that it preserves suffix identity in that if two arguments have the same suffix then their values also have the same suffix. However, not all suffix-identity preserving conversions are finite-time computability preserving, and our main theorem does not hold for suffix-identity preserving conversions from Σω. The important thing about finite-time computability is that the shared suffix between x and f (x), which exists from the definition of finite-time computability, should be computable from x.
We introduce finite-time computable functions with some examples in Section 2, and finite-time computability preserving conversions in Section 3. Then, in Section 4, we concentrate on the case X = Σω and show our main theorem. In Section 5, we show relations between finite-time computability preserving and suffix-identity preserving conversions.
Notation and Terminology:

Let Σ be a finite alphabet. For a cardinal number c ≤ ω, we denote by Σc the Σ of finite length, and by Σ∞ the set Σ∗ ∪ Σω. We denote by |x| the length of a set of sequences on Σ of length c. We also denote by Σ∗ the set of sequences on sequence x and denote by ε the empty sequence.
For a finite or infinite sequence x = {xi}0≤i<c (c ≤ ω), we denote by x ↑m the sequence {xi}m≤i<c obtained by discarding the first m digits (elements) of x and denote by x ↑n the sequence {xi}0≤i<n obtained by extracting the first n digits of
x. We define x ↑m to be the empty sequence ε if |x|≤ m and x ↑n to be x if |x|≤ n.
We denote by x ↑n the sequence (x ↑n) ↑m= {xi}m≤i<n. We also denote by x ↑∗ the
set {x ↑n | n ∈ N} and denote by x ↑∗ the set {x ↑n | n ∈ N}. We call an element of
x ↑∗ a prefix of x and an element of x ↑∗ a suffix of x. On Σ∞, we define the order

relation x ≤ y if x ∈ y ↑∗ or x = y.
For u ∈ Σ∗ and v ∈ Σ∞, we denote by u · v the concatenated sequence of u and
v. For a letter a ∈ Σ and a sequence x, we also denote by a · x the sequence obtained by prepending a to x. For finite sequences x(0), x(1),... , x(n) ∈ Σ∗, we denote by 0≤i≤n x(i) the concatenated sequence x(0) · x(1)   x(n).
is a Type2 machine M which outputs f (x) when x ∈ dom(f ) is given as the input. When f is a partial function from Σω to Σω, we say that f is computable if there It is well known that computable functions on Σω are continuous. Note that we do
not require f to be strong, that is, dom(f ) may be a proper subset of dom(M ). We also define computable functions from Σω to Σ∗, and from Σω to N similarly. For
X, Y ⊂ Σω, we call a bijection from X to Y a conversion function.
Finite-time Computable Functions

Definition 2.1 We say that a partial function f :⊆ Σω → Σω is finite-time com- putable if there are computable partial functions g :⊆ Σω → Σ∗ and μ :⊆ Σω → N such that

for x ∈ dom(f ).
f (x)= g(x) · x ↑μ(x)

Definition 2.2 We say that a partial function f :⊆ Σω → Σω is constant-time computable if f is finite-time computable and there is a k ∈ N such that the values x ↑k for all x ∈ dom(f ). That is, x ↑k= y ↑k implies g(x)= g(y) and μ(x)= μ(y). of g(x) and μ(x) in the definition of finite-time computability of f depend only on
Proposition 2.3 A ﬁnite-time computable function is a computable function.
Proposition 2.4 If dom(f ) is compact, then any ﬁnite-time computable function on X is constant-time computable.
When a representation ϕA :⊆ Σω → A is given, we can define finite-time com- putability of a function on A.
Definition 2.5 Let ϕ : Σω → A be a representation of A. We say that a partial multi-valued function F :⊆ A ⇒ A is finite-time computable with respect to ϕ when F is realized by a finite-time computable partial function f :⊆ Σω → Σω. That is, ϕ(f (x)) ∈ F (ϕ(x)) for every x ∈ Σω.
We also define constant-time computable partial multi-valued function F : A ⇒
A, similarly.
Note 1 We can generally deﬁne ﬁnite-time computability for multi-valued functions with the domain and the range different. We have this deﬁnition because we are only interested in the case they are the same in this paper.
Example 2.6 Let Σ = {0, 1}, I = [0, 1] be the closed unit interval, and δB :
Σω → I be the binary representation of I. That is, δB(x) = Σ∞ xn/2n+1. Then,
computable with fi : Σω → Σω the function which realizes Fi (i = 1, 2, 3). the following (multi-valued) functions Fi : I ⇒ I (i = 1, 2, 3) are constant time

F1(a)= a/2.
f1(x)=0 · x.
F (a)= ⎧⎨ 2a	if 0 ≤ a ≤ 1/2,
2a − 1	if 1/2 ≤ a ≤ 1. f2(x)= x ↑1.
F (a)= ⎧⎨ a + 1/2	if 0 ≤ a ≤ 1/2,
⎧⎩ a − 1/2	if 1/2 ≤ a ≤ 1.
3
⎩ 0 · x ↑1	if x0 = 1.
Example 2.7 Let Σ = {0, 1, ’.’}, X = {x ∈ Σω | x contains one ’.’}, and δ' :⊆
Σω → R+ be the binary representation of the set R+ of non-negative real numbers.
That is, dom(δ' ) = X and δ' (x) = δB(x ↑k ·x ↑k+1)2k for k the index of ’.’ in x.
B	B
Then, F4 : R+ → R+ defined as F4(a)= 2a is finite-time computable, with its code the function f4 : X → X defined recursively as follows,
f4(c · x)= c · f4(x)	(for c ∈ {0, 1}), 
f4(. · c · x)= c · . · x	(for c ∈ {0, 1}). 
Example 2.8 Let Σ = {0, 1}, δG : Σω → I be the Gray representation defined in
Section 1. We can extend it to the representation δ' : X → R+ of R+ for X the set
defined in Example 2.7, as we did for the binary representation. As we will show in
the next section, all the finite-time computable and constant-time computable func-

tions with respect to δB and δ'
belong to the same class of functions with respect

to δG and δ' , respectively. For example, F1 is realized by f1 and F2 is realized by
⎧ x ↑1	if x0 = 0,
f5(x)=	0 · x ↑2	if x0 =1 and x1 = 1.
⎪⎪⎩ 1 · x ↑2	if x0 =1 and x1 = 0.
In addition to them, there are functions finite-time computable with respect to δG
but not with respect to δB. For example, the following functions F6 and F7 are constant-time computable with respect to δG with f2 and f3 the functions which realize them, respectively.
F (a)= ⎧⎨ 2a	if 0 ≤ a ≤ 1/2,
⎩ 2 − 2a	if 1/2 ≤ a ≤ 1.
F7(a)=1 − a.

However, F6 and F7 are not finite-time computable with respect to δB.

Finite-time computability preserving conversion

Let the Gray-code conversion G : Σω → Σω be the function defined as G(x)n = xn ⊕ xn−1. Here, a ⊕ b is the exclusive-OR of a and b, and x−1 is defined to be 0. Then, the two representations δG and δB have the relation:
δB = δG ◦ G.
Definition 3.1 Let X and Y be subsets of Σω. We say that a bijection α : X → Y is a finite-time computability preserving conversion if α is computable and α◦f ◦α−1 is finite-time computable for all finite-time computable partial function f :⊆ Σω → Σω, whose domain and range are subsets of X.
Proposition 3.2 Let X and Y be subsets of Σω, α : X → Y be a ﬁnite-time computability preserving conversion and ϕ :⊆ Σω → A be a representation of a set A with dom(ϕ) = Y . If a partial multi-valued function f :⊆ A ⇒ A is ﬁnite-time computable with respect to ϕ ◦ α, then it is ﬁnite-time computable with respect to ϕ.
For integers k, m ≥ 0 and a function B : Σk+m+1 → Σ, we define a sliding block function α : Σω → Σω as α(x)n = B(xn−k,... , xn+m). Here, we assume that xn function for k = 1,m = 0,B : Σ2 → Σ the exclusive-OR function, and x−1 = 0. is defined to be some constant for n < 0. Gray-code conversion is a sliding block
More generally, we define an extended sliding block function as follows.
Definition 3.3 Let Y be a subset of Σω. We say that a function α : Σω → Y is an λ : Σω  → Σ∗, ρ : Σn  → Σ∗, and s : Σω  → N  such that extended sliding block function if there are an interger n and computable functions

α(x)= λ(x)·ρ(x ↑s(x)+n)·ρ(x ↑s(x)+1+n)·ρ(x ↑s(x)+2+n)	= λ(x)·	 
ρ(x ↑i+n).

s(x)
s(x)+1
s(x)+2
i
s(x)≤i<ω

Proposition 3.4 Any extended sliding block bijection preserves ﬁnite-time com- putability.

Corollary 3.5 (1) A sliding block bijection preserves ﬁnite-time computability.
Gray-code conversion preserves ﬁnite-time computability.
Every ﬁnite-time computable function with respect to the binary representation is ﬁnite-time computable with respect to the Gray representation.

Characterization of Finite-time Computability Pre- serving Conversions from Σω
In this section, we show the converse of Proposition 3.4 as our main theorem.

Theorem 4.1 If α : Σω → Y is a ﬁnite-time computability preserving conversion, then α is an extended sliding block function.
To prove this theorem, we need some lemmata. Let α : Σω → Σω be a finite-time computability preserving conversion.
For a letter a ∈ Σ, let pa : Σω → Σω be the function which prepends the letter a to sequences, that is, pa(x) = a · x. This prepending function pa is a typical finite-time computable function on Σω.
Lemma 4.2 There are an integer n and computable functions g : Σn → Σ∗ and
μ : Σn → N such that the following recursive formula holds.
α(x)= g(x ↑n) · α(x ↑1) ↑μ(x↑n ) .	(2) Proof. Since α ◦ pa ◦ α−1 is a finite-time computable function, it must have the form ga(x)· x ↑μa (x) for computable functions ga : Σω → Σ∗ and μa : Σω → N. Thus,
we have
α(a · x)= ga(α(x)) · α(x) ↑μa (α(x)) .
We define computable functions g : Σω → Σ∗ and μ : Σω → N by
g(x)= gx0 (α(x ↑1)),
μ(x)= μx0 (α(x ↑1)).
Then, α must satisfy
α(x)= α(x0 · x ↑1)= g(x) · α(x ↑1) ↑μ(x) .
the values of g(x) and μ(x) are defined by x ↑n and we can regard the domain of Since Σω is compact and g and μ are computable, there is an integer n such that these functions as Σn.	 
Note that (2) is a recursive equation that α must satisfy.
We introduce a new letter H which does not belong to Σ. We call this letter H
θ : (Σ ∪ {H})∞ → Σ∞ is applied. We first define θ : (Σ ∪ {H})∗ → Σ∗ on finite a “hole” which cancels the succeeding ordinary letter when the following function sequences. For any sequence x ∈ (Σ ∪ {H})∗,
⎧ x0 · θ(x ↑1)	if x0 ∈ Σ, θ(x)=	θ(x ↑1) ↑1		if x0 = H,
⎪⎪⎩ ε	if x = ε.
It can be easily checked that θ is monotonic. That is, for x ∈ (Σ ∪ {H})∗ and an
'
integer m, there is a integer m' such that, θ(x ↑m) = θ(x) ↑m . Therefore, we can
extend this function to the function θ : (Σ ∪ {H})∞ → Σ∞ as
θ(x) = lim θ(x ↑m)
m→ω

for x ∈ (Σ ∪ {H})ω .
We define functions α' : Σω → (Σ ∪ {H})ω and α'
: Σj+n → (Σ ∪ {H})∗ for an

integer j by
α'(x)= 
0≤i<ω
α' (x)= 
0≤i<j
g(x ↑i+n) · H g(x ↑i+n) · H

i n
μ(x↑i	),


i n
μ(x↑i	).

We also extend α' to a function from Σω to (Σ ∪ {H})∗ as α' (x)= α' (x ↑j+n).
j	j	j
Then, from the definition, α' satisfies the following recursive formula
α'(x)= g(x ↑n) · Hμ(x↑n ) · α'(x ↑ ).
If we apply θ to this formula, we have
θ(α'(x)) = g(x ↑n) · θ(α'(x ↑1)) ↑μ(x↑n ) .
This recursive formula of θ ◦ α' is the same as the one (2) of α. In addition, from the construction of θ and α', θ ◦ α' is the least fixed-point of the recursive equation
(2) on the domain [Σω → Σ∞], and therefore θ(α'(x)) ≤ α(x) for any function
α ∈ [Σω → Σ∞] which satisfies the equation (2). For the details of domain theory, see [2] and [4], for example.
Now, we prove that |θ(α'(x))| = ω for any x ∈ Σω, and therefore it is the only output is determined by some interval x ↑i+n of length n and the intervals overlap fixed-point of (2). One of the difficulties in handling α'(x) is that each digit of the
for each i. Therefore, we pick up indexes k1,... , kn,... for which x ↑ki+n are the
same. Such a sequence k1,... , kn,... exists because |Σn| is finite.
Lemma 4.3 If x ↑k+n= x ↑k' +n for x ∈ Σω and integers k < k', then

k	k'
Σ
(|g(x ↑i+n)|− μ(x ↑i+n)) > 0.

i	i
k≤i<k'
We skip the proof of this lemma. Note that it uses the fact that α is an injective function.
Lemma 4.4 For any x ∈ Σω,
lim |θ(α'(x))| = ω.
i→ω	i
Therefore, we have the following.
Lemma 4.5 θ ◦ α' = α.
Next, we show that θ ◦α' is an extended sliding block function. Set N = |Σ|n and
M = maxw∈Σn μ(w). Since θ(α' (x)) is monotonic to j and limi→ω |θ(α'(x))| = ω,

j
we have j0, j1,... such that θ(α'
i
(x)) > θ(α' (x)). In the following lemma, we

show that such ji appear in every interval of length MN 2.

Lemma 4.6 For any x ∈ Σω and any integer j ∈ N, |θ(α' (x))| < |θ(α'
2 (x))|.

j	j+MN 
We define functions λ : Σω → Σ∗, ρ : ΣMN2 +n+1 → Σ∗, and s : Σω → N as follows:
λ(x)= θ(α'	2 (x)),
MN 

ρ(x)= θ(α'	2	(x)) ↑|θ(α'
(x))|,

MN +1
s(x)= 0.
MN2

We will accomplish the proof of the theorem with the following lemma.
Lemma 4.7

α(x)= λ(x) ·	 
s(x)≤i<ω
ρ(x ↑i+MN 2+n+1).

Corollary 4.8 Every extended sliding block function can be expressed as

α(x)= λ(x) · 
0≤i<ω
ρ(x ↑i+n).

Suffix Identity Preserving Conversions

are integers m and n such that x ↑m= y ↑n. We write x ∼ y when x and y share a Definition 5.1 We say that two infinite sequences x and y share a suffix if there suffix. We say that a partial function f :⊆ Σω → Σω is suffix-identical if x and f (x) share a suffix for all x ∈ dom(f ).
the form g(x) · x ↑μ(x) for partial functions g :⊆ Σω → Σ∗ and μ :⊆ Σω → N. The From the definition, a partial function f is suffix-identical if and only if f (x) has difference between a suffix-identical function and a finite-time computable function
is that g and μ are required to be computable in the latter case.
A finite-time computable function is obviously suffix-identical. However, the converse is not true, as we will see in Example 5.4.
Definition 5.2 For X, Y ⊂ Σω, we say that a conversion α from X to Y preserves suffix identities if α(z) and α(w) share a suffix for any z, w ∈ X which share a suffix.
Since ∼ is an equivalence relation, we consider the quotient Σω/ ∼. A suffix identity preserving conversion α determines a function from Σω/ ∼ to Σω/ ∼.
Proposition 5.3 A ﬁnite-time computability preserving conversion preserves suffix identities.
On the other hand, not all suffix identities preserving conversions are finite-time computability preserving.
Example 5.4 For n > 0, we denote z(n) =  1≤i≤n 1i0 = 10120130 ··· 1n−101n0 and z(ω)=  1≤i 1i0 = 10120130 ··· 1n−101n0 .. ., and define a function β : Σ∗ → Σ∗

by
β(0m0 1n0 0m1 1n1 ··· 0mk 1nk )= 0m0 z(n0)0m1 z(n1) ··· 0mk z(nk),
where n0,... , nk−1, m1,... , mk > 0 and nk, m0 ≥ 0. Since β(x ↑n) is a prefix of β(x) for any n ∈ N and x ∈ Σ∗, we can extend β to β : Σω → Σω. Let Y = range(β). The conversion β : Σω → Y preserves suffix identities. That is, when x ↑n= y ↑m, β(x) ↑k= β(z) ↑l for some k and l. Note that we need to study separately the case x contains finite number of 0, in which case β(1ω )= z(ω) is a suffix of x. On the
p1(x)= 1 · x. It is a finite-time computable function. Let h = β ◦ p1 ◦ β−1 : Y → Y . other hand, β is not finite-time computability preserving. Consider the function h satisfies the followings.

h(0 · x)	= 1 · 0 · 0 · x, h(z(n) · 0 · x) = z(n + 1) · 0 · x,
h(z(ω))	= z(ω).

One can consider these equations as a procedure to compute h, and thus h is a computable function. One can see that h is a suffix-identical function.
g(y) · y ↑μ(y) for g :⊆ Y → Σ∗ and μ :⊆ Y → N computable functions. We have However, h is not a finite-time computable function. Suppose that h(y) = μ(z(n) · 0 · x) ≥ |z(n)|− n − 1, and limn→ω μ(z(n) · 0 · x)= ω. On the other hand, limn→ω z(n) · 0 · x is z(ω) and μ(z(ω)) must have a finite value. Therefore, μ is not continuous, and therefore it is not computable.
Since dom(β) = Σω, this example also shows that our main theorem does not hold for suffix-identity preserving conversions.

References
Douglas A. Lind and Brian Marcus. An Introduction to Symbolic Dynamics and Coding. Cambridge University Press, Cambridge, 1995.
G. Gieez, K. H. Hofmann, K. Keimel, J. D. Lawson, M. Mislove and D. S. Scott. Continuous lattices and domains. Cambridge Univ. Press, Cambridge, 2003.
F. Gray. Pulse code communications. U. S. Patent 2632058, March 1953.
Viggo Stoltenberg-Hansen, Ingrid Lindstrom and Edward R. Griffor. Mathematical theory of domains.
Cambridge University Press, 1994.
Hideki Tsuiki. Real number computation through gray code embedding. Theoretical Computer Science, 284(2):467–485, 2002.
Klaus Weihrauch. Computable analysis, an Introduction. Springer-Verlag, Berlin, 2000.
