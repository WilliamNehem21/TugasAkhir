Electronic Notes in Theoretical Computer Science 45 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume45.html 13 pages


Regular-Language Semantics for a Call-by-Value Programming Language

Dan R. Ghica 1,2
Department of Computing and Information Science, Queen’s University, Kingston,
Ontario, Canada K7L 3N6


Abstract
We explain how game semantics can be used to reason about term equivalence in a finitary imperative first order language with arrays. For this language, the game- semantic interpretation of types and terms is fully characterized by their sets of complete plays. Because these sets are regular over the alphabet of moves, they are representable by (extended) regular expressions. The formal apparatus of game semantics is greatly simplified but the good theoretical properties of the model are preserved. The principal advantage of this approach is that it is mathematically elementary, while fully formalized. Since language equivalence for regular languages is decidable, this method of proving term equivalence is suitable for automation.


Introduction
In the last decade the use of game semantics in the analysis of programming languages has yielded numerous remarkable theoretical results. Most impor- tantly, this innovative approach led to fully abstract models for languages that have been under semantic scrutiny for decades, such as PCF [10,2] and idealized Algol [4,6]. The theoretical success of game semantics is well com- plemented by an elegantly articulated and intuitive conceptual association between key language features (such as mutable state or control) and neat combinatorial constraints on strategies (such as innocence or bracketing )[3].
There is, however, a frustrating aspect of game semantics. While the mod- els proposed are fully abstract, which means that in principle they correctly validate all program equivalences and inequivalences, they are at the same time so intricate that applying them to that end is often a Gordian task. What is needed is an adequate notation that would allow a calculus of games,

1 This author acknowledges the support of a NSERC PGSB grant.
2 Email: ghica@cs.queensu.ca
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


to make proofs less prolix and more formal. While a wieldy and accessible calculus that captures the full power of games may be unattainable, calculi for restricted yet non-trivial subsets of game-based models are very handy. They illustrate the game semantics in an applied setting, making the subject more accessible to those who find its abstractness daunting. But, more impor- tantly, such calculi can actually serve as a foundation for a new and practical approach to program analysis, predicated on solid theoretical results. A simi- lar avenue of research, but as applied to static analysis, is explored by Hankin and Malacaria [8,9].
In a previous paper [7] we showed how a greatly simplified games model of idealized Algol can be used to give elementary proofs to semantically relevant putative equivalences that have been an important part of the study of the language [12]. This paper follows a similar approach, but focuses on a different language, an imperative call-by-value first order language with arrays. This language is important from a practical point of view; it is the idiom in which many common programs, for example for searching or sorting, are written. For this language we present what we believe to be a practicable semantic cal- culus which can be used for validating term (subprogram) equivalences. Since equivalent subprograms can be replaced in any context, without restrictions, the technique presented here can be applied to both program development through refinement and to program maintenance. We are optimistic about the practical application of such a technique because it is mathematically ele- mentary and calculational, both features considered essential requirements for a “popular semantics” [15]. Moreover, this calculus is fully formal. Because it is based on regular expressions, language equivalence is decidable, which makes it suitable for automation.

Foil: a first order imperative language
In this paper we are concerned with a simple, prototypical, programming language that can be found at the core of most of today’s imperative lan- guages. It combines the features of the simple imperative language (mutable local variables, control structures) with a recursion-free first-order procedure mechanism based on the simply typed call-by-value lambda calculus, and an elementary data structure facility (arrays). The data sets of Foil are finite, as is the case with realistic programming languages. The decision to set aside higher order procedures and recursion is dictated by the need to confine the formalism to regular expressions only; they are not expressive enough to rep- resent these more powerful features. Another restriction is to allow only un- curried functions, but this is only for the sake of simplicity of presentation. Curried functions can be readily added and explicated within the bounds of the same formalism.
Foil has three kinds of types: return types, argument types and function types. The return types are the most elementary, and can be returned by

functions. They are the “values” of the language: booleans, naturals and a type of commands, void, similar to that in C or Java.
τ ::= bool | nat | void.
The argument types include the return types plus all the other types that can be passed as arguments to functions, which are variables, arrays and tuples:
σ ::= τ | var | array[n] | σ × σ,	n ∈ N.
The types above and function types, from argument to return types, form the type system of the language:
θ ::= σ | σ → τ.
The terms of the language are associated with typing judgments of the form:
ι1 : θ1, ι2 : θ2,..., ιk : θk ▶ M : θ,
where ιi are free variables.
The terms of the language are constants, operators, free variables, control structures, command composition, variable declaration, array declaration, ar- ray element selection, assignment, dereferencing and function declaration and application (Figure 1).


Game semantics of
Foil

The reader is not expected to be familiar with game semantics in order to understand this article. Also, it is not possible to condense such a rich topic in a few pages, but good and comprehensive introductory material is available [3]. The specific games model used to interpret Foil and on which we base the present regular language model is the one developed by Abramsky and McCusker [5,1]. In this section we will only introduce some of the key intuitive concepts of game semantics, especially as applied to call-by-value games.
The concept of game employed by game semantics is a broad one: “an activity conducted according to prescribed rules.” Computation is represented as a dialogical game between two protagonists: Player (P) represents the program and Opponent (O) represents the environment, or the context, in which the program is run. The interaction between O and P consists of a sequence of moves, governed by rules. For example, O and P need to take turns and every move needs to be justiﬁed by a preceding move. The moves are of two kinds, questions and answers; one of the rules constraining the interplay is that every answer must correspond to the last unanswered question (bracketing ).
To every type in the language corresponds a game; that is, the set of all possible sequences of moves, together with the way in which they are



Fig. 1. Terms and typing judgments

justified within the sequence. A program is represented as a set of sequences of moves in the appropriate game, more precisely as a strategy for that game: a predetermined way for P to respond to O’s moves. The semantic models which provide full abstraction for call-by-name languages are developed within this general games framework.
In an influential paper, Moggi showed that call-by-value languages are in- terpreted in a Cartesian Closed Category (CCC) with coproducts and a strong monad [13]. If a CCC has infinite co-products then its free completion under co-product produces the required monadic structure. The games framework forms indeed a CCC, with games as objects and strategies as morphisms, and McCusker showed how co-product games can be added [11]. These two ideas are incorporated in [5] to create a category of games suitable for inter- preting call-by-value languages. Arriving at the concrete call-by-value games presented here is only a matter of carrying out in enough detail the categorical construction.
The resulting games are, however, interesting in their own right because they offer some basic insight into call-by-value computation. A type is not

represented by a game, but by a family of games. A strategy interpreting a term has two distinct stages, a protocol stage in which one of the members of the family is selected, followed by a play in the selected game. Intuitively, this mirrors the fact that, in call-by-value, all arguments are evaluated exactly once before the body of the function is evaluated. Accordingly, free identifiers can have only one value throughout the evaluation of a term. In contrast, call- by-name allows identifiers to correspond to different values at various points in the evaluation.
This point is illustrated by the following example: f : nat → nat, x: nat ▶
f(x) : nat. For call-by-name a typical play is:
f: nat → nat	x: nat	▶	f(x) : nat
q
q
q
q n
n q
q n'
n'
m
m

O asks for the value of f(x); P asks for the value returned by f; O asks for the argument of f; P asks for the value of x; O answers n; P relays that answer back to O; O asks again for the argument of f and the same cycle repeats; O answers with m to the value returned by f; P relays that answer back to O, answering the initial question. Notice that in the course of the play the value of x can be requested several times, and since the answer is given by O it may change. Now let us look at the same term evaluated under call-by-value:
f: nat → nat	x: nat	▶	f(x) : nat
?


?(n)
m
?
n
?(n)

m

The moves under the ▶ symbol are not part of the play, but they are some of the concealed activities that are part of the protocol. The play is: O asks for the value of f(x); as a result of the protocol, P asks for the value of f in component n; O answers m; P relays the answer back, answering the initial question. Only part of the protocol is shown: P asks in what component should

the play proceed; O answers with a component index n for x; P requests that the game should continue in component n.
In [5] it was shown that this games framework gives a fully abstract model for call-by-value. Moreover, by relaxing one of the constraints on strategies (innocence) the same article shows how a fully abstract model for an imper- ative language with ML-style data references can be defined, using a good- variable non-innocent strategy to model mutable store. These ideas are fur- ther expanded in [1] to show that dropping another constraint on strategies (visibility ) gives rise to a fully abstract model for general references (references to data, procedures, higher order functions, other references).
Regular language semantics of types
A game for a type, or a strategy for a term, is fully characterized by its set of plays together with the way moves are justified. But if the language is sufficiently restricted then there is only one way in which moves can be justified within a play sequence—Foil is such a restricted language. This means that such languages can be fully characterized by plays taken to be sequences of moves only. Moreover, the sequences of moves are regular sets, so they can be denoted by (extended) regular expressions. This is an approach we took before, in dealing with Algol [7]. For the restricted language, extended regular expressions give a convenient, compact, fully formal calculus, quite handy in defining the semantics of actual programs. The regular-language semantics arises out of the model in [5], by working out the details of the categorical construction.
Definition 4.1 The set RA of extended regular expressions R over a ﬁnite alphabet A is deﬁned as:
R ::= ∅| ϵ | a,  a ∈A   Constants, R ::= R · R | R + R | R ∩ R Operators, R ::= R∗	Iteration,
R ::= R|A' ,  A' ⊆A	Hiding,
R ::= R⟨v⟩	Indexing.

Most of the above are standard regular expression constructs, to which we add intersection and two new operations, hiding and indexing. The latter are operations on regular languages that can be carried out directly at the level of regular expressions. Hiding represents a restriction of a regular expression to a subset of its alphabet by removing all the occurrences of symbols in the restricted alphabet; its language is the set of sequences of the original languages with all the elements of A' deleted. Indexing is defined as the tagging of the first symbol a of any sequence in the language with the string























Fig. 2. Semantics of Foil types
v, resulting in a(uv), where u is the pre-existing tag of R, possibly empty (ϵ).
A regular-language representation of the game semantics of Foil is defined as follows. With types we associate games, represented as regular languages over an alphabet denoting the moves. With terms we associate strategies, represented as regular languages over the disjoint sum of the alphabets of the types of the free identifiers and the term itself.
As mentioned in the previous sections, a call-by-value game for a type
θ has two stages: a protocol-game P c followed by a component-game Rθ =
θ
k∈Kθ Rθ(k). The protocol part of the play corresponds to the co-product
structure which forms the monad, tying together the various components.
A play in the protocol game always has the form ? · c for c ∈ Cθ. We call Cθ the set of component-selecting moves. The first move in a play in the component game Rθ has the form m(k), where k ∈ Kθ. We call Kθ the set of component-deﬁning moves; every such component is represented by the regular language Rθ(k). Notice that Cθ and Kθ are distinct sets. If sets C or K only have one element (*), we will often omit it as an index.
The regular language semantics of Foil types is the one given in Figure 2. For void, nat and bool the definition is straightforward. Variables var are the product of an acceptor and an expression type, not reified in the actual language. Arrays of size n are identified with products of n variables. Proving

these regular expressions correctly represent games is tedious, but routine.
In the case of product and function types it is required that the alphabets (sets of moves) of the types involved are disjoint. This is achieved by system- atically tagging all the moves in each alphabet with tags uniquely associated with each type occurrence.

Regular language semantics of terms
Terms in Foil are interpreted as families of regular expressions, representing the call-by-value strategies. They have the following form, where P and R are the protocol and the component parts:

 ι1 : θ1,..., ιn : θn ▶ M : θ) =
c∈ i≤n Cθi
 Σk∈Kθ
P c,k · RM (k)∗, .

Free identifiers are interpreted as:

c,k	c	ι	ι
 ι : θ ▶ ι : θ)	:	Pι : θ = Pθ ,	k ∈ Kθ,	Rι = Rθ[m/m·m ][n/n ·n],
for all moves m of odd index in the play (the O-moves) and n of even index (P-moves). Since in the regular expressions moves always occur in pairs, this substitution can be carried out directly on the regular expression defining the plays. This “doubling-up” of moves is the representation of the important copy-cat strategy of game semantics. The new tag ι is meant to differentiate between the two occurrences of type θ, in the environment and in the term itself. For example:
x: nat ▶ x: nat = {? · n · ϵ | n ∈ N } ,
 f: nat → nat ▶ f: nat → nat) = ?·*·R∗}
= ?·*· Σi,n∈N q(i)·q(i) ·n ·n , .
∗
f	f

For all basic constants of the language we have R = ϵ and:

Binary arithmetic, logic and arithmetic-logic operators can be interpreted as abbreviations involving predefined functions, for which the semantics of ap- plication (to be defined later) will be used to compose the meanings of sub- phrases:
 +: nat × nat → nat)	:	P+	= ? · *,	R+(m, n)= ?(m, n)·(m + n), with m, n ∈ N . Similarly for all other operators. Sequencing is:

 −; −: void × void → void)	:	P; =? · *,	R; = ϵ,
−; −: void × nat → nat	:	P; =	? · n,	R; = ϵ.
n∈N
Assignment and dereferencing are respectively:
 −:=− : var × nat → void)	:	P:= =? · *,	R:=(n)= write(n)·*,
!−: var → nat	:	P! =? · *,	R! =	read ·n.
n∈N
Abstraction is defined as explicitly reindexing the regular expressions denoting the meaning of a term M with the component moves of the types of identifiers abstracted over:
 Γ ▶ λι1 ... ιk : σ1 ×· · · × σk.M : σ1 × ··· × σk → τ ) :
P	=? · *, Rλ(k)= Q⟨k⟩, k ∈	Cσ , Q ∈  Γ, ι1 : σ1,..., ιk : σk ▶ M ) .

The most important, and the most complex, is the meaning of application:

c'	'
x,y

 Γ ▶ MN : τ )	:	PMN = ?·PN · RM (c)[x·y/RN  ],	RMN = ϵ

where	?·P c' ·c·R
∈ Γ'' ▶ N : σ) ,	RN
x,y N
x,y

' (c) ∈ Γ' ▶ M : σ → τ ,	Rσ =	x·y.
c	x,y
The regular expressions and regular expression families involved in the defini- tion above are well defined in general, with one exception. If N is a diverging

term then either one of Pc'
and RN
may be ∅ with the other arbitrary, ∅

being a zero-element for concatenation. This ambiguity is resolved by always

choosing Pc' = ∅, to be consistent with the fact that P
diverge
= ∅, as presented

earlier. The choice for RN is then irrelevant, ϵ by convention.
The semantics of application is derived directly from the game semantics as well, more precisely from compositions of strategies. In composing strate- gies, which is how application is interpreted, the moves in the game (type occurrence) through which composition is realized serve as “triggers” which switch the thread of execution between the two strategies. In our particular case, whenever such a move x occurs, a regular expression denoting the trace of execution for the argument is inserted in the regular expression denoting the body of the function, up to the point where another context-switching move y occurs. In the process of composing strategies all trigger moves are subsequently hidden. Here, the key technique is to decompose a regular ex- pression into smaller regular expressions and, using systematic substitution and concatenation, create the regular expressions corresponding to the result. This technique will be also used in defining the regular language semantics of terms which are not abbreviations.
Since functions are not curried we need to define pairing. It reflects the left-to-right order of argument evaluation in function call, specific to Foil:

 Γ ▶ (M, N ): σ × σ'  :
P (c,c')(k,k') = ?·Qc,k ·Qc',k' ·(c, c'),	R


(k, k')= R


(k) + R


(k') ∗


M	N	N
Branching and looping are defined directly, not as abbreviations:
tt	'	ff	'
 if B then M else N )	:	Pif = (?·PB ·PM ·*)+ (?·PB ·PN ·*), Rif = ϵ,
tt	'	∗	ff
 while B do M )	:	Pwhile = ?·(PB ·PM ) ·PB ·*,  Rwhile = ϵ,
where	:	PB =	Σ ?·P v ·v, PM = ?·P ' ·*, PN = ?·P ' ·* . 

The semantics of if is directly specified in the games semantics. Looping in game semantics is defined as an abbreviation using the recursion combinator. A general recursion combinator is not specified in this treatment, but the fixed point can be calculated by hand; the semantics of while above is the result of that calculation.
Array element access is also directly defined:
 Γ ▶ ι[N ]: var)	:

k ι[N ]
= ?·P k' ·*,	R

ι[N ]
(k) = Σ read (k)·m + Σ write(k, m)·*,

where Pk' = ?·P k ·k.
m∈N
m∈N

N
Finally, as in the case of Algol, local variables are realized by imposing a good variable restriction on the plays and by hiding the actions of the local variables. Good-variable behaviour simply means that the last value written in a variable will be the next value read from that variable; this restriction is imposed using intersection with the following regular expression, associated with a variable ι:
γι =	∗	∗ Σ	write(n)ι·*ι	∗ (read ι·nι·A ∗)∗ ∗ ,
where Aι = {read ι, write(n)ι, nι, *ι|n ∈ N } is the set of all moves tagged by ι,
i.e. all moves involving variable ι. Therefore local variable definition is:
 new ι in M ) = {(γ ∩ Q) |Aι	| Q ∈ M )} .
For similar reasons, the meaning of array declaration is:
 new ι[n] in M ) =    γι[i] ∩ Q	 Q ∈ M ) ,

i≤n

    
 i≤n Aι[i]
    


This concludes the semantic definition of Foil. We can state that:
Lemma 5.1 (Representation) The regular language semantics of

Foil is

a fully correct representation of the games and strategies used in the game semantic model.

From this, it follows directly from [5] that:
Theorem 5.2 (Full Abstraction) The regular language semantics of Foil is fully abstract, i.e. two terms of Foil are equivalent if and only if they denote the same family of regular languages:
For all Γ ▶ P, Q : θ,	P ≡ Q ⇐⇒  P ) =  Q) .
In addition, since the representation is by regular languages, for which language equality is decidable, it follows directly that:
Theorem 5.3 (Decidability) Equivalence of two terms of Foil is decidable.
Example of reasoning
Since one of the stated purposes of this article is to provide a basis for a new and potentially practical tool, we think it is important to show in some detail an example. Space constraints prevent us from presenting a realistic program, so we will instead prove a simple, but theoretically important, equivalence of Foil:
f: nat → void, v: nat ▶	new x in x := v; f(!x) ≡void f(v).
Proof:
x: var ▶ x: var : P  =? · *,
Rx = Σ read ·read x·nx·n + Σ write(m)·write(m)x·*x·*

x: var ▶!x : nat  : P!x = ?·	·read x·nx·n,	R!x = ϵ
n∈N

 f: nat → void ▶ f: nat → void) : Pf = ?·*,	Rf
= Σi∈N
q(i)·q(i)f ·*f ·* ∗

 f: nat → void, x: var ▶ f(!x) : nat) :

Pf (!x)
= ?·	read x·nx· q(n)f ·*f ∗ ·*,	R
n∈N
f (!x) = ϵ

 v: nat, x: var ▶ x := v: void) : Px:=v = ?·write(v)
· *x
·*,	Rx:=v = ϵ

 f: nat → void, v: nat, x: var ▶ x := v; f(!x) : void) :

v  x:=v;f (!x)
= ?·write(v)x·*x·	read x·nx· q(n)f ·*f ∗ ·*,	R
n∈N
x:=v;f (!x) = ϵ


f: nat → void, v: nat ▶ new x in x := v; f(!x) : void :
Pv = ?· write(v)x· *x ·read x·vx· q(v)f ·*f ∗ ·* = ?· q(v)f ·*f ∗ ·*,	R = ϵ.


Therefore:
f: nat → void, v: nat ▶ new x in x := v; f(!x) : void
=  ?· q(v)f ·*f ∗ · * v ∈ N , =  f: nat → void, v: nat ▶ f(v) : void) .

Conclusion
We have presented a games-based regular language semantics for an imperative language with first order procedures using call-by-value function application, with arrays and variables passed by-reference. The model is obtained directly from the game semantic model [5,1] by working out the details of the category- theoretical presentation and by observing that much of the games apparatus (justification pointers, etc.) is unnecessary in handling the present language subset.

Acknowledgement
Guy McCusker’s suggestions and explanations were essential in the writing of this paper, I owe him a great deal. I would like to thank Bob Tennent for his support and encouragement. Many thanks are due to the anonymous referees for providing insightful comments and pertinent corrections.

References
Abramsky, S., K. Honda and G. McCusker, A fully abstract game semantics for general references, in: Proceedings, Thirteenth Annual IEEE Symposium on Logic in Computer Science, 1998.
Abramsky, S., P. Malacaria and R. Jagadeesan, Full abstraction for PCF, Lecture Notes in Computer Science 789 (1994), pp. 1–59.
Abramsky, S. and G. McCusker, Game semantics, lecture notes, 1997 Marktoberdorf summer school (available from http://www.dcs.ed.ac.uk/ home/samson/mdorf97.ps.gz).
Abramsky, S. and G. McCusker, Linearity, sharing and state: a fully abstract game semantics for Idealized Algol with active expressions, in: O’Hearn and Tennent [14] pp. 297–329, two volumes.
Abramsky, S. and G. McCusker, Call-by-value games, in: CSL: 11th Workshop on Computer Science Logic, LNCS 1414, 1998, pp. 1–17.
Abramsky, S. and G. McCusker, Full abstraction for Idealized Algol with passive expressions, Theoretical Computer Science 227 (1999), pp. 3–42.


Ghica, D. R. and G. McCusker, Reasoning about idealized algol using regular languages, in: Proceedings of 27th International Colloquium on Automata, Languages and Programming ICALP 2000, LNCS 1853 (2000), pp. 103–116.
Hankin, C. and P. Malacaria, Generalised flowcharts and games, Lecture Notes in Computer Science 1443 (1998).
Hankin, C. and P. Malacaria, Non-deterministic games and program analysis: an application to security, in: Proceedings, Fourteenth Annual IEEE Symposium on Logic in Computer Science, 1999 pp. 443–452.
Hyland, J. M. E. and C.-H. L. Ong, On full abstraction for PCF: I, II and III, Information and Computation 163 (2000).
McCusker, G., “Games and Full Abstraction for a Functional Metalanguage with Recursive Types,” Distinguished Dissertations, Springer-Verlag Limited, 1998.
Meyer, A. R. and K. Sieber, Towards fully abstract semantics for local variables: preliminary report, in: Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages (1988), pp. 191– 203, reprinted as Chapter 7 of [14].
Moggi, E., Notions of computation and monads, Information and Computation
93 (1991), pp. 55–92.
O’Hearn, P. W. and R. D. Tennent, editors, “Algol-like Languages,” Progress in Theoretical Computer Science, Birkh¨auser, Boston, 1997, two volumes.
Schmidt, D. A., On the need for a popular formal semantics, ACM SIGPLAN Notices 32 (1997), pp. 115–116.
