Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 348 (2020) 43–60
www.elsevier.com/locate/entcs
Introducing Synchrony in Fuzzy Automata 1
Leandro Gomes 2
INESC TEC
Univ. Minho Braga, Portugal
Alexandre Madeira3
CIDMA
Univ. Aveiro Aveiro, Portugal
Luis Soares Barbosa4
INESC TEC
Univ. Minho Braga, Portugal
United Nations University UNU-EGOV
Guimar˜aes, Portugal

Abstract
This paper introduces a sort of automata and associated languages, often arising in modelling natural phenomena, in which both vagueness and simultaneity are taken as first class citizens. This requires a fuzzy semantics assigned to transitions and a precise notion of a synchronous product to enforce the simultaneous occurrence of actions. The expected relationships between automata and languages are revisited in this setting; in particular it is shown that any subset of a fuzzy synchronous language with the suitable signature forms a synchronous Kleene algebra.
Keywords: fuzzy automata, fuzzy languages, synchronous languages.


1 This work is financed by the ERDF – European Regional Development Fund through the Operational Programme for Com- petitiveness and Internationalisation - COMPETE 2020 Programme and by National Funds through the Portuguese funding agency, FCT - Fundaca˜o para a Ciˆencia e a Tecnologia, within projects POCI-01-0145-FEDER-030947 and UID/MAT/04106/2019. The second author is supported in the scope of the framework contract foreseen in the numbers 4, 5 and 6 of the article 23, of the Decree-Law 57/2016, of August 29, changed by Portuguese Law 57/2017, of July 19. This paper is also a result of the project SmartEGOV: Harnessing EGOV for Smart Governance (Foundations, Methods, Tools) NORTE-01-0145- FEDER-000037, supported by Norte Portugal Regional Operational Programme (NORTE 2020), under the PORTUGAL 2020 Partnership Agreement, through the European Regional Development Fund (EFDR). It received further support from the PT-FLAD Chair in Smart Cities & Smart Governance.
2 Email: leandro.r.gomes@inesctec.pt
3 Email: madeira@ua.pt
4 Email: lsb@di.uminho.pt

https://doi.org/10.1016/j.entcs.2020.02.004
1571-0661/© 2020 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

Introduction
The notion of an automaton [7] as the de facto mathematical abstraction of a computational process over discrete spaces, is being constantly revisited to capture different sorts of computational behaviour in the most varied contexts, either pre- scribed in a program or discovered in Nature. Already in 1997 Robin Milner [15] emphasised that
from being a prescription for how to do something – in Turing’s terms a ‘list of instructions’, soft- ware becomes much more akin to a description of behaviour, not only programmed on a computer, but also occurring by hap or design inside or out- side it.
Over time different kinds of automata have been proposed accordingly, generating (or recognising, depending on the perspective) such behaviours (or the languages that express them) [2,3,21]. In this context, Kleene algebra was introduced [8] as an algebraic structure to capture axiomatically the basic properties of regular expressions.
This paper focus on a specific sort of automata and languages, often arising in modelling natural phenomena, in which two extra ingredients cannot be overlooked. The first is vagueness. In a biological network [4], for example, this expresses the possibility of a certain enzyme being absent or scarce in certain configurations. The other is simultaneity, i.e. the fact that certain events (for example the flow of some reagents in a chemical reaction) are required to happen at the same time, instead of, as usually considered in interleaving models of concurrency, in a non deterministic alternation.
The first ingredient — vagueness — is formalised by the notion ofa fuzzy finite- state automata (FFA), a structure introduced in the Sixties [23] to give a formal semantics to vagueness inherent to several computational systems. Variants of this idea, e.g. incorporating fuzziness to either states or transitions, or both, are well documented in the literature [3,10,12]. In any case, fuzzy languages [9,1] are recog- nised by a FFA only up to a certain membership degree. Applications are transversal to several domains [11,16,17,24]. Probabilistic automata [19], another approach to handle uncertainty, fixes the interpretation of the latter as a probability, always enforcing the production of an outcome (as expressed by the requirement that the outgoing probabilities always sum 1). Such is not the case in the fuzzy framework adopted in this paper.
On its turn, simultaneity, our second ingredient, was suitably formalised in what Milner called the ‘synchronous version of CCS’ — the SCCS [14] calculus, a variant of CCS [13] where arbitrary actions can run synchronously. This very same idea of synchronous evolution appears in the work of C. Priscariu on synchronous Kleene algebra (SKA) [18]. Kleene algebras are idempotent, and thus partially ordered, semirings endowed with a closure operator. Models for SKA, as well as for its

variant with tests (SKAT), are given in terms of sets of synchronous strings and finite automata accepting synchronous strings. These structures found application, for instance, in variants of deontic logic to formalise contract languages [20,22], and of Hoare logic to reason about parallel synchronous programs with shared variables [18].
start









Fig. 1. Interleaving two automata representing deterministic flows.
Both of these ingredients are combined in this paper. The sort of systems we have in mind is illustrated in Fig. 1. Suppose that two automata represent the flow of two reagents c and m into a solution. The scheme of Fig. 1 represents their interleaving as two alternative sequential compositions. Our objective, however, has a different focus. First we intend to record that elementary steps are ‘uncertain’, in the sense that each individual flow may exhibit failures or interruptions. The transitions in the automata are thus labelled with the flow identifier and a ‘certainty’ degree measuring how certain it is for each flow (event ) effectively flowing. Second, their combination makes sure that both flows (actions) occur simultaneously combining their ‘certainty’ degrees into the ‘certainty’ degree of their joint flow. These features are expressed in the fuzzy synchronous automata that this paper proposes to add to the broad family of finite-state automata mentioned above.
In order to formalise such a behaviour, the paper introduces a synchronous product construction between a variant of fuzzy transition automata in the spirit of reference [12] where, depending on the application scenario, “vagueness” can be modelled in an arbitrary, either discrete or continuous, domain. This is captured by a complete Heyting algebra introduced as a parameter in the model. The notion of synchronous sets in reference [18] is generalised to that of fuzzy synchronous languages, and some operators over them suitably defined. A map that interprets the terms of SKA as fuzzy synchronous languages is provided. Then we prove that the terms of a SKA can be used to generate a H-NFA accepting precisely the fuzzy synchronous language that constitutes its interpretation. Obtaining a regular expression from a H-NFA proceeds by state elimination as in the classical case [6]. The procedure results in a H-NFA with a single transition from the initial to the final state, labelled by an action α of SKA such that its interpretation is the language recognised by that H-NFA.
This paper is organised as follows. Section 2 recaps some fundamental con- cepts required later. Section 3 introduces fuzzy synchronous languages and defines some suitable operators over them. Section 4 introduces a method for constructing

the synchronous product of two nondeterministic automata with fuzzy transitions. Moreover, it is proved that the algebra constituted by any set of fuzzy synchronous languages and the signature previously defined forms a SKA. Finally, Section 5 concludes and enumerates some topics for future research.

Preliminaries
Definition 2.1 (Kleene algebra) A Kleene algebra (K, +, ·,∗ , 0, 1) is an idem- potent semiring with an extra unary operator ∗ satisfying the axioms (1) − (13) of Fig. 2. A partial order ≤ is deﬁned as α ≤ β ⇔ α + β = β.
The operators +, · and ∗ are typically understood as nondeterministic choice, sequence and iteration, respectively. Actions 0 and 1 represent fail and skip, re- spectively.
Well-known examples of Kleene algebras are the algebra of binary relations over a set X, the set of all languages over Σ∗, and the (min, +) algebra, also known as the tropical algebra.
Extending the original definition with an operation × to capture the synchronous execution of actions 5 lead to the notion of a synchronous Kleene algebra [18].
Definition 2.2 (Synchronous Kleene algebra) A synchronous Kleene algebra (SKA) is a tuple
S = (A, +, ·, ×,∗ , 0, 1, AB)
where AB is a ﬁnite discrete set of basic actions and A a (possible inﬁnite) set of
composed actions, satisfying the axioms in Fig. 2.
The sets of actions A and AB are structured by AB ⊆ A× ⊂ A, where AB is
the set of basic actions and A× is its closure under ×.
We denote by TSKA the term algebra of SKA, generated by the grammar:

α ::= ab | 0 | 1 | α + α | α · α | α × α | α∗
where ab ∈ AB. Following a common practice, we write abbb, rather than ab · bb, for
ab, bb ∈ AB. The elements of A× are called ×-actions (e.g. a, a× b ∈ A× but a + b,
B	B
a × b + c, 0, 1 ∈/ A×).
Definition 2.3 (Complete Heyting algebra) A	complete	Heyting	algebra (CHA) is a tuple
H = (H, +, ; , 0, 1, →)
which satisﬁes axioms (1)-(9) in Fig. 2, replacing · by ; and, additionally, the fol- lowing axioms:

5 Following [18], the symbol × stands for the synchronous product; any possible confusion with the same symbol used for Cartesian product is desambiguated by context.
































B

Fig. 2. Axiomatisation of SKA from [18].

h1; h2 = h2; h1	(22)
h; h = h	(23)
h1 + (h1; h2)= h1	(24)
h1; h2 ≤ h3 ⇔ h2 ≤ h1 → h3	(25)
h;  Σ hi! = Σ(h; hi)	(26)

 Σ hi! ; h = Σ(hi; h)	(27)
with Σ denoting the iterated version of the associative operator +, and I being an (possible inﬁnite) index set.
We assume H to be complete to ensure that all suprema exist when characterising operators ·, × and ∗ on fuzzy synchronous languages as (possible) infinite sums. Such property, together with axiom (25) ensure that every suprema distributes over arbitrary infima, which is used to prove Theorem 4.6. The examples below illustrate

this structure.
Example 2.4 (2- the Boolean algebra) A ﬁrst example is the well-known bi- nary structure
2 = ({T, ⊥}, V, Λ, ⊥, T, →)
with the standard interpretation of Boolean connectives.
Example 2.5 A second example is the three-valued Go¨del chain, which introduces an explicit denotation u for “unknown” (or “undeﬁned”).
G3 = ({T, u, ⊥}, V, Λ, ⊥, T, →)

Example 2.6 (G¨odel algebra) Another example is given by the standard G¨odel algebra


where
G = ([0, 1], max, min, 0, 1, →)

x → y =	1, if x ≤ y
y, if y < x

Fuzzy synchronous languages
This section introduces a notion of fuzzy synchronous language, based on C. Prisacariu proposal for the crisp synchronous case [18]. A number of operations over fuzzy synchronous languages are also defined. Finally, a map that interprets each term of TSKA as a fuzzy synchronous language is formalised. The reader is referred to any classical introduction to fuzzy logic, e.g. [1], for the standard defi- nitions of fuzzy sets and fuzzy languages used in the sequel.
Definition 3.1 (H-Fuzzy synchronous language) Let AB be a set of basic ac- tions and H a CHA over carrier H, and Σ = P(AB) \ {∅} the alphabet of all the nonempty subsets of AB (denoted by x, y). Sequences u, v, . . . ∈ Σ∗ are called AB-synchronous strings, with notation ϵ standing for the empty string. A H-fuzzy
∗
synchronous language over AB is an element of HΣ , i.e. a function L : Σ∗ → H.
We can then generalise for this setting, the standard operators from regular language theory. For any H-fuzzy synchronous languages L, L1, L2, and for all w ∈ Σ∗, we define the following operations:
- ∅(w)= 0, for all w ∈ Σ∗

χ(w)=	1	if w = ϵ
0	otherwise
- (L1 ∪ L2)(w)=L1(w)+ L2(w)
(L1 · L2)(w)	=	u,v L1(u); L2(v),	with	w	=	uv	standing for the concatenation of strings u and v

- L∗(w)= Σ

i≥0
Li (w), with L0(w)= χ(w), L(i+1)(w)= (L· Li)(w)

(L1 × L2)(w)=  u,v L1(u); L2(v), with w = u × v defined by
u × ϵ = u = ϵ × u
u × v = (x ∪ y)(uj × vj) where u = xuj and v = yvj, with x, y ∈ Σ.
One may notice that the expressions that define operators · and × seem related. Note, however, that operator · ranges over all possible ways to construct the word w by concatenation of the smaller words u and v, while operator × looks over all the possible constructions by “classical” synchronous product of words u×v defined above.
Definition 3.2 (Basic H-fuzzy and ×− H-fuzzy synchronous languages) A basic H-fuzzy synchronous language, denoted by LB, is a H-fuzzy synchronous language such that LB(w) = 0 whenever w /∈ AB. A ×− H-fuzzy synchronous language, denoted by L×, is a H-fuzzy synchronous language such that L×(w)= 0 whenever w /∈ A×.
Note that A× does not contain any action built from operator · (e.g. for AB =
{a, b, c}, abc ∈/ A×).
Without loss of generality, we write ab for the singleton set {ab}, for any ab ∈ AB. Moreover, expression a1 ... an, for n ≥ 1 will denote in the sequel a synchronous string where ai ∈ Σ, with 1 ≤ i ≤ n.
Similarly to the homomorphism used to interpret SKA as synchronous sets [18], we define a map to interpret term actions of α ∈ TSKA as H-fuzzy synchronous languages.
Definition 3.3 (Fuzzy interpretation) Consider a map FISKA : AB ∪ {0, 1}→ 
HΣ∗ such that
FISKA(ab)= LB
FISKA(0)= ∅
FISKA(1)= χ
where LB is a basic H-fuzzy synchronous language such that LB(w) = 0 for all
w /= ab.

Its extension F ISKA : TSKA → HΣ
pretation of SKA and deﬁned as
over the term algebra is called a fuzzy inter-

F ISKA(α)= FISKA(α), ∀α ∈ AB ∪ {0, 1} F ISKA(α + β)= F ISKA(α) ∪ F ISKA(β) F^ISKA(α · β)= F^ISKA(α) · F^ISKA(β)

F ISKA(α × β)= F ISKA(α) × F ISKA(β) F^ISKA(α∗)= F^ISKA(α)∗
Synchronous product of fuzzy automata
This section presents our main results. First a new type of fuzzy automata is defined on top of a CHA which models the space of possible membership values for fuzzy transitions. An appropriate notion of a synchronous product for these sort of automata then is presented. The section ends with the generalisation of two classical results:
for every term α of TSKA, there is a H-NFA which accepts precisely F ISKA(α);
given a H-NFA M, there is a function f mapping M to α of SKA such that
F ISKA(α)= L(M).
Definition 4.1 (Nondeterministic automata with fuzzy transitions) For a CHA over H,a set AB of basic actions, a nondeterministic finite-state automaton with fuzzy transitions (H-NFA) is a tuple M = (X, Σ, x0, F, δ) where:
X is a ﬁnite set of states;
Σ= P(AB ) \{∅} is the input alphabet (i.e. the powerset of the set of basic actions minus the empty set);
x0 is the initial state;
F is the set of ﬁnal states;
δ : X × Σ × X → H is the fuzzy transition function.
Intuitively, δ(x1, a, x2), for a ∈ Σ, can be interpreted as the truth degree of “input
a causing a transition from x1 to x2”.
The fuzzy transition relation can be inductively extended to the free monoid Σ∗ over Σ through a function δ∗ : X × Σ∗ × X → H such that, for any x1, x2 ∈ X,
δ∗(x , ϵ,x )=  1	if x1 = x2
and, for any x1, x2 ∈ X, w ∈ Σ∗ and a ∈ Σ,
δ∗(x1, aw, x2)=	δ(x1, a, xj); δ∗(xj, w, x2)
x∗∈X

For any states x1, x2 ∈ X and any word w ∈ Σ∗, δ∗(x1, w, x2) can be interpreted as the truth degree of “word w causes a transition from x1 to x2”.
Given a residuated lattice A with support set A, a fuzzy language over an alphabet Σ is classically defined as a fuzzy subset of Σ∗, that is, a function λ : Σ∗ → A [9]. Thus,
Definition 4.2 Given a CHA over H and a H-NFA M = (X, Σ, x0, F, δ), the fuzzy synchronous language recognised by M is a function L(M): Σ∗ → H deﬁned as


L(M)(w)=	δ∗(x0, w, x)
x∈F
for w ∈ Σ∗.
We can interpret L(M)(w) as the truth degree of “the word w causes a transition from an initial state to a ﬁnal state in M”. L(M)(w) is the degree of recognition of w by M.
Now we prove a Kleene theorem for H-NFA and fuzzy synchronous languages. The proof proceeds by taking a class of H-NFA denoted Mα whenever the automa- ton is a H-NFA associated to an action α ∈ TSKA.
Theorem 4.3 For any action α ∈ SKA there exists a H-NFA Mα which accepts precisely F ISKA(α).
Proof. We construct a H-NFA Mα for each regular expression built from a basic action ab ∈ AB and operators +, · and ∗. Then we provide a construction similar to the one in [18] for the synchronous operator ×. Each transition of the automaton is labelled by a pair (α, δ(xi, α, xj)), 0 ≤ i, j ≤ n where α ∈ TSKA is the action relating to the input that causes a transition between states xi and xj, and δ(xi, α, xj) ∈ H the is “weight” of the transition. Slightly abusing the notation, let α ∈ TSKA represent the input of the automaton that relates to action α, a convention that allows a clearer presentation of the inductive proof. Thus,

Base case:
The automata corresponding to ab ∈ AB, 0 and 1, i.e. Mab , M0 and M1, are depicted in Figure 3 from top to bottom, respectively. By Definition 4.2 it is easy to see that the fuzzy synchronous language recognized by each one of these automata coincides precisely with F^ISKA(ab), F^ISKA(0) and F^ISKA(1), respectively.


start
(ab,δ(x0, ab, x1))
0	1



start	x0
start	x0


(ϵ,1)
1


Fig. 3. Automata representing actions a ∈ AB, 0 and 1.
By Definition 4.2, the fuzzy synchronous language recognized by Mab is given
by
L(Ma )(ab)= δ∗(x0, ab, x1)= δ(x0, ab, x1)
and L(Mab )(w) = 0, for all w /= ab. Thus, L(Mab ) = F ISKA(ab). The fuzzy synchronous language recognized by M0 is given by L(M0)(w)= 0, for all w ∈ Σ∗.

Analogously, the fuzzy synchronous language recognized by M1 is defined as
L(M1)(ϵ)= 1 and
L(M1)(w)= 0, for all w /= ϵ. Clearly L(M1)= F ISKA(1).
Inductive case:
The automata Mα+β, Mα·β and Mα∗ depicted in Figures 4, 5 and 6, respec- tively, correspond to terms α + β, α · β and α∗. Their construction is the standard one [6].



start




Fig. 4. Automata representing action α + β.

The fuzzy synchronous language recognized by Mα+β is given by:

L(Mα+β)(ϵαϵ)= δ∗(x0, ϵαϵ, x5)= δ(x0, ϵ, x1); δ∗(x1, αϵ, x5)+ δ(x0, ϵ, x3); δ∗(x3, αϵ, x5)
= 1; δ∗(x1, α, x2); δ(x2, ϵ, x5)+ 1; δ∗(x3, α, x4); δ(x4, ϵ, x5)
= δ∗(x1, α, x2); 1 + 0; 1 = δ∗(x1, α, x2) and analogously for word ϵβϵ,
L(Mα+β)(ϵbϵ)= δ∗(x2, β, x3)

On the other hand, F ISKA(α + β) = Lα ∪ Lβ and (Lα ∪ Lβ)(α) = δ∗(x1, α, x2), (Lα ∪Lβ)(β)= δ∗(x2, β, x3) and (Lα ∪Lβ)(w)= 0 for w /= α, β. Thus, L(Mα+β)= F ISKA(α + β).
start


start
(є,1)
x0	x1
(α,δ(x1, α, x2))
(є,1)
x2	x3






Fig. 5: Automata representing action
α · β.
(є,1)
(є,1)
Fig. 6: Automata representing action
α∗.

The fuzzy synchronous language recognised by Mα·β is defined as


L(Mα·β)(αϵβ)= δ∗(x0, αϵβ, x3)= δ∗(x0, α, x1); δ∗(x1, ϵb, x3)
= δ∗(x0, α, x1); δ(x1, ϵ, x2); δ∗(x2, β, x3)= δ∗(x0, α, x1); 1; δ∗(x2, β, x3)
= δ∗(x0, α, x1); δ∗(x2, β, x3)
Analogously as before, F^ISKA(α · β)	=	Lα · Lβ  with (Lα · Lβ)(w)	=
δ∗(x0, α, x1); δ∗(x2, β, x3) if w  = α · β and 0 otherwise.	Hence, L(Mα·β)  =
F ISKA(α · β).
Finally, automaton Mα∗ recognizes the fuzzy synchronous language given by

L(Mα∗ )(ϵαα∗ϵ)= δ(x0, ϵ, x1); δ∗(x1, αα∗ϵ, x3)= 1; δ∗(x1, α, x2); δ∗(x2, α∗ϵ, x3)
= δ∗(x1, α, x2); δ∗(x2, α∗, x2); δ(x2, ϵ, x3)= δ∗(x1, α, x2); δ∗(x2, α∗, x2); 1
= δ∗(x1, α, x2); δ∗(x2, α∗, x2)


and for word ϵ, L(Mα∗ )(ϵ) = δ(x0, ϵ, x3) = 1. where
F^ISKA(α∗) = F^ISKA(α)∗ = L∗

L∗ (w)= Σ Li (w)= χ(w)+ Lα(w)+ L2 (w)+ ... 

= Lα(αα∗)+ L2 (αα∗)+ ... = Lα(αα∗)+ Lα(αα∗); Lα(αα∗)+ ... 
= Lα(αα∗)= Lα(α); Lα(α∗)= δ∗(x1, α, x2); δ∗(x2, α∗, x2)
L∗ (w)= χ(ϵ)= 1 if w = ϵ and 0 otherwise. Therefore, L(Mα∗ )= F ISKA(α∗).
2
The synchronous product of two H-NFA Mα = (Xα, P(Aα ) \ {∅}, xα,Fα, δα)
B	0
and
Mβ = (Xβ, P(Aβ ) \ {∅}, xβ,Fβ, δβ) is
B	0
Mα×β = (Xα × Xβ, P(Aα ∪ Aβ ) \ {∅}, (xα, xβ),Fα × Fβ, δα×β)
B	B	0	0


where
δα×β : (Xα × Xβ) × (P(Aα ∪ Aβ ) \ {∅}) × (Xα × Xβ) → H

B	B
is defined, for u ∈ P(Aα ) \ {∅} and v ∈ P(Aβ ) \ {∅}, w = u ∪ v, by

B


δα×β((xα, xβ), w, (yα, yβ)) =
B

δα(xα, u, yα)	if xβ = yβ ∈ Fβ
δβ(xβ, v, yβ)	if xα = yα ∈ Fα
,,Σu,v δα(xα, u, yα); δβ(xβ, v, yβ)	otherwise

The corresponding construction is illustrated in Fig. 7.
Definition 4.4 Let Mα = (Xα, P(Aα ) \{∅}, xα,Fα, δα) and Mβ = (Xβ, P(Aβ ) \
B	0	B
{∅}, xβ,Fβ, δβ) be two H-NFA and Mα×β	=	(Xα  × Xβ, P(Aα ∪ Aβ ) \
0	B	B

{∅}, (xα, xβ),Fα × Fβ, δα×β) its synchronous product. The fuzzy synchronous lan-
0	0
guage recognised by Mα×β is the function L(Mα×β): P(Aα ∪Aβ )\{∅} → H deﬁned
B	B
by
L(Mα×β)(w)= Σ  δα×β ∗((xα, xβ), w, (xα, xβ)).
0	0	f	f
xα∈Fα
xβ∈Fβ
Analogously to other cases, we prove that Mα×β recognizes the fuzzy syn- chronous language F^ISKA(α × β):

L(Mα×β)(α × β)= (δα×β)∗((xα, xβ),α × β, (xα, xβ)) = δα×β((xα, xβ),α × β, (xα, xβ))
0	0	f	f	0	0	f	f
= δα(xα, α, xα); δβ(xβ, β, xβ)
0	f	0	f

α	α	β	β	α	β
But F^ISKA(α×β)= Lα ×Lβ such that (Lα ×Lβ)(w)= δ (x0 , α, xf ); δ (x0 , β, xf )
if w = α × β and 0 otherwise. Hence, L(Mα×β)(α × β)= F^ISKA(α × β).


start
start
×
start
−→
x1,x3


s2
x2,x3
x1,x4

s1

x2,x4


Fig. 7. Example of the automaton construction corresponding to α × β.
where s1 denotes the label (α,δα(x1, α, x2)), s2 the label (β,δβ(x3, β, x4)) and s the label
(α×β, δα×β((x1, x3), α×β, (x2, x4))) corresponding to the synchronous action α×β.
The proof of completeness of SKA w.r.t. the fuzzy interpretation proceeds by eliminating states which generates a regular expression. Consider a function f which takes a H-NFA Mα and returns an action α ∈ SKA. The weight associated with this action is computed accordingly, depending on the weight of each transition of the automaton. Note that this procedure considers actions of SKA as labels for the automaton transitions, rather than as elements of the input alphabet Σ.
Theorem 4.5 For all α ∈ TSKA, f (Mα) results in an action α such that
F ISKA(α)= L(Mα).
Proof. The proof uses induction on the structure of the actions.
Base case:
Let us consider the automata Ma, M0 and M1 of Figure 3. Applying f , we obtain the actions a, 0 and 1 with weights δ(x0, a, x1), 0 and 1, respectively.
Inductive case:
Case α = α1 + α2. The automaton Mα1+α2 is obtained with the construction for + of Theorem 4.3 from the automata Mα1 and Mα2 . Then, f eliminates states

x1 and x2, obtaining a single transition labelled with the action 1 · α1 · 1 ≡ α1, with weight 1; δ(x1, α1, x2); 1 = δ(x1, α1, x2), and states 3 and 4 obtaining a single transition labelled by the action 1 · α2 · 1 ≡ α2 with weight 1; δ(x3, α2, x4); 1 = δ(x3, α2, x4). Finally it combines the two transitions into one labelled by the action α1 + α2 with weight δ(x1, α1, x2)+ δ(x3, α2, x4).


start
start
start







Fig. 8. Application of f in automata Mα+β , Mα·β and Mα∗ .


Case α = α1 · α2.
The automaton Mα1·α2 is obtained from Mα1 and Mα2 by the process of Theorem 4.3. By eliminating intermediate states x1 and x2 we obtain a single transition labelled α1 · 1 · α2 ≡ α1 · α2 with weight δ(x0, α1, x1); 1; δ(x2, α2, x3) = δ(x0, α1, x1); δ(x2, α2, x3).
Case α = α∗.
Using the same procedure, f eliminates states x1 and x2 of Mα∗ , obtaining an automaton with a single transition labelled by 1 · α1 · (1 · α1)∗ · 1 + 1 ≡ α∗ with weight 1; δ(x1, α1, x2); (1; δ(x1, α∗, x2)); 1 + 1 = δ(x1, α1, x2); δ(x1, α∗, x2)+ 1.
1	1
The resulting automata obtained by the procedure of the cases above are shown in
Figure 8.
Case α = α1 × α2.
Analogously, function f eliminates states (x1, x4) and (x2, x3), obtain- ing an automaton with a single transition labelled by α × β with weight δα1 (x1, α1, x2); δα2 (x3, α2, x4)= δα1×α2 ((x1, x3), α1 × α2, (x2, x4)).
2

Next we characterise the set of fuzzy synchronous languages as a SKA.
Theorem 4.6 Any set of fuzzy synchronous languages containing ∅ and χ and closed under the operations of Deﬁnition 3.1 is a synchronous Kleene algebra, for any CHA.
Proof. The proofs of (1)-(13) are analogous to [5]. Note that in [5], instead of
(12) and (13), the proofs of the equivalent axioms α · γ ≤ γ ⇒ α∗ · γ ≤ γ and γ · α ≤ γ ⇒ γ · α∗ ≤ γ are presented. We present only the proof for axioms dealing with operator ×, for a given word a1 ... an ∈ Σ∗, with n ≥ 1.
Axiom (14):

(L1 × (L2 × L3))(a1 ... an)
=	{ definition of ×}
Σk≥1(L1(a1 ... an); (L2 × L3)(a1 ... ak)+ L1(a1 ... ak); (L2 × L3)(a1 ... an))
=	{ definition of ×}
Σ  L1(a1 ... an);  Σ(L2(a1 ... an); L3(a1 ... al)+ L2(a1 ... al); L3(a1 ... an)) 
k≥1	l≥1
+ L1(a1 ... ak);  Σ(L2(a1 ... an); L3(a1 ... al)+ L2(a1 ... al); L3(a1 ... an)) 
l≥1
=	{ (26) and (5)}
Σ  Σ (L1(a1 ... an); (L2(a1 ... an)); L3(a1 ... al)+ (L1(a1 ... an); L2(a1 ... al)); L3(a1 ... an) 
k≥1  l≥1
+ Σ (L1(a1 ... ak); (L2(a1 ... an)); L3(a1 ... al)+ (L1(a1 ... ak); L2(a1 ... al)); L3(a1 ... an) 
l≥1
=	{ (27) and change indexes without loss of generality}
Σ  Σ (L1(a1 ... ak); L2(a1 ... al)+ L1(a1 ... al); L2(a1 ... ak)); L3(a1 ... an) 
k≥1  l≥1
+ Σ (L1(a1 ... an); L2(a1 ... al)+ (L1(a1 ... al); L2(a1 ... an))
l≥1
; L3(a1 ... ak)); L3(a1 ... ak) 
=	{ definition of ×}
Σk≥1 (L1 × L2)(a1 ... ak); L3(a1 ... an)+ (L1 × L2)(a1 ... an); L3(a1 ... ak) 
=	{ definition of ×}
((L1 × L2) × L3)(a1 ... an)
Axiom (15):
(L1 × L2)(a1 ... an)
=	{ definition of ×}
Σ(L1(a1 ... an); L2(a1 ... ak)+ L1(a1 ... ak); L2(a1 ... an))
k≥1
=	{ (2) and (22)}
Σ(L2(a1 ... an); L1(a1 ... ak)+ L2(a1 ... ak); L1(a1 ... an))
k≥1
=	{ definition of ×}
(L2 × L1)(a1 ... an)

Axiom (16):
(L× χ)(a1 ... an)
=	{ definition of ×}
Σ(L(a1 ... an); χ(a1 ... ak)+ L(a1 ... ak); χ(a1 ... an))
k≥1
=	{ definition of χ and (6)}
Σ(L(a1 ... an)+ L(a1 ... ak)) = L(a1 ... an)	definition of ×
k≥1
χ × α is proved analogously.

Axiom (17):
(L× ∅)(a1 ... an)
=	{ definition of ×}

Axiom (18):
This axiom applies only to basic fuzzy synchronous languages LB. So, given a basic fuzzy synchronous

Σ(L(a1
k≥1
... an); ∅(a1
... ak)
language LB,
(LB × LB)(ab)

+ L(a1 ... ak); ∅(a1 ... an))
=	{ definition of ∅ and (9)}
=	{ definition of ×}
Σk≥1 LB(ab); LB(ab)

=	{ (23)}
Σ
	 

=	{ definition of ×}
∅(a1 ... an)
The proof of ∅ × α uses a similar reasoning.
Axiom (19):
(L1 × (L2 ∪ L3))(a1 ... an)
=	{ definition of × and ∪}
Σ L1(a1 ... an); (L2(a1 ... ak)+ L3(a1 ... ak))
k≥1
+ L1(a1 ... ak); (L2(a1 ... an)+ L3(a1 ... an)) 
=	{ (7)}
=	{ definition of ×}
LB(ab)






=	{ (2)}
Σ L1(a1 ... an); L2(a1 ... ak)
k≥1
+ L1(a1 ... ak); L2(a1 ... an)
+ L1(a1 ... an); L3(a1 ... ak)

Σ L (a

...a ); L (a

...a )+ L (a

...a ); L (a

...a )
+ L1(a1 ... ak); L3(a1 ... an) 

1  1
k≥1
n	2 1	k
1  1	n	3  1
k
=	{ definition of × and ∪}

+ L1(a1 ... ak); L2(a1 ... an)+ L1(a1 ... ak); L3(a1 ... an) 
Axiom (20): Analogously to (19) but using (8).
((L1 × L2) ∪ (L1 × L3))(a1 ... an)

Axiom (21): This proof is done by considering ×-fuzzy synchronous languages.

((L× · L1) × (L× · L2))(a1 ... an)
1	2
=	{ definition of ×}
Σ	 (L× · L1)(a1 ... an); (L× · L2)(a1 ... ak) + (L× · L1)(a1 ... ak); (L× · L2)(a1 ... an) 
=	{ definition of ·}
Σ  Σ L×(a1 ... al); L1(al+1 ... an) ; Σ L×(a1 ... al); L2(al+1 ... ak) 

k≥1
1
l≥0
2
l≥0

+ Σ L×(a1 ... al); L1(al+1 ... ak) ; Σ L×(a1 ... al); L2(al+1 ... an) 

1
l≥0
2
l≥0

=	{ L×(a1 ... ak)= 0 for k /= 1}
Σ	 (L×(a1); L1(a2 ... an)); (L×(a1); L2(a2 ... ak)) + (L×(a1); L1(a2 ... ak)); (L×(a1); L2(a2 ... an)) 
=	{ (5) and (22)}
Σ	 (L×(a1); L×(a1)); (L1(a2 ... an); L2(a2 ... ak)) + (L×(a1); L×(a1)); (L1(a2 ... ak); L2(a2 ... an)) 
=	{ (7)}
Σ	 (L×(a1); L×(a1)); (L1(a2 ... an); L2(a2 ... ak)+ L1(a2 ... ak); L2(a2 ... an)) 
=	{ definition of × and L×(a1 ... ak)= 0 for k /= 1}
Σ	 (L× × L×)(a1 ... an); (L1 × L2)(a2 ... an) 
=	{ definition of ·}
((L× × L×) · (L1 × L2))(a1 ... an)
1	2
2

Let us revisit the example mentioned in the Introduction, concerning the joint fuzzy flow of two reagents. The fuzzyness in a flow represents potential malfunctions in the control apparatus. In order to model the confidence values of execution, we assume the structure G of Example 2.6. Consider, for instance, that the machine releases the reagents c and m with certainty values 0.95 and 0.93, respectively. We model such situation by taking the action corresponding to adding c with certainty
0.95 and the action of adding m with certainty 0.93 by the two H-NFA depicted in Fig. 9, where c abbreviates the label (c, δc(x0, c, x1)) and, analogously, m the label (m, δm(x0, m, x1)).
start	start

Fig. 9. Two H-FA representing the basic actions c and m.

Let us consider a machine able of execute both actions c and m simul- taneously. Its behaviour is modelled by the synchronous product of the au- tomata above, the result being depicted in Fig. 10, with c, m abbreviating label ({c, m}, δc×m((x1, x3), {c, m}, (x2, x4))).
start







Fig. 10. The synchronous product.

The weight of action c × m, corresponding to the certainty of obtaining the mix of both reagents, is given by

δc×m(((x1, x3), {c, m}, (x2, x4))) = δc(x1, c, x2); δm(x3, m, x4)= min{0.95, 0.93} = 0.93


Conclusions
In this work we defined the concept of a fuzzy synchronous language, a number of operators over such languages, and a synchronous product construction of two H-NFA. A generalisation of two classic results was proved: for every term α of TSKA, it is possible to construct a H-NFA which accepts precisely F ISKA(α); and, for all α ∈ TSKA, there exists a function f mapping Mα into α of SKA such that F ISKA(α) = L(Mα). Finally, we have shown that any set of fuzzy synchronous languages enriched with the fuzzy operators previously defined is a SKA.

Note that some axioms of Figure 2, namely (10)-(13), may have different rep- resentations in some literature. Even the very axiomatisation here presented for Kleene algebra is not minimal ((3) and (4) may be omitted). However, the axioma- tisation from [18] was maintained, since we intend to present the algebra of fuzzy languages as a model of SKA. One may notice also that operator → is absent from the automata constructions presented in the paper. Its role is however related with the proof of Theorem 4.6, as it assures, together with the complete property of the Heyting algebra, the infinite distribution of “;” over arbitrary suprema.
The construction of FFA with membership degrees in a lattice-ordered monoid L [10] is studied in an analogous context of this work, based on the concept of L-fuzzy regular expression. Such expressions are defined as regular expressions from an alphabet X with a scalar λ ∈L multiplication, using the monoid multiplication operator. It is precisely this scalar that attributes the weight to a transition in the automaton. In the approach presented in this paper, on the other hand, automata are built using standard regular expressions instead of fuzzy regular expressions. Regular expressions are then interpreted as fuzzy languages accepted by a fuzzy automaton, using the interpretation map F I.
Most of the results presented in the context of fuzzy languages are constructed using either the real interval [0, 1] or a generic residuated lattice L to model the (possible) many valued membership values. However, one of the main results of this paper, Theorem 4.6 relies on properties provided by a specific characterisation of a lattice ordered structure: the operator ; of the parameter must be idempotent and commutative. The definition presented for H-NFA differs from [12] in the semantic structure used for membership values. Although the original definition uses the unit interval [0, 1], we consider values from a more generic structure, a complete Heyting algebra.
A set of possible directions for future work emerge. The extension of SKA to tests, known as the synchronous Kleene algebra with tests, SKAT [18], mod- elled by a notion of fuzzy guarded synchronous languages is worth to be dis- cussed. This entails the need for defining guarded H-NFA and extending the syn- chronous product construction accordingly. Another extension worth to be con- sidered is to study a relaxation of SKA. Considering, for instance, the structure R = (R+ ∪ {∞}, min, +, ∞, 0, →) with x → y = max{y − x, 0}, ∀x, y ∈ R+ ∪ {∞}, known as the tropical semiring, as a parameter, would make possible to address situations where the experimenter could choose the desired proportion of reagents c and m involved. The synchronous action c × m would then represent the sum of the respective quantities. Such extension would not only broaden the number of applications of the approach proposed in this paper, but also open the discussion on which implications the more generic algebra would have in the proven results.
References
L A. Zadeh. Fuzzy languages and their relation to human and machine intelligence. Proc. Int. Conf. on Man and Computer, pages 148–179, 05 1996.
Sabine Broda, Ant´onio Machiavelo, Nelma Moreira, and Rog´erio Reis. On the average size of


glushkov and equation automata for KAT expressions. In Leszek Gasieniec and Frank Wolter, editors, Fundamentals of Computation Theory - 19th International Symposium, FCT 2013, Liverpool, UK, August 19-21, 2013. Proceedings, volume 8070 of Lecture Notes in Computer Science, pages 72–83. Springer, 2013.
Mansoor Doostfatemeh and Stefan C. Kremer. New directions in fuzzy automata. Int. J. Approx. Reasoning, 38(2):175–214, 2005.
Daniel Figueiredo, Manuel A. Martins, and Madalena Chaves. Applying differential dynamic logic to reconfigurable biological networks. Mathematical Biosciences, 291:10–20, 2017.
Leandro Gomes, Alexandre Madeira, and Lu´ıs Soares Barbosa. Generalising KAT to verify weighted computations. Technical report, HASLab INESC TEC - Univ. of Minho, Portugal, Department of Informatics, 2018.
John E. Hopcroft, Rajeev Motwani, and Jeffrey D. Ullman. Introduction to automata theory, languages, and computation - international edition (2. ed). Addison-Wesley, 2003.
S. C. Kleene. Representation of events in nerve nets and finite automata. In Claude Shannon and John McCarthy, editors, Automata Studies, pages 3–41. Princeton University Press, Princeton, NJ, 1956.
Dexter Kozen. On Kleene algebras and closed semirings. In Branislav Rovan, editor, Mathematical Foundations of Computer Science 1990, MFCS’90, Bansk´a Bystrica, Czechoslovakia, August 27-31, 1990, Proceedings, volume 452 of Lecture Notes in Computer Science, pages 26–47. Springer, 1990.
E. T. Lee and Lotfi A. Zadeh. Note on fuzzy languages. Inf. Sci., 1(4):421–434, 1969.
Yongming Li and Witold Pedrycz. Fuzzy finite automata and fuzzy regular expressions with membership values in lattice-ordered monoids. Fuzzy Sets and Systems, 156(1):68–92, 2005.
Feng Lin and Hao Ying. Modeling and control of fuzzy discrete event systems. IEEE Trans. Systems, Man, and Cybernetics, Part B, 32(4):408–415, 2002.
Alexandru Mateescu, Arto Salomaa, Kai Salomaa, and Sheng Yu. Lexical analysis with a simple finite- fuzzy-automaton model. J. UCS, 1(5):292–311, 1995.
R. Milner. A Calculus of Communicating Systems. Springer Lect. Notes Comp. Sci. (92), 1980.
Robin Milner. Calculi for synchrony and asynchrony. Theor. Comput. Sci., 25:267–310, 1983.
Robin Milner. Turing, Computing and Communication, pages 1–8. Springer Berlin Heidelberg, Berlin, Heidelberg, 01 2006.
John Mordeson and Davender Malik. Fuzzy automata and languages: theory and applications. Chapman and Hall/CRC; 1 edition, 2002.
Witold Pedrycz and Adam Gacek. Learning of fuzzy automata. International Journal of Computational Intelligence and Applications, 1(1):19–33, 2001.
Cristian Prisacariu. Synchronous Kleene algebra. J. Log. Algebr. Program., 79(7):608–635, 2010.
Michael O. Rabin. Probabilistic automata. Information and Control, 6(3):230 – 245, 1963.
Krister Segerberg. A deontic logic of action. Studia Logica, 41(2):269–282, Jun 1982.
Aleksandar Stamenkovic and Miroslav Ciric. Construction of fuzzy automata from fuzzy regular expressions. Fuzzy Sets and Systems, 199:1–27, 2012.
G. H. von Wright. An Essay in Deontic Logic and the General Theory of Action with a Bibliography of Deontic and Imperative Logic. –. North-Holland Pub. Co, 1968.
William Wee and K S. Fu. A formulation of fuzzy automata and its application as a model of learning systems. IEEE Trans. Systems Science and Cybernetics, 5:215–223, 01 1969.
Mingsheng Ying. A formal model of computing with words. IEEE Trans. Fuzzy Systems, 10(5):640– 652, 2002.
