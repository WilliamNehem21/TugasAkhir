Electronic Notes in Theoretical Computer Science 40 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume40.html 28 pages


Metric Semantics and Full Abstractness for Action Reﬁnement and Probabilistic Choice

J.I. den Hartog a, E.P. de Vink b,c and J.W. de Bakker a a Department of Software Engineering, CWI, P.O. Box 94079,
1090 GB Amsterdam, The Netherlands
Faculty of Mathematics and Computer Science, Technical University Eindhoven,
P.O. Box 513, 5600 MB Eindhoven, The Netherlands
LIACS, Leiden University, P.O. Box 9512, 2300 RA Leiden, The Netherlands


Abstract
This paper provides a case-study in the field of metric semantics for probabilistic programming. Both an operational and a denotational semantics are presented for an abstract process language Lpr , which features action refinement and probabilistic choice. The two models are constructed in the setting of complete ultrametric spaces, here based on probability measures of compact support over sequences of actions. It is shown that the standard toolkit for metric semantics works well in the probabilistic context of Lpr , e.g. in establishing the correctness of the denotational semantics with respect to the operational one. In addition, it is shown how the method of proving full abstraction —as proposed recently by the authors for a nondeterministic language with action refinement— can be adapted to deal with the probabilistic language Lpr as well.

Introduction
In this paper we study the applicability of metric techniques for the develop- ment of an operational and a denotational semantics for a nontrivial language, and for their comparison in a probabilistic setting. We have chosen to mix dis- crete probabilistic choice with the construct of action refinement. In [HVB99] we have indicated how, in a nondeterministic setting, an operational and a de- notational semantics can be constructed, the correctness of the denotational model with respect to the operational one can be established, and, moreover, how a full abstractness result can be obtained, all using metric methods. The aim of this paper is to investigate the flexibility of the metric machinery by combination and adaptation of earlier results. It turns out that indeed the various techniques are orthogonal: replacing nondeterminacy by probability does not affect the proof methods.
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


There exist only a few metric models for probabilistic process languages. In [KN98], extending the earlier [KN96], action guarded probabilistic choice is added to a subset of CSP. A full abstractness result is obtained for a metric denotational model with respect to a variant of probabilistic bisimulation as proposed by [LS91]. The semantical interpretation of probability in [KN98] is based on a different quantitative paradigm than the one of the present paper, namely worst-case best-case intervals. Moreover, the denotational semantics is developed in situ and does not appeal to a general methodology of con- structing operational and denotational semantics. A modal logic approach to quantitative process equivalences is reported in [DGJP99]. Van Breugel and Worrel [BW01] have developed a quantitative comparison of probabilistic systems based on the Hutchinson metric exploiting the existence of a final co-algebra in the category of pseudo-metric spaces. In this approach two sys- tems are close if they assign approximately the same probabilities to similar processes. This is different from the approach in this paper were two systems are considered close if they assign exactly the same probability to processes which are close to each other. As far as the probabilistic information is con- cerned, the approach of this paper is qualitative; one can check whether or not two probabilities are the same, but not how far apart two probabilities are. In [BK97] a metric denotational semantics for an extension of CCS with action guarded probabilistic choice is shown to be fully abstract with respect to probabilistic bisimulation. The present paper establishes full abstraction with respect to an operational model. Identification of bisimilar processes (here for probabilistic bisimulation a` la Larsen and Skou) is automatic when working with metric domains obtained as final coalgebras of contracting func- tors (cf. [RT94,VR99,HV99b]). The work of Seidel [Sei95] exploits the mea- sure theoretical apparatus of stochastic kernels for the modeling of CSP-style operators. Apart from the important papers [GSS95,LS91] for probabilistic bisimulation we mention [Chr90,NFL95,GRN98] as fully abstract models for probabilistic choice in the setting of testing semantics.
The construct of action refinement has been studied by several authors in different settings, mostly in the true concurrency framework. An early full abstraction result is [NEL88] where series-parallel pomsets are used for the modeling. Work in the area of Petri-nets includes the approach of Vogler using interval semi-words (cf. [Vog91,Vog92]). A process algebra for action refinement is proposed in [Ace90,AH93]. Gorrieri and co-workers base their semantics [Gor91,DG95,GGR96] on the causal trees of [DD89,DD93]. Other work on the semantics of action refinement includes [CS95,Ren93]. A metric interleaving semantics is presented in [BV94].
The paper [HVB99] studies a process language Lref with action refine- ment and nondeterministic and parallel composition in a metric setting. The domain of meanings consists of compact sets of sequences of actions. It is shown that the denotational semantics given for Lref is fully abstract with respect to the operational semantics presented there. The present paper, de-

voted to the process language Lpr , seeks to adapt the result of [HVB99] from a nondeterministic framework to a probabilistic one. The nondeterministic constructs of nondeterministic and parallel composition of Lref are removed and the construct of probabilistic choice is added in Lpr . Although probability measures of compact support over sequences of actions are used as semanti- cal objects in this paper, our case-study shows that essentially the metrical instruments from [HVB99] remain the same: Banach’s Fixed Point Theorem and the ‘ε ≤ 1 ε-principle’ as general techniques (see, e.g., [BV96]) and the method of proving full abstraction. Moreover, our analysis illustrates that the techniques to deal with action refinement, as introduced in [HVB99], is eligible to be mixed with other elements of the metric approach.
There are no nondeterministic constructs in the language Lpr because the presence of both nondeterminism and probability in the same language cre- ates several modeling issues (see, e.g., [Har98,HV99a,Mis00]). The presence of action refinement does not seem to influence the extension of a probabilistic language to a language containing both nondeterminism and probability. The approach of [Har98] can likely also be used to extend the language Lpr with nondeterministic choice and parallel composition. Full abstractness, however, is not dealt with in [Har98]. To obtain full abstractness for parallel compo- sition with synchronization a more complex approach using failure sets, also exploited in [HVB99], should be used. At present, it is an open question whether failure sets can be easily combined with the probabilistic concepts used in this paper.
The method of proving full abstraction for a denotational semantics Ð with respect to an operational semantics 0 is outlined as follows. The denotational semantics Ð for Lpr has functionality Ð: Lpr → SemRef → P where SemRef, the collection of semantical refinements, is given by SemRef = Act → P, Act is a given set of atomic actions and P is the complete ultrametric space of probability measures of compact support of finite and infinite sequences of actions from Act. The main hurdle to be taken is the proof of completeness for Ð, i.e., to prove the implication

(1.1)
0[[C[s']]] = 0[[C[s'']]] for all contexts C[·] ⇒ Ð(s')= Ð(s'')

for any two statements s', s'' ∈ Lpr . Instead of proving (1.1) directly we focus on its contraposition

(1.2)
Ð(s') /= Ð(s'') ⇒ 0[[C[s']]] /= 0[[C[s'']]] for some context C[·].

So we assume Ð(s') /= Ð(s'') for two statements s', s'' ∈ Lpr . Hence, for some semantical refinement η ∈ SemRef we have that Ð(s')(η) and Ð(s'')(η) are not equal, and that they have therefore a positive distance. Due to the structure of P we then have that d(Ð(s')(η), Ð(s'')(η)) = 2−n for some n ≥ 0. We sub- sequently choose a so-called finitary semantical refinement η' ∈ SemRef for which d(Ð(s')(η'), Ð(s'')(η')) = 2−n as well. Thus, we can restrict our atten- tion to finitary η' only, without altering the distance of Ð(s') and Ð(s''). The crucial property of finitary semantical refinements, such as η', is that in the

setting of Lpr they can be represented by a finite sequences ⟨ai ❀ si⟩n
of action refinements.	More precisely, we can find actions a1,..., an and

statements s1,..., sn such that Ð(s)(η') = Ð(s⟨ai ❀ si⟩n
)(ηid ) for any

statement s ∈ Lpr (where ηid is the so-called empty semantical refinement which essentially does not alter the meaning of any action s). We thus ob-

tain d(Ð(s'⟨ai ❀ si⟩n
)(ηid ), Ð(s''⟨ai ❀ si⟩n
)(ηid )) = 2−n. The correct-

ness result for the denotational semantics yields, for any statement s, that

Ð(s)(ηid ) = 0[[s]].	So, we derive, putting C[·] = (·)⟨ai ❀ si⟩n
, that

d(0[[C[s']]], 0[[C[s'']]]) = 2−n and therefore 0[[C[s']]] /= 0[[C[s'']]] as was re- quired for proving (1.2).
The remainder of this paper is organized as follows. Section 2 presents some mathematical preliminaries and some notation. The language Lpr and its operational semantics is introduced in Section 3, while Section 4 is devoted to the denotational semantics Ð for Lpr . The correctness of the model Ð with respect to the semantics 0 is subject of Section 5, whereas the full abstraction result is discussed in Section 6. Finally, Section 7 addresses some concluding remarks.

Mathematical preliminaries
We assume a basic understanding of elementary metric topology and basic measure theory, in particular the notions of complete metric space, closed and compact subset, and σ-algebra and Borel probability measure. We refer to [BV96] or standard textbooks on general topology such as [Dug76,Eng89] for more details on the former topic, and to [Rud66,Hal74] for more information on the latter.
A metric space X is said to be an ultrametric space if, for all x, y, z ∈ X, it holds that d(x, z) ≤ max{ d(x, y), d(y, z) }. We use Bε(x) with ε> 0 and some element x in a metric space (X, d) to denote the open ball of radius ε and center x. Often the metric d is left implicit. We call a function f : X1 → X2 between metric spaces (X1, d1) and (X2, d2) nonexpansive if d2(f (x),f (y)) ≤ d1(x, y) for all x, y ∈ X1. The mapping f is called a contraction if there exists a real number α, 0 ≤ α < 1 such that d2(f (x),f (y)) ≤ α · d1(x, y) for all x, y ∈ X1. In the latter situation we also refer to f as an α-contraction.
The following version of Banach’s Fixed Point Theorem will be frequently applied in the sequel.
Theorem 2.1 A contraction f : X → X on a complete metric space (X, d) has a unique ﬁxed point fix(f ) in X. Moreover, if X0 ⊆ X is a nonempty and closed subset such that f (x) ∈ X0 when x ∈ X0, then it holds that fix(f ) ∈ X0.
The semantical models discussed in this paper are based on the collection Act∞ of finite and infinite sequences or words over the alphabet Act and on Borel probability measures on Act∞.  We endow the set Act∞ with the so-called



Baire metric dB given by

dB (w, v)= 2− sup{ n|w[n]=v[n] }

where w[n], v[n] denote the prefixes of w, v of length n. As a consequence we have dB(a · w, a · v) = 1 dB(w, v) and dB(a · w, b · v) = 1 for a /= b. It holds
2
that (Act∞,d 
B) is a complete ultrametric space.
A Borel probability measure p on Act∞ is said to be of compact support if there exists a compact set K ⊆ Act∞ such that p(O)=0 iff O ∩ K = ∅ for every open O ⊆ Act∞. The collection M(Act∞) of Borel probability measures of compact support comes equipped with the Hutchinson-metric
dH(p, p') = inf{ ε | p(Bε(w)) = p'(Bε(w)) }.
It holds that M(Act∞) is a complete ultrametric space (cf. [VR99]).  For
a ∈ Act and p ∈ M(Act∞) the Borel probability measure a · p is given by

(a· p)(B)= p(B/a) for Borel-sets B ⊆ Act∞ where B/a df
{ w | a· w ∈ B}. In

fact a· p is the measure p along prefa, i.e. a· p = p◦ pref−1, with prefa: Act∞ →
Act∞, prefa(w)= a · w. We have that

(2.1)
dH(a · p, a · p')= 1 dH(p, p').

For w ∈ Act∞ the Dirac-measure Dir(w) is defined as w(B) = 1 if w ∈ B, w(B) = 0 otherwise for any Borel set B ⊆ Act∞. For m ≥ 1, 0 ≤ ρ1,..., ρm ≤ 1 such that ρ1 + ··· + ρm = 1 and p1,..., pm ∈ M(Act∞), the
convex combination  m ρi ∗pi is given by ( m ρi ∗pi)(B)= Σm ρi · pi(B)
for any Borel set B ⊆ Act∞. We have the following basic property:
m	m

(2.2)
dH(   ρi ∗ pi,   ρi ∗ p') ≤ max{ dH(pi, p') | 1 ≤ i ≤ m }

i=1
i	i
i=1

for arbitrary pi, p' ∈ M(Act∞).
For a nonempty set V and a metric space X let V → X denote the collec- tion of all functions from V to X. The set V → X is endowed with the distance of pointwise convergence inherited from X, i.e., d(f, g)= sup{ d(f (v), g(v)) | v ∈ V } for f, g: V → X. If X is a complete ultrametric space, then V → X is a complete ultrametric space as well. For metric spaces X and Y we denote by X →1 Y the collection of all nonexpansive mappings from X to Y . We consider X →1 Y to be a subspace of X → Y . We have that completeness of Y implies completeness of X →1 Y .
Operational semantics
In this section we introduce the process language Lpr and present its opera- tional semantics 0. The model 0 will serve as a point of reference for our understanding of Lpr and for the semantical considerations in later sections. We start off with the syntax for Lpr .
Definition 3.1 Let Act and PVar be given syntactical classes of countably infinite many actions and procedure variables, respectively. The language Lpr ,

ranged over by s, is then given by
s ::= a | s; s | s ⊕π s | s⟨a ❀ s⟩| x,
where a and x range over Act and PVar and 0 <π < 1.
Elements of Lpr are referred to as statements. The language Lpr contains the usual ingredients of abstract, uninterpreted actions a, sequential composi- tion s1; s2 and recursion via procedure variables. More specific constructions in Lpr are the construction of probabilistic choice s1 ⊕π s2 and of action re- finement s1⟨a ❀ s2⟩.
The intuition behind the construct s1 ⊕π s2 is that upon its execution, with probability π the alternative s1 is taken, and with the complementary probability 1 − π the alternative s2 is executed. The idea underlying action refinement is that in s1⟨a ❀ s2⟩ the actions of s1 are performed, but with the execution of s2 replacing the execution of actions a of s1. So, for example, a ⊕1/4 (b; c) delivers, on the average, in 25% of the cases a and in 75% the sequence bc. Instead ((a ⊕1/4 (b; c))⟨a ❀ b; d⟩)⟨c ❀ d⟩ will have bd for all of its executions.
In order to cater for recursion we assume that some declaration D: PVar → Stat is given, such that for x ∈ PVar, the statement D(x) is guarded. (Here we define that each action a is guarded, that s1; s2 is guarded if s1 is guarded, and that s1 ⊕π s2 and s1⟨a ❀ s2⟩, respectively, are guarded if both s1 and s2 are guarded.)
The transition system for Lpr makes use of so-called refinement sequences in order to keep track of the relevant action refinements. As states of the tran- sition system we choose resumptions which typically consist of sequential and probabilistic compositions of pairs of a statement and a refinement sequence.
Definition 3.2
The class Ref of reﬁnement sequences is given by
R ::= ϵ | ⟨a ❀ s⟩· R,
where ϵ is a fresh symbol representing the empty sequence. Ref is ranged over by R.
The class Res, the elements of which are called resumptions and ranged over by r, is given by
r ::= E | s : R | r; r | r ⊕ρ r,
where E is a fresh symbol and R is a refinement sequence as introduced in part (a).
Below we also employ the notation ⟨a1 ❀ s1⟩⟨a2 ❀ s2⟩··· ⟨an ❀ sn⟩ for arbitrary refinement sequences, and the notion R · ⟨a ❀ s⟩ for nonempty refinement sequences. We will furthermore identify E; r with the resumption r. In the transition system as given by Definition 3.3 below, we make use of

schemes of the form r1 →D,0 r2 which are shorthand for rules of the form
r →λ	r

r →λ	r
indicating that if the resumption r1 makes a λ-transition to the resumption r then so does the resumption r2. For π such that 0 <π < 1 we use πc to denote 1 − π.
Definition 3.3 Define the set Lab, ranged over by λ, as Lab = Act ∪ (0, 1). The transition system →⊆ Res × Lab × Res is given by the following axioms and rules:
a


r →λ	'
•

(Seq)

r ; r →λ	r' ; r
1	2	D  1	2

π	πc
r1 ⊕π r2 →D r1	r1 ⊕π r2 →D r2	(PChoice 1,2)
The axiom (Act 1) and rules (Act 2) and (Act 3) reflect the stack-like book- keeping for action refinement. The leftmost component of a refinement se- quence applies, if the action to be refined, viz. a', matches the action in the control part of the resumption, viz. a; otherwise the action refinement is skipped. If no action refinement is left on the stack, i.e. the refinement sequence in the resumption is the empty sequence ϵ, the action a itself is executed as indicated by the label a ∈ Act ⊆ Lab of the axiom (Act 1).
Procedure variables are handled by means of body replacement using the implicitly given declaration D. Sequential and probabilistic composition in the control part of a resumption, i.e. for resumptions of the format (s1 ∗ s2): R, distribute over the pair-constructor ‘ :’ of resumptions ‘yielding’ (s1 : R) ∗ (s2 : R). Similarly, an action refinement s⟨a' ❀ s'⟩ in the control part of a resumption s⟨a' ❀ s'⟩ : R amounts to an update of the refinement sequence of the resumption, where the action refinement ⟨a' ❀ s'⟩ is prefixed to the sequence R. A sequential composition of resumptions is handled as usual.

A probabilistic choice between resumptions is resolved by selection of one of the probabilistic alternatives while delivering its probability as a label π or 1 − π in the open interval (0, 1) ⊆ Lab. Note that we suppress the issue of multiplicity of transitions. The typical example being the transitions for the statement a ⊕1/2 a. There are several techniques to handle this, e.g., considering multi-sets of transitions or using a regime of indices.
Examples Consider the resumption (a ⊕1/4 (b; c)) : ϵ. Since
1

(a : ϵ) ⊕	((b; c): ϵ) →4	(a : ϵ)

by (PChoice 1), we have

Similarly, since


1

(a ⊕	(b; c)) : ϵ →4	a : ϵ.

3

(a : ϵ) ⊕	((b; c): ϵ) →4	((b; c): ϵ)
by (PChoice 2), we have
3

(a ⊕	(b; c)) : ϵ →4	(b; c): ϵ.
For the resumption (((a ⊕1/4 (b; c))⟨a ❀ b; d⟩)⟨c ❀ d⟩) : ϵ we have, applying the shorthand of the →D,0 -notation, for example
(((a ⊕1/4 (b; c))⟨a ❀ b; d⟩)⟨c ❀ d⟩): ϵ
→D,0 ((a ⊕1/4 (b; c))⟨a ❀ b; d⟩): ⟨c ❀ d⟩ by (Ref)
→D,0 (a ⊕1/4 (b; c)) : ⟨a ❀ b; d⟩· ⟨c ❀ d⟩ by (Ref)
→D,0 (a : ⟨a ❀ b; d⟩· ⟨c ❀ d⟩) ⊕1/4 ((b; c): ⟨a ❀ b; d⟩· ⟨c ❀ d⟩) by (Op)
1

→4	a : ⟨a ❀ b; d⟩· ⟨c ❀ d⟩ by (PChoice 1)
In turn, considering the resumption a : ⟨a ❀ b; d⟩· ⟨c ❀ d⟩ we have
a : ⟨a ❀ b; d⟩· ⟨c ❀ d⟩
→D,0 (b; d): ⟨c ❀ d⟩ by (Act 2)
→D,0 (b : ⟨c ❀ d⟩); (d : ⟨c ❀ d⟩) by (Op)
→D,0 (b : ϵ); (d : ⟨c ❀ d⟩) by (Act 3),(Seq)
→b	d : ⟨c ❀ d⟩ by (Act 1),(Seq).

Often structural induction is not a suitable proof technique in the semantical investigations below, due to the presence of procedure variables in Lpr . Instead we call upon so-called wgt-induction which is based on the transition system for Lpr . In particular, we will directly obtain from the definition of the wgt- function on Res –to be given in a minute– that wgt(r') < wgt(r) if r →D,0 r'.

Definition 3.4
The function wgt: Lref → N is given by
wgt(a) = 1 
wgt(s1; s2) = wgt(s1)+1 
wgt(s1 ⊕ρ s2) = wgt(s1)+ wgt(s2)+1 
wgt(s1⟨a ❀ s2⟩) = wgt(s1)+ wgt(s2)+1 
wgt(x) = wgt(D(x)) + 1.
The function wgt: Res → N is given by
wgt(E) = 0
wgt(s : ⟨a1 ❀ s1⟩⟨a2 ❀ s2⟩··· ⟨an ❀ sn⟩)
= wgt(s)+ wgt(s1)+ wgt(s2)+ ··· + wgt(sn)
wgt(r1; r2) = wgt(r1)+1 
wgt(r1 ⊕ρ r2) = wgt(r1)+ wgt(r2)+ 1.
Note that the well-definedness of wgt relies on the guardedness of the state- ments D(x) for x ∈ PVar. We will adopt the notation r ⇒D π ∗ r1 ⊕ πc ∗ r2

in case both r →π
D r1
and r πc
r2. Here it is not necessarily the case that r

equals r1 ⊕π r2 (cf. the examples following Definition 3.3).
A first application of the technique of wgt-induction is the following struc- tural property of the transition system.
Lemma 3.5 For all r ∈ Res exactly one of the following cases holds:
r = E
r →a  r' for some a ∈ Act, r' ∈ Res
r ⇒D π ∗ r' ⊕ πc ∗ r'' for some r', r'' ∈ Res and π ∈ (0, 1).
Proof. We only consider the cases for a sequential composition of resump- tions. The other cases are straightforward. Suppose r ≡ r1; r2. Note, r1 /≡ E as E; r2 is identiﬁed with r2. As wgt(r1) < wgt(r) we have by the induction
hypothesis that either r →a	r' or r  ⇒	π ∗ r' ⊕ πc ∗ r''. Therefore, by (Seq),
a	1	D  1	1	D	1	1
r1; r2 →D r' ; r2 or r1; r2 ⇒D  π ∗ (r' ; r2) ⊕ πc ∗ (r''; r2). From inspection of
1	1	1
the transition system we obtain that, for a resumption of the format of r only
rule (Seq) of the transition system applies. Hence, if r →λ	r' then there exist

r ,r , r' such that r ≡ r ; r , r →λ	r' and r' ≡ r' ; r
from which it follows

1	2	1	1	2	1	D  1	1	2
that exactly one of the three cases above holds for a sequential composition of
resumptions.	✷
The lemma above states that a resumption is either a terminating resumption
(i.e. r ≡ E), a deterministic resumption (i.e. ∃a, r': r →a	r'), or a probabilistic
D


resumption (i.e. ∃π, v', v'': v ⇒D π ∗ v' ⊕ πc ∗ v''). This fact will be exploited in the definition of the operational semantics for Lpr .
Definition 3.6
The semantical mapping 0: Res → M(Act∞) is given by
0(E) = ϵ
0(v) = a · 0(v') if v →a	v'
0(v) = π ∗ 0(v') ⊕ πc ∗ 0(v'') if v ⇒D π ∗ v' ⊕ πc ∗ v''
The operational semantics 0[[·]]: Stat → M(Act∞) is given by 0[[s]] =
0(s : ϵ).
We choose to deliver a probability measure over finite and infinite sequences of actions as the meaning of a statement from Lpr . The intuition is that execution of a statement yields, in general, several runs of actions with a cer- tain probability. The distribution assigning the associated probability to a sequence of actions thus reflects the computational essence of the statement. Because infinitely many and infinite sequences may occur as possible compu- tations (e.g. for x where D(x)= a ⊕1/4 (a; x) and for y where D(y)= b; y), we have to resort to the more general probability measures.
Examples
0((a ⊕1/4 (b; c)) : ϵ)
= 1 ∗ 0(a : ϵ) ⊕ 3 ∗ 0((b; c): ϵ)
4	4
as (a ⊕1/4 (b; c)) : ϵ ⇒D 1 ∗ (a : ϵ) ⊕ 3 ∗ ((b; c): ϵ)
4	4

= 1 ∗ a · 0(E) ⊕ 3 ∗ b · 0(c : ϵ) as a : ϵ →a	E and (b; c): ϵ →b
c : ϵ

4	4	D	D
= 1 ∗ a · Dir(ϵ) ⊕ 3 b · c · Dir(ϵ) as 0(E) and c →c	E
4	4	D
= 1 ∗ Dir(a) ⊕ 3 ∗ Dir(bc).
4	4
0((((a ⊕1/4 (b; c))⟨a ❀ b; d⟩)⟨c ❀ d⟩): ϵ)
= 1 ∗ 0(a : ⟨a ❀ b; d⟩⟨c ❀ d⟩) ⊕ 3 ∗ 0((b; c): ⟨a ❀ b; d⟩⟨c ❀ d⟩)
4	4
as (a ⊕1/4 (b; c))⟨a ❀ b; d⟩⟨c ❀ d⟩ ⇒D
1 ∗ (a : ⟨a ❀ b; d⟩⟨c ❀ d⟩) ⊕ 3 ∗ ((b; c): ⟨a ❀ b; d⟩⟨c ❀ d)⟩
4	4
= 1 ∗ b · 0(d : ⟨c ❀ d⟩) ⊕ 3 · b · 0(c : ⟨a ❀ b; d⟩⟨c ❀ d⟩)
4	4
as a : ⟨a ❀ b; d⟩⟨c ❀ d⟩ →b D d : ⟨c ❀ d⟩
and (b; c): ⟨a ❀ b; d⟩⟨c ❀ d⟩ →b D c : ⟨a ❀ b; d⟩⟨c ❀ d⟩


= 1 ∗ b · d · 0(E) ⊕ 3 · b · d · 0(E)
4	4
as d : ⟨c ❀ d⟩ →d	E and c : ⟨a ❀ b; d⟩⟨c ❀ d⟩ →d	E
= 1 ∗ Dir(bd) ⊕ 3 ∗ Dir(bd)
4	4
= Dir(bd).
Next we compute 0(x : ϵ) where D(x)= a ⊕1/2 (a; x). For this it turns out to be convenient to exploit the metric foundation of 0. On the one hand we have

(3.1)
0(x : ϵ)= 1 ∗ a · 0(ϵ) ⊕ 1 ∗ a · 0(x : ϵ).

2	2
On the other hand we have for the probability measure p ∈ M(Act∞)
given by p = 1 ∗Dir(a)⊕ 1 ∗Dir(aa)⊕ 1 ∗Dir(aaa)⊕· · · =  ∞	1 n∗Dir(an)
			

2
that p satisfies
(3.2)
4	8

p = 1 ∗ Dir(a) ⊕ 1 ∗ a · p.
n=1 2

2	2
We claim that 0(x : ϵ)= p. This can be shown by the following metric argument:
d(0(x : ϵ), p)
= [equations (3.1), (3.2)] d( 1 ∗Dir(a) ⊕ 1 ∗a·0(x : ϵ), 1 ∗Dir(a) ⊕ 1 ∗a· p)
2	2	2	2
≤ [property (2.2)] max{ d(Dir(a), Dir(a)), d(a · 0(x : ϵ),a · p) }
= [property (2.1)] 1 d(0(x : ϵ), p).
We conclude that d(0(x : ϵ), p) = 0 and hence, since M(Act∞) is a metric space, that 0(x : ϵ)= p.
Although it holds that wgt(v) > wgt(v1), wgt(v2) if v ⇒D π ∗ v1 ⊕ πc ∗ v2 there is in general no structural relationship nor a comparison in wgt for v at the right-hand side and v' at the left-hand side of the second clause of Definition 3.6. Therefore the definition of 0 needs further justification. We introduce a higher-order transformation Φ: Sem → Sem and check that Φ is a contraction on a complete metric space. Then, by Banach’s Fixedpoint Theorem, there exists a unique fixedpoint of Φ, which must equal 0 by its definition.
Lemma 3.7 Put Sem = Res → M(Act∞). The higher-order transformation
Φ: Sem → Sem is given by
Φ(S)(E) = ϵ
Φ(S)(v) = a · S(v') if v →a D v'
Φ(S)(v) = π ∗ Φ(S)(v') ⊕ πc ∗ Φ(S)(v'') if v ⇒D π ∗ v' ⊕ πc ∗ v''
for S ∈ Sem. Then Φ is well-deﬁned and 1 -contractive.
Proof. Well-deﬁnedness of Φ follows from the fact that wgt(v'), wgt(v'') <


wgt(v) if v ⇒D π ∗ v' ⊕ πc ∗ v''. In order to show 1 -contractiveness of Φ we

check

d(Φ(S1)(v), Φ(S2)(v)) ≤ 1 d(S1, S2)

for arbitrary S1, S2 ∈ Sem by distinguishing three cases. The case for E is clear.
[v →a	v']	d(Φ(S )(v), Φ(S )(v))
= d(a · S1(v'),a · S2(v'))
= [property (2.1)]  1 d(S1(v'), S2(v'))
≤ [deﬁnition d on Sem] 1 d(S1, S2)
[v ⇒D π ∗ v' ⊕ πc ∗ v'']	d(Φ(S1)(v), Φ(S2)(v))
= d(π ∗ Φ(S1)(v') ⊕ πc ∗ Φ(S1)(v''),π ∗ Φ(S2)(v') ⊕ πc ∗ Φ(S2)(v''))
= [property (2.2)]
max{ d(Φ(S1)(v'), Φ(S2)(v')), d(Φ(S1)(v''), Φ(S2)(v'')) }
≤ [induction hypothesis on v', v''] 1 d(S1, S2).
✷

Denotational semantics
The operational semantics 0 is of a step-oriented nature. The model 0 re- flects the computational intuition underlying the process language Lpr . In this section we present a denotational semantics Ð for Lpr . Traditionally, this implies that Ð has the following characteristic properties:
Ð maps statements into a mathematical domain (here, a complete ultra- metric space)
compositionality, i.e. the meaning Ð(s1 ∗ s2) of a composition s1 ∗ s2 in Lpr is obtained from a composition Ð(s1) ∗ Ð(s2) of the meanings Ð(s1) of s1 and Ð(s2) of s2
recursion is handled via a fixed point construction (here, Banach’s Fixed Point Theorem).
First we present our mathematical domain.
Definition 4.1 The domain of denotations P is given by P = M(Q) where
Q = Act∞ \ {ϵ}.
The metavariables p and q are used to range over P and Q, respectively. The re- striction to measures over nonempty words is necessary for proving Lemma 4.6 which is in turn crucial in proving the fixed point characterization of Ð in Lemma 4.8. We have that every element in P can be written in one of the

following three forms:
the indicator function Dir(a) for some a ∈ Act
a · p for some a ∈ Act, p ∈ P

m
ρi ∗ pi for ρi ∈ (0, 1), pi = ai or pi = ai · p' with ai ∈ Act, p' ∈ P and

Σi=1 ρ  = 1.
The fact that a finite combination in the third clause for the representation of elements in P suffices, follows from the observation that in P only measures of compact support are considered.
Next we provide semantical counterparts of the syntactical construction of the sequential and probabilistic compositions ‘ ;’ and ‘ ⊕π’.
Definition 4.2
The semantical operator ‘ ;’: P × P → P is given by
Dir(a); p = a · p
(a · p); p' = a · (p; p')

m i=1
ρi ∗ pi); p' =  m
ρi ∗ (pi; p')

The semantical operator ‘ ⊕π’: P × P → P, for π ∈ (0, 1), is given by
p ⊕π p' = (π ∗ p) ⊕ (πc ∗ p').
The definition of the semantical operator ‘ ;’ needs further comment as ‘ ;’ occurs also at the right-hand side of Definition 4.2. Again, we introduce a higher-order transformation. Now we consider a mapping Ω;: Op → Op on a complete metric space Op and verify the contractivity of Ω;.
Lemma 4.3 Put Op = P × P → P. Deﬁne the higher-order transformation
Ω;: Op → Op by
Ω;(φ)(Dir(a), p') = a · p'
Ω;(φ)(a · p¯, p') = a · φ(p¯, p')
Ω;(φ)(  m  ρi ∗ pi, p') =  m  ρi ∗ Ω;(φ)(pi, p').
Then Ω; is well-deﬁned and 1 -contractive.
Proof. Well-deﬁnedness of Ω; is clear. In the third clause each pi is either of the format pi = Dir(ai) or pi = ai · p¯i, which are covered by the other clauses. To show that Ω; is contractive we prove, for arbitrary φ1, φ2 ∈ Op, p, p' ∈ P,
d(Ω;(φ1)(p, p'), Ω;(φ2)(p, p')) ≤ 1 d(φ1, φ2)
from which, by deﬁnition of d on Op, it follows that d(Ω;(φ1), Ω;(φ2)) ≤
1 d(φ1, φ2). We distinguish three cases:
[a]	d(Ω;(φ1)(a, p'), Ω;(φ2)(a, p')) = d(a · p',a · p')=0 [a · p¯]	d(Ω;(φ1)(a · p¯), Ω;(φ2)(a · p¯))
= d(a · φ1(p¯, p'),a · φ2(p¯, p'))

= [property (2.1)] 1 d(φ1(p¯, p'), φ2(p¯, p'))


[  m
≤ 1 d(φ1, φ2)
ρi ∗ pi]	d(Ω;(φ1)(  m


ρi ∗ pi, p'), Ω;(φ2)(  m


ρi ∗ pi, p'))

i=1
= d(  m
i=1
ρi ∗ Ω;(φ1)(pi, p'),  m
i=1
ρi ∗ Ω;(φ2)(pi, p'))

≤ [property (2.2)] max{ d(Ω;(φ1)(pi, p'), Ω;(φ2)(pi, p') | i ∈ I }
≤ [previous cases] 1 d(φ1, φ2).
✷
We next present the denotational semantics Ð for Lpr . In the context of Ð the role of the refinement sequences R as for the operational semantics 0, will now be played by so-called semantical refinements as introduced in [HVB99]. The usage of an extra argument for the semantical mapping Ð is reminiscent of the deployment of so-called environments to handle recursion (see, e.g., [Sto77]).
Definition 4.4 Let the collection SemRef of semantical refinements, ranged over by η, be given by SemRef = Act → P. In particular we distinguish ηid ∈ SemRef such that ηid (a) = Dir(a) for all a ∈ Act. The semantical mapping Ð: Lpr → SemRef → P is given by
Ð(a)(η) = η(a)
Ð(s; s')(η) = Ð(s)(η); Ð(s')(η)
Ð(s ⊕π s')(η) = Ð(s)(η) ⊕π Ð(s')(η)
Ð(s⟨a ❀ s'⟩)(η) = Ð(s)(η[Ð(s')(η)/a])
Ð(x)(η) = Ð(D(x))(η)
The denotational semantics Ð[[·]]: Lpr → P is given by Ð[[s]] = Ð(s)(ηid ).
Note that Definition 4.4 does not go by structural induction (cf. the clause for x) nor does it go by wgt-induction (cf. the clause for s; s'). We first provide some examples of Ð before delving into the well-definedness of Ð.
Examples
Ð(a ⊕1/4 (b; c))(ηid )
= Ð(a)(ηid ) ⊕1/4 Ð(b; c)(ηid )
= 1 ∗ ηid (a) ⊕ 3 ∗ (Ð(b)(ηid ); Ð(c)(ηid ))
4	4
= 1 ∗ Dir(a) ⊕ 3 ∗ (ηid (b); ηid (c))
4	4
= 1 ∗ Dir(a) ⊕ 3 ∗ (Dir(b); Dir(c))
4	4
= 1 ∗ Dir(a) ⊕ 3 ∗ (Dir(bc))
4	4

Ð(((a ⊕1/4 (b; c))⟨a ❀ b; d⟩)⟨c ❀ d⟩)(ηid )
= Ð((a ⊕1/4 (b; c))⟨a ❀ b; d⟩)(ηid [Ð(d)(ηid )/c])
= Ð((a ⊕1/4 (b; c))⟨a ❀ b; d⟩)(ηid [Dir(d)/c])
= Ð((a ⊕1/4 (b; c))(ηid [Dir(d)/c][Ð(b; d)(ηid [Dir(d)/c])/a]))
= ... 
= Ð(a ⊕1/4 (b; c))(ηid [Dir(d)/c, Dir(bd)/a])
= 1 ∗ Ð(a)(ηid [Dir(d)/c, Dir(bd)/a]) ⊕
3 ∗ Ð(b; c)(ηid [Dir(d)/c, Dir(bd)/a])
= ... 
= 1 ∗ Dir(bd) ⊕ 3 ∗ (Dir(b); Dir(d))
4	4
= 1 ∗ Dir(bd) ⊕ 3 ∗ Dir(bd)
4	4
= Dir(bd)
Suppose D(x)= a ⊕1/2 (a; x). On the one hand we have
Ð(x)(ηid )
= Ð(a ⊕1/2 (a; x))(ηid )
= 1 ∗ Ð(a)(η) ⊕ 1 ∗ (Ð(a)(ηid ); Ð(x)(ηid ))
2	2
= 1 ∗ Dir(a) ⊕ 1 ∗ (a · Ð(x)(ηid ))
2	2
On the other hand we have for p =   ∞  ( 1)n ∗ Dir(an) that p = 1 ∗
Dir(a) ⊕ 1 ∗ (a · p). Hence, as for the same example in the context of Section 3, we have
d(Ð(x)(ηid ), p)
= d( 1 ∗ Dir(a) ⊕ 1 ∗ (a · Ð(x)(ηid )), 1 ∗ Dir(a) ⊕ ∗(a · p))
2	2	2
≤ [property (2.2)] max{ d(Dir(a), Dir(a)), d(a · Dir(x)(ηid ),a · p) }
= [property (2.1)] 1 · d(Ð(x)(ηid ), p).

Therefore, d(Dir(x)(ηid
), p)=0 and Ð(x)(ηid
∞
i=1
( 1)n ∗ Dir(an).

We first establish some nonexpansiveness/contractivity properties and dis- tributivity results of the semantical operators that are needed for the justifi- cation of the definition of Ð in the sequel.
Lemma 4.5 The semantical operator ‘ ;’ is nonexpansive in its ﬁrst argument and 1 -contractive in its second argument.
Proof. Deﬁne the subset Op0 ⊆ Op by φ ∈ Op0 ⇐⇒ d(φ(p, p''), φ(p', p'')) ≤
d(p, p') ∧ d(φ(p, p'), φ(p, p'')) ≤ 1 d(p', p''). Note that Op0 ⊆ Op is a nonempty

and closed subset. We check that φ ∈ Op0 implies Ω;(φ) ∈ Op0 and then apply Theorem 2.1.
Pick any φ ∈ Op0 and choose arbitrary p, p', p'' ∈ P. We verify the inequal- ity d(Ω;(φ)(p, p''), Ω;(φ)(p', p'')) ≤ d(p, p'). Without loss of generality (leaving the details to the reader) we can assume d(p, p') < 1 . We distinguish three
cases.
[p = a, p' = a]	Clear.
[p = a · p¯, p' = a · p¯']	We have that d(p, p')= 1 d(p¯, p¯').
d(Ω;(φ)(p, p''), Ω;(φ)(p', p''))
= d(a · φ(p¯, p'),a · φ(p¯', p''))
= 1 d(φ(p¯, p''), φ(p¯', p''))
≤ [property φ] 1 d(p¯, p¯')
= d(p, p')

[p =  m  ρi ∗ pi, p' =  m  ρi ∗ p']	Note that, for i, 1 ≤ i ≤ m, pi, p'
are

either both of the format pi = ai, p'
= ai or both of the format pi =

ai · p¯i, p' = ai · p¯'.
i	i
d(Ω;(φ)(p, p''), Ω;(φ)(p', p''))

= d(  m
ρi ∗ Ω;(φ)(pi, p''),  m
ρi ∗ Ω;(φ)(p', p''))

= max{ d(Ω;(φ)(pi, p''), Ω;(φ)(p'))
≤ [earlier cases] d(p, p').
We conclude that d(Ω;(φ)(p, p''), Ω;(φ)(p', p'')) ≤ d(p, p'). Similarly, one can
prove that d(Ω;(φ)(p, p'), Ω;(φ)(p, p'')) ≤ 1 d(p', p'').	✷
Nonexpansiveness of the semantical operator ‘ ⊕π’ is straightforward. Lemma 4.6 The semantical operator ‘ ⊕π’ is nonexpansive for all π ∈ (0, 1). Proof. Immediate by property (2.2).	✷
Next we establish that probabilistic composition distributes over sequential composition.
Lemma 4.7 For all p, p', p'' ∈ P it holds that (p ⊕π p'); p'' = (p; p'') ⊕π (p'; p'').

Proof. Suppose p =  m
ρi ∗ pi, p' =  n
σj ∗ p' . Then, for any π ∈ (0, 1),

(p ⊕π p'); p''

= ((  m
(π · ρi) ∗ pi) ⊕ (  n
(πc · σj) ∗ p' )); p''

m i=1
(π · ρi) ∗ (pi; p'')) ⊕ ((πc · σj) ∗ (p' ; p''))

= π ∗ (  m
ρi ∗ (pi; p'')) ⊕ πc ∗ (  n
σj ∗ (p' ; p''))

= (π ∗ (p; p'')) ⊕ (πc ∗ (p'; p''))
= (p; p'') ⊕π (p'; p'').
✷
We have now gathered sufficient auxiliary results in order to be able to provide a fixed point characterization for Ð.
Lemma 4.8 Let Sem = Lpr → SemRef →1 P. Deﬁne the higher-order trans- formation Ψ: Sem → Sem by
Ψ(S)(a)(η) = η(a)
Ψ(S)(s; s')(η) = Ψ(S)(s)(η); S(s')(η)
Ψ(S)(s ⊕π s')(η) = Ψ(S)(s)(η) ⊕π Ψ(S)(s')(η)
Ψ(S)(s⟨a ❀ s'⟩)(η) = Ψ(S)(s)(η[Ψ(S)(s')(η)/a]) Ψ(S)(x)(η) = Ψ(S)(D(x))(η)
for S ∈ Sem. Then it holds that:
Ψ is well-deﬁned.
Ψ is 1 -contractive.
Proof.
We check by induction on wgt(s) that Ψ(S)(s) is nonexpansive in η, for any S ∈ Sem. We only cover three cases. (The cases for a and x are straightforward.) Choose η1, η2 ∈ SemRef.
[s; s']  d(Ψ(S)(s; s')(η1), Ψ(S)(s; s')(η2))
= d(Ψ(S)(s)(η1); S(s')(η1), Ψ(S)(s)(η2); S(s')(η2))
≤ [‘ ;’ nonexpansive/contractive]
max{ d(Ψ(S)(s)(η1), Ψ(S)(s)(η2)),
1 d(S(s')(η1), S(s')(η2)) }
≤ [induction hypothesis for s; property S ∈ Sem] d(η1, η2) [s ⊕π s']	d(Ψ(S)(s ⊕π s')(η1), Ψ(S)(s ⊕π s')(η2))
= d(Ψ(S)(s)(η1) ⊕π Ψ(S)(s')(η1),
Ψ(S)(s)(η2) ⊕π Ψ(S)(s')(η2))
≤ [‘ ⊕’ nonexpansive]
max{ d(Ψ(S)(s)(η1), Ψ(S)(s)(η2)),
d(Ψ(S)(s')(η1), Ψ(S)(s')(η2)) }


≤ [induction hypothesis for s, s'] d(η1, η2)
[s⟨a ❀ s'⟩]	d(Ψ(S)(s⟨a ❀ s'⟩)(η1), Ψ(S)(s⟨a ❀ s'⟩)(η2))
= d(Ψ(S)(s)(η1[Ψ(S)(s')(η1)/a]),
Ψ(S)(s)(η2[Ψ(S)(s')(η2)/a]))
= [induction hypothesis for s] d(η1[Ψ(S)(s')(η1)/a], η2[Ψ(S)(s')(η2)/a])
≤ [deﬁnition d on SemRef]
max{ d(η1, η2), d(Ψ(S)(s')(η1), Ψ(S)(s')(η2)) }
≤ [induction hypothesis for s'] d(η1, η2)
We prove by induction on wgt(s) that
d(Ψ(S1)(s)(η), Ψ(S2)(s)(η)) ≤ 1 d(S1, S2)

for any S1, S2 ∈ Sem, s ∈ Lpr , η ∈ SemRef. We treat three cases (leaving the cases of a and x to the reader).
[s; s']	d(Ψ(S1)(s; s')(η), Ψ(S2)(s; s')(η))
= d(Ψ(S1)(s)(η); S1(s')(η), Ψ(S2)(s)(η); S2(s')(η))
≤ [‘ ;’ nonexpansive/contractive]
max { d(Ψ(S1)(s)(η), Ψ(S2)(s)(η)),
1 d(S1(s')(η), S2(s')(η)) }
≤ [induction hypothesis for s; deﬁnition d on Sem]
1 d(S1, S2)
[s ⊕π s']	d(Ψ(S1)(s ⊕π s')(η), Ψ(S2)(s ⊕π s')(η))
= d(Ψ(S1)(s)(η) ⊕π Ψ(S1)(s')(η),
Ψ(S2)(s)(η) ⊕π Ψ(S2)(s')(η))
≤ [‘ ⊕π’ nonexpansive]
max{ d(Ψ(S1)(s)(η), Ψ(S2)(s)(η)),
d(Ψ(S1)(s')(η), Ψ(S2)(s')(η)) }
≤ [induction hypothesis for s, s']  1 d(S1, S2)
[s⟨a ❀ s'⟩]	d(Ψ(S1)(s⟨a ❀ s'⟩)(η), Ψ(S2)(s⟨a ❀ s'⟩)(η))


= d(Ψ(S1)(s)(η[Ψ(S1)(s')(η)/a]),
Ψ(S2)(s)(η[Ψ(S2)(s')(η)/a]))
≤ [ultrametricity]
max{ d(Ψ(S1)(s)(η[Ψ(S1)(s')(η)/a]),
Ψ(S1)(s)(η[Ψ(S2)(s')(η)/a])),
d(Ψ(S1)(s)(η[Ψ(S2)(s')(η)/a]),
Ψ(S2)(s)(η[Ψ(S2)(s')(η)/a])) }
≤ [Ψ(S1)(s) nonexpansive in η; induction hypothesis for s]
max{ d(Ψ(S1)(s')(η), Ψ(S2)(s')(η)), 1 d(S1, S2) }
= [induction hypothesis for s'] 1 d(S1, S2).	✷
Note the usage above of the ultrametricity, i.e. the strong triangle inequality, which holds for the space M(Act∞ \ {ϵ}).
Correctness
In this section we will establish the correctness of the denotational semantics Ð for Lpr with respect to its operational model 0[[·]]. As the functionality of Ð differs form that of 0, viz.  Ð: Lpr → SemRef → M(Act∞ \ {ϵ}) versus 0: Res → M(Act∞) we will use an intermediate function E that is based on Ð for its definition, but agrees with 0 for its functionality. The main lemma of this section, Lemma 5.2, exploits Banach’s Fixed Point Theorem to show that 0 and E in fact coincide.
First we need a mechanism, as proposed in [HVB99], to combine syntactical refinement sequences R ∈ Ref and semantical refinements η ∈ SemRef.
Lemma 5.1 Let the function · d ·: Ref × SemRef → SemRef be inductively given by
ϵdη = η
(R · ⟨a ❀ s⟩) dη = Rd η[Ð(s)(η)/a].
Then it holds that
(a) Ð(s⟨a1 ❀ s1⟩⟨a2 ❀ s2⟩··· ⟨an ❀ sn⟩)(η) = Ð(s)(⟨a1 ❀ s1⟩⟨a2 ❀
s2⟩··· ⟨an ❀ sn⟩ d η);
(b) Ð(s1⟨a ❀ s2⟩)(Rd η)= Ð(s1)((⟨a ❀ s2⟩· R) d η).
Proof. Induction on n for part (a). Application of part (a) for part (b).	✷
Next we present the intermediate semantical mapping E and prove that E
is a fixed point of the higher order transformation Φ of Lemma 3.7. Since,

by Banach’s Fixed Point Theorem, Φ has exactly one fixed point —which is 0— it follows that 0 = E . The definition of E makes both use of the denotational semantics Ð, for resumptions of the format s : R, and of the semantical operators defined on the domain P, for resumptions of the format v1 ∗ v2 where ‘ ∗’ is either a sequential or a probabilistic operator.
Lemma 5.2 Let the mapping E : Res → M(Act∞) be given as follows:
E (E) = Dir(ϵ)
E (s : R) = Ð(s)(Rd ηid )
E (v1 ∗ v2) = E (v1) ∗ E (v2) for ∗∈ {;, ⊕π}.
Then it holds that Φ(E )= E.
Proof. It is straightforwardly checked that E (v) ∈ P for v /= E, hence E is well-deﬁned. We prove that Φ(E ) = E by weight-induction for resumptions. We only exhibit a few typical cases:
[(s1 ∗ s2): R for ∗∈ {;, ⊕π}]  Φ(E )((s1 ∗ s2): R)
= [transition rule (Op)] Φ(E )((s1 : R) ∗ (s2 : R))
= [induction hypothesis] E ((s1 : R) ∗ (s2 : R))
= [deﬁnition of E] E (s1 : R) ∗ E (s2 : R)
= [deﬁnition of E]  Ð(s1)(Rd ηid ) ∗ Ð(s2)(Rd ηid )
= [deﬁnition of Ð] Ð(s1 ∗ s2)(Rd ηid )
= [deﬁnition of E] E ((s1 ∗ s2): R) [s1⟨a ❀ s2⟩ : R]	Φ(E )(s1⟨a ❀ s2⟩ : R)
= [transition rule (Ref)] Φ(E )(s1 : ⟨a ❀ s2⟩· R)
= [induction hypothesis] E (s1 : ⟨a ❀ s2⟩· R)
= [deﬁnition of E] Ð(s1)((⟨a ❀ s2⟩· R) d ηid )
= [Lemma 5.1] Ð(s1⟨a ❀ s2⟩)(Rd ηid )
= E (s1⟨a ❀ s2⟩ : R)

[v ; v ]	Suppose v →a	v' . Then v ; v →a
v' ; v .

1	2	1	D  1
Φ(E )(v1; v2)
1	2	D  1	2

= [transition rule (Seq)] a · E (v' ; v2)
= [deﬁnition of E] a · (E (v' ); E (v2))
= [deﬁnition ‘ ;’] (a · E (v' )); E (v2)
= [deﬁnition Φ] Φ(E )(v1); E (v2)

= [induction hypothesis for v1] E (v1); E (v2)
= [deﬁnition E] E (v1; v2)
Suppose v1 ⇒D π∗v' ⊕πc ∗v''. Then v1; v2 ⇒D π∗ (v' ; v2) ⊕πc ∗ (v''; v2).
1	1	1	1
Φ(E )(v1; v2)
= [deﬁnition Φ] π ∗ Φ(E )(v' ; v2) ⊕ πc ∗ Φ(E )(v''; v2)
1	1
= [induction hypothesis] π ∗ E (v' ; v2) ⊕ πc ∗ E (v''; v2)
1	1
= [deﬁnition of E] π ∗ (E ((v' ); E (v2)) ⊕ πc ∗ (E (v''); E (v2))
1	1
= [Lemma 4.7] (π ∗ E (v' ) ⊕ πc ∗ E (v'')); E (v2)
1	1
= [deﬁnition Φ] Φ(E )(v1); E (v2)
= [induction hypothesis for v1] E (v1); E (v2)
= [deﬁnition E] E (v1; v2) [v1 ⊕π v2]	Φ(E )(v1 ⊕π v2)
= [transition rules (PChoice)] π ∗ E (v1) ⊕ πc ∗ E (v2)
= [deﬁnition ⊕π] E (v1) ⊕π E (v2)
= [deﬁnition E] E (v1 ⊕π v2).	✷
From the lemma we immediately obtain the correctness result for the denota- tional semantics Ð for Lpr .
Theorem 5.3 For all s ∈ Lpr ,0[[·]] = Ð(s)(ηid ) on Lpr .
Proof. We have 0[[s]] = 0(s : ϵ)= E (s : ϵ)= Ð(s)(ηid ) for any s ∈ Lpr .	✷

Full abstraction
In this section we establish for the semantical mapping Ð: Lpr → SemRef → P full abstraction with respect to 0[[·]], i.e. we will show, for any s1, s2 ∈ Lpr , that
Ð(s1)= Ð(s2) ⇐⇒ 0[[C[s1]]] = 0[[C[s2]]] for all contexts C[·].
The route to the main technical lemma of this section, namely Lemma 6.7, passes the following ideas:
If a statement s has denotations with respect to the semantical refinements η1, η2 of distance 2−(n+1) then the semantical refinements η1, η2 have a dis- tance of at least 2−(n+1) on the collection of the first n actions occuring in any run of s.
A finitary semantical refinement, i.e. a semantical refinement which deliv- ers another denotation than Dir(a) for finitely many actions a only, and

which moreover delivers a convex combination of point measures over finite sequences, can be represented by a syntactical refinement sequence.
The discussion here is restricted to the general outline of the technique and to the particularities for the probabilistic setting of Lpr . In [HVB99] more details can be found for a nonprobabilistic process language with action refinement.
We start with a definition for actn(s) which indicates the first n actions that may occur in a run of a statement s.
Definition 6.1 For n ∈ N and s ∈ Stat, the subset actn(s) of Act is induc- tively given by
act0(s) =  ∅
actn+1(a) = {a}
actn+1(x) = actn+1(s)  where D(x)= s
actn+1(s1; s2) = actn+1(s1) ∪ actn(s2)
actn+1(s1 ⊕π s2) = actn+1(s1) ∪ actn+1(s2)
actn+1(s1⟨a ❀ s2⟩) = (actn+1(s1) \ {a}) ∪ actn+1(s2).
For s ∈ Stat the set act(s) ⊆ Act is given by act(s)=  n actn(s).
The next lemma handles the first idea for the full abstractness theorem below.
Lemma 6.2 Let n ∈ N and s ∈ Stat. If d(η1, η2) ≤ 2−n on actn(s) then it holds that d(Ð(s)(η1), Ð(s)(η2)) ≤ 2−n, for all η1, η2 ∈ SemRef.
Proof. Induction on n and subinduction on wgt(s). In order to illustrate a typical argument, we exhibit the subcase for s1 ⊕π s2 in the case for n + 1: If d(η1, η2) ≤ 2−(n+1) on actn+1(s1 ⊕π s2), then, since actn+1(s1 ⊕π s2) = actn+1(s1) ∪ actn+1(s2), we have that d(η1, η2) ≤ 2−(n+1) on actn+1(s1, s2). Thus, it follows that d(Ð(si)(η1), Ð(si)(η2)) ≤ 2−(n+1) for i = 1, 2, by the induction hypothesis for s1 and s2. By compositionality of Ð and nonexpan- siveness of ⊕π, we obtain
d(Ð(s1 ⊕π s2)(η1), Ð(s1 ⊕π s2)(η2))
≤  max{ d(Ð(s1)(η1), Ð(s1)(η2)), d(Ð(s2)(η1), Ð(s2)(η2)) }
≤ 2−(n+1).	✷
The following lemma is preparatory to the second idea for Theorem 6.8 as reflected by Lemma 6.6. In the proof of Lemma 6.3 we exploit the so-called ‘ ε ≤ 1 ε’-principle. In a metric space two elements coincide iff their distance equals 0. So for a collection of pairs of elements we have equality of their components iff the supremum of their distances is 0. Calling that supremum ε it therefore suffices to show that ε ≤ 1 ε for which 0 is the only nonnegative
real that makes the inequality hold.

Lemma 6.3 It holds that Ð(s)(η1) = Ð(s)(η2), for s ∈ Stat and η1, η2 ∈
SemRef such that η1 = η2 on act(s).
Proof. Deﬁne ε = sup{ d(Ð(s)(η1), Ð(s)(η2)) | η1 = η2 on act(s) }. One shows by induction on wgt(s) that d(Ð(s)(η1), Ð(s)(η2)) ≤ 1 ε. From this it follows that ε = 0. Hence d(Ð(s)(η1), Ð(s)(η2)) = 0 and Ð(s)(η1)= Ð(s)(η2) for s, η1, η2 such that η1 = η2 on act(s). By way of example we provide the case for s1; s2:
d(Ð(s1; s2)(η1), Ð(s1; s2)(η2))
≤ [‘ ;’ nonexpansive/contractive]
max{ d(Ð(s1)(η1), Ð(s1)(η2)), 1 d(Ð(s2)(η1), Ð(s2)(η2)) }
= [induction hypothesis for s1, act(s2) ⊆ act(s1; s2), deﬁnition ε]  1 ε.   ✷
The next lemma involves a technicality having to do with iterated refinement versus simultaneous substitution.
Lemma 6.4
Suppose a1,..., an ∈ Act are pairwise distinct, and s1,..., sn ∈ Stat are such that act(si) ∩{ a1,..., an } = ∅ for 1 ≤ i ≤ n. Then it holds that

Ð(s⟨ai ❀ si⟩n
where pi = Ð(si)(η) for 1 ≤ i ≤ n.
)(η)= Ð(s)(η[pi/ai]n )

Suppose a¯i, a'
(1 ≤ i, j ≤ n) are pairwise distinct. Then it holds that

Ð(s⟨a¯i ❀ a'⟩n )(η)= Ð(s)(η[η(a')/a¯i]n ).
i i=1	i	i=1
Proof. Part (a) goes by induction on n using Lemma 6.3. Part (b) follows from part (a).	✷
We have now arrived at the second idea on our way to the full abstractness of Ð. First we need a definition.
Definition 6.5 A semantical refinement η ∈ SemRef is called ﬁnitary if the following conditions are fulfilled:
for all a ∈ Act it holds that η(a) is a finitary probability distribution over Act+,
η(a) /= {a} for finitely many a ∈ Act.
The crux underlying he proof of Lemma 6.6 is that any convex combination of Dirac-measures of finite words can be syntactically represented. For example, the distribution 1 ∗ Dir(a) ⊕ 1 ∗ Dir(bc) ⊕ 1 ∗ Dir(ade) can be represented by
2	3	6
the statement a⊕1/2 ((b; c) ⊕2/3 (a; d; e)), in the sense that Ð(a⊕1/2 ((b; c) ⊕2/3
(a; d; e)))(ηid )= 1 ∗ Dir(a) ⊕ 1 ∗ Dir(bc) ⊕ 1 ∗ Dir(ade).
2	3	6
Lemma 6.6 Let η ∈ SemRef be a ﬁnitary semantical reﬁnement and A ⊆ Act
a ﬁnite set of actions. Then there exists, for all n ∈ N, a reﬁnement sequence



⟨ai ❀ si⟩k
such that
d(Ð(s)(η), Ð(s⟨ai ❀ si⟩k

)(ηid )) ≤ 2−n,

for all s ∈ Stat with actn(s) ⊆ A.
Proof. If p is a ﬁnitary probability distribution over Act+, say p =  m  ρi∗qi
for m ≥ 1, ρ1,..., ρm > 0 such that ρ1 + ··· + ρm = 1, q1,..., qm ∈ Act+, the
statement stat(p) is given by stat(p)=   m  ρi ∗ stat'(qi) where stat'(a)= a,
stat'(a · q) = a; stat'(q). (Note that Lpr provides binary probabilistic com- position only. Further details on transforming arbitrary ﬁnite probabilistic composition into repeated binary probabilistic is omitted here.) It is straight- forwardly checked that Ð(stat(p))(ηid ) = p by simultaneous induction on m and the lengths of the qi’s.
Suppose a¯1,..., a¯l are all actions a such that η(s) /= a. We are done if we show
d(Ð(s)(η), Ð(s⟨a¯i ❀ stat(η(a¯i))⟩l	)(ηid )) ≤ 2−n.
(Some caution has to be taken though, in order to prevent clashes of actions. See [HVB99].) As η is ﬁnitary, only ﬁnitely many actions are involved. The lemma then follows using Lemma 6.2 and Lemma 6.4.	✷
We have now arrived at the main technical result of this section.
Lemma 6.7 If s', s'' ∈ Stat satisfy Ð(s') /= Ð(s'') then 0[[C[s']]] /= 0[[C[s'']]]
for some context C[·].
Proof. Suppose Ð(s') /= Ð(s''). We can choose η ∈ SemRef and n ∈ N such that d(Ð(s')(η), Ð(s'')(η)) = 2−n. Let η' be ﬁnitary such that d(η, η') ≤ 2−(n+1) on actn(s') ∪ actn(s''). By Lemma 6.2 and ultrametricity we then obtain
d(Ð(s')(η'), Ð(s'')(η')= 2−n.
Pick, applying Lemma 6.6 and again ultrametricity, a reﬁnement sequence

⟨ai ❀ si⟩k
such that
d(Ð(s'⟨ai ❀ si⟩k

)(ηid ), Ð(s''⟨ai ❀ si⟩k

)(ηid )) = 2−n,

hence Ð[[s'⟨ai ❀ si⟩k
]] /= Ð[[s''⟨ai ❀ si⟩k
]]. Deﬁne the context C[·] =

(·)⟨ai ❀ si⟩k  . Then, by Theorem 5.3, it follows that 0[[C[s']]] /= 0[[C[s'']]].✷
The correctness result of Section 5 and Lemma 6.7 have paved the way for a proof of the full abstractness of the semantical mapping Ð with respect to the operational semantics 0[[·]] of Lpr .
Theorem 6.8 Ð: Lref → SemRef → P is fully abstract with respect to 0[[·]].
Proof. Suppose Ð(s1) /= Ð(s2) for two statements s1, s2 ∈ Stat. Then by Lemma 6.7 there exists a context C[·] such that 0[[C[s1]]] /= 0[[C[s2]]]: Sup- pose Ð(s1) = Ð(s2) for two statements s1, s2 ∈ Stat. By deﬁnition of Ð we have, for any context C[·] and semantical reﬁnement η, that Ð(C[s1])(η) = 

Ð(C[s2])(η). In particular Ð[[C[s1]]] = Ð[[C[s2]]], hence 0[[C[s1]]] = 0[[C[s2]]]
by Theorem 5.3. We conclude that, for any s1, s2 ∈ Stat,
Ð(s1)= Ð(s2) ⇐⇒ 0[[C[s1]]] = 0[[C[s2]]] for any context C[·], i.e., Ð: Stat → SemRef → P is fully abstract with respect to 0[[·]].	✷
Concluding remarks
For the abstract process language Lpr with probabilistic choice and action refinement we have developed an operational semantics 0 using syntactic re- finement sequences and a denotational semantics Ð using semantical refine- ments. The denotational semantics is shown to be fully i abstract with respect to the operational model; the denotational semantics identifies exactly those statements that have the same operational meaning in all contexts.
The case-study for Lpr shows that the general techniques for metric op- erational and denotational semantics remain in place in the setting of proba- bilistic programming. In fact, the domain of probability measures of compact support is a suitable complete ultrametric space for the modeling of discrete probabilistic choice, also in the presence of a specific construct such as action refinement. In particular, the method for proving completeness of the denota- tional semantics of [HVB99] —based on the distance of two statements that have different meanings in the denotational model— carries over to the setting of the probabilistic domain.

References
[Ace90] L. Aceto. Action Reﬁnement in Process Algebras. PhD thesis, University of Sussex, 1990.
[AH93] L. Aceto and M. Hennessy. Towards action-refinement in process algebras. Information and Computation, 103:204–269, 1993.
[BK97] C. Baier and M.Z. Kwiatkowska. Domain equations for probabilistic processes (extended abstract). In C. Palamidessi and J. Parrow, editors, Proc. Express’97. ENTCS 7, 1997.
[BV94] J.W. de Bakker and E.P. de Vink. Bisimulation semantics for concurrency with atomicity and action refinement. Fundamenta Informaticae, 20:3– 34, 1994.
[BV96] J.W. de Bakker and E.P. de Vink. Control Flow Semantics. The MIT Press, 1996.
[BW01] Franck van Breugel and James Worrell. Towards quantitative verification of probabilistic transition systems.  In Fernando Orejas, Paul G. Spirkis, and Jan van Leeuwen, editors, Proc. ICALP’01, pages 421–432. LNCS 2076, 2001.


[Chr90] I. Christoff. Testing equivalences and fully abstract models for probabilistic processes. In J.C.M Baeten and J.W. Klop, editors, Proc. CONCUR’90, pages 126–140. LNCS 458, 1990.
[CS95] J.P. Courtiat and D.E. Saidouni. Relating maximality-based semantics to action refinement in process algebras. In D. Hogrefe and S. Leue, editors, Formal Description Techniques VII, pages 292–308. Chapman & Hall, 1995.
[DD89] Ph. Darondeau and P. Degano. Causal trees. In G. Ausiello, M. Dezani- Ciancaglini, and S. Ronchi Della Rocca, editors, Proc. ICALP’89, pages 234–248. LNCS 372, 1989.
[DD93] P. Darondeau and P. Degano. Refinement of actions in event structures and causal trees. Theoretical Computer Science, 118:21–48, 1993.
[DG95] P. Degano and R. Gorrieri. A causal operational semantics of action refinement. Information and Computation, 122:97–119, 1995.
[DGJP99] J. Derarnais, V. Gupta, R. Jagadiasan, and P. Panagaden. Metrics for labelled transition systems. In J.C.M Baeten and S. Mauw, editors, Proc. CONCUR’99, pages 258–273. LNCS 1664, 1999.
[Dug76] J. Dugundji. Topology. Allyn and Bacon, 1976.
[Eng89] R. Engelking. General Topology. Sigma Series in Pure Mathematics 6, Heldermann Verlag, revised and completed edition, 1989.
[GGR96] U. Goltz, R. Gorrieri, and A. Rensink. Comparing syntactic and semantic action refinement. Information and Computation, 125:118–143, 1996.
[Gor91] R. Gorrieri. Reﬁnement, Atomicity and Transactions for Process Description Languages. PhD thesis, University of Pisa, 1991. Also available as Technical Report TD–2/91, Dipartimento di Informatica, Universit`a degli Studi di Pisa.
[GRN98] C. Gregorio-Rodr´iguez and M. Nun˜ez. Denotational semantics for probabilistic refusal testing. In M. Huth and M.Z. Kwiatkowska, editors, Proc. ProbMIV’98. ENTCS 22, 1998.
[GSS95] R.J. van Glabbeek, S.A Smolka, and B. Steffen. Reactive, generative and stratified models of probabilistic processes. Information and Computation, 121:59–80, 1995. Preliminary version (co-authored by C.M.N. Tofts) appeared in Proc. LICS’90, Philadelphia.
[Hal74] P.R. Halmos. Measure Theory, volume 18 of Graduate Texts in Mathematics. Springer, reprint edition, 1974.
[Har98] J.I. den Hartog. Comparative semantics for a process language with probabilistic choice and non-determinism. Technical Report IR–445, Vrije Universiteit, Amsterdam, February 1998.


[HV99a] J.I. den Hartog and E.P. de Vink. Mixing up nondeterminism and probability: A preliminary report. ENTCS, 22, 1999.
[HV99b] J.I. den Hartog and E.P. de Vink. Taking chances on  and fail: Extending strong and probabilistic bisimulation. Technical Report IR–454, Vrije Universiteit, Amsterdam, 1999.
[HVB99] J.I. den Hartog, E.P. de Vink, and J.W. de Bakker. Full abstractness of a metric semantics for action refinement. Fundamenta Informaticae, 40:335–382, 1999.
[KN96] M.Z. Kwiatkowska and G.J. Norman. Probabilistic metric semantics for a simple language with recursion. In Proc. MFCS’96, pages 419–430. LNCS 1113, 1996.
[KN98] M.Z. Kwiatkowska and G.J. Norman. A fully abstract metric-space denotational semantics for reactive probabilistic processes. In Proc. Express’98. ENTCS 13, 1998.
[LS91] K.G. Larsen and A. Skou.  Bismulation through probabilistic testing.
Information and Computation, 94:1–28, 1991.
[Mis00] M. Mislove. Nondeterminism and probabilistic choice: Obeying the laws.
In Proc. CONCUR’00, pages 350–364. LNCS 1877, 2000.
[NEL88] M Nielsen, U. Engberg, and K.S. Larsen.	Fully abstract models for a process language with refinement.	In J.W. de Bakker, W.P. de Roever, and G. Rozenberg, editors, Proc. REX School/Workshop on Linear Time, Branching Time and Partial Order in Logics and Models for Concurrency, pages 523–548. LNCS 354, 1988.
[NFL95] M. Nunez, D. de Frutos, and L. Llana. Acceptance trees for probabilistic processes. In I. Lee and S.A. Smolka, editors, Proc. CONCUR’95, pages 249–263. LNCS 962, 1995.
[Ren93] A. Rensink. Models and Methods for Action Reﬁnement. PhD thesis, University of Twente, 1993.
[RT94] J.J.M.M. Rutten and D. Turi.	Initial algebra and final coalgebra semantics for concurrency.  In J.W. de Bakker, W.-P. de Roever, and
G. Rozenberg, editors, Proc. REX School/Symposium ”A Decade of Concurrency”, pages 530–582. LNCS 803, 1994.
[Rud66] W. Rudin. Real and Complex Analysis. McGraw-Hill, 1966.
[Sei95] K. Seidel. Probabilistic communicating processes. Theoretical Computer Science, 152:219–249, 1995.
[Sto77] J.E. Stoy.	Denotational Semantics—the Scott-Strachey approach to programming language theory. MIT Press, 1977.
[Vog91] W. Vogler.	Failures semantics based on interval semiwords is a congruence for refinement. Distributed Computing, 4:139–162, 1991.


[Vog92] W. Vogler. Modular Construction and Partial Order Semantics of Petri Nets. LNCS 625, 1992.
[VR99] E.P. de Vink and J.J.M.M. Rutten. Bisimulation for probabilistic transition systems: a coalgebraic approach. Theoretical Computer Science, 221:271–293, 1999.
