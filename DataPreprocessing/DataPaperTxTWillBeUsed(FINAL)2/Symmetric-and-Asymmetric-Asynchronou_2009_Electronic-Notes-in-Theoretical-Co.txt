

Electronic Notes in Theoretical Computer Science 229 (2009) 77–95
www.elsevier.com/locate/entcs

Symmetric and Asymmetric Asynchronous Interaction

Rob van Glabbeek1
NICTA, Sydney, Australia
University of New South Wales, Sydney, Australia

Ursula Goltz2	Jens-Wolfhard Schicke3
Institute for Programming and Reactive Systems TU Braunschweig
Braunschweig, Germany


Abstract
We investigate classes of systems based on different interaction patterns with the aim of achieving dis- tributability. As our system model we use Petri nets. In Petri nets, an inherent concept of simultaneity is built in, since when a transition has more than one preplace, it can be crucial that tokens are removed instantaneously. When modelling a system which is intended to be implemented in a distributed way by a Petri net, this built-in concept of synchronous interaction may be problematic. To investigate the problem we assume that removing tokens from places can no longer be considered as instantaneous. We model this by inserting silent (unobservable) transitions between transitions and their preplaces. We investigate three different patterns for modelling this type of asynchronous interaction. Full asynchrony assumes that every removal of a token from a place is time consuming. For symmetric asynchrony, tokens are only removed slowly in case of backward branched transitions, hence where the concept of simultaneous removal actu- ally occurs. Finally we consider a more intricate pattern by allowing to remove tokens from preplaces of backward branched transitions asynchronously in sequence (asymmetric asynchrony ).
We investigate the effect of these different transformations of instantaneous interaction into asynchronous interaction patterns by comparing the behaviours of nets before and after insertion of the silent transitions. We exhibit for which classes of Petri nets we obtain equivalent behaviour with respect to failures equivalence. It turns out that the resulting hierarchy of Petri net classes can be described by semi-structural properties. In case of full asynchrony and symmetric asynchrony, we obtain precise characterisations; for asymmetric asynchrony we obtain lower and upper bounds.
We briefly comment on possible applications of our results to Message Sequence Charts.
Keywords: reactive systems, Petri nets, distributed systems, asynchronous interaction, equivalence notions



1 Email: rvg@cs.stanford.edu
2 Email: goltz@ips.cs.tu-bs.de
3 Email: drahflow@gmx.de


1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.06.040




⇒





Fig. 1. Transformation to the symmetrically asynchronous implementation
Introduction
In this paper, we investigate classes of systems based on different asynchronous in- teraction patterns with the aim of achieving distributability, i.e. the possibility to execute a system on spatially distributed locations, which do not share a common clock. As our system model we use Petri nets. The main reason for this choice is the detailed way in which a Petri net represents a concurrent system, including the interaction between the components it may consist of. In an interleaving based model of concurrency such as labelled transition systems modulo bisimulation se- mantics, a system representation as such cannot be said to display synchronous or asynchronous interaction; at best these are properties of composition operators, or communication primitives, defined in terms of such a model. A Petri net on the other hand displays enough detail of a concurrent system to make the presence of synchronous communication discernible. This makes it possible to study asyn- chronous communication without digressing to the realm of composition operators. In a Petri net, a transition interacts with its preplaces by consuming tokens. An inherent concept of simultaneity is built in, since when a transition has more than one preplace, it can be crucial that tokens are removed instantaneously, depending
on the surrounding structure or—more elaborately—the behaviour of the net.
When modelling a distributed system by a Petri net, this built-in concept of synchronous interaction may become problematic. Assume a transition t on a loca- tion l models an activity involving another location l', for example by receiving a message. This can be modelled by a preplace s of t such that s and t are situated in different locations. We assume that taking a token can in this situation not be considered as instantaneous; rather the interaction between s and t takes time. We model this effect by inserting silent (unobservable) transitions between transitions and their preplaces. We call the effect of such a transformation of a net N an asynchronous implementation of N .
An example of such an implementation is shown in Figure 1. Note that a can be disabled in the implementation before any visible behaviour has taken place. This difference will cause non-equivalence between the original and the implementation under branching time equivalences.
Our asynchronous implementation allows a token to start its journey from a place to a transition even when not all preplaces of the transition contain a token. This design decision is motivated by the observation that it is fundamentally impossible to check in an asynchronous way whether all preplaces of a transition are marked—it

could be that a token moves back and forth between two such places.
We investigate different interaction patterns for the asynchronous implementa- tion of nets. The simplest pattern (full asynchrony) assumes that every removal of a token from a place is time consuming. For the next pattern (symmetric asyn- chrony ), tokens are only removed slowly when they are consumed by a backward branched transition, hence where the concept of simultaneous removal actually oc- curs. Finally we consider a more intricate pattern by allowing to remove tokens from preplaces of backward branched transitions asynchronously in sequence (asymmetric asynchrony ).
Given a choice of interaction pattern, we call a net N asynchronous when there is no essential behavioural difference between N and its asynchronous implementation I(N ). In order to formally define this concept, we wish to compare the behaviours of N and I(N ) using a semantic equivalence that fully preserves branching time, causality and their interplay, whilst of course abstracting from silent transitions. By choosing the most discriminating equivalence possible, we obtain the smallest possible class of asynchronous nets, thus excluding nets that might be classified as asynchronous merely because a less discriminating equivalence would fail to see the differences between such a net and its asynchronous implementation. To simplify the exposition, here we merely compare the behaviours of N and I(N ) up to failures equivalence [6]. This interleaving equivalence abstracts from causality and respects branching time only to some degree. However, we conjecture that our results are in fact largely independent of this choice and that more discriminating equivalences, such as the history preserving ST-bisimulation of [21], would yield the same classes of asynchronous nets. Using a linear time equivalence would give rise to larger classes; this possibility is investigated in [19].
Thus we investigate the effect of our three transformations of instantaneous interaction into asynchronous interaction patterns by comparing the behaviours of nets before and after insertion of the silent transitions up to failures equivalence. We show that in the case of full asynchrony, we obtain equivalent behaviour exactly for conflict-free Petri nets. Further we establish that symmetric asynchrony is a valid concept for N-free Petri nets and asymmetric asynchrony for M-free Petri nets, where N and M stand for certain structural properties; the reachability of such structures is crucial. For symmetric asynchrony we obtain a precise characterisation of the class of nets which is asynchronously implementable. For asymmetric asynchrony we obtain lower and upper bounds.
In the concluding section, we discuss the use of our results for Message Sequence Charts, as an example how they may be useful for other models than Petri nets. When interpreting basic Message Sequence Chart as Petri nets, the resulting Petri nets lie within the class of conflict-free and hence N-free Petri nets. The more expressive classes give insights in the effect of choices in non-basic MSCs.
This is an extended abstract; for sake of brevity most proofs are omitted. They are contained in the full version of this paper [8], as well as in [19].
The paper is structured as follows. In Section 2 we establish the necessary basic notions. In Section 3 we introduce the fully asynchronous transformation and give

a semi-structural characterisation of the resulting net class. In Section 4 we re- peat those steps for the symmetrically asynchronous transformation. Furthermore we describe how the resulting net class relates to the classes of free-choice and ex- tended free choice nets. In Section 5 we introduce the asymmetrically asynchronous transformation. We give semi-structural upper and lower bounds for the resulting net class and relate it to simple and extended simple nets. In the conclusion in Section 6 we compare our findings to similar results in the literature.

Basic Notions
We consider here 1-safe net systems, i.e. places never carry more than one token, but a transition can fire even if pre- and postset intersect. To represent unobservable behaviour, which we use to model asynchrony, the set of transitions is partitioned into observable and silent (unobservable) ones.
Definition 2.1
A net with silent transitions is a tuple N = (S, O, U, F, M0) where
S is a set (of places),
O is a set (of observable transitions),
U is a set (of silent transitions),
F ⊆ S × T ∪ T × S (the flow relation) with T := O ∪ U (transitions) and
M0 ⊆ S (the initial marking ).
Petri nets are depicted by drawing the places as circles, the transitions as boxes, and the flow relation as arrows (arcs) between them. When a Petri net represents a concurrent system, a global state of such a system is given as a marking, a set of places, the initial state being M0. A marking is depicted by placing a dot (token) in each of its places. The dynamic behaviour of the represented system is defined by describing the possible moves between markings. A marking M may evolve into a marking M ' when a nonempty set of transitions G ﬁres. In that case, for each arc (s, t) ∈ F leading to a transition t in G, a token moves along that arc from s to
t. Naturally, this can happen only if all these tokens are available in M in the first place. These tokens are consumed by the firing, but also new tokens are created, namely one for every outgoing arc of a transition in G. These end up in the places at the end of those arcs. A problem occurs when as a result of firing G multiple tokens end up in the same place. In that case M ' would not be a marking as defined above. In this paper we restrict attention to nets in which this never happens. Such nets are called 1-safe. Unfortunately, in order to formally define this class of nets, we first need to correctly define the firing rule without assuming 1-safety. Below we do this by forbidding the firing of sets of transitions when this might put multiple tokens in the same place.
Definition 2.2 Let N = (S, O, U, F, M0) bea net. Let M1, M2 ⊆ S.
We denote the preset and postset of a net element x by •x := {y | (y, x) ∈ F } and
x• := {y | (x, y) ∈ F } respectively. A nonempty set of transitions G ⊆ (O ∪ U ),G /=
∅, is called a step from M1 to M2, notation M1 [G⟩N M2, iff

all transitions contained in G are enabled, that is
∀t ∈ G. •t ⊆ M1 ∧ (M1 \ •t) ∩ t• = ∅ ,
all transitions of G are independent, that is not conflicting :
∀t, u ∈ G, t /= u. •t ∩ •u = ∅ ∧ t• ∩ u• = ∅ ,
in M2 all tokens have been removed from the preplaces of G and new tokens have been inserted at the postplaces of G:

M2 =  M1 \   •t  ∪   t• .

To simplify statements about possible behaviours of nets, we use some abbrevi- ations.
Definition 2.3 Let N = (S, O, U, F, M0) be a net with silent transitions.
−→N ⊆ P(S) × P(O) × P(S) is defined by M1 −G→N M2 ⇔ G ⊆ O ∧ M1[G⟩N M2
−τ→N ⊆ P(S) × P(S) is defined by M1 −τ→N M2 ⇔ ∃t ∈ U. M1 [{t}⟩N M2

• =⇒N
⊆ P(S) × O∗ × P(S) is defined by M1
=t=1 t=2=···=tn⇒
M2 ⇔

τ ∗ {t1}
M
τ ∗ {t2}	τ ∗
τ ∗ {tn}	τ ∗

1 −→N −→N −→N −→N −→N ··· −→N −→N −→N M2
where −τ→∗ denotes the reflexive and transitive closure of −τ→ .
N
We write M1 −G→N for ∃M2. M1 −G→N M2, M1 z−G→N for ∄M2. M1 −G→N M2 and similar for the other two relations.
A marking M1 is said to be reachable iff there is a σ ∈ O∗ such that M0 =σ⇒ M1. The set of all reachable markings is denoted by [M0⟩N .
We omit the subscript N if clear from context.
As said before, here we only want to consider 1-safe nets. Formally, we restrict ourselves to contact-free nets where in every reachable marking M1 ∈ [M0⟩ for all t ∈ O ∪ U with •t ⊆ M1
(M1 \ •t) ∩ t• = ∅ .
For such nets, in Definition 2.2 we can just as well consider a transition t to be enabled in M iff •t ⊆ M , and two transitions to be independent when •t ∩ •u = ∅. In this paper we furthermore restrict attention to nets for which •t /= ∅, and •t and t• are finite for all t ∈ O ∪ U . We also require the initial marking M0 to be finite. A consequence of these restrictions is that all reachable markings are finite, and it can never happen that infinitely many independent transitions are enabled. Hence- forth, we employ the name τ-nets for nets with silent transitions obeying the above restrictions, and plain nets for τ -nets without silent transitions, i.e. with U = ∅.
Our nets with silent transitions can be regarded as special labelled nets, defined as in Definition 2.1, but without the split of T into O and U , and instead equipped with a labelling function l : T → Act ∪ {τ }, where Act is a set of visible actions and τ /∈ Act an invisible one. Nets with silent transitions correspond to labelled nets

in which no two different transitions are labelled by the same visible actions, which can be formalised by taking l(t)= t for t ∈ O and l(t)= τ for t ∈ U .
To describe which nets are “asynchronous”, we will compare their behaviour to that of their asynchronous implementations using a suitable equivalence rela- tion. As explained in the introduction, we consider here branching time semantics. Technically, we use failures equivalence, as defined below.
Definition 2.4 Let N = (S, O, U, F, M0) bea τ -net, σ ∈ O∗ and X ⊆ O.
<σ, X> is a failure pair of N iff


∃M . M =σ⇒ M ∧ M
z−τ→ ∧∀t ∈ X. M
z{t} .

1	0	1	1
1 −→

We define F (N ) := { <σ, X> | <σ, X> is a failure pair of N }.
Two τ -nets N and N ' are failures equivalent, N ≈F N ', iff F (N )= F (N ').
A τ -net N = (S, O, U, F, M0) is called divergence free iff there are no infinite chains of markings M1 −τ→ M2 −τ→ ··· with M1 ∈ [M0⟩.

Full Asynchrony
As explained in the introduction, we will examine in this paper different possible as- sumptions of how asynchronous interaction between transitions and their preplaces takes place. In this section, we start with the simple and intuitive assumption that the removal of any token by a transition takes time. This is implemented by inserting silent transitions between visible ones and their preplaces.
Definition 3.1 Let N = (S, O, ∅, F, M0) bea plain net.
The fully asynchronous implementation of N is defined as the net
FI(N ) := (S ∪ Sτ , O,U ',F ', M0) with
Sτ := {st | t ∈ O, s ∈ •t} ,
U ' := {ts | t ∈ O, s ∈ •t} and
F ' := (F ∩ (O × S)) ∪ {(s, ts), (ts, st), (st, t) | t ∈ O, s ∈ •t} .
It is not hard to see that implementations of contact-free nets are contact-free and implementations are always divergence free; in fact an implementation of a plain net is always a divergence free τ -net.
Whereas in a plain net N for any sequence of observable transitions σ ∈ O∗ there is at most one marking M with M0 =σ⇒ M , in its fully asynchronous implementation FI(N ) there can be several such markings. These markings M ' differ from M in that some tokens may have wandered off into the added invisible transitions on the incoming arcs of visible ones.
As a consequence, a visible transition t that is enabled in M need not be enabled in M '—we say that in FI(N ) t can be refused after σ. This may occur for instance for the net N of Figure 2, namely with σ = ε (the empty sequence), M the initial




N :	FI(N ): 





Fig. 2. A net which is not failures equivalent to its fully asynchronous implementation
marking of N , M ' the marking of FI(N ) obtained by firing the rightmost invisible transition, and t = a.
When this happens, we have <σ, {t}> ∈ F (FI(N )) \ F (N ), so the nets N and FI(N ) are not failures equivalent. If, on the other hand, the wandering off of tokens into τ -transitions never disables a transition that would be enabled otherwise, then there is no essential behavioural difference between N and FI(N ), and they are equivalent in any reasonable behavioural equivalence that abstracts from silent transition firings. In that case, N could be called fully asynchronous.
Definition 3.2
The class of fully asynchronous nets respecting branching time equivalence is defined as FA(B) := {N | FI(N ) ≈F N }.
As for any plain net N we have F (N ) ⊆ F (FI(N )) [8], the class of nets FA(B) can equivalently be defined as FA(B) := {N | F (FI(N )) ⊆ F (N )}.
It turns out that there exists a quite structural characterisation of those nets which are failures equivalent to their fully asynchronous implementation.
Definition 3.3
A plain net N = (S, O, ∅, F, M0) has a partially reachable conflict iff ∃t, u ∈ O. t /= u ∧ •t ∩ •u /= ∅ and ∃M ∈ [M0⟩. •t ⊆ M ∨ •u ⊆ M .
The nets N of Figures 2 and 3, for instance, have a partially reachable conflict. Theorem 3.4 A plain net N is in FA(B) iff N has no partially reachable conflict. Proof. See [19] or [8].	 
Symmetric Asynchrony
For investigating the next interaction pattern, we change our notion of asynchronous implementation of a net. We only insert silent transitions wherever a transition has multiple preplaces. These are the situations where the synchronous removal of tokens is really essential.
Definition 4.1 Let N = (S, O, ∅, F, M0) bea net. Let Ob = {t | t ∈ O, |•t| > 1}. The symmetrically asynchronous implementation of N is defined as the net



N:	SI(N):





Fig. 3. The transition a can be refused in SI(N ) by firing the left τ .
SI(N ) := (S ∪ Sτ , O,U ',F ', M0) with
Sτ := {st | t ∈ Ob,s ∈ •t} ,
U ' := {ts | t ∈ Ob,s ∈ •t} and
F ' := F ∩ (O × S) ∪ (S × (O \ Ob))
∪ {(s, ts), (ts, st), (st, t) | t ∈ Ob,s ∈ •t} .
An example is shown in Figure 3.
As for the fully asynchronous case, an implementation of a plain net is always a divergence-free τ -net.
Again, the only difference in behaviour between the original net and its imple- mentation is that observable transitions can potentially be refused in the imple- mentation, as in Figure 3. This yields a concept of a symmetrically asynchronous net.
Definition 4.2
The class of symmetrically asynchronous nets respecting branching time equivalence
is defined as SA(B) := {N | SI(N ) ≈F N }.
Again we have F (N ) ⊆ F (SI(N )) for any plain net N [8]. We now show that plain nets can be implemented symmetrically asynchronously with respect to failure equivalence exactly when they do not contain reachable structures of the form shown in Figure 3.
Definition 4.3
A plain net N = (S, O, ø, F, M0) has a partially reachable N iff ∃t, u ∈ O. t /= u
∧ •t ∩ •u /= ø ∧ |•u| > 1 ∧ ∃M ∈ [M0⟩N . •t ⊆ M ∨ •u ⊆ M .
Theorem 4.4 A plain net N is in SA(B) iff N has no partially reachable N.
Proof.	See [19] or [8].	 
The following proposition shows that the current class of nets strictly extends the one from the previous section.
Proposition 4.5 FA(B) Ç SA(B).
Proof. A net without partially reachable conflict surely has no partially reachable
N. The inequality follows from the example in Figure 2.	 

It turns out that our class of nets SA(B) is strongly related to the following established net classes [2,3].
Definition 4.6 Let N = (S, O, ø, F, M0) bea plain net.
N is free choice, N ∈ FC , iff ∀p, q ∈ S. p /= q ∧ p• ∩ q• /= ø ⇒ |p•| = |q•| = 1.
N is extended free choice, N ∈ EFC , iff ∀p, q ∈ S. p• ∩ q• /= ø ⇒ p• = q•.
N is behaviourally free choice, N ∈ BFC , iff ∀u, v ∈ O. •u ∩ •v /= ø ⇒
(∀M1 ∈ [M0⟩. •u ⊆ M1 ⇔ •v ⊆ M1).
The above definition of a free choice net is in terms of places, but the notion can equivalently be defined in terms of transitions:
N ∈ FC iff ∀t, u ∈ T. t /= u ∧ •t ∩ •u /= ø ⇒ |•t| = |•u| = 1.
Both conditions are equivalent to the requirement that N must be N-free, where N is defined as in Definition 4.3 but without the reachability clause. Also the notion of an extended free choice net can equivalently be defined in terms of transitions:
N ∈ EFC iff ∀t, u ∈ T. •t ∩ •u /= ø ⇒ •t = •u.

This condition says that N may not contain what we call a pure N: places p, q and transitions t, u such that p ∈ •t ∩ •u, q ∈ •u and q /∈ •t.
In [3] it has been established that FC Ç EFC Ç BFC . In fact, the inclu- sions follow directly from the definitions, and Figure 4 displays counterexamples to strictness.
The class of free choice nets is strictly smaller than the class of symmetrically asynchronous nets respecting branching time equivalence, which in turn is strictly smaller than the class of behavioural free choice nets. The class of extended free choice nets and the class of symmetrically asynchronous nets respecting branching time equivalence are incomparable.
Proposition 4.7 FC Ç SA(B) Ç BFC , EFC ¢ SA(B) and SA(B) ¢ EFC .
Proof. The first inclusion follows because a partially reachable N is surely an N, and also the second inclusion follows directly from the definitions. The four inequalities follow from the examples in Figure 4. The first net is unmarked and thus trivially in SA(B). The second ones symmetrically asynchronous implementation has the additional failure <ε, {a, b}> and hence this net is not in SA(B).	 
In Figure 5 the relations between our semantically defined net class SA(B), the structurally defined classes FC , EFC , and the more behaviourally defined class BFC are summarised. These relations may be interpreted as follows.
Starting at the top of the diagram, free choice nets are characterised structurally, enforcing that for every place, a token therein can choose freely (i.e. without inquir- ing about the existence of tokens in any other places) which outgoing arc to take. This property makes it possible to implement the system asynchronously. In partic- ular, the component which holds the information represented by a token can choose


		

Fig. 4. Differences between various classes of free-choice-like nets
FC



EFC 	#	
SA(B)



BFC


Fig. 5. Overview of free-choice-like net classes
arbitrarily when and into which of multiple asynchronous output channels to for- ward said information, without further knowledge about the rest of the system. As this decision is solely in the discretion of the sending component and not based upon any knowledge of the rest of the system, no synchronisation with other components is necessary.
The difference between SA(B) and FC is that in SA(B) the quantification over the places is dropped, making the requirement more straightforward: Every token can choose freely which outgoing arc to follow. Thus, SA(B) allows for non-free- choice structures as long as these never receive any tokens.
This also explains why BFC includes SA(B). Since SA(B) guarantees that all transitions of a problematic structure are never enabled, transitions in such structures are never enabled while others are disabled.
The incomparability between the left and the right side of the diagram stems from the conceptual allowance of slight transformations of the net before evaluating whether it is free choice or not. Extended free choice nets and behavioural free choice nets were proposed as nets that are easily seen to be behaviourally equivalent to free choice nets, and hence share some of their desirable properties: in [2,3] constructions can be found to turn any extended free choice net into an equivalent free choice net, and any behavioural free choice net into an extended free choice net. 1 Applied on the last two nets in Figure 4 these constructions yield:
For the second net of Figure 4,a τ -transition is introduced, which collects both


	

Fig. 6. Transformed nets from Figure 4

tokens and then marks a single postplace from which the two original transitions are enabled. Hence the choice between the two transitions is centralised in the newly introduced place and thus free again. In the definition of our symmetrically asynchronous implementation SI, we do not allow any insertion of such “helping” τ - transitions, as it seems unclear to us how much computing power should be allowed in possibly larger networks of such transitions. This becomes especially problematic if these networks somehow track part of the global status of the net inside themselves and thus make quite informed decisions about what outgoing transition to enable.

Asymmetric Asynchrony
As seen in the previous section, the class of symmetrically asynchronous nets is quite small. It precludes the implementation of many real-world behaviours, like waiting for one of multiple inputs to become readable, a Petri net representation of which will always include non free-choice structures.
Therefore we propose a less strict definition of asynchrony such that actions may depend synchronously on a single predetermined condition. In a hardware implementation the places which earlier could always forward a token into some silent transitions must now wait until they receive an explicit token removal signal from their posttransitions.
To this end we introduce a static priority over the preplaces of each transition. Every transition first removes the token from the most prioritised preplace and then continues along decreasing priority. To formalise this behaviour in a Petri net we insert a silent transition for each incoming arc of every transition. These silent transitions are forced to execute in sequence by newly introduced buffer places between them. In the final position of this chain, the original visible transition is executed. An example of this transformation is given in Figure 7.
Definition 5.1 Let N = (S, O, ø, F, M0) bea plain net.
Let g ⊆ (S × O) × (S × O) be a relation on F ∩ (S × O) such that for each t ∈ O
g ∩ (•t × {t}) is a total order on •t × {t}. Let ≤t be the total order on •t given by
p ≤t s iff ((p, t), (s, t)) ∈ g.

1 In [2,3] the nature of the equivalence between the original and transformed net is not precisely specified. However, it can be argued that whereas the transformation from EFC-nets to FC-nets preserves branching time as well as causality, the transformation from BFC-nets to EFC-nets preserves branching time only: the third net of Figure 4 is interleaving bisimulation equivalent with its EFC-counterpart in Figure 6, but whereas the original net can perform the transitions a and c concurrently (in one step), the transformed net cannot.

s	s

⇒











Fig. 7. Transformation to asymmetric asynchrony; g such that p <b s <b q.
g	g

We write mint for the ≤t -minimal element of •t and (s − 1)t
for the next place in

g	g	g
t that is ≤t -smaller than s.
We define a set of silent transitions as X := {ts | t ∈ O, s ∈ •t}. Let h : X → X ∪ O be the function
  t	iff s = mint

The asymmetrically asynchronous implementation with respect to g of N is defined as the net AIg := (S ∪ Sτ , O,U ',F ', M0) with
Sτ := {st | t ∈ O, s ∈ •t, s /= mint } ,
U ' := h(X) \ O = {ts | t ∈ O, s ∈ •t, s /= mint } and
F ' := F ∩ (O × S)
∪ {(s, h(ts)) | t ∈ O, s ∈ •t}
∪ {(ts, st)	| t ∈ O, s ∈ •t, s /= mint }
∪ {(st, h(tp)) | t ∈ O, s ∈ •t, s /= mint , p = (s − 1)t } .
g	g
As before, we are interested in the relationship between nets and their possible implementations. The definition of asymmetric asynchrony however allows different implementations for the same net.
We define a net to be asymmetrically asynchronous if any of the possible imple- mentations simulates the net sufficiently.
Definition 5.2
The class of asymmetrically asynchronous nets respecting branching time equivalence
is defined as AA(B) := {N | ∃g. AIg(N ) ≈F N }.
As before, we have F (N ) ⊆ F (AIg(N )) for any plain net N and any priority relation g [8]. Additionally we would like to obtain a semi-structural characterisation of AA(B) in the spirit of Theorems 3.4 and 4.4. Unfortunately we didn’t succeed in this, but we obtained structural upper and lower bounds for this net class.








s	s





N ∈/ AA(B)	N ∈ AA(B)

Fig. 8. Nets which have a left and right border reachable M, but no left and right reachable M

Definition 5.3
A net N = (S, O, ø, F, M0) has a left and right reachable M iff ∃t, u, v ∈O ∃p∈•t∩•u
∃q ∈ •u ∩ •v. t /= u ∧ u /= v ∧ p /= q ∧ ∃M1, M2 ∈ [M0⟩. •t ∪ •u ⊆ M1 ∧ •v ∪ •u ⊆ M2. A net N = (S, O, ø, F, M0) has a left and right border reachable M iff ∃t, u, v ∈ O
∃p ∈ •t ∩ •u ∃q ∈ •u ∩ •v. t /= u ∧ u /= v ∧ p /= q ∧ ∃M1, M2 ∈ [M0⟩. •t ⊆ M1 ∧ •v ⊆ M2.
Theorem 5.4 A plain net N in AA(B) has no left and right reachable M. A plain net N which has no left and right border reachable M is in AA(B).
Proof.	See [19] or [8].	 
Figure 8 shows two nets, each with a left and right border reachable M but no left and right reachable M, that thus fall in the grey area between our structural upper and lower bounds for the class AA(B). In this case the first net falls outside AA(B), whereas the second net falls inside. The crucial difference between these two examples is the information available to u about the execution of y.
There exists an implementation for the right net, namely by u taking the tokens from r, q and s in that order. The first token (from r) conveys the information that y was executed, and thus t is not enabled. Collecting the last token (from s) could fail, due to v removing it earlier. Even so, removing the tokens from r and q did not disable any transition that could fire in the original net. In the left net such an implementation will not work.
The following proposition says that our class of symmetrically asynchronous nets strictly extends the corresponding class of asymmetrically asynchronous nets.
Proposition 5.5 SA(B) Ç AA(B).
Proof. A net which has no partially reachable N also has no left or right border reachable M. The inequality follows from the example in Figure 3.	 
As before, our class AA(B) is related to some known net classes [3].
Definition 5.6 Let N = (S, O, ø, F, M0) bea plain net.

N is simple, N ∈ SPL, iff ∀p, q ∈ S. p /= q ∧ p• ∩ q• /= ø ⇒ |p•| =1 ∨ |q•| = 1.
N is extended simple, N ∈ ESPL, iff ∀p, q ∈ S. p• ∩ q• /= ø ⇒ p• ⊆ q• ∨ q• ⊆ p•.
Extended simple nets appear in [2] under the name asymmetric choice systems. Note that simple is equivalent to M-free, where M is as in Definition 5.3 but without the reachability clauses. Clearly, we have FC Ç SPL Ç ESPL and EFC Ç ESPL, whereas EFC ¢ SPL and SPL ¢ EFC : the inclusions follow immediately from the definitions, and the first two nets of Figure 4 provide counterexamples to the inequalities.
The class of asymmetrically asynchronous nets respecting branching time equiv- alence strictly extends the class of simple nets, whereas it is incomparable with the class of extended simple nets.
Proposition 5.7 SPL Ç AA(B), AA(B) ¢ ESPL and ESPL ¢ AA(B).
Proof. The inclusion is straightforward, and the inequalities follow from the coun- terexamples in Figure 4 (the second one) and Figure 9. The missing tokens in the latter example are intended. As no action is possible there will not be any additional implementation failures.	 
The relations between the classes SPL, ESPL and AA(B) are summarised in Figure 10. Similarly to what we did in Section 4, we now try to translate Figure 10 into an intuitive description.
The basic intuition behind SPL is that for every transition there is only one preplace where conflict can possibly occur. Whereas in SPL that possibility is determined by the static net structure, in AA(B) reachability is also considered.
Similar to the difference between FC and EFC there exists a difference between ESPL and SPL which originates from the fact that ESPL allows small transforma- tions to a net before testing whether it lies in SPL. Again our class AA(B) does not allow such “helping” transformations.

Conclusion and Related Work
We have investigated the effect of different types of asynchronous interaction, using Petri nets as our system model. We propose three different interaction patterns: fully asynchronous, symmetrically asynchronous and asymmetrically asynchronous. An asynchronous implementation of a net is then obtained by inserting silent (un- observable) transitions according to the respective pattern. The pattern for asym- metric asynchrony is parametric in the sense that the actual asynchronous imple-



Fig. 9. N ∈ AA(B), N ∈/ ESPL

SPL


ESPL	AA(B)


Fig. 10. Overview of asymmetric-choice-like net classes

mentation of a net depends on a chosen priority function on the input places of a transition. For each of these cases, we investigated for which types of nets the asynchronous implementation of a net changes its behaviour with respect to failures equivalence (in the case of asymmetric asynchrony, the ‘best’ priority function may be used). It turns out that we obtain a hierarchy of Petri net classes, where each class contains those nets which do not change their behaviour when transformed into the asynchronous version according to one of the interaction patterns. This is not surprising because later constructions allow a more fine-grained control over the interactions than earlier ones.
We did not consider connections from transitions to their postplaces as relevant to determine asynchrony and distributability. This is because we only discussed contact-free nets, where no synchronisation by postplaces is necessary. In the spirit of Definition 3.1 we could insert τ -transitions on any or all arcs from transitions to their postplaces, and the resulting net would always be equivalent to the original.
Although we compare the behaviour of a net and its asynchronous implementa- tions in terms of failures equivalence, we believe that the very same classes of nets are obtained when using any other reasonable behavioural equivalence that respects branching time to some degree and abstracts from silent transitions—no matter if this is an interleaving equivalence, or one that respects causality. We would get larger classes of nets, for example for the case of full asynchrony including the net of Figure 2, if we merely required a net N and its implementation to be equivalent under a suitably chosen linear time equivalence. This option is investigated in [19]. The central results of the paper give semi-structural characterisations of our se- mantically defined classes of nets. Moreover, we relate these classes to well-known and well-understood structurally defined classes of nets, like free choice nets, ex-
tended free choice nets and simple nets.
To illustrate the potential interpretation of our results in other models of dis- tributed systems, we give an example.
Message sequence charts (MSCs), also contained in UML 2.0 under the name sequence diagrams, are a model for specifying interactions between components (instances) of a system. A simple kind are basic message sequence charts (BMSCs) as defined in [13], where choices are not allowed. A Petri net semantics of BMCSs with asynchronous communication and a unique sending and receiving event for each message will yield Petri nets with unbranched places (see for instance [10]). Hence in this case the resulting Petri nets are conflict-free and therefore fully asynchronously


i1	i2

Fig. 11. An MSC and a potential implementation as Petri net, which has an N.

implementable according to Theorem 3.4.
However in extended versions of MSCs, e.g. in UML 2.0 or in live sequence charts (LSCs, see [11]), inline expressions allow to describe choices between possible behaviours in MSCs. Consider for example the MSC given in Figure 11 and a naive Petri net representation. The instances i1 and i2 can either communicate or execute their local actions. Obviously, this requires some mechanism in order to make sure that the choice is performed in a coherent way (see e.g. [7] for a discussion of this type of problem). In the Petri net representation, we find a reachable N, hence with Theorem 4.4 the net does not belong to the class SA(B) of symmetrically asynchronously implementable nets. However, the net is M-free, and thus does belong to the class AA(B) of asymmetrically asynchronously implementable nets. By giving priority to the collection of the message token (choosing the appropriate function g in our notion of implementation), it can be assured that instance i2 does not make the wrong choice and gets stuck (however it is still not clear whether the message will actually be consumed).
The obvious question is whether the naive Petri net interpretation we have given is conform with the intended semantics of the alt -construct (according to the informal UML semantics the alternatives always have to be executed completely; in LSCs it is specified explicitly whether messages are assured to arrive). However, on basis of a maybe more elaborate Petri nets semantics, it could be discussed what types of MSCs can be used to describe physically distributed systems, in particular which type of construct for choices is reasonable in this case.
Another model of reactive systems where we can transfer our results to are process algebras. When giving Petri net semantics to process algebras, it is an interesting question to investigate which classes of nets in our classification are obtained for certain types of operators or restricted languages, and to compare the results with results on language hierarchies (as summarised below).
We now give an overview on related work. A more extensive discussion is con- tained in [19]. We start by commenting on related work in Petri net theory.
The structural net classes we compare our constructions to were all taken from [3], where Eike Best and Mike Shields introduce various transformations between free choice nets, simple nets and extended variants thereof. They use “essential equivalence” to compare the behaviour of different nets, which they only give in-

formally. This equivalence is insensitive to divergence, which is also relied upon in their transformations. As observed in Footnote 1, it also does not preserve concur- rency. They continue to show conditions under which liveness can be guaranteed for some of the classes.
In [1], Wil van der Aalst, Ekkart Kindler and Jo¨rg Desel introduce two extensions to extended simple nets, by allowing self-loops to ignore the discipline imposed by the ESPL-requirement. This however assumes a kind of “atomicity” of self-loops, which we did not allow in this paper. In particular we do not implicitly assume that a transition will not change the state of a place it is connected to by a self-loop, since in case of deadlock, the temporary removal of a token from such a place might not be temporary indeed.
In [18] Wolfgang Reisig introduces a class of systems which communicate using buffers and where the relative speeds of different components are guaranteed to be irrelevant. The resulting nets are simple nets. He then proceeds introducing a decision procedure for the problem whether a marking exists which makes the complete system live.
The most similar work to our approach we have found is [12], where Richard Hopkins introduces the concept of distributable Petri Nets. These are defined in terms of locality functions, which assign to every transition t a set of possible ma- chines or locations L(t) on which t may be executed, subject to the restriction that a set of transitions with a common preplace must share a common machine. A plain net N is distributable iff for every locality function L that can be imposed on it, it has a “distributed implementation”, a τ -net N ' with the same set of visible transitions, in which each transition is assigned a specific location, subject to three restrictions:
the location of a visible transition t is chosen from L(t),
transitions with a common preplace must have the same location
and there exists a weak bisimulation between N and N ', such that all τ -transitions involved in simulating a transition t from N reside on one of the locations L(t).
The last clause enforces both a behavioural correspondence between N and N ' and a structural one (through the requirement on locations). Thus, as in our work, the implementation is a τ -net that is required to be behaviourally equivalent to the original net. However, whereas we enforce particular implementations of an original net, Hopkins allows implementations which are quite elaborate and make informed decisions based upon global knowledge of the net. Consequently, his class of dis- tributable nets is larger than our asynchronous net classes. As Hopkins notes, due to his use of interleaving semantics, his distributed implementations do not always display the same concurrent behaviour as the original nets, namely they add concur- rency in some cases. This does not happen in our asynchronous implementations.
Another branch of related work is in the context of distributed algorithms. In
[5] Luc Boug´e considers the problem of implementing symmetric leader election in the sublanguages of CSP obtained by either allowing all guards, only input guards or no communication guards at all in guarded choice. He finds that the possibility

of implementing it depends heavily on the structure of the communication graphs, while truly symmetric schemes are only possible in CSP with input and output guards.
Quite a number of papers consider the question of synchronous versus asyn- chronous interaction in the realm of process algebras and the π-calculus. In [4] Frank de Boer and Catuscia Palamidessi consider various dialects of CSP with differing degrees of asynchrony. In particular, they consider CSP without output guards and CSP without any communication based guards. They also consider explicitly asynchronous variants of CSP where output actions cannot block, i.e. asynchronous sending is assumed. Similar work is done for the π-calculus in [17] by Catuscia Palamidessi, in [16] by Uwe Nestmann and in [9] by Dianele Gorla. A rich hierarchy of asynchronous π-calculi has been mapped out in these papers. Again mixed-choice, i.e. the ability to combine input and output guards in a single choice, plays a central role in the implementation of truly synchronous behaviour. It would be interesting to explore the possible connections between these languages and our net classes.
In [20], Peter Selinger considers labelled transition systems whose visible actions are partitioned into input and output actions. He defines asynchronous implemen- tations of such a system by composing it with in- and output queues, and then characterises the systems that are behaviourally equivalent to their asynchronous implementations. The main difference with our approach is that we focus on asyn- chrony within a system, whereas Selinger focusses on the asynchronous nature of the communications of a system with the outside world.
Finally, there are approaches on hardware design where asynchronous interaction is an intriguing feature due to performance issues. For this, see the papers [14] and
[15] by Leslie Lamport. In [15] he considers arbitration in hardware and outlines various arbitration-free “wait/signal” registers. He notes that nondeterminism is thought to require arbitration, but no proof is known. He concludes that only marked graphs can be implemented using these registers. Lamport then introduces “Or-Waiting”, i.e. waiting for any of two signals, but has no model available to characterise the resulting processes. The used communication primitives bear a striking similarity to our symmetrically asynchronous nets.

References
W.M.P. van der Aalst, E. Kindler & J. Desel (1998): Beyond asymmetric choice: A note on some extensions. Petri Net Newsletter 55, pp. 3–13.
E. Best (1987): Structure theory of Petri nets: The free choice hiatus. In W. Brauer, W. Reisig &
G. Rozenberg, editors: Advances in Petri Nets 1986, LNCS 254, Springer, pp. 168–206.
E. Best & M.W. Shields (1983): Some equivalence results for free choice nets and simple nets and on the periodicity of live free choice nets. In G. Ausiello & M. Protasi, editors: Proceedings 8th Colloquium on Trees in Algebra and Programming (CAAP ’83), LNCS 159, Springer, pp. 141–154.
F.S. de Boer & C. Palamidessi (1991): Embedding as a tool for language comparison: On the CSP hierarchy. In J.C.M. Baeten & J.F. Groote, editors: Proceedings 2nd International Conference on Concurrency Theory (CONCUR ’91), Amsterdam, The Netherlands, LNCS 527, Springer, pp. 127–141.
L. Boug´e (1988): On the existence of symmetric algorithms to find leaders in networks of communicating sequential processes. Acta Informatica 25(2), pp. 179–201.

S.D. Brookes, C.A.R. Hoare & A.W. Roscoe (1984): A theory of communicating sequential processes.
Journal of the ACM 31(3), pp. 560–599.
T. Gehrke, U. Goltz & H. Wehrheim (1999): Zur semantischen Analyse der dynamischen Modelle von UML mit Petri-Netzen. In E. Schnieder, editor: Proceedings 6th Symposium on Development and Operation of Complex Automation Systems.
R.J. van Glabbeek, U. Goltz & J.-W. Schicke (2008): Symmetric and asymmetric asynchronous interaction. Technical Report 2008-03, TU Braunschweig.
D. Gorla (2006): On the relative expressive power of asynchronous communication primitives. In
L. Aceto & A. Ing´olfsd´ottir, editors: Proceedings 9th International Conference on Foundations of Software Science and Computation Structures (FoSSaCS ’06), LNCS 3921, Springer, pp. 47–62.
P. Graubmann, E. Rudolph & J. Grabowski (1993): Towards a petri net based semantics definition for message sequence charts. In Proceedings 6th SDL Forum (SDL ’93).
D. Harel & R. Marelly (2003): Come, Let’s Play. Springer.
R.P. Hopkins (1991): Distributable nets. In Advances in Petri Nets 1991, LNCS 524, Springer, pp. 161–187.
International Telecommunication Union (1996): Message sequence chart. Standard ITU-T Z.120.
L. Lamport (1978): Time, clocks, and the ordering of events in a distributed system. Communications of the ACM 21(7), pp. 558–565.
L. Lamport (2003): Arbitration-free synchronization. Distributed Computing 16(2-3), pp. 219–237.
U. Nestmann (2000): What is a ‘good’ encoding of guarded choice? Information and Computation 156,
pp. 287–319.
C. Palamidessi (1997): Comparing the expressive power of the synchronous and the asynchronous pi-calculus. In Conference Record of the 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL ’97), ACM Press, pp. 256–265.
W. Reisig (1982): Deterministic buffer synchronization of sequential processes. Acta Informatica 18,
pp. 115–134.
J.-W. Schicke (2008): Studienarbeit: Asynchronous Petri net classes.
P. Selinger (1997): First-order axioms for asynchrony. In Proceedings 8th International Conference on
Concurrency Theory (CONCUR ’97), Warsaw, Poland, LNCS 1243, Springer, pp. 376–390.
W. Vogler (1993): Bisimulation and action refinement. Theoretical Computer Science 114(1), pp. 173–200.
