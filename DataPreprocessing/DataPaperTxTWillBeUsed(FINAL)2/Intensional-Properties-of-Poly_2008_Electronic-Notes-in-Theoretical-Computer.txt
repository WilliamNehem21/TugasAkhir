Electronic Notes in Theoretical Computer Science 203 (2008) 65–77	
www.elsevier.com/locate/entcs

Intensional Properties of Polygraphs
Guillaume Bonfante1	Yves Guiraud2
INRIA-LORIA
615 rue du Jardin Botanique - BP 101 Villers-l`es-Nancy 54602 - FRANCE

Abstract
We present polygraphic programs, a subclass of Albert Burroni’s polygraphs, as a computational model, showing how these objects can be seen as first-order functional programs. We prove that the model is Turing complete. We use polygraphic interpretations, a termination proof method introduced by the second author, to characterize polygraphic programs that compute in polynomial time. We conclude with a characterization of polynomial time functions and non-deterministic polynomial time functions.
Keywords: polygraph; polygraphic program; polygraphic interpretation; termination; complexity.


Introduction
Polygraphs are special higher-dimensional categories, introduced by Albert Burroni to provide a unified algebraic setting for rewriting [3]. For example, any term rewriting system can be translated into a polygraph which has, in case of left- linearity, exactly the same properties of termination and confluence [10,6].
Here, we study how these mathematical objects can be used as a computational model. Informally, computations generated by a polygraph are done by a net of cells which individually behave according to some local transition rules. This model is close to John von Neumann’s cellular automata [16] and Yves Lafont’s interaction nets [9] with notable differences: while von Neumann’s automata are essentially synchronous, interaction nets and polygraphs are asynchronous; polygraphs have a much more rigid geometry than interaction nets: the underlying graphs of the formers are directed acyclic graphs, preventing the ”vicious circles” of the latters.
Termgraph rewriting systems provide another model of graphical computa- tion [15]: it is an extension of term rewriting with an additional operation, sharing,

1 Guillaume.Bonfante@loria.fr
2 Yves.Guiraud@loria.fr

1571-0661 © 2008 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.034

that allows for a more correct representation of actual computation. The transla- tion of terms into polygraphs is close to the one into termgraphs and they seem to have the same properties, as suggested by the first results in [8]. For example, let us consider the following term rewriting rule, used to compute the multiplication on natural numbers: mult(x, succ(y))  add(x, mult(x, y)). When applied, this rule duplicates the term corresponding to the argument x. In termgraph rewriting, one is able to share it instead, so that there is no need for extra memory space. This sharing operation can be algebraically formalized as an operation with one input and two outputs, whose semantics is a duplication operation. In polygraphs, one can have many such operations with many outputs, explicitely represented and handled.
This is a key fact in our results on implicit computational complexity: indeed, the interpretations we consider here, called polygraphic interpretations [6,8], can reflect the fact that two outputs of the same operation have some links between them, as we will see with the example of the list splitting function used in ”divide and conquer” algorithms. This allows us to give complexity bounds where traditional polynomial interpretations [13] cannot with the method described in [4,1] or to give better bounds, as indicated here and in [8]. Moreover, the polygraphic interpretations give separated information on the spatial and on the temporal complexities of functions. Because of space constraints, we only give the main arguments used to prove the results we present here; the complete proofs can be found in a longer paper, together with extended comments and technical details [2]. Let us note that the present paper proposes a slightly more general framework than the other one, allowing
non-deterministic polygraphic programs.
In section 2 we introduce the notion of polygraphic program in an informal way and give the corresponding semantics we consider; we introduce the leading example of this paper, the polygraphic program computing the ”fusion sort” on lists, and we prove that polygraphic programs form a Turing complete model of computation. In section 3, we recall the notion of polygraphic interpretation, give examples, define the notion of simple polygraphic program and prove results on termination of polygraphic programs. Finally, in section 4, we give polynomial complexity bounds for simple programs and prove that they characterize the classes ptime and nptime of functions computable in polynomial time, respectively by a Turing machine and by a non-deterministic Turing machine.
Polygraphs as a computational model
The general definition of polygraph can be found in documents by Albert Burroni, Yves Lafont and Franc¸ois M´etayer [3,10,14,11,12]. Here we give a rewriting-minded presentation of a special case of polygraphs, seeing them as rewriting systems on algebraic circuits.
Definition 2.1 A monoidal 3 -polygraph is a composite object consisting of cells, paths and compositions organized into dimensions.
Dimension 1 contains elementary sorts called 1 -cells and represented by wires.

Their concatenation 0 yields product types called 1 -paths and pictured as jux- taposed vertical wires. The empty product ∗ is also a 1-path, represented by the empty diagram.
Dimension 2 is made of operations called 2 -cells, with a finite number of typed inputs and outputs. They are pictured as circuit gates, with inputs at the top and outputs at the bottom. Using all the 1-cells and 2-cells as generators, one builds circuits called 2 -paths, using the following two compositions:


 0
=
 1	=



The constructions are considered modulo some relations, including topological de- formation: one can stretch or contract wires freely, move 2-cells, provided one does not create crossings or break wires. Each 2-cell and each 2-path f has a 1-path s1(f) as input, its 1 -source, and a 1-path t1(f) as output, its 1 -target. The compact notation f : s1(f)  t1(f) summarizes these facts.
Dimension 3 contains rewriting rules called 3 -cells. They always transform a 2-path into another one with the same 1-source and the same 1-target. Using all the 1-cells, 2-cells and 3-cells as generators, one can build reductions paths called 3 -paths, by application of the following three compositions, defined for F going from f to f' and G going from g to g': F 0G goes from f 0g to f' 0g'; when t1(f) = s1(g), then F 1 G goes from f 1 g to f' 1 g'; when f' = g, then F 2 G goes from f to g'. These constructions are identified modulo some relations, given in [7], where their 3-dimensional nature was explained. The relations allow one to freely deform the constructions in a reasonable way: in particular, they identify paths that only differ by the order of application of the same 3-cells on non-overlapping parts of a 2-path. A 3-path is elementary when it contains exactly one 3-cell. Each 3-cell and each 3-path F has a 2-path s2(F) as left-hand side, its 2 -source, and a 2-path t2(F) as right-hand side, its 2 -target. The notation F : s2(F) $ t2(F) stands for these facts.
For monoidal 3-polygraphs, rewriting notions are defined in a similar way as
for term rewriting systems, with terms replaced by 2-paths, reduction steps by el- ementary 3-paths and reduction paths by 3-paths [6]. Hence, a normal form in a polygraph P is a 2-path f which is the 2-source of no elementary 3-path. The poly- graph P terminates when it does not contain infinite families (Fn)n∈N of elementary 3-paths such that t2(Fn) = s2(Fn+1) for all n. Other rewriting properties, such as confluence or convergence are also defined in an intuitive way.
Remark 2.2 As defined here, the k-paths of such a polygraph, equipped with their k compositions, form a k-category. More precisely, this is the k-category freely generated by all the i-cells, for 0 ≤ i ≤ k [3].
Definition 2.3 A polygraphic program is a monoidal 3-polygraph such that:
Its 2-cells are divided into structure 2 -cells, constructors and functions. The structure 2-cells consist of one  : ξ 0 ζ ⇒ ζ 0 ξ for each pair of 1-cells (ξ, ζ), plus one  : ξ ⇒ ξ 0 ξ and one  : ξ ⇒ ∗ for each 1-cell ξ. The constructors

are 2-cells such with a 1-cell as 1-target. The functions are any 2-cells.
Its 3-cells are divided between structure 3 -cells and computation 3 -cells. The structure 3-cells are given, for every constructor  : x  ξ and every 1-cell ζ, by:
x	ζ	x	ζ	ζ	x	ζ	x	x	x	x	x

 $
ζ	ξ	ζ	ξ
 $ 
ξ	ζ	ξ	ζ
 $ 	 $
ξ ξ	ξ	ξ

The 2-targets of the 3-cells of Δ2 use structure 2-paths built from the structure
2-cells by using the following structural induction rules:

∗	ξ	ξ
=
x	ξ ζ
x٨0 ξ  ζ
=
x	ξ
∗	x ٨0 ξ
= ∗	=




ξ	∗	ξ
=

ζ  ξ ٨0 x
=
ζ ξ	x


∗	x ٨0 ξ	x	ξ
	= ∗		=	 

The computation 3-cells are 3-cells whose 2-source is of the shape t 1 ϕ, with ϕ a function 2-cell and t a 2-path built only with 1-cells and constructors. Further- more, there is a finite constant that bounds the number of structure 2-cells in the 2-target of each computation 3-cell.
For the present study, we assume that there exists a procedure to perform each step of computation: more formally, for every 3-path F : f  g containing exactly one 3-cell, the map giving g from the pair (f, F) is computable in polynomial time.
Example 2.4 We consider the following polygraphic program with one 1-cell, two constructors  and , two functions  and  and four computation 3-cells (we do not give the structure cells):

$	$	$	$
With the constructors, one can represent the natural number n, using  for 0 and  for the successor operation, yielding a 2-path tn with zero input and one output. Furthermore, one can check that this polygraph is convergent and that, given tm and tn, the normal form of (tm 0 tn) 1  is tm+n, while the one of (tm 0 tn) 1  is tmn.
Hence this polygraphic program computes the addition and the multiplication on natural numbers: the 1-cells are the data types, the 2-paths ξ  ∗ built only from constructors are the values, while the result of the application of a function  with n inputs to well-typed values (t1,... , tn) is the normal form of the 2-path (t1 0 ··· 0 tn) 1 . This semantical interpretation is formalized thereafter.
Definition 2.5 [Semantics] Let us fix a polygraphic program P. If ξ is a 1-cell, a term of type ξ is a 2-path built only with constructors and with ξ as 1-target. A value or closed term is a term with no input. The set of values with type ξ is denoted by V(ξ). The domain of computation of P is the multi-sorted algebra

made of the family of all the sets V(ξ) equipped with the operations given, for each constructor γ : ξ1 0 ··· 0 ξn ⇒ ξ, by the map still denoted by γ:
γ : V(ξ1) × ··· × V(ξn) → V(ξ)
(t1,... , tn) '→ (t1 0 ··· 0 tn) 1 γ.
Let us consider a function f from V(ξ1) ×···× V(ξm) to V(ζ1) ×···× V(ζn). There are two cases whether P is confluent or not.
If P is confluent, we say that P computes f if there exists a 2-path, still denoted by f, from ξ1 0 ··· 0 ξm to ζ1 0 ··· 0 ζn, such that, for every family (t1,... , tm) of values in V(ξ1) × ··· × V(ξm), the 2-path (t1 0 ··· 0 tm) 1 f normalizes into the family f(t1,... , tm) of values in V(ζ1) × ··· × V(ζn). Let us note that the normal form is unique in that case.
If P is not confluent, after Gurevich and Gr¨adel [5], we say that it computes f if, for all values (t1,... , tm) in V(ξ1) × ··· × V(ξm), the following holds, where the considered order is the lexicographic order:
f(t1,... , tm) = max , normal forms of (t1 0 ··· 0 tm) 1 f }.
Example 2.6 Let us consider a polygraphic program that computes, among other functions, the fusion sort function on lists of natural numbers. It has two 1-cells, nat for natural numbers and list for lists of natural numbers. Its other cells, apart from structure ones are:
Constructors: one	∗ ⇒ nat for each natural number n, plus  : ∗ ⇒ list for
the empty list and	: nat 0 list ⇒ list for the list constructor.
Functions: the main	: list ⇒ list for fusion sort, together with	: list ⇒
list 0 list for splitting lists and	: list 0 list ⇒ list for merging them.
Computation 3-cells:



 $ 	$
 $  	 $
p ≤ q
$	$	$
$
$



p> q
$

Note that the last two rules for the  function are, in fact, a notation for an infinite family of 3-cells: there is exactly one of them for each pair (p, q) of natural numbers, depending which one of p ≤ q or p > q holds. However, these two conditions are computable (in linear time), preventing super-Turing computations. We have chosen a simplified representation of natural numbers which considers them as being predefined, at the ”hardware level”, together with their predicate

≤. The reason for this choice is to postpone the study of modularity and of the
if-then-else construction to subsequent work.
Theorem 2.7 Polygraphic programs form a Turing-complete model of computa- tion.
Proof. Here we give a sketch of the proof, while the complete one can be found in [2]. We could use the fact that we can simulate rewriting systems which are Turing complete, but we give the explicit simulation as a first step to the proof of Theorem 4.9. Given a Turing machine, one defines:
Constructors: one  : 0   1 for the empty word plus one a : 1   1 for each letter
a.
Functions: one  : 1 $ 1 for the function to be computed plus one stepq,a =
: 2 ⇒ 1 for each state q and each letter a, including the blank symbol .
Computation 3-cells are given thereafter, the first rule initializing the computa- tion, the four subsequent families replicating the transitions of the Turing machine and the final family starting the computation of the result:
$

$	$	both when δ(q, a) = (q', c, L)

$	$	both when δ(q, a) = (q', c, R)
$	
We assume that, at the end of the computation, the result of the Turing machine is the word written on the tape at the right of the head: this is why the last 3-cell erases the left part.
Let us assume that the machine is in the state q, reading the letter a, with wl and wr the two words respectively written on the left of a, from right to left, and on the right of a, from left to right. Then, this state of the system is represented

by the 2-path (wl 0 wr) 1
. Then one checks that each transition step of the

Turing machine corresponds to an elementary 3-path of its polygraphic version. 

Polygraphic interpretations and simple programs
Polygraphic interpretations have been introduced to prove termination of 3- polygraphs [6]. Here we use a restricted form to get properties on the complexity of polygraphic programs. In order to give some intuition, let us imagine that 2-paths are electrical circuits, crossed by currents going downwards, from the inputs to the outputs.
A polygraphic interpretation associates to each 2-cell ϕ a ”current map” ϕ∗ and

a ”heat map” [ϕ]. The current map gives the intensity of the currents leaving the circuit gate ϕ, according to the intensity of the incoming currents. The heat map says how much heat is produced by the same gate ϕ during this process.
From these maps, one can compute the currents and heat produced by each 2-path. The original use was to find a polygraphic interpretation such that each reduction step replaces a 2-path by another one that produces strictly less heat. Here, the current maps will be used as approximations of the size of the computed values, while heat maps will estimate the number of computation steps remaining to reach a result: hence, current maps and heat maps will give bounds respectively on the spatial and on the temporal complexities of a polygraphic program.
Definition 3.1 A polygraphic interpretation of a polygraphic program P consists into a mapping of each 2-path f with m inputs and n outputs onto two monotone maps f∗ : Nm  Nn and [f] : Nm  N, such that the following conditions are satisfied:
For every 1-path x of length n, we have x∗ = Idn and [x] = 0.
For every 2-paths f and g, the following equalitities hold when defined:
· (f  0 g)∗(x, y) = (f∗(x), g∗(y)) and [f  0 g](x, y) = [f](x)+ [g](y) ;
· (f 1 g)∗(x) = g∗(f∗(x)) and [f 1 g](x) = [f](x)+ [g](f∗(x)).

Given an interpretation and a 2-cell ϕ, we denote by ϕj
the jth component of the

map ϕ∗. An interpretation of P generates a binary relation denoted by >: it is defined, on 2-paths f and g with the same 2-source and the same 2-target, by f > g when the two inequalities f∗(i) ≥ g∗(i) and [f](i) > [g](i) hold for every possible family i of natural numbers. An interpretation is compatible with a 3-cell α when s2(α) > t2(α) and weakly compatible with α if s2(α) ≥ t2(α).
It was proved in [6] that an interpretation is entirely determined by its values on the 2-cells of the polygraph, that the binary relation > is a terminating strict order and that context are strictly monotone with respect to it. These are the main steps towards the following result.
Theorem 3.2 ([6]) If a polygraphic program admits an interpretation which is compatible with all of its 3-cells, then it terminates.
Example 3.3 Let us assume that we have a current map (·)∗ on a polygraphic program such that the following conditions hold:
If  is a constructor with n inputs, then ∗(i1,... , in) > i1 + ··· + in.
One structure 2-cells, we have ∗(i, j) = (j, i) and ∗(i) = (i, i). We define a heat map [·]S as follows:

On structure 2-cells, we have	 S (i, j) = ij,	 S (i) = i  and   (i) = i.
2
It is proved in [2] that these values generate a polygraphic interpretation compatible with the structure 3-cells. Hence theorem 3.2 tells us that a polygraphic program

without computation 3-cell terminates.
Definition 3.4 Given a current map (·)∗ on a polygraphic program that satisfies the conditions of example 3.3, the heat map [·]S is called structure heat generated by (·)∗.
Definition 3.5 We denote by N[x1, ··· , xn] the algebra of polynomials in n vari- ables and coefficients in N. Let P be a polygraphic program. A polygraphic inter- pretation is simple when the following conditions are met:

For any 2-cell ϕ with m inputs and n outputs, the maps .n
j and [ϕ] are

polynomials of N[x1,... , xm].
If γ is a constructor with n inputs, then γ∗ = .m

xi + aγ, with aγ > 0, and

[γ] = 0. Moreover, we assume that there exists a a ∈ N∗ bounding all the aγ’s.
On structure 2-cells, one has	(i, j) = (j, i) and (i) = (i, i). Moreover, struc-
ture cells produce no heat:	(i) = 0,   (i, j) = 0,  (i) = 0.
For every function ϕ with	inputs and n outputs and for every family

(i1,... , im) of natural numbers, we have .n
ϕj (i1,... , im) ≥ i + ··· + im.

A polygraphic program is called simple when the 2-targets of its computation 3-cells contain at most K structure 2-cells, for some fixed K, and when it admits a simple polygraphic interpretation which is compatible with all of its computation 3-cells.
Theorem 3.6 A simple polygraphic program terminates.
Proof. Let P be a simple polygraphic program and let (·)∗ and [·] be the current and heat maps of a simple interpretation, compatible with all the computation 3- cells of P. It is a direct computation to check that such an interpretation is weakly compatible with the structure 3-cells of P. Hence, we deduce that P terminates if and only if the polygraphic program Q does, where Q is built from P by removal of the computation 3-cells. The map (·)∗ also satisfies the conditions to generate a structure heat map [·]S proving the termination of Q.	 
Example 3.7 Let us prove that the polygraphic program of example 2.6 is simple. Let us consider the interpretation generated by these values:
n ∗ = 1,	∗ = 1,	∗(i, j) = i + j + 1;
 ∗(i) = i,	∗(i) = ([i/2| , [i/2♩),	∗(i, j) = i + j;
 (i) = 2i2,	 (i) = i,	 (i, j) = i + j.
We have used the notations [·| and [·♩ for the rounding functions, respectively by excess and by default. This interpretation meets the conditions of definition 3.5 and, thus, is simple. Now, one has to check that it is compatible with all the computation 3-cells: we give some of the computations for the last 3-cell of the function . Let us start with (·)∗. On one hand:
  ∗ (i, j, k) =   ∗ i, ∗(j, k)  = ∗ ◦ ∗ i, ∗(j, k)  = i + j + k + 2.

And, on the other hand:
⎛⎜⎜⎝	⎞⎟⎟⎠ (i, j, k) = i + j + [k/2| + [k/2♩ + 2 = i + j + k + 2.

Now, let us consider [·]. For the 2-source of the 3-cell, one gets:

  (i, j, k) =   (i + j + k + 2) = 2 · (i + j + k + 2)2.
And, for its 2-target, ⎡⎢⎢⎣	⎤⎥⎥⎦ (i, j, k) is equal to:


  (k)+  (i + [k/2| + 1)+  (j + [k/2♩ + 1)

= 2 · (i + [k/2| + 1)2 + 2 · (j + [k/2♩ + 1)2 + i + j + 2k + 2.

We conclude, for example, by considering two cases, depending on the parity of k.
Example 3.8 For the polygraphic program of example 2.4, the following values generate a simple interpretation which is compatible with the four computation 3-cells:
 ∗ = 1,	∗(i) = i + 1,	∗(i) = (i, i),	∗(i, j) = i + j,	∗(i, j) = ij;
 =  (i) =  (i) =  (i) = 0,	  (i, j) = i,	  (i, j) = (i + 1)j.

Complexity of simple programs
Definition 4.1 Let P be a polygraphic program. If f is a 2-path of P, we denote by ||f|| the number of 2-cells f is made of. If F is a 3-path of P, we denote by |||F||| the number of 3-cells F is made of.
Let P be a simple program with a fixed interpretation made of (·)∗ and [·]. We want to prove that (·)∗ is a good estimation of the size of values computed by P, given by ||·||, while [·] is one for the size of the computations, given by |||·|||. Once again, the complete proofs are in [2]. We recall that, by assumption, there exists a a > 0 that bounds each aγ = γ∗(0,... , 0), for γ a constructor. By induction on the size of values, we prove that (·)∗ is an estimation of the size of values:
Lemma 4.2 For every value t, the inequalities ||t|| ≤ t∗ ≤ a ||t|| hold in N.

Using the properties of the polygraphic interpretation we consider and lemma 4.2, we prove that the size of intermediate and of final values are bounded by a polyno- mial in the size of the initial values:
Proposition 4.3 Let ϕ be a function with m inputs and n outputs. Let Pϕ
be the polynomial in N[x1,... , xm] deﬁned by Pϕ = .n  ϕj (ax ,... , axm). Let
t be a family of values of type s1(ϕ) and let us assume that t 1 ϕ reduces
into a 2-path of the shape u 1 c, where u has p outputs. Then the inequality

.p uj
≤ P (||t1 || ,... , ||tm||) holds. In particular, if u = ϕ(t), the inequality

j=1 ∗	ϕ
||ϕ(t)|| ≤ Pϕ(||t1 || ,... , ||tm||) holds.
Example 4.4 If one computes these polynomials for the simple polygraphic pro- gram of example 2.6, one sees that, for any list t, the sorted list (t) and all the intermediate values computed to reach the result have their sizes bounded by the size of t:
P(x) = ∗(1 · x) = x,		P(x, y) = ∗(1 · x, 1 · y) = x + y, P (x) =	1(1 · x)+	2(1 · x) = [x/2| + [x/2♩ = x.
∗	∗
For the polygraphic program of example 2.4, one gets P(x, y) = x + y and P(x, y) = xy. Hence, the current maps give us information on the spatial com- plexity of the computation, separated from the length of computations.
Now we interest ourselves into polynomial bounds for the length of computations. We start by a technical lemma, which proves that, during a computation, the po- tential structure heat increase due to the application of a computation 3-cell is polynomially bounded by the size of the arguments. We recall that, by assumption, each computation 3-cell contains at most K structure 2-cells.
Lemma 4.5 Let ϕ be a function with m inputs. We denote by Sϕ the polynomial K · P2 . Let t be a family of values of type s1(ϕ), let f and g be 2-paths such that t 1 ϕ reduces into f which itself reduces into g by application of a computation rule α. Then the following inequality holds:
[f]S + Sϕ(||t1 || ,... , ||tm||) ≥ [g]S.

Proof. The complete, technical proof is in [2]. Here we recall the main reasoning
steps. We denote by α : a $ b the computation 3-cell used to reduce f into g. We decompose f and g to make a and b appear and use the properties of current and
heat maps to conclude that there exist natural numbers i1, ... , im such that the inequality [f]S + [b]S(i1,... , im) ≥ [g]S holds. Then we prove that [b]S(i1,... , im) is polynomially bounded by the size of t. By definition of the structure heat, [b]S(i1,... , im) is the sum of all the structure heats produced by the structure 2- cells b is made of. Then we use proposition 4.3 to prove that the current incoming in each input of each structure 2-cell of b is bounded by Pϕ(||t1 || ,... , ||tm||). Then, by definition of [·]S on structure 2-cells, we conclude that the structure heat produced by each one is at most P2 (||t1 || ,... , ||tm||). Finally, we use the fact that b is the

2-target of a computation 3-cell to deduce that there is at most K structure 2-cells in b.	 
Example 4.6 For the polygraphic program of example 2.6 we have K = 1, S(x) = x2, S  (x) = x2 and S  (x, y) = (x+y)2. For the one of example 2.4, we have K = 1, S  (x, y) = (x + y)2 and S  (x, y) = x2y2.
Now let us prove that the length of a computation is polynomially bounded by the size of the arguments.

Proposition 4.7 Let ϕ be a function with m inputs. We deﬁne polynomials:
the following

Qϕ(x1,... , xm) = [ϕ](ax1,... , axm)	and	Rϕ = Qϕ · (1 + Sϕ).

Let t be a family of values of type s1(ϕ), let F be a 3-path with 2-source t 1ϕ, made of k computation 3-cells and l structure 3-cells. Then the following inequalities hold:
k ≤ Qϕ(||t1 || ,... , ||tm||))	and	l ≤ Qϕ(||t1 || ,... , ||tm||)) · Sϕ(||t1 || ,... , ||tm||)).
As a consequence, |||F||| ≤ Rϕ(||t1 || ,... , ||tm||) holds.
Proof. We decompose F into a 2-composite of elementary computation 3-paths followed by structure 3-paths. Using the fact that the heat map we consider is strictly decreasing on computation 3-cells and weakly decreasing on structure 3- cells, we deduce that [t 1 ϕ] is minored by k. We use the properties of [·] and lemma 4.2 to get the bound we seek on k. Then, we apply proposition 4.7 to each of the structure 3-paths we have isolated. We sum up the resulting inequalities and use the facts that [t 1ϕ]S = 0 and [t2(F)]S ≥ 0 to get k· Sϕ(||t1 || ,... , ||tm||) ≥ l. We deduce the inequality on l from this one and the one on k. We conclude by using the equality |||F||| = k + l.	 
Example 4.8 For the functions of example 2.6, we have Q(x) = 2x2, Q(x) = x and Q(x, y) = x + y. For example, let us fix a list t. The polynomial Q tells us that, during the computation of the sorted list (t), there will be at most ||t|| applications of a computation 3-cell. The polynomial R guarantees that there is no
more than ||t||2 (1 +||t||2) applications of rules. On the examples we have considered, the polynomial Qϕ gives a bound that is close to known ones but the polynomial Rϕ gives a very overestimated bound. To get a better estimation, we will have to work on the structure heat increase bound Sϕ.
Theorem 4.9 Functions computed by simple confluent polygraphic programs are exactly ptime functions.
Proof. We start by proving that functions computed by simple polygraphic pro- grams are in ptime. Proposition 4.7 tells us that the length of any computation in such a polygraph are polynomially bounded by the size of the arguments. Fur- thermore, each step of computation can be done in polynomial time with respect

to the size of the current 2-path: we find a redex in a directed acyclic graph with decorations then replace it by the corresponding reduce and both operations can be done in polynomial time.
Now let us prove that any ptime function can be computed by a simple poly- graphic program. The first step is to translate a Turing machine equipped with a clock into a polygraphic program. We fix a function f in ptime, a Turing machine M that computes f and a polynomial P that bounds the length of the computation. We consider a copy of the polygraphic program of example 2.4 which computes addition and multiplication of natural numbers, with its 1-source denoted by nat. Let us note that this polygraphic program computes any polynomials, including P. Then we extend it with a variant of the polygraphic Turing machine of section 2: it is made of a 1-cell mon; its constructors are the empty word  : mon ⇒ mon, plus one cell a : mon ⇒ mon for each letter of the alphabet of M; its functions are the main  : mon ⇒ mon for f, plus a size function  : mon ⇒ nat, plus a modified
cell q a : nat 0 mon 0 mon  mon for each state q of M and each letter a in the alphabet of M, including the blank symbol ; its computation 3-cells are:

$	$ 	$	$


$	$
both when δ(q, a) = (q', c, L)



$
$
both when δ(q, a) = (q', c, R)

Then, one checks that this polygraphic program mimics the transition of the orig- inal Turing machine M and, thus, computes f. We conclude by checking that the following polygraphic interpretation, extending the one already built on natural numbers, is simple and compatible with each computation 3-cell:
 ∗ = 1, a ∗(i) = i + 1,  ∗(i) = i,	∗(i, j, k) = i + j + k, ∗(i) = P∗(i)+ i + 1.
 (i) = i,	 (i, j, k) = i,   (i) = [P](i)+ P∗(i)+ i + 1.

Actually, as the simulation is done step by step, another theorem follows, still taking the definition of nptime functions to be the one of Gr¨adel and Gurevich [5]:
Theorem 4.10 Functions computed by simple non-confluent polygraphic programs are exactly nptime functions.

References
Guillaume Bonfante, Adam Cichon, Jean-Yves Marion, and Hlne Touzet, Algorithms with polynomial interpretation termination proofs, Journal of Functional Programming 11 (2001), no. 1, 33–53.

Guillaume Bonfante and Yves Guiraud, Programs as polygraphs: computability and complexity, Logical Methods in Computer Science (in press), 2006.
Albert Burroni, Higher-dimensional word problems with applications to equational logic, Theoretical Computer Science 115 (1993), no. 1, 43–62.
Adam Cichon and Pierre Lescanne, Polynomial interpretations and the complexity of algorithms, Lecture Notes in Artificial Intelligence 607 (1992), 139–147.
Erich Grdel and yuri Gurevich, Tailoring recursion for complexity, Journal of Symbolic Logic 60 (1995), no. 3, 952–969.
Yves Guiraud, Termination orders for 3-dimensional rewriting, Journal of Pure and Applied Algebra
207 (2006), no. 2, 341–371.
	 , The three dimensions of proofs, Annals of Pure and Applied Logic 141 (2006), no. 1-2, 266–295.
	 , Polygraphs for termination of left-linear term rewriting systems, Preprint, 2007.
Yves Lafont, Interaction nets, Principles of Programming Languages, ACM Press, 1990, pp. 95–108.
	 , Towards an algebraic theory of boolean circuits, Journal of Pure and Applied Algebra 184
(2003), no. 2-3, 257–310.
	 , Algebra and geometry of rewriting, To appear in Applied Categorical Structures, 2006.
Yves Lafont and Franois Mtayer, Polygraphic resolutions and homology of monoids, Preprint IML, 2006.
Dallas Lankford, On proving term rewriting systems are noetherian, Tech. report, Louisiana Tech University, 1979.
Franois Mtayer, Resolutions by polygraphs, Theory and Applications of Categories 11 (2003), 148–184.
Detlef Plump, Term graph rewriting, Handbook of Graph Grammars and Computing by Graph Transformation 2 (1999), 3–61.
John von Neumann, Theory of self-reproducing automata, University of Illinois Press, 1966.
