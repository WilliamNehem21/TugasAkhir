Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 352 (2020) 5–27
www.elsevier.com/locate/entcs
Weakest Preconditions in Fibrations
Alejandro Aguirre 1,2
IMDEA Software Institute & Universidad Polit´ecnica de Madrid Campus de Montegancedo, 28223 Pozuelo de Alarc´on, Madrid, Spain
Shin-ya Katsumata1,3
National Institute of Informatics
2-1-2 Hitotsubashi, Chiyodaku, Tokyo, Japan

Abstract
Weakest precondition transformers are useful tools in program verification. One of their key properties is compositionality, that is, the weakest precondition predicate transformer (wppt for short) associated to program f; g should be equal to the composition of the wppts associated to f and g. In this paper, we study the categorical structure behind wppts from a fibrational point of view. We characterize the wppts that satisfy compositionality as the ones constructed from the Cartesian lifting of a monad. We moreover show that Cartesian liftings of monads along lax slice categories bijectively correspond to Eilenberg-Moore monotone algebras. We then instantiate our techniques by deriving wppts for commonplace effects such as the maybe monad, the non-empty powerset monad, the counter monad or the distribution monad. We also show how to combine them to derive the wppts appearing in the literature of verification of probabilistic programs.
Keywords: Weakest precondition predicate transformer, Monad, Computational effects, Fibered category theory, Hoare logic.


Introduction
Dijkstra’s weakest precondition predicate transformer (wppt for short) [6] computes, for a given imperative program f and a predicate Q, the weakest predicate P such that, for any input x satisfying P , f (x) is guaranteed to satisfy Q. When the imper- ative program f always terminates and only updates the memory deterministically, the behavior of f can be modeled as an endofunction [f ] over the set M of memory

1 This research was supported by ERATO HASUO Metamathematics for Systems Design Project (No. JPMJER1603), JST. This research was conducted during the first author’s visit to the National Institute of Informatics. The authors are grateful to Satoshi Kura for detailed comments on this paper, and to anonymous reviewers for careful reading of our manuscript and constructive feedback.
2 Email: alejandro.aguirre@imdea.org
3 Email: s-katsumata@nii.ac.jp

https://doi.org/10.1016/j.entcs.2020.09.002
1571-0661/© 2020 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

configurations, and the weakest predicate P is defined so that [P ]] ⊆ M (memory configurations satisfying P ) corresponds to the inverse image of [Q]] ⊆ M along [[f ]]. One of the key properties of predicate transformers that make them suitable for program verification is composability: the weakest precondition wp(f ; g, Q) of a composite program f ; g is equal to the composition of the weakest preconditions of its components, that is, wp(f, wp(g, Q)). This allows for predicate transformers to be defined and applied inductively over the structure of a program.
Following Dijkstra’s seminal work, wppts and their variants have been applied to program verification in different manners, such as computing expected values over outputs of probabilistic programs [29], estimating runtime [16], or estimating tail bounds of rewards over control-flow graphs [21]. The motivation of this paper is to identify a mathematical structure behind these variations of wppt-like semantics. Towards this goal, in this paper we set out to study wppts and their composability in ﬁbrations. Roughly speaking, a fibration is a functor p : P → C that exposes a relationship between a category P of predicates and an underlying category C modeling computation - when pP = X holds, we regard P ∈ P as a predicate over X ∈ C; this viewpoint is shared with the categorical study of reﬁnement types [30]. Fibrations are especially suited to interpret predicate transformers and their composability thanks to the Cartesian lifting property, which allows us to take the “inverse image” of Q ∈ P along a morphism f : X → pQ in C, resulting an object f∗Q ∈ P such that p(f∗Q) = X. This is a categorical abstraction of the inverse image operation.
We now consider extending the imperative programming language (whose pro- grams are modeled as functions of type M → M ) and its Hoare logic with side effects. 4 To give the denotational semantics to both systems in the monadic style

[32], we employ a pair of monads T on C and T˙
on P such that p strictly pre-

serve the monad structure - the latter is called a lifting of T along p. We then

regard morphisms in PT˙
as interpretations of Hoare triples. This induces a natural

wppt that characterizes the Hoare triple, but it does not satisfy the composabil-
ity in general. This raises the question of when monadic computations do induce compositional predicate transformers. In this paper, we answer to this question by introducing the property called Cartesian-ness on monad liftings, and contribute to its understanding as follows:
We show that the wppt defined using a monad lifting is composable if and only if the monad lifting is Cartesian. This result establishes the tight connection between the composability of wppts in monadic setting and the Cartesian-ness of liftings.
We study Cartesian liftings of monads along domain fibrations from lax slice categories. For this class of fibrations, there is a bijective correspondence be- tween Cartesian liftings of a monad T and Eilenberg-Moore monotone algebras

4 Here side effects refer to those that can not be modeled by memory update functions of type M → M, such as input, output, nondeterministic choice, probabilistic choice, and manipulating an external memory device. The last one may be modeled by the state monad S ⇒ (−× S) employing the set S of states taken independently from M.

of T ; this is exhibited through the monoidal isomorphism between the category of algebras (of varying endofunctors) over the slicing object and the category of fibered functors between domain fibrations. This result simplifies the task of exploring Cartesian liftings of monads along such fibrations. We also relate strongest postcondition predicate transformers as left adjoints to wppts, and discuss when they are available in domain fibrations.
Computational effects are often modeled by composite monads via distributive laws. We extend the correspondence given in (ii) to Cartesian liftings of com- posite monads and pairs of Eilenberg-Moore monotone algebras satisfying an extra coherence law given in [4,27]. This correspondence provides a modular method to compute Cartesian liftings of composite monads.
To compute the wppts of the programs containing effectful commands (such as probabilistic choice and counting), we study the interaction between Plotkin and Power’s algebraic operations [34], which are a categorical models of effectful commands, and wppts studied in (ii).
Apart from domain fibrations, we illustrate a few examples of Cartesian lift- ings of monads along relational fibrations. They are outside of the framework presented in [11] and [13].
These studies allow us to define liftings of monads (and therefore, wppts) from their algebras, as well as defining transformers for composite monads by composing individual algebras. We illustrate this by defining predicate transformers for monads in the literature: the maybe monad, the non-empty powerset monad, the counting monad, the distribution monad and the indexed distribution monad. Then we show how to combine these to recover predicate transformers in the literature, such as the expected runtime transformer by Kaminski et al. [16] and the higher-order moment transformer by Kura et al. [21].
Preliminaries
Composition of functors, and whiskering [42] of functors and natural transforma- tions are denoted by juxtaposition. The vertical and horizontal composition of natural transformations are denoted by  and ∗ respectively.
We omit the definitions of monads, Eilenberg-Moore (EM for short) algebras of monads and Kleisli categories of monads; see e.g. [24, Section VI]. Let (T , ηT , μT ) be
a monad on a category C. The Kleisli lifting of f : X →T Y is f #T Δ T ◦T . When
= μY
T is obvious from context, we simply write f # to mean f #T . The Kleisli category of T is denoted by CT , and composition in it is denoted by •. The adjunction between C and CT is called the Kleisli resolution of T . Following [32], we regard morphisms in CT as abstract representations of programs causing computational effects.
Let (S, ηS , μS ) be another monad on C. A distributive law [4] of S over T is a natural transformation α : ST → T S such that
ηT S = α٨ SηT	α٨ SμT = μT S ٨ T α٨ αT	T ηS = α٨ ηS T	α٨ μS T = T μS ٨ αS ٨ Sα

The distributive law yields the monad (T S, ηT ∗ ηS , (μT ∗ μS ) (T αS)) over the composite functor. We denote this monad by T ◦α S.

Fibrations
Dijkstra’s weakest preconditions manipulate predicates over memory configurations. In the abstract study of predicate transformers, however, it is convenient to extend the concept of predicates so that they can be defined over arbitrary objects on a category. For this abstract and general treatment of predicates, we leverage the notions of ﬁbered category theory (see e.g. [14]). Before introducing these concepts, we give an informal account of them.
Given a category C (whose objects we denote with letters X, Y , Z) we aim to define predicates over its objects by introducing a category P (whose objects we denote with P, Q, R) and a functor p : P → C. We understand this general situation as follows:
An object in P is a predicate above some object in C, which is recorded by the functor p : P → C. That is, pP = X means that P ∈ P is a predicate over X ∈ C.
A morphism f : P → Q in P is a witness of the fact that the underlying mor- phism pf : pP → pQ in C “respects” these predicates, that is, pf maps elements satisfying the predicate P to those satisfying the predicate Q. In particular, if f : P → Q satisfies pf = idX, then f witnesses that P implies Q.
Inverse images under the functor p : P → C for an object X ∈ C form a category denoted by PX, known as the ﬁber category above X. Formally, an object of PX is a P-object P ∈ P such that pP = X, and a PX-morphism from P to Q is a P-morphism f : P → Q such that pf = idX. Intuitively, objects of this category are predicates over X and morphisms witness the implications between them.
Underlying weakest precondition predicate transformers, the strength of pred- icates are compared by an order relation, so we focus our attention on posetal ﬁbrations. Recall that the weakest precondition predicate transformer collects all the memory configurations that entail the postcondition. Set-theoretically, this op- eration is called inverse image, and ﬁbrations offers a more general and flexible treatment of inverse images. Roughly speaking, a fibration is a functor p : P → C such that for any f ∈ C(X, Y ) and P ∈ PY , we can find the inverse image f∗P ∈ PX of P along f . Formal definition of posetal fibration follows.
For objects P, Q ∈ P and a morphism f ∈ C(pP, pQ), we define the set Pf (P, Q) of P-morphisms above f by Pf (P, Q)= {k ∈ P(P, Q) | pk = f}.
A morphism k ∈ P(P, Q) is Cartesian if for any R ∈ P and h ∈ C(pR, pP ), the postcomposition of k, regarded as a function of type Ph(R, P ) → Ppk◦h(R, Q), is a bijection. This is the universal property of Cartesian morphism. A Cartesian morphism k : P → Q abstractly represents the situation that P is an inverse image of Q along pk.
A functor p : P → C is a ﬁbration if for any f ∈ C(X, Y ) and Q ∈ PY , there is an object P ∈ PX and a Cartesian morphism k ∈ Pf (P, Q) called the cartesian

lifting of f with Q.
A fibration p : P → C is posetal if each fiber category PX is a poset. In any posetal fibration the Cartesian lifting of f ∈ C(X, Y ) with Q ∈ PY uniquely exists; we therefore denote it by fQ and its domain by f∗Q. We note that posetal fibrations are faithful. From these, a morphism f : P → Q in P is Cartesian if and only if P = (pf )∗Q.
For f ∈ C(X, Y ), the assignment Q ∈ PY '→ f∗Q ∈ PP extends to a functor of type PY → PX, which we call the reindexing functor. The assignment f '→ f∗ furthermore satisfies (idX)∗ = idP  and (g ◦ f )∗ = f∗ ◦ g∗.
A ﬁbered functor between posetal fibrations p : P → C and q : Q → D is a pair

of functors F : C → D and F˙
: P → Q such that q ◦ F˙
= F ◦ p, and F˙
preserves

Cartesian morphisms. This is equivalent to: for any object P ∈ P and morphism f : X → pP in C, F˙ (f∗P )= (Ff )∗(F˙ P ). Given two fibered functors (F, F˙ ), (G, G˙ ) from p : P → C to q : Q → D, a 2-cell from the former to the latter is a pair

of natural transformations α : F → G and α˙
: F˙
→ G˙
such that qα˙
= αp. The

2-category determined by these data is denoted by Pos-Fib. We say that a 2-cell
(α, α˙ ) is Cartesian if F˙ P = α∗ (G˙ P ). The subcategory of Pos-Fib(p, q) whose
2-cells are restricted to Cartesian ones is denoted by Pos-Fibc(p, q).
Further restriction of posetal fibrations is possible. Let K be a subcategory of the category Pos of posets and monotone functions. A K-fibration p : P → C is a posetal fibration such that each fiber category PX and each reindexing functor f∗ belong to K. A K-fibered functor (F, F˙ ) from a K-fibration p : P → C to another
one q : Q → D is a fibered functor from p to q such that the restriction of F˙ to
each fiber PX becomes a morphism of type PX → QFX in K. We write K-Fib for
the sub-2-category of Pos-Fib (resp. Pos-Fibc) where 0-cells are K-fibrations and 1-cells are K-fibered functors. 2-cells remain the same.
Dijkstra Structures and Weakest Precondition Pred- icate Transformers
In the previous section, we have seen how to define a category of predicates P over a category C. We next add computational effects modeled by some monad T to this situation. We aim to model the statement that a monadic computation f : X →T Y respects pre- and post-conditions, given as predicates over X and Y respectively.

For this purpose, the first step is defining a lifting of T into a monad T˙
over P.

Definition 3.1 Let p : P → C be a posetal fibration and (T , η, μ) be a monad on

C. A monad (T˙ , η˙, μ˙ ) on P satisfying pT˙
= T p, pη˙ = ηp and pμ˙
= μp is called a

lifting of T (along p). We say that the lifting is:
ﬁbered if (T , T˙ ) is a fibered functor from p to p, and

Cartesian if it is fibered and μ˙
and η˙ are Cartesian, that is, P = η∗
(T˙ P ) and

T˙ T˙ P = μ∗ T˙ P .
The concept of monad lifting is not new; it appeared as a semantic counterpart

of logical relations for monads [7,8,10,17,18]; Hermida considered the comonadic case earlier than these works [12, Chapter 5]. The definition of Cartesian lifting of monads makes sense when p is a non-posetal fibration. When C is a category with pullbacks, a monad T on C is Cartesian (see e.g. [23, Section 4.1]) if and only if the evident lifting T → : C→ → C→ of T to the arrow category C→ along the codomain fibration cod : C→ → C is Cartesian.

The tuple consisting of a posetal fibration p,a monad T and its lifting T˙
along

p provides us a setting where we define an abstract notion of Hoare triple and the wppt associated to it.
Definition 3.2 [Dijkstra Structure] A (resp. fibered, Cartesian) Dijkstra structure
is a tuple (p, T , T˙ ) of a posetal fibration p : P → C, a monad T on C and a (resp.

fibered, Cartesian) lifting T˙
of T along p.

Definition 3.3 Let (p : P → C, T , T˙ ) be a Dijkstra structure. Below X, Y range over C-objects.
For any f : X → T Y in C and P ∈ PX ,Q ∈ PY , we define the Hoare triple
P{f}Q by

Δ
P{f}Q ⇐⇒ ∃
f˙ ∈ P(P, T˙ Q) . pf˙ = f.	(1)

Such f˙ is unique because p is faithful.
We define the weakest precondition predicate transformer (wppt for short) wp :
C(X, T Y ) × PY → PX by


Δ
wp(f, Q) = f
∗(T˙ Q).	(2)

These two concepts are linked by the equivalence P ≤ wp(f, Q) ⇐⇒ P{f}Q. The Hoare triple and the wppt in our categorical setting are more general than the standard ones since we can supply any P-object and C-morphism to the wppt. This liberation allows us to relate the composability of the wppt and the Cartesian-ness of T˙ . Since wp takes a Kleisli morphism as an argument, the composability should
be discussed with respect to the Kleisli composition.
Theorem 3.4 Let (p, T , T˙ ) be a Dijkstra structure.  We have inequalities wp(ηpP ,P ) ≥ P and wp(f • g, P ) ≥ wp(g, wp(f, P )) for any f, g, P of appropri- ate type. Moreover, they become equalities if and only if the Dijkstra structure is Cartesian.

Proof. The unit η˙P : P → T˙ P of T˙
is above ηpP . Therefore

wp(ηpP ,P )= η∗ (T˙ P ) ≥ P. 
If η˙P is Cartesian, this inequality becomes an equality. Next, the multiplication

μ˙ P : T˙ T˙ P → T˙ P of T˙
is above μpP . Therefore T˙ T˙ P ≤ μ∗
T˙ P ; this becomes an

equality if μ˙ is Cartesian. Moreover, for any X ∈ C,P ∈ P and f : X → pP , we

have T˙ (f∗P ) ≤ (T f )∗(T˙ P ); this becomes an equality if T˙
if fibered. From these,

we obtain the following inequality, which becomes an equality if μ˙ is Cartesian and
T˙ is fibered.
(f • g)∗(T˙ P )= (μ ◦T f ◦ g)∗(T˙ P )= g∗((T f )∗(μ∗(T˙ P )))
≥ g∗((T f )∗(T˙ T˙ P )) ≥ g∗(T˙ (f∗(T˙ P )) = wp(g, wp(f, P )).

We have thus proved the inequalities about wp for a general Dijkstra Structure (p, T , T˙ ), and if it is Cartesian, these inequalities become equalities.
Conversely, let (p, T , T˙ ) be a Dijkstra Structure, and assume
P = wp(ηpP ,P )= η∗ (T˙ P ),	(3)
g∗T˙ (f∗T˙ P )= wp(g, wp(f, P )) = wp(f • g, P )= f∗(Tg)∗μ∗ T˙ P.	(4)
Below let X = pP . (3) implies that η˙P is Cartesian. By letting g = idTTP and
f = idTP in (4), we obtain T˙ T˙ P = μ∗ (T˙ X), hence μ˙ P is Cartesian. By letting
g = idTX and f = ηX ◦ h : Y → X → TX for some h : Y → X in (4), we obtain

T˙ (h∗P )= T˙ (h∗η∗ T˙ P )= (T h)∗(T˙ P ), hence T˙
is fibered.	2

Therefore in a Cartesian Dijkstra structure (p : P → C, T , T˙ ), the wppt becomes a functor of type (CT )op → Pos. The corresponding fibration (by Grothendieck construction) coincides with the extension of p to Kleisli categories:
Corollary 3.5 Let (p, T , T˙ ) be a Cartesian Dijkstra Structure. We take Kleisli

resolutions L E R : CT → C of T and L˙ E R˙ : PT˙
→ P of T˙ . We deﬁne the functor

pT ,T˙
: PT˙
→ CT by pT ,T˙ P = pP and pT ,T˙ f = pf. Then

pT ,T˙ is a posetal ﬁbration whose pullback coincides with the wppt: f∗P =
wp(f, P ).
For each X ∈ C, we have the isomorphism between ﬁber categories: (PT˙ )LX ∼=
PX .
(L, L˙ ) and (R, R˙ ) form a ﬁbered adjunction (see [14, Exercise 1.8.10]) between
p and pT ,T˙ .
A recent work [2] presents the failure of the composability of the relational pre- expectation operator (rpeo for short). We associate their problem and our setting. Their rpeo coincides with our categorical wppt in the Dijkstra structure (p, D, K), where p : EPMet → Set is the forgetful functor from the category of extended pseudometric spaces (which is a partial order fibration), D is the finite probability distribution monad (Example 5.6), and K is the Kantorovich metric construction, known as a lifting of the finite probability distribution monad D along p. Since it fails to satisfy composability, we conclude that K is not Cartesian.
Dijkstra Structures on Lax Slice Categories
In the setting of an arbitrary fibration, we are unaware of any general way of con- structing Cartesian liftings of monads. However, in the specific case of domain ﬁbra- tions from lax slice categories, there is a recipe for constructing Cartesian liftings.

In this section, we will study this recipe abstractly, and we will then instantiate it for the examples in Sections 5-7, by constructing various Cartesian liftings of monads along domain fibrations.
With the goal of having fibers with structure of posets, we consider slices over ordered objects, defined as:
Definition 4.1 An ordered object in a category C is a pair of an object Ω ∈ C and an assignment of a partial order ≤X to the homset C(X, Ω) for each X ∈ C. These partial orders should satisfy: for any h : Y → X, i ≤X ij implies i ◦ h ≤Y ij ◦ h.
Example 4.2 A typical way to give an ordered object in Set is to take a poset (Ω, ≤) and define the partial order ≤X on Set(X, Ω) to be the pointwise order of functions. Examples in Section 5-7 all uses domain fibrations arising from this kind of ordered object.
From an ordered object (Ω, ≤) in C, we define the lax slice category C/Ω. Its objects are C-morphisms into Ω. A morphism from i to j is a morphism h ∈ C(X, Y ) such that i ≤dom(i) j ◦ h. The domain functor dC,Ω : C/Ω → C defined by

dC,Ω
Δ
i =dom(i) and d
C,Ω
Δ
(f ) = f is a posetal fibration, and the fiber category (C/Ω)X

at X ∈ C is the poset (C(X, Ω), ≤X). The pullback of i : X → Ω along h : Y → X
is given by h∗i = i ◦ h.
For the remainder of this section, let C be a category and (Ω, ≤) an ordered object in C.
We are particularly interested in fibered / Cartesian Dijkstra structures of the form (dC,Ω, T , T˙ ). In fact, a pair (T , T˙ ) making the triple a fibered / Cartesian Dijkstra structure is nothing but a monoid object in the strict monoidal category (Pos-Fib(dC,Ω, dC,Ω), Id, ◦) / (Pos-Fibc(dC,Ω, dC,Ω), Id, ◦) respectively. To study these monoidal categories and monoids therein, we introduce the closely related concept of monotone algebras over Ω. In the coalgebra community, it has been used to determine predicate liftings of coalgebra functors [19,38,5].
Definition 4.3 Let F : C → C be a functor. A monotone F-algebra over Ω is an F -algebra o : F Ω → Ω such that the implication i ≤X ij =⇒ o ◦ Fi ≤FX o ◦ Fij holds for any i, ij ∈ C(X, Ω).
From this definition, a monotone F -algebra o : F Ω → Ω determines a lifting Fo : C/Ω → C/Ω of the functor F along dC,Ω : C/Ω → C. It is given by Fo(i) , o ◦ Fi. To understand the assignment o '→ Fo better, we form the category MAlgC,Ω of monotone algebras over Ω as follows. An object is a pair (F, f ) of a functor F : C → C and a monotone F -algebra o over Ω. A morphism from (F, o) to (G, oj) is a natural transformation α : F → G such that o ≤F Ω oj ◦αΩ. The unit and tensor
Δ	j	j
product are defined by I = (IdC, idΩ) and (F, o) ⊗ (G, o ) , (F ◦ G, o ◦ Fo ). We
define MAlgC,Ω to be the wide subcategory of MAlgC,Ω where a morphism from (F, o) to (G, oj) is a natural transformation such that o = oj ◦ αΩ. The following result lays out the relationship between fibered functors and monotone algebras.

Theorem 4.4 There are monoidal isomorphisms of categories
(MAlgC,Ω, I, ⊗)  (Pos-Fib(dC,Ω, dC,Ω), Id, ◦), (MAlgC,Ω, I, ⊗)  (Pos-Fibc(dC,Ω, dC,Ω), Id, ◦).

The object part of this isomorphisms is already shown as [5, Proposition 12]. By unfolding the definition, a monoid object in MAlgC,Ω consists of a monad (T , η, μ) and a monotone T -algebra o : T Ω → Ω satisfying idΩ ≤ o ◦ ηΩ and o ◦T o ≤ o ◦ μΩ. We call o a lax EM monotone T -algebra over Ω. A monoid object in MAlgC,Ω is exactly a pair of a monad T and an EM monotone T -algebra over Ω. From Theorem 4.4, we obtain the following correspondence:
Corollary 4.5 For any monad T on C, there is a bijective correspondence between a (resp. lax) EM monotone T -algebra over Ω and a Cartesian (resp. ﬁbered) lifting of T along dC,Ω.
We end this section by summarizing wppts of the Cartesian Dijkstra structures arising from EM monotone algebras.
Corollary 4.6 Let T be a monad on C, o be an EM monotone T -algebra over Ω, and T o be the corresponding Cartesian lifting of T along dC,Ω by Corollary 4.5. The wppt in the Dijkstra structure (dC,Ω, T , T o) satisﬁes
wp(f, i)= o ◦ Ti ◦ f.

The same holds when o is a lax EM monotone T -algebra and T o is the corresponding ﬁbered lifting of T .

Further Restriction of Domain Fibrations
We consider imposing further conditions on the partial order given to the homset C(P, Ω). Let K be a subcategory of Pos. We say that an ordered object (Ω, ≤) in C belongs to K if 1) the poset (C(X, Ω), ≤X) belongs to K for any X ∈ C, and
2) for any C-morphism h : Y → X, the function −◦ h : C(X, Ω) → C(Y, Ω) is a morphism of type (C(X, Ω), ≤X) → (C(Y, Ω), ≤Y ) in K.
Lemma 4.7 Let K be a subcategory of Pos. For any ordered C-object (Ω, ≤) be- longing to K, the domain ﬁbration dC,Ω : C/Ω → C is a K-ﬁbration.
Next, fix an ordered object (Ω, ≤) in C belonging to K. For an endofunctor F : C → C, we say that o : F Ω → Ω is a K-algebra if for any X ∈ C, the function o ◦ F− : C(X, Ω) → C(FX, Ω) is a K-morphism of type (C(X, Ω), ≤X
) → (C(FX, Ω), ≤FX). We write K-AlgC,Ω for the full (monoidal) subcategory of
MAlgC,Ω consisting of K-algebras.
Theorem 4.8 Let K be a subcategory of Pos and (Ω, ≤) be an ordered C-object belonging to K. There is a monoidal isomorphism of categories (K-AlgC,Ω, I, ⊗) 
(K-Fibc(dC,Ω, dC,Ω), Id, ◦).

Example 4.9 We write CLat∧ for the category of complete lattices and monotone functions preserving all meets. This is a subcategory of Pos. When we view the two- point poset 2 = {⊥ ≤ ⊆} as an ordered object in Set (as done in Example 4.2), it
belongs to CLat∧. Therefore dSet,2 : Set/2 → Set is a CLat∧-fibration. Further- more, for any (T , T˙ ) ∈ CLat∧-Fibc(dSet,2, dSet,2) the associated wppt preserves meets, i.e. wp(f, Vi P i) = Vi wp(f, P i). In the context of program verification,
such wppts are called conjunctive.
Strongest Postcondition Predicate Transformers
We turn our attention to strongest postcondition predicate transformers. In Hoare logic, the strongest postcondition with respect to a program f and a precon- dition φ is a formula ψ such that 1) φ{f}ψ holds, and 2) ψ entails ξ in the Hoare logic whenever φ{f}ξ holds. We formulate the concept of strongest postconditions
in a Dijkstra structure (p : P → C, T , T˙ ). The strongest postcondition with respect
to a morphism f : X → T˙ Y in C and an object P ∈ PX is an object S ∈ PY such
that for any Q ∈ PY , S ≤ Q if and only if P{f}Q. If such S exists, it is uniquely determined by f and P , hence we write it by sp(f, P ). To summarize, we obtain the three-way equivalence:
sp(f, P ) ≤ Q ⇐⇒ P{f}Q ⇐⇒ P ≤ wp(f, Q).
Therefore if sp(f, P ) exists for any f, P , we obtain a function sp : C(X, T Y ) × PX → PY called the strongest postcondition predicate transformer, and sp(f, −) is characterized as a left adjoint of wp(f, −).
When programs are simply modeled as endofunctions over the set of memory configurations, sppts correspond to direct images. A categorical abstraction of this operation is pushforward [31, Example 6] in op-ﬁbrations, which we briefly review below. A functor p : P → C is an op-fibration if pop : Pop → Cop is a fibration. Given P ∈ P, Y ∈ C and f : pP → Y in C, the op-Cartesian lifting of f along the op-fibration is denoted by f P , and its target by f∗P , which is called the pushforward of P along f . A functor that is both a fibration and an op-fibration is known as a biﬁbration. Posetal bifibrations can be characterized by the following lemma:
Lemma 4.10 ([14]) Let Posr be the subcategory of Pos where morphisms are re- stricted to right adjoints between posets. A posetal ﬁbration is a biﬁbration if and only if it is a Posr-ﬁbration.
Example 4.11 Consider the case of CLat∧-fibrations. Since reindexing functors preserve arbitrary meets, they have left adjoints, which we can be computed as
f∗P = V{Q ∈ Pcodf | P ≤ f∗Q}. Since CLat∧ is a (full) subcategory of Posr,
CLat∧-fibrations are posetal bifibrations.
Existence of left adjoints allows us to define sppt’s as stated by the following result:
Proposition 4.12 Let (p : P → C, T , T˙ ) be a Dijkstra structure where p is a

posetal biﬁbration, and assume that the restriction T˙
: PX → PT X of T˙
to each

ﬁber is a right adjoint. Then for any f : X → T Y in C, wp(f, −) : PY → PX has a left adjoint sp(f, −): PX → PY . If the Dijkstra structure is Cartesian, sp is composable: sp(ηpP ,P )= P and sp(f, sp(g, P )) = sp(f • g, P ).

Lifting of Composite Monads to the Lax Slice Category
In many situations, monads for modeling computational effects are composites of simpler monads through distributive laws. We extend our lifting theory of monads to composite monads.
Let T , S be monads on C and α : ST → T S be a distributive law (see Section 2). We are interested in EM monotone algebras of T ◦α S, which give Cartesian liftings of T ◦α S. Such EM algebras are studied in [4, Section 2], [27, Theorem 2.4.3]. Below we mildly extend these results.
Theorem 4.13 Let T , S be monads on C and α : ST → T S be a distributive law. There is a bijective correspondence between each two of:
An EM monotone T ◦α S-algebra.
A pair of EM monotone algebras t : T Ω → Ω and s : SΩ → Ω satisfying
s ◦ St = t ◦T s ◦ αΩ;	(5)


A triple of Cartesian liftings T˙
of T and S˙
of S along dC,Ω and a distributive

law α˙ : S˙ T˙
→ T˙ S˙
above α whose components are Cartesian.

We note that the condition (5) appeared in [4, Section 2]. This theorem says that to identify liftings of T ◦α S, it suffices to identify all the pairs of EM monotone T - and S-algebras satisfying (5).
It is natural to seek for a lax version of the above correspondence. However, it cannot be fully generalized to the ordered setting. The problem comes from not being able to compare certain morphisms involving composition of algebras.

Specifically, o : T SΩ → Ω and o ◦T (ηS ◦ o ◦ ηT
) are in general not comparable.

Ω	SΩ
But when o is the composite t ◦T s of lax EM monotone algebras t : T Ω → Ω

and s : SΩ → Ω, we do have o ≤ o ◦T (ηS ◦ o ◦ ηT
). Therefore, we can find an

Ω	SΩ
isomorphism when we restrict it to these “well-behaved algebras”.
Theorem 4.14 Let T , S be monads on C and α : ST → T S a distributive law.

Then a lax EM monotone T ◦α S-algebra o such that o ≤ o◦T (ηS ◦o◦ηT
) bijectively

Ω	SΩ
corresponds to a pair of lax EM monotone algebras t : T Ω → Ω and s : SΩ → Ω
such that s ◦ St ≤ t ◦T s ◦ αΩ,t = t ◦T s ◦T ηS and s = t ◦T s ◦ ηT .
Ω	SΩ
Algebraic Operations and Weakest Precondition Predicate Transformer
Various program constructs that cause computational effects can be naturally mod- eled by Plotkin and Power’s algebraic operations [34]. They frequently occur in the monadic semantics of effectful programs. In this section, we give a wppt semantics of algebraic operations. We assume that C is Cartesian closed and T has a strength

θX,Y : X ×T Y → T (X × Y ). We use notations ⇒, λ, λ—1, ev for the exponential object, currying, uncurrying and evaluation.
Any morphism g : A → T B (called generic effect) equips an EM T -algebra
o : T X → X with the following operation op(o, g): A × (B ⇒ X) → X:

Δ	j


here θj
op(o, g) = o ◦T (ev) ◦ θB,B⇒X ◦ (g × idB⇒X);
: T X × Y → T (X × Y ) is the symmetric version of θ. Specifically, the

family of operations on free algebras {α(g)X }X∈C defined by α(g)X = op(μX , g) forms the algebraic operation corresponding to g. The following theorem helps us (in Section 6.2) to compute the wppt of programs involving algebraic operations:
Theorem 4.15 Let o : T Ω → Ω be an EM monotone T -algebra and T o be the Cartesian lifting of T along dC,Ω by o. For any morphisms g : A →T B, a : Y → A, b : Y → B ⇒ T X and i : X → Ω, the following equality holds in the Dijkstra structure (dC,Ω, T , T o):
wp(α(g)X ◦ ⟨a, b⟩, i)= op(o, g) ◦ ⟨a, λ(wp(λ—1(b), i))⟩.

Dijkstra Structures on dSet,2
We apply the techniques developed in the previous sections to concrete settings. We first consider the lax slice category with the poset 2 = {⊥≤ ⊆}, viewed as an ordered object in Set (Example 4.2). We identify an object i : X → 2 in Set/2 as a pair (X, P ) of sets such that P ⊆ X. The fibration dSet,2 : Set/2 → Set is isomorphic to the subobject fibration (see e.g. [14, Chapter 0]) of Set.
Example 5.1 [11, Section 2.3] As a warm-up exercise, we consider Cartesian lift- ings of the maybe monad (a.k.a. partiality monad) M along dSet,2. Its functor part
Δ
is defined by MX = X + {∗}, where {∗} denotes the singleton set. There are exactly
two EM monotone M-algebras tot, par over 2:
tot(x)= ⊆ ⇐⇒ x = ⊆,	par(x)= ⊆ ⇐⇒ (x = ⊆∨ x = ∗).

They respectively induce two Cartesian liftings Mtot, Mpar of M along dSet,2. The Dijkstra structures associated to these Cartesian liftings offer the total and partial correctness interpretations of Hoare triples.

Example 5.2 [13, Example 3.3] We next consider the Cartesian liftings of the non- empty powerset monad P+ along dSet,2. Its functor part is defined by P+X , {U ⊆ X | U /= ∅}. There are exactly two monotone EM P+-algebras may, must over 2:
may(U )= ⊆ ⇐⇒ ⊆ ∈ U,	must(U )= ⊆ ⇐⇒ ⊥ /∈ U

They induce two Cartesian liftings P+
+
must
of P+ along dSet,2. The Dijkstra

structures with these Cartesian liftings of P+ along dSet,2 offer the may and must
correctness interpretations of Hoare triples.

Example 5.3 We consider again the P+ monad of the previous example, but now we regard dSet,2 as a CLatΛ-fibration. Then must above is the only EM CLatΛ- algebra over 2. Therefore must correctness interpretation of the Hoare triple has the strongest postcondition predicate transformer.
Example 5.4 We consider the state monad S, whose functor part is defined by S X = S ⇒ X × S; here S is the set of states. However, the two-point set 2 is too small to remember stored values when |S|≥ 2. Indeed,
Theorem 5.5 When |S|≥ 2, there is no EM monotone S-algebra over 2.
The proof idea is simple, every computation needs to be associated to an element of 2 in such a way that they satisfy the algebraic theory of lookup and update studied by Plotkin and Power in [35]. If |S|≥ 2 then there exist s1 /= s2 in S and we cannot distinguish between looking up the state, storing s1 and storing s2, so a contradiction can be derived.
When we replace the slicing object 2 with S ⇒ 2 (with the pointwise order), we find that it carries an EM monotone S-algebra o(k) , λs . π1(ks)(π2(ks)); see also [25, Section 4.4]. The corresponding Cartesian lifting of S along dSet,(S⇒2) : Set/(S ⇒ 2) → Set and the derived wppt satisfies
So(i)(c)= λs . i(π1(cs))(π2(cs)),  wp(f, i)(x)= λs . i(π1(f (x)(s)))(π2(f (x)(s))).
By using the uncurrying ij and fj of i and f respectively, wppt can be simplified: wp(f, i)(x)= λs . ij(fj(x, s)).
Example 5.6 Finally, we consider the finite probability distribution monad D. A 
ﬁnite probability distribution on a set X is a function μ : X → [0, 1] such that μ is non-zero at finitely many elements in X, and Σi∈X μ(i) = 1. The functor part of the monad D is given by DX = {μ is a finite probability distribution on X}.
Theorem 5.7 There are exactly two EM monotone D-algebras over 2, given by
pmay(μ)= ⊆ ⇐⇒ μ(⊆) > 0,	pmust(μ)= ⊆ ⇐⇒ μ(⊆)=1 
They induce two Cartesian liftings Dpmay, Dpmust of D along dSet,2. The pred- icate transformers associated to them generalize the may and must correctness of nondeterministic programs to the probabilistic setting.


Here the notation Pry∼f(x)[y ∈ Q] denotes the probability of y ∈ Q when sampling
y from f (x).
We note that Cartesian liftings are rather rare, compared to arbitrary liftings. We look at the case of the powerset monad P along dSet,2. For each regular cardinal λ, Pλ(P ⊆ X)= {U ⊆ P | |U| < λ} gives a lifting of the powerset monad P along dSet,2. On the other hand, (a modification of) Example 5.2 shows that there are only two Cartesian liftings of P along dSet,2. Example 5.4 also shows that there is no Cartesian lifting of the (nontrivial) state monad along dSet,2.
Dijkstra Structures on dSet,[0,∞]
We next replace 2 with the poset [0, ∞] of non-negative extended reals, with the usual numerical order. It is a completely distributive lattice, and the domain fi- bration dSet,[0,∞] : Set/[0, ∞] → Set has a rich structure (in fact it is a tripos [33, Example 2.2]). An object of Set/[0, ∞] is a function i : X → [0, ∞], which can be seen in many different ways: random variables, assignments of cost, robustness, fuzzy predicates, reward functions, etc.
Example 6.1 We consider the counting monad C over Set, whose functor part is
Δ
given by CX = N × X. This is identical to the writer monad with a single character
(N 1∗). Each monotone function f : [0, ∞] → [0, ∞] (bijectively) determines an EM monotone C-algebra f (n, x) , f n(x), and the corresponding Cartesian lifting Cf of C along dSet,[0,∞] is given by Cf (i)(n, x) = f n(i(x)). The standard choice of f : [0, ∞] → [0, ∞] is the successor function s(x) = x + 1. In this case, the lifting becomes Csi = λ(n, x) . n + i(x).
Example 6.2 We consider Cartesian liftings of the nonempty powerset monad P+ along dSet,[0,∞]. There are at least two EM monotone P+-algebras sup, inf : P+[0, ∞] → [0, ∞]. They induce two Cartesian liftings:
P+ (i)= λU . sup i(x),	P+ (i)= λU . inf i(x)	(i : X → [0, ∞])

sup
x∈U
inf
x∈U

Example 6.3 We can view objects in Set/[0, ∞] as random variables. The ex- pected value of a random variable i : X → [0, ∞] over a probability distribution μ ∈ DX, denoted by Ex∼μ[i(x)], is computed as E ◦ Di(μ), where E : D[0, ∞] → [0, ∞] is the expected value function on [0, ∞]. It is easy to check that E is an EM monotone D-algebra over [0, ∞]. Therefore the expected value is a Cartesian lifting of D along dSet,[0,∞]:
DE(i) , λμ . Ex∼μ[i(x)] = λμ . Σ i(x) · μ(x).	(i : X → [0, ∞])
The wppt of the Cartesian Dijkstra structure (dSet,[0,∞], D, DE) computes the weak- est pre-expectation [29]:
wp(f, i)= λj . Ex∼f(j)[i(x)].	(f : Y → DX, i : X → [0, ∞])

Example 6.4 When modeling a programming language with both non- deterministic choice and probabilistic choice, we might want to combine P+ and D via a distributive law D◦ P+ → P+ ◦ D. However, Plotkin showed that there is no such distributive law [40]. To remedy this, Varacca and Winskel introduced the indexed valuation monad [40], which does have a distributive law with P+.
In this paper we employ its probabilistic variant called ﬁnite indexed distribution monad [37]. A ﬁnite indexed distribution over a set X is an unordered list of pairs (p, x) where p ∈ (0, 1] and x ∈ X, and moreover the sum of ps in the list is 1. We de-
Δ
fine I(X) = {μ : finite indexed distribution over X}. The probabilistic sum of finite
indexed distributions is defined as follows: (below @ denotes list concatenation):
Δ ⎧⎪⎨ [··· (qj , yj ) ··· ]	(p = 0)

[··· (pi, xi) ··· ] ⊕p [··· (qj , yj ) ··· ] =
[··· (p · pi, xi) ··· ]@[··· ((1 — p) · qj , yj ) ··· ] (0 < p < 1)
⎪⎩ [··· (pi, xi) ··· ]	(p = 1)

Every finite probability distribution may be regarded as a finite indexed distri- bution; we write the inclusion map by ιX : D(X) → I(X). We can extend I to a monad on Set called the ﬁnite indexed distribution monad. The concept of ex- pectation can also be extended to finite indexed distributions. First, the function IE : I([0, ∞]) → [0, ∞] defined below gives an EM monotone I-algebra over [0, ∞]:


IE[(p ,x ), ··· 
Δ Σ p

· x .

1	1	, (pn, xn)] =
i	i
i=1

We write IEx∼ν[i(x)] to mean IE ◦ (I(i)(ν)). We note that E = IE ◦ ι holds. The corresponding Cartesian lifting of I along dSet,[0,∞], and the wppt within the derived Cartesian Dijkstra structure is

IIE(i)(ν) , IEx∼ν[i(x)] = Σ
(p,x)∈ν
p · i(x),	wp(f, i)(x)=	Σ
(p,y)∈f(x)
p · i(y).


Dijkstra Structures for Composite Monads
Various intensional quantities of program executions can be measured using the counting monad in Example 6.1. The distributive law of any Set-monad T over the counting monad C exists, and is provided by the unique strength θX,Y : X ×T Y → T (X × Y ) of T (see [32]). Here we discuss giving a Cartesian lifting of T ◦θ C.
Theorem 6.5 Let o : T [0, ∞] → [0, ∞] be an EM monotone T -algebra and f : [0, ∞] → [0, ∞] be a monotone function. Then o and f (the EM monotone C- algebra associated to f; Example 6.1) satisfy (5) if and only if o ◦T = f ◦ o, that is, f is a T -algebra endomorphism over o.
Example 6.6 We consider the instance of Theorem 6.5 where T is the finite prob- ability distribution monad D. The combined monad D ◦θ C is suitable for modeling the programs that report cost counting during their executions. We will see this in Section 6.2. The EM monotone D-algebra E : D[0, ∞] → [0, ∞] and the successor

function s : [0, ∞] → [0, ∞] evidently satisfies the equality condition of Theorem 6.5:
E ◦ Ds = λμ . Ex~μ[1 + x]= λμ . 1+ Ex~μ[x]= s ◦ E.
Therefore E and s satisfy (5) by Theorem 6.5. The composite DE ◦Cs is a Cartesian lifting of D◦θC along dSet,[0,∞], and is computed as DE◦Cs(i)= λμ . E(c,x)~μ[c+i(x)].
The wppt in the Dijkstra structure (dSet,[0,∞], D ◦θ C, DE ◦ Cs) is
wp(f, j)(x)= E(c,y)~f(x)[c + j(y)]  (f : X →D ◦θ C(Y ),j : Y → [0, ∞]).
Example 6.7 The nonempty powerset monad P+ distributes over the finite in- dexed distribution monad I. The distributive law γ : I ◦ P+ → P+ ◦I is given by

Δ
γP [(p1, U1), ··· , (pn, Un)] = {[(p1, x1), ··· , (pn, xn)] | x1 ∈ U1, ··· , xn ∈ Un}.
It is easy to check that the expectation function IE : I([0, ∞]) → [0, ∞] (Example 6.4) distributes over sup : P+[0, ∞] → [0, ∞] (Example 6.2). Therefore the wppt in

the Cartesian Dijkstra structure (dSet,[0,∞], P+ ◦γ I, P+
IIE) is



wp(f, i)(j)= sup
ν∈f(j)
IEx~ν[i(x)].	(f : X → P+ ◦ I(Y ))

This wppt performs angelic choice. We can also derive the one performing demonic choice by replacing sup with inf in this argument. Finally, we compose it with the counting monad C. This yields the Cartesian Dijkstra structure (dSet,[0,∞], (P+ ◦γ

I) ◦θ C, P+
IIE ◦ Cs), whose wppt is:
wp(f, i)(j)= sup
ν∈f(j)

IE(c,x)~ν[c + i(x)].


Expected Runtime as Weakest Precondition
Kaminski et al. showed that the expected runtime of probabilistic programs can be computed using a predicate transformer-like operator called the expected runtime transformer (ert for short) [16]. We apply our theory of Dijkstra structures to derive their ert operator.
The language we consider here is a loop-free fragment of Kaminski et al.’s lan- guage. Fix sets Var, Exp, Bool of variables, probabilistic expressions and probabilis- tic boolean expressions, respectively. The syntax of the language is defined by the following BNF grammar (below x ∈ Var,e ∈ Exp,b ∈ Bool):
Prog e C := empty | C; C | x :∼ e | tick | {C}2{C} | if(b){C}{C}.
The command x :∼ e samples a value from a probabilistic expression e. The box operator {C}2{Cj} non-deterministically chooses C or Cj and executes the chosen program. The conditional expression if(b){C}{Cj}, samples a bit from a Bernoulli distribution with bias given by an expression b, then runs C if the sample is 1;

otherwise runs Cj. This conditional expression thus combines both probabilistic choice and deterministic conditionals.
Before introducing the expected runtime transformer, we prepare some inter-
pretations of primitives. We fix a set V of values and let M = V Var be the set of memory configurations. We give interpretations of e ∈ Exp and b ∈ Bool by functions [e]] : M → DV and [b]] : M → [0, 1], respectively. We also as- sume that the memory configuration update function updx : M × V → M is suitably defined for each variable x ∈ Var. The expected runtime transformer ert : Prog ×(Set/[0, ∞])M → (Set/[0, ∞])M is inductively defined as follows:
ert(empty, i)ρ = i(ρ)	ert(tick, i)ρ =1 + i(ρ)
ert(C1; C2, i)ρ = ert(C1, ert(C2, i))ρ	ert({C1}2{C2}, i)ρ = max(ert(C1, i)ρ, ert(C2, i)ρ)
ert(x :~ e, i)ρ =1 + Ev∼[[e]]ρ[i(updx(ρ, v))]  ert(if(b){C1}{C2}, i)ρ =1 + ert(C1, i)ρ ⊕[[b]]ρ ert(C2, i)ρ

To derive the ert in our framework, we first give a monadic semantics of the language using the composite monad T , (P+ ◦γ I) ◦θ C in Example 6.7. We interpret effectful commands and conditional using the following generic operations and associated T -algebraic operations (c.f. Section 4.3):
t(∗)= {[(1, (1, ∗))]}	α(t)(U )= {I(λx . x + 1)(ν)|ν ∈ U}
u(∗)= {[(1, (0, ⊆))], [(1, (0, ⊥))]}   α(u)(U, V )= U ∪ V
c(p)= {[(p, (0, ⊆)), (1 − p, (0, ⊥))]}	α(c)(p, U, V )= {ν ⊕p μ|ν ∈ U, μ ∈ V }
From these algebraic operations we define our denotational semantics:

[[empty]] = ηT	[[tick]] = α(t)M ◦ ηT
[[C1; C2]] = [[C2]] • [[C1]]	[[{C1}2{C2}]] = α(u)M ◦ ⟨[[C1]], [[C2]]⟩
[[x :~ e]] = T (updx) ◦ θM,V ◦ ⟨idM ,ι ◦ [[e]]⟩	[[if(b){C1}{C2}]] = α(c)M ◦ ⟨[[b]], [[C1]], [[C2]]⟩


Recall that in Example 6.7, we obtained a Cartesian lifting T˙
+
sup
IIE ◦ Cs of

T along dSet,[0,∞]. In the Dijkstra structure (dSet,[0,∞], T , T˙ ), wp([[C]], i) satisfies
wp([[empty ], i)ρ = i(ρ)	wp([[tick]], i)ρ =1 + i(ρ)
wp([[C1; C2]], i)ρ = wp( [C1]], wp([[C2]], i))ρ	wp([[{C1}2{C2}]], i)ρ = max(wp([[C1]], i)ρ, wp([[C2]], i)ρ)
wp([[x :~ e]], i)ρ = Ev∼[[e]]ρ[i(updx(ρ, v))]	wp([[if(b){C1}{C2}]], i)ρ = wp( [C1]], i)ρ ⊕[[b]]ρ wp([[C2]], i)ρ

This is already very close to Kaminski et al’s expected runtime transformer. The major difference between wp and ert is that the latter adds 1 to reflect the time consumption by probabilistic assignments and probabilistic conditionals. This dif- ference can be resolved by an accounting transformation A defined below. It inserts a tick command before time-consuming instructions:



Theorem 6.8 Under the Cartesian Dijkstra structure (dSet,[0,∞], T , T˙ ), we have
ert(C, i)= wp( [A(C)]], i).

Dijkstra Structures on dSet,[0,∞]n
As our final example we consider predicates that take values over [0, ∞]n. Kura et al. [21] study the problem of estimating the value of higher moments of the runtime of a program, with the goal of computing bounds on tail probabilities. That is, their techniques allow us to estimate expected values of the form E[T n], where T is the runtime of an execution of a program. These higher-order moments are computed with a wppt-like operator that acts on the set of configurations of a control-flow graph and that propagates functions from configurations to [0, ∞]n backwards through the graph.
We derive this operator as a wppt in a suitable Cartesian Dijkstra structure on a domain fibration (unlike [21] here we do not consider the nondeterministic
computations). Consider again the composite D ◦θ C of the counter monad and the finite probability distribution monad considered in Example 6.6. Let Un denote
the upper-triangular n × n matrix such that (Un)i,j = j whenever i ≤ j and 0

i
otherwise. Then we define a family of operation called tickn : [0, ∞]n
→ [0, ∞]n
to be

the affine map: tickn(r1,..., rn)= (r1,..., rn) · Un + (1,..., 1). This coincides with
the elapse function defined in [21]. From this, we derive a family of EM monotone C-algebras tickn : C[0, ∞]n → [0, ∞]n. On the other hand, we take the product of n-many copies of the EM monotone D-algebra of E : D[0, ∞] → [0, ∞] in Example
6.3. We name the resulting monotone algebra En : D([0, ∞]n) → [0, ∞]n. It follows from affinity of the tickn operator and linearity of the expected value that tickn is a D-algebra endomorphism over En. From Theorem 6.5, we obtain the Cartesian

lifting DEn ◦ Ctickn of D ◦θ C along d
Set,[0,∞]n
Set,[0,∞]n
: Set/[0, ∞]n
→ Set. In the Dijkstra

structure (d
, D ◦θ C, DEn ◦ Ctickn ), the wppt satisfies the definition below,

which coincides with the Fn operator from [21]:
Δ	Δ	Σ


Σ k 

wp(f, p)(j) = (wp1(f, p)(j),..., wpn(f, p)(j)),  wpk (f, p)(j) =

c∈[0,∞],i∈X
f(j)(c, i) ·

l=0
cl—kpl(i).
l


Dijkstra Structures on Relational Fibrations
So far we have seen examples of fibrations from lax slice categories, whose objects represent Ω-valued predicates as morphisms of type X → Ω. In this section we consider Ω-valued relations represented as morphisms of type X ⊗ Y → Ω, and consider Cartesian liftings of monoidal monads to Ω-valued relations.
Let (C, I, ⊗) be a monoidal category and (Ω, ≤) be an ordered object in C. We take the pullback of dC,Ω : C/Ω → C along the tensor product functor ⊗ : C2 → C in CAT:

BRel(C, Ω)
rC,Ω
  
 C/¸Ω
dC,Ω
  

C2	⊗	 C¸
This is a typical way to derive fibrations for binary relations [14,5]. The resulting projection functor, which we name rC,Ω : BRel(C, Ω) → C2, is a fibration. The

concrete description of BRel(C, Ω) is the following: objects are triples (X, Y , i : X ⊗ Y → Ω) of two objects and a morphism in C, and a morphism from (X, Y , i) to (Xj,Y j, ij) is a pair of C-morphisms f : X → Xj and g : Y → Y j such that i ≤X⊗Y ij ◦ (f ⊗ g). Intuitively, BRel(C, Ω) is the category of Ω-valued binary relations between C-objects, represented as morphisms in C. In the fibration rC,Ω, the pullback is given by (f, g)∗(X, Y , i)= i ◦ (f ⊗ g).
Theorem 8.1 Let C be a monoidal category, (T , mI, mX,Y , η, μ) be a monoidal monad on it, and o be an EM monotone T -algebra over Ω. Then the mapping T o deﬁned by T o(X, Y , i)= (T X, T Y, o ◦T i ◦ mX,Y ) extends to a Cartesian lifting of the monad T 2 on C2 along rC,Ω : BRel(C, Ω) → C2.
We first set C = Set, Ω = 2, and instantiate Theorem 8.1 with T = P+ and o ∈ {may, must} (Example 5.2); notice that the monad P+ is commutative, hence carries a symmetric monoidal structure with respect to the Cartesian monoidal structure of Set [20]. We identify an object in BRel(Set, 2) and a triple of sets (X, Y , R) where R ⊆ X × Y . The theorem derives the following Cartesian liftings of (P+)2 along rSet,2 : BRel(Set, 2) → Set2:
T may(X, Y , R)= (P+X, P+Y, {(U, V ) | ∃u ∈ U . ∃v ∈ V . (u, v) ∈ R})
T must(X, Y , R)= (P+X, P+Y, {(U, V ) | ∀u ∈ U . ∀v ∈ V . (u, v) ∈ R}).
We next set C = Set, Ω = [0, ∞] and instantiate Theorem 8.1 with T = D, which is commutative, and o = E (Example 6.3). The theorem derives the following Cartesian lifting of D2 along rSet,[0,∞] : BRel(Set, [0, ∞]) → Set2; below μ ⊗ ν is the product distribution:
DE(X, Y , i)= (DX, DY , λ(μ, ν) . E(x,y)~μ⊗ν[i(x, y)]).
Related Work
The interpretation of Hoare logic has been pursued using other structures than fibrations. Abramsky et al. introduce speciﬁcation structures as a loose framework for general Hoare logic [1]. It is easy to see that a Dijkstra structure in our setting determines a specification structure. Specification structures themselves do not provide wppts, and computational effects are not explicitly modeled.
Martin et al. [28] give a categorical framework for Hoare logic using certain func- tors of type H : S → PreOrd. They correspond to opﬁbrations, hence they offers strongest postconditions predicate transformers instead. Computational effects are not explicitly modeled. One unique feature of [28] is that their Hoare logic supports trace operators in the sense of Joyal et al [15]. Supporting (possibly diverging) loop in our framework is missing, and an interesting future work.
In [9], Goncharov et al. constructed semantics of Hoare logic from a pair (P, T ) of an order-enriched monad T and an innocent submonad P of T . They showed that P1 is a frame, and used this fact to interpret Hoare logic predicates by morphisms of type X → P1. They introduced the wppt using the join of P1 in [9], and called its

composability sequential compatibility. Later they showed the wppt induced from the pair (P, T ) is sequentially compatible if and only if the canonical morphism T P1 → P1 is an EM-algebra [36, Remark 11]. This fact bridges the work [9,36] and the following approach studied by Hasuo.
In [11], Hasuo introduced PT situations to construct composable wppts. A PT situation is a tuple of an order-enriched monad (T , ≤) (in a different sense from [9]), an object Ω ∈ C and an EM T -algebra τ on T Ω, satisfying certain conditions. Each PT situation induces a functor PKl(τ ): (CT )op → Pos embodying a wppt. The construction of PKl can be accounted for by the recipe given in Section
4. Let (T , ≤, Ω,τ ) be a PT situation. It determines an ordered object (T Ω, ≤)
in C, and τ is monotone [11, Definition 2.4]. Using the recipe in Section 4, it determines a Cartesian lifting T τ of T along dC,T Ω : C/T Ω → C. Then the wppt wp in the Cartesian Dijkstra structure (dC,T Ω, T , T τ ) coincides with PKl(τ ). This demonstrates that the recipe in Section 4 generalizes the construction of PKl(τ ) given in [11]. Especially, our recipe does not demand order enrichment on T , and allows us to take arbitrary ordered object (not limited to the form T Ω) as the basis of the lax slice construction. Examples 5.2, 5.4, 5.6 are benefited from this generalization.
In [13], Hino et al. introduced another construction of wppts using relative algebras. A relative algebra is a monad morphism of type T → D(Ω—, Ω), where T is a Set-monad and D is a category with powers ΩI [24, Section X.4 (4)] of a fixed D-object Ω. They construct wppts by composing the comparison functor SetT → SetT [24, Theorem VI.3] and the functor SetT → Dop induced by an relative algebra [13, Theorem 4.8]. When D = Pos, their wppts coincide with those of Cartesian liftings of T along the posetal fibration dSet,Ω in Section 4. Therefore examples in Section 5-7 are also covered by the relative-algebra based wppts. On the other hand, materials in Section 4.2 and 4.3 are new compared to [13]. Particularly, the interaction between generic operations and wppts is the key in the semantic analysis of Kaminski’s ert in Section 6.2.
The concept of monotone EM algebra appears in Voorneveld’s program logic for a call-by-push-value language [41]. The logic can have multiple modalities to make assertions about effectful programs, and these modalities are interpreted by endofunctor algebras of the monad TΣ of possibly infinite and partial Σ-terms. He introduces two conditions on such endofunctor algebras: leaf-monotonicity [41, Def- inition 4.5] and sequentiality [41, Definition 4.10]. They are respectively equivalent to monotonicity (Definition 4.3) and Eilenberg-Moore algebra axiom.
Our categorical framework is designed to provide an underlying semantic struc- ture for the Hoare logic where formulas can only examine memory configurations. On the other hand, several extensions of program logics are introduced for the lan- guages with exception [22,39,25]. In these extensions, formulas in the logic can also examine exceptions raised by programs — for instance, in [39], the Hoare logic is extended so that we can specify two postconditions for normal and exceptional ter- mination. It is an interesting challenge to understand these extended Hoare logic within our fibrational framework.

Turning our eyes to functional programming languages, a series of recent pa- pers [3,25,26] develop Dijkstra monads for the verification of effectful programs in dependent type theories. The main task of a Dijkstra monad is to take a type A and a specification w ∈ WA written in the language of a speciﬁcation monad W, and collect computations that satisfy w. In [25, Section 5], they establish an equivalence between Dijkstra monads and monad morphisms into ordered monads. Dijkstra monads intersect with our categorical wppts when the former arise from monad morphisms of type T → Wpure, where Wpure is an ordered continuation monad (see [25, Section 4.1] for detail). In this situation, such a monad morphism bijectively corresponds to an EM monotone T -algebra o over the return type of Wpure [25, Section 4.4]. The corresponding Dijkstra monad then collects all the computations c ∈T A such that the predicate transformer wp(−, c) induced from o is below the specification w ∈ WpureA. This is the only relationship we know be- tween Dijkstra monads and our fibrational theory of wppts, and we leave exploring further relationships between them as future work.
Conclusion
We have presented a fibrational and monadic semantics of Hoare triples and weakest precondition predicate transformers. The key fact is that the composability of wppts is equivalent to the Cartesian-ness of the monad lifting. We next studied the Cartesian liftings of monads along domain fibrations; they bijectively correspond to EM monotone algebras, giving a fibrational view of [11]. Despite examples presented here being within the framework of [11,13], we studied new examples, in which we have revealed the monads behind wppt-like operators used to compute expected run-time [16] and higher moments [21].

References
Samson Abramsky, Simon Gay, and Rajagopal Nagarajan. Specification Structures and propositions- as-types for concurrency, pages 5–40. Springer Berlin Heidelberg, Berlin, Heidelberg, 1996.
Alejandro Aguirre, Gilles Barthe, Justin Hsu, Benjamin Lucien Kaminski, Joost-Pieter Katoen, and Christoph Matheja. Kantorovich continuity of probabilistic programs. CoRR, abs/1901.06540, 2019.

Danel Ahman, Catalin Hritcu, Kenji Maillard, Guido Mart´ınez, Gordon D. Plotkin, Jonathan Protzenko, Aseem Rastogi, and Nikhil Swamy. Dijkstra monads for free. In Giuseppe Castagna and Andrew D. Gordon, editors, Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages, POPL 2017, Paris, France, January 18-20, 2017, pages 515–529. ACM,
2017.
Jon Beck. Distributive laws. In B. Eckmann, editor, Seminar on Triples and Categorical Homology Theory, pages 119–140, Berlin, Heidelberg, 1969. Springer Berlin Heidelberg.
Filippo Bonchi, Barbara K¨onig, and Daniela Petrisan. Up-to techniques for behavioural metrics via fibrations. In Sven Schewe and Lijun Zhang, editors, 29th International Conference on Concurrency Theory, CONCUR 2018, September 4-7, 2018, Beijing, China, volume 118 of LIPIcs, pages 17:1–17:17. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik, 2018.
Edsger W. Dijkstra.	Guarded commands, nondeterminacy and formal derivation of programs.
Commun. ACM, 18(8):453–457, 1975.
Andrzej Filinski. Controlling Effects. PhD thesis, Carnegie Mellon University, 1996.


Andrzej Filinski. On the relations between monadic semantics. Theor. Comput. Sci., 375(1-3):41–75, 2007.
Sergey Goncharov and Lutz Schr¨oder. A relatively complete generic hoare logic for order-enriched effects. In 28th Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2013, New Orleans, LA, USA, June 25-28, 2013, pages 273–282. IEEE Computer Society, 2013.
Jean Goubault-Larrecq, Slawomir Lasota, and David Nowak. Logical relations for monadic types.
Mathematical Structures in Computer Science, 18(6):1169–1217, 2008.
Ichiro Hasuo. Generic weakest precondition semantics from monads enriched with order. Theoretical Computer Science, 604:2 – 29, 2015. Coalgebraic Methods in Computer Science.
Claudio Hermida. Fibrations, Logical Predicates and Indeterminants. PhD thesis, University of Edinburgh, 1993.
Wataru Hino, Hiroki Kobayashi, Ichiro Hasuo, and Bart Jacobs. Healthiness from duality. In Martin Grohe, Eric Koskinen, and Natarajan Shankar, editors, Proceedings of the 31st Annual ACM/IEEE Symposium on Logic in Computer Science, LICS ’16, New York, NY, USA, July 5-8, 2016, pages 682–691. ACM, 2016.
Bart Jacobs. Categorical Logic and Type Theory. Number 141 in Studies in Logic and the Foundations of Mathematics. North Holland, Amsterdam, 1999.
Andr´e Joyal, Ross Street, and Dominic Verity. Traced monoidal categories. Mathematical Proceedings of the Cambridge Philosophical Society, 119(3):447–468, 1996.
Benjamin Lucien Kaminski, Joost-Pieter Katoen, Christoph Matheja, and Federico Olmedo. Weakest precondition reasoning for expected run-times of probabilistic programs. In Peter Thiemann, editor, Programming Languages and Systems - 25th European Symposium on Programming, ESOP 2016, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2016, Eindhoven, The Netherlands, April 2-8, 2016, Proceedings, volume 9632 of Lecture Notes in Computer Science, pages 364–389. Springer, 2016.
Shin-ya Katsumata. A semantic formulation of TT-lifting and logical predicates for computational metalanguage. In Proc. CSL ’05, volume 3634 of LNCS, pages 87–102. Springer, 2005.
Shin-ya Katsumata, Tetsuya Sato, and Tarmo Uustalu. Codensity lifting of monads and its dual.
Logical Methods in Computer Science, Volume 14, Issue 4, October 2018.
Bartek Klin. A coalgebraic approach to process equivalence and a coinduction principle for traces. Electronic Notes in Theoretical Computer Science, 106:201 – 218, 2004. Proceedings of the Workshop on Coalgebraic Methods in Computer Science (CMCS).
Anders Kock. Strong functors and monoidal monads. Archiv der Mathematik, 23:113–120, 1970.
Satoshi Kura, Natsuki Urabe, and Ichiro Hasuo. Tail probabilities for randomized program runtimes via martingales for higher moments. In Tom´aˇs Vojnar and Lijun Zhang, editors, Tools and Algorithms for the Construction and Analysis of Systems, pages 135–153, Cham, 2019. Springer International Publishing.
K. Rustan M. Leino and Jan L. A. van de Snepscheut. Semantics of exceptions. In Ernst- Ru¨diger Olderog, editor, Programming Concepts, Methods and Calculi, Proceedings of the IFIP TC2/WG2.1/WG2.2/WG2.3 Working Conference on Programming Concepts, Methods and Calculi (PROCOMET ’94) San Miniato, Italy, 6-10 June, 1994, volume A-56 of IFIP Transactions, pages 447–466. North-Holland, 1994.
Tom Leinster. Higher Operads, Higher Categories. London Mathematical Society Lecture Note Series. Cambridge University Press, 2004.
Saunders MacLane. Categories for the Working Mathematician (Second Edition), volume 5 of Graduate Texts in Mathematics. Springer, 1998.
Kenji Maillard, Danel Ahman, Robert Atkey, Guido Mart´ınez, Catalin Hritcu, Exequiel Rivas, and E´ric Tanter. Dijkstra monads for all. Proc. ACM Program. Lang., 3(ICFP):104:1–104:29, 2019.
Kenji Maillard, Catalin Hritcu, Exequiel Rivas, and Antoine Van Muylder. The next 700 relational program logics. Proc. ACM Program. Lang., 4(POPL):4:1–4:33, 2020.
Ernest Manes and Philip Mulry. Monad compositions I: general constructions and recursive distributive laws. Theory and Applications of Categories, 18:172–208, 04 2007.
Ursula Martin, Erik A. Mathiesen, and Paulo Oliva. Hoare logic in the abstract. In Zolta´n E´sik, editor,
Computer Science Logic, pages 501–515, Berlin, Heidelberg, 2006. Springer Berlin Heidelberg.


Annabelle McIver and Carroll Morgan. Abstraction, Refinement and Proof for Probabilistic Systems. Springer, New York, NY, 2005.
Paul-Andr´e Melli`es and Noam Zeilberger. Functors are type refinement systems. In Sriram K. Rajamani and David Walker, editors, Proceedings of the 42nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2015, Mumbai, India, January 15-17, 2015, pages 3–16.
ACM, 2015.
Paul-Andr´e Melli`es and Noam Zeilberger. Isbell duality for refinement types. CoRR, abs/1501.05115, 2015.
Eugenio Moggi. Notions of computation and monads. Information and Computation, 93(1):55–92, 1991.
Andrew M. Pitts. Tripos theory in retrospect. Electronic Notes in Theoretical Computer Science, 23(1):111 – 127, 1999. Tutorial Workshop on Realizability Semantics and Applications (associated to FLoC’99, the 1999 Federated Logic Conference).
Gordon Plotkin and John Power. Semantics for algebraic operations, 2001.
Gordon Plotkin and John Power. Notions of computation determine monads. In Mogens Nielsen and Uffe Engberg, editors, Foundations of Software Science and Computation Structures, pages 342–356, Berlin, Heidelberg, 2002. Springer Berlin Heidelberg.
Christoph Rauch, Sergey Goncharov, and Lutz Schro¨der. Generic hoare logic for order-enriched effects with exceptions. In Phillip James and Markus Roggenbach, editors, Recent Trends in Algebraic Development Techniques - 23rd IFIP WG 1.3 International Workshop, WADT 2016, Gregynog, UK, September 21-24, 2016, Revised Selected Papers, volume 10644 of Lecture Notes in Computer Science, pages 208–222. Springer, 2016.
Tetsuya Sato. A probabilistic monad with nondeterminism for coalgebraic trace semantics. tetsuya sato. In CALCO Young Researchers Workshop CALCO-jnr 2011 selected papers. University of Southampton, 2011.
Lutz Schroder. Expressivity of coalgebraic modal logic: The limits and beyond. Theoretical Computer Science, 390(2):230 – 247, 2008. Foundations of Software Science and Computational Structures.
Emil Sekerinski. Dependability and Computer Engineering: Concepts for Software-Intensive Systems, chapter Exceptions for Dependability, pages 11–35. IGI Global, 2012.
Daniele Varacca and Glynn Winskel. Distributing probability over non-determinism. Mathematical Structures in Computer Science, 16(1):87–113, 2006.
Niels F. W. Voorneveld. Quantitative logics for equivalence of effectful programs. In Barbara Ko¨nig, editor, Proceedings of the Thirty-Fifth Conference on the Mathematical Foundations of Programming Semantics, MFPS 2019, London, UK, June 4-7, 2019, volume 347 of Electronic Notes in Theoretical Computer Science, pages 281–301. Elsevier, 2019.
Whiskering. https://ncatlab.org/nlab/show/whiskering.
