Available online at www.sciencedirect.com



Electronic Notes in Theoretical Computer Science 278 (2011) 145–158
www.elsevier.com/locate/entcs

A Rooted Tableau for BCTL*

John Christopher McCabe-Dansted
Computer Science and Software Engineering University of Western Australia
Perth, Austrlia

Abstract
The existing pure tableau technique for satisfiability checking BCTL* [7] begins by constructing all possible colours. Traditional tableaux begin with a single root node, and only construct formulae that are derived from that root. These rooted tableaux provide much better performance on most real world formulae, as they only need to construct a fraction of the possible nodes. We present a rooted variant of this tableau for BCTL*, together with an implementation demonstrating the performance of our rooted variant is superior to the original; this implementation is made available as a Java applet. We discuss further possible optimisations. This research will be useful in finding an optimised rooted tableau for CTL*.
Keywords: Full Computation Tree Logic, BCTL*, Tableau, Bundled.


Introduction
There has been recent renewed interest in decision procedures for Full Computation Tree Logic (CTL*). It has long been known that CTL* is decidable and is 2EXP- TIME complete, [1,2] provides a doubly exponential automaton based satisfiability checker, and [9] gives a lower-bound. The automaton based satisfiability checkers are expected to have poor performance on average and have not been implemented [3]. Recently, tableau based decision procedures have been proposed that have greater potential for reasonable real world performance, and that have publicly accessible implementations [8,3]. The CTL* tableau of [8] builds upon a previous tableau for Bundled Full Computation Tree Logic (BCTL*) [7].
BCTL* is a variant of CTL* which has the same syntax but where only paths in a certain bundle are considered. As the bundle can contain all paths, if a formula is satisfiable in CTL* it is also satisfiable in BCTL*. Similarly if it is a theorem of BCTL* it is also a theorem of CTL*, as such it is reasonable to prove that a formula is a theorem of BCTL* where possible so we can use the theorem without

1 Email: john@csse.uwa.edu.au

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.10.012

consideration of the difference between BCTL* and CTL*. Also, we note that when only finite periods of time are considered the bundled and unbundled semantics are equivalent (see for example [5]). See Section 2.4 for a comparison of CTL* and BCTL*.
A traditional tableau begins with a single formula and then builds a tree, with the label rooted with that formula. The tableau defined in [7] instead begins with a maximal tableau, and then prunes nodes. This is sufficient to give optimum worst-case performance results; however, it means that we always have to construct all possible nodes. So, with the tableau of [7], it would take longer to check the satisfiability of φ Λp Λчp than φ. By contrast, a rooted tableau would typically find the contradiction quickly and terminate.
Although the hybrid satisfiability checker for CTL* of [3] appears to be faster overall than [8], we investigate finding a rooted tableau for three reasons. Firstly, the
tableau of [8] can be quick, for example, using the default settings, the tableau of [8] shows that (p → (qUr)) Λ (qUp)) → (qUr) is satisfiable in 0.16s, while constructing the automata for [3] alone requires 395 seconds on the same Core2Duo. Thus, it
makes sense to investigate improvements to tableaux of [7] and [8] to determine whether they can outperform [3]. Secondly, as [3] is based on a rooted tableau, it makes more sense to compare [3] to a rooted variant of [8]. Thirdly, the approach of [7] and [8] works by constructing a finite tableau built from subformulae of the formula inputted by the user, with each step being based upon the semantics of (B)CTL*. The workings of these tableaux are more meaningful to the user than those of [3], which reasons about the existence of an infinite tableau using a parity game.
In this paper we propose a rooted variant 2 of the tableau for BCTL* in [7]. Although, BCTL* has some advantages over CTL* the primary reason we chose to implement a BCTL* tableau is that the CTL* tableau of [8] is built from the much simpler BCTL* tableau of [7]. As such it makes sense to study and optimise the simpler BCTL* tableaux before trying to optimise the corresponding CTL* tableau.

BCTL* Logic
BCTL* Syntax
As with CTL*, BCTL* has a set u of atomic propositions that we call atoms. Where p varies over u, we define BCTL* (and CTL*) formulae according to the following abstract syntax
φ := T| p | чφ | (φ Λ φ) | (φUφ) | Xφ | Aφ .

The T, ч, Λ, X, U and A are the familiar “true”, “not”, “and”, “next”, “until” and “all paths” operators from CTL and CTL*. The abbreviations ⊥, V, F , G, W , E → and x are defined as in CTL* logic, that is: ⊥ ≡ (p Λ чp), T ≡ ч⊥,

2 This is available as a Java Applet at: http://www.csse.uwa.edu.au/~john/BCTL2/, and includes the tableaux of [7] and [8] for comparison.

α Vβ ≡ ч (чα V чβ), “Finally” Fα = TUα, “Globally/Always” Gα ≡ чFчα, “Weak Until” αWβ ≡ αUβ V Gα, “Exists a Path” Eα ≡ чAчα, α → β ≡ чα V β and α x β ≡ (α → β) Λ (β → α).

CTL-Structures
Definition 2.1 We say that a binary relation R on S is serial (total) if for every a
in S there exists b in S such that aRb. We will sometimes write aRb as (a, b) ∈ R.
Definition 2.2 A transition frame is a pair (W, >), where W is a non-empty set of states and > is a serial relation on W .
Definition 2.3 We let u be our set of atoms. A valuation g is a map from a set of states W to the power set of the atoms. Informally, the statement p ∈ g(w) means “the atom p is true at state w”.
Definition 2.4 We call an ω-sequence σ = ⟨w0, w1,.. .⟩ of states a fullpath iff for all non-negative integers i we have wi > wi+1. For all i in N we define σ≥i to be the fullpath ⟨wi, wi+1,.. .⟩, we define σi to be wi and we define σ≤i to be the sequence ⟨w0, w1,..., wi⟩. We say that a set of fullpaths B is fusion closed iff for all non-negative integers i, j and σ, π ∈ B we have ⟨σ0, σ1,..., σi, πj, πj+1,.. .⟩ ∈ B if σi+1 = πj. We say that a set of fullpaths B is suffix closed iff for all integers i and σ ∈ B we have σ≥i ∈ B. We say a set of fullpaths is a bundle if it is non-empty, suffix closed and fusion closed.
Definition 2.5 A BCTL-structure M = (W, >, g, B) is a 4-tuple containing a set of states W , a serial binary relation >, a valuation g on the set of states W , and B is a bundle on (W, >).

BCTL* Semantics
We define truth of a BCTL* formula φ on a fullpath σ = ⟨w0, w1,.. .⟩ in a BCTL- structure M recursively as follows:
M, σ ▶ Xφ iff M, σ≥1 ▶ φ
M, σ ▶ φUψ iff ∃i∈N s.t. M, σ≥i ▶ ψ and ∀j∈Nj < i =⇒ M, σ≥j ▶ ψ M, σ ▶ Aφ iff ∀π∈B s.t. π0=σ0 M, π ▶ φ
The definitions for p, ч and Λ are as we would expect from classical logic:
M, σ ▶ p iff p ∈ g (p0) M, σ ▶ чφ iff M, σ $ φ
M, σ ▶ φ Λ ψ iff M, σ ▶ φ Λ M, σ ▶ ψ ,
We say that a formula φ is satisfiable in BCTL* iff there exists a BCTL structure M = (W, >, g, B) such that there exists a path σ in B such that we have M, σ ▶ φ. A formula is valid iff its negation is not satisfiable. CTL* is similar, but B must be the set of all possible paths through >.

CTL*
In this paper we will not formally consider CTL*; however, we will briefly discuss it here so we can compare it to BCTL*. We see that if a formula is satisfiable in CTL* then it must be satisfiable in BCTL*; equivalently if it is valid in BCTL* then it must be valid in CTL*. The axiomatisation of CTL* [6] includes a limit closure (LC) axiom, which is not valid in BCTL:
LC: AG(Eα → EX((EβUEα)) → (Eα → EG((EβUEα)))
Consider a system where we process non-empty input of finite but unbounded size. Since the size of input is unbounded, if we have just read an input symbol, then it is possible that we will read another input symbol at the next step, which we may want to represent as r → EXr; this will always be true since no matter how many input symbols we have read, it is always possible there will be one more, which we can represent as AG (r → EXr), under CTL* we can deduce that r → EGr. Since the input is non-empty we have r and thus EGr; indicating that there is a computation path where we read new input symbols forever. However, we have stated that the input is always finite. We see that the semantics of CTL* are not appropriate to this specification. It is reasonable to first attempt to prove that a formula is valid in BCTL*, and only worry about whether the semantics of BCTL* or CTL* are more appropriate if it turns out not to be valid in BCTL*.

A Tableau for BCTL*
Here we define a tableau BCTL*-RTAB for checking the satisfiability of BCTL* formulae. This tableau is derived from Reynolds’ [7] tableau for BCTL*.
Definition 3.1 For any pair of formulae (φ, ψ), we say that φ ≤ ψ iff φ is a subfor- mula of ψ.
Definition 3.2 The closure clφ of the formula φ is defined as the smallest set that satisfies the four following requirements:
φ ∈ clφ
For all ψ ∈ clφ, if δ ≤ ψ then δ ∈ clφ.
For all ψ ∈ clφ, чψ ∈ clφ or there exists δ such that ψ = чδ and δ ∈ clφ.
Definition 3.3 We say that a ⊆ clφ is Partially Propositionally Consistent (PPC) iff for all α, β ∈ clφ:
(M1)	if ччα ∈ a then α ∈ a,
(M2)	if (α Λ β) ∈ a then α ∈ a and β ∈ a.
PPC sets are quite similar to Maximally Propositionally Consistent (MPC) sets, but with MPC sets M1 is stronger: if β = чα then β ∈ a iff α ∈/ a. With an MPC set a, for every formula α in the closure, a either has α or its negation. By contrast,

the intuition behind PPC is that a PPC set a can exclude both α and чα unless one of these formulae is a direct consequence of other formulae in a.
A hue is roughly speaking a set of formulae that could hold along a single fullpath.

Definition 3.4 [Hue] A set a ⊆ clφ is a hue for φ if a satisfies H1,H3 and H4 (below). A set a ⊆ clφ is a finished hue for φ iff it satisfies all of:
(H1)	a is PPC;
(H2)	 if αUβ ∈ a then α ∈ a or β ∈ a; (H3)	if ч (αUβ) ∈ a then чβ ∈ a; and (H4)	if Aα ∈ a then α ∈ a.
The hues of [7] are similar to finished hues, exception that they must be MPC (not just PPC). We do not include H2 in our definition of hues so that the following definition is unique:
Definition 3.5 For a set a of formulae we let hue (a) be the minimal superset of a
that is also a hue.
Definition 3.6 Where h is a finished hue we define succ(a) as the minimal set such that
if Xα ∈ a then α ∈ succ(a); and
if чβ ∈ a and αUβ ∈ a then αUβ ∈ succ(a); and
if ч (αUβ) ∈ a and α ∈ a; then ч (αUβ) ∈ succ (a).
Definition 3.7 [rA] For hues a, b, we put (a, b) in rA iff the following conditions hold:
(A1)	Aα ∈ a iff Aα ∈ b
(A2)	For all p ∈ u, we have p ∈ a iff p ∈ b
Definition 3.8 We say a set C of hues is a colour if it satisfies C1. A set of hues
C is a finished colour of φ iff it satisfies both of:
(C1)	for all a, b ∈ C we have (a, b) ∈ rA; and
(C2)	if a ∈ C and чAα ∈ a then there is b ∈ C such that чα ∈ b; and
We now define a function Col; given a set of sets of formulae the set Col (C) is intuitively the minimal colour that is a superset of C; however, we have not defined minimal sets of sets, so we formally define Col as follows:
Definition 3.9 For a set of sets of formulae C, the set (C)٨ is the set that results when we iteratively:
replace each member a of C with hue (a);
replace each member a of C with a ∪ {α} where α ∈ b ∈ C and α is of the form
Aβ, чAβ, p or чp.

repeat 1 and 2 until it is not possible to modify C any further.
All of the tableau rules use the above definition to ensure that every node is a colour. This increases the similarity of this tableau to that of [7] (where all nodes are colours).
As with [7], a hue a represents the formula  a, and C = {h , h ,..., h } rep- resents the formula A( i(  hi)) Λ  i E (  hi).
In the tableau we allow the hues to contain a special marker e. This indicates that we have chosen this hue as the hue that we will try to find temporal successors for. We will always have e in exactly one hue of each colour. For a colour C we let Ce be the hue in C that contains e. The hue containing e is similar to the first hue h0 in the paper [8], incidentally this is also how we implemented e in our sample implementation.
Definition 3.10 For each formula ψ of one of the forms below, we define a left choice L (ψ) and right choice R (ψ) as follows:

Note that the bottom two rules are required because (as with [7]) we have not added X (αUβ) to the closure set so we use the pair of formulae чβ and (αUβ) to indicate that the temporal successor must also contain αUβ.
A rule node is a tuple (C, “R”), where C is a colour, and a temporal node is a tuple (C, “T ”). A node is either a rule node or a temporal node. Each node is associated with a branch. Each branch has a letter to indicate the type of branch, and a node is a rule node unless it is the child of a H-branch (defined below).
We begin the tableau with a single node (({{φ, e} , ∅})٨ , “R”). We need to include the empty hue ∅, as otherwise the initial colour would represent the case where all paths satisfy φ, which may not be the case. We then define the tableau iteratively as follows: for each rule node (C, “R”), where C = h1, h2,..., h|C| , we associate a branch as defined as follows,
If there exists ψ ∈ h ∈ C for some leaf such that L (ψ) is defined, L (ψ) ∈/ h, R (ψ) ∈/ h then we let the branch of (C, “R”) be a disjunctive B-branch with the following four children:
A child ((C1)٨ , “R”) where C1 results from adding L (ψ) to h in C.
A child ((C2)٨ , “R”) where C2 results from adding R (ψ) to h in C.
A child ((C3)٨ , “R”) where C3 = C1 ∪ (C2 − {e}).
A child ((C4)٨ , “R”) where C4 = (C1 − {e}) ∪ (C2).
If there exists чAψ ∈ a ∈ C such that ∀b ∈ C we have чψ ∈/ b, we then let the branch of (C, “R”) be a disjunctive E-branch, with |C| children:

The ith child is ((Ci)٨ , “R”), where Ci = C ∪ {hi ∪ {чψ}− {e}}.
If we cannot apply rules 1 or 2, then we let the branch of (C, “R”) be a dis- junctive H-branch with |C| children:
the ith child is (Ci, “R”), where Ci is the same as C except that e has been
moved into the ith hue (given some arbitrary ordering of the hues). We let the branch of (Ci, “R”) be a disjunctive X-branch with 2|Ci|—1 children. Each child of (Ci, “R”) is of the form (Cj, “T ”) where Cj is formed by picking some subset S of C such that Ce ∈ S, and replacing each a in S with succ (a), finally we let Cj be (S)٨.
Intuitively, (i) is about finishing hues, (ii) is about finishing colours, and (iii) is for taking a temporal step, moving to the next world on the fullpath.
Definition 3.11 We define the set of eventualities in a colour to be the set of formu- lae of the form αUβ such that αUβ ∈ Ce. We define the set of eventuality-children (eChildren) of an H-branch for a node (C, “R”) to be the singleton set {(C, “T ”)} (that is, the eChild of an H-branch is the child that “moves” the e marker back to its original position); for all other branches we define the set of eChildren as being the same as the set of children. We define the eventuality descendants (eDescendants) as being the transitive closure of the eChildren. We say an eventuality αUβ of C is directly satisfied if β ∈ Ce. We say an eventuality is satisfied at a node if there exists an eDescendant of the node where β ∈ Ce.
We say a disjunctive branch is covered if any of its children are not pruned. We say a conjunctive branch is covered if all its children are not pruned. We mark a branch as pruned if:
the colour C of the branch is contradictory, i.e. {ψ, чψ}⊆ h ∈ C; or
the branch is not covered; or
there is an unsatisfied eventuality.
We say the tableau succeeds if it halts and the root is not pruned.

Soundness and completeness
BCTL*-RTAB is sound, that is, if it halts and succeeds on φ then φ is satisfiable in BCTL*. We sketch a proof of this here, for more details see [4].
Say that BCTL*-RTAB finishes with the set Sj of colours. Then we define a BCTL-structure M = (W, >, g, B) as follows: the set of worlds W are the set of colours used in H-branches. We put a pair of colours (C, D) in > iff we can reach the node (D, “R”) from (C, “R”) in the tableau by crossing precisely one X-branch); the valuation g (C) of a world/colour C contains an atom p iff p ∈ C. We now define
the set of bundled paths B.
Definition 3.12 [rX] The temporal successor rX relation on hues below is defined as in [7]; for all hues a, b put (a, b) in rX iff the following conditions are satisfied:
(R1)	Xα ∈ a implies α ∈ b

(R2)	чXα ∈ a implies чα ∈ b
(R3)	αUβ ∈ a and β ∈/ a implies αUβ ∈ b
(R4)	ч(αUβ) ∈ a and α ∈ a implies ч(αUβ) ∈ b
Lemma 3.13 For every (C, D) ∈> we have CerX De and for every b ∈ D we have
a ∈ C such that arX b.
Note that the X-branch replaces every hue a with succ (a); that a is a finished hue and so (a, succ (a)) ∈ rX; that X-branches are the only branches that remove formulae from hues, and we only cross one X-branch when travelling from C to D for (C, D) ∈>. From this is easy to prove this Lemma 3.13.
Definition 3.14 We call an ω-sequence ⟨(c0, h0) , (c1, h1) ,.. .⟩ a thread through W
iff for all i ≥ 0: each ci ∈ Sj, each hi ∈ ci, each (ci, ci+1) ∈>, each (hi, hi+1) ∈ rX.
We say that this is a fulfilling thread iff for all i ≥ 0
(i) For all formulae of the form (αUβ) in hi, there exists j ≥ i such that β ∈ hj
We include a fullpath σ = ⟨c0, c1,.. .⟩ in B iff there exists a fulfilling thread
⟨(c0, h0) , (c1, h1) ,.. .⟩, and we say that this thread justifies σ being in B.
Proposition 3.15 If μ = ⟨(c0, h0) , (c1, h1) ,.. .⟩ justifies σ ∈ B then for all j ≥ 0,
μ≥j justifies σ≥j ∈ B.
Lemma 3.16 B is fusion closed
Say that σ, π are in B and σ0 = π1. We will show below that
⟨π0, σ0, σ1,.. .⟩∈ B .
The general case where σ0 = πj follows from prefix closure and induction.
As σ ∈ B, there is a fulfilling thread μ = ⟨(σ0, h1) , (σ1, h2) ,.. .⟩. As (π0, π1) ∈>, we can choose h0 from π0 such that (h0, h1) ∈ rX (see Lemma 3.13).
If αUβ ∈ h0, then β ∈ h0 or αUβ ∈ h1. As μ is fulfilling, if αUβ ∈ h1 then there exists j ≥ 1 such that β ∈ hj.
Lemma 3.17 If h ∈ c ∈ Sj then there is a fulfilling thread
μ = ⟨(c0, h0) , (c1, h1) ,.. .⟩
such that h0 = h and c0 = c. Thus σ = ⟨c0, c1, c2,.. .⟩∈ B.
As with Reynolds [7] we iteratively satisfy the oldest eventuality first. Hence every eventuality is eventually fulfilled.
Say we have chosen the first n elements of μ and 0 ≤ i ≤ n. We say that an
eventuality αUβ ∈ hi is unfulfilled iff for all j ≤ i ≤ n the formula β ∈/ hj.
For the lowest i such that there exists an unfulfilled eventuality in hi we fulfil this eventuality as follows:
Case 1: If no such i exists, we choose (cn+1, hn+1) such that (cn, cn+1) ∈> and
(hn, hn+1) ∈ rX.

Case 2: If the eventuality is of the form αUβ, then there must exist αUβ ∈ hn. Due to the pruning rule that removes unfulfilled eventualities, for some j there must exist a sequence of instances
(cn, hn, αUβ) , (cn+1, hn+1, αUβ) ,..., (cj, hj, αUβ)
such that the final instance is directly fulfilled (β ∈ hj), and each other instance is fulfilled by the next instance in the chain. Having now chosen μ up to (cj, hj) with β ∈ hj, the eventuality αUβ ∈ hi is now fulfilled.
Lemma 3.18 For all α in clφ, for all threads μ = ⟨(c0, h0), (c1, h1),.. .⟩ justifying
σ = ⟨c0, c1,.. .⟩ we have
M, σ ▶ α if α ∈ h0
We can prove this using induction. Let Lψ be the statement: for all threads μ =
⟨(c0, h0), (c1, h1),.. .⟩ justifying σ = ⟨c0, c1,.. .⟩ we have (W, >, g, B),σ ▶ ψ iff ψ ∈ h0. First note that Lψ holds by definition when ψ is an atom. Assume that Lψ holds for all ψ in clφ where |ψ| ≤ n. We can show [4] that Lψ holds for any ψ in clφ where |ψ| ≤ n + 1. For example, say that ψ is of the form α Λ β. Then since the hue is PPC, we see that α and β are also in h0. Then M, σ ▶ α and M, σ ▶ β. Hence M, σ ▶ α Λ β.
Soundness follows from Lemmas 3.17 and 3.18.

Completeness
Lemma 3.19 The tableau will halt, in an amount of time at worst doubly exponen- tial in the length of the input formula.
The closure set is linear in the length of the input formula. We see that the number of hues is singly exponential in the size of the closure set, the number of colours are exponential in the number of hues. We only apply rules to the rule nodes, and there is at most one rule node per colour. Each step is at worst polynomial in the number of colours, or singly exponential in the number of hues. Thus BCTL*- RTAB will halt in an amount of time at worst doubly exponential in the length of the formula.
Definition 3.20 For a colour C = {h0, h1,..., hn} in the tableau we define f (C)
as follows:

f (C)=   Ce  Λ  A(  (  hi)) Λ   E   hi   .

Lemma 3.21 BCTL*-RTAB is complete, that is, if φ is satisfiable in BCTL* then BCTL*-RTAB halts and succeeds on φ.
The proof [4] involves showing that a node with colour C will never be pruned if f (C) is satisfiable.

Performance
We have constructed a sample implementation of this tableau. This implementation stops constructing a node once it has constructed enough descendants of the node to know whether the node will be pruned.
We present a list of results in Tables 1 and 2. Table 1 is based upon a class of formulae proposed by [3] for testing asymptotic performance; in this table α1 = AFGq, β1 = AFAGq and for each i ≥ 1 we have αi+1 = AFGαi and βi+1 = AFAGβi.  Table 2 gives standard examples used in [7] and [8].  In each column,
the first subcolumn is for the our new BCTL* tableau, the second subcolumn is for the old BCTL* tableau of [7], and the third is for the hybrid technique of [3]. If the technique completes successfully “Sat” will be “Y” (or “N”) to indicate that the technique reported that the formula was (not) satisfiable; “m” indicates that the procedure exceeded 1GB and failed, “h” indicates that a hardcoded limit in the implementation was exceeded, and “t” indicates that we simply terminated the procedure after an hour. The “CPU Time” column is the number of seconds used by the implementation on a computer with 2620M Core i7 processor and 8GB of ram. The number of colours in the new tableau is the number of unique colours used in rule nodes (note that there tend to be many more rule nodes than temporal nodes, and every temporal node is the direct descendant of a rule node). For the implementation of [3], we let the “Colours” be the number of states in the parity game. We do not define an equivalent to hues in [3], so there is no third hues column. A “+” in any column indicates that the number may have been larger if we had not terminated the implementation before it finished.
Our new rooted BCTL* tableau performs better than the original. In Table 2 we see that every example formula used by Reynolds can be handled by our tableau, while many cannot be handled by the original tableau (both using default settings). In each table we see the new tableau can handle every formula that can be handled by the original, also our new tableau is often much faster and never significantly slower.
The comparison with [3] is preliminary. Note that the [3] technique is for CTL*, while out technique is for BCTL* and so comparing the running times of the imple- mentations may be misleading. If the running time of [3] is marked with a “*” the [3] technique has proven that the formula is satisfiable in CTL* (and hence BCTL*) as well. If the running time is marked with an “L” the formula is an LTL formula, that is it does not contain any path quantifiers (A/E) and so it is satisfiable in CTL* iff it is satisfiable in BCTL*. If it is marked with an “N” then, as we have shown that it is not satisfiable in BCTL*, and hence not satisfiable in CTL* either, we have proven a stronger result. Given that a [8] style variant of this tableau would require duplicating colours, we consider BCTL* easier than CTL*, and so we consider it reasonable to compare running times marked with an “N”. The implementation of
[3] requires a parity game solver, but does not select one by default. We have chosen the “recursive” parity game solver. In our benchmarks we found that the imple- mentation of [3] spent less than one tenth of the time in the parity game solver, so there is little point in investigating other solvers for these benchmarks. For con-

sistency, we limited the heap size of the pure tableaux to 1GB; we were not able to do so for the implementation provided by [3]; however, we used a 32bit architec- ture so we doubt that their implementation could have used more than one order of magnitude more memory. In our benchmarks [3] performed significantly worse than in the benchmarks provided by [3]. We believe this is because we used a 32bit architecture.
Our intuition is that our technique will usually be able to prove that a formula is satisfiable much faster than that of [3], but that it would be harder to find a short formula that [3] cannot reason about. Our pure tableau technique can quit as soon as it has found a model of the input formula. This provides our technique with a significant advantage as a satisfiable formula can be satisfied by many different models. By contrast the [3] technique always completes a parity game. However, once the parity game is completed, many well researched parity game solving tech- niques can be used, and so there is reason to believe that it would be hard to find a relatively short theorem that could not be proven by [3]. While it is too early to rigorously compare these techniques, our benchmarks are at least compatible with this intuition.
There are many possible optimisations.
The implementation of [7] first computed the hues that were consistent with the semantics of LTL. We could similarly require that colours contain only LTL consistent hues. For benchmarks with this optimisation see [4].
if {a, h, b}⊆ C and a ⊆ h ⊆ b then we can simplify C by removing h from C. To see that this is safe, note that this does not affect f (C).
The implementation blindly adds eDescendants trying to fulfil eventualities, and then covers them. If would be faster if it only covered the eDescendants on the branch which actually fulfilled the eventuality.
Like [7], we use чβ and αUβ to indicate that the temporal successor must contain αUβ. This means that β and its subformulae occur both positively and negatively, potentially effectively doubling the size of the closure set. It is possible that using X (αUβ) would be more efficient.
X-branches have an exponential number of children. We could change X- branches so that they have only a single child, by including all hues, but marking the hues that do not descend from Ce as optional, we change H-branches so they only chose non-optional hues. When a contradiction is discovered in an optional hue we remove the hue from the colour rather than prune the colour. When an optional hue contains a formula ψ of the form Aβ, чAβ, p or чp that does not exist in some other hue of C then instead of always adding ψ to all the other hues we add a branch along which we remove the optional hue instead. There are a number of reasons to believe this would be more efficient: we might come across a contradiction before we need to branch; the number of branches is at most equal to the number of formulae ψ of the form Aβ, чAβ, p or чp; it may be the case that all hues already have ψ in which case we can avoid the branch entirely.


Figure 1. Example Output: Proof that Xp → Fp 
>/.	Enter interior node/Enter unsatisfiable leaf
N/Y	Exit node (Not Satisfiable)/ Exit node (Satisfiable) L	Leaf
U-	B-branch for formula of form ч(αUβ)
X	Temporal Successor Branch, also: next time operator X
H	Choose Hue Branch (move selected hue to h0) C:	Colour of node
P:	Parents of node
D:	Children of node
S:	Set of eventualities
o/c/e	Original Node/Node created to cover parent/to resolve eventuality
-/&/|/>	Negation ч / And (Λ) / or (V) / Implication (→)

Table 1 Asymptotic Benchmarks



If {a, h}⊆ C and a ⊆ h and h is optional, we can simplify C by removing
h. (Similar to (1) above).
if “чA” does not occur anywhere in a colour we can simplify C by removing all optional hues.
Instead of always constructing the optional hues, we could only try to con- struct them only when they are required because we have come across a formula of the form чAα.

Table 2 Benchmarks



Conclusion

We have presented a rooted tableau for BCTL*. This was expected to have much better performance than the original tableau in [7], and the benchmarks included in this paper show that this is indeed the case. We have tried to keep this tableau otherwise similar to the original; as such it is more “fair” to compare other rooted tableaux to this tableau than the original. It is often hard to directly compare the benchmarks of this tableau with that of [3], as this paper uses BCTL* while [3] uses CTL*, but we suspect that each technique will outperform the other in some cases. To compare the techniques more conclusively we will investigate the effect of different optimisations, develop a similarly efficient CTL* tableau, and compare the techniques using randomly generated formulae.
The pure tableau techniques have the advantage that they work by creating a finite tableau, with each step being based upon sub-formulae of the formulae provided by the user. This output is likely to be more intelligible to the user. For an example of the output tableau see Figure 1.
Proving that a formula is valid in BCTL* has the advantage that it also demon- strates that the formula is valid in CTL*. The semantics of CTL* may not be ap- plicable in all cases. Never-the-less we considered efficient rooted tableau of BCTL* primarily as a step towards finding efficient CTL* tableaux.

References
Emerson, E. A. and A. P. Sistla, Deciding branching time logic: A triple exponential decision procedure for CTL*, in: E. M. Clarke and D. Kozen, editors, Logic of Programs, Lecture Notes in Computer Science 164 (1983), pp. 176–192.
Emerson, E. A. and A. P. Sistla, Deciding branching time logic, in: Proceedings of the 16th annual ACM symposium on Theory on computing (STOC) (1984), pp. 14–24.
Friedmann, O., M. Latte and M. Lange, A decision procedure for CTL* based on tableaux and automata, in: J. Giesl and R. Hähnle, editors, 5th International Joint Conference on Automated Reasoning (IJCAR), LNCS 6173, Springer, 2010 pp. 331–345.
URL  http://dx.doi.org/10.1007/978-3-642-14203-1_28
McCabe-Dansted, J. C., A rooted tableau for BCTL* (2011).
URL http://www.csse.uwa.edu.au/~john/papers/Rooted_BCTL_Tableau.pdf

McCabe-Dansted, J. C., “A Temporal Logic of Robustness,” Ph.D. thesis, The University of Western Australia (2011).
URL http://dansted.co.cc/papers/Thesis_RoCTL.pdf
Reynolds, M., An axiomatization of full computation tree logic, The Journal of Symbolic Logic 66 (2001),
pp. 1011–1057.
URL http://www.jstor.org/stable/2695091
Reynolds, M., A Tableau for Bundled CTL*, J Logic Computation 17 (2007), pp. 117–132.
URL http://logcom.oxfordjournals.org/cgi/content/abstract/17/1/117

Reynolds, M., A tableau for CTL*, in: A. Cavalcanti and D. Dams, editors, Proceedings of the 16th International Symposium on Formal Methods (FM), Lecture Notes in Computer Science 5850 (2009),
pp. 403–418.
Vardi, M. Y. and L. Stockmeyer, Improved upper and lower bounds for modal logics of programs, in:
Proceedings of the 17th annual ACM symposium on Theory of computing (STOC) (1985), pp. 240–251.
