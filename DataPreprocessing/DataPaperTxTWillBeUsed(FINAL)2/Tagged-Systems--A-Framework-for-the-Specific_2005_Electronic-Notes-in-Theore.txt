Electronic Notes in Theoretical Computer Science 137 (2005) 151–174 
www.elsevier.com/locate/entcs


Tagged Systems: A Framework for the Specification of History-dependent Properties *
Fernando Rosa-Velardo Clara Segura David de Frutos-Escrig
Departamento de Sistemas Informa´ticos y Programacio´n Universidad Complutense de Madrid, Spain
e-mail: {fernandorosa,csegura,defrutos}@sip.ucm.es


Abstract
We propose a general method for the treatment of history-dependent runtime errors. When one has to control this kind of errors, a tagged version of the language is usually defined, in which tags capture only the necessary information of the history of processes. We will characterize such tagged languages as being quotients of the reachability tree defined by the computations of the original language. From this fact we can conclude that the property characterized by each tagged language is indeed a property of the original one. In this way, we can work in a common framework, instead of defining an ad hoc semantics for each property. In particular, we could still use the analysis machinery existing in the calculus in order to prove that or other related properties. We have applied this methodology to the study of resource access control in a distributed π-calculus, called Dπ. In particular, we have proved that the tagged version of Dπ is indeed a tagging according to our definition.
Keywords: Security properties, enhanced semantics, static analyses.


Introduction
Several frameworks for the definition of security properties can be found in the literature [7,8,3,4,1]. In order to specify a property sometimes it is enough to detect some erroneous states of the analyzed systems. Some of those er- roneous states can be statically identified, regardless the way in which the

  Work partially supported by the Spanish project TIC 2003-01000.


1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.01.043


error-prone state has been reached. An example of such a security property is conﬁdentiality, in which the erroneous states are those where a secret piece of data is being exhibited. 1
On the other hand, some security properties cannot be proved to hold by mere inspection of the current state. This is the case of history-dependent properties. An example of scenario in which this happens is when in order to access a resource, a process needs to have been given prior permission to use it [7].
In the former case, all that is needed to ensure that no error can occur is to identify those erroneous states, for example by means of a suitable type system, in such a way that they will not be typeable. Then, if the original system is typeable and we have subject reduction for the typed semantics, we can guarantee that no error can ever occur.
However, in the latter case, this is not possible, as errors are not a property of a single state, but of the whole computation. The most natural way of performing the necessary trace analysis is by somehow remembering along the computation the information that is needed for the characterization of the considered kind of error, tagging the processes with this information. In the previous papers on the subject, such as [7] or [10], the corresponding enriched semantics is defined in an ad hoc way, not relating it in an explicit way with the original semantics, thus making necessary specific non-reusable proofs for the corresponding relation between the original and the enriched semantics.
We propose in this paper a systematic methodology for the treatment of these errors, that begins by defining a tagged language and a unary relation on tagged processes. We will characterize such tagged languages as being quotients of the reachability tree defined by the computations of the original language. From this fact we can conclude that the property characterized by each tagged language is indeed a property of the original one. In this way, we can work in a common framework, instead of defining an ad hoc semantics for each property. In particular, we could again use a type-based analysis to guarantee that no erroneous tagged state is ever reached along the computation.
Additionally, we prove that the set of quotient systems is a complete lat- tice and profit from its algebraic structure by defining the merging of different taggings of the same system in order to capture the conjunction of two prop- erties.
The remainder of the paper is organized as follows: in Section 2 we define tagged transition systems; in Section 3 we define quotient transition systems

1 Clearly by means of such a simple property we could not cover implicit flows of informa- tion.


and prove that they are essentially tagged transition systems. Section 4 shows simple ways of deriving tagged languages; in Section 5 we present an example of the use of this methodology: we show that tagged Dπ [7,6] is a tagging according to our definition and, therefore, a quotient. Section 6 exploits the algebraic structure of quotient systems lattice by defining the combination of different taggings of the same system. Finally, Section 7 presents our conclu- sions and proposes some future work.

Tagged Transition Systems
In this section we will formally define what a tagged language will be for us. We start by defining the tagged syntax generated by a given many-sorted signature [2,5] with respect to a symbol of the signature and the considered set of labels.
Definition 2.1 Given a many-sorted signature (S, Σ), let E be the S-sorted
term algebra of Σ, f a symbol of Σ and L a set of labels (Γ, ∆,... ∈ L). We will call (f, L)-tagged syntax of E, and we will denote it by E¯L (or sometimes
just by E¯), to the S-sorted term algebra of ΣL = (Σ − {f }) ∪ {f |Γ ∈ L},
f	Γ
where arity(fΓ) = arity(f ) for every Γ ∈ L.
In terms of abstract syntax trees, tagged terms are usual terms where some nodes, either leaves in case the distinguished symbol f is a constant operator, or internal nodes otherwise, are annotated with labels in L. A more general
version of tagged syntax, E¯L1,L2,..., would consider a collection of symbols
f1, f2,... in Σ, and a (possibly) different set of labels for each one of them.
Example 2.2 Let us consider the signature (S, Σ), where S = {N at} and Σ = {Zero, Succ, +, ×}, with arity(Zero) = N at, arity(Succ) = N at → N at and arity(+) = arity(×) = N at → N at → N at. Let us also consider the
set of labels L = { ,◦}.  The S-sorted term algebra of Σ defines a set
of arithmetic expressions.  One possible tagged syntax is that generated by
Σ+,× = {Zero, Succ, ⊕, ⊗, ☒, ☒}, which defines ordinary expressions in which the operation symbols are substituted by “encircled” or “framed” symbols. Figure 1 shows the abstract syntax trees of expressions 1+(0×1) and 1⊕(0☒1).
We will use ordinary labelled transition systems.
Definition 2.3 A labelled transition system S is a tuple S = (E, V, →, e0), where E is the set of states, V is the set of transition labels, e0 ∈ E is the initial state and →⊂ E × V × E is the transition relation. If (e1, a, e2) ∈→
we will write e1 → e2.



Figure 1. Abstract syntax trees for 1 + (0 × 1) and 1 ⊕ (0 ☒ 1)

Figure 2. Transition System of Example 2.6
We will write e ⇒ e' if there exist a1,... , an ∈ V and e1,... , en ∈ E such
a1	a2	an
that e	e → ... → e  = e'. We will call the latter a computation sequence,
C the set of computation sequences, and Reach(S) = {e ∈ E | e0 ⇒ e} the set of reachable states.
Definition 2.4 Let S = (E, V, →, e0) and T = (F, V, '→, f0) be two labelled transition systems. We will say that S and T are isomorphic, and we will write S ≈ T , if there exists a mapping h : Reach(S) → Reach(T ) such that:
h is a bijection between Reach(S) and Reach(T ).
h(e0) = f0

e →a
e' ⇔ h(e) →a
h(e') for all e ∈ Reach(S)

We will say that such h is an isomorphism of labelled transition systems.
Next we will define when a transition system over the tagged syntax is a tagging of the original transition system. We will denote by O(e) the term obtained from a tagged term e once we have removed all the tags in it, defined by structural induction as:
O(h(e1,... , en) = h(O(e1),... , O(en)) if f /= h
O(fΓ(e1,... , en) = f (O(e1),... , O(en))



Figure 3. Tagged Systems of Example 2.6
Definition 2.5 Let E be the S-sorted term algebra of Σ and E¯ a (f, L)-tagged syntax of E. Also let S = (E, V, →, e0) and T = (E¯, V, '→, e¯0) be two transition systems with O(e¯0) = e0. We will say that T is a tagging of S if the following conditions hold:

If e¯ →
e¯' then O(e¯) →a
O(e¯').

If e → e' then for all e¯ reachable from e¯0
such that O(e¯) = e there exists

a unique e¯' with O(e¯') = e' such that e¯ →a
e¯'.

The first condition is a correctness property for tagged systems: they do not introduce new transitions, that is, all their transitions come from untagged ones. The second is a completeness condition: we have a unique tagged ver- sion for each original transition. Besides, uniqueness states that we cannot separately remember different things about the same past.
Example 2.6 Let us consider the sorted signature (S, Σ) where S = {N at}, Σ = {1, 2, 3, 4, 5} with arity(i) = N at and the set of tags L = {◦, }. The terms obtained when we tag every symbol with tags in L, are just the elements in {1,... , 5} enclosed by ◦ or . Now let us consider the transition system defined by the graph in Figure 2. In this simple example, in which the graph
defining the transition system is in fact a tree, a tagged system will consist of one or several copies of the original system, with at most one for each different way of annotating the initial symbol, like in the examples shown in Figure 3. However, these copies could partially overlap for non-reachable terms, getting for instance the examples shown in Figure 4.
Notice that in the definition of tagged systems we allow the presence of some garbage nodes (under certain conditions), that will not be reachable from the initial state. We do this in order to get a more flexible definition of tagged
systems, so that we do not need an exact knowledge of the set of reachable terms to define a tagged system. Of course, in practice, we will try to define them with the least possible amount of garbage, in order to have systems as






simple as possible. 2
Figure 4. More Tagged Systems of Example 2.6

Note that in this case all the tagged systems are indeed isomorphic: if we remove every non reachable term they become equal, up to the names of states. This is so because in this simple example the transition graph is a tree and, therefore, each node determines a unique path from the initial node (the transition graph and the reachability tree are isomorphic).
Example 2.7 As a new example, illustrating non isomorphic systems, let us consider the transition system defined by the graph on the left of Figure 5, that is not a tree.  In particular, we can interpret it as a system in which an agent can be at three different servers and move from one to other by following the arrows. The corresponding tagged systems on the right can now discriminate between different ways of reaching state 3. If we consider that server 2 is malicious and we do not want our agents to move to 2 then we are interested in the property captured by the tagged system in the middle.
There, tag ◦ identifies computations in which server 2 has been visited, as
opposed to tag  . If we were only interested in which server has been first
visited then we would use the transition system on the right.
These simple examples show that it is the existence of several reachable nodes with different labels what makes labels useful: just by checking the label in the reached state we have a (partial) knowledge of the way we reached that node.

Alternative characterization of tagged systems
In this section we will characterize the tagged systems defined in the previous section as quotients of their reachability tree.  To be more precise, tagged

2 Garbage nodes are useless, but at the same time they are absolutely innocuous, out of the increasing of the size of the system.



Figure 5. Transition System (left) and Tagged Systems (right) of Example 2.7
systems are isomorphic (in the sense we have defined) to the computation tree, once we have identified some of its nodes. We start by defining the computation trees.
Definition 3.1 Given S = (E, V, →, e0) a labelled transition system and C the set of computation sequences of S, we define the corresponding compu- tation tree St = (C, V, '→, e0), as the transition system obtained by taking '→⊂ C × V × C, defined by the rule
e → e'	last(L) = e

L →a
(L →a
e')

where “last” is the function that gives us the last state of each computation sequence.
The computation tree is simply the transition system defined by the reach- ability tree of the original system. It merely accumulates in its states the se- quence of states that have been visited along the computation and the trans-
itions between them. Thus, it contains all the information about the history of the process. We will sometimes call it the totally tagged system.
However, in general we will only be interested in a particular aspect of this information. We will use equivalence relations among computations to identify the required information.
Definition 3.2 We will say that an equivalence relation ∼⊂ C × C is suitable
if it satisfies the following conditions:
L1 ∼ L2 ⇒ last(L1) = last(L2)
L ,L	∈ C and L  ∼ L  ⇒ ∀a ∈ V and e ∈ E such that last(L ) →a e
1	2	1	2	1
a	a	a
(and therefore last(L2) → e) it holds (L1 → e) ∼ (L2 → e).
For example, the relations ∼⊥ such that L1 ∼⊥ L2 ⇔ last(L1) = last(L2) and ∼T such that L1 ∼T L2 ⇔ L1 = L2 are trivial examples of suitable equivalences.


By means of suitable equivalences we will characterize the information about the past we are interested in. For instance, ∼⊥ is the relation that forgets everything about the past, while ∼T is that remembering absolutely everything. Now we define the quotient transition system generated by such an equivalence relation.
Definition 3.3 Let S = (E, V, →, e0) be a labelled transition system and
∼⊂ C × C a suitable equivalence relation. We define S∼ = (C/∼, V, '→∼, [e0]), and call it a quotient transition system of S with respect to ∼, as the transition system defined by the rule
L → L'

[L] →a	[L']
where L, L' ∈ C.
The first condition in Definition 3.2 is introduced so that the quotient transition system is uniformly defined, in the sense that its transitions do not depend on the choice of the representatives of the equivalence classes. The second condition states that the relation remembers at least the final state reached by the computation.
For the equivalences ∼⊥ and ∼T defined above, it turns out that S∼⊥ and
S∼T are isomorphic to S and St, respectively.
Quotient transition systems are a conservative extension of ordinary trans- ition systems in the following sense.
Proposition 3.4 If [L1], [L2]  ∈ C/∼ are two equivalence classes such that
[L ] →a	[L ] then last(L ) →a last(L ).
1	∼	2	1	2
Proof Let us suppose that [L ] →a	[L ]. By definition of '→  there exist L'
1	∼	2	∼	1
a
and L' such that L1 ∼ L' , L2 ∼ L' and L' '→ L' . As well, by definition of

2	'  1 a
2	1	2

'→, it holds that last(L1) '→ last(L' ) and, since ∼ was suitable and Li ∼ L',
it follows that last(Li) = last(L' ) and, therefore, we are done.	 
Now let us take a closer view at the structure of the set of quotient trans- ition systems.
Definition 3.5 We denote by S the set of quotient transition systems, that is,
S = {S∼ |∼ suitable}, and define the operators H and H by S∼1 HS∼2 Δ S∼1 ∩∼2
and S∼1 H S∼2 Δ S∼1 ∪∗∼2 , where R ∪∗ R is the transitive closure of R ∪ R .
=	1	2	1	2
The order induced by those operators is S∼1 ≤ S∼2 ⇔ ∼1⊇∼2, that is, the more the information captured by the relation, the upper the corresponding quotient system is in the lattice. Then we have the following


Proposition 3.6 (S, H, H) is a complete lattice that has S and St as bottom and top elements, respectively.
Proof First, (S, H, H) is a lattice, since both H and H are idempotent, com- mutative, associative and satisfy the absorption law.	To prove that it is
complete we have to see that every subset of S has a supremum and an
infimum. Let {S∼i | i ∈ I} be a subset of S and take ∼inf =  ∗	∼i and

∼sup=
i∈I
i∈I ∼i. Both ∼inf and ∼sup are suitable equivalence relations and

S∼inf and S∼sup are the infimum and the supremum of {S∼i | i ∈ I}, re- spectively. Also, if ∼ is a suitable equivalence relation then ∼T⊆∼⊆∼⊥ and, therefore S∼⊥ ≤ S∼ ≤ S∼T . To conclude, it remains to see that S and St are isomorphic to S∼⊥ and S∼T , respectively. The latter is trivial. Let us see the former. Let us consider the function h given by h(e) = [e]∼⊥ for e ∈ E, that is, the quotient mapping restricted to empty computations sequences. Let us
see that h is a bijection satisfying the required conditions. First, h is biject- ive since it has last([L]∼⊥ ) = last(L) as inverse. Note that it is well defined
a
since ∼⊥ is suitable. Moreover, since [e → e']∼	= [e']∼ , it follows that
e → e' ⇔ h(e) →a  h(e'), for all e ∈ Reach(S), as required by Definition 2.4. 
Now let us state the main theorem of this section.
Proposition 3.7 Let S = (E, V, →, e0) be a labelled transition system and T = (E¯, V, '→, e¯0) a tagging of S. Then T is isomorphic to a quotient transition system of S.
Proof Let us suppose that T is a tagging of S. We must find a suitable relation ∼, such that T will be isomorphic to S∼. We will get it by defining a function π over the computation sequences of S such that O(π(L)) = last(L),
Δ
and taking ∼ as the kernel of π, that is, L1 ∼ L2 ⇔ π(L1) = π(L2). For each
computation L, we define π(L) by induction on its length. The base case is straightforward, π(e0) = e¯0, that satisfies O(π(e0)) = e0 = last(e0). Let us
suppose that we have just defined π(L) = e¯ and we want to define π(L →a e').
If e = last(L), since e →a e' and we are assuming that O(e¯) = e, there exists
a single e¯' satisfying condition 2 of the definition of tagged systems. Then we
take π(L →a e') = e¯', that also satisfies O(e¯') = last(L →a e').
It is easy to see that the so defined relation is suitable and that T is isomorphic to S∼, just taking h([L]) = π(L), that is well defined by definition of ∼, is a bijection between reachable terms and satisfies the conditions to be an isomorphism between transition systems.	 
The definition of tagged system induces a commutative diagram for every computation sequence, as depicted in Figure 6. In this diagram function π is


a	b	c
0  e1  e2  e3


π

e¯0
π

a	e¯1
π

 e¯2 b
π

c	e¯3

Figure 6. Commutative diagram induced by a tagged system
defined over the computation sequence reaching each ei. The converse is also true.
Proposition 3.8 Let S = (E, V, →, e0) be a labelled transition system and ∼
a suitable equivalence relation. Then S∼ is isomorphic to a tagging of S.
Proof Let S = (E, V, →, e0) be a labelled transition system and ∼ a suitable
relation over its computation sequences. We must define a tagging of S, S¯, isomorphic to S∼. First, we will tag every term of the syntax, so that tagged
terms can be seen as pairs (e, Γ) with e ∈ E. Now, we take as set of labels the set C/∼ of equivalence classes defined by the suitable relation ∼. Then we define '→ by the rule
e → e'	last(L) = e

(e, [L]) →a
(e', [L →a
e'])

The transition relation '→ is well defined since ∼ is suitable. Then, it holds that S¯ = (E × C/∼, V, '→, (e0, [e0])) is a tagging of S. To conclude the proof, we just have to check that the function h([L]) = (last(L), [L]) defines an isomorphism between S¯ and S∼, what is immediate.	 
In our Example 2.6 the lattice generated by the transition system is de- generate, since the bottom the top elements are isomorphic. Therefore, all the tagged systems are also isomorphic. Let us now study a more complex example.
Example 3.9 Let us now consider the language Dπ 3 [7] and the process
l ∗(go κ.go l)) which spawns trivial agents that go to location κ and then back to l, where they die. We will use the set of labels L = { ,◦} to label
the transition system that the term generates. For each natural number n let us denote also by n the term κ go l) | . n.. | κ go l) | l ∗(go κ.go l)), that is, the term representing the state in which exactly n agents are at κ. In Figure 7

3 That language will be formally presented in Section 5, although we consider that this particular example can be understood here without going into those formal details.



Figure 7. Transition graph (left) and reachability tree (right) of Example 3.9

Figure 8. Two quotient transition systems for Example 3.9
we present the transition graph (left) and the corresponding reachability tree (right).
Then the two transition graphs shown in Figure 8 define a couple of quo- tient transition systems. The one on the left determines the parity of the number of agents that have died, while the one on the right only determines
whether any agent has ever died. Therefore, in this second case state	cor-
responds to computation 01 ... n, while state	identifies every computation
sequence ending in state n, but 01 ... n. In terms of the used suitable relation,
~ identifies every computation of the form 01 ... n (the right-branch of the reachability tree) only with itself, while for the rest of the nodes, it relates every computation ending in the same state.
Proposition 3.7 states the existence of a quotient system isomorphic to a tagging of a transition system. However, such quotient system is not ne- cessarily unique, because our notion of isomorphism totally disregards the information of states.
Example 3.10 In Figure 9, the graph on the left defines a simple transition



Figure 9. Isomorphic quotient systems of Example 3.10
system and the others are different quotient systems of the latter. The quotient systems are indeed isomorphic but intuitively they capture different proper- ties of the original system: the one on the left identifies those computations starting by 3, while the one on the right identifies the computations starting by 2.
To get uniqueness (see Theorem 3.15) we will need a refined version of isomorphism that also preserves some properties of states. We will formally define these properties by means of functions that map states to a common domain.
Definition 3.11 Given S = (E, V, →, e0) and T = (F, V, '→, f0) and a func- tion f : E ∪ F → States mapping states in E and F to a set States, we say that a mapping h is a f -isomorphism if:
h is an isomorphism of transition systems.
f (h(e)) = f (e) for every e ∈ Reach(S).
We will write S ≈f T if there exists a f -isomorphism between S and T .
We want our isomorphism to respect the reached state, both in tagged and quotient systems. Therefore we will identify these transition systems up to st-isomorphisms, being st(e) = O(e) and st([L]∼) = last(L). To be more precise, and abusing notation, when comparing quotient systems we will use st : C/∼1 ∪ C/∼2 → E, and when comparing a tagged system and a quotient
system we will use st : E¯L∪C/  → E. We will need the following two lemmas.

Lemma 3.12 If [L0]∼
then [L1]∼ = [L2]∼.
→a	[L ] , [L ]
→a	[L ]	and last(L ) = last(L )

Proof If [L ]  →a	[L ]
and [L ]  →a	[L ]
then there exist L' , L'', L'
and

0 ∼	∼	1 ∼
0 ∼	∼	2 ∼
a	0	0	1

L' such that L' ∼ L ∼ L'', L ∼ L' for i = 1, 2, L'
'→ L' and L'' →a L' .

2	0	0	0	i	i
0	1	0	2


Since last(L1) = last(L2) and ∼ is suitable, it follows that there exists e
such that L' = L' →a e and L' = L'' →a e. Again, since L' ∼ L'' and ∼ is
suitable it holds L' ∼ L' . By transitivity of ∼ we get L1 ∼ L2 and therefore
[L1]∼ = [L2]∼.	 
Lemma 3.13 If the quotient systems S∼1 and S∼2 are st-isomorphic then there exists one and only one st-isomorphism between S∼1 and S∼2 , namely the function h deﬁned by h([L]∼1 ) = [L]∼2 .
Proof Let h be a st-isomorphism between S∼1 and S∼2 . Let us see that h([L]∼1 ) = [L]∼2 by induction on the length of L. If L = e0 then h([e0]∼1 ) = [e0]∼2 because h is an isomorphism and [e0]∼1 and [e0]∼2 are the initial states
of S∼1 and S∼2 , respectively.  Now suppose L = L' →a  e.  The induction
a
hypothesis tells us that h([L']∼1 ) = [L']∼2 . Since L' → L then [L']∼ →∼ [L]∼ .
i	i

Since h is an isomorphism, for i = 1 we get h([L']∼1
) = [L']∼2
→∼2
h([L]∼1 ).

Let L'' ∈ C such that [L'']∼2 = h([L]∼1 ). Since h preserves states, last(L'') = st(h([L]∼1 )) = st([L]∼1 ) = last(L). Then we can apply the previous lemma to obtain h([L]∼1 ) = [L'']∼2 = [L]∼2 .	 
Lemma 3.14 If S∼1 ≈st S∼2 then ∼1=∼2.
Proof Since S∼1 ≈st S∼2 there exists a st-isomorphism h as in the previous lemma. Now, L ∼1 L' ⇔ [L]∼1 = [L']∼1 ⇔ h([L]∼1 ) = h([L']∼1 ) ⇔ [L]∼2 = [L']∼2 ⇔ L ∼2 L', where the second equivalence holds because h is bijective. 
Notice that Example 3.10 was not a counterexample for the previous lemma since S∼1 and S∼2 were isomorphic but, in fact, they were not st-isomorphic. Now we can prove our theorem.
Theorem 3.15 If T is a tagging of S then there exists a sigle quotient S∼
such that T ≈st S∼.
Proof
Existence: the equivalence ∼ and the mapping h, as defined in the proof of Proposition 3.7, that is h([L]∼) = π(L), are such that h defines an isomorphism between T and S∼. Moreover, h is a st-isomorphism since st(h([L]∼)) = st(π(L)) = last(L) = st([L]∼).
Uniqueness: Suppose that there exist ∼1 and ∼2 such that S∼1 ≈st T and T ≈st S∼2 . By transitivity of ≈st it holds that S∼1 ≈st S∼2 and therefore, applying the previous lemma, S∼1 = S∼2 .
 

Deriving Tagged Languages
Now we address the problem of deciding whether an operational semantics, defined by a reduction relation over a tagged syntax, is in fact a tagging (and therefore a quotient) of the original reduction semantics, which was our initial goal.
Tagged semantics will be parameterized over the set of possible initial tagging functions tag : E → E¯, that will depend on the specific application we are interested in. In particular, tagging functions will satisfy O ◦ tag = IdE, but not the other way around. Typically, this function will capture on tags the
static information needed to formalize the property in which we are interested. In general, a semantics over the tagged syntax is a tagging of another operational semantics with respect to an initial tagging function tag if for every P the transition system that generates tag(P ) is a tagging of the transition
system generated by P .
Definition 4.1 We will say that a reduction relation R¯ = (E¯, V, '→) is a
tagging of R = (E, V, →) with respect to the initial tagging function tag if for every e ∈ E the labelled transition system (E¯, V, '→, tag(e)) is a tagging of (E, V, →, e).
We will just consider a particular case, that will be enough for our current purposes: that in which the reduction relation is structurally defined.  Let

us suppose that → is defined by means of a set of axioms Ai
: Pi
→ai
Qi for

i = 1, 2,... and a set of structural rules Ri of the form

P → Q Ci(P ) → Ci(Q)
with contexts Ci = fi(t1, .., , .., tn ), i = 1, 2,.. ., where the fi’s used in the contexts are not distinguished symbols. Then, these structural rules can be directly considered as rules for the tagged syntax. In this setting, if we replace every axiom Ai by the set of corresponding tagged versions Ai for every way of tagging the Pi’s, we obtain a tagging of R.
Proposition 4.2 Let us consider R deﬁned by means of the axioms Ai as
above and a set of axioms A¯ : P¯ →ai  Q¯ , with i = 1, 2,.. ., such that O(P¯ ) = P
i	i	i	i	i
and O(Q¯i) = Qi. Assume that each A¯i is deﬁned for every possible tagging 4



4 To be exact, we will have an axiom A¯
¯ : P¯
ai Q¯
for each P¯
such that O(P¯ ) = P ,

i,Pi
i →	i	i	i	i

but usually all of them will have a homogenous structure. This is why we proposed above
that more concise notation.

of Pi and let R¯ be the reduction relation deﬁned by the set of axioms A¯1, A¯2,... 
and the set of compositional rules R1, R2,... Then R¯ is a tagging of R.
Proof Given P0, we prove condition 1 by rule induction on the definition of
'→ and condition 2 by rule induction on the definition of →:

If P¯ →a
P¯' then O(P¯) →a
O(P¯')

A¯ : P¯ →ai Q¯ . By hypothesis A : O(P¯ ) →ai O(Q¯ ).
i	i	i	i	i	i
For the sake of readability, let us suppose that fi is a unary con-
a
structor, so that we have Ri : P¯ = fi(Q¯) → fi(Q¯') = P¯' with
Q¯ →a Q¯'. By the induction hypothesis we have O(Q¯) →a O(Q¯'). Since
the symbol fi is not distinguished, O(P¯) = O(fi(Q¯)) = fi(O(Q¯)),
a
and we can apply rule Ri to obtain O(P¯) = fi(O(Q¯)) → fi(O(Q¯')) =
O(fi(Q¯')) = O(P¯').
If P →a P ' and P¯ ∈ Reach(tag(P )) such that O(P¯) = P then there
0
exists a unique P¯' with O(P¯') = P ' and P¯ →a P¯':

ai
A : P → Q . By hypothesis, for every tagging P¯ of P
we have a

i	i	i	i	i

unique tagged version of the axiom, A¯i.
Again, let us suppose that P = fi(Q) →a
P ' = fi(Q') with Q →a

Q'.

Given P¯ as above, since fi is not distinguished, it must be the case
that P¯ = fi(Q¯) with O(Q¯) = Q. Now we can apply the induc-
tion hypothesis: there exists a single Q¯' such that O(Q¯') = Q' and
Q¯ →a Q¯'. Now we can take P¯' = fi(Q¯'), that is the only term such
that O(P¯') = P ' and P¯ →a P¯'.

This is the simplest way of deriving a tagged semantics from a given se- mantics. The same can be done if the latter is defined by means of a structural congruence, when the distinguished symbols do not appear either in its axioms or in the rules. In this case these axioms and rules can also be applied to the tagged relation, thus defining a structural equivalence between tagged terms. Then, if we add to the set of given previous reduction rules the corresponding congruence rule we also obtain a tagging of the original semantics. This is the case we will study in the following section.

Tagged Dπ
In this section we will apply the proposed methodology to the language Dπ [7], which is a distributed version of the π-calculus. In fact, for simplicity, we will consider the version presented in [6]. There, a type-based analysis is defined for detecting those systems where there exists a violation of the permissions for using resources (more specifically, channels). In order to prove the correctness
















Figure 10. Syntax of Dπ

of the analysis, an enhanced semantics is defined over a tagged syntax, where agents are decorated by permissions that are accumulated by them along the execution of the system. Then a subject reduction theorem and a safety theorem are proved, so that well-typed agents do not violate permissions in the enhanced semantics. However there is no formalized connection between the enhanced semantics and the original one and consequently, the property captured by the type system is not clearly related with the original semantics. We think that a way to express the property in the original calculus is needed. In this section we provide such way, as we prove that tagged Dπ is a tagging of Dπ according to our definition and therefore, a quotient. This leads to the conclusion that the type system captures a property of the original system. Additionally, the generality of our approximation would allow us to do the same for any property we would like to capture with a static analysis.
The syntax of Dπ is defined in Figure 10. The dots stand for the usual primitives of the π-calculus [9]: termination, composition, replication, input, output and conditional. A new construct k P ), meaning that P is located at k, and a primitive go for movement are introduced. Created names can be channels, but also localities. Such names are local, so localized names such as u@v are needed when using global references.
In Figure 11 you can find the definition of the operational semantics of the language. The structural congruence ≡ (that we do not show here) and most of the rules are similar to those of π-calculus. Only rules (R-GO) and (R-COMM) are specific of Dπ. The former moves one process from one location to another, while the latter restricts communication to be local, that is, between processes within the same location.


Figure 11. Semantics of Dπ

Figure 12. Tagged axioms of Dπ

Tagged Dπ is a version of Dπ in which the construct  ) is substituted by
 )Γ, where Γ ranges over typing environments, that is, partial functions from locality identifiers to K, the set of locality types, whose formal definition is here irrelevant [7]. Intuitively, they assign permissions (to use channels) to agents
at each locality. For instance, if an agent is tagged with Γ and Γ(k) = K then it has permissions at k specified by K.
The semantics of Tagged Dπ is defined by the axioms and rules in Fig- ure 12. There, Γ, {ke : E} denotes the extension of Γ at k with the new name e having type E. The most important rule is (R-COMM) which allows the acquisition of new permissions through communication.
Then the set of tags L is the set of typing environments and the distin- guished symbol is  ). By mere inspection of the rules defining the tagged


language it can be seen that they satisfy the conditions imposed in the pre- vious section. Indeed, we have a tagged version of each axiom, for every way of tagging the term on its left hand-side. The rest of the rules of the original language can also be considered as rules of the tagged one, since the symbol
 ) does not appear in their definition. Then we have the following
Theorem 5.1 Tagged Dπ is a tagging of Dπ.
According to this result and our characterization of tagged systems it fol- lows that the transition system generated by each term of Tagged Dπ is iso- morphic to a quotient transition system. Therefore, every property defined over Tagged Dπ is also a property of Dπ. In particular, every subset of tagged terms (e.g., that of erroneous terms) defines a subset of computations (that of erroneous computations).
The result is true whatever the initial tagging function is. However, the choice is crucial to adequately formalize the runtime errors we have in mind: in this case the resource access errors. In [7] the chosen function tag is only defined for typed processes of the original calculus, so that if M is not typeable then tag(M ) = ∅. As a consequence, it is not possible to describe the resource access errors (violation of permissions) produced by non-typeable systems. In our opinion the definition of resource access error should be independent of typability. Then we should prove that the type system rules out erroneous systems.
Following this approach we tag every original process, simply by adding to the tags the created names, which are exactly those the agents have ini- tially permission to use. We will do so using the mappings tagΓ(M ), where Γ is the initial knowledge of M . Let us consider the system defined by (νa : A)(k b!⟨a⟩) | k b?(x : A).x!⟨c⟩)). Though the channel a is created with the two agents under its scope, only the agent on the left knows of its exist- ence. In fact, the scope of the names can always be extended via extrusion. In particular, that system and (νa : A)k b!⟨a⟩) | k b?(x : A).x!⟨c⟩) are equi- valent. In order to deal with this fact, we will restrict ambient domains in tagΓ(M ) to the set of free names in M , that is, we will have the invariant
dom(Γ) = fn(M ), and we will denote by ΓM the restriction Γ |fn(M). Now we
can define the initial tagging function.
Definition 5.2 Let Φ be the empty (partial) function in L (that with empty

domain). Then we define the function tag : M → M¯
tag(M ) = tagΦ(M ) if M is closed
tagΓ(0) = 0
tagΓ(M | N ) = tagΓM (M ) | tagΓN (N )
by:


tagΓ((νle : E)M ) = (νle : E)tagΓ,{Æe:E}(M ) if e ∈ f n(M )
tagΓ((νle : E)M ) = (νle : E)tagΓ(M ) if e /∈ f n(M )
tagΓ(l P )) = l P )Γ
In [7] an error relation on the corresponding tagged systems M → err is defined, meaning that a process can violate its permissions. To remove these errors, a type system ▶ for the original language and another one H for the tagged systems were defined. Now we need the following lemma.
Lemma 5.3 If Γ ▶ M then Γ H tagΓ(M ).
Proof The proof is straightforward by induction on the rules used to derive Γ ▶ M (see [7]):
Γ ▶ 0. Since tagΓ(0) = 0 and Γ H 0 the thesis follows.
Γ ▶ k P ). Then it is the case that Γ ▶k P . Since Γ <: Γ it follows that Γ H k P ).
Γ ▶ M1 | M2 with Γ ▶ Mi. By strengthening it follows that ΓMi ▶ Mi and by the induction hypothesis, ΓMi H tagΓM (Mi) and, by weakening, Γ H tagΓM (Mi). Since tagΓ(M1 | M2) = tagΓM1 (M1) | tagΓM2 (M2) it fol- lows that Γ H tagΓ(M1 | M2).
Γ ▶ (νke : E)M with Γ, {ke : E} ▶ M . By induction hypothesis it follows that Γ, {ke : E} H tagΓ,{ e:E}(M )
If e ∈ f n(M ) then tag((νke : E)M ) = (νke : E)tagΓ,{ke:E}(M ) and we can conclude Γ H tagΓ((νke : E)M )
If e ∈/ f n(M ), by strengthening it also holds that Γ H tagΓ,{ e:E}(M ) and since then tag((νke : E)M ) = (νke : E)tagΓ,{ke:E}(M ), the thesis follows.

A subject reduction theorem and a safety theorem for the tagged system were proved in [7]. Then we have our safety theorem.
Theorem 5.4 If	Γ ▶ M and tagΓ(M ) '→∗ M ' then M ' /→ err.
And the following
Corollary 5.5  If	Φ ▶ M and tag(M ) '→∗ M ' then M ' /→ err.
This result also appears in [7], but no interpretation of it is given in terms of the original semantics of the language. Instead, we can now interpret the fact that M /→ err as the impossibility to use a resource when we have not received the permission to do it along the current computation, since the tags remember exactly the set of accumulated permissions.


Example 5.6 As a very simple example, let us consider
M = (νl : loc{a : res⟨T ⟩})(νkb : res⟨T ⟩)(νlc : T )l b!⟨c⟩)
We can tag M , getting
tag(M ) = (νl : loc{a : res⟨T ⟩})(νkb : res⟨T ⟩)(νlc : T )l b!⟨c⟩)Γ
with
Γ = {l : loc{a : res⟨T ⟩,c : T },k : loc{b : res⟨T ⟩}}
However, M is not typeable and, in fact, tag(M ) → err, since it attempts to use channel b at locality l, which is not allowed by Γ. Of course, since types cannot be complete, it could be the case that M is not typeable but tag(M ) will not produce any error.

Applications of the algebraic structure of quotient systems lattice
In this section we are giving a brief overview of how we can profit the algebraic structure of the quotient systems lattice, in particular for the combination of different taggings of the same system. We start by defining the merging of two different taggings of a given syntax.
Definition 6.1 Given a many-sorted signature (S, Σ), let E be the S-sorted term algebra of Σ, f1 and f2 two symbols of Σ and L1 and L2 two (non-
empty) sets of labels. We define the merging of E¯L1 and E¯L2 ,and we denote

it E¯L1 ⊕ E¯L2 , as E¯L1 ,L2 if f
/= f
ƒ1
or as E¯L1×L2 when f
ƒ2
= f . This definition

ƒ1	ƒ2
ƒ1 ,ƒ2	1	2	ƒ1	1	2

can be easily generalized to consider different distinguished symbols and sets
of tags.
If we take O1 and O2 as the functions deleting labels from L2 and L1,
respectively, given e1 ∈ E¯L1 and e2 ∈ E¯L2 such that O(e1) = O(e2) there
exists only one e ∈ E¯L1 ⊕E¯L2 , that we denote e1 ⊕e2,such that O (e) = e1 and
ƒ1	ƒ2	1
O (e) = e2. Then we can define a partial operator ⊕ from the set E¯L1 × E¯L2
2	ƒ1	ƒ2
to E¯L1 ⊕ E¯L2 , as depicted below. It simply takes a term tagged in two ways
ƒ1	ƒ2

and merges those tags.
E
¯L1
ƒ1



E¯L1 ⊕ E¯L2	⊕	E¯L1 × E¯L2

ƒ1	ƒ2	ƒ1	ƒ2


Now let us make use of these notations to combine different taggings.
Definition 6.2 Let S = (E, V, →, e0) be a labelled transition system of E and

T = ( ¯L1	1
¯L2	2

1	Eƒ1 , V, '→1, e0 ) and T2 = (Eƒ2 , V, '→2, e0 ) two different taggings of S.
We define the merging of T and T as T ⊕ T =(E¯L1 ⊕ ¯L2	'→, e 1 ⊕ e 2),

1	2	1	2
where '→ is defined as follows:
 	a	
ƒ1	Eƒ2 , V,	0	0

Oi(e1) '→i Oi(e2)	i = 1, 2

e →a e
Proposition 6.3 If T1 and T2 are taggings of the transition system S then
T1 ⊕ T2 is a tagging of S.
Proof We must check that the two conditions for a transition system over a tagged syntax to be a tagging:
If e  →a  e  then O(e ) → O(e ): by definition of '→, O (e ) →  O (e ). T
1	2	1	2	1  1	1	1  2	1
is a tagging of S and, therefore, O(O (e )) →a O(O (e )), that is (see the

diagram above), O(e ) →a
1  1	1  2
O(e2).

Let e  →a
e2 and e1 ∈ Reach(T1 ⊕ T2) such that O(e1) = e1. Then e1 =

e11 ⊕ e12 with e1i ∈ Reach(Ti) (i=1,2). Since T1 and T2 are taggings of S
and O(e i) = e there exist a single e 1 and a single e 2 such that e i →a  e i.
1	1	2	2	1	i  2
Then we can take e = e 1 ⊕ e 2, which is the only term in E¯L1 ⊕ E¯L2 such

2	2	2
  a  
ƒ1	ƒ2

that O(e2) = e2 and e1 '→ e2.

Moreover, T1 ⊕ T2 captures exactly those properties captured by T1 and
T2, as formalized by the following theorem.
Theorem 6.4 Let S = (E, V, →, e0) be a labelled transition system of E and

T = ( ¯L1	1
¯L2	2

1	Eƒ1 , V, '→1, e0 ) and T2 = (Eƒ2 , V, '→2, e0 ) two different taggings of S.
Suppose that S∼1 and S∼2 are the quotient systems st-isomorphic to T1 and
T2, respectively. Then T1 ⊕ T2 is st-isomorphic to S∼1 H S∼2 .
Proof Let us suppose that hi are st-isomorphisms between S∼i and Ti, for i =
1, 2, and take h : C/ → E¯L1 ⊕E¯L2 , defined as h([L] ) = h ([L]	)⊕h ([L]	),

~
where ∼=∼1 ∩ ∼2.
ƒ1	ƒ2
~	1	∼1
2	∼2

h is well defined: if L ∼ L' then L ∼i L' for i = 1, 2 by definition of ∼. Since hi is well defined, hi([L]∼ ) = hi([L']∼ ) for any i = 1, 2 and therefore,
i	i
h([L]∼) = h([L']∼). Moreover, ⊕ is defined for h1([L]∼1 ) and h2([L]∼2 )
because O(hi([L]∼i )) = st(hi([L]∼i )) = st([L]∼i ) = last(L) for i = 1, 2 and therefore, O(h1([L]∼1 )) = O(h2([L]∼2 ))
h is injective: h([L]∼) = h([L']∼) ⇒ h1([L]∼1 ) ⊕ h2([L]∼2 ) = h1([L']∼1 ) ⊕
h2([L']∼2 ). This implies (by definition of ⊕) that hi([L]∼i ) = hi([L']∼i ) for



i = 1, 2. Since h1 and h2 are injective, [L]∼i therefore, [L]∼ = [L']∼.
= [L']∼
for i = 1, 2 and

h is surjective: let e ∈ Reach(T1 ⊕ T2) and take Oi(e) = ei ∈ Reach(Ti).
i
Since hi is surjective there exist [Li]∼i such that hi([Li]∼ ) = e . Again, since
e ∈ Reach(T1 ⊕ T2) there exists L ∈ C such that L1 ∼1 L ∼2 L2. Then,
h([L]∼) = h1([L]∼1 ) ⊕ h2([L]∼2 ) = h1([L1]∼1 ) ⊕ h2([L2]∼2 ) = e1 ⊕ e2 = e.
h is an isomorphism of transition systems:
h([e0]∼) = h1([e0]∼1 ) ⊕ h2([e0]∼2 ) = e01 ⊕ e02, since h1 and h2 are iso- morphisms.
[L]  →a	[L']  ⇔ [L]	→a	[L']	⇔ h ([L]  ) →a  h ([L']  ) ⇔ h([L] ) →a

∼	∼	∼
∼i	∼i	∼i
i	∼i	i  i	∼i	∼

h([L']∼)
h preserves states: st(h([L]∼)) = st(h1([L]∼1 )⊕h2([L]∼2 )) = O(h1([L]∼1 )) =
st(h1([L]∼1 )) = st([L]∼1 ) = last(L) = st([L]∼).

Example 6.5 Let us recall our Example 3.9 in Section 3. Since every symbol in the syntax is tagged, every tag in the merged system is a pair (Γ, ∆) with
Γ, ∆ ∈ { ,◦}. To simplify the notation we will take 5 ◦ = (◦,◦),  = ( , ) and ⬦ = (◦,  ) (we will not need the tag ( ,◦) since terms tagged with it will
not be reachable). The merging of the two properties, shown in Figure 13, tell us whether any agent has died, and in such a case, whether this happened an even number of times. Theorem 6.4 tells us that this new transition system
captures the conjunction of both properties, that is, terms tagged with ◦
identify those computations in which no agent has died, identifies those computations in which an odd number of agents have died and ⬦ identifies those computations in which an even, but not null, number of agents have
died. However, when we consider the meet of both transition systems (the disjunction of properties) we go all the way down to the bottom of the lattice.

Conclusion and Future Work
We think that the present work is a rather simple, but conceptually important justification of the use of tagged languages for the analysis of systems. The fact that these systems are quotients of the corresponding reachability trees tells us that the properties defined over them are, indeed, also properties of the original semantics, thus keeping us within the same original framework for every possible property of our interest. Besides, the work has been developed

5 Obviously, we are here overloading the notation in order to preserve the symbols used in the figures.



Figure 13. Merging of tagged systems

St
⊥S
Figure 14. Extended quotient systems lattice
in a very general setting that can be systematically applied to any particular language and property of interest.
Here we have just applied the algebraic structure to a very simple situation, that where we want to study several properties at the same time. It may be worth a further study of the algebraic structure of the set of tagged languages, trying to exploit it to study the combination of several properties in a more general setting that includes, for example, the disjunction of properties, that seems to be trickier.
So far, we have considered equivalences remembering at least the reached state, thus getting always some tagged systems. However, this constraint could be relaxed to obtain a superset of our class of quotient systems (see Figure 14). Then the bottom would represent the tagged system forgetting absolutely everything, even the reached state. Additionally, we would have transition systems lying in the diamond of the bottom of Figure 14, remembering only certain properties about the reached state, and transition systems combining both approaches, the ones in the diamonds at both sides of the figure, that


remember some things about the past of the process but still only part of the information about the reached state. This could be of interest for instance when the syntax is defined as the term algebra of a given signature, modulo an equational theory. In that case we do not only want to identify computations reaching identical terms, but also those reaching terms that are equivalent in that theory. Of course, extra soundness conditions between that theory and the labelled transition system should hold.
We plan to study all these equivalences in a systematic way, thus trying to get their properties in a uniform way, to avoid the development of ad hoc proofs for each particular case in which we could be interested.

References
M. Boreale and M. Buscemi. A framework for the analysis of security protocols. In Concurrency Theory, 13th International Conference, CONCUR’02, volume 2421 of LNCS, pages 483–498. Springer, 2002.
Hartmut Ehrig and B. Mahr. Fundamentals of Algebraic Speciﬁcation I. Springer-Verlag New York, Inc., 1985.
R. Foccardi and R. Gorrieri. Classification of security properties (Part I: Information flow). In Foundations of Security Analysis and Design, FOSAD’00, volume 2171 of LNCS, pages 331–396. Springer, 2001.
R. Foccardi, R. Gorrieri, and F. Martinelli. Classification of security properties (Part II: Network security). In Foundations of Security Analysis and Design II, FOSAD’02, volume 2946 of LNCS, pages 139–185. Springer, 2004.
M. Hennessy. The Semantics of Programming Languages: An Elementary Introduction Using Structural Operational Semantics. John Wiley and Sons, 1990.
M. Hennessy, M. Merro, and J. Rathke. Towards a behavioural theory of access and mobility control in distributed systems. In Foundations of Software Science and Computational Structures, 6th International Conference, FOSSACS’03, volume 2620 of LNCS, pages 282–298. Springer, 2003.
M. Hennessy and J. Riely. Resource access control in systems of mobile agents. In High-Level Concurrent Languages, HLCL’98, volume 16 of ENTCS, pages 3–17. Elsevier, 1998.
M. Hennessy and J. Riely. Information flow vs. resource access in the asynchronous pi-calculus.
ACM Transactions on Programming Languages and Systems (TOPLAS), 24(5):566–591, 2002.
R. Milner, J. Parrow, and D. Walker. A calculus of mobile processes, I. Inf. Comput., 100(1):1– 40, 1992.
B. Pierce and D. Sangiorgi. Typing and Subtyping for Mobile Processes. In Proceedings 8th IEEE Logics in Computer Science, LICS’93, pages 376–385. IEEE Computer Society Press, 1993.
