	Electronic Notes in Theoretical Computer Science 214 (2008) 255–276	
www.elsevier.com/locate/entcs

More Relational Concurrent Refinement: Traces and Partial Relations
John Derrick1
Department of Computer Science, University of Sheffield, Sheffield, UK
Eerke Boiten2
Computing Laboratory, University of Kent, Canterbury, Kent, UK

Abstract
Data refinement in a state-based language such as Z is defined using a relational model in terms of the behaviour of abstract programs. Downward and upward simulation conditions form a sound and jointly complete methodology to verify relational data refinements. On the other hand, refinement in a process algebra takes a number of different forms depending on the exact notion of observation chosen, which can include the events a system is prepared to accept or refuse.
In this paper we continue our program of deriving relational simulation conditions for process algebraic refinement by defining further embeddings into our relational model: traces, completed traces, failure traces and extension.
Keywords: Data refinement, Z, simulations, process algebraic refinement preorders.


Introduction
Motivated by both theoretical comparisons of refinement and integrations of specification languages there has been significant interest in relating differing models of relational data refinement with those arising in a concurrent context.

1 Email: J.Derrick@dcs.shef.ac.uk
2 Email: E.A.Boiten@kent.ac.uk


1571-0661 Crown Copyright © 2008 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.06.012

In a process algebra such as CSP [18,24] a system is defined in terms of actions (or events) which represent the interactions between a system and its environment. The exact way in which the environment is allowed to interact with the system varies between different semantics. Typical semantics are set-based, associating one or more sets with each process, for example traces, refusals, divergences. Refinement is then defined in terms of set inclusions and equalities between the corresponding sets for different processes. As defined, the obvious and cumbersome method of verifying that refinement holds is by evaluating such set inclusions, between large and potentially infinite sets. A survey of many prominent refinement relations is given in [27].
State-based systems provide an alternate view, whereby specifications are considered to define abstract data types (ADTs), consisting of an initialisa- tion, a collection of operations and a finalisation. A program over an ADT is a sequential composition of these elements. Refinement is defined to be the subset relation over program behaviours, where what is deemed visible (i.e., the domain of the initialisation and the range of the finalisation) is the input/output relation. Thus an ADT C refines an ADT A if for every pro- gram and sequence of inputs, the outputs that C produces are outputs that A could also have produced. This definition of refinement quantifies over pro- gram behaviour and simulations have become the accepted approach to make verification of refinements tractable [13]. For a complete method, often two kinds of simulations are defined: downward and upward simulations.
Research on combining relational and concurrent refinement concentrated initially on providing joint semantics, and on identifying correspondences be- tween variations of the relational models and concurrency semantics. In the latter category, see e.g. work by Bolton and Davies [7,8] and Reeves and Streader [23]. Our work on relational concurrent refinement started [5,14] from the powerful idea that the relational ﬁnalisations can encode the obser- vations embedded in concurrency semantics. The relational simulation rules can then be used to extract simulations for concurrency. These provide a “canned induction” method of verifying concurrent refinement, by checking a fixed number of conditions for each possible action, rather than checking inclu- sion between potentially large sets. We derived simulation rules for failures- divergences refinement [14,5], including also outputs and internal operations [4], and for readiness refinement [14]. These were mostly based on the total relations model (as described below).
This paper continues the programme, by considering more concurrent re- finement relations, many of them based on the partial relations model. The structure of this paper is simple. In Section 2 we provide the basic definitions and background. In Section 3 we provide the simulation rules for a number of

process algebraic preorders, and we conclude in Section 4.

Background
This background section presents the standard refinement theory [15] for ab- stract data types in a relational setting. The relational model of data refine- ment where all operations are total, as described in the 1986 paper by He, Hoare and Sanders [17], traditionally received the most attention. The stan- dard refinement theory of Z [28,15], for example, is based on this version of the theory. However, later publications by He and Hoare, in particular [16], dropped the restriction to total relations, and proved soundness and joint completeness of the same set of simulation rules in the more general case. De Roever and Engelhardt [13] also present the partial relations theory, without putting much emphasis on this aspect.

A partial relational model
As usual [15], a program (defined here as a sequence of operations) is given as a relation over a global state G, implemented using a local state State. The initialisation of the program takes a global state to a local state, on which the operations act, a ﬁnalisation translates back from local to global.
In order to distinguish between relational formulations (which use Z as a meta-language) and expressions in terms of Z schemas etc., we introduce the convention that expressions and identifiers in the world of relational data types are typeset in a sans serif font.
Definition 2.1 [Data type]
A data type is a quadruple (State, Init, {Opi i∈I, Fin). The operations Opi , indexed by i  I , are (total or partial) relations on the set State; Init is a total relation from G to State; Fin is a total relation from State to G.
Insisting that Init and Fin be total merely records the facts that we can always start a program sequence (the extension to partial initialisations is trivial and uninteresting) and that we can always make an observation.
Definition 2.2 [Complete program]
A complete program over a data type D = (State, Init, Opi i∈I, Fin) is an
expression of the form Init o P o Fin, where P, a relation over State, is a program
9	9
over {Opi }i∈I . Programs are finite sequences of operations. For a sequence p
over I , and data type D, pD denotes the complete program over D characterised

by p. For example, if p = ⟨p1, ..., pn⟩ then pD = Init o Opp
o ... o Oppn o Fin.

As usual we assume that the data types are conformal, i.e., they use the same index set for the operations.
Definition 2.3 [Data refinement for partial relations]
For partial data types A and C, C reﬁnes A, denoted A ±data C (dropping the subscript if the context is clear), iff for each finite sequence p over I , pC ⊆ pA.
Downward and upward simulations [13] form a sound and jointly complete [17,13] proof method for verifying refinements. In a simulation a step-by-step comparison is made of each operation in the data types, and to do so the concrete and abstract states are related by a retrieve relation.
Definition 2.4 [Downward simulation]
Assume data types A = (AState, AInit, {AOpi}i∈I , AFin) and C = (CState, CInit, COpi i∈I , CFin). A downward simulation is a relation R from AState to CState satisfying
CInit ⊆ AInit o R R o CFin ⊆ AFin
∀ i : I • R o COp ⊆ AOp o R
If such a simulation exists, we also say that C is a downward simulation of A
and similarly for corresponding operations of A and C.
Any relational data types A and C in this paper are assumed to be defined as in the above definition (occasionally with extra conditions imposed).
Definition 2.5 [Upward simulation]
For data types A and C, an upward simulation is a relation T from CState to
AState such that
CInit o T ⊆ AInit CFin ⊆ T o AFin
∀ i : I • COp o T ⊆ T o AOp
If such a simulation exists, we also say that C is an upward simulation of A
and similarly for corresponding operations of A and C.
Totalisations
In terms of the observations it makes, the partial relational model described above has limitations. The fact that a trace p is “impossible” is represented by its interpretation pD being the empty set. This may be interpreted as this trace (or a prefix of it) leading to a guaranteed deadlock. However, the re- lations contain non-determinism, and depending how this is resolved during

the computation, a particular trace may or may not deadlock. In the partial relational model, it is not immediately observable that deadlock is possible but not guaranteed – thus, the non-determinism is interpreted angelically: negative results are ignored when positive ones also exist. Richer observations can be obtained in one of two ways. In most of this paper we will do so by staying within the partial relations model, by observing more at finalisation. This gives extra information not just for a trace, but through universal quan- tification over all traces, also for all its prefixes. This will, e.g., turn out to be enough to characterise possible deadlock when refusals are observed, see Section 3.3. Another way of observing possible as opposed to certain error is through modelling it explicitly by totalising the relations first. Elsewhere, a so-called non-blocking totalisation is used; here we only use the blocking to- talisation defined below. The blocking totalisation still encodes the intuition, also present in the partial relations model, that an operation cannot be applied outside its domain (the “guard”), by mapping such applications to an explicit error value  . The non-blocking view, in contrast, maps such applications to all possible values (including an “error” one), modelling the interpretation that outside the domain (the precondition) “anything” can happen, including unspecified error. For the trace-based semantics considered in this paper, the non-blocking view is less interesting, as in that model all traces are possible. The totalisations turn a partial relation on a set S into a total relation on a set S⊥, which is S extended with a distinguished value ⊥ not in S.

Definition 2.6 [Blocking totalisation]
For a partial relation Op on State, its blocking totalisation is a total relation on State⊥, defined by

O^pb == Op ∪ {x : State	| x /∈ dom Op • (x, ⊥)}


Characterisations of downward and upward simulations on these totalised relations can be simplified to remove any reference to . This results in the standard definitions of downward and upward simulations for partial relations [15].

Definition 2.7 [Downward simulation for totalised relations]
Given data types A and C where the operations may be partial. A downward
simulation is a relation R from AState to CState satisfying, in the blocking

model
CInit ⊆ AInit o R R o CFin ⊆ AFin
∀ i : I • ran(dom AOpi D R) ⊆ dom COpi
∀ i : I • R o COp ⊆ AOp o R
Definition 2.8 [Upward simulation for totalised relations]
For data types A and C where the operations may be partial, an upward simulation is a relation T from CState to AState satisfying, in the blocking model
CInit o T ⊆ AInit CFin ⊆ T o AFin
∀ i : I • dom COpi ⊆ dom(T D− dom AOpi)
∀ i : I • COp o T ⊆ T o AOp
The conditions imposed on all operations in Definitions 2.7 and 2.8 are called “applicability” and “correctness” in both cases.
Note, however, that the upward and downward simulations given above are not jointly complete for blocking refinement [3], which means that com- pleteness needs to be proved separately.
Reﬁnement in Z
The definition of refinement in a specification language such as Z is usually based on the totalised framework just given, sticking with the blocking variant. Specifically, a Z specification can be thought of as a data type, defined as a tuple (State, Init, Opi i∈I ). The operations Opi are defined in terms of (the variables of) State (its before-state) and State' (its after-state). The initialisation is also expressed in terms of an after-state State'. In addition to this, operations can also consume inputs and produce outputs. Finalisation normally does not appear explicitly in the simulation rules as presented in Z for reasons we shall see later.
If specifications have inputs and outputs, these are included in both the global and local state of the relational embedding of a Z specification. See
[15] for the full details on this – in this paper we only consider datatypes without inputs and outputs. In concurrent refinement relations, inputs add little complication; outputs particularly complicate refusals as described in [4].
In a context where there is no input or output, the global state contains no information and is a one point domain, i.e., G == {∗}, and the local state

is State == State. In such a context the other components of the embedding are as follows:
Init == {Init •∗ '→ θState'}
Op == {Op • θState '→ θState'}
Fin == {(θState, ∗)}
R == {R • θAState '→ θCState}
Given these embeddings, we can translate the relational refinement condi- tions of downward simulations into refinement conditions for Z ADTs, where we note that the finalisation conditions are always satisfied in this Z interpre- tation.
Definition 2.9 [Standard downward simulation in Z]
Given Z data types A = (AState, AInit, {AOpi }i∈I ) and C = (CState, CInit, COpi i∈I ). The relation R on AState  CState is a downward simulation from A to C in the blocking model if
∀ CState • CInit ⇒ ∃ AState • AInit ∧ R
and for all i : I :
∀ AState; CState • R ⇒ (pre AOpi ⇔ pre COpi )
∀ AState; CState; CState • R ∧ COpi ⇒ ∃ AState • R ∧ AOpi
Any Z data types A and C in this paper are assumed to be defined as in the above definition.
The translation of the upward simulation conditions is similar, however this time the finalisation produces a condition that the simulation is total on the concrete state.
Definition 2.10 [Standard upward simulation in Z]
For Z data types A and C , the relation T on AState CState is an upward simulation from A to C in the blocking model if
∀ CState • ∃ AState • T
∀ AState ; CState • CInit ∧ T ⇒ AInit
and for all i : I :
∀ CState • ∃ AState • T ∧ (pre AOpi ⇒ pre COpi )
∀ AState ; CState; CState • (COpi ∧ T ) ⇒ ∃ AState • T ∧ AOpi

Process algebraic based refinement
Process algebras [18,22,2] provide a means to describe and verify concurrent systems and processes, and provide operators such as synchronisation, com- munication, and various flavours of composition. The semantics of a process algebra is often given by means of a structural operational semantics (SOS) which associates a labelled transition system (LTS) to each term. Equiva- lence, and preorders, can be defined over the semantics where two terms are identified whenever no observer can notice any difference between their exter- nal behaviours. Thus equivalences and preorders can be defined in terms of a function O that represents the set of observations one could make while inter- acting with a process. For every such O we can define p ±O q iff O (q ) ⊆ O (p) and p =O q iff O (p)= O (q ). Varying how the environment interacts with a process leads to differing observations and these can be thought of as differing testing scenarios, and thus different preorders (i.e., refinement relations).
These are detailed in the literature, and an overview and comprehensive treatment is provided by van Glabbeek in [26,27]. As in [14] we do not con- sider internal or silent events here, and the relationship between differing equivalences and refinement relations is hence often given by the linear-time, branching-time spectrum given in Figure 1.
The testing scenarios described in [27] are found by modelling a process as a black box that contains an interface to the environment, via which tests are performed. Varying the interface gives different testing scenarios, a full characterisation is given in [25], for example, the interface might contain a display in which the name of the action is shown that is currently carried out by the process, buttons might also be present (one for each action) so that the observer may determine which actions are free and which are blocked, or lamps which illuminate if the process is ready to engage in that action.
We assume the usual notation for labelled transition systems (LTSs):
Definition 3.1 [Labelled Transition Systems (LTSs)]
A labelled transition system is a tuple (States, Act , T, s0) where States is a non-empty set of states, s0 ∈ States is an initial state, Act is a set of actions, and T ⊆ States × Act × States is a transition relation.
Every state in the LTS represents a process itself – namely the one that the original one (the initial state s0) evolves to after following a specific path in the LTS. Specific notation needed includes the usual notation for writing
transitions as p −→ q for (p, a, q ) ∈ T and the extension of this to traces
(written p	tr	q ) and the set of initial actions of a process which is defined as:



Fig. 1. The linear time - branching time spectrum [27]
next (p)= {a ∈ Act	∃ q • p −a→ q}.
In the remainder of this section we detail differing preorders and show how they are embedded into our relational model. For each we give its definition, its characterisation as a testing scenario as described by van Glabbeek, its embedding into a relational model, and thereby the definition of simulation rules to characterise the preorder.


Trace preorder
Deﬁnition and testing scenario
Definition 3.2 σ ∈ Act ∗ is a trace of a process p if ∃ q • p


−→ q . T (p)

denotes the set of traces of p. The trace preorder is defined by p ±tr q iff
T (q ) ⊆T (p).
Testing scenario: Observations consist of a sequence of actions performed by the process in succession, that is, the interface is just a display which shows the name of the action that is currently carried out by the process, and the name remains visible in the display if deadlock occurs (unless deadlock occurs initially).

Relational embedding
As observed previously [14] the partial relations model records exactly trace information for the embedding with trivial finalisation described in Section
2.3. Possible traces lead to the single global value; impossible traces have no relational image.
Definition 3.3 [Trace embedding]
A Z data type (State, Init, {Opi i∈I) has the following trace embedding into the relational model.
G ==
State == State
Init == {Init •∗ '→ θState'}
Op == {Op • θState '→ θState'}
Fin == {(θState, ∗)}
Observe also that the finalisation is a total function, thus conditions in- volving inclusions between finalisations will simplify to equalities. To prove the correspondence between trace preorder and data refinement we need to provide a definition of the traces of an abstract data type.
Definition 3.4 The traces of a Z data type (State, Init, {Opi }i∈I ) are all se- quences ⟨i1,..., in⟩ such that


∃ State' • Init o Opi
o ... o Opi

We denote the traces of an ADT A by T (A).
Theorem 3.5 With the trace embedding, data reﬁnement corresponds to trace preorder. That is, when Z data types A and C are embedded as A and C 3 ,
A ±data C iff T (C ) ⊆T (A)
Proof From the definition of traces for Z data types and the embedding given it is obvious that for any sequence p, (∗, ∗) ∈ pA iff p ∈T (A). Also, for any p, pA = ( , ) or pA = ∅. Thus, data refinement (pA pC for all p) corresponds to trace refinement. 
From this result it can be seen that observations in the testing scenario, here a display with an action name displayed, are distributed in the relational notion of refinement. That is, although finalisations are often taken to be the ‘observations’, in fact, some of the observations are implicit in the program

3 This condition is left implicit in the rest of this paper.

p and the relational inclusion pC pA (since finalisations only contain the information as to whether the trace was defined or not).
We can now extract the simulation rules that correspond to this notion of refinement. These are of course the rules for standard Z refinement but omitting applicability of operations, as used also e.g. in Event-B [1].

Simulations
The conditions for a downward simulation in the partial relational model are (c.f. Definition 2.4):
CInit ⊆ AInit o R R o CFin ⊆ AFin
∀ i : I • R o COp ⊆ AOp o R
The first and last of these are just the standard initialisation and correctness conditions, respectively. The finalisation condition in fact places no further requirements with the trace embedding. The same is true for upwards simu- lations. We thus have the following conditions for the trace embedding.
Definition 3.6 [Trace simulations in Z]
Given Z data types A and C , the relation R on AState CState is a trace downward simulation from A to C if


∀ CState
CInit ⇒ ∃ AState
AInit	R
'	'

∀ i ∈ I • ∀ AState; CState; CState
R ∧ COpi ⇒ ∃ AState
R ∧ AOpi

The total relation T on AState	CState is a trace upward simulation from
A to C if


CInit ∧ T
AInit
'

∀ i : I • ∀ AState ; CState; CState •
(COpi ∧ T') ⇒ (∃ AState • T ∧ AOpi )

Completed trace preorder
Deﬁnition and testing scenario
Definition 3.7 σ ∈ Act ∗ is a completed trace of a process p if ∃ q • p −σ→ q and next (q ) = ∅. CT (p) denotes the set of completed traces of p. The completed trace preorder, ±ctr , is defined by p ±ctr q iff T (q ) ⊆ T (p) and CT (q ) ⊆ CT (p).

Testing scenario: Observations consist of a sequence of actions performed by the process in succession, that is, the interface is just a display which shows the name of the action that is currently carried out by the process, where the display becomes empty if deadlock occurs.
Relational embedding
Definition 3.8 [Completed trace embedding]
The Z data type (State, Init, Opi i∈I ) has the following completed trace em- bedding into the relational model.
G ==	, √
State == State
Init == {Init •∗ '→ θState'}
Op == {Op • θState '→ θState }
Fin == {State • θState '→ ∗} ∪ {State | (∀ i : I • ¬ pre Opi ) • θState '→	}
Here the global state has been augmented with an additional element √, which denotes that the given trace is complete (i.e., no operation is applicable).
Definition 3.9 The completed traces of a Z data type (State, Init, {Opi }i∈I ) are all sequences ⟨i1,..., in⟩ such that


∃ State' • Init o Opi
o ... o Opi
∧∀ i : I • ¬(pre Opi )

We denote the complete traces of an ADT A by CT (A).
Theorem 3.10 With the completed trace embedding, data reﬁnement corre- sponds to completed trace preorder. That is,
A ± C iff CT (C ) ⊆ CT (A) and T (C ) ⊆T (A)
Proof	1. Suppose that CT (C ) ⊆ CT (A) and T (C ) ⊆ T (A).	To show
A ± C we need pC ⊆ pA for all programs p. Given p, if p is not a trac√e of C

then pC = ∅, and thus the inclusion is trivial. Otherwise, either (∗,
(∗, ∗) are both in pC or just (∗, ∗) is in pC.
) and

√
Hence (∗, √) is in pA, and so is (∗, ∗). If just (∗, ∗) is in pC then p is a trace which is not a completed trace in C . Since T (C ) ⊆T (A), p is also a trace in
A. Hence (∗, ∗) is in pA.

2. Suppose A ± C .
Given p ∈ CT (C ). Thus (∗,
√) ∈ pC ⊆ pA, and hence p ∈ CT (A). For a

similar reason we also get trace inclusion. 

We can now extract the simulation rules that correspond to this notion of refinement.
Simulations
Given the completed trace embedding in the relational model, only the finali- sation is altered from the embedding given in Section 3.1. Thus we just have to consider the effect of the finalisation requirement:
Downward simulations: R o CFin ⊆ AFin is equivalent to
∀ AState; CState • R ∧∀ i : I • ¬ pre COpi ⇒ ∀ i : I • ¬ pre AOpi
Upward simulations: CFin ⊆ T o AFin is equivalent to
∀ CState • ∀ i : I • ¬ pre COpi ⇒ ∃ AState • T ∧∀ i : I • ¬ pre AOpi
We thus have the following conditions for the trace embedding.
Definition 3.11 [Completed trace simulations in Z]
Given Z data types A and C . The relation R on AState CState is a completed trace downward simulation from A to C if


∀ CState
CInit ⇒ ∃ AState
AInit	R
'	'

∀ i ∈ I • ∀ AState; CState; CState • R ∧ COpi ⇒ ∃ AState • R ∧ AOpi
∀ AState; CState • R ∧∀ i : I • ¬ pre COpi ⇒ ∀ i : I • ¬ pre AOpi
The total relation T on AState	CState is a completed trace upward sim- ulation from A to C if


AState ; CState
'
CInit ∧ T
AInit
'

∀ i ∈ I • ∀ AState ; CState; CState •
(COpi ∧ T') ⇒ (∃ AState • T ∧ AOpi )
∀ CState • ∀ i : I • ¬ pre COpi ⇒ ∃ AState • T ∧∀ i : I • ¬ pre AOpi
Failure preorder
Deﬁnition and testing scenario
The failures semantics records both the traces that a process can do, and also sets of actions which it can refuse, that is, actions which are not enabled. These are recorded as failures of a process.
Definition 3.12 (σ, X ) ∈ Act ∗ × P(Act ) is a failure of a process p if there is a process q such that p −σ→ q , and next (q ) ∩ X = ∅. F(p) denotes the set of failures of p. The failures preorder, ±f , is defined by p ±f q iff F(q ) ⊆ F(p).

Testing scenario: The machine for testing failures has, in addition to the interface of the completed trace machine, a switch for each action in Act . One can then observe which actions are blocked. If the process reaches a state where all actions are blocked, then this can be observed by an empty display. Observations are thus the failures of a process.
Relational embedding
This was covered in detail in [5,14,4], although we used an embedding into the totalised relational model there. Lemma 3 in [4] suggested this was not necessary:  appears as a possible outcome iff somewhere along the trace the next action of the trace could be refused. Thus, below we give a simpler embedding into the partial relations model.
Definition 3.13 [Failures embedding]
A Z data type (State, Init, {Opi i∈I ) in the refusals interpretation is embedded in the relational model as follows.
G == P I
State == State
Init == {Init ; E : P I • E '→ θState'}
Op == {Op • θState '→ θState }
Fin == {State; E : P I | (∀ i ∈ E • ¬ pre Opi ) • θState '→ E}
In the relational embedding failures are pairs (tr, X ), where tr is a trace, and there exists states (State, State')	tr (with State being initial) such that
'
∀ i : X • State /∈ dom Opi .
Theorem 3.14 With the failures embedding, data reﬁnement corresponds to the failures preorder. That is,
A ± C iff F(C ) ⊆ F(A)
The proof of this is an adaptation of that given in [14].	 

Simulations
Given the failures embedding the changes to the simulation conditions are as follows (these are derived in [14] - remember we have no input/output at this stage):
Downward simulations: R o CFin ⊆ AFin is equivalent to
∀ AState; CState • R ∧ pre AOpi ⇒ pre COpi

Upward simulations: CFin ⊆ T o AFin is equivalent to
∀ CState • ∃ AState • ∀ i : I • T ∧ (pre AOpi ⇒ pre COpi )

Failure trace preorder
Deﬁnition and testing scenario
The failure trace semantics considers refusal sets not only at the end of a trace, but also between each action in a trace.
Definition 3.15 σ ∈ (Act ∪ P Act )∗ is a failure trace of a process p if σ = X1a1X2a2 ... Xnan Xn+1 where a1a2 ... an is a trace of p and each (a1 ... ai , Xi+1) is a failure of p. FT (p) denotes the set of failure traces of p. The failures traces preorder, ±ftr , is defined by p ±ftr q iff FT (q ) ⊆ FT (p).
Testing scenario: The display in the machine for testing failures traces is the same as that for failures. However, it does not halt if the process cannot proceed, rather it idles until the observer allows one of the actions the process is ready to perform. The observations are traces with idle periods in between, and for each idle period the set of actions that are not blocked by the observer. It has been argued [19,20] that this is a better notion for testing than simply observing failures of a process, and is appropriate when one can detect that a process refuses an action, and if this is the case, one has the ability to
try another action.

Relational embedding
Definition 3.16 [Failure trace embedding]
A Z data type (State, Init, {Opi i∈I ) in the failure trace interpretation is em- bedded in the relational model as follows.
G == seq P I
State == seq P I × State
Init == {Init ; fs : seq P I • fs '→ (⟨ ⟩, θState )}
Op == {Op; fs : seq P I ; E : P I | (∀ i : E • ¬ pre Opi ) •
(fs, θState) '→ (fs - ⟨E⟩, θState')}
Fin == {State; fs : seq P I | (∀ i : E • ¬ pre Opi ) • (fs, θState) '→ fs}

In the relational embedding failures traces are the obvious generalisation of failures.

Theorem 3.17 With the failure traces embedding, data reﬁnement corre- sponds to the failure traces preorder. That is,
A ± C iff FT (C ) ⊆ FT (A)

Simulations
In the failure trace embedding, both the correctness and finalisation conditions are potentially amended due to the record of failures at each operation step.
Downward simulations: Here, in fact, the finalisation condition is sub-

sumed by the correctness, and R o COp
⊆ AOp
o R expands to the following

∀ AState; CState; CState • ∀ E •
R ∧ COpi ∧ Fcond (E, θCState') ⇒
∃ AState • R ∧ AOpi ∧ Fcond (E, θAState )
where Fcond (E, s) == ∀ i : E • ¬ ∃ Opi • s = θState.
Upward simulations: Similarly, COp o T ⊆ T o AOp expands to
∀ AState ; CState; CState • ∀ E •
(COpi ∧ T' ∧ Fcond (E, θCState')) ⇒
∃ AState • T ∧ AOpi ∧ Fcond (E, θAState )

Ready preorder
Deﬁnition and testing scenario
An alternative to the various failures semantics and preorders are semantics based upon acceptance sets, that is, semantics recording the actions a process is willing to engage in, rather than its refusal sets.
Definition 3.18 (σ, X ) ∈ Act ∗ × P(Act ) is a ready pair of a process p if there is a process q such that p −→ q , and next (q ) = X . R(p) denotes the set of ready pairs of p. The readiness preorder, ±r , is defined by p ±r q iff R(q ) ⊆ R(p).
Testing scenario: In the readiness semantics observations consist of a trace of a process or a trace together with the set of actions which the observation could have been extended with (if the observer had wished). The machine corresponding to this has a light for each action, which illuminate if the process is ready to engage with that action.

Relational embedding
The relational embedding is mostly as in the failures embedding, using the same global state and initialisation. However, rather than finalising to any set of events that may be refused, we now finalise to the set of events that must be accepted.
Definition 3.19 [Readiness embedding]
A Z data type (State, Init, {Opi i∈I ) in the readiness interpretation is embed- ded in the relational model as follows.
G == P I
State == State
Init == {Init ; E : P I • E '→ θState'}
Op == {Op • θState '→ θState }
Fin == {State • θState '→ {i ∈ I • pre Opi }}
Theorem 3.20 With the readiness embedding, data reﬁnement corresponds to the readiness preorder. That is,
A ± C iff R(C ) ⊆ R(A)
Proof  See [14]. 

Simulations
Given the readiness embedding the changes to the simulation conditions are as follows (these are derived in [14]):
Downward simulations: R o CFin ⊆ AFin is equivalent to
∀ AState; CState; i : I • R ⇒ pre COpi ⇔ pre AOpi
Upward simulations: CFin ⊆ T o AFin is equivalent to
∀ CState • ∃ AState • ∀ i : I • T ∧ (pre COpi ⇔ pre AOpi )
Ready trace preorder
The ready trace semantics is similar to the failure trace semantics, except ac- ceptance sets replace failures in the traces observed. The relational embedding is the same as that for the failure trace, except with the substitution of an appropriate acceptance set. Similar derivation can be made for the simulation rules.

Extension and conformance
Deﬁnition and testing scenario
Although not considered in [27], a number of alternative preorders for process algebras have been suggested motivated by testing and the need for test gen- eration. Specifically, in the context of testing from LOTOS specifications [6] these have included extension and conformance [10]. To define these formally we need the following notation which defines refusals sets after a particular trace.
Definition 3.21 [Refusals after a trace]
Let p be an LTS, σ a trace of p, and X ⊆ Act . Then p after σ ref X iff
∃ q • p −→ q and X ∩ next (q )= ∅

Testing scenario: Three definitions of refinement can be given on the basis of the idea behind Definition 3.21. These were motivated in [10,11] by considering that there might be a number of different notions of implementation:
implementation as a real/physical system
implementation as a (deterministic) reduction of a given specification
implementation as a (conforming) extension of a given specification
implementation as a refinement of a given specification
These are formalised [9] by, respectively, conformance, reduction, extension and testing equivalence. Reduction (also called the testing preorder [12]) in our context (of no divergence) is identical to the failures preorder. Testing equivalence is the equivalence induced by that preorder.
Conformance has the following characteristics: if p conf q then q dead- locks less often than p when in any environment whose traces are limited to those of q . Thus conformance restricts the quantification (of traces one must check refusals about) to be over the abstract specification (and this restriction gives rise to efficient test generation algorithms).
The extension preorder can be defined as conformance together with the additional property that traces can be extended. Thus, if p  ext q then q has at least the same traces as p, but in an environment whose traces are limited to those of p, it deadlocks less often. The equivalence induced by extension is the same as that by reduction (that is, testing equivalence). Leduc [21] documents the relationship between these relations in some detail. They can be defined as follows.
Definition 3.22 [Reduction, conformance, and extension]

Let p, q be LTSs. Then
p ±red q iff ∀ σ : Act ∗; X ⊆ Act • q after σ ref X implies p after σ ref X
p ±conf q iff ∀ σ : T (p); X ⊆ Act • q after σ ref X implies p after σ ref X p ±ext q iff
T (p) ⊆T (q ) and
∀ σ : T (p); X ⊆ Act • q after σ ref X implies p after σ ref X
Relational embedding
The relational embedding we use to model extension is, in fact, a totalisation over the space of partial relations, and is the standard non-blocking model (e.g., as discussed in [15]), that is, we use the same construction to record the effect of extension in a blocking model as we did to record failures in a non-blocking model.
Definition 3.23 [Extension embedding]
A Z data type (State, Init, {Opi i∈I ) in the extension interpretation is embed- ded in the relational model as follows.
G == P I ∪ {⊥}
State == State ∪ {⊥}
Init == {Init ; E : P I • E '→ θState'}
Op == OpB ∪ {x, y : State | x /∈ dom OpB • (x, y)} where OpB == {Op • θState '→ θState'}
Fin == {State; E : P I | (∀ i : E • ¬ pre Opi ) • θState '→ E}∪ {(⊥, ⊥)}
Theorem 3.24 With the extension embedding, data reﬁnement corresponds to the extension preorder. That is,
A ± C iff
T (A) ⊆T (C ) and ∀ σ ∈T (A) ∩T (C );
X ⊆ Act • C after σ ref X implies A after σ ref X
Proof	1. Suppose that	(A)	(C ) and	σ	(A)	(C ); X	Act C after σ ref X implies A after σ ref X .
Given (g, E ) ∈ pC then tr ∈T (C ). Either tr ∈T (A) in which case refusal inclusion gives us (g, E ) ∈ pA or tr /∈ T (A) in which case the non-blocking totalisation gives (g, E ), (g, ⊥) ∈ pA.

2. Suppose A C . Then trace inclusion can be proved by induction over the length of the trace, and refusals subsetting follows as a consequence of using the non-blocking totalisation. 
Whilst we have found an embedding such that data refinement induces ex- tension, this is not possible for conformance. This is because conformance is not a preorder (see any of the references given above), but data refinement is a preorder. Thus no combinations of embeddings as a data refinement theory will produce an embedding equivalent to it. Intuitively this is because the quantification over programs, and the subsetting of program behaviour con- tains at its very heart an embedding of trace inclusion. However, conformance makes no requirement about trace inclusion, from either the concrete to the abstract or vice versa, and is just concerned with refusals, and hence cannot be modeled this way.
Simulations
The use of the non-blocking totalisation for modelling extension means we can extract simulation conditions by reference to above results. They are thus the following.
Definition 3.25 [Extension downward simulation in Z]
Given Z data types A and C . The relation R on AState CState is a extension downward simulation from A to C if
∀ CState' • CInit ⇒∃ AState' • AInit ∧ R'
∀ i : I •∀ AState; CState • pre AOpi ∧ R ⇒ pre COpi
∀ i : I •∀ AState; CState; CState' • pre AOpi ∧ R ∧ COpi ⇒∃ AState' • R' ∧ AOpi
Definition 3.26 [Extension upward simulation in Z]
Given Z data types A C . The total relation T on AState	CState is an
extension upward simulation from A to C if
∀ AState ; CState • CInit ∧ T ⇒ AInit
∀ CState • ∃ AState • ∀ i : I • T ∧ (pre AOpi ⇒ pre COpi )
∀ i : I • ∀ AState ; CState; CState •
(COpi ∧ T') ⇒ (∃ AState • T ∧ (pre AOpi ⇒ AOpi ))
Note the symmetry: failure-divergence for the non-blocking model is extension for the blocking model.
Conclusions
In this paper we have derived simulations for relational embeddings of a num- ber of refinement preorders found in process algebras.

Although downward and upward simulations (Definitions 4 and 5) are com- plete, their totalised versions are not. However, complete simulations can be given for each semantics, e.g. the failures semantics simulations are known to be complete. A separate completeness proof for simulations is needed in each embedding, this waits for an extended version of this paper.

References
Abrial, J.-R., D. Cansell and D. M´ery, Reﬁnement and reachability in eventb, in: H. Treharne,
S. King, M. C. Henson and S. A. Schneider, editors, ZB, Lecture Notes in Computer Science
3455 (2005), pp. 222–241.
Bergstra, J. A., A. Ponse and S. A. Smolka, editors, “Handbook of Process Algebra,” Elsevier Science Inc., New York, NY, USA, 2001.
Boiten, E. and J. Derrick, Incompleteness of relational simulations in the blocking paradigm
(2008), submitted for publication.
Boiten, E., J. Derrick and G. Schellhorn, Relational concurrent reﬁnement II: Internal operations and outputs, Formal Aspects of Computing Accepted for publication.
URL http://www.cs.kent.ac.uk/pubs/2007/2633

Boiten, E. A. and J. Derrick, Unifying concurrent and relational reﬁnement, ENTCS 70 (2002), proceedings REFINE’02, Editors: J. Derrick, E. A. Boiten, J. von Wright and J. C. P. Woodcock.
Bolognesi, T. and E. Brinksma, Introduction to the ISO Speciﬁcation Language LOTOS, Computer Networks and ISDN Systems 14 (1988), pp. 25–59.
Bolton, C. and J. Davies, Reﬁnement in Object-Z and CSP, in: M. Butler, L. Petre and K. Sere, editors, Integrated Formal Methods (IFM 2002), Lecture Notes in Computer Science 2335 (2002), pp. 225–244.
Bolton, C. and J. Davies, A singleton failures semantics for Communicating Sequential Processes, Formal Aspects of Computing 18 (2006), pp. 181–210.
Brinksma, E., A theory for the derivation of tests, in: S. Aggarwal and K. Sabnani, editors,
Protocol Speciﬁcation, Testing and Veriﬁcation, VIII (1988), pp. 63–74.
Brinksma, E. and G. Scollo, Formal notions of implementation and conformance in LOTOS, Technical Report INF-86-13, Dept of Informatics, Twente University of Technology (1986).
Brinksma, E., G. Scollo and C. Steenbergen, Process speciﬁcation, their implementation and their tests, in: B. Sarikaya and G. v. Bochmann, editors, Protocol Speciﬁcation, Testing and Veriﬁcation, VI (1986), pp. 349–360.
de Nicola, R., Extensional equivalences for transition systems, Acta Informatica 24 (1987),
pp. 211–237.
de Roever, W.-P. and K. Engelhardt, “Data Refinement: Model-Oriented Proof Methods and their Comparison,” CUP, 1998.
Derrick, J. and E. Boiten, Relational concurrent reﬁnement, Formal Aspects of Computing 15
(2003), pp. 182–214.
Derrick, J. and E. A. Boiten, “Refinement in Z and Object-Z,” Springer-Verlag, 2001.
He Jifeng and C. A. R. Hoare, Prespeciﬁcation and data reﬁnement, in: Data Reﬁnement in a Categorical Setting, Technical Monograph, number PRG-90, Oxford University Computing Laboratory, 1990 .

He Jifeng, C. A. R. Hoare and J. W. Sanders, Data reﬁnement reﬁned, in: B. Robinet and
R. Wilhelm, editors, Proc. ESOP 86, Lecture Notes in Computer Science 213 (1986), pp. 187–196.
Hoare, C. A. R., “Communicating Sequential Processes,” Prentice Hall, 1985.
Langerak, R., A testing theory for LOTOS using deadlock detection, in: Protocol Speciﬁcation Testing and Veriﬁcation IX (1989), pp. 87–98.
Langerak, R., “Transformations and Semantics for LOTOS,” Ph.D. thesis, University of Twente, The Netherlands (1992).
Leduc, G., “On the Role of Implementation Relations in the Design of Distributed Systems using LOTOS,” Ph.D. thesis, University of Li`ege, Li`ege, Belgium (1991).
Milner, R., “Communication and Concurrency,” Prentice-Hall, 1989.
Reeves, S. and D. Streader, Data reﬁnement and singleton failures reﬁnement are not equivalent, Formal Aspects of Computing Accepted for publication.
Roscoe, A., “The Theory and Practice of Concurrency,” International Series in Computer Science, Prentice Hall, 1998.
van Glabbeek, R., The linear time – branching time spectrum II; the semantics of sequential systems with silent moves (extended abstract), in: E. Best, editor, Proceedings CONCUR’93, 4th
International Conference on Concurrency Theory, Hildesheim, Germany, August 1993, Lecture Notes in Computer Science 715 (1993), pp. 66–81.
van Glabbeek, R. J., The linear time - branching time spectrum, in: J. C. M. Baeten and J. W. Klop, editors, CONCUR 90, Lecture Notes in Computer Science 458 (1990), pp. 278–297.
van Glabbeek, R. J., The linear time - branching time spectrum I. The semantics of concrete sequential processes, in: J. Bergstra, A. Ponse and S. Smolka, editors, Handbook of Process Algebra, North-Holland, 2001 pp. 3–99.
Woodcock, J. C. P. and J. Davies, “Using Z: Specification, Refinement, and Proof,” Prentice Hall, 1996.
