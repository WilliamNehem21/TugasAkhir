

Electronic Notes in Theoretical Computer Science 229 (5) (2011) 135–157
www.elsevier.com/locate/entcs

The Recursion Scheme from the Cofree Recursive Comonad
Tarmo Uustalu1
Institute of Cybernetics at Tallinn University of Technology, Akadeemia tee 21, EE-12618 Tallinn, Estonia
Varmo Vene2
Dept. of Computer Science, University of Tartu,
J. Liivi 2, EE-50409 Tartu, Estonia

Abstract
We instantiate the general comonad-based construction of recursion schemes for the initial algebra of a functor F to the cofree recursive comonad on F . Differently from the scheme based on the cofree comonad on F in a similar fashion, this scheme allows not only recursive calls on elements structurally smaller than the given argument, but also subsidiary recursions. We develop a Mendler formulation of the scheme via a generalized Yoneda lemma for initial algebras involving strong dinaturality and hint a relation to circular proofs a` la Cockett, Santocanale.
Keywords: structured recursion, comonad-based recursion, cofree comonads, cofree recursive comonads, Mendler recursion, circular proofs


Introduction
In this paper, we are interested in structured recursion schemes for initial algebras. These are a central tool for programming with inductive types in total functional programming languages like Charity of Cockett [8] or type-theoretically inspired dependently typed languages.
We have previously [36] developed a general structured recursion scheme that, for the initial algebra of a functor F , is parameterized by a comonad and a dis- tributive law of the functor F over the comonad. We have also [34] demonstrated a technique for casting conventional-style structured recursion schemes into a format with similarities to general recursion that makes them convenient for programming

1 Email: tarmo@cs.ioc.ee
2 Email: varmo@cs.ut.ee

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.02.020

while maintaining the beneficial totality guarantee. Originating from Mendler [19], this format is known as Mendler-style recursion, but has also been promoted under the name of ‘type-based termination’. The idea is to control the manipulation of data within a recursion by polymorphic typing. Our approach to Mendler recursion is a cute simple application of the Yoneda lemma and its variants.
One instance of the comonad-based scheme arises from the cofree comonad on F , sending an object A to the cofree F -algebra on A, i.e., the final A n F -coalgebra where (A n F )X =df A × FX. This gives course-of-value iteration, the recursion scheme where recursive calls can be made not only on the predecessor of the given argument but on all structurally smaller values. A related comonad is the cofree recursive comonad on F , delivering initial A n F -algebras. One could ask: Does this comonad also yield a recursion scheme?
In this paper, we answer exactly this question in the affirmative. There is indeed a canonical distributive law of F over the cofree recursive comonad on F and hence a recursion scheme is obtained. What is more, the cofree recursive comonad forms, despite being a little more technical, in a certain sense a more natural basis for a recursion scheme than the cofree comonad. The recursion scheme from the cofree recursive comonad supports subsidiary recursions on the predecessors of the given argument. It also admits a tenable Mendler-style formulation and becomes in that format a useful tool for devising categorical semantic descriptions for circular sequent versions of typed lambda-calculi that Cockett [7] and Santocanale [24] have studied as possible cores for total functional programming languages.
In this paper we study the new recursion scheme foremostly as an instance of comonad-based recursion and of the technique of deriving Mendler-style recursion schemes from conventional-style schemes. discussing the rather technical application to circular proofs only tangentially. This will be the subject of a separate paper with Cockett.
The paper is organized as follows. In Section 2, we first review the comonad- based recursion scheme [36] and especially its instantiation to cofree comonads, including course-of-value iteration. Then we continue with the Yoneda lemma, to- gether with a generalized version for final coalgebras, and Mendler-style recursion. In Section 3, we proceed to the instance arising when the cofree comonad is re- placed with the cofree recursive comonad. In Section 4, we comment on a Haskell implementation of the combinators. The connection of the Mendler-style scheme to circular proofs is explained in Section 5. Following an orientation about related work in Section 6 we conclude with final remarks in Section 7.
Structured recursion schemes for initial algebras
Recursion schemes from comonads
We start by reviewing structured recursion for initial algebras of functors (inductive types).
Let F be an endofunctor (typically, a polynomial functor representing a sig- nature) on a category C (typically a category with finite products, finite coprod-

ucts and possibly exponents, as well as with initial algebras and final coalgebras of functors of interest to us; we think of Set). We are interested in the initial F -algebra, which we denote (μF, inF ). Lambek’s lemma states that the algebra structure inF : F (μF ) → μF (which we think of as the constructor of the inductive type) is an isomorphism.
The primary function definition principle associated to the initial F -algebra is the recursion scheme of iteration (a.k.a. fold ), which is exactly its initiality: for any F -algebra (C, φ), there exists a unique F -algebra map f : (μF, inF ) → (C, φ), i.e., a unique map μF → C, satisfying

F (μF )  inF	/μF/
Ff	f
J	J 

FC	φ
/C/


We denote this map f by iterF (φ). It is useful to think that f is defined here as the composition of an analysis of the given argument of interest into its predecessors 3 (in−1), recursive calls of f on these predecessors (Ff ) and assembling the result (φ). A number of further structured recursion principles are consequences of iteration.
We [36] have shown (and Bartels [3] did the same independently for the dual situation of final coalgebras) that a wide variety of them are instances of general scheme parameterized by a comonad D = (D, ε, δ) and a distributive law κ of the functor F over it. The idea is that call trees would have FD rather than F as the branching factor.
Specifically, comonad-based recursion says this: Given a comonad D and a dis- tributive law κ of F over D, for any FD-algebra (C, φ), there exists a unique map f : μF → C (denoted comrecF (κ, φ)), satisfying


F (μF )
Fι J 
FD(μF )
FDf J 

inF
/μF/

f
J 

FDC 	/C/
φ

where ι =df iterF (DinF ◦ κμF ): μF → D(μF ) turns out to be a coalgebra structure of not only the functor D but also the comonad D. The map defined by the scheme is constructible as the postcomposition of an ordinary iteration with the counit. We have
comrecF (κ, φ)= εC ◦ iterF (Dφ ◦ κDC ◦ FδC)


3 Viewing elements of μF as wellfounded F -branching trees, these would be the immediate subtrees of the given tree.

or, diagrammatically,
F (μF ) 	inF	/μF/

Fg 
J 	//		//
g
	/J  f

FDC F δC
FDDC κDC
DFDC  Dφ
D/C
εC
J, 7
C

Two important special cases covered by comonad-based recursion are primitive recursion and course-of-value iteration.
Primitive recursion (allowing direct use of the predecessors of the given argu- ment) states that, for any object C and map φ : F (C × μF ) → C, there is a unique map f (denoted recF (φ)) satisfying
F (μF )   inF	/μF/
F⟨f,idμF ⟩	f
J	J 

F (C × μF )
/C/
φ

Primitive recursion is recovered from comonad-based recursion by taking DA =df A × μF , κA =df ⟨F fst, inF ◦ F snd⟩ : F (A × μF ) → FA × μF . As a result, ι = ⟨idμF , idμF ⟩ : μF → μF × μF and Df ◦ ι = ⟨f, idμF ⟩ : μF → C × μF .
A slightly more general scheme (supporting simultaneity with an independent iteration) is obtained by choosing DA =df A×E where (E, χ) is any F -algebra and κA =df ⟨F fst,χ ◦ F snd⟩ : F (A × E) → FA × E. In this case ι = ⟨idμF , iterF (χ)⟩ : μF → μF × E and Df ◦ ι = ⟨f, iterF (χ)⟩ : μF → C × E. Primitive recursion corresponds to the instance (E, χ) =df (μF, inF ).
Course-of-value iteration is the scheme that allows recursive calls on not only the predecessors of the given argument, but on all structurally smaller elements. For an object A and functor H, let A n H denote the functor defined by (A n H)X =df A × HX. The scheme says this: Any object C and map φ : F (ν(C n F )) → C defines a unique map f : μF → C (denoted cviterF (φ)) satisfying
F (μF ) 	inF	/μF/
F (coitCuF (⟨f,in−1⟩))	f
J	J 

F (ν(C n F ))
/C/
φ

The map φ has access to recursive call results for all elements structurally smaller than the given argument. These are stored in a tree-like datastructure of the same shape as the argument (essentially a labelled copy of the argument), except that, by its type, this tree is not guaranteed to be wellfounded.
This scheme is obtained from the cofree comonad on F and the canonical dis- tributive law of F over it.

We look first at a more general version involving the cofree comonad on any functor.
The cofree comonad on a functor H is carried by the functor that sends an object A to the final A n H-coalgebra. We define DA =df ν(A n H), εA =df fst ◦ outAnH : DA → A, θA =df snd ◦ outAnH : DA → HDA.
Further, we use coiteration (finality) to define δA =df coitDAnH (⟨idDA, θA⟩) : 
DA → DDA, so δA is a unique map f satisfying
DA 	θA  /H/DA

f
J 
DA ¸, 
Hf
//J 

εDA DDA
θDA HDDA


The cofree comonad is given by the data (D, ε, δ), constituting a comonad, and the
natural transformation σ : D →.  H defined by σA =df HεA ◦ θA : DA → HA.
Distributive laws of F over D are in a natural bijection with natural transfor-
mations FD →.  HF . The distributive law λ¯ of F over D induced by a natural
transformation λ : FD →. HF is defined by λ¯A =df coitF AnH (⟨F εA, λDA ◦ FδA⟩): 
FDA → DFA, so λ¯A is a unique map f satisfying
FDA   F δA /F/DDA  λDA /H/F DA

f
J 
εFA  DFA 




θFA 
Hf
J 
HDF A



Given a functor H together with a natural transformation λ : FD →.
can instantiate the general scheme with κ =df λ¯.
HF , we

Course-of-value iteration is given by the special case HA =df F A, λA =df
FσA : FDA → FF A. In this situation ι = coitμF nF (⟨idμF , in−1⟩) where in−1 =df
F	F
iterF (F inF ): μF → F (μF ) is the inverse of inF .
Slightly more generally one can use a general functor H equipped with a natural
transformation χ : FH →. HF , as this gives a natural transformation λ : FD →. HF
via λX = χX ◦ FσX . In this case ι = coitμF nH (⟨idμF , iterF (HinF ◦ χμF )⟩).
Generalized primitive recursion is a degenerate case where HA =df E in which
case a natural transformation χ : FH →. HF becomes an algebra structure FE →
E.
Another special case is course-of-value primitive recursion, arising from HA =df
μF × F A, χA =df ⟨inF ◦ F fst,F snd⟩ : F (μF × F A) → μF × FF A.

A Yoneda lemma for ﬁnal coalgebras
Next we proceed to the contravariant Yoneda lemma. Below we will reformulate our recursion schemes relying on this important fact, but we also need a generalization. The Yoneda lemma states this: For any functor K : Cop → Set and object

C ∈ |C|, there is an isomorphism
iK,C : [Cop, Set](C(−, C), K−) → KC
natural in K and C 4 . The isomorphism is defined by iK,C(Θ) =df ΘC idC and its

inverse by i−1
(x)(f ) =df Kf (x). An important special case (of the Yoneda embed-

ding ) is K =df C(−, D) establishing an isomorphism [Cop, Set](C(−, C), C(−, D)) → C(C, D).
It is not unnatural to ask whether the Yoneda lemma generalizes in any inter- esting way to mixed-variant hom-functors. The answer turns out to be positive: there is a generalization and it will be very useful for us. Curiously, we have not come across it in the literature in this explicit form 5 , but it is intimately related to the fact that the final F -coalgebra is the (big!) colimit of the F -coalgebra structure forgetting functor.
To present the generalized Yoneda lemma we must first digress to introduce strong (a.k.a. Barr) dinatural transformations [21].

Let H, K : Cop ×C → D be functors. A dinatural transformation H →..
K is a

family of maps ΘX : H(X, X) → K(X, X) in D for all objects X in C such that, for any map f : X → Y in C, the following hexagon commutes:
H(X, X) 	ΘX	/K/(X, X)

H(f,X)  ¸
H(Y, X)
	//
K(X,f )
z_
_K¸(X, Y )
K(f,Y )

H(Y, Y )	ΘY
K(Y, Y )

A strongly dinatural transformation is also a family of maps ΘX : H(X, X) → K(X, X) in D for all objects X in C, but the coherence condition is that, for any map f : X → Y in C, object W and maps p0 : W → H(X, X), p1 : W → H(Y, Y ) in D, if the square in the following diagram commutes, then so does the hexagon:
H(X, X) 	ΘX	/K/(X, X)

H(X,f )
z_
W	_H¸(X, Y )	⇒
K(X,f )
z_
_K¸(X, Y )

z_
H(Y, Y )
H(f,Y )
ΘY
/K/(Y, Y )
K(f,Y )

Differently from the case of ordinary (Dubuc-Street) dinaturals [11], strong di- naturals compose unproblematically. We denote by SDinat(C, D) the category of mixed-variant functors Cop ×C → D and strong dinatural transformations between them. (As a downside, however, D being Cartesian closed does not imply that so is SDinat(C, D).)

4 This is ignoring the issue that we cannot know the domain to actually be a set before having established that it is isomorphic to the codomain, about which we assume this.
5 (however see our old NWPT ’00 slides [31] as well as the recent discussion in the Types mailinglist [17])

We are now ready to introduce the generalized contravariant Yoneda lemma:
For any functors K : Cop → Set and H : C → C, there is an isomorphism
iK,H : SDinat(C, Set)(C(−,H+), K−) → K(νH)
natural in K and H. This isomorphism is defined by iK,H (Θ) =df ΘνH outH and its

inverse by i−1
(x)C(φ) =df K(coitH (φ))(x). Unwinding the definition, we learn that

a family of maps ΘX : C(X, HX) → KX for any X is strongly dinatural if, for any f : X → Y , φ : X → HX, ψ : Y → HY , the condition Hf ◦φ = ψ ◦f (of f being an H-coalgebra map) implies ΘXφ = Kf (ΘY ψ). To verify that iK,H is an isomorphism

indeed, we convince ourselves that i−1
(iK,H (Θ))X (φ)= K(coitH (φ))(ΘνH outH )= 

ΘX φ (using that Θ is strongly dinatural and outH ◦ coitH (φ)= HcoitH (φ) ◦ φ) and

iK,H (i−1
(x)) = K(coitH (outH ))(x)= KidνH (x)= idK(νH)(x)= x.

The specific choice K  =df  C(−, D) gives an isomorphism SDinat(C, Set)(C(−,H+), C(−, D)) → C(νH, D).
Note that the standard Yoneda lemma is recovered from the generalization by specializing for HX =df C (with the effect that νH = C, outH = idC, coitH (f )= f ).

Mendler-style recursion
The Yoneda lemma allows us to shape recursion schemes in the style of Mendler [19]. The idea is to go higher-order, so a recursion can be specified in terms of a transfor- mation of functions to functions rather than (potential) function results to function results, and to use polymorphic typing to prohibit unwanted data manipulations that might otherwise become possible.
Recall that conventional-style iteration says that, for any F -algebra (C, φ) (i.e., an object C and map φ : FC → C), there is a unique map f satisfying f ◦ inF = φ ◦ Ff . Picking K =df C(F−, C), we learn from the Yoneda lemma that maps
FC → C are in natural bijection with natural transformations C(−, C) →.  C(F−, C).
The Mendler-style formulation of iteration is based on exactly this observation. It says: For any object C and natural transformation Φ : C(−, C) → C(F−, C), there is a unique map f : μF → C (denoted miterF (Φ)) satisfying
f ◦ inF = ΦμF f

The two formats are interchangeable: miterF (Φ) = iterF (ΦidC) and iterF (φ) = miterF (Φ) where ΦY f =df φ ◦ Ff for f : Y → C. For intuition, it is useful to think of Φ as an operation sending any approximation of f capable of handling the predecessors of the given argument of interest to an improved approximation of f that can also handle this argument (all this without actually looking at the predecessors).
For general comonad-based recursion, a similar reformulation is possible: Given a comonad D and a distributive law κ of F over D, for any object C and natural
transformation Φ : C(−, DC) →.  C(F−, C), we have a unique map f : μF → C

(denoted mcomiterF (κ, Φ)) satisfying
f ◦ inF = ΦμF (Df ◦ ι) where ι =df iterF (DinF ◦ κμF ): μF → D(μF ).
For a scheme of this generality a Mendler-style formulation is not particularly advantageous over the conventional formulation. In specific cases, however, consid- erably more specialized Mendler-style formulations are possible.
In the case of primitive recursion, we can take advantage of the natural isomor- phism C(C, A0) × C(C, A1) ∼= C(C, A0 × A1) to arrive at the following formulation:

For any object C and natural transformation Φ : C(−, C) × C(−, μF ) →. we have a unique map f : μF → C (denoted mrecF (Φ)) satisfying
f ◦ inF = ΦμF (f, idμF )
C(F−, C),

In the case of course-of-value iteration we can additionally apply the general- ized Yoneda lemma of the previous subsection for final coalgebras. It tells us that the maps F (ν(C n F )) → C are in a natural bijection with the strong dinatural
transformations C(−,C ×F +) →..  C(F−, C). We get: Any object C and strongly di-
natural transformation Φ : C(−, C)×C(−,F +) →..  C(F−, C) define a unique solution
f : μF → C to the equation
f ◦ inF = ΦμF (f, in−1)
Notice that products, pairing, final coalgebras and coiteration of the category C are absent in the reformulated scheme. They disappeared in the “refunctionalization” due to the Yoneda lemmas. Hence, especially with this scheme, the Mendler-style format is lighter than the conventional formulation in the sense that it does not work with a type of trees to record recursive call results.

The scheme from the cofree recursive comonad
Cofree recursive comonads
Recursive comonads, dualizing the completely iterative monads of Aczel, Ad´amek et al. [2,20], are comonads D ∼= Id × D0 supporting unique solvability of guarded equations of a certain kind.
While the cofree comonad on H is given by the final coalgebras of the functors A n H for all objects A, the cofree recursive comonad on H is defined by the initial algebras instead.
Let us look at the data of this comonad. For convenience, we rely on the iso- morphism μ(A n H) ∼= A × μ(H(A n Id)). We define DA =df A × μ(H(A n Id)),

εA =df fst : DA → A, θA =df in−1
snd : DA → HDA. Further, we let

δA =df ⟨idDA, recH(AnId)(inH(DAnId) ◦H⟨⟨fst, snd◦snd⟩, fst◦snd⟩)◦snd⟩ : DA → DDA.

It is not hard to verify that δA is a unique map f satisfying
DA 	θA  /H/DA

f
J 
DA ¸, 
Hf
//J 

εDA DDA
θDA HDDA

This condition was the defining (coiteration) description for δA in the case of the cofree comonad. In our new situation it is a derived characterization.
The comonad is given by the data (D, ε, δ).	The cofreeness as a recursive
comonad also involves σ : D →. H defined by σA =df HεA ◦ θA.
Differently from the cofree comonad case, we can no more get a distributive law of
F over D from any natural transformation FD →.  HF . But a canonical distributive
law κ of F over D still exists, if D is the cofree recursive comonad on H =df F . It is defined by κA =df ⟨F fst, inF (FAnId) ◦F (iterF (AnId)(⟨F fst, inF (FAnId) ◦F snd⟩) ◦ snd)⟩ : FDA → DFA. With some effort one can check that κA is a unique solution in f of the equation system
FDA  FθA /F/F DA

f
J 
εFA  DFA 




θFA 
Ff 
J 
FDFA 

which is the same condition that defines κA by coiteration, if D is the cofree comonad on F .

The recursion scheme, basic version
Given the existence of a distributive law κ of F over the cofree recursive comonad D on F , we can instantiate the comonad-based recursion scheme with these D and κ.
To do so, we have to work out the coalgebra structure ι : μF → D(μF ). Gen- erally, ι =df iterF (DinF ◦ κμF ): μF → D(μF ). A calculation demonstrates that a simpler expression for our particular choice of D and κ is ι = ⟨idμF , recF (inF (CnId) ◦ F⟨snd, fst⟩)⟩. As a result, for f : μF → C, Df◦ι = ⟨f, recF (inF (CnId) ◦F⟨f◦snd, fst⟩)⟩ Summing up, we have established this scheme: For any object C and map
φ : F (C × μ(F (C n Id))) → C, there exists a unique map f : μF → C (we denote it iterxF (φ)) satisfying
F (μF ) 	inF	/μF/
F⟨f,recF (inF (CuId)◦F⟨f◦snd,fst⟩)⟩	f
J	J 

F (C × μ(F (C n Id))
/C/
φ

From the general reduction of comonad-based recursion to iteration we can conclude,

after simplifications, that

iterxF (φ)= fst ◦ iterF (⟨φ, inF (CnId)⟩)

What is the practical meaning of this scheme? On the surface it is very simi- lar to course-of-value iteration: the map φ assembling the result of f on the given argument operates on a tree-like datastructure with recursive call results for all structurally smaller elements. But now the datastructure comes with a wellfound- edness guarantee, in fact it is a labelled copy of the parsed version of the given argument. How can this be used? Is there any difference from course-of-value itera- tion? Intuitively, if the datastructure is wellfounded, one can induct on it. Exactly this is also the potential of the intermediate datastructure here. The scheme shown allows recursions on the intermediate datastructure, which really mean subsidiary (inner) recursions on the predecessors of the given argument, with access to the results of the main (outer) recursion. The Mendler-style formulation to follow in the next subsection will make this very evident.
In the light of the above reflection, it is not surprising that the new scheme sub- sumes both primitive recursion (from labelled copies of the predecessors of the given argument one should well be able to extract these predecessors) and course-of-value iteration. Using the natural transformations rA =df idA × iterF (AnId)(inF ◦ F snd): 

A × μ(F (A n Id)) → A × μF and sA =df out−1
(idA × iterF (AnId)(F out−1
)) :

A × μ(F (A n Id)) → ν(A n F ) we recover: recF (φ) = iterxF (φ ◦ FrC) (for φ :
F (C × μF ) → C) and cviterF (φ)= iterxF (φ ◦ FsC) (for φ : F (ν(C n F )) → C).

Mendler version of the scheme
The generalized contravariant Yoneda lemma for final coalgebras dualizes into a generalized covariant Yoneda lemma for initial algebras: For any functors K : C → Set and H : C → C, there is an isomorphism

iK,H : SDinat(C, Set)(C(H−, +), K+) → K(μH)

natural in K and H.
But a Mendler version of the recursion scheme from the cofree recursive comonad is not obtained as simply as in the case of the cofree comonad. Simply applying the generalized covariant Yoneda lemma for initial algebras is not possible, as the occurrence of μ(F (C n Id)) in the expression C(F (C × μ(F (C n Id))), C) is con- travariant.
Instead, we must first use the contravariant Yoneda lemma and then proceed with the generalized covariant Yoneda lemma for initial algebras, and finally ap- ply the contravariant Yoneda lemma once again. We get the following chain of isomorphisms:

C(F (C × μ(F (C n Id))), C)
∼= [Cop, Set]Y (C(Y, C × μ(F (C n Id))), C(FY, C))
∼= [Cop, Set]Y (C(Y, C) × C(Y, μ(F (C n Id))), C(FY, C))
∼= [Cop, Set]Y (C(Y, C)
j	j	j
×SDinat(C, Set)C′ ,C′ (C(F (C × C—), C+), C(Y, C+)), C(FY, C))

−  +
∼= [Cop, Set]Y (C(Y, C)
×SDinat(C, Set)C′ ,C′ ([Cop

∼= [Cop, Set]Y (C(Y, C)

, Set]Y ′ (C(Y

j,C × Cj ), C(FY j, Cj )), C(Y, Cj )),
C(FY, C))

op	j	j	j	j	j	j
×SDinat(C, Set)C′ ,C′ ([C  , Set]Y ′ (C(Y , C) × C(Y , C—), C(FY , C+)), C(Y, C+)),
−  +
C(FY, C))
One can now check that the recursion scheme of the previous subsection implies the following Mendler-style scheme: Any object C and natural transformation

Φ: [Cop, Set]Y (C(Y, C)
×SDinat(C, Set)C′ ,C′ ([Cop, Set]Y ′ (C(Y j, C) × C(Y j, Cj ), C(FY j, Cj )), C(Y, Cj )),

−  +	—
+	+
C(FY, C))

define a unique map f : μF → C, which we denote miter2F (Φ), satisfying
f ◦ inF = ΦμF (f, updateμF (mrecF ,f )) where updateY takes a natural transformation


op	j	j	j
j	j	..	j

Θ: [C
, Set]Y ′ (C(Y , C—) × C(Y
, μF ), C(FY , C+)) →C′ ,C′ C(Y, C+)

−  +
and a map g : μF → C and sends them to a natural transformation


op	j
j	j	j	j	..	j

updateY (Θ, g): [C
, Set]Y ′ (C(Y
, C) × C(Y
, C—), C(FY , C+)) →C′ ,C′ C(Y, C+)

−  +
in the expectable way.
We see that the result of f can depend on the results of recursive calls of f on the predecessors of the given argument of interest plus a “local, enhanced iterator” on these predecessors that, in addition to what the normal iterator can do, gains access to f (in the course of iteration) on all structurally smaller elements.
In principle, it is possible to modify the scheme so that subsidiary recursions can be according to more sophisticated schemes than iteration (even according to the main scheme itself). We will not discuss this here, as the version we have just shown is higher-order enough to confuse. We advise the reader to check the Haskell implementation that we will comment next.

A Haskell implementation
To illustrate the mechanics of the schemes, it is useful to show some programs. We accompany this paper by a Haskell implementation, with some examples of uses, of all combinators discussed in the previous sections. For most of them, we show several alternative definitions, corresponding, besides the basic computation rule (the recursion equation), also to encodings in terms of other combinators etc. The implementation is available at http://cs.ioc.ee/~tarmo/haskell/msfp08/.
Some remarks are in order. First, we use Haskell only as a demonstration (for
the lack of a better alternative for our purposes). Haskell is not a total functional language. We work in a safe corner where we have set up some basic infrastruc- ture for initial algebras and final coalgebras and we program with them confining ourselves to just this infrastructure (avoiding confusing initial algebras and final coalgebras, using general recursion etc.). Second, Haskell has no mechanisms for enforcing functor and comonad laws etc. Likewise we ignore the question of when strong dinaturality is free.
As the code uses rank-n type signatures, it only runs with GHC, with the
-fglasgow-exts option. Some ugliness (bureaucratic constructors/destructors) in the code is due to the fact that lambda-abstraction is not available for type constructors and a type constructor is not automatically a datatype constructor.
Here are some comments on the code. Inductive types and iteration in the conventional format are introduced via a recursive datatype and a general-recursive function definition describing how iteration computes.
newtype Mu f = In {ini :: f (Mu f)}
iter :: Functor f => (f c -> c) -> Mu f -> c iter phi (In x) = phi (fmap (iter phi) x)
To define comonad-based recursion, we first introduce a type-constructor class of comonads with member functions for the counit and comultiplication, by subclassing from the Prelude-defined class of functors.
class Functor d => Comonad d where counit :: d a -> a
comult :: d a -> d (d a)
Likewise, distributive laws of functors over comonads are defined as a multi-parameter class.
class (Functor f, Comonad d) => Dist d f where dist :: f (d a) -> d (f a)
We are ready to define the comonad-based recursor, parameterized by a comonad and a distributive law. We can either give a general-recursive definition stating the computation rule of the combinator
comrec :: Dist d f => (f (d c) -> c) -> Mu f -> c
comrec phi (In x) = phi (fmap (fmap (comrec phi) . iota) x)

where iota = iter (fmap In . dist)
or choose to reduce it to iteration
comrec phi = counit . iter (fmap phi . dist . fmap comult)
Course-of-value iteration is an instance corresponding to the cofree comonad on F and the distributive law of F over it. As the cofree comonad is given by cofree algebras, we need to introduce coinductive types and coiteration.
newtype PairF f a x = PF { unPF :: (a, f x) } instance Functor f => Functor (PairF f a) where ... data Nu f = Outi { out :: f (Nu f) }
coit :: Functor f => (c -> f c) -> c -> Nu f coit psi = Outi . fmap (coit psi) . psi
newtype Cofree f a = Cf { unCf :: Nu (PairF f a) } instance Functor f => Functor (Cofree f) where ... instance Functor f => Comonad (Cofree f) where
counit = fst . unPF . out . unCf
comult = Cf . coit (PF . pair Cf (snd . unPF . out)) . unCf
instance Functor f => Dist (Cofree f) f where dist = Cf . coit (PF
. pair (fmap (fst . unPF . out . unCf))
(fmap (fmap Cf . snd . unPF . out . unCf)))
Now course-of-value iteration can be defined “from scratch” by its computation rule
cviter :: Functor f => (f (Cofree f c) -> c) -> Mu f -> c cviter phi (In x)
= phi (fmap (Cf . coit (PF . pair (cviter phi) ini)) x)
but it also arises as a special case of comonad-based recursion
cviter = comrec
The new scheme relies relies on the cofree recursive comonad instead of the cofree comonad.
newtype FPair f a x = FP { unFP :: f (a, x) } instance Functor f => Functor (FPair f a) where ...
newtype CofreeRec f a = CfR { unCfR :: (a, Mu (FPair f a)) }

instance Functor f => Functor (CofreeRec f) where ... instance Functor f => Comonad (CofreeRec f) where
counit = fst . unCfR comult = CfR .
pair id
(rec (In . FP . fmap (pair (CfR . pair fst (snd . unP . snd))
(fst . unP . snd))
. unFP) . snd . unCfR)
instance Functor f => Dist (CofreeRec f) f where dist = CfR .
pair (fmap (fst . unCfR))
(In . FP . fmap (iter (pair (fmap fst)
(In . FP . fmap snd)
. unFP) . snd . unCfR))
The recursor can be defined by its computation rule
iterx :: Functor f => (f (CofreeRec f c) -> c) -> Mu f -> c iterx phi (In x) = phi (fmap (CfR .
pair (iterx phi)
(rec (In . FP . fmap (pair (iterx phi . snd) fst . unP)))
) x)
or as a specialization of the comonad-based recursor
iterx = comrec
Mendler-style recursion schemes do not need intermediate datastructures, in- stead they rely on higher-order functions and polymorphism. For Mendler-style iterator, the definition via the computation rule is
miter :: Functor f => (forall y. (y -> c) -> f y -> c) -> Mu f -> c miter psi (In x) = psi (miter psi) x
while one can also reduce it to conventional-style iteration
miter psi = iter (psi id)
(the functoriality of F is really only made use of in the latter case).
Mendler-style course-of-value iteration and Mendler-style iteration with sub- sidiary iterations are defined by their computation rules by
mcviter :: Functor f => (forall y. (y -> c)
-> (y -> f y) -> f y -> c)
-> Mu f -> c
mcviter psi (In x) = psi (mcviter psi) ini x
miter2 :: Functor f => (forall y. (y -> c)

-> (forall c’. (forall y’. (y’ -> c) -> (y’ -> c’) -> f y’ -> c’)
-> y -> c’)
-> f y -> c)
-> Mu f -> c miter2 psi (In x) = psi (miter2 psi) (update mrec (miter2 psi)) x
update ::
(forall c’. (forall y’. (y’ -> c’) -> (y’ -> Mu f) -> f y’ -> c’)
-> y -> c’)
-> (Mu f -> c)
-> (forall c’. (forall y’. (y’ -> c) -> (y’ -> c’) -> f y’ -> c’)
-> y -> c’)
update theta g = \ psi -> theta (\ de io -> psi (g . io) de)
(For update, it is necessary to explicitly give the type, otherwise Haskell’s type inferencer will not generalize enough.) The r eductions to the conventional-style schemes are
mcviter psi = cviter (psi (fst . unPF . out . unCf)
(fmap Cf . snd . unPF . out . unCf))
miter2 psi = iterx (psi (fst . unCfR)
(\ psi’ x -> iter (psi’ fst snd . unFP)
(snd (unCfR x))))
To show some example uses of the combinators, we define the inductive type of natural numbers.
data N x = Z | S x
instance Functor N where ... type Nat = Mu N
zero :: Nat	suc :: Nat -> Nat
zero = In Z	suc n = In (S n)
Fibonacci numbers (specified informally by ﬁbo 0 = 0, ﬁbo 1 = 1, ﬁbo (n + 2) = ﬁbo (n + 1)+ ﬁbo n) can now be defined with conventional-style course-of-value iteration (relying on a datastructure with results on elements structurally smaller than the given argument)
fibo :: Nat -> Int
fibo = cviter phi where phi Z = 0
phi (S (Cf (Outi (PF (_, Z))))) = 1
phi (S (Cf (Outi (PF (f, S (Outi (PF (f’, _)))))))) = f + f’
or with Mendler-style iteration, considerably closer to the style of general recursion

(relying on an assumed function for making the recursive calls and an assumed predecessor function)
fibo = mcviter psi where psi _	_	Z	= 0
psi fibo ini (S n) = case ini n of
Z	-> 1
S n’ -> fibo n + fibo n’
Notice that, in the definition of psi, the functions fibo and ini are formal param- eters (so the definitions of these functions from outside are overridden) and that fibo :: y -> Int, ini :: y -> N y, n :: y for a fresh type variable y which only gets instantiated to Nat when an application of fibo is evaluated using the computation rule.
To demonstrate a use of the recursion scheme from the cofree recursive comonad, we look at a simple example of mutual iteration, specified informally by foo 0 = 1, bar 0= 0, foo (n + 1) = 3 ∗ foo n + bar n, bar (n + 1) = foo n +3 ∗ bar n. We take foo to be our main function of interest and bar to be an auxiliary function.
The definition by conventional-style scheme defines the auxiliary function by iterating on a datastructure containing the results of the main function on elements structurally smaller than the given argument:
foo :: Nat -> Int
foo = iterx phi where phi Z = 1
phi (S (CfR (f, fs))) =
let bar = iter phi’ where
phi’ (FP Z) = 0
phi’ (FP (S (f’, g’))) = f’ + 3 * g’ in 3 * f + bar fs
(in this definition, bar :: Mu (FPair N Int) -> Int inputs not a natural number but a datastructure containing the result of foo on every smaller number).
In the case of the Mendler-style scheme we rely on assumed functions for doing the recursive calls:
foo = miter2 psi where psi :: (y -> Int)
-> (forall c’.
(forall y’. (y’ -> Int) -> (y’ -> c’) -> N y’ -> c’)
-> y -> c’)
-> N y -> Int
psi _	_	Z	= 1
psi foo miter (S n) = let bar = miter psi’ where
-- psi’ :: (y’ -> Int) -> (y’ -> Int)
-> N y’ -> Int
psi’ _	_	Z	= 0

psi’ foo bar (S m) = foo m + 3 * bar m in 3 * foo n + bar n

Connection to circular proofs
Let us now turn to sequent-style versions of intuitionistic proof systems or typed lambda-calculi with least and greatest fixedpoint operators. We will be informal in the section, only attempting to convey some intuitions, as a fuller treatment would necessarily involve a significant amount of introduction of concepts and notation. In particular, we show no terms, only types.
The constructor in and the conventional iterator iter justify the following μ-right and μ-left inference rules in the spirit of Park and Kozen for positive (syntactically functorial) F :

Γ −→ F (μF )
Γ −→ μF
Γ,F (Q Γ ⇒ C) −→ C


Γ, μF −→ C


(keep in mind that Γ,A −→ C should be equiderivable with A −→  Γ ⇒ C). It is also possible to consider alternative μ-left inference rules for other conventional-style recursors, e.g., for rec in the form
Γ,F ((Q Γ ⇒ C) × μF ) −→ C
Γ, μF −→ C

However the resulting systems are not particularly pleasant proof-theoretically. Some drawbacks are that the μ-detour cut elimination rule introduces inferences by the derived inference rule of “functoriality” (whereby the derivation of the functo- riality rule for F is by an induction “outside the system” on the type expression for
F ) and that the inference rules are quite far from the design ideal of sequent calculi that the premises should analyze the main formula of the conclusion solely in terms of its subformulae.
Mendler-style recursion combinators open up a different design space, which leads to more pleasing systems, but at the cost of introducing higher-order inference rules a` la Schroeder-Heister [25] (well within the coding power of logical frameworks such as LF). One can think of this as natural deduction on sequents.
The Mendler-style iterator miter justifies the following rule:
Γ,Y −. → C
.
Γ,FY −→ C
Γ, μF −→ C

saying that to prove Γ, μF −→ C, it suffices to prove Γ,FY −→ C where Y is a fresh type variable and in that proof it is legitimate to use a hypothesis (“local axiom”) Γ,Y −→ C.

Other Mendler-style recursors can be exploited similarly. The primitive recursor
mrec justifies the μ-left inference rule



Γ,Y −→ C
Γj, μF −→ Cj


. Γj,Y −→ Cj
.

Γ,FY −→ C
Γ, μF −→ C
allowing the proof of Γ,FY −→ C to also depend on a “local rule” by which the task of proving any sequent Γj,Y −→ Cj can be reduced to proving Γj, μF −→ Cj. (We note that while the rule based on miter was 2nd-order, this rule is already 3rd- order.) Likewise the course-of-value iterator mcviter leads to the μ-left inference rule

Γ,Y −→ C
Γj,FY −→ Cj


. Γj,Y −→ Cj
.

Γ,FY −→ C
Γ, μF −→ C
allowing Γj,Y −→ Cj to be concluded from Γj,FY −→ Cj within a proof of Γ,FY −→ C.
What about the recursor miter2 from the cofree recursive comonad? The corre- sponding (4th-order) μ-left inference rule is:
⎛ Γ,Y j −→ C . Γj,Y j −→ Cj ⎞
Γ,Y −→ C	⎜	j	j	j	⎟
Γ ,FY −→ C
Γj,Y −→ Cj
.
.
Γ,FY −→ C
Γ, μF −→ C

Now the proof of Γ,FY → C may depend on inferences by a local rule reminiscent of that for miter except that the role of μF is played by Y and there is an extra hypothesis. This corresponds to subsidiary iteration which has access to the results of the main recursion.
Circular proof systems have been offered as an alternative design to the Park and Kozen style. The μ-right and left inference rules are


Γ −→ F (μF )
Γ −→ μF
Γ,F (μF ) −→ C
Γ, μF −→ C
μL∗


corresponding essentially to in and in—1 (and no recursor). But the concept of proofs is nonstandard. A proof is a nonwellfounded tree, satisfying two conditions:
(a) it is rational (i.e., has finitely many distinct subtrees), (b) every infinite path

in the tree contains a trace of occurrences of a μ-type with infinitely many μL∗- inferences whose main formula is the trace’s designated occurrence of that μ-type in the conclusion of the inference (the progress condition).
Our claim is that Mendler-style sequent calculi provide a way to recast rational circular proofs into wellfounded proofs. There are two ingredients.
First, a proof being a rational tree means that it has cycles. Such a tree is rep- resentable as a wellfounded tree with backpointers. Due to the progress condition, the cycles can be shifted so that they all begin with μL∗ inferences, which means that we can deal with backpointers by making a μ-left rule whose premise depends on a hypothesis:
Γ, μF .−→ C
.
Γ,F (μF ) −→ C
Γ, μF −→ C

Wellfounded proofs using this rule represent exactly those rational circular proofs where every infinite path contains an infinite number of μL∗ inferences. However, there is a problem: We are not keeping track about staying on the right trace.
This brings us to the second trick, the use of a fresh type variable to ensure that at the end of any cycle we are on the same trace. We reformulate our rule as

Γ,Y −. → C
.
Γ,FY −→ C
Γ, μF −→ C


(notice that this is the rule we obtained from miter in our discussion above). The new attempt is sound, contrarily to the previous one, which naively used μF instead of Y , but now a cycle starting at a μL∗ inference must finish with the next one on the same trace. This is remedied by the rule inspired by mcviter:



Γ,Y −→ C
Γj,FY −→ Cj


. Γj,Y −→ Cj
.

Γ,FY −→ C
Γ, μF −→ C


With this rule a cycle starting with a μL∗ inference can pass through several further μL∗ inferences before reaching a backpointer. But still a problem remains: These further μL∗ inferences cannot be used as starting points of new (entangled) cycles.

This is partially remedied by the rule dictated by the miter2 recursor:
⎛ Γ,Y j −→ C . Γj,Y j −→ Cj ⎞
Γ,Y −→ C	⎜	j	j	j	⎟
Γ ,FY −→ C
Γj,Y −→ Cj
.
.
Γ,FY −→ C
Γ, μF −→ C
Here a cycle starting at a μL∗ inference can pass through a subsequent μL∗ inference which can start other cycles, but these subsidiary cycles must necessarily be of length 1 then—not passing through further μL∗ inferences. This is is a restriction, but the reason is that, with the way we chose to formulate our Mendler-style recursor from the cofree recursive comonad, the only flavour of subsidiary recursion we allow is iteration. It is possible (by an additional fixedpoint construction) to formulate a rule where the subsidiary recursions can be of the same kind as the main recursion.
Related work
Total functional programming has been experimented with in Cockett’s Charity language [8], based on categorical combinators; it has also been advocated for a number of years by D. A. Turner [29,30]. Totality is also the natural paradigm for type-theoretical proof assistants and dedicated languages for dependently typed programming where proofs are identified with functions.
Functional programming with inductive and coinductive types based on categor- ical combinators was pioneered by Hagino [15] and Cockett and Spencer [9]. The comonad-based recursion scheme was introduced by Uustalu, Vene, Pardo [36], in an attempt to extract the common pattern of primitive recursion and course-of-value iteration [33]. Independently, Bartels [3] described a dual corecursion scheme and looked also at the corresponding coinduction principle. Capretta, Uustalu, Vene [6] took the original work further, showing that the scheme extends from initial algebras to any coalgebras recursive in the sense of Osius.
Mendler-style (co)recursion originates from Mendler’s work [19] on a typed lambda-calculus with inductive and coinductive types. The original work was ex- ploited and developed further (still in the typed lambda-calculi context) in papers by Leivant [16], Parigot [22], Geuvers [12], Splawski [26], de Bruin [10], Uustalu and Vene [32], Matthes [18]. More recently, Barthe et al. [4] and Abel [1] have popularized Mendler recursion under the name of “type-based termination”. The more subtle Mendler-style course-of-value iteration was first formulated by de Bruin [10]. The semantic connection to the Yoneda lemma was first pointed out by Uustalu, Vene [32]. An account of the Church (a.k.a. B¨ohm-Berarducci) encod- ings (fold/build syntax) of inductive types and the deforestation rule of fold/build fusion in terms of strongly dinatural transformations was given by Ghani, Uustalu and Vene [14].

Free completely iterative monads are the subject of a series of recent papers by Aczel, Ad´amek, Milius and Velebil [2,20]. Cofree recursive comonads have been employed in a discussion of an application to tree transformations by Uustalu and Vene [35]; they were also touched upon in the work of Ghani et al. [13].
Circular sequent calculi (where proofs are rational or nonwellfounded trees) for logics with least and greatest fixedpoint operators have mainly been investigated in the context of classical predicate or modal logic. Such calculi were first con- sidered by Pliuskeviˇcius [23], Stirling and Walker [28] (in a model checking con- text) and Wal-ukiewicz [37] and have been studied further by, e.g., Sprenger and Dam [27], Brotherston and Simpson [5] (this list is far from complete). Into the context of sequent-style versions of intuitionistic proof systems and typed lambda- calculi, circular proof systems were introduced by Santocanale [24] and Cockett [7]. With syntactic progress conditions, they are related to typed lambda-calculi with syntactically guarded (co)recursion. With fresh type variables they are related to Mendler-style (co)recursion, as we have claimed here.




Conclusions
We have shown that the cofree recursive comonad yields a meaningful instance of the comonad-based recursion scheme. It gives a scheme that supports subsidiary recursions on the predecessors of the given argument. This happens by allowing recursion on a datastructure containing the results of the main recursion. While at first we had little intuition about the mechanics of this scheme, in retrospect it appears as a completely natural strengthening of course-of-value iteration, where essentially the same datastructure can only be finitely observed, as it comes without a wellfoundedness guarantee. It is also pleasant that there is a connection to the repeated regeneration phenomenon in circular proofs.
A number of issues require further work. First, in this paper we have depended on a rather naive approach to polymorphism based on strong dinaturality. We have done so deliberately, as this seems to be a good level of abstraction (due to the Yoneda-like natural isomorphisms that we can work with), allowing for a viable separation of concerns. But actual applications of our constructions must depend on meaningful sufficient conditions for a family of maps to be strongly dinatural, so we need to identify the most appropriate such conditions for our purposes. Second, the connection of Mendler recursion to circular proof systems should be worked out to the level of a full account of a categorical semantics for a circular sequent-style term calculus a` la Cockett based on Mendler-style recursors. Third, the Yoneda “reductions” employed in this paper are bound to be related to deforestation and defunctionalization/refunctionalization in ways we have not yet explored. We would like to work out the details of these connections.

Acknowledgement
Tarmo Uustalu is grateful to the PC of HOR 2007 for the invitation to give a talk and to Robin Cockett for many useful discussions on circular proofs. We also thank our referees for their helpful criticism.
This work was partially supported by the Estonian Science Foundation under grant no. 6940.

References
Abel, A., Termination checking with types, Theor. Inform. and Appl. 38(4) (2004), pp. 277–319.
Aczel, P., J. Ad`amek, S. Milius, and J. Velebil, Infinite trees and completely iterative theories: a coalgebraic view, Theor. Comput. Sci., 300(1–3) (2003), pp. 1–45.
Bartels, F., Generalised coinduction, Math. Struct. in Comput. Sci. 13(2) (2003), pp. 321–348.
Barthe, G., M. J. Frade, E. Gim´enez, L. Pinto, and T. Uustalu, Type-based termination of recursive definitions, Math. Struct. in Comput. Sci. 14(1) (2004), pp. 97–141.
Brotherston, J. and A. Simpson, Complete sequent calculi for induction and infinite descent, in: “Proc. of 22nd IEEE Symp. on Logic in Comput. Sci., LICS 2007 (Wroc-law, July 2007),” IEEE CS Press, 2007, pp. 51–62.
Capretta, V., T. Uustalu, and V. Vene, Recursive coalgebras from comonads, Inform. and Comput.,
204(4) (2006), pp. 437–468.
Cockett, R., Deforestation, program transformation, and cut-elimination, Electron. Notes in Theor. Comput. Sci. 44(1) (2001), pp. 88–127.
Cockett, R. and T. Fukushima, About Charity, Yellow Series Report 92/480/18, Dept. of Comput. Sci., Univ. of Calgary, 1992.
Cockett, R. and D. Spencer, Strong categorical datatypes I, in: R. A. G. Seely, ed., “Proc. of Int. Summer Category Theory Meeting (Montr´eal, June 1991),” Canadian Mathematical Society Conf. Proc. 13, AMS, 1992, pp. 141–169.
de Bruin, P. J., “Inductive Types in Constructive Languages,” PhD thesis, Dept. of Comput. Sci., Univ. of Groningen, 1995. Available at http://irs.ub.rug.nl/ppn/128570415.
Dubuc, E. and R. Street, Dinatural transformations, in: S. Mac Lane, ed., “Reports of the Midwest Category Seminar IV,” Lecture Notes in Mathematics 137, Springer, 1970, pp. 126–137.
Geuvers, H., Inductive and coinductive types with iteration and recursion, in: B. Nordstr¨om,
K. Pettersson, and G. Plotkin, eds., “Informal Proc. of Wksh. on Types for Proofs and Programs, TYPES ’92,” Dept. of Computing Science, Chalmers Univ. of Techn. and Go¨teborg Univ., 1992, pp. 193– 217.
Ghani, N., C. Lu¨th, F. De Marchi and J. Power, Dualising initial algebras, Math. Structures in Comput. Sci. 13(2) (2003), pp. 349–370.
Ghani, N., T. Uustalu, and V. Vene, Build, augment and destroy, universally, in: W.-N. Chin, ed., “Proc. of 2nd Asian Symp. on Programming Languages and Systems, APLAS 2004 (Taipei, Nov. 2004),” Lecture Notes in Computer Science 3302, Springer, 2004, pp. 327–347.
Hagino, T., A typed lambda calculus with categorical type constructors, in: D. H. Pitt, A. Poign´e, and
D. E. Rydeheard, eds., “Proc. of 2nd Int. Conf. on Category Theory and Computer Science, CTCS ’87 (Edinburgh, Sept. 1987),” Lecture Notes in Comput. Sci. 283, Springer, 1987, pp. 140–157.
Leivant, D., Contracting proofs to programs, in: P. Odifreddi, ed., “Logic and Computer Science,” APIC Studies in Data Processing 31, Academic Press, 1990, pp. 279–327.
Levy, P. B., T. Altenkirch et al., Polymorphic isomorphisms, discussion in the Types mailinglist, 2008. Available at http://lists.seas.upenn.edu/pipermail/types-list/2008/001179.html.
Matthes, R., Tarski’s fixed-point theorem and lambda calculi with monotone inductive types, Synthese
133(1) (2002), pp. 107–129.

Mendler, N. P., Inductive types and type constraints in the second-order lambda-calculus, Ann. of Pure and Appl. Logic 51(1–2) (1991), pp. 159–172.
Milius, S., Completely iterative algebras and completely iterative monads, Inform. and Comput. 196(1) (2005), pp. 1–41.
Mulry, P. S., Strong monads, algebras and fixed points, in: M. P. Fourman, P. T. Johnstone, and A. M. Pitts, eds., “Applications of Categories in Computer Science,” London Math. Society Lecture Note Series 177, Cambridge Univ. Press, 1992, pp. 202–216.
Parigot, M., Recursive programming with proofs, Theor. Comput. Sci. 94(2) (1992), pp. 335–356.
Pliuskeviˇcius, R., Investigation of finitary calculi for the temporal logics by means of infinitary calculi, in: B. Rovan, ed., “Proc. of 15th Int. Conf. on Math. Foundations of Comput. Sci., MFCS ’90 (Banska´ Bystrica, Aug. 1990),” Lecture Notes in Computer Science 452, Springer, 1990, pp. 464–469.
Santocanale, L., A calculus of circular proofs and its categorical semantics, in: M. Nielsen and
U. Engberg, eds., “Proc. of 5th Int. Conf. on Foundations of Software Science and Computation Structures, FoSSaCS 2002 (Grenoble, Apr. 2002),” Lecture Notes in Computer Science 2303, Springer, 2002, pp. 357–371.
Schroeder-Heister, P., A natural extension of natural deduction, J. of Symb. Logic 49(4) (1984),
pp. 1284–1300.
Sp-lawski, Z., “Proof-Theoretic Approach to Inductive Definitions in ML-Like Programming Languages versus Second-Order Lambda Calculus,” PhD thesis, Wroc-law Univ., 1993.
Sprenger, C. and M. Dam, On the structure of inductive reasoning: circular and tree-shaped proofs in the μ-calculus, in: A. D. Gordon, ed., “Proc. of 6th Int. Conf. on Foundations of Software Science and Computational Structures, FoSSaCS 2003 (Warsaw, April 2003),” Lecture Notes in Computer Science 2620, Springer, 2003, pp. 425–440.
Stirling, C. and D. Walker, Local model checking in the modal μ-calculus, Theor. Comput. Sci. 89(1) (1991), pp. 161–177.
Turner, D. A., Elementary strong functional programming, in: P. Hartel and R. Plasmeijer, eds., “Proc. of 1st Int. Symp. on Functional Programming Languages in Education, FPLE ’95 (Nijmegen, Dec. 1995),” Lecture Notes in Computer Science 1022, Springer, 1995, pp. 1–13.
Turner, D. A., Total functional programming, J. of Univ. Comput. Sci. 10(7) (2004), pp. 751–768.
Uustalu, T., Strong dinaturality and initial algebras, slides for NWPT ’00, 2000. Available at http:
//www.ii.uib.no/~nwpt00/Proceedings/Uustalu-slides.ps
Uustalu, T. and V. Vene, A cube of proof systems for the intuitionistic predicate μ, ν-logic, in:
M. Haveraaen and O. Owe, eds., “Selected Papers from 8th Nordic Wksh. on Programming Theory, NWPT ’96 (Oslo, Dec. 1996),” Research Report 248, Dept. of Informatics, Univ. of Oslo, 1997, pp. 237– 247.
Uustalu, T. and V. Vene, Primitive (co)recursion and course-of-value (co)iteration, categorically, Informatica 10(1), pp. 5–26, 1999.
Uustalu, T. and V. Vene, Coding recursion `a la Mendler (extended abstract), in: J. Jeuring, ed., “Proc. of 2nd Wksh. on Generic Programming, WGP 2000 (Ponte de Lima, July 2000),” Technical Report UU-CS-2000-19, Universiteit Utrecht, 2000, pp. 69–85.
Uustalu, T. and V. Vene, The dual of substitution is redecoration, in: K. Hammond and S. Curtis, eds., “Trends in Functional Programming 3,” Intellect, 2002, pp. 99–110.
Uustalu, T., V. Vene, and A. Pardo, Recursion schemes from comonads, Nordic J. of Comput. 8(3) (2001), pp. 366–390.
Wa-lukiewicz, I., Completeness of Kozen’s axiomatization of the propositional μ-calculus, Inform. and Comput. 157(1–2) (2000), pp. 142–182.
