Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 327 (2016) 5–25
www.elsevier.com/locate/entcs
Modeling Hybrid Systems in SIMTHESys
Enrico Barbierato1 Marco Gribaudo2
Politecnico di Milano,
via Ponzio 34/5, 20133 Milano (Italy)
Mauro Iacono3
Seconda Universit`a degli Studi di Napoli viale Ellittico, 81100 Caserta (Italy)

Abstract
Hybrid systems (HS) have been proven a valid formalism to study and analyze specific issues in a variety of fields. However, most of the analysis techniques for HS are based on low-level description, where single states of the systems have to be defined and enumerated by the modeler. Some high level modeling formalisms, such as Fluid Stochastic Petri Nets, have been introduced to overcome such difficulties, but simple procedures allowing the definitions of domain specific languages for HS could simplify the analysis of such systems. This paper presents a stochastic HS language consisting of a subset of piecewise deterministic Markov processes, and shows how SIMTHESys - a compositional, metamodeling based framework describing and extending formalisms - can be used to convert into this paradigm a wide number of high-level HS description languages. A simple example applying the technique to solve a model of the energy consumption of a data- center specified using Queuing Network and Hybrid Petri Nets is presented to show the effectiveness of the proposal.
Keywords: Performance evaluation, hybrid systems, metamodeling.

Introduction and related works
HS represent an extremely flexible formalism and a successful research field, as a wide number of problems belonging to different areas - such as biology, networks, telecommunications and many others - have been studied and analyzed through hybrid models. This article considers a subset of the Piecewise Deterministic Markov Processes [12], a set of stochastic models characterized by randomness appearing in the form of point events.
The relevance of HS in different fields is testified by the longevity of related studies and the diversity in approaches that can be found in literature. A good

1 enrico.barbierato@polimi.it
2 gribaudo@elet.polimi.it
3 mauro.iacono@unina2.it

http://dx.doi.org/10.1016/j.entcs.2016.09.021 1571-0661/© 2016 Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

survey summarizing the main issues in the first three decades of studies is provided by [2], which gives a very good general introduction of the field, with both conceptual definitions and examples. In [27] a control systems oriented point of view on the field is given, including a wide bibliography. Non expert readers can find a good introduction in [25]. In [2] a list of software solutions offering tools to study HS is available: here we will just mention Ptolemy [24], HyTech [17], UPPAAL [22] and Prism [21], as we explored their characteristics to have a conceptual benchmark while shaping our approach.
This work aims at providing a basis to allow flexible modeling of HS by means of a framework enabling the definition of custom modeling formalisms, fitting at best the applications. The main contribution of this work is not the definition of just another hybrid modeling formalism, but to show a generic method from which high level hybrid models can be analyzed by mean of a suitable interchange format. At the best of our knowledge, this is an original contribution to the field.
For the purposes of this work, besides the mathematical aspects characterizing the possible descriptions of hybrid systems (see [12]), the aspects related to their operational semantics play a relevant role in supporting the development of a gen- eral modeling framework for a class of formalisms suitable for their representation and analysis. In this sense, [23] offers an interesting perspective. Important contri- butions are also given by the theory of Hybrid Automata (HA) [16] and the theory of Continuous and Hybrid Petri Nets [1], which also inspired our research.
The roots of the paper can be found into our studies on Hybrid Petri Nets (HPN) [14][13][15] and on multiformalism modeling [26][4]. The approach presented in this paper distills the essential aspects of Hybrid Petri Nets semantics and analysis, abstracting them to obtain the mechanisms to define custom formalisms with hybrid characteristics.
The present approach is founded onto the SIMTHESys multiformalism modeling framework. SIMTHESys (Structured Infrastructure for Multiformalism modeling and Testing of Heterogeneous formalisms and Extensions for SYStems) is a frame- work including solution engines to evaluate performance indexes by simulation or with suitable numerical techniques. The framework allows the definition of custom modeling languages, named formalisms, which are organized into families according to the types of techniques that are needed to analyze a model written following the corresponding semantic. Currently, SIMTHESys supports: the design of classical formalisms such as SPN, Tandem Finite Capacity Queueing Networks (TFCQN) and Gordon and Newell Queueing Networks (GNQN), and multiformalism models based on them [20]; multiformalism performance oriented models allowing test- ing against some conditions [5]; the formal definition of formalism enriched with an exception handling mechanism [8]; two approaches (of increasing complexity) adding software rejuvenation features to performance models [3] [19]; a perfor- mance evaluation oriented modeling language for SOA BPEL applications [9]; a performance evaluation oriented modeling language for Map-Reduce applications [6][7]; formalisms suitable for the implementation of product-form solution theory based analysis techniques, allowing compositional multiformalism modeling [10].

The paper is organized as follows: Section 2 introduces a running example to present the work along the paper; Section 3 introduces the reference formal defi- nitions for the target HS class; Sections 4 and 5 present our approach; Sections 6 and 7 introduce the basis and the results of this work; Section 8 demonstrates the approach on the running example; finally, conclusions are drawn.

A running example
To start pointing out the nature of the systems this work aims to consider and analyze, let us focus on a running example, consisting of the characterization of the simplified data center shown in Fig.1a. In particular, the focus is on the study of the total energy required to run the servers, considering both IT resources and cooling. The more the servers are loaded, the more the temperature increases. In normal operating conditions, the data center is cooled using an air flow generated by a fan. If temperature reaches a given threshold, the data center turns on an air conditioning system (AC) to cool down the server room. If cooling down is insufficient and the room reaches a critical temperature, servers are shut down to prevent hardware damage. Moreover, the AC might fail to start, forcing a preventive shut down of all the system to allow for repair. It is supposed that user demands alternate at Poisson rates λL and λH between a high and a low workload.
The temperature of the room is modeled by a continuous variable x. Tempera- ture can rise due to the heating produced by the servers at different rates depending on the workload: aH during the high demand period, and aL otherwise. Tempera- ture can decrease due to the effect of both the fan (decreasing at rate dL) and the AC (rate dH ). The fan is always active, while the AC is turned on at rate μAC only if the temperature reaches the threshold fMax. When the temperature drops below threshold fMin, the system can switch back to fan cooling at rate μF an. The room has a base temperature fRoom, and must stay below a critical temperature fCritical. The rate at which the start of AC might fail is μS. In this case the servers are immediately shut down to allow repair, which takes an exponentially distributed amount of time characterized by rate μR. Repairing will leave a random tempera- ture in the room, to account for the fact that during the process both the AC and the servers might be started and stopped several times. To model this issue, we will not consider the room temperature during the repair process, and we will set the level x at which the system will restart to be distributed according to a truncated normal distribution centered on the average room temperature, and characterized by a given variance γ. The system will always restart with the low demand, to allow testing before increasing the demand again.

The considered Hybrid Systems
As a basis for our framework, a subset of the Piecewise Deterministic Markov Pro- cesses introduced in [12] is considered. In order to simplify the description, in the following this subset will be addressed as Hybrid System Modeling Language



Data center

x:=Ntrunc((fRoom+fCritical)/2,,fRoom,fCritical)



fCritical fMax
x’=aL-dH
m1: AC
Low
Fan(x)

AC(x)
x’=aL-dL
m2: Fan Low


R
S(x)

fMin	H

L	H
m5:
L	Fail



fRoom x

m3: AC
High
x’=aH-dH

Fan(x)

AC(x)

m4: Fan High
x’=aH-dL

S(x)

a)	b)

Fig. 1. A simplified data center example: a) the system, b) the corresponding HSML model.
(HSML), and HS will be used to denote hybrid systems in general: i.e. real systems that could be modeled using PDMPs. Our class of HS is characterized by a discrete and finite set of modes M = {m1,..., mM }. For each mode mi, the system is characterized by a finite number di of continuous variables xi,j (with 1 ≤ j ≤ di), each defined on a compact subset of R characterized by a lower boundary li,j and an upper boundary ui,j. The continuous domain of a mode mi is called Di, and defined as:
d
Di =×[li,j, ui,j]	(1)
j=1
where × represents the cartesian product of the corresponding sets. Each state is thus defined by a tuple σ:
σ = (mi, xi,1, . . . , xi,di ) with mi ∈M and xi,j ∈ [li,j, ui,j]	(2)
To simplify the notation, we define with xi = (xi,1, . . . , xi,di ), and the state becomes σ = (mi, xi). The state space of the model S is defined as:
S = {σ} = [ ({mi}× Di)	(3)
i=1
An HSML model is defined by a tuple (S, Φ, E, Λ, Ψ), where S is the state space, as defined in Eq.3. Φ = {φ1,..., φM } are the continuous evolution functions. Specifically, for every mode mi ∈ M, function φi is defined as:
φi : Di × R → Di	(4)
Let us suppose that in a time interval [a, b] the system visits only continuous states belonging to the same mode mi. Let us denote with σ(t)= (mi, xi(t)) the state at time a ≤ t ≤ b. The continuous part of the states evolves according to function φi. In particular:
σ(α)= (mi, xi) =⇒ σ(β)= (mi, φi(xi,β − α)) ,  ∀a ≤ α ≤ β ≤ b	(5)
It can be easily shown that by definition we must have φi(xi, 0) = xi. The random evolution of the model is governed by a set of N possible events E = {e1,..., eN }.

The rate at which events can occur is defined by function Λ:


Λ: S × E → R+
(6)

In particular, in any time interval Δt → 0 we have that an event ek ∈ E can occur in state σ with probability:
Pr{ek occurs in state σ during Δt} = Λ(σ, ek) · Δt + o(Δt)	(7)
Finally, Ψ describes the effects of an event to the state of the system. It is defined as:
Ψ: S × E × S → [0, 1]	(8)
Specifically, Ψ(σj|ek, σ) defines the probability that the system will jump to state σj, conditioned to the occurrence of event ek in state σ. More formally, we have that:

Pr{σj with mj = mj, xj
≤ xj,1, . . . , xj	≤ xj,d |ek, σ} =

j	j,1
j,dj	j
(9)

= Ψ(mj, xj,1, . . . , xj,dj |ek, σ)
To simplify the notation, it is possible to write Ψ(ek, σ) = DIST (σ), where DIST (σ) is a valid probability distribution that might be parameterized on the current state σ. For example, Ψ(ek, mi, xi) = DET (ml, xi) denotes an event ek that changes deterministically (DET) the mode from mi to ml leaving the contin- uous variables unchanged (provided that di = dl). It is a shorthand notation for:

Ψ(m , x |e ,m , x )= ⎧⎨ 1 if mj = ml ∧ xi ≤ xj


(10)

j	j  k	i	i
⎩ 0 otherwise

where xi ≤ xj denotes the element-wise comparison of the elements of vectors xi
and xj.

Application to the running example
Let us model the data center described in Section 2 using the proposed HSML. As shown in Fig.1b, the model is characterized by M = 5 modes: AC-Low (m1), Fan-Low (m2), AC-High (m3), Fan-High (m4) and Fail (m5). Modes m1 to m4 have a single fluid component x1, bounded between li,1 = fRoom and ri,1 = fCritical, while mode m5 do not have any continuous variable associated.
The state space for our running example is thus:
S = {m1, m2, m3, m4}× [fRoom, fCritical] ∪ {m5}	(11)
The fluid evolution accounts for the changes in the users demand and in the type of cooling being used, and functions Φ are defined as follows:

φ1(x1, t)= min(x1 + (aH − dL) · t, fCritical)	(12)
φ2(x1, t)= max(x1 + (aL − dL) · t, fRoom) φ3(x1, t)= min(x1 + (aH − dH ) · t, fCritical) φ4(x1, t)= max(x1 + (aL − dH ) · t, fRoom)
The change in the modes is governed by N = 6 events: High (e1) and Low (e2) when the system jumps from low to high and from high to low demand, StartAC (e3) and StopAC (e4) to describe the start and the stop of the AC, Fail (e5) and Repair (e6) to model the failures and the repairs. The AC can start only if the temperature is more than fMax, and it can stop only if it drops below fMin. Since the AC can fail only when it is starting, event e5 can only take place if the temperature is greater than fMax. If we call 1(Y ) the indicator function that returns 1 if predicate Y is true, and 0 if it is false, function Λ is defined as follows:
Λ(mi, x1, e1)= λH · 1(i ∈ {1, 2})	(13)
Λ(mi, x1, e2)= λL · 1(i ∈ {3, 4})
Λ(mi, x1, e3)= μAC · 1(i ∈ {2, 4}∧ x1 ≥ fMax) Λ(mi, x1, e4)= μF an · 1(i ∈ {1, 3}∧ x1 ≤ fMin) Λ(mi, x1, e5)= μS · 1(i ∈ {2, 4}∧ x1 ≥ fMax) Λ(mi, x1, e6)= μR · 1(i = 5)
Finally, function Ψ changes the fluid component x1 only in mode m5 to account for the restart after the failure. TO summarize:

Ψ(e ,m ,x )= ⎧⎨ DET (m3, x1) mi = m1

(14)

i	1
⎩ DET (m4, x1) mi = m2

Ψ(e ,m ,x )= ⎧⎨ DET (m1, x1) mi = m3

i	1
⎩ DET (m2, x1) mi = m4

Ψ(e ,m ,x )= ⎧⎨ DET (m2, x1) mi = m1

i	1
⎩ DET (m4, x1) mi = m3

Ψ(e ,m ,x )= ⎧⎨ DET (m1, x1) mi = m3

i	1
⎩ DET (m2, x1) mi = m4

Ψ(e5, mi, x1)= DET (m5)
Ψ(e6, m5)= DET (m1) × Ntrunc((fRoom + fCritical)/2, γ, fRoom, fCritical)

where Ntrunc((fRoom + fCritical)/2, γ, fRoom, fCritical) denotes that the next state will have the mode deterministically set to m1, and the temperature randomly distributed according to a normal distribution with mean (fRoom + fCritical)/2 and variance γ, truncated between fRoom and fCritical.

Defining high-level hybrid system languages
The example provided in Section 2 shows how models for very simple systems may require a very complex description. The proposed formalization is very hard to use from a modeler’s perspective due to several reasons. The simplest to address is the use of numbers to identify modes and events: this however can be overcame quite easily by using proper symbolic representations of the considered quantities. More subtle is the difficulty in defining in a consistent way all the functions involved (i.e. Λ, Φ and Ψ). Moreover, due to the similarity of the considered formalism to automata, both the number of states and events grows exponentially in the complexity of the model.
Thus we propose an integration of the considered type of HS in the SIMTHESys framework to automatically generate all the elements of the HSML tuple from an high-level description of the considered system. In order to describe how hybrid continuous-discrete paradigms can be implemented and translated into the consid- ered HSML language in a way that allows the solution of multiformalism models, we will first recall how the object-oriented SIMTHESys methodology works on standard discrete multiformalism system. In particular, we will present how SPN and sim- ple exponential Queuing Networks (QN), can be implemented in SIMTHESys. We will then extend such concepts to include continuous state components and we will apply them to implement a multiformalism language allowing cooperation between the hybrid counterparts of the two reference discrete formalisms. For what concerns SPN, we will focus on Hybrid Petri Nets (HPN), a special type of Fluid Stochastic Petri Nets (FSPN) [18]. For what concerns QN, the use of HSML allows extend the proposed formalism including non-exponential FCFS service centers. Even if such extension does not describe proper HS since the apparent state space of the model is only discrete, the inclusion of non-exponential transitions must be implemented using supplementary variables, thus leading to a model requiring the considered underlying HSML definition to be properly solved.
Note that a preliminary approach to modeling HS in SIMTHESys was given in [3] to add rejuvenation to PN or TFCQN models. However, in that case, the continuous part was limited to model aging of the components. This limitation allowed such models to be solved by first translating them into labeled transition systems [10], and then by externally attaching a solver handling the related continuous part. The approach proposed in this paper greatly extends such results, by allowing the representation of a more general class of hybrid systems.

SIMTHESys approach to multiformalism modeling
The SIMTHESys framework consists of i) a metamodeling 4 structure, ii) a set of interfaces and iii) a solving architecture. A user builds a model as composition of submodels where each one may be written in a (possibly different) formalism and

4 Metamodeling studies the rules and the structures that specify models. A metamodel can be defined an abstraction of a class of models, considering that a model abstracts the real world.

tied together in a composition by using metamodeling approach.
In SIMTHESys, formalisms are described by Formalism Description Language (FDL, based on XML) documents, which define all their modeling primitives. The FDL follows an object-oriented approach, in which elements can be characterized by interfaces that allow the interchange of objects as long as they provide the same interface.
The basic part of a formalism is the Element, defining all the atomic primitives describing a model. Formalism Elements are used to define submodels, and can contain other elements. An Element is characterized by Properties and Behaviors. Properties associate values of given types to the elements of a formalism. Behaviors define the actions that the element performs. For example, the following properties characterize the Place element of a SPN:
<propertyType name="id" type="String" default="" storage="static"/>
<propertyType name="Tokens" type="int" default="0" storage="dynamic"/>
<propertyType name="MeanTokens" type="Result" storage="computed"/>

where static denotes a constant value, dynamic indicates a value instantiated by the model that may change during the system evolution, and computed refers to a value calculated by the solving engine. Each property automatically defines getter and setter methods that can be called by the code defining the behaviors to read or write the corresponding value. For example getTokens() returns the value of the Tokens property associated with a place. The value of the same property can be set using the setTokens(int v) method. With regard to Behaviors, the following example determines the current number of tokens in a SPN Place:
<behavior name="getOccupancy" return="int">
<code>
return getTokens();
</code>
</behavior>

Interfaces provide the capability to share common sets of behaviors used by different elements. The main idea of interfaces consists of binding formalisms and solving engines. SIMTHESys exploits three types of interfaces: solver interfaces (to define which solving engine should be used), solver helper interfaces (to guarantee that a set of behaviors and properties are mandatory in all models produced in the specified formalism) and behavioral interfaces (to reuse existing abstractions).
A Model is declared by a document written in Model Description Language (MDL) and it must conforms to one (or more) formalism. In particular, a model instantiates a set of elements: for each element, it specifies the initial value for all the dynamic properties, and assigns a constant value to all the static properties.

SIMTHESys Solving Engines
Beside the FDL Analyzer, SIMTHESys provides also a set of six solution tech- niques for two formalism families (exponential events and exponential and imme- diate events based), and exploits six different solution engines. The six solution techniques are based either on discrete event simulation or on state space gener- ation. The foundation of the latter engines consists of a state snapshot logic and

uses a behavior to retrieve the requested information from the high-level formalism model. In the first phase, the process builds up the transition graph of the model (which in most of the case is a CTMC) by running all the states considering in each step those events that are enabled, stopping when all the produced states can be found in a snapshot. In the next phase, the generator matrix is derived from the transition graph. Finally, the steady state solution vector is computed. Discrete event simulation engines instead use behaviors to choose one possible evolution, and produce performance indices by averaging several traces.
Formalism families
A formalism family is a set of Formalisms that can be handled over the same solving engines. They also share a set of similarities, which can be exploited to automatically generate the multiformalism behavior from the specification of the way in which primitives of single formalisms components works. Any formalism that is part of a family can be solved by any solution engine supporting that family by using a dedicated group of solver and solver helper interfaces.
Exponential Event Formalisms
To show how a new formalism family should be designed, we can consider the Exponential Event Formalisms (EEF) family as a reference, as it is the basis for well known formalisms. As the name suggests, EEF are formalisms in which the state of the model is modified through events that occur after random exponentially distributed times. Moreover, all the events that can occur have the property that they can be enabled or disabled depending on the model state. The model is composed by “containers” that can hold a different number of objects, which moves among the various modeling primitives available in the formalism that belong to the EEF family. The first behavior defined in a FDL is called ‘InitEvents’ and it must check which elements are currently enabled (“active”) in a given model state. Each solution engine exploits a behavior called ‘Schedule’ that is used by ‘InitEvents’. Each implementation of ‘Schedule’ behavior must specify what will be executed whenever an event occurs using a program routing written in a suitable programming language (Java in the current implementation). The portion of code that is executed reflects the evolution of the model by updating the state of the elements. All languages that want to automatically interact together must define an ‘isActive’ behavior for all elements that represent events. The languages also must expose a ‘fire’ behavior that is called whenever the event occurs to determine the how the state of the model will change. All elements that represent containers must implement either ‘push’ or ‘pull’ behaviors to move objects among them.
Finally, the performance indexes are collected by a another set of behaviors, which are called in turn by the solving engines to compute and update the measure- ments. To simplify the presentation, we will not enter in detail of these behaviors: interested readers can refer to [20] for further details.
To be more formal, with reference to the framework defined in this paper, EEF

encompasses all the formalisms that can be described by a sub-set of the HSML (£, E, Λ, Ψ), where £ = {mi} contains its (finite and discrete) state space, E con- tains all the events that can modify the state, and occur at an exponential (and possible state dependent rate) Λ : S × E → R+. When an event occurs, the state is probabilistically changed according to a distribution Ψ : S×E×S → [0, 1]. The state space £ is computed as the set of all the possible combinations of values the proper- ties of all the elements of the model may assume. The ‘InitEvents’ behavior, checks which events e ∈ E are enabled in a state m ∈£ calling the ‘isActive’ behavior of the modeling primitives that can cause it (for example, transitions in SPN, or queues in QN). If the event can occur, it is scheduled using the ‘Schedule’ behavior, passing the rate at which the event occurs computed with λ(m, e), and a piece of code that computes the possible set of next states Next(m) = {mj : Ψ(m, e, mj) > 0}. Note that the EEFs can be easily mapped to a CTMC, with state space £, in which the transition rate qij from state i to state j (with i /= j) is defined as:
qij = Σ λ(mi, e)Ψ(mi, e, mj).	(15)
e∈E

Stochastic Petri Nets
A SPN formalism defines four type of elements: places, transitions, standard arcs and inhibitor arcs. Places have a ‘Tokens’ property that counts the tokens inside a place. The semantic of the formalism implements some additional behaviors. Specif- ically the ‘Place’ <elementType> implements the ‘ElementOccupancy’ behavioral interface to check a place. The ‘getOccupancy’ and ‘setOccupancy’ behaviors are wrappers to implement the ‘ElementOccupancy’ interface, which uses the ‘Tokens’ property. The second element type is ‘Transition’, which implements ‘Active’ and ‘FireableEvents’ interfaces, and uses ‘PushPull’ behaviors. Other two behaviors play a crucial role in the model definition: ‘isActive’ implements ‘Active’ interface, while ‘fire’ implements ‘FireableEvents’ (and the firing rule of SPN transitions) by activating behaviors of the elements that are connected as inputs and outputs of a transition, which in turn are compliant with the ‘PushPull’ and ‘CheckCapacity’ in- terfaces. Only arcs and inhibitor arcs can be connected to a transition. The purpose of ‘isActive’ behavior is to check the enabling of the transition in the model. Follow- ing ‘Place and ‘Transition’ elements, an ‘Arc’ element implements Edge’, ‘Active’ and ‘PushPull’ behaviors, and uses ‘ElementOccupancy’ (to check a Place). The ‘isActive’ behavior evaluates if the enabling rule of SPN is satisfied by the input place of the arc, as required by the ‘isActive’ implementation of the transition, while ‘Push’ and ‘Pull’ (that implement ‘PushPull’) enact token consumption and production in consequence of the activation of the ‘fire’ behavior of the transition. The fourth and last element type is ‘InhibitorArc’, which is similar to Arc, but checks if a place has less than a given quantity of tokens. The InitEvents behavior checks which transitions are enabled and schedules consequently the firing of the eligible ones at the corresponding rate according to Algorithm 1. Note that the rate at which the event occurs corresponds to the firing rate of the correspond-

ing transition, and that the piece of code that it is executed calls the firing of the transition.
As an example of how behaviors are implemented, Algorithms 2 and 3 denote respectively the ‘IsActive’ and ‘Fire’. In the former, a transition looks both for incoming arcs and inhibitor arcs, which in turn implement the ‘IsActive’ behavior by verifying that the marking of the incoming place is respectively less, or greater or equal to their weight; in the latter, each time a transition fires, it updates the marking. Finally, the performance indices are computed by defining a state reward for each place (that is, its mean number of tokens), and an impulse reward for each transition (its throughput).

Algorithm 1 InitEvents
1: for all T ∈ Transition do
2:	if T.IsActive() then
3:	solver.Schedule(T.rate,“T.Fire()”);
4:	end if
5: end for

Algorithm 2 IsActive
1: for all a ∈ Arc ∪ InhibitorArc where a.to = this do
2:	if NOT a.IsActive() then
3:	return false;
4:	end if
5: end for
6: return true;


Algorithm 3 Fire
1: for all a ∈ Arc where a.from = this do
2:	a.Push();
3: end for
4: for all a ∈ Arc where a.to = this do
5:	a.Pull();
6: end for

Queueing Networks
Queueing Networks (QN) is a formalism used to analyze a system where a number of servers are connected to serve customers, waiting in a queue. Queuing networks are composed by just two element types: queuing stations and interconnection arcs. In this case queuing nodes are characterized by the ‘Length’ property that counts the number of jobs currently in execution, and by the event that fires when the job currently in service finishes. The ‘InitEvents algorithm is shown in 4. The ‘isActive’ behavior is implemented by checking if the length of the corresponding queue is greater than 0. The ‘Queue’ element consists of the ‘getOccupancy’ and

‘setOccupancy’ that are wrappers to implement the ‘ElementOccupancy’ interface and work on the ‘Length’ property. The ‘Arc’ subElement implements ‘Push’ and ‘Pull’. Specifically, it uses the ‘Push’ behavior of the connecting arc to address the customer to the next station and in turn calls the ‘AddOccupancy’ behavior of the ‘Queue’ at the other end of the ‘arc’. The ‘AddOccupancy(c)’ behavior adds c customers to the length of each queue.

Algorithm 4 InitEvents
1: for all q ∈ Queue do
2:	if q.IsActive() then
3:	for all a ∈ Arc where a.from = q do
4:	solver.Schedule(a.prob · q.rate,“q.Fire(a)”);
5:	end for
6:	end if
7: end for
The event is scheduled at rate that is computed as a.prob · q.rate: the first term represents the routing probability and it is used to allow a probabilistic choice among several destination. The notation a.prob states that it is collected from a static property of the arc. The latter, q.rate, is instead a property of the queue and corresponds to the exponential service rate of the considered station. As for SPN, the code containing the definition of what happens when the scheduled event is executed, relies on the execution of a ‘Fire’ behavior. However, in this case, the ‘Fire’ behavior of a ‘Queue’ includes a parameter defining the destination of the service. The ‘Fire’ behavior is described by Algorithm 5.

Algorithm 5 Fire(a)
1: a.Push();
2: length = length - 1;

Finally, the following performance metrics are computed: the throughput of the queues as impulse rewards, and the average number of jobs in a queue as state rewards.
Note that, since the both SPN and QN use the same behaviors to check if nodes are enabled and move objects among the primitives, the two formalisms can easily interact and be interconnected together to analyze multiformalism models.
A Hybrid Formalisms Family for SIMTHESys
EEFs can be extended to support HS: this new formalism family will be addressed as Hybrid Formalism Family (HFF). In particular, it must account for the fact that states are composed of a discrete and a continuous part. The latter is characterized by a continuous domain that can change depending on the former. It must also consider the fact that the rate at which events occur can depend on the continuous part of the state, and whenever the system changes mode (its discrete state), all the continuous variables could be altered in a deterministic or stochastic way.

HFF still uses the ‘InitEvents’ behavior in order to take account of the events that are enabled (or can be enabled due to the evolution of the continuous variables) in a state. In addition, HFF requires supported formalisms to implement two new behaviors: ‘getFluidDomain’ returns the continuous variables that must be consid- ered in the corresponding discrete state. If the current state corresponds to mode mi, it returns the value of variable Di in the HSML state definition. Behavior ‘get- FluidEvolution’ returns the function describing how the continuous variable evolve with time in the considered mode. If the current state is mode mi, it returns a function encoding φi. The parameters used by ‘Schedule’ behavior must take into account Λ and Ψ. In particular, since Λ for HSML can depend on the continuous state, the ‘Schedule’ behavior implemented by the solvers of the HFF models must accept a function instead of a constant to specify the firing rate of the events. The code being executed, must implement the change in the mode of function Ψ. The change to the continuous variables must instead be passed as an extra parameter to the ‘Schedule’ behavior. It should not only update the discrete properties of the model to determine the next mode, but it must also adjust the values of the continuous variables of the current mode to account for the new variables that will be available in the destination mode.

Hybrid Petri Nets
Hybrid Petri Nets (HPN) adds to conventional SPN new elements to model HS. Several slightly different HPN dialects have been defined: in this work we will focus on the primitives shown in Figure 2. In particular, HPN are characterized by a set of discrete places PD and a set of discrete transitions TD. Each transition τ ∈ TD is characterized by a possibly state dependent exponential firing rate μτ (σ). HPN also contains a set of fluid places PF (usually represented as double circles) and a set of fluid transitions TF (drawn as double boxes). HPN contains several different type of arcs: discrete and inhibitor arcs (collected respectively in sets AD and AH ) have the conventional meaning defined for SPN. Test arcs AT , usually represented as a line with an arrow on both sides, consist of a primitive enabling transitions when the connected place has more tokens than the weight of the arc. For standard SPN, they can be considered as a short-hand notation for two arcs, with the same weight, connecting one transition to one place in opposite direction. For HPN however they have a special meaning and must be explicitly included in the formalism. Fluid arcs AF , usually represented as pipes, allow the flow of fluid between fluid places and fluid transitions. A fluid arc a ∈ AF is characterized by a fluid weight wa ∈ R.
Fluid places are characterized by a level property, accounting for the continuous value contained in the place. This level is usually addressed as fluid as opposed to tokens contained in conventional discrete places. Each fluid place has an implicit lower boundary at level 0; in order to allow for model solution, the level of a fluid place p ∈ PF is usually upper bounded by a specified level Bp. An enabled fluid transition τ ∈ TF transfers fluid at rate rτ (σ) among the fluid places to which it is connected. In particular, if arc a ∈ AF starts from fluid place p ∈ PF and ends in an enabled transition τ ∈ TF , it removes from place a fluid at rate −wa · rτ (σ) units


	B	r


Discrete Place
Discrete Transition
Fluid Place
Fluid Transition


w	w	w	w


Discrete Arc

Inhibitor Arc

Test Arc

Fluid Arc


Fig. 2. HPN modeling primitives
per second. If arc aj starts from τ and ends in p, then the enabled transition pumps wa′ · rτ (σ) fluid units per second int place p. Fluid transitions can be enabled or disabled by discrete places using inhibitor or test arcs. If the input place has not enough fluid to satisfy the outgoing request, or if an output place is full, the rate of the corresponding transition is reduced to allow flow conservation. This procedure, called rate adaption [1] is quite complex, and its description is outside the scope of this work. In this paper, it is simply assumed that the fluid rate rτ (σ) accounts for rate adaption in its state dependency.
The evolution and the semantic of the discrete part of HPN is identical to the one of SPN: for this reason it can be implemented exactly as outlined in Section 6.1. In the corresponding HSML, the state space £ is defined as the set of the possible different configurations that the discrete part of the model (i.e. the marking of the discrete places) may assume, and it can be generated in SIMTHESys with the same technique used to visit the state space of SPN models. The InitEvents behavior checks which transitions are enabled. The rate at which events can occur, λ(σ, e) depends on the level of the fluid places. Moreover, if event eτ ∈ E corresponds to the firing of a transition τ ∈ TD, then λ(σ, eτ ) = μτ (σ) will be defined as the (possibly fluid dependent) rate of τ . The ‘Schedule’ behavior is then called for each active transition τ ∈ TD, using as rate the function λ(σ, eτ ). The code associated to the event updates the mode of the HSML by changing the token in the discrete places as for conventional SPN. Fluid variables remain unchanged, so ‘Schedule’ behavior receives parameter Ψ(eτ , σ)= DET(σ).
In HPN the continuous variables are identical in all the states and correspond to the level of the fluid places of the model. For this reason, all discrete states mi have the same continuous domain Di:
Di = × [0, Bp]	(16)
p∈PF
This implies that the behavior ‘getFluidDomain’ always returns Di. The evolution of the continuous variables depends on the enabled fluid transitions, which in turns depend on the marking of places (both discrete and continuous). Behavior ‘get- FluidEvolution’ returns the function that describes the fluid evolution, considering input and output fluid arcs for each continuous place. In particular, let us call E (σ) ∈ TF the set of fluid transitions enabled in state σ. Let us call x ∈ Di the set

of the continuous values contained all the fluid places of the model when behavior ‘getFluidEvolution’ is called. Function φ can be computed as the solution of the following differential equation:

⎧⎪ dφ(x,τ ) = Σ

r (σ) · Win − Wout 



⎪⎩ φ(x, 0) = x

where Win = |wa:τ→p| is a vector with as many components as fluid places, and for each p ∈ PF , term wa:τ→p denotes the weight of the fluid arc starting from τ and directed to p or zero if such arc does not exist. In a similar way, Wout accounts for
the arcs ending on fluid transition τ .

Queuing Networks with general service distribution
QN with general service distributions are solved with the supplementary variable approach [11]. In particular, each non-exponential queue has associated a fluid variable that represents the ‘clock’ of the corresponding service time distribution. Behavior ‘getFluidDomain’ returns a domain with as many components as the non- exponential queues that are currently working (i.e. not idle) in the state. Behavior ‘getFluidEvolution’ instead returns a linear increase with rate 1 for each continuous variable corresponding to the clock of a non-idle queue. The ‘Schedule’ behavior is called for each non-idle queue, with firing rate argument Λ set to the hazard rate of the corresponding non-exponential service time distribution, and parameter Ψ set to a function that puts to zero the supplementary variable corresponding to the queue that has finished service, and leaves the other clocks unchanged.
Application
We now extend the case study presented in Section 2 to consider a more complex workload model. We use a standard closed QN model to describe the IT components of the data-center and a HPN to model the air conditioning system. The model of the considered system is shown in Figure 3. The workload of the data-center is characterized by N users that submit requests to the system. Each users has a think time Z which is spent in the infinite server station Terminals of the QN part of the model. Jobs requires both compute resources at queue Compute characterized by a given average service time SC, and storage resources at queue Storage with service time SS. Requests always ends after a visit to the compute node, with probability pjob, otherwise they perform another storage-compute cycle. The data-center is composed by cC compute servers, and cS storage servers, which are modeled with c-servers queues.
The temperature is now modeled by fluid place Temperature, and it rises consid- ering the heat produced by the workloads of the compute (fluid transition HeatC) and the storage (HeatS) servers. The cooling effects of fan and AC are modeled

QN: servers and storage
FSPN: cooling and air conditioning

Fig. 3. A small datacenter QN-HPN model.
respectively by fluid transitions CoolF an and CoolAC. When place Fan is marked, the data-center is cooled down using just fans. As soon as the temperature becomes larger than fMax, the token moves to place AC thanks to the exponential transition StartAC to denote the activation of the air conditioning system. The firing of the exponential transition StopAC models the return to fan-based cooling whenever the temperature drops below threshold fMin. To simplify the presentation, the case in which the AC can fail starting has not been taken in account. Instead, the domain of the fluid places is set to [tRoom, tCritical], and the failure event is evaluated as the probability of reaching fCritical with the considered configuration. Note that a de- scription of the considered system directly in HSML would have required N (N + 1) different modes.
Power consumption is computed using a simple linear model, supposing that the power consumption is linearly proportional to the utilization of the system:
P = cC · PC-idle + (PC-Max − PC-idle)UC +
+ cS · PS-idle + (PS-Max − PS-idle)US +	(18)
+ PF an + Pr{#AC = 1}· PAC
where PC-idle and PC-Max are respectively the idle and maximum power of each compute server, PS-idle and PS-Max the same values for the storage servers, 0 ≤ UC ≤ cC and 0 ≤ US ≤ cS are the utilizations of the compute and storage servers, PF an

and PAC are the power consumptions of the fan and of the air conditioning systems, and Pr{#AC = 1} is the probability that place AC is marked. Parameters used in the model are summarized in Table 1. The components of the tuple (£, Φ, E, Λ, Ψ) have been manually generated following the procedure described in Section 5. The solution has been computed discretizing the temperature range in 61 equally spaced steps: in this way the HSML model has been transformed into an ordinary CTMC and solved using conventional techniques 5 . The solution of the model required few seconds on a 2011 MacBook Air Intel Core-i5 PC with 4GB of RAM.
Table 1 Model parameters


The model has been evaluated with an increasing workload N = 1 ... 25, for different numbers of compute servers cC = 3 ... 5. The configuration with cC = 5 has been evaluated with two configurations exploiting two different AC units: one capable of cooling 1.5 deg. / s. and requiring a power of PAC = 1000 Watt (denoted in Figures 4-8 with c = 5), and a second more powerful system capable of cooling 2 deg. / s., but requiring PAC = 1350 Watt (denoted with c = 5+).
110
100
90
80
70
60
50
40
30
20
0	5	10	15	20	25
N

Fig. 4. Response time of the system as function of the workload for a different number of compute servers.
Figure 4 shows the average system response time that, as expected, decreases when increasing the number of compute servers. It is interesting to note that the

5 Please note that a general solution technique for HSML models is an important topic which outside the scope of this work. Here, an ad-hoc solution has been implemented to show the feasibility of the multiformalism approach

type of AC device used has no influence on this part of the model (that is the lines for c = 5 and c = 5+ are superposed), since there is no feedback from the HPN sub-model to the QN component.

30

28

26

24

22

20

18
0	5	10	15	20	25
N

Fig. 5. Average temperature of the system as function of the workload for a different number of compute servers.
The average room temperature is shown in Figure 5. As expected, the average temperature increases with workload, and tends to reach the asymptote (tMax + tMin)/2= 22.5 due to the control that activates and turns off the air conditioning. It is interesting to note that the average temperature depends just on the workload, and not on the number of servers used in the configuration.


1
1e-05
1e-10
1e-15
1e-20
1e-25
1e-30
1e-35
1e-40
1e-45


0	5	10	15	20	25
N


Fig. 6. Fault probability of the system as function of the workload for a different number of compute servers.
Figure 5 also shows that the temperature for the case c = 5 (five compute servers, lower power AC system) tends to rise more than in the other configurations. Figure 6 shows the probability of reaching the critical temperature for the various configu- rations. It is clear that while for most of the cases this probability is negligible, the configuration c = 5 has a large value, meaning that the AC unit that can be used with c =3 or c = 4 is not enough to cool down the room with c = 5, and a larger (but more power demanding) model is required, as shown by the curve labeled as c = 5+.
Figure 7 shows the average power consumption of the considered configurations. As expected, the power consumption increases with the number of servers, but com-



2000
1800
1600
1400
1200
1000
800
600
400


0	5	10	15	20	25
N


Fig. 7. Average power consumption of the system as function of workload for a different the number of compute servers.

1
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0
0	5	10	15	20	25
N

Fig. 8. Probability of switching on the air conditioning system as function of the workload for a different number of compute servers.
paring curves c = 5 and c = 5+ for workloads N ≤ 13 where the configuration with the less powerful AC unit still provides a reliable operation, it can be seen that the use of a more powerful cooling system can reduce the overall energy requirements. This is illustrated in Figure 8 where the probability that the AC is activated is shown: the more powerful air conditioner can be activated for a shorter time period when using medium workloads, leading to a lower average power consumption even if the cooling equipment requires a larger amount of energy.
Conclusions and Future Work
In this paper a general solution has been presented to support the definition of custom modeling languages for HS. Besides this, the main points behind the de- sign of such formalisms have been pointed out and examined, in order to help interested readers to autonomously produce own solutions, independently from the SIMTHESys framework. Many developments are planned after this first work on the topic, going from the use of SIMTHESys to study and define specific domain oriented formalisms to the enrichment of the HFF with additional features and

support for custom metrics.
Acknowledgment
The results of this work have been [partially] funded by EUBra-BIGSEA (690116), a Research and Innovation Action (RIA) funded by the European Commission under the Cooperation Programme, Horizon 2020 and the Ministrio de Cincia, Tecnologia e Inovao (MCTI), RNP/Brazil (grant GA/0000000650/04).

References
Alla, H. and R. David, Continuous and hybrid petri nets, Journal of Circuits, Systems and Computers
08 (1998), pp. 159–188.
Antsaklis, P. J. and X. D. Koutsoukos, “Hybrid Systems: Review and Recent Progress,” John Wiley & Sons, Inc., 2005 pp. 273–298.
Barbierato, E., A. Bobbio, M. Gribaudo and M. Iacono, Multiformalism to support software rejuvenation modeling., in: ISSRE Workshops (2012), pp. 271–276.
Barbierato, E., M. Gribaudo and M. Iacono, Defining Formalisms for Performance Evaluation With SIMTHESys, Electr. Notes Theor. Comput. Sci. 275 (2011), pp. 37–51.
Barbierato, E., M. Gribaudo and M. Iacono, Exploiting multiformalism models for testing and performance evaluation in SIMTHESys, in: Proceedings of 5th International ICST Conference on Performance Evaluation Methodologies and Tools - VALUETOOLS 2011, 2011.
Barbierato, E., M. Gribaudo and M. Iacono, A performance modeling language for big data architectures., in: W. Rekdalsbakken, R. T. Bye and H. Zhang, editors, ECMS (2013), pp. 511–517.
Barbierato, E., M. Gribaudo and M. Iacono, Performance evaluation of nosql big-data applications using multi-formalism models, Future Generation Computer Systems 37 (2014), pp. 345 – 353.
Barbierato, E., M. Gribaudo, M. Iacono and S. Marrone, Performability modeling of exceptions-aware systems in multiformalism tools, in: ASMTA, 2011, pp. 257–272.
Barbierato, E., M. Iacono and S. Marrone, PerfBPEL: A graph-based approach for the performance analysis of BPEL SOA applications., in: VALUETOOLS (2012), pp. 64–73.
Barbierato, E., G.-L. D. Rossi, M. Gribaudo, M. Iacono and A. Marin, Exploiting product forms solution techniques in multiformalism modeling, Electronic Notes in Theoretical Computer Science 296 (2013),
pp. 61 – 77.
Cox, D. R., The analysis of non-markovian stochastic processes by the inclusion of supplementary variables, Mathematical Proceedings of the Cambridge Philosophical Society 51 (1955), pp. 433–441.
Davis, M., “Markov Models & Optimization,” Chapman & Hall/CRC Monographs on Statistics & Applied Probability, Taylor & Francis, 1993.
Ghasemieh, H., A. Remke, B. R. Haverkort and M. Gribaudo, Region-based analysis of hybrid petri nets with a single general one-shot transition, in: M. Jurdzinski and D. Nickovic, editors, Formal Modeling and Analysis of Timed Systems - 10th International Conference, FORMATS 2012, London, UK, September 18-20, 2012. Proceedings, Lecture Notes in Computer Science 7595 (2012), pp. 139–154.
Gribaudo, M. and A. Remke, Hybrid petri nets with general one-shot transitions for dependability evaluation of fluid critical infrastructures, in: High-Assurance Systems Engineering (HASE), 2010 IEEE 12th International Symposium on, 2010, pp. 84–93.
Gribaudo, M. and A. Remke, Hybrid petri nets with general one-shot transitions for dependability evaluation of fluid critical infrastructures, in: 12th IEEE High Assurance Systems Engineering Symposium, HASE 2010, San Jose, CA, USA, November 3-4, 2010 (2010), pp. 84–93.
Henzinger, T. A., The theory of hybrid automata, in: Proceedings of the 11th Annual IEEE Symposium on Logic in Computer Science, LICS ’96 (1996), pp. 278–.

Henzinger, T. A., P.-H. Ho and H. Wong-toi, Hytech: A model checker for hybrid systems, Software Tools for Technology Transfer 1 (1997), pp. 460–463.
Horton, G., V. G. Kulkarni, D. M. Nicol and K. S. Trivedi, Fluid stochastic petri nets: Theory, applications, and solution techniques, European Journal of Operational Research 105 (1998), pp. 184– 201.
Iacono, M., E. Barbierato and M. Gribaudo, The SIMTHESys multiformalism modeling framework, Computers and Mathematics with Applications (2012), pp. 3828–3839.
Iacono, M. and M. Gribaudo, Element based semantics in multi formalism performance models, in:
MASCOTS (2010), pp. 413–416.
Kwiatkowska, M., G. Norman and D. Parker, Probabilistic symbolic model checking with prism: a hybrid approach, International Journal on Software Tools for Technology Transfer 6 (2004), pp. 128–142.
Larsen, K. G., P. Pettersson and W. Yi, Diagnostic Model-Checking for Real-Time Systems, in: Proc. of Workshop on Verification and Control of Hybrid Systems III, 1066 (1995), pp. 575–586.
Lee, E. and H. Zheng, Operational semantics of hybrid systems, in: M. Morari and L. Thiele, editors, Hybrid Systems: Computation and Control, Lecture Notes in Computer Science 3414, Springer Berlin Heidelberg, 2005 pp. 25–53.
Liu, J., X. Liu and E. A. Lee, Modeling distributed hybrid systems in ptolemy ii, Proceedings of the American Control Conference (2001), pp. 4984–4985.
Lygeros, J., Lecture notes on hybrid systems, Technical report, ETH Zurich (2004).
URL http://robotics.eecs.berkeley.edu/~sastry/ee291e/lygeros.pdf

Moscato, F., F. Flammini, G. D. Lorenzo, V. Vittorini, S. Marrone and M. Iacono, The software architecture of the OsMoSys multisolution framework, in: ValueTools ’07: Proceedings of the 2nd international conference on Performance evaluation methodologies and tools, 2007, pp. 1–10.
Zhu, F. and P. J. Antsaklis, Optimal control of hybrid switched systems: A brief survey, Discrete Event Dynamic Systems 25 (2015), pp. 345–364.
