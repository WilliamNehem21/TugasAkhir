Electronic Notes in Theoretical Computer Science 181 (2007) 35–47	
www.elsevier.com/locate/entcs

Verification of Peer-to-peer Algorithms: A Case Study
Rana Bakhshi1
School of Information and Communication Technology Royal Institute of Technology
Kista, Sweden
Dilian Gurov2
School of Computer Science and Communication Royal Institute of Technology
Stockholm, Sweden

Abstract
The problem of maintaining structured peer-to-peer (P2P) overlay networks in the presence of concurrent joins and failures of nodes is the subject of intensive research. The various algorithms underlying P2P systems are notoriously difficult to design and analyse. Thus, when verifying P2P algorithms, a real challenge is to find an adequate level of abstraction at which to model the algorithms and perform the verifications. In this paper, we propose an abstract model for structured P2P networks with ring topology. Our model is based on process algebra, which, with its well-developed theory, provides the right level of abstraction for the verification of many basic P2P algorithms. As a case study, we verify the correctness of the stabilization algorithm of Chord, one of the best-known P2P overlay networks. To show the correctness of the algorithm, we provide a specification and an implementation of the Chord system in process algebra and establish bisimulation equivalence between the two.
Keywords: Peer-to-peer systems, verification, process algebra.


Introduction
In recent years, great importance has been placed on distributed applications and P2P networks. Such systems are decentralized and highly dynamic, allowing an arbitrary number of nodes to join and leave the network. The essential operation in most P2P systems is the efficient location of data items, and the question whether a node is reachable in the network is a crucial problem. P2P network constructs

1 Email:ranab@kth.se
2 Email:dilian@nada.kth.se

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.01.052

and maintains an overlay network with specific topology depending on the applica- tion requirements. Robust P2P systems produce a desired topology starting from assumed initial state. For large systems, careful design is needed to ensure the correctness of stabilization algorithms. An example of such a system is Chord [14], a simple robust structured P2P system that implements a Distributed Hash Table (DHT) abstraction [3]. A DHT maps keys (data identifiers) to the nodes of an over- lay network and provides facilities for locating the current peer node responsible for a given node. Chord maintains its distributed state as nodes join and leave the system by executing the procedure called stabilization algorithm.
In the literature that describes such algorithms, e.g. the original Chord paper by Stoica et al. [15], correctness proofs are sketched at a high level of abstraction and tend to provide no operational semantics. On the other hand, model-checking techniques are not directly applicable to the verification of P2P systems as these systems are inherently dynamic and have infinite-state behaviour. Thus, a real challenge is to find a right level of abstraction at which to model the algorithms and perform the verification.
This paper summarizes the results of a formal verification of Chord’s stabiliza- tion algorithm. It focuses on the Pure Join Model of the Chord protocol [14] where an arbitrary number of nodes can join the network and each node runs the stabi- lization algorithm. We analyse the correctness of the stabilization algorithm using process algebra. The process algebra chosen is the π-calculus [8,13], which is a nat- ural language for modelling concurrent and distributed programs and particularly suitable for specifying mobile systems with dynamically changing communication topologies.
The main results of this paper are:
An abstract formulation of dynamic networks with ring topology (Sect. 4).
Modelling of both a specification and an implementation of the dynamic Chord system in terms of the π-calculus (Sect. 4).
Formal proof of equivalence of the specification and the implementation using weak bisimulation relation, thus establishing the correctness of Chord’s stabiliza- tion algorithm (Sect. 5).

Related Work.
All previous studies that model ring-based network with process algebra assume a fixed number of nodes in the network. A lookup algorithm of the DHT-based DKS system has been verified for a static model of the network using value-passing CCS [4]. Palamidessi [10] shows the leader election problem on a symmetric ring of processes with π-calculus with mixed choice. The paper makes an assumption about the existence of a special free outgoing channel for communication with the ”external world”. It also assumes the existence of a special subset from the set of names equipped with one-to-one mapping with the natural numbers to identify the individual processes in a network. Phillips et al. [11] take a similar approach to solve the same problem in the calculus of Mobile Ambients.

Other formal approaches, for instance the assertional proof method, has been used for the problem of concurrent maintenance of the ring topology in P2P net- works [7]. Krishnamurthy et al. [6] present an analytical study of Chord under churn using a master-equation-based approach.
Note that a formal justification that the model, proposed in our work, conforms the actual algorithm is beyond the ambitions of the present paper. But, the rela- tive simplicity of the algorithm, written in the syntax of the Erlang programming language, allows to relate both by simple inspection with a high level of confidence. The study by Noll and Roy [9] addresses the problem of mapping Erlang into the π-calculus.

Chord Protocol
In this section we briefly describe the Chord protocol, focusing on its stabilization algorithm. The details not relevant to this work, e.g. key’s assignment to a node, are left out of the paper and can be found in Stoica et al. [14].
Chord is a self-organizing distributed P2P lookup protocol that provides support for one op- eration: given a key, it maps the key onto a node (Fig. 1). Data location can be easily implemented on top of Chord by associating a key with each data item, and storing the key/data item pair at the node to which the key maps. Chord adapts ef- ficiently as nodes join and leave the system, and can answer queries even if the system is continu- ously changing.
Fig. 1: Chord ring
Identifier space
In Chord, every node has an n-bit identiﬁer
(ID), which is assumed to be unique and belongs to the set called an ID space.  Nodes’ ID space forms a ring of size n, denoted with Nn, where Nn :=
{k1, k2, ..., kn} ⊆ N, N is a set of natural numbers. The values sent and received are terms ranged over finite set of indices I ⊆ Nn. We let ☒ and  be addition and subtraction modulo n ranged over N and the result is always strictly less than the modulus.
When a new node joins the network, it should be placed between two nodes with proper IDs in the ring. The two basic neighbours that a node has are its predecessor and successor, chosen according to the partial order on I. A node is called a successor of the node with ID x in the set mˆ if it is the first node succeeding x in the
set mˆ and is defined as: succ(x, mˆ )= {y ∈ mˆ |(y x)= min{(z x)|z ∈ mˆ }∧mˆ ⊆ I}. The function succ: I×P(I) → I is well-defined, as z x = y x iff z  y = 0; P(I)
is a powerset of I. A predecessor of the node with ID x in the set mˆ is defined as:

pred(x, mˆ )= {y ∈ mˆ |(y  x)= max{(z  x)|z ∈ mˆ }∧ mˆ use mˆ ⊕ x to denote union mˆ ∪ {x}.
⊆ I} ∪ {x ∈/ mˆ
| ⊥}. We

The Stabilization Algorithm.
In order to assert that lookups execute correctly as the set of participating nodes changes, Chord must ensure that each node’s successor pointer is up to date. It does this using the stabilization algorithm, presented in Fig. 2.
Definition 2.1 A Chord ring is stable if predecessor(successor(u)) = u for all nodes u, and there is no node v such that u < v < successor(u).
The Pure Join model of the Chord protocol assumes the absence of nodes’ failure. To simplify the network representation this model doesn’t include successor lists and finger tables considered in the general model of the protocol. The stabilization scheme guarantees nodes to join a ring in a way that preserves reachability of existing nodes, even in the face of concurrent joins.


Fig. 2. Stabilization on Join algorithm
Although the stabilization algorithm of Chord is presented in ”RPC-style” in the original paper [14], any actual implementation would use asynchronous message- passing as it is the natural communication discipline for P2P systems [5]. This is reflected in our version of the stabilization algorithm, given in Fig. 2.
The algorithm is presented in the syntax of the Erlang programming language [1]. For a formal semantics of Erlang, see e.g. [12]. In Erlang, the communication be-

tween processes is asynchronous by means of process message queues (”mailboxes”). Briefly, n, n', pred, succ are node IDs; primitive → denotes ”then” like notation; I! defines sending event to the process I; assignment is denoted as :=; receive X end inspects the process incoming mailbox and delivers the first X pattern-matching element; loop X end executes X in loop. {”M”, I} represents a message of type M, sent by process with ID I.
When node n first starts, it runs join(n’), like the one shown in Fig. 2, where
n' is any known Chord node. The join() function asks n' to find the immediate successor of n, but does not make the rest of the network aware of n. All nodes execute code, given in lines 8–16 in Fig. 2, for appropriated response.
Each node in the system executes stab() periodically. When node n runs stab() (see Fig. 2), it asks its successor for the successor’s predecessor p, and decides whether p should be n’s successor instead. This would be a case if node p joined the system. Also, stab() notifies node n’s successor of n’s existence, giving the successor the chance to change its predecessor to n. The successor does this only if it knows of no closer predecessor than n.
This stabilization algorithm [14] guarantees the convergence of the Chord ring to a stable configuration, i.e. a ring topology, in spite of the concurrent joins if the system starts in stable configuration (Def. 2.1).


Fig. 3. Illustration of stabilization on join

Figure 3 illustrates an example of the join operation. Node 26 joins the system between nodes 21 and 32. The arcs represent the successor relationship. (a) Initially, node 21 points to node 32; (b) node 26, by executing join(), asks any known node to find its successor (i.e., 32) and points to it; (c) stab() updates the successor of node 21 to node 26.

π - calculus
As the Chord system is dynamic, i.e. nodes can freely join the network, our choice of modelling formalism is the π-calculus [8,13]. It is based on the concepts of processes and names. Communication between processes takes place on names (channels). A process Q that offers an output of the value v on the channel p, i.e. p⟨v⟩.Q, may
synchronise with a parallel process Q' that attempts to read from channel p, i.e.
p(z).Q'. Names sent as values can be used later as channels for communication. This feature allows processes to establish connections dynamically during computation.

This section briefly reviews the syntax and the operational semantics of the π- calculus. For more details refer to Milner [8] and Sangiorgi and Walker [13]. The section also draws inspiration from the prior work of Borgstro¨m et al. [4] on the static case of structured P2P systems.

Fig. 4. Syntax

Our model and verification of the Chord protocol’s stabilization scheme use a variant of the extended polyadic π-calculus (Fig. 3).

Operational Semantics.
The operational semantics of the π-calculus is defined by the commitment rules [8,13]:
	−	

(R-RCT-L)
'	'  τ
(1)
'

(p(z).Q + M )|(p⟨v⟩.Q + M ) →{v/z}Q|Q


(R-TAU)
	−	
τ.Q + M →τ Q
(2)


Q →π Q'

(R-PAR-L)	π	'
(3)

Q|R → Q |R


(R-RES)
Q → Q'
π
(4)
'

(νp)Q →(νp)Q
The symmetric versions of (1), (3) are omitted. Evaluation of expressions is a function [·]] : E π → N, where E π is a set of π-calculus expressions (Fig. 3):
[[e]] = {ki, if e = ki; ⊥, otherwise} Predicate eb(·) performs a boolean check:
eb(e1 = e2) is true iff [[e1]] = [[e2]]	(5)


eb(e1 ∈ [e2, e3]) is true iff [ei]] = ki ∈ I,
where i = 1, 3 and 0 ≤ k1  k2 ≤ k3  k2
(6)

To evaluate the expressions of if statements, π-calculus is extended with the reduc- tion relation >, satisfying the rules:
if ψ then Q else Q' > Q, if eb(ψ)	(7)
if ψ then Q else Q' > Q', if ¬eb(ψ)	(8) and a corresponding commitment rule:
Q > Q' Q' →π Q''

(R-RED)
Q →π Q
(9)
''


Bisimulation.
In the π-calculus, the standard equivalence relation on processes is bisimula- tion [8,13]. Intuitively, two systems are bisimilar if they can stepwise match each other’s actions. The difference between strong and weak versions is the view on silent actions, τ . Let Pπ be a set of π-calculus process expressions (Fig. 3).

Definition 3.1 For any prefix π, given in Fig. 3, the relations ⇒ and ⇒π
as follows:
are defined

P ⇒ Q means that there is a sequence of zero or more reactions P → ... → Q.
def	∗
Formally, ⇒ = → , the transitive reflexive closure of →.
π	p1	pn
Let π = p1...pn. P → Q means P ⇒ → P1... ⇒ → Pn ⇒ Q.
Formally,→π def	p1	pn
= ⇒ → ⇒ ... ⇒ → ⇒.
Definition 3.2 A binary relation S over set Pπ is a strong simulation if, whenever
π	'	'	π	'	'	'
P SQ, if P → P  then ∃Q . Q → Q and P SQ .

If both S and its converse are strong simulations then S is a strong bisimulation
and is denoted by ∼.
Definition 3.3 A binary relation S over set Pπ is a weak simulation if, whenever
P SQ,
if P ⇒ P ' then ∃Q'. Q ⇒ Q' and P 'SQ';
p⟨u⟩	'	'	p⟨u⟩	'	'	'
if P =⇒ P  then ∃Q . Q =⇒ Q and P SQ ;
p	'	'	p	'	'	'
if P ⇒ P  then ∃Q . Q ⇒ Q and P SQ .
If both S and its converse are weak simulations then S is a weak bisimulation and
is denoted by ≈.

Modelling
We now describe a formal model for the specification and implementation of the Chord protocol. The dynamic model of the system should clearly define the topol- ogy and express the joining of nodes to the system. Note that all channels are unidirectional and single purpose (i.e. each type of channel is used for one type of a message, shown in Fig. 7), as it is suggested for the base π-calculus.

Specification.
We specify the Chord protocol as a collection of nodes in a network, forming a ring topology and growing in size.
In general, nodes can join the network in arbitrary order. Since the internal structure of the system is hid- den from the observer, a major problem is how to specify the behaviour of a ring. The approach we propose is to add a token ring protocol, i.e. an abstract token to be passed clockwise along the ring, on top of the Chord protocol.
Process Ring represents a ring of nodes. Communi- cation between the nodes is not specified; thus, internal

links are restricted and unobservable. The only visible
Fig. 5: Process Ring

actions are the outputs on ports specific to every node, representing its ID (Fig. 5).

Ring(ki, m)  τ.idki .Ring⟨succ(ki, m), m⟩

+
kj ∈I\m
τ.Ring⟨ki,m ⊕ kj⟩	(10)


Here m represents a set of identifiers of the nodes already in the system; idki is an output port performed only by node ki and, therefore, denotes a node in an abstract way; succ(ki, m) is the successor of node ki from the set m; I is finite set of indices.
The Ring behaviour is expressed by the following non-deterministic choice:




Fig. 6. Modified Stabilization algorithm
A new node can join the ring allowing the network to grow by adding its ID to the set m. The procedure of acquiring the neighbours links is performed by τ . Here, we do not restrict the order, in which the nodes join the network, i.e. ∀kj ∈ I\m.
A node performs an output on its channel (idki ), preceded by τ , and passes the token to the closest neighbour, its successor. This forms a cycle of sequential outputs, where each successor is waiting for its predecessor to be enabled.

Implementation.
Chord is implemented as a product of concurrent mobile processes - one process per node, where all request/responses are handled according to the algorithm, given in Fig. 2.
As with our specification, we extend the Chord protocol’s implementation by adding a token ring port. This extension does not affect the stabilization algorithm as the reaction on this port doesn’t cause the reaction on the algorithm’s ports, i.e.
inx, inx, inx, inx.
1	2	3	4

π-calculus uses synchronous communication, implying that a deadlock or erro- neous behaviour may occur under some circumstances. This includes the case when a node tries to contact itself. Therefore, we have made two modifications on the original algorithm, shown in Fig. 2, to handle the case with one and two nodes in the network. The modified version of the stabilization algorithm appears in Fig. 6.
Process P is a node that is not in the network but may join it:

−−→
ki
−−→
−−→
ki
kj −→
−−→ −−→ −→ 



Here kj is the ID of a node that wishes to connect to the network and is not yet part of the ring; inki is the ”find successor” port of an arbitrary node in the Chord ring.
Process A, illustrated in Fig. 7, defines a network node with the encoded stabilization algorithm (Fig. 6). It stores information about itself, its successor and its predecessor:

A(id , in , in , in )  in1⟨in ⟩.A⟨id , in , in , in ⟩


Fig. 7: Process A

o −→z
z −→p
o −→o
−→z
−→p

+ in1(in ).in2⟨in ⟩.A⟨id , in , in , in ⟩

o −→z
z −→o
o −→o
−→z
−→p

+ in2(in ).(if z ∈ (o, s) then in3⟨in ⟩.A⟨id , in , in , in ⟩
o −→o −→s −→p
else (if z = o then A⟨id , in , in , in ⟩

s −→o
o −→o
−→s
−→p

o −→z
else in3⟨in ⟩.A⟨id , in , in , in ⟩)

+ in3(in ).(if p = ⊥∨ z ∈ (p, o)
z −→o

−→o
−→z
−→z

then (if (p = o) ∧ (s = o) then in3⟨in ⟩.A⟨id , in , in , in ⟩
o −→o −→s −→z

o −→o
−→s
−→p
else A⟨id , in , in , in ⟩)

else A⟨id , in , in , in ⟩)
o −→z
z −→s

−→o
−→s
−→p

+ in4(in ).(if z ∈ (o, s] then in4⟨in ⟩.A⟨id , in , in , in ⟩

s −→z
−→o
−→s
−→p

else in4⟨in ⟩.A⟨id , in , in , in ⟩)

o	o	o

−→o
−→s
−→p	s

+ in5.id .A⟨id , in , in , in ⟩|in5.0	(12)

−→x

x	x	x	x	x

where: in  = {x, in1 , in2 , in3 , in4 , in5 }.
o
−→o

Here o is ID of node, id
−→s
its special output port, in
−→p
ID and listening (in-) ports

of node; in
ID and in-ports for successor, in
ID and in-ports for predecessor.

Node A uses in- ports of its neighbours to send the messages. These links are acquired by performing the following actions (see (12) and Fig. 6):
o −→z
Wait for a ”find successor” message from the new node (in4(in )), get node’s ID
and in-ports; check if the successor of the new node is the successor and, if true,

z −→s
return the successor’s ID and in-ports to a new node (in4⟨in ⟩), or if false, pass
s −→z
the information about the new node around the circle to the successor (in4⟨in ⟩).
This fragment is presented by lines 10–18 in Fig. 6.
o −→z
Receive a ”request predecessor” message (in1(in )) from another node, put the
z −→p
predecessor information into a message and send this message back (in2⟨in ⟩).
For the code details, see lines 36–37 of Fig. 6.
o −→z
Listen for the ”response predecessor” message (in2(in )), check if the condition
z ∈ (o, s) is satisfied, notify a sender so that it becomes the node’s predecessor by sending its ID and in-ports and updating the successor information. If the check fails then confirm the successor to be its predecessor only if z = o. This corresponds to lines 24–27 in Fig. 6.
o −→z
Get notification from another node (in3(in )) with a node’s ID and in-ports, check
the condition p = ⊥ ∨ z ∈ (p, o) - if true, update the predecessor information; in addition, update the successor’s information and send the notification to it if p = o = s ; if false, ignore the notification. For the code details, refer to lines 38–43 of Fig. 6.
Request information from the successor by sending a ”request predecessor” mes-
s −→o
sage (in1⟨in ⟩). This is done according to line 22 of Fig. 6.
Receive a token (ino), release another one for the successor (ins.0) and signal on
		5	5
special port (ido).
Process Impl implements Chord protocol and consists of collection of nodes A, nodes P ready to join a network and a token, all running in parallel:


−−→ −−→ −−→
ki
Σ	−−→	kv

Impl(ki, m)  (νinkj , inki , inkl )((in5 .0)|(
kj ∈I\m kv∈m'
P ⟨inkj , in4 ⟩)|
(13)

|		A⟨idk '
−−→ −→ −→
−−→ −→ −→
kl


k ' ∈m''⊂m
i , inki' , ski' , pki' ⟩|
kl∈m' ⊆m
A⟨id
, inkl , skl, pkl ⟩)

'  −→x
−−−−−−−→
−→x
−−−−−−−→
''

where kj ∈ I\m and ki ∈ m ; s
= insucc(x,m) and p
= inpred(x,m); m
is a set

that contains all nodes that are connected but not settled in the Chord ring, i.e.
haven’t acquired the links; m' – a set of the nodes settled in the Chord ring, i.e. that have both neighbours. Note that m'' can be empty when all nodes are placed in the Chord ring and m = m' ⊕ m''.
Verification
We now present the results of a formal verification of Chord’s stabilization algorithm under the previously made assumptions. Verification gives us the confidence that the stabilization algorithm will eventually fix the immediate successor of each node (as we consider a Pure Join model) and the network will eventually form a ring topology again. Intuitively, the Chord ring becomes stable if all nodes will get

correct information about their predecessors, i.e. a node will get both right and left neighbours.
We verify the correctness of the implementation with respect to the specification by establishing their behavioural equivalence. If the two models are bisimilar then the algorithm works correctly, i.e. eventually yields a ring topology encompassing the new nodes that join the network.
The proof technique we use to show the specification (10) and implementation
(13) are (weakly) bisimilar is to prove that they are solutions of the same guarded systems of equations, and then to appeal to the Unique-Solution Theorem [8,13] for the extended π-calculus.
Theorem 5.1 Let Ring and Impl be deﬁned as above. Then
Ring ≈ Impl



The theorem is proved by showing that the specification (10) and the implemen- tation (13) solve the following system of guarded equations:



X(ki, m) ≈ τ.idki .X⟨succ(ki, m), m⟩ +
kj∈I\m
τ.X⟨ki,m ⊕ kj⟩	(14)

where ki ∈ m, kj ∈ I\m.
More details of the proof appear in the full version of this paper [2].

Conclusion
In this paper, we introduce an abstract model for structured P2P networks with a ring topology. Our choice of modelling formalism is the π-calculus, a calculus of mobile processes, and is based on the observation that P2P systems are of a highly dynamic nature, allowing nodes to join and leave the network at any time. We verify the correctness of Chord’s stabilization algorithm by establishing weak bisimulation between the specification of Chord as a ring network and the implementation of the stabilization algorithm, both modelled in the π-calculus.
The present case study shows that the π-calculus offers a suitable theory for the verification of relatively simple P2P algorithms. It extends previous results on the correctness of a lookup algorithm of another P2P system for the static case without node joins and failures [4].
Future work is needed to include other aspects of P2P networks, including pres- ence of failures in the network, adding finger tables and successors lists, etc. In addition, the π-calculus models can be formalized and the bisimulation proof can be carried out in a theorem proving system such as Isabelle/HOL.

References
J. Armstrong, R. Virding, C. Wikstr¨om, and M. Williams. Concurrent Programming in Erlang. Prentice Hall, 2nd edition, 1996.
R. Bakhshi and D. Gurov. Verification of Peer-to-peer Algorithms: A Case Study. Technical report, ICT, May 2006. http://www.nada.kth.se/∼ dilian/Papers/chord.ps.gz .
Hari Balakrishnan, M. Frans Kaashoek, David Karger, Robert Morris, and Ion Stoica. Looking up data in P2P systems. Communications of the ACM, February 2003.
Johannes Borgstr¨om, Uwe Nestmann, Luc Onana Alima, and Dilian Gurov. Verifying a Structured Peer-to-Peer Overlay Network: The Static Case. In Global Computing, pages 250–265, 2004.
Geoffrey Fox. Message Passing: From Parallel Computing to the Grid. Issue of Computing in Science and Engineering. IEEE Distributed Systems Online, 3(8):70–73, September/October 2002.
Supriya Krishnamurthy, Sameh El-Ansary, Erik Aurell, and Seif Haridi. A statistical theory of chord under churn. In 4th International Workshop on Peer-To-Peer Systems, Ithaca, New York, USA, February 2005.
Xiaozhou Li, Jayadev Misra, and C. Greg Plaxton. Brief announcement: concurrent maintenance of rings. In Soma Chaudhuri and Shay Kutten, editors, PODC, page 376. ACM, 2004.
Robin Milner. Communicating and mobile systems: the π-calculus. Cambridge University Press, New York, NY, USA, 1999.
Thomas Noll and Chanchal Kumar Roy. Modeling Erlang in the π-calculus. In ERLANG ’05: Proceedings of the 2005 ACM SIGPLAN workshop on Erlang, pages 72–77, New York, NY, USA, 2005. ACM Press.
Catuscia Palamidessi. Comparing the expressive power of the synchronous and the asynchronous pi- calculus. In Symposium on Principles of Programming Languages, pages 256–265, 1997.
I.C.C. Phillips and M.G. Vigliotti. Leader election in rings of ambient processes. In Proceedings of Express: Workshop on Expressiveness in Concurrency, London, August 2004, volume 128 of Electronic Notes in Theoretical Computer Science, pages 185–199. Elsevier, 2005.
Lars–˚Ake Fredlund. Framework for Reasoning about Erlang Code. PhD thesis, Royal Institute of Technology, Kista, Sweden, August 2001.
Davide Sangiorgi and David Walker. π-Calculus: A Theory of Mobile Processes. Cambridge University Press, New York, NY, USA, 2001.
Ion Stoica, Robert Morris, David Karger, M. Frans Kaashoek, and Hari Balakrishnan. Chord: A scalable peer-to-peer lookup service for internet applications. In Proceedings of the 2001 conference on applications, technologies, architectures, and protocols for computer communications, pages 149–160. ACM Press, 2001.
Ion Stoica, Robert Morris, David Liben-Nowell, David Karger, M. Frans Kaashoek, Frank Dabek, and Hari Balakrishnan. Chord: A scalable peer-to-peer lookup service for internet applications. Technical report, MIT, January 2002.
