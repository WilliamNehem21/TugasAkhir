

Electronic Notes in Theoretical Computer Science 260 (2010) 73–89
www.elsevier.com/locate/entcs
Global Coordination Policies for Services 1
Vincenzo Ciancia2 Gian Luigi Ferrari2 Roberto Guanciale3
Daniele Strollo2,3

Abstract
An important issue of the service oriented approach is the possibility to aggregate, through programmable coordination patterns, the activities involved by service interactions. Two different approaches can be adopted to tackle service coordination: orchestration and choreography. In this paper, we introduce a formal methodology purposed to handle coordination among services from the perspective of a global observer, in the spirit of choreography models. In particular, we address the problem of verifying compliance and consistency between the design of service interactions and the choreography constraints.
Keywords: Service-oriented architectures, coordination, sessions, conformance


Introduction
The web service protocol stack (e.g. WSDL, UDDI, SOAP) provides basic sup- port for the development of service-oriented architectures by exploiting facilities to publish, discover and invoke network-available services. The service protocol stack has been extremely valuable to highlight the key innovative features of the service oriented computing approach.
Most of the current development methodologies and standards are focused on composition of services. Two different approaches can be adopted: orchestration and choreography. In the orchestration, an intermediate component, the orches- trator is responsible to arrange service activities according to the work-flow plan. This strategy provides a local view of the participants. From the other hand, the choreography model involves all parties and their associated interactions providing a global view of the system. Relevant standard technologies have emerged to model
coordination policies. Among them, particular relevance is given to the Business Process Execution Language (BPEL) [22], for the orchestration, and Web Service

1 Research partially supported by the EU FP6-IST IP 16004 SEnSOria
2 Universit`a degli Studi di Pisa, Dipartimento di Informatica
3 Institute for Advanced Studies IMT Lucca

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.12.032

Choreography Description Language (WS-CDL) [24], for the choreography. How- ever, it is not infrequent that such standards have drawbacks. In fact, constructs are often informally specified. This usually leads to ambiguities or redundancy. Even though research is still underway, several research efforts are currently de- voted to provide foundational models for orchestration and choreography, including contributions such as COWS [18], Global Calculus [5], λreq [2] ORC [21], SCC [3], SOCK [15], and [17]). A well known paradigm for specifying and programming distributed systems is the event notiﬁcation paradigm (EN, for short), where dis- tributed computational components can act as publishers and/or subscribers. When a component intends to send data to or requests a service from other components, it issues an event that eventually shall trigger a reaction from subscribers that pre- viously subscribed for such kind of events. The EN paradigm provides a suitable framework to deal with service oriented architectures (SOAs) that require compo- nents to be loosely coupled. Specifically, the EN paradigm features high level coordi- nation mechanisms that allow programmers/designers to decouple components and rely entirely on event handling. In [9] a middleware for service coordination called Java Signal Core Layer (JSCL) has been introduced. The middleware consists of a set of API for programming services interacting through suitable events. JSCL is equipped with a graphical environment, an Eclipse plug-in, providing capabilities for designing components and their inter-connections. The JSCL API’s are available at www.tao4ws.net. A distinguished feature of JSCL consists of the strict interplay among formal semantic foundations, implementation pragmatics and experimental evaluation of the resulting programming constructs. More precisely, all the pro- gramming facilities available in JSCL have been motivated semantically. At the abstract level, the middleware takes the form of the Signal Calculus (SC) [9,10,8]. The SC calculus is a variant of the π-calculus [23] with explicit primitives to deal with event notification and component distribution. The SC & JSCL framework allows one to specify and program services coordination policies (orchestration and choreography) relying on event notification only. Moreover, it features sessions as a mechanism to synchronize workflows of distributed and independent components. Remarkably, the middleware does not assume any centralized mechanism for pub- lishing, subscribing and notifying events. Instead, each subscriber explicitly defines the class of events it is interested in. In [20] this pattern is referred to as non brokered, in contrast with the brokered solutions that implements publish/subscribe mechanisms on top of a classification of signals without taking into account the involved components. Basically, brokered solutions rely on global state space e.g. Linda tuple spaces [14]. All SC notions are reflected in the JSCL API’s. Indeed, the design choices underlying the JSCL implementation have been formally motivated in terms of the SC calculus. Hence, SC and JSCL can be regarded as a full-fledged framework for specifying, verifying and programming coordination policies of dis- tributed services.
In SC, and coherently in JSCL, components are thought of as isolated and their behavior is independent from the network context they are going to operate. Only once plugged into the network, components receive information regarding their

neighbors, namely the subscribers that are directly connected. This corresponds to a local view of coordination. In this paper, we introduce a formal methodology for the SC & JSCL framework with the aim of managing coordination among services from the perspective of a global observer in the spirit of choreography models. In particular, we address the problem of verifying compliance and consistency between the design of service interactions and the choreography constraints.
Our approach is based on process calculi techniques. We introduce a process calculus, called Network Coordination Policies (NCP) that extends and equips our framework with a choreography model. The two calculi (SC and NCP) lay at two dif- ferent levels of abstraction. The former is tailored to support the (formal) design of services, the latter is the specification language to declare the coordination policies. Policies take the form of processes that represent the behavior that is seen by an observer standing from a global point of view, thus seeing all the public interactions taking place on the network infrastructure. Hence, each NCP process describes the interactions that are expected to happen, and how these are interleaved. Indeed, certain features can be described at both levels: the NCP specification declares what is expected from the service network infrastructure, the SC design specifies how to implement it. Formally, this means that the two calculi share the same computa- tional paradigm and the two semantics are related by a correctness result: for each SC network, there is an NCP policy that reflects all the properties of the network. We establish this result by the introduction of a semantics-based transformation mapping a SC design into a NCP network. We show that the transformation is fully abstract with respect to an abstract semantics notion. The converse is not true : not every coordination policy that one can specify is implementable.
Our first contribution is the introduction of the NCP process calculus. As it happens in the π-calculus, NCP features scope extrusion as fundamental capability to model fresh resource generation. However, names that are object of freshness and scope extrusion are not pure names, but rather they carry a network topology which is considered fresh and is extruded when received. On the one hand, this comes from the fact that the basic structure of NCP are network topologies and not just channel names. On the other hand, this provides a model for private subnetworks in a process calculus. While not adding or removing any expressive power to the calculus, this “network binding” operation is a natural model for all these real-world situations in which an entire sub-network can be hidden or discovered, independently from the presence of a single access point like it happens in the π-calculus. As an example, we can mention virtual private networks (VPNs).
Our second contribution consists of the definition of the abstract semantics for the NCP calculus. The abstract semantics allows us to reason about the behavior of SC services when plugged into suitable network contexts with certain choreography constraints. In particular, it distinguishes services that behave differently in the same network context. This feature is useful to evaluate how the invocation of a service is successful (e.g. meets the SLA constraints) only within certain kinds of choreographies. Technically, the NCP asbtract semantics is inspired by the “directed HT bisimulation” for the asynchronous π-calculus as presented in [16,1].

The main result of this paper is the embedding of SC in NCP. This result can be exploited to bridge the gap between the choreography model and the actual design: conformance of an SC design with respect to an NCP specification is formally proved by checking weak bisimilarity between them.

Preliminaries: The Signal Calculus
In this section we review the syntax and the operational semantics of the Signal Calculus (SC). We assume a countable set T of topic names (ranged over by τ ) and a countable set of component names A, ranged over by a, b, c, .... We adopt the notation a to denote a set of component names.
The calculus is centered around the notion of component. A component is the container of a service. A component is uniquely identified by a name a (the public address of the service) and has an internal behavior. Components exchange mes-
sages, called signals. Signals are pairs of topics τ ◯c τ', where the first element is the
signal type (a unique name identifying the kind of event) and the second element is the session identifier. Session identifiers and event kinds are freely interchange- able, and can be dynamically generated. When an event is raised by a component
(the publisher ), it is notified to the components interested in handling it (the sub-
scribers). Notice that notifications are not anonymous, namely subscription relates both the event topic and the publisher. Therefore, components behave as reac- tive agents that declare the set of event kinds they are interested in together with the associated tasks to perform for their handling (reactions), and the set of target components for the notification delivery (flows). The calculus provides two different kinds of reaction: the lambda reactions and the check reactions. Lambda reactions are activated independently from the signal session, while check reactions handle signals belonging to a well defined session. Lambda reactions, once installed, remain persistent in the component interface, the check reactions, instead, once executed, are removed from the component interface.
We now introduce the syntax of the calculus. We start by illustrating the syntax of reactions.
R	::=	0  |  ⟨ρ⟩→ B  |  R|R
where the input preﬁx ⟨ρ⟩ is either a lambda reaction (τ ◯c λτ') or check reaction (τ ◯c τ').
The lambda reaction τ ◯c λτ' → B is triggered by signals having topic τ inde- pendently from their session. Conversely, the check reaction τ ◯c τ' → B reacts only to signals having topic τ issued for the session τ'. Once a reaction to a certain
signal occurs, the behavior B starts its execution in parallel with the already active behavior. Notice that for a lambda reaction the name τ' is bound in the behavior B, while, for a check reaction, it is free. Reaction composition allows a component
to react to different kinds of signal in different ways.
Now, we introduce the syntax of behaviors, i.e. the constructs components ex- ecute to deal with coordination issues. Behaviors are described by the following grammar:



B	::=	out⟨τ ◯c τ'⟩.B	(Signal emission)
|	(ντ )B	(Topic restriction)
|	rupd (R) .B'	(Reaction update)
|	fupd(F ).B'	(Flow update)
|	B | B'	(Parallel composition)
|	0	(Empty behavior)
where a flow F is a set of pairs of the form (τ, b) such that τ is a topic and b a component name.
The signal emission out⟨τ ◯c τ'⟩.B spawns into the network a signal of topic τ and session τ', and then continues as B. Topics can be dynamically generated via the restriction operator acting as a binder, namely, the occurrences of τ in B are bound.
The calculus provides two primitives to allow a component to dynamically change its interface: the reaction update rupd (R) .B' and the flow update fupd(F ).B'. The former installs a new reaction R in the interface part of the component and the
latter appends F to its flows. The remaining constructs have the obvious meaning.
Networks describe the component distribution and the signals exchanged among components.

N ::=	∅ |	a[B]R  |	N	N  |	⟨τ ◯c τ'⟩@a  |	(ντ )N

A network can be empty ∅, a single component a[B]R having name a, installed reactions R, flow F and behavior B, or the parallel composition of networks N  N'. Networks carry signals exchanged among components. The signal emission spawns into the network, for each target component, an “envelope” ⟨τ ◯c τ'⟩@a containing
the signal and the target component name a. The last operator allows one to extend the scope of dynamic topics within networks. Hereafter, we assume that components are uniquely identified by their names. Hence, we will always consider well formed networks, namely networks where components with the same name are not allowed.


SC Operational Semantics
We briefly outline the SC reduction semantics as given in [10]. We first define structural congruence. This is the smallest equivalence relation that satisfies the commutative monoid laws (associativity, commutativity and 0 being an identity) for (R, |, 0), (B, | , 0) and (N, , ∅). Additionally, the following laws hold, where we

denote with f n(−) the free names of any entity:

(ντ )0 ≡ 0,	((ντ )B) | B' ≡ (ντ )(B | B'), if τ ∈/ f n(B')
(ντ )∅≡ ∅,	((ντ )N )  N' ≡ (ντ )(N  N'), if τ ∈/ f n(N ')
(ντ )(ντ')B ≡ (ντ')(ντ )B	(ντ )(ντ')N ≡ (ντ')(ντ )N

and, if B ≡ B',
τ ◯c λτ' → B ≡ τ ◯c λτ' → B'	(1)
τ ◯c τ' → B ≡ τ ◯c τ' → B'	(2)
where τ' can be alpha converted in (1). Finally, in the case of networks, the following equations hold:


F1 ≡ F2	B1 ≡ B2	R1 ≡ R2
a[B ]R1 ≡ a[B ]R2	,
τ ∈/ f n(R) ∪ f n(F ) ∪ {a}
.
a[(ντ )B]R ≡ (ντ )a[B]R

F1
F2	F	F


The reduction semantics describes how components can communicate and up- date their interfaces. The reduction relation → is depicted in Figure 1. The intuitive interpretation of the reduction rules is straightforward. Notice that rule emit intro- duces in the network a set of envelopes, i.e. an envelope for each of the subscriber components. The rule exploits the auxiliary operator (F (τ )), defined as follows:

F (τ ) = {b | (τ, b) ∈ F}

The rules check and lambda describes the activation of check reactions, that require the exact match of the session identifier, and of lambda reactions, receiving the session identifier as argument.


The choreography model
In this section we introduce the syntax and the operational semantics of the Network Coordination Policy calculus (NCP). This calculus has been specifically designed to be the choreography model for SC. Basically, NCP is an extension of the asynchronous π-calculus supporting multi-cast communication and multi-layered dynamic topolo- gies with hidden network layers. Network layers are first order entities: they can be dynamically created and exchanged in communications. Many other process calculi has been designed to deal with process distribution. The novel feature of NCP is the capability to restrict a part of the network topology.



N → N'

N	M → N'	M
N ≡ N'	N' → M'	M' ≡ M
npar)		 (struct)
N → M

a[B]R −→ a[B']R'
N → N

F	F'	(par)

1	(new)

a[B | B ]R −→ a[B' | B ]R'
(ντ )N → (ντ )N

1 F	1 F'	1

a[rupd (R') .B]R → a[B]R|R'	(rupd)	a[fupd(F').B]R → a[B]R
(fupd)

F	F	F	F∪F'
	F (τ ) = {b1,..., bn}	 (emit)
a[out⟨τ ◯c τ'⟩.B]R → a[B]R  ⟨τ ◯c τ'⟩@b1  ...  ⟨τ ◯c τ'⟩@bn
F	F

⟨τ ◯c τ'⟩@a	a[B]τ⃝c τ'→B'|R → a[B|B']R
(check)

F	F

⟨τ ◯c τ'⟩@a	a[B]τ⃝c λτ1→B'|R → a[B|{τ'/τ }B']τ⃝c λτ1→B'|R
(lambda)

F	1	F


Fig. 1. Operational semantics
The syntax of the language is defined as follows:

P	::=	P  P	|  (ντ : T ) P	| skip.P	|
Σi∈I ρi@ai.Pi | ⟨τ ◯c τ'⟩@a | ττ'@a.P	| fupd(F )@a.P ρ	::=	τ (τ') | ττ'
where T is a set of pairs of the form (a, b), a /= b, called linkage. Finally, I is a finite set of indices. We use ∅ as a shorthand to denote the empty guarded sum
Σi∈∅ ρi@ai.Pi.
A NCP process is called a coordination policy. We use the word policy to em-
phasize the fact that the calculus has been introduced to specify and constrain the behavior of SC networks.
A policy ρ@a.P describes from a global standpoint the execution of the reaction ρ by the component a, with continuation P . Besides reactions, we have other forms of prefixing. Prefix τ (τ') describes the action of receiving any topic as input by
listening on topic τ . We call this kind of action lambda action because it is tailored
to describe SC lambda reaction. Similarly, Prefix ττ' describes the action of receiving signals having topic τ and session τ'. We call check this action. As it will be clearer later, the two actions above, lambda and check, provide NCP with a (restricted) form
of recursion and a (restricted) form of matching. The action ττ'@a.P describes the emission of an envelope on session τ' by the component a for those services that

are listening on topic τ . The action fupd(F ) allows one to describe the operation that updates the linkages of a SC component. The envelope ⟨τ ◯c τ'⟩@a represents a message (whose destination is a) still pending in the network. Notice that the
source component that generated the envelope is not remembered. (ντ : T ) P defines the scope of the topic τ , with an associated linkage T that represents a hidden network layer, in the policy P . The topic τ is assumed to be fresh. For example, the restriction (ντ : {(a, b)}) P extends the network topology with a new linkage between a and b for the new topic τ . Notice that this mechanism permits to express network hiding, via the name restriction, and multi layer network scoping, via the name binding. Finally the policy skip.P , represents the execution of an internal activity before the execution of P .
Free names fn(P ) and bound names bn(P ) of a policy are defined as usual. The operational semantics of NCP defines the meaning of policies from a global standpoint. Since policies describe not only the interactions among components, but also reflect the structure of the event topology within a network, we need to introduce a suitable notion of state.
Definition 3.1 We deﬁne the topic-driven topology to be a set of triples (a, τ, b) where a, b are component names and τ is a topic name. Hereafter, we use μ to range over topic-driven topologies. We introduce some useful auxiliary operations on topic-driven topology.
Let μ be a topic-driven topology, let a be a component name and F be a flow. Deﬁne μ ⊕ (a × F ) to be the topic-driven topology μ ∪ {(a, τ, b) | (τ, b) ∈ F}.
Let μ be a topic-driven topology, let τ be a topic. Deﬁne μ(τ ) to be the linkage
{(a, b) | (a, τ, b) ∈ μ}. Similarly, the function μ(τ )(a) is deﬁned to the the set
{b | (a, τ, b) ∈ μ}.
Let μ be a topic-driven topology, let τ be a topic name and T be a linkage. Deﬁne μ g (τ × T ) to be the topic-driven topology μ − {(a, τ, b) | (a, b) ∈ T}, where − denotes the difference between sets.
Let μ be a topic-driven topology, n(μ) denotes the set of all names occuring in μ.
Definition 3.2 Let be μ a topic-driven topology and P a coordination policy, then the pair (μ, P ) is called NCP state.
We now introduce the labelled transition system semantics of NCP. The opera- tional rules are similar in spirit to the rules given by Honda and Tokoro [16], and Amadio, Castellani and Sangiorgi [1] in the case of the asynchronous π-calculus. Our operational semantics exploits the notion of topic-driven topology to manage explicitly the global view of a choreography. Indeed, the evaluation of a coordina- tion policy depends on the state of the topology of the network. This enables us to model in a natural way multi-cast communication. For example, listening on the
topic τ in the action ττ' is not sufficient to receive messages on that topic. In fact,
we require that the topology must link the sender and the receiver for the topic τ .
We start by introducing the set of actions α.



α	::=	ϵ  |  ττ'@a  |  (ττ'@a)  |  ⟨τ ◯c τ'⟩@a  |  ⟨τ ◯c (τ' : T )⟩@a

The action ϵ models unobservable activities, like internal communications. Ac- tion ⟨τ ◯c τ'⟩@a is the free (asynchronous) event notification of kind τ , session τ' and destination a. Action ⟨τ ◯c (τ' : T )⟩@a represents a bound event notification; the linkage T is exploited to delimit the scope of the event in the network. Action ττ'@a is a free reaction activation and is inspired by the semantics of the asyn- chronous π-calculus in the early instantiation style. Finally (ττ'@a) represents the action of receiving a message and storing it in parallel with the current process.
This action is observable in any system, thus including the empty policy. Hereafter, we use n(α) to denote the set of names in the action α.
The labelled transition system semantics of NCP is defined by the rules depicted in Figure 2, where ≡n denotes the syntactic identity modulo α−conversion. We use
μ, P −→α  μ',P' to represent that the coordination policy P , plugged in the topology
μ, by performing the action α evolves to the policy P' and the network topology to μ'. For simplicity, we omit symmetric rules for par, com, close, new and open. Rules struct and par have the standard meaning. Skip represents an internal computation. Fupd extends the topic-driven topology μ with the linkages outgoing from a derived
from the flow information F . The rule emit models the asynchronous multi-casting communication. The rule checks the state of the topology (μ(τ )(a)) to derive the set of subscriber components for the topic τ . Then, for each subscriber one envelope is spawned into the network. The rule notify describes the notification of an envelope to a component and corresponds to the output rule for the asynchronous π-calculus.
Rules check and lambda model the execution of reactions. If a check reaction is selected (ρj = ττ'), the policy can read only envelopes having the same topic and session. If a lambda reaction is selected (ρj = τ (τ')), the policy can read any signal having the topic τ independently from the identity of the received session τ' and from the linkage T (τ' and T act as variables). In other words, it performs an early
instantiation on both the received session and the associated linkage. Notice that, after the communication has occurred, all competitor inputs are garbaged. The rule async, as in the asynchronous π-calculus, permits any policy to perform an
input, simply storing the received message for subsequent usages (thus allowing to arbitrarily delay the communication). The rule com allows the communication of a session (τ') that is not under the scope of a restriction. The rule new allows one to extend the topology (μ ⊗ (τ × T )) for a fresh generated topic (τ ). Notice that the
rule hides the updates of the topic topology dependent from the generated name outside its scope (μ' g (τ' × T ')). Finally the rules open and close model the scope extrusion of the name (τ'), and of its bound communication.

Examples
To better highlight the main features of NCP, we introduce two simple examples. We also refer the reader to [6] for an example on the kind of situations that we would



μ, skip.P −→є  μ, P
(skip)


μ, fupd(F )@a.P −→є  μ ⊕ (a × F ),P 
(fupd)

μ(τ )(a) = b	j ∈ I	pj = ττ'

'	є	'
(emit)
Σ

ττ'@a
(check)

b∈b
i	i	i	j
i∈I

j ∈ I	pj = τ (τ'')	(

lambda)

μ, Σ
i∈I
ττ'@aj
pi ai.Pi −−−−→ μ ⊕ τ
× T ), {τ'/τ
''}Pj  pj@aj.Pj


c  ' @

⟨τ ⃝c τ'⟩@a
(notify)

(ττ'@a)
(async)
c  '

μ, ⟨τ◯τ ⟩
a −−−−−−→ μ, ∅
μ, P −−−−−→ μ, P	⟨τ ◯τ ⟩@a

τ' ∈ n/ (μ)	μ ⊕ (τ'
⟨τ ⃝c τ'⟩@a
× T ,P −−−−−−→ μ ⊕ τ
× T ),P'

(open)

μ, ντ' : T
⟨τ ⃝c (τ':T )⟩@a
P −−−−−−−−−→ μ ⊕ τ
× T ),P'

ττ'@a	'	'	⟨τ ⃝c (τ':T )⟩@a	'	'
μ, P1 −−−−→ μ , P1	μ, P2 −−−−−−−−−→ μ , P2 (close)

μ, P1  P2 −→є  μ, ντ' : T (P '  P')
τ ∈ n/ (α) ∪ n(μ)	μ ⊕ (τ × T ),P −→α  μ',P'	T ' = μ'(τ )

μ, (ντ : T ) P −→α  μ' g (τ × T '), ντ : T ' P'
(new)


ττ'@a	'	⟨τ ⃝c τ'⟩@a	'
μ, P1 −−−−→ μ, P1	μ, P2 −−−−−−→ μ, P2 (com)
μ, P1  P2 −→є  μ, P' 	'

μ, P −→α  μ',P'
μ, P ≡
μ ,P 
−→α
μ ,P ≡
μ',P'

(par)
n  1	1
2	2	n
(struct)

μ, P  P1 −→α  μ',P'  P1
μ, P −→α
μ',P'


Fig. 2. LTS semantics

like to model using SC and NCP, and to [11] for more formal examples of using the
SC/NCP framework to solve problems related to refactoring of code.

NCP hidden communications
Let μ be a topic topology. The following NCP state describes the evolution of a component b raising an event having the same session as the one received by a:
μ, τ τ' @a.skip.τ1τ'@b

Intuitively, this specification models a coordination policy where the component a can receive signals having topic τ . After some internal activity has taken place, the component b raises a signal having the same session (τ') of the one received by

a. This behavior constrains the components a and b to exchange the name of the received session τ', however this communication is not explicitly represented.
The operational rules lambda, skip and emit detail the required behavior. The lambda rule handles the early instantiation of the input, allowing the transition for any name τ ''. Notice that the lambda reaction remains active and that the envelopes spawned by the component b have the same session of the received one. The actual
operational derivation is given below.


μ, τ (τ') @a.skip.τ1τ'@b
rr''@a  є  є
−−−−→−→−→
μ, τ (τ') @a.skip.τ1τ'@b   c∈μ(r )(b)⟨τ1◯c τ ''⟩@c


NCP scope of topology
Let μ = {(a, τ, b)}) the topology describing a single connection from the component
a to the component b for the topic τ . Let us consider the following NCP state.


μ, τ (τ1) @b.τ1τs@a  ( ντ' : ∅ fupd({(τ', b)})@a.⟨τ ◯c τ'⟩@b)

When the coordination begins, the topology for the topic τ' is hidden outside the right part of the parallel policy. The reception of the signal for the component b (by the lambda reaction) performs the extrusion of the name τ' within the topology. Hence, a can emit signals having τ' to the recipient b.
The behavior described above is represented by the following operational deriva- tion.

μ, fupd({(τ', b)})@a.⟨τ ◯c τ'⟩@b
−→є
μ ⊕ {(a, τ', b)}, ⟨τ ◯c τ'⟩@b
μ, (ντ' : ∅) fupd({(τ', b)})@a.⟨τ ◯c τ'⟩@b
−→є
μ, (ντ' : {(a, b)}) ⟨τ ◯c τ'⟩@b
μ, τ (τ1) @b.τ1τs@a  ((ντ' : ∅) fupd({(τ', b)})@a.⟨τ ◯c τ'⟩@b)
−→є
μ, τ (τ1) @b.τ1τs@a  ((ντ' : {(a, b)}) ⟨τ ◯c τ'⟩@b)

Then the two parallel policies can communicate, extruding the τ' linkage:







μ, τ (τ1) @b.τ1τs@a
rr'@b
−−−→
μ ⊕ {(a, τ', b)}, τ'τs@a
μ ⊕ {(a, τ', b)}, ⟨τ ◯c τ'⟩@b
⟨r ⃝c r'⟩@b
−−−−−−→
μ ⊕ {(a, τ', b)}, ∅


μ, (ντ' : {(a, b)}) ⟨τ ◯c τ'⟩@b
⟨r ⃝c (r':{(a,b)})⟩@b
−−−−−−−−−−−−→
μ ⊕ {(a, τ', b)}, ∅



μ, τ (τ1) @b.τ1τs@a  ((ντ' : {(a, b)}) ⟨τ ◯c τ'⟩@b)
−→є
μ, (ντ' : {(a, b)}) (τ'τs@a  ∅)

Bisimulation Semantics
To conclude this section, we introduce a black-box semantics of NCP, in the form of a bisimulation relation. Honda-Tokoro [16] and Amadio et alia [1] have studied bisimilarity for asynchronous calculi. We use these results (in particular, the directed HT labelled transition systems from [1]) to define our bisimulation semantics.
Following these approaches, in the bisimulation game, any process can act as a “buffer” that reads any possible message and stores it without consuming the message. This is done, in our case, by rule async. On the other hand, “effective” inputs that actually consume messages are not observed at all in the bisimulation game, whereas synchronizations induced by these inputs are. Thus, in defining bisimilarity, we keep into account the transitions induced by the rule async, but not those obtained by check or lambda.
Definition 3.3 Given two coordination policies P1 and P2, and two topic topologies μ1 and μ2, the bisimulation relation ∼ is the greatest symmetric relation such that, for each (μ1, P1) ∼ (μ2, P2), the following holds:

For each transition μ1, P1 −→α
μ' ,P', with α ∈ {ϵ, ⟨τ ◯c τ'⟩@a, (ττ'@a)} there is a

transition
α	'	'
1	1
'	' )	( '
' ).

μ2, P2 −→ μ2, P2 and (μ1, P1
⟨r ⃝c (r':T )⟩@a
~ μ2, P2
'	'	'

For each transition μ1, P1 −−−−−−−−−→ μ1, P1 with τ ∈/ fn(P2), there is a transi-

tion
⟨r ⃝c (r':T ')⟩@a	'	'
'	'	'	'

μ2, P2 −−−−−−−−−→ μ2, P2 and (μ1, P1) ∼ (μ2, P2).
A key difference between NCP and the asynchronous π-calculus is the awareness of topic topologies in the semantics. However, it would be too restrictive to require that only policies with the same topology can be bisimilar. For example, the empty network is bisimilar to itself under any topology. This is also reflected in the definition of the clause for the bound output: when a bound output transition is matched in the bisimulation relation, the two hidden topologies associated to the

transition are not taken in account, and, therefore, can be different.
The weak transition relation is defined in the standard way:

μ, P =⇒є  μ',P'	iff μ, P (−→є )∗μ',P'

μ, P =α⇒ μ',P'	iff μ, P =⇒є
. −→α
. =⇒є
μ',P' (for α /= ϵ)


Finally, the definition of weak bisimulation (≈) is obtained by replacing the strong labelled transition with the weak ones in Definition 3.3. Obviously μ, P ∼ μ',P' implies that μ, P ≈ μ',P'.


Checking Choreography
In this section, we introduce a formal methodology to verify correctness of a network of SC components against global coordination policies as given by NCP specifications. The first step of our methodology consists of providing an encoding from SC networks to NCP policies. The basic idea of the encoding is to transform SC reactions into NCP transitions labelled with ϵ.
The encoding function B)a takes a SC behavior B, localized within the compo- nent a, and maps it into a NCP policy. This function is defined as follows:

 0)a = ∅	 B | B')a = B)a   B')a

 (ντ )B)a = (ντ : ∅) B)a	 out⟨τ ◯c τ'⟩.B)a = ττ'@a. B)a


 rupd (R) .B)a = skip. R)a   B)a	 fupd(F ))a = fupd(F )@a. B)a

The function R)a takes a SC reaction R, installed in the interface of the component
a, and maps it into a policy. The function is defined as follows:

 0)a = ∅	 R|R')a = R)a   R')a

 τ ◯c τ' → B)a = ττ'@a. B)a	 τ ◯c λτ' → B)a = τ (τ') @a. B)a

Finally, the function N ) takes a SC network N and maps it into a NCP state. The function is defined as follows:



 ∅) = ∅, ∅	 ⟨τ ◯c τ'⟩@a) = ∅, ⟨τ ◯c τ'⟩@a


 N ) = μ, P	 N') = μ',P'
 N	N') = μ ∪ μ',P	P'
 N ) = μ, P	T = μ(τ )


 (ντ )N ) = μ g (τ × T ), (ντ : T ) P


 a[B]R) = μ, B)a   R)a where μ = ∅⊕ a × F

The correctness of the encoding is ”up-to” bisimilarity as shown by the following theorem.
Theorem 4.1 Let N and N' be SC networks. It holds that N → N' if and only if
 N ) −→є  (μ, P ) and (μ, P ) ∼ N')
Proof. (outline) The proof is done by induction on the structure of SC networks (“if” side), and by induction on SC transition rules (“only if” side) and is quite straightforward. The case of parallel composition makes use of a weakening lemma that shows compositionality of NCP bisimulation with respects to network contexts:
if (μ, P ) ∼ (μ',P'), then for every graph σ we have (μ ∪ σ, P ) ∼ (μ' ∪ σ, P'). 
The previous theorem allows us to derive the choreography model of a SC net- work. The next step of our methodology consists of making verification to be com- positional. Once a choreography has been verified, it should be possible to “plug” it into a distributed network of components, without altering verified properties. This is formalized in the rest of this section.
First, we have to define SC network contexts. We use the notions of occurrence
of a symbol in a term, and of substitution that can be defined in the standard way.
Definition 4.2 The set C of one-hole SC network contexts is deﬁned as the least subset of terms generated by the following grammar, where the number of occurrences of the placeholder ∗ is one.
C ::= ∅ | a[B]R  | C	C  |  ⟨τ ◯c τ'⟩@a  |  (ντ )C  |  ∗
Assume that C ∈ C, and let N be a SC network. The application C [N ] of C to
N is deﬁned as the syntactic substitution of the single occurrence of ∗ in C with N.
We have the following compositionality result.
Theorem 4.3 Let N1 and N2 be SC networks such that  N1) ∼  N2). For all
C ∈ C, it holds that  C [N1]) ∼ C [N2]).
Proof. (outline) The proof is done by induction on the structure of contexts, and by coinduction on the bisimulation relation. It is easy to see that only two kinds of one-hole contexts are possible, namely (ντ )∗ and N  ∗, for N network and τ topic name. The interesting context is the context of the form (ντ )∗, and in particular



Fig. 3. Conformance to specification in model driven development

when the open rule is considered in the coinduction scheme, the issue being that the graph topology is affected. However, in the reached states (by a bound output transition) the bisimulation relation is restricted to those observations whose subject is not the restricted name, thus it is preserved in one step, and then by coinduction we obtain the proof.	 
Putting the contents of this section together, we have a definition of satisfaction of a policy: let N be a SC network, P be a NCP policy and let μ denote a topic- driven topology. We say that N implements the choreography (μ, P ) provided that N ) ≈ (μ, P ). Using weak bisimulation, internal computation steps may be discarded. This is common in verification of services by bisimulation, and it is useful if one considers the asynchronous nature of the calculus, which introduces additional computation steps when messages are produced or consumed.
This defintion of satisfaction is a semantic-based notion, that can be mechani- cally checked at least for finite state systems exploiting bisimulation-checking tech- niques such as those of [13]. This notion of satisfaction can support the development of systems in a Model Driven Development methodology. For instance, the designer can develop several SC systems that implement the same high level policy, each of them obtained refining the previous one by adding more details. The conformance of each design with respect to the NCP policy specification can be formally verified via our techniques. Figure 4 illustrates this methodology.

Concluding remarks
In this paper we have extended the SC & JSCL framework with a choreography model: the NCP calculus. We have presented an encoding from the design language (SC) to the choreography language in order to verify whether an SC network respects a global NCP policy. This is done via bisimulation checking.
Some research efforts have addressed the problem of relating choreography and orchestration. For instance, the notion of simulation conformance has been consid- ered [4,19]. The methodological idea of providing separated languages to describe the global and local view of service coordination has been also considered in [5]. However, our framework introduces some new notions, like multi-layered networks and multi-party sessions.
Our long term goal is to provide modal logic and model checking algorithms, defined on the grounds of the labelled semantics of NCP. Additionally, we plan to

implement and integrate these verification techniques within the JSCL design envi- ronment, possibly exploting the finite-state techniques for nominal calculi developed in [12,13,7].

References
Amadio, R. M., I. Castellani and D. Sangiorgi, On bisimulations for the asynchronous pi-calculus, Theor. Comput. Sci. 195 (1998), pp. 291–324.
Bartoletti, M., P. Degano, G. Ferrari and R. Zunino, Secure service orchestration, in: FOSAD, Lecture Notes in Computer Science 4667 (2007).
Boreale, M., R. Bruni, L. Caires, R. D. Nicola, I. Lanese, M. Loreti, F. Martins, U. Montanari, A. Ravara,
D. Sangiorgi, V. T. Vasconcelos and G. Zavattaro, Scc: A service centered calculus., in: WS-FM, Lecture Notes in Computer Science 4184 (2006), pp. 38–57.
Busi, N., R. Gorrieri, C. Guidi, R. Lucchi and G. Zavattaro, Choreography and orchestration: A synergic approach for system design, in: ICSOC, Lecture Notes in Computer Science 3826 (2005), pp. 228–240.
Carbone, M., K. Honda and N. Yoshida, Structured communication-centred programming for web services, in: ESOP 2007, Lecture Notes in Computer Science 4421 (2007), pp. 2–17.
Ciancia, V., G. L. Ferrari, R. Guanciale and D. Strollo, Checking correctness of transactional behaviors, in: FORTE, Lecture Notes in Computer Science 5048 (2008), pp. 134–148.
Ciancia, V. and U. Montanari, A name abstraction functor for named sets, Electr. Notes Theor. Comput. Sci. 203 (2008), pp. 49–70.
Ferrari, G. L., R. Guanciale and D. Strollo, Event based service coordination over dynamic and heterogeneous networks., in: A. Dan and W. Lamersdorf, editors, ICSOC, Lect. Notes in Comput. Sci. 4294 (2006), pp. 453–458.
Ferrari, G. L., R. Guanciale and D. Strollo, Jscl: A middleware for service coordination., in: FORTE, Lecture Notes in Computer Science 4229 (2006), pp. 46–60.
Ferrari, G. L., R. Guanciale, D. Strollo and E. Tuosto, Coordination via types in an event-based framework, 27th IFIP WG 6.1 International Conference on Formal Methods for Networked and Distributed Systems FORTE 4574 (2007), pp. 66–80.
Ferrari, G. L., R. Guanciale, D. Strollo and E. Tuosto, Refactoring long running transactions, in:
WS-FM, Lecture Notes in Computer Science to appear (2008).
Ferrari, G. L., U. Montanari and M. Pistore, Minimizing Transition Systems for Name Passing Calculi: A Co-algebraic Formulation, in: M. Nielsen and U. Engberg, editors, FOSSACS 2002, Lecture Notes in Computer Science 2303 (2002), pp. 129–143.
Ferrari, G. L., U. Montanari and E. Tuosto, Coalgebraic minimization of hd-automata for the pi-calculus using polymorphic types., Theor. Comput. Sci. 331 (2005), pp. 325–365.
Gelernter, D., Generative communications in Linda, ACM Transactions on Programming Languages and Systems 7 (1985), pp. 80–112.
Guidi, C., R. Lucchi, R. Gorrieri, N. Busi and G. Zavattaro, A calculus for service oriented computing, in: ICSOC, Lecture Notes in Computer Science 4294 (2006), pp. 327–338.
Honda, K. and M. Tokoro, An object calculus for asynchronous communication, Lecture Notes in Computer Science 512 (1991), pp. 133–147.
Kazhamiakin, R. and M. Pistore, Choreography conformance analysis: Asynchronous communications and information alignment, in: WS-FM, Lecture Notes in Computer Science 4184 (2006), pp. 227–241.
Lapadula, A., R. Pugliese and F. Tiezzi, A calculus for orchestration of web services, in: ESOP, Lecture Notes in Computer Science 4421 (2007), pp. 33–47.
Li, J., H. Zhu and G. Pu, Conformance validation between choreography and orchestration, in: First Joint IEEE/IFIP Symposium on Theoretical Aspects of Software Engineering, TASE 2007 (2007), pp. 473–482.

Liu, Y. and B. Plale, Survey of publish subscribe event systems, Technical Report TR574, Computer Science Department, Indiana University (2003).
Misra, J., A programming model for the orchestration of web services., in: SEFM (2004), pp. 2–11.
OASIS Bpel Specifications, OASIS - BPEL, http://www.oasis-open.org/cover/bpel4ws.html.
Sangiorgi, D. and D. Walker, “The π-Calculus: a Theory of Mobile Processes,” Cambridge University Press, 2002.
W3C, Web Services Choreography Description Language (v.1.0), Technical report.
