	Electronic Notes in Theoretical Computer Science 168 (2007) 175–190	
www.elsevier.com/locate/entcs

Component-Based Specification of Collaborative Objects
Abdessamad Imine1
LORIA, INRIA - Lorraine
Campus Scientifique, 54506 Vandœuvre-L`es-Nancy Cedex, France

Abstract
A collaborative object represents a data type (such as a text document or a spreadsheet) designed to be shared by multiple geographically separated users. In order to improve performance and availability of data in such a distributed context, each user has a local copy of the shared objects, upon which he may perform updates. Locally executed updates are then transmitted to the other users. So, the updates are applied in different orders at different copies of the collaborative object. This replication potentially leads, however, to divergent (i.e. different) copies. The Operational Transformation (OT) approach provides an interesting solution for copies divergence. Indeed, every collaborative object has an algorithm which transforms the remote update according to local concurrent ones. But this OT algorithm needs to fulfill two conditions in order to ensure the convergence. Proving the correctness of OT algorithms is very complex and error prone without the assistance of a theorem prover. In the present work, we propose a compositional method for specifying complex collaborative objects. The most important feature of our method is that designing an OT algorithm for the composed collaborative object can be done by reusing the OT algorithms of component collaborative objects. By using our method, we can start from correct small collaborative objects which are relatively easy to handle and incrementally combine them to build more complex collaborative objects.
Keywords: CSCW, groupware systems, component-based design, formal methods


Introduction
Distributed collaborative systems allow two or more users (sites) to simultaneously manipulate objects (i.e. text, image, graphic, etc.) without the need for physical proximity and enable them to synchronously observe each other’s changes. In order to achieve an unconstrained group work, the shared objects are replicated at the local memory of each participating user. Every operation is executed locally first and then broadcasted for execution at other sites. So, the operations are applied in different orders at different replicas (or copies) of the object. This potentially leads to divergent (or different) replicas – an undesirable situation for replication-based collaborative systems [10].

1 Email: imine@loria.fr

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.08.027

Operational Transformation (OT) is an approach which has been proposed to overcome the divergence problem, especially for building real-time groupware [1,8]. This approach consists of an algorithm which transforms an operation (previously executed by some other site) according to local concurrent ones in order to achieve convergence. It has been used in several group editors [1,6,8,7,11,9], and it is em- ployed in other replication-based groupwares such as a generic synchronizer [5]. The advantages of this approach are: (i) it is independent of the replica state and de- pends only on concurrent operations; (ii) it enables an unconstrained concurrency,
i.e. no global order on operations is required; (iii) it ensures a good responsiveness in real-time interaction context. However, if OT algorithms are not correct then the consistency of shared data is not ensured. Thus, it is critical to verify such algo- rithms in order to avoid the loss of data when broadcasting operations. According to [6], the OT algorithm of every collaborative object needs to fulfill two conver- gence conditions TP 1 and TP 2 that will be detailed in Section 2. Finding such an OT algorithm and proving that it satisfies TP 1 and TP 2 is not an easy task. This proof is often difficult – even impossible – to produce by hand and unmanageably complicated. In [4], we proposed a formal framework for modeling and analyzing the OT algorithms with algebraic specifications. For checking the convergence con- ditions we used a theorem prover. Using our formal approach we have detected bugs in well-known OT algorithms.
Until now the OT approach has been used to only deal with simple collaborative objects, such as a string object. When we consider a complex object (such as a filesystem or an XML document that are composite of several primitive objects) the formal design of its OT algorithm becomes very tedious because of the large number of updates and synchronization situations to be considered if we start from scratch. As continuation of [4], we propose in the present work a compositional method for specifying complex collaborative objects. The most important feature of our method is that designing an OT algorithm for the composed collaborative object can be done by reusing the OT algorithms of component collaborative objects. By using our method, we can start from correct small collaborative objects (i.e. they satisfy convergence conditions) which are relatively easy to handle and incrementally combine them to build more complex collaborative objects that are also correct.
This paper is organized as follows: in Section 2 we give the basic concepts of the OT approach. The ingredients of our formalization for specifying the collaborative object and OT algorithm are given in Section 3. In Section 4, we present two constructions for composing collaborative objects in algebraic framework. Finally, we give conclusions and present future work.


Operational Transformation Approach
Due to high communication latencies in wide-area and mobile wireless networks the replication of collaborative objects is commonly used in distributed collaborative systems. But this choice is not without problem as we will see in next sub-section.


		

op1 = ins(1,' f ')
¸¸¸¸¸
op2 = del(5)
....
op1 = ins(1,' f ')
¸¸¸¸¸¸
op2 = del(5)
,,,,,

¸¸¸..
¸¸¸,¸,,

“effecte” ..
 .s.
¸¸ “efect”
¸z 
 , ,,,,,
¸¸¸¸¸¸z˛

del(5)	ins(1,' f ')	IT (op2, op1)= del(6)	ins(1,' f ')

Fig. 1. Incorrect integration.	Fig. 2. Integration with transformation.
Convergence Problems
One of the significant issues when building distributed collaborative systems with a replicated architecture and an arbitrary communication of messages between users is the consistency maintenance (or convergence) of all replicas. To illustrate this problem, consider the following example:
Example 2.1 Consider the following group text editor scenario (see Figure 1): there are two users (sites) working on a shared document represented by a sequence of characters. These characters are addressed from 0 to the end of the document. Initially, both copies hold the string “efecte”. User 1 executes operation op1 = Ins(1, “f”) to insert the character “f” at position 1. Concurrently, user 2 performs op2 = Del(5) to delete the character “e” at position 5. When op1 is received and executed on site 2, it produces the expected string “effect”. But, when op2 is received on site 1, it does not take into account that op1 has been executed before it and it produces the string “effece”. The result at site 1 is different from the result of site 2 and it apparently violates the intention of op2 since the last character “e”, which was intended to be deleted, is still present in the final string.
To maintain convergence, an OT approach has been proposed in [1]. It consists of application-dependent transformation algorithm such that for every possible pair of concurrent updates, the application programmer has to specify how to merge these updates regardless of reception order. We denote this algorithm by a function IT , called inclusion transformation [8].
Example 2.2 In Figure 2, we illustrate the effect of IT on the previous exam- ple. When op2 is received on site 1, op2 needs to be transformed in order to include the effects of op1: IT ((Del(5),Ins(1, “f”)) = Del(6). The deletion po- sition of op2 is incremented because op1 has inserted a character at position 1,

which is before the character deleted by op2.  Next, op'
is executed on site 1.

In the same way, when op1 is received on site 2, it is transformed as follows:
IT (Ins(1, “f”), Del(5)) = Ins(1, “f”); op1 remains the same because “f” is inserted before the deletion position of op2.
Intuitively we can write the transformation IT as follows:



Transformation Properties
Notation [op1; op2; ... ; opn] represents an operation sequence.  We denote Do(X, st) = st' when an operation (or an operation sequence) X is executed on a replica state st and produces a replica state st'.
Using an OT algorithm requires to satisfy two properties [6], called transfor-

mation properties. Given two operations op1 and op2, let op'
= IT (op2, op1) and

op' = IT (op1, op2), the conditions are as follows:
Property TP1: Do([op1; op' ], st) = Do([op2; op' ], st), for every state st.
2	1
Property TP2: IT (IT (op, op1), op' ) = IT (IT (op, op2), op' ).
2	1
TP1 defines a state identity and ensures that if op1 and op2 are concurrent, the effect of executing op1 before op2 is the same as executing op2 before op1. This condition is necessary but not sufficient when the number of concurrent operations is greater than two. As for TP2, it ensures that transforming op along equivalent and different operation sequences will give the same result. In [7], the authors have proved that conditions TP1 and TP2 are sufficient to ensure the convergence property for any number of concurrent operations which can be executed in arbitrary order.
Proving the correctness of OT algorithms, w.r.t TP1 and TP2 is very complex and error prone even on a simple string object. Consequently, the design of OT algorithms must be assisted by an automatic theorem prover [4].
Describing Individual Collaborative Objects
Basic Notions
In this sub-section we present terminology and notation that are used in the fol- lowing sections. We assume that the reader is familiar with algebraic specifications. For more background on this topic see [12,3].
A many-sorted signature Σ is a pair (S, F ) where S is a set of sorts and F is a S∗ × S-sorted set (of function symbols). Here, S∗ is the set of finite (including empty) sequences of elements of S. Saying that f : s1 × ... × sn → s is in Σ = (S, F ) means that s1 ... sn ∈ S∗, s ∈ S, and f ∈ Fs ...s ,s. A Σ-algebra A interprets sorts as sets and operations as appropriately typed functions. A signature morphism

Φ : Σ → Σ' is a pair (f ,g), such that f : S → S' and g : Σ → Σ' ∗ ,f
an (S∗ × S)-

sorted function. Usually, we ignore the distinction between f and g and drop all
subscripts, writing Φ(s) for f (s) and Φ(σ) for g(σ) such that σ ∈ Fs1 ...sn,s.
Let X be a family of sorted variables and let TΣ(X) be the algebra of Σ-terms.
An equation is a formula of the form l = r where l, r ∈ TΣ(X)s for some sort s ∈ S.
A conditional equation is a formula of the following form:  n	ai = bi =⇒ l = r,
where ai, bi ∈ TΣ(X)si . An algebraic speciﬁcation is a pair (Σ, E) where Σ is a many-sorted signature and E is a set of (conditional) Σ-equations, called axioms

of (Σ, E). A (Σ, E)-model is a Σ-algebra A that satisfies all the axioms in E. We write A |=Σ E to indicate that A is a (Σ, E)-model. Given a signature morphism Φ : Σ → Σ' and a Σ'-algebra A', the reduct of A' to Σ, denoted Φ(A'), represents
carriers A'	for s ∈ S and operations σΦ(s) for σ ∈ Σs ...s ,s. Given a Σ-equation e
Φ(s)	1	n
of the form l = r. Then Φ(e) is Φ(l)= Φ(r) where Φ: TΣ(X) → TΣ' (X') and X' = Φ(X). An important property of these translations on algebras and equations under signature morphisms is called satisfaction condition, which expresses the invariance of satisfaction under change of notation:
Theorem 3.1 (Satisfaction Condition [2]). Given a signature morphism Φ : Σ → Σ', a Σ'-algebra A' and a Σ-equation e, Φ(A') |=Σ e iff A' |=Σ' Φ(e)	 
An observational signature is a many-sorted signature Σ = (S, Sobs,F ) where Sobs ⊆ S is the set of observable sorts. An Observational Speciﬁcation is a pair (Σ, E) where Σ is an observational signature and E is a set of axioms. We assume that axioms are conditional equations with observable conditions. A context is a term with exactly one occurrence of a distinguished variable, say z. Observable contexts are contexts of observable sort. Let CΣ(s, s') be the set of contexts of sort
s' that contain a distinguished variable of sort s. We write c[t] for the replacement
of distinguished variable z by the term t. A Σ-algebra A behaviorally satisﬁes an
equation l = r, denoted A |=Σ	l = r, iff A |=Σ c[l] = c[r] for every observable
context c. A model of an observational specification SP = (Σ, E) is a Σ-algebra A
that behaviorally satisfies every axioms in E. We write A |=Σ  SP or A |=Σ E.

Also we write E |=Σ
e iff A |=Σ
E implies A |=Σ
e where e is a (conditional)-

equation.
Component Speciﬁcations
Using Observational semantics we consider a Collaborative Object (CO) as a black box with a hidden (or non-observable) state [3]. We only specify the interactions between a user and an object. In the following, we give our formalization:
Definition 3.2 (CO Signature). Given S the set of all sorts, Sb = {State, Meth} is the set of basic sorts and Sd = S \ Sb is the set of data sorts. A CO signature Σ = (S, Sobs,F ) is an observational signature where the sort State is the unique non-observable sort. The set of function symbols F is defined as follows:
FMeth State,State = {Do}, FMeth Meth,Meth = {IT }, FMeth State,Bool = {Poss}, and
Fω,s = ∅ for all other cases where ω ∈ S∗ and s ∈ Sb.
A function symbol f : s1×s2×.. .×sn → Meth is called a method if s1·s2·.. .·sn ∈
S∗.
A function symbol f : s1×s2×.. .×sn → s is called an attribute if: (i) s1·s2·.. .·sn
contains only one State sort; and (ii) s ∈ Sd.
We use Σ, Σ', Σ1, Σ2, .. ., as variables ranging over CO signatures.	 
The states of a collaborative object are accessible using the function Do which given a method and a state gives the resulting state provided that the execution of

this method is possible. For this we use a boolean function Poss that indicates the conditions under which a method is enabled. The OT algorithm is denoted by the function symbol IT which takes two methods as arguments and produces another method.
Definition 3.3 (Σ-Morphism).  Given CO signatures Σ and Σ', then a Σ-
morphism Φ: Σ → Σ' is a signature morphism such that:
Φ(s)= s for all s ∈ Sd;
Φ(f )= f for all f ∈ Σω,s where ω ∈ S∗ and s ∈ Sd;
Φ(Sb)= S' (where S' = {State’, Meth’}, Φ(State)= State’ and Φ(Meth)= 
b	b
Meth’).	 
The three conditions stipulate that Σ-morphisms preserve State sort, observable sorts and functions.
Definition 3.4 (Collaborative Component Specification).	A collaborative component speciﬁcation is a tuple C = (Σ, M, A,T, E) where:
Σ is a CO signature;
M is a set of method symbols, i.e. M = {m | m ∈ Σω,Meth and ω ∈ S∗};
A is a set of attribute symbols, i.e. A = {a | a ∈ Σω,s where ω contains exactly one State sort and s ∈ S∗};
T is the set of axioms corresponding to the transformation function;
E is the set of all axioms.
We let C, C', C1, C2, .. ., denote collaborative component specifications.	 
In the following, we assume that all used (conditional) equations are universally quantified.
Example 3.5 The following component specification CCHAR models a memory cell (or a buffer) which stores a character value:
spec CCHAR = sort:
Char Meth State opns:
Do : Meth State -> State putchar : Char -> Meth getchar : State -> Char IT : Meth Meth -> Meth
axioms:
getchar(Do(putchar(c),st)) = c;
IT(putchar(c1),putchar(c2)) = putchar(maxchar(c1,c2));
CCHAR has one method putchar and one attribute getchar. Axiom (2) gives how to transform two concurrent putchar in order to achieve the data convergence. For that, we use function maxchar that computes the maximum of two character values. Note we could have used another way to enforce convergence.
As the previous specification CNAT and CCOLOR model a memory cell which stores respectively a natural number value and a color value:
spec CNAT = sort:
Nat Meth State opns:


Do : Meth State -> State putnat : Nat -> Meth getnat : State -> Nat
IT : Meth Meth -> Meth axioms:
getnat(Do(putchar(n),st)) = n;
IT(putnat(n1),putnat(n2)) = putnat(minnat(n1,n2));

spec CCOLOR = sort:
Color Meth State opns:
Do : Meth State -> State putcolor : Color -> Meth getcolor : State -> Color IT : Meth Meth -> Meth
axioms:
getcolor(Do(putcolor(cl),st)) = cl;
IT(putcolor(cl1),putcolor(cl1)) = putcolor(mincolor(cl1,cl2));
To get data convergence we have used in CNAT (resp. CCOLOR) another function
minnat (resp. mincolor) that computes the minimum value.
The sorts Char, Nat and Color are built-in.	 
For a concise presentation and without loss of generality, we shall omit the observable-sorted arguments from methods and attributes. We could suppose we have one function for each of its possible arguments. For instance, method putchar(c) may be replaced by putcharc for every c ∈ CHAR.
Definition 3.6 ((M ,A)-Complete).  Given a component specification C = (Σ, M, A,T, E). The set E is (M ,A)-complete iff all equations involving M have the form:
C =⇒ a(Do(m, x)) = t
with x is a variable of sort State, a ∈ A, m ∈ M , t ∈ TΣ\M ({x}) and C is a
finite set of visible pairs t1 = t' , t2 = t' , .. ., tn = t' where t1, t' ∈ TΣ(X)s , t2,
1	2	n	1	1
t' ∈ TΣ(X)s , .. ., tn, t' ∈ TΣ(X)s .	 
2	2	n	n
In Example 3.5, component specification CCHAR is (M ,A)-complete as the only axiom involving methods (i.e., axiom (1)) has the required form. CNAT and CCOLOR are also (M ,A)-complete. In the remaining of this paper, we restrict our intention to component specification which are (M ,A)-complete.
As a component specification has a an observational signature with one non- observable sort, State, then the observable contexts have the following form: a(Do(mn,... , Do(m1, s)) where m1,.. ., mn are methods and a is an attribute.
Definition 3.7 (Specification morphisms). Given two collaborative compo- nent specifications C = (Σ, M, A,T, E) and C' = (Σ',M ', A',T ', E'), a speciﬁca-
tion morphism Φ : C → C' is a signature morphism Φ : Σ → Σ' such that:
(i) Φ(M ) ⊆ M '; (ii) Φ(A) ⊆ A'; (iii) E' |=Σ' Φ(e) for each e ∈ E.	 
Definition 3.7 provides a support for reusing component specification through the notion of specification morphism. Moreover, it exploits the fact that the source component specification is (M ,A)-complete by only requiring the satisfaction of finite number of equations (see condition (iii)).

Convergence Properties
Before stating the properties that a component specification C = (Σ, M, A,T, E) has to satisfy for ensuring convergence, we introduce some notations. Let m1, m2,
. .., mn and s be terms of sorts Meth and State respectively:
applying a method sequence on a state is denoted as:
(s)[m1; m2; ... ; mn] ≡ Do(mn,... , Do(m2, Do(m1, s)) .. .)
Legal([m1; m2; ... ; mn], s)	≡	Poss(m1, s)  ∧  Poss(m2, (s)m1)  ∧  ... 
∧ Poss(mn, (s)[m1; m2; ... ; mn−1]).
IT ∗(m, [])	=	m	and	IT ∗(m, [m1; m2; ... ; mn−1])	=
IT ∗(IT (m, m1), [m2; ... ; mn−1]) where [] is an empty method sequence.
TP1 expresses a state identity between two method sequences. As mentioned before, we use an observational approach for comparing two states. Accordingly, we define the condition TP1 by the following state property (where the variables st, m1 and m2 are universally quantified):
CP 1 ≡ (Legal(seq1, s)= true ∧ Legal(seq2, s)= true)
=⇒ (s)seq1 = (s)seq2
where seq1 = [m1; IT (m2, m1)] and seq2 = [m2; IT (m1, m2)].
Let M ' ⊆ M be a set of methods, we denote CP 1|M' as the restriction of CP 1 to M '. Let M1, M2 ⊆ M be two disjoint sets of methods, we define CP 1|M1 ,M2 as:
CP 1|M1,M2 ≡ (Legal(seqi, s)= true ∧ Legal(seqj, s)= true)
=⇒ (s)seqi = (s)seqj
where seqi = [mi; IT (mj, mi)] and seqj = [mj; IT (mi, mj)] such that mi ∈ Mi and
mj ∈ Mj for all i /= j ∈ {1, 2}.
TP2 stipulates a method identity between two equivalent sequences. Given three methods m1, m2 and m3, transforming m3 with respect to two method sequences [m1; IT (m2, m1)] and [m2; IT (m1, m2)] must give the same method. We define TP2 by the following property:
CP 2 ≡ IT ∗(m3, [m1; IT (m2, m1)]) = IT ∗(m3, [m2; IT (m1, m2)])
Let M ' ⊆ M be a set of methods, we denote CP 2|M' as the restriction of CP 2 to M '. Let M1, M2 ⊆ M be two disjoint sets of methods, we define CP 2|M1 ,M2 as:
CP 2|M1 ,M2  ≡ IT ∗(m, [m'; IT (m'', m')]) = IT ∗(m, [m''; IT (m', m'')])
such that m' ∈ Mi, m'' ∈ Mj and m ∈ Mk for all i, j, k ∈ {1, 2} with k /= i or
k /= j.

The following definition gives the conditions under which a component specifi- cation ensures the data convergence:
Definition 3.8 (Consistency). C is said consistent iff C |=obs CP 1 ∧ CP 2. 

Composing Collaborative Objects
The concurrent interaction in a collaborative context is an essential feature of the object paradigm. More attention is paid for allowing concurrent executions to achieve convergence. This section describes how to build complex collaborative objects from components using two kinds of composition. For that, we are inspired of work of Goguen et al [2].
Static Concurrent Composition
As first construction, we propose a composition of several components without interference (or synchronization) between them, in the sense that every component can change state independently.
Definition 4.1 (Static composition). Given n component specifications Ci = (Σi, Mi, Ai, Ti, Ei) with i ∈ {1,... , n} and n > 1. A component specification C =
(Σ, M, A,T, E) is said static concurrent composition of Ci iff there exists specification
morphisms Φi : Ci → C such that for each i /= j ∈ {1,... , n}: (i) Σ =  Φi(Σi);
i
(ii) M =	i Φi(Mi); (iii) A =	i Φi(Ai); (iv) T =  Φi(Ti) ∪	i,j Tij where:
Tij = {IT (Φi(mi), Φj(mj)) = Φi(mi) | mi ∈ Mi and mj ∈ Mj}

(v) E = 
	i
Φi(Ei) ∪ IE where IE is called the interaction part between Ci, and

IE =
i,j (Tij ∪ Aij) such that:

Aij = {Φi(ai)(Do(Φj(mj), x)) = Φi(ai)(x) | ai ∈ Ai and mj ∈ Mj}
We denote the static concurrent composition as C =  i Ci.	 
Example 4.2 Consider the character memory cell CCHAR = (Σ1, M1, A1, T1, E1), the natural memory cell CNAT = (Σ2, M2, A2, T2, E2) and the color memory cell CCOLOR = (Σ3, M3, A3, T3, E3) of Example 3.5. The static concurrent compo- sition of CCHAR and CNAT is the following composite specification SIZEDCHAR = (Σ, M, A,T, E) (see Figure 3(a)):
spec SIZEDCHAR =
sort:
Char Nat Meth State opns:
Do : Meth State -> State putchar : Char -> Meth putnat : Nat -> Meth getchar : State -> Char getnat : State -> Nat IT : Meth Meth -> Meth
axioms:
getchar(Do(putchar(c),st)) = c;
getnat(Do(putnat(n),st)) = n;
getchar(Do(putnat(n),st))=getchar(st);
getnat(Do(putchar(c),st)) = getnat(n);


IT(putchar(c1),putchar(c2)) = putchar(maxchar(c1,c2));
IT(putnat(n1),putnat(n2)) = putchar(minnat(n1,n2));
IT(putchar(c1),putnat(n1)) = putchar(c1);
IT(putnat(n1),putchar(c1)) = putnat(n1);



J,˜¸C NAT` z,
¸¸¸¸Φ1


,J¸˜CCHAR` z,
Φ2 sss


J,˜¸C COLOR` z,
¸¸¸¸¸Θ1


,J¸˜CCHAR` z,
Θ2 ....

¸¸¸¸
ssss
¸¸¸¸
....

¸z ,sss
J˜
¸z  ,. c.

,¸SIZEDCHAR` z,
First Composition
,J¸˜COLOREDCHAR` z,
Second Composition

Fig. 3. Static Concurrent Composition
where Tij contains axioms (9)-(10) and Aij contains the axioms (4)-(5) for all i, j ∈ {1, 2} and i /= j. Note that the specification morphisms Φ1 : C1 →C and Φ2 : C2 →C are just the inclusion morphisms. For instance this concurrent composition may be associated to an object that has a character value and an attribute for modifying the font size. In the same way, the static concurrent composition of CCHAR and CCOLOR is the following specification COLOREDCHAR = (Σ, M, A,T, E) that models an object with a character and a color (see Figure 3(b)):
spec COLOREDCHAR =
sort:
Char Color Meth State opns:
Do : Meth State -> State putchar : Char -> Meth putcolor : Color -> Meth getchar : State -> Char getcolor : State -> Color IT : Meth Meth -> Meth
axioms:
getchar(Do(putchar(c),st)) = c;
getcolor(Do(putcolor(cl),st)) = cl;
getchar(Do(putcolor(cl),st))=getchar(st);
getcolor(Do(putchar(c),st)) = getcolor(st);
IT(putchar(c1),putchar(c2)) = putchar(maxchar(c1,c2));
IT(putcolor(cl1),putcolor(cl2)) = putcolor(mincolor(n1,n2));
IT(putchar(c1),putcolor(cl1)) = putchar(c1);
IT(putcolor(cl1),putchar(c1)) = putcolor(cl1);


We define the true concurrency (or the commutativity of methods) between n component specifications combined into one specification according to Defini- tion 4.1:
Definition 4.3 (Independent Components). Let C =   Ci for i ∈ {1,... , n}
and n > 1. The component specifications Ci are said independent iff:

Σ
obs
(s)[Φi(mi); Φj(mj)] = (s)[Φj(mj); Φi(mi)]

such that mi ∈ Mi and mj ∈ Mj with i /= j ∈ {1,... , n}.	 
In Example 4.2, components CCHAR and CNAT are independent because the fol- lowing equation:
Do(putchar(c),Do(putnat(n),s))=Do(putnat(n),Do(putchar(c),s))
is an observable consequence of SIZEDCHAR.
The following theorem means that the static concurrent composition preserves the convergence properties of individual components:

Theorem 4.4 Given component speciﬁcations Ci and C = 
Ci for i ∈ {1,... , n}

and n > 1, such that Ci are independent.	If Ci are consistent then C |=Σ
CP 1|Φi(Mi) ∧ CP 2|Φi(Mi).	 
The proof of this theorem is given in Appendix A.
In Example 4.2, it is easy to see that CCHAR, CNAT and CCOLOR are consistent. The composite specifications SIZEDCHAR or COLOREDCHAR preserves also the convergence properties of their components.
The following theorem is very important in the sense that it stipulates that the consistency property (see Definition 3.8) can be obtained by composition. Indeed, composing consistent components produces a consistent composite object provided that the components are independent between them.
Theorem 4.5 The concurrent composition of n consistent and independent com- ponent speciﬁcations is also consistent, where n > 1.	 
The proof of this theorem is given in Appendix A.
In Example 4.2, as CCHAR, CNAT and CCOLOR are independent between them, then
SIZEDCHAR and COLOREDCHAR are consistent.
Static Concurrent Composition with Synchronization
As second construction, we allow the component specifications to interact. It is possible to get situations where the component specifications share some methods and attributes. These components are said synchronized by their shared part. Such a shared part is just a way for component objects to communicate.
Definition 4.6 (Shared Component). Let Ci be component specifications for i ∈ {0,... , n} and n > 1. The component C0 is called a shared component of C1, .. ., Cn iff there exists a family of specification morphisms Θi : C0 → Ci such that for every methods m ∈ M0 and m' ∈ Mi \ Θi(M0) and for every attributes
a ∈ A0 and a' ∈ Ai \ Θi(A0) we have: (i) Ci |=Σi  IT (Θi(m), m') = Θi(m);

(ii) Ci |=Σi
IT (m', Θi(m)) = m'; (iii) Ci |=Σi
a'(Do(Θi(m), x)) = a'(x); (iv) Ci |=Σi

Θi(a)(Do(m', x)) = Θi(a)(x); (v) Ci |=Σi (s)[Θi(m); m']= (s)[m'; Θi(m)].	 
Conditions (i)-(iv) give how the interaction between Ci and C0 is defined. In fact, Ci and C0 do not have to interfere between them and their methods must be commutative according to condition (v).
Definition 4.7 (Synchronized static composition). Given component specifi- cations C0, C1, .. ., Cn, such that C0 is a shared component of Ci with i ∈ {1,... , n}
and n > 1. A component C is said a synchronized composition of Ci iff there exist specification morphisms Θi : C0 → Ci and Φi : Ci → C for i ∈ {1,... , n} such that:
(i) Θi ◦ Φi = Θj ◦ Φj for i /= j, and; (ii) C =  Ci. We denote the synchronized
  C0	i

composition as C =
i  Ci.	 

The signature of the synchronized composition is built by taking all operations from the signatures of the components. It should be noted that no duplicates are

made of any methods or attributes from a shared component (condition (i) of the above definition).

		

J,˜¸CNAT` z,
Φ1
J,˜¸C CHAR` ¸z,
Φ2 sss	¸¸¸¸Θ2
J,˜¸CCOLOR` z,
Θ1

ss
z  ,sss
J,˜¸SIZEDCHAR` z,
¸¸¸¸Ω1
¸¸¸¸
¸¸¸¸¸z  s
J,˜¸COLOREDCHAR` z,
Ω2 ...
...



¸z  ,. c.
,J¸˜FCHAR` z,
Fig. 4. Synchronized Concurrent Composition

Example 4.8 Let come back to the component specifications illustrated in Ex- ample 4.2. Recall that SIZEDCHAR is a character object with a size attribute and COLOREDCHAR is a character object with a color attribute. These objects have a shared part namely CCHAR (see Figure 4). Thus the composition of SIZEDCHAR and COLOREDCHAR is made by synchronization to common object CCHAR. We obtain the following specification:
spec FCHAR = sort:
Char Color Nat Meth State opns:
Do : Meth State -> State putchar : Char -> Meth putnat : Nat -> State putcolor : Color -> Meth getchar : State -> Char getnat : State -> Nat getcolor : State -> Color IT : Meth Meth -> Meth
axioms:
getchar(Do(putchar(c),st)) = c;
getnat(Do(putnat(n),st)) = n;
getcolor(Do(putcolor(cl),st)) = cl;
getchar(Do(putcolor(cl),st))=getchar(st);
getchar(Do(putnat(n),st)) = getchar(st);
getnat(Do(putchar(c),st)) = getnat(st);
getcolor(Do(putchar(c),st)) = getcolor(st);
getnat(Do(putcolor(cl),st)) = getnat(st);
getcolor(Do(putnat(n),st)) = getcolor(st);
IT(putchar(c1),putchar(c2)) = putchar(maxchar(c1,c2));
IT(putnat(n1),putnat(n2)) = putnat(maxnat(n1,n2));
IT(putcolor(cl1),putcolor(cl2)) = putcolor(maxcolor(cl1,cl2));
IT(putchar(c1),putcolor(cl1)) = putchar(c1);
IT(putcolor(cl1),putchar(c1)) = putcolor(cl1);
IT(putchar(c1),putnat(n1)) = putchar(c1);
IT(putnat(n1),putchar(c1)) = putnat(n1);
IT(putcolor(cl1),putnat(n1)) = putcolor(cl1);
IT(putnat(n1),putcolor(cl1)) = putnat(n1);
where the interaction part IE contains the axioms (4)-(9) and (13)-(18). Note that Ω1 and Ω2 are just inclusion morphisms and Φ2 ◦ Ω1 = Θ2 ◦ Ω2. 
Unlike the previous composition (see Definition 4.3), the component specifi- cations have a common part from which they are synchronized. Thus, the true concurrency is defined between the disjoint parts of these components.
Definition 4.9 (Independent Components). Let C =   C0 Ci for i ∈ {1,... , n}
and n > 1. The component specifications Ci are said independent iff:


Σ
obs
(s)[Φi(mi); Φj(mj)] = (s)[Φj(mj); Φi(mi)]

such that mi ∈ Mi \ Θi(M0) and mj ∈ Mj \ Θj(M0) with i /= j ∈ {1,... , n}.	 
In Example 4.8, SIZEDCHAR and COLOREDCHAR have as a shared part CCHAR and they are independent according to the above definition because:
Do(putcolor(c),Do(putnat(n),s))=Do(putnat(n),Do(putcolor(c),s))
is an observable consequence of FCHAR.
The convergence properties of individual components is preserved by the syn- chronized composition:
Theorem 4.10 Given component speciﬁcations Ci and C  =   C0 Ci for i  ∈
{1,... , n} and n > 1, such that Ci are independent.	If Ci are consistent then
C |=Σ CP 1|Φ (M ) ∧ CP 2|Φ (M ).
obs	i	i	i	i
Proof. The proof of this theorem is similar to Theorem 4.4.	 
Composing consistent components synchronized by a common component pro- duces a consistent composite object provided that these components are indepen- dent between them.
Theorem 4.11 The synchronized concurrent composition of n consistent and in- dependent component speciﬁcations is also consistent, where n > 1.	 
The proof of this theorem is given in Appendix A.
In Example 4.8, CCHAR, CNAT and CCOLOR are consistent and indepen- dent. By composition, SIZEDCHAR = CNAT⊕CCHAR and COLOREDCHAR = CCOLOR⊕CCHAR are consistent. Finally, by synchronized composition, FCHAR = SIZEDCHAR⊕CCHARCOLOREDCHAR is also consistent.

Conclusion
This work is a first step toward to give a compositional method for specifying and verifying complex collaborative objects. In this respect, we have proposed two constructions for composing collaborative objects: (i) the first construction has as a basic semantic property to combine several components without allowing these components to interact; (ii) as for the second one it enables components to communicate by means of a shared part. Moreover, we have provided sufficient conditions for preserving TP 1 and TP 2 by both constructions.
Many features are planned to be investigated effectively with large systems. We plan to deal with composition of arbitrary number of collaborative objects by using a dynamic composition such that the objects are created and deleted dynamically. Next, we intend to study the semantic properties of compositions given in this paper. Finally, we want to implement these compositions in our tool VOTE [4].

References
Ellis, C. A. and S. J. Gibbs, Concurrency Control in Groupware Systems, in: Proceedings SIGMOD Conference, 1989, pp. 399–407.


Goguen, J. and R. Diaconsecu, Towards an algebraic semantics for the object paradigm, in: H. Ehrig and F. Orejas, editors, Recent Trends in Data Type Specification, 1994, pp. 1–29.
Goguen, J. and G. Malcolm, A hidden agenda, Theoretical Computer Science 245 (2000), pp. 55–101.
Imine, A., M. Rusinowitch, G. Oster and P. Molli, Formal design and verification of operational trans- formation algorithms for copies convergence, Theoretical Computer Science 351 (2006), pp. 167–183.

Molli, P., G. Oster, H. Skaf-Molli and A. Imine, Using the transformational approach to build a safe and generic data synchronizer, in: Proceedings of the 2003 international ACM SIGGROUP conference on Supporting group work (2003), pp. 212–220.

Ressel, M., D. Nitsche-Ruhland and R. Gunzenhauser, An Integrating, Transformation-Oriented Approach to Concurrency Control and Undo in Group Editors, in: Proceedings of the ACM Conference on Computer Supported Cooperative Work (CSCW’96), Boston, MA, USA, 1996, pp. 288–297.

Suleiman, M., M. Cart and J. Ferri´e, Concurrent Operations in a Distributed and Mobile Collaborative Environment, in: Proceedings of the Fourteenth International Conference on Data Engineering, Orlando, Florida, USA (1998), pp. 36–45.

Sun, C., X. Jia, Y. Zhang, Y. Yang and D. Chen, Achieving Convergence, Causality-preservation and Intention-preservation in real-time Cooperative Editing Systems, ACM Transactions on Computer- Human Interaction (TOCHI) 5 (1998), pp. 63–108.
Sun, D., S. Xia, C. Sun and D. Chen, Operational transformation for collaborative word processing, in:
Proceedings CSCW, 2004, pp. 437–446.
Tanenbaum, A. S., “Distributed operating systems,” Prentice-Hall, Inc., 2002.

Vidot, N., M. Cart, J. Ferri´e and M. Suleiman, Copies convergence in a distributed real-time collaborative environment, in: Proceedings of the ACM Conference on Computer Supported Cooperative Work (CSCW’00), Philadelphia, PA, USA, 2000.
Wirsing, M., Algebraic Specification, Handbook of theoretical computer science (vol. B): formal models and semantics (1990), pp. 675–788.

A	Proofs

Proof. (Theorem 4.4) We consider two cases:
Proof of C |=obs CP 1|Φi(Mi): We have to show that for every visible contexts ci
and c we have:
Ci |=Σi ci[CP 1|M ] implies C |=Σ c[CP 1|Φ (M )]
with i ∈ {1,... , n}. Note that ci has the form ai((st)[mi1 ; mi2 ; ... ; mip ]) with p ≥ 0, mi1 , mi2 , .. ., mip ∈ Mi, and ai ∈ Ai. In the same way, c is a((st)[m1; m2; ... ; mq]) with q ≥ 0, m1, m2, .. ., mq ∈ M , and a ∈ A.
Two cases are to be considered:
c = Φi(ci): In this case we have
Ci |= ci[CP 1|Mi ] implies C |= Φi(ci)[CP 1|Φi(Mi)]
which follows from Theorem 3.1 and the fact that Φi(ci[CP 1|Mi ]) = Φi(ci)[CP 1|Φi(Mi)].
c /= Φi(ci): It means that a is not the image of ai by Φi. Without loss of
generality, assume that in c the methods m1, m2, .. ., ml (for 0 ≤ l < q) are

the images by Φi of some methods in Mi. Thus c[CP 1|Φi(Mi)] is rewritten as follows:
a((st)[Φi(m); IT (Φi(m'), Φi(m)); m1; ... ; ml; ... ; mq])
=
a((st)[Φi(m'); IT (Φi(m), Φi(m')); m1; ... ; ml; ... ; mq])
with m, m' ∈ Mi. As the component specifications Ci (i ∈ {1,... , n}) are independent, methods m1, m2, .. ., ml are commutative with ml+1, .. ., mq, and we get
a((st)[ml+1; ... ; mq; Φi(m); IT (Φi(m'), Φi(m)); m1; ... ; ml; ])
=
a((st)[ml+1; ... ; mq; Φi(m'); IT (Φi(m), Φi(m')); m1; ... ; ml])
which holds by using condition (v) of Definition 4.1.
Proof of C |=obs CP 2|Φi(Mi): As CP 2 does not contain State terms, then we have to show:
Ci |=Σi CP 2|M implies C |=Σ CP 2|Φ (M )
which also follows from Theorem 3.1 using the fact Φi(CP 2|Mi )= CP 2|Φi(Mi).
 
Proof. (Theorem 4.5) Let C be the concurrent composition of C1, C2, .. ., Cn

where n ≥ 2. By definition, C is consistent iff C |=Σ
CP 1 ∧ CP 2.

Proof of C |=Σ
CP 1: The convergence property CP 1 can be formulated as

follows:
CP 1 ≡ Φi(CP 1|Mi ) ∧ CP 1|Φi(Mi),Φj (Mj )

with i /= j ∈ {1,... , n}. Since Ci are consistent then C |=Σ Φi(CP 1|M ) follows
i
from Theorem 4.4 and the fact that Φi(CP 1|Mi ) = CP 1|Φi(Mi)). By using
Definition 4.1, C |=Σ CP 1|Φ (M ),Φ (M ) is rewritten as follows:

obs
i	i	j	j

C |=obs (s)[Φi(mi); Φj(mj)] = (s)[Φj(mj); Φi(mi)]
(where mi ∈ Mi and mj ∈ Mj) that is true because the component specifications are independent.

Proof of C |=Σ
CP 2. The convergence property CP 2 can be expressed as

follows:
CP 2 ≡ Φi(CP 2|Mi ) ∧ CP 2|Φi(Mi),Φj (Mj )

with i /= j ∈ {1,... , n}. Because Ci are consistent and using Theorem 4.4 we

have C |=Σ	Φi(CP 2|M ). As for C |=Σ
CP 2|Φ (M ),Φ (M ), it is rewritten as

obs	i
follows:
obs
i	i	j	j

IT ∗(Φk1 (m), [Φi1 (m'); IT (Φj1 (m''), Φi1 (m'))]) =
IT ∗(Φk1 (m), [Φj1 (m''); IT (Φi1 (m'), Φj1 (m''))])

where m' ∈ Mi1 , m'' ∈ Mj1 and m ∈ Mk1 for all i1, j1, k1 ∈ {i, j} with k1 /= i1
or k1 /= j1. Two cases are possible:
i1 = j1 and k1 /= i1: As Ck1 and Ci1 are independent
IT ∗(Φk1 (m), [Φi1 (m'); Φi1 (IT (m'', m'))]) = Φk1 (m)
and
IT ∗(Φk1 (m), [Φi1 (m''); Φi1 (IT (m', m''))]) = Φk1 (m)
i1 /= j1 and (k1 = i1 or k1 = j1): Consider the case where k1 = i1 (the case
k1 = j1 is similar). As Ci1 and Cj1 are independent
IT ∗(Φi1 (m), [Φi1 (m'); Φj1 (m'')]) = IT (Φi1 (IT (m, m')), Φj1 (m'')) =
Φi1 (IT (m, m')) and
IT ∗(Φi1 (m), [Φj1 (m''); Φi1 (m')]) = Φi1 (IT (m, m'))

Proof. (Theorem 4.11) Let C be the synchronized composition of C1, C2, .. ., Cn (n > 1) which have C0 as a shared component, i.e. there exist specifications Θi : C0 → Ci and Φi : Ci → C for i ∈ {1,... , n}. Note that Φi(Mi) ∩ Φj(Mj) = Φi(Θi(M0)) = Φj(Θj(M0)) for i /= j ∈ {1,... , n}. Let Mi = Mi \ Θi(M0). By

definition, C is consistent iff C |=Σ
CP 1 ∧ CP 2.

Proof of C |=Σ
CP 1: The convergence property CP 1 can be formulated as

follows:
CP 1 ≡ Φi(CP 1|Mi ) ∧ CP 1|Φi(Mi),Φj (Mj )

with i /= j ∈ {1,... , n}. Since Ci are consistent then C |=Σ Φi(CP 1|M ) follows
i
from Theorem 4.10 and the fact that Φi(CP 1|Mi ) = CP 1|Φi(Mi)). By using

Definition 4.1, C |=Σ
CP 1|Φi(Mi),Φj (Mj)
is rewritten as follows:



Σ
obs
(s)[Φi(mi); Φj(mj)] = (s)[Φj(mj); Φi(mi)]


	
(where mi ∈ Mi and mj ∈ Mj) that is true because the component specifications are independent.
Proof of C |=obs CP 2. It is similar to the proof given for Theorem 4.5.
 
