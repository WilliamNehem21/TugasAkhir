Electronic Notes in Theoretical Computer Science 112 (2005) 19–36  
www.elsevier.com/locate/entcs


Abstract Model Checking of tccp programs

Mar´ıa Alpuente 1 ,2	Mar´ıa del Mar Gallardo 1 ,3
Ernesto Pimentel1 ,4	Alicia Villanueva 1 ,5

Abstract
The Timed Concurrent Constraint programming language (tccp) introduces time aspects into the Concurrent Constraint paradigm. This makes tccp especially appropriate to analyze by model checking timing properties of concurrent systems. However, even if very compact state representa- tions are obtained thanks to the use of constraints in tccp, large state spaces can be still generated which may prevent model checking tools from verifying tccp programs completely. In this paper, we introduce an abstract methodology which is based on over– and under–approximating tccp models and mitigates the state explosion problem which is common to traditional model checking algorithms. We ascertain the conditions for the correctness of the abstract technique and show that, due to the timing aspects of the language, this semantics does not correctly simulate the suspension behavior, which is a key feature of tccp. Then, we present a refined abstract semantics which correctly models suspension.
Keywords: Model Checking, Timed Concurrent Constraint Programming, Abstract Interpretation.


Introduction
In the past few years, some extensions of the concurrent constraint paradigm [4,20] have been defined in order to model reactive systems. All these exten- sions introduce a notion of time which makes it possible to model the typical

1 This research is supported by the CICYT project TIC2001-2705-C03-02.
2 Email: alpuente@dsic.upv.es
3 Email: gallardo@lcc.uma.es
4 Email: ernesto@lcc.uma.es
5 Email: villanue@dsic.upv.es



1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.01.024


ingredients of these systems, such as timeouts, preemptions, etc. The au- tomatic verification of systems specified in the timed concurrent constraint language tccp of [4] was first studied in [11]. Then, an exhaustive method for applying the classical model checking technique to tccp was proposed in [12] which uses the temporal logic for reasoning about tccp programs of [5]. The main idea behind these methods is to take advantage of the constraint dimen- sion of tccp in order to obtain a compact representation of the system which is then used as an input for the model checking algorithms. Unfortunately, both
[11] and [12] develop exhaustive model checking algorithms, which causes the traditional state explosion problem and makes them not applicable to large size systems. In this work, we develop some suitable approximation tech- niques which are based on abstract interpretation [8] in order to drastically reduce the state space of model checking tccp thus providing a framework where exhaustive analysis of more complicated systems could be achieved.
Abstract model checking [7,10,17] combines abstract interpretation [8] and model checking [6] to improve the automatic verification of large systems. Ap- plying abstract model checking involves the abstraction of both the model to be analyzed (M ) and the properties to be checked within the model. Usually, in the classic abstract model checking literature, the abstract model M + is an over-approximation of the original one M , meaning that each possible con- crete execution trace is mimicked in the abstract model. This approach allows one to verify properties which regard all the possible behavior paths. Two techniques have been successfully developed to construct M +. The predicate abstraction approach consists of substituting some selected model expressions with boolean variables, which leads to important simplifications (e.g., this is used in the tool SLAM [3,2]). In contrast, the data abstraction method re- duces the type of certain data by transforming its original concrete domain into an approximate and simpler domain. For instance, this second approach has been used for abstracting models in the tools Bandera [16] and αSPIN [13]. In this paper, we follow the data abstraction method to approximate tccp computations. The common way of formalizing this technique is to introduce abstract operations that over-approximate the original ones (see, for instance,
[14] where a data-based abstraction for the modeling language Promela is
developed). However, inaccurate abstract models would be obtained by over- approximation due to the time dimension of tccp. We overcome this problem by combining over- and under-approximation in the abstraction of tccp oper- ators. This approach is novel and allows us to build abstract models which are satisfactorily precise.
The abstraction of models usually involves adding non–determinism, due to the loss of information caused by the abstraction, and does affect the sus-


pension of processes: the suspension of a process in the original model does not generally imply that the process abstractly suspends. This is why abstraction is not adequate for analyzing system deadlocks. In the case of tccp, changing the suspension behavior might have undesirable consequences because pro- cesses are totally synchronized meaning that, at each time instant, all enabled agents (i.e., actions) involving a unit time are simultaneously carried out.
We have successively solved these two problems in the paper. First, we have defined an abstract semantics which takes into account the potential non– determinism added by the abstraction. We have proved that, provided the suspension behavior is correctly simulated, the abstract semantics is correct
w.r.t. the original one. We have also defined a source-to-source transformation from the tccp program into its abstract version which is valid for this case. Source-to-source transformations are particularly interesting in the context of abstract model checking because they permit reusing model checkers. Next, we have slightly modified the abstract semantics, solving the suspension problem mentioned above. Due to lack of space, the problem of abstracting properties to adapt them to the new model representation is not dealt with in the paper. The paper is organized as follows. Section 2 recalls the main features of the tccp language. In Section 3, we introduce our data abstraction methodology for tccp. We also present the abstract semantics for tccp, which does not take into account the potential suspension of processes. Section 4 discusses the correctness of this semantics and introduces a refined abstract semantics which correctly models process suspension. Finally, Section 5 shows the conclusions
and discusses some future work.



The tccp language

In [4], the Timed Concurrent Constraint language (tccp in short) was defined as an extension of the Concurrent Constraint programming language ccp [19]. In the cc paradigm, the notion of store as valuation is replaced by the notion of store as constraint. The computational model is based on a global store where constraints are accumulated, and a set of agents which interact with the store. The model is parametric w.r.t. a cylindric constraint system C defined below. In tccp, a new conditional agent (now c then A else A) is introduced (w.r.t. ccp) which makes it possible to model behaviors where the absence of information can cause the execution of a specific action. Intuitively, the execution of a tccp program evolves by asking and telling information to the store. Let us

briefly recall the syntax of the language:
A ::= stop | tell(c) | Σ ask(ci) → Ai | now c then A else A | A||A | ∃xA | p(x)
i=1
where c, ci are ﬁnite constraints (i.e., atomic propositions) of C. A tccp process P is an object of the form D.A, where D is a set of procedure declarations of the form p(x) :: −A, and A is an agent. 6
Intuitively, the stop agent finishes the execution of the program, tell(c)
adds the constraint c to the store, whereas the choice agent (Σn ask(ci) →
Ai) consults the store and non-deterministically executes the agent Ai in the
following time instant, provided the store satisfies the condition ci; otherwise the agent suspends. The conditional agent (now c then A else B) can detect negative information in the sense that, if the store satisfies c, then the agent A is executed; otherwise (even if ¬c does not hold), B is executed. A1||A2 executes the two agents A1 and A2 in parallel. The ∃x A agent is used to hide the information regarding x, i.e., it makes x local to the agent A.
The notion of time is introduced by defining a global clock which synchro- nizes all agents. In the semantics, the only agents which consume time (timing agents) are the tell, choice and procedure call agents.
We show an example of a tccp program in Figure 1. This program models a photocopier by means of four procedure declarations which represent the two main processes (user(C,A) and photocopier(C,A,Max,E,T)) and the syn- chronization of such processes (system(Max,E,C,A,T) and initialize(Max)).
Agent user(C,A) can execute non-deterministically three different actions or do nothing. The system is assumed to be synchronous, in the sense that the user cannot execute any action (through stream C) before the photocopier satisfies the previous request. This fact is modeled by the stream variable A. The stream variable T is used to detect if no request has been received after Max time units. When this occurs, the photocopier is automatically turned- off. The system is initialized (initialize(Max)) and then synchronized by
executing in parallel the photocopier and the user processes.

Abstracting tccp programs
Recently, some model checking algorithms have been formalized for the con- current constraint paradigm. The common idea behind them is to exploit the constraint nature of the language to represent the model of the system in a compact way. However, the state explosion problem of classical model

6 We assume that all programs which we consider in this work are well typed.


user(C,A)::= ask(A=[free| ]) → tell(C=[on| ]) + ask(A=[free| ]) → tell(C=[off| ]) + ask(A=[free| ]) → tell(C=[nc| ]) + ask(A=[free| ]) → tell(true).
photocopier(C,C’,A,A’,Max,E,E’,T,T’)::= ∃  Aux,Aux’(
now (T=[Aux| ] ∧ Aux>0) then now (C=[on| ]) then
tell(E’=[going| ] ∧ T’=[Max| ] ∧ A’=[free| ])
else now (C=[off| ]) then
tell(E’=[stop| ] ∧ T’=[Max| ] ∧ A’=[free| ])
else now (C=[nc| ]) then
tell(E’=[going| ] ∧ T’=[Max| ] ∧ A’=[free| ])
else tell(Aux’=Aux-1) || tell(T’=[Aux’| ] ∧ A’=[free| ])
else tell(E’=[stop| ]) || tell(A’=[free| ])).
system(Max,E,C,A,T)::= ∃ E’,C’,A’,T’(tell(E=[ |E’]) || tell(C=[ |C’]) ||
tell(A=[ |A’]) || tell(T=[ |T’]) || user(C,A) ||
ask(true)→ask(true)→photocopier(C,C’,A,A’,Max,T,T’,E,E’) ||
ask(A’=[free| ])→system(Max,E’,C’,A’,T’)).
initialize(Max)::= ∃ E,C,A,T(tell(A=[free| ]) || tell(T=[Max| ]) ||
tell(E=[off| ]) || system(Max,E,C,A,T).
Figure 1. tccp program modeling a photocopier

checking techniques also happens in these algorithms. In order to avoid this problem, symbolic representations ([1,18]) and abstract models have been pro- posed ([10,14]), which we combine in this work.

Abstracting constraint systems
Definition 3.1 A simple constraint system is a structure such as ⟨C, ▶⟩ where
C is the set of atomic constraints and relation ▶⊆ ℘(C) ×C satisfies
C1.	u ▶ C, for all C ∈ u.	C2.	u ▶ C, if u ▶ C', ∀C' ∈ v, and v ▶ C
Relation ▶ may be extended to the relation ▶⊆ ℘(C) × ℘(C) as:
u ▶ v ⇐⇒ ∀C ∈ v, u ▶ C
Proposition 3.2 Relation ▶ has the following properties:
(Reflexivity) ∀u ∈ ℘(C).u ▶ u.
(Transitivity) ∀u, v, w ∈ ℘(C).u ▶ v, v ▶ w implies that u ▶ w.

During tccp program computation, stores are represented by elements of
℘(C). That is, if u ⊆ C is the current store, the information accumulated by u is the conjunction of all constraints C ∈ u. In addition, ▶ is the entailment relation used to deduce information from stores.
An abstract interpretation (an abstraction) of the simple constraint system (C, ▶) is given by defining an upper closure operator (uco) ρ : ℘(℘(C)) →
℘(℘(C)), that is, a monotonic (sst1 ⊆ sst2 then ρ(sst1) ⊆ ρ(sst2)), idempotent (ρ(sst) = ρ(ρ(sst))) and extensive (sst ⊆ ρ(sst)) operator. The intuition of this definition is that each store st ⊆ C is abstracted by its closure ρ({st}). Closures operators have many interesting properties. For instance, when the domain considered is a complete lattice, as (℘(℘(C)), ⊆), each closure operator is uniquely determined by the set of its fixed points. In the context of abstract interpretation, closure operators are important because abstract domains can be equivalently defined by using them or by Galois insertions as introduced in [9]. Let ι : ℘(℘(C)) → E be an isomorphism. Then, given an uco ρ : ℘(℘(C)) →
℘(℘(C)), structure (℘(℘(C)),ι ◦ ρ, ι−1, E) is a Galois insertion, where ι ◦ ρ and
ι−1 are the abstraction and concretization functions, respectively.
Note that, using abstract interpretation terminology, ρ({st}) is the most precise abstraction of the store st ∈ ℘(C) and if ρ({st}) ⊆ sst, then sst is also an abstraction of st.
    n mod 1=0 ¸¸¸¸¸¸¸¸¸
,n,mod 2=¸0¸¸¸	,n,mod 2=¸1¸¸¸
,,,	¸	,,,	¸

n mod 4=0 ¸¸	n mod 4=2
¸¸¸¸¸¸¸¸¸¸¸¸¸
n mod 4=1	 n mod 4=3
,,,, 

¸¸ ∅ ,    
Figure 2. Closure operator ρx


Example 3.3 Let C = {x = n, y = m|n, m ∈ N}, and ρx : ℘(℘(C)) →
℘(℘(C)) an abstraction which does not affect variable y, while the abstract value of x is given in Figure 2. In this figure, expression n mod a = b repre- sents the set of stores which contain the constraint x = n, with n mod a = b. In order to construct ρx, we define the following sets of stores where m ∈ N: [y = m]= {{y = m}}, [n mod a = b, y = m]= {{x = b + ak, y = m}|k ∈ N} and [n mod a = b]= {{x = b + ak}|k ∈ N}
Using the lub operator induced by the lattice shown in Figure 2 (denoted below as  ), we define operator  x over these sets as:
[n mod a1 = b1,y = m] .x[n mod a2 = b2,y = m] = [(n mod a1 = b1) .(n mod a2 = b2),y = m].
[n mod a1 = b1] .x[n mod a2 = b2] = [(n mod a1 = b1) .(n mod a2 = b2)].
[c1] .x[c2] = [c1] ∪ [c2], otherwise.
Now, ρx is defined as: ρx(∅) = ∅; ρx({st}) = [c] iff [c] is the smallest set of stores


such that st ∈ [c]; ρx({sti|i ∈ I}) = (.x)i∈Iρx({sti}).
The following definition introduces two dual entailment relations into the abstract constraint systems.
Definition 3.4 Given a simple constraint system ⟨C, ▶⟩ and an abstraction
ρ : ℘(℘(C)) → ℘(℘(C)), we define the over- and under-approximated constraint systems ⟨℘(C), ▶+⟩ and ⟨℘(C), ▶−⟩ where ▶+, ▶−⊆ ℘(℘(C)) × ℘(℘(C)) are:
ρ	ρ	ρ	ρ
sst1 ▶+ sst2 ⇐⇒ ∃u ∈ ρ(sst1), ∃v ∈ sst2 such that u ▶ v.
sst1 ▶− sst2 ⇐⇒ ∀u ∈ ρ(sst1), ∃v ∈ sst2,u ▶ v.
The following proposition justifies the names of the new structures given in the previous definition.
Proposition 3.5 Given a simple constraint system (C, ▶) and an abstraction
ρ : ℘(℘(C)) → ℘(℘(C)), then
1.	If u ▶ v, then ρ({u}) ▶+ {v}.	2.	If ρ({u}) ▶− {v}, then u ▶ v
ρ	ρ
Proposition 3.6 Given a simple constraint system ⟨C, ▶⟩ and an abstraction
ρ : ℘(℘(C)) → ℘(℘(C)), then
(Reflexivity for ▶+) ∀sst ∈ ℘(℘(C)).sst ▶+ sst.
ρ	ρ
(Transitivity for ▶−) ∀sst1, sst2, sst3 ∈ ℘(℘(C)).sst1 ▶− sst2, sst2 ▶− sst3
ρ	ρ	ρ
implies that sst1 ▶− sst3.
Intuitively, the image associated to a store by means of ▶+ is bigger than the one obtained by applying ▶− to the same store. However, it is worth noting
that, in general, relation ▶+ is not transitive and ▶− is not reflexive, as shown
ρ	ρ
in the following example. This means that abstract entailment relations lose
information with respect to the original relation as usual when abstraction is applied. In addition, each abstract relation loses only one of the two properties characterizing the entailment relations. This fact follows from the definition of the relations.
Example 3.7 Assume that the constraint system of Example 3.3 is extended with the constraint n mod 2 = 0 containing the natural meaning about value n of variable x.
▶+ is not transitive. {{x = 8}} ▶+ {{n mod 2= 0}} and {{n mod 2= 

ρ
0}} ▶+
ρx
{{x = 6}}, since {x = 6} ∈ ρx({{n mod 2= 0}}) and {x = 6}▶ 

{x = 6}. However, {{x = 8}} /▶+
▶− is not reflexive. {{x = 2}} /▶−
{{x = 6}}.
{{x = 2}}, since {x = 6} ∈ ρx({{x =

ρ	ρx
2}}) and {x = 6} /▶ {x = 2}.

Definition 3.8 Let us define the operator Hρ : ℘(℘(C)) → ℘(℘(C)) as
sst1 Hρ sst2 = ρ({u ∪ v|u ∈ sst1,v ∈ sst2,u ∪ v ▶ true}).
Operator Hρ provides the abstract information given by the accumulation of the constraints in its two operands. Note that, following the operational semantics of the language, inconsistent stores might appear (due to the tell agent), thus it is necessary to explicitly remove them from sst1 Hρ sst2 as is done by means of the operator Hρ. The following proposition states that operator Hρ correctly approximates ∪.
Proposition 3.9 For all u, v ∈ ℘(C) if u ∪ v ▶ true then ρ({u ∪ v}) ⊆
ρ({u}) Hρ ρ({v})
In tccp, special constraint systems called cylindric constraint systems are used. Cylindric constraint systems are defined as follows.
Definition 3.10 ⟨C, ▶, Var , ∃⟩ is a cylindric constraint system iff ⟨C, ▶⟩ is a simple constraint system, Var is a denumerable set of variables, and for each x ∈ Var , there exists a function ∃x : ℘(C) → ℘(C) such that for each u, v ∈ ℘(C):


u ▶ ∃xu
u ▶ v then ∃xu ▶ ∃xv
∃x(u ∪ ∃xv)= ∃xu ∪ ∃xv
∃x(∃yu)= ∃y(∃xu)

A set of diagonal elements for a cylindric constraint system is a family
{δxy ∈ C|x, y ∈ var} such that


∅▶ δxx
If y /= x, z then δxz =∃x(δxy∪δyz).
If x /= y then δxy ∪ ∃x(v ∪ δxy) ▶ v.

Diagonal elements allow us to hide variables, representing local variables, as well as to implement parameter passing among predicates. Thus, quan- tifier ∃x and diagonal elements δxy allow us to properly deal with variables in constraint systems. Assuming that the original constraint system ⟨C, ▶⟩ to be abstracted is a cylindric constraint system, and given an abstraction ρ : ℘(℘(C)) → ℘(℘(C)), in general, the over and under-approximated con-
straint systems ⟨℘(C), ▶+⟩ and ⟨℘(C), ▶−⟩ are not cylindric constraint systems.
ρ	ρ
Example 3.7 shows that some property of the underlying simple constraint sys-
tem may be lost during the abstraction process. In addition, the remaining properties concerning the existential quantifier or the diagonal elements may also be lost. An extensive study of the conditions that the abstraction ρ has to satisfy for the abstraction process to preserve all these properties can be found in [15] where a generalized semantics for logic concurrent languages is introduced. In short, ρ must satisfy some consistency properties to ensure

that the existential quantification behaves correctly. We extend function ∃x
to sets of stores as ∃x : ℘(℘(C)) → ℘(℘(C)) where ∃xsst = {∃xu|u ∈ sst}.
Example 3.11 Consider the tccp program modeling a photocopier shown in Figure 1. Let C be the set of atomic constraints appearing in the code. Define the set msg = {on, off , nc}. Given X, X' ∈ Var , construct the sets msg(X, X') = {X = [A|X']|A ∈ msg} and MSG = ∪X,X' ∈Var msg(X, X'). Divide each store u ∈ ℘(C) into the subsets u1 = u−MSG and u2 = u∩MSG. Then the upper closure operator ρ : ℘(℘(C)) → ℘(℘(C)) is defined as follows.

Given u ∈ ℘(C), then u' ∈ ρ({u}) if u' = u1 ∪ u'
where u'
is constructed by

choosing an element C' ∈ msg(X, X') whenever msg(X, X') ∩ u /= ∅.
Given u ∈ ℘(C), then ρ({u})= {u} iff ∀X, X' ∈ Var , msg(X, X') ∩ u = ∅.
ρ(sst)= (∪u∈sstρ({u})).
In short, function ρ abstracts the messages in msg. For instance,

ρ({{X = [on|X']}})= {{X = [off |X']}, {X = [on|X']}, {X = [nc|X']}}
Note that an implementation of this abstraction would substitute the con- crete constants on, off and nc by an abstract constant (for example, msg), thus making the abstract store simpler.
Abstract Semantics
The source-to-source transformation from the original model into the abstract one is a well-known technique of integrating abstraction and model checking [13,16] since it enables reusing the existing model checkers for the original language. In this section, we study the difficulties of applying this method to tccp programs.
In the case of tccp, the abstraction of now has to be done with special care. The reason for this is that the non-determinism introduced when abstracting this agent cannot be handled in tccp instantaneously. The use of ask involves passing one time unit. To solve this problem, we have introduced a new agent askα which allows us to introduce non-determinism without consuming time. We formalize the abstract operational semantics of a tccp model (with the new agent) in terms of a transition relation similar to the operational semantics of the original tccp language. Similarly to the original operational semantics of tccp, each transition involves time passing. However, we will show that the time aspects of tccp may impede the correct simulation of the synchronization of agents in the concrete model. This aspect differentiates
tccp from other modeling languages having no time aspects.



Figure 3. Abstract operational semantics of tccp
In the semantic rules, we are assuming that an abstraction operator ρ :
℘(℘(C)) → ℘(℘(C)) has been provided and it has the properties discussed in Section 3.1. We have dropped the subindex ρ from ▶+, ▶− and H in order to simplify the presentation. For the same reason, in the sequel, we write sst ▶+ c, sst ▶− c and sst H c for sst ▶+ {{c}}, sst ▶− {{c}} and sst H {{c}}. The two main points of the abstract semantics are the new askα agent and the abstraction of the conditional agent. We show the transition rules for each agent in Figure 3. 7 A conﬁguration of the form ⟨Γ, sst⟩ represents a computation state, where Γ is a multiset of agents and sst ∈ ℘(℘(C)) is an
abstract store.
Let us now explain the main differences between the abstract semantics and the concrete one defined in [4]. The first important point to observe in the semantics is the use of the two abstract entailment relations ▶+ and ▶−. The

7 In rule R12, the superscript in ∃dB represents the information accumulated during the execution of the agent B. See [4] for details.


application of the different rules in Figure 3 depends on these two abstract entailment relations. In particular, under-approximation is used only for the conditional agent. There is a completely new rule (R4), which defines the semantics for the instantaneous choice agent (askα). This rule states that, provided agent Aj can evolve to agent A' , the instantaneous choice can evolve to A' . It is important to remark the timing difference between rule R3 and rule R4. Both of them introduce non-determinism but a time unit is consumed in the first one before executing the agent in the body of the ask agent, whereas in the second rule, non-determinism is introduced instantaneously.

Program Abstraction
In this section, we give a first step towards a source-to-source transformation of tccp programs into abstract programs which represent an approximate model of the system. For each tccp agent A, we inductively construct a corresponding abstract tccp agent α(A) as is shown in Figure 4.

Figure 4. α-transformation for tccp programs

The intuitive idea of the transformation of the conditional agent is as follows. We let ▶− (▶+) represent a suitable under (over) approximation of the entailment relation ▶ of the constraint system. In order to represent the possible conditional execution in the concrete model by an execution in the corresponding abstract model, we consider the following four possible cases, where st ∈ ℘(C) and sst ∈ ℘(℘(C)) are, respectively, the concrete store and the abstract one, and ρ({st}) ⊆ sst.
if st ▶ c and sst ▶− c, then B1 is executed in both the concrete and the abstract models,


if st ▶ c and sst /▶− c, then agent B1 is executed in the concrete model whereas any of the agents B1 or B2 could be executed in the abstract one,
if st /▶ c but sst ▶+ c, then in the concrete model agent B2 is executed, whereas any of the agents B1 or B2 could be executed in the abstract one,
if st /▶ c and sst /▶+ c, then both the abstract and the concrete models execute agent B2.
Note that the combination of the two abstract entailment relations al- lows us to precisely approximate the behavior of now for the first case above, whereas this could not be obtained by using only ▶+.

Correctness
In this section, we demonstrate that some additional conditions concerning the suspension behavior of the program are needed for the abstract semantics of tccp programs to correctly approximate the standard one. In the case these conditions hold, we develop an abstraction-by-transformation method which allows us to approximate tccp computations. Finally, we show how the abstract semantics can be refined in order to preserve suspension. However, the transformation method for implementing abstraction can not be directly applied to the refined abstract semantics anymore.
Conditions to obtain correctness
Given a tccp program (a process) P of the form D.Γ0 and an initial configura- tion ⟨Γ0, st0⟩,a trace t of P starting at ⟨Γ0, st0⟩ is a sequence of configurations t = ⟨Γ0, st0⟩ −→ ··· built using the transition rules given by the operational semantics. Let O(P )(⟨Γ0, st0⟩) denote the set of traces generated using the standard operational semantics given in [4]. We say that a concrete trace t =⟨Γ0, st0⟩ −→ ·· ·∈ O(P )(⟨Γ0, st0⟩) is erroneous iff ∃i ≥ 0.sti is not consistent.
Similarly, given an abstraction ρ, let Aρ(Pα)(⟨Γ0, sst0⟩) denote the set of abstract traces generated by the abstract program P α using the abstract operational semantics given by Figure 3. Note that abstract program P α may include the new agent askα.
Given a trace t = ⟨Γ0, st0⟩ −→ ⟨Γ1, st1⟩ −→ ··· ∈ O(P )(⟨Γ0, st0⟩), we de- note with α(t) the abstract trace obtained by applying the transformation α presented previously to the agents in the configurations of t, and abstract- ing the corresponding stores using ρ, that is, α(t) = ⟨α(Γ0), ρ({st0})⟩ −→
⟨α(Γ1), ρ({st1})⟩ −→ ··· . In addition, given two abstract traces tα=⟨Γα, sst01)⟩
1	0
−→ ⟨Γα, sst11⟩ −→ ··· and tα = ⟨Γα, sst02})⟩ −→ ⟨Γα, sst12⟩ −→ ··· , we write
1	2	0	1
tα ± tα when ∀i ≥ 0.ssti1 ⊆ ssti2.
1	2


Conditions for Correctness (CC) Assume that function ρ preserves the local suspension from the concrete configurations to the abstract ones, that is, for all configuration Γ and for each store st, if ⟨Γ, st⟩ /−→ and ρ({st}) ⊆ sst then ⟨α(Γ), sst)⟩ /−→.
Theorem 4.1 Given a tccp program P, an initial conﬁguration ⟨Γ0, st0⟩ and an abstraction function ρ : ℘(℘(C)) → ℘(℘(C)) satisfying condition CC, then for each non erroneous trace t ∈ O(P )(⟨Γ0, st0⟩) there exists an abstract trace tα ∈ Aρ(α(P ))(⟨α(Γ0), ρ({st0})⟩) such that α(t) ± tα.
Example 4.2 The abstraction given in Example 3.11 of the tccp program illustrated in Figure 1 satisfies CC. Note that the concrete model never sus- pends if stream C has a message, and the same applies to the abstract model. In addition, if C has no message, both the concrete and the abstract model suspend. Therefore, Theorem 4.1 may be applied in this case. This abstrac- tion is useful to check properties like “the photocopier is switched off when it is inactive during M ax time units”.
The abstraction may modify some time aspects, in such a way that abstract agents are not correctly synchronized, as illustrated by the following example.
Example 4.3 Consider the abstraction given by Figure 2 which takes into account the divisibility by four of variable X (recall that the abstract store n mod 4 = 0 represents the stores where X = n and n satisfies this condition). Figure 5 shows that if CC does not hold, the abstract model does not correctly simulate the original one. In the figure, the new agents A’ and B’ appear since A and B could evolve to these agents when rules R5 or R7 are applied.

Implementation of the abstract semantics
In Section 3 we showed how it is possible to abstract tccp programs. An abstract semantics for the abstract model and a program transformation of the program was formulated. In this section, we show how we can implement the abstract semantics by using only the original tccp agents, i.e., eliminating the askα agent thus obtaining a source-to-source trasnformation from the concrete to the abstract model. We also prove that the implementation corresponds to the intended behavior of the abstract semantics.
We first recall the transformation of the conditional agent:
α(now c then B1 else B2) = now c then α(B1) else askα(c) → α(B1) + askα(true) → α(B2)
If we simply substitute the askα agent by the original ask one, then the body agent in the abstract model is executed in the current time instant, whereas in the new version it is executed in the next one. This means that


Concrete Trace
STORE	AGENTS

X=0	ask(X=4) → tell(Y=2) || ask(true) → ask(true) → now Y=2 then A else B
X=0	ask(X=4) → tell(Y=2) || ask(true) → now Y=2 then A else B

X=0	ask(X=4) → tell(Y=2) || now Y=2 then A else B
X=0	ask(X=4) → tell(Y=2) || B’

Abstract trace
STORE	AGENTs

n mod 4 = 0	ask(X=4) → tell(Y=2) || ask(true) → ask(true) → now Y=2 then A else B ask(true) → ask(true) → now Y=2 then A else B

n mod 4 = 0	tell(Y=2) || ask(true) → now Y=2 then A else B
n mod 4 = 0 ∧ Y=2	now Y=2 then A else B

n mod 4 = 0 ∧ Y=2	A’
Figure 5. A non correct abstract model

other agents that could eventually be executed concurrently could introduce information in the store which interferes with the execution, thus changing the program semantics.
In order to overcome this problem, we strategically introduce delays in the program. For this purpose, we first apply a static analysis to the program which determines what is the maximum number (N ) of nested conditional agents in the program, and associates to each occurrence of timing agents an integer number which represents its relative depth (with respect to nested conditional agents). Aє denotes that the relative depth of A is ϵ.
In short, the transformed program is obtained by introducing N − ϵ delays for each Aє agent in the program. Note that it is also necessary to introduce the corresponding delay in the case when the choice agent suspends. This implies a more elaborated transformation which we do not present in this work due to the limited space. In Figure 6 we show the transformation associated to each agent. Notation (ask(true) →)N −є means that the ask(true) agent is replicated N − ϵ times.
Intuitively, we can imagine that we split each time instant into N parts. When we abstract a concrete program, the structure of the abstracted pro- gram ensures that all agents corresponding to concrete agents (except for the conditional agent) are executed in the last part of each N block. Furthermore, the execution of conditional agents will start during the corresponding part of the block depending on its relative depth.
Given a program P , we call P β to the β-program transformation. Next we prove that the β-transformation described above is correct. We say that



Figure 6. β-transformation of tccp programs
the transformation is correct if, for all P , P β simulates the behavior of P α
obtained by applying the α-transformation described in Section 3.
We define the notion of observable for β-programs as NOb(P β)(⟨Γ0, sst0⟩)
= {⟨Γ0∗N , sst0∗N ⟩ −→ ⟨Γ1∗N , sst1∗N ⟩ −→ ⟨Γ2∗N , sst2∗N ⟩ −→ ... | ⟨Γ0, sst0⟩ −→
⟨Γ1, sst1⟩ −→ ⟨Γ2, sst2⟩ ... ∈ Aρ(Pβ)(⟨Γ0, sst0⟩)}
Theorem 4.4 Given a tccp program P, an initial conﬁguration ⟨Γ0, sst0⟩ and an abstraction function ρ : ℘(℘(C)) → ℘(℘(C)) then
NOb(P β)(⟨Γ0, sst0⟩)= Aρ(Pα)(⟨Γ0, sst0⟩)
The proof is based on the demonstration that the β-abstraction models the α-abstraction (and vice-versa), and is done by induction on both the length of traces (for the procedure call case) and the structure of agents.

A Correct Abstract Semantics
We finalize the discussion about the correct simulation of a tccp program by giving an abstract semantics where the problem shown by Figure 5 is solved. The idea is to non-deterministically allow the repetition of an abstract configuration when it is possible that some concretization may suspend. Note that again, in this case, the use of the abstract entailment relation ▶− makes it possible to precisely represent this situation.
Consider the transition system obtained by modifying the abstract seman- tics given in Figure 3 with the new rules presented by Figure 7, as follows. Rule R1 is substituted by rule R1’, rule R3’ is added, and rules R6, R8, R10 and R11 are dropped. Note that a configuration containing an ask is repli- cated with the new abstract semantics when it may suspend in the concrete semantics. This is how to simulate suspension in the abstract semantics.



Figure 7. New rules for a correct abstract semantics of tccp
The new semantics (A' ) gives us the desired result about correctness.
Theorem 4.5 Given a tccp program P of the form D.Γ0, an initial conﬁgu- ration ⟨Γ0, st0⟩ and an abstraction function ρ : ℘(℘(C)) → ℘(℘(C)), then for each non erroneous trace t ∈ O(P )(⟨Γ0, st0⟩) there exists an abstract trace tα ∈ A' (α(P ))(⟨α(Γ0), ρ({st0}⟩) such that α(t) ± tα.
Example 4.6 For instance, consider the traces given in Figure 5, with the new semantics we obtain the abstract simulation shown in Figure 8
New Abstract trace
STORE	AGENTs

X mod 4 = 0	ask(X=4) → tell(Y=2) || ask(true) → ask(true) → now Y=2 then A else B
X mod 4 = 0	ask(X=4) → tell(Y=2) || ask(true) → now Y=2 then A else B

X mod 4 = 0	ask(X=4) → tell(Y=2) || now Y=2 then A else B
X mod 4 = 0	ask(X=4) → tell(Y=2) || B’

Figure 8. A correct abstract model


Conclusions and Future Work
In this work, we have proposed a methodology which mitigates the state explo- sion problem in tccp model checking. We have defined a source-to-source trans- formation for tccp programs which is based on over- and under-approximating constraint systems. The abstraction of the conditional tccp agent introduces some specific difficulties which have been solved by using under-approximation in the abstract semantics; this idea is novel since only over-approximations are typically used when approximating models in the data abstraction approach. The inspiration to combine over- and under-approximation in model–checking tccp comes from [13]. Moreover, we have proved that correctness of the se- mantics is not guaranteed unless several conditions concerning the suspension of agents do hold. We also provide a simple refinement of the abstract seman- tics which overcomes this problem. Unfortunately, we obtain a computation model which is not the one of tccp anymore. As future work, we plan to complete our methodology by defining an approximation technique for the


properties that must be verified. We intend to formulate this method also as a source-to-source transformation, which will allow us to compare the state- spaces generated by the exhaustive classical method to the one proposed here.

References
Alpuente, M., Falaschi, M. and Villanueva, A., Symbolic Model Checking for Timed Concurrent Constraint Programs, in: Proc. of III Jornadas de Programaci´on y Lenguajes, Alicante, 2003.
Ball, T., Podelski, A. and Rajamani, S.K., Relative completeness of abstraction reﬁnement for software model checking, in: TACAS’02, LNCS 2280:158–172, (2002).
Ball, T. and Rajamani, S.K., The slam project: Debugging system software via static analysis, in: Proc. of POPL 2002, 2002, pp. 1–3.
Boer, F. de, Gabbrielli, M. and Meo, M.C., A Timed Concurrent Constraint Language., Information and Computation 161 (2000), pp. 45–83.
Boer, F. de, Gabbrielli, M. and Meo, MC., A Temporal Logic for reasoning about Timed Concurrent Constraint Programs, in: Proc. of 8th Int. Symposium on Temporal Representation and Reasoning (2001), pp. 227–233.
Clarke, E.M., Emerson, E.A. and Sistla, A.P., Automatic veriﬁcation of ﬁnite- state concurrent systems using temporal logic speciﬁcations, ACM Transactions on Programming Languages and Systems 8 (1986), pp. 244–263.
Clarke, E.M., Grumberg, O. and Long, D.E., Model Checking and Abstraction, ACM Transactions on Programming Languages and Systems 16 (1994), pp. 1512–1542.
Cousot, P. and Cousot, R., Abstract interpretation: A uniﬁed lattice model for static analysis of programs by construction or approximation of ﬁxpoints, in: Proc. of POPL (1977), pp. 238–252.
Cousot, P. and Cousot, R., Systematic Design of Program Analysis Frameworks, in:
Proc. of POPL (1979), pp. 269–282.
	Dams, D., Gerth, R. and Grumberg, O., Abstract interpretation of reactive systems, ACM Transactions on Programming Languages and Systems 19 (1997), pp. 253–291.
	Falaschi, M., Policriti, A. and Villanueva, A., Modeling Timed Concurrent systems in a Temporal Concurrent Constraint language - I, Selected papers from 2000 Joint Conference on Declarative Programming, ENTCS 48 (2000).
	Falaschi, M. and Villanueva, A., Automatic veriﬁcation of timed concurrent constraint programs (2003), submitted for publication.
	Gallardo, M., Mart´ınez, J., Merino, P. and Pimentel, E., αspin: a tool for abstract model checking, Int. Journal on Software Tool for Technology Transfer online version http://sttt.cs.uni-dortmund.de/ (2003).
	Gallardo, M., Merino, P. and Pimentel, E. A generalized semantics of promela for abstract model checking, Formal Aspects of Computing to appear (2004).


	Giacobazzi, R., Debray, S.K. and Levi, G., Generalized semantics and abstract interpretation for constraint logic programs, J. of Logic Progr. 25 (1995), pp. 191–247.
	Hatcliff, J., Dwyer, M., Pasareanu, C. and Robby, Foundations of the bandera abstraction tools, in: The Essence of Computation, LNCS 2566, pp. 172–203.
	Loiseaux, C., Graf, S., Sifakis, J. and Boujjani, S.B.A., Property preserving abstractions for the veriﬁcation of concurrent systems, Formal Methods in System Design 6 (1995),
pp. 1–35.
McMillan, K.L., Symbolic Model Checking: An Approach to the State Explosion Problem
Kluwer Academic, 1993.
	Saraswat, V.A., Concurrent Constraint Programming Languages, The MIT Press, Cambridge, MA, 1993.
	Saraswat, V.A., Jagadeesan, R. and Gupta, V., Foundations of Timed Concurrent Constraint Programming, in: Proc. 9th IEEE Symposium on LICS (1994), pp. 71–80.
