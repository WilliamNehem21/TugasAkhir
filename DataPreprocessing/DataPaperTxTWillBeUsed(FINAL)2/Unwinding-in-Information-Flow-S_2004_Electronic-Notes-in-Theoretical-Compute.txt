 Electronic Notes in Theoretical Computer Science 99 (2004) 127–154 
www.elsevier.com/locate/entcs




Unwinding in Information Flow Security *

A. Bossi1	R. Focardi2	D. Macedonio3	C. Piazza4	S. Rossi5
Dipartimento di Informatica, Universita` Ca’ Foscari di Venezia via Torino 155, 30172 Venezia, Italy

Abstract
We study information flow security properties which are persistent, in the sense that if a system is secure then all of its reachable states are secure too. We present a uniform characterization of these properties in terms of a general unwinding schema. This unwinding characterization allows us to prove several compositionality properties of the considered security classes. Moreover, we exploit the unwinding condition to dictate the form of the rules we can use to incrementally develop secure processes and to rectify insecure processes.


Introduction
Information flow security properties have been proposed as a means to ensure confidentiality of classified information in multilevel systems. These properties impose constraints on information flow among different groups of entities with different security levels. Often only two groups are considered and are labelled with the security levels high (H) and low (L). The condition is that no information should flow from H to L.

 This work has been partially supported by MIUR project “Modelli formali per la si- curezza”, the EU project MyThS (IST-2001-32617) and the FIRB project (RBAU018RCZ) “Interpretazione astratta e model checking per la verifica di sistemi embedded”.
1 Email: bossi@dsi.unive.it
2 Email: focardi@dsi.unive.it
3 Email: mace@dsi.unive.it
4 Email: piazza@dsi.unive.it
5 Email: srossi@dsi.unive.it


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.02.006

The necessity of controlling information flow as a whole (both direct and indirect) motivated Goguen and Meseguer in introducing the notion of Non- interference [19,20]. Non-Interference formalizes the absence of information flow within deterministic systems. Given a system in which conﬁdential (i.e., high level) and public (i.e., low level) information may coexist, non-interference requires that confidential inputs never affect the outputs on the public inter- face of the system, i.e., never interfere with the low level users. If such a property holds, one can conclude that no information flow is ever possible from high to low level.
Starting from Sutherland [36], many definitions extending the concept of non-interference to non-deterministic systems have been proposed in the litera- ture. They are developed in different settings such as programming languages [4,33,34,35], trace models [25,26], process calculi [11,14,22,30,31,32], proba-
bilistic models [2,12], timed models [15,21], cryptographic protocols [1,5,16].
In [13], Focardi and Gorrieri express the concept of non-interference in the Security Process Algebra (SPA) language, in terms of bisimulation semantics. In particular, inspired by [37], they introduce the notion of Bisimulation- based non Deducibility on Compositions (BNDC ): a system E is BNDC if what a low level user sees of the system is not modified (in the sense of the bisimulation semantics) by composing any high level process Π with E. The main advantage of BNDC with respect to trace-based properties is that it is powerful enough to detect information flows due to the possibility, for a high level malicious process, to block or unblock a system. In particular, in [13,14], it is shown that a malicious process may build a channel from high to low, by suitably blocking and unblocking some system services accessible by low level users. The system used to build this covert channel turns out to be secure with respect to trace-based properties. This motivates the use of more discriminating equivalences such as bisimulation.
Although Martinelli [24] has shown that a class of BNDC -like properties is decidable over finite state processes, the problem of efficiently verifying BNDC is still open. Indeed, decidability of BNDC is an open problem. The main difficulty consists of getting rid of the universal quantification on high level processes Π. Another drawback of BNDC is that it is not compositional with respect to the main SPA operators, such as the parallel composition and the nondeterministic choice. Compositionality results are useful since they help in designing efficient verification algorithms and in defining proof systems which allow one to incrementally build systems which are secure by construction.
For these reasons many decidable and compositional sufficient conditions for BNDC have been studied in the literature. In [9] it has been proved that four of these sufficient conditions, namely Persistent BNDC (P BNDC ),

Strong BNDC (SBNDC ), Compositional P BNDC (CP BNDC ), and Pro- gressing P BNDC (PP BNDC ), can be characterized in terms of unwinding conditions.
Unwinding conditions demand properties of individual actions: they aim at “distilling” the local effect of performing high level actions. As observed by many authors (see [31,29,23,32]) they are easier to handle and more amenable to automated proof with respect to global conditions.
In this paper we bridge the gap between unwinding conditions and com- positionality. In particular, we introduce a parametric notion of unwinding which generalizes the unwinding characterizations considered in [9]. We ex- ploit the parametric unwinding condition to formulate general composition- ality results. Such results aim at establishing a link between the semantics of the operator with respect to which we want to ensure compositionality and the relations involved in the unwinding condition. The compositionality properties of P BNDC, SBNDC, CP BNDC, and PP BNDC are just special instances of our general results. In the same spirit, we analize how to preserve unwinding conditions under reﬁnement (see [8]). By exploiting the parametric unwinding condition and its general compositionality properties, we can also define proof systems (see [7]) which allow us to build processes which are se- cure by construction. Finally we suggest methods to rectify (see [6]) insecure processes in order to obtain processes which satisfy the unwinding conditions characterizing specific security properties.
The paper is organized as follows. In Section 2, we recall the syntax and the semantics of the SPA language. In Section 3 we introduce the security properties BNDC and P BNDC. Moreover, in Section 3.1 we define a general unwinding schema and give a uniform presentation of the security properties P BNDC, SBNDC, CP BNDC, and PP BNDC as different instances of the general schema. In Section 4 we analize the relationships between unwind- ing conditions and compositionality with respect to the SPA operators and refinement. We exploit these results to develop proof systems for properties characterized through unwinding. In Section 5 we exploit the general unwind- ing schema to present a method for rectifying insecure processes. Finally, in Section 6 we draw some conclusions.
This paper surveys previous work by the authors [6,7,8,9,10]. The above mentioned general framework is an original contribution which allows us to uniformly present our results and also to generalize some of them.

Preliminaries
In this section we report the syntax and semantics of the process algebra we consider. It is a variation of Milner’s CCS [27], similar to the Security Process Algebra (SPA, for short) language [14], where the set of visible actions is partitioned into high level actions and low level ones in order to specify multilevel systems. In addition to constant definitions, we allow one to use the replication (!) operator for defining recursive systems.
The syntax of our process algebra is based on the same elements as CCS that is: a set L of visible actions such that L = I ∪ O where I = {a, b,.. .} is a set of input actions and O = {a¯, ¯b,.. .} is a set of output actions; a
special action τ which models internal computations, i.e., not visible outside the system; a complementation function ¯· : L → L, such that a¯ = a, for all a ∈ L. Act = L ∪ {τ } is the set of all actions. The set of visible actions is partitioned into two sets, H and L, of high and low actions such that H = H and L = L.
The syntax of SPA terms 6 (or processes) is defined as follows:
E ::= 0 | a.E | E + E | E|E | E \ v | E[f ] | Z | !E

where a ∈ Act , v ⊆ L, f : Act → Act is such that f (α¯) = f (α), f (τ ) = τ , f (H) ⊆ H ∪ {τ }, and f (L) ⊆ L ∪ {τ }, and Z is a constant that must be associated with a definition Z d=ef E.
Intuitively, 0 is the empty process that does nothing; a.E is a process that can perform an action a and then behaves as E; E1 + E2 represents the nondeterministic choice between the two processes E1 and E2; E1|E2 is the parallel composition of E1 and E2, where executions are interleaved, possibly synchronized on complementary input/output actions, producing an internal action τ ; E \ v is a process E prevented from performing actions in v; E[f ] is the process E whose actions are renamed via the relabelling function f ; !E (bang E) is the process E|E| .. ., i.e., the parallel composition of as many copy as needed of the process E.
We say that a process E is guarded if it can be built by using the rule
a.E + a.E instead of E + E in the syntax of SPA terms above.
We denote by E the set of all SPA processes and by EH the set of all high level processes, i.e., those constructed only using actions in H ∪ {τ }.
The operational semantics of SPA agents is given in terms of Labelled Transition Systems (LTS, for short). A LTS is a triple (S, A, →) where S is a

6 Actually, the SPA syntax does not include the ! operator. We maintain the name SPA for our language since adding ! does not increase the expressive power of the language.

set of states, A is a set of labels (actions), →⊆ S × A × S is a set of labelled
transitions. The notation (S , a,S ) ∈→ (or equivalently S  →a  S ) means
1	2	1	2
that the system can move from the state S1 to the state S2 through the action
a. The operational semantics of SPA is the LTS (E , Act , →), where the states are the terms of the algebra and the transition relation →⊆ E × Act × E is defined by structural induction as the least relation generated by the inference rules depicted in Figure 1. We use also the notion of rooted labelled transition system which is a LTS augmented with a distinguish node, the root. Given a process E we denote by LT S(E)= (SE, E, Act , →) the rooted LTS constituted of the subpart of the SPA LTS reachable from E. E is a ﬁnite-state process if LT S(E) has a finite number of nodes, that is SE is finite.
The concept of observation equivalence is used to establish equalities among processes and it is based on the idea that two systems have the same semantics if and only if they cannot be distinguished by an external observer. This is obtained by defining an equivalence relation over E. The strong bisimulation relation [27] equates two processes if they are able to mutually simulate their behavior step by step.
We will use the following auxiliary notations. Act ∗ denotes the set of (possibly empty) sequences of actions, while Act + denotes the set of nonempty
a1	an
sequences of actions. If t = a1 ··· an ∈ Act ∗ and E → ··· → E', then we write
E →t E'. We also write E =⇒t	E' if E(→τ )∗ →a1 (→τ )∗ ··· (→τ )∗ →an (→τ )∗E' where
(→τ )∗ denotes a (possibly empty) sequence of τ labelled transitions. If t ∈ Act ∗, then tˆ∈ L∗ is the sequence gained by deleting all occurrences of τ from t. As

a consequence, E
=aˆ⇒ E' stands for E
=a⇒ E' if a ∈ L, and for E(→τ )∗E'

if a = τ (note that =τ⇒ requires at least one τ labelled transition while =τ⇒ˆ
means zero or more τ labelled transitions). We say that E' is reachable from

E when there exists t ∈ Act ∗ such that E →t
set of all sates reachable from E.
E'. We denote by Reach(E) the

The notion of strong bisimulation can be defined through the simulation
preorder as follows.
Definition 2.1 [Simulation] A binary relation R ⊆ E × E over agents is a
simulation if (E, F ) ∈ R implies, for all a ∈ Act ,

if E →a
E', then there exists F ' such that F →a
F ' and (E',F ') ∈ R.

An agent E is simulated by another agent F , denoted by E ≤ F , if there exists a simulation R containing the pair (E, F ).
The relation ≤ is the largest simulation and it is a preorder relation, i.e., it is reflexive and transitive.





Prefix

Sum



E →a
—
a.E →a
'
1

E
→a	'



E1 + E2 →	'	E1 + E2 →	'

E1 →
E |E →a

'
1
E' |E
E2 →
E |E	→a

'
2
E |E'

Parallel
1	2	1
E →a
2
'  E2
1
→a¯
2	1	2
'
2 a ∈ L 

E |E →τ  E' |E'
1	2	1	2


Restriction
E →a
E \ v →a
E'
E' \ v

if a /∈ v


Relabelling
E →a E'


f (a)

E[f ] → E'[f ]


Constant

Replication



E →a
E →a
Z →a
E'

E'
E'
E →a
if Z d=ef E E' E →a¯





E''




a ∈ L 

!E →
E'|!E
!E →
E'|E''|!E




Fig. 1. The operational rules for SPA
Definition 2.2 [Strong Bisimulation] A binary relation R ⊆ E×E over agents is a strong bisimulation if both R and R−1 are simulations.
Two agents E, F ∈ E are strongly bisimilar, denoted by E ∼B F , if there exists a strong bisimulation R containing the pair (E, F ).
The relation ∼B is the largest strong bisimulation and it is an equivalence relation.
In many applications strong bisimulation is too demanding, i.e., it is too fine. In particular, the internal transitions are treated as all the other actions. The weak bisimulation relation is similar to strong bisimulation, but it does not care about internal τ actions.

Definition 2.3 [Weak Bisimulation] A binary relation R ⊆ E ×E over agents is a weak bisimulation if (E, F ) ∈ R implies, for all a ∈ Act ,

if E →a
if F →a
E', then there exists F ' such that F =aˆ⇒ F ' and (E',F ') ∈ R;
F ', then there exists E' such that E =aˆ⇒ E' and (E',F ') ∈ R.

Two agents E, F ∈ E are weakly bisimilar, denoted by E ≈B F , if there exists a weak bisimulation R containing the pair (E, F ).

The relation ≈B is the largest weak bisimulation and it is an equivalence relation [27].
In our security properties we need the notions of weak bisimulation on low actions, which equates processes which are bisimilar from the low level user point of view, and progressing bisimulation on low actions, which also requires that each τ action is simulated by at least one τ .

Definition 2.4 [Weak Bisimulation on Low Actions] A binary relation R ⊆ E × E over agents is a weak bisimulation on low actions if (E, F ) ∈ R implies, for all l ∈ L ∪ {τ },

if E →l
if F →l
E', then there exists F ' such that F F ', then there exists E' such that E
=lˆ F ' and (E',F ') ∈ R;
=lˆ E' and (E',F ') ∈ R.

Two agents E, F ∈ E are weakly bisimilar on low actions, denoted by E ≈L F ,
if there exists a weak bisimulation R containing the pair (E, F ).

It is immediate to prove that E ≈L F is equivalent to E \ H ≈B F \ F .
Progressing bisimulation on low actions is similar to weak bisimulation on low actions, but it is based on the notion of progressing bisimulation introduced in [28].

Definition 2.5 [Progressing Bisimulation on Low Actions] A binary relation R ⊆ E ×E over agents is a progressing bisimulation on low actions if (E, F ) ∈ R implies, for all l ∈ L ∪ {τ },

if E →l
E', then there exists F ' such that F =⇒
F ' and (E',F ') ∈ R;

if F →l
F ', then there exists E' such that E =⇒l
E' and (E',F ') ∈ R.

Two agents E, F are progressing bisimilar on low actions, denoted by E ≈L F ,
if there exists a weak bisimulation R containing the pair (E, F ).


Fig. 2. The LTS of the memory cell M x.
Bisimulation Based Security Properties
In [13], Focardi and Gorrieri express the concept of non-interference in terms of bisimulation semantics through the notion of Bisimulation-based non Deducibili- ty on Compositions (BNDC ). Property BNDC is based on the idea of checking the system against all high level potential interactions, representing every pos- sible high level malicious program. In particular, a system E is BNDC if for every high level process Π a low level user cannot distinguish E from (E|Π), i.e., if Π cannot interfere with the low level execution of the system E. In other words, a system E is BNDC if what a low level user sees of the system is not modified by composing any high level process Π to E.
Definition 3.1 [BNDC] Let E ∈ E. E ∈ BNDC if

∀ Π ∈ EH, E ≈L
(E|Π)

Example 3.2 Let us consider an abstract specification M x of a binary mem- ory cell. M x contains the binary value x and is accessible, by high and low users, through the four operations rh, wh, rL, wL representing a high read, a high write, a low read and a low write, respectively. Each operation is implemented through two different actions, one for each binary value. For example wh 0 and wh 1 indicate a high level user writing value 0 and 1, respectively. 7 The LTS of process M x is depicted in Figure 2.
M x d=ef r x . M x + w 0 . M 0+ w 1 . M 1
+ rL x . M x + wL 0 . M 0+ wL 1 . M 1
Notice that read (write) operations are modelled as outputs (inputs). Process M x can send the stored value x through the two output actions rh x and rL x. Moreover, write operations are performed by accepting an input wh y

7 The following expression for M x is indeed a definition scheme: the actual processes M 0 and M 1 are obtained by replacing x with 0 and 1, respectively.

and wL y (with y ∈ {0, 1}) and moving to M y, i.e., storing y into the memory cell.
Notice that M 0 and M 1 are totally insecure processes. As a matter of fact, a high level user may use the memory cell to directly send confidential information to the low level. Using BNDC we detect that M 0 and M 1 are insecure. In fact, considering the process Π ≡ wh 1.0 we get that (M0|Π)\H ≡ τ.M1 \ H which is not weak bisimilar to M0 \ H, since in τ.M1 \ H the low level user reads 1, while in M0 \ H he reads 0.
In [14], Focardi and Gorrieri observe that the BNDC property is diffi- cult to use in practice: its decidability is still an open problem. It would be desirable to have an alternative formulation of BNDC which avoids the universal quantification on high level processes and exploits local information only. One of the main difficulty in finding such an alternative characterization comes from the fact that BNDC is not persistent and thus the requirements on the processes reachable from a BNDC process E should be different from the requirements on E itself. In [17], it is introduced a security property called Persistent BNDC (P BNDC, for short), in which persistence is imposed by definition.
Definition 3.3 [P BNDC] Let E ∈ E. E ∈ P BNDC if
∀ E' ∈ Reach(E), E' ∈ BNDC .
The decidability of P BNDC over finite state processes has been proved in [17] by exploiting a bisimulation based characterization.
A standard way to protect confidential data is to apply the multilevel se- curity model of [3]. First, we need to assign a security level to any information containers (called objects); then the following access control rules are imposed:
(i) no low level user can read from high level objects; (ii) no high user can write into low level objects. Indeed, these are the only two (direct) ways for leaking confidential information. Sometimes they are sufficient to ensure security as described in the following example.
Example 3.4 The memory cell of Example 3.2 is neither BNDC nor P BNDC. In order to protect confidential data we can transform M x into both a high level cell Mh x (see Figure 3), by eliminating any low level read operation
(rule (i) above),
Mh x d=ef rh x . Mh x + wh 0 . Mh 0+ wh 1 . Mh 1
+ wL 0 . Mh 0+ wL 1 . Mh 1
and a low level cell ML x, by eliminating any high level write operation (rule
(ii) above):


Fig. 3. The LTS of the memory cell Mh x.

ML x d=ef r x . ML x + r x . ML x
+ wL 0 . ML 0+ wL 1 . ML 1
We can prove that both Mh x and ML x are P BNDC.
Other bisimulation based persistent security properties have been studied in the literature. We recall here the following: Strong BNDC (SBNDC, for short), introduced in [13], Compositional P BNDC (CP BNDC, for short), introduced in [8], and Progressing P BNDC (PP BNDC, for short), introduced in [9]. All these properties are included in the BNDC class, i.e., if a process satisfies one of them, then it is BNDC. In the next subsection we introduce them through a uniform unwinding definition.

Unwinding Deﬁnitions
The idea behind the notion of unwinding is to introduce some constraints on the transitions of the system (see [32]) which imply some global properties. In particular, when an unwinding condition is used to define a non-interference property it usually requires that each high level action can be “simulated” in such a way that it is impossible for the low level user to infer which high level actions have been performed (see [29]).
In this section we give a uniform presentation of the security properties P BNDC, SBNDC, CP BNDC, and PP BNDC by introducing a generalized unwinding condition. Our unwinding is parametric with respect to two binary relations on processes: an equivalence relation, ~L, which represents the low level indistinguishability and a transition relation, −−·, which characterizes the local connectivity required by the unwinding condition.
Definition 3.5 [Generalized Unwinding] Let ~L be a binary equivalence re- lation on E and −−· be a binary relation on E. We define the unwinding class

W(~L, −−·) as
W(~L, −−·) d=ef {E ∈ E | ∀ F, G ∈ Reach(E) and ∀ h ∈ H
if F →h G then ∃G' such that F −−· G' and G ~L G'}.

The unwinding condition characterizing an unwinding class clearly im- plies persistence. Moreover, any process E which does not perform high level actions belongs to any unwinding class W(~L, −−·), since the unwinding con- dition is trivially satisfied.
The following theorem follows from the unwinding characterizations of P BNDC studied in [7] and of PP BNDC studied in [9], and from the original definitions of SBNDC in [13] and of CP BNDC in [8].
Theorem 3.6 (Unwinding) Let E ∈ E be a process.

E ∈ P BNDC iff E ∈ W(≈L ,
=τ⇒ˆ );

E ∈ SBNDC iff E ∈ W(≈L , ≡);
E ∈ CP BNDC iff E ∈ W(≈L , =τ⇒);
E ∈ PP BNDC iff E ∈ W(≈L ,  τ⇒);
P  =
where ≡ is the syntactic equality between processes.
The above theorem helps us to understand the local meaning of our security properties. Let F be a process reachable from a P BNDC process E. If F can perform a high level transition reaching a process G, then F can also simulate such a move reaching, through a (possible empty) sequence of silent transitions, a process G' which is undistinguishable from G from a low level view. In the case of SBNDC the sequence of silent transitions is replaced by no transitions, i.e., G' is F itself, while in the case of CP BNDC and PP BNDC the silent sequence cannot be empty. Moreover, in PP BNDC weak bisimulation on low actions is replaced by progressing bisimulation on low actions.
Example 3.7 Consider the memory cells Mh x and ML x described in Ex- ample 3.4. Exploiting the unwinding characterization of P BNDC given in Theorem 3.6 it is easy to see that both Mh 0 and Mh 1 are P BNDC . First,
notice that Mh 0 ≈L Mh 1, since there is no way for a low level user to dis-
tinguish between the two states. As a matter of fact, the only possible low level actions are the two write operations wL 0, wL 1 which, both in Mh 0 and in Mh 1, move the system into the same states. The fact that ML 0 and ML 1 are P BNDC is even easier to prove: the only high level actions rh 0, rh 1 do not change the system state. Moreover, since neither Mh x nor ML x perform











Fig. 4. The LTS of the memory cell Nh x.

Fig. 5. Security Properties.

any τ transition, one can infer that they are also SBNDC. Finally, one can notice that Mh x and ML x are neither CP BNDC nor PP BNDC, since there are not τ moves executable by the two processes.
Consider now the processes Nh x (see Figure 4) and NL x obtained by adding a time-out realized by a τ -loop in the initial state of both Mh x and ML x, i.e.,
Nh x d=ef r x . Nh x + w 0 . Nh 0+ w 1 . Nh 1
+ wL 0 . Nh 0+ wL 1 . Nh 1+ τ . Nh x
NL x d=ef r x . NL x + r x . NL x
+ wL 0 . NL 0+ wL 1 . NL 1+ τ . NL x.
The processes Nh x and NL x are both CP BNDC and PP BNDC.
The unwinding characterizations allow us to easily prove that PP BNDC ⊂ CP BNDC ⊂ P BNDC, SBNDC ⊂ P BNDC, and the processes containing only low level actions satisfy all of them. The situation is summarized in Figure 5.

How to Incrementally Build Secure Processes
Compositionality is useful for both verification and synthesis. On one hand, if a property is preserved when systems are composed, then the analysis pro- cess can be decomposed and applied to subsystems in order to prove that the system as a whole satisfies the desired property. On the other hand, in the synthesis of a system, compositionality makes it possible to deal with all the subcomponents in a uniform way. In this section we analyze the relations be- tween the unwinding conditions and compositionality results. We show that all the security properties we considered are compositional with respect to the parallel operator, while not all of them are fully compositional. In particular, P BNDC and SBNDC are not preserved by the nondeterministic choice op- erator. In general, when we build a system that may (nondeterministically) choose to behave as one of two secure subsystems, we could obtain an inse- cure system. As also observed in [18], this seems to be counterintuitive. On the contrary, PP BNDC and CP BNDC are fully compositional, i.e., they are compositional also with respect to the nondeterministic choice.
Besides standard algebra operators, we also consider refinement operators which are useful for the stepwise development of secure processes. Indeed, one usually starts from a very abstract specification of the desired system which is then refined and decomposed until one arrives at a concrete specification that can directly be implemented. If properties are preserved under each refinement step then those properties which have been already investigated in some phase need not to be re-investigated in later phases.
Given an unwinding class W(∼L, −−·) and a partial function f : E k −→ E, we say that W(∼L, −−·) is compositional with respect to f if E1,... , Ek ∈ W(∼L, −−·) implies that either f (E1,... , Ek) ∈ W(∼L, −−·) or f (E1,... , Ek) is not defined (denoted by f (E1,... , Ek) ↑).
To study compositionality properties of unwinding classes we first intro- duce the following notions of preservation and reflection.
Definition 4.1 [Preservation and Reflection] Let f : E k −→ E be a partial function and ⊙ ⊆ E × E be a relation.
The function f preserves ⊙ if the following condition holds. Let I J be any partition of {1,... , k} with I /= ∅. If ∀i ∈ I (Gi ⊙ G') and ∀j ∈ J (Gj ≡ G' )
i	j
then

f (G1,... , Gk) ⊙ f (G' ,... , G' ) or (f (G1,... , Gk) ↑ and f (G' ,... , G' ) ↑)
1	k	1	k

The function f reflects ⊙ if the following condition holds. If f (G1,... , Gk) ⊙

M , then ∃ I, J , I  J = {1,... , k} and I /= ∅ such that
∀i ∈ I (Gi ⊙ G') and ∀j ∈ J (Gj ≡ G' ) and M ≡ f (G' ,... , G' )
i	j	1	k
The condition I /= ∅ in the above definition has the aim of considering also non reflexive relations, e.g. the relation →h .
Example 4.2 Let ⊙ be the weak bisimulation relation, i.e., E ⊙ F if and only if E ≈B F . It holds that the parallel composition operator preserves weak bisimulation [27]. On the other hand, the nondetermistic choice operator does not preserve weak bisimulation. In fact, 0 ≈B τ.0, but a.0 + 0 /≈B a.0 + τ.0.
Let ⊙ be the reachability relation, i.e., {(E, F ) | E ∈ E and F ∈ Reach(E)}. The parallel operator reflects ⊙. In fact, if G1|G2 reaches M , i.e., M ∈

Reach(G1|G2) then M ≡ G' |G' with both G' ∈ Rach(G1) and G'
∈ Rach(G2).

1	2	1	2
Compositionality of an unwinding class can be proved by means of the following theorem.
Theorem 4.3 (Reflection-Preservation Composition) Let f : E k −→ E

be a partial function reflecting →h
and the reachability relation and preserving

−−· and ∼L. Then W(∼L, −−·) is compositional with respect to f.
Proof. It is not restrictive to assume k = 2.
Let E, F ∈ W(∼L, −−·). We have to prove that f (E, F ) ∈ W(∼L, −−·). If f (E, F ) reaches M , then, since f reflects the reachability relation 8 , there exist G, K (one of them possibly equal to E or F , respectively) such that E

reaches G, F reaches K, and M ≡ f (G, K). If M →h
→h , three cases are possible:
M ', then, since f reflects

G →h
K →h
G' and M ' ≡ f (G', K);
K' and M ' ≡ f (G, K');

G →h
G', K →h
K', and M ' ≡ f (G', K').

In the first case G −−· G'' and G'' ∼L G'. Hence, since f preserves −−· and
∼L we have M −−· f (G'', K) and f (G'', K) ∼L f (G', K). The second and the
 third cases are similar. Hence, f (E, F ) ∈ W(∼L, −−·).	 

As we will see in the next subsection, the hypotheses of the above theo- rem are satisfied when we deal with operators whose semantics is recursively defined on subprocesses (e.g., the parallel operator |). Other operators have a

8 Note that the reachability relation is reflexive.

semantics which is a “union” of the semantics of subprocesses (e.g., the nonde- terministic choice operator). To deal with such kind of operators we introduce the notions of propagation and projection.
Definition 4.4 [Propagation and Projection] Let f : E k −→ E be a partial function and ⊙ ⊆ E × E be a relation.
The function f propagates ⊙ if the following condition holds. If ∃i such that (Gi ⊙ G'), then f (G1,... , Gk) ⊙ G' or f (G1,... , Gk) ↑.
i	i
The function f projects ⊙ if the following condition holds. If f (G1,... , Gk) ⊙
M , then ∃i such that Gi ⊙ M .
Example 4.5 Let ⊙ be the relation → and f be the nondetermistic choice
operator +. It holds that + propagates →a . In fact, if G →a G' then G +G →a
a	a	1	1	1a	2
G' . Moreover, + projects →, since if G1 + G2 → M then either G1 → M or
1 a
G2 → M .
We say that a process E positively reaches a process E' if there exists a
process E'' and an action a such that E →a E'' and E'' reaches E'.
Theorem 4.6 (Projection-Propagation Composition) Let f : E k −→ E

be a partial function projecting →h
and the positive reachability relation and

propagating −−·. Then W(∼L, −−·) is compositional with respect to f.
Proof. It is not restrictive to assume k = 2.
Let E, F ∈ W(∼L, −−·). We have to prove that f (E, F ) ∈ W(∼L, −−·). If
f (E, F ) reaches M , then, two cases are possible:
M ≡ f (E, F );
f (E, F ) positively reaches M .
In the first case we have to prove that if f (E, F ) →h M ', then f (E, F ) −−· M ''
and M '' ∼L M '. If f (E, F ) →h M ', since f projects →h , it is not restrictive to
assume that E →h M '. Since E ∈ W(∼L, −−·), by definition, E −−· M '' and
M '' ∼L M '. From the fact that f propagates −−· we get that f (E, F ) −−· M '', i.e., the thesis.
In the second case, since f projects the positive reachability relation, we can safely assume that E reaches M . Since E ∈ W(∼L, −−·) and E reaches M , we immediately get the thesis.	 

Compositionality with respect to the Algebra Operators
The following result is an immediate consequence of Theorem 4.3, since all the operators it deals with reflect → and the reachability relation.

Corollary 4.7 (Restriction, Renaming, Parallel, Definition) Consider an unwinding class of processes W(∼L, −−·).
Let v ⊆ L. If the function restv : W(∼L, −−·) −→ E deﬁned as restv(E) = E \ v preserves −−· and ∼L, then W(∼L, −−·) is compositional with respect to the v-restriction;
Let g be a renaming. If the function reng : W(∼L, −−·) −→ E deﬁned as reng(E) = E[g] preserves −−· and ∼L, then W(∼L, −−·) is compositional with respect to the g-renaming;
If the function par : W(∼L, −−·)2 −→ E deﬁned as par(E, F ) = E|F pre- serves −−· and ∼L, then W(∼L, −−·) is compositional with respect to the parallel composition |;
If the function def : W(∼L, −−·) −→ E deﬁned as def(E)= Z, with Z d=ef E, preserves −−· and ∼L, then W(∼L, −−·) is compositional with respect to the constant deﬁnition d=ef.
The following result is a consequence of Theorem 4.6, since the nondeter- ministic choice operator projects → and the positive reachability relation.
Corollary 4.8 (Non Deterministic Choice) Let W(∼L, −−·) be an unwind- ing class of processes. If the function sum : W(∼L, −−·)2 −→ E deﬁned as sum(E, F ) = E + F propagates −−·, then W(∼L, −−·) is compositional with with respect to the nondeterministic choice operator +.
Theorem 4.9 (Low Prefix) Let W(∼L, −−·) be an unwinding class of pro- cess. If l ∈ L is a low level action, then W(∼L, −−·) is compositional with respect to the low preﬁx operator which maps E into l.E.
Proof. We have to prove that if E ∈ W(∼L, −−·) and l ∈ L, then l.E ∈ W(∼L
, −−·). If l.E reaches E', then two cases are possible:
E' ≡ l.E;
E' ∈ Reach(E).
In the first case E' cannot perform any high level action, hence we have nothing to prove. In the second case by the hypothesis that E ∈ W(∼L, −−·) we
 immediately get the thesis.	 

The replication operator needs an ad-hoc theorem since it does not re-

flects →h
and the reachability relation. In fact, if !E reaches E' this does not

correspond to the fact that E reaches E'' and E' ≡!E''. In particular, if !E reaches E' we can prove that E' is of the form E1| ... |En|!E where all the Ei’s are reached by E. The following theorem allows us to exploit this form

of ‘reflection’ of the reachability relation to obtain sufficient conditions for the compositionality with respect to the replication operator.
Theorem 4.10 (Replication) Let W(∼L, −−·) be an unwinding class of pro- cesses. If it holds that
−−· is included in the reachability relation, i.e., if E −−· F then E reaches
F,
for each F ∈ W(∼L, −−·) and k ≥ 0 the function f F : W(∼L, −−·)k −→ E
deﬁned as f F (E1,... , Ek)= E1| ... |Ek|!F  preserves ∼L,
for each k ≥ 0 the function gk : E k −→ E such that gk(E1,... , Ek) =
E1| ... |Ek preserves −−·,
if F −−· F ', then !F −−· F '|!F ,
then W(∼L, −−·) is compositional with respect to the replication operator !.
Proof. First we prove the following claim.
Claim 1. If !F reaches F ', then there exist n ≥ 0 and F1,... , Fn such that F
reaches Fi, for i = 1,... ,n and F ' ≡ F1|F2| ... |Fn|!F.

Since !F reaches F ', there exists t ∈ Act ∗ such that !F →t
by induction on the length ln of t.
F '. We proceed

If ln = 0, then F ' ≡!F , hence we have the thesis with n = 0.
Let us assume that we have proved the thesis for all the ln ≤ m. Let

ln = m + 1. This means that there exists F ''
t'
such that !F → F
'', t'
has length

m, and F '' →a
F '. By inductive hypothesis there exist n ≥ 0 and F ,... ,F 

1	n
such that F reaches Fi, for i = 1,... ,n and F '' ≡ F1|F2| ... |Fn|!F. If the
action a is performed by one of the Fi’s, say F1, we have the thesis, since F
reaches F and F →a  F ' and F ' ≡ F '|F | ... |F |!F. Similarly we obtain the
1	1	1	1	2	n
thesis if a = τ is a synchronization between two of the Fi’s. If the action a
is performed by !F applying the first rule of Replication, then F → Fn+1 and F ' ≡ F1|F2| ... |Fn|Fn+1|!F. Similarly we obtain the thesis in the remaining two cases, i.e. if a is performed by !F applying the second rule of Replication or if a is a synchronization between one of the Fi’s and !F .
Now we have to prove that if F ∈ W(∼L, −−·), then !F ∈ W(∼L, −−·), i.e.,
if !F reaches F ' and F ' →h G, then F ' −−· G' with G' ∼L G.
If !F reaches F ', by Claim 1, we have that F ' is of the form F1| ... |Fn|!F .

If n = 0, then F ' ≡!F . If !F →h
G, then F →h
G'' and G ≡ G''|!F . Since

∈ W(∼L, −−·), we have that F −−· K and K ∼L G''. By hypothesis (4),
!F −−· K|!F . Moreover, by hypothesis (1), we have that K ∈ W(∼L, −−·),
hence since, by hypothesis (2), f F preserves ∼L, we get K|!F ∼L G''|!F .

If n > 0, then F ' ≡ F | ... |F |!F . If F ' →h
G, then two cases are possible:



there exists i such that F →h F ' and G ≡ F | ... |F '| ... |F
|!F ;

i	i	1	i	n

F →h
F '' and G ≡ F1| ... |Fn|F ''|!F .

In the first case, since F ∈ W(∼L, −−·) reaches Fi we have that Fi −−· K
with K ∼L F '. Since, by hypotheses (3) and (2), gn+1 preserves −−· and f F
i	n
preserves ∼L we get that F ' −−· G' ≡ F1| ... |K| ... |Fn|!F and G' ∼L G.
In the second case, since F ∈ W(∼L, −−·), F −−· K with K ∼L F ''. Hence, by hypothesis (4), we get that !F −−· K|!F . Since, by hypothesis (3), gn+1 preserves −−· we have that F ' −−· G' ≡ F1| ... |Fn|K|!F . By hypothesis (1)
we obtain K ∈ W(∼L, −−·), hence we can exploit the fact that f F	preserves
 ∼L to get G' ∼L G.	 

We are now ready to apply our general results to the security properties
P BNDC, SBNDC, CP BNDC, and PP BNDC.
Corollary 4.11 P BNDC, SBNDC, CP BNDC, PP BNDC are compositional with respect to the following operators:
the l-preﬁx operator, for each l ∈ L;
the v-restriction operator, for each v ⊆ L;
the g-renaming operator, for each renaming g;
the parallel composition |;
the constant deﬁnition d=ef;
the replication operator !.
CP BNDC, PP BNDC are compositional with respect to the nondeterministic choice operator +.
Proof. As far as the first 5 operators are concerned, the compositionality can be proved by observing that the hypothesis of Theorem 4.9 and Corollary 4.7 hold.

To prove the compositionality with respect to the replication operator we need to prove that the hypothesis of Theorem 4.10 hold.
The relations (→τ )∗, (→τ )0, (→τ )+ are included in the reachability.
We prove that the f F ’s preserve ∼L. In the case of P BNDC the fact

that each f F
preserves ≈L
can be proved by proving that

R = {(E1| ... |Ek|!F, E' | ... |E' |!F ) | Ei, E',F ∈ P BNDC and Ei ≈L  E'}
1	k	i	B	i
is a weak bisimulation on low actions (see Lemma 5 of [10]). In the case of
SBNDC and CP BNDC the thesis follows from the case of P BNDC, since

they are both included in P BNDC and they use ≈L , as P BNDC does. In the case of PP BNDC the proof can be obtained similarly by proving that
R = {(E1| ... |Ek|!F, E' | ... |E' |!F ) | Ei, E',F ∈ PP BNDC and Ei ≈L E'}
1	k	i	P	i
is a progressing bisimulation on low actions.

The fact that each gk
preserves (→τ )∗, (→τ )0, (→τ )+ is a consequence of

the semantics of the parallel operator.
Also the last hypothesis, i.e., F −−· F ' implies !F −−· F '|!F , can be easily proved for our security properties (modulo the use of structural congruence in the case of SBNDC and P BNDC ).

To prove that CP BNDC and PP BNDC are compositional with respect to the nondeterministic choice operator we can apply Corollary 4.8.

Example 4.12 Consider the parallel composition of the high and low memory cells Mh x and ML x defined in Example 3.4, i.e.,
Mh|L x d=ef Mh x|ML x.
Since both Mh 0 and ML 0 are P BNDC, by Corollary 4.11, Mh|L 0 is P BNDC
too. Similarly an unbounded number of high memory cells defined as
M !h x d=ef!M h x.
is P BNDC.
Consider now the non-deterministic composition of Mh x and ML x. In particular, consider the memory cell Mh+L x that behaves as either Mh x or ML x, i.e.,
Mh+L x d=ef Mh x + ML x.
We know that Mh x and ML x are P BNDC, however their non-deterministic composition, i.e., Mh+L x, is not. Indeed, consider the execution of a high level write action wh 0. This moves the whole Mh+L 0 system to Mh 0 (notice that ML 0 does not accept the high level input wh 0). The problem is that a low level user can observe this move by trying to write some value into the memory cell. As a matter of fact, since Mh 0 does not accept low level inputs, the low level user can deduce that some high level action has been performed. This indirect information flow can be exploited to build a so called covert-channel (see, e.g., [14] for more detail). Formally, we can prove that Mh+L 0 is neither P BNDC, SBNDC, CP BNDC nor PP BNDC by observing that the move

Mh+L 0 wh 0
h 0 cannot be simulated by M
h+L 0.

Consider now the the memory cell Nh+L x obtained as non-deterministic composition of the cells Nh x and NL x of Example 3.7, i.e.,
Nh+L x d=ef Nh x + NL x.
Since we have already showed that Nh x and NL x are both CP BNDC and PP BNDC, by compositionality results we obtain that Nh+L x is both CP BNDC and PP BNDC. Notice that the problem of simulating the move Nh+L 0 wh 0 Nh 0 is now solved by performing the τ of the added τ . Nh 0 branch in the
definition of Nh 0. In particular we have that Nh+L 0 →τ  Nh 0.

Compositionality with respect to Reﬁnement
In [8] we introduced a new notion of refinement for SPA processes. Intuitively, an abstract specification (given here as a SPA system) defines the set of pos- sible (allowed) behaviors of a system. Refining a specification corresponds to choosing among these allowed behaviors, the ones that will be actually imple- mented. The idea is that a refined specification should never show behaviors that were not foreseen in the initial specification. To formalize this idea, we require that (i) each state of the abstract specification is refined to, at most, one state of the more concrete (i.e., refined) specification; (ii) the behavior of the refined states is simulated by the abstract states, i.e., it should always be possible to simulate an action performed by a refined state by the corre- sponding abstract state, and the two reached states should be still one the refinement of the other.
Refinement is formalized as a partial function from processes.
Definition 4.13 (Refinement) A binary relation R ⊆ E × E over processes is a reﬁnement if
R−1 is a simulation and
R is a partial function from E to E.
We say that E is a reﬁnement of F , denoted by E ≤ F , if there exists a refinement R such that R(F )= E.
The following theorem has been proved in [8] but it is easy to see that it is also a consequence of Theorem 4.3. Just note that any refinement R reflects
→h and the reachability relation since, by definition, R−1 is a simulation.
Theorem 4.14 Let W(∼L, −−·) be an unwinding class of processes and R be a reﬁnement. If R preserves −−· and ∼L, then W(∼L, −−·) is compositional with respect to R.




Fig. 6. The LTS of the memory cell Ph x.
Example 4.15 Consider the processes Mh x and ML x introduced in Exam- ple 3.4. We have seen that they are both P BNDC. It is now interesting to study how this property is preserved by further refining the processes. To this aim we apply Theorem 4.14. Notice that neither Mh 0 nor ML 0 perform any τ transitions, thus the only condition that we should care about is that the refinement preserves ≈L . As a consequence, removing high level actions does not affect the security of the two systems. For example, if we allow the high level user to only reset the cell value to 0 (by removing the wh 1 . Mh 1 branch), the resulting process is still P BNDC.
On the other hand, modifications of low behavior should be performed coherently in all equivalent states. For example, the refinement
Ph 0 d=ef r 0 . Ph 0+ w 0 . Ph 0+ w 1 . Ph 1
Ph 1 d=ef r 1 . Ph 1+ w 0 . Ph 0+ w 1 . Ph 1+ w 0 . Ph 0
in which the low level user can reset to 0 the high level cell, only when the cell contains value 1 (notice that in Ph 0 no low level write operations are allowed) is not preserving ≈L . The LTS of Ph 0 is depicted in Figure 6.
It is easy to see that Ph 0 /∈ P BNDC . The fact that Ph 0 is not P BNDC reveals a slightly subtle information flow due to the fact that a low level user may track the content of the high level cell by trying to reset it: every time the reset succeeds the low level user can conclude that the cell contains value
1. A correct refinement achieving the same low level reset behavior described above, should include the branch wL 0 . Ph 0 also in Ph 0.
Proof Systems for Unwinding classes
Unwinding conditions are also useful for giving efficient proof techniques. In- deed, we used them to define proof systems which allow us to statically prove that a process is secure, i.e., by just inspecting its syntax [7,10]. These sys- tems offer a means to build processes which are secure by construction, in an incremental way. They extend the one given in [24] for finite processes, i.e.,

processes that may only perform finite sequences of actions. In particular, we are able to deal also with recursive processes which may perform unbounded sequences of actions. Here we provide a general scheme for the construction of correct proof rules for unwinding classes of processes which generalize the proof rules proposed in [7,10].
Theorem 4.16 Let W(∼L, −−·) be an unwinding class of processes. Let Sys
be a proof system whose rules are of the following form
E1,... , Ek ∈ W(∼L, −−·)

f (E1,... , Ek) ∈ W(∼L, −−·)
where W(∼L, −−·) is compositional with respect to f, or the rule
E ∈ EL

E ∈ W(∼L, −−·)
Then Sys is correct, i.e., if there exists a derivation of E ∈ W(∼L, −−·) in
Sys, then E ∈ W(∼L, −−·).
By Theorem 4.16 and Corollary 4.11 we get for instance the following rule
E1, E2 ∈ P BNDC

E1|E2 ∈ P BNDC
However, by considering the proof system obtained exploiting only to the operators in Corollary 4.11 we can only prove that the processes in EL are P BNDC , SBNDC, CP BNDC , PP BNDC . In fact, we have no way to in- troduce high level actions. In the case of P BNDC we have that P BNDC is compositional with respect to the functions of the form f : E p+q −→ E defined
as
f (F1,... , Fp, G1,... , Gq)= Σ li.Fi + Σ (hj.Gj + τ.Gj)
1≤i≤p	1≤j≤q
where li ∈ L for all i = 1,... ,p and hj ∈ H for all j = 1,... ,q (see also Theorem 5.2). Hence we can add to the proof system the rules of the form
F1,... , Fk, G1,... , Gh ∈ P BNDC
Σ1≤i≤p li.Fi + Σ1≤j≤q (hj.Gj + τ.Gj) ∈ P BNDC
which allows use to build secure processes not in EL. These rules can be used also in the cases of CP BNDC and PP BNDC, while in the case of SBNDC

we can prove the correctness of the rule
E ∈ SBNDC
E + h.E ∈ SBNDC

How to Rectify Insecure Processes
In [6] we propose a general method for rectifying non P BNDC processes. The idea is to automatically transform a process E into a P BNDC process Eτ and to identify a large class of processes for which the transformation preserves the low level observational semantics, i.e., for the low level user E and Eτ are not distinguishable. This transformation can be used to construct “secure” processes from a first possibly “insecure” definition. Here we generalize the transformation presented in [6] to deal with any unwinding class of processes and sequences s of actions. Given a process E and a sequence of actions s = s1 ... sn ∈ Act +, we denote by s.E the process s1	sn.E.
Definition 5.1 [Es] Let W(∼L, −−·) be an unwinding class of processes com- positional with respect to the v-restriction, for each v ⊆ L∗, the g-renaming, for each renaming g, the parallel composition operator |, the constant defini- tion d=ef, the replication operator !. Given a guarded process E and s ∈ Act + with n > 0 we inductively define Es as follows:
0s = 0	(E \ v)s = Es \ v	(E[g])s = Es[g]

(E |E )s = Es|Es
Zs d=ef Fs	!Es =!(Es)

1	2	1	2
(Σ li.Fi + Σ hj.Gj)s = Σ li.F s + Σ (hj.Gs + s.Gs)
where l ∈ L ∪ {τ }, h ∈ H, and Z was associated to Z d=ef F .
Theorem 5.2 (Rectifications) Let W(∼L, −−·) be an unwinding class of pro- cesses compositional with respect to the v-restriction, for each v ⊆ L∗, the g-renaming, for each renaming g, the parallel composition operator |, the con- stant deﬁnition d=ef , the replication operator !. Let E ∈ E be a guarded process.
If s ∈ Act + is a sequence of actions and such that E →s F implies E−−·F, then
Es ∈ W(∼L, −−·).
Proof. By induction on E. If E ≡ 0, then Es ≡ 0 ∈ W(∼L, −−·).
If E ≡ E1 \v, then by inductive hypothesis on E1, Es ∈ W(∼L, −−·), hence, since W(∼L, −−·) is compositional with respect to the v-restriction, we get the thesis. The cases of renaming, parallel composition, constant definition, and replication are similar.

If E ≡ ΣL ∈L∪{τ } li.Fi + Σh ∈H hj.Gj and Es reaches E' two cases are
i	j
possible:
E' is Es;
one of the Fs, Gs’s reaches E'.
i	j
In the first case if Es →h E'' we have that there exists j such that E'' ≡ G .
j
Hence, Es −−· Gj and Gj ∼L Gj, since ∼L is an equivalence relation.
 In the second case the thesis follows by inductive hypothesis on the Fs, Gs’s. 

Corollary 5.3 Let E ∈ E be a guarded process.
Eτ ∈ P BNDC , CP BNDC , PP BNDC .
Example 5.4 The memory cell M x presented in Example 3.2 was not secure. We transformed it into two memory cells, a high level one and a low level one. Since the low level user cannot read from the high memory cell and the high level user cannot write on the low memory cell we obtain that the two memory cell are secure. Imagine now that we want to model the low level memory cell in such a way that each value can be read at most once. At the beginning the cell QL e is empty, when a low level user writes a value x the cell is moved in the state QL x in which it remains until either a high or a low level user read the value. After a reading the cell is reset in the state QL e.
QL e d=ef wL x . QL x
QL x d=ef rL x . QL e + rh x . QL e
In particular, with this implementation each value is read exactly once. How- ever, QL e is not P BNDC. In fact, if any user reads the value the low level user cannot write a new value, i.e., the system is blocked. Applying to QL e our rectification we get
QL eτ d=ef wL x . QL xτ
QL xτ d=ef rL x . QL eτ + rh x . QL eτ + τ.QL eτ
In this case the rectification corresponds to the modelling of a timeout: if the value is not read within a certain amount of time, the system reset the cell. Now each value is read at most once.
The LTS’s of QL eτ is depicted in Figure 7.
The above theorem does not requires the compositionality with respect to the non-deterministic choice operator. As a consequence the correction can be applied only to guarded processes. In the case we deal with a fully compositional unwinding class we can extend the correction to non guarded




Fig. 7. The LTS of the memory cell Ql eτ .

processes.
Definition 5.5 [Es] Let W(∼L, −−·) be an unwinding class of processes com- positional with respect to the v-restriction, for each v ⊆ L∗, the g-renaming, for each renaming g, the parallel composition operator |, the constant defini- tion d=ef, the replication operator ! and the nondeterministic choice operator
+. Given a process E and s ∈ Act + we inductively define Es as follows:
0s = 0	(l.E)s = l.Es	(h.E)s = h.Es + s.Es
(E \ v)s = Es \ v	(E[g])s = Es[g]	(E1|E2)s = (E1)s|(E2)s
Z d=ef F	!E =!(E )	(E + E ) = (E ) + (E )
where l ∈ L ∪ {τ }, h ∈ H, and Z was associated to Z d=ef F .
Theorem 5.6 (Rectifications) Let W(∼L, −−·) be an unwinding class of pro- cesses compositional with respect to the v-restriction, for each v ⊆ L∗, the g-renaming, for each renaming g, the parallel composition operator |, the con- stant deﬁnition d=ef, the replication operator !, and the nondeterministic choice operator +. Let E ∈ E be a process. If s ∈ Act + is a sequence of actions and
such that E →s F implies E−−·F, then
Es ∈ W(∼L, −−·).

Proof. The result can be proved by induction on E exploiting the fact that all the unwinding classes are compositional with respect to the low prefix o perator.	 

Corollary 5.7 Let E ∈ E be a process.
Eτ ∈ CP BNDC, PP BNDC .

Conclusions
In this paper we consider information flow security properties of SPA pro- cesses expressed in terms of unwinding conditions. The aim of the present work is to bridge the gap between unwinding conditions and composition- ality results. This is done by exploiting a generalized unwinding condition W(∼L, −−·), parametric with respect to a low level behavioral equivalence ∼L and a transition relation −−·. To prove the compositionality of a class of secure processes, expressed as an instance of W(∼L, −−·), with respect to an operator f we need to establish connections between the semantics of f and the relations ∼L and −−·. By instantiating f as one of the algebra operators we rediscover already proved compositionality results (e.g., the compositionality of P BNDC with respect to the parallel operator). Moreover, by instantiat- ing f as a reﬁnement operator, which solves the non-deterministic choices, we obtain results concerning the preservation of the security properties un- der refinement. Unwinding conditions can be also exploited for defining proof systems which provide efficient techniques for the verification and the develop- ment of secure processes. Proof systems allow us to verify whether a process is secure just by inspecting its syntax, and thus avoiding the state-explosion problem. Moreover, they also allow us to build processes which are secure by construction in an incremental way. Finally compositionality of unwinding conditions can be easily exploited to rectify insecure processes.

References
Mart´ın Abadi. Secrecy by typing in security protocols. Journal of the ACM, 46(5):749–786, 1999.
A. Aldini, M. Bravetti, and R. Gorrieri. A Process-algebraic Approach for the Analysis of Probabilistic Non-interference. Journal of Computer Security, 2004. To appear.
D. E. Bell and L. J. La Padula. Secure computer systems: Unified exposition and multics interpretation. Technical Report ESD-TR-75-306, MITRE MTR-2997, 1975.
V. Benzaken, M. Burelle, and G. Castagna. Information flow security for xml transformations. In Proc. of Asian Computing Science Conference (ASIAN’03), LNCS. Springer-Verlag, 2003. To appear.
C. Bodei, P. Degano, F. Nielson, and H. Riis Nielson. Static analysis for secrecy and non- interference in networks of processes. In Victor E. Malyshkin, editor, Proc. of International Conference on Parallel Computing Technologies, volume 2127 of Lecture Notes in Computer Science, pages 27–41. Springer-Verlag, 2001.
A. Bossi, R. Focardi, C. Piazza, and S. Rossi. Transforming Processes to Ensure and Check Information Flow Security. In H. Kirchner and C. Ringeissen, editors, Int. Conference on Algebraic Methodology and Software Technology (AMAST’02), volume 2422 of LNCS, pages 271–286. Springer-Verlag, 2002.
A. Bossi, R. Focardi, C. Piazza, and S. Rossi. A Proof System for Information Flow Security. In M. Leuschel, editor, Logic Based Program Development and Transformation, volume 2664 of LNCS, pages 199–218. Springer-Verlag, 2003.


A. Bossi, R. Focardi, C. Piazza, and S. Rossi. Refinement Operators and Information Flow Security. In Proc. of the 1st IEEE Int. Conference on Software Engineering and Formal Methods (SEFM’03), pages 44–53. IEEE Computer Society Press, 2003.
A. Bossi, R. Focardi, C. Piazza, and S. Rossi.  Verifying Persistent Security Properties. Computer Languages, Systems and Structures, 2003. To appear. Available at http://www.dsi.unive.it/∼srossi/cl03.ps.gz.
A. Bossi, D. Macedonio, C. Piazza, and S. Rossi. Information Flow Security and Recursive Systems. In Proc. of the Italian Conference on Theoretical Computer Science (ICTCS’03), volume 2841 of LNCS, pages 369–382. Springer-Verlag, 2003.
M. Bugliesi, S. Crafa, M. Merro, and V. Sassone. Communication Interference in Mobile Boxed Ambients. In M. Agrawal and A. Seth, editors, Proc. of Int. Conference on Foundations of Software Technology and Theoretical Computer Science (FSTTCS’02), volume 2556 of LNCS, pages 71–84. Springer-Verlag, 2002.
A. Di Pierro, C. Hankin, and H.Wiklicky. Approximate Non-Interference. In Proc. of the IEEE Computer Security Foundations Workshop (CSFW’02), pages 3–17. IEEE Computer Society Press, 2002.
R. Focardi and R. Gorrieri. A Classification of Security Properties for Process Algebras.
Journal of Computer Security, 3(1):5–33, 1994/1995.
R. Focardi and R. Gorrieri. Classification of Security Properties (Part I: Information Flow). In R. Focardi and R. Gorrieri, editors, Proc. of Foundations of Security Analysis and Design (FOSAD’01), volume 2171 of LNCS, pages 331–396. Springer-Verlag, 2001.
R. Focardi, R. Gorrieri, and F. Martinelli. Information flow analysis in a discrete-time process algebra. In Proc. of the IEEE Computer Security Foundations Workshop (CSFW’00), pages 170–184. IEEE Computer Society Press, 2000.
R. Focardi, R. Gorrieri, and F. Martinelli. Non Interference for the Analysis of Cryptographic Protocols. In U. Montanari, J. D. P. Rolim, and E. Welzl, editors, Proc. of Int. Colloquium on Automata, Languages and Programming (ICALP’00), volume 1853 of LNCS, pages 744–755. Springer-Verlag, 2000.
R. Focardi and S. Rossi. Information Flow Security in Dynamic Contexts. In Proc. of the IEEE Computer Security Foundations Workshop (CSFW’02), pages 307–319. IEEE Computer Society Press, 2002.
R. Forster. Non-Interference Properties for Nondeterministic Processes. PhD thesis, Oxford University Computing Laboratory, 1999.
J. A. Goguen and J. Meseguer. Security Policies and Security Models. In Proc. of the IEEE Symposium on Security and Privacy (SSP’82), pages 11–20. IEEE Computer Society Press, 1982.
J. A. Goguen and J. Meseguer. Unwinding and Inference Control. In Proc. of the IEEE Symposium on Security and Privacy (SSP’84), pages 75–86. IEEE Computer Society Press, 1984.
R. Gorrieri, E. Locatelli, and F. Martinelli. A simple language for real-time cryptographic protocol analysis. In P. Degano, editor, Proc. of European Symposium on Programming (ESOP’03), volume 2618 of LNCS, pages 114–128. Springer-Verlag, 2003.
M. Hennessy and J. Riely. Information Flow vs. Resource Access in the Asynchronous Pi- calculus. ACM Transactions on Programming Languages and Systems (TOPLAS), 24(5):566– 591, 2002.
H. Mantel. Unwinding Possibilistic Security Properties. In Proc. of the European Symposium on Research in Computer Security (ESoRiCS’00), volume 2895 of LNCS, pages 238–254. Springer-Verlag, 2000.
F. Martinelli. Partial Model Checking and Theorem Proving for Ensuring Security Properties. In Proc. of the IEEE Computer Security Foundations Workshop (CSFW’98), pages 44–52. IEEE Computer Society Press, 1998.


J. McLean. Security Models and Information Flow. In Proc. of the IEEE Symposium on Security and Privacy (SSP’90), pages 180–187. IEEE Computer Society Press, 1990.
J. McLean. Security Models. Encyclopedia of Software Engineering, 1994.
R. Milner. Communication and Concurrency. Prentice-Hall, 1989.
U. Montanari and V. Sassone. CCS Dynamic Bisimulation is Progressing. In Proc. of the Int. Symposium on Mathematical Foundations of Computer Science (MFCS’91), volume 520 of LNCS, pages 346–356. Springer-Verlag, 1991.
A. W. Roscoe and M. H. Goldsmith. What is intransitive noninterference? In Proc. of the IEEE Computer Security Foundations Workshop (CSFW’99), pages 228–238. IEEE Computer Society Press, 1999.
A. W. Roscoe, J. C. P. Woodcock, and L. Wulf. Non-Interference through Determinism.
Journal of Computer Security, 4(1), 1996.
P. Y. A. Ryan. A CSP Formulation of Non-Interference and Unwinding. Cipher, pages 19–27, 1991.
P.Y.A. Ryan and S. Schneider. Process Algebra and Non-Interference. Journal of Computer Security, 9(1/2):75–103, 2001.
A. Sabelfeld and A. C. Myers. Language-Based Information-Flow Security. IEEE Journal on Selected Areas in Communication, 21(1):5–19, 2003.
A. Sabelfeld and D. Sands. Probabilistic Noninterference for Multi-threaded Programs. In Proc. of the IEEE Computer Security Foundations Workshop (CSFW’00), pages 200–215. IEEE Computer Society Press, 2000.
G. Smith and D. M. Volpano. Secure Information Flow in a Multi-threaded Imperative Language. In Proc. of ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL’98), pages 355–364. ACM Press, 1998.
D. Sutherland. A Model of Information. In Proc. of the 9th National Computer Security Conference, pages 175–183, 1986.
J. T. Wittbold and D. M. Johnson. “Information Flow in Nondeterministic Systems”. In
Proceedings of the 1990 IEEE Symposium on Research in Security and Privacy, pages 144–
161. IEEE Computer Society Press, 1990.
