

Electronic Notes in Theoretical Computer Science 253 (2009) 31–46
www.elsevier.com/locate/entcs

An Ahead-of-time Yet Context-Sensitive Points-to Analysis for Java
Xin Li1 ,2	Mizuhito Ogawa3
School of Information Science
Japan Advanced Institute of Science and Technology Nomi, Japan

Abstract
Points-to analysis is a prerequisite of program verification and static analysis on Java programs. It is known that call graph is typically constructed on-the-fly when points-to analysis proceeds for a better precision. In this work, we propose an ahead-of-time yet context-sensitive points-to analysis for Java as all-in-one weighted pushdown model checking. The analysis is context-sensitive in the sense that, (i) method calls and returns match with each other (a.k.a., valid paths); and (ii) targets of dynamic dispatch are analyzed separately for different calling contexts (a.k.a., context-sensitive call graph). The insight of our approach is that, by encoding dataflow as weights, invalid control flows that violate Java semantics on dynamic dispatch are detected as those carrying conflicted dataflow. Our analysis is presented as field-sensitive and flow-sensitive. Flow-insensitivity is shown to be easily obtained as a hierarchy considering efficiency and
concurrent behaviors. Due to the lack of control flow structure and the explicit stack-based design, program analysis on bytecode is not an easy matter. We implemented the analysis in the framework of Soot compiler, and utilized the Weighted PDS Library as the back-end analysis engine. The analysis works on Jimple, a typed three-address intermediate representation of bytecode supported by Soot. The results of the analysis can be encoded into the class file as attributes for the further analysis or verification on bytecode.
Keywords: Points-to Analysis, Weighted Pushdown Model Checking, Java


Introduction
Points-to analysis [3] for Java is to detect the set of heap objects, i.e., instances of classes or arrays, possibly referred to by reference variables at run-time. Many ap- plications such as program understanding, program verification, and static analysis depend on points-to analysis to reason the underlying control/data flow of Java pro- grams. Due to dynamic object-oriented features like dynamic dispatch 4 , points-to

1 We would like to thank anonymous reviewers for their valuable and thorough comments. This research is supported by the 21st Century COE program ”Verifiable and Evolvable e-Society” of JAIST, funded by the Japanese Ministry of Education, Culture, Sports, Science and Technology.
2 Email: li-xin@jaist.ac.jp
3 Email: mizuhito@jaist.ac.jp
4 In this paper, we limit our focus to single dynamic dispatch only. Multiple dynamic dispatch, e.g., reflection in Java, demands non-trivial extension and thus independent discussion.

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.11.013

analysis is mutually dependent to call graph construction. Thus we have choices of constructing call graph either on-the-fly as the points-to sets of call site receivers are computed, or ahead-of-time based on syntactical information of the program such as CHA [21] and RTA (Rapid Type Analysis) [22]. The former essentially enjoys a higher precision and is the choice of most of points-to analysis algorithms.
This paper presents an ahead-of-time yet context-sensitive points-to analysis for Java as all-in-one WPDMC (weighted pushdown model checking). Though it is well understood that program analysis can be regarded as model checking of abstract interpretation [1], model checking based approach to a context-sensitive points- to analysis is not straightforward. We limit our focus to providing the following context-sensitivities in the analysis, such that (i) method calls and returns match with each other (a.k.a., valid paths), which is guaranteed by encoding the program as a pushdown system; and (ii) targets of dynamic dispatch are analyzed separately for different calling contexts (a.k.a., context-sensitive call graph). Our approach to (ii) is, by further encoding dataflow as weights, invalid control flows that violates Java semantics on dynamic dispatch are detected as those carrying conflicted dataflow. These context-sensitivities are recently shown to be crucial to a precise points-to analysis in practice [5,18], as illustrated by Example 1.1. Our analysis is also flow- sensitive and field-sensitive. Concerning efficiency and concurrent behaviors of Java programs, points-to analysis is typically designed as flow-insensitive. One smart idea is combining SSA (Static Single Assignment) and complete flow insensitivity [7]. We briefly discussed how to easily obtain flow-insensitivity as a hierarchy.
Example 1.1 We denote by ol an abstract heap object that is allocated at the program line l, and by '→the mapping relation afterwards. An analysis will pre- cisely compute {c '→o3,d '→o5} if it obeys to valid paths, and will furthermore erroneously infer {c '→o5,d '→o3} otherwise. An analysis will precisely compute
{o3.f '→o15, o5.f '→o20} if a context-sensitive call graph is constructed, and will furthermore erroneously infer {o3.f '→o20, o5.f '→o15} otherwise.

public class Main {	12. public class A {
public static void main(String[] args) {	13.	Object f;
}	18. public class B extends A {
public static A foo(A x) {	19.	public void set() {
Due to the lack of control flow structure and explicit operand stack-based design, static analysis on bytecode is not an easy matter. We thus design and implement the analysis as a sub-phase of the compilation procedure in the Soot framework. Soot is an open-source compilation/optimization framework for Java, which has been originally designed to simplify the process of developing new optimizations for Java bytecode and supports three kinds of intermediate representations of bytecode.




Fig. 1. Points-to Analysis on Jimple in the Soot Framework
As shown in Figure 1, the Java source code (bytecode) is firstly compiled into the Jimple [25] code, which is a typed three-address intermediate representation. Our analysis PTA is then performed on the Jimple code, and the analysis results can be encoded into the class file as attributes for any kind of later use. It can be useful for other occasions to perform complicated static analysis on an intermediate language like Jimple and annotate the class file with analysis results.
The remainder of the paper is organized as follows: Section 2 briefly introduces weighted pushdown model checking. Section 3 formalizes our abstraction and mod- elling on heap operations. Section 4 presents our ahead-of-time points-to analysis as all-in-one weighted pushdown model checking. The skeleton of holding soundness property is given, and the prototype implementation is shown. Section 5 compares related work and Section 6 concludes this paper with a discussion on future work.

Background
Weighted Pushdown Model Checking
Definition 2.1 A pushdown system P = (Q, Γ, Δ, q0, w0) is a pushdown au- tomaton regardless of input, where Q is a finite set of states called control loca- tions, and Γ is a finite set of stack alphabet, and Δ ⊆ Q × Γ × Q × Γ∗ is a finite set of transition rules, and q0 ∈ Q and w0 ∈ Γ∗ are the initial control location and stack contents respectively. We denote the transition rule ((q1, w1), (q2, w2)) ∈ Δ by ⟨q1, w1⟩ ‹→ ⟨q2, w2⟩. A configuration of P is a pair ⟨q, w⟩, where q ∈ Q and w ∈ Γ∗. Δ defines the transition relation ⇒ between pushdown configurations such that if ⟨p, γ⟩ ‹→ ⟨q, ω⟩, then ⟨p, γω'⟩⇒ ⟨q, ωω'⟩, for all ω' ∈ Γ∗.
A pushdown system is a finite transition system carrying an unbounded stack. A weighted pushdown system extends a pushdown system by associating a weight to each transition rule. The weights come from a bounded idempotent semiring.
Definition 2.2 A bounded idempotent semiring S = (D, ⊕, ⊗, 0, 1) consists of a set D (0, 1 ∈ D) and two binary operations ⊕ and ⊗ on D such that
(D, ⊕) is a commutative monoid with 0 as the unit element, and ⊕ is idempo- tent, i.e., a ⊕ a = a for a ∈ D;
(D, ⊗) is a monoid with 1 as the unit element;

⊗ distributes over ⊕, i.e., ∀a, b, c ∈ D, a ⊗ (b ⊕ c) = (a ⊗ b) ⊕ (a ⊗ c) and (a ⊕ b) ⊗ c = (a ⊗ c) ⊕ (b ⊗ c);
∀a ∈ D, a ⊗ 0=0 ⊗ a = 0;
The partial ordering ± is defined on D such that ∀a, b ∈ D, a ± b iff a ⊕ b = a, and there are no infinite descending chains on D wrt ±.
Remark 2.3 As stated in Section 4.4 in [8], the distributivity of ⊕ can be loosened to a ⊗ (b ⊕ c) ± (a ⊗ b) ⊕ (a ⊗ c) and (a ⊕ b) ⊗ c ± (a ⊗ c) ⊕ (b ⊗ c). The associativity of ⊗ can be loosened too, as long as both (a ⊗ b) ⊗ c and a ⊗ (b ⊗ c) conservatively approximates the program execution when applied to program analysis.
Definition 2.4 A weighted pushdown system is a triple W = (P, S, f), where P = (Q, Γ, Δ, q0, w0) is a pushdown system, S = (D, ⊕, ⊗, 0, 1) is a bounded idem- potent semiring, and f : Δ → D is a function that assigns a value from D to each rule of P.
Definition 2.5 Consider a weighted pushdown system W = (P, S, f), where P = (Q, Γ, Δ, q0, w0) is a pushdown system, and S = (D, ⊕, ⊗, 0, 1) is a bounded idem- potent semiring. Assume σ = [r0, ..., rk] to be a sequence of pushdown transition rules, where ri ∈ Δ(0 ≤ i ≤ k), and v(σ) = f (r0) ⊗ ... ⊗ f (rk). Let path(c,c') be the set of all rule sequences that transform configurations from c into c'. The generalized pushdown reachability problem(GPR) is to find
δ(c, C)=   {v(σ)|σ ∈ path(c, c'), c' ∈ C}
for c ∈ Q × Γ∗ and a set C(⊆ Q × Γ∗) of regular configurations.
The GPR can be easily extended to answer the classic “meet-over-all-valid- paths” problem in program analysis. Efficient algorithms for solving GPR are de- veloped based on the property that the regular set of pushdown configurations is closed under forward and backward reachability [8]. There are two off-the-shelf implementations of weighted pushdown model checking algorithms, Weighted PDS Library 5 , and WPDS+ 6 . We apply the former as the back-end analysis engine in the prototype implementation.
Program Analysis as WPDMC
When designing a program analysis as WPDMC, the intuition behind ⊗ and ⊕ is:
A weight function models a transfer function which typically represents the data flow changes for one-step program execution;
f ⊕ g represents the merging of data flow at the meet of two control flows;
f ⊗ g represents the sequential composition of abstract state transformers;
1 implies that an execution step does not change the program state; and

5 http://www.fmi.uni-stuttgart.de/szs/tools/wpds/
6 http://www.cs.wisc.edu/wpis/wpds++/

Table 1
Syntactical Notations for References

0 implies that the program execution is interrupted by an error.
Recall the usual encoding of programs as finite model checking, program states, i.e., the product of global variables, local variables and program execution points, are encoded as states of finite automata. For pushdown model checking, the push- down stack can simulate the runtime stack of program execution. For instance, the pushdown stack can be encoded to store calling contexts for procedure calls, just like the program execution on stack machine. In this paper, we will follow the convention defined in Definition 2.6.
Definition 2.6 Define an interprocedural control flow graph G = (N, E, n0), where N = Ni ∪ Nc ∪ Ne is the set of nodes, with Ni, Nc, Ne as the sets of internal nodes, call sites, and method exits, respectively. E = Ei ∪ Ec ∪ Ee is the set of edges with Ei ⊆ Ni × N, Ec ⊆ Nc × Ni, Ee ⊆ Ne × Ni, where Ei, Ec, and Ee are the sets of internal edges, call edges, and return edges, respectively. n0 ∈ N is the unique entry node of G. We denote by Nr ⊆ Ni the set of return points of method calls. Let assign : Nc → Nr be the function that associates with each call site from Nc with a distinguished return point in Nr, Nr = {nr | nr = assign(nc), nc ∈ Nc}.
Definition 2.7 The encoding of an interprocedural control flow graph G = (N, E, n0) as a pushdown system P = (Q, Γ, Δ, q0, w0) is defined as follows
Q is a singleton set denoted by {·};
Γ= N with w0 = n0;
Δ is constructed as follows,
⟨·, ni⟩ ‹→ ⟨·, n' ⟩	if (ni, n') ∈ Ei
i	i
⟨·, ni⟩ ‹→ ⟨·, ncnr⟩	if (ni, nc) ∈ Ec, and nr = assign(nc) ∈ Nr
⟨·, ne⟩ ‹→ ⟨·, ϵ⟩	if (ne, ni) ∈ Ee

Modelling and Abstraction
Semantics of Heap Operations
Definition 3.1 Define O be the set of heap objects in the concrete domain, where To ∈ O is the greatest element and represents any objects; ⊥o ∈ O is the least element and represents no objects (i.e., null reference). Elements in O except To and ⊥o are incomparable.
We take Jimple, a three-address intermediate representation of Java, as our

target language, since it is syntactically much simpler than either Java or Bytecode. Table 1 prepares notations for, (i) the set of references Vref that is syntactically allowed in Jimple; and (ii) the set of references Vdiref in the semantic domain of heap environments (Definition 3.2). Static fields are treated in the same way with local variables, since they can be syntactically identified as well and we limit our focus to single-thread Java programs in the presentation.
Definition 3.2 A heap environment henv is a mapping from Vdiref to O. The set of heap environments is denoted by Henvcon. The evaluation function evalcon : Henvcon → Vref →O on reference variables is defined as:
evalcon(henv, v) = henv(v) evalcon(henv, v[i]) = henv(henv(v)[i]) evalcon(henv, v.f )= henv(henv(v).f )
Let hinit be the initial heap environment such that, for each r  ∈ Vdiref ,
evalcon(hinit, r)= ⊥o (null reference).
Let Loc be the set of program locations. Since we only consider single thread Java program here, the next program location at each execution step is uniquely determined. We informally refer it as next(l) for l ∈ Loc. Later it will be discussed how to leverage the analysis to a flow-insensitive counterpart regarding concurrency.
Definition 3.3 Define an transition system OS = (States, sinit, →) to represent the Java semantics on heap, where
States ⊆ (Loc × Henvcon) is a set of pairs of a program location and a heap environment,
sinit is the initial state, which is a pair of the program entry l0 and hinit;
→	⊆ States × States is the set of operational semantic rules, and →∗ denotes the transitive closure of →.
A transition rule ⟨l, henv⟩ → ⟨next(l),τ (henv)⟩ for typical pointer assignment statements at l ∈ Loc is shown in Table 2, where
the function ν(henv, T) generates a fresh heap object of type T in O; and
for r, r' ∈ Vdiref , o ∈ O,

(henv ⊙ [r '→o])r' =
o	if r = r'
henv(r)	otherwise


Definition 3.4 The composition of heap environment transformers is de- fined by the standard η-expansion, such that, for exph1, exph2 ∈ ExpHenv,
(λhenv. exph2) ◦ (λhenv. exph1) =η λh. (λhenv. exph2)(λhenv. exph1)h
=β λh. exph2[henv := exph1[henv := h]]
The notation E[h := E'] means the expression E with E' substituted for free oc- currences of h.

Table 2
Heap Environment Transformer

Definition 3.5 Let ł be the set of method identifiers, and let 7 be the set of ref- erence types. Let any = type(To) and none = type(⊥o). For t, t' ∈7 \{any, none} and m ∈ ł, t' conflicts with t with respect to the method m if and only if, (i) t' /= t and t' does not inherit t, or (ii) t' inherits t with redefining m. Otherwise, we say t' is compatible with t with respect to the method m. Furthermore, t is compatible with any, for each t in 7 and vice versa; none conflicts with t, for each t in 7 and vice versa.
Abstraction
There are varieties of infinities to be abstracted away for a tractable analysis, such as the nesting of array structures, method invocations, field reference, and the number of allocated heap objects. We take the following abstractions in the analysis,
An unique abstract heap object models objects allocated at each heap alloca- tion site, and is identified by its type and program line number (Definition 3.6). Therefore, the number of abstract heap objects are syntactically bounded;
The indices of arrays are ignored, such that members of an array are not distin- guished. We denote by [v ] the representative for array references v[i]. References with nested [ ] refer to multi-array access. We denote {[[o]] | o ∈ Obj} by [Obj]].
Note that, after abstracting heap objects to be a finite set, the nesting of either field references or array references are correspondingly finite yet unbounded. Since local variables have a unique counterpart representation in the analysis, we will reuse notations in Table 1 afterwards when it is clear from the context.
Definition 3.6 Define abstract heap objects Obj = {[t, l| | t ∈ 7 ,l ∈ Loc}∪ 
{Tobj, ⊥obj}, where Tobj is the greatest element and ⊥obj is the least element. Other elements in Obj except Tobj and ⊥obj are incomparable.
Definition 3.7 An abstract heap environment henv is a mapping from Vdiref
to У(Obj), where У is the powerset operator. The set of abstract heap environ-

Table 3
Abstract Heap Environment Transformer ExpFun

ments is denoted by Henvabs. The evaluation function evalabs : Henvabs → Vref → У(Obj) on reference variables in the abstract domain is defined as:
evalabs(henv, v)= henv(v)
evalabs(henv, [[v]]) = {henv([[o]]) | o ∈ evalabs(henv, v)}
evalabs(henv, v.f )= {henv(o.f ) | o ∈ evalabs(henv, v)}
Let hinit be the abstract initial heap environment such that evalabs(hinit, r)= ⊥obj for each r ∈ Vref .
Abstract heap environment transformers for typical pointer assignment state- ments are shown in Table 3, where [t, l| ∈ Obj, and for r, r' ∈ Vdiref , o ∈ Obj



(henv • [r '→o])r' =
henv(r') ∪ {o}	if r = r' ∈ [[Obj]]
⎪⎩henv(r')	otherwise

Points-to Analysis as WPDMC
The Design of Weight Space
By encoding the program as a pushdown system, we are provided with context- sensitivity regarding valid pathes. To construct a context-sensitive call graph during the analysis, we enrich the notion of valid paths, such that valid paths that violate type requirements of dynamic dispatch are also regraded as invalid. By encoding dataflow as weights, an invalid control flow is detected as that carrying conflicted dataflow, and combining weights along the control flow will result in the weight 0.
Definition 4.1 Define abstract heap environment transformers ExpFun as,

For this purpose, the basic weight functions, i.e., the abstract heap environment transformers (Definition 4.1), are extended by pairing path constraints (Definition 4.2). We denote by (s, t ↑ m) a path constraint (s, t, m) ∈ PathCons, which intends

Table 4
Abstract Heap Environment Transformer with Path Constraints




that the dynamic dispatch of a call edge demands the runtime type of the heap object pointed to by s to be compatible with the type t w.r.t. the method m. This judgement on types should exactly obey to (such as Definition 3.5) or soundly approximates the Java semantics for dynamic dispatch.
Definition 4.2 Define a set of path constraints PathCons ⊆V× 7 × ł, where
V ::= v | V.f | [[V ] is the set of references that syntactically allows nested field references and array structures.
The evaluation function evalabs is extended as evalabs : Henvabs → V ∪ Obj → У(Obj), such that for henv ∈ Henvabs, o ∈ Obj
evalabs(henv, o)= {o}	evalabs(henv, v)= henv(v) evalabs(henv, V.f )= {henv(o.f ) | o ∈ evalabs(henv, V)} evalabs(henv, [[V]]) = {henv([[o]]) | o ∈ evalabs(henv, V)}
Definition 4.3 Define Ref: ExpFun → V → У(Expt) such that for τ = λhenv. ExpHenv • [vf '→vt] and τ ' = λhenv. ExpHenv ∈ ExpFun,

Ref(τ ', v)	otherwise
Ref(τ, V.f )= {Ref(τ, vt'.f ) | vt' ∈ Ref(τ, V)}
Ref(τ, [[V]]) = {Ref(τ, [[vt']]) | vt' ∈ Ref(τ, V)}
Table 4 shows the abstraction of virtual method invocations. The heap envi- ronment transformer for the virtual call edge is paired with a singleton set, which specifies the expected runtime type t for the call site receiver to follow this call path. Transformers for other program statements are paired with an empty set ∅ initially.
Definition 4.4 Define Ref−1 : У(Expt) → У(V ∪ Obj) such that Ref−1(V) =
vt∈V Ref−1({vt}) for V ⊆ Expt, where
Ref−1({[t, l|})= {[t, l|}
Ref−1({henv(v)})= {v}
Ref−1({henv(Expt.f )})= {Ref−1({Expt}).f }
Ref−1({henv([[Expt]])})= {[[Ref−1({Expt})]]}

Definition 4.5 Define trace : ExpFun → V → У(V ∪ Obj) such that trace =
Ref−1 ◦ Ref.
Example 4.6 Let τ = λhenv.henv • [x '→henv(y)] • [henv(z).f '→o]. Then
trace(τ, x.f )= y.f , trace(τ, z.f )= o, and trace(τ, y)= y.
Definition 4.7 Let c ⊆ PathCons and τ ∈ Expfun. For (s, t ↑ m) ∈ c,
⎧⎪⎨error	if there exits (s, t ↑ m) ∈ c s.t.
⎪⎩ (s,t↑m)∈c judge({(s, t ↑ m)},τ )	otherwise
judge({(s, t ↑ m)},τ )
⎧⎪error	if trace(τ, s) ⊆ Obj and for all o ∈ trace(τ, s),



⎪⎪⎩ 
type(o) is compatible with t w.r.t. m

s'∈trace(τ,s){(s',t ↑ m)}	otherwise
Definition 4.7 defines judgements on path constraints when composing the ex- tended weights.
The first case says, error returns if the current abstract heap environment is known not to satisfy the path constraints on s. This case results in the weight 0 and the related control flow is thus excluded from the analysis result.
The second case says, a known satisfied constraint will not be included into the newly generated path constraints for efficiency.
The last case says, new path constraints are generated when the judgement on path constraints is pending at the moment.
Definition 4.8 Define a semiring Se = (De, ⊕e, ⊗e, 0e, 1e), such that
De = У(D), where D = {(f, c) | f ∈ ExpFun, c ⊆ PathCons}
0e = ∅ and 1e = {(λhenv.henv, ∅)}
w1 ⊗e w2 = { p1 ⊗ p2 | p1 = (func1, c1) ∈ w1, p2 = (func2, c2) ∈ w2 }
(func ,c ) ⊗ (func ,c )=  0e	if jpc = error


where jpc = judge(c2, func1), w1, w2 ∈ De.
w1 ⊕e w2 = w1 ∪ w2 for w1, w2 ∈ De
Remark 4.9 Both the associativity of ⊗ and the distributivity of ⊕ over ⊗ hold. Since the nesting of field references and array structures is finite yet un- bounded, a bound can be given on their nested depth for efficiency.  That is,

a field or array reference nested deeper than the given bound will be regarded as pointing to anywhere(i.e., Tobj), as illustrated in Example 4.10. As a result, (w0 ⊗ w1) ⊗ w2 ± w0 ⊗ (w1 ⊗ w2) for w0, w1, w2 ∈ D.
Example 4.10 If we limit the nesting of field references to the depth 1, the anal- ysis of the Java code fragment “x.f = w; y = x.f ; z = y.g;” returns the weight λhenv.henv • [henv(x).f '→henv(w)] • [y '→henv(w)] • [z '→henv(henv(w).g)] by (w0 ⊗w1)⊗w2, and λhenv.henv•[henv(x).f '→henv(w)]•[y '→henv(w)]•[z '→oTbj] by w0 ⊗ (w1 ⊗ w2).
Remark 4.11 The points-to analysis presented above is flow-sensitive. It is easy to obtain parameterized flow-sensitivity as a hierarchy by loosening the following dimensions in the weight space design, (i) whether the points-to target of a reference is changed by a new assignment on it. For this purpose, • is reinterpreted as the union extension on maps for all references; and (ii) whether the ordering of the composition of heap environment transformers is kept on a sequence of program codes. Apart from (i), the ⊗e operation on weights w1, w2 is extended as w1 ⊗e w2
= {λhenv.henv • p1 ⊗ p2(henv) • p2 ⊗ p1(henv) | p1 ∈ w1, p2 ∈ w2}.
Definition 4.12 For a program starting with the entry point l0 ∈ Loc, let W = (P, Se,f ) be the weighted pushdown system encoded from it by Definition 2.6, and let Ret be the set of return points introduced for method invocations. The points-to analysis on the reference r ∈ Vref at the program point l ∈ Loc ∪ Ret is defined as
pta(r, C)= evalabs(δ(c, C)(hinit), r)
where δ(c, C) is from Definition 2.5 with c = ⟨·, l0⟩ and C = ⟨·, l.(Ret)∗⟩.
We take C = ⟨·, l.(Ret)∗⟩ to represent all possible pushdown configurations as an approximation, when l is the top-most stack symbol. Therefore, pta computes points-to information along all paths leading from the program’s entry point to the program point l of concern.
Soundness
Since ⊕ operation conservatively combines all possible dataflow in the analysis, we turn to the following two steps to show that our analysis is sound (Theorem 4.18),
(i) the analysis on any sequential execution path infers sound points-to results based on abstract interpretation (Theorem 4.16), and (ii) if some control flow is removed during the analysis, it is invalid indeed in the concrete execution, which is witnessed by Lemma 4.17.
Definition 4.13 Let type : O → 7 and loc : O → Loc be functions that return the type and the allocation site of a heap object, respectively. The abstraction on heap objects α : O → Obj is defined as follows,
α(o)= (t, l) for o ∈O \ {To, ⊥o}, t = type(o) ∈7 , l = loc(o) ∈ Loc; and
α(To)= Tobj and α(⊥o)= ⊥obj

The concretization is denoted by γ = α−1 : Obj → У(O). The powerset extensions of α and γ are denoted by αo : У(O) → У(Obj) and γo : У(Obj) → У(O).
Definition 4.14 For the program entry l0 and the program point l ∈ Loc ∪ Ret, let ⟨l0, hinit⟩ →∗ ⟨l, henv⟩. For r ∈ Vref at l and C = ⟨·, l.(Ret)∗⟩, pta(r, C) is sound if α0(evalcon(henv, r)) ⊆ pta(r, C).
Definition 4.15 For abstract environment transformers f1, f2 ∈ ExpFun, x ∈ Vref
and henv ∈ Henvabs, f1   f2 if evalabs(f1(henv), x) ⊇ evalabs(f2(henv), x).
Theorem 4.16 For a Jimple statement s ∈ Stmt, let f be the heap environment transformer of s, and f abs be the abstract heap environment transformer of s. Then, f abs  αo ◦ f ◦ γo.
Theorem 4.16 is proved by a case analysis on the Jimple statement s.
Lemma 4.17 For w1, w2 ∈ D, and (τ, c) ∈ w1, (τ ', c') ∈ w2, henv ∈ Henvabs, and
(s, t ↑ m) ∈ c',



s'∈tr ace(τ,s)
evalabs(henv, s') ⊇ evalabs(τ (henv), s)

Lemma 4.17 says that, the result of back-tracing by trace soundly comprise all the contributed path constraints. As illustrated in Figure 2, the analysis is performed on an operational transition sequence, where “• −→ •” represents an operational transition in one step, and w1 and w2, respectively, denote the resulting weight by composing transitions marked with the dotted line. By Lemma 4.17, to check the points-to targets of s on τ (henv) amounts to check that of all s' ∈ trace(τ, s) on henv.
henv	τ (henv)	τ ' ◦ τ (henv)

(τ,c)∈w1	'
(τ ,(s,t↑m))∈w2

Fig. 2. Sound Tracing on Path Constrains

Theorem 4.18 (Soundness) For r ∈ Vref at l ∈ Loc ∪ Ret and C = ⟨·, l.(Ret)∗⟩,
pta(r, C) is sound.
Prototype Implementation
We implemented the analysis algorithm as a prototype in the Soot framework. As shown in Figure 3, it starts off preprocessing from Java sources (or bytecode) to Jimple codes by Soot. Soot provides facilities of call graph construction and points- to analysis at various levels of precision. We borrow the most imprecise analysis CHA (Class Hierarchy Analysis) [21] to produce a preliminary call graph for the ahead-of-time analysis. A weighted pushdown system designed for the ahead-of- time points-to analysis is then constructed from the Jimple code. The analysis is finally performed by calling the Weighted PDS Library on the model, during

which the invalid control flows are removed from the analysis results on-demand. Note that, during the encoding of programs as a weighted pushdown system, extra variables will be introduced in RefVar to denote formal parameters and return values of reference type. For program statements whose execution does not change heap states, their corresponding heap environment transformers are thus identity function λhenv.henv, such as the conditional branching statement.

Fig. 3. The Prototype Framework and Running Profiles

Definition 3.5 defines rules for judging whether a type t conflicts or compatible with a type t'. For simplicity at the first stage, the case (ii) is not provided in the prototype implementation and will be included in the later ver- sion. The right-hand-side of Figure 3 shows the points-to result of analyzing Example 1.1. The analysis returns two abstract heap environment transformers. f1 gives the precise dataflow summary of this program following the control flow “4 → 9 → 15 → 6 → 9 → 20”, which precisely infers that {o3 '→o15, o5 '→o20}. f0 is a dataflow summary of the invalid call path “6 → 9 → 15” due to excluding the case (ii) above.

Related Work
Points-to analysis for Java has been an active field over the past decade. We limit our discussion primarily to recent advances especially related to context-sensitive points-to analysis.
One of the pioneer work in this field is Andersen’s points-to analysis for C [13]. It is a subset-based, flow-insensitive analysis implemented via constraint solving, such that object allocations and pointer assignments are described by subset constraints,

e.g. x = y induces pta(y) ⊆ pta(x). The scalability of Andersen’s analysis has been greatly improved by more efficient constraint solvers [14,15]. Andersen’s analysis was introduced to Java by using annotated constraints [16].
Reps, et al. present a general framework for program analysis based on CFL- reachability [11]. A points-to analysis for C is shown by formulating pointer assign- ments as productions of context-free grammars. Borrowing this view, Sridharan, et al. formulated Andersen’s analysis for Java in a demand-driven manner [17]. The analysis targets on applications with small time and memory budgets. A key insight of their algorithm is that a field read action is supposed to be preceded by a field write action, so-called balanced-parentheses problem. An improved context- sensitive analysis is later proposed by refining call paths as a balanced-parentheses problem as well [18]. The lost precision is retained by further refinement procedures. The demand-driven strategy, as well as the refinement-based algorithm makes this analysis scale.
A scalable context-sensitive points-to analysis for Java is presented in [19]. Pro- grams and analyses are encoded as the set of rules in logic programs Datalog. The context-sensitivity is obtained by cloning a method for each calling context, and by regarding loops as equivalent classes. The BDD (Binary Decision Diagram) based implementation, as well as approximation by collapsing recursions, make the anal- ysis scale. As shown in [5], there are usually rich and large loops within the call graph, and thus much precision is lost by collapsing loops.
Spark[23] is a widely-used testbed for experimenting with points-to analysis for Java. It supports both equality and subset-based analysis, provides various algo- rithms for call graph construction (such as CHA, RTA, and an on-the-fly algorithm), and enables variations on field-sensitivity. The BDD-based implementation of the subset-based algorithms further improves the efficiency of operations on points-to sets [24]. Our analysis also borrows its CHA for a preliminary call graph. A recent empirical study compares precision of subset-based points-to analyses with various abstractions on context-sensitivity [5].
One stream of research examines calling contexts in terms of sequences of objects on which methods are invoked, called object-sensitivity [20]. Similar to call-site strings based approach, the sequence of receiver objects can be unbounded and demands proper approximations, like k-CFA [6]. [5] also concludes that a context- sensitive points-to analysis in terms of object-sensitivity excels at precision and is even more likely to scale by experimental studies.
Concerning scalability for context-sensitive points-to analysis, some analysis uti- lizes BDD as the underlying data structure [23,19], others only compute results that sufficiently meet the client’s needs, so-called client-driven and demand-driven man- ner [4,18]. These strategies are also applicable to our analysis in this paper.

Conclusions
This paper presents context-sensitive points-to analysis for Java as all-in-one weighted pushdown model checking. The notion of valid paths are enriched such

that dataflow along each valid path need further satisfy type requirements for dy- namic dispatch. The ahead-of-time analysis is formalized as one run of weighted pushdown model checking, which enjoys context-sensitivities regarding both call graph and valid paths. The proposed points-to analysis is implemented as a proto- type, with Soot as the preprocessor from Java to Jimple and Weighted PDS library as the model checking engine.
The time complexity in general case specific to our analysis is Θ(|Δ|· |D|· |T⊕|· 
|T⊗|). |D| is the cardinality of the weight space. |Δ| is up to the program size by encoding. |T⊕| and |T⊗| are the prices for each weight operation. At present, the tentative experiments are restricted to small examples, due to the weight package is implemented based on linked list for a fast prototyping. Our next step is to prepare a weight package based on CrocoPat [26], a high level BBD package.

References
D. A. Schmidt. Data flow analysis is model checking of abstract interpretation. In Proceedings of the Twenty Fifth Annual Symposium on Principles of Programming Languages, pages 38-48. ACM Press, 1998.
Cousot, P. and Cousot, R., Abstract Interpretation: a unified lattice model for static analysis of programs by construction of approximation of fixpoints, Proc. 4th ACM Symposium on Principles of Programming Languages, pp.238–252, 1977.
B. G. Ryder. Dimensions of precision in reference analysis of object-oriented programming languages. In the International Conference on Compiler Construction (CC’03), pages 126-137, 2003.
S. Z. Guyer and C. Lin. Client-driven pointer analysis. In the 10th International Static Analysis Symposium (SAS), San Diego, CA, June 2003.
O. Lhot´ak and L. Hendren. Context-sensitive points-to analysis: is it worth it? In the 15th International Conference on Compiler Construction (CC 2006). LNCS volume 3923, Pages 47-64, 2006.
Olin Shivers. Control-Flow Analysis of Higher-Order Languages. PhD thesis, Carnegie Mellon University, May 1991. CMU-CS-91-145.
Rebecca Hasti and Susan Horwitz. Using static single assignment form to improve. flow-insensitive pointer analysis. In SIGPLAN 98 Conference on Programming Language Design and Implementation, pages 97-105, June 1998.
Reps, T., Schwoon, S., Jha, S., and Melski, D., Weighted pushdown systems and their application to interprocedural dataflow analysis. Science of Computer Programming, 58(1C2):206–263, October 2005.
Sagiv, M., Reps, T., and Horwitz, S., Precise interprocedural dataflow analysis with applications to constant propagation. Theoretical Computer Science 167 (1996), 131–170.
A. Bouajjani, J. Esparza, and O. Maler. Reachability analysis of pushdown automata: Application to model-checking. In the 8th International Conference on Concurrency Theory (CONCUR’97), volume 1243 of LNCS, pages 135-150. Springer-Verlag, 1997.
T. Reps. Program analysis via graph reachability. Information and Software Technology, 40(11- 12):701C726, November/December 1998.
Jim Alves-Foss (Ed.). Formal syntax and semantics of Java. LNCS 1523 Springer 1999.
L. O. Andersen. Program Analysis and Specialization for the C Programming Language. PhD thesis, University of Copenhagen, DIKU, 1994.
M. F¨andrich, J. S. Foster, Z. Su, and A. Aiken. Partial online cycle elimination in inclusion constraint graphs. In ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI),Montreal, Canada, June 1998.
N. Heintze and O. Tardieu. Ultra-fast aliasing analysis using CLA: A million lines of C code in a second. In ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), Snowbird, Utah, June 2001.


A. Rountev, A. Milanova, and B. G. Ryder. Points-to analysis for Java using annotated constraints. In Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), Tampa Bay, Florida, October 2001.
M. Sridharan, D. Gopan, L. Shan, and R. Bod´ık. Demand-driven points-to analysis for Java. In
Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), 2005.
M. Sridharan and R. Bodik. Refinement-Based Context-Sensitive Points-To Analysis for Java. In the Proceedings of ACM SIGPLAN 2006 Conference on Programming Language Design and Implementation (PLDI 2006).
John Whaley and Monica S. Lam. Cloning-based context-sensitive pointer alias analysis using binary decision diagrams. Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation(PLDI), 2004.
A. Milanova, A. Rountev, and B. Ryder. Parameterized object-sensitivity for points-to and side-effect analyses for Java. In the International Symposium on Software Testing and Analysis, pages 1-11, 2002.
Dean, J., Grove, D., and Chambers, C. Optimization of object-oriented programs using static class hierarchy analysis. In Proceedings of the Ninth European Conference on Object-Oriented Programming (ECOOP’95) (Aarhus, Denmark, Aug. 1995), W. Olthoff, Ed., Springer-Verlag, pp. 77-101.
Bacon, D. F. Fast and Effective Optimization of Statically Typed Object-Oriented Languages. PhD thesis, Computer Science Division, University of California, Berkeley, Dec. 1997. Report No. UCB/CSD- 98-1017.
O. Lhot´ak and L. Hendren. Scaling Java points-to analysis using Spark. In Proceedings of the 12th International Conference on Compiler Construction (CC), pages 153-169, April 2003.
M. Berndl, O. Lhot´ak, F. Qian, L. Hendren, and N. Umanee. Points-to analysis using BDDs. In ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), San Diego, CA, June 2003.
R. Vallee, Phong, C. Etienne, G. Laurie, H. Patrick, and L. Vijay: Soot - a Java bytecode optimization framework, Proceedings of the 1999 conference of the Centre for Advanced Studies on Collaborative research 1999 (CASCON ’99), Ontario, Canada, November 1999.
D. Beyer, A. Noack, C. Lewerentz. Efficient Relational Calculation for Software Analysis. IEEE Transactions on Software Engineering (TSE), 31(2):137-149, 2005.
