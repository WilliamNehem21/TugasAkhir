Available online at www.sciencedirect.com



Electronic Notes in Theoretical Computer Science 276 (2011) 5–28
www.elsevier.com/locate/entcs

A Revisionist History of Concurrent Separation Logic
Stephen Brookes
Department of Computer Science Carnegie Mellon University Pittsburgh, USA

Abstract
Concurrent Separation Logic is a resource-sensitive logic for fault-free partial correctness of concurrent pro- grams with shared mutable state, combining separation logic with Owicki-Gries inference rules, in a manner proposed by Peter O’Hearn. The Owicki-Gries rules and O’Hearn’s original logic lacked compositionality, being limited to programs with a rigid parallel structure, because of a crucial constraint that “no other process modifies” certain variables, imposed as a side condition in the inference rule for conditional criti- cal regions. In prior work we proposed a more general formulation of a concurrent separation logic using resource contexts, and we offered a soundness proof based on a trace semantics. Recently Ian Wehrman and Josh Berdine discovered an example showing that this soundness proof relies on a hidden assumption, tantamount to “no concurrent modification”, so that the proposed logic also suffices only for rigid programs. Here we show that, with a natural and simple adjustment we can avoid this problem. The key idea is to augment each assertion with a “rely set” of variables, assumed to be unmodified by other processes, and adjust the inference rules to validate and take advantage of these assumptions. This revised concurrent separation logic is compositional, allowing rigid and non-rigid programs, and the extra constraints imposed by rely set requirements ensure soundness. At the same time, we relax the Owicki-Gries constraints on the use of critical variables, allowing variables to be protected by multiple resources and building into the logic a simpler, yet more general, protection discipline. In the revised logic, a process wanting to write to a shared variable must acquire all resources that protect it, while a process wishing to read a shared variable need only acquire one such resource. This generalization brings concurrent separation logic closer in spirit to permission-based logics, in which processes may be allowed to perform concurrent reads.
Keywords: concurrency, shared memory, denotational semantics, resources, separation logic

Introduction
Concurrent Separation Logic (CSL) is a resource-sensitive logic for reasoning about fault-free partial correctness of shared-memory concurrent programs. CSL com- bines separation logic, originally introduced in [10] by John Reynolds for reasoning about sequential pointer programs, with Owicki-Gries rules for pointer-free shared- memory programs [7], in a manner proposed by Peter O’Hearn [6]. The Owicki- Gries and O’Hearn logics lack compositionality, being limited to programs with rigid parallel structure, because of a static constraint that “no other process modifies” certain variables, imposed as a side condition in the rule for conditional critical regions.

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.09.013

In prior work we formulated a more general concurrent separation logic [3] using resource contexts in an attempt to avoid these limitations, and we gave a soundness proof, using on a trace-based denotational semantics. A major feature in this devel- opment was a semantic formalization of O’Hearn’s notion of “ownership transfer” based on resource invariants, and O’Hearn’s principle that processes “mind their own business” [6]. Recently Ian Wehrman and Josh Berdine found a counterexam- ple [12] showing that this soundness proof makes a hidden assumption, tantamount to “no other process modifies”, leading to the realization that the soundness analysis of [3] only suffices for rigid programs.
We show here that, with a systematic natural adjustment to the prior formula- tion, we can develop a fully compositional concurrent separation logic that avoids this problem. The key idea is to augment the assertions of CSL with a “rely set”, representing a set of variables assumed to be left unmodified by the “environment”. By making this set an integral part of assertions, we avoid the need for a non- compositional side condition; we are able to properly account for the assumptions and guarantees that a process makes about modifications to shared variables, in a purely syntax-directed manner.
At the same time, we relax the Owicki-Gries constraints on the use of critical variables, allowing variables to be protected by multiple resources and building into the logic a simpler, more general, protection discipline. This brings concurrent separation logic closer in spirit to permission-based logics, in which processes may be allowed to perform concurrent reads [1,2].
Again using action trace semantics, we sketch a soundness proof for the revised logic, this time without the hidden assumption and without requiring rigid program structure. We offer a series of examples, addressing Wehrman’s problem, and show- ing that the augmented logic can deal with a wider variety of programs than the original, because of our relaxation of the Owicki-Gries constraints. We intend the revised and augmented logic presented here to replace the original.
We assume familiarity with separation logic, as defined by Reynolds [10].

Syntax
The syntax of our programming language (as in [3]) is given by the following abstract grammar, in which c ranges over the set Com of commands.

c ::= skip | i:=e | i:=[e] | [e]:=ej | i:=cons E | dispose e
|  c1; c2 | if b then c1 else c2 | while b do c
|  with r when b do c | c1  c2
Let e, b range over integer expressions and boolean expressions, respectively, and E range over list expressions of form [e1,..., en]. Expressions are pure, i.e. indepen- dent of the heap.
We distinguish syntactically between identiﬁers (i ∈ Ide) denoting integer vari-

ables, and resource names (r ∈ Res), which behave like binary semaphores, to be represented semantically as integer variables whose value is constrained to be 0 or 1.
Let free(c) ⊆ Ide be the set of identifiers with a free occurrence in c, mod (c) be the set of identifiers with a free write occurrence, and res(c) ⊆ Res be the set of resource names with a free occurrence in c. These are defined as usual, by structural induction. For example,

free(i:=e)= free(e) ∪ {i}
free(c1; c2)= free(c1  c2)= free(c1) ∪ free(c2) free(with r when b do c)= free(b) ∪ free(c) free(resource r in c)= free(c)
res(i:=e)= {}
res(c1; c2)= res(c1  c2)= res(c1) ∪ res(c2) res(with r when b do c)= res(c) ∪ {r} res(resource r in c)= res(c) − {r}
mod (i:=e)= mod (i:=cons E)= mod (i:=[e]) = {i}
mod ([e]:=ej)= mod (dispose e)= {}
mod (c1; c2)= mod (c1  c2)= mod (c1) ∪ mod (c2) mod (with r when b do c)= mod (c) mod (resource r in c)= mod (c)
Assertions
As in Owicki-Gries [7], we associate to each resource name r a set X ⊆ Ide of “protected variables” and a “resource invariant” R [5]. As in O’Hearn’s CSL [6], pre- and post-conditions, and resource invariants, are separation logic formulas. As in [3], instead of assuming a fixed choice of resource invariants and protection sets, we extend the syntax of partial correctness assertions to include a resource context Γ. We relax the permission rules from Owicki-Gries, O’Hearn, and the original concurrent separation logic [3], by not insisting that protection sets be pairwise disjoint. As in [3] we require resource invariants to be precise [10]. A separation logic formula R is precise iff, for all stores s and heaps h, there is at most one sub-heap hj ⊆ h such that (s, hj) |= R.
Definition 3.1 A well-formed resource context Γ has the form
r1(X1): R1,..., rn(Xn): Rn

where r1,..., rn are distinct resource names, X1,..., Xn are sets of identifiers, each
Ri is precise, and free(Ri) ⊆ Xi for each i.
We say that r protects x in Γ when r(X): R is in Γ and x ∈ X. Let owned (Γ) =
Sn	Xi, and inv (Γ) = R1∗·· ·∗Rn. Let dom(Γ) be {r1,..., rn}. We let (Γ, r(X): R)
i=1
be the context formed by augmenting Γ with r(X): R, provided this is well-formed.
Definition 3.2 An assertion has form
Γ ▶A {p}c{q}

where A is a set of identifiers, which we will call a rely set. The pre- and post- conditions p and q, and the resource invariants in Γ, do not mention resource names. Such an assertion is well-formed iff Γ is a well-formed context, free(p, q) ⊆ A, and free(c) ⊆ owned (Γ) ∪ A.
In a well-formed assertion Γ ▶A {p}c{q} the pre- and post-conditions may men- tion identifiers owned by resources in Γ, but only if they also belong to the rely set A; the command c may use variables owned by resources or belonging to the rely set. The inference rules (to be introduced shortly) will constrain how and where c is allowed to read and write these variables: in particular, c can only write to a variable protected by r inside a critical region that names r; and reads of a pro- tected variable must be inside a critical section, unless the variable belongs to the rely set. The rules keep track (in the rely sets) of the variables used (outside of critical regions) in a proof: these must not be modified by any other process, and this constraint is enforced as a side condition of the parallel rule. Our revised logic actually enforces the following protection regime: every write in c to a protected variable must be inside (nested) critical regions naming all resources that protect it; and every read occurrence in c of a protected variable must be inside a critical region naming some resource that protects it. In the special case where the protec- tion sets are pairwise disjoint, this coincides with the usual Owicki-Gries discipline: reads or writes to a protected variable must be inside a critical region naming the (unique) protecting resource.
Validity
Even before we introduce a semantic model for the programming language we can provide an intuitive characterization of what an assertion is intended to say about program behavior. An assertion expresses a “guarantee” on program behavior in suitably constrained environments, i.e. when executed concurrently with other pro- cesses whose behavior is assumed to behave as specified.
Definition 4.1 The assertion Γ ▶A {p}c{q} is valid iff every finite interactive com- putation of c, from a state (with values for all variables in Γ, A) satisfying p∗inv (Γ), in an environment that respects Γ and does not modify the variables in A, is fault- free, respects Γ, and ends in a state satisfying q ∗ inv (Γ).

Respect for Γ means obeying the protection regime implied by Γ and preservation of each resource invariant (separately). Fault-freedom means no runtime errors such as dangling pointers, and no race conditions involving concurrent writes to shared variables or heap.
This notion of validity will be made formal later, by means of action trace semantics and “local enabling” relations −−−λ→ defined as before [3] except that we only allow “environment” moves that do not modify the variables in the rely set A. Validity of Γ ▶A {p}c{q} implies that when c is executed in isolation from a state satisfying p ∗ inv (Γ), the execution is fault-free, and if it terminates the final state satisfies q ∗ inv (Γ). This is because the empty environment vacuously respects Γ and does not modify any variable. Hence the usual slogan that provable programs
are safe.

Inference rules
The inference rules for our revised logic are obtained from the original CSL [3] by adding rely sets, and relaxing the constraints on use of protected variables. We only allow well-formed instances of the rules, so every provable formula will be well-formed, as specified above.

Skip

Assignment


Γ ▶A {p}skip{p}

if free(p) ⊆ A





Γ ▶A {[e/i]p}i:=e{p}
if i ∈/
owned (Γ), free(e) ⊆ A

Sequence

Conditional

Loop

Γ ▶A1 {p1}c1{p2}	Γ ▶A2 {p2}c2{p3}

Γ ▶A1∪A2 {p1}c1; c2{p3}
Γ ▶A1 {p ∧ b}c1{q}	Γ ▶A2 {p ∧ ¬b}c2{q}

Γ ▶A1∪A2 {p}if b then c1 else c2{q}
Γ ▶A {p ∧ b}c{p}


Γ ▶A {p}while b do c{p ∧ ¬b}

Parallel
Γ ▶A1 {p1}c1{q1}	Γ ▶A2 {p2}c2{q2}


if mod (c ) ∩ A = mod (c ) ∩ A


= {}

1	2	2	1

Critical region
Γ ▶A∪X {(p ∧ b) ∗ R}c{q ∗ R}
Γ, r(X): R ▶A {p}with r when b do c{q}

Local resource
Γ, r(X): R ▶A {p}c{q}
Γ ▶A∪X {p ∗ R}resource r in c{q ∗ R}


Renaming

Γ ▶A {p}resource rj in [rj/r]c{q} Γ ▶A {p}resource r in c{q}


if rj


/∈ res(c)

Lookup




Γ ▶A {[ej/i]p ∧ e '→ ej}i:=[e]{p ∧ e '→ ej}
if i ∈/
free(e, ej), i /∈ owned (Γ)

Update

Allocation


Γ ▶A {e '→ −}[e]:=ej{e '→ ej}





Γ ▶A {emp}i:=cons(E){i '→ E}
if i ∈/
free(E), i ∈/
owned (Γ)

Disposal

Frame


Γ ▶A {e '→ −}dispose e{emp}



	Γ ▶A {p}c{q}	
Γ ▶A∪free(R) {p ∗ R}c{q ∗ R}
if mod (c) ∩ free(R)= {}



Consequence

 Γ ▶A {p}c{q} 
Γ ▶A′ {pj}c{qj}


if A ⊆ Aj, pj ⇒ p, q ⇒ qj



Auxiliary
Γ ▶A∪X {p}c{q}
Γ ▶A {p}c\X{q}

if X is auxiliary for c, X ∩ free(p, q)= {}, X ∩ owned (Γ) = {}
Conjunction


Commentary
Γ ▶A1 {p1}c1{q1}	Γ ▶A2 {p2}c2{q2}
ΓA1∪A2 {p1 ∧ p2}c{q1 ∧ q2}

We offer some intuition and explanation for the side conditions, and the (mostly implicit) rˆole played by the well-formedness requirements.
Skip: the side condition that free(p) ⊆ A ensures well-formedness.

Assignment: allowed to read identifiers belonging to the rely set A; only allowed
to write to i if i ∈/ owned (Γ). Well-formedness implies i ∈ A.
Sequence: rely set A1∪A2 includes the free variables of the intermediate condition
p2, not just those of the pre- and post-condition.
Conditional, Loop: well-formedness implies that free(b) ⊆ A.
Parallel: c1 relies on its environment to modify variables in A1, hence the side condition mod (c2) ∩ A1 = {}; similarly for c2 and mod (c1) ∩ A2 = {}. Suppose Γ ▶A1 {p1}c1{q1} and Γ ▶A2 {p2}c2{q2} are well-formed, and the side conditions hold. Then free(p1, q1) ⊆ A1 and free(p2, q2) ⊆ A2, so mod (c1) ∩ free(p2, q2)= {} and mod (c2) ∩ free(p1, q1) = {}, as in Owicki-Gries. We also have free(c1) ⊆ owned (Γ) ∪A1 and free(c2) ⊆ owned (Γ) ∪A2, so “critical variables are protected”,
i.e. mod (c1) ∩ free(c2) ⊆ owned (Γ) and mod (c2) ∩ free(c1) ⊆ owned (Γ), as in Owicki-Gries. The rely set A1 includes the variables used (outside of critical regions) in the proof for c1, and similarly for A2 and c2, so we enforce here the “no concurrent modification” requirement on the relevant variables. It is natural to do so here, since after all this is the inference rule for concurrent processes.
Critical region: The premiss relies on A∪X because mutual exclusion for r implies that no concurrent process can touch the variables in X. In the conclusion there is no need to include the protected variables in the rely set, although this is allowed. If the premiss is well-formed, so is the conclusion.
Local resource: The conclusion relies on A ∪ X, which ensures well-formedness because free(R) ⊆ X by well-formedness of the premiss.
Update, Lookup, Allocation, Disposal: axioms as before, with side conditions to ensure well-formedness.
Frame: as before, c must not write to any variable occurring free in R. There is no need to insist that free(R) ∩ owned (Γ) = {} (as in the original CSL formulation), because pre- and post-conditions are allowed to mention protected variables; in- stead we add the variables occurring free in R to the rely set, reflecting the assumption that no concurrent processes modify these variables.
Consequence: as usual, except that we also allow strengthening of the rely set. If Γ ▶A {p}c{q} is valid and A ⊆ Aj, then Γ ▶A′ {p}c{q} is also valid, since it ex- presses a less general semantic property of c, quantifying over a more constrained set of possible environments.
Auxiliary: a set X of variables is auxiliary for c iff each free occurrence in c of a variable from X is in an assignment whose target identifier also belongs to X. The requirement that auxiliary variables do not occur free in the pre- or post-condition is standard; that they do not appear in protection lists is also crucial.
Conjunction: as noted by John Reynolds, precision of resource invariants is crucial in showing the soundness of this rule. When R is precise, for all p1 and p2 we have (p1 ∧ p2) ∗ R ⇔ (p1 ∗ R) ∧ (p2 ∗ R).

Examples
We now discuss some example programs and assertions, to illustrate the way the inference rules work and to contrast the new CSL with the original one. Examples
(i) and (ii) address the issues raised by Wehrman and Berdine.
We adopt the convention that when free(R)= X, we may omit X from r(X): R and just write r : R, since this leads to more succinct assertions.
The assertions
r : x = a ∧ emp ▶{a,t} {emp}with r do t:=x{t = a ∧ emp}
r : x = a ∧ emp ▶{a,t} {t = a ∧ emp}with r do x:=t{emp}
are valid and well-formed. Each is also provable from Region, having first proven
▶{a,t,x} {x = a ∧ emp}t:=x{t = a ∧ emp},
▶{a,t,x} {t = a ∧ x = a ∧ emp}x:=t{x = a ∧ emp}
by Assignment and Consequence. However, the assertions
(aj)	r : x = a ∧ emp ▶{t} {emp}with r do t:=x{t = a ∧ emp}
(bj)	r : x = a ∧ emp ▶{t} {t = a ∧ emp}with r do x:=t{emp}
are invalid (and not well-formed), and not provable.
Let c1 be with r do t:=x; with r do x:=t. The assertion
r : x = a ∧ emp ▶{a,t} {emp}c1{emp}
is valid, well-formed, and provable from (a) and (b) using Sequence. But the assertion
(cj)	r : x = a ∧ emp ▶{t} {emp}c1{emp}
is invalid (even though well-formed), and unprovable.
Let c1 be as above and let c2 be with r do (x:=x + 1; a:=a + 1). There is no set A of identifiers for which the assertion
r : x = a ∧ emp ▶A {emp}c1  c2{emp}
is valid. Indeed, even for the most restrictive rely set A = {x, a, t} the assertion is invalid: executing c1  c2 without interference does not necessarily preserve equality of x and a.
Moreover, there is also no set A for which this assertion is provable, because
A would need to be expressible as A1 ∪ A2 with both
r : x = a ∧ emp ▶A1 {emp}c1{emp}

and

r : x = a ∧ emp ▶A2 {emp}c2{emp}

being provable. The first of these would need an intermediate condition that mentions (t and) either x or a, so A1 would have to contain x or a. But c2 modifies both of these variables, so the side condition on the parallel rule would fail.
This example, without the rely set, was found by Wehrman and Berdine, who showed that the assertion
r : x = a ∧ emp ▶ {emp}c1  c2{emp}
is provable in the original concurrent separation logic but not valid (with re- spect to the notion of validity used in CSL). The analysis above shows that the use of rely sets avoids this problem.
The assertion
r : x = a + b ∧ emp ▶{a} {a =0 ∧ emp}
with r do (x:=x + 1; a:=a + 1)
{a =1 ∧ emp}
is valid, and provable from Region and Consequence, because
▶{x,a,b} {x = a + b ∧ a =0 ∧ emp}
x:=x + 1; a:=a +1 
{x = a + b ∧ a =1 ∧ emp}
is provable from Sequence, Assignment, and Consequence.
Similarly we can prove
r : x = a + b ∧ emp ▶{b} {b =0 ∧ emp}
with r do (x:=x + 1; b:=b + 1)
{b =1 ∧ emp}.
Using Parallel and Consequence we can then derive
r : x = a + b ∧ emp ▶{a,b} {a =0 ∧ b =0 ∧ emp}
with r do (x:=x + 1; a:=a + 1)
 with r do (x:=x + 1; b:=b + 1)
{a =1 ∧ b =1 ∧ emp}.

This assertion is also valid.
Using the Resource rule and Consequence we then obtain
▶{a,b,x} {a =0 ∧ b =0 ∧ x = a + b ∧ emp}
resource r in
with r do (x:=x + 1; a:=a + 1)  with r do (x:=x + 1; b:=b + 1)
{a =1 ∧ b =1 ∧ x = a + b ∧ emp}.
By Sequence, Assignment, and Consequence we then have
▶{a,b,x} {x =0 ∧ emp}
a:=0; b:=0;
resource r in
with r do (x:=x + 1; a:=a + 1)  with r do (x:=x + 1; b:=b + 1)
{x =2 ∧ emp}.

Finally, since {a, b} is an auxiliary variable set for this program, and a, b do not occur in the pre- or post-condition, we can use the Auxiliary rule to obtain
▶{x} {x =0 ∧ emp}
resource r in
with r do x:=x +1  with r do x:=x +1 
{x =2 ∧ emp}.

We revisit O’Hearn’s one-place buffer program [6,3]. The example goes through almost unchanged, except for the insertion of rely sets. Let R be (full = 1∧z '→
−) ∨ (full =0 ∧ emp). Let PUT and GET be the commands
PUT :: with buf when full =0 do (z:=x; full :=1)
GET :: with buf when full =1 do (y:=z; full :=0).
The assertions
buf (z, full ): R ▶{x} {x '→ −}PUT{emp}
buf (z, full ): R ▶{y} {emp}GET{y '→ −}
are valid and provable. Similarly,
buf (z, full ): R ▶{y} {emp}(GET ; dispose y){emp}

is provable, and so is
buf (z, full ): R ▶{x,y} {x '→ −} PUT  (GET ; dispose y){emp}.
Now let Rj be (full =1 ∧ z '→ −) ∨ (full =0 ∧ emp). The assertions
buf (z, full ): Rj ▶{x} {x '→ −}PUT{x '→ −}
buf (z, full ): Rj ▶{y} {emp}GET{emp}
are valid and provable. Similarly
buf (z, full ): Rj ▶{x} {x '→ −}(PUT ; dispose x){emp}
is provable, and so is
buf (z, full ): Rj ▶{x,y} {x '→ −} (PUT ; dispose x)  GET{emp}.
The assertion
r : x = y ∧ emp ▶{} {emp}with r do (x:=x + 1; y:=y + 1){emp} is valid. Clearly {y} is auxiliary for the command here. The assertion
r : x = y ∧ emp ▶{} {emp}with r do (x:=x + 1){emp}
is obviously invalid. This shows that the side condition requiring that auxiliary variables must not appear in resource invariants is crucial, as noted previously.
Let c1 and c2 be:
c1 :: with r1 do ((with r2 do a:=1); [42]:=1)
c2 :: with r2 do ((with r1 do a:=2); [42]:=2).
Let R1 and R2 be the assertions
R1 :: (a =1 ∧ 42 '→ 1) ∨ (a =2 ∧ emp)
R2 :: (a =1 ∧ emp) ∨ (a =2 ∧ 42 '→ 2).

Note that R1 ∗ R2 is equivalent to (a =1 ∧ 42 '→ 1) ∨ (a =2 ∧ 42 '→ 2). The following assertions are provable:


▶{a} {R1 ∗ R2}a:=1{(42 '→  ∧ a = 1) ∗ R2}
r2(a): R2 ▶{a} {R1}with r2 do a:=1{42 '→  ∧ a = 1}
r2(a): R2 ▶{a} {42 '→  ∧ a = 1}[42]:=1{R1}
r2(a): R2 ▶{a} {R1}(with r2 do a:=1); [42]:=1{R1}
r1(a): R1, r2(a): R2 ▶{} {emp}c1{emp}
Assignment, Consequence
Region, (a)
Update, Consequence, (b)
Sequence, (b), (c)
Region, Consequence, (d)

Similarly we can derive
r1(a): R1, r2(a): R2 ▶{} {emp}c2{emp}
Then, by Parallel from (e), (f ) we obtain
r1(a): R1, r2(a): R2 ▶{} {emp}c1  c2{emp}
and finally, by Resource (used twice),
▶{a} {R1 ∗ R2}resource r1 in resource r2 in (c1  c2){R1 ∗ R2}.
Note that this program cannot be proven correct in the original CSL, because it violates the more stringent Owicki-Gries constraints on use of critical variables. Indeed, we made use in the proof of a resource context r1(a) : R1.r2(a) : R2 in which the protection lists are not disjoint. The same example has been discussed as a “problematic program” by John Reynolds [11], and can also be handled cleanly in Uday Reddy’s logic [9] by using fractional permissions. We include this example to indicate an advantage of employing weaker restrictions on variable use.
States, actions and traces
As in [10] a state σ is a pair (s, h) consisting of a store s and a heap h. The store maps (a finite set of) identifiers to (integer) values; the heap maps (a finite set of) locations to values; locations are also integers. In a given state dom(s) is the set of identifiers currently in scope, and dom(h) is the set of active locations. We regard resource names as identifiers whose value is restricted to be 0 (in use) or 1 (available). Let St be the set of all states.
As in [3] the set Λ of actions (ranged over by λ, μ) is specified as follows, where v, vj, v0 ..., vn range over integer values, i ranges over identifiers, and r ranges over resource names:
λ ::= δ | i=v | i:=v
|  [v]=vj | [v]:=vj | alloc(v, [v0,..., vn]) | disp(v)
|  acq (r) | rel (r) | try (r)
|  abort
We let mod (λ) be the set of identifiers whose value is modified by λ: mod (i:=v)= 
{i} and mod (λ) = {} otherwise. We let writes(λ) ⊇ mod (λ) be the set of identifiers or heap cells modified by λ: writes(i:=v) = {i}, writes([v]:=vj) =
{v}, writes(alloc(v, [v0,..., vn])) = {v, v + 1,...,v + n}, writes(disp(v)) = {v}, writes(λ)= {} otherwise. Similarly we let reads(λ) be the set of identifiers or heap cells whose value is read by λ: reads(i=v)= {i}, reads([v]=vj)= {v}, reads(λ)= {}



(s, h) =⇒δ
(s, h)


(s, (h) ===⇒ (s, h)	if (i, v) ∈ s
i=v
(s, h) ===⇒ abort	if i ∈/ dom(s)

(s, h) ====⇒ ([s | i : v], h)	if i ∈ dom(s)
i:=v
(s, h) ====⇒ abort	if i ∈/ dom(s)


[v]=v′	j
(s, h) =====⇒ (s, h)	if (v, v ) ∈ h
[v]=v′
(s, h) =====⇒ abort	if v ∈/ dom(h)


[v]:=v′	j
(s, h) ======⇒ (s, ([h | v : v ])	if v ∈ dom(h)
[v]:=v′
(s, h) ======⇒ abort	if v ∈/ dom(h)


disp(v)
(s, h) ======⇒ (s, h\v)	if v ∈ dom(h)
disp(v)
(s, h) ======⇒ abort	if v ∈/ dom(h)


alloc(v,[v0,...,vn])	j
(s, h) ==============⇒ (s, h )	if {v,...,v + n}∩ dom(h)= {},
where hj = [h | v : v0,...,v + n : vn]


acq r
(s, h) ====⇒ ([s | r : 0], h)	if (r, 1) ∈ s


try r
(s, h) ====⇒ (s, h)	if (r, 0) ∈ s


(s, h) ====⇒ ([s | r : 1], h)	if (r, 0) ∈ s


(s, h)
=a=b=o=r⇒t
abort


Fig. 1. Enabling relations
otherwise.  And we let free(λ) be the set of identifiers or heap cells used in λ:
free(λ)= reads(λ) ∪ writes(λ). And we let res(λ) be the set of resource names used

in λ.
Actions have an effect on the state, as specified by the enabling relations
St × (St ∪ {abort}). These relations are given in Figure 1.

=⇒λ  ⊆ 

Note that read and write actions (i = v and i:=v) depend only on, and only affect, the store; lookup, update, allocation and disposal actions depend only on, and only affect, the heap; and resource actions depend only on, and only affect the values of resource names (again, in the store). It is also obvious that the enabledness of a store action, and its effect, only depends on the value of the identifier or resource name attached to the action.


Semantics
We use the same denotational semantic model as before [3]. We summarize the key concepts and technical details. Expressions denote sets of evaluation traces: an evaluation trace has form (ρ, v), where ρ is a finite sequence of read actions (or δ) and v is a value. Expression evaluation always terminates, so ρ ranges over finite traces. Since expressions are pure their traces only involve read actions. We assume given the semantics of expressions: for integer expressions e, [[e]] ⊆ Λ∗ × Vint ; for boolean expressions b, [[b]] ⊆ Λ∗ × {true, false}; and for list expressions E, [[E]] ⊆ Λ∗ × V ∗ . For boolean expressions we let [b]]true = {ρ | (ρ, true) ∈ [[b]]}, and [b]]false = {ρ |
(ρ, false) ∈ [[b]]}. We write Vint for the set of integers, Vbool for the set of truth

values, and V ∗
for the set of finite sequences of integers.

Commands denote sets of action traces, which may be finite or infinite, and whose structure reflects the mutual exclusion assumption, that resources behave like binary semaphores. Command semantics is defined by structural induction, as follows.

[[skip]] = {δ}
[[i:=e]] = {ρ i:=v | (ρ, v) ∈ [[e]]}
[[c1; c2]]= [[c1]][[c2]]
[[if b then c1 else c2]]= [[b]]true [[c1]] ∪ [[b]]false [[c2]]
[[while b do c]]= ( [b]]true [[c]])∗[[b]]false ∪ ([[b]]true [[c]])ω
[[local i = e in c]] = {ρ(α\i) | (ρ, v) ∈ [[e]] & α ∈ [[c]][i:v]}
[[i:=[e]]] = {ρ [v]=vj i:=vj | (ρ, v) ∈ [[e]] & vj ∈ Vint }
[[[e]:=ej]] = {ρρj [v]:=vj | (ρ, v) ∈ [[e]] & (ρj, vj) ∈ [[ej]]}
[[i:=cons(E)]] = {ρ alloc(v, L) | (ρ, L) ∈ [[E]] & v ∈ Vint }
[[dispose(e)]] = {ρ disp(v) | (ρ, v) ∈ [[e]]}

[[with r when b do c]] = wait∗enter ∪ waitω
where wait = {try (r)}∪ {acq (r) ρ rel (r) | ρ ∈ [[b]]false }
and enter = {acq (r) ρα rel (r) | ρ ∈ [[b]]true & α ∈ [[c]]}
[[resource r in c]] = {α\r | α ∈ [[c]][r:1]}
[[c1  c2]] = S{α1{}  {}α2 | α1 ∈ [[c1]] & α2 ∈ [[c2]]}
The semantic clause for local resources uses enabling relations to characterize traces that are sequentially executable under an assumption that a resource name is “local”,
i.e. assuming that no other process changes its value. We say that α is executable for r iff α T r is enabled from the store [r : 1] (i.e. assuming that r is initially available). We write [c]][r:1] for the set of traces of c that are executable from [r : 1]. The clause for local variables uses a similar construction.
The semantic clause for parallel composition uses fair interleaving [8] with race detection and attention to resources, treating a potential race as a catastrophe. If α1 and α2 are traces, and O1, O2 are disjoint sets of resource names, we define α1 O1  O2 α2 to be the set of traces obtainable by interleaving α1 with α2, paying attention to resources, assuming that the process executing α1 starts with resources O1 and the process executing α2 starts with resources O2. When O1 ∩ O2 = {} we
define the relation O1 ===λ⇒ Oj , which holds when a process with resources O1 can
O2	1
execute λ in an environment with resources O2, after which the process will have
resources Oj . These relations are given by:


acq (r)
O1 =====⇒ O1 ∪ {r}	if r ∈/
O2
rel (r)

O1 ∪ O2

O1 =====⇒ O1 − {r}	if r ∈ O1
O2
try (r)
O1 =====⇒ O1	if r ∈ O1 ∪ O2
O2
λ

O1 ===⇒ O1	if λ ∈/
O2
{acq (r), rel (r), try (r) | r ∈ Res}



We extend to finite traces in the obvious way, so that O1
===α⇒ Oj
iff a process

O2	2
starting with resources O1 can, in an environment with resources O2, execute the
sequence α and afterwards possess resources Oj . Then for finite traces we define the fair merge operators O1  O2 inductively as usual:

α O  O
ϵ = {α | ∃Oj . O1 ===α⇒ Oj }

1	2	1
ϵ	j
O2	1
β	j

O1 O2 β = {β | ∃O2. O2 ===⇒ O2}
1

(λα) O  O (μβ) = {λγ | O1 ===λ⇒ Oj
& γ ∈ α  ′  O (μβ)}

1	2	O2	1
∪ {μγ | O ==μ	Oj & γ
1
∪ {abort | λ da μ}
O1	2
∈ (λα) O1 O′ β}

We define the conflict relation λ da μ to hold iff writes(λ)∩free(μ) /= {} or writes(μ)∩ free(λ) /= {}. Note that conflict thus corresponds to a write of an identiﬁer or a heap cell that is being used concurrently. This definition extends to infinite traces in the standard way, but since we only need to deal here with finite traces we will omit the details.
The following result shows that commands respect resources.
Lemma 8.1 If α ∈ [[c]] then for each resource name r, α T {acq r, rel r} is a preﬁx of ((acq r)(rel r))ω.
The following property of finite (non-aborting) traces, is also useful.

Lemma 8.2 If α ∈ [[c]] and (s, h)
for all r, and sj(i)= s(i) for all i ∈/
=α⇒ (sj, hj) then dom(sj)= dom(s), sj(r)= s(r)
writes(c).

Local state
A global state (s, h), seen from the perspective of a process interacting with its environment, can be represented as (s, (h1, O1), (h2, O2),H), where (h1, O1) repre- sents the heap portion and resource set owned by the process, (h2, O2) is owned by the environment, and H is the rest of the heap, containing a portion in which the resource invariants hold, separately, for the currently available resources. The global heap is the disjoint union of these portions, i.e. h = h1 · h2 · H. As in [10], heaps h1 and h2 are separate, written h1 ⊥ h2, iff dom(h1) ∩ dom(h2) = {}, and when this holds we write h1 · h2 for the (disjoint) union of h1 and h2.
For a set of resource names O let Γ T O = {r(X) : R ∈ Γ | r ∈ O} and
Γ\O = {r(X) : R ∈ Γ |  r ∈/	O}. When O is a singleton we write Γ T r as an
abbreviation for Γ T {r}, and similarly Γ\r for Γ\{r}. Recall that inv (Γ) is the separate conjunction of the invariants in Γ; when Γ is empty this is emp.
Definition 9.1 A local state for Γ is a combination (s, (h1, O1), (h2, O2),H) satis- fying the following separation properties:
h1, h2,H are separate
O1 ∩ O2 = {}, s(r) = 0 for all r ∈ O1 ∪ O2, s(r) = 1 otherwise
(s, H) |= inv (Γ\(O1 ∪ O2)) ∗ true.
In other words, the process, its environment, and the available resources, own separate heap portions; the process and its environment own disjoint resources; and in the rest of the heap, the invariants for available resources hold, separately. Let ΣΓ be the set of local states for Γ.
A local state (s, (h1, O1), (h2, O2),H) corresponds to a global state, namely (s, h1 · h2 · H), obtained by combining the heap portions and ignoring the resource ownership partition. In general, a global state may be representable in such manner by many different local states, or by no such local state, for example if no subheap of the global heap satisfies the resource invariants.


(s, (h1, O1), (h2, O2),H) −−−δ→ (s, (h1, O1), (h2, O2),H)


(s, (h1, O1), (h2, O2),H) −−i=−→v
(s, (h1, O1), (h2, O2),H)

if (i, v) ∈ s and i ∈ owned (Γ T O1) ∪ A


(s, (h1, O1), (h2, O2),H) −i−:=−→v
([s | i : v], (h1, O1), (h2, O2),H)

if i ∈/ owned (Γ\O1)


[v]=v′	j
(s, (h1, O1), (h2, O2),H) −−−Γ−,A−→ (s, (h1, O1), (h2, O2),H)	if (v, v ) ∈ h1

[v]:=v′	j
(s, (h1, O1), (h2, O2),H) −−Γ−,−A−→ (s, ([h1 | v : v ], O1), (h2, O2),H)	if v ∈ dom(h1)


(s, (h1, O1), (h2, O2),H)
−−Γ−,−A−→ (s, (h1\v, O1), (h2, O2),H)	if v ∈ dom(h1)



(s, (h1, O1), (h2, O2),H) −a−ll−o−c−(v−,−[v−0−,.−..−,v−n−→])
(s, (hj , O1), (h2, O2),H)

if {v,...,v + n}∩ dom(h1 · h2 · H)= {}, where hj
= [h1 | v : v0,...,v + n : vn]



(s, (h1, O1), (h2, O2),H) −−a−cq−→r
([s | r : 0], (h1 ∪ hr, O1 ∪ {r}), (h2, O2),H − hr)

if r ∈/
O1 ∪ O2, hr ⊆ H, (s, hr) |= inv (Γ T r)



(s, (h1, O1), (h2, O2),H)
−tr−y−→r
(s, (h1, O1), (h2, O2),H)	if r ∈ O1 ∪ O2



(s, (h1, O1), (h2, O2),H) −r−el−→r
([s | r : 1], (h1 − hr, O1 − {r}), (h2, O2),H ∪ hr)

if r ∈ O1, hr ⊆ h1, (s, hr) |= inv (Γ T r)

Fig. 2. Local enabling relations

For each action λ we define a partial relation

−−−λ→ ⊆ ΣΓ × (ΣΓ ∪ {abort})



(s, (h1, O1), (h2, O2),H) −−i=−→v
abort	if i ∈/
owned (Γ T O1) ∪ A



(s, (h1, O1), (h2, O2),H) −i−:=−→v
abort	if i ∈ owned (Γ\O1)



[v]=v′
(s, (h1, O1), (h2, O2),H) −−−Γ−,A−→ abort	if v /∈ dom(h1)


[v]:=v′
(s, (h1, O1), (h2, O2),H) −−Γ−,−A−→ abort	if v ∈/
dom(h1)



(s, (h1, O1), (h2, O2),H)
−−Γ−,−A−→ abort	if v /∈ dom(h1)


(s, (h1, O1), (h2, O2),H) −r−el−→r  abort	if ∀hj ⊆ h1. (s, hj) |= ¬inv (Γ T r)


(s, (h1, O1), (h2, O2),H) −a−b−o−r→t
abort


Fig. 3. Local enabling relations

reflecting execution of action λ by the process, describing when this action is en- abled, and its effect on ownership of heap and resources. Such an action is only legal if it respects the ownership discipline and maintains the separation properties. An abort result indicates an action that breaks the rules. Note that we assume throughout that dom(s) contains all variables read or written by the process or its environment. The definitions for these local enabling relations are given in Figures 2 and 3.
It is easy to check that the local enabling relations are well defined, in that whenever σ ∈ ΣΓ and σ −−−λ→ σj /= abort , it follows that σj ∈ ΣΓ.
The following lemma summarizes some obvious, but useful, properties.


Lemma 9.2
If (s, (h1, O1), (h2, O2),H) −−−λ→ (sj, (hj , Oj ), (hj , Oj ),Hj), then hj

= h2, Oj =

Γ,A
1	1	2	2	2	2

O2, O1 ===λ⇒ Oj , and sj agrees with s except on writes(λ) ∪ res(λ).
O2	1
If s1 and s2 agree on free(λ) then (s1, (h1, O1), (h2, O2),H) −−−λ→ abort if and only
if (s2, (h1, O1), (h2, O2),H) −−−λ→ abort
If s1 and s2 agree on free(λ) and

(s1, (h1, O1), (h2, O2),H) −−−λ→ (sj , (hj , Oj ), (h2, O2),Hj),

Γ,A
1	1	1

there is a store sj
such that sj
agrees with sj
on writes(λ) ∪ res(λ) and

(s2, (h1, O1), (h2, O2),H) −−−λ→ (sj , (hj , Oj ), (h2, O2),Hj).

Γ,A
2	1	1

By interchanging the rˆole of process and environment we obtain the dual no- tion of an environment move, and we formalize the notion of an environment that respects Γ and does not modify the variables in A.
Definition 9.3 We define ~Γ,A ⊆ ΣΓ × ΣΓ by
(s, (h1, O1), (h2, O2),H) ~Γ,A (sj, (h1, O1), (hj , Oj ),Hj)
2	2
μ	j
iff there is an action μ such that writes(μ) ∩ A = {}, O2 ===⇒ O2, and
1

(s, (h2, O2), (h1, O1),H) −−−μ→ (sj, (hj , Oj ), (h1, O1),Hj).
Γ,A	2	2


We then define
==λ=⇒ = (~Γ,A)∗ ◦ (−−−λ→) ◦ (~Γ,A)∗.

Γ,A	Γ,A
These relations extend to traces in the obvious way, by composition. In partic- ular, when α is λ1 ... λn,
==α=⇒ = ==λ=1⇒ ◦···◦ ==λ=n⇒

Γ,A
Γ,A
Γ,A

where we interpret relational composition from left to right, i.e.
f ◦ g = {(σ, σjj) | ∃σj. (σ, σj) ∈ f & (σj, σjj) ∈ g}.

Since command traces respect resources, and environment moves do not modify variables in the rely set, we obtain the following result, expressing these properties in semantic terms.
Lemma 9.4
If α ∈ [[c]] and (s, (h1, O1), (h2, O2),H) ==α=⇒ (sj, (hj , Oj ), (hj , Oj ),Hj), then Oj =

Γ,A
O1, and sj agrees with s on writes(α) ∩ A.
1	1	2	2	1

The following result connects the effects of an action on a local state with its effect on the corresponding global state, as in the Local/Global Connection Theorem of [3].
Lemma 9.5

If (s, h)
=⇒λ
abort and (s, (h1, O1), (h2, O2),H) ∈ ΣΓ with h = h1 · h2 · H, then

(s, (h1, O1), (h2, O2),H) −−−λ→ abort.
If (s, (h1, O1), (h2, O2),H) −−−λ→ (sj, (hj , Oj ), (h2, O2),Hj),
Γ,A	1	1

then (s, h1 · h2 · H)
=⇒λ
(sj, hj · h2 · Hj).

Note that the first result holds for any ownership partition of resources and heap, for any global state (s, h). The second result specifies a particular ownership partition of the global state.
Validity, made formal
We can now offer a formal definition of validity for an assertion Γ ▶A {p}c{q}, expressed in terms of the semantics and local enabling relations. This makes precise the informal characterization given earlier; we now have a semantic formalization of “interactive execution in an environment that respects Γ and does not modify A”. The definition enforces implicitly the requirement that c preserves the invariants (separately), in any environment that preserves the invariants (separately), because of the separation property built into local states in ΣΓ.
Definition 10.1 The assertion Γ ▶A {p}c{q} is valid iff, for all traces α ∈ [[c]], and all local states σ = (s, (h1, O1), (h2, O2),H) ∈ ΣΓ with dom(s) ⊇ owned (Γ) ∪ A,
if (s, h1) |= p then

¬(σ
if σ
==α=⇒ abort )
Γ,A
==α=⇒ (sj, (hj , O1), (hj , O2),Hj), then (sj, hj ) |= q.

Γ,A	1	2	1
Soundness
As usual, soundness of the inference rules follows from the property that the rules preserve validity: For all well-formed instances of each inference rule, if the premisses are valid and the side conditions hold, then the conclusion is valid. The proof is a rule-by-rule case analysis, mostly as in [3] but augmented with the use and manipulation of rely sets. We summarize the main steps in showing soundness of the Parallel rule, and the rule dealing with local resources.
The following Parallel Decomposition Lemma is the key to the Parallel rule. Again, it is obtained by augmenting the analogous lemma from [3], and the rely sets play a crucial rˆole here in the technical justification.
Theorem 11.1 Let mod (α1)∩A2 = mod (α2)∩A1 = {}, free(α1) ⊆ owned (Γ)∪A1, and free(α2) ⊆ owned (Γ) ∪ A2. Let O1 ∩ O2 = {} and α ∈ α1 O1  O2 α2. Let σ = (s, (h, O), (h3, O3),H) ∈ ΣΓ and h = h1 · h2,O = O1 · O2,A = A1 ∪ A2. Let σ1 = (s, (h1, O1), (h2 · h3, O2 · O3),H) and σ2 = (s, (h2, O2), (h1 · h3, O1 · O3),H).

If σ
==α=⇒ abort, then σ
Γ,A
==α=1=⇒ abort or σ2
Γ,A1
==α=2=⇒ abort.
Γ,A2

If σ
==α=⇒ (sj, (hj, Oj), (hj , Oj ),Hj), then σ1
==α=1=⇒ abort, σ2
==α=2=⇒ abort, or

Γ,A	3	3
Γ,A1
Γ,A2

there are hj , hj , Oj , Oj such that Oj ∩ Oj = {}, Oj = Oj · Oj , hj = hj · hj , and
1	2	1	2	1	2	1	2	1	2
σ1 ==α=1=⇒ (sj, (hj , Oj ), (hj · hj , Oj · Oj ),Hj)

Γ,A1
1	1	2	3	2	3

σ2 ==α=2=⇒ (sj, (hj , Oj ), (hj · hj , Oj · Oj ),Hj).

Γ,A2
2	2	1	3	1	3

Proof: by induction on the length of α.	(End of Proof )
Corollary 11.2 If Γ ▶A1 {p1}c1{q1} and Γ ▶A2 {p2}c2{q2} are well-formed and valid, and mod (c1) ∩ A2 = mod (c2) ∩ A1 = {}, then
Γ ▶A1∪A2 {p1 ∗ p2}c1  c2{q1 ∗ q2}
is valid.
This shows soundness of the parallel rule.
For dealing with local resource blocks of form resource r in c we need the following lemma.
Theorem 11.3
If (s, (h1 · h, O1), (h2, O2),H) ∈ ΣΓ, (s, h) |= R, free(R) ⊆ X,
and r ∈/  dom(Γ), then ([s | r : 1], (h1, O1), (h2, O2),H · h) ∈ ΣΓ,r(X):R.
β\r
If r /∈ dom(Γ), (s, (h1 · h, O1), (h2, O2),H) ======⇒ abort, and β ∈ [[c]][r:1], then

β
([s | r : 1], (h1, O1), (h2, O2),H) ===========⇒ abort.
(Γ,r(X):R),A
If ([s	|	r	:	1], (h ,O ), (h ,O ),H · h)	β


([sj	|	r	:

1	1	2	2
===========⇒
(Γ,r(X):R),A

, (hj , Oj ), (hj , Oj ),Hj), (s, h) |= R, and β ∈ [[c]]	, there is a heap hj ⊆

1	1	2	2
j	j	j
[r:1]
β\r	j	j

H such that (s ,h ) |= R and (s, (h1 · h, O1), (h2, O2),H)
======⇒
Γ,A∪X
(s , (h1 ·

hj, Oj ), (hj , Oj ),H − hj).
1	2	2
We then obtain soundness for the Local Resource rule.
Lemma 11.4 Suppose Γ, r(X) : R ▶A {p}c{q} is valid and well-formed, so r /∈
dom(Γ) and free(R) ⊆ X. Then Γ ▶A∪X {p ∗ R}resource r in c{q ∗ R} is valid.
Proof: Let σ = (s, (h1 · h, O1), (h2, O2),H) be a local state for Γ with (s, h1) |= p
and (s, h) |= R, so that (s, h1 · h) |= p ∗ R. Let α ∈ [[c]][r:1].
α\r
If σ ======⇒ abort then there is a local computation of form
Γ,A∪X
(s, (h1, O1), (h2, O2),H · h) =======α====⇒ abort.
(Γ,r(X):R),A
But this would contradict validity of the premiss, since (s, h1) |= p.
Now suppose

α\r
j	jj
j	j	j

σ ======⇒ (s , (h , O ), (h , O ),H ).
Γ,A∪X
Then there must be heaps hj , hj such that hjj = hj · hj, (sj, hj) |= R, hj ⊥ Hj, and
1	1	1
(s, (h1, O1), (h2, O2),H · h) =======α====⇒ (sj, (hj , O1), (hj , Oj ),Hj · hj).
(Γ,r(X):R),A	1	2	2
By validity of the premiss and the assumption that (s, h1) |= p, it follows that (sj, hj ) |= q. Hence (sj, hjj) |= q ∗ R, as required.	(End of Proof )
1	1

Provable programs are fault-free
Theorem 12.1 If Γ ▶A {p}c{q} is valid, then every ﬁnite execution of c from a global state satisfying p∗inv (Γ) is race-free, and ends in a state satisfying q∗inv (Γ).
Proof: Suppose Γ ▶A {p}c{q} is valid, and let (s, h) be a global state satisfying
p ∗ inv (Γ). Let s = h1 · H with (s, h1) |= p and (s, H) |= inv (Γ). Let α ∈ [[c]]. If

(s, h)
=α⇒ abort , then (s, (h1, {}), ({}, {}),H)
==α=⇒ abort . But this would contradict
Γ,A

validity, so there must be sj, hj such that (s, h)
=α⇒ (sj, hj).

By assumption, (s, (h1, {}), ({}, {}),H) is a local state for Γ, in which all resources are available. A global computation of c, without interference, from (s, h) corre- sponds to a local computation of c from (s, (h1, {}), ({}, {}),H) in which the envi-
ronment steps are trivial. By validity, there must be hj ,Hj such that hj = hj · Hj,

α	j	j
1	1
j	j	j

(s, (h1, {}), ({}, {}),H)
===⇒ (s , (h , {}), ({}, {}),H ), and (s , h ) |= q. (A trivial
Γ,A

environment obeys the rely constraint vacuously.) Moreover, since this local com-
putation produces a legal local state for Γ, we must also have (sj,Hj) |= inv (Γ). Thus (s, hj) |= q ∗ inv (Γ), as required.	(End of Proof ) Special case:
When c has no free resource names, and ▶A {p}c{q} is valid, the conventional partial correctness assertion {p}c{q} is valid, and c is race-free from all states satisfying p.

Further extensions
Our inference rules include a Frame rule [6] as in the original CSL. This rule allows the “framing on” (by separate conjunction) of an additional formula in the pre- and post-condition of an assertion, provided the formula does not mention any variable written by the program. It is natural to ask whether there is an analogous rule that permits framing inside resource invariants. Our semantic investigation into the revised logic suggests the following new rule, which we call Invariant Framing:


	Γ, r(X): R ▶A {p}c{q}	
Γ, r(X ∪ Xj): R ∗ Rj ▶A {p}c{q}
if mod (c) ∩ Xj = {} and free(Rj) ⊆ Xj


Of course this rule can be used repeatedly to deal with multiple resources at a time. Together with the Parallel rule, this would allow the following Parallel Framing rule to be derived:
Γ, r(X1): R1 ▶A1 {p1}c1{q1}	Γ, r(X2): R2 ▶A2 {p2}c2{q2}

provided mod (c1) ∩ (A2 ∪ X2)= {} and mod (c2) ∩ (A1 ∪ X1)= {}. This rule has a pleasing symmetry.

Conclusions
We have presented a revised formulation of Concurrent Separation Logic, using assertions annotated with rely sets, and sketched the details behind a proof of soundness for this logic, based on an action trace semantics. This repairs a defect hidden inside our earlier version of CSL, in response to a counterexample found by Wehrman and Berdine [12]. At the same time we have been able to weaken the syntactic constraints imposed on shared variable use in Owicki-Gries and adopted without change in the original CSL. As a benefit of this generalization, the new CSL can handle programs in which shared variables are protected by multiple resources, and the new rules require that a program must acquire all protecting resources before writing a shared variable and must acquire some protecting resource before reading a shared variable.
It should be straightforward to adapt the semantic framework and technical de- velopment to incorporate permissions as in [4], using a permission algebra (P, ⊕, T) as in [1], and working with permissive stores S = Ide ~fin Vint × P and heaps H = Loc ~fin Vint × P. A global state would then be representable “locally” as a tuple (σ1, σ2,τ ) of compatible state portions, where σ1 represents the local state of the process, σ2 the local state of the environment, and τ the state belonging to available resources. We believe that this would offer a way to show soundness of Uday Reddy’s logic [9] based on syntactic control of interference, in which permis- sions are used statically. We plan to explore the connections between Reddy’s logic and the revised CSL, in future work; it seems likely that a provable assertion in our logic corresponds to a multitude of alternative assertions in Reddy’s logic, differing only in the choice of permission attached to identifiers used by the program.
Acknowledgement
This work was supported by the NATIONAL Science Foundation (NSF) No. 1017011.

References
R. Bornat, C. Calcagno, P. W. O’Hearn, and M. Parkinson. Permission accounting in separation logic. POPL 2005, SIGPLAN Notices, 40(1), 259-270.
J. Boyland. Checking interference with fractional permissions. Proc. 10th Symposium on Static Analysis,
R. Cousot, editor. Springer LNCS vol. 2694, pp. 55-72, 2003.
S. Brookes. A semantics for concurrent separation logic. Invited paper, CONCUR 2004, London. Springer LNCS 3170, August 2004. Journal version in: Theoretical Computer Science, 375(1-3), May 2007.
S. Brookes. Variables as Resource for Shared-Memory Programs: Semantics and Soundness. MFPS 2006, Genova, Italy. ENTCS, Volume 158, 123-150. May 2006
C.A.R. Hoare, Towards a Theory of Parallel Programming. In Operating Systems Techniques, C.
A. R. Hoare and R. H. Perrott, editors, pp. 61-71, Academic Press, 1972.


P. W. O’Hearn. Resources, Concurrency, and Local Reasoning. Invited paper, CONCUR 2004, London. Springer LNCS 3170, pp. 49-67, August 2004. Journal version in: Theoretical Computer Science, 375(1- 3), 271-307, May 2007.
S. Owicki and D. Gries, Verifying properties of parallel programs: An axiomatic approach, Comm. ACM. 19(5):279-285, May 1976.

D. Park. On the semantics of fair parallelism. In: Abstract Software Specifications, Springer-Verlag LNCS vol. 86, 504–526, 1979.
U.	Reddy.	Syntactic Control of Interference for Separation Logic. Talk presented at MFPS 2011, Pittsburgh, May 2011. A preliminary version is available at http://www.cs.bham.ac.uk/ udr/papers/sci-seplogic.pdf.
J.C. Reynolds, Separation logic: a logic for shared mutable data structures, Invited paper. Proc. 17th IEEE Conference on Logic in Computer Science, LICS 2002, pp. 55-74. IEEE Computer Society, 2002.
J, C. Reynolds. Invited Talk, MFPS 2011. Pittsburgh, May 2011.
I. Wehrman and J. Berdine. Private communication. January 2011.
