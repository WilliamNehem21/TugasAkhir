Electronic Notes in Theoretical Computer Science 180 (2007) 71–89	
www.elsevier.com/locate/entcs

On the Expressiveness of Timed Coordination via Shared Dataspaces
Isabelle Linden and Jean-Marie Jacquet1
Institute of Informatics University of Namur Namur, Belgium

Abstract
Since Linda, many differents coordination models using shared dataspaces have been developped. However, a few only have incorporated the notion of time. This paper builds upon previous work to study the expressive power of two families of timed coordination models based on shared dataspaces. The first one relies on Linda’s communication primitives whereas the second relies on the more general notion of multi-set rewriting, incorporated, for instance, in Gamma. We analyse the expressiveness increase provided by the primitives in each of the two families and also compare the expressiveness power of the two families.
Keywords: Expressiveness, Shared dataspaces, Timed coordination


Introduction
As motivated by the constant expansion of computer networks and illustrated by the development of distributed applications, the design of modern software systems centers on re-using and integrating software components. This induces a paradigm shift from stand-alone applications to interacting distributed systems, which, in turn, naturally calls for well-defined methodologies and tools aiming at integrating heterogeneous software components. One of these tools consist of coordination languages and models, which, following Gerlernter’s Linda ([10]) proposal, have advocated the interest of clearly separating interactional and the computational aspects of software components.
In Linda, communication between agents does not cope with time. However, data rarely has an eternal life and most of services have to be provided in a bounded amount of time. For exemple, a request at a bank machine has to be satisfied in a reasonable amount of time. Moreover, time is considered as critical in areas such as

1 Email: ili,jmj@info.fundp.ac.be

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.10.047

traffic control and telecommunication switches. Finally, industrial proposals such as TSpaces and JavaSpaces have incorporated time constructs.
In our recent work [14,13], we have studied the introduction of time in Linda- like models in four differents ways, by using two notions of time, relative time and absolute time, and, for each notion, two types of features: delay mechanism and explicit deadlines on the validity of tuples and on the duration of suspension of communication operations. In addition to the description of the language prim- itives, elementary expressiveness results have been presented and implementation techniques have been detailed.
In this paper, we extend our study to the introduction of time in multiset based coordination languages. To that end, we shall only consider time in a relative manner. Following previous work, we shall use the so-called two-phase functioning approach to real-time systems illustrated by languages such as Lustre ([7]), Esterel ([2]) and Statecharts ([11]). This approach may be described as follows. In a first phase, elementary actions of statements are executed. They are assumed to be atomic in the sense that they take no time. Similarly, composition operators are assumed to be executed at no cost. In a second phase, when no actions can be reduced or when all the components encounter a special timed action, time progresses by one unit. Although simple, this approach has been proved to be effective for modelling reactive systems.
To our best knowledge, this paper is the first one to propose a time extension to multiset based coordination languages and to study their expressiveness.
Related proposals for the introduction of time in coordination-like languages mainly fall in the category of relative time languages and for variants of Linda languages. For instance, [18] introduces time in the concurrent constraint setting 2 ([20]) by identifying quiescent points in the computation where no new information is introduced and by providing an operator for delaying computations by one unit. At each quiescent point of time, the dataspace is reinitialized to an empty content. The paper [19] extends this framework, on the one hand, by introducing a primitive for checking the absence of information and reacting on this absence during the same unit of time and, on the other hand, by generalizing the delay mechanism in an hence A construct which states that A holds at every instant after the considered time. The resulting languages are called tcc and tdcc.
The paper [23] has shown that the language tcc can embed one classical repre- sentative of the state oriented synchronous languages, namely Argos ([15]), and one representative of the declarative class of dataflow synchronous languages, namely Lustre ([7]).
De Boer, Gabbrielli, and Meo have presented in [3] a timed interpretation of concurrent languages by fixing the time needed for the execution of parallel tell and ask operations as one unit and by interpreting action prefixing as the next operator. A delay mechanism is presented in Oz ([22]), a language which combines object ori- ented features with symbolic computation and constraints, and, (relative) time-outs

2 Concurrent constraint languages may be viewed as a variant of Linda restricted to two communication primitives putting information of a dataspace and checking the presence of information on it

have been introduced in TSpaces ([24]) and JavaSpaces ([9]). A formal semantics of these time-outs and other mechanisms, different from our expressiveness study, is presented in [5].
Another piece of work on the expressiveness of timed constraint system is [17]. There, various extensions of the tcc languages have been studied: extension with replication and recursion static scoping. Decidability results are proved as well as several encodings, which are however not of the form of modular phased embeddings used in this paper.
Finally, [6] investigates the impact of various mechanisms for expired data col- lection on the expressiveness of coordination systems. However, the study is based on Random Access Machines, on ordered and unordered tells of timed data and on decidability results.
The rest of the paper is structured as follows. Section 2 introduces the two families of languages under study in the paper. Section 3 presents the framework for comparing the expressiveness of languages. To that end, we shall refine the notion of modular embedding proposed in [8] to our time context presented in phases. This will lead to the notion of phased-embedding. With these comparison tools, section 4 studies the expressive increasing provided by successive introduction of primitves tell, ask, get, nask and delay in each of the two families of languages. The two families are then compared in section 5. Finally, section 6 draws our conclusion.

The families of coordination languages
The families under study in this paper are described by first introducing the common syntax and rules, then by defining the family based on Linda like primitives and finally that based on multiset rewriting.
Common syntax and rules
We shall consider two families of languages R(X ) and M(X ) parameterised w.r.t. the set of communication primitives X . The set is in turn a subset of a general set of communication primitives depending on the family under consideration. Assuming this general set, all the languages use sequential, parallel, and choice operators (see “General rule” in figure 1), whose meaning is defined by the usual rules (S), (P), and
(C) in figure 2. There the configurations are of the form ⟨A | σ⟩ where A represents the agent under consideration and σ represents, the dataspace, subsequently called the store and which consists of a multiset of subscripted tokens.
As already said, we shall adopt the classsical two-phase functioning approach to real-time system. Accordingly, time needs to be taken into account explicitly in the transitions. This is achieved in two ways. First by the introduction of transition rules which define a transition relation ~ to express the progress of time by one unit. In fact, the → reduction is used to model the first phase of the two-phase functioning approach to real-time while the ~ relation is used to model the second phase of this approach. Second, as a result of the progress of time, delays under reduction, must be decreased by one unit.



Fig. 1. Comparative syntax of the languages.
A delay primitive is introduced in each family. As expected, the effect of delay(d) is to postpone the computation of d units of time. The resolution of delay(0) is described in rule (D).
The R family
The R family is based on Linda. Following our previous work, we shall use a slightly different modelling of the Linda primitives. We shall consider four primitives: tell to place a token on the store, ask to test the presence of a token, get to remove this token and nask to test the absence of a token. In our time setting, the effect of tell is additionnally a time to the token being told with the idea that the token will live for that amount of time. With respect to the other three primitives, the effect of time is to indicate the delay within which the request has to be satisfy.
Definition 2.1 Define Stoken as an enumerable set, the elements of which are called tokens and are typically represented by letters t and u. Define Sduration as the set composed of infinity, denoted ∞, and the positive integers. Elements of this set are subsequently called durations.
Definition 2.2 Define the set Srcom of time communication primitives as the one generated by the R rule of figure 1, where t ∈ Stoken and d are durations. Moreover, for any sybset X of Srcom, define the language R(X) as the set of agents generated



Fig. 2. Comparative semantics of the languages.
by the generale rules of figure 1 for C ∈ X .
For any X , computation in R(X) may be modelled by a transition system writ- ten in Plotkin’s style. To easily express termination, we shall introduce a special terminating symbol E. For uniformity, we shall abuse language and qualify E as an agent. However, to meet the intuitive expectation, we shall always rewrite agent of the form (E ; A), (E || A) and (A || E) as A. This is technicaly achieved by defining the extended set of agents as follows and by simplifying agents according to the bimonoid structure.
Definition 2.3 Define the extended set of agents Seagent by the following gram- mar
Ae ::= E | C | A ; A | A || A | A + A
Moreover, we shall subsequently assert that the structure (Seagent, E, ; , || ) is a bimonoid and simplify elements of Seagent accordingly.
Definition 2.4
Define the set of the stores Ststore as the set of the finite multisets of tokens of Stoken with duration as subscript.

Define the set of configurations Sconf as Seagent × Ststore. Configurations are denoted as ⟨A | σ⟩, where A is an (extended) timed agent and σ is a timed store.
When a temporal transition occures, agents and store content have to look older.
This is achieved by the A− and σ− constructions.
Definition 2.5
Given an agent A ∈ R(X), we denote by A− the agent defined inductively as follows: 3


telld(t)− = telld(t) askd(t)− = askmax{0,d−1}(t)
naskd(t)− = naskmax{0,d−1}(t)
getd(t)− = getmax{0,d−1} (t) delay(d)− = delay(d − 1)


(B ; C)− = B− ; C
(B || C)− = B− || C−
(B + C)− = B− + C−

Given a timed store σ, we denote by σ− the new store obtained by decreasing the duration associated with the tokens by one unit and by removing those associated in σ with 1 unit of time: precisely, if all the notations are understood to relate to multi-sets: σ− = {td−1 : td ∈ σ, d > 1}
The operational semantics is defined by means of the transition relations → and
~ describing the two phase approach. These transition relations are defined by the transition rules in figure 2.
Rule (Tr) states that the primitive telld(t) can be executed in any store σ, and that its execution results in adding the token t with duration d as subscript to the store σ. Rule (T0) states that telling a token for a zero duration succeeds without updating the store. The three others primitives are computable only for a stricly positive duration. Rules (Ar) and (Nr) state respectively that the atomic agents askd(t) and naskd(t) can be executed in any store containing the token t and not containing t, and that their execution does not modify the current store. Rule (Gr) also states that the agent getd(t) acts similarly to the agent askd(t) but deletes one occurrence of t from the store. Note that the symbol ∪ actually denotes multiset union.
In order to avoid that the computation infinitely tries to decrease blocked non- delay primitives, rule (W) requires that some progress can be made, namely that the agent A progresses, ie A− differs from A, or that the store progresses, ie σ− differs from σ.
The operational semantics is obtained by the integration of the two phase- relations in one relation.

3 We extend classical arithmetic on natural numbers by ∞− 1= ∞.

Definition 2.6
Let δ+ and δ− be two fresh symbols denoting respectively success and failure. Define the set of final states Sfstate as the set Ststore × {δ+, δ−}.
Let '→ be the relation defined by ⟨A | σ⟩ '→ ⟨B | τ ⟩ iff ⟨A | σ⟩ → ⟨B | τ ⟩ or
⟨A | σ⟩ ~ ⟨B | τ ⟩.
Define the operational semantics Or : R(Srcom) → P(Sfstate) as the follow- ing function: For any timed agent A,
Or(A)= {(σ, δ+): ⟨A | ∅⟩ '→∗ ⟨E | σ⟩}
∪ {(σ, δ−): ⟨A | ∅⟩ '−→∗ ⟨B | σ⟩ /'→,B /= E}

The M family
The transition rules (T r), (Ar), (Nr), and (Gr) suggest an alternative view of Linda- like communication primitives in terms of which conditions the current store should obey to allow the transitions to occur and which modifications these transitions make on the store.
A natural dual view of communication primitives is then to consider them as the rewriting of pre-conditions into post-conditions. We shall consequently examine, as a second family, languages based on multi-set rewriting. It is here worth noting that this approach has already been taken in [1,4,12,16].
Each communication primitive thus consists of a multi-set of pre-conditions and of a multi-set of post-conditions. Pre- and post-conditions are (possibly empty) multi-sets of positive and negative tuples. Intuitively speaking, the operational effect of a multi-set rewriting (pre, post) is to insert all positive post-conditions and to delete all negative post-conditions from the current store σ, provided that σ contains all positive pre-conditions and does not contain any of the negative pre- conditions.
Time is introduced in this framework by associating pre and post sets with durations. The duration associated with the pre-condition indicates the delay within which the request has to be satisfy and the duration associated to the post-condition will be used as subscript for the tokens added to the store by the rewriting. For instance, the operational effect of the multi-set rewriting ({+r, −s, +t}2, {+u, −t}3) is to add u3 and delete t from the store σ provided that σ, in the current form or the one after one clock tick, contains r and t and does not contain s.
Given a multi-set rewriting (pred, postd' ) we shall denote by pre+ the multi-set
{t | +t ∈ pre} and by pre− the multi-set {t | −t ∈ pre}. The denotations post+
and post− are defined analogously.
A multi-set rewriting (pred, postd' ) is consistent iff pre+ ∩ pre− = ∅. A multi-set rewriting (pred, postd' ) is valid if post− ⊆ pre+, where ⊆ denotes multi-set inclusion.
Definition 2.7 Define the set of multi-set communication primitives Smscom as the set of C’s engendered by the M rules of figure 1. On the point of notation, λ is used there to denote the empty sequence.

Given a subset X of Smscom, define the language M(X ) as the set of the consistent and valid A’s generated by the general rule of figure 1.
As a result of restricting to consistent and valid multi-set communication prim- itives, four basic pairs of pre and post-conditions are only possible: ({+t}d, {}d' ), ({−t}d, {}d' ), ({}d, {+t}d' ), ({+t}d, {−t}d' ). We shall respectively identify them to askd(t), naskd(t), telld' (t), and getd(t).
For our comparison purposes, given X a subset of communication primitives of Srcom, we shall abuse notations and denote by M(X ) the language obtained by restricting multi-set rewriting pairs to component-wise multi-set unions of pairs as- sociated with the communication primitives of X . For instance, if X = {ask, nask}, then the language M(X ) only involves pairs of the form (Pred, {}d' ) where Pre may contain positive and negative tokens. Similarly, if X = {tell, get} then M(X ) in- cludes only pairs of the form (Pred,Postd' ) where Pre contains positive tokens only provided that each one is associated with one negative counterpart in Post and Post contains negative tokens provided each one is associated to one positive token in Pre as well as positive tokens (without restriction). Note that these notations fully agree with the one introduced in definition 2.7.
As in the case of the R family, the extention of the set of the agents with the termminating symbol E turns the structure (M(X ) ∪ {E}, E, ; , || ) into a bimonoid.
Similarly to definition 2.5, one has to define the transformation of an agent after one clock tick. This is achieved as follows.
Definition 2.8 Let A be an agent of M. We denote by A− the agent defined inductively as follows:

(pred, postd' )− = (premax{0,d−1}, postd' )
delay(d)− = delay(d − 1) (B ; C)− = B− ; C
(B || C)− = B− || C−
(B + C)− = B− + C−

Pre-conditions do not care about the duration of the tokens on the store. They are only concerned with the presence or absence of some token. In order to capture this in the formalization of the rewriting transition, we introduce the following notation.
Definition 2.9 Let σ denote any store of Ststore. We denote by σ∗ the set of the tokens of σ without their subscript.
The transition rules used in order to define the operational semantics of the M family of languages are provided by the general rules of figure 2 together with rules (CM) and (W) of that figure.

Rule (CM) states that a multi-set rewriting (pred, postd' ) can be executed in a store σ if the multi-set pre+ is included in σ∗ and if no negative pre-condition occurs in σ∗. If these conditions hold and if duration d is strictly positive, then the execution of the rewriting deletes, from σ, all the negative post-conditions, and adds, to σ, all the positive post-conditions with duration d' as subscript. The transition in rule (CM0) can be fired in similar conditions but with d' = 0. In this case, negative postconditions are deleted from the store but no tokens is added.
Definition 2.10 Define the operational semantics Om : M(Smscom) → P(Sfstate) as the following function: for any timed agent A,
Om(A)= {(σ, δ+): ⟨A | ∅⟩ '→∗ ⟨E | σ⟩}
∪ {(σ, δ−): ⟨A | ∅⟩ '→∗ ⟨B | σ⟩ /'→,B /= E}

Normal Form
A classical result of concurrency theory is that modelling parallel composition by interleaving, as we do, allows agents to be considered in a normal form. We first define what this actually means, and then state the proposition that agents and their normal forms are equivalent in the sense that they yield the same computations.
Definition 2.11 Given a subset X of Srcom or Smscom, the set Snagent of agents in normal form is defined by the following rule, where N is an agent in normal form and c denotes a communication action of X :
N ::= c | c ; N | N + N.
Proposition 2.12 For any agent A, there is an agent N in normal form which has the same derivation sequences as A.

Language comparison
Introduction
A natural question to ask is whether the timed multi-set rewriting extension we just introduced strictly increases the expressivity of languages of the R family and, if so, whether some of the timed primitives may be expressed in terms of others.
A basic approach to answer that question has been given by Shapiro in [21] as follows. Consider two languages L and L'. Assume given the semantics mappings (observation criteria) S : L → Obs and S' : L' → Obs', where Obs and Obs' are some suitable domains. Then, according to [21], L can embed L' if there exists a mapping C (coder) from the statements of L' to the statements of L, and a mapping De (decoder) from Obs to Obs', such that De(S(C(A))) = S'(A), for every statement A ∈ L'. This approach is however too weak since, for instance, the above equation is satisfied by any pair of Turing-complete languages. To circumvent this problem, De Boer and Palamidessi have proposed in [8] to add three constraints on the coder C and on the decoder De. First, De should be defined in an element-wise way w.r.t.

⟨A | ∅⟩ →∗ ⟨A1 | α1⟩ ~ ⟨A' | α' ⟩ →∗ ... →∗ ⟨An | αn⟩ /'→
C	De  C	De
⟨B | ∅⟩ →∗ ⟨B1 | β1⟩ ~ ⟨B' | β' ⟩ →∗ ... →∗ ⟨Bn | βn⟩ /'→
1	1

Fig. 3. Phased embedding.


Obs:
∀X ∈ Obs : De(X)= {Deel(x) | x ∈ X}	(P1)

for some appropriate mapping Deel. Second, the coder C should be defined in a compositional way w.r.t. the sequential, parallel and choice operators: 4


C(A ; B)= C(A); C(B)
C(A || B)= C(A) || C(B)
C(A + B)= C(A) + C(B)

(P2)

Finally, the embedding should preserve the behavior of the original processes w.r.t. deadlock, failure and success (termination invariance):
∀X ∈ Obs, ∀x ∈ X : tm'(Deel(x)) = tm(x)	(P3) where tm and tm' extract the information on termination from the observables of L
and L', respectively. An embedding satisfying these properties (P1, P2, P3) is said to be modular.
Phased embedding
In our time context, we introduce an additional requirement associated with time. Intuitively, we require that statements and their codings obey the commuting equa- tion De(S(C(A))) = S'(A) after each phase, thus giving rise to the situation depicted in figure 3. A modular embedding satisfying this constraint is called modular phased embedding. The formal definition is as follows. It is phrased directly in our time coordination setting.
Definition 3.1 Define the semantics O∗ as a generalisation of the semantics Or or Om to arbitrary starting store but restricted to one phase: for any agent A and any store α,
O∗(A)(α)= {(σ, δ+): ⟨A | α⟩ →∗ ⟨E | σ⟩}
∪ {(σ, δ−): ⟨A | α⟩ →∗ ⟨A' | σ⟩ /→, A' /= E}
Definition 3.2 For any agents A and B and any stores α and β, ⟨B | β⟩ is decod- able in ⟨A | α⟩ iff

4 Actually, this is only required for the parallel and choice operators in [8].

C(A)= B where the coder C is extended with C(E)= E.
⎧⎨ δ+ if A = E = B

Deel((β, δ)) = (α, δ) where δ =
⎩ δ− otherwise

Definition 3.3 Assume a coder C and a decoder De. For any agents A, B, any store α, β, (A, α) is phase-simulable in (B, β) iff the following properties hold:
⟨B | β⟩ is decodable in ⟨A | α⟩
for any agent A1 and any store α1 such that ⟨A | α⟩ →∗ ⟨A1 | α1⟩ /→, there exist B1 and β1 such that ⟨B | β⟩ →∗ ⟨B1 | β1⟩ /→ and ⟨B1 | β1⟩ is decodable
in ⟨A1 | α1⟩; moreover ⟨A1 | α1⟩ ~ ⟨A' | α' ⟩ iff ⟨B1 | β1⟩ ~ ⟨B' | β' ⟩ and
1	1	1	1
(A' , α' ) is phase-simulable in (B' , β' ).
1	1	1	1
for any agent B1 and any store β1 such that ⟨B | β⟩ →∗ ⟨B1 | β1⟩ /→, there exist A1 and α1 such that ⟨A | α⟩ →∗ ⟨A1 | α1⟩ /→ and ⟨B1 | β1⟩ is decodable
in ⟨A1 | α1⟩; moreover ⟨A1 | α1⟩ ~ ⟨A' | α' ⟩ iff ⟨B1 | β1⟩ ~ ⟨B' | β' ⟩ and
1	1	1	1
(A' , α' ) is phase-simulable in (B' , β' ).
1	1	1	1
Definition 3.4 [Modular phased embedding] Let L and L' be two languages of the

families R, M, and let Ox and O'
denote their corresponding operational semantics.

The language L can embed L' in a modular and phased manner iff there exists a coder C (coder) from the statements of L' to the statements of L, and a decoder De

(decoder) from Ox to O'
such that properties (P1), (P2), (P3) hold and such that

for any agent A of L', (A, ∅) is phase-simulable in (C(A), ∅).
The existence of a modular phased embedding from L' into L is subsequently denoted by L' ≤ L. It is easy to see that ≤ is a pre-order relation. Moreover if L' ⊆ L then L' ≤ L, that is, any language embeds all its sublanguages. This property descends immediately from the definition of modular phased embedding, by setting C and De equal to the identity function.

Intra family comparisons
The hierarchy of the languages with relative duration
The complete study of the relation between the 16 languages of the R family without delay has been operated in [14]. For the purpose of this present paper, let us just recall the following result.
Proposition 4.1
R(tell) < R(ask, tell) < R(ask, get, tell) < R(ask, nask, get, tell)
Let us now consider the introduction of the delay primitive. Obviously, the extended language embeds its sublanguage. However, this embedding is strict.
Proposition 4.2 R(ask, nask, get, tell) < R(ask, nask, get, tell, delay)
Proof.

By contradiction, assume that there is a coder C and decoder Ðe provided by the definition 3.4. By the phased embedding property, the coding of the agent delay(0) succeeds at time 1.
Let us now consider the agent delay(1). By the phased embedding property, the coding of delay(1) succeeds at time 2. It is easy to observe that the first step of any such computation corresponds to the execution of a telld(t) or naskd(t) primitive on the empty set and thus is not a temporal step. Any computation can then be represented as follow.
⟨C(delay(1)) | ∅⟩1 → ⟨C' | σ⟩1 →∗ ⟨C'' | τ ⟩1 ~ ⟨C(delay(0)) | τ −⟩2 →∗ ⟨E | μ⟩2
where Ðe((τ, δ+)) = (∅, δ+) and Ðe((μ, δ+)) = (∅, δ+).
As the first step is not a temporal transition, this gives, by definition of + , a valid prefix for a computation of the coding of the agent delay(0) + delay(1) that finishes at time 2. That contradicts the fact that, by the phased embedding property, any computation of this agent succeeds at time 1.	 

The hierarchy of the languages with multiset rewriting
The first results in the expressiveness study of the ł family come from language inclusion.
Proposition 4.3
ł(tell) ≤ ł(ask, tell) ≤ ł(ask, get, tell)
≤ ł(ask, nask, get, tell) ≤ ł(ask, nask, get, tell, delay)
Proof. It is sufficient to consider the identity as coder and decoder.	 
Let us now establish that these embeddings are strict.
Proposition 4.4
ł(ask, tell) /≤ ł(ask)
ł(ask, get, tell) /≤ ł(ask, tell)
ł(ask, nask, get, tell) /≤ ł(ask, get, tell)
ł(ask, nask, get, tell, delay) /≤ ł(ask, nask, get, tell)
Proof.

Consider the agent ({+a}1, {}1). Its operational semantics is given by 0m(({+a}1, {}1)) = {(∅, δ−)}. As any agent in ł(tell) has only successful com- putations, it is impossible to provide a coder and a decoder satisfying property P 3.
Assume that ł(ask, get, tell) ≤ ł(ask, tell) and that there is a coder C and decoder Ðe provided by the definition 3.4.  Consider the

agent ({}1, {+a}1) ;  ({+a}1, {−a}1).  Since C is compositional and since
0m(({}1, {+a}1)  ;  ({+a}1, {−a}1))  =  {(∅, δ+)},  the termination mark
of any element of 0m(C(({}1, {+a}1))  ;  C(({+a}1, {−a}1))) is success- ful.  As C(({+a}1, {−a}1)) is composed of rewriting with empty nega- tive postconditions, it does not destroy any element of the store.  As all the preconditions have empty negative part, it follows that any ele- ment of 0m(C(({}1, {+a}1))  ;  C(({+a}1, {−a}1)))  ;  C(({+a}1, {−a}1)))
has    a    successful    termination    mark.	However,
0m(({}1, {+a}1) ; ({+a}1, {−a}1) ; ({+a}1, {−a}1)) = {(∅, δ−)}, which con-
tradicts property P 3.
The third relation is also established by contradiction. Assume that ł(ask, nask, get, tell) ≤ ł(ask, get, tell) and that there is a coder C and decoder Ðe provided by the definition 3.4. Let us first consider the coding of the agent ({}1, {+a}1). As ({}1, {+a}1) succeeds without temporal transition on the empty store, the phased embedding property ensures that any computation of its coding is of the following type
⟨C(({}1, {+a}1)) | ∅⟩1 →∗ ⟨E | σ⟩1
with Ðe((σ, δ+)) = ({a1}, δ+).
Now consider C(({−a}1, {}1)). As it is in ł(ask, get, tell), its normal form can be written as
C(({−a}1, {}1)) = ({+a(1),... , +a(1), +b(1),... , +b(1) }d ,
1	n1	1	m1	1
{+c(1),... , +c(1), −b(1),... , −b(1) }e ); A1

1
+ ... +
l1	1
m1	1

({+a(i),... , +a(i), +b(i),... , +b(i) }d ,
1	ni	1	mi	i
{+c(i),... , +c(i), −b(i),... , −b(i) }e ); Ai
1	li	1	mi	i
Our first observation is that the coding can not contain any choice starting with an empty precondition. Indeed, if there is one choice starting with an empty precondition, i.e. there is some j such that nj = mj = 0, then the coding of the agent A = ({}1, {+a}1) ; (({}1, {+b}1) + ({−a}1, {}1)) accepts the following derivation
⟨C(A) | ∅⟩1 →∗ ⟨C(({}1, {+b}1) + ({−a}1, {}1)) | σ⟩1
→ ⟨Aj | σ ∪ τ ⟩1
where τ is the set of the tokens c(j)(1 ≤ k ≤ lj) with duration ej as subscript.
As ({−a}1, {}1) fails on the store containing a, the agent Aj has to fail. This derivation provides then a valid prefix for a failing derivation of the agent. This contradicts, by property P 3, the fact that A has only successful computations.
A second observation about C(({−a}1, {}1)) is that, following its normal form, its computation on the empty store fails or starts with a temporal transition.

This contradicts the phased embedding property. Indeed, following ({−a}1, {}1), C(({−a}1, {}1)) has to succeed at time 1 without any temporal transition.
The proof proceeds as for proposition 4.2 but with the first observation on the agent delay(1) modified as follows.
By the phased embedding property, the coding of delay(1) succeeds at time 2. As it succeeds on the empty store, the first step of any such computation corresponds to the execution of a rewriting (pred, poste) with d > 0 and pre+ and post− empty. Consequently, this first transition is not a temporal step.

Inter families comparisons

Proposition 5.1 For any set of communication primitives X , R(X ) ≤ ł(X )
Proof. Immediate by defining the decoder as the identity and the coder as follows:


C(telld(t)) = ({}1, {+t}d)
C(askd(t)) = ({+t}d, {}1) C(delay(d)) = delay(d)
C(getd(t)) = ({+t}d, {−t}1)
C(naskd(t)) = ({−t}d, {}1)


Proposition 5.2 R(tell) ≡ ł(tell)
Proof. The relation R(tell) ≤ ł(tell) has already been observed. Let us now consider the converse relation. As any agent of the two families has only successful computations at time 1, it is sufficient to consider the following coding


C(({}d, {t1,... , tn}d' )) = || n
telld' (ti)

and to use the identity as decoder.	 
Proposition 5.3
R(ask, tell) < ł(ask, tell)
R(tell, ask, get) < ł(tell, ask, get)
R(ask, nask, get, tell) < ł(ask, nask, get, tell)
R(ask, nask, get, tell, delay) < ł(ask, nask, get, tell, delay)
Proof. The four inclusions follow from proposition 5.1. The strict relations follow from the transitivity of ≤ and from the following result.	 
Proposition 5.4 ł(ask, tell) /≤ R(ask, nask, get, tell, delay)

Proof. By contradiction, assume that there is a coder C and decoder Ðe provided by definition 3.4.
Let us first observe that, for any token t, there are tokens x1, ··· , xm, y1, ··· , ym, stores σ, τ, α, α', β, β', and computations C1, C2, C3, C4 of

C = C(({}1, {+x1}1); ... ; ({}1, {+xm}1))
C ; C(({}1, {+t}1))
C ; C(({}1, {+y1}1); ... ; ({}1, {+yn}1))
C ; C(({}1, {+y1}1); ... ; ({}1, {+yn}1); ({}1, {+t}1))
respectively, such that
C2 is the continuation of C1 by one computation C∗ of C(({}1, {+t}1))
C4 is the continuation of C3 with C∗
C3 is the continuation of C1 with one computation of the coding agent
C(({}1, {+y1}1); ... ; ({}1, {+yn}1))
if σ and τ are the store resulting from the computations C1 and C3, then, the computations C2 and C4 respectively end in the stores σ ∪ α \ β and τ ∪ α' \ β'
α'∗ = α∗ and β'∗ = β∗.
Indeed, any computation of ({}1, {+t}1)) can be viewed as a sequence of ask, nask, get, tell and delay operations. Since the agent C(({}1, {+t}1))) is finite and, by property P 3 and the phased embedding property, has to succeed at time 1, there is only a finite set of such sequences. Moreover, for any set of distincts tokens z1, ··· , zp, any computation of
C(({}1, {+z1}1); ... ; ({}1, {+zp}1); ({}1, {+t}1)))
which is necessarily successful by property P 3, necessarily terminates by such a sequence, thanks to property P 2. In these conditions, progressively increasing the set of tokens zi neccessarily results in repeating a sequence, which establishes the claim.
To conclude, let us consider the normal form of C(X) for the agent X = ({+x1,... , +xm, +y1,... , +yn, +t}1, {}1). In its most general form, this normal form is written as
telld1 (t1); A1 + ··· + telldp (tp); Ap
+ aske1 (u1); B1 + ··· + askeq (uq); Bq
+ getf1 (v1); C1 + ··· + getfr (vr); Cr
+ naskg1 (w1); D1 + ··· + naskgs (ws); Ds
+ delay(h1); E1 + ··· + delay(hk); Ek

Let us first observe that there is actually no alternative guarded by a telldi (ti) primitive. Indeed, otherwise, the transition ⟨C(X) | ∅⟩1 → ⟨Aj | {(ti)di }⟩1 would be valid, which, as X has only one failing computation, can only be continued by failing computations. However, this transition then induces a failing computation for C(X) + C(({}1, {+t}1)), which is absurd by properties P 2 and P 3. Similarly, one can prove that there is no alternative guarded by a naskgi (wi) with gi > 0, or by a delay(0).
A second observation is that the tokens ui’s and vj’s do not appear in σ, τ and α. Formally, if U = {ui :1 ≤ i ≤ q and ei > 0} and V = {vi :1 ≤ i ≤ r and fi > 0}, then (U ∪ V ) ∩ (σ∗ ∪ τ ∗ ∪ α∗)= ∅. Indeed, it is sufficient to use the same argument as that just employ for the tell primitives by observing the three agents

({}1, {+x1}1); ... ; ({}1, {+xm}1); X,
({}1, {+x1}1); ... ; ({}1, {+xm}1); ({}1, {+t}1); X
({}1, {+x1}1); ... ; ({}1, {+xm}1); ({}1, {+y1}1); ... ; ({}1, {+yn}1); X

which only one failing computation. Let us finally consider the agent
Y = ({}1, {+x1}1); ... ; ({}1, {+xm}1); 
({}1, {+y1}1); ... ; ({}1, {+yn}1); ({}1, {+t}1); X.
The following computation prefix of its coder results from the above observations:
⟨C(Y ) | ∅⟩1 →∗ ⟨C(({}1, {+t}1); X) | τ ⟩1
→ ⟨C(X) | σ ∪ α' \ β'⟩1 /→
To conclude, we need to analyze two cases: either C(X)− = C(X) or not. Both cases will lead to absurdity. On the one hand, if C(X)− = C(X), no temporal tran- sition is possible and the previous computation prefix yields a failing computation for Y which is absurd by P 3. On the other hand, if C(X)− /= C(X), a tempo- ral transition occurs which, by the phased property, contradicts the fact that any computation of Y finishes at time 1.	 
We finally observe the following results.
Proposition 5.5
R(ask, get, tell) /≤ ł(ask, tell)
R(ask, nask, get, tell) /≤ ł(ask, get, tell)
R(ask, nask, get, tell, delay) /≤ ł(ask, nask, get, tell)
Proof.
The proof proceeds as for part (ii) of proposition 4.4 by considering the agents
tell1(a); get1(a) and tell1(a); get1(a); get1(a).

R(tell) ł(tell)

R(ask, tell)

R(ask, get, tell)	ł(ask, tell)

R(ask, nask, get, tell)	ł(ask, get, tell)

R(ask, nask, get, tell, delay)	ł(ask, nask, get, tell)

ł(ask, nask, get, tell, delay)

Fig. 4. families comparison
The proof proceeds as for part (iii) of proposition 4.4 by considering succes- sively the agents tell1(a), nask1(a) and tell1(a); (tell1(b) + nask1(a)).
The proof proceeds as for part (iv) of proposition 4.4.

Conclusion
This paper has studied the expressiveness of two timed extensions of coordination languages. Both are based on the two-phase functioning approach to real-time systems and incorporate relative time. The first family is based on a set of Linda like primitives while the second relies on multi-set rewriting, already employed in Gamma.
We have used the notion of modular phased embedding, introduced in our pre- vious work, to study the expressiveness increase provided by the primitives and to compare the two families of languages. The graph on figure 4 summerizes the results we have obtained. It is worth noting that only the main results of the figure have been established in the paper. Other results are direct consequence of the transitivity of the embeddings.
On the point of graphical representation, languages on the same node of the graphs embed each other in a strong modular phased way. An arrow from a language L1 to a language L2 means that L2 strictly embeds L1 in a modular phased manner,

that is L1 ≤ L2 but that the converse modular phased embedding relation does not hold, L2 /≤ L1. Excepted for the relations directly induced by the transitivity of the embeddings, the absence of arrow between two languages means that there is no modular phased embedding between these languages.

References
J. Banatre and D. LeMetayer. Programming by Multiset Transformation. Communications of the ACM, 36(1):98–111, 1991.
G. Berry and G. Gonthier. The Esterel Synchronous Programming Language: Design, Semantics, Implementation. Science of Computer Programming, 19, 1992.
F.S. De Boer, M. Gabbrielli, and M.C. Meo. A Timed Concurrent Constraint Language. Information and Computation, 161(1):45–83, 2000.
A. Brogi and J.-M. Jacquet. On the Expressiveness of Coordination via Shared Dataspaces. Science of Computer Programming, 46(1-2):71–98, 2003.
N. Busi, R. Gorrieri, and G. Zavattaro. Process Calculi for Coordination: from Linda to JavaSpaces. In Proc. AMAST, Lecture Notes in Computer Science. Springer Verlag, 2000.
N. Busi and G. Zavattaro. Expired Data Collection in Shared Dataspaces. Theoretical Computer Science, 298:529–556, 2003.
P. Caspi, N. Halbwachs, P. Pilaud, and J. Plaice. Lustre: a Declarative Language for Programming Synchronous Systems. In Proc. POPL’87. ACM Press, 1987.
F.S. de Boer and C. Palamidessi. Embedding as a Tool for Language Comparison. Information and Computation, 108(1):128–157, 1994.
E. Freeman, S. Hupfer, and K. Arnold. JavaSpaces: Principles, Patterns, and Practice. Addison- Wesley, 1999.
D. Gelernter and N. Carriero. Coordination Languages and Their Significance. Communications of the ACM, 35(2):97–107, 1992.
D. Harel. Statecharts: a Visual Formalism for Complex Systems. Science of Computer Programming, 8, 1987.
J.-M. Jacquet and L. Monteiro. Towards Resource Handling in Logic Programming: the PPL Framework and its Semantics. Computer Language, 22(2/3):51–77, 1996.
Isabelle Linden and Jean-Marie Jacquet. On the Expressiveness of Absolute-Time Coordination Languages. In Rocco De Nicola, Gianluigi Ferrari, and Greg Meredith, editors, Coordination Languages and Models, 6th International Conference, COORDINATION 2004, Pisa, Italy, volume 2949 of Lecture Notes in Computer Science, pages 232–247. Springer, February 2004.
Isabelle Linden, Jean-Marie Jacquet, Koen De Bosschere, and Antonio Brogi. On the Expressiveness of Relative-Timed Coordination Models. In Proceedings of the International Workshop on the Foundations of Coordination Languages and Software Architectures (FOCLASA’03), Marseille, France, 2 september, 2003, Electronic Notes in Computer Science, 2003.
F. Maraninchi. Operational and Compositional Semantics of Synchronous Automaton Composition. In Proc. Concur’92, volume 630 of Lecture Notes in Computer Science. Springer, 1992.
D. Gelernter N. Carriero and L. Zuck. Bauhaus Linda. In In P. Ciancarini, O. Nierstrasz, and
A. Yonezawa, editors, Object based models and languages for concurrent systems, volume 924 of Lecture Notes in Computer Science, pages 66–76. Springer-Verlag, 1994.
M. Nielsen, C. Palamidessi, and F.D. Valencia. On the Expressive Power of Temporal Concurrent Constraint Programming Languages. In Proceedings of the 4th international ACM SIGPLAN conference on Principles and practice of declarative programming, pages 156–167. ACM, 2002.
V. Saraswat, R. Jagadeesan, and V. Gupta. Programming in Timed Concurrent Constraint Languages. In B. Mayoh, E. Tougu, and J. Penjam, editors, Computer and System Sciences, volume ASI-131 of NATO. Springer Verlag, 1994.
V. Saraswat, R. Jagadeesan, and V. Gupta. Timed Default Concurrent Constraint Programming.
Journal of Symbolic Computation, 11, 1996.

V.A. Saraswat. Concurrent Constraint Programming Languages. The MIT Press, 1993.
E.Y. Shapiro. Embeddings among Concurrent Programming Languages. In W.R. Cleaveland, editor,
Proceedings of CONCUR’92, pages 486–503. Springer-Verlag, 1992.
G. Smolka. The Oz Programming Model. In J. Van Leuwen, editor, Computer Science Today, volume 1000 of Lecture Notes in Computer Science, pages 324–343. Springer Verlag, 1995.
S. Tini. On the Expressiveness of Timed Concurrent Constraint Programming. Electronics Notes in Theoretical Computer Science, 1999.
P. Wyckoff, S.W. McLaughry, T.J. Lehman, and D.A. Ford. TSpaces. IBM Systems Journal, 37(3), 1998.
