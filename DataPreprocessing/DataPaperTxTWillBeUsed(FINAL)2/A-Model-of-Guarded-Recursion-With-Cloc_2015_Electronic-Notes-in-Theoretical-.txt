Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 319 (2015) 83–101
www.elsevier.com/locate/entcs

A Model of Guarded Recursion With Clock Synchronisation
Aleˇs Bizjak 1
Department of Computer Science, Aarhus University, Denmark
Rasmus Ejlers Møgelberg2
IT University of Copenhagen, Denmark

Abstract
Guarded recursion is an approach to solving recursive type equations where the type variable appears guarded by a modality to be thought of as a delay for one time step. Atkey and McBride proposed a calculus in which guarded recursion can be used when programming with coinductive data, allowing productivity to be captured in types. The calculus uses clocks representing time streams and clock quantifiers which allow limited and controlled elimination of modalities. The calculus has since been extended to dependent types by Møgelberg. Both works give denotational semantics but no rewrite semantics.
In previous versions of this calculus, different clocks represented separate time streams and clock synchro- nisation was prohibited. In this paper we show that allowing clock synchronisation is safe by constructing a new model of guarded recursion and clocks. This result will greatly simplify the type theory by removing freshness restrictions from typing rules, and is a necessary step towards defining rewrite semantics, and ultimately implementing the calculus.
Keywords: Guarded recursion, coinductive types, type theory, categorical semantics.

Introduction
Guarded recursion [17] is an approach to solving recursive type equations where the type variable appears guarded by a ► (pronounced “later”) modal type operator. In particular the type variable could appear positively or negatively or both, e.g. the equation σ = 1 + ►(σ → σ) has a unique solution [6]. On the term level the guarded ﬁxed point combinator fixτ : (► τ → τ ) → τ satisfies the equation f (next (fixτ f )) = fixτ f for any f : ► τ → τ . Here next : τ → ► τ is an operation that “freezes” an element that we have available now so that it is only available in the next time step.

1 Email: abizjak@cs.au.dk
2 Email: mogel@itu.dk

http://dx.doi.org/10.1016/j.entcs.2015.12.007
1571-0661/© 2015 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

One situation where guarded recursive types are useful is when faced with an unsolvable type equation. These arise for example when modelling programming languages with sophisticated features. In this case a solution to a guarded version of the equation often turns out to suffice, as shown in [6].
But guarded recursive versions of polymorphic type equations are also useful in type theory, even in settings where inductive and coinductive solutions to these equations are assumed to exist. To see this, consider the coinductive type of streams Str, i.e., the final coalgebra for the functor S(X) = N × X. Proof assistants like Coq [14] and Agda [18] allow programmers to construct streams using recursive definitions, but to ensure consistency, these must be productive, i.e., one must be able to compute the first n elements of a stream in finite time. Coq and Agda inspect recursive definitions for productivity by a syntactic property that is often overly conservative and does not interact well with higher-order functions.
Using the type of guarded streams Strg, i.e., the unique type satisfying the equa- tion Strg = N × ► Strg, one can encode productivity in types: a productive recursive stream definition is exactly a term of type ► Strg → Strg. To combine the bene- fits of coinductive and guarded recursive types, Atkey and McBride [3] suggested a simply typed calculus with clock variables κ representing time streams, each with associated ►κ type constructors, and universal quantification over clocks ∀κ. If we think of the type τ as being time-indexed along κ, then the type ∀κ.τ contains only elements which are available for all time steps. The relationship between the two notions of streams can then be captured by the encoding of the coinductive stream type as Str = ∀κ. Strgκ. This encoding works for a general class of coinductive types including those given by polynomial functors, and these results were since extended to the dependently typed setting by Møgelberg [16]. In both cases the encodings were proved sound with respect to a denotational model and no rewrite semantics was given. This paper is part of ongoing work to construct just that.

Clock synchronisation
In the calculus for guarded recursion with clocks, typing judgements are given in a context of clocks Δ, which is just a finite set of names for clocks, as well as a context of term variables Γ. Clock variables κ are simply names, there are no constants or operations on them, and there is no type of clocks. The introduction and elimination rules for ∀κ as defined by Atkey and McBride [3] are


Δ,κ | Γ ▶ t : τ


Δ | Γ ▶ Λκ.t : ∀κ.τ
Δ, κj | Γ ▶ t : ∀κ.τ	κj /∈ ∀κ.τ


Δ, κj | Γ ▶ t[κj]: τ [κj/κ]	(1)

These rules are very similar to those for polymorphic types in System F [8], except for the freshness side condition on the elimination rule ensuring that the clocks κ and κj are not synchronised in τ . The side condition makes the rule syntactically not well-behaved. For instance it is not clear that the β-rule for clock application preserves types.
This becomes a more serious problem in dependent type theory.  The rule

Møgelberg [16] considers for clock instantiation is
κ /∈ fc (Γ)	Δ,κ | Γ ▶ τ	Δ, κj | Γ, Γj ▶ t : ∀κ.τ
Δ, κj | Γ, Γj ▶ t[κj]: τ [κj/κ]
where the side condition requires that none of the types τ depends on contain the clock κ. The reason for the additional clock context Γj is to ensure that the calculus is closed under weakening. However, closure under substitution was overlooked and the rules do not appear to be sufficient to derive the substitution property like
Δ | Γ,x : τ ▶ t : σ	Δ | Γ ▶ s : τ
Δ | Γ ▶ t[s/x]: σ[s/x]
which is necessary for a well-behaved dependent type theory.
The restriction on clock instantiation comes from the denotational models of guarded recursion. The original work on guarded recursion [5,6] models a type as a presheaf over the ordered natural numbers, i.e., a diagram of the form
X(1)  X(2)  X(3)  ··· 

For example, the guarded recursive type of streams satisfying Strg = N × ► Strg is modelled by the presheaf with X(n)= Nn. In this model ► shifts a type one step to the right inserting a singleton set in the end of the sequence.
This model was generalised by Møgelberg [16] (Atkey and McBride [3] use es- sentially the same idea) to multiple clocks by simply indexing by multiple copies of natural numbers. Thus, conceptually, a type with clocks κ1 and κ2 was modelled as a two dimensional diagram of sets (as in the left hand part of Figure 1). In this model there is no semantic correspondent to clock substitution. In particular, if τ is a type with two free clocks κ1 and κ2, then the denotation of τ [κ1/κ2] is a one dimensional diagram, but this is in general not the diagonal of the denotation of τ , as one might expect. Semantically, one reason is that taking the diagonal does not commute with the cartesian closed structure.
We propose a new model which supports clock substitution that preserves all the constructs of type theory in the correct way. The model verifies soundness (up to solving the coherence problem, see Section 4) of the rules (1) as understood in dependent type theory, but without the freshness side condition on the elimination rule. In the new model a type depending on two clocks κ1 and κ2 is modelled as a commutative diagrams of the form in Figure 1: the two dimensional grid on the left represents the type X when clocks κ1 and κ2 are not identified and the vertical diagram on the right represents the type X when clocks κ1 and κ2 become synchronised. The arrows inside the two and one dimensional diagrams describe the evolution of elements when the clocks decrease and the arrows from the diagonal of the diagram on the left to the diagram on the right describe how the elements change when the clocks are synchronised. This also explains why there are no arrows from the vertical diagram on the right to the diagram on the left. Once the clocks

.	.	.	.
X(1, 3)  X(2, 3)  X(3, 3)	X(3)

X(1, 2)  X(2, 2)	X(2)

X(1, 1)	X(1)


Figure 1. A type with two free clocks in the new model.

are identified there is no way to disentangle them. To model the substitution κ1/κ2
we simply take the right vertical part of the diagram.
With more clocks the denotation of a type becomes more complex. For instance when we have three clocks the denotation will have a three dimensional diagram (representing the state when none of the clocks are identified), three two dimensional diagrams (representing the state when two of the clocks are identified) and a one dimensional diagram, representing the state when all of the clocks are identified.
Arrows between the different diagrams are given according to the following schema
κ1, κ2, κ3
κ1 = κ2, κ3	κ1 = κ3, κ2	κ1, κ2 = κ3 κ1 = κ2 = κ3
where, for example, κ1 = κ2, κ3 represents the diagram where clocks κ1 and κ2 are identified, and κ3 is independent of the two.

Related work
The calculus considered in this paper can be understood as a modal variant of sized types [1,2]. The modal aspect of ∀κ is investigated by Clouston et. al. [7] which replaces clocks and quantification ∀κ by a single comonadic modality □. This corresponds to having exactly one clock always available. And indeed the calculus is modelled in the topos of trees. The paper provides operational semantics for the calculus and a logic, which is essentially the internal language of the topos of trees with some additional constructs and rules, for reasoning about equality of programs.

Rules of the type theory
Due to space restrictions we only give a brief overview of some of the type and term constructs which are not part of basic dependent type theory. For details on how to use the terms we refer to Møgelberg [16] and Atkey and McBride [3].

The new types in addition to standard constructs of dependent type theory are


Δ | Γ ▶ τ


Δ | Γ ▶ ►κ τ

κ ∈ Δ
Δ ▶ Γ	Δ,κ | Γ ▶ τ


Δ | Γ ▶ ∀κ.τ

κ /∈ Δ
Δj ⊆ Δ	Δ ▶ Γ Δ | Γ ▶ UΔ′


The first two rules introduce ►κ and ∀κ. type formers. The third rule gives universes. The reason we need universes UΔ′ for each Δj ⊆ Δ is to ensure that they are preserved by clock substitution, in particular by weakening. Clock substitution from clock context Δ1 to clock context Δ2 is given by a function f : Δ1 → Δ2, e.g. a substitution κ1/κ2 from clock context κ1, κ2 to clock context κ1 is given by the unique function. We point out in particular how clock substitution on universes is defined, on other constructs it is standard. If f : Δ1 → Δ2 is a clock substitution and Δj ⊆ Δ1 then we define f (UΔ′ )= Uf [Δ′], where f [Δj] denotes the image of the set Δj by f . For example (Uκ ,κ ) [κ1/κ2] = Uκ . Note that this would not make
1  2	1
sense if we only had one universe UΔ in each clock context Δ, since f might not be
surjective. See Section 3.5 and also Møgelberg [16] for semantic reasons why these additional universes are needed.
The main terms introducing and eliminating the new constructs are


Δ | Γ ▶ t : τ

Δ | Γ ▶ nextκ t : ►κ τ κ ∈ Δ
Δ | Γ ▶ t : ►κ (τ → σ)	Δ | Γ ▶ s : ►κ τ


Δ | Γ ▶ t ②κ s : ►κ σ

Δ ▶ Γ	Δ,κ | Γ ▶ t : τ	Δ | Γ ▶ t : ∀κ.τ

κ /∈ Δ
j	j
 κ′ ∈ Δ


Δ | Γ,x : ►κ τ ▶ t : τ

Δ | Γ ▶ fixκ x.t : τ	κ ∈ Δ

The constructs nextκ and ②κ are part of the applicative functor [15] structure of
κ. The second line contains introduction and elimination forms for the ∀κ type. The term fixκ x.t is the unique fixed point of t.
In addition to standard rules these constructs satisfy type isomorphisms


τ ∼= ∀κ.τ	if κ /∈ τ
∀κ.τ + ∀κ.σ ∼= ∀κ.(τ + σ)

Σx:τ
∀κ.σ ∼= ∀κ.
Σx:τ
σ	if κ /∈ τ
κ′ ∀κ.τ ∼= ∀κ. ►κ′ τ	for κ /= κj
∀κ.τ ∼= ∀κ. ►κ τ


which are needed for encoding coinductive types using guarded recursive types. The directions from left to right are definable in the calculus with only the stan- dard introduction and elimination forms, but the inverses need to be added as ad- ditional terms, together with definitional equalities stating that they are inverses. Møgelberg [16] explains in detail how this is done.

The new model
We fix a countable set of clocks CV = {κ1, κ2,.. .}. The model we construct can be briefly described as follows. We build an indexed category GR, indexed by the opposite of the full subcategory of Set on ﬁnite subsets of CV. For each finite set of clocks Δ, the category GR (Δ) is a model of extensional dependent type theory: term variable contexts Δ ▶ Γ, types Δ | Γ ▶ A and terms Δ | Γ ▶ t : A are interpreted in GR (Δ). For any f : Δ1 → Δ2 the reindexing functor GR (f ): GR (Δ1) → GR (Δ2), which is used to model clock substitution, preserves all the structure required for modeling dependent type theory. Finally, for any inclusion ι :Δ → Δ,κ the reindexing functor GR (ι): GR (Δ) → GR (Δ, κ) has a right adjoint ∀κ which is used to interpret quantification over clocks. Due to space restrictions we cannot describe the model in whole, but we only provide definitions of constructs used to interpret ►κ, ∀κ and the universes and proof sketches of important points.
The indexed category GR
The category GR (Δ) is the category of presheaves over the poset I (Δ) which we describe first. To understand the definition of the poset I (Δ) it is useful to keep in mind the example in Figure 1. Let Δ be a finite set of clocks. An element I (Δ) should indicate what is the state of clocks, i.e. which clock are identified, and it should indicate how much time is left on each clock. Hence elements of I (Δ) should be pairs (E, δ) of an equivalence relation E on Δ and a function δ :Δ → N. Since identified clocks should have the same amount of time remaining, the function δ should preserve E. The order on I (Δ) should allow us to get from state represented by (E, δ) to (Ej, δj) whenever Ej identifies more clocks than E and there is no more time left on δj than on δ. This makes sense because we want to be able to substitute clocks, and substitution, in general, identifies clocks. On the other hand once the clocks are identified we can no longer separate them, hence we should not be able to get from a state where more clocks are identified to a state where fewer of them are. With this in mind, here are the precise definitions.
Definition 3.1 For Δ ⊆fin CV let E (Δ) be the set of equivalence relations on Δ (considered as subsets of Δ × Δ).
The order relation on E (Δ) is the opposite of the reﬁnement order, concretely E ≥ Ej ⇐⇒ E ⊆ Ej (note the reverse inclusion). Or in other words, Ej ≤ E if whenever two elements are related by E, they are also related by Ej.
The top element for this ordering is the diagonal relation dΔ. The bottom element is the relation that equates everything.
For a function f : Δ1 → Δ2 let E (f ): E (Δ2) → E (Δ1) be the function defined by pullback as E (f ) (E)= {(κ1, κ2) | (f (κ1),f (κ2)) ∈ E}, i.e. clocks κ1 and κ2 are related by E (f ) (E) if they become equated in E after substitution with f .
Definition 3.2 Let Δ be a finite set of clocks. The poset I (Δ) has elements pairs (E, δ) where E ∈ E (Δ) is an equivalence relation and δ :Δ → N is a function that

respects E. This means that if (κ1, κ2) ∈ E then δ(κ1)= δ(κ2).
The order on I (Δ) is component-wise: (E, δ) ≥ (Ej, δj) ⇐⇒ E ≥ Ej ∧ δ ≥ δj. where the ordering on functions is pointwise.
For a function f : Δ1 → Δ2 the function I (f ) : I (Δ2) → I (Δ1) is defined as
I (f ) (E, δ)= (E (f ) (E),δ ◦ f ).
Definition 3.3 Let Δ be a finite set of clocks. The category GR (Δ) is the category Set(I(Δ))op of (contravariant) I (Δ)-indexed set valued presheaves.
For a function f : Δ1 → Δ2 let GR (f ) : GR (Δ1) → GR (Δ2) be the functor defined by precomposition with I (f ). Concretely
GR (f ) (X)= X ◦ I (f )	and	GR (f ) (α)(E,δ) = αI(f )(E,δ)
where X is an object of GR (Δ1), α is a natural transformation in GR (Δ1) and (E, δ) ∈ I (Δ2). We will also use f∗ for the functor GR (f ).
For use in Section 3.5 below we record a property of surjective substitutions.
Lemma 3.4 Let f : Δ1 → Δ2 be a function between clock contexts. If f is surjec- tive then E (f ) and I (f ) are injective.
Basic properties of GR
For each finite set of clocks the category GR (Δ) is a presheaf topos, hence it is a model of extensional dependent type theory. As mentioned above we aim to use the functors GR (f ) to interpret clock substitution and this means that these functors must preserve constructs used to interpret dependent type theory.
The first property we show is that all the functors GR (f ) are locally cartesian closed functors. This property is not so straightforward to show and requires some preparations. First, because the functors GR (f ) are given by precomposition, they have left and right adjoints [13, Theorem VII.2.2]. Hence they preserve all limits and colimits and in fact they preserve the natural choice of these on the nose, a property that simplifies some proofs. To show that they also preserve exponentials and local exponentials we require some preparation.
Definition 3.5 Let P and Q be two posets. An order-preserving function φ : P →
Q is a ﬁbration if for every p ∈ P and q ∈ Q such that q ≤ φ(p) the set
Bp,q = pj ≤ p  φ(pj)= q
has a top element u(p, q) and moreover whenever q1 ≤ q2, also u(p, q1) ≤ u(p, q2).
This definition is equivalent to a standard definition of a fibration [10], but we found it useful to have names for the top element u(p, q).
One of the reasons ﬁbrations are useful is the following property.
Proposition 3.6 Let P and Q be two posets and φ : P → Q a fibration. The functor φ∗ : SetQop → SetP op given by precomposition with φ, i.e. φ∗(X)= X ◦ φ, is a locally cartesian closed functor.

Proof sketch It is possible to show this directly, but φ being a fibration implies the assumption of Lemma C.3.3.8.(ii) of Johnstone [11] which shows in particular that the functor φ∗ is locally cartesian closed by Proposition C.3.3.1 of loc. cit. 2
Next, we show the crucial property in detail.
Lemma 3.7 Let Δ1, Δ2 be two ﬁnite sets of clocks and f : Δ1 → Δ2 a function. Then E (f ): E (Δ2) → E (Δ1) and I (f ): I (Δ2) → I (Δ1) are both fibrations.
Proof
E (f ) is a fibration Let E  ∈ E (Δ2) and E (Δ1) e F  ≤ E (f ) (E).	Define
u(E, F ) ∈ E (Δ2) as the transitive closure of the relation
Eb = (κ, κj) (κ, κj) ∈ E ∨ ∃(κ1, κ2) ∈ F, f (κ1)= κ ∧ f (κ2)= κj }
The relation Eb is reflexive because E is and it is symmetric because E and F are symmetric. The transitive closure of a reflexive and symmetric relation is again reflexive and symmetric and by definition also transitive. Hence u(E, F ) is an equivalence relation. The first part of the disjunction in the definition of Eb ensures u(E, F ) ≤ E.
Next we check that E (f ) (u(E, F )) = F by showing two inclusions.
First the easy direction.  Take (κ1, κ2) ∈ F .  We need to show that (f (κ1),f (κ2)) ∈ u(E, F ).  This is simple because (f (κ1),f (κ2)) ∈ Eb since it satisfies the second part of the defining condition by choosing witnesses κ1 and κ2.
The converse inclusion is more involved. First we show that if (κ1, κ2) ∈ E (f ) (Eb), meaning (f (κ1),f (κ2))  ∈  Eb, then (κ1, κ2)  ∈  F .  So let (f (κ1),f (κ2)) ∈ Eb. Then
either (f (κ1),f (κ2)) ∈ E in which case (κ1, κ2) ∈ E (f ) (E) and so (κ1, κ2) ∈ F
(because F ≤ E (f ) (E))
or there are (κj , κj ) ∈ F such that f (κj )= f (κ1) and f (κj )= f (κ2). Because
1	2	1	2
E is reflexive and F ≤ E (f ) (E) we have (κj , κ2) ∈ F and (κ1, κj ) ∈ F . Using
2	1
transitivity of F we get (κ1, κ2) ∈ F .
To conclude we show that E (f ) (Eb) ⊇ E (f ) (Eb ◦ Eb) where Eb ◦ Eb is compo- sition of relations. Because Eb is reflexive and E (f ) monotone this implies E (f ) (Eb) = E (f ) (Eb ◦ Eb). Finally because E (f ) commutes with unions, which is easy to check directly from the definition of E (f ), this result implies E (f ) (u(E, F )) = E (f ) (Eb) ⊆ F . The last inclusion is what we have shown above.
So take (κ1, κ2) ∈ E (f ) (Eb ◦ Eb). By definition (f (κ1),f (κ2)) ∈ Eb ◦ Eb so there is a z, such that (f (κ1), z) ∈ Eb and (z, f (κ2)) ∈ Eb.
If (f (κ1), z) ∈ E and (z, f (κ2)) ∈ E then by transitivity of E also (f (κ1),f (κ2)) ∈ E and so (κ1, κ2) ∈ E (f ) (Eb).
Otherwise z = f (κ) for some κ such that (κ1, κ) ∈ F or (κ, κ2) ∈ F . The cases are symmetric because Eb is so we only consider the case when (κ1, κ) ∈ F . Observe that in such a case we also have (κ, κ2) ∈ F . Indeed, if (z, f (κ2)) ∈

Eb then either (z, f (κ2)) ∈ E in which case we have (κ, κ2) ∈ F from the assumption F ≤ E (f ) (E), or there is a pair (κj, κj ) ∈ F such that f (κj) = z = f (κ) and f (κj )= f (κ2). Because E is reflexive and F ≤ E (f ) (E) we have (κj, κ) ∈ F and (κj , κ2) ∈ F . Thus by transitivity and symmetry of F we have (κ, κ2) ∈ F . This further gives (κ1, κ2) ∈ F which shows (f (κ1),f (κ2)) ∈ Eb, concluding the proof.
To see that u(E, F ) is the largest Ej ≤ E such that E (f ) (Ej)= F take some Ej satisfying this condition and observe that it suffices to show Eb ⊆ Ej because Ej is transitive. So take (κ, κj) ∈ Eb. If (κ, κj) ∈ E then (κ, κj) ∈ Ej by using Ej ≤ E. On the other hand if there are (κ1, κ2) ∈ F such that f (κ1)= κ and f (κ2)= κj then by definition we have (κ1, κ2) ∈ F = E (f ) (Ej). Hence (f (κ1),f (κ2)) ∈ Ej and thus (κ, κj) ∈ Ej.
The last property to check is that if F1 ≤ F2 ≤ E (f ) (E) then u(E, F1) ≤
u(E, F2). This is immediate from the explicit definition of the relations Eb.
I (f ) is a fibration To see that I (f ) isa fibration let (E, δ) ∈ I (Δ2) and I (Δ1) e
(F, γ) ≤ I (f ) (E, δ). Define δj : Δ2 → N as

δj(κ)=	γ(κ1)	if ∃κ1 ∈ Δ1, (κ, f (κ1)) ∈ E δ(κ)	otherwise

Then define u((E, δ), (F, γ)) = (u(E, F ), δj) where u(E, F ) is the element given by the first part of the proof.
First we check that in the first case it does not matter which κ1 we choose, i.e., that δj is well-defined. Suppose (κ, f (κ1)) ∈ E and (κ, f (κ2)) ∈ E. Then (f (κ1),f (κ2)) ∈ E and so (κ1, κ2) ∈ E (f ) (E) ⊆ F . Hence γ(κ1)= γ(κ2) because γ respects F .
Now to show that (u(E, F ), δj) is an element of I (Δ2) we need to show that δj respects u(E, F ). Because equality is transitive it suffices to check that if (κ, κj) ∈ Eb then δj(κ)= δj(κj). So take such κ, κj. We consider two cases:
there exist (κ1, κ2) ∈ F such that f (κ1)= κ and f (κ2)= κj. Then because E is reflexive the first case of the definition of δj applies and since γ(κ1)= γ(κ2), because γ respects F , we also have δj(κ)= δj(κj).
the second case is when (κ, κj) ∈ E. We split into two further cases.
If there isa κ1 ∈ Δ1 such that (κ, f (κ1)) ∈ E then we also have (κj,f (κ1)) ∈ E
because of symmetry and transitivity of E and so δj(κ)= γ(κ1)= δj(κ).
Otherwise the other case applies and we use the fact that δ preserves E. Thus we have shown that δj well-defined. Now observe that because E is reflexive we have δj(f (κ)) = γ(κ) hence we have I (f ) (u(E, F ), δj)= (F, γ).
To see that δj ≤ δ let κ ∈ Δ2 and we consider two cases:
if (κ, f (κ1)) ∈ E for some κ1 ∈ Δ1. Then because γ ≤ δ ◦ f and δ preserves E
we have δ(κ)= δ(f (κ1)) ≥ γ(κ1)= δj(κ).
otherwise δ(κ)= δj(κ).
In both cases we have δ(κ) ≥ δj(κ) so we conclude δ ≥ δj.
Suppose now that (Ejj, δjj) is such that I (f ) (Ejj, δjj) = (F, γ) and (Ejj, δjj) ≤

(E, δ). Then we know from the first part of the this proof that Ejj ≤ u(E, F ). To see δj ≥ δjj take κ ∈ Δ2 and we consider two cases.
If (κ, f (κ1)) ∈ E for some κ1 ∈ Δ1. Then δj(κ) = γ(κ1). On the other hand
δjj(κ)= δjj(f (κ1)) = γ(κ1) which follows from the fact that δjj ◦ f = γ.
Otherwise δj(κ)= δ(κ) and since δjj ≤ δ we have δjj(κ) ≤ δ(κ).
In both cases we have δjj(κ) ≤ δj(κ) so we conclude δjj ≤ δj which is what we need.
The fact that the assignment u((E, δ), (F, γ)) is order preserving in the second argument follows directly from the definition of δj.
2
The last two results combined prove the following.
Theorem 3.8 Let f : Δ1 → Δ2 be a function between clock contexts. The functor
GR (f ) is a locally cartesian closed functor.
Remark 3.9 As we mentioned already the functors GR (f ) do preserve the natural choice of limits and colimits on the nose. However there does not appear to be a natural choice of exponentials or dependent products such that GR (f ) would preserve them on the nose. As a consequence we have some technical problems with coherence, which we comment on in Section 4 below.

The ►κ functors
Let Δ be a clock context and κ ∈ Δ. We now define the functor ►κ on GR (Δ) and the natural transformation nextκ : idGR(Δ) → ►κ such that the triple (GR (Δ) , ►κ, nextκ) is a model of guarded recursive terms [6, Definition 6.1].
Example 3.10 To understand the definition recall the diagram X with two clocks in Figure 1.  We wish clock substitution to preserve ► in the sense that (►κ1 ►κ2 X) [κ1/κ2] is the same as ►κ1 ►κ1 (X[κ1/κ2]) and so the diagram
κ1 ►κ2 X should be

1  X(1, 2)  X(2, 2)	X(1)
			
1  X(1, 1)
	
1	1

In particular notice that the one dimensional diagram on the left is delayed twice, because it represents the state when κ1 and κ2 are identified.
To define ►κ in general we start with an auxiliary definition.
Definition 3.11 Let κ ∈ Δ ⊆fin CV, E ∈ E (Δ) and δ : Δ → N. The function

δ—κ :Δ → N is defined as


—κ	j
 max{1, δ(κ) − 1}	if (κ, κj) ∈ E




The thing to notice in this definition is that all the clocks equivalent to κ have their remaining time decreased by 1. This is crucial for clock substitution to com- mute with ►κ in the appropriate way, as illustrated in Example 3.10 above. De- creasing the value of all the clocks related to κ also ensures that if δ preserves E then so does δ—κ. This implies (E, δ—κ) ∈ I (Δ). Observe that (E, δ—κ) ≤ (E, δ) and this assignment is also order preserving. Moreover, this assignment commutes with reindexing I as stated in the following lemma.
Lemma 3.12 Let f : Δ1 → Δ2 be a function and (E, δ) ∈ I (Δ2). For any κ ∈ Δ1 the pairs (E (f ) (E), δ—f(κ) ◦ f ) and (E (f ) (E), (δ ◦ f )—κ) are in I (Δ1) and moreover they are equal.
The definition of ►κ : GR (Δ) → GR (Δ) is now simple.
Definition 3.13 Let κ ∈ Δ ⊆fin CV and X an object of GR (Δ). The action of the functor ►κ on objects is
κ(X)(E, δ)=	1	if δ(κ)=1 
X (E, δ—κ)	otherwise

κ(X) ((E ,δ ) ≤ (E ,δ )) =  !

 
if δ1(κ)=1 

	

where 1 is the singleton set {∗} and ! is the unique arrow to 1. On morphisms


κ(α)

E,δ
=	id1	if δ(κ)=1 
αE,δ−κ	otherwise

There is an associated natural transformation nextκ : idGR(Δ) → ►κ



κ
X (E,δ)
=	∗	if δ(κ)=1 
X ((E, δ—κ) ≤ (E, δ)) (x)	otherwise

It is easy to see that ►κ preserves all limits, since these are given pointwise and any limit of any diagram of terminal objects is a terminal object. It does not preserve colimits, however. For example it does not preserve the initial object.
Proposition 3.14 (Properties of ►) Let Δ1 and Δ2 be two clock contexts and f : Δ1 → Δ2 a function between them. Let κ ∈ Δ1 be a clock. The following properties hold.
Let X, Y be two objects in GR (Δ1) and α : Y ×►κ(X) → X a natural transfor- mation. There exists a unique β : Y → X such that α ◦ ⟨idY , nextκ ◦ β⟩ = β.

We write fixκ(α) for this unique ﬁxed point. Moreover, for any γ : Z → Y
fixκ(α) ◦ γ = fixκ (α ◦ γ × idY ) which expresses naturality of ﬁxed points.
Clock substitution preserves ►, i.e. f∗ ◦ ►κ = ►f(κ) ◦ f∗, and for every
X ∈ GR (Δ), f∗ (nextκ )= nextf(κ) .
X	f∗ (X)
Let α : Y × ►κ X → X be a morphism in GR (Δ1). From the fact that f∗ preserves products on the nose and the previous item the morphism f∗(α) has type f∗(Y ) × ►f(κ) f∗(X) → f∗(X) and moreover f∗ (fixκ(α)) = fixf(κ) (f∗(α)).
Proof sketch The fixed point β at (E, δ) is defined by induction on δ(κ) as
 αE,δ(y, ∗)	if δ (κ)=1 

Item (ii) is shown by simple unfolding of definitions. Item (iii) is shown by establishing that the term on the left is a fixed point of f∗(α) and then using uniqueness of fixed points.	2
The facts above show that for each clock context Δ and κ ∈ Δ, the triple (GR (Δ) , ►κ, nextκ) is a model of guarded recursive terms [6, Definition 6.1]. Hence for each object X ∈ GR (Δ) the slice category GR (Δ) /X also admits a ►X functor
defined by pullback [6, Theorem 6.3]
X Y  ►κ Y

X α
κ α

X  nextκ
κ X

This comes with the associated morphism nextκ,X in GR (Δ) /X. Moreover, for f :Δ → Δj we easily conclude from Proposition 3.14 and the fact that the functor f∗ preserves all limits on the nose that
f∗ ►X Y  = ►f∗ (X) f∗(Y )
and similarly for f∗ nextκ,X so clock substitution behaves well also with respect to ►κ and nextκ in slices.
Clock quantiﬁcation
For any clock context Δ and clock κ /∈ Δ the inclusion function ι : Δ → Δ,κ gives rise to the weakening functor ι∗ : GR (Δ) → GR (Δ, κ). Because ι∗ is defined by precomposition with I (ι) it has a right (as well as left) adjoint [13, Theorem VII.2.2]. We shall call this right adjoint ∀κ and in this section we provide a more explicit description of it, which will provide some more intuition behind it and its relation to coinductive types.
To understand the definition it is again useful to consider the case with two clocks from Figure 1. The object ∀κ2.X is a one dimensional diagram and at stage

n it is the limit (in Set) of the diagram
X(n, 1)  X(n, 2)  X(n, 3)  X(n, 4)  ··· 

The idea is that the type (∀κ2.X)(n) contains information about X(n, k) for all times k. Note that in particular the one dimensional diagram which represents the state of X when the clocks κ1 and κ2 are identified is ignored. This is because the clock κ2 is no longer free and no substitution will be able to equate it to some other clock, i.e. substitution is capture avoiding.
To define the right adjoint of the inclusion in general we need some auxiliaries.
Lemma 3.15 Let Δ be a clock context and ι : Δ → Δ,κ the inclusion. Then
E (ι): E (Δ, κ) → E (Δ) has a right adjoint ι! deﬁned explicitly as
ι!(E)= E ∪ {(κ, κ)}.
In contrast the function I (ι) does not have a right adjoint, the reason being that
N does not have a top element. However for each n ∈ N we can define a function ι!


! : I (Δ, κ) → I (Δ)
ι! (E, δ)= (ι!(E), δ! )
δ(κj)	if κj ∈ Δ
where	δn(κ )= 
n	if κj = κ

n	n


Using the explicit description of ι! in Lemma 3.15 it is easy to see that δ!
preserves

ι!(E). We record some useful properties for use below.
Lemma 3.16 Let Δ be a clock context, κ /∈ Δ and ι :Δ → Δ,κ the inclusion
If n ≤ m and (E, δ) ≤ (Ej, δj) then ι! (E, δ) ≤ ι! (Ej, δj).
n	m
For any (E, δ) ∈ I (Δ, κ) we have (E, δ) ≤ ι!	(I (ι) (E, δ)).
For any (E, δ) ∈ I (Δ) and any n ∈ N we have I (ι) ι! (E, δ) = (E, δ).
For any (E, δ) ∈ I (Δ, κ) and κj ∈ Δ, δ! —κ′ = δ—κ′ ! .
We are now ready to describe the right adjoint ∀κ to ι∗. Let Δ be a clock context, κ a clock not in Δ and ι :Δ → Δ,κ the inclusion.
Define ∀κ : GR (Δ, κ) → GR (Δ) on an object X ∈ GR (Δ, κ) at stage (E, δ) ∈
I (Δ) by taking the limit (in Set) of the diagram of restrictions
X ι! (E, δ)  X ι! (E, δ)  X ι! (E, δ)  ··· 

where the arrows are X’s restrictions using Lemma 3.16. The restrictions of ∀κ.(X) and the action of ∀κ on morphisms are determined purely formally from the uni- versal properties of limits. The unit η of the adjunction is constructed using the universal property of the limit using Lemma 3.16.(iii) which shows that the diagram
ι∗(X) ι! (E, δ)  ι∗(X) ι! (E, δ)  ι∗(X) ι! (E, δ)  ···	(2)

is a constant diagram. The counit ε is constructed with the projections of the limit together with Lemma 3.16.(ii). In more detail, εX : ι∗(∀κ(X)) → X and so at
stage (E, δ) we must define a function εX	: ι∗(∀κ(X))(E, δ) → X(E, δ) which is
a function from the limit of
X ι! (I (ι) (E, δ))  X ι! (I (ι) (E, δ))  ···  X ι!	(I (ι) (E, δ))   ··· 

to X(E, δ). There is a projection from the limit to X ι!	(I (ι) (E, δ)) and from
Lemma 3.16.(ii) we have (E, δ) ≤ ι!	(I (ι) (E, δ)) which means there is a function


X  (E, δ) ≤ ι!

(I (ι) (E, δ)) : X ι!

(I (ι) (E, δ))  → X(E, δ).


Since the diagram is in Set we could describe the limit very explicitly as the set of compatible sequences. This is useful for checking some properties, but we omit it here due to lack of space.
Equipped with a this description of ∀κ we are able to show the necessary prop- erties for interpreting the rules of the type theory.
Proposition 3.17 (Properties of ∀κ) Let Δ be a clock context and κ ∈ CV a clock not in Δ. The functor ∀κ satisﬁes
The unit η of the adjunction ι∗ E ∀κ is a natural isomorphism. Hence ι∗ is a full and faithful functor witnessing that GR (Δ) is a full subcategory of GR (Δ, κ).
The functor ∀κ preserves all coproducts, but not colimits in general.
For any object X ∈ GR (Δ, κ) the canonical morphism c : ∀κ.X → ∀κ.(►κ X)
deﬁned as c = ∀κ. (nextκ) is an isomorphism.
(Beck-Chevalley condition for ∀κ) Let f : Δ1 → Δ2 be a function between two clock contexts, and let κ /∈ Δ1 ∪ Δ2 be a clock. Let and ι1 : Δ1 → Δ1,κ and ι2 : Δ2 → Δ2,κ be the two inclusions.
For every X ∈ GR (Δ1, κ) the presheaves f∗(∀κ.X) and ∀κ. (f + idκ)∗ (X)
∗
are equal and the canonical morphism ∀κ.((f + idκ)∗(ε)) ◦ ηf (∀κ.X) from
f∗(∀κ.X) to ∀κ. (f + idκ)∗ (X) is the identity.
Let Δ be a clock context, κj ∈ Δ, κ /∈ Δ and X ∈ GR (Δ, κ) the canonical morphism ∀κ.(►κ′ (ε)) ◦ η : ►κ′ (∀κ.X) → ∀κ. ►κ′ X is an isomorphism.
Proof sketch
Using Lemma 3.16.(iii) the object ∀κ.ι∗(X) at stage (E, δ) is the limit of the constant diagram (2). Because the diagram is connected its limit is isomorphic to X(E, δ) by the unique mediating map, which is by definition the unit η. The second part is a standard fact about adjoint functors [12, Theorem IV.3.1].
The reason this property holds is that coproducts are given pointwise and that in Set coproducts commute with connected limits.

The arrow ∀κ.(nextκ) at stage (E, δ) ∈ I (Δ) is by definition the mediating map from the limit of
X ι! (E, δ)  X ι! (E, δ)  X ι! (E, δ)  ··· 
to the limit of
1  X ι! (E, δ)  X ι! (E, δ)  X ι! (E, δ)  ··· 
so it is an isomorphism.
The proof is somewhat technical due to the amount of notation involved, but essentially straightforward. Lemma 3.16 is used.
Follows by computation and Lemma 3.16.(iv). Note that to even state it Propo- sition 3.14 is used to get ι∗ ◦ ►κ′ = ►κ′ ◦ ι∗ so we could apply the counit ε.
2
Extension of ∀κ to slices proceeds exactly as before [16, Proposition 1]. The interpretation of the clock instantiation t[κj] now proceeds as follows. A term Δ | Γ ▶ t : ∀κ.τ corresponds to a morphism from (the interpretation of) Γ to
∀κ.τ in GR (Δ). Transposing along the adjunction ι∗ E ∀κ we get a morphism tj from ι∗(Γ) to τ in GR (Δ, κ). Let f : Δ,κ → Δ be the identity on Δ and map κ to κj. Applying GR (f ) to tj we get a morphism from GR (f ) (GR (ι) (Γ)) to GR (f ) (τ ) in GR (Δ) which we define to be the interpretation of t[κj]. Notice that GR (f ) (GR (ι) (Γ)) is just Γ and by definition GR (f ) (τ ) is the interpretation of τ [κj/κ], so the interpretation is consistent.
Remark 3.18 This interpretation is standard, see e.g. Jacobs [10], but note that it is crucial that we have general clock substitution GR (f ), for arbitrary f , and this is precisely the ingredient that was missing in previous models, hence the restrictions on clock instantiation rules.
Universes
We follow previous work [5,16] and use Hofmann and Streicher’s construction of uni- verses in presheaf toposes from universes in Set [9] which we now recall instantiated to our special case. We first recall what a semantic universe is.
Definition 3.19 Let C be a locally cartesian closed category with coproducts and el : E → U a morphism in C. A morphism f : A → Γ is small with respect to el if there is a morphism f : Γ → U such that f is appears as the pullback of el along
f . The morphism f is called a code of f . An object Γ is small if the unique map Γ → 1 is small.
The map el is a universe if the objects 0, 1, N are small and the notion of small- ness is closed under composition, finite coproducts and small dependent products.
Let U be a Grothendieck universe in Set such that N ∈ U and let Δ be a finite set of clocks.

Definition 3.20 The presheaf V Δ ∈ GR (Δ) is defined as V Δ(E, δ) = U↓ (E,δ)op where ↓ (E, δ)op is the set of elements of I (Δ) below (E, δ) and U↓ (E,δ)op is the set of presheaves D on ↓ (E, δ)op such that for all (Ej, δj) ≤ (E, δ) we have D(Ej, δj) ∈ U. The	action	of	V Δ	on	morphisms	is	by	precomposition:
V Δ ((E1, δ1) ≤ (E2, δ2)) (D) = D ◦ ι where ι is the inclusion of ↓ (E1, δ1) to
↓ (E2, δ2).

The presheaf of elements EV
is defined as EV (E, δ)= Σ

D∈V

Δ(E,δ)
D(E, δ) with

restrictions EV ((E1, δ1) ≤ (E2, δ2)) (D, x)= (D ◦ ι, D((E1, δ1) ≤ (E2, δ2))(x)) .
The universe is the first projection uΔ : EV → V Δ defined as uΔ (D, x)= D.
Hofmann and Streicher [9] show that the universe uΔ is closed under the usual constructs used to model dependent type theory, provided U is. What remains is to show that they are also closed under ∀κ and ►κ and that they are suitably preserved by reindexing functors GR (f ). The first two of these properties follow exactly as before [16] so we focus on the last.
The functors GR (f ) do not in general preserve the universes. In particular the inclusion ι∗ : GR (Δ) → GR (Δ, κ) does not map V Δ to (an object isomorphic to) V Δ,κ ∈ GR (Δ, κ). However surjective substitutions do preserve universes in the appropriate sense.
Lemma 3.21 Let s :Δ → Δj be a surjective function between clock contexts Δ and

such that the diagram




commutes.


∗	V	cE
Δ
s∗(uΔ)
s∗ V Δ  cV




EV ′

uΔ′
V Δ′
Δ	Δ′

Proof sketch From Lemma 3.4 we have I (s) injective and from Lemma 3.7 we have that I (s) is a fibration. Thus I (s) restricted to a function ↓ (E, δ) →
↓ I (s) (E, δ) is a bijection with an order preserving inverse given by the assignment
u((E, δ), −).
Moreover, because the bijection is given by a restriction of a single function I (s) it is natural in (E, δ). We thus have
s∗(V Δ)(E, δ)= V Δ (I (s) (E, δ)) = U↓ I(s)(E,δ)op ∼= U↓ (E,δ)op = V Δ′ (E, δ)
where the bijection U↓ I(s)(E,δ)op ∼= U↓ (E,δ)op is natural in (E, δ). Thus s∗(V Δ) ∼=
V Δ′ as presheaves in GR (Δj). The map cE is defined similarly.	2
Remark 3.22 Inspection of the proof also shows why for the inclusion ι : Δ → Δ, κ, the reindexing ι∗ does not preserve universes in this way. This is consistent with the situation as it was in Møgelberg’s previous model [16] and so following loc. cit. we add additional universes in each GR (Δ).

Definition 3.23 Let Δ and Δj be clock contexts such that Δj ⊆ Δ. Let ι : Δj → Δ be the inclusion. We define the universe uΔ′ , E Δ , U Δ as
U Δ = ι∗ V Δ′	E Δ = ι∗ EV	uΔ = ι∗ uΔ′ .
Theorem 3.24 The triple uΔ′ , E Δ , U Δ  is a universe closed under dependent
Proof sketch To see that the notion of smallness is closed under dependent product and sum one uses the fact that ι∗ is an LCC functor (Theorem 3.8) and the fact that a universe is closed under dependent products if a particular generic map is small and this generic map can be constructed using only the LCC structure, hence it is preserved by ι∗. The same approach works for dependent sums. See Shulman [19] for details on how the generic maps for dependent products and sums are constructed.
Closure under ► follows by first showing that the universes V Δ have codes dκ

for ►κ and then deriving codes for U Δ
from these using Proposition 3.14. Closure

under ∀κ is also shown first for universes V Δ and then using the Beck-Chevalley condition (Proposition 3.17) for U Δ . See Møgelberg [16] for more details.	2
Finally, these additional universes are preserved by clock substitution in the appropriate way.
Proposition 3.25 Let f : Δ1 → Δ2 be a function between clock contexts Δ1 and
Δ . Let Δj ⊆ Δ be another clock context and  uΔ1 , E Δ1 , U Δ1  the universe from
Deﬁnition 3.23. There exist two natural isomorphisms cf and cf such that the

diagram
∗	Δ1
Δ′


f
E	Δ2
f [Δ ]

f∗ uΔ1 
 
uΔ2
f [Δ′]
cf
 

commutes. In particular, f∗ U Δ1 ∼= U Δ2 .
Proof Let ι1 be the inclusion of Δj into Δ1 and ι2 the inclusion of f [Δj] into Δ2. Let s : Δj → f [Δj] be the restriction of f . By definition s is surjective and f ◦ ι1 = ι2 ◦ s and so f∗ ◦ ι∗ = ι∗ ◦ s∗. Lemma 3.21 gives natural isomorphisms cV
1	2
and cE such that the diagram on the left


s∗ EV	cE	EV

ι∗ s∗

 EV
  ι∗(cE )
ι∗ EV

Δ′
s∗ uΔ′ 
f [Δ′]
′
2	Δ′
ι∗ s∗ uΔ′ 
2	f [Δ′]
∗  f [Δ′] 

s∗ V Δ′	cV

V f [Δ′]

∗  ∗ 
Δ′  ι∗(cV ) ∗ 

f [Δ′] 

commutes.	Hence the diagram on the right commutes and the vertical mor-



f∗ U Δ1 and also by definition ι∗ V f[Δ′] = U Δ2
1
. This concludes the proof. 2

Conclusions and future work
We have sketched (up to solving the coherence problem) that allowing clock syn- chronisation retains soundness by constructing a model which validates it. With regards to the coherence problem, we can certainly solve it in each GR (Δ), so that substitution of terms into types and terms behaves correctly. However we also need to interpret clock substitution, which we do using the functors GR (f ) for functions f : Δ1 → Δ2 between clock contexts. And in order to validate equalities such as JΔ2 ▶ f (Γ)) = GR (f ) (JΔ1 ▶ Γ)) we would require GR (f ) to preserve our choice of interpretation of all the constructs on the nose, but it only does so up to canonical isomorphism.
We believe this is a technical, rather than essential, problem with the particular presentation. In particular, without universes, we do have a solution to the coher- ence problem by replacing the categories GR (Δ) by equivalent ones obtained by the B´enabou construction [4] (see also [10, Corollary 5.2.5]). This then allows us to make choices of structure that are preserved on the nose by functors interpreting clock substitution. However doing this breaks type equalities like El(in t)  El(t)
where in is a universe inclusion from U Δ to U Δ, for instance. The types on the left
and right are only interpreted as isomorphic objects, not equal.
We are working on giving computational meaning to various type isomorphisms validated by the model and required for working with coinductive types via guarded recursive types. Removing the “freshness” requirements in clock instantiation rule considerably simplifies the syntactic theory.
Acknowledgement
We thank Lars Birkedal for helpful discussions. Aleˇs Bizjak is supported in part by a Microsoft Research PhD grant.

References
Abel, A. and B. Pientka, Wellfounded recursion with copatterns: A unified approach to termination and productivity, in: Proceedings ICFP 2013 (2013), pp. 185–196.
Abel, A., B. Pientka, D. Thibodeau and A. Setzer, Copatterns: Programming infinite structures by observations, in: Proceedings of POPL, POPL ’13 (2013), pp. 27–38.
Atkey, R. and C. McBride, Productive coprogramming with guarded recursion, in: Proceedings of ICFP 2013 (2013), pp. 197–208.
B´enabou, J., Fibrations petites et localement petites, C. R. Acad. Sci. Paris S´er. A-B 281 (1975), pp. Ai, A897–A900.
Birkedal, L. and R. E. Møgelberg, Intensional type theory with guarded recursive types qua fixed points on universes, in: LICS, 2013, pp. 213–222.

Birkedal, L., R. E. Møgelberg, J. Schwinghammer and K. Støvring, First steps in synthetic guarded domain theory: step-indexing in the topos of trees, Logical Methods in Computer Science 8 (2012).
Clouston, R., A. Bizjak, H. B. Grathwohl and L. Birkedal, Programming and reasoning with guarded recursion for coinductive types, in: Proceedings of FoSSaCS, 2015, pp. 407–421.
Girard, J.-Y., P. Taylor and Y. Lafont, “Proofs and Types,” Cambridge University Press, New York, NY, USA, 1989.
Hofmann, M. and T. Streicher, Lifting Grothendieck universes (1999), unpublished.
URL www.mathematik.tu-darmstadt.de/~streicher/NOTES/lift.pdf

Jacobs, B., “Categorical Logic and Type Theory,” Number 141 in Studies in Logic and the Foundations of Mathematics, North Holland, Amsterdam, 1999.
Johnstone, P. T., “Sketches of an elephant: a topos theory compendium. Vol. 2,” Oxford Logic Guides
44, The Clarendon Press Oxford University Press, Oxford, 2002, i–xxii, 469–1089 and I1–I71 pp.
MacLane, S., “Categories for the Working Mathematician,” Graduate Texts in Mathematics, Springer New York, 1998, second edition.
MacLane, S. and I. Moerdijk, “Sheaves in Geometry and Logic: A First Introduction to Topos Theory,” Mathematical Sciences Research Institute Publications, Springer New York, 1992.
The Coq development team, “The Coq proof assistant reference manual,” LogiCal Project (2004), version 8.0.
URL http://coq.inria.fr
McBride, C. and R. Paterson, Applicative programming with effects, J. Funct. Programming 18 (2008),
pp. 1–13.
Møgelberg, R. E., A type theory for productive coprogramming via guarded recursion, in: Proceedings of CSL-LICS 2014 (2014), pp. 71:1–71:10.
Nakano, H., A modality for recursion, in: Proceedings of LICS 2000 (2000), pp. 255–266.
Norell, U., “Towards a practical programming language based on dependent type theory,” Ph.D. thesis, Chalmers University of Technology (2007).
Shulman, M., Univalence for inverse diagrams and homotopy canonicity, Mathematical Structures in Computer Science 25 (2015), pp. 1203–1277.
URL http://journals.cambridge.org/article_S0960129514000565
