Electronic Notes in Theoretical Computer Science 106 (2004) 105–120 
www.elsevier.com/locate/entcs


Relationally Staged Computations in Calculi of Mobile Processes
Neil Ghani1
Dept. of Mathematics and Computer Science,
University of Leicester, University Road, Leicester, LE1 7RH, United Kingdom.
Kidane Yemane2 ,3	Bj¨orn Victor2 ,4
Dept. of Information Technology,
Uppsala University, Box 337, S-751 05 Uppsala, Sweden.

Abstract
We apply the recently developed techniques of higher order abstract syntax and functorial opera- tional semantics to give a compositional and fully abstract semantics for the π-calculus equipped with open bisimulation. The key novelty in our work is the realisation that the sophistication of open bisimulation requires us to move from the usual semantic domain of presheaves over subcate- gories of Set to presheaves over subcategories of Rel. This extra structure is crucial in controlling the renaming of extruded names and in providing a variety of different dynamic allocation operators to model the different binders of the π-calculus.
Keywords: Process Calculi, Abstract Syntax, Algebra, Coalgebra


Introduction
The π-calculus was introduced by Milner, Parrow and Walker [9] as an exten- sion of previous paradigms for distributed and concurrent computation with

1 Email: N.Ghani@mcs.le.ac.uk
2 Work supported by European Union project PROFUNDIS, Contract No. IST–2001–
33100.
3 Email: Kidane.Yemane@it.uu.se
4 Email: Bjorn.Victor@it.uu.se



1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.02.027


structure to reflect not only the locality of information but also its mobil- ity. Thus, in addition to the usual combinators of process algebra such as prefix, parallel combination, nondeterministic choice, input and output, the π-calculus contains processes of the form (νx)P which should be thought of as the process P with local information x. Crucially, the operational semantics of the π-calculus allows the topography of this locality to evolve dynamically so that information which is local at some point may become global later. This phenomenon, known as extrusion, is the central innovation of the π-calculus. The π-calculus allows processes to change their connectivity over time. Hence it is called a calculus of mobile processes.
One of the key advances of research in process algebra was the concept of bisimulation as a method of proving equivalences of processes. While this concept is fairly simple as introduced in CCS [8], the concept becomes more intricate in process algebra with variable binding as a variety of different pos- sibilities exist. The simpler ones, such as early bisimulation and late bisimula- tion [9] suffer from not being congruences. Open bisimulation [15] on the other hand is a congruence but is complicated by the fact that the bisimulation rela- tion must be closed under not only transitions, but also certain substitutions and these substitutions vary from process to process. This makes the overall definition rather more complex and subtle than the definition of early and late bisimulation.
The success of the π-calculus, and the variety of different bisimulations it supports, makes it an ideal case study for some exciting recent developments in program language semantics, in particular for higher order abstract syntax (HOAS) [4] and functorial operational semantics (FOS) [18]. HOAS aims to extend the highly successful paradigm of initial algebra semantics to languages involving variable binding while FOS seeks a uniform framework in which to reason about the relationship between operational and denotational models. Hence we aim at a treatment of open bisimulation in the π-calculus by using the following strategy:
Since the π-calculus contains variable binding, we follow the HOAS ap- proach and model the syntax of the π-calculus by the initial algebra of an endofunctor over a category of presheaves.
The observations one can make of a process are given by a language of pre- fixes which is modelled by a copointed endofunctor over the same category of presheaves. This endofunctor is called the behaviour functor. Transition systems are the coalgebras for this behaviour functor and bisimulations are given by coalgebraic bisimulations.
We model the operational semantics as a distributivity of the syntax over the behaviour from which we derive compositionality and full abstraction

results.
The contributions of this paper are therefore:
We give a clean presentation of open bisimulation and derive results like compositionality and full abstraction. This is achieved by using abstract ideas such as coalgebra, naturality and indexing to avoid the various tech- nical side conditions concerning free and bound names which appear in the standard definitions [16].
The sophistication of open bisimulation arises from its closure under varying classes of renamings. The novelty of our approach is that we capture this feature by moving from presheaves over a subcategory of Set (as in [5]) to presheaves over a subcategory of Rel which we call relational presheaves. In this paper Rel is taken to be the category with relations as objects and monotone functions as morphisms. These relational presheaves offer more dynamic allocation operators to model the binders in the π-calculus than are usually available.
As we comment in the conclusion, this extra power of relational presheaves seems exactly what is needed to treat other elaborate bisimulations such as hyperbisimulation in the Fusion calculus [11].

Related Work:
This program of research has been applied to the π-calculus in [5] but only to early and late bisimulations. However, the sophistication of open bisim- ulation means that these methods could not be applied — our solution of using relational presheaves seems to be precisely what is required in terms of providing appropriate extra structure. Open bisimulation has been writ- ten about extensively in the concurrency literature [16,12] (e.g. regarding its axiomatisation, symbolic transition systems leading to efficient characterisa- tions, and implemented algorithms for deciding equivalence). Interestingly, in these papers, some constructions are indexed by relations as proposed here while others are not. Thus our idea of building our semantics around relational presheaves fits in with, and extends, a trend in the mainstream treatment of open bisimulation. But the fact that one then sees connections with other bisimulations such as hyperbisimulation makes a strong case for moving to our more abstract setting.
This paper will appeal to those coalgebraists who are interested in HOAS and FOS as, in order for this theory to fully mature, more complex examples need to be treated. This is precisely what we have done. For example, we wonder whether the relational presheaves we consider here fit into Power’s axiomatics for FOS [14]. In addition, two of the present authors work in the


Fig. 1. Syntax of π-calculus
area of concurrency and came to this subject as they were interested in the possibility of more abstract treatment of their subject. Given the proliferation of different process algebras and the numerous associated bisimulations, this is certainly a growing area of interest and we expect other concurrency theorists to be interested in this work. In summary, there are both good theoretical and practical reasons for the development of open bisimulation within the higher order functorial operational semantics framework that we have provided.
The paper is structured as follows: We provide the concrete syntax and semantics of π-calculus in section 2 followed by abstract syntax of the π- calculus in section 3. Section 4 contains the associated behaviour functor and the key results on the compositional and fully abstract semantics of the π- calculus. We finish in section 5 with some conclusions and ideas for further work.

The π-calculus
In this section we recall the syntax and semantics of the π-calculus and the definition of open bisimulation equivalence. As this is standard material, we refer the reader to standard texts for some of the technical details, e.g. [16].
We assume an infinite set of names N ranged over by a, b,... x, y,.. .. These represent the communication channels and the values sent and received.
Definition 2.1 (The π-calculus) The set of raw π-calculus processes, ranged over by P, Q, R etc, and prefixes α are defined inductively by the rules of Fig- ure 1.
0 stands for the empty process which can do nothing. The process α.Q can perform the relevant input, output or silent action and then become the process Q; Q + R is the nondeterministic choice of Q and R; Q | R is the




pref
	−	
α.P −α→ P P −α→ P '
res
P −α→ P '
(νz)P −α→ (νz)P P −α→ P '
if z /n∈(α)
'

sum
P + Q −α→ P
par
'

P | Q −α→ P ' | Q
if bn(α) /f∈n(Q)

P −α→ P '
P −u−(x→)


P ',	Q −u→y Q'

match
com
α	'	τ	'	'

[x = x]P −→ P	P | Q −→ P {y/x}| Q



P −x→y  P '
P −u−(y→)


P ',	Q −u−(y→) Q'

open
(νy)P −x−(y→) P
if x /=y	close
'
P | Q −→τ	(νy)(P '
| Q')

P −α→ P '


P −u→y P ',	P −u−(→y)
P ''

rep-pref
! P −α→ P ' | ! P
rep-com
! P −→τ	P '
| P ''
{y/x}| ! P

P −u−(y→)
P ',	P −u−(y→)
P ''

rep-close
! P −→τ	(νy)(P '
| P ''
) | ! P



Fig. 2. Transition rules for π-calculus

process Q and R running in parallel; (νx)Q is the process Q where x occurs locally and is bound in Q; [x = y]Q is the process Q if the names x and y are equal and otherwise is 0. Finally ! P is the replication operator which can be seen as unlimited copies of P and can be used to encode recursion. The prefixes generate the observable behaviour that processes exhibit as they evolve. Observations vary depending upon the bisimulation one wants to study but for open bisimulation there are four, namely i) a(x) represents the input of an unknown name x on channel a; ii) ax represents the output of a global name x on channel a; iii) a(x) represents the output of a local name x on channel a; and iv) τ represents a silent internal action. In the actions above, we call a the subject of the action, and x the object.
The input prefix and the restriction operator are binders (the bound output prefix a(x) .P is short for (νx)ax . P ). Thus there are the obvious notions of free and bound names in a process or prefix, denoted fn(P ), fn(α), bn(P ), bn(α); we write n(P ) and n(α) for the free and bound names in a process or prefix. The binders then induce the obvious notion of α-equivalence on processes, and the terms of the π-calculus are the processes quotiented by α-equivalence. Having defined the syntax of the π-calculus, we turn to its operational seman- tics.

Definition 2.2 The family of transitions P
−α→ Q is the least family satis-

fying the laws in Figure 2, where symmetric rules for sum, par, com and
close have been omitted.


Open bisimulation, originally defined by Sangiorgi [15], is finer than the early and late bisimulations [9]; unlike early and late bisimulation, open bisim- ulation is a congruence and, although its definition may seem more complex at first sight, it has an “efficient” characterisation exploited in automated tools [15,19]. Open bisimulation is defined as a set of relations indexed by distinctions which are used to express the permanent inequality of names.
Definition 2.3 A distinction is a finite symmetric and irreflexive relation on names. We may write {(x, y)} for {(x, y), (y, x)} etc, omitting symmetric pairs. A substitution is a function on names which has obvious actions on processes and distinctions. A substitution σ respects a distinction D if (a, b) ∈ D implies σ(a) /= σ(b).
Distinction relations are used to record the names extruded by bound output; these names were originally bound and hence must be kept different from all other names — the use of distinction relations allows us to consider only those renamings which keep extruded names distinct.
Definition 2.4 A distinction indexed set £ = {SD} of symmetric process relations is an open bisimulation if for each SD and for each σ which respects D, whenever (P, Q) ∈ £D
if Pσ —a—(x→) P ' with x /∈ fn(Q), then there is a Q' such that Qσ —a—(x→) Q'
and (P ', Q') ∈ SD' , where D' = Dσ ∪ {{x}× fn(P σ, Qσ)};
if Pσ —α→ P ' with bn(α) /∈ fn(Q) otherwise, then Q' exists s.t. Qσ —α→ Q'
and (P ', Q') ∈ SD.
P and Q are open D-bisimilar, written P ~D Q, if there is an open bisimulation
£ s.t. (P, Q) ∈ SD for SD ∈ £.
As a simple motivating example, consider the processes

P = x. 0 | y. 0
Q = x.y . 0 + y. x. 0
P0 = (νx, y)zx . zy. P
Q0 = (νx, y)zx . zy. Q

where clearly P /~  Q, since P {x/y} —→τ
P '  but Q{x/y} —→τ/
Q'. However,

P0 ~∅ Q0, since there is no possibility of x and y ever being identified. This
information is recorded in the distinction index of the open bisimulation rela- tion; after the first two bound outputs z (w) and z (y), we only need to verify that P ~{(x,y)} Q, thus ruling out all substitutions identifying x and y. For further examples and motivation see e.g. [16,15].
We shall see later how these technical conditions concerning bound and free names etc are subsumed within the HOAS set up to provide a more pleasing

definition.

Abstract Syntax
The problem with the concrete definition of the syntax of the π-calculus as given in section 2.1 is that it is presented as a quotient datatype. Reasoning with such quotient datatypes is notoriously difficult as one either has to ef- fectively pick representatives for the equivalence classes or work directly with the equivalence classes themselves. Consequently, it was something of a break- through when it was discovered how to present not just the raw terms, but also the α-equivalence classes of terms as free or initial datatypes [4].
The approach may be summarised as follows: rather than defining a set of raw terms and then quotienting them by α-equivalence, one defines for each set of free variables, the set of terms definable in that context. These contexts are also called stages. Thus for each context or stage we have a set of terms. Allowing renaming of variables in contexts means contexts form a category C and then terms should be given by a functor C → Set. Typically C has been chosen to be either the category of finite sets and all functions [5], or the category of finite sets and injective functions [5]. Our central insight and the novelty of our approach is that to tackle more sophisticated situations such as open bisimulation in the π-calculus and hyperbisimulation in the Fusion calculus, more structure is required of the stages and in particular that stages form subcategories of Rel.
Open bisimulation is closed not just under transitions but also renamings which must be injective on the names which have been extruded. Thus each stage should not consist only of a set of free variables but should include a relation which says when names cannot be renamed to be the same. Thus our presheaves will be over certain subcategories of Rel and not Set. For open bisimulation, this subcategory is the category of distinction relations which we now define.
The Category of Distinction Relations
To interpret open bisimulation we use stages which consist of distinction re- lations. Thus π-calculus-terms will form a presheaf D → Set where D is the category of distinction relations.
Definition 3.1 (The category D) The category D of distinctions relations is the full subcategory of Rel whose objects are distinction relations, i.e., relations which are irreflexive, symmetric and have a finite carrier set.
Thus morphisms between distinction relations (n, dn) and (m, dm) are func-


tions f : n → m which preserve the distinction relation. Intuitively, a distinc- tion relation is a set and a relation such that related elements are thought of as definitely distinct which must never be renamed to be the same. As we argued earlier, finding a mathematical formalism to ensure that extruded names are renamed injectively while other names may be renamed non-injectively is the key to understanding open bisimulation.
As mentioned above, the main insight here is that we work in the presheaf category SetD. Much of the required structure of this presheaf category is inherited from D as we now describe.
Lemma 3.2 (Structure of D) The category D has three distinguished dy- namic allocation functors Id, δ+, δ− : D → D
Proof. The dynamic allocation operator Id is the identity, while δ− is simply coproduct with the distinction relation on the one element set. The action of δ+ : D → D on objects is given by δ(n, dn) = (n + 1, dn+1) where dn+1 is the symmetric closure of
dn ∪ {(∗, i)|i ∈ n}
The action on morphisms is as expected while functoriality is a simple calcu- lation.	 
Thus both δ− and δ+ both add an extra element to the carrier of a dis- tinction relation to represent the bound variable. However, δ+ asks that, in addition, this new element is made distinct from the other elements. The functor δ+ will be used for the binding associated with restriction to ensure that the extruded name cannot be renamed to other name while the δ− func- tor is used for bound input where no such restrictions are necessary. The superscripts +, — are designed to convey the idea that while both δ+ and δ− both add in an extra element, δ+ adds in extra distinctions. The presence of more than one dynamic allocation operator is a direct consequence of our move to relational presheaves as a semantic domain. We use the identity as a dynamic allocation operator solely to avoid case analysis later on.
The structure exhibited in Lemma 3.2 lifts to structure of the category of D-presheaves as follows. Note that the restriction to finite distinction relations means that there are no size problems when talking about the category of D- presheaves. Rather than invent new symbols for the lifted structure, we shall use the same symbols but ensure the reader has enough information to deduce which category we are working in.
Lemma 3.3 (Structure of SetD) The category SetD has products, coprod- ucts, a presheaf of names, three dynamic allocation functors Id, δ−, δ+ and a

ﬁnite powerset functor deﬁned as follows:
The presheaf of names N ∈ SetD with action N(n, dn)= n.
As with all limits and colimits in functor categories, products and coproducts are computed pointwise. Thus (P × Q)(n, dn) = P (n, dn) × Q(n, dn) and similarly for coproducts.
Each dynamic allocation functor κ ∈ {Id, δ+, δ−} on D deﬁnes the dynamic allocation operator ◦ κ : SetD → SetD.
If Pf is the ﬁnite powerset functor on Set, then Pf ◦  : SetD → SetD
deﬁnes the ﬁnite power operator on D-presheaves.
We can now give an initial algebra semantics for the π-calculus based upon distinction relations.
π-calculus Syntax as an Initial Algebra
The category of presheafs SetD provides a suitable universe of types to model syntax and semantics of π-calculus with an open interpretation. The syntax of π-calculus given in Definition 2.1 is captured up-to α-equivalence by an endofunctor Σ : SetD → SetD defined in Figure 3.


Fig. 3. Endofunctor modelling π-calculus-terms
The functor Σ is constructed as expected as the sum of functors for each specific syntactic category of the language. For example, the 0 process always adds one process, while free output prefixed processes consist of two names and a process already constructed. Bound output on the other hand consists of the


name of the channel on which the previous local name was to be transmitted, and the process with the extruded name declared to be distinct from all other names by the use of δ+. Compare this situation with the input prefix where the name expected along the input channel is not extruded and hence not forced to be distinct from other names by using δ−.
The syntax of the π-calculus is the initial Σ-algebra which we write Σπ. That Σ has an initial algebra follows from the fact that i) SetD has ω-colimits and an initial object inherited from Set; and ii) sums and products preserve filtered colimits while for any functor F , ◦F always preserves filtered colimits. That Σπ(X) is the set of π-calculus terms up-to α-equivalence with free names from X is easily seen via the same kind of argument as in [5] to establish the correctness of the higher order abstract syntax approach to the untyped λ- calculus. Notice that since Σπ is a D-presheaf, we can also rename π-calculus terms. However, exactly which names can be equated by such renamings is controlled by the stage or distinction relation where the process lives. Recall that achieving this is the key step to tackling open bisimulation.

Labelled Transition Systems
Having given an initial algebra semantics for the syntax of the π-calculus, we turn to a treatment of the open transition relation and hence open bisim- ulation. Our approach is to define a behaviour functor such that an open transition system is simply a coalgebra for the behaviour functor and open bisimulation is then a coalgebraic bisimulation. Of course, we wish to use the advantages of HOAS to work up-to α-equivalence and so the first step is to replace the prefixes of Definition 2.1 which contain bound variables, with versions up-to α-equivalence. Thus we define the set Act = {a(), a(), ab, τ } and note that if σ : N → N is any function over names, then there is the obvious action on the set Act.
Next, we use these actions to define the notion of transition system. In the HOAS framework processes are given in specific stages and hence the nodes of the transition system must be pairs of stages and processes which inhibit them.
Definition 4.1 (D-transition systems) A D-transition system consists of a presheaf X : SetD and a graph such that
The nodes are labelled by pairs (p, d) where p ∈ X(d)
The edges are labelled by elements of the set Act such that if

· (p, d) —a→()


· (p, d) —a→()
(p', d') then d' = δ−d and a ∈ d
(p', d') then d' = δ+d and a ∈ d





· (p, d) —a→b
· (p, d) —→τ
(p', d') then d' = d and a, b ∈ d
(p', d') then d' = d

If (p, d) —α→ (p', κd) where κ ∈ {Id, δ−, δ+} and σ : d → d'

then (pσ, d') —α→σ
(p'σ, κd').

The essence of the FOS approach is to represent transition systems such as those in Definition 4.1 as coalgebras of a behaviour functor. We define the behaviour functor as follows:
Definition 4.2 (Behaviour Functor) The functor B : SetD → SetD is defined as follows
BP = Pf (P + N × N × P + N × δ+P + N × δ−P )
To understand the above definition, think of BP as the possible evolution of a presheaf of processes P . Non-determinism means there are many possible evolutions and hence the presence of the power type functor Pf ◦ . Each of these possible evolutions consists of the observable action and the resulting process. The silent and free output actions are the first two possibilities — notice that the resulting processes live in the same stage. For bound output, we observe the channel along which the output is sent and the resulting process has the name extruded and hence the stage is extended by the extruded name which must be kept distinct from all others. Finally, for bound input much the same is true except that in the resulting process the fresh name need not be distinct from the other names.
Lemma 4.3 D-transition systems are in one-to-one correspondence with B- coalgebras.
Proof. The structure map of the coalgebra gives us exactly the transition relation while the naturality of the coalgebra structure map corresponds ex- actly to the closure condition of open transitions under distinction preserving renamings.	 
A B-coalgebraic bisimulation is defined as follows:
Definition 4.4 (Coalgebraic Bisimulation) A B-bisimulation over a B- coalgebra X is given by a relation R over X such that there is a B-coalgebra structure on R making the following diagrams commute.
X (	 R 	) X
.
.
.
.
.
v	.v	v
BX (	 BR 	) BX


Lemma 4.5 The following data are equivalent:
A B-bisimulation over a presheaf X : D 	) Set
A family of symmetric relations
{Rd ⊂ X(d) × X(d)}d∈D
such that
If σ : d → d' and p Rd q, then pσ Rd' qσ
p Rd q implies if
p —τ→ p' then there is a q' such that q —τ→ q' and p' R q'

p —a→() p'
a()	'
then there is a q'
'
such that q —a→() q'
a()	'
and p'
'
Rδ− d q'
'

p —→ p
then there is a q
such that q —→ q
and p
Rδ+ d q .



p —a→b


p' then there is a q' such that q —a→b
q' and p' Rd q'.

Lemma 4.5 gives an elegant characterisation of B-bisimulations as open bisimulations but is this really the same notion of open bisimulation as found in Definition 2.4. The conditions relating to bound names have been implicitly implemented by making processes reside in a specific distinction relation and by using the dynamic allocation operators δ− and δ+. The only other issue is that Definition 2.4 is not immediately closed under distinction preserving renaming but this is actually a well known property [16].

Categorical rules
In this section we show how the operational rules of π-calculus given in Fig- ure 2 are modelled via natural transformations of a certain form which imply a compositional semantics with full abstraction property provided that the behaviour functor is finitary and preserves weak pullbacks. That such natural transformations give rise to a compositional and fully abstract semantics goes back to the seminal paper [17]. More recent work [7,13] has recast the abstract theory more elegantly in terms of distributivity laws but, since our goal is to establish the existence of such distributivity laws, we stick with the original concrete format. Since the material here is as one would expect, we treat only the following laws for the restriction operator.

P —a→b P '	P —x→y P '

res
(νz)P —a→b (νz)P
if z /∈a{, b}	open
'
(νy)P —x—(y→) P
if x /= y 
'

In general, we seek to model such operational laws as natural transforma- tions which are natural in X
(1)	Σ(X × BX) → BTX	in	SetD


In the case of the two rules for restriction given above, we derive the correct natural transformation from a natural transformation δ+(X × BX) → BTX is generated by

δ+N × δ+N × δ+X —→ρ  P (N × N × TX + N × δ+TX)
ƒ

The definition of ρ can be given using the internal language defined in [3].
⎧ (a'(), q'),	if a is old (a') and if b = new (b')
ρ(a, b, q)=	(a'b', (νz)q'), if a is old (a') and b = old (b')
⎪⎪⎩ ∅	if a = new (a')
where old and new are the injections D  ) δ+D and 1  ) δ+D. Naturality can easily be checked.
Results in [17] show the semantics associated to the natural transforma- tion modelling the operational rules induces compositional semantics with full abstraction property, i.e., two process with the same semantics are B-bisimilar.

Lemma 4.6 Operational rules of Figure 2 modelled by natural transformation of type (1) induces a compositional semantics having full abstraction property.

Proof.
Most of the constructors of the behaviour functor have already been proven finitary. That Pƒ : Set  ) Set is finitary is folklore, and thus power type operator Pƒ ◦ is finitary, since if K is any finitary functor, so is K ◦
The fact that B preserves weak pullbacks follows from i) the fact that prod- ucts and coproducts do; the fact that Pƒ does; iii) and that if K : D  ) D is any functor then ◦ K : SetD  ) SetD preserves weak pullbacks. This can be proved as follows.
Let P be the weak pullback of η : S  ) Q and ϵ : R  ) Q (assume that the following diagrams are weak pullbacks).
P	p ) R
p'	є
v	v
S 	) Q
y


We must show P ◦ X is the weak pullback of η ◦ X : S ◦ X   ) Q ◦ X and
ϵ ◦ X : R ◦ X 	) Q ◦ X.
P ◦ X	p◦X ) R ◦ X


p'◦X
v
є◦X
v

S ◦ X 	) Q ◦ X
y◦X
Given a map h : H  ) S ◦ X and h' : H  ) R ◦ X with the properties that (η ◦ X) ◦ h = (ϵ ◦ X) ◦ h', we get maps LanX H  ) S and LanX H  ) R making the square commute. Since P is the weak pullback of this square, we have a map LanXH  ) P and hence a map H  ) P ◦ X as required. All commutations follow from naturality.	 

Conclusion
This paper has given a clean presentation of open bisimulation in the π- calculus using the recently developed theories of higher order abstract syntax and functorial operational semantics. Open bisimulation is more sophisti- cated than early and late bisimulation which had previously been studied in this framework because the extruded names must be recorded and kept dis- tinct from all other names under renaming. We solve this technical challenge in an elegant way by moving from presheaves over a subcategory of Set to presheaves over a subcategory of Rel, namely the category of distinction re- lations. The extra structure of such relational presheaves offers a choice of dynamic allocation operators to model the different binding operators which arise in the language. By verifying the preconditions of the functorial opera- tional semantics framework, we then obtain a compositional and fully abstract semantics for open bisimulation in the π-calculus.
There are a number of future directions we wish to take this research. Firstly relational presheaves seem to offer the extra structure required to model sophisticated bisimulations such as open bisimulations. The fusion calculus [11] is a variant of the π-calculus where the communication rule


com
P —u—(x→)


P ', Q —u→y
Q',

P | Q —→τ
is replaced by the communication rule
P '{y/x}| Q'


com


P —u→x P ', Q —u→y
Q'
|x| = |y|

P | Q —{—x=—y→}
P ' | Q'

which can be thought of as an explicit substitution and with all the associated


benefits of making substitution local etc. In such a calculus processes are defined in a context which consists of not just a set of free names but also an equivalence relation on the names which arise from the communication rule above. This suggests modelling the fusion calculus using presheaves with stages given by finite equivalence relations. We already have sketched the details and will include them in the forthcoming journal version of this paper. In the longer term there are a variety of directions we wish to go. On the theoretical side, it would be very interesting to extend these techniques to higher order process calculi and much of the semantic infrastructure already exists and is waiting to be used. We would also like to consider whether these techniques can be extended to Milner’s bigraphs [6] which is a formalism intended to abstract away from specific process calculi. Further, it would be interesting to test the applicability of Power’s recent work on computing with
distributivity laws [13] to this setting.
A more practical direction to take this research is that of HD-automata [10]. HD-automata seek to give an operational model of History Dependent calculi by decorating the states of automata with relevant information (free names of a processes) and establishing the correspondence between the local information in different states. These automata can be seen as concrete re- alisations of the more abstract framework [12,2]. By automatically distilling a concrete, minimised representation of a process as a history dependent au- tomata, we can expect applications in model checking and verification along the lines of [1].

References
Gianluigi Ferrari, Stefania Gnesi, Ugo Montanari, Marco Pistore, and Gioia Ristori. Verifying mobile processes in the HAL environment. In Alan J. Hu and Moshe Y. Vardi, editors, Proceedings of CAV ’98, volume 1427 of LNCS. Springer, 1998. Tool Poster.
Gianluigi Ferrari, Ugo Montanari, and Marco Pistore. Minimizing transition systems for name passing calculi: A co-algebraic formulation. In Mogens Nielsen and Uffe H. Engberg, editors, Proceedings of FoSSaCS 2002, volume 2303 of LNCS, pages 129–143. Springer, April 2002.
Marcelo Fiore, Eugenio Moggi, and Davide Sangiorgi. A fully-abstract model for the π-calculus (extended abstract). In Proceedings of LICS ’96, pages 43–54. IEEE, Computer Society Press, July 1996.
Marcelo Fiore, Gordon Plotkin, and Daniele Turi. Abstract syntax and variable binding (extended abstract). In Proc. 14th LICS Conf., pages 193–202. IEEE, Computer Society Press, 1999.
Marcelo Fiore and Daniele Turi. Semantics of name and value passing. In Proc. 16th LICS Conf., pages 93–104. IEEE, Computer Society Press, 2001.
Ole Hogh Jensen and Robin Milner. Bigraphs and transitions. SIGPLAN Not., 38(1):38–49, 2003.


Marina Lenisa, John Power, and Hiroshi Watanabe. Distributivity for endofunctors, pointed and co-pointed endofunctors, monads and comonads. In Horst Reichel, editor, Proceedings 3rd Workshop on Coalgebraic Methods in Computer Science, CMCS’00, volume 33, Berlin, Germany, 25–26 March 2000. Elsevier.
R. Milner. A Calculus of Communicating Systems, volume 92 of LNCS. Springer, 1980.
Robin Milner, Joachim Parrow, and David Walker. A calculus of mobile processes, part I/II.
Journal of Information and Computation, 100:1–77, September 1992.
Ugo Montanari and Marco Pistore. History dependent automata. Technical report, Computer Science Department, Universita` di Pisa, 1998. TR-11-98.
Joachim Parrow and Bj¨orn Victor. The fusion calculus: Expressiveness and symmetry in mobile processes. In Proceedings of LICS ’98, pages 176–185. IEEE, Computer Society Press, July 1998.
Marco Pistore and Davide Sangiorgi. A partition refinement algorithm for the π-calculus. Journal of Information and Computation, 164(2):264–321, January 2001. An extended abstract appeared in Proceedings of CAV’96: 38–49.
John Power. Towards a theory of mathematical operational semantics. In H. Peter Gumm, editor, Electronic Notes in Theoretical Computer Science, volume 82. Elsevier, 2003.
John Power. A unified category-theoretic approach to variable binding. In Proceedings of MERLIN 2003, Uppsala, Sweden, August 2003.
Davide Sangiorgi. A theory of bisimulation for the π-calculus. Acta Informatica, 33:69–97, 1996. Earlier version published as Report ECS-LFCS-93-270, University of Edinburgh. An extended abstract appeared in the Proceedings of CONCUR ’93, LNCS 715.
Davide Sangiorgi and David Walker. The π-calculus: a Theory of Mobile Processes. Cambridge University Press, 2001.
D. Turi and G.D. Plotkin. Towards a mathematical operational semantics. In Proc. 12th LICS Conf., pages 280–291. IEEE, Computer Society Press, 1997.
Daniele Turi. Functorial Operational Semantics and its Denotational Dual. PhD thesis, Free University, Amsterdam, June 1996.
Bj¨orn Victor and Faron Moller. The Mobility Workbench — a tool for the π-calculus. In David Dill, editor, Proceedings of CAV ’94, volume 818 of LNCS, pages 428–440. Springer, 1994.
