Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 322 (2016) 227–242
www.elsevier.com/locate/entcs

A Class of
Reversible Primitive Recursive Functions
Luca Paolinia,1,2,  Mauro Piccoloa,1,2 and  Luca Roversia,1,2
a Dipartimento di Informatica, Università degli Studi di Torino, Corso Svizzera 185, 10149 Torino

Abstract
Reversible computing is bi-deterministic which means that its execution is both forward and backward deterministic, i.e. next/previous computational step is uniquely determined. Various approaches exist to catch its extensional or intensional aspects and properties. We present a class RPRF of reversible functions which holds at bay intensional aspects and emphasizes the extensional side of the reversible computation by following the style of Dedekind-Robinson Primitive Recursive Functions. The class RPRF is closed by inversion, can only express bijections on integers — not only natural numbers —, and it is expressive enough to simulate Primitive Recursive Functions, of course, in an effective way.
Keywords: Reversible computing, Recursive permutations, Primitive Recursive Functions.


Introduction
Reversible computing (sometimes called isentropic or adiabatic computing) is, on its own, an unconventional form of computing. Origins of reversible computing trace back to the study of entropy in physical systems [16]. The goal was relating thermo- dynamic properties of the system with the amount of information that it could carry around. In the sixties, Landauer was the first to define a technique for transforming irreversible computations into equivalent reversible ones [9]. Landauer thought his machines could not reversibly get rid of their undo trails. Lecerf first described a technique to uncompute histories [10], but he was unaware of the thermodynamic applications. Bennett [2] rediscovered Lecerf reversal. “Bennett’s trick” corresponds to copying the output before uncomputing the undo trail, thereby showing for the first time reversible computations that could avoid entropy generation. The moral of these studies tells us that, if a physical system performs a logically irreversible

1 Partially supported by the LINTEL project.
2 Email: luca.paolini@unito.it, mauro.piccolo@unito.it,luca.roversi@unito.it

http://dx.doi.org/10.1016/j.entcs.2016.03.016
1571-0661/© 2016 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

operation then it must increase the entropy of the environment [19]. When a com- putational system erases a bit of information, it must dissipate ln 2 × kT energy, where k is Boltzmann’s constant and T is the temperature. For T = 300 Kelvins (room temperature), this is about 2.9×10−21 Joules (roughly, the kinetic energy of a single air molecule at room temperature). Today’s computers erase a bit of informa- tion (in the above sense) every time they perform a logic operation, so their hunger for energy is ever-increasing. Reversible computing can avoid to use irreversible operations and entropy increasing.
Here above we have recalled the Physics related aspects that make reversible computation relevant. From a Computer Science foundational point of view re- versible computing is interesting because it subsumes classical computing: every computation in a classical model can be simulated by a reversible one [14]. Moreover, aspects of reversible computation are ubiquitous in everyday classical computations. We can find them in activities spanning from software verification to programming languages, passing through computer architectures, as well as part of innovative computing models, like quantum, bio, chemical and molecular ones.
Reversible Turing-machines. Foundational studies on the notion of “re- versible computation” exist. They have been chiefly devoted to frame the thermo- dynamic relations between entropy and computation via Turing-machines [1,2,6]. A reversible Turing-machine is both deterministic (like a classical Turing-machine) and backward-deterministic, i.e. it is bi-directionally deterministic. The backward determinism allows to easily reverse the computation, viz. we can undo a reversible program step by step eventually re-establishing former situations [1]. Only recently, recursion-theoretic arguments have been surveyed with some degree of systematiza- tion in [1].
This work develops a starting proposal to a recursion theory of reversible functions, in the line of Dedekind-Robinson-Kleene.
Dedekind-Robinson-Kleene Functions. We start recalling the distinguishing aspects of Kleene’s Partial Recursive Functions [7], that we simply call Partial Re- cursive Functions, abbreviated as (RF). These functions form an extension of the Dedekind-Robinson Primitive Recursive Functions (PRF) this paper starts from.
Our starting point are RF and PRF for various reasons. First, we want to manage entities that compose because they stand for and are written as functions. Second, RF, as well as PRF, balance intensional and extensional aspects. Intensionally, they can be taken as programming languages whose semantics is given informally. Exten- sionally, RF deals with partial functions 3 while PRF with total ones, both shifting the focus on functions closer to what other computational models can express and providing support to functional, or compositional, programming.

3 A relation between two sets A, B is a subset of the cartesian product A×B. A relation is functional when (a, b), (a, b′) ∈ A × B implies b = b′. A relation is co-functional when (a, b), (a′, b) ∈ A × B implies a = a′. A relation is total whenever a ∈ A implies that b ∈ B exists such that (a, b) ∈ A × B. A relation is co-total whenever b ∈ B implies that a ∈ A exists such that (a, b) ∈ A × B. A function is a total functional relation. A partial function is a functional relation. A function is injective whenever its graph is a co-functional relation. A function is surjective whenever its graph is a co-total relation.

We aim at giving a prominent computational status to the operation of functional inverse. The inverse f−1 of a function f is defined by reversing its underlying relation 4 , viz. (y, x) ∈ f−1 if and only if (x, y) ∈ f .
We focus on bijections, because the inversion of a computable bijection is always a computable function, see [13, p.31].
A little bit more specifically, our goal is the synthesis of a formalism which, at least, describes a reasonable large class of first-order functions whose graphs can be effectively inverted inside the formalism itself. The simple and effective inversion operation that we propose in this work takes great advantage from the compositional nature of the computational model we introduce. As a side effect we shall eventually be able to compare the programming style our computational model supplies with those ones available inside the Reversible Turing Machines as in [1] and Janus [18].
Primitive Recursive functions. We develop our goal gradually. In this paper, we do not aim at the synthesis of a full analogous of RF which, we recall, is Turing-complete. We present what we think is a good candidate we can identify as being the analogous of PRF i.e. a class of terms which could capture all the algorithms developed in mathematics until the first part of XX Century, see [13]. PRF is not Turing-complete and corresponds to a core of RF which only contains everywhere-defined, i.e. total, functions. In analogy to PRF, we supply Reversible Primitive Recursive Functions (RPRF) which always terminate and keeps semantic redundancies at bay (with a relatively light abstract syntax).
We show that PRF can be simulated by RPRF, so RPRF functions inherit the following statement, typically associated to PRF:
“programs which terminate but do not belong to PRF are rarely of practical interest”.
The main problem we must cope with is to identify the right class of total functions acting as the extensional model of reference. Identifying such a class is not obvious for the following reasons.
On one side, we might rely on [1]. It contains a statement saying that Reversible Turing Machines compute injective RF. The statement in [1] seems to suggest to consider the class of Injective Primitive Recursive Functions (JPRF) as our exten- sional model of reference to identify a functional language which is able to talk about reversible functions. This choice is doomed to failure. The reason is that JPRF is not closed under inversion. There is a function f such that its inverse f−1 is not in JPRF. An example is the successor succ on natural numbers. It belongs to JPRF but its inverse succ−1 is undefined on 0 and does not belong to JPRF.
The situation does not improve if we think of restricting our extensional model to BPRF, i.e. the class of all Bijective Primitive Recursive Functions. BPRF is strictly smaller than JPRF, but the problem becomes somewhat “bigger”.
Theorem 1.1 (Kuznekov [8]) There is an f ∈ BPRF whose inverse f−1 does not even belong to PRF.

4 The inverse of a partial function may not be functional. The inverse of a total function may be not total. However, restricted (and effective) operation of inversion can be defined also in such cases, e.g. see [12].

Proof. See [15, Exercise 5.7, p.25]. We sketch the proof. Consider a total com- putable function whose rate of growth is too fast to be primitive recursive, e.g. consider the Ackermann-like function A0(x)= 2x and An+1(x)= An ... An (1).
It is possible to prove that {< x, y > |Ax(x) = y} is primitive recursive, xalthough
x
the injective increasing function x '→ Ax(x) is not. Let R denote the range of x '→ Ax(x), i.e. R = {y|∃x, Ax(x)= y}. R is infinite and co-infinite. The predicate checking y ∈ R is still primitive recursive, because  y−1 Ax(x) = y is primitive

recursive. For an infinite set S ⊆ N, let πs
: N → N be defined as
πS(0)
def
= min(S)

and
πS(n + 1)
= min(S − {πS(0),..., πS(n)}). Patently, if S is primitive recursive

then πs is a primitive recursive bijection (by bounded minimization). Let f be the permutation of N defined by
⎧⎨ 2π−1(y)	if y ∈ R,

Despite f is primitive recursive, its inverse f−1 is not, because f−1(2x)= πR(x)= 
Ax(x).	2
Corollary 1.2 BPRF and general recursive bijections 5 are two diﬀerent classes of functions. In particular, primitive recursive permutations and general recursive per- mutations are diﬀerent classes of functions.
Proof. Let f be the permutation defined in the proof of Theorem 1.1.	2
Moreover, it is not possible to enumerate general recursive permutations because it would provide an effective enumeration of total recursive functions as well.
Theorem 1.3 General recursive permutations cannot be recursively enumerated.
Proof. Assume φ0,..., φn,... be a such effective enumeration. We aim to build a permutation ψ (viz. a bijection on N) different from all enumerated ones.
Assume that there is a k ∈ N such that φ0(0) /= φk(k). We can define ψ by

induction,
ψ(0)
def
= φk(k)
and
ψ(n+1)
def
= min(N−{ψ(0),..., ψ(n), φn+1
(n+1)}).

Let h = φ (0). If φ (i) = h for each i ∈ N then, let
def
. Clearly, ψ is

0	i	ψ(0) = h
different from all φi+1, because each involved function is a bijection. Let m ∈ N

be such that m /= φ (0) = h and m /= φ (1); we can define
def
(so ψ is

0	0	ψ(1) = m
different of φ0 on 1). It is easy to complete the definition of ψ in a suitable way,

e.g.
ψ(n + 2)
def
= min(N − {ψ(0),..., ψ(n + 1)})
2

The above properties forcefully addressed us to look for a class of total com- putable functions F whose main features are that (i) every element of PRF has a

5 Recall that the class of general recursive functions is formed by all and only total recursive functions. Recall that endo-bijections are called permutations.

faithful counterpart in F, (ii) F is rich enough to represent N by means of a suitable encoding and (iii) F can be represented in PRF.
Reversible Primitive Recursive Functions (RPRF). It is the class of functions we propose to fulfill our goals. RPRF includes only bijections and is closed under the meta-operation of inversion which is effective. Moreover, RPRF is expres- sive enough to represent PRF and, in particular, the gödelization.
Related Papers.  In [11] a reversible for-language has been proposed and
studied. The programs of such a language only expresses total reversible functions. The language is presented in a very appealing programming style which does not make the comparison with the terms of RPRF immediate. The work [11] mainly aims at an algebraic and programming study of reversibility. In particular, it does not characterize the set of functions that can be represented. Our conjecture is that the language in [11] would be equivalent to the set of functions in RPRF only once extended with stack-like data-types.
A work that introduces a language related to RF is [5]. First it provides a rep- resentation of the full set of invertible partial recursive functions between natural numbers, unlike ours. Moreover, a second difference with RPRF is that the language in [5] heavily depends on the explicit binary representation of numbers. This differ- ence is essential for us, since we aim at characterizations independent from the data representation as for Dedekind-Robinson-Kleene ones.
Reversible Primitive Recursive Functions
We introduce the class of Reversible Primitive Recursive Functions that we abbre- viate as RPRF. RPRF includes only total functions. Among them we show that all primitive recursive functions can be represented by using an embedding technique that recalls the ones we can find in [2,17,18]. One novelty of RPRF, as compared to the class of primitive recursive functions (and classic recursion theory), is that its functions operate on integers instead than on natural numbers (as first proposed in [11]). The reason is that natural numbers do not form a group (endowed by inverses) with standard operations. Another peculiar aspect of RPRF is that it is closed under inversion in an effective way.
Some preliminary steps are worth giving before formally introducing RPRF.
We use Z to denote the set of integers and N to denote the set of natural num- bers 6 . Consider a function f : Xn → Y m where X, Y are sets and n, m ∈ N; we say that f is arity-respecting if X = Y and n = m. For sake of simplicity, we restrict ourselves to consider only arity-respecting functions so to include only permutations. Finally, let «_, _» : Z2 → Z be a given bijection. For our purposes its full definition is irrelevant 7 .
Definition 2.1 [Reversible Primitive Recursive functions ] The set RPRF of

6 We recall that N and Z are in bijection, see [3, Example 5.1].
7 For those who are curious, «_, _» can be defined by suitably composing the bijection between N ↔ Z
as in the Example 5.1 of [3] and Cantor’s pairing variant defined in [4] which is a bijection as well.

Reversible Primitive Recursive functions contains total functions from Zk to Zk, for every k ≥ 0. We inductively define RPRF as follows.
RPRF includes the successors Si(x1,..., xi,..., xk)= (x1,..., xi + 1,..., xk) and
the predecessors Pi(x1,..., xi,..., xk)= (x1,..., xi − 1,..., xk) where 1 ≤ i ≤ k.
RPRF includes every finite permutation of a k-tuple, defined as follows. Let l =
i1,..., ik be an ordered list of pairwise distinct natural numbers from 1 through
k. The associated finite permutation is fPl(x1,..., xk)= (xi1 ,..., xik ).
Let j, k ∈ N be greater than 1 and let k1,..., kj ∈ N be such that k = Σj	ki. For
every 1 ≤ i ≤ j, let gi : Zki −→ Zki and f : Zk −→ Zk belonging to RPRF. The se-

ries composition of f with g1,..., gj from Zk to Zk is	1
#„	#„
j	1	j

#„	#„
[f ; g ,...,g ]( x
,..., x )= 

f (g1( x 1),..., gj( xj)) and belongs to RPRF. Of course, for every 1 ≤ i ≤ n, we
assume that #„ contains ki elements.
RPRF includes the pairing functions addPair(i,j), subPair(i,j) : Zk → Zk such that
h	h
1 ≤ i < j ≤ k, 1 ≤ h ≤ k and h /= i, j. The function addPair(i,j) is the identity on all arguments but the one in position h. This latter is incremented by «xi, xj». The function subPair(i,j) is the identity on all arguments but for the one in position
h. This latter is decremented by «xi, xj». For example, addPair(2,3)(n, x, y,.. .)= (n + «x, y», x, y,.. .) and subPair(2,3)(n, x, y,.. .) = (n − «x, y», x, y,.. .) where

1 ≤ i < j ≤ k.
RPRF includes the unpairing functions addUnPair(i,j), subUnPair(i,j)
: Zk → Zk

h	h
such that 1 ≤ i < j ≤ k, 1 ≤ h ≤ k and h /= i, j. The function addUnPair(i,j) is the identity on all its arguments but those ones in positions i and j-th. They are incremented by x and y, respectively, if «x, y» is the argument of position h. The function subUnPair(i,j) is the identity on all arguments but those ones in positions i and j-th. They are decremented by x and y, respectively, if «x, y» is the argument of position h. For instance, addUnPair(2,3)(«xj, yj», x, y,.. .)= («xj, yj»,x + xj,y +
yj,.. .) and subUnPair(2,3)(«xj, yj», x, y,.. .) = («xj, yj»,x − xj,y − yj,.. .) where

1 ≤ i < j ≤ k.
...

Let f, g, h : Zk −→ Zk be elements of RPRF. For every n ≥ 0, let f n denote
[f ; ... ◦ [f ; f ] .. .] with n occurrences of f . RPRF includes the recursive scheme
Reci[f, g, h]: Zk+1 → Zk+1, for each i such that 1 ≤ i ≤ k + 1, defined as follows:

#−„	#„
.y..
#−„ #„
#−„ #„

⎧⎪⎨(x1, y, z1)	if y > 0 and h
(x0, z0)= (x1, z1)
 	 


⎪⎩ #−„	#„
...
#−„ #„
#−„ #„

and belongs to RPRF. Of course, we assume that #−„ #−„ contain i − 1 elements,

#„	#„
x0, x1

while z0 and z1 contain (k + 1) − i elements.	2
Definition 2.1 follows the pattern that drives the definition of Primitive Recursive Functions (PRF) but shows distinctive features. Among the basic functions RPRF explicitly contains the predecessor, unlike PRF. Projections are missing from RPRF,

because intrinsically irreversible. We “replace” them with all finite permutations.
For sake of completeness, we remark that subUnPair(i,j), subPair(i,j) can be de-
h	h
fined in terms of addUnPair(i,j), addPair(i,j). This means that addUnPair(i,j), addPair(i,j)
h	h	h	h
and addUnPair(i,j), addPair(i,j) are pairwise interdefinable. The only existing defini-
h	h
tion of a class of functions we are aware of and which makes use of pairing and
unpairing is by Bernays and Robinson, see [13, p.72]. They used pairing and un- pairing for a non standard definition of PRF, like we do. The main motivation to let pairing and unpairing available is to pack the information. A single argument can be used as a kind of store, like the coming example shows.  The composi-
tion fP2,1,3,4 ◦ subUnPair(1,4) ◦ addPair(1,4) ◦ subUnPair(2,3) ◦ addPair(2,3) transforms
2	2	1	1
(0, x2, x3, x4) in (««x2, x3», x4», 0, 0, 0) as follows:
fP1,2,3,4 ◦ subUnPair(1,4) ◦ addPair(1,4) ◦ subUnPair(2,3) ◦ addPair(2,3)(0, x2, x3, x4)
2	2	1	1
= fP2,1,3,4 ◦ subUnPair(1,4) ◦ addPair(1,4) ◦ subUnPair(2,3)(«x2, x3», x2, x3, x4)
2	2	1
= fP2,1,3,4 ◦ subUnPair(1,4) ◦ addPair(1,4)(«x2, x3», 0, 0, x4)
2	2
= fP2,1,3,4 ◦ subUnPair(1,4)(«x2, x3», ««x2, x3», x4», 0, x4)
= fP2,1,3,4(0, ««x2, x3», x4», 0, 0) = (««x2, x3», x4», 0, 0, 0) .
We remark that adding pairing-unpairing functions (non arity-respecting, similar to that of Bernays and Robinson) to RPRF will still provide a correct model of reversible computation.
The composition among elements of RPRF has no major differences with the composition scheme of PRF. The recursion scheme is, in fact, an iterator. It itera- tively applies one of the three parameters in RPRF as many times as the value of the argument in position i if xi /= 0, one time otherwise. The value of that argument is not passed to the iterated function. Instead, it is preserved by the whole evaluation and reappears untouched as part of the result. Of course the i-th argument can be negative. We take into account this case by using its absolute value for driving the iteration.
We define some functions that will be useful later. For every k ∈ N, the identity
Idk #„	#„
( x )= x is the permutation that does not exchange any of its k arguments. When
clear from the context, we omit the arity apex. Given two functions f, g : Zk → Zk, we abbreviate ◦[f ; g] by means of the more standard f ◦ g. Let fi : Zki −→ Zki
and let #„  contains ki elements for every 1 ≤ i ≤ n.	The parallel composi-

tion of f ,...,f 
from Zk1+···+kn to Zk1+···+kn is			#„
#„	def

1
Idk1+···+kn
#„ n	#„
(f1	...	fn)( x 1,..., xn) =

(f1( x 1),..., fn( xn)).
We define an inversion operation that maps RPRF to RPRF in an effective way.
Definition 2.2 The function ® : RPRF → RPRF is defined inductively as follows.

®(S)
= P and ®(P)
def
= S

For each permutation fPl, ®(fPl) is equal to the (unique) finite permutation fPl′
that inverts fPl. Patently, this permutation always exists and belong to RPRF.

®(◦[f ; g1,..., gj])
def
= ◦[(®(g1)	...	®(gn)); ®(f )]

®(addPair(i,j)
def
(i,j)
(i,j)
def
(i,j)

h	) = subPairh	and ®(subPairh	) = addPairh	.

®(addUnPair(i,j)
def
(i,j)
(i,j)
def
(i,j)

h	) = subUnPairh	and ®(subUnPairh	) = addUnPairh	.

®(Reci
[f, g, h])
= Rec [®(f ), ®(g), ®(h)].

Indeed RPRF is closed under inversion in the following strong sense.
Theorem 2.3 (RPRF is closed under inversion) If f : Zk → Zk is a RPRF

then,	#„	#„
#„	#„

f ( x )= y if and only if ®(f )( y )= x.
Proof. The proof is by induction on the Definition 2.2.	2
Corollary 2.4 Each RPRF is a bijective function on Zk, for some k ∈ N.
Theorem 2.3 technically justifies why RPRF works on Z instead of N. If the issue is to define a theory of computable reversible functions, the restriction to N and to a class of functions where the predecessor cannot be a primitive function looks artificial. This position, which we share with [11], will be reinforced by the coming sections, where we show that RPRF is complete with respect to PRF which means that we are developing a theory of computable functions which are reversible, indeed.
Expressiveness of RPRF
We define some functions in RPRF. First we want to suggest how Bennett’s technique fits into RPRF. Second, we want to give a flavor about the expressiveness of the class of reversible functions we just introduced. Let k ∈ N.
Let inc : Z2+k → Z2+k be defined as Rec2[S1, Id, P1], that is inc(n, x,  ) = (n +
x, x, . . .). The function inci : Z2+k → Z2+k generalizes inc by involving the values of the arguments in position i and j, provided that i /= j and 1 ≤ i, j ≤ 2+ k. The first one drives the iteration. The value of the latter gets added to the value of the first as follows:
j—1	j—1
inci (¸... x, `n,. .˛., x,.. .)= (¸... x, `n,. .˛.,x + n, . . .) .
If j < i then we can define inci as Reci[Sj, Id, Pj]. If i < j then we can define
inci as Reci[Sj—1, Id, Pj—1] because xi is hidden by recursion, see Definition 2.1.
Remark that if xi is negative then we subtract it from x.
The function deci : Z2+k → Z2+k involves the values of the arguments in position i and j, provided that i /= j and 1 ≤ i, j ≤ 2+ k. The first one drives the iteration. The value of the latter gets subtracted from the value of the first as follows:
j—1	j—1
deci (¸... x, `n,. .˛., x,.. .)= (¸... x, `n,. .˛.,x − n, . . .) .

If j < i then we can define deci as Reci[Pj, Id, Sj], otherwise Reci[Pj—1, Id, Sj—1].
Remark that ®(deci )= inci .
j	j
If sum : Z3+k → Z3+k is defined as inc3 ◦ inc2 then sum(n, x1, x2,.. .) = (n +
1	1
x1 + x2, x1, x2,.. .). Moreover, ®(sum)(n, x1, x2,.. .) = (n − x1 − x2, x1, x2,.. .).

The natural generalization under the same pattern as inci
and deci
is sum(i,j) :

Z3+k → Z3+k which adds the arguments of position i and j to the one of position h, provided that i, j, h are pairwise distinct and 1 ≤ i, j, h ≤ 2+k. We remark that sum(9, 5, −3) = (11, 5, −3). Generally speaking, the sum of two numbers needs an argument initialized to zero. This is a the typical side-effect of representing an inherently non-reversible function by a reversible one. To avoid such a side effect,
[2] uses a third tape and [17] uses some input-constant.
We define mult : Z3+k → Z3+k by means of Rec3[inc2, Id, dec2]. It is easy to verify
1	1
that mult(n, x1, x2,.. .)= (n + x1 + ... + x1, x1, x2,.. .). and, on the other hand,
`	˛x¸2	x
`	˛x¸2	x
Z3+k → Z3+k, which adds the products of the i, j-th arguments to the h-th one, is:


j—1
¸	ix—`1 x`˛	˛


j—1
¸	ix—`1 x`	˛	˛



can be defined by mult(i,j) = Recj[inci , Id, deci ], provided that 1 ≤ h < i < j ≤
h	h	h
3+ k. It is easy to adapt the previous definition to all ordering of i, j, h provided
that they are pairwise distinct.
Let square : Z3+k → Z3+k be defined as dec2◦mult(2,3)◦inc2, so square(0, x, 0,.. .)= 
3	1	3
(x2, x, 0,.. .). We emphasize that the square operator rests on the assumption that a zero-valued argument (the third one) is available.
The coming examples introduce functions deliberately defined to behave like the identity on negative inputs. This simplifies their definition but leave them general enough to represent various interesting functions. We can obtain such a behavioral asymmetry by exploiting the branching mechanism of Rec—[_, _, _] that allows to determine the sign of one of its arguments.
The (total) predecessor restricted to positive numbers totalNatPred : Z2+k → Z2+k
can be defined as S2 ◦ Rec2[S1, Id, Id] ◦ P2. The defined function grants that if x ≥ 0
then totalNatPred(0, x,.. .)= ((x −. 1), x,.. .), otherwise totalNatPred(0, x,.. .)= (0, x,.. .).
The (total) subtraction restricted to positive numbers totalNatMinus : Z3+k →
Z3+k can be defined as inc3 ◦ Rec2[S1, Id, Id] ◦ dec3 (where dec is defined above),

2
that is totalNatMinus(0, x1, x2,.. .)= ((x1 −.
2
x2), x1, x2,.. .).

We define the factorial fact : Z6+k → Z6+k such that, whenever x ≥ 0 we have
fact(0, x, 0, 0, 0, z,.. .)= (x!, x, x, x!, zj,.. .).
Let l1,3 be the finite list swapping first and third arguments and let l4,5 be the finite list swapping 4th and 5th arguments, being the identity elsewhere.
Let clean3 be fPl	◦ subUnPair(3,5) ◦ addPair(3,5); it is easy to see that it satisfies
4,5	4	4
clean3(x1, x2, x3, 0, x5,.. .)= (x1, x2, 0, 0, «x3, x5»,.. .).

Finally, fact is Rec2[clean3 ◦ mult(2,3) ◦ S2 ◦ fPl
, Id, Id] ◦ S1. (Remind that the

1
recursion hide an argument).
1,3

Primitive Recursive functions and RPRF
We recall the class of Primitive Recursive Functions (PRF), see for instance [3,13]. It is the smallest class of functions on natural numbers:
which contains the functions 0( x ) = 0, the successor S(x) := x +1 and the projections πk(x1,..., xk) := xi for all k ≥ i ≥ 1,
which is closed under composition, i.e. the schema that given g1,..., gm,h of

suitable arities, produces	#„
#„	#„
1	m
), and

which is closed under primitive recursion, viz. the function f which is defined

from g and h by means of the schema	#„
#„  and	#„

#„	#„
f ( x, 0) := g( x )
f ( x, y + 1) :=

h(f ( x, y), x, y).
In coming subsections we show the computational equivalence of PRF and RPRF.
From PRF to RPRF
We present a formal correspondence between PRF and RPRF. Specifically, for any f ∈ PRF, we show how to define a corresponding function in RPRF which, suitably restricted in domain and range, extensionally behaves as f , of course, exploiting that N ⊆ Z.
Definition 3.1 [RPRF-deﬁnable functions ] A function f : Nk → N is RPRFk- definable (for h ≥ 3) whenever there exists a function f : Zk+h → Zk+h in RPRF such that, for all x1,..., xk,z ∈ N, if f (x1,..., xk)= y then
f (0, x1,..., xk, 0,..., 0, z)= (y, x1,..., xk, 0,..., 0, zj)
` h˛—¸2 x	` h˛—¸2 x
for some zj ∈ N.	2
We write f ∈ RPRFk to denote that f represents f which is RPRFk-definable.
Some remarks on Definition 3.1 are in order. Extensionally, every f behaves as an identity on all its arguments, but on the first and the last ones. This means that every argument with position 2 ≤ i ≤ k + h − 1 are moved to the output. (We remark that in the intensional “intermediate computation steps” these arguments can be altered). The last argument, with position k + h, plays the role of a waste bin

that we shall operate on, as it was a stack. The first argument, which conventionally carries the value 0, balances the presence of the first output which contains the value f (x1,..., xk) of the function we encode. Only the presence of the first argument makes the input and the output arities equal.
Lemma 3.2 (“Weakening” on the map ( )) For every f : Nk → N, if f is
RPRFk-definable, then f is also RPRFk	-definable.
h	h+1
Lemma 3.2 holds because, if f : Nk → N is defined by f ∈ RPRFk for some h ≥ 3
then ®fPl ◦ (f  Id) ◦ fPl, where l = 1,...,k + h + 1,k + h, represents f in RPRFk	.
We remark that ®fPl = fPl.
The two following functions of RPRF  makes evident why we consider the last argument, and the last output of a given ( ) a sort of waste bin which we use as a stack.
Definition 3.3 We call nS-tuple each tuple of Nn such that S ⊆ {1,..., n} and for all i ∈ S the i-th position of the tuple is 0 (no assumptions are done on the other positions). For any n ∈ N such that n ≥ 3, let l = 1,..., n,n − 1.
We denote push the term fPl ◦ subUnPair(i,n) ◦ addPair(i,n) that maps a n{n—1}-tuple

i
to a n{i,n—1}-tuple as follows:
n—1
n—1

pushi(..., xi—1, xi, xi+1,..., 0, xn)= (..., xi—1, 0, xi+1,..., 0, «xi, xn»)  .
Symmetrically, we denote pop the term subPair(i,n) ◦ addUnPair(i,n) ◦ fPl that maps

i
a n{i,n—1}-tuple to a n{n—1}-tuple as follows:
n—1
n—1

popi(..., xi—1, 0, xi+1,..., 0, «xi, xn»)= (..., xi—1, xi, xi+1,..., 0, xn)  .
2
The condition “ n ≥ 3” of Definition 3.3 is an instance of the inequality “h ≥ 3” in Definition 3.1. The operations of Definition 3.3 act on the last argument, but they use an auxiliary argument (the second last one) to be performed. This fact justifies the introduction of the constraint “ h ≥ 3” of Definition 3.1 whose ultimate meaning is to assure that: (i) the first argument returns the output of the defined function, (ii) the last argument is a sort of waste bin, and (iii) the penultimate input and output positions serve to correctly apply pushi and popi.
We can finally state the main theorem of this work.
Theorem 3.4 Every f ∈ PRF is RPRF-definable.
The proof of Theorem 3.4 is by induction on the definition of f ∈ PRF. For sake of simplicity, we present some of its cases in an exemplified form.

Let f be 0 : Nk → N for some fixed k. We can define 0 := Idk+3 with input and out- put arity k + 3. The definition should not surprise because 0(0, x1,..., xk, 0, y)= (0, x1,..., xk, 0, y), so it is RPRFk-definable.
Let f be πk : Nk → N for some fixed k. We can define πk := inci+1. (inci+1 is
i	i	1	1



defined in Section 2.1.) So, πk(0, x1,..., xk, 0, y) = (0 + xi, x1,..., xk, 0, y) and projections are RPRFk-definable.
Let f be S : N → N. We can define S := S1 ◦inc2 with input and output arity 1+3. So, S(0, x1, 0, y)= S1(0 + x1, x1, 0, y)= (x1 + 1, x1, 0, y) and the PRF-successor is RPRF1-definable.

Let f : Nk → N be a PRF defined as	#„
#„	#„
1	m
where h :

Nm → N, gi : Nk → N are PRF. Let gi be RPRFk -definable, for all i such that
1 ≤ i ≤ li, and let h be RPRFm-definable. Assume l = max{l1, l2, l3, lh} and
lj =3 + m · (k + l) so that, there are g1, g2, g3 ∈ RPRFk and h ∈ RPRFm	. We

l
aim at building a f ∈ RPRFk defining f .
l′—m

For sake of simplicity, we do not present the more general case but we discuss in detail the case m = 3, k =2 and l = 3, which shows all the technical problems. Still, to simplify the reading we proceed step-by-step.
We are looking for a f ∈ RPRF2 thus, by Definition 3.1, we expect an input of
the shape 0, x1, x2, 0,..., 0, 0,z with 20 arguments.
`˛1¸5x	3       	2
Z20 → Z20 because g1, g2, g3 ∈ RPRF2. So, we apply the next RPRF-functions:

inc2
◦ inc2 ◦ inc2 produces 0, x1, x2, 0, x1, 0, 0, 0, 0, x1, 0, 0, 0, 0, x1, 0, 0, 0, 0, z;


3	3	3 produces
`	˛5¸	x `	˛5¸	x `	˛5¸	x	.


The application of	3 
	 `	2˛5¸	x `	˛5¸	x `	˛5¸	x

0, x1, x2, g1(x1, x2), x1, x2, 0, z1, g2(x1, x2), x1, x2, 0, z2, g3(x1, x2), x1, x2, 0, z3, 0,z .
5	5	5
Now, we predispose the arguments for the application of Id2  h where h ∈
RPRF3 by pushing useless values on our “stack”, by erasing copies of x1 and x2
and by permuting arguments:
let z∗ = «z1, «z2, «z3, z»»», so push18 ◦ push13 ◦ push8 produces
0, x1, x2, g1(x1, x2), x1, x2, 0, 0, g2(x1, x2), x1, x2, 0, 0, g3(x1, x2), x1, x2, 0, 0, 0, z∗ ;
`	˛5¸	x `	˛5¸	x `	˛5¸	x

dec3 ◦ dec2 ◦ dec3 ◦ dec2 ◦ dec3 ◦ dec2 produces
16	15	11	10	6	5
0, x1, x2 g1(x1, x2), 0, 0, 0, 0, g2(x1, x2), 0, 0, 0, 0, g3(x1, x2), 0, 0, 0, 0, 0, z∗ ;
 	     		 	     		 	     	
5	5	5
a suitable finite permutation fPl2 can produce




Since f (x1, x2) = h(g1(x1, x2), g2(x1, x2), g3(x1, x2)), the application of Id2  h




By applying push

push	push

we push
`˛1¸2x

on the

“stack”.
4 ◦	5 ◦	6
g1(x1, x2), g2(x1, x2), g3(x1, x2)

We conclude by permuting the f (x1, x2) with the first two arguments. Thus we
obtain, f (x1, x2), x1, x2, 0,..., 0, 0, z5 that respecting the Definition 3.1 makes
2	`˛1¸5x
f a RPRF18-definable function.
Let f : Nk+1 → N be a PRF defined by means of h : Nk+2 → N and g : Nk → N, i.e.

by means of the schema	#„
#„ and	#„
#„	#„
. Let h

be RPRFk+2-definable and let g is RPRFk -definable. Assume l = max{lg, 3+lh} so
lh	lg
that, there are g ∈ RPRFk and h ∈ RPRFk+2. We aim at building a f ∈ RPRFk+1.
l	l—3	l
For sake of simplicity, we do not present the more general case but we discuss
in detail the case k = 2, lg = 3 and lh = 5, which shows all the technical problems. Still, to simplify the reading, we proceed step-by-step. We remind that the evaluation of the PRF function f (−→x, n) starts by evaluating g(−→x ) and proceeds by iteratively applying h as many times as n.
We are looking for f ∈ RPRF3 thus, by Definition 3.1, we would expect an input of the shape 0, x1, x2, y, 0, 0, 0, 0, 0, 0,z containing 11 arguments.
We want to predispose the arguments for Id1  g that, belongs to Z11 → Z11 because g ∈ RPRF2. Thus, we apply a suitable finite permutation prefixing y to the remaining argument-list.
The application of Id1  g produces y, g(x1, x2), x1, x2, 0, 0, 0, 0, 0, 0, z.
The more tricky point is the simulation of the primitive-recursion by means of the reversible-recursion.
We move an argument from position 5 to position 2 (by means of a finite permutation), obtaining y, 0, g(x1, x2), x1, x2, 0, 0, 0, 0, 0, z. Since we want to use y to drive the recursion, we need to define an auxiliary function h∗ : Z10 → Z10 making Rec1[h∗, Id10, Id10] our recursive block. We remark that y (i.e. the first argument) is excluded by the argument-list provided to h∗ by Definition
2.1. Thus, the argument-list supplied to h∗ is 0, g(x1, x2), x1, x2, 0, 0, 0, 0, 0,z 
containing 10 values.
The main issue for getting to the definition of f is that each application of h∗ requires an argument-list which carries the information about how many times h∗ has already been applied. The value zero of position 5, which we increment at each step, serves to provide such an information to h∗. Additionally, at each recursive step, we push the previous result (in position 2) and, finally, we permute the first two positions of the argument-list (i.e. we put a zero in the position 1 and we make the new intermediary result available) by using a suitable finite permutation fPl3 . Formally, we define h∗ as fPl3 ◦ push2 ◦ S5 ◦ h,

so that
h∗(0,f (x1, x2, n), x1, x2, n, 0, 0, 0, 0, z)= 
fPl3 ◦ push2 ◦ Si(f (x1, x2,n + 1),f (x1, x2, n), x1, x2, n, 0, 0, 0, 0, z)= 
fPl3 ◦ push2(f (x1, x2,n + 1),f (x1, x2, n), x1, x2,n + 1, 0, 0, 0, 0, z)= 
fPl3 (f (x1, x2,n + 1), 0, x1, x2,n + 1, 0, 0, 0, 0, «f (x1, x2, n), z»)= 
(0,f (x1, x2,n + 1), x1, x2,n + 1, 0, 0, 0, 0, «f (x1, x2, n), z»)
which is ready for the next recursive step. Notice that h∗ does not respect Definition 3.1 (because the fifth argument), so h∗ does not define a PRF function. However, it is sufficient that the f (we want define) respects Definition 3.1.
The application of Rec1[h∗, Id10, Id10] to y, 0, g(x1, x2), x1, x2, 0, 0, 0, 0, 0, z, pro- duces y, 0,f (x1, x2, y), x1, x2, y, 0, 0, 0, 0, zj for some zj.
We can conclude by eliding the a copy of y by applying dec6 and then applying a suitable finite permutation moving the first two arguments just before the last one. Hence, f is RPRF2 -definable.
From RPRF to PRF
We think that the mere intuition should convince that whatever we can compute inside RPRF we can also compute inside PRF. This subsection contains basic hints to make the intuition concrete.
We start recalling from [3, Example 5.1] the two following isomorphic maps
α : Z → N and α—1 : N → Z:

α(x)= 
2x	if x ≥ 0
−2x − 1	if x < 0 ,

α—1
(x) = 
x 	
2
x+1 2
if x is even if x is odd .

Then, we fix the meaning of representing every multi-output element of RPRF by means of single-output elements in PRF. For every f ∈ RPRF with arity k, the map ( ) supplies a family f = {fi : Nk → N}1≤i≤k of functions in PRF which satisfy the following constraints:
(α—1 ◦ πi ◦ f )(x1,..., xk)= fi(α(x1),..., α(xk))	1 ≤ i ≤ k .
We do not supply a full blown definition of ( ). We just give the translation of some of the basic functions of RPRF. To that purpose, let us recall that we can define the sum +, the multiplication × and the following functions as elements of PRF:

Not(x)=	1	if x is 0
0	if x is 1
isE?(x)=	1	if x is even
0	otherwise
isZ?(x)=	1	if x =0 
0	otherwise
isO?(x)=	1	if x is odd
0	otherwise	.

The inductive definition of ( ) proceeds by cases on its argument. We start making P explicit because the predecessor is a sort of conceptual pivot around which many of our design choices relative to RPRF rotate. Inside PRF the predecessor implements the following function on N:

P(x)=	x − 1	if x > 0
0	otherwise	.

It cannot break through the barrier that 0 represents. Instead, the predecessor of RPRF is primitive and can decrease any of its arguments. It follows that P must allow to move along even numbers to simulate P ∈ RPRF on positive values, and along the odd ones to simulate it on negative values with particular attention to the zero-valued argument. The family P needs only to contain the following single element:
S(S(x)) × isO?(x)+ isE?(x) × (P(P(x)) × Not(isZ?(x)) + S(x) × isZ?(x))) .
It increments twice every odd argument, which comes from a negative value. In case of an even x, it distinguishes whether x is either greater than or equal to 0. In the last case it increases x once, so that the final value, through α—1(x), becomes −1.
The translation of S does non need to discriminate a zero-valued argument, among the even ones. Its unique function is:
P(P(x)) × isO?(x)+ S(S(x)) × isE?(x) .

Finally, the definition of fPl, with arity k and l ≡ i0,..., ik—1, necessarily requires a family fPl with k elements:
fPl = {fi (x0,..., xk—1)= πk (x0,..., xk—1)}i ∈l .
j	ij	j
Both ◦[f ; g1,..., gj] and Rec[f, g, h] of course are a bit more involved. We leave them to an extended version of this work.

Conclusions
We conjecture that the proof of Theorem 1.1 can be generalized to prove that each language of functions being sufficiently expressive to code and decode TM- configurations either is complete or it lacks to contain one of its inverse (i.e. it is not closed by inversion).
It is an open issue if pairing and unpairing functions included in Definition 2.1 are independent from the remaining functions.
We plan to explore the above questions in order to build an extension of our language providing a fully blown characterization of reversible functions.

References
H. B. Axelsen and R. Glück. What do reversible programs compute? In 14th International Conference on Foundations of Software Science and Computational Structures, volume 6604 of Lecture Notes in Computer Science, pages 42–56. Springer, 2011.
C. H. Bennett. Logical reversibility of computation. IBM J. Res. Develop., 17:525–532, 1973.
N. Cutland. Computability: An Introduction to Recursive Function Theory. Cambridge University Press, 1980.
J. E. Hopcroft, R. Motwani, and J. D. Ullman. Introduction to Automata Theory, Languages, and Computation (3rd Edition). Addison-Wesley Longman Publishing Co., Inc., Boston, MA, USA, 2006.
G. Jacopini and P. Mentrasti. Generation of invertible functions. Theor. Comput. Sci., 66(3):289–297, 1989.
G. Jacopini, P. Mentrasti, and G. Sontacchi. Reversible turing machines and polynomial time reversibly computable functions. SIAM J. Discrete Math., 3(2):241–254, 1990.
S. Kleene. Introduction to Metamathematics. Bibliotheca Mathematica. Wolters-Noordhoff, 1952.
A. V. Kuznecov. On primitive recursive functions of large oscillation. Doklady Akademii Nauk SSSR, 71:233–236, 1950. In russian.
R. Landauer. Irreversibility and heat generation in the computing process. IBM J. Res. Dev., 5(3):183– 191, 1961.
Y. Lecerf. Machines de turing réversibles. Comptes Rendus Hebdomadaires des Séances de L’académie des Sciences, 257:2597–2600, 1963.
A. B. Matos. Linear programs in a simple reversible language. Theor. Comput. Sci., 290(3):2063–2074, 2003.
J. McCarthy. The inversion of functions defined by turing machines. In C. Shannon and J. McCarthy, editors, Automata Studies, Annals of Mathematical Studies, 34, pages 177–181. Princeton University Press, 1956.
P. Odifreddi. Classical recursion theory: the theory of functions and sets of natural numbers. Studies in logic and the foundations of mathematics. North-Holland, 1989.
K. S. Perumalla. Introduction to Reversible Computing. Chapman & Hall/CRC Computational Science. Taylor & Francis, 2013.
R. Soare. Recursively Enumerable Sets and Degrees: A Study of Computable Functions and Computably Generated Sets. Perspectives in Mathematical Logic. Springer, 1987.
L. Szilard. Über die entropieverminderung in einem thermodynamischen system bei eingriffen intelligenter wesen. Zeitschrift für Physik, 53(11-12):840–856, 1929.
T. Toffoli. Reversible computing. In J. W. de Bakker and J. van Leeuwen, editors, Automata, Languages and Programming, 7th Colloquium, Noordweijkerhout, The Netherland, July 14-18, 1980, Proceedings, volume 85 of Lecture Notes in Computer Science, pages 632–644. Springer, 1980.
T. Yokoyama, H. B. Axelsen, and R. Glück. Principles of a reversible programming language. In
A. Ramírez, G. Bilardi, and M. Gschwind, editors, Proceedings of the 5th Conference on Computing Frontiers, 2008, Ischia, Italy, May 5-7, 2008, pages 43–54. ACM, 2008.
H. Zenil. Information theory and computational thermodynamics: Lessons for biology from physics.
Information, 3(4):739–750, 2012.
