Electronic Notes in Theoretical Computer Science 120 (2005) 145–157 
www.elsevier.com/locate/entcs


A Fast Algorithm for Julia Sets of Hyperbolic Rational Functions
Robert Rettinger 1
Department of Computer Science FernUniversitaet Hagen
Hagen, Germany

Abstract
Although numerous computer programs have been written to compute sets of points which claim to approximate Julia sets, no reliable high precision pictures of non-trivial Julia sets are currently known. Usually, no error estimates are added and even those algorithms which work reliable in theory, become unreliable in practice due to rounding errors and the use of fixed length floating point numbers.
In this paper we prove the existence of polynomial time algorithms to approximate the Julia sets of given hyperbolic rational functions. We will give a strict computable error estimation w.r.t. the Hausdorff metric on the complex sphere. This extends a result on polynomials z '→z2 + c, where
|c| < 1/4, in [10] and an earlier result in [12] on the recursiveness of the Julia sets of hyperbolic
polynomials.
The algorithm given in this paper computes Julia sets locally in time O(k · M (k)) (where M (k) denotes the time needed to multiply two k-bit numbers). Roughly speaking, the local time com-
plexity is the number of Turing machine steps to decide a set of disks of spherical diameter 2−k so that the union of these disks has Hausdorff distance at most 2−k+2. This allows to give reliable pictures of Julia sets to arbitrary precision.
Keywords: Julia Sets, Computational Complexity.


Introduction
Julia sets provide some of the most striking illustrations of how an apparently simple process can lead to highly intricate sets. Since they are a seemingly unexhaustable source of fantastic shapes and images (e.g.  [9]), numerous

1 Email: robert.rettinger@fernuni-hagen.de



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.06.041


computer programs have been written for generating pictures of Julia sets. Algorithms for computing approximations of Julia sets can be found e.g. in
[11] and [8]. It has turned out that increasing precision (zooming) requires rapidly increasing computation time. Since usually the programs are realized on computers operating on floating point numbers of fixed length instead of real numbers, high precision pictures reflect effects of the rounding procedure rather than the intended Julia set. Therefore, presumably nobody has ever seen the micro-micro-micro structure of non-trivial Julia sets.
In this paper we give algorithms to compute the Julia sets of hyperbolic rational functions locally in time O(k M (k)) (where M (k) denotes the time needed to multiply two k-bit numbers) on Turing machines, i.e. with a detailed analysis of rounding errors. Roughly speaking, the local time complexity is the number of Turing machine steps to give a (zoomed) set of pixels with Hausdorff distance at most 2−k+2. This gives the first polynomial bound on the complexity of such a general and rich class of Julia sets and extends a result of Rettinger and Weihrauch in [10], where a similar algorithm is given for polynomials z '→z2 + c for |c| < 1/4. Furthermore, in [12] it is shown that the Julia sets of hyperbolic polynomials are recursive. However, the methods used in [12] cannot be applied to estimate computational complexity. In [6] it is shown that for fractal subsets of the Euclidean space computational complexity and Hausdorff dimension are independent.
In the next section we will give some basic general facts about Julia sets. In Section 3 we mainly discuss extensions to the local repelling property of J . This result allows us to use similar ideas to [10] even in the general case of rational functions. In Section 4 we then give and discuss the definition of local complexity on C∞. Finally, in Section 5 we present our algorithms for Julia sets of hyperbolic rational functions. The algorithm for rational functions of degree at least 2 will be divided into a general preliminary phase, discussed in Subsection 5.1, and a main phase, discussed in Subsection 5.2.

Julia Sets
In this section we will give some basic notions and notations on Julia sets. Many of the results presented in this section are from the book [2] where many more details on Julia sets of rational functions can be found. Other valuable sources are [3], [5], [1], [8] and [7].
The set of rational, real and complex numbers are denoted by Q, R and C, respectively. We consider polynomials p(z) = an · zn + ... + a0 ∈ C[z] of one complex variable, where an = 0 is the leading coefficient and n is the degree of p, and rational functions r(z) = p(z)/q(z), where p and q are polynomials.


The degree of r is the maximum of the degrees of p and q, where we assume that p and q don’t have any non-constant factors in common.
As usually we denote the n-th iterate and the derivative of a function f by fn and f ', respectively. A complex number z is called a fixed point of a function f iff f (z) = z. z is called periodic point of f iff z is a fixed point of some iterate of f . A fixed point z is called repelling, attracting or indifferent iff f '(z) > 1, f '(z) < 1 or f '(z) = 1, respectively. Similarly, periodic points are classified (where f have to be replaced by a sufficient iterate). We call z a critical point of f iff f '(z) = 0.
Definition 2.1 The Julia set J (r) of a rational function r is the closure of all repelling periodic points of r.
There are many more equivalent characterizations of Julia sets, e.g. a point z is in the Julia set of a rational function r iff the sequence {rn} is not normal (or equivalently not equicontinuous) on some neighborhood of z. Another characterization is given below.
Lemma 2.2 Let r be a rational function of degree at least 2. Then
J (r) is an uncountable compact set containing no isolated points.
r(J (r)) = r−1(J (r)) = J (r) = J (rn) for all integers n > 0.
For any z ∈ J (r),J(r) = cls( ∞ r−k({z}))	(where cls(A) denotes
the closure of the set A).
For any neighborhood U of z ∈ J (r), and any compact set K ⊆ C
there exist z', z'' and an integer n > 0 so that rn(U ) ⊃ K \ {z', z''}.

Finally, we call a rational function r hyperbolic iff the closure of the forward orbit Oc(r) =  r'(z)=0  n rn(z) of the critical points of r is disjoint to J (r). An immediate consequence of Lemma 2.2, (4) above is the following property
of hyperbolic rational functions (see [2]). This will be the decisive ingredient for Lemma 3.2 in the next section and thus for our algorithms in Section 5.
Lemma 2.3 Let r be a hyperbolic rational function and c > 0 be given. Then there exists a neighborhood U of the Julia set J (r) of r and an integer n > 0 so that for all m > 0 and z ∈ U, |(rm)'(z)| > c.
Whereas polynomials can be treated adequately on the complex plane, an appropriate discussion of rational functions is only possible on the complex sphere C∞ (see Section 3 below). There, all the above notions can be defined for the point ∞ in the usual way. We omit the details.

The Complex Sphere
Let S denote the 2-sphere in R3, i.e. S = {(x, y, z) ∈ R3 : |x|2 +|y|2 +|z|2 = 1}. Furthermore fix a point ∞ = (0, 0, 1). Then we can identify S \{∞} with C by the stereographic projection φ∗ : C → S, φ∗(z) =  1  (2঩(z), 2 (z), |z|2 − 1), where ঩(z) and  (z) denote the real and imaginary part o∫f z, respec-
γ is a smooth curve from z to z' . This metric induces the usual metric on S (viewed as manifold): σ(z, z') is the length of the shortest path from z to z', where all points of the path have to be in S (we will identify the complex numbers z and z' with φ∗(z) and φ∗(z') without further mentioning). We will denote S together with the spherical metric by C∞. As usually we use the notation σ(z, A) for subsets A ⊂ C∞ to denote the distance of a point z to A,
i.e. σ(z, A) = infz'∈A σ(z, z'). Similarly we define σ(A, A') for A, A' ⊂ C by
σ(A, A') = max{supz∈A σ(z, A'), supz∈A' σ(z, A)}.
It is obvious that every rotation of the sphere induces a σ isometry of C∞. These rotations are exactly those Mo¨bius transformations M (a, c), M (a, c)(z) = az−c , with |a|2 +|c|2 = 1, which maps c to 0. Furthermore for each z ∈ C\{0}
there exists a unique representation z = c , where |a|2 + |c|2 = 1 and a is a
non-negative real number. Let Mz := M (a, c), where c is this unique repre-
sentation, M∞(z) := z−1 and M0 be the identity id on C∞.
We will give the main result of this section in Lemma 3.2 below. We prepare this result by some remarks. The following (rough) relation of the spherical and Euclidean metric will be used frequently below.
Lemma 3.1 Let z, z' ∈ C and γ be the geodesic from z to z', ∞ ∈/ γ. Then
|z − z'|≤ (1 + β2)2 · σ(z, z') and σ(z, z') ≤ 2|z − z'|
where βγ = supu∈γ |u|.
Notice, that in the above lemma βγ exists because the image of γ (which we again denote by γ) is compact. We will switch several times between spherical and Eucledean metric in the proof of Lemma 3.2 below. To simplify notations
we will use β− := supu∈K |u|, βK := supu∈K |r(u)|, β' := supu∈K |r'(u)| and
K	K
'' := supu∈U |r''(u)| for compact sets K ⊂ C.
As the Euclidean and the spherical metric coincide in 0, we can transfer local properties from C to C∞ by using suitable M¨obius transformations. For example, in the proof of Lemma 3.2 we will need derivatives on C∞: Given a

rational function r, let r'
(z) be determined by (Mr(z) ◦ r ◦ M −1)'(0). A simple

calculation gives r'
1+|z|2
1+|r(z)|2
r'(z) for z ∈ C. To bound the variation of

' (z) for different points z, we would also like to define something like a second



derivative r'' . Unfortunately, however r'
is not analytic. To circumvent this

∞	∞
problem, we define for δ > 0, r''(z) := (rδ)' , where rδ = (1 + δ2)r'(z) (the
δ	∞
meaning of this will become clear in the proof below). One easily verifies
r''(z) = r''(z)(1 + δ2)(1 + |z|2)/(1 + |r(z)|2).
Lemma 3.2 There exists a polynomial P so that for all rational functions r
and all complex numbers z, z' with |z − z'| < 1/2 and |r(z) − r(z')| < 1/2 we

have	(|r'
|− P (β−,β , β' , β'')σ(z, z'))σ(z, z') ≤ σ(r(z), r(z'))

and	σ(r(z), r(z')) ≤ (|r' (z)| + P (β−,β , β' , β'')σ(z, z'))σ(z, z').

where γ denotes the geodesic from z to z', i.e. σ(z, z') = 
and ∞ ∈/ γ ∪ r(γ).
2/(1 + |z|2)|dz|,

Proof.  Let r, γ and z, z' be given according to the lemma and let K ⊃ γ be a sufficiently small compact neighborhood of γ not containing ∞. We will achieve the above result in several steps. First we show, that we can replace r by the rational function q = Mr(z) r M −1 which simplifies the calculation of the spherical distance between z, z' and r(z), r(z').
Claim 3.3 Let q = Mr(z) ◦ r ◦ M −1 and z∞ = Mz(z'). Then

q'
(0) = q'(0) = r'
(z),	q(0) = 0,

σ(q(0), q(z∞)) = σ(r(z), r(z'),	σ(0, z∞) = σ(z, z') and
for all v ∈ Mz(K) we have |q(v)|≤ 1,	|q'(v)|≤ 16β' (1 + |r(z)|)2 and
''	9	4	''	'	'  2
|q (v)|≤ 2 (1 + |r(z)|) (βK + βK + (βK ) ).
We will use q instead of r in the sequel. To simplify matters we reuse γ to be the geodesic from 0 to z∞. Next we rewrite σ(r(z), r(z')) by σ(r(z), r(z')) =

σ(q(0), q(z
)) = ∫ q(z∞)   2   |du| = ∫ z∞
2|q'(u)| |du| = ∫ z∞ 2|q' (u)| |du| where

∞	0	1+|u|2
0	1+|q(u)|2
0	1+|u|2

we use ∫ b f (u)du for the integral on the straight line from a to b, for short.
Next we bound |q' (0) − q' (u)| by a constant and the spherical distance of 0
and u. To state this formally, we need another technical result.
Claim 3.4 There exists an ε > 0 so that for all t, t', so that the straight line from γ(t) to γ(t') belongs to K, we have for ∆ = |γ(t') − γ(t)|

1+ |γ(t)|2
1+ |γ(t')|2

'	− 2	−	2

1+ |q(γ(t)|2 − 1+ |q(γ(t')|2  ≤ (2βK (1 + (βK ) )+ 2βK )∆ + ε∆ .
Now let u be a point on γ and denote the part of γ from 0 to u again by γ. Obviously, γ is a geodesic. Furthermore let ∆ > 0 be given and t0, ..., tn be a partition of the domain of γ so that |γ(ti) − γ(ti+1)| ≤ ∆ and the straight


line from γ(ti) to γ(ti+1) belongs to K.  With ∆i :=  γ(ti+1)	γ(ti)  and
δi := β' (2β' (1 + (β−)2)+ 2β−)∆i + ε∆2 we have

K	K	K
|q  (u) − q'
K
(0)| ≤ Σn−1 |q'
i
(ti+1) − q'

(ti)|

≤ Σn−1 ∫ γ(ti+1 ) |q''(v)( 1+|γ(ti)|2
)||dv| + δ

Taking the limit ∆ → 0 leads to
i=0
γ(ti )
1+|q(γ(ti))|2	i

'	'	''	'	'	− 2	−
|q∞(u) − q∞(0)|≤ (|q∞| + βK (2βK (1 + (βK ) )+ 2βK ))|u|
where |q'' | ≤ β'' ·(1+(β−)2) is |q'' | = supv∈K |q'' (v)|. Putting things together

we can finally conclude
σ(r(z), r(z')) =
∫z∞
2|q'
(u)|

|du| = q

(0)σ(0, z∞)+ ε

where
1+ |u|2

|ε| ≤ ∫ z∞ 2| q' (u)−q' (0) ||du|≤ (|q'' | + β' (2β' (1 + (β−)2)+ 2β−))|u|σ(0, u).
By Lemma 3.1 we can bound u by σ(0, u) and a suitable factor. As this holds for arbitrary K the proof is completed.
□

Local Complexity on C∞
The local complexity of subsets of C was introduced in [10]. Given a Turing machine M , let L(M ) denote the set accepted by M and let UM (k) be the union of all intervals Ik,i,j = [2−k · i; 2−k · (i + 1)] × [2−k · j; 2−k · (j + 1)] with ”0k, i, j” ∈ L(M ), where i, j are given by their binary representation. Then we say, that M decides a closed set AM iff for each k, UM (k) covers AM and additionally has Hausdorff distance at most 2−k+1 to AM . Notice that AM is uniquely determined by M . Identifying the subsets Ik,i,j (for given k) with a pixel (i, j) (say on a monitor), this definition is probably quite accurate to investigate the problem of drawing pictures of subsets up to arbitrary precisions. Finally, we say that a set A ⊆ C has local complexity O(t) iff there exists a O(t) time bounded Turing machine M with AM = A.
This rises the question why we don’t investigate in a ”global complexity” of a set, e.g. the complexity of giving all the pixels in UM (k). The answer is simply that such a global complexity is not suitable for most of the problems: For many sets we need an exponentially number (in k) of pixels of size 2−k to cover the set. This would lead to exponentially time bounded algorithms, hiding the finer complexity structures. Furthermore we cannot display an unbounded number of pixels on a monitor of fixed resolution. Thus, what we usually do, is to zoom into the picture, and the complexity of this zooming is quite accurately captured by the notion of local complexity given above.
This notion does neither depend on the exact shape of the pixels nor on

the Hausdorff distance 2−k+1. The latter can be chosen to be (√2−k + ε) · 2−k for arbitrary ε > 0. More generally, for each k, let Ck = (Vi,k)i be a covering of C of diameter at most d · 2−k. Then, for given k and ε > 0, any set A ⊂ C
distance of A and Vk is at most (d + ε)2−k. Thus, replacing the intervals Ik,i,j by Vi,k gives a more general notion of local complexity. If we replace herein the Euclidean metric by the spherical metric, we get a suitable definition for the local complexity of subsets of C∞. To simplify matters we fix Vi,k to be a circle with suitable center. Furthermore we fix ε := 1.
Definition 4.1 For given k, i, j  N let


	

ck,i,j =

2
i−1 2

−k−2
,j · 2

−k−2
, − 
2
1 − (|

i−1 2
2
— |j|2)2

−2k−4
) if i is odd

and Ck,i,j = {z ∈ C∞ : ck,i,j ∈ C∞ ∧ σ(z, ck,i,j) ≤ 2−k}. A Turing machine

for all k N, where i, j are presented to M by their binary representation. A subset A C has local complexity O(t) iff there exists a O(t) time bounded Turing machine M which decides A.
For compact subsets of C the local complexity (as subset of C∞) and the complexity defined in [10] coincide. Thus again we could draw parts of the approximations according to the discussion given above, i.e. according to the Euclidean metric, as long as we are far enough away from . However, a probably better way of presenting such pictures is by means of local spherical projections. Similar to the complex plane we can represent any set in C∞ by approximations demanded by the above definition:
Lemma 4.2 F or every set A ⊆ C∞ and every k ∈ N there is a set I ⊆ N × N
A Fast Algorithm for Rational Functions
In the sequel we use a Turing machine model with extra (oracle) tapes and states, so that entering these states with a string of the form 0n 0i 0j 0s re- sults in an answer x y 0d where x and y are the binary representation (say of length log2 x + n + 2) of an approximation of the imaginary and real part of the i-th linear factor (up to 2−n) of the nominator (s = 0) or denominator (s = 1) polynomial. Furthermore d gives the degree of this polynomial. We don’t assume a certain order on the linear factors so that this representation is equivalent to the representation by the coefficients of the polynomials. Al-


though the representation is one among many others, it seems to be natural for many problems in practice.
The algorithms presented in the sequel assume, that the rational function r = p/q represented by the (input) polynomials p and q are hyperbolic and furthermore p and q have no factors in common. Notice, that neither of these assumptions can be decided for the given representation of the input.
Our algorithms work in two phases. In the preliminary phase a first ap- proximation to the Julia set is calculated. This phase outputs three open sets U0 U1 U2, each represented by a finite sequence of open balls with ratio- nal center and radius, a bijective M¨obius transformation τ and δ > 0, n > 0 so that for the n-th iteration s = (τ ◦ r ◦ τ −1)n we have
τ (zr) /∈ K := {z : |z| ≤ δ} for a critical point zr of r,
J ' := J (s)(= τ (J (r))) ⊆ U0 ⊂ U2 ⊂ K,
σ(U2,J') ≤ ε−1,	σ(z, C∞ \ U2) ≥ 1 ε−1 and σ(z', C∞ \ U1) ≥ 1 ε−1
3	3
for all z ∈ U1, z' ∈ U0,
|(s)' (z)| ≥ 2 for all z ∈ U2,
where ε = P (β−, βK, β' , β'' ) (P the polynomial from Lemma 3.2). This phase
K	K	K
does not depend on the requested precision or pixel.
In the main phase we will then approximate the Julia set up to the re- quested precision 2−k for a pixel Ck,i,j in the sense of Definition 4.1. This phase needs time O(k M (k)), where M (k) is the time needed to multiply two k bit numbers. Using the Scho¨nhage-Strassen algorithm we get a (local) com- plexity of O(n2 log n log log n) for the Julia set of a hyperbolic rational func- tion. Notice however, that, despite the fact, that our algorithms are uniform in the sense, that they compute the Julia sets for any given hyperbolic ratio- nal function, the given time bound is not uniformly, i.e. the constant factor hidden in the big-O depends on the given function. Furthermore we strongly conjecture, that a common polynomial or even exponential time bound on the complexity of Julia sets of hyperbolic functions of a certain degree  2 does not exist.

Preliminary Computations
In this section we give an informal description on how to compute U0 to U2, τ and δ. By the representation of the rational function r = p/q it is clear, that the value of r and the modulus of continuity (to arbitrary precision) can be determined at any complex number z = x + iy, x, y rational and q(z) /= 0.


Furthermore for given points z and z' in C∞, it is possible to compute the spherical distance to arbitrary precision, for example by using suitable Mo¨bius transformations.
It is quite easy to give fast algorithms for rational functions of degree 1: In this case there exists bijective M¨obius transformations φ so that φ ◦ r ◦ φ−1 is of the form z '→z + β or z '→kz. In the former case J (r) = ∅ and in the latter J (r) depends on k: if k < 1 then J (r) =    , if k > 1 then J (r) =  0 , if k = 1 we have J (r) = . For more details see [2]. We will thus assume, that the rational functions given to our algorithms are of degree at least 2.
Now to the preliminary computations which we need in Subsection 5.2. In a first step we compute an 2−k (say k = 3) approximation to τ . If r is a polynomial we simply take τ = id. Otherwise we can find an approximation
−1
zc to a critical point of r. Let τ := M∞ ◦ Mzc and s := τ ◦ r ◦ τ	. Notice that
this is a first approximation to τ . If we later recognize, that τ is not sufficient, we increase k and compute a better approximation to zc and then again set τ = M∞ ◦ Mzc and repeat the following steps for this new τ .
Next we search an approximation of a repelling periodic point z0 of s. If
we fail after a fixed number of steps (say e.g. 100 · k), restart with a better approximation for zc and τ . By Lemma 2.2 and Definition 2.1 we will finally find such a point and this point belongs to J (r).
Then we compute one after the other the sets s−1(z0), s−1(s−1(z0)), ...,
i.e. the preimages of z0, the preimages of the preimages of z0 and so on. At the same time we try to find a set A of open balls B(z) of points z in these preimages and an index n so that a) z	U (z), b) for each U (z)  A
we have (sn)−1(U (z)) ⊆  U (z)∈A U (z), c) the radius of U (z) is at most ε−1
and d) |(sn(z'))' | > 2 for all z' ∈  U (z)∈A U (z). If we find such an n and a set
A, we are done. If we fail to find such a set A after a fixed number of steps
(say again 100 · k) we will restart with a better approximation for zc and τ .
Once such a set A is found we can take U2 = U (z)∈A U (z) and repeat this procedure to get U1 and finally U0. The existence of such an A follows by the following result.
Lemma 5.1 For each δ > 0 there exists an n > 0 and a finite set A of balls
U (z) = {z' : σ(z, z') < rz} of radius rz ≤ δ, so that

J (r) ⊂
U (z)∈A
((τ ◦ r ◦ τ −1)n)−1(U (z)) ⊂
U (z)∈A
U (z).

A few comments on this procedure are in order: As we can compute the sets mentioned above only up to finite precision, the properties a) to d) are meant to be guaranteed by the algorithm. Lemma 5.1 gives enough space to do this by appropriate approximations. Another problem are the roots of q.


If we are near such roots, nearly nothing can be said about the modulus of continuity. This problem is resolved by choosing a suitable τ .

Approximation up to Arbitrary Precision
We will now assume that the properties (i) to (iv) of the introductory discus- sion of this section are fulfilled, i.e. n, δ, τ and U0, U1, U2 are chosen properly. The problem to decide, on input 0k, i, j, wether the pixel Ck,i,j should belong to a covering A of J (r) of Hausdorff distance at most 2−k+2 is equivalent to the decision, wether the pixel z : σ(z, τ (ck,i,j)) < 2−k should belong to a covering A' of τ (J (r)) of Hausdorff distance at most 2−k+2. Thus, to simplify matters, we replace r by (τ ◦ r ◦ τ −1)n presented by the preliminary phase, and i, j by the corresponding values, where we reuse the same notations r, i, j again. (Actually we have to replace the single pixel by a finite number of pixels of higher precision, as the new center is probably not a center of a pixel
Ck,i',j'. We omit the purely technical details.)
Furthermore we divide the question, wether the pixel Ck,i,j is near to J (r) into tests Tk,i',j'(2−k/t) ∈ {0, 1} where t > 1 and


Tk,i',j'(2−k
/t) = 

 0  if σ(ck+k',i',j' ,J(r)) > 2−k

for a suitable constant k'.
Obviously, we can then cover and thus decide the pixel Ck,i,j by at most (4 · t)2 such tests Tk,i',j' (2−k/t). To simplify notation, we use ck,i,j for the center of these tests, although they are actually of the form Ck',i,j for some k' > k. Notice, that different to the algorithm in [10] we have to cover the whole surface of a pixel by such tests, as the Julia set might no longer be connected.
To finally apply Lemma 3.2 and give an algorithm for the tests Tk,i,j(2−k/t), we have to consider the errors introduced by rounding (intermediate) results.

Let therefore δ = β−
be the constant of the introductory discussion of this

section, i.e. U2 ⊂ K = {z : |z| < β−} and l0 := [log2 β− + 1|. Furthermore,
for x ∈ K ∩R, let [x]l denote an l0 +l bit approximation of x so that |x−[x]l| ≤ 
2  and the fractional part of [x]l has l bits. We will denote the set of all such [x]l with x  K by Kl, for short. Similarly, for z  C we use [z]l to denote roundings of the real and imaginary part of z. The corresponding set is thus Kl + iKl. Obviously, we have |z − [z ]l| ≤ 2−l+2 and thus σ(z, [z]l) ≤


  0	 t+1
  t	s=1

can be proven by a simple induction, gives a rough upper bound on the error made by multiplying in this way (in a special case).


Lemma 5.2 Let N , l ∈ N, δ > 0 and x1, ..., xN in Kl with |xi| ≤ δ (for all
	 	 
Let K and ε = P (β−, βK, β' , β'' ) be given as in the introductory discus-
K	K	K
sion of this section. Furthermore let k, m > 0 and t > 1 be given. Then we
can use Lemma 3.2 to prove the following version of this lemma, respecting rounding errors.
Lemma 5.3 Let l = k +6 + [log2 t| + [log(β' (1 + (β−)2)+ 1/m)|− [ε♩ and
z ∈ Kl + iKl be given so that σ(z, J (r)) ≤ 2/(3mε). Then either
σ(z, J (r)) ≤ (β' (1 + β2 )+ 1/m)−12−k−2/t and σ([r(z)]l,J(r)) ≤ 2−k/t
or	σ(z, J (r)) > (β' (1 + β2 )+ 1/m)−12−k−2/t, and
K	K

(|r'
(z)|− (1/m))σ(z, J (r)) ≤ σ([r(z)]l,J(r)) ≤ (|r'
(z)| + (1/m))σ(z, J (r))


Now we are prepared to give the main algorithm. The following algorithm performs for given k' ≥ 2 a test Tk,i,j(2−k/t) with the help of a constant number of pixels of a 2/(3 · 2k' ε) approximation to J (r). To simplify notation
let N (k) = [k/ log2(2/3)|+1 and L(k, k') = max{k +6+[log2 t|+[log(β' (1+ (β−)2)+2−k' )|−[ε♩,N (k)[log  (2β' (1+(β−)2)+1)|}, thus L(k, k') ≤ c·(k+k')
for some constant c > 0 (not depending on k).
ALGORITHM Reduce(k’) INPUT: 0k, i,j 
OUTPUT: 0 or zn (see Lemma 5.4 below)
BEGIN
z0 := ck,i,j, l := L(k, k'), n := 0, m := 1;
k+1	k'
WHILE (zn ∈ U1 and m ≤ 1+ 2	/(3 · 2 ε)) DO
m := [[|r' (zn)|]l · m]l; zn+1 := [r(zn)]l, n := n + 1;
END WHILE
IF zn ∈/ U1 THEN RETURN 0
ELSE RETURN zn
END
The correctness of the above algorithm is given by the following lemma.
Lemma 5.4 The above algorithm stops on all inputs ck,i,j. If the algorithm returns 0 then σ(ck,i,j,J(r)) > 2−k/t and otherwise the algorithm returns zn
with n ≤ N (k) and		'
1 if σ(z ,J(r))	2/(3 2k ε)
Tk,i,j (2−k/t) = 
 0  if σ(z ,J(r)) ≥ 2(β' (1 + (β−)2)+ 2)/(3 · 2k' ε)
is a test for ck,i,j in the sense discussed above, where


t = 3 · (1 + 2−k' )N(k)/(1 − 2−k')N(k)
Proof. By Lemma 5.2 we have for n ≤ N (k):

|  (|r' (z )|· (1 − 2−k') − [[  ] (|r' (z )|· (1 − 2−k' )] |≤ 1

∞  s
s=0
l	∞  s	l
s=0

and thus [[  N (k)] (|r' (z )|· (1 − 2−k' )] |≥ ( 3 )N(k) − 1 ≥ 2k. That means, the
algorithm must have stopped before reaching zN(k). For z0 with σ(z0,J(r)) 2−k we get by Lemma 5.3 for all computed zn

σ(z
,J(r)) ≥ (  n−1(|r' (z )|· (1 − 2−k' ))σ(z ,J(r))

≥ ([[( n−1] (|r' (z )|· (1 − 2−k' ))] − 1)σ(z ,J(r))
For the final zn returned by the algorithm we have therefore either zn ∈/ U1 or
k'
σ(zn,J(r)) ≥ 2/(3 · 2 ε). Analogously, we get the upper bound.
Using (1 + 1/n)n ≤ 3 and (1 − 1/n)n ≥ 1/3 for n > 1 we get for k' =
[log2 N (k)| immediately.




Tk,i,j
(2−k/c) =  1  if σ(z, J (r)) ≤ 2/(3N (k)ε)
 0 if σ(z, J (r)) ≥ 2(β' (1 + (β−)2)+ 2)/(3N (k)ε)

is a test for ck,i,j in the sense discussed above, where c is a suitable constant not depending on k. Otherwise we have σ(ck,i,j,J(r)) > 2−k/c.
Notice that for k' = 2 there exists a constant c (not depending on k) so that t in the above lemma can be bounded by 2cN(k). Furthermore the above algorithm needs in each step a finite number of multiplications, divisions and additions of l + c' ≤ c(k + k') + c'-bit numbers (the additive constant stems from the fact, that we have to compute intermediate results up to a higher precision to get the demanded precision of the result in the considered step). Thus for k' k the above algorithm needs at most c k M (k) + c steps to present a result, where c does not depend on k.
Now the main result can be deduced easily: First use algorithm Reduce(2) and the set U1 to get an exponentially time bounded algorithm for the lo- cal complexity of J (r) (by the discussion above we need (4 t)2 tests of the form Tk,i,j, i.e. O(22cN(k)kM (k)) steps, to decide for a given pixel Ck,i,j wether it should be accepted or not). The idea of a faster algorithm is similar to the one in [10]. There it is shown that, for given t, c' > c and any algo- rithm which decides J (r) in time O(t), one can decide the question wether σ(z, J (r)) ≤ c2−k) or σ(z, J (r)) ≥ c'2−k in time O(t(c''k + c'')) for a suitable


constant c'' not depending on k. Thus by Corollary 1 we can use first the algorithm Reduce([log2 N (k)|) and decide the reduced problem afterwards by the exponentially time bounded algorithm Reduce(2). This leads to a polynomially time bounded algorithm, as the length of the reduced input is O(log2 N (k)) = O(log2 k), compared to the original input length O(k). Us- ing Reduce( log2 N (k) ) and this polynomially time bounded algorithm then gives the following result.
Theorem 5.5 The Julia sets of hyperbolic rational functions have a local com- plexity of O(k M (k)), where M (k) denotes the time needed to multiply two k-bit numbers.

References
M. F. Barnsley, Fractals Everywhere, Academic Press, Boston, 2nd edition, 1993.
A. F. Beardon, Iteration of Rational Functions, Springer, 1991.
R. L. Devaney, An introduction to chaotic dynamical systems, Addison-Wesley, Redwood City, 2nd edition, 1989.
A. Douady, Does a Julia set depend continuously on the polynomial?, Proc. Symposia in Applied Math., Complex and Dynamical Systems: The Mathematics Behind the Mandelbrot Set and Julia Sets, 49:91-138, 1994.
K. Falconer, Fractal Geometry, Mathematical Foundations and Applications, John Wiley & Sons, Chichester, New York, 1990.
H. Kamo, K. Kawamura and I. Takeuti, Computational Complexity of fractal sets, Real Analysis Exchange, 26(2):773-793, 2000/01.
J. Milnor, Dynamics in One Complex Variable, Vieweg, Braunschweig, 2nd edition, 2000.
H.-O. Peitgen, H. Ju¨rgens and D. Saupe, Fractals for the classroom, Part Two, Complex Systems and the Mandelbrot set, Springer, 1992.
H.-O. Peitgen and P. H. Richter, The beauty of fractals. Images of complex dynamical systems, Springer, Berlin, 1986.
R. Rettinger and K. Weihrauch, The Computational Complexity of Some Julia Sets, Proceedings of the 35th Annual ACM Symposium on Theory of Computing, 177-185, San Diego, 2003.
D. Saupe, Efficient computation of Julia sets and their fractal dimension, Physica, 28D:358-370, 1987.
N. Zhong, Recursively enumerable subsets of Rq in two computing models: Blum-Shub-Smale machine and Turin machine,Theoretical Computer Science, 197:79-94,1998.
