Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 308 (2014) 25–48
www.elsevier.com/locate/entcs
Coalgebraic Update Lenses
Danel Ahman1
Laboratory for Foundations of Computer Science, University of Edinburgh, 10 Crichton Street, Edinburgh EH8 9LE, United Kingdom
Tarmo Uustalu2
Institute of Cybernetics at Tallinn University of Technology, Akadeemia tee 21, 12618 Tallinn, Estonia

Abstract
Lenses are mathematical structures used in the context of bidirectional transformations.
In this paper, we introduce update lenses as a refinement of ordinary (asymmetric) lenses in which we distinguish between views and updates. In addition to the set of views, there is a monoid of updates and an action of the monoid on the set of views. Decoupling updates from views allows for other ways of changing the source than just merging a view into the source. We also consider a yet finer dependently typed version of update lenses.
We give a number of characterizations of update lenses in terms of bialgebras and coalgebras, including analogs to O’Connor’s coalgebraic and Johnson, Rosebrugh and Wood’s algebraic characterizations of ordi- nary lenses. We consider conversion of views and updates, a tensor product of update lenses and composition of update lenses.
Keywords: lenses, comonads, monads, coalgebras, algebras, bialgebras, distributive laws, liftings, monoid acts, directed containers


Introduction
Lenses are studied in the context of bidirectional transformations. A lens is a structure on two sets mediating actions on them. Think of making sure that two copies of a database, one on a server and one on a client computer, remain in agreement no matter how the database is changed on the client’s side; this must also work when the client only sees a part of the database, a “view”.
Many different variations of lenses have been considered in the literature. In the seminal work of Foster et al. [8], a lens between sets X and S was defined as a pair of maps lkp : X → S and upd : X × S → X, subject to appropriate

1 d.ahman@ed.ac.uk
2 tarmo@cs.ioc.ee

http://dx.doi.org/10.1016/j.entcs.2014.10.003
1571-0661/© 2014 Elsevier B.V. All rights reserved.

round-trip laws. Here, X is to be thought of as a set of sources and S as a set of views. O’Connor [18] and also Power and Shkaravska [19] showed that such lenses are nothing but coalgebras of the array comonad for S. Johnson, Rosebrugh and Wood [14] and Gibbons and Johnson [10] characterized lenses as algebras for a certain monad on Set/S.
Other variants of lenses include, for example, quotient lenses [9], symmetric lenses [12], (symmetric) edit lenses [11], and (asymmetric) delta lenses [6].
In this paper, we define a variation of ordinary (asymmetric) lenses, which we call update lenses (this name is justified by their practical motivation and agrees with the terminology of our prior related work [3] on update monads). In short, update lenses differ from ordinary state-based lenses in that they distinguish between views and updates. In addition to the set of views S, there is also a monoid (P, o, ⊕) of updates and an action ↓ of (P, o, ⊕) on S. The update map thus becomes upd : X ×P → X, allowing for other ways of changing the source than just merging a view into the source. There is also a dependently typed version where every view s : S comes with its own set of updates P s.
We give a number of characterizations of update lenses in terms of bialge- bras, algebras and coalgebras, which we derive from standard facts about dis- tributive laws between comonads/functors, compatible composition of comonads, liftings of comonads/functors to categories of coalgebras, distributive laws of mon- ads/functors over comonads/functors, cofree comonads, adjoint monads and comon- ads etc. [7,5,4,20,21]. We study conversion of views and updates, a tensor of update lenses, composition of update lenses. In the appendix, we also discuss a specializa- tion, initializable update lenses.
Of the related work, the closest to ours is that of Hofmann, Pierce and Wag- ner [11] on (symmetric) edit lenses. They analyze symmetric lenses, and recognize that edits (in our terminology updates) often carry a natural monoidal structure, and are thus best modeled using monoids. As a result of the symmetric setting, edit lenses consist of two monoids, with the upd operations given by a suitable vari- ation of monoid homomorphisms. A different line of related work is that of Diskin, Xiong, and Czarnecki [6] and Johnson and Rosebrugh [15], on (asymmetric) delta lenses. The latter group of authors also introduced a subclass of delta lenses, called c-lenses, with a more succinct definition. Both groups of authors investigate adding more structure to the sets of sources and views, taking them to be reflexive graphs (or, equivalently, categories). The nodes model sources or views, and arrows model deltas (in our terminology updates) between them. The lkp and upd operations rely on functoriality to guarantee the correct and composable translation of deltas.
For readability, we develop all our mathematics for Set (and categories built on Set), but for nearly everything we do it could be replaced by any category with finite products or any Cartesian closed category.

Ordinary lenses
Ordinary lenses: the definition
Given a set S (of views), an ordinary (asymmetric) lens for S is a set X (of sources) and maps lkp : X → S (viewing a source) and upd : X × S → X (updating a source) 3 satisfying the conditions
x = upd (x, lkp x)	upd (upd (x, s), sj)= upd (x, sj)	lkp (upd (x, s)) = s
i.e., making the following three diagrams commute


X
⟨id,lkp⟩ J 
(X × S) × S
⟨fst,id⟩ J 
upd×S X¸× S
Jup d
X × S
upd  X¸
Jlkp 

X × S  upd  X¸
X × S 	upd	 X¸	z 


A map between two ordinary lenses (X, lkp, upd), (Xj, lkpj, updj) is a map h :
X → Xj (conversion of a source) satisfying
lkp x = lkpj (h x)	h (upd (x, s)) = updj (h x, s)


i.e.,

X 	h	 X¸j

X × S


  h×S  X¸j × S

lkp J 
lkp′
upd J 
Jup d′

S   S	X 	h	 X¸j
Ordinary lenses for S and maps between them form a category Lens S.
Running example: editing a bookshop database
Consider modelling a database of a small bookshop. We will work with a very simple database, consisting of only one table, containing information about the identity (e.g., book title and author names, or ISBN), price and quantity of every book in the shop. We let book , price, quantity stand for the sets of allowed values of these data.
We let the set of sources X (the set of database states) be
X = ΣB ⊆ book .B → price × quantity
Every such database state consists of a set of books B currently in the database, and an assignment of price and quantity to each book in B.
A simple example of a set of views S for the above set of sources X can be given
by
S = ΣB ⊆ book .B → price

3 We use the letter X for the source set and S for the view set, and the names lkp for get and upd for put. This may at first feel confusing, but agrees with what is mnemonic for algebras of update monads [3].

This set of views can be used to define an ordinary lens for editing book prices as follows.
We define lkp : X → S by simply discarding the quantity field of each book, that is
lkp (B, v)= (B, fst ◦ v)
We define upd : X × S → X by removing all books that are in the database but not in the given view, editing the prices and preserving the quantities of all books that are both in the database and the view, and adding all books that are only in the view with quantity 0. In detail, upd is defined by
upd ((B, v), (Bj, vj)) = (Bj, λb. if b ∈ B then (vj b, snd (v b)) else (vj b, 0)) Observe that, for this bookshop database to satisfy the 3rd ordinary lens law,
the view argument passed to upd has to contain all the books we want to leave
in the database after the update. Also, as we cannot restrict which books can be edited, we have to allow the lens to be able to add new books to the source, with some default quantity, here 0.
We claim that such forced choices are a real shortcoming of ordinary lenses, and address it in the rest of this paper by developing the theory of update lenses.

Ordinary lenses: some alternative descriptions
Johnson et al. [14] pointed out that the category of lenses for S is the same as the category of algebras of the following monad (T1, η1, μ1) on Set/S:
T1 (X, lkp)= (X × S, snd)
η1 {X, lkp} x = (x, lkp x) μ1 ((x, s), sj)= (x, sj)
Indeed, an algebra of (T1, η1, μ1) is a map upd : (X × S, snd) → (X, lkp) in Set/S, i.e., a map upd : X × S → X satisfying lkp (upd (x, s)) = s, which must moreover satisfy the conditions of an algebra structure of (T1, η1, μ1). The latter amounts exactly to x = upd (x, lkp x) and upd (upd (x, s), sj)= upd (x, sj).
O’Connor [18] and also Power and Shkaravska [19] observed that the category of lenses is isomorphic to the category of coalgebras of the following comonad (D, ε, δ) on Set (Power and Shkaravska call it the array comonad for S):
DX = S × (S → X)
ε (s, v)= vs 
δ (s, v)= (s, λsj. (sj, v))
Explictly, a coalgebra of (D, ε, δ) is a set X and a map act : X → S × (S → X) satisfying
x = let (s, v) → act x in vs 
let (s, v) → act x in (s, λsj. act (v sj)) = let (s, v) → act x in (s, λsj. (sj, v))

The isomorphism assigns to a lens structure (lkp, upd) on a set X the (D, ε, δ)- coalgebra structure act = ⟨lkp, cur upd⟩ on X.
A further characterization, due to Power and Shkaravska 4 , is only an equivalence of categories, not an isomorphism. The category of lenses for S is equivalent to Set. With a set R, one associates the lens (X, lkp, upd) defined by X = S × R, lkp (s, r)= s, upd ((s, r), sj)= (sj, r). In the converse direction, a lens (X, lkp, upd) is sent to the set R = {x : X | lkp x = s0} where s0 is some chosen element of
S. The choice of s0 only makes the difference of an isomorphism: for any s, sj : S, the function λx. upd (x, sj) : {x : X | lkp x = s} → {x : X | lkp x = sj} is an isomorphism by the 1st and 3rd lens conditions. (In the special case S = 0, we take R = 0.)
Intuitively, X is decomposed into two parts: S, which can be both viewed and updated, and R, which can be neither viewed nor updated.

Composition of ordinary lenses
Rather than thinking of S (the set of views) as a fixed set, we can let it vary. We can then define that an (ordinary) lens between two sets X and Y is a pair of maps lkp : X → Y and upd : X × Y → X satisfying the three ordinary lens laws.
For any set X, there is the identity lens (id {X}, fst). Given two lenses (lkp, upd): X → Y and (lkpj, updj) : Y → Z, we define their composition to be (lkpjj, updjj) : X → Z where lkpjj x = lkpj (lkp x) and updjj (x, z)= upd (x, updj (lkp x, z)). Sets and lenses between them form a category.

Update lenses
In this paper, we are interested in a more fine-grained variation of ordinary lenses that we call update lenses.

Update lenses: the definition
We define an act to be given by a set S (of views), a monoid (P, o, ⊕) (of updates) and an action ↓ of the monoid on the set (describing the outcome of applying any given update on any given view). 5
An update lens for an act (S, (P, o, ⊕), ↓) is a set X (of sources) and maps lkp : X → S (viewing a source) and upd : X × P → X (updating a source) satisfying the conditions
x = upd (x, o)  upd (upd (x, p), pj)= upd (x, p ⊕ pj)  lkp (upd (x, p)) = lkp x ↓ p

4 J. Power, O. Shkaravska, Arrays with garbage, Slides from a talk at the Estonian Computer Science Theory Days at Viinistu, Oct. 2005, http://cs.ioc.ee/~tarmo/tday-viinistu/shkaravska-slides.pdf.
5 In the literature, the pair (S, ↓) is often called a (P, o, ⊕)-set. We will occasionally use this terminology too.

i.e.,


X
ρ J 
X × 1
X×o J 
(X × P ) × P
α J 
X × (P × P )
X×⊕ J 
upd×P X¸× P


upd
J 
X × P


lkp×P

J 
upd  X¸


lkp

J 

X × P	upd  X¸
X × P	upd	 X¸
S × P	↓	 S¸


A map between two update lenses (X, lkp, upd), (Xj, lkpj, updj) is a map
h : X → Xj (conversion of a source) satisfying
lkp x = lkpj (h x)	h (upd (x, p)) = updj (h x, p)


i.e.,

X 	h	 X¸j

X × P


  h×P  X¸j × P

lkp J 
lkp′
upd J 
Jup d′

S   S	X 	h	 X¸j
Update lenses for an act (S, (P, o, ⊕), ↓) and maps between them form a category
ULens (S, (P, o, ⊕), ↓).

Running example: editing a bookshop database
We now revisit the bookshop example from Section 2.
We first recall that it was somewhat inconvenient to use the ordinary bookshop lens to edit the price of a particular book. In particular, we could not simply list the books whose prices we wanted to edit, but had to also list all the other books. The main cause for this inconvenience was the single set of views S that got used in both lkp and upd. Here we illustrate how decoupling the updates from the views helps us reuse the same set of views for different update strategies.
We keep the set of sources X, the set of views S and the viewing map lkp as before, but let (P, o, ⊕), ↓, upd vary depending on what we want to do with the database.
For the first example, we revisit editing book prices by taking P to be P = (book ×price)∗. Any update ps : P is to be read as a sequence of price modifications of single books. The monoid structure (o, ⊕) is that of free monoids (with o = [] and ⊕ = ++), while ↓ and upd are defined below.
(B, v) ↓ [] = (B, v)
(B, v) ↓ ((b, p) :: ps)= (B, λbj. if bj = b then p else v bj) ↓ ps
upd ((B, v), []) = (B, v)
upd ((B, v), (b, p) :: ps)= upd ((B, λbj. if bj = b then (p, snd (v bj)) else v bj), ps)

(With this definition, if some book we want to modify is not in the database, it will not be added to the database!)
Thanks to the additional freedom offered by update lenses, we can equally well modify the book prices relative to the prices in the database. For this purpose, we can define P to be (book × change)∗ (let us agree that a price can only be a non-negative number, but a change can also be negative). The monoid structure (P, o, ⊕) is as above, but the definitions of ↓ and upd are adjusted accordingly.
(B, v) ↓ []= (B, v)
(B, v) ↓ ((b, c) :: ps)= (B, λbj. if bj = b then max (0,v bj + c)) else v bj) ↓ ps
upd ((B, v), []) = (B, v)
upd ((B, v), (b, c) :: ps)= 
upd ((B, λbj. if bj = b then (max (0, fst (v bj)+ c), snd (v bj)) else v bj), ps)
As an additional treat, we can also use the same set of views S to perform both deletions and additions of books. We choose P to be ((book × price × quantity )+ book )∗ where the first summand stands for addition of a book and the second sum- mand for deletion of a book. The monoid structure (P, o, ⊕) is again that of free monoids.
(B, v) ↓ [] = (B, v)
(B, v) ↓ (inl (b, p, q) :: ps)= (B ∪ {b}, λbj. if bj = b then p else v bj) ↓ ps
(B, v) ↓ (inr b :: ps)= (B\{b}, v|B\{b}) ↓ ps
upd ((B, v), []) = (B, v)
upd ((B, v), inl (b, p, q) :: ps)= upd ((B ∪ {b}, λbj. if bj = b then (p, q) else v bj), ps)
upd ((B, v), inr b :: ps)= upd ((B\{b}, v|B\{b}), ps)
Of course, we can also combine the addition and deletion of entries with modi- fication of entries, if needed.
Notice that when changing a book’s price, or when adding a new book, we have to introduce additional default behavior when the absolute value of a negative change is greater than the book’s price resp. if the book is already in the database. This is needed because every update must always be applicable. We will address this deficiency in Section 7 by introducing a dependently typed version of update lenses.
Update lenses as bialgebras of a functor and monad
The category of lenses for (S, (P, o, ⊕), ↓) admits several alternative character- izations. We will now consider these in turn. The ultimate insight will be that update lenses are coalgebras of an appropriate comonad. We will arrive there in several small steps through intermediate characterizations that are also of indepen- dent value. We only use standard facts about monads, comonads, distributive laws, liftings, cofree comonads, adjoint monads and comonads. These appear scattered in the literature, some references include [7,5,4,20,21].

We begin by noting that a map lkp from a set X to S is nothing but a coalgebra structure on X of the functor F0 defined by F0 X = S. An action upd of (P, o, ⊕) on X is exactly an algebra structure on X of the monad (T1, η1, μ1) defined by

T1 X = X × P
η1 x = (x, o)
μ1 ((x, p), pj)= (x, p ⊕ pj)

Finally, an action ↓ : S × P → S of (P, o, ⊕) on S is exactly a distributive law of the monad (T1, η1, μ1) over the functor F0.
Therefore, an update lens (X, lkp, upd) for (S, (P, o, ⊕), ↓) is nothing but a ↓- bialgebra of the functor F0 and monad (T1, η1, μ1), i.e., a triple of a set X, map lkp : X → S and algebra structure upd : X × P → X of (T1, η1, μ1) cohering in the sense of the condition


X × P	upd	 X¸
lkp×P J 
lkp	 S¸


S × P 	↓	 S¸


In the same way, update lens maps are bialgebra maps. So the category of update lenses is the same as
the category of ↓-bialgebras of the functor F0 and monad (T1, η1, μ1). It follows that this category can also be described as:
(0’) the category of coalgebras of the ↓-lifting F↓ of F0 to the category of algebras
of (T1, η1, μ1);
(0”) the category of algebras of the ↓-lifting (T↓, η↓, μ↓) of (T1, η1, μ1) to the
1	1	1
category of coalgebras of F0.
Let us spell out (0’) and (0”).
(0’): The category of algebras of (T1, η1, μ1) is (P, o, ⊕)-Set. The ↓-lifting F↓
of F0 to (P, o, ⊕)-Set is defined by F↓(X, upd) = (S, ↓). A coalgebra of F↓ is
0	0
therefore given by a (P, o, ⊕)-set (X, upd) witha map lkp to (S, ↓). So the category
of coalgebras of F↓ is (P, o, ⊕)-Set/(S, ↓).
(0”): The category of coalgebras of F0 is Set/S. The ↓-lifting (T↓, η↓, μ↓) of
1	1	1
(T1, η1, μ1) is defined by

T↓ (X, lkp)= (X × P, λ(x, p). lkp x ↓ p)

An algebra of (T↓, η↓, μ↓) is an object (X, lkp) of Set/S with a map upd from (X×P,
1	1	1
λ(x, p). lkp x ↓ p) satisfying the conditions of a monad algebra.

Update lenses as bialgebras of a comonad and monad
Let (D0, ε0, δ0) be the cofree comonad on the functor F0, explicitly given by
D0 X = S × X
ε0 (s, x)= x
δ0 (s, x)= (s, (s, x))
The category of coalgebras of F0 (i.e., the category Set/S) is isomorphic to the category of coalgebras of (D0, ε0, δ0), whose objects are given by a set X and map dlkp : X → S × X satisfying

X	dlkp  S¸× X	X	dlkp	 S¸× X

Jsnd 
X
dlkp J 
S × X
J⟨fs t,id⟩
	 S¸× (S × X)
S×dlkp

The isomorphism assigns to any F0-coalgebra structure lkp : X → S on a set X the (D0, ε0, δ0)-coalgebra structure dlkp = ⟨lkp, id⟩ : X → S × X.
Furthermore, the distributive law ↓ of (T1, η1, μ1) over F0 induces a distributive law λ of (T1, η1, μ1) over (D0, ε0, δ0), explicitly given by
λ : (S × X) × P → S × (X × P )
λ ((s, x), p)= (s ↓ p, (x, p))
As a result, the category of update lenses, i.e, the category of ↓-bialgebras of F0
and (T1, η1, μ1), is isomorphic to
the category of λ-bialgebras of (D0, ε0, δ0) and (T1, η1, μ1).
Explictly, the objects of this category are triples ofa set X, (D0, ε0, δ0)-coalgebra structure dlkp : X → S × X and (T1, η1, μ1)-algebra structure upd : X × P → X satisfying

X × P	upd	 X¸
dlkp×P J 
dlkp
=⟨lkp,id⟩
  S¸× X
,,
S×upd

(S × X) × P 	λ	 S¸× (X × P )
This category can also be described as:
(1’) the category of coalgebras of the λ-lifting (Dλ, ελ, δλ) of (D0, ε0, δ0) to the

category of algebras of (T1, η1, μ1);
0	0	0

(1”) the category of algebras of the λ-lifting (Tλ, ηλ, μλ) of (T1, η1, μ1) to the

category of coalgebras of (D0, ε0, δ0).
1	1	1


Update lenses as pairs of coalgebras of a functor and comonad
Instead of replacing the functor F0 with a comonad, we could replace the monad (T1, η1, μ1) with a different comonad. This is what we will embark on now.

Consider the following comonad (D1, ε1, δ1):
D1 X = P → X
ε1 v = v o
δ1 v = λp. λpj.v (p ⊕ pj)
The functor D1 is the right adjoint of the functor T1. What is more, the comonad (D1, ε1, δ1) is the corresponding “right adjoint” of the monad (T1, η1, μ1) in the sense of [7]. As a consequence, the category of algebras of (T1, η1, μ1) is isomorphic to the category of coalgebras of (D1, ε1, δ1). Explicitly, a coalgebra of (D1, ε1, δ1) is an object X with a map cupd : X → (P → X) satisfying


X	cupd  P¸→ X
Jo→ X
X	cupd	 P¸→ X
J⊕→  X

→ X	cupd
J	J 
P × P → X
J 

X	P → X P×cupd P¸→ (P → X)

The isomorphism assigns to a (T1, η1, μ1)-algebra structure upd : X × P → X on a set X the (D1, ε1, δ1)-coalgebra structure cupd = cur upd : X → (P → X).
Further the distributive law ↓ of (T1, η1, μ1) over F0 induces a distributive law of F0 over (D1, ε1, δ1), namely  = cur ↓. It follows that the category of ↓-bialgebras of F0 and (T1, η1, μ1) is isomorphic to
the category of  -matching pairs of coalgebras of F0 and (D1, ε1, δ1).
Explicitly, the objects of this category are given by triples of a set X, map
lkp : X → S and coalgebra structure cupd : X → (P → X) of (D1, ε1, δ1) satisfying


S ¸,lkp
X	cupd
 P¸→ X

=cur upd
JP →  lkp
S		 P¸→ S

This category can also be described as:
(2’) the category of coalgebras of the lifting F  of the functor F0 to the category
of coalgebras of (D1, ε1, δ1).
Update lenses as pairs of coalgebras of two comonads
We now combine what we did in the last two paragraphs. We replace both F0 with (D0, ε0, δ0) and (T1, η1, μ1) with (D1, ε1, δ1). Both the distributive law λ of (T1, η1, μ1) over (D0, ε0, δ0) and the distributive law  of F0 over (D1, ε1, δ1) give us the following distributive law θ of (D0, ε0, δ0) over (D1, ε1, δ1):
θ : S × (P → X) → (P → S × X)
θ (s, v)= λp. (s ↓ p, v p)

The category of update lenses, i.e., the category of ↓-bialgebras of the functor
F0 and monad (T1, η1, μ1), is therefore isomorphic to
the category of θ-matching pairs of coalgebras of (D0, ε0, δo) and (D1, ε1, δ1). Explicitly, an object of this category is given by a set X, (D0, ε0, δ0)-coalgebra structure dlkp : X → S × X and (D1, ε1, δ1)-coalgebra structure cupd : X → (P →
X) satisfying


S × X
S×cupd J 
¸,dlkp
=⟨lkp,id⟩
X 	cupd	 P¸→ X
=cur upd
JP →  dlkp

S × (P → X) 	θ	 P¸→ S × X

The same category can also be described as
(3’) the category of coalgebras of the θ-lifting (Dθ, εθ, δθ) of the comonad
0	0  0
(D0, ε0, δ0) to the category of coalgebras of (D1, ε1, δ1).
Update lenses as coalgebras of a comonad
We have two comonads (D0, ε0, δ0) and (D1, ε1, δ1) with a distributive law θ of the former over the latter. This gives a compatible composite comonad (D, ε, δ):
DX = (D0 · D1) X = S × (P → X)
ε (s, v)= v o
δ (s, v)= (s, λp. (s ↓ p, λpj.v (p ⊕ pj)))
The category of update lenses, i.e., of θ-matching pairs of coalgebras of (D0, ε0, δ0) and (D1, ε1, δ1), is isomorphic to
the category of (D, ε, δ)-coalgebras.
Explicitly, a (D, ε, δ)-coalgebra is a set X with a map act : X → S × (P → X) satisfying
x = let (s, v) → act x in v o
let (s, v) → act x in (s, λp. act (v p)) = let (s, v) → act x in (s, λp. (s ↓ p, λpj.v (p ⊕ pj)))
i.e.,

X  act  S¸× (P → X)	X 	act	 S¸× (P → X)

Jε 
act J 
Jδ 

X	S × (P → X) S×(P→ac t) S¸× (P → S × (P → X))

The isomorphism associates to an update lens structure (lkp, upd) on a set X a (D, ε, δ)-coalgebra structure act = ⟨lkp, cur upd⟩.
Following two routes (0)-(1)-(3)-(4) and (0)-(2)-(3)-(4), we have derived that up- date lenses for (S, (P, o, ⊕), ↓) are essentially the same as coalgebras of the comonad

(D, ε, δ). The algebraic characterization (0”) is analogous to that of Johnson et al.
[14] for ordinary lenses for a set S and the coalgebraic characterization (4) is anal- ogous to O’Connor’s [18], while perhaps the most basic one is (0’), which says that an update lens is a (P, o, ⊕)-set with a map to (S, ↓). Many of the other alternative characterizations of update lenses are without counterparts for ordinary lenses.
We have no opportunity to discuss this here in any detail, but update lenses for (S, (P, o, ⊕), ↓), i.e., coalgebras of the comonad (D, ε, δ), comodel the same (gen- erally large) Lawvere theory that is modelled by the algebras of what we have elsewhere [3] called the update monad for (S, (P, o, ⊕), ↓). This monad (T, η, μ) is defined by
T X = S → P × X
ηx = λs. (o, x)
μf = λs. let (p, g) → f s in let (pj, x) → g (s ↓ p) in (p ⊕ pj, x)

Update lenses: an equivalent characterization
Here is a different characterization, which is only an equivalence of categories, not an isomorphism.
We first observe that any act (S, (P, o, ⊕), ↓) defines a category ⟨⟨S, (P, o, ⊕), ↓⟩⟩ where an object is an element s of S and a map between s, sj : S is an element p of P such that s ↓ p = sj. The identity on s is o and the composition of p and pj is p ⊕ pj.
The category ULens (S, (P, o, ⊕), ↓) is equivalent to the functor category [⟨⟨S, (P, o, ⊕), ↓⟩⟩, Set]. A functor R : ⟨⟨S, (P, o, ⊕), ↓⟩⟩ → Set is mapped to the up- date lens (X, lkp, upd) defined by X = Σs : S. R s, lkp (s, r)= s and upd ((s, r), p)= (s ↓ p, R p r). In the converse direction, an update lens (X, lkp, upd) is mapped to the functor R defined by Rs = {x : X | lkp x = s}, Rp x = upd (x, p).

Turning ordinary lenses into update lenses
Given an act (S, (P, o, ⊕), ↓), any ordinary lens (X, lkp : X → S, upd : X × S → X) for S defines an update lens (X, lkp, updj : X × P → X) for (S, (P, o, ⊕), ↓) via updj (x, p)= upd (x, lkp x ↓ p). And any map h between two ordinary lenses for S is also a map between the corresponding update lenses for (S, (P, o, ⊕), ↓). This gives us a functor from Lens S to ULens (S, (P, o, ⊕), ↓).
This functor is “caused” by a morphism τ between the comonads (D, ε, δ), (Dj, εj, δj) where DX = S × (S → X) and Dj X = S × (P → X). It is de- fined by τ (s, v)= (s, λp. v (s ↓ p)). Any morphism between two comonads gives a functor between the corresponding categories of coalgebras.

Conversions of views and updates
So far we have seen that update lens maps h : (X, lkp, upd) → (Xj, lkpj, updj) model the conversion from a source set X toa source set Xj, for a fixed act (S, (P, o, ⊕), ↓).

In this section, we discuss how maps between acts give rise to conversions between view and update sets, for a fixed source set X.
A map (t, q) between acts (S, (P, o, ⊕), ↓) and (Sj, (P j, oj, ⊕j), ↓j) consists of a function (conversion of views) t : S → Sj and a monoid homomorphism (conversion of updates) q : (P j, oj, ⊕j) → (P, o, ⊕), such that
t (s ↓ q p)= ts ↓j p
(Notice the reversed direction of the monoid homomorphism! In the literature, e.g., [17], one typically requires that q : (P, o, ⊕) → (P j, oj, ⊕j) and t (s ↓ p)= ts ↓j q p, but this is not what is needed here.) Acts form a category Act.
We say that a conversion of views and updates induced by a morphism (t, q) between acts (S, (P, o, ⊕), ↓), (Sj, (P j, oj, ⊕j), ↓j) is a functor
ULens (t, q): ULens (S, (P, o, ⊕), ↓) → ULens (Sj, (P j, oj, ⊕j), ↓j) defined as
ULens (t, q) (X, lkp, upd)= (X, t ◦ lkp, upd ◦ (X × q))
ULens (t, q) h = h
We note that ULens is a functor from Act to CAT.
From the functor ULens we can build the total category ULensTot of all update lenses by using the Grothendieck construction (see, e.g., [13, §1.10]), i.e., ULensTot = ULens.
In detail, an object of ULensTot is an act (S, (P, o, ⊕), ↓) together with an up- date lens (X, lkp, upd) for that act, i.e., an object of ULens (S, (P, o, ⊕), ↓). A map between two objects ((S, (P, o, ⊕), ↓), (X, lkp, upd)) and ((Sj, (P j, oj, ⊕j), ↓j),
(Xj, lkpj, updj)) is an act map (t, q) : (S, (P, o, ⊕), ↓) → (Sj, (P j, oj, ⊕j), ↓j) paired with a map h : ULens (t, q) (X, lkp, upd) → (Xj, lkpj, updj) of update lenses for (Sj, (P j, oj, ⊕j), ↓j).

Conversions of views and updates as mappings of comonad coalgebras to comonad coalgebras
Just as every act (S, (P, o, ⊕), ↓) defines a comonad S, (P, o, ⊕), ↓) = (D, ε, δ), every morphism (t, q) between two acts (S, (P, o, ⊕), ↓) and (Sj, (P j, oj, ⊕j), ↓j) de- fines a morphism  t, q)  =  τ  between the comonads  S, (P, o, ⊕), ↓)  and
 Sj, (P j, oj, ⊕j), ↓j). Explictly, this natural transformation is defined by
τ : ∀{X}. (S × (P → X)) → Sj × (P j → X)
τ (s, v)= (t s,v ◦ q)
 −) forms a functor from Act to Comonads(Set).
As already said earlier, a morphism τ between two comonads (D, ε, δ) and (Dj, εj, δj) determines a functor between the corresponding categories of coalgebras, sending a (D, ε, δ)-coalgebra (X, act) to the (Dj, εj, δj)-coalgebra (X, τ {X}◦ act).

While the category ULens (S, (P, o, ⊕), ↓) is isomorphic to the category of coal- gebras of the comonad  S, (P, o, ⊕), ↓), the functor ULens (t, q)  : ULens (S, (P, o, ⊕), ↓) → ULens (Sj, (P j, oj, ⊕j), ↓j) is isomorphic to the functor between the categories of coalgebras of S, (P, o, ⊕), ↓) and Sj, (P j, oj, ⊕j), ↓j), in- duced by the comonad morphism t, q). In summary, we have that the following diagram commutes up to isomorphism:
Act 	 —)	 C¸omonads(Set)

CAT
Tensoring update lenses
Sometimes we might want to collect multiple update lenses into a single update lens structure. We show how this can be done with a tensor product on the category of all update lenses.
We define the unit act I to be the act (1, (1, !, !), !).
For any two acts (S0, (P0, o0, ⊕0), ↓0) and (S1, (P1, o1, ⊕1), ↓1), we define their tensor product by
(S0, (P1, o1, ⊕1), ↓1) ⊗ (S1, (P1, o1, ⊕1), ↓1)= (S0 × S1, (P0 × P1, o, ⊕), ↓)


where
o = (o0, o1)	(p0, p1) ⊕ (pj , pj )= (p0 ⊕0 pj , p1 ⊕1 pj )

0	1	0	1
(s0, s1) ↓ (p0, p1)= (s0 ↓0 p0, s1 ↓1 p1)
I and ⊗ make Act into a monoidal category.
Now for the act I we have a unit lens J = (1, !, !).
And for two update lenses (X0, lkp0, upd0) and (X1, lkp1, upd1) for acts (S0, (P0, o0, ⊕0), ↓0) resp. (S1, (P1, o1, ⊕1), ↓1), there is the tensor update lens
(X0, lkp0, upd0) ☒ (X1, lkp1, upd1)= (X0 × X1, lkp, upd) for the act (S0, (P0, o0, ⊕0), ↓0) ⊗ (S1, (P1, o1, ⊕1), ↓1) with
lkp (x0, x1)= (lkp0 x0, lkp1 x1)	upd (x0, x1) (p0, p1)= (upd0 (x0, p0), upd1 (x1, p1))
With this we have shown that ULens is a lax monoidal functor from Act to CAT (wrt. the (I, ⊗) monoidal structure on Act and the product monoidal structure on CAT), where the monoidality witnesses are
J :1 → ULens I
☒ : ULens (S0, (P0, o0, ⊕0), ↓0) × ULens (S1, (P1, o1, ⊕1), ↓1)
→ ULens((S0, (P0, o0, ⊕0), ↓0) ⊗ (S1, (P1, o1, ⊕1), ↓1))

It is also evident that (I, ⊗) and (J, ☒) endow the total category ULensTot with a monoidal structure. The unit is (I, J ) and the tensor of ((S0, (P0, o0, ⊕0), ↓0), (X0, lkp0, upd0)) and ((S1, (P1, o1, ⊕1), ↓1), (X1, lkp1, upd1)) is ((S0, (P0, o0, ⊕0), ↓0)⊗ (S1, (P1, o1, ⊕1), ↓1)), (X0, lkp0, upd0) ☒ (X1, lkp1, upd1)).
The tensor product on ULensTot is kind of a “parallel composition” of update
lenses.
The category of acts also carries a product monoidal structure. However, due to its involved definition and lack of space, we refrain from discussing it here. For the dependently typed version of acts discussed in Section 7, we refer the reeader to [2] for details.

Composition of update lenses
We have already seen how to convert sources (for a fixed act) and views/updates (for a fixed set of sources). We now discuss a notion of composition of two update lenses where the view set of one update lens is the source set of another.
We develop the definition in two steps, starting from the alternative characteri- zation (0’) of update lenses from Section 3.
We recall from (0’) that an update lens (X, lkp : X → S, upd : X × P → X) for an act (S, (P, o, ⊕), ↓) is essentially the same as an object ((X, upd), lkp : (X, upd) → (S, ↓)) of (P, o, ⊕)-Set/(S, ↓). If we keep (P, o, ⊕) fixed, but let (S, ↓) vary, we can say that an update lens for (P, o, ⊕) isa (P, o, ⊕)-set map lkp : (X, upd) → (Y, updj). The identity update lens on (X, upd) is then id {X} and the composition of two update lenses lkp : (X, upd) → (Y, updj) and lkpj : (Y, updj) → (Z, updjj) is lkpj ◦ lkp.
To be able to compose update lenses for possibly different monoids, we need to let (P, o, ⊕) vary too. We achieve this by switching to a more involved category where again lenses are maps.
An object of this category is just a set. But a map between two sets X, Y is given by a monoid (P, o, ⊕) with actions upd and ↓ on X resp. Y (up to isomorphism in the choice of these data) and a map lkp : X → Y satisfying lkp (upd (x, p)) = lkp x ↓ p. The identity map on X is (P, o, ⊕, upd, ↓, lkp) where P = X → X, o = id,
f ⊕ g = g ◦ f , upd (x, f ) = x ↓ f = f x, lkp = id. The composition of two maps (P0, o0, ⊕0, upd0, ↓0, lkp0): X → Y and (P1, o1, ⊕1, upd1, ↓1, lkp1) : Y → Z is (P, o, ⊕, upd, ↓, lkp) where P = {(p0, p1) : P0 × P1 | ∀y : Y. y ↓0 p0 = upd1 (y, p1)},
o = (o0, o1), (p0, p1) ⊕ (pj , pj )= (p0 ⊕0 pj , p1 ⊕1 pj ), upd (x, (p0, p1)) = upd0 (x, p0),
0	1	0	1
z ↓ (p0, p1)= z ↓1 p1, lkp = lkp1 ◦ lkp0.
This treatment of an update lens between X and Y as a map between X and Y arises from analyzing the data (P, o, ⊕, upd, ↓) as a span of monoid morphisms to the endomap monoids (X → X, id, ;) and (Y → Y, id, ;)
(P, o, ⊕)

v˛
(X → X, id, ;)	(Y → Y, id, ;) 

and lkp as a map between X and Y satisfying
P


X → X



z 
X → Y
z 
Y → Y

where upd○ : P → (X → X) and ↓○ : P → (Y → Y ) are obtained from upd and ↓
by swapping the arguments and currying.
Under this view, it is only natural to take the identity update lens on X to be given the span of identity monoid morphisms with the vertex (X → X, id, ;) and the identity map on X. The composition of lenses (P0, o0, ⊕0, upd0, ↓0, lkp0): X → Y and (P1, o1, ⊕1, upd1, ↓1, lkp1) : Y → Z can be taken to be given by the following span of monoid morphisms constructed with a pullback
(P, o, ⊕)


(P0, o0, ⊕0)
v˛
pb	(P1, o0, ⊕1)


v˛	v˛
(X → X, id, ;)	(Y → Y, id, ;)	(Z → Z, id, ;) 
and by the composition of lkp0 and lkp1 as maps.
A dependently typed generalization
It often happens that every view comes with a specific set of safe or allowed updates. For example, if we recall our bookshop database, then one expects to be able to edit and delete only the books appearing in the view and to add only the books that are not in the view. As we saw in Section 3, update lenses do not offer this flexibility; one has to provide ↓ and upd with suitable additional default behavior. The reason for this is that, with a single monoid of updates, all updates must act on every possible view.
We propose to remove the need for such additional default behavior by intro- ducing a dependently typed version of update lenses. This development is based on our previous work with Chapman [2] on directed containers, a specialization of Abbott, Altenkirch and Ghani’s containers [1]. Due to lack of space, we must keep the presentation very brief and refer the interested reader to our earlier work [2,3].

Containers, directed containers
Recall that a container is given by a set S and a S-indexed family P of sets. A
map between two containers (S, P ) and (Sj,Pj) is given by functions t : S → Sj and

q : Π{s : S}.Pj (t s) → P s. Containers and maps between them form a category
Cont. Any container (S, P ) gives rise to a set functor  S, P )c defined by
 S, P )cX = Σs : S.P s → X
 S, P )ch = λ(s, v).(s, h ◦ v)

Any container map (t, q) defines a natural transformation t, q)c : S, P )c → Sj,Pj)c by t, q)c = λ(s, v). (t s, v◦q). −)c is a fully faithful functor from Cont to [Set, Set]. A directed container (S, P, ↓, o, ⊕) is given by a container (S, P ) and operations
↓ : Πs : S. P s → S
o : Π{s : S}.P s
⊕ : Π{s : S}. Πp : P s. P (s ↓ p) → P s 

satisfying five conditions
s ↓ o = s	s ↓ (p ⊕ pj)= (s ↓ p) ↓ pj
p ⊕ o = p	o ⊕ p = p	(p ⊕ pj) ⊕ pjj = p ⊕ (pj ⊕ pjj)

Directed containers are a dependently typed generalization of acts. Here we do not have a single monoid and not a family of monoids either, but rather a single monoid-like structure spread out over multiple carriers P s. If one ignores the dependent typing of the above five equations, they are exactly the equations of an act.
A map between directed containers (S, P, ↓, o, ⊕) and (Sj,Pj, ↓j, oj, ⊕j) isa map (t, q) between the underlying containers (S, P ) and (Sj,Pj) that satisfies

t (s ↓ q p)= ts ↓j p	o = q oj	qp ⊕ q pj = q (p ⊕j pj)

Of course, a map between directed containers is a dependently typed generalization of a map between acts. Directed containers form a category DCont.
A directed container (S, P, ↓, o, ⊕) determines a comonad S, P, ↓, o, ⊕)dc = (D, ε, δ) given by
DX = S, P )c X = Σs : S. P s → X
ε (s, v)= v o
δ (s, v)= (s, λp. (s ↓ p, λpj.v (p ⊕ pj)))
For a map (t, q) between two directed containers (S, P, ↓, o, ⊕) and (Sj,Pj, ↓j, oj, ⊕j), the natural transformation  t, q)c is a comonad map between  S, P, ↓, o, ⊕)dc and
 Sj,Pj, ↓j, oj, ⊕j)dc.
The fully faithful functor −)c : Cont → [Set, Set] lifts to a fully faithful functor
 −)dc : DCont → Comonads(Set). In fact, −)dc is the pullback in CAT of −)c
along U : Comonads(Set) → [Set, Set].

Dependently typed update lenses
A dependently typed update lens (X, act) for a directed container (S, P, ↓, o, ⊕) is a set X (of sources) and a map act : X → Σs : S. P s → X satisfying
x = let (s, v) → act x in v o
let (s, v) → act x in (s, λp. act (v p)) = let (s, v) → act x in (s, λp. (s ↓ p, λpj.v (p ⊕ pj)))
A map between dependently typed update lenses (X, act) and (Xj, actj) isa map
h : X → Xj (conversion of a source) satisfying
actj (h x)= let (s, v) → act x in (s, h ◦ v)
The category of dependently typed update lenses is precisely the category of coalgebras of the comonad (D, ε, δ) defined above.
While simply-typed update lenses fail to subsume ordinary lenses (since an arbitrary unstructured set S does not carry monoid structure), an ordinary lens (X, lkp, upd) for a set S is a dependently typed update lens for (S, P, ↓, o, ⊕) given by P s = S, s ↓ sj = sj, o {s} = s, sj ⊕ {s} sjj = sjj.

Running example: editing a bookshop database
We briefly revisit our bookshop database example in the context of dependently typed update lenses. We define a dependently typed update lens structure for editing book prices in a type-safe way.
We keep the set of sources X and the set of views S as before. We define the
S-indexed family P of updates inductively as heterogeneous lists by the two rules
vb + c ≥ 0	ps : P (B, λbj ∈ B. if b = bj then vj b + c else vj b)
[] : P (B, v)	(b, c) :: ps : P (B, v)
Here, P (B, v) encodes sequences of single book price changes whose application is guaranteed to lead to no negative price in the database, if all prices in the given view (B, v) of the database are nonnegative.
The monoid structure (o, ⊕) is again that of nil and append with the dependently typed ↓ and act defined as below.
(B, v) ↓ [] = (B, v)
(B, v) ↓ ((b, c) :: ps)= (B, λbj ∈ B. if b = bj then v bj + c else v bj) ↓ ps
act (B, v)= ((B, fst ◦ v), λps. actj (B, v) ps) where
actj : Π(B, v): X. P (B, fst ◦ v) → X
actj (B, v) [] = (B, v)
actj (B, v) ((b, c) :: ps)= 
actj (B, λbj. if bj = b then (fst (v bj)+ c, snd (v bj)) else v bj) ps

Conclusions and future work
Combining insights from our work on update monads [3] with existing knowledge about ordinary (asymmetric) lenses [18,19,14,10], we were led to a concept of update lenses.
Update lenses are a refinement of ordinary lenses that we find both practically meaningful and theoretically elegant. Most interestingly perhaps, update lenses admit decompositions that ordinary lenses do not enjoy: they can be seen as pairs of matching coalgebras, bialgebras etc. These characterizations arise naturally from various kinds of distributive laws.
We wish to continue this work by turning to symmetric variations of update lenses. We expect to be able to build on both the original work on symmetric lenses [12,11] and the newest categorical ideas of Johnson and Rosebrugh [16]. We also plan to find out the precise connections to delta and c-lenses [15].
Acknowledgement
Tarmo Uustalu thanks Andreas Abel for reminding him of O’Connor’s work. This ongoing work is being supported by the University of Edinburgh Principal’s Career Development PhD Scholarship, the ERDF funded Estonian CoE project EXCS and ICT National Programme project “Coinduction”, the Estonian Ministry of Edu- cation and Research target-financed research theme 0140007s12 and the Estonian Science Foundation grant no. 9475.

References
Abbott, M., T. Altenkirch, N. Ghani. Containers: constructing strictly positive types, Theor. Comput. Sci. 342(1), 2005, pp. 3–27.
Ahman, D., J. Chapman, and T. Uustalu, When is a container a comonad? Log. Methods in Comput. Sci. 10(3), 2014, article 14.
Ahman, D. and T. Uustalu, Update monads: cointerpreting directed containers, in: R. Matthes and
A. Schubert, eds., “Proc. of 19th Int. Conf. on Types for Proofs and Programs, TYPES ’13 (Toulouse, Apr. 2013),” Leibniz Int. Proc. in Informatics 26, Dagstuhl Publishing, 2014, pp. 1–23.
Barr, M. and C. Wells, Toposes, Triples and Theories, Grundlehren der mathematischen Wissenschaften
278, Springer, 1984.
Beck, J., Distributive laws, in: B. Eckmann, ed., “Seminar on Triples and Categorical Homology, ETH 1966/67,” Lect. Notes in Math. 80, Springer, 1969, pp. 119–140.

Diskin, Z., Y. Xiong, and K. Czarnecki, From state- to delta-based bidirectional model transformations: the asymmetric case, J. of Object Technology 10, 2011, article 6.
Eilenberg, S. and J. Moore, Adjoint functors and triples, Illinois J. of Math. 9(3), 1965, pp 381–398.
Foster, J. N., M. B. Greenwald, J. T. Moore, B. C. Pierce, and A. Schmitt, Combinators for bidirectional tree transformations: a linguistic approach to the view-update problem, ACM Trans. on Program. Lang. and Syst. 29(3), 2007, article 17.
Foster, J. N., A. Pilkiewicz, and B. C. Pierce, Quotient lenses, in: “Proc. of 13th ACM SIGPLAN Int. Conf. on Functional Programming, ICFP ’08 (Victoria, BC, Sept. 2008),” ACM, 2008, pp. 383–396.

Gibbons, J. and M. Johnson, Relating algebraic and coalgebraic descriptions of lenses, in: F. Hermann and J. Voigtl¨ander, eds., “Proc. of 1st Int. Wksh. on Bidirectional Transformations, BX 2012 (Tallinn, March 2012),” Electron. Commun. of EASST 49, 2012, 16 pp.
Hofmann, M., B. C. Pierce, and D. Wagner, Edit lenses, in: “Proc. of 39th Ann. ACM SIGPLAN- SIGACT Symp. on Principles of Programming Languages, POPL ’12 (Philadelphia, PA, January 2012),” ACM, 2012, pp. 495–508.
Hofmann, M., B. C. Pierce, and D. Wagner, Symmetric lenses, in: “Proc. of 38th Ann. ACM SIGPLAN- SIGACT Symp. on Principles of Programming Languages, POPL ’11 (Austin, TX, Jan. 2011),” ACM, 2011, pp. 371–384.
Jacobs, B., Categorical Logic and Type Theory, Studies in Logic and the Foundations of Mathematics
141, North Holland, 1999.
Johnson, M., R. Rosebrugh, and R. J. Wood, Algebras and update strategies, J. of Univ. Comput. Sci
16(5), 2010, pp. 729–748.
Johnson, M. and R. Rosebrugh, Delta lenses and opfibrations, in: P. Stevens and J. F. Terwilliger, “Proc. of 2nd Int. Wksh. on Bidirectional Transformations, BX 2013 (Rome, March 2013),” Electron. Commun. of EASST 57, 2013, 18 pp.
Johnson, M. and R. Rosebrugh, Spans of lenses, in: K. Selcuk-Candan et al., eds., “Proc. of Wkshs. of EDBT/ICDT 2014 Joint Conf. (Athens, March 2014),” CEUR Wksh. Proc. 1133, RWTH Aachen, 2014, pp. 112–118.
Kilp, M., U. Knauer, A. V. Mikhalev, Monoids, Acts and Categories: With Applications to Wreath Products and Graphs, De Gruyter Expositions in Mathematics 29, De Gruyter, 2000.
O’Connor, R., Functor is to lens as applicative is to biplate: introducing multiplate, arXiv preprint 1103.2841, 2011. (Paper presented at 2011 ACM SIGPLAN Wksh. on Generic Programming, WGP ’11, Tokyo, Sept. 2011.)
Power, J. and O. Shkaravska, From comodels to coalgebras: state and arrays, in: J. Ad´amek and
S. Milius, eds., “Proc. of 7th Int. Wksh. on Coalgebraic Methods in Computer Science, CMCS ’04 (Barcelona, March 2004),” Electr. Notes in Theor. Comput. Sci. 106, Elsevier, 2004, pp. 297–314.
Power, J. and H. Watanabe, Combining a monad and a comonad, Theor. Comput. Sci. 280(1-2), 2002,
pp. 137–162.
Tanaka, M., Pseudo-distributive laws and unified framework for variable binding, PhD thesis, LFCS, Univ. of Edinburgh, 2005.

Initializable ordinary and update lenses
In this section we discuss a further specialization that is applicable to both ordinary and update lenses, initializability.
Initializable ordinary lenses
In the lenses literature [9,12], one sometimes equips an ordinary lens (X, lkp, upd) for a set S with an additional map create : S → X (creation of a source from a view) satisfying
lkp (create s)= s	upd (create s, sj)= create sj


i.e.,

S  create X¸


S × S create×S X¸× S

Jlkp 
snd J 
Jup d

S	S   create	 X¸

We call such a structure (X, lkp, upd, create) an initializable lens.
A  map  between  two  initializable  lenses  (X, lkp, upd, create)  and (Xj, lkpj, updj, createj) isa map h between (X, lkp, upd) and (Xj, lkpj, updj) that also satisfies


i.e.,
h (create s)= createj s



S
create J 
S
Jcre ate′

X   h  X¸j

Of course initializable lenses for S and maps between them form a category.

Initializable update lenses
Update lenses admit this specialization too.

Initializable update lenses: the definition
We define an initializable update lens (X, lkp, upd, create) for an act (S, (P, o, ⊕), ↓) to be given by an update lens (X, lkp, upd) together with an ad- ditional map create : S → X satisfying
lkp (create s)= s	upd (create s, p)= create (s ↓ p)


i.e.,

S  create X¸


S × P create×P X¸× P

Jlkp 
↓ J 
Jup d

S	S 	create	 X¸
A map between two initializable update lenses (X, lkp, upd, create) and (Xj, lkpj, updj, createj) isa map h between (X, lkp, upd) and (Xj, lkpj, updj) that also satisfies


i.e.,
h (create s)= createj s



S
create J 
S
Jcre ate′

X   h  X¸j

Initializable update lenses for (S, (P, o, ⊕), ↓) and maps between them form a category.

Initializable update lenses: alternative descriptions
Recall the definitions of F0, (T1, η1, μ1) and (D, ε, δ) from Section 3.
It is immediate from the definition that the category of initializable update lenses is the same as
(o) the category of triples of a coalgebra of F0, algebra of (T1, η1, μ1) and algebra of F0 on the same carrier, pairwise matched by the distributive law ↓ of (T1, η1, μ1) over F0 (used twice) and the distributive law id of F0 over itself.
Explicitly, the objects of this category are quadruples of a set X, map lkp : X → S, (T1, η1, μ1)-algebra structure upd : X × P → X and map create : S → X satisfying


X × P
 upd  X¸
lkp  S¸
S create X¸
lkp  S¸
X × P	upd X¸ c¸rea,te S
,,

lkp×P
J 
S × P 	↓	 S¸	S	S
create×P

S × P	↓	 S¸


(remember that a (T1, η1, μ1)-algebra structure on X is an action of (P, o, ⊕) on X). We already know that the category of ↓-matching bialgebras of F0 and (T1, η1, μ1)
is isomorphic to the category of coalgebras of (D, ε, δ). It is also the case that the distributive laws id of F0 over itself and ↓ of (T1, η1, μ1) over F0 make [id, cur ↓] a distributive law of F0 over (D, ε, δ). It follows that the category of initializable update lenses is also isomorphic to
the category of bialgebras of (D, ε, δ) and F0 matched by the distributive law
⟨id, cur ↓⟩ of F0 over (D, ε, δ).
Explicitly, the objects of this category are triples of a set X, (T1, η1, μ1)-coalgebra structure act : X → S × (P → X) and map create : S → X satisfying


S 	create	 X¸
	act	 S¸× (P → X)
=⟨lkp,cur upd⟩

,,
S×(P→create)
S 	⟨id,cur ↓⟩	 S¸× (P → S)

But notably we can also pack together upd and create instead of upd and lkp.
This is done in two steps.
First we observe that the category of algebras of F0 is isomorphic to the category of algebras of the free monad (T0, η0, μ0) on F0, explicitly defined by
T0 X = S + X
η0 x = inr x μ0 (inl s)= inl s
μ0 (inl (inl s)) = inl s μ0 (inl (inr x)) = inr x

The isomorphism assigns to a F0-algebra (X, create) the (T0, η0, μ0)-algebra (X, dcreate) where dcreate = [create, id].
The distributive laws id of F0 over itself and ↓ of (T1, η1, μ1) over F0 induce distributive laws [id, id] of (T0, η0, μ0) over F0 and φ of (T1, η1, μ1) over (T0, η0, μ0) where
ψ : (S + X) × P → S + X × P
ψ (inl s, p)= inl (s ↓ p) ψ (inr x, p)= inr (x, p)
The category of initializable update lenses is therefore also isomorphic to
the category of triples of a coalgebra of F0, algebra of (T1, η1, μ1) and algebra of (T0, η0, μ0) on a common carrier pairwise matched by the distributive laws ↓, [id, id] and ψ.
Explicitly, the objects of this category are quadruples of a set X, map lkp : X → S, (T1, η1, μ1)-algebra structure upd : X ×P → X and (T0, η0, μ0)-algebra structure dcreate : S + X → X satisfying


X × P
upd  X¸
lkp  S¸
S + X
dcreate

=[create,id]
 X¸
lkp	 S¸

lkp×P
J 
S+lkp
J 

S × P	↓	 S¸
S + S	[id,id]	 S¸

X × P 	upd	 X¸
,,
dcreate×P

¸dc,reate 
S + X
,,
S+upd

(S + X) × P	ψ	 S¸+ X × P

Second, we notice that the distributive law ψ of (T1, η1, μ1) over (T0, η0, μ0) defines a compatible composition (T, η, μ) of the two monads, explicitly
TX = S + X × P
ηx = inr (x, o)
μ (inl s)= inl s
μ (inr (inl s, p)) = inl (s ↓ p)
μ (inr (inr(x, p), pj)= inr (x, p ⊕ pj)
The category of algebras of (T, η, μ) is isomorphic to the category of ψ-matching pairs of algebras of (T0, η0, μ0) and (T1, η1, μ1). The algebra of (T, η, μ) correspond- ing to a ψ-matching pair (X, create, upd) of algebras of (T0, η0, μ0) and (T1, η1, μ1) is (X, maintain) where maintain = [create, upd].
The distributive laws ↓ of (T1, η1, μ1) over F0 and [id, id] of (T0, η0, μ0) over F0 determine a distributive law [id, ↓] of (T, η, μ) over F0. As a result, the category of initializable update lenses is isomorphic to
the category of bialgebras of F0 and (T, η, μ) for the distributive law [id, ↓].

Explicitly, the objects of this category are triples of a set X, map lkp : X → S
and (T, η, μ)-algebra structure maintain : S + X × P → X satisfying


S + X × P  maintain  X¸
=[create,upd]
	lkp	 S¸

S+lkp×P
J 
S + S × P	 S¸
[id,↓]
We see that we can construct initializable update lenses by first giving ourselves the means to initialize and update the source, and only then to view the source.
