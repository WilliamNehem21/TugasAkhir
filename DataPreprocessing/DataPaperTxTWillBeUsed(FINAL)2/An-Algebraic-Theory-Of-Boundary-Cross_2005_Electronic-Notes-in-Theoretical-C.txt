Electronic Notes in Theoretical Computer Science 115 (2005) 69–88  
www.elsevier.com/locate/entcs


An Algebraic Theory Of Boundary Crossing Transitions
Arnab Ray1 ,2
Dept. of Computer Science, SUNY at Stony Brook, Stony Brook NY 11794-4400, USA
Rance Cleaveland3
Dept. of Computer Science, SUNY at Stony Brook, Stony Brook NY 11794-4400, USA
Arne Skou4
Dept. of Computer Science, Aalborg Univ, Fredriksbajersvej 7E, DK-9220 Aalborg, Denmark.

Abstract
This paper gives a process-algebraic semantics for the hierarchical state machine (HSM) fragment of Statecharts, in which state transitions are permitted to cross state boundaries. Although frowned upon by researchers as promoting unstructured modeling, such transitions are used extensively in practice to model parameterized start states and conditional exit states. The purpose of this work is to develop a compositional semantics for HSMs that may be fit together with compositional semantic accounts for Statecharts without boundary-crossing transitions in order to arrive at a compositional theory for virtually the whole Statecharts language. Our technical development consists of a process algebra for HSMs that is equipped with an operational semantics, an argument that bisimulation is a congruence for the algebra, a syntax-directed translation procedure for HSMs into the process algebra, and an equational axiomatization of the algebra.
Keywords: Statecharts, Process Algebra, Compositional Semantics, Formal Methods


1 Research supported by Army Research Office grants DAAD190110003 and DAAD190110019, and National Science Foundation grants CCR-9988489 and CCR- 0098037
2 Email: arnabray@cs.sunysb.edu
3 Email: rance@cs.sunysb.edu
4 Email: ask@cs.auc.dk


1571-0661 © 2005 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.09.029

Introduction



Statecharts [6] is a visual language for specifying reactive, embedded and real- time systems. This formalism extends finite-state machines with concepts of hierarchy (state refinement), concurrency, and priority (preemption among transitions). The success of Statecharts in the software engineering community is founded on its easy-to-learn graphical syntax and its support for the hier- archical modeling of complex control software. Dialects of the language [22] may be found in several commercial design notations, including ROOM [19] , STATEMATE [8], Stateflow [10] and UML [4].
Despite its transparent syntax, equipping Statecharts language with a for- mal operational semantics has proved to be a challenge. Pnueli and Shalev [18] gave the first authoritative operational semantics for the notation. Their ap- proach, however, was not compositional: transitions of a given chart could not be inferred purely from the transitions of its sub-charts, and thus compo- sitional reasoning techniques could not be employed on Statecharts. Various researchers have studied different approaches to overcome this compositional- ity problem, either by enriching the information stored in a transition [13,20] or redefining transitions as sequences of sub-transitions [11,12]. However, these latter works typically consider only subsets of Statecharts in which boundary- crossing transitions are disallowed. The argument offered for this restriction is that such transitions are inherently “unstructured” and their use should be disallowed.
On the other hand, boundary-crossing transitions are quite widely used in practice, and accounting for them compositionally remains an important open problem. In this paper, we address this question by defining a process algebra into which the hierarchical state-machine fragment of Statecharts can be translated in a structure- and semantics-preserving manner. The alge- bra encodes boundary-crossing transitions using ideas adapted from notions of method-invocation and exception-handling found in contemporary program- ming languages. Bisimulation is shown to be a congruence for this algebra, and our translation is structure-preserving; thus, our semantics is compositional. An axiomatization for bisimulation equivalence is also given for the process algebra, as is a discussion of the design decisions we took in designing the lan- guage. We also briefly discuss how the language may be combined with the SPL process algebra of [11], which handles the concurrency- and preemption- based features of Statecharts. The final section contains our conclusions and directions for future work.

Motivations
Our goal in this paper is to give an operational, compositional semantics for boundary-crossing transitions. The motivation for compositionality is obvious: for a modeling language to “scale” it must be possible to define the semantics of subsystems without reference to how they are embedded within larger systems. Over the past decade, operational approaches to defining language semantics have also predominated, and are especially important for modeling languages for tool-support reasons: tools like simulators and model checkers require an operational semantics for their modeling notations.

Disabled	Enabled








Fig. 1. Boundary-crossing transitions.
The need for boundary-crossing transitions is perhaps less obvious, and we devote the rest of this section to this point. As an illustration of the utility of boundary-crossing transitions in practice, consider the sample Statechart given in Fig. 1 (for clarity, we have simplified the traditional Statecharts tran- sition labels; in particular, the labels contain no action component). The diagram depicts a highly abstracted view of one of the authors’ personal digi- tal assistant (PDA), which has the following behavior: it may be switched on and, if it is functioning normally, it may be switched off. However, while the machine is switched on a bug sometimes occurs; the PDA becomes disabled and does not respond to being switched on or off until the machine is reset.
Fig. 1 models the PDA using two fundamental modes: Disabled and
Enabled, with the former being the initial configuration. Each of these fun- damental modes has two submodes: Off and Wait in the case of Disabled,
and Good and Bad in the case of Enabled. In each case, the first sub-
mode mentioned is the “default” submode within the enclosing mode. When the PDA is in the Off submode of Disabled, it may switched on (the on transition); the PDA then transitions to the default submode (i.e. Good) of the Enabled mode. In this submode the machine may be switched off, or a bug may occur. In the latter case, a transition to the Bad submode occurs, with an error transition then leading to the Wait submode of the Disabled mode. In this submode the machine cannot be switched on or off until it is


reset. At any point of time in which the machine is Enabled, the machine may be reset and move to Disabled wherein the machine goes to the default state of Disabled ie Off.
This example highlights the main uses to which boundary-crossing transi- tions are put in system modeling: conditional exits, and parameterized start states. The transition labeled on exemplifies the former: this transition indi- cates that mode Disabled can be only be exited via on when its submode is Off; this exit transition is otherwise disabled. The transition labeled err also illustrates the conditional-exit phenomenon, but it also highlights how start states can be “parameterized”, since the target of this transition is the Wait submode of Disabled. In effect, this transition stipulates that when the Disabled mode is entered via this transition, the starting submode is specified by the transition itself, rather than by the default (submode Off). The motivation for these two uses of boundary-crossing transitions is evi- dent: they keep models simple by supporting greater reuse of sub-models. In the case above, boundary-crossing transitions could be avoided, but at the cost of having to replicate the Enabled mode so that different start states could be designated. (i.e. there would be a version of Disabled having Wait as its initial submode) Such replication is wasteful and contributes to versioning issues, since different versions of the same sub-model have to be kept consis- tent with one another. Boundary-crossing transitions offer an elegant solution to this problem. The goal of this paper is to show how a compositional op- erational semantics may be given for formalisms that have boundary-crossing
transitions.

Related work
Several papers have considered the problem of an operational semantics of Statecharts. Pnueli and Shalev [18] have defined the reference operational se- mantics for Statecharts. Their approach, however, is global, in that it requires an examination of the entire structure of a Statechart term in order to com- pute its behavior. For large models, this is problematic; in such cases, for rea- sons of efficiency, one would like to “separately compile” sub-models and then combine sub-model transitions into global transitions. The Pnueli-Shalev se- mantics does not support such an approach. These observations have led other researchers to define compositional operational approaches to the semantics of Statecharts using a variety of approaches based on process algebra [11,13,20]. However, these frameworks disallow boundary-crossing transitions, arguing that such transitions are “abstraction-breaking” and thus undesirable. In this paper we argue against this point of view and indeed show that boundary- crossing transitions can be accounted for while preserving compositionality.


Huizing, Gerth and de Roever have given a compositional denotational semantics for a variant of Statecharts in [9] that includes boundary-crossing transitions. Their approach relies on the use of “partial transitions”, or un- vollendetes, as a means of detaching a sub-model of a Statechart from the rest of the model. These “dangling transitions” may be seen as entry / exit points into a model, which is a notion exploited in our semantics as well. However their semantics, is trace-based: systems are modeled via sequences of transitions leading from “incoming” partial transitions to “outgoing” ones. Such a semantics is appropriate when a model is deterministic, as earlier ver- sions of Statecharts were. However the semantics of Pnueli and Shalev allows nondeterminism, and purely trace-based models like the one in [9] suffer from an inability to properly to model the conjunctive nondeterminism (i.e. “OR- waiting”) that is predominant in event-based system modeling.
Related work on giving meaning to boundary-crossing transitions have been published by Mikk, Lakhnech and Siegel in [15]. It introduces extended hiererachical automata (extended HA) that acts as an intermediate format to facilitate the linking of new tools to the [7] Statemate environment. Closely similar to the Argos language [14] (which do not support boundary crossing transitions) extended HA provide support for boundary crossing transitions by using prioritized transtions.
Other formalisms have also used ideas similar to the entry/exit points we define. The idea of splitting transitions in order to localize information has been used in ROOM [19]. In [2], Alur and Grosu define a new Statecharts- type language with compositional semantics and modular reasoning. They also deal with boundary crossing transitions by splitting them into entry and exit points. However, their language contains no events, and their semantics, which is trace-based, has the same problems in modeling nondeterminism and conjunctive nondeterminism that the Huizing-Gerth-de Roever work does.

Hierarchical State Machines
This section introduces Hierarchical State Machines (HSMs), which are a frag- ment of conventional Statecharts. Like Statecharts, HSMs permit the defini- tion of hierarchical state machines with boundary-crossing transitions; unlike Statecharts, HSMs have no provision for concurrency, and transition labels may only contain simple events (no trigger/action pairs, no negated events, etc.). In this paper we study HSMs rather than Statecharts in order to study boundary-crossing transitions; at the end, however, we discuss how our work may be combined with that of [11] in order to obtain a compositional theory treating these other language features as well.

Syntax of HSMs
In order to formalize the notion of HSMs we first introduce the concept of state frames, which define hierarchical state structures such as the one in Fig. 1.
Definition 3.1 The set F of state frames is the least set such that ⟨S, sI, e⟩ ∈ 
F when:
S is a finite, nonempty set of states;
sI ∈ S is the start state; and
e : S → F, the embedding function, is a partial function.
Note that F is defined inductively, and that the definition is well-formed, since the occurrence of F in Part iii of the definition appears covariantly. The inductiveness of the definition also ensures the absence of cyclic structures.” Intuitively, a state frame contains a set of states and a start state, with each state in turn potentially containing a state frame nested within in it, as defined by the embedding function. The form of the definition also ensures that the nesting structure within a state frame state frame can only be finitely deep, since the “base case” of the inductive definition introduces state frames whose embedding function is everywhere undefined.
Example 3.2 Fig. 2 depicts the state frame ⟨{s1, s2}, s2, e⟩ graphically. Note that e is partial: e(s1) is defined, while e(s2) is not. States, like s2, for which the embedding function is undefined are sometimes referred to as basic states in Statecharts terminology.

Fig. 2. A state frame.
State frames will be used to define the states of HSMs. To define the transition relation of an HSM, we introduce the notion of transition endpoints of a state frame. In what follows, we use · to represent list concatenation, ε for the empty list, and ≤ to represent the prefix ordering on lists ( eg a ≤ a.b ie a is a prefix of a.b and would hence come before it in the ordering) . We also abuse notation by identifying single-element lists with the element they contain; so if S is a set and s ∈ S, then we also treat s as a list whose only element is s.

Definition 3.3 The transition endpoints, E(F ), of state frame F = ⟨S, sI, e⟩
are defined inductively as follows.
S ⊆ E(F ).
If e ∈ S, e(s) is defined, and l' ∈ E(e(s)), then s · l' ∈ E(F ). Intuitively, transition endoints may be thought of as lists of states.
Example 3.4 In the state frame F given in Fig. 2,
E(F )= {s1, s2, s1 · t1, s1 · t2, s1 · t1 · u1, s1 · t1 · u2}.
To define HSMs formally, we first fix a set L of transition labels. An HSM now consists of a state frame and a transition relation involving labels and the transition endpoints of the frame.
Definition 3.5 An HSM has form ⟨S, sI, e, ~⟩, where:
F = ⟨S, sI, e⟩ is a state frame.
~⊆ E(F ) × L × E(F ) is the transition relation.

Fig. 3. A hierarchical state machine.
Example 3.6 Fig. 3 contains a HSM whose state frame is given by Fig. 2.
Operational semantics of HSMs
We now define the operational semantics of HSMs by showing how they can be translated into standard, “flat”, labeled transition systems. Before making this definition, we first introduce an auxiliary notion on state frames.
Definition 3.7 Let F = ⟨S, sI, e⟩ be a state frame, and let l ∈ E(F ). Then maxF (l) is defined as follows.
⎧ l	if l ∈ S and e(l) undefined
maxF (l)=	l · maxF ' (s' ) if l ∈ S and e(l)= F ' = ⟨S', s' , e'⟩
⎪⎪⎩ s · maxe(s)(l') if l = s · l' and l' ∈ E(e(s))


Intuitively, maxF (l) extends l into a “maximal” transition endpoint (i.e. one whose last state component is guaranteed to be a basic state) by padding l appropriately with initial states. We now give the semantics of HSMs as follows.
Definition 3.8 Let H = ⟨S, sI, e, ~⟩ be a HSM, and define FH = ⟨S, sI, e⟩. Then the labeled transition system LTS(H)= ⟨SH, sH, −→H⟩, where the state set SH, initial state sH ∈ SH, and transition relation −→H⊆ SH × L × SH are given as follows.
SH contains the maximal (with respect to ≤) transition endpoints of F :
SH = {l ∈ E(F ) | ∀l' ∈ E(F ).l ≤ l' =⇒ l = l'}.
sH = maxFH (sI).

l −a→
l' if there exists l1
≤ l such that l1 ~
' and l' = maxH
(l' ).

Example 3.9 With H, HF given as in Fig. 3, we have:
SH = {s1 · t1 · u1, s1 · t1 · u2, s1 · t2, s2} sH = maxF (s2)= s2
The transition relation −→H consists of the following.


s1 s1
s · t
· t2
· t2
· u
−a→
−a→
−a→

s2
s1 · t1 s


· u1
s −→b	s · t s · t · u −→c	s
d

1	1	1	H  2
a
s1 · t1 · u1 −→H s1 · t2

s1 · t1 · u2 −→H s2
s · t · u −d→ s · t

s1 · t1
· u1
−a→
s1 · t1
· u2
1	1	2
H  1	2


Compositionality
From the definition of HSMs it is apparent why compositionality is problem- atic: while the states of a HSM are defined compositionally, the edge relation
~ is given globally. This gives the definition of the semantic transition rela- tion −→H a non-compositional flavor: in particular, transitions for a state are not inferable based on the basis transitions of sub-states. This is the reason that boundary-crossing transitions have not been considered in compositional treatments of Statecharts semantics.
However, the discussion in Section 2 hints at a compositional approach to a semantics: treat states as having “entry” and “exit” points into their internal structure. Rather than atomic entities, boundary-crossing transitions may be thought of as consisting of multiple “segments” that connect entry / exit points appropriately. The information about these transition segments is


stored locally in the process definitions; when the components are composed, the transition segments are “stitched” together to form the global transition.
Fig.	4 is Fig. 1 redrawn by explicitly showing entry and exit points by blackened triangles.

Disabled	Enabled
Fig. 4. Entry and exit points.

The next section formalizes these intuitions in the setting of process al- gebra. Specifically, we define a process algebra containing notions of entry and exit points, together with operators for “entering” and “exiting” process terms. We treat these notions semantically by in essence viewing entry points as analogous to “method declarations”, with entry being like method invo- cation, and exit points as exceptions and exiting as exception handling. We establish compositionality for the algebra by showing that bisimulation [16] is a congruence for the algebra. Finally, we use this algebra as a vehicle for giving a compositional semantics, via a syntax-directed translation, for HSMs. The notions of entry and exit points have been used in other graphical state-machine-based formalisms, most notably ROOM [19] and the hierarchic state machines of [2]. Neither, however, provides an algebraic treatment of these notions, and the semantics of ROOM, while precise, is not formal. As noted earlier, the state machines of [2] do not contain the notion of event, and the trace-based semantics there, while adequate for that framework, suffers from the usual problems in the presence of conjunctive (i.e. “or-waiting”)
nondeterminism that is inherent in event-based notations like HSMs.


A Process Algebra for HSMs
The syntax of HPA, our process algebra for HSMs, is parameterized with respect to the set L of transition labels used in the definition of HSMs and a countably infinite set C of process identifiers. In what follows, we assume



a




(1) Q =∆ (a)P	(2) R =∆ b.<a>Q



(3) P =∆ a.Q + b.R + [c|	(4) Q = [c| [⟩ ([c♩b.R)
Fig. 5. HSMs and associated HPA terms
a ∈ L and X ∈ C. The terms of HPA may now be given as follows.
P ::= nil | X | a.P | P + P	(Regular CCS)

In the sequel we use T to represent the set of all HPA terms.
Understanding HPA
HPA extends regular CCS [16] (i.e. CCS without parallel composition, re- striction or relabeling) with operators for “embedding” one process within another (this operator is reminiscent of the disabling operator of LOTOS [3], and is also used as an embedding operator in [20]), for defining entry and exit points, and for exercising these entry and exit points. An intuitive reading of the operators is as follows. The term nil represents the terminated process that perform no actions, while a.P means a process that can perform an a


action and become P . P + P means a process’s behavior is determined by the non-deterministic choice operator +. X constitutes an “invocation” of a process declared via an equation X =∆ P . In P [⟩Q, P is allowed to perform its actions until Q “disables” it by performing an action; after this point, the process behaves like Q. The term (a)P may be thought of as the declaration of a “method” a with body P that, when invoked, behaves like P . Process
<a>P “invokes” method a in P , causing control to shift to the body of the method. Process [a| attempts to “exit at a”; this is analogous to raising an exception named a. Handlers for such exits / exceptions may be defined using [a♩P , with the [⟩ operator being used to connect processes that raise exceptions with their handlers.
Fig. 5 contains examples highlighting the HSM intuitions behind these constructs. Example (1) shows the intended correspondence between (a) and entry points: (a)P allows a transition to “attach” to P via entry point a.
Example (2) shows how another process R uses Q’s entry point on a; the net intended effect is that in R, a b transition will lead to sub-state P with the larger state Q. Note that there are two transition segments: one from R to the boundary of Q and another from that point to the boundary of P . The full transition is formed by joining these segments together.
Example (3) shows how exit points may be defined. Here P can evolve into Q or R but it can also do an exit through an exit point c.
Finally, Example (4) shows how an exit point c is handled. Here P defines an exit point c and crosses Q’s boundary and becomes R. Another thing to note here is the [⟩ operator; in addition to its use as an “embedding” operator it also is responsible for “connecting” exits to handlers.

Operational Semantics of HPA
To formalize this semantics we use the SOS approach [17]. The rules are contained in Fig. 6. As is standard in process algebra, we assume the existence of an environment of equations of form X =∆ P associating terms to process identifiers.
Before discussing the rules we first note that the labels on the transitions have a richer structure than those for HSMs. In particular, in addition to elements of the set L, transitions may be labeled by:
(a) existence of an entry point / method declaration a
[a| capability of exiting via / raising exception a
[a♩ capability of attaching to, or handling, exit / exception a.
We use (L), [L| and [L♩ to denote the set of all entry, exit and “handle”



(P)	(S1)




(S2)



(Em1)



(Em3)
(R)



[a /∈ [L|] (Em2)





(Entry)



(Ex)
(Enter)



(H)



Fig. 6. SOS rules for HPA.
actions, respectively.
Rules (P), (S1), (S2) and (R) are standard from CCS, and we do not elabo- rate on them here. Rules (Em1)–(Em3) define the behavior of the embedding operator. (Em1) stipulates that P1[⟩P2 can perform the non-exit transitions of P1 while P2 idles, while (Em2) states that this process can engage in ex- actly the non-handler transitions of P2, with P1 being disabled in the process. (Em3) establishes that P2 can “handle” exits enabled by P1. Rule (Entry) states that (a)P enables an entry point a, while (Enter) establishes that <a>P can “enter” the a entry point of P . Rules (Ex) and (H) define the behavior of [a|, which is an exit point, and [a♩P , which is capable of attaching to exit point a.


Note that rules (Em3) and (Enter) use chaining among the premises: the target of one transition in the premise is used as the source of another tran- sition in the premise.

Example
The following is an encoding of the “decorated” HSM in Fig. 4.
Disabled =∆ (Off + (d ).Wait) [⟩ DO Off =∆ [d |
Wait =∆ reset.Off Enabled =∆ Good [⟩ EO
Good =∆ bug.Bad + [e |
Bad =∆ [e |
DO =∆ [d ♩on.Enabled
EO =∆ [e ♩off.Disabled + [e ♩err.<d >Disabled
+reset.DISABLED
Using the SOS rules one can infer the existence of transitions such as the following.


(d2 )
Disabled −→
bug
Wait [⟩ DO
Disabled −o→n
err
Enabled

Enabled −→
Bad [⟩ EO
Bad [⟩ EO −→
Wait [⟩ DO

Compositionality
Process algebra has a rich meta-theory for bisimulation that has been de- veloped around SOS operational definitions. One such result may be found in [21], which asserts that, provided the SOS rules for a process algebra fall within a specific syntactic format presented in that paper, bisimulation equiv- alence [16] will be a congruence for that algebra. The SOS rules of HPA satisfy this criterion, and thus it immediately follows that bisimulation is a congruence for HPA.

Converting HSMs to HPA
In the previous two sections we developed the theories of HSMs and HPA, with a view toward using the latter to give a compositional semantics of the former. We complete this program in this section by giving a structure-based translation of HSMs into HPA terms.


The algorithm below takes as its input a HSM and outputs the correspond- ing PA term, together with a list of process-identifier declarations used in the term. The key elements of the translation are: (1) the use of the embed- ding operator [⟩ to embed an HSM inside the state of another HSM; (2) the handling of “incoming” boundary-crossing transitions using the (a) and <a> constructs; and (3) the encoding of “outgoing” boundary-crossing transitions via [a| and [a♩ constructs. More detailed information can be found in the comments in the pseudo-code.

Input:
HSM H = ⟨S, sI, e, ~⟩


Output:
⟨XsI , E⟩, where:
XsI is a variable associated with sI
E is a list of HPA declarations of the form Xs =
E(⟨S, sI, e⟩).
Assume:




Ps indexed by s ∈

Existence of injective function f : ~ × E⟨S, sI, e⟩ → L that, given an edge and a transition endpoint, returns a unique label.

algorithm Trans (⟨S, sI, e, ~⟩) return TransAux (ε, ⟨S, sI, e⟩) end algorithm Trans
/* TransAux does the ”real work” of the translation. The parameter l
records the ”path” in the HSM to the state frame that is the second parameter */
algorithm TransAux (l, ⟨S, sI, e⟩)
E := ε /* E is list of equations to return */
/* Generate equation for each state in S. */
for each s ∈ S do:
eO := nil; /* eO will be term for ”outer part” of s */
if e(s) is undefined then eI := nil /* eI: ”inner part” of s */
else ⟨X', E'⟩ := TransAux (l · s, e(s)); /* recursive call */
E := E · E';
eI := X'
/* Now handle transitions involving states in S.*/

for each t = ⟨l1, a, l2⟩ ∈~ do
/* Case when transition originates from the current state.*/
if l1 = l · s then
if l2 = l · s' then /* non-BCT */
eO := eO + a.Xs'

else if l2 = l · s' · l'
/* BCT entering sibling state*/

then eO := eO + a.<f (t, l · s')>X'
else eO := eO + [f (t, l)| /* Outgoing for parent */

/* Case when transition originates from substate of current state.*/

else if l1 = l · s · l'
some l'
then

if l2 = l · s' then /* transition target is sibling of current state */
eO := eO + [f (t, l · s)♩a.Xs'

else if l2 = l · s' · l'
then /* transition target is child of sibling */

eO := eO + [f (t, l · s)♩a.<f (t, l · s')>X'
else /* transition is BCT for parent also */
eO := eO + [f (t, l · s)♩[f (t, l)|
/* Case when transition is incoming to current state.*/

else if l2 = l · s · s' · l'
then

if l'
= ε then /* i.e. transition ends at s’ */

eI = eI + (f (t, l · s))Xl·s'
else eI := eI + (f (t, l · s))<f (t, l · s · s')>Xl·s·s'
od;
E := (X =∆ (e [⟩ e )) · E;
od;
return ⟨XsI , E⟩
end algorithm TransAux


Correctness of the Translation
We now outline the proof of correctness of the translation procedure. Our general approach will be to show that one can build a bisimulation-like relation between HSM states and HPA terms that relates the HSM initial “semantic state” to the HPA term returned by our translation.
Of course, HPA terms are capable of transitions that HSM states are not: in particular, transitions labeled by (a), [a| and [a♩ cannot be matched by HSM states. So the relation that we construct will only consider elements of L; the other transitions in the HPA terms may be thought of as the “infras- tructure” that is needed for compositionality.

Theorem 5.1 Let H = ⟨S, sI, e, ~⟩ be an HSM, with LTS(H) = ⟨SH, sH,
−→H⟩ and T rans(H) = ⟨P, E⟩ the HPA term and supporting declarations constructed by our algorithm. Then there exists R ⊆ SH ×T such that sH RP, and such that whenever sR t, then for any a ∈ L:
If s −a→	s' then there exists t' such that t −a→ t' and s' R t'.
If t −a→ t' then there exists s' such that s −a→	s' and s' R t'.

Axiomatizing HPA
Although we have referred to HPA as a process algebra, we have not yet endowed it with any algebraic structure. In this section we address this issue by giving a sound and complete equational axiomatization for the finite (i.e. identifier-free) fragment of HPA.
Another apparently relevant result from the SOS meta-theory of process algebra may be found in [1]; in that paper, a method is given for automatically generating sound and complete axiomatizations for bisimulation from SOS rules. However, the rules for HPA fall outside the format considered in that paper, so we cannot use that work.
Table 1 lists the axioms; we comment on them briefly here. (A1)–(A4) are the standard monoid and absorption laws for CCS. The remaining equations are designed to eliminate occurrences of [⟩ and <a> from terms: key among these are (Em5), which accounts for the interaction between exit points and exit handlers, and (En4), which captures the interplay between entry points and the enter operation.
Proving these laws sound and complete may be done using standard tech- niques [16]. Soundness follows from the construction of appropriate bisimu- lations. Completeness relies on the definition of normal syntactic forms; the definition of these may be intuited from the definition of r in the prelude to Axioms (Em3)–(Em6) in the table. Although laborious, the details are routine and are omitted.

Discussion
In this section we present the rationales for some the decisions we took in developing the work in this paper. We also outline how HPA may be com- bined with the process algebra given in [11] in order to obtain a compositional semantic theory for Statecharts with boundary-crossing transitions.
To begin with, one may wonder why we elected to give our compositional semantics of HSMs indirectly, via a translation into a process algebra. Both



(A1)		x + y = y + x	(A2)	x + (y + z) = (x + y)+ z (A3)	x + nil = x	 (A4)		x + x = x

(Em1)	nil [⟩ x = x	(Em2) (x + y) [⟩ z = (x [⟩ z)+ (y [⟩ z)

In (Em3)–(Em6), let
r' = Σ ai.xi + Σ(bj)yj + Σ[ck|
i	j	k
r = r' + Σ[dl♩zl
l


Table 1
Axiomatizing HPA for bisimulation.

pragmatic and philosophical considerations played a role in this decision. On the one hand, the work grew out of an effort to model and verify a controller for a battlefield medical device (an automatic resuscitator). In that study the state-machine models we were working with had boundary-crossing tran- sitions, but the verification tool we were using (the CWB-NC [5]) had only a textual interface. We therefore had to come up with a textual language for boundary-crossing transitions, and that notation played a major part in the work here. At a more conceptual level, however, compositionality is an in- herent feature of process algebras; when attempting to define a compositional semantics for a new modeling-language feature, a natural strategy to pursue involves defining an algebra for the feature so that the rich meta-theory of process algebra may be brought to bear. (In our case, we got “bisimulation congruence” for free because of this.) Once one has an understanding of the


basic conceptual issues, one may then explore more direct semantics accounts. Another issue involves the design of the process algebra HPA. In general, three main considerations guided our development of this language: HSMs should be easy to encode in the language; the operational and equational theory should be clean; and the language should be easy to combine with the process algebra in [11], which is used as a vehicle for giving a composi- tional semantics for Statecharts without boundary-crossing transitions. Other considerations, such as how to handle various types of nondeterminism, were
generally left aside. Thus, for example, the process
<a>((a)b.nil + (a)c.nil)
is bisimilar to the process b.nil + c.nil, even though some may argue that the existence of two “different” a method declarations / entry points in the body of the <a> ··· term ought to lead to a nondeterministic (internal) choice between the b.nil and c.nil. However, our needs in this paper do not depend on reflecting such internal choices, we elected not to try to force them into the language. Similar considerations underpin our treatment of exceptions / exit points ([a|) and exit handling ([a♩P ). The language in its current form requires that exits be handled immediately by a handler; in particular, in the process
([a| [⟩ nil) [⟩ [a♩P
the a-handler cannot handle the a-exit because of the intervening nil. For the purposes of translating HSMs this is not problematic, and indeed the axiomatization of this language is slightly simpler because of this design choice. However, one could imagine redesigning the language to allow exceptions / exits to be handled more flexibly (by, e.g., eliminating the side conditions in the SOS rules (Em1) and (Em2) for [⟩); the resulting axiomatization, however, is more complex.
We close this section by commenting on how HPA may be enriched in order to model the other features of Statecharts, including concurrency and preemption. In [11] a process algebra, SPL, was introduced in order to give a compositional semantics to Statecharts without boundary-crossing transitions. The syntax of SPL is parameterized with respect to a set of labels (event names); it shares some operators with HPA (+, recursion), has some operators that are not present at all in HPA (emit, parallel composition, restriction, delay), and has some that are similar to, but differ in key respects, from those in HPA (prefix, disabling, enabling). The operational semantics is given via a transition relation that is labeled with two sets of events: those emitted, and those that must be absent from the environment. It it straightforward to merge HPA into SPL as follows: add entry, enter, exit and handle operators;


use the SPL notion of prefixing; adapt the definitions of parallel composition and restriction to be sensitive to HPA transition labels; and modify the SPL disabling operator in order to introduce an exit-handling capability. Since the transition labels of SPL and HPA are disjoint, the modifications are not difficult. However, the resulting language is somewhat large; for this reason we have focused our technical development on HPA in this paper.

Conclusions and Directions for Future Work
In this paper we have developed a compositional operational semantics for hierarchical state machines (HSMs). HSMs enrich traditional state machines with capabilities for embedding state machines within states of other machines and for transitions that cross state boundaries. Traditional wisdom has been that such boundary-crossing transitions are inherently non-compositional; we prove that this need not be the case. The semantics relies on a structure- preserving translation into a process algebra for which bisimulation equiva- lence is a congruence. This last fact ensures that the semantics of HSMs is also compositional. We also give a sound and complete axiomatization of the process algebra for bisimulation equivalence.
As future work, we wish to study the incorporation of our ideas into richer calculi, such as the Statecharts process algebra of [11], which includes treat- ments for the other constructs in Statecharts that are not present in HSMs. We also think ideas from [12] may be adopted to this paper in order to give a direct compositional semantics to HSMs rather than an indirect one, via translation, as is done in this paper.

References
Aceto, L., B. Bloom and F. Vaandrager, Turning SOS rules into equations, Information and Computation 111 (1994), pp. 1–52.
Alur, R. and R. Grosu, Modular reﬁnement of hierarchic reactive machines, Principles of Programming Languages(POPL) 390-402 (2000).
Bolognesi, T. and E. Brinksma, Introduction to the ISO speciﬁcation language LOTOS, Computer Networks and ISDN Systems 14 (1987), pp. 25–59.
Booch, G., I. Jacobson and J. Rumbaugh, “The Unified Modeling Language User Guide,” Addison-Wesley, 1998.
Cleaveland, R. and S. Sims, Generic tools for verifying concurrent systems, Science of Computer Programming 41 (2002), pp. 39–47.
D.Harel, Statecharts: A visual formalism for complex systems, Science of Computer Programming,8 (1987), pp. 231–274.
Harel, D. and A. Naamad, The STATEMATE semantics of statecharts, ACM Transactions on Software Engineering and Methodology 5 (1996), pp. 293–333.


Harel, D. and M. Politi, “Modeling Reactive Systems with Statecharts: the STATEMATE Approach,” McGrawHill, 1998.
Huizing, C., R. Gerth and W. de Roever, CAAP ’88, 13th colloquium on trees in algebra and programming, in: M. Dauchet and M. Nivat, editors, CAAP, Lecture Notes in Computer Science 299 (1988), pp. 271–294.
Inc., T. M., http://www.mathworks.com/products/stateflow .
Luettgen, G., M. von der Beeck and R. Cleaveland, Statecharts via process algebra, in: J. Baeten and S. Mauw, editors, Tenth International Conference on Concurrency Theory (CONCUR ’99), Lecture Notes in Computer Science 1664 (1999), pp. 399–414.
Luettgen, G., M. von der Beeck and R. Cleaveland, A compositional approach to statecharts semantics, in: D. Rosenblum, editor, Eighth International Symposium on Foundations of Software Engineering (2000), pp. 120–129.
Maggiolo-Schettini, A., A. Peron and S. Tini, Equivalences of Statecharts, in: U. Montanari and V. Sassone, editors, Seventh International Conference on Concurrency Theory (CONCUR ’96),, Lecture Notes in Computer Science 1119 (1996), pp. 687–702.
Maraninchi, F., The argos language:graphical representation of automata and description of reactive systems, IEEE Workshop on Visual Languages (1991).
Mikk, E., Y. Lakhnech and M. Siegel, Hierarchical automata as model for statecharts, Asian Computer Science Conference (ASIAN’97), LNCS 1345 (1997).
Milner, R., “Communication and Concurrency,” Prentice Hall, 1989.
Plotkin, G., A structural approach to operational semantics, Technical Report DAIMI-FN-19, Computer Science Department, Aarhus University, Aarhus, Denmark (1981).
Pnueli, A. and M. Shalev, What is in a step: On the semantics of statecharts, in: T. Ito and
A. R. Meyer, editors, Theoretical Aspects of Computer Software: Proc. of the International Conference TACS’91, Springer, Berlin, Heidelberg, 1991 pp. 244–264.
Selic, B., G. Gullelson and P. Ward, “Real Time Object Oriented Modelling and Design,” J.Wiley, 1994.
Uselton, A. and S. Smolka, A compositional semantics for Statecharts using labeled transition systems, in: B. Jonsson and J. Parrow, editors, Fifth International Conference on Concurrency Theory (CONCUR ’94), Lecture Notes in Computer Science 836 (1994), pp. 2–17.
Verhoef, C., A congruence theorem for structured operational semantics with predicates and negative premises, in: B. Jonsson and J. Parrow, editors, Fifth International Conference on Concurrency Theory (CONCUR ’94), Lecture Notes in Computer Science 836 (1994), pp. 433–448.
von der Beeck, M., A comparison of statecharts variants, Lecture Notes in Computer Science
863 (1994), pp. 128–128.
