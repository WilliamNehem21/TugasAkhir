	Electronic Notes in Theoretical Computer Science 196 (2008) 113–128	
www.elsevier.com/locate/entcs

A Bidirectional Refinement Type System for LF
William Lovas1	Frank Pfenning2
Computer Science Department Carnegie Mellon University Pittsburgh, PA, USA

Abstract
We present a system of refinement types for LF in the style of recent formulations where only canonical forms are well-typed. Both the usual LF rules and the rules for type refinements are bidirectional, leading to a straightforward proof of decidability of type-checking even in the presence of intersection types. Because we insist on canonical forms, structural rules for subtyping can now be derived rather than being assumed as primitive. We illustrate the expressive power of our system with several examples in the domain of logics and programming languages.
Keywords: LF, refinement types, subtyping, dependent types, intersection types


Introduction
LF was created as a framework for defining logics [6]. Since its inception, it has been used to formalize reasoning about a number of deductive systems (see [13] for an introduction). In its most recent incarnation as the Twelf metalogic [14], it has been used to encode and mechanize the metatheory of programming languages that are prohibitively complex to reason about on paper [3,9].
It has long been recognized that some LF encodings would benefit from the addition of a subtyping mechanism to LF [12,2]. In LF encodings, judgements are represented by type families, and many subsyntactic relations and judgemental inclusions can be elegantly represented via subtyping.
Prior work has explored adding subtyping and intersection types to LF via reﬁnement types [12]. Many of that system’s metatheoretic properties were proven indirectly by translation into other systems, though, giving little insight into a

1 Email: wlovas@cs.cmu.edu
2 Email: fp@cs.cmu.edu

1571-0661© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.09.021

notion of adequacy or an implementation strategy. We present here a refinement type system for LF based on the modern canonical forms approach, and by doing so we obtain direct proofs of important properties like decidability.
In canonical forms-based LF, only β-normal η-long terms are well-typed — the syntax restricts terms to being β-normal, while the typing relation forces them to be η-long. Since standard substitution might introduce redexes even when substi- tuting a normal term into a normal term, it is replaced with a notion of hereditary substitution that contracts redexes along the way, yielding another normal term. Since only canonical forms are admitted, type equality is just α-equivalence, and typechecking is manifestly decidable.
Canonical forms are exactly the terms one cares about when adequately encod- ing a language in LF, so this approach loses no expressivity. Since all terms are normal, there is no notion of reduction, and thus the metatheory need not directly treat properties related to reduction, such as subject reduction, Church-Rosser, or strong normalization. All of the metatheoretic arguments become straightforward structural inductions, once the theorems are stated properly.
By introducing a layer of refinements distinct from the usual layer of types, we prevent subtyping from interfering with our extension’s metatheory. We also follow the general philosophy of prior work on refinement types [5,4] in only assigning refined types to terms already well-typed in pure LF, ensuring that our extension is conservative.
In the remainder of the paper, we describe our refinement type system alongside several illustrative examples (Section 2). Then we explore its metatheory and give proof sketches of important results, including decidability (Section 3). We note that our approach leads to subtyping only being defined on atomic types, but we show that subtyping at higher types is already present in our system by proving that the usual declarative rules are sound and complete with respect to an intrinsic notion of subtyping (Section 4). Finally, we discuss some related work (Section 5) and summarize our results (Section 6).

System and Examples
We present our system of LF with Refinements, LFR, through several examples. In what follows, R refers to atomic terms and N to normal terms. Our atomic and normal terms are exactly the terms from canonical presentations of LF.

R ::= c | x | R N	atomic terms
N, M ::= R | λx. N	normal terms

In this style of presentation, typing is defined bidirectionally by two judgements: R ⇒ A, which says atomic term R synthesizes type A, and N ⇐ A, which says normal term N checks against type A. Since λ-abstractions are always checked against a given type, they need not be decorated with their domain types.

Types are similarly stratified into atomic and normal types.
P ::= a | P N	atomic type families
A, B ::= P | Πx:A. B	normal type families
The operation of hereditary substitution, written [N/x]A , is a partial function which computes the normal form of the standard capture-avoiding substitution of N for x. It is indexed by the putative type of x, A, to ensure termination, but neither the variable x nor the substituted term N are required to bear any relation to this type index for the operation to be defined. We show in Section 3 that when N and x do have type A, hereditary substitution is a total function on well-formed terms.
Our layer of refinements uses metavariables Q for atomic sorts and S for nor- mal sorts. These mirror the definition of types above, except for the addition of intersection and “top” sorts.
Q ::= s | Q N	atomic sort families
S, T ::= Q | Πx::SиA. T | T | S1 ∧ S2	normal sort families
Sorts are related to types by a refinement relation, S и A (“S refines A”), discussed below. A term of type A can be assigned a sort S only when S и A. We occasionally omit the “и A” from function sorts when it is clear from context.
Example: Natural Numbers
For the first running example we will use the natural numbers in unary notation.
In LF, they would be specified as follows
nat : type.	zero : nat.	succ : nat → nat.
Suppose we would like to distinguish the odd and the even numbers as refine- ments of the type of all numbers.
even и nat.	odd и nat.
The form of the declaration is s и a where a is a type family already declared and s is a new sort family. Sorts headed by s are declared in this way to refine types headed by a. The relation S и A is extended through the whole sort hierarchy in a compositional way.
Next we declare the sorts of the constructors. For zero, this is easy:
zero :: even.
The general form of this declaration is c :: S, where c is a constant already declared in the form c : A, and where S и A. The declaration for the successor is slightly more difficult, because it maps even numbers to odd numbers and vice versa. In order to capture both properties simultaneously we need to use intersection sorts, written as S1 ∧ S2. 3

3 Intersection has lower precedence than arrow.

succ :: even → odd Λ odd → even.
In order for an intersection to be well-formed, both components must refine the same type. The nullary intersection T can refine any type, and represents the maximal refinement of that type. 4


s и a ∈ Σ


s N1 ... Nk и a N1 ... Nk
S и A	T и B


Πx::S. T и Πx:A. B
S1 и A	S2 и A S1 Λ S2 и A



T и A
To show that the declaration for succ is well-formed, we establish that even → odd Λ
odd → even и nat → nat.
The reﬁnement relation S и A should not be confused with the usual subtyping relation. Although each is a kind of subset relation, they are quite different: Sub- typing relates two types, is contravariant in the domains of function types, and is transitive, while refinement relates a sort to a type, so it does not make sense to consider its variance or whether it is transitive. We will discuss subtyping below and in Section 4.
Now suppose that we also wish to distinguish the strictly positive natural num- bers. We can do this by introducing a sort pos refining nat and declaring that the successor function yields a pos when applied to anything, using the maximal sort.
pos и nat.    succ :: ··· Λ T → pos.
Since we only sort-check well-typed programs and succ is declared to have type
nat → nat, the sort T here acts as a sort-level reflection of the entire nat type.
We can specify that all odds are positive by declaring odd to be a subsort of pos.
odd ≤ pos.
Although any ground instance of odd is evidently pos, we need the subsorting dec- laration to establish that variables of sort odd are also pos.
Now we should be able to verify that, for example, succ (succ zero) ⇐ even. To explain how, we analogize with pure canonical LF. Recall that atomic types have the form a N1 ... Nk for a type family a and are denoted by P . Arbitrary types A are either atomic (P ) or (dependent) function types (Πx:A. B). Canonical terms are then characterized by the rules shown in the left column above.
There are two typing judgements, N ⇐ A which means that N checks against A (both given) and R ⇒ A which means that R synthesizes type A (R given as input, A produced as output). Both take place in a context Γ assigning types to variables. To force terms to be η-long, the rule for checking an atomic term R only checks it at an atomic type P . It does so by synthesizing a type P ' and comparing it to the given type P . In canonical LF, all types are already canonical, so this comparison is just α-equality.

4 As usual in LF, we use A → B as shorthand for the dependent type Πx:A. B when x does not occur in
B.



On the right-hand side we have shown the corresponding rules for sorts. First, note that the format of the context Γ is slightly different, because it declares sorts for variables, not just types. The rules for functions and applications are straight- forward analogues to the rules in ordinary LF. The rule switch for checking atomic terms R at atomic sorts Q replaces the equality check with a subsorting check and is the only place where we appeal to subsorting (defined below). For applications, we use the type A that refines the type S as the index parameter of the hereditary substitution.
Subsorting is exceedingly simple: it only needs to be defined on atomic sorts, and is just the reflexive and transitive closure of the declared subsorting relationship.


s1≤s2 ∈ Σ

	
s1 N1 ... Nk ≤ s2 N1 ... Nk	Q ≤ Q
Q1 ≤ Q'	Q' ≤ Q2 Q1 ≤ Q2

The sorting rules do not yet treat intersections. In line with the general bidirec- tional nature of the system, the introduction rules are part of the checking judge- ment, and the elimination rules are part of the synthesis judgement.


Γ ▶ N ⇐ S1	Γ ▶ N ⇐ S2


Γ ▶ N ⇐ S1 Λ S2
(Λ-I)


Γ ▶ N ⇐ T 
(T-I)



Γ ▶ R ⇒ S1 Λ S2


Γ ▶ R ⇒ S1
(Λ-E1)
Γ ▶ R ⇒ S1 Λ S2


Γ ▶ R ⇒ S2
(Λ-E2)

Note that although LF type systhesis is unique, sort synthesis is not, due to the intersection elimination rules.
Now we can see how these rules generate a deduction of succ (succ zero) ⇐ even. The context is always empty and therefore omitted. To save space, we abbreviate even as e, odd as o, pos as p, zero as z, and succ as s, and we omit reflexive uses of

subsorting.


▶ s (s z) ⇒ e
▶ s (s z) ⇐ e
Using the Λ-I rule, we can check that succ zero is both odd and positive:


.
▶ s z ⇐ o
.
▶ s z ⇐ p

▶ s z ⇐ o Λ p
Each remaining subgoal now proceeds similarly to the above example.
To illustrate the use of sorts with non-trivial type families, consider the definition of double in LF.
double : nat → nat → type.
dbl-zero : double zero zero.
dbl-succ : ΠX:nat. ΠY :nat. double X Y → double (succ X) (succ (succ Y )).
With sorts, we can now directly express the property that the second argument to double must be even. But to do so, we require a notion analogous to kinds that may contain sort information. We call these classes and denote them by L.
K ::= type | Πx:A. K	kinds
L ::= type | Πx::SиA. L | T | L1 Λ L2	classes
Classes L mirror kinds K, and they have a refinement relation L и K similar to S и A. (We elide the rules here.) Now, the general form of the s и a declaration is s и a :: L, where a : K and L и K; this declares sort constant s to refine type constant a and to have class L.
We reuse the type name double as a sort, as no ambiguity can result. As before, we use T to represent a nat with no additional restrictions.
double и double :: T → even → type.
dbl-zero :: double zero zero.
dbl-succ :: ΠX::T. ΠY ::even. double X Y → double (succ X) (succ (succ Y )).
After these declarations, it would be a sort error to pose a query such as “?- double X (succ (succ (succ zero))).” before any search is ever attempted. In LF, queries like this could fail after a long search or even not terminate, depending on the search strategy.
The tradeoff for such precision is that now sort checking itself is non- deterministic and has to perform search because of the choice between the two

intersection elimination rules. As Reynolds has shown, this non-determinism causes intersection type checking to be PSPACE-hard [16], even for normal terms as we have here [15]. Using techniques such as focusing, we believe that for practical cases they can be analyzed efficiently for the purpose of sort checking. 5
A Second Example: The λ-Calculus
As a second example, we use an intrinsically typed version of the call-by-value simply-typed λ-calculus. This means every object language expression is indexed by its object language type. We use sorts to distinguish the set of values from the set of arbitrary computations. While this can be encoded in LF in a variety of ways, it is significantly more cumbersome.
tp : type.	% the type of object language types
0 : tp → tp → tp.	% object language function space
%infix right 10 0 .
exp : tp → type.	% the type of expressions
cmp и exp.	% the sort of computations
val и exp.	% the sort of values
val ≤ cmp.	% every value is a (trivial) computation
lam :: (val A → cmp B) → val (A 0 B).
app :: cmp (A 0 B) → cmp A → cmp B.
In the last two declarations, we follow Twelf convention and leave the quantifica- tion over A and B implicit, to be inferred by type reconstruction. Also, we did not explicitly declare a type for lam and app. We posit a front end that can recover this information from the refinement declarations for val and cmp, avoiding redundancy. The most interesting declaration is the one for the constant lam. The argument type (val A → cmp B) indicates that lam binds a variable which stands for a value of type A and the body is an arbitrary computation of type B. The result type val (A 0 B) indicates that any λ-abstraction is a value. Now we have, for example (parametrically in A and B): A::Tиtp, B::Tиtp ▶ lam λx. lam λy. x ⇐ val (A 0
(B 0 A)).
Now we can express that evaluation must always returns a value. Since the declarations below are intended to represent a logic program, we follow the logic programming convention of reversing the arrows in the declaration of ev-app.
eval :: cmp A → val A → type.
ev-lam :: eval (lam λx. E x) (lam λx. E x).
ev-app :: ΠE' ::(val A → cmp A).
eval (app E1 E2) V
← eval E1 (lam λx. E' x)
← eval E2 V2

5 The present paper concentrates primarily on decidability, though, not efficiency.

← eval (E'
V2) V.

Sort checking the above declarations demonstrates that evaluation always returns a value. Moreover, due to the explicit sort given for E' , the declarations also ensure that the language is indeed call-by-value: it would be a sort error to ever substitute a computation for a lam-bound variable, for example, by evaluating (E' E2) instead
of (E' V2) in the ev-app rule. An interesting question for future work is whether
type reconstruction can recover this restriction automatically—if the front end were to assign E' the “more precise” sort cmp A → cmp A, then the check would be lost.

A Final Example: The Calculus of Constructions
As a final example, we present the Calculus of Constructions. Usually, there is a great deal of redundancy in its presentation because of repeated constructs at the level of objects, families, and kinds. Using sorts, we can enforce the stratification and write typing rules that are as simple as if we assumed the infamous type : type.
term : type.	% terms at all levels
hyp и term.	% hyperkinds (the classifier of “kind”)
knd и term.	% kinds fam и term.	% families obj и term.	% objects
tp :: hyp Λ knd.
pi :: fam → (obj → fam) → fam Λ	% dependent function types, Πx:A. B
fam → (obj → knd) → knd Λ	% type family kinds, Πx:A. K
knd → (fam → fam) → fam Λ	% polymorphic function types, ∀α:K. A
knd → (fam → knd) → knd.	% type operator kinds, Πα:K1. K2
lm :: fam → (obj → obj) → obj Λ	% functions, λx:A. M
fam → (obj → fam) → fam Λ	% type families, λx:A. B
knd → (fam → obj) → obj Λ	% polymorphic abstractions, Λα:K. M
knd → (fam → fam) → fam.	% type operators, λα:K. A
ap :: obj → obj → obj Λ	% ordinary application, M N 
fam → obj → fam Λ	% type family application, A M obj → fam → obj Λ	% polymorphic instantiation, M [A] fam → fam → fam.	% type operator instantiation, A B 
The typing rules can now be given non-redundantly, illustrating the implicit over- loading afforded by the use of intersections. We omit the type conversion rule and auxiliary judgements for brevity.
of :: knd → hyp → type Λ fam → knd → type Λ obj → fam → type.
of-tp :: of tp tp.


of-pi :: of (pi T1 λx. T2 x) tp
← of T1 tp
← (Πx::term. of x T1 → of (T2 x) tp). of-lm :: of (lm U1 λx. T2 x) (pi U1 λx. U2 x)
← of U1 tp
← (Πx::term. of x U1 → of (T2 x) (U2 x)).
of-ap :: of (ap T1 T2) (U1 T2)
← of T1 (pi U2 λx. U1 x)
← of T2 U2.
Intersection types also provide a degree of modularity: by deleting some conjuncts from the declarations of pi, lm, and ap above, we can obtain an encoding of any point on the λ-cube.

Metatheory
In this section, we present some metatheoretic results about our framework. These follow a similar pattern as previous work using hereditary substitutions [17,11,7]. To conserve space, we omit proofs that are similar to those from prior work, and only sketch novel results. We refer the interested reader to the companion technical report [10], which contains complete proofs of all thoerems.
Hereditary Substitution
Hereditary substitution is defined judgementally by inference rules. The only place β-redexes might be introduced is when substituting a normal term N into an atomic term R: N might be a λ-abstraction, and the variable being substituted for may occur at the head of R. Therefore, the judgements defining substitution into atomic terms are the only ones of interest.
First, we note that the type index on hereditary substitution need only be a simple type to ensure termination. To that end, we denote simple types by α and define an erasure to simple types (A)−.
α ::= a | α1 → α2	(a N1 ... Nk)− = a	(Πx:A. B)− = (A)− → (B)−
We write [N/x]n M = M ' as short-hand for [N/x]n − M = M '.
A	(A)
We denote substitution into atomic terms by two judgements: [N0/x0]rr R = R',
for when the head of R is not x, and [N0/x0]rn R = (N ', α'), for when the head of R
is x. The former is just defined compositionally; the latter is defined by two rules:
[N0/x0]rn R1 = (λx. N1, α2 → α1)
[N0/x0]n N2 = N '	[N ' /x]n N1 = N '

[N0/x0]rn x0 = (N0, α0)
(rn-var)
	α0	2	2	α2	1 (rn-β)
[N0/x0]rn R1 N2 = (N ' , α1)

α0	α0	1
The rule rn-var just returns the substitutend N0 and its putative type index α0.

The rule rn-β applies when the result of substituting into the head of an application is a λ-abstraction; it avoids creating a redex by hereditarily substituting into the body of the abstraction.
A simple lemma establishes that these two judgements are mutually exclusive.
Lemma 3.1
If [N/x]rr R = R', then the head of R is not x.
If [N/x]rn R = (N ', α'), then the head of R is x.
Proof. By induction over the given derivation.	 
Substitution into normal terms has two rules for atomic terms R, one which calls the “rr” judgement and one which calls the “rn” judgement.
[N0/x0]rr R = R'
	α0	 (subst-n-atom)
[N0/x0]n R = R'
 [N0/x0]rn R = (R', a')
(subst-n-atomhead)
[N0/x0]n R = R'
Note that the latter rule requires both the term and the type returned by the “rn” judgement to be atomic.
Every other syntactic category’s substitution judgement is defined composition- ally.
Decidability
A hallmark of the canonical forms/hereditary substitution approach is that it allows a decidability proof to be carried out comparitively early, before proving anything about the behavior of substitution, and without dealing with any complications introduced by β/η-conversions inside types. Ordinarily in a dependently typed calculus, one must first prove a substitution theorem before proving typechecking decidable. (See [8] for a typical non-canonical account of LF definitional equality.) If only canonical forms are permitted, then type equality is just α-convertibility,
so one only needs to show decidability of substitution in order to show decidability of typechecking. Since LF encodings represent judgements as type families and proof-checking as typechecking, it is comforting to have a decidability proof that relies on so few assumptions.
Lemma 3.2 If [N0/x0]rn R = (N ', α'), then α' is a subterm of α0.
Proof. By induction on the derivation of [N0/x0]rn R = (N ', α'). In rule rn-var, α' is the same as α0. In rule rn-β, our inductive hypothesis tells us that α2 → α1 is a subterm of α0, so α1 is as well.	 
Theorem 3.3 (Decidability of Substitution) Hereditary substitution is decid- able. In particular:

Given N0, x0, α0, and R, either ∃R'. [N0/x0]rr R = R', or / ∃R'. [N0/x0]rr R =
R',
Given N0, x0, α0, and R, either ∃(N ', α'). [N0/x0]rn R = (N ', α'), or

/ ∃(N ', α'). [N0/x0]rn R = (N ', α'),
Given N0,	x0,	α0,	and N,	either ∃N '. [N0/x0]n

N	=	N ',	or   /

∃N '. [N0/x0]n N = N ',
and similarly for other syntactic categories
Proof. By lexicographic induction on the type subscript α0, the main subject of the substitution judgement, and the clause number. For each rule defining hereditary substitution, the premises are at a smaller type subscript, or if the same type subscript, then a smaller term, or if the same term, then an earlier clause. The case for rule rn-β relies on Lemma 3.2 to know that α2 is a strict subterm of α0. 
Theorem 3.4 (Decidability of Subsorting) Given Q1 and Q2, it is decidable whether or not Q1 ≤ Q2.
Proof. Since the subsorting relation Q1 ≤ Q2 is just the reflexive, transitive closure of the declared subsorting relation s1 ≤ s2, it suffices to compute this closure and check whether the heads of Q1 and Q2 are related by it.	 
We prove decidability of typing by exhibiting a deterministic algorithmic system that is equivalent to the original. Instead of synthesizing a single sort for an atomic term, the algorithmic system synthesizes an intersection-free list of sorts, Δ.
Δ ::= · | Δ,Q | Δ, Πx::SиA. T

One can think of Δ as the intersection of all its elements. Instead of applying intersection eliminations, the algorithmic system eagerly breaks down intersections using a “split” operator, leading to a deterministic “minimal-synthesis” system.
split(Q)= Q	split(S1 Λ S2) = split(S1), split(S2) split(Πx::SиA. T )= Πx::SиA. T		split(T)= ·


c::S ∈ Σ	c:A ∈ Σ Γ ▶ c $ split(S)
x::SиA ∈ Γ


Γ ▶ x $ split(S)
Γ ▶ R $ Δ	Γ ▶ Δ@ N = Δ' Γ ▶ R N $ Δ'

The rule for applications uses an auxiliary judgement Γ ▶ Δ @ N = Δ' which computes the possible types of R N given that R synthesizes to all the sorts in Δ. It has two key rules:
Γ ▶ Δ@ N = Δ'	Γ ▶ N @ S	[N/x]s T = T '



Γ ▶ · @ N = ·


Γ ▶ (Δ, Πx::SиA. T )@ N = Δ', split(T ')

The other rules force the judgement to be defined when neither of the above two rules apply. Finally, to tie everything together, we define a new checking judgement

Γ ▶ N @ S that makes use of the algorithmic synthesis judgement; it looks just like Γ ▶ N ⇐ S except for the rule for atomic terms.
Γ ▶ R $ Δ	Q' ∈ Δ	Q' ≤ Q
Γ ▶ R @ Q
This new algorithmic system is manifestly decidable.
Theorem 3.5 Algorithmic type checking is decidable. In particular:
Given Γ and R, there is a unique Δ such that Γ ▶ R $ Δ.
Given Γ, N, and S, it is decidable whether or not Γ ▶ N @ S.
Given Γ, Δ, and N, there is a unique Δ' such that Γ ▶ Δ@ N = Δ'.
Proof. By induction on the term, R or N , the clause number, and the sort S or the list of sorts Δ. For each rule, the premises are either known to be decidable, or at a smaller term, or if the same term, then an earlier clause, or if the same clause, then either a smaller S or a smaller Δ.	 
Note that the algorithmic synthesis system always outputs some Δ; if the given term has no sort, then the output will be ·.
It is straightforward to show that the algorithm is sound and complete with respect to the original bidirectional system.
Theorem 3.6 (Soundness of Algorithmic Typing)
If Γ ▶ R $ Δ, then for all S ∈ Δ, Γ ▶ R ⇒ S.
If Γ ▶ N @ S, then Γ ▶ N ⇐ S.
If Γ ▶ Δ @ N = Δ', and for all S ∈ Δ, Γ ▶ R ⇒ S, then for all S' ∈ Δ', Γ ▶ R N ⇒ S'.
Proof. By straightforward induction on the given derivation.	 
Lemma 3.7 If Γ ▶ Δ @ N = Δ' and Γ ▶ R $ Δ and Πx::SиA. T ∈ Δ and
Γ ▶ N @ S and [N/x]s T = T ', then split(T ') ⊆ Δ'.
Proof. By straightforward induction on the derivation of Γ ▶ Δ@ N = Δ'. 
Theorem 3.8 (Completeness for Algorithmic Typing)
If Γ ▶ R ⇒ S, then Γ ▶ R $ Δ and split(S) ⊆ Δ.
If Γ ▶ N ⇐ S, then Γ ▶ N @ S.
Proof. By straightforward induction on the given derivation. In the application case, we make use of the fact that Γ ▶ Δ @ N = Δ' is always defined and apply Lemma 3.7.	 
Decidability theorems and proofs for other syntactic categories’ formation judge- ments are similar, so we omit them.

Identity and Substitution Principles
Since well-typed terms in our framework must be canonical, that is β-normal and η-long, it is non-trivial to prove S → S for non-atomic S, or to compose proofs of S1 → S2 and S2 → S3. The Identity and Substitution principles ensure that our type theory makes logical sense by demonstrating the reflexivity and transitivity of entailment. Reflexivity is witnessed by η-expansion, while transitivity is witnessed by hereditary substitution.
The Identity Principle effectively says that synthesizing (atomic) objects can be made to serve as checking (normal) objects. The Substitution Principle dually says that checking objects may stand in for synthesizing assumptions, that is, variables.
Theorem 3.9 (Substitution) If ΓL ▶ N0 ⇐ S0 , and ▶ ΓL, x0::S0иA0, ΓR ctx , and ΓL, x0::S0иA0, ΓR ▶ S  и A , and ΓL, x0::S0иA0, ΓR ▶ N  ⇐ S , then
[N0/x0]γ ΓR = Γ' and ▶ ΓL, Γ' ctx , and [N0/x0]s S = S' and [N0/x0]a A = A'

and ΓL, Γ'
▶ S' и A' , and [N0/x0]n
N = N ' and ΓL, Γ'
▶ N ' ⇐ S' , and similarly

for other syntactic categories.
Proof. The staging of the substitution theorem is somewhat intricate. First, we strengthen its statement to one that does not presuppose the well-formedness of the context or the classifying types, but instead presupposes that substitution is defined on them. This strengthened statement may be proven by induction on (A0)− and the derivations being substituted into. In the application case, we require a lemma about how hereditary substitutions compose, analogous to the fact that for ordinary substitution, [N0/x0] [N2/x2] N = [[N0/x0] N2/x2] [N0/x0] N .	 
A more in-depth discussion of the proof of substitution for core canonical LF can be found in [7]. The story for LFR is quite similar, and is detailed in the companion technical report [10].
Theorem 3.10 (Expansion) If Γ ▶ S и A and Γ ▶ R ⇒ S, then Γ ▶ ηA(R) ⇐ S.
Proof. By induction on S. The Πx:A2. A1 case relies on the auxiliary fact that
[ηA2 (x)/x]s S1 = S1.	 
Corollary 3.11 (Identity) If Γ ▶ S и A, then Γ, x::SиA ▶ ηA(x) ⇐ S.

Subsorting at Higher Sorts
Our bidirectional typing discipline limits subsorting checks to a single rule, the switch rule when we switch modes from checking to synthesis. Since we insist on only typing canonical forms, this rule is limited to atomic sorts Q, and consequently, subsorting need only be defined on atomic sorts.
As it turns out, though, the usual variance principles and structural rules for subsorting at higher sorts are admissible with respect to an intrinsic notion of higher- sort subsorting. The simplest way of formulating this intrinsic notion is as a variant of the identity principle: S is a subtype of T if Γ, x::SиA ▶ ηA(x) ⇐ T . This notion







S ≤ S
(refl)
S1 ≤ S2	S2 ≤ S3 S1 ≤ S3
(trans)
S2 ≤ S1	T1 ≤ T2
Πx::S1. T1 ≤ Πx::S2. T2
(S-Π)

(T-R)  T ≤ S1	T ≤ S2 (Λ-R)	S1 ≤ T
(Λ-L1)	S2 ≤ T

(Λ-L2)

S ≤ T 
T ≤ S1 Λ S2
S1 Λ S2 ≤ T
S1 Λ S2 ≤ T

(T/Π-dist)	(Λ/Π-dist)
T ≤ Πx::S. T	(Πx::S. T1) Λ (Πx::S. T2) ≤ Πx::S. (T1 Λ T2)


Fig. 1. Derived structural rules for subsorting.
is equivalent to a number of other alternate formulations, including a subsumption- based formulation and a substitution-based formulation.
Theorem 4.1 (Alternate Formulations of Subsorting) The	following	are equivalent:
If Γ ▶ R ⇒ S1, then Γ ▶ ηA(R) ⇐ S2.
Γ, x::S1иA ▶ ηA(x) ⇐ S2.
If Γ ▶ N ⇐ S1, then Γ ▶ N ⇐ S2.
If ΓL, x::S2иA, ΓR ▶ N ⇐ S and ΓL ▶ N1 ⇐ S1,
then ΓL, [N1/x]γ ΓR ▶ [N1/x]n N ⇐ [N1/x]s S.
A	A	A
Proof. Using Identity and Substitution, and the fact that [N/x]n ηA(x)= N .
i =⇒ ii: By rule, Γ, x::S1иA ▶ x ⇒ S1. By i, Γ, x::S1иA ▶ ηA(x) ⇐ S2.
ii =⇒ iii: Suppose Γ ▶ N ⇐ S1. By ii, Γ, x::S1иA ▶ ηA(x) ⇐ S2. By Theorem 3.9 (Substitution), Γ ▶ [N/x]n ηA(x) ⇐ S2. Thus, Γ ▶ N ⇐ S2.
iii =⇒ iv: Suppose ΓL, x::S2иA, ΓR ▶ N ⇐ S and ΓL ▶ N1 ⇐ S1. By iii, ΓL ▶ N1 ⇐ S2. By Theorem 3.9 (Substitution), ΓL, [N1/x]γ ΓR ▶ [N1/x]n N ⇐
A	A
[N1/x]s S.
iv =⇒ i: Suppose Γ ▶ R ⇒ S1. By Theorem 3.10 (Expansion), Γ ▶ ηA(R) ⇐ S1. By Corollary 3.11 (Identity), Γ, x::S2иA ▶ ηA(x) ⇐ S2. By iv, Γ ▶ [ηA(R)/x]n ηA(x) ⇐ S2. Thus, Γ ▶ ηA(R) ⇐ S2.	 
All of the rules in Fig. 1 are sound with respect to this intrinsic notion of subsorting.
Theorem 4.2 If S ≤ T , then Γ, x::SиA ▶ ηA(x) ⇐ T .
Proof. By induction, making use of the alternate formulations given by Theo- rem 4.1.	 
The soundness of the rules in Fig. 1 demonstrates that any subsumption rela- tionship you might want to capture with them is already captured by our checking and synthesis rules. More interesting is the fact that the usual rules are complete

with respect to our intrinsic notion. Space limitations preclude more than a brief overview here; the companion technical report contains a detailed account.
We demonstrate completeness by appeal to an algorithmic subtyping system very similar to the algorithmic typing system from Section 3.2. This system is characterized by two judgements: Δ ≤ S and Δ @ (N :: Δ1) = Δ2. With the appropriate definition, we can prove the following by induction on the type A and the derivation E.
Theorem 4.3 Suppose Γ ▶ R ⇒ A. Then:
If Γ ▶ R $ Δ and E :: Γ ▶ ηA(R) @ S, then Δ ≤ S.
If Γ ▶ R $ Δ and E :: Γ ▶ Δ0 @ ηA(R)= Δ', then Δ0 @ (ηA(R) :: Δ) = Δ'. From this and Theorem 3.8 we obtain a completeness theorem:
Theorem 4.4 If Γ, x::SиA ▶ ηA(x) ⇐ T , then split(S) ≤ T .
Finally, we can complete the triangle by showing that the algorithmic formula- tion of subtyping implies the original declarative formulation:
Theorem 4.5 If split(S) ≤ T , then S ≤ T .

Related Work
The most closely related work is [12], which also sought to extend LF with refine- ment types. We improve upon that work by intrinsically supporting a notion of canonical form. Also closely related in Aspinall and Compagnoni’s work on subtyp- ing and dependent types [2,1]. The primary shortcoming of their work is its lack of intersection types, which are essential for even the simplest of our examples.

Summary
In summary, we have exhibited a variant of the logical framework LF with a notion of subtyping based on refinement types. We have demonstrated the expressive power of this extension through a number of realistic examples, and we have shown sev- eral metatheoretic properties critical to its utility as a logical framework, including decidability of typechecking.
Our development was drastically simplified by the decision to admit only canon- ical forms. One effect of this choice was that subsorting was only required to be judgementally defined at base sorts; higher-sort subsorting was derived through an η-expansion-based definition which we showed sound and complete with respect to the usual structural subsorting rules.
There are a number of avenues of future exploration. For one, it is unclear how subsorting and intersection sorts will interact with the typical features of a metalogical framework, including type reconstruction, unification, and proof search, to name a few; these questions will have to be answered before refinement types can be integrated into a practical implementation. It is also worthwhile to consider

adapting the refinement system to more expressive frameworks, like the Linear Logical Framework on the Concurrent Logical Framework.

References
David Aspinall. Subtyping with power types. In Peter Clote and Helmut Schwichtenberg, editors, CSL, volume 1862 of Lecture Notes in Computer Science, pages 156–171. Springer, 2000.
David Aspinall and Adriana B. Compagnoni. Subtyping dependent types. Theoretical Computer Science, 266(1-2):273–309, 2001.
Karl Crary. Toward a foundational typed assembly language. In G. Morrisett, editor, Proceedings of the 30th Annual Symposium on Principles of Programming Languages (POPL ’03), pages 198–212, New Orleans, Louisiana, January 2003. ACM Press.
Rowan Davies. Practical Refinement-Type Checking. PhD thesis, Carnegie Mellon University, May 2005. Available as Technical Report CMU-CS-05-110.
Tim Freeman. Refinement Types for ML. PhD thesis, Carnegie Mellon University, March 1994. Available as Technical Report CMU-CS-94-110.
Robert Harper, Furio Honsell, and Gordon Plotkin. A framework for defining logics. Journal of the Association for Computing Machinery, 40(1):143–184, January 1993.
Robert Harper and Daniel R. Licata. Mechanizing metatheory in a logical framework. Journal of Functional Programming, 2007. To appear. Available from http://www.cs.cmu.edu/~ drl/.
Robert Harper and Frank Pfenning. On equivalence and canonical forms in the LF type theory.
Transactions on Computational Logic, 6:61–101, January 2005.
Daniel K. Lee, Karl Crary, and Robert Harper. Towards a mechanized metatheory of Standard ML. In Matthias Felleisen, editor, Proceedings of the 34th Annual Symposium on Principles of Programming Languages (POPL ’07), pages 173–184, Nice, France, January 2007. ACM Press.
William Lovas and Frank Pfenning. A bidirectional refinement type system for LF. Technical Report CMU-CS-07-127, Department of Computer Science, Carnegie Mellon University, 2007.
Aleksandar Nanevski, Frank Pfenning, and Brigitte Pientka.	Contextual modal type theory.
Transactions on Computational Logic, 2007. To appear.
Frank Pfenning. Refinement types for logical frameworks. In Herman Geuvers, editor, Informal Proceedings of the Workshop on Types for Proofs and Programs, pages 285–299, Nijmegen, The Netherlands, May 1993.
Frank Pfenning. Logical frameworks. In Alan Robinson and Andrei Voronkov, editors, Handbook of Automated Reasoning, chapter 17, pages 1063–1147. Elsevier Science and MIT Press, 2001.
Frank Pfenning and Carsten Schu¨rmann. System description: Twelf — a meta-logical framework for deductive systems. In H. Ganzinger, editor, Proceedings of the 16th International Conference on Automated Deduction (CADE-16), pages 202–206, Trento, Italy, July 1999. Springer-Verlag LNAI 1632.
John C. Reynolds. Even normal forms can be hard to type. Unpublished, marked Carnegie Mellon University, December 1, 1989.
John C. Reynolds. Design of the programming language Forsythe. Report CMU–CS–96–146, Carnegie Mellon University, Pittsburgh, Pennsylvania, June 28, 1996.
Kevin Watkins, Iliano Cervesato, Frank Pfenning, and David Walker. A concurrent logical framework I: Judgments and properties. Technical Report CMU-CS-02-101, Department of Computer Science, Carnegie Mellon University, 2002. Revised May 2003.
