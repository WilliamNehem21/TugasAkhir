Electronic Notes in Theoretical Computer Science 101 (2004) 95–127 
www.elsevier.com/locate/entcs


Unifying Views of UML1
Zhiming Liu, He Jifeng and Jing Liu
International Institute for Software Technology The United Nations University, Macao SAR China
Xiaoshan Li
Faculty of Software Engineering, University of Macao, Macao SAR China

Abstract
We present an approach to embedding a formal method into Rational Unified Process (RUP). The purposes are: (a) to unify different views of UML, (b) to enhance UML with the formal method to improve the quality of software systems; and (c) to support effective use of the formal method for system specification and reasoning with the iterative and incremental approach by providing a unified conceptual framework. One of the main features of RUP is that it is use-case driven and supports iterative development more explicit than other process models, such as the waterfall model. Object-orientation also supports better and more explicitly incremental programming than the traditional imperative programming. These together will help to scale up the use of the formal method in software system development. The model is based on Hoare and He’s Unifying Theories of Programming (UTP).
Keywords: Object-Orientation, RUP, UML, UTP


Introduction
Nowadays, a software system, such as one used for health care, social security, or defence, is a model (of part) of the real world represented in a program-

1 Email: lzm@iist.unu.edu,hjf@iist.unu.edu,xsl@umac.mo.
Z. Liu is on leave from Department of Computer Science of the University of Leicester, England;
J. He is on leave from East China Normal University, Shanghai, China.
J. Liu is on leave from Shanghai University, China.
This work is partly supported by the research grant 02104 MoE and the 973 project 2002CB312000 of MoST of P.R.China.


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.02.018


ming language. As the real world keeps changing, the software system that represents it needs to be continuously maintained and evolved. To develop and maintain such an evolving software system is obviously difficult. A well disciplined process and a good modelling notation are essential to control the activities in constructing and documenting the different models obtained at different stages of the software development. The Rational Unified Process (RUP) [32] has emerged as a popular software development process [33,38,31]. As the modelling notation, RUP uses UML [9], which is the de-facto stan- dard modelling language for the development of software in a broad range of application.
RUP promotes several best practices, but one standing above the others is the idea of use-case driven and iterative development. In the use-case driven and iterative approach of RUP, a system development is organized as a series of short, fixed-length mini-projects called iterations, each for a small number of use cases. Each iteration includes its own requirements analysis, design, implementation, and testing/verification activities, described in the following subsection.
Although RUP and UML are practically popular, they are not well-founded with a formal method making it hard to analyze consistency of UML speci- fications. This work is towards an integration of a formal method with RUP and UML.
Section 2 briefly discusses the activities and UML models in RUP. We provide a summary of the main ideas of our approach in Section 3. Section 4 introduces an object-oriented notation that will be used in the proposed formal method. Section 5 shows the use of the specification notation in the specifi- cation of UML models. Instead of going into details of the formalization of UML, we will use a library system as an example to illustrate the treatment of models created in different cycles of the RUP. Finally, Section 6 concludes the paper with a discussion. The discussion on the relationship to existing work is given in Section 7.

RUP and UML
As said earlier, each RUP iteration includes its own requirements analysis, design, implementation, testing and verification activities.

Requirement analysis
The requirements analysis of an iteration is to create a UML model for the requirements that contains an use-case model and a conceptual class model.






















Fig. 1. Iterative software development Process

The use-case model consists of an use-case diagram and a textual descrip- tion of each use case. The use-case diagram provides only static information about the use cases. The functional and behavioral properties described in a textual descriptions of the use cases are partially represented as sequences of interactions between actors of the use case and the system. A UML system sequence diagram is used to describe the possible order of the interactions be- tween the actors of a use case and the system treated as a black box, but it does not describe the change of the system state caused by such an interaction. It is important to note that a system sequence diagram does not and should not provide information about interactions among objects inside the system [14,38,40], as the these internal interactions are the concern of the design. A formalization of an use-case model should deal with both the order of the interactions (i.e. the interactive view) and the state changes caused by these interactions i.e. the functional and behavioral view. The Object Constraint Language (OCL) [53], as a part of UML, can describe some functional aspects, such as pre- and post-conditions of operations. However, OCL does not have


a formal semantics and it is not expressive enough to describe many useful aspects of object-orientation, such as recursive method call, dynamic binding. In this paper, we will define an object-oriented specification language (OOL) that can be used to specify functional behaviour at different levels of abstract. The conceptual model is a class diagram consisting of classes (also called concepts), and associations between classes. A class represents a set of concep- tual objects and an association determines how the objects in the associated classes are related in the application domain. The reason why we call the class diagram conceptual at this level is that it is not concerned with what an object does, how it behaves, or how an attribute is represented. The decisions on these issues will be made during the design phase when the responsibilities
of a use case are decomposed and assigned to appropriate objects.
The UML community say that the class model represents the static view, whereas the use-case model represents the dynamic and interactive view of the requirements.

Design
The design is to transform the model of the requirements to a model of design that consists of a design class diagram and a family of interaction diagrams. The interaction diagrams, representing the interactive view of the design, show how objects of the system interact and collaborate with each other. The cre- ation of the interaction diagrams mainly involves assignment of responsibilities to objects so that their interactions correctly realize the use cases. Use case decomposition and responsibility assignment are carried out according to the knowledge that the objects maintain. What an object can do depends on what it knows, though an object does not have to do all what it can do. What an object knows is determined by its attributes and associations with other objects.
After the responsibilities of the objects are decided, the directions of the associations (i.e. navigation and visibility from one object to another) and the methods of the classes can be determined. This will lead to the construction of the design class diagram, which shows the static view of the design, i.e. how the concepts and associations of the conceptual class diagram are realized by software classes.

Implementation
The implementation is to code the design in a programming language. In an object-oriented programming language, this is to define the software classes from the classes in the design class diagram and their methods based on the


interaction diagrams. Once the interaction diagrams and the design class diagram are obtained, code can be easily produced from it. It is possible to develop a tool to help in transforming a design into a code of implementation.

Iterative and incremental model construction
The iterative lifecycle in RUP is based on the successive enlargement and refinement of a system through multiple iterations, with cyclic feedback and adaption as core drivers to converge upon a suitable system. The system grows incrementally over time, iteration by iteration, and thus this approach is also known as iterative and incremental(see Figure 1). Early iterative process ideas were known as spiral development and evolutionary development [7]. However, what is new in RUP is its nature of being use-case driven and its explicit support to object-orientation and incremental development.
Each cycle may consider one or a number of use cases to analyze, and build a conceptual model for them. Then these use cases can be designed to create the interaction diagrams and the design class diagram. The design is then verified, coded and tested. This one cycle can also be done again in an iterative way by taking the use cases or “parts” of a use case in turns. In the next cycle, we may take a refined or extended version of a use case from the previous cycle and refine or extend the system, or we take some new uses case to analyze, design and implement. Therefore, the models created in the new iteration are refinement and enlargement of those obtained in the previous iteration. This is shown in Figure 1.
In each iteration, the relationship between a use-case model and a con- ceptual model is that the conceptual model specifies the environment, i.e. the state space, under which the use cases are to be carried out. A state is an object diagram that consists of a set of objects and a set of links among these objects. A conceptual model is consistent with a use-case model if it is adequate to re- alize the functional services required by the use-case model. This consistency needs to be checked in each cycle. The design specification is required to be verified against the requirement specification of the same iteration. And the consistency and correctness need to be preserved in the following cycles. The main aim of the integration of the formal method into RUP is to allow these checks to be carried out precisely.

Summary of the Approach
In this paper, we will focus on the incremental and iterative feature of RUP and address the following problems:


How to formalize a UML model of the requirements in an iteration and ensure the consistency between static and dynamic views of the model?
How to formalize a UML model of the design of an iteration and ensure the consistency between its static and dynamic/interaction views?
How to formally relate the UML models of the design and the require- ments of an iteration?
How to preserve the established consistency and correctness in sequent iterations?
We approach these problems by first developing a formal framework for object- oriented programming. The framework includes an object-oriented specifica- tion language (OOL) and a calculus for refinement of object-oriented designs (COOL). The calculus is relational and predicative and it is based on Hoare and He’s Unifying Theories of Programming (UTP) [29]. We will then study how UML models of requirements and designs can be formally represented and reasoned about in the design calculus.
When formalizing a UML model RM = (cm, um) of requirements, we de- scribe the static view cm as a declaration section cdeclscm and the use-case model um by a program command specification cum. Therefore, RM is defined as an object-oriented program specification cdeclscm • cum. The semantics of cdeclscm, cum and their composition • are given in the semantics of OOL. This formalization captures both the syntax and semantics of cm and um and the consistency between them. The command cum specifies what operations on the system states are to be carried out and in what possible order. A system state is in fact an object diagram of the class diagram cm. As one cannot decide the order in which the use cases are to be performed, OOL will allow the specification of non-determinism. Therefore, OOL will not only formalize some UML models, but also complement UML to provide functional descrip- tions of use cases. Properties of the specification, such as class invariants and constraints on associations between classes can be reasoned in the logic. Con- sistency changes in the class and use case models can be ensured by preserving these properties and even by refinement.
Similarly, for a UML model of design DM = (dc, sd) consisting of a design class diagram dc and a family sd of sequence diagrams, we formalize the design class diagram dc with a declaration section cdeclsdc in OOL. Classes in this declaration section now have methods and a method of a class may call meth- ods of other classes. Therefore, the specification of these methods describes the object interactions in the sequence diagrams. However, methods are still to be activated by commands in the main program csd. Therefore, a UML model of design (dc, sd) is also specified as the composition of a declaration


section and a main program (which again does not have a UML counterpart): cdeclsdc • csd. The consistency between the class diagram dc and the object sequence diagrams sd are captured by the semantics of cdeclsdc and the se- mantics of method calls in the OOL. In fact, the specification of the methods in the design class diagram combine both of functional view which has not UML counterpart, behavioural view which is described by object UML state diagrams and interactive view which is captured by UML object interaction diagrams. The correctness of the design model (dc, sd) w.r.t the requirements model (cm, um) is defined by the reﬁnement relation
cdeclscm • cum ± cdeclsdc • csd
Refinement can also be used to justify steps of incremental design (e.g. those informally used in [33,38]), such as adding attributes, promoting attributes from a subclass to it superclass, encapsulating attributes, delegating function- ality of an object to its associated objects, etc. Such an integration of the refinement calculus with RUP makes the use of the design calculus more ef- fective in an iterative and incremental manner so that only a small model will be treated at each stage of an iteration.

The Formal Object-Oriented Specification Language
We develop an object-oriented language with classes, references, visibility, dynamic binding, nested declaration, and mutual recursive method calls. Class declarations as well as commands will be defined as designs, the notion that is defined in [29].
Syntax
A program is of the form cdecls • P , where cdecls is the declaration section, and P is a command, that can be understood as the main method of a Java program.
The main method command corresponds to an active class. In this paper, we only deal with sequential programs thus we do not deal with active class in general. Therefore, in this case, the statechart of an object will start from a state when a method is invoked and then state changes will follow according to the method definition. In a multi-thread computation, we would have more than one “main method” or “run” method, so more than one active classes.
Class declarations
We assume a set CName of class names. A declaration section cdecls is of the form cdecls ::= cdecl | cdecls; cdecl, where cdecl is a class declaration of

the following form
Class N extends M {
private U u = a, protected V v = b, public W w = d;
method m1(T 11 x1, T 12 y1 , T 13 z1){c1 }; ··· ; mÆ(T Æ1 xÆ, T Æ2 yÆ, T Æ3 zÆ){cÆ}
}
where
N and M are names of classes in CName, and M is called the direct superclass of N , and the extends part is optional.
The private declaration declares the private attributes u of the class, their types U and initial values a, and similarly, the protected and public dec- larations for the protected and public attributes with the meaning in Java. We define
def
pri(N ) = {U a = u | U a = u ∈ U u = a}
and similarly pro(N ) and pub(N ). We use attr(N ) to denote the union of these three sets of attributes; and for an attribute u of N , we use dcltype(N.u) to denote the type of a and Init(N.u) the initial value of u declared in N .
The method declaration declares the methods, their value parameters T i1 xi, result parameters T i2 yi, value-result parameters T i3 zi and bod- ies ci, denoted by val(N.mi), res(N.mi), valres(N.mi), and body(N.mi),
respectively. We will also simply use m(paras){c} to denote a method dec- laration.
We will use the Java convention to write a class specification, and assume an attribute protected when it is not tagged with private or public.


Commands
Our language supports typical object-oriented programming constructs:
c ::= skip | chaos | c; c	termination, abort, sequence
| var T x=e | end x local variable declaration and undeclaration
| c ¢ b ¢ c | c H c	conditional and nondeterministic choice
| b ∗ c | read(T x)	iteration and read in a value
| C.new(x)	object creation
| le := e | le.m(e, v, u) assignment and method call
where b is a Boolean expression, e an expression, and le an expression which may appear on the left hand side of an assignment and is of the form le := x|le.a|self where x a simple variable and a is an attribute of an object.

Expressions
Expressions, which can appear on the right hand sides of assignments, are constructed according to the rules below.
e ::= x|null|self |e.a|f (e)
where null represents the special object of the special class Null. Notice that expressions can appear as arguments of method calls, but we do not allow method call to be an expression as we explicitly use result and val-result parameters in methods. We can include more expression such as type casting (C)e and type test (e is C), but they are not needed in this paper.

Semantics
In UTP [29], a program or a program command is identified as a design, which is represented by a pair (α, P ), where
α denotes the set of variables of the program.
P is a predicate of the form

p(x) ▶
' def
∧ p(x)) ⇒ (ok' ∧ R(x, x'))

R(x, x ) = (ok
where x and x' stand for the initial and final values of program variables x ⊆ α, the predicate p, called the precondition of the program, characterizes the initial states in which the activation of the program will lead its execution to termination, and the predicate R, called the post-condition of the program, relates the initial states of the program to its final states. We describe the termination behaviour of a program by the Boolean variables ok and ok', where the former is true if the program is properly activated and the later becomes true if the execution of the program terminates successfully.
A program command usually modifies a subset of the program variables α. Let V be a subset of α , the notation V : (p ▶ R) denotes the (framed) design
p ▶ (R ∧ w' = w)
where w contains all the variables in α but those in V . V is called the frame of the design p ▶ R. In the examples, we often omit the frame of a design by assuming that a design only changes the value of a variable x if its primed version x' occurs in the design.

A design D2
def
= (α, P2) is called a reﬁnement of D1
def
= (α, P1), denoted

D1 ± D2, if P2 entails P1, i.e.
∀x, x',..., z,z' · (P2 ⇒ P1 )
where we assume that α contains x,... , z.

Let ρ be a mapping from α2 to α1 that can be defined as a design too, then
def
a design D2 = (α2, P2) is a reﬁnement under the mapping of D1 = (α1, P1)
under mapping ρ if
∀x ∈ α , ∀y' ∈ α' · ((ρ; P ) ⇐ (P ; ρ))
2	1	1	2

where α'
is the set of primed versions of those variables in α1; and the seman-

tics of sequential composition is formally defined later.
We will follow this classical way of defining a state-based model for a programming language and define our OOL in terms of variables, states, ex- pressions, commands, declarations and programs. However, for simplicity, the above model adopts a universal data type and allows neither reference types nor nested declarations. To formalize the behaviour of an object-oriented program, we have to take into account the following features:
A program operates not only on variables of primitive types, such as inte- gers, but also objects of reference types.
To protect attributes from illegal accesses, the model has to address the problem of visibility of attributes to the environment.
An object can be associated with any subclass of its originally declared one. To validate expressions and commands in a dynamic binding environment, the model must keep track of the current type of each object.
Values and objects
A value is either a member of a primitive type or an object identity. We assume an infinite set REF of object identities that can be referred to, and null ∈ REF . An object o is an entity defined by the following structure
o ::= null| < ref, type, state >
where ref ∈ REF , and type is a class name, and state is a mapping from attr(type) to objects. For an object o =< ref, C,σ >, we use identity(o) to denote the identity ref of o, type(o) to denote the type name C of the object o, state(o)(a) to denote the value σ(a) of an attribute a of class C. When there is no confusion, we also use C to denote the set of objects o such that type(o)= C, and in this case C also denotes the semantic class/type and we can say o ∈ C.
Let O be the set of all objects, including null, such that for any o1 and o2 in O, identity(o1) = identity(o2) implies type(o1) = type(o2) and state(o1)= state(o2). We therefore can use identity of an object in O to re- fer to the object. In the rest of the paper, an object o =< ref, C,σ > means one in O if there is no confusion, and will use ref.a to denote state(o)(a), and type(ref ) to denote type(o).

Notations:	We introduce the following notations:
A class N is said to be a subclass of M , denoted by N ≤ M , if N = Null
or N = M , or there exists a finite set {Ci | 0 ≤ i ≤ n} of classes such that
N = C0,  M = Cn and super(Ci)= Ci+1, for 0 ≤ i < n
Let s =< s1,... , sk > be a non-empty sequence. We use head(s) to denote
def
the first element s1of s; tail(s) = < s2,... , sk > that is the sequence ob-
tained from s by removing its first element (it can be the empty list < >);
|s| the length k of s; and πi(s) the ith element si, for i ∈ {1,... , k}.
Let S and S1 be sets. For better reading in the context of semantic defini- tion, we define S1 Œ S to be the set with the elements of S1 being removed from S.
For a mapping F : D '−→ E, d ∈ D and r ∈ E

def
F ⊕ {d '→ r}
'	∧ ∀b ∈ {d} Œ D • F '(b)= F (b)

= F , where F (d)= r
For an object o =< ref, C,σ >, an attribute a of C and an entity d which is either a member of a primitive type or an object in O,
def
ref ⊕ {a '→ d} = < ref, C,σ ⊕ {a '→ d} >
For a set S ⊆ O of objects,
def
S  {< ref, C, σ >} = {o | identity(o)= ref }	S ∪ {< ref, C,σ >}
def
Ref (S) = {ref | ref is the identity of an object in S}


Variables and states
Our model describes the behaviour of an object-oriented program by a design containing the following logical variables as its free variables.
cn: its value is the set of class names which are declared so far, and it is modified by a class declaration.
Each class N ∈ cn is associated with
attr(N ): the set of class N ’s (declared or inherited) attributes. We also use a ∈ attr(N ) to denote that a is an attribute name of class N .
op(N ): the set of class N ’s (declared and inherited) methods.
{m1 '→ (paras1, D1 ), ·· · , mk '→ (parask, Dk)}
which states that each method mi has parasi as its formal parameters, and that the behaviour of mi is defined by the design Di referred by Def(N.mi). These variables are modified by class declarations.
For each N ∈ cn, Σ(N ) is the set of objects of class N current existing in the execution of the program, and it will be changed by creating a new object (and destroying an existing object that we do not deal with in this

paper). Let

def
Σ =
N[∈cn
Σ(N )

super: the partial function mapping a class to its direct superclass. This variable is also modified by a class declaration.
var: its value is the set of variables which are known to the program. Since our language allows nested declaration, var associates each variable with a sequence of types
{(x1 ,< T11 ,..., T1m >), ·· · , (xn,< Tn1 ,..., Tnk >)}
where Ti1, for i ∈ {1,... , n}, is the most recently declared type of xi and denoted by dcltype(xi). We will also use var(x) to denote the sequence of types associated with x.
visattr: its value is the set of attributes which are visible from inside the current class, i.e. all its declared attributes plus the protected attributes of its superclasses and all public attributes. This value will be modified by the whole declaration of the program and by variable redeclarations.
x: this logical variable represents the state of variable x. Since a variable can be redeclared, its state is usually a nonempty finite sequence of values, whose first (head) element represents the current value of variable x. A variable of a primitive data type can take any member of that type as its value. However, an object variable can store an object name or identity as its value.

Evaluation of expressions
The evaluation of an expression e determines its type type(e) and its value. The evaluation makes use of the state of Σ(C) for each class C ∈ cn.
A variable x is well-defined if it is declared in var, its type is either primitive and then its current value is a member of this type, or a class in cn and in this case its current value is an identity of an object.
def

D(x)
= x ∈ var ∧ (dcltype(x) is primitive ∨ dcltype(x) ∈ cn)
∧  dcltype(x) is primitive ⇒ head(x) ∈ dcltype(x)
∧  dcltype(x) ∈ cn ⇒ head(x) ∈ Ref (Σ(dcltype(x))

type(x) def ( dcltype(x)	if dcltype(x) is primitive
type(head(x)) otherwise
def	
value(x) = head(x)

The null object expression,
def



def



def

D(null) = true,  type(null) = NU LL,  value(null) = null
self is a special variable whose type has to be a class in cn, and it is

evaluated in the same way as other variables,
def

Ð(self )

type(self )
value(self )
= self ∈ var Λ dcltype(self ) ∈ cn


Λ  head(self) ∈ Ref (Σ(dcltype(self )))
def
= type(head(self))
def
= head(self)

An attribute le.a is defined only when le is of type of a class and attached to an non-null object, and a is an attribute name. An attribute is thus defined inductively as follows:
def

Ð(x.a)
=	Ð(x) Λ dcltype(x) ∈ cn Λ head(x) /= null
Λ type(x).a ∈ visattr

type(x.a) value(x.a)
def


=	type(head(x).a)
def


=	head(x).a

D(le.a) value(le.a) type(le.a)
def
=  D(le) Λ type(le).a ∈ visattr
def
=  vaule(le).a
def
=  type(value(le).a)

The following exemplifies the well-definedness and evaluation of built-in expressions

Ð(e/f )
def
=	Ð(e) Λ Ð(f ) Λ type(e)= Real
Λ type(f )= Real Λ value(f ) /=0 

value(e/f )
def
=	value(e)/value(f )

The semantics of the equality e1 = e2 is the reference equality:
Ð(e1) Λ Ð(e2 ) Λ (value(e1)= value(e2 )) Λ (type(e1)= type(e2))

Semantics of commands
A typical aspect of an execution of an object-oriented program is about how objects are to be attached to program variables (or entities [43]). An at- tachment is made by an assignment, the creation of an object or passing a parameter in a method invocation.
When we define the semantics [E ] of an element E of the language, we will use E itself to denote its semantics in a semantic defining equation.
Command skip terminates and does not change the state
def
skip = $ : (true ▶ true)
Command chaos has the weakest specification
def
chaos = $ : (false ▶ true)
Assignments: There are two cases of assignments. The first is to (re-)attach a value to a variable. This can be done only when the type of the object is consistent with the declared type of the variable. The attachment of values

to other variables are not changed.
def
x := e =
{x} : Ð(x) Λ Ð(e) Λ (type(e) ≤ dcltype(x)) ▶ (x' =< value(e) > ·tail(x))
The second case is to modify the value of an attribute of an object attached to a variable. This is done by finding the attached object in the system state Σ and modify its state accordingly. Thus, all variables that points to the identity of this object will be changed.
def
le.a := e = {Σ(type(le))} : (Ð(le.a) Λ Ð(e) Λ (type(e) ≤ dcltype(le.a))) ▶
(Σ(type(le))' = Σ(type(le))  {value(le) ⊕ {a '→ value(e)})
Condition choice: is defined in the traditional way:

P ¢ b ¢ Q

We use
def
= (Ð(b) Λ type(b)= Bool)
⇒ (P Λ value(b) ∨ Q Λ ¬value(b))

if{(bi −→ ci)|1 ≤ i ≤ n}fi
to denote the multiple choice statement. Its semantics is defined to be the design
n	n
^(Ð(bi) Λ type(bi)= Bool) ⇒ _(value(bi) Λ ci)
Non-deterministic choice is defined as
def
P H Q = P ∨ Q
Sequential composition corresponds to relational composition:
'	'  def	'
P (s, s ); Q(s, s ) = ∃m · P (s, m) Λ Q(m, s )
Loop statement is defined in terms of the weakest fixed point:

b ∗ P
def
= µX.(P ; X)	b	skip

Object creation: The execution of C.New(x) (re-)declares variable x, creates a new object, attaches the object to x and attaches the initial values of the attributes to the attributes of x too.
def
C.New(x) = {var, x, Σ(C)} : C ∈ cn ▶ ∃ref /∈ Ref (Σ)•
0 Σ(C)' = Σ(C) ∪ {< ref, C, {a '→ Init(C.a) | a ∈ attr(C)} >}Λ 1

'
(var' = {x} Œ var ∪ {(x, < C > ·var(x))})∨
(x /∈ var Λ (x' =< ref >) Λ (var' = var ∪ {(x, < C >)}))
CCA

We use C.New(x)[c] to denote the command C.New(x); x.a := c, where a is the lists of attributes of C, and c is a list of expressions of the same length.

Variable declaration:	declares a variable and initializes it:
def
var T x = e = {x, var} : Ð(e) Λ (type(e) ≤ T ) ▶
((x ∈ var Λ x' =< value(e) > ·xΛ
var' = {x} Œ var ∪ {< T > ·var(x)}∨
x /∈ var Λ (x' =< value(e) >) Λ (var' = var ∪ {(x, < T >)})
Variable undeclaration:	terminates the block of the permitted use of a variable:
def
end x = {var, x} : ( ∈ var) ▶
(|var(x)| =1 Λ var' = {x} Œ var)∨
(|var(x)| > 1 Λ x' = tail(x) Λ var' = {x} Œ ∪{(x, tail(var(x)))})
Read in Value: is defined as
def
read(T x) = ∃c0 · (var T x = c0 )
Method Call:  Let v, r and vr be lists of expressions. The command le.m(v, r, vr) assigns the values of the actual parameters v and vr to the formal value and value-result parameters of the method m of the object o that le refers to, and then executes the body of m. After it terminates, the value of the result and value-result parameters of m are passed back to the actual parameters r and vr.
def
le.m(v, r, vr) = D(le) Λ type(le) ∈ cn Λ m ∈ op(type(le)) ⇒
∃N • (type(le)= N ) Λ	var N self = le, T1 x = v, T2 y = r, T3 z = vr;
Ψ(N.m); r, vr := y, z; end self, x, y,z 
where x, y, z are the value, result and value-result parameters of the method of class type(le), and Ψ(N.m) stands for the design associated with method m of class N , that will be defined in Section 4.2.6.

Semantics of a class declaration
A class declaration cdecl given in Section 4.1.1 is well-defined if the following conditions hold.
N has not been declared before: N /∈ cn, N and M are distinct: N /= M , and the attribute names of N are distinct
distinct(u · v · w)
where distinct can be obviously defined.
The initial values of the attributes matches their corresponding types.
∀i : 1..m • type(ui)= Ui Λ ∀i : 1..n • type(vi)= Vi
Λ ∀i : 1..k : •type(wi)= Wi
The method names are distinct
distinct(< m1,..., mÆ >)

The parameters of every method are distinct.
∀i : 1..l •	distinct(xi · yi · zi)Λ
|xi| = |T i1 |Λ |yi| = |T i2 |Λ |zi| = |T i3|
Let D(cdecl) denote the conjunction of the above conditions . The class dec- laration cdecl adds the structural information of class N to the state of the following up program, and this role is characterized by the following design.
def
cdecl = {cn, super, pri, protattr, pub} : Ð(cdecl) ▶
cn' = cn ∪ {N }Λ super' = super ⊕ {N '→ M }Λ
pri' = pri ⊕ {N '→ {< U u = a >}}Λ pro' = pro ⊕ {N '→ {< V v = b >}}Λ pub' = pub ⊕ {N '→ {< W w = c >}}Λ
op' = op ⊕ {N '→ {(m1 '→ (paras1, c1)),.. ., (mÆ '→ (parasÆ, cÆ))}}
where the dynamic behaviour of the methods cannot be defined before the dependency relation among classes is specified. At the moment, the logical variable op(N ) binds each method mi to code ci rather than its definition which will be calculated in the end of the declaration section.

Semantics of a program
A class declaration section cdelcs comprises a sequence of class declarations. Its semantics is defined from the semantics of a single class declaration given in the previous subsection, and the semantics of sequential composition. How- ever, the following well-definedness conditions need to be enforced:
D1: All class names used in the variable, attribute and parameter declarations are defined in the section.
D2: The function super does not induce circularity.
D3: No attributes of a class can be redefined in its subclasses.
D4: No method of a class is allowed to redefine its signature in its subclass.
Let cdecls be a class declration section and P a command, the meaning of a program (cdecls • P ) is defined as the composition of the meaning of class declarations cdecls (defined in Section 4.2.5), the design init, and the meaning of command P :
def
cdecls • P  = (cdecls; init; P )
where the design init performs the following tasks
to check the well-definedness of the declaration section,
to decide the values of attr and visattr from those of pri, pro and pub.
to define the meaning of every method body c.

The design init is formalized as:
def
init = {visattr, attr, op} : Ð1 Λ Ð2 Λ Ð3 Λ Ð4 ▶
0 visattr' = SN∈cn{N.w | ∃T, d• < T w = d >∈ pub(N )}Λ	1
∀N ∈ cn • attr'(N )= ∪{pri(N ) ∪ pro(M ) ∪ pub(M ) | N ≤ M }Λ
op'(N )= {m '→ (paras, Ψ(N.m)) | m ∈ op(M ) Λ N ≤ M }
where the family of designs Ψ(N.m) defined by a set of recursive equations. It contains for each class N ∈ cn, each class M such that N ≤ M , and every method m ∈ op(M ) an equation
Ψ(N.m)= FN.m(Ψ)	where supercalss(N )= M
where F is constructed according to the following cases.
Case (1) m is not defined in N , but in a superclass of N , i.e. m /∈ op(N ) ∧ m ∈ ∪{op(M ) | N ≤ M }. Then a call to the method m in the environment of N will be executed according to the definition of m in the lowest superclass of N that declares the method. Let M be that lowest superclass of N , i.e. m is declared in M but no subclass of M declares m. The defining equation for FN.m(Ψ) in this case is
def
FN.m(Ψ) = Set(N ); φN (body(M.m)); Reset
Case (2) m is a method defined in class N . In this case, the behaviour of the method N.m is captured by its body and the environment in which it is executed
def
FN.m(Ψ) = Set(N ); φN (body(N.m)); Reset
where the design Set(N ) finds out all attributes visible to class N , whereas
Reset does it for the main program:
def	'

Set(N )
= {visattr} : true ▶ visattr =
{N.a | a ∈ pri(N )}∪ {M.a | N ≤ M, a ∈ pro(M )}∪
{M.a | M ∈ cn,a ∈ pub(M )}

def	'
Reset = {visattr} : true ▶ visattr = {M.a | M ∈ cn,a ∈ pub(M )}
The function φN renames the attributes and methods of class N in the code
body(N.m) by adding object reference self :
def
φN (skip) = skip
def
φN (chaos) = chaos
def
φN (p1; p2) = φN (p1); Set(N ); φN (p2)
def
φN (P1 ab d P2 ) = φN (P1) a φN (b) d φN (P2 )
def
φN (P1 H P2 ) = φN (P1) H φN (P2)
def
φN (b ∗ P ) = φN (b) ∗ (φN (P ); Set(N ))



def
φN (var T x = e) = var x : T = φN (e)
def
φN (end x) = end x
def
φN (C.New(x)) = C.New(φN (x))
def
φN (le := e) = φN (le) := φN (e)
def
φN (le.m(v, r, vr)) = φN (le).m(φN (v), φN (r), φN (vr))
def
φN (m(v, r, vr)) = self.m(φN (v), φN (r), φN (vr))
def	self.x ∃M · N ≤ M Λ x ∈ attr(M )
φN (x) =
x	otherwise
def
φN (self ) = self
def
φN (le.a) = φN (le).a
def
φN (null) = null
def
φN (f (e)) = f (φN (e))
Notice that we did not introduce the syntax super.m to explicitly indicate the call to a method according to its definition in the superclass. Instead the a method call will be executed according to the definition of method at the lowest position in the inheritance hierarchy. There is no difficulty to introduce super.m and define its semantics accordingly.

Specifying UML Models
This section uses an iterative development of a library system as an example to show how to specify and reason about UML models of requirements analysis and designs. We refer the reader to our paper [40] for details of formal speci- fication of UML models of requirements, and to [37,36] for a formal semantics of UML sequence diagrams.

Conceptual class diagram
A class in a class diagram is specified as class declaration. An association between two classes N and M is a type of pairs of objects of N and M , and modelled as a class that has two attributes with the association’s end roles N and M as their types.
Assume that an iteration of a library system development considers the use case to record a copy and the conceptual model in left diagram of Figure 2. A library Lib Owns a number of Publications and each publication Contains some Copy(ies).
We specify this diagram as CM1 below:
Class Lib {String name, String address}; Class Copy {String id}; Class P ub {String id, String title, String author, String isbn}; Class Contains {P ub p, Copy c}; Class Owns {Lib lib, P ub p}


	
Fig. 2. Models of the Requirements for Cycle 1 (Left) and Cycle 2 (Right)
We also assume the set of objects Σ(N ) is initially empty for each class N , and the operations S.f ind(), S.add(), and S.delete() for a set S. For the above declared conceptual class diagram, we have
PLib Lib = ∅; PPublication Publication = ∅; PCopy Copy = ∅; POwns Owns = ∅; PContains Contains = ∅

Use cases
The informal identification and description of a use case is important for the creation of the conceptual model to support it. However, the formal specifi- cation of the use cases depends on the specification of the conceptual model. We have a canonical form of a use case specification by introducing a use-case handler class 2 . At any time during the execution, this class will only have a single instance. Considering the use case RecordCopy that adds a new copy of an existing publication to the library. We specify this use case by introducing a use case handler class LS (denoting the logic library system):
CM1 ; //** import the conceptual model
Class LS ::
method RecordCopy(< String cid, String pid >){
∃p ∈ Σ(P ub),l ∈ Σ(Lib) • p.id = pid Λ (l, p) ∈ Σ(Owns) ⇒
Copy.New(c)[cid]; var P ub p = Σ(P ub).f ind(pid);
Σ(Copy) := Σ(Copy) ∪ {c}Λ Σ(Contains) := Σ(Contains) ∪ {< p, c >};
end c, p}
In the specification, we have used programming commands, programming con- structs, predicate and logical connectives. This is because that programming commands and constructs have been defined as predicates and logical oper- ations. Also c1 ∧ c2 does not specify the order in which of the commands c1

2 This is suggested by the facade controller pattern.

and c2 are executed.
Then we define the system specification by defining the main method in which

RCopy
def
= read(String cid, String pid); hrc.RecordCopy(cid, pid) in the fol-

lowing statement:
main(){var Bool stop = false, Services s; LS.N ew(hrc); Lib.N ew(lib);
¬stop ∗ (read(s); if {s = ”RecordCopy” −→ RCopy} fi; read(stop));
end stop, s}
where Services denotes the set of names of services that the library system provides. When further use cases are developed, their names are added to Services and their executions are added to the command set in the multiple choice statement of the main method.
In the case for sequential programs, only one instance h of a use-case handler H-Handler is needed and h.op can be simply written as op. Then each use case UH is a piece of sequential program, and whole main program main() is an iterative deterministic choice among the use cases:
¬stop ∗ (read(service); if {service = H −→ UH } fi; read(stop))
A call to a system operation m(x, y, z) can also be written as a CSP-like process, where x, y and z are the value, result and value-result parameters:
m?x −→ m(x, y, z); m!y
Then use case H as a whole can be written as a CSP process UH and the program P in the canonical system specification can be specified as an

iterative process (UH1
[] ··· []UHÆ
)∗.

Therefore our methodology is:
For a sequential software development, after the system operations are iden- tified and specified in the use-case handler classes, writing the formal speci- fication of the use cases becomes writing a specification of the main method P of the object-oriented software. Although it will not affect the overall functionality of the system, it is recommendable to have a handler class for each use case as in the normal form of the system specification. This makes the method more programmatic and fit in an iterative development process better. In a later stage of the design, we can refine the specification to combine some classes.
For a concurrent system, writing the formal specification of the use cases is to write the specification of the run methods of the concurrent actors that requires services from the system.
However, as suggested in UML, the development takes a sequential view first and treats concurrency in the implementation stage by using activity


diagrams. Then the design and implementation of the system is mainly to design and implement the system operations by decomposing them into interactions between objects of the system.
We have a third suggestion in our component calculus [26] to deal with concurrency at the level of component compositions via the interfaces and protocols of components.
This is a typical top-down development, but the use cases and system opera- tions can be taken in turns in an iterative process.
In general, a use case is more complicated than the one we discussed above and may have alternatives and exceptional courses of events. Due to the space limit, we cannot treat such a use case in this paper. However, use cases [33,38] show that the method for informal description of such a general use case, the drawing of its system sequence diagram, and the specification of the design of the system operation identified in the sequence diagram is quite programmatic and can scale up very well. The formalization in OOL can be worked out systematically for the informal description.
By calculating the semantics of (CM1; HandleRcopyDecl)• main() within our model, we can check that the conceptual class diagram is consistent with the use case speciﬁed speciﬁcation. The semantics supports to check the well- definedness of the declaration section (CM1; HandleRcopyDecl), the well- definedness of the commands in main(). The well-definedness of (CM1; Handle RcopyDecl) implies the well-formedness of the corresponding UML class dia- gram, and the consistency between the class diagram and the use case model. The sufficient condition to ensure the overall consistency is that semantics of the composition
(CM1; HandleRcopyDecl) • main()
does not equal to chaos. An intuitive understanding about the consistency problem is to think of a static inconsistency, such as missing class or association and conflict names, as an “compiling error” of the program (CM1; HandleRcopy Decl)•main(), and a dynamic inconsistency, such as violation of pre-condition or invariants and dynamic binding error, as an “execution error” of the pro- gram. The advantage of the formalization is that it enables us to reason about inconsistency without compilation and execution and the reasoning can be done at the requirement level. Notice that within our semantic framework, a correction of any inconsistency is then formally treated as a reﬁnement of the program specification.

Interaction diagrams and design class diagrams
To specify a sequence diagram and a design class diagram, we need to refine the classes in the conceptual model into software classes by adding methods, and realizing the associations by attributes of classes. Roughly speaking, an


		
Fig. 3. Models of the Designs for Cycle 1 (Left) and Cycle 2 (Right)

incoming message to a class in a sequence diagram corresponds to a method of the class, the outgoing messages of the class following that incoming message is specified as sequential composition of method calls. Formal definitions of sequences diagrams are given in our related work in [37,36]. For example, the object sequence diagram and its design class diagram in Figure 3 (on the left) are specified by the following class declarations:
Class Lib {String name, String address PP ub pub; //** newly added
method add(< String cid, String pid >){
var P ub p = P ub.find(pid); p.makeCopy(cid); end p}};
Class P ub {String id, String title, String author, String isbn, PCopy Cp;
method makeCopy(< String cid >) {Copy.New(c)[cid]; Cp.add(c)}};
Class Copy {String id};
Class LS {Lib lib;
method RecordCopy(< String cid, String pid >){lib.add(cid, pid)}}
In the design, main() method is almost the same as that in the use-case model.
main(){var Bool stop = false, Services s; Lib.N ew(lib); LS.N ew(ls)[lib];
¬stop ∗ (read(s); if {s = ”RecordCopy” −→ RCopy} fi; read(stop));
end stop, s}



Define the data refinement mapping:
def


def	[




def
Σ(Copy) =
p∈ls.[lib.P ub

def
p.Cp,	Σ(Owns) = {ls.lib}× ls.lib.P ub

With our model and reﬁnement calculus, we can check whether a design class diagram is consistent with a family of sequence diagrams, that this design refines the program that represents the use-case speciﬁcation. Details about the consistency of a model of design and the link between a UML model of design to a UML of requirements are formally addressed in [37,36]. The refinement involves in adding or removing attributes, methods, classes and associations; delegating methods; and refining commands. A refinement calculus for object- oriented systems is given in [25] in which all these “refectoring” operations on the structure of an object-oriented program are proven to be valid refinement.
An alternative but still correct design of RecordCopy is to redefine the
add() method in Lib,
Lib :: add(){var Publication , p, Copy c;
p := P ub.find(pid); Copy.New(c); p.addCopy(c); end p, c
}
and to replace Publication :: makeCopy() by
Publication :: addC(val Copy c){Cp.add(c)}
However, this design adds an extra dependency between Lib and Copy.



Further development of the library system

Now consider the use case to register a member that creates a member and logs it to the library. We thus have to extend the class diagram on the left of Figure 2 to the one on the right, that is denoted by CM2, by adding the following two classes.
Class Member {String name, String title, String id, String address};
Class Has {Lib lib, Member m}

Let SList be the type String × String × String × String and details
def
=

(name, title, id, address) denote the tuple of the attributes of M ember. We can then specify the use case to register a member, denoted by RegisterM , by a use-case handler HandleRM which has Lib lib as an attribute and a method RegisterM . However, we can also use the same use case handler class LS to

handle this new use case too:
LS :: RegisterM (< SList ml >){
¬∃m ∈ Σ(Member) • m.details = ml Λ ∃lib ∈ Σ(Lib) ⇒
Member.New(m)[ml]; Σ(Member) := Σ(Member) ∪ {m};
(Σ(Has) := Σ(Has) ∪  Æ∈Σ(Lib) {< l, m >})}
We can prove that this use case is consistent with the extended conceptual model.
We can consider RegisterM independently from RecordCopy with its own conceptual model of classes Lib, M ember and the association Has. We then obtain CM2 by merging this model with CM1. If different names are used for the same concept, rename one to another.
Then the main method will be enlarged by adding the service name ”RegisterM ” in Service and adding the following command to the multiple choice statement
def
RegM = read(SList ml); hrm.RegisterM (ml)
guarded by s = ”RegisterM ”
main(){var Bool stop = false, Services s; Lib.N ew(lib); LS.N ew(ls)[lib];
¬stop ∗ (read(s); if	s = ”RecordCopy” −→ RCopy,	fi; read(stop)); s = ”RegisterM ” −→ RegM
end stop, s}
Following the design patterns in [33], we can work out the interaction diagram and the design class diagram on the right Figure 3.
Lib :: PMember M ; // ∗ ∗add a new attribute to Lib
Lib :: makeMember(< SList ml >){// ∗ ∗add a method to Lib New Member(m)[ml]; M.add(m); end m};
LS :: RegisterM (< SList ml >){lib.makeMember(SList ml)}
The main method is nearly the same as in the requirement specification.
We prove the design of RegisterM is correct by defining the data refine- ment mapping
def	def
Σ(Member) = ls.lib.M  Σ(Has) = {< ls.lib, m > | m ∈ ls.lib.M }
With CM2, we can specify and design use cases SearchMember, SearchPub
and SearchCopy.

Borrow a copy
Now let us consider the use case BorrowCopy that records the fact that a registered member has borrowed a copy from the library. We need to introduce a new concept Loan that records the information of a loan of a copy by a member. The Loan class is associated with classes Member and Copy so that





1
has
*
1	owns	*



1	1	1


1
contains
*

takes
*
borrows

Fig. 4. Conceptual model for BorrowCopy

Fig. 5. Design model for cycle 3

a member Takes the loan which Borrows a copy. The conceptual model CM2
is extended CM3 in Figure 4, and specified as follows:
def
CM3 = CM2; //**Reuse conceptual model
Class Loan {String date, String id};
Class T akes {Member m, Loan loan} Association Class Class Borrows {Copy c, Loan loan}  Association Class
We specify the use case as a method of the same handler class LS, though we can use a new handler.
LS:: BorrowCopy(val String cid, String mid){
∃m ∈ Member • member.id = mid
Λ∃c ∈ Copy • c.id = cid Λ ¬∃loan ∈ Loan• < loan, c >∈ Borrows ⇒
var Loan loan, Member m;
Loan.N ew(loan) Λ m := Members.find(mid); Loan' = Loan ∪ {loan}Λ
Borrows' = Borrows ∪ {< loan, c >}Λ T akes' = T akes ∪ {< m, loan >};
end loan, m
}


As the second iteration, add ”BorrowCopy” to Service, and define
def
BCopy = read(String cid, String mid); LS.BorrowCopy(cid, mid)
The main program is specified as
main(){ var Bool stop, Service s;
stop := true; while ¬stop do{ read(s); read(stop)
if {s = ”RecordCopy” −→ RCopy, s = ”RegisterM ” −→ RegisterM, s = ”BorrowCopy” −→ BCopy} fi;
end s, stop}
}
The main program can be extended as before by adding the new BorrowCopy
service.
The same conceptual model CM3 supports the specification of the use cases for finding the number of loans for a member MGetLoanSize and for a copy CGetLoanSize.



Design use case BorrowCopy
We give a design by adding an attribute PCopy Copy and a method makeLoan() to class Copy, an attribute PLoan Loan and a method takeLoan() to class Member, redefine class Loan so that it has an attribute Copy c, and redefine the method BorrowCopy() in LS. We give a UML design model in Figure 5, and its specification below:
Lib :: PCopy Copy = ∅;
Lib :: makeLoan(val String mid, String cid){
var Member m, Copy c;
m := Member.find(mid) Λ c := Copy.find(cid); m.takeLoan(c) ¢ (c /= null Λ m /= null) ¢ chaos; end m, c };
Member :: PLoan Loan;
Member :: takeLoan(val Copy c){
var Loan loan; loan := Loan.N ew(loan)[c]; Loan.add(loan); end loan
};
Class Loan {Date date, String id, Copy c}; LS :: BorrowC(val String mid, String cid){
lib.makeLoan(mid, cid)
}
More use cases, such as Return a Copy, can be developed in the next iteration.

Conclusion
Based on UTP [29], we have presented a model for object-oriented programs. The model is compositional, where the well-definedness of a class is deter- mined in dependence of its constituents. Incremental code changes, as what often happen in object-oriented programming, require revising only the af- fected parts of the model and not the model as a whole. The model allows us to compose the static UML view with the UML functional view of the re- quirements, and the static UML model with the UML interaction model of the design. It also supports the verification of the correctness of a design model against a requirement models.
The important nature of the integrated method is that each iteration is only concerned with a small part of the system functionality and a small model at a time. Instead of using a traditional compositional approach, we decompose the system informally according to use cases. We obtain formal models in each iteration and compose them to form a larger system step by step. We believe that this is important for scaling up the use of a formal method. A system developed this way is easy to maintain when the business rules change. For example, consider the need to impose the restriction on the use case BorrowCopy that a member is only allowed to take a limited number k of loans. We only need to add a method NBorrow() method in LS
LS :: NBorrow(val String mid, String cid){
Int n := LoanSize(mid);
self.Borrow(mid, cid) ¢ (n < k) ¢ (”error”)
Then we replace Borrow use case with NBorrow in the main program. This does not need to change the implementation of any other core classes of the system.
Because our approach supports refinement of models by introducing mod- elling elements in an incremental manner, it clearly supports the Sketch and blueprint modes of UML usage pointed out by Martin Fowler in his invited talk at <<UML>> 2003 [19]. Also, our formalization of UML model in a specification in a Java-like notation can be seen as a step toward third mode of usage of UML suggested by Martin Fowler as a programming language. Being able to use UML as a programming language is very important for the success of MDA [19,6,42].

Related Work
Models of object-oriented programs
There is a large number of publications on models for object-oriented program- ming, e.g. [1,2,8,4,10,45]. A large body of work on modelling object-oriented


programming is based on type theories or operational semantics. Our ap- proach is among those that are state-based and uses a predicate logic.
State-based formalisms have been used in conjunction with object-oriented techniques, via languages such as Object-Z [10] and V DM ++ [15], and meth- ods such as Syntropy [13] (which uses the Z notation) and Fusion [12] (which is related to V DM ). Whilst these formalisms are effective in modelling data structures as sets and relations, they are not ideal for capturing more sophis- ticated object-oriented mechanisms, such as dynamic binding and polymor- phism.
Cavalcanti and Naumann define an object-oriented programming language with subtype and polymorphism using predicate transformer [11,45]. Mikha- jlova and Sekerinski [44] design a rich object-oriented language by using a type system and predicate transformers as well. However, neither reference types nor mutual dependency between classes is allowed in those approaches.
There are a number of recent articles on Hoare Logics for object-oriented programming (see, e.g. [46,52,30,47]). The normal form of a program in our paper is similarly to those in [11,46]. However, a class declaration (sec- tion) and a program, as well as a command, are represented as predicates called designs in UTP [29]. This provides us with a formal characterization of the contextual/structural feature of the object-oriented programs and a structural reﬁnement relation between object-oriented programs [25]. Also the refinement relation between programs is defined as implication between their designs. The proof of a refinement will be carried out in the predicate logic rather than in a Hoare logic proof system. The notion of structural re- finement supports a formal treatment of refectorings [20] and object-oriented designs to support iterative and incremental development. This has turned out to be essential when we use this model to formalize and compose different UML models. Another advantage of our approach is that writing a specifica- tion in the relational calculus is quite straightforward and a specification is easy to understand. Although we have not dealt with concurrency, the power of UTP for describing different features of computing, including concurrency and communication, timing, and higher-order computing [29,54,50], makes our approach ready for extension to cope with these different aspects of object- oriented programs. Alternatively, one can also use temporal logic, such as [3], for the specification and verification of multithreading Java-like programs. However, we would like to deal with concurrency at a higher level when we extend this model for component-based software development [27,26].

Formalizations of UML
The research on formal support for UML modelling (e.g. [18,5,17,16,22,48]) is currently very active . However, there is a large body of work in formalizing UML and providing tool support for UML focuses on models for a particular view (e.g. a class models, statecharts, and sequence diagrams), and the trans- lation of them into an existing formal formalism (e.g. Z, VDM, B, and CSP). In contrast, we concentrate on use cases and combinations of different UML models. This is the most imprecise part of UML and the majority of existing literature on the UML formalization often avoids them. Our methodology is directly towards improved support for requirement analysis and transition from requirements to design models in RUP. The notion of structural refine- ment enables us to transform UML models consistently. This is very impor- tant for UML-based development as these transformations allow developers to model a system at different level of abstraction. In fact the article [18] pointed out the need of such correctness preserving manipulation of UML models and made the initial attempt to provide some transformations. Unfortunately, it could not go far enough and only considered transformation of class diagrams to preserve state invariant. Our choice of a Java-like syntax for the specifi- cation language is a pragmatic solution to the problems of representing name spaces and (the consequences of) inheritance in a notation such as CSP.
An earlier version of the semantic model for OOL was presented in [24] that does not deal with references and nested local variable declaration. Based on [24], the notions of refinements for commands, class declarations and programs are defined in [25]. Our idea about combining a conceptual class model and a use-case model was initially presented in [39], without using a specification language. It was embedded into a use-case driven approach for requirement analysis in the paper [34]. These two papers evolved into a comprehensive method for UML-based requirement analysis in [40] with the ideas of normal form of specification. The completeness of the model for requirement analysis can be justified by the computation model presented in [41]. Then we estab- lished the semantic model for OOL with references and nested local variable declaration in the report [28]. We have recently used OOL to give a formal semantics of UML interaction diagrams in [37,36]. This paper presents the formal semantics of OOL given in [28] and embeds it in the context of RUP and UML based software development.
In this paper, we focus on only conceptual aspects of object orientation. Most syntactical and semantic consistency conditions defined in this paper have straightforward algorithms for checking and hence support necessary au- tomated tools [35]. For example, the transformation of a class diagram to a declaration section is obvious and the well-defined conditions for declaration


section is clearly consistent with the well-formed conditions of UML defined in terms of OCL. Other constraints on a class model, such as multiplicities of an association, properties of an aggregation association, characterization of an abstract class and associative classes, can be specified as state invariants that need to be preserved by use case commands [40].

Future work
We are currently working on a comprehensive set of refinement laws to support both behavioural and structural refinement of object-oriented designs. Future work also includes the extension of this method to component-based software development (e.g. [14,51]) so that components can be developed in parallel, and the application of this framework to formal treatment of patterns [21]. Defining an executable semantics for the modelling language in this paper and thus to provide an executable semantics for (a subset of) UML will be attractive to the MDA [19,6,42] community 3 .
In addition, tool support, e.g. in the direction of [23], for formal object- oriented methods is an area of considerable significance for further industrial take-up of these methods. We are also interested in studying the difference and relationship between our model and Separation Logic [49].

Acknowledgments
First of all, we are very much grateful to the two referees for their careful reading, insight comments and for the technical errors they pointed, that have helped a lot to bring the paper into this revised form. We thank Dines Bjorner at Technical University of Denmark, Anders Ravn from Aalborg University of Denmark and Uday Reddy from Birmingham University of the UK for their helpful comments and discussions at and after the seminars that the second author gave on parts of the works when he visited them. Our UNU-IIST fellows Quan Long, Bhim Upadhyaya and Jing Yang also read and gave useful comments on earlier versions of the article. The second author would also like to thank the students at the University of Leicester and those participants of the UNU-IIST training schools and courses who took his course on Software Engineering and System Development for their feedback on the understanding of the use-case driven, incremental and iterative OO development and the design patterns.

3 A number of panellists of the Panel of “What should a good modelling language look like” at UML’03 pointed out that a modelling language should be executable in terms of having a compiler so the testing and simulation can be carried out effectively.

References
M. Abadi and L. Cardelli. A Theory of Objects. Springer, 1996.
M. Abadi and R. Leino. A logic of object-oriented programs. In M. Bidoit and M. Dauchet, editors, TAPSOFT ’97: Theory and Practice of Software Development, 7th International Joint Conference, pages 682–696. Springer-Verlag, 1997.
E. Abraham-Mumm, F.S. de Boer, W.P. de Roever, and M. Steffen. Verification for Java’s reentrant multithreading concept. In Foundations of Software Science and Computation Structures, Lecture Notes in Computer Science 2303, pages 5–20. Springer, 2002.
P. America. Designing an object-oriented programming language with behavioural subtyping. In J. W. de Bakker, illem P. de Roever, and G. Rozenberg, editors, REX Workshop, Lecture Notes in Computer Science 489, pages 60–90. 1991.
R.J.R. Back, L. Petre, and I.P. Paltor. Formalizing UML use cases in the refinement calculus. In Proc. UML’99. Springer-Verlag, 1999.
J. Benivin. MDA: from hype to hope and reality. In P. Srevens, J. Whittle, and G. Booch, editors, <<UML>> 2003 -The Uniﬁed Modeling Language, 6th International Conference, Lecture Notes in Computer Science 2863. Springer, 2003.
B. Boehm. A spiral model of software development and enhancement. IEEE Computer, May 1988.
M.M. Bonsangue, J.N. Kok, and K. Sere. An approach to object-orientation in action systems. In J. Jeuring, editor, Mathematics of Program Construction, Lecture Notes in Computer Science 1422, pages 68–95. Springer, 1998.
G. Booch, J. Rumbaugh, and I. Jacobson. The Uniﬁed Modelling Language User Guide. Addison-Wesley, 1999.
D. Carrington, et al. Object-Z: an Object-Oriented Extension to Z. North-Halland, 1989.
A. Cavalcanti and D. Naumann. A weakest precondition semantics for an object-oriented language of refinement. In Lecture Notes in Computer Science 1709, pages 1439–1460. Springer, 1999.
D. Coleman, et al. Object-Oriented Development: the FUSION Method. Prentice-Hall, 1994.
S. Cook and J. Daniels. Designing Object Systems: Object-Oriented Modelling with Syntropy. Prentice-Hall, 1994.
D. D’Souza and A.C. Wills. Objects, Components and Framework with UML: The Catalysis Approach. Addison-Wesley, 1998.
E. Du¨rr and E.M. Dusink. The role of V DM ++ in the development of a real-time tracking and tracing system. In J. Woodcock and P. Larsen, editors, Proc. of FME’93, Lecture Notes in Computer Science 670. Springer-Verlag, 1993.
A. Egyed. Scalable consistency checking between diagrams: The Viewintegra approach. In
Proc. 16th IEEE ASE, San Diego, USA, 2001.
G. Engels, et al. A methodology for specifying and analyzing consistency of object-oriented behavioral models. In The Proc. FSE-10, Austria, 2001.
A. Evans, et al. Developing the UML as a formal modelling notation. In Proc. UML’98, Lecture Notes in Computer Science 1618. Springer-Verlag, 1998.
M. Fowler. What is the point of UML. In P. Srevens, J. Whittle, and G. Booch, editors,
<<UML>> 2003 -The Uniﬁed Modeling Language, 6th International Conference, Lecture Notes in Computer Science 2863. Springer, 2003.
M. Fowler, K. Beck, J. Brant, W. Opdyke, and D. Roberts. Refactoring: Improving the Design of Existing Code. Addison-Wesley, 1999.


E. Gamma, et al. Design Patterns. Addison-Wesley, 1995.
D. Harel and B. Rumpe. Modeling languages: Syntax, semantics and all that stuff - part I: The basic stuff. Technical Report MCS00-16, The Weizmann Institute of Science, Israel, September 2000.
D. Harel, et al. Smart play-out of behavioral requirements. In Proc. FMCAD02, pages 378–398, 2002.
J. He, Z. Liu, and X. Li. A relational model for object-oriented programming. Technical Report UNU/IIST Report No 231, UNU/IIST, P.O. Box 3058, Macau, March 2001.
J. He, Z. Liu, and X. Li. Towards a refinement calculus for object-oriented systems. In Proc. ICCI02, Alberta, Canada. IEEE Computer Society, 2002.
J. He, Z. Liu, and X. Li. A component calculus. In H.D. Van and Z. Liu, editors, Proc. Of FME03 Workshop on Formal Aspects of Component Software (FACS03), UNU/IIST Technical Report 284, UNU/IIST, P.O. Box 3058, Macao, Pisa, Italy, 2003.
J. He, Z Liu, and X. Li. Contract-oriented component software development. Technical Report 276, UNU/IIST, P.O. Box 3058, Macao SAR China, 2003.
J. He, Z. Liu, and X. Li. Modelling object-oriented programming with reference type and dynamic binding. Technical Report UNU/IIST Report No 280, UNU/IIST, P.O. Box 3058, Macau, May 2003.
C.A.R. Hoare and J. He. Unifying Theories of Programming. Prentice-Hall, 1998.
M. Huisman and B. Jacobs. Java program verification via a Hoare logic with abrupt termination. In T. Maibaum, editor, FASE 2000, Lecture Notes in Computer Science 1783, pages 284–303.
I. Jacobson, G. Booch, and J. Rumbaugh. The Uniﬁed Software Development Process. Addison-Wesley, 1999.
P. Kruchten. The Rational Uniﬁed Process – An Introduction (2nd Edition). Addison-Wesly, 2000.
C. Larman. Applying UML and Patterns. Prentice-Hall International, 2001.
X. Li, Z. Liu, and J. He. Formal and use use-case driven requirement analysis in UML. Technical Report UNU/IIST Report No 230, UNU/IIST, P.O. Box 3058, Macau, March 2001. A short version is accepted for presentation at COMPSAC2001, October, USA.
X. Li, Z. Liu, and J. He. Generating a prototype from a UML model of system requirements. Submitted for publication, 2003.
X. Li, Z. Liu, and J. He. A formal semantics of UML sequence diagrams. In Pro. of Australian Software Engineering Conference (ASWEC’2004). IEEE Computer Sciety, 2004.
J. Liu, Z. Liu, J. He, and X. Li. Linking UML models of design and requirement. In Pro. of Australian Software Engineering Conference (ASWEC’2004). IEEE Computer Sciety, 2004.
Z. Liu. Object-oriented software development in UML. Technical Report UNU/IIST Report No. 259, UNU/IIST, P.O. Box 3058, Macau, SAR, P.R. China, July 2002.
Z. Liu, J. He, and X. Li. Formalizing the use of UML in requirement analysis. Technical Report UNU/IIST Report No 228, UNU/IIST, P.O. Box 3058, Macau, March 2001. A short version “Towards a formal use of UML for software requirement analysis is accepted for presentation at PDPTA2001, June, 2001, Las Vegas, USA.
Z. Liu, J. He, X. Li, and Y. Chen. A relational model for formal requirements analysis in UML. In J.S. Dong and J. Woodcock, editors, Formal Methods and Software Engineering, ICFEM03, Lecture Notes in Computer Science 2885, pages 641–664. 2003.
Z. Liu, X. Li, and J. He. Using transition systems to unify uml models. Technical report, Dept. of Maths and Computer Science, the University of Leicester, England., May 2002.


S.J. Mellor and M.J. Balcer. Executable UML: a foundation for model-driven architecture. Addison-Wesley, 2002.
B. Meyer.	From structured programming to object-oriented design: the road to Eiffel.
Structured Programming, 10(1):19–39, 1989.
A. Mikhajlova and E. Sekerinski. Class refinement and interface refinement in object-orient programs. In Proc of FME’97, Lecture Notes in Computer Science. Springer, 1997.
Naumann. Predicate transformer semantics of an Oberon-like language. In E.-R. Olerog, editor, Proc. of PROCOMET’94. North-Holland, 1994.
C. Pierik and F.S. de Boer. A syntax-directed hoare logic for object-oriented programming concepts. Technical Report UU-CS-2003-010, Institute pf Information and Computing Science, Utrecht University, 2003.
A. Poetzsch-Heffter and P. Muller. A programming logic for sequential Java. In S.D. Swierstra, editor, Proc. Programming Languages and Systems (ESOP’99), Lecture Notes in Computer Science 1576, pages 162–176. Springer, 1999.
G. Reggio, et al. Towards a rigorous semantics of UML supporting its multiview approach. In
H. Hussmann, editor, Proc. FASE 2001, Lecture Notes in Computer Science 2029. Springer, 2001.
J. Reynolds. Separation logic: a logic for a shared mutable data structure (invited talk). In Proceedings of IEEE Symposium Logic in Computer Science (LICS’02). IEEE Computer Sciety, 2002.
A. Sherif and J. He. Towards a time model for Circus. In ICFEM02, Lecture Notes in Computer Science 2495. Springer, 2002.
C. Szyperski. Component Software: Beyond Object-Oriented Programming. Addison-Wesley, 1998.
D. von Oheimb. Hoare logic for Java in Isabelle/HOL. Concurrency and Computation: Practice and Experience, 13(13):1173–1214, 2001.
J. Warmer and A. Kleppe. The Object Constraint Language: precise modeling with UML. Addison-Wesley, 1999.
J.C.P. Woodcock. Unifying theories of parallel programming. In Logic and Algebra for Software Engineering. IOS Press, 2002.
