

Electronic Notes in Theoretical Computer Science 242 (2009) 49–72
www.elsevier.com/locate/entcs

Hard Life with Weak Binders
Massimo Bartoletti, Pierpaolo Degano, Gian Luigi Ferrari
Dipartimento di Informatica, Universita` di Pisa, Italy
Roberto Zunino
Dipartimento di Informatica e Telecomunicazioni, Universita` di Trento, Italy

Abstract
We introduce weak binders, a lightweight construct to deal with fresh names in nominal calculi. Weak binders do not define the scope of names as precisely as the standard ν-binders, yet they enjoy strong semantic properties. We provide them with a denotational semantics, an equational theory, and a trace inclusion preorder. Furthermore, we present a trace-preserving mapping between weak binders and ν-binders.
Keywords: Nominal calculi, variable binding, alpha-conversion, freshness


Introduction
Over the last few years naming has been envisaged as a suitable abstraction for capturing and handling a variety of computational concepts, like distributed objects, cryptographic keys, session identifiers. Also, the dynamicity issues usually arising in distributed computing (e.g., network reconfiguration, module versioning) may be usefully explained in terms of naming disciplines such as fresh name generation, binding and scoping rules. The π-calculus [12,18] is probably the most illustrative example of nominal calculi, in which many of the concepts outlined above have been formally modelled and explained. Nominal calculi manipulate names via explicit binders that define their scope. The standard example is the π-calculus restriction operator νn. A ν-binder also declares that a fresh name has to be created. A broad variety of formal theories [8,9,20,17,13,14,4] developed in the last few years shows the intrinsic difficulties of handling naming and freshness.

٨ This research has been partially supported by EU-FETPI Global Computing Project IST-2005-16004
sensoria (Software Engineering for Service-Oriented Overlay Computers)

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.06.013

This paper aims at contributing to this line of research. Our motivating starting point is to understand what is the actual gain in using ν-binders to deal with fresh names. Indeed, the equational theory of ν-binders allows for freely moving them almost anywhere in a process (except escaping from a recursion). So, one might wonder whether ν-binders can be omitted in a process, and replaced by a more primitive construct, e.g. an atomic action to be interpreted as a gensym() that explicitly creates a fresh name.
We introduce a nominal calculus with weak binders, a construct for generating fresh names as an atomic action, without explicit ν-binders. Our calculus slightly extends Bergstra and Klop’s Basic Process Algebras [3], by allowing parametrized atomic actions α(r), that abstract from dispatching the action α to the object r. Objects can be freshly created through the special action new(n), our “weak binder”. We study under which conditions a weakly bound process can be treated co- herently with a process with ν-binders. For instance, in the weakly bound process p = new(n) · α(n)+ new(m) · α(m) there is no confusion between the scopes of the “bound” names n and m, and so p is equivalent to the “strongly bound” process P = νn.νm.(new(n) · α(n)+ new(m) · α(m)). We shall then say that p is well-bound, and that P is its bindiﬁcation. This transformation makes precise the scopes of names in weakly bound processes, by inserting the ν-binders at the right points. This is not always possible, however, e.g. in the process new(n) · (ε + new(n)) · α(n) there is an inherent ambiguity, because we cannot tell whether the action α has to be done on the object created by the first or by the second new. When bindification is possible, we prove that the semantics of the weakly bound and of the bindified
processes are trace equivalent.
A further contribution is a trace inclusion preorder  for weakly bound processes: when p  q, the traces of p are included in those of q. We compare this preorder with a trace inclusion preorder for strongly bound processes. Preorders of processes are a relevant and non-trivial aspect of subtyping/subeffecting for type and effect systems [1]. Also, thay can be udes to study the compliance of contracts with implementations and subcontract relations in calculi for Web services [5,6].
We envisage the impact of our approach as follows. Our main result is the formal definition of a methodology for handling the freshness of names without resorting to explicit binders. The overall outcome of our semantical investigation consists in the full characterization of weak binders. We have proved that weak binders still enjoy interesting semantic properties, comparably to what can be obtained through ν-binders. We have exploited weak binders to develop the static machinery (a type and effect system and a model checker) of a linguistic framework for resource usage control [1]. As a downside, we have found that weak binders, having a weaker structure than ν-binders, may make the life hard when going into the proofs.
The paper is organized as follows. We first introduce a calculus with explicit ν-binders, we give its operational and denotational semantics, and we show them fully abstract. We then remove ν-binders, and define a denotational semantics and an equational theory of weakly bound processes. Then, we define the bindify transformation, and we state its correctness: the bindification of a weakly bound

process p is trace equivalent to p. After that, we compare the equational theories and the trace inclusion preorders of strongly bound and weakly bound processes. We conclude by reporting our experience about using weak binders, and by discussing some related work. Because of space limitations, here we shall omit the proofs of our statements. All the proofs are available in the companion technical report [2].

Strongly bound processes
We now introduce a process calculus with name binders, building upon Basic Process Algebras (BPAs, [3]). Our calculus shares with BPAs the primitives for sequential composition, for non-deterministic choice, and for recursion (though with a slightly different syntax). Quite differently from BPAs, our atomic actions (called events) have a parameter, which indicates the resource upon which the action is performed. Resources r, r',... ∈ Res are system objects that can either be already available in the environment or be created at run-time. Resources can be accessed through a given finite set of actions α, α', new,... ∈ Act. The special action new represents the creation of a fresh resource: this means that for each dynamically created resource r, the event new(r) must precede any other α(r). 1 An event α(r) ∈ Ev abstracts from accessing the resource r through the action α. We also have events the target of which is a name n, n',... ∈ Nam, to be bound by an outer ν. Since the name binders are explicit in this calculus, we call its processes strongly bound, whose abstract syntax is given in Def. 2.1.
Definition 2.1 (Syntax of strongly bound processes)
P, Q	::=	ε	empty process
h	variable
α(ρ)	event (ρ ∈ Res ∪ Nam)
νn.P	resource binding
P · Q	sequential composition
P + Q	choice
μh.P	recursion
In a recursion μh.P , the free occurrences of h in P are bound by μ. In the construct νn. P , the ν acts as a binder for the free occurrences of the name n in
P . The intended meaning is to keep track of the binding between n and a freshly created resource. A process is closed when it has no free names and variables.
The behaviour of a strongly bound process is described by the set of sequential traces (typically denoted by η, η',... ∈ Ev∗) of its events. As usual, ε denotes the empty trace, and εη = η = ηε. The trace semantics P )op of a closed, strongly bound process P , is a function from finite set of resources to sets of traces (Def. 2.2).
We first introduce an auxiliary labelled transition relation P, R −→a  P ', R' (where
a ∈ Ev ∪ {ε} and R, R' ⊂ Res). The set R in configurations accumulates the

1 We conjecture this is a decidable property, e.g. suitably adapting the techniques of [10] should enable us to identify and discard those P that produce ill-formed traces where an α(r) comes before a new(r).

resources created at run-time, so that no resource can be created twice, e.g.
(νn. new(n)) · (νn. new(n)), ∅ −−−ε−→ new(r0) · (νn. new(n)), {r0}
new(r0)
−−−−−→  νn. new(n), {r0}
−−−/−→ new(r0), {r0}
The labelled transition relation is then exploited in the definition of P )op, which contains two kinds of traces. First, we include in P )op all the traces for terminating executions, i.e. those leading to ε. Then, we add all the prefixes of all executions, and mark these truncated traces with a trailing ! symbol. Here, we just let ! be a distinguished event not in Ev. Including these η! prefixes in P )op is useful, since they allow us to observe non-terminating computations.
Definition 2.2 (Trace semantics of strongly bound processes)


α(r),
α(r)
R −−→
ε, R∪ {r}	νn. P, R −→ε
P {r/n}, R∪ {r}	if r /∈ R 

ε · P, R −→ε
P, R	P · Q, R −→a
P ' · Q, R' if P, R −→a
P ', R'

P + Q, R −→ε
P, R	P + Q, R −→ε
Q, R	μh. P, R −→ε
P {μh. P/h}, R

The trace semantics  P )op(R) is then defined as

 P )op(R)= { η | P,

η
R −→
ε, R' }∪{ η! | P,

η
R −→
P ', R' }

Example 2.3 Consider the following strongly bound processes:
P0 = μh. α(r) · h	P1 = μh. h · α(r)	P2 = μh. νn. (ε + α(n) · h)
Then, P0)op(∅) = α(r)∗!, i.e. P0 generates traces with an arbitrary, finite number of α(r). Note that all the traces of P0 are non-terminating (as indicated by the !) since there is no way to exit from the recursion. Instead, P1)op(∅) = {!}, i.e. P1 loops forever, without generating any events. The semantics of P2)op(∅) consists of all the traces of the form α(r1) ··· α(rk) or α(r1) ··· α(rk)!, for all k ≥ 0 and pairwise distinct resources ri.	 
The denotational semantics P )s of a strongly bound process P is given below (Def. 2.5) as a function Y in a cpo Ds, which we define now. We first let D0 be
{ X ⊆ Ev∗ ∪ Ev∗! | ! ∈ X }, that is the cpo of sets X of traces such that ! ∈ X. Then we let Dh be the cpo Pfin (Res) ~ D0 (where ~ denotes partiality). Finally, Ds is the cpo (Nam → Res) → Dh Intuitively, P )s(χ)(R) contains all the possible traces of P . The first argument χ ∈ Nam → Res records the bindings between names and resources. The second argument R ∈ Pfin (Res) is a finite set of resources which indicates those already used, so to make them unavailable for future creations. As usual, the parameter θ binds the free variables of P (in our case, to values in Dh). Before giving the semantics, it is convenient to introduce some auxiliary defini-
tions that help in composing traces sequentially (see Def. 2.4 below).

The operator ⊙ ensures that all the events after a ! are discarded. For instance, the process P = (μh. h) · α(r) will never fire the event α(r), because of the infinite loop that precedes the event. The composition of the semantics of the first com- ponent μh. h is { !}, while the semantics of α(r) is { ! , α(r), α(r)!}. Combining the two semantics results in { !}⊙ { ! , α(r), α(r)!} = { !}.
The operator  takes two semantics and combines their traces sequentially. While doing that, it records the resources created, so to avoid that a resource is generated twice. For instance, let P = (νn. new(n)) · (νn'. new(n')). The traces of the right-hand side νn'. new(n') must not generate the same resources used in the left-hand side νn. new(n), e.g. new(r0)new(r0) is not a possible trace of P .
The definition of  exploits the auxiliary operator R, that computes the set of resources occurring in a trace η. Also, ↓∈ R(η) indicates that η is terminating, i.e. it does not contain any ! s.
Definition 2.4 Let X ∈ D0, and x ∈ Ev ∪{ !}. We define x ⊙ X and η ⊙ X as:


x ⊙ X =	{ xη | η ∈ X }	if x /=! 
{x}	if x =! 
(a1
··· an
) ⊙ X = a1
⊙ ··· ⊙ an ⊙ X

Given Y0, Y1 ∈ Ds, their composition Y0  Y1 is:
Y0  Y1 = λχ, R.	{ η0 ⊙ Y1(χ)(R∪ R(η0)) | η0 ∈ Y0(χ)(R) }
where R(η) is defined inductively as follows:
R(ε)= {↓}	R(η α(r)) = R(η) ∪ {r} if ! /∈ η	R(η ! η')= R(η) \ {↓}
Definition 2.5 (Denotational semantics of strongly bound processes)
 ε)s = λχ, R. { ! , ε}	 h)s = λχ, R. θ(h)(R)

θ
 α(ρ))s = λχ, R.  { ! , α(ρ), α(ρ)!}	if ρ = r
θ

 P · Q)s = P )s   Q)s



θ

 μh.P )s = λχ, R. 



i≥0
θ
 λZ. λR¯ . P )s
θ	θ	θ
(χ)(R¯) i(λR.{ !}) (R)

The semantics of an event α(r) comprises the possible “truncations” of {α(r)},
i.e. !, α(r)! and α(r) (notice that ! is always included in the semantics of all P , coherently with the definition of the trace semantics). The semantics of α(n) is similar, but it looks in χ for the resource associated with n. The semantics of νn. P joins the semantics of P , where the parameters R and χ are updated to record the binding of n with r, for all the resources r not yet used in R. The semantics of P · Q combines the semantics of P and Q with the operator . The semantics of P + Q is the least upper bound of the semantics of P and Q. The semantics of a recursion μh. P is the least upper bound of f i(λR.{ !}), where f (Z)= 

¯	s
θ{Z/h}
(χ)(R¯ ). Since f is continuous and λR.{ !} is the bottom element of

the cpo Dh, then f i(λR.{ !}) is an ω-chain, and its least upper bound is the least
fixed point of f .
The following theorem states that the denotational semantics of strongly bound processes is fully abstract with respect to their operational semantics.

Theorem 2.6 (Full abstraction) Let R be a ﬁnite sets of resources, and let ∅ be the empty mapping. Then, for all closed strongly bound processes P:

 P )op(R) =  P )s(∅)(R)


Weakly bound processes
In strongly bound processes, the ν-binders precisely define the scope of names. However, classical equational theories [11] for these processes usually allow binders to be floated out, towards the top-level, e.g. in P0 + νn. P1 = νn. P0 + P1, under the usual conditions. Indeed, the binder can always be brought outside a context, provided that 1) no recursion boundary is crossed, i.e. in μh. νn.P the binder cannot be moved outside, and 2) no name in the context is captured. Because of this, it is often convenient to define a normal form for processes, where all the binders are placed at their top-most position, i.e. at the top-level or just under a recursion. These are standard and well-known facts about process algebras.
One might wonder what information is actually carried by the presence of the ν-binders. From an operational point of view, we can see them as the points where resources are created. In our setting, this information is also carried by the new events. Therefore, it is interesting to study whether, under this assumption, we can neglect placing binders in our processes, and let the new events to define, at least in some loose way, the scope of names.
To this purpose, we now introduce weakly bound processes, which have no ν-binders (Def. 3.1). For instance, let p = new(n) · α(n)+ new(m) · α'(m). Here, the event new(n) binds the name n, while new(m) binds m. We shall later on define a semantics of weakly bound processes such that p is equivalent to the strongly bound process (νn.new(n) · α(n)) + (νm.new(m) · α'(m)), as the intuition suggests.
While weakly bound processes may make our reasoning more agile, we must not neglect that, unlike in the strongly bound case, weakly bound processes are possible where names have no clear scope. E.g., in new(n) · (new(n)+ ε) · α(n) it is not clear what binds the last occurrence of n. Roughly, these troublesome processes are those that can be derived from a strongly bound process by neglecting to α-convert some name while enlarging the scope of a ν-binder, yielding to unwanted name captures. We shall return to this point in Sect. 4.

Definition 3.1 (Syntax of weakly bound processes)

p, q	::=	ε	empty process
h	variable
α(ρ)	event (ρ ∈ Res ∪ Nam)
new(n)	resource creation
p · q	sequential composition
p + q	choice
μh.p	recursion

Free names in weakly bound processes have to be dealt with quite peculiarly, because of the absence of ν-binders. Consider e.g. p = p' · α(n). To tell whether n is free in p we have to inspect p'. For example if p' = new(n), we shall consider n as non-free; instead, if p' = ε, the name n is obviously free. Given p', we define which names are bound by p', so to extend the scope of the names of p' when it occurs at the left of another process, as in p' · p''. Non-determinism complicates matters: it might happen than a process p' binds a name to a resource only in some, but not all, of its execution, e.g. p' = new(n)+ ε. So, we define two sets of names, the must-bound names bn (p) and the may-bound names bno(p), for the names that are bound in every execution of p, and the names that are bound in some execution of p, respectively (see Def. 3.2). So, if p' = new(n)+ ε, we have bn (p')= ∅ and bno(p')= {n}. Note that the sets bn (p') and bno(p') can be seen as static approximations for the actual run-time bindings created by the process p'. Of course, bn (p) ⊆ bno(p). Note that no “weak” binding can escape a recursion, as real ν-binders cannot cross recursive contexts. So, in (μh. new(n) · h + ε) · α(n) the last n is free, and is unrelated to the new(n) event under the μh. Therefore, the bound names (both must and may ) of a recursion are empty.

Definition 3.2 (Must-bound names bn (p) and may-bound names bno(p))

bn  (ε)= bn  (h)= ∅	bn  (α(ρ)) =	{n}	if α = new and ρ = n
∅	otherwise
bn (p · q)= bn (p) ∪ bn (q)	bn (p + q)= bn (p) ∩ bn (q)	bn (μh. p)= ∅
  bn (p)	if p = ε, h, α(ρ), μh. p'

We can now define the free names fn(p) of a weakly bound process p. This is mostly standard, except that must-bound names are checked to single out captured names. The choice of using must-bound names instead of may-bound names is done so that, e.g. in p = (new(n)+ ε) · α(n) we consider n as free. This has the nice property that, whenever fn(p)= ∅, in no execution of p we will attempt to fire an event α(n) without a proper binding for n.

Definition 3.3 (Free names fn(p))

fn(h)= ∅	fn(α(ρ)) =	{n}	if ρ = n and α /= new
∅	otherwise


fn(μh. p)= fn(p)

fn(ε) = ∅	fn(p · q)= fn(p) ∪ (fn(q) \ bn (p))	fn(p + q)= fn(p) ∪ fn(q)
We now define a denotational semantics of weakly bound processes. Unlike in the case of strongly bound processes, where the result of the semantics was a set of event traces, here we also need to keep track of the bindings generated by the new events. We shall then use sets of pairs (η, χ) instead of sets of traces η. Note that this difference – the extra χ – between the semantic domains for the strongly/weakly bound processes is exactly the same difference between the classic domains for programming languages with static/dynamic scoping.
As we did with strongly bound processes in Def. 2.4, we introduce the auxiliary operators ⊙ and  to handle sequential composition.
The operator ⊙ merges two pairs (η, χ), so ensuring that all the events after a ! are discarded, as well as the bindings created after the !. For example, (η!, χ) ⊙ (η', χ') = (η!, χ), discarding both η' and χ'. Here we also use two cpos, D1 and Dw, to play the role of D0 and Ds used for strongly bound processes. We let D1 be the cpo of sets X of pairs (η', χ') such that there exists a pair in X with η' =!. Formally, D1 is the cpo { X ⊆ (Ev∗ ∪ Ev∗ !) × (Nam → Res) | ∃χ'. (!, χ') ∈ X }.
Definition 3.4 Let a ∈ Ev ∪{ !}, X ∈ D1, (η, χ), (η', χ') ∈ X. We define ⊙ as:
(a, χ) ⊙ (η', χ')=	(a, χ)	if a =! 
(aη', χ')	otherwise
(η, χ) ⊙ (η', χ')= (a1, χ) ⊙ ··· ⊙ (ak, χ) ⊙ (η', χ') if η = a1 ··· ak
(η, χ) ⊙ X = { (η, χ) ⊙ (η¯, χ¯) | (η¯, χ¯) ∈ X }

The operator  takes two semantics Y0 and Y1 and combines their traces se- quentially. In Y0  Y1 the bindings (i.e. the χ) generated by Y0 are passed to Y1, so that e.g. new(n) · α(n) works as expected.
Definition 3.5 Let Dw = (Nam → Res) → Pfin (Res) ~ D1 be the cpo of functions from functions from names to resources, to the finite subsets of Res to D1 (where
~ denotes partiality). Given Y0, Y1 ∈ Dw, their composition Y0   Y1 is:
Y0  Y1 = λχ, R.  { (η0, χ0) ⊙ Y1(χ0)(R∪ R(η0)) | (η0, χ0) ∈ Y0(χ)(R) }
The denotational semantics  p)w of a weakly bound process p is defined as a
function Y ∈ Dw, where we assume that Y (χ)(R) is defined only if R ⊇ ran (χ). The parameter θ is a mapping from the free variables h of p to Dh.
Definition 3.6 (Denotational semantics of weakly bound processes)

The semantics  p)w is inductively defined through the following equations, where
set χI = { (η, χ) | η ∈ I }.

 ε)w = λχ, Y. set χ{ ! , ε}	 h)w = λχ, Y. set χθ(h)(Y)

θ



 α(ρ))w = λχ, Y.
θ
set χ{ ! , α(ρ), α(ρ)!}	if ρ = r
set χ{ ! , α(χ(n)), α(χ(n)) !}	if ρ = n ∈ dom (χ)

⎪⎪⎩{(! , χ)} ∪ 

r/∈Y
set	{α(r), α(r)!}	if ρ = n /∈ dom (χ)
and α = new

 p · q)w =  p)w   q)w	 p + q)w = p)w H q)w
θ	θ	θ	θ	θ	θ

 μh.p)w = λχ, Y. set χ  λZ.λY¯ . fst ( p)w

(χ|
o	)(Y¯ )) i(λY.{ !}) (Y)


The semantics above is similar to the one for strongly bound processes, so we just comment on the differences. First, each trace η has now been bundled with its generated bindings χ. Related to this, now the new(n) event creates the actual binding, which augments the χ at hand. Note that we assume the operators ∪ and H to be undefined when one of the arguments is undefined. This must hold also for ⊙ and  , so making e.g. the semantics of (new(n)+ ε) · α(n) undefined when n /∈ dom (χ), since in one branch α(n) is evaluated without a proper binding for n. The semantics of recursion variables h is peculiar. First, note that we chose the semantics parameter θ so that θ(h) is an element of Dh and not of Dw. This is because, when recursion is involved, the bindings of names must not be propagated: this is strictly related to the fact that ν-binders cannot cross a recursive context in strongly bound processes. For example, in the strongly bound process μh. νn. P ·h·P ' there is no way for the resource bound to n to be “passed” to the inner “call” to h; similarly, if the inner “call” generates a binding, it cannot be “returned” so to interfere with P '. Of course, this would change if we allowed a more complex form of recursion where h can take a resource as an argument. Returning to the semantics of h, since θ(h) ∈ Dh needs no χ, then it suffices to pass it an Y, and then augment
the returned set of traces with χ. This is accomplished by the set χ function.
The semantics of the recursion μh. p is quite similar to the one for strongly bound processes. For the reasons explained above, we compute a fixed point over Dh and not Dw. This means that we have to adapt the semantics of p, which is in Dw, to a function in Dh. More concretely, we just need to provide χ to  p)w and ignore the χ returned by it. The latter is done by a trivial left projection, the fst in the actual formula. The χ we pass, instead, is the top-level χ – the one provided to the whole recursive process – after the bindings which affect bno(p) have been filtered out. This filtering is needed to prevent name confusion e.g. in new(n) · (μh. new(n) · p), where the outer n is unrelated to the inner one. Aside from this, the fixed point is computed exactly as for the strongly bound processes, exploiting the continuity of
f (Z)= λY¯ . fst ( p)w	(χ')(Y¯ )).

Bindifying weakly bound processes
To make precise the scope of names in weakly bound processes, we shall translate them into strongly bound processes, through the transformation bindify (Def. 4.3). This transformation will insert the ν-binders at the right points, provided that the introduced scopes of names do not interfere dangerously. We shall call well-bound those weakly bound processes that can be safely translated into strongly bound ones. To help the intuition, we shall first give some examples.
Example 4.1 Consider the weakly bound processes:
p1 = new(n) · new(n) · α(n)	p2 = α(n) · new(n)	p3 = new(n)+ α(n)
p4 = (ε + new(n)) · α(n)	p5 = μh.new(n).h
p6 = new(n) · (μh. (ε + new(n) · h)) · α(n)
The processes p1, p2, p3, p4 are not well-bound. If p1 were such, its bindification would either be νn. new(n)·(νn. new(n))·α(n)– where α is performed on the resource generated by the outer ν-binder – or νn. new(n) · (νn. new(n) · α(n)) – where α acts on the resource of the inner binder. Because of this possible ambiguity, we treat p1 as not well-bound. The process p2 is not well-bound, too, because it would produce an ill-formed trace α(r)new(r) where the event α(r) is fired before the event new(r) that signals the creation of r. Similarly, the process p3 is not well-bound, because its bindification would give rise to the ill-formed trace α(r). The process p4 is not well- bound, because choosing the branch ε would lead to a similar situation. Observe that the denotation of p1 contains the non-sense trace new(r)new(r)α(r), while the semantics of p2, p3 and p4 are undefined, because  and H are strict. Finally, the process p5 is well-bound: it loops over new(n), generating a fresh resource at each iteration. Also, p6 is well-bound, because the μ-binder clearly separates the scope of the outer new(n) from that of the inner one.	 
The following definition formalizes when a process is well-bound. The empty process, variables and events are well-bound. A recursion is well-bound when its body is such. A choice p + q is well-bound when both p and q are well-bound. Additionally, we require that the may-bound names of p are disjoint from the free names of q, and viceversa (e.g. new(n)+ α(n) is not well-bound). A sequence p · q is well-bound when both p and q are well-bound, and furthermore (i) the may-bound names of q are disjoint from the names of p (e.g. α(n) · new(n) and new(n) · new(n) are not well-bound), and (ii) the free names of q are either must-bound in p, or they are not may-bound in p (e.g. (ε + new(n)) · α(n) is not well-bound).
Definition 4.2 (Well-bound processes) A weakly bound process p is well-bound
when wb(p), defined inductively as:
wb(ε)= wb(h)= wb(α(ρ)) = true	wb(μh. p) if wb(p)
wb(p + q) if wb(p), wb(q), bno(p) ∩ fn(q)= bno(q) ∩ fn(p)= ∅
wb(p · q) if wb(p), wb(q), bno(q) ∩ (bno(p) ∪ fn(p)) = (bno(p) \ bn (p)) ∩ fn(q)= ∅

We now introduce the bindify transformation, which is defined on well-bound processes only. The may-bound names are lifted to the leftmost position of the bindified process, and they are placed within the scope of a ν-binder. In the case of a recursion μh. p, the may-bound names of p are lifted to the leftmost position within the recursion, i.e. they do not escape the scope of the μh.
Definition 4.3 (Bindification) If wb(p), the bindification bindify(p) of p is a strongly bound process, defined as:
bindify(p)= ν bno(p). β(p)
where the auxiliary operator β is defined inductively as follows:

Example 4.4 Recall from Sect. 1 the process p = new(n) · α(n)+ new(m) · α(m). It is easy to check that p is well-bound, and that its may-bound names are:
bno(p)= bno(new(n) · α(n)) ∪ bno(new(m) · α(m)) = {n, m}
Then the bindification of p is the strongly bound process:
bindify(p) = νn.νm.(new(n) · α(n)+ new(m) · α(m))
Example 4.5 Recall the process p5 = new(n) · (μh. (ε + new(n) · h)) · α(n) from Ex. 4.1. It is easy to check that p5 is well-bound. Its may-bound names are:
bno(p5)= bno(new(n)) ∪ bno(μh. (ε + new(n) · h)) ∪ bno(α(n)) = {n}∪∅ = {n}
The bindification of p5 is then computed as follows:
bindify(p )= νn. β new(n) · (μh. (ε + new(n) · h)) · α(n)
= νn. β(new(n)) · μh. bindify(ε + new(n) · h) · β(α(n))
= νn. new(n) · (μh. νn. β(ε + new(n) · h)) · α(n)
= νn. new(n) · (μh. νn. (ε + new(n) · h)) · α(n)
We now state the correctness of bindification (Theorem 4.6). The “strong” seman- tics of bindify(p) contains exactly the traces of the “weak” semantics of p.
Theorem 4.6 For all closed, weakly bound processes p such that wb(p),  p)w(∅)(∅)

is deﬁned, and:
 bindify(p))s(∅)(∅) = fst ( p)w(∅)(∅))

$	$
Equational theories and trace inclusion
In this section we provide strongly bound and weakly bound processes with an equational theory and a trace inclusion preorder. We shall state their correctness,

i.e. the equational theory preserves the set of traces, while the preorder preserves their inclusion. Finally, we shall highlight some differences between the two calculi.
We first give in Def. 5.1 an equational theory of strongly bound processes.
Definition 5.1 (An equational theory of strongly bound processes) The relation = over strongly bound processes is the least congruence including α-conversion of names and variables such that:
P + P = P	(P + P ')+ P '' = P + (P ' + P '')	P + P ' = P ' + P
(P · P ') · P '' = P · (P ' · P '')	ε · P = P = P · ε
(P + P ') · P '' = P · P '' + P ' · P ''	P · (P ' + P '')= P · P ' + P · P ''
μh.μh'.P = μh'.μh.P	μh.P = P {μh. P/h}	νn.ε = ε
νn.νn'.P = νn'.νn.P	νn.(P + P ')= (νn.P )+ P ' if n /∈ fn(P ')
νn.(P · P ')= P · (νn.P ') if n /∈ fn(P )	νn.(P · P ')= (νn.P ) · P ' if n /∈ fn(P ')
The operation + is associative, commutative and idempotent; · is associa- tive, has identity ε, and distributes over +. The binders μ and ν allow for α- conversion of bound names and variables, and can be rearranged. A μh can be introduced/eliminated when h does not occur free. A νn can be extruded when it does not bind a free occurrence of n. A μh. P can be folded/unfolded as usual.
As expected, the equational theory above is not complete, e.g. P )s = P ')s does not imply P = P '. E.g., μh. α(r) · h cannot be equated to μh. α(r) · α(r) · h, yet they have the same traces α(r)∗ !. However, the equational theory is sound w.r.t. our semantics, as established by the first item Theorem 5.3 below.
We then define a preorder P ≤ Q betweeen strongly bound processes. The preorder ≤ includes equivalence, and it is closed under contexts. Also, a strongly bound process P can be arbitrarily “weakened” to P + Q.
Definition 5.2 (A trace inclusion preorder of strongly bound processes)
The relation ≤ over strongly bound processes is the least precongruence such that:
P ≤ Q	if P = Q	P ≤ P + Q
The following theorem states that the equational theory = and the preorder ≤
agree with the semantics of strongly bound processes.
Theorem 5.3 For all closed, strongly bound processes P and Q:
if P = Q, then  P )s = Q)s.
$	$
if P ≤ Q then  P )s(χ)(Y) ⊆  Q)s(χ)(Y), for all Y and χ.
$	$
We now consider how to express an equational theory and a trace inclusion preorder for weak binders, in the same spirit of Def. 5.1 and Def. 5.2. In spite of their weaker structure, weakly bound processes still share many semantic-preserving equational properties with strongly bound processes, as summarized in Def. 5.4.

Notably, the equations involving + and · are identical with respect to Def. 5.1. The recursions μh can be rearranged, as before. Of course, here we do not have ν-binders, so the α-conversion of bound names can not be done, in general. As an important exception, we know that bound names inside a recursion can not escape, so their scope is completely known. In this case, we allow for α-conversion. Note that unfolding recursions is not allowed, otherwise we would have μh.new(n) · h ≈ new(n)·(μh.new(n)·h) ≈ new(n)·new(n)·(μh.new(n)·h), so causing name confusion
— indeed, the first two processes are well-bound, while the last one is not. As with strong binders, the equational theory below is not complete, yet it is sound w.r.t. the
 −)w semantics, as established by the first item of Theorem 5.7.
Definition 5.4 (An equational theory of weakly bound processes) The re- lation ≈ over weakly bound processes is the least congruence including α-conversion of variables such that:
p + p ≈ p	(p + p')+ p'' ≈ p + (p' + p'')	p + p' ≈ p' + p	ε · p ≈ p ≈ p · ε (p · p') · p'' ≈ p · (p' · p'')	(p + p') · p'' ≈ p · p'' + p' · p''	p · (p' + p'') ≈ p · p' + p · p'' μh.μh'.p ≈ μh'.μh.p	μh.p ≈ μh.(p{m/n}) if n ∈ bno(p) and m /∈ p
Example 5.5 The equational theories shown above offer an opportunity to com- pare strong ν-binders with weak new binders. Consider the following equation: new(n) · p + new(n) · q ≈ new(n) · (p + q). This is a trivial fact, since it di- rectly follows from the distributive law. Its equivalent for strongly bound processes, (νn. P )+(νn. Q)= νn. (P + Q), appears instead to be non trivial. Indeed, although Def. 5.1 comprises all the classic equations for ν-binders, the mentioned equation can not be derived from them, since we can not identify the two binders. Yet, in most process algebras, we expect the equation to be sound w.r.t. any reasonable process equivalence relation. So, in this case weak binders offer a simpler view.
We shall now introduce a preorder p N q on weakly bound processes. Here, we use a set of names N as an index to the preorder relation. This index is needed to avoid name confusion, as we shall see below. When p N q holds, then the semantics of p is included in that of q (second item of Theorem. 5.7).
Definition 5.6 (A trace inclusion preorder of weakly bound processes)
The relation  N over weakly bound processes is the least preorder such that:
p  $ q	if p ≈ q	p  $ p + q	p  N ∪N ' p''	if p  N p' and p'  N ' p''
C(p)  N C(q)	if p  N q and N ∩ (bno(C) ∪ fn(C)) = ∅
pσ{μh. p/h}  ran (σ) μh. p	if ran (σ) ∩ fn(p)= ∅
where C = p · • | • · p | p + • | • + p is a context, σ : Nam → Nam is an injective function with dom (σ)= bno(p), and pσ{μh. p/h} is capture-avoiding.
The preorder N includes ≈-equivalence (Def. 5.4). A process p can be arbi- trarily “weakened” to p + q. The relation is closed under contexts, provided that

the names in N are disjoint from those in the context. Note that, because of this side condition, N is not a precongruence, unlike ≤ for strongly bound processes. Folding/unfolding is possible, but in a weaker form than in Def. 5.1. To avoid name confusion and preserve well-boundness, the unfolded names must be fresh. For in- stance, if p = μh. new(n) · α(n) · h, then we shall have new(n') · α(n') · p  {n'} p. The name n' in {n'} is needed to avoid name clashes. For instance, it prevents from using the previous unfolding in the context C = •·α'(n'), since the extruded new(n') would bind the name n' in α'(n'), as checked by the context rule above. The side condition on the rule for folding/unfolding is needed to ensure that all the processes smaller (w.r.t. ) than a well-bound process are well-bound (Theorem 5.8). Omit- ting the disjointness condition between fn(p) and the range of the substitution σ would lead to situations like α(n')· new(n')  {n'} μh. α(n')· new(n), where the right- hand side is well-bound, while the left-hand side is not. Substitutions of names must be coherent with bindification, i.e. they must not affect names that would be put under a ν-binder by β(−), e.g. (new(n) · μh. new(n)){m/n} = new(m) · μh. new(n). Similarly, substitutions can trigger α-conversions to avoid name captures, e.g. (μh. new(m) · α(n)){m/n} = μh. new(m') · α(m).
We now formally state that our syntactic preorder agrees with the semantics of weakly bound processes, as it yields trace inclusion. Note that trace inclusion requires the two semantics to be defined. Otherwise we have new(n) · μh. α(n) $ new(n) · μh. (new(n)+ ε) · α(n): when the branch ε is chosen in the right-hand side, we find χ'(n)= χ|dom(χ)\{n}(n), so α(n) cannot be evaluated, and the whole semantics is undefined (while the semantics of the left-hand side is always defined). Note however that is q is well-bound, then also p is such (Theorem 5.8), and so by Theorem 4.6 both the semantics are defined.
Theorem 5.7 For all closed, weakly bound processes p and q:
if p ≈ q, then  p)w = q)w.
$	$
if p  N q and, then fst ( p)w(χ)(Y)) ⊆ fst ( q)w(χ)(Y)), for all Y and χ such
$	$
that dom (χ) ∩N = ∅ and both the semantics are deﬁned.
The projection fst in the statement above is necessary. Consider e.g. p = new(n) {n} μh. new(m) = q. Here, the semantics of p and q agree on the η components, i.e. the truncations of new(r) with r /∈ Y, but p will augment χ with the new binding {r/n}, unlike q which does not affect χ.
The next theorem guarantees that bindify is well-defined, i.e. it maps
≈-equivalent weakly bound processes to =-equivalent strongly bound processes. Moreover, processes smaller (w.r.t.  N ) than well-bound processes are well-bound.
Theorem 5.8 For all weakly bound processes p and q:
if p ≈ q, then wb(p) if and only if wb(q).
if p ≈ q and wb(p), then bindify(p)= bindify(q).
if p  N q and wb(q), then wb(p).

Conclusions

We have investigated weak binders – a construct for fresh name generation – as an alternative for ν-binders in nominal calculi. Weak binders allow for a looser reasoning, while still admitting a trace-preserving translation into strong binders. However, this comes at a cost: often, useful properties, e.g. trace inclusion (Th. 5.7), require more side conditions to be checked for ensuring sanity. Also, α-conversion of names can only be applied inside μ-binders. This is possible through the last rule of the equational theory in Def. 5.4. An alternative would be to always consider weakly bound processes modulo α-conversion within the μ-binders, at the cost of making some proofs (e.g. those that do not depend on ≈) more complex. A further downside of weak binders is that compositionality is reduced, since e.g. wb(p) and wb(q) do not automatically imply wb(p · q) which – if needed – must be established by exploiting further assumptions on the names of p and q. Future work would address the use of weak binders in other process calculi. Indeed, we expect that weak binders enjoy stronger properties in calculi without sequential composition (e.g. CCS [11]). Moreover, studying some relaxed variants of well-boundness could improve the applicability of weak binders.
In our experiments with weak binders, we also found they sometimes lead to intricate proofs, since particular care must be exercised with corner cases. For in- stance, handling recursion in an operational semantics for weakly bound processes seems to be quite complex. Indeed, na¨ıve unfolding causes name confusion, so one has to resort to either renaming all bound names so that they are indeed globally fresh, or to record the “call frames” (entering/leaving the body of a recursion) in a stack. Since we need to keep track of this, run-time configurations become more complex, and we found our operational semantics (not presented in this paper) to be too inconvenient to be used in proofs. Even when using the denotational seman- tics (Def. 3.6), we felt that writing inductive statements for weak binders required more trial-and-error steps, w.r.t. strong binders. However, in some occasions weak binders may become a more agile tool. For instance, they can be exploited to im- plement a type and effect inference algorithm for a calculus with side effects and explicit name binders (like [1]), on top of an existing algorithm for a calculus without binders. Each time a ν-binder is encountered, a fresh name is generated, similarly to fresh type variables in Hindley-Milner type inference. After solving the obtained type and effect constraints through unification, the resulting effect is bindified. Of course, this is not always possible, e.g. when the effect is not well-bound. Possible counter-measures consist in suitably extending let-polymorphism to ν-binders.
Related work. A number of formal techniques have been developed to handle bind- ing and freshness of names. The permutation model of sets introduced by Fraenkel- Mostowski has led to an elegant and powerful mathematical theory of naming [8]. The key observation of this approach is that α-conversion, binding and freshness can be defined through name permutations (or swappings). For instance, the freshness axiom for a name of a computational entity (i.e. an object, a process, a context, etc.) is expressed by saying that the fresh name does not belong to the support of

the computational entity. Notably, in the permutation model the support of com- putational entities is ﬁnite. This mathematical theory has been used to model early and late semantics of the π-calculus [9]. Also, it has driven the design of a func- tional language, FreshML [20], which includes primitive mechanisms for handling fresh bindable names. In FreshML freshness is managed by a gensym() primitive to dynamically generate names, and a primitive for permuting names. Our notion of weakly bound processes exploits the gensym() primitive without resorting to α-conversion. Indeed, the bindify trasformation singles out the names in the finite support of a weakly bound process. A monadic denotational semantics for FreshML has been used to handle freshness through a continuation monad on FM-sets [19]. This semantics allows for translating the usual domain-theoretic results in the con- text of FM-sets, and to use them to prove freshness-related properties. There is also a cost associated to α-converting names [7,15] which could be reduced e.g. by compiling strong binders into weak binders.
The λν-calculus presented in [16] extends the pure λ-calculus with names. In contrast to λ-bound variables, nothing can be substituted for a name, yet names can be tested for equality. Reduction in λν is confluent, and it allows for deterministic evaluation. Furthermore, all the observational equivalences that hold in the pure λ- calculus still hold in λν. This has the practical consequence that all the equational techniques for transforming and verifying pure functional programs are also appli- cable to programs with local names. Nominal techniques have been implicitly used for reasoning about the semantics of functional languages with local state in [17], to prove when two functional programs are equivalent in every evaluation context. Binding and freshness of names have been a main concern in process calculi.
History-Dependent automata [13,14] provide an automata-based model where states are equipped with name permutations to manage freshness and garbage collections of names. They automatically manage the creation and deallocation of names, while allowing for a compact representation of the system behaviour, by collapsing the states that only differ for the renaming of local names. The π-calculus is extended in [4] with an operational model where names are localized to their owners; each sequential process has its logical space on names and a local manager generates fresh names whenever necessary.

References
M. Bartoletti, P. Degano, G. L. Ferrari, and R. Zunino. Types and effects for resource usage analysis. In Foundations of Software Science and Computation Structures (FOSSACS), 2007.
M. Bartoletti, P. Degano, G. L. Ferrari, and R. Zunino. Hard life with weak binders. Technical Report TR-08-13, Dip. Informatica, Univ. Pisa, 2008.
J. A. Bergstra and J. W. Klop. Algebra of communicating processes with abstraction. Theoretical Computer Science, 37:77–121, 1985.
C. Bodei, P. Degano, and C. Priami. Names of the π calculus agents handled locally. Theoretical Computer Science, 253(2):155–184, 2001.

M. Bravetti and G. Zavattaro. Towards a unifying theory for choreography conformance and contract compliance. In Software Composition, 2007.

G. Castagna, N. Gesbert, and L. Padovani. A theory of contracts for web services. In ACM SIGPLAN- SIGACT Symposium on Principles of Programming Languages (POPL), 2008.
M. Fern´andez, I. Mackie, and F.-R. Sinot. Closed reduction: explicit substitutions without α-conversion.
Math. Structures Comput. Sci., 15(2):343–381, 2005.
M. Gabbay and A. M. Pitts. A new approach to abstract syntax with variable binding. Formal Asp. Comput., 13(3-5):341–363, 2002.
M. J. Gabbay. The pi-calculus in FM. In F. Kamareddine, editor, Thirty-five years of Automath, volume 28 of Applied Logic Series, pages 247–269. Kluwer, 2003.
A. Igarashi and N. Kobayashi. Type reconstruction for linear -calculus with i/o subtyping. Inf. Comput., 161(1):1–44, 2000.
R. Milner. Communication and concurrency. Prentice-Hall, Inc., 1989.
R. Milner, J. Parrow, and D. Walker. A Calculus of Mobile Processes, I and II. Information and Computation, 100(1):1–40,41–77, September 1992.
U. Montanari and M. Pistore. An introduction to history dependent automata. Electr. Notes Theor. Comput. Sci., 10, 1997.
U. Montanari and M. Pistore. Structured coalgebras and minimal hd-automata for the π-calculus.
Theor. Comput. Sci., 340(3):539–576, 2005.
M. Norrish and R. Vestergaard. Proof pearl: De bruijn terms really do work. In TPHOLs, pages 207–222, 2007.
M. Odersky. A functional theory of local names. In ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL), 1994.
A. M. Pitts and I. D. B. Stark. Operational reasoning for functions with local state. Higher order operational techniques in semantics, pages 227–274, 1998.
D. Sangiorgi and D. Walker. The π-Calculus: a Theory of Mobile Processes. Cambridge University Press, 2002.
M. R. Shinwell and A. M. Pitts. On a monadic semantics for freshness. Theoretical Computer Science, 342(1):28–55, 2005.
M. R. Shinwell, A. M. Pitts, and M. Gabbay. FreshML: programming with binders made simple. In
International Conference on Functional Programming (ICFP), 2003.

Appendix: strongly bound processes
This appendix contains a number of intermediate definitions and lemmata that are necessary to prove Theorem 2.6. All the detailed proofs are in [2].
Remark A.1 To simplify the proof of full abstraction, hereafter we shall extend strongly bound pro- cesses with the process ! , that models a non-terminated computation. The labelled transition system in Def. 2.2 is enriched with the following rule, that allows for observing the finite prefixes of non-terminating computations:

P, Y −→!
! , Y

The trace semantics P )op(Y) is then defined as follows:


 P )op(Y) = { η | P,
η
Y −→
ε, Y' }∪{ η ! | P,
η !
Y −−→
Q, Y' and ! /∈ η }

Lemma A.2 For all strongly bound processes P and for all Y, if η ∈ P )op(Y) and ! ∈ η, then η = η' !
for some η' such that ! /∈ η'.
We now define the function R(P ), that computes the set of resources mentioned in P and reachable in some computations of P . To do that, R(P ) performs a sort of reachability analysis, e.g. R(α(r)·(μh. h)·α(r')) contains r but not r', since the non-terminaing loop μh. h makes α(r') unreachable. Having ↓∈ R(P ), means that P allows for some terminating computations. The function T(P ) defined below exploits this fact to characterize the processes that may terminate.
Definition A.3 For all strongly bound processes P and for all functions Θ from variables h to Res ∪ {↓}, we define RΘ(P ) inductively as follows:

RΘ(ε)= {↓}	RΘ(! ) = $	RΘ(h)= Θ(h)	RΘ(νn. P )= RΘ(P )


R (α(ρ)) = {r, ↓}  if ρ = r	R
{↓}	otherwise
(RΘ(P ) \ {↓}) ∪ RΘ(Q)  if ↓∈ RΘ(P )
RΘ(P )	otherwise


RΘ(P + Q)= RΘ(P ) ∪ RΘ(Q)	RΘ(μh. P )= R	(P )

Also, we define TΘ(P ) as follows:
TΘ(P ) = {↓} ∩ RΘ(P )
Example A.4 Let P = μh. νn. h · α(r)+ α(n). Since T{∅/h}(νn. h · α(r)+ α(n)) = T{∅/h}(h · α(r)) ∪
T{∅/h}(α(n)) = {↓} and ↓∈ R{{↓}/h}(h)= {↓}, we have that:

R∅(P )= R{T	(νn. h·α+α(n))/h}(νn. h · α(r)+ α(n))
= R{{↓}/h}(νn. h · α(r)+ α(n))
= R{{↓}/h}(h · α(r)) ∪ R{{↓}/h}(α(n))
= R{{↓}/h}(h) ∪ R{{↓}/h}(α(r)) ∪ {↓}
= {↓, r}
Lemma A.5 For all P and Θ, we have that TΘ(P ) equals to:

{↓}	if P = ε or P = α(ρ)
{↓} ∩ Θ(h)	if P = h
$	if P =! 
TΘ(Q)	if P = νn. Q
TΘ(P0) ∩ TΘ(P1)	if P = P0 · P1
TΘ(P0) ∪ TΘ(P1)	if P = P0 + P1
T	(Q)	if P = μh. Q

The following lemma proves some basic facts about R and T.
Lemma A.6 For all P , h, Y, Y', Θ, and for all χ : Nam → Res:

(A.6a)
(A.6b)
(A.6c)
(A.6d)
(A.6e)
(A.6f)
(A.6g)
Y ⊆ Y' =⇒ T	(P ) ⊆ T	'	(P )
Θ{TΘ(h)/h}
Θ{TΘ{∅/h}(P )/h}	Θ{∅/h}
Y ⊆ Y' =⇒ R	(P ) ⊆ R	'	(P )
RΘ(P ) ⊆ RΘ(P χ) ⊆ RΘ(P ) ∪ ran (χ)
RΘ(P ) ⊆ R	(P ) ∪ Θ(h)
RΘ(μh. P )= RΘ{RΘ(μh. P )/h}(P )

The following lemma states two basic properties of the trace semantics. The first item guarantees that the freshly created resources are disjoint from Y. The second item shows that the trace semantics is antimonotonic w.r.t. R.
Lemma A.7 For all closed strongly bound processes P :

(A.7a)
(A.7b)
η ∈ P )op(Y) =⇒ (Y\ R∅(P )) ∩ R(η)= $
Y ⊆ Y' =⇒ P )op(Y) ⊇ P )op(Y')

We study below how the trace semantics is affected by adding/removing resources from Y, and by substi- tuting a resource for a name.
Lemma A.8 For all strongly bound processes P and P ':

(A.8a)
η
P, Y −→
P ', Y' =⇒ P, Y\ {r
η
} −→
P ', Y' \ {r} if r ∈ Y \ R(η)

(A.8b)
η
P, Y −→
P ', Y' =⇒ P, Y∪ {r
η
} −→
P ', Y' ∪ {r} if r /∈ Y'

(A.8c)
η
P {r/n},	ε, Y' =⇒ P {r'/n},
η ε, Y' if r /∈ R(η)

(A.8d)
Y −→η
P {r/n},
ε, Y' =⇒ P {r'/n}, Y −→'	η ε, Y'{r'/r} if r'/∈ R(η' ),

Y −→
Y{r /r} −→
r /∈ Y 

The following lemma relates the labelled transition relation with the trace semantics.
Lemma A.9 For all strongly bound processes P, P ':


P, Y −→a
P ', Y' =⇒ P )op(Y) ⊇ a ⊙ P ')op(Y')


We now introduce a further denotational semantics −)sub of strongly bound processes. The main difference from −)s of Def. 2.5 is the way the two semantics handle the case νn. P . In νn. P )s, the freshly created resource r is used to extend the environment χ with the binding {r/n}. Instead, in νn. P )sub the substitution {r/n} is performed directly on P — hence the environment χ can be omitted. Since substitutions are also used by −)op, in the proof of full abstraction we shall conveniently use −)sub as a bridge between −)op and −)s.
Definition A.10 (Substitution semantics of strongly bound processes)
The substitution semantics P )sub of a strongly bound process P such that fn (P )= $ is defined below. Let
θ	∗
D0 be the following cpo of sets of traces ordered by set inclusion: D0 = { X ⊆ (Ev ∪{ ! }) | ! ∈ X ∧ ∀η ∈
X : η ! ∈ X }. The set { ! } is the bottom element of D0. Then, let Dsub = Pfin (Res) → D0 be the cpo of functions from the finite subsets of Res to D0. Note that the bottom element ⊥ of Dsub is λY. { ! }. Then, the semantics of P (parametrized by θ) is a function in Dsub. The parameter θ is a function that maps each variable h to a function in Dsub. We require dom (θ) ⊇ fv (P ). The semantics P )sub is inductively
defined through the following equations.
 ε)sub = λY. { ! , ε}
 α(ρ))sub = λY. { ! , α(ρ), α(ρ)! }  if ρ ∈ Res
 νn. P )sub = λY. Sr/∈R  P {r/n})sub(Y∪ {r})
θ	θ
 P · P ')sub = P )sub  P ')sub
θ	θ	θ
 P + P ')sub = P )sub H P ')sub
θ	θ	θ
 !)sub = ⊥
 h)sub = θ(h)
 μh.P )sub = G f i(⊥) where f(Y )= P )sub

θ
i≥0
θ{Y/h}


We first check that the above semantics is well-defined. Lemma A.11 proves that the image of the semantics function is indeed D0. Lemma A.14 guarantees that the least upper bound in the last equation exists (since f is monotone). Also, since f is continuous, by the Knaster-Tarski theorem the semantics of μh. P is the least fixed point of f.
Lemma A.11 For all strongly bound processes P , for all θ and Y, ! ∈ P )sub(Y).

Lemma A.12 The structure (Dsub, H, , id H, id  ), where id H = ⊥ and id  = λY.{ ! , ε} is a semi-ring.

Lemma A.13 Let {Yi}i and {Zi}i be subsets of Dsub. Then:
G (Yi  Zi) = `G Yi´  `G Zi´
Lemma A.14 For all strongly bound processes P such that fn (P )= $, and for all θ such that dom (θ) ∪

{h} ⊇ fv (P ), the function fP (Y )= P )sub
is continuous.

Lemma A.15 We say Y ∈ Dsub anti-monotone when Y ⊆ Y' implies Y (Y) ⊇ Y (Y') for all Y, Y'. For all P and anti-monotone θ, P )sub is anti-monotone.
Definition A.16 For all Y ∈ Dsub, we define R(Y ) and T(Y ) as follows:
R(Y )=	R(Y (Y))	T(Y )= {↓} ∩ R(Y )
Y
Here we state that T correctly characterizes termination.
Lemma A.17 For all Y ∈ Dsub:
T(Y )= $	if ∀Y : η ∈ Y (Y) =⇒ ! ∈ η
{↓}  otherwise
Remark A.18 The function R is not continuous. For instance, take a set of distinct resources {ri}i∈ω. Let {Yi}i∈ω a family of functions in Dsub, defined as Yi = λY. { α(rk) | k > |Y| − i } where |Y| denotes the cardinality of the finite set Y. This family is actually an ω-chain, since k > |Y| − i implies k > |Y| − (i + 1). However, it is easy to check that R( i Yi)= { rk | k ∈ ω } while i R(Yi)= $.
The following lemma provides an alternative definition of R(Y ), in terms of R(η).
Lemma A.19 For all monotone non-increasing Y , and for all ω-chain {Yi}i such that Si Yi = Res:
R(Y ) = \ [ { R(η) | η ∈ Y (Yi) }
Termination is not affected by the particular choice of Y.
Lemma A.20 For all Y ∈ Dsub and for all Y, T(Y )= T(Y (Y)).
We now state the correspondence between the syntactic and semantic variants of R.
Lemma A.21 For all strongly bound processes P with fn (P )= $:
R( P )sub)= RR(θ)(P )
for all θ such that: ∀Y ∀h ∈ fv (P ): R(θ(h)(Y)) ⊆ R(θ(h)) ∪ (Res \ Y).
This is the analogous of Lemma A.7a, adapted to the substitution semantics.
Lemma A.22 For all P , θ, Y, we have that:
η ∈ P )sub(Y) =⇒ (Y\ RR(θ)(P )) ∩ R(η)= $ We now state that the substitution semantics is included in the trace semantics.
Lemma A.23 Let P be a strongly bound processes with fn(P )= $, let θ be a function such that dom (θ)= 
{h1,. .., hk} ⊇ fv (P ) and θ(hi)(Y¯ ) ⊆ Pi)op(Y¯ ) for all i ∈ 1..k and for all Y¯ ⊇ Y, and let Y ⊇ RR(θ)(P )
be a finite set of resources. Then:
 P )sub(Y) ⊆ P {P1/h1, ··· , Pk/hk})op(Y)


The next two lemmata allow for substitution of h-variables and for unfolding of recursions in strongly bound processes.
Lemma A.24  For all strongly bound processes P, P ' with fn(P )= fn(P ')= $, for all θ such that dom (θ) ⊇
fv (P ) ∪ fv (P '), and for all h /∈ fv (P '):

 P {P '/h})sub = P )sub
θ	θ{ P ')sub /h}
Lemma A.25 (Unfolding) For all strongly bound processes P , and for all θ:


 μh. P )sub
=  P )sub	sub
θ{ μh. P )θ  /h}


We now state the opposite direction of Lemma A.23, i.e. that the labelled transition relation is included in the substitution semantics.
Lemma A.26 Let P, P ' be closed, strongly bound process, let Y, Y' be finite sets of resources, and let
θ0 = $. Then:

P, Y −→a
P ', Y' =⇒ P )sub(Y) ⊇ a ⊙ P ')sub(Y')

θ0	θ0
The next two lemmata relate the operational, the denotational and the substitution semantics. Summed up, they imply the full abstraction result (Theorem 2.6).
Lemma A.27 Let P be a closed, strongly bound process, and let Y be a finite set of resources. Then:
 P )op(Y) =  P )sub(Y)
Lemma A.28 For all strongly bound P , for all Y, θ and χ such that fn(P χ)= $:
 P χ)sub(Y)= P )s(χ)(Y)
θ	θ
Appendix: weakly bound processes
In this Appendix we prove some intermediate results about weakly bound processes. These will be exploited in App. C and in App. D to show the correctness of the bindify transformation and of the trace inclusion preorder, respectively.
Lemma B.1 For all weakly bound processes p:

(B.1a)
(B.1b)
fn(p) ∩		$
Fn (p) ⊇ fn (p) ∪ bno(p)

The following lemma ensures that the condition Y ⊇ ran (χ) is always respected by the intermediate results of Def. 3.6. Therefore, in what follows we shall always omit to explicitly check this condition.
Lemma B.2 For all weakly bound processes p, and for all Y, χ:
(η, χ') ∈ p)w(χ)(Y) ∧Y ⊇ ran (χ) =⇒ Y ∪ R(η) ⊇ ran (χ') The weakly-bound analogous of Def. A.16 and Lemma A.17 follow.
Definition B.3 For all Y ∈ Dw , we define T(Y ) and R(Y ) as follows:


R(Y )= 
Y,χ
R(fst (Y (χ)(Y)))	T(Y )= {↓} ∩ R(Y )

Lemma B.4 For all Y ∈ Dw:

T(Y )= $	if ∀Y, χ. (η, χ') ∈ Y (χ)(Y) =⇒ ! ∈ η
{↓}  otherwise

The following definition enumerates some sanity conditions that any reasonable semantics of weakly bound process must adhere to. Lemma B.6 below ensures that the semantics of Def. 3.6 fulfills all these conditions.

Definition B.5 We say that Y ∈ Dw is sane if and only if, for all Y, χ:

(B.5a)
(B.5b)
(B.5c)
(B.5d)
(B.5e)

(B.5f)
Y (χ)(Y) /= $
Y (χ)(Y) ≥ Y (χ)(Y')	if Y ⊆ Y'
(η, χ') ∈ Y (χ¯)(Y) =⇒ χ' ≥ χ¯
(η, χ'{r/n}) ∈ Y (χ{r/n})(Y) Λ r /∈ η =⇒ (η, χ') ∈ Y (χ)(Y) if r /∈ R(η) Λ n /∈ dom (χ'): 
(η, χ') ∈ Y (χ)(Y) =⇒ (η, χ'{r/n}) ∈ Y (χ{r/n})(Y ∪ {r})
(η, χ') ∈ Y (χ)(Y) =⇒ R(Y ) ⊆ R(η) ⊆ Y(Y ) ∪ ran (χ) ∪ (Res \ Y)

We say that Z ∈ Dsub is sane if λY, χ.set χZ(Y) is sane. We say that θ is sane if θ(h) is sane for all h ∈ dom (θ).
Lemma B.6 For all weakly bound processes p and sane θ:

(B.6a)
(B.6b)
 p)w is sane
f(Z)= λY¯ . fst ( p)w


(χ)(Y¯ )) is sane, for all χ and sane Z ∈ Dsub

Lemma B.7 For all weakly bound processes p and sane θ:
 p)w(χ)(Y) ⊆ [ p)w(χ)(Y ∪ {r})
θ	θ
r/∈Y
The following lemma is the weakly-bound analogous of Lemma A.21.
Lemma B.8 For all weakly bound processes p and sane θ, R( p)w)= RR(θ)(p).

Appendix: correctness of bindification
In this Appendix we shall establish in Theorem 4.6 the correctness of bindification, i.e. that p)w =
 bindify (p))s for each well-bound p. Some intermediate results and definitions precede the proof of the main theorem.
We start by defining the action of filtering a name n from a pair (η, χ). If χ(n) does not occur in η, then
the filter removes from χ the binding for n (Def. C.1). This is used in the following Def. C.2. A semantic function Y is “anticipating on n” when Y (χ)(R) can be computed by joining the possible instantiations Y (χ{r/n})(R ∪{r}) for all r /∈ Y – modulo filtering of n. This is the weakly-bound analogous of lifting a νn binder to the top-level, as done in strongly-bound processes. Lemma C.3 below states that the semantics of weakly bound processes in Def. 3.6 is anticipating, for all names n.
Definition C.1 For all η, χ and n ∈ Nam, we define:

fltn
(η, χ)	if χ(n) ∈ R(η) (η, χ|dom (χ)\{n}) otherwise

Definition C.2 We say Y ∈ Dw is anticipating on n if, for all χ such that n /∈ dom (χ) and Y ≥ R(Y ) such that Y (χ)(Y) is defined:
Y (χ)(Y) = fltn(	Y (χ{r/n})(Y ∪ {r}))
r/∈Y
We say that Y ∈ Dsub is anticipating if λY, χ. set χY (Y) is anticipating on Nam.
Lemma C.3 For all weakly bound processes p, for all anticipating θ such that dom(θ) ≥ fv (p), and for all n /∈ fn (p), p)w is anticipating on n.
The following lemma relates the free names and the R-function of (well-bound) weakly bound processes with their strongly-bound counterparts. Also, the third item guarantees that the χ component is preserved when it already contains the bindings for all the may-bound names of the process.
Lemma C.4 For all weakly bound processes p such that wb(p):

(C.4a)
(C.4b)
(C.4c)
fn(p)= Fn (bindify (p))
RΘ(p)= RΘ(bindify (p))
(η, χ') ∈ p)w(χ)(Y) Λ dom (χ) ≥ bno(p) =⇒ χ = χ'


The following lemma contains the inductive statements about the bindify transformation that will allow us to prove in Theorem 4.6 its correctness.
Lemma C.5 For all weakly bound processes p such that wb(p), and for all Y, χ, θ such that dom (χ) ≥
fn (p), dom (θ) ≥ fv (p), and Y ≥ RR(θ)(p):

(C.5a)
(C.5b)
 p)w(Y)(χ)	is defined
 bindify (p))s (χ)(Y)= fst ( p)w(χ)(Y))	if dom (χ) ∩ bno(p)= $

θ	θ

(C.5c)
 β(p))s (χ)(Y)= fst ( p)w(χ)(Y))	if dom (χ) ≥ bno(p)

θ	θ
The following Theorem states the correctness of the bindify transformation. Its proof is direct from Lemma C.5b, the hypotheses of which are trivially satisfied.
Theorem 4.6.  For all closed, weakly bound processes p such that wb(p),  p)w($)($) is defined, and
 bindify (p))s ($)($)= fst ( p)w($)($)).
$	$
Appendix: equational theories and trace inclusion
In this Appendix we prove the main results from Sect. 5, i.e. that the preorder for strongly bound processes preserves trace inclusion (Theorem 5.3), and that the same happens for weakly bound processes (Theo- rem 5.7). Finally, in Theorem 5.8 we show that the equational theory of weakly bound processes preserve well-boundness, and that processes smaller (w.r.t. N ) than well-bound processes are well-bound.
Definition D.1 The names N(p) of a weakly bound process p are defined as:
N(p)= fn(p) ∪ bno(p)

The following definition introduced a preorder N between semantic functions in Dw. Roughly, Y N Z holds when the traces returned by Y are included in those of Z, neglecting the possible extra bindings of names in N returned by Y .
Definition D.2 Let Y, Z ∈ Dw. We write Y  N Z when for all Y,χ such that χ ∩N = $:

{ (η, χ'|dom(χ' )\N ) | (η, χ') ∈ Y (χ)(Y) } ⊆ Z(χ)(Y) Let Y, Z ∈ Dsub, we write Y ≤ Z whenever for all Y we have Y (R) ⊆ Z(R).
The following lemma states that the semantic function ·)sub is monotonic on the argument θ. This fact is used in the proof of Theorem 5.3, in the case of recursion.
Lemma D.3 For all strongly bound processes P , and for all θ, θ':

θ ≤ θ' =⇒ P )sub ≤ P )sub
θ	θ'

Theorem 5.3. For all closed, strongly bound processes P and P ':
if P = P ', then P )s = P ')s .
$	$
if P ≤ P ' then P )s (χ)(Y) ⊆ P ')s (χ)(Y), for all Y and χ.
$	$

The following two lemmata about bound and free names are straightforward.
Lemma D.4 For all weakly bound processes p and q such that p ≈ q:
fn(p)= fn(q)			bno(p)= bno(q)
Lemma D.5 For all weakly bound processes p and q such that p  N q:

fn(p) ⊆ fn(q)	bno(p) ⊆ bno(q) ∪N	bn (p) ≥ bn (q)


The following definition formalizes the notion of “captures” and capture-avoidance in substitutions of h- variables in weakly bound processes.

Definition D.6 The captures cpt N
follows:
(p, h) of h in a weakly bound process p are defined inductively as
N  if h = h'



cpt N (p0 · p1, h)= cpt N (p0 + p1, h)= cpt N (p0, h) ∪ cpt N (p1, h)
' '	jcpt N∪bn。(p')(p', h) if h /= h'

We say p{p'/h} capture-avoiding if bno(p')= $ = cpt bn。(p)(p, h) ∩ fn (p').
The following lemma is the weakly-bound analogous of Lemma A.24. Note that in this case the statement is trickier, since it requires capture-avoidance, and the semantics  p')w must be suitably projected on Dsub.
Lemma D.7 (Substitution) If p{p'/h} is capture-avoiding, then:


 p{p'/h})w(χ)(Y)  =  p)w	' w
(χ)(Y)

θ	θ{λY¯ . fst ( p )θ (χ)(Y¯ ))/h}
Lemma D.8 If X  N Y , Y  N ' Z, then X  N∪N ' Z.
The following lemma states that the semantic function p)w is monotonic on the argument p w.r.t. the
preorder  . This fact is used to prove Theorem 5.7.
Lemma D.9 For all weakly bound processes p, p' and for all N and θ:

(D.9a)
p ≈ p' =⇒ p)w  $ p')w

θ	θ

(D.9b)
p  N p' =⇒ p)w  N p')w

θ	θ
The following Theorem relates ≈ and  with trace inclusion. The first item follows from Lemma D.9a. The second item follows from Lemma D.9b and by Def. D.2.
Theorem 5.7. For all closed, weakly bound processes p and q:
if p ≈ q, then p)w = q)w.
$	$
if p N q, then fst ( p)w(χ)(Y)) ⊆ fst ( q)w(χ)(Y)), for all Y and χ such that dom(χ) ∩N = $ and both
$	$
the semantics are defined.

The following Theorem relates well-boundness with ≈ and . The first items is straightforward by Lemma D.4 and by induction on the derivation of p ≈ q. The second item is by induction on the structure of p. The last item is straightforward by Lemma D.5 and by induction on the derivation of p N q.
Theorem 5.8. For all weakly bound processes p and q:
if p ≈ q, then wb(p) if and only if wb(q).
if p ≈ q and wb(p), then bindify (p)= bindify (q).
if p  N q and wb(q), then wb(p).
