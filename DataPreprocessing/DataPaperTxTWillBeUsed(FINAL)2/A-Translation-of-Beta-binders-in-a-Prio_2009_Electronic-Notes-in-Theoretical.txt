

Electronic Notes in Theoretical Computer Science 229 (2009) 109–125
www.elsevier.com/locate/entcs

A Translation of Beta-binders in a Prioritized Pi-calculus 1
Igor Cappelloa, Paola Quagliaa,2
a Dipartimento di Ingegneria e Scienza dell’Informazione, Universita` di Trento

Abstract
A translation of Beta-binders in pi@ is presented. Beta-binders is a bio-inspired formalism that allows the modelling of processes wrapped into boundaries. No notion of enclosing compartment can instead be found in pi@, a dialect of the pi-calculus where actions are associated with a priority value driving their execution and where channel names can have a composite structure.
As recently shown, pi@ is a suitable language for encoding both Bio-Ambients and Brane Calculi, two of the most well-known formalisms for modelling biological scenarios. The translation provided here, which comes together with results about the operational correspondence of Beta-binders processes and their encodings, goes in the direction of assessing pi@ as a platform for investigating the relative expressive power of various bio-inspired languages.
Keywords: Name-passing process calculi, reduction semantics.


Introduction
Driven by the observation of the analogies between the behaviour of biological sys- tems and computations of distributed communicating systems [9], many research efforts have recently gone in the direction of interpreting living entities as terms of process calculi. The foreseen gain is the ability to reason about the functional- ity of biological systems, and hopefully about emergent behaviours, using formal techniques and analysis tools developed over mathematically sound bases.
Investigations in this field led to the definition of a set of process calculi equipped with bio-mimetic primitives and/or bio-inspired communication paradigms. Exam- ples are BioAmbients [8], Brane Calculi [1], and Beta-binders [4]. All of the above languages provide primitives to model compartments, as well as primitives for inter- acting with entities external to the local wrapper. This is in line with the observation

1 This work has been partially sponsored by the PRIN 2006 Project BISCA - Sistemi e calcoli di ispirazione biologica e loro applicazioni.
2 Corresponding author: quaglia@disi.unitn.it

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.02.008

that biological entities typically have an internal processing unit, as well as a sort of surrounding border through which the internal unit can receive and communi- cate signals. On the other hand, each of the various bio-inspired calculi moves at a distinct level of abstraction, and is characterized by a specific communication paradigm which makes the language suitable to easily represent some particular scenarios rather than others.
A challenging question then is whether the various bio-oriented calculi can be mutually compared and to what extent. A positive answer to this question could lead to concentrate research efforts in developing theories and tools for the refer- ential formalism and designing automated mappings from the various languages into a suitable common platform. Another interesting issue, this time more on the linguistic side, is a fine understanding of the relationship between bio-inspired com- partmentalized calculi and general purpose calculi, like, e.g., the π-calculus [2,12], which have shown suitable to model some scenarios from life science (e.g., [10,11]). Some recent works provide a preliminary answer to the above mentioned chal- lenges.	In particular, in [13,15] a dialect of the π-calculus is used to provide semantics-preserving encodings of both BioAmbients and Brane Calculi. Such di- alect, which is called π@, extends π-calculus in two ways: by prioritized communi- cations, and by polyadic synchronizations. This last feature amounts to let channel names have a composite structure. A viable π@ channel is, e.g., x@y where x and y are π-calculus names for channels. Notably, π@ comes with a stochastic extension and a simulation algorithm [14] that could be the basis of automated tools for the
analysis of biological behaviours.
Here we further pursue the above research direction and use π@ as target of a semantics-preserving mapping of Beta-binders, a formalism whose communication paradigm is quite different from both the one of BioAmbients and that of Brane Calculi. In particular, Beta-binders encapsulates (extended) π-calculus processes into compartments with interaction sites, but, differently from BioAmbients and Brane Calculi, compartments cannot be explicitly nested, nor moved the one into the other. Moreover, communication between Beta-binders compartments is driven by a notion of compatibility of interaction sites, and this has no analogy with the paradigms adopted by both BioAmbients and Brane Calculi.
The rest of the paper is organized as follows. We first review the source and the target languages of the translation (Sec. 2 and Sec. 3, respectively). The actual mapping is then defined in Sec. 4, together with the results about the operational correspondence between Beta-binders processes and their encodings. The paper ends with some concluding remarks in Section 5.

The source language: Beta-binders
This section reviews the definition of Beta-binders [4], a language of boxes with interaction capabilities. As in the π-calculus, the existence of a countably infinite set of names (ranged over by x, y, z, . . .) is assumed.  A special class of binders is used to characterize the typed interaction sites of boxes. The domain of types

is left unspecified. It can be arbitrarily instantiated under the proviso that it is decidable whether types are pairwise compatible or not. Processes are generated by the following grammar:
B ::= Nil | B[ P ] | B  B
B ::= β(x, Γ) | βh(x, Γ) | β(x, Γ) B | βh(x, Γ) B
P ::= nil | x(w).P | xy. P | P | P | νy P | ! P |
expose(x, Γ) .P | hide(x) .P | unhide(x) .P 
where Nil is the deadlocked process, B[ P ] denotes the process P enclosed in a box with interaction capabilities B, and B1  B2 is the parallel composition of B1 and B2. The graphical representation of the process B1  B2 = β(y, Δ)[ yz. nil ]  β(x, Γ)[ x(w). ww. nil | νu xu. nil ] follows.




B1 :
y : Δ 


B2 :
x : Γ 


(1)


Interaction capabilities B are represented by sequences of elements of either the shape β(x, Γ) or the shape βh(x, Γ), which are called elementary beta binders (unhidden and hidden, respectively). In either β(x, Γ) or βh(x, Γ), the name x identifies the interaction site and is called the subject of the binder, while Γ is the type of x. No requirement is set over the domain of types T , but for assuming that each of its possible instances comes together with the definition of a symmetric compatibility relation, and that the predicate comp : T × T → {true, false}, which returns true iff its argument types are compatible, is decidable.
The grammar for P generates extended π-calculus processes. The deadlocked nil, as well as the input and output prefixes, and the operators for parallel composi- tion, restriction and replication, have the same meaning as in π-calculus. The added prefixes expose, hide, and unhide are directives for changing the interaction capabil- ities of the enclosing box. Following the standard π-calculus terminology, x is said to be the subject of either the action x(w) or the action xw, while w is called its object or parameter. Also, the usual definitions of free names fn( ), of bound names bn( ), and of name substitution are extended by stipulating that expose(x, Γ) .P is a binder for x in P .
Notational conventions. We write u˜ as a shorthand for the tuple u1 ... un of
names, and use νu˜ for νu1 ... νun .  Also, with a slight abuse of notation, we
sometime read tuples as sets. The set of the subjects of all the elementary beta binders in B is denoted by sub(B), and we write B = B1B2 to mean that B is given by the juxtaposition of B1 and B2. A binder B is said to be well-formed when the subjects of its elementary components are all distinct. We use Δ, Δ1,..., Γ, Γ1,... to range over site types, and B, B1,... to range of Beta-binders processes. When all the binders B1, B2,... occurring in B are well-formed, B itself is said to be well- formed. The symbol β+ is sometimes used to stay for either β or βh. Moreover,



P1 ≡ P2 if P1 ≡α P2
P | nil ≡ P,	P1 | P2 ≡ P2 | P1,	P1 | (P2 | P3) ≡ (P1 | P2) | P3,	! P ≡ P | ! P
νz nil ≡ nil,	νz νw P ≡ νw νz P,	νz (P1 | P2) ≡ P1 | νz P2 provided z /∈ fn(P1)
BB'[ P1 ] ≡b B'B[ P2 ] if P1 ≡ P2
B ≡b B' if (B = β+(x : Δ)B[ P ] and B' = β+(y : Δ)B[ P{y/x} ]) or
(B' = β+(x : Δ)B[ P ] and B = β+(y : Δ)B[ P{y/x} ])
with y fresh in P and in sub(B)
B  Nil ≡b B,	B1  B2 ≡b B2  B1,	B1  (B2  B3) ≡b (B1  B2)  B3



Table 1
Structural congruences ≡ and ≡b.


the meta-variables B1, B2,... are overloaded to stay for either a beta binder or the empty string. For instance, we write β(x, Γ) B1[ P ] to mean a process that could have no other interface besides x. Notice, however, that by definition each process has to have at least one (possibly hidden) interface. So, for example, B1 is meant to be different from the empty string in B1[ P ].	 

The operational semantics of Beta-binders makes use of both a structural con- gruence over pi-processes and a structural congruence over boxes. They are the smallest relations satisfying the laws in Table 1, where ≡α is used to denote α- equivalence. It is intended that the notion of α-equivalence is extended to deal with expose binders in the natural way. Also notice that the second law for ≡b is a sort of α-conversion axiom for boxes.
The reduction relation describing the operational semantics of Beta-binders is defined by the axioms and rules collected in Tab. 2. This is actually a subset of the Beta-binders transition system. The complete semantics of the language also provides ways to join boxes together and to split a box in two. This is achieved by introducing specific axioms that can be applied when some desired conditions are satisfied. Joining and splitting activities, however, are purely semantic affairs. They have no syntactic counterpart in the language, i.e. they do not correspond to any primitive or operator. As such, joining and splitting do not seem to naturally belong to the domain of a compilation process.
The axiom intra concerns communications between pi-processes within the same box. For instance, given the process B1  B2 in (1), it allows the inference of the transition
B1  B2 d β(y, Δ)[ yz. nil ]  β(x, Γ)[ νu (uu. nil | nil)] .
The axiom inter describes possible interactions between boxes, and shows how com- patibility of types is used to match complementary actions performed by parallel


(intra)

(inter)
P ≡ νu˜ (x(w). P1 | xz. P2 | P3)

B[ P ] d B[ νu˜ (P1{z/w}| P2 | P3)] 
P ≡ νu˜ (x(w). P1 | P2)	Q ≡ νv˜ (yz. Q1 | Q2)

β(x, Γ) B [ P ]	β(y, Δ) B [ Q ] d β(x, Γ) B [ P' ]	β(y, Δ) B [ Q' ]

1	2	1	2




(expose)
where P' = νu˜ (P1{z/w}| P2) and Q' = νv˜ (Q1 | Q2) provided comp(Γ, Δ) and x, z ∈/ u˜ and y, z ∈/ v˜
P ≡ νu˜ (expose(x, Γ) . P1 | P2)

B[ P ] d B β(y, Γ)[ νu˜ (P1{y/x}| P2)] provided y ∈/ u˜ ∪ sub(B) ∪ fn(P2)
P ≡ νu˜ (hide(x) . P1 | P2)

(hide)


B β(x, Γ)[ P ] d B βh(x, Γ)[ νu˜ (P1 | P2)] provided x ∈/ u˜


(unhide)
P ≡ νu˜ (unhide(x) . P1 | P2)
B βh(x, Γ)[ P ] d B β(x, Γ)[ νu˜ (P1

| P2)] 




(redex)
provided x ∈/ u˜
B d B'

B	B'' d B'	B''


B ≡b B1	B1 d B2	B2 ≡b B'
(struct)		
B d B'





Table 2
Beta-binders semantics.

Beta-binders processes. For example, assuming comp(Γ, Δ), for the parallel com- position in (1) we have:
B1  B2 d β(y, Δ)[ nil ]  β(x, Γ)[ zz. nil | νu xu. nil ] .
The axioms expose, hide, and unhide cause the modification of the interaction capa- bilities of the box at hand by, respectively, adding a new site to it, hiding an active site, and unhiding an inactive site.
The target language: π@
The language π@ [13] extends the π-calculus [2] in two ways: (i) by prioritized communications, and (ii) by polyadic synchronizations. An integer k, indicating the priority of an action, is associated to every channel, and communication channels can be addressed by @-names. These are strings μ of the shape x1@ ... @xn where x1,..., xn are the usual π-calculus names.  Processes are given by the following


(tau)
τ ∈/ 


i<k
Ii(D)

(async)
C → C'	τ ∈/ 


i<k
Ii(C | D)


(sync)

k : τ. C + D → C
τ ∈/ 


i<k

Ii(E | F )
C | D → C' | D

(k : μ(y˜).C + E) | (k : μ⟨z˜⟩.D + F ) → C{z˜/y˜}| D
C ≡@ D	D → D'	D' ≡@ C'


C → C'

(struct)		
C → C'
(res)		
νx C → C'





Table 3 Reduction rules for π@

grammar:
C ::= nil | Σiπi. Ci | C | C | ! C | νx C
π ::= k : τ | k : μ(y1,..., ym) | k : μ⟨z1,..., zj⟩
where m, j ≥ 1. We let C, D,... range over π@ processes. Also, as said in Sec. 2, we keep using y˜ and z˜ as shorthands for the tuples y1,..., ym and z1,..., zj, and sometime read tuples as sets. For μ = x1@ ... @xn, the usual π-calculus notions of free and bound names are extended as follows:
fn(k : μ(y˜)) = {x1,..., xn},  fn(k : μ⟨z˜⟩) = {x1,..., xn}∪ z˜,
bn(k : μ(y˜)) = y˜,	bn(k : μ⟨z˜⟩) = ∅ .
The semantics of π@, given in reduction style, makes use of the structural con- gruence ≡@. That relation is defined as the least congruence relation satisfying either the laws defined for ≡ in Table 1 (just read C for P there) or the monoidal axioms for the choice operator. Notice, however, that by C ≡α D we mean the natural adaptation of the usual notion of α-conversion to @-names. For instance, νx(k : x@y⟨z⟩. nil) ≡α νw(k : w@y⟨z⟩. nil).
The definition of the operational semantics of π@-processes is also based on the function Ik(C) which returns the set of the (relevant components of the) actions with priority k which are enabled in C. Function Ik(C) is inductively defined below, where the set Tk(C | D) is not empty iff there exists α ∈ Ik(C) such that α /= τ and α ∈ Ik(D) (after setting, as usual, μ = μ). When it is not empty, Tk(C | D) = {τ}.
Ik(Σπi. Ci) = {μ | πi = k : μ(y˜) for some y˜}∪ {μ | πi = k : μ⟨z˜⟩ for some z˜}∪
{τ | πi = k : τ}

Ik(νy C) = Ik(C) \ {α | (α = x1@ ... @xn ∨ α = x1@ ... @xn) ∧ y ∈ {x1,..., xn}} Ik(C | D) = Ik(C) ∪ Ik(D) ∪ Tk(C | D)   Ik(! C) = Ik(C | C)
The operational semantics of π@ is given in Table 3. It enforces the condition that reductions can take place only if: (i) the involved actions have the lowest

priority value w.r.t. all of the enabled actions; (ii) in interactions the matching input and output actions have the same priority. As for the π-calculus, the notion of substitution is an integral part of the operational semantics. Again, similarly at what happens for α-conversion, name substitutions are adapted to @-names in the natural way. For example, (k : x@y⟨z⟩. nil){w/x} = k : w@y⟨z⟩. nil.
Notational convention. In what follows, we often omit both trailing occurrences of ‘. nil’ and unrelevant parameters of input and output actions. Also, since the forthcoming translation uses only two priority values, we use underlines to improve readability and drop the prefixing ‘k :’ from basic actions. In detail, high priority actions π0 and low priority actions π1 are generated by the following grammars:
π0 ::= τ | μ(y˜) | μ⟨z˜⟩	π1 ::= τ | μ(y˜) | μ⟨z˜⟩ .
	


Mapping Beta-binders into π@
Below we describe the proposed translation [ ] of Beta-binders into π@, and present two main results about the operational correspondence between the behaviour of processes of the source language and that of their encodings.

Deﬁnition of the translation
The complete definition of the translation is reported in Tab. 4. In what follows, the encoding is described in an incremental way, by focussing on the most relevant design choices step by step, up to refining the presentation into the definition shown in Tab. 4.
The main challenge of the translation is related to the fact that two distinct communication paradigms live together within Beta-binders. One of them, quite similar to that adopted in π@, although not prioritized, follows a strict policy of action complementarity. The other one, for the description of interactions between boxes, is driven by a notion of compatibility and still implements name-passing. Moreover, the boxes of the source language are essentially closed worlds, while π@ describes flat parallel processes each of which can freely interact with any of the oth- ers. So, a main issue in the design of the encoding is the concurrent handling of both
complementarity-driven (hereafter called local ) and compatibility-driven (hereafter
called global ) communications. To overcome the above issue, the definition of the translation is underpinned by the following basic ideas.
Inter-communications between boxes are not rendered as atomic communica- tions but rather mimicked by an ad hoc protocol. The main actor of such a protocol is a monitor process that is in charge of mediating actual communi- cations between encoded boxes. In detail, at its highest level, the translation of B is given by:
[[B]] = {|B|} | Πi,j CH(Γi, Γj) with comp(Γi, Γj) and Γi, Γj occurring in B



[[B]] = {|B|} | Πi,j CH(Γi, Γj ) with comp(Γi, Γj ) and Γi, Γj occurring in B
{| Nil |} = nil
{|B1  B2|} = {|B1|} | {|B2|}
{|B[ P ]|} = νg νv˜ ([[B[]g | [[P []g | Πx∈fn(P ) GSC(g, x)) where v˜ = sub(B)
GSC(g, x)=! n@g@x(h). h⟨g⟩
CH(Γ, Δ)=! put@Γ(w, k2, f2). (νk3 νf3 get@Δ⟨w, k3, f3⟩. (k3. k2 + f3. f2)+ f2) [[B[]g = νt ([[B[]t | TM(t) | EH(g, t))
TM(t)= t | ! t.t 
EH(g, t)=! ex@g(x, Γ, h).νw ex@g@h⟨w⟩. ([[β(w, Γ)[]t | GSC(g, w))
[[β+(x : Γ)B[]t = [[β+(x : Γ)[]t | [[B[]t	assuming [B[]t = nil for B empty
g	g	g	g
[[β(x, Γ)[]t = νr (BH(g, t, x, Γ, r) | ! r. BH(g, t, x, Γ, r))
[[βh(x, Γ)[]t = νr (uh@g@x. r | ! r. BH(g, t, x, Γ, r))

BH(g, t, x, Γ, r) = g@g@x(w, k1, f1). t. PUT(t, w, Γ, k1, f1, r)+
t. GET(g, t, x, Γ, r)+ hd@g@x. uh@g@x. r
PUT(t, w, Γ, k1, f1, r)= νk2 νf2 put@Γ⟨w, k2, f2⟩. (k2. k1. t. r + f2. f1. t. r)+ f1. t. r
GET(g, t, x, Γ, r)= get@Γ(w, k3, f3). (g@x⟨w⟩. k3. t. r + f3. t. r)+ τ. t. r
 
[[P []g = νl QP ¢l
Qnil¢l = nil
QP | Q¢l = QP ¢l | QQ¢l
g	g	g
Q! P ¢l = !QP ¢l
g	g
Qνx P ¢l = νx (QP ¢l | LSC(g, l, x))
g	g
LSC(g, l, x)=! n@g@x(h). h⟨l⟩
Qhide(x) .P ¢l = hd@g@x. QP ¢l
g	g
Qunhide(x) .P ¢l = uh@g@x. QP ¢l
g	g
Qexpose(x, Γ) .P ¢l = νh ex@g⟨x, Γ, h⟩. ex@g@h(x). QP ¢l
g			g
Qx(w).P ¢l = g@x(w). (GSC(g, w) | QP ¢l )+ l@x(w). QP ¢l
g			g			g
Qxw. P ¢l = νb νk1 νf1 (C | ! b.C)	where C stays for
νh n@g@w⟨h⟩. h(c). (c@c@x⟨w, k1, f1⟩. (k1. QP ¢l + f1. b)+ l@x⟨w⟩. QP ¢l + τ. b)
	  	g			g




Table 4 Definition of the translation.

where, with a slight abuse of notation, we use Γk to mean the name correspond- ing to type Γk. Each parallel subcomponent CH(Γ, Δ) of the monitor acts as a compatibility handler for the pair (Γ, Δ): it controls the inter-communications that involve an output action over a site of type Γ and an input action over a site of type Δ. Roughly, the protocol goes as follows. An output action over a site typed by Γ engages in an interaction with CH(Γ, Δ), for Δ non- deterministically chosen among all the types compatible with Γ. If some input action over a site typed by Δ is ready to interact with CH(Γ, Δ), the relevant parameter is passed to the requesting process and the simulation of the inter- communication completes successfully. The protocol session fails otherwise, and a rollback mechanism takes the system back to the pre-existing state.
Each box B[ P ] is mapped into a parallel composition which comprises a π@ process playing the role of B, and a process playing P . More specifically:

{|B[ P ]|} = νg νv˜ ([[B[]g | [[P []g | .. .) where v˜ = sub(B) .	(2)

(The missing portion of (2) will be illustrated later on.) Above, the shared private name g can be thought of as an identifier of the box. It is used to form @-names exploited in the implementation of global communications. Orthog- onally,
[[P []g = νl QP ¢l
where the new name l uniquely identifies the content of the box, and indeed l is used to form @-names involved in local communications within the box identified by g.
Process {|B[ P ]|} monitors the access to Πi,j CH(Γi, Γj) at two distinct levels.
First, (the encoding of) one single binder in B at a time can interact with compatibility handlers. This ensures that the inter-communication protocol cannot involve (the encoding of) input and output actions residing in the same box, like for instance in β(y, Γ) β(x, Δ)[ yz | x(w) ].
Second, one single parallel component of [P []g at a time can access the handler of an elementary binder. In this way, [B[]g monitors the compe- tition to inter-communications which shows, e.g., in β(y, Γ)[ yz | yu ]  β(x, Δ)[ x(w) ].
In more detail:


where
TM(t) = t | ! t.t 
[[B[]g = νt ([[B[]t | TM(t) | .. .)	(3)

[[β+(x : Γ)B[]t = [[β+(x : Γ)[]t | [[B[]t	assuming [B[]t = nil for B empty
g	g	g	g
[[β(x, Γ)[]t = νr (BH(g, t, x, Γ, r) | ! r. BH(g, t, x, Γ, r))
[[βh(x, Γ)[]t = νr (uh@g@x. r | ! r. BH(g, t, x, Γ, r))
BH(g, t, x, Γ, r) = g@g@x(w, k1, f1). t. PUT(t, w, Γ, k1, f1, r)+
t. GET(g, t, x, Γ, r)+
hd@g@x. uh@g@x. r

PUT(t, w, Γ, k1, f1, r) = νk2 νf2 put@Γ⟨w, k2, f2⟩. (k2. k1. t. r + f2. f1. t. r)+

f1. t. r

GET(g, t, x, Γ, r) = get@Γ(w, k3, f3). (g@x⟨w⟩. k3. t. r + f3. t. r)+ τ. t. r
CH(Γ, Δ) = ! put@Γ(w, k2, f2). (νk3 νf3 get@Δ⟨w, k3, f3⟩. (k3. k2 + f3. f2)+ f2) Above, process BH(g, t, x, Γ, r) is the binder handler for β(x, Γ), and PUT
and GET implement attempts to inter-communications driven, respectively, by an output and by an input over x. The actions complementary to either g@g@x(w, k1, f1) (in BH) or g@x⟨w⟩ (in GET ) are offered by [P []g . Actual
interactions of BH with either CH(Γ, Δ) or CH(Δ, Γ) occur over the channel
put@Γ or over get@Γ, respectively. The third alternative component of BH

goes for handling hiding/unhiding of binders through interactions with the encoding of hiding/unhiding internal prefixes, which are defined as follows:

Qhide(x) .P ¢l = hd@g@x. QP ¢l

Qunhide(x) .P ¢l = uh@g@x. QP ¢l .
Process TM can be thought of as a token manager and implements the kind of monitoring we discussed in (a) above. Before executing an action over ei- ther put@Γ or get@Γ, process BH has to grant itself the token t which is a shared resource of all of the binder handlers in [B[]t . The token is then re- leased by means of a t action at the end of the protocol session, which may terminate either successfully (triggering the high priority ki actions) or un- successfully (triggering either the low priority fi actions or the low priority τ action in GET ). The form of monitoring commented upon in (b) is granted by the definition of [β(x, Γ)[]t . For each unhidden elementary binder, one single copy of the corresponding handler BH is initially available for interaction with
[[P []g , while the replicated component of [β(x, Γ)[]t can be unfolded only at
the execution of r, i.e. either at the end of a protocol session or when possi- ble hiding-unhiding activities are over. Analogously, if the binder is initially hidden, then the corresponding handler BH becomes available only after the execution of an unhide directive.
On the ground of the above overview about the translation principles, we can now complete the definitions partially stated in (2) and (3). Both the two omissions relate to a component that is exploited to ensure that the inter-communication protocol is not run unproperly, i.e. for output actions with a bound object. To better comment on this point, we focus on the axiom inter of Tab. 2. If comp(Γ, Δ), and P ≡ νu˜ (x(w). P1 | P2) and Q ≡ νv˜ (yz. Q1 | Q2), such axiom allows to infer an execution step leading from β(x, Γ) B1[ P ]  β(y, Δ) B2[ Q ] to
β(x, Γ) B1[ νu˜ (P1{z/w}| P2)]  β(y, Δ) B2[ νv˜ (Q1 | Q2)] .
This, however, can happen only under the proviso that x, z ∈/ u˜ and y, z ∈/ v˜.
To obtain a semantics preserving translation of Beta-binders into π@, we need to guarantee that a session of the inter-communication protocol is spawned only if the subjects and the objects of the involved input and output action meet the highlighted side conditions on the involved names. This is easily achieved for the

conditions over the action subjects, namely to ensure that x ∈/
u˜ and y ∈/
v˜. In

fact, if x is bound in P then the encoding of P cannot synchronize with the binder
handler of [β(x, Γ)[]t over the channel g@x (see process GET above). This will be
fully clear after introducing [P []g . We can just anticipate that, since [β(x, Γ) B1[]g
and [P []g are run in parallel, under the above hypotheses the scope of x would be restricted to [P []g , leading, at best, at a composition looking like

g@x⟨z⟩.C | νx (g@x(w). D)  .
	
For analogous reasons, if y ∈ v˜ then the encoding of Q cannot synchronize with
the binder handler of [β(y, Δ)[]t' over the channel g'@g'@y. Yet another one of the

four conditions on names is not problematic. This is the case for z ∈/ u˜, which is actually a non-issue, as it could be best seen in the Beta-binders labelled transition system [5]. Intuitively, if z ∈ u˜, all we have to do in order to make the inter axiom applicable is to choose a suitable α-conversion of P . Looking at this same case from the perspective of the π-calculus semantics, what happens here is that the name substitution {z/w} has to be applied to the process νu˜ x(w). P1. Whether or not z ∈ u˜ is completely irrelevant. The name substitution takes successfully place anyhow, possibly inducing the refreshing of u˜ to avoid capturing z. We are now left with the fourth side condition on names: z ∈/ v˜. This is the most delicate point. Seen on the Beta-binders side, this requirement enforces the assumption that the border of boxes is the furthest limit that scope extrusion can reach. In π@, though, just as in π-calculus, there is no explicit way to prevent scope extrusion. To overcome this issue, the translation makes use of scope handlers that are enquired to understand whether or not a certain name can be used as argument of inter-communications. In detail:

GSC(g, x) = ! n@g@x(h). h⟨g⟩

LSC(g, l, x) = ! n@g@x(h). h⟨l⟩
Operationally, before using x as object of an inter-communication an enquiry is sent over the channel n@g@x, and either g or l is sent back to the requesting process depending on which kind of scope handler (global or local ) is in the scope of x.
The missing portion of (2) serves the purpose of setting the proper global scope handlers at the outermost level. Precisely:
{|B[ P ]|} = νg νv˜ ([[B[]g | [[P []g | Πx∈fn(P ) GSC(g, x)) where v˜ = sub(B).
Further scope handlers are added by the encoding of expose prefixes, restricted internal processes, and input prefixes. In the case of expose prefixes this task is carried on by the expose handler that completes (3) as shown below.
[[B[]g = νt ([[B[]t | TM(t) | EH(g, t))

EH(g, t) = ! ex@g(x, Γ, h). νw ex@g@h⟨w⟩. ([[β(w, Γ)[]t | GSC(g, w)) .
The above handler is triggered by encoded expose directives:
Qexpose(x, Γ) .P ¢l = νh ex@g⟨x, Γ, h⟩. ex@g@h(x). QP ¢l .
g			g
Up to structural congruence we have in fact that
EH(g, t) | Qexpose(x, Γ) .P ¢l d2
EH(g, t) | νw ([[β(w, Γ)[]t | GSC(g, w) | QP ¢l {w/x})
g	g
where the global scope handler GSC(g, w) goes along with the fact that w is free in QP ¢l {w/x}. By contrast, the encoding of restricted processes induces the insertion of a local scope handler:

Qνx P ¢l
= νx (QP ¢l
| LSC(g, l, x)) .

The translation of input prefixes takes into account the fact that input activities may non-deterministically (i.e. with equal priority) be involved in either local or global communications. In the first case the actual parameter of the communication can be either free or bound within the box, but its relative scope handler in anyhow already in place. On the other hand, if the input action is fired for a successful inter-communication, then, as discussed above, the received parameter is surely free. Then, since such a parameter could be fresh w.r.t. the free names of the box, a global scope handler is added in this case. Formally:
Qx(w).P ¢l = g@x(w). (GSC(g, w) | QP ¢l )+ l@x(w). QP ¢l .
g			g			g
We eventually comment on the encoding of output prefixes:

Qxw. P ¢l
= νb νk1 νf1 (C | ! b. C)	where C stays for



νh n@g@w⟨h⟩. h(c).

(c@c@x⟨w, k1, f1⟩. (k1. QP ¢l + f1. b)+ l@x⟨w⟩. QP ¢l + τ. b) .
g			g
The first step of Qxw. P ¢l is to contact the scope handler for w. If w is a name
with local scope, then c is instantiated by l and no action complementary to l@l@x can be found in the encoded process. Hence only two alternatives are feasible for C: engaging in a local communication over l@x with high priority, or silently causing a rollback to the initial configuration with low priority. On the other hand, if w is recognized to be a suitable name for global communications, then c gets instantiated by g and, with the same high priority, C can either engage in a session of the inter-communication protocol or take part into a local communication. Also, it may happen that no synchronization over either g@g@x or l@x can occur. This is the case, e.g., when the box has no binder named x and the internal process has no unguarded input over x. If so, then a copy of C is spawned and the above behaviour is replicated once more from the very beginning. The same rollback mechanism is triggered when, through f1, process C receives from the handler of the binder x the notification that the session of the inter-communication protocol failed.
To conclude the presentation of the translation, a schematic overview of what is involved in the inter-communication protocol is shown in Fig. 1. There we consider a session of the protocol relative to the Beta-binders process B1  B2 graphically reported in the lower portion of Fig. 1. The upper portion of the figure shows an interconnection graph whose nodes represent the π@ processes involved. For instance, BHy denotes the handler for the binder y of B1, and BHx the handler
1	2
for the binder x of B2. The edges of the graph are labelled to record two kinds of
information: the relevant channel used for communications between the end-points of the edge (e.g., t2 above the rightmost edge), and the relevant private resources shared by such end-points (e.g., (t2) below the rightmost edge).  The temporal
ordering of the communications involved in the protocol session is reported in UML style in Fig. 2. In that diagram, arrows point to the receiver, and labels keep track of both communication channel and actual parameters.  Notice in particular the
communications between BHy and TM1 = t1 | ! t1. t1, and those between BHx


J,T¸M` 1\, 	t1	 J,˜¸BH` y \, 	put@Γ  J,C¸H(Γ` , Δ,)   get@Δ	 J,B¸H` x\, 	t2	 J,T¸M` 2\,


g1@g1@y (g1,k1,f1)	g2@x (g2)


J,G¸S` Cz\,   n@g1@z	

J,[[˜¸P1` []

g1\,


(a)

J,[[˜¸P2` []

g2\,





B1 :
y : Γ 




(b)


B2 :
x : Δ 


Fig. 1. Schema of the interconnection topology (a) for a specific inter-communication (b).



[[P1[]g1
GSCz
BHy
T M1	CH(Γ, Δ)	T M2	BHx
[[P2[]g2

Fig. 2. Temporal ordering of communications for the inter-communication in Fig. 1.

and T M2 = t2 | ! t2. t2. Also, recall that each token manager is shared by the translations of all of the elementary binders of the given box. The communications over t1 and t2 show that access to CH(Γ, Δ) is dealt with as a critical session. This ensures that input and output actions residing within the same box (think, e.g., of β(y, Γ) β(x, Δ)[ P1 | P2 ]) cannot possibly interact via CH(Γ, Δ).
The layout of the diagram in Fig. 2 puts evidence on the fact that the failures driving the rollback mechanims can happen at three different levels (correspondingly to notifications over f1, f2, f3).
f1: If Γ were not compatible with Δ (nor with other types possibly in the system), then CH(Γ, Δ) would not exist and hence BHy could not contact it over put@Γ. In this case, or upon receiving a higher level failure notification over f2, the binder

handler BHy would send a f1 signal to [P1[] .
g1
f2: If the binder β(x, Δ) were hidden, or the binder handler BHx would not yet own the token t2, then CH(Γ, Δ) could not execute its prioritized activity over the get@Δ channel. In this situation, or upon receiving over f3, the compatibility handler would send back to BHy a notification over f2.
f3: Even if BHx already owns the token t2, [[P2[]g might be unable to interact over
x. For example, P2 could be u(w). nil. Under these circumstances, BHx would
notify the protocol failure to the compatibility handler via f3.
Reasoning about failures, notice that the use of priorities is fundamental to provide a proper implementation of the rollback mechanism: in all of the involved processes synchronizations over the successful ki channels have higher priority than synchronizations over the fi channels. This ensures that failure notifications are put forward only when successful termination cannot occur.

Properties of the translation
Below we report on two main properties of the translation, which are relative to the operational correspondence between Beta-binders processes and their encodings. These properties rely on the definition of a structural congruence which extends ≡@ with the addition of the following law:
νx (! k : μ(y˜). C) ≡^ @ nil if x ∈ μ .	(4)

The above axiom allows the garbage collection of possible deadlocked processes which are left as residuals in the derivative of Qxw. P ¢l . Indeed, recall that the encoding of internal processes of the form xw. P exploits a parallel component ! b.C to unfold a fresh copy of C when either xw cannot take part into a communication (neither locally nor globally) or a session of the intercommunication protocol fails. If and when a communication involving xw terminates successfully, process ! b.C cannot be further unfolded and remains hanging.
Definition 4.1 The relation ≡@ is the least congruence relation satisfying both the axioms used to define ≡@ and the garbage collection law in (4).
As expected, one step of a Beta-binders process is simulated by one or more reduction steps of its encoding.
Theorem 4.2 If B is well-formed and B d B' then [[B]] →∗ ≡^ @[[B']].
Proof. A few auxiliary results are needed to prove the assertion. One of them is that the translation reflects structural congruence, namely that for all well-formed B and B', B ≡b B' implies [B]] ≡@ [[B']]. Below we just sketch the proof strategy of the main statement. First, by the hypothesis B d B' we deduce the possible structure of both B and B' (see [5], Lemma 4). In this way we get two processes

B1 and B'
such that B1 ≡b B and B'
≡b B', and which can assume five (pairs

of) distinct forms, essentially depending on the axiom rule driving the derivation

of B d B'. We then reason on B1, and the proof goes on by a case analysis of its form, which in turn determines the form of the encoding [B1]]. In each of the possible cases we show that, for suitable C and C',
[[B1]] → C →∗ C' ≡^ @ [[B' ]].
Hence, by [B]] ≡@ [[B1]], and the π@ structural rule, we get [B]] →∗ C'. Then the thesis, by C' ≡^ @ [[B' ]] ≡@ [[B' ] which implies C' ≡^ @ [[B']].	 
Theorem 4.3 below states that any reduction of [B ] may either lead to a rollback, or to the encoding of a Beta-binders process reachable from B in one single step. In both cases the result holds up to structural congruence. Notice, however, that in case of rollback the garbage collection axiom is superfluous.
Theorem 4.3 If B is well-formed and [[B]] → C then there exists C' such that
C →∗ C' and
either C' ≡@ [[B]],
or C' ≡^ @ [[B']] for some B' such that B d B'.
Proof. By definition of the translation no τ action occurs unguarded in [B]]. Hence the derivation of [B]] → C can only be driven by a (sync) axiom. Five distinct classes of complementary input/output actions can be involved in such synchronization. The relevant channels are:
ex@g (see EH(g, t) and Qexpose(x, Γ) .P ¢l );
hd@g@x (see BH(g, t, x, Γ, r) and Qhide(x) .P ¢l );
uh@g@x (see [βh(x, Γ)[]t and Qunhide(x) .P ¢l );
n@g@w (see Qxw. P ¢l and either GSC(g, w) or LSC(g, l, w)).
t (see TM(t) and BH(g, t, x, Γ, r));
The first three kinds of channels are involved in the encoding of expose, hide, and unhide directives. In each of these cases we show that C →∗ ≡@[[B' ] for some B' such that B d B'. Hence the thesis, by ≡@ ⊆ ≡@.
The fourth kind of synchronization is triggered by the translation of an output prefix with actual parameter w. Specifically, suppose that the output action is xw. Depending on whether w is a private resource of the box or not, the partner of the synchronization is either the local or the global scope handler for w, and a further synchronization discloses this (either l or g is received over h in Qxw. P ¢l ). A range of possibilities is now considered. If w is local, then with high priority the next step can be a communication over l@x, and with low priority it can be a τ action. (Here notice that none of the processes in Tab. 4 ever offers an input over l@l@x.) If instead w is global, then non-deterministically and with high priority the next reduction can be a synchronization over either g@g@x or l@x, and with low priority it can be a τ action. In those cases when a synchronization over l@x takes place we show that there exists C' such that C →∗ C' and, for some B' such that B d B' and for some b and D, C' ≡@ [[B']] | νb (! b. D). Hence the thesis by C' ≡@ [[B']]. The same is done in the case of communications over g@g@x which end up in the

successful completion of a session of the inter-communication protocol (see Fig. 2 for a schematic overview of the involved reductions). When the τ alternative is taken, as well as when the inter-communication protocol is rolled-back for failure, we show instead that C →∗ ≡@[[B]].
The fifth kind of synchronization is relative to those cases when a binder handler gets the token for accessing a compatibility handler (see t2 in Fig. 2). Here we distinguish two main cases: either an instance of the inter-communication protocol actually takes place, or a low priority τ action forces the token be released and the binder handler be re-initialized. In the first case, be the protocol session successful or not, we get the same results discussed above for initial synchronizations over n@g@w. In the second case we show that C →∗ ≡@[[B]].	 

Concluding remarks
We presented a translation of Beta-binders into π@. This work mostly relates to the encodings of other two compartmentalized calculi, BioAmbients and Brane Calculi, into the same target language [13,15]. The three source languages largely differ in their communication paradigms. Both BioAmbients and Brane Calculi express a hierarchy of compartments and provide primitives (located within ambients or on membranes) to allow their dynamic evolution. So, the encodings presented in [13,15] mainly focus on the need to faithfully render and update the tree-like structure of compartment nesting. This is done by implementing a multicast communica- tion mechanism which allows the timely delivery of notifications about changes of the nesting structure. As for the translation of Beta-binders, the main issue is the accurate handling of the possible interferences of the two distinct communi- cation mechanisms that live together in the language: intra-communications and inter-communications. Then the key point is the design of appropriate interaction protocols.
In all of the three above mentioned encodings, the polyadic synchronization of π@ seems to be a convenient tool rather than a fundamental feature. In fact, although @-names bring in the flavour of a sort of partial application of name substi- tution, it would seem that translations of the three compartmentalized calculi could also be obtained, via more involved encodings, by using simple channel names in the π-calculus style. Things are completely different, though, when we come at the prioritized communications of π@. In the encodings of BioAmbients and Brane Calculi, priorities are mainly exploited to force the predecence of communications of structural information over all of the other communications. This, e.g., avoids that an interaction between two processes takes place if some event changed their relative positions and they are not entitled to synchronize in the updated config- uration. In the case of the Beta-binders encoding, priorities are fundamental to the implementation of the transactional mechanism that allows a rollback when a session of the inter-communication protocol cannot successfully terminate. In this respect, the relevance of priorities is not surprising at all. Essentially, priorities master the proper undo of the many steps needed to simulate Beta-binders atomic

inter-communications by means of a finer grained communication paradigm.
To conclude, the translation presented in this paper, together with those of BioAmbients and Brane Calculi, goes in the direction of assessing π@ as a plausible formal ground for the investigation of the relative expressive power of compartmen- talized bio-inspired languages. It goes unsaid that this kind of investigation will not be particularly easy. Indeed, the same sort of task shows to be quite demanding for encodings which are much handier than those for compartmentalized calculi (see, e.g., [16,6,7,3]).

References
L. Cardelli. Brane Calculi. In V. Danos and V. Sch¨achter, editors, Proc. 2nd Int. Workshop on Computational Methods in Systems Biology, CMSB 2004, volume 3082 of LNBI. Springer, 2005.
R. Milner. Communicating and mobile systems: the π-calculus. Cambridge Universtity Press, 1999.
U. Nestmann and B.C. Pierce. Decoding Choice Encodings. In U. Montanari and V. Sassone, editors, Proc. 7th Int. Conference on Concurrency Theory, CONCUR 1996, volume 1119 of LNCS, pages 179–194. Springer, 1996.
C. Priami and P. Quaglia. Beta Binders for Biological Interactions. In V. Danos and V. Sch¨achter, editors, Proc. 2nd Int. Workshop on Computational Methods in Systems Biology, CMSB 2004, volume 3082 of LNBI, pages 21–34. Springer, 2005.
P. Quaglia. On Beta-Binders Communications. In P. Degano, R. De Nicola, and J. Meseguer, editors,
Concurrency, Graphs and Models, volume 5065 of LNCS, pages 457–472. Springer, 2008.
P. Quaglia and D. Walker. On synchronous and asynchronous mobile processes. In J. Tiuryn, editor, Proc. 2nd Int. Conference on Foundations of Software Science and Computation Structures, FoSSaCS 2000, volume 1784 of LNCS, pages 283–296. Springer, 2000.
P. Quaglia and D. Walker. Types and full abstraction for polyadic π-calculus. Information and Computation, 200:215–246, 2005.
A. Regev, E. M. Panina, W. Silverman, L. Cardelli, and E. Y. Shapiro. Bioambients: an abstraction for biological compartments. Theoretical Computer Science, 325(1):141–167, 2004.
A. Regev and E. Shapiro. Cells as computations. Nature, 419:343, 2002.
A. Regev, W. Silverman, and E. Shapiro. Representing biomolecular processes with computer process algebra: π-calculus programs of signal transduction pathways. In American Association for Artificial Intelligence Pubblication, 2000.
A. Regev, W. Silverman, and E. Shapiro. Representation and simulation of biochemical processes using the pi-calculus process algebra. In Proceedings of the Pacific Symposium of Biocomputing 2001, volume 6, pages 459–470, 2001.
D. Sangiorgi and D. Walker. The π-calculus: a Theory of Mobile Processes. Cambridge Universtity Press, 2001.
C. Versari. A core calculus for a comparative analysis of bio-inspired calculi. In R. De Nicola, editor, Proc. 16th European Symposium on Programming, ESOP 2007, volume 4421 of LNCS, pages 411–425. Springer, 2007.
C. Versari and N. Busi. Stochastic Simulation of Biological Systems with Dynamical Compartment Structure. In Proc. Int. Conf. on Computational Methods in Systems Biology, CMSB 2007, LNCS, pages 80–95. Springer, 2007.
C. Versari and R. Gorrieri. π@: A pi-Based Process Calculus for the Implementation of Compartmentalised Bio-inspired Calculi. In M. Bernardo, P. Degano, and G. Zavattaro., editors, Formal Methods for Computational Systems Biology, SFM 2008, volume 5016 of LNCS, pages 449–506. Springer, 2008.
N. Yoshida. Graph Types for Monadic Mobile Processes. In Proc. 16th Conference on Foundations of Software Technology and Theoretical Comp. Sc., FST&TCS 1996, volume 1180 of LNCS, pages 371–386. Springer, 1996.
