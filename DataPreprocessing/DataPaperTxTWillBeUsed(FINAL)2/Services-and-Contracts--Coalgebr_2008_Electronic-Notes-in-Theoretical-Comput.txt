	Electronic Notes in Theoretical Computer Science 212 (2008) 207–223	
www.elsevier.com/locate/entcs

Services and Contracts: Coalgebraically1
Sun Meng2
CWI, Kruislaan 413, Amsterdam, The Netherlands

Abstract
The popularity of service-oriented computing has not been accompanied by the necessary formalization of the notions being involved. This paper focuses on the development of a coalgebraic framework to support service-oriented application design. In this paper, the concepts are separated into three hierarchies – inter- faces, contracts and services. Interfaces are specified by functors, and services are shown to be coalgebras of such functors, which should satisfy the axioms given in corresponding contracts. Different interfaces, contracts and services are related respectively by the morphisms between them. And the notion of bisimula- tion for services is derived from service morphisms, which captures the observational equivalence of services.

Keywords: interface, contract, service, coalgebra, composition


Introduction
Service-oriented Computing (SOC) [11,16] has now become the prominent paradigm for distributed computing and e-commerce, creating opportunities for service providers and application developers to use services as fundamental elements in their application development processes. It provides a mean to design Service-oriented Applications (SOAs) that span organizations and computing platforms by exploit- ing and composing services available over the network. Nowadays, an increasing number of companies and organizations implement only their core businesses and use other application services over the Internet to support their needs. Services are platform- and network-independent components that support rapid low-cost com- position of distributed applications and can be described, published, discovered, and loosely coupled in novel ways.
The notion of service has been widely used in application development, especially due to the use of service technologies such as the Web Services Description Language (WSDL) [21], Universal Description, Discovery, and Integration (UDDI) [19], Simple

1 The work reported in this paper is supported by a grant from the GLANCE funding program of the Dutch National Organization for Scientific Research (NWO), through project CooPer (600.643.000.05N12).
2 Email: M.Sun@cwi.nl

1571-0661© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.063

Object Access Protocol (SOAP) [20], which intend to provide languages that allow easy integration of services. Some other initiatives such as the Business Process Execution Language for Web Services (BPEL4WS or BPEL) [2], are focused on representing service compositions where flow of a process and bindings between services are known a priori. Despite all these efforts, composition of services still remains a highly complex task, and automatic composition of services is a critical problem. Conspicuously, the principles of component-based software development (CBSD) [18] are not yet integrated in the various methods that currently exist for custom composition of services.
Until now, most of the existing methods only describe how to communicate with a service (the syntax), but not the expected effects of such communications (the semantics). Therefore, the information that can be obtained from the service descriptions given in these approaches is limited to the signature of operations provided by the services. In particular, no information about the effect of invoking the operations can be obtained from the service descriptions.
It has been widely recognized that SOAs development is a rather intricate activ- ity and there is still no general agreement about the formal foundation of SOC. Thus the need for a formal foundation of services was identified by many researchers. Es- pecially, the development of a general theoretical framework for SOA development is one of the few prominent challenges in computer science. In this paper, we build a formal framework to support SOA design which separates the three concepts – interfaces, contracts and services. The semantics of services and contracts are given by coalgebras, which are the formal duals of algebras [10,17]. In coalgebras the state spaces are taken as black boxes to which one can only have limited access via specified operations. This aspect is one main characterization of components (and also services) and thus makes coalgebras appropriate for specifying semantics of services. The notion of bisimulation models the observational indistinguishability of service behavior for two services with the same interfaces.
Note that the notion of service is distinguished from that of contract in this paper. The latter is the specification of services, which specifies both the interface of the service and the effects of the service behavior. A service is a model of the contract which meets all the requirements in the contract. Following the unification principle of system modularization and composition in category theory proposed by J. Goguen [8], which has been used by J. Fiadeiro and T. Maibaum in parallel program design [7], we build three categories – the categories of interfaces, contracts and services respectively, and show the relation between them. In the proposed categorical framework, we show how services can be composed together.
The organization of this paper is as follows: Section 2 introduces the concepts of interfaces, contracts and services. Section 3 and Section 4 show how we can put contracts and services together to form more complex contracts and services. Rela- tionships between services, including bisimulation and bisimulation up to a natural transformation, are presented in Section 5. Section 6 investigates the refinement relations for contracts and services respectively. Section 7 presents a family of op- erators on composing services. Final remarks appear in Section 8.

Interfaces, Contracts and Services
In a service-oriented application, interfaces are used to model the seams between different services. A service encapsulates a number of operations through a public interface which provides limited access to the service. By declaring an interface, one can specify the desired behavior type of a service independent of its implementation.

Interfaces
Taking into account the nature of services, an interface should be comprised of three kinds of features: the type feature, the variable feature and the value feature. The type feature includes the information that is state-independent and gives the data context in which the service is placed. The variable feature denotes a family of variables and keeps the information that is state dependent. The value feature accounts for the observations and actions that the service may perform.
Definition 2.1 An interface is a triple I = (T, V, M) where
T denotes a family of types;
V denotes a family of variables;
M denotes a family of observations and actions, each observation or action may have parameters.
In this definition, T is a family of sets being used in the other two counterparts, and the elements of these sets are designated by types. For any interface I there is
always a type TC ∈ T which denotes the state space of the corresponding service.
V is a set of variable definitions. Every variable is an entity in which values of a
where x and T ∈ T represent the name and type of the variable respectively. Every particular type can be stored and every variable definition in V has the form x : T variable defined in V of an interface must have distinct name. All the variables in
V are accessible by clients of the interface. M is a set of method definitions. Every method in M denotes a possible operation provided by the interface and a method
declaration in M can be an action, which has the form m : TC × S → TC × O, or an observer with the form o : TC × S' → O'. The types S, S' and O, O' denotes the input and output parameter types of the corresponding methods respectively
3 . The method name m and the parameter types together gives the signature of the method. In an interface, two methods with the same name can be declared, but they must have different signature.
Often a service is specified as a collection of interfaces over a shared state space, each of which exhibiting some operations. Merging the interfaces together results in a service which provides the different kinds of operations simultaneously by the resulted interface.

3 In this paper we will focus on the case that the type S' is instantiated with the singleton 1, which collapse part of the observation structure. Since TC × 1 ∼= TC , an observer can be equally represented by a function with the form o : TC → O', which is usually called an attribute in the object-oriented programming paradigm.

Definition 2.2 For two interfaces I1 = (T1, V1, M1) and I2 = (T2, V2, M2), if no variable is declared simultaneously with different types in both V1 and V2, then I1 and I2 can be merged together and their merge I = I1 I2 is defined as I = (T, V, M), where
T = T1 ∪ T2;
V = V1 ∪ V2;
M = M1 ∪ M2.
Theorem 2.3 The merge of interfaces satisﬁes:
I  I = I.
I1  I2 = I2  I1.
I1  (I2  I3)= (I1  I2)  I3.
Interface can be built in successive steps, at each step adding declarations with the extend operator.
Definition 2.4 For a given interface I1 = (T1, V1, M1), if no variable in V1 is redeclared in V2, then the expression
extend I1 with (T2, V2, M2) defines a new interface I = (T, V, M) where
T = T1 ∪ T2;
V = V1 ∪ V2;
M = M1 ∪ M2.
Theorem 2.5 The extension of interfaces satisﬁes:
extend I1 with I2 = I1  I2.
extend I1 with (I2  I3)= extend (I1  I2) with I3.
extend I1 with (I2  I3)= (extend I1 with I2)  I3.
Interfaces can also be built by hiding some features from existing interfaces.
Definition 2.6 For a given interface I1 = (T1, V1, M1), if T2 ⊆ T1, V2 ⊆ V1,
M2 ⊆ M1, and no types in T2 is used in V1 \ V2 and M1 \ M2, then
hide (T2, V2, M2) in I1
defines a new interface I = (T, V, M) where
T = T1 \ T2;
V = V1 \ V2;
M = M1 \ M2.

Contracts and Services
The main aspect of a service that we wish to capture coalgebraically is that it has a hidden state space, which is only accessible via limited operations. Therefore, services will be naturally presented as coalgebraic models of contracts, which are the interface specifications.
We first come to the notion of contracts. It is clear that for most services it is necessary to have developers working on different services simultaneously to reduce overall schedule time. To make developers work with a reasonable degree of independence, the services and interfaces should be identified and specified with no ambiguity. A contract is such a clear, unambiguous statement, which says precisely what the essential properties of the services (interfaces) are.
Definition 2.7 A contract is a triple Ctr = (I, L, A) where
I = (T, V, M) is an interface;
L = local (TL, VL, ML) denotes a collection of local declarations;
A = (X, C) where X denotes a collection of axioms specifying properties of behavior of the services implementing the contract, and C denotes a collection of creating conditions for specifying the properties hold for initially created services, denoted by init.
For an arbitrary contract Ctr as defined in Definition 2.7, we can always associate
a functor F with its interface I. Suppose there are n actions m1, m2, ··· , mn ∈ M, with the form mi : TC ×Si → TC ×Oi for i = 1, 2, ··· ,n respectively, and k observers

o1, o2, ··· , ok ∈ M, with the form oj : TC → O'
for j = 1, 2, ··· ,k respectively.

j
'
Then let A =	1≤j≤k Oj be the cartesian product of the result types of the k

different, but simultaneously available, observers o1, o2, ··· , ok, S = Σ
Si and

O = Σ
1≤i≤n
1≤i≤n Oi be the sum of the input and output parameters of the n actions

m1, m2, ··· , mn respectively, we can get the functor
F = A × (−× O)S	(1)
The shape of this functor expresses the way the state of the corresponding service is
accessed through observers and, on the other hand, how it evolves, through actions. The behavior of a service specified by the contract with interface F given in (1)
is totally deterministic. However, there also may be other possibilities, capturing more complex behavior features. For example, one may know how to get output from input but not in all cases. Then the functor is replaced by
F = A × (−× O + 1)S
which results a service whose behavior is partial. For a given input, it returns either a
valid result or an exception value. One may also be uncertain of the result of service behavior, in the sense that the evolution of the service may be nondeterministic. In

this case the functor is typed as
F = A × P(−× O)S
where P denotes the finite powerset monad. This means that the computation of P-structure          of          such          pairs. the service action will not simply produce an output and a successor state, but a
Keeping in mind the discussion above, we may parameterize the interface functor
F by a strong monad B, acting as its behavior model and abstracting away from any concrete behavior model.
F = A × B(−× O)S	(2)
Note that here we use the exponential Y X representing the set of functions from
X to Y . For an arbitrary action m : TC × S → B(TC × O), which produces a B-structure as the result of its computation, we can get its transpose m : TC → B(TC × O)S, whose signature is specified by the functor F as given in (2).
The logic being used in axioms and creating conditions is equational logic. For
a type T , the terms over T are built from constants, λ-abstraction, application, tuples, case distinction and (co)projections. Atomic formula are equalities t1 = t2 for terms t1 and t2. Formulas are closed under the logic connectives and quantifiers. If there is a variable init : TC in a formula, then the formula is a creating condition. Otherwise, it is an axiom.
Definition 2.8 Consider a contract as defined in Definition 2.7, with functor F as- sociated with the interface. A service satisfying the contract consists of the following elements:
A carrier set U , giving an interpretation of the state space;
A transition structure α : U → F(U ) interpreting the methods of the contract in
M in such a way that the axioms in X are satisfied;
An initial state u0 ∈ U which satisfies the conditions in C.
Therefore, a service satisfying a contract is given by a seeded F-coalgebra of the
”public” interface. Furthermore, it should behave like a F'-coalgebra where F' is
(V, β : V → F'(V ), v0) such that u0 and v0 can not be distinguished from each other associated with all the methods in both M and ML: there is a seeded F'-coalgebra by the observers and actions in M. If a service p satisfies a contract Ctr, we say
that p is an implementation of Ctr.
In this picture, a service implements the operations specified in the contracts. And a service can be instantiated to different instances, which may contain the particular states that can be inspected via the attributes and methods implemented by the service.

Interface and Contract Morphisms
In the previous section we discussed interfaces, contracts as interface specifications, and single services as instantiations of contracts. One of the most important char- acterizations of SOC technology is the support for building complex applications by composition of services. Formal tools for this purpose can be borrowed from category theory, the idea is to put service units as coalgebras together to make applications, which are still coalgebras. Hence, we need to provide a notion of morphism between coalgebras of different functors (i.e. services with different in- terfaces) and build a category of these coalgebras. Before that, we first have a look at the interface morphisms and contract morphisms.
morphism    φ    :   I1   →   I2    consists    of Definition 3.1 Given two interfaces I1 = (T1, V1, M1) and I2 = (T2, V2, M2), a
A morphism of type φT : T1 → T2 such that ∀T ∈ T1, φT(T ) ∈ T2, and φT
is distributive over product and sum of types: φT(	Ti) =	φT(Ti)

and φT(Σ
1≤i≤n Ti)= 
Σ1≤i≤n φT(Ti);
1≤i≤n
1≤i≤n

∀v : T in V1, a variable φV(v): φT(T )in V2;
∀m ∈ M1 with the signature m : T → T ', a method φM(m) : φT(T ) → φT(T ')
in M2.
Intf . This category is ﬁnitely cocomplete and has (∅, ∅, ∅) as the initial interface. Proposition 3.2 Interfaces and interface morphisms together constitute a category Once the interface morphism φ : I1 → I2 is given, we can always derive a morphism between the functors F1 and F2 corresponding to the two interfaces, i.e.,
a natural transformation ϕ : F1 → F2.
Given an interface morphism φ : I1 → I2 and formula t1 = t2, the formula trans- formation φ(t1 = t2) associated with φ is φ(t1)= φ(t2). And formula transformation
is closed under logic connectives and quantifiers.
a contract morphism ψ : Ctr1 → Ctr2 is an interface morphism φ : I1 → I2 that Definition 3.3 Given two contracts Ctr1 = (I1, L1, A1) and Ctr2 = (I2, L2, A2), preserving the properties specified by A1, i.e. for every formula f in A1, we can
get the formula transformation φ(f ) from A2.
Proposition 3.4 Contracts and contract morphisms together constitute a category
Ctr. This category is ﬁnitely cocomplete.
Contracts may be built incrementally. The idea is that we build a new contract by putting together two smaller ones, which may share some features.
Definition 3.5 The merge of two contracts Ctr1 = (I1, L1, A1) and Ctr2 = (I2, L2, A2) is denoted by
Ctr = Ctr1 Ctr0 Ctr2
where Ctr0 = (I0, L0, A0) is a subcontract of both Ctr1 and Ctr2, denoting their shared parts. Generally, Ctr = (I, L, A) is defined by

I = I1  I2;
L = L1 ∪ L2;
A = A1 ∪ A2.
Ctr is in fact the pushout of the following diagram, where ψ1 and ψ2 denote the
inclusion as contract morphisms from Ctr0 to Ctr1 and Ctr2 respectively.


Ctr0
ψ2
ψ1	 C tr
ω1

J	ω2	J 
Ctr2 	 C tr
At the interface level, if Ctr = (I, L, A) is the result of merging two contract Ctr1 = (I1, L1, A1) and Ctr2 = (I2, L2, A2), while Ctr0 = (I0, L0, A0) is a subcon- tract of both Ctr1 and Ctr2, denoting their shared parts, then I can be defined in terms of a pushout on the category Intf as shown in the following diagram:
ψ1	 
0	1
ψ2	ω1
J   ω2	J 
I2 	 I 
If Ctr0 is an empty contract, i.e., there is no common part of Ctr1 and Ctr2, then we can simplify the notation and denote the merge of Ctr1 and Ctr2 as
Ctr = Ctr1  Ctr2
Theorem 3.6 The merge of contracts satisﬁes:
Ctr  Ctr Ctr = Ctr.
Ctr1 Ctr0 Ctr2 = Ctr2 Ctr0 Ctr1.
(Ctr1 Ctr0 Ctr2) Ctr0 Ctr3 = Ctr1 Ctr0 (Ctr2 Ctr0 Ctr3).
And it is easy to get the following corollary:
Corollary 3.7 The merge of contracts satisﬁes:
Ctr  Ctr = Ctr.
Ctr1  Ctr2 = Ctr2  Ctr1.
(Ctr1  Ctr2)  Ctr3 = Ctr1  (Ctr2  Ctr3).

Service Morphisms
The morphism between services can be defined as follows:
Definition 4.1 Given two contracts Ctr1 and Ctr2, with functors F1 and F2 as- sociated with their interfaces respectively. For services p1 = (U1, α1, u1) satisfying

Ctr1 and p2 = (U2, α2, u2) satisfying Ctr2. A service morphism ρ from p1 to p2
consists of the following elements:

a natural transformation ϕ : F1 → F2 derived from the corresponding interface morphism.
a morphism h : U1 → U2 which preserves the initial state h(u1)= u2 and makes
0	0
the following diagram commute:
U1 	h	 U 

α1
F (J  ϕU1 F (U )
α2
F2(h)	J 
2(U2)

Cop. The signature functor G : Cop → Intf which maps every service (seeded Proposition 4.2 Services and service morphisms together constitute a category F-coalgebra) to its interface (the functor F) and every arrow (ϕ, h) to ϕ is a coﬁ-
bration.

Proof. The composition of two arrows ρ1 = (ϕ1, h1): p1 → p2 and ρ2 = (ϕ2, h2): p2 → p3 is ρ2 ◦ ρ1 = (ϕ2 ◦ ϕ1, h2 ◦ h1) : p1 → p3. Associativity of composition identity morphism for any service p = (U, α : U → F(U ), u0) which is defined by is inherited from that in Set and Cat. It is even easier to show that there is an
(idF, idU ) where idF is the identity natural transformation from F to itself and idU
every arrow ϕ : F1 → F2, and the service p = (U, α : U → F1(U ), u0), (ϕ, idU ) is the is the identity function on the state space U . Therefore, Cop forms a category. For cocartesian arrow for ϕ and p. Therefore, G is a cofibration.	 
Often a service is specified via a collection of actions over a shared state space, each of which is specified by a contract and can be taken as an independent service. We can pack such different services together and get an aggregated service, which has an additive interface. Furthermore, its behavior is unique and already known from that of its component services.
Definition 4.3 For two independent services with different interfaces, but over the same state space U and initial state u0
p1 = (U, α1 : U → A1 × B1(U × O1)S1 , u0)

and
p2 = (U, α2 : U → A2 × B2(U × O2)S2 , u0)

The aggregated service p = p1 ⊕ p2 is defined by
p = (U, α : U → A × B(U × O)S, u0)
where the observer of p is o = ⟨o1, o2⟩, the action of p arises as the currying of
m = [B1(id × ι1) ◦ m1, B2(id × ι2) ◦ m2] ◦ dr

Theorem 4.4 Service aggregation satisﬁes 4 :
p ⊕ p ∼ p.
p1 ⊕ p2 ∼ p2 ⊕ p1.
(p1 ⊕ p2) ⊕ p3 ∼ p1 ⊕ (p2 ⊕ p3).
Comparing Services
When comparing services, one intuitively identifies models which, being non isomor- phic at the data level, behave in a similar way “as far as we can see”. Furthermore this tends to be the key ingredient in specifications of distributed systems whose “observational contents” (or parts thereof) are shared by different observers.
In [15], the notion of bisimulation was introduced in process algebra to capture this kind of observational equivalence between processes. Two processes are bisimi- lar to each other if there exists a bisimulation relationship between them, indicating how one process can be simulated by the other and vice versa. We also consider bisimulation a fundamental notion in service technology, as it seems to capture appropriately the ”black-box” characterization of services.
A categorical definition with respect to coalgebras is given by Aczel and Mendler
[1] as a relation R ⊆ U × V for two F-coalgebras (U, α) and (V, β) such that there is a F-coalgebra (R, γ) satisfying
F(π1) ◦ γ = α ◦ π1
F(π2) ◦ γ = β ◦ π2
from which we can get
⟨F(π1), F(π2)⟩◦ γ = ⟨α ◦ π1,β ◦ π2⟩
≡
F(⟨π1, π2⟩) ◦ γ = (α × β) ◦ ⟨π1, π2⟩
≡
F(idR) ◦ γ = (α × β) ◦ idR
≡
γ = α × β
≡
(u, v) ∈ R ⇔ u ∈ U ∧ v ∈ V
which means that any relation preserving the transition structures of α and β is a
bisimulation between them.
The following diagram is the corresponding instantiation for the functor F as

4 Note that the terms are not equal but bisimular to each other in the theorem. The formal definition of bisimularity will be given in Section 5.

given in (2) underlying our model of services.

U ¸,	π1
R 	π2	 V 

α	γ	β
J	J	J 
A × B(U × O)S ¸,	 A × B(R × O)S 	 A × B(V × O)S
A×B(π1×O)S	A×B(π2×O)S
Then, let α = ⟨oα, mα⟩, β = ⟨oβ, mβ⟩, γ = ⟨oγ, mγ⟩, a simple calculation yields that
α ◦ π1
=(A × B(π1 × O)S) ◦ ⟨oγ, mγ⟩
=⟨oγ, B(π1 × O)S ◦ mγ⟩
=⟨oγ, B(π1 × O) ◦ mγ⟩
and, similarily, β ◦ π2 = ⟨oγ, B(π2 × O) ◦ mγ⟩. A direct consequence of these equal- ities is the fact that, for any ⟨u, v⟩∈ U × V , the following equations hold:
oγ⟨u, v⟩ = oαu = oβv
B(π1 × O) ◦ mγ⟨u, v⟩ = mαu
B(π2 × O) ◦ mγ⟨u, v⟩ = mβv
We may rephrase such results as a proof rule for bisimulation, whose shape depends
B = P, the proof rule resembles the definition of bisimulation for classical labelled on the adopted behavior monad B. For example, for the nondeterministic case transition systems.
⟨u, v⟩∈ R ⇐⇒ oαu = oβv
∧ ∀s ∈ S
( ∀⟨u', t⟩∈ mα⟨u, s⟩ . ∃⟨v', t⟩∈ mβ⟨v, s⟩ . ⟨u', v'⟩∈ R
∧
∀⟨v', t⟩∈ mβ⟨v, s⟩ . ∃⟨u', t⟩∈ mα⟨u, s⟩ . ⟨u', v'⟩∈ R)

Definition 5.1 Let p = (U, α : U → FU, u0) and q = (V, β : V → FV, v0) be services over the same interface I. They are said to be bisimilar, written p ∼ q, iff there is a F-bisimulation R ⊆ U × V containing the pair ⟨u0, v0⟩.
tions: A map h : U → V is a homomorphism between (U, α) and (V, β) iff its graph There is a close relationship between coalgebra homomorphisms and bisimula- is a bisimulation between (U, α) and (V, β). Is there any corresponding results for
service morphisms? This question leads to the following definition of bisimulation up to φ.
Definition 5.2 Let p = (U, α : U → FU, u0) and q = (V, β : V → F'V, v0) be ser- vices over interface I and I' respectively, and φ : F → F' be a natural transformation

as given in Definition 4.1. Then p and q are said to be bisimilar up to φ, written
p ∼φ q, iff (U, φU ◦ α, u0) ∼ q.
Refinement
It is clear that if we want to develop applications of any size, we must be able to decompose their description into different services and compose the application from the developed services. This is just as true when the description is a contract as it is when it is a service.
In general, the construction of services is a process which involves a system- atic trajectory for transformation, starting from “abstract” descriptions, leading to “concrete” ones. Refinement can be defined, in broad terms, as such a transforma- tion. It changes the representation of a service, entailing a notion of substitution, but not necessarily equivalence.
In this section, we investigate two levels of refinement relations. We start by in- troduce the refinement of contracts, and then the refinement of services is discussed.

Contract Reﬁnement
In general, a refinement of contracts involves two contracts: an abstract one and a concrete one as its refinement. The idea involved in contract refinement is that the concrete contract adds implementation details which are left open in the abstract contract. For example, it can reduce the level of underspecification / nondetermin- ism.
Contract refinement requires validity of the properties in the abstract contract after transformed into the concrete one. That is, if contract Ctr2 is a refinement of Ctr1, we need to know whether Ctr2 is a “correct” refinement of Ctr1. We say that Ctr2 is correct if it meets the following two requirements:
property preservation: All properties that can be proved about Ctr1 can also be proved for Ctr2 (but not in general vice versa);
substitutivity: A component of Ctr1 in a system can be replaced by a component of Ctr2 and the resulting new system should implement all the functionalities of the earlier system.
Keeping this idea in mind, we can get the following definition describing contract refinement:

we say that Ctr2 is a refinement of Ctr1, denoted by Ctr2 ± Ctr1 if there is an Definition 6.1 Let Ctr1 = (I1, L1, A1) and Ctr2 = (I2, L2, A2) be two contracts, interface morphism φ : I2 → I1, such that for every component p = (U, α, u0) as an implementation of Ctr2, p' = (U, φU ◦ α, u0) is an implementation of Ctr1.
Theorem 6.2 Contract reﬁnement satisﬁes:
Ctr ± Ctr.
If Ctr2 ± Ctr1 and Ctr3 ± Ctr2, then Ctr3 ± Ctr1.

If Ctr2 ± Ctr1, then for any Ctr, Ctr2  Ctr ± Ctr1  Ctr.
Service Reﬁnement
The basic idea of service refinement, which is called the principle of substitutivity, is rather simple: Intuitively, it is acceptable to replace one service by another, provided it is impossible for a user of the services to observe that the substitution has taken place. If a service can be acceptably substituted by another, then the second service is called a reﬁnement of the first one.
There is a diversity of ways of understanding both what substitution means, and what such a transformation should seek for. For services, refinement can be addressed at two different levels (at least), namely, behavioural and architectural reﬁnement.
The behavioral reﬁnement typically relates services of the same interface, where the refinement is based on a simulation preorder between the two services. Since morphisms between services of the same interface are in fact coalgebra homo- morphisms which, therefore, entail bisimilarity, we built a weaker notion of a morphism between services, which still preserve the source service dynamics.
The architectural reﬁnement is used for decomposing a service with a specified behavior into a distributed architecture, i.e., a family of services being combined together, which is also modelled as a concrete coalgebra. The refined service is also a “behavioral refinement” of the given service with respect to the interface of the given service.
An order ≤ on a Set endofunctor F is defined in [9] as a functor ≤ (concretely, mapping every set U into a collection of preorders (FU, ≤FU )). In the sequel ≤ will be referred to as a reﬁnement preorder.

F-coalgebras p1 = (U1, α1 : W1 → FU1) and p2 = (U2, α2 : U2 → FU2). A forward Definition 6.3 Let F be an extended polynomial functor on Set and consider two morphism h : p1 → p2 with respect to a refinement preorder ≤, is a function from
U1 to U2 such that
F h ◦ α1 ≤ α2 ◦ h
Dually, h is called a backwards morphism if
α2 ◦ h ≤ F h ◦ α1
p ± q, if there exist services r and s such that p ∼ r, q ∼ s and r ±F s, where Definition 6.4 Given services p and q, p is a behavioural refinement of q, written r ±F s stands for the existence of a (seed preserving) forward morphism from r to
s.
In the case of large-scale applications consisting of many services, it is not prac- tical to consider the whole system each time we want to refine one of its services. On the contrary, we prefer to do the refinement steps locally for the particular ser- vice being considered. Fortunately, behavioural refinement is well behaved in this respect.

Behavioral refinement characterizes what it means to preserve service behavior. But if our framework is based on behavioral refinement alone, the inability to change the syntactic interface will force us to work at the same level of interface abstraction throughout the whole development process. As a result, the development will be unnecessarily complex and inflexible. Furthermore, when we develop an application, it is certainly not enough to characterize its black-box behavior only, we also need to capture its internal structural aspects. For these purposes, we introduce the notion of architectural reﬁnement in [14]. All the refinement steps in an architectural refinement are required to respect the architectural structure, and preserve the application behavior. Thus, it is a generalization of behavioral refinement.
Due to the length limitation, we only briefly introduce the notion of hehavioural refinement in this paper. More details about refinement for coalgebras can be found in [14]. Furthermore, taking QoS into consideration, we need to define a wider range of behavior. For example, an essential aspect of behavior of services is the execution time of certain (sequence of) operations. In other words, refinement of services should preserve all kinds of temporal constraints. We will not discuss such problems in this paper and leave them as future work.



Composing Services

In this section, we move on to a brief introduction of service composition. Compo- sition enables prefabricated services to be reused by rearranging them in ever-new composites. Resulting composite services can be used as basic services in further compositions or offered as complete applications and solutions to service clients. Or- thogonal to the vertical refinement of concrete services from abstract specifications, composition operations are needed to support the horizontal decomposition of the applications into component services. That means, an application is represented by specifying its component services and their composition. By stating how services are composed together, we can get a view of the architecture of the application.
In [4,13] two different frameworks for defining the combinators of coalgebras are investigated, and [5,3] provides a summarization for these two approaches. In this section, we will have a brief overview of the operators using the heterogeneous framework adopted by [13] for composition of services.
One widely used combinator for composing services is sequential composition, which connects the output interface of one service to the input interface of another, if the interfaces are declared to be compatible. This operator is formally defined as follows.

Definition 7.1 Let p = (Up, αp : Up → Ap × Bp(Up × K)I, up ∈ Up) and q = (Uq, αq : Uq → Aq × Bq(Uq × O)K, uq ∈ Uq) be two services. Their sequential composition is formed by placing them side by side and connecting the output of p

to the input of q 5 . Formally, the sequential composition of p and q is given by
p; q = (U, αp;q : U → A × B(U × O)I , ⟨up, uq⟩∈ U )
where U = Up ×Uq, A = Ap ×Aq, B = BpBq 6 . And the dynamics αp;q is represented by op;q : U → A and ap;q : U × I → B(U × O). The detailed definition is given as follows:


and
op;q : Up × Uq
⟨op,oq ⟩
−→ Ap × Aq

ap;q : (Up × Uq) × I
τ Bp
xr
−−−−→ Up × I × Uq
B (a·xr)
ap×id
−−−−→	p(Up × K) × Uq

−−−r−→ B (U × K × U )
−−−−−→ B (U × (U
× K))

p	p	q
B (id×a )
p	p	q
B τ Bq

−−−−−−→ B (U × B (U
× O))	l	B (B (U
× (U
× O)))

BpBq a◦
p	p	q	q
−−−−→
p	q	p	q

−−−−−→ BpBq(Up × Uq × O)
where a and s are two isomorphisms representing associativity and commutativity
respectively:
a : A × B × C → A × (B × C)
s : A × B → B × A
a◦ is the inverse of a, and xr = a◦ ◦ (id × s) ◦ a is the exchange morphism which changes the position of factors in the multiplicative expression:
xr : A × B × C → A × C × B
Services can be aggregated in a number of different ways, besides the ‘pipeline’
been defined. The restriction T and relabelling −[γ] shows the possibilities of chang- style modelled by the sequential composition. In [13], a family of operators have ing interfaces of services. Given two services p and q satisfying specified conditions,
their external choice p ☒ q, parallel composition p ☒ q and concurrent composi- tion p q are defined separately by exploiting the universal constructions in the category Cop. When interacting with p ☒ q, the environment will be allowed to choose either to input a value of input type of p or that of q, which will invoke the corresponding service (p or q, respectively), producing the relevant output. On its turn, parallel composition corresponds to a synchronous product: both services are executed simultaneously when triggered by a pair of legal input values. Note, however, that the behavior effect, captured by monad B, propagates. For example,

5 In general, the output type K of p does not need to be same with that of the input channel of q, which we denote by L. The condition that K ⊆ L is enough. But for simplicity, we still let L = K in the following definition.
6 The simple composition of the corresponding functors Bp and Bq does not always lead to new monads. In order to define a new monad based on BpBq for two given monads Bp and Bq , a natural transformation
λ : Bq Bp → BpBq satisfying a number of conditions should exist. The more detailed result on this topic can be found in [6].

if B can express behavioral failure and one of the arguments fails, the product will fail as well. Finally, concurrent composition combines choice and parallel, in the sense that p and q can be executed independently or jointly, depending on the input supplied. Generalized interaction is catered through a sort of ‘feedback’ mechanism on a subset of the input ends, which can be defined similarly as that in [4].

Concluding Remarks
In this paper, we have shown how a formal framework for assisting service-oriented applications development can be defined around the notions of interface, contract, service and corresponding notions of morphisms. In such a formalism, services are described by coalgebras whose signature functors are derived from the corresponding interfaces, and satisfy the axioms given in corresponding contracts. This work pro- vides a unifying framework for different notions (interfaces, contracts and services) in SOA development.
With respect to the composition of services, we adopt the categorical approach which can be traced back to the work of Goguen et al[8]. Indeed, the category of services forms the cofibration over the corresponding category of interfaces, and thus provides the starting point for the definition of combinators for services. Preliminary work can be found in [13].
Concerning locality of services in the whole application, a family of operators for composing services are introduced and a framework for building application by aggregating services is provided. This allows developers to decompose an application into services, discover different services separately and finally build the system by composing the services.
One immediate topic for future work is to investigate the composability of ser- vices for replaceability, compatibility and conformance. Another research challenge is to integrate QoS aspects of services [12] into the coalgebraic model and build a QoS-aware calculus for composing services.

References
P. Aczel and N. Mendler. A final coalgebra theorem. In D.H. Pitt, D.E. Rydeheard, P. Dybjer, A. Pitts, and A. Poigne, editors, Proceedings of Category Theory and Computer Science, volume 389 of LNCS, pages 357–365. Springer, 1989.
Tony Andrews, Francisco Curbera, Hitesh Dholakia, Yaron Goland, Johannes Klein, Frank Leymann, Kevin Liu, Dieter Roller, Doug Smith, Satish Thatte, Ivana Trickovic, and Sanjiva Weerawarana. Business process execution language for web services version 1.1, 2003. http://www-106.ibm.com/developerworks/webservices/library/ws-bpel/ .
Lu´ıs S. Barbosa, Sun Meng, Bernhard K. Aichernig, and Nuno Rodrigues. On the semantics of componentware: a coalgebraic perspective. In Jifeng He and Zhiming Liu, editors, Mathematical Frameworks for Component Software - Models for Analysis and Synthesis. World Scientific, 2006.
Lu´ıs Soares Barbosa. Components as Coalgebras. PhD thesis, Universidade do Minho, Braga, Portugal, 2001.
Lu´ıs Soares Barbosa and Sun Meng. Generic components. In Graham Hutton, editor, Proceedings of First APPSEM-II Workshop, Nottingham, March 2003. APPSEM Network Report.
Michael Barr and Charles Wells. Toposes, Triples and Theories. Springer, 1985.


Jos´e Luiz Fiadeiro and Tom Maibaum. Categorical Semantics of Parallel Program Design. Science of Computer Programming, 28:111–138, 1997.
Joseph Goguen. Categorical Foundations for General Systems Theory. In F. Pichler and R. Trappl, editor, Advances in Cybernetics and Systems Research, pages 121–130. Transcripta Books, 1973.
Bart Jacobs and Jesse Hughes. Simulations in coalgebra. In H. Peter Gumm, editor, Elect. Notes in Theor. Comp. Sci. (CMCS’03 - Workshop on Coalgebraic Methods in Computer Science), volume 82, pages 245–263, Warsaw, April 2003.
Bart Jacobs and Jan Rutten. A tutorial on (co)algebras and (co)induction. Bulletin of the European Association for Theoretical Computer Science, 62:222–259, 1997.
M. P. Papazoglou and D. Georgakopoulos. Service Oriented Computing. Comm. ACM, 46(10):25–28, 2003.
Sun Meng. QCCS: A Formal Model to Enforce QoS Requirements in Service Composition. In J. He and
J. Sanders, editors, Proceedings of 1st IEEE & IFIP International Symposium on Theoretical Aspects of Software Engineering, TASE’07, pages 389–400. IEEE Computer Society, 2007.
Sun Meng and Bernhard Aichernig. A Coalgebraic Calculus for Component-based Systems. In Hung Dang Van and Zhiming Liu, editor, Proceedings of the Forkshop on Formal Aspects of Component Sofsware FACS’03, pages 27–46, 2003.
Sun Meng, Lu´ıs S. Barbosa, and Zhang Naixiao. On Refinement of Software Architectures. In
Proceedings of ICTAC’05, volume 3722 of LNCS, pages 482–497. Springer, 2005.
Robin Milner. Communication and Concurrency. Prentice Hall, 1989.
Michael P. Papazoglou, Paolo Traverso, Schahram Dustdar, and Frank Leymann. Service-Oriented Computing: State of the Art and Research Challenges. IEEE Computer, pages 64–71, 2007.
Jan Rutten. Universal coalgebra: a theory of systems. Theoretical Computer Science, 249:3–80, 2000.
Clemens Szyperski. Component Software – Beyond Object-Oriented Programming. Addison-Wesley, 1998.
Universal Description, Discovery, and Integration (UDDI) v3.0. http://www.uddi.org/.
W3C. Simple object access protocol (soap) v1.2. http://www.w3.org/2000/xp/Group/ .
W3C. Web Service Description Language (WSDL) 1.1. http://www.w3.org/TR/wsdl .
