Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 283 (2012) 29–51
www.elsevier.com/locate/entcs

An Introduction to the Topological Theory of Distributed Computing with Safe-consensus
Rodolfo Conde1,2 and Sergio Rajsbaum3,4
Instituto de Matema´ticas Universidad Nacional Auto´noma de M´exico
Ciudad Universitaria, M´exico D.F. 04510, M´exico

Abstract
The theory of distributed computing shares a deep and fascinating connection with combinatorial and algebraic topology. One of the key ideas that facilitates the development of the topological theory of distributed computing is the use of iterated shared memory models. In such a model processes communicate through a sequence of shared objects. Processes access the sequence of objects, one-by-one, in the same order and asynchronously. Each process accesses each shared object only once. In the most basic form of an iterated model, any number of processes can crash, and the shared objects are snapshot objects. A process can write a value to such an object, and gets back a snapshot of its contents.
The purpose of this paper is to give an introduction to this research area, using an iterated model based on the safe-consensus task (Afek, Gafni and Lieber, DISC’09). In a safe-consensus task, the validity condition of consensus is weakened as follows. If the first process to invoke an object solving a safe-consensus task returns before any other process invokes it, then the process gets back its own input; otherwise the value returned by the task can be arbitrary. As with consensus, the agreement requirement is that always the same value is returned to all processes.
A safe-consensus-based iterated model is described in detail. It is explained how its runs can be described with simplicial complexes. The usefulness of the iterated memory model for the topological theory of distributed computing is exhibited by presenting some new results (with very clean and well structured proofs) about the solvability of the (n, k)-set agreement task. Throughout the paper, the main ideas are explained with figures and intuitive examples.
Keywords: distributed system, wait-free, set agrement, consensus, safe-consensus, topology.


Introduction
The theory of distributed computing is an actively developed field of computer sci- ence that shares a deep and fascinating connection with combinatorial and algebraic topology. One of the key ideas that facilitates the development of the topological

1 Supported by a CONACyT grant.
2 Email: rodolfo@math.unam.mx
3 Supported by DGAPA-PAPIME and PAPIIT grants.
4 Email: rajsbaum@math.unam.mx

1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.05.004

theory of distributed computing is the use of iterated shared memory models, in- troduced in [10]. In such a model processes communicate through a sequence of shared objects. Processes access the sequence of objects, one-by-one, in the same order and asynchronously. Each process accesses each shared object only once.
In the most basic form of an iterated model, any number of processes can crash, and the shared objects are snapshot objects. A process can write a value to such an object, and gets back a snapshot of its contents. It is known that this model is equivalent to the standard wait-free read/write shared memory model [10,15], but its runs are more structured and easier to analyse than the runs in the standard shared memory model. The recursive nature of the iterated shared memory model was instrumental for the results in [10] and for the proof of the Asynchronous computability theorem of [19]. This theorem uncovered the intimate connection that exists between topology and distributed computing. Extensions of the basic iterated model have also been studied, where the processes communicate through a sequence of objects more powerful than snapshot objects [16] or where the asynchrony of the system is limited to model failure detectors [22]. For an overview of the iterated approach see [21].
The purpose of this paper is to give an introduction to this research area (for the non-specialist), using an iterated model based on the safe-consensus task of Afek, Gafni and Lieber [2]. In a safe-consensus task, the validity condition of consensus
[13] is weakened as follows. If the first process to invoke an object solving a safe- consensus task returns before any other process invokes it, then the process gets back its own input; otherwise the value returned by the task can be arbitrary. As with consensus, the agreement requirement is that always the same value is returned to all processes. The safe-consensus task was introduced in [2] (as a generalization of the consensus problem) to show the equivalence of the g-tight-group-renaming task of [3] and the consensus task for g processes. The paper also proves that the safe-consensus task is as powerful as consensus.
We define an iterated safe-consensus-based shared memory model in two ways: the classical fashion and the “topological way”. After that, we show its usefulness, and its connection with topology by exhibiting some new results (with easy, well structured proofs) about the solvability of consensus and (n, k)-set agreement [11] (where n is the number of processes). While in the consensus task processes agree on at most one value, the (n, k)-set agreement task allows processes to agree on at most k different values.
The iterated model studied in this paper, is an extension of the iterated model of [10] with the power of safe-consensus objects. A safe-consensus object is a shared object that receives input values from the processes and returns to the processes output values consistent with the safe-consensus task specification (Section 3). The new model allows the processes to communicate by using a sequence of snapshot ob- jects and safe-consensus objects. As with any iterated model, computation proceeds in iterations, accessing copies of the objects, asynchronously, and in the same order. In each iteration, each process first writes to the shared memory, then it invokes a safe-consensus object and finally it takes a snapshot of the shared memory. As the

purpose of this paper is to give an easy to read introduction to the area, we will put an additional restriction in our new extended model: Each safe-consensus object in the sequence must be invoked by all the processes (and in the same order). We call this model of computation the iterated shared memory with full safe-consensus objects (IFSC) model.
Specifically, the results we present are:
The (n, n − 1)-set agreement task can be implemented in the IFSC model using only one safe-consensus object (with a simple one-round protocol, Theorem 3.2);
It is impossible to solve the consensus problem for n processes in the IFSC model (Theorem 3.6).
These results say that the IFSC model is indeed more powerful than the basic it- erated model, because (n, n − 1)-set agreement cannot be solved using only shared memory [8,18,23]. But the IFSC model still has limitations as it cannot solve consensus (while consensus is solvable using safe-consensus objects [2] without re- strictions). This impossibility does not come from the fact that we are working in an iterated model, rather, it is caused by the requirement that processes access the same safe-consensus object altogether in each iteration.
Also, in connection with the topological theory of distributed computing, to represent executions of protocols in the iterated model (and in the extended IFSC model), we will have something to say about Theorem 3.6. It is known that the protocol complexes in the iterated shared memory model are connected and because of this, it is impossible to solve consensus [7,19]. In this paper, we argue that the protocol complexes in the IFSC model are disconnected, yet, these protocols cannot solve consensus. The discussion about Theorem 3.6 is in Section 3.
In summary, our aims in this introductory paper include explaining:
How to analyze protocol complex connectivity in an iterated model;
how does the power of the communication objects affects the connectivity of a protocol complex;
and what are the consequences of connectivity for task solvability.
As mentioned above, the iterated shared memory model has been extended with objects more powerful than read/write registers [16], but these objects were at most as powerful as the set agreement task. To our knowledge, this is the first time in which an attempt is made to study an iterated model by adding objects as powerful as the consensus problem. Nevertheless, we stress that our intention in this paper is not to provide new results, but to give an introduction to the area. In a sequel to this paper [12] we study in more depth iterated models extended with safe-consensus objects. One of these models is the IFSC model.
The outline of the paper is as follows. In Section 2 we give an introduction to the basic concepts of the iterated shared memory model (in the usual combinatorial way), and then we show how to represent the behavior of protocols in terms of combinatorial topology, using simplicial complexes. Here we also give the definition

of the (n, k)-set agreement task [11], the task in which we will focus our attention. In Section 3 we extend the basic iterated model of shared memory, adding the power of safe-consensus objects to obtain the IFSC model described above. We study the IFSC model using the tools introduced in Section 2. Throughout the paper, we explain the main ideas behind concepts and proofs with figures and simple examples. Section 4 contains our concluding remarks.
The iterated shared memory model
We now introduce the iterated shared memory model of distributed computing [10], and explain how the runs of protocols in this model have a well behaved geometric structure given in terms of simplicial complexes.
Basic model of computation
Our formal model is standard, see e.g. [6], so we do not state it here in detail. A system consists of n processes p1,..., pn. A process is a deterministic state machine, which has a (possible infinite) set of local states, including a subset called the initial states and a subset called the output states. Processes communicate by means of a shared memory, structured as a sequence of arrays SM (i) [1 ··· n] (i ≥ 0) of a finite number of single-writer multi-reader atomic registers. Each register may attain values from some domain, which includes a special “undefined” value ⊥. We make no assumptions about the size of the registers, and therefore we may assume that each process pi can write its entire state in a single register. Each shared memory SM (i) provides two atomic operations that can be used at most once by a process.
SM (i).write(): writes some value to the register SM (i) [j], where j is the id of process pj.
SM (i).snapshot(): returns a copy of the whole shared memory array SM (i).
We assume w.l.o.g. that a process always alternated write and snapshot opera- tions. Notice that the snapshot operation can be implemented in read/write shared memory [1].
A (system) state consists of the local states of the processes and all the registers in the shared memory. Formally, a state is a vector
S = ⟨s1,..., sn; SM⟩,
where si is the local state of process pi and SM is the shared memory of the system. An initial state is a state in which every local state is an initial local state and all register in the shared memory are set to ⊥. A decision state is a state in which all local states are output states.
Events and round schedules
An event of the system is performed by a single process pi, which applies only one of the following actions: a write (W) or read (R) operation (i.e. a snapshot). Any

of these operations may be preceded/followed by some local computation, formally a change of the process to its next local state. It is convenient to consider events performed concurrently. If E is any event and pi1 ,..., pik are processes, then we denote the fact that pi1 ,..., pik execute concurrently the event E by E(i1,..., ik). A round schedule is a finite sequence of the form
E1(j11,..., j1p1 ),..., Er(jr1,..., jrpr ),
that encodes the way in which processes perform the events E1,..., Er. For example the round schedule given by
W(1, 3), R(1, 3), W(2), R(2),
means that processes p1, p3 perform the write and read events concurrently; af- ter that, p2 executes solo its read/write events. Similarly, the round schedule W(1, 2, 3), R(1, 2, 3) says that p1, p2, p3 execute concurrently the write/read oper-
ations. Let n¯ = {1,..., n}. Then we denote E(1,..., n) by E(n); if A ⊂ n and
n − A = {i1,..., iq}, E(n − A) denotes E(i1,..., iq); when A = {i}, E(n − A) is
E(n − i).
Decision tasks
A decision task Δ is a relation that has a domain I of input values and a domain O of output values; Δ specifies for each assignment of the inputs to processes on which outputs processes can decide. Examples of tasks includes consensus [13], renaming [9,3] and the set agreement task [11] (to be defined later).

Figure 1. General form of a protocol in the iterated model (code for pi)


The basic iterated model
The state machine of each process pi models a local protocol Ai, that determines the steps taken by pi. We assume that all local protocols are identical; i.e. Pro- cesses have the same state machine. A protocol is a collection A of local protocols A1,..., An. In this paper, we are interested in protocols in the iterated read/write shared memory model of distributed computing. From now on we just call it the basic iterated model. For the sake of simplicity, we give protocols specifications us- ing pseudocode and we establish the following conventions: A lowercase variable

denotes a local variable, with a subindex that indicates to which process it belongs; the shared memory (which is visible to all processes) is denoted with uppercase letters. Figure 1 shows the general form of a protocol in the iterated model.
An execution of a protocol A is a finite or infinite alternating sequence of states and round schedules S0, π1,..., Sk, πk+1,..., where S0 is an initial state and Sk is the resulting state of applying the sequence of events performed by the processes in the way described by πk. An r-round partial execution of A is a finite execution of A of the form S0, π1,..., Sr—1, πr, Sr, that is, an execution of A until the end of round r. A state P is said to be reachable in A if there exists an r-round partial execution of A (r ≥ 0) that ends in the state P and when there is no confusion, we just say that S is reachable.
We identify two special components of each process’ states: an input and an output. It is assumed that initial states differ only in the value of the input compo- nent; moreover, the input component never changes. The protocol cannot overwrite the output, it is initially ⊥; once a non-⊥ value is written to the output component of the state, it never changes; when this occurs, we say that the process decides. The output states are those with non-⊥ output value.
A protocol solves a decision task Δ if any finite execution α can be extended to an execution αj in which all processes decide on values which are allowable (accordingly to Δ) for the inputs in α. Because the outputs cannot be overwritten, if a process has decided on a value in α, it must have the same output in αj. This means that outputs already written by the processes can be completed to outputs for all processes that are permissible for the inputs in α.
A protocol is wait-free if in any execution of it, a process either it has a finite number of events or it decides. This implies that if a process has an infinite number of events, it must decide after a finite number of events.
We do not require the processes to halt; they solve the decision task and decide by writing to the output component; processes can continue to participate. We typically consider the behavior of a process until it decides, and therefore, the above distinction does not matter.

Properties of states
Let A be a protocol in the iterated model and let S, R be states, we say that R is a successor of S in A, if there exists an execution α of A such that
α = S0, π1,..., Sr = S, πr+1,..., πr+k, Sr+k = R, ..., 

i.e., starting from S, we can run the protocol A k rounds (for some k ≥ 0) such that the system enters state R. If π is any round schedule and S is a state, the successor of S in A obtained by running the protocol (starting in the state S) one iteration with the round schedule π is denoted by S · π.
Two states S, P are said to be adjacent if there exists a non-empty subset X ⊆ n such that all processes with ids in X have the same local state in both S and P . That is, for each i ∈ X, pi cannot distinguish between S and P . We denote this

by S ∼X
P and when X = {i} we use the notation S ∼i
P . States S and P are

connected if we can find a sequence of states S = P1,..., Pr = P such that for all j
with 1 ≤ j ≤ r − 1, Pj and Pj+1 are adjacent.

Equivalence of the iterated model with the standard model
It would seem that the iterated model that we have defined is too restrictive: a process cannot go back and read again the same shared array. Moreover, all pro- cesses must access all the shared arrays in the same order. Because of this, one may think it does not have full generality when compared with the more standard, non-iterated wait-free shared memory model, that does not have the restrictions imposed to protocols in the iterated model. The crucial question is: Does there exists a task that is solvable in the wait-free standard model and it is not solvable in the iterated model? The answer is no. Every task that is solvable in the wait- free standard model is also solvable in the iterated model. This is proved using an algorithm that simulates the standard model in the iterated model, first in [10], and more recently in [15]. Therefore, there is no loss of generality (for computability purposes) in considering only protocols in the iterated model.


The geometry of the Iterated model
The framework we have described to study distributed algorithms can be given in geometric terms, using simplicial complexes. We assume that the reader is familiar with basic concepts from combinatorial topology [5,4].
We begin with an example, let n = 3 and suppose processes p1, p2 and p3 execute a protocol A in the iterated model with their input values all equal to 0. In the first round of A, there are several possible ways for the processes to execute their actions of reading and writing to the shared memory; one possibility is that p1 and p2 execute concurrently the basic operations and later, p3 executes the same steps. This is represented by the round schedule W(1, 2), R(1, 2), W(3), R(3). At the end of the round, the local view of the shared memory of p1 and p2 only contains the values these processes wrote; they cannot see the value written by process p3 because they executed faster that p3, which wrote its information in the shared memory after p1 and p2 executed their reads (snapshots) operations 5 . But p3’s local view of the memory contains the data of the three processes, so that p3 can see all the information written by p1 and p2. This (system) state (which is reachable in A) can be represented by a 2-simplex Δ2 as shown in the following figure.



5 This models the possibility that p3 is just running slower that p1 and p2 and also it models the situation in which p3 crashes and does not take any steps at all.

000






00⊥	00⊥
Each vertex of Δ2 is labeled with the process id and the local state of that process (this includes the local view of the memory). Now consider the case where the three processes execute the shared operations concurrently (this is described with the round schedule W(1, 2, 3), R(1, 2, 3)) and the views they have of the memory at the end of the first round. As in the previous case, we represent this state as a 2-simplex Δj .
000	⊥⊥0








00⊥
000
000

This time, all the processes can see each other’s input values and because p1 and
p2 have a different local view of the memory, they can distinguish between the
state given by Δj and the previous one (represented by Δ2); but p3 cannot tell the
difference, because it has exactly the same information in both states. This is the

reason why the simplexes Δ2 and Δj
have the vertex with p3’s id as a common face,

p3 cannot distinguish between the two states, because in both of them it has the same local state. In a similar way, the simplex that represents the reachable state in A obtained by executing the first round of the protocol in the way described by
W(3), R(3), W(1, 2), R(1, 2), is adjacent to Δj (this time, p1 and p2 cannot distin-
guish).
We can represent all the possible reachable states in the first round of A as 2-simplexes and construct a simplicial complex, which we call the 1-round protocol complex of A (Figure 2 (a)). It is just a subdivided triangle. Each simplex in this complex represents a state S that the system can reach after the processes execute the first round of A with a round schedule that makes the protocol enter into state S.
In the second round, processes start to execute the protocol with the state they had at the end of the first round, and then all the possible round schedules of the first round can be repeated. If we represent the state that the processes have at


	
(a)	(b)
Figure 2. The protocol complex for a 3-process protocol in the iterated model after the execution of the first round (a) and the second round (b).

the beginning of round two as the corresponding 2-simplex of the 1-round protocol complex of A (that is, as a reachable state of the first round of the protocol) then using the fact that we are working with an iterated model of computing, we can encode all the possible states of the system at the end of round two as a subdivision of the triangle that represents the state that the processes had at the end of round one. This subdivision is identical to the protocol complex of round one, so that we can describe all the possible reachable states in round two of A as the simplicial complex of Figure 2 (b), this is the 2-round protocol complex of A. Notice that this complex is also a subdivided triangle, with several subcomplexes isomorphic to the protocol complex of round one. This behavior is going to repeat itself for all subsequent rounds– the k-round protocol complex for a protocol in the iterated model for three processes will be a subdivision of the 2-simplex. To obtain the complex of a subsequent round, we just take the complex of the previous round and replace each simplex in it with the complex of Figure 2 (a) and we can see that the k-round protocol complex has a simple and elegant recursive structure.
In general, if we have n + 1 processes, each possible initial or final local state of a process is modeled as a vertex v = (i, smi), a pair consisting of a process id i and the local state smi of process pi. We say that the vertex is coloured with the process id. A set of n + 1 mutually compatible initial or final local states is represented as an n-simplex Δn and with this we model a possible system state. Given a protocol A in the iterated model, where each process pi receives the input value vi (i = 1,...,n + 1), for each round number r ≥ 0 all the possible reachable states in A at the end of round r are represented as a n dimensional complex, the r-round protocol complex (for brevity, we just say the “protocol complex”), PA, in which each vertex is labeled with a process id and that process state at the end of round r. Thus, each simplex in PA corresponds to an equivalence class of executions

of A that “look the same” to the processes at its vertices. It is argued in [10] that
PA is always a subdivided n-simplex.
There is more information about the protocol complex in [19]. In fact, the definition we have presented of the r-round protocol complex PA (associated with the input values that the processes have when they begin executing the protocol
A) is closely related with the notion of a span in [19, Definition 4.4, page 884]. Herlihy and Shavit define the protocol complex as a bigger geometric structure which depends on all the possible input values of processes and all possible executions of a protocol A. However, for most cases, it is sufficient to work with the definition of protocol complex we have given. We find our definition sufficient for the purposes of this introductory paper.

Set agreement tasks
We are interested in the (n, k)-set agreement task, where n is the number of processes and k < n. This task was proposed the first time in [11] and it has been fundamental in the study of distributed computing. It is described as follows:
The (n, k)-set agreement problem. In this task, every process starts with some initial input value taken from a set I (|I| ≥ n) and must output a value such that:
Termination: Each process must eventually output some value.
k-Agreement: The set of output values from all processes must be of size at most
k.
Validity: If some process outputs v, then v is the initial input of some process. The set agreement task is a natural generalization of consensus, which corre-
sponds to the (n, 1)-set agreement task. That is, processes must agree on a unique
output value. Before the set agreement task was defined, it was well known that the consensus problem is not solvable in the presence of even only one faulty process [13]. This impossibility result uses simple graph connectivity arguments. But since the (n, k)-set agreement task was conceived, it was an open question whether it could be solved in the wait-free shared memory model (with the parameters 2 ≤ k < n), until 1993 when three independent teams [8,23,18] showed that there is no wait-free protocol that can solve set agreement.
Theorem 2.1 ([8,23,18]) For 1 ≤ k < n, the (n, k)-set agreement task has no wait-free read/write solution in the iterated shared memory model.
As the iterated model is equivalent to the usual standard wait-free shared mem- ory model, Theorem 2.1 implies the impossibility to solve the set agreement task in the standard model. It is worth noticing that the set agreement task is not the only distributed problem in which topological techniques have been useful. Other examples are musical benches [14], renaming [19] and loop agreement [17] among others.

An enrichment of the iterated model
In this section, we add more powerful shared objects to the iterated model, and study the solvability of the set agreement task in this extended model.
The extended iterated model with safe-consensus
The objects we will add to the iterated model are based on a variant of the consensus problem, which is called safe-consensus.
The safe-consensus task. In this task, every process starts with some initial input value taken from a set I and must output a value such that:
Termination: Each process must eventually output some value.
Agreement: All processes output the same value.
Validity: (1) If a process pi starts executing the task and outputs before any other process starts executing the task, then the task’s output is pi’s proposed input value. (2) Otherwise, if two or more processes initially access the safe-consensus task concurrently, then the task can return any value from a countable set V such that I is a proper subset of V .
The safe-consensus task is the result of weakening the validity condition of con- sensus. It was first proposed by Yehuda, Gafni and Lieber [2]; they use it to show that the g-tight-group-renaming task [3] is as powerful as consensus for g processes. We can now define new objects to extend the basic iterated model.
A safe-consensus object is a shared object that can be used by any number of processes. The object receives an input value from each process that invokes it, and returns to all the processes an output value that satisfies the Agreement and Validity condition of the safe-consensus task. In other words, a safe-consensus object is like a “black box” that the processes can use to solve instances of the safe-consensus task. The method of using distributed tasks as black boxes inside protocols is a standard way to study the relative computational power of distributed tasks (i.e. if one task is weaker than another).
It can be seen that the safe-consensus shared objects are primitives more power- ful than the read/write shared memory. This is because in [2] the authors give two protocols that solve the consensus problem for n processes in a model of distributed computing that extends the standard shared memory model with safe-consensus ob- jects (without any restriction in the way that the processes use the safe-consensus objects) and this says that the safe-consensus task is as powerful as consensus. Re- member that in this paper, in order to make a clear exposition of the field, we use the safe-consensus objects by imposing some rules in the way in which processes invoke the shared objects.
More precisely, we add to the basic iterated model defined in Section 2.2, an infinite array of safe-consensus objects; each of these provides an exec method that takes one parameter as input value and returns to all participating processes a unique value, satisfying the properties of the safe-consensus task. We assume that

the input value that processes feed to the safe-consensus objects is their own ids 6 . For the purposes of this paper, we also assume that in each iteration, all the pro- cesses invoke the same safe-consensus object, that is, there is only one safe-consensus object in each round and it is used by all processes. We call this model of com- putation the Iterated shared memory with full safe-consensus objects (IFSC) model (Figure 3). Finally, we extend the set of events of the iterated model with the event of a call to a safe-consensus object. This event will be denoted by S.

Figure 3. General form of a protocol in the IFSC model (code for pi)

Before continuing with our exposition, we would like to make some remarks concerning the model of distributed computing that we have defined. Notice in Figure 3 that the calls to the safe-consensus objects have been placed between the write and read (snapshot) shared memory operations. In the sequel to this paper [12], we investigate different iterated models which arise from extending the basic iterated model with safe-consensus objects. One issue we consider is precisely where to place the calls to the safe-consensus objects. As we explain in [12], depending on where we put the calls to safe-consensus objects, we can obtain quite different models. In fact, one of the models investigated in [12] is an extension of the IFSC model.

The protocol complex with safe-consensus
After we add to the basic iterated model the power to use safe-consensus objects, one of the first questions that we would like to answer is: What happens to the protocol complex in the extended model ? Are the topological properties unchanged ? In order to answer this question, the first thing we must do is to formally define the protocol complex for protocols in the new IFSC model. If A is a protocol in the IFSC model for n processes, the protocol complex SA of A is defined in the same way as we defined protocol complexes in Section 2.3, the only thing that changes is the view associated to a vertex. A vertex of SA is a tuple v = (i, smi, val), where i is the id of process pi, smi is the local state of pi and val is the return value of the safe-consensus object invoked by all processes.
In Figure 4 we have a drawing of a part of the protocol complex SA of a one- round execution of a protocol A for three processes in the IFSC model. The complete

6 It is not hard to see that this assumption is done without loss of generality.




























Figure 4. Part of the one round Protocol complex of a protocol in the IFSC model. The entire complex contains a countable number of copies of the subcomplex at the bottom. 3.1).


complex is a disconnected space with an infinite number of connected components. Clearly, this complex is not the same complex of Figure 2. Each connected com- ponent is associated with an output value of the safe-consensus task. To see why this is true, let us take a closer look at the subcomplex, say T3, on top of Fig- ure 4, it has a 2-simplex that represents a state in the first round of A that is reachable by means of the round schedule W(3), S(3), R(3), W(1, 2), S(1, 2), R(1, 2). In this execution, process p3 is faster that p1 and p2, thus it executed the safe- consensus object in solo, hence by the Validity condition of the safe-consensus task, the shared object returns the valid input value of 3 to all processes. Now, if we consider the 2-simplex of T3 representing the state reachable through the schedule W(2, 3), S(2, 3), R(2, 3), W(1), S(1), R(1) then we know that p2 and p3 were faster that p1 and executed the safe-consensus object concurrently and by the Validity condition of the safe-consensus task, the shared object can return any value to all processes, so that there exists the possibility that the return value of the safe- consensus object is 3. With a similar analysis of the other simplexes in T3, we can conclude that the safe-consensus value given in the vertices of every 2-simplex of T3

is precisely 3. This subcomplex cannot have simplexes with a safe-consensus value other that 3. For example, it is easy to show that the simplex representing the state obtained with the execution of A given by W(1), S(1), R(1), W(2, 3), S(2, 3), R(2, 3) cannot be adjacent to any simplex of f3 (because of the different safe-consensus values). If we now take the subcomplex f1 in the leftmost part of the figure and the subcomplex f2 in the rightmost part (both of them are isomorphic to f3), we can prove that f1 contains only simplexes with vertices of safe-consensus value equal to 1 and all the simplexes of f2 have vertices with 2 as the safe-consensus value.
What about the subcomplex Bx at the bottom of the figure ? It contains sim- plexes that represent states in which the safe-consensus object returns an invalid output value x /= 1, 2, 3. All the states represented in Bx come from executions in which at least two processes invoke the safe-consensus task concurrently and the value the processes obtain from the shared object is precisely x. But there are a countable number of invalid output values that the task can return to the processes, so that there should be in the complex of Figure 4 a subcomplex Bβ (isomorphic to Bx) for each possible invalid value β. For simplicity, we only show one of these subcomplexes. In summary, the protocol complex £A of the first round of the pro- tocol is disconnected, with an infinite number of connected subcomplexes, one for each possible output value of the safe-consensus task.
We have described the one-round protocol complex of a protocol in the IFSC model. Because we work in an iterated model, in the second (third, fourth and so on) round, the protocol complex is composed of many subcomplexes like f1, f2, f3 and Bx, each simplex of the previous round transforms into a subcomplex like £A. It is not hard to prove that the behavior we have described for 3-processes proto- cols in the IFSC model, generalizes to protocols with any number of processes n /= 3. The protocol complex of any protocol in the IFSC model is a disconnected complex with an infinite number of connected subcomplexes. In general, the structure of the protocol complex in the IFSC model is not as uniform as the well behaved structure
of the protocol complex in the basic iterated model.

Solving (n, n — 1)-set agreement tasks with safe-consensus
We now show that the difference between protocols in the basic iterated model and protocols in the extended model with safe-consensus is not only about geometric shapes. In this section, we prove that in the extended model we can solve the (n, n— 1)-set agreement task for n ≥ 2 processes, a distributed task that we know is unsolvable in the iterated model [18,23,8]. But we also prove that we cannot solve every set agreement task, because n-consensus ((n, 1)-set agreement) is impossible to solve in the IFSC model (when n ≥ 3).
A protocol for (n, n — 1)-set agreement
The protocol in Figure 5 solves (n, n — 1)-set agreement for n ≥ 2 processes in one round with only one safe-consensus object. We proceed to prove its correctness.
Lemma 3.1 For any process pi that executes line 9 of the protocol in Figure 5,



Figure 5. A (n, n — 1)-set agreement protocol in the IFSC model (code for pi)
The cardinality of the set Ai = {α | smi [α] /= ⊥} is at least 2 and min Ai /= n.
If n ∈/ Ai then min Ai /= n — 1.
Proof (a) Suppose that process pi executes line 9 of the if/else block, then it must be true that screti ∈/ {1,..., n}Vsmi [screti]= ⊥, so either the safe-consensus object returned an invalid process id or process pscreti did not write its proposed value to the shared memory before pi executed the snapshot operation (pscreti could be slow or perhaps it crashed). In any case, by (2) of the Validity condition of the safe- consensus task, there must exists two processes pr, ps that called the safe-consensus object concurrently. These processes wrote their input values to the shared memory before accessing the safe-consensus object, so that when pi takes a snapshot of the memory, the local array smi contains at least two non-⊥ values and with this we have that |Ai| ≥ 2. Now suppose that αi = min Ai is such that αi = n. There must exists j ∈ Ai with j /= n, but then j < n = αi which is a contradiction. Hence, αi /= n. (b) Given that n ∈/ Ai, we can use a similar argument to that used in (a) and obtain this case.	2
Theorem 3.2 Let n ≥ 2. The (n, n — 1)-set agreement problem is solvable in the IFSC model in one round using one safe-consensus object.
Proof We prove that the protocol in figure 5 solves (n, n — 1)-set agreement. Triv- ially, the protocol satisfies the Termination condition of the (n, n— 1)-set agreement task. Let pi be any process; after pi writes to the shared memory its input value, it invokes the unique safe-consensus object and takes a snapshot of the memory, pi executes the if/else block at lines 6-10. First suppose that screti ∈ {1,.  , n}
and smi [screti] /= ⊥. Then process pscreti wrote to the shared memory its input value before pi took the snapshot and this implies that smi [screti] contains a valid proposed input value and this is the decided value of process pi. On the other hand, if smi [screti] = ⊥ or screti ∈/ {1,..., n}, pi goes on to execute line 9. By (a) of Lemma 3.1, the set Ai = {α | smi [α] /= ⊥} is not empty, so that there exists a minimum element αi ∈ Ai and then when pi assigns to deci the contents of the local register smi [αi], it has a valid proposed input value, so that the decided value of process pi is correct. Hence, the Validity condition of the (n, n — 1)-set agreement problem is fulfilled by the protocol.

We now show that the set of values decided by the processes in any execution of the protocol has size no bigger that n — 1. Suppose that processes pi1 ,..., pir (r ≤ n, some processes may crash) finish an execution of the protocol and let D be the set of values decided by the processes. We argue by cases.
Case 1. Two or more processes executed line 7 of the protocol. Then |D| ≤ n— 1, because all processes invoked the same safe-consensus object and by the Validity property of the safe-consensus task, the return value of the shared object is the same for all processes, so that if at least two processes executed line 7, they decided the same value.
Case 2. Only one process pl executed line 7 of the protocol. Let v be the value that the safe-consensus object returned to all participating processes. Then for process pl we have that scretl = v and sml [v] (which is non-⊥) is the value decided by pl. If v ∈ {1,...,n — 1} then |D| ≤ n — 1, because for every process pi with i /= l, pi executed the second part of the if/else block and by (a) of Lemma 3.1, pi could not decide the value proposed by process pn. On the other hand, if v = n, then for all i /= l, screti = n and smi [screti] = ⊥ and these two facts imply that Ai ⊆ {1,...,n — 1}. With (b) of Lemma 3.1 we have that min Ai /= n— 1, so that all other processes with ids not equal to l decided at most n — 2 values, which together with the value decided by pl, make up for at most n — 1 different values, therefore |D| ≤ n — 1.
Case 3. No process executed line 7 of the protocol. By (a) of Lemma 3.1, for every process pi we have that αi ∈ {1,...,n — 1}, so all processes decided at most n — 1 values.
In any case, we conclude that the set of decided values has size at most n — 1, thus the protocol satisfies the (n— 1)-Agreement condition of the (n, n— 1)-set agreement problem, hence the protocol is correct.	2
Impossibility of consensus in the IFSC model
Theorem 3.2 tell us that the IFSC model is more powerful that the basic iterated model, because in the new model we can solve the (n, n—1)-set agreement task. But now we will show that in the IFSC model, we cannot solve consensus, i.e., (n, 1)-set agreement.
Trying to solve consensus in distributed systems
The impossibility results for consensus in various models of distributed comput- ing [13,20,7] and the impossibility results for set agreement in the iterated model [19,8,24], have shown that solving consensus in distributed environments is related to connectivity of graphs (0-connectivity of simplicial complexes). Roughly speak- ing, consensus is not solvable in a given model if for each valid input of the consensus problem, the protocol complex (associated with that input 7 ) is connected.
7 Remember our discussion at the end of Section 2.3 about our definition of protocol complexes and its relation with the definition of a span of [19].

In Theorem 3.6 we will prove that it is not possible to solve the consensus pro- blem for n ≥ 3 processes in the IFSC model, despite the fact that the protocols in this model have disconnected protocol complexes (see Figure 4). We remark that this impossibility comes from the restriction in the use of the safe-consensus objects (all processes invoke the same object in each round) of the IFSC model, and not from the fact that we are working in an iterated model 8 .
If A is a protocol for the consensus problem in the IFSC model and its protocol complex £A is disconnected: Why is it impossible for A to solve consensus? We can always find an execution of A in which when all the processes have decided their output values, there are at least two processes that decided two distinct val- ues, contradicting the Agreement property of the consensus task. Now, this “bad execution” exists because we can choose i ∈ n and two simplexes Δi, Δn—i in the complex £A such that
Δi represents an execution in which process pi can see only his own input value (that is, an execution in solo of pi).
Δn—i represents an execution in which the other processes never see pi’s input value.
The simplexes Δi and Δn—i lie inside a connected component of £A.
As a consequence of the last point, there is a (graph) path from any vertex of Δi to any vertex in Δn—i. Using one of these paths and an argument involving non-distinguishable states, we can prove that the bad execution exists, so that A cannot solve consensus. Thus we see that this impossibility is due to some kind of “local connectivity” (between a specific pair of vertices) of £A. Before the formal impossibility proof, we will workout an example with three processes.

Some deﬁnitions for consensus protocols
To be able to work with protocols that solve consensus, we need some additional definitions. Let A be a consensus protocol; if v is a valid input value for processes and S is a reachable state in A, we say that S is v-valent if in every execution of A starting from S, there exists a process that outputs v. S is univalent if in every execution starting from S processes always output the same value. If S is not univalent, then S is bivalent. Fix i ∈ n and define the round schedules πi, π∗ and πn—i as
(πi)  W(i), S(i), R(i), W(n — i), S(n — i), R(n — i), (π∗)  W(n), S(n), R(n),
(πn—i) W(n — i), S(n — i), R(n — i), W(i), S(i), R(i).



8 In the sequel to this paper [12] we propose another iterated model with safe-consensus objects (which can be seen as a generalization of the IFSC model) and prove that consensus can be implemented in that model.

An example with three processes
If we take the case of n = 2 processes, then by Theorem 3.2, consensus of 2 processes ((2, 1)-set agreement problem) is solvable with safe-consensus objects. As we have seen in this section, the protocol complexes of protocols in the IFSC model are disconnected, so that one would expect to be able to solve consensus in this model, but our next results argue otherwise.
Round 1:


W(1)
S(1)
R(1) W(2, 3)
S(2, 3)
R(2, 3)
W(2, 3)
S(2, 3)
R(2, 3) W(1)
S(1)
R(1)




I · π
{2,3}	1

Round 2:
1 ∼ I · π∗ ∼ I · π3—1





(I · π ) · π
{2,3}
(I · π ) · π
~ · · ·∼ (I · π
) · π
∼1 (I · π
) · π

1	1 ∼	1	∗


3—1	∗


3—1


3—1

Figure 6. Subcomplexes of the first and second round protocol complexes of a protocol in the IFSC model.

Let A be a protocol for three processes in the IFSC model and assume that A can solve the consensus problem and for simplicity, suppose that the processes receive as input values their own ids. Let I be the initial state in which the processes begin to execute the protocol. If the processes run A only one round and then decide a (unique) output value, then we know that the protocol complex £A is the space shown in Figure 4. One of the subcomplexes of £A is depicted at the top of Figure 6, it represents all the reachable states in the first round of A for which the output
value of the safe-consensus object is 1. The round schedules π1, π∗ and π3—1 give three possible ways to execute the first round of A and they take the protocol into the states I · π1,I · π∗ and I · π3—1 respectively and these states are represented in the complex of Figure 6. Because the value returned by the safe-consensus object to all

processes in the three states is 1, it is easy to see that p2 and p3 cannot distinguish between I · π1 and I · π∗ and p1 cannot distinguish between I · π∗ and I · π3—1, thus we have the sequence of connected states


I · π
{2,3}	1

1 ∼ I · π∗ ∼ I · π3—1.

If the processes solve consensus in just one round, then these states are decision states. As in the state I · π1 process p1 can see only itself, it has to decide its own input value, which is 1 and by the Agreement property of consensus, p2 and p3 are forced to decide 1; while in the state I · π3—1, p2 and p3 cannot see the input value of p1 and this implies that p2, p3 decide a unique element u of the set {2, 3} and p1 also decides u. As we have said before, p2 and p3 cannot distinguish between the
states I · π1 and I · π∗ and they decide 1 in the state I · π1, then they also decide 1 in I · π∗. On the other hand, p1 cannot distinguish between I · π∗ and I · π3—1 and in the later state p1 decides u, gather that, p1 also decides u in I · π∗. We conclude that in the execution in which A enters the state I · π∗, p2 and p3 decide 1 but p1 decides u /= 1. This constitutes a violation of the Agreement condition of the consensus problem, then the protocol cannot end in one iteration. If the processes execute A
for one more round and decide, then because we work in an iterated model, we can prove that £A will contain the subcomplex given at the bottom of Figure 6; it has simplexes representing reachable states in the second round of A of the form
(I · ρ) · σ	ρ, σ ∈ {π1, π∗, π3—1},
and it can be verified that this complex contains a sequence of states that connect (I · π1) · π1 with (I · π3—1) · π3—1 and this fact can be used to show that there is an execution of the second round of A in which processes decide two different values, again violating the Agreement property of consensus. As we work in an iterated model, we can repeat the same argument in every round of A and that would imply that A cannot solve the consensus problem for three processes.

The formal results
We now formalize the main ideas of the example above to prove that it is impossible to solve n-consensus (n ≥ 3) in the IFSC model.
Lemma 3.3 Let n ≥ 3,i ∈ n. If A is a protocol in the IFSC model and S is any reachable state in some round r ≥ 0 of A, then there exists the sequence




S · πi n∼—i S · π∗ ∼i
S · πn—i,	(3.1)

of connected reachable states in round r +1 of A. Moreover, the value of the safe- consensus object is the same in all three states.
Proof Let S be a reachable state in A and i ∈ n. We first show that there exists executions of A in which the return value of the safe-consensus object is the same

in the three states S · πi,S · π∗ and S · πn—i respectively. If this fact is true, then it will be clear that the given states can be connected in the way described by (3.1). In the state S · πi, the value of the safe-consensus object is i, because pi executes the shared object before any other process executes it and by the Validity condition of the safe-consensus task, the return value must be the value proposed by pi. For the states S · π∗ and S · πn—i, the value of the safe-consensus can be arbitrary. This is true because in each round, all processes invoke the same safe-consensus object and by hypothesis n ≥ 3 (this implies that |n|, |n — i| ≥ 2). Thus in the executions of A (given by the round schedules π∗ and πn—i) that take the protocol into the states S · π∗ and S · πn—i, at least two processes execute the safe-consensus object concurrently. By the Validity property, the return value of the object can be arbitrary. Therefore there exists the possibility that the value returned by the safe- consensus object to all processes is precisely i in the states S · πi,S · π∗ and S · πn—i. It follows that the sequence (3.1) of connected reachable states in A exists.	2
Lemma 3.4 Let n ≥ 3,i ∈ n. If A is a protocol in the IFSC model and there exists a sequence
X1	Xl
S0 ∼ ··· ∼ Sl	(l ≥ 1)
of connected reachable states in A such that for all j with 1 ≤ j ≤ l, Xj = n — i or
Xj = {i}. Then there exists a sequence

Z1	Zs
Q0 ∼ · · · ∼ Qs	(s ≥ 1)
of connected reachable states in A such that
Every state Qt is a successor state of some Sj.
For all m with 1 ≤ m ≤ s, Zm is such that Zm = n — i or Zm = {i}.
Proof We use induction on l, the round schedules πi, π∗, πn—i and Lemma 3.3 to construct the sequence Q1,..., Qs of connected states with the desired properties.
X1
For the base case, consider the states S0 ∼ S1 where X1 = {i}V X1 = n — i. It
is easy to see that the state S0 · ρ is adjacent to the state S1 · ρ, where ρ is πi if
X1 = {i} and is πn—i if X1 = n — i. Assume that we have build the sequence

Z1	Zs′
Q0 ∼ · · · ∼ Qs′ ,
of connected successor states of S1,..., Sq (1 ≤ q < l) with Zm = n — i or Zm = {i} for all m ≤ sj. Each state Qm is of the form Qm = Sj · α, where α ∈ {πi, π∗, πn—i}. We now show how to connect Qs′ (a successor state of Sq) with a successor state of Sq+1. Let Xq+1 be the set of processes that cannot distinguish between Sq and Sq+1. We have to deal with cases.
Case 1. Qs′ = Sq · πi. If Xq+1 = {i}, then we can connect Sq · πi with Sq+1 · πi (pi cannot distinguish between these two states). Now, if Xq+1 = n — i, using Lemma 3.3 we can build the sequence




Sq · πi n∼—i Sq · π∗ ∼i


Sq · πn—i n∼—i Sq+1 · πn—i.

Case 2. Qs′ = Sq · π∗. Whether Xq+1 = {i} or Xq+1 = n— i we have the sequence of connected states


Sq · π∗
Xq+1
Sq · πXq+1
Xq+1
Sq+1 · πXq+1 .

Case 3. Qs′ = Sq · πn—i. The argument here is very similar to Case 1, so we omit it.
We have build with induction the sequence of connected states Q1,..., Qs from the sequence S1,..., Sl satisfying the demanded properties. The result follows.	2
Lemma 3.5 Let n ≥ 3,i ∈ n. Suppose that A is a protocol in the IFSC model
X1	Xl
that solves the consensus problem and that S0 ∼ · · · ∼ Sl (l ≥ 1) is a sequence of
connected reachable states in A that satisﬁes the hypothesis of Lemma 3.4 and also assume that S0 is a v-valent state. Then Sl is v-valent.
Proof It is enough to prove the lemma for l = 1, as the general case follows easily from this case. Suppose (without loss of generality) that S = S0 is v-valent and that Sj = Sl is vj-valent (v /= vj). Since S is v-valent, in every execution starting from S, there is at least one process that outputs v and by the Agreement condition of consensus, all processes must output v as the consensus value; the same is true for Sj, replacing v with vj. Let r be the round number of both S and Sj (this makes sense, because S and Sj are adjacent, thus they must have the same round number, which is part of the local state of each process), then combining Lemma
3.4 with an inductive argument, we can find for all m ≥ r and any two r-round partial executions
R0, π1,..., πr, Rr = S	and	P0, πj ,..., πj , Pr = Sj,
1	r


that end in S and Sj respectively, m-round partial executions
R0, π1,..., πr, Rr, πr+1,..., πm, Rm	and	P0, πj ,..., πj , Pr, πj	,..., πj


, Pm,

1	r	r+1	m
such that Rm and Pm are adjacent states for all m ≥ r. As the protocol solves the consensus problem, there must exists a k such that Ru and Pu are decision states for all u ≥ k. Without loss, we can assume that k ≥ r. Since Ru is a successor state of S, which is a v-valent state, all processes decide v in Ru; simillary, as Pu is a successor of Sj (a vj-valent state), processes must decide vj in Pu. Let X be the set of ids of processes that cannot distinguish between Ru and Pu. Then, for each j ∈ X the local state of process pj in Pu and Ru must be the same and this includes its output component. But this is a contradiction because in Ru, pj decides v while in the state Pu, pj decides vj. We conclude that Sj must be v-valent, such as S. 2
Theorem 3.6 For n ≥ 3, there is no protocol in the IFSC model to solve consensus for n processes.
Proof Assume that there exists a protocol A for consensus in the IFSC model and (without loss of generality) suppose that 0,1 are two valid input values. Let i be

any process id and let O, U be the initial states in which all processes have as input values 0s and 1s respectively. Clearly, O is a 0-valent state and U is a 1-valent state. Let OU be the initial state in which pi has input value 0 and all other processes have input value 1. Then in the first round of A, we have the following sequence of connected reachable states in A:


O · πi ∼i


OU · πi n∼—i OU · π∗ ∼i


OU · πn—i n∼—i U · πn—i.

Because O · πi is 0-valent, Lemma 3.5 tell us that the state U · πn—i is also 0-valent. But this contradicts the fact that U · πn—i is a 1-valent state. Therefore no such protocol A can exists.	2

Conclusion
We have described the iterated model of distributed computing, a useful tool to study and understand the behavior of distributed systems. Also, we described how the runs of protocol in this model can be represented with simplicial complexes and we presented some standard tools (i.e. connectivity of states, valency, etc.) com- monly used to investigate distributed systems. Also, we described the set agreement task, one of the most important distributed problems.
To show to the reader what sort of results can be achieved with the iterated model and the topological approach, we defined the iterated shared memory with full safe-consensus objects (IFSC) model, an extension of the basic iterated model using the safe-consensus task of [2]. We showed how to analyze protocol complexes in the IFSC model, and we discovered that the protocol complexes of protocols in the IFSC model are (globally) disconnected. We explained why local connectivity between some pairs of vertices of the protocol complex is sufficient to prove that consensus is unsolvable in the IFSC model. Thus we see that connectivity of the protocol complex (which is related to the notion of non-distinguishable states) is indeed fundamental in the study of distributed computing.
But we also proved that in the new IFSC model we can solve (n, n — 1)-set agreement. As this problem cannot be solved in the basic iterated model [8,23,18], we can conclude that the IFSC model is indeed more powerful that the basic iterated model.
Several questions remain open. For example, is there an iterated model extended with safe-consensus objects that is equivalent (for task solvability) to the wait-free standard model extended with safe-consensus objects?

References
Afek, Y., H. Attiya, D. Dolev, E. Gafni, M. Merritt and N. Shavit, Atomic snapshots of shared memory,
J. ACM 40 (1993), pp. 873–890.
Afek, Y., E. Gafni and O. Lieber, Tight group renaming on groups of size g is equivalent to g-consensus, in: Proceedings of the 23rd international conference on Distributed computing (DISC’09), LNCS 5805 (2009), pp. 111–126.


Afek, Y., I. Gamzu, I. Levy, M. Merritt and G. Taubenfeld, Group renaming, in: OPODIS ’08: Proceedings of the 12th International Conference on Principles of Distributed Systems, LNCS 5401 (2008), pp. 58–72.
Alexandrov, P. S., “Combinatorial topology. Vol. 1, 2 and 3,” Dover Publications Inc., Mineola, NY, 1998, 650 pp., translated from the Russian, Reprint of the 1956, 1957 and 1960 translations.
Armstrong, M. A., “Basic Topology,” Springer-Verlag, 1983.
Attiya, H. and S. Rajsbaum, The combinatorial structure of wait-free solvable tasks, SIAM J. Comput.
31 (2002), pp. 1286–1313.
Biran, O., S. Moran and S. Zaks, A combinatorial characterization of the distributed 1-solvable tasks,
J. Algorithms 11 (1990), pp. 420–440.
Borowsky, E. and E. Gafni, Generalized flp impossibility result for t-resilient asynchronous computations, in: STOC ’93: Proceedings of the twenty-fifth annual ACM symposium on Theory of computing (1993), pp. 91–100.
Borowsky, E. and E. Gafni, Immediate atomic snapshots and fast renaming, in: PODC ’93: Proceedings of the twelfth annual ACM symposium on Principles of distributed computing (1993), pp. 41–51.
Borowsky, E. and E. Gafni, A simple algorithmically reasoned characterization of wait-free computation (extended abstract), in: PODC ’97: Proceedings of the sixteenth annual ACM symposium on Principles of distributed computing (1997), pp. 189–198.
Chaudhuri, S., More choices allow more faults: set consensus problems in totally asynchronous systems, Inf. Comput. 105 (1993), pp. 132–158.
Conde, R. and S. Rajsbaum, Two normal forms of an iterated snapshot model and their power to solve consensus from safe-consensus (2010), manuscript.
Fischer, M. J., N. A. Lynch and M. S. Paterson, Impossibility of distributed consensus with one faulty process, J. ACM 32 (1985), pp. 374–382.
Gafni, E. and S. Rajsbaum, Musical benches, in: Proceedings of the 19th international conference on Distributed computing (DISC’05), LNCS 3724 (2005), pp. 63–77.
Gafni, E. and S. Rajsbaum, Distributed programming with tasks, in: OPODIS ’10: Proceedings of the 14th International Conference on Principles of Distributed Systems, Lecture Notes in Computer Science 6490 (2010), pp. 205–218.
Gafni, E., S. Rajsbaum and M. Herlihy, Subconsensus tasks: Renaming is weaker than set agreement, in: Proceedings of the 20th international conference on Distributed computing (DISC’06), LNCS 4167 (2006), pp. 329–338.
Herlihy, M. and S. Rajsbaum, A classification of wait-free loop agreement tasks, Theoretical Computer Science 291 (2003), pp. 55 – 77.
Herlihy, M. and N. Shavit, The asynchronous computability theorem for t-resilient tasks, in: STOC ’93: Proceedings of the twenty-fifth annual ACM symposium on Theory of computing (1993), pp. 111–120.
Herlihy, M. and N. Shavit, The topological structure of asynchronous computability, J. ACM 46 (1999),
pp. 858–923.
Loui, M. C. and H. H. Abu-Amara, Memory requirements for agreement among unreliable asynchronous processes, Parallel and Distributed Computing, Advances in Computing Research. F. P. Preparata ed., JAI Press, Greenwich, CT 4 (1987), pp. 163–183.
Rajsbaum, S., Iterated shared memory models, in: LATIN ’2010: Proceedings of the 9th Latin American Symposium on Theoretical Informatics, Lecture Notes in Computer Science 6034 (2010), pp. 407–416.
Rajsbaum, S., M. Raynal and C. Travers, The iterated restricted immediate snapshot model, in: COCOON ’08: Proceedings of the 14th annual international conference on Computing and Combinatorics (2008), pp. 487–497.
Saks, M. and F. Zaharoglou, Wait-free k-set agreement is impossible: the topology of public knowledge, in: STOC ’93: Proceedings of the twenty-fifth annual ACM symposium on Theory of computing (1993),
pp. 101–110.
Saks, M. and F. Zaharoglou, Wait-free k-set agreement is impossible: The topology of public knowledge, SIAM J. Comput. 29 (2000), pp. 1449–1483.
