Electronic Notes in Theoretical Computer Science 122 (2005) 67–87  
www.elsevier.com/locate/entcs


From Geometry of Interaction to Denotational Semantics
Esfandiar Haghverdi 1
School of Informatics & Department of Mathematics Indiana University Bloomington
Bloomington, Indiana USA
Philip Scott2 ,3
Department of Mathematics and Statistics University of Ottawa
Ottawa, Ontario Canada



Abstract
We analyze the categorical foundations of Girard’s Geometry of Interaction Program for Linear Logic. The motivation for the work comes from the importance of viewing GoI as a new kind of semantics and thus trying to relate it to extant semantics. In an earlier paper we showed that a special case of Abramsky’s GoI situations–ones based on Unique Decomposition Categories (UDC’s)–exactly captures Girard’s functional analytic models in his first GoI paper, including Girard’s original Execution formula in Hilbert spaces, his notions of orthogonality, types, datum, algorithm, etc. Here we associate to a UDC-based GoI Situation a denotational model (a ∗- autonomous category (without units) with additional exponential structure). We then relate this model to some of the standard GoI models via a fully-faithful embedding into a double-gluing category, thus connecting up GoI with earlier Full Completeness Theorems.
Keywords: Geometry of Interaction, Denotational semantics, Linear logic, *-autonomous categories, Unique decomposition categories.


1 Email: ehaghver@indiana.edu
2 Research Supported by an NSERC Discovery Grant
3 Email: phil@mathstat.uottawa.ca



1571-0661 © 2005 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.06.052

Introduction
Girard introduced his Geometry of Interaction (GoI) programme in the late 80’s in a series of fundamental papers [9,8,10]. Girard’s goal in the original GoI was to analyze the dynamics of cut-elimination, using sophisticated math-
ematical models arising from functional analysis. In the original papers, Gi- rard established a kind of feedback equation (known as the Execution Formula) which gives an intrinsic measure of “information flow” in the cut-elimination
process. In his detailed modelling of proofs, Girard also established that for a large class of types (for example, strong enough to represent System F), the Execution formula is an invariant for cut-elimination.
The GoI interpretation was extended to untyped λ-calculus by Danos in [6]. In many subsequent works, Danos and Regnier and coauthors (e.g. [21,7]) further extended the GoI interpretation. They developed a theory of paths in abstract nets (untyped or typed), with detailed comparisons with many λ-calculus notions of path.   After Girard’s original GoI papers appeared,
Joyal, Street, and Verity [19] introduced traced monoidal categories (TMC’s);
balanced monoidal categories with an abstract notion of “trace” or “feedback”. These categories have proved useful in many areas ranging from topology and knot theory to theoretical physics and computer science (see Section 2 below).
In Linear Logic, the theory of TMC’s led to an abstract formalisation of GoI via the notion of GoI Situation, introduced by Abramsky in his Siena lecture [2], based on earlier formalizations of GoI in [4], using domain theory. GoI
Situations give the essential categorical ingredients of GoI, at least for the multiplicative and exponential (MELL) fragment. Abramsky’s programme was sketched in [2] and completed in [11] and [3] (see also Section 2 below).
However two questions remained in [3]:
How to compare the general algebraic framework of a GoI Situation with the actual details of the functional-analytic models introduced by Girard and studied by Danos & Regnier, et al?
How to compare GoI models with denotational models (of proofs)? In the case of linear logic, this means we want to naturally connect up GoI models with ∗-autonomous categories, with the additional structure to model exponentials.
Re (1), in our first paper [14], we showed how the axiomatics of TMC’s in GoI situations (see [3]), when restricted to Unique Decomposition Categories (UDC’s) (see below and Section 3), allows us to categorically reconstruct Girard’s first model. This model is based on the C∗-algebra of bounded linear operators on the space l2 of square summable sequences [9]. Our categorical approach permits an elegant derivation of Girard’s original execution formula


in his model, explicates his notion of type, datum, and algorithm and clarifies the role of the later theory of TMCs in Girard’s original proofs.
Re (2), traditional semantics models cut-elimination by static equalities. This means that if Π, Π' are proofs of a sequent Γ ▶ A and if we have a reduction Π > Π' by cut-elimination, then in any categorical model their interpretations  −  denote equal morphisms, i.e.  Π  =  Π'  :  Γ  →  A  . The goal of GoI is to provide a mathematical model of the dynamics of cut- elimination, independent of the syntax.

In this paper, as in our paper [14], we restrict the abstract TMC’s to a useful subclass: traced unique decomposition categories (Traced UDC’s) with standard trace [11,12]. These are symmetric monoidal categories whose homsets are enriched with certain infinitary partial sums, thus allowing us to consider morphisms as matrices and the execution formula as an infinite sum. Such categories are inspired from early categorical analyses of programming languages by Elgot, Arbib and Manes, et al. ([20]).
We start with a UDC-GoI Situation and construct a denotational model for MELL without units. It is a ∗-autonomous category without units, together with an endofunctor satisfying certain axioms. We show this denotational category may be fully and faithfully embedded in a double-gluing category
[11,18,24] built via the G construction of Abramsky (shown to be isomorphic to JSV’s Int construction in [11].) This not only connects up our theory with the known denotational models already studied in [3,11,12] but also connects
with fully complete MLL models arising from GoI [11,13]. The rest of the paper is organized as follows: In Section 2 we recall the necessary definitions, namely traced symmetric monoidal categories and GoI Situations, following [11,3]. In Section 3 we recall the definition of a unique decomposition category and give some examples. Section 4 briefly recalls the GoI interpretation for MELL formulas and proofs taken directly from [14]. Section 5, is the main part of the paper where we explain and detail the construction of a ∗-autonomous
category from a UDC-GoI Situation that we call the orthogonality construc-
tion. In Section 6 we relate this latter category to double-gluing categories familiar from work in Full Completeness. Finally in section 7 we conclude by
discussing related and future work.

Traced Monoidal Categories and GoI Situation
Joyal, Street and Verity [19] introduced the notion of an abstract trace on a balanced monoidal category (a monoidal category with braiding and twist.) This trace can be interpreted in various contexts where it could be called


feedback, parametrized fixed-point, Markov trace or braid closure. These cat- egories have their origins in the analysis of braided tensor categories and in knot theory. However the special case of traced symmetric monoidal cate- gories have been particularly useful in some areas of theoretical computer
science, for example in cyclic lambda calculi [15], semantics of asynchronous networks [22], full completeness theorems for multiplicative linear logic via GoI [11,13], analysis of finite state machines [17], relational dataflow [16], and they independently arose in Stefanescu’s work in network algebra [23].
In what follows we only consider symmetric monoidal categories.
Definition 2.1 A traced symmetric monoidal category (TMC) is a symmetric

monoidal category (C, ⊗,I, s) with a family of functions TrU
→ C(X, Y ) called a trace, subject to the following axioms:
: C(X ⊗U, Y ⊗



Natural in X, TrU
(f )g = TrU '
(f (g ⊗ 1U )) where f : X ⊗ U → Y ⊗ U ,

g : X' → X,
Natural in Y , gTrU

= TrU

' ((g ⊗ 1U )f ) where f : X ⊗ U → Y ⊗ U ,

g : Y → Y ',
Dinatural in U , TrU

((1Y

⊗ g)f ) = TrU'

(f (1X

⊗ g)) where f : X ⊗ U →

Y ⊗ U ', g : U ' → U ,
Vanishing (I,II), TrI

(f ) = f and TrU⊗V (g) = TrU

(TrV

(g))

X,Y
X,Y
X,Y
X⊗U,Y ⊗U

for f : X ⊗ I → Y ⊗ I and g : X ⊗ U ⊗ V → Y ⊗ U ⊗ V ,
Superposing,


U X,Y
⊗ g = TrU
((1Y ⊗ sU,Z)(f ⊗ g)(1X ⊗ sW,U ))

for f : X ⊗ U → Y ⊗ U and g : W → Z,
Yanking, TrU (sU,U ) = 1U .
TMC’s admit a geometric diagram calculus that can be found in the references (e.g. [11,3,19]).
Joyal, Street, and Verity [19] also introduced the Int construction on traced symmetric monoidal categories C; Int(C) is a kind of “free compact closure”
of the category C. Int(C) is used in [19] to give a 2-categorical structure theorem for TMC’s. Int(C) isolates the key properties of Girard’s GoI for the multiplicative connectives; for example composition in Int(C) uses a ver- sion of Girard’s Execution Formula applied to the GoI interpretation of the cut rule. Abramsky [1] independently introduced the G construction which
associates a compact closed category to a traced symmetric monoidal one.
In [11] the two constructions are shown to yield isomorphic compact closed categories starting with the same TMC. There are two problems: first, these


(isomorphic) constructions only yield “degenerate” compact closed models for MLL (so tensor = par). Second is the problem of how to extend this to the exponential connectives.
Re the second problem, in the Abramsky program (see [3]) this is achieved by adding certain additional structure to a traced symmetric monoidal cat- egory. This structure involves a monoidal endofunctor T , a reflexive object
U , and appropriate monoidal retractions, as introduced below, to yield a GoI
situation. It was shown in [3] that GoI situations endow the monoid C(U, U ) with the structure of a linear combinatory algebra. Such combinatory algebras capture the appropriate computational meaning of the exponentials in linear
logic and model a Hilbert-style presentation of MELL.
Re the first problem above, it is possible to construct a non-compact ∗- autonomous category from a given compact closed one using the double glueing construction of Hyland and Tan [24,18] on top of the compact closed category. On the other hand, in this paper we start with a UDC-GoI Situation and directly construct a ∗-autonomous category and an endofuctor ! on it to get a denotational model for MELL. Here not only is the construction direct but more importantly it exploits the structure of a GoI Situation. The Int (or G) constructions do not take into account either the roˆle of the reflexive object U or the orthogonality relation defined on C(U, U ) (see the definition below). We believe that the latter two are among the most important and interesting ingredients of the GoI interpretation.
Definition 2.2 A GoI Situation is a triple (C,T,U ) where:
C is a traced symmetric monoidal category
T : C → C is a traced symmetric monoidal functor with the following retractions (note that the retraction pairs are monoidal natural transfor- mations):
TT  T (e, e') (Comultiplication)
Id  T (d, d') (Dereliction)
T ⊗ T  T (c, c') (Contraction)
KI  T (w, w') (Weakening). Here KI is the constant I functor.
U is an object of C, called a reflexive object, with the specified retractions:
(a) U ⊗ U  U (j, k), (b) I  U (m, n), and (c) TU  U (u, v).
For examples of GoI Situations see Section 3. For our models of linear logic, we will take the following definitions.
Definition 2.3 A symmetric monoidal category (C, ⊗,I, s) isa ∗-autonomous category if there exists a full and faithful functor (−)⊥ : Cop → C such that there exists an isomorphism C(A ⊗ B, C⊥) → C(A, (B ⊗ C)⊥) natural in A, B


and C.
The models of multiplicative linear logic (MLL) are ∗-autonomous categories. For the multiplicative and exponential fragment (MELL), we assume:
Definition 2.4 A denotational model of MELL consists of the following data:
A ∗-autonomous category (C, ⊗,I, s, (−)⊥),
A symmetric monoidal functor (!, ϕ, ϕI) : C → C.
Monoidal natural transformations:
der :! =⇒ Id
δ :! =⇒!!
weak :! =⇒ KI where KI is the constant I functor
con :! =⇒!⊗! such that
(!, der, δ) is a comonad.
for each object A, the triple (!A, weakA, conA) is a commutative comonoid.
for each object A, the maps weakA and conA are maps of coalgebras.
for each object A, the map δA is a map of commutative comonoids.
Finally, we remark that there are two “styles” of GoI Situations in the concrete models studied in [3]: Sum style and Product style. These are determined by the form of the tensor in the underlying TMC. Roughly, in sum style, the tensor ⊗ is given by a disjoint union on objects; in product style, it is more
like a cartesian product. We shall exclusively consider Sum style models here, corresponding to Girard’s GoI 1. Sum style GoI admits a semantics based on “particles flowing through a network” [3,11].

Unique Decomposition Categories
We consider monoidal categories whose homsets allow the formation of cer- tain infinite sums. These are monoidal categories enriched in Σ-monoids (see below).  In the case where the tensor is coproduct and Σ-monoids satisfy
an additional condition, such categories include the partially additive and it-
erative categories used in the early categorical analyses of flow charts and
programming languages by Bainbridge, Elgot, Arbib and Manes, et. al. (e.g. [20]).
Definition 3.1 A Σ-monoid consists of a pair (M, Σ) where M is a nonempty set and Σ is a partial operation on the countable families in M (we say that
{xi}i∈I is summable if	i∈I xi is defined), subject to the following axioms:
Partition-Associativity Axiom.  If {xi}i∈I is a countable family and if
{Ij}j∈J is a (countable) partition of I , then {xi}i∈I is summable if and

only if {xi}i∈Ij is summable for every j ∈ J and Σi∈Ij xi is summable for
j ∈ J. In that case, Σi∈Ixi = Σj∈J (Σi∈Ij xi)
Unary Sum Axiom. Any family {xi}i∈I in which I is a singleton is summable and  i∈I xi = xj if I = {j}.
Σ-monoids form a symmetric monoidal category (with product as tensor), called ΣMon. A ΣMon-category C is a category enriched in ΣMon; i.e. the homsets are enriched with a partial infinitary sum compatible with composi- tion. Note that such categories have non-empty homsets and automatically have zero morphisms, namely 0XY : X → Y =  i∈∅ fi for fi ∈ C(X, Y ). For
details see [20,11].
Definition 3.2 A unique decomposition category (UDC) C is a symmetric monoidal ΣMon-category which satisfies the following axiom:
For all j ∈ I there are morphisms called quasi injections: ιj : Xj → ⊗IXi, and quasi projections: ρj : ⊗IXi → Xj, such that
ρkιj = 1Xj if j = k and 0Xj Xk otherwise.
Σi∈I ιiρi = 1⊗IXi .

Proposition 3.3 (Matricial Representation) Given f : ⊗J Xj → ⊗I Yi in a UDC with |I| = m and |J| = n, there exists a unique family {fij}i∈I,j∈J : Xj → Yi with f =  i∈I,j∈J ιifijρj, namely, fij = ρif ιj.
Thus every morphism f : ⊗J Xj → ⊗I Yi in a UDC can be represented by a matrix; for example f above (with |I| = m and |J| = n) is represented by the m × n matrix [fij]. Composition of morphisms in a UDC then corresponds to matrix multiplication.
Proposition 3.4 (Standard Trace Formula) Let C bea unique decompo- sition category such that for every X, Y, U and f : X ⊗ U → Y ⊗ U, the sum

f11 + Σ∞
f12fn f21 exists, where fij are the components of f 4 . Then, C is

n=0	22
U
Σ∞	n

The trace formula above is called the standard trace, and a UDC with such a trace is called a traced UDC with standard trace. Note that a UDC can be traced with a trace different from the standard one. In this paper all traced
UDCs are the ones with the standard trace.
The following examples have standard trace, as above.
Examples 3.5 (Traced UDC’s)  (For details see [3,11,13]).

4 Here X1 = X, Y1 = Y, X2 = Y2 = U . So f11 : X → Y, f12 : U → Y , etc.


Any partially-additive category (see [20]). This includes:
Rel+ (sets and relations). Here ⊗ =  (disjoint union, which is a biprod- uct). In Rel+, all countable families are summable, and	i∈I Ri =
∪iRi.
Pfn (sets and partial functions), with ⊗ = . Define a countable fam- ily of partial functions {fi}i∈I to be summable iff they have pairwise disjoint domains. Then (  i∈I fi)(x) = fj(x) iff x ∈ Dom(fj), for some
j ∈ I, otherwise undefined.
SRel, the category of stochastic relations. Here the objects are measur- able spaces (X, FX) and maps f : (X, FX) → (Y, FY ) are stochastic kernels, i.e. f : X × FY → [0, 1] such that f (x, .) is a subproba- bility measure and f (., B) is a bounded measurable function, for all
x ∈ X and B ∈ FY . Composition gof (x, C) = Y g(y, C)f (x, dy), where f (x, .) is the measure for integration. This category has finite
and countable coproducts (which form the tensor). A family {fi}i∈I is summable iff  i∈I fi(x, Y ) ≤ 1 for all x ∈ X.
PInj (sets and partial injective functions). Here ⊗ = ; this is not a coproduct, indeed PInj does not have coproducts. The UDC structure is
ιj	ρj
Xj −→ i∈IXi with ιj(x) = (x, j), and  i∈IXi −→ Xj with ρj(x, j) = x
and ρj(x, i) undefined for i /= j. Summable families are as in Pfn but with disjoint domains & codomains.
Hilb2. Consider the category Hilb of Hilbert spaces and linear contrac- tions (norm ≤ 1).  Barr [5] defined a contravariant faithful functor l2 :PInjop →Hilb by: for a set X, l2(X) is the set of all complex valued functions a on X for which the (unordered) sum  x∈XΣ|a(x)|2 is finite.

and inner product given by < a, b >= x∈X a(x)b(x) for a, b ∈ l2(X). Given f : X → Y in PInj, define l2(f ) : l2(Y ) → l2(X) by l2(f )(b)(x) = b(f (x)) if x ∈ Dom(f ) and = 0, otherwise.
This gives a correspondence between partial injective functions and partial isometries on Hilbert spaces (see also [10,1].) Let Hilb2 = l2[PInj].
Its objects are l2(X) for a set X and morphisms u : l2(X) → l2(Y ) are of
f
the form l2(f ) for some partial injective function Y −→ X. Hence, Hilb2
is a nonfull subcategory of Hilb. It forms a traced UDC with respect to
⊕, where l2(X) ⊕ l2(Y ) ∼= l2(X  Y ) is a tensor product in Hilb2 (but is a biproduct in Hilb) with the necessary structure induced by l2 from
PInj.
The above examples yield GoI situations (C,T,U ) with T an additive functor ([3,11]):


(Rel+,T, N), (Pfn,T, N), and (PInj,T, N) with T = N × −.
(Hilb2,T, l2) with T = l2 ⊗ −, where l2 = l2(N).
(SRel,T, NN), where T (X, FX) = (N×X, FN×X ), where FN×X is the σ-field generated by	N X.

The GoI Interpretation for MELL
We remind the reader of definitions and results pertaining to the GoI inter- pretation of MELL that we shall be using in the sequel. These are crucial for a proper understanding of the results in this paper. For more details see [9] for the original definitions and our [14] for the categorical version. We follow [14].
In the sequel C is a traced UDC with standard trace, T an additive endo- functor and U an object of C, such that (C,T,U ) forms a GoI Situation. We interpret proofs in the homset C(U, U ) and formulas (= types) are interpreted as certain subsets of C(U, U ).
Convention: We write 1Γ instead of 1Un , where |Γ| = n and where U denotes the n-fold tensor product of U with itself. The retraction pairs are fixed once and for all using the names in Definition 2.2. j1, j2 and k1, k2 denote the components of j and k respectively. If A and B are square matrices of size n × n and m × m, resp., then A ⊗ B denotes the n + m × n + m block matrix with A and B on the “main diagonal” and the rest zeros.
Definition 4.1 Let f, g ∈ C(U, U ). We say that f is nilpotent if fk = 0 for some k ≥ 1. We say f is orthogonal to g, denoted f ⊥ g if gf is nilpotent. Orthogonality is a symmetric relation, well-defined since 0UU exists. Also,
0 ⊥ f for all f ∈ C(U, U ).
Given a subset X of C(U, U ), we define

X⊥ = {f ∈ C(U, U )|∀g(g ∈ X ⇒ f ⊥ g)}
A type is any subset X of C(U, U ) such that X = X⊥⊥. Note that types are inhabited, since 0UU belongs to every type.

Definition 4.2 Consider a GoI Situation (C,T,U ). Let A be an MELL for- mula. We define the GoI interpretation of A, denoted θA, inductively as follows:
If A ≡ α that is A is an atom, then θA = X an arbitrary type.
If A ≡ α⊥, θA = X⊥, where θα = X is given by assumption.


If A ≡ B ⊗ C, θA = Y ⊥⊥ where	Y = {j1ak1 + j2bk2|a ∈ θB, b ∈ θC}.

If A ≡ B
(θC)⊥}.
.....
.
C,  θA = Y ⊥
, where	Y = {j1ak1 + j2bk2|a ∈ (θB)⊥
,b ∈

If A ≡!B, θA = Y ⊥⊥ , where Y = {uT (a)v|a ∈ θB}.
If A ≡?B, θA = Y ⊥ , where Y = {uT (a)v|a ∈ (θB)⊥}.
It is an easy consequence of the definition that (θA)⊥ = θA⊥ for any formula

Every MELL sequent will be of the form ▶ [∆], Γ where Γ is a sequence of formulas and ∆ is a sequence of cut formulas that have already been made in the proof of ▶ Γ (e.g. A, A⊥, B, B⊥). This is used to keep track of the cuts.
Suppose |Γ| = n, |∆| = 2m formulas. Then the GoI interpretation of a proof Π
of ▶ [∆], Γ is represented by a pair (  Π  , σ), where   Π  ∈ C(Un+2m,Un+2m)
and the morphism σ : U 2m → U 2m which models the cuts ∆ in ▶ [∆], Γ is defined as σ = s ⊗ ··· ⊗ s (m-copies) where s is the symmetry map, the 2 × 2 antidiagonal matrix [aij], where a12 = a21 = 1; a11 = a22 = 0. In the case where ∆ is empty, the proof is cut-free, we define σ : I → I to be 1I = 0II. Note that U 0 = I where I is the unit of the tensor in the category C. It is much more convenient to work in C(Un+2m,Un+2m) (matrices on C(U, U )), although by the retractions we can equally work in C(U, U ).
Let Π be a proof of ▶ [∆], Γ. We define the GoI interpretation of Π, denoted by  Π  , by induction on the length of the proof as follows. For lack of room, we only give three cases and refer to [14] for details and the associated (block) matrix representation. Pictorially picture Π as an I/O box, with n + 2m wires (labelled by the formulas in Γ, ∆) coming in and out. The wires are the interface.
Π is an axiom ▶ A, A⊥, then m = 0, n = 2 and  Π  = s.
Π is obtained using the cut rule on Π' and Π'' that is


Π. '
.
▶ [∆'], Γ',A 
Π. ''
.
▶ [∆''], A⊥, Γ''

▶ [∆', ∆'', A, A⊥], Γ', Γ''	(cut)


Define  Π  as follows:  Π  = τ −1(  Π'  ⊗  Π''  )τ , where τ is a permu- tation “rearranging the interface” (pictorially, stack one I/O box on top of the other; τ permutes the wires to put all the cut formulas adjacent.)
A similar interpretation holds for the times and par rules.


Π is obtained from Π' by the contraction rule, that is Π is of the form

Π. '
.
▶ [∆], Γ', ?A, ?A
▶ [∆], Γ', ?A	(contraction)


Then  Π  = (1Γ' ⊗ ucU (v ⊗ v) ⊗ 1∆)  Π'
T ⊗ T  T (c, c').
 (1Γ' ⊗ (u ⊗ u)cU v ⊗ 1∆), where

Definition 4.3 (Girard[9]) We are in a traced UDC-GoI situation. Let Γ =
A1, ··· , An. A datum of type θΓ is a morphism M : Un → Un such that for any β1 ∈ θ(A⊥), ··· , βn ∈ θ(A⊥), (β1 ⊗··· ⊗ βn)M is nilpotent. An algorithm
1	n
of type θΓ is a morphism M : Un+2m → Un+2m for some non-negative integer m such that for σ : U 2m → U 2m defined in the usual way, EX(M, σ) is a finite sum and a datum of type θΓ, where


2m
EX(M, σ) = TrUn,Un ((1Un ⊗ σ)M)

is known as the Execution Formula for M.
Lemma 4.4 Let M : Un → Un and a : U → U. Deﬁne CUT (a, M) =

(a ⊗ 1Un−1 )M : Un
→ Un
. Then M = [mij] is a datum of type θ(A, Γ) iff

for any a ∈ θA⊥, am11 is nilpotent and the morphism  ex(CU T (a, M)) =
TrA(s−1 CUT (a, M)sΓ,A) ∈ θ(Γ). Here sΓ,A is the symmetry morphism.
The following is due to Girard [9], and proved categorically in our [14]:
Theorem 4.5 (Girard) Let Π be a proof of a sequent ▶ [∆], Γ in MELL with
|∆| = 2m and |Γ| = n. Then
Π  is an algorithm of type θΓ, in particular EX(  Π  , σ) is a ﬁnite sum.
If Π reduces to Π' by any sequence of cut-eliminations and ”?” does not oc- cur in Γ, then EX(  Π  , σ) = EX(  Π'  ,τ ). So EX(  Π  , σ) is an invariant of cut-elimination.
If Π' is the normal form of Π under cut-elimination, then EX(  Π  , σ) =  Π'  .
In Hilb ,	EX(  Π  , σ) = ((1 − σ˜2) Σ∞   Π  (σ˜(  Π  ))n(1 − σ˜2))	. Here
(A)n×n denotes the n × n submatrix of the matrix A consisting of the ﬁrst
n rows and the ﬁrst n columns of A and σ˜ is the n + 2m square matrix
0n ⊗ σ, where 0n is n × n zero matrix and σ is the 2m × 2m square matrix associated with the cuts ∆.

Orthogonality Construction
We explain the orthogonality construction which given a UDC-GoI Situation yields a ∗-autonomous category without units and an endofunctor on it form- ing a denotational model of MELL without units. In the sequel we have omitted many of the routine and tedious verifications (these will appear in the long version). However, in each and every case we explain the reasoning behind the definition, so that the reader would not get the wrong impression that the definitions are somehow arbitrary. The general intuition behind this construction is to use the GoI interpretation for formulae to define the objects and to use the GoI interpretation of a cut-free proof of ▶ A⊥,B to define a
morphism f : A → B. In Girard’s terminology above, kfj is a datum of type
θ(A⊥, B).
Given a UDC-GoI Situation (C,T,U ), we define the category O(C) as follows:
Objects: An object A is a subset of C(U, U ) such that A⊥⊥ = A. Recall that these are the types (GoI interpretation for formulae) defined in the previous section.
Arrows: An arrow f : A → B is a morphism f in C(U, U ) such that for

every a ∈ A,	f .a =def TrU
(sU,U (a ⊗ 1U )(kfj)sU,U ) is in B.

Note that as we are working in a traced UDC, we have
f .a = k2f j2 + Σ k2f j1(ak1f j1)nak1f j2.
n≥0

The intuition is that we think of f : A → B as the interpretation of a cut- free proof of ▶ A⊥, B, or in other words we think of kfj as a datum of type θ(A⊥, B), see Definition 4.3 and Theorem 4.5 above. As a matter of fact for those familiar with Girard’s work, this definition is exactly ex(CU T (a, kfj)) formulated in terms of categorical trace explained in [14] and cited in Lemma
4.4 in the previous Section.
Identity: The identity morphism on A, denoted 1A, is given by jsU,U k ∈
C(U, U ). Note that for any a ∈ A, 1A.a = TrU  (sU,U (a⊗1U )(kjsU,U kj)sU,U ) = 

U U,U
(sU,U (a ⊗ 1U )sU,U sU,U ) = a ∈ A. The latter equality is known as gener-

alized yanking in TMC’s (see [11,12].) The intuition is that we use the GoI
interpretation of the cut-free proof of ▶ A⊥, A.
Composition: Composition is defined as follows: given f : A → B and
g : B → C in O(C),


U ⊗U
U ⊗U,U ⊗U
((1 ⊗ 1 ⊗ s)τ −1(kfj ⊗ kgj)τ )k.


where τ = (1 ⊗ 1 ⊗ s)(1 ⊗ s ⊗ 1). The motivation comes from the GoI interpretation as follows: we take the cut-free proofs of ▶ A⊥,B and ▶ B⊥,C and apply the GoI interpretation for the cut rule to these two proofs, hence we get a proof with cuts in it, namely we get a proof of ▶ [B, B⊥], A⊥, C. But we need a cut-free proof so we apply the execution formula to this latter proof to get the GoI interpretation of a cut-free proof of ▶ A⊥, C. Our definition precisely reflects these operations.
Note that gf ∈ C(U, U ). As we are working in a traced UDC we have
⎡ k1f j1	0	k1f j2	0	⎤

gf = jTr ⎢
⎢
0	k2gj2	0	k2gj1 ⎥ k
0	k1gj2	0	k1gj1 ⎥

⎣ k2f j1	0	k2f j2	0	⎦

If a ∈ A then (gf ).a ∈ C; this follows from the construction and Theorem
4.5 which implies that k(gf )j is a datum of type θ(A⊥, C). Hence gf is a well-defined morphism in O(C).
Note that this is essentially the same as the formula for composition in G(C) (called symmetric feedback in [1]), see [11,1], and of course this is no surprise as the definition of composition in G(C) is also motivated by the execution formula applied to the cut of two proofs. This is discussed further
in Section 6 below.
Proposition 5.1 Let (C,T,U ) be a UDC-GoI Situation with the additional requirement that U ⊗ U ∼= U (j, k). Then, O(C) is a category.
Proof. As mentioned above the composition and identity morphisms are similar to those in G(C) and hence the associativity and unit equations hold true. However just to illustrate, let’s look at 1Bf = f for f : A → B.
⎡ k1f j1 0 k1f j2 0 ⎤

1 f = jTr ⎢
0	0	0	1 ⎥ k = j ⎛⎡ k1f j1 0 ⎤ + ⎡
0	k1f j2
k = f

B
⎢	0	1	0	0 ⎥
⎝⎣	0	0 ⎦
⎣ k fj k fj ⎦⎠

⎣ k2f j1 0 k2f j2 0 ⎦
2	1  2	2



We next define the ∗-autonomous structure. Given A and B objects in O(C), define:


Tensor: A ⊗ B = {j1ak1 + j2bk2|a ∈ A, b ∈ B}⊥⊥. Given f : A → B
and g : A' → B' we define

f ⊗ g = j(j ⊗ j)(1 ⊗ s ⊗ 1)(kfj ⊗ kgj)(1 ⊗ s ⊗ 1)(k ⊗ k)k.


Notice that the tensor product used on the right hand side is the one in
C. Here is the proof that motivates this definition (ignoring the exchange rule hereafter):
▶ A⊥,B , ▶ A'⊥, B'

▶ A⊥, A'⊥,B ⊗ B' times
par
⊥ .....	'⊥	'
▶ A  ... A  ,B ⊗ B
“Tensor Unit”: The candidate for the unit of tensor is given by I =
{1U }⊥⊥. Below we shall show that it falls short; instead we get A  A ⊗ I for every object A.
Symmetry: The symmetry sA,B : A ⊗ B → B ⊗ A is defined as

sA,B = j(j ⊗ j)(s ⊗ 1 ⊗ 1)(1 ⊗ s ⊗ 1)(s ⊗ s)(1 ⊗ s ⊗ 1)(s ⊗ 1 ⊗ 1)(k ⊗ k)k.

Here is the proof that motivates this definition:
▶ B⊥,B , ▶ A⊥,A 
▶ B⊥, A⊥,B ⊗ A  times
▶ A⊥, B⊥,B ⊗ A exchange
par

▶ A⊥
Duality: Given A define
.....
...
B⊥,B ⊗ A


A⊥ = {f ∈ C(U, U )|f ⊥ g, for all g ∈ A}.

Note that A = A⊥⊥ by definition of objects in O(C).
Par product: Given A and B objects of O(C) we define


.....
.
B = {j1ak1 + j2bk2|a ∈ A⊥
,b ∈ B
⊥}⊥.


“Par Unit” The candidate for unit of par is of course ⊥= {1U }⊥, however as pointed out above for the case of tensor, ⊥ fails to be the unit of par.
Theorem 5.2 Let (C,T,U ) be a UDC-GoI Situation with the additional re-
quirement that U ⊗ U =∼ U (j, k). Then O(C) is a ∗-autonomous category without units.


Proof.	First we show that tensor is a bifunctor: note that 1A ⊗ 1B =
⎡	0	j1k1 + j2k2 ⎤
j	k = jsk = 1A⊗B. This uses the fact that jk =
j1k1 + j2k2	0
1U . It can also be shown that f 'f ⊗ g'g = (f ' ⊗ g')(f ⊗ g), for f, g, f ', g' of appropriate types using similar matrix calculations.
We define the structure morphisms as follows: ρA : A⊗I → A is defined by

ρA = j(j1 ⊗ k1)sk = j2k2 + j2k2 and ρ'
: A → A ⊗ I = j(k1 ⊗ j1)sk = j1k1k2 +

1	1	A

j2j1k1. λA : I ⊗ A → A = j(j2 ⊗ k2)sk, and λ'
: A → I ⊗ A = j(k2 ⊗ j2)sk.

Finally αA,B,C : A ⊗ (B ⊗ C) → (A ⊗ B) ⊗ C is defined as
αA,B,C = j(j ⊗ 1)(1 ⊗ j ⊗ j)(1U2 ⊗ s ⊗ 1)(1U2 ⊗ j ⊗ 1U2 )(1 ⊗ s ⊗ 1U3 )(s ⊗ s ⊗ s) (1 ⊗ s ⊗ 1U3 )(1U2 ⊗ k ⊗ 1U2 )(1U2 ⊗ s ⊗ 1)(1 ⊗ k ⊗ k)(k ⊗ 1)k.
This is motivated by the proof below:
▶ A⊥,A ▶ B⊥,B 
▶ A⊥, B⊥, (A ⊗ B)  ▶ C⊥,C 

▶ A⊥, B⊥, C⊥, (A ⊗ B) ⊗ C

▶ A⊥
, B⊥
.....
.
C⊥, (A ⊗ B) ⊗ C

▶ A⊥
....
...
(B⊥
.....
...
C⊥), (A ⊗ B) ⊗ C

We shall show below that the maps ρA and ρ'
are indeed O(C) morphisms

and that they form a retraction pair (ρ' , ρA) : A  A ⊗ I. First note that ρA : U → U . Let m ∈ A ⊗ I = {j1ak1 + j2bk2 | a ∈ A, b ∈ I}⊥⊥, one computes ρA.m = k1mj1, now let p ∈ A⊥, then j1pk1(j1ak1 +j2bk2) = j1pak1 is nilpotent and hence j1pk1 ∈ (A⊗I)⊥, therefore m ⊥ j1pk1 which implies that k1mj1 ⊥ p

and thus ρA.m ∈ A⊥⊥ = A. Similarly one gets that ρ' , λA and λ'
are O(C)

A	A
morphisms. Finally one computes that ρ' ρA = j2j1k2 + j2k1k2 /= 1A⊗I, on the

other hand ρAρ'
A	1	1
= j2k1 + j1k2 = 1A.

We omit the details of the verification of the coherence axioms and the naturality of ρA and λA in A.
Next we show that O(C) is symmetric and that the duality defined above on objects can be made into a full and faithful functor on O(C).  Indeed

⎡
after lengthy computations one gets sB,AsA,B = j ⎣

which is 1A⊗B, since jk = 1U .
0	j1k1 + j2k2
k
j1k1 + j2k2	0

Given f : A → B we define f ⊥ : B⊥ → A⊥ as f ⊥ = js(kfj)sk. (1A)⊥ = js(kjskj)sk = jsk = 1A⊥ and for f : A → B and g : B → C, (gf )⊥ = js(kgfj)sk = jsTr((1 ⊗ 1 ⊗ s)τ −1(kfj ⊗ kgj)τ )sk = jTr((1 ⊗ 1 ⊗ s)τ −1(k(jskgjsk)j ⊗ k(jskfjsk)j)τ )k = f ⊥g⊥ showing that (−)⊥ is a


functor. Now let f, g ∈ O(C)(A, B) such that f ⊥ = g⊥ then js(kfj)sk = js(kgj)sk which implies that s(kfj)s = s(kgj)s and hence f = g. Now let g ∈ O(C)(B⊥, A⊥), let f = js(kgj)sk, it is immediate that f ⊥ = g. Hence (−)⊥ is full and faithful.

We define A
....
...
B = (A⊥
⊗ B⊥)⊥
and need to show the required isomor-

phism.  Let f  ∈ O(C)(A⊗B, C⊥).  Define θ(f ) = j(1⊗j)(k⊗1)(kfj)(j⊗1)(1⊗

k)k and θ'(g) = j(j ⊗1)(1⊗k)(kgj)(1⊗j)(k ⊗1)k for g ∈ O(C)(A, B⊥
.....
.
C⊥).

Consider θ'(θ(f )) = j(j ⊗ 1)(1 ⊗ k)(kj(1 ⊗ j)(k ⊗ 1)(kfj)(j ⊗ 1)(1 ⊗ k)kj)(1 ⊗
j)(k ⊗ 1)k = f . Similarly θ(θ'(g)) = g and hence θ' = θ−1. Thus O(C) is a
∗-autonomous category.	 
Note that in this way we have constructed a model of MLL without units out of a UDC-GoI Situation. We now proceed to construct a model of MELL without units.
Theorem 5.3 Let (C,T,U ) be a UDC-GoI Situation with T = (T, ψ, ψI) and additional property that
U ⊗ U ∼= U (j, k) and TU ∼= U (u, v),
(T, d', e') is a comonad,
(T A, w' , c' ) is a commutative comonoid for each A ∈ C,
A  A
' is a map of commutative comonoids,

' and c'
are maps of coalgebras.

Then there is an endofunctor (!, ϕ, ϕI) on O(C) such that (O(C), !) is a de-
notational model of MELL without units.
Proof.
! : O(C) → O(C) is defined as follows. !(A) = {uT (a)v | a ∈ A}⊥⊥ which clearly is an object in O(C) and for f : A → B define

!f = j(ueU ⊗ u)ψ−1T ((dU ⊗ 1)(kfj)(d' ⊗ 1))ψ(e' v ⊗ v)k

We show that ! is a functor: !(1A) = jsk = 1!A which can be shown using
a simple matrix calculation and the fact that eU T (dU ) = 1TU and T (d' )e' =
U	U
1TU and that uv = 1U . Similarly it can be shown that !(gf ) =!g!f , using the
facts above, vu = 1TU and properties of trace.
We next define the monoidal natural transformations:
der :! =⇒ Id by derA :!A → A = j(udU ⊗ 1)s(d' v ⊗ 1)k. The definition is
motivated by:
▶ A⊥,A 
▶?A⊥,A dereliction


δ :! =⇒!! by δA :!A →!!A = j(ueU ⊗ ueU )ψ−1T ((eU ⊗ 1)ψ−1T ((dU ⊗ 1)s(d' ⊗
)ψ(e' ⊗ 1))ψ(e' v ⊗ e' v)k, motivated by the proof:
U	U	U
▶ A⊥,A 
▶?A⊥,A dereliction
▶?A⊥, !A ofcourse
▶?A⊥, !!A ofcourse
weak :! → KI by weakA :!A → I = j(uwU ⊗ m)(1I ⊗ 1I)(w' v ⊗ n)k = 0UU ,
motivated by the proof
  ▶ 1	 weakening
▶?A⊥, 1
Here I  U (m, n), 1 is the unit of tensor in MELL and 1I = 0II as I is the zero object in C.
con :! =⇒!⊗! by conA :!A →!A⊗!A = j(ucU ⊗ j)(1 ⊗ s ⊗ 1)(h ⊗ h)(1 ⊗

s ⊗ 1)(c' v ⊗ k)k where h = (eU ⊗ u)ψ−1T ((dU ⊗ 1)s(d'
⊗ 1))ψ(e'
⊗ v),

U
motivated by the proof
▶ A⊥,A 
▶?A⊥,A der
U	U

▶ A⊥,A 
▶?A⊥,A der

▶?A⊥, !A ofcourse ▶?A⊥, !A ofcourse
▶?A⊥, ?A⊥, !A⊗!A	times
▶?A⊥, !A⊗!A	contraction
All the necessary conditions for ! follow from the conditions on T . The well- definedness of monoidal natural transformations above follows from Theorem
4.5.	 

Double Glueing and Orthogonality
GoI Construction
In this section we recall Abramsky’s G construction [1]. This is related to the Geometry of Interaction interpretation for MLL in that the composition in the G(C) uses a version of Girard’s execution formula applied to the GoI interpretation of the cut rule. We will describe this construction and then
remark that it is equivalent to the Int construction of Joyal, Street, and Verity.
However, it is more natural to relate O(C) to G(C).
Definition 6.1 (The Geometry of Interaction construction) Given a traced symmetric monoidal category C we define a new category G(C), as follows:
Objects: Pairs of objects from C, e.g. (A+, A−) where A+ and A− are


objects of C.
Arrows: An arrow (A+, A−) −f→ (B+, B−) in G(C) is A+ ⊗B− −f→ A− ⊗B+
in C. The identity is given by 1(A+,A−) = sA+,A− .
Composition: Composition is given by symmetric feedback.	Given f : (A+, A−) → (B+, B−) and g : (B+, B−) → (C+, C−), gf : (A+, A−) →

(C+, C−) is given by gf = TrB−⊗B+
(β(f ⊗ g)α) where α and β are

permutations.
Tensor: (A+, A−) ⊗ (B+, B−) = (A+ ⊗ B+, A− ⊗ B−) and for (A+, A−)  f

(B+
, B−
) and (C
+, C−
g
) −→ (D
+,D ), f ⊗ g = (1A− ⊗ sB+ ,C− ⊗ 1D+ )(f ⊗

g)(1A+ ⊗ sC+,B− ⊗ 1D− ) and the tensor unit is (I, I).
Proposition 6.2 Let C be a traced symmetric monoidal category. Then G(C) deﬁned as in Deﬁnition 6.1 is a compact closed category. Moreover, N : C → G(C) with N(A) = (A, I) and N(f ) = f is a full and faithful embedding.

Proposition 6.3 ([11]) Let C be a traced symmetric monoidal category, then
G(C) ∼= Int(C).


Double Glueing
The double glueing construction we recall here is due to Tan and Hyland. Given a compact closed category, this construction produces a ∗-autonomous category which makes tensor and par distinct. The presentation here follows
[24] (see also [18]).
Let C = (C, ⊗,I, s, (−)∗) be a compact closed category. Let H denote the covariant hom functor C(I, −) : C → Set and K denote the contravariant
functor C(−,I) ∼= C(I, (−)∗) : Cop → Set.
Define a new category GC, the double glueing category of C, whose objects are triples A = (|A|, As, At) where |A| is an object of C, As ⊆ H(|A|) = C(I, A), is a set of points of A, and At ⊆ K(|A|) = C(A, I) ∼= C(I, A∗) is a set of copoints of A.
A morphism f : A → B in GC is a morphism f : |A| → |B| in C such that Hf : As → Bs and Kf : Bt → At. Given f : A → B and g : B → C in GC, the composite gf : |A| → |C| is induced by the morphism gf in C. The identity morphism on A is given by the identity morphism on |A| in C.
We will denote the underlying object of A by A, etc. Given objects A and
B we define the tensor product as follows: | A ⊗ B |= A ⊗ B, (A ⊗ B)s =
{σ ⊗ τ | σ ∈ As,τ ∈ Bs}, and (A ⊗ B)t = GC(A, B⊥). where given A,



⊥	∗	⊥ ⊥
.....
⊥	⊥ ⊥

A = (A , At, As). We define A −◦ B = (A⊗B )
and A . .
B = (A
⊗B ) .

Proposition 6.4 (Tan) For any compact closed category C, GC is a *- autonomous category with tensor ⊗ as above and unit 1 = (I, {idI}, C(I, I)).
Remark 6.5 Note that GC is a non-degenerate categorical model of MLL. That is, the tensor and par products are always distinct. For example, (I, ∅, ∅)⊗
.....
(I, ∅, ∅) = (I, ∅, C(I, I)) while (I, ∅, ∅) .. (I, ∅, ∅) = (I, C(I, I), ∅).
..
In a logical setting one can think of an object A of GC as an object A in C together with a collection of proofs of A (the collection As) and a collection of disproofs or refutations of A (the collection At.)
Proposition 6.6 There is a fully faithful monoidal (−)⊥–preserving embed- ding F : O(C) → G(GC).


Proof.	Note that an object in G(GC) consists of a triple ((A, B), As, At) where A, B are objects in C, As ⊆ C(B, A) and At ⊆ C(A, B)
The functor F is defined as follows: Given an object A ∈ O(C), F (A) = ((U, U ), A, A⊥) and given a morphism f : A → B in O(C), F (f ) = kfj. We shall verify that kfj is indeed a morphism from ((U, U ), A, A⊥) to ((U, U ), B, B⊥). Clearly kfj : U ⊗ U → U ⊗ U . Now let g ∈ A; then GC(I, kfj)g = (kfj)g = Tr((1 ⊗ g)s(kfj)s) = Tr(s(g ⊗ 1)(kfj)s) = f .g, and we know that f .g ∈ B as g ∈ A. Next, let g ∈ B⊥, GC(kfj, I)g = g(kfj) = Tr((1 ⊗ g)(kfj)) = Tr(s(g ⊗ 1)s(kfj)ss) = f ⊥.g. Recall that f : A → B and hence f ⊥ : B⊥ → A⊥ and so f ⊥.g ∈ A⊥. This verifies that F (f ) is a G(GC) morphism.
Next we shall verify that F is indeed a functor, F (1A) = F (jsk) =
k(jsk)j = s = 1FA. Let f : A → B and g : B → C, F (gf ) = F (jTrU⊗U	(

(1 ⊗ 1 ⊗ s)τ −1(kfj ⊗ kgj)τ )k) = TrU⊗U
F (g)F (f ). Here τ = (1 ⊗ 1 ⊗ s)(1 ⊗ s ⊗ 1).
((1 ⊗ 1 ⊗ s)τ −1(kfj ⊗ kgj)τ ) = 

Clearly F is injective on objects. Let f, g : A → B and F (f ) = F (g). Then kfj = kgj and so f = g. Also given g : ((U, U ), A, A⊥) → ((U, U ), B, B⊥), h := jgk : A → B is an O(C)-morphism and F (h) = g, hence F is a full and faithful embedding. Observe that (F A)⊥ = ((U, U ), A, A⊥)⊥ = ((U, U ), A⊥, A) = F (A⊥) and given f : A → B, and F (f ⊥) = F (js(kfj)sk) = kjs(kfj)skj = s(kfj)s = (Ff )⊥. As for the monoidal structure define ϕI : ((I, I), {1I}, C(I, I)) → ((U, U ), {1U }⊥⊥, {1U }⊥) by ϕI = 1U . Note that
F (A ⊗ B) = ((U, U ),A ⊗ B, (A ⊗ B)⊥) and F (A) ⊗ F (B) = ((U ⊗ U, U ⊗
U ), As, At) where As = {a ⊗ b | a ∈ A, b ∈ B} and At = G(GC)(F A, (FB)⊥). Define ϕA,B : F (A) ⊗ F (B) → F (A ⊗ B) by ϕA,B = (1 ⊗ s)(s ⊗ 1)(j ⊗ k). 

Conclusion and Future Work
In this paper we have used the UDC-GoI Situation to construct a denota- tional model for MELL without units, thus relating the GoI Semantics to
denotational semantics in the case of MELL. While this is fine for “sum” or “particle-style” GoI, the next natural step is to generalize to any GoI Situ- ation: this work is currently in progress. The most important aspect of this
new work will be the axiomatization of the orthogonality relation (cf. [18]) that will include the nilpotency based definition of Girard as an example. In this way one also hopes to include other categorical implementations of GoI, including “product”-style, like the one by Abramsky and Jagadeesan [4], that do not fit the UDC framework.
In [10], Girard extended the geometry of interaction to the full case, in- cluding the additives and constants. He also proved a nilpotency theorem for this semantics and its soundness with respect to a slight modification of familiar sequent calculus in the case of exponential-free conclusions. This too constitutes one of the main parts of our future work and thus construction of denotational models for full LL.
One of the most intriguing questions is full-completeness. While we have given precise connections with the fully complete double-gluing GoI models of MLL in [11], the actual lifting of Hyland-Tan-style full completeness theorems to our setting here appears to be not so straightforward, and is left for future work.
Last but certainly not least, we believe that GoI could be further used in its capacity as a new kind of semantics to analyze PCF and other fragments of functional and imperative languages and be compared to usual denotational and operational semantics through full abstraction theorems.

References
Abramsky, S. (1996), Retracing Some Paths in Process Algebra. In CONCUR 96, Springer LNCS 1119, pp. 1-17.
Abramsky, S. (1997), Interaction, Combinators and Complexity. Lecture Notes, Siena, Italy.
Abramsky, S., Haghverdi, E. and Scott, P.J. (2002), Geometry of Interaction and Linear Combinatory Algebras. Math. Structures in Comp. Sci., vol. 12(5), 2002, pp. 625-665, Cambridge.
Abramsky, S. and Jagadeesan, R. (1994), New Foundations for the Geometry of Interaction.
Information and Computation 111(1), pp. 53-119.
Barr, M. (1992), Algebraically Compact Functors. JPAA 82, pp. 211-231.
Danos, V. (1990), La logique lin´eaire appliqu´ee a` l’´etude de divers processus de normalisation et principalement du λ-calcul. PhD thesis, U. Paris VII.


Danos, V. and Regnier, L. (1995), Proof-nets and Hilbert Spaces. In J-Y. Girard et al. Eds.
Advances in Linear Logic, LNS, 222, pp. 307–328.
Girard, J.-Y. (1988), Geometry of Interaction II: Deadlock-free Algorithms. In Proc. of COLOG’88, Springer LNCS 417, pp. 76–93.
Girard, J.-Y. (1989a) Geometry of Interaction I: Interpretation of System F. In Proc. Logic Colloquium 88, pp. 221–260. North Holland.
Girard, J.-Y. (1995), Geometry of Interaction III: Accommodating the Additives. Advances in Linear Logic, J.Y. Girard et al. Eds., London Math. Soc. LNS 222, pp. 329–389, Cambridge University Press.
Haghverdi, E. A Categorical Approach to Linear Logic, Geometry of Proofs and Full Completeness, PhD Thesis, Univ. of Ottawa, Canada 2000.
Haghverdi, E. Unique Decomposition Categories, Geometry of Interaction and Combinatory Logic , Math. Structures in Comp. Sci. 10, 2000, pp. 205-231.
Haghverdi E., Partially Additive Categories and Fully Complete Models of Linear Logic,
TLCA’01, Springer LNCS, vol. 2044, pp. 197-216, 2001.
Haghverdi, E. and Scott, P.J. (2004), A Categorical Model for the Geometry of Interaction, ICALP 2004.
Hasegawa, M. (1997), Recursion from Cyclic Sharing : Traced Monoidal Categories and Models of Cyclic Lambda Calculus, TLCA’97, Springer LNCS 1210, pp. 196-213.
Hildebrandt, T. , Panangaden, P., Winskel, G, A Relational Model of Nondeterministic Dataflow, to appear in Math. Structures in Comp. Sci. , 2004.
Hines, P. A categorical framework for finite state machines, Math. Structures in Comp. Sci.
13, 2003, pp. 451-480.
Hyland, M and Schalk, A. Glueing and Orthogonality for Models of Linear Logic. Theoretical Computer Science vol. 294, 2003, pp. 183–231.
Joyal, A., Street, R. and Verity, D. (1996), Traced Monoidal Categories. Math. Proc. Camb. Phil. Soc. 119, pp. 447-468.
Manes, E.G. and Arbib, M.A. (1986), Algebraic Approaches to Program Semantics. Springer- Verlag.
Regnier, L. (1992), Lambda-calcul et R´eseaux, PhD Thesis, Univ. de Paris VII.
Selinger, P. (1999), Categorical Structure of Asynchrony. ENTCS, 20. Elsevier Science B.V.
Stefanescu, G. (2000), Network Algebra, Springer-Verlag.
Tan, A.M. Full Completeness for Models of Linear Logic. PhD thesis, Cambridge University, 1997.
