

Electronic Notes in Theoretical Computer Science 239 (2009) 85–103
www.elsevier.com/locate/entcs

Automatic Verification of Counter Systems With Ranking Function
Emmanuelle Encrenaz & Alain Finkel
LSV, ENS-Cachan & CNRS Cachan, France
{encrenaz,finkel}@lsv.ens-cachan.fr

Abstract
The verification of final termination for counter systems is undecidable. For non flattable counter systems, the verification of this type of property is generally based on the exhibition of a ranking function. Proving the existence of a ranking function for general counter systems is also undecidable. We provide a framework in which the verification whether a given function is a ranking function is decidable. This framework is applicable to convex counter systems which admit a Presburger or a LPDS ranking function. This extends the results of [6]. From this framework, we derive a model-checking algorithm to verify whether a final termination property is satisfied or not. This approach has been successfully applied to the verification of a parametric version of the ZCSP protocol.
Keywords: Final Termination Property, Ranking function, Convex Counter Systems, Automatic Verification, Parametric Protocol ZCSP.

Introduction
While verifying a parametric protocol (ZCSP) with FAST [2], we came across an interesting problem. We had to verify a ﬁnal termination property, expressing that the system will end in a given set of states in an unavoidable manner. Unfortunately, the class of counter systems modelling the protocol did not fit with the hypothesis under which FAST may automatically solve it: our model for ZSCP is neither flat nor trace-flattable.
Indeed, the final termination property is undecidable in the general case, and one has to consider some strong hypotheses to automate its verification. This ter- mination problem is classically solved by exhibiting a ranking function; it has been actively studied in the last three years in the context of code analysis for imperative programs containing loops with integer variables. In this context, [15] presents a complete method for the synthesis of linear ranking functions on the restricted class of single path loops. This result has been recently extended in [7] to (single path) nested loops and is implemented in the tool TERMINATOR [8], devoted to the anal-

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.05.032

ysis of C code for hardware device drivers. A complementary approach is presented in [14]. A semi-algorithm based on region graphs is proposed; it applies to exclusive multiple-path loops and is implemented in the PONES tool, devoted to the verifi- cation of Java programs. [6] synthesizes linear ranking functions for a larger class of systems: Integer-variable loops with multiple paths with non-exclusive guards. The synthesis is based on an enumeration of all linear functions (represented as Presburger formulas). The method is complete (if such a linear function exists, the procedure will eventually exhibit it), however, this work does not consider parame- ters.
Our contributions. We revisit the ranking function synthesis problem in the context of (possibly non deterministic) counter systems . We distinguish between the problem of the Existence of a ranking function and the problem of Verification whether a function in a given class is a ranking function. We first recall that the existence of a recursive ranking function is undecidable, but it becomes decidable when considering trace-flattable counter systems. Similarly, verifying whether a re- cursive function is a ranking function is undecidable although verifying a Presburger definable ranking function is decidable. Unfortunately, ZCSP does not admit any Presburger definable ranking function, but it admits a ranking function definable in a Presburger extension allowing multiplication with a unique parameter.
M. Bozga, R. Iosif and Y. Lakhnech showed in [5] that Linear Parametric Dio- phantine Systems (LPDS) are effectively solvable. LPDS strictly extend the existen- tial fragment of Presburger arithmetic in allowing the multiplication of a variable with a unique parameter p. We prove that verifying if a counter system (using Presb∃-definable linear functions and having a Presb∃-definable reachability set) satifies a LPDS definable ranking function is decidable.
From this result, we derive a procedure to automatically synthesize either Presburger-definable ranking functions or LPDS-definable ranking functions. The procedure will enumerate potential ranking functions and check them. The proce- dure terminates if and only if a Presburger-definable or a LPDS-definable ranking function exists. The proposed approach is used to verify a final termination prop- erty of the protocol ZCSP. The method extends the aforementionned works since our hypothesis are as general as [6] (which are larger than [14] and [7]), and the class of ranking functions we synthesize is larger than [6].
The exhibited ranking function could not have been found with the cited meth- ods or tools, since it required the most relaxed hypothesis (multiple-path loop with non-exclusive guards), and did not admit any Presburger linear ranking function. In particular, when analyzing multi-threaded programs, TERMINATOR focuses on the “thread termination” property, which is not the property we want to verify.
Organisation of the paper. A preliminary section collects some useful notions about flat and flattable counter systems. Sections 3 and 4 present an abstraction of the ZCSP protocol as a counter system and the verification of safety properties that have been achieved with FAST. Section 5 defines a method to prove the final termination of a counter system with the automatic synthesis of a ranking function. In Section 6, this method is illustrated on the model of ZCSP. The appendix gives

details about the ZCSP protocol and presents the derived counter system. The description of the ZCSP protocol and complete proofs of propositions in Sections 4, 5 and 6 are given in the appendix of the long version of the paper on the web pages of the authors.

Preliminaries
Counter systems
We recall that Presburger arithmetic is the first order theory of the structure
⟨N, +, =⟩. Given a Presburger formula φ with free variables belonging to the set C of counters and a ∈ NC, we write a |= φ if φ is true for the valuation a. A set X ⊆ Nn is said to be Presburger deﬁnable iff there is a Presburger formula ψ(x) with free variables x = ⟨x1,... , xn⟩ such that X = {a ∈ Nn : a |= ψ(x)}. This can be extended without problems to Zn. Presburger arithmetic is known to be decidable and therefore, all the problems in the forthcoming sections that can be reduced to Presburger arithmetic are decidable. We recall that the set of polyhedral convex sets is exactly equal to the set of Presb∃ definable sets, where Presb∃ is the Presburger existential fragment (without modulo). A Presburger function is a partial function definable by a Presburger formula. A Presburger-linear function f is a Presburger function which can be represented by a tuple (A, b, φ) where A is a square matrix in NC×C, b ∈ ZC and φ is a Presburger formula such that f (a)= A.a + b for every a |= φ (φ is a formula representing the domain of f , also denoted by dom(f )). We denote by ΣC the set of such functions.
Definition 2.1 A counter system is a graph whose edges are labeled with Pres- burger linear functions, that is a tuple CS = ⟨Q, E⟩ where E ⊆ Q × ΣC × Q.
With a counter system CS  = ⟨Q, E⟩, we associate the transition system
TS(CS) = ⟨Q × NC, →⟩ defined by (q, a) → (q', a') if there is a transition q f  q'
in E such that a' = f (a). A simple cycle in a graph G = ⟨Q, E⟩ is a closed path
(where the initial and final vertices coincide) with no repeated edge. G is said to be flat if every q ∈ Q belongs to at most one simple cycle. A counter system CS is said to have the ﬁnite monoid property if the multiplicative monoid generated by the matrices used in its labels is finite. Note that for a counter system CS = ⟨Q, E⟩, the control states can be encoded as positive integers (ie Q ⊆ N) and then the set of configurations is represented by N|C|+1.
Theorem 2.2 [11] Let CS be a flat counter system ⟨Q, E⟩ with the ﬁnite monoid property and TS(CS)= ⟨N|C|+1, →⟩ its associated transition system. Then the re- flexive and transitive closure →∗ of the reachability relation is effectively Presburger deﬁnable.
In the following, we will assume that the set of states is in Nn. In [9], a temporal logic for counter systems –FOPCTL٨(Pr)– is introduced. The model- checking of a flat counter system with the finite monoid property and a formula in FOPCTL٨(Pr)is decidable.

Model-checking for flattable systems
Flat counter systems have numerous desirable properties, however, realistic sys- tems are rarely flat. It is interesting to consider larger classes of systems – called flattable counter systems – that are reducible to flat counter systems via graph homomorphism [9].
Definition 2.3 Let CS = ⟨Q, E⟩ and CS' = ⟨Q', E'⟩ be two counter systems, having the finite monoid property, of the same dimension, h be a function h : Q' → Q, q ∈ Q and q' ∈ Q'. ⟨CS', q'⟩ is a h-flattening of ⟨CS, q⟩ iff h(q') = q, CS' is flat, and whenever ⟨s, f, s'⟩∈ E', we have ⟨h(s), f, h(s')⟩∈ E.
When ⟨CS', q'⟩ is a h-flattening of ⟨CS, q⟩, CS can be viewed as an abstraction of CS'. The tool FAST [2] generates flattenings via an exhaustive search algorithm. Several flattenings are defined and for each of them, the preserved sub-classes of FOPCTL٨(Pr)formulas are established. The most common relationship between CS and CS' is the equality of reachability sets (leading to the notion of post∗- flattening).
Let CS = ⟨Q, E⟩ be a counter system. The reachability sets from a configuration and from a set of Presburger definable configurations are defined as follows:

post∗
def
(⟨q, a⟩	{⟨q', a'⟩∈ Q × NC : ⟨q, a⟩ →∗ ⟨q', a'⟩}.

TS(CS)
post∗
) =
def 

post∗

(⟨q, a⟩).

TS(CS)(q, ψ(x)) =
a|=ψ(x)
TS(CS)

Definition 2.4 (from [9]) ⟨CS, q'⟩ is a h-post∗-flattening (post∗-flattening for

short) of ⟨CS, q⟩ with respect to ψ) iff post∗
(q, ψ)= h(post∗
' (q', ψ)) and

TS(CS)	TS(CS )
CS' is a h-flattening of CS (h is naturally extended to states of TS(CS)); we say
that ⟨CS, q⟩ is post∗-flattable.
Post∗-flattening preserves reachability properties [9]. Intuitively, a system CS' is a trace-flattening (cf. Appendix A) of a system CS if CS' is a h-flattening of CS and if the set of traces of CS is equal to the image by h of the set of traces of CS'. Trace-flattening preserves the LTL fragment of FOPCTL٨(Pr)which is decidable for trace-flattable counter systems. As a consequence, the final termination problem can be expressed as a LTL formula hence it is decidable for trace-flattable counter systems.
Example 2.5 The system CS1 described in Fig. 1 is not flat, but it is post∗- flattable from the initial configuration Init0 = N4. The reachability set from Init0
is obtained by the flat trace t1.t∗.t∗.t4 which can be computed by acceleration [11].
2 3
Moreover, CS1 is not trace-flattable [9]. The system produces a non-finite union
of flat traces (the size of the union depends on parameter p2, which is unbounded).
In practice, the post∗flattable framework works quite well for verifying safety properties (see e.g. [11],[3],[2]). But, realistic systems are rarely trace-flattable. Hence, the proof of final termination must, in general, rely on another approach.


t1 = [T RU E] → {x' := p1, y' := p2}
t2 = [x > 0] → {x' := x − 1, y' := y}
t3 = [x =0 ∧ y = 0] → {x' := p1, y' := y − 1}
t4 = [x =0 ∧ y = 0] → {x' := x, y' := y}




Fig. 1. A post*-flattable but not trace-flattable system
A counting abstraction of protocol ZCSP
Presentation of the protocol ZCSP
Protocol ZCSP (for Zero-Copy Secure Protocol) is a communication protocol imple- mented in the MPC parallel computer [10]. In essence, ZCSP protocol is a variant of BRP protocol that has been extensively studied (for instance, see [1]). In ZCSP several messages may be emitted before the respective acknowledgments are re- ceived; the acknowledgements may be received out of order; emitted messages have to be stored up to the reception of their own acknowledgment and those of their predecessors. This storage induces a greater complexity than BRP.
Desirable properties
P1. The number of table entry is constant (and equal to TMAX).
P2. At a given time, there is never more than one message under re-emission.
P3. If there is no re-emission, the counter of re-emission is set to 0.
P4. Each lost message will be re-emitted.
P5. Some message re-emission will reach the maximal retransmission bound.
P6. No re-emitted message oversteps the maximal retransmission bound.
P7. If the table contains any number of message to be emitted, and no new message is eventually inserted, then the table and channels will unavoidably become empty.

A counting abstraction of ZCSP
We present a counter system abstraction of ZCSP. The system has been abstracted in two directions : messages are atomic, and their identity is not not represented.
The counter system contain 14 counters. With this abstraction, messages in the table are not identified by their entry-index, but rather by their state. The content of the storage table is modeled as a set of five counters c1, c2, c3, c4, c5 indicating the number of messages in each corresponding category. The channel StoR, transmitting messages from the sender to the receiver, is modelled as two counters c6 and c7, distinguishing the first emission of a message from a re-emission. In the same way, the channel RtoS, transmitting acknowledgments from the receiver to the emitter is modelled by two counters c8 and c9. The timeout occurrences are modelled as two counters c10 and c11. The current number of re-emission is modeled as a counter c12. Counters c13 and c14 contain resp. the maximal retransmission number and the number of entry in the storage table.

We denote Z the counter system which is composed of a unique local state and 16 self-looping transitions. Every state s of Z is a tuple (s1, s2, ...s14) ∈ N14;
Proposition 3.1 Forall 1 ≤ i ≤ 7, if < Z |= Pi > then < ZCSP |= Pi >
Proof. (sketch) The abstraction represents an overapproximation of the set of be- haviours of ZCSP: files are represented as counters and bounds on files are relaxed. Moreover, messages are now atomic. This coarser representation does not miss any interleavings since in ZCSP, packets of a given message are sent atomically. 

Verification of safety properties with FAST
The counter system Z is not flat. Init is the initial state, defined as follows:
Init = {s ∈ N14 | s1 + s2 + s3 + s4 + s6 + s7 + s8 + s9 + s10 + s11 + s12 =0 ∧ s5 = s13 ∧ s13 > 0 ∧ s14 > 0}. Init represents the set of configurations when the pending message table is empty (all entries are free), the channels StoR and RtoS are empty, there is no pending timeout, and the re-emission counter is set to 0.
Proposition 4.1 (Z, Init) is post∗-flattable.
Hence reachability properties can be automatically checked. Properties P1 to P3, P4’ which is a relaxation of P4, and P5 to P6 were automatically verified with FAST.
We now concentrate on the property P7: “If the table contains any number of message to be emitted, and no new message is eventually inserted, then the table and channels will unavoidably become empty”. This property expresses a final termination, it is not reducible to a reachability property but is expressible in LTL or CTL. Unfortunately, the language of (Z, Init) contains a sequence of the form (abpc)n, hence:
Proposition 4.2 (Z, Init) is not trace-flattable.
Hence final termination properties cannot be checked by an automatic trace- flattening of (Z, Init). The automatic synthesis of a ranking function is an alterna- tive.

Proving final termination with automatic synthesis of ranking functions
Ranking function for termination
Let us note CSpresb the class of counter systems CS such that the relation →∗
is effectively Presburger definable. We denote CSpost∗ (resp. CStrace) the set of counter systems CS, with an initial Presburger set Init, such that it is post∗- flattable (resp. trace-flattable). Let us remark that: CStrace ⊆ CSpost∗ ⊆ CSpresb.
Definition 5.1 Let TS be a transition system and Init and F inal two sets.
< TS, Init, F inal > is deadlock-free if ∀s ∈ post∗ (Init) \ F inal, postTS(s) /= ∅.
TS 

Proposition 5.2 Given a counter system CS ∈ Cpresb and two Presburger sets
Init and F inal, the deadlockfree property of < TS(CS), Init, Final > is decidable.


When CS is flat with a finite monoid, then the set post∗
(Init) is an effective

Presburger-definable set, hence:
Corollary 5.3 Given a flat CS with a ﬁnite monoid and two Presburger sets Init
and F inal, the deadlockfree property of < TS(CS), Init, Final > is decidable.
Ranking functions are often used for proving termination. A general ranking function f is a function from the set S of states into an ordered set (N, ≺) such that there do not exist infinite strictly decreasing sequence in N . For counter systems CS of dimension n, we will study recursive functions from Nn+1 into N. This is not a restriction because to every ranking function f : Nn+1 → Nk,k ≥ 1 one may associate another ranking function f ' : Nn+1 → N such that f '(x)= y1 + y2 + ... + yk with f (x)= (y1, y2, ..., yk).
Definition 5.4 Let us consider a transition system TS(CS) =< S, →> with two sets of configurations Init, F inal ⊆ S and a function f : S → N. We say that a recursive function f is a ranking function of (TS(CS), Init, Final) if
∀x, x' ∈ post∗	(Init) \ F inal, x→x' implies f (x') < f (x).
Proposition 5.5 For any transition system TS(CS) =< S, →> equipped with two sets Init, F inal, such that (TS(CS), Init, Final) is deadlockfree, we have
< TS(CS),Init >|= AF Final iff there exists a ranking function for < TS(CS), Init, Final >.

Decidability of the ranking function property
Given a class C of transition systems (with S as set of states), a class X of recursive sets and a class F of recursive functions from S to N, we distinguish two problems associated with each triple (C, X, F ):
The Existence Ranking Problem ERP(C,X,F).
Input: Given a transition system TS =< S, →> in C, two sets of configura- tions Init, F inal ∈ X.
Output:  To decide whether there exists a ranking function f ∈ F for
< TS, Init, F inal > ?

The Verification Ranking Problem VRP(C,X,F).
Input: Given a transition system TS =< S, →> in C, two sets of configura- tions Init, F inal ∈ X and a function f ∈ F .
Output: Is f a ranking function of < TS, Init, F inal > ?
We denote Xpresb (resp. Xconv) the set of Presburger-definable sets (resp. the set of Presburger polyhedral convex sets) and Frec (resp. Fpresb and Fpresblin) the set of recursive functions (resp. Presburger functions and Presburger-linear functions).

From the fact that liveness properties are undecidable for post∗-flattable CS
with finite monoid, we deduce that:
Proposition 5.6 The Existence Ranking Problem ERP(CSpost∗ , Xpresb, Frec) is undecidable.
From the fact that the LTL model-checking of trace-flattable CS with a finite monoid is decidable [9], we may deduce:
Proposition 5.7 The Existence Ranking Problem ERP(CStrace, Xpresb, Frec) is de- cidable.
There exists a reduction of the problem of testing whether a recursive function is decreasing to the VRP(CSpost∗ , Xpresb, Frec). We build a CS of dimension n, with Init = 0 as the initial state; CS has an unique local state and for every counter ci, there exists a transition ti : ci := ci + 1. This counter system is not flat but
it is post∗-flattable and its reachability set is equal to post∗	= NC. Now the
condition for a recursive function f from NC into N to be a ranking function of
< TS(CS),Init = 0,F inal = NC >, remains to say that f is strictly decreasing. And this last problem is undecidable [12]. Hence we obtain:
Proposition 5.8 The Veriﬁcation Ranking Problem VRP(CSpost∗ , Xpresb, Frec) is undecidable.
Although this last problem was undecidable, there exists a decidable sufficient condition for any counter system CS and any Presburger function f ; as a matter of fact, one may always decide the satisfiability of the following Presburger formula: (∀x, x' ∈ NC+1, x→x' implies f (x') < f (x)). f is called a absolute ranking function. The VRP becomes decidable if one restricts the class of functions to be Presburger-definable. The condition to be a ranking function can be coded into a Presburger formula φ and we obtain that the VRP is true iff φ is satisfiable then
it becomes decidable.
Proposition 5.9 The Veriﬁcation Ranking Problem VRP(CSpresb, Xpresb, Fpresb) is decidable.
This last result may suggest to enumerate (fairly and efficiently) all Presburger functions and to test whether every Presburger function is a ranking function. This strategy will find a ranking function if there exists one Presburger ranking function. In the other case, the computation will not terminate. In particular, it may exist a non-Presburger ranking function.
For instance, let us suppose that there only exists a ranking function which uses some kind of multiplication between variables, typically between a parameter (i.e. a variable which is never modified) and a variable. In the general case, the VRP would be undecidable for this sort of functions. Let us first recall that Linear Diophantine Systems can be written as a boolean combination of linear equations of the form:

n i=1
ei.xi + e0 = 0 where all ei ∈ Z. Their set of solutions are a Presburger set,

and more precisely, a polyhedral convex Presburger set. It is possible to extend

this sort of systems to Linear Parametric Diophantine Systems in allowing some multiplications between one variable and the unique parameter.
Let us denote Zk[p] the set of polynoms of maximum degree k, whose unique variable is p. A Linear Parametric Diophantine System (LPDS) [5] is a Linear Diophantine System that can be written as a boolean combination of equations of

the form: Σn
ei.xi + e0 =0 where all ei ∈ Zk[p]. From [5] (Theorem 2) one knows

that the satisfiability problem for LPDS is decidable.
Let us note that LPDS strictly extends the existential fragment of Presburger arithmetic. On the other hand, no universally quantified Presburger formula is al- lowed in LPDS. A formula which is both in Presburger and in LDS is in Presb∃. We now define LPDS functions allowing a kind of multiplication between any vari- able and the unique parameter p.
Definition 5.10 A LPDS function is a function definable by a LPDS.
We denote by FLP DS the set of LPDS functions. For example, f (x) = ci.x + dj with ci in Zk[p]C and dj in Zk[p] is a LPDS function. Let us remark that every (integer) linear function with a polyhedral convex domain is a LPDS function without parameter. The converse is obviously false.
Definition 5.11 A counter system (CS, Init) is said convex if the domain of each

Presburger-linear function of CS is polyhedral convex and if post∗
(Init) is

polyhedral convex.
Let us denote by CSconv the set of convex counter systems. From the fact that given a Presburger formula, one may decide if it is equivalent to a formula in Presb∃, we deduce :
Proposition 5.12 The convex property is decidable for counter systems with a effective Presburger reachability set.
Proposition 5.13 The VRP(CSconv, Xconv, FLP DS) is decidable.
Model-checking procedure for counter systems
The model-checking procedure consists in enumerating functions, and for each fonc- tion, check if it satisfies the ranking function condition.
First we have to find the parameters. This is performed either by a syntactical analysis of the counter system (we find among the variables those which are in fact parameters, i.e. which are never modified by all the functions of the counter system), or by a dynamic analysis of the reachable state set (we may test if a variable x is a parameter in computing post∗ and in verifying that the variable x never changes its value). If there are no parameters, enumerate Presburger functions and test. Else, for every parameter, enumerate the LPDS functions and test whether it is a ranking function.

Procedure Model-Check(CS:counter system; Init, F inal:	two polyhedral convex sets)

Compute with FAST Post∗
(Init);

Compute Deadlock = 

t∈E
¬dom(t);

if Post∗
(Init) ∩ Deadlock /= ∅ return FALSE;

Compute the set P of parameters of CS;
If P = ∅ then
Enumerate all Presburger functions f
If f is a ranking function for <	TS(CS), Init, Final	> then return TRUE else goto 5(a)
Else for every parameter p ∈ P enumerate all LPDS functions f
If CS is a convex counter system then
If f is a ranking function for < TS(CS),Init,Final > then return TRUE
else goto 6.
Else If f is a absolute ranking function then return TRUE else goto 6.
Proposition 5.14 If procedure Model-Check  terminates then CS, Init  |=
AF  Final.
The converse is not true : a system may have a ranking function not being in FLP DS neither in Fpresb. In this last case, the procedure Model-check will not find it and will not terminate.

Proving final termination in finding a ranking func- tion
Let us return back to the verification of property P7 of system Z. In Z, the emission of new messages is modeled by transition t1. We consider Z' being the system Z without transition t1. We denote Init' the set of states representing the non empty table.
Init' = post∗ (Init)= {s1 ≤ s13  ∧  s2+s3+s4+s5+s7+s8+s9+s10+s11+s12 =
0  ∧  s6 = s1  ∧  s13 > 0  ∧  s14 > 0}.
We denote F inal' the unavoidable set of states in Z' from Init'. F inal' repre- sents a table with all entries being free and channels being empty. It corresponds to the set of states Init.
Property P7 may be now expressed as : ∀s ∈ Post∗ (Init),s  |= AF  Final'.
This can be rephrased in Z' : < Z',Init' |= AF  Final' >.
To prove this property, we apply the algorithm defined in Sec. 5.3.
Remark : We can see that Init', F inal' and the domain of each each transition of Z' are convex. Even if we can theoretically decide whether Z' is convex or not, we were not able to automatically test it; it will be done once the implementation of the result of [13] will be achieved.
Here are the successive steps of the Model-Check(Z',Init',F inal'):

step 1. Compute Post∗ '(Init')
step 2. Compute Deadlock = ∩2≤i≤16чdom(ti)
step 3. post∗ '(Init') \ F inal'  Deadlock = ∅
step 4.  By a static analysis of the transitions of Z', we determine the set of parameters P = {c13, c14}.
step 5. As P /= ∅, we directly jump to step 6.
step 6. Consider parameter c14 in P and enumerate the LPDS function f with respect to parameter c14.
step 6.a. We don’t know whether Z' is convex : this requieres to determine whether
post∗ ' (Init') is convex; this is decidable but not automated yet.
step 6.b. For each f , decide whether f is an absolute ranking function.
Let f be the following LPDS function from N14 to N:
f (s)= (3.s14 + 5)(3.s6 + 2.s8 + s10)  + (3.s14 + 4).s4  + (3.s7 + 2.s9 + s11 + 3.s12)
+ 2.s2 + (s13 — s5)
Proposition 6.1 f is a LPDS absolute ranking function for < Z',Init',Final' >.
We also prove that:
Proposition 6.2 < Z',Init',Final' > does not admit a linear ranking function.

Conclusion and perspectives
We characterize the classes of systems for which the proposed analysis is feasable. We propose a model-checking algorithm to analyse the final termination property of counter systems. Our procedure is complete: the procedure terminates iff a ranking function of a given class exists. Our results extend the class of Bradley’s ranking functions and are complementary to those obtained with TERMINATOR for nested loops.
In order to automate the model-checking procedure, several points have to be solved.
to have an efficient procedure for solving LPDS. To the best of our knowledge, no such dedicated tool exists.
to have an efficient enumeration scheme of potential ranking functions (either Presburger or LPDS definable). One could follow Bradley’s approach to prune the enumeration space.
to determine whether Post∗(Init) is a polyhedral convex set. A way to proceed consists in translating the symbolic representation of Post∗(Init) into a Presburger formula, and then to check whether this formula is convex or not.

References
P. Abdulla, A. Annichini, and A. Bouajjani. Symbolic verification of lossy channel systems: Application to the bounded retransmission protocol. In Tools and Algorithms for the Consctruction and Analysis


of Systems (TACAS), volume 1579 of Lecture Notes in Computer Science, pages 208–223. Springer, 1999.
S. Bardin, A. Finkel, J. Leroux, and L. Petrucci. Fast: Fast acceleration of symbolic transition systems.
In CAV 2003, 15th International Conference on Computer-Aided Verification, Boulder, CO, USA, volume 2725 of Lecture Notes in Computer Science, page short paper. Springer, 2003.
S. Bardin and L. Petrucci. From pnml to counter systems for accelerating petri nets with fast. In
Workshop on Interchange Format for Petri Nets, Bologna, Italy, pages 26–40, 2004.
V. Beaudenon, E. Encrenaz, and J.-L. Desbarbieux. Design validation of zcsp with spin. In IEEE 3rd Int. Conf. on Application of Concurrency to System Design (ACSD), pages 102–110. IEEE Computer Society Press, 2003.
M. Bozga, R. Iosif, and Y. Lakhnech. Flat parametric counter automata. In Automata, Languages
and Programming, 33rd International Colloquium, ICALP 2006, Venice, Italy, Proceedings, Part II, volume 4052 of Lecture Notes in Computer Science, pages 577–588. Springer, 2006.
A. Bradley, Z. Manna, and B. Sipma. Termination analysis of integer linear loops. In CONCUR 2005
- Concurrency Theory, 16th International Conference, CONCUR 2005, San Francisco, CA, USA,, volume 3653 of Lecture Notes in Computer Science, pages 488–502. Springer, 2005.
B. Cook, A. Podelski, and A. Rybalchenko. Termination proofs for systems code. In PLDI, Proceedings of the ACM SIGPLAN 2006 Conference on Programming Language Design and Implementation, Ottawa, Ontario, Canada, June 11-14, 2006, pages 415–426, 2006.
B. Cook, A. Podelski, and A. Rybalchenko. Terminator: Beyond safety. In Computer Aided Verification, 18th International Conference, CAV 2006, Seattle, WA, USA, pages 415–418, 2006.
S. Demri, A. Finkel, V. Goranko, and G. van Drimmelen. Towards a model-checker for counter systems.
In ATVA 2006, 4th International Symposium on Automated Technology for Verification and Analysis, Beijing, Rep. of China, volume 4218 of Lecture Notes in Computer Science, pages 493–507. Springer, 2006.
J.-L. Desbarbieux, O. Glck, A Zerrouki, A. Fenyo, A Greiner, F. Wajsbrt, C. Spasevski, F. Silva, and
E. Dreyfus. Protocol and performance analysis of the mpc parallel computer. In 15th Int. Parallel and Distributed Processing Symposium, page 52. ACM, 2001.
A. Finkel and J. Leroux.	How to compose presburger accelerations: Application to broadcast
protocols. In 22th Conference on Foundations of Software Technology and Theoretical Computer Science (FST&TCS), Kanpur, India, volume 2556 of Lecture Notes in Computer Sciences, pages 145–
156. Springer, 2002.
Alain Finkel, Pierre McKenzie, and Claudine Picaronny. A well-structured framework for analysing Petri net extensions. Information and Computation, 195(1-2):1–29, November 2004.
J. Leroux. A polynomial time presburger criterion and synthesis for number decision diagrams. In 20th
IEEE Symp. Logics in Computer Science (LICS), pages 147–156. IEEE Computer Society Press, 2005.
S. Leue and W. Wei. A region graph based approach to termination proofs. In TACAS, Tools and Algorithms for the Construction and Analysis of Systems, 12th International Conference, TACAS 2006 Held as Part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2006, Vienna, Austria, March 25 - April 2, 2006, pages 318–333, 2006.
A. Podelski, A.and Rybalchenko. A complete method for the synthesis of linear ranking functions.
In Verification, Model Checking, and Abstract Interpretation, 5th International Conference, VMCAI 2004,, volume 2937 of Lecture Notes in Computer Science, 2004.

Appendix A – Definition of trace-flattening
Let CS = ⟨Q, E⟩ be a counter system. A trace for ⟨q, a⟩ is a (possibly infinite) sequence of the form ⟨q0, a0⟩ ⟨q1, a1⟩ ⟨q2, a2⟩ ... such that ⟨q0, a0⟩ = ⟨q, a⟩, and for every i, ⟨qi, ai⟩→ ⟨qi+1, ai+1⟩ in Q × NC. The set of traces for ⟨q, a⟩ in C is denoted

by tracesCS
(⟨q, a⟩). By extension, traces
def
CS(q, ψ) =
⟨q,a⟩|=ψ
tracesCS
(⟨q, a⟩).

Definition 7.1 ⟨CS', q'⟩ is a h-trace-flattening (trace-flattening for short) of
⟨CS, q⟩ with respect to ψ iff tracesCS(q, ψ) = h(tracesCS' (q', ψ)) and CS' is a h- flattening of CS; we say that ⟨CS, q⟩ is trace-flattenable.



Fig. 2. A scenario of ZCSP.

Appendix B – Details about ZCSP protocol
Overall architecture of the protocol
A first model has been developed and verification of a finite instance has been achieved with model checker SPIN ([4]). This model is very close to the real imple- mentation of the protocol, in particular, the management of the pending messages is faithfully represented. The overal architecture of the protocol is presented in Fig. 3 in Appendix. It is composed of one emitter and one receiver connected through two unidirectional bounded channels storing and retrieving data in FIFO order. Details of the processes are given in [4]. The emitter is composed of a pending message table (detailled in Appendix), and two asynchronous processes sender and update modi- fying its content. The receiver is composed of a unique process receiver. It checks that the received packet is the awaited one, and sends an acknowledgment if the received packet was the last one of the message. Channel StoR stores the message packets from the emitter to the receiver and channel RtoS stores acknowledgment packets from the receiver to the emitter.

A possible scenario
Fig. 2 presents a possible scenario. A message A is transmitted and its acknowledg- ment is lost. Meanwhile, a message B is transmitted correctly. Then the message A is entirely re-emitted. The order of acknowledgments does not follow the order of (first) emission of messages.

Architecture of the protocol
Fig. 3 presents the overall architecture of the protocol.









Fig. 3. Architecture of ZCSP.


Structure of the table
The pending message table is an array of TMAX slots, which contains information about the messages
already sent, but not acknowledged yet,
already acknowledged, but preceded by a non-acknowledged message (under re- emission).
One slot may either be free or contain the information concerning a pending message. This concerns : the first sequence number of the message, the number of packets of the message, the acknowledgment bit, the retransmission bit.
Accesses to the table are performed in a circular manner. Entries in the table are pointed out by three pointers : FF (indicates the “first free”entry, where the next pending message will be placed), FT (for “first timeout” indicates the pending message that will be altered by the next timeout’s occurrence), and EldP (indicates the “eldest” pending message altered by a timeout and not acknowledged yet (under re-emission)).
Processes sender and update read and modify the content of the pending entry table. When a new message has to be sent, process sender places the message identifier in the first free entry table (modifying FF pointer), and sends the message into the StoR channel. When an acknowledgment or a timeout is received, process update modifies the table entry pointers, either FT in case of timeout, or eldP and FT in case of an acknowledgment.


Eld_P	FT	FF





free
sent, not acknowleded nor timeout sent, timeout, currently re−emitted sent, acknowledged
sent, timeout (to be re−emitted)
Fig. 4. A configuration of the table.

The counting abstraction of the table
Entries in the message pending table are classified into five sets.

Set 1 : message sent, no timeout occurred, no acknowledgment received (message entry in ]FT, FF [ and ack =0 ∧ retransmit = 0)
Set 2 : message sent, ack received but a previous message received a timeout (hence, cannot leave the table yet) (message entry in ]FT, FF [ and ack = 1)
Set 3 : message currently under re-emission (message entry in ]eldP ,FT ] and
ack =0 ∧ retransmit =1 and eldP = FT — 1)
Set 4 : message to be re-emitted (message entry in ]eldP ,FT ] and ack = 0 ∧
retransmit =1 and eldP < FT — 1)
Set 5 : free (message entry in [FF, eldP [ ) 
Fig. 4 presents a configuration of the pending message table, and classify the message entries.

Appendix C – Parametric counter program of the ab- straction of ZCSP
The parametric counetr program of the abstraction of ZCSP is given in table 1.

Appendix D – Safety properties of ZCSP.
P1 : The number of table entry is equal to T .
Let I1 = {s ∈ N14 | s13 = s1+s2+s3+s4+s5} then P1 = Post∗(Init)   N14\I1 = ∅
P2 : There is never more than one message under re-emission.
Let I2 = {s ∈ N14 | s3 ≤ 1} then P2 = Post∗(Init)  N14 \ I2 = ∅ P3 : If there is no re-emission, the counter of re-emission is set to 0. Let I3 = {s ∈ N14 | s3 = 0&s12 > 0} then P3 = Post∗(Init)  I3 = ∅
P4 : Each lost message will be re-emitted. This property is relaxed into P4’:


Table 1
Parametric abstraction of ZCSP.

”There exists some message being re-emitted”.
Let I4 = {s ∈ N14 | s3 = 1&s12 > 0} then P4’ = Post∗(Init)  I4 /= ∅
P5 : There exists some message whose retransmission number reaches the maximal bound.
Let I5 = {s ∈ N14 | s3 = 1&s12 = s14} then P5 = Post∗(Init)  I5 /= ∅
P6 : No re-emitted message oversteps the maximal retransmission bound.
Let I6 = {s ∈ N14 | s3 = 1&s12 > s14} then P6 = Post∗(Init)   N14 \ I6 = ∅

Appendix E – Proofs of propositions about ZCSP
Proposition 4.1
(Z, Init) is post∗-flattable.
Proof. We introduce an invariant to guide the space-search and help FAST to terminate. The set I = {s ∈ N14 | s7 + s9 + s11 = s3} is an invariant of (Z, Init) : it is true in Init, and the firing of any transition ti for 1 ≤ i ≤ 16 preserves I. As I is an invariant from Init, post∗(Init)= post∗(Init ∩ I). Using the tool FAST, the computation of Post∗ (Init ∩ I) terminates thanks to the acceleration of sequences of length 2.	 
Let f be a LPDS function from N14 to N:
f (s)= (3.s14 + 5)(3.s6 + 2.s8 + s10)  + (3.s14 + 4).s4  + (3.s7 + 2.s9 + s11 + 3.s12)
+ 2.s2 + (s13 — s5)
Proposition 6.1
f is a LPDS absolute ranking function for < Z',Init',Final' >.

Proof.
We prove that ∀s, s' ∈ Post∗ (Init') such that s ti

s' : f (s') < f (s) by a case

Z'	→
splitting analysis (forall ti with 2 ≤ i ≤ 16). Each case is proven with the help of
tool Maple. Hence f is a ranking function for < Z',Init',Final' > and property
P7 is satisfied.	 
Proposition 6.2
< Z',Init',Final' > does not admit any ranking linear function.
Proof. Let f be a linear function from N14 → N. f is of the form : f (s)= a.s + b
with s ∈ N14, a ∈ ZZ14, and b ∈ N.
To prove that Z' does not admit any linear ranking function, one has to prove that there exists some states s and s' in Post∗ ' (Init') \ F inal' such that s → s', and the expression f (s') — f (s) < 0 does not admit a solution.

For each transition ti
with 2 ≤ i ≤ 16, and state s' such that s ti
s' we build the

expression : ∀s, s' ∈ Post∗(Init'), (s ti
s' ∧ f (s')— f (s) < 0). Considering transition

t2, this leads to : for every s14 ∈ N : a12.s14 < a1 + a10 —(a7 + a3). Assuming a12 > 0 (this is inferred by solving the inequality for other transitions), this last expression is not solvable with ai terms being naturals : the difference of two natural terms must be greater than an unbounded term, this leads to a contradiction.	 

Appendix F – Proofs of propositions about ranking func- tions
Proposition 5.2
Given a counter system CS ∈ Cpresb and two Presburger sets Init and F inal, the deadlockfree property of < TS(CS), Init, Final > is decidable.

Proof. From the hypothesis, post∗
(Init) is Presburger-definable then

∗
TS(CS)
(Init) \ F inal is also a Presburger-definable set because Presburger

logics is closed by difference.	Hence the condition that for every state s ∈

∗
TS(CS)
(Init) \ F inal, postTS(CS)(s) /= ∅ may be encoded by another Presburger

formula whose satisfiability is decidable.	 
Proposition 5.5
For any transition system TS =< S, →> equipped with two sets Init, F inal, such that (TS, Init, Final) is deadlockfree, we have < TS, Init >|= AF Final iff there exists a ranking function for < TS, Init, F inal >.
Proof. ⇒. Assuming ∀s ∈ Init, s |= AF  Final, let us build a ranking function of
< TS, Init, F inal >. Let s ∈ Post∗(Init) \ F inal. We first state that there exists some infinite sequence starting in s : post∗(s) represents an infinite state-space, but as the number of transitions of TS is bounded, the output-arity of each state is bounded. By applying K¨onig’s Lemma, one concludes that there exists some infinite sequence from s. As TS is deadlock-free, all sequences are unbounded. We then define f (s) as the length of the longest sequence from s avoiding F inal. We now prove that f (s) /= ω : if f (s) were infinite, then s would not verify AF Final, contradiction. Consider now s' such that s → s'. As s ∈ Post∗(Init) \ F inal and s |= AF Final, s' |= AF Final and f (s') ≤ f (s) — 1. We have f (s') < f (s). Moreover, f is recursive than f is a ranking function for < TS, Init, F inal >.
Let us consider a deadlock-free post∗-flattable system, two Presburger sets Init and F inal, and a ranking function f . Let s ∈ post∗(Init) \ F inal and f (s) = n. Two cases have to be considered :
n = 0. We prove that s ranked at 0 has all its successors in F inal: TS is deadlock- free, hence s has at least one successor s'; assume s' not being in F inal, then s' is associated with a rank given by f (s'), and by definition of the ranking function, f (s') < f (s); as the co-domain of f is N, this is a contradiction. It follows that every successor of s is in F inal, and s |= AF Final.
n /= 0. Then each sequence σ starting in s has at most n successor states not being in F inal. We conclude that s |= AF Final.

Proposition 5.13
The VRP(CSconv, Xconv, FLP DS) is decidable.
Proof. Let CS be a polyhedral convex counter system in CSconv, Init, F inal two convex sets in Xconv and f ∈ FLP DS a LPDS function. The negation of the VRP

of f for < TS(CS), Init, Final > can be translated into the satisfaction problem of a LPDS formula.
We build the formula : Φ = ∃x, x' : φ1(x, x') ∧ φ2(x, x') ∧ φ3(x, x') rep- resenting a counter-example to the fact that f is a ranking function for < TS(CS), Init, Final > where:

φ1(x, x')= x ∈ post∗
(Init) \ F inal ∧ x' ∈ post∗
(Init) \ F inal ,

φ2(x, x')= f (x) ≥ 0 ∧ f (x') ≥ 0,
φ3(x, x') =  g ∈ ΣC, (x ∈ dom(g) ∧ x ∈ dom(f ) ∧ x' ∈ dom(f ) ∧ x' = g(x) ∧
f (x') ≥ f (x)).
The formula φ1 is in Presb∃ from the hypothesis. The formulas φ2 and φ3 are both LPDS formulas. Hence the formula φ1(x, x') ∧ φ2(x, x') ∧ φ3(x, x') is still a LPDS formula; moreover, LPDS systems are closed by existential quantifiers hence Φ is a decidable LPDS formula.	 
