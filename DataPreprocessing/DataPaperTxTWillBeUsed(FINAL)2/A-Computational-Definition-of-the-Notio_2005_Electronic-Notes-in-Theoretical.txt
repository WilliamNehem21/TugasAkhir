Electronic Notes in Theoretical Computer Science 117 (2005) 249–261 
www.elsevier.com/locate/entcs


A Computational Definition of the Notion of Vectorial Space
Pablo Arrighia and Gilles Dowekb
a Institut Gaspard Monge, 5 Bd Descartes, Champs-sur-Marne, 77454 Marne-la-Vall´ee Cedex 2,
France
arrighi@univ-mlv.fr
b E´cole polytechnique and INRIA
LIX, E´cole polytechnique, 91128 Palaiseau Cedex, France
Gilles.Dowek@polytechnique.fr http://www.lix.polytechnique.fr/˜dowek/


Abstract
We usually define an algebra by a set, some operations defined on this set and some propositions that the algebra must validate. In some cases, we can replace these propositions by an algorithm on terms constructed upon these operations that the algebra must validate. We show in this note that this is the case for the notion of vectorial space and bilinear function.
Keywords: Rewrite system, vectorial space, bilinear function, tensorial product

One way to prove the equality of two vectors expressed by terms such as
2.x + y + 3.x and 5.(x + y)+ (−4).y is to transform these terms into linear combinations of the unknowns and check that the terms obtained this way are the same. This algorithm transforming a term expressing a vector into a linear combination of the unknowns is also useful to express the operational semantic of programming languages for quantum computing [1], because in such languages a program and its input value form a term expressing a vector whose value, the output, is a linear combination constants. More generally, several algorithms used in linear algebra, such as matrix multiplication algo- rithms, transform a term expressing a vector with various constructs into a linear combination of constants.
The algorithm transforming a term expressing a vector into a linear com- bination of the unknowns is valid in all vectorial spaces. The goal of this note


1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.06.013


is to show that, moreover it completely defines the notion of vectorial space. This computational definition of the notion of vectorial space can be extended to define other algebraic notions such as bilinearity.

Algorithms and models
Definition 1.1 (Rewriting) Let L be a first-order language and R be a rewrite system on L. We say that a term t R-rewrites in one step toa term u if and only if there is an occurrence α in the term t, a rewrite rule l −→ r in R, and a substitution σ such that t|α = σl and u = t[σr]α.
Definition 1.2 (Associative-Commutative Rewriting) Let L be a first- order language containing binary function symbols f1, ..., fn and R be a rewrite system on L. We say that a term t R/AC(f1, ..., fn)-rewrites in one step to a term u if and only if there is term t', an occurrence α in the term t', a

rewrite rule l −→ r in R, and a substitution σ such that t' =AC t, t'
= σl

and u =AC t'[σr]α.
Remark 1.3 This notion must be distinguished from that of R,AC-rewriting where a term t rewrites to a term u only when it has a subterm AC-equivalent to an instance of the left hand side of a rewrite rule. For instance with the rule x+x −→ 2.x the term t+(u+t) R/AC-rewrites to 2.t+u but is R, AC-normal.
Definition 1.4 (Algebra) Let L be a first-order language. An L-algebra is a family formed by a set M and for each symbol f of L of arity n, a function fˆ
from Mn to M . The denotation t)φ of a term t for an assignment φ is defined as usual.
Definition 1.5 (Model of a rewrite system) Let L be a first-order lan- guage and R an algorithm defined by a rewrite system on terms of the language
L. An L-algebra M is a model of the algorithm R, or the algorithm R is valid in the model M, (M |= R) if for all rewrite rules l −→ r of the rewrite system and valuations φ, l)φ = r)φ.
Example 1.6 Consider the language L formed by two binary symbols + and
× and the algorithm R defined by the rules
(x + y) × z −→ (x × z)+ (y × z) x × (y + z) −→ (x × y)+ (x × z)
transforming for instance, the term (a + a) × a to the term a × a + a × a. The algebra ⟨{0, 1}, min, max⟩ is a model of this algorithm.
Remark 1.7 This definition of the validity of an algorithm in a model extends some definitions of the semantics of a programming language where a semantic


is defined by a set M , a function [ ] mapping values of the language to elements of M and n-ary programs to functions from Mn to M , such that the program P taking the values v1, ..., vn as input produces the value w as output if and only if [w]= [P ]([v1], ..., [vn]).
Indeed, let us consider a programming language where the set of values is defined by a first-order language, whose symbols are called constructors. Consider an extension of this language with a function symbol p and possibly other function symbols. A program P in this language is given by a terminat- ing and confluent rewrite system on the extended language, such that for any n-uple of values v1, ..., vn the program P taking the values v1, ..., vn as input produces the value w as output if and only if the normal form of the term p(v1, ..., vn) is w. Then, a model of this rewrite system is formed by a set M , for each constructor c of arity m, a function cˆ from Mm to M , a function pˆ from Mn to M , and possibly other functions, such that for all rules l −→ r of the rewrite system and valuations φ, l)φ = r)φ.
The denotations of the constructors define the function [ ] above mapping values to elements of M and the function pˆ is the function [P ]. For any n-uple of values v1, ..., vn, if the normal form of the term p(v1, ..., vn) is the value w then w) = pˆ( v1), ..., vn)) and thus [w]= [P ]([v1], ..., [vn]).
Definition 1.8 (Model of an AC-rewrite system) Let L be a first-order language containing binary function symbols f1, ..., fn, and R an algorithm defined by an AC(f1, ..., fn)-rewrite system on terms of the language L. An L-algebra M is a model of the algorithm R (M |= R) if
for all rewrite rules l −→ r of R and valuations φ, l)φ = r)φ,
for all valuations φ and indices i

 fi(x, fi(y, z)))φ =  fi(fi(x, y), z))φ
 fi(x, y))φ =  fi(y, x))φ

Vectorial spaces
An algorithm
Let L be a 2-sorted language with a sort K for scalars and a sort E for vectors containing two binary symbols + and × of rank ⟨K, K, K⟩, two constants 0 and 1 of sort K, a binary symbol, also written +, of rank ⟨E, E, E⟩, a binary symbol . of rank ⟨K, E, E⟩ and a constant 0 of sort E.
To transform a term of sort E into a linear combination of the unknows, we want to develop sums of vectors


λ.(u + v) −→ λ.u + λ.v
but factor sums of scalars and nested products
λ.u + µ.u −→ (λ + µ).u
λ.(µ.u) −→ (λ × µ).u
we also need the trivial rules
u + 0 −→ u
0.u −→ 0
1.u −→ u
and, finally, three more rules for confluence

λ.0 −→ 0
λ.u + u −→ (λ + 1).u u + u −→ (1 + 1).u
As we want to be able to apply the factorization rule to a term of the form (3.x+ 4.y)+ 2.x, reductions in the above rewrite system must be defined modulo the associativity and commutativity of +. This leads to the following definition.
Definition 2.1 (The rewrite system R) The rewrite system R is the AC(+)-rewrite system
u + 0 −→ u
0.u −→ 0
1.u −→ u
λ.0 −→ 0
λ.(µ.u) −→ (λ.µ).u λ.u + µ.u −→ (λ + µ).u λ.u + u −→ (λ + 1).u
u + u −→ (1 + 1).u
λ.(u + v) −→ λ.u + λ.v


To be complete, we should also transform the axioms of the theory of fields into a rewrite system, which is known to be difficult. However, there are many fields, for instance the field Q of rational numbers, whose addition and multiplication can be presented by a terminating and ground confluent rewrite system. Thus, we shall not consider an arbitrary vectorial space over an arbitrary field. But, we consider a given field K defined by a terminating and ground confluent rewrite system S and focus on K-vectorial spaces.
Definition 2.2 (Scalar rewrite system) A scalar rewrite system is a rewrite system on a language containing at least the symbols +, ×, 0 and 1 such that:
S is terminating and ground confluent,
for all closed terms λ, µ and ν, the pair of terms
0+ λ and λ,
0 × λ and 0,
1 × λ and λ,
λ × (µ + ν) and (λ × µ)+ (λ × ν),
(λ + µ)+ ν and λ + (µ + ν),
λ + µ and µ + λ,
(λ × µ) × ν and λ × (µ × ν),
λ × µ and µ × λ
have the same normal forms,
0 and 1 are normal terms.
Proposition 2.3 The system R terminates.
Proof. Consider the following interpretation (compatible with AC)
|u + v| =2 + |u| + |v|
|λ.u| =1 + 2|u|
|0| =0 
Each time a term t rewrites to a term t' we have |t| > |t'|. Hence, the system terminates.	 
Proposition 2.4 For any scalar rewrite system S, the system R ∪ S termi- nates.
Proof. By definition of the function | |, if a term t S-reduces to a term t' then |t| = |t'|. Consider a (S ∪ R)-reduction sequence. At each R-reduction step, the measure of the term strictly decreases and at each S-reduction step it remains the same. Thus there are only a finite number of R-reduction steps in the sequence and, as S terminates, the sequence is finite.	 


Definition 2.5 (The rewrite system S0) The system S0 is formed by the rules
0+ λ −→ λ
0 × λ −→ 0
1 × λ −→ λ
λ × (µ + ν) −→ (λ × µ)+ (λ × ν) where + and × are AC symbols.
Proposition 2.6 The rewrite system R ∪ S0 is confluent.
Proof. As the system is terminating it is sufficient to prove the all critical pair close. This can be mechanically checked, for instance using the system CIME 1 .	 
Definition 2.7 (Subsumption) A terminating and confluent relation S sub- sumes a relation S0 if whenever t S0 u, t and u have the same S-normal form.
Definition 2.8 (Commutation) The relation R commutes with the relation R', if whenever t R u1 and t R' u2, there exists a term w such that u1 R' w and u2 R w.
Proposition 2.9 Let R, S and S0 be three relations deﬁned on a set such that S is terminating and confluent, R ∪ S0 is confluent, S subsumes S0, and the the relation R commutes with the reflexive-transitive closure S∗ of S. Then the relation R ∪ S is confluent.
Proof. We write t↓ for the S-normal form of t. We define the relation S↓ by t S↓ u if u is the S-normal form of t and the relation R; S↓ by t (R; S↓) u if there exists a term v such that t R v S↓ u.
First notice that, if t R u then t↓ (R; S↓) u↓. Thus if t (R ∪ S)∗ u then
t↓ (R; S↓)∗ u↓ and if t (R ∪ S0)∗ u then t↓ (R; S↓)∗ u↓.
We then check that R; S↓ is locally confluent. If t (R; S↓) v1 and t (R; S↓) v2 then there exist terms u1 and u2 such that t R u1 S↓ v1 and t R u2 S↓ v2. Thus, by confluence, of R ∪ S0 there exists a term w such that u1 (R ∪ S0)∗ w and u2 (R ∪ S0)∗ w. Thus u1↓ (R; S↓)∗ w↓ and u2↓ (R; S↓)∗ w↓ i.e. v1 (R; S↓)∗ w↓ and v2 (R; S↓)∗ w↓.
As the relation R; S↓ is locally confluent and terminating, it is confluent.
Finally, if we have t (R∪S)∗ u1 and t (R∪S)∗ u2 then we have t↓ (R; S↓)∗ u1↓ and t↓ (R; S↓)∗ u2↓. Thus, there exists a term w such that u1↓ (R; S↓)∗ w and and u2↓ (R; S↓)∗ w. Thus u1 (R ∪ S)∗ w and u2 (R ∪ S)∗ w.	 

1 http://cime.lri.fr/


Proposition 2.10 Let S be a scalar rewrite system. The rewrite system R∪S is confluent on terms containing variables of sort E but no variables of sort K.
Proof. We use Proposition 2.9 on the set of semi-open terms, i.e. terms with variables of sort E but no variables of sort K. As S is ground confluent and terminating it is confluent and terminating on semi-open terms, S subsumes S0 because S is a scalar rewrite system and R commutes with S∗ because 0 and 1 are normal terms.	 
Remark 2.11 Confluence on semi-open terms implies ground confluence in any extension of the language with constants for vectors, typically base vectors.
Proposition 2.12 Let t be a normal term whose variables are among x1, ..., xn. The term t is 0 or a term of the form λ1.xi1 + ... + λk.xik + xik+1 + ... + xik+l where the indices i1, ..., ik+l are distinct and λ1, ..., λk are neither 0 nor 1.
Proof. The term t is a sum u1 + ... + un of normal terms that are not sums (we take n =1 if t is not a sum).
A normal term that is not a sum is either 0, a variable, or a term of the form λ.v. In this case, λ is neither 0 nor 1 and v is neither 0, nor a sum of two vectors nor a product of a scalar by a vector, thus it is a variable.
As the term t is normal, if n > 1 then none of the ui is 0. Hence, the term
t is either 0 or a term of the form
λ1.xi1 + ... + λk.xik + xik+1 + ... + xik+l
where λ1, ..., λk are neither 0 nor 1. As the term t is normal, the indices
i1, ..., ik+l are distinct.	 

Vectorial spaces
With respect to the notion of model, algorithms play the same role as sets of axioms: an algorithm may or may not be valid in a model, exactly like a set of axioms may or may not be valid in a model.
The notion of validity may be used to study sets of axioms, typically building a model is a way to prove that some proposition is not provable from a set of axioms. But validity can also be used in the other direction: to define classes of algebras as classes of models of some theories. For instance, given a field K = ⟨K, +, ×, 0, 1⟩ the class of K-vectorial spaces can be defined as follows.
Definition 2.13 (Vectorial space) The algebra ⟨E, +, ., 0⟩ is a K-vectorial


space if and only if the algebra ⟨K, +, ×, 0, 1, E, +, ., 0⟩ is a model of the 2- sorted set of axioms
∀u∀v∀w ((u + v)+ w = u + (v + w))
∀u∀v (u + v = v + u)
∀u (u + 0 = u)
∀u ∃u' (u + u' = 0)
∀u (1.u = u)
∀λ∀µ∀u (λ.(µ.u)= (λ.µ).u)
∀λ∀µ∀u ((λ + µ).u = λ.u + µ.u)
∀λ∀u∀v (λ.(u + v)= λ.u + λ.v)
We now prove that, the class of K-vectorial spaces can be defined as the class of models of the rewrite system R.
Proposition 2.14 Let K = ⟨K, +, ×, 0, 1⟩ be a ﬁeld. The algebra ⟨E, +, ., 0⟩ is a K-vectorial space if and only if the algebra ⟨K, +, ×, 0, 1, E, +, ., 0⟩ is a model of the rewrite system R.
Proof. We first check that all the rules of R are valid in all vectorial spaces,
i.e. that the propositions
(u + v)+ w = u + (v + w)
u + v = v + u u + 0 = u
0.u = 0
1.u = u
λ.0 = 0
λ.(µ.u)= (λ.µ).u
λ.u + µ.u = (λ + µ).u
λ.u + u = (λ + 1).u u + u = (1 + 1).u
λ.(u + v)= λ.u + λ.v
are theorems of the theory of vectorial spaces.
Seven of them are axioms of the theory of vectorial spaces, the propositions λ.u + u = (λ + 1).u and u + u = (1 + 1).u are consequence of 1.u = u and λ.u+ µ.u = (λ + µ).u. Let us prove that 0.u = 0. Let u' be such that u+u' =


0. Then 0.u = 0.u+ 0 = 0.u+u+u' = 0.u+ 1.u+u' = 1.u+u' = u+u' = 0. Finally λ.0 = 0 is a consequence of 0.u = 0 and λ.(µ.u)= (λ.µ).u.
Conversely, we prove that all axioms of vectorial spaces are valid in all models of R. The validity of each of them is a consequence of the validity of a rewrite rule, except ∀u∃u' (u+u' = 0) that is a consequence of u+(−1).u = 0 itself being a consequence of λ.u + µ.u = (λ + µ).u and 0.u = 0.	 

Universality
Proposition 2.15 Let t and u be two terms whose variables are among x1, ..., xn. The following propositions are equivalent:
the normal forms of t and u are identical modulo AC,
the equation t = u is valid in all K-vectorial spaces,
and the denotation of t and u in Kn for the assignment φ = e1/x1, ..., en/xn, where e1, ..., en is the canonical base of Kn, are identical.
Proof. Proposition (i) implies proposition (ii) and proposition (ii) implies proposition (iii). Let us prove that proposition (iii) implies proposition (i).
Let t be a normal term whose variables are among x1, ..., xn. The decom- position of t along x1, ..., xn is the sequence α1, ..., αn such that if there is a subterm of the form λ.xi in t, then αi = λ, if there is a subterm of the form xi in t, then αi = 1, and αi =0 otherwise.
Assume t)φ = u)φ. Let e1, ..., en be the canonical base of Kn and φ = e1/x1, ..., en/xn. Call α1, ..., αn the coordinates of t)φ in e1, ..., en. Then the decompositions of the normal forms of t and u are both α1, ..., αn and thus they are identical modulo AC.	 

Bilinearity
An algorithm
Definition 3.1 (The rewrite system R') Consider a language with four sorts: K for scalars and E, F , and G for the vectors of three vector spaces, the symbols +, ×, 0, 1 for scalars, three copies of the symbols +, . and 0 for each sort E, F , and G and a symbol ⊗ of rank ⟨E, F, G⟩.
The system R' is the rewrite system formed by three copies of the rules of the system R and the rules
(u + v) ⊗ w −→ (u ⊗ w)+ (v ⊗ w) (λ.u) ⊗ v −→ λ.(u ⊗ v)

u ⊗ (v + w) −→ (u ⊗ v)+ (u ⊗ w)
u ⊗ (λ.v) −→ λ.(u ⊗ v)
0 ⊗ u −→ 0 u ⊗ 0 −→ 0
Proposition 3.2 The rewrite system R' terminates.
Proof. We extend the interpretation of Definition 2.3 with
|u ⊗ v| = (3|u| + 2)(3|v| + 2)

Proposition 3.3 For any scalar rewrite system S, the system R' ∪ S termi- nates.
Proof. As in Proposition 2.4.	 
Proposition 3.4 The rewrite system R' ∪ S0 is confluent.
Proof. As in the proof of Proposition 2.6, we prove local confluence by check- ing that all critical pair close.	 
Proposition 3.5 Let S be a scalar rewrite system. The rewrite system R' ∪ S is confluent on terms containing variables of sort E, F, and G but no variables of sort K.
Proof. Using Proposition 2.9.	 
Proposition 3.6 Let t be a normal term whose variables of sort E are among x1, ..., xn, whose variables of sort F are among y1, ..., yp, and that has no variables of sort G and K. If t has sort E or F, then it has the same form as in Proposition 2.12. If it has sort G, then it has the form

λ1.(xi1 ⊗ yj1 )+ ... + λk.(xik ⊗ yjk )+ (xik+1 ⊗ yjk+1 )+ ... + (xik+l ⊗ yjk+l )
where the pairs of indices ⟨i1, j1⟩, ..., ⟨ik+l, jk+l⟩ are distinct and λ1, ..., λk are neither 0 nor 1.
Proof. The term t is a sum u1 + ... + un of normal terms that are not sums (we take n =1 if t is not a sum).
A normal term that is not a sum is either 0, a term of the form v ⊗ w, or of the form λ.v. In this case, λ is neither 0 nor 1 and v is neither 0, nor a sum of two vectors nor a product of a scalar by a vector, thus it is of the form v ⊗ w.


In a term of the form v ⊗ w, neither v nor w is a sum, a product of a scalar by a vector or 0. Thus both v and w are variables.
As the term t is normal, if n > 1 then none of the ui is 0. Hence, the term t is either 0 or a term of the form λ1.(xi1 ⊗ yj1 )+ ... + λk.(xik ⊗ yjk )+ (xik+1 ⊗ yjk+1 )+ ... + (xik+l ⊗ yjk+l ) where λ1, ..., λk are neither 0 nor 1. As the term t is normal, the pairs of indices are distinct.	 

Bilinearity
Definition 3.7 (Bilinear function) Let E, F , and G be three vectorial spaces on the same field. A function ⊗ from E × F to G is said to be bilinear if
(u + v) ⊗ w = (u ⊗ w)+ (v ⊗ w)
(λ.u) ⊗ v = λ.(u ⊗ v)
u ⊗ (v + w)= (u ⊗ v)+ (u ⊗ w)
u ⊗ (λ.v)= λ.(u ⊗ v)
Proposition 3.8 Let K = ⟨K, +, ×, 0, 1⟩ be a ﬁeld. The structures ⟨E, +, ., 0⟩,
⟨F, +, ., 0⟩, ⟨G, +, ., 0⟩ are K-vectorial spaces and ⊗ is a bilinear function from E × F to G if and only if ⟨K, +, ×, 0, 1, E, +, ., 0, F, +, ., 0, G, +, ., 0, ⊗⟩ is a model of the system R'.
Proof. The validity of the rules of the three copies of the system R, express that ⟨E, +, ., 0⟩, ⟨F, +, ., 0⟩, ⟨G, +, ., 0⟩ are K-vectorial spaces. The validity of the six other rules is the validity of the axioms of Definition 3.7 plus the two extra propositions 0 ⊗ u = 0 and u ⊗ 0 = 0 that are consequences of these axioms.	 

Universality
Definition 3.9 (Tensorial product) Let E and F be two vectorial spaces, the pair formed by the vectorial space G and the bilinear function from E × F to G is a tensorial product of E and F if for all bases (ei)i∈I of E and (e'j)j∈J of F the family (ei ⊗ e'j)⟨i,j⟩ is a base of G.
Example 3.10 Let ⊗ be the unique bilinear function such that ei ⊗ e'j = e''p(i−1)+j where e1, ..., en is the canonical base of Kn, e'1, ..., e'p that of of Kp, and e''1, ..., e''np that of Knp. Then Knp together with ⊗ is the tensorial product of Kn and Kp.


Proposition 3.11 Let t and u be two terms whose variables of sort E are among x1, ..., xn, whose variables of sort F are among y1, ..., yp, and that have no variables of sort G and K. The following propositions are equivalent:
the normal forms of t and u are identical modulo AC,
the equation t = u is valid in all structures formed by three vectorial spaces and a bilinear function,
the equation t = u is valid in all structures formed by two vectorial spaces and their tensorial product,
and the denotation of t and u in Knp for the assignment
φ = e1/x1, ..., en/xn, e'1/y1, ..., e'p/yp
where e1, ..., en is the canonical base of Kn, e'1, ..., e'p that of Kp and
⊗ is the unique bilinear function such that ei ⊗ e'j = e''p(i−1)+j where
e''1, ..., e''np is the canonical base of Knp.
Proof. Proposition (i) implies proposition (ii), proposition (ii) implies propo- sition (iii) and proposition (iii) implies proposition (iv). Let us prove that proposition (iv) implies proposition (i).
Let t be a normal term of sort G with variables of sort E among x1, ..., xn, variables of sort F among y1, ..., yp, and no variables of sort G and K. The decomposition of t along x1, ..., xn, y1, ..., yp, is the sequence α1, ..., αnp such that if there is a subterm of the form λ.(xi ⊗ yj) in t, then αp(i−1)+j = λ, if there is a subterm of the form xi ⊗yj in t, then αp(i−1)+j = 1, and αp(i−1)+j =0 otherwise.
Assume t)φ = u)φ. Call α1, ..., αnp the coordinates of t)φ in e''1, ..., e''np. Then the decompositions of the normal forms of t and u are both α1, ..., αnp and thus they are identical modulo AC.	 

Conclusion
We usually define an algebra by three components: a set, some operations defined on this set and some propositions that must be valid in the algebra. For instance a K-vectorial space is defined by a set E, the operations 0, + and . and the equations of Definition 2.13.
We can, in a more computation-oriented way, define an algebra by a set, operations on this set and an algorithm on terms constructed upon these operations that must be valid in the algebra. For instance a K-vectorial space is defined by a set E, the operations 0, + and . and the algorithm R.
This algorithm is a well-known algorithm in linear algebra: it is the al-


gorithm that transforms any linear expression into a linear combination of the unknowns. This algorithm is, at a first look, only one among the many algorithms used in linear algebra, but it completely defines the notion of vec- torial space: a vectorial space is any algebra where this algorithm is valid, it is any algebra where linear expressions can be transformed this way into linear combinations of the unknowns.

Acknowledgements
The authors want to thank Evelyne Contejean, Claude Kirchner and Claude March´e for comments on a previous draft of this paper.

References
P. Arrighi and G. Dowek, Operational semantics for formal tensorial calculus, 2nd International Workshop on Quantum Programming Languages, Helsinki, 2004.
N. Dershowitz and J.-P. Jouannaud, Rewrite systems, Handbook of theoretical computer science (vol. B): formal models and semantics, MIT Press, 1991.
G.E. Peterson and M.E. Stickel, Complete sets of reductions for some equational theories, Journal of the ACM, 28, 2, p.233-264, 1981.
