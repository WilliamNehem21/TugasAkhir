

Electronic Notes in Theoretical Computer Science 251 (2009) 65–81
www.elsevier.com/locate/entcs
A Practical Approach to Courcelle’s Theorem 1
Joachim Kneis2 Alexander Langer3
Dept. of Computer Science RWTH Aachen University Germany

Abstract
In 1990, Courcelle showed that every problem definable in Monadic Second-Order Logic (MSO) can be solved in linear time on graphs with bounded treewidth. This powerful and important theorem is amongst others the foundation for several fixed parameter tractability results. The standard proof of Courcelle’s Theorem is to construct a finite bottom-up tree automaton that recognizes a tree decomposition of the graph. However, the size of the automaton, which is usually hidden as a constant in the Landau-notation, can become extremely large and cannot be bounded by any elemental function unless P = NP (Frick and
Grohe, 2004). This makes the problem hard to tackle in practice, because it is just impossible to construct the tree automata.
Aiming for a practical implementation, we give a proof of Courcelle’s Theorem restricted to Extended MSO formulas of the form opt U ⊆ V ϕ(U ), where ϕ is a first-order formula with vocabulary (adj,U ) and
opt ∈ {min, max}. Note that many optimization problems such as Minimum Vertex Cover, Minimum Dominating Set, and Maximum Independent Set can be expressed by such formulas. The proof uses a new technique based on using Hintikka game properties in dynamic programming. To demonstrate the usability of this approach, we present an implementation that solves such formulas on graphs with small pathwidth. It turns out that the large constants can be circumvented on graphs that are not too complex.
Keywords: Exact Algorithms, Parameterized Algorithms, Treewidth, Model-Checking, Monadic Second-Order Logic, Courcelle’s Theorem

Introduction
There is a large number of NP-hard problems in graph theory, for which exact solu- tions can be computed efficiently on trees. For example, it is long-known [4,12,30,31] that all problems definable in Monadic Second-Order Logic (MSO) can be solved in linear time on the class of trees. MSO is an extension of First-Order Logic (FO), which allows quantification not only over objects, but also over sets of objects, as in, e.g., ∃D ϕ(D), where ϕ(D) is an MSO-formula with free set variable D. The classic approach for MSO model checking on trees is to construct a deterministic bottom-up tree automaton that in linear time recognizes the language defined by

1 Supported by the DFG under grant RO 927/8
2 Email: kneis@cs.rwth-aachen.de
3 Email: langer@cs.rwth-aachen.de

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.08.028

the formula. For finite structures (such as graphs), there are a couple of optimized implementations available, for example the MONA tool [22] developed at the Uni- versity of Aarhus.
Many hard problems can even be solved efficiently on graphs that might not be trees, but are—in some sense—still sufficiently treelike. A formal parameter that is widely accepted to measure this likeliness is the treewidth of a graph. For example, trees and forests have treewidth 1, but the complete graph on n nodes has treewidth n − 1. Interweaved with the definition of treewidth is the one of a tree decomposition of a graph G. Such a tree decomposition is basically a tree T annotated with graph separators of G such that certain properties hold. Treewidth
and tree decompositions were introduced by Robertson and Seymour in a series of papers on graph minors [27,28,29], but turned out to be very useful in other areas as well, for example for solving hard problems on graphs. The reasons is, that one can often use the tree structure of the tree decomposition to solve the problem on G. Since the aforementioned graph separators have size bounded by the treewidth plus one, this approach can lead to algorithms with a run time polynomially bounded in |G| if G has bounded treewidth. This is one of the reasons why treewidth has found many applications in parameterized complexity theory.
Parameterized complexity theory is an approach to explore whether hard prob- lems can be solved exactly with a run time that comes close to polynomial time on “well-behaved” instances. For example, one could argue that graphs with low treewidth are “well-behaved” for a problem, if the problem is efficiently solvable on treelike graphs. Formally, a parameterized problem L is a set of pairs (I, k) where I is an instance and k the parameter. A parameterized problem L is called ﬁxed parameter tractable and belongs to the complexity class FPT if there is an algo- rithm that decides membership of L in time f (k)poly(|I|), where f is an arbitrary function. If the parameter is small, such an algorithm can be quite efficient in spite of the NP-hardness of the problem—in particular if f is a moderately exponential function. For more information on parameterized complexity, we refer the reader to introductionary texts such as [9,15,26].
In 1990, Courcelle [6] showed that each problem definable in Counting MSO, an extension of MSO with additional predicates evaluating the size of sets, can be solved in linear time on graphs with bounded treewidth. In other words, every such problem is in FPT when parameterized in the graph’s treewidth. This result was generalized by Arnborg, Lagergren, and Seese [1] to Extended MSO (EMSO), which furthermore introduces relational evaluation over the size of sets. Among others, one may for example take the minimum or the maximum size among all sets satisfying a formula and evaluate this integer further.
This general and strong result, commonly referred to as “Courcelle’s Theorem”, allows a broad application in the field of parameterized complexity theory, some- times even when the original parameterization is not the treewidth. For example, it is used in recent work on the parameterized complexity of the Crossing Number problem [19,21], for which no direct algorithm is known.
The standard proof of Courcelle’s Theorem is again the automata-theoretic ap-



Fig. 1. The classical automata-theoretic approach to Courcelle’s Theorem: Given a formula ϕ and a tree decomposition T of a graph G, one first computes a labeled binary tree T∗ and a formula ϕ∗, such that T∗ |= ϕ∗ iff G |= ϕ. Then, by the well-known methods for MSO model-checking on trees, a tree automaton A with L(A)= L(ϕ∗) is constructed that tests membership T∗ ∈ L(A) in linear time. Since ϕ∗ only depends on ϕ and the treewidth, the construction of A is independent of G, the input graph.

proach. Naturally, the details are a bit more complicated than in the construction of classical tree automata for MSO formulas, but the method in general (see Figure 1) is well-understood: Given a formula and a tree decomposition, the problem is first reduced to the MSO model checking problem on labeled binary trees. The well- known methods for MSO model-checking on trees involving a deterministic tree automaton that recognizes this labeled binary tree then yield the FPT run time bounds, since the automaton only depends on ϕ and the treewidth, and the actual recognition of the tree decomposition can be done in linear time. In particular, the construction of A is independent of G, the input graph. There are a couple of other proofs of Courcelle’s Theorem known (see, e.g., [6,5,1,8,9,7,17,24]). The automata- theoretic approach, however, is the most common and has been investigated to a large extent, in particular with respect to upper and lower bounds of the constants hidden in the Landau-notation [17,14,32].
Even if the algorithm asymptotically only requires linear time in the number of nodes, the size of these hidden constants can not be neglected in practical ap- plications. Unfortunately, they can become extremely huge [18] (see also [25,23]): Unless P = NP, there is no elementary function f , such that these constants can be bounded by f (|Φ|, w), where |Φ| depends on the formula Φ defining the problem and w is the treewidth of the graph. Hence, it is not surprising that the only known upper bounds are extremely large. To obtain some real numbers, we can use the quite precise estimations Weyer [32, pp. 213ff] found: It turns out that even for for rather simple Σt-FO formulas (MSO adds an additional exponential) with only four quantifiers the upper bound he obtains is as large as
2(w+4)|Φ|
22	.

It is easy to see that even for constant treewidth w = 1 (i.e., trees and forests) automata of that size can not be constructed in practice. At the same time, the lower bound [18,32] of
22o(|Φ|)
22
for FO and w = 1 indicate that this upper bound is already quite good, at least if FTP /= W[1] holds, which is widely believed. Therefore, even restrictive MSO formulas like
∃D ∀x1∃x2∀x3 ϕ(D, x1, x2, x3),	ϕ quantifier-free,	(1) can cause heavy blow-up in automata size.

The automata-theoretic approaches usually suffer from a bottleneck in a similar way, even if an automaton is not constructed explicitly. Roughly speaking, all the information that is required to a allow linear run time in the second phase—the recognition or dynamic programming—is computed in a constant time first phase, let it be the construction of the automaton, or the computation of decision rules or look-up-tables for the dynamic programming. This first step usually depends on the formula and the treewidth only. For example, the automaton constructed (cf., Figure 1) is the same for all graphs bounded by that treewidth. In other words, the automaton that is computed has to contain all the states it needs to keep track of all the different “possibilities” appearing in worst-case instances— and hence is (non-elementary) large even if the graph that is part of the actual input to the model-checking problem is simple. A similar bottleneck occurs in related approaches. For instance, Courcelle and Mosbah [8] use direct dynamic programming on the tree decomposition. The dynamic programming step uses Boolean connectives as decision rules, which are obtained from a variant (see [6]) of the Feferman-Vaught-Theorem [13]. The Feferman-Vaught-Theorem is also used by Makowsky [24] to compute a large look-up-table for dynamic programming. Finally, Frick’s approach [17] is to compute the set of all MSO types for the formula, which can again be done with the help of the Feferman-Vaught-Theorem [20]. Since, however, the constructive proof of this theorem resembles the construction of the tree automaton, it is not surprising that one experiences a similar explosion [23].
Several techniques have been developed to address this problem where possible, with mixed results (see, e.g., [2,22]). Since formulas occurring in practice are often comparably simple and do not cause this explosion, the corresponding automata typically remain much smaller. On the other hand, we find that Courcelle’s Theorem is used whenever one is currently not able to give a better, direct algorithm for the problem at hand. This view is strengthened by a comment by Grohe [19] in

his aforementioned work on the
Crossing
Number
problem:  “This statement

involves a non-trivial quantifier alternation, which is what makes the translation to an algorithm difficult. At this point, I think that the route through logic and Courcelle’s theorem is essential for our proof.” It is not hard to see that quantifier alternations are the reason for the explosion in automata size. Hence, whenever we actually need Courcelle’s Theorem in practice because the formula is too complex to give direct algorithms, the corresponding automaton becomes large. This is unsatisfactory, because it should be perfectly possible to solve the problem, given as a formula only, on simple graphs, e.g., long paths, even if the automaton might be too large even with tricks.
We believe that the aforementioned problems are the reason why there is de facto no practical implementation of Courcelle’s Theorem available and hence none for, e.g., the Crossing Number problem. A fast algorithm would not only yield a fast implementation for this problem—important on its own—but also for any other result based on Courcelle’s Theorem.
Our goal was therefore to develop an alternative proof of Courcelle’s Theorem that is not subject to this bottleneck, which is independent of the graph at hand.

Instead, it should incorporate the knowledge on the whole input, i.e., take into account the graph that is part of the input, such that worst-case lower bounds remain those until both, the formula and the graph, are worst-case instances. To this end, we aimed for a more direct approach, i.e., it shall not use methods lend from the automata-theoretic background and directly work on the tree decomposition and the graph. In this paper, we cannot yet prove the full strength Courcelle’s Theorem: The restriction is that for now we only allow one set quantifier, and the respective set shall be minimized or maximized in size (such as in equation 1). This yields formulas of the the form
opt U ⊆V ϕ(U ),
where ϕ is a first-order formula with vocabulary (adj,U ) and opt ∈ {min, max}.

Note that still many common optimization problems such as Minimum
Vertex

Cover, Minimum Dominating Set, and Maximum Independent Set can be
expressed by such formulas, and that the non-elementary lower bounds also hold, since we can express all first-order properties.
The basic idea of our approach is to use dynamic programming on the tree decomposition, but in each step, we use Hintikka games (model checking games) to decide whether the formula still holds in the graph G. Model checking games are only the game-theoretic formalism that eases the proofs, but can nicely and straight-forwardly be translated to direct algorithms. Since an MSO-formula with quantifier-rank q cannot distinguish subgraphs of G iff the duplicator has a winning strategy in the Ehrenfeucht-Fra¨ıss´e-game with q rounds, we only use equivalency classes of subgraphs for the model checking game. If the graph is rather “simple”, which in this context does not necessarily mean “small”, there are only few ways to play the Ehrenfeucht-Fra¨ıss´e-game in q rounds, and hence few equivalency classes and the tables remain small. This way, we take into account the actual graph that is part of the input.
Of course, our approach is subject to the non-elementary worst-case lower bounds mentioned above as well, because these do already hold for FO. However, if we are stuck with a bad formula that yields a very huge automaton, we might still be able to solve the problem on a wide variety of graphs occurring in practice.
For a proof of concept and in order to show feasibility, we developed a C++ program based on our approach. At the time of this writing, it is already able to solve problems defined by a formula with few quantifiers on graphs with small pathwidth, and indeed the space requirements are much smaller than what we could expect from the current known bounds.

Preliminaries
We start with the notation used in this paper and the introduction of the essential concepts underlying our approach. The power set of a set U is denoted by 2U . For graphs G = (V, E) and U ⊆ V , the induced subgraph of U is denoted by G[U ] and the set of nodes of G is denoted by V (G).
A tree decomposition (T, X) for a graph G = (V, E) is a rooted tree T = (I, F ),

and a function X : I → 2V , such that:
For each node v ∈ V there is an i ∈ I with v ∈ X(i).
For each edge {u, v}∈ E there is an i ∈ I with {u, v}⊂ X(i).
For each node v ∈ V , the subtree of T induced by { i ∈ I	| v ∈ X(i) } is connected.
The sets X(i) are called bags. The width of a tree decomposition is the size of its largest bag minus one and the treewidth of G is the smallest width over all tree decompositions of G. Without loss of generality, we assume that all tree decompo- sitions used throughout this paper are nice, i.e.,
each i ∈ I has at most two children,
if i ∈ I has exactly one child j ∈ I, then X(i) and X(j) differ by exactly one node v ∈ V , and
if i ∈ I has two children l, r ∈ I, then X(i) = X(l) = X(r).
Nodes of T having two children are called join nodes, while nodes i with exactly one child j are called forget (resp. introduce) nodes, if X(i) ⊂ X(j) (X(j) ⊂ X(i)). A terminal graph is a labeled graph (V, E, X) with terminals X. Two terminal subgraphs T1 and T2 with the same set of terminals X and T1[X] = T2[X] can effectively be “glued” on X, denoted by T1 ⊕ T2, by identifying the nodes in X.
This yields a new terminal subgraph. A notable property of tree decompositions exploited by most algorithms using treewidth—including our own—is the fact that each bag X(i) is a graph separator of G. Hence with each bag X(i) we can associate two (forget, introduce) or three (join) well-defined terminal subgraphs with terminal set X(i). For further information on treewidth and tree decompositions, we refer the reader to Bodlaender’s guide to treewidth [3].
The model-checking problem for a logic on a domain of structures is to decide whether a given structure is a model for a formula in this logic. In this paper, we consider the domain of graphs and formulas over vocabulary {adj} in (Extended) Monadic Second-Order ((E)MSO) logic. MSO extends First-Order (FO) logic by universal and existential quantification over sets, and EMSO furthermore allows to evaluate the size of these sets (see [1]). We shall use lower case letters for first- order variables and upper case letters for monadic second-order (set) variables. Throughout this work, we only use the EMSO extension to express optimization problems and restrict ourselves to EMSO formulas of the form opt U ϕ(U ), where opt ∈ {min, max}, and ϕ contains exactly the free set variable U , but no further set quantification (first-order quantifiers are still allowed). In other words, ϕ is an FO- formula with vocabulary (adj,U ). In slight abuse of the model-theoretic formalism, the semantics is that the formula shall “return” the size of an optimal set U on which ϕ(U ) holds. Furthermore, we wlog assume ϕ is in negation normal form, i.e., negations only occur on atomic expressions. The nesting depth of quantifiers in a formula Φ is called the quantifier rank qr(ϕ).
We only briefly introduce the game-theoretic foundations used in this paper, for more information see, e.g. [10]. Firstly, it is a well-known fact that the model

checking problem for relational MSO and FO can be expressed as a winning strat- egy problem in finite Hintikka (model checking) games: To any structure A with universe A, any formula Φ(x) of the same vocabulary in negation normal form, and any assignment a to the free variables x of Φ, we associate a model checking game MCG(A, Φ(a)). There are two players, the veriﬁer and falsiﬁer. The former tries to prove that A |= Φ(a), while the latter wants to show the opposite. The game is positional with positions (ϕ, b), where ϕ is a subformula of Φ and b is an assignment to the free variables of ϕ. If the current position is (∃uϕ, b) or (∃Uϕ, b), the verifier has to choose u ∈ A or U ⊆ A, and the game continues at position (ϕ, b'), where b' is obtained from b by assigning u or U according to his choice. At position (ψ1 ∨ψ2, b), the verifier has to choose ψ ∈ {ψ1, ψ2} and the game continues in (ψ, b). Similarly, the falsifier moves at universal quantification or conjunctions. The game stops on positions (ϕ, b) if ϕ is an atom or a negated atom. The verifier has won iff A |= ϕ(b). Then A |= ϕ(a) iff the verifier has a winning strategy for MCG(A, Φ(a)) starting in (Φ, a). We call two positions (ϕ, b1) and (ϕ, b2) equiv- alent, if A |= ϕ(b1) ⇔ A |= ϕ(b2). If A is finite, it is easy to see that a simple recursive algorithm can be used to decide A |= ϕ(a) by exhaustively simulating MCG(A, Φ(a)).
Secondly, Ehrenfeucht-Fra¨ıss´e-games show that the quantifier rank bounds the ability of an MSO-formula to distinguish structures: Let A and B be structures over the same relational vocabulary τ . We write A ≡q B iff A |= Φ ⇔ B |= Φ for every MSO-formula Φ over τ with qr(Φ) ≤ q. The Ehrenfeucht-Fra¨ıss´e-game is played in up to q ∈ N rounds. In each round, the spoiler has to choose new elements or sets from A or B. Next, the duplicator has to answer with previously not chosen elements or sets from the opposite structure, such that the selected elements and sets a in A and b in B form a partial isomorphism between (A, a) and (B, b). If one of the players cannot move, he lost the game. The duplicator wins the overall game if it is always possible to find a partial isomorphism. Then A ≡q B if and only if the duplicator has a winning strategy for the Ehrenfeucht-Fra¨ıss´e-game on A and B with q rounds [16,11]. Note that if we understand the sets that have been chosen as labels, each such partial isomorphism corresponds to induced, labeled subgraphs of A and B. We furthermore point out the relation between model-checking and Ehrenfeucht-Fra¨ıss´e-games: The elements and sets chosen in either structure in the latter game can be used for assignments to the free variables of Φ in the former.
Finally, the non-elementary function tow(u, v) : N × N → N is defined as:



tow(

u, v
) :=	2v·tow(u−1,v)	u > 0
1	u = 0 

Proving a Restricted Version of Courcelle’s Theorem
From now on, we fix a graph G = (V, E) with (wlog) V ∩ N = ∅, a nice tree decomposition (T, X) of G of width w, and an EMSO formula
opt U Φ(U, x1) := opt U ∀x1ϕ(U, x1),

where opt ∈ {min, max} and Φ is an FO-formula over vocabulary {adj,U} with quantifier rank t := qr(Φ) = qr(ϕ)+ 1.
A typical framework for solving problems with the help of the tree decompo- sition can be sketched as follows: For every bag X(i), one first stores in a table Si all local solutions. Then, by dynamic programming starting in the leaves of the tree decomposition, local solutions are extended to optimal global solutions where possible. We use this framework to find an optimal global solution U ⊆ V , i.e., a maximum or minimum set U ⊆ V with G |= Φ(U ). We call U ⊆ X(i) a local solution for a node i of the tree decomposition iff for all x1 ∈ X(i), the verifier has a winning strategy from position (ϕ, (x1)) in the game MCG(G, Φ(U )). It is now easy to see that G |= Φ(U ) if and only if U is a local solution for every node of the tree decomposition. Traversing the latter bottom-up from the leaves to the root, we compute the (size of) optimal sets that are local solutions for all nodes seen so far. In the root, only global solutions remain.
However, we have to avoid enumerating all possible sets U ⊆ V for each node of the tree decomposition, since otherwise we could also solve the initial problem within the same time. To this end, we use the observation that Φ cannot distinguish two sets U1, U2 ⊆ V with (V, E, U1) ≡t (V, E, U2). For example, consider a formula
min U ∀x1∀x2ψ(U, x1, x2)
with qr(ψ) = 0 and assume the model-checking game is in position (ψ, (U, x1)) for some U ⊆ V and x1 ∈ X(i). Now the falsifier has |V | possibilities to choose x2 ∈ V , but only up to five ways to choose x2 ∈ V so that the new positions are pairwise inequivalent: Either choose x2 = x1, or any combination of whether x2 is adjacent to x1 and of whether x2 ∈ U —these are the only five cases that influence atomic formulas. This coincides with the “effective” number of ways the Ehrenfeucht- Fra¨ıss´e-game can be played on (V, E, U ) (plus one): Again, the partial isomorphism in the finite round is already determined by whether x1 and x2 are adjacent and if x2 is in U . This argument easily carries over to formulas with larger quantifier ranks (even though each quantifier introduces a further exponential into the upper bound). The idea is now that for every set U ⊆ V we only use a representation of the equivalence class of (V, E, U ) under the Ehrenfeucht-Fra¨ıss´e-game, which can be enumerated faster. Then, given the set of all equivalence classes, we can decide whether members of each class are local solutions for X(i) within FPT run time bounds, and in the dynamic programming, we only save the size of optimal solutions in every equivalence class.
The representation that we use here is a rooted tree that describes how the Ehrenfeucht-Fra¨ıss´e-game can be played “locally” on a terminal subgraph T of G: Since the sets shall be local solutions (defined in terms of model-checking games), we also restrict the first round of the Ehrenfeucht-Fra¨ıss´e-game to the terminals, but at the same time leave open which which x ∈ X(i) has been explicitly chosen in the first round. We call these Ehrenfeucht-Fra¨ıss´e-games local. Then each node of the tree representation corresponds to a round in the local Ehrenfeucht-Fra¨ıss´e- game, where the root represents the (open) choice of some x ∈ X(i), and each other


	
Fig. 2. The Ehrenfeucht-Fra¨ıss´e-game representation EFG3(T, U ) for the terminal graph T on the left with terminals X = {A, B} and U = {C} (shown as a square node): we restrict the games such that in the first round the players always have to choose any x ∈ X (root of the tree). In the next round, the players effectively only have two choices to pick the first non-terminal (labeled 1): Either pick the non-terminal C, which yields the left subgame, or choose either of {D, E} for the right subgame: The nodes D and E always yield the same induced labeled subgraphs (up to isomorphism) in the following round, where the second non-terminal is chosen (labeled 2), and hence effectively do not introduce new subgames.

node corresponds to the choice of a certain non-terminal. Each node is labeled with the partial isomorphism that is obtained in that round or, more precisely, with the current induced labeled subgraph (see Figure 2 for an example).
Definition 3.1 Let X be a bag, T be a terminal subgraph of G, U ⊆ V (T ), and for each k ≥ 0 let (v1,..., vk) ∈ (V (T ) \ X)k, such that vi /= vj for each i /=
j. The partial isomorphism representation SUB(T, v1,..., vk,U ) of T , (v1,..., vk) and U is obtained from the labeled (terminal) subgraph (T [X ∪ {v1,..., vk}],U ∩ (X ∪ {v1,..., vk})) by identifying each non-terminal vj as the integer j (recall that V ∩ N = ∅).
For any terminal graph T , any set U ⊆ V (T ), each 0 ≤ k ≤ t − 1 and each
(v1,..., vk) ∈ (V (T ) \ X)k we recursively define labeled trees EFGv ···v  as follows.
The root of EFGv1···vk  is labeled with SUB(T, v1,..., vk,U ). Furthermore, if k < 
t − 1, for each
EFG ∈ {EFGv1···vkv | v ∈ V (T ) \ X ∧ v /= v1,..., vk}
there is a subtree EFG. The Ehrenfeucht-Fra¨ıss´e-game representation of T and U
is defined as EFGt(T, U ) := EFGє, where ϵ is the empty sequence.
If for some set U ⊆ V with U /⊆ V (T ), we may abbreviate EFGt(T, U ∩ V (T )) as EFGt(T, U ). It turns out (see the next lemma) that the number of different local Ehrenfeucht-Fra¨ıss´e-games is bounded from above in terms of w ≥ |X| − 1 (the treewidth) and quantifier rank only and particularly does not depend on the size of G (the input size). This is good for the FPT run time we want to achieve, but bad if we want to avoid the across-the-board explosion we mentioned in the introduction. Note however, that even though each quantifier introduces an exponential into the upper bound—which is to be expected due to the known lower bounds—the real number of local games obtained depends on the input (terminal) graph, as the example in Figure 2 shows.

Lemma 3.2 Let X be a bag (i.e., |X|− 1 ≤ w), and T be a terminal graph. The number of non-equivalent Ehrenfeucht-Fra¨ıss´e-game representations EFGt(T, U ), i.e., the size of
{ EFGt(T, U ) | U ⊆ V (T ) },
is bounded by O(2w2tow(t−1,w+t+2)) and the size of each representation is bounded by O(tow(t − 1,w + t + 2)).
Proof. We prove the upper bound by induction over the number of rounds in the local Ehrenfeucht-Fra¨ıss´e-game. Recall that we only consider those games where the first round was chosen in X, but we leave open, which x has been explicitly chosen. Hence, we consider all of these games using one representation. For any 0 ≤ k < t, we by nk denote the number (sub)games the players can play for arbitrary U ⊆ V (T ) (structure (T, U )), when
beginning in round k + 1 with previous choices (x, v1,..., vk),
for all x ∈ X (at the same time),
but with distinct v1,..., vk ∈ V (T ) \ X, vi /= vj.
If k = t − 1, the game is over and hence only the empty game can be played. If k < t − 1, the players have to move to some new v ∈ V (T ) (since we consider all x ∈ X at the same time), if possible. There are 2 · 2w+1 · 2k = 2w+k+2 possibilities for v, such that (x, v1,..., vk, v) yields a distinct induced labeled subgraph: Either choice of v ∈ U , an edge between v and any x ∈ X and to the previous k nodes, and any such v might be present in the current structure (T, U ) or not. By induction, we obtain an upper bound of 22w+k+2nk+1 , and with k < t, we obtain the second factor. The additional factor O(2w) is due to the at most 2w+1 ways to choose U ⊆ X.
The size bound for each fixed game is obtained analogously.	 
We now know, that each bag X splits the graph into two or three terminal subgraphs, and for each such terminal subgraph T and set U ⊂ V (T ) we found a way to represent the locally restricted Ehrenfeucht-Fra¨ıss´e-games on (T, U ). We now show that the opposite holds as well, i.e., when terminal graphs T1 and T2 are glued, we can construct the corresponding Ehrenfeucht-Fra¨ıss´e-game representation for T1 ⊕ T2 and any U1 ⊆ V (T1) and U2 ⊆ V (T2). This will be needed for join nodes in the dynamic programming as well as for finding local solutions (by the corresponding model-checking game).
Lemma 3.3 Let T1 and T2 be terminal graphs with the same set of terminals X and T1[X] = T2[X], and let U1 ⊆ V (T1) and U2 ⊆ V (T2) with U1 ∩ X = U2 ∩ X. Given E1 = EFGt(T1, U1) and E2 = EFGt(T2, U2), one can compute EFGt(T1⊕T2, U1∪U2) in time poly(|E1|, |E2)|).
Proof. Since no two nodes from V (T1) \ X and V (T2) \ X are adjacent, they will not be adjacent in T := T1 ⊕ T2 either. Hence, each round of the local Ehrenfeucht- Fra¨ıss´e-game on T1 ⊕T2 is already determined by the possible moves on (T1, U1) and (T2, U2): Assume the game is in round k + 1, i.e., (x, v1,..., vk) have already been chosen, where we again assume x is a placeholder for any terminal. If k < t− 1, the











Fig. 3. Forgetting a terminal in the Ehrenfeucht-Fra¨ıss´e-game representation: The original terminal set is
{A, B} (left), but A is forgotten and hence is no longer a terminal (right). Since we only study those games where the first round is restricted to terminals, A no longer occurs in the root. However, it can still be chosen in the next two rounds, which adds a couple of new moves to the game. The places where A, now a non-terminal, has been chosen are marked bold.

player now has to choose some v ∈ V (T ) \ (X ∪ {v1,..., vk}). However, since any such v originates in either T1 or T2, we can just enumerate all possible choices that are available in EFGt(T1, U1) or EFGt(T2, U2).
We omit the full algorithm since the actual construction is rather technical and boring. Instead, we only hint how a simple recursive algorithm can traverse E1 and E2. In some sense, the algorithm exhaustively simulates the Ehrenfeucht-Fra¨ıss´e- game and works as follows: There are an integer k ≤ t counting the current round, two pointers p1 and p2 that mark the current position in E1 and E2, respectively, and a pointer for position p in the to-be-constructed EFGt(T, U1 ∪U2): If k < t− 1, for every child c of p1 a corresponding child c' is added below p and the algorithm recursively continues at positions c, p2 and c' and with k' := k + 1. The same is done for all children of p2. When finished with p1 and p2, duplicates below p have to be eliminated.	 
As mentioned, this lemma can already be used in the dynamic programming to construct the possible game representations for join nodes. Of course, we also need to make sure that we can do so for introduce and forget nodes as well. For the former, this task is easily done.
Lemma 3.4 Let i be an introduce node of the tree decomposition and j its unique child. Let X(i) = X(j) ∪ {x} be the corresponding bags, and let Ti and Tj be the terminal graphs with terminal sets X(i) and X(j), respectively, such that Ti[X(i) \
{x}] = Tj. Then { EFGt(Ti,U ) | U ⊆ V (Ti) } can computed from { EFGt(Tj,U ) |
U ⊆ V (Tj) } in linear time.
Proof. The node x is the only new node in Tj and is a terminal. Since the Ehrenfeucht-Fra¨ıss´e-games are local, x will always be chosen in the first round. On the other hand, x is not adjacent to any node in V (Ti)\X(i) = V (Tj)\X(j). Hence, we only need to slightly modify the labels for each game-representation on Tj accord- ingly, which yields two representations corresponding to the cases x ∈ U ⊆ V (Tj) and x ∈/ U ⊆ V (Tj) for each EFG ∈ { EFGt(Tj,U ) | U ⊆ V (Tj) }. The algorithm is straight-forward.	 

Forget nodes require slightly more work: The “forgotten” node becomes a non- terminal, and thus in the local game we will never choose it in the first round. Instead, it can now be chosen in any subsequent round. This possibly adds new subtrees to the game representation whenever it has not been chosen in previous rounds (see Figure 3).
Lemma 3.5 Let i be a forget node of the tree decomposition and j its unique child. Let X(i) = X(j) \ {x} be the corresponding bags, and let Ti and Tj be the terminal graphs with terminal sets X(i) and X(j), respectively, such that Tj = Ti (seen as regular graphs). Then for any U ⊆ V (Ti), Ei := EFGt(Ti,U ) can computed from Ej := EFGt(Tj,U ) in time poly(|Ej|).
Proof. (Sketch.) Since V (Ti) = V (Tj) and the set U remains the same, it is easy to see that we only need to make sure that x is correctly used in the (representation of the) local Ehrenfeucht-Fra¨ıss´e-game.
We omit the technical and not very interesting algorithm, and again give imple- mentation hints only: As before, the algorithm in some sense exhaustively simulates the local Ehrenfeucht-Fra¨ıss´e-game on (Ti,U ) that we want to represent: There are two functions. The first one recursively traverses Ej top-down, and at each node of Ej first calls itself for all children. This first step corresponds to the case that a non-terminal not equal to x is chosen, which still allows x to be taken in subsequent rounds. In a second step, we add a subtree for the case that x is chosen. This subtree for x is obtained from the current subtree of Ej by a second function: The leaves might have to be cut off (only t rounds are played), and the labels have to be modified in a way such that x becomes a non-terminal chosen in the current round k, and all other non-terminals j > k must have their indices increased. Finally, the label for the root of the new tree is determined from the old tree by just delet- ing x, and duplicate subtrees, i.e., those that represent equivalent subgames, must be eliminated.	 
We can now sketch our main algorithm (depicted in Algorithm 1), and obtain our main result.
Theorem 3.6 Algorithm 1 returns an optimal solution U ⊆ V for Φ(U ) in time bounded by
O(2w24·tow(t−1,w+t+2) · |T |).

Proof. Wlog, let opt = max. For any node i, let Ti,p be the terminal graph in the past of i, i.e., the terminal graph that contains all nodes in bags below i, and let Ti,f be the future of i, i.e., the unique Ti,f , such that G = Ti,p ⊕ Ti,f .
By a straight-forward induction over the first bottom-up traversal, one first can show (omitted here) with the help of Lemmata 3.3, 3.4 and 3.5, that for each i, Pi contains an entry EFGt(Ti,p,U ) for all U ⊆ V (Ti,p). Similarly, the top-down traversal yields an entry EFGt(Ti,f ,U ) in Fi for all U ⊆ V (Ti,f ) and all i.
By an induction over the second bottom-up traversal of i, we shall now show that the algorithm computes the correct values. That is, if Si contains an entry

Algorithm 1 Input: A graph G = (V, E), a nice tree decomposition (T, I) of G of width w, an EMSO-formula opt U Φ(U ) = opt U ∀x1ϕ(U, x1) without set quantiﬁers in Φ and qr(Φ) = t.
Output: The size of an optimal set U with G |= Φ(U ).

For each i ∈ V (T ), create empty tables Pi and Fi (called past and future) that can hold a set of local Ehrenfeucht-Fra¨ıss´e-game representations together with a list of pointers to entries in Pj and Fj for each child j of i.
Traverse T bottom-up and update the past Pi accordingly: For leaves i, enu- merate all U ⊆ X(i) and insert EFGt(G[X(i)],U ) into Pi. For join, introduce and forget-nodes, use the algorithms of Lemmata 3.3, 3.4, and 3.5, respectively.
In the root r, enumerate all U ⊆ X(r) and insert EFGt(G[X(r)],U ) into Fi.
Traverse T top-down, and update the future Fi accordingly: introduce and forget use the respective opposite algorithm for their children; for join nodes i with two children l and r, Fl is “joined” from Fi and Pr; Fr analogue.
For each i ∈ V (T ), create a table Si that for pairs of game-representations holds values in N ∪ {fail}, where fail ∈ {+∞, −∞} (depending on opt ) is the default value.
Traverse T bottom-up and update each Si as follows: If i is a leaf, introduce, or join node, then for each Ep := EFGt(Tp, Up) ∈ Pi and Ef := EFGt(Tf , Uf ) ∈ Fi, use the model-checking game to test whether Up ∪ Uf is a local solution for Tp ⊕ Tf = G. If not, let Si[Ep, Ef ] := fail and continue. If yes, Si[Ep, Ef ] must be updated using entries in the previously computed tables (here, we use the pointers):
If i is a leaf node, just set Si[Ep, Ef ] := |Up ∩ X(i)|, which can be deducted from Ep.
If i is an introduce node with child j, let E' be the unique entry from which
Ep was obtained bottom-up, and let E' be the entry obtained by Ef top-
down, such that x ∈ U in E' iff x ∈ U in E' . Then let Si[Ep, Ef ] :=
Sj[E' , E' ]+ |{x}∩ U'|.
p	f
If i is a forget node with child j, let Si[Ep, Ef ] be the optimal value among
all entries Sj[E' , E' ], such that Ep was obtained from E' bottom up, and E'
p	f	p	f
is the unique entry that was obtained from from Ef top-down.
If otherwise i is a join node with children l and r, we iterate over all El,p := EFGt(Tl, Ul) ∈ Pl, all Er,p := EFGt(Tr, Ur) ∈ Pr and all Ef := EFGt(Tf , Uf ) ∈ Fi (where Ul, Ur and Uf are only implicit). Let Ep := EFGt(Tl ⊕ Tr, Ul ∪ Ur) (Lemma 3.3). We now again use the model-checking game to test whether Uf ∪Ul ∪Ur is a local solution for Tf ⊕Tl ⊕Tr = G. If not, let Si[Ep, Ef ] := fail and continue. Otherwise, we possibly update Si, i.e., we let
Si[Ep, Ef ] := opt {Si[Ep, Ef ], sl + sr − |Up ∩ X(i)|},
where sl = Sl[El,p, EFGt(Tf ⊕Tr, Uf ∪Ur)], sr = Sr[Er,p, EFGt(Tf ⊕Tl, Uf ∪Ul)], and |Up ∩ X(i)| can be deducted from Ep.

Si[Ep, Ef ] ∈ N, then Si[Ep, Ef ] is the optimal size |U ∩ V (Ti,p)| among all U ⊆ V
such that
Ep = EFGt(Ti,p,U ),
Ef = EFGt(Ti,f ,U ), and
U is a local solution on i and on all nodes j below i in the tree decomposition.
Otherwise, Si[Ep, Ef ] = fail iff there is no such set. This then yields the size of an optimal global solution in root table.
For leaves i, the claim is easily seen, because V (Ti,p) = X(i). For the induction step, we only prove the “join” case; the induction steps for introduce and forget nodes are deducted similarly. Hence, let i be a join node with children l and r, and by hypothesis assume the claim holds for Sl andSr. Furthermore, let U ⊆ V be such that U is optimal for the aforementioned properties. Since Fi, Pl and Pr are complete, they contain entries EFG(Ti,f ,U ), EFG(Tl,p,U ), and EFG(Tr,p,U ), respectively. Let sl := Sl[EFGt(Tl,p,U ), EFGt(Tl,f ,U )]. By hypothesis, sl is the optimal value among all sets that are local solutions for l and all nodes below l, and hence sl ≥ |U ∩ V (Tl,p)| and analogously, sr ≥ |U ∩ V (Tr,p)|. Thus,
Si[EFGt(Tl,p ⊕ Tr,p,U ), EFGt(Ti,f ,U )] = sl + sr − |X(i) ∩ U|≥ |U ∩ Ti,p|.
For equality, assume wlog sl /= |U ∩ V (Tl,p)|. Hence, there is U' ⊆ V , such that
EFGt(Tl,p,U') = EFGt(Tl,p,U ),
EFGt(Tl,f ,U') = EFGt(Tl,f ,U ) = EFGt(Tr,p ⊕ Ti,f ,U ),
U' is a local solution for l and all nodes below l in the tree decomposition, and
|U' ∩ V (Tl,p)| > |U ∩ V (Tl,p)|.
Let U'' := (U' ∩ V (Tl,p)) ∪ (U \ V (Tl,p)).  Then EFGt(Tl,p,U'') = EFGt(Tl,p,U') = 
EFGt(Tl,p,U ) and EFGt(Ti,f ,U'') = EFGt(Ti,f ,U ), and hence U'' is a also local solution for r and all nodes below r. Similarly, U'' is a local solution for l and all nodes below l. Therefore, U'' is a local solution for i and all nodes below i, but
|U ∩ V (Ti,p)| < |U '' ∩ V (Ti,p)|—a contradiction to the choice of U .
Finally, Lemma 3.2 yields all mentioned run time bounds, where the 4 in 24tow... originates from the cubic complexity required for join, plus a rather pessimistic upper bound of the time required to modify and compute game representations. Note that the first factor still remains 2 · 2w = |2U∩X(i)| since we can fix U ∩ X(i) before doing anything else.	 
On a last remark, we note that Algorithm 1 can easily be modified to work for formulas of the form opt U ∃x1ϕ(U, x1).
Implementation
In the introduction we mentioned that our long-term goal is to obtain a practical implementation of Courcelle’s Theorem that can be used for a wide variety of prob- lems. Currently, such an implementation is already in development. It is written

in C++ and strictly follows Algorithm 1 sketched above. The current state of work is seen as a proof-of-concept, whose primary purpose is to prove feasibility of the approach presented in this paper. In particular, we want to use it to estimate the table size for real graphs occurring in practice. Currently, the parts involving join nodes are still under development, which means we currently can only work on path decompositions of graphs, i.e., where the tree decomposition itself is a path. Since in general the pathwidth is larger than the treewidth, this is no real limitation for our purposes.
Despite its unoptimized prototype state, the implementation is already now able to solve optimization given as a formula with few quantifiers on graphs with small pathwidth, e.g., a grid of size 2 × 100. Among the problems that we tested are Min-

imum
Vertex
Cover,
Minimum
Dominating
Set,
Maximum
Independent

Set, and—to a limited extend–also Minimum Distance Two Dominating Set
(MDTDS), which requires an additional quantifier.
It turns out that indeed the table sizes on graphs occurring in practice are much smaller than the incredible large upper bound suggests. For example, on paths of arbitrary length the tables Pi and Fi contain only up to 960 entries for all formulas with three FO quantifiers (including, e.g., MDTDS). However, the implementation itself is quite naive and requires a lot more work and optimization before it can compete with existing tools like MONA.

Conclusion
The main result of this paper is an alternative proof for a restricted version of Courcelle’s Theorem. Our direct approach uses dynamic programming and respects the input graph to the model-checking problem early. Even a naive implementation without further optimization can avoid space explosion on “simple” graphs.
However, a lot of work remains: Firstly, our method needs to be adopted to all formulas in MSO, in particular we need to allow more set quantifiers. While we believe that task is not too hard, EMSO contains evaluation terms and relations that must be addressed by the framework.
Secondly, Courcelle’s Theorem and its extensions also hold for two-sorted (E)MSO, where quantification over sets of edges is allowed. Two-sorted MSO is
a proper superset of the one-sorted MSO used in this paper, for example one can express the Hamiltonian Path problem, which is known to be impossible in one- sorted MSO. Using two-sorted structures as in, e.g., [1], i.e., a structure with a disjoint set of objects and two relations V and E that distinguishes vertex and edge objects, our method should carry over to two-sorted MSO. However, such structures
have larger treewidth (each edge object appears in each bag), and it is open how this affects the running time of our approach.
Finally, even though the preliminary results encourage further development and optimization of our implementation, a lot of work remains until a real and widely ap- plicable implementation is available. In particular, the formula used for the Cross-
ing Number problem mentioned in the introduction of this work contains many

quantifiers, and additional tricks are required to avoid the explosion even on compa- rably simple graphs. Maybe we can also combine the automata-theoretic methods with our approach for an overall improvement.

References
S. Arnborg, J. Lagergren, and D. Seese. Easy Problems for Tree-Decomposable Graphs. J. Algorithms, 12(2):308–340, 1991.
M. Biehl, N. Klarlund, and T. Rauhe. Algorithms for guided tree automata. In First International Workshop on Implementing Automata, WIA ’96, Lecture Notes in Computer Science, pages 6–25, 1997.
H. L. Bodlaender. A tourist guide through treewidth. Acta Cybernetica, 11:1–21, 1993.
J. R. Bu¨chi. Weak second-order arithmetic and finite automata. Zeitschrift fu¨r mathematische Logik und Grundlagen der Mathematik, 6:66–92, 1960.
B. Courcelle. Graph rewriting: an algebraic and logic approach. In Handbook of theoretical computer science (vol. B): formal models and semantics, pages 193–242. MIT Press, Cambridge, MA, USA, 1990.
B. Courcelle. The monadic second order theory of Graphs I: Recognisable sets of finite graphs.
Information and Computation, 85:12–75, 1990.
B. Courcelle, J. A. Makowsky, and U. Rotics. On the fixed parameter complexity of graph enumeration problems definable in monadic second-order logic. Discrete Applied Mathematics, 108(1-2):23–52, 2001.
B. Courcelle and M. Mosbah. Monadic second-order evaluations on tree-decomposable graphs. Theor. Comput. Sci., 109(1-2):49–82, 1993.
R. G. Downey and M. R. Fellows. Parameterized Complexity. Springer-Verlag, 1999.
H.-D. Ebbinghaus and J. Flum. Finite Model Theory. Springer, 1999.
A. Ehrenfeucht.  An application of games to the completeness problem for formalized theories.
Fundamenta Mathematicae, 49:129–141, 1961.
C. Elgot. Decision problems of finite-automata design and related arithmetics. Trans. Amer. Math. Soc., 98:21–51, 1961.
S. Feferman and R. Vaught. The first order properties of algebraic systems. Fund. Math, 47:57–103, 1959.
J. Flum, M. Frick, and M. Grohe. Query evaluation via tree-decompositions. J. ACM, 49(6):716–752, 2002.
J. Flum and M. Grohe. Parameterized Complexity Theory. Springer-Verlag, 2006.
R. Fra¨ıss´e. Sur quelques classifications des syst`emes de relations. Publications Scientifiques de l’Universit´e d’Alger, Series A(1):35–182, 1954.
M. Frick. Easy Instances for Model Checking. PhD thesis, Universit¨at Freiburg, 2001.
M. Frick and M. Grohe. The complexity of first-order and monadic second-order logic revisited. Ann. Pure Appl. Logic, 130(1–3):3–31, 2004.
M. Grohe. Computing crossing numbers in quadratic time. Journal of Computer and System Science, 68(2):285–302, 2004.
M. Grohe. Logic, graphs, and algorithms. In J. Flum, E. Gr¨adel, and T. Wilke, editors, Logic and Automata: History and Perspectives, pages 357–422. Amsterdam University Press, Amsterdam, 2007.
K. Kawarabayashi and B. Reed. Computing crossing number in linear time. In Proceedings of the 39th ACM Symposium on Theory of Computing, pages 382–390, 2007.
N. Klarlund, A. Møller, and M. I. Schwartzbach. MONA Implementation Secrets. In Proc. of CIAA00, pages 182–194. Springer-Verlag, 2001.
R. E. Ladner. Application of Model Theoretic Games to Discrete linear orders and finite automata.
Information and Control, 33(4):281–303, 1977.

J. A. Makowsky. Algorithmic uses of the Feferman-Vaught Theorem. Ann. Pure Appl. Logic, 126(1- 3):159–213, 2004.
A. R. Meyer. Weak monadic second-order theory of successor is not elementary recursive. In Proc. Symposium on Logic, volume 453 of Lecture Notes in Mathematics, pages 132–154, 1975.
R. Niedermeier. Invitation to Fixed-Parameter Algorithms. Oxford University Press, 2006.
N. Robertson and P. D. Seymour. Graph minors I. Excluding a forest. Journal on Combinatorial Theory Series B, 35:39–61, 1983.
N. Robertson and P. D. Seymour. Graph minors—a survey. In I. Anderson, editor, Surveys in Combinatorics, pages 153–171. Cambridge University Press, 1985.
N. Robertson and P. D. Seymour. Graph minors. II. Algorithmic aspects of tree-width. J. Algorithms, 7:309–322, 1986.
J. W. Thatcher and J. B. Wright. Generalized finite automata theory with an application to a decision problem of second-order logic. Mathematical Systems Theory, 2(1):57–81, 1968.
W. Thomas. Languages, automata, and logic, pages 389–455. Springer-Verlag New York, Inc., New York, NY, USA, 1997.
M. Weyer. Modifizierte parametrische Komplexita¨tstheorie. PhD thesis, Universit¨at Freiburg, 2008.
