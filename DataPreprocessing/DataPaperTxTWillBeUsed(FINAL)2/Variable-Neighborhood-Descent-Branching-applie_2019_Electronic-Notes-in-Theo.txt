Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 346 (2019) 437–447
www.elsevier.com/locate/entcs

Variable Neighborhood Descent Branching applied to the Multi-Way Number Partitioning Problem
Alexandre Frias Faria1 S´ergio Ricardo de Souza1 Elisangela Martins de Sa´1
Centro Federal de Educac¸˜ao Tecnol´ogica de Minas Gerais
Av. Amazonas 7675, 30510-000 – Nova Gameleira – Belo Horizonte – MG – Brazil
Carlos Alexandre Silva2
Instituto Federal de Educa¸c˜ao Tecnol´ogica de Minas Gerais
Av. Serra da Piedade 299, 34515-640 – Morada da Serra – Sabar´a – MG – Brasil

Abstract
This paper presents an application of the Variable Neighborhood Descent Branching method to solve the Multi-Way Number Partitioning Problem. This problem consists of distributing the elements of a given sequence into k disjoint subsets such that the sums of each subset elements fit in the shortest interval. It shows a new method to decompose the MWNPP in n−1 subproblems using local branching constraints. This decomposing justifies the neighborhood structure used in the proposed algorithm. The study of parameter settings defines the operation of the proposed algorithm. The results shows that there is no statistically significant difference of objective value between proposed algorithm and mathematical model solved by CPLEX, but the time used by both methods are significantly different.
Keywords: Combinatorial Optimization, Multi-Way Number Partitioning Problem, Variable Neighborhood Descent Branching, Matheuristics.


Introduction
A partition of a set X is a collection of mutually disjoint subsets whose union forms X. A k-partition is a partition with exactly k non-empty subsets. In this article, the subsets belonging to the partition are called parts, the set Z+ denotes

1 Email: alexandrefrias1@hotmail.com, sergio@dppg.cefetmg.br, elisangelamartins@cefetmg.br
2 Email: carlos.silva@ifmg.edu.br

https://doi.org/10.1016/j.entcs.2019.08.039
1571-0661/© 2019 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

the set of strictly positive integers. Furthermore, the notation Im = {y ∈ Z : 1 ≤
y ≤ m} represents the closed set of integers between 1 and m.
The Two-Way Number Partitioning Problem (TWNPP) consists of finding a 2-partition for the indexes of a given sequence V . The purpose of the problem is to minimize the difference between the sums of elements in distinct parts. A gener- alization of TWNPP is the Multi-Way Number Partitioning Problem (MWNPP). In this problem, the number of parts k in which the sequence elements V are to be distributed is fixed. Let the weight g(Aj) be given by the sum of the elements whose indexes are contained in the part Aj. Given a numerical sequence V , the
goal is to find a k-partition for its indexes, so that the set of weights {g(Aj)}k	be
contained in the shortest possible interval.
TWNPP is formally listed in [7] as one of the basic NP-complete problems. There are a number of equivalences demonstrated between TWNPP and other NP- complete problems. On the other hand, MWNPP appears originally in an article about the analysis of a constructive heuristic called Differencing Method, better known as Karmarkar-Karp Heuristic (KKH), proposed in [6]. According to [4], MWNPP is a very difficult problem to solve using general purpose meta-heuristics, such as Genetic Algorithms, Simulated Annealing and others. In many cases, these methods lose in computational time and performance for constructive heuristics such as KKH and even for the Longest Processing Time heuristic (LPT), proposed by [5]. The construction of exact algorithms for the solution of these problems is proposed in [8]. For this, a Backtrack procedure is performed in constructive heuristics. When the LPT heuristic is used during the enumeration, the Complete Greedy Algorithm (CGA) is produced; if KKH is used, the Complete Karmarkar-Karp Algorithm (CKK) is generated. The first improvement to be proposed in these algorithms occurs with the algorithm Recursive Number Partitioning (RNP), proposed by [9]. The second improvement is due to [12], in which a new data structure applied to the CKK algorithm is proposed, speeding up the search in the Karmarkar-Karp Tree. Through successive MWNPP conversions of a (k − 1)-partition to a k-partition, [11] proposes an algorithm based on solving smaller subproblems. Currently, the state of the art for MWNPP is the Sequential Number Partitioning algorithm, presented in [10], and the Cached Iterative Weakening algorithm, shown in [14]. A complete and highly relevant analysis of these algorithms is found in [13].
Given a mathematical model for the MWNPP, a branching technique by inser- tion of Local Branching Constraints is proposed in [3]. These constraints are defined from an initial solution xs, and determine how close or far a feasible solution can be of xs. This technique allowed the proposition of many exact and approximate meth- ods for the solution of combinatorial optimization problems. One of these methods is the Variable Neighborhood Descent Branching (VNDB), described in [1], which defines its neighborhoods using Local Branching Constraints.
This article addresses an adaptation of the VNDB method to the MWNPP us- ing the constructive heuristic LPT as an initial solution. The ability to exclude regions already exploited from the search space by simply adding constraints to the mathematical model justifies the application of VNDB to solve this problem.

The analysis of the computational time spent and the upper bound for each in- stance shows that VNDB, with a reasonable number of neighborhoods, finds results as good as the standard CPLEX solver and, in addition, in a shorter run time. The article is organized as follows. Section 2 presents the problem addressed and states a mathematical model for MWNPP. Section 3 introduces an analysis of local branching constraints. Section 4 addresses the proposed VNDB method and evalu- ates the particularity of its neighborhood in rings. Following, Section 5 presents the computational tests performed for the comparison between the algorithms. Finally, Section 6 concludes the paper, including a critique about the found results and the proposed scope.
Problem Statement
MWNPP treated here is the version originally addressed in [6]. Its input is a sequence V and its output is a k-partition of the indexes of V .
Definition 2.1 Let V = {v1, v2,..., vn} be a sequence of positive integers, and k a positive integer. Find a k-partition of the V indexes, in the form {A1, A2,..., Ak}, that minimizes the function:
f ({A1, A2,..., Ak})= max{g(Aj′ )}− min{g(Aj)}.	(1)
j′	j
For instance, the sequence V = {11, 25, 13, 34, 89, 65, 43, 96, 56, 87} may be parti- tioned in the ways shown in Table 1 for the values k ∈ {3, 4, 5, 6}. The feasible and optimal values of the objective function for these cases are presented in Table 2.

feasible	optimal

k =3	{96, 43, 34}, {89, 56, 25}, {87, 65, 13, 11}	{89, 87}, {25, 13, 34, 43, 56}, {11, 65, 96}

v	 ,	 
173
v	 ,	 
170
v	 ,	 
176
v , 
176
v	 ,	 
171
v	 ,	 
172

k =4	{96, 25, 13}, {89, 34}, {87, 43}, {65, 56, 11}	{25, 13, 89}, {43, 87}, {34, 96}, {11, 65, 56}

v	 ,	 
134
v , 
123
v , 
130
v	 ,	 
132
v	 ,	 
127
v , 
130
v , 
130
v	 ,	 
132

k =5	{11, 89, 13}, {25, 87}, {96}, {34, 65}, {43, 56}	{11, 89}, {25, 87}, {13, 96}, {34, 65}, {43, 56}

v	 ,	 
113
v , 
112
v , 
96
v , 
99
v , 
99
v , 
100
v , 
112
v , 
109
v , 
99
v , 
99

k =6	{96}, {89}, {87}, {11, 13, 65}, {56, 25}, {43, 34}	{96}, {89}, {87}, {11, 25, 43}, {13, 65}, {34, 56}

v , 
96
v , 
89
v , 
87
v	 ,	 
89
v , 
81
v , 
77
v , 
96
v , 
89
v , 
87
v	 ,	 
79
v , 
78
v , 
90



Table 1
Solutions of MWNPP for k ∈ {3, 4, 5, 6}.

Table 2 Objective function values.

MWNPP can be modeled using binary variables xji to indicates if the i-th term of the sequence V belongs to the part j (xji = 1) or not (xji = 0). Only pairs (j, i)

outside the lower right triangle must be set to avoid multiplicities. Using this set of variables, a mixed integer programming (MIP) formulation for MWNPP can be given as:
min t2 − t1	(2a)
n
st. t1 ≤	vixji ≤ t2,	∀j ∈ Ik	(2b)
i=j
min{i,k}

Σj=1
xji = 1,	∀i ∈ In	(2c)

t1, t2 ∈ R+	(2d)
xji ∈ {0, 1},	∀(j, i): i ≥ j	(2e)
The objective function (2a) minimizes the size of the interval containing

{g(Aj)}k
. Constraints (2b) guarantees that each part is non-empty, since t1 > 0,

and that the weight associated to each part are contained in the interval [t1, t2]. Constraints (2c) guarantee that the parts are disjoint and that all elements of V are allocated to some part, since the problem is only well defined when n ≥ k. Finally, constraints (2d) ensure that the constraints of maxj{g(Aj)} and minj{g(Aj)} are always positive. This MIP model were first introduced in [2], with a little difference in relation to the variables excluded.
The solution of this model implies the solution of MWNPP, but there is still a surjective correspondence between feasible solutions of the mathematical model and the set of k-partitions.
Analysis of Local Branching Constraints
Local Branching constraints define the Hamming distance between a given solu- tion and a feasible solution of the problem by counting the number of variables with different values [3]. Consider an incumbent solution xs for the mathematical model

(2). Let B be the set of pairs of indexes (j, i) such that xs
= 1. Local Branching

constraints are defined by the following expressions:
Δ(xs, x) := Σ (1 − xji) + Σ xji ≤ R	(3a)

Δ(xs, x) := Σ (1 − xji) + Σ xji = R	(3b)
	
Δ(xs, x) := Σ (1 − xji) + Σ xji ≥ R	(3c)
	
The constraint (3a) means that a feasible solution must be at a Hamming distance less than or equal to R with respect to the solution xs. Thus, the neighborhood NR(xs) is a disk of radius R and center xs. In the constraint (3b), only solutions with Hamming distance exactly equal to R in relation to xs are allowed. This neighborhood structure is a degenerate ring with center at xs and internal and external radius equal to R.  Finally, the constraint (3c) considers all the space

outside the radius disk R and center xs as space of feasible solutions.
It is important to note that Local Branching constraints do not always define the exact neighborhood structure, because its shape will depend on the intersection with the feasible region of the mathematical model of the problem studied.
Let x1 and x2 be two distinct feasible solutions of model (2). The first column

of the solution matrix always has the values x1
= 1 and x2
= 1. Therefore, there

are n − 1 columns left for the variables to assume different values. From the second column forwards, an increase of at most two units per column at the total Hamming distance can be obtained since, due to the constraints (2c), there is only one j such that xji = 1 for each i column. Thus, the Hamming distance between two feasible solutions of the mathematical model (2) is always an even number. Therefore, it can be concluded that:
∀x1, x2	∃r ∈ In−1 :	Δ(x1, x2)= 2r	(4)
and, as a consequence of (4), the maximum Hamming distance between two feasible solutions can be given as:
max{Δ(x1, x2)} = 2(n − 1).	(5)
Therefore, there is a decomposition of MWNPP into subproblems with con- straints (3b). Using the equation (4), a subproblem Pr(xs) resulted by adding the constraint Δ(xs, x)= 2r to the model (2) is given as:
(Pr(xs))  min t2 − t1	(6a)
n
st. t1 ≤	vixji ≤ t2,	∀j ∈ Ik	(6b)
i=j
min{i,k}

Σj=1
xji = 1,	∀i ∈ In	(6c)

Σ (1 − xji) + Σ xji = 2r	(6d)

t1, t2 ∈ R+	(6e)
xji ∈ {0, 1},	∀(j, i): i ≥ j	(6f)
It is known that the mathematical model (6) only assumes feasible solutions when 1 ≤ r ≤ n − 1 due to the equation (5). It is also important to note that Pr (xs) and Pr (xs) have no feasible solution in common whenever r1 /= r2, because its distances from solution xs are distinct in this case. Therefore, the collection of subproblems {Pr(xs)}n−1 is a decomposition of the mathematical model (2) and, thus, a decomposition of MWNPP.
Proposed Algorithm
The proposed VNDB algorithm works with the insertion and removal of Lo- cal Branching Constraints aiming, in addition to the definition of neighborhoods,

the memory of the search space already explored using mathematical expressions. Thus, let x1 be a feasible solution of the problem (2) and x2 be the solution of the subproblem P1(x1). The initial problem of VNDB is P1(x1). The next subproblem will be P2(x1) or P1(x2) ∩ {Δ(x1, x) ≥ 2}, depending on which is the best solution, or x1 or x2. The same logic applies to each of the possibilities.
In general, method decisions are made as follows. Let M be a set of constraints of

type (3c) and (xl)m
a sequence of solutions found by VNDB. In the iteration t, the

solution of the subproblem Pr(xl)∩M leads to the solution xl+1. If the solution xl+1 is better than xl, the subproblem is updated by adding the constraint Δ(xl, x) ≥ 2(r + 1) to the set M and yielding the set Mj. This step eliminates the feasible region of the Pr(xl) subproblem. Finally, the constraint Δ(xl, x) = 2r is replaced by the constraint Δ(xl+1, x) = 2. This procedure creates a problem in the form P1(xl+1) ∩Mj. If the solution xl+1 is no better than xl, the constraint Δ(xl, x)= 2r is changed by Δ(xl, x)= 2(r + 1), generating the subproblem Pr+1(xl) ∩ M .
The mathematical model (7) shows the structure of the VNDB subproblem after
passing through m distinct solutions and performing t = Σm rl iterations.




min t2 − t1	(7a)
n
s.t. t1 ≤	vixji ≤ t2,	∀j ∈ Ik	(7b)
i=j
min{i,k}

Σj=1
xji = 1,	∀i ∈ In	(7c)

Σ (1 − xji) +	Σ xji = 2rm	(7d)

Σ (1 − xji) +	Σ xji ≥ 2rl,	∀l ∈ Im—1	(7e)
	
t1, t2 ∈ R+	(7f)
xji ∈ {0, 1},	∀(j, i): i ≥ j	(7g)




The subproblem (7) has m more constraints than the mathematical model (2). The constraint (7d) represents the current neighborhood of the iteration. The m− 1 constraints (7e) make infeasible the search regions of the previous subproblems. The increase of m with the number of iterations depends on the initial solution chosen and the size of the neighborhood structure. The values rl ∈ In—1 define by how many neighborhoods each solution passed without being surpassed.



Algorithm 1 VNDB
1: function VNDB(x˙, N )	d Initial solution and number of neighborhoods
2:	r → 1	d Initial neighborhood
3:	t → 1	d Iteration
4:	while t < Itermax and r ≤ N do
5:	add Δ(x˙, x)= 2r
6:	x¨ → solve()	d Subproblem solution
7:	remove Δ(x˙, x)= 2r
8:	if optimal then
9:	if ƒ (x¨) ≥ ƒ (x˙) then	d Without improved solution
10:	r → r +1	d Next neighborhood
11:	else	d Improved solution
12:	add Δ(x˙, x) ≥ 2(r + 1)	d Exclusion of explored search space
13:	r → 1	d Return to the first neighborhood

14:
x˙ → x¨
d Update solution

15:	end if
16:	else if ƒeasible then	d No search space reduction
17:	if ƒ (x¨) ≥ ƒ (x˙) then
18:	r → r +1 
19:	else
20:	r → 1

21:
x˙ → x¨

22:	end if
23:	else	d Infeasible or solve() does not find solution
24:	r = r +1 
25:	end if
26:	t → t +1 
27:	end while
28:	return x˙
29: end function
Algorithm 1 summarizes the above explanations. The stopping criterion is the exhaustion of the N neighborhoods in a given solution or by the maximum number of iterations Itermax (or maximum time). In practice, the function solve() also has a time limit to resolve the VNDB subproblem. Then there must be conditional deviations for all possible solution status: {feasible, optimal, infeasible}.
When the method solve() returns a feasible but not optimal improvement so- lution, it is not possible to exclude the subproblem region because there is some unexploited space that may still contain the optimal solution to the general problem.

Computational Experiments
The proposed VNDB algorithm and the mathematical model presented in Sec- tion 2 were coded in C++ using the Concert Technology of CPLEX 12.6 in the default configuration. The computational experiments were carried out on an Intel Core i7-3770 CPU 3.4 GHz with 8 cores and 32GB RAM running on a Ubuntu
16.04 64-bit operating system using clang compiler version 3.8. The test instances composed of a set of sequences were randomly generated as follows. Sequences with n integer elements with 12 digits ranging from 0000000000 to 999999999999 are generated by randomly sampling for 12 consecutive times a number between 0 and 9 using a uniform distribution.

The computational experiments are performed aiming to compare the quality of the solution ub and the computational time associated to the VNDB and the CPLEX solver applied in the mathematical model 2 considering a time limit of t = 4500 seconds. The measures used to compare the results are based on the relative error measure given by gap(B, A)= z(A)—z(B) 100%, where z(A) and z(B) corresponds to the objective function value associated to the best solution provided by algorithm A and algorithm B, respectively. This function shows that the solution provide by the algorithm B is better than the solution provided by the algorithm A when gap(B, A) > 0. For instance, the gap(B, A) = 90% means that the response of the algorithm A would have to be divided by 10 to match the algorithm B response. The closer to 100% is the result of the function gap(B, A), better the algorithm B is compared to an algorithm A. The same measure applies to the run time of the algorithms. The order of the algorithms in the function entry is gap(V NDB, MIP ). The values of gap() ≥ 100% are due to rounding.
A set of experiments was performed using the generated instances with n ∈
{100, 200, 400, 800} and considering k ∈ {3, 4, 5, 6}. Tables A.1 and A.2 present the computational experiments results, i.e., the runtime (in seconds) and the upper bound (ub), for each instance. These results are used to compute the gap() presented in Table A.3. Table A.3 may be observed for a descriptive analysis of the results. First, the VNDB runtime is always shorter since the gapt values are greater than 60%, indicating a runtime of at least 2.5 times smaller. VNDB finds the optimal solution for 9 instances in the k = 3 column when gapub = 100% is observed. Furthermore, the number of times that the ub provided by the VNDB algorithm exceeds the one provided by the mathematical model (2) solved via CPLEX solver, which corresponds to the number of positive gapub observed, is a total of 39 of the 80 instances tested. In more detail, VNDB presented to be best in 10 instances of column k = 3, 8 instances of column k = 4, 8 instances of column k = 5, and 13 instances of column K = 6.
Finally, a set of statistical tests using objective function values falg as samples is performed. The tests aim to answer whether it is possible to assert with 95% confidence if the objective function values fMIP , associated to the best solution attained by CPLEX solver when solving the mathematical model (2), are smaller than the ub obtained through VNDB, given by fV NDB. The hypothesis test used is:


H0 : fMIP ≥ fV NDB H1 : fMIP < fV NDB
(8)


Table 3 shows the p-values of the statistical tests using objective function values falg as samples. The hypothesis test rejects the null hypothesis only in instances with k = 4. In this case, it is possible to state that there is a difference between the algorithms and this difference is significant, i.e., the ub obtained through VNDB is inferior to objective function values fMIP associated to the mathematical model
(2). In other cases, there is no difference between the results.

Table 3
Results of the paired t-test with 95% confidence using the objective function values.


Conclusion
This article presented an adapted VNDB matheuristic for solving MWNPP and a comparison with the solution of the mathematical model using the CPLEX solver. Results were obtained using randomly generated instances with uniformly distributed elements.
Computational experiment results show that VNDB never reaches the maximum time available for execution due to neighborhood exhaustion and a large number of solved subproblems with non-optimal status. Despite this, VNDB has statistically as good results as the same MIP running for a shorter time interval. The only exception is its performance in instances where k = 3. A drawback found in the computational experiments is that the CPLEX solver does not seem to set time in a deterministic way on a multi-core processor. This causes some problems to take up to 4500 seconds more in MIP execution.
As future work, a more elaborate parameter analysis can be applied to the proposed VNDB so that it can use all the available time for the experiment. Thus the comparison with the MIP problem can be more fair.

References
Caserta, M. and S. Voß, Matheuristics: Hybridizing metaheuristics and mathematical programming, Metaheuristics: Intelligent Problem Solving, Springer, Berlin (2009), pp. 1–38.
Faria, A. F., S. R. de Souza and C. A. Silva, Variable neighborhood descent applied to multi-way number partitioning problem, Electronic Notes in Discrete Mathematics 66 (2018), pp. 103 – 110.
Fischetti, M. and A. Lodi, Local branching, Mathematical programming 98 (2003), pp. 23–47.
Gent, I. P. and T. Walsh, Analysis of heuristics for number partitioning, Computational Intelligence
14 (1998), pp. 430–451.
Graham, R. L., Bounds for certain multiprocessing anomalies, The Bell System Technical Journal XLV
(1966), pp. 1563–1581.
Karmarkar, N. and R. M. Karp, The differencing method of set partition, Report UCB/CSD 81/113, Computer Science Division, University of California, Berkeley, CA (1982).
Karp, R. M., Reducibility among combinatorial problems, in: R. E. Miller, J. W. Thatcher and J. D. Bohlinger, editors, Proceedings of a Symposium on the Complexity of Computer Computations (1972),
pp. 85–103.
Korf, R. E., A complete anytime algorithm for number partitioning, Artificial Intelligence 106 (1998),
pp. 181–203.
Korf, R. E., Multi-way number partitioning., in: IJCAI, Citeseer, 2009, pp. 538–543.
Korf, R. E., E. L. Schreiber and M. D. Moffitt, Optimal sequential multi-way number partitioning, in:
International Symposium on Artificial Intelligence and Mathematics (ISAIM-2014), 2013.
Moffitt, M. D., Search strategies for optimal multi-way number partitioning, in: Proceedings of the Twenty-Third international joint conference on Artificial Intelligence, AAAI Press, 2013, pp. 623–629.

Pedroso, J. P. and M. Kubo, Heuristics and exact methods for number partitioning, European Journal of Operational Research 202 (2010), pp. 73–81.
Schreiber, E. L., “Optimal Multi-Way Number Partitioning,” Ph.D. thesis, University of California Los Angeles (2014).
Schreiber, E. L. and R. E. Korf, Cached iterative weakening for optimal multi-way number partitioning, in: Proceedings of the Twenty-Eighth Annual Conference on Artificial Intelligence (AAAI-14) Quebec City, Canada, 2014.

A	Appendix
Table A.1 Mathematical Model 2 Results

All resources used for experiments of this paper (including codes, in- stances, and results) are available in https://github.com/AlexandreFrias/ AlgorithmsLAGOS2019.

Table A.2 VNDB Results

Table A.3
Comparison between VNDB and Mathematical Model 2 using gap(vndb, mip) on upper bound and runtime.
