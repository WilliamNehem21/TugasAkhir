 Electronic Notes in Theoretical Computer Science 91 (2004) 171–194 
www.elsevier.com/locate/entcs




A Membership Algorithm for Functional and Multi-valued Dependencies in the Presence of Lists
Sven Hartmann1 and Sebastian Link2
Information Science Research Centre, Massey University,
Palmerston North, New Zealand

Abstract
Nested lists are used as a data structure whenever order matters. List types are therefore supported by many advanced data models such as genomic sequence, deductive and object-oriented data models including XML.
What impact does the finite list type have on the two most important classes of relational de- pendencies? The membership problem of functional and multi-valued dependencies in databases supporting base, record and list types is investigated. The problem is to decide whether a functional or multi-valued dependency follows from a given set of functional and multi-valued dependencies. In order to capture different data models at a time, an abstract algebraic approach based on nested attributes and subtyping is taken. This algebraic framework allows to generalise Beeri’s well-known membership algorithm in [6] from the relational data model. It is argued that the algorithm presented works correctly and in polynomial time.
Keywords: Advanced Data Models, Dependencies, Finite Implication Problem, Correctness, Complexity


Introduction
Dependency Theory in Relational Databases
In designing databases the semantics of the application domain has to captured as completely as possible. As this cannot be expressed solely by structures,

1 Email:s.hartmann@massey.ac.nz
2 Email:s.link@massey.ac.nz


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2003.12.012

we have to use dependencies, i.e., sentences in a logic suitable for the data model used. Database theory has to investigate the implications arising from the presence of dependencies. This means to describe semantically desirable properties of “well-designed” databases, e.g., the absence of redundancy, to characterise (if possible) them syntactically by in-depth investigation of the dependencies and to develop algorithms to transform schemata into normal forms, which guarantee the desirable properties to be satisfied.
In the relational data model (RDM, [2,36]) a lot of research has been done on dependency theory and normal forms. Starting with the seminal work by Codd [20] normal forms such as third normal form (3NF), Boyce- Codd normal form (BCNF, [13,21]) and fourth normal form (4NF, [22,23,24]) have been introduced to characterise the absence of redundancy and update anomalies in the presence of functional and multi-valued dependencies (FDs, MVDs), though a theoretically convincing justification for these normal forms was given only 20 years later [45]. Roughly speaking, a functional dependency X → Y requires that whenever two tuples of a relation coincide on X, they must also coincide on Y . A multi-valued dependency X ։ Y requires that whenever two tuples of a relation coincide on X, their values on Y must be mutually exchangeable and thus generate additional tuples.
Various other classes of dependencies for the RDM have been introduced (see [41] for an overview) and large parts of database theory deals with the finite axiomatisation of these dependencies and the finite implication problem for them, i.e., to decide that a dependency ϕ is implied by a set of dependencies Σ, where implication refers to the fact that all finite models of Σ are also models of ϕ. Armstrong [4] was the first to give a finite axiomatisation for FDs, and Beeri and others gave a finite axiomatisation for FDs and MVDs [9] and developed various versions of efficient decision algorithms [6,7,8].
Challenges in Advanced Data Models
The need to store data beyond relational structure has become more and more apparent over the years. Many new and different data models have been in- troduced. First, so called semantic data models have been developed [18,30], which were originally just meant to be used as design aids, as application se- mantics was assumed to be easier captured by these models [5,19,44]. Later on some of these models, especially the nested relational model [36], object oriented models [38] and object-relational models, the gist of which are cap- tured by the higher-order Entity-Relationship model (HERM, [42,43]) have become interesting as data models in their own right.
One key problem is to develop dependency theories (or preferably a uni- fied theory) for the most relevant advanced data models. These are probably

the HERM as a nested model with various bulk type constructors, good the- oretical foundations and proven practical relevance [43], the object oriented model [38], the semi-structured data model and XML [1], which add unions and most importantly references, the expansion of which leads to rational tree structures. The development of such a dependency theory will have a signif- icant impact on understanding application semantics and laying the grounds for a logically founded theory of well-designed databases.
Biskup [15,16] lists in particular two challenges for database design the- ory: finding a unifying framework and extending achievements to deal with advanced database features such as complex object types.

Contributions
This paper continues to take on these two challenges. In order to find a unifying framework and capture several data models at a time our work is based on an abstract approach in the context of types for nested attributes and subtyping. Recall that in the RDM, the set of all subsets of a relation schema forms a Boolean Algebra with respect to inclusion and the set operations of union, intersection and difference. This simple, yet powerful tool is the basis for the success of relational dependency theory. We follow a similar algebraic approach in order to extend these achievements to complex object types.
This article considers FDs and MVDs in the presence of record and list types. There are several reasons for the importance of lists. First of all, lists are perhaps the most common data type. The need for lists arises from ap- plications that store ordered relations, time-series data, meteorological and astronomical data streams, runs of experimental data, multidimenstional ar- rays, textual information, voices, sound, images, video, etc. Lists have been subject to studies in the deductive and temporal database community for some time [37,34]. The list type also naturally appears in object-oriented databases [38,25] and is in particular important for XML [1,47]. Recently, bioinformatics has become a very important field of research. Of course, lists occur naturally in genomic sequence databases [39,17].
The main result in [29] presents a finite axiomatisation of FDs and MVDs in the presence of record and finite list types extending the work in [9] from the RDM. This paper presents a membership algorithm for deciding the finite implication problem of FDs and MVDs. Due to the natural algebraic ap- proach, this algorithm is quite similar to Beeri’s membership algorithm from the RDM ([6]). Such an algorithm for deciding implication of dependencies can be used to decide the equivalence of two sets of dependencies or the re- dundancy of a given set of dependencies. This is considered a significant step towards automated database schema design [12,10,11] which some researchers

see as the ultimate goal for research in dependency theory [8].
Furthermore, we formally demonstrate that the algorithm works correctly and in polynomial time. Finally, the paper shows that the algebraic approach based on nested attributes seems to be very natural. That is, established re- sults from relational database theory can be carried over to complex object databases. The nesting of attributes can be easily extended to sets, multi- sets, unions, references etc. Therefore, our work might serve as a unifying framework for the foundation of dependency theory in advanced data models.
Outline
The paper is structured as follows. Section 2 briefly comments on related work. After introducing fundamental definitions in Section 3, it is demon- strated that the set of subattributes for some fixed nested attribute carries the structure of a Brouwerian Algebra (co-Heyting Algebra). This generalises the framework of a Boolean Algebra from the RDM. We repeat in Section 4 how to obtain a sound and complete set of inference rules for the implication of FDs and MVDs in the presence of base, record and list types (see [29]). The inference rules presented are natural generalisations of their counterparts from relational databases. It turns out, however, that an additional rule allowing the derivation of non-trivial FDs from MVDs is needed (which is impossible in the RDM). In order to decide the membership problem it is sufficient to compute the dependency basis of some nested attribute. Section 5 presents an algorithm for computing the dependency basis. The algorithm is a nat- ural extension of Beeri’s membership algorithm from the RDM ([6]). The correctness proof, outlined in Section 6, is based on the finite axiomatisation from [29] using the algebraic framework. Finally, Section 6 demonstrates that the membership problem can be solved in polynomial time. We conclude in Section 7 and comment on future work.

Previous and Related Work
The work in [33] and [35] study normalisation in the nested relational data model where nesting refers to sets rather than lists. Both approaches define FDs based on the notion of a path and do not derive any axiomatisation re- sults nor algorithms for deciding the (finite) implication problem. We have also studied FDs in the presence of the finite set type and provided a finite axiomatisation [27] and a normal form proposal [28] proving the equivalence to the absence of redundancy and sufficiency for the absence of any update anomalies in the spirit of [45]. The expressiveness of FDs, based on our al- gebraic approach in the presence of sets only, deviates from those in either

works mentioned above.
The article [40] considers normalisation in an object-oriented framework. The authors provide an extension of functional dependencies to cope with the richer semantics of relationships between objects, called path dependency, local dependency, and global dependency constraints. An object is said to be in normal form if and only if the user’s interpretation of this object is derivable from the model of the object. Again, this approach is very different from ours. The works in [3] and [46] define FDs in the context of XML. Both notions are again based on paths. [3] derives some complexity results for the implica- tion problem of certain subclasses of FDs and certain DTDs. The only paper that discusses MVDs is [46]. There are, however, no results on axiomatisation nor any discussion of the implication problem. In fact, the approaches are entirely different from ours. Note that there are different notions of FDs in the context of XML which all lead to a different expressiveness. See [26] for a discussion. Normalisation should then be studied from different points of
view.
The approach in this paper specifically focuses on lists and is of algebraic nature. The authors are not aware of any similar work in the literature.

The Algebra of Nested Attributes
This section introduces a data model based on the nesting of attributes and subtyping. It may be used to provide a unifying framework for the study of complex object types such as records, lists, sets, multisets, unions and references. This article, however, focuses on records and lists only.
Nested Attributes
We start with the definition of flat attributes and values for them.
Definition 3.1 A universe is a finite set U together with domains (, i.e., sets of values) dom(A) for all A ∈ U. The elements of U are called flat attributes.2
For the relational data model a universe was sufficient. That is, a relation schema is defined by a finite and non-empty subset R ⊆ U. For higher-order data models, however, nested attributes are needed. In the following definition we use a set L of labels, and assume that the symbol λ is neither a flat attribute nor a label, i.e., λ ∈/ U ∪ L. Moreover, flat attributes are not labels and vice versa, i.e., U ∩ L = ∅.
Definition 3.2 Let U be a universe and L a set of labels. The set N A = N A(U , L) of nested attributes over U and L is the smallest set satisfying the following conditions:

λ ∈ N A,
U ⊆ N A,
for L ∈ L and N1, . . . , Nk ∈ N A with k ≥ 1 we have L(N1, . . . , Nk) ∈ N A,
for L ∈ L and N ∈ N A we have L[N ] ∈ N A.
We call λ null attribute, L(N1, . . . , Nk) record-valued attribute and L[N ] list- valued attribute.	2
We can now extend the mapping dom from flat attributes to nested at- tributes, i.e., we define a set dom(N ) of values for every nested attribute N ∈ N A.
Definition 3.3 For a nested attribute N ∈ N A we define the domain dom(N ) as follows:
dom(λ) = {ok},
dom(L(N1, . . . , Nk)) = {(v1, . . . , vk) | vi ∈ dom(Ni) for i = 1, . . . , k}, i.e., the set of all k-tuples (v1, . . . , vk) with vi ∈ dom(Ni) for all i = 1,  , k, and
dom(L[N ]) = {[v1, . . . , vn] | vi ∈ dom(N ) for i = 1, . . . , n}, i.e., the set of	 all finite lists with elements in dom(N ).	2
The empty list is denoted by [ ]. Note that the relational data model is completely covered by the presence of tuple-valued attributes only. Instead of relation schemata R we will now consider a nested attribute N , assuming that a universe U and a set L of labels are fixed. An R-relation r is then replaced by some finite set r ⊆ dom(N ).

Subattributes
Dependency theory in the relational data model is based on the powerset P(R) for a relation schema R. In fact, P(R) is a powerset algebra with partial order
⊆, set union ∪, set intersection ∩ and set difference −. We will generalise these operations for nested attributes starting with a partial order ≤.
Definition 3.4 The subattribute relation ≤ on the set of nested attributes N A over U and L is defined by the following rules, and the following rules only:
N ≤ N for all nested attributes N ∈ N A,
λ ≤ A for all flat attributes A ∈ U,
λ ≤ N for all list-valued attributes N ∈ N A,
L(N1, . . . , Nk) ≤ L(M1, . . . , Mk) whenever Ni ≤ Mi for all i = 1,	, k,
L[N ] ≤ L[M ] whenever N ≤ M .

For N, M ∈ N A we say that M is a subattribute of N if and only if M ≤ N
holds. We write M /≤ N if and only if M is not a subattribute of N .	2
The subattribute relation ≤ on nested attributes is reflexive, anti-symmetric and transitive.
Lemma 3.5 The subattribute relation is a partial order on nested attributes.2
Informally, M ≤ N for N, M ∈ N A if and only if M comprises at most as much information as N does. The informal description of the subattribute
relation is formally documented by the existence of a projection function πN :
Dom(N ) → Dom(M ) in case M ≤ N holds.
Definition 3.6 Let N, M ∈ N A with M ≤ N . The projection function
N : Dom(N ) → Dom(M ) is defined as follows:

if N = M , then πN
if M = λ, then πN
= idDom(N) is the identity on dom(N ),
: Dom(N ) → {ok} is the constant function that maps

every v ∈ Dom(N ) to ok,
if N = L(N , . . . , N ) and M = L(M , . . . , M ), then πN

= πN1 × · · · × πNk

1	k	1	k
M	M1	Mk

which maps every tuple (v1, . . . , vk) ∈ Dom(N ) to (πN1 (v1), . . . , πNk (vk)) ∈
M1	Mk
Dom(M ), and
if N = L[N ′] and M = L[M ′], then πN : Dom(N ) → Dom(M ) maps every
M N ′	N ′
list [v1, . . . , vn] ∈ Dom(N ) to the list [πM ′ (v1), . . . , πM ′ (vn)] ∈ Dom(M ). 2
Let X , Y be two sets of nested attributes. X is called a generalised subset of Y, denoted by X ⊆gen Y if and only if for every X ∈ X there is some Y ∈ Y with X ≤ Y . Note that ⊆gen is a pre-order on sets of nested attributes.

The Brouwerian Algebra of Subattributes
Fix a set U of attribute names, and a set L of labels.
Definition 3.7 Let N ∈ N A be a nested attribute. The set Sub(N ) of subattributes of N is Sub(N ) = {M | M ≤ N }. The bottom element λN of Sub(N ) is given by λN = L(λN1 , . . . , λNk ) whenever N = L(N1, . . . , Nk), and λN = λ whenever N is not a tuple-valued attribute.	2
We study the algebraic structure of Sub(N ). A Brouwerian Algebra [31] is

a lattice (L, ⊑, ⊔, ⊓, −. , 1) with top element 1 and a binary operation −.
which

satisfies a−. b ⊑ c iff a ⊑ b ⊔ c for all c ∈ L. In this case, the operation −. is called the pseudo-difference. The Brouwerian complement ¬a of a ∈ L is then defined by ¬a = 1−. a. A Brouwerian Algebra is also called a co- Heyting Algebra or a dual Heyting Algebra. The system of all closed subsets of a topological space is a well-known Brouwerian Algebra. It is obvious that

(Sub(N ), ≤, λN , N ) is a partially ordered set with bottom element λN and top element N .
Definition 3.8 Let N ∈ N A and Y, Z ∈ Sub(N ). The join Y ⊔N Z, meet Y ⊓N Z and pseudo difference Y −. N Z of Y and Z in Sub(N ) are inductively defined as follows:
Y ⊔N Z = Z iff Y ≤ Z iff Y ⊓N Z = Y and Z−. N λN = Z, and Z ≤ Y iff
Z−. N Y = λN ,
if N = L[M ], Y = L[A], Z = L[B], then Y ◦N Z = L[A ◦M B] for ◦ ∈ {⊔, ⊓}
and if Z /≤ Y , then Z−. N Y = L[B−. M A].
if N = L(N1, . . . , Nn), Y = L(A1, . . . , An) and Z = L(B1, . . . , Bn), then
Y ◦N Z = L(A1 ◦N1 B1, . . . , An ◦Nn Bn) for ◦ ∈ {⊔, ⊓, −}.	2
.
In order to simplify notation, occurences of λ in a tuple-valued attribute are usually omitted if this does not cause any ambiguities. That is, the sub- attribute L(M1, . . . , Mk) ≤ L(N1, . . . , Nk) is abbreviated by L(Mi1 , . . . , Mil ) where {Mi1 , . . . , Mil } = {Mj : Mj /= λNj and 1 ≤ j ≤ k} and i1 < · · · < il. If Mj = λNj for all j = 1, . . . , k, then we use λ instead of L(M1, . . . , Mk). The subattribute L1(A, λ, L2[L3(λ, λ)]) of L1(A, B, L2[L3(C, D)]) is abbrevi- ated by L1(A, L2[λ]). However, the subattribute L(A, λ) of L(A, A) cannot be abbreviated by L(A) since this may also refer to L(λ, A).
If the context allows, we omit the index N from the operations ⊔N , ⊓N , −. N and from λN . The Brouwerian Algebra for J[K(A, L[M (B, C)])] is illustrated in Figure 1.
  J[K(A,L[M(B,C)])]
J[K(L[M(B,C)])]

 J[K(A,L[M(B)])]
 J[K(A,L[M(C)])]

J[K(L[M(B)])]
 
 


J[K(L[M(C)])] 


  J[K(A,L[ ])]



J[K(L[ ])] 
 J[K(A)]



J[ ] 











 
 
Fig. 1. The Brouwerian Algebra of J[K(A, L[M (B, C)])]


Given some nested attribute N ∈ N A and Y, Z ∈ Sub(N ), we use Y C = N −. Y to denote the Brouwerian complement of Y in Sub(N ). Again, we omit the subscript N if the context allows. The pseudo difference Z−. Y of Z and Y in

Sub(N ) satisfies
Z−. Y ≤ X	if and only if	Z ≤ Y ⊔ X
for all X ∈ Sub(N ). Consequently, for all X ∈ Sub(N ) holds Y C ≤ X if and only if X ⊔ Y = N holds.
The following result is straightforward to see: Sub(λ) is isomorphic to the Boolean Algebra of order 0, Sub(A), A a flat attribute, isomorphic to the Boolean Algebra of order 1. Sub(L(P )) is isomorphic to Sub(P ), Sub(L(P1, . . . , Pn)) isomorphic to the direct product of Sub(P1), . . . , Sub(Pn), and Sub(L[P ]) is isomorphic to Sub(P ) augmented by a new minimum. It is an easy exercise to show that the set of all (finite) Brouwerian Algebras is closed with respect to both operations (add a new minimum, direct product). The following theo- rem generalises the fact that (P(R), ⊆, ∪, ∩, −, ∅, R) is a Boolean Algebra for a relation schema R in the RDM.
Theorem 3.9 (Sub(N ), ≤, ⊔N , ⊓N , −. N , N ) forms a Brouwerian Algebra for every N ∈ N A.	2
Note that (Sub(N ), ≤, ⊔, ⊓, (·)C, λ, N ) is in general not boolean. Take for instance N = L[A] and Y = L[λ]. Then Y C = N and Y ⊓ Y C = Y /= λ. Furthermore, Y CC = λ /= Y . Moreover, every Brouwerian Algebra is distributive.
Axiomatising FDs and MVDs
Definition 4.1 Let N ∈ N A be a nested attribute. A functional dependency on N is an expression of the form X → Y where X, Y ∈ Sub(N ). A finite set r ⊆ Dom(N ) satisfies a functional dependency X → Y on N if and only if
πN (t1) = πN (t2) holds whenever πN (t1) = πN (t2) for any t1, t2 ∈ r holds.
Y	Y	X	X
A multi-valued dependency on N is an expression of the form X ։ Y where
X, Y ∈ Sub(N ). A finite set r ⊆ Dom(N ) satisfies a multi-valued dependency
X ։ Y on N if and only if for all values t1, t2 ∈ r with πN (t1) = πN (t2) there

is a value t ∈ r with πN
(t) = πN
(t1) and πN
X
C (t) = πN
X
C (t2).	2

Example 4.2 Consider N =Pubcrawl(Person,Visit[Drink(Beer,Pub)]) and a typical snapshot r ⊆ Dom(N ):
{ (Sven,[(Lu¨bzer,Deanos),(Kindl,Highflyers)]), (Sven,[(Kindl,Deanos),(Lu¨bzer,Highflyers)]),
(Klaus-Dieter,[(Guiness,Irish Pub),(Speights,3Bar),(Guiness,Irish Pub)]), (Klaus-Dieter,[(K¨olsch,Irish Pub),(B¨onnsch,3Bar),(Guiness,Irish Pub)]), (Klaus-Dieter,[(Guiness,Highflyers),(Speights,Deanos),(Guiness,3Bar)]),

(Klaus-Dieter,[(K¨olsch,Highflyers),(B¨onnsch,Deanos),(Guiness,3Bar)]), (Sebastian,[ ]) }
Obviously, the FD
Pubcrawl(Person) → Pubcrawl(Visit[Drink(Pub)]) is not satisfied by r, neither is the FD
Pubcrawl(Person) → Pubcrawl(Visit[Drink(Beer)]).
However, |=r Pubcrawl(Person) ։ Pubcrawl(Visit[Drink(Pub)]). This MVD informally says that a person has prefered lists of pubs, e.g. according to the weekday, and prefered lists of beers, e.g. according to the mood that person is in. Since a weekday is independent from the mood of a person, all possible combinations of these lists can occur. Note that
|=r Pubcrawl(Person) → Pubcrawl(Visit[λ])
holds. This means informally that the person determines the number of bars visited by that person.	2
The notions of implication (|=) and derivability (⊢R) with respect to a set R of inference rules for a class C of dependencies can be defined analogously to the notions in the RDM (see for instance [2, pp. 164-168]). Since (real-life) databases are always finite, implication is considered to be finite implication only in this article. Let Σ be a set of dependencies from C on some nested attribute N . We are interested in the set of all dependencies in C implied by Σ, i.e., Σ∗ = {ϕ ∈ C | Σ |= ϕ}. Our aim is finding sets R of inference rules
which are sound (Σ+ ⊆ Σ∗ ) and complete (Σ∗ ⊆ Σ+) for the implication of
C	C	C	C
dependencies in the class C, and where Σ+ = {ϕ ∈ C | Σ ⊢R ϕ}. In this paper, C will be the class of FDs and MVDs.
A dependency σ on some nested attribute N is called trivial if and only if |=r σ for every r ∈ Dom(N ). Trivial FDs and trivial MVDs have been characterised in [29].
Lemma 4.3 Let N ∈ N A, X → Y an FD on N and X ։ Y an MVD on
N. Then is X → Y trivial if and only if Y ≤ X holds.Furthermore is X ։ Y
trivial if and only if Y ≤ X or X ⊔ Y = N holds.	2
Fagin proves in [23] that MVDs “provide a necessary and sufficient con- dition for a relation to be decomposable into two of its projections without loss of information (in the sense that the original relation is guaranteed to be the join of the two projections).” Let N ∈ N A and X, Y ∈ Sub(N ). Let

r1 ⊆ Dom(X) and r2 ⊆ Dom(Y ). Then

r1 ⊲⊳ r2	=	{t ∈ Dom(X ⊔ Y ) | there are t1 ∈ r1, t2 ∈ r2 with
πX⊔Y (t) = t1 and πX⊔Y (t) = t2}.
X	Y

is called the generalised join r1 ⊲⊳ r2 of r1 and r2. The projection πX (r) of r ⊆ Dom(N ) on X ≤ N is defined as {πN (r) | t ∈ r}. In this sense, r ⊆ Dom(N ) satisfies the MVD X ։ Y exactly when r is the lossless generalised join of its projections on X ⊔ Y and X ⊔ Y C, i.e., r = πX⊔Y (r) ⊲⊳ πX⊔Y C (r). The following theorem has been proven in [29].
Theorem 4.4 Let N ∈ N A, r ⊆ Dom(N ) and X ։ Y an MVD on N. Then is X ։ Y satisified by r if and only if r = πX⊔Y (r) ⊲⊳ πX⊔Y C (r).   2
Note that if an FD X ։ Y on N is satisfied by some r ⊆ Dom(N ), then r = πX⊔Y (r) ⊲⊳ πX⊔Y C (r), but not vice versa. Take for instance N = L(A, B) and r = {(a, b1), (a, b2)}. Then |=r L(A) → L(B), but r = {a} ⊲⊳ {b1, b2}.
Example 4.5 In view of Theorem 4.4,
|=r Pubcrawl(Person) ։ Pubcrawl(Visit[Drink(Pub)]) in Example 4.2 suggests to decompose r into the two projections
rPubcrawl(Person,Visit[Drink(Pub)]) and rPubcrawl(Person,Visit[Drink(Beer)]), i.e.,
{(Sven,[Lu¨bzer,Kindl]),(Sven,[Kindl,Lu¨bzer]),(Klaus- Dieter,[Guiness,Speights,Guiness]),(Klaus-
Dieter,[K¨olsch,B¨onnsch,Guiness]),(Sebastian,[ ]) }
and
{(Sven,[Deanos,Highflyers]),(Klaus-Dieter,[Irish Pub,3Bar,Irish Pub]),(Klaus-Dieter,[Highflyers,Deanos,3Bar]),(Sebastian,[ ]) },
respectively.	2

Completeness
A sound and complete set of inference rules for FDs and MVDs has been provided in [9]. Natural extensions of the (sound and complete) rules from [36, p.80,81] are also sound in the presence of base, record and finite list types. Apart from these rules there is a further sound rule which allows to derive a non-trivial FD X → Y ⊓ Y C from an MVD X ։ Y . The following theorem was the main result of [29].

Theorem 4.6 The following set of inference rules



X → Y

Y ≤X
X → Y X → X ⊔ Y

(reflexivity axiom)	(extension rule)

X → Y, Y → Z


X → Z
X → Y X ։ Y

(transitivity rule)	(implication rule)

X ։ Y X ։ Y C
X ։ Y
V ≤W
W ⊔ X	V ⊔ Y

(Brouwerian-complement rule)	(multi-valued augmentation rule)

X ։ Y	Y ։ Z X ։ (Z−. Y )
X ։ Y	Y → Z X → (Z−. Y )

(pseudo-transitivity rule)	(mixed pseudo-transitivity rule)

X ։ Y	X ։ Z X ։ (Y ⊔ Z)
X ։ Y	X ։ Z X ։ (Z−. Y )

(multi-valued join rule)	(pseudo-difference rule)

X ։ Y


X → Y ⊓ Y C
X ։ Y	X ։ Z X ։ (Y ⊓ Z)

(mixed meet rule)	(multi-valued meet rule)
is sound and complete for the implication of FDs and MVDs on a nested attribute N in the presence of base, record and finite list types.	2
Note that reflexivity axiom, extension rule and transitivity rule form a sound and complete set of inference rules for the implication of FDs in the presence of base, record and finite list types (see [29]).
It is easy to see that all rules from Theorem 4.6 except the mixed meet rule are natural extensions of rules in the RDM (compare [36, p. 80,81]). Interpreting the mixed meet rule in relational databases means that the trivial FD X → ∅ can be derived from the MVD X ։ Y , and is therefore not needed.

Dependency Basis and Possessed Attributes
Definition 4.7 Let N ∈ N A. The subattribute basis SubB(N ) of N is the smallest set SubB(N ) ⊆ Sub(N ) such that for all X ∈ Sub(N ) we have
X = ⊔Z for some Z ⊆ SubB(N ). Every X ∈ SubB(N ) is called a basis

attribute for N . A basis attribute X ∈ SubB(N ) is called maximal if and only if X ≤ Y for some basis attribute Y ∈ SubB(N ) implies that X = Y holds. Basis attributes that are not maximal are called non-maximal. Let MaxB(N ) denote the set of maximal basis attributes, and non-MaxB(N) the set of non-maximal basis attributes.	2
Note that λ /∈ SubB(N ) since λ = ⊔∅, and SubB(N ) is not an anti-chain with respect to ≤. It is true that X = XCC ⊔ (X ⊓ XC) holds in every Brouwerian Algebra. A basis attribute Y ∈ SubB(N ) is maximal if and only if Y = Y CC holds, and non-maximal if and only if Y = Y ⊓ Y C holds.
Example 4.8 Let N = A(B, C[D(E, F [G])]). The subattribute basis is then
SubB(N ) = {A(B), A(C[λ]), A(C[D(F [λ])]), A(C[D(E)]), A(C[D(F [G])])}.
The maximal basis attributes are A(B), A(C[D(E)]) and A(C[D(F [G])]). The non-maximal basis attributes are A(C[λ]) and A(C[D(F [λ])]).	2
Consider the set of all Y with X ։ Y ∈ Σ+ for a fixed X defined on some nested attribute N . According to the multi-valued join, multi-valued meet and pseudo-difference rule this set, partially ordered by ≤, forms a Brouwerian Algebra. Due to the mixed meet rule, all basis attributes of Y which are not maximal in N are already functionally determined by X.
Definition 4.9 Let N ∈ N A, X ∈ Sub(N ) and Σ a set of multi-valued and functional dependencies on N . Let Dep(X) be the set of all Y ∈ Sub(N ) with X ։ Y ∈ Σ+ and X+ = ⊔{Y | X → Y ∈ Σ+}. Let XM ⊆ Sub(N ) have the following properties:
for all U ∈ MaxB(N ) there is a unique V ∈ XM with U ≤ V ,
for all U ∈ XM there is some W ⊆ MaxB(N ) with U = ⊔W ,
for all V ∈ Dep(X) there is some Z ⊆ XM with V CC = ⊔Z, and
XM is maximal with these properties with respect to ⊆gen.
The dependency basis of X with respect to Σ is DepB(X) = SubB(X+) ∪
XM .	2
Note that {MaxB(W ) | W ∈ XM } is the partition of MaxB(N ) which is generated by {MaxB(Y CC) | Y ∈ Dep(X)}. The first property says that every maximal basis attribute of N is the subattribute of exactly one element in XM . The second property guarantees that every element in XM is the join of maximal basis attributes of N . If X ։ V ∈ Σ+ holds, then the join of all basis attributes in V which are maximal in N (, i.e. V CC, ) is the join over elements of XM by property three. Finally, the last property guarantees the uniqueness of the dependency basis and that X ։ W ∈ Σ+ holds for all



K[L(M[N(A)])
K[L(M[N(B)])
K[L(C)]


Fig. 2. The subattribute basis of K[L(M [N (A, B)], C)]
W ∈ XM . An MVD X ։ Y is derivable from Σ iff the right-hand side Y is the join over some elements of the dependency basis of X with respect to Σ.
Proposition 4.10 Let N ∈ N A and Σ as set of FDs and MVDs on N. Then
X ։ Y ∈ Σ+ if and only if Y = ⊔Z for some Z ⊆ DepB(X)
X → Y ∈ Σ+ if and only if Y ≤ X+.	2
Proving the completeness result for FDs and MVDs involves the definition of some instance which satisfies all dependencies in Σ. This instance initially contains two elements t1, t2 which are coincident on exactly all attributes which are functionally determind by some fixed X. Afterwards new elements are generated and added to the instance by exhaustively combining values from t1 on some W ⊆ XM and the values from t2 on XM \W . Let W, W ′ ∈ XM . Since the meet W ⊓ W ′ is not necessarily equal to λ one needs to show that such a construction is possible in general. It will turn out that SubB(W ⊓ W ′) contains only attributes already functionally determined by X.
Definition 4.11 Let N ∈ N A, X′ ⊆ MaxB(N ) and X = ⊔X′. A basis attribute Y ∈ SubB(X) is possessed by X if and only if every basis attribute Z ∈ SubB(N ) with Y ≤ Z is also a subattribute of X (Z ≤ X).	2
It follows that SubB(W ⊓ W ′) with W, W ′ ∈ XM contains only basis attributes of W or W ′ which are neither possessed by W nor by W ′.
Example 4.12  Let K[L(M [N (A, B)], C)] ∈ N A, and X = K[L(M [N (A, B)])].
Then X does possess K[L(M [λ])], but does not possess K[λ]. For an illustra- tion see also Figure 2.
A basis attribute is not possessed by some X exactly if it is also a basis at- tribute of XC. According to the mixed meet rule it follows that basis attributes which are not possessed by some element in XM are functionally determined by X. Suppose DepB(X) = SubB(X+) ∪ {W0,1, . . . , W0,m, W1,  , Wk} with
W0,i ≤ X+ for i = 1, . . . , m and W1, . . . , Wk /≤ X+. We have seen that SubB(Wi ⊓ Wj), i /= j, contains only basis attributes of Wi or Wj neither possessed by Wi nor by Wj. It follows that X → Wi ⊓ Wj holds.
In summary, the construction is based on the relational theory for maximal basis attributes and the fact that non-maximal basis attributes not possessed

by any W ∈ XM are functionally determined by X.

Computing the Dependency Basis
Given a set Σ of dependencies from one of our classes, and a further depen- dency σ from the same class, the membership problem is to decide whether Σ |= σ holds. In view of Theorem 4.6, the membership problem is decidable for FDs and MVDs. That is, given some Σ, we can obviously enumerate all the dependencies that can be derived from it. However, the enumeration al- gorithm is time consuming and therefore impractical. We will now present an efficient membership algorithm for FDs and MVDs. Our main objective is the presentation of the algorithm, argue that it works correctly and in polynomial time. Implementation details are not discussed. Thus the time bound will only be a rough estimate of the upper bound.
Algorithm 5.1 (Attribute Set Closure and Dependency Basis) Input: N ∈ N A, X ∈ Sub(N ), set Σ of FDs and MVDs on N

Output: X+
and DepB
alg
(X)

Method:
VAR DBnew, DBold ⊆ MaxB(N ), Xnew, Xold
 ˜
, W, U, V , U

′ ∈ Sub(N );

Xnew := X;
DBnew := MaxB(XCC) ∪ {XC}; REPEAT
Xold := Xnew; DBold := DBnew;
FOR each U → V ∈ Σ DO
U := ⊔{W ∈ DBnew | ∃U ′.U ′ possessed by W, U ′ /≤ Xnew, U ′ ≤ U };
˜	. 
V := V −U ;
IF ˜ /= λ THEN BEGIN
Xnew := Xnew ⊔ ˜;
DBnew := {(W −. ˜)CC | W ∈ DBnew, (W −. ˜)CC /= λ} ∪ MaxB( ˜CC);
V	V	V
END; ENDDO;
FOR each U ։ V ∈ Σ DO
U := ⊔{W ∈ DBnew | ∃U ′.U ′ possessed by W, U ′ /≤ Xnew, U ′ ≤ U };
˜	. 
V := V −U ;
IF ˜ /= λ THEN BEGIN
Xnew := Xnew ⊔ ( ˜ ⊓ ˜C );

FOR each W ∈ DBnew DO
IF ( ˜ ⊓ W )CC /= λ AND ( ˜ ⊓ W )CC /= W THEN
DBnew := (DBnew − {W }) ∪ {( ˜ ⊓ W )CC, (W −. ˜)CC};
V	V
ENDDO; END;
ENDDO;
UNTIL (Xnew = Xold) AND (DBnew = DBold);

+
alg
:= Xnew;

DepBalg(X) := SubB(X+ ) ∪ DBnew;
RETURN(X+ , DepBalg(X));
2
In order to become more familiar with Algorithm 5.1 we present a simple example.
Example 5.1 Suppose the input for Algorithm 5.1 is as follows:
N = L1(L2[L3[L4(A, B, C)]], L5[L6(D, E)], L7(F, L8[L9(G, L10[H])], I)),
U1 = L1(L5[λ], L7(F, L8[L9(G)], I)), V1 = L1(L2[L3[L4(C)]], L5[L6(E)])],
U2 = L1(L2[L3[λ]], L7(F )), V2 = L1(L2[L3[L4(A)]], L7(L8[L9(G)], I)),
U3 = L1(L7(F, L8[L9(L10[λ])])), V3 = L1(L2[L3[λ]], L5[L6(D)]),
Σ = {U1 ։ V1, U2 → V2, U3 ։ V3} and X = L1(L7(F, L8[L9(L10[H])])).
After the initialization we have
Xnew = X
DBnew = {L1(L2[L3[L4(A, B, C)]], L5[L6(D, E)], L7(L8[L9(G)], I)); L1(L7(F ));
L1(L7(L8[L9(L10[H])]))}.
The initial state is illustrated in Figure 3. Functionally determined basis attributes are marked with a circle, remaining maximal basis attributes are boxed according to their membership.

B	G	H


L 3 [  ] 

L 2 [  ] 



L 5 [  ] 


L8 [  ]
  L 10 [ ]





 
 


Fig. 3. Initialisation for DepBalg(X)
The first pass through the REPEAT UNTIL loop yields the following in-

termediate results:
U2 → V2:
U = L1(L2[L3[L4(A, B, C)]], L5[L6(D, E)], L7(L8[L9(G)], I)),
˜
V = λ and therefore no changes
U1 ։ V1:
U = L1(L2[L3[L4(A, B, C)]], L5[L6(D, E)], L7(L8[L9(G)], I)),
˜
V = λ and therefore no changes
U3 ։ V3:
U = λ, ˜ = V3
Xnew = L1(L2[L3[λ]], L5[λ], L7(F, L8[L9(L10[H])]))
DBnew = {L1(L2[L3[L4(A, B, C)]], L5[L6(E)], L7(L8[L9(G)], I)); L1(L7(F ));
L1(L7(L8[L9(L10[H])])); L1(L5[L6(D)])}
The second pass through the REPEAT UNTIL loop yields the following intermediate results:
U2 → V2:
U = λ, ˜ = V2,
Xnew = L1(L2[L3[L4(A)]], L5[λ], L7(F, L8[L9(G, L10[H])], I)),
DBnew = {L1(L2[L3[L4(A)]]); L1(L7(L8[L9(G)])); L1(L7(I));
L1(L2[L3[L4(B, C)]], L5[L6(E)]); L1(L7(F )); L1(L7(L8[L9(L10[H])]));
L1(L5[L6(D)])}
U1 ։ V1:
U = λ, ˜ = V1,
Xnew = L1(L2[L3[L4(A)]], L5[λ], L7(F, L8[L9(G, L10[H])], I)),
DBnew = {L1(L2[L3[L4(A)]]); L1(L7(L8[L9(G)]));
L1(L7(I)); L1(L2[L3[L4(B)]]); L1(L2[L3[L4(C)]], L5[L6(E)]); L1(L7(F ));
L1(L7(L8[L9(L10[H])])); L1(L5[L6(D)])}
U3 ։ V3:
U = λ, ˜ = V3 and therefore no changes.
The next pass through the REPEAT UNTIL loop yields nothing new. We therefore have the output

•	+
alg
= L1(L2[L3[L4(A)]], L5[λ], L7(F, L8[L9(G, L10[H])], I)) and

DepBalg(X) = {L1(L2[λ]); L1(L2[L3[λ]]); L1(L2[L3[L4(A)]]); L1(L5[λ]);
L1(L7(F )); L1(L7(L8[λ])); L1(L7(L8[L9(G)])); L1(L7(L8[L9(L10[λ])]));
L1(L7(L8[L9(L10[H])])); L1(L7(I)); L1(L5[L6(D)]); L1(L2[L3[L4(B)]]);
L1(L2[L3[L4(C)]], L5[L6(E)])}.
Figure 4 illustrates DepBalg(X).	2




A	B	F	I	G	H


L 3 [  ] 

L 2 [  ] 



L 5 [  ] 


L8 [  ]
  L 10 [ ]




 
 


Fig. 4. Final State for DepBalg(X) from Example 5.1.
Correctness and Complexity
The correctness proof of Algorithm 5.1 is sketched, i.e., X+




= X+ and

DepBalg(X) = DepB(X). The first step is to show that the output of the algorithm admits only dependencies which can also be inferred.
Lemma 6.1  Let N ∈ N A, X ≤ N, Σ a set of FDs and MVDs on N and

DepBalg(X) = SubB(X+ ) ∪ XM
the output of Algorithm 5.1. Then

alg	alg
X ։ Wj ∈ Σ+ for all Wj ∈ DepBalg(X) and

•	+
alg
∈ Σ+ hold.

Proof. [sketch] The proof can be done by induction on the number of passes through the two outermost FOR loops of Algorithm 5.1.	2
Consider the proper chain Σ = Σ0 ⊂ Σ1 ⊂ Σn = Σ+ where Σi results from Σi−1 by adding exactly one functional or multi-valued dependency which is not in Σi−1 and can be derived by applying one of the inference rules from Theorem 4.6 to dependencies in Σi−1. On the way to showing the correctness of Algorithm 5.1 we have to justify that it is sufficient to consider FDs and MVDs in Σ. That is, we need to show that dependencies in Σ+\Σ do not alter the dependency basis. Suppose the algorithm does not only select U → V, U ։ V ∈ Σ within the two FOR loops, but all FDs and MVDs from some
fixed Σi instead. Denoting the respective output by (X+ , DepBalg,i(X)), we
define

i +
alg
=	{X → Y | Y ≤ X+ } ∪

{X ։ Y | Y = ⊔Z for some Z ⊆ DepBalg,i(X)}.

Then it is obvious that Σ+
= (Σ0)+
⊆ (Σ1)+
⊆ · · · ⊆ (Σn)+
holds.

The algorithm is designed in such a way that Σi ⊆ (Σi)+
holds for any i.

Furthermore, it can be shown that Σ+
= (Σ1)+
. It follows then immediately



that Σ+ ⊆ (Σn)+
+
alg
holds. Since also Σ+
⊆ Σ+ by Lemma 6.1 and

Proposition 4.10, we have indeed shown that Σ+ = Σ+.
Lemma 6.2 Σ+ = (Σ1)+
Proof. [sketch] Let N ∈ N A, X ≤ N and Σ a set of FDs and MVDs on N . One can show that the functional or multi-valued dependency in Σ1\Σ does not affect the output (X+ , DepBalg(X)) of Algorithm 5.1. Therefore, every inference rule from Theorem 4.6 needs to examined in turn.	2
Putting everything together we obtain the following result.
Theorem 6.3 Let N ∈ N A, X ≤ N and Σ a set of FDs and MVDs on N. Then Algorithm 5.1 always terminates and computes attribute set closure X+ and dependency basis DepB(X) for X with respect to Σ.
Proof. It remains to show the termination of Algorithm 5.1. After the ini- tialization and after each pass through the REPEAT UNTIL loop, the set MaxBasis={MaxB(Z) | Z ∈ DBnew} is a partition of MaxB(N ). Conse- quently, the number of sets in any such partition is at most | MaxB(N ) |, the number of maximal basis attributes of N . However, after each pass through the REPEAT UNTIL loop (except the last) the partition MaxBasis is refined, and the number of sets in it increases, or the number of elements in non- MaxB (Xnew) increases. It follows, that the REPEAT UNTIL loop is executed at most | SubB(N ) | = | MaxB(N ) | + | non-MaxB (N ) | times, and therefore the algorithm terminates.	2
We will now show that the membership problem of FDs and MVDs can be decided in polynomial time. When studying the time complexity of Algorithm
5.1 we consider nested attributes N as sets of attributes, i.e., instead of looking at N , we rather use SubB(N ). Let N ∈ N A, X ∈ Sub(N ) and Σ a set of FDs and MVDs on N be the input for Algorithm 5.1. We use | N | to denote the size of N , that is | N | is the number of basis attributes of N , i.e., | SubB(N ) |. It is relatively easy to see that SubB(X) and MaxB(X) can be computed in time O(| N |). Furthermore, the union and intersection of sets can be com- puted in time O(| N |) as well. Since SubB(X ⊔ Y ) = SubB(X) ∪ SubB(Y ) and SubB(X ⊓ Y ) = SubB(X) ∩ SubB(Y ), join and meet operation are lin- ear in | N |, as well. The pseudo-difference, and therefore the Brouwerian- complement operation as well, can be implemented in quadratic time:
SubB(X−. Y ) := SubB(X); FOR ALL A ∈ SubB(X) DO
IF A ∈ SubB(Y ) THEN SubB(X−. Y ) := SubB(X−. Y ) − {A};

ENDDO;
FOR ALL A ∈ SubB(X—. Y ) DO
SubB(X—. Y ) := SubB(X—. Y ) ∪ SubB(A); ENDDO;
, i.e., time 0(| N |2). Next, we will write down an algorithm which com- putes U := H{W ∈ DBnew | EU ′.U ′ is possessed by W, U ′ /≤ Xnew, U ′ ≤ U }. Recall that U ′ is possessed by some W ∈ DBnew if and only if U ′ ∈ SubB(W ) and U ′ ∈/ SubB(W C).

U := λ;
WHILE (SubB(U ) /= ∅) AND (DBnew /= ∅) DO SELECT U ′ ∈ SubB(U );
SubB(U ) := SubB(U ) — {U ′};
IF U ′ ∈/ SubB(Xnew) THEN FOR ALL W ∈ DBnew DO
IF (U ′ ∈ SubB(W )) AND (U ′ ∈/ SubB(W C)) THEN
U := U H W ;
DBnew := DBnew — {W }; ENDIF;
ENDDO; ENDIF;
ENDDO;

This demonstrates that U can be computed in time 0(| N |3). Let us now look at the time complexity to refine Xnew and DBnew, respectively.
First, consider the case where this refinement has been triggered by a func-
tional dependency U → V ∈ Σ. If ˜ /= λ, then Xnew := Xnew H ˜ which
takes time in 0(| N |). In order to compute DBnew := {(W —. ˜)CC | W ∈
DBnew, (W —. ˜)CC /= λ} ∪ MaxB( ˜CC), we need to compute (W —. ˜)CC in time
0(| N |2) for every W ∈ DBnew. Since DBnew has at most | MaxB(N ) |
elements, this takes time in 0(| N |3). Computing MaxB( ˜CC) and forming the union is in 0(| N |2). Consider now the case where the refinement is
triggered by some multi-valued dependency U ։ V ∈ Σ. If ˜ /= λ, then
Xnew := Xnew H ( ˜ H ˜C) which takes time in 0(| N |2). As the computation

of ( ˜
V	V
CC	. ˜ CC	2

the refinement of DBnew takes 0(| N |3) steps.
It follows that each pass through the REPEAT UNTIL loop takes time in 0(| N |3 · | Σ |). As we have seen before, the REPEAT UNTIL loop is executed at most | N | times. Therefore, the time complexity of Algorithm

5.1 is 0(| N |4 · | Σ |).
Theorem 6.4 Let N ∈ N A, Σ a set of FDs and MVDs on N and σ an FD or MVD on N. The membership problem whether Σ |= σ holds can be decided in time 0(| N |4 · | Σ |).
Proof. Let σ be the FD X → Y . Algorithm 5.1 computes the attribute set closure X+ in time 0(| N |4 · | Σ |). It follows that Σ |= X → Y if and only if Y ≤ X+ according to Proposition 4.10. To decide whether Y ≤ X+ holds takes time in 0(| N |).
Let σ be the MVD X ։ Y . Algorithm 5.1 computes the dependency basis DepB(X) = SubB(X+) ∪ XM in time 0(| N |4 · | Σ |). It follows that Σ |= X ։ Y if and only if Y = HZ for some Z ⊆ DepB(X) according to Proposition 4.10. To decide whether Y is the join of some elements in DepB(X) takes time in 0(| N |2). This proves the theorem.	2
7	Conclusion and Future Work
FDs and MVDs have proven significance for the logical design of relational databases (see [2,7,8,13,15,16,21,22,23,24,36,41,45]). We have continued study- ing the class of FDs and MVDs in databases supporting base, record and finite list types. In [29] a sound and complete set of inference rules for the implica- tion of FDs and MVDs has been presented, generalising the set of inference rules from [9] for the RDM. Based on this axiomatisation a membership algo- rithm, deciding the finite implication problem for FDs and MVDs with base, record and finite list types, has been presented in this article. This member- ship algorithm is a natural extension of Beeri’s algorithm from [6] for relational databases. It was argued that the algorithm works correctly and runs in poly- nomial time. This shows that the membership problem can still be solved efficiently when complex data types are present in databases. The results also show that the approach based on types and nested attributes pays off for the development of a unified dependency theory for advanced data models.
Derivations not using the Brouwerian-complement rule are of particular interest, see for instance [6] for an explanation why the complementation rule is of particular interest in the RDM. In the relational case it is possible to decide in polynomial time whether a given FD or MVD can be derived from a given set of FDs and MVDs without using the complementation rule. We are confident that this decision procedure can be extended to databases supporting various types.
The inference rules from Theorem 4.6 are expected to be redundant. A detailed study of minimal sets of inference rules, in the sense that any proper

subset will not be complete anymore, was outside the scope of this paper. It might help to simplify the lengthy correctness proof for Algorithm 5.1. Results similar to [14,32] are expected.
There are many ways of continuing our research. For the future, we would like to explore richer type systems containing sets, multisets, unions and even references leading to rational trees. The class of FDs in the presence of base, record and finite set types has already been studied in [27] and has led to a more sophisticated set of inference rules since the extension rule is no longer valid in the presence of sets. We have also looked at extending this result to lists and multisets. FDs can be quite easily captured in the presence of base, record and finite list types only. On the other hand, MVDs show an interesting behaviour in the presence of finite set types, in the sense that Theorem 4.4 is no longer valid. That is MVDs deviate from binary join dependencies.
The main objective is of course the study of normal forms for nested at- tributes which guarantee well-designed databases. The desirable goal would be a theory extending the results from [45] to databases supporting various types. The start for this research has already been made in [27] where the Higher Level normal form has been proposed as a strictly weaker normal form than Boyce-Codd normal form. For the class of FDs in the presence of base, record and finite set types, this normal form has been proven equivalent to the absence of redundancies and sufficient for the absence of abnormal up- date behaviour. We would like to generalise the fourth normal form on the basis of several type systems and semantically justify these generalisations. The membership problem presented in this article will then be very useful for eliminating redundancies.
In the future, various other classes of relational dependencies (see [41]), including join dependencies and inclusion dependencies, together with their interactions should be studied with respect to various type systems.

References
Abiteboul, S., P. Buneman and D. Suciu, Data on the Web: From Relations to Semistructured Data and XML. Morgan Kaufmann Publishers, 2000.
Abiteboul, S., R. Hull and V. Vianu, Foundations of Databases. Addison-Wesley, 1995.
Arenas, M. and L. Libkin, A normal form for XML documents. In PODS 2002. ACM, 2002.
Armstrong, W. W., Dependency structures of database relationships. Information Processing, pages 580–583, 1974.
Batini, C., S. Ceri and S. B. Navathe, Conceptual Database Design: An Entity-Relationship Approach. Benjamin Cummings, 1992.
Beeri, C., On the membership problem for functional and multivalued dependencies in relational databases. Transactions on Database Systems, 5(3):241–259, 1980.


Beeri, C. and P. A. Bernstein, Computational problems related to the design of normal form relational schemata. In Transactions on Database Systems, pages 30–59. Association for Computing Machinery, 1979.
Beeri, C., P. A. Bernstein and N. Goodman, A sophisticate’s introduction to database normalization theory. In Proceedings of 4th International Conference on Very Large Databases, pages 113–124, 1978.
Beeri, C., R. Fagin and J. H. Howard, A complete axiomatization for functional and multivalued dependencies in database relations. In Proceedings of the International Conference on Management of Data, pages 47–61. Association for Computing Machinery, 1977.
Beeri, C., A. Mendelzon, Y. Sagiv and J. Ullman, Equivalence of relational database schemes.
SIAM Hournal on Computation, 10:647–656, 1981.
Beeri, C. and J. Rissanen, Faithful representation of relational database schemes. IBM Research Report, San Jose, 1980.
Bernstein, P., Synthesizing third normal form relations from functional dependencies. ACM Transactions on Database Systems, 1:277–298, 1976.
Bernstein, P. A. and N. Goodman, What does Boyce-Codd normal form do? In Proceedings of the International Conference on Very Large Databases, pages 245–259, 1980.
Biskup, J., On the complementation rule for multivalued dependencies in database relations.
Acta Informatica, 10(3):297–305, 1978.
Biskup, J. Database schema design theory:achievements and challenges. In Proceedings of the 6th International Conference on Information Systems and Management of Data, number 1066 in Lecture Notes in Computer Science, pages 14–44. Springer, 1995.
Biskup, J. Achievements of relational database schema design theory revisited. In Semantics in databases, number 1358 in Lecture Notes in Comptuer Science, pages 29–54. Springer, 1998.
Bry, F. and P. Kr¨oger, A computational biology database digest: data, data analysis, and data management. Distributed and Parallel Databases, 13(1):7–42, 2003.
Chen, P. P., The entity-relationship model: Towards a unified view of data. ACM Transactions Database Systems 1, pages 9–36, 1976.
Chen, P. P., English sentence structure and entity-relationship diagrams. Information Science 29, pages 127–149, 1983.
Codd, E. F., A relational model of data for large shared data banks. Communications of the ACM, pages 377–387, 1970.
Codd, E. F., Further normalization of the database relational model. In Courant Computer Science Symposia 6: Data Base Systems, pages 33–64. Prentice-Hall, 1972.
Codd, E. F., Recent investigations in relational database system. In Proceedings of the IFIP Conference, pages 1017–1021, 1974.
Fagin, R.,	Multivalued dependencies and a new normal form for relational databases.
Association for Computing Machinery, 2(3):262–278, 1977.
Fagin, R.,  A normal form for relational databases that is based on domains and keys.
Transactions on Database Systems, pages 387–415, 1981.
Gardarin, G., J.-P. Cheiney, G. Kiernan, D. Pastre and H. Stora, Managing complex objects in an extensible relational dbms. In Proceedings of the Fifteenth International Conference on Very Large Data Bases, August 22-25, 1989, Amsterdam, The Netherlands, pages 55–65. Morgan Kaufmann, 1989.
Hartmann, S. and S. Link, More functional dependencies for XML. In Advances in Databases and Information Systems, volume 2798, pages 355–369. Springer Lecture Notes in Computer Science, 2003.


Hartmann, S. and S. Link, On functional dependencies in advanced data models. Electronic Notes in Theoretical Computer Science, 84, 2003.
Hartmann, S., S. Link and K.-D. Schewe, Generalizing Boyce-Codd normal form to conceptual databases. In Pre-Proceedings of the 13th European-Japanese Conference on Information Modeling and Knowledge Bases, pages 93–110, 2003.
Hartmann, S., S. Link and K.-D. Schewe, Reasoning about functional and multi-valued dependencies in the presence of lists. In Proceedings of Third International Symposium on Foundations of Information and Knowledge Systems, Vienna, Austria. Springer Lecture Notes in Computer Science, 2004.
Hull, R. and R. King, Semantic database modeling: Survey, applications and research issues.
ACM Computing Surveys, 19(3), 1987.
McKinsey, J. and A. Tarski, On closed elements in closure algebras. Annals of Mathematics, 47:122–146, 1946.
Mendelzon, A., On axiomatising multivalued dependencies in relational databases. Journal of the ACM, 26(1):37–44, 1979.
Mok, W. Y., Y. K. Ng and D. W. Embley, A normal form for precisely charachterizing redundancy in nested relations. Transactions on Database Systems, 21:77–106, 1996.
Naqvi, S. and S. Tsur, A logical language for data and knowledge bases. Computer Science Press, 1989.
O¨ zsoyoglu, Z. M. and L. Y. Yuan, A new normal form for nested relations. Transactions on Database Systems, 12:111–136, 1987.
Paredaens,J., P. De Bra, M. Gyssens and D. Van Gucht, The Structure of the Relational Database Model. Springer-Verlag, 1989.
Richardson, J., Supporting lists in a datamodel. In Proceeding of VLDB, pages 127–192, 1992.
Schewe, K. D. and B. Thalheim, Fundamental concepts of object oriented databases. Acta Cybernetica, 11(4):49–85, 1993.
Seshadri, P., M. Livny and R. Ramakrishnan, The design and implementation of sequence database system. In Proceedings of the Twentysecond International Conference on Very Large Data Bases, Mumbai, India, 1996.
Tari, Z., J. Stokes and S. Spaccapietra, Object normal forms and dependency constraints for object-oriented schemata. ACM ToDS, 22:513–569, 1997.
Thalheim, B., Dependencies in Relational Databases. Teubner-Verlag, 1991.
Thalheim, B. Foundations of entity-relationship modeling. Annals of Mathematics and Artificial Intelligence, 6:197–256, 1992.
Thalheim, B., Entity-Relationship Modeling: Foundations of Database Technology. Springer- Verlag, 2000.
Tjoa, A. M. and L. Berger, Transformation of requirement specifications expressed in natural language into an eer model. In Entity-Relationship Approach, volume 823. Springer Lecture Notes Series, 1993.
Vincent, M., The semantic justification for normal forms in relational database design. PhD thesis, Monash University, Melbourne, Australia, 1994.
Vincent, M., J. Liu and C. Liu, A redundancy free 4nf for XML. In XML Database Symposium, 2003.
W3C. Xml schema part 2: Datatypes. http://www.w3.org/TR/xmlschema-2/#datatype, 2001.
