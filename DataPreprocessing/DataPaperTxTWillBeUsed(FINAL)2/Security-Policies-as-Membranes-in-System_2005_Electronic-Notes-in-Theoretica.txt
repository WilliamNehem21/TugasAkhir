Electronic Notes in Theoretical Computer Science 138 (2005) 23–42	
www.elsevier.com/locate/entcs

Security Policies as Membranes in Systems for Global Computing 1
Daniele Gorla2
Dip. di Informatica, Univ. di Roma “La Sapienza”, Italy Dip. di Sistemi ed Informatica, Univ. di Firenze, Italy
Matthew Hennessy3
Dep. of Informatics, Univ. of Sussex, Brighton (UK)
Vladimiro Sassone4
Dep. of Informatics, Univ. of Sussex, Brighton (UK)

Abstract
We propose a simple global computing framework, whose main concern is code migration. Systems are structured in sites, and each site is divided into two parts: a computing body, and a membrane which regulates the interactions between the computing body and the external environment. More precisely, membranes are filters which control access to the associated site, and they also rely on the well-established notion of trust between sites. We develop a basic theory to express and enforce security policies via membranes. Initially, these only control the actions incoming agents intend to perform locally. We then adapt the basic theory to encompass more sophisticated policies, where the number of actions an agent wants to perform, and also their order, are considered.
Keywords: Global Computing, Code Migration, Access Control, Security Policies, Types.


1 This work has been partially supported by EU FET – Global Computing initiative, projects MIKADO IST-2001-32222 and MyThS IST-2001-32617. The funding bodies are not responsible for any use that might be made of the results presented here.
2 Email: gorla@di.uniroma1.it
3 Email: matthewh@susx.ac.uk
4 Email: vs@susx.ac.uk




1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.05.003

Introduction

Computing is increasingly characterised by the global scale of applications and the ubiquity of interactions between mobile components. Among the main features of the forthcoming “global ubiquitous computing” paradigm we list distribution and location awarness, whereby code located at specific sites acts appropriately to local parameters and circumstances, that is, it is “context- aware”; mobility, whereby code is dispatched from site to site to increase flexibility and expressivity; openness, reflecting the nature of global networks and embodying the permeating hypothesis of localised, partial knowledge of the execution environment. Such systems present enormous difficulties, both technical and conceptual, and are currently more at the stage of exciting future prospectives than that of established of engineering practice. Two concerns, however, appear to clearly have a ever-reaching import: security and mobility control, arising respectively from openness and from massive code and resource migrations. They are the focus of the present paper.
We aim at classifying mobile components according to their behaviour, and at empowering sites with control capabilities which allow them to deny access to those agents whose behaviour does not conform to the site’s policy.
We see every site of a system
k[[ M |⟩ P ]]
as an entity named k and structured in two layers: a computing body P , where programs run their code – possibly accessing local resources offered by the site – and a membrane M, which regulates the interactions between the computing body and the external environment. An agent P wishing to enter a site N must be verified by the membrane before it is given a chance to execute in N. If the preliminary check succeeds, the agent is allowed to execute, otherwise it is rejected. In other words, a membrane implements the policy each site wants to enforce locally, by ruling on the requests of access of the incoming agents. This can be easily expressed by a migration rule of the form:
k[[ Mk |⟩ gol.P | Q ]]  l[[ Ml |⟩ R ]] → k[[ Mk |⟩ Q ]]  l[[ Ml |⟩ P | R ]]	if Ml ▶k P
The relevant parts here are P , the agent wishing to migrate from k to l, and l, the receiving site, which needs to be satisfied that P ’s behaviour complies with its policy. The latter is expressed by l’s membrane, Ml. The judgement Ml ▶k P represents l inspecting the incoming code to verify that it upholds Ml.

Observe that in the formulation above Ml ▶k P represent a runtime check of all incoming agents. Because of our fundamental assumption of openended- ness, such kind of checks, undesirable as they, cannot be avoided. In order to reduce their impact on systems performance, and to make the runtime seman- tics as efficient as possible, we adopt a strategy which allows for efficient agent verification. Precisely, we adopt an elementary notion of trust, so that from the point of view of each l the set of sites is consistently partitioned between “good,” “bad,” and “unknown” sites. Then, in a situation like the one in the rule above, we assume that l will be willing to accept from a trusted site k a k-certiﬁed digest T of P ’s behaviour. We then modify the primitive go and the judgement ▶k as in the refined migration rule below.
k[[ Mk |⟩ goTl.P | Q]]  l[[ Ml |⟩ R]] → k[[ Mk |⟩ Q]]  l[[ Ml |⟩ P | R]]	if Ml ▶k P

The notable difference is in Ml ▶k
P . Here, l verifies the entire code P against

Ml only if it does not trust k, the signer of P ’s certificate T. Otherwise, it suffices for l to match Ml against the digest T carried by go together with P from k, so effectively shifting work from l to the originator of P .
Our main concern in this paper is to put the focus on the machinery a membrane should implement to enforce different kinds of policies. We first distill the simplest calculus which can conceivably convey our ideas and still support a non-trivial study. It is important to remark that we are abstracting from agents’ local computations. These can be expressed in any of several well- known models for concurrency, for example CCS [13] or the π–calculus [14]. We are concerned, instead, with agents’ migration from site to site: our main language mechanism is go rather than intra-site (i.e. local) communication. Using this language, we examine four notions of policy and show how they can be enforced by using membranes. We start with an amusingly simple policy which only lists allowed actions. We then move to count action occurrences and then to policies expressed by deterministic ﬁnite automata. Note that such policies are only concerned with the behaviour of single agents, and do not take into account “coalitional ” behaviours, whereby incoming agents – apparently innocent – join clusters of resident agents – they too apparently innocent – to perform cooperatively potentially harmful actions, or at least overrule the host site’s policy. We call resident those policies intended to be applied to the joint, composite behaviour of the agents contained at a site. We explore resident policies as our fourth and final notion of policy. In all the cases, the theory adapts smoothly to the various cases; we only need to refine the information stored in the membrane and the inspection mechanisms.
Structure of the paper.  In Section 2 we define the calculus used in this

Agents	P, Q, R	::=	nil  a.P	 goTl.P	 P |Q  !P
Systems	N	::=	0  l[[ M |⟩ P ]]  N1  N2

Fig. 1. A Simple Calculus
paper, and start with the straightforward policy which only prescribes the actions an agent can perform when running in a site. In Section 3, we enhance the theory to control also how many (and not only which kind of) actions an agent wants to perform in a site, and their order of execution. Finally, in Section 4 we extend the theory to control the overall computation taking place at a site, and not only the behaviour of single agents. The paper concludes in Section 5 where a comparison with related work is also given. The theoretical results are proved in the full paper [8].

A Simple Calculus
In this section we describe a simple calculus for mobile agents, which may migrate between sites. Each site is guarded by a membrane, whose task is to ensure that every agent accepted at the site conforms to an entry policy.

The Syntax
The syntax is given in Figure 1 and assumes two pairwise disjoint sets: basic agent actions Act, ranged over by a, b, c, ··· , and localities Loc, ranged over by l, k, h, ··· . Agents are constructed using the standard action-prefixing, parallel composition and replication operators from process calculi, [13]. The one novel operator is that for migration, goTl.P . This agent seeks to migrate to site l in order to execute the code P ; moreover it promises to conform to the entry policy T. In practical terms this might consist of a certification that the incoming code P conforms to the policy T, which the site l has to decide whether or not to accept. In our framework, this certification is a policy that describes the (local) behaviour of the agent; thus, in goTl.P , T will be called the digest of P .
A system consists of a finite set of sites running in parallel. A site takes the form l[[ M |⟩ P ]], where l is the site name, P is the code currently running at l, and M is the membrane which implements the entry policy. For convenience we assume that site names are unique in systems. Thus, in a given system we can identify the membrane associated with the site named l by Ml. We start with a very simple kind of policy, which we will then progressively enhance.

Definition 2.1 [Policies] A policy is any finite subset of Act ∪ Loc. For two policies T1 and T2, we write T1 enforces T2 whenever T1 ⊆ T2.
Intuitively an agent conforms to a policy T at a given site if every action it performs at the site is contained in T, and it will only migrate to sites whose names are in T. For example, conforming to the policy {info, req, home}, where info, req are actions and home a location, means that the only actions that will be performed are from the set {info, req} and migration will only occur, if at all, to the site home. With this interpretation of policies, our definition of the predicate enforces is also intuitive; if some code P conforms to the policy T1 and T1 enforces T2 then P also automatically conforms to T2.
The purpose of membranes is to enforce such policies on incoming agents. In other words, at a site l[[M |⟩Q ] wishing to enforce a policy Tin, the membrane M has to decide when to allow entry to an agent such as goTl.P from another site. There are two possibilities.
The first is to syntactically check the code P against the policy Tin; an implementation would actually expect the agent to arrive with a proof of this fact, and this proof would be checked.
The second would be to trust the agent that its code P conforms to the stated T and therefore only check that this conforms to the entry policy Tin. Assuming that checking one policy against another is more efficient than the code analysis, this would make entry formalities much easier.
Deciding on when to apply the second possibility presupposes a trust man- agement framework for systems, which is the topic of much current research. To simplify matters, here we simply assume that each site contains, as part of its membrane, a record of the level of trust it has in other sites. Moreover, we assume only three possible levels: lbad, loc and lgood.
Definition 2.2 [Membranes] A membrane M is a pair (Mt, Mp) where Mt is a partial function from Loc to {loc, lgood, lbad}, and Mp is a policy.

The Operational Semantics
Having defined both policies and membranes, we now give an operational semantics for the calculus, which formalises the above discussion of how to manage agent migration. This is given as a binary relation N → N' over sys- tems; it is defined to be the least relation which satisfies the rules in Figure 2. Rule (r-act) says that the agent a.P running in parallel with other code in site l, such as Q, can perform the action a; note that the semantics does

(r-act)	l[[ M |⟩ a.P | Q ]] → l[[ M |⟩ P | Q ]]
N1 → N'

(r-par)

(r-struct)
N1  N2 → N'
N ≡ N1	N1 → N'
N → N'

 N2
N' ≡ N'

(r-mig)	k[[ Mk |⟩ goTl.P | Q ]]  l[[ Ml |⟩ R ]]	→
k[[ Mk |⟩ Q ]]	l[[ Ml |⟩ P | R ]]	if Ml ▶k P


Fig. 2. The reduction relation
not record the occurrence of a. (r-par) and (r-struct) are standard. The first allows reductions within parallel components, while the second says that reductions are relative to a structural equivalence. The precise rules defin- ing this equivalence are unsurprising and therefore left to the full paper [8]; they state that ‘|’ and ‘  ’ are monoidal operators (with nil and 0 acting as identities, resp.), and that replicated processes can be freely unfolded. The interesting reduction rule is the last one, (r-mig), governing migration; the
agent goTl.P can migrate from site k to site l provided the predicate Ml ▶k P
is true. This ‘enabling’ predicate formalises our discussion above on the role
of the membrane Ml, and requires in turn a notion of code P satisfying a policy T,

▶ P : T
With such a notion, we can then define Ml ▶k

P to be:

if Ml(k)= lgood then (T enforces Ml ) else ▶ P : Ml	(1)
t	p	p
In other words, if the target site l trusts the source site k, it trusts that the professed policy T is a faithful reflection of the behaviour of the incoming agent P , and then entry is gained provided that T enforces the entry policy
Ml (i.e., in this case, T ⊆ Ml ). Otherwise, if k can not be trusted, then the
p	p
entire incoming code P has to be checked to ensure that it conforms to the
entry policy, as expressed by the predicate ▶ P : Ml .
In Figure 3 we describe a simple inference system for checking that agents conform to policies, i.e. to infer judgements of the form ▶ P : T. Rule (tc-empty) simply says that the empty agent nil satisfies all policies. (tc-act) is also straightforward; a.P satisfies a policy T and if a is allowed by T, and the residual P satisfies T. The rule (tc-par) says that to check




(tc-empty)
(tc-act)
▶ P : T
(tc-mig)
▶ P : T'
(tc-repl)
▶ P : T
(tc-par)
▶ P : T	▶ Q : T

▶ nil : T
a ∈ T
▶ a.P : T
▶ goT'
l ∈ T
l.P : T


▶ !P : T


▶ P | Q : T


Fig. 3. Typechecking incoming agents
P | Q it is sufficient to check P and Q separately, and similarly for replicated agents. The most interesting rule is (tc-mig), which checks goT' l.P . This not only checks that migration to l is allowed by the policy, that is l ∈ T, but it also checks that the code to be spawned there, P , conforms to the associated professed policy T'. In some sense, if the agent goT' l.P is allowed a entry into a site k, then k assumes responsibility for any promises that it makes about conformance to policies.
Safety
We have just outlined a reduction semantics in which sites seek to enforce policies either by directly checking the code of incoming agents against entry policies, or more simply by checking the professed policy of trusted agents. The extent to which this strategy works depends, not surprisingly, on the quality of a site’s trust management.
Example 2.3 Let home be a site name with the following trust function

h t
Consider the system
: {alice, bob, secure}	'→	lgood .



S = home[[M
h|⟩P
h]]	bob[[Mb
|⟩P
b]]	alice[[M
a |⟩P
a]]	secure[[M
s|⟩P
s]]

in which the entry policy of home, Mh, is {info, req, secure}, and that of
secure, Ms, is {give, home}. Since Mh(bob) = lgood, agents migrating
p	t
from bob to home are trusted and only their digests are checked against the entry policy Mh. So, if Pb contains the agent
goT1 home.(take.Q)
where T1 enforces Mh, then the entry policy of home will be transgressed. The problem in this example is that the trust knowledge of home is faulty;
it trusts in sites which do not properly ensure that professed policies are en-
forced. Let us divide the sites into trustworthy and otherwise. This biparti- tion could be stored in an external record stating which nodes are trustworthy




(wf-empty)
▶ 0 : ok
(wf-g.site)
▶ P : Mp
▶ l[[ M |⟩ P ]] : ok

l trustworthy



(wf-par)
 ▶ N1 : ok,	▶ N2 : ok 
▶ N1  N2 : ok
(wf-u.site)

▶ l[[ M |⟩ P ]] : ok

l not trustworthy

Fig. 4. Well-formed systems
(i.e. typechecked) and which ones are not. However, for economy, we prefer to record this information in the membranes, by demanding that the trust knowledge at trustworthy sites is a proper reflection of this division. This is more easily defined if we assume the following ordering over trust levels:
loc <: lbad	and	loc <: lgood
This reflects the intuitive idea that sites classified as loc may, perhaps with further information, be subsequently classified either as lgood or lbad. On the other hand, lgood or lbad cannot be further refined; sites classified as either, will not be reclassified.
Definition 2.4 [Trustworthy sites and Coherent systems] In a system N, we say the site k is trustworthy if Mk(k) = lgood. N is coherent if for every
trustworthy site k, it holds that Mk(l) <: Ml(l).
t	t
Thus, if a trustworthy site k believes that a site l can be trusted (i.e.,
Mk(l) = lgood), then l is indeed trustworthy (as represented by Ml(l) =
t	t
lgood). Similarly, if it believes l to be lbad, then l is indeed bad. The only
uncertainty is when k classifies l as loc: then l may be either lgood or lbad. Of course, in coherent systems we expect sites which have been classified as trustworthy to act in a trustworthy manner, which amounts to say that code running at such a k must have at one time gained entry there by satisfying the entry policy. Note that by using policies as in Definition 2.1, if P satisfies an entry policy Mk, then it continues to satisfy the policy while running at k (cf. Theorem 2.7 below).
This property of coherent systems, which we call well-formedness, can therefore be checked syntactically. In Figure 4, we give the set of rules for deriving the judgement ▶ N : ok, of well-formedness of N. There are only two interesting rules. Firstly, (wf-g.site) says that l[[ M |⟩ P ] is well-formed whenever l is trustworthy and ▶ P : Mp. There is a subtlety here; this not only means that P conforms to the policy Mp, but also that any digests proffered by agents in P can also be trusted. The second relevant rule is (wf-u.site),


(lts-repl)	(lts-par)

(lts-act)
(lts-mig)
P | !P →α P '
P  →α P '

	1	1	

a.P →a P
goT
l.P →l
nil
!P →α  P '
P1 | P2 → P ' | P2

P2 | P1 → P2 | P '

Fig. 5. A Labelled Transition System
for typing unknown sites: here there is no need to check the resident code, as agents emigrating from such sites will not be trusted.
Example 2.5 (Example 2.3 continued.) Let us now re-examine the system S in Example 2.3. Suppose home is trustworthy, that is Mh(home) = lgood. Then, if S is to be coherent, it is necessary for each of the sites bob, alice and secure also to be trustworthy. Consequently, S can not be well-formed. For example, to derive ▶ S : ok it would be necessary to derive
▶ goT1 home.(take.Q): M
b

where Mb is the entry policy of bob.	But this requires the judgement ▶
take.Q : T1, where T1 enforces Mh. Since take /∈ Mh, this is not possible.
In well-formed systems we know that entry policies have been respected. So one way of demonstrating that our reduction strategy correctly enforces these policies is to prove two things: system well-formedness is preserved by reduction, and only legal computations take place within trustworthy sites. The first requirement is straightforward to formalize:
Theorem 2.6 (Subject Reduction) If ▶ N : ok and N → N', then ▶ N' :
ok.
To formalise the second requirement we need some notion of the compu- tations of an agent. With this in mind, we first define a labelled transition system between agents, which details the immediate actions an agent can per-
form, and the residual of those actions. The rules for the judgements P →α Q,
where we let α to range over Act ∪ Loc, are given in Figure 5, and are all
straightforward. These judgements are then extended to P →σ Q, where σ
ranges over (Act ∪ Loc)∗, in the standard manner: σ = α1,... , αk, when

there exists P ,...,P 
such that P = P
→α1
αk
...	P
= P '. Finally, let

0	k	0	→	k
act(σ) denote the set of all elements of Act ∪ Loc in σ.
Theorem 2.7 (Safety) Let N be a well-formed system.	Then, for every
trustworthy site l[[ M |⟩ P ]] in N, P →σ  P ' implies that act(σ) enforces M .
p

Entry Policies
The calculus of the previous section is based on a simple notion of entry policies, namely finite sets of actions and location names. An agent conforms to such a policy T at a site if it only executes actions in T before migrating to some location in T. However both the syntax and the semantics of the calculus are completely parametric on policies. All that is required of the collection of policies is a binary relation T1 enforces T2 between them, and a binary relation ▶ P : T indicating that the code P conforms to the policy T. With any collection of policies, endowed with two such relations, we can define the

predicate M ▶k
P as in (1) above, and thereby get a reduction semantics for

the calculus. In this section we investigate two variations on the notion of entry policies and discuss the extent to which we can prove that the reduction strategy correctly implements them.
Multisets as Entry Policies
The policies of the previous section only express the legal actions agents may perform at a site. However in many situations more restrictive policies are desirable. To clarify this point, consider the following example.
Example 3.1 Let mail serv be the site name of a mail server with the fol- lowing entry policy Mms: {list, send, retr, del, reset, quit}. The server accepts client agents performing requests for listing mail messages, send- ing/retrieving/deleting messages, resetting the mailbox and quitting. Now, consider the system


S = mail serv[[ Mms
|⟩ P ms
]]	spam[[ Ms
|⟩ goTmail serv.(!send) ]]

where T = {send}. According to the typechecking of Figure 3, we have that
▶ ! send : Mms. However, the agent is a spamming virus and, in practical implementations, should be rejected by mail serv.
In such scenarios it would be more suitable for policies to be able to fix an upper-bound over the number of messages sent. This can be achieved in our setting by changing policies from sets of agent actions to multisets of actions. First let us fix some notation. We can view a multiset as a set equipped with an occurrence function, that associates a natural number to each element of the set. To model permanent resources, we also allow the occurrence func- tion to associate ω to an element with an infinite number of occurrences in the multiset. Notationally, eω stands for an element e occurring infinitely many times in a multiset. This notation is extended to sets; for any set E, we let
Eω to denote the multiset {eω : e ∈ E}.








1	2

Fig. 6. Typechecking with policies as Multisets

Example 3.2 (Example 3.1 continued.) Coming back to Example 3.1, it would be sufficient to define Mms to be {... , sendK,.. .} where K is a rea- sonable constant. In this way, an agent can only send at most K messages in each session; if it wants to send more messages, it has to disconnect from mail serv (i.e. leave it) and then reconnect again (i.e. immigrate again later on).
The theory presented in Sections 2.2 and 2.3 can be adapted to the case where policies are multisets of actions. The judgment ▶ P : T is redefined in Figure 6, where operator ∪ stands for multiset union. The key rules are (tc-act), (tc-par) and (tc-repl). The first two properly decrease the type satisfied when typechecking sub-agents. The third one is needed because re- cursive agents can be, in general, freely unfolded; hence, the actions they in- tend to locally perform can be iterated arbitrarily many times. For instance,

Δ
agent P = !
Δ
send, satisfies policy T =
{sendω}. Notice that the new pol-

icy satisfaction judgement prevents the spamming virus of Example 3.1 from
typechecking against the policy of mail serv defined in Example 3.2.
The analysis of the previous section can also be repeated here but an appropriate notion of well-formed system is more difficult to formulate. The basic problem stems from the difference between entry policies and resident policies. The fact that all agents who have ever entered a site l respects an entry policy Mp gives no guarantees as to whether the joint effect with the code currently occupying the site l also satisfies Mp. For instance, in the terms of Example 3.2, mail serv ensures that each incoming agent can only send at most K messages. Nevertheless, two such agents, having gained entry and now running concurrently at mail serv, can legally send – jointly – up to 2K messages. It is therefore necessary to formulate well-formedness in terms of the individual threads of the code currently executing at a site. Let us say P is a thread if it is not of the form P1 | P2. Note that every agent P can be written in the form of P1| ... |Pn,n ≥ 1, where each Pi is a thread.

So the well-formedness judgment is modified by replacing rule (wf-g.site) in Figure 4 as below.
(wf-g.sitem)
∀i. (Pi a thread and	▶ Pi : Mp) l trustworthy
▶ l[[ M |⟩ P1| ... |Pn ]] : ok
Theorem 3.3 (Subject Reduction for multiset policies) If ▶ N  : ok
and N → N', then ▶ N' : ok.
The statement of safety must be changed to reflect the focus on individual threads rather than agents.
Theorem 3.4 (Safety for multiset policies) Let N be a well-formed sys- tem. Then, for every trustworthy site l[[ M |⟩ P1| ... |Pn ]] in N, where each Pi
is a thread, P →σ  P ' implies that act(σ) enforces M .
i	i	p
Finite Automata as Entry Policies
A second limitation of the setting presented in Section 2 is that policies will sometimes need to prescribe a precise order for executing legal actions. This is very common in client/server interactions, where a precise protocol (i.e. a pattern of message exchange) must be respected. To this aim, we define policies as deterministic ﬁnite automata (DFAs, for short).
Example 3.5 Let us consider Example 3.1 again. Usually, mail servers re- quires a preliminary authentication phase to give access to mail services. To express this fact, we could implement the entry policy of mail serv, Mms, to
be the automaton associated to the regular expression below.
usr.pwd.(list + send + retr + del + reset)∗.quit
The server accepts client requests only upon authentication, via a user- name/password mechanism. Moreover, the policy imposes that each session is regularly committed by imposing that each sequence of actions is terminated by quit. This could be required to save the status of the transaction and avoid inconsistencies.
We now give the formal definitions needed to adapt the theory developed in Section 2. We start by defining a DFA, the language associated to it, the enforces predicate between DFAs and a way for an agent to satisfy a DFA.
Δ
As usual [11], a DFA is a quintuple A = (S, Σ, s0, F, δ) where S is a finite set
of states, Σ is the input alphabeth, s0 ∈ S is the starting state, ∅ ⊂ F ⊆ S
is the set of ﬁnal states, and δ : S × Σ → S is the transition relation In

our framework, the alphabeth of the DFAs considered is a finite subset of Act ∪ Loc. Moreover, for the sake of simplicity, we shall always assume that the DFAs in this paper are minimal.
Definition 3.6 [DFA Acceptance and Enforcement] Let A be a DFA. Then
Acps(A) contains all the σ ∈ Σ∗ such that σ leads A from state s to a final state;
Acp(A) is defined to be Acps0 (A);
A1 enforces A2 holds true whenever Acp(A1) ⊆ Acp(A2).
We now formally describe the language associated to an agent. To this aim, we exploit the notion of concurrent regular expressions (CRE, for short) in- troduced in [7] to model concurrent processes. For our purposes, the following subset of CRE suffices:
e	::=	ϵ	|	α	|	e1.e2	|	e1 ⊙ e2	|	e⊗


ϵ denotes the empty sequence of characters, α ranges over
Act ∪ Loc, ‘.’

denotes concatenation, ⊙ is the interleaving (or shuﬄe) operator and ⊗ is its closure. Intuitively, if e represents the language L, then e⊗ represents
{ϵ} ∪ L ∪ L ⊙ L ∪ L ⊙ L ⊙ L.. .. Given a CRE e, the language associated to it, written lang(e), can be easily defined; a formal definition is given in the full paper. Now, given a process P , we easily define a CRE associated to it. Formally

Δ	Δ
CRE(nil) = ϵ	CRE(a.P ) = a.CRE(P )

Δ	Δ
CRE(goAl.P ) = l	CRE(P1 | P2) = CRE(P1) ⊙ CRE(P2)

CRE(!P

Δ
) = CRE(
P )⊗


Definition 3.7 [DFA Satisfaction] An agent P satisfies the DFA A, written
▶ P : A, if lang(CRE(P )) ⊆ Acp(A) and, for every subagent of P of the form
goA' l.Q, it holds that ▶ Q : A'.
In the full paper, we prove that the enforcement predicate can be estab- lished efficiently, while DFA satisfaction is decidable, but extremely hard to establish. This substantiate our hypothesis that verifying digests is preferable to inspecting the full code from the point of view computational complexity. We are now ready to state the soundness of this variation. It simply consists in finding a proper notion of well-formed systems. Like in Section 3.1, the entry policy can only express properties of single threads, instead of coalitions

of threads hosted at a site. Thus, we modifiy rule (wf-g.site) from Figure 4 as below.


(wf-g.siteA)
∀i. Pi a thread and	∃s ∈ S. lang(CRE(Pi)) ⊆ Acps(Mp)
▶ l[[ M |⟩ P1| ... |Pn ]] : ok

l trustworthy

This essentially requires that the languages associated to each of the threads in l are suffixes of words accepted by Mp (cf. Theorem 3.9 below). Since this may appear quite weak, it is worth remarking that the well-formedness predicate is just a ‘consistency’ check, a way to express that the agent is in a state from where it will respect the policy of l.
Theorem 3.8 (Subject Reduction for automata policies) If ▶ N : ok
and N → N', then ▶ N' : ok.
Theorem 3.9 (Safety for automata policies) Let N be a well-formed system. Then, for every trustworthy site l[[ M |⟩ P1| ... |Pn ]] in N, where each Pi is a thread, it holds that σ ∈ lang(CRE(Pi)) implies that there ex- ists σ' ∈ Acp(Mp) such that σ' = σ''σ, for some σ''.

Resident Policies
Here we change the intended interpretation of policies. In the previous section a policy dictated the proposed behaviour of an agent prior to execution in a site, at the point of entry. This implied that safety in well-formed systems was a thread-wise property (see rules (wf-g.siteM) and (wf-g.siteA)). Here we focus on policies which are intended to describe the permitted (coalitional) behaviour of agents during execution at a site. Nevertheless these resident policies are still used to determine whether a new agent is allowed access to the site in question; entry will only be permitted if the addition of this incoming agent to the code currently executing at the site does not violate the policy.
Let us consider an example to illustrate the difference between entry and resident policies.
Example 4.1 Let licence serv be the site name of a server that makes available K licences to download and install a software product. The distri- bution policy is based on a queue: the first K agents landing in the site are granted the licence, the following ones are denied. The policy of the server

should be Ms Δ
{get licenceK}. However if this policy is interpreted as an

p =
entry policy, applying the theory of Section 3.1, then the system grants at

most K licences to each incoming agent. Moreover this situation continues indefinitely, effectively handing out licences to all incoming agents.
We wish to re-interpret the policies of the previous section as resident policies and here we outline two different schemes for enforcing such policies. For simplicity we confine our attention to one kind of policy, that of multisets.
Static membranes
Our first scheme is conservative in the sense that many of the concepts devel- oped in Section 3.1 for entry policies can be redeployed. Let us reconsider the migration rule from Figure 2:
(r-mig)  k[[ Mk |⟩ goTl.P | Q ]]  l[[ Ml |⟩ R ]] →
k[[ Mk |⟩ Q ]]	l[[ Ml |⟩ P | R ]]	if Ml ▶k P
(2)
Here the membrane Ml only takes into consideration the incoming code P ,

and its digest T, when deciding on entry, via the predicate Ml ▶k
P . But

if the membrane is to enforce a resident policy, then it must also take into account the contribution of the code already running in l, R. To do so we need a mechanism for joining policies, such as those of the incoming P and the resident R in (2). So let us assume that the set of policies, with the relation enforces is a partial order in which every pair of elements T1 and T2 has a least upper bound, denoted T1 H T2. For multiset policies this is the case as H is simply multiset union. In addition we need to be able to calculate the (minimal) policy which a process R satisfies; let us denote this as pol(R). For multiset policies we can adjust the rules in Figure 6, essentially by eliminating weakening, to perform this calculation; the resulting rules are given in Figure 7, with judgements of the form H P : T.
Definition 4.2 Define the partial function pol(·) over closed terms by letting
pol(P ) to be the unique policy such that H P : T, if it exists.
With these extra concepts we can now change the rule (r-mig) in (2) to take the current resident code into account. It is sufficient to change the side

condition, from Ml ▶k P to Ml,R ▶k
P , where this latter is defined to be

T	T
if Ml(k)= lgood then (TH pol(R)) enforces Ml  else ▶ P | R : Ml
t	p	p
Here if only the digest needs to be checked then we compare TH pol(R), that is the result of adding the digest to the policy of the resident code R, against the resident policy Mp. On the other hand if the source site is untrusted we




nil : ∅
T′ enforces T






Fig. 7. Type inference for agents with policies as multisets


then need to analyse the incoming code in parallel with the resident code R. It should be clear that the theory developed in Section 3.1 is readily adapted to this revised reduction semantics. In particular the Subject Reduction and Safety theorems remain true; we spare the reader the details. However it should also be clear that this approach to enforcing resident policies has serious practical drawbacks. An implementation would need to:
freeze and retrieve the current content of the site, namely the agent R;
calculate the minimal policy satisfied by R to be merged with P ’s digest in order to check the predicate enforces , or typecheck the composed agent P | R;
reactivate R and, according to the result of the checking phase, activate
P .
Even if the language were equipped with a passiﬁcation operator, as in [17], the overall operation would still be computationally very intensive. Consequently we suggest below another approach.


Dynamic membranes
In the previous approach we have to repeatedly calculate the policy of the current resident code each time a new agent requests entry. Here we allow the policy in the membrane to “decrease,” in order to reflect the resources already allocated to the resident code. So at any particular moment in time the policy currently in the membrane records what resources remain, for any future agents who may wish to enter; with the entry of each agent there is a corresponding decrease in the membrane’s policy. Formally we need to change the migration rule (2) to one which not only checks incoming code, or digest,



(wf-g.site)

l trustworthy

(wf-empty)

Θ ▶ l[[ M |⟩ P ]] : ok (pol(P ) H Mp) enforces Θ(l)
Θ ▶ 0 : ok



(wf-u.site)

Θ ▶ l[[ M |⟩ P ]] : ok

l not trustworthy
(wf-par)
 Θ ▶ N1 : ok,  Θ ▶ N2 : ok 
Θ ▶ N1  N2 : ok



Fig. 8. Well-formed systems under Θ
against the membrane’s policy, but also updates the membrane:
(r-mig')	k[[ Mk |⟩ goTl.P | Q ]]  l[[ Ml |⟩ R ]] →
k[[ Mk |⟩ Q ]]  l[[ M^l |⟩ P | R ]]	if Ml ▶k


P > M^l

where the judgement Ml ▶k
P > M^l is defined as


let T' =
⎧⎨ T	if Ml(k)= lgood
⎩ pol(P ) otherwise

in ( T' enforces Ml  ∧
Ml = M^ l H T'	∧	Ml = M^l)

First notice that if this migration occurs then the membrane at the target site
changes, from Ml to M^ l . The latter is obtained from the former by eliminating
those resources allocated to the incoming code P . If the source site, k, is
deemed to be lgood this is calculated via the incoming digest T; otherwise a direct analysis of the code P is required, to calculate pol(P ).
This revised schema is more reasonable from an implementation point of view, but its soundness is more difficult to formalise and prove. As a com- putation proceeds no permanent record is kept in the system of the original resident policies at the individual sites. Therefore well-formedness can only be defined relative to an external record of what the resident policies were, when the system was initiated. For this purpose we use a function Θ, mapping trustworthy sites to policies; it is sufficient to record the original polices at these sites as we are not interested in the behaviour elsewhere.
Then we can define the notion of well-formed systems, relative to such a Θ; this is written as Θ ▶ N : ok and the formal definition is given in Table 8. The crucial rule is (wf-g.site), for trustworthy sites. If l is such a site then l[[ M |⟩ P ] is well-formed relative to the original record Θ if Ml H pol(P )
guarantees the original resident policy at l, namely Θ(l).

Theorem 4.3 (Subject Reduction for resident policies) If Θ ▶ N : ok
and N → N', then Θ ▶ N' : ok.
Theorem 4.4 (Safety for resident policies) Let N be a well-formed sys-
tem w.r.t. Θ. Then, for every trustworthy site l[[ M |⟩ P ]] in N, P →σ P '
implies that act(σ) enforces Θ(l).

Conclusion and Related Work
We have presented a framework to describe distributed computations of sys- tems involving migrating agents. The activity of agents entering/running in ‘good’ sites is constrained by a membrane that implements the layer dedicated to the security of the site. We have described how membranes can enforce sev- eral interesting kind of policies. The basic theory presented for the simpler case has been refined and tuned throughout the paper to increase the expres- siveness of the framework. Clearly, any other kind of behavioural specification of an agent can be considered a policy. For example, a promising direction could be considering logical frameworks (by exploiting model checking or proof checkers).
The calculus we have presented is very basilar: it is even simpler than CCS [13], as no synchronization can occur. Clearly, we did not aim at Turing- completeness, but at a very basic framework in which to focus on the roˆle of membranes. We conjecture that, by suitably advancing the theory pre- sented here, all the ideas presented here can be lifted to more complex calculi (including, e.g., synchronization, value passing and/or name restriction).
Related Work. In the last decade, several calculi for distributed systems with code mobility have appeared in literature. In particular, structuring a system as a (flat or hierarchical) collection of named sites introduced the possibility of dealing with sophisticated concrete features. For example, sites can be considered as the unity of failure [6,1], mobility [6,3] or access control [10,16,9]. The present work can be seen as a contribution to the last research line.
Similarly to [9], we have presented a scenario where membranes can evolve. However, the membranes presented in Section 4 only describe ‘what is left’ in the site. On the other hand, the (dynamically evolving) type of a site in [9] always constrains the overall behaviour of agents in the site and it is modified upon acquisition/loss of privileges through computations.
We borrowed from [16] the notion of trust between sites. In loc. cit., agents coming from trusted sites are accepted without any control. Here, we relaxed this choice by examining the digest of agents coming from trusted sites.

Moreover, we have a fixed net of trust; we believe that, once communication is added to our basic, the richer scenario of [16] (where the partial knowledge of a site can evolve during its computation) can be recovered.
A related paper is [12]. The authors develop a generic type system that can be smoothly instantiated to enforce several properties of the π–calculus (dealing with arity mismatch in communications, deadlock, race control and linearity). They work with one kind of types, and modify the subtyping rela- tion in order to yield several relevant notions of safety. The main difference with our approach is that we have different kind of types (and, thus, different type checking mechanisms) for any variation we propose. It would be nice to lift our work to a more general framework closer to theirs; we leave this for future work.
Our work is also related to [15]. Policies are described there as determinis- tic finite automata and constrain the access to critical sections in a concurrent functional language. A type and effect system is provided that guarantees ad- herence of systems to the policy. In particular, the sequential behaviour of each thread is guaranteed to respect the policy, and the interleavings of the threads’ locks to be safe. Differently from our paper, [15] has no code migra- tion, and no explicit distribution; thus, only one centralised policy is used.
Membranes as filters between the computing body of a site and the external environment are also considered in [5,2,17]. There, membranes are computa- tionally capable objects, and can be considered as a kind of processes. They can evolve and communicate both with the outer and with the inner part of the associated node, in order to regulate the life of the node. This differs from our conception of membranes as simple tools for the verification of incoming agents.
To conclude, we remark that our understanding of membranes is radically different from the concept of policies in [4]. Indeed, in loc. cit., security au- tomata control the execution of agents running in a site by in-lined monitoring. This technique consists in accepting incoming code unconditionally, but block- ing at runtime those actions not abiding the site policy. Clearly, in order to implement the strategy, the execution of each action must be filtered by the policy. This contrasts with our approach, where membranes are ‘containers’ that regulate the interactions between sites and their environments. The com- putation taking place within the site is out of the control of the membrane that, hence, cannot rely on in-lined monitoring.

References
R. Amadio. On modelling mobility. Theoretical Computer Science, 240(1):147–176, 2000.


G. Boudol. A generic membrane model. To appear in the Proc. of Global Computing’04, LNCS. Springer, 2004.
L. Cardelli and A. D. Gordon. Mobile ambients. Theoretical Computer Science, 240(1):177– 213, 2000.
U. Erlingsson and F. Schneider. SASI Enforcement of Security Policies: A Retrospective. In
Proc. of New Security Paradigms Workshop, pages 87–95. ACM, 1999.
G. Ferrari, E. Moggi, and R. Pugliese. Higher-order types and meta-programming for global computing. Mathematical Structures in Computer Science, 2003. To appear.
C. Fournet, G. Gonthier, J. L´evy, L. Maranget, and D. R´emy. A calculus of mobile agents. In
Proc. of CONCUR’96, volume 1119 of LNCS, pages 406–421. Springer, 1996.
V. Garg and M. Raghunath. Concurrent regular expressions and their replationship to Petri nets. Theoretical Computer Science, 96:285–304, 1992.
D. Gorla, M. Hennessy, and V. Sassone. Security policies as membranes in systems for global computing. Full version of this paper, available as Computer Science Research Report 02/2004, Dept. of Informatics, Univ. of Sussex (UK).
D. Gorla and R. Pugliese. Resource access and mobility control with dynamic privileges acquisition. In Proc. of ICALP’03, volume 2719 of LNCS, pages 119–132. Springer-Verlag, 2003.
M. Hennessy and J. Riely. Resource Access Control in Systems of Mobile Agents. Information and Computation, 173:82–120, 2002.
J. Hopcroft and J. Ullman. Introduction to automata theory, languages and computation. Addison-Wesley, 1979.
A. Igarashi and N. Kobayashi. A generic type system for the pi-calculus. In Proceedings of POPL ’01, pages 128–141. ACM, 2001.
R. Milner. A Calculus for Communicating Systems. Springer-Verlag, 1982.
R. Milner. Communicating and Mobile Systems: the π-Calculus. Cambridge University Press, 1999.
N. Nguyen and J. Rathke. A typed static analysis for a concurrent policy based resource access control. Draft, 2004.
J. Riely and M. Hennessy. Trust and partial typing in open systems of mobile agents. In
Proceedings of POPL ’99, pages 93–104. ACM, 1999.
A. Schmitt and J. Stefani. The M-calculus: a higher-order distributed process calculus. In
Proc. of POPL’03, pages 50–61. ACM, 2003.
