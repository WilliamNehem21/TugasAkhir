

Electronic Notes in Theoretical Computer Science 229 (2009) 97–115
www.elsevier.com/locate/entcs

Towards Secrecy for Rewriting in Weakly Adhesive Categories
Tobias Heindel
Abteilung fu¨r Informatik und angewandte Kognitionswissenschaft Universit¨at Duisburg-Essen
Duisburg, Germany

Abstract
Inspired by the scope extrusion phenomenon of name passing calculi that allow to reason about knowledge of (secret) names, we propose an abstract formulation of the concept of secret in any weakly adhesive category. The guiding idea is to mark part of a system state as visible or publicly accessible; further, in principle, something that has become public knowledge will stay accessible indefinitely.
The main technical contribution consists in providing a proof which shows that a recently proposed categorical construction, which produces a category having monomorphisms as objects and pullback squares as morphisms, preserves weak adhesivity. Finally we sketch how it is possible to verify certain secrecy properties using unfolding based verification approaches that lately have been generalized to rewriting systems in weakly adhesive categories.
Keywords: adhesive categories, interaction models, verification

Introduction
In every day communication, private information is usually exchanged only between communication partners that trust each other, as the consequences of public avail- ability of private information tend to be numerous and subtle. In fact, more often than not, one would rather prefer that a certain piece of private information will never be become known to the public. Here we are not only talking about issues of embarrassment or reputation, but also about secret data like personal identification numbers for (on-line) banking accounts.
Nevertheless, as the example of on-line banking illustrates, there often occur situations in which secret data need to be transmitted via protected channels between trustworthy communication partners, and moreover the critical data must not become disclosed to a third party. The running example of this paper will be concerned with access keys to a private network, e.g. the intranet of some banking institute. Obviously, in this scenario, it is important that such access keys do not become publicly available.

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.06.041

One of the first approaches to formally reason about the security of key exchange protocols using cryptographic methods, is the spi-calculus [1], which extends the π-calculus [14] by cryptographic primitives. Based on this name passing calculus, there has been carried out a large amount of work concerning the verification of concrete protocols. The actual protocol verification tools however do sometimes use techniques from other fields of computer science (see e.g. [3]). Alternatively, protocols might also be specified and verified using graph transformation systems [4,12]; the latter have the advantage that they are often easier understandable by laypersons. Now the aim of this paper is not another concrete proposal of a modelling technique for protocols. Instead we strive for a better understanding of the funda- mental distinction between private and public knowledge, which corresponds to the open/bound names dichotomy of name passing calculi. Moreover the scope extrusion phenomenon of the latter captures the possibility to exchange secret information
and, in the extreme, to make secret information publicly available.
Taking a more abstract point of view, given an arbitrary state of a system, then part of of this state is open to public access (while at the same time other parts are still secret). In the process calculus world, the open part corresponds to the free names of a process. In graph transformations systems using the borrowed context approach [5], the open part is singled out by a sub-graph of the graph which models the whole system state.
The main question is now, when the private part and the public part (in the model) of a given system state should be considered “sufficiently” distinct such that all secret information is protected from public access. Though this question usually has an intuitive answer in concrete example cases, the question seems more difficult in the abstract setting of this paper, as we consider system states as objects of an arbitrary (weakly) adhesive category.
To help answer this question, we proceed as follows. First we introduce the protected links calculus as an toy example of a simple name passing calculus, which
nevertheless is sufficiently rich to illustrate the private/public dichotomy and allows to give a precise characterization of secrecy violations. Then we give the graphical representation of this calculus in section 3. With these concrete examples at hand,
in section 4, we set out to lift the notion of secrecy violation to the abstract setting
of adhesive categories in such a way that the results of [2] apply.

The protected links calculus
The running example of this paper will be the protected links calculus (plc), which couples the ideas of (the implementation of) the explicit fusion calculus [16] with a basic access control mechanism. Recall that the explicit fusion calculus was developed with the goal of providing an implementation of Milner’s π-calculus [14]. The “machine model” was the fusion machine described in [16]; a simplified version of the latter has been proposed in [8], where also a “low-level” encoding of the π-calculus was presented.
Now the main characteristic of the protected links calculus that it shares with

the explicit fusion calculus and the fusion machine, is that it does not use any name substitution at the meta-level but instead uses a “low-level” approach similar to the one of the fusion machine. In the latter, substitution of names is implemented by a forwarding mechanisms that was explored in more detail in [8].
Indeed, the major part of the primitives of the protected links calculus are taken from the calculus of explicit fusions and its fusion machine, namely (asynchronous) input and output, parallel composition, and forwarders, which we here more often
call links; the latter however are equipped with an access control mechanism based
on the notion of access right, which is the new entity kind of the plc.
Definition 2.1 (Syntax of the protected links calculus) Let 𝒩 be a collection of names, which is the disjoint union of public names ¨𝒩 and private names ˆ𝒩, which means 𝒩 = ¨𝒩  ˆ𝒩. Then the set of (raw) terms of the pl-calculus is given by the following speciﬁcation.
P ::= u⟨x⟩	u, x ∈ 𝒩	(output action)
 u(y)	u, y ∈ 𝒩	(input action)
 u−'w	u, w ∈ 𝒩	(protected link)
 x  u	x ∈ 𝒩,u ∈ ˆ𝒩	(access right)
 0	(inaction)
 P | P	(parallel composition)

Let P be a raw term; then the set of free names of P, written fn P, contains all names that occur in P but are not private, i.e. fn P = {x ∈ ¨𝒩 | x occurs in P}.
A process of the pl-calculus is a raw term up to structural congruence, written ≡,
which is the smallest equivalence relation on raw terms satisfying the following axioms where P, Q, R range over plc terms.
P | 0 ≡ P	P | Q ≡ Q | P	P | (Q | R) ≡ (P | Q) | R

If a name v is public, i.e. v ∈ ¨𝒩, we sometimes write v¨ instead of v to emphasize this fact; conversely, if v¨ is a name, then we implicitly assume that v¨ ∈ ¨𝒩; by a similar convention, if we write vˆ, then we silently presuppose that vˆ ∈ ˆ𝒩.
As mentioned above, the main difference w.r.t the calculus of explicit fusions
consists in the new entity, called access right. Following a common interpretation of process calculi, names are often referred to as channels through which input and output actions may synchronise and communicate. Further we will talk about scopes, which are those parts of terms that share a private name uˆ, or names that are related to uˆ via a chain of bi-directional links, i.e. uˆ and v are in the same scope, if there is a chain uˆ−'w1 | w1−'uˆ | ··· v−'wn | wn−'v. Relying on this word usage, the ideas of the protected links calculus can be described as follows.
The protection mechanism of links ensures that an output action can enter into a scope only if it has the access right for the scope in question. This is captured by the conditional forwarding mechanism of protected links, which checks access rights before output actions are relocated. In contrast, modelling the possibility of attacks

and careless users, access rights may always spread between linked channels. These phenomena are made precise in the formal definition of the reaction relation over plc terms, and is discussed in more detail afterwards.
Definition 2.2 (Reaction in the PLC) The reaction relation over plc terms, written d, is the smallest relation satisfying the axioms and rules of Figure 1.



prot
	vˆ ∈ ˆ𝒩	
(u⟨x⟩ | x vˆ | u−'vˆ) d (vˆ⟨x⟩ | x vˆ | u−'vˆ)
	v¨ ∈ ¨𝒩	

pub


exch


comm


struct
(u⟨x⟩ | u−'v¨) d (v¨⟨x⟩ | u−'v¨)
(x vˆ | x−'y) d (y vˆ | x−'y) (u⟨x⟩ | u(y)) d (x−'y | y−'x)
P ≡ P'	P' d Q'	Q' ≡ Q
P d Q

Fig. 1. Reaction rules of the protected links calculus

These axioms and rules can be explained as follows. The protection mechanism of links is captured by the prot-axiom: an output action u⟨x⟩ is forwarded along a link u−'vˆ only if the data x come equipped with the access right x vˆ to the channel vˆ, to which the action could be transported via the link. To simplify the modelling process we think of the data x as a representation of the actual user that is trying to send x.
However, the protection mechanism does not restrict transmissions to public channels, i.e. everyone can send on public channels. This is formalized by the pub-rule, which says that given a link u−'v¨, which models a direct network link connecting u to v¨, an output action u⟨x⟩ at the origin u can always travel to the target v¨, provided that the target channel v¨ is a public.
Next we come to the formal counterpart of the phenomenon that, as known from practical experience, keys are often stolen or exchanged with untrustworthy partners. Hence, assuming the worst case, the distribution of access keys is unconditional,
i.e. whenever there is a direct means of communication a key may be exchanged. Precisely the exch-axiom says that whenever the user x has a key to enter the scope v, modelled by the access right x vˆ, in the presence of a link x−'y, which models a direct means of communication, the user y will always manage to obtain the “key” granting access to v, which then results in the access right y vˆ.
A request for a (new) channel for the transmission of (possibly confidential) data is modelled by a send action u⟨x⟩ where x is a channel name which, simplifying again, is thought of as the user issuing the channel request. The receiver, corresponding to the input action u(y), then will establish direct links between x and y, which is

represented by complementary forwarders x−'y and y−'x; the described communication protocol is captured by the comm-axiom. Note, that this axiom is essentially the same as the single reaction axiom of the calculus of explicit fusions [16]. Finally the struct-rule says that reaction is closed under structural congruence.
Example 2.3 (Key exchange) To show the pl-calculus at work, we consider key exchange. That a user xˆ has a key granting access to vˆ is modelled by the access right xˆ vˆ. Now suppose user xˆ wants to exchange this key with user yˆ and that xˆ and yˆ usually communicate via channel u, possibly a private channel as well. The plc process xˆ vˆ | u⟨xˆ⟩ | u(yˆ) is a possible solution to achieve this, as we have the following reactions.


xˆ vˆ | u⟨xˆ⟩ | u(yˆ) d xˆ vˆ | xˆ−'yˆ| yˆ−'xˆ
d yˆ vˆ | xˆ−'yˆ| yˆ−'xˆ
(comm)
(exch)

Hence after these two steps, user yˆ has the key granting access to vˆ, which is modelled by the access right yˆ vˆ.
Before we come to the main theme of this paper, namely secrecy, we give a short comparison of the pl-calculus on the one hand, and the calculus of explicit fusions, the fusion machine and the linear forwarder calculus on the other hand. The only properly new primitive of the pl-calculus is the access right since the fusion related calculi do not have any similar entities; however the latter calculi are not designed to reason about secrecy but only about communication via name passing.
The second theme which allows to discern the mentioned calculi concerns the mechanisms that are used to connect channels or “fuse” names. Whereas the calculus of explicit fusions addresses the issue of connection of names at the level of structural congruence, which intuitively corresponds to (irreversible) fusion of names, both the linear forwarder calculus [8] and the protected links calculus choose a “low-level” approach, and add reaction rules that “implement” the fusion of names; this “low- level” approach has the advantage, that additional reaction rules might be added to model the break down of network links, which corresponds to the removal of links between names.
Finally we would like to stress that the pl-calculus is just an example which allows to illustrate the idea of secrecy without the need to formally introduce the technical details of double pushout rewriting [6]. Hence we also omitted replication, and synchronous input and output, which only would have burdened the presentation. Moreover, for the purpose of this paper, it seemed suitable to avoid the notions of α-equivalence and bound name.
Summarizing, the pl-calculus can be seen as a simplified version of the linear forwarder calculus with a new entity called access right. The latter allows to reason about secrecy, as demonstrated in the following, central example of the paper, which illustrates how secrecy holes are modelled in the pl-calculus.
Example 2.4 (Secrecy hole) A secrecy hole of a network, is a channel through which private access keys are made public. A process term P contains an immediate secrecy hole, if P contains a sub-term of the form v¨ wˆ, i.e. if in the modelled system,

there is a publicly available key granting access to some private channel wˆ.
Further a process Q models a system with a covert secrecy hole, if Q does not
contain any sub-term of the form v¨  wˆ but such a sub-term might arise after a
number of reductions of P. For example the process uˆ wˆ | uˆ−'v¨ does not contain any immediate secrecy hole; however we have the reaction (uˆ wˆ | uˆ−'v¨) d (v¨ wˆ | uˆ−'v¨) via the exch-rule, and the latter contains an immediate secrecy hole. Hence, given a term Q one might want to prove that it does not contain any (covert) secrecy holes.
We would like to emphasize that we do not claim that this is the only class of secrecy holes that might be worthwhile to investigate.
How the verification of secrecy w.r.t this “definition” may be achieved using the unfolding technique of [2], is sketched in 4.6. However we first need to recall the necessary concepts concerning transformation systems and categories that allow to model systems following the double pushout approach of [6].

The graphical counterpart of the PLC
In this section we give a graphical representation of the plc; more precisely, for each process there will be a corresponding graph and vice versa. Moreover each reaction rule will be a graph transformation rule based on the double pushout approach
(dpo) [6]. However, omitting the details of dpo rewriting, we give an informal
presentation that nevertheless should convey the main ideas of graph transformation. The channels or names of plc processes will correspond to nodes in the graphical representation. All entities of the pl-calculus correspond to different kinds of edges between the nodes. An output action u⟨x⟩ is represented by a send arrow x	u , an input action u(y) corresponds to a receive edge u	y , an access right x  uˆ is
drawn as x	uˆ , a link u−'w becomes a connection arc u	w , and the inaction is
the empty graph ∅. Finally parallel composition is achieved by union of graphs. To avoid clutter, a pair of complementary links u−'w | w−'u is represented by u	w . For
a private node uˆ , the label uˆ already contains the information that this is a private
node, and the gray boundary only emphasizes this fact.
Moreover, not only does each process correspond to a graph, but also each reaction rule has a corresponding transformation rule. A (linear) graph transformation rule or production q is essentially a pair of graphs L, R (called left- and right- hand side, respectively) with a common sub-graph K (referred to as interface), i.e. q = L ⊇ K ⊆ R. Assuming that the sets of nodes and edges in rules are disjoint, and writing as if graphs were mere sets, the rewriting mechanism of such rules can be described as follows.
Suppose that the left-hand side L of a rule q = L ⊇ K ⊆ R is a sub-graph of some larger graph G, i.e. L ⊆ G, then the rule q first removes from G all those nodes and edges that are covered by the left-hand side L but not contained in the interface K, which results in an intermediate graph D ⊆ G; in a second step, those nodes and edges of R that are not contained in K are adjoined to the intermediate result D, yielding a graph H ⊇ D. Provided that R ∩ G ⊆ K (and the inclusion L ⊆ G satisfies the so-called dangling condition [4]), the result H can be described

as H = (G \ (L \ K)) ∪ R.
Now the graphical counterpart of the rules of the plc is illustrated in Figure 2. Note that in this encoding of the plc rules, one directly mentions which resources


prot:
⊇
⊆
exch:	⊇	⊆



pub:
⊇	⊆
comm:	⊇	⊆


Fig. 2. The graphical representation of the plc calculus

are only used as “catalysts”, and hence remain unchanged during the reactions. To see the correspondence between the calculus and its graphical presentation, consider the following example concerning the comm-rule.
Example 3.1 (Communication in PLC via graphs) The protected link calculus process u(y) | u⟨x⟩ | u(z) has two possibilities to evolve: either u⟨x⟩ reacts with u(y) or with u(z), i.e.
(y−'x | x−'y | u(z)) D (u(y) | u⟨x⟩ | u(z)) d (u(y) | z−'x | x−'z)
The corresponding graph transformation steps can be illustrated as follows.

⊇	⊆	⊇	⊆


⊇	⊆	⊇	⊆
So far we have not elaborated on the concept of graph we have actually used in this encoding. As a starting point, we will work with suitably labelled graphs.To emphasize that the set of public nodes is actually a fully fledged sub-graph of the graph which represents the whole process, we will later use marked graphs instead; the latter are pairs of a graph an a marked sub-graph (see Definition 3.2). The use of marked graphs is motivated by the fact that the notion of sub-graph allows for a straightforward categorical generalization, viz. sub-object, whereas this is not the case for labels. In the end, marking of objects might be thought of as an abstract labelling mechanism.

The graphical representation in a slice category
A suitable choice of a category for a precise, graphical presentation of processes of the protected links calculus is the category of graphs typed 1 over the type graph

1 This terminolgoy is in accordance with the theory and applications of graph grammars, see e.g.
http://tfs.cs.tu-berlin.de/agg/typegraph.html.



T =	∈ G,


i.e. processes correspond to objects of the slice category G↓T where G is the usual category of directed multi-graphs (see Definition A.1 in Appendix A). In the graph T , the left node corresponds to public channels, the right one to private ones, the three loops on the left node stand for inputs, outputs and links between pairs of public names, respectively, the four loops on the right one represent inputs, outputs, links, and access rights between pairs of private channels, respectively, and similar explanations can be provided for the remaining edges between the two different
nodes. This means that the G↓T -object T−idT ⭢T would be depicted as


.


Note that this formal rendering in the slice category G↓T means that Figure 2 actually gives schemes for rules, since it is not specified for several nodes whether

they are public or private, i.e. whether they are mapped to
or
in T ; in other

words there are actually eight different instances of the comm-rule, and four instances
for each of the other rules.
In this formal setting, a secrecy violation	is an object of G↓T , which can
also be seen as a sub-graph of T , corresponding to the obvious graph morphism
c :	>⭢ T in G. Further, observe that a (typed) graph (A−a⭢T ) ∈ G↓T does
not contain any secrecy violation v¨	wˆ , i.e. there does not exist any monomorphism
>⭢ (A−a⭢T ) in G↓T , if and only if pulling back along c yields a discrete graph
(in the slice category G↓	). More general, given any graph (B−b⭢T ) ∈ G↓T
representing some pl-process P , pulling back along c :	>⭢ T followed by
post-composition with c yields the secrecy relevant part of (B−b⭢T ).
This pullback-compose construction can be generalized to any graph morphism ϕ : T ' → T in G, and actually gives rise to functors ϕ③ : G↓T → G↓T which act by pulling back along ϕ followed by post-composition with ϕ, i.e. ϕ③ = Σϕ ◦ ϕ∗ where ϕ∗ : G↓T → G↓T' and Σϕ : G↓T' → G↓T are a choice of a pullback functor and its left adjoint, respectively. The co-unit ε : ϕ③ → idG↓T of this adjunction Σϕ E ϕ∗ embeds the secrecy relevant part of an G↓T -object.
In the same way, the public part of an object (A−a⭢T ) ∈ G↓T is given by i③ (a)
where i :	>⭢ T is the inclusion morphism mapping the single node to the left node
of T . As i is a monomorphism, also the co-unit ε : i③ >⭢ idG↓T is monic. Hence ε gives for each typed graph (A−a⭢T ) the embedding εa : i③ (a) >⭢ a of its public part into the whole object. This exactly corresponds to the free names of a process if (A−a⭢T ) arose from a pl-process. Abstracting away from the functors i③ and c③ ,

we thus lead to the following alternative labelling mechanism.

Marking graphs
An alternative to attribution, labelling or typing of graphs is the idea to “mark” part of a given graph. This idea has been discussed recently within the graph transformation community and is presented in detail in [10]. In the present case, one might for example choose to mark only the public nodes of a graph, i.e. the objects we are working with are pairs ⟨G, G'⟩ such that G ⊇ G'. In the next section we will replace graphs by objects of any (weakly) adhesive category. Hence the details about the graphs that we will use are deferrred to the end of this section.
The main idea of the graphical presentation of pl-calculus terms is as follows: let
P be a plc term and let P ) be the presentation of P , which is an (edge and node labelled) graph. Then the public nodes of P form the set of free names fn P , which is – when considered as a discrete graph, i.e. a graph without edges – a sub-graph of P ), i.e. the pair ⟨ P ), fn P⟩ satisfies P ) ⊇ V '.
For the remainder of the section we write ⟨G, G'⟩⊇ if G and G' are graphs, such that the inclusion G ⊇ G' holds, and call the pair ⟨G, G'⟩⊇ a marked graph. Next
we will supply as suitable notion of morphism between marked graphs, such that the marked part of a graph will remain marked and moreover the marked and the unmarked part will be kept distinct. This is made formal in the next definition for the case of (unlabelled multi-)graphs.
Definition 3.2 (Marked Graph) A marked graph is a pair G⊇ = ⟨G, G'⟩⊇ of graphs G and G' such G' is a sub-graph of G, i.e. G ⊆ G'. A marked graph mapping between marked graphs G⊇ = ⟨G, G'⟩⊇ and H⊇ = ⟨H, H'⟩⊇ is a pair of graph morphisms f⊇ = ⟨f : G → H, f' : G' → H'⟩ such that ıH ◦f' = f ◦ıG is satisﬁed where ıH : H' >⭢ H and ıG : G' >⭢ G are the inclusion morphisms and moreover
if the image of a node v of G is in the marked part H', then the node itself is marked, i.e. for every node v of G, if fV (v) ∈ H' then v ∈ G', and
the same holds for all edges e in G, i.e. fE(e) ∈ H' implies e ∈ G'.
A marked graph mapping f⊇ = ⟨f, f'⟩ is an inclusion mapping if f and f' are inclusion morphisms.
To prepare the definition of the category of reflected monos, we give a categorical characterization of the category of marked graphs and mappings. For this we recall that, given a graph H, a sub-graph H' ⊆ H, and a morphism f : G → H in the category of graphs and graph morphisms, the (natural choice of a) pullback of the co-span G −f ⭢ H ›ı< H' is the span G ›ı< f−1(H') −f †H' ⭢ H', giving rise to
the pullback square f−1 (H')	H' where f−1(|H'|) = {h ∈ |G| | f (h) ∈ |H'|} is the
pre-image of |H'|, and the graph morphism f TH' : f−1(H') → H' is the co-domain restriction of f : G → H, which maps x ∈ f−1(|H'|) to f TH' (x) = f (x) ∈ |H'|.
Lemma 3.3 (Marked mappings as pullback squares) Let G⊇ = ⟨G, G'⟩⊇ and H⊇ = ⟨H, H'⟩⊇ be marked graphs and f⊇ = ⟨f, f'⟩ : G⊇ → H⊇ be a marked graph mapping. Then G' = f−1(H') and f' = f TH' , which means that G ›ı< G' −f'⭢ H' is

a pullback of G −f ⭢ H ›ı< H', giving rise to the pullback square G'	H'
Proof. First we show that G' = f−1(H'). To show that G' ⊆ f−1(H'), let x ∈ |G'|; then f (x) = f'(x) ∈ |H'|, i.e. x ∈ f−1(|H'|). To prove the converse, let x ∈ f−1(|H'|),
i.e. f (x) ∈ |H'|, whence also x ∈ G' by Definition 3.2. Having shown this, the equation f' = f TH' follows immediately.		 
Marked graphs and their mappings satisfy a certain reflection property, namely for any given mapping ⟨f, f'⟩ : ⟨G, G'⟩⊇ → ⟨H, H'⟩⊇, the marked part G' can be recovered from its image, i.e. the equation |G'| = f−1(f (|G'|)) holds.
A categorical approach to secrecy
Having introduced the protected links calculus to motivate the notion of marked graph, we now set out to lift the latter notion to an abstract level, namely the so-called categories of reflected monos [10]. This is followed by suggestions for the description of secrecy related concepts using category theoretical language. Finally we discuss possibilities to verify secrecy properties on this abstract level.
Categories of reflected monos
Using Lemma 3.3, the idea of the category of marked graphs and their mappings can easily transferred to any category, by the reflected monos construction. This lemma at the same time illustrates the main difference between categories of reflected monos and the arrow category G→, more precisely to the full subcategory of the arrow category G→ having the class of all G-monomorphisms as objects.
Definition 4.1 (Reflected Monos) Let C be a category with pullbacks along mono- morphisms, i.e. for each co-span A −f ⭢ D ›m< M with monic m, a pullback span
A ›n< N −g⭢ M exists, yielding a pullback square A	N
Then the category of reflected C-monos, written RMon(C), has C-monomorphisms A'>a⭢A as objects and an RMon(C)-morphism f›< : (A'>a⭢A) → (B'>b⭢B) is a pair f›< = ⟨f : A → B, f' : A' → B'⟩ of C-morphisms such that A ›a< A' −f'⭢ B' is
a pullback of A −f ⭢ B ›b< B', yielding a pullback square A'	B'
The category of reflected monos RMon(C) comes equipped with a forgetful functor ƒ : RMon(C) → C which maps each monomorphism A' >a⭢ A to A, i.e.
 aƒ = A, and each morphism f›< = ⟨f : A → B, f' : A' → B'⟩ to f , i.e. ⟨f, f'⟩ƒ = f .
Reflected monos in weakly adhesive categories
We will now recapitulate the notion of weakly adhesive category presented in [2], which provides a framework that is suitable for double pushout rewriting, and moreover is compatible with the RMon construction, a fact which will be made precise
in Proposition 4.4. Weakly adhesive categories generalize adhesive categories [13] and are closely related to weak adhesive hlr categories [7]. The advantage of this weaker notion of adhesivity lays in the fact that it captures additional examples, e.g.
those presented in [7], which are of practical relevance.

Definition 4.2 (Weakly adhesive category) A category is weakly adhesive if
pullbacks along monomorphisms exist and also pushouts along monomorphisms exist, i.e. for each span B ›f−A>m⭢C with monic m, a pushout B−n⭢D ›g−C exists, yielding a pushout square B ↓←↓ A;
D ’← C
pushouts of pairs of monomorphisms are universal (or stable under pullback),
i.e. in each commutative cube over a pushout square B←A	having pullback
squares as lateral faces as shown in the middle diagram in the display below, the top face is a pushout square;

⎛


D'	⇒ ⎜



'



'

⇒
A'	'	⎞

b	c
B	C	⎜⎝ B	C


pushouts along monomorphisms are mono-universal and converse mono-uni-
versal: in each commutative cube on top of a pushout square B←A	as in the
left diagram in the display below, with pullback squares as back faces and the “corner”-arrows b and c monic, its top face is a pushout square if and only if the front faces are pullback squares and the morphism d is monic.


'
f'	m'	'
'	'	⎜	'


A' m'
'	'
A' m'	⎞
' ⎟

B
n' D'	g'	a
C	B
⇒ ⎜	n' D'	g'
B	C
⇒	n' D'	g'	a	⎟

b	A	c
f	m
d	C
n D	g
⎜⎜ B		d n D
c ⇐  b
f	m
B	d
g	n D
f	m	C ⎟⎟⎠




Note that adhesive categories [13], apart from having all pullbacks, satisfy the simpler (and stronger) version of Condition iii that does not contain any conditions on the vertical morphisms a, b, c and d. Condition iii is equivalent to the requirement that pushouts along monomorphisms are hereditary in the sense of [11]. Finally, the subtle difference to the weak adhesive hlr-categories of [7] is that in the definition of the latter, the vertical morphism d into the “tip” of the bottom pushout is required to be monic already in the antecedent, which implies the “top face-front faces”-equivalence. This is also the reason why the proof of Proposition 4.4 does carry over to weak adhesive hlr-categories. The exact relation among weakly adhesive, adhesive, and weak adhesive hlr categories is also discussed in [2].
An example of a category that is weakly adhesive but not adhesive and hence deserves being mentioned, is the category of undirected multi-graphs. That this

category is weakly adhesive but not adhesive can be shown by adapting the results presented in [15].
Example 4.3 (Undirected multigraphs) An undirected multigraph is a triple M = ⟨E, V, c : E → V ⊕⟩, where V ⊕ is the free commutative monoid over the set of vertices V and the connection function c assigns to each edge e ∈ E a multiset c(e) ∈ V ⊕ of adjacent vertices. Finally, given another multigraph M' = ⟨E',V ', c' : E' → V '⊕⟩, a multigraph morphism f : M → M' is a pair of functions (fE : E → E', fV : V → V ') : M → M' such that f⊕ ◦ c = c' ◦ fE where the homomorphism f⊕ : V ⊕ → E⊕ is the freely adjoined monoid homomorphism of the function fV : V → E.
Now we come to the main technical contribution of this paper, which says that the RMon construction yields a weakly adhesive categories when applied to a weakly adhesive category.
Proposition 4.4 (Weakly adhesive reflected monos) Let C be a weakly adhe- sive category. Then the category of reflected monos RMon(C) is weakly adhesive.



Proof. First one shows that a morphism f›< = ⟨f, f'⟩ : a → b in RMon(C) is monic, if and only if both f and f' are monic in C. Moreover it is straightforward to show that pullbacks along monomorphisms are constructed component-wise.
The main task of the proof consists in showing that also pushouts along monomor- phisms are constructed component-wise. Given a morphism f›< = ⟨f, f'⟩ : a → b and a monomorphism m›< = ⟨m, m'⟩ : a → c, then the candidate for the pushout directly arises from the definition of weakly adhesive categories.






B'	C'
b	c
B

~	⇒






It remains to show that this square satisfies the universal property of pushouts. Hence let ⟨h, h'⟩ : b → e and ⟨k, k'⟩ : c → e be morphisms such that the left one of the following C-diagrams commutes.







B' n'
h'
'
f'




D' g'
A' m'
C'

a

⇒ E	u'  b
d
e	h	n
D
k'
f A	c
m C
g
k

E	u



Now we obtain a pair of morphisms u' : D' → E' and u : D → E such that the right one of these diagrams commutes, since {n', g'} are jointly epic. It remains to show that the pair u',u actually defines a mediating morphism as it then is easy to show that it is unique.
To derive existence, let E' ›u¯− D¯ >d¯⭢ D be a pullback of E' >e⭢ E ›u− D as shown in the left one of the following diagrams.



'	'
m'
f'	'
m'

B' n¯	C'
h'
B' n¯	C'
h'	¯


E'	u¯ b

B
D¯ g¯

d¯
a	k	'
f A	c	⇒
m C

u¯ b

B
g¯


d¯
a	k'
f A	c
m
C

e	h	n	g
k
u
e	h	n	g
D	k
E	u




Now there exist unique C-morphisms n¯ : B' → D¯
and g¯ : C' → D¯
making this

C-diagram commute, which moreover yield pullback squares as illustrated. Then, by the definition of weakly adhesive category, the co-span B' >n¯⭢ D¯ ›g¯− C' is
a pushout of the span B' ›f'− A' >m'⭢ C' as indicated in the right one of the above diagrams. Finally, by straightforward calculation, we obtain an isomorphism i : D' → D¯ satisfying both u' = u¯ ◦ i and d = d¯◦ i, i.e. ⟨u, u'⟩ : d → e is actually a
mediating morphism.		 

Thus we have laid the foundations for discussing the notions of secret and secrecy on an abstract level. To illustrate the idea, we turn back to Example 2.4, and the discussion of secrecy holes in systems that are modelled using the pl-calculus.

Secrecy violations revisited
Having established the theoretical framework, namely reflected monos in weakly adhesive categories, we are now ready to study secrecy related phenomena at a more abstract level. In particular we address the questions of how to describe secrecy holes, of when the private/public separation might be violated, and of how persistence of public information can be ensured.
As for the first point, recall that an immediate secrecy hole in a plc process P
is witnessed by a sub-term of the form v¨ wˆ, which corresponds to the fact, that the
encoding P ) as sketched in section 3 contains a sub-graph of the form v¨	wˆ . More
precisely, the graphical representation of P is actually a marked graph ⟨ P ), fn P⟩⊇

and also
is a marked graph, namely ⟨ v¨
wˆ , v¨ ⟩⊇. Moreover P has an (imme-

diate) secrecy hole if and only if the inclusion ⟨ v¨	wˆ , v¨ ⟩⊇ ⊆ ⟨ P ), fn P⟩⊇ holds in

the category of marked graphs, which is the case if v¨
v¨ ∈ fn P .
wˆ is a sub-graph of P ) and

Now, the first observation is that the marked graph ⟨ v¨	wˆ , v¨ ⟩⊇ is an object
of the category of marked graphs that witnesses a secrecy violation. Hence on the
abstract level, given a category D and a system with states being modelled as objects of the category D, then a state S ∈ D will have a secrecy violation V ∈ D if there is a monomorphism m : V >⭢ S. This leaves us the task of motivating, for the case of D = RMon(C), when an object W'>w⭢W ∈ RMon(C) should be considered as a secrecy violation.



An abstract characterization of secrecy violations
We assume that in applications it is usually clear which parts of a given system are secrecy relevant. This assumption seems harmless in the case of (on-line) banking, where personal identification numbers are clearly secrecy relevant data, and similarly it is obvious that private keys that are used in (asymmetric) cryptographic protocols should remain secret.
by a certain functor R: D → RMon(D) which marks the respective part of each The process of pointing out the secrecy relevant part of a state is formalized object A ∈ D. It is clear that R should satisfy the equation  ƒ ◦ R = idD (see
application of R really yields a monomorphism into any given object A ∈ D. For the paragraph after Definition 4.1 for ƒ : RMon(D) → D), which means that the
the case of D = RMon(C), the value R(a): m >⭢ a at an object A'>a⭢A ∈ RMon(C),
is a C-pullback square A'	M' ; with some abuse of notation, we often will write
A'	RA' in such a situation.
The general idea of a secrecy violation in the category RMon(C) w.r.t. to a
suitable functor R: RMon(C) → RMon2(C), i.e. R satisfies ƒ ◦ R = idRMon(C), is as follows. Given a state modelled by an object S'>s⭢S ∈ RMon(C) with associated
secrecy relevant part R(s): m >⭢ s, resulting in a pullback square S'	M' , the
(completely) private part of the secrecy relevant part M is represented by the

(pseudo-)complement 2 m : M' >⭢ M of m : M' >⭢ M (which exists if the subobject poset over M in C is finite or the category C is sufficiently rich). Now secrecy relevant information is kept private in s provided that M is actually a coproduct
M' >m⭢ M' + M¯ ' ›m¯ < M¯ '
`  ˛¸  x
and there exists some C-arrow l : M' >⭢ M¯ ' satisfying m = m¯ ◦ l. This condition appears to be compatible with the intuition that the (secrecy relevant) private and public data should be located in disjoint parts of the state.
relevant part R(v): n >⭢ v such that either the pseudo-complement n : N' >⭢ N is Conversely, a secrecy violation is an object V '>v⭢V ∈ RMon(C) with secrecy not a co-product injection, or if N' >n⭢ N ›n¯< N¯' is a co-product then n¯ does not
factor through n, i.e. there is no l such that n¯ ◦ l = n.
The running example of the paper can be regained by taking the slice category
G↓T for C. As mentioned in subsection 3.1, taking the “pullback” of a typed graph
A>t⭢T ∈ G↓T along the G-morphism i :	>⭢ T gives rise to an RMon(G↓T )-object

as follows: after constructing the G-pullback
›t'−A' >a⭢A of
>i⭢T ›a−A, which

gives rise to a pullback square A'	A, we can define the RMon(G↓T ) counterpart
of A>t⭢T as a : (i ◦ t') >⭢ t.
This “pullback” construction can be generalized to any monomorphism ϕ : T ' >⭢T in G, and actually gives rise to functors ϕ③ : G↓T → RMon(G↓T ) which act by pulling back along ϕ followed by post-composition with ϕ; functoriality is
a consequence of the universal properties of pullbacks. In the same way, the “global” secrecy relevant part of an G↓T -object is obtained by applying the functor
c③ : G↓T → RMon(G↓T ) where c is the “inclusion”	>⭢ T in G.
Having the two functors c③ and i③ at our disposal, we obtain, for each G↓T -object S, an RMon(G↓T )-object i③ (S) = S' >s⭢ S with a marked public part, and a (global) secrecy relevant part c③ (S) = M >ę⭢ S; taking the pullback S' ›ę'< M' >m⭢ M
of S' >s⭢ S ›ę< M results in the expected pullback square S'	M' . The technical
details of the definition of a suitable functor R: RMon(G↓T ) → RMon2(G↓T ) based
on these pullback constructions are numerous but straightforward.

The fact that the typed graph by inspecting the pullback square
is a secrecy violation can now be recovered


←
↓	↓	,
←


since the pseudo-complement a co-product injection.
>⭢
of the monomorphism
>⭢
is not



2 See for example [9] for a definition.

We remark that the proposed notion of secrecy violation is intimitely related with the private/public distinction. Moreover we are “only” studying those secrecy holes, that have a “topological” or structural representation of the described kind; hence, though it does not appear to be very strict, this restriction needs to be kept in mind during the system modelling process.
We would also like to remark once more that the goal of this paper is not a proposal of a new “concrete” technique: for practical applications working with typed graphs, i.e. with objects of G↓T , is usually sufficient. However, in a manner
of speaking, the category G↓T has too much structure which is not directly relevant.
The aim of this paper now consists in the exploration of ways to describe the “essentials” of secrecy related phenomena using the language of category theory.

Dynamic aspects
So far we have only spoken about properties of system states, modelled as objects of categories of reflected monos, and gave suggestions of how to determine whether private and public areas are disjoint in a given state. However we might also want to reason about the dynamic evolution of a given system.
For example one might ask whether public information will always stay available, or whether it may eventually be lost; this question concerns the transformation rules of the system. Recall that a rule R ›α< K >β⭢ R in a category C is non-deleting
if α is an isomorphism. Now, a simple sufficient condition which ensures that a rule l ›⟨ı,ı'⟩< k >⟨j,j'⟩⭢ r in the category RMon(C) leaves all public information untouched is the requirement that ı' is an isomorphism since this corresponds to the fact that
every application of this rule does not delete anything in the public part of the state to which the rule is applied.

Verifying secrecy properties
We have argued that (at least in certain cases) it is possible to model secrecy violations as objects which have a structure that models disclosure of private information,
the prime example being the marked graph ⟨ v¨	wˆ , v¨ ⟩⊇ in the context of the
graphical representation of the protected links calculus (see Figure 2). In analogy,
suppose that the RMon2(C)-object V '	RV ' models a secrecy violation where C is
a weakly adhesive category and R: RMon(C) → RMon2(C) is a “secrecy relevance” functor. Now, as the results of [2] apply (because RMon2(C) is weakly adhesive by
Proposition 4.4), one can in principle verify that in a system that is modelled by a set of rules {qn = ln ›< kn >⭢ rn | n = 1,..., m} and an object S ∈ RMon2(C)
corresponding to the start state, there is no reachable system state with a secrecy violation, i.e. the system does not have (structural) secrecy holes.
Speaking in Petri net terms, the object V '	RV ' corresponds to a marking, the
rules {qn = ln ›< kn >⭢ rn | n ∈ N} with a start object S in the category RMon2(C) together correspond to a marked Petri net. The fact that no reachable object contains
V '	RV ' is in analogy to the fact that a given “bad” marking is not coverable in
the marked Petri net. Further, in the long rung, the results of [2] might lead to

generalizations of the methods for Petri nets and graph transformation systems (cf. [12]), that allow to automatically verify that a “bad” marking is not coverable.
Conclusion
Based on the recently proposed reflected monos-construction of [10], we have dis- cussed possibilities for abstract, formal counterparts of secrecy related notions, that allow to reason about secret keeping in systems that are faithfully modelled by trans- formation systems in categories of reflected monos. To ensure that transformation systems in categories of reflected monos can be given in terms of double pushout rewriting [6], we have established that the reflected monos construction preserves weak adhesivity in the sense of [2]. Finally, we have sketched how the results of the latter work might eventually lead to automatic verification of secrecy properties, working on the abstract level of weakly adhesive categories.
Acknowledgement
I would like to thank the referees of the interactive reviewing process for their constructive criticism, and Sander Bruggink, Barbara Ko¨nig, and Arend Rensink for enlightening discussions about the content and the presentation of the paper.

References
Abadi, M. and A. D. Gordon, A calculus for cryptographic protocols: The spi calculus, Information and Computation 148 (1999), pp. 1–70.
Baldan, P., A. Corradini, B. Ko¨nig, T. Heindel and P. Sobocin´ski, Unfolding weakly adhesive grammars, submitted.
Blanchet, B., An efficient cryptographic protocol verifier based on prolog rules, in: CSFW (2001), pp. 82–96.
	Corradini, A., U. Montanari, F. Rossi, H. Ehrig, R. Heckel and M. L¨owe, Algebraic approaches to graph transformation – part i: Basic concepts and double pushout approach, in: G. Rozenberg, editor, Handbook of Graph Grammars (1997), pp. 163–246.
Ehrig, H. and B. K¨onig, Deriving bisimulation congruences in the DPO approach to graph rewriting with borrowed contexts, Mathematical Structures in Computer Science 16 (2006), pp. 1133–1163.
	Ehrig, H., M. Pfender and H. J. Schneider, Graph-grammars: An algebraic approach, in: 14th Annual Symposium on Switching and Automata Theory (1973), pp. 167–180.
	Ehrig, H. and U. Prange, Weak adhesive High-Level Replacement categories and systems: A unifying framework for graph and petri net transformations, in: K. Futatsugi, J.-P. Jouannaud and J. Meseguer, editors, Essays Dedicated to Joseph A. Goguen, Lecture Notes in Computer Science 4060 (2006), pp. 235–251.
Gardner, P., C. Laneve and L. Wischik, Linear forwarders, in: R. Amadio and D. Lugiez, editors,
CONCUR 2003, Lecture Notes in Computer Science 2761 (2003), pp. 415–430.
URL http://www.wischik.com/lu/research/linfwd.html
Gr¨atzer, G., “Lattice theory,” W.H. Freeman and Company, San Francisco, 1971.
Kastenberg, H. and A. Rensink, Graph attribution through sub-graphs, submitted.
Kennaway, R., Graph rewriting in some categories of partial morphisms, in: H. Ehrig, H.-J. Kreowski and G. Rozenberg, editors, Graph-Grammars and Their Application to Computer Science, Lecture Notes in Computer Science 532 (1990), pp. 490–504.

K¨onig, B. and V. Kozioura, Augur—a tool for the analysis of graph transformation systems, EATCS Bulletin 87 (2005), pp. 125–137, appeared in The Formal Specification Column.
	Lack, S. and P. Sobocin´ski, Adhesive and quasiadhesive categories, Theoretical Informatics and Applications 39 (2005), pp. 511–546.
Milner, R., J. Parrow and D. Walker, A calculus of mobile processes, i and ii, Information and Computation 100 (1992), pp. 1–40, 41–77.
Prange, U., Algebraic High-Level Nets as Weak Adhesive HLR Categories, Electronic Communications of the EASST 2 (2007).
Wischik, L., “Explicit Fusions: Theory and Implementation,” Ph.D. thesis, Computer Laboratory, University of Cambridge (2001).
URL http://www.wischik.com/lu/research/efti.html

A	Basic Definitions
Definition A.1 (Graphs and morphisms, marked graphs and mappings)

An unlabelled multi-graph is a quadruple G = ⟨V, E, s, t⟩ where V is the set of nodes, E is the set of edges and s, t : E → V are the source and target functions, respectively, which assign to each edge the source and target of the edge, respectively.
W.l.o.g. we assume that nodes and edges are a pair of disjoint sets, i.e. E ∩ V = ∅; then the carrier of G can be deﬁned as the set |G| := E ∪ V .
Next, a graph morphism between two graphs G = ⟨V, E, s, t⟩ and G' = ⟨V ', E', s', t'⟩ is a pair of functions f = ⟨fV : V → V ', fE : E → E'⟩ such that the following two diagrams commute


fE	E'
s	s'
V	fV	V
E	fE
t
V	fV

E'
t'	,
V '

i.e. the two equations fE ◦ s' = s ◦ fV and fE ◦ t' = t ◦ fV are satisﬁed; such a morphism f corresponds to a unique carrier function |f| : |G|→ |G'|.
Given a graph G = ⟨V, E, s, t⟩, then another graph G' = ⟨V ', E', s', t'⟩ is a sub- graph of G if both inclusions G' ⊆ G and V ' ⊆ V hold, and moreover for each edge e ∈ E' the two equations s'(e) = s(e) and t'(e) = t(e) hold. The fact that G' is a sub-graph of G is expressed by G' ⊆ G. If G' is a sub-graph of G then the obvious inclusion morphism is written ıG : G' >⭢ G. Graphs and graph morphsims congregate into the category of graphs G.
We will often identify a graph with its carrier and a graph morphism with the corresponding carrier function.
