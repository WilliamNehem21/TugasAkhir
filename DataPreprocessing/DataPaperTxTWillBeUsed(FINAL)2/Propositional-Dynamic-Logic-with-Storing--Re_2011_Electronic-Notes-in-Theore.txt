

Electronic Notes in Theoretical Computer Science 269 (2011) 95–107
www.elsevier.com/locate/entcs

Propositional Dynamic Logic with Storing, Recovering and Parallel Composition
Mario R. F. Benevides1,2
Computer Science Department and Systems and Computer Engineering Program Federal University of Rio de Janeiro
Brazil
Renata de Freitas1,3 Petrucio Viana1,4
Institute of Mathematics Fluminense Federal University Brazil

Abstract
This work extends Propositional Dynamic Logic (PDL) with parallel composition operator and four atomic programs which formalize the storing and recovering of elements in data structures. A generalization of Kripke semantics is proposed that instead of using set of possible states it uses structured sets of possible states. This new semantics allows for representing data structures and using the five new operator one is capable of reasoning about the manipulation of these data structures. The use of the new language (PRSPDL) is illustrated with some examples. We present sound and complete set of axiom schemata and inference rules to prove all the valid formulas for a restricted fragment called RSP DLo.
Keywords: Propositional Dynamic Logic, Parallel Composition, Modal Logic for Program Specification, Concurrency


Introduction and Motivation
Propositional Dynamic Logic (PDL) [7,14] plays an important role in formal spec- ification and reasoning about sequential programs and systems. It has been used to describe and verify properties as correctness, termination, fairness, liveness and equivalence of programs.
PDL is a multi-modal logic with one modality ⟨π⟩ for each program π. The logic has a set of basic programs and a set of operators (sequential composition,

1 The author was partially supported by grants from CNPq, Capes and FAPERJ
2 Email: mario@cos.ufrj.br
3 Email: naborges@cos.ufrj.br
4 Email: petrucio@cos.ufrj.br

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.03.008

nondeterministic choice, test and iteration) that are used to inductively build the set of non-basic programs. A Kripke semantics can be provided, with a frame F = (W, Rπ), where W is a non-empty set of possible program states and, for each program π, Rπ is a binary relation on W such that (s, t) ∈ Rπ if and only if there is a computation of π starting in s and terminating in t.
In modal logics in general and, consequently, in PDL an state has no internal structure, in the sense that its possible constituents play no role in the process of evaluating a formula in that state. In the last decade, many logical formalisms have been proposed to cope with mutable data structures and updates. Separation Logic [17,21] was proposed to reasoning about imperatives programs with shared mutable data structures, i.e structures with fields that can be updated and ref- erenced in different points of its execution. An interesting extension of this logic was proposed in [15] to deal with concurrency. Moreover, in the field of Epistemic Logic, many formalism have been proposed to deal with the dynamics of knowl- edge in situations like, agent based systems, games and social networks. Logics like Dynamic Epistemic Logic DEL [11] and Public Announcement Logic PAL [20] are examples. These logics must deal with updates and changes of knowledge as actions are performed by the agents or by the environment.
Another weakness PDL suffers is the lack of operators for the treatment of parallelism and concurrence of programs. There are many extensions of PDL to deal with this kind of operators [19,18,2,3,12,16,1,6]. The aim of all these logics is to reasoning about parallel or concurrent programs.
In this work — although it is not our main concern to reasoning about parallel execution of programs — we stay close to the above traditions, proposing an ex- tension of the PDL regular language with a parallel operator and four operators: two to store data and two to recover data. Our language, which we call PRSPDL, is endowed with a semantics based on structured sets, in which the parallel oper- ator together with the projections can be used to represent and manipulate data structures. This semantics is a generalization of Kripke semantics which instead of using a set of possible states uses a structured set of states. The idea of providing structure to a set was inspired in fork algebras [13,9] and has been used in many formalisms [8,22,10].
We start the study of PRSPDL by presenting the system, exemplify its expressive power, and show a completeness result for a fragment of it.
The paper is structured as follows. Section 2 presents the basics on syntax and semantics of the PRSPDL language. Section 3, presents some programs written in PRSPDL language and provide some motivations. Section 4 presents axioms and rules as well as soundness for the restricted system, RSPDL0, obtained from PRSPDL by excluding the iteration, parallel composition and the test operators. Section 5 presents a completeness result for RSPDL0. Finally, section 6 contains some discussion about our contribution and some future works.

Syntax and semantics
The language is the usual PDL language with composition, choice, iteration, and test operators added with four atomic programs s1, s2, r1, r2 and a binary operator of parallel composition. Intuitively, the semantics of these new operators is as follows. It is important to notice that ours states are “ordered pairs“. The intended meaning of the nondeterministc program s1, called store ﬁrst, is to store the current state as the first component of the resulting state, i.e., when the program s1 runs at state s it finishes its running producing a new state (s, t) whose first coordinate is s. Analogously, s2, called store second, stores the current state s as a second coordinate of the resulting state (t, s). The intended meaning of the deterministc program r1, called recover ﬁrst, is to recover a data (state) that is stored at the first component of the current state. When the program r1 runs at state (s, t) it finishes its running at (a recovered) state s, Analogously, the program r2, called recover second, recovers the second component of the current state (s, t) and finishes at state t. Finally, when program π1  π2 runs at state (s1, t1), its effect is to run π1 and π2 in parallel at state s1 and t1 respectively, yielding a new state (s2, t2).
Formally, we have the following definitions:
Definition 2.1 Let Act = {a, b, c, . . .} be the set of basic programs, typically de- noted by α. The PRSPDL programs, typically denoted π, are defined as follows:
π ::= α | π1; π2 | π1 ∪ π2 | π∗ | π1  π2 |?φ | s1 | s2 | r1 | r2.
Definition 2.2 The dynamic modal language with parallel composition, storing and recovering (PRSPDL) is a multi-modal language consisting of a set Φ of countably many propositional symbols, typically denoted by p, q, r,.. ., the boolean connectives
¬ and ∧, and a family of modal operators {⟨π⟩ : π is a PRSPDL program}. The PRSPDL formulas, typically denoted φ, are defined as follows:
φ ::= ⊥| p | ¬φ | φ1 ∧ φ2 | ⟨π⟩φ.
Definition 2.3 A frame is a pair F = (W, {Rπ : π is a program}), where:
W is a non-empty set,
Rπ ⊆ W × W , for each program π.
Definition 2.4 A model is a pair M = (F,V ), where F is a frame and V :Φ → 2W is a valuation function mapping proposition symbols into subsets of W .
Definition 2.5 A model is standard when it satisfies the following conditions:
Rπ1;π2 = Rπ1 ; Rπ2 ,
Rπ1∪π2 = Rπ1 ∪ Rπ2 ,
Rπ∗ = (Rπ)∗,
R?φ = {(w, w) ∈ W 2 : M,w |= φ}.
The main semantical difference between PDL and PRSPDL is that in the later formulas are interpreted on sets of structured states [9].

Definition 2.6 A set of structured states is a triple (S, E, ) where S is a non- empty set, E is an equivalence relation on S, and : S2 → S is injective, i.e., a binary operation satisfying
s1  s2 = t1  t2 iff s1 = t1 and s2 = t2,
for every (s1, s2), (t1, t2) ∈ E.
Definition 2.7 A structured frame is a pair
F = ((S, E, ), {Rπ : π is a program}),
where:
(S, E, ) is a non-empty set of structured states,
Rπ ⊆ E, for each program π,
(S, {Rπ : π is a program}) is a frame.
A structured model is model based on a structured frame.
Definition 2.8 A structured frame F is proper when it satisfies the following con- ditions:
Rs1 = {(s, s  t): s, t ∈ S},
Rs2 = {(t, s  t): s, t ∈ S},
Rr1 = {(s t, s): s, t ∈ S},
Rr2 = {(s t, t): s, t ∈ S},
Rπ1  π2 = {(s1  t1, s2  t2): s1, t1, s2, t2 ∈ S and (s1, s2) ∈ Rπ1 and (t1, t2) ∈ Rπ2 }. A structured model is proper when it is based on a proper structured frame.
Definition 2.9 An PRSPDL model is a proper standard model.
Observe that, in proper standard frames, the relations Rs1 and Rr1 are converse of each other. A similar remark applies to the relations Rs2 and Rr2 . Besides, in proper standard frames, the following properties are true, where IS = {(s, s) : s ∈ S} is the identity relation on S:
Rs1 ; Rr1 = IS	(1)
Rs2 ; Rr2 = IS	(2)
Rs1 ; Rr2 = E	(3)
(Rr1 ; Rs1 ) ∩ (Rr2 ; Rs2 ) ⊆ IS	(4)
Rr1 ; E = Rr2 ; E	(5)
It is important to notice that there are other properties that hold in proper standard frames, but the ones listed above are used in the proofs in the rest of the paper.
Definition 2.10 Let M be a model. The notion of satisfaction of a formula φ in a model M at a state s, notation M,s |= φ is inductively defined as follows:

M,s |= ⊥,
M,s |= p iff s ∈ V (p),
M,s |= ¬φ iff M,s |= φ,
M,s |= φ ∧ ψ iff M,s |= φ and M,s |= ψ,
M,s |= ⟨π⟩φ iff there exists t ∈ S, sRπt and M,t |= φ.
The interpretations of the constant atomic programs s1, s2, r1 and r2 and parallel composition on proper standard models are as expected:
M,s |= ⟨s1⟩ϕ iff there is t ∈ S such that sRs1 t and M,t |= ϕ iff there are t, s2 ∈ S such that t = s s2, and M,t |= ϕ iff there is s2 ∈ S such that M,s s2 |= ϕ. In another words, M,s |= ⟨s1⟩ϕ iff s is the first coordinate of an element standing for an ordered pair in which ϕ is true.
M,s |= ⟨s2⟩ϕ iff there is t ∈ S such that sRs2 t and M,t |= ϕ iff there are t, s1 ∈ S such that t = s1 s, and M,t |= ϕ iff there is s1 ∈ S such that M, s1 s |= ϕ. In another words, M,s |= ⟨s2⟩ϕ iff s is the second coordinate of an element standing for an ordered pair in which ϕ is true.
M,s |= ⟨r1⟩ϕ iff there is t ∈ S such that sRr1 t and M,t |= ϕ iff there are t, s1, s2 ∈ S such that s = s1  s2, t = s1 and M, s1 |= ϕ iff there are s1, s2 ∈ S such that s = s1 s2 and M, s1 |= ϕ. In another words, M,s |= ⟨r1⟩ϕ iff s stands for an ordered pair in whose first coordinate ϕ is true.
M,s |= ⟨r2⟩ϕ iff there is t ∈ S such that sRr2 t and M,t |= ϕ iff there are t, s1, s2 ∈ S such that s = s1  s2, t = s2 and M, s2 |= ϕ iff there are s1, s2 ∈ S such that s = s1 s2 and M, s2 |= ϕ. In another words, M,s |= ⟨r2⟩ϕ iff s stands for an ordered pair in whose second coordinate ϕ is true.
M,s |= ⟨π1  π2⟩ϕ iff there is t ∈ S such that sRπ1  π2 t and M,t |= ϕ iff there are s1, s2, t1, t2 ∈ S such that s = (s = s1 s2) and t = (t1 t2) and s1Rπ1 s2 and t1Rπ2 t2, and M,t |= ϕ. In another words, M,s |= ⟨π1  π2⟩ϕ iff programs π1 and π2 are executed in parallel in s and reach a state t where ϕ holds.
By applying the PRSPDL operators to these basic programs we can define some new useful operators. For instance, we can define the operators in [4,5] which are used in diagrammatic reasoning based on allegories. We also leave this matter for further investigation.
If M,w H ϕ for every state w, we say that ϕ is globally satisﬁed in the model M, notation M H ϕ. If ϕ is globally satisfied in all models M of a frame F, we say that ϕ is valid in F, notation F H ϕ. Finally, if ϕ is valid in all frames, we say that ϕ is valid, notation H ϕ. Two formulas ϕ and ψ are semantically equivalent if H ϕ ↔ ψ.

Examples
In order to illustrate the usage of the PRSPDL language we present four examples. In all of them, we take advantage of the operations of storing and recovering, to

store some data and then recover this data during the computation. One powerful mechanism is the combination of these operations of store/recover with test, it allows for reasoning about properties that holds at previous states in the computation and use this information at the current state. In what follows, we abbreviate ?¬⊥ as 1.
Example 1
In this example, we present a program π1 which when start to run on input u, stores the initial state u at the second coordinate of an ordered pair, then executes actions α and β over the first coordinate of the pair, successively and, after that, returns to the initial state by restoring the second coordinate. This sequence of actions is displayed at the following diagram:
u ¸_s2 /(v/, u) α 1 /(v/, u) β 1 /(v/, u)
0	1	2
r2
When written as a PRSPDL program, π1 can be specified as:
π1 ≡ s2; (α  1); (β  1); r2.

Example 2
In this example, we present a program π2 which when start to run on input u, stores the initial state u at the second coordinate of an ordered pair, then executes action α on the first coordinate of the current pair, until property φ is true, then after that, returns to the initial state by restoring the second coordinate of the current pair.

u ¸_s2 // (чφ?;α 1)s /
φ? 1 /(w/, u)

(v0, u)	/(v1, u)
r2
When written as a PRSPDL program, π2 can be specified as:
π2 ≡ s2; (¬φ?; α  1)٨; (φ?  1); r2.

Example 3
In this example, we present a program π3 which when start to run on input u, stores the initial state u at second coordinate of an ordered pair, then executes action α over the first coordinate of the pair and, after that, if property φ is true at the initial state then it performs action β over the first coordinate of the current pair, else it performs action γ over it. It is important to notice that formula φ is tested at the initial state and not at current state.


u 	s2 /(v/, u)
// (⟨r2;φ?⟩T/)? /	//

0	(v1, u)
(v1, u)
(v2, u)

(⟨r2;чφ?⟩T)?
(v1, u)	(v3, u)

When written as a PRSPDL program, π3 can be specified as:
π3 ≡ s2; (α  1); ((⟨r2; φ?⟩T)?; β  1) ∪ (⟨r2; чφ?⟩T)?; (γ  1).

Example 4
In this example, we present a program π4 which when start to run on input u, stores the initial state u at second coordinate of an ordered pair, then executes action α over the first coordinate of the pair and, after that, it either stores the current state as the second coordinate of an ordered pair, executes action α over the new first coordinate, and returns to the second pair obtained in the computation; or executes action β over the first coordinate of the pair and returns to the initial state.


u ¸¸¸¸s2 /(v/, u)
/(v/, u)	s2 /(v/, (v , u))	/(v/, (v , u))

¸¸¸¸¸ 0
¸¸¸¸¸
1	¸_	2	1	3	1
r

r2 ¸¸¸¸¸¸
β 1	2
J 
(v4, u)

When written as a PRSPDL program, π4 can be specified as:
π4 ≡ s2; (α  1); ((s2; (α  1); r2) ∪ (β  1)); r2.

Axiomatic System for RSPDL0
In this section, we restrict the language presented in Section 2 to a fragment called RSPDL0. In this fragment, we do not allow the use of the operators of test (?), iteration ( ) and parallel composition (  ). We intend to use the work reported in this fragment as a basis for the investigation of the whole language.
Our objective is to present a set of axioms for RSPDL0 and prove soundness and completeness for it with respect to the semantics on structured sets. We use the standard Boolean abbreviations T, V, → and x, and the modal abbreviations [π]φ := ч⟨π⟩чφ, for every program π.
Let RSPDL0 be the modal logic defined by the schemata and rules in Table 1. Axiom 2 is the standard K axiom of distributivity. Axioms 3 and 4 are the standard PDL axioms for composition and non-deterministic choice, respectively. Axiom 5 expresses that the relations Rr1 and Rr2 , interpreting r1 and r2, respectively, are functional. Axiom 6 is the standard temporal axiom expressing that the relations Rs1 and Rr1 (also Rs2 and Rr2 ), interpreting s1 and r1 (also s2 and r2), respectively, are the converse of each other. Axiom 7 expresses that the relations Rr1 and Rr2 , interpreting r1 and r2, respectively, have the same domain. Axiom 8 warrants unicity of ordered pairs. Axioms 9, 10 and 11, in conjunct, express that the relation Rs1;r2 ,
interpreting the composite program s1; r2, is an equivalence relation on its field.
Theorem 4.1 (Soundness) If ▶ ϕ, then ϕ is valid in all RSPDL0 frames.
Proof. The proof of the soundness of the first four axioms are usual.





Axioms
All tautologies
[π](ϕ → ψ) → ([π]ϕ → [π]ψ)
[π1; π2]ϕ x [π1][π2]ϕ
[π1 ∪ π2]ϕ x [π1]ϕ ∧ [π2]ϕ
⟨r1⟩ϕ → [r1]ϕ
⟨r2⟩ϕ → [r2]ϕ
ϕ → [s1]⟨r1⟩ϕ ϕ → [r1]⟨s1⟩ϕ ϕ → [s2]⟨r2⟩ϕ ϕ → [r2]⟨s2⟩ϕ
⟨r1⟩T x ⟨r2⟩T
⟨s1⟩T x ⟨s2⟩T
⟨s1; r1⟩ϕ → [s1; r1]ϕ
⟨s2; r2⟩ϕ → [s2; r2]ϕ
[s1; r2]ϕ → ϕ
ϕ → [s1; r2]⟨s1; r2⟩ϕ
[s1; r2]ϕ → [s1; r2][s1; r2]ϕ

Inference Rules


MP)
Necπ)
φ	φ → ψ ψ
φ


[π]φ




Table 1 RSPDL0 axiomatics.

Axiom 5. We treat just the instances relative to r1. The instances relative to r2
can be treated in a similar way.
Suppose M,s |= ⟨r1⟩ϕ. So, there are s1 and s2 such that s = s1  s2 and
F, V, s1 |= ϕ. Let u ∈ S be any state for which sRr u. By definition, there are sj

1
and sj such that s = sj sj and u = sj . From s = s1 s2 = sj sj
1
and the injectivity

2	1	2	1	1	2
of , we have s1 = sj . Since, M, s1 |= ϕ and u = sj = s1, we have M,u |= ϕ. So,
1	1
we can conclude M,u |= ϕ, for every u ∈ S such that sRr1 u, i.e., M,s |= [s1]ϕ.
Axiom 6. We treat just the instances relative to s1 and r1. The instances relative to s2 and r2 can be treated in a similar way.
Suppose M,s |= ϕ. Let t be such that sRs1 t. Hence, there is a s2 ∈ S such that

t = s  s2. So, there are sj , sj ∈ S such that t = sj  sj and M, sj
|= ϕ, which is

1	2	1	2	1
the same as M,t |= ⟨r1⟩ϕ. So, we can conclude M,t |= ⟨r1⟩ϕ, for every t ∈ S such
that sRs1 t, i,e., M,s |= [s1]⟨r1⟩ϕ.
Now, suppose again that M,s |= ϕ and let t be such that sRr1 t. Hence, there are s1, s2 ∈ S such that s = s1  s2 and t = s1. By definition, s1Rs1 s1  s2. From M,s |= ϕ and s = s1  s2, we have M, s1  s2 |= ϕ. So, there is a u ∈ S such that tRs1 u and M,u |= ϕ, which is the same as M,t |= ⟨s1⟩ϕ. So, we can conclude M,t |= ⟨s1⟩ϕ, for every t ∈ S such that sRr1 t, i,e., M,s |= [r1]⟨s1⟩ϕ.
Axiom 7. We treat just the instance relative to r1 and r2. The instance relative to s1 and s2 can be treated in a similar way.
We have that M,s |= ⟨r1⟩T iff there is some t ∈ S such that sRr1 t and M,t |= T, iff there is some t ∈ S such that sRr t, iff there are t, tj ∈ S such that s = t tj, iff there is some tj ∈ S such that sRr tj, iff there is some tj ∈ S such that sRr tj and
2	2
M, tj |= T, iff M,s |= ⟨r2⟩T.
Axiom 8. We treat just the instance relative to s1 and r1. The instance relative to s2 and r2 can be treated in a similar way.
Suppose M,s |= ⟨s1; r1⟩ϕ. Hence, there are u, v ∈ S such that sRs1 uRr1 v and M,v |= ϕ. Hence, there are u, v, vj, sj ∈ S such that u = s sj, u = v vj, and M,v |= ϕ. By the injectivity of , we have s = v. Hence, M,s |= ϕ. Now, let t ∈ S be such that sRs1;r1 t. Hence, there are u, tj, sj ∈ S such that u = s sj and u = t tj. By the injectivity of , we have s = t. Hence, M,t |= ϕ.
Axiom 9. Suppose M,s |= [s1; r2]ϕ. Hence, for every t ∈ S if sRs1;r2 t, then M,t |= ϕ. Now, since we have sRs1 s s and s sRr2 s, we have sRs1;r2 s. So, we conclude M,s |= ϕ.
Axiom 10. Suppose M,s |= ϕ. Let t ∈ S be such that sRs1;r2 t. Now, since we have tRs1 t s and t sRr2 s, we have tRs1;r2 s. This, together with M,s |= ϕ, gives us M,t |= ⟨s1; r2⟩ϕ. So, we can conclude that M,t |= ⟨s1; r2⟩ϕ, for every t ∈ S such that sRs1;r2 t, i,e. M,s |= [s1; r2]⟨s1; r2⟩ϕ.
Axiom 11. Suppose M,s |= [s1; r2]ϕ. Hence, for every t ∈ S if sRs1;r2 t, then M,t |= ϕ. Let u, v ∈ S be such that sRs1;r2 u and uRs1;r2 v. Since we have sRs1 s v and s vRr2 v, we have sRs1;r2 v, which gives us M,v |= ϕ. Hence, we have M,v |= ϕ for every v ∈ S such that uRs1;r2 v, i.e., M,u |= [s1; r2]ϕ. Moreover, we have M,u |= [s1; r2]ϕ for every u ∈ S such that sRs1;r2 u, i.e. M,s |= [s1; r2][s1; r2]ϕ, as required.	2

Completeness of RSPDL0
System RSPDL0 is the restriction of PRSPDL obtained by the exclusion of the iteration operator ∗, the test operator and the parallel composition operator. A proof system for RSPDL0 was presented in Section 4. In this section, we prove the completeness of this proof system for RSPDL0.
Theorem 5.1 If /▶RSPDL0 ϕ, then there is a model in which ϕ is not valid.
Proof. The canonical model is the structure
Mc = (W c, {Rc : π is a program},V c),
defined as usual:
W c is the set of all maximal consistent sets of formulas,
sRc t iff formula ϕ is in t for every formula [π]ϕ in s,
V cp is the set of all maximal consistent sets of formulas containing p. The canonical frame is the structure Fc = (W c, {Rc : π is a program}).
Observe that we do not have neither that the canonical frame nor the canonical
model is a proper frame or model. This is because we do not have that W c is a structured set. Anyway, by a standard modal logic reasoning, we have:
Lemma 5.2 If a formula ϕ is such that /▶ ϕ, then there is some state w in the canonical model Mc such that Mc,w |= ϕ.
Axioms 3 and 4 warrant that the canonical model is standard.
Lemma 5.3 Mc is standard.

Proof. First, we shall prove Rc
c	c
π1	π2

To prove the inclusion from left to right, suppose Σ and Σj are MCS satisfying

c π1;π2
Σj. First, we prove that the set of formulas Γ = {ϕ : [π1]ϕ ∈ Σ}∪ {ч[π2]ψ :

ψ /∈ Σj} is consistent.  In fact, if Γ ▶ ⊥, then there are ϕ1,..., ϕn such that
[π1]ϕ1,..., [π1]ϕn ∈ Σ and there are ψ1,..., ψm /∈ Σj such that ▶ ϕ1 ∧ ··· ∧ ϕn ∧ ч[π2]ψ1 ∧ ··· ∧ ч[π2]ψm → ⊥. By normality, we obtain ▶ ϕ1 ∧ ··· ∧ ϕn → ([π2]ψ1 V
··· V [π2]ψm). Hence, ▶ [π1]ϕ1 ∧ · · ·∧ [π1]ϕn → [π1]([π2]ψ1 V · · ·V [π2]ψm). So, Σ ▶ [π1][π2]ψ1V· · ·V[π1][π2]ψm. Now, by applying Axiom 3, we have Σ ▶ [π1; π2]ψ1V
··· V [π1; π2]ψm, which, since ΣRc	Σj, implies ψ1 ∈ Σj or ... or ψm ∈ Σj, a
contradiction.
Now, let Σjj be a maximal consistent set such that Γ ⊆ Σjj. For each ϕ such
that [π1]ϕ ∈ Σ, we have ϕ ∈ Γ ⊆ Σjj. Hence, ΣRc Σjj. Besides, let ψ ∈ Σj, that is,
чψ /∈ Σj. We have ч[π2]чψ ∈ Γ ⊆ Σjj, which is the same as ⟨π2⟩ψ ∈ Σjj. Hence,

jj  c
π2
Σj. From these, we obtain ΣRc	c	j

To prove the other inclusion, let Σ and Σj be MCS satisfying ΣRc	c Σj. Let

Σjj be a MCS such that ΣRc
Σjj and ΣjjRc
Σj. Let ϕ ∈ Σj. Hence, ⟨π2⟩ϕ ∈ Σjj,

and so ⟨π1⟩⟨π2⟩ϕ ∈ Σ. Now, by Axiom 3, we have ⟨π1; π2⟩ϕ ∈ Σ which proves

c π1;π2
Σj.

The proof that Rc
c	c
π1	π2
is trivial, using Axiom 4.	2

Axioms 5–11 warrant that relations have the required properties to make W c a structured set.

Lemma 5.4	(i) Relations Rc
and Rc
are functional.

Relations (Rc )—1; Rc  and (Rc )—1; Rc
are injective.

r1	r1	r2	r2

Relations Rc
and Rc
have the same domain.

Relations Rsϕ and Rsϕ are the converse of each other. Also, relations Rsϕ and
s1	r1	s2
Rsϕ are the converse of each other.
Proof. To prove Rc is functional, we proceed as follows. Suppose Σ, Σ1, and Σ2
are MCSs satisfying ΣRc Σ1 and ΣRc Σ2. Let φ ∈ Σ1. Since ΣRc Σ1, we have
r1	r1	r1
⟨r1⟩φ ∈ Σ. Now, by applying Axiom 5, we obtain [r1]φ ∈ Σ, and since ΣRc Σ2, we
have φ ∈ Σ2. Hence, Σ1 ⊆ Σ2. The inclusion Σ2 ⊆ Σ1 can be proved analogously.

The proof that Rc
is functional is entirely similar.

To prove (Rc )—1; Rc is injective, we proceed as follows. Suppose Σ, Σ1, and
r1	r1
Σ2 are MCSs satisfying Σ1(Rc )—1; Rc Σ and Σ2(Rc )—1; Rc Σ. Let φ ∈ Σ1. Since
r1	r1	r1	r1
Σ1(Rc )—1; Rc Σ, there is some MCS Σj such that ΣjRc Σ1 and ΣjRc Σ. Since φ ∈ Σ1
r1	r1	r1	r1
and ΣjRc Σ1, we have ⟨r1⟩φ ∈ Σj. Now, by applying Axiom 5, we obtain [r1]φ ∈ Σj,
and since ΣjRc Σ, we have φ ∈ Σ. Besides, since Σ2(Rc )—1; Rc Σ, there is some MCS
r1	r1	r1
Σjj such that ΣjjRc Σ1 and ΣjjRc Σ. Since ΣjjRc Σ and φ ∈ Σ, we have ⟨r1⟩φ ∈ Σjj.
r1	r1	r1
Again, by applying Axiom 5, we obtain [r1]φ ∈ Σjj, and since ΣjjRc Σ2, we have
φ ∈ Σ2. Hence, Σ1 ⊆ Σ2. The inclusion Σ2 ⊆ Σ1 can be proved analogously.
The proof that (Rc )—1; Rc is injective is entirely similar.
r2	r2
To prove that Rc and Rc have the same domain, we proceed as follows. Suppose
Σ and Σj are MCSs satisfying ΣRc Σj. Since T∈ Σj, we have ⟨r1⟩T ∈ Σ. Now, by applying Axiom 7, we obtain [r2]T∈ Σ and, then there is some MCS Σjj such that
ΣRc Σjj. Hence, the domain of Rc is included in the domain of Rc .
r2	r1	r2
The proof of the other inclusion is entirely similar.

The proofs that Rc
and Rc
are converses, as well the proof of the same property

for Rc and Rc , are as usual in temporal logic, using Axiom 6.	2
Given Σ ∈ W c, let MΣ be the sub-model of Mc, generated by Σ and (Rc )—1; Rc .
r1	r2
By the Generated Sub-model Lemma, we have:
Lemma 5.5	(i) For any Σ ∈ W c, MΣ |= RSPDL0.
If /▶RSPDL0 ϕ, then there is a Σ ∈ W c such that MΣ, Σ |= ϕ.
Relation (RΣ)—1; RΣ is total.
r1	r2
Now we see prove that, given Σ ∈ W c, the model MΣ has enough nice properties to be the counter-model we need. In fact, by applying a reasoning similar to that employed in [9], we can prove that MΣ is indeed a model of RSPDL0, i.e. that

W Σ is a structured set. More specifically, since Rs , Rr , Rs and Rr
are programs

of RSPDL0 and since they satisfy Lemmas 5.4 and 5.5, we have that Rs , Rr , Rs
1	1	2
Σ	Σ
and Rr2 are functional relations sharing the same domain, covering W  × W  , and

warranting unicity of ordered pairs. These conditions suffice to define an injective
function  : W Σ × W Σ → W Σ for which Rs = {(w, w  v) : w, v ∈ W Σ}, Rs =

{(v, w v) : w, v ∈ W Σ}, Rr w, v ∈ W Σ}, as follows.
= {(w  v, w) : w, v ∈ W Σ}, and Rr
= {(w  v, v) : 

Define f ⊆ (W Σ × W Σ) × W Σ in the following way, for all w, v, u ∈ W Σ:
((w, v), u) ∈ f iff (u, w) ∈ Rr1 and (u, v) ∈ Rr2 .
We have that f is an injective functional relation. All these facts together allow us to define  : W Σ × W Σ → W Σ by setting:
w  v = f (w, v),
for any pair (w, v) ∈ W Σ × W Σ. From this definition it is obvious that


w v = u iff (u, w) ∈ Rr1 and (u, v) ∈ Rr2 ,
for any (w, v) ∈ W Σ × W Σ and u ∈ W Σ, and this gives us Rs

= {(w, w  v) : 

w, v ∈ W Σ}, Rs
= {(v, w  v) : w, v ∈ W Σ}, Rr
= {(w  v, w) : w, v ∈ W Σ}, and

Rr2
= {(w  v, v): w, v ∈ W Σ}.
To conclude the proof just observe that f is functional and injective, and Domf =

W Σ × W Σ. This is what we need to show that MΣ is a proper model.	2
Final Remarks
This paper starts the study of PRSPDL, an extension of the PDL regular language with a parallel operator and four operators: two to store data and two to recover data. More specifically, we exemplify the expressive power of PRSPDL and present an axiomatization for a restrict fragment, RSPDL0, without parallel composition, iteration and test and provide a proof of completeness for this fragment.
The semantics of PRSPDL is a generalization of Kripke semantics with a notion of structured set of possible states instead of sets of states. Structured sets allows one to represent structured data in a very natural way, as we show in some specific examples.
There are many possibilities for future work, we just list the most prominent. First, we would like to establish decidability and complexity issues for the fragment RSPDL0. Second, we would like to provide an axiomatization for PRSPDL with parallel composition, iteration and test, provide a proof of completeness, and inves- tigate decidability and complexity questions for it. Finally, it would be interesting to have some application of the PRSPDL language in specification of properties of programs with mutable data structures and updates.

References
Abrahamson, K., “Decidability and expressiveness of logics of processes,” Ph.D. thesis, Ph.D. Dissertation, Department of Computer Science, University of Washington (1980).

Benevides, M. and L. Schechter, A propositional dynamic logic for CCS programs, in: Proceedings of the XV Workshop on Logic, Language, Information and Computation, LNAI 5110 (2008), pp. 83–97.
Benevides, M. and L. Schechter, A propositional dynamic logic for concurrent programs based on the π-calculus, in: Proceedings of Methods for Modalities, Electronic Notes in Theoretical Computer Science ENTCS 262 (2010), pp. 49–64.
Brown, C. and G. Hutton, Categories, allegories and circuit design., in: Proc. Ninth Annual IEEE Symp. on Logic in Computer Science (1994), pp. 372–381.
Brown, C. and A. Jeffrey, Allegories of circuits., in: Proc. Logical Foundations of Computer Science
(1994), pp. 56–68.
dos Santos, V., “Concorrˆencia e Sincroniza¸c˜ao para L´ogica Dinˆamica de Processos,” Ph.D. thesis, Federal University of Rio de Janeiro (2005).
Fischer, M. and R. Ladner, Propositional dynamic logic of regular programs, Journal of Computer and System Sciences 18 (1979), pp. 194–211.
Freitas, R., P. Viana, M. Benevides, S. Veloso and P. Veloso, Squares in fork arrow logic, Journal of Philosophical Logic 32-4 (2003).
Frias, M., “Fork Algebras in Algebra, Logic and Computer Science,” Advances in Logic, Vol. 2, World Scientific, 2002.
Frias, M., P. Veloso and G. Baum, Fork algebras: past, present and future, Journal of Relational Methods in Computer Science 1 (2004), pp. 181–216.
Gerbrand, J. and W. Groeneveld, Reasoning about information change, Journal of Logic, Language and Information 6 (1997), pp. 147–169.
Goldblatt, R., Parallel action: Concurrent dynamic logic with independent modalities, Studia logica 51
(1992).
Haeberer, A., M. Frias, G. Baum and P. Veloso, Fork algebras, in: W. K. C. Brink and G. Schmidt, editors, Relational Methods in Computer Science, Springer, Viena, 1997 .
Harel, D., D. K. D. and Tiuryn, “Dynamic Logics,” MIT Press, 2000.
Hoare, T. and P. P. O’Hearn, Separation logic semantics for communicating processes, Electron. Notes Theor. Comput. Sci. 212 (2008), pp. 3–25.
Mayer, A. and L. Stockmeyer, The complexity of pdl with interleaving, Theoretical Computer Science
161-1-2 (1996).
O’Hearn, P., J. Reynolds and H. Yang, Local reasoning about programs that alter data structures, in:
Lecture Notes in Computer Science, Computer Science Logica 2142 (2001), pp. 1–19.
Peleg, D., Communication in concurrent dynamic logic, Journal of Computer and System Sciences 35
(1987), pp. 23–58.
Peleg, D., Concurrent dynamic logic, Journal of the Association for Computing Machinery 34 (1987),
pp. 450–479.
Plaza, J., Logics of public communications, in: Proceedings of 4th Intrenational Symposium on Methodologies for Intelligent Systems, 1989, pp. 201–216.
Reynolds, J., Separation logic: A logic for shared mutable data structures, in: Proceedings of 7th Annual IEEE Symposium on Logic in Computer Science (2002), pp. 55–74.
Veloso, P., R. Freitas, P. Viana, M. Benevides and S. Veloso, On fork arrow logic and its expressive power, Journal of Philosophical Logic 36-5 (2007).
