	Electronic Notes in Theoretical Computer Science 167 (2007) 95–115	
www.elsevier.com/locate/entcs

On the Complexity of the Pancake Problem
Fuxiang Yu1 ,2
Department of Computer Science State University of New York Stony Brook, NY, U.S.A.

Abstract
We study the computational complexity of finding a line that bisects simultaneously two sets in the two-dimensional plane, called the pancake problem, using the oracle Turing machine model of Ko. We also study the basic problem of bisecting a set at a given direction. Our main results are: (1) the complexity of bisecting a nice (thick) polynomial-time approximable set at a given direction can be characterized by the counting class #P ; (2) the complexity of bisecting simultaneously two linearly separable nice (thick) polynomial-time approximable sets can be characterized by the counting class #P ; and (3) for either of these two problems, without the thickness condition and the linear separability condition (for the two-set case), it is arbitrarily hard to compute the bisector (even if it is unique).
Keywords: Computational complexity, the pancake problem, #P , complexity theory of real functions.


Introduction
Given two Lebesgue measurable sets of arbitrary shapes in the two- dimensional plane R2, there exists a line that simultaneously bisects them (i.e., the line cuts each set into two parts of equal area). This is the famous Pancake Theorem, or, the two-dimensional version of a more general Ham Sandwich Theorem. These theorems are related to two fundamental theo- rems, the Brouwer Fixed Point Theorem and the Borsuk-Ulam Theorem, in

1 This material is based upon work supported by National Science Foundation under grant No. 0430124. The author is grateful to his advisor, Professor Ker-I Ko, for valuable discussions and his support.
2 Email: fuxiang@cs.sunysb.edu





1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.08.009

topology (see, e.g., Fulton [5]).
The Pancake Theorem leads to a computational problem, called the pan- cake problem, of finding the line, called the bisector (or pancake/ham sandwich cut in literature), that simultaneously bisects two given regions. In this pa- per, we study the computational complexity of the pancake problem. It has been well studied for the cases where the sets in question are polygons (see, e.g., [12,1]), or are composed of a finite number of points (in this case, the measure is the number of points instead of the area; see, e.g., [8,9,4]). Here, we consider the general cases where the sets may be subsets of the plane R2 of more complicated shapes.
In order to study the pancake problem for arbitrary subsets S1 and S2 of R2, we need to fix a specific model for representing such sets and measure the computational complexity accordingly. In this paper, we apply the model of Turing-machine based complexity theory of real functions to this prob- lem, and focus on the case where the sets S1 and S2 have polynomial-time representations, as introduced by Ko [7] and Chou and Ko [2]. That is, we assume that sets S1 and S2 are polynomial-time approximable, polynomial- time recognizable, or are bounded Jordan domains with polynomial-time com- putable boundaries, and investigate whether the corresponding bisectors are polynomial-time computable.
We also consider two related problems: (1) for a fixed angle α ∈ [0, π) (e.g., α = π/2), computing the bisector L of a set S such that the angle from the positive x-axis to L is α; and (2) computing two lines that are perpendicular to each other and divide a set S into four parts of equal area. Our main results use discrete complexity class #P and other related classes to characterize the complexity of the bisectors. They can be summarized as follows:
These problems are all solvable if the sets in question are polynomial- time approximable and there exists a unique bisector (or a unique pair of lines for the problem of dividing a set into four parts). However, there are no fixed complexity bounds even if the sets have sufficient polynomial-time represen- tations. For example, it can be arbitrarily hard to compute two lines that are perpendicular to each other and divide a polynomial-time approximable set S into four parts of equal area, even if S is also polynomial-time recogniz- able and convex, and has a polynomial-time computable Jordan curve as the boundary.
The complexity of finding the vertical bisector L of a polynomial-time approximable set S has a lower bound of P #P1[1] and an upper bound of P #P , provided that S is suﬃciently thick around L. Here P #P is the class of languages A such that A is polynomial-time decidable with a #P function as an oracle, #P1 is the unary version of #P , and the notation [1] in P #P1[1]

means that the oracle is only queried once.
The complexity of finding the bisector L that bisects two P - approximable sets S1 and S2 has a lower bound of P #P1[1] and an upper bound of P #P , provided that S1 and S2 are linearly separable (i.e., S1 and S2 are on different sides of some line) and both S1 and S2 are suﬃciently thick around their own bisectors at all angles.
We give, in Section 2, a brief summary of the basic computational model of the Turing machine-based complexity theory of real functions, as well as the exact definition of the above discrete complexity classes. For more careful discussion of the theory, see Ko [7] and Chou and Ko [2]; for the discrete complexity classes related to #P , see, for example, Du and Ko [3] and Green et al. [6].

Preliminary
Basic notation
This paper involves notions used in both discrete computation and continuous computation. The basic computational objects in discrete computation are integers and strings in {0, 1}∗. The length of a string w is denoted l(w). We write ⟨w1, w2⟩ to denote the pairing function on w1 and w2. We write ||S|| to denote the number of elements in a (finite) set S.
The basic computational objects in continuous computation are dyadic rationals D = {m/2n : m ∈ Z,n ∈ N}, and we denote Dn = {m/2n : m ∈ Z}. Each dyadic rational d has infinitely many binary representations with arbitrarily many trailing zeros. For each such representation s, we write l(s) to denote its length. If the specific representation of a dyadic rational d is understood (often the shortest binary representation), then we write l(d) to denote the length of this representation.
We use R to denote the real line (and the class of real numbers) and R2 the 2-dimensional plane. We often use letters in math bold font, such as z, or two letters in brackets, such as ⟨x, y⟩, to represent a point in R2. For any point z ∈ R2 and any set S ⊆ R2, we let dist(z, S) be the distance between z and S; that is, dist(z, S)= inf{|z−z'| : z' ∈ S}, where |·| denotes the absolute value. For two sets S1, S2 ⊆ R2, we let dist(S1, S2)= inf{|z1 − z2| : z1 ∈ S1, z2 ∈ S@} be the distance between S1 and S2. The complement of a set S is written as Sc, the closure of a set S is written as S, and the boundary of a set S is written as ∂S.
We say a function φ : N → D binary converges to (or represents) a real number x, or φ is a Cauchy function of x, if (i) for all n ≥ 0, φ(n) ∈ Dn, and (ii) for all n ≥ 0, |φ(n) − x| ≤ 2−n. For any x ∈ R, let CFx denote the

set of functions that binary converge to x. Among functions CFx there is a unique function bx : N → D that satisfies the condition x − 2−n < bx(n) ≤ x for all n ≥ 0. We call this function bx the standard Cauchy function for x. We say two functions φx, φy : N → D binary converge to (or represent) a point z := ⟨x, y⟩ ∈ R2 if φx and φy binary converge to two real numbers x and y, respectively.
Complexity classes
The fundamental complexity classes we are interested in are the class P of sets accepted by deterministic polynomial-time Turing machines, and the class FP of functions (mapping strings to strings) computable by deterministic polynomial-time Turing machines. We will also use in this paper the counting class #P , i.e., the class of functions that count the number of accepting paths of nondeterministic polynomial-time machines.
A set T ⊆ {0, 1}∗ is called a tally set if T ⊆ {0}∗. For a complexity class C
of sets of strings in {0, 1}∗, we let C1 denote the complexity class {A ∈C : A ⊆
{0}∗}. Similarly, for a complexity class FC of functions from {0, 1}∗ to {0, 1}∗, we let FC1 denote the complexity class {F ∈ FC : the domain of F is {0}∗}. In this paper, we will use complexity classes FP1, P1 and #P1.
The following properties of the complexity class #P are well known (see Du and Ko [3] and Green et al. [6]) and are useful in our constructions in Section 3.
Proposition 2.1 Let f : {0, 1}∗ → N be a function. The following are equiv- alent:
f ∈ #P.
There exist a polynomial-time computable predicate R and a polynomial p that for all inputs of length n, f (x) is equal to the number of strings y of length p(n) such that R(x, y), i.e., f (x)= ||{y : l(y)= p(l(x)), R(x, y)}||.
Computational model for continuous computation
To compute a real-valued function f : R → R, we use oracle Turing machines as the computational model. An oracle Turing machine M is an ordinary Turing machine equipped with an extra query tape and two extra states: the query state and the answer state. The machine M makes a query to an oracle function φ : N → D as follows: First, it writes an integer k on the query tape, then enters the query state and waits for the answer φ(k). The oracle φ then reads the input k, replaces the integer k on the query tape with φ(k), then places the machine M on the answer state. After the machine M enters the answer state, it continues like ordinary machines; in particular, it can read

φ(k) off the query tape. The action from the query state to the answer state counts only one machine step. We use Mφ(n) to denote the output of machine M with regard to an input n and an oracle φ. We say an oracle Turing machine M operates in polynomial time if there exists a polynomial p such that for all inputs n and all oracles φ, Mφ(n) halts in time p(n).
Definition 2.2 (a) A function f : [0, 1] → R is said to be computable if there is an oracle Turing machine M that, on an oracle function φ : N → D that binary converges to a real number x and an input n ∈ N, outputs a string d ∈ Dn such that |d − f (x)|≤ 2−n.
A function f : [0, 1] → R is polynomial-time computable if it is com- putable by an oracle Turing machine that operates in polynomial time.
When an oracle φ used by M is the standard Cauchy function bd for a dyadic rational d, we can simulate the computation of M using d as an input instead of an oracle. To emphasize this fact, we write Md instead of Mbd to denote that the oracle is the standard Cauchy function of d.
The following equivalent definition for polynomial-time computable real functions f is useful. We say a function f : [0, 1] → R has a polynomial modulus if there exists a polynomial p such that |x − y| ≤ 2−p(n) implies
|f (x) − f (y)|≤ 2−n.
Proposition 2.3 A function f : [0, 1] → R is polynomial-time computable if and only if
f has a polynomial modulus, and
There exist a Turing machine M and a polynomial p such that for any integer n and any d ∈ Dm, M(d, n) outputs, in time p(m + n), a dyadic rational number e such that |e − f (d)|≤ 2−n.
The notions of computable and polynomial-time computable real functions can be extended naturally to functions f : R → R2 and functions f : R2 → R2. For instance, the machine computing a function from R2 to R2 will use two oracles φ and ψ, representing two real numbers x and y, and will output two dyadic rationals e1 and e2, such that |⟨e1, e2⟩− f (⟨x, y⟩)|≤ 2−n.
A Jordan curve (simple, closed curve) Γ in R2 is polynomial-time com- putable if there exists a polynomial-time computable function f : [0, 1] → R2 such that the range of f is Γ, f is one-to-one on [0, 1) and f (0) = f (1). It is well known that the interior S of a Jordan curve Γ is a simply connected domain, which is called a Jordan domain. If Γ is polynomial-time computable, we say S is a polynomial-time Jordan domain.
Besides polynomial-time Jordan domains, we also consider the following two other kinds of subsets in R2, which were introduced in Chou and Ko [2].

Given an oracle Turing machine M and a set S ⊆ R2, for n ∈ N, we define an error set En(M) as the set of all z ∈ R2 having a Cauchy function repre- sentation ⟨φ, ψ⟩ such that Mφ,ψ(n) /= χS(z), where χS(z) is the characteristic function defined on R2 such that χS(z) = 1 iff z ∈ S, and μ∗ is the outer Lebesgue measure.
Definition 2.4 (a) We say a set S ⊆ R2 is polynomial-time approximable (or simply P-approximable) if there exists a polynomial-time oracle Tur- ing machine M such that for any input n, the error set En(M) has size μ∗(En(M)) ≤ 2−n.
We say a set S ⊆ R2 is polynomial-time recognizable (or simply P- recognizable) if there exists a polynomial-time oracle Turing machine M such that Mφ,ψ(n)= χS(z) whenever ⟨φ, ψ⟩ represents a point z whose distance to ΓS is > 2−n (where ΓS is the boundary of S); i.e., En(M) ⊆ {z : dist(z, ΓS) ≤ 2−n}.
The above two concepts are not equivalent by Chou and Ko [2]: there exists a Jordan domain S that is P -recognizable but not P -approximable; the polynomial-time probabilistic class BPP collapses to P if all P -approximable sets are P -recognizable. On the other hand, while there exists a P -recognizable set S whose measure is not recursive, the measure of a P -approximable set is polynomial-time computable relative to an oracle in #P . When we present negative results in this paper, we often construct sets that are both P -approximable and P -recognizable (P-approximable/recognizable, for short), and show the complexity of bisecting these sets is arbitrarily high.
Because the Lebesgue measure is consistent with area of the traditional sense (e.g., if S is a rectangle, μ(S) is the area of S), hereafter we use area and the Lebesgue measure interchangeably. Note that there exists a set S ⊆ R2 that is not measurable. However, in this paper we only consider measurable sets S, especially P -approximable/recognizable sets and polynomial-time Jor- dan domains.

Bisecting one set
¿From now on, unless specified otherwise, by “bisecting” a set we mean “divid- ing” a subset of R2 into two parts of equal area using a line, and by “bisector” of a set we mean a line that bisects the set. The Pancake Theorem states that two bounded sets have a common bisector. We first study the complexity of bisecting one set.
Let S be a bounded set in R2. Fix an angle α ∈ [0, π). If the angle from the positive x-axis to a line L is α, we say that L is at angle α. It is easy

to see that there exists a bisector L of S at each angle α. It is possible that there is another bisector L' of S at the same angle α. In this case, the area of the part of S between L and L' is zero, and any line between L and L' that is parallel to L is a bisector of S at angle α. Then, the complexity of some bisector can be very high. We assume that this does not happen and assume that there exists a unique bisector of S at any fixed angle α.
Definition 3.1 Let S be a bounded set in R2. A line L defined by x = a divides S into two parts, with the left part denoted Sx≤a and the right part Sx≥a. We define the thickness of S at L, denoted thkS(L), as the greatest lower limit of the area change of Sx≤a when moving L parallelly, that is,


thkS
(L) = lim inf area(Sx≤a+δ) − area(Sx≤a) .

δ→0	δ
For a line L at an angle α ∈ [0, π), we can also define thkS(L) in a similar way. More precisely, we rotate S and L about the origin by an angle π/2 − α to obtain S' and L', respectively, and define thkS(L)= thkS' (L').
It is obvious that for any line L at any angle α ∈ [0, π), thkS(L) is non- negative. If S is a convex Jordan domain, then thkS(L) is the length of the chord L ∩ S. If L is a bisector of S at angle α such that thkS(L) > 0, then L is the unique bisector of S at angle α. Note that it is possible that thkS(L) > 0, but for any ϵ > 0, there exists a line L' such that L' is parallel to L and dist(L, L') < ϵ, but thkS(L')= 0. We say S has a positive thickness around a line L if there exist two positive real numbers ϵ and δ, such that if L' is a line parallel to L with dist(L, L') < ϵ, then thkS(L') > δ.
If for a set S and an angle α, there are two bisectors L and L', then thkS(L) = thkS(L') = 0. However, it is possible that there exists a unique bisector L of S at angle α even if thkS(L) = 0. Below we show that the complexity of finding such a bisector can be arbitrarily hard, while a positive thickness around a bisector reduces the complexity (see Theorem 3.3).
Theorem 3.2 Let b ∈ (0, 1) be a computable number. There exists a P- approximable/recognizable set S ⊆ [0, 1]2 such that the line L deﬁned by x = b is the unique bisector of S at angle π/2; furthermore, thkS(L) = 0 and for any line L' deﬁned by x = b', where b' ∈ (0, 1) − {b}, thkS(L') > 0.
Proof. We construct a P -approximable/recognizable set S such that (1) the boundary of S is the union of line segment {⟨x, 0⟩ : x ∈ [0, 1]} and the image of a polynomial-time computable function f , and is of a finite length; and (2) the set S is “symmetric” with respect to the bisector.
We assume that b is not a dyadic since, if b is a dyadic, it is very easy

to construct a polygon whose vertical bisector is defined by x = b. Let φ be a computable Cauchy function in CFb and let t : N → N be a computable function which bounds the runtime of the function φ. We assume that t(k) ≥ 2k for all k ∈ N. We inductively define two sequences {dk } and {dk} of dyadic numbers in [0, 1]:

d1 = 0; d1 = 1;
dk = max{dk−1, φ(k) − 2−k},

dk = min{dk−1, φ(k)+ 2−k}, k ≥ 2. We observe that for any k ≥ 2,

0= d1 ≤ d2 ≤ dk ≤ dk+1 < b < dk+1 ≤ dk ≤ d2 ≤ d1 = 1,

and that dk k2 + k.
and dk are computable in time O(s(k)), where s(k)= Σk
t(i) ≥

Let I1 ⊆ N be a set of indices such that i ∈ I1 if and only if di+1 > di; in other words, {di}i∈I1 is the largest strictly increasing subsequence of the increasing subsequence {di}i∈N. Similarly, let I2 ⊆ N be a set of indices such that i ∈ I2 if and only if di+1 < di. Note that since b is not a dyadic, both I1 and I2 contain infinitely many elements. Let am,n be the n-th smallest number in Im, where m ∈ {1, 2} and n ∈ N. For any n ∈ N, let i denote a1,n and j denote a1,n+1, h1 = max(a1,n+1, a2,n+1) and h2 = max(a1,n+2, a2,n+2). We note that dj − di ≥ 2−j since dj − di is a positive dyadic in Dj. We call [di, dj ] the n-th interval of the first kind. The part of set S between two lines x = di and x = dj is a pentagon of area 2−(2s(h1 +1)+1); more precisely, the five vertices of the pentagon are ⟨di, 0⟩, ⟨di, 2−2s(h1+1)⟩, ⟨(di +dj )/2, 2−2s(h1+1)/(dj − di) − (2−2s(h1+1) + 2−2s(h2 +1))/2⟩, ⟨dj, 2−2s(h2+1)⟩, and ⟨dj, 0⟩; we denote this pentagon Pi,j,h1,h2 . Similarly we define the other parts of S according to I2 (e.g., we will have the n-th interval of the second kind).


di  n−th interval dj
of 1st kind
b	n−th interval
of 2nd kind

Fig. 1. The set S consisting of pentagons.
We can see that the line x = b is the unique bisector of S at angle π/2,

since from the construction of S, for any n ∈ N, the pentagon associated with the n-th interval of the first kind and that associated with the n-th interval of the second kind are of the same area. Note that the boundary of S is the union of the unit interval [0, 1] on the x-axis and the set {⟨x, f (x)⟩ : x ∈ [0, 1]}, where the function f is easy to obtain from the construction of S above. We first show that f is polynomial-time computable by proving that f satisfies both conditions in Proposition 2.3. Indeed, it is easy to see that f has a linear modulus of continuity since, for each n ∈ N, let i = a1,n, j = a1,n+1, h1 = max(a1,n+1, a2,n+1) and h2 = max(a1,n+2, a2,n+2), then we have s(h1+1) ≥
2−2s(h1 +1)/(d −d )
h2 +1 ≥ j, |d − d | ≥ 2−j ≥ 2−s(h1+1) and 	j	i  < 2, which implies

1	j	i
(dj −di)/2

that the derivative (which exists almost everywhere) of f is between −2 and
2; furthermore, we can see that the boundary of S is of a finite length. Next we show that for any two integers m, n ∈ N and any dyadic d ∈ Dm ∩ [0, 1], a dyadic e can be computed in time O(m + n) such that |e − f (d)| < 2−n by the following algorithm:
Compute in time O(n) an integer k such that k = max{i : s(i) ≤ n} by simulating a machine M with time bound t that computes φ as follows: Let M compute one by one φ(1), φ(2), ·· ·, and halt after n moves, now k is the maximum number such that φ(k) is computed in this process. (Note that the simulation may have started to compute φ(k + 1) but it is not ﬁnished since it is terminated after n moves. In this case s(k) ≤ n < s(k + 1). )
Compute in time O(n) the (multi)set {di, di : i ≤ k}, I' := I1 ∩
{1, 2, ··· ,k − 1}, and I' := I2 ∩ {1, 2, ··· ,k − 1}.  (Note that it may
take more than n moves to decide whether k ∈ I1 (or k ∈ I2), but we do not need this result. This step can be combined with step (1).)
Compute in time O(k2) three integers q = min(||I' ||, ||I' ||), i0 = a1,q and
1	2
j0 = a2,q. Check in time O(m + k) whether d ∈ [di0 , dj0 ], d < di0 , or
d > dj0 : if d ∈ [di0 , dj0 ], let e = 0 and halt; if d < di0 , go to step (4); if
d > dj0 , go to step (5).
Compute in time O(k2 + m) = O(n + m) three integers l < q, i = a1,l
and j = a1,l+1 such that d ∈ [di, dj ]. There are two sub cases:
(4.1) l = q − 1. Compute in time O(k2) an integer h1 = max(a1,q, a2,q). We have h2 := max(a1,q+1, a2,q+1) > k (we do not compute h2 now) and
s(h2) > n. The quadrangle P '	with vertices ⟨di, 0⟩, ⟨di, 2−2s(h1+1)⟩,
⟨(di + dj )/2, 2−2s(h1+1)/(dj − di) − 2−2s(h1+1)/2⟩ and ⟨dj, 0⟩ is an ap- proximation to the pentagon Pi,j,h1,h2 with error ≤ 2−2s(h2+1) < 2−2n. Do an interpolation in time O(m + n + j + s(h1 + 1)) = O(m + n) on

'
i,j,h1
to obtain an approximation e to f (d) such that |e−f (d)| < 2−n

and halt.
(4.2) l < q − 1.  Compute in time O(k2) two integers h1 = max(a1,l+1, a2,l+1) and h2 := max(a1,l+2, a2,l+2). (Now the pentagon Pi,j,h1,h2 is exactly the part of S between lines x = di and x = dj.) Do an interpolation in time O(m + n + j + s(h1 + 1) + s(h2 + 1)) = O(m + n) on Pi,j,h1,h2 to obtain an approximation e to f (d) such that
|e − f (d)| < 2−n and halt.
(It is similar to step (4) and is omitted.)
We can see that the above algorithm takes time O(m + n) since each step takes time O(m + n). Also from the algorithm, for the cases of d < di0 and d > dj , an approximation e to f (d) with an error ≤ 2−n is obtained. We need to show that if d ∈ [di0 , dj0 ], e = 0 is an approximation to f (d) with an error < 2−n, that is, |f (d)| < 2−n. Without loss of generality, assume that d ∈ [di0 , b), then there exists an integer l ≥ q such that d ∈ [di, dj ], where i = a1,l, j = a1,l+1; that is, d is in the l-th interval of the first kind. Let h1 = max(a1,l+1, a2,l+1) and h2 = max(a1,l+2, a2,l+2). From the definition of q, h2 > h1 ≥ k. Then f (d) is decided by the pentagon Pi,j,h1,h2 . Since h1 ≥ k, s(h2 + 1) > s(h1 + 1) ≥ s(k + 1) > n, and |f ((di, dj )/2)| = 2−2s(h1+1)/(dj − di) − (2−2s(h1+1) + 2−2s(h2+1))/2 < 2−n, we have |f (d)| < 2−n, which completes the proof that f is polynomial-time computable.
In order to check whether a point ⟨x, y⟩ is in S, we check whether 0 < y <
f (x). As f is polynomial-time computable, S is P -recognizable. Note that f (b) = 0, and the boundary of S is the union of two Jordan curves and of a finite length, it follows that S is also P -approximable (Chou and Ko [2]). It is also easy to check that thkS(L) = 0 and for any line L' defined by x = b', where b' ∈ (0, 1) − {b}, thkS(L') > 0: f is continuous, thus for any line Lr defined by x = r, where r ∈ (0, 1), thkS(Lr)= f (r); furthermore, f (r) > 0 iff r /= b.	 
Theorem 3.2 is a negative result for the case where the thickness of the set S at a bisector is zero. Next we prove a positive result for the case where S has a positive thickness around a bisector.
Let S be a P -approximable set with a positive thickness around a bisector
Lα at an angle α. Without loss of generality, we consider the case α = π/2.
Theorem 3.3 In the following, (a) ⇒ (b) ⇒ (c):
FP = #P .
For any P-approximable set S ⊆ [0, 1]2 that has a positive thickness W > 0 around the unique vertical bisector L deﬁned by x = b, the real number b is polynomial-time computable.

FP1 = #P1.
Proof. (a) ⇒(b). We define a function g : [0, 1] → R2 such that g(t) = area(Sx≤t) − area(Sx>t), where Sx≤t = {⟨x, y⟩ ∈ S : x ≤ t} and Sx>t = S − Sx≤t. Then b is the root of g(x). We will show that the function g is polynomial-time computable under the condition FP = #P . The function g is increasing and furthermore, since S has a positive thickness around the vertical bisector L, we have |area(Sx≤b+δ)−area(Sx≤b)|≥ |δ|·thkS(L)/2 when δ is sufficiently small, which means that g has a polynomial inverse modulus near b. According to Corollary 4.7 of Ko [7], the root b of g(x) can be computed in polynomial time by binary search.
Now we show how to compute g in polynomial time. First, g has a lin- ear modulus of continuity, because S ⊆ [0, 1]2 and by the definition of g,
|g(t1) − g(t2)| ≤ |t1 − t2| for t1, t2 ∈ [0, 1]. Then by Proposition 2.3, we only need to show that the values of g at dyadic points can be approximated in polynomial time. Since S is P -approximable, there exists a polynomial-time oracle Turing machine M such that for any input n, the error set En(M) has size μ∗(En(M)) ≤ 2−n. Let p be a polynomial function that bounds M. Without loss of generality, assume that p(n) > n.
For n ∈ N and t ∈ Dn ∩ [0, 1], consider the following two sets:
A(n, t)= {⟨d1, d2⟩∈ D2	: d1 < t, Md1 ,d2 (n)= 1};
B(n, t)= (Dp(n) ∩ [0, t)) × (Dp(n) ∩ [0, 1]) − A(n, t).

For x, y, d ∈ R with d > 0, let N(⟨x, y⟩; d) denote the set {⟨x', y'⟩ ∈ R2 : |x' − x| < d, |y' − y| < d}. Suppose that a dyadic point d = ⟨d1, d2⟩ is in A(n, t), then for any z ∈ N(d; 2−(p(n)+1)), since z has an oracle repre- sentation ⟨φ, ψ⟩ such that φ(i) = bd1 (i) and ψ(i) = bd2 (i) for all i ≤ p(n), the computation Mφ,ψ(n) works exactly the same as that of Md1 ,d2 (n), and hence it outputs 1. That means that either z ∈ Sx≤t or z ∈ En(M); in other words, N(d; 2−(p(n)+1)) ⊆ Sx≤t ∪ En(M). Similarly, if d ∈ B(n, t), then N(d; 2−(p(n)+1)) ⊆ Sx≥t ∪En(M). Note that the small squares N(d; 2−(p(n)+1)), where d ∈ (Dp(n) ∩ [0, t)) × (Dp(n) ∩ [0, 1]), do not overlap each other and the union of them cover the rectangle [−2−(p(n)+1),t − 2−(p(n)+1)] ×[−2−(p(n)+1), 1+ 2−(p(n)+1)] (except a finite number of line segments whose area is zero). Now it is easy to see that 2−2p(n) · ||A(n, t)|| is close to the area of Sx≤t, with an error bounded by μ∗(En(M)) + 4 · 2−(p(n)+1) < 2−(n−1). We define a function G : N × (D ∩ [0, 1]) → N such that G(n, t) = ||A(n, t')|| for all (n, t) ∈ N × (D ∩ [0, 1]), where t' = max{x ∈ Dn : x ≤ t}. Note that A(n, t')

is the number of elements ⟨d1, d2⟩ ∈ D2
that satisfy the polynomial-time

computable predicate d1 < t' ∧ Md1 ,d2 (n) = 1, thus according to Proposi- tion 2.1, G is in #P . Therefore, if #P = FP , then the area of Sx≤t can be computed in polynomial time. The same conclusion holds for Sx>t. Therefore, g is polynomial time computable if #P = FP .

Fig. 2. The domain S for (b)⇒ (c) of Theorem 3.3.
(b)⇒ (c). Chou and Ko [2] constructed a P -approximable set S' ⊆ [0, 1]2 such that the area of S' is polynomial time computable if and only if #P1 = FP1. We construct a domain S such that the left part of S is a large rectangle [0, c] × [0, 1], and the right part of S is a copy of S' (see Figure 2). Then, because the problem of computing b is equivalent to decide the area of S' (i.e., area(S')= 2b − c), the theorem is proved.	 
In other words, Theorem 3.3 shows that the complexity of computing the bisector at a given angle of a P -approximable bounded set with a posi- tive thickness around the bisector is between P #P and P #P1 (more precisely, P #P1[1], since to compute an approximation to the area of S', the #P1 or- acle will only be queried once; for details, see Chou and Ko [2]). Whether P #P = P #P1 is still an open question in discrete complexity theory (see, e.g., Ogihara et al. [10]).
We present a pure mathematical result below that any Jordan domain has a positive thickness around any bisector; furthermore, the thickness is always greater than a positive constant (i.e., bounded below).
Lemma 3.4 Let S be a Jordan domain and Γ the boundary of S. Then there exists a real number Δ > 0, such that for any line L that divides S into two parts S1 and S2 with |area(S1) − area(S2)| < area(S)/3, there is a point Q in the intersection L ∩ S of L and S such that dist(Q, Γ) > Δ. It follows that S has a positive thickness around all bisectors.
Proof. Let f : [0, 1] → R2 be a continuous function such that f is 1-1 on [0, 1), f (0) = f (1) and the image of f is Γ. Let {t} denote the distance of real number t and integer points (e.g., {0.6} = 0.4, {1} = 0). Let K > 0 be a real number such that πK2 < area(S)/3 and K < area(S)/(6R), where R is the

radius of a disk that covers S. Then there exists a real number H > 0 such that for any t1, t2 ∈ [0, 1], {t1 − t2} < H ⇒ |f (t1) − f (t2)| < K.
Let A = {(t1, t2) ∈ [0, 1]2 : t1 < t2, |f (t1) − f (t2)| ≥ 3K}. It is clear that A is closed. From the assumption of K < area(S)/(6R), A is nonempty, for otherwise, all Γ is contained in a rectangle of dimensions 3K × 2R < area(S), which is a contradiction. Now we define a function g on A as follows. Let (t1, t2) ∈ A. If γ is a path from f (t1) to f (t2) such that γ ⊆ S, we let γK denote the portion of γ whose distance to f (t1) and f (t2) is no less than K, i.e., γK = {Q ∈ γ : dist(Q, f (ti)) ≥ K, i = 1, 2}. From the definition of A, γK is nonempty. g(t1, t2) is the least upper bound of the distances dist(γK, Γ) over all paths γ ⊆ S from f (t1) to f (t2). Roughly speaking, there is a tube that connects f (t1) and f (t2) such that the tube is of width≥ 2g(t1, t2) in the middle. We have g(t1, t2) > 0 since there exists a path γ ⊆ S from f (t1) to f (t2) such that γK is strictly inside Γ, which implies that g(t1, t2) ≥ dist(γK, Γ) > 0.
It is an interesting problem to prove that g is continuous. For any real number ϵ > 0, there exists a real number δ > 0 such that for any t1, t2 ∈ [0, 1],
{t1 − t2} < δ ⇒ |f (t1) − f (t2)| < ϵ/2. For any two pairs (t1, t2), (t' , t' ) ∈ A
1  2
such that |ti − t' | < δ for i = 1, 2, let γ be a path from f (t1) to f (t2) such
that dist(γK, Γ) ≥ g(t1, t2) − ϵ/2. Assume that t1 < t' and t2 < t' . Let
γ' be the path consisting of γ, f ([t1, t' ]) and f ([t2, t' ]) (removing any re-

1
peated portion). Then g(t' , t' ) ≥ dist(γ'
2
, Γ) ≥ dist(γK, Γ) − max(|f (t1) −

1  2	K
f (t' )|, |f (t2) − f (t' )|) > (g(t1, t2) − ϵ/2) − ϵ/2 = g(t1, t2) − ϵ. Symmetri-
1	2
cally, g(t1, t2) > g(t' , t' ) − ϵ. Therefore, |g(t1, t2) − g(t' , t' )| < ϵ. Thus, g is
1  2	1  2
continuous.
Since g is continuous on a bounded closed set, g assumes its minimum at some points. That is, there exists a real number Δ > 0 such that g(t1, t2) ≥ 2Δ for any (t1, t2) ∈ A.
Now we prove the lemma. From the assumption of K, there exist t1, t2 ∈ [0, 1] such that f (t1) and f (t2) are on different sides of L and are the furthest points away from L among all points of Γ on two sides of L, respectively. Then dist(f (ti), L) > K for i = 1, 2 and |f (t1) − f (t2)| > 3K. Assume t1 < t2, then (t1, t2) ∈ A and g(t1, t2) ≥ 2Δ. Then there exists a path γ ⊆ S from f (t1) to f (t2) such that dist(γK, Γ) ≥ g(t1, t2) − Δ ≥ 2Δ − Δ = Δ. The curve γK must intersect L, since f (t1) and f (t2) are on different sides of L and dist(f (ti), L) > K for i = 1, 2. Pick any point Q in γK ∩ L, we have dist(Q, Γ) ≥ Δ.	 
Remark: In the proof above, we can show further that g(t1, t2)= dist(γK, Γ) for some path γ ⊆ S from f (t1) to f (t2), but this requires the Arzela-Ascoli Theorem in real analysis (see, e.g., Rudin [11]), which complicates the proof

unnecessarily.
Note that by Lemma 3.4, any Jordan domain has a thickness W around any bisector such that W is greater than a positive constant 2Δ. Then we have the following corollary from Theorem 3.3.
Corollary 3.5 In the following, (a) ⇒ (b) ⇒ (c):
FP = #P .
For any P-approximable Jordan domain S, the bisector of S at any polynomial-time computable angle α ∈ [0, π) is polynomial-time computable. 3
FP1 = #P1.
There is also another version of bisecting a single set S: the bisector is through a fixed point Q, instead of forming a fixed angle with the positive x-axis. If the fixed point Q is away from the set S in the sense that Q and S are on different sides of a line (i.e., Q and S are linearly separable), and S has a positive thickness around a bisector L of S that goes through Q, then L is the unique such bisector. Note that here thickness around a line L is more naturally defined as the rate of area change over angle change. More precisely, suppose Q and S are separated by a horizontal line and Q is below S. For an angle α ∈ [0, π), let Lα be the half line through Q at angle α, and Sangle<α be the part of S on the right of Lα. Now the thickness of S at line Lα (or we may say the thickness of S at angle α with respect to Q) is defined as
lim inf area(Sangle<α+δ ) − area(Sangle<α) ,
δ→0	δ
and similarly we can define positive thickness around a line (or angle). We remark that this definition is consistent with the previous one in the sense that if S has a positive thickness around a line Lα by the previous definition, Definition 3.1, then by the current definition S still has a positive thickness around angle α with respect to a point Q on Lα that is linearly separable from
S. (However, the exact thickness values under these two definitions are not the same.)
Theorem 3.6 In the following, (a) ⇒ (b) ⇒ (c):
FP = #P .
Let S be a P-approximable set such that the origin O and S are linearly separated by a horizontal line with O below S. If a line Lα (α ∈ [0, π)) through O is a bisector of S and S has a positive thickness around angle α with

3 Note that the bisector is defined by y = tan(α)x + b if α /= π/2 and x = b if α = π/2, for some real number b, and the problem is to compute b in polynomial time.

respect to O, then Lα is the unique such bisector of S and α is polynomial-time computable.
FP1 = #P1.
Proof. The proof is similar to that of Theorem 3.3 and thus is omitted. Note that for the part (b) ⇒ (c), we still use the domain S shown in Figure 2, and we can make the bisector Lα only intersect the left part of S, i.e., the rectangle, then the problem of finding Lα is equivalent to decide the area of
S.	 
On the other hand, if the fixed point Q can be inside S, there is no fixed complexity bound for finding the bisector of S through Q.
Theorem 3.7 Suppose α ∈ [0, π) is a computable number. Then there exists a P-approximable/recognizable convex Jordan domain S, such that the unique bisector of S through the origin O is at angle α.
Proof. The idea of the construction of S is similar to that in the proof of Theorem 3.2. The boundary of S is the image of a function f : [0, 2π] → R2 such that for any β ∈ [0, 2π], f (β)= g(β)⟨cos(β), sin(β)⟩, where g : [0, 2π] → R is a function whose values are always positive. It suffices to just describe the boundary of S in order to explain what f is.
Without loss of generality, we assume that α ∈ (1/4, 1/2). We follow the notations of the proof of Theorem 3.2, and define two sequences {dn} and

{dn} that binary converge to α from below and upper, function s(n), sets I1
and I2, the intervals of the first and second kinds, and let am,n be the n-th smallest number in Im, where m ∈ {1, 2}.
For any n ∈ N, let i = a1,n and j = a1,n+1 and h = max(a1,n+1, a2,n+1). We have dj − di ≥ 2−s(h). Then on the n-th interval [di, dj ] of the first kind, the image of f is identical to the part of the unit circle at the sector between angles di and dj , except that there is a bump on [di, di +2−s(h)]; more precisely, the image of f on [di, di + 2−s(h)] is the union of two tangents: that is, on [di, di + 2−s(h)], the image of f is a piecewise linear curve with breakpoints
⟨cos(di), sin(di)⟩, ⟨cos(di + 2−(s(h)+1)), sin(di + 2−(s(h)+1))⟩/ cos(2−(s(k)+1))⟩ and
⟨cos(di + 2−s(h)), sin(di + 2−s(h))⟩. Similarly, we define f on the intervals of the second kind. The image of f on [0, 2π] − [1/4, 1/2] is identical to the unit circle on the same domain.
Figure 3 illustrates the domain S: the lines OA, OB and OC are at angles α, 1/2, 1/4 respectively; the bumps on different sides of OA can be paired up such that the two bumps in each pair are of the same area. We can check that S is a P -approximable/recognizable Jordan domain similar to the proof of Theorem 3.2. Also, S is convex, since its boundary ∂S consists of circular


Fig. 3. The domain S for (b) Theorem 3.7.
arcs and tangents. (The domain S does not look convex in the figure because we want to emphasize the bumps in a small region.) As shown in the figure, the area of bumps in the sector AOB is the same as the area of bumps in the sector AOC, so OA is a bisector of S that goes through the origin O. There are no other such bisectors because for any line OD other than OA, on one side of OD, there are only a finite number of bumps, while on the other side, there are infinitely many bumps.	 

Bisecting two sets simultaneously
Mathematically, the Pancake Theorem follows the intermediate value theo- rem and the Borsuk-Ulam Theorem (see, e.g., Fulton [5]). For the sake of self-containness, we show how the intermediate value theorem implies the Borsuk-Ulam Theorem and how the Borsuk-Ulam Theorem implies the Pan- cake Theorem on the two-dimensional plane (see, e.g., Fulton [5]).
Let C be the unit circle with its center at the origin. For α ∈ [0, 2π], we use zα to denote a point ⟨cos α, sin α⟩. The Borsuk-Ulam Theorem on the two-dimensional plane states that any continuous function f : C → R must map a pair of antipodal points zα0 and zα0 +π to the same value. To see this, let g : C → R be the function defined by g(zα)= f (zα) − f (zα+π). Then g is a continuous function satisfying g(z0)= −g(zπ). From the intermediate value theorem, there must exists a number α0 ∈ [0, π] such that g(zα0 ) = 0, i.e., f (zα0 )= f (zα0 +π ).
Now we show how the Borsuk-Ulam Theorem implies the Pancake Theo-
rem. Let S and S' be two Lebesgue measurable sets. We can assume that S and S' are both inside the unit circle: if S and S' are unbounded, we can consider the problem on bounded approximations to S and S' and then take

a limit. Now we define a function f : C → R as follows: for any zα ∈ C, let Lα+π/2 be the “middle” bisector of S at angle α + π/2 (we make Lα+π/2 in the middle among all possible bisectors at the same angle, so that for the antipodal point zα+π of zα, the same bisector Lα+π/2 will be chosen), which

divides S' into two parts S'
and S'
with S'
closer to zα, and f (zα) is the area

of S' . Assuming that f is continuous, 4 then from the Borsuk-Ulam theorem, there exists a number α0 ∈ [0, π] such that f (zα0 )= f (zα0+π ), which implies that Lα +π/2 bisects S' too.
Next we present some results on the computability and complexity of the intermediate value theorem and the Borsuk-Ulam Theorem.
Theorem 4.1 (a) Let f : [0, 1] → R be a computable function such that f (0)f (1) < 0. Then there exists a computable number r ∈ (0, 1) such that f (r)= 0.
(b) (Ko [7, Theorem 4.4]) For any computable number r ∈ (0, 1), there exists a polynomial-time computable function f : [0, 1] → R such that (1) f is strictly increasing; (2) f (0)f (1) < 0; and (3) f (r)= 0.
Part (a) of Theorem 4.1 provides a positive result that every computable function that changes sign has a computable zero, while part (b) shows a negative result that it is arbitrarily hard to compute it even if there is only one zero and the function is polynomial-time computable. As pointed out in Ko [7], if the function f has a polynomial inverse modulus, the unique zero of f is polynomial-time computable.
In the following, we prove a negative result about the complexity of the Borsuk-Ulam Theorem.
Theorem 4.2 Let α ∈ [0, π) be a computable number. Then there exists a polynomial-time computable function f : C → R such that (zα, zα+π) is the only pair of antipodal points that satisﬁes f (zα)= f (zα+π).
Proof (Ideas) Without loss of generality, suppose α ∈ (π/3, 2π/3). We can construct a function g : [0, 2π] → R such that
g is strictly increasing on [0, π] with g(α)= 1.
g is piecewise-linear on [π, 2π] with g(4π/3) = 1, g(5π/3) = 1 and
g(2π)= g(0).
The construction of (1) follows that of part (b) of Theorem 4.1. It is obvious that g(α) = g(α + π)(= 1). To prove that (α, α + π) is the only such pair, we note that for β ∈ [0, π/3], g(β) < 1 and g(β + π) ≥ 1; for

4 This is not obvious to be true, but we can assume that S and S′ are of “good” shapes so that f is continuous, then prove the Pancake Theorem and take a limit for the general case.

β ∈ [2π/3, π], g(β) > 1 and g(β + π) ≤ 1; for β ∈ [π/3, 2π/3], g(β + π) = 1 but g(β) /=1 if β /= α.
Let f (zβ) = g(β) for any β ∈ [0, 2π]. From the above discussion, it is clear that (zα, zα+π) is the only pair of antipodal points that satisfies f (zα)= f (zα+π).	 
Now we consider the Pancake Theorem. Again the computability problem has an affirmative answer and we omit its proof. Our results below show that in general it is arbitrarily hard to compute the common bisector of two P - approximable sets even if (1) each of these sets has a positive thickness around any bisector; and (2) there is exactly one common bisector. However, if the two sets are linearly separable, the complexity of the problem is characterized by counting classes #P and #P1.
Note that we only need to compute the angle α from the positive x-axis to the common bisector L, since once α is known, the common bisector can be computed.
Theorem 4.3 Let α ∈ [0, π) be a computable number. Then there exist two convex P-approximable/recognizable Jordan domains S and S' that have only one common bisector L, and the angle from the positive x-axis to L is α.
Proof. he domain S is the same as in Theorem 3.7, and S' is the unit disk. 
There is another version of the Pancake theorem, which states that for any bounded set S ⊆ R2, there exist two lines that are perpendicular to each other and divide S into four parts of equal area.
Theorem 4.4 Let α ∈ [0, π) be a computable number. Then there exists a convex P-approximable/recognizable Jordan domain S whose boundary is polynomial-time computable, such that the following properties are satisﬁed:
(1) there exist exactly two lines L1 and L2 that are perpendicular to each other and divide S into four parts of equal area; (2) the angle from the positive x-axis to L1 is α; and (3) both lines L1 and L2 pass through the origin.
Proof.  The domain S is similar to the one constructed in the proof of Theorem 3.7, except that we remove some parts from S in intervals [α + 3π/2, 2α + 3π/2 — 1/4] and [2α + π/2 — 1/2,α + π/2], with the area in each removed part equals what is added to S (compared to the unit disk) in the interval [1/4, α] (and in the interval [α, 1/2]). Then the area of S is the same as the unit disk, that is, area(S)= π. See Figure 4(a) for an illustration of S. It is easy to check that the two lines L1 and L2 satisfying conditions (2) and
divide S into four parts of equal area.
It remains to show that L1 and L2 are the only pair of lines that can do so.

Suppose that two lines L'
and L'
are perpendicular to each other and divide






L’2





Fig. 4. (a) The domain S for Theorem 4.4, (b) Divisions with two lines.

S into four parts of equal area area(S)/4= π/4, as in Figure 4(b). There are two cases.

Case (a): Both L'
and L'
contain the origin O. It is easy to check that

{L1, L2} = {L' , L' }.
1	2
Case (b): Not the above case. Without loss of generality, assume that L'

does not contain the origin O. L'
must intersect the arc from D through A

to E of the boundary of S, for otherwise L'
divides S into two parts, with

the area of one of them less than area(S)/2= π/2, since it is smaller than

a half unit disk. Without loss of generality, assume that L'
intersects the

arc from D to A (see Figure 4(b)). Then D and O are on the same side

of L' , for otherwise L'
divides S into two parts, with the area of the part

1	1
containing D less than area(S)/2. Then D and O must be on the same

side of L' , for otherwise the part of S divided by L' and L'
that contains

2	1	2

O is larger than 1/4 of a unit disk. Now the part of S divided by L'
and

' that contains E (i.e., the part marked with ∗’s in Figure 4(b)) is of area
< area(S)/4, which is a contradiction.	 
We point out that if we just want to get an approximate answer (i.e., for an integer n > 0, find a pair of two lines that are perpendicular to each other and divide S into four parts with the area difference between any two parts less than 2−n), the complexity can be characterized by NP #P (since we can guess two lines and then verify that the area differences are less than 2−n). However, Theorem 4.4 shows that these pairs of lines may not converge rapidly to the exact pair of lines that are perpendicular to each other and divides S into four parts of equal area. An interesting question is whether there exists a natural condition, like the positive thickness condition for the problem of bisecting one set, that helps reduce the complexity.
Recall that we say two sets S and S' are linearly separable if they are on different sides of some line. If the two sets S and S' are linearly separable and each of them has a positive thickness around all its bisectors, there exists

exactly one common bisector of S and S'.
Theorem 4.5 In the following, (a) ⇒ (b) ⇒ (c):
FP = #P .
For any two linearly separable bounded P-approximable sets S and S' with positive thickness around all bisectors, the unique line L that bisects si- multaneously the two sets is polynomial-time computable.
FP1 = #P1.
Proof. The spirits of the proof are quite similar to the proof of Theorem 3.3. For the proof of (a)⇒ (b), suppose that S and S' are separated by a vertical line L(see Figure 5). For any line L' that intersects L, we define its direction as from a point on L' lying on the left of L to a point on L' lying on the right of L. Then we can say the angles of such lines with respect to the positive
x-axis are from —π/2 to π/2.
We define a function g : (—π/2, π/2) → R as follows: for any α ∈ (—π/2, π/2), there exists uniquely a line Lα that bisects S at angle α. Lα will divide S' into two parts S1 and S2, with S1 on the right of Lα (recall that Lα has a direction). Let g(α)= area(S1) — area(S2). Function g has only one root α0, with Lα being the unique common bisector of S and S'. Next we will show that under condition (a), α0 is polynomial-time computable, which further implies that Lα0 is polynomial-time computable by Theorem 3.3.
First g(α) has a linear inverse modulus when α is close to the root α0 of g: as in Figure 5, for two angles α, β ∈ (—π/2, π/2) with α < β, S' and the intersection of Lα and Lβ must be on different sides of L, which implies that g(α) < g(β); more precisely, g(β) — g(α) is twice the area of the intersection of S' and a sector region of angle β — α, and from the thickness condition of S', g(β) — g(α) > m(β — α) for some m > 0, provided that α and β are sufficiently close to α0. Therefore, by Corollary 4.7 of Ko [7], the root α0 of g is polynomial-time computable if g is polynomial-time computable. According to Theorem 3.3, g is polynomial-time computable under condition (a), thus the proof is completed.




S’
Fig. 5. The domains S and S' for (a)⇒ (b) of Theorem 4.5.
For the proof of (b)⇒ (c), we let S be a domain similar to the one in the proof of (b)⇒(c) of Theorem 3.3 and S' a disk lying below S. Then the

common bisector of S and S' must go through the center of S'. The proof is completed by following (b) ⇒ (c) of Theorem 3.6.	 

References
Abbott, Timothy, Erik D. Demaine, Martin L. Demaine, Daniel Kane, Stefan Langerman, Jelani Nelson and Vincent Yeung, Dynamic ham-sandwich cuts of convex polygons in the plane, In Proceedings of Canadian Conference on Computational Geometry (CCCG’05), pages 61–64, 2005.
Chou, Arthur, and Ker-I Ko, Computational complexity of two-dimensional regions, SIAM Journal on Computing, 24:923–947, 1995.
Du, Ding-Zhu, and Ker-I Ko, “Theory of Computational Complexity”, John Wiley & Sons, New York, 2000.
Edelsbrunner, H., and R. Waupotitsch, Computing a ham-sandwich cut in two dimensions, J. Symb. Comput., 2(2):171–178, 1986.
Fulton, William, “Algebraic Topology: A First Course”, Number 153 in Graduate Texts in Mathematics, Springer, 1997.
Green, F., J. K¨obler, K. Regan, T. Schwentick, and J. Tor´an, The Power of the Middle Bit of a #P Function, Journal of Computer and System Sciences, 50:456–467, 1995.
Ko, Ker-I, “Complexity Theory of Real Functions”, Birkha¨user, Boston, 1991.
Lo, Chi-Yuan, Jir´ı Matousek, and William L. Steiger, Ham-sandwich cuts in Rd, In Proceedings of Annual ACM Symposium on Theory of Computing (STOC 1992), pages 539–
545. ACM, 1992.
Lo, Chi-Yuan, Jir´ı Matousek, and William L. Steiger, Algorithms for ham-sandwich cuts, Discrete & Computational Geometry, 11:433–452, 1994.
Ogihara, Mitsunori, Thomas Thierauf, Seinosuke Toda, and Osamu Watanabe, On closure properties of #P in the context of PF◦#P . J. Comput. Syst. Sci., 53(2):171–179, 1996.
Rudin, Walter, “Principles of Mathematical Analysis”, McGraw-Hill, 1976.
Stojmenovic, Ivan, Bisections and ham-sandwich cuts of convex polygons and polyhedra, Inf. Process. Lett., 38(1):15–21, 1991.
