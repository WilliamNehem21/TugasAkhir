Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 347 (2019) 281–301
www.elsevier.com/locate/entcs

Quantitative Logics for Equivalence of Effectful Programs
Niels Voorneveld1,2
Faculty of Mathematics and Physics University of Ljubljana
Ljubljana, Slovenia

Abstract
In order to reason about effects, we can define quantitative formulas to describe behavioural aspects of effectful programs. These formulas can for example express probabilities that (or sets of correct starting states for which) a program satisfies a property. Fundamental to this approach is the notion of quantitative modality, which is used to lift a property on values to a property on computations. Taking all formulas together, we say that two terms are equivalent if they satisfy all formulas to the same quantitative degree.
Under sufficient conditions on the quantitative modalities, this equivalence is equal to a notion of Abram- sky’s applicative bisimilarity, and is moreover a congruence. We investigate these results in the context of Levy’s call-by-push-value with general recursion and algebraic effects. For example, the results apply to (combinations of) nondeterministic choice, probabilistic choice, global store, and error.
Keywords: Quantitative Logic, Program Equivalence, Algebraic Effects, Behavioural Equivalence, Applicative Bisimilarity, Modalities, Call-by-push-value, Probability, Nondeterminism, Global Store, Error, Effect Combinations.


Introduction
There are many notions of program equivalence for languages with effects. In this paper, we explore the notion of behavioural equivalence, which states that programs may be considered behaviourally equivalent if they satisfy the same behavioural properties. This can be made rigorous by defining a logic, where each formula φ denotes a certain behavioural property. We write (.P.. |= φ) to express the satisfaction of formula φ by term .P.., which is usually given by a Boolean truth value (true or false). Two terms .P.. and R... are said to be behaviourally equivalent if they satisfy the same formulas. Such an approach is taken in for example [9].

1 This material is based upon work supported by the Air Force Office of Scientific Research under award number FA9550-17-1-0326. This project has received funding from the European Union’s Horizon 2020 research and innovation programme under the Marie Sk-lodowska-Curie grant agreement No 731143.
2 Email: Niels.Voorneveld@fmf.uni-lj.si

https://doi.org/10.1016/j.entcs.2019.09.015
1571-0661/© 2019 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

In particular, we use this method to define equivalence for a language with algebraic effects in the sense of Plotkin and Power [27]. Effects can be seen as aspects of computation which involves interaction with the world ‘outside’ the environment in which the program runs. They include: exceptions, nondeterminism, probabilistic choice, global store, input/output, cost, etc. The examples given have common ground in the work of Moggi [22], and can moreover be expressed by specific effect triggering operations making them ‘algebraic’ in nature. In the presence of such algebraic effects, computation terms need not simply reduce to a single terminal term (that is a value), they may also invoke effects on the way. Following [27,13], we consider a computation term to evaluate to an effect tree, whose nodes are effect operators and leaves are terminal terms. The paper [29] introduced modalities that lift boolean properties of values to boolean properties of the trees modelling their computations. See [24,23,28] for alternative ways in which logics can be used to describe properties of effects.
The use of a Boolean logic does however not readily adapt to several examples of effects, for example the combination of probability and nondeterminism. The lit- erature on compositional program verification shows the usefulness of quantitative (e.g. real-number valued) program logics for verifying programs with probabilis- tic behaviour, possibly in combination with nondeterminism [14,21]. The paper
[29] develops a general Boolean-valued framework which, although featuring many examples, does not apply to this combination of probability and nondeterminism.
This paper provides a general framework for quantitative logics for expressing behavioural properties of programs with effects, generalising the Boolean-valued framework from [29]. We consider a quantitative (quantity-valued) satisfaction re- lation ‘|=’, where (.P.. |= φ) is given by an element from a quantitative truth space A (a degree of satisfaction). This allows us to ask open questions about programs, like “What is the probability that ...” or “What are the correct global starting states for ...”. We define equivalence by stating that programs .P.. and R... are equivalent, if for any formula φ we have (.P.. |= φ) = (R... |= φ) (.P.. satisfies φ precisely as much as R... does). A key feature of the logic is the use of quantitative modalities to lift quantitative properties on value types to quantitative properties on computation types.
As in [29], we are able to establish that the behavioural equivalence as above is compatible, therefore a congruence, as long as suitable properties on the quan- titative modalities are satisfied. These properties require notions of monotonicity, continuity, and a notion of preservation over sequencing called decomposability. As in [29], compatibility is established by proving that given one of the properties (leaf-monotonicity), our behavioural equivalence is equal to an effect-sensitive no- tion of Abramsky’s applicative bisimilarity [1,3]. Given further properties on the modalities, this relation can be proven to be compatible using Howe’s method [11]. The main contribution of this paper is the generalisation of [29], and the corre- sponding generalised results. This goes through smoothly, though there are some subtleties like what to take as primitive in a quantitative setting. In particular, we will see the necessity of a threshold operation. The other main contributions are

the examples illustrating the quantitative approach. Some examples such as the combination of nondeterminism with probabilistic choice, or with global store, do not fit into the Boolean-valued framework of [29], but do work here 3. But there are also examples, such as probability, global store, and cost, whose treatment is more natural in our quantitative setting, even though they also fit in the framework of [29].
As a vehicle of our investigation we use Levy’s call-by-push-value (CBPV) [17,16], together with general recursion and the aforementioned algebraic effects. As such, it generalises [29] in a second way by using call-by-push-value to incorporate both call-by-name (CBN) and call-by-value (CBV) evaluation strategies. This is sig- nificant, since once either divergence or effects are present, the distinction between the reduction strategies becomes vital. For example, if we take some probabilistic choice por signifying a fair coin flip, we have that ‘por(λx . 0, λx. 1) ≡ λx . por(0, 1)’ holds in CBN, but not in CBV. So it is interesting to consider CBPV, as it expresses both these behaviours. The distinction is expressed in the difference between pro- ducer -types FA where one explicitly observes effects, and types like A → C where the observation of effects is postponed to a later moment. As such, this language is an ideal backdrop for studying effects.
In Section 2 we give the operational semantics of the language, starting with the effect-free version and working towards our treatment of algebraic effects. In Sec- tion 3 we present our quantitative logic, introducing quantitative modalities to deal with the observation of effects. In Section 4 we look at the resulting behavioural equivalence and the properties that establish the congruence property (or compat- ibility in its technical form). In Section 5 we relate this equivalence to applicative (bi)similarities by defining a relator using our modalities. This then allows us to adapt a Howe’s method proof of compatibility from [3,29] for this equivalence. We finish in Section 6 with some discussions.

Operational semantics
We use a simply-typed call-by-push-value functional language as in [16,17], together with general recursion and a ground type for natural numbers, making it a call-by- push-value variant of PCF [25]. To this, we add algebraic-effect-triggering operators in the sense of Plotkin and Power [27]. We first focus on the effect-free part of the language, as we want to consider effects independently of the underlying language.

The language
We give a brief overview of the language and its semantics. The types are divided into two flavours, Value types and Computation types. Value types contain value terms that are passive, and do not compute anything on their own. Computation

3 The combination of global store and nondeterminism is possible in the framework of [29], only if one considers angelic (helpful) nondeterminism. The problem is with general (neutral) or demonic (antagonistic) nondeterminism, combined with global store.

types contain computation terms which are active, which means they either return something to or ask something of the environment.
Value types A, B and computation types C, D are given by:
A, B ::= U C  | 1 | N | Σi∈I Ai | A × A	C, D ::= FA | A → C | Πi∈I Ci
where I is any ﬁnite indexing set. By asserting finiteness of I in the case of product types, the number of program terms is kept countable (a property which will have benefits later on in the formulation of the logic). The type U C  is a thunk type, which consists of terms which are frozen. These terms were initially computation terms but are made inactive by packaging them into a thunk. The type N is the type of natural numbers, containing the non-negative integers. With this type, we can program any computable function on the natural numbers as in PCF [25]. The type FA is a producer type, which actively evaluates and returns values of type A to the current environment. As was stated, this is the type at which we can observe effects. The type A → C is a type of functions, which is a computation type since its terms are actively awaiting input.
We have a countably-infinite collection of term variables x, and term contexts: Γ ::= ∅| Γ,x : A.
A term is closed if it has context ∅, else it’s open. Note that contexts only contain Value types, meaning that like in call-by-value, we can only ever substitute value terms. This is no loss of generality, as we can simulate substituting computation terms by packaging them into a thunk. The terms of the language are as follows:
Value terms: V, W ::= ∗| Z | S(V ) | x | thunk(M ) | (i, V ) | (V, W )
Computation terms: M, N  ::= case V in {M, S(x) ⇒ N}| let x be V . M |
return(V ) | M to x. N  | force(V ) | λx : A . M  | M · V |
pm V as {..., (i.x) . Mi,... }| pm V as (x, y) . M  | ⟨Mi | i ∈ I⟩| 
M · i | fix(M )
We underline terms M and types C when they are computation terms and computa- tion types respectively. We will also use .E..,.F.. and .P.., R... to denote general types and their terms, e.g. they could be either value or computation types/terms. Following [16], their typing rules are given in Fig. 1, where we distinguish two typing judge- ments, ▶v and ▶c, for value and computation terms respectively. We write Terms(.E..) for the set of closed terms of type .E... Note the addition of the fixpoint operator fix(−) which has been added to allow for general recursion and hence divergence. We write n : N for the numeral representing the n-th natural number.
Semantics
We give the semantics of this language by specifying a reduction strategy for com- putation terms in the style of a CK-machine [5]. We distinguish a special class of computation terms, called terminal terms, which will not reduce further. They consist of: return(V ): FA, λx : A . M  : A → C, and ⟨Mi | i ∈ I⟩ : Πi∈IMi.


	
Γ ▶v ∗ : 1	Γ ▶v Z : N
Γ ▶v V : N

Γ ▶v S(V ): N
Γ ▶v V : N	Γ ▶c M :  C	Γ,x : N ▶c N :  C

Γ ▶c case V in {M, S(x) ⇒ N} :  C



Γ,x : A, Γ' ▶v x : A
Γ ▶v V : A	Γ,x : A ▶c M :  C

Γ ▶c let x be V . M :  C
Γ ▶v V : A

Γ ▶c return(V ): FA
Γ ▶c M : FA	Γ,x : A ▶c N :  C

Γ ▶c M to x. N  :  C

Γ ▶c M :  C

Γ ▶v thunk(M ): U C 
Γ ▶v V : U C 

Γ ▶c force(V ) :  C
Γ,x : A ▶c M :  C

Γ ▶c λx : A . M  : A →  C
Γ ▶v V : A	Γ ▶c M : A →  C

Γ ▶c M · V :  C

Γ ▶v V : Aj
Γ ▶v V : Σi∈I Ai	Γ,x : Ai ▶c Mi :  C for each i ∈ I
Γ ▶v V : A	Γ ▶v V ' : B

	 j ∈ I 	 	

Γ ▶v (j, V ): Σi∈I Ai
Γ ▶c pm V as {..., (i.x) . Mi,... } :  C
Γ ▶v (V, V ' ): A × B

Γ ▶v V : A × B	Γ,x : A,y : B ▶c M :  C

Γ ▶c pm V as (x, y) . M  :  C
Γ ▶c Mi :  Ci for each i ∈ I

Γ ▶c (Mi | i ∈ I⟩ : Πi∈I Ci
Γ ▶c M : Πi∈I Ci Γ ▶c M · j :  Cj
Γ ▶c M : U C  →  C

Γ ▶c fix(M ) :  C


Fig. 1. Typing rules
We first give the rules for terms we can directly reduce. We denote these using relation symbol ~ :


case Z in {M, S(x) ⇒ N} ~ M .
case S(V ) in {M, S(x) ⇒ N}	~
N [V/x].
let x be V . M ~ M [V/x].
force(thunk(M )) ~ M .
pm (j, V ) as {..., (i.x) .Mi,... } ~
Mj [V/x].
pm (V, W ) as (x, y) . M 	~
M [V/x, W/y].
fix(M ) ~ M · thunk(fix(M )).

The behaviour of the other non-terminal computation terms; M to x. N , M · V and M · i, is implemented using a system of stacks defined recursively:  S, Z ::= ε | S ◦ (−) to x. M  | S ◦ V | S ◦ j.
We write S{M} for the computation resulting from applying S to M , which can be seen as evaluating the program M within the environment S.
ε{M} := M	(S ◦ (−) to x. N ){M} := S{M to x. N}
(S ◦ V ){M} := S{M · V }	(S ◦ i){M} := S{M · i}
Whenever one encounters a computation of which one needs to first evaluate a subterm, one unfolds the continuation into the Stack and focusses on evaluating that subterm. This method is given by the stack reduction relation > in the following way:


If M	~	N , then (S, M )	>
(S, N ).
(S, M to x. N )	>	(S ◦
(−) to x. N, M ).
(S ◦ (−) to x. N, return(V ))	>
(S, N [V/x]).
(S, M · V ) > (S ◦ V, M ).
(S ◦V, λx : A . M ) > (S, M [V/x]).
(S, M · j) > (S ◦ j, M ).
(S ◦ j, ⟨Mi | i ∈ I⟩) > (S, Mj ).

Adding algebraic effect operators
We add algebraic effects in the style of [13], given by specific effect operators. We use a type variable α for computation types. Effects are given by operators of the following arities (like in [13,26]):
αn → α | N × αn → α | αN → α.

For each effect under consideration, we bundle together effect operators pertaining to that effect in a set called an effect signature Σ. Given such a signature, new computation terms can be constructed for each op ∈ Σ, according to the typing rules in Fig. 2.

∀1 ≤ i ≤ n.(Γ ▶c Mi : C)	n
Γ ▶c op(M ,..., M  ): C op : α  → α
Γ,x : N ▶c M : C	N
Γ ▶c op(x. M ): C op : α → α

1	n
Γ ▶v V : N	∀1 ≤ i ≤ n.(Γ ▶c Mi : C)	n
Γ ▶c op(V, M ,..., M  ): C	op : N × α  → α
1	n
Fig. 2. Effect typing rules

We look at the running examples of this paper.
Example 1 (Probabilistic choice) The effect of probability is implemented by the signature Σp := {por : α2 → α}, where we have a single binary operator for

fair probabilistic choice. The computation por(M, N ) will have a 1
probability of

evaluating M, and 1 probability of evaluating N.
Example 2 (Global store) In the case of global variables for natural numbers, we deﬁne a signature Σg :=  l∈L {lookupl : αN → α, updatel : N × α → α}, where we have a set of locations L for storing natural numbers. The computation lookupl(x.M ) looks up the number at location l and substitutes it for x in M. The computation updatel(n, M ) stores n at l and then continues with the computation M.
Example 3 (Probabilistic choice and global store) We will also consider the combination of the previous two examples, probabilistic choice with global store, given by effect signature Σpg := Σp ∪ Σg.
Example 4 (Cost) If we want to keep track of costs of an evaluation, we take the signature Σc := {costc : α → α | c ∈ C}, where we have a countable set of real- valued costs C. The computation costc(M ) assigns a cost of c to the evaluation of
M. This cost can represent a time delay or some other resource.
Example 5 (Combinations with nondeterminism) We consider a binary op- erator nor : α2 → α for nondeterministic choice, which contrary to probabilistic choice is entirely unpredictable. One interpretation is to consider it under the con- trol of some external agent or scheduler (e.g. a compiler), which one may wish to model as being cooperative (angelic), antagonistic (demonic), or neutral. We will consider binary nondeterminism and its operator in combination with any one of the previous three examples. The resulting signatures are named Σpn, Σgn, Σgpn, and Σcn respectively.
Example 6 (Combinations with error) Lastly, given some set of error mes- sages E, we consider adding error raising effect operations {raisee : α0 → α | e ∈ E} to the language, where raisee() stops the evaluation of a term, and displays message
e. There is no continuation possible afterwards.
In the presence of such effects, the evaluation of a computation term might halt when encountering an algebraic effect operator. We broaden the semantics,

where a computation term now evaluates to an effect tree, a coinductively generated term using operations from our effect signature Σ together with terminal terms and a symbol for divergence ⊥. This idea appears in [27], but here we adapt the formulation from [13] to call-by-push-value.
We define the notion of an effect tree over any set X, where X can be thought of as a set of terminal terms.
Definition 2.1 An effect tree (henceforth tree) over a set X, determined by a signature Σ of effect operations, is a labelled and possibly non-well-founded tree whose nodes have the possible forms given below:
A leaf node labelled ⊥ (the symbol for nontermination/divergence).
A leaf node labelled x where x ∈ X.
A node labelled ‘op’ with children t1,..., tn, when op ∈ Σ has arity αn → α.
A node labelled ‘op’ with children t0, t1,... , when op ∈ Σ has arity αN → α.
A node labelled ‘opm’ where m ∈ N with children t1,..., tn, when op ∈ Σ has arity N × αn → α.
The set of trees over set X and signature Σ is denoted TΣ(X). We can equip this set with a partial order ≤, where t ≤ r if t can be constructed from r by pruning (possibly infinitely many) subtrees and labelling the pruning points with ⊥. Moreover, the preorder is ω-complete, so each ascending chain of trees t0 ≤ t1 ≤ ... has a least upper bound Hntn.
For any x ∈ X, we write η(x) ∈ TΣ(X) for the tree which only consists of one leaf labelled x. We have a map μ : TΣ(TΣ(X)) → TΣ(X) which flattens a tree of trees into one tree, by transforming the leaves (which are trees) into subtrees. We write op{t0,..., t1} or op{m '→ tm} for the tree with node op and children t0, t1,... . For each computation type C we define the evaluation map |−| : Terms(C) → TΣ(Terms(C)), which returns a tree, whose leaves are either labelled with ⊥ or labelled with a terminal term of type C. We define this inductively by constructing
for each n ∈ N the n-th approximation of the tree.
(i) |S, M|0 := ⊥.	(ii) |ε, M|n+1 := η(M ) if M is a terminal compu- tation term.
|S, M|n+1 := |Sj, Mj|n if (S, M ) > (Sj, Mj).
|S, op(M 1,..., Mm)|n+1 := op{|S, M 1|n,..., |S, Mm|n} if op : αm → α.
|S, op(x. M )|n+1 := op{m '→ |S, M [m/x]|} if op : αN → α.

|S, op(k, M 1,..., Mm)|n+1 := opk{|S, M 1|n,..., |S, Mm|n} if op : N × αm → α.
Using this, we define |M| :=  n |ε, M|n. We view |M| as an operational semantics of M in which M is reduced to its (possibly) observable computational behaviours, namely the tree of effect operations potentially performed in the evaluation of M . See Figure 3 for two examples of effect trees.
These trees are still quite syntactic, and may contain lots of unobservable infor- mation irrelevant to the real-world behaviour of programs. In the next section, we


por	nor


0	por	lookupl
1
lookupr
1

nor	1	updater,0	updater,1	updater,2 ...	updatel,0	updatel,1	updatel,2
0	1	0	1	2	0	1	2
Fig. 3. Tree examples: The unpredictable coin and the nondeterministic copier.
will set up the quantitative logic which will extract from such trees only the relevant information, using quantitative modalities.
Quantitative Logic
We define a quantitative logic expressing behavioural properties of terms. Each type has a set of formulas, which can be satisfied by terms of that type to varying degrees of satisfaction. These degrees of satisfaction are given by truth values from a countably complete lattice.
A countably complete lattice is a set A with a partial order Ð, where for each subset X ⊆ A there is a least upper bound sup(X) and a greatest lower bound inf(X). In particular, we define T := sup(A)= inf(∅) as the completely true value, and F := inf(A)= sup(∅) as the completely false value.
We also equip this space with a notion of negation or involution, which is a bijective map ¬ : A → A such that ∀a ∈ A, ¬(¬a) = a and ∀a, b ∈ A, (a Ð b) ⇔ (¬b Ð ¬a). We will use the words involution and negation interchangeably. Given the conditions of an involution, it holds that ¬T = F and ¬F = T . 4 Examples of complete lattices with involution/negation used in this paper are:
The Booleans B := {T , F}, where F Ð T . Negation swaps the elements.
The real number interval [0, 1], with the usual order. Here T = 1, F = 0, and
¬x := 1 − x.
The powerset P(X) over some set X, whose order is given by inclusion ⊆, so T = X and F = ∅. Negation is given by the complement, where ¬A := X − A = {x ∈ X | x ∈/ A}.
For A a complete lattice and X a set, the function space AX with point-wise order is a complete lattice.
The inﬁnite interval [0, ∞] with reversed order. Here, T = 0, F = ∞, and
¬x := 1/x.
We construct a logic for our language in order to define a behavioural pre- order. For each type .E.., value or computation, we have a set of formulas Form(.E..). Greek letters φ, ψ, . . . are used for formulas over value types, underlined Greek let- ters φ, ψ,... for formulas over computation types, and underdotted Greek letters

4 Results about the positive behavioural equivalence, and the positive logic, do not need negation. So a subset of results in this paper are still valid without it. Moreover, A need not necessarily be distributive, though in each example it is.

.φ.., ψ...,... for formulas over any type. We are aiming to define a quantitative relation (.P.. |= .φ..) to denote the element of A which describes the degree to which the term
.P.. satisfies the formula .φ.. (e.g. this may describe the probability of satisfaction or the amount of time needed for satisfaction). We choose the formulas according to the following two design criteria, as in [29].
Firstly, we design our logic to only contain behaviourally meaningful formulas. This means we only want to test properties that are in some sense observable by users or other programs. For the natural numbers type N we have a formula {n} which checks whether a term is equal to the numeral n. For function types we have formulas V → φ which tests a program on an input V , and checks how much the resulting term satisfies φ.
Secondly, we desire our logic to be as expressive as possible. To this end, we add countable disjunction (suprema) and conjunction (infima) over formulas, to- gether with negation ¬. Moreover, we add two natural quantity-specific primitives: a threshold operation and constants. Both such operations are used frequently (albeit implicitly) in practical examples of quantitative verification, e.g. in [21].

Quantitative modalities
Fundamental to the design of the logic is how we interpret algebraic effects. In CBPV, effects are observed in producer types FA. In order to formulate observable properties of FA-terms in our logic, we include a set of quantitative modalities which lift formulas on A to formulas on FA. We bundle our a selection of quantitative modalities together in a set Q.
Each modality q ∈ Q denotes a function Jq) : TΣ(A) → A, which is used to translate a tree of truths into a singular truth value. Given a quantitative predicate Θ : X → A on a set X, we can use a modality q to lift it to a quantitative predicate q(Θ) : TΣ(X) → A as follows. For t ∈ TΣ(X), we write t[Θ] for the tree in TΣ(A) where each non-⊥ leaf x ∈ X is replaced by the value Θ(x). Then q(Θ)(t) := Jq)(t[Θ]). 5
In the examples, we will define the denotation of a modality q by giving for each n ∈ N an approximation Jq)n. These will follow the rules: Jq)0(t)= F, Jq)n(⊥)= F, and Jq)n+1(η(a)) = a, and effect specific rules given in the examples below. Given these approximations, the denotation Jq)(t) is given by sup{Jq)n(t) | n ∈ N}.
Example 1 (Probabilistic choice) We use as quantitative truth space the real number interval A := [0, 1] with Ð := ≤, which denote probabilities. 6 We take a single modality E for expectation, where (M |= E(Θ)) gives the expected value of (V |= Θ) given the probabilistic distribution M induces on its return values V . This is achieved by giving E the denotation JE) : TreesΣp (A) → A which sends a tree of real numbers to the expected real number, where the approximation of the denotation is given by: JE)n+1(por(t, r)) = (JE)n(t)+ JE)n(r))/2.

5 For the examples, each Jq) will be an Eilenberg-Moore algebra, though this needs not be the case in general.
6 One could alternatively consider [0, ∞] as the value set, with the standard order.

Example 2 (Global store) Given a set of locations L, we have a set of states S := L → N. Our set of truth values is given by the powerset A := P(S) with Ð := ⊆. We have a single modality G, where (M |= G(Θ)) gives the set of starting states for which M terminates with a value V such that the end state is contained in (V |= Θ). We deﬁne this formally with the following rules: JG)n+1(lookupl(t0, t1,... )) =
{s ∈ S | s ∈ JG)max(0,n−s(l))(ts(l))} and JG)n+1(updatel,m(t)) = {s | s[l := m] ∈
JG)n(t)}. To ensure that the modality is continuous, as required later on in this paper, the deﬁnition of JG)n+1 at lookup(t0, t1,... ) has been constructed in such a way that it only depends on a ﬁnite amount of subtrees, in particular t0, t1,..., tn.
Example 3 (Probabilistic choice and global store) For this combination of effects, we take as truth space the functions A := [0, 1]S with point-wise order, where S is the set of global states and [0, 1] the lattice of probabilities with stan- dard order. Intuitively, this space assigns to each starting state a probability that a property is satisﬁed. We deﬁne a single modality EG which, for each state s ∈ S, is given by the following rules: JEG)n+1(por(t, r))(s) := (JEG)n(t)(s)+ JEG)n(r)(s))/2, JEG)n+1(lookupl(t0, t1,... ))(s) = JEG)max(0,n−s(l))(ts(l))(s), and JEG)n+1(updatel,m(t))(s)= JEG)n(t)(s[l := m]).
Example 4 (Cost) We use the inﬁnite real number interval A := [0, ∞] with Ð :=
≥ denoting an abstract notion of cost (e.g. time). Trees are just branches in this example. We have a single modality C, where (M |= C(Θ)) is the cost it takes for M to evaluate plus the cost given by (V |= Θ), where V is the value M evaluates to. The deﬁnition of JC) : TreesΣc (A) → A is such that JC)n+1(costc(t)) = c + JC)n(t). Note that for any tree t either inﬁnite or with leaf ⊥, we have JC)(t) = ∞. This reflects the idea that a diverging computation will exceed any possible ﬁnite cost.
Example 5 (Combinations with nondeterminism) To  add  nonde- terminism to any of the previous examples,  we keep their truth space A  ∈  {[0, 1], P(S), [0, 1]X, [0, ∞]}, and extend the deﬁnition of their modality q ∈ {E, G, EG, C} in two ways, creating an optimistic modality q0 and a pessimistic modality q2 such that:
Jq0)n+1(nor(t, r))	=	Jq0)n(t) ∨ Jq0)n(r)	Jq2)n+1(nor(t, r))	=
Jq2)n(t) ∧ Jq2)n(r).
We add both for neutral nondeterminism. We can see the nondeterministic choice as being controlled by an external agent, which chooses a strategy for resolving the nondeterministic choices, like in a Markov decision process. E.g., E0 and E2 re- spectively maximize and minimize the expected score (see [19] for more descriptions of nondeterminism with probability). Similarly, C0 and C2 respectively minimize and maximize cost.
For instance, if the denotation |M| of a term M of type FN is given by the ﬁrst tree in Fig. 3, then (M |= E0({1})) = 1/2 and (M |= E2({1})) = 1/4. If |N| is given by the second tree from Fig. 3, then (N |= G0({0})) = {s ∈ S | s(l)=0 ∨ s(r)= 0} and (N |= G2({0})) = {s ∈ S | s(l)=0= s(r)}.
Example 6 (Combinations with error) There are two ways of deﬁning com- binations with error messages, akin to the sum and tensor approach of combining



n ∈ N


{n}∈ Form(N)
φ ∈ Form(C)

⟨φ⟩∈ Form(U C)
φ ∈ Form(Aj )


(j, φ) ∈ Form(Σi∈I Ai)
φ ∈ Form(A)

π1φ ∈ Form(A × B)

φ ∈ Form(B)

π2φ ∈ Form(A × B)
V ∈ Terms(A)	φ ∈ Form(C) (V '→ φ) ∈ Form(A → C)
j ∈ I	φ ∈ Form(Cj ) (j '→ φ) ∈ Form(Πi∈I Ci)

q ∈Q	φ ∈ Form(A)

q(φ) ∈ Form(FA)
X ⊆countable Form(.E..)


W X ∈ Form(.E..)
X ⊆countable Form(.E..)

  X ∈ Form(.E..)

.φ.. ∈ Form(.E..)	a ∈ A

.φ..Ḏa ∈ Form(.E..)
a ∈ A


κa ∈ Form(.E..)
.φ.. ∈ Form(.E..)

¬.φ.. ∈ Form(.E..)


Fig. 4. Formula constructors
effects from e.g. [12]. Let Σ, A and Q be the signature, truth space, and quantitative modalities of the effects to which we want to add error messages from a set E. Given a modality q ∈Q and some function f : E → A, assigning to each message a value, we deﬁne a new modality qf which, besides inheriting the rules from q, follows the rule Jqf )n+1(raisee)= f (e). We deﬁne two new sets of modalities for this combina- tion, Q+ := {qf | q ∈ Q,f : E → {F, T}} and Q× := {qf | q ∈ Q,f : E → A}, each giving a different interpretation of error.
For instance, in the presence of global store (Example 2), the modalities from Q+ are not able to observe the ﬁnal global state when an error message has been raised, whereas some modalities from Q× can. For instance, for e ∈ E and f : E → A such that f (e) := {s[l := 1] | s ∈ S}, it holds that Gf is in Q× but not in Q+. Moreover, (updatel(1, raisee()) |= (Gf (T))) = T whereas (updatel(0, raisee()) |= Gf (T)) = F. Those two terms are however not distinguishable by any modality from Q+.
All the Boolean-valued examples of modalities for effects in [29], can also be accommodated in our quantitative setting by taking A := {T , F}. These include modalities for the Input/Output effect.
Formulation of the logic
We write Form(.E..) for the set of formulas over type .E.., which is defined by induction on the structure of .E... Fig. 4 gives the inductive rules for generating these formulas. We have modality formulas q(φ), constant formulas κa, and step formulas .φ..Ḏa. Note that conjunctions and disjunctions (i.e., meets and joins) are taken over countable sets of formulas only.
We define a quantitative satisfaction relation |=: Terms(.E..)×Form(.E..) → A, thus for .P.. ∈ Terms(.E..) and φ ∈ Form(.E..), the satisfaction statement (.P.. |= φ) denotes an element of A. Satisfaction of the formulas is defined inductively by the following rules:

(V |= {n})	:=	T  if V = n
F  otherwise.
((i, V ) |= (j, φ))	:=	(V |= φ)	if i = j.
F	otherwise.

The modality formula q(φ) is particularly important, as it expresses how the quan-

titative modalities are used to observe effects. The last couple of satisfaction rules are for formula constructors occurring at each type.
(.P.. |=  X) := sup{(.P.. |= .φ..) | .φ.. ∈ X}.	(.P.. |=  X) := inf{(.P.. |= .φ..) | .φ.. ∈ X}.


(P |= φ
) :=  T	if (.P.. |= .φ..) Ḏ a.	(.P.. |= κa) := a.


All formulas together form the general logic V. We distinguish a specific fragment of V, the positive logic V+ excluding all formulas which use ¬(). The logic V+ can be interpreted without defining an involution for A.
We end this section by looking at some interesting properties we can con- struct using the logic, illustrating the expressibility of the logic. In case of global store (Example 2), we can construct formulas in the style of Hoare logic. For instance, taking two subsets P, Q ∈ A = P(S) of global states, the statement M |= G(κQ)ḎP will give T , precisely if, when starting the execution of M with a state from P , the execution will terminate with a state from Q. As another ex- ample, in case of global store with probability (Example 3), where A := [0, 1]S, we can construct, given a formula φ and a distribution of states μ ∈ [0, 1]S, a formula Σμ(φ) such that (M |= Σμ(φ))(s) = min(1,  s∈S μ(s) · (M |= φ)(s)). Then (M |= Σμ(EG(κT ))) expresses the probability of termination of M , given that the starting state is sampled from μ. In the same vein, we can look at the combination of probability and nondeterminism (Example 1 and 5), where
(M |=  a,b∈[0,1](E0(κT )Ḏa ∧ E2(κT )Ḏb ∧ κ(a+b)/2)) expresses the probability that M terminates, given that the agent/scheduler in control of nondeterministic choice is sampled from a distribution of which 50% is helpful and 50% is antagonistic.

Behavioural equivalence
We can define a logical preorder for any sub-collection of formulas L.
Definition 4.1 For any fragment of the logic L ⊆ V, the logical preorder ±L is given by:
∀.P.., R... ∈ Terms(.E..), .P.. ±L R... ⇐⇒ (∀.φ.. ∈ Form(.E..), (.P.. |= .φ..) Ð (R... |= .φ..))
The logical equivalence ≡L is given by ±L ∩ ±L.
The general behavioural preorder ± is the logical preorder ±V , whereas the pos- itive behavioural preorder ±+ is the logical preorder ±V + . We denote ≡ and ≡+ for the logical equivalences ≡V and ≡V + respectively (the behavioural equivalences). These closed relations can be extended to relations on open terms by using the open extension (where two open terms are related if they are related for any substitution of context variables).
A basic formula is a non-constant formula (not necessarily atomic) which on the top level does not have conjunction , disjunction , negation ¬, a constant formula κa or step-construction (−)Ḏa. It is not difficult to see that both ± and

±+ are completely determined by basic formulas. Note that since V+ ⊆ V, it holds that (±) ⊆ (±+) and (≡) ⊆ (≡+).
Lemma 4.2 The general behavioural preorder ± is symmetric, so (±)= (≡).
Proof. Assume .P.. ± R..., then for any formula .φ.. we have ¬(.P.. |= .φ..)= (.P.. |= ¬(.φ..)) Ð
(R... |= ¬(.φ..)) = ¬(R... |= .φ..). Hence (R... |= .φ..) Ð (.P.. |= .φ..) for any .φ.., so R... ± .P...	2
Lemma 4.3 For any fragment L of the logic V closed under countable conjunctions,

it holds that for any term
.P.. :
.E.. there is a formulas χ.P.. s.t.: If
.P.. ±L R... then

(R... |= χ.P.. )= T, and if .P.. /±L R... then (R... |= χ.P.. )= F.
Proof. For any R... : .E.. such that .P.. /±L R... we can find a formula ψR... such that (.P.. |= ψR... ) /Ð (R... |= ψR... ). We choose such a formula for each R... as above, and define

R...
Ḏ(.P..|=ψ.R.. )
| R... : .E.., .P.. /±L R...}, which is countable since there are countably

many terms. Then χ.P.. :=	X has the desired properties.	2
Lemma 4.4 For L∈ {V, V+}, we have the following characterisations of the logical preorder R := ±L:

V RNW ⇐⇒ V = W.
V jRBWj.

MRU CN ⇐⇒ force(M ) RC force(N ). (v) MRA→CN	⇐⇒	∀V : A, M ·

(j, V )RΣi∈I Ai (k, W )	⇐⇒	(j =
k) ∧ V RAj W.
(V, V j)RA×B(W, Wj) ⇔ V RAW ∧
V RC N · V .
(vi) MRΠi∈I Ci N	⇐⇒	∀j ∈ I, M ·
j RMj N · j.

Proof. Note that at each type level, the preorder is completely determined by basic formulas. All other formulas depend solely on the satisfaction of basic formulas, by a simple induction. As such, the above characterisations are a simple consequence of unfolding the satisfaction relation of basic formulas.	2

Congruence properties
A relation on terms is compatible, if it is preserved over the typing rules from Fig. 1. We introduce the three properties that we will require in order to establish that (the open extensions of) the behavioural preorders are compatible, hence precongruences. The space TΣ(A), which forms the basis of the technical definition of the modalities, plays a fundamental role in this.
The first property considers the leaf order TΣ(Ð) on TΣ(A), where t TΣ(Ð) r if r can be created by replacing leaves a ∈ A of t by leaves b ∈ A of higher value a Ð b. The ⊥ leaves can however not be replaced.
Definition 4.5 A modality q ∈Q is leaf-monotone if ∀t, r ∈ TΣ(A), t TΣ(Ð) r =⇒
Jq)(t) Ð Jq)(r).
This property is useful for establishing a variety of different results, but mainly just shows that modalities preserve the implicit (point-wise) order .φ.. ⇒ ψ  on formulas
(.φ.. ⇒ ψ... iff ∀.P.., (.P.. |= .φ..) Ð (R... |= ψ )).

The second property considers the ω-complete tree order ≤ on TΣ(A), defined just after Definition 2.1.
Definition 4.6 A modality q ∈ Q is Scott tree continuous if for any ascending chain t0 ≤ t1 ≤ t2 ≤ ... it holds that Jq)( n∈N tn)= sup{Jq)(tn) | n ∈ N}.
This is property is necessary in the congruence proof for inductively approximating the satisfaction value of infinite trees generated by the fixpoint operator and infinite arity effect operators. Note that this continuity assumption rules out countable nondeterminism as a possible example in this framework.
The third and final property is the most technical one, and considers the preser- vation of the behavioural preorder over sequence operations such as (−) to x. (−). It considers the monad multiplication map μ : TΣ(TΣ(A)) → TΣ(A), and requires that the abstract generalisation of the behavioural preorder on TΣ(TΣ(A)) and TΣ(A) is preserved by the μ-map. To formulate this, we need first define these abstract relations.
We write h : A →Ð A to say that h is a monotone function from A to A, so a Ð b ⇒ h(a) Ð h(b). For a function h : X → Y we write h∗ : TΣ(X) → TΣ(Y ) for its (functorial) lifting defined by h∗(t) := t[x → h(x)]. For a function h : X → A (a valuation on X) and a modality q ∈ Q, we write t ∈ q(h) for Jq)(h∗(t)).
Definition 4.7 For any two trees t, tj ∈ TΣ(A), t ≤ tj	⇐⇒	∀q ∈ Q, ∀h : A →Ð
A, (t ∈ q(h)) Ð (tj ∈ q(h)).
For any relation R ⊆ X × Y , and valuation h : X → A, we define (R ↑(h)) : Y → A to be the function such that R ↑(h)(b) := supa∈X,aYb(h(a)). We classify abstract quantitative behavioural properties on TΣ(A). A function H : TΣ(A) → A is called quantitative behaviourally saturated if for any two trees t, tj ∈ TΣ(A) such that t ≤ tj, it holds that H(t) Ð H(tj). We write QBS for the set of quantitative behaviourally saturated functions. Note that H ∈ QBS if and only if there is a function F : TΣ(A) → A such that H =≤↑(F ). Moreover, for any q ∈ Q, it is easy to see that Jq) ∈ QBS. We define a relation on quantitative double trees TΣ(TΣ(A)).

Definition 4.8 We define the preorder  on TΣ(TΣ(A)) by: for any two quanti- tative double trees r, rj ∈ TΣ(TΣ(A)),  r  rj  ⇐⇒  ∀q ∈ Q, ∀H ∈ QBS, r ∈ q(H) Ð rj ∈ q(H).
Lemma 4.9 If all modalities q ∈ Q are leaf-monotone, then for any two r, rj ∈
TΣ(TΣ(A)),
r  rj	⇐⇒	∀F : TΣ(A) → A, ∀q ∈ Q, r ∈ q(F ) Ð rj ∈ q(≤↑(F )).
Proof. For ‘⇒’, note that for any t ∈ TΣ(A), F (t) Ð ≤↑(F )(t) so the result follows from leaf-monotonicity and the fact that ≤↑ (F ) ∈ QBS. For ‘⇐’, use that for H ∈ QBS, ≤↑(H)= H.	2
We can define the third property, decomposability, together with its stronger

counterpart, sequentiality. 7
Definition 4.10 Q is decomposable if for all t, r ∈ TΣ(TΣ(A)), if t  r then μt ≤
μr. A modality q ∈Q is sequential if for all t ∈ TΣ(TΣ(A)), Jq)(μt)= Jq)(Jq)∗(t)).
Lemma 4.11 If all modalities q ∈ Q are leaf-monotone and sequential, then Q is decomposable.
Proof. Assume r  rj, and let q ∈ Q and h : A →Ð A. It is easy to see that Jq) ∈ QBS, so (Jq) ◦ h∗) ∈ QBS too. Since q is sequential, Jq)(h∗(μr)) = Jq)(μ(h∗∗(r))) = Jq)(Jq)∗ ◦ h∗∗(r)) = (r ∈ q(Jq) ◦ h∗)) Ð (rj ∈ q(Jq) ◦ h∗)) which is by the same steps equal to Jq)(h∗(μrj)). Hence μr ≤ μrj, and as such, Q is decomposable.	2
The three properties defined above allow us to establish compatibility, as argued in the next section.
Theorem 4.12 If Q is a decomposable set of leaf-monotone and Scott tree contin- uous modalities, then ± and ±+ are compatible, hence precongruences.
All our examples satisfy these three properties. Both leaf-monotonicity and Scott tree continuity are consequences of the inductive and hence continuous definitions of the modalities, while decomposability holds by observing that any modality from the examples is sequential. We illustrate this in the following lemma.
Lemma 4.13 In Example 5 of combined probability and nondeterminism, E2 is sequential.
Proof. Take r, rj ∈ TΣ(TΣ(A)) as above and assume JE2)(μr) > a ∈ [0, 1], then since JE2)(μr) = supn(JE)n(μr)) there must be an n ∈ N such that JE)n(μr) >
a. By the recursive definition of JE2)(—) we can see that JE)n(r[t '→ JE)n(t)]) ≥
JE)n(μr), and hence by leaf- and Scott tree continuity JE2)(JE2)∗(r)) > a.
Now assume JE2)(JE2)∗(r)) > a, then there must be an m such that JE)m(JE2)∗(r)) > a. Now, JE)m only looks at a finite amount of leaves, and hence there must be a k such that JE)m(JE)∗(r)) > a. Again, studying the recursive def- inition of JE2)(—) we observe that JE2)m+k(μr) ≥ JE)m(JE)∗(rj)), so we conclude that JE2)(μr) > a. This is for all such a ∈ A, so JE2)(μr)= JE2)(JE2)∗(r)).   2
We end this section with an example of an equivalence and an in-equivalence. It has to be said that the purpose of this paper is to give a widely applicable approach to deﬁning equivalence, not to prove equivalence of terms. Moreover, for practical purposes, establishing an in-equivalence is easier than establishing an equivalence, since you only have to find one formula which distinguishes the two.
As an example, we look at the combination of cost and nondeterminism, given by signature Σcn, truth space [0, ∞] with reverse order (Ð:=≥), and modalities {C0, C2}. Consider the two terms M := cost1(return(7)) and N := nor(return(7), cost3(return(7))), both of which always return 7, though N may re- turn it at a lower or higher cost. Then M /±+ N , since (M |= C2({7})) = 1 /Ð 3= 

7 Sequentiality is one of two properties for Jq) to be an Eilenberg-Moore algebra for the monad TΣ(—).

(N |= C2({7})), and N /±+ M , since (N |= C0({7})) = 0 /Ð 1 = (M |= C0({7})).
However, taking K := nor(M, N ), it can be shown that K ≡ N , since for any formula φ ∈ Form(N), (N |= C0(φ)) = (7 |= φ) = (K |= C0(φ)) and (N |= C2(φ)) = (7 |= φ)+3 = (K |= C2(φ)).
Applicative Bisimilarity
We investigate how our quantitative modalities can be used to define a notion of Abramsky’s applicative bisimilarity [1], related to the behavioural equivalence (Theorem 5.7), starting off by defining a relator [18,30].
Definition 5.1 Given Q, we have a relator Q(−) : P(X × Y ) → P(TX × TY ) given by:
t Q(R) r ⇐⇒ ∀q ∈ Q, ∀h : X → A,t ∈ q(h) Ð r ∈ q(R ↑(h))
We write xRy for (x, y) ∈ R. Remember from the previous section that (t ∈ q(h)) = Jq)(h∗(t)) = Jq)(t[x '→ h(x)]) and (R ↑(h))(b) := sup{h(a) | a ∈ X, aRb}. Note that Q(Ð) = ≤ and Q(≤) = (see Lemma 4.9). The following characterisation of the relator is immediate:
Lemma 5.2 For any t ∈ TX, r ∈ TY , and R ⊆ X × Y , t Q(R) r  ⇐⇒ ∀h :
X → A, h∗(t) ≤ (R ↑(h))∗(r).
The following lemma shows that this satisfies the usual properties of monotone relators from [18,30]. The proof is technical yet straightforward, and is left out to preserve space.
Lemma 5.3 If all quantitative modalities from Q are leaf-monotone, then Q(−)
has the following properties:
If R is reflexive, then so is Q(R).
If R⊆ S, then Q(R) ⊆ Q(S).
For R⊆ X × Y and S ⊆ Y × Z, Q(R)Q(S) ⊆ Q(RS). Here RS is relational concatenation.
∀f : X → Z, g : Y → W, R ⊆ Z × W it holds that Q((f × g)—1R) = (f∗ ×
g∗)—1Q(R)
where (f × g)—1(R)= {(x, y) ∈ X × Y | f (x) Rg(y)}.
Fundamental to the definition of the relator is the notion of the right-predicate R ↑ (h). When the relation in question is our behavioural preorder, these right- predicates can be expressed in the logic.
Lemma 5.4 Take L ∈ {V, V +}. For any predicate D : Terms(A) → A, there is a formula φD ∈L such that (V |= φD)= (±L↑(D))(V ) for any term V ∈ Terms(A).
Proof. We use Lemma 4.3 to define φD :=  {  {κD(V ), χV }| V ∈ TΣ(A)}.	2

In the case that R is a relation on terms of some value type A, we write Q(R) for the relation on terms of type FA given by Q({(return(V ), return(W )) | V RAW}). A relation R on terms is well-typed, if it only relates terms of the same type and context, and R is closed if it only relates closed terms.
Definition 5.5 A well-typed closed relation R is an applicative Q-simulation if:

V RNW =⇒ V = W .
MRU CN =⇒ force(M ) RC force(N ).
(j, V )RΣi∈I Ai (k, W )	=⇒	(j  =
k) ∧ V RAj W .
(V, V j)RA×B(W, Wj)	=⇒
V RAW ∧ V jRBWj.
MRA→CN	=⇒	∀V  : A, M ·
V RC N · V .
MRΠi∈I Ci N	=⇒	∀j ∈ I, M ·
j RMj N · j.
MRFAN  =⇒ |M| Q(RA) |N| .

The applicative Q-similarity is the largest applicative Q-simulation, whereas the
applicative Q-bisimilarity is the largest symmetric applicative Q-simulation.
Theorem 5.6 If all quantitative modalities from Q are leaf-monotone, then the positive behavioural preorder ±+ is the applicative Q-similarity.
Proof. Note that ±+ satisfies the first 6 properties for being a Q-simulation as a consequence of Lemma 4.4. We prove the seventh property:
Assume M ±+ N , q ∈ Q and D : Terms(A) → A. We use Lemma 5.4 to find a formula φD such that (V |= φD) = (±+↑(D))(V ). By reflexivity of ±+, we have D(V ) Ð (±+↑(D))(V ), so by leaf-monotonicity and M ±+ N it holds that: Jq)(D∗(|M|)) Ð (M |= q(φD)) Ð (N |= q(φD)) = Jq)((±+↑(D))∗(|N|)). We can conclude that |M|Q(±+)|N|. So we proved that ±+ is a Q-simulation.
We now need to prove that ±+ contains any other Q-simulation R. To do that, we show that R preserves any formula .φ.. in the following sense: If .P.. R R..., then (.P.. |=
.φ..) Ð (R... |= .φ..). We do this by induction on formulas, using the fact that any formula

is well-founded.  Assume
.P.. R R.... Suppose R preserves any formula from X ⊆

Form(P). Then (P |=	X)= sup{(P |= φ) | φ ∈ X} Ð sup{(R |= φ) | φ ∈ X} = (R... |=  Y ) and (.P.. |=  X) = inf{(.P.. |= .φ..) | .φ.. ∈ X} Ð inf{(R... |= .φ..) | .φ.. ∈ X} =
so (R... |= .φ..) Ḏ a, hence (R... |= .φ..Ḏa)= T . R obviously preserves constant formulas,
since (.P.. |= κa)= a Ð a = (R... |= κa).
It is not difficult to prove that R preserves most basic formulas. The only difficult formula to consider is q(φ) ∈ Form(FA). Assume MRN , so by simulation property
|M| Q(R) |N|. By induction hypothesis and relator property 2 in Lemma 5.3, it holds that |M|Q(±+)|N|. Hence (M |= q(φ)) Ð Jq)((±+↑(V '→ (V |= φ)))∗(|N|)), which since (±+↑(V '→ (V |= φ)))(W ) Ð (W |= φ) means with leaf-monotonicity of q that (M |= q(φ)) = Jq)(|M|[φ]) Ð Jq)(|N|[φ]) = (N |= q(φ)). We conclude that M ±+ N .
We can conclude that ±+ is the largest Q-simulation, hence it is equal to Q- similarity.	2

Note the crucial use of Lemma 5.4 in the proof, which explains the need for the step-formulas in the logic.
Theorem 5.7 If all quantitative modalities from Q are leaf-monotone, then the general behavioural preorder ± is the largest symmetric applicative Q-simulation, and hence equal to applicative Q-bisimilarity.
Proof. Firstly, it holds by Lemma 4.2 that ± is symmetric. Secondly, ± is a Q- simulation by the same proof as above. Lastly, any symmetric Q-simulation R is included in ±, using a similar proof as above, proving with induction on formulas
.φ.. that .P.. R R... implies (R... |= .φ..) Ð (.P.. |= .φ..) and (.P.. |= .φ..) Ð (R... |= .φ..).	2

Howe’s method
In this subsection, we briefly outline how Howe’s method [10,11] can be used to establish compatibility for the open extension of applicative Q-similarity and Q- bisimilarity as in [3,29]. Firstly, we need some properties of the relators in addition to Lemma 5.3. The proofs are technical and are left out to preserve space.
Lemma 5.8 If all q ∈ Q are leaf-monotone and Scott tree continuous, then the following four properties hold:
∀R ⊆ X × Y, t ∈ TΣ(X),r ∈ TΣ(Y ), tQ(R)r ∧ tj ≤ t ∧ r ≤ rj =⇒ tjQ(R)rj.
For any two chains of trees t0 ≤ t1 ≤ ... and r0 ≤ r1 ≤ ... ,  ∀n ∈
N.(tnQ(R)rn) ⇒ (Hntn)Q(R)(Hnrn).
∀R ⊆ X × Y , S ⊆ A × B and (f, g): X × Y → A × B, (xRy ⇒ f (x)Sg(y)) ⇒
(tQ(R)r ⇒ f∗(t)Q(S)g∗(r)).
∀R ⊆ X × Y, x ∈ X, y ∈ Y , xRy =⇒ η(x)Q(R)η(y)
The following lemma necessarily uses the property of decomposability.
Lemma 5.9 Given a decomposable set Q of leaf-monotone modalities, then:
aQ(Q(R))b ⇒ μaQ(R)μb.
Proof. Assume a Q(Q(R)) b and take some h : X → A. Let t := h∗∗(a) and r := (R ↑(h))∗∗(b), then μt = h∗(μa) and μr = R ↑(h)∗(μb). In the next paragraph, we are going to prove that t  r using Lemma 4.9, so we can use decomposability to derive μt ≤ μr, from which we can conclude that h∗(μa) ≤ (R ↑(h))∗(μb), which by Lemma 5.2 implies μaQ(R)μb.
We prove that t   r.	Let q ∈ Q and H ∈ QBS, then (t ∈ q(H)) =
Jq)(H∗(t)) = Jq)((H ◦ h∗)∗(a)) = (a ∈ q(H ◦ h∗)) Ð (b ∈ q(Q(R) ↑(H ◦ h∗))). Now
(Q(R) ↑ (H ◦ h∗))(k) = sup{H(h∗(l)) | lQ(R)k} Ð sup{H(h∗(l)) | h∗(l) ≤ (R ↑ (h))∗(k)} by Lemma 5.2.  Since H ∈ QBS, the statement is smaller than H((R ↑(h))∗(k)). Hence using leaf-monotonicity, (b ∈ q(Q(R) ↑((H ◦ h∗)))) Ð (b ∈ q(H ◦ (R ↑(h))∗) = (r ∈ q(H)). So we can conclude that (t ∈ q(H)) Ð (r ∈ q(H)), and we are finished.	2

Corollary 5.10 Given that Q is a decomposable set of leaf-monotone and Scott tree continuous modalities:
(∀x, y, xRy ⇒ f (x)Q(S)g(y)) ∧ tQ(R)r ⇒ μ(f∗(t))Q(S)μ(g∗(r))
(∀k, ukQ(S)vk) ⇒ op(u0, u1, ...)Q(S)op(v0, v1, ...)
One of the contributions of this paper is identifying the properties on quanti- tative modalities for which the above relator properties are satisfied, such that we can apply Howe’s method. The application of Howe’s method itself is however not novel, and is simply an alteration of the proof used for the call by value case in [3,29] (untyped and simply-typed respectively), using results from [15]. As such, details of the proof have been omitted. In short, Howe’s method allows us to establish the following theorem.
Theorem 5.11 If Q is a decomposable set of leaf-monotone and Scott tree contin- uous quantitative modalities, then Q-similarity and Q-bisimilarity are compatible.
Combining theorems 5.6, 5.7, and 5.11 we can derive Theorem 4.12, that the general and positive behavioural equivalence (and preorder) are compatible, and therefore (pre)congruences.
Discussions
We have generalised the logic from [29] toa quantitative logic for terms of a call-by- push-value language with general recursion and several (combinations of) algebraic effects. The quantitative logic is expressive, contains only meaningful behavioural properties, and induces a compatible program equivalence on terms.
In this paper, we consider program properties (or observations) as the primary way of describing program behaviour. According to this philosophy, the generalisa- tion to quantitative properties is natural. Alternatively, one could consider relations (or comparisons) as primary, and instead generalise to quantitative relations. The resulting theory is that of metrics, along the lines of [2,4,20]. Relating the logic from this paper, or a variation thereof, to metrics (e.g. like the ones in [7]) is a topic for future research.
The quantitative logic does not however naturally induce a metric on the terms. This is mainly because of the inclusion of step-formulas φḎa, which takes the quan- titative information from φ and collapses it to a binary value. These step-formulas are necessary for relating the behavioural equivalence with applicative bisimilarity. Their necessity can be seen as a natural consequence of the non-linearity of the language. E.g., in the case of probability with A := [0, ∞], the step-formula can be constructed using products of formulas.
The quantitative logic is very expressive, allowing one to deal with some awkward combinations of effects that are not amenable to a boolean treatment. Despite the many examples of combination of effects, there is no general theory for quantitative modalities of combined effects. Such a theory is a potential subject for further research. It would also be interesting to look at other examples of effects which the

quantitative logic could describe, like a the algebraic jump effect described in [6], or some form of concurrency.
The logic and examples from [29] can be considered as further examples for this paper, where one considers A := {T , F}. The property of Scott openness is the Boolean version of a combination of Scott tree continuity and leaf-monotonicity, and the notion of decomposability is a quantitative generalisation of the notion from [29] with the same name. It should be noted, however, that most modalities from [29] are not sequential.
Along the lines of [29], it is possible to define a pure variation of the logic. This is a logic independent of the term syntax, using function formulas of the form (ψ '→ φ) instead of (V '→ φ), where (M |= (ψ → φ)) := {(M ·V |= φ) | (V |= ψ)= T }. The logical equivalence of this pure logic will be equal to the behavioural equivalence, if (the open extension of) the behavioural equivalence is compatible.
The denotation Jq) : T A → A of quantitative modalities are, in the case of the running examples, Eilenberg-Moore algebras. These are algebras a : TX → X such that a ◦ ηX = idX and a ◦ Ta = a ◦ μX , the second statement coincides with the property of sequentiality in this paper. As such, our example modalities potentially fit into the framework of Hasuo [8]. Connections between the two approaches may be explored in the future.
Since the theory has been formulated for call-by-push-value, one can extract logics for specific reduction strategies including; call-by-name, call-by-value and lazy PCF [16,17]. The language can also be extended with universal (but not existential) polymorphic and recursive types. These extensions of the language are worked out in the author’s forthcoming thesis. Further extensions could be considered in the future.

Acknowledgement
I would like to thank Alex Simpson, Francesco Gavazzo, Aliaume Lopez, and the anonymous reviewers for all the helpful discussions and comments.

References
Samson Abramsky. The lazy λ-calculus. Research Topics in Functional Programming, pages 65–117, 1990.
Andr´e Arnold and Maurice Nivat. Metric interpretations of infinite trees and semantics of non deterministic recursive programs. Theoretical Computer Science, 11(2):181 – 205, 1980.

Ugo Dal Lago, Francesco Gavazzo, and Paul Blain Levy. Effectful applicative bisimilarity: Monads, relators, and Howe’s method. Logic in Computer Science, pages 1–12, 2017.

Mart´ın Hotzel Escard´o. A metric model of PCF, 1999. In: Workshop on Realizability Semantics and Applications.

Matthias Felleisen and Daniel P. Friedman. Control operators, the SECD-machine, and the lambda- calculus. Formal Description of Programming Concepts, pages 193–217, 1986.

Marcelo Fiore and Sam Staton. Substitution, jumps, and algebraic effects. In Proceedings of the Joint Meeting of the Twenty-Third EACSL Annual Conference on Computer Science Logic (CSL) and the Twenty-Ninth Annual ACM/IEEE Symposium on Logic in Computer Science (LICS), CSL-LICS ’14, pages 41:1–41:10, New York, NY, USA, 2014. ACM.
Francesco Gavazzo. Quantitative behavioural reasoning for higher-order effectful programs: Applicative distances. Proceedings of the 33rd Annual ACM/IEEE Symposium on Logic in Computer Science, pages 452–461, 2018.
Ichiro Hasuo. Generic weakest precondition semantics from monads enriched with order. Theor. Comput. Sci., 604(C):2–29, November 2015.
Matthew Hennessy and Robin Milner. Algebraic laws for nondeterminism and concurrency. Journal of the ACM (JACM), 32(1):137–161, 1985.
Douglas J. Howe. Equality in lazy computation systems. Proc. 4th IEEE Symposium on Logic in Computer Science, pages 198–203, 1989.
Douglas J. Howe.	Proving congruence of bisimulation in functional programming languages.
Information and Computation, 124(2):103–112, 1996.
Martin Hyland, Gordon Plotkin, and John Power. Combining effects: Sum and tensor. Theor. Comput. Sci., 357(1):70–99, July 2006.
Patricia Johann, Alex Simpson, and Janis Voigtl¨ander. A generic operational metatheory for algebraic effects. Logic in Computer Science, pages 209–218, 2010.
Dexter Kozen. Probabilistic PDL. Journal of Computer and System Sciences, 30:162–178, 1985.
Søren Bøgh Lassen. Relational Reasoning about Functions and Nondeterminism. PhD thesis, BRICS, 1998.
Paul Blain Levy. Call-By-Push-Value. PhD thesis, University of London, 2001.
Paul Blain Levy. Call-by-push-value: Decomposing call-by-value and call-by-name. Higher-Order and Symbolic Computation, 19(4):377–414, 2006.
Paul Blain Levy. Similarity quotients as final coalgebras. Lecture Note in Computer Science, 6604:27– 41, 2011.
Aliaume Lopez and Alex Simpson. Basic operational preorders for algebraic effects in general, and for combined probability and nondeterminism in particular. In 27th EACSL Annual Conference on Computer Science Logic, CSL 2018, September 4-7, 2018, Birmingham, UK, pages 29:1–29:17, 2018.
Radu Mardare, Prakash Panangaden, and Gordon D. Plotkin. Quantitative algebraic reasoning. In Proceedings of the 31st Annual ACM/IEEE Symposium on Logic in Computer Science, LICS ’16, New York, NY, USA, July 5-8, 2016, pages 700–709, 2016.
Annabelle McIver and Carroll Morgan. Abstraction, Refinement And Proof For Probabilistic Systems (Monographs in Computer Science). SpringerVerlag, 2004.
Eugenio Moggi. Notions of computation and monads. Information and Computation, 93(1):55–92, 1991.
Eugenio Moggi. A general semantics for evaluation logic. 9th LICS, page 353–362, 1994.
Andrew M. Pitts. Evaluation logic. In Proceedings of 4th Higher Order Workshop, pages 162–189, 1991.
Gordon Plotkin. LCF considered as a programming language. Theoretical Computer Science, 5(3):223– 255, 1977.
Gordon Plotkin. Adequacy for infinitary algebraic effects. In Proceedings of the 3rd International Conference on Algebra and Coalgebra in Computer Science, CALCO’09, pages 1–2, Berlin, Heidelberg, 2009. Springer-Verlag.
Gordon Plotkin and John Power. Adequacy for algebraic effects. Foundations of Software Science and Computation Structures, pages 1–24, 2001.
Gordon Plotkin and Matija Pretnar. A logic for algebraic effects. 23rd Symposium on Logic in Computer Science, pages 118–129, 07 2008.
Alex Simpson and Niels Voorneveld. Behavioural equivalence via modalities for algebraic effects. In Programming Languages and Systems - 27th European Symposium on Programming, pages 300–326, 2018.
Albert Marchienus Thijs. Simulation and fixpoint semantics. PhD thesis, University of Groningen, 1996.
