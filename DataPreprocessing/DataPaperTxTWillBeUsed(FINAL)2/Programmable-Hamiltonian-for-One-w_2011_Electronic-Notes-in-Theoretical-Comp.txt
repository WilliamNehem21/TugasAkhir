

Electronic Notes in Theoretical Computer Science 270 (2) (2011) 155–161
www.elsevier.com/locate/entcs

Programmable Hamiltonian for One-way Patterns
S. Saleka F. Seifana E. Kashefib
a Faculty of Mathematics, Statistics and Computer Science, University of Tehran, Iran
b School of Informatics, University of Edinburgh, UK

Abstract
We construct a family of time-independent Hamiltonians which are able to perform universally pro- grammable quantum computation. The construction is obtained via direct translation of one-way computer assembly language code into a Hamiltonian evolution. We also present how to evolve adiabatically to this Hamiltonian. It is hoped that this approach contributes further into the study of the structural relationship between measurement-based and adiabatic models of quantum computing.
Keywords: Hamiltonian evolution, adiabatic evolution, universal quantum computer, quantum circuit model

Introduction
After Feynman’s proposal for quantum computers different models have been de- signed to perform universal quantum computation, with the most widely used one being the quantum circuit model (QC) [3]. Recently, distinctly different models have emerged, namely adiabatic quantum computing (AQC) [2,4], and measurement- based quantum computing (MBQC) [5,6]. These new models suggest different ar- chitectures, and fault tolerant schemes, and provide specific approaches to new applications and algorithms, and specific means to compare classical and quantum computation.
The central question that this paper aims to make a progress upon is the study of the structural relationship between MBQC and AQC. Several methods for the adiabatic simulation of a given circuit have been already proposed [7,8]. These methods are essentially based on rewriting a circuit into rounds of computation with few gates in each round, which are then used to construct a corresponding local Hamiltonian. In another approach adiabatic evolution has been exploited to make the MBQC computation more robust [9]. Our construction differs from the previously known results in presenting a programmable Hamiltonian construction

1571-0661 © 2011 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.01.029

which leads to an Adiabatic evolution. A programmable model is one that includes ‘program’ and ‘data’ regions and the state of the program region determines which operations are to be applied to the data register. Hence, instead of hard wiring for every particular problem, we can have a programmable model and just initialise the state of the program region through software for different problems. Furthermore we achieve locality for our construction by the usage of geometric clock. Our approach can be also easily adapted to inherit the intrinsic parallel structure of the MBQC, however there would be a trade-off between parallelism and the required dimension of the physical system to implement the construction.
The Feynman Hamiltonian [10] was the first construction which considered two registers for the computer, one for the data and the other for what he called cursor :
T

1
H = √
Σ U σ+σ−
+ U†σ+ σ−
(1)

f	
T +1 
t t
t=1
t−1
t  t−1 t

where T is the number of unitary transformations to be applied, σ+ and σ− are
k	k
raising and lowering operators on the kth cursor qubit out of T + 1 ones. Later,
Kitaev constructed a similar Hamiltonian, to encode quantum circuits into Hamil- tonian interaction [11]. He considered a system with two registers, clock register and work register. Kitaev’s Hamiltonian is a sum of three terms,
Hkitaev = Hprop + Hout + Hinput	(2)
The ground state of the first term is the uniform superposition over the history state and checks the correct propagation of the computation, second term ensures that Hkitaev can have low eigenvalue only for the input states which provide “yes” answer on the output of corresponding circuit. Finally the last term checks the correct initialisation of the ancilla qubits. After Kitaev, other people constructed different Hamiltonians with different properties, like the one which acts on a line [12].
While these time-independent Hamiltonians are universal for quantum computa- tion, one can also simulate any quantum circuit with a time-dependent Hamiltonian by adiabatic evolution [2]. In adiabatic quantum computation, we pick two Hamil- tonians which act on our system; Hinit and Hfinal, where the ground state of the first Hamiltonian is easy to construct while the ground state of the final Hamiltonian encodes the solution of the problem. We consider the time-dependent Hamiltonian as H(s)= (1 −s)Hinit + sHfinal. The adiabatic theorem states that if for all s, H(s) has a unique ground state, then for any fixed δ > 0 , if
	|| Hfinal − Hinit ||1+δ

T ≥ Ω
ϵδ mins∈[0,1]
{Δ2+δ (H(s))}
(3)

then the final state of an adiabatic evolution according to H for time T is ϵ-close in l2-norm to the ground state of Hfinal. 1 The equivalence of this model with quantum circuits was proved in [13,8].
On the other hand, a relatively different model called one-way quantum com- puter was introduced by Raussendorf and Briegel [5,6] where its algebraic struc-

1 The matrix norm is the spectral norm defined as || H ||= maxw || Hw || / || W ||.

ture was formalised in [1] and a simple assembly language for one-way compu- tation was provided. The basic commands of the language are: 1-qubit prepa- rations Ni that prepares qubit i in state |+⟩i, 2-qubit entanglement operators Eij := ∧Zij (controlled-Z), 1-qubit measurements Mα defined by orthogonal projec- tions |±α⟩⟨±α|i, applied at qubit i, with the convention that |+α⟩⟨+α|i corresponds to the outcome 0, while |−α⟩⟨−α|i corresponds to 1, and 1-qubit Pauli corrections Xi, Si, where i, j represent the qubits on which each of these operations apply, and α is a parameter in [0, 2π). Qubits are measured at most once, therefore we may represent unambiguously the outcome of the measurement done at qubit j by sj. Dependent corrections, used to control non-determinism, will be written Xsj
sj	0	0	1	1	i
and Zi , with Xi = Zi = I, Xi = Xi, and Zi = Si. A measurement pattern, or
simply a pattern, is defined by the choice of V a finite set of qubits, two possibly overlapping subsets I and O determining the pattern inputs and outputs, and a finite sequence of commands acting on V .
One can count two of the main advantages of the one-way quantum computation as having an intrinsic parallel structure [14] and a rich graph theoretical toolkits for algorithm design [15,16,17]. Generally speaking, a model to have these prop- erties beside the advantage of having a programmable and robust continuous-time evolution is the main goal of this paper. The first step is a translation of one-way pattern into Hamiltonian evolution, which is presented next.
Hamiltonian Construction
Here we wish to construct a Hamiltonian that is capable of doing a universal quan- tum computation which can be programmed by the one-way assembly language. Our Hamiltonian is similar to the construction in [18], but the underlying assembly language is different as it is based on the one-way patterns.
As said before, one-way quantum computation is performed by entangling oper- ator, Pauli corrections and single qubit measurements with angle α. However since the measurements cannot be performed continuously, we have to rewrite one-way patterns where measurements are implemented coherently [19], to be able to con- struct a Hamiltonian and evolve it continuously. Next, we replace measurements and their dependent correction with a controlled gate of the state, correspondent to the angle of the measurement, tensored with the desired Pauli correction.
Xsi Mα → ∧Xα := |−α⟩⟨−α|i ⊗ X + |+α⟩⟨+α|i ⊗ I

The nearest neighbour swap gate will be added to our commands list in order to construct the nearest neighbour Hamiltonian interaction. In another words we can enforce our commands to act only on the nearest neighbour using several swap gates. Therefor we have a new assembly language for the one-way patterns with commands sequence being
{Si, ∧Xi , Ei, Ii}	(4)
where a command Ai acts on the pair of qubits (i, i+1) and Ii stands for the identity

operator which will be used to help the pointer reach its correct place on time (see below).
In [18] the authors were interested in constructing a Hamiltonian that acts on one dimension and hence they had to consider extra data qubits and prepare them in |0⟩ state to keep them out of the effect of the gates, which in their construction are normal controlled gate or swap or identity. However, in our construction we use a generalised control gate, so |0⟩ state is not suitable for our case. Therefore we distinct the program and the data registers physically and prepare the data qubits in |+⟩ state, just like the qubits in a conventional one-way pattern (we address later the arbitrary inputs case). Finally, to implement the notion of the geometric clock which links the discrete time steps of the one-way computation and the continuous evolution of the Hamiltonian, we add to our commands sequence the pointer symbol D and the empty symbol •, where their action is defined below [18].
Rule 1: Symbols in the program register can move one step to the left, if there is an empty symbol in that position.
Rule 2: When a command meets a pointer symbol, they are swapped in the program register and the two qubits beneath them are affected by the command.
To program our computer, first we need to initialise our program register in a certain style. The length of program register is L = 2M = 2KN where K is the number of command sequences, M is the number of commands apart from D and • and N is the number of data qubits. We have to initialise the left half of the program register with K pointers at positions kN for k = 1, ··· ,K and empty symbols elsewhere. The right half holds the command sequences with an identity in front of each of them. A simple example has been given in the appendix.
Now we can construct a Hamiltonian for universal quantum computation with the same insight as started by Feynman, i.e. a Hamiltonian such that its ground state is the superposition over the history states:
L−1

HEMC
= − Σ
j=1
†
(R + R )(j,j+1)
(5)

where R corresponds to the rules defined above

R =	Σ
A∈{S,∧Xα,E,I}
|A •⟩⟨• A|p1,p2 ⊗ Id1,d2 + |A D⟩⟨D A|p1,p2 ⊗ Ad1,d2	(6)

where p stands for the program register and d for the data register of the respective program command. The final step is the design of an adiabatic algorithm to prepare the ground state of HEMC which is the topic of the next section.
We finish this part with a comment on the parallelism. In our construction to achieve the same depth complexity of the one-way pattern, we could first dispose all the Z dependency of the measurements using the signal shifting scheme intro- duced in [1] and then parallelise the resulting controlled-gates using the techniques introduced in [14]. However this will effect the dimension of the program register. The study of structural links between locality and parallelism is outside the scope of this paper and demands a further investigation.

Adiabatic Evolution of HEMC
In this part we will show how to obtain adiabatic quantum computation based on our architecture. We are interested in making an interpolation between the initial and the final configurations. However, our initial and final Hamiltonian must be different from the non-programmable models in a sense that our Hamiltonians must prepare the states of program and data registers in the same time, unlike the previous works in which one had to only prepare the input data state.
In what follows |φi⟩ is the state of the system at step i. For the initial Hamilto- nian we penalise all configurations that are not desired as an initial state:

Σ D   D 
K−1 (j+1)N −1
 
•

Hinit := I −

i=1
 null
null
 Ni −

j=0

i=jN +1
null
null
 i	(7)

(K+1)N
 	 
Σ	 A   A 

— i=KN +1 +
+ i − i=(K+1)N +1 null
null i

where N , K and L are the same as defined in the last section, and all the qubits are prepared in |+⟩. This ensures that the ground state is precisely |φ0⟩.
To define the final Hamiltonian, as discussed in [13], we need to have a Hamil- tonian whose ground state is a sum over history states. Instead of using directly HEMC which might lead to some degenerate cases we add penalty terms to our HEMC which prefers the transition elements.
L−1	L

H	:= Σ |φ ⟩⟨φ |− 1 Σ |φ ⟩⟨φ
| + |φ
1	1
⟩⟨φ | +  |φ ⟩⟨φ | +  |φ
⟩⟨φ
|(8)

final
i	i
i=1
2	t
i=0
t−1
t−1	t
2	0	0
2	L	L

The proof in [13], that improved by [8], shows that the spectral gap of these Hamilto- nians is inverse polynomial in the number of commands. Therefore, the interpolation between our initial and final Hamiltonian can be performed adiabatically.
Conclusion
In this paper we have constructed a local Hamiltonian which could be programmed through direct translation of one-way patterns based on the coherent implementa- tion of the measurements. We have also showed that the ground state of this Hamil- tonian could be obtained by adiabatic evolution from an easy to construct initial Hamiltonian. Our Hamiltonians are different from the previous adiabatic proofs in a sense that our construction has to prepare both data and program registers in our desired state to keep our construction both adiabatic and programmable. The locality of our Hamiltonian and the ability to perform adiabatic computation to our final state will give us more robustness against decoherence. Moreover the notion of assembly language from the one-way model gives us the ability of standardisation and having more parallel structures with graph theoretical toolkit. There are still many questions to be asked about the hybrid architecture. We will seek the ways to use real measurements besides keeping the system in its ground state, which is

seemingly incompatible however one special approach has been already investigated in [9].

Acknowledgement
Authors wish to thank Afsoon Ebrahimi for her useful discussions.

References
V. Danos, E. Kashefi, and P. Panangaden. The measurement calculus. Journal of ACM, 54, 2007.
E. Farhi, J. Goldstone, S. Gutmann, and M. Sipser. Quantum computation by adiabatic evolution. quant-ph/0001106.
D. Deutsch. Quantum computational networks. Proc. Roy. Soc. Lond A, 425, 1989.

E. Farhi, J. Goldstone, S. Gutmann, J. Lapan, A. Lundgren, and D. Preda. A quantum adiabatic evolution algorithm applied to random instances of an NP-complete problem. Science, 2001.
R. Raussendorf and H. J. Briegel. A one-way quantum computer. Physical Review Letters, 86, 2001.
R. Raussendorf and H. J. Briegel. Computational model underlying the one-way quantum computer.
Quantum Information & Computation, 2, 2002. quant-ph/0108067.

D. Aharonov, W. van Dam, J. Kempe, Z. Landau, S. Lloyd, and O. Regev. Adiabatic quantum computation is equivalent to standard quantum computation. SIAM JOURNAL OF COMPUTING, 37, 2007.

P. Deift, M. B. Ruskai, and W. Spitzer. Improved gap estimates for simulating quantum circuits by adiabatic evolution. Quantum Information Processing, 6, 2007.

G. K. Brennen and A. Miyake. Measurement-based quantum computer in the gapped ground state of a two-body hamiltonian. Physical Review Letter, 101, 2008.
R. P. Feynman. Quantum mechanical computers. Foundations of Physics, 16, 1986.

A. Y. Kitaev, A. H. Shen, and M. N. Vyalyi. Classical and Quantum Computation. Graduate Studies in Mathematics. American Mathematical Society, 2002.
D. Aharonov, D. Gottesman, S. Irani, and J. Kempe. The power of quantum systems on a line. In
Proceedings of FOCS’07 – Symposium on Foundations of Computer Science. LNCS, 2007.
D. Aharonov, W. van Dam, J. Kempe, Z. Landau, S. Lloyd, and O. Regev. Adiabatic quantum computation is equivalent to standard quantum computation. In Proceedings of FOCS’04 – Symposium on Foundations of Computer Science. LNCS, 2004.
A. Broadbent and E. Kashefi. On parallelizing quantum circuits. Theoretical Computer Science, 2009.
V. Danos and E. Kashefi. Determinism in the one-way model. Physical Review A, 2006.

D. E. Browne, E. Kashefi, M. Mhalla, and S. Perdrix. Generalized flow and determinism in measurement-based quantum computation. New Journal of Physics, 9, 2007.

N. de Beaudrap, V. Danos, E. Kashefi, and M. Roetteler. Quadratic form expansions for unitaries. In Theory of Quantum Computation, Communication, and Cryptography Third Workshop, TQC 2008 Tokyo, Japan, number 5106 in Lecture Notes in Computer Science, 2008.
D. Nagaj and P. Wocjan. Hamiltonian quantum cellular automata in 1d. Physical Review A, 78, 2008.

R. B. Griffiths and C. Niu. Semiclassical Fourier transform for quantum computation. Physical Review Letters, 76, 1996.

Appendix
The following sequence of the configurations shows how to initialise and execute a program that is obtained from the one-way pattern Xs1 M 0E12.
2	1
D	•	D	I	E	I	∧X0
q1	q2


D	•	I	D	E	I	∧X0
q1	q2


D	I	•	E	D	I	∧X0
q1⇐⇒q2

I	D	E	•	I	D	∧X0
q1⇐⇒q2

I	•	E	D	I	•	∧X0	D
q1⇐⇒q2

I	E	•	I	D	∧X0	•	D
q1⇐⇒q2

I	E	I	•	∧X0	D	•	D
q1⇐⇒q2

I	E	I	∧X0	•	D	•	D
q1⇐⇒q2
