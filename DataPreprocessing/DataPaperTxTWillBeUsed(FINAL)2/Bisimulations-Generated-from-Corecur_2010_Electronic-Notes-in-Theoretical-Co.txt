

Electronic Notes in Theoretical Computer Science 265 (2010) 245–258
www.elsevier.com/locate/entcs

Bisimulations Generated from Corecursive Equations
Venanzio Capretta1,2
School of Computer Science University of Nottingham Nottingham, UK

Abstract
We consider the problem of determining the unicity of solutions for corecursive equations. This can be done by transforming the equations into a guarded form, that is, representing them as a coalgebra. However, in some examples this transformation is very hard to achieve. On the other hand, mere unicity of solutions can be determined independently by constructing a bisimulation relation. The relation is defined inductively by successive steps of reduction of the body of the equation and abstraction of the recursive calls. The algorithm is not complete: it may terminate successfully, in which case unicity is proved; it may terminate with a negative answer, in which case no bisimulation could be constructed; or it may run forever. If it diverges, the inductively defined relation is in fact a bisimulation and unicity obtains. However, we cannot decide whether the algorithm will run forever or not.
Keywords: corecursion, bisimulation, streams, coalgebra.


Introduction
We investigate the solutions of corecursive equations in functional programming languages and type theories. Coinductive types were introduced in functional pro- gramming by Hagino [10]. Their categorical properties were first clarified by Aczel and Mendler [2]. Functions to coinductive types are defined by exploiting their universal property as final coalgebras. This has been encoded syntactically as a principle of definition by guarded recursion [6].
Type-theoretic realizations of these ideas were implemented starting from Nuprl
[14] and then in Coq [9] and Agda [16,5,3].

1 Thanks to Hans Zantema for challenging me with some engaging corecursive equations and to Thorsten Altenkirch, Nils Anders Danielsson and Graham Hutton for stimulating discussions. Some typos and minor errors occurring in the published version of the article have been corrected; I thank Florent Balestrieri for signaling them.
2 Email: vxc@cs.nott.ac.uk

1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.08.015

Reasoning on coinductive types exploits the coinduction principle, stating that bisimilarity implies equality. The notion of bisimulation was first introduced by Park [17] and Milner [15] as a way of reasoning about processes. Aczel [1] adopted it as the appropriate notion of equality for non-well-founded sets. In type theory it is realized by a coinductive relation (see Chapter 13 of [4]).
As productive functions toward coinductive types become more common in (de- pendent) functional programming [8,11], the question arises of how to deal with equations that do not satisfy the guardedness condition.
Two recent advancements in this direction use, respectively, a notion of pebble- flow network [7] and term rewriting [22]. This paper tackles some cases of equations that are not treated by known methods. We know of no uniform way to prove existence of a solution for them. However, the coinduction principle provides a way
to prove unicity of solutions by exploiting ad hoc bisimulations.
Section 2 introduces the basic terminology about streams and bisimulations on them, the notion of guardedness and some basic operations on streams. Section 3 illustrates the topic by studying two examples of non-guarded equations and proving the unicity of solutions by defining bisimulation relations for both. Then, in Section 4 the general algorithm to inductively define such bisimulations is given and a proof of its correctness is sketched. Finally, in Section 5 we outline the questions that are still open and lay down a plan for future research.

Streams and Bisimulations
By coinductive data types we mean sets of structured objects with a non-well- founded structure. To be more precise, such a type is, in categorical terminology, the ﬁnal coalgebra of a functor. We will not work in full generality, but limit our discourse to the category of sets and concentrate on the type of streams over a given type of elements D. Streams are infinite sequences of elements.
Definition 2.1 Given a type D, the type SD of streams over D is the set of infinite sequences of elements of D. We usually drop the subscript D if the element type is understood. The basic operations on streams are head : S → D that returns the first element of the sequence, tail : S → S that returns the sequence of elements after the first, and cons : D → S → S that prepends a new head to a given stream. We use the notation hs for (head s), ts for (tail s), and d :: s for (cons d s).
In categorical terms, ⟨head, tail⟩ : S → D× S is the final coalgebra for the functor
FX = D × X and cons is its inverse.
We use the notation nts for successive applications of tail and hns for the nth element of s: 0ts = s, (n+1)ts = t(nts), hns = h(nts).
Determining that two streams are equal requires verifying that all the elements in corresponding positions are the same. A powerful logical characterization of equality of streams is bisimilarity: Two streams are bisimilar if they have the same head and their tails are also bisimilar.

Definition 2.2 A bisimulation on S is a binary relation ∼ on streams such that
∀s1, s2 : S.s1 ∼ s2 ⇒ hs1 = hs2 ∧ ts1 ∼ ts2.
Theorem 2.3 (Coinduction Principle) Let ∼ be a bisimulation; for every
s1, s2 : S, if s1 ∼ s2, then s1 = s2.
The notion of bisimulation and the coinduction principle can be generalized and applied to final coalgebras in any category. However, there are subtle differences between several notions of bisimulation that are not equivalent in full generality: recent work by Staton [21] investigated their correlations.
In Type Theory, final coalgebras are implemented by coinductive types. The syntactic notion of guardedness is used to determine whether recursive equations correctly define coinductive objects. An equation is called guarded if the recursive
calls occur only as direct arguments of top-level constructors. In the case of streams, a subterm x of a term e is guarded if it recursively satisfies these requirements: x is guarded in a :: x; if x is guarded in e then x is guarded in a :: e; if x is guarded in e1,..., en then x is guarded in (case t of c1 '→ e1 | · · · | cn '→ en). There is some allowance for the application of functions that ﬁlter constructors: for example, if x is guarded in e then it is guarded in (map f e) because the definition of the map function guarantees that it will generate a (::) in for each (::) of its input. The full definition of the guardedness condition can be found in its Coq implementation [9]. For example, the following definition of the interleave function (the (::) operator has the lowest precedence):
(  ) : S → S → S
s1  s2 = hs1 :: s2  ts1
is accepted because the recursive call to  on the right-hand side occurs immediately under the application of the constructor (::).
On the other hand, definitions like these:


bad : N → S
bad n = bad (n + 1)
wrong : S → S
wrong s = hs :: t(wrong s)


are incorrect: the first because the recursive call occurs at top level and not under a constructor; the second because, even if the recursive call is under a constructor, it does not occur directly as an argument, but it has an application of the tail function on top of it.
Mutually recursive equations defining several functions are accepted if each sat- isfies the guardedness condition with respect to itself and the others. The following mutual recursion is not accepted as it is presented:


even : S → S
even s = hs :: odd ts
odd : S → S
odd s = even ts

because the occurrence of even in the definition of odd is not guarded by a construc- tor. However, the equation can be easily modified to satisfy the condition:
odd s = h1s :: odd 2ts.
It is not always so easy to put a definition into guarded form; and yet, it may still be productive, that is, it may guarantee that its unfolding will always produce new elements of the result stream. The main topic of this article is in fact how to derive logical principles for those equations for which a transformation into guarded form is too difficult.
Guardedness guarantees that an equation has a unique solution. In fact, finality of ⟨head, tail⟩ means that for every coalgebra γ : C → D × C there exists a unique function f : C → S such that f c = π1 (γ c) :: f (π2 (γ c)). It is a simple task to associate a coalgebra to any guarded equation or system of equations, so that existence and unicity of solutions is ensured. In some cases, we may be able to prove the unicity of solutions independently of their existence for non-guarded equations. This is the topic of this article.

Corecursive Equations
In this section we look at two examples of corecursive equations on streams that are not guarded and not easily reducible to guarded form. However, there is a relatively simple technique to prove that, if they have any solution, that solution must be unique. The method works by assuming that there are two solutions to the equation, constructing an appropriate bisimulation relation, and showing that the two solutions must be related by it. We can then conclude, by the coinduction principle, that the two solutions must be equal. The technique is closely related to that developed by Rosu and Lucanu [18] and implemented in the prover CIRC.
The first example was suggested to me by Hans Zantema.
Example 3.1
φ : S → S
φ s = hs :: (φ(even ts))  (φ(odd ts))
It is easy to check that the identity function is a solution to the equation in Example 3.1. But how do we prove that it is the only one? The equation is not guarded by constructors: The recursive calls to φ occur as arguments of , not directly under a top-level constructor.
Proposition 3.2 The equation in Example 3.1 has at most one solution.
Proof. Suppose φ1 and φ2 are two solutions to the equation. We want to prove that they are extensionally equal. Towards that goal, we define an inductive relation on S, we prove that it is a bisimulation and we show that equality of the two functions follows by the coinduction principle.

The relation ∼ on S is inductively generated by the following rules:

s : S


φ1 s ∼ φ2 s
(R0)	x1, x2, y1, y2 : S	x1 ∼ x2	y1 ∼ y2 (R1).
x1  y1 ∼ x2  y2

Let us show that ∼ is a bisimulation. Assume that s1 ∼ s2, we need to prove
that hs1 = hs2 and ts1 ∼ ts2. We proceed by induction on the generation of ∼. We have two cases according to the last rule used in the derivation of s1 ∼ s2:
If the last rule used was R0, then it must be s1 = φ1 s and s2 = φ2 s for some s.
Then, because φ1 and φ2 satisfy the equation in Example 3.1, we have

s1 = φ1 s = hs :: (φ1(even ts))  (φ1(odd ts)),
s2 = φ2 s = hs :: (φ2(even ts))  (φ2(odd ts)).
So hs1 = hs = hs2 and
ts1 = (φ1 (even ts))  (φ1(odd ts)),	ts2 = (φ2(even ts))  (φ2(odd ts)).
By R0 we have that
φ1(even ts) ∼ φ2(even ts)	and	φ1(odd ts) ∼ φ2(odd ts);
therefore ts1 ∼ ts2 by R1 (with instantiations x1 := φ1(even ts), x2 := φ2(even ts), y1 := φ1(odd ts), y2 := φ2(odd ts)).
If the last rule used was R1, then there must be streams x1, x2, y1, y2 such that
s1 = x1  y1 and s2 = x2  y2 with x1 ∼ x2 and y1 ∼ y2. By induction hypothesis we have that

hx1 = hx2,	tx1 ∼ tx2;	hy1 = hy2,	ty1 ∼ ty2.

Then we have, by definition of  ,
hs1 = h(x1  y1) = hx1 I=H hx2 = h(x2  y2) = hs2
and
ts1 = t(x1  y1) = y1  tx1	and	ts2 = t(x2  y2) = y2  tx2.
But we know that y1 ∼ y2 by assumption and tx1 ∼ tx2 by induction hypothesis, so ts1 ∼ ts2 by R1.
We conclude that ∼ is a bisimulation and, by the coinduction principle, every time
s1 ∼ s2 we can deduce that s1 = s2.
Since, for every s, φ1 s ∼ φ2 s by R0, we conclude that φ1 s = φ2 s and therefore
φ1 and φ2 are extensionally equal.	2
Although Example 3.1 does not satisfy the guardedness condition, it is easy to see why it has a unique solution: the equation guarantees that at least one element will

be produced by φ, and the ( ) operator outputs the elements generated by the two recursive calls, ensuring productivity. We could extend the notion of guardedness to take such obvious cases into account, but we would still miss some of the tricky examples shown next.
It is possible to associate a coalgebra to the equation in Example 3.1. We leave this to the reader: The construction is similar to what we do for the next example.
Example 3.3 In the following example, the recursive call occurs under an appli- cation of the tail function, making even an extended guardedness check fail:

χ : S → S
χ s = hs :: ts  t(χ ts)
To illustrate it, here is its output when it is applied to the stream of natural numbers
nat = 0 :: 1 ::2 ::3 ::4 ::5 :: .. .:
χ nat = 0 :: 1 ::2 ::2 ::3 ::3 ::3 ::4 ::4 ::5 ::4 ::6 ::4 ::7 ::5 ::8 ::5 ::9 ::6 :: 10 :: .... 
Proposition 3.4 The equation in Example 3.3 has at most one solution.
Proof. Suppose χ1 and χ2 are two solutions to the equation. We want to prove that they are extensionally equal. Towards that goal, we define an inductive relation on S, we prove that it is a bisimulation and we show that equality of the two functions follows by the coinduction principle. (The next section gives the algorithm to automatically generate the rules of the inductive relation from the recursive equation.)
The relation ∼ on S is inductively generated by the following rules:

s : S
(R0)	s, x1, x2 : S	x1 ∼ x2 (R1)	s, x1, x2 : S	x1 ∼ x2 (R2).

χ1 s ∼ χ2 s
s  tx1 ∼ s  tx2
x1  s ∼ x2  s

Let us show that ∼ is a bisimulation. Assume that s1 ∼ s2, we need to prove that hs1 = hs2 and ts1 ∼ ts2. We proceed by induction on the generation of ∼. We
have three cases according to the last rule used in the derivation of s1 ∼ s2:
If the last rule used was R0, then it must be s1 = χ1 s and s2 = χ2 s for some s.
Then, because χ1 and χ2 satisfy the equation in Example 3.1, we have
s1 = χ1 s = hs :: ts  t(χ1 ts),	s2 = χ2 s = hs :: ts  t(χ2 ts).
So hs1 = hs = hs2 and
ts1 = ts  t(χ1 ts),	ts2 = ts  t(χ2 ts).
By R0 we have that χ1 ts ∼ χ2 ts, therefore ts1 ∼ ts2 by R1 (with the instantia- tions s := ts, x1 := χ1 ts and x2 := χ2 ts.)

If the last rule used was R1, then there must be streams s, x1, x2 such that
s1 = s  tx1 and s2 = s  tx2 with x1 ∼ x2. By induction hypothesis we have that hx1 = hx2 and tx1 ∼ tx2. Then we have, by definition of  ,
hs1 = h(s  tx1) = hs = h(s  tx2) = hs2
and
ts1 = t(s  tx1) = tx1  ts	and	ts2 = t(s  tx2) = tx2  ts.
But we know that tx1 ∼ tx2 by induction hypothesis, so ts1 ∼ ts2 by R2 (with the instantiations s := ts, x1 := tx1 and x2 := tx2).
If the last rule used was R2, then there must be streams s, x1, x2 such that s1 = x1  s and s2 = x2  s with x1 ∼ x2. By induction hypothesis we have that hx1 = hx2 and tx1 ∼ tx2. Then we have, by definition of  ,
hs1 = h(x1  s) = hx1 I=H hx2 = h(x2  s) = hs2
and
ts1 = t(x1  s) = s  tx1	and	ts2 = t(x2  s) = s  tx2.
Since x1 ∼ x2 by hypothesis, then ts1 ∼ ts2 by R1.
We conclude that ∼ is a bisimulation and, by the coinduction principle, every time
s1 ∼ s2 we can deduce that s1 = s2.
Since, for every s, χ1 s ∼ χ2 s by R0, we conclude that χ1 s = χ2 s and therefore
χ1 and χ2 are extensionally equal.	2
Let us show, for comparison, how we can prove both existence and unicity of solutions by associating a coalgebra to Example 3.3. The general idea is that we need an ad hoc data type to represent all the possible unfoldings of the right-hand side of the equation. It’s a set of trees where the nodes represent applications of and the leaves represent either a constant stream or the tail of a recursive application of χ.


data Tχ : Set
leafΔ : S → Tχ
leaf  : S → Tχ
node : Tχ → Tχ → Tχ

τ : Tχ → D × Tχ
τ (leafΔ s) = ⟨hs, leafΔ ts⟩
τ (leaf s) = ⟨h1s, node (leaf ts) (leafΔ 2ts)⟩
τ (node t1 t2) = ⟨d, node t2 t' ⟩ if ⟨d, t' ⟩ = τ t1.

1	1

There exists a unique coalgebra morphism from ⟨Tχ,τ⟩ to ⟨S, ⟨h−, t−⟩⟩, let’s call it χτ . We can define χ s = hs :: χτ (node (leafΔ ts) (leaf ts)) to obtain a solution of the recursive equation in Example 3.3. On the other hand, if χ is a solution of the
recursive equation, we can use it to define a coalgebra morphism from Tχ to S like

this:
χ٨ : Tχ → S χ٨(leafΔ s) = s χ٨(leaf s) = t(χ s)
χ٨(node t1 t2) = (χ٨ t1)  (χ٨ t2).
This technique is related to work by Rutten and collaborators on complete sets of co-operations and behavioral differential equations [19,20,12]. It gives a stronger result than the bisimulation construction: it ensures existence besides unicity of the solution.
However, so far no uniform way to construct the ad hoc type has been given in
a form general enough to cover all the examples in this paper. In some other cases, defining an appropriate data type and a coalgebra on it is less straightforward than above, while the method of proving unicity of solutions using bisimulations still works nicely. Example 4.1 in the next section illustrates this point.
General Method
We now show how to apply the method in general. The starting point is a recursive equation defining a function φ with several arguments from the domain D and from SD; so φ : Dm → Sn → S.
The general form of the equation is
φ →a →s = t[→a, →s, φ]
where →a is a vector of element variables and →s a vector of stream variables. The right-hand side term t may contain occurrences of the function φ that we are trying to define. We allow only fully applied occurrences, that is, φ is always applied to m subterms of type D and n subterms of type S.
The idea is to try to “straighten” the equation by forcing it to be in constructor form, that is, the right-hand side is the application of (::) to two subterms. To that end we can just take the head and tail of the right-hand side and put the equation in the equivalent form
φ →a →s = h(t[→a, →s, φ]) : t(t[→a, →s, φ]).
After reduction and simplification we require that the recursive calls disappear from the head:
φ →s = d[→a, →s] :: t1[→a, →s, φ].
We are not going to be any more precise about what is meant by reduction and simpliﬁcation: the details will depend on the nature and strength of the formal theory we are working with. For our purposes, we can just assume that we are given a relation ~ on terms; it has to preserve the denotation of the term and, for the algorithm to be effective, it has to be decidable.

So we will have that h(t[→a, →s, φ]) ~ d[→a, →s] and t(t[→a, →s, φ]) ~ t1[→a, →s, φ]. In set theory, we will mean that d and t1 are terms denoting the same object (element of the set D or infinite sequence of elements) as ht and tt for every value of the variables. In type theory, we will mean that d and t1 are reducts or normal forms of ht and tt. The algorithm is modular with respect to the adopted notion of simplification, and in what follows we will not be any more specific about it.
If the equation cannot be simplified into this form, the algorithm fails immedi- ately. If we are very lucky, the term t1 will satisfy the guardedness condition with respect to all occurrences of φ and then the algorithm may terminate with success. But in general, the occurrences of φ may not be guarded.
The idea is to repeat this kind of splitting and simpliﬁcation on the term t1 and continue in this vein until the guardedness condition is satisfied. This, however, may never happen.
To increase our chances of success, we also apply a generalization operation that
replaces some subterms with parameters and variables. The generalized term cannot be used to prove guardedness directly anymore, but it can be used to generate a derivation rule for the bisimulation.

Algorithm
The input of the algorithm is a recursive equation for a function φ of the form

φ : Dm → Sn → S
φ →a →s = t[→a, →s, φ]

We assume that there are no nested applications of φ: the problem of extending the algorithm to nested recursion is still open. We introduce two variables φ1 and φ2 denoting two solutions of the equation. The output of the algorithm is a bisimulation relation ∼ given by a sequence of inductive rules. The very first rule states that the results of φ1 and φ2 are related and can be used together with the coinduction principle to prove that the two solutions are extensionally equal.
The algorithm generates an infinite sequence of terms t0, t1, t2,.. .. Each term contains occurrences of three kinds of variables: object parameters are variables of type D denoted by a, b; stream parameters are variables of type S denoted by r, s; recursive variables are variables of type S denoted by x, y, z. The difference between parameters and recursive variables lies in their use in the generation of the rules for the bisimulation relation. Some of the terms may also depend on the function variable φ itself.
To each of these terms, t[→a, →s, →x, φ] we associate the following rule for the bisim-

ulation relation:	−−−→
−−→
−−−−−−→
−−−−−→

a : D	s : S	x1, x2 : S	x1 ∼ x2
t[→a, →s, x→1, φ1] ∼ t[→a, →s, x→2, φ2]
where we use a vector notation to summarize sequences of assertions: for example
s : S is short for the sequence of assumptions s1 : S, s2 : S,... for all the variables

in →s; similarly −x−−∼−−x→ is short for x
~ x	,x	∼ x
and so on for all variables

1	2
in →x.
1,1
2,1	1,2
2,2

Base case: t0[→a, →s, φ] = (φ →a →s).
Recursive step: tk+1 is generated from tk in the following way. We take the head and tail of tk and simplify them as described in the two steps below. During simplification, we are allowed to replace the head of any recursive variable x with a fresh object parameter dx and its tail with a fresh recursive variable x'. In other words, we postulate x = dx :: x'.
First take htk and reduce/simplify it as much as possible. If the reduced form does not contain any occurrence of φ or of recursive variables, then proceed to the next point. Otherwise the algorithm terminates with a negative response:
no bisimulation could be constructed.
Next take ttk and reduce/simplify it as much as possible. Let’s say ttk ~ t' .
Then apply the following generalization operations.
Replace every maximal subterm not containing any occurrence of recursive
variables or φ with a new parameter: if t' = C[u] where u is a maximal subterm
of type D not containing φ or any recursive variable, then generalize it to C[b]
where b is a fresh object parameter; if t' = C[v] where v is a maximal subterm
of type S not containing φ or any recursive variable, then generalize it to C[s] where s is a fresh stream parameter.
Replace every recursive application of φ with a new recursive variable: if
' = C[(φ ·· ·)], then generalize it to C[y] where y is a fresh recursive variable.
Also replace every instance of a previous term in the sequence with a new

recursive variable: if t'
= C[ti[d→, →s, →y, φ]], then generalize it to C[z] where z is a

fresh recursive variable.
After performing all the possible generalizations and simplifications, if the term we obtained is a single parameter or recursive variable, then the algorithm terminates with a positive response: we constructed a bisimulation.
Otherwise we take this term as tk+1, we generate the bisimulation rule asso-
ciated to it and repeat the recursive step to generate the next term.
Note 1 By an instance of a previous term we mean the result of applying a substi- tution to an earlier term in the sequence. We can substitute a parameter with any term not depending on recursive variables or φ, and we can substitute a recursive variable with either x' or dx :: x'.
Note 2 In the reduction/simpliﬁcation of ttk we must at ﬁrst not split dx :: x', that is, we should treat this term as the single recursive variable x. We perform all the simpliﬁcation and generalization steps and check if the term is an instance of a previous term in the sequence. If it isn’t, then we lazily reduce the term, splitting dx away from x' as necessary, to obtain further simpliﬁcation.
Note 3 It will be observed that, in the case that there are no nested application of it, φ will occur only in t0 and will be substituted with a recursive variable everywhere in t1. However, we maintained the generalization case for it in the recursive step because it will not be so anymore when we extend the algorithm to nested recursion.

We illustrate the algorithm on a new example.
Example 4.1

ψ : S → S
ψ s = hs :: even(ψ(odd ts))  odd(ψ(even ts))
ψ nat = 0 :2 :5 :12 :25 :52 :105 :212 :425 :852 :1705 :3412 :6825 :13652 :27305 :54612::
109225 : 218452 : 436905 : 873812 : .... 
The application of the algorithm to this equation proceeds as follows.
We start with the base term and its associated derivation rule:
s : S

t0 = ψ s,


ψ1 s ∼ ψ2 s
(R0).

ht0 = h(ψ s) = hs by the equation. This expression does not depend on ψ or any recursive variable, so it’s OK.
tt0 = t(ψ s) = even(ψ(odd ts))  odd(ψ(even ts)). We apply the generalization operation to this term. The two calls to ψ are replaced with recursive variables,
ψ(odd ts) by x and ψ(even ts) by y. Thus we obtain the next term in the sequence and the next rule:

t1 = even x  odd y,
x1, x2, y1, y2 : S	x1 ∼ x2	y1 ∼ y2
even x1  odd y1 ∼ even x2  odd y2
(R1).

ht1 = h(even x) = hx = dx. Remember that we are allowed to replace the head of a recursive variable with a fresh parameter, so the resulting expression does not depend on the recursive variable anymore and it’s OK.
tt1 = odd y  t(even x) = even ty  odd tx = even y'  odd x', where we were allowed to replace the tails of recursive variables with fresh variables x' and y'.
This expression is actually an instance of t1 (with x := y' and y := x') so we can replace it with a single recursive variable z. Since the resulting term is a single variable, the algorithm stops with success.
The algorithm constructed an inductive relation ∼ with two introduction rules, R0 and R1. The reader can verify, in the way we did for the examples in the previous section, that it is a bisimulation relation and therefore, by the coinduction principle, we can conclude unicity of solution for the equation.
The reader is also invited to check that the bisimulation relations used in the previous section are exactly the ones produced by the algorithm on those examples.
Theorem 4.2 For every corecursive equation on streams not containing nested re- cursive calls, if the algorithm terminates with a positive answer or diverges, then the equation has at most one solution.
Proof. (Sketch) The algorithm generates a sequence of derivation rules for the relation ∼. If we can prove that it is a bisimulation, then the coinduction principle,

together with rule R0, implies that any two solutions of the equation must be extensionally equal.
The proof that ∼ is a bisimulation proceeds by induction on its generation. For every rule, we must prove that the related terms in the conclusion must have equal heads and similar tails.
In fact, in the recursive case of the algorithm we check first of all if the head of tn (of which the heads of the related terms are an instantiation) does not depend on φ or on recursive variables. If it is in fact so, then the two heads are syntactically identical and we have proved the first part of our goal. Note that the allowance for the head of a recursive variable to be replaced by a fresh parameter corresponds to an application of the induction hypothesis for it.
Similarly, when proving that the tails are similar, recursive variables in the term correspond to subterms that are similar either by assumption (the original recursive variables) or inductive hypothesis (the recursive variables x' introduced as tails of the original ones) or by the application of one of the derivation rules (the recursive variables replacing instances of previous terms). We are allowed to apply any of the previously constructed rules: this corresponds to substituting any instance of a previous term with a recursive variable. Also, we are allowed to replace tails of recursive variables with fresh variables because of the corresponding induction hypothesis. If the simplified term is just a variable, then we know that the tails can be proved similar. Otherwise we add a new rule stating exactly that the generalizations of the tails are similar.	2

Conclusion
We defined a partial algorithm that, when applied to a corecursive equation on streams, investigates the unicity of its solutions by constructing a bisimulation re- lation. If the algorithm terminates successfully or diverges, the defined relation is indeed a bisimulation and the equation has at most one solution.
Among the related literature, the studies most similar to this work are the ones on pebbleflow networks [7] and on circular corecursion [18].
The first reference tackles the same problem: proving unicity (and existence) of solutions for recursive equations on streams. Their method is quite different, consisting in the generation and analysis of a king of circuit associated to the equa- tion. They characterize the class of equations on which their technique can decide productivity. The examples analyzed in this paper, however, do not belong to that class.
The second method, implemented in the system CIRC, addresses a more gen- eral problem: proving the equality of functions satisfying different equations. The technique is very similar to the algorithm presented here: a sequence of unfoldings of the desired equality is generated until an instance of a previous goal is encoun- tered. However, due to the fact that they compare terms with different structures, it is not possible to perform a generalization step as in the present work, which relies on abstracting corresponding subterms. For this reason CIRC cannot solve

the equalities of different solutions to the equations presented in this paper.
The results of this article point to four directions for further research.
Meaning of failure. We have seen that the algorithm is sound in the sense that whenever it gives a positive outcome, unicity of solutions obtains. Moreover, if the algorithm diverges, we proved that we also have unicity. On the other hand, if the algorithm terminates with failure, all we can say is that we couldn’t construct a bisimulation. This does not necessarily mean that the equation does not satisfy unicity of solutions. The generalization step in the algorithm obliterates some of the information contained in the term. The lost information might be essential for productivity. Future work will concentrate on the analysis of the failure cases.
Nested recursive equations. We postulated that the equations we consider don’t contain any nested recursive call. A simple equation with recursive nesting is the following:
θ : S → S
θ s = hs :: θ(θ(even ts))  ts
θ nat = 0 ::1 ::1 ::3 ::2 ::3 ::3 ::7 ::4 ::3 ::5 ::7 ::6 ::7 ::7 :: 15 ::8 ::5 ::9 ::7 :	This equation
appears to be productive, but our algorithm is not refined enough to deal with it. Future work will try to extend the method to nested recursion.
Application to other coinductive types. Finally, we plan to extend the field of research beyond the application to stream functions, and study if similar results can be obtained for other coinductive data types, for example infinite trees. The final goal could be a general algorithm applicable to corecursive equations on any coinductive structure.

References
Peter Aczel. Non-Well-Founded Sets. Number 14 in CSLI Lecture Notes. Stanford University, 1988.
Peter Aczel and Nax Paul Mendler. A final coalgebra theorem. In D. H. Pitt, D. E. Rydehead,
P. Dybjer, A. M. Pitts, and A. Poign´e, editors, Category Theory and Computer Science, volume 389 of Lecture Notes in Computer Science, pages 357–365. Springer-Verlag, 1989.
Thorsten Altenkirch and Nils Anders Danielsson. Mixing induction and coinduction. http://www.cs. nott.ac.uk/~nad/publications/danielsson-altenkirch-mixing.html, 2009.
Yves Bertot and Pierre Cast´eran. Interactive Theorem Proving and Program Development. Coq’Art: The Calculus of Inductive Constructions. Springer, 2004.
Ana Bove, Peter Dybjer, and Ulf Norell. A brief overview of Agda - a functional language with dependent types. In Stefan Berghofer, Tobias Nipkow, Christian Urban, and Makarius Wenzel, editors, TPHOLs 2009, volume 5674 of Lecture Notes in Computer Science, pages 73–78. Springer, 2009.
Thierry Coquand. Infinite objects in type theory. In Henk Barendregt and Tobias Nipkow, editors, Types for Proofs and Programs. International Workshop TYPES’93, volume 806 of Lecture Notes in Computer Science, pages 62–78. Springer-Verlag, 1993.
J¨org Endrullis, Clemens Grabmayer, Dimitri Hendriks, Ariya Isihara, and Jan Willem Klop. Productivity of stream definitions. In Erzs´ebet Csuhaj-Varju´ and Zolt´an E´sik, editors, FCT 2007, volume 4639 of Lecture Notes in Computer Science, pages 274–287. Springer, 2007.
Jeremy Gibbons and Graham Hutton. Proof methods for corecursive programs. Fundamenta Informatica, 66(4):353–366, 2005.


Eduardo Gim´enez. Codifying guarded definitions with recursive schemes. In Peter Dybjer, Bengt Nordstr¨om, and Jan Smith, editors, Types for Proofs and Programs. International Workshop TYPES ’94, volume 996 of Lecture Notes in Computer Science, pages 39–59. Springer, 1994.
Tatsuya Hagino. A typed lambda calculus with categorical type constructors. In D. H. Pitt, A. Poign´e, and D. E. Rydeheard, editors, Category Theory and Computer Science, volume 283 of LNCS, pages 140–157. Springer, 1987.
Ralf Hinze. Functional pearl: streams and unique fixed points. In James Hook and Peter Thiemann, editors, ICFP, pages 189–200. ACM, 2008.
Clemens Kupke and Jan J. M. M. Rutten. Observational coalgebras and complete sets of co-operations.
Electr. Notes Theor. Comput. Sci., 203(5):153–174, 2008.
Alexander Kurz, Marina Lenisa, and Andrzej Tarlecki, editors. Algebra and Coalgebra in Computer Science, Third International Conference, CALCO 2009, Udine, Italy, September 7-10, 2009. Proceedings, volume 5728 of Lecture Notes in Computer Science. Springer, 2009.
N. P. Mendler, P. Panangaden, and R. L. Constable. Infinite objects in type theory. In Proceedings, Symposium on Logic in Computer Science, pages 249–255, Cambridge, Massachussetts, 16–18 June 1986. IEEE Computer Society.
Robin Milner. A Calculus of Communicating Systems, volume 92 of Lecture Notes in Computer Science. Springer-Verlag, 1980.
Ulf Norell. Dependently typed programming in Agda. Lecture notes from the summer school on Advanced Functional Programming, 2008.
David Park. Concurrency and automata on infinite sequences. In P. Deussen, editor, Theoretical Computer Science, volume 104 of LNCS, pages 167–183. Springer-Verlag, 1981. Proceedings of the 5th GI-Conference Karlsruhe.
Grigore Rosu and Dorel Lucanu. Circular coinduction: A proof theoretical foundation. In Kurz et al. [13], pages 127–144.
Jan J. M. M. Rutten. A coinductive calculus of streams. Mathematical Structures in Computer Science, 15(1):93–147, 2005.
Alexandra Silva and Jan J. M. M. Rutten. Behavioural differential equations and coinduction for binary trees. In Daniel Leivant and Ruy J. G. B. de Queiroz, editors, WoLLIC, volume 4576 of Lecture Notes in Computer Science, pages 322–336. Springer, 2007.
Sam Staton. Relating coalgebraic notions of bisimulation. In Kurz et al. [13], pages 191–205.
Hans Zantema. Well-definedness of streams by termination. Proceedings of the 20th Conference on Rewriting Techniques and Applications (RTA), 2009, editor R. Treinen, Springer Lecture Notes in Computer Science.
