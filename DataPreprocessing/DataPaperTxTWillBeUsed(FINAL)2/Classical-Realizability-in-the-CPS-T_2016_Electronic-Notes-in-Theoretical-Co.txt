Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 325 (2016) 111–126
www.elsevier.com/locate/entcs
Classical Realizability
in the CPS Target Language
Jonas Frey1
Department of Computer Science University of Copenhagen, Denmark
jofr@di.ku.dk


Abstract
Motivated by considerations about Krivine’s classical realizability, we introduce a term calculus for an intuitionistic logic with record types, which we call the CPS target language. We give a reformulation of the constructions of classical realizability in this language, using the categorical techniques of realizability triposes and toposes.
We argue that the presentation of classical realizability in the CPS target language simplifies calculations in realizability toposes, in particular it admits a nice presentation of conjunction as intersection type which is inspired by Girard’s ludics.
Keywords: Classical realizability, ludics, topos, tripos, CPS translation.


Introduction
The relationship between continuation passing style (CPS) translations of the λ- calculus, negative translations of classical into intuitionistic logic, control operators in abstract machines, and evaluation order (call-by-value vs. call-by-name) was un- covered during the 70’s, 80’s, and early 90’s of the past century. The first step was Plotkin [22] recognizing that CPS translations can be used to simulate differ- ent evaluation orders within one another. In the 80’s, Felleisen and his collabora- tors [5] made the connection between control operators in abstract machines and CPS translations, observing that the behavior of a control operator like call/cc in the source language of a CPS translation can be implemented by a purely func- tional expression in the target language. Griffin [13] observed the analogy of CPS translations and negative translations via the proofs-programs-correspondence, and through this analysis he discovered that the natural type for call/cc is Pierce’s law,

1 This work is supported by the Danish Council for Independent Research Sapere Aude grant “Complexity via Logic and Algebra” ( COLA).

http://dx.doi.org/10.1016/j.entcs.2016.09.034 1571-0661/© 2016 Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

i.e. the propositional schema ((A ⇒ B) ⇒ A) ⇒ A. Since Pierce’s law when added to constructive logic yields full classical logic, his observation was celebrated as the unexpected discovery of an algorithmic meaning of classical logic.
Negative translations do not require full intuitionistic logic as target logic, and – inspired by Girard’s [11] – Lafont, Reus, and Streicher identified the (¬, ∧)-fragment of intuitionistic logic as sufficient [18,19]. Although in this representation negation is taken as primitive, it is often useful to think of negation as given by the intuitionistic encoding ¬A ≡ A ⇒ ⊥, and when constructing models in cartesian closed cate- gories or response categories [24,23] C, one has to interpret ⊥ by an object R ∈ C other than the initial object to avoid degeneracy. This R is called the response type, and is comparable to the parameter A in Friedman’s A-translation [9].
Krivine’s classical realizability [17] is a realizability interpretation of classical logic which builds on the algorithmic understanding of classical logic arising from Griffin’s insight. It is formulated using an extension of the λ-calculus with call/cc, with an operational semantics provided by the Krivine abstract machine (KAM) [16]. To interpret logic, the interpretation utilizes a parameter called the pole, which plays a role comparable to the response type R, and to Friedman’s A, as has been pointed out by Miquel [20].
A motivation of the present work is to make more explicit in which sense the pole plays the role of the response type, by giving a formulation of classical real- izability in the target language instead of the source language, in which Krivine’s work takes place. To this end, we introduce a term language for a minimal intu- itionistic logic based on negation and disjunction (not conjunction as Lafont, Reus and Streicher proposed). A design goal is to get a minimalistic system with a simple operational semantics, and this is achieved by combining negation and disjunction into a ‘synthetic’ finitary multi-disjunction which should be understood as some- thing like ¬(A1 ∨· · ·∨An), but we write as l1(A1),..., ln(An) , where l1,..., ln are elements of a countable set L of labels, comparable to biases in Girard’s ludics [12]. The CPS target language is a term language of a natural deduction system based on this type constructor scheme.
Instead of presenting the system as a minimal intuitionistic logic based on nega- tion and disjunction, we could also have chosen a presentation as a dual-intuitionistic (i.e. using sequents with many formulas on the right and at most one on the left) [27] system based on negation and conjunction, which would be closer to Carraro, Sal- ibra, and Ehrhard’s stack calculus [1], a system which was introduced for similar reasons (as an analysis of Krivine realizability), but is based on implication rather than negation. I have chosen the intuitionistic – rather than dual-intuitionistic – presentation for the simple reason that it is easier to handle and does not require as much ‘backward thinking’, but it is good to keep the alternative point of view in mind when comparing with Krivine realizability. In particular, the terms of the CPS target language are records, i.e. a kind of tuples, and should be viewed in analogy to stacks on the Krivine machine, which fits with the fact that we use sets of terms as truth values where Krivine uses sets of stacks.
However, we reverse the order on truth values relative to Krivine’s account, and

take the empty set as falsity (rather than the set of all stacks as Krivine does), since we use a call-by-value translation of classical logic into the target language instead of the call-by-name translation that is implicit in Krivine’s approach. This difference is immaterial from a model-theoretic point of view since it only reverses the order on predicates, which are symmetric as Boolean algebras, but it changes the implementation of classical connectives: where in Krivine realizability, universal quantification is the primitive operation that is given by unions of truth values (and the encoding of ∃ is indirect and involves dualization), in our presentation existential quantiﬁcation is the primitive operation. Moreover, in Section 4 we describe how conjunction can be represented as an intersection type under certain (mild) conditions, and together we get a simple representation of the connectives of regular logic (i.e. the (∃, ∧, T)-fragment of first order logic) not involving the pole at all. This is desirable since regular logic is all that is required for the tripos-to-topos construction [14], and a simpler representation of its connectives greatly facilitates calculations in classical realizability toposes.
Related work
The CPS target language is similar in spirit to Thielecke’s CPS calculus [26], which can also be motivated as a term calculus for a type system with a kind of multi- negation. The main difference is that in Thielecke’s system the basic type construc- tor is a negated n-ary conjunction, and not a an n-ary disjunction as in the CPS target language.
Although different in objective, Curien et al.’s work on term calculi for clas- sical logic [2,3] was inspirational for the present article, and so were Melli`es and Tabareau’s tensor logic [21] and Zeilberger’s analysis of polarized logic [28].
Terui’s computational ludics [25] is a term calculus for ludics designs with a notion of head reduction analogous to the CPS target language. Specifically, the CPS target language can be understood as a non-linear version of the purely additive fragment of the syntax of computational ludics.
Finally – and rather unsurprisingly – there is a strong analogy to Hyland and Ong’s innocent strategies [15]. Specifically, the η-expanded closed normal forms of a type A without variables are precisely the innocent strategies on A viewed as tree.
The CPS target language
The syntax of the CPS target language, given in Table 1, distinguishes two syntactic classes called terms and programs.
A term is either a variable or a record, i.e. a family ⟨ l1(x1. p1),..., ln(xn. pn)⟩ of programs pi – the methods of the record, each abstracted by a variable xi – indexed by a finite subset {l1,..., ln}⊆ L of a countable set of labels, which we take to be the set L = {a,..., z}∗ of lower case strings (in practice we will only use strings of length 1). The use of different fonts is important: curly k, l are placeholders for generic labels, whereas sans-serif k, l are specific labels. The order in which the methods of a record are listed is not important – we view them abstractly as



Table 1
The CPS target language.


functions from finite sets F ⊆fin L of labels to programs with a distinguished free variable. In accordance with this viewpoint, we use ‘family notation’ ⟨ l(x. p) | l ∈ F⟩ for records when convenient (in particular in Section 4). We refer to the set of labels indexing the methods of a record t as the domain of the record and denote it dom(t) – thus dom(⟨ l1(x1. p1),..., ln(xn. pn)⟩) = {l1,..., ln} and dom(⟨ l(x. p) | l ∈ F⟩)= F .
A program is an expression of the form tlu, with the intended meaning that the program (or method ) labeled l in t is called with u as an argument. This reading suggests the reduction rule ⟨ l1(x1. p1),..., ln(xn. pn)⟩li t > pi[t/xi] (provided 1 ≤ i ≤ n), which gives the operational semantics of the language. We use the symbol ‘>’ only for top-level reduction of programs (i.e. weak head reduction), and write ‘→β’ for the compatible closure (i.e. the closure under term and program formers) of > on terms and programs. A redex is a program tlu where t is a record (not a variable). A redex tlu with l /∈ dom(t) can not be reduced and is said to be blocked. A normal form is a term or program that does not contain any redexes, i.e. in every application tlu the term t is a variable.
We define the sets FV(t) and FV(p) of free variables of a term or program in the usual way, where the distinguished variable x of a method l(x. p) in a record t is considered bound in p. There are no closed normal programs (since the term in head position cannot be a variable) but there are blocked closed programs like ⟨⟩k⟨⟩

and diverging closed programs like ⟨ k(x. xkx)⟩k⟨ k(x. xkx)⟩.
To allow the construction of non-trivial classical realizability models, the syn- tax has to be extended by non-logical constructs like constants or instructions to perform side effects 2 . This is achieved by extending the clause for programs in the grammar. To have a model for idealized shell-programs, for example, one can extend the definition of programs to be
p, q	::=	tlu | r(p, q) | w0(p) | w1(p) | 0 | 1
with the intended meaning that the program r(p, q) reads a bit from standard input and continues with p or q depending on its value, w0(p) and w1(p) write a 0 or 1, respectively, to standard output before continuing with p, and 0 and 1 represent successful and unsuccessful termination. For example, ⟨ k(x. xkx)⟩k⟨ k(x. r(xkx, 0))⟩ is a program that reads bits from standard input until it encounters a 1, whereupon it terminates successfully.
Formally, such an extension of the syntax has to be accompanied by an extension of the operational semantics, which in the case of the above example can either be given as a labeled transition system or as a transition relation on programs with state. This is explained in detail in [8] using Krivine’s syntax, where it is also explained how in such a setting specifications on program behavior give rise to poles and thus to realizability triposes and toposes. These ideas all transfer to the reformulation of classical realizability given in this article, but instead of formulating our results in this generality – which would require a lot of repetition – we use as running example only a single non-logical constant end which represents termination and is comparable to Girard’s daimon H 3 . Thus, from now on we assume that programs are of the form
p, q	::=	tlu | end.

We denote the sets of closed terms and programs generated by this grammar (to- gether with the rule for terms in Table 1) by T and P, and more generally we denote by T[x1,..., xn] and P[x1,..., xn] the sets of terms and programs whose free variables are contained in {x1,..., xn}. The analogous sets of pure terms and programs (i.e. those not containing end) are denoted by T0, P0, T0[x1,..., xn], and P0[x1,..., xn].
We consider a Curry-style type system for the CPS target language, whose types
are generated from type variables and for each finite set {l1,..., ln} an n-ary con- structor which forms the record type l1(A1),..., ln(An) out of types A1,..., An. There are two kinds of typing judgments corresponding to the two syntactic classes:
terms t ∈ T0[x1,..., xn] are typed by sequents ( x1 : A1,..., xn : An ▶ t : B ), and
programs p ∈ P0[x1,..., xn] are typed by sequents ( x1 : A1,..., xn : An ▶ p ).

2 Essentially because of [8, Lemma 26].
3 A referee points out that a concept comparable to the daimon already appears in Coquand’s evidence semantics [4].



Table 2
Admissible rules for the typing relation, where Γ ≡ x1 : A1,..., xn : An, and σ is a permutation.
Thus, programs are not associated to types, but we think of them as having response type (or type ⊥).
There are three rules (Var), (Abs) and (App), typing variables, records, and applications, respectively. Furthermore, the typing relation is closed under a number of admissible rules.
Lemma 2.1 The derivable typing judgments are closed under the rules in Table 2.
Proof. Each of the four pairs of rules can be shown to be admissible by simulta- neous induction on the structure of t and p.	2
A consequence of the admissibility of (Cut) is subject reduction.
Lemma 2.2 (Subject reduction) If Γ ▶ ⟨ l1(x1. p1),..., ln(xn. pn)⟩li t is deriv- able for some 1 ≤ i ≤ n, then Γ ▶ pi[t/xi] is derivable.
Proof. Inspection of the typing rules shows that Γ ▶ ⟨ l1(x1. p1),..., ln(xn. pn)⟩li t
can only be derived by a deduction
Γ, x1 : A1 ▶ p1	...	Γ, xn : An ▶ pn
Γ ▶ ⟨ l1(x1. p1),..., ln(xn. pn)⟩ : l1(A1),..., ln(An)	Γ ▶ t : Ai

Γ ▶ ⟨ l1(x1. p1),..., ln(xn. pn)⟩li t
and applying (Cut) to the hypotheses with pi and t yields the claim.	2
Realizability
Classical realizability models are always defined relative to a pole, which is a set
‚ ⊆ P of closed programs satisfying
p > q, q ∈ ‚ ⇒ p ∈ ‚	(1)
for all p, q ∈ P. The deliberations that follow are valid for arbitrary poles satisfying this condition (relative to reasonable extensions of the pure language with non- logical instructions such as in [8,10]), but to have something to hold on to, we fix a

pole ‚ by

‚ = {p | p >∗ end} ,

which is the set of all programs p whose weak reduction sequence ‘terminates’, i.e. leads to the constant end 4 .
A truth value is a set S ⊆ T of closed terms. We define as semantic counterparts of the type constructors for each set {l1,..., ln} of labels an n-ary connective on the set P (T) of truth values.
Definition 3.1 Given truth values S1,..., Sn ∈ P (T) and labels l1,..., ln ∈ L, the truth value l1(S1),..., ln(Sn) is defined by
 l1(S1),..., ln(Sn) = {t ∈ T | ∀i ∈ {1,..., n} ∀s ∈ Si . tli s ∈ ‚} .

We introduce realization judgments as semantic counterparts of typing judg- ments.
Definition 3.2 Given truth values S1,..., Sn,T ⊆ T, and a term t ∈ T[x1,..., xn] or program p ∈ P[x1,..., xn],

We call expressions of the form (2) and (3) realization judgments. Slightly redun- dantly, we also say ‘the realization judgment (Γ H t : T ) is valid ’ instead of simply asserting the judgment itself.
The following result is an analogue of Krivine’s adequation lemma [17, Theo- rem 3].
Lemma 3.3 Valid realization judgments are closed under the rules in Table 3.
Proof. The only nontrivial case is (Abs). Assume that Γ,y : Tk H pk for 1 ≤ k ≤ m, and that si ∈ Si for 1 ≤ i ≤ n. We have to show that
(⟨ l1(y. p1),..., ln(y. pm)⟩[→s/→x])lj t ∈ ‚
for every 1 ≤ j ≤ m and t ∈ Tj. For fixed j and t we have
(⟨ l1(y. p1),..., ln(y. pm)⟩[→s/→x])lj t =
(⟨ l1(y. p1[→s/→x]),..., ln(y. pm[→s/→x])⟩)lj t > pj[→s/→x, t/y] where the reduct is in ‚ by assumption, and the claim follows from (1).	2
4 The classical realizability model arising from this pole has some interesting properties, as the author learned from Krivine [7].



Table 3
Admissible rules for realization judgments, where S1,..., Sn, S, T1,..., Tm,T ⊆ T, Γ ≡ x1 : S1,..., xn : Sn, and σ is a permutation.

Classical realizability triposes
We now show how to do classical realizability in the CPS target language by instan- tiating a simple (call-by-value) negative translation. To start we fix the shorthands
T ≡	чA ≡  k(A)	ч(A, B) ≡  l(A), r(B) 

for nullary, unary, and binary type constructors, and using these we encode classical conjunction as
A Λ B ≡ ч(чA, чB).	(4)
The negative translation maps classical sequents
A1,..., An ▶ B1,..., Bm

consisting of formulas built up from propositional variables and the connectives, T, ч and Λ, to intuitionistic sequents
A∗,..., A∗ , чB∗,..., чB∗ ▶
1	n	1	m
where the formulas A∗ and B∗ are obtained by expanding the classical connectives
i	j
according to the above shorthands and encoding.
We could now define classical realization judgments by mimicking the negative translation on the level of realizability, but we will not spell this out explicitly, and

rather develop the remainder of the section in categorical language, by laying out the construction of classical realizability triposes analogous to the treatment in [8].
Broadly speaking, realizability triposes [14] capture the model theoretic essence of realizability interpretations as a collection of order relations on sets of semantic predicates, which together are required to form an indexed preorder – i.e. a con- travariant functor P : Setop → Ord from sets to preorders – subject to certain conditions. The precise definition of strict Boolean tripos (which is the version of triposes that we use) is given in Definition A.3.
In our setting, semantic predicates on a set J are functions

ϕ, ψ : J → P (T)
into the set of truth values, and the order on predicates is defined by

ϕ ≤ ψ	:⇔	∃p ∈ P0[x, y] ∀j ∈ J .  x : ϕ(j),y : чψ(j) H p ,	(5)
i.e. ϕ ≤ ψ if there exists a pure program p[x, y] which realizes the negative transla- tion of ϕ(j) ▶ ψ(j) uniformly in j.
The first step in establishing that semantic predicates form a tripos is to show that the predicates on a fixed set form a Boolean prealgebra, i.e. a preorder whose poset reflection is a Boolean algebra (Definition A.1).
Theorem 3.4 For every set J, the set of P (T)J of semantic predicates on J
equipped with the order relation (5) is a Boolean prealgebra.
Proof. We show first that ≤ is actually a preorder. Reflexivity follows from the fact that ( x : S, y : чS H ykx ) for arbitrary truth values S.
For transitivity, assume that ϕ ≤ ψ and ψ ≤ θ, i.e. that there exist p ∈ P[v, w] and q ∈ P[x, y] such that ( v : ϕ(j),w : чψ(j) H p ) and ( x : ψ(j),y : чθ(j) H q ).
The claim ϕ ≤ θ follows from Lemma 3.3 via the derivation
x : ψ(j),y : чθ(j) H q
y : чθ(j) H ⟨ k(x. q)⟩ : чψ(j)	v : ϕ(j),w : чψ(j) H p
v : ϕ(j),y : чθ(j) H p[⟨ k(x. q)⟩/w]

Next we show that the order has finite meets. The predicate with value constant T is a greatest element, since ( x : S, y : чT H yk⟨ ⟩) for arbitrary truth values S. We claim that a binary meet of ϕ and ψ is given by pointwise application of (the semantic version of) the type constructor defined in (4), i.e. (ϕΛψ)(j)= ϕ(i) Λψ(i). The such defined ϕ Λ ψ is smaller than ϕ since ( x : ч(чϕ(j), чψ(j)),y : чϕ(j) H xly ), and similarly for ψ. To see that it is a greatest lower bound, assume that θ ≤ ϕ and θ ≤ ψ, i.e. there exist programs p ∈ P[w, x] and q ∈ P[w, y] such that ( w : θ(j),x : чϕ(j) H p ) and ( w : θ(j),y : чψ(j) H q ). Then we have θ ≤ ϕ Λ ψ by

the following derivation.
w : θ(j),x : чϕ(j) H p	w : θ(j),y : чψ(j) H q
w : θ(j) H ⟨ l(x. p), r(y. q)⟩ : ч(чϕ(j), чψ(j))
w : θ(j),z : ч(чϕ(j), чψ(j)) H zk⟨ l(x. p), r(y. q)⟩
To finish the proof that (P (P)J , ≤) is a Boolean algebra, it now suffices to verify the conditions (i)–(iii) of Lemma A.2, with the negation operation given by (чϕ)(j)= чϕ(j).
For (i) assume that ϕ Λ ψ ≤ ч⊥, i.e. that there exists p[x, y] ∈ P[x, y] with ( x : ч(чϕ(j), чψ(j)),y : ччT H p ). Then we have
w : ϕ(j),z : ччψ(j) H zk⟨ k(y. p[⟨ l(v. vkw), r(w. wky)⟩/x, ⟨ k(v. vk⟨⟩)⟩/y])⟩
(in the following we do not spell out the derivation of realization judgments any more, and leave the type checking to the reader) and hence ϕ ≤ чψ.
For (ii) we have
x : ч(чϕ(j), чч(ϕ(j)),y : ччT H xr⟨ k(z. xlz)⟩
and for (iii) we have
x : ччϕ(j),y : чϕ(j) H xky.
2
Every function f : J → I induces a function f∗ : P (T)I → P (T)J on predicates by precomposition, and it is easy to see that f∗ is monotone and preserves all logical structure (since all propositional operations on predicates are defined pointwise in a uniform way). Since the operation (f '→ f∗) clearly preserves composition and identities, it is the morphism part of a contravariant functor
K‚ : Setop → BA.
from sets to Boolean prealgebras with object part J '→ (P (T)J , ≤). We can now prove the main theorem.
Theorem 3.5 K‚ is a strict Boolean tripos (Deﬁnition A.3).
Proof. It remains to show that the reindexing maps f∗ admit left adjoints subject to the Beck-Chevalley condition, and that there is a generic predicate.
Let f : J → I. We claim that a left adjoint ∃f to f∗ can be defined by fiberwise union, i.e.
∃f (ϕ)(i)=   ϕ(j)	for	ϕ ∈ P (T)J ,
fj=i
and to prove this we have to show that for any ψ ∈ P (T)I we have ϕ ≤ f∗ψ if and only if ∃f ϕ ≤ ψ. Unfolding definitions yields
∃p ∈ P0[x, y] ∀j ∈ J ∀s ∈ ϕ(j) ∀t ∈ чψ(fj) . p[s, t] ∈ ‚

for the first inequality, and
∃p ∈ P0[x, y] ∀i ∈ I ∀s ∈   ϕ(j) ∀t ∈ чψ(i) . p[s, t] ∈ ‚
fj=i
for the second one. The two statements are equivalent since in both cases the arguments of ϕ and ψ range over all pairs (i, j) with fj = i.
It is easy to see (and well known e.g. from the effective tripos) that fiberwise unions strictly satisfy the Beck-Chevalley condition.
Finally, a generic predicate is given by the identity function on P (T).	2
To conclude the section, we reprove [8, Lemma 26] in the new syntax.
Lemma 3.6 The tripos K‚ induced by a pole ‚ is non-degenerate (not equivalent to the terminal tripos) if and only if P0 ∩ ‚ = ∅.
Proof. A tripos is degenerate if and only if all truth values are equivalent, which is easily seen to be equivalent to the existence of a pure program p[x] ∈ P0[x] such that the realization judgment ( x : T H p[x] ) holds. If this is the case, then p[⟨⟩] ∈ P0 ∩ ‚. Conversely, if there exists q ∈ P0 ∩ ‚ then we have ( x : T H q ).	2
Conjunction as intersection type
In the previous section we have seen that relative to a fixed pole ‚ the semantic predicates give rise to a tripos K‚, and this tripos in turn gives rise to a topos Set[‚] whose construction relies only on the regular fragment of first order logic,
i.e. the fragment of logic consisting of existential quantification and conjunction. To facilitate computation in classical realizability toposes, it is good to have an easy representations of the basic connectives, and in the proof of Theorem 3.5 we saw that existential quantification in the tripos is given by set theoretic union, which is easy enough. However, for conjunction we only have the representation (4) and the involved double negation entails a high logical complexity and obscures things considerably, i.e. it is difficult to know what the elements of S Λ T look like, even if we know the elements of S and T very well.
In this section, we show that under certain conditions on the pole we can identify a class of ‘nice’ representatives of predicates in the tripos which admits an imple- mentation of conjunction as intersection type, while being closed under the other logical operations. The idea to represent conjunction as intersection is inspired by ludics [12].
Given a record
t = ⟨ l(x. p) | l ∈ F⟩
and a set M ⊆ L of labels, define the restriction of t to M to be the record
t|M = ⟨ l(x. p) | l ∈ F ∩ M⟩.
The syntactic order ± on terms and programs is the reflexive-transitive and com- patible (i.e. closed under term and program constructors) closure of the set of all

pairs (t|M , t) for records t and sets M of labels. Observe that the empty record
⟨⟩ is smaller than any other record in the syntactic order, but not smaller than a variable.
Definition 4.1 A pole ‚ is called strongly closed, if it satisfies the conditions
p →∗ q, q ∈ ‚ ⇒ p ∈ ‚	and
p ± q, p ∈ ‚ ⇒ q ∈ ‚,
i.e. it is closed under inverse β-reduction and upward w.r.t. the syntactic order.
A truth value S ⊆ T is called strongly closed, if it satisfies the analogous condi- tions
t →∗ u, u ∈ S ⇒ t ∈ S	and
t ± u, t ∈ S ⇒ u ∈ S.
Although strong closure is a much stronger condition on a pole than mere closure under inverse head reduction, it is satisfied for many ‘reasonable’ poles, in particular for the pole of terminating programs, and more generally for poles constructed from specifications as in [8].
For a fixed strongly closed ‚, there is an easy way to strongly close any given truth value, via a well-known double duality construction. Concretely, for S ⊆ T define
S↑ = {p[x] ∈ P[x] | ∀s ∈ S. p[s] ∈ ‚} ,
and dually for E ⊆ P[x] define
S↓ = {s ∈ T | ∀p[x] ∈ E. p[s] ∈ ‚} .
If ‚ is strongly closed, it is obvious that so is S↑↓ for any truth value S.
A truth value S is said to be supported by a set M ⊆ L of labels, if we have s|M ∈ S for every s ∈ S. More generally, a predicate ϕ ∈ P (T)J is said to be supported by M , if ϕ(j) is supported by M for all j ∈ J.
The main result of the section is the following.
Theorem 4.2 Let ϕ, ψ ∈ P (T)J be predicates that are both pointwise strongly closed, and supported by disjoint ﬁnite sets F = {l1,..., ln} and G = {k1,..., km} of labels, respectively. Then the predicate ϕ ∩ ψ, which is deﬁned by (ϕ ∩ ψ)(j) = ϕ(j) ∩ ψ(j), is a meet of ϕ and ψ and is supported by F ∪ G.
Proof. We claim that the realization judgments
x : ϕ(j) ∩ ψ(j) H x : ϕ(j)	x : ϕ(j) ∩ ψ(j) H x : ψ(j)
and
x : ϕ(j),y : ψ(j) H u[x, y]: ϕ(j) ∩ ψ(j)
with	u[x, y]= ⟨ l1(z. xl1 z),..., ln(z. xln z), k1(z. yk1 z),..., km(z. ykm z)⟩

hold for all j. The first two are obvious. For the third one assume that s ∈ ϕ(j) and t ∈ ψ(j). Then for each li ∈ dom(s) the redex sli z in u[s, t] can be reduced, and the result uj[s, t] satisfies uj[s, t] ± s|F . We have s|F ∈ ϕ(j) since ϕ(j) is supported by F , and uj[s, t] ∈ ϕ(j) ∈ ϕ(j) and u[s, t] ∈ ϕ(j) by strong closure. An analogous argument shows that u[s, t] is in ψ(j), and therefore in ϕ(j) ∩ ψ(j). The claim that ϕ ∩ ψ is a meet of ϕ and ψ now follows from the next lemma.
To see that ϕ ∩ ψ is supported by F ∪ G, assume that t ∈ ϕ(j) ∩ ψ(j) for some
j ∈ J. Then t|F ∪G ± t|F ∈ ϕ(j) and by strong closure we have t|F ∪G ∈ ϕ(j).	2
Lemma 4.3 If ϕ, ψ, θ ∈ P (T)J are predicates and s[z], t[z] ∈ T0[z] and u[x, y] ∈
T0[x, y] are pure terms such that the realization judgments
z : θ(j) H s[z]: ϕ(x)	z : θ(j) H t[z]: ψ(x)	x : ϕ(j),y : ψ(j) H u[x, y]: θ(x, y)
for all j ∈ J, then θ is a meet of ϕ and ψ.
Proof. From the first two judgments we can deduce ( z : θ(j),v : чϕ(j) H vks[z]) and ( z : θ(j),v : чψ(j) H vkt[z] ), which means that θ ≤ ϕ and θ ≤ ψ, and thus θ ≤ ϕ Λ ψ. From the third judgment we can derive
w : ч(чϕ(j), чψ(j)),z : чθ(j) H wl⟨ k(x. wr⟨ k(y. zku[x, y])⟩)⟩,
which means that ϕ Λ ψ ≤ θ.	2
Thus we have a nice representation of conjunction for pointwise strongly closed predicates which are finitely supported by disjoint sets.
Disjointness can always be achieved by renaming, i.e. ‘relocating’, as long as supports are ﬁnite. Moreover, strong closure and finite support are preserved by existential quantification, and by the semantic type constructors (Definition 3.1) provided the the pole is strongly closed. A finitely supported and strongly closed generic predicate can also be obtained, by negating the canonical one given by the identity on P (T).
Acknowledgement
The ideas presented in this article were developed over a long period of time, and I profited from discussions on related issues with many people, including – but not limited to – Pierre Clairambault, Pierre-Louis Curien, Nicolas Guenot, Paul Blain Levy, Paul-Andr´e Melli`es, Guillaume Munch-Maccagnoni, Jakob Grue Simonsen, Thomas Streicher, Noam Zeilberger, and St´ephane “El Z´ım” Zimmermann.
Thanks to the referees for their careful rereading and helpful comments.

References
A. Carraro, T. Ehrhard, and A. Salibra. The stack calculus. In Proceedings Seventh Workshop on Logical and Semantic Frameworks, with Applications, LSFA 2012, Rio de Janeiro, Brazil, September 29-30, 2012., pages 93–108, 2012.


P.L. Curien and H. Herbelin. The duality of computation. In Proceedings of the Fifth ACM SIGPLAN International Conference on Functional Programming (ICFP ’00), Montreal, Canada, September 18- 21, 2000., pages 233–243, 2000.
P.L. Curien and G. Munch-Maccagnoni. The duality of computation under focus. In Theoretical computer science, volume 323 of IFIP Adv. Inf. Commun. Technol., pages 165–181. Springer, Berlin, 2010.
T. Coquand. A semantics of evidence for classical arithmetic. J. Symbolic Logic, 60(1):325–337, 1995.
M. Felleisen, D. Friedman, E. Kohlbecker, and B. Duba. Reasoning with continuations. In Proceedings of the Symposium on Logic in Computer Science (LICS ’86), Cambridge, Massachusetts, USA, June 16-18, 1986, pages 131–141, 1986.
R.C. Flagg. Church’s thesis is consistent with epistemic arithmetic. In Intensional mathematics, volume 113 of Stud. Logic Found. Math., pages 121–172. North-Holland, Amsterdam, 1985.
J. Frey. Computability and Krivine realizability. Note of a conversation with J.L. Krivine, available at
https://sites.google.com/site/jonasfreysite/krivine-comp.pdf,  2015.
J. Frey. Realizability toposes from specifications. In 13th International Conference on Typed Lambda Calculi and Applications, TLCA 2015, July 1-3, 2015, Warsaw, Poland, pages 196–210, 2015.
H. Friedman. Classically and intuitionistically provably recursive functions. In Higher set theory (Proc. Conf., Math. Forschungsinst., Oberwolfach, 1977), volume 669 of Lecture Notes in Math., pages 21–27. Springer, Berlin, 1978.
J. Frey and J.G. Simonsen. Toposes for Time Complexity Classes, 2016. Developments in Implicit Computational Complexity (DICE 2016), available at https://lipn.univ-paris13.fr/DICE2016/ Abstracts/paper_6.pdf.
J.Y. Girard. A new constructive logic: classic logic. Mathematical Structures in Computer Science, 1(03):255–296, 1991.
J.Y. Girard. Locus solum: From the rules of logic to the logic of rules. Mathematical Structures in Computer Science, 11(03):301–506, 2001.
T. Griffin. A formulae-as-type notion of control. In Proceedings of the 17th ACM SIGPLAN-SIGACT symposium on Principles of programming languages, pages 47–58. ACM, 1990.
J.M.E. Hyland, P.T. Johnstone, and A.M. Pitts. Tripos theory. Math. Proc. Cambridge Philos. Soc., 88(2):205–231, 1980.
J.M.E. Hyland and C.H.L. Ong. On full abstraction for PCF: I, II and III. Inform. and Comput., 163(2):285–408, 2000.
J.L. Krivine. A call-by-name lambda-calculus machine. Higher-Order and Symbolic Computation, 20(3):199–207, 2007.
J.L. Krivine. Realizability in classical logic. Panoramas et synth`eses, 27:197–229, 2009.
Y. Lafont. Negation versus implication. Logical Frameworks, pages 223–229, 1991.
Y. Lafont, B. Reus, and T. Streicher. Continuation semantics or expressing implication by negation. Unpublished, available at http://iml.univ-mrs.fr/~lafont/pub/continuation.ps, 1993.
A. Miquel. Existential witness extraction in classical realizability and via a negative translation. Log. Methods Comput. Sci., 7(2):2:2, 47, 2011.
P.A. Melli`es and N. Tabareau. Resource modalities in tensor logic. Ann. Pure Appl. Logic, 161(5):632– 653, 2010.
G.D. Plotkin. Call-by-name, call-by-value and the λ-calculus. Theoret. Comput. Sci., 1(2):125–159, 1975.
P. Selinger. Control categories and duality: on the categorical semantics of the lambda-mu calculus.
Math. Structures Comput. Sci., 11(2):207–260, 2001.
T. Streicher and B. Reus. Classical logic, continuation semantics and abstract machines. Journal of functional programming, 8(06):543–572, 1998.
K. Terui. Computational ludics. Theor. Comput. Sci., 412(20):2048–2071, 2011.
H. Thielecke. Continuation semantics and self-adjointness. Electronic Notes in Theoretical Computer Science, 6:348–364, 1997.
I. Urbas. Dual-intuitionistic logic. Notre Dame J. Formal Logic, 37(3):440–451, 1996.
N. Zeilberger. On the unity of duality. Ann. Pure Appl. Logic, 153(1-3):66–96, 2008.

A  Boolean (pre)algebras and Boolean triposes
This appendix recalls the definitions of Boolean (pre)algebra and strict Boolean tripos, and states an auxiliary lemma to characterize Boolean prealgebras.

Definition A.1 A Boolean algebra is a complemented distributive lattice, i.e. a distributive lattice (B, ≤, T, Λ, ⊥, V) such that for every a ∈ B there exists a b ∈ B with a Λ b = ⊥ and a V b = T.
A Boolean prealgebra is a preorder whose poset-reflection is a Boolean algebra.

The term ‘Boolean prealgebra’ does not seem to be very prevalent in the litera- ture, but it appears e.g. in [6].

Lemma A.2 A preorder (B, ≤) is a Boolean prealgebra if and only if it has ﬁnite meets (denoted by Λ, T) and there exists a function ч(—): B → B such that

(i) a Λ b ≤ чT  ⇒  a ≤ чb	(ii) a Λ чa ≤ чT	(iii) ччa ≤ a

for all a, b ∈ B.

Proof. The following derivation shows that ч(—) is antimonotone.

a ≤ b
чb Λ a ≤ чb Λ b	чb Λ b ≤ чT чb Λ a ≤ чT
чb ≤ чa

The converse implication of (i) is shown as follows.

a ≤ чb
a Λ b ≤ чb Λ b	чb Λ b ≤ чT

a Λ b ≤ чT

The following shows that ч(—) is an involution,

a Λ чa ≤ чT
a ≤ ччa

which implies that (A, ≤) is auto-dual and hence a lattice. The non-trivial direction

of distributivity is shown as follows.

ч(a Λ b) Λ a Λ b ≤ чT ч(a Λ b) Λ a ≤ чb
ч(a Λ b) Λ a Λ чc ≤ чb Λ чc ч(a Λ b) Λ a Λ чc ≤ чч(чb Λ чc)
ч(чb Λ чc) Λ ч(a Λ b) Λ a Λ чc ≤ чT
ч(чb Λ чc) Λ ч(a Λ b) Λ чc ≤ чa	ч(чb Λ чc) Λ ч(a Λ b) Λ чc ≤ чc ч(чb Λ чc) Λ ч(a Λ b) Λ чc ≤ чa Λ чc
ч(чb Λ чc) Λ ч(a Λ b) Λ чc ≤ чч(чa Λ чc) ч(чa Λ чc) Λ ч(чb Λ чc) Λ ч(a Λ b) Λ чc ≤ чT ч(чa Λ чc) Λ ч(чb Λ чc) ≤ ч(ч(a Λ b) Λ чc) (a V c) Λ (b V c) ≤ (a Λ b) V c
It remains to check that for a ∈ A, чa is a complement of a in the sense of the previous definition. This follows from (ii) and the fact that ч(—) is an involution.2
The following definition of strict Boolean tripos is a special case of the concept of tripos as introduced in [14].
Definition A.3 A strict Boolean tripos is a contravariant functor
P : Setop → BA
from the category of sets to the category of Boolean prealgebras and structure preserving maps such that
for any f : J → I, the map P(f ) has a left 5 adjoint ∃f (which is not required to preserve Boolean prealgebra structure), such that for any pullback square
L	q /K¸
p	 g 
J   f	/I ¸
we have P(g) ◦ ∃f = ∃q ◦ P(p) (this is the Beck-Chevalley condition), and
there exists a generic predicate, i.e. a set Prop and an element tr ∈ P(Prop) such that for every set I and ϕ ∈ P(I) there exists a unique f : I → Prop with P(f )(tr)= ϕ.






5 Note that the right adjoint ∀f is for free in the Boolean case, it is given by ∀f ϕ = ¬∃f ¬ϕ.
