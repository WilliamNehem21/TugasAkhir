Electronic Notes in Theoretical Computer Science 73 (2004) 87–109  
www.elsevier.com/locate/entcs


On the Ubiquity of Certain Total Type Structures
(Extended Abstract)

John Longley1 ,2
LFCS, School of Informatics University of Edinburgh Edinburgh, UK


Abstract
It is a fact of experience from the study of higher type computability that a wide range of plausible approaches to defining a class of (hereditarily) total functionals over N results in a surprisingly small handful of distinct type structures. Among these are the type structure C of Kleene-Kreisel continuous functionals, its recursive substructure RC, and the type structure HEO of the hereditarily effective operations. However, the proofs of the relevant equivalences are often non-trivial, and it is not immediately clear why these particular type structures should arise so ubiquitously.
In this paper we present some new results which go some way towards explaining this phenomenon. Our results show that a large class of realizability-style constructions always give rise to C, RC or HEO (as appropriate). The proofs make essential use of a technique due to Dag Normann. In this extended abstract, we content ourselves with giving precise statements of our theorems, and a brief outline of the method of proof.
Several new results, and some previously known ones, can be obtained as instances of our theorems, but more importantly, the proofs apply uniformly to a whole family of constructions, and provide strong evidence that the above three type structures are highly canonical mathematical objects.
Keywords: recursion theory, higher type computability, type structures, total functionals, continuous functionals, hereditarily effective operations



1 Research partly supported by EPSRC grant GR/N64571 “A proof system for correct program development”. The author wishes to thank the organizers of the Domains VI meeting for the opportunity to present this work, and also Andrej Bauer, Ulrich Berger, Mart´ın Escardo´, Dag Normann and Gordon Plotkin for illuminating discussions.
2 Email: jrl@inf.ed.ac.uk


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.08.004

Introduction
In our survey paper [12], we discussed the general problem of trying to identify the natural notions of “computability” for operations of higher type, and re- viewed the many different approaches to higher type computability that have been proposed in the literature over the last fifty years. As argued in [12], it is far from clear a priori what one ought to mean by “computability” in the higher type setting, but it is a pleasing fact of experience that a wide range of plausible approaches leads in practice to a relatively small handful of distinct notions. Thus, for example, if we restrict attention to classes of effectively computable functionals (i.e. extensional operations) of simple types over the natural numbers, it seems that all known approaches essentially boil down to one of six notions: two notions of “total computable functional”, and four notions of “partial computable functional”. The situation is summarized at the end of [12], and will be expounded more fully in two sequel papers.
Each of these six notions admits a wide range of different mathematical characterizations, and in each case we have a bunch of theorems asserting that these various characterizations all lead to the same class of functionals. (This is rather analogous to the situation in ordinary recursion theory, where definitions via Turing machines, lambda calculus, recursion schemes etc. all gives rise to the same class of computable first order functions.) In the higher type setting, many of these theorems are non-trivial and surprising, since they often relate constructions which appear totally different in character. Equivalence results of this kind contribute to the impression that the notion of computability in question is in some sense a natural or fundamental one.
In this paper we will present some new results in this vein, concentrating in particular on certain classes of hereditarily total functionals. (Informally, these are total functionals which act on total functionals which act on total functionals ... and so on down to the ground type.) A class of such functionals can be conveniently embodied by a total type structure over the set N of natural numbers. A little terminology and notation will be helpful at this point. We will be considering the simple types σ generated by the grammar:
σ ::= 0 | σ1 → σ2

We inductively define n + 1 to be the type n → 0, and we refer to the types n as the pure types. For the purposes of this paper, a type structure T will consist of a family of sets Tσ, one for each type σ, such that T0 = N, and Tσ→τ is some set of total functions from Tσ to Tτ . We sometimes write Tn in place of Tn, and more generally replace n by n when it appears as a subscript.
Several natural ways of constructing type structures of this kind are sur- veyed in [12], along with a number of equivalence results relating such con-


structions. A consideration of these results leads us to observe that there are three type structures which seem to arise with a remarkable frequency:
Constructions based on some idea of “continuous functions acting on continuous data” tend to lead consistently to the type structure C of Kreisel’s continuous functionals [7], or equivalently Kleene’s countable functionals [5].
Constructions based on an idea of “effective functions on continuous data” tend to lead to the type structure RC of recursive continuous func- tionals (this can be regarded as an effective substructure of C).
Constructions based on an idea of “effective functions on effective data” tend to lead to the type structure HRC of hereditarily recursively continu- ous functionals, or equivalently to the type structure HEO of hereditarily effective operations [7,16].
The words “continuous” and “effective” here can be made precise in various different ways; the point is that in each of the three cases, all reasonable choices lead to the same structure.
We will give some precise definitions of all three of these type structures in Section 3.4 below. The structure C is not itself a candidate for a class of “computable” functions (unless one allows one’s “programs” to be infinite objects), but it nevertheless plays an important role in the study of higher type computability. The other two type structures, RC and HEO, represent the two reasonable notions of “total computable functional” alluded to in our first paragraph. 3 These two notions are quite different in flavour and are in some sense incomparable: there are functionals in HEO that have no counterpart in RC, and vice versa. We refer the reader to [12] for further background in this area.
It thus appears that for definitions of a class of total computable functionals (setting aside the notion of Kleene computability), the main dichotomy is between approaches in which functions defined on arbitrary continuous objects of the appropriate type, and approaches in which they defined on just the effective objects of the appropriate type. Other aspects of the definitions which we might have expected to be significant, such as how we choose to represent functions intensionally and what kinds of “computation” we allow, usually

3 There is also another important notion of total computable functional, namely the one given by Kleene’s schemata S1–S9 [6]. Strictly speaking, these schemata give several related notions of computability, since they can be interpreted in many different type structures. However, in the author’s view, these notions of computability are best treated as derived
from one of the notions of partial computable functional we consider. We will develop this
point of view in more detail in the sequel to [12]. For the purpose of the present paper, we will leave to one side the notion of Kleene computability.


turn out not to make any difference. (Curiously, this is in stark opposition to the situation for notions of partial computable functional, where these other considerations turn out to be critical, but the dichotomy between “continuous” and “effective” is of minor importance.)
What we have sketched here is simply an impression that emerges from a number of individual results connecting up different constructions. It is therefore natural to ask whether one can give some kind of explanation for why these three type structures arise so ubiquitously, or whether our observa- tions (i)–(iii) can be made precise in some way. The purpose of this paper is to present some results which go some way towards realizing these objectives. We will obtain some general theorems saying that any construction that follows a certain pattern will result in the type structure C (respectively RC, HEO). Our theorems will cover many (though not all) of the constructions hitherto consid- ered in the literature, and so our approach will provide a unified explanation (and indeed a uniform proof) of several of the previously known equivalence results. In addition, a wealth of new characterizations of these type structures (many of them non-trivial in themselves) can be obtained as further instances of our theorems. Perhaps most importantly, by virtue of their generality, our results will furnish some kind of justification for the above statements (i)–(iii), and (in the author’s view) provide strong confirmation that the structures C, RC and HEO are highly canonical mathematical objects.
The results of this paper are thus of a somewhat more sweeping character than many of the previous results in the area, since they apply uniformly to a whole class of constructions. We will therefore need some general framework for describing the class of constructions we have in mind. Roughly speaking, the constructions that are covered by our results are those that can be nat- urally presented as standard realizability constructions (see Section 2 below). In order to articulate our results, we will make use of a framework from realiz- ability involving typed partial combinatory algebras, introduced by the author in [11]. As we shall see, many of the known constructions of C and RC, and virtually all known constructions of HEO, are easily shown to be equivalent to constructions that fit within our realizability framework. A plentiful supply of additional constructions is also provided by many of the structures considered in denotational semantics.
Since one typically has to work quite hard to obtain such results even for individual realizability constructions, the possibility of proving general the- orems of this kind came as a considerable surprise, at least to the present author. Even in the light of the known equivalence results, nothing would previously have led him to suspect that such a general result might hold. The proofs of our theorems are non-trivial, and make essential use of a technique


due to Normann [14], who used it to show that the total computable function- als arising from the standard Scott model were all definable in the language PCF. Normann’s proof is already somewhat technical, and our own proofs are even more so, since several further ingredients need to be added. In this extended abstract, we will content ourselves with a very brief outline of our method of proof and the role of Normann’s work; the full proof will appear in an expanded version of this paper.

Motivations
In general (as we have argued in [12, Section 4]), the partial notions of higher type computability are both intrinsically better behaved than the total notions and also have a greater relevance for computer science. We should therefore say a few words concerning some plausible motivations for the work undertaken in this paper, beyond its intrinsic conceptual interest.
One kind of motivation for the study of total computable functionals comes from the study of formal systems for constructive logic, such as first order Heyting arithmetic HA or its higher order counterpart HAω (see for exam- ple Troelstra [16] and Beeson [2]). For metamathematical purposes, one often considers interpretations of such systems (such as realizability interpretations) that embody some kind of constructive or computational content. Frequently, these interpretations are based on some notion of a constructive or computable operation of finite type. In the case of HAω with extensionality, in particular, one is naturally led to consider the class of the hereditarily total functionals that arise from such a notion, so in order to study properties of our inter- pretation we will surely want to know what this class of functionals is. The results of the present paper will answer this question in a large number of cases, allowing existing knowledge about the resulting class of functionals to be applied to the interpretation in question.
A second possible motivation comes from the study of the notion of totality in programming languages, as discussed for example in Plotkin [15]. In prac- tice, higher order programming languages allow us to write non-terminating programs, and so give rise to notions of partial computable operation. How- ever, for much of the time one wants to write terminating programs, and these are certainly easier to reason about since we do not have to worry about the possibility of “undefinedness”, so it is of interest to consider the class of to- tal computable operations that the language supports. As explained in [15], there are various subtle issues involved in defining a good notion of totality for programs of higher type; but in any case, we will certainly be interested in knowing what class of total operations we obtain from the language in ques- tion. Once again, in many cases the results of the present paper will enable


us to answer this question, and will enable us to apply existing knowledge about the resulting class of functionals to the programming language under consideration.

Structure of paper
The remainder of the paper is structured as follows. In Section 2 we set up the realizability framework within which we will work, based around the notion of typed partial combinatory algebras (TPCAs) and the extensional collapse construction. In Section 3 we illustrate this framework with some concrete examples, and summarize some known constructions of our three type structures that fit within this framework. In Section 4 we introduce the key ideas of effective and continuous TPCAs. We use these to give a precise statement of our results, and briefly discuss our method of proof and the role played by Normann’s ideas. We also mention a few applications and specific instances of our results. Finally, in Section 5 we try to assess the significance of our results, point out some of their limitations, and suggest some problems for further research.

A Realizability Framework
This section is concerned with setting up the general framework needed to express our results. In Section 2.1 we present a variant of the definition of typed partial combinatory algebras (TPCAs) which we introduced in [11] (under the name of partial combinatory type structures). In Section 2.2 we review the standard extensional collapse construction that we shall study, and in Section 2.3 we define a useful “relative” version of this construction. Concrete examples of all these notions will be given in Section 3.
Let us fix some notational conventions. We use ρ, σ, τ to range over types, and consider → to be right-associative, so that ρ → σ → τ means ρ → (σ → τ ). In connection with potentially non-denoting expressions we write e↓ to mean “e is defined”; e = e' to mean “e, e' are defined and equal” (strict equality); and e  e' to mean “if either e or e' is defined then so is the other and they are equal” (Kleene equality).

Typed partial combinatory algebras
Many constructions giving rise to C, RC and HEO involve structures of the following kind. We will regard the following definition as providing our basic notion of a “universe of higher type operations”.

Definition 2.1 [TPCA] A typed partial combinatory algebra (or TPCA) A
consists of
a set Aσ for each type σ;
for each σ, τ , a partial function ·στ : Aσ→τ ×Aσ ~ Aτ (known as application) such that there exist elements
kστ ∈ Aσ→τ→σ	(for each σ, τ )
sρστ ∈ A(ρ→σ→τ )→(ρ→σ)→ρ→τ (for each ρ, σ, τ )
yρ ∈ A(ρ→ρ)→ρ	(for each type ρ = σ → τ )
^0, ^1, ^2,... ∈ A0
suc ∈ A0→0
recσ ∈ Aσ→(0→σ→σ)→0→σ	(for each σ)
for which the following conditions hold for all elements x, y, z, f of the appro- priate types and for all n ∈ N:
k · x · y = x
s · x · y ↓
s · x · y · z  (x · z) · (y · z)
y · f ↓
y · f · x  f · (y · f ) · x
suc · n = n^+1  
rec · x · f · ^0= x
rec · x · f · n^+1  f · n^ · (rec · x · f · n^)
We frequently omit type subscripts where these can be inferred from the
context (we have taken this liberty even within the definition itself), and treat ‘·’ as left-associative, so that x · y · z means (x · y) · z. Strictly speaking, the choice of elements k, s, y, ··· is not part of the data for a TPCA — only the existence of such elements is required. Nevertheless, we will sometimes implicitly assume that a given TPCA comes equipped with a suitable choice of such elements.
Note that in the more usual definition of TPCA (see [11] or [8]), only the special elements k and s are required — in this terminology, a structure of the above kind would be a “TPCA with recursors and numerals”. However, in the present paper we will for convenience include the existence of recursors and numerals in the definition of TPCA. The idea is that all the TPCAs we consider must have enough computational structure to support “general

recursive computation”.
Note also that the equation for y is weaker than the more familiar fixed point equation y · f = f · (y · f ). This extra generality is exploited by some of the natural examples.
The extensional collapse construction
From any TPCA we may obtain a total type structure over N (in the sense of the Introduction) by means of the following construction. Recall that a partial equivalence relation or PER on a set X is just a symmetric, transitive relation on X (that is, an equivalence relation on a subset of X). If ∼ is a PER on X, we write X/∼ for the set of equivalence classes for ∼, and [x] for the equivalence class (if there is one) containing a particular x ∈ X.
Definition 2.2 [Extensional collapse] Given any TPCA A, define partial equivalence relations ∼σ on the sets Aσ as follows:
x ∼0 y iff x = y = n for some n;
f ∼σ→τ g iff for all x, y ∈ Aσ, x ∼σ y implies f · x ∼τ g · y.
We now define EC(A), the extensional collapse of A, to be the unique type structure isomorphic to A/ ∼. More precisely, we require that there exist bijections βσ : Aσ/ ∼σ→ EC(A)σ for each σ, such that
for all n ∈ N we have β0[n]= n ;
for all f ∼σ→τ f and x ∼σ x we have βσ→τ [f ](βσ[x]) = βτ [f · x].
Thus, the PERs ∼σ pick out the “hereditarily extensional” elements of A, and the construction of EC(A) turns these into a type structure. (The isomorphisms βσ are needed only because in our definition of a type structure T in Section 1 we required that Tσ→τ is concretely a set of functions from Tσ to Tτ ).
It is worth noting that EC(A) corresponds precisely to the usual type structure over the natural number object in the category PER(A), obtained by repeated exponentiation (see [11]). Since we may regard PER(A) as the “standard realizability model” over A, we can think of the definition of EC(A) as the standard realizability construction of a type structure. If βσ[x]= t, we often say that x ∈ A realizes t ∈ EC(A). Apart from this, however, no formal knowledge of PER(A) and realizability will be presupposed in this paper.
Remark 2.3 (i) A superficially more general definition could be given by allowing a non-empty set of realizers for each natural number n rather than just a single element n. In other words, we could represent N by any PER
≈0 on A0 for which the successor and recursor operations were realizable


in A. This would then induce PERs ≈σ at higher types as above, and we would obtain a type structure EC(A, ≈) isomorphic to A/≈. However, it is easy to show that for any such representation ≈0 of N there is an equivalent single-valued representation corresponding to some choice of numerals n; in particular, EC(A) defined as above (for this choice of numerals) coincides exactly with EC(A, ≈).
(ii) Another, even more superficial, generalization could be obtained by allowing the representing type of the natural numbers to be some type γ other than 0. We may reduce a TPCA A of this more general kind to a TPCA Aγ of the above kind just by setting Aγ = Aσ[γ], where
0[γ] = γ,   (σ → τ )[γ] = σ[γ] → τ [γ].
Remark 2.4 We would like to stress the fact that it is in general quite hard to establish relationships between type structures EC(A) and EC(B), even when A and B themselves are known to be closely related. For instance, one can make precise in various ways a relation A ≤ B between TPCAs, informally meaning “A can be simulated in B”, or “B has at least the computational power as A” (see e.g. [11]); we can loosely regard ≤ as a kind of “inclusion” for TPCAs. One may likewise define a suitable relation T ≤ U for type structures. However, in general A ≤ B does not imply that EC(A) ≤ EC(B); indeed, as we pass from some TPCA A to some B ≥ A, the extensional collapse may get bigger, or smaller, or remain the same, or jump sideways. Even if we have A ≤ B ≤ C with EC(A) = EC(C), any of these four relationships between EC(A) and EC(B) may arise. (The study of higher-type computability furnishes examples of all these situations, but we will not spell these out here.) All this is because the construction EC(−) is highly non-functorial — it does not interact well with “morphisms” between TPCAs — and the root of the problem is of course the “contravariance” built into the definition of ∼σ.
Our reason for labouring these points is to emphasize that, in general, one has to establish what EC(A) is separately for each TPCA A — it is not often that one is able to deduce such results cheaply from other known results of this kind, except in rather trivial cases. Thus, from the point of view of the operation EC(−), we have to consider each TPCA as living in its own bubble, so that extensional collapse results, while they may be non-trivial and beautiful theorems in themselves, typically have a rather “isolated” character and do not connect up with one another in any obvious way.
The main novelty of the results presented in this paper is that they offer, in certain cases, a way to break the isolation of individual TPCAs, and to establish the extensional collapse of a whole class K of TPCAs all at once. This gives us a much more powerful result than would be given by simply es- tablishing the extensional collapse for the “minimal” and “maximal” elements

of K, for instance.

A relative version
In the definition of TPCAs above, operations of higher type are treated as entities of the same kind as the data they act on: both are simply elements of A. Thus, TPCAs are a suitable framework for notions such as “continu- ous operations acting on continuous data”, or “effective operations acting on effective data”. However, some refinements to this framework are needed if we wish to consider notions such as “effective operations acting on continuous data” — or, more generally, a notion of operations of some restricted class acting on data in some wider class. We may capture such notions by means of a relative version of the extensional collapse construction, which we now introduce.


Definition 2.5 [Relative extensional collapse]
A sub-TPCA A' of a TPCA A consists of a family of subsets A'

⊆ Aσ,

one for each σ, such that (for some k, s, y, n, suc, rec suitable for A) we have
for all ρ, σ, τ and all n ∈ N, kστ , sρστ , yσ, n, suc, recσ ∈ A';
A' is closed under application, in the sense that

'
σ→τ
∧ x ∈ A'
∧ f · x↓  ⇒ f · x ∈ A' .

A substructure T ' of a type structure T consists of a family of subsets
' ⊆ Tσ, one for each σ, such that T ' = T0 = N and T ' is closed under
application in the evident sense.
If A' is a sub-TPCA of A, we define EC(A; A'), the relative extensional collapse of A and A', to be the substructure of EC(A) consisting of those elements t that are realized by at least one element of A'.
In fact, EC(A; A') corresponds precisely to the type structure over the natural numbers in the relative realizability model PER(A; A') (see e.g. [1]). Note that the substructure EC(A; A') need not be (even isomorphic to) a type structure in its own right, since it need not be extensional. That is, there could be two elements f, g ∈ EC(A; A')σ→τ which are distinct as functions EC(A)σ → EC(A)τ , but which restrict to the same function EC(A; A')σ → EC(A; A')τ . However, in the examples of interest in this paper, EC(A; A') will be the substructure RC of C, which is in fact extensional and so can itself be regarded as a standalone type structure. This is a consequence of the
Kleene-Kreisel density theorem — see [12] or, for full details, [13].
As a trivial point, note that EC(A; A)= EC(A).

Examples of TPCAs
We now illustrate our general framework by means of some examples. In Sec- tions 3.1–3.3 we consider various classes of TPCAs which give some indication of the scope of the notion. In Section 3.4 we review some of the known results concerning the extensional collapses of these models.
Untyped PCAs
Any ordinary (untyped) partial combinatory algebra can be viewed as a TPCA. Recall that a partial combinatory algebra (or PCA) consists of a set A equipped with a partial function · : A × A ~ A, such that there exist elements k, s ∈ A satisfying the first three conditions given in Definition 2.1. We may view any PCA A as a TPCA, by setting Aσ = A and ·σ,τ = · for all σ, τ . In the untyped setting, a suitable recursor y and a system of numerals can be constructed from k, s by well-known means (see e.g. [9, Chapter 1]).
Furthermore, we may say A' is a sub-PCA of A if A' ⊆ A contains some k, s suitable for A and is closed under application in the sense of Definition 2.5(i). Clearly, if A' is a sub-PCA of A, then viewing A, A' as TPCAs, A' is a sub- TPCA of A.
The following examples are particularly important for our purposes:
Example 3.1 Kleene’s ﬁrst model, denoted K1. Here the underlying set is N, and by definition m · n φm(n), where φ0, φ1,... is some fixed effective enumeration of the partial recursive functions.
Example 3.2 Kleene’s second model, denoted K2. Here the underlying set is NN, the set of all total functions N → N. To define application in K2, we need some auxiliary notation. First, let ⟨·· ·⟩ be some fixed effective coding of finite sequences of natural numbers as natural numbers, and for any g ∈ NN, let g˜ ∈ NN be the course-of-values function defined by
g˜(n) = ⟨g(0),..., g(n − 1)⟩.
Next, define a partial function |: NN × NN ~ N by
f | g  f (g˜(r)), where r is the least number s.t. f (g˜(r)) > 0.
(The motivation for this definition is explained in [12, Section 3.3].) We also define functions gm (for m ∈ N) by gm(0) = m, gm(n + 1) = g(n). Thus, from any f, g we may obtain a partial function Λm. f | gm : N ~ N. The application operation for K2 is now defined by
Λm. f | gm if this is a total function,
f · g =
⎩ undefined  otherwise.


Notice that the functions NN → NN that are representable in K2 (i.e. are of the form Λg. f · g for some f ∈ K2) are precisely the continuous functions with respect to the usual Baire topology on NN.
Moreover, by restricting to the total recursive functions N → N, we obtain a sub-PCA Keff of K2. (In this paper we will uniformly use the superscript eff to denote an effective substructure of some given structure.)
Other PCAs, whose definition will not be required in this paper, include: Scott’s graph model Pω; Plotkin’s Tω; van Oosten’s B; the effective sub-PCAs of all these; and various term models of untyped lambda calculi, such as Λ0/β, the set of closed lambda terms modulo β-equivalence. Several of these PCAs are discussed e.g. in [10].
CCC models
Many of the cartesian closed categories considered in denotational semantics naturally give rise to TPCAs. The general idea is as follows: we start with

a cartesian closed category C, within which we can find an object N¯
with a

canonical inclusion N ‹→ Hom(1, N¯ ). We may then interpret our types σ by
objects [ σ ] as follows:

[[ 0 ]] =
N¯ ,	[[ σ → τ ]] = [[ τ ]][[ σ ]].

Now define a structure A by taking Aσ = Hom(1, [[ σ ]]) for each σ, with ·στ the function induced by the evaluation morphism [ σ → τ ]] × [[ σ ]] → [[ τ ]]. The existence of suitable k, s follows from the fact that C is cartesian closed, and the numerals n are given by our canonical inclusion. Furthermore, if C contains successor, recursor and fixed point morphisms in an obvious sense, then A will contain suitable elements suc, rec, y and will hence be a TPCA. Intuitively, these conditions will hold in any category that is a “model of PCF” (see Section 3.3 below). This includes many categories of domains based on order-theoretic notions (e.g. Scott domains, stable domains), as well as more intensional categories such as the sequential algorithms model of Berry and Curien, and many of the categories of games considered by Abramsky,

Hyland et al. Typically, in all these models, we take N¯
to be the object

playing the role of the domain N⊥. Furthermore, most of these models have obvious “effective submodels” which give rise to sub-TPCAs.
As in [12], we will write P for the TPCA obtained in this way from the standard Scott model (consisting of the partial continuous functionals over N⊥), and Peff for its effective submodel. We will also write L for the TPCA

arising from the category of continuous lattices (where we take N¯
to be the

“flat” lattice of natural numbers with a bottom and top element), and Leff for the effective submodel of L.

Syntactic models
Another class of TPCAs are those arising as term models for programming languages, particularly extensions of Plotkin’s PCF. As in [12], let us define (combinatory) PCF to be the language consisting of the well-typed expressions built up via application from the constants
Kστ : σ → τ → σ
Sρστ : (ρ → σ → τ ) → (ρ → σ) → (ρ → τ )
Yσ : (σ → σ) → σ
if : 0 → σ → σ
0 : 0
suc : 0 → 0
pre : 0 → 0
We write k as an abbreviation for the term suck0, and define the reduction relation ~ for PCF to be the smallest transitive relation on PCF terms sat- isfying the following clauses, in which we assume all terms are well-typed:
K UV ~ U ,   S UV W ~ (UW )(VW ),   Y U ~ U (Y U ).
pre 0 ~ 0,  pre k^+1 ~ k.
if 0 U V ~ U ,   if k^+1 U V ~ V .
If U ~ U ' then UV ~ U 'V .

If U ~ U ' : 0 then c U ~ c U ' for c = suc, pre, if.
Suppose now that L is any language obtained from PCF by extending the definition with (finitely many) new typed constants and reduction rules: for example, PCF with “parallel-or”, or PCF with a non-functional operator such as “catch”. Let ∼ be any congruence on terms of L; that is, an equivalence relation which contains ~ and satisfies
M ∼ M ' ∧ N ∼ N ' ⇒ MN ∼ M 'N '
We may define a TPCA L/∼, called the term model of L modulo ∼, by taking (L/∼)σ to be the set of L-terms modulo ∼; ·στ to be the function induced by application of L-terms; and k, s, y, n, suc to be the equivalence classes of K, S, Y, n, suc. It is a simple exercise to write a suitable PCF program for rec. Note that the smallest interesting congruence here will be the one gen- erated by ~, and the largest will be the one corresponding to observational
equivalence of L-terms.

Known constructions of particular type structures
We next review some known results concerning the total type structures ob- tained as the extensional collapse of the above models. These will give us some possible definitions of our three type structures of interest. We refer the reader to [12] for further details of relevant equivalence results.
The type structure C of continuous functionals may be obtained in any of the following ways:
C = EC(K2). This is essentially Kleene’s original definition of C via asso- ciates (see e.g. [12, Section 3.3]). Modulo unimportant details, an associate for a functional is essentially a realizer in K2.
C = EC(P). This characterization, due to Ershov, can be seen as a cleaned- up version of Kreisel’s original definition, and is the construction that is usually favoured as the definition of C in the more recent literature (see e.g. [13]). The equivalence between this and the K2 characterization is non-trivial. Since all the relevant domains Pσ are known to be retracts of Plotkin’s Tω, it follows easily from this characterization that also C = EC(Tω).
C = EC(L). This is due to Scott, and is quite close to Ershov’s characteri- zation. Since all continuous lattices are known to be retracts of Scott’s Pω, it follows easily that C = EC(Pω).
Most of the other known constructions of C are of a topological or semi- topological character: for instance, one obtains C as the type structure over N in the cartesian closed category of compactly generated Hausdorff spaces, or of filter spaces, limit spaces, etc. These characterizations do not fit into the realizability framework considered here.
Many of the above constructions can be effectivized in a natural way, and hence allow us to define an “effective” substructure of C. In fact, all reasonable effectivizations seem to lead to the same effective substructure RC ⊂ C of recursive continuous functionals. Thus:
RC = EC(K2; Keff).
RC = EC(P; Peff)= EC(Tω; Tωeff).
RC = EC(L; Leff)= EC(Pω; Pωeff).
A few of the topological models, such as the category of filter spaces, have a natural effective submodel, and these too give rise to RC.
Now suppose that for each of these models we consider the effective sub- model as a TPCA in its own right, so that we are only considering “effective operations acting on effective data”. In this case, the extensional collapse


construction yields a third class of functionals: the type structure HRC of hereditarily recursive continuous functionals. Here, a purely topological char- acterization is not available, but instead we have an alternative realizability characterization.
HRC = EC(Keff).
HRC = EC(Peff)= EC(Tωeff) (Ershov).
HRC = EC(Leff)= EC(Pωeff) (Scott).
Remarkably, HRC coincides with the type structure HEO of hereditarily effective operations, defined as EC(K1). This highly non-trivial result is known as the generalized Kreisel-Lacombe-Shoenﬁeld (KLS) theorem. 4 It was noted by Kreisel in [7], but the first published proof appeared in [16]. A proof of the result in the form in which we have stated it appears in [3].
We will henceforth use the name HEO for this type structure, as it is somewhat more familiar than HRC. In addition, the characterization via K1 plays an important role in the proof of our main result.
As noted in the Introduction, HEO is “incomparable” with RC and indeed with C. For instance, the Kleene tree functional is present in HEO2 but has no counterpart in RC or C, whereas the fan functional in RC3 has no counterpart in HEO. We refer the reader to [12] for further details.
The above is not an exhaustive list of the known characterizations of our type structures, and we shall have occasion to mention a few others below.

Continuous and Effective TPCAs
The pattern that emerges from the foregoing results is that the type structure obtained from an extensional collapse construction depends solely on whether the TPCA or TPCAs in question are “full continuous” or “effective”. This leads us to look for precise notions of full continuous TPCA and effective TPCA that will allow us to obtain theorems of roughly the following kind:
If A is a full continuous TPCA, then EC(A)= C.
If A is a full continuous TPCA and A' an effective sub-TPCA of A, then
EC(A; A')= RC.
If A is an effective TPCA then EC(A)= HEO.
We now propose some such definitions, which seem to us to capture the intuitive notions we have in mind, and introduce a little more machinery relevant to these. This will allow us, in Section 4.3, to give precise statements

4 The ordinary KLS theorem essentially states that HRC2 = HEO2.


of our main results, together with a brief overview of the method of proof. In Section 4.4 we will mention some specific applications of our results.

Realizations of TPCAs
We will start with the following general notion:
Definition 4.1 Suppose A is a TPCA, B an untyped PCA, and suppose 0, 1,... is a suitable system of numerals in A, and 0, 1,... a system of numerals in B.
A realization of A over B consists of a family of relations −σ ⊆ B × Aσ
(one for each σ) with the following properties:
For all a ∈ Aσ there exists b such that b −σ a.
For each σ, τ , there is an element αστ ∈ B such that for all b, b' ∈ B,
a ∈ Aσ→τ , a' ∈ Aσ,
b −	a ∧ b' − a' ∧ a · a' ↓  ⇒ αστ · b · b' − a · a'.
(We may think of this as saying “αστ tracks ·στ ”.)
There is an element χ ∈ B such that for all m, n ∈ N,
m −0n^ ⇒ χ · m = n˜.
We say A is realizable over B if there exists a realization of A over B.
In fact, this definition can be phrased more concisely using the terminology of [11]: a realization of A over B is an applicative morphism γ : A −→|  B such that γδ ≤ ϵ, where δ, ϵ are the canonical applicative morphisms from K1 to A, B respectively. The definition can also be generalized further, allowing B to be an arbitrary TPCA, though this will not be necessary for our present purposes.
The condition involving χ ensures that the representation of numerals in A
is in some sense “standard”. To see why this condition is important, consider

the situation where A = KT
for T some non-trivial Turing degree, and B =

K1. Intuitively, we do not expect A to be realizable over B. However, it turns out that there is an applicative morphism KT −→|  K1 (see [9, Chapter 3]), so in some sense we can simulate non-effective computations in K1. This is of no use in practice, though, because we have no way of “decoding” the result of the computation to obtain its value as a natural number; this deficiency corresponds to the absence of a suitable element χ.
The following facts are easily checked:
Proposition 4.2 (i) If A is realizable over B and B is realizable over C
(where A is a TPCA and B, C are PCAs), then A is realizable over C.

(ii) K1 (considered as a TPCA) is realizable over any PCA B.
We now propose the following definition:
Definition 4.3 A TPCA is effective if it is realizable over K1.
In view of the foregoing proposition, the notion of an effective TPCA is quite robust: for example, if B is any PCA realizable over K1 (such as Keff), then a TPCA is effective iff it is realizable over B. It is easy to check that all the “effective models” mentioned earlier — Peff, Leff, Tωeff, Pωeff, Keff and of course K1 itself — are effective TPCAs. In addition, any term model of the kind described in Section 3.3 is an effective TPCA, since we may give a realizability relation by means of a Go¨del-numbering of terms.
It is perhaps not immediately clear what the notion of a continuous TPCA should be. We propose the following:
Definition 4.4 A TPCA is continuous if it is realizable over K2.
A little experimentation reveals that all the familiar examples of “full con- tinuous PCAs” (e.g. Pω, Tω, B) are realizable over K2, and K2 is itself re- alizable over some of these, so this notion of continuous TPCA seems to be reasonably robust, and also covers all the examples we have in mind. The intuition is that in a continuous TPCA, each object embodies only a count- able amount of information (and hence can be coded by an element of K2); moreover all the relevant operations must act continuously with respect to this information content (and hence be realizable within K2).
We say a continuous TPCA is full continuous if, intuitively, it contains all set-theoretic functions N → N in a “standard” way. More precisely:
Definition 4.5 Suppose A is a continuous TPCA, with −σ a realization over
K2. We say A is full continuous if
for every f : N → N, there exists a ∈ A1 such that for all n ∈ N, a·n = f (n).
moreover a realizer for some such element a may be computed from f within K2. More precisely, there is an element ψ ∈ K2 such that for all f ∈ NN, we have ψ · f −1a for some a ∈ A1 satisfying the foregoing condition, where · denotes application in K2.
This condition can also be expressed in terms of applicative morphisms, though it is not quite trivial to do so. The second half of the condition ensures that the first half holds in a suitable “constructive” sense; this appears to be essential for the proofs of our theorems.
We also need the notion of an effective sub-TPCA of a full continuous TPCA. Recall here that we have a sub-PCA Keff of K2, whose carrier set is
the set of total recursive functions.


Definition 4.6 Suppose A is a full continuous TPCA, with −σ , αστ , χ,ψ as in Definitions 4.1 and 4.5, and A' is a sub-TPCA of A. We say A' is an effective sub-TPCA of A if
for all a ∈ A' , there exists f ∈ Keff with f − a;
σ	2	σ
for all σ, τ , the elements αστ , χ,ψ are in Keff.
Since Keff is itself an effective PCA, it is easy to see that if A' is an effective sub-TPCA of A then A' is an effective TPCA in its own right.
Realizations of type structures
We will also need the notion of a realization of a type structure over a PCA. This is an obvious adaptation of Definition 4.1; indeed, in the more general framework of applicative morphisms, we can make do with a single notion of realization.
Definition 4.7 Let T be a type structure, B be a PCA. A realization of T
over B is a family of relations −σ ⊆ B × Tσ such that
for all x ∈ Tσ there exists some b −σ x;
For each σ, τ there is an element θστ ∈ B such that for all b, b' ∈ B, f ∈
Tσ→τ , x ∈ Tσ, we have
b −	a ∧ b' − a' ∧ a · a' ↓ ⇒ θστ · b · b' − a · a'.
Finally, we will need a notion of when two realizations of a type structure are isomorphic. Intuitively, this is so when suitable translations between the realizations are computable within the PCA in question. (Again, this is simply an instance of a general concept of applicative isomorphism in the framework of [11].)
Definition 4.8 If − and −' are both realizations of T over B, we say
−, −' are isomorphic if for all σ there exist uσ, vσ such that for all x ∈ Tσ
and b, b' ∈ B we have
b −x ⇒ u · b −'x,	b' −'x ⇒ v · b' −x.
If moreover uσ, vσ belong to some sub-PCA B' of B, we say −, −' are iso- morphic relative to B'.
Clearly, a realization − of a TPCA A over B induces a realization −∗ of
EC(A) over B: using the notation of Definition 2.2, we define b −∗σ x if there
exists a ∈ Aσ with b − a and β[a]= x. Likewise, for any sub-TPCA A' of A,
a realization of A over B induces a realization of EC(A; A') over B.
Our three type structures have realizations arising from their definitions, which we may regard as the “standard” ones:

Definition 4.9 (i) The standard realization of C is the realization of C =
EC(K2) over K2 induced by the identity realization on K2.
The standard realization of RC is the realization of RC = EC(K2; Keff)
over K2 induced by the identity.
The standard realization of HEO is the realization of HEO = EC(K1) over K1 induced by the identity.
The main theorems
We are now at last able to give precise statements of our main results. The theorems for C and RC can be stated just as we would like them:
Theorem 4.10 (Ubiquity of C) Let A be any full continuous TPCA. Then EC(A) = C; moreover, the induced realization of EC(A) is isomorphic to the standard realization of C.
Theorem 4.11 (Ubiquity of RC) Let A be any full continuous TPCA, and
A' an effective sub-TPCA of A. Then EC(A; A') = RC; moreover, the in-

duced realization of EC(A; A') is isomorphic relative to Keff
to the standard

realization of RC.
The third theorem is considerably more delicate than the others, and at present we are able to prove it only under some slightly technical hygiene conditions:
Theorem 4.12 (Ubiquity of HEO) Let A be any effective TPCA satisfying the following conditions (where −σ, αστ are as in Deﬁnition 4.1):
Each αστ satisﬁes m −στ a ∧ n −σ b ∧ αστ (m, n) −τ c ⇒ a · b = c.
The relation m −0n is r.e. in m, n.
Then EC(A)= HEO; moreover, the induced realization of EC(A) is isomorphic to the standard realization of HEO.
Condition (A) here is very mild, and in all naturally arising examples that we know can be arranged to hold by choosing the functions αστ suitably. Condition (B) holds in most known models, but unfortunately rules out a few important models such as Pωeff and Keff (though in these cases the conclusion is known to hold anyway), as well as the effective Nakajima tree model of the untyped lambda calculus. We are very hopeful that it may be possible to
0
weaken (B) to “the relation m −0n^ is Π ”, which holds in all the models of
interest that we are aware of. It appears, however, that our method of proof
will not allow us to dispense with either (A) or (B) completely.
Our proofs of the above theorems are long and complex, and make essential use of a technique developed by Normann in [14]. We will briefly outline the


method of proof here, taking the case of HEO as an example. Full details of the proofs will appear in an extended version of this paper.
Normann showed that in the extensional collapse of Peff, every equivalence class contains at least one PCF-definable element of Peff. From this, it is not too hard to show that if Q is the term model for PCF (modulo any reasonable congruence), then EC(Q) = EC(Peff) = HEO, and moreover all these realizations of HEO are isomorphic to the standard one. We next note that PCF can be in some sense “interpreted” in any TPCA A whatever — this is clear enough from the similarity between the definition of TPCA and that of PCF. (In the parlance of denotational semantics, this interpretation of PCF will be sound but not in general adequate.) This amounts to saying that Q is realizable over A. In the situation of the Theorem 4.12, we are considering an effective TPCA A. That is, we have realizations
Q −→|	A −→|	K1
where EC(Q) = EC(K1) = HEO. Here one may naturally think of Q as the “weakest” effective TPCA and K1 as the “strongest”, with A sandwiched between them.
This already makes it look plausible that EC(A) = HEO, but in fact the proof is still very difficult, involving an elaborate induction up the types. At each type level σ, the crux is to show that each F ∈ HEOσ is present in EC(A)σ in a suitable way. We do this by constructing a PCF term M that “computes” F , and showing that the image of M in A is a suitable realizer for F . Here the technique for constructing M comes from Normann’s proof. Essentially, Normann considered the above situation in the case A = Peff, and showed by an ingenious and beautiful argument how to construct a PCF term for a given F ∈ HEOσ in this case. The core of our task is to adapt Normann’s method so that it works for a general effective PCA A. This requires various refinements and some delicate recursion-theoretic arguments, since certain useful features of Peff such as monotonicity are not available to us in the general setting. Both the generalized KLS theorem and the Myhill-Shepherdson theorem play an important role in these arguments.

Applications of our results
As the range of examples of TPCAs in Section 3 makes clear, a large number of new characterizations of our type structures flow from our theorems. Of course, many of these are of no obvious interest and answer questions that no one has ever asked. However, in the case of TPCAs which themselves em- body seemingly natural “notions of computability”, our theorems do provide specific results which are of relevance for our general project of mapping out


such notions and the relationships between them. We would particularly sin- gle out the van Oosten algebra B (a full continuous PCA) and its effective submodel, and also the type structure R of sequentially realizable functionals and its effective substructure — see [12]. Direct proofs of our results for these structures would probably be feasible but rather tiresome.
Perhaps most striking is the application of our results to syntactic mod- els, such as term models for the untyped lambda calculus. The problem of identifying the type structures arising from such models was explicitly raised by Beeson in [2], and has occasionally been mentioned in passing as an open problem since then (see e.g. [9, page 250]). Until recently, the author believed that this problem was probably intractable at present (as would seem to be the case for the problem of identifying the partial type structures arising from these models). However, we can now see immediately that EC(Λ0/β) = HEO for any consistent theory T .
It is also worth pointing out that our results apply even to such unwieldy structures as term models for full-scale programming languages. Consider, for example, the set of closed programs of Standard ML of simple type (for instance, with respect to the initial dynamic basis). Under the congruence generated by the evaluation relation, these clearly form an effective TPCA, and so without knowing any more about the definition of ML, one can conclude (along the lines described in Section 1.1) that the hereditarily total functionals computable in ML are precisely those of HEO. A version of this result holds even in the presence of global state variables, though its formulation requires a little extra care.

Conclusion
We have shown that some large classes of “standard realizability” construc- tions all give rise to one of the well-known type structures C, RC, HEO. As we have observed, even for individual TPCAs such results tend to have a non-trivial character, and so the possibility of obtaining such general results comes as a considerable surprise. Since our classes include a large number of mathematically natural constructions (as well as an even larger number of unnatural ones), we regard our results as providing strong evidence that these type structures are highly canonical mathematical objects. This is conceptu- ally very reassuring since, at least in the author’s view, it is usually rather difficult to convince oneself that any single extensional collapse construction, considered in isolation, defines a mathematically natural type structure: one is typically left with a nagging concern that the type structure obtained might be unreasonably sensitive to the kind of realizers involved.


We venture to suggest that our theorems in some way represent a new kind of result in the field of higher type computability. Whereas many of the main results in this field to date have been of the form that two particular construc- tions yield the same type structure, our results are of a rather more sweeping kind: any construction in some interesting (axiomatically defined) class gives rise to a certain type structure. Intuitively, rather than just considering a few isolated points or landmarks in the “space of notions of computability”, we are able to take care of a whole tract of territory in a single swoop.
We feel that the possibility of proving such general results is an encouraging sign for our overall project of mapping out the higher type computability landscape, since they allow us to progress in much bigger strides, and save us from the need (or temptation) to prove an endless stream of individual equivalence results. It would be interesting to know whether any results in a similar vein can be obtained for partial type structures (see [12, Section 4]).
Although our results are quite general, one shortcoming is that they do not at present apply to modiﬁed realizability constructions. In the modified realizability construction on a TPCA A, one first picks out a substructure A' of “hereditarily total” elements of A, and then applies the standard exten- sional collapse to A'. The problem is that A' may not be a TPCA in the sense of the present paper, since it will usually not possess y combinators. (In certain circumstances it is trivial to show that the standard and modified constructions agree, but this is not so in general.) Nevertheless, modified real- izability constructions are very much in the same ballpark as the constructions we have considered, so one might reasonably hope that our theorems could be extended to cover them. Further support for this is provided by a striking and non-trivial result of Bezem [4], who shows that the modified extensional collapse of K1 is also HEO, and likewise the modified extensional collapse of K2 is C.
Extending our theorems to include modified realizability would in our view give a better sense of completion to our results, but at present we cannot see how to achieve this. A closer study of Bezem’s proofs might well yield some useful insights here.

References
Awodey, S., L. Birkedal, and D.S. Scott, Local realizability toposes and a modal logic for computability, Mathematical Structures in Computer Science 12 (2002), 319–334.
Beeson, M., “Foundations of Constructive Mathematics,” Springer-Verlag, 1985.
Berger, U., Total sets and objects in domain theory, Annals of Pure and Applied Logic 60
(1993), 91–117.


Bezem, M., Isomorphisms between HEO and HROE, ECF and ICFE, Journal of Symbolic Logic 50 (1985), 359–371.
Kleene, S.C., Countable functionals, in Heyting, A., editor, “Constructivity in Mathematics: Proceedings of the Colloquium held at Amsterdam, 1957”, North-Holland (1959), 81–100.
Kleene, S.C., Recursive functionals and quantiﬁers of ﬁnite types I, Transactions of the American Mathematical Society 91 (1959), 1–52.
Kreisel, G., Interpretation of analysis by means of functionals of ﬁnite type, in Heyting, A., editor, “Constructivity in Mathematics: Proceedings of the Colloquium held at Amsterdam, 1957”, North-Holland (1959), 101–128.
Lietz, P., and T. Streicher, Impredicativity entails untypedness, Mathematical Structures in Computer Science 12 (2002), 335–347.
Longley, J.R., “Realizability Toposes and Language Semantics,” Ph.D. thesis, University of Edinburgh, 1995. Available as ECS-LFCS-95-332.
Longley, J.R., Matching typed and untyped realizability, Electronic Notes in Theoretical Computer Science 23(1) (1999).
Longley, J.R., Unifying typed and untyped realizability, Unpublished note, 1999. Available at
http://www.inf.ed.ac.uk/home/jrl/unifying.txt .
Longley, J.R., Notions of computability at higher types I, to appear in “Logic Colloquium 2000, Proceedings”, 109pp.
Normann, D., The continuous functionals, in Griffor, E.R., editor, “Handbook of Computability Theory”, North-Holland (1999), 251–275.
Normann, D., Computability over the partial continuous functionals, Journal of Symbolic Logic
65 (2000), 1133–1142.
Plotkin, G.D., Full abstraction, totality and PCF, Mathematical Structures in Computer Science 9(1) (1997), 1–20.
Troelstra, A.S., “Metamathematical Investigation of Intuitionistic Arithmetic and Analysis,” Lecture Notes in Mathematics 344, Springer-Verlag, 1973.
