Electronic Notes in Theoretical Computer Science 124 (2005) 97–111 
www.elsevier.com/locate/entcs


ACTAS : A System Design for Associative and Commutative Tree Automata Theory
Hitoshi Ohsaki
National Institute of Advanced Industrial Science and Technology (AIST) &
PRESTO – Japan Science and Technology Agency (JST)
ohsaki@ni.aist.go.jp

Toshinori Takai
CREST – Japan Science and Technology Agency (JST)
takai@ni.aist.go.jp


Abstract
ACTAS is an integrated system for manipulating associative and commutative tree automata (AC- tree automata for short), that has various functions such as for Boolean operations of AC-tree automata, computing rewrite descendants, and solving emptiness and membership problems. In order to deal with high-complexity problems in reasonable time, over- and under-approximation algorithms are also equipped. Such functionality enables us automated verification of safety prop- erty in infinite state models, that is helpful in the domain of, e.g. network security, in particular, for security problems of cryptographic protocols allowing an equational property. In runtime of model construction, a tool support for analysis of state space expansion is provided. The interme- diate status of the computation is displayed in numerical data table, and also the line graphs are generated. Besides, a graphical user interface of the system provides us a user-friendly environment for handy use.
Key words: term rewriting, AC-tree automata, veriﬁcation, cryptographic protocols

Introduction
Tree automata are the counterpart of finite automata for strings, in the sense that they inherit most of the properties holding for finite automata. It is known that tree languages recognized by tree automata are closed un-
der Boolean operations and most of the decidability results are positive [4].


1571-0661 © 2005 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.07.017


The tree automata framework is useful in dealing with trees (i.e. terms), and several verification techniques based on the tree automata theory have been
studied [5,7]. For instance, Kaji et al. pointed out in [8] that several impor-
tant cryptographic protocols can be modeled by term rewriting systems (TRS
for short, [2]) and tree automata, and moreover, the positive decidability re- sults and closure properties of tree automata allow us to design an automated deduction technique for reasoning about the security problems.
In fact, verification tools for security protocols have been developed by using tree automata framework [1,3]. Genet and Viet Triem Tong provided a tree automata library, called Timbuk [5,6], in which associative and com-
mutative properties of functions symbols are treated by using approximation. Rule-based approaches allowing associativity and commutativity have been also investigated, e.g. in [9].
Let us briefly explain below how to handle the model checking problem for infinite state transition systems in practice by using term rewriting and tree automata. We suppose that a TRS R over the signature F specifies the transition relation of a transition system M. We say M admits the transition step s →M t under an initial state space L if (1) s = C[lσ] and t = C[rσ] for some rewrite rule l → r in R, context C and substitution σ, and (2) there is

a state s0 in L such that s0 →∗
s, where →∗
is the reflexive and transitive

closure of →M. One should notice that →M ⊆ →R. Namely, the domain of the system M is the set of all ground terms over F, and the state space of M to be verified is the reachable states from L by R. We suppose that the initial state space L can be represented by some tree automaton A, in such a way that t ∈ L if and only if t is accepted by A. So, in this setting, given a rewrite system and a tree automaton specifying each of M and L, the reachable state
space of a transition system is considered to be defined. In the paper, we denote by L(A) the set of elements accepted by a tree automata A, and by [ →∗ ](L(A)) the set of reachable states.
Let P be some subset of the domain of M, that consists of states to which we do not allow M to admit the transition step from any initial state in L. For instance in the network protocols, P is the set of private information, L is the initial knowledge of the intruder, and R is the intruder’s possible operations. So the information obtainable by the intruder can be represented
by [ →∗ ](L), and thus, the intersection of P and [ →∗ ](L) contains a private
R	R
information that is reachable somehow by the intruder. In other words, the non-emptiness of the intersection indicates that the protocol is not secure.
However, the set [ →∗ ](L) of reachable states is not a regular tree language even if L is a regular tree language. Even worse, it is not computable in general. A tree language L is called regular if there exists a tree automata A such that


L is recognized by A. To overcome the above problem there have been several studies, such as: (1) to find a subclass, i.e. sufficient conditions, of R in which regularity is preserved, and (2) to extend the tree automata framework so that a wider class of tree languages can be handled. Decidable subclasses of such TRS that effectively preserve regularity have been investigated in [16,17].
Regarding the second approach, it is known that regularity is not AC- closed. Precisely, the AC-closure of a regular tree language is no longer regular. A binary function symbol f in a signature F is associative and commutative
if the following axioms are assumed:


f (x, f (y, z)) = f (f (x, y), z)	f (x, y) = f (y, x)


The AC-closure of a tree language L is, given a subset FAC of the binary function symbols in F, a set {t | ∃s ∈ L. s =AC t}. Here =AC denotes the equivalence relation induced by AC-axioms of all function symbols in FAC. The above negative observation reveals that for modeling a cryptographic protocol
allowing equational property like Diffie-Hellman key exchange protocol, the reachable state space can not be handled by the standard tree automata.
In this research we take the second approach. We proposed in [14] an extension of tree automata, called equational tree automata. We also showed in [11,12] that under certain useful equational axioms, e.g. associativity and/or
commutativity, tree languages accepted by the equational tree automata are closed under Boolean operations. To this extent, the previous Diffie-Hellman key exchange protocol can be handled, and even the verification process is automatable [13].
The AC-tree automata simulator (ACTAS) is a tool for the computation of tree automata allowing that some of the binary function symbols are asso- ciative and commutative. A screen shot of this system is presented in Fig. 1.
The class of AC-tree automata is effectively closed under union and in- tersection, and the membership and emptiness problems are decidable. In regular case, the emptiness test is solvable in linear time. The decidability
result of emptiness problem for non-regular case is also positive, however, it is
not manageable in the sense of real computation, that can be observed by the fact that the reachability of a Petri-net instance is known to be EXPSPACE- hard and non-regular AC-tree automata are in some sense a generalization of
Petri-nets. Therefore we designed in ACTAS over- and under-approximation

algorithms, for efficiently computing rewrite descendants [ →∗
](L(A/AC))

of given AC-tree automaton A/AC and AC-TRS R/AC.



Fig. 1. Control panel of ACTAS

AC-Tree Automata
We begin this section by introducing AC-tree automata. We then explain how to operate ACTAS as a tool for manipulating AC-tree automata and even as a tool for supporting automated verification.
A tree automaton (TA for short) A is a 4-tuple (F , Q, Qfin , ∆), whose components are the signature F, i.e. a finite set of function symbols with fixed arities, a finite set Q of special constant symbols, called states, with F ∩ Q = ∅, a subset Qfin of Q whose elements are called ﬁnal states, and a finite set ∆ of transition rules in one of the following forms:

such that f ∈ F with arity(f ) = n and p1,... , pn, q1,... , qn ∈ Q. In Type 2 the root function symbols of the left- and right-hand sides must be the same. Transition rules in Type 3 are called ϵ-rules (“epsilon-rules”). A TA A is called regular if ∆ consists only of rules in Type 1. Rules of Type 2 are not treated
in [4]. Under consideration of equational properties, however, Type 2 is essen- tial in the sense that, e.g. recognizable tree languages of our definition have a bijective correspondence to the word language hierarchy [11]. An efficient


algorithm for the intersection of such AC-tree automata, presented in [14], is also one of the advantages.
A transition move →A is the rewrite relation →∆ by taking ∆ as a TRS
∆ over the signature F ∪ Q. A ground term t over F is accepted if t →∗ qf
for some qf ∈ Qfin . The set of terms accepted by a tree automaton A is denoted as L(A). A tree language L, that is a subset of all ground terms, is recognizable if there is a tree automata A such that L = L(A).
An equational tree automaton is a pair of a tree automaton A and an equational theory E, denoted as A/E. The transition move is defined by the relation →A modulo E. An AC-tree automaton is an equational tree automaton whose equational theory is the associativity and commutativity
axioms for some of the binary function symbols in F. The basic properties of AC-tree automata are stated below:
Theorem 2.1 [12,14] (1) The class of tree languages recognizable with AC- tree automata are closed under union and intersection. (2) The class of tree languages recognizable with regular AC-tree automata are closed under Boolean operations. (3) The membership problem and the emptiness problem for AC- tree automata are decidable.	 
We consider the tree automaton A with the following transition rules
a → qa	b → qb	f(qa, qb) → q	f(q, q) → q
with the final state q. Suppose f is associative and commutative, then the AC-tree automaton A/AC accepts such trees t that
|t|a = |t|b
i.e. the number of occurrences of a is the same as the number of occurrences of b in the same tree t. One should notice that the above language is not recognizable with any tree automata.
In ACTAS the above AC-tree automaton A/AC is specified as shown below:
[signature] AC: f
const: a,b

[T-rule(q): A]
-> q_a
-> q_b f(q_a,q_b) -> q
f(q,q) -> q

The signature of the term model is specified by declaring AC-symbols (e.g. AC: f) and also declaring constant function symbols (e.g. const: a,b). Ac- cording to the syntax, the other constant symbols are recognized as state symbols. The tree automaton A is specified in the second module, named A,





Fig. 2. AC-rewrite descendant computation in ACTAS


by listing the transition rules. The argument value q of T-rule is the final state of the tree automaton A.
At the current implementation, ACTAS is equipped with the following func-
tions for (i)–(ii) Boolean operations and (iii) rewrite descendants computation, and the two solvers for (iv) membership problem and (v) emptiness problem:
Given AC-tree automata A/AC and B/AC, construct an AC-tree automa- ton C/AC such that L(C/AC) = L(A/AC) ∪ L(B/AC).
Given AC-tree automata A/AC and B/AC, construct an AC-tree automa- ton C/AC such that L(C/AC) = L(A/AC) ∩ L(B/AC).
Given an AC-tree automaton A/AC and an AC-TRS R/AC whose rewrite rules do not contain AC-function symbols, construct AC-tree automaton

C/AC such that L(C/AC) = [ →∗
](L(A/AC)).

Given an AC-tree automaton A/AC and a term t, determine whether
t ∈ L(A/AC).
Given an AC-tree automaton A/AC, determine whether L(A/AC) = ∅.
The computation results obtained by the operations (i)–(iii) can be re-used for new inputs. For automated verification, the above function (iii) is useful in order to construct models.
We consider the example in Fig. 2. The rewrite system R consists of the single rewrite rule 0 → s(s(0)). The tree automaton A1 accepts a tree t if one of the following three conditions is satisfied: (1) t = 0, (2) t = sum(s(0), s(0)), or (3) t = sum(t1, t2) such that t1, t2 are accepted by A1/AC. Due to the declaration AC: sum, the binary symbol sum is associative and commutative. Thus, the above language coincides with L = {t | |t|s(0) is even }. This means
t consists of the three components sum, 0, s(0) and the number of occurrences
of s(0) in t is even.
We take L(A1/AC) (= L) as an initial state space, then the transition

system induced by R/AC satisfies that: s is an element in [ →∗
]( L ) if and

Σn	R/AC

only if s = sum{ s1,... , sn } such that
i=1[[si ] is even, where [0]] = 0 and


[[s(t)]] = [t]]+1. Namely, s is a term generated by Y/AC with A1/AC whenever the sum of natural numbers occurring in s is even. On the other hand, the

tree language [ →∗
]( L ) can be represented by an AC-tree automaton, for

instance, A2/AC defined in Fig. 2. But the advantage of using ACTAS is that
we can construct an AC-tree automaton as a result of descendant computation. One can observe that in constructing AC-tree automata by the fixpoint computation, the bounded computation is often required, because given an

AC-TRS Y/AC and an AC-tree automaton A/AC, (a) [ →∗
](L(A/AC)) is

not computable in general, and (b) even if [ →∗
](L(A/AC)) is computable

under a certain condition, it may not be recognizable with AC-tree automata.
These two cases correspond to non-terminating computation.
From the above observation, in ACTAS, three parameters are arranged in

the control panel. (See the lower left-hand corner in Fig. 1).
Parameter 1

restricts the number of the execution of the outermost-loop in the algorithm:
By setting Parameter 1 to be n (≥ 1) in function (iii), we can execute the
rewrite descendant computation only of n-loops. In case that Parameter 1 is 0, the program checks whether a given ACTAS code is syntactically correct as no substantial computation occurs.
For computing over- or under-approximated results, we select appropriate positive integers for Parameters 2 and 3. If non-left-linear rewrite rules like f (x, x) → x are included in the rewrite system, we need to check, in the algorithm of function (iii), whether tree automata Ap1 = (J , Q, {p1}, ∆) and
Ap2 = (J , Q, {p2}, ∆) satisfy
L(Ap1 /AC) ∩ L(Ap2 /AC) /= ∅
for some p1, p2 in Q with p1 /= p2. The values of Parameters 2 and 3 restrict the search depth and width of the decision procedure of the above question. But if Parameters 2 and 3 are the maximum 100, upper-bound limitation is ignored. That in turn results in the exact solution if the computation termi- nates. Hence, by selecting appropriate positive integers for Parameters 1–3,

one can obtain under-approximated results of [ →∗
](L(A/AC)) in reason-

able time. On the other hand, by letting Parameters 2 and 3 be 0, it turns
out over-approximated results.

Cryptographic Protocol Verification
We explain below how to verify network protocols by using ACTAS. In the protocol illustrated in Fig. 3, we write E(x, y) for a message y encrypted by some key x, and K(x) for a principal x’s secret key. The goal of this protocol is to send a secret message m from alice to bob without losing the secrecy.


Hence m is encrypted with another secret key (nonce) r, and thus r is also encrypted and transfered to bob. In this network communication, alice first sends a triple of E(K(alice), r), alice the sender’s ID, and bob the receiver’s ID. Then server reacts to this request by sending back E(K(bob), r) to alice. At the final step alice sends the pair of E(K(bob), r) and E(r, m), to bob. The latter component is generated by encrypting m by r. The receiver bob can retrieve the clear-text m by decrypting E(K(bob), r) first.

(1)E(K(alice), r), alice, bob	_s erver
  (2)E(K(bob), r)

alice
	  bob
E(K(bob), r),E(r, m)


Fig. 3. A cryptographic protocol

Now we assume that an intruder eve has the following 4 abilities:
If eve knows x and E(x, y), then eve also knows y,
eve knows how to apply encryption and decryption functions E and D,
i.e. if eve knows x and y, eve can construct E(x, y) and D(x, y),
eve knows its own secret key K(eve) and names of all the other principals,
e.g. alice and bob,
eve can wiretap the network channels, i.e. eve knows all information flow- ing in the network of Fig. 3.
To detect the security flaw (otherwise, to ensure the secrecy of the proto- col), we verify the protocol by using TRS and tree automata. We first model by a tree automaton the initial knowledge of the intruder eve. We then gen-
erate the set of states reachable from the initial knowledge by the following TRS:
Ycrypt = { D(x, E(x, y)) → y }
The TRS Ycrypt corresponds to the above intruder’s ability 1. The other assumptions 2–4, which are the intruder’s initial knowledge and available op- erations, can be represented by the tree automaton Ainitial, that is shown in Fig. 4.
The tree automaton Ainitial accepts a term t if and only if t is obtainable by the intruder without using the encryption-decryption axiom Ycrypt. The

∗ Rcrypt
](L(Ainitial)) of reachable states corresponds to the fixpoint of the

intruder’s knowledge. By computing rewrite descendants (function (iii)), we

have a tree automaton Afixpoint that satisfies L(Afixpoint) = [ →∗
](L(Ainitial))

if there exists. Therefore, by solving membership constraint (function (iv))





Fig. 4. Specification code of cryptographic protocol assuming wiretapping only




Fig. 5. Specification code of cryptographic protocol assuming active attack


m ∈ L(Afixpoint)?, it can be determined whether or not the protocol is secure against wiretapping.
Along the similar construction scheme, we can detect that the same proto- col is not secure against impersonation. The associated tree automaton and TRS is illustrated in Fig. 5, that represents the previous protocol example in
which intruder’s active attack is assumed. By allowing that every principal (including the intruder eve) sends a request to server, we add the rewrite rule

s(x, y, z) → E(k(z), D(k(y), x))



Fig. 6. The numbers of transition rules and state symbols (loop 0–4)

and the transition rule s(q, q, q) → q to the previous code. In the left-hand side s(x, y, z) of the rewrite rule, the variables x, y, z are respectively (in- tended to) assigned to encrypted data, sender’s ID and receiver’s ID. The
result of this rewriting step is a server’s reply, and that is hoped to be re- ceived by a sender. More precisely, the sender receives an encrypted message E(K(s1), D(K(s2), s3)), that is once decrypted with a sender’s key at server
site and the result is encrypted with a receiver’s key. We assume also that eve
can decompose any data of the form s(t1, t2, t3), and this situation is repre- sented by the other three rewrite rules.
In the experiment, by using function (iii) of ACTAS with Parameter 1 to be
or the greater (and the others to be arbitrary positive integers), we obtain an under-approximated result. The numbers of transition rules and state symbols at each loop are shown in Fig. 6. This table together with the line graphs is generated automatically. We can save the displayed data as HTML format files (Fig. 7).
The resulting tree automaton accepts the secret message m, and thus, we know that the protocol is not secure. Actually, the protocol allows the follow-
ing security flaw: The intruder eve first sends the tuple of E(K(alice), r), alice, eve to server. These elements are included in eve’s initial knowledge due to the assumptions 3 and 4. Then eve obtains E(K(eve), r) as a response from server. By the assumptions 2 and 3, eve creates D(D(K(eve), E(K(eve), r)), E(r, m)) that gives rise to m, because of Ycrypt that is the assumption 1.

4	Diffie-Hellman Key-Exchange Protocol
The protocol illustrated below is called Diffie-Hellman key-exchange algorithm (e.g. Section 22.1, [15]):
In the figure H(x, y) stands for the composition of data x and y, that is an integer yx (mod p where p is given) in the real situation. To simplify the property of H, we assume in this model that H is implemented as H(x, y) = px+y (mod q where p, q are given). A secret key of a principal x is denoted
by K(x). The goal of this protocol is without losing the secrecy to share a session key by exchanging some data between the initiator (alice in the



Fig. 7. Tool support for state space analysis
H(K(alice),r), r	 



alice	¸,
H(K(bob),r)
bob

	(3) E(H(H(K(bob),r),K(alice)),m)	 

Fig. 8. Diffie-Hellman key-exchange algorithm

example) and the receiver (bob), and then to send from the initiator to receiver a message encrypted by the session key. The protocol consists of the three steps: alice first chooses a number r and sends it to bob together with an integer H(K(alice), r). We suppose that no one else can retrieve K(alice) only from H(K(alice), r). At the second step bob returns H(K(bob), r) to alice. Because of the exponentiation in the implementation of H, one can assume
that H is associative and commutative:

H(x, H(y, z)) = H(H(x, y), z)	H(x, y) = H(y, x)





Fig. 9. Diffie-Hellman key-exchange protocol (assuming wiretapping only)


Due to the first two steps, alice can generate H(H(K(bob), r), K(alice)) by combining H(K(bob), r) and K(alice). The latter component is her secret key. Similarly, bob also generates H(H(K(alice), r), K(bob)) such that:
H(H(K(alice), r), K(bob))  =AC H(H(K(bob), r), K(alice)).
Hence bob obtain the message m as follows.
D(H(H(K(alice), r),K(bob)),E(H(H(K(bob), r),K(alice)), m))  =AC
D(H(H(K(bob), r),K(alice)),E(H(H(K(bob), r),K(alice)), m))  →Rcrypt  m
The assumption of the protocol can be specified as the ACTAS code like in Fig. 9. In this setting we suppose that (a) the intruder eve can wiretap the network channels, but (b) eve does not actively attack to the protocol.
Even if the binary function symbol H is associative and commutative, the AC-rewrite descendants can be computed by using the same algorithm of [16], because H does not appear in rewrite rules.  But since the left-hand
side of Ycrypt has multiple occurrences of the variable x, the intersection-
emptiness problem for AC-tree automata has to be dealt with in the algorithm. The intersection of AC-tree automata can be computed in ACTAS efficiently. However, the resulting AC-tree automata are no longer AC-regular in this
efficient construction, and to solve the emptiness problem for non-regular AC- tree automata is EXPSPACE-hard [12].
In fact, when computing the exact solution fully automatically, it is nearly


non-terminating computation. Then there are two choices for this example: th over-approximation algorithm (by setting Parameter 2 to be 0) and the under-approximation (by choosing positive integers for Parameters 2 and 3).
Over-approximation. In this case, the result, that is an AC-tree automaton, is some superset of eve’s obtainable knowledge. Namely, if the secret message m is not accepted, the secrecy of the protocol is guaranteed. By taking the above input (Fig. 9), we obtain an AC-tree automaton as the output that accepts m. But then, it does not imply security flaw of the protocol. At
the current implementation there is no option to refine the over-approximated result.
Under-approximation. In the full automation mode, the security flaw of the protocol is not detected either. This meas that by taking several pairs of positive integers for Parameters 2 and 3, the under-approximated result is obtained, but none of the AC-tree automata that represents some subset of
eve’s obtainable knowledge accepts the secret message m. Despite of this fact,
we have another possibility to handle this protocol example in the AC-tree automata framework. The underlying idea of computing rewrite descendants is, given a tree automaton A = (J , Q, Qfin , ∆), to find a rewrite rule l → r ∈Y 
and an assignment ρ = {xi '→ qi | 1 ≤ i ≤ n} with q, qi ∈ Q and 1 ≤ i ≤ n

such that lρ →∗
q but rρ /→∗
q. Then we add new states and transition

rules to A, so that the newly obtained system A'/AC satisfies rρ →∗ '	q.
This process corresponds to one-step rewrite descendant computation for the case that t →R t' for some t ∈ L(A/AC) and t' ∈/ L(A/AC) such that t/o = lσ, t' = s[rσ]o, ρ = σ ↓A/AC (i.e. ρ is a normalized substitution of σ with respect to A/AC). Furthermore, as an exceptional case in the above computation, non-left-linear rewrite rules are treated as follows. For instance, we consider
the rule f (x, x) → x and take two (different) state symbols p1 and p2, then we check whether

L(A(p1)/AC) ∩ L(A(p2)/AC) /= ∅.
The above L(A(pi)/AC) is a tree language accepted by A/AC whose final state Qfin is replaced by {pi}. If the above question is positively solved, we take the different assignment x '→ p1 and x '→ p2 for the same variable x. Formally, non-linear variable x is replaced by x1 and x2, and then define the substitution ρ containing the assignments x1 '→ p1 and x2 '→ p2.
Suppose A0/AC is the AC-tree automaton initially provided.  Then the
following statement is stated.
Lemma 4.1 For each state symbols p and q of A0/AC, the intersection-


emptiness of L(A0(p)/AC) and L(A0(q)/AC) is tested by solving ﬁnitely many membership problems.
Proof. We suppose p /= q, where q is the final state symbol of the AC- tree automaton in Fig. 9. By construction, L(A0(p)/AC) accepts only finitely many trees t1,..., tn, and t1,... , tn are effectively generated, due to Ko¨nig’s
Lemma e.g. in [10]. So, in this case, the intersection-emptiness is solvable by membership tests. The remaining case is obvious.	 
Membership function in the system assists us to perform the above test. In theory, membership problem for regular AC-tree automata is NP-complete (Corollary 4, [12]), but in this example, the size of trees is at most 9. This implies that all the possible combinations of p and q are computable in rea- sonable time. By using this result, we can examine the following property is correct.
Lemma 4.2 Let p1, p2, p3, p4 be state symbols of A0/AC such that
L(A0(p1)/AC) ∩ L(A0(p2)/AC) /= ∅,
then D(p1, E(p2, p3)) →∗	p4 if and only if p1 = p2 = p3 = p4 = q.	 

Theorem 4.3 The tree language [→∗
crypt
](L(A0/AC)) is recognizable with

A0/AC.	 
Therefore A0/AC is already the fixpoint, namely, the protocol is secure against wiretapping, because m is not in eve’s initial knowledge L(A0/AC).
Regarding the active attack by assuming impersonation, the security flaw of the protocol is noted in [15]. For instance, this protocol allows the following attack:

(1) H(K(alice),r), r		(2) H(K(eve),r), r	 
	


alice ¸,
H(K(bob),r)
eve ¸,
H(K(bob),r)
bob

 E(H(H(K(bob),r),K(alice)),m) 


Fig. 10. Man-in-the-middle attack in Diffie-Hellman key exchange protocol


Acknowledgement
The authors thank the three anonymous referees for their numerous comments and suggestions to improve the early version of the paper.

References
A. Armando, D. Basin, M. Bouallagui, Y. Chevalier, L. Compagna,
S. Mo¨dersheim, M. Rusinowitch, M. Turuani, L. Vigan`o and L. Vigneron: The AVISS Security Protocol Analysis Tool, Proc. of 14th CAV, Copenhagen (Denmark), LNCS 2404, pp. 349–353, Springer-Verlag, 2002.
F. Baader and T. Nipkow: Term Rewriting and All That, Cambridge University Press, 1998.
Y. Chevalier and L. Vigneron: Automated Unbounded Veriﬁcation of Security Protocols, Proc. of 14th CAV, Copenhagen (Denmark), LNCS 2404, pp. 324–337, Springer-Verlag, 2002.
H. Comon,	M. Dauchet,	R. Gilleron,	F. Jacquemard,	D. Lugiez,
S. Tison and M. Tommasi: Tree Automata Techniques and Applications, 2002. Draft available from http://l3ux02.univ-lille3.fr/tata/ .
T. Genet and F. Klay: Rewriting for Cryptographic Protocol Veriﬁcation, Proc. of 17th CADE, Pittsburgh (PA), LNCS 1831, pp. 271–290, Springer-Verlag, 2000.
T. Genet and V. Viet Triem Tong: Reachability Analysis of Term Rewriting Systems with Timbuk, Proc. of 8th LPAR, Havana (Cuba), LNAI 2250, pp. 691–702, Springer-Verlag, 2001.
H. Hosoya, J. Vouillon and B.C. Pierce: Regular Expression Types for XML, Proc. of 5th ICFP, Montreal (Canada), SIGPLAN Notices 35(9), pp. 11–22, ACM Press, 2000.
Y. Kaji, T. Fujiwara and T. Kasami: Solving a Uniﬁcation Problem Under Constrained Substitutions Using Tree Automata, Journal of Symbolic Computation 23, pp. 79–117, 1997.
Jos´e Meseguer: Software Speciﬁcation and Veriﬁcation in Rewriting Logic, Proc. of NATO Advanced Study Institute on Models, Algebras and Logic of Engineering Software, Computer and Systems Sciences 191, pp. 133–193, IOS Press, 2003
Y.N. Moschovakis: Notes on Set Theory, Undergraduate Texts in Mathematics, Springer- Verlag, 1994.
H. Ohsaki, H. Seki and T. Takai: Recognizing Boolean Closed A-Tree Languages with Membership Conditional Rewriting Mechanism, Proc. of 14th RTA, Valencia (Spain), LNCS 2706, pp. 483–498, Springer-Verlag, 2003.
H. Ohsaki and T. Takai: Decidability and Closure Properties of Equational Tree Languages, Proc. of 13th RTA, Copenhagen (Denmark), LNCS 2378, pp. 114–128, Springer-Verlag, 2002.
H. Ohsaki and T. Takai: A Tree Automata Theory for Uniﬁcation Modulo Equational Rewriting, Proc. of 16th UNIF, Copenhagen (Denmark), 2002.
Draft available from http://staff.aist.go.jp/hitoshi.ohsaki/ .
H. Ohsaki: Beyond Regularity: Equational Tree Automata for Associative and Commutative Theories, Proc. of 15th CSL, Paris (France), LNCS 2142, pp. 539–553, Springer-Verlag, 2001.
B. Schneier: Applied Cryptography: Protocols, Algorithms, and Source Code in C, Second Edition, John Wiley & Sons, 1996.
T. Takai, Y. Kaji and H. Seki: Right-Linear Finitely Path overlapping Term Rewriting Systems Effectively Preserve Recognizability, Proc. of 11th RTA, Norwich (UK), LNCS 1833, pp. 246– 260, 2000.
T. Takai, H. Seki, Y. Fujinaka and Y. Kaji: Layered Transducing Term Rewriting System and Its Recognizability Preserving Property, IEICE Transactions on Information and Systems E86-D(2), pp. 285–295, 2003, Information about IEICE Transactions is found at http://www.ieice.org/.
