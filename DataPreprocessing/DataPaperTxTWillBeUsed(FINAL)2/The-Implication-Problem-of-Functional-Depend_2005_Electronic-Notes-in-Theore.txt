Electronic Notes in Theoretical Computer Science 123 (2005) 125–137 
www.elsevier.com/locate/entcs


The Implication Problem of Functional Dependencies in Complex-value Databases
Sven Hartmann1 and Sebastian Link2
Information Science Research Centre, Massey University, Palmerston North, New Zealand

Abstract
Modern applications increasingly require the storage of data beyond relational structure. The challenge of providing well-founded data models that can handle complex objects such as lists, sets, multisets, unions and references has not been met yet. The success of such data models will greatly depend on the existence of automated database design techniques that generalise achievements from relational database design. In this paper, a provably-correct and polynomial-time algorithm for deciding implication of functional dependencies in the presence of all combinations of records, lists, sets, and multisets is proposed. The notion of a functional dependency is based on a Brouwerian algebra of subattributes, yielding a complementary expressiveness.
Keywords: Logic in Databases, Implication Problem, Functional Dependency, Brouwerian Algebra, Data Type


Introduction
Functional dependencies (FDs) were introduced in the context of the relational data model (RDM) by Codd in 1972 (see [18]). FDs are expressions of the form X → Y on a relation schema R with X, Y ⊆ R. A relation r over R is said to satisfy the FD X → Y if and only if any two tuples of r that coincide on X also coincide on Y . FDs are not independent from one another. That is, an FD X → Y is implied by a set Σ of FDs, if X → Y is satisfied by every relation which already satisfies all dependencies in Σ. A sound and

1 Email:s.hartmann@massey.ac.nz
2 Email:s.link@massey.ac.nz



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.04.051


complete set of inference rules for the implication of FDs in the RDM has been discovered by Armstrong in [3]. In the context of the RDM such inference rules are easily available. The set of all attribute sets for some relation schema forms a Boolean algebra with respect to set inclusion, union, intersection and complement. On the basis of Armstrong’s axiomatisation, polynomial time algorithms for deciding the implication problem [7], deciding the equivalence of two given sets of FDs [10] and deriving minimal covers for FDs [37] have been developed. A solution to these problems was a big step towards automated database schema design [10] which some researchers see as the ultimate goal in dependency theory [8]. Moreover, normal form proposals such as Boyce-Codd Normal Form and Third Normal Form [8,7,11] have been semantically justified [20,50] by formally proving the equivalence to the absence of redundancies and abnormal update behavior using again Armstrong’s axiomatisation.
During the last couple of decades, many new and different data models have been introduced. First, so called semantic data models have been developed [17,33,47], which were originally just meant to be used as design aids, as ap- plication semantics was assumed to be easier captured by these models. Later on some of these models, especially the nested relational model [35], object- oriented and object-relational models [6,24,43,44] have become interesting as data models in their own right and some dependency and normalisation the- ory has been carried over to these advanced data models [25,26,27,39,41,46,52]. Most recently, the major research interest is on the model of semi-structured data and XML [48]. Work on integrity constraints in the context of XML can be found in [2,15,23,22,51]. One key problem is to develop dependency theo- ries (or preferably a unified theory) for these advanced data models. Biskup
[13] lists in particular two challenges for database design theory: finding a uni- fying framework and extending achievements to deal with advanced database features such as complex object types. We propose to classify data models ac- cording to the type constructors which are supported by the model. The RDM, for instance, is completely captured by the record type, the nested relational data model by the record and set type. This view allows to study problems in dependency theory for various classes of dependencies in the presence of various combinations of types, as illustrated in Figure 1.
In the present paper we consider all combinations of record, set, multiset and list type that include at least the record type. The need for these various types arises from applications that store ordered relations, time-series data, meteorological and astronomical data streams, runs of experimental data, mul- tidimensional arrays, textual information, voices, sound, images, video, etc. They have been subject to studies in the deductive and temporal database community for some time [42,40], and occur also naturally in object-oriented



Dependencies

Join Inclusion MVDs
FDs



records sets multisets lists unions references  Data Models
Fig. 1. Research in Dependency Theory
databases [6,43,24] and are in particular important for XML [48]. Recently, bioinformatics has become a very important field of research. Of course, lists and sets occur naturally in genomic sequence databases [36,45,14]. Multisets are the fundamental data structure of a number of computational frameworks, such as Gamma coordination language [4], the Chemical Abstract Machine [12], and P systems modeling membrane computing [19]. For a recent survey on the use of multisets in various areas of logic and computer science see [16], in which [34] specifically focuses on database systems.

An Abstract Data Model
The goal of this section is to provide a framework for the study of dependency classes in the context of complex-value databases. In this paper, we will deal with records, lists, sets, and multisets.
Definition 2.1 A universe is a ﬁnite set U together with domains dom(A)
for all A ∈ U . The elements of U are called flat attributes.	 
In the following definition we use a set L of labels, and assume that the symbol λ is neither a flat attribute nor a label, i.e., λ ∈/ U∪ L. Moreover, flat attributes are not labels and vice versa, i.e., U ∩ L = ∅.
Definition 2.2 Let U be a universe and L a set of labels. The set N A = N A(U , L) of nested attributes over U and L is the smallest set satisfying the following conditions:
λ ∈ N A, and U ⊆ N A,
for L ∈L and N1,... , Nk ∈ N A with k ≥ 1 we have L(N1,..., Nk) ∈ N A,
for L ∈L and N ∈ N A we have L{N}, L⟨N⟩, L[N] ∈ N A.
We call λ null attribute, L(N1,... , Nk) record-valued attribute, L{N} set- valued attribute, L⟨N⟩ multiset-valued attribute, and L[N] list-valued at- tribute.	 


We extend the mapping dom from flat attributes to nested attributes.
Definition 2.3 For a nested attribute N ∈ N A we deﬁne the domain dom(N)
as follows:
dom(λ)= {ok},
dom(L(N1,... , Nk)) = {(v1,..., vk) | vi ∈ dom(Ni) for i = 1,..., k}, i.e., the set of all k-tuples (v1,..., vk) with vi ∈ dom(Ni) for all i = 1,... , k,
dom(L{N}) = {{v1,... , vn} | vi  ∈ dom(N) for i  = 1,... , n}, i.e.,
dom(L{N}) is the set of all ﬁnite subsets of dom(N),
dom(L⟨N⟩)  =  {⟨v1,... , vn⟩  |  vi  ∈  dom(N) for i  =  1,..., n}, i.e.,
dom(L⟨N⟩) is the set of all ﬁnite multisets with elements in dom(N),
dom(L[N]) = {[v1,... , vn] | vi ∈ dom(N) for i = 1,... , n}, i.e., the set of all ﬁnite lists with elements in dom(N).	 
We denote empty set, empty multiset, and empty list by ∅, ⟨ ⟩, [ ], respec- tively. Nested attributes can be partially ordered according to the information content they represent.
Definition 2.4 The subattribute relation ≤ on the set of nested attributes N A over U and L is defined by the following rules, and the following rules only:
N ≤ N for all N ∈ N A, and λ ≤ A for all A ∈ U,
λ ≤ N for all set-, multiset- and list-valued attributes N ∈ N A,
L(N1,... , Nk) ≤ L(M1,... , Mk) whenever Ni ≤ Mi for all i = 1,..., k,
L{N}≤ L{M}, L⟨N⟩≤ L⟨M⟩, and L[N] ≤ L[M], if N ≤ M.
For N, M ∈ N A we say that M is a subattribute of N if and only if M ≤ N
holds. We write M /≤ N if and only if M is not a subattribute of N. 
The subattribute relation is indeed a partial order on nested attributes, i.e., reflexive, anti-symmetric and transitive. Informally, M ≤ N for N, M ∈ N A if and only if M comprises at most as much information as N does.
Definition 2.5 Let N, M ∈ N A with M ≤ N. The projection function πN :
Dom(N) → Dom(M) is deﬁned as follows:
if N = M, then πN = idDom(N) is the identity on dom(N),
if M = λ, then πN : Dom(N) → {ok} maps every v ∈ Dom(N) to ok,
if N = L(N1,... , Nk) and M = L(M1,... , Mk), then πN = πN1 × ··· × πNk
M	M1	Mk
mapping (v1,... , vk) ∈ Dom(N) to (πN1 (v1),... , πNk (vk)) ∈ Dom(M),
M1	Mk
if N = L{N '} and M = L{M '}, then πN : Dom(N) → Dom(M) maps
every set S ∈ Dom(N) to the set {πN' (s) : s ∈ S}∈ Dom(M),



if N = L⟨N '⟩ and M = L⟨M '⟩, then πN'
: Dom(N) → Dom(M) mapping

S ∈ Dom(N) to ⟨πN' (s) : s ∈ S⟩∈ Dom(M), and

if N = L[N '] and M = L[M '], then πN
: Dom(N) → Dom(M) maps every

list [v ,... ,v ] ∈ Dom(N) to the list [πN' (v ),... , πN' (v
)] ∈ Dom(M). 

1	n	M '	1	M '	n
It follows, in particular, that ∅, ⟨ ⟩, [ ] are always mapped to themselves, except when projected on the null attribute λ in which each of them is mapped to ok. Fix a set C of attribute names, and a set L of labels.
Definition 2.6 Let N ∈ U A be a nested attribute. The set Sub(N) of subattributes of N is Sub(N) = {M | M ≤ N}. The bottom element λN of Sub(N) is given by λN = L(λN1 ,..., λNk ) whenever N = L(N1,... , Nk), and λN = λ whenever N is not a record-valued attribute.	 
We study the algebraic structure of Sub(N). A Brouwerian algebra [38] is

a lattice (L, ±, H, H, —. , 1) with top element 1 and a binary operation —.
which

satisfies a—. b ± c iff a ± b H c for all c ∈ L. In this case, the operation —. is
called the pseudo-difference. The Brouwerian complement чa of a ∈ L is then defined by чa = 1—. a. The system of all closed subsets of a topological space is a well-known Brouwerian algebra [38].
Definition 2.7 Let N ∈ U A and X, Y ∈ Sub(N). The join X HN Y , meet X HN Y and pseudo-difference X—. N Y of X and Y in Sub(N) are inductively deﬁned as follows:
if X ≤ Y , then X HN Y = Y, X HN Y = X and X—. N Y = λN ,
X—. N λN = X,
if N = L{M}, X = L{X'},Y = L{Y '}, then X ◦N Y = L{X'◦M Y '} for ◦∈ 
{H, H} and if X /≤ Y , then X—. N Y = L{X'—. M Y '},
if N = L⟨M⟩, X = L⟨X'⟩,Y = L⟨Y '⟩, then X ◦N Y = L⟨X' ◦M Y '⟩ for ◦∈ 
{H, H} and if X /≤ Y , then X—. N Y = L⟨X'—. M Y '⟩,
if N = L[M], X = L[X'],Y = L[Y '], then X ◦N Y = L[X' ◦M Y '] for ◦ ∈ 
{H, H} and if X /≤ Y , then X—. N Y = L[X'—. M Y '],
if N = L(N1,... , Nk),X = L(X1,... , Xk) and Y = L(Y1,... , Yk), then
X ◦N Y = L(X1 ◦N1 Y1,... , Xk ◦Nk Yk) for ◦∈ {H, H, —. }.	 
In order to simplify notation, occurences of λ in a record-valued attribute are usually omitted if this does not cause any ambiguities. If the context allows, we omit the index N from the operations HN , HN , —. N and from λN . Given some nested attribute N ∈ U A and Y, Z ∈ Sub(N), we use Y C = N —. Y to denote the Brouwerian complement of Y in Sub(N). The pseudo difference Z—. Y of Z and Y in Sub(N) satisfies Z—. Y ≤ X if and only if Z ≤ Y H X for all X ∈ Sub(N). Consequently, for all X ∈ Sub(N) holds Y C ≤ X if and only

if X H Y = N holds.
Theorem 2.8 (Sub(N), ≤, HN , HN , —. N ,N) forms a Brouwerian algebra for every N ∈ U A.	 


Axiomatising Functional Dependencies
We define FDs on a nested attribute and introduce some sound inference rules for the implication of FDs.
Definition 3.1 Let N ∈ U A be a nested attribute. A functional dependency on N is an expression of the form X → Y where X , Y ⊆ Sub(N) are non- empty. A set r ⊆ Dom(N) satisﬁes an FD X → Y on N, denoted by |=r
X → Y, if and only if πN (t1)= πN (t2) holds for all Y ∈Y whenever πN (t1)= 
Y	Y	X
πN (t2) holds for all X ∈X and any t1, t2 ∈ r.	 
The notions of implication (|=) and derivability (▶R) with respect to a rule system R for FDs on a nested attribute can be defined analogously to the notions in the RDM (see for instance [1, p. 163-168]). Note that in the case of FDs the finite implication problem coincides with the unrestricted implication problem. We are interested in the set of all FDs implied by Σ, i.e., Σ∗ = {ϕ | Σ |= ϕ}. Our aim is finding a set R of inference rules which is sound (Σ+ ⊆ Σ∗) and complete (Σ∗ ⊆ Σ+), where Σ+ = {ϕ | Σ ▶R ϕ} is the set of FDs derivable from Σ using only inference rules from R. The following example reveals a fundamental difference between sound inference rules in the RDM and our data model.
Example 3.2 Let N = Tennis{Match(Winner, Loser)} and r = {t1, t2} ⊆ Dom(N) an instance with t1 = {(Becker, Agassi), (Stich, McEnroe)} and t2 = {(Becker, McEnroe), (Stich, Agassi)}. The projections of t1 and t2 co- incide on Tennis{Match(Winner)} and Tennis{Match(Loser)}.	 
Example 3.2 shows that Definition 3.1 of an FD X → Y on some nested attribute N cannot be simplified to an expression of the form X → Y with X, Y ∈ Sub(N). In general, the values on subattributes X and Y do not de- termine the value on X HY . The following condition is sufficient and necessary when values on subattributes X and Y determine the value on X H Y .
Definition 3.3 Let N ∈ U A. The subattributes X, Y ∈ Sub(N) are reconcil- able if and only if at least one of the following conditions is satisﬁed
Y ≤ X or X ≤ Y ,
N = L(N1,..., Nk),X = L(X1,... , Xk),Y = L(Y1,... , Yk) where Xi and
Yi are reconcilable for all i = 1,... , k,

N = L[N '],X = L[X'],Y = L[Y '] where X' and Y ' are reconcilable.	 The next result has been proven in [31] which extends the work in [27]. Theorem 3.4 The generalised Armstrong Axioms for FDs, i.e.

X → Y Y ⊆ X ,


{X}→ {Y }
 X → Y	 X → X ∪ Y





{X, Y }→ {X HN Y }
X, Y reconcilable,	X → Y, Y → Z ,

are minimal, sound and complete for the implication of FDs in the presence of records, lists, sets and multisets.	 

A polynomial-time Membership Algorithm
We will now present a provably-correct membership algorithm that works in polynomial time. Similar to the RDM [7] we introduce the notion of a closure for a set of nested attributes with respect to a given set of FDs.
Definition 4.1 Let N ∈ U A, X ⊆ Sub(N) a set of subattributes of N, and Σ a set of FDs on N. The closure X + ⊆ Sub(N) of X with respect to Σ is X + = {Z : X → {Z}∈ Σ+}.	 
We then have Y ⊆ X + iff Σ |= X → Y. It is even sufficient to compute

the set X +
Y ⊆gen X +
of ≤-maximal subattributes of X + since Y ⊆ X + if and only if
, where Y ⊆gen X holds iff for all Y ∈ Y there is some X ∈ X 

with Y ≤ X (Hoare-ordering). In order to solve the implication problem for
FDs on some nested attribute N we will split N into mutually reconcilable subattributes Ni.
Definition 4.2 Let N ∈ U A. A nested attribute Ni ∈ Sub(N) isa unit of N if and only if Ni is ≤-maximal with the property that all reconcilable X, Y ≤ Ni satisfy X ≤ Y or Y ≤ X. The set of all units of N is denoted by C(N). 
Given some set X ⊆ Sub(N) of nested attributes, the function max(X ) returns all maximal elements of X with respect to ≤. Moreover, if C(N) = 
{N1,... , Nk}, then Xi = {X H Ni : X ∈ X } for i = 1,..., k.
Algorithm 1 (Nested Attribute Closure)
Input: N ∈ N A, X ⊆ Sub(N ), set Σ of FDs on N
Output: X alg
Method:
VAR X new, X old, Ci, Vi ⊆ Sub(N) for i = 1,... , k, N1,... , Nk ∈ Sub(N);
i	i



Compute C(N)= {N1,..., Nk};
FOR i =1 TO k DO X new := max({X H Ni : X ∈ X });
REPEAT
FOR i =1 TO k DO X old := X new;
i	i
FOR each C → V ∈ Σ DO
IF Ci ⊆gen X new for i = 1,... ,k THEN
FOR i =1 TO k DO X new := max(X new ∪ Vi);
i	i
ENDIF; ENDDO;
UNTIL X new = X old for i = 1,... , k;
i	i

alg max
:= {X1 H ... H Xk : Xi ∈ X new};

RETURN(X alg );	 


The correctness of Algorithm 1, i.e., X alg
+
max
is proven in the full

version of the paper.
Theorem 4.3 Algorithm 1 is correct, i.e., X alg

max.	 

The input of Algorithm 1 consists of some nested attribute N, some set Σ of FDs on N and a set X of subattributes of N. We define the size m of N as the number of subattributes of N, i.e., m = | Sub(N) |. This is a reasonable measure since we consider sets of subattributes in general. The size s of Σ is simply defined as the number of its elements, i.e., s = | Σ |. The size of X is defined as | X |. The following upper complexity bound for deciding implication in the presence of all types is proven in the full version of the paper.
Theorem 4.4 In the presence of records, lists, sets and multisets, the impli- cation problem Σ |= σ for FDs on a nested attribute N can be solved in time O(m4 · s · min{m, s}) where m = | Sub(N) | and s = | Σ |.	 
Figure 2 shows upper complexity bounds for the implication problem of FDs in the presence of various types. If one of the input parameters is the nested attribute N, then let n denote the number of join-irreducible subat- tributes of N.

Consider a retailer which keeps track of its sales on a daily basis. For each day the sequence of incoming orderes is stored. Every order consists of information about the customer who places the order, the multiset of articles ordered, and the total value of the order. A customer is described by its name, address and payment details. Every article in that order has a title, a

Records, Lists, Sets, Multisets
O(m4 ,· s,· m in {m, s})
,,,,,,,,,,,,
Records, Lists, Sets	Records, Lists, Multisets	Records, Sets, Multisets
O(m4 · s · m in {m, s})	O(m4 ,· s,· m in {m, s})	O(m3 ,· s,· min{m, s})
  , , , , , ,,	  , , , , , ,,
,,,,	,,,,

Records, Lists
O(n · s)
Records, Sets
O(m3 · s · min{m, s})
Records, Multisets
O(m3 ·,s,· min{m, s})

,,,,,
,,,,
Records
O(n · s)
Fig. 2. Upper Complexity Bounds for the Implication Problem

description and a price. Besides the sequence of incoming orders, the retailer stores the set of different products which were sold that day. As a matter of fact, not only the title of the sold product is stored but also the name of the customer who bought it. Moreover, the company keeps information about the total price of sales, the total number of orders, the total number of products sold and the total number of shippings for each day. An order might be desribed by
Order(Cart⟨Article(Title,Type,Price)⟩,Customer(Name,Address,Payment),SubTotal)
in which a cart is used to collect a multiset of articles, and SubTotal is used to denote the total value of the order. In what follows, we will use the label Order to identify the nested attribute above. The final nested attribute N itself may look as follows
Sales(Day,List[Order],Sold{Product(Item,CustName)},Total,NOrd,NProd,NShip).
Product(Item,CustName) denotes an item together with the name of the cus- tomer who bought it. Total denotes the total price of sales, NOrd the total number of orders, NProd the total number of products and NShip the total number of shippings. A few reasonable constraints that a database designer may specify for this application are the following.
Sales(Day) → N ,
Sales(List[Order(Cart⟨Article(Title)⟩)]) → Sales(Sold{Product(Item)}),
Sales(List[Order(Cart⟨Article(Price)⟩)]) → Sales(List[Order(SubTotal)]),
Sales(List[Order(SubTotal)]) → Sales(Total),
Sales(List[Order(Customer(Name))]) → Sales(Sold{Product(CustName)}),
Sales(List[Order(Cart⟨Article(Title)⟩,Customer(Name))]) →
Sales(Sold{Product(Item,CustName)}),
Sales(List[λ]) → Sales(NOrd), and Sales(NOrd) → Sales(List[λ]),
Sales(List[Order(Cart⟨λ⟩)]) → Sales(NProd),
Sales(List[Order(Cart⟨λ⟩,Customer(Address))]) → Sales(NShip).


Suppose we want to find the closure of the subattribute Sales(List[Order(Cart⟨Article(Price)⟩)]) with respect to Σ. Using Algo- rithm 1 we obtain
Sales(List[Order(Cart⟨Article(Price)⟩,SubTotal)],Total,NOrd,NProd).
This shows that given the list of multisets of individual prices, one can deter- mine the list of total values of the orders, the total price of sales, the total number of orders and the total number of products ordered.

Some Applications
Algorithm 1 can be applied to solve several other important problems related to database design. One application is to eliminate redundant FDs. An FD σ is called redundant in a set Σ of FDs on some nested attribute N if and only if (Σ — {σ})+ = Σ+. A non-redundant cover of Σ is a set Θ of FDs on N where Θ+ = Σ+ and Θ does not contain any redundant FD. In order to determine if σ is redundant in Σ, one can test whether σ ∈ (Σ—{σ})+ holds. A subset Θ ⊆ Σ that is a non-redundant cover of Σ can be found using the following algorithm:
Θ := Σ;
FOR each σ ∈ Σ DO
IF σ ∈ (Θ — {σ})+ THEN Θ := Θ — {σ};
ENDDO; RETURN(Θ);
Note that Θ will always be a subset of Σ although this is not required by the definition of a non-redundant cover. The result is dependent on the selection order of σ. The running time of the previous algorithm is O(m4·s2·min{m, s}) in the most general case. A set X ⊆ Sub(N) of subattributes of some nested attribute N is called a superkey for N with respect to a given set Σ of FDs on N if and only if Σ |= X → N holds. This means that X is a superkey for N if and only if N ∈ X +. The problem of deciding whether X ∈ Sub(N) isa superkey for N with respect to Σ can therefore be solved in time O(m4 · s · min{m, s}) in the most general case.

Related and Future Work
Our definition of FDs deviates significantly from previous approaches in the nested relational data model, object-oriented data models and XML. Instead of following a path-based notion, our approach is based on a Brouwerian alge-


bra of subattributes, yielding a complementary expressivenss. In a nutshell, we are not concerned with how to represent flat data using complex object types, but with actual dependencies among complex objects. For a detailed comparison to previous works see [31].
Future work is best explained using Figure 1. The class of FDs should be studied in the presence of unions and references which are particularly impor- tant for XML [48]. We intend to extend previous work on normal forms, i.e. syntactically describe well-designed nested attributes with respect to a given set of constraints, and to semantically justify this proposal. In [30] the Nested List Normal Form has been proposed and justified. The axiomatisation in [27,31] may help to justify normal form proposals for more sophisticated com- binations of types. More classes of relational dependencies are to be studied next, e.g. multi-valued dependencies (MVDs), join and inclusion dependen- cies. The work in [32,29] provides minimal axiomatisations for the class of MVDs and the class of FDs and MVDs in the presence of records and lists. A provably-correct polynomial time algorithm for the implication of FDs and MVDs in the presence of records and lists can be found in [28]. We intend to address normalisation for FDs and MVDs leading to a normal form pro- posal which is likely to deviate from a simple extension of the well-known Fourth Normal Form [20,50]. Finally, a more general treatment in which data dependencies are interpreted as formulae in a suitable logic may result in a successful treatment as in the RDM [21,49]. Here, the first-order theories of lists, multisets and sets established in [19] seem promising.

References
Abiteboul, S., R. Hull and V. Vianu, “Foundations of Databases,” Addison-Wesley, 1995.
Arenas, M. and L. Libkin, A normal form for XML documents, ToDS 29 (2004), pp. 195–232.
Armstrong, W. W., Dependency structures of database relationships, Information Processing (1974), pp. 580–583.
Banatre, J. and D. Le Metayer, Programming by multiset transformation, Communications of the ACM 36 (1993), pp. 98–111.
Beeri, C., On the membership problem for functional and multivalued dependencies in relational databases, ToDS 5 (1980), pp. 241–259.
Beeri, C., A formal approach to object-oriented databases, Data and Knowledge Engeneering 5
(1990), pp. 353–382.
Beeri, C. and P. A. Bernstein, Computational problems related to the design of normal form relational schemata, ToDS 4 (1979), pp. 30–59.
Beeri, C., P. A. Bernstein and N. Goodman, A sophisticate’s introduction to database normalization theory, in: VLDB, 1978, pp. 113–124.
Beeri, C., R. Fagin and J. H. Howard, A complete axiomatization for functional and multivalued dependencies in database relations, in: SIGMOD, 1977, pp. 47–61.
Beeri, C., A. Mendelzon, Y. Sagiv and J. Ullman, Equivalence of relational database schemes, SIAM Journal on Computation 10 (1981), pp. 647–656.
Bernstein, P., Synthesizing third normal form relations from functional dependencies, ToDS 1
(1976), pp. 277–298.
Berry, G. and G. Boudol, The chemical abstract machine, Theoretical Computer Science 96
(1992), pp. 217–248.


Biskup, J., Achievements of relational database schema design theory revisited, in: Semantics in databases, number 1358 in LNCS (1998), pp. 29–54.
Bry, F. and P. Kr¨oger, A computational biology database digest: data, data analysis, and data management, Distributed and Parallel Databases 13 (2003), pp. 7–42.
Buneman, P., S. Davidson, W. Fan, C. Hara and W. Tan, Keys for XML, in: Tenth WWW Conference (2001).
Calude, C., G. Paun, G. Rozenberg and A. Salomaa, editors, “Multiset Processing, Mathematical, Computer Science, and Molecular Computing Points of View,” LNCS 2235, Springer, 2001.
Chen, P. P., The entity-relationship model: Towards a uniﬁed view of data, ToDS 1 (1976),
pp. 9–36.
Codd, E. F., Further normalization of the database relational model, in: Courant Computer Science Symposia 6: Data Base Systems (1972), pp. 33–64.
Dovier, A., A. Policriti and G. Rossi, A uniform axiomatic view of lists, multisets, and sets, and the uniﬁcation algorithm, Fundamenta Informaticae 36 (1998), pp. 201–234.
Fagin, R., Multivalued dependencies and a new normal form for relational databases, ToDS 2
(1977), pp. 262–278.
Fagin, R. and M. Vardi, The theory of data dependencies: a survey, in: Mathematics of Information Processing: Proceedings of Symposia in Applied Mathematics (1986), pp. 19–71.
Fan, W. and L. Libkin, On XML integrity constraints in the presence of DTDs, in: PODS 2001
(2001).
Fan, W. and J. Sim´eon, Integrity constraints for XML, in: PODS 2000 (2000).
Gardarin, G., J.-P. Cheiney, G. Kiernan, D. Pastre and H. Stora, Managing complex objects in an extensible relational DBMS, in: VLDB, 1989, Amsterdam (1989), pp. 55–65.
Hara, C. and S. Davidson, Reasoning about nested functional dependencies, in: PODS 1999
(1999), pp. 91–100.
Hartmann, S., On the implication problem for cardinality constraints and functional dependencies, Annals of Mathematics and Artificial Intelligence 33 (2001), pp. 253–307.
Hartmann, S. and S. Link, On functional dependencies in advanced data models, ENTCS 84
(2003).
Hartmann, S. and S. Link, A membership algorithm for functional and multi-valued dependencies in the presence of lists, ENTCS 91 (2004).
Hartmann, S. and S. Link, Multi-valued dependencies in the presence of lists, accepted for PODS (2004).
Hartmann, S. and S. Link, Normalisation in the presence of lists, in: ADC, Conf. Research and Practice in Inf. Technology 27 (2004), pp. 53–64.
Hartmann, S., S. Link and K.-D. Schewe, Axiomatising functional dependencies in the presence of records, lists, sets and multisets, Technical Report 1/2004, Dept of Information Systems, Massey University, New Zealand (2004).
Hartmann, S., S. Link and K.-D. Schewe, Reasoning about functional and multi-valued dependencies in the presence of lists, in: FoIKS, LNCS 2942 (2004), pp. 134–154.
Hull, R. and R. King, Semantic database modeling: Survey, applications and research issues, ACM Computing Surveys 19 (1987).
Lamperti, G., M. Melchiori and M. Zanella, On multisets in database systems, in: WMP 2000, LNCS 2235 (2000), pp. 147–216.
Levene, M., “The Nested Universal Relation Database Model,” Springer, 1992.
Li, J., S. Ng and L. Wong, Bioinformatics adventures in database research, in: Database Theory
- ICDT 2003, LNCS 2572 (2002), pp. 31–46.
Maier, D., Minimum covers in relational database model, JACM 27 (1980), pp. 664–674.
McKinsey, J. and A. Tarski, On closed elements in closure algebras, Annals of Mathematics
47 (1946), pp. 122–146.
Mok, W. Y., Y. K. Ng and D. W. Embley, A normal form for precisely charachterizing redundancy in nested relations, ToDS 21 (1996), pp. 77–106.
Naqvi, S. and S. Tsur, “A logical language for data and knowledge bases,” Computer Science Press, 1989.
O¨ zsoyoglu, Z. M. and L. Y. Yuan, A new normal form for nested relations, ToDS 12 (1987),
pp. 111–136.
Richardson, J., Supporting lists in a datamodel, in: Proceeding of VLDB, 1992, pp. 127–192.
Schewe, K.-D. and B. Thalheim, Fundamental concepts of object oriented databases, Acta Cybernetica 11 (1993), pp. 49–85.
Scholl, M. and H.-J. Schek, A relational object model, in: ICDT (1990), pp. 89–105.
Seshadri, P., M. Livny and R. Ramakrishnan, The design and implementation of sequence database system, in: VLDB, Mumbai, India, 1996.


Tari, Z., J. Stokes and S. Spaccapietra, Object normal forms and dependency constraints for object-oriented schemata, ToDS 22 (1997), pp. 513–569.
Thalheim, B., “Entity-Relationship Modeling: Foundations of Database Technology,” Springer- Verlag, 2000.
Thompson, H. S. D. Beech, M. Maloney, and N. Mendelsohn, XML Schema, W3C Recommendation, May 2001, http://www.w3.org/XML/Schema (2001).
Vardi, M. Y., Fundamentals of dependency theory, in: E. B¨orger, editor, Trends in Theoretical Computer Science (1987), pp. 171–224.
Vincent, M., “The semantic justification for normal forms in relational database design,” Ph.D. thesis, Monash University, Melbourne, Australia (1994).
Vincent, M. W., J. Liu and C. Liu, A redundancy free 4NF for XML, in: XML Database Symposium, 2003.
Weddell, G., Reasoning about functional dependencies generalized for semantic data models, TODS 17 (1992), pp. 32–64.
