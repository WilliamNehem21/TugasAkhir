Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 334 (2018) 17–29
www.elsevier.com/locate/entcs
Fuzzy Set Abstraction
Jacob Lidman and Josef Svenningsson1
Computer science and engineering, Chalmers University of Technology, Gothenburg, Sweden

Abstract
Program analysis plays a key part in improving modern software. Static (sound) analyses produce globally correct, but often pessimistic results while dynamic (complete) analyses yield highly precise results but with limited coverage. We present the Fuzzy set abstraction which generalizes previous work based on 3-valued logic. Our abstraction allows for hybrid analysis where static results are refined dynamically through the use of fuzzy control systems.
Keywords: Abstract interpretation, static program analysis, dynamic program analysis


Introduction
Static and dynamic analysis are complementary. Static analysis is sound because it summaries all possible executions, whereas dynamic analysis provides more precise information because it summaries the executions which actually happen in practice. Over-approximation in static analysis is sometimes a sever problem for appli- cations that rely on the results. Static alias analysis often produce point-to sets several times larger than dynamic alias analysis[8],[9] and in extension inhibits sev-
eral opportunities for parallelization.
Being able to combine both kinds of analyzes can greatly improve results, for instance in non-functional verification (e.g. deducing worst-case benefit of com- piler optimizations) when pessimistic assumptions about input state/environment is used. In this case, sound results are interesting at compile-time so that optimiza- tions that are guaranteed to be detrimental is not applied. In contrast, complete results are interesting at run-time where the actual set of inputs are known and hence the benefit of an optimization can be accurately evaluated. The fuzzy data- flow framework[5] showed how program analyzes based on fuzzy logic can uncover

1 Email: lidman@chalmers.se, josefs@chalmers.se

https://doi.org/10.1016/j.entcs.2018.03.003
1571-0661/© 2018 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

optimization opportunities that classical frameworks would not. The generalization to many-valued fuzzy logics allow program properties to be true or false to a certain degree. The truth values are elements of the unit interval 2 and denote bias of the program property. For instance, a result of 0.1875 would indicate that the property tends to false since it is closer to 0 (false) than to 1 (true).
The increased expressiveness offered by using fuzzy logic in program analysis however motivates additional research into the properties of the analysis framework, in particular soundness and completeness.
We introduce the Fuzzy Set Abstraction that generalize the three-valued logic abstraction[10]. We present the theoretical foundation of the fuzzy set abstraction and prove soundness for the static analysis (Section 3.1). We also present a dynamic analysis (Section 3.2) where we use an adaptive fuzzy inference system from fuzzy control theory to gradually specialize the analysis results to improve accuracy.
Preliminaries
We briefly introduce several concepts from the fuzzy set community. Our static analyses manipulate fuzzy sets using predicate transformers, expressed using fuzzy logic (Section 2.1), and collector functions motivated by possibility theory (Section 2.2). Similarly our dynamic analyses start from the results of the static analysis and iteratively specialize it to increase the accuracy of our results. This process relies on a fuzzy classifier (Section 2.3).
Fuzzy set and logic
Fuzzy sets assign a partial membership to each element as opposed to classical sets where the membership is binary. We use the common point-wise ordering to relate two fuzzy sets: ⟨S, μA⟩≤ ⟨S, μB⟩⇔ ∀s ∈ S : μA(s) ≤ μB(s).
Definition 2.1 Let S be a set of elements and μS a membership function that assigns a membership value from the unit interval [0, 1] to each element. Then
⟨S, μS⟩ is a fuzzy set.
A fuzzy set over a singleton set can be considered a description of partial truth. Fuzzy logic defines logical connectives to manipulate such fuzzy sets. Here, com- plement ¬˜ is often defined as negation (i.e., 1 − x) and, in the Min-max fuzzy logic, the max operation is used for disjunction ∨˜ and min operator for conjunction ∧˜.
Definition 2.2 Fuzzy logics  ∧˜, ∨˜, ¬˜ satisfy the De Morgans laws. ∧˜ and ∨˜ are
two binary functions [0, 1]2 → [0, 1] that are commutative, associative and monoton- ically decreasing/increasing and have identity elements (x ∧˜ 1 = x and x ∨˜ 0 = x). Similarly ¬˜ is a unary function ¬˜ : [0, 1] → [0, 1] that is decreasing, involutory (i.e.
¬˜(¬˜(x)) = x) and satisfy the boundary conditions ¬˜(0) = 1 and ¬˜(1) = 0 3 . The

2 To guarantee termination we use a finite congruence set of the unit interval.
3 In the fuzzy logic literature the conjunction operator is called a Triangular norm (T-norm), the disjunction operator called Triangular conorm (S-norm) and complement the C-norm

logical connectives are lifted point-wise for non-singleton sets of elements.
Possibility theory
Possibility theory is a non-classical theory for reasoning about uncertainty. Whereas probabilities are self-dual, i.e. P (x)= 1 −P (x), possibilities Π are dually related to necessities N , i.e. Π(x)=1 − N (x). Underlying these two measures is a possibility distribution π that encode the partial knowledge of a universe Ω: for x ∈ 2Ω, π(x)=1 mean x is totally possible and π(x)=0 mean x is rejected as impossible 4 .
Definition 2.3 The possibility and necessity measure is defined by Π(X) = supu∈X π(u) and N (X) = infu/∈X 1 − π(u) respectively, where π : 2Ω → [0, 1] is a possibility distribution that given a universe of discourse Ω with measurable subsets, satisfies:
π(∅)=0 
π(Ω) = 1
For any set U of pair-wise disjoint subsets Ui ⊆ Ω: π( i Ui)= supi π(Ui)
Although concepts parallel to probability theory (e.g., independence, condition- ing) can be defined for possibility theory [2] we restrict attention to partial orders between distributions. An information order sort distributions based on their in- formative content by comparing a measure to its negation (i.e., Π(x) = 1 − Π(x) or N (x)=1 − N (x)). The measure provides the least amount of information when it is equal to its negation, i.e. Π(x) = Π(x) = 0.5. We define a semi-lattice 5 [0, 1], ≤H, H over a set of events isomorphic to the unit interval (i.e. [0, 1]= 2Ω) such that x ≤H y mean P (x) is more informative than P (y):



0.1

0
0.5



0.9

1
max(x, y) x, y ≤ 0.5
x H y =	min(x, y) x, y ≥ 0.5
⎪⎪⎩ 0.5	otherwise

Conceptually the join operation returns the consensus of both inputs, i.e. the least informative of the two or the middle ground (0.5) if they are conflicting (one input is
< 0.5 and onei > 0.5). The information order is used in our static analysis in Section
3.1 to merge results from different control paths and formalize a concretization function.
Takagi-Sugeno Adaptive-Network-based fuzzy inference system (TS-ANFIS)
TS-ANFIS implements classification as inference in a system of fuzzy IF-THEN rules. Each rule is composed of an antecedent and consequence part. The antecedent is composed of a fuzzy set for each input variable of the classifier and the consequence is a polynomial mapping the input variables to the output domain. A two rule example classifier is shown in Figure 1 for two input variables x0 and x1 where the

4 Possibility measures are special cases of plausibility functions in Dempster-Shafer theory [2], a general- ization of Bayesian probability theory
5 Using the duality theorem the inverse order of this join semi-lattice is a meet semi-lattice, where in our case the elements would correspond to measures of N (x) since Π(x)=1 — N (x).

IF x0 is A0 and x1 is B0 THEN f = c(1,0) + c(1,1)x0 + c(1,2)x1 Example, classification of x = ⟨0.6, 0.2⟩ where f1(x) = 
IF x0 is A1 and x1 is B1 THEN f = c(2,0) + c(2,1)x0 + c(2,2)x1 0.2x0 — 0.43x1 and f2(x)= 0.1x1 + 0.5 and membership
functions given below.



x0





x1








w2


w¯1


w¯2
x0 x1








x0 x1


w¯1f1

μA0	μB0
0.6


f	μA1	μB1

0.286

x0	x1
The firing strength of each rule is given by:
w1 = 0.6 ∧˜ 0.5= 0.5
w2 = 0.286 ∧˜ 0.1= 0.1
The output of the classifier is:
f = 0.5f1(x)+ 0.1f2(x)
0.6
0.073
=	= 0.122
0.6


Fig. 1. First-order Takagi-Sugeno ANFIS with two rules and two variables
fuzzy sets in the antecedent part is called A0 (A1) and B0 (B1) for the first (second) rule respectively and similarly the coefficients of the polynomial of the consequence part is denoted c1,i (c2,i). The classifier is composed of five layers. The first three layers look up the fuzzy membership degrees of the input vector and compute the normalized fuzzy conjunction of this collection, producing the normalized ﬁring strength of the rule, i.e. the fuzzy membership or weight of the rule. In the example the fuzzy membership of the input vector is μA0 (x0)= 0.6 and μB0 (x1)= 0.5. The fuzzy conjuncture of the min-max fuzzy-logic evaluates to w1 = min(0.5, 0.6) = 0.5,
similarly w2 = 0.1, and hence the normalized weight is w¯1 =  w1  = 0.5 . The
next layer weight the consequent output fi(x) with the normalized firing strength. The final layer sums each weighted rule classification. Returning to the example we get f1(x)= 0.034 and f2(x)= 0.56 hence the output of the classifier is 0.5 0.034 +
0.1 0.56 = 0.122. Since the consequent part is a polynomial and the classification can be improved online using algorithms for statistical regression/adaptive filtering, e.g. Least Mean Square (LMS). We use TS-ANFIS and LMS when we can guarantee convergence for the dynamical analysis in Section 3.2.

Fuzzy set abstraction
Program analyses reason about the dynamics of the individuals of the analysis (e.g. memory stores, redundant expressions) with respect to a set of properties. The 3-valued logic analysis of Sagiv et al.[10] uses logical predicates to state when individuals possess a property, and logical formulas to model how statements up- date predicates. Their framework relies on first-order 3-valued Kleene logic with transitive closure and bi-lattice theory [4], where inference values are ordered both according to a information order and a truth order. The framework crucially en- ables summarizing predicates over a potentially infinite number of individuals and interpretations in a concrete semantics to a finite, tractable program analysis.
Our interest in increasing the precision of analyses and incorporating dynamic information leads us to consider analyses where individuals can possess properties to a certain degree. To this end we use a family of fuzzy logics.
One of the simplest forms of fuzzy logics is Kleene’s 3-valued logic as used by Sagiv et al.[10] which we get by restricting the min-max fuzzy logic to three

values. We will therefore use their program analysis framework as a basis for our own fuzzy set abstraction which is described in Section 3.1. Although analyzes in our framework are decidable and sound the resulting abstract description could, in the worst-case, be very large. Therefore we also consider cases where the resulting description is kept to a minimum. Analyses in this approximation yield a single interpretation representing the maximum interpretation.
Static analysis
Similar to Sagiv et al.[10] we start with a given set of predicates, a vocabulary, P =
{p1, ..., pn}. A program statement, which defines the new state for each property of each individual, is modeled as a predicate transformer, i.e. a logical formula over P that transforms a predicate into a new predicate.
Definition 3.1 Let P be a vocabulary. A program statement is a set of predicate transformers, one for each predicate p ∈ P. A predicate transformer is described by a logical formula φ from the grammar below. A Flow graph is a edge-labeled connected graph G = V ∪ {vstart}, E, C where vstart is the unique start node with zero in-degree, nodes v ∈ V are program statements, edges e ∈ E ⊂ V × V denote control transfer between two vertices and C maps an edge to its control transfer condition.
⟨φ⟩ ::= ⊥ | T | p(v1, ..., vk) | ¬φ | φ ∧ φ | φ ∨ φ | ∀v : φ | ∃v : φ | TCv1, v2 : φ
The concrete semantics defines the set of possible 2-valued logical structures that satisfy a predicate transformer. The semantics of a formula is defined in the standard way for 2-valued logics with transitive closure.
Definition 3.2 [Sagiv et al.[10], def. 3.2] Let US be a universe of individuals and
P = P1 ∪ P2... ∪ Pk a set of unary, binary,..., k-ary predicates.
2-valued interpretation is a structure S = US, iS where iS(p∗) is a map from US ∗ to a truth value (i.e., 0 or 1), p∗ ∈ P∗. The set of 2-valued interpretations is denoted 2-STRUCT [P].
An assignment ZS is a mapping from variables to individuals, i.e. Z : V ≤→
US. The assignment is complete if Z is total.
The free variables of a formula φ is defined in the standard way. If free(φ)= ∅ we say φ is a closed formula.
2-valued meaning [[φ]]S(Z) of a closed formula φ and a complete assignment
Z yields a truth value and defined inductively in Figure 2 (left)
S and Z satisfy φ if [φ]]S(Z) = 1. We denote this by S, Z |= φ, or S |= φ if φ
is satisfied for all Z.
A statement updates each property (of each individual) according to a prede- fined transfer function. The semantics of a statement should hence generate new predicates, defined in terms of the predicates of its predecessors.
Definition 3.3 [Sagiv et al.[10], def. 3.3] Let P = P1 ∪P2 ∪ ...Pk be a vocabulary

[[⊥]]S (Z)=0 
[[T]]S (Z)=1 
[[¬φ]]S (Z)=1 — [[φ]]S (Z)
S [0,1]q S [0,1]q
[[¬φ]]S
(Z) = 0.0
(Z) = 1.0
(Z) = ¬˜ [[φ]]S



(Z) 

[[p (v1, ..., vk) ]]S (Z)= iS (p) Z(v1), ..., Z(vk) 
[[p (v1, ..., vk) ]]S	(Z)= iS (p) Z(v1), ..., Z(vk) 


[[φ1 ∧ φ2]]S (Z)= min [[φ1]]S (Z), [[φ2]]S (Z) 
[[φ1 ∧ φ2]]S	(Z)= ∧˜ [[φ1]]S
(Z), [[φ2]]S
(Z) 

[[φ1 ∨ φ2]]S (Z)= max [[φ1]]S (Z), [[φ2]]S (Z) 
[[φ1 ∨ φ2]]S	(Z)= ∨˜ [[φ1]]S
(Z), [[φ2]]S
(Z) 

[[∀v : φ]]S (Z)= minu∈US [[φ]]S Z[v '→ u] 
[[∀v : φ]]S	(Z)=  ∧˜ [[φ]]S
 Z[v '→ u] 

[[∃v : φ]]S (Z)= maxu∈US [[φ]]S Z[v '→ u] 
[[∃v : φ]]S	(Z)=  ∨˜ [[φ]]S
 Z[v '→ u] 

2	2
[[TC v1, v2 : φ]]S (Z)= 
[0,1]q
[[TC v1, v2 : φ]]S
u∈US
(Z) = 
[0,1]q

2
n−1

S ⎛⎝
 v1 '→ ui
 ⎞⎠
[0,1]q
n−1
S



⎛⎝  v1 '→ ui
 ⎞⎠

Z(v1)= u0
Z(v2)= un
Z(v1)= u0
Z(v2)= un


Fig. 2. Definition of the semantics of classical first-order logic with transitive closure (left) and first-order fuzzy logic with transitive closure over the congruence domain [0, 1]q (right)


of unary, binary,... k-ary predicates, let φw
be the formula with free variables

v1, ..., vx which updates predicate p at statement w. Given a structure S we define
the semantics of S after w as
[[st(w)]] (S)= US,  k	λp ∈ Pxλu1, ..., λux.[[φw]]S([v1 ≤→ u1, ..., vx ≤→ ux]) .
The 2-valued semantics define the (possibly infinite) set of logical structures that a node may see on entry. The collecting semantics is later defined as the least fixed-point of the 2-valued semantics.
Definition 3.4 Let VS map v ∈ V to a set of 2-valued logical structures. The 2-valued semantics of a flow graph G = ⟨V, E, C⟩ is given by


[[G]]
2(V S)= λv.
⎪
 [[st(w)]] (S)|S ∈ V S(w) and S |= C(w, v)} otherwise

⎩ w→v∈E	2
The natural order on [0, 1] has infinite height, hence includes infinite chains. Fix- point iteration in such a domain may not terminate. Widening operators solve this problem by traversing the domain in a finite number of steps, e.g. by a sequence of jumps in the domain followed by the top/bottom element. However, its very hard to control the degree of over-approximation introduced by a widening operator. Rather than introducing a widening operator we let our fuzzy abstraction use a finite congruence domain of the unit interval. To trade expressiveness for tractability, or vice versa, we define the abstract semantics over a family of congruence domains over [0, 1]: the ϵq domains, where q ∈ N − {0}. The domains are linearly ordered such that a truth value t in ϵq is split to two truth values (not including 0.5) in ϵq+1. We illustrate the congruence relation in Figure 3 for the ϵ1 (i.e., 3-valued Kleene logic used by Sagiv et al.[10]), ϵ2 and ϵ3. The values in the light gray box of ϵ2 (i.e. 1/4, 1/2 and 3/4) are therefor mapped to 1/2 in ϵ1 and similarly the dark gray boxes of ϵ3 denote sets of values that are mapped to a single value in ϵ2. The congruence






1

2


0
є1-domain
(3-valued logic)

є2-domain

є3-domain


Fig. 3. Equivalence partitioning of the є1, є2 and є3 graded truth orders


relation is consistent with the information order introduced in Section 2, i.e., when interpreting a ϵq+1 value in a ϵq domain the value is never more informative.
Definition 3.5 The ϵq equivalence class of x ∈ [0, 1], denoted [x]q, is defined by
rounding x to the closest multiple of  1 towards 1 . The set of all ϵq equivalence
classes is [0, 1] = {  1 x|x ∈ N q } where N q = x | x ∈ N ∧ 0 ≤ x ≤ 2q}.

The abstract semantics over ϵq is defined in terms of the fuzzy logics from Section 2. The definition uses concepts such as interpretation and assignment which is similar to that of the concrete semantics but where truth value is now an element of [0, 1]q rather than {0, 1}.
Definition 3.6 [Sagiv et al.[10], def. 4.2] The [0, 1]q-valued interpretation and assignment is analogous to the concrete semantics.
Given a Fuzzy logic ∧˜, ∨˜, ¬˜ the fuzzy ϵq meaning [[φ]]S	(Z) of a closed
formula φ and a complete assignment Z yields a truth value in [0, 1]q and defined inductively in Figure 2 (right)
The definition of the semantics of a statement (i.e., [st(w)]][0,1]q ) is analogous to the concrete case in Definition 3.3 but the formulas are interpreted in a given fuzzy logic.
S and Z potentially satisfy φ if [φ]]S	(Z) > 0. We denote this by S, Z |=[0,1]
q
φ, or S |=[0,1]q φ if φ is satisfied for all Z.
Embeddings was introduced by Sagiv et al.[10] to relate 2-valued and 3-valued inter- pretations. Informally they relate logical structures that conform to an information order. The embeddings cluster individuals and decide the value of their properties in terms of the corresponding values of the members of the cluster. Importantly, the class of embeddings that minimize information loss is termed tight and are used to define the abstract semantics of a flow-graph. Note that although we choose to cluster individuals here it is also possible to cluster predicates[7] as in a predicate abstraction.
Definition 3.7 Let S = US, iS	j	S′  S′  be two [0, 1] -interpretations.
A surjective function f : US → US′ is a ≤-embedding (denoted by S ≤ƒ Sj) if it

satisfies below relation. The embedding is tight if the relation holds for equality.

∀x ∈ [1, k], ∀p ∈ Px : S′	j
j  ≥	 
iS(p)(u , ..., u )

i  (p)(u1, ..., ux)
1	x
(u1, ..., ux) ∈ (US)x
f (ui)= uj, 1 ≤ i ≤ x

The abstract semantics need to preserve information loss to be conservative (i.e. should not spuriously introduce more precise results). For this reason our abstract semantics is monotonically increasing with respect to an information order ≤.

Lemma 3.8 (Sagiv et al.[10], Lemma 4.4) Let S = US, iS 
and Sj
=  U
S′ , iS′ 

be two structures where S = Sj and let f : US → US′ be a ≤-embedding. Then for

every complete assignment Z, all k-arity p ∈ Pk: iS ≤ iS′ ⇒ [[φ]]S
S′
[0,1]q

where iS ≤ iS′ is the point-wise extension of ≤.
Intuitively, given a finite number of individuals (predicates) we should be able to cluster (even an infinite number of) predicates (individuals) into a finite number of clusters such that all predicates (individuals) in a cluster are equivalent with respect to the individuals (predicates). We refer to this special embedding as normaliza- tion 6 . More specifically the number of clusters from the normalizer is bounded by
|US′ |≤ (1 + 2q)Σk  |ri|i in a [0, 1]  domain.
Definition 3.9 Let P = P1 ∪ ... ∪ Pk be the sets of unary (P1), ..., k-ary (Pk) predicates. Two individuals ui, ui ∈ US, ui /= uj are equivalent if all predicates evaluate to the same values for ui and uj, i.e. if ∀p ∈ P1 : p(ui) = p(uj) and
∀p ∈ P2, uj ∈ US : [p(ui, uj)= p(uj, uj)] ∧ [p(uj, ui)= p(uj, uj)] and analogously for all Pi, 3 ≤ i ≤ k. The normalizer fNorm is a ≤-embedding that generates a new logical structure  UˆS ,ˆiS  that maps equivalent individuals from US to the same
individual in UˆS .
Example 3.10 Let S = {u1, u2, u3, u4, u5, u6}, iS  be as in left most table be- low. Here u2, u4 and u6 are equivalent w.r.t all predicates (i.e., p, q and r). Shown in the right most table below is the resulting structure when applying the nor-
malizer, where equivalent individuals are represented by a new individual u246.
	
Using normalization we can hence produce a logical structure with a finite num- ber of individuals, and by extension, bound the number of logical structures. We

6 Sagiv et al.[10] refer to this as the canonical abstraction

also consider the extreme case of normalization, when the set of logical structures is a singleton. To accommodate both cases we parameterize the abstract semantics on a function Fn, the collector function that takes n sets (representing the results from n incoming edges) of logical structures and produce a single set of logical structures. We consider the following F∗ and ≤∗ combinations:

(n ≥ 1) The bounded union semantics with ≤∪ and Fn(S)= 
n
Si.

(n = 1) The maximum semantics with ≤H and
i=1

Fn(S)= U Sˆ, k	{λu1, ..., λux.    n	iSy (p) [v1 ≤→ u1, ..., vx ≤→ ux] |p ∈ Px} .
We introduce an abstract semantics as the fixed-point, with respect to set-inclusion (when n is bounded) or the information order (when n = 1) from Section 2.2, of the equation system below and show that it over-approximates the collecting semantics.
Definition 3.11 Let Fn be a collector function and f be a tight ≤∗-embedding and VS map v ∈ V to a set of bounded [0, 1]q-valued logical structures. The [0, 1]q- valued semantics of a flow graph G = ⟨V, E, C⟩ is given by
⎧⎪ F 1 V S(vstart)	v = vstart

[[G]][0,1]q (V S)= λv. ⎪⎨ Fn ⎛⎜⎧⎪⎨f [[st(w)]]

S ∈ V S(w) and
⎫⎪⎬
⎞⎟ otherwise

⎪⎪⎩
∗ ⎜⎝⎪⎩
[0,1]q
 S |=

[0,1]q
C(w, v) ⎪⎭
w→v∈E ⎟⎠

Computing the fixed-point proceeds by iteratively applying a monotonic increas- ing transfer function and terminates in bounded time because the set of possible logical structures is bounded. The result of the analysis is sound as per Theorem
3.12. Note that the result of a fuzzy set abstraction using Fn is the most accurate

maximum logical structure a ϵq
true value.
domain can provide, i.e. within a factor  1
of the

Theorem 3.12 For a flow graph G = ⟨V, E, C⟩ and initial assumptions Sentry =
{S0, ..., Sn}⊂ [0, 1]q-STRUCT [P],n ∈ N the collecting semantics of the flow graph is denoted C and is deﬁned using the 2-valued semantics:
C = lfp⊆[[G]]2({vstart → Sentry}∪ {v → ∅|v ∈ V -{vstart})
The abstract semantics with the bounded union- and the maximum collector func- tions is similarly deﬁned using [0, 1]q-valued semantics:


AF∪
= lfpF∪ [[G]]

[0,1]q
({vstart → Sentry}∪ {v → ∅|v ∈ V -{vstart})

AFH
= lfpFH [[G]]

[0,1]q
({v

start
→ Fn(S

entry
1
)}∪ {v → |v ∈ V -{v
2
start})

 
where	=	US,

{λu1, ..., ux.iS(p)
 [v1 ≤→ u1, ..., vx ≤→ ux]
= 0.5} 

x=1 p∈rx
The corresponding concretization functions are given by γF∪ and γFH where [S]1 de- notes the interpretation of structure S in 3-valued logic, i.e. the point-wise extension

of Deﬁnition 3.5.


γF∪ γFH
(S) = {S# ∈ 2-STRUCT [P]|S# ≤H [S]1}
(⟨U, i⟩)=   U, i#  ∈ [0, 1]q-STRUCT [P] | ∀x ∈ [1, k],p ∈ Px, u1, ..., ux ∈ U :

 i(p) [v1 ≤→ u1, ..., vx ≤→ ux] − i#(p) [v1 ≤→ u1, ..., vx ≤→ ux]  ≤ !
1
With the above deﬁnitions in place we can state or main theorem: The concrete semantics is approximated by the composition of the abstract semantics and the concretization function:
C(v) ⊆	γF∪ (s)
∀v :	s∈AF∪ (v)
⎪⎩C(v) ⊆ γFH AFH (v) 

Dynamical analysis
We next explore an dynamical analysis which starts from the results of the static analysis with an ϵq domain and improves the accuracy by specializing the analysis result given a sequence of dynamical assignments of a property. The aim is to improve completeness, possibly sacrificing soundness, and compute a new fuzzy set with increased classification accuracy. The resulting fuzzy set is described implicitly by an TS-ANFIS. We consider improving the accuracy with respect to the least square error between the example(s) and the analysis results.
Our dynamical analysis instantiate an TS-ANFIS and use gradient descent (GD) to improve classification online. GD is similar to Newton’s method and so we use results from Newtonian program analysis[3] in formalizing our dynamic analysis.

Esparza et al. [3] showed that polynomials f (x) = Σi
ciφi(x) = Σi
ci #j
ai,j i,j

over ω-continuous (commutative) semirings admit fixed-points due to Kleene’s fixed-
point theorem. Since membership of a fuzzy set is an element of the unit interval [0, 1] we use the special case of polynomials over the real semiring R ∪ {∞}, +, ·, 0, 1 .
∇f = Σ ∂ƒ ei denote its gradient and Df  (x) = ∇f (ν) · x the differential of a
polynomial f . We stress that our polynomials are evaluated on a congruence do- main of the real semiring, i.e. an ϵq domain. In this article we consider the case when the resulting set of logical structures from the static analysis is a singleton, i.e., the result was computed using the maximum abstract semantics above 7 .
The logical structure, i.e. S = ⟨U, i⟩, can be considered a set of classifiers, one for each k-ary predicate p ∈ i, where the variables are assigned an individual (from U ) as input value. Given p we create a two rule TS-ANFIS where the variables x[1,k] are real-valued encodings of the individuals, e.g. the encoding ui ≤→ i.

7 It is possible to extend our scheme to an arbitrary n ∈ N by building an TS-ANFIS with 2n rules. But this obviously comes at a high cost and for lack of a better scheme we postpone formalization to future work


Table 1 Newton/GD fixed-point equation

(Rule 1) p is the fuzzy set in the premise part and f (x1, ..., xk) = 1 is the consequent polynomial.
(Rule 2) ¬˜ p is the fuzzy set in the premise part and f (x1, ..., xk) = 0 is the consequent polynomial.
The output of the initial TS-ANFIS is hence equal to the predicate p. Our dynam- ical analysis is iteratively given an example assignment x and the corresponding actual fuzzy membership y. It computes a new fixed-point when x is the input producing the expected fuzzy membership and updates the consequent polynomials f (x) based on the error. The algorithm used for rule 1 minimizes the polynomial coefficient corresponding to the constant (which were initialized to 1) and maximizes the remaining coefficients (which was initialized to 0). The polynomial for rule 2 remains constant. Table 1 shows the fixed-point equations. Note that elements of a semiring do not in general have an additive inverse, hence subtraction may seem erroneous. But as noted by Esparza et al. [3] for the particular case when the func- tion is a polynomial in a semi-ring the difference is always positive, a consequence of a generalized form of Taylors theorem. For a commutative semiring the accuracy increases exponentially with each iteration[6]. The number of elements in a ϵq do- main is 2q. Hence each iteration of our dynamical analysis produce the fixed-point in the ϵq+1 domain.
Lemma 3.13 shows that the fixed-point systems admit a solution. As all ascend- ing/descending chains are finite in an ϵq domain the sequence will, assuming x is monotonically decreasing/increasing, converge to a new consequent polynomial.
Lemma 3.13 Let f (x) be a polynomial. Then the ascending/descending sequence νi i∈N is increasing/decreasing monotonically and converges to unique least/great- est ﬁxed-point:
0 ≤ νi ≤ f +(νi) ≤ νi+1 ≤ sup≤	νj

≤
j∈N
νj ≤ νi+1 ≤ f—(νi) ≤ νi ≤ 1

The fixed-point equations admit a recursive closed-form that we state in Lemma
3.14. Our results show that we can guarantee validity in the real semiring by imposing constraints on the inputs rather than resorting to a non-negative version of the GD algorithm [1].
Lemma 3.14 Given a ⟨x, y⟩ and a polynomial f (x) let e(k)= f (x) −y for f + and

e(k)= y − f (x) for f—. We can compute f∗ using ck+1 = ck
+ 2μei(k)φ(x).

i,j	i,j
Finally, we show in Theorem 3.15 that our dynamical analysis indeed improve the analysis results for a set of examples.
Theorem 3.15 For a flow graph G = ⟨V, E, C⟩ let A : V ≤→ [0, 1]q-STRUCT [P]

be the analysis result with the Fn
abstract semantics and ⟨x, y⟩

1≤i≤N
a sequence

of examples such that ∀j : xj i+1 ≤ xj i and yi+1 ≤ yi. Then each iteration i
of the GD algorithm, applied to the example ⟨x, y⟩i, updates the polynomials such that the coefficients are non-negative and in the limit converge to a polynomial that
minimize the least square error to the set of examples.
Conclusion
We have introduced the Fuzzy Set Abstraction which enables stating properties about programs which are true or false to a certain degree. This opens up new possibilities for speculative optimizations which can now use information about which values, branches, etc. are more likely than others.
We have also shown how to perform hybrid analysis by refining the result of a static analysis online. This has been done using TS-ANFIS, an adaptive fuzzy inference system from control theory. This result paves the way for importing other results from the rich literature of fuzzy control theory.

References
Chen, J., C. Richard, J. C. M. Bermudez and P. Honeine, Nonnegative least-mean-square algorithm, IEEE Transactions on Signal Processing 59 (2011), pp. 5225–5235.
Dubois, D., H. Prade and H. Prade, “Fundamentals of Fuzzy Sets,” The Handbooks of Fuzzy Sets, Springer US, 2000.
Esparza, J., S. Kiefer and M. Luttenberger, Newtonian program analysis, J. ACM 57 (2010), pp. 33:1– 33:47.
Ginsberg, M., Multivalued logics: A uniform approach to inference in artificial intelligence, Computational Intelligence 4 (1988), pp. 265–316.
Lidman, J. and J. Svenningsson, Bridging static and dynamic program analysis using fuzzy logic, Quantitative Aspects of Programming Languages and Systems (QAPL) (2017).
Luttenberger, M. and M. Schlund, “Convergence of Newton’s Method over Commutative Semirings,” Springer Berlin Heidelberg, Berlin, Heidelberg, 2013 pp. 407–418.
Manevich, R., E. Yahav, G. Ramalingam and M. Sagiv, “Predicate Abstraction and Canonical Abstraction for Singly-Linked Lists,” Springer Berlin Heidelberg, Berlin, Heidelberg, 2005 pp. 181– 198.
Mock, M., M. Das, C. Chambers and S. J. Eggers, Dynamic points-to sets: A comparison with static analyses and potential applications in program understanding and optimization, in: Proceedings of the 2001 ACM SIGPLAN-SIGSOFT Workshop on Program Analysis for Software Tools and Engineering, PASTE ’01 (2001), pp. 66–72.
Ribeiro, C. and M. Cintra, Quantifying uncertainty in points-to relations, in: Languages and Compilers for Parallel Computing, Lecture Notes in Computer Science 4382, Springer Berlin Heidelberg, 2007
pp. 190–204.
Sagiv, M., T. Reps and R. Wilhelm, Parametric shape analysis via 3-valued logic, ACM Trans. Program. Lang. Syst. 24 (2002), pp. 217–298.

A	Omitted proofs
Proof. of Theorem 3.12. We first consider the case when using the F∪ function, Note that γ(S) creates the set of all 2-valued logical structures that are ≤∪ S,

quantized to the ϵ1 domain (i.e., the 3-valued domain in Sagiv et al.[10] by Definition 3.5). Since generating S (i.e., the fixed-point iteration) was done conservatively by Theorem 3.8 we can re-use the argument from Sagiv et al.[10] Theorem 4.9 (i.e., that

an embedding is extensive w.r.t. to the information order: [φ]]S(Z) ≤
′
[[φ]]3 (f
Z)),

Theorem 6.1 (i.e., that we are conservative w.r.t. a branch condition and program statement) and Theorem 6.2 (i.e., ∀v : C(v) ⊆  s∈A(v) γ(s)).
We next consider the case when using the FH function.  Note that, as per
Knaster-Tarskis fixed-point theorem the abstract semantics is well-defined. We ar- gue that the result is a conservative approximation (i.e., ∀v : C(v) ⊆ γFH AFH (v) ) based on proof by contradiction on the existence of a fixed-point for the collectors Fn: Assume an fixed-point S∞ has been reached then S∞(v),v ∈ V is the unique maximal element in ϵq. γFH (S∞(v)) is the set of [0, 1]q logical structures where the
predicates are within  1 from S∞(v). If S∞ is not a conservative approximation
then there exists an element S∗ /∈ γFH (S∞(v)) that is further away from γFH (S∞(v))
than  1 which contradict that S∞ is the unique fixed-point.	2
Proof. of 3.13 This is a special case of Theorem 3.10 in Esparza et al. [3] with the (non-negative) real semiring.	2
Proof. of 3.14. As the fixed-point iteration is performed over a totally ordered set (the least square error) the minimal/maximal and infimum/supremum element co-
incide. We consider finding the coefficients ci of a polynomial f (x)= Σi ciφi(x)= 
ticular ⟨x, y⟩. Since e(x)2 is convex we know that globally minimal solution occur where gradient is zero:
∂ f (x) − y 2	∂ Σ c φ (x) − y







Hence maxci
= 2 f (x) − y φ(x)
= 2e(x)φ(x)
 f (x) − y 2 = 2e(x)φ(x) and since the expression only depends on

variables in the current iteration the sequence of updates is given by ci+1 = ci +
2μe(x)φ(x). Similary minc y − f (x) 2 = −2e(x)φ(x) and hence ci+1 = ci −

Proof. of 3.15. Lemma 3.14 shows that each iteration finds the coefficients that minimize the least square error. Toghether with monotonicity of x & y and Lemma
3.13 the sequence is guaranteed to converge eventually.	2
