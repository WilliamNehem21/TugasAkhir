Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 315 (2015) 17–30
www.elsevier.com/locate/entcs

Using Binary Patterns for Counting Falsifying Assignments of Conjunctive Forms
Guillermo De Ita Luna1
Facultad de Ciencias de la Computaci´on Benem´erita Universidad Aut´onoma de Puebla Puebla, M´exico
J. Raymundo Marcial-Romero2,
Facultad de Ingenier´ıa Universidad Aut´onoma del Estado de M´exico
Toluca, M´exico
Pilar Pozos-Parra3
Divisi´on Acad´emica de Inform´atica y Sistemas Universidad Ju´arez Aut´onoma de Tabasco Tabasco, M´exico
Jos´e A. Herna´ndez4
Facultad de Ingenier´ıa Universidad Aut´onoma del Estado de M´exico
Toluca, M´exico

Abstract
The representation of the set of falsifying assignments of clauses via binary patterns has been useful in the design of algorithms for solving #FAL (counting the number of falsifying assignments of conjunctive forms (CF)). Given as input a CF formula F expressed by m clauses defined over n variables, we present a deterministic algorithm for computing #FAL(F ). Principally, our algorithm computes non-intersecting subsets of falsifying assignments of F until the space of falsifying assignments defined by F is covered. Due to #SAT(F ) = 2n-#FAL(F ), results about #FAL can be established dually for #SAT. The time complexity of our proposals for computing #FAL(F ) is established according to the number of clauses and the number of variables of F .
Keywords: #SAT, #FAL, Binary Patterns, Enumerative Combinatorics.


1 Email:deita@cs.buap.mx
2 Email:jrmarcialr@uaemex.mx
3 Email:pilar.pozos@ujat.mx
4 Email:xoseahernandez@uaemex.mx

http://dx.doi.org/10.1016/j.entcs.2015.06.003
1571-0661/© 2015 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

Introduction
The problem of counting models for a Boolean formula (#SAT problem) can be reduced to several problems in approximate reasoning. For example, estimating the degree of belief in propositional theories, generating explanations to propositional queries, repairing inconsistent databases, Bayesian inference and truth maintenance systems [4,12,13,14]. The above problems come from several AI applications such as planning, expert systems, approximate reasoning, etc.
There are many real-life problems that can be abstracted as counting combina- torial objects on graphs. For instance, reliability network issues are often equivalent to connected component issues on graphs, e.g. the probability that a graph remains connected is given by the probabilities of failure over each edge, which is essentially the same as counting the number of ways that the edges could fail without losing connectivity [13].
The combinatorial problems that we address in this paper are the computation of the number of models and falsifying assignments for Boolean formulas in Con- junctive Forms (CF), denoted as #SAT and #FAL, respectively. Both problems (#SAT and #FAL ) are classical #P -complete problems even for the restricted cases of monotone and Horn formulas. We also show that string patterns can be used as a succinct representation of the set of falsifying assignments of conjunctive formulas.
Among the class of #P-complete problems, #SAT is considered a fundamen- tal instance due to both, its application in deduction issues, and its relevance in establishing a boundary between efficient and intractable counting problems.

Literature Review
Given a 2-CF F with n variables and m clauses, it is common to analyze the computational complexity of the algorithms for solving #SAT regarding to n or m or any combination of both [14,15].
The standard strategy used to solve #SAT comes from variants of the classical Davis and Putnam (D&P) method, especially designed to solve the SAT problem. In this case, the main variant arises from reviewing the entire tree of search on the set of assignments of the formula; for example, the backtracking process has to be applied not only when a partial assignment falsifies a sub-formula, but also for assignments satisfying it. However, now a days, each variant from D&P have an exponential-time complexity [4,14].
In [6], some cases are presented where #SAT(F ) is computed in polynomial time considering the graph-topological structure of the constrained graph of F . Additionally, in [5] a new way to measure the degree of difficulty for solving #SAT is presented. It is shown that there is a threshold, determined by the same number of models, where #SAT is computed in polynomial time.
Indeed, as #SAT (F )= 2n − #FAL(F ), then #SAT (F ) can also be computed based on the computation of #FAL(F ). And it is the case that analogous results can be proved for #SAT (F ) and #FAL(F ).

One of the first works for computing #FAL was presented by Dubois [8]. Dubois’ method begins analyzing the computation of #FAL(Ci ∧ Cj) for any two pair of clauses Ci and Cj, as:
#FAL(Ci ∧ Cj)= #FAL(Ci)+ #FAL(Cj) − #FAL(Ci ∩ Cj).
Given a 2-CF F = {C1,..., Cm}, the above formula for counting unsatisfy- ing assignments can be extended, based on the inclusion-exclusion formula, as:
#FAL(F ) = | Sm  Ai|, where each Ai is the subset of assignments from the total
formula falsifying Ci, then the following equation is inferred:
m	m
#FAL = Σ |Ai|− Σ |Ai ∩ Aj | + Σ |Ai ∩ Aj ∩ Ak| + ... + −1m−1| \ Ai|	(1)

i=1
i<j
i<j<k
i=1

However, this last inclusion-exclusion formula expresses an exponential number of operations on the input m (number of clauses). Several algorithms have been designed as finer or shorter versions of (1) for computing #FAL [1,2,8,3,10,11].
For example, Lozinskii [11] analyzed the set of terms in (1) in order to reduce the number of operations to be performed. He found that two clauses with oppo- site literals determine disjoint sets of falsifying assignments; therefore his proposal consists on working with subsets of clauses of F without opposite literals.
One of the main line, appearing during the 90’s, was to approximate the compu- tation of inclusion-exclusion formulas via the calculation of a limited number of its terms. For example, Linial and Khan [10,3] have shown that the size of the union in (1) can be approximated accurately when the sizes of only a certain part of the set of intersections are known. Assuming that the intersection sizes are known for
all subfamilies containing at most k sets, if k ≥ Ω(√m), then the union size can be
approximated with an additive error of O(exp(−( √k ))).
The Bonferroni’s inequalities generalize the inclusion-exclusion principle by show- ing that truncactions of the sum at odd (even) depths give upper (lower) bounds. For example, the inclusion-exclusion sum over subsets of size at most k yields an upper bound on the overall sum if k is odd, and a lower bound if k is even. Im- provements to Bonferroni’s inequalities, either in terms of generalization or reduced computation, is prevalent in the literature [1,2].
From those pioneer works, until now, there are not concise algorithms or meth- ods establishing when #FAL can be computed in polynomial time based on the application of the inclusion-exclusion formula.
In [1], the terms in (1) are ordered via a tree exploration, where there is a node for each subset S ⊂ 2m. The inclusion-exclusion formula is performed by a search on the tree, summing the contributions of each node. An improvement on this search comes from the observation that a node S with conflicting clauses contribute nothing to the sum, and no descendant of S will ever contribute to the overall sum. Therefore, the sum is optimized by pruning any subtree whose root has conflicting clauses (null intersections).
Bennett [1] looked for the identification of terms with same cardinality but different sign; therefore, their mutual contribution to the sum is zero, meaning that

both terms would be canceled. He also applied subsumption among clauses for pruning large subtrees. He has shown by an empiric analysis, that subsumption can greatly improves the average-case performance of the inclusion-exclusion based model counting.
In order to increase the pairs of clauses with opposite literals, Dubois introduced the reduction of independence between two clauses [8]. The efficiency of this process, as he suggested, depends on the order between consecutive set of clauses, because the independence reduction is not a commutative operation.
In this paper, we present a method for computing #FAL(F ) in an incremental way with respect to the set of clauses in F . We order the clauses of the formula, taking advantages of the binary strings representing the falsifying assignments of a set of clauses. In order to accelerate the computation of #FAL(F ), we reduce the cardinality of the set of clauses to work with by applying some reductions among clauses; e.g. the application of the independent reduction rule combined with subsumed clause rule.
Our proposal also suggests the possibility of applying a primal-dual procedure for computing #SAT(F ), similar to Bonferroni’s inequalities for the inclusion-exclusion formula or the primal-dual method for linear programming, where the procedure oscillates from the number of models to the number of falsifying assignments of a subset of clauses of F , according to the smallest value between them.
The paper is organized as follows. In Section 2 we give the basic notation as well as several definitions. In Section 3 we describe the binary pattern based approach for 2-CF cases, and we extend such approach for CF cases. Section 4 provides the algorithm associated with our proposal. In Section 5, we present the conclusions of the work.

Preliminaries
Let X = {x1,..., xn} be a set of n Boolean variables. A literal is either a variable
xi or a negated variable xi. As usual, for each xi ∈ X, x0 = xi and x1 = xi.
A clause is a disjunction of different and non complementary literals (sometimes, we also consider a clause as a set of literals, e.g. x1 ∨x2 = {x1, x2}). Notice that we discard the case of tautological clauses. For k ∈ IN ,a k-clause is a clause consisting of exactly k literals. A variable x ∈ X appears in a clause c if either x or x is an element of c.
A conjunctive form (CF) F is a conjunction of non tautological clauses. We say that F is a monotone positive CF if all of its variables appear in an unnegated form. A k-CF is a CF containing only k-clauses. (≤ k)-CF denotes a CF containing clauses with at most k literals. A 2-CF formula F is said to be strict only if each clause of F consists of two literals. The size of a formula F is defined as the sum of the number of clauses and variables of F .
We use υ(X) to represent the variables involved in the object X, where X could be a literal, a clause or a CF. For instance, for the clause c = {x1, x2}, υ(c) = {x1, x2}.  Lit(F ) is the set of literals involved in F , i.e.  if X = υ(F ),



then Lit(F )= X ∪ X = {x1, x1, ..., xn, xn}. We denote {1, 2, ..., n} by [n]] and the cardinality of a set A by |A|.
An assignment s for F is a function s : υ(F ) → {0, 1}. An assignment s can also be considered as a set of literals without a complementary pair of literals, e.g., if l ∈ s, then l /∈ s, in other words s turns l true and l false or viceversa. Let c be a clause and s an assignment, c is satisﬁed by s if and only if c ∩ s /= ∅. On the other hand, if for all l ∈ c, l ∈ s, then s falsifies c. If n = |υ(F )|, then there are
possible assignments defined over υ(F ). Let S(F ) be the set of 2 assignments defined over υ(F ).
Let F be a CF, F is satisﬁed by an assignment s if each clause in F is satisfied by s. F is contradicted by s if any clause in F is falsified by s. A model of F is an assignment for υ(F ) that satisfies F . A falsifying assignment of F is an assignment for υ(F ) that contradicts F . The SAT problem consists of determining whether F has a model. SAT(F ) denotes the set of models of F , then SAT(F ) ⊆ S(F ). The set FAL(F )= S(F ) \ SAT (F ) consists of the assignments from S(F ) that falsify F . The #SAT problem (or #SAT(F ) problem) consists of counting the number of models of F defined over υ(F ), while #FAL(F ) denotes the number of falsifying assignments of F . Thus, #FAL(F )= 2n- #SAT(F ) and #2SAT denotes #SAT for
2-CF formulas.
A 2-CF F can be represented by an undirected graph, called the constrained graph of F , and determined as: GF = (V (F ), E(F )), where V (F ) = υ(F ) and E(F )= {{υ(x), υ(y)} : {x, y} ∈ F}. I.e. the vertices of GF are the variables of F , and for each clause {x, y} in F there is an edge {υ(x), υ(y)}∈ E(F ).
The neighborhood for x ∈ V (F ) is N (x) = {y ∈ V (F ) : {x, y} ∈ E(F )} and its closed neighborhood is N (x) ∪ {x} denoted as N [x]. The degree of a variable x, denoted by δ(x), is |N (x)|, and the degree of F is Δ(F )= max{δ(x): x ∈ V (F )}. The size of the neighborhood of x, δ(N (x)), is δ(N (x)) =  y∈N (x) δ(y).
An algorithm to compute #SAT (F ) considers the set of connected components
of its constrained graph GF . It has been proved that the set of connected compo- nents of a constrained graph can be determined in linear time with respect to the number of clauses in the formula.
Thus, #SAT (F )= #SAT (GF )=  k	#SAT (Gi), where {G1,..., Gk} is the
set of connected components of GF [12].
The set of connected components of GF conforms a partition of F .
So, from now on, we will work with a formula F represented by just one con- nected component.
Computing #FAL via Binary Patterns
Let F = {C1, C2,..., Cm} be a strict 2-CF (each clause has length 2) and let n = |υ(F )|. The size of F is n + m. Let k be a positive integer parameter such that k < 2 . The values of k, where #SAT(F ) = k can be determined in polynomial time, is given by the following cases.
If k =0 or k = 1, the Transitive Closure procedure presented in [9] can be applied

for determining if #SAT(F )= k. Such procedure has a linear time complexity on the size of the 2-CF.
If k is upper bounded by a polynomial function on n, e.g. k ≤ p(n), then in [5], an exact algorithm was shown for determining when #SAT(F )= k, and such algorithm has a polynomial time complexity on the size of F .
So, the hard cases to answer whether #SAT(F ) = k are given when k > p(n). In [7], several hard cases for solving #SAT(F ) are identified. Such identification depends on the relation between its number of clauses (m) and the variables (n) of the instances F . For example, some of the proved cases were:
If F = {C1, C2,..., Cm} is a 2-CF, with n = |υ(F )|, the hard cases to answer whether #SAT(F )= k, are given when m > n [7].
Lemma 3.1 Let F = {C1,..., Cm} be a 2-CF and n = |υ(F )|, if F is not a tautology then #FAL(F ) ≥ 2n−2 or the number of falsifying assignments is at least 2n−2.
Proof. Let C = (li, lj) be a clause of F and s a falsifying assignment of C. As we assume that C is not a tautology then υ(li) /= υ(lj), and as s falsifies C then li ∈ s and lj ∈ s. So two of the n positions in the assignment have fixed values, and there are n − 2 different variables that can be assigned any truth value. That means that there are 2n−2 possible assignments that falsify C. Hence, from the 2n assignments, 2n−2 are falsified by C. Thus, #SAT (F ) is not bigger than 2n − 2n−2.	2
It is known that for any pair of clauses Ci and Cj, it holds that #FAL(Ci∪Cj)= #FAL(Ci)+ #FAL(Cj) − #FAL(Ci ∩ Cj) [8]. The following lemmas show when the number of models can be reduced.
Lemma 3.2 Let F be a 2-CF, n = |υ(F )|. If Ci ∈ F and Cj ∈ F, i /= j have non-complementary pairs of literals, but they share a literal (e.g. Ci ∩Cj /= ∅), then there are exactly 2n−2 + 2n−3 assignments from S(F ) falsifying Ci ∪ Cj.
Proof. Since Ci ∩Cj /= ∅ the elements Ai and Aj have a same value in the common literal (e.g. Ai ∩ Aj = ∗ ... ∗ 0 ∗ ... ∗ 0 ∗ ... ∗ 0 ∗ ... ∗) which represent 2n−3 assignments. That means that 2n−2 + 2n−2 − 2n−3 = 2n−1 − 2n−3 assignments from S(F ) are falsified.	2
In our algorithmic proposal, we have used binary patterns in order to represent the set of falsifying assignments of any clause defined on n variables. Those patterns allow us to design procedures for computing #FAL(F ).
Let F = {C1,.	, Cm} be a 2-CF and n = |υ(F )|. Assume an enumeration over
the variables of υ(F ), e.g. x1, x2,.  , xn. For each clause Ci = {xj, xk}, let Ai be a
set of binary strings of length n such that the values at the j-th and k-th positions of each string, 1 ≤ j < k ≤ n, represent the truth value of xj and xk that falsifies Ci. E.g., if xj ∈ Ci then the j-th element of Ai is set to 0. On the other hand, if xj ∈ Ci then the j-th element of Ai is set to 1. The same argument applies to xk. It is easy to show that if Ci = {xj, xk}, then xj and xk have the same values in each string of Ai in order to be a falsifying assignment of F . Those variables not

contained in the clause can take any truth value since the clause has been already falsified.
Example 3.3 Let F = {C1, C2} be a 2-CF and |υ(F )| = 3. If C1 = {x1, x2} and
C2 = {x2, x3} then A1 = {000, 001} and A2 = {000, 100}.
We will use the symbol ∗ to represent the variables that can take any truth value in the set Ai, e.g. if F = {C1,..., Cm} is a 2-CF, n = |υ(F )|, C1 = {x1, x2} and C2 = {x2, x3} then we will write A1 = 0`0 ∗˛∗¸... ∗x and A2 = `∗00 ˛∗¸... ∗x. This
abuse of notation will allow us to present a concise and clear representation in the rest of the paper, for considering the string Ai as a pattern formed from {0, 1, ∗} symbols, and which gives a succinct notation for representing the set of falsifying assignments for any clause Ci.
We define a falsifying string as a binary pattern Ai which represents the set of falsifying assignments of Ci. Let F = {C1,..., Cm} be a 2-CF, n = |υ(F )|, we denote by Fals String(Ci) the procedure which constructs the falsifying string (with n symbols) of Ci. Given a falsifying string Ai, the positions where 0 or 1 appear in Ai are called the fixed values of the string, while the positions where the symbol ∗ appears are called the free values of the string. We define the string representing the null clause as the full string: `∗ ∗˛.¸.. ∗x.

Lemma 3.4 [7] Let F be a 2-CF, n = |υ(F )|. If Ci ∈ F and Cj ∈ F, i /= j contain a complementary pair of literals, that is xk ∈ Ci and xk ∈ Cj, the falsifying set of assignments Ai and Aj of Ci and Cj respectively, forms a disjoint set of falsifying assignments. Consequently, both clauses suppress exactly 2n−2 + 2n−2 = 2n−1 assignments from S(F ).
We propose to generalize the previous definitions and results to any CF and then consider #SAT and #FAL problems for CF formulas in general, not only for the 2-CF case. We consider now any CF without restriction on the length of its clauses.
Definition 3.5 [8] Given two clauses Ci and Cj, if they have at least one com- plementary literal, it is said that they have the independence property. Otherwise, we say that both clauses are dependent.
Definition 3.5 can be written in terms of falsifying strings as follows:
Definition 3.6 Given two falsifying strings A and B both of the same length, if there is an i such that A[i]= x and B[i]= 1 −x, x ∈ {0, 1}, it is said that they have the independence property. Otherwise, we say that both strings are dependent.
Definition 3.7 Let F = {C1, C2, ··· Cm} be a CF. F is called independent if each pair of clauses Ci, Cj ∈ F, i /= j, has the independence property, otherwise F is called dependent.

Let F = {C1, C2, ··· Cm} be a CF, n = |υ(F )|. Let C be a clause in F and
x ∈ υ(F ) \ υ(C) be any variable, we have that
C = (C V x) Λ (C V x)	(2)
Furthermore, this reduction preserves the number of falsifying assignments of C with respect to F , since #FAL(C)= 2n−|C| = 2n−(|C|+1)+2n−(|C|+1) = #FAL((CV x) Λ (C V x)), because (C V x) Λ (C V x) are two independent clauses. In terms of falsifying strings, let F = {C1, C2,... Cm}, n = |υ(F )|, if A is the falsifying string of a clause Cj such that there is an index i, A[i]= ∗ then the falsifying string A can be replaced by two falsifying strings say A1 and A2 as follows:
A1[j]= A[j] if j /= i and A1[j]=1 if j = i.
A2[j]= A[j] if j = i and A2[j]=0 if j = i.
It is easy to show that the falsifying assignments represented by A with respect
to F are equal to the sum of the falsifying assignments represented by A1 and A2
with respect to F .
Given a pair of dependent clauses C1 and C2. Let us assume that there are literals in C1 which are not in C2, let x1, x2, ..., xp be these literals. There exists a reduction to transform C2 to be independent with C1, we call at this transformation the independent reduction, and this works as follows: By (2) we can write: C1 ΛC2 = C1 Λ (C2 V чx1) Λ (C2 V x1). Now C1 and (C2 V чx1) are independent. Applying (2) to (C2 V x1):
C1 Λ C2 = C1 Λ (C2 V чx1) Λ (C2 V x1 V чx2) Λ (C2 V x1 V x2)
The first three clauses are independent. Repeating the process of being inde- pendent between the last clause with the previous ones, until xp is considered, we have that C1 Λ C2 can be written as:
C1 Λ(C2 Vчx1) Λ(C2 Vx1 Vчx2) Λ...Λ(C2 Vx1 Vx2 V...Vчxp) Λ(C2 Vx1 Vx2 V...Vxp).
The last clause contains all literals of C1, so it can be eliminated because it is subsumed by C1, and then

C1 Λ C2 = C1 Λ (C2 V чx1) Λ (C2 V x1 V чx2) Λ ... Λ (C2 V x1 V x2 V ... V чxp) (3)
We obtain on the right hand side of (3) an independent set of p + 1 clauses. Let us present the independent reduction transformation in terms of falsifying strings. Given a pair of falsifying strings A and B. Let us assume that there are indices x1, x2, ..., xp such that A[xi] = 1 or A[xi] = 0 and B[xi] = ∗, for all i ∈ [[p]]. There exists a reduction to transform B to be independent with A, we call at this transformation the independent reduction, and this works by replacing the falsifying
string B by p falsifying strings say B1, B2,... Bp as follows:
B1[i]= B[i] if i /= x1 and B1[i]=1 — A[i] if i = x1.
B2[i] = B[i] if i /= x1 and i /= x2, B2[i] = A[i] if i = x1 and B1[i] = 1 — A[i] if
i = x2.
··· 

Bp[i] = B[i] if i /= xj,j ∈ [[p]] and Bp[i] = A[i] if i = xj,j ∈ [[p — 1]], and
Bp[i]=1 — A[i] if i = xp.
We will denote the independent reduction between two clauses C1 and C2 or be- tween their corresponding falsifying strings A and B as: reduc(C1, C2) or reduc(A, B), respectively. Notice that the independent reduction is not commutative, in the sense that reduc(C2, C1) builds an independent set of |Lit(C2) — (Lit(C1) ∩ Lit(C2))| clauses, while reduc(C1, C2) builds an independent set of |Lit(C1) — (Lit(C1) ∩ Lit(C1))| clauses. However, reduc(C1, C2) and reduc(C2, C1) are logically equiva- lent because they determine the same set of falsifying assignments. Furthermore, when (Lit(C1)—(Lit(C1)∩Lit(C2))) = ∅ then the set of falsifying assignments of C2 is a subset of the set of falsifying assignments of C1, that is, FAL(C2) ⊆ FAL(C1), and then reduc(C1, C2)= C1.
Independence reductions containing the smallest number of clauses can be formed by computing both |Lit(C1)—(Lit(C1)∩Lit(C2))| and |Lit(C2)—(Lit(C1)∩Lit(C2))| or if we are working with falsifying strings by computing the set of indices {i | A[i]= 1 or A[i]=0 and B[i]= ∗} and {i | B[i]=1 or B[i]=0 and A[i]= ∗}. The set with the smallest cardinality can be chosen to be reduced.
For formulas in CF, a pair of dependent clauses has either at least one common literal or not variables in common.
Let Ci, Cj be two dependent clauses with at least one common literal, in a CF F with n variables. Let A and B the falsifying strings of Ci and Cj. That A and B are dependents with at least one common literal means that the following conditions hold:
if A[i]= x then B[i] /=1 — x for all i ∈ [[n]],
there is a non-empty set of indices xj such that A[xj]= B[xj] and
there is a set of indices xj such that (A[xj]=0 or A[xj]=1 and B[xj]= ∗) or (B[xj]=0 or B[xj]=1 and A[xj]= ∗).
Example 3.8 The following table shows two falsifying strings of two dependent clauses with a common literal

The application of reduc(A, B) modifies the string B as follows

Lemma 3.9 Let Ci, Cj be two dependent clauses with no common literals, in a formula F with n variables. The number of falsifying assignments for this pair of clauses is:
2n−|Ci| + Σ|Ci| 2n−|Cj |−i
i=1

Proof. By applying |Ci|-times the independent reduction on Ci and Cj.	2
Example 3.10 Let Ci, Cj ∈ F , where Ci = (x1 V x2) and Cj = (x3 V x4) are dependent clauses. By lemma 3.9, #F AL(Ci Λ Cj) = 2n—2 + 2n—3 + 2n—4. The transformation to obtain independent clauses can be applied over Cj as (x1 V x2) Λ (x3 V x4)= (x1 V x2) Λ (x1 V x3 V x4) Λ (x1 V x2 V x3 V x4).
Lemma 3.11 For any independent formula F = {C1,..., Cm} involving n vari-

ables, #FAL(F )= Σm
2n—|Ci|.

Corollary 3.12 If F is an independent k-CF then #FAL(F )= Σm
2n—k.

F is a contradiction when #FAL(F )= 2n, then all k-CF with at least 2k inde- pendent clauses will be a contradiction.
Furthermore, let F be a CF, n = |υ(F )| and F is not necessarily an independent formula. Let C be an independent clause with each clause of F , based on the iterative application of lemma 3.4, it holds
#FAL(F Λ C)= #FAL(F )+ 2n—|C|	(4)
Then, the independent reduction determines a procedure to compute #FAL(F Λ C) when #F AL(F ) has already been computed. The procedure consists of applying the independent reduction on C and the clauses in F involving the variables υ(C) until we build a new set of clauses Cj which will be independent with each clause Ci ∈ F . where υ(C) ∩ υ(Ci) /= ∅ and then #FAL(F Λ C) = #FAL(F Λ Cj) = #FAL(F )+ #FAL(Cj).
For example, let F = {{x1, x2}, {x3, x2}, {x4, x3}, {x4, x5}, {x5, x6}}. #FAL(F ) can be computed incrementally using the falsifying strings of the clauses of F . The matrix of Table 1 represents the falsifying string of each clause.

Table 1
The falsifying strings for the clauses in F

Clauses C1 and C2 are independent so no reduction is needed between those clauses. The clause C3 is not independent with C1, even more, this pair of clauses does not have a common literal hence the independent reduction has to be applied either to C1 or C3. Applying it to C3 we obtain the strings of Table 2.
Now, the four clauses are independent each other. Consider now C4 whose falsifying string is ∗ ∗ ∗00∗. Again it is not independent with C1, applying the


Table 2
The falsifying strings after applying the independent reduction between C1 and C3.

Table 3
The falsifying strings after applying the independent reduction between C1 and C4.

independent reduction rule we obtain the strings of Table 3.
Both C4—11 and C4—12 are independent with C1. The new clauses have to be checked to be independent with the rest of the clauses. It can be noticed that the new clause C4—11 is not independent with the clause C2 so the procedure is repeated until each clause in F is independent with each other. The independent reduction application gives the results shown in Table 4.
From lemma 3.11, #FAL(F )= Σ10 2n—|Ci| = 24 + 24 + 23 + 22 + 22 + 20 + 20 +
20 + 20 + 20 = 53. Then, #SAT(F )= 2n — #FAL(F )= 64 — 53 = 11.
Reducing the sizes of CF’s
The size reduction of CF’s formulas is a relevant task in order to build efficient algorithms with the aim of check #FAL(F ). In order to reduce the number of clauses while applying the independent reduction principle, the following rule can be applied.

Subsumed clause Rule.
Given two clauses Ci and Cj of a CF F , if Lit(Ci) ⊆ Lit(Cj), then Cj is subsumed by Ci, and then Cj can be deleted from F .
Namely, all satisfying assignments of Cj are satisfying assignments of Ci: SAT(Cj) ⊆
SAT(Ci). Thus, it is enough to keep Ci (the clause which subsumes) in the CF. In


Table 4
The falsifying strings after applying the independent reduction between C1 and C4.

terms of falsifying strings.
Definition 3.13 Let A and B be two falsifying strings of length n. It is said that B subsumes A if there is a set of indices I = {i1,..., ik}⊂ {1,..., n} such that the following conditions hold:
∀i ∈ I, (A[i]=0 or A[i] = 1) and B[i]= ∗
∀j ∈/ I, j ∈ [[n]], A[j]= B[j].
The subsumed clause rule requests that each falsifying string will be compared with the rest in the Table of falsifying strings in order to find a subsumed clause, if it exists. That implies the order of O(n · m2) basic operations in the worst case.

An Incremental Computation for #FAL
Given F (n, m) a CF, Algorithm 1 computes #SAT (F ) based on the computation of #FAL(F ). We start with the first clause C1 ∈ F , and continue adding the following clause making it independent with the previous processed clauses, until all the original clauses in F are processed. Furthermore, if we know the value for #SAT (F ) then we can also determine if F is (or not) satisifiable.
The procedure Simplify(Ti) works on a set of falsifying strings Ti, looking for pair of strings representing subsumed clauses in order to delete the string corre- sponding to the subsumed clause. The procedure Simplify(Ti) keeps or reduces the cardinality of the set of strings Ti. As Simplify(Ti) involves to compare each falsifying string A with the following strings in Ti, it has a time complexity of O(n · |Ti|2).



Algorithm 1 Procedure #Falsifying(F )
Input: A CF F with m clauses and n variables Output: (True /False )= (SAT (F )=  or not)
Simplify(F ); delete all subsumed clause m = F ; count the new number of clauses for all Ci	F do
Ai = Fals String(Ci);

end for
T1 = A1;  Begin the table of falsifying strings for F
for all i =2 to m do
Ti = reduc(Ai, Ti−1); Apply independent reduction
Simplify(Ti);  delete all subsumed clause
if (Ti has a full string) then
Returns 0 (F ‘is unsatisfiable’); Fals(F ) cover all the assignments
end if end for
Ct = Count Falsifyings(Tm);  Count number of falsifying assignments
if ((2n	Ct) > 0) then
Returns Ct (F ‘is satisfiable’);
else
Returns 0 (F ‘is unsatisfiable’);
  end if	
The procedure Count Falsifyings(Tm) counts the number of falsifying assign- ments of an independent set of clauses represented by the set of falsifying strings Tm. This computation is done in time O(|Tm|).
Furthermore, the function Count Falsifyings can be performed into the body of the main loop of the procedure #Falsifying(F ) in order to detect any minimum unsatisfiable subset of clauses of F .
The total time complexity of our proposal is polynomial on n and on the size of the falsifying table Ti. Then, we have to compute the growing size of the set Ti when each new falsifying string Aj is processed into the loop of #Falsifying(F ). Of course, a non-tight upper bound for |Tm| is #FAL(F ) itself, because at most each falsifying string can have n fixed values and there are at most #FAL(F ) falsifying strings in Tm. However, the representation of each FAL(Ci), Ci ∈ F by a falsifying string guarantees that it is not needed to express in an exhaustive way the set FAL(Ci).
For formulas F , whose number of falsifying assignments is bounded by a poly- nomial on the size of F , our algorithm computes #FAL(F ) in a polynomial time- complexity on the size of F ; therefore, the value #SAT(F ) = 2n— #FAL(F ) too. Furthermore, Count Falsifyings is an effective procedure when subset of falsifying assignments of F are represented by a reduced number of fixed variables into the set of variables of υ(F ), in such a way that the codification of such subset is effective via falsifying strings.
Our proposal suggests the possibility to use a primal-dual method for computing #SAT(F ), where the computation of #SAT(F ) oscillates from the number of models to the number of falsifyng assignments of subsets of clauses of F , according to the smaller value between them.

Conclusions
Given as input a CF F expressed by m clauses defined on n variables, we have shown a deterministic algorithm for computing #FAL(F ). Our method is incremental on

the set of clauses of F . We use a short notation to represent the set of falsifying assignments of clauses using string patterns. And we show how to manipulate such strings to form the set of falsifying assignments of a conjunctive formula.
We begin computing excluded subsets of falsifying assignments of F until the whole space of falsifying assignments defined by F is covered. Due to #SAT(F )= 2n-#FAL(F ), results about #FAL can be established dually for #SAT. Some reduc- tions in our procedure are used, as subsumed clauses and the independent reduction involving dependent clauses, in order to accelerate the computation of #FAL(F ).

References
Bennett H., Results on Extensions of the Satisfiability Problem, Thesis of Master degree, Computer Sc. Dept., University of Colorado, (2012).
K. Dohmen, Improved Bonferroni Inequalities via Abstract Tubes: Inequalities and identities of the Inclusion-Exclusion Type, Lecture Notes in Mathematics, Springer-Verlag, (2003).
Kahn J., Linial N., Samorodnitsky A., inclusion-exclusion: Exact and Approximate, Combinatorica, Vol. 16 , No. 4, (1996), pp. 465–477.
Dahll¨of V., Jonsson P., Wahlstro¨m M., Counting models for 2SAT and 3SAT formulae, Theoretical Computer Sciences, 332(1-3), (2005), pp. 265-291.
De Ita G., Marcial-Romero R., Hern´andez J.A., A threshold for a Polynomial Solution of #2SAT,
Fundamenta Informaticae, 113:1(2011), pp. 63-77.
De Ita G., Bello P., Contreras M., New Polynomial Classes for #2SAT Established Via Graph-Topological Structure, Engineering Letters, Vol. 15;2, Int. Assoc. of Engineers, www.engineeringletters.com, (2007), pp. 250-258.
De Ita G., Marcial-Romero J.R., Computing #2SAT and #2UNSAT by Binary Patterns, LNCS, Vol. 7329 - 4th Mexican Conf. on Pattern Recognition, (2012), pp. 273-282.
Dubois Olivier, Counting the number of solutions for instances of satisfiability, Theor. Comp. Sc. 81, (1991), 49-64.
Gusfield D., Pitt L., A bounded approximation for the minimum cost 2-Sat problem, Algorithmica 8, (1992), 103-117.
Linial N., Nisan N., Approximate inclusion-exclusion. Combinatorica, Vol. 10, No. 4, (1990), pp. 349-
365.
Lozinskii E., Counting propositional models, Inf. Proc. Letters 41, (1992), pp. 327-332.
Roth D., On the hardness of approximate reasoning, Artificial Intelligence 82, (1996), pp. 273-302.
Vadhan Salil P., The Complexity of Counting in Sparse, Regular, and Planar Graphs, SIAM Journal on Computing, Vol. 31, No.2, (2001), pp. 398-427.
Wahlstr¨om M., A Tighter Bound for Counting Max-Weight Solutions to 2SAT Instances, LNCS, Vol. 5018 - Parameterized and Exact Computation: Third Int. Workshop, (2008), pp. 202-213.
Zhou Junping, Yin Minghao, Zhou C., New Worts-Case Upper Bound for #2-SAT and #3-SAT with the Number of Clauses as the Parameter, Proc. of the AAAI, (2010), pp. 217-222.
