

Electronic Notes in Theoretical Computer Science 249 (2009) 269–286
www.elsevier.com/locate/entcs

On the Relative Expressive Power of Calculi for Mobility
Daniele Gorla
Dip. di Informatica, Univ. di Roma “La Sapienza”

Abstract
In this paper, we comparatively analyze some mainstream calculi for mobility: asynchronous π-calculus, distributed π-calculus and Mobile/Boxed/Safe ambients. In particular, we focus on their relative expressive power, i.e. we try to encode one in the other while respecting some reasonable properties. According to the possibility or the impossibility for such results, we set up a hierarchy of these languages.
Keywords: Expressiveness, Encodings, Mobility, Process Calculi.

Introduction
In the last ten years, one of the main research lines in the field of concurrency theory has been the development of new formalisms, paradigms and environments that bet- ter model distributed and mobile systems. Several terms have been coined to name this fortunate research line (network-aware programming, WAN/global/ubiquitous computing, ...) that has attracted many computer scientists around the world. In this scenario, the term mobility has become the reference keyword to denote several possible dynamic evolutions of systems, ranging from name mobility to mobile com- putation and mobile computing. A lot of efforts have been spent to define more and more sophisticated type theories, behavioural equivalences and implementations for these calculi. What is still missing is, from the practical side, real-life applications where the distinctive features of such formalisms are essential and, from the theoret- ical side, an exhaustive comparative analysis of all these proposals, from a linguistic perspective.
In this paper, we approach the last issue by comparing some mainstream calculi for mobility: asynchronous π-calculus (written πa) [15,1], distributed π-calculus (written Dπ) [14], and Mobile/Boxed/Safe ambients (written MA/BA/SA) [7,2,17]. Our results formally prove some claims informally appeared in the literature or differently prove results already known. Moreover, for the sake of systematization, we also consider and compare languages that, to the best of our knowledge, have

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.094

never been contrasted, neither informally.
To this aim, we compare languages via their relative expressive power, i.e. we try to encode one language in another, while respecting some reasonable properties. Of course, the definition of such properties is crucial for the meaningfulness of our study: too liberal properties would lead to poorly informative results (most of the encodings would be possible), whereas too stringent properties would be fruitless (very few encodings would be possible).
In principle, a good encoding should satisfy at least two properties: composition- ality (the encoding of a compound term must be expressed in terms of the encoding of its components) and faithfulness (the encoding of a term must have exactly the
same functionalities as the original term). There are different ways to formalize these notions; mainly for the second one, a number of different proposals have been considered in the literature (e.g., sensitiveness to barbs/divergence/deadlock, op-
erational correspondence, full abstraction, ...). Here, we take the proposal in [13] and consider only encodings that satisfy the following properties: compositionality, name invariance (i.e., the encodings of two source processes that differ only in their free names must only differ in the associated free names), operational correspondence
(i.e., computations of a source term must correspond to computations in the en- coded term, and vice versa), divergence reflection (i.e., terminating processes must be translated into terminating processes) and success sensitiveness (i.e., successful
terms – for some notion of success – must be translated into successful terms, and vice versa). In [13] we show that these criteria form a valid proposal for language comparison: most of the encodings in the literature respect them (so our notion is consistent with the common understanding of the community), but there still exist encodings that do not satisfy them (so our notion is non-trivial); moreover, the best known separation results can be proved (in a much easier and uniform way) by rely- ing on our proposal. Here, we furthermore vindicate the validity of our proposal by showing that some widely believed (but never formally proved) separation results can be established by relying on the above mentioned criteria.
Our results are summarized in the side figure. There, we put an arrow from L1 to L2 if L1 can be encoded in L2 but not vice

versa (the dashed arrow denotes an encod- ability result slightly weaker than the solid
SA,, 
 

arrow). We say that L2 is more expressive
     

Dπ¸,¸
M,A,??	B A,

than L1 if there is a sequence of arrows from L1 to L2; L1 and L2 are incomparable if nei- ther L1 is more expressive than L2 nor vice
¸¸¸
¸¸
πa

versa.
Some of our results are expectable: for example, we confirm that πa is the minimal  common  denominator  of  calculi
Figure 1

for mobility, since it can be encoded in all the languages considered. However, though expectable, some results turned out very difficult to prove. For example,

to encode πa in MA we had to develop quite a complex encoding since one of our criteria is operational correspondence: what we propose is, to the best of our knowledge, the first encoding that does not introduce any ‘spurious’ computation in the encoding of a πa process. Ruling out computations that are not present in the source process is a sensible task when dealing with MA, because of the high possibility of interferences between MA processes. A simpler encoding of πa is possible, e.g., in SA (see [17]), because the latter language is “more controlled” than MA. Another issue that turned out surprisingly difficult to prove is the encodability of MA in BA, that we believe not to hold; this is the only conjecture that this paper leaves open.
This paper is organized as follows. In Section 2, we formally present the syntax and operational semantics of the languages considered. In Section 3, we recall from
[13] the properties that encodings should satisfy. In Section 4, we formally build up our hierarchy: for every pair of languages, we give an encodability/separation result. Finally, in Section 5 we conclude the paper by also mentioning some related work. In this extended abstract we have omitted the motivations behind the languages; for more details, see the original papers where such languages were introduced.
The Languages
A process calculus is a triple L = (P, '−,→ ), where
	is the set of language terms, usually called processes and ranged over by P, Q, R, .. .. All the process calculi we are going to consider have a common core syntax given by:
P ::= 0  (νn)P  P1|P2  !P  √
As usual, 0 is the terminated process, whereas √ denotes success (see the discus- sion on Property 5 in Section 3); P1 P2 denotes the parallel composition of two processes; (νn)P restricts to P the visibility of n and binds n in P ; finally, !P
denotes the replication of process P . We have assumed here a very simple way of modeling recursive processes; all what we are going to prove does not rely on this choice and can be rephrased under different forms of recursion.
	is the operational semantics, needed to specify how a process computes; following common trends in process calculi, we specify the operational semantics by means of reductions, whose inference rules shared by all our process calculi are:
P '−→P '	P ≡ P'	P' '−→Q'	Q' ≡ Q

E (P ) '−→(EP ')	P '−→Q
where ( ) denotes an evaluation context and ‘ ’ denotes structural equivalence (used to equate different ways of writing the same process). Of course, the op- erational axioms, the evaluation contexts and structural equivalence are peculiar to every language. As usual, e⇒= denotes the reflexive and transitive closure of '−.→

	is a behavioural equivalence/preorder, needed to describe the abstract be- haviour of a process; usually,  is a congruence/precongruence at least with respect to parallel composition.
We now present the syntax and reduction-based operational semantics of the specific calculi considered in this paper. In what follows, we assume a countable set of names,  , ranged over by a, b, c,..., l, k,..., m, n, ..., u, v, w,..., x, y, z, ... and their decorated versions. To simplify reading, we shall use a, b, c, . . . to denote channels, l, k, ... to denote localities, m, n, . . . to denote ambients and x, y, z,... to denote input variables; u, v, w, . . . are used to denote generic names (channels and variables in πa; channels, localities and variables in Dπ; ambients and variables in MA, SA and BA).

The asynchronous π-calculus (πa)
We consider the asynchronous version of the π-calculus, as defined in [1]. This language is nowadays widely considered the minimal common denominator of calculi for mobility, it is a good compromise between expressiveness and simplicity, and it also has a good implementation [24]. Its syntax extends the common syntax of processes by letting
P	::=	...  u¯⟨v⟩  u(x).P
Intuitively, u¯ v represents message v unleashed along channel u. Dually, u(x).P waits for some message from channel u and, once received, replaces with such a message every occurrence of variable x in P . Processes u(x).P and (νa)P bind x and a in P , respectively; a name occurring in P that is not bound is called free. Consequently, we define the free and bound names of a process P , written f n(P ) and bn(P ); alpha-conversion is then defined accordingly.
Evaluation contexts are defined as follows:

E (·)	::=	·   E (·) | P  P |E (·)  (νn)E (·)

The structural equivalence relation, , is the least equivalence on processes closed by evaluation contexts, including alpha-conversion and satisfying the following axioms:

P|0 ≡ P	P1|P2 ≡ P2|P1	P1|(P2|P3) ≡ (P1|P2)|P3
!P ≡ P|!P	(νa)0 ≡ 0	(νa)(νb)P ≡ (νb)(νa)P P1|(νa)P2 ≡ (νa)(P1|P2) if a /∈ f n(P1)
The reduction relation,  , is the least relation on processes closed by the inference rules described above and satisfying the following axiom:

a(x).P | a¯⟨b⟩ '−→P {b/x}

where P b/x denotes the capture-avoiding substitution of each occurrence of x in
P with an occurrence of b.

Distributed π-calculus (Dπ)
We present a slightly simplified version of [14]; mainly, we elided typing information from the syntax. The main syntactic entity are nets, that are collections of located processes, possibly sharing restricted names:

N ::= 0  l : P  N|N  (νu)N Processes are obtained from the common syntax by letting
P ::= ...  u(x).P  u¯⟨v⟩.P  go u.P

The main differences between Dπ and πa are: processes and channels are located at a specified locality; communication can only happen between co-located processes and, hence, there is a primitive to let processes migrate between localities (viz. action go u); finally, communication is synchronous (i.e., it blocks both the sending and the receiving process).
Since the main syntactic entity is the set of nets, evaluation contexts, reductions and structural equivalence will be given for nets.

E (·)	::=	·  E (·) | N  N |E (·)  (νn)E (·) The structural axioms are:
l : P|0 ≡ l : P	l : P1|P2 ≡ l : P1 | l : P2	l : !P ≡ l : P|!P
N|0 ≡ N	N1|N2 ≡ N2|N1	N1|(N2|N3) ≡ (N1|N2)|N3
(νu)(νw)N ≡ (νw)(νu)N	(νn)0 ≡ 0	l : (νu)P ≡ (νu)l : P	if u /= l
(νl)N ≡ (νl)(N | l : 0)	N1|(νu)N2 ≡ (νu)(N1|N2)  if u /∈ f n(N1) The reduction axioms are:
l : a(x).P | l : a¯⟨b⟩.Q '−→l : P{b/x} | l : Q
l : go l'.P | l' : 0 '−→l : 0 | l' : P

Notice that a migration at l' is legal only if l' is an existing locality of the net. In the original paper [14], this check was carried out, among other tasks, by the type system. We prefer the present formulation for the sake of simplicity; however, all what are going to prove does not rely on this choice.

Mobile Ambients (MA)
We consider the Ambient calculus as presented in [7].

P ::= ...  (x).P  ⟨M⟩  M.P  u[P ]
M ::= u  in u  out u  open u  M.M

MA is somewhat related to Dπ in the sense that processes are located within ambients (viz. u[P ]) and only co-located processes can communicate via a monadic, asynchronous and anonymous communication: (x).P represents the anonymous in- put prefix, whereas M represents the asynchronous and anonymous output parti- cle, where message M can be not only a raw name but also a sequence of actions. However, differently from Dπ, entire ambients can move: an ambient n can enter into a sibling ambient m via the in m action or exit from the enclosing ambient m via the out m action. Moreover, an ambient n can be opened via the open n action.
Evaluation contexts are defined as follows:

E (·)	::=	·   E (·) | P  P |E (·)  (νn)E (·)  n[E (·)]

The structural equivalence relation extends structural equivalence of πa with the following axioms:
(M.M').P  ≡ M.(M'.P )	m[(νn)P ] ≡ (νn)m[P ]  if n /= m

The reduction axioms are:

n[in m.P1|P2] | m[P3] '−→m[P3 | n[P1|P2]] open n.P1 | n[P2] '−→P1 | P2 m[n[out m.P1|P2] | P3] '−→n[P1|P2] | m[P3]  (x).P | ⟨M⟩ '−→P {M/x}
MA, like all the following Ambient-like languages, strongly relies on a type system to avoid inconsistent processes like, e.g., m.P or in n[P ]; these two processes can arise after the (ill-typed) communications (x).x.P  m and (x).x[P ]  in n . For MA, like for SA and BA, we shall always consider the sub-language formed by all the well-typed processes, as defined in [6,17,2].

Safe Ambients (SA)
We consider the Safe Ambient calculus as presented in [17]. SA extends MA by adding co-actions, though which ambient movements/openings must be authorized by the target ambient. Hence, the syntax of SA is the same as MA’s, with



M ::= ...  in u  out u open u

Evaluation contexts and structural equivalence are the same as for MA; the reduc- tion axioms are:
(x).P | ⟨M⟩ '−→P {M/x}	open n.P1 | n[open n.P2|P3] '−→P1 | P2 | P3 n[in m.P1|P2] | m[in m.P3|P4] '−→m[P3 | P4 | n[P1|P2]]

m[n[out m.P1|P2] | out m.P3 | P4] '−→n[P1|P2] | m[P3|P4]
Boxed Ambients (BA)
We consider the Boxed Ambient calculus as presented in [2]. BA evolves MA by removing the open action that is considered too powerful and, hence, potentially dangerous. To let different ambients communicate, BA allows a restricted form of non-local communication: in particular, every input/output action can be per- formed locally (if tagged with direction ), towards the enclosing ambient (if tagged with direction U ) or towards an enclosed ambient n (if tagged with direction n).

P ::= ...  (x)η.P  ⟨M⟩η .P  M.P  u[P ]

M ::= u  in u  out u  M.M	η ::=	 u
Evaluation contexts and structural equivalence are the same as for MA; the reduc- tion axioms are:
n[in m.P1|P2] | m[P3] '−→m[P3 | n[P1|P2]] m[n[out m.P1|P2] | P3] '−→n[P1|P2] | m[P3] (x)٨.P1 | ⟨M⟩٨.P2 '−→P1{M/x} | P2
(x)٨.P1 | n[⟨M⟩U.P2|P3] '−→P1{M/x} | n[P2|P3] (x)n.P1 | n[⟨M⟩٨.P2|P3] '−→P1{M/x} | n[P2|P3]
⟨M⟩٨.P1 | n[(x)U.P2|P3] '−→P1 | n[P2{M/x}|P3]
⟨M⟩n.P1 | n[(x)٨.P2|P3] '−→P1 | n[P2{M/x}|P3]
Properties of Encodings
A translation of	1 = ( 1,	1,	1) into	2 = ( 2,	2,	2), written   ) :	1
2, is a function from 1 to 2. We shall call encoding any translation that satisfies the five properties we are going to present now. There, to simplify reading, we let S range over processes of the source language (viz., L1) and T range over processes of the target language (viz., L2).

As already said in the introduction, an encoding should be compositional. To for- mally define this notion, we exploit the notion of k-ary context, written ( 1; ... ; k), that is a term where k occurrences of 0 are replaced by the k holes  1,..., k.
Property 1 A translation · ) : L1 → L2 is compositional if, for every k- ary L1-operator op and ﬁnite subset of names N, there exists a k-ary con- text oNp[ 1; ... ; k] such that op(S1,..., Sk) ) = oNp[ S1 ); ... ; Sk )], for every S1,..., Sk with f n(S1,..., Sk) = N.
Moreover, a good encoding should reflect in the encoded term all the name substitutions carried out in the source term. However, it is possible that an encoding fixes some names to play a precise rˆole or it can map a single name into a tuple of names. In general, every encoding assumes a renaming policy ϕ ) : N −→ N k that is a function such that ∀u, v ∈ N with u /= v, it holds that ϕ )(u) ∩ ϕ )(v) = ∅ (where ϕ )( ) is simply considered a set here). We extend the application of a substitution to sequences of names in the expected way.
Property 2 A translation ) : 1  2 is name invariant if, for every substi- tution σ, it holds that


 Sσ )
⎩
=  S )σ'	if σ is injective
  2  S )σ' otherwise

where σ' is the substitution such that ϕ )(σ(a)) = σ'(ϕ )(a)).
Injectivity of σ must be taken into account because non-injective substitutions can fuse two distinct names, and this matters because compositionality also depends on the free names occurring in the encoded terms. For more discussion, see [13].
A source term and its encoding should have the same operational behaviour, i.e. all the computations of the source term must be preserved by the encoding without introducing “new” computations. This intuition is formalized as follows.
Property 3 A translation  · ) : L1 → L2 is operationally corresponding if
for every S and S' such that S e⇒=1 S', it holds that  S ) e⇒=2 2 S');
for every S and T such that  S ) e⇒=2 T, there exists S' such that S e⇒=1 S'
and T e⇒=2 2  S' ).
An important semantic issue that an encoding should avoid is the introduction of infinite computations, written '−ω→.
Property 4 A translation  · ) : L1 → L2 is divergence reflecting whenever
 S ) '−ω→implies that S '−ω→, for every S.
Finally, we require that the source and the translated term behave in the same way with respect to success, a notion that can be used to define sensible semantic theories [9,25]. To formulate our property in a simple way, we follow the approach in
[25] and assume that all the languages contain the same success process √; then, we
define the predicate , meaning reducibility (in some modality, e.g. may/must/fair- must) to a process containing a top-level unguarded occurrence of √.  Clearly,

different modalities in general lead to different results; in this paper, proofs will be carried out in a ‘may’ modality. Finally, for the sake of coherence, we require the notion of success be caught by the semantic theory underlying the calculi, viz.  ; in particular, we assume that  never relates two processes P and Q such that P ⇓ and Q /⇓.
Property 5 A translation · ) : L1 → L2 is success sensitive if, for every S, it holds that S ⇓ iff S ) ⇓.
Derived Properties
The results we are going to prove (both negative and positive) rely on the choice of equivalence/preorder in the target language, viz. ‘ 2’. Some translations become encodings (i.e., they satisfy all the properties just listed) only under some choices of ‘ 2’: a representative sample is given in Theorem 4.5. Similarly, some separation results can be proved under specific assumptions on ‘ 2’, in the sense that the proof we provide only works under such assumptions. Indeed, in [13] we show that some separation results can be proved in the general framework but, to carry out more proofs, we have to slightly specialize the framework. In particular, in loc.cit. we have considered three alternative settings:
	2 is exact, i.e. T 2 T ' and T performs an action imply that T ' can (weakly) perform the same action as well; moreover, parallel composition must be trans- lated homomorphically, i.e. for every N ⊂N it holds that CN [ 1; 2] = 1 | 2;
2 is reduction sensitive, i.e. T 2 T ' and T ' '−2→imply that T '−2→;
the occurrences of  2 in Property 3 are restricted to pairs of kind ((νn)( S' ) | T '), S' )), for any n and T ' such that (νn)( S' ) | T ')  2  S' ).
All these assumptions are discussed and justified at length in [13]. By relying on them, we can prove a number of auxiliary results that will be useful in carrying out the main proofs of the paper.
Proposition 3.1 Let · ) be an encoding and assume that we are in setting (ii) or (iii); then, S '/ −1→implies that S ) '/ −2→.
Proposition 3.2 Let · ) be an encoding and assume that we are in setting (ii) or (iii); if there exist two source terms S1 and S2 such that S1 | S2 ⇓, S1 /⇓ and S2 /⇓, then S1 | S2 ) '−2→.
Proposition 3.3 Let  ) : 1  2 be an encoding and assume that we are in setting (ii) or (iii). If there exists two source terms S1 and S2 that do not reduce but such that S1 | S2 ) '−2→, then
if L2 ∈ {πa, Dπ}, it can only be that  S1 ) |  S2 ) '−2→;
if L2 ∈ {MA, BA, SA}, it can only be that C1( S1 )) | C2( S2 )) '−2→, where C|	[ 1; 2], i.e. the context used to compositionally translate S1 | S2, is of the form E (C1( 1) | C2( 2)) for some evaluation context E (·) and two contexts C1(·) and C2(·) that are either empty (viz., · ) or a single top-level ambient

containing a top-level hole (viz., m[ ·| R]).
Theorem 3.4 Assume that there is a L1-process S such that S '/ −1→, S /⇓ and
S | S ⇓; moreover, assume that every L2-process T that does not reduce is such that
T	T / 2. Then, there cannot exist any encoding  ) :	1	2 under none of the settings (i), (ii) and (iii).
To state the following proof-technique, let us define the matching degree of a language , written Md( ), as the greatest number of names that must be matched to yield a reduction in  . For example, the matching degree of MA is 1, whereas the matching degree of Dπ is 2.
Theorem 3.5 If Md(L1) > Md(L2), then there exists no encoding  · ) : L1 → L2
under settings (ii) nor (iii).
A new derived property, not needed for the results in [13], is the following one.
Proposition 3.6 Let · ) : L1 → L2 be a translation that satisﬁes Property 2; for every S and n /∈ f n(S), it holds that ϕ )(n) ∩ f n( S )) = ∅.
Proof. By contradiction, let n' ∈ ϕ )(n)∩f n( S )). Let m be such that m /∈ f n(S) and ϕ )(m)  f n( S )) = ; moreover, let σ be the permutation that swaps m and n.  Trivially, S = Sσ and, hence,  S ) =  Sσ ).  However, by Property 2,
 Sσ ) = S )σ', for σ' that swaps ϕ )(m) and ϕ )(n) component-wise. The only possible way to have that S ) = S )σ' (that holds because of transitivity) is to have dom(σ') ∩ f n( S )) = ∅ that, however, does not hold, because dom(σ') = ϕ )(n) ∪ ϕ )(m) and n' ∈ ϕ )(n) ∩ f n( S )): contradiction.	 
It is worth noting that all negative results we are going to prove hold under settings (ii) and (iii); on the contrary, only some of them also hold in setting (i). All the three settings have advantages and disadvantages. In our opinion, the better compromise is setting (iii) that, in spite of being very ‘syntactical’, exactly captures the intuition underlying the occurrences of ‘ 2’ in Property 3: to garbage collect junk processes left by the encodings. Indeed, it is the only setting that is satisfied by all the encodings we are aware of. Clearly, a challenging direction for future work consists in finding other settings that enable proofs but are more liberal than the present ones.

The Hierarchy, bottom-up
We now give the results underlying the hierarchy of calculi for mobility depicted in Figure 1.
Theorem 4.1 There exists no encoding of MA, SA and BA in Dπ and πa.
Proof. Corollary of Theorem 3.4:
On one hand, notice that

if T is a πa-process such that T | T '−2→, then T ≡ (νn)(a(x).P | a¯⟨b⟩ | T '), for some a not in n. Thus, trivially, T '−2→; hence, every πa-process T that does not reduce is such that T | T '/ −→2.
if T is a Dπ-net such that T | T '−2→, then either T ≡ (νn)(l : a(x).P | l :
a¯⟨b⟩.Q | T ') or T ≡ (νn)(l : go l'.P | l' : 0 | T '), for some a, l and l' not in
n. Thus, trivially, T '−2→; hence, every Dπ-net T that does not reduce is such that T | T '/ −→2.
On the other hand, we can find in MA, SA and BA a process S that does not reduce and does not report success, but such that S S reports success: it suffices to let S be
(νp)(open p.√ | n[in n.p[out n.out n]]). in MA and BA;
			

(νp)(open p.√ | n[in n.p[out n.out n.open p] | in n | out n]) in SA.


Theorem 4.2 There exists no encoding of Dπ in SA, BA, MA and πa.


Proof. Corollary of Theorem 3.5, since
Md(Dπ) = 2 whereas
Md(MA) =

Md(SA) = Md(BA) = Md(πa) = 1.	 

Theorem 4.3 Dπ and BA are more expressive than πa.
Proof. Because of Theorems 4.1 and 4.2, it suffices to encode πa in Dπ and BA.
Clearly, πa can be trivially encoded in Dπ: it suffices to co-locate the πa process in a pre-defined locality hosting all the channels needed. This translation is an encoding under any choice of 2.
BA can encode πa: [2] provides an encoding of πa in BA that satisfies all the properties of Section 3, with operational correspondence that holds up to any (pre)congruence that satisfies the law (νn)n[P ]  0 whenever k  f n(P ) (e.g., strong barbed equivalence). It is defined as a homomorphism w.r.t. all the opera- tors, except for

 u(x).P )   (x)u. P )	 u¯⟨v⟩ )  (νk)(u[⟨v⟩٨.in k] | k[0])	for k fresh
 

Theorem 4.4 MA is more expressive than πa.
Proof. Because of Theorem 4.1, MA cannot be encoded in πa. We are left with proving that πa can be encoded in MA; this is not a trivial task, if we want to satisfy all the properties in Section 3 with operational correspondence that holds up to strong barbed equivalence. Indeed, in several papers [7,6,5] there are attempts to encode πa in MA, but none of them satisfies Property 3.
The encoding relies on a renaming policy that maps every name a to a triple of pairwise distinct names (a1, a2, a3); it is a homomorphism w.r.t. all the operators,

except for restrictions, inputs and outputs, that are translated as follows:

 (νa)P )  (ν a1, a2, a3) P )

 a¯⟨b⟩ )  a1[a2[open a3.⟨b1, b2, b3⟩]]

 a(x).P )  open a1.(νp, q)(open p
|  a3[in a2.open rest  |  (x1, x2, x3).in q.p[out q. P )]]
| q[open a2.rest[! rest[in a3.out q.in a2.open rest]]]) for p and q fresh
where (x1, x2, x3) is a shortcut for (x1).open pol.(x2).open pol.(x3) and  b1, b2, b3 is a shortcut for b1	pol[ b2	pol[ b3 ]], with pol a reserved name for implement- ing polyadic communications. The proof that the translation just presented satis- fies all the properties listed in Section 3 is omitted for space reasons; the interested reader can find it in [10].		 
Our encoding follows the philosophy underlying the encoding of πa in BA; how- ever, MA misses the parent-child communication of BA, used to translate an input action. Thus, for every communication along a, the ambient named a3 is used as a ‘pilot’ ambient to enter a2 and consume the datum associated to b. To reflect the fact that an output along a can be consumed only once, we exploit the outer ambient a1 and the corresponding open a1 action. However, interferences can still arise from independent communications along channel a: several a3-ambients can enter into the same a2-ambient. In this case, only one of them is opened and the re- maining ones must be rolled back, i.e. reappear at top-level, ready to enter another a2-ambient. Such a rolling back is done by opening a2 in a restricted ambient q and by leading all the not consumed a3-ambients out from q via the reserved ambient rest, that also restores the in a2 capability.
Theorem 4.5 SA is more expressive than MA: SA can be encoded in MA, whereas there exists no encoding of SA in MA.
Proof. In [17] MA is translated into SA by mapping all the operators homomor- phically, except for  u[P ] )   u[! in u  ! out u  ! open u  P )]. Such an encod- ing enjoys operational correspondence up to (strong/weak) barbed equivalence re- stricted to translated contexts (written tr). Indeed, the MA process open n n[0] reduces to 0, whereas its encoding can only reduce to ! in n ! out n ! open n and the latter process is only translated barbed equivalent 1 to the encoding of 0 (viz.,




1 The idea is that, if placed within an ambient different from n, ! i n n | ! out n | ! open n has the same effect as 0. If placed (possibly, after some reduction steps) within an ambient n, ! i n n | ! out n | ! open n is useless (and, again, has the same effect as 0): since we are working in a translated setting (and hence every ambient has replicated occurrences of all the co-capabilities involving its name), an identical process is already present within n and can be absorbed thanks to Milner’s law !P  tr !P | !P .

0 itself).
On the contrary, SA cannot be encoded in MA; this is proved by con- tradiction.  Consider the pair of SA processes P   n[in n. m ] and Q 
n[in n.(m[out n.open m.√]  out n)]  open m, for n = m; by Proposition 3.2,
 P Q ) must reduce and, because of Proposition 3.3 and the definition of the re- duction rules for MA, it can only be that
either	1( P )) exhibits a top-level ambient n' and	2( Q )) wants to en- ter/open it;
or 2( Q )) exhibits a top-level ambient n' and 1( P )) wants to enter/open it.
for some context 1( ) and 2( ) that are empty or have a single top-level ambient containing a top-level hole. Notice that the reduction cannot happen because of a communication otherwise, by Property 2, m[in m.⟨n⟩] | Q ) would reduce, against Proposition 3.1. For the same reason, it must be that n' ∈ ϕ )(n).
We now prove that both cases are impossible; without loss of generality, assume that we fall in case (i), since case (ii) is similar. First, notice that C1(·) must be empty: if it was not, we would have that  n[out n.⟨m⟩] | Q ) '−→(recall that C1(·) is part of C{n,m}[ 1;  2], the context used to encode parallel composition of processes
with free names n, m ; so, it only depends on parallel composition and such names). Thus, we have that P ) exhibits the top-level ambient n'; but also this leads to a contradiction. Indeed, by Property 1, it holds that  P )  C{n,m}( in n.⟨m⟩ )); so,
the ambient named n' can be exhibited either by C{n,m}(·) or by  in n.⟨m⟩ ) (and,
hence, C{n,m}(·) has a top-level hole). In both cases, we can contradict Proposi- tion 3.1: in the first case, we would have that  n[out n.⟨m⟩] | Q ) '−;→in the
second case, we would have that in n.⟨m⟩ | Q ) '−.→
We want to remark that SA can encode MA also in a different way, that allows us to formulate operational correspondence up to standard (i.e., not just translated) barbed equivalence. To this aim, we have to consider a family of encodings · )N , for N ⊂ N , with the idea that a MA process P can be encoded via  · )N only if f n(P ) ⊆ N . For every N ,  · )N is a homomorphism for all operators, except for

 0 )N  PN	 u[P ] )N  u[PN |  P )N ]

 (νn)P )N  (νn) P )N ∪{n}	 (x).P )N  (x). P )N ∪{x}



where PN   n∈N ! in n | ! out n | ! open n. By exploiting the equivalence !P 
!P | !P , it is easy to check that now operational correspondence holds up to  .
It is however worth noting that such a kind of parameterized encoding (and, similarly, those proposed by [19,16]) is not considered in our framework because

If we did not restrict our attention to translated contexts, we could use n[·] as a distinguishing context in SA for the two processes 0 and ! i n n | ! out n | ! open n .

it would make difficult to formulate our properties and carry out proofs without knowing what the index represents. For example, having a parameterized encoding
  )Ξ, which is the initial (i.e., top-level) value of Ξ in  )Ξ? Moreover, even as-
suming that Ξ are names (as in the translation of SA in MA just presented), are they names in the source or in the target language? The latter question is very delicate: in the first case, Property 2 should be adapted by requiring that  Sσ )Ξσ is equal/equivalent to ( S )Ξ)σ'; in the second case, we have that Sσ )Ξσ' must be equal/equivalent to ( S )Ξ)σ'. Thus, even if we believe that such an enhanced form of encoding is reasonable, we have problems in adapting our framework without specifying anything on the index. On the contrary, we would find it very strange to make too many assumptions on the index, in general.
Nevertheless, we believe that both the argument shown in the proof of Theo- rem 4.5 and this further possible encoding give the feeling that SA can be encoded in MA. This fact justifies the dashed arrow placed in Figure 1 between SA and MA: there should be some kind of arrow from MA into SA, but it seemed us fair to distinguish such an arrow from the other ones in the picture.
Theorem 4.6 There exists no encoding of BA in SA and MA.
Proof. We show the non-encodability of BA in SA, since the result for BA in MA is simpler. Consider the processes (x)n.√ and n[ b ٨], for n = b. Because of Proposition 3.2,  (x)n.√  n[ b ٨] ) must reduce and, because of Propositions 3.3
and of the reduction rules for SA, this can only happen because:
either 1( (x)n.√ )) wants to enter into an ambient named n' and 2( n[ b ٨] ))
allows such an entrance;
or  2( n[ b ٨] )) wants to enter into an ambient named n' and  1( (x)n.√ ))
allows such an entrance;
or  1( (x)n.√ )) wants to open an ambient named n' and  2( n[ b ٨] )) allows
such an opening;
or  2( n[ b ٨] )) wants to open an ambient named n' and  1( (x)n.√ )) allows
such an opening.
Indeed, C1( (x)n.√ )) and √C2( n[⟨b⟩٨] )) cannot perform a communication, other-

wise, by Property 2,  (x)n.
be that n' ∈ ϕ )(n).
| b[⟨n⟩٨] ) would reduce; for the same reason, it must

However, we now prove that all the cases depicted above lead to contradict Proposition 3.1. Let us consider C2( n[⟨b⟩٨] )) in all cases. If C2(·) is empty we can work as follows.  First, observe that  n[⟨b⟩٨] )   C{b}( ⟨b⟩٨ )); if the action
is produced by C{b}(·) alone, also  n[⟨b⟩U] ) would produce the same action and so (x)n.√ | n[⟨b⟩U] ) would reduce; similarly, if the action is produced by ⟨b⟩٨ ) alone,  (x)n.√ | ⟨b⟩٨ ) would reduce. Hence, the action is produced both by C{b}(·)
and ⟨b⟩٨ ); this means that C{b}(·) provides an ambient and ⟨b⟩٨ ) performs the action in n', in n' or open n'. However, the latter fact is not possible because otherwise n' ∈ f n( ⟨b⟩٨ )), in contradiction with Proposition 3.6. So, it must be

that 2( ) is not empty; this rules out case (iv) above and imposes that n[ b ٨] ) performs the action in n', in n' or open n', respectively. We then work like in the case in which 2( ) is empty to prove that there is no way for n[ b ٨] ) to perform such an action without contradicting Proposition 3.1.	 
Theorem 4.7 There exists no encoding of SA in BA.
Proof. By contradiction. First, consider the pair of SA processes P n[in n. m ] and Q  n[in n.(m[out n.open m]  out n)]  open m.√, for n = m; by Propo-
sitions 3.2 and 3.3, and by definition of the reduction rules for BA, it must be
that
either	1( P )) exhibits an ambient n' and	2( Q )) wants to enter in it, or vice versa;
or 1( P )) sends a message to a sibling ambient n' and 2( Q )) is ready to locally receive a message, or vice versa;
or 1( P )) waits for a message from a sibling ambient n' and 2( Q )) locally sends some message, or vice versa.
In all cases, n' ϕ )(n). We now prove that the three cases above all lead to a contradiction: the first case is formally identical to the proof of Theorem 4.5; the second and the third case are similar, so we only work out case (ii). First, notice that C1(·) must be empty: if it were not, it must be a single ambient and, hence, it
could not send/receive any message. So, the action is produced either by C{n,m}(·) or by in n.⟨m⟩ ). In both cases, we can contradict Proposition 3.1: in the first case, we would have that n[in m.⟨n⟩] | Q ) '−;→in the second case, we would have
that in n.⟨m⟩ | Q ) '−.→
To complete the hierarchy of Figure 1, it would suffice to prove that there exists no encoding of MA in BA. Surprisingly, we have not been able to prove such a (quite expectable) result; we leave it open as a conjecture. Thus, there are only two possibilities for resolving the ‘??’ in Figure 1:


SA¸,¸
¸ ¸
¸
B A,
 
   
SA,, 
 
 

Dπ¸,¸ ¸
M A,
Dπ	MA	BA

¸¸¸
¸,¸¸¸	,,   ,

¸¸¸
πa
¸¸¸¸¸
    
πa

according to whether MA is encodable in BA or not. We strongly believe that the right one should hold, even if we still have not been able to prove it.

Conclusions and Related Work
We have comparatively studied some mainstream calculi for mobility, namely the asynchronous π-calculus, a distributed π-calculus and Mobile/Safe/Boxed Ambi-



Table 1
Overview of all our results: ‘J’ stands for a possibility result, ‘×’ stands for an impossibility result, ‘??’ stands for an open question.



ents. We have organized all these languages in a clear hierarchy based on their relative expressive power. In [11], we also extend our analysis to various dialects of MA/BA/SA appeared in the literature in the last years and compare every dialect with the language it comes from.
The results of this paper are summed up in Table 1 and are compared with analogous results from the literature (‘?’ stands for absence – to the best of our knowledge – of any formal claim already appeared). To obtain such results, we have exploited the set of criteria presented and discussed in [13].

To the best of our knowledge, our encoding of πa in MA is the first one that satisfies operational correspondence. It is quite complex (the encoding of a single communication in πa requires 14 reduction steps in MA) because some ingenuity is needed to handle the possible interferences that can arise between the encod- ing of different actions on the same channel. Notice that the encoding of πa in SA [17] is simpler (just 5 reductions to mimic a single communication), since co- actions can be exploited to reduce such interferences; this is a further evidence of SA’s expressive power. Moreover, the encoding of πa in BA [2] is even simpler: thanks to parent-child communications, just 2 reductions are needed to mimic a single communication. These facts suggest that co-actions and, even more, remote communications are more suitable to implement channel-based communications in ambient-based languages.
To conclude, we want to mention some strictly related results. First, [26] pro- vides an encoding of the synchronous (choice-free) π-calculus in ‘pure’ SA, i.e. SA without communications. The encoding enjoys all our properties, with homomor- phism w.r.t. ‘ ’ that holds only for processes without free names; otherwise, it is simply compositional, because it introduces a channel-handler for every free name of the translated process. Second, [16] provides an encoding of (a variant of) BA in (a variant of) SA; the encoding respects all our criteria but the languages con- sidered differ from the ones we have presented. Third, the results in [4] entail that Dπ cannot be encoded in πa, under properties similar to ours; notably, they need homomorphism w.r.t. parallel composition whereas we just rely on composition- ality. Fourth, [22,23] are inspired by Palamidessi’s work on electoral systems [21] and separate several calculi for mobility according to the possibility of solving the problem of leader election. Though their approach is different from ours, our results confirm theirs: for example, they prove that πa cannot encode MA, SA and BA. However, we want to remark that our approach is more informative than theirs, since we are able to compare pairs of languages in which leader election is either possible or impossible (e.g., SA and MA, or πa and Dπ).
Finally, calculi for mobility have been a workbench for investigations on the expressiveness of operators like restriction, communication primitives, non- deterministic choice and replication ([3,18,21,20,12,8], just to cite some samples). These works are quite orthogonal to ours, since they compare different sub-calculi of the same language, whereas we compare different programming paradigms.

References
G. Boudol. Asynchrony and the π-calculus (note). Rapport de Recherche 1702, INRIA Sophia- Antipolis, May 1992.
M. Bugliesi, G. Castagna, and S. Crafa. Access Control for Mobile Agents: the Calculus of Boxed Ambients. ACM Transactions on Programming Languages and Systems, 26(1):57–124, 2004.
N. Busi and G. Zavattaro. On the expressive power of movement and restriction in pure mobile ambients. Theoretical Computer Science, 322(3):477–515, 2004.
M. Carbone and S. Maffeis. On the expressive power of polyadic synchronisation in π-calculus. Nordic Journal of Computing, 10(2):70–98, 2003.


L. Cardelli, G. Ghelli, and A. D. Gordon. Mobility types for mobile ambients. In Proc. of ICALP, volume 1644 of LNCS, pages 230–239. Springer, 1999.
L. Cardelli and A. D. Gordon. Types for mobile ambients. In Proc. of POPL, pages 79–92. ACM, 1999.
L. Cardelli and A. D. Gordon. Mobile ambients. Theoretical Computer Science, 240(1):177–213, 2000.
R. De Nicola, D. Gorla, and R. Pugliese. On the Expressive Power of KLAIM-based Calculi. Theoretical Computer Science, 356(3):387–421, 2006.
R. De Nicola and M. Hennessy. Testing equivalence for processes. Theoretical Computer Science, 34:83–133, 1984.
D. Gorla. Comparing calculi for mobility via their relative expressive power. Technical Report 09/2006, Dip. di Informatica, Universit`a di Roma “La Sapienza”.
D. Gorla. On the relative expressive power of ambient-based calculi. To appear in the Proc. of TGC. Springer, 2008.
D. Gorla. On the relative expressive power of asynchronous communication primitives. Proc. of FoSSaCS, volume 3921 of LNCS, pages 47–62. Springer, 2006.
D. Gorla. Towards a Unified Approach to Encodability and Separation Results for Process Calculi. In
Proc. of CONCUR’08, volume 5201, pages 492–507. Springer, 2008.
M. Hennessy and J. Riely. Resource Access Control in Systems of Mobile Agents. Information and Computation, 173:82–120, 2002.
K. Honda and M. Tokoro. An object calculus for asynchronous communication. In Proc. of ECOOP, volume 512 of LNCS, pages 133–147. Springer, 1991.
F. Levi. A typed encoding of boxed into safe ambients. Acta Informatica, 42(6):429–500, 2006.
F. Levi and D. Sangiorgi. Mobile safe ambients. ACM Transactions on Programming Languages and Systems, 25(1):1–69, 2003.
S. Maffeis and I. Phillips. On the computational strength of pure ambient calculi. Theoretical Computer Science, 330(3):501–551, 2005.
R. Milner. Functions as processes. Journal of Mathematical Structures in Computer Science, 2(2):119– 141, 1992.
U. Nestmann and B. C. Pierce. Decoding choice encodings. Information and Computation, 163:1–59, 2000.
C. Palamidessi. Comparing the expressive power of the synchronous and the asynchronous π-calculi.
Mathematical Structures in Computer Science, 13(5):685–719, 2003.
I. Phillips and M. Vigliotti. Electoral systems in ambient calculi. In Proc. of FoSSaCS, volume 2987 of LNCS, pages 408–422. Springer, 2004.
I. Phillips and M. Vigliotti. Leader election in rings of ambient processes. Theoretical Computer Science, 356(3):468–494, 2006.
B. C. Pierce and D. N. Turner. Pict: A programming language based on the pi-calculus. In Proof, Language and Interaction: Essays in Honour of Robin Milner. MIT Press, 2000.
J. Rathke, V. Sassone and P. Sobocinski. Semantic Barbs and Biorthogonality. In Proc. of FoSSaCS, volume 4423 of LNCS, pages 302–316. Springer, 2007.
P. Zimmer. On the Expressiveness of Pure Safe Ambients. Mathematical Structures in Computer Science, 13:721–770, 2003.
