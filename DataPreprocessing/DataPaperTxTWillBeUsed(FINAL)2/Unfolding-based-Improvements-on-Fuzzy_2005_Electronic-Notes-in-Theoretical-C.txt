Electronic Notes in Theoretical Computer Science 137 (2005) 69–103 
www.elsevier.com/locate/entcs


Unfolding-based Improvements on Fuzzy Logic Programs 1
Pascual Julia´n2
Dep. of Computer Science, ESI, Univ. of Castilla–La Mancha Paseo de la Universidad, 4; 13071 Ciudad Real, Spain
Gin´es Moreno2
Dep. of Computer Science, EPSA, Univ. of Castilla–La Mancha Campus Universitario, s/n; 02071 Albacete, Spain
Jaime Penabad2
Dep. of Mathematics, EPSA, Univ. of Castilla–La Mancha Campus Universitario, s/n; 02071 Albacete, Spain

Abstract
Unfolding is a semantics-preserving program transformation technique that consists in the ex- pansion of subexpressions of a program using their own definitions. In this paper we define two unfolding-based transformation rules that extend the classical definition of the unfolding rule (for pure logic programs) to a fuzzy logic setting. We use a fuzzy variant of Prolog where each program clause can be interpreted under a different (fuzzy) logic. We adapt the concept of a computation rule, a mapping that selects the subexpression of a goal involved in a computation step, and we prove the independence of the computation rule. We also define a basic transformation system and we demonstrate its strong correctness, that is, original and transformed programs compute the same fuzzy computed answers. Finally, we prove that our transformation rules always produce an improvement in the efficiency of the residual program, by reducing the length of successful Fuzzy SLD-derivations.
Keywords: Fuzzy Logic Programming, Program Transformation.


1 This work is partially supported by MCYT under grant TIN 2004-07943-C04-03
2 Emails:	{Pascual.Julian, Gines.Moreno, Jaime.Penabad}@uclm.es



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.01.040

Introduction
Logic Programming [12] has been widely used for problem solving and know- ledge representation in the past. Nevertheless, traditional logic programming languages do not incorporate techniques or constructs in order to treat explic- itly uncertainty and approximated reasoning. Fuzzy Logic provides a mathe- matical background for modeling uncertainty and/or vagueness. Fuzzy logic relays on the concept of fuzzy set, the theory of fuzzy connectives (t-norms, t-conorms, etc.) and the extension of two-values classical predicate logic to a logic where formulas can be evaluated in the range of the [0, 1] real interval (see [22] or [13] for a comprehensive introduction of this subject). Fuzzy sets
[23] are objects introduced to deal with the fuzziness or vagueness we find in the real world when we try to describe phenomena that have not sharply defined boundaries. Given a set U , an ordinary subset A of U can be defined in terms of its characteristic function χA(x) (that returns 1 if x ∈ A or 0 otherwise) which neatly specifies whether or not an element x is in A. On the other hand, a fuzzy subset A of U is a function A : U → [0, 1]. The function A is called the membership function, and the value A(x) represents the de- gree of membership (it is not meant to convey the likelihood that x has some particular attribute such as “young” [13]) of x in the fuzzy set A. Different functions A can be considered for a fuzzy concept and, in general, they will present a soft shape instead of the characteristic function’s crisp slope of an ordinary set.
Fuzzy Logic Programming is an interesting and still growing research area that agglutinates the efforts to introduce Fuzzy Logic into Logic Program- ming. During the last decades, several fuzzy logic programming systems have been developed, where the classical inference mechanism of SLD-Resolution is replaced with a fuzzy variant which is able to handle partial truth and to reason with uncertainty. Most of these systems implement the fuzzy resolu- tion principle introduced by Lee in [10], such as the Prolog-Elf system [4], Fril Prolog system [2] and the F-Prolog language [11].
On the other hand, there is also no agreement about which fuzzy logic must be used when fuzzifying Prolog. Most systems use min-max logic (for mod- eling the conjunction and disjunction operations) but other systems just use Lukasiewicz logic [7]. Other approaches are parametric with respect the inter- pretation of the fuzzy connectives, letting them unspecified to obtain a more general framework [21]. Recently, it has been appeared in [20] a theoretical model for fuzzy logic programming which deals with many values implications. Finally, in [19] we find an extremely flexible scheme where, apart from intro- ducing negation and dealing with interval-valued fuzzy sets [8], each clause on a given program may be interpreted with a different logic. In this paper, we

follow this last extension in a very natural way.
The fold/unfold transformation approach (also known as “rules+strategies” approach [15]) was first introduced in [3] to optimize functional programs and then used for logic programs [17] and integrated functional-logic programs [1]. This approach is based on the construction, by means of a strategy, of a se- quence of equivalent programs —called transformation sequence and usually denoted by P0,... , Pn— where each program Pi is obtained from the pre- ceding ones P0,... , Pi−1 by using an elementary transformation rule. The essential rules are folding and unfolding, i.e., contraction and expansion of subexpressions of a program using the definitions of this program (or of a preceding one). Other rules which have been considered are, e.g., definition introduction/elimination, and algebraic replacement.
Focusing in unfolding, the objective of this program transformation oper- ation is to replace a program rule by the set of rules obtained after applying a symbolic computation step (in all its possible forms) on the body of the selected rule [15]. Depending on the concrete paradigm taken into account (functional [3], logic [17] or integrated functional–logic [1]) the considered computation step will be performed using —some variant of— its associated operational mechanism (rewriting, resolution or narrowing, respectively).
In this paper we study the extension of two unfolding-based transforma- tions to a fuzzy context. In particular, besides defining a fuzzy variant of the unfolding transformation of [17], we also introduce a new transformation, called T-Norm replacement, operating on the fuzzy component of an expres- sion, which has some similarities with the algebraic replacement of [3]. As we will see, the adaptation of the unfolding rule from classical LP to fuzzy LP can not be made in a naive way, if we really want to define it in a natural and correct way. In particular we need to take into account the “functional” dimension associated to the fuzzy component and, what it is more important, it is crucial to introduce an intermediate language (not required neither in LP, nor in FP) for coding the programs involved during the transformation process.
Apart from [5] and as far as we now, this is the first approach described in the literature for introducing fuzzy transformation rules. The present work largely improves [5] in the following points: i) Language: We use a richer extension of the fuzzy logic language described in [21] which directly affects all the subsequent definitions, results and proofs. ii) Transformations: Now we present a clearer transformation scheme by providing two unfolding-based transformation rules, each one focused in a language component: whereas the fuzzy unfolding rule concentrates into the logic part, the T-Norm replacement rule handles the fuzzy component. Moreover, the effects obtained by the


(fourth variant of the) T-Norm replacement operation can not be achieved by the single transformation rule introduced in [5]. iii) Properties: Besides correctness results, we proof the reduction in length of successful Fuzzy SLD- derivations (when they are computed in the transformed program).
The outline of this paper is as follows. In the next section, we summarize an extension of the fuzzy Prolog dialect described in [21]. In the new extension, that we call f-Prolog, each program clause can be interpreted under a different logic. Section 3 presents the operational semantics of our language. Moreover, in Section 4, we also adapt the concept of a computation rule and we prove a result which is the fuzzy counterpart of the independence of the computation rule theorem demonstrated in [12]. In Section 5 we define two unfolding- based transformation rules for a labeled mark variant of f-Prolog whereas in Section 6 we prove its main theoretical/practical properties. Finally, we show our conclusions in Section 7.

Fuzzy Prolog Programs
Among the variety of fuzzy logic programming languages in the literature, the one described in [21] is specially appropriated to define the concept of unfolding of fuzzy logic programs. In this section we present an extension of this language, that we call f-Prolog ( fuzzy Prolog) and allow us to give a more flexible interpretation of the logical connectives in the style introduced by [19]. Let L be a first order language containing variables, function symbols, predicate symbols, constants, quantifiers ∀ and ∃, and connectives ¬, seq, et1, and et2 (the intended meaning is that seq is an implication —the left-arrow version is written as qes—, et1 is a conjunction evaluating modus ponens with seq, and et2 is a conjunction typically occurring in the body of clauses). Although et1 and et2 are binary connectives, we usually generalize them as functions with an arbitrary number of arguments. That is we write, for in-
stance, et2(x1,... , xn) instead of et2(x1, et2(x2,... , et2(xn−1, xn) .. .)).
A (definite) clause is a formula ∀(A qes et2(B1,... , Bn)), and a (definite) goal is a formula ∀(qes et2(B1,... , Bn)), where A and each Bi are atomic formulas. In general, we call them (seq, et2)- formulas or simply formulas if the kind of connectives used in their writing is not important or can be inferred by the context. Also, we write A←B1,... , Bn as syntactic sugar of
∀(A qes et2(B1,... , Bn)), etc. As usually, A is said to be the head of the clause and (B1,... , Bn) the body. Clauses with an empty body are called facts, whereas clauses with a head and a body are called rules. A sort of degenerate clause is the empty clause, denoted by ‘ ’, representing a contra- dictory formula.


The meaning function for the connective seq, denoted by [seq]], is the residual implication defined as: [seq]](x, y)= sup {z ∈ [0, 1] : [[et1]](x, y) ≤ y}. Therefore [[seq ] is a R-implication, since it is only defined beginning from a t-norm, but it is not necessarily a S-implication, neither a QM-implication [18]. Nevertheless, the meaning function for the connective seq we use in this paper is the one proposed by [21], where [[seq ] is linked to [et1]] in such a way that modus ponens is a sound rule, what is essential in order to proof the correctness of the Fuzzy SLD-Resolution Calculus.
Note also that, in the discussion above, the meaning functions for connec- tives et1 and et2 were let unspecified as arbitrary t-norms 3 [[eti]] : [0, 1]2 → [0, 1], properly extended as many valued functions, and they are intended to be fixed in the range of the whole program. However, as it has been told in [19], it may be useful from a practical point of view to associate a concrete interpretation for each operator et1 or et2 in the context of a program clause instead of a fixed interpretation for the whole program environment. In par- ticular, note that, the conjunction is defined by Zadeh via the min operator but it is widely accepted that no single operator for conjunction can model the wide variety of expressions that is necessary to formalize.
Example 2.1 Given a clause p(x) ←− q(x), r(x) if we interpret p(x) as “x is sportsman”, q(x) as “x is young” and r(x) as “x is healthy”, the predicates of the body are of positive influence (that is, they mutually reinforce them- selves). In this case the conjunction et2 of body is usually understood as min. Similarly, if q(x), and r(x) are interpreted as independent or noninteractive predicates. However, if q(x) is interpreted as “x is low” and r(x) as “x is tall”, that is, the predicates q(x) and r(x) has a contradictory meaning, the conjunction et2 of body is advisable to be interpreted as max.
We can redefine the concept of fuzzy theory that appears in [21] in order to cope with this problem.
Definition 2.2 A  fuzzy theory is a partial mapping T applying a triple
⟨α, le1, le2⟩ in (0, 1] × Sem × Sem, to each formula, where (0, 1] is the do- main of truth degrees and Sem is a set of semantics labels indicating the associated meaning for et1 and et2 respectively.
The real α is a truth degree expressing the confidence which the user of the system has in the truth of the clause C. A truth degree α =1 means that the user believes the clause C is true; on the other hand, a truth degree less

3 They are commutative, associative, and monotone in both arguments and [eti]](x, 1) = x (hence, they subsume classical conjunction {0, 1}2 → {0, 1}) [16]. Note also that, in general, meaning functions for eti connectives are not distributive.


than 1 represents the degree of uncertainty or lost of confidence on the truth of a belief; a truth degree near 0 expresses the lack of confidence on the truth of a belief. We can use labels indicating the meaning assigned to the et1 or et2 operator in the clause C . For instance, a label lei = lukasiewicz interprets an operator eti as a Lukasiewicz t-norm, that is, [[eti]](x, y)= max(0,x + y − 1). Other possible labels would be: min, if [eti]](x, y) = min(x, y); product, if [[eti]](x, y) = x · y; etc. A void value in Sem is employed to express that no meaning for et1 or et2 is selected. Note that, operationally, since void must be linked to a t-norm, void(1, x)= void(x, 1) = x.
Definition 2.3 A deﬁnite f-Prolog program, P, is a fuzzy theory such that:
Dom(P) is a set of (seq, et2)-definite program clauses or facts,
for C1, C2 ∈ Dom(P), we say C1 ≈ C2 if and only if C1 is a variant of C2
and P(C1)= P(C2), and
Dom(P)/≈ is finite.
Roughly speaking, a program can be seen as a set of pairs (C; ⟨r, l1, l2⟩), where C is a clause, r is the truth degree of the clause C, and l1, l2 are the semantics labels associated with the operators et1 and et1 for this clause. However we prefer to write C with ⟨r, l1, l2⟩, or more descriptively: C with α = r and le1 = l1 and le2 = l2. If clause C is a fact, le1 and le2 are void and we simply write: C with α = r; omitting the values for le1 and le2. Similarly, a goal G has only associated a semantic label for et2, but no initial truth degree or semantic label for et1, and we write: G with le2 = l2.

Operational Semantics and Labeled Fuzzy Prolog
Given a goal G its truth degree, α, is obtained by evaluating a sequence of Fuzzy SLD-Resolution steps leading to an empty clause. In the sequel we formalize the concepts of Fuzzy SLD-Resolution, Fuzzy SLD-Derivation and Fuzzy computer answer, with some variations with regard to the definitions that appear in [21].
Let P be a program and G a goal. Since Dom(P)/≈ is a classical definite program, the classical SLD-resolution should still work. Therefore, the main operational problem is to define the machinery for evaluating truth degrees. The truth degree of a expression is a semantic notion that must be evaluated using meaning functions. Considering a program rule C ≡ A←B1,... , Bm, with α = q, and a goal G ≡ ←A', where A' unifies with the head A of C, it is possible a SLD-resolution step leading to the resolvent G' ≡ ←(B1,... , Bm). If we want to evaluate the truth degree of G, we have to compute the truth degrees r1,..., rn of all subgoals B1,... , Bm before the truth degree q of the


rule can be applied to obtain [[et1]](q, [[et2]](r1,... , rn)), the truth degree of the goal G. We need a mechanism in order to remenber that a program rule was applied in former steps, since it is necessary to distinguish when to apply [[et1]] or [et2]]. In [21] a context grammar was introduced to solve this problem. This

grammar contains left and right marks (
and
) labeled by a real

value, to remember the exact point where a rule with α = q was applied. Hence

the previous resolution step can be annotated as:
B1,... , Bm
. For

our case, in order to manage the resolution process properly while extending the expressive power of our language, it is also necessary to expand the label mechanism to distinguish what is the meaning operator [et1]] or [[et2]] that must
be applied. Hence, we introduce the marks	and	.
We call lf-Prolog the extended language obtained by adding labeled marks and real numbers to the f-Prolog alphabet. A lf-expression is an atom, a sequence of real numbers, or a real number enclosed between labeled marks. The following definition makes use of lf-Prolog in the formalization of Fuzzy SLD-Resolution (we write o for the -possibly empty- sequence of syntactic objects o1,... , on).
Definition 3.1 Let G ≡ ←Q with le2 = [[et2]] be a lf-Prolog goal and let ϑ be a substitution, a lf-Prolog state is a pair ⟨Q; ϑ⟩. Let E be the set of lf- Prolog states. Given a f-Prolog program P, we define Fuzzy SLD-Resolution as a state transition system, whose transition relation →FR ⊆ (E × E) is the smallest relation satisfying the following rules:
Rule 1. (Clause Resolution Rule)


		
⟨X,Am,Y ; ϑ⟩→FR⟨(X,
Am is the selected atom,
θ is an mgu of Am and A,
B1,..., Bl


, Y )θ; ϑθ⟩ if

C ≡ (A ← B1,... , Bl with ⟨q, [[et1]], [[et2]]⟩) ∈ P and l ≥ 1.
Rule 2. (Fact Resolution Rule)

⟨X, Am, Y ; ϑ⟩→FR⟨(X, r, Y )θ; ϑθ⟩ if
Am is the selected atom,
θ is an mgu of Am and A, and
C ≡ (A ← with r) ∈ P.
Rule 3. ([[et1]] Resolution Rule) 4

4 In [21], the [[et1 ] resolution rule is expressed as a combination of our third and fourth rules but our reformulation is completely equivalent to the original when the labels le1 and le2 are fixed in the whole program.


			
⟨X,	r	, Y ; ϑ⟩→FR⟨X, [[et1]](q, r), Y ; ϑ⟩ if
r is a real number.
Rule 4. ([[et2]] Resolution Rule)

⟨X,	r	, Y ; ϑ⟩→FR 

⟨X,


[[et2]](r)	R(q,[[et1]],[[et2]]⟩ , Y ; ϑ⟩ if

r ≡ r1,... , rn, where n > 1, are real numbers.
All familiar logic programming concepts can be extended for the fuzzy case, assuming also that clauses involved in fuzzy SLD-computation steps are renamed before being used. In the following, symbols →F R1, →F R2, →F R3 and
→F R4 may be used for explicitly referring to the application of each one of the four fuzzy resolution rules. When needed, the exact lf-expression and/or clause used in the corresponding step, will be also annotated as a super-index of the
→FR symbol. In order to extend the notion of computer answer in our fuzzy setting, in the following definition we use id to refer to the empty substitution, Var(s) denotes the set of distinct variables occurring in the syntactic object s, and θ[Var(s)] corresponds to the substitution obtained from θ by restricting its domain, Dom(θ), to Var(s).
Definition 3.2 Let P be a f-Prolog program and G ≡ ←Q with le2 = [[et2]] be a lf-Prolog goal. A pair ⟨r; θ⟩ consisting of a real number r and a substitution θ is a fuzzy computed answer (f.c.a.) if there is a sequence E0,... , En (called f-derivation) such that:

E0 = ⟨
, Q,
; id⟩,

for each 0 ≤ i < n, Gi →FR Gi+1 is a fuzzy SLD-resolution step,
En = ⟨r; θ'⟩ and θ = θ'[Var(Q)].
We illustrate the last definition by means of the following example.
Example 3.3 Let P be the f-Prolog program,
C1 :	p(X)←q(X, Y ), r(Y )	with ⟨0.8, prod, min⟩ C2 :	q(a, Y )←s(Y )	with ⟨0.7, prod, void⟩ C3 :	q(Y, a)←r(Y )	with ⟨0.8, luka, void⟩ C4 :	r(Y )←	with 0.7
C5 :	s(b)←	with 0.9
The following is a successful f-derivation for the program P and the goal

“←p(X), r(a) with min” with f.c.a. ⟨0.504; {X/a}⟩:


⟨	→F R1C1


⟨

→F R1C2


⟨	σ2⟩	→F R2C5
⟨	→F R2C4
⟨	→F R2C4
⟨	→F R3

//since product(0.9,0.7)=0.63


⟨


⟨	0.7
0.7
; σ5⟩	→F R4

//since min(0.63,0.7)=0.63

; σ5⟩	→F R3

//since product(0.63,0.8)=0.504

⟨	; σ5⟩	→F R4

//since min(0.504,0.7)=0.504

⟨	; σ5⟩	→F R3

// since void(1,0.504)=0.504
⟨ 0.504 ; σ5⟩
where Ψ0 ≡ ⟨1, void, min⟩, Ψ1 ≡ ⟨0.8, prod, min⟩ and Ψ2 ≡ ⟨0.7, prod, max⟩, are the triples associated with the original goal and clauses C1 and C2 re- spectively. Also the substitutions σ0 = id, σ1 = {X/X1}, σ2 = {X/a, X1/a, Y1/Y2}, σ3 = {X/a, X1/a, Y1/b, Y2/b}, σ4 ={X/a, X1/a, Y1/b, Y2/b, Y3/b} and σ5 ={X/a, X1/a, Y1/b, Y2/b, Y3/b, Y4/a}.
In [21], the authors established the correctness results for the Fuzzy SLD- Resolution operational mechanism (following a technique similar as the one proposed by Lloyd, in [12], for classical logic programming), but extending all results with the treatment of truth degrees. These correctness results can be

easily adapted to our case.
As for the classical SLD-Resolution calculus, we assume the existence of a fixed selection function, also called fuzzy computation rule, deciding, for a given goal, which is the selected lf-expression to be exploited in the next fuzzy SLD-Resolution step. For instance, when building the f-derivation shown in Example 3.3, we have used a computation rule similar to the left to right selection rule of Prolog but delaying the application of the [[et1]] and [[et2]] resolution rules until all atoms have been resolved. Given a fuzzy compu- tation rule R, we say that a fuzzy SLD-derivation is via R if the selected lf-expression in every step is obtained by the application of the mapping R to the corresponding goal in that step. In the following section, we stablish in our fuzzy setting the independence of the computation rule proved in [12] for the pure logic programming case.

Independence of the Fuzzy Computation Rule
Before starting with the core of the paper, we introduce some technical nota- tions and concepts that will help us to develop our proofs. In the following we use C << P to denote an standardised apart new variant of a clause in a lf-Prolog program P such that C contains no variable which was previously met during a computation. The equational representation of a substitution θ = {x1/t1,..., xn/tn} is the set of equations ^ = {x1 = t1,..., xn = tn}. Let mgu(E) denote the most general uniﬁer of an equation set E (see [9] for a formal definition of this concept). Parallel composition of substitu- tions [14] corresponds to the notion of unification generalized to substitu- tions. Given two idempotent substitutions θ1 and θ2, the parallel composition θ1 ⇑ θ2 = mgu( ^ ∪ ^ ). The following propperty will be usefull later.
Lemma 4.1 [14] Let θ1 and θ2 be idempotent substitutions,
θ1 ⇑ θ2 = θ1mgu( ^	)= θ2mgu( ^	).
In order to prove the independence of the fuzzy computation rule, we need the following auxiliary Lemmas. The first one focuses on the preservation of substitutions in f.c.a.’s obtained on two-steps fuzzy SLD-derivations exploiting two different atoms of a given goal, with independence of the order in which they are exploited.
Lemma 4.2 Let P be a lf-Prolog program and let G	≡	←Q with
le2 = [[et2]]0 be a lf-Prolog goal, such that A and A' are different atoms in Q

and Ψ0
≡ ⟨1, void, [[et2]]0⟩. Then, ⟨	Q
; θ0⟩→	A	Q1
; θ0 θ1⟩



→	A'θ1 ⟨	Q
; θ θ θ ⟩	iff	⟨	Q
; θ ⟩→	A'


⟨	Q'

; θ0 θ' ⟩→

Aθ'	'
1 ⟨	Q
; θ0θ' θ' ⟩, where θ0θ1 θ2 = θ0θ' θ' .

1	FR 
1 2	1 2

Proof.
(⇒) Let atoms H1 and H2 be the heads of the two clauses C1, C2 << P used to exploit (instances of) atoms A and A', respectively, in the considered f-

derivation:	⟨	Q
; θ ⟩→	A⟨	Q
; θ θ ⟩→
A'θ1

⟨	Q2
; θ0θ1θ2⟩, where θ1 = mgu({A = H1}) and θ2 = mgu({A'θ1 =

H2}). Moreover, since θ0θ1θ2 /= f ail, in particular θ2 /= f ail, and hence
θ' = mgu({A' = H2}) /= f ail. Now, the following equalities hold:
θ1θ2	=
θ1mgu({A'θ1 = H2})	=	(since Dom(θ1) ∩ Var(C2)= ∅)
θ1mgu(mˆgu({A' = H2})θ1) = 
θ1mgu( ^' 1)	=	(by Lemma 4.1)

θ1θ
θ1 ⇑ θ'

=	(by Lemma 4.1)

θ' mgu( ^  ' )	=
1	θ1θ1
θ' mgu(mˆgu({A = H1})θ' ) =	(since Dom(θ' ) ∩ Var(C1)= ∅)
1	1	1
θ' mgu({Aθ' = H1})
1	1

Moreover, since θ1θ2 /= f ail then θ' mgu({Aθ'
= H1}) /= f ail and, in partic-

1	1

ular, θ' = mgu({Aθ' = H1}) /= f ail. Hence, θ1θ2 = θ' θ'
which implies that

2	1	1 2
θ0θ1θ2 = θ0θ' θ' , as we wanted to prove.
1 2
(⇐) This case can be easily proved in a similar way as the previous one, by
also exploiting the equivalence between θ1θ2 and θ' θ' .	 
1 2
The following Lemma generalizes the previous one at two different levels:
by implying the preservation of both elements in the derivation states i.e., not only substitution, but also partially evaluated truth degrees, and
by considering the whole set of resolution rules of Definition 3.1 (instead of the first pair uniquely) when applying the two resolution steps on the considered derivation.
Lemma 4.3 (Switching Lemma) Let P be a lf-Prolog program and let G ≡ 
←Q with le2 = [[et2]]0 be a lf-Prolog goal, such that E and E' are different lf-expressions in Q and Ψ0 ≡ ⟨1, void, [[et2]]0⟩. Then,



⟨	Q
iff
; θ0⟩→	E⟨	Q1
; θ1 ⟩→

'
E θ1
FR	2
; θ2 ⟩

⟨	Q	; θ ⟩→	E' ⟨
'	; θ' ⟩→
'
Eθ1
FR 
'	; θ' ⟩,

where Q2 = Q' and θ2 = θ' .

Proof. In our proof, we assume that Q ≡ X, E1, Y, E2, Z where X, Y and
Z are arbitrary sequences of valid lf-expressions (such that X is headed with

and Z ends with	)and E1 and E2, i.e., the lf-expressions se-
lected in the first and the second f-derivation steps, will be atoms (denoted by A or A'), sequences of real numbers (like r or n) or real numbers en-

closed between labeled marks (for instance,	r
or	n
, with

Ψ ≡ ⟨p, [[et1]], [[et2]]⟩, Ψ' ≡ ⟨q, [[et1]]', [[et2]]'⟩), depending on the concrete res- olution rule of Definition 3.1 used on any step. For readability reasons, we underline the selected lf-expression exploited in each derivation step. Now, we exhaustively proceed with each one of all the possible cases. Fortunately, note that it is not relevant if E1 is to the left or to the right of E2 and, moreover, the case where the first step is done with rule i and the second one with rule j is perfectly analogous to the case where first step is done with rule j and the second one with rule i, which drastically reduces the number of alternatives.
First step with Rule 1 and second step with Rule 1.
Assume that: C1 ≡ (H1 ← B1; Ψ) << P and C2 ≡ (H2 ← B2; Ψ') << P, with Ψ ≡ ⟨p, [[et1]], [[et2]]⟩ and Ψ' ≡ ⟨q, [[et1]]', [[et2]]'⟩. Then,

⟨X, A, Y, A', Z; θ0⟩	→F R1C1



⟨(X,

	
, Y, A', Z)θ1; θ1⟩	→F R1C2


iff


⟨(X,


, Y, 


, Z)θ2; θ2⟩

⟨X, A, Y, A', Z; θ0⟩	→F R1C2

⟨(X, A, Y, 
, Z)θ' ; θ' ⟩	→	C1


⟨(X,

, Y, 
1	1	F R1
, Z)θ' ; θ' ⟩

2	2
where, by Lemma 4.2 we have that θ2 = θ' , which also implies that the first element of the final states in both derivations are syntactically identical, as we wanted to prove.
First step with Rule 1 and second step with Rule 2.
Assume that: C1 ≡ (H1 ← B1; Ψ) << P and C2 ≡ (H2 ←; q) << P, with

Ψ ≡ ⟨p, [[et1]], [[et2]]⟩. Then,

⟨X, A, Y, A', Z; θ0⟩	→F R1C1



⟨(X,

	
, Y, A', Z)θ ; θ ⟩ →	C2


iff


⟨(X,

	
, Y, q, Z)θ2; θ2⟩

⟨X, A, Y, A', Z; θ0⟩	→F R2C2
⟨(X, A, Y, q, Z)θ' ; θ' ⟩	→F R1C1

⟨(X,
1	1
, Y, q, Z)θ' ; θ' ⟩

2	2
where, by Lemma 4.2 we have that θ2 = θ' , which also implies that the first element of the final states in both derivations are syntactically identical, as we wanted to prove.
First step with Rule 1 and second step with Rule 3.
Assume that: C1 ≡ (H1 ← B1; Ψ) << P with Ψ ≡ ⟨p, [[et1]], [[et2]]⟩, and Ψ' ≡ ⟨q, [[et1]]', [[et2]]'⟩. Then,


	
⟨X, A, Y,	n


, Z; θ0⟩	→F R1C1



⟨(X,


, Y, 
n


, Z)θ1; θ1⟩ →F R3


iff


⟨(X,

⟨X, A, Y, 



n

	
, Y, [[et1]]'(q, n), Z)θ1; θ1⟩

, Z; θ0⟩	→F R3


		
⟨X, A, Y, [[et1]]'(q, n), Z; θ0⟩	→F R1C1



⟨(X,
as we wanted to prove.

	
, Y, [[et1]]'(q, n), Z)θ1; θ1⟩


First step with Rule 1 and second step with Rule 4.
Assume that: C1 ≡ (H1 ← B1; Ψ) << P with Ψ ≡ ⟨p, [[et1]], [[et2]]⟩, and Ψ' ≡ ⟨q, [[et1]]', [[et2]]'⟩. Then,


	
⟨X, A, Y, 


, Z; θ0⟩	→F R1C1



⟨(X,


, Y, 


, Z)θ1; θ1⟩ →F R4



⟨(X,

	
, Y, [[et2]]'(r), Z)θ1; θ1⟩



iff

	
⟨X, A, Y, 


, Z; θ0⟩	→F R4


		
⟨X, A, Y, [[et2]]'(r), Z; θ0⟩	→F R1C1



⟨(X,

	
, Y, [[et2]]'(r), Z)θ1; θ1⟩

as we wanted to prove.
First step with Rule 2 and second step with Rule 2.
Assume that: C1 ≡ (H1 ←; p) << P and C2 ≡ (H2 ←; q) << P. Then,

⟨X, A, Y, A', Z; θ0⟩	→F R2C1

⟨(X, p, Y, A', Z)θ1; θ1⟩ →F R2C2


iff

		
⟨(X, p, Y, q, Z)θ2; θ2⟩

⟨X, A, Y, A', Z; θ0⟩	→F R2C2
⟨(X, A, Y, q, Z)θ' ; θ' ⟩ →F R2C1

1	1
⟨(X, p, Y, q, Z)θ' ; θ' ⟩
2	2
where, by Lemma 4.2 we have that θ2 = θ' , which also implies that the first element of the final states in both derivations are syntactically identical, as we wanted to prove.
First step with Rule 2 and second step with Rule 3.
Assume that: C1 ≡ (H1 ←; q) << P and Ψ ≡ ⟨p, [[et1]], [[et2]]⟩. Then,


	
⟨X, A, Y,	n


, Z; θ0⟩	→F R2C1


		
⟨(X, q, Y,	, Z)θ1; θ1⟩ →F R3

⟨(X, q, Y, [[et1]](p, n), Z)θ1; θ1⟩
iff

⟨X, A, Y,	, Z; θ0⟩ →F R3

⟨X, A, Y, [[et1]](p, n), Z; θ0⟩	→F R2C1

⟨(X, q, Y, [[et1]](p, n), Z)θ1; θ1⟩
as we wanted to prove.
First step with Rule 2 and second step with Rule 4.



Assume that: C1 ≡ (H1 ← B1; q) << P and Ψ ≡ ⟨p, [[et1]], [[et2]]⟩. Then,


	
⟨X, A, Y, 

⟨(X, q, Y, 


, Z; θ0⟩	→F R2C1

, Z)θ1; θ1⟩ →F R4


		
⟨(X, q, Y, [[et2]](r), Z)θ1; θ1⟩
iff

⟨X, A, Y,	, Z; θ0⟩ →F R4

⟨X, A, Y, [[et2]](r), Z; θ0⟩	→F R2C1

⟨(X, q, Y, [[et2]](r), Z)θ1; θ1⟩
as we wanted to prove.
First step with Rule 3 and second step with Rule 3.
Assume that Ψ ≡ ⟨p, [[et1]], [[et2]]⟩ and Ψ' ≡ ⟨q, [[et1]]', [[et2]]'⟩. Then,

		

⟨X,
, Y,	n
, Z; θ0⟩ →F R3


		

⟨X, [[et1]](p, r), Y, 
n
, Z; θ0⟩	→F R3




iff

		
⟨X, [[et1]](p, r), Y, [[et1]]'(q, n), Z; θ0⟩



⟨X,	r


, Y, 
n


, Z; θ0⟩ →F R3



⟨X,

	
, Y, [[et1]]'(q, n), Z; θ0⟩	→F R3


		
⟨X, [[et1]](p, r), Y, [[et1]]'(q, n), Z; θ0⟩
as we wanted to prove.
First step with Rule 3 and second step with Rule 4.
Assume that Ψ ≡ ⟨p, [[et1]], [[et2]]⟩ and Ψ' ≡ ⟨q, [[et1]]', [[et2]]'⟩. Then,

		

⟨X,
, Y, 
, Z; θ0⟩ →F R3


		
⟨X, [[et1]](p, r), Y,	, Z; θ0⟩	→F R4


iff

		
⟨X, [[et1]](p, r), Y, [[et2]]'(n), Z; θ0⟩


		

⟨X,	r
, Y, 
, Z; θ0⟩ →F R4





⟨X,

	
, Y, [[et2]]'(n), Z; θ0⟩	→F R3


		
⟨X, [[et1]](p, r), Y, [[et2]]'(n), Z; θ0⟩
as we wanted to prove.
First step with Rule 4 and second step with Rule 4.
Assume that Ψ ≡ ⟨p, [[et1]], [[et2]]⟩ and Ψ' ≡ ⟨q, [[et1]]', [[et2]]'⟩. Then,



⟨X,


, Y, 


, Z; θ0⟩ →F R4


		
⟨X, [[et2]](r), Y,	, Z; θ0⟩	→F R4


iff

		
⟨X, [[et2]](r), Y, [[et2]]'(n), Z; θ0⟩



⟨X,


, Y, 
, Z; θ0⟩ →F R4





⟨X,

	
, Y, [[et2]]'(n), Z; θ0⟩	→F R4


		
⟨X, [[et2]](r), Y, [[et2]]'(n), Z; θ0⟩
as we wanted to prove.

Finally, we can formalize and prove the main result of this section.
Theorem 4.4 (Independence of the Fuzzy Computation Rule) Let P be a lf-Prolog program, and G ≡ ←Q with le2 = [[et2]] be a lf-Prolog goal. Then, for any pair of different fuzzy computation rules R and R', we have that:

⟨	Q
; id⟩ → 
n ⟨r; θ⟩	iff	⟨	Q
; id⟩ →	n
⟨r; θ⟩

FRR	FRR'
where Ψ ≡ ⟨1, void, [[et2]]⟩ and n is the (same) number of fuzzy SLD-resolution steps in both derivations.
Proof. Immediate by repeatedly applying the Switching Lemma 4.3. 

Unfolding-based Transformations for Fuzzy Programs
In essence, the unfolding transformation traditionally considered in pure logic programming consists in the replacement of a program clause C by the set of clauses obtained after applying a symbolic computation step in all its possible forms on the body of C [15]. In [5] we gave a first approach to the fuzzy


extension of unfolding, by considering the complete set of fuzzy SLD-resolution rules in Definition 3.1 (when performing symbolic computation steps) in order to generate all alternative clauses. However, a deeper look at Definition 3.1, reveals us that only rules 1 and 2 reproduce the essence of classical logic programming by exploiting atoms and generating unifiers and, in this sense, they are more appropriate to be used during the unfolding process to simulate the original definition. On the other hand, rules 3 and 4 neither reduce atoms nor produce unifiers, but simply perform numerical manipulations to produce truth degrees (what, in some way, reflects the fuzzy component of this enriched context). Therefore, rules 3 and 4 should be more appropriately used for defining other kind of transformations (as we will see in Definition 5.3).
In this paper we adopt this new point of view and in the next two sections, we define a set of program transformations based on (fuzzy variants of) the classical unfolding operation for pure logic programs defined in [17]. We also prove their strong correctness, i.e., they are sound and complete w.r.t. the semantics of fuzzy computed answers obtained by fuzzy SLD-resolution.

The Fuzzy Unfolding Transformation Rule
As we have seen in the previous sections, the differences between f-Prolog and lf-Prolog programs appear only at the syntactic level: whereas the body B of a (non unit) f-Prolog program clause (which in essence, is no more than a simple goal, that is, an atom or a conjunction of atoms) respects the grammar B → B,... ,B | atom, we need to enrich this set of grammar rules with
B →	B	| number, if we really want to cope with the possibility
of including marks and real numbers in the body of lf-Prolog clauses (which intuitively have the same structure of any initial, intermediate or final goal appearing in fuzzy SLD-derivations). This implies that any f-Prolog program is also a lf-Prolog program, although the contrary is not always true (i.e., the set of f-Prolog programs is a proper subclass of the set of lf-Prolog programs). Apart from this simple fact (which, on the other hand, is mandatory to define the fuzzy SLD-resolution principle) both languages share the same operational semantics.
On the other hand, note that the application of rules 1 and 2 always gen- erates clauses whose bodies include marks or numbers which implies that an unfolding transformation based on these rules is able to preserve the syntactic structure of lf-Prolog programs but, even in the case that original programs be also f-Prolog programs, the transformed ones will never belong to this sub- class: the marks or real numbers incorporated into the transformed clauses by unfolding steps force the lost of the original f-Prolog syntax. In order to


avoid this inconvenience, our transformation rules focus on the general frame- work of lf-Prolog programs instead of the more restricted subclass of f-Prolog programs. Note also that this fact does not suppose a problem in practice: the most important purpose of transformations rules, apart from preserving the program semantics, is to optimize code, independently of the object lan- guage. Classical fold/unfold based transformation systems optimize programs by returning code which uses the same source language, but unfolding has also played important roles in the design of compilers (see [6]) which generate an object code written in a target language. In this sense, our transformation system can be seen as a mixed technique that optimizes f-Prolog programs and compiles it into lf-Prolog programs, with the advantage in our case that both programs are executable with exactly the same operational principle.
In the following, we consider a fixed transformation sequence (P0,... , Pk), k ≥ 0, where we only require that the initial program P0 be an f-Prolog program since the remaining ones will necessarily adopt the lf-Prolog syntax.
Definition 5.1 [Fuzzy Unfolding]
Let (P0,... , Pk) be a transformation sequence of lf-Prolog programs starting from an f-Prolog program P0. Assume that C ≡ (H ← B with Ψ) ∈ Pk is a (non unit) lf-Prolog program clause, such that Ψ ≡ ⟨p, [[et1]], [[et2]]⟩ and A is an atom included in the body B. Then, the next program Pk+1 in the transformation sequence can be obtained by fuzzy unfolding of clause C at atom A in program Pk as follows: Pk+1 = (Pk − {C}) ∪ {Hσ ← B' with Ψ |

⟨
; id⟩→	A
; σ⟩}.

There are some remarks to do regarding our definition. Similarly to the classical SLD-resolution based unfolding rule presented in [17], the substitu- tions computed by resolution steps during unfolding are incorporated to the transformed rules in a natural way, i.e., by applying them to the head of the clause. On the other hand, the propagation of truth degrees during the fuzzy unfolding process is done at two different levels: by directly assigning the com- plete tuple Ψ (containing the truth degree p and labels for [et1]] and [[et2]]) of the original clause to the transformed one, and by introducing marks and/or real numbers in its body. The following example illustrates these facts.
Example 5.2 Consider again the set of clauses of Example 3.3 as the initial program, P0, of a transformation sequence. It is easy to see that the unfolding of clause C2 w.r.t. P0 (exploiting the second rule of Definition 3.1) generates the new program P1 = (P0 − {C2}) ∪ {C6}, where C6 is the new unfolded rule “q(a, b)←0.9 with ⟨0.7, product, void⟩”.
On the other hand, if we want to unfold now clause C1 in program P1, we

must firstly generate the following one-step Fuzzy SLD-derivations 5 :

⟨	q(X, Y ), r(Y )
; id⟩ →FR1 C6




⟨
0.9
, r(b)
; σ1⟩

⟨	q(X, Y ), r(Y )
; id⟩ →FR1 C3




⟨
r(Y1)
, r(a)
; σ2⟩

where Ψ1 ≡ ⟨0.8, prod, min⟩, Ψ6 ≡ ⟨0.7, prod, max⟩ and Ψ3 ≡ ⟨0.8, luka, void⟩, are the triples corresponding to clauses C1, C6 and C3 respectively; also the uni- fiers σ1 = {X/a, Y/b} and σ2 = {X/Y1,Y/a}.
So, the unfolded program P2 = (P1 − {C1}) ∪U where U contains the new clauses:

C7 : p(a) ←
0.9
, r(b)	with ⟨0.8, prod, min⟩



C8 : p(Y1)←
r(Y1)
, r(a) with ⟨0.8, prod, min⟩

Finally, by performing a new resolution step with the second rule of Definition
3.1 on atom r(b) in the body of clause C7, we obtain the new unfolded program
P3 = {C3, C4, C5, C6, C8, C9} (note that clauses C1, C2 and C7 have been removed

after being unfolded) where C9 ≡ p(a) ←
with ⟨0.8, prod, min⟩.
0.9
, 0.7

It is important to note now that the application of this last rule to the goal “←p(X), r(a) with min” simulates the effects of the first four resolution steps shown in the derivation of Example 3.3, which evidences the improvements achieved by unfolding on transformed programs.

The T-Norm Replacement Transformation Rule
Although we have seen in the previous section that the actions performed by unfolding on the body of transformed clauses drastically rebound in the com- putation/propagation of truth degrees when solving goals against transformed programs, the ’compiled-in’ information collected on the body of unfolded rules admits significant numerical manipulations to eliminate or, at least to simplify, marks and real numbers. The following transformation performs this task in a very similar way to rules 3 and 4 of Definition 3.1.
Definition 5.3 [T-Norm Replacement]

5  Both steps are performed with Rule 1 of Definition 3.1 (the first one uses clause C6 and the second one clause C3) and exploit the same selected -underlined- atom q(X, Y ).


Let (P0,... , Pk) be a transformation sequence of lf-Prolog programs starting from an f-Prolog program P0. Assume that C ≡ (H ← B with Ψ) ∈ Pk is a (non unit) lf-Prolog program clause, such that Ψ ≡ ⟨p, [[et1]], [[et2]]⟩. Then, the next program Pk+1 in the transformation sequence can be obtained by T- Norm Replacement of clause C in program Pk as follows: Pk+1 = (Pk −{C}) ∪
{H ← B' with Ψ'}, such that:

if B ≡ (X,	r	, Y ), where r is a real number, then

B' ≡ (X, [[et1 ]]'(p', r), Y ) and Ψ' ≡ Ψ.

if B ≡ (X,	r	, Y ), where r ≡ r1,... , rn(n > 1) are


	
real numbers, B' ≡ (X,  L '	'
'	[[et2 ]]'(r) R '


'	'	, Y ) and Ψ' ≡ Ψ.


	
if B ≡ r, where r is a real number, then B' is empty and Ψ' ≡ [[et1 ]](p, r).

if B ≡ r, where r ≡ r1,... , rn (n > 1) are real numbers, then B' ≡ [[et2 ]](r) and Ψ' ≡
⟨p, [[et1 ]], void⟩.
The previous definition remembers the so called “algebraic replacement” traditionally used in transformation systems for pure functional programs [3,15], where a functional expression, in a program rule, is replaced by other equivalent expression w.r.t. a given algebraic property. For instance, the pure functional rule f(X, Y) → X + Y can be transformed by algebraic replacement into f(X, Y) → Y + X, thanks to the commutativity of the sum. Observe also that similarly to many other pure functional transformation rules (including algebraic replacement and pure functional unfolding) our T-Norm replacement replaces an original clause by a single new one, which contrasts with the un- folding rule defined for pure logic and/or fuzzy logic programs. All these facts are not surprising, since the fuzzy component of our logic language has a func- tional taste, in the sense that the numerical manipulations performed by rules 3 and 4 of Definition 3.1 recall functional evaluations. This property is also in- herited by Definition 5.3 where we define some particular instances of algebraic replacement, but exclusively focused on t-norm operations. For that reason, in our fuzzy setting, we decided to use the name of “T-Norm replacement” instead of “algebraic replacement” to designate this kind of transformations. Apart from algebraic replacement, the T-Norm replacement transforma- tion has also some similarities with fuzzy unfolding. In fact, note that the following unfolding-like definition subsumes the first kind of T-Norm replace-



ment: Pk+1 = (Pk − {C}) ∪ {H ← B' with Ψ | ⟨
; id⟩→F R3

⟨	; σ⟩}, where a simple fuzzy SLD-resolution step of kind 3 have
been applied for performing a T-Norm replacement of type [[et1]]. Observe


also that, by replacing →F R3 with →F R4 in the previous definition, we ob- tain an alternative, unfolding-like definition, of the second and fourth kinds of T-Norm replacement (depending on which is the [[et2 ]-based lf-expression

exploited: inside of B or directly the whole	expression). Anyway,
the T-Norm replacement of kind 3 has never been considered in the literature, neither implicitly nor explicitly (although it was proposed as future work in [5]), and its application is able to transform a non unit program clause into a fact (i.e., a clause with empty body). Observe that no other transformation has this capability, which indirectly imply that, in the best case, although programs to be transformed by this transformation must necessarily belong to the lf-Prolog superclass, once transformed by T-Norm replacement of kind 3, they may recover the f-Prolog syntax.
The following example illustrates the application of transformations based on T-Norm replacement and some of their advantages.


Example 5.4 Let us continue with the transformation sequence started in example 5.2 by performing now some T-Norm replacements. So, the next pro- gram in the sequence is P4 = (P3 −{C9}) ∪ {C10}, where C10 ≡ p(a) ←0.63, 0.7 with ⟨0.8, prod, min⟩. It has been obtained by T-Norm replacement of kind 1 on clause C9 (note that prod(0.9, 0.7) = 0.63). Moreover, since min(0.63, 0.7) = 0.63, a T-Norm replacement of kind 4 on this last clause generates the new one C11 ≡ p(a) ←0.63 with ⟨0.8, prod, void⟩. Finally clause C11 becomes in the fact C12 ≡ p(a) ← with 0.504 (since prod(0.63, 0.8)= 0.504) after the last T-Norm replacement of kind 3. Hence, the final program is P6 = {C3, C4, C5, C6, C8, C12} and now the derivation shown in example 3.3 can reduce its length in six steps thanks to the use of clause C12, which evidences once again the improve- ments achieved not only by unfolding, but also by T-Norm replacement, on transformed programs.


The following section is devoted to formalize the best properties one can expect of a transformation system like the our, namely:
on the theoretical side, the exact and total correspondence between fuzzy computed answers for goals executed against the original and the trans- formed programs, and
ii) on the practical side, the gains in efficiency when executing transformed programs by reducing the number of fuzzy SLD-resolution steps needed to solve a goal.

Properties of Fuzzy Transformations

The following Lemma, which can be seen as the counterpart of Lemma 4.2 (preservation of substitutions in f.c.a.’s on interchangeable derivation steps) is auxiliary. Intuitively it shows that, even in the case that two derivation steps can not be switched since the second one exploits an lf-expression introduced on the considered goal by the first one, its effect (w.r.t. fuzzy computed answer substitutions) can be simulated by a single step performed with a transformed clause obtained by fuzzy unfolding.


Lemma 6.1 Let P be a lf-Prolog program, G ≡ ←Q with le2 = [et2]]0 a
lf-Prolog goal, Ψ0 ≡ ⟨1, void, [[et2]]0⟩ and C1, C2 << P, where C1 is a non

unit clause. Then, ⟨	Q
; θ ⟩→
C1 ⟨	Q
; θ θ ⟩→	C2

⟨	Q2	; θ0θ1θ2⟩ where the second steps exploits an atom introduced

in Q1 by the ﬁrst step, iff ⟨	Q
; θ0⟩→F R1C3 ⟨	Q3
; θ0θ3⟩,

where C3 is obtained by fuzzy unfolding of C1 with C2 and θ0θ1θ2 = θ0θ3 [Var(Q)].



Proof.
(⇒) Let C1 ≡ (H1←X1, A1, Y1; Ψ) where Ψ ≡ ⟨p, [[et1]], [[et2]]⟩, let H2 be the atom at the head of clause C2 and let Q ≡ X, A, Y where X, Y, X1 and Y1 are arbitrary sequences of valid lf-expressions and A is the atom se- lected in Q by the considered computation rule. Then, in the f-derivation

⟨	Q	; θ ⟩→
C1 ⟨	Q
; θ θ ⟩→	C2

⟨	Q2	; θ0θ1θ2⟩  we  have  that:	θ1	=	mgu({A	=	H1}),

Q1 ≡ (X,  LΨ  X1, A1, Y1	, Y )θ1. Moreover, if A1θ1 is the atom selected
in Q1 by the considered computation rule, then θ2 = mgu({A1θ1 = H2}). Now, consider σ = mgu({A1 = H2}). Then, the following equalities hold:

θ1θ2	=
θ1mgu({A1θ1 = H2}) =	(since Dom(θ1) ∩ Var(C2)= ∅)


θ1mgu(mˆgu({A1 = H2})θ1) = 
θ1mgu(σ^θ1)	=	(by Lemma 4.1)
θ1 ⇑ σ	=	(by Lemma 4.1)
σmgu( ^  )	=
σmgu(mˆgu({A = H1})σ)	=	(since Dom(σ) ∩ Var(Q)= ∅)
σmgu({A = H1σ}).
Moreover, since θ1θ2 /≡ f ail, then σ /≡ f ail and thus there exists a clause C3 obtained by unfolding (atom A1 in the body of) C1 by using C2, such that the head of C3 is the atom H1σ. Now, since mgu({A = H1σ}) /≡ f ail, the following f-resolution step done on the selected atom A in Q ≡ X, A, Y

can be proved: ⟨	Q
; θ0⟩→F R1C3 ⟨	Q3
; θ0θ3⟩, where θ3 =

mgu({A = H1σ}). Finally, since θ1θ2 = σθ3, then θ0θ1θ2 = θ0σθ3, and since Dom(σ) ∩ Var(Q) = ∅ and Dom(σ) ∩ Dom(θ0) = ∅, we have that θ0θ1θ2 = θ0θ3 [Var(Q)], as we wanted to prove.
(⇐) This case can be easily proved in a similar way as the previous one, by also exploiting the equivalence between θ1θ2 and σθ3.	 
In order to prove Theorem 6.4, we treat separately both claims of the double implication, since the strong correctness of fuzzy unfolding or T-Norm Re- placement implies both strong soundness (⇐) and strong completeness (⇒).
Theorem 6.2 (Strong Soundness) Let P be a lf-Prolog program and let G ≡ ←Q with le2 = [[et2]]0 be a lf-Prolog goal. If P' is an lf-Prolog program ob- tained by fuzzy unfolding or by T-Norm Replacement of P,  then

⟨	Q	; id⟩→
∗⟨r; θ⟩ in P  if ⟨	Q
; id⟩→
∗⟨r; θ'⟩ in P',

where θ = θ'[Var(Q)] and Ψ0 ≡ ⟨1, void, [[et2]]0⟩.

Proof. Let D' ≡ [⟨	Q
; id⟩→
∗⟨r; θ⟩] be the (generic) successful

derivation for G in P' that we plan to simulate by constructing a new deriva- tion D in P. The construction of D is done by induction on the length of D', n. Since the case base, i.e. n = 0, is trivial, we proceed with the general case when

n > 0. Then, D' ≡ [⟨	Q
; id⟩→
FR⟨	Q'
; ϑ⟩→
∗⟨r; θ'⟩].

If the first step of D' has been given with the second, third or fourth rule of Definition 3.1, or, even it is has been performed with the first one but using a clause also belonging to P, then the claim follows by the inductive hypothesis. Otherwise, this initial step is done with rule 1 using a clause C' that has been obtained by unfolding or T-Norm Replacement other clause C ∈ P. Since the


unfolding step has been performed with one of the two rules of Definition 3.1, and the T-Norm Replacement step has been performed with one of the three rules of Definition 5.3 we treat each case separately.

Unfolding based on Rule 1.
Let C ≡ (H1 ← X1, A1, Y1; Ψ) ∈ P with Ψ ≡ ⟨p, [[et1]], [[et2]]⟩ and C2 ≡ (H2 ← B2; Ψ') ∈ P with Ψ' ≡ ⟨q, [[et1]]', [[et2]]'⟩ such that, by unfolding C w.r.t. C2 using the Definition 5.1, we obtain the clause C' ≡ ((H1 ←



X1,


B2

		
, Y1)σ; Ψ) ∈ P'. Now, assume that Q ≡ X, A, Y



where X and Y are arbitrary sequences of valid lf-expressions and A is the selected atom. Then, D' has the following form:

⟨X, A, Y ; id⟩	→F R1C'

⟨(X,	,
, Y	, Y )σγ; σγ⟩ →	∗


⟨r; θ'⟩
1	FR 


And now, the first step of D' can be simulated in derivation D by using clauses C and C2 of P as follows:

⟨X, A, Y ; id⟩	→F R1C



⟨(X,


, A1, Y1


, Y )α; α⟩	→
C2
F R1

⟨(X,	,
, Y	, Y )αβ; αβ⟩ →	∗


⟨r; θ⟩
1	FR 


By Lemma 6.1 we can conclude that αβ = σγ[Var(Q)], and hence the third state in D coincides syntactically with the second one in D'. More- over, by the inductive hypothesis θ = θ'[Var(Q)] and hence the entire f-derivations D and D' are equivalents, as we wanted to prove.

Unfolding based on Rule 2.
Let C ≡ (H1 ← X1, A1, Y1; Ψ) ∈ P with Ψ ≡ ⟨p, [[et1]], [[et2]]⟩ and C2 ≡ (H2 ←; q) ∈ P such that, by unfolding C w.r.t. C2 using the Definition 5.1, we obtain: C' ≡ ((H1 ← X1, q, Y1)σ; Ψ) ∈ P'. Then, D' has the



following form:

	
⟨X, A, Y ; id⟩	→F R1C'

⟨(X,
, q, Y
, Y )σγ; σγ⟩ →	∗

1	FR 
⟨r; θ'⟩
And now, the first step of D' can be simulated in derivation D by using clauses C and C2 of P as follows:

⟨X, A, Y ; id⟩	→F R1C



⟨(X,


, A1, Y1


, Y )α; α⟩  →
C2
F R2

⟨(X,
, q, Y
, Y )αβ; αβ⟩ →	∗

1	FR 
⟨r; θ⟩
By Lemma 6.1 we can conclude that αβ = σγ[Var(Q)], and hence the third state in D coincides syntactically with the second one in D'. More- over, by the inductive hypothesis θ = θ'[Var(Q)] and hence the entire f-derivations D and D' are equivalents, as we wanted to prove.

T-Norm Replacement of kind 1.
Let C ≡ (H1 ← X1,	n	, Y1; Ψ) ∈ P with Ψ ≡ ⟨p, [[et1]], [[et2]]⟩,
and let Ψ' ≡ ⟨q, [[et1]]', [[et2]]'⟩. By T-Norm Replacement of clause C using the rule of kind 1 in Definition 5.3, we obtain the clause C' ≡ (H1 ←
X , [[et' ]](q, n), Y ; Ψ) ∈ P'. Then, D' has the following form:
1	1	1

⟨X, A, Y ; id⟩	→F R1C'

⟨(X,
, [[et ]]'(q, n), Y
, Y )α; α⟩ →	∗

1	1	FR 
⟨r; θ'⟩
And now, the first step of D' can be simulated in P by giving two resolution steps in D: the first one with rule 1 using clause C and the second one with rule 3, as follows:

⟨X, A, Y ; id⟩	→F R1C



⟨(X,  LΨ	X1,


n	, Y1


, Y )α; α⟩ →F R3



⟨(X,
⟨r; θ⟩


, [[et1]]'(q, n), Y1


, Y )α; α⟩	→	∗


Since the third state in D coincides syntactically with the second one in
D', our claim holds by the inductive hypothesis.


T-Norm Replacement of kind 2.

Let C ≡ (H1 ← X1,


, Y1; Ψ) ∈ P, with Ψ ≡ ⟨p, [[et1]], [[et2]]⟩

and let Ψ' ≡ ⟨q, [[et1]]', [[et2]]'⟩. By T-Norm Replacement of C using the rule of	kind	2	in	Definition	5.3,	we	obtain	the	new	clause:



C' ≡ (H1 ← X1,
following form:
[[et2]]'(n)


, Y1; Ψ) ∈ P'. Then, D' has the


	
⟨X, A, Y ; id⟩	→F R1C'

⟨(X,
,	[[et ]]'(n)	, Y
, Y )α; α⟩ →	∗

2	1	FR 
⟨r; θ'⟩
And now, the first step of D' can be simulated with clauses of P by giving two resolution steps in D: the first one with rule 1 using clause C and the second one with rule 4, as follows:

⟨X, A, Y ; id⟩	→F R1C



⟨(X,  LΨ	X1,


, Y1


, Y )α; α⟩	→F R4

⟨(X,
,	[[et ]]'(n)	, Y
, Y )α; α⟩ →	∗


⟨r; θ⟩
2	1	FR 

Since the third state in D coincides syntactically with the second one in
D', our claim holds by the inductive hypothesis.
T-Norm Replacement of kind 3.
Let C ≡ (H1 ← n; Ψ) ∈ P, with Ψ ≡ ⟨p, [[et1]], [[et2]]⟩, such that, by T- Norm Replacement of C using the rule of kind 3 in Definition 5.3, we obtain the new clause C' ≡ (H1 ← ; [[et1]](p, n)) ∈ P'. Then, D' has the following form:

⟨X, A, Y ; id⟩	→F R2C'
⟨(X, [[et1]](p, n), Y )α; α⟩ →	∗
FR 
⟨r; θ'⟩
And now, the first step of D' can be simulated with clauses of P by giving two resolution steps in D: the first one with rule 1 using clause C and

the second one with rule 3, as follows:

⟨X, A, Y ; id⟩	→F R1C

⟨(X,	n	, Y )α; α⟩ →F R3

⟨(X, [[et1]](p, n), Y )α; α⟩	→	∗
⟨r; θ⟩
Since the third state in D coincides syntactically with the second one in
D', our claim holds by the inductive hypothesis.
T-Norm Replacement of kind 4.
Let C ≡ (H1 ← n; Ψ) ∈ P, with Ψ ≡ ⟨p, [[et1]], [[et2]]⟩, such that, by T- Norm Replacement of C using the rule of kind 4 in Definition 5.3, we obtain the new clause C' ≡ (H1 ← [[et2]](n); Ψ) ∈ P'. Then, D' has the following form:

⟨X, A, Y ; id⟩	→F R1C'

⟨(X,
[[et ]](n)

, Y )α; α⟩ →	∗

2	FR 
⟨r; θ'⟩
And now, the first step of D' can be simulated with clauses of P by giving two resolution steps in D: the first one with rule 1 using clause C and the second one with rule 3, as follows:

⟨X, A, Y ; id⟩	→F R1C

⟨(X,	, Y )α; α⟩	→F R4

⟨(X,
[[et ]](n)
, Y )α; α⟩ →	∗

2	FR 
⟨r; θ⟩
Since the third state in D coincides syntactically with the second one in
D', our claim holds by the inductive hypothesis.

Now, we proceed with the counterpart of the previous Theorem, that is, the strong completeness.

Theorem 6.3 (Strong Completeness) Let P be a lf-Prolog program and let G ≡ ←Q with le2 = [et2]]0 be a lf-Prolog goal. If P' is an lf-Prolog program obtained by fuzzy unfolding or T-Norm Replacement of P, then,



⟨	Q	; id⟩→
∗⟨r; θ'⟩ in P'  if ⟨	Q
; id⟩→
∗⟨r; θ⟩ in P,

where θ' = θ[Var(Q)] and Ψ0 ≡ ⟨1, void, [[et2]]0⟩.
Proof. Our proof consists in simulating in P' a re-ordered successful f-deriva-

tion originally performed in P. So, let D
≡ [⟨	Q
; id⟩→
n⟨r; θ ⟩]

be a (generic) n-steps successful f-derivation for G in P. Assume now that C ∈ P is the clause unfolded in P which obviously does not belong to P'. Any existing step done with clause C in D0 introduces an instance of the body of C in the next state of the derivation. Since we are dealing which a successful derivation, this instanciated body of C must necessarily be reduced in the im- mediately next step or in subsequent ones. For the second case, we can safely interchange the step done with clause C and the next one, by application of the Switching Lemma 4.3. Moreover, by repeated application of this Lemma,

we can obtain a new n-steps f-derivation D ≡ [⟨	Q
; id⟩→
n⟨r; θ⟩]

in P verifying θ = θ0[Var(Q)], where any step (if it exists) using the clause C unfolded in P, is followed by other step exploiting an lf-expression just in- troduced by the previous step (i.e., belonging to the instanciated body of C). We say that D is an successful f-derivation re-ordered w.r.t. clause C.
Now, and similarly to the previous theorem, we are going to simulate D in P' by constructing a new derivation D' using the clauses of P' and fol- lowing an schema perfectly analogous to the one used in Theorem 6.2, but inverting now the use of terms P and P' (and related ones). The construc- tion of D' is done by induction on the length of D, n. Since the case base,
i.e. n = 0, is trivial, we proceed with the general case when n > 0. Then,

D ≡ [⟨	Q
; id⟩→
FR⟨	Q'
ϑ⟩→
∗⟨r; θ⟩]. If the first step of

D has been given with the second, third or fourth rule of Definition 3.1, or, even it is has been performed with the first one but using a clause also belong- ing to P', then the claim follows by the inductive hypothesis. Otherwise, this initial step is done with rule 1 using a clause C that, once it is transformed, generates the new clause C' ∈ P'. Since the unfolding step has been performed with one of the four rules of Definition 5.1, and the T-Norm Replacement step fulfil one of de four rules of Definition 5.3 we treat each case separately.

Unfolding based on Rule 1.
Let C ≡ (H1 ← X1, A1, Y1; Ψ) ∈ P with Ψ ≡ ⟨p, [[et1]], [[et2]]⟩ and C2 ≡
(H2 ← B2; Ψ') ∈ P with Ψ' ≡ ⟨q, [[et1]]', [[et2]]'⟩. By unfolding C w.r.t.
C2 we obtain: C' ≡ ((H1 ← X1,	B2	, Y1)σ; Ψ) ∈ P'. Now,

assume that Q ≡ X, A, Y where X and Y are arbitrary sequences of valid


lf-expressions and A is the selected atom. Then, since D is a successful f-derivation reordered w.r.t. clause C, then it has the following form:

⟨X, A, Y ; id⟩	→F R1C



⟨(X,


, A1, Y1


, Y )α; α⟩	→
C2
F R1

⟨(X,	,
, Y	, Y )αβ; αβ⟩ →	∗


⟨r; θ⟩
1	FR 

And now, the first two steps of D can be simulated in P' by using clause
C' in derivation D' as follows:

⟨X, A, Y ; id⟩	→F R1C'

⟨(X,	,
, Y	, Y )σγ; σγ⟩ →	∗


⟨r; θ'⟩
1	FR 

By Lemma 6.1 we can conclude that αβ = σγ[Var(Q)], and hence the third state in D coincides syntactically with the second one in D'. More- over, by the inductive hypothesis θ = θ'[Var(Q)] and hence the entire f-derivations D and D' are equivalents, as we wanted to prove.
Unfolding based on Rule 2.
Let C ≡ (H1 ← X1, A1, Y1; Ψ) ∈ P with Ψ ≡ ⟨p, [[et1]], [[et2]]⟩ and C2 ≡ (H2 ←; q) ∈ P such that, by unfolding C w.r.t. C2 using the Definition 5.1, we obtain: C' ≡ ((H1 ← X1, q, Y1)σ; Ψ) ∈ P'. Then, since D is a successful f-derivation reordered w.r.t. clause C, then it has the following form:

⟨X, A, Y ; id⟩	→F R1C



⟨(X,


, A1, Y1


, Y )α; α⟩  →
C2
F R2

⟨(X,
, q, Y
, Y )αβ; αβ⟩ →	∗

1	FR 
⟨r; θ⟩
And now, the first two steps in D can be simulated in P' by using clause
C' as follows:

⟨X, A, Y ; id⟩	→F R1C'

⟨(X,
, q, Y
, Y )σγ; σγ⟩ →	∗

1	FR 
⟨r; θ'⟩


By Lemma 6.1 we can conclude that αβ = σγ[Var(Q)], and hence the third state in D coincides syntactically with the second one in D'. More- over, by the inductive hypothesis θ = θ'[Var(Q)] and hence the entire f-derivations D and D' are equivalents, as we wanted to prove.

T-Norm Replacement of kind 1.
Let C ≡ (H1 ← X1,	n	, Y1; Ψ) ∈ P with Ψ ≡ ⟨p, [[et1]], [[et2]]⟩
and let Ψ' ≡ ⟨q, [[et1]]', [[et2]]'⟩. By T-Norm Replacement of kind 1 of C (see the Definition 5.3), we obtain C' ≡ (H1 ← X1, [[et1]](q, n), Y1; Ψ) ∈ P'. Moreover, since D is a successful f-derivation reordered w.r.t. clause C, then it has the following form:

⟨X, A, Y ; id⟩	→F R1C



⟨(X,  LΨ	X1,


n	, Y1


, Y )α; α⟩ →F R3



⟨(X,
⟨r; θ⟩


, [[et1]]'(q, n), Y1


, Y )α; α⟩	→	∗



And now, the first two steps in D can be simulated in P' by giving a unique resolution step using clause C' in D' as follows:

⟨X, A, Y ; id⟩	→F R1C'

⟨(X,
, [[et ]]'(q, n), Y
, Y )α; α⟩ →	∗

1	1	FR 
⟨r; θ'⟩

Since the third state in D coincides syntactically with the second one in
D', our claim holds by the inductive hypothesis.


T-Norm Replacement of kind 2.

Let C ≡ (H1 ← X1,


, Y1; Ψ) ∈ P with Ψ ≡ ⟨p, [[et1]], [[et2]]⟩

and Ψ' ≡ ⟨q, [[et1]]', [[et2]]'⟩. By T-Norm Replacement of kind 2 of C using


the Definition 5.3, we get C' ≡ (H1 ← X1,
[[et2]](n)

, Y1; Ψ)

∈ P'.	Moreover, since D is a successful f-derivation reordered w.r.t.

clause C, then it has the following form:

⟨X, A, Y ; id⟩	→F R1C



⟨(X,  LΨ	X1,


, Y1


, Y )α; α⟩	→F R4

⟨(X,
,	[[et ]]'(n)	, Y
, Y )α; α⟩ →	∗


⟨r; θ⟩
2	1	FR 

And now, the first two steps in D can be simulated in P' by giving a unique resolution step using clause C' in D' as follows:

⟨X, A, Y ; id⟩	→F R1C'

⟨(X,
,	[[et ]]'(n)	, Y
, Y )α; α⟩ →	∗

2	1	FR 
⟨r; θ'⟩
Since the third state in D coincides syntactically with the second one in D', our claim holds by the inductive hypothesis.

T-Norm Replacement of kind 3.
Let C ≡ (H1 ← n; Ψ) ∈ P, with Ψ ≡ ⟨p, [[et1]], [[et2]]⟩, such that, by T- Norm Replacement of C using the rule of kind 3 in Definition 5.3, we obtain the new clause C' ≡ (H1 ← ; [[et1]](p, n)) ∈ P'. Moreover, since D is a successful f-derivation reordered w.r.t. clause C, then it has the following form:

⟨X, A, Y ; id⟩	→F R1C

⟨(X,	n	, Y )α; α⟩ →F R3

⟨(X, [[et1]](p, n), Y )α; α⟩	→	∗
⟨r; θ⟩
Now, the first two steps in D (the first one with rule 1 using clause C and the second one with rule 3) can be simulated in P' by giving a unique resolution step using clause C' in D' as follows:

⟨X, A, Y ; id⟩	→F R2C'
⟨(X, [[et1]](p, n), Y )α; α⟩ →	∗
FR 
⟨r; θ'⟩
Since the third state in D coincides syntactically with the second one

in D', our claim holds by the inductive hypothesis.
T-Norm Replacement of kind 4.
Let C ≡ (H1 ← n; Ψ) ∈ P, with Ψ ≡ ⟨p, [[et1]], [[et2]]⟩, such that, by T- Norm Replacement of C using the rule of kind 4 in Definition 5.3, we obtain the new clause C' ≡ (H1 ← [[et2]](n); Ψ) ∈ P'. Moreover, since D is a successful f-derivation reordered w.r.t. clause C, then it has the following form:

⟨X, A, Y ; id⟩	→F R1C

⟨(X,	, Y )α; α⟩	→F R4

⟨(X,
[[et ]](n)
, Y )α; α⟩ →	∗


2	FR 
⟨r; θ⟩
Now, the first two steps in D (the first one with rule 1 using clause C and the second one with rule 4) can be simulated in P' by giving a unique resolution step using clause C' in D' as follows:

⟨X, A, Y ; id⟩	→F R1C'

⟨(X,
[[et ]](n)
, Y )α; α⟩ →	∗

2	FR 
⟨r; θ'⟩
Since the third state in D coincides syntactically with the second one in D', our claim holds by the inductive hypothesis.

Finally, we are able to formalize and prove the best properties of our fuzzy transformations (namely, its strong correctness and the guarantee for producing improvements on transformed programs) as follows:
Theorem 6.4 (Strong Correctness of the Transformation System ) Let (P0,... , Pk) be a transformation sequence of lf-Prolog programs where each program in the sequence, except the initial f-Prolog program P0, is obtained from the immediately preceding one by applying fuzzy unfolding or T-Norm replacement. Then, for any lf-Prolog goal G ≡ ←Q with le2 = [[et2]], we have:

⟨	Q
; id⟩→
n⟨r; θ⟩ in P
iff ⟨	Q
; id⟩→
m⟨r; θ⟩ in P

where Ψ ≡ ⟨1, void, [[et2]]⟩ and the number of fuzzy SLD-resolution steps in each derivation verify that m ≤ n.

Proof. The two claims of Theorem 6.4 can be easily proved as follows:
The strong correctness of the transformation system is immediate by sim- ply applying Theorems 6.2 and 6.3, since both theorems prove the equiva- lence between any pair of consecutive programs inside the transformation sequence (P0,... , Pk), thus implying the final equivalence between P0 and Pk.
Regarding the reduction of the length of successful derivation in transformed programs, we have seen in proofs of both theorems 6.2 and 6.3 that any fuzzy SLD-resolution step done with a new clause obtained after applying fuzzy unfolding or t-norm replacement subsumes two fuzzy SLD-resolution steps done against the original program, which confirms that m ≤ n, as we wanted to prove.

Conclusions
This work introduces two safe unfolding-based transformation rules for optimi- zing fuzzy logic programs. To the best of our knowledge, this is the first time the issue, of integrating transformation techniques in the context of fuzzy logic languages, is treated in the literature.
After an inspection of the main proposals for the inclusion of fuzzy logic into a logic programming setting, we have selected an extension of the language described in [21], that we call lf-Prolog, since we think it is the best suited to deal with the problems that may arise in the transformation process of logic programs. It is remarkable that lf-Prolog is provided with a labeled mark language. Inspired in [19], we have extended this language in order to be able to code different fuzzy logics inside the same program, which greatly enhances the expressive power of the former language. Also, as an auxiliary result, we have established the independence of the Fuzzy Computation Rule for lf-Prolog programs and goals (Theorem 4.4).
We have defined the fuzzy unfolding and T-Norm replacement of lf-Prolog programs (Definition 5.1 and 5.3) and we have demonstrated the (strong) correctness (Theorem 6.4) of the transformation system. Moreover, we have proved that transformation sequences can be guided in a blind way since any transformation step based on fuzzy unfolding and T-Norm replacement always produces an improvement on transformed programs. This contrasts with other transformation rules, like definition introduction or folding that may degrade the efficiency of programs, if appropriate “transformation strategies” are not used to drive the construction of the transformation sequence.
Finally, it is important to say that the results in this paper can be thought


as a basis to optimize fuzzy prolog programs and they are the first step in the construction of a global fold/unfold framework (including more transformation rules and strategies) for optimizing this class of programs.

References
M. Alpuente, M. Falaschi, G. Moreno, and G. Vidal. Rules + Strategies for Transforming Lazy Functional Logic Programs. Theoretical Computer Science, 311:479–525, 2004.
J. F. Baldwin, T. P. Martin, and B. W. Pilsworth. Fril- Fuzzy and Evidential Reasoning in Artiﬁcial Intelligence. John Wiley & Sons, Inc., 1995.
R.M. Burstall and J. Darlington. A Transformation System for Developing Recursive Programs. Journal of the ACM, 24(1):44–67, 1977.
M. Ishizuka and N. Kanai. Prolog-ELF Incorporating Fuzzy Logic. In Aravind K. Joshi, editor, Proceedings of the 9th International Joint Conference on Artiﬁcial Intelligence (IJCAI’85). Los Angeles, CA, August 1985., pages 701–703. Morgan Kaufmann, 1985.
P. Julian, G. Moreno, and J. Penabad. Unfolding Fuzzy Logic Programs. In Proc. of the Fourth International Conference on Intelligent Systems Design and Applications, ISDA’04, Budapest, Hungary, pages 595–600. (Sponsored by IEEE), 2004.
P. Julian and C. Villamizar. Analizing Definitional Trees: Looking for Determinism. In Yukiyoshi Kameyama and M. Peter J. Stuckey, editors, Proc. of the 7th Fuji International Symposyum on Functional and Logic Programming, FLOPS’04, Nara (Japan), page 25. Springer-Verlag LNCS (To appear), 2004.
Frank Klawonn and Rudolf Kruse. A L- ukasiewicz logic based Prolog. Mathware & Soft Computing, 1(1):5–29, 1994.
G. J. Klir and B. Yuan. Fuzzy Sets and Fuzzy Logic. Prentice-Hall, 1995.
J.-L. Lassez, M. J. Maher, and K. Marriott.  Unification Revisited.  In J. Minker, editor, Foundations of Deductive Databases and Logic Programming, pages 587–625. Morgan Kaufmann, Los Altos, Ca., 1988.
R.C.T. Lee. Fuzzy Logic and the Resolution Principle. Journal of the ACM, 19(1):119–129, 1972.
Deyi Li and Dongbo Liu. A fuzzy Prolog database system. John Wiley & Sons, Inc., 1990.
J.W. Lloyd. Foundations of Logic Programming. Springer-Verlag, Berlin, 1987. Second edition.
H.T. Nguyen and E.A. Walker. A First Course in Fuzzy Logic. Chapman & Hall/CRC, Boca Rat´on, Florida, 2000.
C. Palamidessi. Algebraic Properties of Idempotent Substitutions. In M.S. Paterson, editor, Proc. of 17th Int’l Colloquium on Automata, Languages and Programming, pages 386–399. Springer LNCS 443, 1990.
A. Pettorossi and M. Proietti. Rules and Strategies for Transforming Functional and Logic Programs. ACM Computing Surveys, 28(2):360–414, 1996.
B. Schweizer and A. Sklar. Probabilistic Metric Spaces. North-Holland, New York, 1983.
H. Tamaki and T. Sato. Unfold/Fold Transformations of Logic Programs. In S. T¨arnlund, editor, Proc. of Second Int’l Conf. on Logic Programming, pages 127–139, 1984.
E. Trillas, C. del Campo, and S. Cubillo. When QM-Operators Are Implication Functions and Conditional Fuzzy Relations. International Journal of Intelligent Systems, 15:647–655, 2000.


C. Vaucheret, S. Guadarrama, and S. Mun˜oz. Fuzzy prolog: A simple general implementation using clp(r). In M. Baaz and A. Voronkov, editors, Proc. of Logic for Programming, Artiﬁcial Intelligence and Reasoning (LPAR 2002), Tbilisi, Georgia, pages 450–463. Lectures Notes in Artificial Intelligence 2514, Springer Verlag, 2002.
P. Vojtas. Fuzzy Logic Programming. Fuzzy Sets and Systems, 124(1):361–370, 2001.
P. Vojtas and L. Paul´ık. Soundness and completeness of non-classical extended SLD-resolution. In R. Dyckhoff et al, editor, Proc. ELP’96 Leipzig, pages 289–301. LNCS 1050, Springer Verlag, 1996.
L. Zadeh. Calculus of fuzzy restrictions. Fuzzy Sets and Their Applications to Cognitive and Decision Processes, pages 1–39, 1975.
L. A. Zadeh. Fuzzy Sets. Information and Control, 8(3):338–353, 1965.
