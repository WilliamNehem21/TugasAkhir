

Electronic Notes in Theoretical Computer Science 256 (2009) 87–102
www.elsevier.com/locate/entcs
Towards an Efficient Prover for the C1
Paraconsistent Logic
Adolfo Netoa,1,2 Celso A. A. Kaestnera,3 Marcelo Fingerb,1,4
a Informatics Department (DAINF)
Federal University of Technology - Parana´ (UTFPR)
Curitiba, Brazil
b Computer Science Department (DCC) University of S˜ao Paulo (USP)
S˜ao Paulo, Brazil

Abstract
The KE inference system is a tableau method developed by Marco Mondadori which was presented as an improvement, in the computational efficiency sense, over Analytic Tableaux. In the literature, there is no description of a theorem prover based on the KE method for the C1 paraconsistent logic. Paraconsistent logics have several applications, such as in robot control and medicine. These applications could benefit from the existence of such a prover. We present a sound and complete KE system for C1, an informal specification of a strategy for the C1 prover as well as problem families that can be used to evaluate provers for C1. The C1 KE system and the strategy described in this paper will be used to implement a KE based prover for C1, which will be useful for those who study and apply paraconsistent logics.
Keywords: tableaux systems, KE system, C1 logic, paraconsistent logics, problem families.


Introduction
Inconsistency is a phenomena that appears naturally in our world. Consider the following situation: two persons have different (contradictory) opinions about a spe- cific statement A: the first one considers A true, meanwhile the second one believes that ¬A is true. This contradiction, however, should not prevent that common conclusions which do not involve A – directly or indirectly – can be deduced.

1 Adolfo Neto and Marcelo Finger acknowledge support from Funda¸cc˜ao de Amparo a Pesquisa do Estado de S˜ao Paulo (FAPESP), Brazil, through the Thematic Project ConsRel, grant number 2004/14107-2. Marcelo Finger also acknowledges an individual research grant from the Brazilian Research Council (CNPq).
2 Email: adolfo@utfpr.edu.br
3 Email: celsokaestner@utfpr.edu.br
4 Email: mfinger@ime.usp.br

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.11.007

This situation is not adequately managed by classical logic, since it is not equipped to deal with inconsistency. The reason is the well known “Ex contradic- tione sequitur quod libet” principle: if a theory Γ is inconsistent, that is, if formulas A and ¬A are theorems, then every formula B of the language is also a theorem in Γ; or, shortly, Γ becomes trivial.
Paraconsistent Logics were initially proposed by Da Costa [8] as logical systems that deal with contradictions in a discriminating way, avoiding the previous principle and managing inconsistent but non-trivial theories.
Presently automatic proof methods are widely used in several computer applica- tions, such as in robot control [23], in medicine [14,16], and many others [10]. Most of the employed methods work on logical formalisms based on classical logic. In this paper we present the specification of an strategy for automatic theorem prover based on a KE system, an improvement of the well known tableaux deduction method,
for a particular paraconsistent logic called C1.
The rest of this paper is organized as follows: Section 2 introduces the axioma- tization and valuation of the paraconsistent logic C1; in Sections 3 and 4 we present the KE system for C1 and its inference rules, and the KEMS strategy, respectively; Section 5 presents a set of problems constructed to evaluate the prover; in Section 6 we present a motivating example, showing that our proposal is adequate to deal with practical problems; in Section 7 we compare our work with similar ones; finally in Section 8 we draw some conclusions and propose future research.
We emphasize the main contributions of this paper: (a) a sound and complete KE system for C1 (Section 3); (b) an informal specification of a KEMS [20] strategy for the C1 prover (Section 4); and (c) problem families that can be used to evaluate provers for C1 (Section 5).

Preliminaries
Let P be a countable set of propositional letters. We concentrate on the propo- sitional language L formed by the usual boolean connectives → (implication), ∧ (conjunction), ∨ (disjunction) and ¬ (negation). We call Σ this set of connectives:
Σ = {¬, ∧, ∨, →} (Σ is called a signature in [6]).  n	and  n	are, respectively,
iterated conjuntion and iterated disjunction.
Throughout the paper, we use uppercase Latin or lowercase Greek letters to denote arbitrary formulas, and uppercase Greek letters to denote sets of formulas. We also work here with signed formulas. A signed formula is an expression
S A where S is called the sign and A is a propositional formula. The symbols T and F , respectively representing the ‘true’ and ‘false’ truth-values, can be used as signs. The conjugate of a signed formula T A (F A) is F A (T A). The subformulas of a signed formula S A are all the formulas of the form T B or F B where B is a subformula of A.
The size of a signed formula S A is defined as the size of A. The size s(A) of a formula A is defined as usual:
s(A) = 1 if A is a propositional atom;

s(  A) = 1 + s(A), where A is a formula and  is a unary connective;
s(A B) = 1 + s(A)+ s(B), where  is a binary connective, and A and B are formulas.
A propositional valuation v is a function v : P → {0, 1}. We extend the definition of valuations to signed formulas in the following way: v(T A) = v(A) and v(F A) = 1 − v(A).

C1, a paraconsistent logic
C1 is a paraconsistent logic [8], “a logic of the early paraconsistent vintage” [6]. It is part of the hierarchy of logics Cn, 1 ≤ n < ω [10]. C1 is of historical importance because it was one of the first paraconsistent logics to be presented.
Paraconsistent logics are logics in which theories can be inconsistent but non- trivial [10]. In classical logic, A ∧ ¬A ▶ B for any formulas A and B. This is not true in paraconsistent logics.
In C1, a consistency operator (◦) is introduced. The intended meaning of ◦A
is “A is consistent” [6]. According to [6], “da Costa’s intuition was that the ‘con- sistency’ (which he dubbed ‘good behavior’) of a given formula would not only be a sufficient requisite to guarantee its explosive character, but that it could also be
represented as an ordinary formula of the underlying language.”
In C1, da Costa represented the consistency of a formula A by the formula
¬(A ∧ ¬A). That is, the consistency connective “◦” is not a primitive connective, but an abbreviation:
A = ¬(A ∧ ¬A).

C1’s Axiomatization
Some axiomatizations for C1 were presented in the literature [6,9,15]. The presen- tation below is based on [6] and [9].
Axiom schemas: (Ax1) α → (β → α)
(Ax2) (α → β) → ((α → (β → γ)) → (α → γ))
(Ax3) α → (β → (α ∧ β))
(Ax4) (α ∧ β) → α
(Ax5) (α ∧ β) → β
(Ax6) α → (α ∨ β)
(Ax7) β → (α ∨ β)
(Ax8) (α → γ) → ((β → γ) → ((α ∨ β) → γ))
(Ax10) α ∨ ¬α
(Ax11) ¬¬α → α
(bc1) ◦α → (α → (¬α → β))

(ca1) (◦α ∧ ◦β) → ◦(α ∧ β)
(ca2) (◦α ∧ ◦β) → ◦(α ∨ β)
(ca3) (◦α ∧ ◦β) → ◦(α → β)
Inference rule:
(MP) α, α → β
β
The difference from classical propositional logic (CPL) axiomatization is that to obtain an axiomatization for CPL we must remove the schemas that deal with the consistency connective ((bc1), (ca1), (ca2) and (ca3)) and add the following axiom schema (called ‘explosion law’ in [6]):
(exp) α → (¬α → β)

C1’s Valuation
C1 received a bivaluation semantics in [9] (see also [6]). A set of clauses character- izing C1-valuations (adapted from the one in [6]) is the following:
v(α1 ∧ α2) = 1 if and only if v(α1) = 1 and v(α2) = 1;
v(α1 ∨ α2) = 1 if and only if v(α1) = 1 or v(α2) = 1;
v(α1 → α2) = 1 if and only if v(α1) = 0 or v(α2) = 1;
v(¬α) = 0 implies v(α) = 1;
v(¬¬α) = 1 implies v(α) = 1;
v(◦α) = 1 implies v(α) = 0 or v(¬α) = 0.
v(◦(α  β)) = 0 implies v(◦α) = 0 or v(◦β) = 0, for  ∈ {∧, ∨, →};
Definition 2.1 Let Γ be {A1, A2,..., An} for n ≥ 0. Γ ▶ B is a valid sequent in C1 if and only if, v(B) = 1 whenever v(Ai) = 1 for all i (1 ≤ i ≤ n). “Γ ▶ B is a valid sequent in C1” can be abbreviated to Γ ▶C1 B.
The KE System for C1
The KE inference system is a tableau method [13] developed by Marco Mon- dadori and discussed in detail in several works authored or co-authored by Marcello D’Agostino [2,11,12]. The KE system was presented as an improvement, in the computational efficiency sense, over Analytic Tableaux [22]. A KE System is a tableau system in which there is only one branching rule. As branching can lead to repetition of efforts (i.e. the same work being done in two or more branches), branching rules lead to less efficient proof systems (and implementations) [12].
We present here a sound and complete KE System we have devised for C1. The
rules in our system are presented in Figure 1. Note that in C1, the set of connectives is Σ = {¬, ∧, ∨, →} but, to make the rules simpler, we have used the connectives in Σ◦ = Σ ∪ {◦}, i.e. including the consistency connective, which is actually an abbreviation.




 (PB)
T A	F A

Fig. 1. C1 KE rules.

In [19,21] (and also in [18]) the first and third authors of this paper have pre- sented KE Systems for two other paraconsistent logics: mbC and mCi (more about these two logics can be found in [6]). The KE System for C1 has several rules in common with the KE Systems for these two logics. However, in these logics, consistency (◦) is not a defined connective.
As in classical KE rules [12], rules with “1” (for instance, “F ∧1”) or “2” as subscript are interchangeable. Only one of each pair is actually essential. By using the PB rule (Figure 1), the other can be derived.
Note also that F ◦  1 and F ◦  2 are actually three rules each, because  can be any connective in {∧, ∨, →}. In a 2-premiss rule, the main premiss is the first premiss. The second premiss is called minor premiss. The main premiss in F◦  1


F ¬(P ∧ (¬P ∧ ◦P ))
T P ∧ (¬P ∧ ◦P )
T P
T ¬P ∧ ◦P
T ¬P
T ◦ P
F P
×


Fig. 2. A proof of ¬(P ∧ (¬P ∧ ◦P )) using the C1 KE system.

(or in F◦  2) can be “F ◦ (A ∧ B)”, “F ◦ (A ∨ B)” or “F ◦ (A → B)”. And, as ‘◦’ is a defined connective, “F ◦ (A B)” is actually “F ¬((A B) ∧ ¬(A B)”. For instance, F◦ ∧1 is:

F ¬((A ∧ B) ∧ ¬(A ∧ B))
T ¬(A ∧ ¬A)
F ¬(B ∧ ¬B)


(F◦ ∧1)

It is easy to see that these rules (F◦  1 and F◦  2) are not analytic. In F◦ ∧1,
F¬(B ∧ ¬B) is not a subformula of any premiss.
Therefore, in our system we have:
12 essential linear rules (5 of these rules are 1-premiss rules and 7 rules are 2- premiss rules);
6 derived linear 2-premiss rules;
1 (0-premiss) branching rule.
Of these rules, 6 of them (F◦  1 and F◦  2) are rather complex, far more complex than any CPL KE rule.
Example 3.1 The formula ¬(P ∧ (¬P ∧ ◦P )) can be proved in C1 KE system as depicted in Figure 2. The same formula was proved in [6] using the C1 tableau system presented there (Figure 3). It is easy to see that the C1 KE proof has less formula nodes and less branches than the C1 tableau [6] proof.

Soundness and Completeness
Our intention here is to prove that the C1 KE system is sound and complete. The proof is very similar to the mCi KE system’s soundness and completeness proof presented in Section B.2.4 of [18]. We begin with some definitions.
Definition 3.2 [12] A branch of a KE tableau is closed when T A and F A appear in the branch.
Definition 3.3 [12] A KE tableau is closed if all its branches are closed.
Definition 3.4 Γ ▶C1 KE B if there is a closed KE tableau for Γ ▶ B.

F ¬(P ∧ (¬P ∧ ◦P ))
T P ∧ (¬P ∧ ◦P )
T P
T ¬P ∧ ◦P
T ¬P
T ◦ P


T P → P
F P → P
T P

T P → ¬P
F P
×
F P → ¬P	F P
T P	×
F ¬P
×

Fig. 3. A proof of ¬(P ∧ (¬P ∧ ◦P )) [6].
Definition 3.5 The C1 KE system is sound if, for any Γ and B, Γ ▶C1 KE B implies Γ ▶C1 B.
Definition 3.6 The C1 KE system is complete if, for any Γ and B, Γ ▶C1 B implies Γ ▶C1 KE B.
Definition 3.7 A set of C1 signed formulas DS is downward saturated:
whenever a signed formula is in DS, its conjugate is not in DS;
when all premises of any C1 KE rule (except PB) are in DS, its conclusions are also in DS;
when the major premiss of a 2-premiss C1 KE rule is in DS, either its auxiliary premiss or its conjugate is in DS.
A Hintikka’s Lemma holds for C1 downward saturated sets:
Lemma 3.8 (Hintikka’s Lemma for C1) Every C1 downward saturated set is sat- isﬁable.
Proof. For any downward saturated set DS, we can easily construct a C1 valuation v such that for every signed formula SX in the set, v(SX) = 1. How can we guarantee this is in fact a valuation? First, we know that there is no pair T X and F X in DS. Second, all premised C1 KE rules preserve valuations. That is, if v(SXi) = 1 for every premiss SXi, then v(SCj) = 1 for all conclusions Cj. And if v(SX1) = 1 and v(SX2) = 0, where X1 and X2 are, respectively, major and minor premises of a C1 KE rule, then v(S'X2) = 1, where S'X2 is the conjugate of SX2. Therefore, DS is satisfiable.	 
Theorem 3.9 Let DS’ be a set of signed formulas. DS’ is satisﬁable if and only if there exists a downward saturated set DS” such that DS’ ⊆ DS”.
Proof. (⇐) First, let us prove that if there exists a downward saturated set DS” such that DS’ ⊆ DS”, then DS’ is satisfiable. This is obvious because from DS” we can obtain a valuation that satisfies all formulas in DS”, and DS’ ⊆ DS”.

(⇒) Now, let us prove that if DS’ is satisfiable, there exists a downward satu- rated set DS” such that DS’ ⊆ DS”.
So, suppose that DS’ is satisfiable and that there is no downward saturated set DS” such that DS’ ⊆ DS”. Using items (ii) and (iii) of (3.7), we can obtain a family of sets of signed formulas DS’i (i ≥ 1) that include DS’. If none of them is downward saturated, it is because for all i, {T X, F X} ∈DS’i for some X. But all rules are valuation-preserving, so this can only happen if DS is unsatisfiable, which is a contradiction.	 
Corollary 3.10 DS’ is an unsatisﬁable set of formulas if and only if there is no downward saturated set DS” such that DS’ ⊆ DS”.
Theorem 3.11 The C1 KE system is sound and complete.
Proof. The C1 KE proof search procedure for a set of signed formulas S either provides one or more downward saturated sets that give a valuation satisfying S or finishes with no downward saturated set. The C1 KE system is a refutation system. The C1 KE system is sound because if a C1 KE tableau for a set of formulas S closes, then there is no downward saturated set that includes it, so S is unsatisfiable. If the tableau is open and completed, then any of its open branches can be represented as a downward saturated set and be used to provide a valuation that satisfies S (in other words, S is satisfiable).
The C1 KE system is complete because if S is satisfiable, no C1 KE tableau for a set of formulas S closes. And if S is unsatisfiable, all completed C1 KE tableaux for S close.	 

Decidability
We do not prove here that the C1 KE system is decidable, i.e., that there is an algorithm for finding proofs in the C1 KE system. We only present the sketch of such a proof that will be detailed in a future paper about the implementation of a C1 prover.
The idea is to define a restriction of the C1 KE system which imposes some conditions on the application the PB rule (Figure 1). In this restricted C1 KE system, the PB rule can only be applied in a branch:
when there is a non-atomic signed formula that can be the main premiss of a 2-premiss rule and that was not yet analysed (i.e. used as main premiss) in the branch; and
when either T A or F A can be the minor premiss of a 2-premiss rule, where A is the PB formula (i.e. the A formula that appears as T A in the new left branch and F A in the new right branch after PB application).
For all the 2-premiss rules in Figure 1, the minor premiss’s size is smaller than major premiss’s size. This, alongside with the conditions above, guarantees the the proof search procedure eventually terminates.

A KEMS Strategy for C1
KEMS [18] is a theorem prover that can be used to implement strategies for many different logical systems. For instance, the current version [20] has 6 strategies for CPL, 2 strategies for mbC and 2 strategies for mCi.
We have to follow some steps to implement a strategy for a logical system in KEMS. First, one has to know how KEMS implementation is structured (by reading [18] and the source code available in [20]). Second, one has to implement the classes that will represent the logical system (such as CPL or C1). Third, one has to implement the classes necessary to represent the rules of the KE system (such as C1 KE system). Only after these three steps, one can implement one or more strategies for a given KE system.
KE systems (as well as many logical proof methods) are usually presented by showing their rules. The rules tells us only what we can do – they do not specify in which order to use the rules. A strategy is a deterministic algorithm for a given KE system, as well as a set of data structures used by the algorithm.

C1 KE Simple Strategy
The C1 KE Simple Strategy resembles mbC and mCi Simple Strategies (see Sec- tions C.4.4 and C.4.5 of [18]). Let us informally describe the algorithm performed by this strategy:
the strategy applies all possible linear rules in the current branch (in the begin- ning, the current branch is the branch containing the formulas obtained from the problem);
if the current branch closes (i.e. if a contradiction {T A, F A} is found), then the strategy tries to remove a branch from its stack of open branches. If it succeeds, this branch becomes the current branch and the control goes back to the first step. If there is no remaining open branch, the procedure ends and the result is that the tableau is declared closed;
if the current branch is linearly saturated (i.e. no more linear rules can be applied), but not closed, the strategy tries to apply the PB rule. The PB rule can be applied when there is at least one non-atomic signed formula in the branch that can be the main premiss of a 2-premiss rule and this signed formula was not yet used as the main premiss in an application of a 2-premiss rule. If the strategy can apply the PB rule, then the (new) right branch is put in the stack of open branches and the left branch becomes the current branch. If the strategy cannot apply the PB rule, then the procedure finishes by declaring the tableau open.
The order of rule applications is:
C1 KE 1-premiss rules;
C1 KE 2-premiss rules;
the PB rule.

See Sections C.2 and C.4 of [18] for more details on how rules are applied in KEMS.

Implementation Remarks
This strategy is a very straightforward strategy for a C1 KE system. The idea is to use the PB rule only as a last resource (as shown in the canonical procedure for KE [12]). The difference is that in the C1 KE system we cannot restrict the strategy to perform only analytic applications of PB. An analytic application of PB is an application of PB where the PB formula (i.e. the A formula that appears as T A in the new left branch and F A in the new right branch after PB application) is a subformula of some formula in the branch.
Another difficulty in the implementation of this strategy (actually in the imple- mentation of almost any proof system for C1) is how to deal with the consistency connective.
We have two options:
only accept problems using the connectives in Σ. Therefore, all rules presented in Figure 1 will have to be implemented using Σ connectives (which makes the rules and the associated pattern matching more complex). Note that the size of problems written in Σ◦ may grow exponentially (in the worst case) when translated to Σ;
accept problems written in Σ◦ and, whenever a ¬(A ∧ ¬A) formula appears (for any A), treat it as if it was (also) ◦A in the applications of rules that have formulas with ◦ as premisses. Although this option allows the prover to deal with smaller problems, it makes rule applications more difficult.
C1 Simple Strategy will use option (i) above. Option (ii) will be used on a second strategy for C1 KE.

Problem Families to Evaluate C1 Provers
A problem family is a set of problems that we know, by construction, whether they are valid, satisfiable or unsatisfiable [18]. A problem is a sequent that can be given as input for a theorem prover. The i-th instance (for i ≥ 1) of a problem family is a (valid, satisfiable or unsatisfiable) sequent.
In Section D.1.2 of [18], seven families of difficult problems that can be used to evaluate theorem provers for paraconsistent logics were presented. All these families were families of valid sequents. To the best of our knowledge, there are no other families of difficult problems designed with this purpose in mind. The families presented there can be used to evaluate provers for two logics: mbC and mCi, which are part of the class of logics of formal inconsistency (LFIs) [6].
In [6] it is shown that C1 can also be classified as an LFI and that it extends mbC. Therefore, the first four families created to evaluate mbC provers [18] can also be used to evaluate provers for C1.
However, these families do not test all C1 KE rules. That is, to prove the problems in those families using the C1 KE system, one does not need to use all

its rules. Therefore, to extend what we could call “rule coverage”, i.e. to test more rules, we present two more families of sequents. These sequents are valid in C1 (but not in mbC, therefore they can also be used to test mbC provers) and, for proving them, we have to use rules that are not used in the first four families’ proofs.
These families were not developed with any intuitive meaning in sight. As the objective was to test theorem provers, they were designed to be difficult to prove, by using as many rules as possible.
The motivation for developing and presenting these problem families before the actual C1 prover was implemented was, inspired by the Test-Driven Development
technique for software development [1], to use the tests as a guide for the design and implementation of the sofwtare.
Note: to make it easier to read the problems, we have used the connectives in Σ◦ and we sometimes use “[” and “]” in place of “(” and “)”.

Fifth family
The sequents in this family (Φ5) demand C1’s T ¬¬ rule to be proven valid. Φ5
(the nth instance of Φ5) is:

n	n	n
◦A1,  (Ai),  [An+1 → ((Ai ∨ Bi) → (◦Ai+1))], (  ◦Ai) → ¬An+1 ▶ ¬¬¬An+1

i=1
i=1
i=1

For instance, Φ5 in signed tableau notation is:

T ◦ A1
T A1 ∧ A2 ∧ A3
T [A4 → ((A1 ∨ B1) → (◦A2))]
∧ [A4 → ((A2 ∨ B2) → (◦A3))]
∧ [A4 → ((A3 ∨ B3) → (◦A4))]
T ((◦A1) ∧ (◦A2) ∧ (◦A3)) → ¬A4
F ¬¬¬A4

Sixth family
In order to prove, using the C1 KE system, that the sequents in this family (Φ6) are valid, it is necessary to use the two C1 KE rules where “◦” is the main connective in the main premiss: F ◦  1 and F ◦  2. Φ6 (the n-th instance of Φ6) is:

n	n	n	n	n
^ (Bi), ^ (◦Ci), ^ ((Ai ∨ Bi) → (◦Ai+1)), ( ^ Ci) → (D ∧ ¬C1) ▶ [ _ (◦(Ai+1 → Ci))] ∨ D

i=1
i=1
i=1
i=1
i=1

For instance, Φ6 is:

T B1 ∧ B2 ∧ B3
T ◦ C1 ∧ ◦C2 ∧ ◦C3
T ((A1 ∨ B1) → (◦A2)) ∧ ((A2 ∨ B2) → (◦A3)) ∧ ((A3 ∨ B3) → (◦A4))
T (C1 ∧ C2 ∧ C3) → (D ∧ ¬C1)
F [◦(A2 → C1)] ∨ [◦(A3 → C2)] ∨ [◦(A4 → C3)] ∨ D

A Motivating Example
We present here an example almost completely based on the example shown in [17]:
Consider the construction of a simple medical system aimed at diagnosing three diseases K, L and M . There are two different symptoms, denoted by N and O. The intended usage of this system is as follows:
The core part of the system is the knowledge provided by a doctor (DOC1).
When we intend to apply this knowledge to a specific patient, other profession- als conduct medical tests on this patient add the results of these tests to the knowledge base.
In order to use the system, we submit a goal to the program in a similar way as it is done in Prolog.
We assume that the system is written in the form of a finite set of formulas over C1. Suppose that DOC1 provided us the following five rules (formulas): (F1) K → ¬L
(F2) L → ¬K (F3) K → M (F4) N → K (F5) O → L
Intuitively, the doctor is telling that:
An individual cannot have both diseases K and L (F1 and F2).
If an individual has the disease K, them he has the disease M (F3)
If an individual has the symptom N , them he has the disease K (F4)
If an individual has the symptom O, them he has the disease L (F5)
To exemplify the use of this knowledge base, we describe four situations. The first one is similar to a query to a Prolog program, while the other three explore the capacity of handling inconsistencies:
Case 1: Suppose that the patient has symptom N and we want to know if he has the disease K but not L.
To answer this query we must verify if

F1, F2, F3, F4, F5,N ▶C1 K ∧ ¬L

is valid. As the KE proof for this sequent is a closed tableau, this sequent is valid. It is also valid in classical logic.
Case 2: Now suppose that the patient tested positive for symptoms N and O, and we want to know if he has both diseases K and L.
To answer this query we must verify if

F1, F2, F3, F4, F5, N,O ▶ K ∧ L	(1)

is valid. (1) is valid in C1. In classical propositional logic, (1) is also valid. Actually, in classical propositional logic:

F1, F2, F3, F4, F5, N,O ▶ B	(2)

is valid for any formula B. However, (2) is not valid in C1 for any formula B .
Case 3: Now suppose that the patient tested positive for symptoms N and O, and we want to know if he has not the disease M .
To answer this query we must verify if

F1, F2, F3, F4, F5, N,O ▶C1 ¬M	(3)

is valid.	The KE proof for this sequent (an open tableau, which shows that the sequent is NOT valid) is the following:

T K → ¬L T L → ¬K T K → M T N → K T O → L T N
T O
F ¬M T K T L T M
T ¬K
T ¬L


However, this sequent is valid in classical logic, because a classical contradiction is found (T K and T ¬K).
Case 4: Now suppose again that the patient tested positive for symptoms N and O, but now we want to know if he has the disease K and if this conclusion is not consistent (¬◦ K).
To answer this query we must verify if

F1, F2, F3, F4, F5, N,O ▶C1 K ∧¬◦ K	(4)

is valid.  The KE proof for this sequent (a closed tableau) is the following:
T K → ¬L T L → ¬K T K → M T N → K T O → L T N
T O
F K ∧¬◦ K
T K T L
T ¬L T ¬K T M
F ¬◦ K T ◦ K F K
×

This query shows that, besides “dealing with inconsistencies in the knowledge base without every formula becoming derivable” [17], a common feature of para- consistent logics, C1 allows us to express propositions about the (in)consistency of formulas.
The sequent (4) is valid in classical logic. Note that, for any formula B, “¬◦ B” is a theorem in classical logic. Therefore, in classical logic, Γ ▶ K ∧¬◦ K if and only Γ ▶ K.
Related Work
A tableau system for C1 was presented in [7]. As this system is based on analytic tableaux (AT) [22], it has four branching rules: the three ones from AT plus a T ¬ branching rule. Due to this T ¬ rule, infinite loops may occur during the proof search, postponing indefinitely the analysis of formulas that involve the negation and consistency operators. Notwithstanding, this system is decidable. This system has been implemented but the source code is not available.
In [4] two tableau systems for C1 were presented, the second one being a version of the first one considered by the authors more adequate to be implemented. The first system has 12 rules (8 of them are branching rules) while the second has 20 rules (12 of them are branching rules). The rules are rather complex, involving much more formulas and connectives than C1 KE rules. The second system was elegantly implemented in LISP (the source code is available in [3]). However it was written in a LISP dialect (muLISP) which cannot be compiled in modern LISP compilers.
We have experimented using Buchsbaum’s system with the formulae described
in Section 5. For example, it was not able to prove instance Φ5  due to lack of
memory. This confirms that the family Φ5 is a family of difficult problems. We are
translating this prover to a different LISP dialect to make it more robust.

Another C1 tableau system appears in [6]. It was obtained by using a gen- eral method for constructing tableau systems [5]. Although this system has a PB branching rule, a feature of KE systems, is not a KE system. To be a KE system it should have only one branching rule, but it has 8 branching rules. Just like the system in [7], it is based on AT. However, it does not have rules that lead to infinite loops. We do not know of any implementation of this method.
In [15], tableau systems for several logics of the Cn hierarchy were presented. The C1 tableau system presented there is also based on AT. While in the previous systems ◦A d=ef ¬(A ∧ ¬A) was applied whenever necessary to generate the branches
of the tableau, this system has specific rules to directly deal with all operators, including “◦”. However, as it is based on the analytic tableau method, it also has too many (six) branching rules. We also do not know of any implementation of this method.
Therefore, the distinctive feature of our C1 KE system is that it has 13 essential rules and only of them is a branching rule. This feature will allow us to implement efficient strategies for this system in KEMS [20].

Conclusion
In this paper, we have presented a sound and complete KE system for Da Costa’s C1 calculus for paraconsistent logic. We have shown that our system has less branch- ing rules than other tableau systems for C1 described in the literature [3,4,6,7,15]. Therefore, it is probably more efficient than those systems (see [12] for a discussion on why branching leads to inefficiency).
We have also described a strategy for this KE system that can be implemented in KEMS. Future work includes implementing this strategy, as well as designing and implementing other strategies for the C1 KE system.
In order to evaluate C1 KE strategies, we have developed two problem families. These families and the first four problem families described in section D.1.2 of
[18] can also be used to evaluate other theorem provers for C1, such as Arthur
Buchsbaum’s prover for C1 [3].
As further work, we intend to compare the results obtained by our strategies (in the style of section D.2 of [18]) among themselves as well as with Arthur Buchs- baum’s prover.

References
Kent Beck. Test Driven Development: By Example. Addison-Wesley Professional, November 2002.
Krysia Broda, Marcello D’Agostino, and Marco Mondadori. A Solution to a Problem of Popper. In Proceedings of the conference Karl Popper Philosopher of Science, 1995. http://citeseerx.ist.psu. edu/viewdoc/summary?doi=10.1.1.43.7542. Last accessed, June 2009.
Arthur Buchsbaum. An automatic proof method for paraconsistent logic (in portuguese), 1988. Available at http://migre.me/gQD. Last accessed, Mar 2009.
Arthur Buchsbaum and Tarcisio Pequeno. A reasoning method for a paraconsistent logic. Studia Logica, 52(2):281–289, June 1993.


Carlos Caleiro, Walter Carnielli, Marcelo Coniglio, and Joao Marcos. Two’s company: The humbug of many logical values. In Logica Universalis, pages 169–189. Birkhauser Basel, 2005.
Walter Carnielli, Marcelo E. Coniglio, and Joao Marcos. Handbook of the Philosophical Logic, volume 14, chapter Logics of Formal Inconsistency, pages 15–107. Springer-Verlag, second edition, 2007.
Walter Alexandre Carnielli and Mamede Lima-Marques. Reasoning under inconsistent knowledge.
Journal of Applied Non-Classical Logics, 2(1), 1992.
Newton C. A. da Costa. Sistemas Formais Inconsistentes. Rio de Janeiro, NEPE, 1963. Reprinted by Editora da UFPR, Curitiba, 1993.
Newton C. A. da Costa and E. H. Alves. A semantical analysis of the calculi Cn. Notre Dame Journal of Formal Logic, 18(4):621–630, 1977. Available at http://migre.me/gMA. Last accessed, Mar 2009.
Newton C. A. da Costa, Decio Krause, and Otavio Bueno. Handbook of the Philosophy of Science. Philosophy of Logic, chapter Paraconsistent Logics and Paraconsistency, pages 791–911. Elsevier, 2007.
Marcello D’Agostino. Are Tableaux an Improvement on Truth-Tables? Cut-Free proofs and Bivalence. Journal of Logic, Language and Information, pages 235–252, 1992. Available at http://citeseer.nj. nec.com/140346.html. Last accessed, May 2005.
Marcello D’Agostino. Tableau methods for classical propositional logic. In Marcello D’Agostino et al., editor, Handbook of Tableau Methods, chapter 1, pages 45–123. Kluwer Academic Press, 1999.
Marcello D’Agostino and Marco Mondadori. The taming of the cut: Classical refutations with analytic cut. Journal of Logic and Computation, pages 285–319, 1994.
Fabio Romeu de Carvalho, Israel Brunstein, and Jair Minoro Abe. Prevision of Medical Diagnosis Based on Paraconsistent Annotated Logic. International Journal of Computing Anticipatory Systems, 18:288–297, 2005.
Itala M. Loffredo D’Ottaviano and Milton Augustinis de Castro. Analytical tableaux for da costa’s hierarchy of paraconsistent logics. Electronic Notes in Theoretical Computer Science, 143:27 – 44, 2006. Proceedings of the 12th Workshop on Logic, Language, Information and Computation (WoLLIC 2005).
Fahim T. Imam, Wendy MacCaull, and Margaret Ann Kennedy. Merging healthcare ontologies: Inconsistency tolerance and implementation issues. Proceedings of the Twentieth IEEE International Symposium on Computer-Based Medical Systems, pages 530–535, 2007.
Decio Krause, Emerson Faria Nobre, and Martin Musicante. Bibel’s matrix connection method in paraconsistent logic: general concepts and implementation. In Proceedings of the XXI International Conference of the Chilean Computer Science Society, pages 161–167, 2001.
Adolfo Neto. A Multi-Strategy Tableau Prover. PhD thesis, University of Sao Paulo, 2007. Available at http://www.dainf.ct.utfpr.edu.br/~adolfo/Thesis/. Last accessed, Mar 2009.
Adolfo Neto and Marcelo Finger. Effective Prover for Minimal Inconsistency Logic. In Artificial Intelligence in Theory and Practice, IFIP, pages 465–474. Springer Verlag, 2006. Available at http:
//www.springerlink.com/content/b80728w7m6885765. Last accessed, November 2006.
Adolfo Neto and Marcelo Finger. KEMS - A KE-based Multi-Strategy Tableau Prover, 2006. http:
//www.dainf.ct.utfpr.edu.br/~adolfo/KEMS. Last accessed, April 2009.
Adolfo Neto and Marcelo Finger. A KE tableau for a logic of formal inconsistency. In Proceedings of TABLEAUX’07 position papers and Workshop on Agents, Logic and Theorem Proving. Technical Report (LSIS.RR.2007.002) of the LSIS/Universit´e Paul C´ezanne, Marseille, France, 2007.
Raymond M. Smullyan. First-Order Logic. Springer-Verlag, 1968.
Cl´audio Rodrigo Torres, Germano Lambert-Torres, Luiz Eduardo Borges da Silva, and Jair Minoro Abe. Intelligent system of paraconsistent logic to control autonomous moving robots. In IEEE Industrial Electronics, IECON 2006 - 32nd Annual Conference on, pages 4009–4013, Nov. 2006.
