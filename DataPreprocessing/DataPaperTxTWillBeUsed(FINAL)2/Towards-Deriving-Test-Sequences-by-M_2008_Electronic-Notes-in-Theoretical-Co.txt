Electronic Notes in Theoretical Computer Science 195 (2008) 21–40	
www.elsevier.com/locate/entcs

Towards Deriving Test Sequences by Model Checking
Adilson Luiz Bonifa´cio1	Arnaldo Vieira Moura2
Computing Institute, University of Campinas
P.O. 6176 – Campinas – Brazil – 13081-970
Adenilso da Silva Sima˜o3	Jos´e Carlos Maldonado4
Mathematic Science and Computing Institute, University of Sa˜o Paulo
P.O. 668 – S˜ao Carlos – Brazil – 13560-970

Abstract
Model-based testing automatically generates test cases from a model describing the behavior of the system under test. Although there exist several model-based formal testing methods, they usually do not address time constraints, mainly due to the fact that some supporting formalisms do not allow a suitable represen- tation of time. In this paper, we consider such constraints in a framework of Timed Extended Finite State Machines (TEFSMs), which augment the Extended Finite State Machine (EFSM) model by including a notion of explicit and implicit time advancement. We use this extension to address conformance testing by reducing the confirming configuration problem to the problem of finding a path in a TEFSM product.
Keywords: Model Checking, Timed EFSM, Conformance testing, Suspicious Configuration.


Introduction
Model-based testing comprises the automatic generation of efficient test cases using models of system requirements, usually based on formally specified system function- alities. It involves the (i) construction of a suitable formal model, (ii) derivation of test inputs, (iii) calculation of test outputs, (iv) execution of test inputs over implementations, (v) comparison of the results from the calculated test outputs and the implementation executions, and (vi) decision of whether the testing should be stopped. All these tasks are tightly related to each other. For instance, the

1 Email: adilson@ic.unicamp.br
2 Email: arnaldo@ic.unicamp.br
3 Email: adenilso@icmc.usp.br
4 Email: jcmaldon@icmc.usp.br

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.08.025

way the model is written impacts on how test inputs can be generated. Moreover, the decision of whether the implementation has already been tested enough de- pends on one’s ability to determine how many undiscovered faults may remain in it. Usually the purpose of testing is not to demonstrate that the implementation is equivalent to its specification, since this goal is infeasible for most practical applica- tions. Instead, this ideal equivalence is relaxed into a conformance relation [13,15]. The so-called conformance testing aims at demonstrating that the implementation behavior conforms (in some sense) to the behavior dictated by the specification [29]. The problem of generating test cases for conformance testing based on Finite State Machines (FSMs) has already been investigated [7,21,28,8,14,12]. However, there are many situations in which the modeling of the system as a FSM is cum- bersome, due to the state explosion problem, or even impossible, due to the fact that there are some relevant aspects that can not be properly expressed, e.g., the passage of time. Some extensions to the FSM model have been proposed in order to overcome these problems [33,6,1]. Other extensions incorporate notions like con- text variables and input/output parameters, allowing the succinct representation of many different configurations [27]. Still others incorporate notions of time, allowing
the model to capture the evolution of time [24,4,36].
An Extended Finite State Machine (EFSM) can be thought of as a folded FSM [27]. Given an EFSM, and assuming that domains are finite, it is possible to un- fold it into a pure FSM by expanding the values of its parameters and variables. The resulting FSM can be used with FSM-based methods for test derivation with complete fault coverage, which means that all fault possibilities can be exhausted. Nonetheless, in most practical situations, this approach is unfeasible, mainly due to the state explosion effect [22,27].
Time plays an important role in determining the acceptability of system behavior in many system categories since not only the input/output relationship can be relevant, but also the period of time when those events occur may be important. In such cases, it is mandatory to be able to represent time constraints of the system, and to test whether a given implementation conforms to these constraints. There are some formalisms that allow the representation of various time related concepts, such as Timed Petri Nets [19] and Timed Automata [2,1,32,11]. Nonetheless, there are few, if any, methods that allow a satisfactory derivation of adequate test cases from those models.
We are interested in model-based methods for testing systems with time con- straints. In particular, we are addressing the problem posed in tasks (i)-(iii) alluded to above, namely the construction of an adequate formalism for modeling systems and the automatic generation of test cases, as well as the determination of the ex- pected outputs. These tasks are closely related, and should be considered together.
To this end, we define Timed EFSMs [5], or TEFSMs, by including the notion of explicit and implicit time advancement in the EFSM formalism. Then, we can adapt some well-established results, derived for FSMs and EFSMs, to the context of systems that require time constraints. In particular, we address the problem of configuration confirmation for TEFSMs in the same vein as done by Petrenko

et al. for EFSMs [27]. In that work, it is shown how the problem of configura- tion confirmation for EFSMs can be reduced to the problem of finding a path in an EFSM product. By defining a property that states when no such a path ex- ists, model-checking techniques can be used to generate a confirming sequence. We show how the notion of product machines and confirming sequences can be applied to the extended formalism of TEFSMs. Given a configuration and a set of suspi- cious configurations, a confirming sequence is a sequence of (parameterized) inputs that allows us to distinguish the given configuration from suspicious configurations by comparing outputs and, possibly, observing the time indicated in each of the outputs. Finding a confirming sequence can also be seen as an extension of the state identification problem [20,16].
This paper is organized as follows. In Section 2 we present the concepts of EFSMs and Extended Timed Transition Systems [7]. In Section 3 we introduce the Timed Extended FSMs. The product of TEFSMs is presented in Section 4. In Section 5 we describe how the TEFSM product can be used in a model-checking set-up, and illustrate this process with a simple example in Section 6. Finally, in Section 7, we draw some concluding remarks and indicate possible directions for future research.

Basic Formal Concepts
In this section, we give a brief overview of the formal concepts that are involved in this work. First, we present EFSMs which are used to specify system requirements. Next, important aspects of extended timed transition systems are introduced.
Extended FSM Model
An EFSM is an extension of a conventional FSM. In contrast to FSMs, in the EFSM model we have to consider other items [27], such as input and output parameters, and context variables. Also, update and output functions, as well as predicates are defined over context variables and input parameters.
Let X and Y be finite sets of input and output symbols. Let R be a finite set of parameter symbols. For z ∈ X ∪ Y , we denote by Rz ⊆ R the set of parameters associated with z. Also Dz denotes the set of parameter valuations associated with
z. An element of Dz maps Rz to some valuation domain. Similarly, let V be a finite set of context variable names, with DV denoting a set of valuations for V . At this point, there is no need to further specify the valuation domains. An EFSM M over X, Y , R, V and the associated valuation domains is a tuple (S, T, s0, λ0), where S and T are finite sets of states and transitions, respectively, s0 ∈ S is the initial state, and λ0 is an initial context variable valuation. Each transition t ∈ T is a tuple (s, x, P, op, y, up, s'), where:
s, s' ∈ S are the source and the target states of the transition, respectively;
x ∈ X is the input symbol of the transition;
y ∈ Y is the output symbol of the transition;

P , op and up are functions defined over valuations of the input parameters and context variables V , thus:
P : Dx × DV → {T rue, False} is the predicate of the transition;
op : Dx × DV → Dy is the output parameter function of the transition;
up : Dx × DV → DV is the context update function of the transition.
Given an input x and the set of input parameter valuations Dx, a parameterized input is a pair (x, px), where px ∈ Dx. The parameterized outputs are defined in a similar way. A configuration of M is a pair (s, λ) ∈ S × DV , where s is a state and λ is a context variable valuation. A transition (s, x, P, op, y, up, s') is enabled for a configuration (s, λ) and parameterized input (x, px) if P (px, λ) evaluates to true.
The machine starts from the initial configuration and operates as follows. Upon receiving an input along with the corresponding parameter valuation, and computes the predicates that are satisfied for the current configuration. From among the presently enabled transitions one will fire. By executing the chosen transition, the machine produces an output along with an output parameter valuation using of the output parameter function. The latter is computed by the output parameter valuation. The machine updates the current context variable valuation according to the context update function, and moves from the source to the target state of the transition.
An EFSM, furthermore, is considered to be:
Predicate complete: for each pair (s, x) ∈ S × X, every element in Dx × DV evaluates at least one predicate to true among the set of all predicates guarding transitions leaving s with input x;
Input complete: for each pair (s, x) ∈ S × X, there exists at least one transition leaving state s with input x;
Deterministic: any two transitions leaving the same state and with the same input have mutually exclusive predicates;
Observable: for each state s and each input x, every outgoing transition from s
on x has a distinct output symbol.

Extended Timed Transition Systems
We can extend the original timed transition system (TTS) notion of [7] by asso- ciating a set of clocks and invariant conditions with each state. All clocks in the model increase in an uniform way, according to a global time frame [1,2], and the corresponding invariant condition must hold in the current state of the model.
First, we say how clocks behave during system evolution [1]. Let C be the set of clock names (or clocks, for short), Φ(C) is the set of clock constraints δ in the form,
δ := c ≤ τ | τ ≤ c | ¬δ | δ1 ∧ δ2,
where c is a clock and τ ∈ Q 5 is a time instant. A clock interpretation, ν, is a

5 Q is the set of rationals and Q>0 is the set of positive rationals.

mapping from C to Q. The set of clock interpretations is denoted by [C '→ Q]. An interpretation ν over C satisfies δ ∈ Φ(C), written ν ▶ δ, iff δ evaluates to true when each clock c is substituted by ν(c) in δ.
Let ν ∈ [C '→ Q] be a clock interpretation. For τ ∈ Q, we define the clock interpretation ν + τ , which maps each clock c to the value ν(c)+ τ . Also, for K ⊆ C, [K '→ τ ]ν is the clock interpretation that assigns τ ∈ Q to each clock c ∈ K and agrees with ν on the rest of the clocks.
An Extended TTS (ETTS) is given by a tuple (S, s0, X, C,Inv, −→), where S is a finite set of states, s0 ∈ S is the initial state, X is a finite set of events, C is a finite set of clocks, Inv : S → Φ(C) maps states to invariant conditions, and −→ is a transition relation, where −→⊆ (S × X × 2C × Φ(C) × S). A configuration is given by a pair (s, ν), where s is a state and ν is a clock interpretation. The initial configuration is given by (s0, ν0), where ν0(c)= 0, for all c ∈ C, is the initial clock interpretation, and ν0 ▶ Inv(s0). Given a configuration (s, ν), a transition (s, x, K, δ, s') indicates that from state s, receiving the input event x, and provided that ν satisfies δ, the system may move to state s', resetting all the clocks in K to zero. The ETTS always starts in the initial configuration (s0, ν0), and with the (global) time set to zero.
A time sequence is a sequence τ¯ = τ0τ1τ2 .. ., where τi ∈ Q, i ≥ 0, τ0 = 0, and τi ≥ τi−1, i ≥ 1. A timed sequence is a pair (x¯, τ¯), where τ¯ is a time sequence and x¯ = x0x1x2 ... is a sequence of input symbols. The intuitive idea is that the symbol xi occurs at time τi. Given two configurations, (s1, ν1) and (s2, ν2), a time delay τ ≥ 0 and an input x, we say that (s2, ν2) evolves from (s1, ν1) over τ and x,

denoted by (s1, ν1) →x
τ
(s2, ν2), iff there is a transition (s1, x, K, δ, s2) such that:

ν1 + η ▶ Inv(s1) for all 0 ≤ η ≤ τ ,
ν1 + τ ▶ δ,
ν2 = [K '→ 0](ν1 + τ ), and
ν2 ▶ Inv(s2).
A sequence of configurations γ¯ = γ0γ1γ2 ... is a run of M iff γ0 is the initial configuration of M , and there is a timed input (x¯, τ¯) such that


γi−1
−x→i
θi
γi, where θi
= τi
— τi−1
, i ≥ 1.


In this case, we say that γ¯ is a run of M over (x¯, τ¯) from γ0.
Note that, in a timed sequence (x¯, τ¯), time evolves by (τi − τi−1) units from the moment when xi−1 occurred until xi occurs (for i > 1). Intuitively a run captures the system evolution, as follows:
it starts at state s0, with all clocks set to zero;
time evolves by τ1 − τ0 = τ1 units;
at instant τ1 the system changes to state s1 on input x1 while resetting clocks in K1 to zero;

time evolves by another τ2 − τ1 units;
at instant τ1 + (τ2 − τ1)= τ2 the system changes to state s2 on input x2 while resetting clocks in K2 to zero;
and so on.
We can see that:
a change of state can only occur when the transition (s, x, K, δ, s') is enabled, i.e., when δ is satisfied in the present configuration;
clocks can be reset to zero in any transition;
any clock reading is the elapsed time since the last instant it was reset to zero; and
all clocks increase uniformly according to a global time frame.

The Timed EFSM model
In the previous sections, we have presented two formalisms: EFSMs and ETTSs. While EFSMs capture the relationships between inputs, outputs and context vari- ables, ETTSs offer a treatment of time evolution and its constraints. We observe that there are several methods and techniques for deriving tests from (E)FSM mod- els (e.g., [27,17,8,26]). However, the derivation of test cases from (E)TTSs is less established, although some works have considered it (e.g., [30,7,18]). It is worth combining both ETTSs and EFSMs formalisms in order to benefit from the power of both models in terms of expressiveness. This section redefines the EFSM model in order to capture real-time. We use the ETTS definition as inspiration for this purpose.

Creating a TEFSM model from an ETTS and an EFSM model
Let X be a finite set of inputs, Y be a finite set of outputs, C be a finite set of clocks, R be a finite set of parameters, and V be a finite set of context variables. A Timed Extended Finite State Machine, or TEFSM, M over X, Y , R, V , C, and the associated valuation domains is a tuple (S, T, Inv, s0, ν0, λ0), where S and T are finite sets of states and transitions, respectively, Inv is a finite set of invariant conditions associated with states and, s0 ∈ S is the initial state, ν0 = [C '→ 0] is the initial clock interpretation and λ0 is an initial context variable valuation. In the TEFSM model: (i) the dynamic behavior is given by clocks and their resetting, as in the ETTS model; and (ii) the data and control flow are given by parameters and context variables, as in the EFSM model. A transition t ∈ T is expressed by a tuple (s, x, Q, K, op, y, up, s'), where:
s, x, s' and K are as defined in the ETTS formalism; see Section 2.2;
op, y, and up are as defined in the EFSM formalism; see Section 2.1;
Q : Dx × [C '→ Q] × DV → {T rue, False} is the predicate of the transition.

It can be seen that the TEFSM model comprises the EFSM formalism. That is, given a EFSM M over X, Y, R, V and some valuation domains, as defined in Sec- tion 2.1, we can construct a TEFSM model Mˆ over the same sets X, Y, R, V and the corresponding domains, by letting the clock set C be simply {c}. For each transition t = (s, x, P, op, y, up, s') in M , we define a transition tˆ = (s, x, Q, K, op, y, up, s') in
Mˆ by letting Q(px, ν, λ)= P (px, λ), for any (px, ν, λ) in Dx × [C '→ Q] × DV . We
also let K = ∅. Clearly, for any px ∈ Dx, λv ∈ DV and any clock interpretation ν ∈ [C '→ Q], we have that Q(px, ν, λv) is true iff P (px, λv) is true. For each state s ∈ S in M , we define the invariant condition Inˆv(s) = (c ≥ 0) in Mˆ . Clearly, ν ▶ Inˆv(s) for any ν ∈ [C '→ Q] and s ∈ S.
Also, any ETTS model can be cast as a TEFSM model. For that, let M = (S, s0, X, C,Inv, −→) be an ETTS model. Take a trivial common domain {0} for all parameters and context variables, a single output symbol Y = {o} and a single context variable V = {v}. For each parameter z ∈ X ∪ Y , we define Rz = {z}. Then, the set of z-valuations is the singleton Dz = {pz}, where pz maps z to 0, for all z ∈ X ∪ {o}. Similarly, DV = {λv}, where λv maps v to 0. Now, a transition t = (s, x, K, δ, s') in M gives rise to a corresponding transition tˆ =
(s, x, Q, K, op, o, up, s') in Mˆ , where:
op maps (px, λv) to po;
up maps (px, λv) to λv; and
Q maps (px, ν, λv) to T rue iff ν ▶ δ.
Here, the set of invariant conditions Inv for M is the same for Mˆ . The initial state

s0 in Mˆ
is the same initial state s0 from M .

A configuration of a TEFSM M is a triple (s, ν, λ), where s is a state, ν is a clock interpretation and λ is a context variable valuation. The initial configuration is (s0, ν0, λ0), where s0 is the initial state of M , ν0 is the initial clock interpretation of M and λ0 is an initial context variable valuation of M . A configuration (s, ν, λ) is valid iff ν ▶ Inv(s). Let Γ ⊆ S × [C '→ Q] × DV be the set of configurations of M .

The Operational Semantics for TEFSM models
Considering the dynamic behavior of ETTS models and the data and control flow of EFSM models, we define the operational semantics of a TEFSM M as follows.
Definition 3.1 Let γi = (si, νi, λi) ∈ Γ, i = 1, 2, be two configurations of M .
There is an implicit move from γ1 to γ2 iff
s1 = s2,
λ1 = λ2,
ν2 = ν1 + τ , for some τ ∈ Q>0, and
ν2 + η ▶ Inv(s1), for all η, 0 ≤ η ≤ τ .
We denote such an implicit move by γ1 −→ γ2.
τ

Definition 3.2 Let γi = (si, νi, λi) ∈ Γ, i = 1, 2, be two configurations of M . Let (x, px) be a parameterized input and (y, py) be a parameterized output. There is an explicit move from γ1 to γ2 over (x, px) and yielding (y, py) iff there is a transition (s1, x, Q, K, op, y, up, s2) in T such that:
ν2 = [K '→ 0]ν1,
ν2 ▶ Inv(s2),
Q maps (px, ν1, λ1) to T rue,
op maps (px, λ1) to py, and
up maps (px, λ1) to λ2.
χ/ξ
We denote such an explicit move by γ1 −→ γ2, where χ = (x, px)e ξ = (y, py).
Definition 3.3 Let γi = (si, νi, λi) ∈ Γ, i = 1, 2, 3; τ ∈ Q>0, (x, px) a parameter-
χ/ξ

ized input and (y, py) a parameterized output. If γ1 −→
τ
γ2 and γ2 −→ γ3, where

χ = (x, px)e ξ = (y, py), then we say that there is a move from γ1 to γ3 and indicate
χ/ξ
this by γ1 −→ γ3.
τ
Some of the decorations over and under −→ may be dropped if they are clear from the context.
A parameterized input sequence is any sequence ρ¯ = ρ1ρ2 ... where each ρi is a parameterized input. A parameterized timed input sequence, or timed input, is a pair (ρ¯, τ¯) where ρ¯ is a parameterized input and τ¯ is a time sequence. Simi- lar definitions hold for parameterized outputs. In particular a timed output is a parameterized timed output sequence.
A sequence of configurations γ¯ = γ0γ1γ2 ... is a run of M iff there are a timed input (ρ¯, τ¯) and a parameterized output sequence μ¯ such that


ρi/μi
γi−1 −→
θi
γi, where θi = τi − τi−1, for all i ≥ 1.

We say that the run is over the timed input (ρ¯, τ¯) and produces the timed output (μ¯, τ¯). We also say that (μ¯, τ¯), or μ¯, is produced by M from γ0 in response to (ρ¯, τ¯).
Some notions from the EFSM and ETTS models are extended to the TEFSM model:
A TEFSM M is said to be predicate complete if, from any configuration (s, ν, λ) and given any parameterized input (x, p), there is a delay τ and a transition (s, x, Q, K, op, y, up, s') such that Q evaluates (p, ν + τ, λ) to T rue and ν + η ▶ Inv(s), for all 0 ≤ η ≤ τ .
The TEFSM M is complete if, for each state s there is a transition leaving s on any input symbol x.
We say M is deterministic if, for any configuration (s, ν, λ), any parameter- ized input (x, p), and any time instant τ , there are no two different transitions (s, x, Q1, K1, op1, y1, up1, s1) and (s, x, Q2, K2, op2, y2, up2, s2) such that both Q1

and Q2 evaluate (p, ν + τ, λ) to T rue.
And, we say M is observable if, for any configuration (p, ν, λ), any parameter- ized input (x, p) there are no two transitions (s, x, Q1, K1, op1, y1, up1, s1) and (s, x, Q2, K2, op2, y2, up2, s2) with y1 /= y2 and with Q1 and Q2 both evaluating (p, ν, λ) to T rue.

Conﬁguration Distinguishability in the TEFSM model
Distinguishability of configurations in the Timed Extended Finite State Machine model is defined over parameterized input sequences. Two configurations γ and γ' of two distinct machines M and M ', respectively, are distinguishable over a timed input (ρ¯, τ¯) if the corresponding timed outputs (μ¯, τ¯) and (μ¯', τ¯'), produced by M and M ' over (ρ¯, τ¯) from γ and γ', respectively, are not compatible, in a sense to be defined shortly. We also say that (ρ¯, τ¯) is a timed input separating those two configurations. We formalize these notions in the sequel, extending the definitions in [27]. Given a context variable valuation λ and a set of variables U , the U -projection of λ is the valuation obtained from λ by retaining the variables that are in the set U , denoted by λ ↓ U . Similarly, for input symbols and their valuations, and for output symbols and the corresponding valuations.
Definition 3.4 Let y and y' be outputs of TEFSMs M and M ', respectively. Let R and R' be the sets of parameters associated, respectively, with y and y'. The parameterized outputs (y, p) and (y', p') are said to be compatible if y = y' and p ↓ R' = p' ↓ R. Two parameterized output sequences, (y1, p1) ... (yk, pk) of M and
(y' , p' ) ... (y' , p' ) of M ' are compatible if, for all i = 1,... , k, the parameterized
1	1	k	k
outputs (yi, pi) and (y', p') are compatible.
i	i
Intuitively, parameterized outputs are compatible when the output symbol is the same, and the output valuation agrees on all common output symbols. Distin- guishability of configurations is defined as follows.

Definition 3.5 Given a timed input α¯
= (ρ¯, τ¯), a configuration γ of M and a

configuration γ' of M ' are distinguishable by α¯ if parameterized output sequence produced by M from γ in response to α¯ is not compatible with any parameterized output sequence that can be produced by M ' from γ' in response to α¯. The timed input α¯ is said to be a sequence separating γ from γ'.

Timed Extended FSM Product
In Section 5 we extend to TEFSMs the method for the derivation of configuration confirming sequences defined in [27]. Since this method requires the notion of prod- uct machines, in this section we present the necessary extension of that notion to TEFSMs.
In the product of TEFSMs, the occurrence of implicit transitions can be ignored, since the global time frame which is used for all clock variables is the same for both

TEFSMs. This guarantees that the system evolution is maintained during implicit transitions.
Let Mi = (Si,Invi,T i), i = 1, 2, and γi = (si , νi, λi ), i = 1, 2, be two TEFSMs
0	0	0
and their corresponding initial configurations. The product machine is denoted by
M 1 × M 2. We will use superscript 1 to denote elements of M 1, like R1 is the set of parameters for M 1. Likewise, superscript 2 will indicate objects associated with M 2, like V 2 is the set of context variables of M 2. The superscript 1, 2 is reserved for the product machine M 1 × M 2.
The set of input symbols of M 1,2 is X1,2 = X1 ∪ X2. Likewise, Y 1,2 = Y 1 ∪ Y 2. The set of parameters of M 1,2 is given by R1,2 = R1 ∪ R2, with the proviso that for all z ∈ R1 ∩ R2, the valuations of z in M 1 and M 2 have a common domain. It is clear that we are using the same parameter domains in M 1,2 as they were in M 1 and
M 2. For any z ∈ X1,2 ∪ Y 1,2, we let R1,2 = R1 ∪ R2. Note that, given a valuation
z	z	z
r1,2 for elements in R1,2 we can get valuations r1 = r1,2 ↓ R1 and r2 = r1,2 ↓ R2, for

z	z	z	z	z
z	z	z

machines M 1 and M 2, respectively, and, moreover, r1,2 = r1 ∪r2. Similarly for clock
z	z	z
interpretations and context variable valuations. We assume that clocks and context
variables are disjoint, i.e., C1,2 = C1 ∪ C2, with C1 ∩ C2 = ∅, and V 1,2 = V 1 ∪ V 2, with V 1 ∩ V 2 = ∅. As for the valuation domains, they are the same as in M 1 as in M 2. The set of states of M 1,2 is given by S1,2 = S1 × (S2 ∪ {f ail}), where fail is a new state. The set of invariant conditions Inv1,2 of M 1,2 maps S1,2 to Φ(C1,2), and it is given by Inv1,2(s1, s2)= Inv1(s1) ∧ Inv2(s2), for all (s1, s2) ∈ S1,2. Moreover, Inv1,2(s1,fail)= Inv1(s1), for all s1 ∈ S1.
The initial configuration of M 1,2 will be given by γ1,2 = ((s1, s2), (ν1,2, λ1,2)),
0	0	0	0	0
where ν1,2 = ν1 ∪ ν2 and λ1,2 = λ1 ∪ λ2. Note that we can take unions here, since
0	0	0	0	0	0
clock and context variables are disjoint in M 1 and M 2.
It remains to specify the transitions of M 1,2. Let (si , x, Qi,Ki, opi, yi, upi, si ),
1	2
i = 1, 2, be transitions of M 1 and M 2, both with the same input x. In the following
definition we will be considering a parameterized input (x, p1,2), a clock interpre- tation ν1,2 and a context variable valuation λ1,2, all for the machine M 1,2.  We
also let p1 = p1,2 ↓ R1 and p2 = p1,2 ↓ R2. Likewise, we let ν1 = ν1,2 ↓ C1 and
x	x	x	x	x	x
ν2 = ν1,2 ↓ C2, and also λ1 = λ1,2 ↓ V 1 and λ2 = λ1,2 ↓ V 2. There are two cases:
case 1: y1 = y2 and op1(p, λ) ↓ R1,2 = op2(p, λ) ↓ R1,2, for all (p, λ) ∈ Dx × DV
where R1,2 = R11 ∩ R22 . That is, the output symbol is the same and the output
y	y
valuations of both transitions are the same on each common output parameter.
We add two transitions to T 1,2,
((s1, s2), x, Q, K, op, y1, up, (s1, s2)), where:
1	1	2	2
Q(p1,2, ν1,2, λ1,2)= Q1(p1, ν1, λ1) ∧ Q2(p2, ν2, λ2)
x	x	x
K = K1 ∪ K2
op(p1,2, λ1,2)= op1(p1, λ1) ∪ op2(p2, λ2). Recall that op1 and op2 coincide on
x	x	x
common output parameters and so we can safely take the union.
up(p1,2, λ1,2)= up1(p1, λ1) ∪ up2(p2, λ2). Recall that V 1 ∩ V 2 = ∅.
x	x	x
((s1, s2), x, Q, K, op, y1, up, (s1,fail)), where:
1	1	2

Q(p1,2, ν1,2, λ1,2)= Q1(p1, ν1, λ1) ∧ (¬Q2(p2, ν2, λ2))
x	x	x
K = K1
op(p1,2, λ1,2)= op1(p1, λ1)
x	x
up(p1,2, λ1,2)= up1(p1, λ1)
x	x
case 2: Else, when the output valuations or the output symbols do not match, we add the transition ((s1, s2), x, Q, K, op, y, up, (s1,fail)) to T 1,2, where:
1	1	2
Q(p1,2, ν1,2, λ1,2)= Q1(p1, ν1, λ1)
x	x
K = K1
op(p1,2, λ1,2)= op1(p1, λ1)
x	x
up(p1,2, λ1,2)= up1(p1, λ1)
x	x
Moreover, if (s1, x, Q, K, op, y, up, s1) is a transition of M 1, we add to M 1,2 the
1	2
transition ((s1,fail), x, Q, K, op, y, up, (s1,fail)).
1	2
Suppose that the product machine is in the state (s1, s2), and on input (x, p1,2)
1	1	x
we find that M 1, on state s1, has a transition on input (s1, p1), where p1 is the
1	1	x	x

reduction of p1,2
to the parameters associated with x in M 1. Similarly, M 2, on

state s2, has a transition on (x, p2 ). Moreover, the output of these transitions agree
1	x
on the output symbol y, and also on valuations of any common output parameter
of y in M 1 and in M 2. In this situation, we would want the product machine M 1,2 to enact both transitions of M 1 and M 2, componentwise. For that: (i) the same clocks are reset; (ii) the output parameter valuations are copied from M 1 and M 2; and (iii) both context updates are also carried over to M 1,2. But we can only enable this action in M 1,2 if both transitions in M 1 and M 2 are enabled. This is case 1(i). Otherwise, we consider the situation where the transition in M 1 is enabled, but the one in M 2 is not. Here, we follow case 1(ii), and make the product machine M 1,2 enact the behavior of M 1 using for that the first state component, while the second component is marked as fail, thereby ignoring the transition from M 2. Note that, in this scenario, M 1 might have taken its transition, while M 2 would be forbidden to do so, even when their external behavior would have been indistinguishable. After
the second state component is set to fail, M 1,2 behaves essentially as M 1.
Finally, when the product machine is in state (s1, s2), and we are considering
1	1
an input (x, p1,2), and we have picked two transitions from M 1 and M 2, starting respectively at s1 and s2, and whose output symbols or output parameter valuations
1	1
do not match as above, then we proceed as in case 2. This is similar to case 1(ii) in
that the second state component in M 1,2 is marked as fail, and M 1,2 uses the first state component to behave as M 1, from this moment on.
Consider configurations γi = (si, νi, λi) of machine Mi, i = 1, 2. Let ρ¯ = (x¯, p¯x) be a parameterized input sequence for M 1 × M 2, and let α¯ = (ρ¯, τ¯) is a timed input for M 1 × M 2. Note that, M 1 and M 2 can be the same machine with different initial configurations. We say that α¯ is a separating sequence for γ1 and γ2 iff there is a run γ¯ = γ0γ1 ... of M 1,2 over α¯, where γ0 = ((s1, s2), ν1 ∪ ν2, λ1 ∪ λ2) and for some
i ≥ 1, γi is a configuration of M 1,2 whose state is (s1,fail) for some s1 ∈ S1.
j	j
The problem of determining a separating sequence for two configurations of a

given TEFSM M can be reduced to a reachability problem. The reachability analy- sis is tractable but hard for EFSMs [23]. Indeed, for TEFSMs it is intractable. This is due to the temporal aspect within the new model. Another difficulty is the com- binatorial explosion in the number of states in product machines. Some approaches try to overcome this difficulty by relaxing their restrictions. Approximation algo- rithms are also used when doing reachability analysis. Other approaches adapted known algorithms in order to manipulate symbolic data structures [34,9,35].
Other simpler contexts [25,3] present algorithms to obtain separating sequences. We postulate that these ideas can be adapted and extended in order to obtain separating sequences in the TEFSM formalism. Such separating sequences would be the result of the test case generation procedure. Moreover, we have been working with the notion of automata discretization in order to overcome the problem of infinite time instants. In addition, it is possible to modify conventional algorithms to reduce the state space generated by the product machine. Another alternative to obtain tractability in a timed approach for finding separating sequences is through the use of suspicious configurations [5]. In this case, we can choose a set of suspicious states, representing a important class fault, based on the expertise of test designers and on assumptions of implementations faults, as seen in [13,31].

Test Generation
This section outlines the main concepts for test case generation. First, we present some discussion on the main rationale of conformance testing. Second, we discuss the notion of confirming configurations, and how it is applied. At last, we discuss deriving test sequences by model-checking for TEFSMs.
Conformance Testing
Conformance testing aims at determining whether an implementation behaves in accordance with a given specification [21,15]. In general, an implementation is regarded as a black box, of which only input/output interfaces are known. In this situation, to verify whether an implementation is in conformance to a specification usually requires an infinite set of test cases in order to exhaust all error possibilities in the implementation. To overcome this problem, one possibility is to define a set of test hypotheses in order to reduce the number of test cases to be considered [13]. Test hypotheses strike a balance between two conflicting aspects. On the one hand, test hypotheses must be defined to be restrictive enough to render the method feasible and tractable. On the other hand, these hypotheses must be as less restrictive as possible, in such a way to be applicable to the largest possible set of implementations.
Conformance testing is guided by a conformance relation between the implemen- tation and the specification [13]. In order to decide whether an implementation is in conformance to a specification, we observe the implementation’s outputs to some applied inputs. Considering real-time systems, it must be also verified whether an implementation when stimulated by inputs responds with the expected outputs

within an allowed time interval.
The problem of using a conformance relation is the number of test sequences which should be obtained in order to verify whether each possible implementation is in conformance to a given specification. This problem is worse for timed systems, where there are infinite time instants for a transition to occur. To overcome this problem, we also need to enforce certain hypotheses about the implementation, as discussed in Section 5. This set of hypotheses will reduce the number of possible faults to be considered over the implementation and will render the method feasible in practical cases.
Several methods employ identification sequences to generate test cases from models. An identification sequence has the property of determining the correctness of the configuration reached after some input sequence is taken. Identification se- quences may be defined as characterization sets [8,13], as distinguishing sequences
[17] or as confirming configuration sequences (CCSs) [27], depending on the model and the generation method. A CCS which are investigated in this paper is a se- quence that can increase the confidence that the correct configuration has been reached in the implementation.

Conﬁguration Conﬁrming Sequences
A configuration confirming sequence (CCS) is a timed input that can be applied to the implementation in order to increase the confidence on its correctness. A CCS can be derived from the product of two machines, one being a specification and the other an undesirable configuration. However, unlike the FSM models where a finite set of undesirable configurations can be postulated, with EFSM models and TEFSM models it is not possible, or desirable, to determine all undesirable configurations. To overcome this problem, a finite set of suspicious configurations is considered [27]. A set of suspicious configurations is derived from the specification to model suspicious implementations which can potentially have faults, reflecting the test designer’s assumptions about the implementation faults. The suspicious configurations are extracted from the specification using a set of test hypotheses based on the fault model (e.g., [13]) and relying on the test designer’s expertise.
These hypotheses define equivalence classes of implementations that must be put under testing, and they are used to reduce the number of possible implementations that need to be considered. In this work, we assume the following test hypotheses:
Specifications and suspicious implementations are modeled by TEFSMs;
The number of clocks in the specification must be less than or equal to the number of clocks in the suspicious implementations; and
The same alphabets are used in both specification and suspicious implementa- tions.
Given a configuration and a suspicious configuration, deriving a CCS can be reduced to the problem of finding a path in the product of two distinct TEFSMs, or of the same core TEFSM with distinct initial configurations. Such a sought

path would run from the initial state to a fail state. If the fail state can not be reached, then the suspicious configuration is equivalent to the original configuration. However, if a fail state is reachable, the model-checking algorithm will produce a counter-example, as a sequence of transitions that leads to this fail state [10]. This sequence would make a test case for the suspicious configuration. However, it is still necessary to identify in which moment each transition was taken, as well as the valuation of the input parameters associated with each input symbol. Gathering of this information forms a set of test cases. The test case is then used to exercise a real implementation, and the outputs are compared with the outputs produced by the specification over the same data. If a disagreement is found between corresponding outputs, then a fault has been identified.

Model-checking
Design errors frequently occur when conventional simulation and testing techniques are used to check safety systems. Model checking is a set of techniques for the automatic analysis of reactive and real-time systems. Some model checking algo- rithms have been modified to discover such errors, thus providing more quality and accuracy in system verifications. In general, given a transition system and a prop- erty, the model checking problem is to decide whether the property holds or not in the model represented by the transition system. If not, the model checking algo- rithm provides a counterexample, i.e. an execution over the model that violates the property [23].
Reachability analysis is a special kind of model-checking method that can be applied in a formal model. In general, given a special state to be found in a model, the reachability analysis decides if it is possible to move from the initial state to the final special state.
To summarize, to automatically test implementations based on a specification represented by a machine M , the following steps are performed:
An empty set TC of test cases is defined.
Given a configuration γ of M , a set of suspicious configurations Γ is defined, based on test hypotheses, fault models and some specific test engineer’s objec- tives.
For each suspicious configuration γs ∈ Γ, the product of M with itself is con- structed, having γ as the initial configuration of the first instance of M in the product, and having γs as the initial configuration of the second instance.
Reachability analysis is carried out, in order to find a path to a fail state in the product machine. If such a path is found, it is added to TC.
For each tc ∈ TC, a time and an input parameter valuation sequences are derived so as to satisfy the predicates along the path specified by tc.
Each path in TC, with its associated data, is applied to the real implementation under testing.

An Example
We are given two TEFSMs M and N , where M is a specification and N is a suspicious implementation of M . We obtain the product of these machines, M × N , by applying our method. In this example, as is usual in practice, N has the same transitions as M . They differ only in their associated initial configurations. Accordingly, we will denote the product by M 0 × M 1, where M 0 is the specification and M 1 is the suspicious configuration. The TEFSM M depicted in Figure 1.
s2








a, x ≥ 5, {x, y},c 
b, x < 5, {x, y},d 
s1	s3

b, y ≤ 16, {x, y}, e(w)
a, x ≤ 4 ∧ w ≤ 4, {x}, c,w := w +1 

Fig. 1. The TEFSM M .
It has three states and seven transitions. The input set is {a, b} and the output set is {c, d, e}. Furthermore, M has two clock variables, x and y, and one context variable w. There are no parameters associated with the input symbols, i.e. Ra = Rb = ∅. Likewise, Rc = Rd = ∅. For each state s in M , the control remains in s whenever its invariant condition is satisfied. The output e has only one associated parameter. In this case, it is not necessary to name the parameter. Instead, in Figure 1 and in the sequel we write e(w) to indicate that the current value of the context variable w is to be attributed to the parameter associated with e. In the figure, each arrow is labeled by a sequence of items. The first three are always the input symbol, the predicate function and the set of clocks to be reset in the transition, respectively. Next, comes the output symbols, either c or d, and we write directly e(w) to indicate both the output symbol and the value of its parameter. Finally, if the value of the context variable w is altered by the transition, this is indicated by the attribution that appears at the end of the label; if the value of w is not altered by the transition we simply omit the trivial expression w := w.
A configuration of M is given by a state, a clock interpretation and a context

variable valuation. Hence, a configuration of M will be denoted by (s, (n, m), k) in- dicating that the machine is in state s, n and m are the values for the clock variables x and y, respectively, and k is the value for the context variable w. The integers are selected as a common valuation domain. In the configuration (s1, (3, 2), 4) the transition a, x ≤ 4 ∧ w ≤ 4, {x}, c,w := w + 1, from s1 to itself, is enabled. Likewise, the transition b, y ≤ 16, {x, y}, e(w), from s1 to s3, is also enabled.
For the product, let M 0 designate M with the initial configuration (s1, (0, 0), 2), and let M 1 designate M with initial configuration (s1, (4, 2), 5). The TEFSM prod- uct of M 0 × M 1 is shown in Figure 2. To simplify the notation in the example, we will use subscript i to denote items of machine Mi, for i = 0, 1, e.g. x1 represents the clock variable x of M1, while w0 denotes the variable w in M 0.
The initial configuration of M 0 × M 1 is denoted by ((s1, s1), (0, 0, 2, 4), (2, 5)), where we list first the items corresponding to M 0, followed by the items associated with M 1. Note that, in the figure, states are represented by subscripts, e.g., the state (s1, s1) in the product is named s11.
By inspection of the product, we can see that the input b enables the transi- tion to fire, since clock conditions on y0 and y1 are satisfied for the initial con- figuration. After that the transition is taken, the new configuration is given by ((s3, s3), (0, 0, 2, 0), (0, 5)). It is easy to see that neither input a nor input b will enable transitions to fire so as to reach, directly, a fail state. Note that, every clock variable was reset to zero, and transition guards are excluding for clock variables x0 and x1. If the input b occurs within less than 5 time units, the configuration becomes ((s1, s1), (0, 0, 2, 0), (0, 5)). Otherwise, if the time evolves for more than 5 time units, only the input a could stimulate the machine to change configurations. The new configuration would still be ((s1, s1), (0, 0, 2, 0), (0, 5)). Both transitions would drive the control back to the initial state, where the transition stimulated by input b is the unique one enabled to fire. This cycle would be executed repeatedly and a fail state would not be reached.
Another possibility is to take the transition on the input a. It is easy to see that the input a separates the configurations (0, 0, 2) from (4, 2, 5). The final con-
figuration reached is ((s1,fail), (0, 0, 3, 4), (2, 5)). On the other hand, the control can be kept within the state (s1, s1), by a continuous time evolution. After that, the stimulation by input a enables the transition to fire, and the configuration ((s1, s1), (1, 1, 2, 5), (3, 5)) can be reached. Then, the transition from state (s1, s1), on input a and with associated predicate x0 ≤ 4 ∧ w0 ≤ 4 ∧ (w1 > 4 ∨ x1 > 4) is enabled and takes the machine to the fail state (s1,fail). Here, only the clock variable x0 is reset, and the context variable w0 is updated by one unit. The new configuration will be ((s1,fail), (0, 1, 3, 5), (3, 5)). From here, we see that input a
separates the configuration (0, 0, 2) from (4, 2, 5), after some time passes. The new
configuration that can be reached in this case is ((s1,fail), (0, 1, 3, 5), (3, 5)).
If we consider another situation, where the initial configurations of M 0 and M 1, respectively, are given by (0, 0, 2) and (4, 2, 4), another run of M 0 × M 1 will also reach the fail state. In this case, a reachability analysis shows that the fail state of M 0 × M 1 can only be reached when a sequence of one or two consecutive inputs a



s2fail

s1fail



















b, y0 ≤ 16 ∧ y1 ≤ 16), {x0, y0, x1, y1}, e(w0), e(w1)


s11	s33
b, x0 < 5 ∧ x1 < 5), {x0, y0, x1, y1},d 
a, x0 ≥ 5 ∧ x1 ≥ 5), {x0, y0, x1, y1},c 

















s3fail
a, x0 > 1 ∧ y0 < 17 ∧ (x1 ≥ 1 ∨ y1 ≥ 17), {x0, y0, x1, y1},c b, x0 ≤ 1 ∧ y0 ≥ 17 ∧ (x1 ≥ 1 ∨ y1 ≤ 17), {x0, y0}, e(w0)

s22

Fig. 2. The TEFSM product of M with itself.

is applied.
In the example, M 0 represents the specification, M 1 represents a suspicious im- plementation, and the product M 0 × M 1 is used to find sequences of configurations that show non conformance between a suspicious implementation and the specifica- tion. We can derive traces from the reachability analysis of M 0 × M 1. The resulting traces are runs that reach the fail state in the product machine, starting from the initial configurations of the participating TEFSMs.

Concluding Remarks
The ability to derive test cases from formal models opens the possibility that we can construct more rigorous and dependable systems, by providing a sound basis for the validation of the systems’ behaviors. There is a direct relationship between the kinds of systems that a given model can deal with and the availability of methods for deriving test cases. The FSM and EFSM models are well-established and have been intensively investigated. One important feature they both lack is the ability to deal with time. In this paper we define TEFSMs as a model that extends the EFSM model with the notion of time. From that, we discussed an extended method for deriving configuration confirming sequences for TEFSMs, a step toward automating the generation of test cases from these models.
Although we can argue that both the model and the generation method can be used, we do not have answers for pragmatic questions, such as (i) how difficult is it to describe a system using TEFSMs and (ii) how large are the models we can handle. To answer these questions, it is necessary to deepen the investigations and implement adequate supporting software tools. We are currently working in this direction.
Other aspects that can be investigated include how to allow time constraint to be defined over outputs. We note that our definition does not deal with constraints that may reflect output response that is not instantaneous. The input and output occur in the same time instant. We are considering how this extension might impact the test case generation methods.

References
Alur, R., Timed automata, in: CAV, number 1633 in LNCS, 1999, pp. 8–22.
Alur, R. and D. L. Dill, A theory of timed automata, Theoretical Computer Science 126 (1994), pp. 183– 235.
URL citeseer.ist.psu.edu/alur94theory.html
Alur, R., M. McDougall and Z. Yang, Exploiting behavioral hierarchy for efficient model checking., in:
CAV, 2002, pp. 338–342.
Behrmann, G., K. G. Larsen, J. Pearson, C. Weise and W. Yi, Efficient timed reachability analysis using clock difference diagrams, in: Computer Aided Verification, 1999, pp. 341–353.
URL citeseer.ist.psu.edu/article/behrmann99efficient.html

Bonif´acio, A. L., A. V. Moura, A. d. S. Sim˜ao and J. C. Maldonado, Conformance Testing by Model Checking Timed Extended Finite State Machines, in: Brazilian Symposium on Formal Methods (SBMF’06), Natal, 2006, pp. 43–58.
Campos, S. V., M. Minea, W. Marrero, E. M. Clarke and H. Hiraishi, Computing quantitative characteristics of finite-state real-time systems, in: Proc. 15th IEEE Real-Time Systems Symp. (1994),
pp. 266–270, san Juan, Porto Rico.
Cardell-Oliver, R., Conformance tests for real-time systems with timed automata specifications, Formal Aspects of Computing 12 (2000), pp. 350–371.
URL citeseer.ist.psu.edu/385816.html

Chow, T. S., Testing software design modeled by finite-state machines, IEEE Transactions on Software Engineering 4 (1978), pp. 178–187.
Cimatti, A., E. Giunchiglia, M. Pistore, M. Roveri, R. Sebastiani and A. Tacchella, Integrating bdd-based and sat-based symbolic model checking., in: FroCos, 2002, pp. 49–56.

da Silva, D. A. and P. D. L. Machado, Towards test purpose generation from ctl properties for reactive systems., Electr. Notes Theor. Comput. Sci. 164 (2006), pp. 29–40.
Dickh¨ofer, M. and T. Wilke, Timed alternating tree automata: the automata-theoretic solution to the tctl model checking problem, in: 26th ICALP, LNCS 1644, 1999, pp. 281–290.
URL citeseer.ist.psu.edu/article/dickhfer99timed.html

Dorofeeva, R., K. El-Fakih and N. Yevtushenko, An improved conformance testing method, in: Formal Techniques for Networked and Distributed Systems, Lecture Notes in Computer Science 3731 (2005),
pp. 204–218.
En-Nouaary, A., R. Dssouli and F. Khendek, Timed wp-method: Testing real-time systems, IEEE Trans. Softw. Eng. 28 (2002), pp. 1023–1038.
Fujiwara, S., G. V. Bochmann, F. Khendek, M. Amalou and A. Ghedamsi, Test selection based on finite state models, IEEE Transaction on Software Engineering 17 (1991).
Gargantini, A., Conformance testing, in: M. Broy, B. Jonsson, J.-P. Katoen, M. Leucker and
A. Pretschner, editors, Model-Based Testing of Reactive Systems: Advanced Lectures, Lecture Notes in Computer Science 3472 (2005), pp. 87–111.
Gill, A., “Introduction to the theory of finite-state machines,” McGraw-Hill, New York, 1962.
Gonnenc, G., A method for the design of fault detection experiments, IEEE Transactions on Computing
19 (1970), pp. 551–558.
Higashino, T., A. Nakata, K. Taniguchi and A. R. Cavalli, Generating test cases for a timed i/o automaton model, in: Proceedings of the IFIP TC6 12th International Workshop on Testing Communicating Systems (1999), pp. 197–214.
Hirai, T., An application of temporal linear logic to Timed Petri Nets, in: Proceedings of the Petri Nets’99 Workshop on Applications of Petri Nets to Intelligent System Development, 1999, pp. 2–13.
Krichen, M., State identification, in: M. Broy, B. Jonsson, J.-P. Katoen, M. Leucker and A. Pretschner, editors, Model-Based Testing of Reactive Systems: Advanced Lectures, Lecture Notes in Computer Science 3472 (2005), pp. 87–111.
Krichen, M. and S. Tripakis, Black-box conformance testing for real-time systems, in: Model Checking Software: 11th International SPIN Workshop, number 2989 in Lecture Notes in Computer Science, Barcelona, Spain, 2004, pp. 109–126.
McMillan, K. L., “Symbolic Model Checking: An Approach to the State Explosion Problem,” Kluwer Academic, 1993.
Merz, S., Model checking: A tutorial overview, in: F. C. et al., editor, Modeling and Verification of Parallel Processes, Lecture Notes in Computer Science 2067, Springer-Verlag, Berlin, 2001 pp. 3–38.
Møller, J. B., Simplifying fixpoint computations in verification of real-time systems (2002).
URL http://citeseer.ist.psu.edu/540135.html
Nr, B., M. Dickhofer and T. Wilke, The automata-theoretic method works for TCTL model checking
(1998).
URL http://citeseer.ist.psu.edu/44733.html

Offutt, A. J., Y. Xiong and S. Liu, Criteria for generating specification-based tests, in: Fifth IEEE International Conference on Engineering of Complex Computer Systems (ICECCS ’99), Las Vegas, NV, 1999, pp. 41–50.
Petrenko, A., S. Boroday and R. Groz, Confirming configurations in efsm testing, IEEE Trans. Softw. Eng. 30 (2004), pp. 29–42.
Petrenko, A. and N. Yevtushenko, Testing from partial deterministic fsm specifications, IEEE Transactions on Computers 54 (2005).
Tretmans, J., Test generation with inputs, outputs, and quiescence., in: T. Margaria and B. Steffen, editors, Tools and Algorithms for Construction and Analysis of Systems, Second International Workshop, TACAS ’96, Passau, Germany, March 27-29, 1996, Proceedings, Lecture Notes in Computer Science 1055 (1996), pp. 127–146.
Tretmans, J., Testing concurrent systems: A formal approach, in: J. Baeten and S. Mauw, editors,
CONCUR’99 – 10th Int. Conference on Concurrency Theory, Lecture Notes in Computer Science
1664 (1999), pp. 46–65.


Wang, C.-J. and M. T. Liu, Generating test cases for efsm with given fault models., in: INFOCOM, 1993, pp. 774–781.
Wang, F., Efficient verification of timed automata with bdd-like data structures., STTT 6 (2004),
pp. 77–97.
Wang, F., Formal verification of timed systems: A survey and perspective., Proceedings of the IEEE
92 (2004), pp. 1283–1307.
Wang, F., Symbolic parametric safety analysis of linear hybrid systems with bdd-like data-structures, Software Engineering, IEEE Transactions on 31 (2005), pp. 38–51.
Wang, F., Under-approximation of the Greatest Fixpoints in Real-Time System Verification, ArXiv Computer Science e-prints (2005), pp. 1060–+.
Wang, F., G.-D. Hwang and F. Yu, Tctl inevitability analysis of dense-time systems., in: CIAA, 2003,
pp. 176–187.
