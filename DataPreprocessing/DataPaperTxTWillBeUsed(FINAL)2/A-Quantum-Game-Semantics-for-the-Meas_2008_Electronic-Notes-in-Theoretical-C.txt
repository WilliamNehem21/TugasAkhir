Electronic Notes in Theoretical Computer Science 210 (2008) 33–48	
www.elsevier.com/locate/entcs

A Quantum Game Semantics for the Measurement Calculus
Yannick Delbecque1
School of Computer Science McGill University Montreal, Canada

Abstract
In this paper we present a game semantics for a quantum programming language based on a new definition of quantum strategies. The language studied is MCdata, a typed version of the measurement calculus recently introduced by Danos et. al. We give a soundness and adequacy result based on our quantum game semantics. The main contribution is not the semantics of MCdata but rather the development of ideas suitable for a game theoretic treatment of quantum computation in general.
Keywords: Quantum programming languages, game semantics, quantum games.


Introduction
The subject of quantum programming languages has emerged as a new field ly- ing at the intersection of programming languages and quantum computation. The goal is not so much the search for the right notation and semantics, but rather the search for structure in quantum computation. Thus the standard programming lan- guage ideas of compositionality and modularity emerge in new settings. Quantum computation has some radically new features: the impossibility of copying and of unrestricted discarding, entanglement and superposition and the probabilistic na- ture of measurement. These features make for entirely new challenges in the search for structure. The field of quantum programming languages is the search for this structure.
The most notable contributions are due to Selinger [14,13] and Abramsky and Coecke [1]. Dealing with higher-order programming languages in the quantum set- ting has proved to be problematic [15], though a few proposals are emerging [18,16].

1 Email: yannick.delbecque@mail.mcgill.ca

1571-0661 © 2008 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.016

Denotational semantics for the various quantum programming languages studied in recent years use the natural setup of density matrices and superoperators [14]. While these are well understood mathematically and physically, they do not provide a satisfactory treatment of higher-order quantum programming languages like those of Selinger and Valiron [16] or van Tonder [18]. The problem is that the obvious category with superoperators as morphisms is not closed: there is no object that correspond to the set of superoperators. Some approaches to find a better category where higher-order programming languages could properly be interpreted have been explored, but to this point, all have failed to produce an adequate category [15].
In this paper, we describe an approach to game semantics for quantum program- ming languages. Classical game semantics is used to construct tight denotational models of various programming languages and logics. Interest in game semantics for programming languages was sparked in the mid-90s by the introduction of two game-based fully-abstract models for PCF [2,9], after many unsuccessful attempts to construct such tights models for this language using other structures. The ap- proach has since been successfully employed to provide fully abstract models for many other languages with various features (non-determinism, probabilistic, con- currency, etc.), all these results following a similar pattern, each new feature being captured with the help of new types of strategies. This paper introduces a con- cept of quantum strategy which is conceptually close to these various classical game semantics.
We analyse in detail a game semantics for a particular language: the measure- ment calculus of Danos et al. [5] which is based on the one-way model of Raussendorf and Briegel [12]. This language is quite low level and quite specific to the one-way model. However, it is a rather novel model of quantum computation and one which has attracted interest among physicists as a basis for implementations. In particu- lar, measurements play a fundamental role, as the name would suggest, and game semantics for this model could shed light on the connection with interpretations of quantum mechanics, for example the consistent histories interpretation [7,11,6]. Our ultimate goal is the development of a higher-order quantum programming lan- guage informed by the theory of game semantics. Our work takes probabilistic game semantics, as introduced in Danos and Harmer [4], as the starting point, but defines games in terms of quantum ingredients like projective measurement operators.

Quantum strategies
The main problem in the interpretation of a quantum language using quantum games and strategies is to find an appropriate quantum version of the classical game semantics definition. The definition of quantum games given below is quite different from what one can find in the literature on quantum games, for example in [10]. In that body of papers, the aim is to generalise probabilistic von Neumann games by letting the players use quantum strategies; this usually creates new Nash equilibriums with better payoffs for the players. These quantum strategies are described as generalisations of classical probabilistic strategies. The definition of

quantum game given below is different because the basic ingredients of the game, the arena and the moves are quantum. The strategies defined below are probabilistic but the probability arises from the fact that quantum measurements are made; at no point does a strategy just pick a move according to an arbitrary probability distribution. The key point is that quantum strategies are much more restricted than general probabilistic strategies: they have to respect constraints to reflect the laws of quantum mechanics.
The basic quantum game on which all our quantum game semantics is con- structed can be understood as a special case of a general point of view on the relation between programming languages, games and physical processes, which is summarised in the following table:

Probabilistic games semantics
We need to begin by a succinct review of the basic definitions of probabilistic game semantics as introduced in [4], where the reader can find this material described in more detail.
An arena A is a triple (MA, λA, ▶A). The set MA is the set of possible moves.
The function
λA : MA → {O, P}× {I, N}
is a labelling which assigns moves to the two players, called Opponent and Player, and whether they are initial or non initial moves. We denote by λOP and λIN the
A	A
composition of λA with the projections. Finally, the enabling relation ▶A constrains
the set of moves that can be performed at a certain point in the play; it must satisfy the following conditions:
(A1) If m ▶A n, then λOP(m) /= λOP(n), λQA(m) /= λQA(n),
(A2) If λIN(n)= I, then λA(n)= (O, I),
A play in A is a sequence of moves s ∈ M ∗ . A justiﬁed play is a play where each non-initial occurrence of a move n has a pointer to a previous occurrence of move m with m ▶A n. Plays must be compatible with the enabling relation: a legal play
is a justified play where Opponent and Player alternate moves and with Opponent starting. The set of legal plays in A is denoted by LA, and the the sets of odd-length and even-length legal plays are denoted by Lodd and Leven respectively.
Given arenas A, B, the arenas product and arrow A ⊙ B and A  B of the operations are defined respectively by
MA  B = MA + MB

MA⊙B = MA + MB
OP NI

λA⊙B
= [λA, λB]
λA  B = [⟨λA , λA ⟩, λB]

m ▶
n iff m ▶  n or m ▶	n
m ▶A  B n iff m ▶A n or

A⊙B	A	B


m ▶	IN

OP	IN
where λA	inverts the role of the two players and λA make all moves of A non-
initial, + denotes disjoint union, and ⟨−, −⟩ and [−, −] are respectively denoting pairing and copairing.
Given a legal play s in an arena A, let next(s)= {b ∈ MA|sb ∈ LA}. A strategy
for Player is a function σ : Leven → [0, 1] such that
(S1) σ(ϵ)=1 
(S2) σ(s) ≥ Σb∈next(sa) σ(sab)
The set T (σ) of traces of a strategy σ in A is the set of even length legal plays that are assigned a non-zero probability by σ. A strategy σ is deterministic if σ(s)= 1 for all s ∈T (σ).
We now describe how, given two strategies σ : A  B and τ : B  C, we define the composed strategy σ; τ : A  C obtained by letting σ and τ interact on B using the fact that Player can play Opponent’s role in the B component of A  B after playing in the B component of B  C, and vice-versa. The set of interactions IA,B,C for A, B, C is
{u ∈ (MA + MB + MC) | u|AB ∈ LA  B, u|BC ∈ LB  C , u|AC ∈ LA  C},

where u|AB is the subsequence of u obtained by deleting the moves of C, and similarly for u|BC . The case of u|AC is a bit different because deleting from u the moves of B and their associated pointers might leave the moves of A or C that are justified by B-moves without justifiers. In this case, we define the justifiers of u|AC to be as follows: a move a in C justified by a move b in B will be justified by the first move of either A or C we get to by following the justification pointers from a in u.
The witnesses of s ∈ LA C in IA,B,C are the interactions u ∈ IA,B,C such that u AC = s. We denote the set of witnesses of s by wit(s). The composition of two strategies σ : A  B and τ : B  C can now be defined as follows:

[σ; τ ](s)=	Σ
u∈wit(s)
σ(u|AB)τ (u|BC )

The copy strategy idA : A  A is the identity with respect to composition; it works by simply copying the opponent’s moves made in one A component to the other A component.
Let PStrat be the category of arenas and probabilistic strategies: we take arenas as objects, and a morphism A → B is a strategy in A  B. The composition of strategies is as defined above, the identity strategy (the so-called “copycat” strategy) is the identity morphism. Composition can be shown to be associative, and it is proved in [4] that probabilistic strategies are closed under composition.
This category has a symmetric monoidal structure. The operation ⊙ is a tensor product, which acts on morphisms as follows. Given σ : A → C and τ : B → D
and s ∈ Leven	'	' , we set [σ ⊙ τ ](s) = σ(s|A  C)τ (s|C  D).  All coherence
A⊙B  A ⊙B
isomorphisms are easily defined using variants of the copycat strategy.

A thread in a play s ∈ Lodd is defined as all the moves of s for which following the justification pointers leads to the same occurrence of an initial move. A play is well-opened if it has only one initial move, and thus one thread. There is a subcategory of PStrat where the tensor is a Cartesian product. The intuitive idea is that we must restrict to strategies where Player’s answers in a given thread do not depend on what happens in other threads of the play; we call these strategies thread independent.
The diagonal strategy ΔA : A → A ⊙ A is defined as the deterministic strategy with the following trace set:
even	'	even	'	'
{s ∈ LA  Al⊙Ar | ∀s ±	s.s |Al ∈ idAl ∧s |Ar ∈ idAr }.
This strategy basically instructs Player to use copycat strategies between A and both Al and Ar. Any possible conflict in A is resolved by separating into different threads the moves made in the left and the right copying plays. The diagonal strategy plays an important role in the process of defining a Cartesian closed category of arenas and strategies from the category we described here; details are given in [8]. We define the pairing ⟨σ, τ ⟩: A → B1 ⊗ B2 of two strategies σ : A → B1 and τ : A → B2 to be the composition (σ ⊙ τ ) ◦ δA.
Games representing qbits
We now turn to the problem of representing quantum data as strategies in an appropriate arena. Recall that a projective measurement is a finite set of Hermitian operators Pa on a Hilbert space, one for each possible outcome a, such that PaPa' = δaa' Pa and  a Pa = I. From now on we will just call these measurements.
The arena qbit is defined as follows: Opponent’s possible initial moves are of
the form P?, where P = {Pa} is a measurement on the Hilbert space H = C2, and Player’s possible answers to P? are the indices a.
Any mixed state ρ can be described a strategy in qbit. When using the strategy
ρ on well-opened plays, Player answers a to P with probability
[ρ](P?a)= Tr(Paρ)
Example 2.1 Let us work in H = C2 using the computational basis |0⟩ and |1⟩. The strategy representing the state |φ⟩ = α|0⟩ + β|1⟩ is described as follows. If Opponent’s first move is the measurement P, Player responds with i with probability Tr(Pa|φ⟩⟨φ|). For instance, if the initial question is {P0 = |0⟩⟨0|, P1 = |1⟩⟨1|}, Player answers 0 or 1 with respective probability |α|2 or |β|2.
Note that Opponent is allowed to begin with the question {P0 = I}?, for which 0 is the only one possible answer. Opponent learns nothing about the state described by Player’s strategy in this play.
There are probabilistic strategies for Player in the arena qbit which do not de- scribe quantum states. For example, consider any deterministic strategies, or strate- gies that answer with the uniform probability distribution regardless of Opponent’s initial move.

Tensor of Quantum Games
Consider now the case of a system of two qbits, respectively described by arenas qbit1 and qbit2. We define a new arena qbit12, where in the typical play, Opponent will ask for the result of a measurement P on the tensor product of the Hilbert spaces for the two qbits, and Player can answer with one of the indices a. A quantum state ρ in the tensor product space will be described by a strategy similar to the one qbit case: Player answers a to ? with probability Tr(Paρ). In general, we will denote by qbitI the arena defined as above but for qbits labeled by elements of a finite set I.
This arena is different from qbit1 ⊙ qbit2, where Opponent can only ask for the result of a measurement for the first or second component at one time. Opponent cannot ask all possible projective measurements on the joint space, but only those of the form {Pa ⊗ I} or {I ⊗ Qb}. The difference between the classical game tensor and the quantum game tensor introduced above is related to the phenomenon of quantum nonlocality without entanglement [3].

Threading
We have so far avoiding the problem of threading by giving our definitions only for well-opened plays. We show below that there are two valid ways of relating multiple runs of the qbit game, with two different physical interpretations.
For the first one, the quantum strategy ρ : qbit defined above on well-opened plays induce a thread-independent strategy ρ in qbit, where Player will play in each thread with the strategy ρ. In this case, Player answers successive questions P ,... , P  behaving in each thread as in the well-opened ρ, and thus:
[ρ^](P1?a1 ··· Pn?an)= Tr(P 1 ρ) ··· Tr(P n ρ).
This is the probability of observing a1,... an when qbits prepared in the same state
ρ are independently measured with the above projective measurements.
There is a second natural strategy induced by ρ, which we denote by ρ. This time, we set


[ρ](P1?a1 ... Pn?an)= Tr(Pn
... P 1 ρP 1
... Pn ),

which makes Player answer as if the successive measurements are made on the same qbit, each measurement affecting the state used to compute the probabilities in the subsequent threads. For the remaining of this paper, we adopt the second point of view, and use simply ρ to denote the thread dependent strategies describing quantum states.

Decoherent histories
The strategies ρ are closely related to the theory of quantum decoherent histories or quantum consistent histories, as presented in [7,11,6]. In this theory, we asso- ciate to each state ρ a function called the decoherence functional which takes two


 
sequences of projectors (called quantum histories) P, Q of equal length and returns a complex number defined by



 
Dρ(P, Q)= tr(P n
··· P  ρQ
··· Q  ).



Given such a function, we can assign a probability p(P ) to each quantum history by setting p(P ) = Dρ(P, P ). This will work provided that Dρ is limited to a set of quantum histories satisfying a condition know as decoherence or consistency: Dρ(P, Q)=0 if P /= Q.
The thread-dependent quantum strategies ρ is related to the decoherence func- tional Dρ as follows:
[ρ](P1?a1 ... Pn?an)= p(P 1 , ··· ,Pn )

It is pointed out in [4] that a total probabilistic strategy in the game bool induces a probability distribution on the set B = {0, 1}∗ of binary sequences equipped with the Borel σ-algebra generated by the Cantor topology. The above correspondence may play an important role in understanding the structure of quantum strategies because decoherence functionals can be defined abstractly on orthoalgebras, struc- tures abstracting the properties of the set of projective operators on an Hilbert space equipped with the partially defined direct sum.

Strategies modelling quantum operations
We now define strategies which represent various basic quantum operations. These will be used below in the construction of a game semantics for a typed version of the measurement calculus.

Unitary operations
Given a measurement P = {Pa} and a unitary operation U , we define U †PU to be {U PaU }. It is easy to verify that this defines a new projective measurement. A unitary operation U : HI → HI , where HI = ⊗i∈IHi, can be represented as a deterministic strategy U : qbitI → qbitI with the following typical play:

qbitI  U  qb itI
P?
(U †PU )?
a
a

Given any quantum strategy ρ in qbitI , the composed strategy U ; ρ behaves as the strategy for the state UρU †:

[U ; ρ](P?a)= Σ[U ](P?U †PU ?ba)[ρ](U †PU ?b)
j
= Σ δba Tr((U †PbU )ρ(U †PbU ))
b
= Tr(Pa(UρU †)Pa)
= [U ρU †](P?a)
Note that using qbit1 ⊙ qbit2 instead of qbit12 as a product of qbit games would not allow one to define the unitary strategy as we do above. Indeed, in the game qbit1 ⊙ qbit2, Opponent can begin by asking P in the first or second component, so Player must asks to Opponent a question of the form U (P ⊗ I)U †
in the input component. The problem is that in general this does not correspond
to an allowed question in qbit1 ⊙ qbit2, since U †(P ⊗ I)U is not necessarily of the form Q⊗ I or I ⊗ Q.

Partial traces
The operation of discarding part of a quantum state by taking the partial trace can be represented by the deterministic strategy, with the following typical play:
qbit12 tr2  qb it1
P?
P ⊗ I?
a
a
Composing with a strategy ρ, we obtain
[tr2; ρ](P?P ⊗ I?ba)= Σ Tr(Pb ⊗ Iρ)δab = Tr(Pa ⊗ Iρ)
b
= Tr(Pa Tr2(ρ)) = [Tr2(ρ)](P?a)

Projective Measurements
There is a deterministic strategy representing the application to a state ρ of a projective measurement given by a family of projectors Q = {Qb}. A typical play for the projective measurement strategy is as follows:
qbit  Q  qb it
P?
Q?
b
P?
a
a

Composing with a strategy ρ, we get
[Q; ρ](P?Q?bP?aa)= Σ Tr(PaQbρQbPa)
b
= Tr(Pa(Σ QbρQb)Pa)
b
= [Q(ρ)](P?a),
and thus the strategy Q faithfully represent the action of making projective mea- surements. Note that while P itself is thread independent, the definition of this strategy assumes that the strategies representing quantum states are thread depen- dent.

MCdata
We now use the above quantum strategies to construct an interpretation for MC- data, a formalisation of the measurement calculus. We begin by giving a short review of this language as described in the original paper [5].
We denote the density matrix associated to |φ⟩ by [φ]. For any α ∈ [0, 2π], we put
 1 	iα	 1 	iα

|+α⟩ = √2 |0⟩ + e  |1⟩ , |−α⟩ = √2 |0⟩− e
|1⟩ .

We denote |+0⟩ and |−0⟩ respectively by |+⟩ and |−⟩.
A pattern type is a finite set of qbits {Hi,i ∈ I} with two subsets In, Out of I. Let Xi, Yi, Zi be the usual Pauli operators on qbit i, and M	be the projector [+α]
on qbit i.
The operations on the qbits of a pattern type are called commands. They are of three kinds:
Measurement The measurement commands allow to measure a qbit with the projectors Mα, I − Mα. All measurements are considered to be destructive. The information obtained by measurement of a qbit with the two projectors is called a signal. The signal associated to the two projectors are represented respectively as 1 if the first projector is applied, and 0 if it is the second projector that gets applied. Two signals s, t can be combined using addition modulo 2 to get a new signal s ⊕ t (sum modulo 2).
Correction One can change the state of an output qbit by applying the Pauli operators X or Z to it.
Entanglement The entanglement command Eij entangle the qbits i, j of the pat- tern type by applying to them the controlled-Z operator (denoted ∧Z).
Signals are used to modify commands as follows:
[X ]s = ,⎨ X if s =1 [Z]s is defined similarly.
, I if s =0 
[Mα]s,t = M (−1)sα+tπ

A pattern consists of a pattern type (I, In, Out) with a finite command sequence
E1,... , En on it that satisfy the following three conditions:
no command depends on signals from qbits not yet measured,
no command is applied to a qbit after it has been measured,
no qbits in Out are measured, all other qbits are measured.
It is also assumed that all non-input qbits are initially in the |+⟩ state.

Syntax of MCdata
The measurement calculus as given [5] lacks a precise type system but we need it for our purposes. We give here a new formalisation of the measurement calcu- lus where commands are typed in such a way that the type system automatically enforces certain conditions on programs or “patterns” as they are called in MC.
Quantum states are constant terms just as Boolean and angle values. The measurement calculus commands are operations taking qbits and other parameters as input and returning qbits. We name the formalised language MCdata.
The terms of the language MCdata are constructed as follows: Booleans B, B1, B2 ::= true | false |!s | B1 ⊕ B2
Angles	W, W1, W2 ::= α | W1 + W2 | rot WB1B2
qbits	Q ::= x | |φ⟩I | measi sWQ | Eij | Xi BQ | Zi BQ
where s, x ∈ Vars, is an infinite set of variables, α ∈ [0, 2π), i, j are labels, I is a finite set of labels and |φ⟩I is a quantum state on HI. We assume there is an infinite number of different labels.
The type system uses four base types
T :: = angle | bool | qbitI | signali
The types angle and bool are the types of angles and Boolean values. Signals are

containers for Boolean values. The label associated to the type signali
is the label

of the qbit that can be measured to change the value of the signal. The Boolean value stored in a signal is accessed by the dereferencing operation !.
A context Γ is a partial function assigning types to variables: a context is denoted x1 : T1,... , xn : Tn. A typing judgement is a triple Γ ▶ M : T with a context Γ, a term M and a type T .
In the MC measurements are destructive and the label of a destroyed qbit cannot be reused. We enforce this formally by using the unused labels of a term M . The set labels unused in M is denoted UL(M ). We can now give the typing rules of MCdata; they are described in table 1.
An MCdata pattern is an MCdata term M for which we can derive a typing judgement of the form


x : qbitIn, {si : signali
}i∈I ▶ M : qbit

Table 1 MCdata typing rules
Constants
Γ,x : T ▶ x : T	x ∈ Vars	Γ ▶ α : angle	α ∈ [0, 2π)


Γ ▶ b : bool	b ∈ {0, 1}	Γ ▶ |φ⟩I : qbitI	|φ⟩ is a state on |I| qbits
Classical operations
Γ ▶ S : signali	Γ ▶ W : angle	Γ ▶ B1 : bool	Γ ▶ B2 : bool

Γ ▶!S : bool
 Γ ▶ B1 : bool	Γ ▶ B2 : bool  Γ ▶ B1 ⊕ B2 : bool
Γ ▶ rot WB1B2 : angle
 Γ ▶ W1 : angle	Γ ▶ W2 : angle  Γ ▶ W1 + W2 : angle

Quantum operations

Γ ▶ B : bool	Γ ▶ Q : qbitI∪{i}
Γ ▶ XiBQ : qbitI
Γ ▶ B : bool	Γ ▶ Q : qbitI∪{i}
Γ ▶ ZiBQ : qbitI

Γ ▶ S : signali	Γ ▶ W : angle	Γ ▶ Q : qbitI∪{i}
	I	
Γ ▶ measi SWQ : qbitI
Γ ▶ Q : qbitI∪{i,j}	Γ ▶ Q : qbitI

Γ ▶ Eij
Q : qbitI∪{i,j}
Γ ▶ prep Q : qbitI∪{i}	i ∈ UL(Q)

where In, Out, Jj ⊆ I.
Example 3.1 Consider the following teleportation pattern:

teleportik = Xk !sj Zk !si measj
sj 0 measi
si 0 Ejk Eij prepk prepj x

We can derive the following typing judgement using the above rules:

x : qbiti, si : signali
, sj : signalj ▶ teleportik : qbitk


Operational semantics of MCdata
The operational semantics we give in this section is a direct adaptation of the semantics given in [5]. We begin by the semantics for MCdata.
A store is a partial function Σ : Vars → {true, false} taking variables to truth values. We put
Σ[s '→ b](t)= ,⎨ b if t = s
, Σ(t) otherwise.
A canonical form Σ,V is a pair with a store Σ and a constant term V . The operational semantics is given by a probabilistic reduction relation Σ,M ⇓p Σ',V , where V is a canonical form and p ∈ [0, 1] is the probability of the reduction
occurrence. The parameter is omitted when it is 1. The reduction rules are described in table 2.

Table 2 MCdata reduction rules
Constants

Σ,α ⇓ Σ,α		Σ, true ⇓ Σ, true	Σ, false ⇓ Σ, false Σ,x ⇓ Σ,x	Σ, |φ⟩I ⇓ Σ, |φ⟩I
Classical operations
Σ,S ⇓p Σ',s 
Σ, !S ⇓p Σ', Σ(s)
Σ,W ⇓p Σ',α	Σ', B1 ⇓q1 Σ'', b1	Σ'', q'', B2 ⇓q2 Σ''', b2

Σ, q, rot WB1B2 ⇓pq1q2 Σ''',β 
α ∈ [0, 2π), b1, b2 ∈ {true, false}, and, setting true = 1, false = 0, with β = αs + tπ
Σ, B1 ⇓p Σ', b1	Σ', B2 ⇓q Σ'', b2

Σ, B1
⊕ B2
pq	''	b1, b2 Boolean values, b = b1 xor b2
⇓	Σ ,b 

Σ, W1 ⇓p Σ', α1	Σ', W2 ⇓q Σ'', α2
Σ, W1 + W2 ⇓pq Σ'',β 
α1, α2 ∈ [0, 2π)
β = α1 + α2 mod 2π

Quantum operations

Σ,B ⇓p Σ',t	Σ',Q ⇓q Σ'', |φ⟩I
Σ, XiBQ ⇓pq Σ'', ([Xa]t|φ⟩)I
Σ,B ⇓p Σ',t	Σ',Q ⇓q Σ'', |φ⟩I
Σ, ZiBQ ⇓pq Σ'', ([Za]t|φ⟩I )I

Σ,W ⇓p Σ',α	Σ',Q ⇓q Σ'', |φ⟩I∪{i}
Σ, measi sWQ ⇓pqr Σ[s '→ 1], (⟨+α|φ⟩/|⟨+α|φ⟩|2)I
Σ,W ⇓p Σ',α	Σ',Q ⇓q Σ'', |φ⟩I∪{i}

Σ, measi sWQ ⇓1−pqr Σ[s '→ 0], (⟨−α|φ⟩/|⟨−α|φ⟩|2)I

Σ,Q ⇓p Σ', |φ⟩I
Σ, EijQ ⇓p Σ', (∧Zij|φ⟩)I
Σ,Q ⇓p Σ', |φ⟩I

Σ, prepiQ ⇓p Σ', (|+⟩i ⊗ |φ⟩)I∪{i}

Denotational semantics of MCdata
Each type of MCdata is interpreted as an arena as follows:

 angle) = angle	 bool) = bool	 qbitI ) = qbitI
 signali ) = signali = (angle ⊙ qbitI∪{i}   qbitI ) ⊙ bool

While the first three definitions are natural, the last one needs to be explained.
There are two operations associated to signals: one to store the result of the mea- surement of a qbit, a strategy

measi : signali → angle ⊙ qbitI∪{i}  qbitI,

and a second one to read a stored Boolean value, deref : signali → bool. We thus take the arena angle ⊙ qbitI∪{i}  qbitI ⊙ bool as the interpretation of the type signal . Both read and write strategies are taken to be the appropriate projection strategies on the components of signali .
A term M is said to be semi-closed if Γ ▶ M : T with Γ containing only signal variables. The interpretation of a semi-closed term in context Γ ▶ M : T is a strategy M ) : Γ) → T ) which is defined by induction on the derivation of typing judgement.
All constants are interpreted as their corresponding strategies described above. The dereferencing operation is interpreted with the strategy deref defined above:
 Γ ▶!S : bool) = S); deref. Other classical operations are interpreted using the obvious deterministic strategies rot, xor and addAngle which make Player query Opponent about each required input data and produce a final answer in the output component:
 Γ ▶ rot WB1B2 : angle) = ⟨ W ),  B1), B2)⟩; rot
 Γ ▶ B1 ⊕ B2 : bool) = ⟨ B1), B2)⟩; xor
 Γ ▶ W1 + W2 : angle) = ⟨ W1), W2)⟩; addAngle Conditional corrections are interpreted as follows:
 Γ ▶ XaBQ : qbitI ) = ⟨ B), Q)⟩; condXi
 Γ ▶ ZaBQ : qbitI ) = ⟨ B), Q)⟩; condZi
The two strategies condXi, condZi : bool ⊙ qbitI → qbitI are defined similarly: if opponent begins with P? in the output component, Player†asks Opponent for a
Boolean in the bool component, and then asks either XiPXi ? or P? when he his
answered true or false respectively. He finally copies the final Opponent’s answer to the output component.
The measurement commands are interpreted using the adjunction Λ bijection between strategies in A ⊙ B → C and those in A → B  C. The projection measi have the adjoint Λ−1(measi ): signali ⊙angle⊙qbitI∪{i} → qbitI . The denotation
of the measurements commands is defined as follows:

 Γ ▶ measi SWQ : qbitI\{i}) = ⟨ S), W ), Q)⟩; Λ−1(measi ).

Entanglement operations are interpreted using the unitary operation strategies given in section 2.3:
 Γ ▶ EijQ : qbitI ) = Q); ∧Zij

Finally, given an interpretation  Γ ▶ Q : qbitI ), prepiQ is interpreted as the strategy
 Γ ▶ prepiQ : qbitI∪{i}) :  Γ) → qbit

which is defined as follows. A typical play in  Q) looks like
 Γ)   Q)  qb itI
P?
b1
.
bn
a
where Player answer a with probability Tr(Paρ) for some state ρ that depends on his interaction with Opponent in the Γ) component, but not on P. Using the strategy
 prepiQ), Player plays as in Q), but will give a final i answer with probability Tr(Paρ ⊗ |+⟩⟨+|). The state ρ ⊗ |+⟩⟨+| does depends on the interaction in the signal component, but not on P.

Consistency and adequacy
To be able to show that the denotational semantics matches the operational semantics of MCdata, we need to take stores into account. For this, we need a
strategy sig : I → signali that behaves appropriately to represent the behaviour of
a signal. Assuming the signal is initially b1 ∈ {true, false}, a typical play using the deterministic strategy sigb1 is:
(angle	⊙	qbitI∪{i} 	 qb itI ) ⊙ bool
?
b1
?	P
α
I ⊗ {|+α⟩⟨+α|i, |−α⟩⟨−α|i}?
b2
P ⊗a I?
a
?
b2
Let Γ: s1 : signal1 ,... , sn : signaln . A Γ-store is a store Σ defined exactly for
I1	In
the variables s1,... , sn. If Σ is a Γ-store,  Σ) is the product strategy
⟨sigΣ(s1 ),... , sigΣ(sn)⟩ : I →  Γ).
We can now define the interpretation of a pair Σ,M , with Γ ▶ M : T semi-closed and Σ a Γ-store, as Σ,M ) = Σ); M ).
Proposition 4.1 If Σ,M ⇓p Σ',V , then for all well-opened s ∈T ( Σ',V )) we have that Σ,M )(s)= p Σ ,V )(s)

The proof of this proposition follows a standard argument: it is shown by prov- ing a stronger proposition by induction on the derivation of Σ,M ⇓p Σ',V , using
 Σ,M )' = Σ); Δ; ( M ) ⊙ id Γ)) instead of Σ,M ). This stronger proposition is that given Σ,M ⇓p Σ',V , we have Σ,M )'(s)= p Σ',V )'(s) for any well-opened play in
'	'
T ( Σ ,V ) ) starting in  T ). Since these plays are the same as those of  Σ,M ), the
proposition follow directly.
The next important result about the relation between the operational and de- notational semantics of MCdata is Adequacy.
Proposition 4.2 (Adequacy) If for all well-opened s ∈ T ( Σ' )) we have that
 Σ,M )(s)= p Σ',V )(s), then Σ,M ⇓p Σ',V .
To prove adequacy, we rely on the standard technique of using a computability predicate, defined as follows:
Definition 4.3 (Computability for MCdata) Suppose Γ contains only variables of type signal.
Γ ▶ M : A, where A = qbitI , angle or bool, is computable if when  Σ,M )(s)= 
p Σ',V )(s) hold for all well-opened s ∈T ( Σ',V )), then Σ,M ⇓p Σ',V .
Γ, x1 : A1,... , xn : An ▶ M : A is computable if for all computable Γ ▶ Ni : Ai
the term


is computable.
Γ ▶ M [N1/x1,... , Nn/xn]: A

Γ ▶ S : signali is computable if both Γ ▶ !S : bool and Γ | x : angle,y : qbitI∪{i} ▶
meas Sxy : qbit are computable.
Proposition 4.2 is a direct consequence of the fact that we can prove by induction that all terms are computable.

Conclusions
We have given a game semantics for a low-level language for describing measurement- based computation. Semantics for this, and other similar languages, can be given more easily without using games. What we hope is that the game semantics frame- work will ultimately be useful for interpreting higher-order quantum computation. Preliminary work toward the construction of a quantum game semantics for Val- iron’s quantum lambda calculus [17,16] based on ideas presented in this paper seems promising. We believe that the two ways that quantum state strategies in qbit games can be threaded may account for the differences between various higher-order quan- tum languages.
Quantum strategies also pose many interesting questions. For example, it is an open problem to characterise using game semantics concepts the strategies that correspond to physical quantum strategies – those transforming by composition quantum state strategies in other quantum state strategies. These physical strate- gies are closed under composition, so quantum games and quantum strategies form

a category. It is necessary to understand its structure and its relation to the cate- gory of probabilistic strategies to be able to use quantum strategies to model more complex quantum languages.
We pointed out the connection between plays in a game and consistent histo- ries. It would be interesting to understand the connections between game theoretic restrictions (analogous to innocence and history-freedom) on strategies and consis- tency conditions on families of histories. It may be the key to understanding which strategies are physically realisable.

References
S. Abramsky and B. Coecke. A categorical semantics of quantum protocols. In Proceedings of the 19th Annual IEEE Symposium on Logic in Computer Science: LICS 2004, pages 415–425. IEEE Computer Society, 2004.
S. Abramsky, R. Jagadeesan, and P. Malacaria. Full abstraction for PCF. Information and Computation, 163:409–470, 2000.
C. H. Bennett, D. P. DiVincenzo, C. A. Fuchs, T. Mor, E. Rains, P. W. Shor, J. A. Smolin, and W. K. Wootters. Quantum nonlocality without entanglement. Physical Review A, 59(2):1070–1091, February 1999.
V. Danos and R. Harmer. Probabilistic games semantics. In Proceedings of the Fifteenth IEEE Symposium On Logic In Computer Science, pages 204–213. IEEE Press, 2000.
V. Danos, E. Kashefi, and P. Panangaden. The measurement calculus. arXiv:quant-ph/0412135, 2004.
M. Gell-Mann and J.B. Hartle. Classical equations for quantum systems. Physical Review D, 47:3345– 3382, 1993.
R.B. Griffiths. Consistent histories and quantum reasoning. Physical Review A, 54:2759–2774, 1996.
R. Harmer. Games and Full Abstraction for Nondeterministic Languages. Ph.D. thesis, Imperial College, 1999.
J. M. E. Hyland and C.-H. L. Ong. On full abstraction for PCF: I. models, observables and the full abstraction problem, II. dialogue games and innocent strategies, III. a fully abstract and universal game model. Information and Computation, 163:285–408, 2000.
D. Meyer. Quantum strategies. Phys. Rev. Lett. 82, 1999.
R. Omn`es. The Interpretation of Quantum Mechanics. Princeton Univ. Press, 1994.
R. Raussendorf and H. J. Briegel. A one-way quantum computer. Phys. Rev. Lett., 86:5188–5191, May 2001.
P. Selinger. A brief survey of quantum programming languages. In Proceedings of the 7th International Symposium on Functional and Logic Programming, Springer LNCS 2998, pp. 1–6, 2004.
P. Selinger. Towards a quantum programming language. Mathematical Structures in Computer Science, 14(4):527–586, 2004.
P. Selinger. Towards a semantics for higher-order quantum computation. In Proceedings of the 2nd International Workshop on Quantum Programming Languages, Turku, Finland, pages 127–143, June 2004.
P. Selinger and B. Valiron. A lambda calculus for quantum computation with classical control. In Proceedings of the Seventh International Conference on Typed Lambda Calculi and Applications (TLCA 2005), Nara, Japan. Springer LNCS 3461, pp. 354–368, 2005.
B. Valiron. A functional programming language for quantum computation with classical control. Master’s thesis, Department of Mathematics, University of Ottawa, 2004.
A. van Tonder. A lambda calculus for quantum computation. Siam Journal on Computing, 33(5):1109– 1135, 2004.
