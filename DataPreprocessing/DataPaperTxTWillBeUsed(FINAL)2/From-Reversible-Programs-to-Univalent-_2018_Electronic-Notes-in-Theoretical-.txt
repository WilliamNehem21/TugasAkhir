Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 336 (2018) 5–25
www.elsevier.com/locate/entcs


From Reversible Programs to Univalent Universes and Back
Jacques Carette
McMaster University

Chao-Hong Chen  Vikraman Choudhury  Amr Sabry
Indiana University

Abstract
We establish a close connection between a reversible programming language based on type isomorphisms and a formally presented univalent universe. The correspondence relates combinators witnessing type isomorphisms in the programming language to paths in the univalent universe; and combinator optimizations in the programming language to 2-paths in the univalent universe. The result suggests a simple computational interpretation of paths and of univalence in terms of familiar programming constructs whenever the universe in question is computable.
Keywords: Reversible programming, unilance, Agda

Introduction
The proceedings of the 2012 Symposium on Principles of Programming Languages [1] included two apparently unrelated papers: Information Eﬀects by James and Sabry and Canonicity for 2-dimensional type theory by Licata and Harper. The first paper, motivated by the physical nature of computation [23,26,29,5,13], proposed, among other results, a reversible language Π in which every program is a type isomorphism. The second paper, motivated by the connections between homotopy theory and type theory [31,28], proposed a judgmental formulation of intensional dependent type theory with a twice-iterated identity type. During the presentations and ensuing discussions at the conference, it became apparent, at an intuitive and informal level, that the two papers had strong similarities. Formalizing the precise connection was far from obvious, however.
Here we report on a formal connection between appropriately formulated reversible languages on one hand and univalent universes on the other. In the next section, we give a rational reconstruction of the reversible programming language Π, focusing

https://doi.org/10.1016/j.entcs.2018.03.013
1571-0661/© 2018 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

on a small “featherweight” fragment Π2. In Sec. 3, we review basic homotopy type theory (HoTT) background leading to univalent fibrations which allow us to give formal presentations of “small” univalent universes. In Sec. 4 we define and establish the basic properties of such a univalent subuniverse U˜[2] which we prove in Sec. 5 as sound and complete with respect to the reversible language Π2. Sec. 6 discusses the implications of our work and situates it into the broader context of the existing literature.

Reversible Programming Languages
Starting from the physical principle of “conservation of information” [16,14], James and Sabry [18] proposed a family of programming languages Π in which computation preserves information. Technically, computations are type isomorphisms which, at least in the case of finite types, clearly preserve entropy in the information-theoretic sense [18]. We illustrate the general flavor of the family of languages with some examples and then identify a “featherweight” version of Π, called Π2, to use in our formal development.

Examples
The examples below assume a representation of the type of booleans 2 as the disjoint union 1 ‘ 1 with the left injection representing false and the right injection representing true. Given an arbitrary reversible function f of type a Ø1 a, we can build the reversible function controlled f that takes a pair of type 2 b a and checks the incoming boolean; if it is false (i.e., we are in the left injection), the function behaves like the identity; otherwise the function applies f to the second argument. The incoming boolean is then reconstituted to maintain reversibility:
controlled : @a. pa Ø1 aq	Ñ p2 b a Ø1 2 b aq
controlled f “ 2 b a	Ø1x unfoldBool b id y p1 ‘ 1qb a	Ø1x distribute  y p1 b aq‘ p1 b aq Ø1x id ‘ pid b fq y p1 b aq‘ p1 b aq Ø1x factor y
p1 ‘ 1qb a	Ø1x foldBool b id y
2 b a
The left column shows the sequence of types that are visited during the computation; the right column shows the names of the combinators 1 that witness the corresponding type isomorphism. The code for controlled f provides constructive evidence (i.e., a program, a logic gate, or a hardware circuit) for an automorphism on 2 b a: it can be read top-down or bottom-up to go back and forth.
The not function below is a simple lifting of swap` which swaps the left and right injections of a sum type. Using the controlled building block, we can build a controlled- not (cnot) gate and a controlled-controlled-not gate, also known as the toffoli gate. The latter gate is a universal function for combinational boolean circuits thus showing

1 We use names that are hopefully quite mnemonic; for the precise definitions of the combinators see the
Π-papers [18,6,19,20,8] or the accompanying code at https://git.io/v7wtW.



Fig. 1. Graphical representation of not3





the expressiveness of the language:

not : 2 Ø1 2
not “ unfoldBool 1 swap` 1 foldBool

cnot : 2 b 2 Ø1 2 b 2
cnot “ controlled not

toffoli : 2 b p2 b 2q Ø1 2 b p2 b 2q
toffoli “ controlled cnot

While we wrote controlled in equational-reasoning style, not is written in the point- free combinator style. These are equivalent as Ø1x ´ y is defined in terms of the sequential composition combinator 1.
As is customary in any semantic perspective on programming languages, we are interested in the question of when two programs are “equivalent.” Consider the following six programs of type 2 Ø1 2:
id1 id2 id3 not1 not2 not3  : 2 Ø1 2
id1 “ id  1 id
id2 “ not  1 id 1 not
id3 “ uniti‹ 1 swap‹ 1 pid b idq 1 swap‹ 1 unite‹ not1 “ id 1 not
not2 “ not  1 not 1 not
not3 “ uniti‹ 1 swap‹ 1 pnot b idq 1 swap‹ 1 unite‹

The programs are all of the same type but this is clearly not a sufficient condition for “equivalence.” Thinking extensionally, i.e., by looking at all possible input-output pairs, it is easy to verify that the six programs split into two classes: one consisting of the first three programs which are all equivalent to the identity function and the other consisting of the remaining three programs which all equivalent to boolean negation. In the context of Π, we can provide evidence (i.e., a reversible program of type Ø2 that manipulates lower level reversible programs of type Ø1 ) that can constructively identify programs in each equivalence class. We show such a level-2 program proving that not3 is equivalent to not. For illustration, the program for not3 is depicted in Fig. 1. We encourage the reader to map the steps below to manipulations

on the diagram that would incrementally simplify it:
notOpt : not3 Ø2 not
notOpt “ uniti‹  1 pswap‹  1 ppnot b idq  1 pswap‹  1 unite‹qqq	Ø2x id d assocLeft y
uniti‹ 1 pswap‹ 1 pnot b idqq 1 pswap‹ 1 unite‹q	Ø2x id d pswapLeft d idq y uniti‹ 1 ppid b notq 1 swap‹q 1 pswap‹ 1 unite‹q	Ø2x id d assocRight y uniti‹ 1 ppid b notq 1 pswap‹ 1 pswap‹ 1 unite‹qqq	Ø2x id d pid d assocLeftq y 
uniti‹ 1 ppid b notq 1 ppswap‹ 1 swap‹q 1 unite‹qq	Ø2x id d pid d pleftInv d idqq y
uniti‹ 1 ppid b notq 1 pid 1 unite‹qq	Ø2x id d pid d idLeftq y 
uniti‹ 1 ppid b notq 1 unite‹q	Ø2x assocLeft y
puniti‹ 1 pid b notqq 1 unite‹	Ø2x unitiLeft d id y
pnot 1 uniti‹q 1 unite‹	Ø2x assocRight y
not  1 puniti‹  1 unite‹q	Ø2x id d leftInv y
not  1 id	Ø2x idRight y
not
It is worthwhile mentioning that the above derivation could also be drawn as one (large!) commutative diagram in an appropriate category, with each Ø2x ´ y as a 2-arrow (and representing a natural isomorphism). See Shulman’s draft book [27] for that interpretation.

A Small Reversible Language of Booleans: Π2
Having illustrated the general flavor of the Π family of languages, we present in full detail an Agda-based formalization of a small Π-based language which we will use to establish the connection to an explicit univalent universe. The language is the restriction of Π to the case of just one type 2:
data 2 : U where 02 12 : 2
The syntax of Π2 is given by the following four Agda definitions. The first definition Π2 introduces the set of types of the language: this set contains just ‘2 which is a name for the type of booleans 2. The next three definitions introduce the programs (combinators) in the language stratified by levels. The level-1 programs of type Ø1 map between types; the level-2 programs of type Ø2 map between level-1 programs; and the level-3 programs of type Ø3 map between level-2 programs:
data Π2 : U where ‘2 : Π2
–––––––-
data _ÐÑ1_ : (AB : Π2) Ñ U where
‘id	: @ {A} Ñ A ÐÑ1 A
‘not	: ‘2 ÐÑ1 ‘2
!1_	: @ {A B} Ñ (A ÐÑ1 B) Ñ (B ÐÑ1 A)
_1_ : @ {AB C} Ñ (A ÐÑ1 B) Ñ (B ÐÑ1 C) Ñ (A ÐÑ1 C)

–––––––-

data _ÐÑ2_ : @ {A B} (pq : A ÐÑ1 B) Ñ U where ‘id2	: @ {A B} {p : A ÐÑ1 B} Ñ p ÐÑ2 p
!2_	: @ {A B} {pq : A ÐÑ1 B} Ñ (p ÐÑ2 q) Ñ (q ÐÑ2 p)
_2_ : @ {A B} {pqr : A ÐÑ1 B} Ñ (p ÐÑ2 q) Ñ (q ÐÑ2 r) Ñ (p ÐÑ2 r)
‘idl	: @ {A B} (p : A ÐÑ1 B) Ñ ‘id 1 p ÐÑ2 p
‘idr	: @ {A B} (p : A ÐÑ1 B) Ñ p 1 ‘id ÐÑ2 p
‘assoc : @ {ABC D} (p : A ÐÑ1 B) (q : B ÐÑ1 C) (r : C ÐÑ1 D)
Ñ (p 1 q) 1 r ÐÑ2 p 1 (q 1 r)
_l2_ : @ {AB C} {pq : A ÐÑ1 B} {rs : B ÐÑ1 C}
Ñ (p ÐÑ2 q) Ñ (r ÐÑ2 s) Ñ (p 1 r) ÐÑ2 (q 1 s)
‘!	: @ {A B} {pq : A ÐÑ1 B} Ñ (p ÐÑ2 q) Ñ (!1 p ÐÑ2 !1 q)
‘!l	: @ {A B} (p : A ÐÑ1 B) Ñ (p 1 !1 p ÐÑ2 ‘id)
‘!r	: @ {A B} (p : B ÐÑ1 A) Ñ (!1 p 1 p ÐÑ2 ‘id)
‘!id	: @ {A} Ñ !1 ‘id {A} ÐÑ2 ‘id {A}
‘!not	: !1 ‘not ÐÑ2 ‘not
‘!‚	: @ {AB C} {p : A ÐÑ1 B} {q : B ÐÑ1 C}
Ñ !1 (p 1 q) ÐÑ2 (!1 q) 1 (!1 p)
‘!!	: @ {A B} {p : A ÐÑ1 B} Ñ !1 (!1 p) ÐÑ2 p
–––––––-
data _ÐÑ3_ {A B} {pq : A ÐÑ1 B} (uv : p ÐÑ2 q) : U where ‘trunc : u ÐÑ3 v
In the previous presentations of Π [6,18,8], the level-3 programs, consisting of just one trivial program ‘trunc, were not made explicit. The much larger level-1 and level-2 programs of the full Π language [8] have been specialized to our small lan- guage. For the level-1 constructors, denoting reversible programs, type isomorphisms, permutations between finite sets, or equivalences depending on one’s favorite inter- pretation, we have two canonical programs ‘id and ‘not closed under inverses !1 and sequential composition 1. For level-2 constructors, denoting reversible program transformations, coherence conditions on type isomorphisms, equivalences between permutations, or program optimizations depending on one’s favorite interpretation, we have the following groups: (i) the first group contains the identity, inverses, and sequential composition; (ii) the second group establishes the coherence laws for level-1 sequential composition (e.g, it is associative); and (iii) finally the third group includes general rules for inversions of level-1 constructors.
Each of the level-2 combinators of type p Ø2 q is easily seen to establish an equivalence between level-1 programs p and q (as shown in previous work [8] and in Sec. 5). For example, composition of negation is equivalent to the identity:

not1notÐÑ2id :  ‘not 1 ‘not ÐÑ2 ‘id not1notÐÑ2id = ((!2 ‘!not) l2 ‘id2) 2 (‘!r ‘not)

What is particularly interesting, however, is that the collection of level-2 combinators above is complete in the sense that any equivalence between level-1 programs p and q can be proved using the level-2 combinators. Formally we have two canonical level-1 programs ‘id and ‘not and for any level-1 program p, we have evidence that either p Ø2 ‘id or p Ø2 ‘not.
To prove this, we introduce a type which encodes the knowledge of which level-1 programs are canonical. The type Which names the subset of ÐÑ1 which are canonical forms:
data Which : U where ID NOT : Which
refine : (w : Which) Ñ ‘2 ÐÑ1 ‘2 refine ID = ‘id
refine NOT = ‘not

This enables us to compute for any 2-combinator c (the name of) its canonical form, as well as a proof that c is equivalent to its canonical form:

canonical : (c : ‘2 ÐÑ1 ‘2) Ñ Σ[ c’ : Which ] (c ÐÑ2 refine c’) canonical ‘id = ID , ‘id2
canonical ‘not = NOT , ‘id2 canonical (!1 c) with canonical c
... | ID , cÐÑ2id = ID , (‘! cÐÑ2id 2 ‘!id)
... | NOT , cÐÑ2not = NOT , (‘! cÐÑ2not 2 ‘!not)
canonical (_1_ {_} {‘2} c1 c2) with canonical c1 | canonical c2
... | ID , c1ÐÑ2id | ID , c2ÐÑ2id = ID , ((c1ÐÑ2id l2 c2ÐÑ2id) 2 ‘idl ‘id)
... | ID , c1ÐÑ2id | NOT , c2ÐÑ2not = NOT , ((c1ÐÑ2id l2 c2ÐÑ2not) 2 ‘idl ‘not)
... | NOT , c1ÐÑ2not | ID , c2ÐÑ2id = NOT , ((c1ÐÑ2not l2 c2ÐÑ2id) 2 ‘idr ‘not)
... | NOT , c1ÐÑ2not | NOT , c2ÐÑ2not = ID , ((c1ÐÑ2not l2 c2ÐÑ2not) 2 not1notÐÑ2id)


It is worthwhile to note that the proof of canonical does not use all the level-2 combinators. The larger set of 2-combinators is however useful to establish a more direct connection with the model presented in the next sections.

HoTT Background
We work in intensional type theory with one univalent universe U closed under propositional truncation. The rest of this section is devoted to explaining what that means. We follow the terminology used in the HoTT book [28]. For brevity, we will often just give type signatures and elide the term. The details can be found in the accompanying code at https://git.io/v7wtW.

Equivalences
Given types A and B, a function f : A Ñ B is a quasi-inverse, if there is another function
g : B Ñ A that acts as both a left and right inverse to f:
is-qinv : {AB : U } Ñ (f : A Ñ B) Ñ U
is-qinv {A} {B} f = Σ[ g : (B Ñ A) ] (g ˝ f „ id ˆ f ˝ g „ id)

In general, for a given f, there could be several unequal inhabitants of the type is-qinv f. As Ch. 4 of the HoTT book [28] details, this is problematic in the proof-relevant setting of HoTT. To ensure that a function f can be an equivalence in at most one way, an additional coherence condition is added to quasi-inverses to define half adjoint equivalences :
is-hae : {AB : U } Ñ (f : A Ñ B) Ñ U
is-hae {A} {B} f = Σ[ g : (B Ñ A) ] Σ[ η : g ˝ f „ id ] Σ[ ε : f ˝ g „ id ] (ap f ˝ η „ ε ˝ f)
qinv-is-hae : {AB : U } {f : A Ñ B} Ñ is-qinv f Ñ is-hae f

Using this latter notion, we can define a well-behaved notion of equivalences between two types:
is-equiv = is-hae

_»_ : (AB : U ) Ñ U
A » B = Σ[ f : (A Ñ B) ] (is-equiv f)
It is straightforward to lift paths to equivalences as shown below:
ide : (A : U ) Ñ A » A
ide A = id , id , refl , refl , (refl ˝ refl)
transport-equiv : {A : U } (P : A Ñ U ) Ñ {ab : A} Ñ a == b Ñ Pa » Pb 
transport-equiv P (refl a) = ide (P a)
id-to-equiv : {AB : U } Ñ A == B Ñ A » B
id-to-equiv = transport-equiv id

Dually, univalence allows us to construct paths from equivalences. We postulate univalence as an axiom in our Agda library:
postulate
univalence : (AB : U ) Ñ is-equiv (id-to-equiv {A} {B})

We also give a short form ua for getting a path from an equivalence, and prove some computation rules for it:

module _ {AB : U } where ua : A » B Ñ A == B
ua = pr1 (univalence A B)

ua-β : id-to-equiv ˝ ua „ id
ua-β = pr1 (pr2 (pr2 (univalence A B)))

ua-β1 : transport id ˝ ua „ pr1
ua-β1 eqv = transport _ (ua-β eqv) (ap pr1)

ua-η : ua ˝ id-to-equiv „ id
ua-η = pr1 (pr2 (univalence A B))
Propositional Truncation
A type A is contractible (h-level 0 or (-2)-truncated), if it has a center of contraction, and all other terms of A are connected to it by a path:
is-contr : (A : U ) Ñ U
is-contr A = Σ[ a : A ] Π[ b : A ] (a == b)
As alluded to in the previous section, equivalences are contractible (4.2.13 in [28]):
is-equiv-is-contr : {AB : U } {f : A Ñ B} Ñ is-equiv f Ñ is-contr (is-equiv f)

A type A is a proposition (h-level 1 or (-1)-truncated) if all pairs of terms of A are connected by a path. Such a type can have at most one inhabitant; it is “contractible if inhabited.” Finally, a type A is a set if for any two terms a and b of A, its type of paths a == b is a proposition:
is-prop : (A : U ) Ñ U
is-prop A = Π[ a : A ] Π[ b : A ] (a == b)
is-set : (A : U ) Ñ U
is-set A = Π[ a : A ] Π[ b : A ] is-prop (a == b)

Any type can be truncated to a proposition by freely adding paths. This is the propositional truncation (or (-1)-truncation) which can be expressed as a higher inductive type (HIT). The type constructor _  takes a type A as a parameter; the point constructor |_| coerces terms of type A to terms in the truncation; and the path constructor ident identifies any two points in the truncation, making it a proposition. We must do this as a postulate as Agda does not yet support HITs:
postulate
 _   : (A : U ) Ñ U
|_|	: {A : U } Ñ (a : A) Ñ  A 




Fiber P pxq	Fiber P pyq
Fiber P pxq
»	Fiber P pyq






x	y	x	““	y

Base Space A	Base Space A

Fig. 2. (left) Type family P : A Ñ U as a fibration with total space Σpx:Aq P pxq;
(right) a path x ““ y in the base space induces an equivalence between the spaces (fibers) P pxq and P pyq

ident : {A : U } {ab :  A } Ñ a == b
-is-prop : {A : U } Ñ is-prop  A 
-is-prop _ _ = ident

This makes A the “free” proposition on any type A. The recursion principle (below) ensures that we can only eliminate a propositional truncation to a type that is a proposition:
module _ {A : U } (P : U ) (f : A Ñ P) (ϕ : is-prop P) where postulate
rec- -  :  A  Ñ P
rec- - -β : Π[ a : A ] (rec-  -  | a | == f a)

Type Families are Fibrations
As illustrated in Fig. 2, a type family P over a type A is a fibration with base space A, with every x in A inducing a fiber P x, and with total space Σ[ x : A ] (P x). 2
The path lifting property mapping a path in the base space to a path in the total space can be defined as follows:
lift : {A : U } {P : A Ñ U } {xy : A} Ñ (u : P x) (p : x == y) Ñ (x , u) == (y , transport Pp u) lift u (refl x) = refl (x , u)

As illustrated in the figure below, the point transport Ppu is in the space P y. A path from that point to another point v in Py can be viewed as a virtual “path” between u and v that “lies over” p. Following Licata and Brunerie [24], we often use the syntax u == v [ P Ó p ] for the path transport P p u == v to reinforce this perspective. In other words, the curved “path” between u and v below consists of first transporting u to the space Py along p and then following the straight path in Py to v:

2 In this and following figures, we color paths in blue and functions in red.

P pxq

P pyq

Given a fibration P and points x, y, u, and v as above, we have the following charac- terization of dependent paths in the total space:

module _ {A : U } {P : A Ñ U } {xy : A} {u : P x} {v : P y} where

dpair= : Σ[ p : x == y ] (u == v [ P Ó p ]) Ñ (x , u) == (y , v) dpair= (refl x , refl u) = refl (x , u)

dpair=-β : (w : Σ[ p : x == y ] (u == v [ P Ó p ])) Ñ (ap pr1 ˝ dpair=) w == pr1 w
dpair=-β (refl x , refl u) = refl (refl x)
dpair=-e : (x , u) == (y , v) Ñ x == y
dpair=-e = ap pr1

The first function builds a path in the total space given a path between u and v that lies over a path p in the base space; the second function is a computation rule for this path; and the third function eliminates a path in the total space to a path in the base space.

Univalent Fibrations
Univalent fibrations are defined by Kapulkin and Lumsdaine [21] in the simplicial set (sSet) model. In our context, a type family (fibration) P : A Ñ U is univalent if the map transport-equiv P defined in Sec. 3.1 is an equivalence, that is, if the space of paths in the base space is equivalent to the space of equivalences between the corresponding fibers. Fig. 2 (right) illustrates the situation: we know that for any fibration P that a path p in the base space induces via transport-equiv Pp an equivalence between the fibers. For a fibration to be univalent, the reverse must also be true: every equivalence between the fibers must induce a path in the base space. Formally, we have the following definition:

is-univ-fib : {A : U } (P : A Ñ U ) Ñ U
is-univ-fib {A} P = @ (ab : A) Ñ is-equiv (transport-equiv P {a} {b})
We note that the univalence axiom (for U ) is a specialization of is-univ-fib to the identity fibration, id. More generally, we can define universes à la Tarski by having a code U for the universe and an interpretation function El into U . Such a presented universe is univalent if El is a univalent fibration:
U˜ = Σ[ U : U ] (U Ñ U )

is-univalent : U˜ Ñ U
is-univalent (U , El) = is-univ-fib El
As Christensen [9] explains, a type U is rarely the base of a univalent fibration. Yet, in that same paper, Christensen characterizes a class of types that is always the base of univalent fibrations. We explain this point and exploit it to build a custom univalent subuniverse in the next section.


The Subuniverse
U˜[ 2 ]

We now have all the ingredients necessary to define the class of univalent subuniverses we are interested in. Given any type T, we can build a propositional predicate that picks out from among all the types in the universe exactly those which are identified with T. This lets us build up a “singleton” subuniverse of U as follows:
U˜[_] : (T : U ) Ñ U˜ U˜[ T ] = U , El
where
U = Σ[ X : U ]  X == T 
El = pr1
We will prove in this section and the next that choosing T to be 2 produces a universe that is sound and complete with respect to the language Π2. The bulk of the argument consists of establishing that U˜[ 2 ] is a univalent universe. We focus on this argument in the first subsection. In the next two subsections, we use this result to characterize the points and paths in the type of codes for this universe. In Sec. 5 this characterization of points and paths will be shown to match the types and combinators of Π2.
The Fibration El2 is Univalent
The universe U˜[ 2 ] consists of a base space U[2] of the codes for the elements, and an interpretation function El2, defined as follows:
U[2] : U
U[2] = pr1 U˜[ 2 ] ––- = Σ[ X : U ]  X == 2 


El2 : Σ[ X : U ]  X == 2  Ñ U
El2 = pr1
The type family El2 defines a fibration with base space U[2] as shown below:

Fiber 2	Fiber X


Base Space U[2] = Σ[ X : U ]  X == 2 
Our goal is to show that El2 is a univalent fibration. We establish this by chaining two equivalences. The first equivalence is a simple appeal to univalence in order to establish that (X == 2) » (X » 2), i.e., our base space is equivalent to the space Σ[ X : U ]  X » 2 . We name this space BAut 2. Generally, BAut T is the “classifying space” of all types that are (merely) equivalent to T. The second equivalence consists of proving that the first projection on BAut T is in fact a univalent fibration, for all spaces with shape Σ[ X : U ]  X » T  for any type T. This is the lemma is-univ-fib-ElB below whose original formulation is due to Christensen [9]:
BAut : (T : U ) Ñ U
BAut T = Σ[ X : U ]  X » T 
ElB : {T : U } Ñ BAut T Ñ U
ElB = pr1
transport-equiv-ElB : {T : U } {vw : BAut T} (p : v == w) Ñ pr1 (transport-equiv ElB p) == transport id (dpair=-e p) transport-equiv-ElB (refl v) = refl id
is-univ-fib-ElB : {T : U } Ñ is-univ-fib ElB
is-univ-fib-ElB (T , q) (T’ , q’) = qinv-is-hae (g , η , ε) where g : T » T’ Ñ T , q == T’ , q’
g eqv = dpair= (ua eqv , ident)

η : g ˝ transport-equiv ElB „ id
η (refl ._) = ap dpair= (dpair= ( ua-η (refl _)
, prop-is-set (λ __ Ñ ident)	))

ε : transport-equiv ElB ˝ g „ id

ε eqv = eqv= (transport-equiv-ElB (dpair= (ua eqv , ident))
‚ ap (transport id) (dpair=-β (ua eqv , ident))
‚ ua-β1 eqv )

This establishes that El2 is a univalent fibration, giving us a characterization of paths in U[2] in terms of equivalences on booleans which we exploit next.

The Base Space U[2]
The points in the base space U[2] are all of the form (X , |p|) where p is of type X == 2. We evidently have a canonical point 20:
20 : U[2]
20 = (2 , | refl 2 |)

which directly corresponds to the boolean type in Π2. We remind the reader that, by construction, U[2] is path-connected. What remains is to characterize the 1-paths, 2-paths, and possibly higher paths in U[2] and to relate them to the 1-combinators, 2-combinators, etc. in Π2.
To conveniently refer to the paths in U[2], we define the loop space on a (pointed) type, and show that the loop space on BAut 2 is equivalent to 2 » 2:
Ω : Σ[ T : U ] T Ñ U
Ω (T , t0) = t0 == t0
Aut : (T : U ) Ñ U
Aut T = T » T
b0 : {T : U } Ñ BAut T
b0 {T} = T , | ide T |
ΩBAut»Aut[_] : (T : U ) Ñ Ω (BAut T , b0) » Aut T
ΩBAut»Aut[ T ] = transport-equiv ElB , is-univ-fib-ElB b0 b0
The above results states that, in general, the loop space of the classifying space of a type T is equivalent to the type of automorphisms of T. In particular, it follows that Ω (BAut 2 , 20) » Aut 2 which reduces the problem of characterizing paths on U[2] to the much simpler problem of characterizing automorphisms on the type of booleans. We now turn our attention to solving that problem.

Automorphisms on 2
The type 2 has two point constructors, and no path constructors, which means it has no non-trivial paths on its points except refl. In fact, we can prove in intensional type theory using large elimination, that the two constructors are disjoint. This is

reflected in the absurd pattern when using dependent pattern matching in Agda. More generally, 2 » 1 Z 1 and the disjoint union of two sets is a set:
02‰12 : 02 == 12 Ñ K
02‰12 p = transport code p tt where code : 2 Ñ U
code 02 = J
code 12 = K

Using 02‰12 and function extensionality (derivable from univalence) we can prove that there are exactly two different equivalences between 2 and 2. Furthermore, for any equivalence f, using the fact that is-equiv f is a proposition, we can show that there are exactly two inhabitants of 2 » 2:
id» not» : 2 » 2
id»	= id , qinv-is-hae (id , refl , refl)
not» = not , qinv-is-hae (not , (λ {02 Ñ refl 02 ; 12 Ñ refl 12})
, (λ {02 Ñ refl 02 ; 12 Ñ refl 12}))
where not : 2 Ñ 2
not 02 = 12
not 12 = 02
Here something very special happens: although in general the type formed by taking n disjoint unions of 1 has a space of automorphisms of size n!, in our case we have that 2 and 2 » 2 are of the same size. This combinatorial accident can actually be lifted to show that there is an equivalence between 2 » 2 and 2. By composing the chain of equivalences Ω (U˜ , 20) » Ω (BAut(2) , b0) » (2 » 2) » 2 we obtain:
2»Ω20 : 2 » (20 == 20)

Thus there are only two distinct 1-loops in U[2]. Calling them id2 and not2, we obtain a decomposition:
all-1-loops : (p : 20 == 20) Ñ (p == id2) + (p == not2)
that every loop in U[2] is identifiable with either the identity or boolean negation.
For 2-loops in U[2], the following analysis shows that they are identifiable with the trivial path. First, by applying the induction principle for disjoint unions, and path induction, we can prove 2 is a set:
2-is-set : is-set 2
2-is-set 02 02 (refl .02) (refl .02) = refl (refl 02)
2-is-set 02 12 ()
2-is-set 12 02 ()
2-is-set 12 12 (refl .12) (refl .12) = refl (refl 12)

From this, we obtain that 20 == 20 is also a set by using ua and transport. This in turns shows the contractibility of 2-loops:
Ω20-is-set : is-set (20 == 20)
Ω20-is-set = transport is-set (ua 2»Ω20) 2-is-set
all-2-loops : {p : 20 == 20} Ñ (γ : p == p) Ñ γ == refl p
all-2-loops {p} γ = Ω20-is-set pp γ (refl p)

In the next section, we will use all-1-loops and all-2-loops as crucial ingredients for showing the correspondence between U[2] and Π2.
Note that most of the results in this section are generic. However when we move beyond 2, the combinatorial explosion of the path space is such that explicit enumeration quickly becomes impractical, and other techniques will become necessary.
Correspondence between U[2] and Π2
Formalizing, in a precise sense, the connection between reversible functions in a programming language and paths in a univalent universe, as intuitive as it may seem, is rather subtle. Paths in HoTT come equipped with principles like the “contractibility of singletons”, “transport”, and “path induction” and none of these principles seem to have any direct counterpart in the world of reversible programming. We will however demonstrate how the semantics of an entire (but admittedly small) reversible programming language such as Π2 can be captured by a specification as compact as Σ[ X : U ]  X == 2 . Our precise correspondence will consist of building mappings between Π2 and U˜[2], for points, 1-paths, 2-paths, and 3-paths, such that each map is invertible up to the appropriate notion of equality. This gives a notion of soundness and completeness for each level.
Mappings
The mappings for points (level-0) are straightforward, as both Π2 and U[2] are singletons:
J_)0 : Π2 Ñ U[2]
J ‘2 )0 = 20
x_y0 : U[2] Ñ Π2
x _ y0 = ‘2
Level-1 is the first non-trivial level. To each syntactic combinator c : A ÐÑ1 B, we associate a path from J A )0 to J B )0 and vice-versa. The mapping from the univalent universe back to the syntax of the reversible language is only possible because we have a complete characterization of the paths in the universe (captured in the construction of all-1-loops in the previous section):

J_)1 : {AB : Π2} Ñ A ÐÑ1 B Ñ J A )0 == J B )0
J ‘id )1	= id2
J ‘not )1	= not2
J !1 p )1	= ! J p )1
J p 1 q )1 = J p )1 ‚ J q )1
x_y1 : 20 == 20 Ñ x 20 y0 ÐÑ1 x 20 y0
x p y1 with all-1-loops p
... | inl pid	= ‘id
... | inr pnot = ‘not
At level-2, we know by the construction of all-2-loops in the previous section that all self-paths in the univalent universe are trivial. Nevertheless the mappings back and forth require quite a bit of (tedious) work. We show below a few cases of the mapping from 2-combinators to 2-paths and the full definition of the reverse mapping. In the first direction, it is a matter of using the necessary properties of paths in the univalent universe (e.g, each path has an inverse). These properties are proved by path induction. The reverse direction crucially relies again on the characterization of 1-loops and the fact that the identity equivalence and the equivalence that swaps the two booleans are distinct:
2
J_)2 : {AB : Π2} {pq : A ÐÑ1 B} Ñ (u : p ÐÑ2 q) Ñ J p )1 == J q )1
J ‘id2 {p = p} )2 = refl J p )1 J !2 u )2	= ! J u )2
J u1 2 u2 )2	= J u1 )2 ‚ J u2 )2
J ‘idl p )2	= ‚unitl J p )1
J ‘idr p )2	= ‚unitr J p )1
J ‘! u )2	= ap !_ J u )2
– remaining cases are omitted

x_y2 : {pq : 20 == 20} Ñ p == q Ñ x p y1 ÐÑ2 x q y1 x_y2 {p} {q} u with all-1-loops p | all-1-loops q
... | inl p=id	| inl q=id	= ‘id2
... | inl p=id	| inr q=not = K-elim (id2‰not2 ((! p=id) ‚ u ‚ q=not))
... | inr p=not | inl q=id	= K-elim (id2‰not2 ((! q=id) ‚ ! u ‚ p=not))
... | inr p=not | inr q=not = ‘id2
For the final level-3, mapping from the univalent universe to Π2 is trivial as the latter has only one constructor at level-3. The other direction requires some involved reasoning in the univalent universe to construct the required 3-path:
lemma : {pqr : 20 == 20} (p=r : p == r) (q=r : q == r) (u : p == q)
Ñ u == p=r ‚ ((! p=r) ‚ u ‚ q=r) ‚ (! q=r)



J_)3 : {AB : Π2} {pq : A ÐÑ1 B} {uv : p ÐÑ2 q} Ñ (α : u ÐÑ3 v) Ñ J u )2 == J v )2
J_)3 {‘2} {‘2} {p} {q} {u} {v} ‘trunc with all-1-loops J p )1 | all-1-loops J q )1
... | inl p=id | inl q=id = lemma p=id q=id J u )2
‚ ap (λ x Ñ p=id ‚ x ‚ ! q=id)
(all-2-loops (! p=id ‚ J u )2 ‚ q=id) ‚ ! (all-2-loops (! p=id ‚ J v )2 ‚ q=id)))
‚ ! (lemma p=id q=id J v )2)
... | inl p=id | inr q=not = K-elim (id2‰not2 ((! p=id) ‚ J u )2 ‚ q=not))
... | inr p=not | inl q=id = K-elim (id2‰not2 ((! q=id) ‚ ! J u )2 ‚ p=not))
... | inr p=not | inr q=not = lemma p=not q=not J u )2
‚ ap (λ x Ñ p=not ‚ x ‚ ! q=not)
(all-2-loops (! p=not ‚ J u )2 ‚ q=not) ‚ ! (all-2-loops (! p=not ‚ J v )2 ‚ q=not)))
‚ ! (lemma p=not q=not J v )2)
x_y3 : {pq : 20 == 20} {uv : p == q} Ñ u == v Ñ x u y2 ÐÑ3 x v y2 x _ y3 = ‘trunc


Coherence
It now remains to show that all these mapping are coherent with each other in the sense that each round trip produces a term that is identifiable with the original term, effectively showing soundness and completness of the univalent universe with respect to Π2. At level-0, this is trivial.
At level-1, soundness means that the mappings are inverses:
any 1-combinator p mapped to a 1-path and back is 2-equivalent to itself, and
there is always a 2-path between a 1-path p sent to a 1-combinator and back.
This is rather more succinct in code:
xJ_)1y1 : (p : ‘2 ÐÑ1 ‘2) Ñ p ÐÑ2 x J p )1 y1
xJ p )1y1 with canonical p | all-1-loops J p )1
... | ID , pôid	| inl p=id	= pôid
... | ID , pôid	| inr p=not = K-elim (id2‰not2 (! ((! p=not) ‚ J pôid )2)))
... | NOT , pônot | inl p=id	= K-elim (id2‰not2 ((! p=id) ‚ J pônot )2))
... | NOT , pônot | inr p=not = pônot
Jx_y1)1 : (p : 20 == 20) Ñ p == J x p y1 )1
Jx p y1)1 with all-1-loops p | canonical x p y1
... | inl p=id	| ID , pôid	= p=id
... | inl p=id	| NOT , pônot = K-elim (id2‰not2 J pônot )2)
... | inr p=not | ID , pôid	= K-elim (id2‰not2 (! J pôid )2))
... | inr p=not | NOT , pônot = p=not
They are also complete in the following sense:

for any two 1-combinators which map to 1-paths which are related by a 2-path, the 1-combinators are related by a 2-combinator, and
for any two 1-paths which map to 1-combinators which are related by a 2- combinator these are related by a 2-path.
Normally, completeness is a rather difficult result to prove. But in our case, the infrastructure from the previous section makes the proof immediate: For the first proof, the key is reversibility of the level-2 combinators using !2; for the second proof it is the reversibility of paths in the univalent universe that is critical:
completeness1 : {pq : ‘2 ÐÑ1 ‘2} Ñ J p )1 == J q )1 Ñ p ÐÑ2 q
completeness1 {p} {q} u = xJ p )1y1 2 (x u y2 2 !2 xJ q )1y1)
completeness1-1 : {pq : 20 == 20} Ñ x p y1 ÐÑ2 x q y1 Ñ p == q
completeness1-1 {p} {q} u = Jx p y1)1 ‚ J u )2 ‚ (! Jx q y1)1)

For level-2, the statements are informally quite similar (with all levels bumped up by one). For 2-combinators, the result is trivial. For the other direction starting from 2-paths in the univalent universe soundness is tricky to even state, mostly because the types involved in x J u )2 y2 and J x u y2 )2 are non-trivial. But enumeration of 1-loops reduces the complexity of the problem to “unwinding” complex expressions for identity paths:

xJ_)2y2 : {pq : ‘2 ÐÑ1 ‘2}
(u : p ÐÑ2 q) Ñ u ÐÑ3 (xJ p )1y1 2 (x J u )2 y2 2 (!2 xJ q )1y1)))
xJ u )2y2 = ‘trunc
Jx_y2)2 : {pq : 20 == 20} (u : p == q) Ñ u == Jx p y1)1 ‚ J x u y2 )2 ‚ (! Jx q y1)1)
Jx_y2)2 {p} {q} u with all-1-loops p | all-1-loops q
... | inl p=id | inl q=id = (lemma p=id q=id u)
‚ (ap (λ x Ñ p=id ‚ x ‚ ! q=id) (all-2-loops (! p=id ‚ u ‚ q=id)))
... | inl p=id | inr q=not = K-elim (id2‰not2 ((! p=id) ‚ u ‚ q=not))
... | inr p=not | inl q=id = K-elim (id2‰not2 (! ((! p=not) ‚ u ‚ q=id)))
... | inr p=not | inr q=not = (lemma p=not q=not u)
‚ (ap (λ x Ñ p=not ‚ x ‚ ! q=not) (all-2-loops (! p=not ‚ u ‚ q=not)))


Level-2 completeness offers no new difficulties:
completeness2 : {pq : ‘2 ÐÑ1 ‘2} {uv : p ÐÑ2 q} Ñ J u )2 == J v )2 Ñ u ÐÑ3 v
completeness2 u = ‘trunc
completeness2-1 : {pq : 20 == 20} {uv : p == q} Ñ x u y2 ÐÑ3 x v y2 Ñ u == v
completeness2-1 {p} {q} {u} {v} α = Jx u y2)2
‚ ap (λ x Ñ Jx p y1)1 ‚ x ‚ ! Jx q y1)1) J α )3
‚ (! Jx v y2)2)

Discussion and Related Work
Reversible Languages.
The practice of programming languages is replete with ad hoc instances of reversible computations: database transactions, mechanisms for data provenance, checkpoints, stack and exception traces, logs, backups, rollback recoveries, version control systems, reverse engineering, software transactional memories, continuations, backtracking search, and multiple-level “undo” features in commercial applications. In the early nineties, Baker [3,4] argued for a systematic, first-class, treatment of reversibility. But intensive research in full-fledged reversible models of computations and reversible programming languages was only sparked by the discovery of deep connections between physics and computation [23,26,29,5,13], and by the potential for efficient quantum computation [12].
The early developments of reversible programming languages started with a conventional programming language, e.g., an extended λ-calculus, and either
extended the language with a history mechanism [30,22,17,10], or
imposed constraints on the control flow constructs to make them reversible [33].
More modern approaches recognize that reversible programming languages require a fresh approach and should be designed from first principles without the detour via conventional irreversible languages [32,25,2,11].

The Π Family of Languages
In previous work, Carette, Bowman, James, and Sabry [6,18,8] introduced the Π family of reversible languages based on type isomorphisms and commutative semiring identities. The fragment without recursive types is universal for reversible boolean circuits [18] and the extension with recursive types and trace operators [15] is a Turing-complete reversible language [18,6]. While at first sight, Π might appear ad hoc, it really arises naturally from an “extended” view of the Curry-Howard correspondence [8]: rather than looking at mere inhabitation as the main source of analogy between logic and computation, type equivalences becomes the source of analogy. This allows one to see an analogy between algebra and reversible computation. Furthermore, this works at multiple levels: that of 1-algebra (types form a semiring under isomorphism), but also 2-algebra (types and equivalences form a weak Rig Groupoid). In other words, by taking “weak Rig Groupoid” as the starting semantics, one naturally gets Π as the syntax for the language of proofs of isomorphisms – in the same way that many terms of the λ-calculus arise from Cartesian Closed Categories.
One can also flip this around, and use the λ-calculus as the internal language for Cartesian Closed Categories. However, as Shulman explains well in his draft book on approaching Categorical Logic via Type Theory [27], this works for many other kinds of categories. As we are interested in reversibility, it is most natural to look at Groupoids. Thus Π2 represents the simplest non-trivial case of a (reversible) programming language distilled from such ideas.

What is more surprising is how this also turns out to be a sound and complete language for describing the univalent universe U[2].
The infinite real projective space RP8
Buchholtz and Rijke [7] use the “type of two element sets,” Σ[ X : U ]  X == S0 , where S0 is the 0-sphere, or the 0-iterated suspension of 2, that is, 2 itself. They construct the infinite real projective space RP8 by using universal covering spaces, and show that it is homotopy equivalent to the Eilenberg-Maclane space KpZ{2Z, 1q which classifies all the 0-sphere bundles. Our reversible programming language is exactly the syntactic presentation of this classifying space. If we choose S1 instead of S0, we get the infinite complex projective space CP8, but it remains to investigate what kind of reversible programming language this would lead to.
If we consider the Π language over all finite types, we conjecture that we should
get a representation of š	KpSn, 1q where Sn is the symmetric group. The idea is
that the nth homotopy group of an Eilenberg-Maclane space KpG, nq is isomorphic to G (and every other homotopy group is trivial). Thus, all necessary information about paths and equivalences between finite types is captured in this model.

Acknowledgement
We would like to thank Robert Rose for developing the model based on univalent fibrations, for extensive contributions to the code, and for numerous discussions.

References
	POPL ’12: Proceedings of the 39th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (New York, NY, USA, 2012), ACM.
	Abramsky, S. A structural approach to reversible computation. Theor. Comput. Sci. 347 (December 2005), 441–464.
Baker, H. G. Lively linear Lisp: — look ma, no garbage! —. SIGPLAN Not. 27 (August 1992), 89–98.
	Baker, H. G. Nreversal of fortune - the thermodynamics of garbage collection. In Proceedings of the International Workshop on Memory Management (1992), Springer-Verlag, pp. 507–524.
	Bennett, C., and Landauer, R. The fundamental physical limits of computation. Scientiﬁc American 253, 1 (1985), 48–56.
Bowman, W. J., James, R. P., and Sabry, A. Dagger Traced Symmetric Monoidal Categories and Reversible Programming. In RC (2011).
	Buchholtz, U., and Rijke, E. The real projective spaces in homotopy type theory. arXiv preprint arXiv:1704.05770 (2017).
Carette, J., and Sabry, A. ESOP 2016. Springer Berlin Heidelberg, Berlin, Heidelberg, 2016, ch. Computing with Semirings and Weak Rig Groupoids, pp. 123–148.
Christensen, D. A characterization of univalent fibrations. In Category Theory, CT2015 (Aveiro, Portugal, 2015).
Danos, V., and Krivine, J. Reversible communicating systems. Concurrency Theory (2004), 292–307.
	Di Pierro, A., Hankin, C., and Wiklicky, H. Reversible combinatory logic. MSCS 16 (August 2006), 621–637.

Feynman, R. Simulating physics with computers. International Journal of Theoretical Physics 21
(1982), 467–488.
	Frank, M. P. Reversibility for eﬃcient computing. PhD thesis, Massachusetts Institute of Technology, 1999.
	Fredkin, E., and Toffoli, T. Conservative logic. International Journal of Theoretical Physics 21, 3 (1982), 219–253.
Hasegawa, M. Recursion from cyclic sharing: Traced monoidal categories and models of cyclic lambda calculi. In TLCA (1997), pp. 196–213.
Hey, A. J. G., Ed. Feynman and Computation: Exploring the Limits of Computers. Perseus Books, Cambridge, MA, USA, 1999.
	Huelsbergen, L. A logically reversible evaluator for the call-by-name lambda calculus. InterJournal Complex Systems 46 (1996).
James, R. P., and Sabry, A. Information effects. In POPL (2012), ACM, pp. 73–84.
James, R. P., and Sabry, A. Isomorphic interpreters from logically reversible abstract machines. In
RC (2012).
James, R. P., and Sabry, A. Theseus: A high-level language for reversible computing. In Work-in- progress report in the Conference on Reversible Computation (2014).
	Kapulkin, C., and LeFanu Lumsdaine, P. The Simplicial Model of Univalent Foundations (after Voevodsky). ArXiv e-prints (Nov. 2012).
	Kluge, W. E. A reversible SE(M)CD machine. In International Workshop on Implementation of Functional Languages (2000), Springer-Verlag, pp. 95–113.
	Landauer, R. Irreversibility and heat generation in the computing process. IBM J. Res. Dev. 5 (July 1961), 183–191.
	Licata, D. R., and Brunerie, G. A cubical approach to synthetic homotopy theory. In Proceedings of the 2015 30th Annual ACM/IEEE Symposium on Logic in Computer Science (LICS) (2015), IEEE Computer Society, pp. 92–103.
Mu, S.-C., Hu, Z., and Takeichi, M. An injective language for reversible computation. In MPC
(2004), pp. 289–313.
Peres, A. Reversible logic and quantum computers. Phys. Rev. A 32, 6 (Dec 1985).
	Shulman, M. Categorical logic from a categorical point of view. Draft for AARMS Summer School 2016. Available at http://mikeshulman.github.io/catlog/catlog.pdf, Version of July 28, 2016.
The Univalent Foundations Program.  Homotopy Type Theory: Univalent Foundations of
Mathematics. http://homotopytypetheory.org/book, Institute for Advanced Study, 2013.
	Toffoli, T. Reversible computing. In Proceedings of the 7th Colloquium on Automata, Languages and Programming (1980), Springer-Verlag, pp. 632–644.
	van Tonder, A. A lambda calculus for quantum computation. SIAM Journal on Computing 33, 5 (2004), 1109–1135.
Voevodsky, V. A very short note on homotopy λ-calculus. Unpublished (September 2006), 1–7.
Yokoyama, T., Axelsen, H. B., and Glück, R. Principles of a reversible programming language. In Conference on Computing Frontiers (2008), ACM, pp. 43–54.
Yokoyama, T., and Glück, R. A reversible programming language and its invertible self-interpreter. In PEPM (2007), ACM, pp. 144–153.
