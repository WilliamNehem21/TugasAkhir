	Electronic Notes in Theoretical Computer Science 203 (2008) 93–108	
www.elsevier.com/locate/entcs

Deduction Graphs with Universal Quantification
Herman Geuvers 1
Institute for Computing and Information Sciences Radboud University Nijmegen, The Netherlands
Iris Loeb2
Department of Mathematics and Statistics University of Canterbury, New Zealand

Abstract
Deduction Graphs are meant to generalise both Gentzen-Prawitz style natural deductions and Fitch style flag deductions. They have the structure of acyclic directed graphs with boxes. In [3] we have investigated the deduction graphs for minimal proposition logic. This paper studies the extension with first-order universal quantification, showing the robustness of the concept of deduction graphs.
Keywords: Natural deduction, universal quantification, cut-elimination.


Introduction
Deduction Graphs for minimal proposition logic
In this paper we extend deduction graphs, DGs, of [3] (see also [6]), with first-order universal quantification. In [3] we have presented deduction graphs for minimal proposition logic (only implication) as a formalism for “natural deduction with sharing”. This extends Gentzen-Prawitz natural deduction, in which sharing is not possible, without introducing the arbitrariness of Fitch deductions, caused by the requirement that derivations are linear. The derivations in our formalism become acyclic directed graphs with boxes to delimit the scope of local assumptions. The boxes are used in the →-introduction rule. We repeat some definitions of [3].

1 Email: H.Geuvers@cs.ru.nl
2 Email: I.Loeb@math.canterbury.ac.nz

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.036

Definition 1.1 A closed box directed graph is a triple ⟨X, G, (Bi)i∈I⟩ where X is a set of labels, G is a directed graph where all nodes have a label in X and (Bi)i∈I is a collection of sets of nodes of G, the boxes. Each box Bi corresponds to a node, the box node of Bi. Moreover, the boxes (Bi)i∈I should satisfy the following properties.
(Non-overlap) Two boxes are disjoint or one is contained in the other: ∀i, j ∈
I(Bi ∩ Bj = ∅∨ Bi ⊂ Bj ∨ Bj ⊂ Bi),
(box node edge) There is only one outgoing edge from a box node and that points into the box itself (i.e. to a node in the box),
(No edges into a box) Apart from the edge from the box node, there are no edges pointing into a box.
Definition 1.2 Let ⟨G, (Bi)i∈I⟩, be a closed box directed graph and let n0 and n1
be nodes in this graph.
Node n1 is in scope of n0 if n0 is in all boxes that n1 is in.  In a formula:
∀i ∈ I(n1 ∈ Bi ⇒ n0 ∈ Bi). (So the nodes in scope of n0 are the nodes that are in ‘wider’ boxes.)
The nodes n0 and n1 are at the same depth, when n0 is in scope of n1, and n1 is in scope of n0. Node n0 is at a greater depth than n1, when n1 is in scope of n0, but n0 is not in scope of n1.
Node n1 is a top-level node if n1 is not contained in any box.
The free nodes are the top-level nodes that have no outgoing edges. The importance of the next definition will become clear in Lemma 2.6.
Definition 1.3 Let G be a closed box directed graph. A box-topological ordering
of G is a linear ordering < of the nodes of G, such that for all nodes n0, n1 of G:
If n0 −−d n1, then n1 < n0.
If n0 is the box node of a box containing n1, then n1 < n0.
Deduction graphs are a special kind of closed box directed graphs (Definition 1.1): The labels of the nodes are formulas of minimal proposition logic, and there are rules to ensure that the graph represents a logical derivation. (The precise definition can be found in [3]; in the present paper it appears as part of Definition 2.3.) Figure 1 shows an example.

The arrow represents (inverse) derivability, so e.g. node (9, B) is derived from nodes (6, A→B) and (8, A): It is an →-elimination. Similarly node (6, A→B) is derived from (5, B) while discharging the nodes without outgoing edges (assumptions) (1, A) and (2, A): It is an →-introduction. Note that node (6, A→B) is shared: It has two incoming edges.
Deduction graphs can contain cuts: An →-introduction, immediately followed by an →-elimination (possibly separated by the repetition of formulas). In principle, we can eliminate a cut in the way that is indicated schematically in Fig.2.


\
\	(1, A)
\

(2, A)
\

/
/	(3, A→A→B)
/	ccc

\	\	/ cc
\	\	cc /
\	\	\	c	/

\	(4, A→B)	/
\	/
\	/
(7, (A→B)→A)
\

\	\	/
\	(5,B)	/
\	/
\	/
\
\
\
\
,,,, (8, A)

\	/	,,,,,	/
\	/	,,,,	/

(6, A→B) ,
zzzz
zzz
/
/
/
/
/
/
(9,B)


Fig. 1. Deduction graph in the implicational fragment



(n1,A)






(n,A−>B)
(m,A)


(p,B)




(p,B)

(m,A)

Fig. 2. Cut-elimination in deduction graphs.



However, the actual situation is harder than the one sketched in Figure 2:
The →-introduction and the →-elimination may be separated by repeats.
The involved box may have multiple incoming edges. In this case, if we would transform the deduction graph as indicated in the figure, the resulting structure would not be a deduction graph again, as these edges would be “dangling”.
The minor premiss (m, A) of the elimination might be at a greater depth than the major premiss (n, A→B). In this case, if we would transform the deduction graph as indicated in the figure, the resulting graph may not be a closed box directed graph, as edges from a node ((n1, A),..., (nk, A) in the figure) might go to a node at a greater depth ((m, A)).
If these problems do not occur, we call the cut safe. The transformations repeat- elimination, unsharing, and incorporation on deduction graphs are used to make a cut safe if any of the above problems occurs. (See [3]). The series of transformations involved in making a cut safe and eliminating the safe cut, is called the process of cut-elimination. In [3] we have shown by going to a λ-calculus with tupling, that the process of cut-elimination is strongly normalising, i.e. we can transform any deduction graph into a cut-free deduction graph in a finite numbers of steps using these transformations.

Adding Universal Quantiﬁcation
Originally, boxes were meant to border the scope of a local assumption, but now we also use boxes to border the scope of a quantifier: When we do a ∀-introduction, we create a box with box node ∀x.ϕ. To carry this extension through we have to consider how to deal with the side condition on the ∀-introduction rule, which is stated in Gentzen-Prawitz style natural deduction as follows: “the eigenvariable does not occur free in any of the non-discharged assumptions”. (The eigenvariable is the quantified variable x in the introduction of ∀x.ϕ.) In DGUs we want to represent this by a more “local” side condition. A first idea would be to require that there is no edge pointing out of the box to a formula in which the eigenvariable occurs free, like usually done in Fitch deductions. (So when we introduce ∀x.ϕ, the box we create should not have edges pointing out to a node ψ with x ∈ FV(ψ).) However, this would cause severe problems in the cut-elimination procedure, as the following graph shows. The ∀-box has been depicted with a dashed line.


(1, A→P(x)→∀y.Q(y))



(2, P(x))
(7, ∀x.S(x))	(8, ∀x.(S(x)→A))








(16, ∀x.P(x))






, ∀x.(∀y.Q(y))→P(x))


There is a non-safe →-cut in node 12: Nodes 6 and 12 are not at the same depth. So we first have to do an incorporation step, moving the box with box node 6 into the box with box node 16.
The eigenvariable of the ∀-box is x. If we would do an incorporation directly, there would be arrows from inside the ∀-box to the nodes 1 and 2 outside the box, in which x occurs free. This is forbidden. We therefore first have to do a renaming of the eigenvariable, as shown in Fig. 3.


(1, A→P(x)→∀y.Q(y))



(2, P(x))
(7, ∀x.S(x))	(8, ∀x.(S(x)→A))










(16, ∀z.P(z))

Fig. 3. Renaming of eigenvariable.






, ∀x.(∀y.Q(y))→P(x))




P(x)
[A]1  A→P(x)→∀y.Q(y)


P(x)→∀y.Q(y)
∀y.Q(y)
1
A→∀y.Q(y)


∀x.S(x)


S(x)


∀x.(S(x)→A)


S(x)→A
A





∀x.(∀y.Q(y)→P(x))

∀y.Q(y)


P(x)
∀x.P(x)


∀y.Q(y)→P(x)


Fig. 4. Gentzen-Prawitz style natural deduction (incorrect).

This renaming is not so trivial because it not only involves nodes inside the box but also the x in node 16. But when we rename x in node 16, we also have to rename it in nodes that refer to 16, and propagate that through the graph. This could thus involve any node of G, eventually even nodes 1 and 2. Renaming is hence not just complicated, but it might a priori not even solve the problem.
As this looks like Gentzen-Prawitz style natural deduction, why doesn’t the necessity to rename variables occur there? There is no sharing in the example graph, so we can present the deduction faithfully as a tree as done in Fig.4.

However, this is not a correct Gentzen-Prawitz style natural deduction, as the variable x occurs free in some non-discharged assumptions when it gets bound. Apparently the ∀-introduction rule in Gentzen-Prawitz style natural deduction is – due to its “global” nature – strict enough to prevent the need for renaming variables during ∀-cut-elimination.
Our solution is to use two sets of variables: free variables, Var and bound vari- ables BVar and to rename the free variable with a fresh bound variable when doing the ∀-introduction. Furthermore, we require that the eigenvariable is unique for that box (i.e. it does not occur anywhere outside the box). A further discussion of the choice of syntax can be found in Section 3.1.
In Section 2 we give the definition of deduction graphs with universal quantifi- cation, called DGUs, starting from definitions for terms and formulas of first-order predicate logic. The process of cut-elimination is discussed in Section 3, followed by strong normalisation in Section 4. Finally, Section 5 compares DGUs with devel- opments in proof nets.

Definition
Different from the language of first-order predicate logic for Gentzen-Prawitz style natural deduction [1,7], we define the language Pred of first-order predicate logic with universal quantification and equality for deduction graphs to have two kinds of variables. The first kind, Var denoted by u, v, w, . . ., are meant to be used as free variables. The second kind, BVar, denoted by x, y, z,.. ., will only be used bound. The same idea is often used for the language of first-order predicate logic for Fitch style flag deductions [8].

We now define the terms, basic formulas, formulas and axioms of Pred.
Definition 2.1	(i) The set Term of terms of Pred, Term is defined as follows.
Term ::= Var | F(Term,..., Term)

where F is a function symbol with a fixed arity and the length of the sequence of terms following it should be equal to the arity of F.
(ii) The set of formulas of Pred, Form, is defined as follows.
Form ::= R(Term,..., Term) | Term = Term | Form→Form | ∀x.Form[x/u]
where R is a relation symbol with a fixed arity and the length of the sequence of terms following it should be equal to the arity of R; x ranges over BVar and u over Var and we require that x is fresh, i.e. it does not yet occur as a bound variable in the formula.
Remark 2.2 When we introduce a binder we also replace a free variable by a bound one. This replacement is denoted by the substitution [x/u]: if ϕ ∈ Form and x is not a bound variable in ϕ, then ∀x.ϕ[x/u] ∈ Form. Because x is required to be fresh, the substitution [x/u] does not involve a renaming of bound variables.
We note that, due to our distinction between BVar and Var and the requirement that bound variables occur uniquely in a formula, the substitutions ψ[t/x] (replacing x by t to be able to go from ∀x.ψ to ψ[t/x]), ϕ[x/u][t/x] (used in the definition of cut-elimination later) and ϕ[t/u] are defined unambiguously.
We adopt the following convention for the brackets in formula: → is right- associative; ∀ binds stronger than →; outer brackets are not written, nor are any other brackets that do not contribute to our understanding of the formula.
So, for example, ∀x.ϕ→ψ→ξ ≡ ((∀x.ϕ)→(ψ→ξ)). Note, however, that
∀x.P(x)→Q(x) can formally only be understood as (∀x.(P(x)→Q(x))), because ((∀x.P(x))→Q(x)) is not a formula. In these cases we will write the inner brackets under the quantifier explicitly anyway, for the convention would otherwise lead us to misinterpret the formula.
Because Pred deviates from the language of first-order predicate logic for Gentzen-Prawitz natural deduction, this also means that the ∀-introduction for deduction graphs cannot be similar to the ∀-introduction in the Gentzen-Prawitz formalism.
The ∀-introduction in Gentzen-Prawitz style natural deduction is as follows:
D

ϕ

∀x.ϕ
Where x may not be free in the non-discharged assumptions of D. This means that
x might be free in ϕ, although it is bound in ∀x.ϕ.

In deduction graphs we will introduce a fresh (bound) variable in the ∀- introduction step. The advantage is then, that a graph may still be correct, when we rename only free variables. We will use this later, in the process of cut-elimination.


Definition 2.3 The collection of deduction graphs for ﬁrst-order universal quan- tiﬁcation, DGU is the set of closed box directed graphs over IN × Pred inductively defined as follows:
Axiom A single node (n, A) is a deduction graph,
→-E If G is a deduction graph containing two nodes (n, A→B) and (m, A) at the top level, then the graph G' := G with
a new node (p, B) at the top level
an edge (p, B) −−d (n, A→B),
an edge (p, B) −−d (m, A), is a deduction graph.
→-I If G is a deduction graph containing a node (j, B) with no ingoing edge and a finite set of free nodes with label A, (n1, A),..., (nk, A), all at the top level, then the graph G' := G with
a box B with box node (n, A→B), containing the nodes (j, B) and (n1, A),
..., (nk, A) and no other nodes that were free in G,
an edge from the box node (n, A→B) to (j, B)
is a deduction graph under the proviso that it is a closed box directed graph.
Repeat If G is a deduction graph containing a node (n, A) at the top level, the graph
G' := G with
a new node (m, A) at the top level,
an edge (m, A) −−d (n, A) is a deduction graph.
∀-I If G is a DGU containing a node (j, ϕ) with no ingoing edge at top-level for some formula ϕ of Pred, then the graph G' := G with
a box B with box node (n, ∀x.ϕ[x/u]) , not containing any nodes without out- going edges, where we call u the eigenvariable of B if u occurs in ϕ,
an edge from the box node (n, ∀x.ϕ[x/u]) to (j, ϕ)


(1, ∀y.(P(y)→Q(y)))
\	\
\	\
\	\
\


(2, ∀x.P(x))	/
	/
/

\	(3, P(u)→Q(u))	(4, P(u))	/

\	zzz
   	/

\	zzz	/
\	(5, Q(u))	/
\	/
\	/
\	(6, ∀x.Q(x))  /
\	/
\	/
(7, ∀x.P(x)→∀x.Q(x))
Fig. 5. An example of a DGU.

is a DGU under the proviso that: G' is a well-formed closed box directed graph and u does not occur in the label of any node that is not in B.
∀-E If G is a DGU with a node (n, ∀x.ϕ) at top-level for some formula ϕ of Pred, then the graph G' := G with
a node (p, ϕ[t/x]) where none of the variables of t is the eigenvariable of any box of G,
an edge from (p, ϕ[t/x]) to (n, ∀x.ϕ) is a DGU.
JoinU If G and G' are two DGUs then G'' = G ∪ G' is a DGU under proviso that the eigenvariables of G and the eigenvariables of G' are disjoint.
So the rules for DGU are the ones for DG with the ∀-I and ∀-E rules added and the Join rule slightly modified.
Example 2.4 Let P and Q be unary predicate symbols of Pred. Figure 5 shows an example of an DGU.
Lemma 2.5 Let G be a DGU. Then for every variable u:
u occurs as eigenvariable of a box of G at most once;
If u is an eigenvariable of a box B of G, it does not occur in a label of a node outside B.
We formulate a criterion to check relatively easily whether a given closed box directed graph is a DGU (Lemma 2.6). As an important notion for DGUs is the eigenvariable of a box, we need a similar notion for general closed box directed graphs. So, we call a variable u a box-variable of B, if u does not occur in the label of the box node of B, but it does occur in the label of the node that the box node points to. Remark that for DGUs the notion of eigenvariable and the notion of box- variable coincide. We also recall from [3] the notion of a box-topological ordering :
is a box-topological ordering of G if it is a linear ordering of the nodes of G, such that n −−dm ⇒ n > m and if B has box node n and m ∈ B, then n > m.
Lemma 2.6 A closed box directed graph G is a DGU if and only if the following hold
If u is a box-variable of a box B of G, it does not occur in a label of a node outside B.
G is ﬁnite.
There is a box-topological ordering > of G.
Every node of G is of one of the following six types:
A n has no outgoing edges.
→-E n has label B and has exactly two outgoing edges: one to a node (m, A→B)
and one to a node (p, A), both within the scope of n.
→-I n is a box node of a box B with label A→B and has exactly one outgoing edge, which is to a node (j, B) inside the box B (and not in any deeper boxes) with no other ingoing edges. All nodes inside the box without outgoing edges have label A.

R n has label A and has exactly one outgoing edge, which is to a node (m, A)
that is within the scope of n.
∀-E n has label ϕ[t/x] for some formula ϕ, some term t and some variable x, and
n has exactly one outgoing edge: to a node (m, ∀x.ϕ) within the scope of n.
∀-I n is a box node of a box B with label ∀x.ϕ for some variable x and some formula ϕ, and has exactly one outgoing edge, which is to a node (j, ϕ[u/x]) inside the box B (and not in any deeper boxes) with no other ingoing edges. There are no nodes without outgoing edges in B.

Cut-elimination
By introducing the universal quantification, we have also introduced a new cut, the ∀-cut (as opposed to the →-cut): A ∀-introduction immediately followed by a
∀-elimination. Lemma 3.3 describes the elimination of a safe ∀-cut.
Just as not all →-cuts are safe, neither are all ∀-cuts, so it might be necessary to apply some transformations to make them safe. These transformations are the same ones as for →-cuts: repeat-elimination, unsharing, and incorporation. The only difference with the transformations on DGs is, that unsharing has become a little more involved, because of the eigenvariable requirement.
Definition 3.1 A ∀-cut in a DGU G is a subgraph of G consisting of:
a box node (n, ∀x.ϕ),
a node (p, ϕ[t/x]),
a sequence of R-nodes (s0, ∀x.ϕ),..., (si, ∀x.ϕ),
edges (p, ϕ[t/x]) −−d (si, ∀x.ϕ) −−d ... −−d (s0, ∀x.ϕ) −−d (n, ∀x.ϕ).
We call the node (n, ∀x.ϕ) the major premiss and we call the node (p, ϕ[t/x]) the
conclusion of the ∀-cut.
Similarly, in a →-cut, we call (n, A→B) the major premiss and the node (p, B) the conclusion.
Definition 3.2 Let B be the box associated to box node n. A (∀/→)-cut in a DGU
G is safe if the following requirements hold:
there is an edge from the conclusion to the major premiss and that is the only edge to the major premiss;
the major premiss and the conclusion are at the same depth (relative to the box structure);
Definition 3.3 The process of eliminating a safe ∀-cut is the following operation on DGUs (see Figure 6):
change the labels ψ of the nodes in the box of n, to ψ[t/u] 3 ;

3 Substituting t for u in ψ does not involve renaming, because t only contains free variables. See also Remark 2.2.

remove the box and box node (n, ∀x.ϕ[x/u]);
add an edge from (p, ϕ[t/u]) to (j, ϕ[t/u]) (the node that n pointed to).

B[t/u]
	J
(j, ϕ[t/u])

(n, ∀x.ϕ[x/u])
(p, ϕ[x/u][t/x])	(p, ϕ[x/u][t/x])
Fig. 6. Schematic presentation of a safe ∀-cut elimination.


Lemma 3.4 If G is a DGU with safe ∀-cut c and G' is obtained from G by eliminating
c, then G' is also a DGU.
Proof. By Lemma 2.6.	 
We can generalise repeat-elimination, unsharing, and incorporation without much ado. Because after unsharing we still want every eigenvariable to occur just once, this step now includes the renaming of eigenvariables of copied boxes.
Definition 3.5 Let G be a DGU with a cut with major premiss (n, ϕ) and conclusion (p, ψ). Suppose G contains a node (n0, ϕ), an R-node (n1, ϕ) and edges n1 −−d n0 and p −−d n1. The repeat-elimination at n0, n1,p is obtained by:
When an edge points to n1, redirect it to n0;
Remove n1.
Lemma 3.6 For G a DGU with a cut with major premiss (n, ϕ) and conclusion (p, ψ). Suppose G contains a node (n0, ϕ), an R-node (n1, ϕ) and edges n1 −−d n0 and p −−d n1, the repeat-elimination of at n0, n1,p is also a DGU.
Proof. By Lemma 2.6.	 
Definition 3.7 Let G be a DGU with a ∀-box B with eigenvariable u. Let v be a fresh variable. Then the renaming of u by v is the graph G in which the labels ψ of the nodes of B have been replaced by ψ[v/u].
Lemma 3.8 Let G be a DGU with a ∀-box B with eigenvariable u. Let v be a fresh variable. Then the renaming of u by v is a DGU.
Proof. By Lemma 2.6.	 
Definition 3.9 Let G be a DGU with a cut c with major premiss n. Suppose n is a box node of a box B and has k ≥ 2 ingoing edges, from p1,..., pk. Then the unsharing of G at nodes n, p1,... pn is obtained by:
making a box B' that contains a copy of all nodes and edges of B,

copy all outgoing edges of B to B' (thus if we had q −−d m with q ∈ B, q' ∈ B'
and m ∈/ B, then we add q' −−d m, where q' is the copy of q ∈ B',
letting p2,..., pk point to n' (the box node of B') instead of n;
renaming the eigenvariable of B' and of all boxes contained in B'.
Lemma 3.10 Let G be a DGU with a cut c with major premiss n. Suppose n is a box node of a box B and has k ≥ 2 ingoing edges, from p1,..., pk. Then the unsharing of G at nodes n, p1,... pn is a DGU.
Proof. By Lemma 2.6.	 
Definition 3.11
We have a depth-conflict in the DGU G, if G contains a cut with major premiss n and conclusion p at a greater depth, such that there is an arrow from p to n and that is the only arrow to n. In that case the incorporation of G at n, p is obtained by moving Bn, i.e. the box of n, into the box at the lowest depth that includes p but excludes n.
Lemma 3.12 Suppose G is a DGU with a depth conflict. Then the incorporation at the major premiss and the conclusion is a DGU.
Proof. By case analysis on the incorporating box. Then by Lemma 2.6.	 
Definition 3.13 Given a DGU G with a cut c, the process of →/∀-cut elimination
is the following;
(Repeat elimination) As long as there is no edge from the conclusion to the ma- jor premiss, perform the appropriate repeat-elimination as defined in Definition 3.5;
(Unsharing) If there is an edge from the conclusion to the major premiss, but this is not the only edge to the major premiss, perform an appropriate unsharing step, as defined in Definition 3.9;
(Incorporation) As long as the conclusion is at a greater depth than the major premiss, perform the appropriate incorporation step, as defined in Definition 3.11.
(Eliminating a safe cut) If c is safe, perform either the safe →-cut-elimination step, or the safe ∀-cut-elimination step, as defined in Definition 3.3.

Discussion
We have made some choices in the definition of DGUs that facilitate the process of cut-elimination. Except for the choice of the language, which has already been discussed in the Introduction, these are:
We deviate from the side-condition for the ∀-introduction rule as normally used in Fitch-style flag deduction, as discussed in the Introduction. (For deduction graphs, this reads as: “there is no edge pointing out of the box to a formula in which the eigenvariable occurs free.)

We require the uniqueness of the eigenvariables.
Suppose we would adopt the Fitch-style side-condition for the ∀-introduction rule, then this results in having to do an additional renaming in the incorporation step in some cases.
If we would abandon the requirement of unique eigenvariables and adopt the Fitch-style side-condition, this would move renaming from the unsharing step to the incorporation step.

Strong Normalisation
To obtain strong normalisation for cut-elimination on DGUs, we extend the λ-calculus with tupling as defined in [3], and prove strong normalisation for it. Then a reduc- tion preserving translation from DGUs to this calculus is defined.
The strong normalisation result we thus get is relatively weak: It is assumed that first one cut is made safe and is eliminated, before handling another cut.
For Gentzen-Prawitz natural deduction, strong normalisation for cut-elimination can be proven by (1) defining a →-cut preserving translation to the →-fragment and
(2) showing that an infinite ∀-cut reduction is impossible. That might also work for the DGU case, but (2) is now problematic, because a ∀-cut contraction may involve unsharing and then other ∀-cuts may be copied. We therefore opt for a direct proof of strong normalisation for cut-elimination for DGUs.
Definition 4.1 The typed expressions T⟨⟩ and types of the λ→⟨⟩-calculus for first order predicate logic with universal quantification are defined as follows.
For ϕ ∈ Form, all variables xϕ are of type ϕ.
If T is of type ϕ→ψ and S is of type ϕ, (TS) is of type ψ.
If T is of type ϕ, then λxψ.T is of type ψ→ϕ.
If T is of type ∀x.ϕ and t is a term, then (T t) is of type ϕ[t/x].
If T is of type ϕ, then λy.T [u := y] is of type ∀y.ϕ[y/u].
If T1,..., Tn are of types ϕ1,..., ϕn respectively, then
⟨T1,..., Tn⟩ is an expression of type ϕ1.
Definition 4.2 The reduction rules for the expressions are as follows: (λxσ.M )N −−>β¯ ⟨M, N⟩ if x ∈/ FV(M )
(λxσ.M )N −−>β¯ M [x := N ] if x ∈ FV(M )
(λy.M )t −−>β¯ M [y := t]
⟨M, P1,..., Pk⟩N −−>β¯ ⟨MN, P1,..., Pk⟩
⟨M, P1,..., Pk⟩t −−>β¯ ⟨Mt, P1,..., Pk⟩
N⟨M, P1,..., Pk⟩ −−>β¯ ⟨NM, P1,... Pk⟩
⟨..., ⟨M, P1,..., Pk⟩,.. .⟩ −−>β¯ ⟨..., M, P1,..., Pk,.. .⟩
As can be observed from the typing and the reduction rules, the N1,..., Nk

in ⟨M, N1,..., Nk⟩ act as a kind of ‘garbage’. The order of the typed expressions in N1,..., Nk is irrelevant and we therefore consider terms modulo permutation of these vectors, which we will write as ≡p.
Definition 4.3 Given a deduction graph G anda node n in G, we define the λ-term
⟨[G, n]⟩ as follows (by induction on the number of nodes of G).
A If (n, A) has no outgoing edges, ⟨[G, n]⟩ := xA,
→E If (n, B) −−d (m, A→B), and (n, B) −−d (p, A), define ⟨[G, n]⟩ := ⟨[G, m]⟩ ⟨[G, p]⟩.
R If (n, A) −−d (m, A), define ⟨[G, n]⟩ := ⟨[G, m]⟩
→I If (n, A→B) is a box node with (n, A→B) −−d (j, B), the free nodes of the box are n1,..., nk and the nodes without incoming edges inside the box are m1,..., mp, then
⟨[G, n]⟩ := λxA.⟨⟨[G, j]⟩, ⟨[G, m1]⟩,..., ⟨[G, mp]⟩⟩[xn := x,..., xn := x].
∀E If (n, ϕ[t/y]) −−d (p, ∀y.ϕ), define ⟨[G, n]⟩ := ⟨[G, p]⟩t.
∀I If (n, ∀y.ϕ[y/u])−−d(j, ϕ) and the nodes without incoming edges are m1,..., mp, then
⟨[G, n]⟩ := λy.⟨⟨[G, j]⟩, ⟨[G, m1]⟩,..., ⟨[G, mp]⟩⟩[u := y]
The interpretation of the deduction graph G, ⟨[G]⟩, is defined as ⟨⟨[G, r1]⟩, .. .,
⟨[G, rl]⟩⟩, where r1,..., rl are the top-level nodes without incoming edges in the deduction graph G.
Definition 4.4 A λ→⟨⟩-context is given by the following abstract syntax K[−]: K[−] := [−] | T⟨⟩K[−] | K[−]T⟨⟩
So a λ→⟨⟩-context is a λ→⟨⟩-term consisting only of applications (no abstrac- tions) with one open place. The following is by induction on K[−].
Lemma 4.5 For all λ→⟨⟩ contexts K[−] and λ→⟨⟩-terms M, N1,..., Nk
K[⟨M, N1,..., Nk⟩] −−−>−>β¯⟨K[M ], N1,..., Nk⟩.
Lemma 4.6 (∀ Cut-elimination is β¯-reduction in λ→⟨⟩)
If G' is obtained from G by a ∀-cut-elimination, then ⟨[G]⟩ −−−>−>+⟨[G']⟩.
Proof. By induction on the structure of G. Similar to the DG case.	 
Theorem 4.7 The process of cut-elimination is terminating for DGUs.
Proof. Analogous to the DG case.	 

Connection with Proof Nets
In [2] we have seen a correspondence between a variant of DGs and proof nets of MELL. We remarked that there are some superficial similarities between the two:

both have boxes and both enable sharing (contraction). Using this, we were able to define a translation from these deduction graphs to proof nets that preserves reduction.
In the way they handle quantification proof nets also seem fairly close to de- duction graphs. In the early days [4] boxes were used to delimit the scope of a quantification. Later (see for example [9]), this was put aside and replaced by global correctness criteria. It seems plausible that in deduction graphs too we could omit boxes for this use. We have not done this as deduction graphs serve another purpose than proof nets, and leaving out the ∀-boxes would make the deduction graphs less perspicuous. This discrepancy in the handling of quantification does
not seem to jeopardise the aim to extend the translation given in [2]: Because (∀x.ϕ)∗ =!(∀x.ϕ∗) (where ()∗ is Girard’s translation), it is the exponential box that should act like the ∀-boxes in deduction graphs anyway.
The main difficulty in both proof nets and deduction graphs is that during cut- elimination it is in some cases necessary to do a renaming. In anticipation to this, we have changed the ∀-introduction rule for deduction graphs and we have used two kinds of variables: one kind for bound uses, and one for free uses (see also [8]).
In [5], Girard discusses proof nets of MLL with quantifiers. Note that, as these proof nets do not include the exponential rules, this results in a simpler system. His approach is similar to ours. He replaces some free variables by constants, which reminds of our solution with two kinds of variables. He also insists on uniqueness of the eigenvariable. About renaming he says:
In practice, it would be crazy to rename bound variables (.. .).
Luckily, as there is no copying going on in the cut-elimination of MLL, renaming is nowhere necessary.
This changes when we shift our attention to MELL proof nets with quantifica- tion. The most complete study of this can be found in [9], and although it handles only second order quantification explicitly, it is generally assumed [4,9], that first order quantifiers do not provide additional difficulties. Instead of discriminating between different kinds of variables, in [9] an equivalence relation is defined on the formulas, making two formulas the same when one can be obtained from the other by renaming bound variables. Deviating from [9], this line might be pursued as
follows 4 :
Define formulas;
Define proof-structures;
Define the equivalence relation on formulas;
Extend the equivalence relation on proof-structures.
Once this has been done, it needs to be shown that after cut-elimination on a proof-net, one gets a proof-structure that is equivalent to a proof net.
This plan has two difficulties, the first being the exact definition of the equiva-

4 Personal communication Lorenzo Tortora de Falco.

lence relation on proof structures. Just saying that two proof structures are equiva- lent, when they have the same structure and when formulas at the same places are equivalent, would not suffice. In addition, it should also consider renaming of free variables in formulas that will get bound somewhere else in the structure.
Secondly, it could be rather complicated to find an equivalent proof-net after cut- elimination. This problem is very similar to the ones discussed in the Introduction. It is not at all clear how this renaming can be done for example after c-b-reduction (copying a box).
Another way out would be to extend the idea used in [5], similarly to deduction graphs: Change the ∀-rule and work with two kinds of variables. This might very well work.
Whence proof nets with quantifiers are defined properly and completely, it seems likely that we can define a reduction-preserving translation from DGUs to them.

Conclusions
We have shown that deduction graphs, a generalisation of both Gentzen-Prawitz natural deduction and Fitch-style flag-deduction, can be extended with universal quantification without having to alter or to extend the underlying structure, the so-called closed box directed graphs.
We have discussed the problems with renaming that arise when eliminating cuts in these graphs, and we have presented a solution to this.
We have studied the process of cut-elimination, which consists of repeat- elimination, unsharing (including renaming), incorporation, and safe cut- elimination. Furthermore, we have demonstrated that the process of cut-elimination is strongly normalising.
Finally, by pointing out similarities between deduction graphs and proof nets, we have indicated some future work in the latter area.

Acknowledgement
We thank the referees for their useful comments.

References
Gerhard Gentzen. Untersuchungen u¨ber das logische Schliessen. In M.E. Szabo, editor, Collected Papers of Gerhard Gentzen. North-Holland Publishing Company, 1969.
Herman Geuvers and Iris Loeb. From deduction graphs to proof nets: Boxes and sharing in the graphical presentation of deductions. In Rastislav Kr´aloviˇc and Pawel Urzyczyn, editors, MFCS, volume 4162 of Lecture Notes in Computer Science, pages 39–57. Springer, 2006.
Herman Geuvers and Iris Loeb. Natural Deduction via Graphs: Formal Definition and Computation Rules. Mathematical Structures in Computer Science (Special Issue on Theory and Applications of Term Graph Rewriting), Volume 17(03):485–526, 2007.
Jean-Yves Girard. Linear logic. Theor. Comput. Sci., 50:1–102, 1987.


Jean-Yves Girard. Quantifiers in linear logic II. In Giovanna Corsi and Giovanni Sambin, editors, Atti della Congresso: Nuovi Problemi della Logica e della Filosofia della Scienza, Vol. 2, pages 79–89. Bologna: CLUEB, 1991.
Iris Loeb. Natural Deduction: Sharing by Presentation. PhD thesis, Radboud Universiteit Nijmegen, 2007.
Dag Prawitz. Natural Deduction: a proof-theoretical study. Stockholm: Almqvist och Wiksell, 1965.
Richmond H. Thomason. Symbolic Logic: an Introduction. New York: Macmillan, 1970.
Lorenzo Tortora de Falco. R´eseaux, coh´erence et exp´eriences obsessionelles. PhD thesis, Universit´e Paris VII- Denis-Diderot, 2000.
