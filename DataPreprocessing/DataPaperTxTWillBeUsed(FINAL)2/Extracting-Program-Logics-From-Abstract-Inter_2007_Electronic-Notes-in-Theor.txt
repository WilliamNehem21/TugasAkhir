

Electronic Notes in Theoretical Computer Science 173 (2007) 339–356
www.elsevier.com/locate/entcs

Extracting Program Logics From Abstract Interpretations Defined by Logical Relations
David A. Schmidt
Computing and Information Sciences Dept.
Kansas State University Manhattan, KS 66506 USA

Abstract
We connect the activity of defining an abstract-interpretation-based static analysis with synthesizing its appropriate programming logic by applying logical relations as demonstrated by Abramsky. We begin with approximation relations of base type, which relate concrete computational values to their approximations, and we lift the relations to function space and upper- and lower-powerset. The resulting family’s properties let us synthesize an appropriate logic for reasoning about the outcome of a static analysis. The relations need not generate Galois connections, but when they do, we show that the relational notions of soundness and completeness coincide with the Galois-connection-based notions.
Keywords: Abstract interpretation, logical relation, Galois connection, temporal logic


Introduction
Static analysis — the automated extraction of program properties — relies upon a suitably chosen programming logic for stating and validating the properties. For example, the static analysis of a nondeterministic state-transition system typically employs a variant of dynamic [16] or Hennessy-Milner [18] logic to state and validate properties: for states, c ∈ C:
c |= p is given, for primitive properties, p, c |= [f ]φ, if for all c' ∈ f (c), c' |= φ
c |= ⟨f ⟩φ, if there exists c' ∈ f (c) such that c' |= φ
where f : C → P(C) denotes a nondeterministic transition function/action.

1 Supported by NSF ITR-0326577.
2 Email: schmidt@cis.ksu.edu



1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.02.042

From where does this logic arise? We can “deconstruct” the logic to discover its origin: first we untangle f from the universal/existential properties defined by [·] and ⟨·⟩. Let c ∈ C and S ⊆ C:

S |= ∀φ, if for all c ∈ S, c |= φ
S |= ∃φ, if there exists c ∈ S such that c |= φ c |= f ; φ, if f (c) |= φ
This exposes the set domains implicit in the original logic. Now, [f ]φ should be read as an abbreviation of f ; ∀φ.
This logic is itself an instance of another logic, where the universal quantifier quantifies disjunctions; there are conjunctions of existential quantifiers; and both domain and codomain properties of transfer functions can be described:

S |= ∀( i<k φi), if for all c ∈ S, there exists j < k such that c |= φj S |=  i<k(∃φi), if for all i < k, there exists c ∈ S such that c |= φi c |= f ; φ, if f (c) |= φ
f (c) |= f (φ), if c |= φ

This logic exposes that the set domains are lower- and upper-powerset constructions and distinguishes between function pre- and post-images. This paper will show that the last set of judgements are extracted from Plotkin-style logical relations for the types, PL(τ ), PU (τ ), and τ1 → τ2 [28]; the relations themselves generate a Cousot- Cousot-style abstract interpretation [1,7,8]:
We show how to define a static analysis based on abstract interpretation in terms of an approximation relation on base types, and we show how to lift the relation to compound types via logical relations, as first proposed by Abramsky [1].
We restate the coincidence between Galois-connection-based approximation and relational approximation regarding best approximation and soundness, and we extend the coincidence to functional completeness.
We show that every abstract domain has an internal logic, and we show how the logical relations generate logical operators within the internal logic.
When there are logical operators that do not fall within an abstract domain’s internal logic, we show how to approximate them soundly by means of an external logic generated with the aid of the logical relations.
We demonstrate how the generated external logic produces the above example logic.
Aside from its obvious debt to the abstract-interpretation theory of Cousot and Cousot [7,8,9,11], this paper builds on groundbreaking work by Abramsky [1], who



Fig. 1. Abstract interpretation: computing on properties

extracted approximation relations from abstraction maps on base type and gener- ated maps on higher type via logical relations; by Backhouse and Backhouse [4], who axiomatized many of Abramsky’s results within relational algebra; and by Dams [13], who applied abstract interpretation to a rigorous development of safety and liveness checking in abstract model checking.
The present paper’s contribution is its use of logical relations to generate a static analysis — even in the absence of Galois connections — and to synthesize a logic appropriate for reasoning about the results of the analysis.

Static analysis and logical properties
Figure 1 displays a small program and a Question: Upon termination, is the output a positive integer? Rather than exhaustively test the program to answer the question, we might employ a static analysis, which in the Figure uses an abstract domain of sign properties, Sign, as approximate values for computation. When the program’s transition functions, succ and pred, are abstracted to compute on Sign, we obtain an abstract interpretation of the program that can be applied to the abstract-test cases. The results, displayed in the Figure, let us conclude that an input of 0 results in a positive output, but the loss in precision within Sign prevents decisions for positive, negative, and arbitrary integer inputs. 3

3 If we improve Sign by adding the properties, ≤zero and ≥zero, then the improved definitions of succ and
pred will decide the Question for pos and neg as well.



Fig. 2. Galois connection between P(Int ) and Sign
Galois connections
Galois connections underlie most static analyses [7,20,26]: For complete lattices, (C, ⊆, ∪, ∩) and (A, ± , H , H ), a pair of monotone maps, α : C → A and γ : A → C, define a Galois connection, written C⟨α, γ⟩A for short, iff α ◦ γ ±A→A idA and γ ◦α ±C→C idC. 4 As we will see, Galois-connection structure lets us define precisely notions of sound, most-precise, and complete approximation of programs and logics. Figure 2 shows the Galois connection usually associated with the abstraction of integers by their signs, as used in Figure 1. The Galois connection in the Figure is a “completion” of the primitive abstraction relation, ρSign ⊆ Int × Sign, which
matches concrete values to their primitive logical properties [24].
Let n > 0 and define ρSign ⊆ Int × Sign as follows:
−n ρSign neg	+n ρSign pos
0 ρSign zero	m ρSign any , for all m ∈ Int
For example, +3 has property pos , because +3 ρSign pos .
Let A be a complete lattice (required for static analysis [20]) and C be a (partially ordered) set. For all c, c' ∈ C, for all a, a' ∈ A, a binary relation, ρ ⊆ C × A, is
U-closed iff cρ a and a ± a' imply cρ a'
GLB-closed iff cρ H{a | cρ a}

4 Equivalently stated, the functions α and γ form a Galois connection when, for all c ∈ C and a ∈ A, c ⊆C γ(a) iff α(c)±a. When the lattices are treated as categories and the functions are treated as functors, the Galois connection defines an adjunction [1].

L-closed iff cρ a and c' ± c imply c' ρ a
LUB-closed iff H{c | cρ a} ρ a.
U- and L-closure ensure the soundness of approximation relation ρ [9,24], and GLB- and LUB-closure ensure the existence of most precise abstractions (α) and con- cretizations (γ), respectively — we have that [1,4,36,38]
U-GLB-L-LUB-closed ρ ⊆ C × A deﬁnes the Galois connection,
C⟨αρ, γρ⟩A, where αρ(c)= H{a | cρ a} and γρ(a)= ∪{c | cρ a}.
Further, every Galois connection deﬁnes the U-GLB-L-LUB-closed relation,
cρ a iff c ⊆C γ(a) (iff α(c) ± a).
Every static analysis is based on an approximation relation, and most such relations possess U-GLB-L-LUB-closure (but not all, e.g., [9,23,41]). Relation ρSign ⊆ Int × Sign above (where Int is discretely ordered) is U-L-GLB-closed but not LUB-closed. In this case, the Galois connection in Figure 2 can be constructed by completing Int to P(Int ). We do so by “lifting” ρSign to logical relation ρL(Sign ), as explained in the section that follows.

Logical relations and Galois connections
Approximation relations on compound types are correctly defined by logical rela- tions [28]. For base types, b, function types, and lower and upper powerset types,
τ ::= b | τ1 → τ2 | L(τ ) | U (τ )
we define these domains:
Db is given (e.g., Int and Sign)
Dτ1 →τ2 = Dτ1 → Dτ2 , the partially ordered set of monotone functions from Dτ1
to Dτ2 . (Monotonicity suffices for static analysis [7].)
DL(τ) = PL(Dτ ), a lower powerset of Dτ , which is a collection of downclosed subsets of D that includes all ↓d for all d ∈ D, partially ordered by ⊆, and closed under ∩. 5 (This includes P↓(D), the collection of all downclosed subsets of D.)
DU(τ) = PU (Dτ ), an upper powerset of Dτ , which is a collection of upclosed subsets of D that includes all ↑d for all d ∈ D, partially ordered by ⊇, and closed under ∪. (This includes P↑(D), the collection of all upclosed subsets of D.)
The family of approximating logical relations is defined as usual, for ρτ ⊆ Cτ × Aτ :
ρb is given, for base type b (e.g., ρSign ⊆ Int × Sign)
f ρτ →τ f iff for all c ∈ Cτ and a ∈ Aτ ,c ρτ a implies f (c) ρτ f (a)
S ρL(τ ) T iff for all c ∈ S ∈ CL(τ ), there exists a ∈ T ∈ AL(τ ) such that c ρτ a S ρU (τ ) T iff for all a ∈ T ∈ AU (τ ), there exists c ∈ S ∈ CU (τ ) such that c ρτ a

5 S ⊆ D is downclosed if S = {d' ∈ D | ∃d ∈ S, d' ±D d}; for d ∈ D, ↓d = {d' ∈ D | d' ±D d}; S ⊆ D is
upclosed if S = {d' ∈ D | ∃d ∈ S, d ±D d'}; and ↑d = {d' ∈ D | d ±D d'}.





























Fig. 3. Approximation by powersets
The definitions read as expected, e.g., f ρτ →τ f asserts that function f is approxi-
1	2
mated by function f because arguments related by an approximation relation map
to answers related by an approximation relation. S ρL(τ) T defines an overapprox- imation relation: S is overapproximated by T because every element of S has an approximant in T . Dually, S ρU(τ) T defines an underapproximation relation, be- cause every element in T is witnessed by a concrete element in S. See Figure 3 for examples of set approximation, which propose logical readings of the relations on lower and upper powersets [27,39], reminiscent of the modal language proposed by Winskel [42], adapted to approximation. The lower-powerset approximation is an example of Abramsky’s safety adjunction, and the upper-powerset approximation is an example of his liveness adjunction [1].
Closure properties of logical relations
Proposition 4.1 For ρτ ⊆ Cτ × Aτ ,
ρL(τ ) and ρU (τ ) are L-closed; ρτ'→τ is L-closed iff ρτ is.
ρL(τ ) and ρU (τ ) are U-closed; ρτ'→τ is U-closed iff ρτ is.
If ρτ is U-GLB-closed, then so is ρL(τ); ρτ'→τ is U-GLB-closed iff ρτ is.
If ρτ is L-LUB-closed, then so is ρU(τ); ρτ'→τ is L-LUB-closed iff ρτ is.

Missing are assurances of LUB-closure for ρL(τ ) and GLB-closure for ρU (τ ); these depend on the specific powersets used. But we do have [36]
For any lower powerset, PA, of type PL(τ ), ρL(τ) ⊆ P↓(Cτ ) × PA is LUB-closed.
For any upper powerset, PC, of type PU (τ ), ρU (τ ) ⊆ PC ×P↑(Aτ ), is GLB-closed.
Using these results, we can build Galois connections from the logical relations, as needed. One standard trick is completing a U-GLB-closed relation, like ρSign ⊆ Int × Sign, where Int is discretely ordered, to U-GLB-L-LUB-closed ρL(Sign ) ⊆ P(Int ) × triv (Sign ), where lower powerset triv(Sign) = ({↓ a | a ∈ Sign}, ⊆) is order-isomorphic to Sign. This produces the Galois connection in Figure 2.

Functional soundness and completeness
Figure 1 showed that the concrete state-transition functions, succ : Int → Int and pred : Int → Int , must be abstracted to succ : Sign → Sign and pred : Sign → Sign to conduct a static analysis.
A function, f : Cτ → Cτ , is soundly abstracted by f : Aτ → Aτ , if f ρτ→τ f . This relational definition coincides with the classical definition of functional sound- ness from abstract interpretation [1,8,15]: If f ρτ→τ f is U-GLB-L-LUB-closed, then the following are equivalent:
f ρτ→τ f 
αρ  ◦ f ±C →A  f ◦ αρ
f ◦ γρ  ±A →C  γρ  ◦ f 
αρ and γρ are semi-homomorphisms with respect to f and f ; see Figure 4.
Given Galois connection, Cτ ⟨αρτ , γρτ ⟩Aτ , the most precise, sound abstraction

of f : Cτ → Cτ with respect to the Galois connection is f 
= αρτ
f ◦ γρτ  =

H{f  | f ρτ→τ f } [8]. As indicated by the last equality and Proposition 4.1, if ρτ lacks U-GLB-closure, then there is no Galois connection and no most-precise abstraction.
Exact preservation of f ’s mappings within A by f yields functional complete- ness; it is characterized in two independent ways:
When α acts as a homomorphism from f to f , then f is α(backwards)- complete for f [8,15].
When γ acts as a homomorphism from f to f , then f is γ(forwards)-complete
for f [14].

See Figure 4. If some f is (α- or γ-) complete for f , then so is f 
[15]. The

consequences of completeness are developed in the next section.
There is one important example of soundness: For a nondeterministic state transition system, (Σ, R ⊆ Σ × Σ), we characterize transition relation R as fR : Σ → P(Σ). Say there is an approximation relation, ρState ⊆ Σ × A, and an abstract transition system, (A, R ⊆ A × A), as used in “abstract model checking” [5,13]. Using the standard definition of simulation [18]: R ρState-simulates R iff for all

Functional soundness: f : A → A is sound for f : C → C iff
α ◦ f ± f ◦ α	iff	f ◦ γ ± γ ◦ f 

f
S	f(S)
	
#
 ( a )	f
	f #	

( S )  f
a	f #(a)

α and γ act as semi-homomorphisms.
Example: For succ : P(Int) → P(Int), succ(S)= {n +1 | n ∈ S}, succ is sound for succ.


γ(forwards)-completeness:
f ◦ γ = γ ◦ f 
α(backwards)-completeness:
α ◦ f = f ◦ α

 ( a )	f
	
f
S	f(S)
	

a	f #

f #(a)
( S )	f #

γ is a homomorphism from A to C: it preserves f as f .
α is a homomorphism from C to A: it preserves f as f .

Examples: For negate : P(Int) → P(Int), negate(S) = {−n | n ∈ S} and negate (neg ) = pos , negate (pos )= neg , etc., negate is α- and γ-complete for negate; in contrast, succ is neither α- nor γ-complete for succ; finally, square is α- but not γ-complete for square(S)= {n2 | n ∈ S}.
Fig. 4. Functional soundness and completeness expressed as semi- and full homomphisms
c, c' ∈ Σ, a ∈ A,
c ρState a and cR c' imply there exists a' ∈ A such that a R a' and c' ρState a',
we have that, if fR : Σ → P(Σ) and fR : A → PA are monotone, where PA is a lower powerset, then R ρState-simulates R iff fR ρState→L(State) fR .

A dual simulation, where Rb ρ−1
-simulates R, is characterized with upper

powersets as fR ρState→U(State) fRb  (cf. “liveness analysis” [1,13]).

Program logic
Given an abstraction, ρ ⊆ C × A, that generates a static analysis (e.g., Figures 1 and 2), we require an assertion language to define the properties that the static analysis must check and validate for program correctness or code improvement.
The simplest assertion language is merely the elements of A itself (e.g., Sign, as used in Figure 1), and its “logical semantics” is [[a]]ρ = {c | cρ a}, for each a ∈ A.
One immediate benefit is that every f : A → A that is sound for f : C → C is also a sound postcondition transformer for f with respect to the assertion language, A: for all a ∈ A and c ∈ C:
c ∈ [[a]]ρ implies f (c) ∈ [[f (a)]]ρ

Indeed, f 
is the strongest postcondition transformer for f in A.

A typical static analysis uses such A and f to compute postconditions for an abstracted program. At the program’s exit (or at a key internal program point), there is some assertion to check. Say the assertion is stated as aout ∈ A. Using cin ρ ain, the static analysis computes f (ain) and checks whether f (ain)±aout holds true. If yes, then f (cin) ∈ [[aout]]ρ holds by U-closure. This is how data-flow analysis, type checking, and program validation are usually implemented.
The previous technique is sound but “incomplete” (cf. Figure 1). We would prefer a decision procedure: Say that ρ ⊆ C × A is U-GLB-closed and define αρ : C → A as αρ(c)= H {a | cρ a}, that is, αρ maps c to its best approximant. We say that f ρ-decides f if, for all c ∈ C, a ∈ A,
f (αρ(c)) ± a iff f (c) ∈ [[a]]ρ
This means all f ’s A-logical properties can be decided by f within A. When ρ
defines a Galois connection, decidability coincides with αρ-functional completeness:

Proposition 6.1 For U-GLB-L-LUB-closed ρ, f ρ-decides f iff f is αρ-complete for f.
This is why α-completeness is important in practice.

Internal logic
Assertion language A possesses an internal logic in the sense that there exist logical connectives that are expressed as functions on A. Here is an important example.
If ρ ⊆ C × A is U-GLB closed, then H : A × A → A is logical conjunction in A: for all c ∈ C, a0, a1 ∈ A:
c ∈ [[a0 H a1]]ρ iff c ∈ [[a0]]ρ and c ∈ [[a1]]ρ
This expands the assertion language based on A to
φ ::= a | φ H φ,  for all a ∈ A,
and we can employ the usual inference rules for conjunction. For example, in Figure 2, H is conjunction, and we can assert, say, 2 ∈ [[any H pos ]]ρSign . Most important, when a logical connective exists in A’s internal logic, we can soundly check it within
A: For conjunction, if a static analysis verifies that aout ± φ1 H φ2, then we safely conclude, for all cρ aout, that c ∈ [[φ1]]ρ and c ∈ [[φ2]]ρ.
Not all propositional connectives exist: For Figure 2, disjunction fails, because
0 ∈ [[any ]]	= [neg H pos ]]	, yet 0 /∈ [[neg ]]	and 0 /∈ [[pos ]]	. 6	Thus,
Sign	Sign	Sign	Sign
zero ± neg H pos does not imply 0 ∈ [[neg ]]ρSign or 0 ∈ [[pos ]]ρSign .
The previous definition of conjunction is somewhat informal; a more precise statement reads
[[ H (a0, a1)]]ρ = and ([[a0]]ρ, [[a1]]ρ)

6 If disjunction would exist in Sign, it must equal H .

where and : P(C ) × P(C ) → P(C ) is ∩. This makes clearer that the connective,
and , is expressed in A by H .
For k-ary logical connective, f : P(C)k → P(C), and k-ary function f  : Ak →
A, we say that f ρ-expresses f if
[[f (ai)i<k ]]ρ = f ([[ai]]ρ)i<k
(See the conjunction example, where f = and and f = H .)
We connect this notion to functional completeness: For ρ ⊆ C × A, define ρ ⊆ P(C) × A as S ρ a iff for all c ∈ S, cρ a. 7 ρ is L-LUB-closed, hence γρ : A → P(C) is γρ(a)= ∪{S | S ρ a} = {c | cρ a} = [[a]]ρ.
Proposition 6.2 When ρ ⊆ C × A is U-GLB-closed, f : A → A ρ-expresses f : P(C) → P(C) iff f is γρ-complete for f.
This is why γ-completeness is important in practice.

Logical relations generate logical connectives
Starting from base type, τ , and approximation relation, ρτ ⊆ Cτ × Aτ , we use the logical relations on compound types to generate logical operators in assertion language Aτ .
Please review the definition of lower powerset from the start of Section 4; recall, for a concrete lower powerset PL(Cτ ) and an abstract lower powerset PL(Aτ ), for downclosed sets S ∈ PL(Cτ ) and T ∈ PL(Aτ ), that
S ρL(τ ) T iff for all c ∈ S, there exists a ∈ T such that c ρτ a
Downclosed sets in PL(Aτ ) might be written as expressions, ↓{ai}i<k. We treat ↓ as if it were a k-ary logical connective for the ais: ↓{·} : Aτ k → PL(Aτ ), defining its semantics from the logical relation:
[[↓{ai}i<k ]]ρ	= {S' ∈ PL(Cτ ) | for all c ∈ S', there is j < k such that c ∈ [[aj ]]ρ }
= fL{[[ai]]ρτ }i<k,
where fL : P(Cτ )k → P(PL(Cτ )) is defined
fL{Si}i<k = {S' ∈ PL(Cτ ) | for all c ∈ S', there exists j < k such that c ∈ Sj}
By definition, ↓ ρL(τ )-expresses fL. What’s more, we can use ↓ to ρτ -express disjunction: Define
c ∈ [[ i<k{ai}]]ρτ  iff ↓c ∈ [[↓{ai}i<k]]ρL(τ )
iff there exists some j < k such that c ∈ [[aj ]]ρτ
This requires that ρτ be U-L-closed. The use of a lower powerset to express dis- junction is known as the disjunctive completion of ρτ , where PL(A)= P↓(A) [15].

7 This is the trick described at the end of Section 4 for “lifting” a relation to make it L-LUB-closed.

We can soundly check disjunction in Aτ : we check that ↓ a ± ↓{ai}i<k, that is, we check whether there exists some j < k such that a ± a ; this implies c ∈ [[ i<k{ai}]]ρτ , for all c ρτ a. This is hardly a surprise, but it shows that one must steer to lower-powerset constructions to express disjunction in a static analysis.
Dually, we use the logical relation on upper powersets to express conjunction (when ρτ is not already U-GLB-closed):
[[↑{ai}i<k]]ρ	= fU {[[ai]]ρ }i<k, where fU : P(Cτ )k → P(PU (Cτ )) is defined
fU {Si}i<k = {S' ∈ PU (Cτ ) | for all i < k, there exists c ∈ S' such that c ∈ Si}
By definition, ↑ ρU (τ )-expresses fU , and we define conjunction in Aτ as
c ∈ [[  i<k{ai}]]ρτ iff ↑c ∈ [[↑{ai}i<k]]ρU (τ ) iff for all i < k, c ∈ [[ai]]ρτ
The logical relation for τ1 → τ2 does not readily surrender a logical connective.
From
f ρτ →τ f iff for all c ∈ Cτ , a ∈ Aτ ,c ρτ a implies f (c) ρτ f (a) we define merely a higher-order constant,
[[f ]]	= {f ∈ Cτ → Cτ | for all c ∈ Cτ , a ∈ Aτ ,
1	2
c ∈ [[a]]	implies f (c) ∈ [[f (a)]]	}
τ1	τ2
We must work to extract a logical connective for ρτ1 and one for ρτ2 . For the latter, we propose the postimage function, post f : P(Cτ1 ) → P(Cτ2 ), which we hope to express by some f :
[[f (a)]]	= post f [[a]]	, where postf (S)= {f (c) ∈ Cτ | c ∈ S}
2	1
By Proposition 6.2, we know that an f : A → A ρ-expresses post f iff f is γρ- complete for post f .
A logical connective that defines function preimage is defined as

 pre
; a]]

ρτ1
= p˜ref [[a]]

ρτ2
, where p˜ref (S)= {c ∈ Cτ1
| f (c) ∈ S}

Say we have some f : A → A such that f ρτ →τ f . To express p˜ref : P(C) →
P(C), we want some f	: A → PL(Aτ ), and the obvious candidate is

 pre
(a) = {a' | f (a') ± a}

If ρτ2
is U-closed, then we have soundness: 8
p˜re f
ρτ1→L(τ2)
pre.

Proposition 7.1 For f : Cτ → Cτ and f : Aτ → Aτ if ρτ is U-GLB-closed and

f is αρ
-complete for f, then f 
ρL(τ )
-expresses p˜re f .



When f 
ρL(τ )
-expresses f

pre
, we check a' ∈ f 
(a), that is, f (a') ± a, to validate

that c' ∈ p˜re f [[a]]ρ
, for all c' ρτ a'.




8 In Abramsky’s terminology [1], f 
defines a safety relation.



Fig. 5. Concrete external logic based on logical relations

External logics
Returning to the example in Figures 1 and 2, we see that neither succ and pred are α- or γ-complete for their respective concrete functions. So, we cannot express the post f and pre f connectives, for f ∈ {succ, pred}, and soundly check them within Sign.
This situation is the rule, rather than the exception — it is almost impossible to define an abstract domain that admits completeness for all the transition functions embedded in a program. For this reason, we must study how to define a less precise, “external” logic for A that admits sound checking of logical operators that might not be expressible in A’s internal logic.
Figure 5 displays the logic we have in mind, which consists of the operators extracted from the logical relations.
Program properties are defined by the judgements, e.g., 2 |=Sign pos , succ(2) = 3 |=Sign succ(pos ), {0, 3} |=L(Sign ) succ(pos ) ∨ zero, 0 |=Sign succ; pos , and so on.
To check |=τ via an abstract interpretation, we must
supply an abstract domain, Aτ , for each concrete domain, Cτ

supply f : Aτ
→ Aτ2
for each concrete transition function, f : Cτ1
→ Cτ2 , such

that f ρτ →τ f .
1	2



Fig. 6. Abstract external logic
Given the output, aout ∈ Aτ , of a program’s static analysis, we attempt to validate judgements of form, aout |=A φ, where abstract judgements based on |=A are defined
τ	τ
in Figure 6. We require that |=A is sound for |=τ : for all φ and a ∈ Aτ ,
a |=A φ implies c |=τ φ, for all c ρτ a
When the above implication is strengthened to an equivalence, we have a form of logical completeness known as best preservation [11,34]: for all a ∈ Aτ ,
a |=A φ iff c |=τ φ, for all c ρτ a
Another form of completeness is stated in terms of concrete values and is known as
strong preservation [29]: for all c ∈ Cτ ,
c |=τ φ iff there exists a ∈ Aτ such that a |=A φ and c ρτ a
The two completeness forms are independent [14]. Returning to Figures 5 and 6, we have this result:
Theorem 8.1 For all τ, |=A in Figure 6 is sound for |=τ in Figure 5.
Missing from Figure 6 is a judgement form for f (φ), the postimage judgement.

The reason is that the naive formulation, namely, f (a) |=A
f (φ), if a |=A
φ, for

f ρτ →τ
f , is unsound. For example, any = succ (pos ) |=A
succ(pos ). Since

1	2	Sign
−2 ρSign any , the abstract judgement appears to imply that −2 |=Sign succ(pos ),
which fails.	The problem is that succ  overestimates the postimage defined by

post succ, whereas the judgement, f (pos ) |=A
succ(pos ) requires an f that un-

derestimates it.
There is a repair, but it is not trivial [35]: First, treat a concrete transition function, f , to have arity, f : C1 → P(C2). 9 Then, define f −1 : C2 → P(C1) as f −1(c) = {d ∈ C1 | c ∈ f (d)}. This means (f −1)−1 = f , and more importantly, that post f = pre f −1 [22]. The preimage function, preg : P(C1) → P(C2), for g : C2 → P(C1), is defined
preg (S)= {c | g(c) ∩ S /= ∅}
Recall from Figure 3 that the upper-powerset construction defines an ab-

9 Indeed, this representation is the usual one for nondeterministic state-transition relations.

stract domain of sets that witness concrete values.  For S ρU (r ) T , the set, T  = {a0, a1, ··· , ai, ·· ·} ∈ PU (A), asserts existence of concrete values,
{c0, c1, ··· , ci, ·· ·} ⊆ S ∈ P(C), such that ci ρ ai, for i ≥ 0. An upper powerset is the appropriate abstract domain for underapproximating a concrete function’s image: For f : Cr → P(Cr ) and fb : Ar → PU (Ar ) such that f ρr →U (r ) fb, we know that f (c) ρU(r ) fb(a), for c ρr a, meaning that every a ∈ fb(a) has a witness c ∈ f (c).
We have this soundness result for approximating function preimages: 10
Lemma 8.2 Assume there exist two sets, Tφ ⊆ Ar2 and Sφ ⊆ Cr2 , such that for all a ∈ Ar , c ∈ Cr , if a ∈ Tφ and c ρr2 a, then c ∈ Sφ.
Then, for f : Cr → PU (Cr ) and fb : Ar → PU (Ar ) such that f ρr →U (r ) fb, for all a ∈ Ar1 , c ∈ Cr1 ,
c ρr1 a and a ∈ pre ƒb (T ) imply c ∈ preƒ (S).
Using the relationship, post ƒ = pre ƒ−1 , we apply Lemma 8.2 to fill the gap in Figure 6: Recall from Figure 5 that
c |=r f (φ), if there exists c' ∈ Cr such that c ∈ f (c') and c' |=r φ
iff c ∈ post ƒ {c' | c' |=r φ}
iff c ∈ pre ƒ −1 {c' | c' |=r φ}
Now, add this abstract judgement to Figure 6 (assuming f −1 ρr →U (r ) fb):


a |=A
f (φ), if a ∈ pre
ƒb {a' | a' |=A φ}

iff there exists a' ∈ Ar  such that a' ∈ fb(a) and a' |=A φ
By Lemma 8.2, Theorem 8.1 is preserved. 11
We finish with some known results regarding expressibility and completeness for
external logics. First, we write [[φ]]r to denote {c | c |=r φ} (similarly for [[φ]]A). We
can relate the sets, [[φ]]r and [[φ]]A, by means of the Galois connection, (P(Cr ), ⊇
)⟨αu, γ⟩(P↓(Ar ), ⊇) [34], where γ(T ) = ∪a∈T γ(a) and αu(S) = {a | γ(a) ⊆ S},
where γ(a)= {c | c ρr a}. We have that

|=A is best-preserving for |=r iff αu[[φ]]r
= [[φ]]A [34]

|=A is strongly-preserving for |=r iff [[φ]]r
= γ[[φ]]A [30]

The abstract external logic, |=A, achieves completeness for |=r when each of its logical operators possess completeness: First, rewrite each concrete judgement form in the format,
c |=r opƒ (φi)i<k, if c ∈ f ([[φi]]ri )i<k,

10 In Abramsky’s terminology [1], pre ƒ b defines a liveness relation.
11 Here is an obvious question: Why not approximate ƒ : Cr1 → P(Cr2 ) by some ƒb : Ar1 → PU (Ar2 ) and approximate post ƒ by post ƒ b ? As shown in [35], post ƒ b is antimonotone and unsound for underapproximing function postimage.

for k-ary logical operator, f : P(Cr )k → P(Cr ) (similarly for |=A). When the
i	r
logical relations, ρr , define Galois connections, we have these results:
The abstract judgement set, |=A, that proves the most sound properties for con- crete judgement set, |=r , is the one that approximates each concrete logical op-
erator, f : P(Cr )k → P(Cr ), by f	: P↓(Ar )k → P↓(Ar ) [6,13,36]
i	best	i

|=A is best-preserving for |=r if each abstract logical operator, f , is αρ
-complete

r
for each concrete logical operator, f [11].
|=A is strongly-preserving for |=r if each f is γρ
r


-complete for f [29].

r	r

Conclusion
This paper showed how to extract an appropriate programming logic from a logical- relation family that also defines a static analysis. Figure 6 displays the logic that results from a classical family of logical relations. As noted in the Introduction, a variety of logics stem from the setup in Figure 6: First, it is common to limit the set-conjunction and set-disjunction connectives to one argument each, giving this logic:
a |=A a', if a ± b a'

A
L(r )
A
U (r )
∀φ, if for all a ∈ T, a |=A φ
∃φ, if there exists a ∈ T such that a |=A φ

a |=A
f ; φ, if f (a) |=A
φ, for f ∈ Ar
→ Ar2

If we hide the typings attached to the judgements, which is usually done, then we restrict the logic to judgements on base type — we do so by applying the operator for function preimage to the ones for disjunction and conjunction:
a |=A f ; ∀φ, if for all a' ∈ f (a), a' |=A φ, for f ∈ Ar → PL(Ar )
a |=A f ; ∃φ, if there exists a' ∈ fb(a) such that a' |=A φ, for fb ∈ Ar → PU (Ar )
We can abbreviate d |=r f ; ∀φ by d |=r ∀f.φ (as in description logic [3]), or by [f ]φ (Hennessy-Milner logic [18]), or by φ when the system studied has only one transition function (CTL [5]). Similarly, d |=r f ; ∃φ is abbreviated by d |=r ∃f.φ, or by ⟨f ⟩φ, or merely by  φ.

History and related work
Galois connections were first proposed by Patrick and Radhia Cousot as a formal- ization of program data-flow and static analysis [7]; the Cousots also defined the notion of best approximation of a transfer function [8]. The notion of a functionally complete approximate transfer function was proposed by Giacobazzi, et al. [14,15]. The lifting of Galois connections from base type to higher types was studied by Nielson [25] and the Cousots [10]. The characterization of a Galois connection by

an approximation relation came from Shmuely [38] and Hartmanis and Stearns [17]. Mycroft and Jones connected the approximation relation to the soundness of static analysis [24], and the idea was formalized by Schmidt [32,33].
Abramsky formalized the connection between approximation relations and log- ical relations within category theory, and his paper [1] provided a categorical for- mulation where Kan extensions are used to characterize the notion of best approx- imating transition function. Backhouse and Backhouse adapted Abramsky’s ideas to relational algebra [4].
Abramsky also defined Scott-domain theory in “logical form” [2], where domains are generated from a set of primitive propositions such that each domain element is a collection (conjunction) of the propositions that hold true for it. Jensen adapted this formulation to define “abstract interpretation in logical form” [19], where an abstract interpretation is defined as collecting some fixed subset of the primitive propositions used to generate the concrete-domain elements. This provides a simple characterization of completeness as the collection of all the propositions contained in a concrete-element’s denotation.
Abramsky’s and Jensen’s efforts are the first towards extracting program log- ics from semantic domains, but in general, the connection between abstract- interpretation domains and logics for program validation is ill-developed (hence, this paper). The traditional logic used with an abstract-interpretation domain is a conjunction of primitive propositions (Jensen’s “conjunctive logic” [19]), called in this paper the domain’s internal logic.
Steffen was the first to observe a connection between branching-time temporal logic and the format of standard data-flow analysis problems [40] — a connection used by Schmidt in his slogan: “data-flow analysis is model checking of abstract interpretations” [31,37]. Lacey, et al. built on this idea to define both the static analysis and the program transformation triggered by its results in terms of a tem- poral logic enriched by Prolog-style logical variables [21], reinforcing the intuition that there exists a fundamental connection between temporal logic and abstract- interpretation domains.
One of the most striking pieces of evidence for this connection was produced by Dams, who showed how software “abstract model checking” could be formalized by means of sound abstract interpretations using domains of overapproximating (“may”) and underapproximating (“must”) denotations [12,13]. Schmidt formalized Dams’s constructions within a theory of Galois connections generated from logical- relation-based, lower- and upper-powerset abstract domains [33,35,36].
The present paper combines these threads of work.

Acknowledgement
In 1982 at Edinburgh University, I learned about powerdomains and logical re- lations from Gordon Plotkin’s lectures and notes. The present work stems from that education and has benefitted from interactions with Radhia and Patrick Cousot, Roberto Giacobazzi, Michael Huth, Isabella Mastroeni, Francesco Ran-

zato, and Francesco Tapparo.

References
S. Abramsky. Abstract interpretation, logical relations, and Kan extensions. J. Logic and Computation, 1:5–41, 1990.
S. Abramsky. Domain theory in logical form. Ann.Pure Appl.Logic, 51:1–77, 1991.
F. Baader, et al. The Description Logic Handbook. Cambridge Univ. Press, 2003.
K. Backhouse and R. Backhouse. Galois connections and logical relations. In Mathematics of Program Construction, LNCS 2386. Springer Verlag, 2002.
E.M. Clarke, O. Grumberg, and D.A. Peled. Model Checking. MIT Press, 2000.
R. Cleaveland, P. Iyer, and D. Yankelevich. Optimality in abstractions of model checking. In Proc. SAS’95. Springer LNCS 983, 1995.
P. Cousot and R. Cousot. Abstract interpretation: a unified lattice model for static analysis of programs. In Proc. 4th ACM Symp. on Principles of Programming Languages, pages 238–252. ACM Press, 1977.
P. Cousot and R. Cousot. Systematic design of program analysis frameworks. In Proc. 6th ACM Symp. on Principles of Programming Languages, pages 269–282. ACM Press, 1979.
P. Cousot and R. Cousot. Abstract interpretation frameworks. J. Logic and Computation, 2:511–547, 1992.
P. Cousot and R. Cousot. Higher-order abstract interpretation. In Proceedings IEEE Int. Conf. Computer Lang., 1994.
P. Cousot and R. Cousot. Temporal abstract interpretation. In Proc. 27th ACM Symp. on Principles of Programming Languages, pages 12–25. ACM Press, 2000.
D. Dams. Abstract interpretation and partition refinement for model checking. PhD thesis, Technische Universiteit Eindhoven, The Netherlands, 1996.
D. Dams, R. Gerth, and O. Grumberg. Abstract interpretation of reactive systems. ACM Trans. Prog. Lang. Systems, 19:253–291, 1997.
R. Giacobazzi and E. Quintarelli. Incompleteness, counterexamples, and refinements in abstract model checking. In Static Analysis Symposium, LNCS 2126, pages 356–373. Springer Verlag, 2001.
R. Giacobazzi, F. Ranzato, and F. Scozzari. Making abstract interpretations complete. J. ACM, 47:361–416, 2000.
D. Harel, D. Kozen, and J. Tiuryn. Dynamic Logic. MIT Press, 2000.
J. Hartmanis and R.E. Stearns. Pair algebras and their application to automata theory. J. Information and Control, 7:485–507, 1964.
M.C.B. Hennessy and Robin Milner. Algebraic laws for non-determinism and concurrency. JACM, 32:137–161, 1985.
T. Jensen. Abstract Interpretation in Logical Form. PhD thesis, Imperial College, London, 1992.
N. Jones and F. Nielson. Abstract interpretation: a semantics-based tool for program analysis. In
S. Abramsky, D. Gabbay, and T. Maibaum, editors, Handbook of Logic in Computer Science, Vol. 4, pages 527–636. Oxford Univ. Press, 1995.
D. Lacey, N.D. Jones, E. VanWyk, and C.C. Frederiksen. Compiler optimization correctness by temporal logic. J. Higher Order and Symbolic Comp., 17:173–206, 2004.
C. Loiseaux, S. Graf, J. Sifakis, A. Bouajjani, and S. Bensalem. Property preserving abstractions for verification of concurrent systems. Formal Methods in System Design, 6:1–36, 1995.
A. Min´e. The octagon abstract domain. J. Higher-Order and Symbolic Computation, 19:31–100, 2006.
A. Mycroft and N.D. Jones. A relational framework for abstract interpretation. In Programs as Data Objects, LNCS 217, pages 156–171. Springer Verlag, 1985.
F. Nielson. Two-level semantics and abstract interpretation. Theoretical Computer Science, 69(2):117– 242, 1989.

F. Nielson, H.R. Nielson, and C. Hankin. Principles of Program Analysis. Springer Verlag, 1999.
G. Plotkin. Domains. Lecture notes, Univ. Pisa/Edinburgh, 1983.
G. D. Plotkin. Lambda-definability in the full type hierarchy. In J. Seldin and J. Hindley, editors, To H.
B. Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, pages 363–374. Academic Press, 1980.
F. Ranzato and F. Tapparo. Strong preservation as completeness in abstract interpretation. In Proc. European Symp. Programming, LNCS 2986, pages 18–32. Springer Verlag, 2004.
F. Ranzato and F. Tapparo. Strong preservation of temporal fixpoint-based operators by abstract interpretation. In Proc. Conf. VMCAI’06, LNCS 3855, pages 332–347. Springer Verlag, 2006.
D.A. Schmidt. Data-flow analysis is model checking of abstract interpretations. In Proc. 25th ACM Symp. on Principles of Prog. Languages. ACM Press, 1998.
D.A. Schmidt. Structure-preserving binary relations for program abstraction. In The Essence of Computation, LNCS 2566, pages 246–266. Springer Verlag, 2002.
D.A. Schmidt. Closed and logical relations for over- and under-approximation of powersets. In Symp. Static Analysis (SAS’04), LNCS 3148, pages 22–37. Springer Verlag, 2004.
D.A. Schmidt. Comparing completeness properties of static analyses and their logics. In Asian Symp. Prog. Lang. Systems (APLAS’06), LNCS 4279, pages 183–199. Springer Verlag, 2006.
D.A. Schmidt. Underapproximating predicate transformers. In Proc. Symp. Static Analysis (SAS’06), LNCS 4134, pages 127–143. Springer Verlag, 2006.
D.A. Schmidt. A calculus of logical relations for over- and underapproximating static analyses. Science Comp. Programming, 64:29–53, 2007.
D.A. Schmidt and B. Steffen. Data-flow analysis as model checking of abstract interpretations. In
G. Levi, editor, Proc. 5th Static Analysis Symposium. Springer LNCS 1503, 1998.
Z. Shmuely. The structure of Galois connections. Pacific J. Mathematics, 54:209–225, 1974.
M. Smyth. Powerdomains. Journal of Computer and System Sciences, 16:23–36, 1978.
B. Steffen. Generating data-flow analysis algorithms for modal specifications. Science of Computer Programming, 21:115–139, 1993.
A. Venet. Automatic determination of communication topologies in mobile systems. In Symp. Static Analysis (SAS’98), pages 152–167. Springer Verlag, 1998.
G. Winskel. On powerdomains and modality. Theor. Comput. Sci., 36:127–137, 1985.
