Electronic Notes in Theoretical Computer Science 212 (2008) 27–40	
www.elsevier.com/locate/entcs
Separation Logic for Multiple Inheritance
Chenguang Luo1
Department of Computer Science Durham University
Durham DH1 3LE, United Kingdom
Shengchao Qin2
Department of Computer Science Durham University
Durham DH1 3LE, United Kingdom

Abstract
As an extension to Floyd-Hoare logic, separation logic has been used to facilitate reasoning about imperative programs manipulating shared mutable data structures. Recently, it has also been extended to support modular reasoning in Java-like object-oriented languages where only single inheritance is allowed. In this paper we propose an extension of separation logic to support also the reasoning for multiple inheritance in C++ -like languages. To cater for multiple inheritance, we modified the standard storage model for separation logic in a way that the correct reference to a field or a method can be easily determined. On top of this storage model, a set of proof rules are proposed. Our verification system also provides basic support for behavioral subtyping.
Keywords: Multiple Inheritance, Separation Logic, Verification


Introduction
Object-oriented programming languages offer a significant means to create software in a modular way. The mechanisms of inheritance and encapsulation allow program modules to provide sufficient information for others to make use of them, meanwhile hiding implementation details. This characteristic is excellent for code reuse and management, but it also calls for new formal approaches to reasoning about and verifying these OO programs.
Separation logic [14,3,15] has been proved to be an effective way to reason about pointer- and heap-related imperative programs. It brought forward a new concept

1 Email: chenguang.luo@durham.ac.uk
2 Email: shengchao.qin@durham.ac.uk

1571-0661© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.051

in the runtime storage model, viz. the heap, and enhanced the expressiveness of Hoare logic over this model. The new logic operators it has introduced, separation conjunction and implication, not only specify explicitly that some part of the heap is disjoint from another part, but also allow local reasoning about pointers and heaps. This feature provides great support for modular reasoning, since each module’s behavior can be held in the variables that it accesses (its so-called “footprint”). As a result, separation logic is an excellent tool for OO program verification.
Due to the fair properties of separation logic for OO verification, in this paper we propose an extension of separation logic to reason about programs written in a C++ -like object-oriented language with multiple inheritance. To achieve this ob- jective, there are two main issues to deal with. The first is to extend the syntax and semantics of separation logic with method definitions and invocations, and (mul- tiple) class inheritance, since the classical separation logic concentrates mostly on simple process-based languages. The second is to treat class inheritance and object polymorphism appropriately in the extension so as to cope with inherited classes and overridden methods. This paper’s contribution mainly resides in the first aspect, that is, it introduces the syntactical constructs and related semantics of multiple inheritance into a modularized separation logic, and formalizes the assertions and verification rules accordingly. For the second aspect, we follow Liskov’s behavioral subtyping ([4,7]) directly to make our work form a whole verification system for OO programs with multiple inheritance.
The remainder of this paper is organized as follows. Next section sets up the syntax of the C++ -like language used throughout this paper, and its semantics of class inheritance and method overriding in a syntactical way. Then the separation logic for this language is introduced, with the storage model expressing the program states, the assertion language and its semantics, and the verification rules. After that our approach of forcing behavioral subtyping is brought out, followed by an example to illustrate this model for multiple inheritance verification, and the last section summarizes the paper with related and future works.






An OO language with multiple inheritance

A core C++

Previous works on separation logic for object-oriented languages were mainly about languages supporting single inheritance, such as Java. This section’s aim is to provide a kernel part of C++ which supports multiple inheritance of classes.
First we exhibit this core of C++ for verification.  Any s means a (possibly

empty) sequence of s.

prog := cdef;
cdef := class C : C'{fdef mdef}
mdef := [virtual] C ∗ m(C1 ∗ x1,..., Cn ∗ xn){s return x; }
fdef := C ∗ f ;
e	:= x | x→C::f | null | this
s	:= x=y→C::f ; | x=(C∗)y; | x=new C(); | delete x; | x→C::f =e; |
x=y→C::m(e); | C ∗ x; | {s} | ; | if (e == e) s else s

This core language includes features such as class definitions, multiple inher- itance, polymorphism and method overriding. Other features comprise field and variable definitions, the initialization and recycling of objects, variable assignment, and conditional constructs.
To keep the formalism simple, we leave out other C++ features that are of less interest. Since separation logic is mainly about the aliases and mutation of pointers to heap, all the variables in this core are assumed to be pointers. Arithmetic expressions and some other language constructs are also omitted. These features are to be added to our concern step by step in our future works towards practical implementation of this system.
Some of C++’s original semantics is also changed. For any field or variable x, as we do not focus on dangling pointers in this paper, it is assumed that x = null if x is initially defined or later deleted. This aspect will be explored later.
At last are some conventions for the remainder of the paper. To traverse the class names, we use C and D with proper subscripts. For class fields and methods, f and m are used respectively. For general variables x (and sometimes y) is used. And for any tuple a, we denote a.i as the i-th component of a.

Semantics for inheritance
Before the introduction of the semantics for program’s execution, this section will bring about the semantics for multiple inheritance of our core C++ in a syntactical way, as a foundation of further runtime semantics.
As is in C++, the inheritance of classes is expressed in the class definition

class C : C1, C2,..., Cn{fdef mdef}
carrying the meaning that C is a subclass of C1, C2,..., Cn. In this case we denote C ≺ Ci and it is clear that they form a partial order among these classes. There is a synonym of this inheritance relationship that, assuming C has a fields list f1,..., fm defined in its body, and each Ci has a fields list fi,1,..., fi,mi , then C’s complete
fields list is f1,..., fm, C1::f1,1,..., C1::f1,m1 ,..., Cn::fn,mn . And this situation also
applies to method inheritance.
This multiple inheritance, like C++, does not require all fields’ and methods’ names are distinct. Actually identical names of fields and methods are the very way

to promote dynamic polymorphism. However, it can also cause ambiguity when we refer to some fields of an object. For this issue we take the former inheritance class C : C1,..., Cn and an object x typed C to describe the following cases:
A field named f which is only defined in C1. Then the reference x→f is equal to x→C1::f . And any other class indirectly inheriting C1, without f defined, can refer to x→f equally as x→C1::f .
A field named f which is defined only in both C and C1. Then the references x→f
and x→C1::f might be distinct. This is similar as the case in single inheritance.
A field named f which is defined only in both C1 and C2. Then the reference x→f is invalid, and the two f ’s that are overridden must be referred to with explicit specification x→C1::f and x→C2::f . This also applies to other classes (indirectly) inheriting C. This case is unique in multiple inheritance and analogous as C++.
A field named f which is defined only in C, C1 and C2. Then all the references x→f, x→C1::f and x→C2::f are distinct. This is also the C++ case, unique in multiple inheritance.
These rules are applicable for methods overriding as well, except for two issues. First, both the method names and the parameter types are criteria to judge “iden- tical names” of methods. Second, unlike fields, only virtual methods (defined with prefix “virtual”) can be overridden.
Followed is the semantics of access to indirectly inherited fields and methods. Assume we have a chain of inheritance relationship C ≺ D1 ≺ D2 ≺ · · ·≺ Dn, and a field f is defined in Dn. Then for an object x of C, f can be referred to with the expression x→D1::D2:: ... ::Dn::f , where we modify the C++ syntax slightly to explicitly specify the inheritance chain instead of casting x.
With the semantics above, the rules to specify a unique field for x→f can be summarized as a function over the syntactical constructs of our language. Consider x as an object of class C and {Dn} is the set of all superclasses of C. When we try to access the field x→f , its syntactical meaning is as follows:



inh(x→f )	=df
Dij ≺ Dij−1 ,j = 1 ... m,C = Dim } and f is in Dik and for any D ∈ {Dn} that has a field f, we have D ∈D and Dik ≤ D;
⎩ ⊥,  otherwise.

inh(x→D::f ) =df x→D::f.

and these two mappings also apply to virtual method invocations. For non-virtual methods like x→D::m, we always have inh(x→D::m) =df x→D::m.
An informal description of ambiguity is that there are two chains of inheritance with the bottom (subclass of all) C, and f occurs in classes of both chains. For other situations different from the one above, that is, f appears and only appears in one chain, then the f in the nearest class to C is the reference we need.
As is stated, dynamic polymorphism can be realized under this infrastructure.

Take a class inheritance class C : D and a variable x typed D as example, x can also be initialized as an object of C via x = new C(). In the situation that both C and D has the field f , the semantics of expression x→f is a reference to the f of x→C::f but not x→D::f , and we must explicitly specify the latter if we want its reference. The verification system to be built later is based on such semantics.
Finally, in the remainder of this paper it is assumed that all the class inheri- tances are valid (no illegal circle in the partial order) and all the references are not ambiguous, since these should be guaranteed at compile-time.
Separation logic for multiple inheritance
The storage model
As is introduced, separation logic is about the reasoning of aliases and shared muta- ble objects. Because both such aliases and sharing occur on the heap, it is necessary to include the heap in our storage model, which is different from classical Hoare logic where variables are accessed based on the stack. Meanwhile stack is still needed in our model, since the heap can be modeled as a mapping from an address to a value, in which the address should be accessed via the stack. Our storage model, given as follows, is based on the standard model for separation logic.
Stack =df ProgVar ~ Loc Aux	=df AuxVar ~ Loc
Heap =df Loc ~ (ClassName × Field)
Field =df {f | f : ClassName × FieldName ~ Loc}
Stack is a mapping from program variables to address locations Loc, which will not be defined further.
The auxiliary variables compose a significant part of the program state. Though they are not a real part of the storage, they can be useful as assistance to describe program states and specifications. Hence they are also involved in the storage model. These variables do not have fixed types and are supposed to capture any appropriate value from both the stack and the heap.
Note that our model of heap is slightly different from the classical separation logic, where heap is modeled as a mapping from locations (a subset of integers or values) to values, i.e. Heap =df Loc ~ Value+. The reason for us to diverge from
this is that, as an object-oriented language, heap locations are not simply typed as integers or floats, but as more complicated objects of user-defined classes in order to support inheritance and method overriding. Hence the type information of an object must be recorded.
Meanwhile, similar as that a heap location can store many values in the classical separation logic, in our model an object can also have many fields with diverse types. As a result, beneath the heap there is one more set of mappings, Field, to
record the information of an object’s fields. Each element f of Field, denoting one
object in the runtime environment, maps a pair of a field’s (type, name) to its stored address, where the name is the name of the field, and the type is the class name

containing the field (but not the type of the field itself). This design is to facilitate multiple inheritance, since a class may inherit many fields with the same name from its ancestor classes, which form a lattice in lieu of a chain; hence both the name of the field and the actual class containing it are needed when accessing that field. The values mapped to by f are undefined for such pairs not contained in this object.
Besides the heap model itself, a union operation for two disjoint heaps is defined here to support the semantics later:

=	h1 ∪ h2, if dom(h1)∩dom(h2)=∅;
⊥,	otherwise.

This operation conforms to the separation conjunction which will be brought in by the introduction of separation logic. Separation conjunction explicitly claims that two pointers point to disjoint part of heap and thus are not alias to each other, which reduces the intricacy of traditional types of logic for stating that a heap location is pointed to by a pointer exclusively.
Based on the aforesaid models, the definition of program state (also storage) model is a cartesian product of them.

Σ =df Stack × Heap × Aux

Later we will employ s, h and σ to go through instances of stacks, heaps and states.


Assertion language
As for separation logic, it adds two separation-related logical operators. One is separation conjunction ∗, and the other is the separation implication −∗. In this paper only the first is utilized. Its semantics will be introduced later.
Next is the assertion language for our verification system, in which e and e'
stand for variables, null and this, and f and f' denote field names:

P =df true | false | ¬P | P∧P | P∨P | P⇒P | P∗P |
e=e' | e→C::f =e'→C::f' | e→C::f '→ e' | e : C | ∃X.P | ∀X.P

It is worth noting here that we do not have the assertion emp in standard separation logic to express empty heap. Instead, the assertion x = null is used to express that no part of the heap is allocated for the variable x and thus it points to a reserved area null. This assertion not only depicts empty heap but also specifies the variable owning no corresponding allocated heap, which is more accurate without the presence of dangling pointers.
With the storage model as a foundation, each assertion is interpreted as a set of

states.

|[true]|	=df Σ
|[false]|	=df ∅
|[¬P ]|	=df Σ \ |[P ]|
|[P ∧Q]|	=df |[P ]|∩ |[Q]|
|[P ∨Q]|	=df |[P ]|∪ |[Q]|
|[P ⇒Q]|	=df |[¬P ∨ Q]|
|[P ∗Q]|	=df {(σ.1, σ.2, σ.3) | σ∈Σ ∧ ∃h1, h2 . (σ.2=h1∗h2
∧ (σ.1, h1, σ.3)∈|[P ]|∧ (σ.1, h2, σ.3)∈|[Q]|)}
|[e=e']|	=df {σ | σ.1(e) = σ.1(e')}
|[e→C::f '→ e']|	=df {σ | σ.2(σ.1(e)).2(C1,f ) = σ.1(e')}
where C1 is the nearest class’ name to f in inh(e→C::f )
|[e→C::f =e'→C'::f']| =df {σ | σ.2(σ.1(e)).2(C1,f ) = σ.2(σ.1(e')).2(C' ,f')}
where C1 and C' are the nearest classes’ names to f and
f' in inh(e→C::f ) and inh(e'→C'::f'), respectively
|[e : C]|	=df {σ | σ.2(σ.1(e)).1 = C}

For the semantics of these assertions, the ones in ordinary logic are easy to under- stand. The separation conjunction ∗ means that, if both P and Q hold for a state σ, and the heap locations referred to by P are different from those by Q, then P∗Q also holds for σ, with the additional semantics that their orbits over the heap are disjoint.
The '→ considers the field C::f of e as a pointer pointing to (or mapped to by the heap) the semantics of e'. This assertion allows us to reason about program variables’ fields, where the fields are interpreted with the predefined function inh for inheritance purposes.
The e : C is a test of a variable (or rather a location)’s real type in the program execution time. This is dynamic due to polymorphism. The result is possibly the variable’s defined type or any of its subtype.
At last, the ∃X.P and ∀X.P are interpreted as in normal first-order logic, where
X is an auxiliary variable. And for ∃X.P (X) we use P (-) for short.


Rules
In this section we present the rules exploited in our verification system. These rules are in the following triple form:

Γ ▶ {P} s {Q}

where Γ := ϵ | {P} C.m(x) {Q}, Γ is the statical result of verification, consisting of verified method specifications. The triples are common Hoare logic triples written in the former assertion language and our kernel C++’s syntax.

Of all the rules in our system, first are the structural ones.




P ⇒ P'	Γ ▶ {P'} s {Q'}	Q' ⇒ Q ( Γ ▶ {P} s {Q}

conseq)


Γ ▶ {P} s {Q}	(var-elim)
Γ ▶ {∃X.P} s {∃X.Q}

Γ ▶ {P} s {Q}
Γ ▶ {P ∗ R} s {Q ∗ R}

(frame)

where no variable in mods(s) appears freely in R.
The frame rule is a substitute of the “rule of constancy” in classical Hoare logic. By using this rule, the reasoning of local heap can be extended to a global one. For instance, if a recursive method call always uses a separate area of heap at a new time of invocation, then its behavior can be modeled locally to this method body first, and then extended to the heap containing other instances of invocation of this method using this rule.
Next are the canonical rules in ordinary Hoare logic. These rules include skip, instruction sequence, blocks and the if conditions.
Γ ▶ {P} ; {P} (skip)


Γ ▶ {P} s1 {R}	Γ ▶ {R} s2 {Q} (seq)	Γ ▶ {P} s {Q}

(block)

Γ ▶ {P} s1; s2 {Q}	Γ ▶ {P} {s} {Q}
Γ ▶ {P ∧ (e1=e2 ∨ e1'→e2)} s1 {Q}	Γ ▶ {P ∧ ¬e1=e2 ∧ ¬e1'→e2} s2 {Q} (if ) Γ ▶ {P} if (e1 == e2) s1 else s2 {Q}
For assignment, there are two cases to be considered in our syntax. One is from object field to another variable, and the other is the opposite direction.

Γ ▶ {y→C::f '→ X} x=y→C::f ; {x = X} (assign-1)
Γ ▶ {e = X} x→C::f =e; {x→C::f '→ X} (assign-2)
The two rules of assignment take use of auxiliary variable X instead of the tradi- tional assignment rule using substitution in assertions. The auxiliary variable in- troduced can be eliminated later in a proof. Note that an assignment also changes the heap location that a variable points to.
Next is a special case of assignment: the downcast.

Γ ▶ {(y=X ∧ y:C) ∨ y=null)} x=(C ∗)y; {x = X} (downcast)

As downcasting requires that a variable of a base class be casted down to an object of its subclass, it is essential to check whether the variable is pointing to an object of the subclass; if not, the downcasting cannot be performed.
The rules below are for fields manipulation.
Γ ▶ {true} C ∗ x; {x=null} (def )

Γ ▶ {x=X} x=new C(); {x=Y ∧ ¬X=Y ∧ x:C} (new)

where Y is a fresh auxiliary variable.

Γ ▶ {x'→-} delete x; {x=null} (delete)

For variable definition, it is supposed that the compiler will prevent re-definition statically, and hence the pre-condition is not needed. The operations of new and delete have opposite behaviors on the heap, as is expressed in the rules, one allo- cates a fresh location in the heap, while the other disposes some part of the heap.
And the last are the rules for methods definition and invocation.


	

   	
Γ ▶ {P ∧ this:C} C ∗ y; y=x; s[y/x] {Q[x/ret]}	m(C' ∗ x'){s return x; } ( Γ ← {P } C.m(x) {Q}, Γ

m-def )

where ret is the return value of the method and
y does not occur freely in the method body.
This rule first ensures that this method is defined in the right class C. After that the method body is checked to agree with the specification {P} s {Q[x/ret]}. Then the specification is added to the statical environment to support potential method invocation, which is depicted in the following rule.

Γ1, {P} D.m(x) {Q}, Γ2 ▶ {θ(P ) ∧ (¬y=null)} x=y→C::m(e); {θ(Q)} (m-call)
where θ = [e, y, x / x, this, ret] and D is the last class name before m in inh(y→C::m).
The above rule verifies the call of a overridden method from an object y. It has the inverse behavior of the last rule by substituting the actual parameters with the formal ones to fit in the specification recorded in Γ. When using this rule the static type of y should be judged.
In this section we have combined separation logic with a OO language with multiple inheritance. This logic has a semantics based on multiple inheritance and heap model of storage, and has a series of formal verification rules upon this model. However, when using such rules to derive a program’s proof we still have to consider the polymorphism and the specification compatibility in method overriding, which will be the main topic of next section.
Behavioral subtyping
As our verification is performed over an object-oriented language with multiple in- heritance, it is necessary to deal with dynamic dispatching during program execution time, for the possible inheritance and the resulted method overriding.
For this issue we turn to Liskov’s behavioral subtyping ([4,7]). Since upcasting could occur in any place of a program, it must be ensured that any object of a subclass should behave like an object of its superclass. That is, for any of this object’s method overriding the superclass’ counterpart, its specification should be consistent with the superclass’ method’s. Thus no matter an object belonging to

a class or its subclass appears, it will conform to the expected specification. And this is formalized with behavioral subtypes, say, a type C is a behavioral subtype of D, if for each virtual method m of C overriding that of D, with the specifications
{PC} {QC} and {PD} {QD}, the implications PD ⇒ PC and QC ⇒ QD hold.
In the view of canonical Hoare logic, this definition of behavioral subtyping is another description of the rule of consequence. If all the classes of a program conform to such restrictions, then in verification it is safe to ignore the real type of an object during execution time, since the behavior of the object’s methods will always comply with the specifications, no matter those for the base class or for its inherited classes.
Parkinson and Biermann ([12]) proposed a concept of compatible speciﬁca- tions, as a generality of behavioral subtyping: ∀s, if we have {PD} s {QD} ⇒
{PC} s {QC}, namely, a proof of the latter with the only premise of the former, then the latter is defined as compatible with the former. The aim of behavioral subtyping is to ensure that each overriding method C.m(x) has a specification com- patible with its counterpart in the superclass, D.m(x).
To achieve this goal, a possible way is to make a “conjunction” of the base class’ method’s specification and the subclass’ method’s. Such specification could carry the conditions specified for both classes’ method and be used appropriately according to the real type of objects.
Consider two specifications for a virtual method m in class C and its base class
D. m in C overrides m in D, and their specifications are as follows, respectively:

{PD}	{QD}	{PC}	{QC}

If we can make a specification consistent with both two above, then whenever the method m of an object x, with static type of class D, is invoked, this specification can be used even if x : C. This can be accomplished by the following means:
  (PC ∧ IC)∨   (QC ∧ IC)∨ 

(PD ∧ ID)	(QD ∧ ID)
where assertions PC, QC, PD and QD are the same as above, while IC and ID are invariants of type identity. It can be shown that this is compatible with both m’s in C and D. To illustrate, for {PD} {QD} as a specification of D.m(x), we can set the invariant as this : D and modify the specification as {PD ∧ this:D} D.m(x) {QD ∧ this:D}, which can be derived just from our specification conjunction. Also an auxiliary variable may be set to specify the different cases, which can be eliminated with the auxiliary variable elimination rule later.
In our case of multiple inheritance, suppose that there are several chains of class inheritance relationship. Then for each of such chain Cn ≺ Cn−1 ≺ · · · ≺ C1 and each overridden method m of these classes, a conjunction of different specifications of diverse implementations of m should be made available. Without loss of generality, assume m is overridden in each Ci with specification {Pi} Ci.m {Qi}, and then the total specification to capture all behaviors of different m’s in this inheritance chain

should be
n	n
{  (Pi ∧ Ii)} m {  (Qi ∧ Ii)}

which can be used at any call site of m belonging to an object with static type of any Ci.
An example
This section depicts an example as an illustration of our former means. It is based on the task-display example from Stroustrup [16,17] and has some modifications to cater for our language.
Consider a simulation of a network of computers. There are mainly two types of beings: tasks and displays. Tasks provide basic facilities for co-routine style behaviors of the network, and displays provide means for the monitoring of object states in the network. For these two concepts, two classes are defined as Task and Display. Task’s objects include network nodes called switches, and Display contains elements like communication lines in the network. These two are naturally modeled as Switch and Line, subclasses of the former two base ones.
Ideally Task and Display are disjoint because they share no similarity. However, a computer terminal, whose class is denoted Terminal, can act both as a task node and a monitor device. Thus the best way is to make Terminal inherit both Task and Display. In the following example we omit the definition of Switch, Line and other indifferent methods in our view for the space limit. For more detailed background of these examples, the bibliography is recommended.
Below are the codes for our examples. The class Node is added for support.


class Node { ... }; class Task {
Node *n;
virtual Node *trace (Node *an) {
this->n = an; return this->n;
}
};
class Display { Node *n;
virtual Node *trace(Node *an) { Node *tmp;
if (an == this->n) tmp = an; else tmp = this->n;
return tmp;
}
};


class Terminal : Display, Task { Node *trace(Node *an) {
Node *tmp;
if (this->Display::n == this->Task::n)
tmp = this->Display::trace(this->Task::n); else tmp = this->Task::trace(an);
return tmp;
}
};

The results of the three methods’ verification is depicted as a Γ built up by their specifications:
{(this→n '→ N1 ∧ an=N1) ∨ (this→n '→ N1 ∧ an = N2 ∧ ¬N1=N2)}
Display.trace(Node ∗ an)
{this→n '→ N1 ∧ N1=an ∧ an=ret}

{an = N1} Task.trace(Node ∗ an) {this→n '→ N1 ∧ N1=an ∧ an=ret}


(this→Display::n '→ N1 ∗ this→Task::n '→ N1) ∨
((this→Display::n '→ N1 ∗ this→Task::n '→ N2) ∧ ¬N1=N2)
Terminal.trace(Node ∗ an)
⎧⎪⎨ ((this→Display::n '→ N1 ∗ this→Task::n '→ N1) ⇒
 


⎫⎪⎬

⎪⎩ (
1
::	::
2	1	2
=
)) ⎪⎭

To deal with behavioral subtyping, as is stated in the paper, a “conjunction” of the three methods’ specifications can be made with an invariant to distinguish among different dynamic situations. However, in our example we only have to conjugate the specifications of Display.trace’s and Terminal.trace’s, and also Task.trace’s and Terminal.trace’s, separately, since these two are different chains of inheritance.

Conclusions
This paper brings out an extension of the separation logic for the reasoning of object-oriented programs with multiple inheritance. It has condensed the syntax of C++ to a core and set up a storage model for it based on the canonical separation logic. The verification rules are proposed according to this model, and behavioral subtyping is considered for the sake of runtime type decision. Finally an example is utilized to illustrate this whole approach.

Related work
Separation logic [14,3,15] is a significant extension of Hoare logic to boost reasoning about programs with pointers and heap manipulation. It allows reasoning to be done locally for a single part of heap without interfering with others, and also al- lows the result of reasoning to be extended again to global environment. Therefore many works took use of this modularity. O’Hearn et al. [10] used the separation conjunction and the hypothetical frame rule to separate one module’s internal re- sources from those accessed by its clients which was a first step for separation logic towards modular program verification. O’Hearn [9] also employed the analogous approach in concurrent program verification to describe resources in critical region of concurrent processes. Due to this modularity, separation logic is highly suitable

for the verification of object-oriented programs. Another former attempt to intro- duce separation logic into the field of OO verification belongs to Parkinson [11]. In that work he found good means (abstract predicate family) to depict methods spec- ifications and to rebuild the logic for Java program reasoning. We intend to follow his route to construct another extension of separation logic for a more general case of class inheritance. In our case the chains of inheritance might have intersections, which are different from single inheritance in both syntax and semantics.
To support reasoning about the type hierarchy and inheritance of object-oriented programming languages, and to capture their important properties such as polymor- phism and diverse implementations, the concept of behavioral subtyping has been developed, as in Liskov [4], Liskov and Wing [7], Meyer [8], Dhara and Leavens [2], Leavens and Naumann [5], Parkinson [11], Parkinson and Biermann [13], and Chin et al. [1]. The first ([4]) was one of the beginners to develop the relationship between data abstraction and type hierarchy. Later Liskov and Wing proposed the behav- ioral subtyping as a general approach to dealing with inheritance and polymorphism ([7]). Another method to enforce that the new specification should also inherit the old one in class inheritance was introduced by Meyer ([8]) for Eiffel. Those two techniques were combined by Dhara and Leavens ([2]), and were eventually proven to be equivalent by Leavens and Naumann ([5]). The rest were practices, using behavioral subtyping or not, to process class hierarchy and inheritance in modeling and verification of object-oriented languages. Chin et al. [1] divided the method specification into finer-grained static and dynamic ones to prevent repeated verifi- cation and meanwhile to preserve behavioral subtyping. Parkinson and Biermann ([13]) used their abstract predicate family to cope with the same problem and could even handle cases there were beyond the capability of behavioral subtyping. In our work we took the compatible specification to guarantee behavioral subtyping. How- ever, as a matter of fact, the way to treat with type hierarchy and class inheritance is orthogonal to our work. Therefore any of the aforesaid approach may be utilized.

Future work
Beyond this work, there are still several possible directions calling for further re- search. One of them aims at the defect of this work, viz. the re-verification of the inherited virtual methods. Since these methods may have different implementations from their antecedents, it may be necessary to treat them as totally new methods for re-verification, which requires much extra workload. Some feasible solutions for this include the works of Chin et al. ([1]), which separated method specifications to static and dynamic ones, where only the latter needed re-verification, and Parkin- son and Biermann ([13]) who invented abstract predicate families to reduce the necessity of re-verification.
Another important future work is to give an implementation of this extension of separation logic. Before this more features of C++ must be added to the language, such as stack variables for basic data types, arithmetic operations and access con- trol. Then the model and the rules should be combined to some (semi-) automatic reasoners for implementation.

Acknowledgement
Chenguang Luo is funded by Doctoral Fellowship Scheme of Durham University. Shengchao Qin is supported in part by the EPSRC project EP/E021948/1.

References
W. Chin, C. David, H. H. Nguyen, and S. Qin. Enhancing modular OO verification with separation logic. San Francisco, USA, January 2008. The 35th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL’08).
K. Dhara and G. Leavens. Forcing behavioral subtyping through specification inheritance. Berlin, Germany, March 1996. Proceedings of the 18th International Conference on Software Engineering (ICSE-18).
S. Isthiaq and P. O’Hearn. BI as an assertion language for mutable data structures. London, United Kingdom, January 2001. The 28th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL’01).
B. Liskov. Data abstraction and hierarchy. ACM SIGPLAN Notices, 23(5):1734, May 1988.
G. Leavens and D. Naumann. Behavioral subtyping is equivalent to modular reasoning for object- oriented programs. Technical Report 06-36, Department of Computer Science, Iowa State University, 2006.
J. Loeckx, K. Sieber, and R. Stansifer. The foundations of program verification. John Wiley and Sons, 1984.
B. Liskov and J. Wing. A behavioral notion of subtyping. ACM Transactions on Programming Languages and Systems, 16(6):1811-1841. November 1994.
B. Meyer. Eiffel: the language. Object-Oriented Series. Prentice Hall. New York, 1992.
P. O’Hearn. Resources, concurrency, and local reasoning. Proceedings of CONCUR’04, LNCS 3170, pp49-67.
P. O’Hearn, H. Yang, and J. Reynolds. Separation and information hiding. Venice, Italy, January 2004. The 31th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL’04).
M. Parkinson. Local reasoning for Java. PhD thesis, Cambridge University, August 2005.
M. Parkinson and G. Biermann. Separation logic and abstraction. Long Beach, California, USA, January 2005. The 32th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL’05).
M. Parkinson and G. Biermann. Separation logic, abstraction and inheritance. San Francisco, California, USA, January 2008. The 35th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL’08).
J. Reynolds. Intuitionistic reasoning about shared mutable data structure. Millennial Perspectives in Computer Science, Proceedings of the 1999 Oxford–Microsoft Symposium in Honour of Sir Tony Hoare, 1999.
J. Reynolds. Separation logic: A logic for shared mutable data structures. In Lecture Notes in Computer Science. Springer-Verlag, 2002.
B. Stroustrup. The C++ programming language. Addison-Wesley, 1991.
B. Stroustrup. Multiple inheritance for C++. The C/C++ Users Journal, May 1999.
Daniel Wasserrab, Tobias Nipkow, Gregor Snelting, and Frank Tip. An operational semantics and type safety proof for multiple inheritance in C++. In OOPSLA’06: Object-Oriented Programming, Systems, Languages, and Applications. ACM Press, 2006.
