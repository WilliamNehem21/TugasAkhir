

Electronic Notes in Theoretical Computer Science 267 (2010) 17–27
www.elsevier.com/locate/entcs
Range and Set Abstraction using SAT
Edd Barrett1,2 and Andy King3
School of Computing University of Kent Canterbury
England

Abstract
Symbolic decision trees are not the only way to correlate the relationship between flags and numeric vari- ables. Boolean formulae can also represent such relationships where the integer variables are modelled with bit-vectors of propositional variables. Boolean formulae can be composed to express the semantics of a block and program state, but they are hardly tractable, hence the need to compute their abstractions. This paper shows how incremental SAT can be applied to derive range and set abstractions for bit-vectors that are constrained by Boolean formulae.
Keywords: Abstract domains, numeric domains, ranges, satisfiability solving.


Introduction
Although the fundamental ideas in abstract interpretation were laid down over thirty years ago [5], abstract interpretation has only entered its industrialisation phase comparatively recently [6]. This new phase is not only characterised by an increased focus on tooling and systems building, but also by work on designing and implementing new abstract domains. For example, domains for improved scalability
i.e. the class of weakly-relational domains [15,19], and domains that better match the structure of real programs i.e. symbolic decision trees that correlate the relation- ship between status flags and numeric variables [1]. This paper focuses on relating status flags to numeric abstractions that are ranges and sets. Blanchet et al [1] illustrates the need for mixed symbolic and numeric abstractions with pseudo-code that is given below:

1 The authors would like to thank Thomas Schilling for his comments on SAT solving, Ralph Corderoy for support on CNF conversion, J¨org Brauer for discussions on minimising bit-vectors, Martin Ellis for code reviews and Stephen Fendyke for sharing his knowledge of interpolation software. We also thank the anonymous reviewers for their comments.
2 Email: e.barrett@kent.ac.uk
3 Email: a.m.king@kent.ac.uk

1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.09.003

B  :=  ( X  =  0);
if  (! B)  Y  :=  1/ X;
This code is correct in that sense that it does not give a division by zero error if
X = 0, but to deduce this it is necessary to track the relationship between B and X. The authors state:
“In order to deal precisely with those examples, we implemented a simple re- lational domain consisting in a decision tree with leaf an arithmetic abstract domain. The decision trees are reduced by ordering Boolean variables and by performing some opportunistic sharing of sub-trees. The only problem with this approach is that the size of a decision tree can be exponential in the number of Boolean variables, and the code contains thousands of global ones”
The problem of relating Booleans to numeric values is particularly acute in binary reverse engineering, though in this context the Booleans are CPU status flags. Binary reverse engineering is the problem of figuring out what a program does from its executable. This is a necessary step when performing, for example, a security audit on code where licensing restrictions prevent access to the source. Motivated by such problems in security, there has been recent interest in recovering the control flow graph (CFG) from a binary [12]. The problem here is the so-called chicken- and-egg problem [8]: to derive the CFG it is necessary to trace values and indirect addresses that occur in registers. However, in order to trace the values in registers, the CFG is required. Kinder resolves this cyclic dependency by applying a constant propagation analysis in conjunction with a CFG that itself grows monotonically as the analysis proceeds [12]. He illustrates these ideas with an idealised assembler language. In practice the problem is considerably harder to solve, partly because of the problem of relating status flags to ranges. To illustrate, consider the following x86 assembler code for a switch table:
mov eax , [ ebp -0 x8 ]	; eax := *( ebp - 8) sub eax , 0 x2	; eax := eax - 2
cmp  eax ,  0 x5	;  CF  :=  (0  =<  eax  <  5)
;  ZF  :=  ( eax  =  5)
ja	0 xd8	; JMP if CF = 0 and ZF = 0 jmp [0 x 8048 a 0 c + eax *4]
To determine the CFG it is necessary to ascertain that eax ∈ [0, 5] when the indirect jump is reached. This range information, and the table itself, permits the CFG to be over-approximated. However, inferring the range on eax itself requires careful reasoning about the value of the carry (CF) and zero (ZF) flags — a problem which is analogous to that addressed by Blanchet et al [1].
Very recently it has been shown how Boolean formulae can be applied to derive transfer functions for range analysis of AVR micro-controller code [2]. In this work, the semantics of a block of code are represented as a Boolean formula, which is then abstracted with octagons [15] and affine equations [11] so as to derive a transfer function that is a system of guarded updates. In this paper we show how Boolean

formulae can be applied directly in the analysis itself in an analogous way to decision trees. However, unlike the decision tree approach, we do not enforce a canonical representation and thereby finesse the size problems that are associated with such data-structures [3]. Instead, we express the semantics of a block as a single proposi- tional formula which can readily be derived with bit-blasting techniques [13]. This formula encodes all the relationships between all the registers and all the status flags, albeit at bit-level granularity. Abstraction is then applied to the formula to extract range invariants that always hold whenever the block is encountered, ul- timately allowing the control flow to be recovered. Furthermore, we may impose range information on entry to the block and observe ranges at the exit, again by applying abstraction. This is similar in spirit to work on best transformers [18], but from a propositional stance. In this paper, we focus on how to abstract Boolean formula for range information. Specifically, we make the following contributions:
We show how to efficiently extract range information for a bit-vector constrained by a Boolean formula where the vector is interpreted as an integer. To be precise, we show how to compute the smallest range that includes all the values the integer can assume, and hence the best over-approximation.
We show how to refine the range abstraction technique in order to discover bound- aries within the range that partition it into a set of ranges. This technique relies on computing over- and under-approximations of the vector in an alternating fashion. This process ultimately converges onto a set S that exactly describes the values of the vector. However, if desired, this process can be terminated prema- turely, after n steps, to compute a set that approximates the values of the vector. To be precise, if n is odd then an over-approximation is computed (a superset of S) otherwise if n is even then an under-approximation is found (a subset of S).
We show how these techniques dovetail with incremental SAT and provide exper- imental results which suggest that the techniques are viable.
Range Abstraction
In order to infer the range of values that a bit-vector x can assume when constrained by a given Boolean formula f – that is, compute a range abstraction for x and f – the maximum and minimum values of x need to be determined. This can be achieved by applying a SAT solver in conjunction with blocking clauses. For instance, suppose a SAT solver is applied to find a solution of f under which the propositional variables x = ⟨x0,..., xn−1⟩ are bound to the truth values b0,..., bn−1 ∈ {0, 1}. A blocking clause c = ∨n−1yi is defined by putting yi = xi if bi = 0 and yi = ¬xi otherwise. Thus any solution to c differs from the truth values b0,..., bn−1 on at least one bi. The force of this is that the formula f ∧ c excludes the previously found solution. By repeating this technique it is possible to enumerate all solutions, hence all values that x can assume, from which the maximum and minimum can be extracted. The limitation of this technique is that the number of invocations of the solver is linear in the number of solutions (which may be large) and moreover, the size of the SAT instance grows as blocking clauses are added.

(1)   func minimum(f, x, s)
(2)	k → ⟨⟩,n → |x|
(3)	while (|k| < n)
(4)	if (s)
(5)	if (sat(f ∧ x[n − 1]))
(6)	f → f ∧ x[n − 1]
(7)	k → ⟨1⟩
(8)	else
(9)	f → f ∧ ¬x[n − 1]
(10)	k → ⟨0⟩
(11)	endif
(12)	s → 0
(13)	else
(14)	if (sat(f ∧ ¬x[n − |k|− 1]))
(15)	f → f ∧ ¬x[n − |k|− 1]
(16)	k → ⟨0⟩ :: k
(17)	else
(18)	f → f ∧ x[n − |k|− 1]
(19)	k → ⟨1⟩ :: k
(20)	endif
(21)	endif
(22)	endwhile
(23)	return k
(24)	endfunc

Fig. 1. Computing the minimum value of the bit-vector x
Computing the Minimum
An alternative approach is given in Figure 1 which presents an algorithm for com- puting a minimum model that requires only n calls to a SAT solver. If the Boolean flag s = 1 then the bit vector x = ⟨x0,..., xn−1⟩ is interpreted as a signed integer, represented using two’s complement, where xn−1 is the sign bit and x0 is the least significant bit. If s = 0 then the bit vector x is interpreted as an unsigned inte- ger. The function minimum returns the minimum value expressed as binary vector k ∈ {0, 1}n.
Consider first the unsigned case that is handled in the else branch of the loop body. The bits of k are computed in reverse order: the high bit first and the low bit last. On each iteration of the loop, f is tested to see whether it possesses a solution in which the bit x[n − |k|− 1] is assigned to 0. If so, then the minimum value of x has a 0 in this bit position, hence 0 is prepended to k. If not, then every solution of x (including the minimum) has a 1 in this position, hence 1 is prepended to k. Note that as the loop progresses, f is itself modified so as to clamp the high bits of x to the high bits of the partially computed minimum k.
The signed case proceeds analogously except for the very first iteration which

(1)	func set(f, x, s)
(2)	return set(f, x, s, −1)
(3)	endfunc
(4)
(5)	func set(f, x, s, c)
(6)	S →∅ 
(7)	p → 1
(8)	l → ⟨0,..., 0, s⟩
(9)	u → ⟨1,..., 1, ¬s⟩
(10)	while (value(l, s) < value(u, s) ∧ c /= 0)
(11)	l → minimum(f ∧ (l ≤s x), x, s)
(12)	u → maximum(f ∧ (x ≤s u), x, s)
(13)	if (p)
(14)	S → S ∪ [value(l, s), value(u, s)]
(15)	else
(16)	S → S \ [value(l, s), value(u, s)]
(17)	endif
(18)	p → ¬p
(19)	f → ¬f
(20)	c → c − 1
(21)	endwhile
(22)	return S
(23)	endfunc
Fig. 2. Computing a set abstraction for the bit-vector x

computes the sign bit of the minimum. If f has a solution with x[n − 1] assigned to 1, then the minimum is negative, which is reflected by setting k to the unary vector ⟨1⟩, so as to record the sign of the minimum. Otherwise, the minimum is non-negative, hence k is set to ⟨0⟩. Setting s to 0 ensures that all subsequent loop iterations deduce the lower bits of k in the same manner as in the unsigned case.
Computing the Maximum
Computing a maximum model is analogous to computing minimum model. The algorithm for computing a maximum can be obtained from the algorithm shown in Figure 1 by:
Inverting the polarities of x[n − 1] on lines 5, 6 and 9;
Inverting the polarities of x[n − |k|− 1] on lines 14, 15 and 18;
Inverting the truth values prepended onto k on lines 7, 10, 16 and 19.
Set Abstraction
Switch tables can in general be hierarchical structures in which a series of tests direct the control into smaller tables that handle indices that are close to one another.

Range abstraction alone cannot accurately model such sets of indices and addresses and therefore it is necessary to instead employ set abstraction. Since an n-ary bit- vector x can assume up to 2n distinct values, the set itself can be large, at least in the pathological case. Therefore, for cautionary reasons, we seek to compute an over-approximation (superset) that keeps the size of the set manageable. As a by-product of this construction, we are also able to compute under-approximations (subsets) of the set of values that bit-vector can assume when constrained by a given Boolean function f .
Figure 2 presents the function set for computing a set abstraction for x. The Boolean argument s indicates whether x has a signed interpretation. The integer argument c bounds the number of iterations of the loop. Moreover, if c is non- negative and odd then an over-approximation is found whereas if c is non-negative and even then an under-approximation is derived. If c is negative then the algorithm will run to completion and exactly characterise the values of x.
The set S, which starts empty, is refined on each iteration of the loop. The vectors l and u are used to further constrain f ; these bounds increase and decrease respectively, until either reaching the c threshold triggers premature termination or the bounds l and u cross and an exact description of the set is found. The special treatment of the most significant bit of l and u on lines 8 and 9 stem from the two’s complement representation for the case that s = 1. The function value is used to interpret a bit vector as a numeric value:
n−2
value(b, s)= (1 − 2s)2n−1b[n − 1] +	2ib[i]
i=0
Each iteration of the loop determines a new minimum (l) and maximum (u) solution to a SAT instance that is obtained by augmenting either f or ¬f with a formula that imposes a less-than-or-equals relation on x. This additional formula prevents the previously found ranges from being rediscovered. Although incremental SAT can be used within the functions minimum and maximum, the different less- than-or-equal-to relations impede incremental SAT being applied in the function set.
For the unsigned case, the relation is formulated propositionally as follows:
⟨⟩ ≤0⟨⟩ = true
⟨x[0] ... x[n − 1]⟩ ≤0⟨y[0] ... y[n − 1]⟩ =
(¬x[n − 1] ∧ y[n − 1]) ∨ ((x[n − 1] ⇔ y[n − 1])∧
(⟨x[0] ... x[n − 2]⟩ ≤0 ⟨y[0] ... y[n − 2]⟩)) whereas the signed case is defined thus:
⟨⟩ ≤1⟨⟩ = true
⟨x[0] ... x[n − 1]⟩ ≤1⟨y[0] ... y[n − 1]⟩ =
(x[n − 1] ∧ ¬y[n − 1]) ∨ ((x[n − 1] ⇔ y[n − 1])∧
(⟨x[0] ... x[n − 2]⟩ ≤0 ⟨y[0] ... y[n − 2]⟩))

On line 11, l is a vector of truth values, hence the formula (l ≤s x) can be partially evaluated to simplify the comparison (and likewise on line 12 for (x ≤s u)). For example consider two 4-bit vectors x and y and suppose y = ⟨1, 0, 1, 1⟩. Then x ≤0 y can be reduced to the formula ¬x[3] ∨ (x[3] ∧ ¬x[2] ∨ (x[2] ∧ ¬x[1])).

Example
Suppose a 4-bit vector x is constrained by a formula f so that it can only draw an unsigned value from the set {1, 2, 3, 5, 6, 8, 9, 12, 13, 15}. The table shows how S converges onto this set by alternating between an over-approximation and an under-approximation.


c	p	l
u	value
value	S

Experimental Results
The minimum/maximum algorithms at the heart of range abstraction and set ab- straction amount to solving a series of related SAT problems. This suggests the ap- plication of incremental SAT. Incremental SAT is the problem of solving a series SAT instances {∧F1,..., ∧Fk} defined over a common set of variables. Each Fi is a set of clauses, and the consecutive instances are related according to Fi+1 = (Fi \ Gi) ∪Hi where Gi and Hi are sets of clauses that are respectively rescinded and added [10,20]. Incremental SAT is most useful when |Gi|  |Fi| and |Hi|  |Fi| since then solv- ing ∧Fi+1 can take advantage of the clauses learnt when solving ∧Fi, and possibly earlier instances.
In the algorithm given in Figure 1, unit clauses of x[n − 1], ¬x[n − 1],
¬x[n − |k|− 1] and x[n − |k|− 1] are added to f at lines 5, 9, 14 and 18 respec- tively. Conversely, the unit clauses x[n − 1] and ¬x[n − |k|− 1] are rescinded when the satisfiability questions posed at lines 5 and 14 are found to have a negative answer. (Note that these removal operations are not reflected in the algorithm but are applied in the else blocks that commence at lines 9 and 18.) Thus whenever a new SAT instance is encountered |Gi| ≤ 1 and |Hi| = 1, which suggests that the algorithm is ideal for incremental SAT. Moreover, only unit clauses are added and removed, and this specialised form of incremental SAT is supported with the so-called unit assumptions of the popular MiniSat solver [9]. (Actually, unit as- sumptions are automatically withdrawn by MiniSat after checking satisfiability and thus those unit assumptions which need to be preserved have to be readded as immutable clauses.)
Of course, incremental SAT is only of value if it actually improves performance.

30



25



20



15



10



5



0
0	10	20	30	40	50	60	70	80	90	100
Number of jump addresses
Fig. 3. Satisfiable jump addresses vs. time

To investigate this, a series of representative Boolean formulae were generated to model multi-level switch tables so as to constrain a bit-vector x of 64 bits to store up to 98 different branch addresses. To investigate scalability, the set abstraction algorithm was applied to switch tables of increasing size where the branch addresses were non-consecutive (this is because typically addresses are 32 or 64 bits in length, meaning that the first byte of an indirect jump address occurs every 4 or 8 bytes). The abstraction algorithm was not terminated prematurely, so as to exercise it fully. The graph shown in Figure 3 suggests that the time to compute the precise set abstraction grows smoothly with the size of the switch table. These timings were generated on a 3GHz x86 machine with 4GB of RAM running Linux.
Interestingly, replacing incremental SAT with a series of independent calls to the same solver gave a slowdown of two orders of magnitude. Thus incremental SAT compensates somewhat for the need to invoke the solver 64 times to compute the minimum/maximum of a 64-bit integer. Figure 4 illustrates the variability in the time required to compute the minima and maxima at different iterations of the set abstraction algorithm. Importantly, the time to compute the minima and maxima do not increase in the latter iterations of algorithm, which one might expect as the solution range diminishes.
It should be emphasised that we report initial results and the efficiency of tech- nique can doubtless be improved by standard tactics such as more refined CNF con- version [17]. Furthermore, by changing the search strategy used in the SAT solver, it may be possible to directly derive the maximum (or minimum) value of a bit vec- tor without deploying n separate (albeit incremental) calls to the solver. Although this would require fundamental changes to the SAT solver itself, the speed-up could

0.11


0.105


0.1


0.095


0.09


0.085


0.08


0.075


0.07


0.065

0	20	40	60	80	100
Range Number

Fig. 4. Time taken to solve minima and maxima of each range.
be very considerable.

Related Work
The question of how to abstract Boolean formulae also arises in the context of de- riving transfer functions, specifically those for range analysis [2]. The automatic derivation of a transfer function is attractive since it supports reasoning about blocks as a whole thereby improving precision. In range analysis, a transfer func- tion transforms its input ranges to output ranges, and Boolean formulae offer a convenient way of calculating such extreme values since ∀-elimination is trivial over this computational domain [13]. There is no reason why the abstraction techniques proposed in this paper can not be deployed to derive octagonal abstractions [15], where one would maximise the expression x − y, to derive a constraint of the form x − y ≤ c.
Cifuentes and Van Emmerik [4] have shown how to compute numeric ranges for switch tables using reverse slicing, however we believe that a more robust approach is to apply bit-blasting with abstraction, as shown in this paper.
Decision procedures have also been applied when computing best transform- ers [18]. This work is more akin to our own since here the decision procedures are applied within the transfer functions themselves rather than in just deriving them [2]. Moreover, the best transformer work does not address bit-vector encodings, and hence does not consider the associated problem of computing range and set abstractions of their values.
Finally, symbolic decision trees offer an alternative way of relating status flags to

numeric variables [1]. This method confers the advantage that the numeric variables can be perfect numbers rather than finite ones which are required for bit-blasting. Symbolic decision trees have traditionally suffered problems of scalability but recent work suggests that this problem can be tackled with judicious widening [7].
Conclusion and Future Work
The paper has shown bit-blasting can be combined with range and set abstraction to extract the range of the values that can be used to index a switch table. This is an important step in CFG recovery which itself is important for underpinning other analyses. That such information can be derived automatically from a block is encouraging, particularly as one cannot ensure that the range checks and multi-way branches take a regular recognisable structure.
The method advocated in this paper could be extended to several blocks as an unusual form of path-sensitive analysis in which one accumulates a formula that documents the recent history of computation. This should handle indirect jumps, even in extreme cases where a jump address is passed from one block to another.
We will also investigate as to whether SMT solvers [16] may be used to speed- up our range and set abstraction techniques; it is yet to be seen whether SMT techniques completely finesse the need to operate at bit level granularity.
Of course, CFG reconstruction remains a challenging problem and Linn and Debray [14] have shown that industry standard disassemblers such as IDA Pro can be persuaded to misinterpret large portions of a binary program. This suggests that more robust disassembly techniques must be developed with anti-reversing techniques in mind. Obfuscation techniques such as those based on pre-empting POSIX signal events [14] are likely to remain out of the reach of analysis for some time.

References
Blanchet, B., P. Cousot, R. Cousot, J. Feret, L. Mauborgnei, A. Min´e, D. Monniaux and X. Rival, A static analyzer for large safety-critical software, in: PLDI, 2003, pp. 196–207.
Brauer, J. and A. King, Automatic Abstraction for Intervals using Boolean Formulae, in: R. Cousot and M. Martel, editors, SAS, LNCS (2010).
Bryant, R. E., Symbolic Boolean Manipulation with Ordered Binary-Decision Diagrams, ACM Computing Surveys 24 (1992), p. 318.
Cifuentes, C. and M. Van Emmerik, Recovery of Jump Table Case Statements from Binary Code, Sci. Comput. Program. 40 (2001), pp. 171–188.
Cousot, P. and R. Cousot, Abstract Interpretation: a Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints, in: POPL, 1977, pp. 238–252.
Cousot, P., R. Cousot, J. Feret, L. Mauborgne, A. Min´e and X. Rival, Why does Astr´ee scale up?, Formal Methods in System Design 35 (2009), pp. 229–264.
Cousot, P., R. Cousot and L. Mauborgne, A Scalable Segmented Decision Tree Abstract Domain, in:
Time for Verification: Essays in Memory of Amir Pnueli, LNCS 6200 (2010).
De Sutter, B., B. De Bus, K. De Bosschere, P. Keyngnaert and B. Demoen, On the static analysis of indirect control transfers in binaries, in: PDPTA, 2000.

Een, N. and N. S¨orensson, MiniSat (2010), www.minisat.se.
Hooker, J. N., Solving the incremental satisfiability problem, Journal of Logic Programming 15 (1993),
pp. 177–186.
Karr, M., Affine Relationships Among Variables of a Program, Acta Informatica 6 (1976), pp. 133–151.
Kinder, J., F. Zuleger and H. Veith, An Abstract Interpretation-Based Framework for Control Flow Reconstruction from Binaries, in: VMCAI, LNCS 5403 (2009), pp. 214–228.
Kroening, D. and O. Strichman, “Decision Procedures,” Springer, 2008.
Linn, C. and S. Debray, Obfuscation of executable code to improve resistance to static disassembly, in:
ACM Conference on Computer and Communications Security, 2003, pp. 290–299.
Min´e, A., The Octagon Abstract Domain, Higher-Order and Symbolic Computation 19 (2006), pp. 31– 100.
Nieuwenhuis, R., A. Oliveras and C. Tinelli, Solving SAT and SAT Modulo Theories: From an abstract Davis–Putnam–Logemann–Loveland procedure to DPLL (T), Journal of the ACM 53 (2006), pp. 937– 977.
Plaisted, D. A. and S. Greenbaum, A Structure-preserving Clause Form Translation, Journal of Symbolic Computation 2 (1986), pp. 293–304.
Reps, T., M. Sagiv and G. Yorsh, Symbolic Implementation of the Best Transformer, in: VMCAI, LNCS 2937 (2004), pp. 3–25.
Simon, A., A. King and J. M. Howe, Two Variables per Linear Inequality as an Abstract Domain, in:
LOPSTR, LNCS 2664 (2002), pp. 71–89.
Whittemore, J., J. Kim and K. Sakallah, SATIRE: A New Incremental Satisfiability Engine, in: Design Automation Conference, 2001, pp. 542–545.
