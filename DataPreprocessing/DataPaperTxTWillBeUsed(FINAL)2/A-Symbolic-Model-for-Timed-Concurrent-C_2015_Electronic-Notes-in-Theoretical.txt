Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 312 (2015) 161–177
www.elsevier.com/locate/entcs

A Symbolic Model for Timed Concurrent Constraint Programming
Jaime Arias1
Univ. Bordeaux, LaBRI, UMR 5800, F-33400 Talence, France CNRS, LaBRI, UMR 5800, F-33400 Talence, France

Michell Guzm´an2
Com`ete, LIX, Laboratoire de l’Ecole Polytechnique associ´e `a l’INRIA/CORDI-S. France DECC, Universidad del Valle. Colombia

Carlos Olarte3
ECT, Universidade Federal do Rio Grande do Norte. Natal, Brazil DECC, Pontificia Universidad Javeriana Cali. Colombia


Abstract
Concurrent Constraint Programming (ccp) is a model for concurrency where agents interact with each other by telling and asking constraints (i.e., formulas in logic) into a shared store of partial information. The ntcc calculus extends ccp with the notion of discrete time-units for the specification of reactive systems. Moreover, ntcc features constructors for non-deterministic choices and asynchronous behavior, thus allowing
for (1) synchronization of processes via constraint entailment during a time-unit and (2) synchronization of processes along time-intervals. In this paper we develop the techniques needed for the automatic verification of ntcc programs based on symbolic model checking. We show that the internal transition relation, modeling the behavior of processes during a time-unit (1 above), can be symbolically represented by formulas in a suitable fragment of linear time temporal logic. Moreover, by using standard techniques as difference decision diagrams, we provide a compact representation of these constraints. Then, relying on a fixpoint characterization of the timed constructs, we obtain a symbolic model of the observable transition (2 above). We prove that our construction is correct with respect to the operational semantics. Finally, we introduce a prototypical tool implementing our method.
Keywords: Concurrent constraint programming, temporal logic, model checking



1 Email: ariasalmeida@gmail.com
2 Email: michellrad@gmail.com
3 Email: carlos.olarte@gmail.com

http://dx.doi.org/10.1016/j.entcs.2015.04.010
1571-0661/© 2015 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

Introduction
In the last years we have seen how Concurrent Constraint Programming [20,21] (ccp) has been extensively used to specify and program concurrent systems. The increasing interest in the community for this powerful model of concurrency is per- haps due to its simplicity and tight connection to logic: processes tell and ask in- formation (formulas in logic) in a store of partial information; moreover, processes can be seen as both computing agents and as logic formulas. The use of ccp models has pervaded different areas in science (e.g., biochemical systems), engineering (e.g., security protocols, mobile and service oriented computing and social networks) and even the arts (e.g., tools for multimedia interaction)–see a survey in [17]. Never- theless, in spite of the many semantic and logical frameworks designed to reason about ccp processes, the automatic verification of ccp programs has received little attention so far.
This paper aims at providing the theoretical and practical tools to carry out the verification of systems specified in the ntcc [16] calculus, a timed extension of ccp to model reactive systems. For that, we propose a symbolic representation of the behavior of processes and we prove that such symbolic model is suitable to be used as a basis for standard techniques in model checking. One of the challenges to define such symbolic representation is that the operational semantics of ntcc is given by two different transition relations: the internal transition representing the steps of the processes during a time-interval and the observable transition describing how processes evolve along time-units. Moreover, the proposed model has to deal with two non-elementary temporal constructs in ntcc: ! P that executes infinite copies of P (one per time-unit) and ?P that describes asynchronous behavior by delaying P an unbounded (but finite) number of time-units. As we shall see, we can neatly characterize the behavior of these constructs by means of a fixpoint computation.
Organization and contributions. We start recalling the ntcc calculus in Section
2. Section 3 describes our approach to represent symbolically the behavior of ntcc processes. We prove that the symbolic model can be obtained for any process in a finite number of steps (Theorem 3.6) and also that our construction is correct with respect to the operational semantics (Theorem 3.9). In Section 3 we also present some examples to show how to compute the symbolic model of a process. Section 4 describes the logic that we shall use to specify properties and Section 5 shows how the symbolic model can be used in standard (symbolic) model checking algorithms. We conclude in Section 6 by pointing out to related work and briefly describing a prototypical tool implementing our methodology.
The ntcc Calculus
Concurrent Constraint Programming (ccp) [20,21] (seea survey in [17]) is a model for concurrency that combines the traditional operational view of process calculi with a declarative view based on logic. This allows ccp to benefit from the large set of reasoning techniques of both process calculi and logic.

Processes in ccp interact with each other by telling and asking constraints (pieces of information) in a common store of partial information. The type of constraints processes may act on is not fixed but parametric in a constraint system (CS). Intuitively, a CS provides a signature from which constraints can be built from basic tokens (e.g., predicate symbols) and variables, and two basic operations: conjunction (H) and variable hiding (∃). The CS defines also an entailment rela- tion (▶) specifying inter-dependencies between constraints: c ▶ d means that the information d can be deduced from the information represented by c. Such systems can be formalized as a Scott information system as in [21], or they can be built upon a suitable fragment of logic e.g., as in [10,16]. Here we shall follow the second approach and constraints are seen as formulas in intuitionistic logic.
Definition 2.1 (Constraint System) A constraint system is a tuple (C, ▶) where C is a set of formulas (constraints) built from a ﬁrst-order signature and the follow- ing grammar
F := true | A | F ∧ F | ∃x.F
where A is an atomic formula. We shall use c, cj, d, dj, etc, to denote elements of
C. Moreover, let Δ be a set of non-logical axioms of the form ∀x.[c ⊃ cj] where all free variables in c and cj are in x. We say that d entails dj, written as d ▶ dj, iff the sequent Δ,d −→ dj is probable in LJ [13].
Process Syntax
The ntcc calculus [16] extends ccp with time-units for the specification of reactive systems, i.e., systems that continuously interact with the surrounding environment. In this language, time is conceptually divided into discrete intervals (or time-units). Intuitively, in a particular time interval, a process P receives a stimulus (i.e., a constraint) from the environment, it executes with this stimulus as the initial store, and when it reaches its resting point, it responds to the environment with the resulting store. The resting point also determines a residual process Q, which is then executed in the next time interval.
Definition 2.2 (Syntax) Processes P, Q, . . . ∈ Proc are built from constraints in the underlying constraint system as follows:

P, Q,... ::= tell(c) | Σ

i∈I
when ci do Pi | P  Q | local x(P )

| next P | unless c next P | ! P | ?P 
Untimed processes. The process tell(c) adds the constraint c to the current store, thus making c available to other processes in the current time interval. Let I
be a finite set of indexes. The ask process Σ when ci do Pi non-deterministically
i∈I
chooses a process Pi s.t. ci is entailed by the current store. The chosen alternative,
if any, precludes the others. If no choice is possible in the current time-unit, all the alternatives are precluded from execution. Ask processes thus define a powerful synchronization mechanism based on entailment of constraints. For the sake of read-
ability, we shall omit “Σ” when I is a singleton and we simply write when c do P .
i∈I

	d ▶ ci,  i ∈ J	

(X; tell(c), Γ; d) −→ (X; Γ; c ∧ d) RTELL
(X; Σ	when c do P , Γ; d) −→ (X; P , Γ; d) RASK



x ∈/ X ∪ fv(d) ∪ fv(Γ)


(X; local x(P ), Γ; d) −→ (X ∪ {x}; P, Γ; d)

RLOC
d ▶ c
(X; unless c next P, Γ; d) −→ (X; Γ; d)

RUNL





(X;! P ; Γ; d) −→ (X; P, next ! P ; Γ; d)
	n ≥ 0	
RREP	(X; ?P, Γ; d) −→ (X; next nP, Γ; d) RSTAR



(X; Γ; c) ≡ (Xj; Γj; cj) −→ (Y j; Δj; dj) ≡ (Y ; Δ; d) (X; Γ; c) → (Y ; Δ; d)

RSTR
(∅; Γ; c) −→∗ (X; Γj; d) /−→


(c,EX.d)
Γ ====⇒ local X(F (Γ ))

ROBS


Fig. 1. Internal (—→) and ObservΣable (=⇒) transitions. Let Γ = {P1,..., Pn}. The future of Γ, F (Γ), is
{FP (P1),..., FP (Pn)} where FP (  j∈J when cj do Pj )= $ and FP (next Q)= FP (unless c next Q)= Q.
The set of free variables in d (resp. P ) is denoted as fv (d) (resp. fv (P )).

The process P  Q represents the parallel composition of P and Q. The process local x(P ) behaves like P , except that all the information on x produced by P can only be seen by P , i.e., x is a local variable of P .
Timed processes. The process next P delays the execution of P for one time-unit. We shall use nextn P as an abbreviation for next next ··· next P where next is repeated n times. The process unless c next P is also a unit delay but the process P is executed in the next time-unit only if the guard c cannot be entailed from the current store. This is known as a negative ask or the preemption of P .
The process ! P represents unboundedly many copies of P but one per time- unit. This is, ! P can be seen as P  next P  next 2P ··· . This construct is powerful enough to encode some forms of recursive definitions in ntcc as shown in [16]. Finally, the process ?P represents an arbitrary long but finite delay for the activation of P . This process can be viewed as P + next P + next 2P + .. ..

Structural Operational Semantics (SOS)
The SOS of ntcc consists of two kind of reductions: the internal transition (−→) representing the evolution of processes during a time-unit and the observable tran- sition (=⇒) representing the evolution of processes between time-units.
The internal transition relation γ −→ γj satisfies the rules in Figure 1. Here we follow the formulation in [10] where the local variables created by the program appear explicitly in the transition system and parallel composition of agents is identified as a multiset of agents. More precisely, a conﬁguration γ is a triple of the form (X; Γ; c), where c is a constraint representing the store, Γ is a multiset of processes, and X is a set of hidden (local) variables of c and Γ. The multi- set Γ = {P1, P2,..., Pn} represents the process P1  P2  ...  Pn. We shall indistinguishably use both notations to denote parallel composition of processes. Moreover, processes are quotiented by a structural congruence relation ∼= satis-

fying: (STR1) local x(P ) ∼= local y(P [y/x]) if y ∈/
fv(P ) (alpha conversion);

(STR2) P  Q ∼= Q  P ; (STR3) P  (Q  R) ∼= (P  Q)  R. We shall write

(X; Γ; c) ≡ (Xj; Γj; cj) whenever X = Xj, Γ ∼= Γj and c ≡ d (i.e., c ▶ d and d ▶ c).
The rules in Figure 1 are straightforward realizing the operational intuitions given above: a tell agent tell(c) adds c to the current store d (Rule RTELL); the process   when ci do Pi executes Pi if its corresponding guard ci can be entailed
i∈I
from the store (Rule RASK); a local process local x(P ) adds x to the set of hidden variables X when no clashes of variables occur (Rule RLOC). Observe that rule RSTR can be used to do alpha conversion if the premise x ∈/ X ∪ fv (d) ∪ fv (Γ) does not hold; if the current store entails c, then the process P in unless c next P is not executed (Rule RUNL); the seemingly missing rule for the process next P is given by the Rule ROBS as explained below; the process ! P generates a copy of P and then, it is executed again in the next time-unit (Rule RREP); for a given n ≥ 0, the process ?P executes nextn P (Rule RSTAR).
Let us now describe the rule for the observable transitions. Rule ROBS says that an observable transition from P labeled with (c, ∃X.d) is obtained by performing a terminating sequence of internal transitions from (∅; Γ; c) to (X; Γj; d), for some Γj. The process to be executed in the next time interval corresponds to the future of Γj (i.e., F (Γj)) as shown in Figure 1. Note that the future function F is not defined for the processes tell(c), local x(P ), ! P and ?P since all these processes have an internal transition. Moreover, the variables in X are hidden by using existential quantification, i.e., the information about X is not visible from the final store d.
Definition 2.3 (Observable Behavior) Let P be a process and s = c1.c2.c3 ··· 
be an inﬁnite sequence of constraints. We say that P outputs sj = cj .cj .cj ··· under

input s if

P ≡ P1
(s,s′)

(c1,c′ )
====1⇒ P2

(c2,c′ )
====2⇒ P3

(c3,c′ )
====3⇒ · · ·
1 2 3

and we write P
j
====⇒. We deﬁne the input-output behavior of P as the set
(s,s′)

io(P )= {(s, s ) | P  ====⇒}.
Symbolic Model of ntcc Processes
Model Checking [6] (see a survey in [19]) is a well established technique for the automatic verification of systems. In this section, we show how to construct a symbolic, and then compact, model of the behavior of a ntcc process. Later, in Section 5, we shall use this model as input to a symbolic model checking algorithm. One of the main difficulties to develop automatic verification techniques for ntcc programs is the fact that the semantics of processes is given by two different tran- sition systems, namely, the internal (−→) and the observable (=⇒) transitions. On one hand, building a model for the internal transition seems to be unnecessary since the internal movements of a process during a time-unit are unobservable from the external environment. Moreover, abstracting away from the internal transition should lead to a more compact representation of the system, thus reducing the search space. On the other hand, the internal transition dictates much of the ob- servable behavior when non-deterministic processes are considered (see e.g., Rules

RASK and RSTAR). Our approach is then to use (temporal) formulas as a compact representation of the reachable states (i.e., stores) of a process. As we shall see, the proposed formulas capture the observable contributions (i.e., constraints) that processes can make to the final store; additionally, the internal (unobservable) tran- sitions are symbolically captured by logical connectives. More precisely, we shall follow the steps below:
Step 1: Give a logical interpretation of P (Definition 3.2). The interesting cases will be the temporal operators ! and ? that require a fixpoint characteri- zation.
Step 2: Perform a fixpoint computation to find a formula that models, sym- bolically, the reachable states of P .
Step 3: Deal with dead-ends, i.e., states without any transition.
Step 1: Logical Interpretation of Processes
We start by introducing some needed notation. The behavior of a process will be specified as a disjunction of formulas of the shape
◦0(c0) ∧ ◦1(c1) ∧· · · ∧ ◦n(cn)	(1)
where each ci is a constraint (Definition 2.1). Intuitively, the above formula reads as “c0 is valid in the current state and, after i observable transitions, ci holds”. The “◦” symbol corresponds to the next modality in Linear Time Temporal Logic (LTL)
[14] as described below. For the sake of readability, we write c instead of ◦0(c) and
(c) instead of ◦1(c). Moreover, we write
{{F 1,F 1, ··· ,F 1 }, {F 2,F 2, ··· ,F 2 }, ··· , {F m,F m, ··· ,F m }}
1	2	n1	1	2	n2	1	2	nm
instead of the following formula in disjunctive normal form
(F 1 ∧ F 1 ∧ ··· ∧ F 1 ) ∨ (F 2 ∧ F 2 ∧· · · ∧ F 2 ) ∨· · · ∨ (F m ∧ F m ∧· · · ∧ F m )  (2)
1	2	n1	1	2	n2	1	2	nm
Definition 3.1 (States) We shall use C◦ to denote the set of formulas built from the set of constraints C and the LTL operator ◦ (next). A state is a conjunction of C formulas of the shape c1 ∧ ··· ∧ cm. Two states A and B are equivalent if A ▶ B and B ▶ A. A C◦ formula of the shape F = A0 ∧ ◦(A1) ∧· · · ∧ ◦n(An) represents a label transition system (LTS) where there is a transition from state sx to state sy, notation sx ~ sy, if Ai (resp. Ai+1) holds in sx (resp. sy). We shall use L(F ) to denote such an LTS. Given an LTS L, we shall use state(L) (resp. trans(L)) to denote the set of states (resp. transitions) of L.
Now we are ready to give logical meaning to processes by using C◦ formulas.
Definition 3.2 (Symbolic Representation) Given a ntcc process P, let S(P ) be inductively deﬁned as in Figure 2 where μ (resp. ν) represents the least (resp. greatest) ﬁxpoint operator in the complete lattice ⟨L(C◦), ≤⟩ where L1 ≤ L2 iff state(L1 ) ⊆ state(L2 ) and trans(L1 ) ⊆ trans(L2 ).

S(tell(c)) = c	S(Σ	when ci do Pi) =  (¬ci) ∨  (ci ∧ S(Pi))

i∈I
S(P	Q)  = S(P ) ∧ S(Q)	S(local x(P ))	= ∃x.(S(P ))
i∈I

S(next P ) = ◦(S(P ))	S(unless c next P )	= (¬c ∧ ◦(S(P ))) ∨ c
S(?P )	= μY.(S(P ) ∨ ◦(Y ))	S(! P )	= νY.(S(P ) ∧ ◦(Y ))

Fig. 2. Symbolic representation of ntcc processes (Definition 3.2). ¬c denotes the absence of c.

Let us give some intuitions about the previous definition. A process tell(c)

defines a state where c holds. A process Σ
 

i∈I
when ci do Pi generates a state where

none of the guards hold (

i∈I
(¬ci)) and states where ci and S(Pi) hold. A process

P  Q defines states where both S(P ) and S(Q) hold. A local process local x(P )
generates a state where P holds but the information about x is irrelevant. A process unless c next P defines a state where c holds (and then P is not executed) and a state where c is absent (i.e., ¬c) and the states generated from P hold.
As shown in [16], the process ?P resembles the eventually modality ( ) in LTL. Then, the states generated by this process can be characterized as the least fixpoint of the disjunction of a state where P holds and a state where P holds in the next time-unit. Similarly, the process ! P resembles the always ( ) modality in LTL. Then, the generated states correspond to the greatest fixpoint of the conjunction of a state satisfying P and a future state where P also holds.

Step 2: Fixpoint Computation
Once we have the logical reading S(P ) of a given process P , we need to perform a fixpoint computation in order to obtain a C◦ formula representing symbolically the states of the system. Before giving some examples of this step, we need to define the degree of a formula (Notation 3.3 below) and a simple program transformation in order to capture correctly the state transitions.
Consider the process P = next tell(c). We know that S(P ) = ◦(c). Then, what should be the observable behavior of P during the first time-unit? We know that P does not add any information to the first time-unit. Then, we need to “complete” the formula ◦(c) to model the fact that P generates two states: s1 where no information can be deduced and s2 where c holds such that s1 ~ s2. We shall represent symbolically this situation as the formula true ∧ ◦(c).
Notation 3.3 (Empty States and Degrees) Let F = ◦0(c0) ∧ ◦1(c1) ∧ · · · ∧ 
n(cn), we shall say that the degree of F, notation degree(F ), is n. We shall assume that for every i ∈ 0..n in F, there exists ci such that ◦i(ci) occurs in F; in other case we assume that ci = true. For the sake of readability, we shall omit the true constraint and we shall write, for instance, ◦2(c) instead of true ∧ ◦(true) ∧ ◦2(c).
Now we introduce a simple program transformation needed to correctly capture the state transitions during the fixpoint computation. Let us explain the need of

P(tell(c), n) = tell(c ∧ stn)	P(Σ	when cj do Pj, n) = Σ	when cj ∧ stn do P(Pj, n)

Fig. 3. Labeling (see Definition 3.4).
such transformation with a simple example. Assume the processes P and Q below:
P = tell(c)  next tell(c)	Q =! tell(c)
We know that S(P ) = c ∧ ◦(c). Moreover, c ∧ ◦(c) is also a solution for the equation S(Q). In the first case, we want to represent the LTS where there are two different states s1 and s2, s1 goes to s2 (s1 ~ s2) and c holds in both states. In the second case, we want to represent an LTS with a single state s3 where c holds and, there is a loop in s3 (s3 ~ s3). Hence, how can we distinguish between the formula S(P ) and the solution of S(Q)? The idea is to label the constraints in order to specify that s1 and s2 above are different and there is a temporal dependency (transition) between them. For instance, in the case of S(P ) we shall produce a formula of the shape c1 ∧ ◦(c2) to distinguish the two occurrences of c in P . The labeling process is a simple program transformation as shown in the next definition.
Definition 3.4 (Labeling) Without loss of generality, we assume that for each i ∈ N, sti is a distinguished atomic constraint in the constraint system. Given a process P, we deﬁne inductively P(P, n) as in Figure 3. To simplify the notation, we shall write cn instead of c ∧ stn. Moreover, instead of c0 we shall write c.
The labeling process is also needed to produce a formula of the shape true0 ∧
(true1) ∧ ◦2(c2) instead of true ∧◦(true) ∧ ◦2(c) when the formula true ∧◦(true) is added to ◦2(c) as explained in Notation 3.3. This avoids, for instance, the un- wanted loop true ~ true when computing the model of a process of the shape next next tell(c).
Now we are ready to show the fixpoint procedure. The idea is to compute the LTS that satisfies the equation S(P(P, 0)). Recall that every state satisfies true and the constraint false only holds in an inconsistent store. Therefore, as standardly done, the computation for a solution of the equation μY.(F ∨◦(Y )) (resp. νY.(F ∧ ◦(Y ))) starts with Y0 = false (resp. Y0 = true). The following example finds the symbolic model for the process ! ? tell(c) that requires both, a least and a greatest fixpoint computation.
Example 3.5 Let P =! ? tell(c). We start by computing S(?tell(c)) = μX.(S(tell(c)) ∨ ◦(X)) as depicted in Figure 4a. Note that both X3 and X4 repre- sent the transition system in the same ﬁgure. Then X3 is the ﬁxpoint and we can use it to compute the meaning of “!”, i.e., νY.(X3 ∧ ◦(Y )) as shown in Figure 4b. Y2 is a solution for the equation S(P ) and it represents the LTS in Figure 4b.
The reader may wonder whether the fixpoint computation stops in a finite num- ber of steps in the presence of replicated (! P ) processes. The following theorem




X0 = false
X1 = c ∨ ◦(false) ≡ c X2 = {{c}, {◦(c)}}
X3 = {{c}, {◦(c)}, {◦2(c)}}
X4 = {{c}, {◦(c)}, {◦2(c)}, {◦3(c)}}




Symbolic model for ٨tell(c). X0 = false since we are computing a solution for μX.(S(tell(c)) ∨ ◦(X)) (a least fixpoint).



Y0 = true
Y1 = {{c}, {◦(c)}, {◦2(c)}, {◦(true)}}
Y2 = {{c, ◦(c)}, {c, ◦2(c)}, {c, ◦3(c)}, {◦(c)}, {◦(c), ◦2(c)},
{◦(c), ◦3(c)}, {◦2(c)}, {◦2(c), ◦3(c)}}




Symbolic model for ! ٨ tell(c).
Fig. 4. Label transition systems for the Example 3.5.
answers positively that question.
Theorem 3.6 Let P be a process and S(P ) = F (X1,..., Xn) be a formula where the variables X1,..., Xn occur in F preceded by either μ or ν. The ﬁxpoint of F can be reached in a ﬁnite number of steps.
Proof. The proof is a direct corollary from: (1) [22, Theorem 4.12] that shows that the output of P can be characterized by a finite subset of C (which is not necessarily finite); and (2) [22, Lemma 4.13] that shows that the number of different states P may generate is also finite. Hence, since the number of possible reachable states is the LTS L(S(P )) is finite, the fixpoint computation must terminate.	 

Dead-ends
After the fixpoint computation in the previous step, it may be the case that the resulting LTS has dead-ends, i.e., states without outgoing transitions. This happens when the process P is not a replicated (“!”) process. As a matter of example, consider the process P = tell(c) whose resulting LTS has a unique state c without transitions. We recall that processes in ntcc are supposed to react continuously with the environment. Then, in the case of tell(c), the process outputs c in the first time-unit and true in the subsequent time-units. Note that this behavior is in accordance with the operational semantics in Definition 2.3: the outputs of a process are always infinite sequences of constraints.
Hence, given a C◦ formula F of degree n representing an LTS with dead-end


Y0 = true
Y1 = {{signal, ◦(on1 )}, {¬(signal), ◦(off1 )}}
Y2 = {{signal, ◦(on1 ), ◦(signal), ◦2 (on1 )}, {signal, ◦(on1 ), ◦(¬signal), ◦2 (off1 )},
{¬signal, ◦(off1 ), ◦(signal1 ), ◦2 (on1 )}, {¬signal, ◦(off1 ), ◦(¬signal), ◦2 (off1 )}}
Y3 = {{signal, ◦(signal), ◦(on1 ), ◦2 (on1 ), ◦2 (signal), ◦3 (on1 )},
{signal, ◦(signal), ◦(on1 ), ◦2 (on1 ), ◦2 (¬signal), ◦3 (off1 )},
{signal, ◦(¬signal), ◦(on1 ), ◦2 (off1 ), ◦2 (signal), ◦3 (on1 )},
{signal, ◦(¬signal), ◦(on1 ), ◦2 (off1 ), ◦2 (¬signal), ◦3 (off1 )}
{¬signal, ◦(signal), ◦(off1 ), ◦2 (on1 ), ◦2 (signal), ◦3 (on1 )},
{¬signal, ◦(signal), ◦(off1 ), ◦2 (on1 ), ◦2 (¬signal), ◦3 (off1 )},
{¬signal, ◦(¬signal), ◦(off1 ), ◦2 (off1 ), ◦2 (signal), ◦3 (on1 )},
{¬signal, ◦(¬signal), ◦(off1 ), ◦2 (off1 ), ◦2 (¬signal), ◦3 (off1 )}}


Fig. 5. Transition system from Example 3.7.
states, we shall add to F (in conjunction) the states ◦n+1(truen+1)∧◦n+2(truen+1). Therefore, the dead-ends of F have a transition to a looping state where only true can be deduced.
Example 3.7 (Control System) Assume a simple control system that must emit the signal on in the next time-unit when the environment reports a given signal signal in the current time-unit. Otherwise, it must emit the signal off in the next time-unit. This can be modeled as the process
P =! (when signal do next tell(on)  unless signal next tell(off))
The symbolic model of P results from the formula S(P(P, 0)) =

νY.(((signal ∧ ◦(on1) ∨ ¬(signal)) ∧ (¬(signal) ∧ ◦(off1) ∨ signal)) ∧ ◦(Y ))
and the ﬁxpoint computation leads to the results in Figure 5.
Example 3.8 (Asynchronous Behavior) Consider now a control system that must emit the signal stop once an error is detected. Moreover, we know that the system is doomed to fail (due to the process ?tell(error) below):
P = ?tell(error) ! when error do ! tell(stop)
Note that as soon as the error signal is detected, the ask process executes the process ! tell(stop) and then, the constraint stop can be deduced from that time interval on. The symbolic model of ?tell(error) is given by the formula:
F1 = error ∨ ◦(error) ∨ ◦2(error)
that determines an LTS similar to that of Figure 4a.
The symbolic model of the process ! tell(stop) is stop ∧ ◦(stop) which deter- mines an LTS such that a state where stop holds is always followed by another state where stop also holds. The symbolic model of P and its corresponding LTS is shown in Figure 6.



Y2 = {{error, stop, ◦(stop), ◦(error), ◦2 (stop), ◦2 (error)},
{error, stop, ◦(stop), ◦(error), ◦2 (stop), ◦2 (¬(error))},
{error, stop, ◦(stop), ◦(¬(error)), ◦2 (stop), ◦2 (error)},
{error, stop, ◦(stop), ◦(¬(error)), ◦2 (stop), ◦2 (¬(error))},
{¬(error), ◦(stop), ◦(error), ◦2 (stop), ◦2 (error)},
{¬(error), ◦(stop), ◦(error), ◦2 (stop), ◦2 (¬(error))},
{¬(error), ◦(¬(error)), ◦2 (stop), ◦2 (error)},
{¬(error), ◦(¬(error)), ◦2 (¬(error))}}





Fig. 6. Symbolic model and LTS from Example 3.8.

We conclude this section by showing that our symbolic construction is correct. Recall that ci means c ∧ sti and ¬c means that c is absent. Since those constraints were introduced during the model construction procedure (and they do not make part of the original process), the correctness result can safely ignore those con- straints. Recall also that the resulting LTS does not have dead-ends, i.e., paths in it are infinite sequences of states.
Theorem 3.9 (Correctness) Let P be a process, F a solution for the equation S(P(P, 0)) and L be the LTS L(F ) as in Deﬁnition 3.1. Consider an inﬁnite sequence of constraints π. Then, π is a path in L iff there exists a sequence πi = c1.c2.c3. ··· such that (πi, πo) ∈ io(P ) where πo is like π but without any occurrence of constraints of the shape sti and ¬c.
Proof. The proof proceeds by induction on the structure of P . For the ⇒ part, assume that π isa path in the LTS L(F ). We shall show that the corresponding πo is indeed an output of P (for a given input πi). The interesting cases are those of the temporal constructs:
P = next Q. It is easy to see that πj, defined as π without the first element, is a path for the LTS L(S(Q)). By induction, there exists a πjo which is an output of
Q. Hence, it is easy to see that πo is indeed an output of P .
P = unless c next Q. If π(1) (the first element of π) isa state where c holds, the proof is trivial. If c does not hold in π(1), then we proceed as in the next case.
P =! Q. We know that F is a solution for the equation G(X)= S(Q) ∧ ◦X. Also, by induction, we know that any path πq in the LTS Lq = L(S(Q)) corresponds to an output πo of Q. Hence, any path starting in one of the initial states in Lq (and also in L(F )) corresponds to an output of Q. Furthermore, since F is a solution for G(X), any suffix of π corresponds also to an output of Q. Since all the suffixes of π (including π itself) are in the output of Q, we conclude that πo is an output of P .
P = ? Q. Note that F is a solution for G(X) = S(Q) ∨ ◦X. If we consider only fair paths in the LTS (i.e., π is not an infinite sequence where a Q-state is never visited) then there exists a suffix πj of π such that πjo corresponds to an output of
Q. By induction we can conclude that πo corresponds to an output of P .
The ⇐ side of the proof is analogous.	 
As we shall see in Section 5, the fairness condition needed to prove the case ?Q

·	·
⟨β, i⟩ |= true	⟨β, i⟩ |= false
·
⟨β, i⟩ |= c iff β(i) |= c	⟨β, i⟩ |= ¬F iff ⟨β, i⟩ |= F
⟨β, i⟩ |= ◦F iff ⟨β, i + 1⟩ |= F	⟨β, i⟩ |=  F iff ∀j≥i ⟨β, j⟩ |= F
⟨β, i⟩ |= F iff ∃j≥i s.t. ⟨β, j⟩ |= F
·
⟨β, i⟩ |= F1 ∧ F2 iff ⟨β, i⟩ |= F1 and ⟨β, i⟩ |= F2
·
⟨β, i⟩ |= F1 ∨ F2 iff ⟨β, i⟩ |= F1 or ⟨β, i⟩ |= F2
Fig. 7. Semantics of CLTL formulas.

is guaranteed by the model checking algorithm that considers fairness constraints.

The Language of Properties
Constraint Temporal Logic (CLTL). Since ntcc processes manipulate con- straints, it is reasonable to think that system properties must be stated in a logic able to deal with constraints. Hence, we shall use CLTL [16], a Linear Time Tem- poral Logic [14] where atomic formulas are constraints. Formulas in propositional CLTL are built from the grammar below:

·	·	·	·	·
F ::= true | false | c | F ∧ F | F ∨ F | ¬F | ◦ F |  F |  F

·	·	·	·	·
where c is a constraint. true, false, ∧, ∨ and ¬ represent the linear-temporal
logic true, false, conjunction, disjunction and negation respectively. These symbols should not be confused with their counterpart in the constraint system (i.e., true, false and ∧). Symbols ◦,  and  denote the LTL temporal operators next, always and eventually.
The interpretation structures of formulas in CLTL are infinite sequences of con- straints (as the observable behavior in Definition 2.3). We say that the infinite sequence of constraints β is a model of (or that it satisfies) a formula F , notation β |= F , if ⟨β, 1⟩ |= F . The meaning of ⟨β, i⟩ |= F is given in Figure 7.
While the semantics of CLTL is given by sequences of constraints, models of LTL formulas are sequences of states (maps assigning values to variables). The relation between satisfiability in CLTL and standard LTL [14] was established in
·	·
[22, Lemma 5.4]: A formula F is LTL satisfiable iff F ∧ ¬false is CLTL satisfiable.
Intuitively, the formula false (the constraint representing the inconsistent store) has at least one model (e.g., the sequence of constraints false.false ... ) while
·	·	·
false does not have any model (⟨β, i⟩ |= false). Then, the “ ¬false” part gets
rid of the CLTL models containing (the constraint) false. This result holds when negation has atomic scope, i.e., G must be an atom (i.e., a constraint) in all formula
·
of the shape ¬G. This is known in [22] as the restricted-negation formula condition.



Fig. 8. Example of a DDD structure. Image and example extracted from [15].
Representation of Constraints
Many of the systems modeled in the ntcc calculus make use of numerical constraints (see e.g., [17]). Hence, we use Difference Decision Diagrams (DDD) [15], a suitable extension of Binary Decision Diagrams (BDD) [4] to represent difference constraint expressions built from the syntax below:
φ ::= false | true | x − y < c | x − y ≤ c | ¬φ | φ1 ∧ φ2 | φ1 ∨ φ2
| φ1 −→ φ2 | φ1 →→ φ2 | ∃x.φ | ∀x.φ
A DDD can be seen as a directed acyclic graph where the set of vertex contains the terminals 0 and 1 and the non-terminals are φ formulas. The set of edges is given by the so-called high and low edges, (v, high(v)), (v, low(v)), for each non- terminal vertex. These edges represent the path taken by the DDD in case that the constraint in the vertex v holds or not. As an example, the Figure 8 shows the DDD corresponding to the expression φ =1 ≤ x − z ≤ 3 ∧ (y − z ≥ 2 ∨ y − x ≥ 0).
DDDs share a large number of features with BDDs. As BDDs, DDDs need to be ordered and reduced, but in the case of DDDs, it is more difficult to obtain a canonical representation of the boolean formula. To deal with this problem, in [15] the authors propose the use of path reduced DDDs, with the aim to obtain a semi- canonical data structure, thus reducing the complexity of handling constraints. In fact, most of the operations on DDDs run in constant time.
Symbolic Model Checking
In Section 3 we saw how to build a symbolic model which is a compact representation of the behavior of a ntcc process. In Section 4 we recalled the CLTL logic able to express temporal properties of ntcc processes. The last step is to use standard techniques from symbolic model checking to verify if a process satisfies a given property. This is done by combining the model of the system and the formula to be proved. In the following we give the relevant details to perform this step.
Recall from Section 4 that the satisfiability problem of CLTL can be reduced to the same problem in LTL. Moreover, as it was shown in [5], the model checking problem for LTL can be solved by reducing it to the symbolic model checking problem for Computation Tree Logic (CTL) [9] with fairness constraints. Then, we can use all the machinery and tools developed for CTL model checking to verify programs written in ntcc.
In CTL, unlike LTL, the temporal operator must be preceded by a path

quantifier. Such quantifiers define where the temporal formulas must hold in the computation tree: the quantifier A, stands for “every path”, and E stands for “there exists a path”. The temporal operators to build CTL formulas are: ◦G, which means that G holds at the next time; and GUH, which means that G holds until H holds. We recall that F can be defined as trueUF and F as ¬ ¬F . Hence, in the following, we shall only use the temporal constructs “◦” and “U”.
The algorithm. Given a process P and a CLTL property φ, we proceed as follows:
Obtain the DDD representation M for the model of the process P .
Compute the DDD representation T of the tableau for the (negated) formula
·
ψ = ¬(φ ∧ ¬false).
Build the set F with all the fairness constraints, i.e., all the subformulas in ψ
containing the U operator.
Obtain the product P (through DDD operations) between the model M and the tableau of T .
Apply the CTL symbolic model checking algorithm with fairness constraints F
over the symbolic product P and the property Etrue.
If the algorithm returns an empty set of states (satisfying the negated property), then P satisfies φ; otherwise, the algorithm returns the set of states satisfying the formula ψ as counterexamples.
Let us elaborate on the above steps. First we build the symbolic model of P as explained in Section 3. Then, as shown in [5], the states σ, σj ... in the tableau T correspond to pow(el (ψ)) where el (ψ) (the set of elementary formulas of ψ) is:


el (F )= F if F is an atomic formula.
el (¬F )= el (F ).
el (F ∨ G )= el (F ) ∪ el (G ).
el (◦F )= ◦F ∪ el (F ).
el(F UG)= ◦(F UG) ∪el (F ) ∪el (G ).

The transition relation T relies on the definition of the function sat (·) that maps subformulas into sets of states:


sat (G )= {σ | G ∈ σ} if G ∈ el (ψ).
sat (¬F )= {σ | σ /∈ sat (F )}.
sat (F ∨ G )= sat (F ) ∪ sat (G ).
sat (F UG )  =  sat (G ) ∪ sat (F ) ∩
sat (◦(F UG )).

Since we are dealing with formulas in LTL, the transition relation of T satisfies the following condition for any state σ: σ ∈ sat (◦F ) iff σj ∈ sat(F ) for all successor σj of σ.
The set F of fairness constraints corresponds simply to the set of subformulas of the shape F UG in ψ. The set of fairness constraints is needed for the model checking algorithm to guarantee that in any path π where the formula F UG holds, it must be the case that G eventually holds. This situation can be also explained

from the point of view of processes. Consider the process P = ?tell(fail) and the
·
formula φ =  ¬fail. We know that the model of P contains a loop where fail
does not hold (due to the loop true ~ true in the LTS). Then, without fairness constraints, we would be able to prove that P satisfies φ, which is wrong.
The product P is simply obtained by operations on DDD (see, e.g., [3]). This product corresponds to the model where the negation of φ (i.e., ψ) holds and also the model of the program. Then, by running the symbolic model checking algorithm with fairness constraints [4,19] on the formula Etrue, if the resulting set of paths is empty, P satisfies the property φ, otherwise, we can exhibit a counterexample.

Concluding Remarks
In this paper we introduced a symbolic model to capture the behavior of ntcc pro- cesses. We showed that the internal and the observable transition relations in ntcc can be neatly captured as temporal formulas. Such a compact representation was shown to be adequate to use standard techniques in model checking to automatically verify concurrent systems programmed in ntcc.
We implemented a tool in Ocaml (http://ocaml.org) to execute our verifica- tion process automatically. The power of functional programming, the compilation process and the type system of Ocaml, made possible to quickly develop such pro- totype. Moreover, we provide to users a more friendly way for writing programs in ntcc by parsing their syntax with ocamllex and menhir.
The tool receives as input the ntcc program and recursively computes its symbolic representation. In order to carry out the verification, the tool com- piles the symbolic model into the format of the model checker NuSMV (http:
//nusmv.fbk.eu/NuSMV/). Then, system properties can be verified on NuSMV. Moreover, the tool generates a PDF file with the LTS of the system as those shown in Section 3’ figures.
We do not describe the implementation of our tool in depth here in order to give a higher priority to the technical aspects of our approach. The reader can find the details of the implementation as well as the execution of the examples described in this paper at http://www.labri.fr/perso/jarias/symbolicMC.
Related work. The ideas of this paper stem mainly from the works in [16] and [22]. In [16] it was shown that the ntcc constructs ! and ? have a strong relation with the LTL temporal operators  and . Moreover, the duality of these operators as greatest and least fixpoints was studied to give a denotational semantics for ntcc processes based on closure operators. In [22] the author showed that the strongest postcondition of a process, notation (P ), can be characterized as a Bu¨chi automata. Roughly the set (P ) contains all the possible outputs of P regardless the input. This fact was used in [22] to show that the verification problem for ntcc is decidable. We used this fact here to prove the Theorem 3.6. The construction of the Bu¨chi automata in [22], however, has a non-elementary space complexity (i.e., the space complexity is worse than exponential). The construction we propose here is symbolic

thus ameliorating this situation: the states do not need to be explicitly enumerated and, using logical rules, some states can be reduced in early stages of the model construction.
Automatic verification techniques for languages based on the ccp model have been also studied in [1,2,12]. In those works, the target language is tccp [8]. Unlike ntcc, tccp does not consider constructs for asynchronous behavior (?P in ntcc). Moreover, the notion of time is identified with the time needed to ask and tell information to the store and the information in the store is carried through the time-units. Note that in ntcc the output in a time-unit is not related to the output in the previous time-unit. For this reason, the SOS of ntcc requires both an internal and an observable transition relation and thus, the above techniques for tccp cannot be used for the verification of ntcc programs.
Finally, we refer to the work in [18] where the authors use a symbolic rep- resentation based on LTL formulas to give meaning to temporal ccp processes. Such representation was proved useful to give meaning to processes engaging in divergent computations due to universally quantified asks (not present in ntcc).
Future work. Symbolic techniques in model checking aim at reducing the space and time needed to verify a given property, thus allowing for dealing with more complex systems [4,19]. However, the state explosion problem is unavoidable. In fact, the model checking algorithm for LTL is linear in the size of the model but exponential in the size of the formula to be verified. To mitigate this situation, we plan to provide tools for abstract debugging that allow the programmer to quickly find problems in her design before attempting the verification of more precise desirable properties. For that, we may rely on the abstract interpretation frameworks for the analysis of ccp programs that have been proposed in the literature (see e.g., [1,7,11,23]). Our idea is to use an abstraction of the constraint system in the lines of [11] in order to reduce the number of states generated by our technique.

Acknowledgment
We thank the anonymous reviewers for their detailed comments. The work of Arias has been supported by the ANR project OSSIA (ANR-12-CORD-0024).

References
Mar´ıa Alpuente, Mar´ıa del Mar Gallardo, Ernesto Pimentel, and Alicia Villanueva. An abstract analysis framework for synchronous concurrent languages based on source-to-source transformation. Electr. Notes Theor. Comput. Sci., 206:3–21, 2008.
Mar´ıa Alpuente, Moreno Falaschi, and Alicia Villanueva. A symbolic model checker for tccp programs. In Nicolas Guelfi, editor, RISE, volume 3475 of Lecture Notes in Computer Science, pages 45–56. Springer, 2004.
Randal E Bryant. Graph-based algorithms for boolean function manipulation. Computers, IEEE Transactions on, 100(8):677–691, 1986.

Jerry R. Burch, Edmund M. Clarke, Kenneth L. McMillan, David L. Dill, and L. J. Hwang. Symbolic model checking: 1020 states and beyond. Inf. Comput., 98(2):142–170, 1992.
Edmund M. Clarke, Orna Grumberg, and Kiyoharu Hamaguchi. Another look at ltl model checking.
Formal Methods in System Design, 10(1):47–71, 1997.
Edmund M. Clarke, Orna Grumberg, and David E. Long. Model checking and abstraction. ACM Trans. Program. Lang. Syst., 16(5):1512–1542, 1994.
Marco Comini, Laura Titolo, and Alicia Villanueva. Abstract diagnosis for timed concurrent constraint programs. TPLP, 11(4-5):487–502, 2011.
Frank S. de Boer, Maurizio Gabbrielli, and Maria Chiara Meo. A timed concurrent constraint language.
Inf. Comput., 161(1):45–83, 2000.
E Allen Emerson and Joseph Y Halpern. Decision procedures and expressiveness in the temporal logic of branching time. Journal of computer and system sciences, 30(1):1–24, 1985.
Francois Fages, Paul Ruet, and Sylvain Soliman. Linear concurrent constraint programming: Operational and phase semantics. Inf. Comput., 165(1):14–41, 2001.
Moreno Falaschi, Carlos Olarte, and Catuscia Palamidessi. Abstract interpretation of temporal concurrent constraint programs. TPLP, Published online on 10 February 2014.
Moreno Falaschi and Alicia Villanueva. Automatic verification of timed concurrent constraint programs.
TPLP, 6(3):265–300, 2006.
Gerhard Gentzen. Investigations into logical deductions. In M. E. Szabo, editor, The Collected Papers of Gerhard Gentzen, pages 68–131. North-Holland, Amsterdam, 1969.
Z. Manna and A. Pnueli. The Temporal Logic of Reactive and Concurrent Systems: Specification. Springer-Verlag, 1991.
Jesper B. Møller, Jakob Lichtenberg, Henrik Reif Andersen, and Henrik Hulgaard. Difference decision diagrams. In J¨org Flum and Mario Rodr´ıguez-Artalejo, editors, CSL, volume 1683 of Lecture Notes in Computer Science, pages 111–125. Springer, 1999.
Mogens Nielsen, Catuscia Palamidessi, and Frank D. Valencia. Temporal concurrent constraint programming: Denotation, logic and applications. Nord. J. Comput., 9(1):145–188, 2002.
Carlos Olarte, Camilo Rueda, and Frank D. Valencia. Models and emerging trends of concurrent constraint programming. Constraints, 18(4):535–578, 2013.
Carlos Olarte and Frank D. Valencia. Universal concurrent constraint programing: symbolic semantics and applications to security. In Roger L. Wainwright and Hisham Haddad, editors, SAC, pages 145–150. ACM, 2008.
Kristin Y. Rozier. Linear temporal logic symbolic model checking. Computer Science Review, 5(2):163– 203, 2011.
Vijay A. Saraswat and Martin C. Rinard. Concurrent constraint programming. In Frances E. Allen, editor, POPL, pages 232–245. ACM Press, 1990.
Vijay A. Saraswat, Martin C. Rinard, and Prakash Panangaden. Semantic foundations of concurrent constraint programming. In David S. Wise, editor, POPL, pages 333–352. ACM Press, 1991.
Frank D. Valencia. Decidability of infinite-state timed ccp processes and first-order ltl. Theor. Comput. Sci., 330(3):577–607, 2005.
Enea Zaffanella, Roberto Giacobazzi, and Giorgio Levi. Abstracting synchronization in concurrent constraint programming. J. of Functional and Logic Programming, 1997(6), 1997.
