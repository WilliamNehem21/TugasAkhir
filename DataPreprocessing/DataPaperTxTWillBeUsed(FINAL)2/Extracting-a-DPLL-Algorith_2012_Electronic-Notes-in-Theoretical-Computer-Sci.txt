Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 286 (2012) 243–256
www.elsevier.com/locate/entcs
Extracting a DPLL Algorithm
Andrew Lawrence 1,2 Ulrich Berger 3 Monika Seisenberger 4
Department of Computer Science Swansea University
Swansea, UK

Abstract
We formalize a completeness proof for the DPLL proof system and extract a DPLL SAT solver from it. When applied to a propositional formula in conjunctive normal form the program produces either a satisfying assignment or a DPLL derivation which shows that it is unsatisfiable. We use non-computational quantifiers to remove redundant computational content from the extracted program and improve its performance. The formalization is carried out in the Minlog system.
Keywords: DPLL, Program Extraction, Interactive Theorem Proving, SAT.


Introduction
In order for verification tools to be used in an industrial context they have to be trusted to a high degree and in many cases are required to be certified. We present a new application of program extraction to develop correct certifiable decision proce- dures. SAT-solvers are such decision procedures which attempt to solve the Boolean satisfiability problem. They are an important component in many contemporary verification tools. The majority of SAT-solvers used in an industrial context are based on the DPLL proof system. We have formalized a correctness and com- pleteness proof of the DPLL proof system in the interactive theorem prover Minlog [20,2,4]. Using the program extraction facilities of Minlog we have been able to obtain a formally verified SAT-solving algorithm. When run on a CNF formula this algorithm produces a model satisfying the formula or a DPLL derivation showing its unsatisfiability. Computational redundancy was then removed from the algo- rithm by labelling certain universal quantifiers in the proof as non-computational,

1 We would like to thank Invensys Rail UK for their support.
2 Email: csal@swansea.ac.uk
3 Email: u.berger@swansea.ac.uk
4 Email: m.seisenberger@swansea.ac.uk

1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.08.016

an optimisation available in the Minlog system. The performance of the resulting program was tested with a number of pigeon hole formulae.
Program extraction aims at producing formally verified programs from a con- structive proof. An example of early work with program extraction is that done in the Nuprl system [10]. Examples of program extraction in Minlog can be found in [5,3]. Other mature interactive theorem provers that support program extraction are Coq [6], which is based on the calculus of inductive constructions, and Isabelle [22,21], a generic theorem prover with extensions for many logics. More recently, other interactive theorem provers based on dependent types [PM80], such as Agda
[9] and Epigram [18], have emerged which realise the Curry-Howard correspondence [12,13] and therefore can also be viewed as supporting program extraction.
Several attempts have been made to integrate an automatic theorem prover into Coq. Most of this work has made use of Coq’s program extraction facilities to extract programs from proofs of decision procedures. A SAT-solver based on the DPLL algorithm has been formalized and its soundness and completeness are veri- fied in Coq [15] and code has been extracted from the proof. Finally, the extracted system has been instantiated on the propositional fragment of Coq’s logic creating a user friendly proof tactic. Binary decision diagrams have been formalized in Coq [26]. Then their correctness has been proven, and certified BDD algorithms have been extracted in Caml. The main reason for their formalization was to integrate symbolic model checking in Coq.
Significant work has also been performed in Isabelle with several decision pro- cedures having been verified and integrated into the system. The DPLL algorithm has been formalized in [16]. The automatic theorem prover Metis [23] was formally verified inside Isabelle and is now used to reconstruct proofs from faster external procedures such as the ones used in Sledgehammer [8].
The approaches [15,16] to formalizing a DPLL SAT-solver in both Coq and Isabelle involve explicitly stating the algorithm to be verified. In contrast, we prove a theorem that just states that each formula in CNF is either unsatisfiable or has a model, and synthesise the program from the proof. In the long run we would like to integrate automatic verification techniques into Minlog. Extracting a SAT-solver in Minlog is one step towards our end goal.
Preliminaries
We begin with some basic definitions, following [15,16].

Definition 2.1
A literal l is either a positive variable +v or a negative variable −v, i.e. a variable v with a label + or − attached.
We define a bar operation which computes the opposite value of a literal as follows; +v = −v, −v = +v.
We set Var(+v)= Var(−v)= v, Var(L)= {Var(l) | l ∈ L} for a set of literals

L, and Var(Δ) = S{Var(L) | L ∈ Δ} for a set of sets of literals Δ.
A clause C is a finite set of literals {l1,..., lk}, to be viewed as the disjunction of the literals.
A formula is in conjunctive normal form (CNF) if it is a finite conjunction of clauses. By a formula Δ we will always mean a formula in CNF, and we will identify it with a finite set of clauses {C1,..., Ck}, representing the conjunction of the Ci.
A valuation Γ is a finite set of literals {l1,..., lk} to be viewed as the conjunc- tion of the elements.
A valuation Γ is consistent (cons(Γ)) if ∀l (l ∈ Γ → l ∈/ Γ).
A model is a total function M which maps literals to booleans and satisfies the property ∀l (M l ↔ ¬M l).
We shall use the abbreviations
M |= Γ, for ∀l ∈ Γ (M l) (“M is a model of Γ”),
M |= Δ, for ∀C ∈ Δ ∃l ∈ C (M l) (“M is a model of Δ”).
We call a valuation Γ and a formula Δ compatible (compatible(Γ, Δ)) if there exists a model satisfying both, i.e. ∃M (M |=Γ ∧ M |= Δ); otherwise Γ and Δ are called incompatible (incompatible(Γ, Δ)).
Definition 2.2 A sequent Γ ▶ Δ is a pair consisting of a valuation and a formula.
The intended meaning of a sequent Γ ▶ Δ is that Γ and Δ are incompatible. As a special case, when Γ is empty, ▶ Δ means that Δ is unsatisfiable. In the following we use the notations X, a := {x | x ∈ X ∨ x = a} (adding a to the set X) and X \ a := {x | x ∈ X ∧ x /= a} (removing a from X).
Definition 2.3 [DPLL Proof System] The DPLL proof system consists of five rules:

Γ,l ▶ Δ Γ ▶ Δ, {l}
Unit
Γ,l ▶ Δ,C 
Γ,l ▶ Δ, (C, l)
Red
Γ,l ▶ Δ
Γ,l ▶ Δ, (C, l)
Elim




Γ ▶ Δ, ∅
Conflict
Γ,l ▶ Δ	Γ, l ▶ Δ Split
Γ ▶ Δ

Soundness and Completeness
In this section we sketch the formal proof of soundness and completeness of the DPLL proof system. We will be very brief with the Soundness Theorem since its proof doesn’t carry computational content and a similar proof is carried out in [15,16]. On the other hand, we will describe the proof of the Completeness Theorem in some detail since we extract our SAT solver from it.
We first reformulate the DPLL proof system as an inductive definition that can be immediately formalized in the Minlog system. The definition has a clause for each rule. We notationally identify a sequent Γ ▶ Δ with the statement ”Γ ▶ Δ is derivable”.

Definition 3.1 The set of derivable sequents Γ ▶ Δ is defined inductively by the following (universally quantified) inductive clauses:
Conflict	∅∈ Δ → Γ ▶ Δ
Unit	{l}∈ Δ → Γ,l ▶ Δ \ {l}→ Γ ▶ Δ
Elim	l ∈ Γ → l ∈ C → C ∈ Δ → Γ ▶ Δ \ C → Γ ▶ Δ
Red	l ∈ Γ → l ∈ C → C ∈ Δ → Γ ▶ (Δ \ C), (C \ l) → Γ ▶ Δ
Split	Γ,l ▶ Δ → Γ, l ▶ Δ → Γ ▶ Δ
Theorem 3.2 (Soundness) If Γ ▶ Δ is derivable, then Γ and Δ are incompatible.
The proof proceeds by structural induction on the given derivation of the sequent Γ ▶ Δ. We omit further details.
We now turn our attention to the Completeness Theorem for the DPLL proof system. The expected statement of completeness is:
∀Γ, Δ (incompatible(Γ, Δ) → Γ ▶ Δ).
A constructive proof of this statement would yield a program that computes a DPLL proof for incompatible Γ, Δ. We reformulate the statement by replacing the implication ’incompatible(Γ, Δ) → Γ ▶ Δ’ with the classically equivalent but constructively stronger disjunction ’compatible(Γ, Δ) ∨ Γ ▶ Δ’. In this way, we obtain an enhanced program that still computes a DPLL proof for incompatible Γ, Δ, but in addition produces a model if Γ and Δ are compatible.
Theorem 3.3 (Completeness of DPLL)
∀Γ, Δ (compatible(Γ, Δ) ∨ Γ ▶ Δ)
Proof. We aim to perform the proof in such a way that an efficient program is extracted. Therefore, we adopt the following strategy:
Since performing a Split rule is the only computational expensive operation – it is the only rule forcing the proof search to branch – we only apply it when it is absolutely necessary.
We perform an optimisation on the proof level by partitioning the clauses into ’clean’ and ’unclean’ clauses, where a clause is called clean if we cannot apply Elim, Red or Unit to that clause. This increases the efficiency of the algorithm by reducing the number of comparisons needed.
To this end we show that for all valuations Γ, and formulas Δ, Θ,
∅ ∈/ Θ ∧ cons(Γ) ∧ Var(Γ) ∩ Var(Θ) = ∅→ 
(Γ ▶ Δ ∪ Θ) ∨ ∃M (M |=Γ ∧ M |=Δ ∪ Θ).
The proof is by main induction on the measure
μ(Γ; Δ; Θ) := |(Δ ∪ Θ) \\Var(Γ)| + #(Δ)+ #(Θ)

where
|X|	:=	the cardinality of a set X
Δ \\V	:=	{l|∃C ∈ Δ(l ∈ C ∧ Var(l) ∈/ V }
#(Δ)	:=	Σ	|C|
and a side induction on |Δ| (i.e. the number of clauses in Δ).
Let Γ, Δ, Θ be given such that ∅ ∈/ Θ, cons(Γ), and Var(Γ) ∩ Var(Θ) = ∅.
Case 1 Δ= ∅.
Case 1.1 Θ= ∅.
We define a model M by M (l)= True ↔ l ∈ Γ. Then M |=Γ ∧ M |= ∅ holds.
Case 1.2 Θ /= ∅.
Let C be a clause in Θ and let l ∈ C (C /= ∅, by the assumption on Θ). Then μ((l, Γ); Θ; ∅) < μ(Γ; ∅; Θ) since |Θ \\Var(l, Γ)| < |Θ \\Var(Γ)|. Furthermore, for the values (l, Γ), Θ, ∅ the hypotheses of the theorem are clearly satisfied. Hence the induction hypothesis for these values yields
(Γ,l ▶ Θ) ∨ ∃M (M |= Γ,l ∧ M |= Θ)	(1)
Similarly, we can apply the induction hypothesis to (l, Γ), Θ, and ∅ yielding
(Γ, l ▶ Θ) ∨ ∃M (M |= Γ, l ∧ M |= Θ)	(2)

The disjunctions (1) and (2) result in 4 cases: In the case that Γ,l ▶ Θ and Γ, l ▶ Θ hold the Split rule is applied and we obtain Γ ▶ Θ. In all of the other cases we use one of the models obtained from the induction hypotheses.
Case 2 Δ= Δj, C.
We perform a case distinction on whether the valuation Γ has a literal in common with C.
Case 2.1 Γ ∩ C = ∅.
We perform a further case distinction on the cardinality of the clause C.
Case 2.1.1 C = ∅.
It suffices to show Γ ▶ (Δj, ∅) ∪ Θ. This follows from the Conflict rule.
Case 2.1.2 C = {l}.
If l ∈ Γ, then Γ ▶ (Δj, {l}) ∪ Θ can be derived by applying (in backwards fashion)
the Red rule followed by the Conflict rule. If l ∈/ Γ, then we use the induc-
tion hypothesis with (Γ, l), Δj ∪ Θ, ∅. This is possible since μ((Γ, l); Δj ∪ Θ; ∅) < μ(Γ; (Δj, {l}); Θ) because |(Δj ∪ ({l}, Θ)) \\Var(Γ)| < |(Δj ∪ Θ) \\Var(Γ, l)| and #(Δj ∪ Θ) < #(Δj, {l}) + #(Θ). Since for the values (Γ, l), Δj ∪ Θ, ∅ the hypothe- ses of the theorem are satisfied (i.p. Γ,l is consistent since l ∈/ Γ), we obtain the

disjunction (Γ,l ▶ Δj ∪ Θ) ∨ ∃M (M |= Γ,l ∧ M |= (Δj ∪ Θ)). In the case that Γ,l ▶ Δj ∪ Θ holds we apply the Unit rule resulting in Γ ▶ Δ ∪ Θ. In the other case we have a model of Γ,l and Δj ∪ Θ which clearly also models Γ and Δ ∪ Θ.
Case 2.1.3 |C|≥ 2.
We perform a case distinction on ∃l (l ∈ C ∧ l ∈ Γ) ∨ ¬∃l(l ∈ C ∧ l ∈ Γ). This disjunction can be proven constructively, since the sets involved are finite.
Case 2.1.3.1 l ∈ Γ for some l ∈ C.
Then we have μ((Γ, l); (Δj,C\l); Θ) < μ(Γ; (Δj, C); Θ) since #(Δj,C\l) < #(Δj, C). The hypotheses of the theorem are satisfied for the chosen values. Hence we obtain, by induction hypothesis, (Γ ▶ (Δj, (C\lj))∪Θ)∨∃M (M |= Γ∧M |= (Δj, (C\lj))∪Θ). In the case that Γ ▶ (Δj, (C \lj))∪Θ holds, we apply the Red rule. In the other case we have a model of Γ and (Δj, (C \ lj)) ∪ Θ which also models the weaker formula (Δj, C) ∪ Θ.
Case 2.1.3.2 ¬∃l (l ∈ C ∧ l ∈ Γ).
In this case we may move C fromΔ to Θ: Since μ(Γ; Δj; (Θ, C)) ≤ μ(Γ; (Δj, C); Θ) we can apply the side induction hypothesis to Γ, Δj, (Θ, C). Since for these values the hypotheses of the theorem are satisfied we obtain Γ ▶ Δj ∪ (Θ, C) ∨
∃M (M |= Γ ∧ M |= Δj ∪ (Θ, C)) which is the same as the required disjunction Γ ▶ (Δj, C) ∪ Θ ∨ ∃M (M |=Γ ∧ M |= (Δj, C) ∪ Θ).
Case 2.2 Γ ∩ C /= ∅.
We can prove constructively that in this case Γ and C have some literal l in com- mon. We apply the induction hypothesis to Γ, (Δj, (C \ l)), Θ. Since clearly the measure decreases (#(Δj, (C \ l)) < #(Δj, C)) and the hypotheses of the theorem are satisfied, we obtain Γ ▶ (Δj, (C\l))∪Θ or ∃M (M |= Γ∧M |= (Δj, (C\l))∪Θ. In the first case we apply the Elim rule, in the second case we use the model provided. 2

Program Extraction
Program extraction in Minlog is based on modified realizability [14]. We highlight a few aspects that are important to understand the optimizations we achieved. For a complete and precise description of program extraction we refer to [25].
A formula is said to have computational content if it has at least one occurrence of ∃ or ∨ at a strictly positive position. To every such formula A one assigns a type τ (A) of ’potential realizers’. If the formula has no computational content, one sets τ (A)= ϵ. From a proof of a formula A with computational content one can extract a program M of type τ (A) that realizes A (written M r A), that is, M solves the computational problem expressed by A.
In order to fine-tune the computational content, in particular to remove re- dundant content, Minlog offers, besides the usual quantifiers ∀ and ∃, the non- computational (nc) quantifiers ∀nc and ∃nc. These have the same logical meaning as the usual quantifiers, but indicate that the extracted program does not operate

on the quantified variable, only on its realizer. The definitions of the type and the realizability relations for the ordinary quantifiers are:
τ (∀xρA)= ρ → τ (A) τ (∃xρA)= ρ × τ (A)

f r ∀xρA = ∀xρ(f (x) r A) (a, y) r ∃xρA = a r A[y/x]
Here, the notation xρ means x has type ρ. For the nc-quantifiers the realizers do not depend on the quantified variables:
τ (∀ncxρA)= τ (A)
τ (∃ncxρA)= τ (A)

a r ∀xρA = ∀xρ(a r A) a r ∃xρA = ∃xρ(a r A)
The program extraction procedure respects the different kind of quantifiers by omit- ting in the nc case any information corresponding to the quantified variable. The proof rules for the nc-quantifiers are subject to stricter variable conditions ensuring that the omitted information is indeed not needed in the extracted program. Minlog is able to automatically detect the maximal set of occurrences of quantifiers in a proof that can be made non-computational without compromising the correctness of the proof [24].
The Extracted Program
The extracted program has a similar structure as the proof. It takes a formula Δ in CNF as input and produces either a model of Δ or a derivation of unsatisfiability. The Minlog system automatically generates algebraic data-types for realizers of inductively defined predicates. For instance, the inductive definition of derivable is extracted into a data structure representing derivations in the DPLL proof system and induction proofs are translated into structurally recursive procedures. The control structure of the program closely follows the inductions and case distinctions we performed in the proof. The measure induction at the start of the proof turns into guarded recursion using the same measure in the program. The separate lemmas which we have used in the proof are invoked like procedures. The main benefit of the extraction process is that the code is generated automatically and hence no errors occur during coding. Furthermore, a formal correctness proof for the extracted program is automatically generated as well.
The main body of the program as extracted by Minlog is as follows:
cgRec([cs3](Rec list cla=>list cla=>valu=>
(list cla=>list cla=>valu=>algsuccess)=>algsuccess)
cs3 cbase cstep)

The first thing we see in the extracted program is a constant cgRec representing the guarded recursion. The latter corresponds to the definition:
(GRecGuard ρ1 ρ2 ρ3 τ )μ z1 z2 z3 Gt = f z1 z2 z3 t where
f : ρ1 ⇒ ρ2 ⇒ ρ3 ⇒ Boole ⇒ τ
f x1 x2 x3 True = G x1 x2 x3 ([y1, y2, y3].f y1 y2 y3(μ y1 y2 y3 < μx1 x2 x3)) f x1 x2 x3 False = Inhab 5
Similarly, it is possible to write the operation Rec list ρ ⇒ τ using a function
f : list ρ ⇒ τ which gives a more intuitive view of its behaviour.
(Rec list ρ ⇒ τ ) ys z G = f ys  where
f Nil = z
f (x :: xs)= Gx xs (f xs)

Execution of the Extracted Program
We have extracted two programs, one from the proof above (∀ solver) and one from the proof involving nc-quantifiers (∀nc solver). The nc-quantifiers were inserted at strategic places in the main proof, namely in inductive definitions and in the lemmas which are outside of the main proof. In the following we will see how both
∀ and ∀nc solvers behave when they are applied to a number of SAT problems. The extracted decision procedure was run on several instances of the pigeon hole principle [11]. The pigeon hole principle states that there is no injective function that maps {1, 2 ..., n} to {1, 2,...,n − 1}.
Definition 6.1 [Pigeon Hole Formula] PHP(n, m) := {{li,1,..., li,m}|1 ≤ i ≤ n}∪ 
{{li,k, lj,k}|1 ≤ i < j ≤ n, 1 ≤ k ≤ m}
Here li,k represents the statement “pigeon i sits in hole k”. The whole formula PHP(n, m) states that n pigeons sit in m holes such that no two pigeons are in the same hole. Hence, PHP(n, m) is satisfiable iff n ≤ m. For example, if we run our DPLL solver with the formula PHP(2, 1) = {{l11}, {l21}, {l11, l21}}, the following derivation is produced:
l11, l21 ▶∅ Conflict
 	Red
l11, l21 ▶ {l21}
   	Red
l11, l21 ▶ {l11, l21}
   	Unit
l11 ▶ {l21}, {l11, l21}
   	Unit
▶ {l11}, {l21}, {l11, l21}
Running the DPLL solver on a satisfiable formula results in a function which maps literals to booleans. For example running the solver with PHP(2, 2) results

5 Inhab is a dummy variable indicating a use of the axiom scheme efq: ⊥ → A.


	
in the function M : literals → B where M(l)= True iff l ∈ {l12, l11, l21, l22}.
Comparison of Program Performance with and without nc-Quantiﬁers
We have performed two comparisons between our extracted solvers with and with- out the ∀nc quantifiers. The first comparison is on unsatisfiable pigeon hole formulae PHP(n + 1, n) which will demonstrate the relative efficiency of the solvers in con- structing a derivation. The second comparison is on satisfiable formulae PHP(n, n). The programs have been run on the term level in the Minlog system using the built in term rewriting system. Therefore, the running times can not be expected to be competitive, but it is interesting to observe the relative difference between the two solvers.


These results demonstrate that the solver extracted from the proof containing the ∀nc quantifiers is significantly faster on unsatisfiable formulae than the solver extracted from the original proof. This is due to the number of non-computational quantifiers added to the definition of derivable. When applied to the pigeon hole formula PHP(6, 5) the ∀ solver takes 5 and a half hours where as the ∀nc solvers takes only 37 minutes.
Conclusion
In this paper we presented a new application of program extraction to decision pro- cedures. The DPLL proof system was formalized and then a constructive proof of completeness was performed from which we extracted a program. The extracted program attempts to show the (un)satisfiability of a propositional formula in con- junctive normal form (CNF). If the CNF formula is satisfiable it produces a model of the formula; otherwise it produces a derivation showing the unsatisfiability of the formula. We strategically inserted ∀nc quantifiers into the proof to reduce the com- plexity of the extracted program and increase its performance. The performance of the original solver was then compared with this improved solver using pigeon hole formulae.
Overall, the case study shows that the approach of developing verified programs via extraction from proofs is scalable to non-trivial applications.  Furthermore,

it demonstrates how to include efficiency considerations into this approach. For instance, we have avoided repeated unnecessary look-ups of clauses by the split of clause sets in two sets Δ and Θ. This counters the often heard argument that with program extraction one ’looses the grip’ on the program and its efficiency. It is important to note that these efficiency considerations do not compromise the correctness of the extracted program since these are applied at the proof level where correctness is guaranteed by the proof system. The big challenge, however, will be to extract from proofs also qualitative information about quantitative aspects of the extracted programs (e.g. computational complexity), for example, by combining approaches to implicit complexity with program extraction (see e.g. [1]).
Future Work
In order to apply the solver practically we need to translate the extracted Minlog term into a functional programming language such as Scheme or Haskell. Currently a translation mechanism from Minlog into Scheme is available, however it does not extract inductive definitions and general recursion. We would like to extend this translation to cover these definitions. Having our DPLL solver as a Haskell program would allow us to observe how lazy evaluation affects performance.
We further want to prove the equivalence of the DPLL proof system and the tree resolution proof system. This will allow us to extract a resolution solver based on the DPLL algorithm.
Extracting efficient data structures for our DPLL solver has the potential of greatly improving the efficiency of the solver and will provide another interesting example of program extraction. Since Haskell is based on lazy data structures such as tries, we would like to know whether a solver in Haskell would make use of these structures and gain something in efficiency. The solver would also benefit from a heuristics to select a splitting literal, currently it just selects the first literal in the formula Θ.
Our current solver could be further improved by adding optimisation techniques such as clause learning and conflict analysis [7,19,17]. This would require a modifi- cation of the current completeness theorem so that the derivation is performed with respect to an added implication graph.

References
Aehlig, K., U. Berger, M. Hofmann and H. Schwichtenberg, An arithmetic for non-size-increasing polynomial-time computation, Theoretical Computer Science 318 (2004), pp. 3–27.
Benl, H., U. Berger, H. Schwichtenberg, M. Seisenberger and W. Zuber, Proof theory at work: Program development in the Minlog system, in: W. Bibel and P. H. Schmitt, editors, Automated Deduction - A Basis for Applications II (1998).
Berger, U., S. Berghofer, P. Letouzey and H. Schwichtenberg, Program extraction from normalization proofs, Studia Logica 82 (2006), pp. 25–49.
Berger, U., K. Miyamoto, H. Schwichtenberg and M. Seisenberger, Minlog - A Tool for Program Extraction Supporting Algebras and Coalgebras, in: A. Corradini, B. Klin and C. Cˆırstea, editors, CALCO 2011, Lecture Notes in Computer Science 6859 (2011), pp. 393–399.

Berger, U., H. Schwichtenberg and M. Seisenberger, The Warshall algorithm and Dickson’s lemma: Two examples of realistic program extraction, Journal of Automated Reasoning 26 (2001), pp. 205–221.
Bertot, Y. and P. Cast´eran, “Interactive Theorem Proving and Program Development: Coq’Art: The Calculus of Inductive Constructions,” Texts in Theoretical Computer Science, Springer Verlag, 2004.
Biere, A., M. Heule, H. van Maaren and T. Walsh, “Handbook of Satisfiability,” Frontiers in Artificial Intelligence and Applications 185, IOS Press, Amsterdam, 2009.
B¨ohme, S. and T. Nipkow, Sledgehammer: Judgement day, in: J. Giesl and R. Ha¨hnle, editors,
Automated Reasoning, Lecture Notes in Computer Science 6173 (2010), pp. 107–121.
Bove, A., P. Dybjer and U. Norell, A brief overview of Agda — A Functional Language with Dependent Types, in: Proceedings of the 22nd International Conference on Theorem Proving in Higher Order Logics, Lecture Notes in Computer Science 5674 (2009).
Constable, R. L., “Implementing Mathematics with the Nuprl Development System,” Prentice-Hall, 1986.
Cook, S. A. and R. A. Reckhow, The relative efficiency of propositional proof systems, The Journal of Symbolic Logic 44 (1979), pp. 36–50.
Curry, H., R. Feys and W. Craig, Combinatory Logic, Studies in Logic and the Foundations of Mathematics 1 (1958).
Howard, W. A., The formulae-as-types notion of construction, To H. B. Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism (1980).
Kreisel, G., Interpretation of analysis by means of constructive functionals of finite types, Constructivity in Mathematics (1959), pp. 101–128.
Lescuyer, S. and S. Conchon, A Reflexive Formalization of a SAT Solver in Coq, in: O. A. Mohamed,
C. Mun˜oz and S. Tahar, editors, Theorem Proving in Higher Order Logics (TPHOLs 2008), Lecture Notes in Computer Science 5170, 2008.
Mari´c, F. and P. Janiˇci´c, Formal correctness proof for DPLL procedure, Informatica 21 (2010), pp. 57– 78.
Marques-Silva, J. P. and K. A. Sakallah, GRASP: A Search Algorithm for Propositional Satisfiability, IEEE Trans. Computers 48 (1999), pp. 506–521.
McBride, C., Epigram: Practical Programming with Dependent Types, Lecture Notes in Computer Science 3622 (2004), pp. 130–170.
Moskewicz, M. W., C. F. Madigan, Y. Zhao, L. Zhang and S. Malik, Chaff: Engineering an efficient SAT solver, in: Annual ACM IEEE Design Automation Conference (2001), pp. 530–535.
Minlog Proof Assistant, http://www.minlog-system.de.
Nipkow, T., L. C. Paulson and M. Wenzel, Isabelle/HOL: A Proof Assistant for Higher-Order Logic, Lecture Notes in Computer Science 2283 (1999).
Paulson, L. C., Isabelle: A Generic Theorem Prover, Lecture Notes in Computer Science 828 (1994).
Paulson, L. C. and K. W. Susanto, Source-Level Proof Reconstruction for Interactive Theorem Proving, in: Proceedings of the 20th International Conference on Theorem Proving in Higher Order Logics, TPHOLs’07 (2007), pp. 232–245.
Ratiu, D. and H. Schwichtenberg, Decorating proofs, in: S. Feferman and W. Sieg, editors, Proofs, Categories and Computations. Essays in honor of Grigori Mints (2010), pp. 171–188.
Schwichtenberg, H. and S. Wainer, “Proofs and Computations,” Cambridge University Press, 2012, 1st edition.
Verma, K. N., J. Goubault-Larrecq, S. Parsad and S. Arun-Kumar, Reflecting BDDs in Coq, in: ASIAN, Lecture Notes in Computer Science 1961 (2000), pp. 162–181.

Appendix: The Extracted Program
The appendix lists the full extracted program as it was produced by Minlog.
Main Program =
cgRec ([cs3](Rec list cla=>list cla=>valu=> (list cla=>list cla=>valu=>algsuccess)=>algsuccess) cs3 cbase cstep)

cgRec =
[(list cla=>list cla=>valu=>(list cla=>list cla=>valu=>algsuccess)=>algsuccess)_0,cs1,cs2,val3]
(list cla=>list cla=>valu=>(list cla=>list cla=>valu=>algsuccess)=>algsuccess)_0 cs1
cs2 val3 (
[cs4,cs5,val6]
(GRecGuard list cla list cla valu algsuccess) (
[cs7,cs8,val9]
Lh(toLit cs7)+Lh(toLit cs8)+Lh(setminus(varSetClaList(cs7++cs8))(varv val9))
)
cs4 cs5 val6
(list cla=>list cla=>valu=>(list cla=>list cla=>valu=>algsuccess)=>algsuccess)_0 (Lh(toLit cs4)+Lh(toLit cs5)+Lh(setminus(varSetClaList(cs4++cs5))(varv
val6))<Lh(toLit cs1)+Lh(toLit cs2)+Lh(setminus(varSetClaList(cs1++cs2))(varv val3)))
)

cbase =
[cs0,val1,(list cla=>list cla=>valu=>algsuccess)_2] [if cs0
(cModelCase val1) (
[c3,cs4]cSplitCase cs0 val1 c3 cs4(list cla=>list cla=>valu=>algsuccess)_2
)
]

cstep =
[c0,cs1,(list cla=>valu=>(list cla=>list cla=>valu=>algsuccess)=>algsuccess)_2,cs3,val4,(list cla=>list cla=>valu=>algsuccess)_5]
[if (vcIntersection val4 c0=(Nil lit)) [if c0
(
[ls6] [if ls6
(cConflictCase cs1 cs3 val4) (
[l7,ls8] [if ls8
[if (memlv(opposite l7)val4) (cElimConflictCase l7 cs1 cs3 val4)
(cUnitCase l7 c0 ls6 ls8 cs1 cs3 val4(list cla=>list cla=>valu=>algsuccess)_5)
]
(
[l9,ls10]
[if (cindmemlem(l7::l9::ls10)val4)
(cReduceCase cs1 c0 cs3 val4 ls6 l7 ls8 l9 ls10(list cla=>list cla=>valu=>algsuccess)_5)
(cCleanCase cs1 c0 cs3 val4 ls6 l7 ls8 l9 ls10(list cla=>valu=>(list cla=>list
cla=>valu=>algsuccess)=>algsuccess)_2(list cla=>list cla=>valu=>algsuccess)_5)
]
)
]
)
]
)
]
(cElimCase c0 cs1 cs3 val4(list cla=>list cla=>valu=>algsuccess)_5)
]

cConflictCase = [cs0,cs1,val2]csuccessZero cderivableZero


cElimConflictCase =
[l0,cs1,cs2,val3]csuccessZero(cderivableThree(CC l0:)(opposite l0)cderivableZero

UnitCase =
[l0,c1,ls2,ls3,cs4,cs5,val6,(list cla=>list cla=>valu=>algsuccess)_7]
[if ((list cla=>list cla=>valu=>algsuccess)_7(remccl(CC l0:)cs4++remccl(CC l0:)cs5)(Nil cla)(conclv l0 val6))
([algderivable8]csuccessZero(cderivableTwo l0 algderivable8)) csuccessOne
]

cReduceCase =
[cs0,c1,cs2,val3,ls4,l5,ls6,l7,ls8,(list cla=>list cla=>valu=>algsuccess)_9,l10] [if ( (list cla=>list cla=>valu=>algsuccess)_9
([if (l10=l5)
(CC(l7::ls8))
(conclc l5 [if (l10=l7)
(CC ls8)
(conclc l7(remlc l10(CC ls8)))
]
)
]::remccl(CC(l5::l7::ls8))cs0)
cs2
val3
)
([algderivable11]csuccessZero(cderivableThree(CC(l5::l7::ls8))(opposite   l10)algderivable11))
csuccessOne
]

cCleanCase =
[cs0,c1,cs2,val3,ls4,l5,ls6,l7,ls8,(list cla=>valu=>(list cla=>list cla=>valu=>algsuccess)=>algsuccess)_9,(list cla=>list cla=>valu=>algsuccess)_10] [if ((list cla=>valu=>(list cla=>list cla=>valu=>algsuccess)=>algsuccess)_9(CC(l5::l7::ls8)::cs2)val3(list cla=>list cla=>valu=>algsuccess)_10)
([algderivable11]csuccessZero(cderivableLemma(CF(cs0++(CC(l5::l7::ls8)::cs2)))   algderivable11))
csuccessOne
]

cElimCase =
[c0,cs1,cs2,val3,(list cla=>list cla=>valu=>algsuccess)_4]
[if ((list cla=>list cla=>valu=>algsuccess)_4(remccl c0 cs1)cs2 val3) ([algderivable5]csuccessZero(cderivableOne c0(cmemlemmaOne val3
c0)algderivable5)) csuccessOne
]

cSplitCase =
[cs0,val1,c2,cs3,(list cla=>list cla=>valu=>algsuccess)_4]
[if ((list cla=>list cla=>valu=>algsuccess)_4(c2::cs3)(Nil cla)(conclv(cSelectLemma c2 cs3)val1))
(
[algderivable5]
[if ((list cla=>list cla=>valu=>algsuccess)_4(c2::cs3)(Nil cla)(conclv(opposite(cSelectLemma c2 cs3))val1))
([algderivable6]csuccessZero(cderivableFour(cSelectLemma c2 cs3)algderivable5 algderivable6))
csuccessOne
]
)
csuccessOne
]

cModelCase = [val0]csuccessOne([l1]memlv l1 val0)

cSelectLemma = [c0,cs1]SelectLit c0
cmemlemmaOne = [val0,c1][if (vcIntersection val0 c1) (Inhab lit) ([l2,ls3]l2)] cderivableLemma =
[f0,algderivable1]
(Rec algderivable=>algderivable) algderivable1
cderivableZero ([c2,l3,algderivable4]cderivableOne c2 l3) ([l2,algderivable3]cderivableTwo l2) ([c2,l3,algderivable4]cderivableThree c2 l3)

([l2,algderivable3,algderivable4]cderivableFour l2) cemptyval =
[algderivable0]
(Rec algderivable=>algderivable) algderivable0
cderivableZero ([c1,l2,algderivable3]cderivableOne c1 l2) ([l1,algderivable2]cderivableTwo l1) ([c1,l2,algderivable3]cderivableThree c1 l2)
([l1,algderivable2,algderivable3]cderivableFour l1)
cemptyvalTwo = [val0,(valu=>algderivable)_1](valu=>algderivable)_1 val0

cDeriveRemoveLemma = [l0,l1,l2,ls3,cs4,cs5,algderivable6] (Rec algderivable=>algderivable) algderivable6
cderivableZero
([c7,l8,algderivable9] cderivableOne c7 l8) ([l7,algderivable8] cderivableTwo l7) ([c7,l8,algderivable9]cderivableThree c7 l8) ([l7,algderivable8,algderivable9]cderivableFour l7)

cindmemlem = [ls0]
(Rec list lit=>valu=>algindmem) ls0
([val2]cindmemOne) (
[l2,ls3,(valu=>algindmem)_4,val5] [if ((valu=>algindmem)_4 val5)
(
[l6]
[if (memlv(opposite l2)val5) (cindmemZero l2) (cindmemZero l6)
]
)
[if (memlv(opposite l2)val5) (cindmemZero l2) cindmemOne
]
]
)
