

Electronic Notes in Theoretical Computer Science 221 (2008) 207–217
www.elsevier.com/locate/entcs

Lower Bounds on the Continuation of Holomorphic Functions
Robert Rettinger1
Lehrgebiet Algorithmen und Komplexit¨at FernUniversita¨t Hagen
D-58084 Hagen Germany

Abstract
We show that continuation of holomorphic functions needs time at least Ω(n2) in the uniform case, which is optimal up to a polylogarithmic factor. In the non-uniform case, i.e. assuming f to be computable in time O(t) on an open subset of its domain, we show, that continuation of f cannot be robustly done in time
o(n · t(n)). This again is optimal up to a polylogarithmic factor.
Keywords: Type-2 theory, continuation, holomorphic functions

Introduction
It is well known that a holomorphic function f is uniquely determined by its values on any open subset of its (connected) domain. The question arises, whether a similar property also holds for computability or even complexity aspects of holomorphic functions, i.e. is a given holomorphic function, which is (efficiently) computable on a small open subset, also (efficiently) computable on all of its domain?
This continuation problem can be solved in time essentially O(n2) (uniformly
and up to a polylogarithmic factor) e.g. by following the ideas of [7] (see also [5]) and using FFT methods for interpolation (see e.g. [3],[2]). In the non-uniform case where we assume f to be a holomorphic function f which is computable in time O(t), this gives an upper time bound of essentially O(n · t(O(n))) (again up to a polylogarithmic factor). (We will give detailed definitions below.)
This rises the question, whether there exist further hidden symmetries of analytic functions, which allow faster continuation than stated above. In this paper we will show that this is not true in the general case, and even if we restrict ourself to

1 Email: robert.rettinger@fernuni-hagen.de

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.018

polynomial time computable mappings, such symmetries would have to heavily rely on complexity aspects of the machine model rather than on general analytic properties. The latter is the best we can say about this case, unless we prove some seemingly very hard and long standing conjectures in classical complexity theory. More precisely, we show that the upper bounds above are sharp. Whereas the lower bound in the uniform case follows easily from a combinatoric lemma which we will give in the next section, the non-uniform case is much harder to prove, and we will indeed only show that in this case the lower bound is optimal in a relativized setting. Beside giving the lower bounds in terms of the precision n we will also present lower bounds depending on further parameters.
Next we will introduce the main notions on representations and complexity, using essentially Type-2-Theory of computability and Ko’s machine model (see [6]). In Section 2 we will consider holomorphic functions on the unit disc, starting with a combinatorical lemma in Section 2.1 and giving the lower bounds in Section 2.2 afterwards. Finally, in Section 3, we show how these lower bounds can be extended to more general domains.
Let Σ be a finite alphabet, 0, 1 ∈ Σ. Furthermore let ⟨·, ·⟩ be an efficient pairing function on Σ∗, e.g. ⟨u, v⟩ = 0|u|1uv. We denote by Σ∗∗ the set of all (total) functions x : Σ∗ → Σ∗ and extend the pairing function ⟨·, ·⟩ to Σ∗∗ by ⟨p, q⟩(⟨u, v⟩) :=
⟨p(u), q(v)⟩ (for all p, q ∈ Σ∗∗ and u, v ∈ Σ∗).
In type-2 theory computability and complexity on spaces X are introduced via type-2 Turing machines and representations of X, i.e. surjective (partial) functions ν :⊆ Σω → X. Using Cantor space in the definition of representations works perfectly well for computability aspects and/or complexity on sets like R or C. For function spaces, however, using this definition of representations seems to be unnaturally restricting. For such spaces the oracle machine model used in [6] seems to be much more adequate. We use essentially this second model by using Σ∗∗ instead of Σω in the definition of representations, i.e. in the sequel we will consider a representation of a set X to be a surjective function ν :⊆ Σ∗∗ → X or ν :⊆ Σ∗ → X. Computability and complexity on such objects are then defined as usually once we have defined computability and complexity on Σ∗∗.
To this end we will consider oracle Turing machines, which are (multi-tape) Turing machines with an extra oracle state and two extra oracle tapes. Given an oracle A : Σ∗ → Σ∗, such a machine works as usually until it enters the oracle state. In this case the contents x of the first oracle tape is cleared and the contents of the second oracle tape is replaced by A(x), and the machine continues as usually. In the definition of its time complexity such oracle steps are counted as single steps. Now we say that a function f :⊆ Σ∗∗ → Σ∗∗ is computable in time t : Σ∗∗ × N → N if there exists some oracle Turing machine M so that for each oracle x ∈ dom(f ) and any y ∈ Σ∗ M computes (f (x))(y) ∈ Σ∗ in time t(x, |y|).
Given sets X and Y and representations ν :⊆ Σ∗∗ → X, ν' :⊆ Σ∗∗ → Y ' we say that a function f :⊆ X → Y is (ν, ν')-computable in time t : X × N → N iff there exist functions g :⊆ Σ∗∗ → Σ∗∗ and T : Σ∗∗ × N → N so that g is computable in time T and furthermore, for each x ∈ dom(f ) each w ∈ ν−1(x) and each n ∈ N, we

have ν'(g(w)) = f (x) and T (w, n) ≤ t(x, n).
Next we will fix standard representations for those sets we will use later on (we will frequently implicitly use these representations without further mentioning). To start with, let Y denote the set of dyadics, i.e. Y = {k · 2−l |k, l ∈ Z}. We take the signed digit representation as our standard representation νY for Y, i.e. let νY :⊆

Σ∗ → Y with Σ = {−1, 0, 1, |} be defined by νY(a1...an|b1...bm) = Σn
ai2n−i +

m
i=1
bi2−i for all a1, ...an, b1, ..., bm ∈ {0, 1, −1}. Using the pairing function ⟨·, ·⟩

we get immediately a standard representation νY[ˆι] of the complex dyadics Y[ˆι] by identifying the complex dyadics by pairs of dyadics as usual (ˆι denotes the square root of −1). The signed digit representation νR of R is then defined by νR(p) = x iff for each u ∈ dom(νY) we have |νY(p(u)) − x| < 2−|u| for all p ∈ Σ∗∗, x ∈ R and
u ∈ Σ∗. Similarly our standard representation νC of C is determined by νC(p) = x iff for each u ∈ dom(νY[ˆι]) we have |νY[ˆι](p(u)) − x| < 2−|u| for all p ∈ Σ∗∗, x ∈ R and u ∈ Σ∗.
Finally, we need representations of holomorphic functions. Though defining such representations in general is a difficult task, we can take a straight forward represen- tation in our case. This is mainly due to the fact that in order to treat continuation in a reasonable way one has to restrict the class of holomorphic functions by certain bounds on the absolute values they can take on their domain. As any bounded holomorphic function can be easily translated to a holomorphic function bounded by 1, we will restrict ourself to this case. Given a bounded domain G ⊆ C let HG denote the class of holomorphic functions f : G → D, where D denotes the unit disk D = {z ∈ C | |z| < 1}. For each domain G' ⊆ G we define a representation νG,G' of HG by means of evaluations, i.e. let νG,G' (p) = f iff for each u ∈ Σ∗ with νY[ˆι](u) ∈ G' we have |νY[ˆι](p(u)) −f (νY[ˆι](u))| < 2−|u|. In most cases we will choose G' to be some disk Dε := {z ∈ C | |z| < ε} or disks DδG := {z ∈ C | δG(z, 0) < ε} where we assume 0 ∈ G and δG is the hyperbolic metric on G.
Before we end this section a few remarks are in common. The oracle machine model we introduced can be easily extended to have multiple oracles. Furthermore we treated oracles as functions whereas in literature often sets are used. It should be clear that these models are equivalent. We introduced computability (complexity) of functions defined on some subset of Σ∗∗. Using the introduced products on this space we can extend these notions to any (Σ∗∗)k for any k ∈ N and even mixed products of Σ∗ and Σ∗∗ (by a suitable adaptation of the product ⟨·, ·⟩). We will use this without further mentioning.
Finally, we will use the O-notation in a sloppy manner. Let t be a function on a product X1 ×...×Xn of spaces (into R). Then we say t(a1, ..., an) ∈ O(α(a1, ..., an)), where α is some expression in the variables a1, ...,an, iff there exists some constant c so that for all (x1, ..., xn) in dom(f ) we have t(x1, ..., xn) ≤ c · α(x1, .., xn) + 
c. Similarly, the notion o(), Ω() and ω() are defined, e.g. we say t(a1, ..., an) ∈
Ω(α(a1, ..., an)) iff α(a1, ..., an) ∈ O(t(a1, ..., an)) etc.



Fig. 1. f is to be evaluated on z from it’s values on D1/α
Continuation on D
In this section we will restrict ourselves to the unit disc D, first, assuming the following situation (see Figure 1): The holomorphic function f is given by its values on some small disc D1/α ⊂ D around 0 (uniform case) or can be computed in time O(t) on D1/α (non-uniform case). Our task is to evaluate f with this information at some point z ∈ D with |z| = 1 − 1/β. (Later on we will frequently use zˆ instead of z to reuse z to denote other variables.)

Combinatorics
Let us assume the situation of Figure 1. How many values and what precisions do we need to continue f ? The answer will depend on the values α and β (and the precision n). Essentially there are two parameters, which influence the answer to the above question: By logα(β) let us denote





Furthermore let


logα
(β) = ⎧⎨ 1	if α ≥ β	.
⎩ [logα(β)| otherwise

Δγ (β) = (1 − 1 )γ − 1
	

α	β	αγ
for γ ≥ 1, where we omit the index γ in the case of γ = 1. The influence of the second parameter, Δα(β), is quite clear: if the point zˆ, to which we want to continue f , is near the disc D1/α, then we can evaluate a point near zˆ immediately, and thus
we know f (zˆ) to some precision. The influence of the former parameter logα(β) will play some role, if β is quite large and will become clear in Lemma 2.1 below. To simplify things, we will distinguish three cases, where Δα(β) is only considered in the first case. In all other cases we will restrict α and β so that this parameter has no influence on the results. Nevertheless, the role of Δα(β) can be studied in a similiar fashion for all these cases. More precisely, we consider the following cases, according to the influence of the above parameters on the number of values we have to evaluate f on:
β is quite small. In this case the distance Δα(β) between α and 1 − 1/β will have some influence on the number of values and the precision of evaluations,



whereas we can ignore logα(β).
β is of medium size, say 2 < β < 8. In this case we get a result, where the precision depends on α, the number of values we have to evaluate depends, however, only on the precision we want to achieve. Notice that the bounds on β are, of course, arbitrary. Actually any compact subintervall of R>1 could be chosen instead.
β is large, i.e. β ≥ 8. In this case, as in the last one, Δα(β) does not have any influence on our results. logα(β) will influence the precision we have to evaluate f to as well as the number of values.
With the above notations we can state our main combinatoric result as follows:
Lemma 2.1 Let c := 1/46, n ∈ N, 0 < 1/α < 1 − 1/β < 1 and zˆ be given so that


α ≥ 2, (1/2) · αlogα(β) · Δlogα(β)(β) =: s > 2 and |zˆ| = 1 − 1/β. Furthermore let

m ≤ c · n · β/(logα(β) − log(Δα(β)))
and z1,...,zm ∈ D(1/α) be given.
Then there exists a complex polynomial p so that
supz∈p(D)(|z|) ≤ 1,
supz∈p(D	)(|z|) ≤ 2−m·(log(s)−1)−n,
p(z1) = p(z2) = ... = p(zm) = 0 and
p(zˆ) = 2−n.
Furthermore p can be chosen to be computable from zˆ, z1,...zm and α.
Proof. Let α, β, n and m, points z1,...,zm ∈ D1/α and zˆ be given as above. Notice that by the restrictions on α and β we have αlogα(β) > 2.
To prove the result we essentially take Lagrange’s representation of polynomials: Let p be determined by
m	 

p(z) = 2−n ·	(zlogα(β) − zlogα(β))/(zˆlogα(β) − zlogα(β)).

Then items (iii) and (iv) in the statement of the lemma follow immediately. Item
(ii) can be seen as follows: For z ∈ D1/α we have

|p(z)| ≤ 2−n · (2 · (1/α)logα(β))m/((1 − 1/β)logα(β) − 1/αlogα(β)))m
≤ 2−n · (2/s)m.
To prove item (i) we will distinguish the cases as discussed above:

Case (a) We assume that β ≤ 2. First notice that in this case we have logα(β) = 1, so that the definition of p reduces to
p(z) = 2−n ·	(z − zi)/(zˆ − zi).
i=1m

To see item (1), i.e. to prove that |p(z)| is always smaller than 1, we can bound
  3/2  m

|p(z)|≤ 2−n · (1+ 1/α)m/((1 − 1/β − 1/α))m ≤ 2−n ·
Δα(β)

Thus item (1) follows from the fact that m ≤ n/(2 − log(Δα(β))) (i.e. a constant
c = 1/2 suffices in this case).

Case (b): We assume 2 < β < 8. Let us first bound Δlogα(β)(β): If α ≤ 8 we have Δlogα(β)(β)) ≥ 1/32 by the condition on s. If, on the other hand, α > 8, we have 1 − 1/β − 1/α > (3/8).
Thus we get for z ∈ D



log
(β)
3 m


If m < n/6 we get |p(z)|≤ 1, which is fulfilled by our condition on m.
Case (c): Let β ≥ 8. Then we have logα(β)+1 ≤ 1/2 · β. Furthermore we get (1+ 1/β)β ≤ e ≤ (1+ 1/β)β · (1+ 1/β) ≤ (1+ 1/β)β · 9/8

and



(1 − (logα(β)+ 1)/β)β ≥ e−(logα(β)+1)

≥ (1 − (logα(β)+ 1)/β)β · (1 − (logα(β)+ 1)/β)

≥ (1 − (logα(β)+ 1)/β)β · 1/2.

Thus we get for m¯ = m/β

|p(z)| ≤ 2−n · (9/8 · e)m¯ /((1 − 1/β)logα(β) − 1/β)m¯

≤ 2−n · (9/8 · e)m¯ /(1/2 · e−(logα(β)+1))m¯
≤ 1

whenever m¯ ≤ n/(log(9/4) + log(e)+ (logα(β) + 1) log(e)).

Notice that the polynomial p in the lemma above can be computed (from zˆ, z1,...zm and α) in polynomial time. We will not use this stronger statement. Furthermore the condition α ≥ 2 can be easily weakend by either extending case (2) in the proof above or using polynomials p(zt) where t = 1/ − log2(α).

Uniform and Computational Bounds
In this paragraph we will apply the above combinatorical lemma to achieve lower bounds on the complexity needed to continue a holomorphic function in the situation of Figure 1. Whereas the result in the uniform case follows easily from Lemma 2.1, we have to use a finite injury priority argument to prove the existence in the non- uniform case. To simplify things, let for given α > 0, β > 0 and n ∈ N the functions mˆ , pˆ :⊆ R+ × R+ × N → R be determined by

mˆ (α, β, n) = c · n · β/(logα(β) − log(Δα(β)))

and
pˆ(α, β, n) = mˆ (α, β, n) · (log(s(α, β) − 1) + n



where s(α, β) = (1/2) · αlogα(β) · Δlogα(β)(β) (see Lemma 2.1).
Theorem 2.2 Let α  ∈  [2; ∞) and M  be an oracle Turing-machine which
(νD,D  , νC, νC)-computes the function Fcont : HD × D → D deﬁned by
Fcont(f, z) := f (z)	(for all f ∈ HD and z ∈ D).
Then tM (f, z, n) ∈ Ω(mˆ (α, 1/(1 − |z|), n) · pˆ(α, 1/(1 − |z|), n)) for all α and β = 1/(1 − |z|) fulﬁlling the conditions of Lemma 2.1 (this means that there exists a common constant in the Ω-notation, which does not dependend on α and β !).
If q(α, f, z, n) denotes the number of questions of precision 2−pˆ(α,(1−|z|),n) M asks on input (f, z) for f ∈ HD and z ∈ D with α and β = 1/(1 − |z|) fulﬁlling the conditions in Lemma 2.1. Then we have q(α, f, z, n) ∈ Ω(mˆ (α, (1 − |z|), n)).
Proof. The first statement clearly follows from the second one. This second state- ment is a simple consequence of Lemma 2.1: Let α and β = 1/(1 − |z|) be given, so that the conditions of Lemma 2.1 are fulfilled. Let us first assume that z ∈ R+. Then M must on input p≡0, which is the constant polynomial 0, ask at least mˆ (α, β, n) questions of precision 2−pˆ(α,β,n). Otherwise we can replace p≡0 by the polynomial p given by Lemma 2.1, where the zi are those questions of M with precision at least 2−pˆ(α,β,n). Thus M cannot distinguish between p≡0 and p for the given precision, whereas p(z) = 2−n and p≡0(1 − 1/β) = 0.
Finally, for z /∈ R+, replace in the above proof p by p◦eˆιφ for suitable φ ∈ (0; 2π) so that eˆιφz ∈ R+.

Next to the non-uniform case:
Theorem 2.3 There exists a computable oracle A ∈ Σ∗∗ so that for all rational α, β, which fulﬁll the condition of Lemma 2.1, and all time-constructible t : N → N there exists a holomorphic function f : D → D which can be computed (with oracle A) in time O(t) on D1/α but cannot be computed (even with oracle A) in time O(T ) on D1−1/β for any T with n · t(n) /∈ O(T ).
Proof. Let in the sequel M0, M1, ... be an enumeration of all oracle machines. Furthermore let t0, t1, ... be the sequence of (partial) computable functions ti :⊆ N → N defined by Mi and similarly f0, f1, ... be the corresponding sequence of (partial) computable functions fi :⊆ D → D. We will assume that, given i, t, x, n ∈ N and z ∈ Y[ˆι], we can decide, wether tMi (x) ≤ t and tMi (n, z) ≤ t, respectively, which will be denoted by ti(x) ↓t and fi(n, z) ↓t, respectively. (Here tM denotes as usually the time complexity of M . Furthermore, by definition of computable functions on D above, n describes the precision, i.e. 2−n, we want to compute fi(z) to.)
Let Pol denote the class of complex polynomials. The oracle A will be given by a mapping A : N × ((0; 1) ∩ Y) × ((0; 1) ∩ Y) × N → Pol, which maps a precision n,

two parameters α and β as well as an index j (of tj) to a polynomial p (given by its values on D1/α). Here we will consider only those parameters α and β, which fulfill the condition of Lemma 2.1, i.e.


(1)	0 < 1/α < 1 − 1/β < 1 and (1/2) · αlogα(β) · Δlogα(β)(β) =: s(α, β) > 2.
Notice that by the standard representations, oracles indeed define functions in Σ∗∗, which are, moreover, computable whenever A is computable. We will thus in the sequel not distinguish between A and the corresponding function in Σ∗∗.
We will construct A so that for all α, β ∈ ((0; 1) ∩ Y) and j, so that tj is a total and monotone function, we have
z '→ limn→∞ A(tj(n)+ n, α, β, j)(z) is well defined and defines a holomorphic function fα,β,j : D1/α → D, which can be continued to D and
|A(tj(n)+ n, α, β, j)(z) − fα,β,j(z)| < 2−n for all z ∈ D1/α.
Items (A) and (B) above clearly show that the function fα,β,j is computable in time O(n+tj(n)) for each α, β ∈ ((0; 1)∩Y) and j so that tj is a total and monotone function.
To simplify the construction of the oracle A we will fix a few more notations: Let G :⊆ N × (0; 1) × (0; 1) × C∗ → Pol be the function, which for given n ∈ N, reals α and β and a sequence z1, ..., zm ∈ C∗ with m ≤ mˆ (α, β, n) determines the polynomial p of Lemma 2.1, i.e. a polynomial p with
p(D) ⊆ D,
p(z1) = p(z2) = ... = p(z) = 0,
p(1 − 1/β) = 2−n and
sup	(|p(z)|) ≤ 2−mˆ (α,β,n)·(log(s(α,β))−1)−n,
1/α
whenever α and β fulfill the conditions of this lemma. Furthermore let τ : (Y ∩ (0; 1))2 × N × N → N be a computable bijection (which can, for example, easily be defined by the product ⟨·, ..., ·⟩).
Next we will give the construction of A, which will be done in stages k = 0, 1, 2, .... In each stage we will construct some oracle Ak with the property that
for every w ∈ Σ∗ there exists some kw ∈ N so that Aj(w) = Ak (w) = Ak (w) for
w
all j ≥ kw. We will then take A to be the oracle which maps each w ∈ Σ∗ to this
stationary result Akw (w).
Beside the oracle Ak itself (and the values kw) we will maintain in every stage a sequence s0, s1, ... of natural numbers, where sr > 0 in stage k means
if Ak+t(w) = Ak(w) for all |w| ≤ sr and all t ∈ N, then there exists a n so that, with r = τ (α, β, i, j), fi computes not correctly the continuation of A(tj(n)+ n, α, β, j) to 1 − 1/β in time mˆ (α, β, n) · tj(n) and precision 2−n.
Finally, we will construct A so that sr keeps constant at a certain stage so that any functions in question are covered by condition (C):
Let i, j ∈ N and α, β ∈ Y ∩ (0; 1) be given so that α and β fulfill the conditions of Lemma 2.1, tj is monotone increasing and Mi stops on infinitely many inputs

(n, 1 − 1/β) in at most mˆ (α, β, n) · tj(n) steps: then there exists a stage k so that
sr > 0 keeps constant, where r = τ (α, β, i, j), for all stages ≥ k.
Notice that items (C) and (D) above guarantee that the functions fα,β,j cannot be continued from D1/α to D1−1/β in time O(T ), if n · tj(n) ∈/ O(T ) (where tj is a monotone increasing function). Thus once we have constructed A so that (A) to
(D) are fulfilled, the theorem is proven.
We will start our construction with sr = 0 and A0(n, α, β, j) = p≡0 for all r, n, j ∈ N and α,β ∈ (0; 1) ∩ Y, where p≡0 is the polynomial, which everywhere takes the value 0. In step k, k ≥ 0 we then construct Ak as follows:
Stage k: Do for each r = 1, ..., k the following computations, where we use the notation (α, β, i, j) = τ−1(r) and s' = maxt∈N st:
Step 1: If sr > 0 continue with the next r
Step 2: Compute s¯ = maxt<r(sr)
Step 3: Check for all n = s¯+1, ..., k, wether mˆ (α, β, n−2r−3)(log(s(α, β))−1) >
2r + 3, tj(n) ↓k and fi(n, 1 − 1/β) ↓mˆ (α,β,n)·tj (n)
if this is not the case, continue with the next r
Step 4: Because of the time restriction, fi can, on input (n, 1 − 1/β) only ask mˆ (α, β, n) questions of the form A(t, α, β, j)(z) up to precision 2−n for t ≥ tj(n)+ n and z ∈ Dα.
Let z1, ..., zm be the inqueried points of this type in Dα and p = G(n − 2r −
2, α, β, z1, ..., zm). Notice that this polynomial indeed exists as pˆ(α, β, n − 2r −
2) ≤ 2−n.
Let sr := mˆ (α, β, n) · tj(n)+ n + s', sl = 0 for all l > r and Ak(t, α', β', j') = Ak−1(t, α', β', j'), whenever (α', β', j') /= (α, β, j) or t < n + tj(n). Further- more, for t ≥ n + tj(n), let Ak(t, α, β, j) be Ak−1(t, α, β, j), if |fi(n, 1 − 1/β) − Ak−1(t, α, β, j)| > 2−n, and Ak−1(t, α, β, j) + 2−2r−1 · p, if |fi(n, 1 − 1/β) − Ak−1(t, α, β, j)|≤ 2−n in all other cases.
Fixing the values in this way will finish stage k (i.e. the remaining r's are not considered!)
If for none of the r = 1, ..., k step 4 above is computed, simply fix Ak = Ak−1.
To prove the correctness of the above construction we will first show that the construction indeed defines an oracle A:

Claim 2.4 For every w ∈ Σ∗ there exists some kw ∈ N so that Aj(w) = Ak
for all j ≥ kw.
(w)

Proof:	First notice that by the above construction, sr is only changed, if sr = 0 and sr is set to some sr > 0 or vice versa. sr is only changed to sr = 0 if for some smaller index l < r with sl = 0, sl is changed to some value sl > 0. Thus each of the cases can happen at most 2r − 1 times. This means that for each r there exists a stage kr, so that none of the values s1, ..., sr are changed after stage kr. Furthermore, for each w ∈ Σ∗ there exists some r so that sr > |w| at stage kr. Choosing kw to equal such a kr thus guarantee that At and Akw are equal for all t ≥ kw by our construction.





Finally we have to check that the items (A) to (D) above are fulfilled. Here item
(C) and (D) follows from our construction: To prove (D) assume that fi, tj, α and β are given as assumed in (D). Then there exists an infinite sequence (nt)t∈N ∈ NN so that fi(nt, 1−1/β) ↓mˆ (α,β,nt)·tj (nt) for all t. There exists a stage k, so that no value sr
with r < τ (α, β, i, j) is changed after step k. Let s¯ = max{s0, ..., sτ (α,β,i,j)} at stage
k. For large t with nt > max{k, s¯} and mˆ (α, β, nt − τ (α, β, i, j))(log(s(α, β)) − 1) > τ (α, β, i, j), τ (α, β, i, j) will be considered in Step 4 unless sτ (α,β,i,j) > 0 at this time. Thus sτ (α,β,i,j) > 0 at some stage k' > k and thus for all stages ≥ k'. To see
(C) let us assume that sτ (α,β,i,j) is set to some value > 0 at some stage k. Then in Step 4, for some n ∈ N, Ak(t, α, β, j), for t ≥ tj(n)+ n is chosen so that |fi(n, 1 − 1/β) −Ak(t, α, β, j)| > 2−n: In the first case, if this already holds for Ak−1 then the
oracle is kept unchanged. In the other case we have |fi(n, 1−1/β)−Ak(t, α, β, j)(1− 1/β)|≥ 2−2r−12−n+2r+3 −|fi(n, 1−1/β)−Ak−1(t, α, β, j)(1−1/β)| > 2−n. However, fi(n, 1 − 1/β) is supposed to be Ak(t, α, β, j)(1 − 1/β) up to precision 2−n.
To see that item (A) holds, let α, β and j be given. Then we add, in the worst case, for each i ∈ N and each time sr is changed, a polynomial 2−2r−1p, where r = τ (α, β, i, j) and p is a polynomial with p(D) ⊂ D. As we have seen above in the proof of Claim 2.4, the values sr can change at most 2r − 1 times to a non- zero value. Thus the sum of all these polynomials at a point in D is bounded by

∞
r=0
2r · 2−2r−1 ≤ 1. As this convergence is locally uniform, item (A) follows.

To see item (B), we can argue as before, as for each of the added polynomials p

for a precision 2−n and for z ∈ D1/α we have Σ∞
2r · 2−2r−1−n ≤ 2−n.


The result of the previous theorem can be extended in several ways. E.g. it is possible to give oracles so that the time bound T depends on α and β similar to Theorem 2.2.

Continuation on C
In this section we will turn to the problem of continuing holomorphic mappings to any point of their domain. This obviously is reasonable only for connected domains. By the Kreiskettenverfahren and Taylor-shifts (see e.g. [8]) we can continue along any path in the domain with roughly the time complexity needed to continue a function on D. Using Riemann mappings similar results are possible without Taylor- shifts. We use this method to give lower bounds, even their dependence on the parameter α and β = 1/(1 − |z|), on the complexity of continuation on bounded domains. To this end we will replace the parameters 1/(1 − |z|) and α using the hyperbolic metric δ.
First notice that there exist c1 > 0 and c2 > 0 so that for all z ∈ D, z /= 0:
c1 · 1/(1 − |z|) ≤ eδD(0,z) ≤ c2 · 1/(1 − |z|).

Using this inequality we can reformulate Lemma 2.1 and/or Theorem 2.1. In the uniform case we get the result immediately.
Theorem 3.1 Let G be a simply connected and bounded subset of C with 0 ∈ G. Furthermore let mˆ (α, β, n) and pˆ(α, β, n) be deﬁned as in Section 2.2 and M be an oracle Turing-machine, which (ν  DδG , νC, νC)-computes the function Fcont,G :
1/α
HG × C → C deﬁned by
Fcont,G(f, z) := f (z)	(for all f ∈ HG and z ∈ G)
in time tM .
Then tM (f, z) ∈ Ω(mˆ (α, eδG(0,z), n) · pˆ(α, eδG(0,z), n)) for all α and β = eδG(0,z)
fulﬁlling the condition of Lemma 2.1.
Proof.
Fix a Riemann mapping Q : D → G and translate Lemma 2.1 and thus Theorem
via Q to G.	 
Similarly one can apply the Riemann mapping to the construction in the proof of Theorem 2.2. Instead of altering the construction, however, we can simply add another oracle, say B, first, which allows to compute the Riemann mapping Q in linear time. Then we can literally use the construction given in the proof of Theorem
to get a suitable oracle. Notice, that whenever Q is computable, the oracle B is also computable. For conditions on G so that Q is computable see [4] (for complexity aspects see [1]).
Theorem 3.2 Let G be given as in Theorem 3.1. There exists a computable oracle A ∈ Σ∗∗ so that for all rational α, β, which fulﬁll the condition of Lemma 2.1, and all time-constructible t : N → N there exists a holomorphic function f : G → D
which can be computed (with oracle A) in time O(t) on DδG  but cannot be computed
(even with oracle A) in time O(T ) on DδG for any T with n · t(n) /∈ O(T ).

References
Binder, I. and Braverman, M. and Yampolsky, M., On computational complexity of Riemann mapping, Arkiv for Matematik, 2007, to appear.
Briggs, W. L. and Henson, V. E., The DFT: An Owner’s Manual for the Discrete Fourier Transform, Society for Industrial and Applied Mathematics, 1995.
Burrus, C. S. and Parks, T. W., Dft/FFT and Convolution Algorithms, Wiley, 1985.
Hertling, P., An effective Riemann Mapping Theorem, Theoretical Computer Science, 219:225–265, 1999.
Ko, K.-I and Friedman, H., Computing power series in polynomial time, Advances in Applied Math., 9:40–50, 1988.
Ko, K.-I, Complexity Theory of Real Functions, Progress in Theoretical Computer Science, Birkh¨auser, 1991.
Mu¨ller, N. Th., Uniform Computational Complexity of Taylor series, ICALP, Lecture Notes in Computer Science, 267:435–444, Springer-Verlag, 1987.
Sch¨onhage, A., Multiplicative Complexity of Taylor Shifts and a New Twist of the Substitution Method, FOCS, IEEE Computer Society, pp 212–217, 1998.
