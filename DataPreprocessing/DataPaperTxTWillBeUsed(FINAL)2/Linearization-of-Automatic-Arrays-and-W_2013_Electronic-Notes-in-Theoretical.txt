Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 298 (2013) 349–365
www.elsevier.com/locate/entcs

Linearization of Automatic Arrays and Weave Specifications
David Sprunger1
Department of Mathematics Indiana University Bloomington, Indiana

Abstract
Grabmayer, Endrullis, Hendriks, Klop, and Moss [6] developed a method for defining automatic sequences in terms of ‘zip specifications’ and proved that a sequence is automatic [2] iff it has a zip specification where all zip terms have the same arity. This paper begins by investigating a similar definitional scheme for the higher-dimensional counterpart of automatic sequences, automatic arrays. In the course of establishing the
results required for this machinery, we find an isomorphism–closely related to the z-order curve [8]–between a final coalgebra for arrays and the standard final coalgebra for sequences . This isomorphism preserves automaticity properties: an array is k, l-automatic iff its corresponding sequence is kl-automatic. The former notion of automaticity (k, l-automatic, note the comma) is defined for arrays as in [2], and the latter notion is the standard notion of automaticity for sequences. It also provides a convenient way to translate between stream zip specifications and array zip specifications.
Keywords: automatic sequence, automatic array, coalgebra, final coalgebra, z-order curve, zip specification


Introduction
The automatic sequences are a class of sequences arising naturally in both com- puter science and many different fields of mathematics [2]. A well-known automatic sequence, the Prouhet-Thue-Morse sequence, has been rediscovered over and over again by its appearances in combinatorics, algebra, number theory, differential ge- ometry, and combinatorial game theory. 2
As an example, sequences are interesting to algebraists as the expansions of numbers in particular bases. A number is rational, for example, iff its represen- tation in base k is an eventually periodic sequence of digits. Sequences which are eventually periodic are highly regular; at the other end of the spectrum are the

1 Email: dasprung@indiana.edu
2 See [1] for more details on the appearances of the PTM sequence.

1571-0661 © 2013 Elsevier B.V. Open access under CC BY-NC-ND license.
http://dx.doi.org/10.1016/j.entcs.2013.09.021

totally random sequences, the investigation of which relies primarily on probabilis- tic methods and/or information-theoretic methods. Automatic sequences form a class of sequences “more random” than the eventually periodic sequences and yet with enough structure that their properties can be investigated without needing probabilistic methods. Numbers whose base k expansion are automatic sequences are useful concrete examples in the study of transcendental numbers. Automatic sequences also play a crucial role in determining transcendence of power series over function fields—this is the content of Christol’s theorem [3].
While the identities and properties of particular automatic sequences are often encountered and used in mathematics, their definition and the method by which they are generated lies more naturally in the realm of theoretical computer science. Automatic sequences list the outputs of a simple class of automata on representa- tions of the natural numbers. This class of automata is a slight generalization of the better known deterministic finite automata (DFA), which is the preferred model in formal language theory for recognizing the regular languages. As a consequence of this similarity, the methodologies used for regular languages and automatic se- quences have strong similarities, but also have some important differences.
Regular languages enjoy a well developed notational system for defining lan- guages and language operations, namely regular expressions. Commonly juxtaposi- tion or · indicate language concatenation, L∗ denotes the Kleene closure of L, and
∪ or + commonly indicates the union of languages. Since the words in regular lan- guages are finite, this definitional scheme is able to compactly describe languages while simultaneously hinting at the structure of their elements.
On the other hand, the class of automatic sequences has necessarily infinite objects, so schemes giving a finite definition of even one element of this space require some thought. Given two finite presentations of infinite objects like sequences, it can be quite difficult to determine whether the two generated objects are even equal. To reason about infinite objects, principles of coinduction and corecursion arising from coalgebra are often employed, as introduced by Rutten [10]. Though the coalgebraic approach is not the original automata theory approach to regular languages, the theory of regular languages and DFAs has been recast in those terms by Rutten [9].
The standard finite scheme to present an automatic sequence is to give a finite automaton which generates that sequence. This scheme is useful when computing entries in the sequence, but suffers from some ambiguities involving input representation. [6] proposed an alternate definitional scheme which gives a sequence as the result interleaving the entries of other sequences. This work showed the collection of automatic sequences exactly coincides with the sequences that can be defined with zip specifications.
In this paper we first by summarize the main techniques used in [6] to define zip-specifications for automatic sequences. Then we begin to investigate a sim- ilar scheme for automatic arrays, which are a two-dimensional generalization of automatic sequences. This investigation will uncover an interesting isomorphism

between automatic arrays and sequences.
A brief introduction to automatic sequences, coalge- bras, and zip specifications
We begin by outlining the primary techniques used in the study of automatic se- quences and coalgebras. For readers seeking more details on the former topic there is a standard book by Allouche and Shallit [2]. For the latter, there are many papers by Rutten and many others expositing coalgebraic methods most notably [10], see also [7] particularly for coalgebraic methods applied to sequences of symbols. With some understanding of these techniques, we then turn to how these techniques are used to construct zip-specifications and check for equality of solutions.
Automata with output and automatic sequences
We now describe in greater detail the process of generating a sequence from an automaton [2,4]. A DFAO (Deterministic Finite Automaton with Output) is an automaton with the following components: an input alphabet (A), a finite set of states (Q), a designated start state (q0 ∈ Q), a transition map taking the current state and an input symbol and returning the next state (δ : Q×A → Q), an output alphabet (Δ) and an output map (f : Q → Δ). These generalize their better known cousin, the DFA, in that a DFA’s output alphabet is necessarily Δ = {accept, reject}.
We can extend a DFAO’s transition function from single letters in A to all words in A∗ with the following recursive scheme:

δ(q, w)=	q	if w = ϵ δ(δ(q, a), w∗)	 if w = aw∗

for w, w∗ ∈ A∗, a ∈ A and ϵ being the empty word in A∗. As we are about to note, this is not the only possible nor the only common way to extend the transition function to all of A∗. We will indicate that a DFAO uses this convention for its extended transition function by saying the DFAO “reads its input in left-to-right order” or “uses the frontwards order”.
We could alternatively extend a DFAO’s transition function to all of A∗ with a slightly different recursive scheme:

δ(q, w)=	q	if w = ϵ δ(δ(q, a), w∗)	if w = w∗a
In this case, we say the DFAO reads its input in the right-to-left order or the backwards order.
In either case, we say the DFAO outputs d ∈ Δ on input w ∈ A∗ if d = f (δ(q0, w)). We say a DFAO is a k-DFAO if |A| = k ∈ N and in this case assume A = {0, 1, 2,...,k − 1} = N<k. Note that each integer n is naturally associated to a

string in A∗: its standard base-k representation which we denote by [n]k ∈ N∗
. We

say a k-DFAO generates the sequence σ = σ0σ1σ2 ... σn ... if σn = f (δ(q0, [n]k)). That is, the DFAO outputs σn on the input [n]k. 3 If σ is a sequence generated by a k-DFAO, we say it is k-automatic.
At this point, there are a few good and well-answered questions to point out. How is the collection of sequences generated by k-DFAOs using the frontwards order related to the collection of sequences generated by k-DFAOs using the backwards order? Is it always possible to modify a k-DFAO to allow the representation [n]k to have leading 0’s without affecting the stream it generates? It turns out the collection of automatic sequences is exactly the same under each of these input conventions, and indeed the functions taking a DFAO with one input convention to the others are computable [2, p. 159].
Though it is more common in the general literature on automatic sequences to encounter the frontwards order input convention, when using coalgebraic techniques there are some reasons to prefer the backwards order convention. As a result, we will assume for the rest of the paper that all our automata read their input in the backwards order.

Coalgebras, ﬁnality and bisimulation
The next critical component in this machinery is the notion of coalgebras for a functor [10]. In this paper we will be considering the Set endofunctor F : X '→ Δ × Xk where the functor acts on arrows by sending the Set morphism f : X → Y to Ff : Δ × Xk → Δ × Y k defined by Ff = ⟨idΔ, f, f,...,f⟩. A coalgebra for this functor is a set C together with a function c : C → FC =Δ × Ck.
The map c is usually called the structure map for the coalgebra, while C is its carrier. We will often need to talk about the different components of the structure map, c = ⟨o, c0, c1,..., ck−1⟩, where o : C → Δ and ci : C → C. o is often called the observation component of the structure, while the ci are called the transitions for the structure.
We define the category of F -coalgebras as follows: objects in the category are F - coalgebras like (C, c) and a morphism of coalgebras ϕ : (C, c) → (D, d) is a function ϕ : C → D such that the following diagram commutes:
C   c	/Δ¸× Ck
ϕ	Fϕ 
J	J 
D 	/Δ¸× Dk
d
We say an F -coalgebra is final if it is a final object in the category of F - coalgebras. Final coalgebras are particularly important in the theory of coalgebras because there is a powerful technique for establishing the equality of two elements of a final coalgebra: bisimulation.

3 Note the DFAO is not a Mealy/Moore machine or other kind of simple transducer, so it is not generating this sequence in a single run. Each run of the DFAO produces a single output and by listing these individual results of each of the runs for these particular inputs we get a sequence.

A bisimulation on an F -coalgebra (C, c) isa relation R ⊆ C × C such that for all (x, y) ∈ R we have o(x)= o(y) and for all 0 ≤ i < k we have (ci(x), ci(y)) ∈ R. A standard theorem of coalgebra is that every bisimulation on a final coalgebra is a subset of the identity relation [10,11]. That is, if R is a bisimulation on a final coalgebra and (x, y) ∈ R, then x = y.

DFAOs and the set of sequences as coalgebras
Coalgebras and bisimulations are commonly used in the analysis of state transition systems and other process calculi. DFAs and DFAOs are simple examples of state transition systems and so they form a natural example of coalgebras and thereby a place to do bisimulations. Less readily apparent is the fact that there is also a coalgebra structure on the set of sequences themselves. 4
A k-DFAO generating an automatic sequence naturally gives an F -coalgebra via the structure map Q → Δ × Qk given by ⟨f, δ(·, 0), δ(·, 1),..., δ(·,k − 1)⟩. As a result of the so-called input robustness results mentioned in section 2.1, we can also assume without loss of generality that our DFAOs (which read in the backwards order) ignore leading zeroes. That is, we have f ◦ δ(·, 0) = f . This property, as will be discussed later, is called zero-consistency.
An important object in the study of automatic sequences is the so-called kernel of a sequence. To define this, we first define projection maps on the set of sequences in Δ. The projection πi,k : Δω → Δω is given by πi,k(σ)= σiσi+kσi+2k ... σi+nk ... =
{σi+nk}n. The k-kernel of the sequence σ is the set of all sequences which can be reached by repeatedly applying the maps π0,k, π1,k,..., πk−1,k to σ. A well-known theorem states that a sequence is k-automatic iff its k-kernel is finite [2, p. 185].
Now, it is a fact due to [7] and [6] independently that Δω is the carrier for a coal- gebra (Δω, ⟨hd, π0,k, π1,k,..., πk−1,k⟩) which is final for zero-consistent F -coalgebras, which form a subcategory of the F -coalgebras. Therefore there is a unique map, seq, such that the following diagram commutes:
Q	⟨f,δ(·,0),δ(·,1),...,δ(·,k−1)⟩	/Δ¸× Qk

seq
Jω 
F seq
J 
/¸

Δ
⟨hd,π0,k,π1,k,...,πk−1,k⟩
Δ × (Δω)k

The seq map takes a state q to the automatic sequence generated by the DFAO when using q as the start state.

The zipk function and zip-speciﬁcations
Now that we understand automatic sequences as coalgebras and can decide when two elements of a final coalgebra are equal, we are ready to discuss zip-specifications, as treated in [6]. The zipk function takes k sequences and merges them into a single sequence by alternating through their terms.  For example, zip2(σ, τ ) =

4 For more details on the coalgebraic structure of DFAs and their final coalgebra, see [9].

zip2(σ0σ1σ2 ..., τ0τ1τ2 .. .) = σ0τ0σ1τ1σ2τ2 .. .. The zipk function in some sense inverts the action of the k-kernel maps: πi,k(zipk(σ0, σ1,..., σk−1)) = σi and con- versely zipk(π0,k(σ), π1,k(σ),..., πk−1,k(σ)) = σ.
Using the zip function, we can set up systems of equations to define streams.
For example, the system


m =0: x
x =1: zip(x, y)
⎪⎩y =0: zip(y, x)
has the Thue-Morse sequence as the solution for m.

(1)

To be exact, a zip specification in an alphabet A is a set of variables, S, along with a zip term for each variable, where a zip term is generated by the BNF grammar
T ::= s | a : T | zipk(T,T,...,T )
where s ∈ S, a ∈ A, and k zip terms are provided as the argument for a term using the zipk rule. For example, zip2(1 : x, zip3(0 : y, x, 1 : 0 : z)) is a zip term in the alphabet {0, 1} with variables {x, y, z}. A zip specification gives a zip term for each variable in the set.
Grabmayer et al. [6] gave conditions for the existence and uniqueness of solutions to these zip specifications. Roughly stated, there is a solution to the specification if each variable is defined by exactly one zip term, and there is a unique solution if for each variable the first symbol of that variable’s term can be determined. They then proved that solutions to zip specifications where all terms using the zip function have arity k are k-automatic. This tells us that all solutions for the variables in specification (1) are 2-automatic, for example.
Generating an automaton for (1) is fairly straightforward. We start with the root (first) variable and apply the πi,2 maps just as if we’re generating the 2-kernel of a sequence, but we get state names instead. For example, π0,2(m) = π0,2(0 : x) = π0,2(01 : zip(x, y)) = 0 : π0,2(zip(x, y)) = 0 : x, so after reading 0, our automaton will transition from a state labelled m to a state labelled 0 : x. Similarly, π1,2(0 : x)= π1,2(01 : zip(x, y)) = 1 : y so the 1 transition out of 0 : x goes to 1 : y and so on. The full 2-DFAO for this specification is given below:


Now given a second zip specification, such as
⎧n =0: zip(1 : w, 1: u)
⎨u =1: zip(v, u)
⎪⎪⎩w = zip(n, v)



(2)

it is fairly straightforward to check that the first few entries in the solution for n match the first few entries for the solution of m, but is a nearly impossible game of index bookkeeping to check that they have the same values at all entries. To aid our understanding and to simplify matters we use the machinery of coalgebras. First we generate a 2-DFAO for this specification in the same manner as the one before it:

start	0




0

Next we find attempt to find a bisimulation from the first DFAO to the second relating m to n. R = {(m, n), (0 : x, 01 : u), (0 : x, n), (1 : y, 1: w), (1 : y, 1: v)} is such a bisimulation. Then if we apply the seq map to this bisimulation it remains a bisimulation in Δω. In particular, (seq(m), seq(n)) ∈ seq(R), which is a bisimulation in a final coalgebra, so seq(m) = seq(n). This allows us to conclude the sequence generated in the first DFAO starting from m is the same as the sequence generated from the second DFAO starting from state n.

Automatic arrays
Automatic arrays are a generalization of automatic sequences to two dimensions. [2, Ch. 14]
Let’s imagine we have a DFAO with input alphabet N<k × N<l. (We will some- times abbreviate this situation with the term k, l-DFAO.) We can encode a pair (m, n) ∈ N × N as a word in this alphabet in a standard way: we find the base-k representation of m, [m]k, and the base-l representation of n, [n]l, and pad whichever has fewer digits with leading zeroes until they are the same length. Then the stan- dard k, l-encoding of (m, n) is the sequence of pairs of these digits starting with the most significant digits.
For example, the standard 2,5-encoding for (13, 82) is formed by taking [13]2 = 1101 and [82]5 = 312 = 0312 and then forming pairs: (1, 0)(1, 3)(0, 1)(1, 2).

Now imagine a quarter infinite grid with positions indexed by N × N with the symbol at position (m, n) being the output of the DFAO when given the standard encoding for (m, n) in N<k × N<l. Such an infinite array is called a k, l-automatic array in analogy to the definition of automatic sequences. When the bases k and l can be inferred from context, we may abbreviate and use the term “automatic array”.
As an example consider the following automaton and the automatic array it generates below. 5 Note that this automaton has input alphabet N<2 × N<2.




start
(0, 0)

q0
0
(0, 1)
(1, 0)
(0, 0)

q1
1



(1, 0)
(1, 1)	(0, 1)

(1, 1)


Previously known results on automatic arrays
At this point the same kinds of questions that are natural for automatic sequences can be asked for automatic arrays. Does the collection of automatic arrays change if we make our k, l-DFAOs read in backwards order vs. frontwards order? Can we allow leading (0, 0) characters for these DFAOs without changing the notion of which arrays are k, l-automatic? These standard input robustness results work out the same way for automatic arrays as they do for sequences: changing the direction of the input and adding leading zeroes does not change the collection of automatic

5 This automaton is intentionally similar to the minimal automaton that generates the Thue-Morse se- quence. The array it generates is also intimately related to the Thue-Morse sequence. Every row and every column is the Thue-Morse sequence or the Thue-Morse sequence with 0 and 1 swapped. The array’s 2,2-linearization is also the Thue-Morse sequence. See 3.2.

arrays [2, p. 408].
Indeed, very many of the results for automatic sequences have a corresponding result for automatic arrays. One important example of this phenomenon regards

the kernel of an array. We define π i , j
to take an array a with entries am,n for all

k l
n, m ≥ 0 to the array with entries akm+i,ln+j for all n, m ≥ 0. Then the k, l-kernel
of the array a is the set of all arrays which can be reached from a by repeatedly

applying the functions π i , j
for i ∈ N<k and j ∈ N<l. It turns out the k, l-kernel of

k l
an array is finite iff the array is k, l-automatic [2, p. 409].
Weave specifications for automatic arrays
To establish results for zip specifications for sequences, several steps were needed. First, one must give conditions for existence and uniqueness of solutions to zip specifications. Then, for zip specifications fulfilling these criteria, one shows there is a natural way to produce a DFAO which generates the sequence which solves the zip specification. Lastly, using a final coalgebra one has a basis for determining equality of solutions to different zip specifications. We begin by developing this last step for automatic arrays.
Final coalgebras for automatic arrays
ω2
Denote by ArΔ =Δ	the set of all quarter-infinite arrays with symbols in Δ. Let
c : ArΔ → Δ be the function taking an array to its corner entry. That is, c(g)= g0,0. We will be showing that ArΔ with the transition structure given by the function c and the array projections π defined above make it into a final coalgebra.
Suppose we have a functor FX = Δ × Xkl and (G, s : G → Δ × Gkl) is a coalgebra for that functor. Then we name the kl + 1 components of the structure:
s = ⟨o, s(0,0), s(0,1),..., s(0,l−1), s(1,0),..., s(k−1,l−1)⟩
where o : G → Δ and s(i,j) : G → G. As before, o is the observation component of the structure, while the other components are the transition components of the structure. We say a coalgebra for this structure is zero − consistent when o = o◦s(0,0), which is to say applying the zero-transition doesn’t change the observation. For general coalgebras, the zero-consistency condition is a restrictive requirement, but for automatic sequences, where we know we can always modify our DFAOs to accept input with leading zeroes, zero-consistency is not a strong requirement [7].
We will also employ a notation for writing out the composition of many tran- sitions in these coalgebras. Rather than writing s3 ◦ s2 ◦ s3 ◦ s1, we will write s(3)(2)(3)(1), where the subscript is a word in the available transition subscripts. So,
for example, we might write (π 0 , 0 ◦ π 1 , 0 ◦ π 0 , 1 )(x)= π( 0 , 0 )( 1 , 0 )( 0 , 1 )(x).
 	 	 	     
2 2	2 2	2 2	2 2  2 2  2 2
Before proving that ArΔ is a final coalgebra, we prove two simple facts.
Lemma 3.1 Let (m, n)k,l be the standard k, l-encoding of the pair (m, n). Let i ∈ N<k and j ∈ N<l. Then (m, n)k,l(i, j), the encoding of (m, n) followed by the symbol (i, j), is the k, l-encoding of (mk + i, nl + j)

Proof. Consider (mk + i, nl + j)k,l. It is clear that [mk + i]k = [m]ki and also that [nl + j]l = [n]lj. Then the last pair in the standard k, l-encoding will be (i, j), and the preceding symbols will just be the k, l-encoding of (m, n). That is, (mk + i, nl + j)k,l = (m, n)k,l(i, j), as desired.	2
Lemma 3.2 For all a ∈ ArΔ, (c ◦ π(m,n)k,l )(a)= am,n.
Proof. We show this by induction on the length of the k, l-coding for (m, n). If the encoding is empty, then m = n =0 so we have c(a)= a0,0, which is true by the definition of c.
Now suppose this statement is true for all encodings of length ≤ d and suppose the length of (m, n)k,l is d + 1. Further let m = q1k + i and n = q2l + j where i ∈ N<k and j ∈ N<l by the division algorithm. There is at least one symbol in our encoding, so we write (m, n)k,l = w(i, j) where (i, j) is a single symbol in N<l × N<k and w = (q1, q2)k,l is the remainder of the coding by Lemma 3.1. Then we are considering (c◦π(m,n)k,l )(a)= (c◦πw ◦π i , j )(a) by definition of the structure
k l
subscripts. Note that w has length d, so the induction hypothesis kicks in and
tells us c ◦ πw finds the (q1, q2) element of its argument, so the above reduces to (π i , j (a))q1,q2 . Now the definition of π i , j (a) above tells us the q1, q2 entry in this
k l	k l
array is the (kq1 + i, lq2 + j)= (m, n) entry of a, as desired.	2
We are now ready to prove the promised result regarding the finality of the coalgebra of ArΔ with c and the π i , j .
k l
Proposition 3.3 The coalgebra ⟨c, π · · ⟩ : ArΔ → Δ × (ArΔ)kl is ﬁnal for the
k l
zero-consistent coalgebras of the functor FX =Δ × Xkl.
Proof. Suppose ⟨o, p(·,·)⟩ : A → Δ ×Akl is a zero-consistent F -coalgebra. We define a map ϕ : A → ArΔ by the following: a ∈ A gets mapped to the Δ-array whose (m, n) entry is given by ϕ(a)m,n = o(p(m,n)k,l (a)).
We must show that this is an F -coalgebra morphism. For this we verify the observation and transition parts separately.
A 	⟨o,p(·,·)⟩	/Δ¸× Akl

ϕ
J	/¸
idΔ×ϕkl
J 
kl

ArΔ	⟨c,π · · ⟩
,
Δ × (ArΔ)

k l
Observation component:
We must show o(a)= c(ϕ(a)). We know c(ϕ(a)) = ϕ(a)0,0 = o(p(0,0)(a)) by our definition of ϕ. Further, o(p(0,0)(a)) = o(a) since A is a zero-consistent F -coalgebra. Hence we have c(ϕ(a)) = o(a), as desired.
Transition components:
We must show ϕ ◦ p(i,j) = π i , j ◦ ϕ for all i ∈ N<k and j ∈ N<l.
 
k l

We first claim that c ◦ ϕ ◦ p(m,n)k,l = c ◦ π(m,n)k,l ◦ ϕ for all m, n ≥ 0. Note that ϕ(a)m,n = (o ◦ p(m,n)k,l )(a) by our definition of ϕ. We also know from Lemma 3.2 that c◦π(m,n)k,l finds the (m, n) element of an array, so ϕ(a)m,n = (c◦π(m,n)k,l ◦ϕ)(a). Therefore o ◦ p(m,n)k,l = c ◦ π(m,n)k,l ◦ ϕ. Now from the observation result above, we know c ◦ ϕ = o, so we get c ◦ ϕ ◦ p(m,n)k,l = c ◦ π(m,n)k,l ◦ ϕ, and our claim is proven.
Now we return to proving ϕ◦p(i,j) = π i , j ◦ϕ. Let a ∈ A and m, n ∈ N. Then we
k l
must show (ϕ◦p(i,j))(a)m,n = (π i , j ◦ϕ)(a)m,n for all such a, m, n. Since c◦π(m,n)k,l
k l
selects the (m, n) entry of a grid by Lemma 3.2, we rewrite this as
(c ◦ π(m,n)k,l ◦ ϕ ◦ p(i,j))(a)= (c ◦ π(m,n)k,l ◦ π i , j ◦ ϕ)(a)
 
k l
= (c ◦ π(mk+i,nl+j)k,l ◦ ϕ)(a)
where the equality is by Lemma 3.1. Now using the claim we just proved we can rewrite the left hand side as
(c ◦ π(m,n)k,l ◦ ϕ ◦ p(i,j))(a)= (c ◦ ϕ ◦ p(m,n)k,l(i,j))(a)= (c ◦ ϕ ◦ p(mk+i,nl+j)k,l )(a) which is again by Lemma 3.1. This shows ϕ is a coalgebra map.
To show ϕ is the final coalgebra map, we must also show it is the unique map with these properties. This is a straightforward induction argument where most of the hard work is done by our previous lemmas. Since we do not need the details later, we omit them.	2
Array linearization with ﬁnal stream coalgebras
In the last section we showed that the set of arrays in Δ, ArΔ, carries a final coalgebra structure for the zero-consistent coalgebras of the functor FX = Δ ×Xkl. We also know the stream coalgebra (Δω, ⟨hd, Nkl⟩)= (Δω, ⟨hd, π0,kl,.  πkl−1,kl⟩) is
a final coalgebra for the zero-consistent coalgebras of F . [6] Consequently, these two coalgebras must be isomorphic. We shall next make this isomorphism explicit. The coalgebra (Δω, ⟨hd, Nkl⟩) has the structure maps hd(σ)= σ0 and πj,kl(σn)= 
{σnkl+j}n being the stream kernel maps with 0 ≤ j < kl. Now fortunately, our result above gives the explicit construction of the final coalgebra map from this coalgebra into the ArΔ coalgebra. Let ϕ : Δω → ArΔ be this final map. Then the array coalgebra maps, when listed out, are
⟨c, π 0 , 0 ,π 0 , 1 ,...,π 0 , l−1 ,π 1 , 0 ,.	,πk−1 , l−1 ⟩
 	 	 
k l	k l	k  l	k l	k	l
while the stream coalgebra maps are
⟨hd, π0,kl, π1,kl,..., πkl−1,kl⟩
so taking the corner of an array corresponds exactly to taking the head of the related

stream, and the array projection π i , j
corresponds exactly to the stream projection

k l
πil+j,kl. Now if we’re given a stream σ and want to find the array ϕ(σ), we’ll try to
find the element of the array at position (m, n) for all m, n ∈ N. Lemma 3.2 tells us that to find the element in the array at this position we should take the (m, n)k,l

encoding of (m, n) and follow those array projections. Since ϕ is an isomorphism, we know that following these projections on ϕ(σ) corresponds exactly to taking the related stream projections on σ and then taking the head of the resulting stream.
For simplicity, let’s consider the case where k  = l  = 2 and σ  = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,.. .), and figure out what ϕ(σ) looks like. Working through the calculation outlined above many times shows that ϕ(σ) begins like

Now since Δω with the hd and πi,4 stream projections is also a final coalgebra for the functor FX = Δ × X4, we know the coalgebra morphism ϕ must be an isomorphism. In particular, ϕ−1 takes an array and transforms it into a stream. Having figured out what ϕ does to a stream, we can easily invert it to see how ϕ−1 linearizes an array.

Fig. 1. The start of lin2,2


This is already known to computer scientists as the “z-order curve” as introduced by G. Morton [8]. It has an important property which makes it easy for machines working with binary representations to use: the entry at (m, n) in the array gets mapped to the element in the stream at the position which is formed by zipping the digits of [m]2 and [n]2. We see this on the diagram below, which is ϕ(σ) as above

but with everything translated into binary and with row and column labels. 6

Indeed we might have guessed this from our definition of the automata operating on pairs of digit representations. If we look at the pairs of red and black digits, they give the pairs in the encoding of that position in the array. At the position (2, 3)2,2 = (1, 1)(0, 1) = (0, 0)(1, 1)(0, 1), highlighted in bold, we indeed get the thirteenth element of the stream and 001101 = [13]2.
With this operation in mind, it is easy to describe what ϕ does as well. Given an element in a sequence, we take its position and write that position in binary, padding with leading zeroes to make the representation have an even number of digits. Then every other digit starting with the first forms the representation for the row in the array, and every other digit starting with the second forms the representation of the column in the array. For example, the 28th element of the stream gets mapped by ϕ to the (2, 6) element of the array since [28]2 = 11100 = 011100 = 011100 and
010 = [2]2 and 110 = [6]2.
3.3  Connections between sequences and arrays using linearization
To avoid confusion between ϕ and ϕ−1, we’ll call ϕ = ord since it takes a sequence and z-orders it into a grid and we’ll call ϕ−1 = lin since it linearizes an array. Each of these should be subscripted with k and l when the grid coalgebra they refer to is unclear from context.
As an example application of this isomorphism, consider the following proposi- tion.
Proposition 3.4 Suppose σ ∈ Δω is a sequence and g ∈ ArΔ is a grid. g is k, l-automatic iff link,l(g) is kl-automatic, and σ is kl-automatic iff ordk,l(σ) is k, l-automatic.
Proof. We prove the first statement, regarding g and lin(g). This will then give the second part by taking g = ord(σ) and noting that lin(ord(σ)) = σ.

6 We have colored all the column-related digits red, so grayscale copies of this document may appear to have a lighter shade for these digits.

The fact that lin : ArΔ → Δω is a coalgebra morphism immediately gives

πil+j,kl ◦ lin = lin ◦ π i , j
for all i ∈ N<k and j ∈ N<l. Then every unique image of

k l

g under repeated application of the π i , j
corresponds to a unique image of lin(g)

k l
under repeated application of the πm,kl. Therefore, the k, l-kernel of g is in 1-1
correspondence with the kl-kernel of lin(g). Since an array is k, l-automatic iff its k, l-kernel is finite, and a sequence is kl-automatic iff its kl-kernel is finite, we have g is k, l-automatic iff lin(g) is kl-automatic.	2
A further illustration of the usefulness of this isomorphism is to extend the work of [6] in automatic sequences and zip specifications to automatic arrays. First we must define the analog of the zip function for automatic arrays.
Definition 3.5 Let the function wvk,l : Arkl → ArΔ (read “weave”) be defined by
wvk,l(g0, g1,.	, gkl−1)= ordk,l(zip(link,l(g0), link,l(g1),.	, link,l(gkl−1))).
Take the 2x2 weave as an example. Suppose
⎡ .	.	.	. ⎤
a20 a21 a22 ... 
A =	,
a10 a11 a12 ... a00 a01 a02 ... 

and B, C and D are similar. Then
⎡ .	.	.	.	. ⎤

⎛	⎞	c10 d10 c11 d11 ... 
C D 
wv	(A, B, C, D)= wv	= ⎢	⎥

2,2
2,2 ⎝ A B ⎠
a10 b10 a11 b11 ... c00 d00 c01 d01 ... a00 b00 a01 b01 ... 

Note this is the block-wise weave of these grids in the pattern suggested by the
second argument style. wv is similar in spirit to zip since it inverts the action of the k, l-kernel maps. That is,
⎛⎜	⎛⎜ gk−1,0 ... gk−1,l−1 ⎞⎟⎞⎟

π i j	wv	.
.	= gi,j



and conversely
k l ⎝
⎝ g0,0  ... g0,l−1 ⎠⎠

⎛ πk−1 , 0 (g) ... πk−1 , l−1 (g) ⎞

k  l
wv ⎜⎜⎝	.

k	l
.	⎟⎟⎠

= g.

Now we are ready to develop a notion of a weave specification for arrays. Let S
be a finite set of variables. We define a weave term in S by the BNF grammar
W ::= s | a : W | wvk,l(W,...,W )
where s is a variable from S, a ∈ Δ, k, l ∈ N≥2 and there are kl weave terms provided as the argument to wvk,l. A weave specification is a pairing of each variable in S to a weave term in S.
We have described how to interpret wvk,l(W,...,W ). a : W is to be interpreted as the grid ord(a : lin(W )). As a result of these definitions and the fact that they have isomorphic generating grammars, every weave term is the z-ordering of a zip term. This means weave specifications will have the same existence and uniqueness conditions on their solutions as their related zip specifications.
For example, the weave specification:
⎧⎪	m =0: x
x =1: wv	x	y
1: y 0: x

⎪⎪⎩ y =0: wv
y	x
0: x 1: y

has the unique solution given by the 2,2-automatic array from section 2.5. As a re- sult of the fact that all weave terms are the z-ordering of a zip term, we can translate between the two formats easily. This gives the following theorem immediately.

Proposition 3.6 For grids g ∈ ArΔ the following are equivalent:
g is k, l-automatic.
g can be deﬁned by a wvk,l speciﬁcation.
g has a ﬁnite k, l-kernel
Proof. We have already noted the equivalence of (i) and (iii) is known in the literature [2]. Every wvk,l specification is the z-ordering of a zipkl specification, and similarly every zipkl specification can be written as the linearization of a wvk,l specification. Our earlier proposition shows that a grid is k, l-automatic iff its linearization is kl-automatic. Therefore, the equivalence of (i) and (ii) is the same as the equivalence of a sequence being kl-automatic and having a zipkl specification. The latter equivalence is proven in [6], so our result follows.	2

Summary
We have presented a natural final coalgebra for arrays, for which automatic arrays are the rational part. This coalgebra is final for a functor also commonly used in the study of automatic sequences and hence gives rise to an isomorphism between the array coalgebra and sequence coalgebra preserving many important automatic- ity properties. We then lifted several results about automatic sequences to facts about automatic arrays, including the zip specification scheme of [6] to the case of automatic arrays. There are a few natural avenues for investigation to proceed from here, which we summarize below.
Investigation of arrays using sequence methods: There is already quite a bit known about automatic sequences. The automaticity-preserving properties of this isomorphism suggest that many of the known results about automatic se- quences could be translated easily into results about arrays, where the literature is significantly less well-developed.
Other space filling curves: We found the z-order/Morton curve as an iso- morphism between array coalgebras and sequence coalgebras. There are many other space filling curves (such as the Hilbert curve or the Peano curve), so we wonder whether there are coalgebras which naturally give rise to these curves as isomor- phism between arrays and sequences.
Partitions and variadic zip specifications: The extra dimension afforded by automatic arrays may offer opportunity to resolve questions about automatic sequences by transposing them to questions about automatic arrays along this iso- morphism. There has been some incomplete progress towards resolving an open question of [6] regarding zip specifications of particularly regular mixed arity. We would like some exploration on what automata naturally emerge from relaxing this regularity condition and perhaps answering the decidability question for zip specifi- cations where the base determination is made by a DFA. (See [6,5] for more details on this set up.)
Acknowledgement
I owe many thanks to Larry Moss for his invaluable advice, comments, and patience reading much rougher drafts.

References
J.-P. Allouche and J. Shallit. The ubiquitous Prouhet-Thue-Morse sequence. In T. Helleseth C. Ding and H. Niederreiter, editors, Sequences and their applications, Proceedings of SETA’98, pages 1–16. Springer Verlag, 1999.
J.-P. Allouche and J. Shallit. Automatic Sequences. Cambridge University Press, 2003.
G. Christol. Ensembles presque periodiques k-reconnaissables. Theoret. Comput. Sci., 9(1):141–145, 1979.
Alan Cobham. Uniform tag sequences. Theory of Computing Systems, 6(1):164–192, 1972.
J. Endrullis, C. Grabmayer, and D. Hendriks. Mix-automatic sequences. In Language and Automata Theory and Applications (LATA 2013), pages 262–274. Springer, 2013.


C. Grabmayer, J. Endrullis, D. Hendriks, J.W. Klop, and L.S. Moss. Automatic sequences and zip- specifications. In Proceedings of the 2012 27th Annual IEEE/ACM Symposium on Logic in Computer Science, pages 335–344. IEEE Computer Society, 2012.
C. Kupke and J.J.M.M. Rutten. On the final coalgebra of automatic sequences. In Logic and Program Semantics, pages 149–164. Springer, 2012.
G.M. Morton. A computer oriented geodetic data base and a new technique in file sequencing. International Business Machines Company, 1966.
J. J. M. M. Rutten. Automata and coinduction (an exercise in coalgebra). In CONCUR’98: concurrency theory (Nice), volume 1466 of Lecture Notes in Comput. Sci., pages 194–218. Springer, Berlin, 1998.
J. J. M. M. Rutten. Universal coalgebra: a theory of systems. Theoret. Comput. Sci., 249(1):3–80, 2000. Modern algebra and its applications (Nashville, TN, 1996).
J. J. M. M. Rutten and D. Turi. On the foundations of final semantics: nonstandard sets, metric spaces, partial orders. In Semantics: foundations and applications (Beekbergen, 1992), volume 666 of Lecture Notes in Comput. Sci., pages 477–530. Springer, Berlin, 1993.
