 Electronic Notes in Theoretical Computer Science 99 (2004) 295–317 
www.elsevier.com/locate/entcs




Checking Integrity via CoPS and Banana: the E-Commerce Case Study *
Chiara Braghin1 and Carla Piazza2
Dipartimento di Informatica, Universita` Ca’ Foscari di Venezia via Torino 155, 30172 Venezia, Italy

Abstract
We consider two different approaches to security issues. In the first one bisimulation equivalences (dynamic verifications) are exploited to verify non-interference security properties on a CCS-like process algebra calculus. In the second approach control flow analysis (static analysis) is applied to verify security properties in Mobile Ambient calculus. We analyze how a simple electronic commerce case study can be modeled and its integrity verified using the two techniques. The tools CoPS and Banana are used to perform the computations.
Keywords: Security Process Algebra, Non-Interference, Mobile Ambients, Nesting Analysis, Integrity.


Introduction
In the last decades the protection of confidential data from undesired accesses has been widely investigated both on systems and networks. Information is typically protected via some access control policy, limiting accesses of entities (e.g., users, processes) to data. There are different levels of flexibility of access control policies depending on the possibility for one entity to change rights to its own data. In the case of mandatory policies, entities cannot change access

 Partially supported by the MIUR Project “Modelli formali per la sicurezza”, the EU Con- tract IST-2001-32617 “MyThS”, and the FIRB project (RBAU018RCZ) “Interpretazione astratta e model checking per la verifica di sistemi embedded”.
1 Email: braghin@dsi.unive.it
2 Email: piazza@dsi.unive.it


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.02.013

rights. For example Multilevel Security [1] imposes that entities and data are associated to (ordered) security levels and no access to data at higher level is ever possible. This strong security policy has been designed to avoid internal attacks performed by Trojan Horse programs. Unfortunately, even with a multilevel security policy data can be indirectly leaked by Trojan Horses (see, e.g., [18,22]).
The necessity of controlling information flow as a whole (both direct and indirect) motivated Goguen and Meseguer in introducing the notion of Non- Interference [14]. Non-Interference formalizes the absence of information flow within deterministic systems. Given a system in which confidential (i.e., high level) and public (i.e., low level) information may coexist, non-interference requires that confidential inputs never affect the outputs of the public in- terface of the system, i.e., they never interfere with low level users. If such a property holds, one can conclude that no information flow is ever possi- ble from high to low level. In [11], Focardi and Gorrieri express the con- cept of non-interference in the Security Process Algebra (SPA) language, in terms of bisimulation semantics: a system is secure if what a low level user sees of the system is not modified by composing any high level attacker with the system. In [13] a persistent version of the security property defined in
[11] has been introduced. Persistency has been proved to be fundamental to deal with processes in dynamic contexts, i.e., contexts that can be re- configured at runtime. Algorithms to efficiently verify this and other bisim- ulation based persistent security properties have been presented in [2] and implemented in the tool CoPS, Checker of Persistent Security, available at
http://www.dsi.unive.it/∼mefisto/CoPS/.
The calculus of Mobile Ambients has been introduced in [6,7] with the
main aim of explicitly modeling mobility. Ambients are arbitrarily nested entities which can move around through suitable capabilities. Big efforts have been devoted to the study of Control Flow Analysis (CFA) of such a calculus [16,20]. In particular, some analysis have been applied to the ver- ification of security properties [3,8,17]. The idea of [3,17] is to compute an over-approximation of ambient nestings that may occur during process com- putation, thus detecting possible intrusions and unwanted information flows. Since the computation of ambient nesting analysis like [3,16,20] requires con- siderably high complexities, the design of efficient techniques turns out to be very important. Time and space efficient algorithms to compute the control flow analysis described in [3,16] have been presented in [4] and implemented
at             http://www.dsi.unive.it/∼mefisto/BANANA/. in the tool Banana, Boundary Ambient Nesting ANAlysis, available


However, many applications require models of security not focused on the complete absence of information flow, but on the preservation of the integrity of the resources, that guarantees that information flowing from one place to another must traverse specific points of the path. For instance, consider the E-Commerce Processing System described in [15]. The system represents a process where:
an order is submitted electronically by a client;
an e-sales process ensures that the order is correct (e.g., the prices and discounts are correct), and, if so, passes it to the process accounts receivable;
accounts receivable interacts with a credit card clearing house and, if every- thing is fine, it passes the order to the shipping process;
the shipping process sends the items to the client.
In [15] the authors use Linear Temporal Logic to specify information flow policies for SELinux, which can then be checked via model-checking. The E-Commerce example is used to illustrate the technique. In particular, in this example it is important to ensure that, if the internal channels of communi- cation are secure, then the action’s casual chain is always the same even in presence of a malicious attacker (e.g., it is not possible that an unpaid order is shipped).
In this paper we show how to use both non-interference security properties and control flow analysis to check the integrity of the E-Commerce Processing System. In the two approaches we take a common starting point, then we concentrate on different aspects. In particular, in Section 2 we describe the non-interference approach by introducing the language and the security prop- erties (Section 2.1), briefly describing the tool CoPS (Section 2.2), modeling the E-Commerce system (Section 2.3). Section 3 is devoted to the control flow analysis approach: we present the language and the nesting analysis (Section 3.1); we outline the features of the tool Banana (Section 3.2); we model and study the E-Commerce system (Sections 3.3 and 3.4). The paper ends with Section 4 containing some comparisons and conclusions.

Non-Interference Approach
Persistent Security Properties
The Security Process Algebra (SPA) [11] is a variation of Milner’s CCS [19], where the set of visible actions is partitioned into high level and low level actions in order to specify multilevel systems. The syntax of SPA processes is

as follows:
E ::= 0 | a.E | E + E | E|E | E \ v | E[f ] | Z
The semantics is the same as in CCS. Intuitively, 0 is the empty process;
istic choice between E1 and E2; E1|E2 is the parallel composition of E1 and a.E performs an action a and continues as E; E1 + E2 is the nondetermin- tary input/output actions, producing the silent action τ ; E \ v prevents E E2, where executions are interleaved, possibly synchronized on complemen- from performing actions in the set v; E[f ] is the process E whose actions are
renamed via the relabeling function f ; the constant Z is associated with a
def
definition Z = E and is used to define recursive processes.
As an example, a binary memory cell which initially contains the value 0 and is accessible by both high and low level users through the read and write operations (e.g., rh0 represents the high read of 0) can be formalized as follows:
def
	
M 0 = rh0 . M 0+ wh0 . M 0+ wh1 . M 1+ rl0 . M 0+ wl0 . M 0+ wl1 . M 1
def
M 1 = rh1 . M 1+ wh0 . M 0+ wh1 . M 1+ rl1 . M 1+ wl0 . M 0+ wl1 . M 1
M 0 and M 1 are totally insecure processes: no access control is implemented and a high level malicious entity may write confidential information into the memory cell which can be then read by any low level user. Our security property will aim at detecting this kind of flaws, even in more subtle and interesting situations.
The non-interference property named Persistent Bisimulation-based Non Deducibility on Composition first introduced in [13] can be defined in terms of unwinding conditions (see [2]): if a state F of a secure process performs a high level action moving to a state G, then F also performs a sequence of silent actions moving to a state K which is equivalent to G for a low level user. We report here the definition of P BNDC denoting by ( τ )∗ a sequence
of zero or more silent actions. We also use ≈ for weak bisimulation (see [19]).
Definition 2.1 [P BNDC [2]] A process E is P BNDC if for all F reachable

from E, if F →
G, then F ( τ )∗K and G \ H ≈ K \ H.

The memory cell defined above is not P BNDC. In fact, there is a direct
information flow from high to low level. We can redefine the cell by eliminating any low level read operation as follows:
def

M 0 = rh0 . M 0+ wh0 . M 0+ wh1 . M 1+ wl0 . M 0+ wl1 . M 1
def

M 1 = rh1 . M 1+ wh0 . M 0+ wh1 . M 1+ wl0 . M 0+ wl1 . M 1
Now the memory cell is P BNDC.

In [2] an efficient polynomial algorithm to verify P BNDC is described. The algorithm is based on the reduction of the problem of checking the security property to the problem of checking strong bisimulation between two graphs. The tool CoPS implements such algorithm. As far as the strong bisimulation underlying algorithm is concerned, CoPS allows the user to choose between the Paige and Tarjan’s algorithm [21] and the fast bisimulation algorithm described in [9]. This choice does not affect the worst-case complexities.

CoPS
The tool CoPS, available at http://www.dsi.unive.it/∼mefisto/CoPS/, is an automatic checker of multilevel system security properties. It implements
the polynomial algorithm described in [2] to check P BNDC. Moreover, it allows to check other security properties studied in [2].
CoPS consists of a graphical interface and a kernel module. The graphical interface has been implemented in Java to get a large portability and allows to:
Insert the process(es) to be checked in the editor pane. The process(es) can be either typed or loaded from a file. A tree is automatically drawn to facilitate the navigation among processes. The syntax is highlighted to get a better readability. Both fonts and colors can be changed by the user.
Select the security property to be checked and start the verification. It is also possible to check whether two processes are strongly or weakly bisimilar.
Read the verification results. Some time/space statistics are shown together with the security result. Moreover, syntax errors are reported.
View the graph representing the semantics of the process(es). This can be also saved in a file whose type (e.g., jpg, gif, eps) can be chosen by the user.
The kernel module has been implemented in standard C to obtain good per- formances and consists of:
A parser which checks for syntax errors and builds the syntax tree out of the SPA process.
A semantics graph generator which elaborates the syntax tree to generate an adjacency-list representation of the graph associated to the process.
A verifier which transforms the graph in order to use a strong bisimulation algorithm to perform the security check.
The graph visualization requires the installation of Graphviz, available at http://www.research.att.com/sw/tools/graphviz/. The kernel execu- tion can be personalized by using the Settings option in the Edit menu. Many options can be chosen, e.g. by setting the path of Graphviz and the format of the generated graph, choosing the bisimulation algorithm to be used

(the Paige and Tarjan’s one [21] or the one presented in [9]), avoiding the graph generation, or setting the use/dimension of an hash table which speeds up the graph generation.
It is possible to avoid the use of the graphical interface and use directly the kernel via command line (checker --help shows the help).
Installation and configuration instructions together with a tutorial on the use of CoPS can be found in the tool site.
E-Commerce Integrity in CoPS via P BNDC
Let us model the E-Commerce Processing System, described in Section 1, in the SPA language and use CoPS to check that the casual chain remains the same even in presence of a malicious attacker.
In order to model the E-Commerce System in SPA and exploit P BNDC to check its integrity we use a standard technique introduced in the modeling of cryptographic protocols [10,12]. P BNDC is based on the assumption that, given two groups of users, H and L, there is no information flow from H to L iff there is no way for a user of level H to modify the behavior of a user of level
L. In the case of protocols we can assume that the users of level L are the honest participants, while H is the external, possibly malicious, environment. Since an intruder may have complete control of the network, we assume that the channels are of level H. In this way all the protocol actions are of level H, while the actions of level L are extra observable actions that are added to the protocol to check its properties. Hence, the way in which the low level actions are added depends on the security property we are interested in. For instance, in the case of integrity, if we want to check that an action h2 can be performed only after the execution of an action h1, we add a low level action l1 after each h1 and a low level action l2 after each h2 and we check that in the low level behavior l2 occurs only after l1.
Notice that P BNDC exploits bisimulation as observational equivalence. Similarly, the Non Deducibility on Composition (NDC ) property introduced in [11], instantiates the non-interference schema using trace equivalence in- stead of bisimulation. In [12] it has been shown that trace equivalence, and hence NDC, is sufficient for verifying several protocol properties, such as au- thentication, and bisimulation is necessary in other cases, such as fairness. The bisimulation relation is dead-lock sensitive, while trace equivalence is not. Hence, in the case of integrity the use of bisimulation instead of trace equivalence allows us to check that also the dead-locks in the casual chain are unalterable, i.e. the process under attack reaches a dead-lock after the action sequence s iff the process in isolation reaches a dead-lock after the sequence
s. In particular, the use of bisimulation ensures that all the branching points



Fig. 1. E-Commerce: basic case.
in the execution chains do not change under attacks.
We start modeling only some basic aspects of the process, then we proceed adding details to the model. In Figure 1 we give a graphical representation of the E-Commerce Processing System assuming that the agents involved com- municate directly through channels (the arrows in the picture). Client sends an order containing prices, payment data and address. Let us assume that Client sends a correct order, i.e., both prices and payment are correct. We use the action itemprice&credcardnum&address to represent this fact 3 . Then Client waits to receive the items. The process E-sales receives the order, and if the prices are correct it sends the payment data and the address to the process AccountsRec. We use the action credcardnum&address to model the fact that the correct payment data are sent to AccountsRec. Similarly, if the payment is correct AccountsRec asks, through the action address, to the pro- cess Shipping to send the items. As said above, since an intruder could have control over the network, all the involved channels are of level high. Hence, in the SPA language we get the following processes.


E-Commerce Client Server
E-sales

AccountsRec Shipping
def
= (Client |Server )
def
= itemprice&credcardnum&address .items.0
def
= E-sales|AccountsRec|Shipping
def
= itemprice&credcardnum&address.credcardnum&address . 0
+ itemprice&wrongcardnum&address.wrongcardnum&address .0
def
= credcardnum&address.address .0
def
= address.items .0

Notice that if the prices are correct while the payment data are wrong the process E-sales reads the prices and outputs the remaining set of data (i.e., payment and address). In this case AccountsRec blocks the process since it cannot read a wrong payment. Another possibility would be to add to

3 In the case of an order with wrong payment data we use the action item- price&wrongcardnum&address.

AccountsRec the alternative behavior corresponding to the synchronization with actions denoting the reception of wrong data. This change would not affect the considerations which follows.
We want to check that in the execution chains only the orders with correct prices are sent to AccountsRec and only the orders with correct price and payment data are shipped. To verify this property, we add the low level actions okl1, okl2, and okl3 in different execution points.


E-Commerce Client Server
E-sales

AccountsRec Shipping
def
= (Client |Server )
def
= itemprice&credcardnum&address .items.0
def
= E-sales|AccountsRec|Shipping
def
= itemprice&credcardnum&address.okl1.credcardnum&address . 0
+ itemprice&wrongcardnum&address.okl1.wrongcardnum&address .0
def
= credcardnum&address.okl2.address .0
def
= address.okl3.items .0

When there are no intruders interacting with the process E-Commerce the low level behavior is of the form okl1.okl2.okl3.0. This can be easily verified
in CoPS by checking that E-Commerce\H is weak bisimilar to the latter. The process E-Commerce is not P BNDC. In particular, the state Shipping which
is reachable from E-Commerce does not satisfy the unwinding condition of

any sequence of τ transitions any state E such that okl3.items.0\H ≈ E \ H. Definition 2.1: Shippingaddressokl3.items.0, and Shipping does not reach with Such a situation, automatically detected by CoPS, represents the fact that a
high level intruder could directly synchronize with the process Shipping and force the system to ship orders which have not been paid. Hence, the lack of integrity is due to the fact that the intruder can communicate with process Shipping.
If we believe that our channels are secure and the intruder cannot directly communicate with the processes inside the E-Commerce system, we can model this fact using a restriction over the channels. Hence, we get the following model.



E-Commerce Client Server
E-sales

AccountsRec Shipping
def
= (Client |Server )\H
def
= itemprice&credcardnum&address .items.0
def
= E-sales|AccountsRec|Shipping
def
= itemprice&credcardnum&address.okl1.credcardnum&address . 0
+ itemprice&wrongcardnum&address.okl1 wrongcardnum&address .0
def
= credcardnum&address.okl2.address .0
def
= address.okl3.items .0

In this case the process E-Commerce satisfies the three security properties checked by CoPS, which implies that the casual chain order is always respected. We can now increase the power of the client by adding the option of query- ing the system through an untrusted channel, as represented in Figure 2. In

Fig. 2. E-Commerce: queries.
this case, the queries are not restricted high level actions, named okh1, okh2, okh3. In order to obtain a secure system, we need to add timeouts (τ actions), i.e., the system does not wait the queries forever.


E-Commerce Client Server
E-sales
def
= (Client |Server )\Hc
def
= itemprice&credcardnum&address .items.0
def
= E-sales|AccountsRec|Shipping
def
= itemprice&credcardnum&address.
(okh1 .okl1.credcardnum&address .0
+ τ .okl1.credcardnum&address .0)+
itemprice&wrongcardnum&address. (okh1 .okl1.wrongcardnum&address .0
+ τ .okl1.wrongcardnum&address .0)

AccountsRec
def
= credcardnum&address.
(okh2 .oklow2.address .0+τ .oklow2.address .0)

Shipping
def
	
= address.(okh3 .oklow3.items .0+ τ .oklow3.items .0)

where Hc ⊆ H is the set of actions {item, itemprice&credcardnum&address,



Fig. 3. E-Commerce: files and queries.






















itemprice&wrongcardnum&address, credcardnum&address, address}. We can a graphical representation of E-Commerce\H. In the graphical representation use CoPS to verify that the systems is P BNDC. Moreover, we can ask to CoPS we can see the sequences of low level actions when the system is not under
attack. Since the system is secure, the sequences remain the same even in presence of any malicious attacker.
Finally, another interesting variation in the modeling of the system con- sists of introducing intermediate files in which the information are stored (see Figure 3). In this case it is important to model the files carefully: each order has to be processed exactly once. For this reason each file has a state empty in which it is reset after the information have been read. We show below part of the model written in the SPA language.



E-Commerce Client Server
def
= (Client|Server )\Hc
def
= itemprice&credcardnum&address.items.0
def
= Socket-empty |E-sales|Filepaydata-empty
|AccountsRec| Fileaddress-empty | Shipping

Socket-empty




Socket-full-okok Socket-full-nook Socket-full-okno Socket-full-nono E-sales



... 
def
= itemprice&credcardnum&address.Socket-full-okok
+wrongitemprice&credcardnum&address.Socket-full-nook
+itemprice&wrongcardnum&address.Socket-full-okno
+wrongitemprice&wrongcardnum&address.Socket-full-nono
def
= socket-itemprice&credcardnum&address.Socket-empty
def
= socket-wrongitemprice&credcardnum&address.Socket-empty
def
= socket-itemprice&wrongcardnum&address.Socket-empty
def
= socket-wrongitemprice&wrongcardnum&address.Socket-empty
def
= socket-itemprice&credcardnum&address.

(okh1 .okl1.credcardnum&address.0+τ	)+
socket-wrongitemprice&credcardnum&address. (noh1 .nol1.0+τ .nol1.0)+... 

Also in this case the system is secure, since it is P BNDC.

Control Flow Analysis Approach
Mobile Ambients and Nesting Analysis
The Mobile Ambient calculus has been introduced in [6] with the main pur- pose of explicitly modeling mobility. Indeed, ambients are arbitrarily nested boundaries which can move around through suitable capabilities. The syntax
of processes is given as follows, where n ∈ Amb denotes an ambient name.

P, Q	::=	(νn)P	restriction	|
nAa
At
[ P ]
ambient

|	0	inactivity	|	in n.P	capability to enter n
|	P | Q	composition	|	outAt n.P	capability to exit n
|	!P	replication	|	openAt n.P	capability to open n


scope to P ; P | Q is P and Q running in parallel; replication provides recursion Intuitively, the restriction (νn)P introduces the new name n and limits its and iteration. By nla [ P ] we denote the ambient named n with the process
t
P running inside it. The capabilities inl n and outl n move their enclosing
ambients in and out ambient n, respectively; the capability openlt n is used to dissolve a sibling ambient n. Labels on ambients and on transitions are introduced as it is customary in static analysis to indicate “program points”. They will be useful in the next paragraphs when developing the analysis.
tion relation → and a structural congruence ≡ between processes. Intuitively, The operational semantics of a process P is given through a suitable reduc- P → Q represents the possibility for P of reducing to Q through some com-
putation (see [6] for more details).
For instance, let P1 be a process modeling an envelope sent from venice to
pisa:
venice [ envelope[[ out venice.in pisa.0 ]] | Q ] | pisa[[ open envelope.0 ]
Initially, envelope is in site venice. Then, it exits venice and enters site pisa by applying its capabilities out venice and in pisa, respectively. Once site pisa receives envelope, it reads its content by consuming its open envelope
capability. Finally, P1 reaches the state venice [ Q ] | pisa [ 0 ] .
To deal with security issues, information is classified into different levels
of confidentiality. This is obtained by exploiting the labeling of the ambi- ents. In particular, the set of ambient labels is partitioned into three disjoint sets: high, low and boundary labels. Ambients labeled with boundary labels (boundary ambients) are the ones responsible for confining confidential infor- mation. Information leakage occurs if a high level ambient exits a boundary, thus becoming possibly exposed to a malicious ambient attack. In the follow- ing examples, we will use b to label boundaries, h for high level ambients, and c for capabilities. For instance, let P2 be a labeled extension of process P1, in which the envelope contains confidential data hdata (labeled high) which needs to be safely sent from venice to pisa.
veniceb1 [ envelopeb2 [[ outc1 venice.inc2 pisa.0 |
hdatah[[0 ]] ] ] |
pisab3 [[ openc4 envelope.0 ]
In this case, venice, pisa and envelope must be labeled boundary to protect
hdata during the whole execution. See [3] for more detail.
In [16], Nielson et al. introduce a Control Flow Analysis of a process P aiming at modeling the possible ambient nestings occurring in the execution of P . It works on pairs (Iˆ, Hˆ ). The first component Iˆ is a set of labels’ pairs which records all nestings: if process P , during its execution, contains an
ambient labeled la having inside either a capability or an ambient labeled l,

then (la, l) is expected to belong to Iˆ. The second component Hˆ
of the correspondence between names and labels.
keeps track

The analysis is defined as usual by a representation and a specification function. The representation function aims at mapping concrete values to their best abstract representation. It is given in terms of a function βCF(P )
which maps process P into a pair (Iˆ, Hˆ ) corresponding to the initial state of
P , with respect to an enclosing ambient labeled with l. In particular, the representation of a process P is defined as βCF (P ), env being a special label to denote the external environment. Consider for example process P2. Its representation function is
βCF (P2) = ({(env, b1), (env, b3), (b1, b2), (b2, h), (b2, c1), (b2, c2), (b3, c4)},
{(b1, venice), (b2, envelope), (h, hdata), (b3, pisa)}),
where all ambient nestings are captured by the first component, while all the
correspondences between ambients and labels of P2 are kept by the second one.
The specification states a closure condition of a pair (Iˆ, Hˆ ) with respect to
all the possible moves executable on a process P . It mostly relies on recursive calls on subprocesses except for the three capabilities open, in, and out, where the result of performing that capability must be recorded in Iˆ. Consider again process P2. The first component of its least solution is
Iˆ = {(env, b1), (env, b2), (env, b3), (b1, b2), (b2, h), (b2, c1), (b2, c2),
(b3, b2), (b3, h), (b3, b3), (b3, c1), (b3, c2), (b3, c4)}.
Notice that the analysis correctly captures through the pair (env, b2) the
possibility for envelope to exit from venice.
In [3], a more accurate abstract domain that separately considers nesting inside and outside security boundaries is proposed, yielding to a much more sophisticated control flow analysis for detecting unwanted boundary crossing, i.e., information leakage. The main idea is to distinguish among nestings either protected or unprotected by boundaries.
The notion of “boundary ambient” and the refined control flow analysis can be further enhanced to infer which ambients should be “protected” to guarantee the absence of information leakage for a given process. More specif- ically, in [5] we consider a process P wherein only high level data are known and the aim of the analysis is to detect which ambients among the “untrusted” ones should be protected and labeled “boundary” to guarantee that the sys- tem is secure. This problem can be properly addressed by re-executing the Control Flow Analysis presented in [3]. A successful analysis infers boundary

ambients until a fix-point is reached, returning the set of ambients that should be “protected”.

Banana
Banana, available at http://www.dsi.unive.it/∼mefisto/BANANA, analy- ses the information leakage in mobile agent specifications through the analysis
described in [3,16]. In particular, all the analyses described in the previous section have been implemented in the tool, i.e., the nesting analysis by Nielson et al. [16] and the boundary nesting analysis of [3].
The main features of Banana are:
A textual and graphical editor for Mobile Ambients, to specify and modify the process by setting ambient nesting capabilities and security attributes in a very user-friendly fashion.
A parser which checks for syntax errors and builds the syntax tree out of the Mobile Ambient process.
An analyzer which computes an over-approximation of all possible nestings occurring at run-time. The tool supports two different control flow analyses, namely the one of Nielson et al. [16] and the one by Braghin et al. [3].
A post-processing module, that interprets the results of the analysis in terms of the boundary-based information-flow model proposed in [3], where infor- mation flows correspond to leakages of high-level (i.e., secret) ambients out of protective (i.e., boundary) ambients, toward the low-level (i.e., untrusted) environment.
A detailed output window reporting both the analysis and the security results obtained by the post-processing module, and some statistics about the computational costs of the performed analysis.
Banana is implemented in Java and strongly exploits the modularity of object-oriented technology, thus allowing scalability to other analysis and ex- tensions of the target language. Moreover, it is conceived as an applet based on AWT and thus compatible with the majority of current web browsers sup- porting Java. A tutorial about the use of Banana is available in the tool web pages.

E-Commerce Integrity in Banana via CFA
Let us now model the E-Commerce Processing System in the pure Ambient calculus, and then use the Banana tool to check the integrity of the process.
Notice that in the pure Ambient calculus there are not communication

primitives. In the absence of such primitives, the exchange of a message be- tween a Sender and a Receiver may be modeled as a sequence of out Sender and in Receiver actions, performed by ambient message. In this way message moves from Sender to Receiver, where it will be opened in order to read its contents. Hence, the opening of an ambient is used to model the synchroniza- tion among the Sender and the Receiver of the message.
We model the E-Commerce system in Mobile Ambients by representing each principle and each protocol phase with an ambient. More specifically, Client and Server ambients represent the main actors, while Server’s sub- ambients model the phases the order goes through. The submission of orders by clients, and the interaction among one protocol phase and the next one correspond to message exchanges which we model as explained above. For in- stance, itemprice moves from Client to E-sales, which is a Server sub-ambient, where it is opened. To check that the order is properly formatted (i.e., the item is available and the purchase price is correct), E-sales opens the ambi- ent itemprice. When the order is correct, the opening of itemprice succeeds, while in the case of a wrong order this ambient is named wrongitemprice thus it cannot be opened (see also itemprice&wrongcardnum&address in Section 2.3). After the opening of the ambient itemprice, the interaction moves inside the ambient AccountsRec, which checks that the payment data are correct by opening the ambient creditcardnum. We summarize in the opening of credit- cardnum all the interactions with the bank to receive the payment. Hence, when the opening succeeds, the payment has been received. Finally, the Ship- ping ambient uses the information contained in address to send the items to the Client . In this way we get that the Server S of the E-Commerce system is modeleed as follows (see also Figure 4):

Server [
E-sales [ open itemprice.0 ] |
AccountsRec [ open creditcardnum.0 ] |
Shipping [ open address. item [ out Shipping.out Server.in Client.0 ] ] ]
Notice that in our modeling each sub-ambient of the Server opens an ambi- ent: each opening represents the fact that a checking phase has been passed. Also the client must be explicitly modeled. The whole system will be the parallel composition of the two. All the capabilities to move from one sub- ambient of the Server to another have to be included in the sub-ambients of the Client. In particular, itemprice has to exit from Client, enter into Server and then into E-sales. If the order is correct, itemprice is opened. After the opening of itemprice, an ambient creditcardnum has to enter into AccountsRec.



Fig. 4. The E-Commerce Server.


Once creditcardnum has been opened, an ambient address has to move inside Shipping where it is used to send the items. Hence, a correct client C1 can be modeled as follows:

Client [
itemprice [ out Client.in Server.in E-sales. creditcardnum [ out E-sales.in AccountsRec.
address [ out AccountsRec.in Shipping.0 ] ] ] ]

It is easy to see that in the execution of process S | C1 the first checking phase is passed with the opening of itemprice, then the second checking phase
is passed with the opening of creditcardnum, and finally the third checking phase is passed with the opening of address. We are interested in ensuring that the three checking phases are performed in the correct order, e.g., we do not want that the address is opened inside Shipping before itemprice is opened inside E-sales.
Using Banana to compute an over-approximation of the nestings of S |
C1, we get that (E-sales, itemprice), (AccountsRec, creditcardnum), and (Ship-
ping, address) belong to Iˆ. The pair (E-sales, itemprice) represents the fact
that the first check correctly starts and ends. Similarly, the other pairs are related to the second and the third checks. The correct order of the checks is assured by the nesting of the ambients inside the client, which forces itemprice to be opened before creditcardnum, and creditcardnum before address.
A honest client C2 sending a wrong payment is similar to the correct client, but instead of the ambient creditcardnum it has an ambient wrongcardnum, i.e., it is of the form:


Client [
itemprice [ out Client.in Server.in E-sales. wrongcardnum [ out E-sales.in AccountsRec.
address [ out AccountsRec.in Shipping.0 ] ] ] ]

In this case, during the execution of process S | C2, the first check is passed, while the second is not. Hence, the third check does not even start because
the process is blocked at the open creditcardnum action. The Iˆ set computed
by the tool captures correctly this fact, since the pairs (AccountsRec, credit- cardnum), and (Shipping, address) are not in Iˆ. Since this does not break the integrity of the E-Commerce system also this client is “correct”.
On the other hand, an intruder is a process which tries to corrupt the casual chain, by skipping one of the checking phases. For example, the following intruder C3 sends his address directly to the Shipping process. In this way he receives the items without paying for them.
Client [ address [ out Client.in Server.in Shipping.0 ] ]

If we analyze S | C3 using Banana, we notice that the pair (Shipping, address) is in Iˆ, while (E−sales, itemprice) and (AccountsRec, creditcardnum) are not in Iˆ.
There are also more subtle intruders which we want to detect. For instance, consider the process C4 of the form:
C1 | Intruder [ address [ out Intruder.in Server.in Shipping.0 ] ]
where C1 is the correct client. In this case even if Iˆcontains all the pairs which
were in the analysis of C1, the system can be corrupted, since there exists an execution in which the intruder receives the items the client has payed for, but unfortunately our analysis cannot detect this kind of attack.
Therefore, we start by giving a definition which aims at avoiding the latter kind of intruders. In particular, we impose that there is at most one address to which shipping the items. Moreover, we restrict the capabilities of the client, since we do not want that the client performs the checks by himself by opening some ambients. Finally, we impose some restrictions on the nesting of the ambients in the initial state of the client. This last condition is necessary to ensure that the checks are performed in the correct order. In the definition we use the notation ambient1“ambient2 to denote the fact that if there is at least one occurrence of ambient2, then all the occurrences of ambient1 are nested in ambient2.
Definition 3.1 [Syntactic Correctness] A client C is syntactically correct if the following conditions hold:


names   Server,   E−sales,   AccountsRec,   and   Shipping; (i) each ambient occurs in C at most once and C cannot have ambients with
only referred to the Client, Server, E−sales, AccountsRec, and Shipping (ii) C has not open capabilities, and the out and in capabilities in C are ambients;
(iii) address“creditcardnum“itemprice.
Notice that the conditions in the above definition are just syntactic checks. Condition (iii) can be checked exploiting Banana, since, for instance, to check creditcardnum“itemprice it is sufficient to compute βCF (C) and, if itemprice occurs in C, check that in the pairs of the form (x, creditcardnum) x is always itemprice.
We have that clients C1, C2, and C3 satisfy Definition 3.1, while C4 does not. Another intruder which is not syntactically correct is
Client [
itemprice [ out Client.in Server.in E-sales.0 ] |
credicardnum [ out Client.in Server.in AccountsRec.0 ] | ... ]
because it does not satisfy Condition (i). In fact in this case there are execu-
tions in which the checks are not performed in the correct order.
We now want to use Banana to distinguish between the honest clients C1
and C2 and the intruder C3. First, we formalize the fact that the checks in the execution chains are performed in the correct order. A prefix of a given
sequence of actions s = ⟨a1,... , an⟩ is a (possibly empty) sequence of the form
⟨a1,... , ai⟩, with i ≤ 0 ≤ n. Intuitively we want to accept only the executions which are prefixes of the execution in which all the checks are performed in
the right order.
tactically correct client. We say that S | C satisfies integrity if in all the Definition 3.2 [Integrity] Let S be the E-Commerce Server and C be a syn- executions of S | C the open capabilities of S are executed in an order which
is a prefix of:
sopen = ⟨open itemprice, open creditcardnum, open address⟩
If the client is syntactically correct, the integrity can be verified by reading
the pairs in Iˆ. The conditions on the initial nestings inside Client imposed in Definition 3.1 (condition (iii)) ensures that when the pairs of interest are in Iˆ, they have been inserted in a certain order. Moreover, we prove that it is never the case that the such pairs are in Iˆ because of an over-approximation. In particular, in the case of a syntactically correct client, the following proposition

translates the prefix requirement of Definition 3.2 in a prefix requirement over
Iˆ.
Proposition 3.3 Let S be the E-Commerce System and C be a syntactically correct client. If Iˆ contains an unordered prefix of:
snesting = ⟨(E-sales, itemprice), (AccountsRec, creditcardnum), (Shipping, address)⟩
where Iˆ is such that (Iˆ, Hˆ ) |=CF S | C, then S | C satisfies integrity.
Proof. We consider all the possible prefixes ⟨a1,... , ai⟩ of snesting and we prove that if {a1,... , ai} is a subset of Iˆ (while ai+1,... , an are not in Iˆ), then in all the executions in which aj, with j ≤ i, is a real nesting (i.e., a pair added not because of over-approximation) also a1,... , aj−1 are real nesting.
If i = 0, then we have nothing to prove. Also the cases i = 1 and i = 2,j = 1 are trivial.
If i = 2 and j = 2, then in Iˆ we have the pairs (E-sales, itemprice) and
(AccountsRec, creditcardnum). Let us consider an execution in which the nest- ing (AccountsRec, creditcardnum) occurs. Since (E-sales, itemprice) is in Iˆ the ambient itemprice occurs in C. Hence, since C is syntactically correct, credit- cardnum is nested in itemprice in the initial state of C. Since C is syntactically
correct, it has no open capabilities, and no out capabilities relatively to item- price. Hence, itemprice has to be opened inside E-sales, i.e., also the nesting (E-sales, itemprice) occurs in the execution under consideration.
Similarly we can prove the thesis in all the remaining cases.
execution ex in which the prefix ⟨a1,... , aj⟩ of snesting occurs, then in ex the In order to prove the proposition we have to prove that if we consider an open capabilities are executed in the order which corresponds to the prefix
length j of sopen. This is again an immediate consequence of condition (iii)
of Definition 3.1.	 

Using Banana we get that S | C1 satisfies integrity, since Iˆ contains all the three pairs required by Proposition 3.3. Also S | C2 satisfies integrity, since Iˆ the first phase. On the other hand, if we consider S | C3, Iˆ contains a suffix contains only the first pair, which means that the execution has blocked after (instead of a prefix) of snesting. In fact S | C3 does not satisfy integrity, since it skips two checks.
Notice that S | C can satisfy integrity even if Iˆ does not contain a prefix of snesting, i.e., the vice-versa of Proposition 3.3 does not hold. Consider for
instance the client C5:
Client [ out Server. address [ out Client.in Server.in Shipping.0 ] ]

In this case Iˆ contains the pair (Shipping,address) and not the other two pairs. However, this is due to an over-approximation, since during the execution
out Server blocks the system S | C5.
Information Leakage
Let us now exploit the tool for what it was originally intended, that is, de- tecting information leakage. This security property is orthogonal to integrity, thus the results obtained are independent one another. Our starting point is the fact that the ordering information sent by the client cannot be disclosed to other untrusted users of the system. We model this fact by labeling as high ambients itemprice, creditcardnum, and address. Then, we apply the analysis of [5], also supported by the tool, to verify if the process is secure and, if not, which ambients should be labeled boundary in order to protect the system.
the execution of S | C process secure, the ordering information (i.e., ambient Using Banana, we can check that the analysis fails. In fact, in order to make itemprice) must be enclosed in a new boundary ambient which protects the
data when it moves out of the client. This requirement corresponds to the SSL-protected network socket requirement of [15].

Comparisons and Conclusions
In [15] the authors informally described a simple E-Commerce case study. They showed how to: express it in a highly abstract model of the SELinux op- erating system access control mechanism; express integrity in temporal logic; verify the integrity of the system using model checking.
In this paper we started from the informal description of the E-Commerce system presented in [15] and we considered two different approaches to study its integrity:
a dynamic verification technique on the SPA language;
a static analysis technique on Mobile Ambients.
As far as the modeling is concerned it is easy to see in the E-Commerce systems we proposed there are many similarities, even if: in the SPA language we had to add low level observable actions to check integrity; in Mobile Ambients we had to exploit in, out, and open capabilities to simulate communications. On the other hand, the main differences concern the verification techniques we used:
the dynamic verification technique is correct, no approximation is explicitly introduced by the technique, and it does not require to model the intruder,

but in the worst-case it has a time/space exponential cost;
the static analysis technique gives us a partial result (thanks to Proposition 3.3) and it requires an explicit modeling of the intruder, but it has a (low) polynomial complexity 4 .
Notice that in order to exploit the static analysis technique to verify integrity we had to prove Proposition 3.3. In fact, we had to prove that, thanks to particular syntactic hypothesis on the processes, the over-approximation is limited. We are presently investigating a possible generalization of this result not depending on the particular system under analysis.
The basic results we get with the two analyses are comparable: the intrud- ers we found in Mobile Ambients correspond to the fact that in SPA without restriction the model is not secure. After getting such common results, we moved into different directions in order to analyze as many aspects as possi- ble: in SPA we applied a restriction over channels and we added other details to the model; in Mobile Ambients we studied syntactic restrictions which allow us to discriminate a priori a large number of intruders.
The above considerations suggest a natural combination of the two tech- niques: apply the dynamic verification technique when the static analysis one does not prove the integrity.
Comparing our analysis with the results in [15] we notice that the model presented in [15] aims at representing the access control policy of SELinux, while our models are more abstract: we decide/infer that some channels have to be secure without describing how to implement them. As a consequence also the integrity results discussed in [15] are strongly related to the imple- mentation of the system in SELinux, e.g., the system satisfies the integrity goal assuming that the administrators are trustworthy.
Acknowledgements
We thank Annalisa Bossi, Agostino Cortesi, Riccardo Focardi, Flaminia Luc- cio, and Sabina Rossi for their suggestions and comments. We also thank Riccardo Cannas, Stefano Filippone, and Enrico Pivato who were involved in the developing of the tools. Finally we thank Roberto Zunino for the useful discussion during the Mefisto meeting in Pisa.

References
D. Bell. Lapadula Secure Computer System: Unified Exposition and Multics, 1975.

4 It is not interesting to report here the time/space statistics shown by the tools, since this example is not large/complex enough to show significant differences.


A. Bossi, R. Focardi, C. Piazza, and S. Rossi.  Verifying Persistent Security Properties. Computer Languages, Systems and Structures, 2003. To appear. Available at http://www.dsi.unive.it/∼srossi/cl03.ps.gz.
C. Braghin, A. Cortesi, and R. Focardi. Security Boundaries in Mobile Ambients. Computer Languages, 28(1):101–127, 2002.
C. Braghin, A. Cortesi, R. Focardi, F.L. Luccio, and C. Piazza. Nesting Analysis of Mobile Ambients. Computer Languages, Systems and Structures, 2003. To appear.
C. Braghin, A. Cortesi, R. Focardi, and S. van Bakel. Boundary Inference for Enforcing Security Policies in Mobile Ambients. In Ricardo Baeza-Yates, Ugo Montanari, and Nicola Santoro, editors, Proc. IFIP Conference on Theoretical Computer Science (IFIP TCS’02), pages 383–395. Kluwer Academic Publishers, 2002.
L. Cardelli and A. D. Gordon. Mobile Ambients. In M. Nivat, editor, Proc. of Foundations of Software Science and Computation Structures (FoSSaCS’98), volume 1378 of LNCS, pages 140–155. Springer-Verlag, 1998.
L. Cardelli and A. D. Gordon. Mobile Ambients. Theoretical Computer Science, 240(1):177– 213, 2000.
P. Degano, F. Levi, and C. Bodei. Safe Ambients: Control Flow Analysis and Security. In Jifeng He and Masahiko Sato, editors, Proc. of Advances in Computing Science - Asian Computing Science Conference, Penang, Malaysia (ASIAN’00), volume 1961 of LNCS, pages 199–214. Springer-Verlag, 2000.
A. Dovier, C. Piazza, and A. Policriti. A Fast Bisimulation Algorithm. In G. Berry, H. Comon, and A. Finkel, editors, Proc. of Int. Conference on Computer Aided Verification (CAV’01), volume 2102 of LNCS, pages 79–90. Springer-Verlag, 2001.
A. Durante, R. Focardi, and R. Gorrieri. A compiler for analysing cryptographic protocols using non-interference. ACM Transactions on Software Engineering and Methodology (TOSEM), 9(4):488–528, October 2000.
R. Focardi and R. Gorrieri. A Classification of Security Properties for Process Algebras.
Journal of Computer Security, 3(1):5–33, 1994/1995.
R. Focardi, R. Gorrieri, and F. Martinelli. Non Interference for the Analysis of Cryptographic Protocols. In U. Montanari, J. D. P. Rolim, and E. Welzl, editors, Proc. of Int. Colloquium on Automata, Languages and Programming (ICALP’00), volume 1853 of LNCS, pages 744–755. Springer-Verlag, 2000.
R. Focardi and S. Rossi. Information Flow Security in Dynamic Contexts. In Proc. of the 15th IEEE Computer Security Foundations Workshop (CSFW’02), pages 307–319. IEEE Computer Society Press, 2002.
J. A. Goguen and J. Meseguer. Security Policies and Security Models. In Proc. of the IEEE Symposium on Security and Privacy (SSP’82), pages 11–20. IEEE Computer Society Press, 1982.
J. D. Guttman, A. L. Herzog, and J. D. Ramsdell. Information Flow in Operating Systems: Eager Formal Methods. Presented at Workshop on Issues in the Theory of Security 2003 (WITS’03).
R. R. Hansen, J. G. Jensen, F. Nielson, and H. R. Nielson. Abstract Interpretation of Mobile Ambients. In A. Cortesi and G. File’, editors, Proc. of Static Analysis Symposium (SAS’99), volume 1694 of LNCS, pages 134–148. Springer-Verlag, 1999.
R. R. Hansen, J. G. Jensen, F. Nielson, and H. R. Nielson. Validating Firewalls in Mobile Ambients. In J. C. M. Baeten and S. Mauw, editors, Proc. of Int. Conference on Concurrency Theory (CONCUR’99), volume 1664 of LNCS, pages 463–477. Springer-Verlag, 1999.
J. K. Millen. “Finite-State Noiseless Covert Channels”. In Proc. of the Computer Security Foundations Workshop II, pages 81–86. the MITRE Corporation, IEEE Computer Society Press, 1989.

R. Milner. Communication and Concurrency. Prentice-Hall, 1989.
F. Nielson, R. R. Hansen, and H. R. Nielson. Abstract Interpretation of Mobile Ambients.
Science of Computer Programming - Special Issue on Static Analysis edited by A. Cortesi and
G. File’, 47(2-3):145–175, 2003.
R. Paige and R. E. Tarjan. Three Partition Refinement Algorithms. SIAM Journal on Computing, 16(6):973–989, 1987.
C. R. Tsai, V. D. Gligor, and C. S. Chandersekaran. “On the Identification of Covert Storage Channels in Secure Systems”. IEEE Transactions on Software Engineering, pages 569–580, June 1990.
