Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 344 (2019) 47–65
www.elsevier.com/locate/entcs

A Formalisation of Nominal C-Matching through Unification with Protected Variables
Mauricio Ayala-Rinc´on†,‡ 1,2
Washington de Carvalho-Segundo‡4 Maribel Fern´andez∗3 Daniele Nantes-Sobrinho†5
Departments of †Mathematics and ‡Computer Science Universidade de Bras´ılia
Bras´ılia D.F., Brazil
∗Department of Informatics King’s College London London, U.K.

Abstract
This work adapts a formalisation in Coq of a nominal C-unification algorithm to include “protected vari- ables” that cannot be instantiated during the unification process. By introducing protected variables we are able to reuse the C-unification algorithm to solve nominal C-matching (as well as equality check) prob- lems. From the algorithmic point of view having this extension would be enough to adapt the C-unification algorithm for dealing with equational check as well as with C-matching problems, but the resulting algo- rithms would not be formally checked by simple reuse of the original formalisation. This paper describes the additional effort necessary in order to adapt the specification and reuse previous formalisations.
Keywords: Nominal Unification, Nominal Matching, Commutative Theory, C-Unification, Formal Methods, Coq


Introduction
Nominal uniﬁcation [24,23] is the problem of solving equations between nominal terms, that is, terms that include binding operators, in which solutions should be defined modulo α-equivalence. Nominal matching is a restriction of nominal unification, in which only one side of the equation can be instantiated. This work

1 Research partially supported by the Brazilian Federal District Foundation FAPDF within grant DE 0193001369/2016.
2 Email: ayala@unb.br Author partially supported by a high productivity research grant from the Brazilian National Council for Scientific and Technological Development CNPq.
3 Email: maribel.fernandez@kcl.ac.uk
4 Email: wtonribeiro@gmail.com
5 Email: dnantes@unb.br

https://doi.org/10.1016/j.entcs.2019.07.004
1571-0661/© 2019 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

is about a formalisation in Coq of a nominal matching algorithm, where terms may include commutative operators. This problem is known as nominal C-uniﬁcation.
In nominal syntax [19], terms include function symbols, abstractions, and two kinds of variables: atoms and unknowns (or simply variables). Atoms are used to represent object-level variables whereas unknowns behave like first-order variables, except that they can have “suspended atom permutations” which act when the variable is instantiated by a term. Atoms can be abstracted over terms, the nominal term [a]s represents the abstraction of a in s and α-equivalence is axiomatised by means of a freshness relation a#t (read: a is fresh in t) and name-swappings (a b), which implement renamings. For example, the first-order logic formula ∀a.a ≥ 0 can be written as a nominal term ∀([a]geq(a, 0)), using function symbols ∀ and geq and

an abstracted atom a. Notice that ∀([a]geq(a, X)) ≈?
∀([b]geq(Y, 0)) is a nominal

unification problem whose solution should be such that a does not occur free in Y .
Nominal unification is a decidable problem and efficient nominal unification al- gorithms are available [18,12,11], that compute solutions consisting of freshness con- texts (containing freshness constraints of the form a#X) and substitutions. Nomi- nal unification modulo commutativity (C), consists of nominal unification problems in which the signature of terms contains commutative function symbols. This alge- braic property has to be taken into account during the unification process.
In [2], we proposed a nominal C-unification algorithm based on a set of sim- plification rules. This algorithm generates, for each solvable nominal C-unification

problem, a finite set of ﬁxed point equations of the form π · X ≈?
X, where π is a

permutation and X is a variable, together with a set of freshness constraints and a substitution. In contrast, the output of the standard nominal unification algorithm consists only of substitutions and freshness constraints. Fixed point equations can be easily eliminated in the standard unification algorithm (they are replaced by freshness constraints), but this is not the case in the presence of commutative sym-

bols. For instance, the fixed point equation (a b) · X ≈?
X has infinite solutions

X/a + b, X/(a + b)+ (a + b),... (see [3] for a procedure to generate solutions of fixed point equations).
The approach in [2] was specified and its correctness and completeness formalised in Coq. In this paper, we adapt the nominal C-unification algorithm specified in [2] to provide a fully verified specification of a nominal C-matching approach. An additional parameter X that is a set of protected variables is now considered as part of the input problem. These variables will not be instantiated during the unification process and therefore, the domain of solutions will be disjoint from this set. If the set of protected variables is empty, the approach solves general nominal C-unification problems; if the set of protected variables consists of the variables occurring in the right-hand side of equations in the problem given as input, the algorithm will output a C-matching solution of this problem, if such solution exists; and if the set of protected variables consists of all the variables occurring in the input problem, the algorithm becomes a C-equational checker. Although these conclusions are obvious from the operational point of view, one cannot straightforwardly reuse the formalisation of the nominal C-unification specification to verify the derived

nominal C-matching algorithm. In this paper, we show how the formalisation of correctness and completeness of the nominal C-matching specification was reached.
To summarise, the contributions of this paper are:
An extension of the nominal C-unification algorithm proposed in [2] that adds a parameter for protected variables. The paper shows how previous formalisations were reused in order to prove termination, soundness and completeness of this extension.
An algorithm for nominal C-matching that is obtained by defining the set of protected variables to be the set of variables on the right-hand side of equations in the input problem. Necessary specifications of nominal C-matching problems and solutions are required and then the algorithm is proven to be terminating, sound and complete.
Additional products are obtained that also require formalisation. For instance as a by-product, a nominal C-equational checker is obtained, by defining the set protected variables to be the set of all variables in the input problem.
All the proofs presented in this paper were formalised in the proof management system Coq, and are available at http://ayala.mat.unb.br/publications.html.

Related work
Equational unification and matching have been studied in automated reasoning and deduction for more than three decades providing interesting problems (some still open) and efficient solutions. For instance, F. Baader, K. Schulz, P. Narendran,
M. Schmidt-Schaußand W. Snyder, in [8,9,10], have investigated several aspects re- lated with general unification with equational theories and combinations of disjoint equational theories, whereas F. Fages, D. Kapur, P. Narendran and J.H. Siekmann have studied associative and/or commutative unification, matching and their com- plexities [14,15,16,17,21,22].
Nominal equational unification was initially investigated in [5] and [20]: in the former paper, the relation of nominal narrowing is defined and a lifting result re- lating nominal narrowing and unification is proven, whereas in the latter paper a nominal unification approach for higher order expressions with recursive let is presented.
The nominal C-unification algorithm proposed in [2] outputs a triple consisting of a substitution, a freshness context and a set of fixed point problems, and it was noticed that the set of fixed point equations could generate infinite solutions. In order to give explicit solutions for the fixed point problems, in [1], combinatorial solutions based on permutation cycles and pseudo-cycles were generated, and an exhaustive search algorithm was given. Thus, if solutions are expressed only with freshness contexts and substitutions, nominal C-unification is infinitary, in contrast with standard first-order C-unification which is finitary.
In addition to the Coq formalisation of nominal C-unification in [2], there are formalisations of non equational nominal unification in Isabelle [23] and PVS [7]. Regarding formalisations in the (non nominal) standard syntax, Contejean [13] for-

malised AC-matching in Coq.
Recently, a new axiomatisation of the alpha equivalence relation for nominal terms was presented [6], which is based on fixed point constraints and allows a finite representation of solutions of nominal C-unification problems, consisting of a substitution and a fixed point context.

Organisation
Section 2 presents basic concepts and notations. Section 3 presents the exten- sion of simplification rules for nominal C-unification with protected variables, and discusses how the formalisations of termination, soundness and completeness were adapted. Section 4 introduces the nominal C-matching algorithm, and discusses the formalisation of its termination, soundness and completeness properties. Section 5 concludes the paper.

Background
Consider countable disjoint sets of variables X := {X, Y, Z, ···} and atoms A :=
{a, b, c, ··· }. A permutation π is a bijection on A with a finite domain, where the domain (i.e., the support ) of π is the set dom(π) := {a ∈ A | π · a /= a}. We will assume as in [4] countable sets of function symbols with different equational properties such as associativity, commutativity, idempotence, etc. Function symbols have superscripts that indicate their equational properties; thus, f C will denote the kth function symbol that is commutative and f∅ the jth function symbol without
any equational property.
Definition 2.1 [Nominal Grammar] Nominal terms are generated by the following grammar.

s, t := ⟨⟩ | a¯ | [a]t | ⟨s, t⟩ | f E t | π.X
⟨⟩ denotes the unit (that is the empty tuple), a¯ denotes an atom term, [a]t
denotes an abstraction of the atom a over the term t, ⟨s, t⟩ denotes a pair, f E t the application of f E to t and, π.X a moderated variable or suspension. Suspensions of the form id.X will be represented just by X.
The inverse of π is denoted by π−1. Permutations can be represented by lists of swappings, which are pairs of different atoms (a b); hence a permutation π is a finite list of the form (a1 b1) :: ... :: (an bn) :: nil, where the empty list nil corresponds to the identity permutation; concatenation is denoted by ⊕ and, when no confusion may arise, :: and nil are omitted. We follow Gabbay’s permutative convention: Atoms differ on their names, so for atoms a and b the expression a /= b is redundant.
Definition 2.2 [Permutation action] The action of a permutation π on a term t, denoted as π · t, is recursively defined as:



π · ⟨⟩ := ⟨⟩	π · ⟨u, v⟩ := ⟨π · u, π · v⟩	π · f E t	:= f E (π · t)
k	k
π · a  := π · a	π · ([a]t) := [π · a](π · t)	π · (πj .X) := (πj ⊕ π) .X 

Notice that according to the definition of the action of a permutation over atoms, the composition of permutations π and πj, usually denoted as π ◦ πj, corresponds to the append πj ⊕ π. Also notice that πj ⊕ π · t = π · (πj · t). The difference set between two permutations π and πj is the set of atoms where the action of π and πj differs: ds(π, πj) := {a ∈A| π · a /= πj · a}.
The set of variables occurring in a term t will be denoted as var(t). This notation extends to a set S of terms in the natural way: var(S)=  t∈S var(t).
A substitution σ is a mapping from variables to terms such that X /= Xσ only
for a finite set of variables. This set is called the domain of σ and is denoted by dom(σ). For X ∈ dom(σ), Xσ is called the image of X by σ. Define the image of σ as im(σ)= {Xσ | X ∈ dom(σ)}. The set of variables occurring in the image of σ is then var(im(σ)). A substitution σ with dom(σ) := {X0, ··· , Xn} can be represented as a set of binds in the form {X0/t0, ··· , Xn/tn}, where for 0 ≤ i ≤ n, Xiσ = ti.
Definition 2.3 [Substitution action] The action of a substitution σ on a term t, denoted tσ, is defined recursively as follows:
⟨⟩σ	:= ⟨⟩	aσ	:= a	(f E t)σ := f E tσ
k	k
⟨s, t⟩σ := ⟨sσ, tσ⟩	([a]t)σ := [a]tσ	(π.X)σ := π · Xσ
Example 2.4 For term t = ⟨(a b).X, f (e)⟩ and substitution σ = {X/[a]a}, we obtain that ((a b).X)σ = ⟨[b]b, f (e)⟩ ≈α ⟨[a]a, f (e)⟩ = Xσ, for some unary function symbol f in the signature.
The following result can be proved by induction on the structure of terms.
Lemma 2.5 (Substitutions and Permutations Commute) (π · t)σ = π · (tσ) The inference rules defining freshness and α-equivalence are given in Fig. 1 and
2. The symbols ∇ and Δ are used to denote freshness contexts that are sets of
constraints of the form a#X, meaning that the atom a is fresh in X. The domain of a freshness context dom(Δ) is the set of atoms appearing in it; Δ|X denotes the restriction of Δ to the freshness constraints on X: {a#X | a#X ∈ Δ}. The rules in Fig. 1 are used to check if an atom a is fresh in a nominal term t under a freshness context ∇, also denoted as ∇▶ a#t.
The rules in Fig. 2 are used to check if two nominal terms s and t are α- equivalent under some freshness context ∇, written as ∇▶ s ≈α t. These rules use the inference system for freshness constraints: specifically freshness constraints are used in rule (≈α [ab]).

Remark 2.6 dom(π)#X	and	ds(π, πj)#X	denote,	respectively,	the	sets
{a#X | a ∈ dom(π)} and {a#X | a ∈ ds(π, πj)}. Notice that dom(π)= ds(π, id).


Fig. 1. Rules for the freshness relation


















Fig. 2. Rules for the relation ≈α
Key properties of the nominal freshness and α-equivalence relations have been extensively explored in previous works [4,7,23,24], among them we have freshness preservation: If ∇ ▶ a # s and ∇ ▶ s ≈α t, then ∇ ▶ a # t; equivariance: for all permutations π, if ∇▶ s ≈α t then ∇▶ π · s ≈α π · t; and, equivalence: ∇▶  ≈α is an equivalence relation.

A nominal C-unification algorithm with protected variables
In [2] we proposed a nominal C-unification algorithm which used sets of transfor- mation rules to deal with equations (Figure 4) and another set of rules to deal with freshness constraints and contexts (Figure 3). These rules act over triples of the form ⟨∇, σ,P ⟩, where σ is a substitution. In this work, we will deal with nominal C-equational problems including another parameter that is a set X of protected variables. This parameter indicates which variables are forbidden to be instanti- ated. The quadruple that will be associated with a C-equational problem of the form ⟨∇, X,P⟩ is ⟨∇, X, id, P⟩. Calligraphic uppercase letters (e.g., P, Q, R, etc) will denote quadruples.

Definition 3.1 [Unification and matching problem] A uniﬁcation problem is a triple ⟨∇, X,P⟩, where ∇ is a freshness context, X a set of protected variables, and P is a finite set of equations and freshness constraints of the form s ≈? t and a#?s, respectively, s and t are terms and a is an atom. Nominal terms in the equa- tions preserve the syntactic restriction that commutative symbols are only applied to tuples. A matching problem consists only of a pair ⟨∇,P⟩.
Definition 3.2 [Solution for a C-unification problem with preserved variables] A solution for a quadruple P = ⟨Δ, X, δ,P ⟩ is a pair ⟨∇, σ⟩, where the domain of σ has no variables in X , and the following conditions are satisfied:

∇▶ Δσ;
(iii) if s ≈? t ∈ P then ∇▶ sσ ≈{α,C} tσ;

if a#?t ∈ P then ∇▶ a # tσ;(iv) there exists λ such that ∇▶ δλ ≈ σ.
A solution for a C-equational problem with preserved variables ⟨Δ, X,P⟩ is a solution for the associated quadruple ⟨Δ, X, id, P⟩. The solution set for a problem or quadruple P is denoted by UC(P).
We will denote the set of variables occurring in the set P of a problem P or quadruple P = ⟨∇, X, σ,P ⟩ as var(P ) or var(P), respectively.
When X equals ∅, the notions of C-unification problem with preserved variables, and its solutions coincide with the corresponding notions for C-unification as given in [2]. For simplicity, C-unification problems and solutions with preserved variables will be called just C-unification problems and solutions.


Fig. 3. Reduction rules for freshness problems
w
These inference rules transform a nominal unification problem into a finite set of unification problems consisting only of ﬁxed point equations, i.e., equations of the form π.X ≈? X, together with a substitution and a freshness context. P is called a ﬁxed point problem if it is a set of fixed point equations. We will denote by P≈, P# and Pfp≈ the sets of equations, freshness problems and fixed point equations in the set P of a unification problem ⟨∇, X,P⟩.
Also, we use rules described in Fig. 5, called uniﬁcation steps, which give a strategy for application of rules specified as presented in Figs. 4 and 3.




Fig. 4. Reduction rules for equational problems
Differently from [2], rule (≈? inst), checks whether the variable X is a protected variable, before applying the instantiation.
Notice that the set X has not effect on the rules for freshness. Rules in Fig. 4 will be applied without restrictions by use of rule (υ≈), but freshness constraints are reduced only when all equations were reduced and the problem consists of fixed point equations. This fact is expressed by the condition P≈ = Pfp≈ in rule (υ#).


Fig. 5. Unification step
Derivation with rules of Fig.  4 is denoted by ⇒≈; thus, ⟨∇, X, σ,P ⟩ ⇒≈
⟨∇, X, σj,Pj⟩ means that the second quadruple is obtained from the first one by application of one rule. We will use the standard rewriting nomenclature, e.g., we will say that P is a normal form or irreducible by ⇒≈, denoted by ⇒≈-nf, whenever
there is no Q such that P ⇒≈ Q; ⇒∗ and ⇒+ denote respectively derivations in
zero or more and one or more applications of the rules in Fig. 4. Derivation with rules of Fig. 3 is denoted by ⇒#.
The theorem below summarises the termination and correctness results regard- ing the algorithm proposed.
Theorem 3.3 (Properties of ⇒≈, ⇒# and ⇒υ)
(Decidability of ⇒≈, ⇒# and ⇒υ)Given a quadruple P, it is possible to decide whether P is a normal form w.r.t. ⇒≈ (resp. ⇒#) or there exists Q such that P ⇒≈ Q (resp. P ⇒# Q).
(Termination of ⇒≈, ⇒# and ⇒υ)The relations ⇒≈, ⇒# and ⇒υ are termi- nating.

(Completeness of ⇒#) If P ⇒# Q, then ⟨∇, σ⟩∈ UC(P) if and only if ⟨∇, σ⟩∈ UC(Q).
Proof. The proofs are obtained by adjusting proofs in [2] taking into account the set of variables X .	2
Remark 3.4 We will call Q a leaf if it is a normal form w.r.t. ⇒υ.
For completeness, we will restrict ourselves to idempotent solutions, in order to obtain such property, we will restrict the applications of rules to valid quadruples.
Definition 3.5 [Valid quadruple] P = ⟨∇, X, σ,P ⟩ is valid if im(σ) ∩ dom(σ) = ∅ and dom(σ) ∩ var(P )= ∅.
As for Theorem 3.3 , the formalisations of Lemmas 3.6, 3.7, 3.8, and Theorems
3.10 and 3.12 are quite similar to the proofs of corresponding lemmas in [2]. For this reason, they are omitted.
Lemma 3.6 (Preservation of valid quadruples)
If P ⇒# Q or P ⇒≈ Q, and P is valid then Q is also valid.
If P ⇒υ Q and P is valid then Q is also valid.
Lemma 3.7 (Preservation of solutions) Let P be a valid quadruple.
If P ⇒≈ Q and ⟨∇, σ⟩∈ UC(Q), then ⟨∇, σ⟩∈ UC(P).
If P ⇒υ Q and ⟨∇, σ⟩∈ UC(Q), then ⟨∇, σ⟩∈ UC(P).
Lemma 3.8 (Completeness of ⇒≈ and ⇒υ) Let P be a valid quadruple.
If P is not a normal form w.r.t. ⇒≈, then ⟨∇, σ⟩∈ UC(P) if and only if there exists Q such that P ⇒≈ Q and ⟨∇, σ⟩∈ Q.
If P is not a leaf, then ⟨∇, σ⟩∈ UC(P) if and only if there exists Q such that
P ⇒υ Q and ⟨∇, σ⟩∈ Q.
Example 3.9 [Nominal C-unification with X equals to the empty set] This example exhibits the execution of the nominal C-unification algorithm for the initial problem
P = ⟨∅, ∅, id, {[a]f⟨[b](X ∗ Y ), Z⟩≈ [b]f⟨[a](a ∗ X), Z⟩}⟩,
where the set of protected variables (X ) is empty; thus, there exists no restriction over the variables of the problem. Notice that the application of rule (≈? C) gen- erates two branches that are represented by items (i) and (ii) in the example. The algorithm generates the leaves ⟨{a#Z}, ∅, {X/b, Y/(a b).X}, {(a b).Z ≈? Z}⟩, and
⟨{a#Z}, ∅, {Y /b}, {(a b).X ≈? X, (a b).Z ≈? Z}⟩.
By Theorem 3.10, the union of the solutions of these two leaves is equal to the set of solutions of the initial problem P. As shown in [1], the complete set of solutions of ⟨{a#Z}, ∅, {X/b, Y/(a b).X}, {(a b).Z ≈? Z}⟩ is unitary whereas the complete set of solutions of ⟨{a#Z}, ∅, {Y/b}, {(a b).X ≈? X, (a b).Z ≈? Z}⟩ is infinite. Figure 3 illustrates the C-unification derivation three for P.






















Fig. 6. Derivation tree for nominal C-unification.
P = ⟨∅, ∅, id, {[a]f⟨[b](X ∗ Y ), Z⟩≈ [b]f⟨[a](a ∗ X), Z⟩}⟩
⇒(≈?[ab]) ⟨∅, ∅, id, {f⟨[b](X ∗ Y ), Z⟩ ≈? f⟨[b](b ∗ (a b).X), (a b).Z⟩, a#?f⟨[a](a ∗
X), Z⟩}⟩
⇒(≈?app) ⟨∅, ∅, id, {⟨[b](X ∗ Y ), Z⟩ ≈? ⟨[b](b ∗ (a b).X), (a b).Z⟩, a#?f⟨[a](a ∗
X), Z⟩}⟩
⇒(≈?pair) ⟨∅, ∅, id, {[b](X ∗ Y ) ≈? [b](b ∗ (a b).X), Z ≈? (a b).Z, a#?f⟨[a](a ∗
X), Z⟩}⟩
⇒(≈?[aa]) ⟨∅, ∅, id, {X ∗ Y ≈? (b ∗ (a b).X), Z ≈? (a b).Z, a#?f⟨[a](a ∗ X), Z⟩}⟩
(i)
⇒(≈?C) ⟨∅, ∅, id, {X ≈? b, Y ≈? (a b).X, Z ≈? (a b).Z, a#?f⟨[a](a ∗
X), Z⟩}⟩
⇒(≈?inst) ⟨∅, ∅, {X/b}, {Y ≈? (a b).X, Z ≈? (a b).Z, a#?f⟨[a](a ∗
X), Z⟩}⟩
⇒(≈?inst) ⟨∅, ∅, {X/b, Y/(a b).X}, {Z ≈? (a b).Z, a#?f⟨[a](a∗X), Z⟩}⟩
⇒(≈?inv) ⟨∅, ∅, {X/b, Y/(a b).X}, {(a b).Z ≈? Z, a#?f⟨[a](a∗X), Z⟩}⟩
⇒(#?app) ⟨∅, ∅, {X/b, Y/(a b).X}, {(a b).Z ≈? Z, a#?⟨[a](a ∗X), Z⟩}⟩
⇒(#?pair) ⟨∅,  ∅,  {X/b,  Y/(a b).X},  {(a b).Z	≈?	Z,  a#?[a](a ∗
X), a#?Z}⟩
⇒(#?a[a]) ⟨∅, ∅, {X/b, Y/(a b).X}, {(a b).Z ≈? Z, a#?Z}⟩
⇒(#?var) ⟨{a#Z}, ∅, {X/b, Y/(a b).X}, {(a b).Z ≈? Z}⟩
(ii)
⇒(≈?C) ⟨∅, ∅, id, {X ≈? (a b).X, Y ≈? b, Z ≈? (a b).Z, a#?f⟨[a](a ∗
X), Z⟩}⟩
⇒(≈?inv) ⟨∅, ∅, id, {(a b).X ≈? X, Y ≈? b, Z ≈? (a b).Z, a#?f⟨[a](a ∗
X), Z⟩}⟩



⇒(≈?inst) ⟨∅, ∅, {Y /b}, {(a b).X ≈? X, Z ≈? (a b).Z, a#?f⟨[a](a ∗
X), Z⟩}⟩
⇒(≈?inv) ⟨∅, ∅, {Y /b}, {(a b).X ≈? X, (a b).Z ≈? Z, a#?f⟨[a](a ∗
X), Z⟩}⟩
⇒(#?app) ⟨∅, ∅, {Y/b}, {(a b).X ≈? X, (a b).Z ≈? Z, a#?⟨[a](a ∗
X), Z⟩}⟩
⇒(#?pair) ⟨∅, ∅, {Y /b}, {(a b).X ≈? X, (a b).Z ≈? Z, a#?[a](a ∗
X), a#?Z}⟩
⇒(#?a[a]) ⟨∅, ∅, {Y /b}, {(a b).X ≈? X, (a b).Z ≈? Z, a#?Z}⟩
⇒(#?var) ⟨{a#Z}, ∅, {Y /b}, {(a b).X ≈? X, (a b).Z ≈? Z}⟩
Theorem 3.10 (Correctness of ⇒∗ ) Let P be a valid quadruple.
(Soundness of ⇒∗ ) If P ⇒∗ Q, Q is a leaf and ⟨∇, σ⟩∈ UC(Q) then ⟨∇, σ⟩∈ 
υ	υ
UC(P).
(Completeness of ⇒∗ ) ⟨∇, σ⟩∈ UC(P) if and only if there exists a leaf Q such that P ⇒∗ Q and ⟨∇, σ⟩∈ Q.
Definition 3.11 [Proper problem] A quadruple P = ⟨Δ, X, δ,P ⟩ is called a proper problem if every commutative function symbol in P has a tuple as argument.
Theorem 3.12 (Characterisation of successful leaves) Let Q = ⟨Δ, X, δ, Q⟩ a leaf, if Q is a proper problem and there exists ⟨∇, σ⟩∈ UC(Q) with dom(σ)∩X = ∅, then Q is a ﬁxed point problem.

Nominal C-matching
In this section we restrict our attention to nominal matching problems: a nominal unification problem whose solutions should be applied only to the left-hand side of the nominal equations.
We specify a nominal C-matching algorithm that consists of applications of the matching step rules presented in Figure 7. These rules basically apply the rules in Figure(s 4, 3 and) 5, but now the set X of protected variables plays an important role and should be defined as the variables occurring in the right-hand sides of the set of equational constraints P in the input problem.
Definition 4.1 [Protected variables and C-matching problems] The set of pro- tected variables for a matching problem ⟨∇,P⟩ (see Definition 3.1) is the set of right-hand side variables of the equational constraints in P , denoted by Rvar(P ), i.e., Rvar(P )= {X | s ≈? t ∈ P and X ∈ var(t)}. The quadruple associated with the C-matching problem ⟨∇,P⟩ is given by ⟨∇, Rvar(P ), id, P⟩.
When solving a problem according to the rules in Fig. 7 using the protected variables given in Def. 4.1, the domain of a substitution that is a solution will be disjoint from the set of right-hand side variables of the problem.
Derivation with rules of Fig. 7 is denoted by ⇒μ.



Fig. 7. Matching step
Definition 4.2 [Solution for a C-matching problem] A C-matching solution for a quadruple P of the form ⟨Δ, Rvar(P ), δ,P ⟩ is a pair ⟨∇, σ⟩, where dom(σ) ∩ Rvar(P )= ∅, and the following conditions are satisfied:

∇▶ Δσ;
∇▶ sσ ≈{α,C} t, if s ≈? t ∈ P ;

∇▶ a # tσ, if a#?t ∈ P ;(iv) there is a substitution λ such that ∇▶ δλ≈σ.
A C-matching solution for the problem ⟨Δ,P⟩ is a solution for ⟨Δ, Rvar(P ), id,P⟩, its associated C-matching problem. The solution set for a matching problem P is denoted by MC(P).
Remark 4.3 We will call a quadruple Q a matching leaf if Q is a normal form
w.r.t. ⇒μ.
Auxiliary properties of nominal C-matching
We now present the main auxiliary lemmas related with nominal C-unification no- tions included in the formalisation.
Remark 4.4 In the specification, the set of protected variables of a C-matching problem is given as a parameter of the deductive system that remains unchanged during derivations. For simplicity, in the following results the protected set is de- noted as X .
Lemma 4.5 (UC and MC equivalence) Let P = ⟨Δ, X, δ,P ⟩ be a quadruple. Then, ⟨∇, σ⟩∈ UC(P) if and only if ⟨∇, σ⟩∈ MC(P).
Proof. The formalisation follows straightforwardly from the definitions of UC(P) and MC(P).	2
Remark 4.6 Despite the fact that the reduction rules (Figures 3, 4, and 7) preserve the set X of protected variables given as input, in the following formalised results, for quadruples of the form P = ⟨Δ, X, δ, P⟩ and Q = ⟨Δj, X, δj, Q⟩, where P ⇒μ Q, the sets Rvar(P ) and Rvar(Q) will be considered. These sets change after reduction steps using rules such as (≈? refl), (≈? inst) and (μfp), but as Lemma
4.7 shows, Rvar(Q) ⊆ Rvar(P ), therefore if Rvar(P ) ⊆X then Rvar(Q) ⊆ X . Since in the matching algorithm X is the set of right-hand side variables of the input problem, for each quadruple in a derivation P0 ⇒μ ... ⇒μ Pn the right-hand side variables are in the protected set.
Lemma 4.7 (Preservation of Rvar by ⇒μ) Let P  = ⟨Δ, X, δ,P ⟩ and Q =
⟨Δj, X, δj, Q⟩ such that P ⇒μ Q. Then Rvar(Q) ⊆ Rvar(P ).
Proof. The formalisation follows by case analysis on the ⇒μ reduction.	2

Corollary 4.8 (Intersection emptyness preservation with right-hand side variables by ⇒μ) Let P and Q be two quadruples, ⟨Δ, X, δ,P ⟩ and ⟨Δj, X, δj, Q⟩, respectively, and Y be an arbitrary set of variables. If Rvar(P )∩Y = ∅ and P ⇒μ Q, then Rvar(Q) ∩Y = ∅.
Proof. This is indeed an easy set theoretically based corollary of Lemma 4.7.  2
Corollary 4.9 (Preservation of valid quadruples by ⇒μ) If P ⇒μ Q and P
is valid then Q is also valid.
Proof. The formalisation follows from Lemma 3.6.	2
Lemma 4.10 (Decidability of ⇒μ) For all quadruple P it is possible to decide whether there exists Q such that P ⇒μ Q. Thus, it is also possible to decide whether P is a leaf.
Proof. The formalisation is obtained by decidability of the relation ⇒υ (item (i) of Theorem 3.3.)	2
Main formalised properties for nominal C-matching
Theorem 4.11 (Termination of ⇒μ) The relation ⇒μ is terminating.
Proof. The proof is by case analysis on the derivation rules of the relation ⇒μ, and uses a lexicographic measure over sets of equation and freshness constraints. The measure is given by

|var(P )|,
s≈?t∈P
|s| + |t|, |P≈/Pfp≈ |,
a#?s∈P
|s| 

Let P = ⟨Δ, X, δ,P ⟩ and Q = ⟨∇, X, σ, Q⟩ such that P ⇒μ Q. For the case of rule (μυ), Theorem 3.3 item (ii) is applied.
For the case of an application of rule (μfp), one observes that:
(i) |var(Q)|≤ |var(P )|,

(ii)
s≈?t∈Q
|s| + |t| <
s≈?t∈P
|s| + |t|,

|Q≈/Qfp≈ | = |P≈/Pfp≈ | and

​
a#?s∈Q
|s| =
a#?s∈P
|s|.

Therefore the measure also decreases in this case, which concludes the proof. 2
Lemma 4.12 (Preservation of solutions by ⇒μ) Let P = ⟨Δ, X, δ,P ⟩ be a valid quatrule and Q = ⟨Δj, X, δj, Q⟩. If Rvar(P ) ∩ dom(σ) = ∅, P ⇒μ Q and
⟨∇, σ⟩∈ MC(Q), then ⟨∇, σ⟩∈ MC(P).
Proof. The proof is by case analysis on the derivation rules of ⇒μ. According Definition 4.2, one has Rvar(Q) ∩ dom(σ)= ∅. From this, the hypothesis Rvar(P ) ∩ dom(σ)= ∅ and using Lemmas 3.7 (item (i)) and 4.5 one concludes the case of rule (μυ). For the case of rule (μfp), one needs to conclude the conditions of Definition 4.2

for the pair ⟨∇, σ⟩ w.r.t. P. Condition (iv) is trivially satisfied. The first condition is proved just observing that every constraint a#X in Δ is also in Δ ∪ dom(π). The second condition is easy proved from the fact that if a#?s ∈ P {π.X ≈? X} then a#?s ∈ P . Then, one applies the hypothesis ⟨∇, σ⟩∈ MC(Q) using Definition 4.2, item (ii), to conclude. The third condition is proved by analysis of two cases. The first case is when s ≈? t ∈ P  {π.X ≈? X} being the equation s ≈? t equal to π.X ≈? X. In this case, one starts proving the statement X ∩ dom(σ) = ∅ using the hypothesis Rvar(P {π.X ≈? X}) ∩ dom(σ) = ∅. Form this, (π.X)σ can be replaced by π.X in the objective ∇ ▶ πXσ ≈{α,C} X, remaining to prove that
∇ ▶ π.X ≈{α,C} X. Then, using the condition (i) of Definition 4.2 of hypothesis
⟨∇, σ⟩ ∈ MC(Q) one has that ∇ ▶ (Δ ∪ dom(π)#X)σ. Since X ∈/ dom(σ), one
concludes that dom(π)#X ⊆∇ and then the objective is proved using the definition of ≈{α,C} for the case of suspensions. The second case is when s ≈? t ∈ P . This case is trivial, and uses hypothesis ⟨∇, σ⟩∈ MC(Q) with Definition 4.2, item (iii).2
Theorem 4.13 (Completeness of ⇒μ) Let P = ⟨Δ, X, δ,P ⟩ a valid quadruple that is not a matching leaf, if Rvar(P ) ∩ dom(σ)= ∅, then ⟨∇, σ⟩∈ MC(P) if and only if there exists Q such that P ⇒μ Q and ⟨∇, σ⟩∈ MC(Q).
Proof. Necessity is proved by case analysis on the derivation rules of ⇒μ. Lemma
4.10 is applied to the premise that P is not a matching leaf to obtain that there exists Qj such that P ⇒μ Qj. Then for the case of rule (μυ), using Lemmas 3.8 (item (iii)) and 4.5 it is proved the assertion that there exists Qjj such that P ⇒υ Qjj and ⟨∇, σ⟩ ∈ UC (Qj). From this, using again Lemma 4.5, applying rule (μυ) and using Corollary 4.8 one concludes. For the case of rule (μfp), P = ⟨Δ, X, δ,P j 

{π.X ≈? X}⟩ with Pj = Pj
. The quadruple Q = ⟨Δ ∪ dom(π)#X, X, δ,P ⟩ will

be a witness. Thus, P ⇒μ Q follows by an application of rule (μfp). To prove that ⟨∇, σ⟩ ∈ MC(Q), one has to show that the conditions of Definition 4.2 are satisfied, having as hypothesis that ⟨∇, σ⟩ ∈ MC(P).  Conditions (ii), (iii) and
are trivially verified and intersection emptiness is proved using Corollary 4.8. For condition (i), a constraint a#X is chosen that is in Δ ∪ dom(π)#X to analyse if it is either in Δ or dom(π)#X. If a#X is in Δ the proof is trivial, otherwise one first proves the assertion that {X}∩ dom(σ) = ∅ from the hypotheses that P is valid and Rvar(P ) ∩ dom(σ) = ∅. This allows to replace every Xσ and every (π.X)σ, respectively, just by X and π.X, because X ∈/ dom(σ). Since π.X ≈? X is in P {π.X ≈? X} and ⟨∇, σ⟩ ∈ MC(P), we have that ∇ ▶ (π.X)σ ≈{α,C} X, therefore ∇▶ π.X ≈{α,C} X and then dom(π)#X ⊆ ∇. On the other hand, having a ∈ dom(π) as hypothesis, one has to prove that ∇ ▶ a#Xσ, which is the same as
∇▶ a#X. Using the fact that dom(π)#X ⊆ ∇, one concludes.
Sufficiency is formalised as a direct consequence of Lemma 4.12.	2
Theorem 4.14 (Soundness of ⇒∗ ) Let P = ⟨Δ, X, δ,P ⟩ be a valid quadruple
and P ⇒∗ Q. If Q is a matching leaf and ⟨∇, σ⟩ ∈ MC(Q) such that Rvar(P ) ∩
dom(σ)= ∅ then ⟨∇, σ⟩∈ MC(P).
Proof. The proof uses Corollaries 4.9 and 4.8 and Lemma 4.12, and it is done by induction on the number of steps of ⇒μ. If P = Q the proof is trivial. In the case

were P ⇒μ Q, Lemma 4.12 is applied to conclude. When P ⇒μ R and R ⇒∗ Q, one uses Lemma 4.12, IH and Lemmas 4.9 and 4.8 to conclude.	2
Theorem 4.15 (Completeness of ⇒∗ ) Let P = ⟨Δ, X, δ,P ⟩ be a valid quadru- ple and ⟨∇, σ⟩ ∈ MC(P). Then there exists a matching leaf Q such that P ⇒∗ Q
and ⟨∇, σ⟩∈ MC(Q).
Proof. The formalisation follows by well-founded induction on the number of ap- plications of ⇒μ. Also, Lemma 4.10 is applied in the analysis of the cases where either P is a matching leaf or there exists Qj such that P ⇒μ Qj. If P is a matching leaf then P = Q and the proof is completed. If there exists Qj such that P ⇒μ Qj, one applies Lemma 4.10 to obtain that P is not a matching leaf. Lemma 4.13 is applied to the premise that P is not a matching leaf. Form this and the hypothesis
⟨∇, σ⟩∈ MC(P) one obtains that there exists Qj such that P ⇒μ Qj.
The IH is established as the following statement: ∀R valid, if P ⇒μ R, Rvar(R)∩
dom(σ) and ⟨∇, σ⟩∈ MC(R), then there exists S, such that R ⇒∗ S and ⟨∇, σ⟩∈ 
MC(S).
This is applied to the hypothesis P ⇒μ Qj to conclude that there exists Q, such that Qj ⇒∗ Q and ⟨∇, σ⟩ ∈ MC(Qj). The other premises of IH are achieved with the auxiliary results given by Lemma 4.9 and Corollary 4.8. Finally, by case analysis on the statement Qj ⇒∗ Q, one concludes.	2
Theorem 4.16 (Characterisation of successful matching leaves) Let Q =
⟨Δ, X, δ, Q⟩ a matching leaf, if Q is a proper problem and there exists ⟨∇, σ⟩ ∈ MC(Q), then Q = ∅.
Proof. First one proves the assertion that Q is a fixed point problem. This state- ment is proved using Theorem 3.12, Lemma 4.5 and rule (μυ) of the definition of matching step (Figure 7). Therefore, if Q is a fixed problem it must be equal to the empty set, otherwise Q could be reduced by an application of rule (μfp) of Figure 7, which contradicts the fact that Q is a matching leaf.	2
Example 4.17 [Nominal C-matching] This example is similar to Example 3.9, but now the set of protected variables is equal to the right-hand side variables of the initial problem, that is {X, Z}. This results in the execution of the nominal C- matching algorithm that provides the matching leaves

⟨∅, {X, Z}, { Y/(a b).X}, {X ≈? b, (a b).Z ≈? Z, a#?f⟨[a](a ∗ X), Z⟩}⟩,
and, ⟨{a#X, b#X, a#Z, b#Z}, {X, Z}, {Y /b}, ∅⟩.
Since X is a protect variable, the former problem has no solution due the fact that the equation X ≈? b cannot be solved since X cannot be instantiated. The latter problem has just one solution given by ⟨{a#X, b#X, a#Z, b#Z}, {Y /b}⟩. Theorems
4.14 and 4.15 show that this solution is the unique C-matching solution for the initial problem.
P = ⟨∅, {X, Z}, id, {[a]f⟨[b](X ∗ Y ), Z⟩≈ [b]f⟨[a]((a ∗ X)), Z⟩}⟩

⇒(≈?[ab])  ⟨∅,	{X, Z},	id,	{f⟨[b](X	∗	Y ), Z⟩	≈?	f⟨[b](b	∗
(a b).X), (a b).Z⟩, a#?f⟨[a](a ∗ X), Z⟩}⟩

⇒(≈?app)  ⟨∅,	{X, Z},	id,	{⟨[b](X	∗	Y ), Z⟩	≈?	⟨[b](b	∗
(a b).X), (a b).Z⟩, a#?f⟨[a](a ∗ X), Z⟩}⟩

⇒(≈?pair)  ⟨∅,	{X, Z},	id,	{[b](X ∗ Y )	≈?	[b](b ∗ (a b).X),	Z	≈?
(a b).Z, a#?f⟨[a](a ∗ X), Z⟩}⟩

⇒(≈?[aa]) ⟨∅, {X, Z}, id, {X ∗ Y ≈? (b ∗ (a b).X), Z ≈? (a b).Z, a#?f⟨[a](a ∗
X), Z⟩}⟩
(i)
⇒(≈?C)  ⟨∅,	{X, Z},	id,	{X	≈?	b,	Y	≈?	(a b).X,	Z	≈?
(a b).Z, a#?f⟨[a](a ∗ X), Z⟩}⟩
⇒(≈?inst)  ⟨∅,	{X, Z},	{Y/(a b).X},	{X	≈?	b,	Z	≈?
(a b).Z, a#?f⟨[a](a ∗ X), Z⟩}⟩
⇒(≈?inv)  ⟨∅,	{X, Z},	{  Y/(a b).X},	{X	≈?	b,	(a b).Z	≈?
Z, a#?f⟨[a](a ∗ X), Z⟩}⟩
(ii)
⇒(≈?C)  ⟨∅,	{X, Z},	id,	{X	≈?	(a b).X,	Y	≈?	b,	Z	≈?
(a b).Z, a#?f⟨[a](a ∗ X), Z⟩}⟩
⇒(≈?inv)  ⟨∅,	{X, Z},	id,	{(a b).X	≈?	X,	Y	≈?	b,	Z	≈?
(a b).Z, a#?f⟨[a](a ∗ X), Z⟩}⟩
⇒(≈?inst)  ⟨∅,	{X, Z},	{Y/b},	{(a b).X	≈?	X,	Z	≈?
(a b).Z, a#?f⟨[a](a ∗ X), Z⟩}⟩
⇒(≈?inv)  ⟨∅,	{X, Z},	{Y /b},	{(a b).X	≈?	X,	(a b).Z	≈?
Z, a#?f⟨[a](a ∗ X), Z⟩}⟩
⇒(#?app) ⟨∅, {X, Z}, {Y /b}, {(a b).X ≈? X, (a b).Z ≈? Z, a#?⟨[a](a ∗
X), Z⟩}⟩
⇒(#?pair) ⟨∅, {X, Z}, {Y/b}, {(a b).X ≈? X, (a b).Z ≈? Z, a#?[a](a ∗
X), a#?Z}⟩
⇒(#?a[a]) ⟨∅, {X, Z}, {Y /b}, {(a b).X ≈? X, (a b).Z ≈? Z, a#?Z}⟩
⇒(#?var) ⟨{a#Z}, {X, Z}, {Y /b}, {(a b).X ≈? X, (a b).Z ≈? Z}⟩
⇒(μfp) ⟨{a#X, b#X, a#Z}, {X, Z}, {Y /b}, {(a b).Z ≈? Z}⟩
⇒(μfp) ⟨{a#X, b#X, a#Z, b#Z}, {X, Z}, {Y /b}, ∅⟩

Example 4.18 [Nominal C-equivalence checking] This example exhibits the execution of the nominal C-unification algorithm applied to nominal C-equivalence check. In item (a), the set of protected variables, {X, Y, Z}, consists now of all variables in the input problem. The algorithm generates two leaves

⟨∅, {X, Y, Z}, id, {X ≈? b, Y ≈? (a b).X, (a b).Z ≈? Z, a#?f⟨[a](a ∗ X), Z⟩}⟩
and

⟨∅, {X, Y, Z}, id, {(a b).X ≈? X, Y ≈? b, (a b).Z ≈? Z, a#?f⟨[a](a ∗ X), Z⟩}⟩.

Both are quadruples that have equations without solutions. In the former one, the X cannot be instantiated to solve X ≈? b, and in the latter one, Y cannot be instantiated to solve Y ≈? b.
In item (b), the set of protected variables, {X, Y }, consists also of all variables in the input problem, but the generated leaves are

⟨∅, {X, Y }, id, {X ≈? b, b ≈? (a b).X, (a b).Y ≈? Y, a#?f⟨[a](a ∗ X),Y ⟩}⟩

and, ⟨{a#X, b#X, a#Y, b#Y }, {X, Y }, id, ∅⟩
The first leaf has also equations with the protected variable X. Namely, in equa- tions X ≈? b and b ≈? (a b).X X cannot be instantiated. Thus, neither equation has solutions. On the other branch, the second leaf provides a solution given by the freshness context {a#X, b#X, a#Y, b#Y }.
⟨∅, {X, Y, Z}, id, {[a]f⟨[b](X ∗ Y ), Z⟩≈ [b]f⟨[a](a ∗ X), Z⟩}⟩

⇒(≈?[ab])  ⟨∅,	{X, Y, Z},	id,	{f⟨[b](X	∗ Y ), Z⟩	≈?	f⟨[b](b  ∗
(a b).X), (a b).Z⟩, a#?f⟨[a](a ∗ X), Z⟩}⟩

⇒(≈?app)  ⟨∅,	{X, Y, Z},	id,	{⟨[b](X	∗	Y ), Z⟩	≈?	⟨[b](b	∗
(a b).X), (a b).Z⟩, a#?f⟨[a](a ∗ X), Z⟩}⟩

⇒(≈?pair)  ⟨∅,	{X, Y, Z},	id,	{[b](X ∗ Y )	≈?	[b](b ∗ (a b).X),	Z	≈?
(a b).Z, a#?f⟨[a](a ∗ X), Z⟩}⟩

⇒(≈?[aa]) ⟨∅, {X, Y, Z}, id, {X∗Y ≈? (b∗(a b).X), Z ≈? (a b).Z, a#?f⟨[a](a∗ X), Z⟩}⟩
(i)
⇒(≈?C) ⟨∅,  {X, Y, Z},  id,  {X	≈?	b,  Y	≈?	(a b).X,  Z	≈?
(a b).Z, a#?f⟨[a](a ∗ X), Z⟩}⟩
⇒(≈?inv) ⟨∅,  {X, Y, Z},  id,  {X  ≈? b,  Y	≈? (a b).X, (a b).Z  ≈?
Z, a#?f⟨[a](a ∗ X), Z⟩}⟩
(ii)
⇒(≈?C) ⟨∅,  {X, Y, Z},  id,  {X	≈?	(a b).X,  Y	≈?	b,  Z	≈?
(a b).Z, a#?f⟨[a](a ∗ X), Z⟩}⟩
⇒(≈?inv) ⟨∅,  {X, Y, Z},  id,  {(a b).X	≈?	X,  Y	≈?	b,  Z	≈?
(a b).Z, a#?f⟨[a](a ∗ X), Z⟩}⟩
⇒(≈?inv) ⟨∅,  {X, Y, Z},  id,  {(a b).X  ≈? X,  Y  ≈? b,  (a b).Z  ≈?
Z, a#?f⟨[a](a ∗ X), Z⟩}⟩

⟨∅, {X, Y }, id, {[a]f⟨[b](X ∗ b),Y ⟩≈ [b]f⟨[a](a ∗ X),Y ⟩}⟩

⇒(≈?[ab])  ⟨∅,	{X, Y },	id,	{f⟨[b](X	∗	b),Y ⟩	≈?	f⟨[b](b	∗
(a b).X), (a b).Y ⟩, a#?f⟨[a](a ∗ X),Y ⟩}⟩

⇒(≈?app)  ⟨∅,	{X, Y },	id,	{⟨[b](X	∗	b),Y ⟩	≈?	⟨[b](b	∗

(a b).X), (a b).Y ⟩, a#?f⟨[a](a ∗ X),Y ⟩}⟩

⇒(≈?pair)  ⟨∅,	{X, Y },	id,	{[b](X ∗ b)	≈?	[b](b ∗ (a b).X),	Y	≈?
(a b).Y, a#?f⟨[a](a ∗ X),Y ⟩}⟩

⇒(≈?[aa]) ⟨∅, {X, Y }, id, {X ∗ b ≈? (b ∗ (a b).X), Y ≈? (a b).Y, a#?f⟨[a](a ∗
X),Y ⟩}⟩
(i)
⇒(≈?C)  ⟨∅,	{X, Y },	id,	{X	≈?	b,	b	≈?	(a b).X,	Y	≈?
(a b).Y, a#?f⟨[a](a ∗ X),Y ⟩}⟩
⇒(≈?inv) ⟨∅,  {X, Y },  id,  {X	≈?	b,  b	≈?	(a b).X, (a b).Y	≈?
Y, a#?f⟨[a](a ∗ X),Y ⟩}⟩
(ii)
⇒(≈?C)  ⟨∅,	{X, Y },	id,	{X	≈?	(a b).X,	b	≈?	b,	Y	≈?
(a b).Y, a#?f⟨[a](a ∗ X),Y ⟩}⟩
⇒(≈?inv)  ⟨∅,	{X, Y },	id,	{(a b).X	≈?	X,	b	≈?	b,	Y	≈?
(a b).Y, a#?f⟨[a](a ∗ X),Y ⟩}⟩
⇒(≈?refl) ⟨∅, {X, Y }, id, {(a b).X ≈? X, Y ≈? (a b).Y, a#?f⟨[a](a ∗
X),Y ⟩}⟩
⇒(≈?inv) ⟨∅, {X, Y }, id, {(a b).X ≈? X, (a b).Y ≈? Y, a#?f⟨[a](a ∗
X),Y ⟩}⟩
⇒(≈?app) ⟨∅, {X, Y }, id, {(a b).X ≈? X, (a b).Y ≈? Y, a#?⟨[a](a ∗
X),Y ⟩}⟩
⇒(≈?pair) ⟨∅, {X, Y }, id, {(a b).X ≈? X, (a b).Y ≈? Y, a#?[a](a ∗
X), a#?Y }⟩
⇒(≈?a[a]) ⟨∅, {X, Y }, id, {(a b).X ≈? X, (a b).Y ≈? Y, a#?Y }⟩
⇒(≈?var) ⟨{a#Y }, {X, Y }, id, {(a b).X ≈? X, (a b).Y ≈? Y }⟩
⇒(μfp) ⟨{a#X, b#X, a#Y }, {X, Y }, id, {(a b).Y ≈? Y }⟩
⇒(μfp) ⟨{a#X, b#X, a#Y, b#Y }, {X, Y }, id, ∅⟩

5	Conclusion and future work
This paper presents an extension of the nominal C-unification algorithm proposed in [2], which permits the use of protected variables. When the set of protected variables is the set of the variables in the right-hand side of nominal equational problems given as input, the algorithm outputs a nominal C-matcher for the input problem if one exists. If all the variables of a nominal unification problem are protected, the algorithm becomes a nominal C-equality checker.
The nominal C-matching algorithm was checked through a formalisation in Coq which reused a formalisation of the unification algorithm in [2] plus additional for- malisations related with the main desired properties of the C-matching algorithm that are termination, soundness and completeness.
Work in progress investigates formalisations of nominal AC-unification and matching, and future work will deal with restricted cases such as linear AC- matching, as well as unification modulo more general theories.

References
M. Ayala-Rinc´on, W. Carvalho-Segundo, M. Fern´andez, and D. Nantes-Sobrinho. On Solving Nominal Fixpoint Equations. In Proc. of the 11th Int. Symp. on Frontiers of Combining Systems (FroCoS), volume 10483 of LNCS, pages 209–226. Springer, 2017.
M. Ayala-Rincon, W. Carvalho-Segundo, M. Fern´andez, and D. Nantes-Sobrinho. Nominal C- Unification. In Post-proc. of the 27th Int. Symp. Logic-based Program Synthesis and Transformation (LOPSTR 2017), volume 10855 of LNCS, pages 235–251. Springer, 2018.
M. Ayala-Rinc´on, W. Carvalho-Segundo, M. Fern´andez, and D. Nantes-Sobrinho. A Formalisation of Nominal α-equivalence with A, C, and AC Function Symbols. Theor. Comput. Sci., Accepted 2019.
M. Ayala-Rinc´on, W. de Carvalho Segundo, M. Fern´andez, and D. Nantes-Sobrinho. A formalisation of nominal α-equivalence with A and AC function symbols. ENTCS, 332:21–38, 2017.
M. Ayala-Rinc´on, M. Fern´andez, and D. Nantes-Sobrinho. Nominal Narrowing. In Proc. of the 1st Int. Conf. on Formal Structures for Computation and Deduction (FSCD), volume 52 of LIPIcs, pages 11:1–11:17, 2016.
M. Ayala-Rinc´on, M. Fern´andez, and D. Nantes-Sobrinho. Fixed Point Constraints for Nominal Equational Unfication. In Proc. of the 3rd Int. Conf. Formal Structures for Computation and Deduction (FSCD), volume 108 of LIPIcs, pages 7:1–7:16, 2018.
M. Ayala-Rinc´on, M. Fern´andez, and A. C. Rocha-oliveira. Completeness in PVS of a Nominal Unification Algorithm. ENTCS, 323:57–74, 2016.
F. Baader. The Theory of Idempotent Semigroups is of Unification Type Zero. J. of Autom. Reasoning, 2(3):283–286, 1986.
F. Baader and Klaus U. Schulz. Unification in the Union of Disjoint Equational Theories: Combining Decision Procedures. J. of Sym. Computation, 21(2):211–243, 1996.
F. Baader and W. Snyder. Unification Theory. In Handbook of Automated Reasoning (in 2 volumes), pages 445–532. Elsevier and MIT Press, 2001.
C. F. Calv`es. Complexity and implementation of nominal algorithms. PhD Thesis, King’s College London, 2010.
C. F. Calv`es and M. Fern´andez. The First-order Nominal Link. In Proc. of the 20th Int. Symp. Logic-based Program Synthesis and Transformation (LOPSTR), volume 6564 of LNCS, pages 234–248. Springer, 2011.
E. Contejean. A Certified AC Matching Algorithm. In Proc. of the 15th Int. Conf. on Rewriting Techniques and Applications, (RTA), volume 3091 of LNCS, pages 70–84. Springer, 2004.
Francois Fages. Associative-Commutative Unification. J. of Sym. Computation, 3:257–275, 1987.
D. Kapur and P. Narendran. NP-Completeness of the Set Unification and Matching Problems. In 8th International Conference on Automated Deduction (CADE), volume 230 of LNCS, pages 489–495. Springer, 1986.
D. Kapur and P. Narendran. Matching, Unification and Complexity. SIGSAM Bulletin, 21(4):6–9, 1987.
D. Kapur and P. Narendran. Complexity of Unification Problems with Associative-Commutative Operators. J. of Autom. Reasoning, 9(2):261–288, 1992.
J. Levy and M. Villaret. An Eﬃcient Nominal Unification Algorithm. In Proc. of the 21st Int. Conf. on Rewriting Techniques and Applications (RTA), volume 6 of LIPIcs, pages 209–226, 2010.
A. M. Pitts. Nominal Sets. Number 57 in Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, 2013.
M. Schmidt-Schauß, T. Kutsia, J. Levy, and M. Villaret. Nominal Unification of Higher Order Expressions with Recursive Let. In Post-proc. of the 26th Int. Sym. on Logic-Based Program Synthesis and Transformation (LOPSTR 2016), volume 10184 of LNCS, pages 328–344. Springer, 2017.
J. H. Siekmann. Matching under commutativity. In Proc. of the Int. Symposium on Symbolic and Algebraic Manipulation (EUROSAM), volume 72 of LNCS, pages 531–545. Springer, 1979.
J. H. Siekmann. Unification Theory. J. of Sym. Computation, 7(3-4):207–274, 1989.
C. Urban. Nominal Unification Revisited. In Proc. of the 24th Int. Work. on Unification (UNIF), volume 42 of EPTCS, pages 1–11, 2010.
C. Urban, A. M. Pitts, and M. J. Gabbay. Nominal Unification. Theor. Comput. Sci., 323(1-3):473–497, 2004.
