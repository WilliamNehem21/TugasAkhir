

Electronic Notes in Theoretical Computer Science 262 (2010) 99–111
www.elsevier.com/locate/entcs

A Solver for Modal Fixpoint Logics
Oliver Friedmann Martin Lange
Dept. of Computer Science University of Munich Munich, Germany

Abstract
We present MLSolver, a tool for solving the satisfiability and validity problems for modal fixpoint logics. The underlying technique is based on characterisations of satisfiability through infinite (cyclic) tableaux in which branches have an inner thread structure mirroring the regeneration of least and greatest fixpoint constructs in the infinite. Well-foundedness for unfoldings of least fixpoints is checked using deterministic parity automata. This reduces the satisfiability and validity problems to the problem of solving a parity game. MLSolver then uses a parity game solver in order to decide satisfiability and derives example models from the winni∗ng strategies in the parity game. Currently supported logics are the modal and linear-time
μ-calculi, CTL , and PDL (and therefore also CTL and LTL). MLSolver is designed to allow easy extensions
in the form of further modal fixpoint logics.
Keywords: tool support, modal logic, satisfiability checking

Introduction
Modal logics are important and very successful tools in various areas in computer science, philosophy, mathematics etc. They are being used – in various shapes and forms – in order to specify correct program behaviour (temporal logics, dynamic log- ics), to model and to reason about knowledge (epistemic logics, description logics), etc.
Any modal logic inherently faces the issue of expressiveness vs. complexity. On the one hand, logics are desirably very expressive, on the other hand, they should come with efficient decision procedures. But naturally, high expressive power entails high complexity. Standard modal logic is particularly weak because of the locality aspect of the diamond and box operators. Very simple properties like reachability – which are vital for some applications like program specification for instance – cannot be expressed in standard modal logic and, thus, require stronger operators. A generic mechanism that has proved to be successful in extending the expressive power of modal logics is that of incorporating operators which can be characterised as solutions to fixpoint equations over modal logic formulas. The modal μ-calculus Lμ [15] does this in the most explicit form by adding fixpoint quantifiers. Similar

1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.04.008

constructs – possibly in restricted form – are also present in other logics, for example as the Kleene-star in propositional dynamic logic PDL [9], as the Until operator in temporal logics LTL, CTL, or CTL∗ [21,7,8], as transitive-closure operators in query languages [27] or in description logics [2], etc.
Despite the similarities between various modal logics, tools for their satisfiability problems usually target a specific logic only. This makes sense because it is easier and more promising to optimise algorithms for specific rather than general prob- lems. Furthermore, different communities seem to prefer different methodologies, for instance the automata-theoretic inclined temporal logic community [29] vs. the tableaux inclined description logic community [3]. On the other hand, similarities are not exploited and optimisations found for one logic may not be transferred to other logics where they may be applicable as well.
One difficulty that is common to satisfiability problems for all modal logics with fixpoint constructs is the regeneration or unfolding problem for least fixpoints. One must ensure that such an unwinding does not continue ad infinitum. There are various ways to do so which all boil down to excluding certain cycles in certain graphs. One way is based on the observation that paths in a tableau with an infinitely unfolded least fixpoint construct are Bu¨chi-recognisable, and therefore also recognisable by a deterministic parity automaton. A product between the tableau and the automaton then yields a parity game, and the problem of deciding satisfiability or even to produce a model is reduced to the problem of solving parity games. Incidentally, the same problem occurs in model checking CTL∗ [17,4]. Note that for logics like CTL, PDL, or the modal μ-calculus, satisfaction of a formula in a state of a transition system can be reduced to satisfaction of subformulas in states [26]. For CTL∗ this is not the case because of the mixture between state and path formulas. A CTL∗ model checker usually has to consider satisfaction of a set of formulas in a state. This introduces the same difficulties that arise with least fixpoint constructs in satisfiability checking procedures.
In this paper we describe a new tool called MLSolver. It provides a framework for satisfiability and validity checking for various 1 modal fixpoint logics. It can also be used as a model checker for these logics. However, it is not meant to be able to compete with state-of-the-art specialised model checkers for logics like CTL, LTL, etc.

The Underlying Theory
The Framework
Satisfiability of various modal fixpoint logics can be characterised through the ex- istence of possibly infinite tableaux in which nodes are data structures containing formulas. Typically, these simply are sets of subformulas of the input formula. The tableaux then come with a notion of a good infinite branch, which is one that does not contain any least fixpoint construct regenerating itself along that branch. A

1 It currently contains decision procedures for CTL∗, PDL, the modal μ-calculus and the linear-time μ- calculus.



14	0



μX.q ∧ νY.X ∨ ⟨a⟩Y
8	8	6


14	3


0


8	14	3


6

Fig. 1. A method for solving satisfiability for modal fixpoint logics.
tableau is then a tree-like structure in which every path starting in a designated initial node is good.
In order to distinguish good and bad branches and in particular detect bad ones we employ automata theory. Bad branches can be accepted by (a combination of) nondeterministic finite ω-automata which essentially guess the occurrence of a least fixpoint construct in some tableau node and trace its infinite regeneration. Au- tomata theory provides algorithms for the determinisation and complementation of such automata into automata with a parity condition. The question of the existence of a tableau is then reduced to the problem of determining for a given node in a parity game which of the two players has a winning strategy for the game start- ing in that node. The nodes of the parity game are nodes which may occur in a tableau annotated with states of a deterministic parity automaton. Fig. 1 depicts this method in a diagram: starting from a modal fixpoint formula, one creates a nondeterministic automaton and a (finite representation of an) infinite tableau with internal structure on the branches. The automaton is determinised and the product of the resulting automaton with the tableau yields a parity game.
The vast majority of modal fixpoint logics can be handled in this way. This has been shown explicitly for variants of the modal μ-calculus including the graded and the probabilistic μ-calculus [5] or for the linear-time μ-calculus [6]. It is also implictly present in other work, again for example for Lμ [19] or for LTL, CTL [16], PDL and therefore also for the description logic ALCreg . A technically more involved but still similar construction yields a satisfiability checker for CTL∗ [11].

μ-Threads
A rule-based tableau system comes with a connection relation which relates a for- mula in a tableau node to formulas in a predecessing node. This gives rise to an internal structure of threads in an infinite branch which is an infinite sequence of connected formulas. Since fixpoint constructs are typically handled through unfold- ing rules which replace such a construct with a defining fixpoint expression (which can contain the construct again), an infinite unfolding leads to a thread on a branch.

These threads can now be characterised as μ- or ν-threads depending on the outer- most / topmost / dominating type of fixpoint construct that is unfolded infinitely often on this thread.
Next, one considers rule applications of this tableau system as an alphabet for a nondeterministic automaton Athread which accepts all infinite sequences of rule applications (i.e. encoded tableau branches) which contain a μ-thread.

Determinisation and Complementation of ω-Automata
Remember that all paths of a tableau do not contain μ-threads. Complementation of ω-automata is obviously needed in such a decision procedure because the non- deterministic automata mentioned above accept bad branches. Furthermore, for many genuinely modal logics these automata also need to be deterministic. This is the case iff the tableau system contains rules with more than one premiss. Then the tableau can have two bad branches which share a common prefix such that the two μ-threads on these bad branches split before the two branches split. Thus, a nondeterminisitic automaton may have accepting runs on these branches that differ on the common prefix, and a labelling of the tableau nodes with single automaton states would not be possible.
Note that determinisation and complementation commute, but in general it is easier to complement a deterministic automaton. Thus, Athread will be determinised first. We make use of two constructions depending on its acceptance type.
If Athread is a nondeterministic Bu¨chi automaton then we use Piterman’s re- finement of the Safra construction [20] in order to obtain a deterministic parity automaton from it.
In cases of logics structurally simpler than the modal μ-calculus, in partic- ular those without nested fixpoint constructs like LTL, CTL, PDL, etc. bad branches are recognisable by nondeterministic co-Bu¨chi automata. Their ex- pressive power is strictly below that of full ω-regularity, but – as opposed to Bu¨chi automata – they enjoy determinisability, for instance via the Miyano- Hayashi construction [18]. It is only marginally more complex than the pow- erset construction for automata on finite words and way less complex than the Piterman construction for instance. Furthermore, deterministic co-Bu¨chi au- tomata can easily be complemented into deterministic Bu¨chi automata which means that in this case satisfiability reduces to the solving of Bu¨chi games, a strict subclass of parity games.

Solving Parity Games
A parity game is a finite graph whose node set is partitioned into nodes owned by player 0 and nodes owned by player 1. Additionally, each node carries a non- negative natural number, its priority. A play is an infinite sequence of adjacent nodes. It is won by player 0 iff the highest priority seen infinitely often in this sequence is even. Otherwise, player 1 wins this play.

The problem of solving a parity game is to compute for each node v, the player who has a strategy that allows him to win every play starting in v that complies with this strategy. It is well-known that this problem is well-defined, i.e. that for each such node exactly one of the players wins this node [31].
The are various algorithms for solving parity games. The most successful ones are the recursive proof of determinacy [31], the small progress measures algorithm [13], and strategy improvement [30,23]. Even though each of those (or the others) requires exponential time in the worst-case, parity games can be solved efficiently in practice [10].
One way of reducing the complexity of the resulting parity games avoids the mapping of every tableau node, annotated with a state of the deterministic au- tomaton, to a node in the game graph. Instead, only those tableau nodes to which the usual modal rule is applied, are mapped. This rule, in CTL for example written as
ϕ1, ψ1,... , ψm	ϕ2, ψ1,... , ψm	...	ϕn, ψ1,... , ψm
EXϕ1,... , EXϕn, AXψ1,... , AXψm, l1,... , lk
is applied whenever all boolean constraints about the current state have been re- solved and the sequent consists of literals and diamond- and box-formulas only. This directly corresponds to a state in a possible model which is labeled with the present propositions and has successors given by the diamond-formulas.
Typically, this rule is the only one that creates universal branching in a tableau. Existential branching between two applications of the modal rule can be collapsed to a single choice by the existential parity game player. This leads to significantly smaller parity games, and can also speed up the construction of those because less effort is needed for the detection of cycles. However, one has to accummulate the priorities of the automaton states that occur on a path between two applications of the modal rule. Also, this optimisation is not easily possible if formulas are un- guarded meaning that the tableau rules do not guarantee that every set of formulas will eventually be transformed into one to which only the modal rule applies. This is possible for PDL with nested Kleene-stars and arbitrary formulas of the modal μ-calculus.

System Description
MLSolver provides a platform for satisfiability and validity checkers for various modal fixpoint logics. In order to allow for domain-specific optimisations and to reuse code for common functionalities, it is built in a modular way, separating the construction of tableaux for example from the automata-theoretic procedures like determinisation. It is publically available under a user-friendly license. 2
MLSolver is written in OCaml for the purposes of execution speed and source code readability. It is able to test input formulas of the supported logics for satisfia- bility or validity, or to check their satisfaction in a transition system given explicitly

2 http://www.tcs.ifi.lmu.de/mlsolver

as a labeled directed graph. This is done as described above: a parity game is gener- ated from the formula as the product of a tableau with a deterministic automaton. The parity game is then solved using PGSolver, a highly efficient and configurable solver for parity games [10]. PGSolver can be linked into MLSolver which al- lows for direct access to the solving routines in there and avoids costly printing and parsing of large parity games.
MLSolver currently supports the following logics: the modal μ-calculus, the linear-time μ-calculus, PDL, and CTL∗. Note that CTL is a simple fragment of CTL∗ and so is LTL which is also a fragment of the linear-time μ-calculus. Thus, MLSolver is also capable of determining satisfiability and validity of LTL and CTL formulas. However, μ-threads in these two logics are co-Bu¨chi-recognisable whereas Bu¨chi automata are required for their superlogics. The decision procedures for LTL and CTL obtained in this way are therefore not optimal.
Extending MLSolver with another modal fixpoint logic is relatively easy. One has to provide an abstract data type modelling formulas of that logic and to im- plement the tableaux rules for that logic as well as the nondeterministic automata recognising bad branches of these tableaux. The remaining tasks, i.e. the automata determinisation and construction of parity games, as well as the decoding of the win- ning strategy into a model / countermodel for the input formula can use available routines.

Benchmarks
In this section we describe hand-crafted benchmarks formalised in some of the cur- rently supported logics and report on performance tests on these benchmarks. Note that the series presented in the tables to follow do not start with the smallest instances. We only present instances with non-negligible running times. On the other hand, the solving of larger instances not presented in the tables anymore has experienced time-outs after one hour, marked †.
All tests have been carried out on a 64-bit machine with four quad-core OpteronTM CPUs and 128GB RAM space. The implementation does not (yet) support parallel computations, hence, each test is run on one processor only. The algorithm used to solve the resulting parity games is Zielonka’s recursive one [31]. It has proved to be generally the best among those implemented in PGSolver [10].


Hard Formulas with Fixpoint Alternation
It is well-known that alternation between least and greatest fixpoint quantifiers causes formulas to be difficult to solve. We therefore use for benchmarking a family of formulas – in the linear-time μ-calculus – that features increasing alternation of
fixpoint quantifiers. It is built as follows.

For every n ≥ 1, ψn := νX. ◯ X ∧  n
qi ∧ 

j/=i
¬qj expresses that in every


Fig. 2. Runtime results on hard formulas with fixpoint alternation.
state of a model exactly one of the propositions q1,... , qn is true. Let


ϕn  := ψn  →
(σXn ... νX2.μX1.
 
i=1
qi → ◯Xi) ↔

  (νX.(μY.qi ∨ ◯Y ) ∧ ◯X) ∧   μX.(νY.¬qj ∧ ◯Y ) ∨ ◯X 

i even
j>i j odd

where σ = ν if n is even, otherwise σ = μ. Note that ϕn has alternation depth n− 1. It expresses that a deterministic parity condition is expressible as a nondeterministic Bu¨chi condition. The left part of the bi-implication states that the greatest index i s.t. infinitely many states are labeled qi, is even. The right part states that there is an even index i with qi occurring infinitely often and no qj doing so if j is odd and greater than i. Intuitively, these two are equivalent. For technical reasons it is necessary to demand uniqueness of propositions at each state.
The times needed to generate and solve the games resulting from determining validity of ϕn as well as their sizes are presented in Fig. 2. The columns in the left part show the index n of the instance, the size of ϕn, as well as the sizes of the thread-finding automaton before and after determinisation. Note that |ϕn| grows quadratically in n and validity checking for the linear-time μ-calculus is PSPACE- complete [24,28].
The middle and right parts contain the size of the resulting game as well as the time it takes to generate and solve it. This is done in two different ways: “without compaction” maps every tableau node annotated with a state of the deterministic automaton to a node in the parity game, “with compaction” does so only for those nodes that precede an application of the modal rule as explained in Sect. 2.4 above. As one can see, this reduces the size of the resulting parity game and makes them easier to solve, but generating the games becomes harder.

Nesting Stars in PDL
It is a well-known fact that the nesting-depth of Kleene stars in the programs of a PDL-formula causes formulas to be difficult to solve. Particularly, the decision procedure has to make sure that certain formulas are not unfolded infinitely often without also seeing infinitely many applications of the modal rule.
We therefore consider two simple families of formulas that feature programs with deep nestings of Kleene stars. Let α0 := tt?∗ and αn+1 := (a∗αnb∗)∗ and
ϕn := ⟨(a ∪ b)∗⟩q ∨ [αn]¬q	ψn  := ⟨αn⟩q ∨ [(a ∪ b)∗]¬q


Fig. 3. Runtime results on nested Kleene stars in PDL.
for n ≥ 0. Note that αn ≡ (a ∪ b)∗ for all n ≥ 1 but not for n = 0. Hence, ϕn and ψn are valid for n ≥ 1. However, in ϕn the nested Kleene stars occur inside a box formula which is a greatest fixpoint construct. In ψn they occur inside a diamond formula which makes it a least fixpoint construct. Since we are looking at validity, the involved deterministic automata need to trace ν-threads, and ϕn has a much richer ν-thread structure than ψn.
The times needed to generate and solve the resulting games as well as their sizes are presented in Fig. 3. A few aspects are worth noting. First of all, the sizes of the determinised thread-finding automata equal those of the original nondeterministic ones because of the structure of the formula: the latter are deterministic already. This shows that determinisation need not always be a problem in this approach. Also, note that one may expect ϕn to be harder to prove valid than ψn because of the richer thread structure. However, the simpler program inside the box operator leads to less branching in the tableaux which explains the better managability of those formulas. This, however, is not an artefact of the automata-theory involved but of the underlying tableaux. Hence, this benchmarking family shows that the supposedly difficult automata-theoretic determinisation may actually be much less of a problem in comparison to using a tableau structure in general for satisfiability
/ validity.

An Example from the Model Checking Domain
We benchmark a simple fairness verification problem using the CTL∗ model
checker in MLSolver. States of a transition system modelling an elevator for
n floors are of type {1,... , n} × {o, c} × ( {Perm(S) | S ⊆ {1,... , n}). The first component describes the current position of the elevator as one of the floors. The second component indicates whether the door is open or closed. The third component – a permutation of a subset of all available floors – holds the requests,
i.e. those floors that should be served next. The transitions on these are as follows.
At any moment, any request or none can be issued. For simplicity reasons, we assume that at most one floor is added to the requests per transition. Note that nondeterministically, no request can be issued, and a request for a certain floor


Fig. 4. Runtime results on the example from the model checking domain.
that is already contained in the current requests does not change them.
If the door is open then it is closed in the next step, the current floor does not change.
If it is closed, the elevator moves one floor (up or down) into the direction of the first request. If the floor reached that way is among the requested ones, the door is opened and that floor is removed from the current requests. Otherwise, the door remains closed.
Proposition isPressed holds in any state s.t. the request list contains the number n, and isAt holds in a state where the current floor is n. We consider two different implementations of this elevator model: the first one stores requests in FIFO style, the second in LIFO style.
Both implementations are checked against the CTL∗ formula A(GFisPressed → GFisAt ). Hence, this formula requires all runs of the elevator to satisfy the following fairness property: if the top floor is requested infinitely often then it is being served infinitely often. Note that the FIFO implementation encodes a positive instance of the model checking problem whereas LIFO encodes a negative one.
The times needed to solve them as well as their sizes are presented in Fig. 4. It shows that this method is capable of doing model checking for non-trivial proper- ties and large transition systems, here more than half a million states. The table does not show the sizes of the involved automata because they are independent of n since the formula expressing the desired correctness property is fixed, and the thread-finding automata only depend on the formula in CTL∗ model checking. The nondeterministic one has 8 states, the determinised one 27. We also remark that a similar benchmark is presented in [10] using PGSolver directly in order to verify these systems. The difference however, is that there the fairness property is for- malised in the modal μ-calculus, and the model checking problem then translates directly into a parity game. Here we formalise it using CTL∗, and we need to go through the thread automata etc. in order to obtain a parity game.

Difficult Temporal Formulas
It is well-known that limit closure – the fact that the limit of an infinite sequence of prefix-sharing paths in a transition system is again a path in this system – is one of the major problems in devising a decision procedure for CTL∗ [22]. It is therefore


Fig. 5. Runtime results on difficult temporal formulas.
reasonable to assume that these formulas are relatively difficult to prove valid. This principle is expressible in CTL∗ as LC ∗(φ, ψ) := AG(Eψ → EX((Eϕ)UEψ)) ∧ Eψ → EG((Eϕ)UEψ) where ϕ and ψ are arbitrary (not necessarily state) formulas. CTL can express a restricted version of that: LC (ψ) := AG(ψ → EXψ) ∧ ψ → EGψ. For the benchmarking, we consider the following families of formulas.


0 := LC ∗(ϕn, ψn)	δ1
:= LC ∗(tt, ψn)	δ2
:= LC (ψn)

where ϕn := G( i≤n ¬qi), ψ0 := q0, ψ2n+1 := q2n+1 ∧ Xψ2n, and ψ2n+2 := q2n+2 ∨
Xψ2n+1.
The times needed to generate and solve the resulting games as well as their sizes are presented in Fig. 5.

Conclusion and Further Work


The implementation of
MLSolver and some of the benchmarks show that the

combined tableaux-automata way of satisfiability and validity solving for modal fixpoint logics is viable. Even difficult logics like CTL∗ and the modal μ-calculus can be tackled this way. However, the benchmarks also show a significant discrepancy between the time that is required to generate the parity games and the time that is required to solve them. There is no question that solving the games is not really the problem, but building the tableaux as well as the associated automata. The benchmarks particularly show that there are basically two difficulties in satisfiability and validity solving for such logics.
The first and most obvious difficulty is that of excluding branches with μ-threads. The automata-theoretic approach we follow here is theoretically elegant and appeal- ing because it applies to a whole variety of logics, as opposed to ad-hoc solutions for one specific logic. The benchmarks reveal a great necessity for optimisations in the determinisation procedures, though. These are theoretically well-understood but practically not optimal yet. The reductions employed here would, for example, benefit from a built-in on-the-fly minimisation of the deterministic automata. It is

not clear though, whether this is possible and how to do that.
Another difficulty which is not exhibited by the benchmarks presented here is propositional reasoning. It is easy to construct formulas that model binary counters for example for which the construction of parity games essentially transforms them into exponentially larger disjunctive or conjunctive normal form. Deciding these formulas is then difficult purely because of the size of the games.
MLSolver’s main advantage is probably the provision of a common platform for satisfiability and validity problems for various and different modal fixpoint logics. Because of its genericity it is difficult to compare it to similar tools (for one of the logics). We are not aware of any implementations of solvers for the modal μ-calculus or even CTL∗, and there only seems to be one reasonable tool 3 for deciding PDL satisfiability based on tableaux [1]. A comparison between the two shows no definite winner, since there are cases in which MLSolver outperforms the tableau solver and vice versa. A thorough analysis of both their strengths and weaknesses will be required in order to engineer a good solver for PDL at least, and it remains to be seen whether findings could be transferred to other logics as well.
It is planned to extend and optimise MLSolver in the future in various ways. As mentioned above, LTL and CTL are currently being supported but only in a non-optimal way. Implementing separate modules for LTL and CTL is not difficult. This will also create a set-up which will allow to measure the exact benefit of using co-Bu¨chi over Bu¨chi automata. There are also other logics (graded μ-calculus, probabilistic μ-calculus, etc.) for which this approach works in theory [5], and they can be implemented in MLSolver as well.
A significant disadvantage is also the creation of the entire parity game before it is being solved. This is in contrast to tableau-based solvers for example, and is done because so far there is only one algorithm for solving parity games which works on-the-fly, i.e. generates the game graph whilst solving it [25]. However, it turns out that in practice [10] it is often much less efficient than global algorithms [31,30]. On the other hand, it remains to be seen whether or not the local algorithm may perform better on graphs that represent satisfiability and validity problems, or whether or not the good global algorithms can be made to work on-the-fly.
Finally, there is another determinisation procedure for nondeterministic Bu¨chi automata which is not based on tree-like states [14]. It remains to be seen whether this leads to more efficient determinisation and therefore quicker generation of par- ity games. Another way of avoiding such Safra-like determinisation constructions transforms the μ-thread recognising nondeterministic automata into, again, nonde- terministic Bu¨chi automata which are exponentially larger but can be used in this game setting instead of deterministic ones [12]. They are presumed to be easier to create than the deterministic ones which can be put to the test in this setting as well.



3 publicly available via http://users.rsise.anu.edu.au/~rpg/PDLProvers

References
Abate, P., R. Gor´e and F. Widmann, An on-the-fly tableau-based decision procedure for pdl-satisfiability, Electron. Notes Theor. Comput. Sci. 231 (2009), pp. 191–209.
Baader, F., Augmenting concept languages by transitive closure of roles: An alternative to terminological cycles, in: Proc. 12th Int. Joint Conf. on Artificial Intelligence, IJCAI’91 (1991), pp. 446–451.
Baader, F. and U. Sattler, An overview of tableau algorithms for description logics, Studia Logica 69
(2001), pp. 5–40.
Bhat, G., R. Cleaveland and O. Grumberg, Efficient on-the-fly model checking for CTL∗, in: Proc. 10th Symp. on Logic in Computer Science, LICS’95, IEEE, San Diego, CA, USA, 1995, pp. 388–397.
Cirstea, C., C. Kupke and D. Pattinson, EXPTIME tableaux for coalgebraic mu-calculi, in: Proc. 18th Int. EACSL Annual Conference on Computer Science Logic, CSL’09, LNCS 5771, 2009, pp. 179–193.
Dax, C., M. Hofmann and M. Lange, A proof system for the linear time μ-calculus, in: Proc. 26th Conf. on Foundations of Software Technology and Theoretical Computer Science, FSTTCS’06, LNCS 4337 (2006), pp. 274–285.
Emerson, E. A. and J. Y. Halpern, Decision procedures and expressiveness in the temporal logic of branching time, Journal of Computer and System Sciences 30 (1985), pp. 1–24.
Emerson, E. A. and J. Y. Halpern, “Sometimes” and “not never” revisited: On branching versus linear time temporal logic, Journal of the ACM 33 (1986), pp. 151–178.
Fischer, M. J. and R. E. Ladner, Propositional dynamic logic of regular programs, Journal of Computer and System Sciences 18 (1979), pp. 194–211.
Friedmann, O. and M. Lange, Solving parity games in practice, in: Proc. 7th Int. Symp. on Automated Technology for Verification and Analysis, ATVA’09, LNCS 5799, 2009, pp. 182–196, to appear.
Friedmann, O., M. Lange and M. Latte, An effective calculus of infinite proofs for the full computation tree logic (2009), submitted.
Henzinger, T. A. and N. Piterman, Solving games without determinization, in: Proc. 20th Int. Conf. on Computer Science Logic, CSL’06, LNCS 4207 (2006), pp. 395–410.
Jurdzin´ski, M., Small progress measures for solving parity games, in: Proc. 17th Ann. Symp. on Theoretical Aspects of Computer Science, STACS’00, LNCS 1770 (2000), pp. 290–301.
K¨ahler, D. and T. Wilke, Complementation, disambiguation, and determinization of Bu¨chi automata unified, in: Proc. 35th Int. Coll. on Automata, Languages and Programming, ICALP’08, LNCS 5125 (2008), pp. 724–735.
Kozen, D., Results on the propositional μ-calculus, TCS 27 (1983), pp. 333–354.
Lange, M. and C. Stirling, Focus games for satisfiability and completeness of temporal logic, in: Proc. 16th Symp. on Logic in Computer Science, LICS’01 (2001).
Lange, M. and C. Stirling, Model checking games for branching time logics, Journal of Logic and Computation 12 (2002), pp. 623–639.
Miyano, S. and T. Hayashi, Alternating finite automata on omega-words, TCS 32 (1984), pp. 321–330.
Niwin´ski, D. and I. Walukiewicz, Games for the μ-calulus, TCS 163 (1997), pp. 99–116.
Piterman, N., From nondeterministic Bu¨chi and Streett automata to deterministic parity automata, in: Proc. 21st Symp. on Logic in Computer Science, LICS’06 (2006), pp. 255–264.
Pnueli, A., The temporal logic of programs, in: Proc. 18th Symp. on Foundations of Computer Science, FOCS’77 (1977), pp. 46–57.
Reynolds, M., A tableau for bundled CTL∗, J. Log. Comput 17 (2007), pp. 117–132.
Schewe, S., An optimal strategy improvement algorithm for solving parity and payoff games, in: Proc. 17th Ann. Conf. on Computer Science Logic, CSL’08, LNCS 5213 (2008), pp. 369–384.
Sistla, A. P. and E. M. Clarke, The complexity of propositional linear temporal logics, Journal of the Association for Computing Machinery 32 (1985), pp. 733–749.


Stevens, P. and C. Stirling, Practical model-checking using games, in: B. Steffen, editor, Proc. 4th Int. Conf. on Tools and Algorithms for the Construction and Analysis of Systems, TACAS’98, LNCS 1384 (1998), pp. 85–101.
Stirling, C., Local model checking games, in: Proc. 6th Conf. on Concurrency Theory, CONCUR’95, LNCS 962 (1995), pp. 1–11.
ten Cate, B., The expressivity of XPath with transitive closure, in: Proc. 25th ACM SIGMOD-SIGACT- SIGART Symp. on Principles of Database Systems, PODS’06 (2006), pp. 328–337.
Vardi, M. Y., A temporal fixpoint calculus, in: ACM, editor, Proc. Conf. on Principles of Programming Languages, POPL’88 (1988), pp. 250–259.
Vardi, M. Y., “An Automata-Theoretic Approach to Linear Temporal Logic,” LNCS 1043, Springer, 1996 pp. 238–266.
V¨oge, J. and M. Jurdzin´ski, A discrete strategy improvement algorithm for solving parity games, in:
Proc. 12th Int. Conf. on Computer Aided Verification, CAV’00, LNCS 1855 (2000), pp. 202–215.
Zielonka, W., Infinite games on finitely coloured graphs with applications to automata on infinite trees, TCS 200 (1998), pp. 135–183.
