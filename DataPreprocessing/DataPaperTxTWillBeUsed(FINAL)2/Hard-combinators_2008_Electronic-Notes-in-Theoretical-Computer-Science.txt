Electronic Notes in Theoretical Computer Science 203 (2008) 31–48	
www.elsevier.com/locate/entcs

Hard combinators
Denis Béchet 1 ,2
LINA
Université de Nantes Nantes, France

Sylvain Lippi3
I3S
Université de Nice Sophia Antipolis, France

Abstract
Hard Interaction systems can be presented as graph relabeling with a handshake mechanism that provide local synchronization. We present a particular one with only four symbols and seven rules that can be used to simulate all the other hard interaction systems.
Keywords: Interaction nets, asynchronous circuits, universal machines, graph rewriting


Introduction
Interaction nets introduced by Yves Lafont [3] can be considered as a generalization of linear logic multiplicative proof nets. Syntactically they are presented as graph rewriting systems where rules are applied on pairs of nodes (called cells) connected by an “active edge” called cut by logicians. Lafont presented in [4] a system of three symbols and six rules called interaction combinators that is universal : any interaction system can be translated (in a sense that we shall detail below) into the system of the combinators. Interaction nets have been successfully used to implement various reduction strategies for the λ-calculus ([8] and [5]) and several interpreters (in particular a parallel one by [10] and a graphical one by [6]) for interaction nets have been proposed. More recently, non-deterministic extensions have been studied [9].

1 Thanks to the referees and to Yves Lafont for their useful advises.
2 Email: denis.bechet@univ-nantes.fr
3 Email: lippi@i3s.unice.fr

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.032

In this paper, we shall focus on a restriction called hard interaction nets where the geometry of the net is invariant during reduction and propose a universal system (called hard combinators) for such systems. The translation of an arbitrary hard interaction system into hard combinators has a quite different character from the corresponding translation for interaction nets where the key technical point is im- plementing the duplication of some nets. 4 Here we shall represent nodes as binary words and calculate the transformations with boolean functions. The name hard interaction nets is well-chosen, since they are a form of abstract hardware. In this perspective, it is interesting to sum up the important rules and give the basic com- ponents that can be used to construct asynchronous circuits. Indeed, it is possible to implement multiplexors, registers, memories and ALUs with hard combinators
[7] so it should be possible to build an asynchronous computer simply by following classical Von Neumann computer architecture and using hard combinators [1].
Notation. The domain of some variables is implicitly given by their names with
words and σ, ρ and τ are signatures (+ or −). Concatenation of p and q is noted pq the following conventions: x, y, z, x0, x1, x2, ... are binary digits, p, q, r, s, t are binary x × y. xn denotes the word x...x with n letters. |p| is the length of p. The set of so xy is a word with two digits and the scalar product of x and y is explicitly noted
boolean values {0, 1} is noted B and the set of natural numbers N.
Hard interaction nets
We present hard interaction nets informally from scratch without any reference to linear logic or even to interaction nets. A hard interaction system (or hard system for short) is composed with a set of symbols and their corresponding arity and with a set of interaction rules.

Cells, Ports, Nets and Cuts
Occurrence of symbols are called cells and have n +1 ports where n is the corre- sponding arity. Each cell has exactly one principal port (pictured with a blob) and n auxiliary ones:
1	n


0
Nets are build with a set of cells and free ports where ports (principal, auxiliary and free ones) are connected pairwise. Cuts are particular nets composed of two cells connected by their principal ports.

4 more precisely principal nets for the connoisseur.

Interaction rules
The difference between the principal port and the auxiliary ones is essential since rewriting (or interaction) can be applied only on cuts. In other words, the left member of an interaction rule is composed of two cells connected by their principal ports. Interaction consists in relabeling cells and changing the orientation of the principal ports; we shall say that the cell is turning. To sum up, an interaction rule is pictured as follows,
k






` ˛l¸ x
and we say that if an α-cell interacts with a β-cell it becomes α' and turns k times counter clockwise. Similarly, β-cell becomes β' and turns l times. Note we are interested only in deterministic hard interaction systems so there is at most one interaction rule for each pair of symbols.

Reduction
Starting from an initial net containing cuts, we can apply an interaction rule ob- taining another net and so on until an irreducible net if the reduction finishes. Hard interaction systems are very simple since the computation is local (only two cells are involved in a reduction) and the geometry of the net is invariant. However one can show that it is complete from a computational point of view i.e for each Turing machine one can define a hard interaction system that simulates this machine. The reader can find a simple translation in Lafont’s paper on combinators [4] (the proof is straightforward) where the proposed system happens to be a hard interaction system where all the cells are unary. Of course, an arbitrarily extendable tape is represented with an infinite number of cells but the alphabet and the set of rules is finite. Let us finish with an essential property due to the local synchronization.

with ν /=ν', then ν and ν' reduce in one step to a common net ξ. Proposition 2.1 (strong confluence) If a net μ reduces in one step to ν and ν',
μ
ν	ν'
ξ

Proof The left member of an interaction rule is a cut and ν /=ν'. Consequently the above reductions are applied on two different instances of cuts. Two instances
of cuts are necessarily disjoint (a cell is in one cut at most) so the corresponding interaction rules can be applied independently.	 


Consequently reduction is deterministic in a strong way: any reduction strategy gives the same result with the same number of steps.

Corollary 2.2 (reduction) If a net μ reduces to an irreducible net ν in n steps, then any reduction starting from μ eventually reaches ν in n steps.



Example
Let us present a simple hard interaction system that implements a “real function”. Given an input stream of bits x1, x2, x3, ..., xn the following net computes an error detection value ab with two bits that gives a criterium that is comparable to sim- ple parity computation. This kind of calculus is used, for instance, to compute a checksum of Ethernet frames. In this case, the checksum has 32 bits.











input


Cells represented by circles can have three different values: 0, 1 or void. The other cells correspond to the duplication operator δx (two symbols), the exclusive or operator + (two symbols) and finally the shift register Sx and Sxy (six symbols). The values ai and bi are recursively defined by ai+1 = ai + bi + xi and bi+1 = ai. Let us give the corresponding rules of this system:

z = x + y
The correctness of the implementation comes from the following three reductions that detail the execution of the three operators:
∗	∗	∗
Remark 2.3 This system can be encoded in a system with only two symbols and three rules that happens to be the binary hard combinators presented in the next section.


A universal system: hard combinators
We present a particular hard system called hard combinators with four symbols and seven rules that is sufficient to simulate all other hard systems. More precisely, we can translate each cell α by a net [α] built with hard combinators such that,
⇒
Cells

two      unary      ones,      +      and      −. Our system is composed of four different symbols: two binary ones, 0 and 1, and


	

Rules
There are seven rules that can be split into two groups: three rules between binary cells and four rules between unary and binary cells. There is no rules between unary cells. Binary rules are also called uniform rules because the principal port “turns in the same direction” (counter clockwise) for each interaction. The three uniform rules can be summed up by the following schema where + denotes sum modulo 2.

Consequently, the four other rules are called non-uniform rules because the ori- entation of a binary cell depends on the unary cell interacting with it. Intuitively,
(+)-cells let binary cells turn counter clockwise and (−)-cells force them to turn clockwise.



Definition 3.1 [clocks] for any bit x,	=

Clocks are introduced for graphical convenience to avoid complicated crossing of
a
wires. They are noted x because they interact as binary cells except their principal
port turns clockwise. For example, we have the following reductions.


Uniform components
In this section, we consider the subsystem composed only with the two binary cells and the corresponding three uniform rules. Surprisingly, non trivial functions can be built in this restriction and, indeed it is a decisive step in the construction of a universal translation.
Definition 4.1 [binary pipes] for any bit x,	=
∗
Lemma 4.2 for any bits x and y,
Proof We apply uniform rules and the equality x + x + y = y mod 2.



=	=






Definition 4.3 [pipes] for any word p = x1... xn,
n

Notation. We also picture an unknown pipe
 



for pipes corresponding to any

word of size n or simply  if there is no ambiguity. Those blank representations
come from the idea that if one does not know what is stored in a pipe then, the place is free ! 
∗
Lemma 4.4 for any words p and q,
Proof by induction on p and q.	 

Definition 4.5 [zero]	=
∗
Lemma 4.6 for any bit x,

Proof The above reduction can be easily checked with the binary rules.	 

Definition 4.7 [seesaws] for any bit x,	=

As clocks, seesaws are introduced to simplify the definitions of the other nets and do not have any functional property. Seesaws interact as binary cells: they change their principal port and their symbol is summed with the interacting cell.
Remark 4.8 Do not confuse between pipes (binary words in a square box), seesaws (bits in a round box) and unary cells (signatures in a round box).



Definition 4.9 [diodes]     =




Remark 4.10 Unlike pipes or zero, diodes correspond to a set of nets not to a unique one. Indeed, bits x and y in the above definition can have any binary values so there are four diﬀerent representation of a diode. We shall use this kind of definition for other components.
∗
Lemma 4.11 For any bits x and y,


Proof The above reduction can be easily checked with the uniform rules. 
Remark 4.12 According to remark 4.10, the above lemma should be read “starting from any representation of the diode in the left member, we obtain another (possibly diﬀerent) representation of the diode in the right member.

Invariant nets

Definition 5.1 [Invariant nets] Let us consider a net ν where free ports are par- titioned into three sets: inputs, pictured with an in-going arrow, outputs, pictured with an out-going arrow, and unused, pictured with no arrow. We say that ν is in- variant on inputs p1, ..., pk and produces outputs q1, ..., ql when we have the following reduction,

∗
where the length of the “input” pipes are respectively |p1|, ..., |pk| and the length of the “output” ones |q1|, ..., |ql|. We shall use the following notation for invariant nets,

q1	ql
Remark 5.2 We do not mention where are the principal ports of ν. Indeed, the important point is to identify the inputs and the outputs and to know how they interact with pipes.
As explained in remark 4.10, the net ν corresponds to a class of nets and the reduction above means that the right member is in the same class of nets as the left
member. For example, in definition 5.6 , x0 and y0 range over {0, 1} and σ ranges over {+, −} so there are eight different representations.
Remark 5.3 According to the previous definition, an invariant net is a pair com- posed of a net and a partition of its free ports and there may be several invariant nets corresponding to a unique net. However, we also say that a net is invariant when such a partition exists.
Remark 5.4 In the previous section we introduced unknown pipes and zero which are invariant. More precisely, p  p and	0.
Duplicator and arithmetic operations
To avoid cumbersome repetitions, we give the definition and the corresponding in- variance property of the following nets in one shot. For example, the net δ is defined by the right member of the equality and we show that it is invariant on input p and produces output p twice.
p
Definition-Lemma 5.1 (duplicator)	=
p	p

Proof We apply lemma 4.11 for the diode and the uniform rules.	 

x	y


Definition-Lemma 5.2 (plus)
=
x + y


Remark 5.5 + denotes the sum modulo 2.
Proof We apply lemma 4.11 for the diode and the uniform rules.	 
In the uniform subsystem, we have defined constants, pipes, duplication and plus. So one may wonder if it is possible to define product as well in this subsystem. The answer is probably negative. Indeed, the plus operation (binary xor) is weaker than binary addition that is computing the sum and but also the carry. Moreover, one can prove that is impossible to build a uniform system that is universal.

x	y


Definition 5.6 [sequential product]
=
x × y

The sequential product use input y first. If y is zero the result is directly returned and input x is not used.


x	y
Definition 5.7 [partial quotient]


  
=

x/y
The partial quotient can be considered as the dual of the sequential product.
Both inputs are used but it returns no result when input y is zero.
Lemma 5.8 We have the following invariants for sequential product and partial quotient,
0	x	1	x	0	x	1



0
,

x
,
and
x

Proof Trivial with uniform but also non-uniform rules.	 

Composition
The first steps, building invariant nets from scratch can be compared to bootstrap in the sense that the difficult part is only to build the very first components (constant zero, duplicator, product). It is now easy to compose invariant nets with pipes and build other more complicated nets.
However, for synchronizations reasons, it is not always possible to compose two invariant nets by plugging directly outputs of the first one with inputs of the second one. To avoid this problem, outputs of invariant nets are connected to unknown pipes. It is not difficult to verify that such “buffered” invariant nets can be freely composed. In some cases, we can suppress those “output pipes” but the proof of the invariance property is tedious. Consequently, from now on, all outputs of invariant nets are connected to pipes when they are composed with other invariant nets.
A first application is to implement binary word constants.
Definition-Lemma 5.3 (constant)


=
p
Remark 5.9 For clarity, constants are defined with non-reduced nets. We can verify that we can reduce them and by the confluence property, we can use the reduced form.
Let us give an invariant net for boolean and.
Definition-Lemma 5.4 (boolean and)
x	y
=
x ∧ y

Proof We consider two cases: y =0 and y =1 and apply composition.	 

Remark 5.10 x∧ y = x× y so the diﬀerence between sequential product and boolean and is that boolean and always uses its two inputs.
In the same way, we can define invariant nets with several inputs and outputs for vectorial boolean functions on several inputs. Eventually, those invariant nets can be used to build the corresponding functions on binary words. To that purpose, the nets spit and merge can be composed to build some kind of parallel/serial adaptators.

Definition-Lemma 5.5 (split and merge)

xy
=
x	y

x	y
=
xy




Proof  By composition.	 



The Translation
Now we are ready to translate a given hard interaction system into the system of hard combinators presented in section 3. Symbols are numbered and represented by
want to encode by a partial function ϕ : BN × BN → BN × N where ϕ(p, q)= (p', k) binary words of a fixed length N . A first idea is to represent the set of rules that we if p interacts with q, becomes p' and turns k times. Let us remark that we need the
values of ϕ(p, q) and ϕ(q, p) to compute the reduction between p and q.
In fact, we choose a slightly different representation and introduce stable cells that interact with another (stable) cell and unstable cells that interact internally reaching eventually a stable state. Each interaction is decomposed into one exter- nal interaction between two stable cells followed by several (possibly zero) internal interactions inside each unstable cell. This way we can impose that a cell turns (uni-
set of rules is represented by a partial function ψ : BN×BN → BN where ψ(p, q)= p' formly !) exactly once at each (external or internal) interaction. Consequently, the if p interacts with q, becomes p' and turns exactly once.
Let us define ψ from ϕ. For each couple of (stable) symbols p and q such that
ϕ(p, q)= (p',k + 1) 5 we introduce k new (unstable) symbols p1, ..., pk and set,



5 If the principal port remains unchanged after reduction, we say that it turns a +1 times where a is the arity of the cell.

⎧⎪ ψ(p, q)	= p1
ψ(p1, 0N )	= p2
⎨ .


⎪ ψ(p

k−1
, 0N ) = pk

⎪⎩ ψ(pk, 0N )	= p'
Since unstable cells do not interact with another one, we arbitrarily fix the value of the second argument of ψ to 0N . Here is the graphical representation of an interaction between p and q where ϕ(p, q)= (p',k + 1) and ϕ(q, p)= (q',l + 1),


+1 
1 external


k internal


l internal


		
interaction	interactions	interactions


Let us introduce two invariant nets. The first one corresponds to the function ψ that computes the new symbol after an (internal or external) interaction. The second one called discriminant ξ, says if a cell is stable or not.
Definition 6.1 [transition and discriminant]
p	q	p
	

ψ(p, q)
p	1N
0N
if p is stable otherwise

Now we can give the translation of the port of a cell into two parts: πin and πout. The important idea is that πin computes the next symbol p' without any interaction with q in the case p is not stable. In the same way πout gives the current symbol p only if p is stable.
Definition 6.2


p


p


=
p
q
=
p'



Lemma 6.3

p
and

p
and
p

p


ψ(p, 0N )
p	q


ψ(p, q)


if p is unstable



if p is stable

Invariant nets are easy to use and compose because we feel “at home” with inputs/outputs. However this notion is not mandatory for general interaction nets. Indeed, in the translation of a port, we need some kind of “full/duplex” connection since a cell outputs its current symbol to another cell but also inputs the symbol of the cell with whom it is interacting ! This is exactly what is done by the net γ.
Definition 6.4 [gamma]


p
i	=
q






Port p corresponds to an input, port q to an output and i to the “full/duplex” interface. Each port of a cell corresponds to a γ-cell; when two cells interact, the input of a γ-cell is reproduced on the output of the other γ-cell. This property is summed up in the following lemma.
Lemma 6.5
p
γ	q
γ
q
p

Remark 6.6 Let us remark that surprisingly γ is built only with uniform cells.
Now we can compose, πin, πout and γ and give the translation of a port π. According to the previous paragraph, port i (interface) is both an input and an output.
Definition 6.7



p
i	=
p'



Lemma 6.8 (external and internal interaction)
p


if p is stable


p


ψ(p, 0N )

if p is unstable

Proof  By composition.	 
The above lemma details two cases: two stable cells interact with one another or an unstable cell interact internally. Consequently, port i is unused or plugged to the interface of another π net.
Definition 6.9 [translation of a cell]

=
where the length of the pipes is |p| = N
By analogy with computer architectures, π corresponds to a form of Arithmetic

and Logical Unit (ALU) and pipe to a register. Then this basic architecture (a net π composed with a pipe) is repeated for the translation of each port of the cell. Another possibility is to “centralize” the transition function for the whole cell. The advantage is we do not have to introduce unstable cells but on the other side we have to implement a more complicated component for the interface part.
Finally, it is now easy to verify that our translation simulates the rules of a given hard system.
Theorem 6.10

⇒	∗
Proof Apply lemma 6.8 and definition 6.9. See appendix A for the detailed reduc- tion.	 

Conclusion
The system we propose seems to be a good candidate for a universal hard system. However this work is a first step in the domain of hard interaction nets. Indeed many questions related to fundaments as well as applications remain still open.
The first one concerns the minimality of such a system; is it possible to give a simpler universal system with fewer symbols or rules? For instance, it is not easy to know whether three symbols would be sufficient. We only know that a system composed only of uniform rules cannot be universal.
There is a correctness criterion for interaction nets imported from linear logic to prevent deadlocks. It is important to reformulate this criterion for the particular case of hard interaction nets since it is an opportunity to simplify and perhaps to refine it.
Although (general) interaction nets cannot be translated into hard interaction nets, it is interesting to see if there could be a compilation process for some subclass of interaction nets. Interaction nets would be the high level program- ming language whereas hard interaction nets would be the target (low level) lan- guage. In the same spirit, interpreters have been developed for interaction nets. Would it be possible to physically implement components for hard combinators? In other words, we can consider hard combinators as components for electronic asynchronous circuits?
As interaction nets can be compared to graph rewriting systems, hard interaction nets can be compared to graph relabeling. These techniques have been particularly successful in the study of graph election algorithms [2]. It would be interesting to

implement such algorithms with hard interaction nets and this way take benefit from the confluence property! More generally, it would be interesting to compare hard interaction nets with other existing rewriting techniques.
The fixed geometry of hard interaction nets gives them a very similar flavour to cellular automata, or a generalization of cellular automata to non-rectangular grids and there are universality results for cellular automata so it should be interesting to compare those rewriting systems.

References
Cecile Germain, Daniel Etiemble. Architecture des Ordinateurs. Cours de Licence Informatique, Université d’Orsay, 2005.
Emmanuel Godard, Yves Métivier, M. Mosbah, and A. Sellani. Termination detection of distributed algorithms by graph relabelling systems. In proceedings of the ﬁrst Conference on Graph Transformation, 2002.
Yves Lafont. Interaction nets. In proceedings of the 17th Annnual ACM Symposium on Principles of Programming Languages, Orlando (Fla., USA), pages 95–108, 1990.
Yves Lafont. Interaction combinators. Information and Computation, 137(1):69–101, 1997.
Sylvain Lippi. Encoding left reduction in the lambda-calculus with interaction nets. Mathematical Structures in Computer Science, 12(6), December 2002.
Sylvain Lippi. in2: a graphical interpreter for the interaction nets. In Proceedings of Rewriting Techniques and Applications (RTA ’02). Springer Verlag, 2002.
Sylvain Lippi. Asynchronous Components with Hard Combinators. In Preparation.
Ian Mackie. Yale: Yet another lambda evaluator based on intetaction nets. In Proceedings of the 3rd ACM SIGPLAN International Conference on Functional Programming (ICFP’98). ACM Press, 1998.
Damiano Mazza. Multiport Interaction Nets and Concurrency. In proceedings of CONCUR 05, LNCS 3653, 2005.
Jorge Sousa Pinto. Implantation parallèle avec la logique linéaire (applications des réseaux d’interaction et de la géométrie de l’interaction). PhD thesis, Ecole Polytechnique, 2001.

A  Simulation of hard interaction rules
We detail the proof of theorem 6.10. We consider the interaction between a cell p and q where p becomes p' and turns k +1 times and q becomes q' and turns l +1 times.

. . .  

p


...



. . .  

q


... 




. . .  
p1
∗
...



. . .  
q1


... 




. . .  



∗
...    pk



. . .  


...   ql




. . .  
∗
p'
...



. . .  
q'
... 
