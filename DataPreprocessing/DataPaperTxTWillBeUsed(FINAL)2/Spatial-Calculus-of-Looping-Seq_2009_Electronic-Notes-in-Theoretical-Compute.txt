

Electronic Notes in Theoretical Computer Science 229 (2009) 21–39
www.elsevier.com/locate/entcs
Spatial Calculus of Looping Sequences1
Roberto Barbuti,2	Andrea Maggiolo–Schettini,3 Paolo Milazzo4	and Giovanni Pardini5
Dipartimento di Informatica Universita` di Pisa
Largo Bruno Pontecorvo 3, 56127 Pisa, Italy


Abstract
The Calculus of Looping Sequences (CLS) enables the description of biological systems and of their evolution. This paper presents the Spatial CLS, an extension of CLS that allows the description of the position of biological elements, and of the space they take up in a 2D/3D space. The elements may move autonomously during the passage of time, and may interact when constraints on their positions are satisfied. The space occupied by each element is modeled as a hard sphere, hence space conflicts may arise during system evolution. These conflicts are resolved by an appropriate algorithm, which rearranges the position of the elements by assuming that they push each other when they are too close. Moreover, rewrite rules are endowed with a parameter describing their reaction rate.
The aim of Spatial CLS is to enable a more accurate description of those biological processes whose behaviour depends on the exact position of the elements. As example applications of the calculus, we present a model of cell proliferation, and a model of the quorum sensing process in Pseudomonas aeruginosa.
Keywords: Calculus of Looping Sequences, Spatial modeling, Systems biology


Introduction
The study of biological systems has traditionally involved the development of math- ematical models (e.g. differential equations) for the description and analysis of their behaviour. New approaches for the modeling of biological processes have been re- cently proposed, which involve the use of modeling formalisms of Computer Sci- ence such as process calculi [10,25,22,21,9,24,28] automata-based models [4,18] and rewrite systems [11,23,8,19,16]. Their use comprises the development of simulators,

1 This research has been partially supported by MiUR PRIN 2006 Project “Biologically Inspired Systems and Calculi and their Applications (BISCA)”.
2 Email: barbuti@di.unipi.it
3 Email: maggiolo@di.unipi.it
4 Email: milazzo@di.unipi.it
5 Email: pardinig@di.unipi.it

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.02.003

and the analysis of the systems and the verification of their properties by using means of Computer Science, such as probabilistic model checking [17].
Among the simulators we quote SPiM [3] and BioSPI [2], both based on (stochas- tic) π-calculus, and SCLSm [1]. MGS [14] is a dynamically typed functional lan- guage, that allows describing transformations over collections of elements. Its main purpose is to allow the simulation of biological processes, and it is proposed as a unifying framework of many different models of computation inspired by biology and chemistry.
Recently, in order to model the protein chemistry of biological cells for phe- nomena where spatial effects are important, particle-based simulators have been developed [27,20] and a spatial extension of the π-calculus has been proposed [15]. The Calculus of Looping Sequences (CLS) [8,19] allows the modelling of bio- logical systems and of their evolution. It is based on term rewriting, hence a CLS model is composed of a term, which describes the biological system, and a set of rewrite rules, modeling its evolution. Two kinds of structures are provided by the calculus: sequences, used to represent simple entities of biological systems such as proteins and DNA strands, and looping sequences that can be used to model more
complex structures such as membranes.
In this paper we present the Spatial Calculus of Looping Sequeces (Spatial CLS), which extends CLS by allowing spatial information to be associated with CLS struc- tures when this information is relevant for determining the system behaviour. Such structures are represented as hard spheres in a continuous space, which can move autonomously and can interact when conditions on their positions are satisfied. Conflicts on the space occupied by different structures may arise during evolution. Elements should not overlap and should not be positioned beyond the bounds of the membrane containing them. These conflicts are resolved by a suitable algorithm that rearranges the elements by assuming that they push each other if they overlap and that they are kept inside the membrane containing them when they exceed its bounds. Finally, rewrite rules are endowed with a parameter describing their reaction rate, that is their propensity to occur when applicable.
The aim of Spatial CLS is to enable a more accurate description of those bio- logical processes whose behaviour depends on the exact position of the elements. This high level of accuracy is especially useful for cell biology, where there can be a high degree of spatial organization and molecular species may be distributed in the space not uniformly [5]. Such descriptions can then be used to simulate the system, so as to obtain a faithful representation of their evolution. As example applications of the calculus, we present a model of cell proliferation, and a model of the quorum sensing process in Pseudomonas aeruginosa. We show the result of the simulation of the former model, obtained with an ad hoc simulator.
A formalism dealing with spatial aspects of biological systems is SpacePI [15], an extension of the π-calculus with space and time. In SpacePI positions in a continuous space (such as R2) are associated with processes, and processes can move autonomously according to a movement function. However, the space occupied by a process cannot be expressed, and membranes cannot be modeled easily.

The Calculus of Looping Sequences
We recall the variant of CLS called CLS+ [19]. In the definition of the syntax of CLS+ terms we assume an infinite alphabet E ranged over by a, b, c,.. ..
Definition 2.1 (Terms) Terms T, branes B and sequences S of CLS+ are given by the following grammar:
T ::= S			 B L ♩ T		T | T S ::= ϵ		a	S · S
The sets of all terms, branes and sequences are denoted by T , B and S, respectively.
The sequencing operator	·	can be used to build sequences of symbols in E and ϵ denotes the empty sequence, that is a concatenation of zero symbols. For constructing terms, we have a looping operator	L, a containment operator ♩ and a parallel composition operator	| . A term may contain simple sequences S and looping sequences B L ♩ T . The containment operator ♩ allows the repre- sentation of compartments; in fact, a looping sequence B L ♩ T usually models a membrane with a surface modeled by B (a parallel composition of sequences) and a content modeled by T . Since, in CLS+, looping		L and containment	♩ are always applied together, we can consider them as a single binary operator which applies to a brane and to a term. Brackets can be used to indicate the order of application of the operators, and		L ♩ is assumed to have precedence over		| .
The structural congruence relation on terms identifies syntactically different terms that conceptually represent the same structure.
Definition 2.2 (Structural congruence) The structural congruence relations on sequences ≡S and terms ≡T are the least congruences satisfying the following rules:
S1 · (S2 · S3) ≡S (S1 · S2) · S3	S · ϵ ≡S ϵ · S ≡S S		S1 ≡S S2 ⇒ S1 ≡T S2 T | ϵ ≡T T	T1 | (T2 | T3) ≡T (T1 | T2) | T3	T1 | T2 ≡T T2 | T1
The structural congruence states the associativity of both the sequencing and the parallel operator, the commutativity of the latter, and the neutral role of ϵ.
The evolution of a system is described by a set of rewrite rules, modeling reac- tions among system elements. A rule is composed of a pair of patterns (terms with variables) with the intuitive meaning that, if the first pattern occurs in a portion of the system, then that portion can be modified according to the second pattern.
We assume the following infinite and pairwise disjoint sets of variables: SV for sequence variables x, y,.. .; X for element variables x, y,.. .; TV for term variables X, Y,... and BV for brane variables X, Y ,.  We denote the set of all variables by
V. We distinguish among different kinds of pattern, as in the following definitions.
Definition 2.3 [Brane and sequence patterns]Brane patterns BP and sequence pat-

terns SP are given by the following grammar:
BP  ::= SP		BP | BP	SP  ::= ϵ		a		SP · SP		x˜		x
We denote the sets of all brane and sequence patterns with BP and SP, respectively.
Definition 2.4 [Term patterns] Left patterns PL and right patterns PR are given by the following grammar:

PL ::= SP		 BPLX  ♩ P
L

	PL

| PL



BPLX  ::= BP		BP | X
 
PLX  ::= PL	PL | X

 		

BPRX  ::= BP	BPRX | X
We denote the sets of all left and right patterns with PL and PR, respectively. We assume brane patterns to be a subset of left and right patterns, i.e. BP ⊂ PL(⊂ PR).
The set of all variables appearing in a pattern P is denoted by Var(P ). We also assume the structural congruence relation to be extended to patterns.
A CLS+ term evolves by applying rewrite rules to it. A rewrite rule is a pair of patterns (PL, PR), usually written as PL '→ PR, such that PL /≡ ϵ and Var(PR) ⊆ Var(PL). If PL and PR are indeed brane patterns, then the rule is called brane (rewrite) rule.
Given a pattern, we may obtain a term by applying an instantiation function σ : V → T , describing the bindings between variables and their values. This application, denoted by Pσ, replaces each occurrence of v ∈ Var(P ) in P with σ(v). For example, we can instantiate the pattern P = a · x | X L ♩ (c | Y ) with instantiation σ = {(x, b · b), (X, a · b · b | d · b · b), (Y, c | d)} obtaining the term Pσ = a · b · b | a · b · b | d · b · b L ♩ (c | c | d). An instantiation function σ must respect the type of var iables, namely for all X ∈ TV, X ∈ BV, x ∈ SV and x ∈ X we have σ(X) ∈T , σ(X) ∈ B, σ(x) ∈S and σ(x) ∈ E, respectively. The set of all instantiations is denoted by Σ.
A rewrite rule PL '→ PR states that a term PLσ, obtained by instantiating variables in PL by some instantiation function σ, can be transformed into the term PRσ. Thus, a term T may evolve to another term T ' by applying a rewrite rule to a subterm of T .
The use of different kinds of patterns allows us to constrain the occurrences of variables inside them. These constraints are useful to simplify the semantics and, as explained in [7], they do not restrict the expressive power of the calculus for modeling usual biological systems. First of all, brane and term variables may occur only on branes and inside looping sequences, respectively. Then, with respect to left patterns, term variables are not allowed at top–level, and at most one brane or term variable is allowed in each compartment. We do not allow term variables on branes: this ensures that the application of a rewrite rule never yields an invalid term, i.e.

a term with looping sequences on branes. For the same reason, we identify brane rewrite rules BP1 '→ BP2 as the only kind of rules that can be applied to branes.
The semantics of the calculus is given as a transition system, in which states correspond to terms, and each transition → represent the applications of a rewrite rule. The definition uses the auxiliary transition relation →B, that describes the evolution of branes (ensuring that only brane rewrite rules can be applied to their elements).
Definition 2.5 [Semantics] Given a set of rewrite rules R, let RB denote its subset of all and only brane rules (RB ⊆ R). The semantics of CLS+ is the least transition relation → on terms closed under ≡T and satisfying the following inference rules:

P1 '→ P2 ∈R	P1σ /≡ ϵ	σ ∈ Σ


P1σ → P2σ
BP1 '→ BP2 ∈ RB	BP1σ /≡ ϵ	σ ∈ Σ
BP1σ →B BP2σ

	T1 → T ′
T1 | T2 → T ′ | T2
	B1 →B B′
B1 | B2 →B B′ | B2

T1 → T2
B →B B′


	
 B L ♩ T → B L ♩ T	 B L ♩ T → B′ L ♩ T

As an example, let T = a · b · b | d · b L ♩ (c | d) and let a · x | X L ♩ (c | Y ) '→ d · x | X L ♩ Y be a rewrite rule modeling the formation of a complex on a membrane by the interaction of an element a · x˜ on the membra ne with an ele ment

The Spatial CLS
The definition of Spatial CLS is based on CLS+, recalled in Section 2. The syntax of terms is an extension of that of CLS+, where sequences and membranes are enriched with spatial information. We assume an alphabet E (as in CLS+), and a set M of names denoting movement functions.
Definition 3.1 Terms T , branes B and sequences S of Spatial CLS are defined as:
T  ::= λ		 S d		 B  ♩ T		T | T
L
B ::=  S d		B | B


where d ∈D = ((Rn × M) ∪ {·}) × R+. The set of all sequences, branes and terms are denoted by S, B and T , respectively. We assume that B⊂ T .
The term λ denotes the empty term, while ϵ denotes the empty sequence. The parameter d associated with the elements describes their spatial information. The calculus allows representing two kinds of elements, positional and non-positional, depending on the form of the parameter d. For positional elements d = ⟨[p, m], r⟩, where p gives the position of the center of the sphere modeling the space occupied

by the element, m is the movement function and r is the radius of the sphere. For non-positional elements d = ⟨·, r⟩, as we do not keep track of their position and movement function (replaced by the special symbol · ), but only of their radius r. For looping sequences  L ♩ , r describes the available space inside the membrane. The position of positional elements appearing on the brane of a looping sequence or inside it, are relative to the center of the looping sequence itself.
Non-positional elements correspond to CLS terms in Spatial CLS, and therefore their behaviour is in accordance with the Law of Mass Action: they are assumed homogeneously distributed in the space available inside the compartment, and the reaction rate of the rules involving those elements is proportional to the product of the concentrations of the reactants. Therefore Spatial CLS allows descriptions at different levels, as precise spatial information can be used only for those elements for which it is relevant.
Each m ∈ M denotes a function mfun describing the autonomous movement of an element over time.	In particular, mfun computes the new position p' = mfun(p, r, x, l, t, δt) of an element after a time interval δt from the current time t, by taking into account its current position p, its radius r, and the parameters x and l specifying where the element appears: either on the surface (on) or inside (in) a membrane with radius l, or at top–level (in such case x = in, l = ∞). Thus mfun : Rn ×R+ × {in, on}×(R+ ∪ {∞})× R+ ×R+ → Rn. For example, a linear mo- tion can be modeled by a movement function defined as mfun(p, r, x, l, t, δt)= q +vt, where q is the initial position and v is the velocity. A useful movement function, which is often needed in models, is the one associated with the elements that do not move autonomously. We denote it as m0, and define it as m0fun(p, r, x, l, t, δt)= p. This formalization of Spatial CLS does not allow direct description of stochas-
tic motions, such as Brownian motion. However, it can be extended to allow pseudo-random motion (that is still deterministic) by introducing another param- eter for movement functions. This parameter represents a seed used to initialize their pseudo-random behaviour, similarly to the initialization of a pseudo-random number generator. The (multiset of) possible values for the seed could be specified in the spatial information of positional elements. In this way, we could define a movement function which realizes, depending on the parameter, a different trajec- tory for the stochastic motion. Because of lack of space, we cannot actually show this extension of the calculus, but in the examples we will assume it to be available.
Definition 3.2 The structural congruence relations on sequences ≡S and on terms
≡T are the least congruences satisfying the following rules:
S1 · (S2 · S3) ≡S (S1 · S2) · S3  S · ϵ ≡S ϵ · S ≡S S   S1 ≡S S2 ⇒ S1 d ≡T  S2 d
T | λ ≡T T	T1 | (T2 | T3) ≡T (T1 | T2) | T3	T1 | T2 ≡T T2 | T1
From a biological point of view, we cannot consider all possible terms to be valid. Intuitively, we have to avoid that different elements occupy the same space. In particular, we introduce the following constraints for positional elements:
elements inside a membrane (or at top–level) must not occupy the same space;

elements of a brane must not occupy the same space;
elements of a brane must not occupy the space of any other element either inside or outside the membrane;
elements inside a membrane must not exceed the limits of the sphere representing the membrane;
the center of the elements of a brane must be located on the surface of the sphere representing the membrane.
Moreover, we want to ensure that the space occupied by all the elements in a membrane does not exceed the volume of the membrane. To take into account the space occupied by non–positional elements, we assume a function SpaceCheck that determines whether there is enough space in a membrane for all the elements inside it, and for all those on its surface. The constraints described are captured by the following definition of well-formedness, where we assume the function dist : Rn × Rn → R+ that gives the distance between two points.
Definition 3.3 [Well-formed terms] The set of well-formed terms is defined as 6
Twf = {T ∈T | ∃I ∈ I. I |= T }
where I = P(J × P(J )), J = (Rn ∪ {·}) × R+, and relation |= ⊆I × T is defined by the following inference rules (where 0 denotes the null vector):
∅ |= λ	{(·, r, ∅)} |= S ·,r	{(p, r, ∅)} |= S [p,m],r
I1 |= B	I2 |= T	SpaceCheck(r, I1, I2)= tt
∀ (p1, r1) ∈ All(I1). dist(0, p1)= r	∀ (p2, r2) ∈ All(I2). dist(0, p2)+ r2 ≤ r
∀ (p1, r1) ∈ All(I1), (p2, r2) ∈ All(I2). dist(p1, p2) ≥ r1 + r2

{(·, r, All(I ))} |= B L ♩ T



{(·, r,J)} |= B L ♩ T
1	·,r
I1 |= T1	I2 |= T2
∀ (p ,r ) ∈ All(I ), (p ,r ) ∈ All(I ). dist(p ,p ) ≥ r + r



{(p, r, J)} |= B L	♩ T
I1 ∪ I2 |= T1 | T2

where SpaceCheck : R+ ×I ×I → {tt , ff } is assumed, and All : I → (Rn × R+) is defined as All(I)= (p,r,J )∈I|·/=p{(p, r)}∪ {(p + p', r') | (p', r') ∈ J ∧ p' /= ·}.
The above inference rules allow deriving pairs of the form I|=T , where I describes all the elements appearing at top-level in T and, for each top-level looping sequence, all the elements appearing on its brane. In particular, the set I contains pairs
⟨(p, r), {(p1, r1),... , (pn, rn)}⟩ where (p, r) describes the spatial information of an element, and the set {(p1, r1),... , (pn, rn)} the spatial information of the elements on its brane (if (p, r) corresponds to a looping sequence, otherwise it is empty). A term T is well-formed iff there exists an I such that I |= T .

6 Symbol P denotes the powerset operator.

The function SpaceCheck takes as parameters the radius r of the looping se- quence, and the spatial descriptions of the elements inside it (I2) and of those on the brane (I1). It can use that information to determine, approximately, if there is enough space for all the elements. For example, the simplest, but the least ac- curate, definition of the function is the constant function that always returns tt , namely SpaceCheck(r, I1, I2)= tt . However, more accurate definitions can be used, if needed.
As for CLS+, we have different kinds of patterns. Now, we also distinguish between brane patterns appearing on the left and on the right part of a rewrite rule. The sets of variables SV , X , BV and TV are assumed as in CLS+, with
V = SV ∪X ∪ BV ∪ TV . Moreover, we assume a set of position variables PV ranged over by u, v,.. .. We distinguish between the instantiation of variables V and that of position variables PV . An instantiation function for variables in V is a partial function σ : V → Twf ∪B ∪S ∪ E that respects the type of variables, while the one for position variables is a partial function τ : PV → D. We denote by Σ and T the sets of all instantiation functions of the two kinds, respectively.
Definition 3.4 [Sequence and brane patterns] Left brane patterns BPL, right brane patterns BPR and sequence patterns SP are defined by the following grammar:


SP  ::= ϵ		a		SP · SP		x˜		x

where u ∈ PV , g : T → D. We denote the sets of all left and right brane patterns, and sequence patterns, by BPL, BPR and S, respectively.
Definition 3.5 [Term patterns] Left patterns PL and right patterns PR are given by the following grammar:

P	::=  SP		 BP

 L ♩ P


	P  | P



PLX	::= PL		PL | X

P	::= λ		 SP 
	 BP

 L ♩ P

	P  | P


	X		X

BPRX  ::= BPR	BPRX | X	X

where u ∈ PV , g : T → D. We denote the sets of all left patterns by PL, the set of all right patterns by PR, and we assume them to be supersets of BPL and BPR, respectively. We denote by Var(P ) the set of all variables appearing in a pattern P , including position variables from PV .
Definition 3.6 A rewrite rule is a 4-tuple (fc, PL, PR, k), usually written as
[ fc ]	PL →k PR
where fc : T → {tt , ff }, k ∈ R+, Var(PR) ⊆ Var(PL), and each function g appearing

in PR refers only to position variables in Var(PL). A rewrite rule where PL and PR
are brane patterns BPL and BPR, respectively, is called brane (rewrite) rule.
Rewrite rules are used for modeling the reactions that can occur in the system. Conceptually, a reaction occurs among the elements of the system that match the sequences (simple and looping) appearing in the left pattern. Term and brane variables appearing in the left pattern are used as placeholders for the other elements of a compartment which are not involved in the reaction.
A term can be obtained from a pattern by applying a pair of instantiation functions τ and σ to it. This entails the instantiation of the variables of the pattern and, for right patterns PR, the replacement of each function g : T → D with the value obtained by applying each of them to τ . A rewrite rule states that, if there exists a pair of instantiation functions τ and σ such that PLτσ matches a subterm of the current system, then that subterm may be rewritten to PRτσ. The function τ conceptually carries the bindings between position variables if the left pattern of the rule and the actual spatial information (radius and, possibly, position and movement function) of the matched elements. In this way, the g functions are used to compute the spatial information for the elements on the right patterns, using the spatial information of the elements that match with the left pattern.
The rewrite rule, besides left and right patterns, is formed by a function fc that specifies its application constraints, that is whether or not the rule can be applied to specific matching elements. The applicability of the rule is determined by evaluating function fc over the τ used for the matching. For instance, this function may be used to check the positions of the involved elements, and to allow the reaction only if they are close enough. Moreover, similarly to the variant of CLS called Stochastic CLS [7], rewrite rules are endowed with a rate constant k ∈ R, modeling its propensity of application. In particular, the value 1/k represents the expected duration of a reaction involving a precise combination of reactants. For example, a value of k =4 means that each occurrence of the reaction modeled by the rule, on the average, lasts 0.25 time units.

Semantics
A biological system, described by a term and a set of rewrite rules, evolves by performing a sequence of steps. A step represents the evolution of the system in a finite timespan, and is conceptually composed of two phases: the first, where at most one reaction can occur; the second, where the positions of all the (positional) elements of the system are updated according to their movement functions. The processes we want to describe can be considered to be Poisson processes. This justifies the assumption that at most one reaction occurs at each step, provided that the time length of the step is chosen short enough.
The result of the application of a rewrite rule could be a non well-formed term (according to Definition 3.3), because collisions arise. The same situation can hap- pen after moving the elements. This problem is solved by performing, as last oper- ation of each of the two phases, a “rearrangement” of the elements in the system.






















Fig. 1. Rules of the transition relation −→mov .



The rearrangement is accomplished by the Arrange algorithm (described in Section 3.2), which may fail to determine a well-formed term: if such is the case when trying to apply a rule to a group of elements, then it is assumed that the considered group of elements cannot react (so the rule cannot be applied). If the rearrangement fails after the phase of movement, then for the current step the elements are not moved. Before defining the semantics, we need to introduce some auxiliary definitions.
Let M ove : Twf × R+ × R+ → Twf be the following function:

T ''	if ∃T ',T ''. ⟨T, t, δt⟩ −i−n−∞→	T ' ∧ T '' = Arrange(T ') /=⊥;
M ove(T, t, δt)= 
T	otherwise;

where relation −x−→l mov, with x ∈ {in, on} and l ∈ R+, is the least labeled transition relation given by the inference rules shown in Figure 1. M ove is used to perform the movement phase, and gives a new term, obtained from the current state T by updating the positions of all the (positional) elements to the positions reached after δt time units from time t.
The rate of a rule application is calculated with the help of the functions comb, comb' and binom. In the following definition, we denote the multiset of top-level elements appearing in a pattern (or term) P by P , and assume the function n : T × T → N that, applied to a term T1, representing a (simple or looping) sequence, and another term T2, gives the number of times the T1 appears at top-level in T2.
Let comb, comb' : PL × T × Σ → N and binom : T × T × T → Q be recursively


Fig. 2. The inference rules used for computing the rate of a rule application.

defined as follows:
comb(PL1 | PL2, τ, σ)= comb(PL1, τ, σ) · comb(PL2, τ, σ)
comb( BP	 L ♩ P	, τ, σ)= comb′(BP	, τ, σ) · comb′(P	, τ, σ)
comb( SP u, τ, σ)= 1

comb′(P
| U, τ, σ)= 
 n((PL|U )τσ, T )  · comb(P
, τ, σ)	U ∈ BV ∪ TV 


comb′(PL, τ, σ)= comb(PL, τ, σ)
n(T3 ,T )

binom(T ,T ,T )= 
	n(T2,T )+ i	

	


Given a finite set of rewrite rules R, let RB ⊆ R be the set of all brane rules in
R,T ,c
R and let −−−→, with R ∈ R,T ∈ T and c ∈  , be the least labeled transition
relation on terms closed with respect to ≡T and satisfying the inference rules shown in Figure 2. These definitions follows closely that of Stochastic CLS given in [7], to which we refer for more details.
The defined transition relation is used to determine each group of elements to which a rewrite rule can be applied, without considering the subsequent rearrange-
R,T ,c
ment. Each transition T1 −−−→ T2 describes the application of rewrite rule R inside
term T1 yielding to T2. The value c ∈ N corresponds to the number of different reactant combinations among which the reaction described by R may, conceptually,
occur. This is needed because, for example, if we consider a rewrite rule involving

non-positional elements, such as  a 

·,0
|  b 
·,0 →
 a · b 

·,0
, then the reaction can

conceptually occur between each pair of elements a ·,0 and b ·,0 contained in a compartment. Nevertheless, all of them yield to a same term, obtained by replacing
one a ·,0 and one b ·,0 with a · b ·,0. Thus, in this case, the value c is the number of pairs of elements that can react, which is equal to the number of a’s times the number of b’s in the compartment.
The following definition gives all the reactions enabled in a state, by also taking

into account the subsequent rearrangement:


Appl(R, T )= {(T , c,T ',T '') | T R,Tr ,c
T ' ∧ T '' ≡ Arrange(T ') /=⊥}

r	−−−−→

Given a rewrite rule R and a term T1, function Appl computes a set of tuples of the form (Tr, c,T ',T ''), where Tr identifies the subterm of T1 to which R is applied (i.e. the reactants), T ' is the term transformed by the application excluding the rearrangement, and T '' is the rearrangement of T '. We consider two reactions to be different if they involve different reactants Tr or different resulting terms T ''. Finally, the number m(R) of different reactant combinations enabled in state T , for a reaction R, and the total number mT of reactions considering a set of rules R, are defined as:


(R)
T
(Tr,c,T ',T '')∈Appl(R,T )
(R)
T
R∈R


Let T describe the state of the system at a certain step, and kR denote the rate
associated with a rewrite rule R. At each step of the evolution of the system, in order to assume that at most one reaction can occur, we have to choose a time

interval δt such that  Σ

R∈R
kR m(R)  δt ≤ 1. Given a set of rewrite rules R, we

choose an arbitrary value N such that for each rule R ∈R it holds 0 < kR/N ≤ 1.
Then we compute the time interval for a step as δt = 1/N , thus satisfying the above
T
condition. The value of N also determines the maximum permitted length of each
step as 1/N time units. Its choice may indirectly affect the precision in representing movement.
Finally, the probability that no reaction happens in the time interval δt is:


pT =1 − Σ ,⎝	Σ

kR/N · c	,
mT

R∈R	(Tr,c,T ',T '')∈Appl(R,T )

and the probability P (T1 → T2, t) of reaching state T2 from T1 after a time interval

δt = 1/N
T1
by t is such that:

′	Σ ,.	Σ


k /N
⎞.	 p


if T1 ≡ T ′;


R∈R ⎝ r	'  2
1	1	⎠
0	otherwise.


The semantics, given as a Probabilistic Transition System, is defined as follows.
Definition 3.7 [Semantics] Given a finite set of rewrite rules R, the semantics of

Spatial CLS is the least relation satisfying the following inference rules:
(Tr, c,T ′, T2) ∈ Appl(R, T1)	R ∈R	T1 /≡ T ′
p = P (T1 → T ′, t)	T ′ ≡ M ove(T2, t, δt)	δt =  1/N

2	2
p
⟨T ,t 
T ′,t + δt⟩
mT1

1 ⟩ −→⟨ 2
p = P (T → T ′, t)	T ′ ≡ M ove(T, t, δt)	δt = 	1/N	

p
⟨T, t
T ′,t + δt⟩

The states of the transition system are of the form ⟨T, t⟩, representing the system
p
at time t. Each transition ⟨T1, t⟩ −→ ⟨T2,t + δt⟩ describes all the reactions, in the
current step, that may lead to T2 from T1, also by considering the rearrangements of elements done after each phase. The first inference rule is used to derive transitions
which yield a term T ' different from T1, while the second is used to derive the
transition representing the case in which no reaction occurs. In the second case, the function P computes a probability which takes into account those reactions that do not change the state of the system.

Resolving space conflicts
Space conflicts that may arise during the evolution of the system are resolved by the algorithm Arrange, which simulates the movement of the elements as if they push each other. The problem is modeled by assuming an instant velocity associated with each element, whose direction and speed depend on the instant position of every element.
Given an element, the velocity it is subjected to is calculated as the sum of other velocities:
for each other element it overlaps with, we assume a velocity directed opposite to the other element (the elements are trying to increase their distance) and whose magnitude is proportional to the length of the overlap;
if the element is not completely within the bounds of the containing membrane, then we assume a velocity directed towards the center of the membrane, whose magnitude is inversely proportional to the distance from the center;
if the element is on the surface of a membrane, but its center is not located on the surface of the sphere, then we assume a velocity directed towards the nearest point of the sphere with a magnitude proportional to the distance from the sphere.
If any of those velocities are not well-defined (for instance, if the centers of two elements coincide), then we assume an arbitrary fixed direction along which the elements move.
This behaviour is modeled by a system of differential equations. Given a term T , let x1,... , xn be the variables for the centers of the positional elements appearing in T , and IL and IS the set of indices denoting looping and simple sequences, respectively (IL ∪ IS = {1,... , n}). Moreover, let In(i), with i ∈ IL, be the set of

indices denoting elements inside the looping sequence i, or, if i = 0, the indices of the top–level elements; let On(i), with i ∈ IL, denote the elements appearing on the surface of i; and Inner(i)= In(i) ∪  j∈In(i) On(j).
The system of differential equations used by Arrange is the following, where hi
is such that i ∈ Inner(hi):


⎧⎪ dxi = ,⎝	Σ
v ⎞⎠ − u + w	∀i. ∃k. i ∈ On(k)

⎪ dxi = ,⎝	Σ
vij⎞⎠ − ui	∀i ∈ In(hi)



and where the following definitions are used (a, b, c are non-null vectors specifying directions used when velocities cannot be calculated) 7 :
y =	xi + yj	if ∃j /= 0. i ∈ On(j) ∨ i ∈ In(j)
xi	otherwise
⎧⎪⎨vij (y^− y )	if yi /= yj

vij =


  
+vij a	if yi = yj and i < j 
⎪ ⎩−vij a	if yi = yj and i ≥ j

	
vij = max{0, ri + rj − yi − yj  }


	

w =	wi xi	if xi /= 0
wi c	if xi = 0
wi = rk

− xi 


The Arrange algorithm stops when a stable setting is reached. If the term rep- resenting this setting is not well-formed, the algorithm returns the special value ⊥, otherwise it returns a term where the positions of all the elements are updated. Note that, even if all space conflicts are resolved, still the term may not be well-formed because there is not enough space for the non-positional elements, as determined by the function SpaceCheck.
The use of this mechanism is not the only solution for dealing with space conflicts among the elements of a system. We could represent the elements as points, which means that they do not occupy any space. However, this assumption would be reasonable only if the elements are small with respect to the environment, and this is not always the case in biological systems. Another option would be allowing the application of a rule only if it would not create a conflict. Unfortunately, this option would lessen the modeling capacity of the calculus; for example, it would not be possible to model a membrane that, increasing its size, pushes contiguous elements.

7 xb denotes the normalized vector x, i.e. xb = x/  x if x /= 0.

A more physically sound modeling of the behaviour of the system in case of space conflicts, could be obtained by extending the calculus with the association of a “weight” and consequently a “pushing strength” to elements. The Arrange algorithm could take such weigths into account, so that an element could push other elements according to its strength.

Examples of modeling
In this section we show two examples of Spatial CLS models.

A model of cell proliferation
We show the development of a biological tissue. We represent the way in which a cell performs the mitosis cycle, and the development of the tissue as a consequence of it. The structure of a cell is made up of a permeable cell membrane, which separates it from external environment but still allows messages to pass through, and contains several organelles scattered in the cytoplasm. We model a simple eukaryotic cells as a membrane containing the nucleus, which, in turn, contains two DNA molecules (the chromosomes). Each cell performs the cell cycle [6], that is the sequence of phases that lead to its division into two daughter cells, structurally alike to the mother cell. Customarily, cell cycle repeats for every generated cell, but, in particular cases, the cell may decide to stop the process in a permanent or temporary way (for instance, in case of unfavourable ambient conditions).
The initial state of the biological system is described by the following term 8 :

T = b L

L
[(0,0),m1 ],10
♩ n L ♩ (cr · g

· g2
· g3
| cr · g4
· g5)

The term contains the looping sequence b L  , representing the space available for
the proliferation as a circle with a 50μm radius. It contains a single cell m L, positioned in (0, 0) and with a radius of 10μm. The cell is subjected to a small Brownian motion, modeled by m1. The nucleus, represented as n L, and the contained chromosomes, are represented as non-positional elements. The nucleus may be in two states, depending on the symbol appearing on its looping sequence. Initially, the nucleus is identified by the symbol n appearing on the surface of its membrane. During the evolution of the system, the symbol n is replaced by ndup, indicating a state in which the nucleus has started the duplication process and is about to divide. Chromosomes are modeled as sequences starting with cr symbol, followed by the genes, represented by the symbols gi’s. Instead, a duplicated chromosome is identified by having 2cr as its first symbol in the sequence.
The Brownian motion of cells represents the small movements the cells are sub- jected to in a biological tissue. The use of Spatial CLS to represent the cell cycle allows showing the spatial arrangement of cells during the tissue development. This

8 For the sake of clarity, we omit the spatial information for non-positional elements, i.e. those elements



(q,r⟩
such that ⟨q, r⟩ = ⟨·, 0⟩.


			
Fig. 3. The graphical representation of the system at times 0, 102h, 108h and 141h during simulation.

is an important point in many biological tissue, see for example [13] for a spatial mathematical modeling of a neural tissue.
The evolution of the system is modeled by the following rewrite rules 9 :

R :[ r =7 ]	 m L
R :[ r = 10 ]	 m L

0.33	L
[p,f ],10 X
♩ X 0→.25 m L	♩ X

2	[p,f ],r
R :[ r = 14 ]	 m L
[p,f ],14
L	0.5	L
[p,f ],r

♩  n


dup
 L ♩ X 

R4 : n

dup
 L ♩ (cr · x˜ | X) 0.→125 n

dup
 L ♩ (2cr · x˜ | X)

R5 : n

dup
 L ♩ (2cr · x˜ | 2cr · y˜) 0→.17 n L ♩ (cr · x˜ | cr · y˜) | n L ♩ (cr · x˜ | cr · y˜)

L
R6	[(x,y),f ],r
 m L
♩  n L ♩ X | n L ♩ Y  →1
♩ n L ♩ X | m L


♩ n L ♩ Y


The first three rules describe the growth of the cell. Rule R1 increases the radius from 7 to 10, leading a just-splitted cell to its normal size. Rule R2 represents the starting of the division process, where the cell grows to 14 and will eventually divide. A cell may block its cell cycle if there is not enough space: this happens when neither R1 nor R2 are applicable to it. The application of rule R3 signals the start of the division process for the nucleus. Rule R4 models the duplication of a single chromosome. Finally, rule R5 and R6 describe the division of the nucleus and the subsequent cellular division. In rule R6, the splitted cells are arbitrarily positioned one next to the other, near the position of the parent cell. The rates have been estimated according to the common relative lengths of the phases forming the cell cycle, and so as to obtain, on the average, a duration of 24 hours for the complete cycle ([6]).
Figure 3 shows the state of the system at certain times during the simulation, obtained by an ad hoc simulator. At time t = 0 the system contains only one cell, positioned inside the limiting membrane. The proliferation stops at time t = 141h, when the space left is not enough for any cell to grow. We can also see that, from time 102h to 108h, a cell near the center has splitted into two small cells, and another cell on the bottom right has grown, thus initiating the division process. By growing, the cell pushed the surrounding cells and caused the rearrangement.

9 For the sake of readability, we use a simpler syntax for writing rewrite rules: in the left part of the rules, we use placeholders for positions, movement functions and radii, and reuse them in the right part in a shorthand notation for defining instantiation functions for position variables.

A model of the quorum sensing process
Many bacteria have the ability of monitoring their population density and modu- lating their gene expressions according to this density. This process is called quorum sensing, and the main entities involved in it are the autoinducers, small molecules that can cross the cellular membrane and can diffuse freely either out or in bacteria, and the R-proteins, transcriptional activator proteins located within the cell.
At low cell density, the autoinducer is synthesized at basal levels and diffuse in the environment where it is diluted. With high cell density both the extracellular and intracellular concentrations of the autoinducer increase until they reach thresh- olds beyond which the autoinducer is produced autocatalytically. This autocatalytic production results in a dramatic increase of its concentration.
We show a simple model of the quorum sensing process in Pseudomonas aerugi- nosa (see [12] for a more detailed description of the phenomenon). Such a bacterium uses quorum sensing to keep low the expression of virulence factors until the colony has reached a certain density, when an autoinduced production of virulence factors is started. The initial state of each bacterium is:


Bacti
L
[pi,m0 ],rB
♩ (lasO · lasR · lasI)

where the bacterium membrane, denoted m L, contains only a DNA strand. Bac- teria do not move, hence their movement function is m0, and their radii are set to rB. The DNA is modeled as a sequence of genes lasO · lasR · lasI, where lasO represents the target to which a complex autoinducer/R-protein binds to promote transcription. The following rewrite rules model the system behaviour.
R  : lasO · lasR · lasI →k1 lasO · lasR · lasI | 3oxo
R : m L ♩ (3oxo | X) →k2 m L ♩ (3R | X)
R : m L ♩ (3R | X) →k3 m L ♩ (3oxo | X)
R  : 3R | lasO · lasR · lasI →k4 3RO · lasR · lasI R  : 3RO · lasR · lasI →k5 3R | lasO · lasR · lasI
R  : 3RO · lasR · lasI →k6 3RO · lasR · lasI | 3oxo

L
R7	[(x,y),f ],r
♩ (3oxo | X) →k7  3oxo 

[(x+r,y+r),mB],r3oxo
L
[(x,y),f ],r ♩ X

R :[ dist(p ,p ) ≤ r
+ 10 ]	 3oxo 
| m L
♩ X →k8 m L
♩ (3oxo | X)

8	1  2	2
R : 3oxo  →k9 λ
[p1 ,mB ],r3oxo
[p2 ,f ],r2
[p2 ,f ],r2

Rule R1 describes the basal production of the autoinducer, modeled as 3oxo. The value k1 is chosen according to its basal rate of production. Rules R2 and R3 describe the formation of the complex autoinducer/R-protein, modeled as 3R , and its decomplexation, respectively. To keep the model simple, we do not describe explicitly the R-protein. The next two rules, R4 and R5, model the binding and unbinding of the 3R complex to gene lasO of the DNA. Rule R6 describes the increased rate of production of the autoinducer, due to the binding of the complex

3R to the DNA. The promoted production of 3oxo can be modeled using a rate k6 much higher than the basal rate k1 used in rule R1. Rules R7 and R8 describe the ability of the autoinducer to cross the membrane, in both directions. An autoinducer inside the bacterium is modeled as a non-positional element, while autoinducers outside have an associated position, radius r3oxo and movement function mB. The movement function mB models Brownian motion, which describes the diffusion of the autoinducer in the environment. Finally, rule R9 models the degradation of the autoinducer, which can happen both inside and outside the bacterium.
This Spatial CLS model of the quorum sensing process is more accurate than other stochastic models (such as the Stochastic CLS model given in [7]). In fact, other stochastic models are usually based on the assumption that biological entities are homogeneously distributed in the environment, and in a quorum sensing process this is not true for the autoinducer proteins outside the bacteria. Note that taking into account the spatial diffusion has a particular significance when reactions are comparatively faster than diffusion rates [26].
Differently with respect to the cell proliferation example, in this case we have not developed an ad hoc simulator, for which the values of reaction constants should be given. We leave the development of a general simulator for Spatial CLS models as future work.

Conclusions
We have presented the Spatial Calculus of Looping Sequences (Spatial CLS), which extends the Calculus of Looping Sequences (CLS) by allowing spatial information to be associated with structures. The Spatial CLS formalism enables the accurate description of those biological processes whose behaviour depends on the exact position of the elements. As example applications, we have presented a model of cell proliferation and a model of the quorum sensing process in Pseudomonas aeruginosa. An ad hoc simulator has been developed for the model of cell proliferation. We leave as future work the development of a general simulator for Spatial CLS models.

References
SCLSm: The Stochastic CLS machine (web page).
URL http://www.di.unipi.it/~milazzo/biosims/
The BioSPI Project.
URL http://www.wisdom.weizmann.ac.il/~biospi/
The Stochastic Pi Machine (SPiM).
URL http://research.microsoft.com/~aphillip/spim/

Alur, R., C. Belta, F. Ivanˇci´c, V. Kumar, M. Mintz, G. J. Pappas, H. Rubin and J. Schug, Hybrid Modeling and Simulation of Biomolecular Networks, LNCS 2034 (2001), pp. 19–32.
Andrews, S. S. and D. Bray, Stochastic simulation of chemical reactions with spatial resolution and single molecule detail, Physical Biology 1 (2004), pp. 137–151.
Avers, C. J., “Molecular Cell Biology,” Addison-Wesley, 1986.

Barbuti, R., G. Caravagna, A. Maggiolo-Schettini, P. Milazzo and G. Pardini, The Calculus of Looping Sequences, LNCS 3016 (2008), pp. 387–423.
Barbuti, R., A. Maggiolo-Schettini, P. Milazzo and A. Troina, A Calculus of Looping Sequences for Modelling Microbiological Systems, Fundamenta Informaticae 72 (2006), pp. 21–35.
Cardelli, L., Brane Calculi. Interactions of Biological Membranes, LNCS 3082 (2005), pp. 257–280.
Curti, M., P. Degano, C. Priami and C. T. Baldari, Modelling biochemical pathways through enhanced
π-calculus, Theor. Comput. Sci. 325 (2004), pp. 111–140.
Danos, V. and C. Laneve, Formal molecular biology, Theor. Comput. Sci. 325 (2004), pp. 69–110.
Dockery, J. and J. Keener, A mathematical model for quorum sensing in pseudomonas aeruginosa, Bulletin of Mathematical Biology 63 (2001), pp. 95–116.
Galli-Resta, L., E. Novelli, Z. Kryger, G. H. Jacobs and B. E. Reese, Modelling the mosaic organization of rod and cone photoreceptors with a minimal-spacing rule, European Journal of Neuroscience 11 (1999), pp. 1461–1469.
Giavitto, J.-L. and O. Michel, MGS: a rule-based programming language for complex objects and collections, Electronic Notes in Theoretical Computer Science 59 (2001).
John, M., R. Ewald and A. M. Uhrmacher, A spatial extension to the π-Calculus, ENTCS 194 (2008),
pp. 133–148.
Krivine, J., R. Milner and A. Troina, Stochastic bigraphs, in: Proc. of MFPS’08, 24th Conference on the Mathematical Foundations of Programming Semantics, ENTCS to appear (2008).
Kwiatkowska, M., G. Norman and D. Parker, Probabilistic Symbolic Model Checking with PRISM: A Hybrid Approach, International Journal on Software Tools for Technology Transfer (STTT) 6 (2004),
pp. 128–142.
Matsuno, H., A. Doi, M. Nagasaki and S. Miyano, Hybrid Petri Net Representation of Gene Regulatory Network, Pacific Symposium on Biocomputing (2000), pp. 341–352.
Milazzo, P., “Qualitative and Quantitative Formal Modeling of Biological Systems,” Ph.D. thesis, Universit`a di Pisa (2007).
Plimpton, S. J. and A. Slepoy, Microbial cell modeling via reacting diffusive particles, Journal of Physics: Conference Series 16 (2005), pp. 305–309.
Priami, C. and P. Quaglia, Beta Binders for Biological Interactions, LNCS 3082 (2005), pp. 20–33.
Priami, C., A. Regev, E. Shapiro and W. Silverman, Application of a stochastic name-passing calculus to representation and simulation of molecular processes, Inform. Proc. Letters 80 (2001), pp. 25–31.
P˘aun, G., “Membrane Computing: An Introduction,” Springer, New York, 2002.
Regev, A., E. M. Panina, W. Silverman, L. Cardelli and E. Shapiro, BioAmbients: an abstraction for biological compartments, Theor. Comput. Sci. 325 (2004), pp. 141–167.
Regev, A., W. Silverman and E. Shapiro, Representation and simulation of biochemical processes using the pi-calculus process algebra., Pacific Symposium on Biocomputing (2001), pp. 459–470.
Takahashi, K., S. N. Arjunan and M. Tomita, Space in systems biology of signaling pathways – towards intracellular molecular crowding in silico, FEBS Letters (2005).
Tolle, D. P. and N. L. Nov`ere, Particle-Based Stochastic Simulation in Systems Biology, Current Bioinformatics (2006).
Versari, C., A core calculus for a comparative analysis of bio-inspired calculi, in: European Symposium on Programming, LNCS 4421 (2007), pp. 411–425.
