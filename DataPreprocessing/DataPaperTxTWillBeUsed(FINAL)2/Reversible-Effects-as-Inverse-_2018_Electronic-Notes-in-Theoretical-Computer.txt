Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 341 (2018) 179–199
www.elsevier.com/locate/entcs
Reversible Effects as Inverse Arrows
Chris Heunen1
School of Informatics University of Edinburgh United Kingdom
Robin Kaarsgaard2
Datalogisk Institut University of Copenhagen Denmark
Martti Karvonen3
School of Informatics University of Edinburgh United Kingdom

Abstract
Reversible computing models settings in which all processes can be reversed. Applications include low- power computing, quantum computing, and robotics. It is unclear how to represent side-effects in this setting, because conventional methods need not respect reversibility. We model reversible effects by adapting Hughes’ arrows to dagger arrows and inverse arrows. This captures several fundamental reversible effects, including serialization and mutable store computations. Whereas arrows are monoids in the category of profunctors, dagger arrows are involutive monoids in the category of profunctors, and inverse arrows satisfy certain additional properties. These semantics inform the design of functional reversible programs supporting side-effects.
Keywords: Reversible Effect; Arrow; Inverse Category; Involutive Monoid

Introduction
Reversible computing studies settings in which all processes can be reversed: pro- grams can be run backwards as well as forwards. Its history goes back at least as far as 1961, when Landauer formulated his physical principle that logically irreversible manipulation of information costs work. This sparked the interest in developing

1 Email: chris.heunen@ed.ac.uk
2 Email: robin@di.ku.dk
3 Email: martti.karvonen@ed.ac.uk

https://doi.org/10.1016/j.entcs.2018.11.009
1571-0661/© 2018 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

reversible models of computation as a means to making them more energy efficient. Reversible computing has since also found applications in high-performance comput- ing [29], process calculi [8], probabilistic computing [32], quantum computing [31],
and robotics [30].
There are various theoretical models of reversible computations. The most well- known ones are perhaps Bennett’s reversible Turing machines [4] and Toffoli’s re- versible circuit model [33]. There are also various other models of reversible au- tomata [26,24] and combinator calculi [1,19].
We are interested in models of reversibility suited to functional programming languages. Functional languages are interesting in a reversible setting for two rea- sons. First, they are easier to reason and prove properties about, which is a boon if we want to understand the logic behind reversible programming. Second, they are not stateful by definition, which eases reversing programs. It is fair to say that existing reversible functional programming languages [20,34] still lack various desirable constructs familiar from the irreversible setting.
Irreversible functional programming languages like Haskell naturally take se- mantics in categories. The objects interpret types, and the morphisms interpret functions. Functional languages are by definition not stateful, and their categori- cal semantics only models pure functions. However, sometimes it is useful to have non-functional side-effects, such as exceptions, input/output, or indeed even state. Irreversible functional languages can handle this elegantly using monads [25] or more generally arrows [17].
A word on terminology. We call a computation a : X → Y reversible when it comes with a specified partner computation a† : Y → X in the opposite direction. This implies nothing about possible side-effects. Saying that a computation is par- tially invertible is stronger, and requires a ◦ a† ◦ a = a. Saying that it is invertible is even stronger, and requires a◦a† and a† ◦a to be identities. We call this partner of a reversible computation its dagger. In other words, reversible computing for us con- cerns dagger arrows on dagger categories, and is modeled using involutions [15]. In an unfortunate clash of terminology, categories of partially invertible maps are called inverse categories [6], and categories of invertible maps are called groupoids [10]. Thus, inverse arrows on inverse categories concern partially invertible maps.
We develop dagger arrows and inverse arrows, which are useful in two ways:
We illustrate the reach of these notions by exhibiting many fundamental reversible computational side-effects that are captured (in Section 3), including: pure re- versible functions, information effects, reversible state, serialization, vector trans- formations dagger Frobenius monads [14,15], recursion [21], and superoperators. Because there is not enough space for much detail, we treat each example in- formally from the perspective of programming languages, but formally from the perspective of category theory.
We prove that these notions behave well mathematically (in Section 4): whereas arrows are monoids in a category of profunctors [18], dagger arrows and inverse arrows are involutive monoids.

This paper aims to inform design principles of sound reversible programming languages. The main contribution is to match desirable programming concepts to precise category theoretic constructions. As such, it is written from a theoretical perspective. To make examples more concrete for readers with a more practical background, we adopt the syntax of a typed first-order reversible functional pro- gramming language with type classes. We begin with preliminaries on reversible base categories (in Section 2).
Dagger categories and inverse categories
This section introduces the categories we work with to model pure computations: dagger categories and inverse categories. Each has a clear notion of reversing mor- phisms. Regard morphisms in these base categories as pure, ineffectful maps.
Definition 2.1 A dagger category is a category equipped with a dagger : a con- travariant endofunctor C → C satisfying f†† = f for morphisms f and X† = X for objects X. A morphism f in a dagger category is:
positive if f = g† ◦ g for some morphism g;
a partial isometry if f = f ◦ f† ◦ f ;
unitary if f ◦ f† = id and f† ◦ f = id.
A dagger functor is a functor between dagger categories that preserves the dagger,
i.e. a functor F with F (f†)= F (f )†. A (symmetric) monoidal dagger category is a monoidal category equipped with a dagger making the coherence isomorphisms
αX,Y,Z : X ⊗ (Y ⊗ Z) → (X ⊗ Y ) ⊗ Z	ρX : X ⊗ I → X
λX : I ⊗ X → X	(and σX,Y : X ⊗ Y → Y ⊗ X in the symmetric case)
unitary and satisfying (f ⊗g)† = f† ⊗g† for morphisms f and g. We will sometimes suppress coherence isomorphisms for readability.
Any groupoid is a dagger category under f† = f−1. Another example of a dagger category is Rel, whose objects are sets, and whose morphisms X → Y are relations R ⊆ X × Y , with composition S ◦ R = {(x, z) | ∃y ∈ Y : (x, y) ∈ R, (y, z) ∈ S}. The dagger is R† = {(y, x) | (x, y) ∈ R}. It is a monoidal dagger category under either Cartesian product or disjoint union.
Definition 2.2 A (monoidal) inverse category is a (monoidal) dagger category of partial isometries where positive maps commute: f ◦ f† ◦ f = f and f† ◦ f ◦ g† ◦ g = g† ◦ g ◦ f† ◦ f for all maps f : X → Y and g : X → Z.
Every groupoid is an inverse category. Another example of an inverse category is PInj, whose objects are sets, and morphisms X → Y are partial injections: R ⊆ X ×Y such that for each x ∈ X there exists at most one y ∈ Y with (x, y) ∈ R, and for each y ∈ Y there exists at most one x ∈ X with (x, y) ∈ R. It is a monoidal inverse category under either Cartesian product or disjoint union.

Definition 2.3 A dagger category is said to have inverse products [11] if it is a symmetric monoidal dagger category with a natural transformation ΔX : X → X ⊗ X making the following diagrams commute:



X	X ⊗ X
 σX,X
X ⊗ X

X
 ΔX
X ⊗ X 
id ⊗ ΔX
ΔX



X ⊗ (X ⊗ X)
X ⊗ X
ΔX ⊗ id 
α	(X ⊗ X) ⊗ X





ΔX
X	X ⊗ X
†
X ⊗ X

Δ ⊗ id
id ⊗ ΔX
†
X
X


(Δ†
X ⊗ (X ⊗ X)
⊗ id) ◦ α

id	ΔX
X

(X ⊗ X) ⊗ X	X ⊗ X
(id ⊗ Δ† ) ◦ α†

These diagrams express cocommutativity, coassociativity, speciality and the Frobe- nius law.
Another useful monoidal product, here on inverse categories, is a disjointness tensor, defined in the following way (see [11]):
Definition 2.4 An inverse category is said to have a disjointness tensor if it is equipped with a symmetric monoidal tensor product −⊕− such that its unit 0 is a zero object, and the canonical quasi-injections


ρ−1
X⊕00,Y
λ−1
00,X ⊕Y

M1 = X −−X→ X ⊕ 0 −−−−−→ X ⊕ Y	M2 = Y
−−Y→ 0 ⊕ Y
−−−−−→ X ⊕ Y

are jointly epic.
For example, PInj has inverse products ΔX : X → X ⊗ X with x '→ (x, x), and a disjointness tensor where X ⊕ Y is given by the tagged disjoint union of X and Y (the unit of which is ∅).
Inverse categories can also be seen as certain instances of restriction categories. Informally, a restriction category models partially defined morphisms, by assigning to each f : A → B a morphism f¯: A → A that is the identity on the domain of
definition of f and undefined otherwise. For more details, see [6].
Definition 2.5 A restriction category is a category equipped with an operation that assigns to each f : A → B a morphism f¯: A → A such that:
f ◦ f¯ = f for every f ;
f¯ ◦ g¯ = g¯ ◦ f¯ whenever dom f = dom g;
g ◦ f¯ = g¯ ◦ f¯ whenever dom f = dom g;

g¯ ◦ f = f ◦ g ◦ f whenever dom g = cod f .
A restriction functor is a functor F between restriction categories with F (f¯) = F (f ). A monoidal restriction category is a restriction category with a monoidal structure for which ⊗ : C × C → C is a restriction functor.
A morphism f in a restriction category is a partial isomorphism if there is a morphism g such that g ◦ f = f¯ and f ◦ g = g¯. Given a restriction category C, define Inv(C) to be the wide subcategory of C having all partial isomorphisms of
C as its morphisms.

An example of a monoidal restriction category is PFn, whose objects are sets, and whose morphisms X → Y are partial functions: R ⊆ X × Y such that for each x ∈ X there is at most one y ∈ Y with (x, y) ∈ R. The restriction R¯ is given by
{(x, x) | ∃y ∈ Y : (x, y) ∈ R}.

Remark 2.6 Inverse categories could equivalently be defined as either categories in which every morphism f satisfies f = f ◦g◦f and g = g◦f ◦g for a unique morphism g, or as restriction categories in which all morphisms are partial isomorphisms [6, Theorem 2.20]. It follows that functors between inverse categories automatically preserve daggers and that Inv(C) is an inverse category.
It follows, in turn, that an inverse category with inverse products is a monoidal inverse category: because X ⊗− and −⊗Y are endofunctors on an inverse category, they preserve daggers, so that by bifunctoriality −⊗− does as well:

(f⊗g)† = ((f⊗idY )◦(idX⊗g))† = (idX⊗g)†◦(f⊗idY )† = (idX⊗g†)◦(f†⊗idY )= f†⊗g†.


Arrows as an interface for reversible effects
Arrows are a standard way to encapsulate computational side-effects in a functional (irreversible) programming language [16,17]. This section extends the definition to reversible settings, namely to dagger arrows and inverse arrows. We argue that these notions are “right”, by exhibiting a large list of fundamental reversible side-effects that they model. We start by recalling irreversible arrows.

Definition 3.1 An arrow on a symmetric monoidal category C is a functor A : Cop×
C → Set with operations

arr : (X → Y ) → A X Y
(>>>): A X Y → A Y Z → A X Z
firstX,Y,Z : A X Y → A (X ⊗ Z) (Y ⊗ Z)

that satisfy the following laws:
(a >>> b) >>> c = a >>> (b >>> c)	(1)
arr(g ◦ f ) = arr f >>> arr g	(2)
arr id >>> a = a = a >>> arr id	(3)
firstX,Y,I a >>> arr ρY = arr ρX >>> a			(4) firstX,Y,Z a >>> arr(idY ⊗ f )= arr(idX ⊗ f ) >>> firstX,Y,Z a	(5) (firstX,Y,Z⊗V a) >>> arr αY,Z,V = arr αX,Z,V >>> first(first a)		(6) first(arr f )= arr(f ⊗ id)	(7)
first(a >>> b)= (first a) >>> (first b)	(8)
where we use the functional programming convention to write A X Y for A(X, Y ) and X → Y for hom(X, Y ) The multiplicative fragment consists of above data except first, satisfying all laws except those mentioning first; we call this a weak arrow.
Define second(a) by arr(σ) >>> first(a) >>> arr(σ), using the symmetry, so analogs of (4)–(8) are satisfied. Arrows makes sense for (nonsymmetric) monoidal categories if we add this operation and these laws.
Definition 3.2 A dagger arrow is an arrow on a monoidal dagger category with an additional operation inv : A X Y → A Y X satisfying the following laws:
inv(inv a)= a	(9)
inv a >>> inv b = inv(b >>> a)	 (10) arr(f†) = inv(arr f )	(11)
inv(first a) = first(inv a)	(12)
A inverse arrow is a dagger arrow on a monoidal inverse category such that:
(a >>> inv a) >>> a = a	(13)
(a >>> inv a) >>> (b >>> inv b)= (b >>> inv b) >>> (a >>> inv a)	(14)
The multiplicative fragment consists of above data except first, satisfying all laws except those mentioning first.
Remark 3.3 There is some redundancy in the definition of an inverse arrow: (13) and (14) imply (11) and (12); and (11) implies inv(arr id) = arr id.
Like the arrow laws (1)–(8), in a programming language with inverse arrows, the burden is on the programmer to guarantee (9)–(14) for their implementation. If that is done, the language guarantees arrow inversion.
Remark 3.4 Now follows a long list of examples of inverse arrows, described in a typed first-order reversible functional pseudocode with type classes, inspired by Theseus [20,19], the revised version of Rfun (briefly described in [22]), and Haskell.

Type classes are a form of interface polymorphism: A type class is defined by a class specification containing the signatures of functions that a given type must imple- ment in order to be a member of that type class (often, type class membership also informally requires the programmer to ensure that certain equations are required of their implementations). For example, the Functor type class (in Haskell) is given by the class specification
class Functor f where
fmap : (a → b) → f a → f b 
with the additional informal requirements that fmap id = id and fmap (g ◦f ) =(fmap g )◦(fmap f )
must be satisfied for all instances. For example, lists in Haskell satisfy these equa- tions when defining fmap as the usual map function, i.e.:
instance Functor List where
fmap	:  (a → b) → List a → List b
fmap f []	= []
fmap f (x ::xs)= (f x )::(fmap f xs)
While higher-order reversible functional programming is fraught, aspects of this can be mimicked by means of parametrized functions. A parametrized function is a function that takes parts of its input statically (i.e., no later than at compile time), in turn lifting the first-order requirement on these inputs. To separate static and dynamic inputs from one another, two distinct function types are used: a → b denotes that a must be given statically, and a ↔ b (where a and b are first-order types) denotes that a is passed dynamically. As the notation suggests, functions of type a ↔ b are reversible. For example, a parametrized variant of the reversible map function can be defined as a function map : (a ↔ b) → ([a] ↔ [b]). Thus, map itself is not a reversible function, but given statically any reversible function f : a ↔ b, the parametrized map f : ([a] ↔ [b]) is.
Given this distinction between static and dynamic inputs, the signature of arr becomes (X ↔ Y ) → A X Y . We will see later that Arrows on C can be modelled categorically as monoids in the functor category [Cop × C, Set] [18]. Definition 3.1 uses the original signature, because this distinction is not present in the irreversible case. Fortunately, the semantics of arrows remain the same whether or not this distinction is made.
Example 3.5 (Pure functions) A trivial example of an arrow is the identity arrow hom(−, +) which adds no computational side-effects at all. This arrow is not as boring as it may look at first. If the identity arrow is an inverse arrow, then the programming language in question is both invertible and closed under program inversion: any program p has a semantic inverse Jp)† (satisfying certain equations), and the semantic inverse coincides with the semantics Jinv(p)) of another program inv(p). As such, inv must be a sound and complete program inverter (see also [23]) on pure functions; not a trivial matter at all.

Example 3.6 (Information effects) James and Sabry’s information effects [19] ex- plicitly expose creation and erasure of information as effects. This type-and-effect system captures irreversible computation inside a pure reversible setting.
We describe the languages from [19] categorically, as there is no space for syntac- tic details. Start with the free dagger category (C, ×, 1) with finite products (and hence coproducts), where products distribute over coproducts by a unitary map. Objects interpret types of the reversible language Π of bijections, and morphisms interpret terms. The category C is a monoidal inverse category.
The category C carries an arrow, where A(X, Y ) is the disjoint union of hom(X× H, Y × G) where G and H range over all objects, and morphisms X × H → Y × G and X × Hj → Y × Gj are identified when they are equal up to coherence isomorphisms. This is an inverse arrow, where inv(a) is simply a†. It supports the following additional operations:
erase	= [ πH : X × H → H ]  ∈ A(X , 1),
createX = [ π† : H → X × H ]  ∈ A(1, X ).
James and Sabry show how a simply-typed first order functional irreversible lan- guage translates into a reversible one by using this inverse arrow to build implicit communication with a global heap H and garbage dump G.
Example 3.7 (Reversible state) Perhaps the prototypical example of an effect is computation with a mutable store of type S. In the irreversible case, such computations are performed using the state monad State S X = S ( (X ⊗ S ), where S ( − is the right adjoint to −⊗ S, and can be thought of as a function type. Morphisms in the corresponding Kleisli category are morphisms of the form X → S ( (Y ⊗S) in the ambient monoidal closed category. In this formulation, the current state is fetched by get : State S S defined as get s = (s, s), while the state is (destructively) updated by put : S → State S 1 defined as put x s = ((), x ).
Such arrows can not be used as-is in inverse categories, however, as canonical examples (such as PInj) fail to be monoidal closed. To get around this, note that it follows from monoidal closure that hom(X, S ( (Y ⊗ S))  hom(X ⊗ S, Y ⊗ S), so that hom(−⊗ S, −⊗ S) is an equivalent arrow that does not depend on closure. With this is mind, we define the reversible state arrow with a store of type S:
type RState S X Y = X ⊗ S ↔ Y ⊗ S
instance Arrow (RState S ) where arr f (x , s)	= (f x, s)
(a >>> b) (x , s) = b (a (x , s))
ﬁrst a ((x , z ), s)= let (x j, sj)= a (x , s) in ((x j, z ), sj)
instance InverseArrow (RState S ) where inv a (y, s)= a† (y, s)
This satisfies the inverse arrow laws. To access the state, we use reversible duplica- tion of values (categorically, this requires the monoidal product to have a natural

diagonal ΔX : X → X ⊗X, as inverse products do). Syntactically, this corresponds to the following arrow:
get	: RState S X (X ⊗ S ) get (x , s)= ((x , s), s)
The inverse to this arrow is assert : RState S (X ⊗ S ) X , which asserts that the current state is precisely what is given in its second input component; if this fails, the result is undefined. For changing the state, while we cannot destructively update it reversibly, we can reversibly update it by a given reversible function with signature S ↔ S. This gives:
update	: (S ↔ S ) → RState S X X update f (x , s)= (x , f s)
This is analogous to how variable assignment works in the reversible programming language Janus [35]: Since destructive updating is not permitted, state is updated by means of built-in reversible update operators, e.g., updating a variable by adding a constant or the contents of another variable to it, etc.
Example 3.8 (Computation in context) Related to computation with a mutable store is computation with an immutable one; that is, computation within a larger context that remains invariant across execution. In an irreversible setting, this job is typically handled by the reader monad (with context of type C), defined as Reader C X = C ⇒ X . This approach is fundamentally irreversible, however, as the context is “forgotten” whenever a value is computed by supplying it with a context. Even further, it relies on the reversibly problematic notion of monoidal closure.
A reversible version of this idea is one that remembers the context, giving us the reversible Reader arrow:
type Reader C X Y = X ⊗ C ↔ Y ⊗ C
This is precisely the same as the state arrow – indeed, the instance declarations for arr , (>>>), ﬁrst , and inv are the same – save for the fact that we additionally require all Reader arrows r to satisfy c = cj whenever r (x , c) = (y, cj). We notice that arr f satisfies this property for all f , whereas (>>>), ﬁrst , and inv all preserve it. This resembles the “slice” construction on inverse categories with inverse products; see [11, Sec. 4.4].
As such, while we can provide access to the context via a function defined exactly as get for the reversible state arrow, we cannot provide an update function without (potentially) breaking this property – as intended. In practice, the property that the context is invariant across execution can be aided by appropriate interface hiding,
i.e. exposing the Reader type and appropriate instance declarations and helpers (such as get and assert ) but leaving the constructor for Reader arrows hidden.

Example 3.9 (Rewriter) A particularly useful special case of the reversible state arrow is when the store S forms a group. While group multiplication if seen as a function G ⊗ G ↔ G is invertible only in degenerate cases, we can use parametriza- tion to fix the first argument of the multiplication, giving it a much more reasonable signature of G → (G ↔ G ). In this way, groups can be expressed as instances of the type class
class Group G where
gunit : G
gmul : G → (G ↔ G ) ginv : G ↔ G
subject to the usual group axioms. This gives us an arrow of the form
type Rewriter G X Y = X ⊗ G ↔ Y ⊗ G

with instance declarations identical to that of RState G , save that we require G to be an instance of the Group type class. With this, adding or removing elements from state of type G can then be performed by
rewrite	: G → Rewriter G X X rewrite a (x , b)= (x , gmul a b)

which “rewrites” the state by the value a of type G. Note that while the name of this arrow was chosen to be evocative of the Writer monad known from irreversible functional programming, as it may be used for similar practical purposes, its con- struction is substantially different (i.e., irreversible Writer arrows are maps of the form X → Y × M where M is a monoid).
Example 3.10 (Vector transformation) Vector transformations, that is, functions on lists that preserve the length of the list, form another example of inverse arrows. The Vector arrow is defined as follows:
type Vector X Y = [X ] ↔ [Y ]
instance Arrow (Vector ) where
arr f xs	= map f xs
(a >>> b) xs = b (a xs)
ﬁrst a ps	= let (xs, zs) = zip† ps in zip (a xs, zs)
instance InverseArrow (Vector ) where
inv a ys = a† ys

The definition of ﬁrst relies on the usual map and zip functions, which are defined as follows:



map	:  (a ↔ b) → ([a] ↔ [b])
map f []	= []
map f (x ::xs)= (f x )::(map f xs)
zip	: ([a], [b]) ↔ [(a, b)]
zip ([], [])	= []
zip (x ::xs, y ::ys)= (x , y )::(zip (xs, ys))

Notice that preservation of length is required for ﬁrst to work: if the arrow a does not preserve the length of xs, then zip (a xs, zs) is undefined. However, since arr lifts a pure function f to a map (which preserves length), and (>>>) and inv are given by the usual composition and inversion, the interface maintains this property.
Example 3.11 (Reversible error handling) An inverse weak arrow comes from re- versible computation with a possibility for failure. The weak Error arrow is defined using disjointness tensors as follows:
type Error E X Y = X ⊕ E ↔ Y ⊕ E
instance WeakArrow (Error E ) where arr f (InL x ) = InL (f x )
arr f (InR e)= InR e
(a >>> b) x	= b (a x )
instance InverseWeakArrow (Error E ) where inv a y = a† y
In this definition, we think of the type E as the type of errors that could occur during computation. As such, a pure function f lifts to a weak arrow which always succeeds with value f (x) when given a nonerroneous input of x, and always propagates errors that may have occured previously.
Raising an error reversibly requires more work than in the irreversible case, as the effectful program that produces an error must be able to recover from it in the converse direction. In this way, a reversible raise requires two pieces of data: a function of type X ↔ E that transforms problematic inputs into appropriate errors; and a choice function of type E ↔ E ⊕ E that decides if the error came from this site, injecting it to the left if it did, and to the right if it did not. The latter choice function is critical, as in the converse direction it decides whether the error should be handled immediately or later. Thus we define raise as follows:
raise	: (X ↔ E ) → (E ↔ E ⊕ E ) → Error E X Y raise f p x = InR (p† (arr f x )))
The converse of raise is handle, an (unconditional) error handler that maps match- ing errors back to succesful output values. Since unconditional error handling is seldom required, this can be combined with control flow (see Example 3.15) to perform conditional error handling, i.e. to only handle errors if they occur.
Example 3.12 (Serialization) When restricting our attention, as we do here, to only first-order reversible functional programming languages, another example of

inverse arrows arises in the form of serializers. A serializer is a function that trans- forms an internal data representation into one more suitable for storage, or for transmission to other running processes. To transform serialized data back into an internal representation, a suitable deserializer is used.
When restricting ourselves to the first-order case, it seems reasonable to assume that all types are serializable, as we thus avoid the problematic case of how to serialize data of function type. As such, assuming that all types X admit a function serialize : X ↔ Serialized X (where Serialized X is the type of serializations of data of type X), we define the Serializer arrow as follows:
type Serializer X Y = X ↔ Serialized Y
instance Arrow (Serializer ) where
arr f x	= serialize (f x )
(a >>> b) x = b (serialize† (a x ))
ﬁrst a (x , z )= serialize (serialize† (a x ), z )
instance InverseArrow (Serializer ) where
inv a y = serialize (a† (serialize y ))
Notice how serialize† : Serialized X ↔ X takes the role of a (partial) deserializer, able to recover the internal representation from serialized data as produced by the serializer. A deserializer of the form serialize† will often only be partially defined, since many serialization methods allow many different serialized representations of the same data (for example, many textual serialization formats are whitespace insensitive). In spite of this shortcoming, partial deserializers produced by inverting serializers are sufficient for the above definition to satisfy the inverse arrow laws.
Example 3.13 (Dagger Frobenius monads) Monads are also often used to capture computational side-effects. Arrows are more general. If T is a strong monad, then A = hom(−,T (+)) is an arrow: arr is given by the unit, >>> is given by Kleisli composition, and first is given by the strength maps. What happens when the base category is a dagger or inverse category modelling reversible pure functions?
A monad T on a dagger category is a dagger Frobenius monad when it satisfies
T (f†) = T (f )† and T (μX ) ◦ μ†	= μT (X) ◦ T (μ† ). The Kleisli category of such
a monad is again a dagger category [15, Lemma 6.1], giving rise to an operation inv satisfying (9)–(10). A dagger Frobenius monad is strong when the strength maps are unitary. In this case (11)–(12) also follow. If the underlying category is an inverse category, then μ ◦ μ† ◦ μ = μ, whence μ ◦ μ† = id, and (13)–(14) follow. Thus, if T is a strong dagger Frobenius monad on a dagger/inverse category, then A is a dagger/inverse arrow. The Frobenius monad T (X)= X ⊗ C2 on the category of Hilbert spaces captures measurement in quantum computation [14], giving a good example of capturing an irreversible effect in a reversible setting. For more examples see [15].
Example 3.14 (Restriction monads) There is a notion in between the dagger and inverse arrows of the previous example. A (strong) restriction monad is a (strong)

monad on a (monoidal) restriction category whose underlying endofunctor is a re- striction functor. The Kleisli-category of a restriction monad T has a natural re- striction structure: just define the restriction of f : X → T (Y ) to be ηX ◦ f¯. The
functors between the base category and the Kleisli category then become restriction functors. If T is a strong restriction monad on a monoidal restriction category C, then Inv(C) has an inverse arrow (X, Y ) '→ (Inv(Kl(T )))(X, Y ).
Example 3.15 (Control flow) While only trivial inverse categories have coprod- ucts [11], less structure suffices for reversible control structures. When the do- main and codomain of an inverse arrow both have disjointness tensors (see Defi- nition 2.4), it can often be used to implement ArrowChoice. For a simple exam- ple, the pure arrow on an inverse category with disjointness tensors implements left : AX Y → A (X ⊕ Z ) (Y ⊕ Z ) as
left f (x , z ) = (f x, z )
The laws of ArrowChoice [16] simply reduce to −⊕− being a bifunctor with natural quasi-injections. More generally, the laws amount to preservation of the disjointness tensor. For the reversible state arrow (Example 3.7), this hinges on ⊗ distributing over ⊕.
The splitting combinator (+++) is unproblematic for reversiblity, but the fan- in combinator (|||) cannot be defined reversibly, as it explicitly deletes information about which branch was chosen. Reversible conditionals thus require two predicates: one determining the branch to take, and one asserted to join the branches after execution. The branch-joining predicate must be chosen carefully to ensure that it is always true after the then-branch, and false after the else-branch. This is a standard way of handling branch joining reversibly [35,34,12].
Example 3.16 (Superoperators) Quantum information theory has to deal with en- vironments. The basic category FHilb is that of finite-dimensional Hilbert spaces and linear maps. But because a system may be entangled with its environment, the only morphisms that preserve states are the so-called superoperators, or completely positive maps [31,7]: they are not just positive, but stay positive when tensored with an arbitrary ancillary object. In a sense, information about the system may be stored in the environment without breaking the (reversible) laws of nature. This leads to the so-called CPM construction. It is infamously known not to be a monad. But it is a dagger arrow on FHilb, where A X Y is the set of completely positive maps X∗ ⊗ X → Y ∗ ⊗ Y , arr f = f∗ ⊗ f , a >>> b = b ◦ a, firstX,Y,Z a = a ⊗ idZ∗⊗Z , and inv a = a†.
Aside from these, other examples do fit the interface of inverse arrows, though they are less syntactically interesting as they must essentially be “built in” to a particular programming language. These include reversible IO, which functions very similarly to irreversible IO, and reversible recursion, which could be used to give a type-level separation between terminating and potentially non-terminating functions, by only allowing fixed points of parametrized functions between arrows rather than between (pure) functions.

Inverse arrows, categorically
This section explicates the categorical structure of inverse arrows. Arrows on C can be modelled categorically as monoids in the functor category [Cop × C, Set] [18]. They also correspond to certain identity-on-objects functors J : C → D. The cate- gory D for an arrow A is built by D(X, Y )= A X Y , and arr provides the functor
J . We will only consider the multiplicative fragment. The operation first can be incorporated in a standard way using strength [18,3], and poses no added difficulty in the reversible setting.
Clearly, dagger arrows correspond to D being a dagger category and J a dagger functor, whereas inverse arrows correspond to both C and D being inverse cate- gories and J a (dagger) functor. This section takes the first point of view: which monoids correspond to dagger arrows and inverse arrows? In the dagger case, the answer is quite simple: the dagger makes [Cop × C, Set] into an involutive monoidal category, and then dagger arrows correspond to involutive monoids. Inverse arrows furthermore require certain diagrams to commute.
Definition 4.1 An involutive monoidal category is a monoidal category C equipped with an involution: a functor ( ): C → C satisfying f = f for all morphisms f , together with a natural isomorphism χX,Y : X ⊗ Y → Y ⊗ X that makes the following diagrams commute 4 :
α	
				
X ⊗ (Y ⊗ Z)	(X ⊗ Y ) ⊗ Z
χ		


id ⊗ χ
χ ⊗ id
X ⊗ Y	Y ⊗ X

X ⊗ Z ⊗ Y	Y ⊗ X ⊗ Z	id

α 


(Z ⊗ Y ) ⊗ X
 χ

α	Z ⊗ (Y ⊗ X)
X ⊗ Y


id	X ⊗ Y

Just like monoidal categories are the natural setting for monoids, involutive monoidal categories are the natural setting for involutive monoids. Any involutive monoidal category has a canonical isomorphism φ : I → I [9, Lemma 2.3]:

ρ −1	χ−1	ρ
I	I,I			I
I = I	I ⊗ I  I ⊗ I = I ⊗ I	I

Moreover, any monoid M with multiplication m and unit u induces a monoid on M with multiplication m ◦ χM,M and unit u ◦ φ. This monoid structure on M allows us to define involutive monoids.
Definition 4.2 An involutive monoid is a monoid (M, m, u) together with a monoid homomorphism i : M → M satisfying i ◦ i = id. A morphism of involutive monoids



4 There is a more general definition allowing a natural isomorphism X → X (see [9] for details), but we only need the strict case.

is a monoid homomorphism f : M → N making the following diagram commute:

f	
M	N
iM	iN
M	N
f

Our next result lifts the dagger on C to an involution on the category [Cop × C, Set] of profunctors. First we recall the monoidal structure on that category. It categorifies the dagger monoidal category Rel of relations of Section 2 [5].
Definition 4.3 If C is small, then [Cop × C, Set] has a monoidal structure
Y
F ⊗ G(X, Z)=	F (X, Y ) × G(Y, Z);

concretely, F ⊗ G(X, Z) =  Y ∈C F (X, Y ) × G(Y, Z)/ ≈, where ≈ is the equiv- alence relation generated by (y, F (f, id)(x)) ≈ (G(id,f )(y), x), and the action on morphisms is given by F ⊗ G(f, g) := [y, x]≈ '→ [F (f, id)x, G(id, g)y]. The unit of the tensor product is homC.
Proposition 4.4 If C is a dagger category, then [Cop × C, Set] is an involutive

monoidal category when one
deﬁnes
the involution on objects F by F (X, Y ) =

F (Y, X), F (f, g)= F (g†,f†) and on morphisms τ : F → G by τ X,Y = τY,X.

Proof. First observe that ( ) is well-defined: For any natural transformation of profunctors τ , τ is natural, and τ '→ τ is functorial. Define χF,G by the following composite of natural isomorphisms:
F ⊗ G(X, Z) ∼=	Y F (X, Y ) × G(Y, Z) by definition of ⊗

=	Y F (Y, X) × G(Z, Y ) by definition of ( ) 
∼=	Y G(Z, Y ) × F (Y, X) by symmetry of ×
∼= G ⊗ F (Z, X) by definition of ⊗

= G ⊗ F (X, Z) by definition of ( ) 
Checking that χ make the relevant diagrams commute is routine.	2
Theorem 4.5 If C is a dagger category, the multiplicative fragments of dagger arrows on C correspond exactly to involutive monoids in [Cop × C, Set].
Proof. It suffices to show that the dagger on an arrow corresponds to an involution on the corresponding monoid F . But this is easy: an involution on F corresponds to giving, for each X, Y a map F (X, Y ) → F (Y, X) subject to some axioms. That this involution is a monoid homomorphism amounts to it being a contravariant identity-on-objects-functor, and the other axiom amounts to it being involutive. 2

Remark 4.6 If the operation first is modeled categorically as (internal) strength, axiom (12) for dagger arrows can be phrased in [Cop × C, Set] as follows: for each object Z of C, and each dagger arrow M , the profunctor MZ = M ((−)⊗Z, (+)⊗Z) is also a dagger arrow, and first−,+,Z is a natural transformation M ⇒ MZ. The arrow laws (7) and (8) imply that it is a monoid homomorphism, and the new axiom just states that it is in fact a homomorphism of involutive monoids. For inverse arrows this law is not needed, as any functor between inverse categories is automatically a dagger functor and thus every monoid homomorphism between monoids corresponding to inverse arrows preserves the involution.
Next we set out to characterize which involutive monoids correspond to inverse arrows. Given an involutive monoid M , the obvious approach would be to just state that the map M → M defined by a '→ a ◦ a† ◦ a is the identity. However, there is a catch: for an arbitrary involutive monoid, the map a '→ a ◦ a† ◦ a is not natural transformation and therefore not a morphism in [Cop × C, Set]. To circumvent this, we first require some conditions guaranteeing naturality. These conditions concern endomorphisms, and to discuss them we introduce an auxiliary operation on [Cop × C, Set].
Definition 4.7 Let C be a dagger category. Given a profunctor M : Cop × C →
Set, define LM : Cop × C → Set by
LM (X, Y )= M (X, X),
LM (f, g)= f† ◦ (−) ◦ f .
If M is an involutive monoid in [Cop × C, Set], define a subprofunctor of LM : L+M (X, Y )= {a† ◦ a ∈ M (X, X) | a ∈ M (X, Z) for some Z}.
Remark 4.8 The construction L is a functor [Cop × C, Set] → [Cop × C, Set]. There is an analogous construction RM (X, Y )= M (Y, Y ) and R+M , and further- more RM = LM . For any monoid M in [Cop × C, Set], LM is a right M -module (and RM a left M -module). Compare Example 3.16.
For the rest of this section, assume the base category C to be an inverse cate- gory. This lets us multiply positive arrows by positive pure morphisms. If M is an involutive monoid in [Cop × C, Set], then the map LM ×L+(homC) → LM defined by (a, g† ◦ g) '→ a ◦ g† ◦ g is natural:
LM × L+(hom)(f, idY )(a, g† ◦ g)
= (f† ◦ a ◦ f, f† ◦ g† ◦ g ◦ f )
'→ f† ◦ a ◦ f ◦ f† ◦ g† ◦ g ◦ f
= f† ◦ a ◦ g† ◦ g ◦ f ◦ f† ◦ f	because C is an inverse category
= f† ◦ a ◦ g† ◦ g ◦ f	because C is an inverse category
= LM (f, idY )(a ◦ g† ◦ g)

Similarly there is a map L+(hom) ×LM → LM defined by (g† ◦g, a) '→ g† ◦g◦a. Now the category corresponding to M satisfies a† ◦ a ◦ g† ◦ g = g† ◦ g ◦ a† ◦ a for all a and pure g if and only if the following diagram commutes:



L+M × L+(hom)	LM × L+(hom)
σ 
L+(hom) × L+M	L+(hom) × LM	LM

(15)



If this is satisfied for an involutive monoid M in [Cop × C, Set], then positive arrows multiply. In other words, the map L+M × L+M → LM defined by (a† ◦ a, b† ◦ b) '→ a† ◦ a ◦ b† ◦ b is natural:


DM (f, g)(a, a†, a)
= (g ◦ a ◦ f, f† ◦ a† ◦ g†,g ◦ a ◦ f )
'→ g ◦ a ◦ f ◦ f† ◦ a† ◦ g† ◦ g ◦ a ◦ f
= g ◦ a ◦ a† ◦ g† ◦ g ◦ a ◦ f ◦ f† ◦ f	by (15)
= g ◦ a ◦ a† ◦ g† ◦ g ◦ a ◦ f	because C is an inverse category
= g ◦ g† ◦ g ◦ a ◦ a† ◦ a ◦ f	by (15)
= g ◦ a ◦ a† ◦ a ◦ f	because C is an inverse category
= M (f, g)(a ◦ a† ◦ a)


This multiplication is commutative iff the following diagram commutes:


L+M × L+M
σ	L+M × L+M LM


(16)



Finally, let DM ‹→ M × M × M be the diagonal DM (X, Y ) = {(a, a†, a) | a ∈
M (X, Y )}.
If M satisfies (15), then the map DM → M defined by (a, a†, a) '→ a ◦ a† ◦ a is natural:



DM (f, g)(a, a†, a)
= (g ◦ a ◦ f, f† ◦ a† ◦ g†,g ◦ a ◦ f )
'→ g ◦ a ◦ f ◦ f† ◦ a† ◦ g† ◦ g ◦ a ◦ f
= g ◦ a ◦ a† ◦ g† ◦ g ◦ a ◦ f ◦ f† ◦ f	by (15)
= g ◦ a ◦ a† ◦ g† ◦ g ◦ a ◦ f	because C is an inverse category
= g ◦ g† ◦ g ◦ a ◦ a† ◦ a ◦ f	by (15)
= g ◦ a ◦ a† ◦ a ◦ f	because C is an inverse category
= M (f, g)(a ◦ a† ◦ a)
Thus M satisfies a ◦ a† ◦ a = a if and only if the following diagram commutes:


M	DM
 
M

(17)

Hence we have established the following theorem.
Theorem 4.9 Let C be an inverse category. Then the multiplicative fragments of inverse arrows on C correspond exactly to involutive monoids in [Cop × C, Set] making the diagrams (15)–(17) commute.	2

Applications and related work
As we have seen, inverse arrows capture a variety of fundamental reversible effects. An immediate application of our results would be to retrofit existing typed re- versible functional programming languages (e.g., Theseus [20]) with inverse arrows to accommodate reversible effects while maintaining a type-level separation between pure and effectful programs. Another approach could be to design entirely new such programming languages, taking inverse arrows as the fundamental representation of reversible effects. While the Haskell approach to arrows uses typeclasses [16], these are not a priori necessary to reap the benefits of inverse arrows. For example, special syntax for defining inverse arrows could also be used, either explicitly, or implicitly by means of an effect system that uses inverse arrows “under the hood”. To aid programming with ordinary arrows, a handy notation due to Pater- son [27,28] may be used. The simplest form of this notation is based on process
combinators, the central one being


p → e1

≺ e2
= ⎧⎨ arr (λp.e2) >>> e1	if p is fresh for e1,
⎩ arr (λp.(e1, e2)) >>> app	otherwise.

Note that if the second branch is used, the arrow must additionally be an instance of ArrowApply (so that it is, in fact, a monad). Though we only know of degen- erate examples where inverse arrows are instances of ArrowApply , this definition is conceptually unproblematic (from the point of view of guaranteeing reversibility) so long as the pure function λp.e2 is first-order and reversible. A more advanced style of this notation is the do-notation for arrows, which additionally relies on the arrow combinator
bind	: AX Y → A (X ⊗ Y ) Z → AX Z f jbindj g = (arr (id ) &&& f ) >>> g .

If the underlying monoidal dagger category has natural coassociative diagonals, for example when it has inverse products, this combinator does exist: the arrow combinator (&&&) can be defined as
(&&&)	: AX Y → AX Z → AX (Y ⊗ Z )
f &&& g = arr (copy ) >>> ﬁrst (f ) >>> second (g )
where copy : X →X ⊗X is the natural diagonal (given in pseudocode by copy x = (x , x )), and the combinator second is derived from ﬁrst in the usual way, i.e., as
second	: AX Y → A (Z ⊗ X ) (Z ⊗ Y )
second f = arr (swap) >>> ﬁrst (f ) >>> arr (swap)
with swap : X ⊗ Y ↔ Y ⊗ X given by swap (x , y ) = (y, x ). This allows do-notation of the form
do {p → c ; A} ≡ c jbindj (κp. do {A}),
so soon as the κ-calculus [13] expression κp. do {A} is reversible. Note, however, that do-expressions of the form do {c ; A} (i.e., where the output of c is dis- carded entirely) will fail to be reversible in all but the most trivial cases. Since do {p → c ; A} produces a value of an inverse arrow type, closure under program inversion provides a program we might call
undo {p → c ; A} ≡ inv (do {p → c ; A}) .
Inverse arrow law (13) then guarantees that doing, then undoing, and then doing the same operation is the same as doing it once.
A pleasant consequence of the semantics of inverse arrows is that inverse arrows are safe: as long as the inverse arrow laws are satisfied, fundamental properties guaranteed by reversible functional programming languages (such as invertibility and closure under program inversion) are preserved. In this way, inverse arrows provide reversible effects as a conservative extension to pure reversible functional programming.

A similar approach to invertibility using arrows is given by bidirectional ar- rows [2]. However, while the goal of inverse arrows is to add effects to already invertible languages, bidirectional arrows arise as a means to add invertibility to an otherwise uninvertible language. As such, bidirectional arrows have different con- cerns than inverse arrows, and notably do not guarantee invertibility in the general case.
Acknowledgements
This work was supported by COST Action IC1405, the Oskar Huttunen Foundation, and EPSRC Fellowship EP/L002388/1. We thank Robert Furber and Robert Glu¨ck for discussions.

References
S. Abramsky. A structural approach to reversible computation. Theoretical Computer Science, 347(3):441–464, 2005.
A. Alimarine, S. Smetsers, A. van Weelden, M. van Eekelen, and R. Plasmeijer. There and back again: Arrows for invertible programming. In Proceedings of the 2005 ACM SIGPLAN workshop on Haskell, pages 86–97, 2005.
K. Asada. Arrows are strong monads. In Proceedings of the third ACM SIGPLAN workshop on Mathematically Structured Functional Programming, pages 33–42. ACM, 2010.
C. H. Bennett. Logical reversibility of computation. IBM Journal of Research and Development, 17(6):525–532, 1973.
F. Borceux. Handbook of categorical algebra. Cambridge University Press, 1994.
J. R. B. Cockett and S. Lack. Restriction categories I: categories of partial maps. Theoretical Computer Science, 270:223–259, 2002.
B. Coecke and C. Heunen. Pictures of complete positivity in arbitrary dimension. Information and Computation, 250:50–58, 2016.
I. Cristescu, J. Krivine, and D. Varacca. A compositional semantics for the reversible π-calculus. In
Logic in Computer Science, pages 388–397. IEEE Computer Society, 2013.
J. M. Egger. On involutive monoidal categories. Theory and Applications of Categories, 25(14):368– 393, 2011.
M. J. Gabbay and P. H. Kropholler. Imaginary groups: lazy monoids and reversible computation.
Mathematical Structures in Computer Science, 23(5):1002–10031, 2013.
B. G. Giles. An investigation of some theoretical aspects of reversible computing. PhD thesis, University of Calgary, 2014.
R. Glu¨ck and R. Kaarsgaard. A categorical foundations for structured reversible flowchart languages. In Mathematical Foundations of Program Semantics XXXIII, Proceedings, 2017. to appear.
M. Hasegawa. Decomposing typed lambda calculus into a couple of categorical programming languages. In D. Pitt, D. E. Rydeheard, and P. Johnstone, editors, Category Theory and Computer Science, volume 953 of Lecture Notes in Computer Science, pages 200–219. Springer, 1995.
C. Heunen and M. Karvonen. Reversible monadic computing. In Mathematical Foundations of Programming Semantics (MFPS), volume 319 of Electronic Notes in Theoretical Computer Science, pages 217–237, 2015.
C. Heunen and M. Karvonen. Monads on dagger categories. Theory and Applications of Categories, 31(35):1016–1043, 2016.
J. Hughes. Generalising monads to arrows. Science of Computer Programming, 37:67–111, 2000.
J. Hughes. Advanced Functional Programming, volume 3622 of Lecture Notes in Computer Science, chapter Programming with Arrows, pages 73–129. Springer, 2005.

B. Jacobs, C. Heunen, and I. Hasuo. Categorical semantics for arrows. Journal of Functional Programming, 19(3-4):403–438, 2009.
R. P. James and A. Sabry. Information effects. In Principles of Programming Languages, pages 73–84. ACM, 2012.
R. P. James and A. Sabry. Theseus: A high level language for reversible computing, 2014. Work-in- progress report at RC 2014, available at https://www.cs.indiana.edu/~sabry/papers/theseus.pdf.
R. Kaarsgaard, H. B. Axelsen, and R. Glu¨ck. Join inverse categories and reversible recursion. Journal of Logical and Algebraic Methods in Programming, 87, 2017.
R. Kaarsgaard and M. K. Thomsen. Rfun revisited. In M. Wald´en, editor, Proceedings of the 29th Nordic Workshop on Programming Theory, volume 27 of TUCS Lecture Notes, pages 65–67. Turku Centre for Computer Science, 2017.
M. Kawabe and R. Glu¨ck. The program inverter lrinv and its structure. In M. V. Hermenegildo and D. Cabeza, editors, Practical Aspects of Declarative Languages, volume 3350 of Lecture Notes in Computer Science, pages 219–234. Springer, 2005.
M. Kutrib and M. Wendlandt. Reversible limited automata. In Machines, Computations and Universality, volume 9288 of Lecture Notes in Computer Science, pages 113–128, 2015.
E. Moggi. Computational lambda-calculus and monads. Logic in Computer Science, 1989.
K. Morita. Two-way reversible multihead automata. Fundamenta Informaticae, 110(1–4):241–254, 2011.
R. Paterson. A new notation for arrows. In International Conference on Functional Programming, pages 229–240, 2001.
R. Paterson. Arrows and computation. In J. Gibbons and O. de Moor, editors, The Fun of Programming, pages 201–222. Palgrave, 2003.
M. Schordan, D. Jefferson, P. Barnes, T. Oppelstrup, and D. Quinlan. Reverse code generation for parallel discrete event simulation. In Reversible Computing, volume 9138 of Lecture Notes in Computer Science, pages 95–110. Springer, 2015.
U. P. Schultz, M. Bordignon, and K. Støy. Robust and reversible execution of self-reconfiguration sequences. Robotica, 29(1):35–37, 2011.
P. Selinger. Dagger compact closed categories and completely positive maps. In Quantum Programming Languages, volume 170 of Electronic Notes in Theoretical Computer Science, pages 139–163. Elsevier, 2007.
B. Stoddart and R. Lynas. A virtual machine for supporting reversible probabilistic guarded command languages. In Reversible Computing, volume 253 of Electronic Notes in Theoretical Computer Science, pages 33–56. Elsevier, 2010.
T. Toffoli. Reversible computing. In International Colloquium on Automata, Languages and Programming, pages 632–644, 1980.
T. Yokoyama, H. B. Axelsen, and R. Glu¨ck. Towards a reversible functional language. In A. De Vos and R. Wille, editors, Reversible Computation 2011, volume 7165 of LNCS, pages 14–29. Springer, 2012.
T. Yokoyama and R. Glu¨ck. A reversible programming language and its invertible self-interpreter. In Partial Evaluation and Semantics-Based Program Manipulation. Proceedings, pages 144–153. ACM Press, 2007.
