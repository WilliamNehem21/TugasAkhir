Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 354 (2020) 107–127
www.elsevier.com/locate/entcs


On Interactive Proof-Search for Constructive Modal Necessity
Favio E. Miranda-Perea2 Lourdes del Carmen González Huesca1
P. Selene Linares-Arévalo3
Departamento de Matemáticas, Facultad de Ciencias UNAM, Circuito Exterior S/N,
Cd. Universitaria 04510, CdMx, México

Abstract
We present a dual sequent calculus for the necessity fragment of the constructive modal logic S4 and show its adequacy for proof-search in the style of modern interactive theorem provers. The main feature of dual systems is the use of two contexts to capture the notions of true and valid formulas, without using any formal semantics. This attribute allows us to give simple rules for the operator that, most of the time, grant the substitution of a strict modal reasoning by a pure propositional one, thus simplifying the proof- search process. Moreover, we introduce a formal notion of backward proof corresponding to a bottom-up construction of a derivation tree by means of a left-to-right depth-first proof-search.
Keywords: constructive modal logic, proof-search, necessity, sequent calculus


Introduction
Modal logics play an important role in several areas of Computer Science and Phi- losophy. For instance, various type systems for concurrent and distributed compu- tations [12,15] employ modalities and a modal lambda calculus has been proposed to model information flow in computer networks [4]. In Artificial Intelligence (AI) they are useful to model knowledge structures among agents, ontologies or the behaviour of computer systems. These and other applications oblige to design effective and simple to use procedures for proof search in modal logics. However, the existing processes are quite sophisticated, for instance [17,1], and machine-oriented in the sense that their inference rules deviate from the natural human reasoning, for they

1 Email: luglzhuesca@ciencias.unam.mx
2 Email: favio@ciencias.unam.mx
3 Email: selene_linares@ciencias.unam.mx

https://doi.org/10.1016/j.entcs.2020.10.009
1571-0661/© 2020 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

are or intend to be fully automated, like the bidirectional approach of [10]. This makes the modelling of actual arguments involving modal reasoning difficult. Such arguments arise for instance in AI, while verifying an agent-based computer system; or in Philosophy, in the representation of concrete cases in modal argumentation theory, where the 2 operator usually represents the argument attack relation [3,8]. In this paper we walk in the opposite direction by proposing a sequent calculus adequate for proof-search but in an interactive style, as is understood and imple- mented in modern proof-assistants like Coq. This means that the proof-search is driven by the human agent: the process starts with the desired sequent S; if it is suitable as a conclusion of some rule, then the process continues with the premises of this rule. If at the end all branches of this search end in an axiom or initial rule, the procedure is succesful. The purpose of this work is to give a precise formal definition of this process and to prove its equivalence with the usual forward proof
construction in the case of constructive modal logic S4 for necessity.


A Dual Sequent Calculus for Necessity
The formal system GS4 hereby considered is a sequent calculus whose foundations come from the analysis of Martin-Löf [13]. Propositions are analysed judgmentally without any semantic label (worlds). In the specific case of modal connectives by means of judgments over propositions. The notion of so-called hypothetical judgments is extended to categorical judgment where a conclusion does not depend on hypotheses about the constructive truth of propositions. Hence, a distinction of two forms of primitive judgments is essential: ‘A true’ means that we know how to verify A under hypothetical judgments, whereas ‘A valid’ represents the fact that A is a proposition whose truth does not depend on any hypotheses, thus internalizing a categorical judgment as a proposition syntactically represented by the modal formula 2A.
The system is called dual for it handles sequents with two separate contexts of the form Δ|Γ ▶ A. We choose to implement such contexts by means of two disjoint lists (instead of sets or multisets), Δ for valid and Γ for true hypotheses. This choice allows us to omit the labels valid, true in context formulae, contrary to Pfenning and Davies [16]. A similar separation is present in several works: for instance the systems of Fitting [6] use global and local assumptions or the work of Avron et al. [2] which discusses modal logic encodings by using separate consequence relations (semantical and deductive) related to classical validity and truth. The idea behind the context separation in GS4 is that formulae in Δ are modal (i.e. boxed formulae), whereas those in Γ are propositional. Nevertheless, like the intuitive semantic qualifiers, this idea does not represent a syntactic restriction, we can have arbitrary formulae in both contexts. Moreover, the succedent of a sequent only considers true propositions, there is no need to consider valid conclusions explicitly as they are represented by the formula 2A.
For the sake of self-containment let us briefly review the elements of our syntax.

Modal formulae are generated by the following grammar:
A, B ::= pn | A → B | A ∧ B | A 𝖵 B | 2A
where pn denotes an element taken from an infinite supply of propositional vari- ables, indexed by a natural number. Let us also note that we do not consider neither negation nor the constant ⊥. Therefore we will be dealing with minimal propositional logic [18] extended with the necessity operator. A particular modal logic is generated by adding suitable axioms. It is important to remark that the logic here discussed is called constructive due to the approach of Martin-Löf but also to distinguish it from both, the classical modal logics where the 2 operator obeys the axiom 2A ↔ ¬ ¬A and the intuitionistic modal logics which include the axiom ¬ ⊥. In contrast, in the constructive modal logic S4 the above axioms are omitted and both modalities are primitive. Our work only considers the necessity modality 2.
Contexts are implemented by means of so-called snoc lists:
Γ, Δ ::= · | Γ,A 
These are finite lists built from the empty list, denoted here by ·, and a constructor that generates a new list from a given one by adding a new element to its right-end. The constructor called snoc is denoted by a comma. Therefore Γ,A is the context obtained by adding A after the last element in Γ. This constructor is opposed to the traditional cons operation, predefined in functional languages, which adds elements at the left-end of the list 4 . The snoc lists provide a formalization akin to the usual practice in computer science logic where the last context formula is the one introduced or discharged to prove an implication.
The concatenation operation is inductively defined in the obvious way and denoted by Γ1; Γ2. Also, whenever we write Γ, A; Γ' it means (Γ, A); Γ', that is, the formula A is associated to the left context. This should be clear, for the expression Γ, (A; Γ') is ill-formed.
The system GS4 is defined by the following inference rules:
Starting rules



Right rules
Δ|Γ, A; Γ' ▶ A (Thyp)


Δ|Γ,A ▶ B

Δ|Γ ▶ A → B (→ R)
Δ, A; Δ'|Γ ▶ A (Vhyp)


Δ|Γ ▶ A	Δ|Γ ▶ B

Δ|Γ ▶ A ∧ B	(∧ R)



Δ|Γ ▶ A
Δ|Γ ▶ A 𝖵 B (∨ R)
Δ|Γ ▶ B
Δ|Γ ▶ A 𝖵 B (∨ R)
Δ|· ▶ A
Δ|Γ ▶ 2A (2 R)



4 The name cons is for constructor and note that snoc is the backward reading of cons.

Left rules for truth contexts.
Δ|Γ, A; Γ' ▶ C	Δ|Γ, B; Γ' ▶ C

Δ|Γ,A 𝖵 B; Γ' ▶ C	(∨ L)
Δ|Γ,A → B; Γ' ▶ A

Δ|Γ,A → B; Γ' ▶ B (→L)
Left rules for valid contexts.
Δ; Δ'|Γ,A ▶ C	Δ; Δ'|Γ,B ▶ C

Δ,A 𝖵 B; Δ'|Γ ▶ C	(∨ LV)
Δ,A → B; Δ'|Γ ▶ A

Δ,A → B; Δ'|Γ ▶ B (→LV)

Δ|Γ, A, B; Γ' ▶ C

Δ|Γ,A ∧ B; Γ' ▶ C (∧L)
Δ, A|Γ; Γ' ▶ B

Δ|Γ, 2A; Γ' ▶ B (2 L)


Δ, A, B; Δ'|Γ ▶ C
Δ,A ∧ B; Δ'|Γ ▶ C (∧LV)
Δ, A; Δ'|Γ ▶ B

Δ, 2A; Δ'|Γ ▶ B (2 LV)

Cut rules
Δ|Γ ▶ A	Δ|Γ,A ▶ B


Δ|Γ ▶ B





(Cut)


Δ|· ▶ A	Δ, A|Γ ▶ B


Δ|Γ ▶ B





(CutV)

We have two starting rules allowing to use an hypothesis present in any of the two contexts; the right rules for the connectives are the usual ones; the left rules come in two versions, one for each context. The rules for conjunction and disjunction follow the usual pattern, except that in the case of the rule (𝖵 LV), the case analysis is performed on the right context. The left rules for implication are new 5 to the best of our knowledge and capture the direct use of an implication to prove its consequent. The right rule for 2 corresponds to the necessitation rule. Observe that we can introduce a formula 2A only in the case when we derive A without resorting to any true hypothesis. This formulation is the key to validate the deduction theorem in Hilbert axiomatic systems for modal logic (see [9]). The left rule 2L is discussed in our previous work [5] and represents a transference principle between contexts: we can move a valid hypothesis A to the truth context by modalizing it. Finally 2LV says that to use an assumption 2A which is valid, it suffices to use only A. These left rules for necessity allow to replace a modal reasoning about 2A, for a propositional reasoning about A.
Let us show a couple of derivations in our system.

Example 2.1 The following is a proof of
· | · ▶ 2(2A → 2B) → 2!2A → 2(2C → 2B)"



5 Except for a mention in our previous work [14].

2A → 2B, A| · ▶ A	Vhyp
2A → 2B, A|2C ▶ 2A	2 R (1)
2A → 2B, A|2C ▶ 2B	→ LV (2)
2A → 2B, A| · ▶ 2C → 2B	→ R (3)
2A → 2B, A| · ▶ 2(2C → 2B)	2 R (4)
2A → 2B|2A ▶ 2(2C → 2B)	2 L (5)
2A → 2B| ·  ▶ 2A → 2(2C → 2B)	→ R (6)
2A → 2B| · ▶ 2!2A → 2(2C → 2B)"	2 R (7)
· |2(2A → 2B) ▶ 2!2A → 2(2C → 2B)"	2 L (8)
· | · ▶ 2(2A → 2B) → 2!2A → 2(2C → 2B)"	→ R (9)
Example 2.2 The following is a proof of
2!(2B → 2A) ∧ (2C → 2A)"| · ▶ 2!2B 𝖵 2C → 2A"

2B → 2A, 2C → 2A|2B ▶ 2B	Thyp
2B → 2A, 2C → 2A|2B ▶ 2A	→ LV (1)
2B → 2A, 2C → 2A|2C ▶ 2C	Thyp
2B → 2A, 2C → 2A|2C ▶ 2A	→ LV (3)
2B → 2A, 2C → 2A|2B 𝖵 2C ▶ 2A	𝖵 L (2, 4)
2B → 2A, 2C → 2A| ·  ▶ 2B 𝖵 2C → 2A	→ R (5)
2B → 2A, 2C → 2A| · ▶ 2(2B 𝖵 2C → 2A)	2 R (6)
(2B → 2A) ∧ (2C → 2A)| · ▶ 2(2B 𝖵 2C → 2A)	∧ LV (7)
2((2B → 2A) ∧ (2C → 2A))| · ▶ 2(2B 𝖵 2C → 2A)	2 LV (8)
The above proofs can be read according to the usual definition of forward deriva- tion, though actually they were gained from a bottom-up proof construction process, which corresponds to the below notion of derivation given originally by Kanger [11].
Definition 2.3 [Derivation à la Kanger] A proof or derivation of Δ|Γ ▶ A is a finite sequence of sequents Π = ⟨𝒥1,..., 𝒥k⟩ such that 𝒥1 is Δ|Γ ▶ A and for every 1 ≤ i ≤ k one of the following conditions hold:
𝒥i is an instance of the (Hyp) or (VHyp) rules.
For every 1 ≤ i ≤ k, 𝒥i is the conclusion of an instance of some inference rule with premise 𝒥j with j > i, or premises 𝒥j, 𝒥l with j, l > i.
Thus, a derivation starts with the sequent sought after, whereas the usual notion

of formal proof ends with it. Also, for any given sequent, the premisses that allow to conclude it appear later in the sequence. This gives an idea of backward proof. For instance, if we enumerate the steps in examples 2.1 and 2.2 in decreasing order, we obtain formal derivations according to Definition 2.3. Regrettably, even when this notion of derivation permeates Kanger’s work, the concept is not engaged, for the proofs there are written forwards. Moreover, like the examples above show, the mere sequence does not let us keep a trace of the proof-search process. Our purpose here is to give a formal notion of backward proof for modal logic that corresponds to the kind of techniques implemented in proof assistants, thus resolving the just mentioned issues. But first let us observe that NS4 indeed captures the constructive modal logic S4 for necessity.




Correspondence with constructive S4

Here we sketch the equivalence of GS4 with the constructive logic S4. To do so we make use of the results in our previous work [5], where we give a detailed and formally verified proof of the equivalence of a natural deduction system NS4 with an axiomatic system for S4. Thus, for the present purposes of showing that GS4 exactly captures the constructive modal logic S4, it suffices to show that GS4 is equivalent to the natural deduction system NS4 whose inference rules are given in the appendix 6. Let us next verify that the elimination rules for implication and box elimination of NS4 can be simulated in GS4. The simulation of the missing elimination rules for conjunction and disjunction is left to the reader.


Lemma 2.4 The following rules are admissible in GS4.

Δ|Γ ▶ A → B	Δ|Γ ▶ A
Δ|Γ ▶ B	(→ E)
Δ|Γ ▶ 2A	Δ, A|Γ ▶ C

Δ|Γ ▶ C	(2 E)

Proof The below proofs witness that these rules are even derivable:
(→ E) is derived as follows:


(1) Δ|Γ ▶ A → B
Δ|Γ ▶ A
Δ|Γ,A → B ▶ A
Given Given Weak (2)

Δ|Γ,A → B ▶ B	→ L (3)
Δ|Γ ▶ B	Cut (1), (4)

(2 E) is derived as follows:
Δ|Γ ▶ 2A
Δ, A|Γ ▶ C


Given Given

Δ|Γ, 2A ▶ C	2L (2)

Δ|Γ ▶ C
Cut (1), (3)
2

Let us now verify that the left rules of GS4 can be simulated in NS4.
Lemma 2.5 The left rules of GS4 are admissible in NS4.
Proof We give proofs showing that the left rules for → and 2 are even derivable. The remaining cases are left to the reader.
→ L.

Δ|Γ,A → B; Γ' ▶ A
Δ|Γ,A → B; Γ' ▶ A → B
Given Hyp

Δ|Γ,A → B; Γ' ▶ B	→ E (2)
→ LV. Is analogous to the previous rule.
2 L.

Δ, A|Γ; Γ' ▶ B
Δ, A|Γ, 2A; Γ' ▶ B
Δ|Γ, 2A; Γ' ▶ 2A
Given Weak (1) Hyp

Δ|Γ, 2A; Γ' ▶ B	2 E (2), (3)
2 LV.

Δ, A; Δ'|Γ ▶ B
Δ, 2A; Δ'| · ▶ 2A
Δ, 2A; Δ', A| · ▶ A
Given VHyp VHyp

Δ, 2A; Δ'| · ▶ A	2 E (2), (3)

Δ, A, 2A; Δ'|Γ ▶ B
Δ, 2A; Δ'|Γ ▶ B
Weak (1)
CutV 6 (5), (4)
2

We can prove now the equivalence between GS4 and NS4.

6 Using the results of [5, Section 4] it is easy to show that the rule CutV is admissible in NS4.

Theorem 2.6 The sequent calculus GS4 is equivalent to the natural deduction sys- tem NS4. That is,
Δ|Γ ▶GS4 C if and only if Δ|Γ ▶NS4 C
Proof We proceed by structural induction on Δ|Γ ▶ C in each system, using adequately the lemmas 2.4 and 2.5 and the fact that the cut rules of GS4 are also admissible in NS4.	2
Corollary 2.7 The sequent calculus GS4 exactly captures the constructive modal logic S4
Proof Immediate from Theorem 2.6, using the fact that NS4 is equivalent to the axiomatic system HS4 for constructive S4, as discussed in [5].	2
3	Backward proof-search in GS4
Sequent calculi are designed with backward proof-search in mind. For this process to automatically succeed is desirable that all rules are invertible. Recall that this means that if the conclusion is derivable, then necessarily the premises are also derivable. If the sequent sought after is indeed derivable, the application of an invertible rule will not lead to a dead end. However, in our case, and as expected, not all rules are invertible and the proof-search process needs the guidance of a human agent. But before describing such interactive process let us show which inference rules are indeed invertible.
Theorem 3.1 (Inversion of the inference rules) The right rules for ∧ and → as well as the left rules for ∧, 𝖵 are invertible. That is, the following rules are admissible:

Δ|Γ ▶ A → B
Δ|Γ,A ▶ B
Δ|Γ ▶ A ∧ B
Δ|Γ ▶ A
Δ|Γ ▶ A ∧ B
Δ|Γ ▶ B

Δ|Γ,A 𝖵 B; Γ' ▶ C


Δ|Γ, A; Γ' ▶ C
Δ|Γ,A ∧ B; Γ' ▶ C


Δ|Γ, A, B; Γ' ▶ C
Δ|Γ,A 𝖵 B; Γ' ▶ C


Δ|Γ, B; Γ' ▶ C
Δ,A ∧ B; Δ'|Γ ▶ C


Δ, A, B; Δ'|Γ ▶ C

Proof By structural induction on the premise of each rule.	2
On the other hand the left rules for → are not invertible. For instance the sequent
· |A → B, B ▶ B is clearly derivable, but it is not the case that · |A → B, B ▶ A holds. Non-invertible rules are evil, in that they lead the proof-search to a dead end. This is why we need an interactive process for proof-search, which we define by means of a formal notion of backward proof.

Let us first introduce a useful device to sequents, namely labelled hypotheses [7], which are pairs of the form H : A where H is a label or shortcut to refer to A. The set of labels is taken to be disjoint with the set of names in the current signature. A labelled context Γ is a set of labelled hypotheses Γ = {H1 : A1,..., Hn : An} where Hi /= Hj, if i /= j. Moreover, in a context of the form Γ, H : A; Γ' we assume that A is not in Γ; Γ' and that H is a new label not used in Γ; Γ'. The use of labels does not contribute much to the usual system of forward derivations, but as we will see soon it is very useful to the backward approach. In the following we use labelled contexts
The process of backward proof construction of a given sequent S consists of searching for an inference rule 𝑌 whose conclusion matches S and then to continue the proof-search with the premisses S or S1, S2 of 𝑌. This backward reading of the inference rules is called a tactic. A backward proof will be a particular sequence of tactics. Let us formalise these concepts.

Definition 3.2 A goal G is any sequent Δ|Γ ▶ A. The set of finite sequences of goals GSeq is recursively defined as follows:
£ ::= [·] | (G :: £)
where [·] denotes the empty goal sequence. Moreover, if £1, £2 ∈ GSeq then by
£1; £2 we mean the concatenation 7 of £1 with £2.

We define now a transition system of tactics corresponding to backward proof- search.

Definition 3.3 The transition system of tactics for G£4 is defined as follows:
The non-empty set of states is the set of goal sequences GSeq.
An initial state is a singleton sequence 8 .
[·] is the unique terminal state.
The transition relation D ⊆ GSeq × GSeq is inductively defined by the below axioms and inference rule, where a transition £1 D £2 can be read as ‘to prove the sequents in £1 it suffices to prove the sequents in £2’.





7 We use the ; for concatenation in both cases: contexts and goal sequences.
8 For clarity, a singleton sequence is identified with its unique element. That is, we write Δ|Γ ▶ A instead of (Δ|Γ ▶ A :: [·])

Conclusion analysis (right sequent rules):
intro H :	Δ|Γ ▶ A → B D Δ|Γ, H : A ▶ B
split :	Δ|Γ ▶ A ∧ B D Δ|Γ ▶ A; Δ|Γ ▶ B
left :	Δ|Γ ▶ A 𝖵 B D Δ|Γ ▶ A
right :	Δ|Γ ▶ A 𝖵 B D Δ|Γ ▶ B
neccesitation :	Δ|Γ ▶ 2A D Δ| · ▶ A
Premise analysis (left sequent rules):
apply H :		Δ|Γ, H : A → B; Γ' ▶ B D Δ|Γ, H : A → B; Γ' ▶ A apply H :	Δ, H : A → B; Δ'|Γ ▶ B D Δ, H : A → B; Δ'|Γ ▶ A destruct H :				Δ|Γ, H : A ∧ B; Γ' ▶ C D Δ|Γ, H1 : A, H2 : B; Γ' ▶ C destruct H :			Δ, H : A ∧ B; Δ'|Γ ▶ C D Δ, H1 : A, H2 : B; Δ'|Γ ▶ C destruct H :				Δ|Γ, H : A 𝖵 B; Γ' ▶ C D Δ|Γ, H1 : A; Γ' ▶ C ;
Δ|Γ, H2 : B; Γ' ▶ C
destruct H :	Δ, H : A 𝖵 B; Δ'|Γ ▶ C D Δ; Δ'|Γ, H1 : A ▶ C ;
Δ; Δ'|Γ, H2 : B ▶ C
destruct H :	Δ|Γ, H : 2A; Γ' ▶ B D Δ, H1 : A|Γ; Γ' ▶ B
destruct H :	Δ, H : 2A; Δ'|Γ ▶ B D Δ, H : A; Δ'|Γ ▶ B
Lemma Assertion (cut rules):
assert A :	Δ|Γ ▶ C D Δ|Γ ▶ A; Δ|Γ, H : A ▶ C
cut A :	Δ|Γ ▶ C D Δ|Γ, H : A ▶ C; Δ|Γ ▶ A vassert A :	 Δ|Γ ▶ C D Δ| · ▶ A; Δ, H : A|Γ ▶ C vcut A :	 Δ|Γ ▶ C D Δ, H : A|Γ ▶ C ; Δ| · ▶ A
Discarding tactics (hypothesis rules):
assumption :	Δ|Γ, A; Γ' ▶ A D [·]
vassumption :	Δ, A; Δ'|Γ ▶ A D [·]
Sequencing :


  £1 D £2	 (seq)
£1 £ D £2 £
A basic transition transforms a singleton goal sequence into a, perhaps empty, sequence of subgoals dictated by the backwards reading of an inference rule of G£4. The (seq) rule determines the order in which goals are solved, namely from the first (most left) goal in the current sequence of pending goals. Also observe that each cut rule has two corresponding tactics, namely cut and assert. The difference being only operational: either we first prove the lemma and then use it or viceversa.
Finally we can give the promised definition of a backward proof.
Definition 3.4 A backward proof of Δ|Γ ▶ A is a finite sequence of states
£1,..., £k such that
£1 is Δ|Γ ▶ A
For every 1 ≤ i < k, £i D £i+1
£k is [·]
Therefore a backward proof of a sequent Δ|Γ ▶ A is a finite sequence of tactics that ends in the empty sequence of goals [·], meaning that the original goal Δ|Γ ▶ A has no pending subgoals left to prove. This transition sequence of tactics corre- sponds to the bottom-up construction of a derivation tree by means of a left-to-right depth-first proof search.
Let us present now some particular examples of backward proofs that intend to show the adequacy of our sequent calculus G£4 for interactive proof-search.
Example 3.5 The following is a backward proof of
· |H1 : 2!(2P → 2Q) 𝖵 2R" ▶ 2 2(2P 𝖵 2R) → 2(2Q 𝖵 2R) 


· |H1 : 2!(2P → 2Q) 𝖵 2R" ▶ 2 2(2P 𝖵 2R) → 2(2Q 𝖵 2R) 
D	destruct H1
H1 : (2P → 2Q) 𝖵 2R| · ▶ 2 2(2P 𝖵 2R) → 2(2Q 𝖵 2R) 
D	necessitation
H1 : (2P → 2Q) 𝖵 2R| · ▶ 2(2P 𝖵 2R) → 2(2Q 𝖵 2R)
D	intro H2
H1 : (2P → 2Q) 𝖵 2R|H2 : 2(2P 𝖵 2R) ▶ 2(2Q 𝖵 2R)
D	destruct H2
H1 : (2P → 2Q) 𝖵 2R, H2 : 2P 𝖵 2R| · ▶ 2(2Q 𝖵 2R)
D	necessitation



H1 : (2P → 2Q) 𝖵 2R, H2 : 2P 𝖵 2R| · ▶ 2Q 𝖵 2R
D	destruct H2
H1 : (2P → 2Q) 𝖵 2R|H2 : 2P ▶ 2Q 𝖵 2R ;
H1 : (2P → 2Q) 𝖵 2R|H2 : 2R ▶ 2Q 𝖵 2R
D	destruct H1
· |H1 : 2P → 2Q, H2 : 2P ▶ 2Q 𝖵 2R ;
· |H1 : 2R, H2 : 2P ▶ 2Q 𝖵 2R ;
H1 : (2P → 2Q) 𝖵 2R|H2 : 2R ▶ 2Q 𝖵 2R
D	left
· |H1 : 2P → 2Q, H2 : 2P ▶ 2Q ;
· |H1 : 2R, H2 : 2P ▶ 2Q 𝖵 2R ;
H1 : (2P → 2Q) 𝖵 2R|H2 : 2R ▶ 2Q 𝖵 2R
D	apply H1
· |H1 : 2P → 2Q, H2 : 2P ▶ 2P ;
· |H1 : 2R, H2 : 2P ▶ 2Q 𝖵 2R ;
H1 : (2P → 2Q) 𝖵 2R|H2 : 2R ▶ 2Q 𝖵 2R

D	assumption
· |H1 : 2R, H2 : 2P ▶ 2Q 𝖵 2R ;
H1 : (2P → 2Q) 𝖵 2R|H2 : 2R ▶ 2Q 𝖵 2R
D	right
· |H1 : 2R, H2 : 2P ▶ 2R ;
H1 : (2P → 2Q) 𝖵 2R|H2 : 2R ▶ 2Q 𝖵 2R
D	assumption
H1 : (2P → 2Q) 𝖵 2R|H2 : 2R ▶ 2Q 𝖵 2R
D	right
H1 : (2P → 2Q) 𝖵 2R|H2 : 2R ▶ 2R
D	assumption
[·]

Example 3.6 The following is a proof of
Δ| · ▶ 2(2A ∧ 2D) → 2E
where Δ =def H1 : 2A → 2(2B ∧ 2C), H2 : 2(2D ∧ 2C) → 2(2E ∧ 2F ).
Δ| · ▶ 2(2A ∧ 2D) → 2E
D	intro H3
Δ|H3 : 2(2A ∧ 2D) ▶ 2E
D	destruct H3
Δ , H3 : 2A ∧ 2D| · ▶ 2E
D	destruct H3
Δ , H3 : 2A, H4 : 2D| · ▶ 2E
D	vassert
2(2B ∧ 2C)
Δ , H3 : 2A, H4 : 2D| · ▶ 2(2B ∧ 2C) ; 
Δ , H3 : 2A, H4 : 2D, H5 : 2(2B ∧ 2C)| · ▶ 2E
D	apply H1
Δ , H3 : 2A, H4 : 2D| · ▶ 2A ;
Δ , H3 : 2A, H4 : 2D, H5 : 2(2B ∧ 2C)| · ▶ 2E
D	vassumption
Δ , H3 : 2A, H4 : 2D, H5 : 2(2B ∧ 2C)| · ▶ 2E
D	destruct H5
Δ , H3 : 2A, H4 : 2D, H5 : 2B ∧ 2C| · ▶ 2E
D	destruct H5
Δ , H3 : 2A, H4 : 2D, H5 : 2B, H6 : 2C| · ▶ 2E
D	vassert
2(2E ∧ 2F )
Δ , H3 : 2A, H4 : 2D, H5 : 2B, H6 : 2C| · ▶ 2(2E ∧ 2F ) ; Δ , H3 : 2A, H4 : 2D, H5 : 2B, H6 : 2C, 
H7 : 2(2E ∧ 2F )| · ▶ 2E

D	apply H2
Δ , H3 : 2A, H4 : 2D, H5 : 2B, H6 : 2C| · ▶ 2(2D ∧ 2C) ; Δ , H3 : 2A, H4 : 2D, H5 : 2B, H6 : 2C, 
H7 : 2(2E ∧ 2F )| · ▶ 2E
D	necessitation
Δ , H3 : 2A, H4 : 2D, H5 : 2B, H6 : 2C| · ▶ 2D ∧ 2C ; Δ , H3 : 2A, H4 : 2D, H5 : 2B, H6 : 2C, 
H7 : 2(2E ∧ 2F )| · ▶ 2E
D	split
Δ , H3 : 2A, H4 : 2D, H5 : 2B, H6 : 2C| · ▶ 2D ; Δ , H3 : 2A, H4 : 2D, H5 : 2B, H6 : 2C| · ▶ 2C ; Δ , H3 : 2A, H4 : 2D, H5 : 2B, H6 : 2C, 
H7 : 2(2E ∧ 2F )| · ▶ 2E
D	vassumption
Δ , H3 : 2A, H4 : 2D, H5 : 2B, H6 : 2C| · ▶ 2C ; Δ , H3 : 2A, H4 : 2D, H5 : 2B, H6 : 2C, 
H7 : 2(2E ∧ 2F )| · ▶ 2E
D	vassumption
Δ , H3 : 2A, H4 : 2D, H5 : 2B, H6 : 2C, 
H7 : 2(2E ∧ 2F )| · ▶ 2E
D	destruct H7
Δ , H3 : 2A, H4 : 2D, H5 : 2B, H6 : 2C, 
H7 : 2E ∧ 2F | · ▶ 2E
D	destruct H7
Δ , H3 : 2A, H4 : 2D, H5 : 2B, H6 : 2C, 
H7 : 2E, H8 : 2F | · ▶ 2E
D	vassumption
[·]
The above example shows the utility of the cut rule with a valid hypothesis, implemented by means of the vassert tactic. Let us show next a more elaborated

example.




Example 3.7 The following is a proof of
2 2P → 2!2(2L 𝖵 2M ) → 2(2N ∧ 2Q)"  | 2 2(2Q 𝖵 2T ) → 2W 
▶ 2 2P → 2(2M → 2W ) 
Let Δ =def H1 : 2 2P → 2!2(2L 𝖵 2M ) → 2(2N ∧ 2Q)" . In some steps below we write only labels in the context, omitting the associated formulas, with purposes of text presentation.
Δ|H : 2(2(2Q 𝖵 2T ) → 2W ) ▶ 2(2P → 2(2M → 2W ))
D	destruct H
Δ , H2 : 2(2Q 𝖵 2T ) → 2W | · ▶ 2(2P → 2(2M → 2W ))
D	necessitation
Δ , H2| · ▶ 2P → 2(2M → 2W )
D	intro H'

Δ , H2|H3'
: 2P ▶ 2(2M → 2W )

D	destruct H3'
Δ , H2, H3 : P |· ▶ 2(2M → 2W )
D	necessitation
Δ , H2, H3 : P |· ▶ 2M → 2W
D	intro H'

Δ , H2, H3 : P |H4'
: 2M ▶ 2W

D	destruct H4'
Δ , H2, H3 : P, H4 : M | · ▶ 2W
D	apply H2
Δ , H2, H3 : P, H4 : M | · ▶ 2(2Q 𝖵 2T )
D	necessitation
Δ , H2, H3 : P, H4 : M | · ▶ 2Q 𝖵 2T
D	left

Δ , H2, H3 : P, H4 : M | · ▶ 2Q
D	assert
2(2(2L 𝖵 2M )
→ 2(2N ∧ 2Q))
Δ , H2, H3 : P, H4 : M | · ▶ 2(2(2L 𝖵 2M ) → 2(2N ∧ 2Q)) ;
Δ , H2, H3 : P, H4 : M |H5' : 2(2(2L 𝖵 2M ) →
2(2N ∧ 2Q)) ▶ 2Q
D	destruct H1
H1' , H2, H3 : P, H4 : M | · ▶ 2(2(2L 𝖵 2M ) → 2(2N ∧ 2Q)) ;
Δ , H2, H3 : P, H4 : M |H5' : 2(2(2L 𝖵 2M ) →
2(2N ∧ 2Q)) ▶ 2Q
D	apply H1'
H1' , H2, H3 : P, H4 : M | · ▶ 2P ;
Δ , H2, H3 : P, H4 : M |H5' : 2(2(2L 𝖵 2M ) →
2(2N ∧ 2Q)) ▶ 2Q
Dx	necessitation
H1' , H2, H3 : P, H4 : M | · ▶ P ;
Δ , H2, H3 : P, H4 : M |H5' : 2(2(2L 𝖵 2M ) →
2(2N ∧ 2Q)) ▶ 2Q
D	vassumption
Δ , H2, H3 : P, H4 : M |H5' : 2(2(2L 𝖵 2M ) →
2(2N ∧ 2Q)) ▶ 2Q
D	assert
2(2N ∧ 2Q)
Δ , H2, H3 : P, H4 : M |H5' : 2(2(2L 𝖵 2M ) →
2(2N ∧ 2Q)) ▶ 2(2N ∧ 2Q) ; Δ , H2, H3 : P, H4 : M |H5' , H6' : 2(2N ∧ 2Q) ▶ 2Q
D	destruct H5'
Δ , H2, H3 : P, H4 : M, H5 : 2(2L 𝖵 2M ) →
2(2N ∧ 2Q)| · ▶ 2(2N ∧ 2Q) ; Δ , H2, H3 : P, H4 : M |H5' , H6' : 2(2N ∧ 2Q) ▶ 2Q
D	apply H5

Δ , H2, H3 : P, H4 : M, H5 : 2(2L 𝖵 2M )
→ 2(2N ∧ 2Q)| · ▶ 2(2L 𝖵 2M ) ; 

Δ , H2, H3 : P, H4 : M |H5' , H6'
: 2(2N ∧ 2Q) ▶ 2Q

D	necessitation
Δ , H2, H3 : P, H4 : M, H5 : 2(2L 𝖵 2M )
→ 2(2N ∧ 2Q)| · ▶ 2L 𝖵 2M ;

Δ , H2, H3 : P, H4 : M |H5' , H6'
: 2(2N ∧ 2Q) ▶ 2Q

D	right
Δ , H2, H3 : P, H4 : M, H5 : 2(2L 𝖵 2M ) →
2(2N ∧ 2Q)| · ▶ 2M ;

Δ , H2, H3 : P, H4 : M |H5' , H6'
: 2(2N ∧ 2Q) ▶ 2Q

D	necessitation
Δ , H2, H3 : P, H4 : M, H5 : 2(2L 𝖵 2M ) →
2(2N ∧ 2Q)| · ▶ M ;

Δ , H2, H3 : P, H4 : M |H5' , H6'
: 2(2N ∧ 2Q) ▶ 2Q

D	vassumption

Δ , H2, H3 : P, H4 : M |H5' , H6'
: 2(2N ∧ 2Q) ▶ 2Q

D	destruct H6'

Δ , H2, H3 : P, H4 : M, H6 : 2N ∧ 2Q|H5'
▶ 2Q

D	destruct H6

Δ , H2, H3 : P, H4 : M, H6 : 2N, H6 : 2Q|H5'
▶ 2Q

D	vassumption
[·]
The above examples show that the proof-search process, though human-guided, can be developed in a very mechanical way.
To finish our presentation we discuss next the equivalence of backward and forward proofs.

4	Equivalence of forward and backward proofs
In this section we formally prove that our backward approach is equivalent to the usual notion of (forward) derivation. Let us start by noting that, according to

definition 3.4, a backward proof is a chaining sequence of particular instances of the relation D. Therefore a backward proof of the sequent Δ|Γ ▶ A corresponds to an instance of the transitive closure of the D relation. For the proof of the equivalence, it will be useful to work directly with this relation.
Definition 4.1 The transitive closure of the relation D, denoted D+, is inductively defined by the following rules:

£ D £'
£ D+ £'

(tc1)
£ D £'	£' D+ £''
£ D+ £''	tc

Lemma 4.2 The following rule is admissible:

£1 D+ £2
£1; £ D+ £2; £

(seq+)

Proof Induction on £1 D+ £2. If £1 D £2, then the rule (seq) yields £1; £ D £2; £
and by rule (tc1) we get £1; £ D+ £2; £. Assume now that £1 D £1' and £1' D+ £2.
By rule (seq) we have £1; £ D £1' ; £ and the I.H. yields £1' ; £ D+ £2; £, therefore rule (tc2) allows us to conclude £1; £ D+ £2; £.	2
Definition 4.3 We say that a goal sequence £ =def G1,..., Gk is solvable, if Gi is derivable for all 1 ≤ i ≤ k.
The next lemma shows that solvability of sequences is rearward preserved by the transition relation D.
Lemma 4.4 If £1 D £2 and the sequence £2 is solvable then £1 is solvable.
Proof It is clear that the property holds for the basic transitions, since these correspond to the inference rules of our sequent calculus. The result follows by an easy induction on D.	2
The above property is easily lifted to the transitive closure D+.
Lemma 4.5 If £1 D+ £2 and the sequence £2 is solvable then £1 is solvable.
Proof Induction on £1 D+ £2.	2
We are now ready to prove the desired equivalence of both proof styles.
Theorem 4.6 (Equivalence of forward and backward proofs) Let Δ|Γ ▶ A
be any sequent. The following conditions are equivalent:
Δ|Γ ▶ A is derivable
Δ|Γ ▶ A D+ [·]
Proof The ⇐) direction is immediate from lemma 4.5, since the sequence [·] is trivially solvable. We prove the ⇒) direction by induction on the derivability of Δ|Γ ▶ A.We show here only some cases leaving the others to the reader.
Case (Vhyp). The assumption tactic yields Δ, H : A; Δ'|Γ ▶ A D+ [·].

Case (∧ R). A backward derivation of Δ|Γ ▶ A ∧ B is the following: Δ|Γ ▶ A ∧ B D Δ|Γ ▶ A; Δ|Γ ▶ B D+ [·]; Δ|Γ ▶ B D+ [·]; [·]= [·]
The split tactic yields the first transition, after that, the second step is an application of the rule (seq+) using the IH Δ|Γ ▶ A D+ [·]; finally, the last step is justified by the IH Δ|Γ ▶ B D+ [·].
Case (→ LV). The backward derivation of Δ,A → B; Δ'|Γ ▶ B is Δ,A → B; Δ'|Γ ▶ B D Δ,A → B; Δ'|Γ ▶ A D+ [·]
where the first step corresponds to the apply tactic and the second is given by the IH.
Case (Cut). A backward derivation of Δ|Γ ▶ B is given by the following transi- tion sequence:
Δ|Γ ▶ B D Δ|Γ ▶ A ; Δ|Γ,A ▶ B D+ [·]; Δ|Γ,A ▶ B D+ [·]; [·]= [·]
where the first step is an instance of the assert A tactic, and the remaining are gained from the inductive hypotheses.
2
The above theorem guarantees the reliability of the proof-search process: if Δ|Γ ▶ A is derivable then the interactive proof-search process succeeds and vicev- ersa. This finishes our exposition.

5	Final Remarks
In this paper we presented a dual sequent calculus G£4 for the constructive modal logic S4 of necessity, and showed that it is adequate for interactive backward proof- search. The rules for handling the necessity operator are simple and intuitive due to the use of dual contexts, a feature that also let us define, in a simple way, a bottom-up construction process by means of a left-to-right depth-first proof-search. This procedure was captured with a formal notion of backward proof which results equivalent to the usual definition of forward proof. This work is the first step in a study of proof-search in modal logic whose natural continuation consists in the proof of the cut-elimination theorem in order to validate if G£4 is loop-free and then can be also adequate for full automatization. As usual, a proof of cut-elimination is not trivial. In our particular case we actually need to eliminate the two versions (Cut) and (CutV) of the cut-rule. However, the rules (2L) and (2LV) for the necessity operator allow us to prove the admissibility of (CutV) from that of (Cut) in a direct way. We are currently finding out if we can do the same for the left rules for valid contexts, a feature that would heavily simplify the proof of cut-elimination for the rule (Cut). Another part of this future inquiry is the extension of the current approach to the full modal logic S4, both constructively, where  is not a dual of

2, but also classically. In this last case additional research about proof-search with negation is required. The final purpose of this program is to show the utility of our deductive systems for actual case studies in some specific areas, like argumentation theory in the lines of [3,8] or proof-search in multi-agent dialogues related to the work of [19].

References
Julius Andrikonis. Loop-free calculus for modal logic s4. i. Lithuanian Mathematical Journal, 52(1):1– 12, Jan 2012.
Arnon Avron, Furio Honsell, Marino Miculan, and Cristian Paravano. Encoding Modal Logics in Logical Frameworks. Studia Logica, 60(1):161–208, Jan 1998.
Guido Boella, Joris Hulstijn, and Leendert van der Torre. A logic of abstract argumentation. In Simon Parsons, Nicolas Maudet, Pavlos Moraitis, and Iyad Rahwan, editors, Argumentation in Multi-Agent Systems, pages 29–41, Berlin, Heidelberg, 2006. Springer Berlin Heidelberg.
Tijn Borghuis and Loe Feijs. A constructive logic for services and information flow in computer networks. The Computer Journal, 43(4):274–289, 01 2000.
Lourdes del Carmen González-Huesca, Favio E. Miranda-Perea, and P. Selene Linares-Arévalo. Axiomatic and dual systems for constructive necessity, a formally verified equivalence. Journal of Applied Non-Classical Logics, 29(3):255–287, 2019.
Melvin C. Fitting. Proof Methods for Modal and Intuitionistic Logics. Synthese Library. Springer Netherlands, 1983.
D. M. Gabbay. Introduction to labelled deductive systems. In Handbook of Philosophical Logic, pages 179–266. Springer Netherlands, 2014.
Davide Grossi. Argumentation in the view of modal logic. In Peter McBurney, Iyad Rahwan, and Simon Parsons, editors, Argumentation in Multi-Agent Systems, pages 190–208, Berlin, Heidelberg, 2011. Springer Berlin Heidelberg.
Raul Hakli and Sara Negri. Does the deduction theorem fail for modal logic? Synthese, 187(3):849–867, 2012.
Samuli Heilala and Brigitte Pientka. Bidirectional decision procedures for the intuitionistic propositional modal logic is4. In Frank Pfenning, editor, Automated Deduction – CADE-21, pages 116–131, Berlin, Heidelberg, 09 2007. Springer Berlin Heidelberg.
Stig Kanger. Provability in logic. In Ghita Holmström-Hintikka, Sten Lindström, and Rysiek Sliwinski, editors, Collected Papers of Stig Kanger with Essays on His Life and Work, volume 1 of Synthese Library: Studies in Epistemology, Logic, Methodology, and Philosophy of Science, pages 8–
41. Kluwer Academic Publishers (Kluwer Academic Publishers Group), 2001. Originally published as Provability in Logic. Acta Universitatis Stockholrnensis, Stockholm Studies in Philosophy I. University of Stockholm 1957.
Pablo López, Frank Pfenning, Jeff Polakow, and Kevin Watkins. Monadic concurrent linear logic programming. In Proceedings of the 7th International ACM SIGPLAN Conference on Principles and Practice of Declarative Programming, July 11-13 2005, Lisbon, Portugal, pages 35–46, 2005.
Per Martin-Löf. On the meanings of the logical constants and the justifications of the logical laws.
Nordic J. Philos. Logic, 1(1):11–60, 1996.
Favio E. Miranda-Perea, P. Selene Linares-Arévalo, and Atocha Aliseda-Llera. How to prove it in natural deduction: A tactical approach. CoRR, abs/1507.03678, 2015.
Tom Murphy VII, Karl Crary, Robert Harper, and Frank Pfenning. A symmetric modal lambda calculus for distributed computing. In Proceedings of the 19th Annual IEEE Symposium on Logic in Computer Science, LICS ’04, pages 286–295, Washington, DC, USA, 2004. IEEE Computer Society.
Frank Pfenning and Rowan Davies. A judgmental reconstruction of modal logic. Mathematical Structures in Comp. Sci., 11(4):511–540, 2001.
Regimantas Pliuškevičius and Aida Pliuškevičiene˙. A new method to obtain termination in backward proof search for modal logic s4. Journal of Logic and Computation, 20(1):353–379, 11 2008.


Morten Heine Sørensen and Pawel Urzyczyn. Lectures on the Curry-Howard Isomorphism, Volume 149 (Studies in Logic and the Foundations of Mathematics). Elsevier Science Inc., New York, NY, USA, 2006.
Martin Sticht. Proof Search in Multi-Agent Dialogues for Modal Logic. PhD thesis, University of Bamberg Press, Universitätsbibliothek Bamberg, 2018. doctoralthesis.

6	Appendix
The deductive system for the implicational fragment of constructive logic NS4 is the one presented in Section 3 of [5]. The system is defined by the inference rules de- picted below, the extension which includes the rules for conjunction and disjunction is straightforward.


Δ|Γ, A; Γ' ▶ A (Thyp)

Δ, A; Δ'|Γ ▶ A (Vhyp)
Δ|Γ,A ▶ B

Δ|Γ ▶ A → B (→ I)



Δ|Γ ▶ A → B	Δ|Γ ▶ A
Δ|Γ ▶ B	(→ E)
Δ|Γ ▶ 2A	Δ, A|Γ ▶ C
Δ|· ▶ A
Δ|Γ ▶ 2A (2 I)

Δ|Γ ▶ C	(2 E)
