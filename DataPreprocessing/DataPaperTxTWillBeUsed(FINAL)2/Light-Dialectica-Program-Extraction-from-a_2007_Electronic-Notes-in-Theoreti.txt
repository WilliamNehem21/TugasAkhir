Electronic Notes in Theoretical Computer Science 171 (2007) 43–53	
www.elsevier.com/locate/entcs

Light Dialectica Program Extraction from a Classical Fibonacci Proof
Mircea-Dan Hernest1 ,2
Laboratoire d’Informatique (LIX) E´cole Polytechnique
F-91128 Palaiseau - FRANCE

Abstract
We demonstrate program extraction by the Light Dialectica Interpretation (LDI) on a minimal logic proof of the classical existence of Fibonacci numbers. This semi-classical proof is available in MinLog’s library of examples. The term of G¨odel’s T extracted by the LDI is, after strong normalization, exactly the usual recursive algorithm which defines the Fibonacci numbers (in pairs). This outcome of the Light Dialectica meta-algorithm is much better than the T-program extracted by means of the pure G¨odel Dialectica In- terpretation. It is also strictly less complex than the result obtained by means of the refined A-translation technique of Berger, Buchholz and Schwichtenberg on an artificially distorted variant of the input proof, but otherwise it is identical with the term yielded by Berger’s Kripke-style refined A-translation. Although syntactically different, it also has the same computational complexity as the original program yielded by the refined A-translation from the undistorted input classical Fibonacci proof.
Keywords: Proof Mining, Program extraction from (classical) proofs, Complexity of extracted programs, Refined A-translations, Quantifiers without computational meaning, Light Dialectica Interpretation, Computationally redundant contractions, G¨odel’s functional “Dialectica” interpretation


Introduction
There has been quite some work in the last years in the field of program ex- traction from classical proofs. Although strong mathematical results have re- cently been obtained in the Proof Mining of classical analytical proofs (see, e.g., [17,15,18,20,22]), the computer-implemented program extraction meta-algorithms were able to produce only limited results, for rather small test-cases and even then, the extracted program is not the optimal one.
Such a situation one partly encounters in the extraction of a rather unusual, distorted algorithm for the computation of Fibonacci numbers by means of the Berger-Buchholz-Schwichtenberg (BBS) refined A-translation of [3]. The term tBBS

1 Project LogiCal - Poˆle Commun de Recherche en Informatique du Plateau de Saclay, CNRS, E´cole Polytechnique, INRIA et Universit´e Paris-Sud - FRANCE
2 Email: danher@lix.polytechnique.fr

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.10.050

of G¨odel’s T extracted via this BBS refined A-translation from an artificially dis- torted 3 variant of the MinLog minimal logic proof of the weak (classical) existence of the Fibonacci numbers, followed by Kreisel’s Modified Realizability [19] and fi- nally strongly normalized [4,5] not only makes necessarily use of a type-2 Go¨del recursor (present also in the original extraction from [3]), but also uses two times the corresponding type-2 functional, fact which strictly increases its computational complexity. The program tBBS has an unexpected exponential time complexity, see the end of Section 4. On the other hand, the program extracted by the BBS technique from the original classical Fibonacci proof outlined in [3] is nonetheless linear-time in the unary representation of natural numbers, see [3] for full technical details.
The aforementioned type-2 recursor is R(ι→ι→ι)→ι, where the type level (degree) of (ι → ι → ι) → ι is 2. Here ι is the base type which denotes the set of natural numbers IN and Rρ is the denotation for the so-called “type-ρ G¨odel recursor”, which actually has the type ρ → (ι → ρ → ρ) → ι → ρ in G¨odel’s T 4 . This situation is quite unexpected since the usual recursive definition of Fibonacci numbers (in pairs) can be expressed in G¨odel’s T by means of a type-0 G¨odel recursor only, namely Rι×ι. Here σ × τ denotes the pairing of types σ and τ. In fact such a T- term was actually extracted in MinLog [25] by pure Modified Realizability, from the usual pure intuitionistic proof of the strong (intuitionistic) existence of Fibonacci numbers, see [3] 5 .
The point of the endeavour of extracting programs from classical rather than constructive or even purely intuitionistic proofs is that (semi-)classical proofs are much easier and more direct to build, both by human brain and also in the various computer-implemented proof-systems. It is therefore desirable that the algorithms synthesised from classical proofs by means of the more complex program extraction meta-algorithms 6 are at least as good as those yielded by the more common extrac- tion techniques 7 from the corresponding constructive/purely intuitionistic proofs. When applied to the semi-classical MinLog Fibonacci proof (by this we hereon mean the distorted variant obtained by automated proof-search, present in [25,11], and not the manual one, originally introduced in [3]), this is not the case, neither for the BBS refined A-translation, nor for the pure G¨odel Dialectica Interpretation, as we show later in the sequel. A repair of this situation can be provided for the BBS refined A-translation by eliminating the distortion from the proof at input 8 or by using its Kripke-style variant due to Berger in [2] 9 . The latter extraction technique

3 This artificial distortion is due to the automated proof-search mechanism of MinLog, relative to the more manually given input proof which was originally used in the classical Fibonacci extraction reported in [3].
4 See paper [3] for more such technical details.
5 On the other hand, this linear - in the unary representation of natural numbers - algorithm is outperformed by other logarithmic algorithms, see [24] for such an example.
6 Here we think particularly (but not exclusively) at those from the Dialectica family (see [23] for a nice unification work) and the Refined A-translation family.
7 Basically variants of Kreisel’s Modified Realizability [19], which is a simpler but weaker form of G¨odel’s functional (Dialectica) interpretation [1,10].
8 See [3,24] or the end of Section 4 for a display of the original program that is obtained by BBS from the undistorted classical Fibonacci proof, which is also of linear-time complexity in the unary representation of the natural-number input. See also Footnote 18.
9 Berger’s Kripke-style refined A-translation introduced in [2] nicely combines the optimizing (in the sense of the efficiency of programs extracted from classical proofs) features of both the BBS [3] and the Coquand-

actually produces exactly the same program as our Light Dialectica interpretation (originally introduced in [13], but see also [14] for a much larger and more unified exposition).
On the other hand, none of the monotone [16] or bounded [8] optimizations of G¨odel’s technique can handle such an exact realizer extraction problem. It is the Light Dialectica interpretation (abbreviated LDI) which gives the solution. The term of Go¨del’s T extracted by the LDI is, after strong normalization, exactly the usual recursive algorithm which defines the Fibonacci numbers (in pairs).

The semi-classical Fibonacci proof in MinLog
MinLog is an interactive proof- and program-extraction system developed by H. Schwichtenberg and members of the logic group at the University of Munich. It is based on first order Natural Deduction calculus and uses as primitive minimal rather than classical or intuitionistic logic. See [11,25] for full details.
Definition 2.1 [Fibonacci Numbers] The inductive definition is as usual

Base : F0 :≡ 0, F1 :≡ 1	Step : Fn+1 :≡ Fn + Fn−1 for n ≥ 1, n ∈ IN
The Fibonacci Numbers example was implemented in MinLog and it was com- paratively analysed in [3] by both pure Modified Realizability (from the usual pure intuitionistic proof) and also by the BBS refined A-translation (from a minimal logic proof of the weak, classical existence of Fibonacci Numbers; we dub such proofs as “semi-classical”) followed by Modified Realizability.
The semi-classical Fibonacci proof in MinLog is a Natural Deduction proof of
∀n∃clk G(n, k)– where ∃clk G(n, k) :≡ (∀k. G(n, k) → ⊥) →⊥ – from assumptions expressing that G is the graph of the Fibonacci function, i.e.,
G(0, 0) AND G(1, 1) AND ∀n, k, l. [G(n, k) ∧ G(n + 1, l)] → G(n + 2,k + l) .

The best source for reading and analysing this proof is the MinLog distribution [11] (or [25]), particularly that this differs, due to the use of automated proof-search, from the more manually given proof from Section 6 of [3]. See also Footnote 18 for some hints on how these semi-classical proofs can be constructed in MinLog. Notice that in the context of program extraction by the Light Dialectica interpretation, presented in Section 3 below, the assumption on G is rather expressed as
G(0, 0) AND G(1, 1) AND ∀n, k, l. [G(n, k) ∧ G(n + 1, l)] → G(n + 2,k + l) ,
where ∀ is the universal quantifier without computational meaning, see below.

Hofmann [7] refined A-translations. It also furthermore adds the so-called uniform quantifiers, which are used to “label” and thus isolate parts of the input proof which are meant not to have a computational content under such a translation.

The light functional Dialectica interpretation
The “light” variant of Go¨del’s functional “Dialectica” Interpretation was intro- duced in [13] as an optimization for term-extraction of Go¨del’s original technique 10 from [10]. The main feature of “Dialectica Light” is the elimination already at extraction time of a number of relevant (for the Dialectica program extraction) Contractions which are identified as redundant and in consequence are isolated by means of an adaptation of Berger’s quantifiers without computational content 11 (introduced in [2] as “uniform quantifiers”), here denoted ∀ and ∃, like in [13,14].
Dialectica Light (abbreviated LDI) is a recursive syntactic translation from proofs in a semi-classical 12 weakly extensional arithmetical system in all finite types 13 (denoted WeZ∃,nc+) to proofs in the corresponding purely intuitionistic sys- tem 14 (denoted WeZ∃) such that the positive occurrences of the strong ∃ and the negative occurrences of ∀ in the proof’s conclusion formula get actually realized by terms in Go¨del’s T. These realizing terms are also called the programs extracted by the LDI and (if only the extracted programs are wanted) the translation process is also referred to as “program extraction”. The LDI translation of proofs includes the following translation of formulas:
Definition 3.1 By quantifier-free (qfr) formula we understand a formula built from prime formulas at(to) and ⊥ by means of ∧, → and, if ∃ is available, also
∨. The qfr formulas are all decidable in our systems. There exists a unique bi- jective association of boolean terms to quantifier-free formulas A0 '→ tA0 such that
▶ A0 ↔ at(tA0 ). Then the LDI translation of formulas is:
AD :≡ AD :≡ at(tA) for quantifier-free formulas A
(A ∧ B)D :≡ ∃x, u ∀y, v  [ (A ∧ B)D :≡AD(x; y; a) ∧ BD(u; v; b)] 
(∃zA(z, a))D :≡ ∃z†, x ∀y [ (∃zA(z, a))D(z†, x; y; a):≡AD(x; y; z†, a)] 
(∀zA(z, a))D :≡ ∃X ∀z†, y  [ (∀zA(z, a))D(X; z†, y; a):≡AD(X(z†); y; z†, a)] 

(∃zA(z, a))D :≡ ∃x ∀y [ (∃zA(z, a))D(x; y; a):≡∃z AD(x; y; z, a)] 

(∀zA(z, a))D :≡ ∃x ∀y [ (∀zA(z, a))D(x; y; a):≡∀z AD(x; y; z, a)] 
(A → B)D :≡ ∃Y , U  ∀x, v  [ (A → B)D:≡AD(x; Y (x, v)) → BD(U (x); v)] 
where · '→ ·† is a mapping which assigns to every given variable z a completely new variable z† which has the same type of z. The free variables of AD are exactly the

10 Paper [1] provides a nice survey in English which includes the extensions to full Analysis.
11 In [13] we named these special existential and universal quantifiers “without (or non-) computational meaning”, abbreviated ncm. We here continue to use our own terminology.
12 This can be extended to fully classical proofs, modulo some double-negation translation, see [14].
13 System WeZ∃,nc+ was denoted WE−Z+ in [13]. It is nevertheless much better presented, with complete comparative details in [14], just like its corresponding WeZ∃ , see below.
14 System WeZ∃ , which was denoted WE−Z− in [13], is a Natural Deduction formulation of the weakly extensional Heyting Arithmetic in all finite types WE−HAω from Section 1.6.12 of [26]. See also [3,24] for the original corresponding fully extensional variant Z∃ ≡ Z + ∃.

free variables of A.

Remark 3.2 For the light Dialectica interpretation, the radical (or “root”) formula AD (which is LDI associated to A) is not necessarily quantifier-free, like it is for the pure G¨odel’s functional interpretation. It actually contains the translation of all ncm quantifiers to the corresponding regular quantifiers.
Theorem 3.3 (Exact realizer synthesis by the Light Dialectica [13])
There exists an algorithm which, given at input a Natural Deduction proof
P : {Ci}n	▶ A 15 in WeZ∃,nc+, it eventually produces at output the following:

the tuples of terms {Ti}n
and T, 

the tuples of variables {xi}n
and y, all together with

the verifying proof  PD : {Ci(xi; Ti(x, y))}n	▶ AD(T (x); y) in WeZ∃ , where

D
x :≡ x1,... , xn .
Moreover,
i=1

the variables x and y do not occur in P (they are all completely new)
the free variables of T and {Ti}n	are among the free variables of A and {Ci}n
– we call this “the free variable condition (FVC) for programs extracted by the
LDI”.

hence x and y also do not occur free in the extracted terms {Ti}n
and T. 

Remark 3.4 G¨odel’s functional “Dialectica” interpretation becomes relatively (far) more complicated at the moment when it has to face contraction. In the Natural Deduction setting, Contraction amounts to the discharging of at least two copies (from the same parcel 16 ) of an open assumption formula A during an Implication
[A] ... /B
Introduction	. This is because, for the so-called “Dialectica-relevant”
A → B
contractions 17 , A becomes part of the (raw, i.e., not yet normalized) realizing term. Therefore, the a priori (i.e., already at the extraction stage) elimination of some of these D-relevant contractions, rather than a posteriori (i.e., during the subsequent strong normalization process), represents an important complexity improvement of the extracted program. We exemplify our statement in the following Section 4.

A comparison of the three extraction techniques
It can be immediately seen, also from the machine benchmarks below, that the program yielded by the Light Dialectica interpretation clearly outperforms the al-

15 Hence of the formula A from the open assumption formulas C1,.. .,Cn . Here “open” is to be understood as “un-cancelled” or “un-discharged” and not necessarily as “un-closed”.
16 In the sense of the terminology from [9]. This is the same notion as “assumption variable” in [24].
17 See [14] for full details on this terminology and generally for a large and unified exposition of the Light Dialectica extraction.

gorithm given by the BBS refined A-translation 18 . The latter is at its turn much more efficient than the term extracted by means of the pure Go¨del Dialectica in- terpretation, which contains an important quantity of redundant information. All three extracted (by the three program-synthesis techniques) terms are presented below in a human-processed adaptation of the raw MinLog output. See [11] for the pure machine-extracted programs. We stress the fact that the outcomes of the pure and the light Dialectica meta-algorithms would remain the same even if the input classical Fibonacci proof would be the original, undistorted one from [3]. Only the output of the BBS A-translation would get better when using its original input, see Footnote 18. Our point here is that if the user is unable or unwilling to optimize the input proof, then it is the responsibility of the extraction technique to deal with such practically very possible artificial situations and overcome the complexity loss. It appears that the BBS refined A-translation is more directly dependent on the shape of the input proof and hence its performance decreases with the artificial distortions. This is because the BBS interpretation is based on an initial proof translation which literally includes the translation of the distortions. The witness is subsequently literally read from such a translated proof by Modified Realizability, which cannot avoid to preserve the distortions. In the case of the distorted classical Fibonacci proof, the redundant use twice of the (basically the induction hypothesis) assumption ∃clk, l. G(n, k) ∧ G(n + 1, l) during the automated search for a proof of the induction step will yield the double appearance of the type-2 functional H in the BBS-extracted program, see it below at 2). On the contrary, for both the D-interpretation and the LDI, the artificial distortion is harmless w.r.t. already the raw extracted program. Only a purely logical contraction, irrelevant already for the pure Dialectica, over the open assumption ∃clk, l. G(n, k) ∧ G(n + 1, l) will occur. This contraction has no computational content anyway, already in the case of the D-interpretation, because its formula translation has an empty universal side, see Definition 3.1 and [13,14] for full technical details. For the LDI the situation is identical, without any use of the special quantifiers without computational mean- ing. In fact not only this extra contraction, but the whole redundant proof-branch produced by the artificial distortion is without computational content under both the D-interpretation and the LDI. This is why the raw programs extracted by the two techniques are unchanged by the redundant distortion in the proof at input, i.e., regardless of whether the afore-mentioned assumption had been used once or twice, etc. Such an invariant situation was not possible for the BBS refined A-translation because this extraction technique lacks the full modularity of the Dialectica in- terpretations (see also [12] for an extended comment on this issue) and is more
proof-dependent (as explained above).
We now attempt a theoretical explanation of why the program extracted by the LDI outperforms so neatly the one given by the pure D-interpretation. As hinted by Remark 3.4, the difference in performance is yielded by (the elimination of)

18 This situation holds only for the more artificial input proof. When its distortions are eliminated by using a (search 1) restricted proof-search command instead of just (search), the run-time performance of the two extracted programs is quite equal. Here (search 1) means that the open assumptions may only be used at most once in the wanted searched proof. See [24] and the MinLog manual [25] for more details.

a computationally D-redundant contraction. This contraction is given by the fact that the assumption u : ∀n, k, l. [G(n, k) ∧ G(n + 1, l)] → G(n + 2,k + l) is open in the proof of the induction step of the classical Fibonacci proof. The contraction is inserted in the proof to be mined independently of the number of open occurrences of u in the original proof at input. The mechanism of the Dialectica interpretation in Natural Deduction will actually double the number of open occurrences of u, hence a logical contraction appears anyway. See [14] for the technical details of such a contraction yielded by the simulation of the general Induction Rule (and thus also of the Induction Axiom) in terms of the more particular rule of induction restricted to assumption-less base and step input proofs. Now, what happens as a consequence of our “light” optimization? Because of the use of the quantifier without computational meaning ∀ instead of the regular ∀ in u, this open assumption looses its Dialectica computational content, which existed only due to the presence of (the three) regular
∀ in a positive position. See [14] for this terminology and full technical details. The number of open occurrences (in the original input proof) of the computationally D- redundant assumption u becomes irrelevant since this assumption is ignored anyway
by the program extraction via the Light Dialectica Interpretation.
The subsequent computer benchmarks were performed on a DELL laptop (model X1, hence powered by an Intel Centrino CPU) running the Windows XP Prof. operating system. We used the more special MinLog distribution [11], which is not yet integrated with the official MinLog [25]. As Scheme interpreter we used the Petite Chez Scheme 7.0a, see [21]. The quantitative measures of computing time and space overhead were obtained by means of the Scheme “time” procedure.
The (MinLog, adapted) outcome of pure G¨odel’s Dialectica interpretation:
..........................
(add-var-name "n" "m" (py "nat"))
(add-var-name "G" (py "nat=>nat=>boole"))
(add-var-name "H" (py "(nat@@(nat@@nat)@@(nat@@nat))"))
..........................
t_{PDI} == [G,n] left right
((Rec nat=>nat@@(nat@@nat)@@(nat@@nat))((0@0@0)@0@1) ([m,H] [if
[if (G left left H left right left H)
[if (G (Succ left left H) right right left H) (G (Succ(Succ left left H))
(left right left H + right right left H)) True]
True]
(m @ right H) (left H)] @ right right H@
left right H + right right H)
n)
(time (nt (mk-term-in-app-form	t_{PDI} (pt "G") (pt "5"))))
314 collections


6031 ms elapsed cpu time, including 676 ms collecting 6110 ms elapsed real time, including 687 ms collecting
341280176 bytes allocated, including 337674848 bytes reclaimed "5"
(time (nt (make-term-in-app-form	t_{PDI} (pt "G") (pt "6")))) 2700 collections
56750 ms elapsed cpu time, including 9676 ms collecting 58375 ms elapsed real time, including 10008 ms collecting
2937460672 bytes allocated, including 2933419728 bytes reclaimed "8"
The outcome of the BBS refined A-translation (MinLog output, adapted):
..........................
(add-var-name "i" "j" "k" "l" "m" "n" (py "nat=>nat=>nat")) (add-var-name "f" (py "nat=>nat=>nat"))
(add-var-name "H" (py "(nat=>nat=>nat)=>nat"))
..........................
> > t_{BBS} == "[k](Rec nat=>(nat=>nat=>nat)=>nat) ([f] f 0 1) ([l,H,f] H ([i,j] H ([n,m] f m (n+m)))) k ([n,m] n)"
(time (nt (make-term-in-app-form t_{BBS} (pt "12"))))
39 collections
813 ms elapsed cpu time, including 109 ms collecting 813 ms elapsed real time, including 107 ms collecting
42919528 bytes allocated, including 39266296 bytes reclaimed "144"
(time (nt (make-term-in-app-form t_{BBS} (pt "15"))))
321 collections
7094 ms elapsed cpu time, including 1153 ms collecting 7203 ms elapsed real time, including 1246 ms collecting
348911096 bytes allocated, including 326154920 bytes reclaimed "610"
The outcome of Light Dialectica interpretation (MinLog output, adapted):
..........................
(add-var-name "n" "m" (py "nat"))
(add-var-name "G" (py "nat=>nat=>boole")) (add-var-name "H" (py "(nat@@nat)"))
..........................
t_{LDI} == "[G,n] left ((Rec nat=>nat@@nat) (0@1) ([m,H] right H @ left H + right H) n)"
(time (nt (mk-term-in-app-form t_{LDI} (pt "G") (pt "15"))))
6 collections
125 ms elapsed cpu time, including 0 ms collecting
140 ms elapsed real time, including 0 ms collecting


6802576 bytes allocated, including 6383624 bytes reclaimed "610"
(time (nt (mk-term-in-app-form t_{LDI} (pt "G") (pt "20"))))
68 collections
1343 ms elapsed cpu time, including 62 ms collecting 1344 ms elapsed real time, including 63 ms collecting
73584536 bytes allocated, including 71466424 bytes reclaimed "6765"
	(time (nt (mk-term-in-app-form t_{LDI} (pt "G") (pt "25")))) 750 collections
16219 ms elapsed cpu time, including 2279 ms collecting 16657 ms elapsed real time, including 2331 ms collecting
816525224 bytes allocated, including 803991296 bytes reclaimed "75025"
Notice that the above concrete quantitative measurements of time and space overhead correspond to the distorted classical Fibonacci proof. For both Dialectica interpretation and the LDI they would be the same also for the original input proof from [3], or the proof obtained by limited automated search via (search 1) (instead of the unlimited (search)). On the contrary, for the BBS refined A-translation the difference would be rather big, since from the cleaner input proof a linear-time program is obtained, with run-time performance fairly equal to that of the output of the LDI technique (despite the difference of syntactic shape). The program tBBS displayed above at 2) can be written as a Scheme [21] program as follows:
(define (FiboBis n)
(fibo2 n (lambda (k l) k))) (define (fibo2 n1 f)
(if (= n1 0)	(f 0 1)
(fibo2 (- n1 1) (lambda (kk ll)
(fibo2 (- n1 1) (lambda (k l) (f l (+ k l)))))))) Recall that the algorithm originally obtained in [3] could be spelled in Scheme as: (define (Fibo n)
(fibo1 n (lambda (k l) k)))
(define (fibo1 n1 f) (if (= n1 0)	(f 0 1)
(fibo1 (- n1 1) (lambda (k l) (f l (+ k l))))))
We immediately figure out that the price to pay for the distortion in the input proof is rather big when using the BBS technique. The algorithm FiboBis is exponential in n because the call of fibo2 on n1 induces two recursive calls of fibo2 on n1-1.

Conclusions and future work
More practical examples should be found for the application of the “light” opti- mization of Go¨del’s Dialectica interpretation. A negative result exists for the case

of the MinLog-implemented semi-classical proof of Dickson’s Lemma (see [6]). Here three nested Inductions give rise at three Contractions which are thus all three included in the extracted term(s), within the triply nested recursion. It is hence immediate to figure out that such a program would be very complex. Unfortunately, the Light Dialectica cannot repair this situation.

References
Avigad, J. and S. Feferman, G¨odel’s functional (‘Dialectica’) interpretation, in: S. Buss, editor,
Handbook of Proof Theory, Studies in Logic and the Foundations of Mathematics 137, Elsevier, 1998
pp. 337–405.
Berger, U., Uniform Heyting Arithmetic, Annals of Pure and Applied Logic 133 (2005), pp. 125–148, Festschrift for H. Schwichtenberg’s 60th birthday.
Berger, U., W. Buchholz and H. Schwichtenberg, Refined program extraction from classical proofs, Annals of Pure and Applied Logic 114 (2002), pp. 3–25.
Berger, U., M. Eberl and H. Schwichtenberg, Normalization by evaluation, in: B. M¨oller and J. Tucker, editors, Prospects for Hardware Foundations, LNCS 1546, Springer Verlag, 1998 pp. 117–137.
Berger, U., M. Eberl and H. Schwichtenberg, Term rewriting for normalization by evaluation, Information and Computation 183 (2003), pp. 19–42, International Workshop on Implicit Computational Complexity (ICC’99).
Berger, U., H. Schwichtenberg and M. Seisenberger, The Warshall algorithm and Dickson’s lemma: Two examples of realistic program extraction, Journal of Automated Reasoning 26 (2001), pp. 205–221.
Coquand, T. and M. Hofmann, A new method for establishing conservativity of classical systems over their intuitionistic version, Mathematical Structures in Computer Science 9 (1999), pp. 323–333.
Ferreira, F. and P. Oliva, Bounded functional interpretation, Annals of Pure and Applied Logic 135
(2005), pp. 73–112.
Girard, J.-Y., P. Taylor and Y. Lafont, “Proofs and Types,” Cambridge University Press, 1989.
G¨odel, K., U¨ber eine bisher noch nicht benu¨tzte Erweiterung des finiten Standpunktes, Dialectica 12
(1958), pp. 280–287.
Hernest, M.-D., The MinLog proof-system for Dialectica program-extraction, Free software, with full code source and documentation @ http://www.brics.dk/edanher/MinLogForDialectica.
Hernest, M.-D., A comparison between two techniques of program extraction from classical proofs, in:
M. Baaz, J. Makovsky and A. Voronkov, editors, LPAR 2002: Short Contributions and CSL 2003: Extended Posters, Kurt G¨odel Society’s Collegium Logicum VIII (2004), pp. 99–102.
Hernest, M.-D., Light Functional Interpretation, Lecture Notes in Computer Science 3634 (2005),
pp. 477 – 492, Computer Science Logic: 19th International Workshop, CSL 2005.
Hernest, M.-D., “Feasible programs from (non-constructive) proofs by the light (monotone) Dialectica

interpretation,” PhD Thesis,
E´cole Polytechnique and University of Munich (LMU) (2006), In

preparation, draft available @ http://www.brics.dk/edanher/teza/.
Kohlenbach, U., Proof Interpretations and the Computational Content of Proofs, Lecture Course, latest version in the author’s web page.
Kohlenbach, U., Analysing proofs in Analysis, in: W. Hodges, M. Hyland, C. Steinhorn and J. Truss, editors, Logic: from Foundations to Applications, Keele, 1993, European Logic Colloquium (1996), pp. 225–260.
Kohlenbach, U., Some logical metatheorems with applications in functional analysis, Transactions of the American Mathematical Society 357 (2005), pp. 89–128.
Kohlenbach, U. and P. Oliva, Proof mining: a systematic way of analysing proofs in Mathematics, Proceedings of the Steklov Institute of Mathematics 242 (2003), pp. 136–164.

Kreisel, G., Interpretation of analysis by means of constructive functionals of finite types, in:
A. Heyting, editor, Constructivity in Mathematics, North-Holland Publishing Company, 1959, pp. 101– 128.
Leu¸stean, L., A quadratic rate of asymptotic regularity for CAT(0)-spaces, Journal of Mathem. Analysis and Applications (2006), To appear, downloadable from Elsevier’s “Science Direct”, Articles in Press, Corrected Proof.
Cadence Research Systems, Chez Scheme, http://www.scheme.com (2006).
Oliva, P., Understanding and using Spector’s bar recursive interpretation of classical analysis, in: Proceedings of CiE’2006, LNCS 3988 (2006), pp. 423–434, Available in the author’s Web page @ http://www.dcs.qmul.ac.uk/epbo/.
Oliva, P., Unifying functional interpretations, Notre Dame Journal of Formal Logic (2006), to appear, downloadable from the author’s Web page.
Schwichtenberg, H., Minimal logic for computable functions, Lecture course on program-extraction from (classical) proofs. Available in the author’s web page or in the Minlog distribution [25].

Schwichtenberg, H. and Others, Proof- and program-extraction system
documentation at http://www.minlog-system.de.
Minlog, Free code and

Troelstra, A., editor, “Metamathematical investigation of intuitionistic Arithmetic and Analysis”, Lecture Notes in Mathematics 344, Springer-Verlag, Berlin - Heidelberg - New York, 1973.
