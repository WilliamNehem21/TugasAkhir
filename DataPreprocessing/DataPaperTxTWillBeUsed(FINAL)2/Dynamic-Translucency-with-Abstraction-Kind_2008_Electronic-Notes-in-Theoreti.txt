

Electronic Notes in Theoretical Computer Science 218 (2008) 313–336
www.elsevier.com/locate/entcs

Dynamic Translucency with Abstraction Kinds
and Higher-Order Coercions
Andreas Rossberg1
Max Planck Institute for Software Systems Saarbru¨cken, Germany

Abstract
When a module language is combined with forms of non-parametric type analysis, abstract types require an opaque dynamic representation in order to maintain abstraction safety. As an idealisation of such a module language, we present a foundational calculus that combines higher-order type generation, modelling type abstraction, with singleton kinds, modelling translucency. In this calculus, type analysis can dynamically exploit translucency, without breaking abstraction. Abstract types are classified by a novel notion of abstraction kinds. These are analogous to singletons, but instead of inducing equivalence they induce an isomorphism that is witnessed by explicit type coercions on the term level. To encompass higher-order forms of translucent abstraction, we give an account for higher-order coercions in a rich type system with higher-order polymorphism and dependent kinds. The latter necessitate the introduction of an analogous notion of kind coercions on the type level. Finally, we give an abstraction-safe encoding of ML-style module sealing in terms of higher-kinded type generation and higher-order coercion.
Keywords: Abstract types, modules, generativity, coercions, parametricity, singleton kinds


Introduction
Modules play an important role in the construction of large-scale software and appear in various forms in many programming languages. Particularly sophisticated module systems have been developed and investigated in the context of the ML family of languages [19,15,13,17,25,6].
Two features form the core of a module type system in this line of work:
Type abstraction provides for encapsulation by hiding the definition of a type exported by a module.
Type sharing enables module signatures to specify several types as equivalent, without necessarily exposing their representation.

1 Email: rossberg@mpi-sws.mpg.de

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.10.019

signature COMPLEX =
sig
type cplx
type base = real
val mk : base → base → cplx
val abs : cplx → base
val add : cplx → cplx → cplx
end
structure C :> COMPLEX =
struct
type cplx = real × real
type base = real
fun mk x y = (x, y)
fun abs z = sqrt (sqr z.1 + sqr z.2)
fun add z1 z2 = (z1.1 + z2.1, z1.2 + z2.2)
end

Fig. 1. Complex numbers in ML
These two aspects are combined in the notion of translucency, where module signa- tures can specify type components using an arbitrary mixture of opaque (abstract) and transparent (concrete) type specifications [13]. Sharing between two abstract types can be expressed by keeping one abstract, while exposing the other as mani- festly equal to the first.
In their seminal paper, Mitchell & Plotkin explain type abstraction as existential quantification [20]. Subsequent work on ML-style modules has mostly followed this view, albeit with more sophisticated type theories involving dependent types or kinds. Type sharing and translucency can be modelled elegantly with singleton kinds [2,27]: classifying a type variable α with the singleton kind S(τ ) effectively says that α ≡ τ . Thereby, existentially quantifying over a type at singleton kind makes it transparent.
As a running example, consider the ML signature COMPLEX given in Figure 1, which specifies the interface for a rudimentary module of complex numbers. It declares an abstract type cplx for complex values, but also a concrete type base manifestly equal to real, denoting the vector base of the complex representation. Combining existential quantification with singleton kinds, this signature can be encoded with the following type:
COMPLEX	=	∃α :Ω × S(real ) .
(α.2 → α.2 → α.1) × (α.1 → α.2) × (α.1 → α.1 → α.1)
This interpretation, also known as phase splitting [15], separates the signature into two parts: the static part, consisting of a (type-level) Cartesian product of all type components, and the dynamic part, a (term-level) product of all value components. The first component of the static part, representing type complex, has ground kind Ω, providing no information about its witness. In contrast, the second component, corresponding to the specification for base, has singleton kind S(real ), thus exposing the underlying definition. The tuple type describing the dynamic part can refer to both types in a uniform manner, like in the ML signature.
In Figure 1 we ascribe the signature COMPLEX to an implementation C, which hides the module’s representation of type cplx, while revealing the identity of base. Following Mitchell & Plotkin, such an ascription corresponds to constructing an appropriate value ⟨τ, e⟩ of existential type COMPLEX , as reflected in Figure 2.
This interpretation of type abstraction is solely static — in particular, it crucially

C	=	⟨⟨real × real , real ⟩,
⟨λx : real . λy : real . ⟨x, y⟩,
λz : real × real . sqrt (sqr z.1+ sqr z.2),
λz1 : real × real . λz2 : real × real . ⟨z1.1+ z2.1, z1.2+ z2.2⟩⟩
⟩ as COMPLEX
Fig. 2. Type abstraction via existential quantification
relies on parametricity in the underlying language [21]. Without parametricity, existential abstraction is no longer safe, since clients might potentially uncover the representation of an abstract type at runtime. This is particularly apparent in languages with reflective features, such as dynamic type analysis (typecase) [1,14]. Using such a feature, we could write a function to “cast” the abstract type to its representation:
let⟨αC , xC ⟩ = C in ... 
cast C = λz:αC.1. typecase z : αC .1 of z' : real × real ⇒ z' else ⟨0, 0⟩
The dynamic semantics of existential elimination will simply substitute αC with the respective witness, such that the typecase always succeeds (takes the first branch). Unfortunately, forms of type analysis are indispensable to safely deal with open systems. For example, Alice ML [23] features modules as first-class packages suit- able for dynamic import and export. When a package is unpacked, its signature is dynamically matched against a static annotation, to ensure type safety. A purely static interpretation of type abstraction would enable abusing this feature to write
a function like cast C .
The question we address in this paper hence is: What is an adequate dynamic
interpretation of type abstraction with translucency?

Dynamic Type Generation with Translucency
A refined model for type abstraction that provides a natural dynamic inter- pretation for type abstraction and does not suffer from parametricity violations is dynamic generativity [22,28,8]. In this approach, type abstraction is interpreted as the generation of a fresh type name. In a formal calculus, this can be modelled by introducing a term construct new t ≈ τ in e that generates a new type name and binds it to t. Within the body e the type variable t is known to be isomorphic to its underlying representation τ . However, t is not equivalent to τ — dynamic type analysis will properly distinguish the two. Any client code outside the original scope of the new construct has no way of discovering the isomorphism, it will just see an opaque type name.
In this paper, we extend earlier work on type generation by presenting the

foundational calculus λω
that combines it with (higher-order) singleton kinds.

This combination provides a dynamic interpretation of ML-style module types with translucency. In particular, it is sufficiently rich to form the semantic basis for dynamic extensions to module type systems, such as those found in Alice ML [23].

Abstraction Kinds
To type check the body e of an expression new t ≈ τ in e, the static semantics needs a way to record the isomorphism t ≈ τ in the typing environment. Previous work has done so by extending typing environments in an ad-hoc manner.
A more regular and expressive approach, which we propose in this paper, is to extend the kind system: in a fashion similar to singleton kinds S(τ ) that classify types as equivalent to τ , we introduce abstraction kinds A(τ ) that classify types as isomorphic to τ . More precisely, in the typing rule for new, the type variable t is entered into the typing environment with kind A(τ ).
Analogous to singleton kinds [27], higher-order forms of abstraction kinds are encodable. This observation leads to a more regular treatment of higher-kinded abstract types than in previous work.

Coercions and Sealing
Because a generated type t and its representation τ are merely isomorphic,

values in the λω
-calculus have to be explicitly coerced between these types. In the

simplest case, coercions apply to individual values of the abstract type. We write

+
t≈τ
for the coercion function τ → t, and C−
for its inverse.

However, coercing individual values is not a realistic model for a module system.
Modules are typically implemented solely in terms of their representation types and then abstracted a posteriori, in one atomic sealing operation applied to the entire implementation. 2 A more realistic approach leads to the concept of higher-order type coercions [22,28] that apply to whole module implementations.
Similar notions of type coercion appear in a variety of other contexts, such as the compilation of subtyping [3], unboxing transformations [16], hybrid type systems [10], or contracts [9]. In most of these works, the host type system is comparably inexpressive. We show how type coercions generalise to a higher-order polymorphic type system with singleton and dependent kinds. The latter induce sig- nificant complications, and necessitate the definition of higher-order kind coercions on the level of types. Fortunately, kind coercions are encodable.
Ultimately, we are able to define a dynamic version of an ML-style module sealing operator as syntactic sugar in our system, by means of a simple combination of higher-order type generation and higher-order type coercion.


Basic System
In the remainder of this paper, we are going to devise the λω


-calculus as a foun-

dational model for a higher-order language with modules and dynamic typing. It extends the higher-order polymorphic λ-calculus with the following features:
Existential types and pair kinds to express modules.
Singleton kinds, subkinding and subtyping to express translucency.

2 Some languages with simpler module systems, such as Haskell, actually require explicit individual coer- cions in the disguise of constructor applications and pattern matches.


(base kinds)	K ::= Ω | A(τ )
(kinds)	κ ::= K | SK(τ ) | Πα:κ.κ | Σα:κ.κ
(types)	τ ::= α | τ → τ | τ × τ | ∀α:κ.τ | ∃α:κ.τ
| λα:κ.τ | ττ | ⟨τ, τ ⟩ | τ.1 | τ.2
(terms)	e ::= x | λx:τ.e | ee | ⟨e, e⟩ | let⟨x, x⟩ = e in e
| λα:κ.e | eτ | ⟨τ, e⟩| let⟨α, x⟩ = e inτ e

| new α ≈ τ inτ e | C+
—
τ ≈τ
| typecase e:τ of x:τ.e else e


Fig. 3. Core λω

Dynamic type analysis to express runtime typing.
Type generativity to give a dynamic interpretation to type abstraction.
Higher-order coercions to express sealing.
We begin our presentation with a simplified version of the calculus that only provides basic coercions and generativity for ground types. We will add higher- order coercions and higher-order generativity in subsequent sections.

Figure 3 gives the syntax of the basic system, which we call Core λω
. It con-

sists of the (impredicative) higher-order λ-calculus including all canonical product constructions, extended with singleton kinds, simple type analysis, and the minimal functionality for dynamic type abstraction.
The expression form new α ≈ τ inτ' e generates a fresh abstract type, with representation τ . The variable α acts as an internal name for the abstract type within the body e (of α-free type τ '). At the same time, it represents a capability

for performing coercions over the new type: an upward coercion C+
(e) serves as

an introduction form for values of type α, while the dual downward coercion C−
(e)

is the respective elimination form. Where clear from context, we occasionally drop the “≈τ ” part from coercions to avoid notational clutter.
The last term construct expresses a simple form of non-parametric type analysis: evaluating typecase e1:τ1 of x:τ2.e2 else e3 compares the dynamic instantiations of type τ1 (of e1) with τ2. If they match, the e2 branch is taken, binding x to the value of e1, otherwise e3 is evaluated. Matching is up to subtyping, so that typecase is reminiscent of a “downcast”. Much more expressive forms of type analysis can be found in literature, but this variant is sufficient to encode the type dynamic [1] as the trivial existential ∃α:Ω.α with introduction and elimination forms

Here, check works up to subtyping, and thus can explore translucency dynamically.

The type language of λω
is completely standard. Note that type names are

simply represented by type variables. On the kind level, we distinguish between base kinds K, i.e. ground kind and abstraction kinds, and general kinds including singletons and standard dependent products and sums. Base singletons can only



C' = new cplx ≈ real × real in
⟨⟨cplx , real ⟩,
⟨λx : real . λy : real . C+
λz : cplx . sqrt (sqr (C−


⟨x, y⟩,
z).1+ sqr (C−



z).2),

cplx
λz1 : cplx . λz2 : cplx . C+
⟩
—
cplx
cplx
z1).1+ (C−
z2).1, (C−
z1).2+ (C−
z2).2⟩⟩



Fig. 4. Type abstraction via type generativity
be formed over base kinds. Higher-order singletons are obtained following Stone & Harper’s definition [27], with the added case S(τ : A(τ ')) := SA(τ')(τ ) for singletons at abstraction kind. 3
Figure 4 shows how our module of complex numbers can be expressed using

Core λω
: it still is an existential package, but this time the abstract type name is

represented by a fresh type name cplx that is used as a witness for α.1. To match the “signature” type COMPLEX , all operations have to use coercions for mitigating between cplx and its internal representation real × real .


Static Semantics
The static semantics of λω

consists of eight standard judgements:

(environment formation) Γ ▶	(kind equivalence) Γ ▶ κ ≡ κ' : (kind formation)	 Γ ▶ κ :   (type equivalence) Γ ▶ τ ≡ τ ' : κ (type formation)	 Γ ▶ τ : κ   (kind inclusion)  Γ ▶ κ ≤ κ' : (term formation)	Γ ▶ e : τ   (type inclusion)  Γ ▶ τ ≤ τ ' : κ
Most of the rules defining these judgements are entirely standard. In particular, rules regarding singletons and extensionality are taken almost verbatim from Stone & Harper [27]. The full type system can be found in the Appendix, here we focus on the parts that are particular to our calculus.
Figure 5 shows the central rules. Abstraction kinds are formed like singleton kinds, except that we in fact generalise singleton formation to arbitrary base kinds. The same generalisation applies to the singleton introduction rule Text-sing. Note that there is no introduction or elimination rule for abstraction kinds. Types of abstraction kind are only introduced via new (i.e., there are no closed types of abstraction kind), and like singletons, abstraction kinds are eliminated simply by kind subsumption (rule KSabs-left).
For terms, we find straightforward rules for type generation and type analysis. Coercions require the annotated type to have abstraction kind, and are assigned cor-

3 Note that it is crucial to distinguish SA(τ ')(τ ) from SΩ(τ ). Conflating the two would necessitate a subkinding rule that allows deriving S(τ ) ≤ A(τ ') if τ : A(τ '). However, such a rule would enable recov- ering abstraction kind dynamically for a plain abstract type name (of static kind Ω) — and thus break abstraction safety. E.g. consider λm:(∃α:Ω.α→int ). let⟨α, f ⟩=m in typecase⟨α, f ⟩ : (∃β:S(α).β→int ) of m' :
(∃β:A(int ).β→int ). let⟨β, f '⟩=m' in f ' (C+ 0) .. . applied to (new α≈int in	⟨α, λx:α. 1/(C− x)⟩).
β	∃α:Ω.α→int	α




Kind Formation
Γ ▶ τ :Ω 
Γ ▶ τ : K
(Γ ▶ κ :  )

Kabs Γ ▶ A(τ ): 
Ksing
Γ ▶ S
(τ ): 


Type Formation

Text-sing
K

Γ ▶ τ : K


Γ ▶ τ : SK(τ )

(Γ ▶ τ : κ)

Term Formation	(Γ ▶ e : τ )


Enew Γ, α:A(τ1) ▶ e : τ2	Γ ▶ τ2 :Ω  Γ ▶ new α ≈ τ1 inτ2 e : τ2
Eclose Γ ▶ τ : κ	Γ ▶ e : τ2
Γ ▶ ⟨τ, e⟩ : ∃α:κ.τ2

	Γ ▶ τ1 : A(τ2)	
Eup
	Γ ▶ τ1 : A(τ2)	
Edown

+
τ1≈τ2
: τ2 → τ1
—
τ1≈τ2
: τ1 → τ2

Ecase Γ ▶ e1 : τ1	Γ, x:τ2 ▶ e2 : τ	Γ ▶ e3 : τ Γ ▶ typecase e1:τ1 of x:τ2.e2 elseτ e3 : τ
Kind Equivalence	(Γ ▶ κ ≡ κ' :  )


KQabs
Γ ▶ τ ≡ τ ' :Ω 


Γ ▶ A(τ ) ≡ A(τ '): 
KQsing
Γ ▶ τ ≡ τ ' : K	Γ ▶ K ≡ K' : 


Γ ▶ SK(τ ) ≡ SK'(τ '): 

Type Equivalence	(Γ ▶ τ ≡ τ ' : κ)
Γ ▶ τ : SK(τ '')	Γ ▶ τ ' : SK(τ '')

TQext-sing


Γ ▶ τ ≡ τ ' : SK(τ '')

Kind Inclusion	(Γ ▶ κ ≤ κ' :  )


KSabs
Γ ▶ τ ≡ τ ' :Ω 

Γ ▶ A(τ ) ≤ A(τ '): 
Γ ▶ τ :Ω 

KSsing
Γ ▶ τ ≡ τ ' : K	Γ ▶ K ≤ K' : 


Γ ▶ SK(τ ) ≤ SK'(τ '): 
Γ ▶ τ : K	Γ ▶ K ≤ K' : 

KSabs-left Γ ▶ A(τ ) ≤ Ω: 
KSsing-left
Γ ▶ S
(τ ) ≤ K' : 

K

Type Inclusion	(Γ ▶ τ ≤ τ ' : κ)
Γ ▶ κ' ≤ κ :	Γ, α:κ' ▶ τ ≤ τ ' :Ω	Γ ▶ ∀α:κ.τ :Ω 

TSuniv

TSexist


Γ ▶ ∀α:κ.τ ≤ ∀α:κ'.τ ' :Ω 
Γ ▶ κ ≤ κ' :	Γ, α:κ ▶ τ ≤ τ ' :Ω	Γ ▶ ∃α:κ'.τ ' :Ω Γ ▶ ∃α:κ.τ ≤ ∃α:κ'.τ ' :Ω 

Fig. 5. Selected typing rules for Core λω

responding function type. As a technical detail, existential formation (rule Eclose) does not require a type annotation: thanks to subtyping (explained below), assign- ing singleton kind to the witness τ allows deriving a (fully transparent) existential type that is principal. The burden of annotation is shifted to new-expressions, which need to be given a τ2 that avoids the local type variable α.
Equivalence for types and kinds bears no surprises, subtyping and subkinding are more interesting: they enable forgetting singleton kinds (KSsing-left) and abstraction kinds (KSabs-left). A type of abstraction kind may thus be used at kind Ω, which allows the type to act as an actual abstract type name, beyond its use as a coercion key. For singletons, subsumption can go to the respective index kind, or a superkind of it, thereby forgetting the type identity. Subtyping then simply lifts the subkinding relation to quantified types, and ultimately, the entire type language (by standard rules). This realises translucent signature matching. For example, ∃α:SΩ(int ).α × α ≤ ∃α:Ω.α × int is derivable.


Dynamic Semantics
Figure 6 defines a small-step operational semantics for Core λω

. Values are defined

as a subset of expressions as usual and consist of λ-abstractions, tuples, existentials and values coerced to abstract type. Reduction is on conﬁgurations C, which are expressions paired with a heap. Heaps capture the type names generated with new as an ordered list of type variables classified by abstraction kind. Evaluating a new- expression pushes the bound type variable on the heap, taking advantage of the usual variable convention for freshness. The only rule for coercions is cancellation;
note that soundness ensures that Δ ▶ τ ≡ τ ' :Ω and Δ ▶ τ ≡ τ ' : A(τ ).
−	−	+	+	−
Type analysis uses the subtyping judgement from the static semantics to check
whether τ1 matches τ2. Since an evaluation context E cannot bind variables, both types are guaranteed to be closed up to type variables from the heap Δ.

Higher-order Coercions


Core λω
has obvious limitations: coercions have to be used all over an imple-

mentation, which has to have a handle on the abstract type name beforehand. In contrast, modules typically allow type abstraction after the fact, outside the actual implementation. How can we faithfully recover that flexibility?
The key is generalising the notion of coercion: instead of performing coercions on individual values of the abstract type, we allow higher-order coercions, which apply to any type. Figure 7 shows the syntax and rules of such coercions: where

a basic coercion C+
+  −
just represents a function of type τ−
→ τ+, a higher-order

coercion C+α.τ˜ is a function of arbitrary type τ˜[τ /α] → τ˜[τ /α] — similarly for
τ+≈τ−	−	+
the downward directions. Basic coercions arise as the special cases C±α.α . Here,
+  −
concrete types τ˜ are a syntactic subset of types that we will explain in Section 3.2.
Types instantiating polymorphic variables are also restricted to be concrete.



(values)	v ::= λx:τ.e | ⟨v, v⟩ | λα:κ.e | ⟨τ, v⟩ | C+
(v)

(contexts)	E ::=	| Ee | vE | ⟨E, e⟩ | ⟨v, E⟩ | let⟨x, x⟩ = E in e | Eτ | ⟨τ, E⟩
| let⟨α, x⟩ = E inτ e | typecase E:τ of x:τ.e else e
(heaps)	Δ ::= ·| Δ, α:A(τ ) (configurations) C ::= Δ; e


(Rapp)	Δ; E[(λx:τ.e) v]	→ Δ; E[e[v/x]]
(Rproj)	Δ; E[let⟨x1, x2⟩=⟨v1, v2⟩ in e]	→ Δ; E[e[v1/x1][v2/x2]] (Rinst)	Δ; E[(λα:κ.e) τ ]	→ Δ; E[e[τ /α]]
(Ropen)	Δ; E[let⟨α, x⟩=⟨τ, v⟩ inτ' e]	→ Δ; E[e[τ /α][v/x]]
(Rnew)	Δ; E[new α≈τ inτ' e]	→ Δ, α:A(τ ); E[e]

(Rcancel) Δ; E[C−
+  −
+
τ ' ≈τ '
v)]	→ Δ; E[v]

+  −
(Rcase1) Δ; E[typecase v:τ1 of x:τ2.e1 elseτ e2] → Δ; E[e1[v/x]] if Δ ▶ τ1 ≤ τ2 :Ω 
(Rcase2)  Δ; E[typecase v:τ1 of x:τ2.e1 elseτ e2] → Δ; E[e2]	if Δ /▶ τ1 ≤ τ2 :Ω 

Fig. 6. Reduction for Core λω

(expressions) e ::= ··· | e τ˜ | ⟨τ˜, e⟩| C+α.τ˜ | C−α.τ˜

τ ≈τ
(values)	v ::= ··· | ⟨τ˜, v⟩ | C+α.α(v)
τ ≈τ


Eup’ Γ ▶ τ+ : A(τ−)	Γ, α:Ω ▶ τ˜ :Ω	Edown’ Γ ▶ τ+ : A(τ−)	Γ, α:Ω ▶ τ˜ :Ω 

Γ ▶ C+α.τ˜
: τ˜[τ /α] → τ˜[τ /α]
Γ ▶ C−α.τ˜
: τ˜[τ /α] → τ˜[τ /α]

τ+≈τ−	−	+	τ+≈τ−	+	−


(Rarrow)
C±α.τ1 →τ2 (v)	→ λx1:τ1[τ /α]. C±α.τ2 (v (C∓α.τ1 x1))

τ+≈τ−
±	τ+≈τ−
τ+≈τ−

(Rtimes)
C±α.τ1 ×τ2 (v)	→ let⟨x1, x2⟩ = v in ⟨C±α.τ1 x1, C±α.τ2 x2⟩

τ+≈τ−
τ+≈τ−
τ+≈τ−

(Runiv)
C±α.∀β:κ.τ (v)	→ λβ:κ[τ /α]. C±α.τ' (v (T α.κ
β))

τ+≈τ−
±	τ+≈τ−
τ∓/τ±

where τ ' = τ [(T α.κ β)/β]
α/τ±

(Rexist)
C±α.∃β:κ.τ (v)	→ let⟨β, x⟩ = v in ⟨T α.κ β, C±α.τ' x⟩

τ+≈τ−
τ±/τ∓
where τ ' = τ [(T α.κ β)/β]
α/τ∓
τ+≈τ−

(Rdrop)
C±α.β (v)	→ v if β /= α
+  −

(Rcancel) C−α.α (C+α.α v) → v
τ+≈τ−	τ ' ≈τ '
+  −
Fig. 7. Extensions for higher-order coercions (reduction rules omit surrounding context Δ; E[ ])

Reduction
Higher-order coercions C±α.τ (v) are reduced to basic coercions via the reduction
+  −
rules given in Figure 7. Reduction is type-directed, driven by the residual type τ
of the coercion. We assume that τ is implicitly normalised [27]. Essentially, the rules proceed by functorially mapping the coercion over the residual type, i.e., η- expanding their argument and pushing the coercion inwards. For monomorphic

types this approach is fairly standard. For quantified types however, the presence of dependent kinds requires a bit more thought.
Without dependent kinds, rule Rcoerce-univ might simply look as follows [22]:

C±α.∀β:κ.τ (v)	→	λβ:κ. C±α.τ (v β)
τ+≈τ−	τ+≈τ−


In λω
this rule is incorrect however, because α may occur free in κ. One might

think that it is enough to simply substitute τ+ or τ− for α (depending on direction), but unfortunately that is not sufficient. Consider the coercion C+α.∀β:SΩ(α).β (f ): its
+  −
reduct λβ:SΩ(τ ). C+α.β (f β) would be ill-typed, because the instantiation f β is not
+	τ+≈τ−
valid — f has type ∀β:SΩ(τ−).β (by rule Eup’), which clashes with the incompatible
kind SΩ(τ+) assigned to the λ-bound β.
In general, we need to instantiate the polymorphic value with a type of kind κ[τ−/α] in the reduct, which we have to construct from β of kind κ[τ+/α]. In other words, we have to coerce β from the latter kind to the former. We write such a

type-level coercion as T α.κ
τ+/τ−
(τ ) (T α.κ
τ−/τ+
(β) here, due to its contravariant position).

Assuming kind coercions given for a moment, we can try reducing to

λβ:κ[τ /α]. C±α.τ (v (T α.κ
β)). This makes the instantiation well-formed. Unfor-

±	τ+≈τ−
τ∓/τ±

tunately, inserting a kind coercion for the argument now changes the resulting type

of the instantiation: the type of v (T α.κ
β) is τ [τ /α][T α.κ
β/β] — but the sur-

τ∓/τ±
rounding coercion expects τ [τ∓/α].
∓	τ∓/τ±

This final problem can be fixed if we find a suitable residual type τ ' in the surrounding coercion that fulfills the following equations:

τ '[τ /α] ≡ τ [τ /α]	(1)
±	±

τ '[τ /α] ≡ τ [τ /α][(T α.κ
β)/β]	(2)

∓	∓	τ∓/τ±

With such a type, the coercion yields type τ [τ /α][(T α.κ β)/β] → τ [τ /α], making
∓	τ∓/τ±	±
the entire reduct well-formed and type-preserving. With the admissible rules for
kind coercions that we will give in the next section, it can be shown that the type τ ' used in Figure 7 indeed has this property: it contains a kind coercion to the actual placeholder α of the surrounding coercion — we call that a placeholder-targetting coercion. A similar trick is employed in rule Rcoerce-exist.

Kind Coercions
Figure 8 gives the definition of kind coercions by induction over the residual kind κ. Unlike types, the shapes of kinds are invariant under substitution, such that kind coercions can be expanded statically and thus be treated as syntactic sugar. Otherwise, the definition closely resembles the reduction rules for type coercions. In particular, it employs placeholder-targetting coercions in the same manner.


T α.Ω (τ )	:= τ
τ+/τ−
T α.SΩ(τ ')(τ )	:= τ '[τ /α]
τ+/τ−	+

α.κ˜'
T	(τ ) := λβ:κ˜ [τ /α].T	2 (τ (T
1 β)) where κ˜'
= κ˜ [(T α.κ˜1 β)/β]

τ+/τ−
1 +	τ+/τ−
τ−/τ+
2	2	α/τ+

T α.Σβ:κ˜1 .κ˜2 (τ ) := ⟨T α.κ˜1 (τ.1), T α.κ˜' (τ.2)⟩	where κ˜'
= κ˜ [(T α.κ˜1 (τ.1))/β]

τ+/τ−
τ+/τ−
τ+/τ−
2	2	α/τ−


Fig. 8. Kind coercions

The following formation and equivalence rules can be shown admissible:
Γ, α:Ω ▶ κ˜ :	Γ ▶ τ− :Ω	Γ ▶ τ+ :Ω 

Tcoerce*
Γ ▶T α.κ˜
: κ˜[τ /α] → κ˜[τ /α]

τ+/τ−	−	+
Γ ▶ τ : κ˜[τ /α]	Γ, α:Ω ▶ κ˜ :	Γ ▶ τ ≡ τ :Ω 
TQdrop* 	−	+	−	

Γ ▶T α.κ˜
τ+/τ−
(τ ) ≡ τ : κ˜[τ−/α]

The most visible difference with the formation rule Eup’ for type coercions is that source type τ− and target type τ+ need not be related by an abstraction kind, because kind coercions do not have to reduce to a basic form. Consequently, kind coercions

need no polarity, the inverse of T α.κ˜
τ+/τ−
is simply T α.κ˜
τ−/τ+
. The equivalence rule is

crucial to equation (1) above, and thus to the correctness of placeholder-targetting
coercions. Also note that kind coercions (obviously) commute with substitution.
One important restriction on kind coercions is that they are not definable for residual abstraction kinds, because those lack the necessary extensionality principle. We call the syntactic subclasses of kinds and types containing no syntactic occur- rences of abstraction kinds concrete, and use the meta variables κ˜ and τ˜ to range over them. Because all coercions with non-concrete residual kind (or type) would eventually expand to a kind coercion over abstraction kind, we have to restrict the use of non-concrete residuals, as implemented by the grammar in Figure 7. 4

Higher-order  Generativity
So far, our language only allows the generation of ground types. Figure 9 gives the

main extensions to Full λω
, necessary to support higher-kinded type generativity.

The extensions to the syntax are straightforward: all occurrences of type names are now annotated with a (concrete) kind. Accordingly, the respective typing rules need to generalise the kinds assigned to these variables: instead of plain abstraction kind A(τ ), they now have to assign higher-order abstraction kind A(τ : κ˜).

4 It would be possible to encompass kind coercions at abstraction kind, but only for the price of making them primitive. However, since abstraction kinds are “internal” and never show up in an encoding of module signatures, the restriction is not substantial.

(expressions)	e ::= ··· | new α:κ˜ ≈ τ inτ e | C+α:κ˜.τ˜ | C−α:κ˜.τ˜

(values)	v ::= · · · | C+α:Ω.α(v)
+  −
(path contexts) P ::=	| P τ | P.1 | P.2 (heaps)	Δ ::= ·| α:A(τ : κ˜)
τ+≈τ−
τ+≈τ−


Enew’ Γ ▶ τ1 : κ˜	Γ, α:A(τ1 : κ˜) ▶ e : τ2	Γ ▶ τ2 :Ω 
Γ ▶ new α:κ˜ ≈ τ1 inτ2 e : τ2
Eup’ Γ, α:κ˜ ▶ τ˜ :Ω	Γ ▶ τ− : κ˜	Γ ▶ τ+ : A(τ− : κ˜)
Γ ▶ C+α:κ˜.τ˜ : τ˜[τ /α] → τ˜[τ /α]
τ+≈τ−	−	+
Edown’ Γ, α:κ˜ ▶ τ˜ :Ω	Γ ▶ τ− : κ˜	Γ ▶ τ+ : A(τ− : κ˜)
Γ ▶ C−α:κ˜.τ˜ : τ˜[τ /α] → τ˜[τ /α]
τ+≈τ−	+	−

Δ; E[new α:κ˜≈τ in e] → Δ, α:A(τ : κ˜); E[e]

±α:κ˜.P [β]
+α':κ˜'.P [α'/β:κ˜'][τ±/α]
±α:κ˜.P [τ '/β:κ˜']
−α':κ˜'.P [α'/β:κ˜'][τ∓/α]

Cτ+≈τ−	(v) → Cβ≈τ '	Cτ+≈τ−	Cβ≈τ '	(v)
where β /= α and Δ(β)= A(τ˜' : κ˜')

C±α:κ˜.P [α](v) → C±α:Ω.α
C±α:κ˜.P [τ∓/α:κ˜](v)

τ+≈τ−
P [τ+/α:κ˜][τ±/α]≈P [τ−/α:κ˜][τ±/α]
where P /=
τ+≈τ−


Fig. 9. Extensions for higher-order type generation (omitted Δ; E[ ] for coercion reduction rules)





A(τ : Ω) := A(τ ) A(τ : SΩ(τ ')) := SΩ(τ ')
A(τ : Πα:κ˜1.κ˜2) := Πα:κ˜1.A(τ α : κ˜2)
A(τ : Σα:κ˜1.κ˜2) := Σα:A(τ.1: κ˜1). A(T α:κ˜1.κ˜2 (τ.2) : κ˜2)

Fig. 10. Higher-order abstraction kinds



Higher-order Abstraction Kinds
Lifting abstraction kinds to higher order does not require any extension to the type or kind language — Figure 10 shows how they are definable. The definition closely mirrors that of higher-order singleton kinds [27], with the only difference showing up in the Σ case: here, a single abstraction is split into two separate ones, one for each component. Since the second component may refer to the first, it has to cross the abstraction barrier of the first via a suitable kind coercion targetting α.
More concretely, higher-order abstraction kinds must be defined such that

higher-order generalisations of the rules from Figure 5 are admissible:

Γ ▶ τ : κ˜ 
Γ ▶ τ ≡ τ ' : κ˜	Γ ▶ κ˜ ≡ κ˜' : 

Kabs* Γ ▶ A(τ : κ˜):	KQabs*


Γ ▶ A(τ : κ˜) ≡ A(τ ' : κ˜'): 

Γ ▶ τ : κ˜ 
Γ ▶ τ ≡ τ ' : κ˜	Γ ▶ κ˜ ≡ κ˜' : 

KSabs-left* Γ ▶ A(τ : κ˜) ≤ κ˜ : 
KSabs*


Γ ▶ A(τ : κ˜) ≤ A(τ ' : κ˜'): 

In particular, an abstraction kind must be a subkind of its index (KSabs-left*). Now consider κ = A(τ : Σα:Ω. SΩ(α)→Ω) with τ = ⟨int, λβ:SΩ(int ).β⟩. According to the definition, it expands to Σα:A(int ). Πβ:SΩ(α). A(β) (modulo βη-reduction of constituent types). Clearly, this is a subkind of the original index, whereas other obvious candidates for the expansion of A(τ : Σα:κ˜1.κ˜2) (such as Σα:A(τ.1: κ˜1).A(τ.2: κ˜2) or Σα:A(τ.1: κ˜1).A(τ.2: κ˜2[τ.1/α])) would fail to produce one.
Reduction of Higher-kinded Type Coercions
One interesting consequence of the way we define higher-order abstraction kinds is that we can keep the notion of value unchanged as well: abstract types can already be denoted by arbitrary type expressions τ+, so that basic coercions subsume higher- kinded abstractions. To see why, consider an abstract type stack : A(list :Ω → Ω). This kind decomposes into Πα:Ω.A(list α). Consequently, a stack of integers can be

formed as the value s = C+α:Ω.α
[5, 2, 7] right away. Here, τ+
= stack int is a

type path, not just a name, but yet has abstraction kind A(list int ).
What we can not express with basic coercions is further abstracting the element

type of s with respect to date ≈ int , as in C+α:Ω.α
(s) — this application

is ill-formed, because stack date has kind A(list date ), not A(stack int ). We need a higher-order coercion C+α:Ω.stack α(s) instead, where α appears in nested position.
The two additional reduction rules for coercions given in Figure 10 deal with cases like this, where the residual type is an abstract path P [α]. For now, you should read occurrences of path replacement P [τ /α : κ] in the rules as P [τ ].
The first rule treats the case where the head of the path is another abstract type β. It looks up β’s representation τ ' on the heap, inserts an auxiliary coercion to τ ', performs the actual coercion on the representation, and finally redoes the coercion to β. For example, C+α:Ω.stack α(s) will be split into three simpler coer-
cions, C+α':Ω→Ω. α' date (C+α:Ω. list α(C−α':Ω→Ω. α' int (s))), and eventually become the

stack ≈list
date ≈int
stack ≈list

+α:Ω.α
stack date ≈list date
+α:Ω.α
date≈int
+α:Ω.α
date ≈int
+α:Ω.α
date ≈int
(7)].

The second rule is more subtle.  It applies whenever we coerce at a (non-
trivial) path P [α] headed by the placeholder variable itself, i.e. when we do a coercion that is higher-order and higher-kinded at the same time. Intuitively, the rule implements two simultaneous simplifications: (1) it splits the coercion into two, first coercing the type arguments (occurrences of α in P ) and then the head of the residual type, and (2) it grounds the head coercion by lift- ing path information from the residual type to the abstract type itself, yield- ing a residual of ground kind Ω. For example, C+α:(Ω→Ω).α (α int)([[7]]) will pro-

+α:Ω.α
stack (stack int)≈list (stack int )
(C+α:(Ω→Ω).list (α int)([[7]])), where the inner coercion


P [τ /τ : κ˜]	:= P [α:κ˜.κ˜α]
+  −	τ+/τ−
[α:κ˜.Ωτ ]	:= τ [τ /α]
τ+/τ−	+
[α:κ˜.SΩ(τ ')τ ]	:= τ [τ /α]
τ+/τ−	+
P [ τ '][α:κ˜.Πα1:κ˜1.κ˜2 τ ] := P [α:κ˜.κ˜2[τ ''/α1]τ τ ''] where τ '' = T α:κ˜.κ˜1 (τ ')

τ+/τ−
τ+/τ−
α/τ−

P [ .1][α:κ˜.Σα1:κ˜1.κ˜2 τ ] := P [α:κ˜.κ˜1 τ.1]
τ+/τ−	τ+/τ−
P [ .2][α:κ˜.Σα1:κ˜1.κ˜2 τ ] := P [α:κ˜.κ˜2[τ.1/α1]τ.2]
τ+/τ−	τ+/τ−

Fig. 11. Coercive path replacement

treats the inner list, and the outer grounds the modified residual type by lifting P [ ] =	(stack int ) to the abstract type. With this rule, all coercions can ulti- mately be brought into ground form, which is in contrast to previous work [22,28]. Once more, singletons create a complication: it is not generally correct to split the coercion by simply replacing only the head of the path, even though we know that τ± : κ˜. What consists a valid split depends on the specifics of kind κ˜. To see why, consider κS = Σα1:Ω.Πα2:SΩ(α1).Ω and τ+ : A(τ− : κS). Under this kind assignment, P [α]= α.2 (α.1) is a valid residual type. However, forming P [τ−]= τ−.2 (α.1) is not:
α.1 does not match the argument kind SΩ(τ−.1) of τ−.2!
To address this problem, the rules actually use coercive path replacement P [τ /α : κ], which is defined in Figure 11. It coerces occurrences of α in P where necessary, such that the resulting type remains well-formed. In the case of P [α] = α.2 (α.1) as before, P [τ±/α : κS] = τ±.2 (τ±.1). In fact, there is no way to separate the two occurrences of α. Consequently, a coercion C+α:κS.α.2 (α.1)(v)
+  −
would not actually “split” the residual type, but ground it in one step with

C+α:Ω.α
τ+.2 (τ+.1)≈τ−.2 (τ−.1)
(C+α:κS.τ−.2 (τ−.1)(v)) (leaving a redundant inner coercion that
+  −

eventually vanishes). This is consistent with the fact that τ+.2 (τ+.1) : A(τ−.2 (τ−.1)).
Contrast this with a singleton-free variation of the example, using kind κΩ = Σα1:Ω.Πα2:Ω.Ω. This results in P [τ±/α : κΩ] = τ±.2 (α.1), and thus the coercion

C+α:κΩ.α.2 (α.1)(v) is split into C+α:Ω.α
(C+α:κΩ.τ−.2 (α.1)(v)), where head

τ+≈τ−
τ+.2 (τ+.1)≈τ−.2 (τ+.1)
τ+≈τ−

and argument are indeed handled separately. Here, τ+.2 (τ+.1) : A(τ−.2 (τ+.1)). In
general, if τ+ : A(τ− : κ˜), we have P [τ+/α : κ˜]: A(P [τ−/α : κ˜]), given a suitable P .

Results
We now have all necessary ingredients to define a dynamically adequate notion of
a posteriori sealing as follows:


e :> ∃α:κ˜.τ˜
:=	let⟨α, x⟩ = e in new β:κ˜ ≈ α in∃α:κ˜.τ˜ ⟨β, C+α:κ˜.τ˜x⟩

with the admissible typing rule


Eseal*
Γ ▶ e : ∃α:κ˜.τ˜

Γ ▶ (e :> ∃α:κ˜.τ˜): ∃α:κ˜.τ˜

Note how higher kinds allow uniformly generating just one type name for the whole static part of the module, and then coercing the dynamic part appropriately with a single higher-order coercion. Moreover, the definition of higher-order abstraction kinds ensures that singleton components remain transparent. Applying this to our complex number example lets us define the safe C' from Figure 4 simply as follows:
C'	=	C :> COMPLEX
where C is the original transparent definition from Figure 2.

The λω
-calculus enjoys the usual soundness properties:

Lemma 5.1 (Preservation)
If Δ ▶ e : τ and (Δ; e) → (Δ'; e'), then Δ' ▶ e' : τ.
Lemma 5.2 (Progress) If Δ ▶ e : τ, then either e = v, or (Δ; e) → (Δ'; e').
More interestingly, type checking is decidable for Full λω :

Lemma 5.3 (Decidability) For each λω
judgement there exists an algorithm

that is sound, complete and terminating.
All algorithms and proofs can be found in [24]. The main difficulty is posed by type equivalence with singleton kinds. Fortunately, we kept our type language close enough to Stone & Harper [27], so that only minor extensions to their algorithms and proofs were required, mostly for dealing with the extended notion of base kinds.

Related and Future Work
Dynamic type generation for abstract types can be found in a number of previous works, including our own [26,22,18,28,8]. Likewise, notions of higher-order coercion are a recurring scheme, as already mentioned in Section 1. However, we are not aware of any previous work that investigates either in the context of a type sys- tem such as ours, which includes both translucency and type analysis or features dependent kinds.

In [22] we first presented a calculus similar to λω
, but without translucency.

Lacking the regularity of abstraction kinds as well, higher-kinded coercions could not be reduced to a simple canonical form, requiring more ad-hoc rules.
Vytiniotis et al. [28] is the only other work that combines a (much richer) type analysis construct with higher-kinded type generativity and higher-order coercions, but without modelling translucency. Not having abstraction kinds, their system syntactically distinguishes between basic and higher-order coercions: their equiva- lent of C+α:(Ω→Ω).α τ (v) would ‘forget’ the residual type annotation and reduce to
—

+
β≈τ−
(v), resulting in a lack of a principal type property. For example, C+
(3)

could be assigned infinitely many incompatible types. It is not obvious that type

checking is decidable, considering higher-order cases like C+
(3) that may

ask for higher-order unification to infer a higher-kinded argument to β.
Crary [3] presents a coercion calculus for eliminating subtyping and bounded quantification. His language is equipped with intersection types, but does not fea- ture higher-order types or dependent kinds. That allows him to express higher-order coercions by a separate coercion language, and have a simple proof of erasability. Interestingly, Crary’s development requires defining a meta function map that ap- plies a pair of positive and negative coercions to all occurrences of a type variable in a type. This roughly corresponds to a simple notion of kind coercion. In another article [4], Crary gives an elimination transformation for singleton kinds. His defi- nition of singleton expansion conincides with the degenerate case of kind coercion where the placeholder α does not actually occur in the residual kind.
Grossman et al.’s abstraction brackets [12] are very similar to higher-order co- ercions over ground types, but in a simply-typed system. Unlike coercions, nested brackets are merged on reduction, dropping all intermediate type annotations. It is not clear if that would leave sufficient information for decidable type checking in a richer type system like ours, particularly with higher kinds and subtyping.
Dreyer employs explicit generativity to model type abstraction of recursive mod- ules [8]. For that purpose, he separates generation of type names (new α↑κ in e) from definition (set α:≈τ in e). An effect system ensures linearity of the defini- tions. He does not consider type analysis, and thus avoids the need for coercions by allowing abstract type names to become transparent at run time.
Dreyer’s thesis [7] describes a problem with the interplay between singleton kinds and higher-order recursive types, where well-formedness of a recursive type does not imply well-formedness of its unrolling. This is due to the same problem that occurs in our setting in the reduction of higher-kinded coercions and led us to introduce coercive path replacement. Dreyer’s solution is to syntactically restrict the kinds on μ-bound type variables, which is not a viable option in our case.
Crary et al. [5] show how type analysis can be translated into term-level dispatch by introducing term representations of types. This translation can be employed to selectively prevent the analysis of certain types, simply by not introducing a representation for them. However, the choice cannot be made on a level that is fine-grained enough for dynamic translucency. For example, if β is the name of an abstract type, then inspection of int × β can only be prevented altogether, whereas our system still allows inspecting the product, but not β itself.
Instead of type names, generative type tags [11] can also ensure encapsulation of abstract values. However, they do not enable regular typecase to translucently match abstract types, and they do not easily support higher kinds.
The most interesting question to address in future work is formally proving a form of representation independence for our system. In [24] we prove a rather weak syntactic “Opacity” property, similar to Grossman et al.’s syntactic “Value Abstraction” [12]. We would like to obtain stronger results by applying semantic

techniques like logical relations to this non-parametric setting.
Acknowledgement
I thank Derek Dreyer for helpful comments and suggestions.

References
Mart´ın Abadi, Luca Cardelli, Benjamin Pierce, and Gordon Plotkin. Dynamic typing in a statically- typed language. TOPLAS, 13(2), 1991.
David Aspinall. Subtyping with singleton types. In Computer Science Logic, LNCS 933, 1995.
Karl Crary. Typed compilation of inclusive subtyping. In ICFP, 2000.
Karl Crary. Sound and complete elimination of singleton kinds. TOCL, 8(2), 2007.
Karl Crary, Stephanie Weirich, and Greg Morisett. Intensional polymorphism in type-erasure semantics.
JFP, 12(6), 2002.
Derek Dreyer, Karl Crary, and Robert Harper. A type system for higher-order modules. In POPL, 2003.
Derek Dreyer. Understanding and Evolving the ML Module System. Phd thesis, Carnegie Mellon University, 2005.
Derek Dreyer. Recursive type generativity. JFP, 17(4&5), 2007.
Robert Findler and Matthias Felleisen. Contracts for higher-order functions. In ICFP, 2002.
Cormac Flanagan. Hybrid type checking. In POPL, 2006.
Neal Glew. Type dispatch for named hierarchical types. In ICFP, 1999.
Dan Grossman, Greg Morrisett, and Steve Zdancewic. Syntactic type abstraction. TOPLAS, 22(6), 2000.
Robert Harper and Mark Lillibridge. A type-theoretic approach to higher-order modules with sharing. In POPL, 1994.
Robert Harper and Greg Morrisett. Compiling polymorphism using intensional type analysis. In POPL, 1995.
Robert Harper, John Mitchell, and Eugenio Moggi. Higher-order modules and the phase distinction. In POPL, 1990.
Xavier Leroy. Unboxed objects and polymorphic typing. In POPL, 1992.
Xavier Leroy. Manifest types, modules, and separate compilation. In POPL, 1994.
James Leifer, Gilles Peskine, Peter Sewell, and Keith Wansbrough. Global abstraction-safe marshalling with hash types. In ICFP, 2003.
David MacQueen. Using dependent types to express modular structure. In POPL, 1986.
John Mitchell and Gordon Plotkin. Abstract types have existential type. TOPLAS, 10(3), 1988.
J. Reynolds. Types, abstraction and parametric polymorphism. In Information Procesing, 1983.
Andreas Rossberg. Generativity and dynamic opacity for abstract types. In PPDP, 2003.
Andreas Rossberg. The missing link – dynamic components for ML. In ICFP, 2006.
Andreas Rossberg. Typed Open Programming. Dissertation, Saarland University, 2007. available from
http://www.mpi-sws.mpg.de/∼ rossberg/papers/thesis.pdf .
Claudio Russo. Types for Modules. Dissertation, University of Edinburgh, 1998.
Peter Sewell. Modules, abstract types, and distributed versioning. In POPL, 2001.
Chris Stone and Robert Harper. Extensional equivalence and singleton types. TOCL, 7(4), 2006.
D. Vytiniotis, G. Washburn, and S. Weirich. An open and shut typecase. In TLDI, 2005.

Core λω
Summary

Syntax
base kinds	K ::= Ω | A(τ )
kinds	κ ::= K | SK(τ ) | Πα:κ.κ | Σα:κ.κ types	 τ ::= α | τ → τ | τ × τ | ∀α:κ.τ | ∃α:κ.τ
| λα:κ.τ | ττ | ⟨τ, τ ⟩ | τ.1 | τ.2
terms	e ::= x | λx:τ.e | ee | ⟨e, e⟩ | let⟨x, x⟩ = e in e
| λα:κ.e | eτ | ⟨τ, e⟩ | let⟨α, x⟩ = e inτ e

| new α ≈ τ inτ e | C+
—
τ ≈τ
| typecase e:τ of x:τ.e elseτ e

environments  Γ ::= · | Γ, x:τ | Γ, α:κ
heaps	Δ ::= · | Δ, α:A(τ ) configurations C ::= Δ; e


Higher-order Singletons

S(τ : Ω) := SΩ(τ ) S(τ : A(τ ')) := SA(τ ')(τ )
S(τ : SK(τ ')) := SK(τ ')
S(τ : Πα:κ1.κ2) := Πα:κ1.S(τ α : κ2)
S(τ : Σα:κ1.κ2) := S(τ.1: κ1) × S(τ.2: κ2[τ.1/α])


Static Semantics Environment Formation

· ▶ 



Γ ▶ κ : 
Γ, α:κ ▶  (α ∈/ Dom(Γ))



Γ ▶ τ :Ω 
Γ, x:τ ▶  (x ∈/ Dom(Γ))


Kind Formation


Γ ▶ 

Γ ▶ Ω: 
Γ ▶ τ :Ω Γ ▶ A(τ ): 
Γ ▶ τ : K

Γ ▶ SK(τ ): 
Γ, α:κ1 ▶ κ2 : 

Γ ▶ Πα:κ1.κ2 : 
Γ, α:κ1 ▶ κ2 : 

Γ ▶ Σα:κ1.κ2 : 


Kind Equivalence


Γ ▶ 

Γ ▶ Ω ≡ Ω: 
Γ ▶ τ ≡ τ ' :Ω Γ ▶ A(τ ) ≡ A(τ '): 
Γ ▶ τ ≡ τ ' : K	Γ ▶ K ≡ K' : 

Γ ▶ SK(τ ) ≡ SK'(τ '): 

 Γ ▶ κ1 ≡ κ' :	Γ, α:κ1 ▶ κ2 ≡ κ' :	 Γ ▶ κ1 ≡ κ' :	Γ, α:κ1 ▶ κ2 ≡ κ' : 
Γ ▶ Πα:κ1.κ2 ≡ Πα:κ' .κ' :	Γ ▶ Σα:κ1.κ2 ≡ Σα:κ' .κ' : 
1  2	1  2


Kind Inclusion




Γ ▶ τ ≡ τ ' :Ω 

Γ ▶ A(τ ) ≤ A(τ '): 
Γ ▶ τ :Ω 

Γ ▶ A(τ ) ≤ Ω: 

Γ ▶ 

Γ ▶ Ω ≤ Ω: 
Γ ▶ τ ≡ τ ' : K	Γ ▶ K ≤ K' : 

Γ ▶ SK(τ ) ≤ SK'(τ '): 
Γ ▶ τ : K	Γ ▶ K ≤ K' : 

Γ ▶ SK(τ ) ≤ K' : 

 Γ ▶ κ' ≤ κ1 :	Γ, α:κ' ▶ κ2 ≤ κ' :	Γ ▶ Πα:κ1.κ2 : 
Γ ▶ Πα:κ1.κ2 ≤ Πα:κ' .κ' : 
1  2
 Γ ▶ κ1 ≤ κ' :	Γ, α:κ1 ▶ κ2 ≤ κ' :	Γ ▶ Σα:κ' .κ' : 
Γ ▶ Σα:κ1.κ2 ≤ Σα:κ' .κ' : 
1  2

Type Formation

Γ ▶ 
Γ ▶ α : Γ(α)

Γ ▶ τ1 :Ω	Γ ▶ τ2 :Ω Γ ▶ τ1 → τ2 :Ω 
Γ, α:κ1 ▶ τ2 :Ω Γ ▶ ∀α:κ1.τ2 :Ω 
Γ, α:κ1 ▶ τ2 : κ2

Γ ▶ λα:κ1.τ2 : Πα:κ1.κ2
Γ ▶ τ1 :Ω	Γ ▶ τ2 :Ω Γ ▶ τ1 × τ2 :Ω 
Γ, α:κ1 ▶ τ2 :Ω Γ ▶ ∃α:κ1.τ2 :Ω 
Γ ▶ τ1 : Πα:κ1.κ2	Γ ▶ τ2 : κ1

Γ ▶ τ1 τ2 : κ2[τ2/α]

Γ ▶ τ1 : κ1	Γ ▶ τ2 : κ2[τ1/α]	Γ ▶ Σα:κ1.κ2 : 
Γ ▶ ⟨τ1, τ2⟩ : Σα:κ1.κ2

Γ ▶ τ : Σα:κ1.κ2 Γ ▶ τ.1: κ1
Γ ▶ τ : Σα:κ1.κ2 Γ ▶ τ.2: κ2[τ.1/α]



Γ ▶ τ : Πα:κ1.κ'
Γ ▶ τ : K

Γ ▶ τ : SK(τ )
Γ, α:κ1 ▶ τ α : κ2	Γ ▶ Πα:κ1.κ' : 

	2	2	
Γ ▶ τ : Πα:κ1.κ2
Γ ▶ τ.1: κ1	Γ ▶ τ.2: κ2[τ.1/α]	Γ ▶ Σα:κ1.κ2 : 
Γ ▶ τ : Σα:κ1.κ2
Γ ▶ τ : κ	Γ ▶ κ ≤ κ' : 
Γ ▶ τ : κ'

Type Equivalence

Γ ▶ 
Γ ▶ α ≡ α : Γ(α)
 Γ ▶ τ1 ≡ τ ' :Ω	Γ ▶ τ2 ≡ τ ' :Ω	 Γ ▶ τ1 ≡ τ ' :Ω	Γ ▶ τ2 ≡ τ ' :Ω Γ ▶ τ1 → τ2 ≡ τ ' → τ ' :Ω		Γ ▶ τ1 × τ2 ≡ τ ' × τ ' :Ω 
1	2	1	2

Γ ▶ κ ≡ κ' :	Γ, α:κ ▶ τ ≡ τ ' :Ω Γ ▶ ∀α:κ.τ ≡ ∀α:κ'.τ ' :Ω 
 Γ ▶ κ1 ≡ κ' :	Γ, α:κ1 ▶ τ ≡ τ ' : κ2
Γ ▶ λα:κ1.τ ≡ λα:κ' .τ ' : Πα:κ1.κ2
Γ ▶ κ ≡ κ' :	Γ, α:κ ▶ τ ≡ τ ' :Ω Γ ▶ ∃α:κ.τ ≡ ∃α:κ'.τ ' :Ω 
 Γ ▶ τ1 ≡ τ ' : Πα:κ1.κ2	Γ ▶ τ2 ≡ τ ' : κ1
Γ ▶ τ1 τ2 ≡ τ ' τ ' : κ2[τ2/α]

1	1 2
 Γ ▶ τ1 ≡ τ ' : κ1	Γ ▶ τ2 ≡ τ ' : κ2[τ1/α]	Γ ▶ Σα:κ1.κ2 : 
Γ ▶ ⟨τ1, τ2⟩ ≡ ⟨τ ' ,τ ' ⟩ : Σα:κ1.κ2

Γ ▶ τ ≡ τ ' : Σα:κ1.κ2 Γ ▶ τ.1 ≡ τ '.1: κ1
1  2
Γ ▶ τ ≡ τ ' : Σα:κ1.κ2 Γ ▶ τ.2 ≡ τ '.2: κ2[τ.1/α]

Γ ▶ τ : SK(τ '')	Γ ▶ τ ' : SK(τ '')
Γ ▶ τ ≡ τ ' : SK(τ '')

Γ, α:κ1 ▶ τ α ≡ τ ' α : κ2	Γ ▶ τ : Πα:κ1.κ'
Γ ▶ τ ≡ τ ' : Πα:κ1.κ2
Γ ▶ τ ' : Πα:κ1.κ''

Γ ▶ τ.1 ≡ τ '.1: κ1	Γ ▶ τ.2 ≡ τ '.2: κ2[τ.1/α]	Γ ▶ Σα:κ1.κ2 : 
Γ ▶ τ ≡ τ ' : Σα:κ1.κ2

Γ ▶ τ ≡ τ ' : κ

Γ ▶ τ ' ≡ τ : κ
Γ ▶ τ ≡ τ ' : κ	Γ ▶ τ ' ≡ τ '' : κ

Γ ▶ τ ≡ τ '' : κ
Γ ▶ τ ≡ τ ' : κ	Γ ▶ κ ≤ κ' : 

Γ ▶ τ ≡ τ ' : κ'

Type Inclusion

Γ ▶ τ ≡ τ ' : κ
Γ ▶ τ ≤ τ ' : κ
 Γ ▶ τ ' ≤ τ1 :Ω	Γ ▶ τ2 ≤ τ ' :Ω	 Γ ▶ τ1 ≤ τ ' :Ω	Γ ▶ τ2 ≤ τ ' :Ω Γ ▶ τ1 → τ2 ≤ τ ' → τ ' :Ω		Γ ▶ τ1 × τ2 ≤ τ ' × τ ' :Ω 
1	2	1	2
Γ ▶ κ' ≤ κ :	Γ, α:κ' ▶ τ ≤ τ ' :Ω	Γ ▶ ∀α:κ.τ :Ω Γ ▶ ∀α:κ.τ ≤ ∀α:κ'.τ ' :Ω 
Γ ▶ κ ≤ κ' :	Γ, α:κ ▶ τ ≤ τ ' :Ω	Γ ▶ ∃α:κ'.τ ' :Ω Γ ▶ ∃α:κ.τ ≤ ∃α:κ'.τ ' :Ω 
Γ ▶ τ ≤ τ ' : κ	Γ ▶ τ ' ≤ τ '' : κ
Γ ▶ τ ≤ τ '' : κ

Term Formation

Γ ▶ 
Γ ▶ x : Γ(x)

Γ, x:τ1 ▶ e : τ2

Γ ▶ λx:τ1.e : τ1 → τ2
Γ ▶ e1 : τ1	Γ ▶ e2 : τ2

Γ ▶ ⟨e1, e2⟩ : τ1 × τ2
Γ, α:κ ▶ e : τ

Γ ▶ λα:κ.e : ∀α:κ.τ
Γ ▶ e1 : τ1 → τ2	Γ ▶ e2 : τ1

Γ ▶ e1 e2 : τ2
Γ ▶ e1 : τ1 × τ2	Γ, x1:τ1, x2:τ2 ▶ e2 : τ


Γ ▶ let⟨x1, x2⟩ = e1 in e2 : τ
Γ ▶ e : ∀α:κ.τ	Γ ▶ τ2 : κ

Γ ▶ e τ2 : τ [τ2/α]

Γ ▶ τ : κ	Γ ▶ e : τ2

Γ ▶ ⟨τ, e⟩ : ∃α:κ.τ2
Γ ▶ e1 : ∃α:κ.τ2	Γ, α:κ, x:τ2 ▶ e2 : τ	Γ ▶ τ :Ω Γ ▶ let⟨α, x⟩ = e1 inτ e2 : τ

Γ, α:A(τ1) ▶ e : τ2	Γ ▶ τ2 :Ω 
Γ ▶ τ1 : A(τ2)
Γ ▶ τ1 : A(τ2)

Γ ▶ new α ≈ τ1 inτ2 e : τ2
+
τ1 ≈τ2
: τ2 → τ1
—
τ1 ≈τ2
: τ1 → τ2

Γ ▶ e1 : τ1	Γ, x:τ2 ▶ e2 : τ	Γ ▶ e3 : τ
Γ ▶ typecase e1:τ1 of x:τ2.e2 elseτ e3 : τ
Γ ▶ e : τ	Γ ▶ τ ≤ τ ' :Ω Γ ▶ e : τ '


Conﬁguration Formation

Γ, Δ ▶ e : τ

Γ ▶ Δ; e : τ



Admissible Rules Kind Formation



Γ ▶ τ : κ


Γ ▶ S(τ : κ): 



Type Formation

Γ ▶ τ : κ

Γ ▶ τ : S(τ : κ)



Kind Equivalence

Γ ▶ τ ≡ τ ' : κ	Γ ▶ κ ≡ κ' : 

Γ ▶ S(τ : κ) ≡ S(τ ' : κ'): 


Type Equivalence

Γ ▶ τ : S(τ '' : κ)	Γ ▶ τ ' : S(τ '' : κ) Γ ▶ τ ≡ τ ' : S(τ '' : κ)
Γ, α:κ1 ▶ τ2 : κ2	Γ ▶ τ1 : κ1
Γ ▶ (λα:κ1.τ2) τ1 ≡ τ2[τ1/α]: κ2[τ1/α]
Γ ▶ τ2 : Πα:κ1.κ2
Γ ▶ λα:κ1.τ2 α ≡ τ2 : Πα:κ1.κ2

Γ ▶ τ1 : κ1	Γ ▶ τ2 : κ2

Γ ▶ ⟨τ1, τ2⟩.1 ≡ τ1 : κ1
Γ ▶ τ1 : κ1	Γ ▶ τ2 : κ2

Γ ▶ ⟨τ1, τ2⟩.2 ≡ τ2 : κ2

Γ ▶ τ : Σα:κ1.κ2
Γ ▶ ⟨τ.1, τ.2⟩ ≡ τ : Σα:κ1.κ2

Kind Inclusion


Γ ▶ τ ≡ τ ' : κ	Γ ▶ κ ≤ κ' : 

Γ ▶ S(τ : κ) ≤ S(τ ' : κ'): 
Γ ▶ τ : κ

Γ ▶ S(τ : κ) ≤ κ : 




Dynamic Semantics
Values and Contexts
values	v ::= λx:τ.e | ⟨v, v⟩ | λα:κ.e | ⟨τ, v⟩ | C+



(v)

contexts E ::=	| Ee | vE | ⟨E, e⟩ | ⟨v, E⟩ | let⟨x, x⟩ = E in e
| Eτ	| ⟨τ, E⟩	| let⟨α, x⟩ = E in e
| typecase E:τ of x:τ.e else e

Reduction rules
(Rapp)	Δ; E[(λx:τ.e) v]	→ Δ; E[e[v/x]]
(Rproj)	Δ; E[let⟨x1, x2⟩=⟨v1, v2⟩ in e]	→ Δ; E[e[v1/x1][v2/x2]] (Rinst)	Δ; E[(λα:κ.e) τ ]	→ Δ; E[e[τ/α]]
(Ropen)	Δ; E[let⟨α, x⟩=⟨τ, v⟩ inτ ' e]	→ Δ; E[e[τ/α][v/x]]
(Rnew)	Δ; E[new α≈τ inτ ' e]	→ Δ, α:A(τ ); E[e]

(Rcancel) Δ; E[C−
+ −
+
τ ' ≈τ '
(v))]	→ Δ; E[v]

+ −
(Rcase1) Δ; E[typecase v:τ1 of x:τ2.e1 elseτ e2] → Δ; E[e1[v/x]] if Δ ▶ τ1 ≤ τ2 :Ω (Rcase2)  Δ; E[typecase v:τ1 of x:τ2.e1 elseτ e2] → Δ; E[e2]	if Δ /▶ τ1 ≤ τ2 :Ω 

Full λω
Syntax
expressions	e ::= ·· · | e τ˜ | ⟨τ˜, e⟩ | new α:κ˜ ≈ τ˜ inτ e | C+α:κ˜.τ˜ | C−α:κ˜.τ˜

concrete kinds κ˜
::= Ω | SΩ(τ ) | Πα:κ˜.κ˜ | Σα:κ˜.κ˜
τ˜≈τ˜
τ˜≈τ˜

concrete types τ˜ ::= α | τ˜ → τ˜ | τ˜ × τ˜ | ∀α:κ˜.τ˜ | ∃α:κ˜.τ˜ | λα:κ˜.τ˜ | τ˜ τ˜ | ⟨τ˜, τ˜⟩ | τ˜.i
heaps	Δ ::= · | Δ, α:A(τ˜ : κ˜)

Kind Coercions
T α:κ.Ω(τ )	:= τ
τ+/τ−
T α:κ.SΩ(τ')(τ )	:= τ '[τ /α]

τ+/τ−
+
α:κ.κ˜2 [T α:κ.κ˜1 α1 /α1 ]

T α:κ.Πα1:κ˜1.κ˜2 (τ ) := λα :κ˜ [τ /α].T
α/τ+
(τ (T α:κ.κ˜1 α ))

τ+/τ−
1  1 +
τ+/τ−
α:κ.κ˜2 [T α:κ.κ˜1 (τ.1)/α1 ]
τ−/τ+  1

T α:κ.Σα1 :κ˜1 .κ˜2 (τ ) := ⟨T α:κ.κ˜1 (τ.1), T
α/τ−
(τ.2)⟩

τ+/τ−
τ+/τ−
τ+/τ−

Higher-Order Abstraction Kinds
A(τ : Ω) := A(τ ) A(τ : SΩ(τ ')) := SΩ(τ ')
A(τ : Πα:κ˜1.κ˜2) := Πα:κ˜1.A(τ α : κ˜2)
A(τ : Σα:κ˜1.κ˜2) := Σα:A(τ.1: κ˜1).A(T α:κ˜1.κ˜2 (τ.2) : κ˜2)


Sealing


e :> ∃α:κ˜1.τ˜2 := let⟨α, x⟩ = e in∃α:κ˜ .τ˜ new β:κ˜1 ≈ α in∃α:κ˜ .τ˜

⟨β, C+α:κ˜1 .τ˜2 x⟩

1 2	1 2
β≈α

Static Semantics Term formation


Γ ▶ τ1 : κ˜ 
Γ, α:A(τ1 : κ˜) ▶ e : τ2	Γ ▶ τ2 :Ω Γ ▶ new α:κ˜ ≈ τ1 inτ2 e : τ2

Γ, α:κ˜ ▶ τ˜ :Ω	Γ ▶ τ− : κ˜	Γ ▶ τ+ : A(τ− : κ˜)
Γ ▶ C+α:κ˜.τ˜ : τ˜[τ /α] → τ˜[τ /α]
τ+≈τ−	−	+
Γ, α:κ˜ ▶ τ˜ :Ω	Γ ▶ τ− : κ˜	Γ ▶ τ+ : A(τ− : κ˜)
Γ ▶ C−α:κ˜.τ˜ : τ˜[τ /α] → τ˜[τ /α]
τ+≈τ−	−	+

Admissible Rules Kind Formation

Γ ▶ τ : κ˜ Γ ▶ A(τ : κ˜): 

Type Formation

Γ, α:κ ▶ κ˜ :	Γ ▶ τ− : κ	Γ ▶ τ+ : κ Γ ▶ T α:κ.κ˜ : κ˜[τ /α] → κ˜[τ /α]
τ+/τ−
Term Formation

Γ ▶ e : τ˜ Γ ▶ e :> τ˜ : τ˜ 

Kind Equivalence

Γ ▶ τ ≡ τ ' : κ˜	Γ ▶ κ˜ ≡ κ˜' : 
Γ ▶ A(τ : κ˜) ≡ A(τ ' : κ˜'): 

Type Equivalence

Γ ▶ κ ≡ κ' :	Γ, α:κ ▶ κ˜ :	Γ, α:κ' ▶ κ˜' : 
Γ ▶ τ+ ≡ τ ' : κ	Γ ▶ τ− ≡ τ ' : κ
+	−
Γ ▶ κ˜[τ+/α] ≡ κ˜'[τ ' /α]:	Γ ▶ κ˜[τ−/α] ≡ κ˜'[τ ' /α]: 
+	−
Γ ▶ T α:κ.κ˜ ≡ T α:κ' .κ˜' : κ˜[τ /α]

τ+/τ−
τ ' /τ '	+

+ −
Γ ▶ τ : κ˜[τ−/α]	Γ, α:κ ▶ κ˜ :	Γ ▶ τ+ ≡ τ− : κ

Γ ▶ T α:κ.κ˜(τ ) ≡ τ : κ˜[τ /α]
τ+/τ−
Γ ▶ τ : κ˜[τ−/α]	Γ, α:κ ▶ κ˜ :	Γ ▶ τ+ : κ	Γ ▶ τ− : κ
Γ ▶ T α:κ.κ˜(T α:κ.κ˜(τ )) ≡ τ : κ˜[τ−/α]
τ−/τ+ τ+/τ−
Kind Inclusion


Γ ▶ τ ≡ τ ' : κ˜ 
Γ ▶ κ˜ ≡ κ˜' : 
Γ ▶ τ : κ˜ 

	
Γ ▶ A(τ : κ˜) ≤ A(τ ' : κ˜'):	Γ ▶ A(τ : κ˜) ≤ κ˜ : 
Dynamic Semantics Values and Contexts
values	v ::= · · · | ⟨τ˜, v⟩ | C+α:Ω.α(v) path contexts P ::= | P τ | P.1 | P.2

Reduction rules
Δ; E[new α:κ˜≈τ in e] → Δ, α:A(τ : κ˜); E[e]
C±α:Ω.τ1 →τ2 (v)	→ λx1:τ1 [τ /α]. C±α:Ω.τ2 (v (C∓α:Ω.τ1 x1))

τ+≈τ−
±	τ+≈τ−
τ+≈τ−

C±α:Ω.τ1 ×τ2 (v)	→ let⟨x1, x2⟩ = v in ⟨C±α:Ω.τ1 x1, C±α:Ω.τ2 x2⟩

τ+≈τ−
τ+≈τ−
τ+≈τ−

C±α:Ω.∀β:κ.τ (v)	→ λβ:κ[τ /α]. C±α:Ω.τ' (v (T α:Ω.κβ))

τ+≈τ−
±	τ+≈τ−
τ∓/τ±

where τ ' = τ [(T α:Ω.κβ)/β]
α/τ±
C±α:Ω.∃β:κ.τ (v)	→ let⟨β, x⟩ = v in ⟨T α:Ω.κβ, C±α:Ω.τ' x⟩

τ+≈τ−
τ±/τ∓
τ+≈τ−

where τ ' = τ [(T α:Ω.κβ)/β]
α/τ∓

±α:κ˜.P [β]
+α':κ˜' .P [α' /β:κ˜'][τ±/α]
±α:κ˜.P [τ '/β:κ˜' ]
−α' :κ˜' .P [α' /β:κ˜'][τ∓/α]

Cτ+≈τ−	(v)	→ Cβ≈τ '	Cτ+≈τ−	Cβ≈τ '	(v)
where β /= α and Δ(β)= A(τ ' : κ˜')

C±α:κ˜.P [α](v)	→ C±α:Ω.α
C±α:κ˜.P [τ∓/α:κ˜] (v)

τ+≈τ−
P [τ+/α:κ˜][τ±/α]≈P [τ−/α:κ˜][τ±/α] τ+≈τ−
where P /=

C−α:Ω.α (C+α:Ω.αv) → v

τ+≈τ−
τ ' ≈τ '

+ −
Notes:  1. Omitted surrounding Δ; E[ ] in reduction rules for coercions.
2. All RHS variables fresh.

Path Replacement
P [τ /τ : κ˜]	:= P [α:κ˜.κ˜ α]
τ+/τ−
[α:κ˜.Ω τ ]	:= τ [τ /α]
τ+/τ−
[α:κ˜.SΩ(τ )τ ]	:= τ [τ /α]
τ+/τ−	+
P [ τ '][α:κ˜.Πα1 :κ˜1 .κ˜2 τ ] := P [α:κ˜.κ˜2 [τ '' /α1 ]τ τ ''] where τ '' = T α:κ˜.κ˜1 (τ ')


τ+/τ−
τ+/τ−
α/τ−

P [ .1][α:κ˜.Σα1 :κ˜1 .κ˜2 τ ] := P [α:κ˜.κ˜1 τ.1]
τ+/τ−	τ+/τ−
P [ .2][α:κ˜.Σα1 :κ˜1 .κ˜2 τ ] := P [α:κ˜.κ˜2 [τ.1/α1 ] τ.2]
τ+/τ−	τ+/τ−
