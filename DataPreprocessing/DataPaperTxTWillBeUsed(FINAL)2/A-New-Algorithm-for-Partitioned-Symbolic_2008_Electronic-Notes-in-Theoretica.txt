

Electronic Notes in Theoretical Computer Science 223 (2008) 137–151
www.elsevier.com/locate/entcs

A New Algorithm for Partitioned Symbolic Reachability Analysis
Kai Lampka1
Computer Engineering and Communication Networks Lab.
ETH Zurich, Switzerland

Abstract
Binary Decision Diagrams (BDDs) and their multi-terminal extensions have shown to be very helpful for the quantitative verification of systems. Many different approaches have been proposed for deriving symbolic state graph (SG) representations from high-level model descriptions, where compositionality has shown to be crucial for the efficiency of the schemes. Since the symbolic composition schemes deliver the potential SG of a high-level model, one must execute a reachability analysis on the level of the symbolic structures. This step is the main resource of CPU-time and peak memory consumption when it comes to symbolic SG generation. In this work a new operator for zero-suppressed BDDs and their multi-terminal extensions for carrying out (partitioned) symbolic reachability analysis is presented. This algorithm not only replaces standard BDD-based schemes, it even makes symbolic composition as found in contemporary symbolic model checkers such as Prism and Caspa obsolete.
Keywords: Binary Decision Diagrams and algorithms, symbolic reachability analysis, quantitative verification of systems


Introduction
In our work we focus on the quantitative verification of systems, where symbolic techniques, i.e. techniques based on Decision Diagrams are still state-of-the-art and employed in probabilistic model checkers. Decision diagrams (DDs) are directed acyclic graphs for representing finite functions. Multi-terminal Binary Decision Di- agrams (MTBDDs) [1] are among the most efficient techniques for the state graph (SG) based quantitative analysis of large and complex systems. For obtaining a com- pact and readable description of systems to be analyzed, one commonly employs a (Markovian) description techniques, such as a Stochastic Process Algebra or Gener- alized Stochastic Petri Nets, among many others, rather than directly specifying the system’s behavior by a SG. Many different approaches have been proposed for de- riving symbolic representations of SGs from their high-level descriptions. Roughly

1 Email: lampka@tik.ee.ethz.ch

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.036

speaking, the proposed schemes can be divided into the classes of monolithic - and compositional approaches. Applying a compositional scheme means that the SG of the overall model is constructed from smaller components, commonly from symbolic representations of the SGs of submodels or partitions (submodel- or partition-local SGs). Compositionality turned out to be crucial, since (a) it reduces the run-time, as not all sequences of independent activities have to be extracted explicitly and (b) it induces regularity on the symbolic structures and thus reduces the peak memory consumption. However, symbolic composition is commonly based on symbolic cross- product computation, it therefore delivers the potential SG underlying a high-level model. For restricting the potential transition system to the set of reachable states and transitions, ones must execute a (symbolic) reachability analysis, commonly carried out on the level of the symbolic structures, which represent the potential transition system of the overall model. These symbolic reachability schemes are the main source of CPU time - and memory consumption when it comes to the construction of symbolic SG representations.

Contribution and related work
Based on Bryant’s well known Apply algorithm [3] different symbolic algorithms have been proposed. Following these traditions this paper introduces a new opera- tor for carrying out partitioned symbolic reachability analysis. In its final version this operator makes symbolic composition as found in contemporary compositional symbolic SG generation methods obsolete, –at least as far as the insertion of identity structures is concerned. The presented approach is tailored for compositional SG generation methods and zero-suppressed BDDs (ZBDDs) and their multi-terminal extension (ZDDs) [9,12]. But, it can easily be adapted to standard BDDs [2,3] and their multi-terminal derivatives [1]. In total it might find therefore its application in tools like the (compositional) symbolic model checkers Caspa [8] and Prism [14].
Multi-step reachability schemes
Following [4] earlier work [11,9] (re-) developed a scheme for partitioned symbolic reachability analysis. Like standard breadth-first-search (bfs) symbolic reachability analysis, this scheme can be considered as symbolic multi-step approach, which means that it sequentially executes a number of operators for computing the one- step reachability set with respect to a transition function. But contrary to the standard approach, it executes the symbolically represented transition functions in an activity-wise manner, rather than all at once, This strategy enables one to employ an early-update strategy on the set of states to be explored in the next step, leading to a quasi-depth-ﬁrst-search (q-dfs) scheme rather than implementing a pure bfs - or dfs scheme. A very similar approach, customized for k-bounded Petri nets and a fully symbolic SG generation technique 2 has already been introduced as chaining in [15]. However, contrary to [11,9] and to the approach presented here, the technique

2 Fully symbolic means that the high-level model description technique possesses a symbolic execution semantics.

of [15] is monolithic and therefore most likely to be hampered by large peak memory requirements.
Single-step approaches
The author of [19] gives a highly detailed overview on techniques related to sym- bolic reachability analysis and computation of relational products when one employs BDDs for representing transition relations. The workings [5] and [13] also present algorithms for computing relational products, where in case of the former BDDs and in case of the latter ZBDDs are addressed. Similar to these contributions our new algorithm combines conjunction and existential quantification into a single al- gorithm. However, the here presented work differs with respect to the state graph generation method and thus leads to a different algorithm. Like many other sym- bolic verification tools we also emphasize the usage of high-level modelling methods for describing systems, thus in our approach we assume compositionally constructed transition relations. In such a context one commonly inserts identity structures on the position of the sub-model-independent state variables before combining the in- dividual transition relations and executing a symbolic reachability analysis. The algorithm as introduced here, makes this unnecessary, since it advises an identity semantic when recursing on such variables.

Organization
Sec. 2 introduces the basic setting and makes the reader familiar with Decision Diagrams (DDs). Sec. 3 introduces the new symbolic reachability algorithm. Its practical feasibility is investigated in Sec. 4, where standard benchmarking models as known from the literature are analyzed. Sec. 5 concludes the paper.

Background Theory
Model world
Powerful methods as known from the functional analysis of systems, have been ex- tended to the Markovian case. In the following it is assumed that the reader has basic familiarity with high-level (Markov) model description techniques, such as Generalized Stochastic Petri Net (GSPNs), or Stochastic Process Algebra (SPA) to name only few of them. It is assumed that each high-level model M consists of a finite ordered set of discrete variables commonly denoted as state variables (SVs) with si ∈ S, and a finite set of activities (Act). Each si records the number of tokens in a place, the state of the program or process counter, the values of the process parameters, etc.. By executing activities, one at a time, the model evolves from one state to another, where each SV si takes an arbitrary value from N, and each transition is equipped with the activity’s label and its (exponential) execution rate. This may allow to map a high-level model to a finite transition system or state graph (SG), where this process is commonly denoted as SG generation. A SG con- sists of a (finite) set of states (S), and a transition function. A transition function

is a mapping Δ : S '→ 2S, yielding a predecessor/successor relation →⊆ S ×S on the set of states. If each directed edge is labeled with a symbol l ∈ Act one speaks of a labeled transition system (LTS), yielding the relation → ⊆ S × Act × S. According to the above discussion transitions are not only equipped with labels, but also with
rates r ∈ +. This gives one a stochastic LTS (SLTS) →⊆ S ×Act × + ×S. From
0	0
a SLTS S a Continuous Time Markov Chain (CTMC) can be derived in a straight
forward manner. For exemplification one may refer to part (A) and (B) of Fig. 1 which show a simple SPN and its SLTS.
Compositionality has turned out to be crucial for the effective employment of sym- bolic SG generation techniques. Therefore it is assumed that high-level models are somehow compositionally structured, where analogously to contemporary composi- tional, symbolic SG generation schemes composition is assumed to be achieved via activity synchronization, which is the joint execution of dedicated activities among the model’s partitions or via a joining of SVs, which is the merging of submodels via the sharing of dedicated SVs. 3 Compositionality allows one to group activities and SVs, obtaining a set of partition- or submodel-local dependent SVs (SD) and a set of partition- or submodel-local independent SV (SI ) for each partition or
submodel P of a high-level model M.

Zero-suppressed MTBDDs (ZDDs)
Let  = {0, 1} be the set of Booleans, N = {0, 1, 2,.. .} the set of naturals, and  the set of reals and let  be a finite set of function values (here  ⊂ ). Let V be some global (finite) set of Boolean variables on which a strict total ordering π is defined. The set of variables F := {v1,... , vn} ⊆ V employed in a Boolean function f is denoted as the set of function or input variables of f . Variable vi is essential for a Boolean function if and only if at least for one assignment to the variables of f it holds that f (v1,... , vi−1, 0, vi+1,... , vn) /= f (v1,... , vi−1, 1, vi+1,... , vn). Otherwise the variable vi is not essential. A non-essential variable is also commonly denoted as don’t-care (dnc) variable. In the following n-ary pseudo-Boolean functions are considered, i.e. functions of the type f : n '→ .
A reduced ordered ZDD is a tuple Z=(KNT ,KT ,VZ,π,var,then,else,value,root) where
KNT is the set of non-terminal - or inner nodes and KT the set of terminal nodes, where |KT | ≥ 1 and KNT ∩ KT = ∅.
VZ = {x1, x2,. .. , xn}(⊆ V) is a finite (possibly empty) set of Boolean variables, and t /∈ VZ is a pseudo-variable, labelling the terminal nodes. 4 Since the elements of VZ are ordered, we will also often employ a vector notation, e.g. →x.
π is a strict total ordering on the elements of VZ ∪ {t}, where ∀xi ∈ VZ : xi < t.
var : KNT ∪ KT '→ VZ ∪ {t} such that ∀k ∈ KNT ∪ KT : var(k)= t ⇔ k ∈ KT .
then : KNT '→ KNT ∪ KT such that ∀n ∈ KNT : var(n) < var(then(n)).
else : KNT '→ KNT ∪ KT such that ∀n ∈ KNT : var(n) < var(else(n)).
value : KT '→ , where  ⊂ .
root ∈ KNT ∪ KT .
and the following reduction rules apply:

3 We differ between partitions and submodels, since in case of the former the sets of SVs among the modules are disjoint, where in case of submodels this might not be the case.
4 This (pure technical) extension allows one to include the terminal nodes into the ordering on the elements of VZ.

Isomorphism-free rule: There are no isomorphic nodes; i.e.
6n, m ∈ KNT :
n /= m → (var(n) /= var(m) V then(n) /= then(m)
Velse(n) /= else(m)) and
6n, m ∈ KT :
n /= m → (value(n) /= value(m)).
Zero-suppressing (0-sup.) reduction rule:
/ En ∈ KNT : then(n) ∈ KT Λ value(then(n)) = 0.
A combination of the Shannon expansion for Boolean functions [17] and the ap- plication of the 0-sup. rule gives now that a ZDD’s graph and a set of Boolean variables (together !) uniquely represents a Boolean function [9,12]. Therefore the notation Z<VZ, π> will be employed, if sets of function variables and their ordering is from concern. In case  =  the ZDD is a ZBDD, where also the notation 0-1 ZDD will be employed.
Within shared BDD-environments ZDD-nodes lose their uniqueness as soon as the represented functions are defined on different sets of input variables. To solve this problem, [9,12] introduced the concept of partially shared ZDDs (pZDDs) and algo- rithms for manipulating them. The basic idea of this approach is as follows: When working with pZDDs, i.e. with ZDDs having different set of input variables, one also iterates over the input variables of the operand pZDDs. This allows one to assign a specific semantics to each visited but skipped variable on the current path. The most important algorithms as far as it is from concern here are the followings:
Relabeling: The operation Z{→x ← →y} constructs a pZDD Y representing the function fZ in case variable xi is substituted by variable yi, where ∀yi ∈ Y : yi ∈/ Z must hold.
The generic pZApply-algorithm: A symbolic representation of a function f := g op h for op being a binary operator, e.g. op ∈ {∧, ∨, ∗, ×,.. .} and for two functions g and h, not necessarily defined on the same set of function variables, can be computed by executing the generic pZApply-algorithm. This algorithm takes the binary operator op, the respective operand pZDDs (i.e. their root nodes) and their sets of function variables G and H as input. The basic idea of the pZApply-algorithm is that for a given pair of ZDDs and their sets of variables G and H, a recursion for each variable v ∈ (G ∪ H) is executed. The recursive behavior depends on the type of the current variable, i.e. whether the current variable is a 0-sup. input variable or a (skipped) non-function variable.
The Abstract-algorithm: This algorithm implements the abstraction of a func- tion from a variable v, i.e. the algorithm constructs a representation of the function h := f |v=0op f |v=1, so that v is not a function variable for function h anymore. For op = ∨ the Abstract-algorithm implements the existential
-, and for op = ∧ it implements the universal quantification. It is straight forward to extend the Abstract-algorithm to the case of abstracting from sets of variables.
For simplicity we also allow Boolean operators to be applied to pZDDs, where 0-1 pZDDs are deliver as results.

A stochastic Petri net
The corresponding SLTS
10 10 0


01 10 0



(D) MTBDD representing the SG
00 10 1

a3 a


00 01 1

2
a1	00 00 2
s1	(C) Binary encodings of the SLTS
t1 s2 t2 s3 t3 s4 t4 s5
t5 s6 t6




Figure 1. From a SPN to the symbolic representation of its underlying SLTS




Symbolic SG representation

For symbolically representing a transition system T by a ZDD ZT <→a,→s,→t > the following setting is defined: The variables of →a (a-variables) of the ZDD hold the values of the binary encoded activity labels, variables of →s (s-variables) the ones of the binary encoded source states, and variables of →t (t-variables) the ones of the binary encoded target states of the transitions.
As common we define the following interleaved order on the variables: am ≺
... ≺ a1 ≺ s1 ≺ t1 ≺ ... ≺ sn ≺ tn. For exemplification the reader may please refer to Fig. 1. The Boolean encodings of the transitions of the SLTS are given in table C. The 5 integer SVs are encoded by 6 pairs of Boolean variables (si, ti). Part (D) shows the corresponding ZDD M, where the 0-sup.-nodes are printed in dotted lines, –we did this for illustration purpose, in the actual graph of the ZDD these nodes are not present!– The rates of the transitions are stored in the terminal nodes. In the ZDD, a dashed (solid) line indicates the value assignment 0 (1) to the corresponding Boolean variable on the respective path.

New operator fo symbolic image computation
Preliminaries
Compositionality is crucial for the efficiency of a symbolic SG generation scheme. This is not only because it influences the efficiency of generating and encoding transitions, but also because it significantly influences the speed and memory con- sumption of symbolic reachability analysis. A compositional procedure, as found in tools like Caspa [8], Prism [14] or M¨obius and its symbolic engine [11,9], one either directly exploits the hierarchic structure of compositionally constructed overall mod- els or somehow decompose the latter. In any case one ends up with a set of symbolic representations (BDDs or ZBDDs), each representing a set of (submodel/partition-) local transitions. What follows next is the application of a (symbolic) composition scheme, which implements a synchronization over activity labels in a process algebra like style and/or implements the merging of state variables in the style of stochas- tic activity networks [16]. Details on the symbolic realization of these composition methods can be found in [6,18,7,10] among others. Independent of the employed procedure one may reveal the following similarities of the different schemes:
The symbolic representation of a (submodel/partition-) local transition function takes only those SVs as input variables, which are in the dependency set of the activities encapsulated in the resp. submodel or partition, i.e. one solely encodes here the values of submodel- or partition-local (dependent) SVs SD.
The symbolic structure Z˜T <→s,→t, π>, representing the potential transition system of the overall model is commonly obtained by cross-product computation of some local transition systems and some identity structures. The identity structures

model the behavior on the positions of those SVs SI
which are not effected

(independent) of the resp. submodel or partition.
For restricting Z˜T to the set of reachable transitions one commonly executes a symbolic reachability analysis. As known from the literature (cf. Sec. 1.1) this step should be organized in a partitioned manner.
To enforce a compositional setting the overall model is now assumed to be par- titioned in an activity-wise manner, i.e. each of the high-level model’s activities (l ∈ Act) is encapsulated in its own submodel, –any other partitioning would also be acceptable. This allows one to construct an individual (activity-)local transition
function for each of these (activity-local) submodels, represented by a ZDD Zl <VD>
D	i l
(see [11,9] for details on this construction step). In such a setting Vl  and Vl are
those sets of Boolean variables, which encode the dependent or independent SVs of
submodel l. The cross-product Z˜l := Zl<VD, π> ×⊥1 (Vi) delivers than the potential
l	l
transition system as induced by submodel l, where ⊥1 (Vi) encodes the identity struc- tures as mentioned above. 5 For carrying out symbolic reachability activity-labels

5 Alternatively one could derive Z˜l from Z˜T as follows: Z˜l := Z˜T × A <→a>, where in the above setting A <→a > encodes activity label l, –or in case of a coarser partitioning all activity labels of a submodel l. Consequently the activity-wise partitioning as employed here is not mandatory, any other fragmentation is suitable, as long as one ends up with local transition functions and their sets of dependent and independent SVs, their Boolean counterparts resp..

are irrelevant, so that they can safely be removed. This is achieved by computing an existential quantification over all a-variables and over all local symbolic structures Z˜l. In such a setting and if the set of (unexplored) states is represented by a ZDD
Zunex<→s, π> the one-step reachability set with respect to activity l can be computed by the following code fragment:
Ztmp := pZApply(∧, Zunex, Z˜l)
Ztmp := ZAbstract(Ztmp,→s, ∨)
Zunex := Ztmp{→s ← →t}
In the above pseudo-code one extracts at first all transitions emanating from states contained in Zunex (line (0)). Subsequently one eliminates the source states (line
(1)) and re-labels the t-variables with t-variables (line (2)), which delivers the newly reached states encoded as source states. The first version of our new operator ExecuteActivity() implements these steps in a single operator.
The new scheme
When traversing the symbolic structures representing the unexplored states (Zunex) and the potential, local transition functions (Z˜l) the new algorithm Execute- Activity executes a recursion for each variable ∈ V(= →s ∪→t). Let vc be the variable of the current recursion: if vc is not skipped within the ZDDs Zunex and Z˜l, the stan- dard Apply-recursion rule is executed [3], otherwise the following case distinctions apply:
Handling of structure Zunex: Let variable vc be a s-variable, i.e. it encodes a bit position of the source state. Since vc is skipped, it must be a 0-assigned vari- able, due to the 0-sup.-reduction rule. Concerning the recursive behavior the else-child to recurse on in the next step is the current node within Zunex itself, whereas the then-child to recurse further with must be the terminal 0-node (= semantics of a 0-sup. node). In case the current variable vc is a t-variable, it is non-decisive for ZDD Zunex, since it holds a bit value of the binary encoded target state. In such cases a don’t-care semantics must be applied,
i.e. one recurses with the current node of Zunex into the else- and then-branch.
The handling of Z˜l is straight-forward: in case vc is skipped it must be 0-sup. and the 0-sup. recursion rule applies.
Part A of Fig. 2 shows ZDD Zunex which represents the initial state of the SPN of Fig. 1.A, and ZDD Z˜l representing the potential and local transition function as induced by high-level activity a of the SPN. In part C we depicted ZDD Z' which represents the image of Zunex with respect to transition function Z˜l. –One may already note that within Z˜l positions referring to variables which are independent of the execution of activity a, here {s3, .., t6} , are filled with identity structures.– Fig. 2.B depicts the call tree of the new operator when recursing on the first 5 variables, where the parameter-lists of the individual function calls are also given. This parameter list contains the current node of the structure representing the set





(A) Operand ZDDs	(B) Call tree (arguments only)	(C) Result

s1	s1
t1
s	t1
g, f, {s1,...s6},{s1,..,t6}	s1
Return
t1
0, 0, {s2,...s6},{t1,..,t6}

Return 0
2
s3
n, k, {s2,...s6},{t1,..,t6}	s2
Return	t2
s3

t3	n, k, {s2,...s6},{s2,..,t6}
2
s4
t4
n, 0, {s2,...s6},{s2,..,t6}
3
s4 t4

s5	0, 0, {s3,...s6},{t2,..,t6}	n, k, {s3,...s6},{t2,..,t6}	s5

5	Return 0
s6
Allocate + Return
t5
s6

t6	s
n, 0, {s3,...s6},{s3,..,t6}
n, l, {s3,...s6},{s3,..,t6}	t

3

Z	Z˜l := Zl<VD, π> ×⊥1 (Vi)
Return	Return
6


Z'

unex	l	l	unex
Figure 2. ZDD-traversal for computing the one-step reachability set

of source states (Zunex), the current node of the ZDD representing the potential transition function (Z˜l) as well as the individual sets of function variables of these ZDDs. The first else-branch recursion is than called with the terminal 0-node,
whereas the then-branch is executed with node n and k (cf. Fig. 2.A and B). The next variable to be visited within this then-branch is variable t1, where a dnc-semantics in case of Zunex and a 0-sup.-semantics in case of Z˜l applies. I.e. within the new else-branch one recurses with n and k, whereas in case of the new
then-branch a recursion with node n and the terminal 0-node is started. In cases where a terminal 0-node is encountered the recursion can terminate by returning the terminal 0-node as result. In all other cases the recursion basically continues
until the terminal non-zero nodes of Zunex and Z˜l are reached (see line 1 - 5 of
Algo. ExecuteActivity, Fig. 3). When returning from the recursion one either allocates a node or abstracts from the (current) variable. I.e. when the recursion returns at a s-variable the 1- and 0-successor of the potential node must be merged, since the operator must abstract from source states. In case the recursion returns at a t-level a node for the preceding s-variable is allocated. This behavior can be found in the call-tree of Fig. 2.B at level 4, i.e. at the level of variable t2: There node a is allocated (labelled with variable s2) and past back as result of the computation. The caller of this recursive step computes then pZApply(+, 0, a) (= a) and returns it as result to its own caller. This functionality is encoded within line 55-60 of algorithm ExecuteActivity as illustrated in Fig. 3. However before we go into detail of its pseudo-code, another recursion-rule shall be covered. This rule will make the insertion of identity structures as found in contemporary

ExecuteActivity
Parameters: Node : g, f, V arSet : G, F , V, Bool : skipF lag

Node res;

/∗ Check terminal condition ∗\
if g = 0-node ∨ f = 0-node
then return 0-node;
else if vc = ∅
then return 1-node;
else if skipF lag then
if g, f ∈ KT
then return 1-node;
else if g = f ∧F = V
then return 1-node;

/∗ Check for pre-computed results ∗\
if vc ∈ →s ∨ vc ∈ F then
res := CacheLookup(f, F ,g, G);
if res /= c return res;

/∗ Prepare recursive step ∗\
Node f 1, f 0, g1, g0, T, E;
var	vg := min(G),
v := min(F ), vc := min(V);
/∗ Obvious both variables contained ∗\
if v  = vc ∧ vg = vc then
(	f 1 := then(f );
f 0 := else(f );
g1 := then(g);
g0 := else(g);
/∗ only var skipped in g, ∗\
/∗ thus vc is func.var for f ∗\
else if v = vc then
/∗ skipped var is assumed to be 0-sup. ∗\
/∗ and func. var ∗\
else f 1 := 0-node;
/∗ obviously level skipped in both graphs ∗\
else
/∗ Fast Fwd to node with smallest var ∗\
if skipF lag then
vc := min(vg, v );
while vc < max(V) do V := V \ max(V); end
while vc < max(F) do F := F \ max(F); end
while vc < max(G) do G := G \ max(G); end
return ExecuteActivity(g, G,f, F , V, true);
/∗ default: skipped var is non-func. s-var ∗\
f 0 := f ;
f 1 := f ;
g0 := g;
/∗ default: skipped level in g is 0-assigned ∗\
g1 := 0-node;
/∗ is t-var thus dnc in g ∗\
/∗ and assume 0-sup. t-var in f ∗\
if vc ∈ →t then
g1 := g;
f 0 := 0-node;
/∗ fast fwd in else-branch if non-func. s-var ∗\
else
v  := succ(vc );
/∗ skipped but func. var ∗\
if vc ∈ →s then
f 1 := 0-node;
f 0 := f ;
v := vc ;

f 1 := then(f );
f 0 := else(f );
g0 := g;
/∗ Remove variables from sets ∗\
F' := F \ {vc }), F '' := F \ {vc, v });

'	''	k

/∗ is t-var and dnc in g or s-var and 0-sup. ∗\
if vc ∈ →t then
g1 := g;
G := G \ {vc }), G  := G \ {vc, v });
V := V \ {vc }), V  := V \ {vc, v });

else g1 := 0-node:
/∗ go into recursion ∗\
T := ExecuteActivity(g1, G''

,f 1, F

'' , V''

, skipF lag));

/∗ var skipped within f => must be s-var ∗\
E := ExecuteActivity(g0, G ,f 0, F , V , skipF lag));

else if vg = vc then
g1 := then(g);
g0 := else(g);
f 0 := f ;
/∗ skipped but non-func. s-var ∗\
if v /∈ F then
f 1 := f ;
/∗ fast fwd in else-branch, ∗\
/∗ disabled for then-branch ∗\
'	'  '

/∗ allocate node if t-var, abstract if s var ∗\
if vc ∈ →t then
res := getZMTBDDNode(pred(vc ),T, E)));
else
res := pZApply(+,T,E);
/∗ Cache pre-computes ∗\
if vc ∈ →s ∨ vc ∈ F then
CacheInsert(res, f, F , g, G);

v  := succ(vc );

skipF lag := false
return res;

Figure 3. New algorithm for computing one-step reachability set
composition schemes and as illustrated above unnecessary. Instead of operating on Z˜l this new rule allows one to directly employ the local transition systems, their symbolic counterparts resp., when computing the one-step reachability set of a set of
source states and with respect to a submodel l. The main idea of doing so is straight- forward: when traversing Zl, its non-function variables are handled according to an identity-semantics. –In the example of Fig. 2 this is the case for Z˜l when hitting variables {s3,... , t6}.
Let V be the set of all function variables for encoding the overall model’s transition system (V := →s ∪ →t). Let G := →s and J ⊆ V be the set of function variables for the symbolic structures Zunex and Zl (not Z˜l !). Let the variable of the current
recursion be denoted vc, the one-step reachability operator must cover the following additional case when accessing a non-function variable (vc /∈ J) within the symbolic

encoded transition function Zl:
If vc is a s-variable one simply recurse with the current node into the else- and then-branch, where a node must be allocated for vc only if there is a node allocated within Zunex, which gives way for skipping variables (see discussion below). In case vc is a t-variable a more complex behavior depending on the current recursion applies: (i) Within the then-branch of the recursion the else- child of the current node is the terminal 0-node and the then-child is the current node itself. (ii) Within the else-branch of the recursion one is enabled to skip one recursive call, since the node to be allocated here would be eliminated due to the 0-sup.-reduction rule anyway.
The whole functionality of the new operator is implemented by algorithm Execute- Activity as illustrated in Fig. 3. This algorithm takes the root nodes of the sym- bolic structure Zunex and Zl as arguments (here g and f ), their sets of function vari- ables (here G and J) and the set of all function variables V, –the Boolean parameter skipFlag is irrelevant for the time being. In line 11 - 51 the different recursions are prepared by setting the parameters of future function calls accordingly, where the recursion is actually executed in line 55 and 56. Once the algorithm returns from a recursion one allocates a node or abstracts from the current variable vc (line 57 -60, as discussed above). One may also note that the caching of pre-computed results is intricate, since in case of non-function variables solely results for s-variables can be stored or fetched, otherwise one terminates with wrong results (line 61 together with line 6). Another important feature of the algorithm is the skipping of vari- ables of V, if on the current path no node labelled with the current variable appears. Such variables can be ignored as long as the last visited variable was /∈ →s, was not a non-function variable for Zl (vc /∈ J) and did not refer to the last node visited in Zunex. Otherwise the recursion must stop at the resp. variable, so that a node can be allocate on the respective path. The status bit for handling such cases is set in line 30, where the skipping of the variables is implemented in line 33-38. For computing now the set of all reachable states algorithm ExecuteActivity must be repetitively executed until a fixed point is reached. This can be done by replacing the three steps of multiplication, abstraction and relabelling (see code fragment above) as found in symbolic reachability algorithms by our new algorithm, where the commonly executed insertion of identity structures is also obsolete.
Finally it is also worth noting that in order to implement algorithm Execute-
Activity for BDDs and standard Multi-terminal Binary Decision Diagrams [1] one need to adapt the terminal conditions, the conditions for cache look-ups and in- sertion, and assign the current node g (f ) resp., to the then-child g1 (f 1) instead of the 0-node (line 22,31,42,45). Also it must be taken care of the node allocating function, so that it implements the correct node elimination rule (line 58).
For exemplification one may refer to Fig. 4, where contrary to previous illustrations we depicted now true ZDDs. Zunex represents state (1, 0, 0, 1, 0) and (0, 1, 0, 1, 0) of the SPN of Fig. 1. Let Zl encode now the transitions as induced by submodel S consisting of activity c and d and their pre- and post-sets of SVs. This gives that


s1 t1 s2 t2 s3 t3 s4 t4 s5 t5 s6 t6


Zunex
Zl := Z

{c,d}
'
unex

Figure 4. Source state, submodel-local transition function and one-step reachability set

Fault-tolerant Multi-processor System (FTMP)
   
Courier Protocol (CP)

Kanban Manufacturing System (Kanban)

Flexibe Manufacturing System (FMS)
Cyclic Server System (Polling)
   

Table 1
Run-times and peak memory consumptions of BDD-based symbolic reachability analysis

the variables {s1,... , t2} are non-function variables for Zl, whereas {s3,... , t6} are its input variables. Within the first recursive call the else-branch takes node l and f as argument, and the then-branch takes node h and f as argument. As one can see, it is often also not necessary to stop for each variable in V, since when return- ing from the recursion sometimes no node will be allocated at the respective level,
e.g. between node k of ZDD Z'	and the nodes at level s2 and s1 no nodes are
allocated, which gives way for optimization of the algorithm as illustrated above.

Emperical Evaluation
In previous work the M¨obius modeling tool was extended with a ZDD-based sym- bolic engine [11]. As standard for semi-symbolic methods this engine also executes explicit SG exploration and encoding, but most likely for a limited number of tran- sitions only. The large majority of transitions is generated by executing a symbolic composition scheme. which requires also the execution of a symbolic reachability scheme for identifying non-reachable transitions within the symbolic structures. As for pure symbolic schemes, the major CPU time - and memory consumption is therefore here also imposed by the symbolic reachability analysis. Consequently this framework is highly suited for benchmarking the new algorithm. Table 1 shows the different run-times when analyzing standard benchmarking models from the literature, where we employed a standard bfs symbolic reachability analysis scheme (stand. scheme), the partitioned quasi-dfs. scheme (partitioned RA) as introduced in [11] and our new algorithm (1-step RA). We give the model scaling parameter N , the columns of #states and #trans. report the size of the model’s underlying CTMCs and V refers to the number of Boolean variables employed for encoding each system transition. For benchmarking the new algorithm the run-times of the schemes are given in sec. (t), as well as the peak memory consumption, where we recorded the max. number of nodes allocated (#nod.). As indicated by the data of Table 1, the new algorithm improves the run-time and lowers the peak memory consumption in almost all cases, –up to this end we can not really explain the be- havior of the CP model for N = 15.– The data makes clear that the partitioning of the transition relations has the largest impact on the run-time and memory re- ductions. But nevertheless, combining the different steps of symbolic reachability analysis within a single BDD-operator and making the explicit insertion of iden- tity structures obsolete improves the situation further, where the new algorithm in particular works well for models with very large state descriptors as demonstrated by the FTMP model. Finally one may note that in case we do not construct the transition rate matrix of the overall model, which is required for solving the model’s underlying CTMC, peak memory consumption could even be reduced further up to a factor of 0.5 in case of the FTMP model. However, this seems to be insignificant for the run-time of the scheme, since this clearly stems from reachability analysis
and not from computing the overall transition rate matrix which can be constructed

by evaluating Σ

l∈Act
Zl × ⊥1 (Vi) × Zreach.

Conclusion
In this paper we presented a new scheme for carrying out symbolic reachability analysis. The newly introduced algorithm computes the one-step reachability set for a set of states and with respect to a (local) transition function within a sin- gle BDD-operation. Contrary to existing approaches the here presented algorithm makes symbolic composition unnecessary, which is achieved by defining an identity semantics within the (local) transition functions on the positions of non-function variables. As demonstrated by the collected run-time data the new algorithm may

reduce the run-time and memory requirement of contemporary BDD-based schemes. The approach can be easily adapted to the case of standard BDDs and their multi- terminal derivatives. It could find therefore its application in contemporary quanti- tative symbolic model checkers such as Caspa [8] or Prism [14]. However, the success of tools such as Prism [14], Caspa [8] (both based on MTBDDs) and M¨obius with its ZDD-based engine, is largely due to the efficiency of the employed symbolic data structures.In the context of high-level model descriptions, a model’s state commonly consists of many state counters, each referring to the state of a local process, to the current value of a specific process parameter, to the number of tokens in a specific place of a Petri net, etc.. When making use of BDD-based structures in such a setting, each state counter is encoded in binary form by n bits, leading to a large number of bit positions filled with zeroes and to a possible small number of encod- ings of reachable states with respect to all possible 2n state labelling. In such a setting MTBDDs and especially ZDDs have shown to be very helpful, as long as their space complexity is restricted. In such an area the here proposed algorithm seems to be a useful innovation. However if other BDD-based approaches it will also fail in cases of highly populated DDs, due to its recursive nature and due to the finiteness of operator caches.

References
Formal Methods in System Design: Special Issue on Multi-terminal Binary Decision Diagrams, Volume 10, No. 2-3, April - May 1997.
S.B. Akers. Binary Decision Diagrams. IEEE Transactions on Computers, C-27(6):509–516, June 1978.
R.E. Bryant. Graph-based Algorithms for Boolean Function Manipulation. IEEE Transactions on Computers, C-35(8):677–691, August 1986.

J.R. Burch, E.M. Clarke, and D.E. Long. Symbolic Model Checking with Partitioned Transition Relations. In A. Halaas and P.B. Denyer, editors, International Conference on Very Large Scale Integration, pages 49–58, Edinburgh, Scotland, 1991. North-Holland.
E. M. Clarke, O. Grumberg, and D. A. Peled. Model checking. The MIT Press, Cambridge, MA (USA), 1999.
L. de Alfaro, M. Kwiatkowska, G. Norman, D. Parker, and R. Segala. Symbolic Model Checking for Probabilistic Processes using MTBDDs and the Kronecker Representation. In S. Graf and
M. Schwartzbach, editors, Proc. of the 6’th Int. Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS’00), Berlin (Germany), LNCS 1785, pages 395–410, Berlin, 2000. Springer.
M. Kuntz and M. Siegle. Deriving Symbolic Representations from Stochastic Process Algebras. In
Process Algebra and Probabilistic Methods (PAPM-PROBMIV’02), LNCS 2399, pages 1–22, 2002.
M. Kuntz, M. Siegle, and E. Werner. Symbolic Performance and Dependability Evaluation with the Tool CASPA. In Proc. of EPEW, pages 293–307. Springer, LNCS 3236, 2004.
K. Lampka. A symbolic approach to the state graph based analysis of high-level Markov reward models. PhD thesis, University of Erlangen-Nuremberg, Erlangen (Germany), 2007.

K. Lampka and M. Siegle. Symbolic Composition within the Moebius Framework. In Proc. of the 2nd MMB Workshop, pages 63–74, September 2002. Forschungsbericht der Universit¨at Hamburg Fachbereich Informatik.
K. Lampka and M. Siegle. Activity-Local State Graph Generation for High-Level Stochastic Models. In Meassuring, Modelling, and Evaluation of Systems 2006, pages 245–264, April 2006.


K. Lampka, M. Siegle, J. Ossowskis, and C. Baier. Partially-shared zero-suppressed Multi-Terminal BDDs: Concept, Algorithms and Applications, 2008. Article submitted for publication, a preliminary version can be downloaded as technical report from ftp.tik.ee.ethz.ch/pub/publications/TIK-Report-
289.pdf.
O. Lhot´ak, S. Curial, and J.N. Amaral. Using ZBDDs in Points-to Analysis. In Proc. of the 20th International Workshop on Languages and Compilers for Parallel Computing, October 2007.
PRISM. http://www.cs.bham.ac.uk/∼dxp/prism/.
Oriol Roig, Jordi Cortadella, and Enric Pastor. Verification of asynchronous circuits by BDD-based model checking of Petri nets. In 16th International Conference on the Application and Theory of Petri Nets, volume 815, pages 374–391, 1995.
W.H. Sanders. Construction and solution of performability models based on stochastic activity networks. PhD thesis, University of Michigan, 1988.
C.S. Shannon. Eine symbolische Analyse von Relaisschaltkreisen. Verlag Brinkmann + Bose, 2000. The article originally appeared with the title: A Symbolic Analysis of Switching Circuits in Transactions AIEE, 57 (1938), 713.
M. Siegle. Advances in model representation. In Luca de Alfaro and Stephen Gilmore, editors, Process Algebra and Probabilistic Methods, LNCS 2165, pages 1–22. Springer, September 2001. Proc. of the Joint Int. Workshop, PAPM-PROBMIV 2001, Aachen (Germany).
F. Somenzi. Binary decision diagrams. Calculational System Design, 173:303–366, 1999.
