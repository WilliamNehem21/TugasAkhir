Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 283 (2012) 77–109
www.elsevier.com/locate/entcs

Formal Relationships Between Geometrical and Classical Models for Concurrency
E´ric Goubault and Samuel Mimram1
DILS/MeASI, Institut Carnot CEA LIST CEA Saclay Nanoinnov, point courrier 174 Gif-sur-Yvette
F-91191, France.


Abstract
A wide variety of models for concurrent programs has been proposed during the past decades, each one focusing on various aspects of computations: trace equivalence, causality between events, conflicts and schedules due to resource accesses, etc. More recently, models with a geometrical flavor have been intro- duced, based on the notion of cubical set. These models are very rich and expressive since they can represent commutation between any number of events, thus generalizing the principle of true concurrency. While they are emerging as a central tool in concurrency, which is very promising because they make possible the use of techniques from algebraic topology in order to study concurrent computations, they have not yet been precisely related to the previous models, and the purpose of this paper is to fill this gap. In particular, we describe an adjunction between Petri nets and cubical sets which extends the previously known adjunction between Petri nets and asynchronous transition systems by Nielsen and Winskel.

A great variety of models for concurrency was introduced in the last decades: transition systems (with independence), asynchronous automata, event structures, Petri nets, etc. Each of these models focuses on modeling a particular aspect of computations, and even though their nature are very different, they are tightly re- lated to each other as witnessed in [43]. More recently, models inspired by ideas coming from geometry, such as cubical sets (also sometimes called higher dimen- sional automata or HDA [30,18]) or local po-spaces [12], have emerged as central tools to study concurrency: thanks to their nice algebraic structure, they allow one to carry on abstractly many computations, and they are very expressive because of their ability to represent commutations between multiple events. However, since their introduction, they have not been systematically and formally linked with the other models, such as transition systems, even though cubical sets contain a notion of generalized transition in their very definition.

1 This work has been supported by the PANDA (“Parallel and Distributed Analysis”, ANR-09-BLAN-0169) French ANR project.

1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.05.007

From a scientific point of view, the mere observation that these models are dif- ferent is not satisfactory and their links with other models have to be investigated in depth. However, it turns out that their relationship is often quite subtle: the various models are usually not isomorphic, nor even one is a retract of the other. Adjunctions between the categories of models, which generalize Galois connections to categories, are the right notion to relate and compare them. This was first stud- ied in the context of operational models for concurrency by Winskel et al. [43] and extended to geometrical models [15], but only between fairly restricted categories. In this paper, we greatly improve previous work by extending it to the full cate- gories of transition systems (operational model of “interleaving” concurrency) and of transition systems with independence (operational model of “true” concurrency). Another approach to compare these models, based on history-preserving bisimula- tions, is developed in [40]. The main motivation underlying this work is that, by relating these models, we can compare the semantics of concurrent languages given in different formalisms. This also allows for reusing specific methods for statically analyzing concurrent programs in one model (such as deadlock detection algorithms for cubical sets [11], invariant generation on Petri nets [32], state-space reduction techniques such as sleep sets and persistent sets in Mazurkiewicz traces [14], or stubborn sets in Petri nets [37]) in the other.
This paper constitutes a major step towards formally relating geometric models with other models for concurrency. The links might appear as intuitive, but the formal step we are making underlines subtle differences between the models: there are many variants of the models, all of which can be embedded in the model of HDA, which allows us to precisely characterize the outcomes of choosing one of the other variant of the models. We have done our best to express in categorical terms how to construct one variant from the other. In particular, most models admits the following variations:
events can be labeled or not,
morphisms can be strict or partial,
the multiplicity of an event can be taken in account or not,
in the case where the events are labeled, morphisms between labels can be strict or not.
It turns out from this study that strongly labeled HDA seem to be the right notion of HDA, at least for comparing with most other common models of concurrency. This also unravels interesting phenomena (besides being necessary for being able to relate semantics given in different styles) such as the fact that persistent set types of methods for tackling the state-space explosion problem can be seen as searching for retracts of the state space, in the algebraic topological sense. We end this article by making some hypotheses on further relationships, with event structures and Petri nets in particular.
Related work. In this paper, we extend Winskel’s results [43], which include adjunctions between transition systems, event structures, trace languages, asyn-

chronous transition systems and Petri nets which are still an active research area [36]. A first step towards comparing higher-dimensional automata (a form of geometric semantics we are considering here), Petri nets, and event structures is reported in [39]. Also, an investigation of the comparison between cubical sets (another form of geometric semantics) and transition systems, as well as transition systems with independence was started in [16], but never formally published.
We describe right adjoint functors from the categories of transition systems, asynchronous transition systems, Petri nets and prime event structures of [43], to HDA. By general theorems, these functors transport limits onto limits, hence pre- serve classical parallel semantics based on pullbacks, by synchronized products [1], as the ones in transition systems or the ones of [43]. Cubical sets (or more gener- ally HDA) that we take as the primary model for geometric semantics here, have appeared in numerous previous works, in algebraic topology in particular [34,4]. A monoidal presentation can also be found in [20]. The basics of “directed alge- braic topology” that is at the basis of the mathematics involved in the geometric semantics we use here can be found in [19].
Contents of the paper. We begin by recalling the geometric model provided by cubical sets in Section 1 and some well-known models for concurrent computations (transition systems, asynchronous automata, event structures and Petri nets) in Section 2. We then relate them by defining adjunctions in Section 3. HDA naturally “contain” transition systems (resp. asynchronous transition systems), which just encode the non-deterministic (resp. and pairwise independence) information. Event structures are also shown to be more abstract than HDA: they impose binary conflict relations and conjunctive dependencies (an event cannot depend on a disjunction of two events), and they do not distinguish different occurrences of the same event. Petri nets have a built-in notion of degree of parallelism, as is the case of HDA (given by cell dimension) but impose specific constraints on dynamics. We finally conclude on future works in Section 4.



Geometric models for concurrency
Precubical sets can be thought as some sort of generalized transition systems with higher-dimensional transitions. Similarly to transition systems there is a corre- sponding notion with “idle transitions”, called cubical sets. These classical objects in combinatorial algebraic topology (see for instance [34]) have been used as an alternative truly concurrent model for concurrency, in particular since the seminal papers [30] and [38]. More recently, they have been used in [11] and [12] for deriv- ing new and interesting deadlock detection algorithms. More algorithms have been designed since then, see for instance [31] and [9]. In the following, we will be mostly using symmetric precubical sets. However, we have done our best to introduce here the notion gradually, and recall some variants as well as important properties.

Cubical sets
A cubical set consists of a family (C(n))n∈N of sets, the elements of C(n) being called n-cells, together with for every pairs of integers n and i, such that 0 ≤ i ≤ n, maps
∂—, ∂+ : C(n + 1) → C(n)	and	ιi : C(n) → C(n + 1)
i	i
respectively called source, target and degeneracy maps, satisfying


∂β∂α = ∂α∂β
ιiιj = ιj—1ιi	(1)

j  i	i  j—1
with i < j and α, β ∈ {−, +} and, for every α ∈ {−, +},
⎧⎪ιi∂α	if i < j 

∂αιi =
j—1
id	if i = j
(2)

⎪⎩ιi—1∂α
if i > j 

A morphism κ : C → Cj between two cubical sets C and Cj consists of a fam- ily (κn : C(n) → Cj(n))n∈N of functions which is natural: for every index i and α ∈ {−, +},
κn ◦ ∂α = ∂α ◦ κn+1	and	κn+1 ◦ ιi = ιi ◦ κn
i	i
and we write CSet for the category thus defined. The 0-source (resp. 0-target ) of an n-cell x ∈ C(n) is the 0-cell ∂— ... ∂—(x) (resp. ∂+ ... ∂+(x)).
0	0	0	0
More conceptually, a cubical set C is a presheaf on the cubical category  , that is
a functor C : op → Set, and a morphism of cubical sets is a natural transformation between the corresponding functors. Here, the cubical category is defined as the free category on the graph whose objects are natural integers n ∈ N and containing, for every integers i and n such that 0 ≤ i ≤ n and every α ∈ {−, +}, arrows


α i,n
: n → n + 1	and	ηi,n : n +1 → n	(3)

quotiented by the relations expressing axioms dual to those given for cubical sets (1)

and (2) – so that for every index n, the function C(εα
) corresponds to ∂α
and

C(ηi,n) corresponds to ιi:


β i,n+1
α j,n
α j—1,n
β i,n+1
ηj,nηi,n+1 = ηi,nηj—1,n+1	(4)

with i < j and α, β ∈ {−, +}, and for every α ∈ {−, +},


α
⎨ j—1,n—1
	

ηi,n—1	if i < j 

α j,n—1
ηi—1,n—1	if i > j.



The precubical category © is defined similarly with only the εα
as generators

and the first equations of (4) as axioms, and a precubical set is a presheaf on the

precubical category: a precubical set consists of a family (C(n))n∈N of sets together with a family of maps ∂—, ∂+ : C(n + 1) → C(n) satisfying the equations on the left
i	i
of (1). We write PCSet for the corresponding category.
Given an integer n, we write n for the full subcategory of whose objects are the integers k ≤ n. An n-dimensional cubical set is a presheaf on n and we write CSetn for the category of n-dimensional cubical sets. The inclusion func- tor n →  induces by precomposition a functor Un : CSet → CSetn called the n-truncation functor (see Section 1.7).
Example 1.1 The geometric intuition underlying cubical sets is the following one. An n-cell x of a cubical set should be seen as an n-dimensional cube, the (n − 1)-di- mensional cubes ∂—(x) and ∂+(x) being respectively the source and target in di-
i	i
mension i of x, and the degeneracy maps ιi allowing us to see an n-dimensional
cube as an (n + 1)-dimensional one, degenerated in dimension i. So for example, a “cylinder” can be described as a precubical set C with

C(0) = {x, y}	C(1) = {f, g, h}	C(2) = {α}	C(n)= ∅	for n > 2

with the following sources and targets, given by ∂—(f ) = ∂+(f ) = ∂—(h) = x,
0	0	0
∂—(g)= ∂+(g)= ∂+(h)= y, ∂—(α)= ∂+(α)= h, ∂—(α)= f and ∂+(α)= g. This
0	0	0	0	0	1	1
cylinder can be pictured graphically as

x   h  y ¸

α	or
f	α	g
(in an unfold representation)

xJ 
h
 yJ¸ 


From a concurrency point of view, a 1-cell corresponds to the occurrence of an event (an action) and an n-cell corresponds to a commutation or an independence between the 1-cells occurring in its faces. The cubical set above representing the cylinder thus corresponds intuitively to a program constituted of two processes in parallel: a (while) loop (the actions f and g) and a single instruction (h). See also Example 1.9.
In previous example, the two transitions f and g are instances of a same event because they are parallel faces of the square α. This suggests that the notion of event should be reconstructed in a precubical set as an equivalence class of transitions as follows. Suppose given a precubical set C. We define a relation ≈ as the smallest equivalence relation on 1-cells of C, such that for every f, g ∈ C(1), f ≈ g when there exists y ∈ C(2) such that f = ∂—(y) and g = ∂+(y), for i =0 or i = 1. An event is
i	i
the equivalence class of a 1-cell under the relation ≈. Given a morphism κ : C → D
between precubical sets, two 1-cells of D in a same event are sent to two 1-cells of D in a same event; any such morphism thus induces a function κ1/ ≈ from the events of C to the events of D.

A monoidal deﬁnition of the cubical category
A shorter description of the cubical category can be given if we take its monoidal structure in account: the cubical category is the free monoidal category (that is, a category equipped with a coherent tensor product and unit [24]) containing a co-cubical object [20]. This will help in defining very concisely the adjunctions we have in mind in Section 3.
Definition 1.2 A cubical object (C, ε—, ε+, η) in a monoidal category (C, ⊗,I) con- sists of an object C together with three morphisms
η : I → C	ε— : C → I	ε+ : C → I


such that

ε— ◦ η	=	idI	=	ε+ ◦ η

A morphism f between two cubical objects (C1, ε—, ε+, η1) and (C2, ε—, ε+, η2) isa 
1	1	2	2
morphism f : C1 → C2 such that
f ◦ η1 = η2	ε— ◦ f = ε—	ε+ ◦ f = ε+
2	1	2	1
Dually, a co-cubical object (C, ε—, ε+, η) in C is a cubical object in Cop.
In the cubical category  , (1, ε—, ε+, η) is a co-cubical object. The fact that  is the free monoidal category containing a co-cubical object means that all the arrows
of can be recovered from those by tensoring with identities (εα = idi ⊗εα ⊗ idn—i
and ηi,n = idi ⊗ η ⊗ idn—i) and that the axioms satisfied by the morphisms – the axioms dual of (1) and (2) – are precisely those imposed by the axioms of monoidal categories and those of co-cubical objects. This can be equivalently reformulated as follows:
Proposition 1.3 Given a monoidal category C, the category of monoidal func- tors  → C and monoidal natural transformations is equivalent to the category of co-cubical objects in C.
In other words, given a monoidal category C, a cubical object in C is “the same” as a monoidal functor op → C. This definition of cubical sets has been known for quite some time, but no concrete application of it has been done up to now. Interestingly, we show here that it can be used to concisely define some cubical sets (see in particular Section 1.5). It is also sometimes useful to define morphisms; for instance, given integers n and i such that 0 ≤ i ≤ n, and α ∈ {−, +}, we

write ∂α
: C(n + 1) → C(1) for the morphism ∂α
= C((εα)⊗i ⊗ id1 ⊗ (εα)⊗(n—i))

where (εα)⊗i denotes the tensor product of i copies of εα.
Similarly, monoidal functors © → C correspond to co-precubical objects in C, where a precubical object (C, ε—, ε+) is an object C of C together with two ar- rows ε—, ε+ : C → I (and no axiom to be satisfied), and a co-precubical object is defined dually.

From precubical sets to cubical sets
In this section, we formalize the intuition that morphisms between precubical sets are to morphisms between cubical sets what partial functions are to total functions. Recall that a pointed set (A, a) consists of a set together with a distinguished element a ∈ A, and a morphism f : (A, a) → (B, b) between two pointed sets consists of a function f : A → B such that f (a)= b. If we write Set∗ for the category of pointed sets, there is a forgetful functor U : Set∗ → Set which to every pointed set (A, a) associates the underlying set A. This functor admits a left adjoint F : Set → Set∗ which to every set A associates the free pointed set it generates, that is the pointed set (A {∗}, ∗) where  denotes the disjoint union (we often use the notation ∗ for the newly added element). We write ? = G ◦ F for the monad on Set induced by this adjunction. It is well-known [24] that
Proposition 1.4 The category of sets and partial functions is isomorphic to the Kleisli category Set? associated to the monad ? on Set. Moreover, this Kleisli category is equivalent to the category Set∗.
Proof A partial function f : A → B induces a morphism g : A → B in Set? (i.e. a morphism g : A → ? B in Set) defined on every x ∈ A by g(x) = f (x) if f (x) is defined and g(x) = ∗ otherwise, where ? B = B  {∗}. Conversely, any morphism g : A → B in Set? (i.e. morphism g : A → ? B in Set, with ? B = B  {∗}) induces a partial function f : A → B defined on every x ∈ A such that g(x) /= ∗ by f (x)= g(x). These two operations can easily be shown to be inverse of each other, thus exhibiting an isomorphism between the category of sets and partial functions and the Kleisli category Set?.
By general properties of monads (see [24], exercises p. 144), the category Set? is equivalent to the full subcategory of Set∗ whose objects are of the form FA for some set A ∈ Set. Moreover, every object (A, a) of Set∗ is isomorphic to the pointed set F (A \ {a}). The categories Set? and Set∗ are thus equivalent.	2
The proposition above formalizes the fact that a partial function f : A → B can be seen as a total function f : A → B  {∗} where f is “undefined” on an element a ∈ A whenever f (a)= ∗. The second part of the proposition states that this partial function can also be seen as a pointed function f : (A  {∗}, ∗) → (B  {∗}, ∗).
The situation between precubical sets and cubical sets is very similar. There is an obvious inclusion functor © → , which by precomposition, induces a forgetful functor U : CSet → PCSet on the corresponding presheaf categories. By general theorems (see Section 1.7), this functor admits a left adjoint F : PCSet → CSet. As previously, we write ? = G ◦ F for the induced monad on PCSet and PCSet? for the Kleisli category associated to the monad. The morphisms in PCSet? should be thought as “partial morphisms of precubical sets”. And actually, this category can be shown to be isomorphic to a category whose objects are precubical sets and morphisms κ : C → D are families (kn : C(n) → D(n))n∈N of partial functions satisfying suitable properties, which we do not need to detail here.
One of the main interests of expressing the “partial” variants of models as Kleisli

constructions is that this enables us to easily lift the adjunctions between models into adjunctions between their partial variants. Namely,
Proposition 1.5 Suppose that C and D are categories and with S and T monads on respectively C and D. Suppose moreover that U : D → C is a functor such that
U ◦ T = S ◦ U

and F sends the unit and the multiplication of T to the unit and the multiplication of U. Then U has a left adjoint if and only if the functor U ◦ ID : DT → CS has a left adjoint, where ID : DT → D is the canonical comparison functor between the Kleisli category DT associated to T and D.
This property, which is proved in a more general version in [27], thus enables us to lift an adjunction between the categories C and D into an adjunction between the corresponding Kleisli categories CS and DT . In the following, it will be particularly useful to lift adjunction between models into adjunctions between corresponding models with partial morphisms.

Symmetric cubical sets
One sometimes needs more structure on cubical sets in order to formally express the fact that the cells of dimension n ≥ 2 in cubical sets arising as models for concurrent processes are essentially not directed. This can be formalized by adjoining a notion of symmetry in cubical sets. The idea here is that given a 2-cell z in a cubical set as shown on the left of



x1 ,¸z
 x2,
x2 ,¸zj
 x1,

y1	y2
x0
y2	y1
x0

there should also be a “mirror” cell zj as shown on the right, expressing the fact that z is not really directed from y1y3 to y2y4. The symmetry of the cubical category will associate to each two cell a “mirror” 2-cell in this way (it actually also generalizes this principle to higher dimensions). The need for symmetry is also explained in the case of labeled cubical sets in Example 1.9.
The symmetric cubical category S is the free symmetric monoidal category containing a co-cubical object. The presheaves on this category are called sym- metric cubical sets and they form a category SCSet. The category S can also be described as the free monoidal category containing a symmetric co-cubical ob- ject (C, ε—, ε+, η, γ), which is a co-cubical object (C, ε—, ε+, η) together with a mor- phism γ : C ⊗ C → C ⊗ C satisfying usual axioms for symmetry
(γ ⊗ C) ◦ (C ⊗ γ) ◦ (γ ⊗ C)= (C ⊗ γ) ◦ (γ ⊗ C) ◦ (C ⊗ γ)	γ ◦ γ = γ  (5)

and
γ ◦ (ε— ⊗ C)= C ⊗ ε—	γ ◦ (ε+ ⊗ C)= C ⊗ ε+	(η ⊗ C) ◦ γ = C ⊗ η γ ◦ (C ⊗ ε—)= ε— ⊗ C	γ ◦ (C ⊗ ε+)= ε— ⊗ C	(C ⊗ η) ◦ γ = η ⊗ C
see [20] for the details. Alternatively, the notion of symmetric cubical set can be equivalently reformulated as a cubical set C together with, for every integer n, an action of the symmetric group Σn on C(n) – the action of the transposition being given by C(γ): C(2) → C(2) – which satisfies the following coherence axioms: for every integers n and i such that 0 ≤ i ≤ n and every α ∈ {−, +},

for every (n + 1)-cell x and permutation σ ∈ Σn+1, ∂α(σx)= ∂α
(x)

i	σ(i)
for every n-cell x and permutation σ ∈ Σn, ιi(σx)= ισ(i)(x)
Namely, any symmetry σ : n → n (i.e. a bijection on a set with n elements) can be decomposed as a product of transpositions and can therefore be seen as a morphism in  S by sending the transposition σi : n → n, which exchanges the i-th and (i + 1)-th element, to the morphism i ⊗ γ ⊗ (n − i − 2). The axioms (5) imposed on γ, as well as the axioms of monoidal categories, ensure that this operation is well defined. In the following, we will thus sometimes implicitly consider a bijection as a morphism in the category S. Given a symmetric monoidal category C (such as Set with cartesian product), any cubical object of the underlying monoidal category of C can be canonically equipped with a structure of symmetric cubical set, the morphism γ being given by the symmetry of the category.
Given an integer n, we write ( S)n for the full subcategory of S whose objects are integers k ≤ n and SCSetn for the category of presheaves on ( S)n, whose objects are called n-dimensional symmetric cubical sets. The symmetric precubical category ©S is defined similarly as the free symmetric monoidal category containing a co-precubical object and we write SPCSet for the category of presheaves on ©S, whose objects are called symmetric precubical sets. Notice that many of the usual models for concurrency can be equipped with a similar, and often related, notion of symmetry: for instance event structures [42,36], or Petri nets [21].

Labeled cubical sets
We have explained that the 1-cells of a cubical set can be seen as occurrences of events in the semantics of a concurrent computational process. One sometimes needs to remember to which instruction of the process it corresponds. Labeled (pre)cubical sets formally allows this. The presentation given here is adapted from [17], see also [13].
Suppose that we are given a set L of labels. The category (Set, ×, 1) has finite products and is thus monoidal with the cartesian product as tensor and the ter- minal set 1 = {∗} as unit (for simplicity, we consider that the monoidal structure is strict). The set L can be canonically equipped with a structure of symmetric precubical object (L, ε—, ε+, γ) where ε—, ε+ : L → 1 are both the terminal arrow

and γ : L × L → L × L is the canonical transposition. According to the preced- ing remarks, it thus induces a symmetric precubical set noted ! L and called the labeling precubical set on L. Moreover, if Lj is another set of labels, any func- tion f : L → Lj induces a morphism between the corresponding co-precubical objects, and therefore induces a morphism ! f : ! L → ! Lj, extending this operation into a functor. An explicit description of the precubical set ! L can be given as follows: its n-cells l ∈ ! L(n) are lists l = (ei)0≤i<n, of length n, of labels ei ∈ L. The face maps ∂—, ∂+ : ! L(n + 1) → ! L(n) both send an (n + 1)-cell (ei)0≤i<n+1 to
n	n
the list obtained by removing the element at the k-th position and the action of a
symmetry σ : n → n on ! L(n) sends a cell (ei)0≤i<n to (eσ(i))0≤i<n.
It can be shown that ! L is the cofree precubical set generated by L in the following sense:
Proposition 1.6 The functor E : SPCSet → Set, which to every precubical set C associates its set C(1)/ ≈ of events (see Section 1.1) and to every mor- phism κ : C → D associates the function (κ1/ ≈) : (C(1)/ ≈) → (D(1)/ ≈), admits ! as right adjoint.
Proof Suppose given a precubical set C and a set L.	To every function
f : (C(1)/ ≈) → L, we associate the morphism ψ(f ) : C → ! L defined on an n-
cell x as the n-cell (f (∂— (x)),...,f (∂—	(x))) of ! L, where the function ∂α is
ч0	ч(n—1)	чi
defined in Section 1.2. Conversely, to every morphism κ : C → ! L of cubical sets,
we associate the function ψ(κ) : (C(1)/ ≈) → L defined as κ1/ ≈: this is well defined since the events of ! L are (in bijection with) the elements of L. Finally, is it straightforward to check that the functions ϕ and ψ are natural in C and L, and inverse of each other.	2
Remark 1.7 The cofree non-symmetric labeling precubical set on a set L could be defined in the same way, but a direct description is more difficult. It can for example be obtained from the symmetric labeling precubical set ! L on L by quotienting by the action of symmetries.
Recall that given categories C, D and E and functors F : C → E and G : D → E , the slice category F ↓ G (sometimes also called comma category ) is the category whose objects are triples (A, f, Aj) where A is an object of C, Aj is an object of D and f : FA → GAj is a morphism of E , and whose morphisms (h, hj) : (A, f, Aj) → (B, g, Bj) are the pairs of morphisms h : A → B of C and hj : Aj → Bj of D making the diagram
FA  F h  F¸B 

f
jj 
g
jj 

GA	 G¸B
Gh
commute. By abuse of notation, we often write D↓ G for the category IdQ ↓ G. A labeled variant of cubical sets is defined as follows.

Definition 1.8 The category of labeled symmetric precubical sets, denoted by
LSPCSet, is the slice category SPCSet ↓ !.
By Proposition 1.6, a given labeled symmetric precubical set (C, l, L) (with C ∈ SPCSet, L ∈ Set and l : C → ! L) can also be seen as a triple (C, l, L) with the function l : E(C) → L associating a label to each event of C. In other words, the category LSPCSet is isomorphic to E ↓ !, where E is the event functor introduced in Proposition 1.6.
Example 1.9 The CCS processes ab + ba and (a|b) respectively induce labeled symmetric cubical sets of the form



y1 ,¸
a
x
 y2,	and
y1 ,¸α β a
x
 y2,
b

with in the second case two squares α and β attached in the middle, respectively labeled by (a, b) and (b, a) (and none in the first case): the presence of a square indicates that the two actions a and b commute and more generally n-cubes indicate the commutation of n actions [15]. Notice that the symmetry intuitively enables us to say that the cell labeled by ab is “the same as” the cell labeled by ba. In a non-symmetric case, there would be only one cell and there is no canonical choice of naming for this cell (this is however sometimes overcome by supposing that letters are totally ordered, but supposing this is not very natural).
Notice that events provides a canonical labeling of symmetric precubical sets:
Proposition 1.10 The forgetful functor U : LSPCSet → SPCSet which to every labeled symmetric precubical set associates the underlying symmetric precubical set (forgetting the labels) admits the functor E : SPCSet → LSPCSet as left adjoint, which to every symmetric precubical set C associates the labeled symmetric precubi- cal set (C, l, ! L) where L = C(1)/ ≈ is the set of events of C and l is the morphism induced by the function l : C(1) → L which to every 1-cell associates its equivalence class under ≈.
This means in particular that all following results about labeled symmetric precu- bical sets simply extend to the unlabeled case by considering precubical sets labeled by their events. We thus only handle labeled cases in the following, since unlabeled structures are a particular instance.
The category of labeled symmetric cubical sets is defined in a similar way. A given pointed set (L, ∗) induces a symmetric cubical object (L, ε—, ε+, η, γ) where ε—, ε+ : L → 1 are both the terminal arrow, η : 1 → L associates ∗ to the unique element of 1 and γ : L × L → L × L is the canonical transposition function. As previously, this induces a symmetric cubical set, that we still write !(L, ∗), and can be shown to be cofree in the sense that

Proposition 1.11 The functor E : SCSet → Set∗, which to every cubical set C associates the pointed set obtained from C(1)/ ≈ by identifying all equivalence classes containing an element of the image of ι0 to a single element ∗ chosen as distinguished element and to every morphism κ : C → D associates the morphism induced by κ1 : C(1) → D(1), admits ! as right adjoint.
Definition 1.12 The category of symmetric labeled cubical sets, denoted by
LSCSet, is the slice category SCSet ↓ !, which is isomorphic to E ↓ !.
An explicit description of !(L, ∗) is similar to the one of the labeling symmetric precubical set: its n-cells are lists l = (ei)0≤i<n, with the same face and symmetry maps as previously. The degeneracy maps ιi : !(L, ∗)(n) → !(L, ∗)(n + 1) associate to every list l of length n the list of length n + 1 obtained from l by inserting ∗ at the i-th position.
We have defined labellings in the most natural way. There is however a slight mismatch between labeled precubical and cubical sets: in the first case functions between labels are total whereas they are partial in the second case. This mis- match actually turns out to bring annoying details, as explained in Section 1.7 (see also [7]). The opposite choices can be made in both cases as follows. A slightly more general notion of labeled precubical set can be defined, by allowing partial functions between morphisms. If we write U : Set∗ → Set for the canonical forgetful func- tor, the category of weakly labeled symmetric precubical sets wLSPCSet is defined as wLSPCSet = SPCSet ↓ ! U . Conversely, one can restrict labeled cubical sets by only allowing total functions between labels and imposing that only degenerate events are labeled by the distinguished element of the labeling pointed set thus defining a category of totally labeled symmetric cubical sets (we do not detail this construction here).
Finally, we introduce the notion of strongly labeled cubical set, which will turn out in Section 3 to be the “right” notion of labeled cubical set in order to relate them with most of the usual models of concurrency.
Definition 1.13 A labeled cubical set (C, l) is strongly labeled when there exists no pair of distinct k-cells, for some dimension k, whose sources and targets are equal, which have the same label: for every index k > 0, and every elements x, y ∈ C(k) such that for every index 0 ≤ i < k ∂i(x)= ∂i(y), if l(x)= l(y) then x = y.
This condition can be seen as a labeled and higher dimensional analogue of Winskel’s “no ravioli” condition for HDA [42], which imposes that two parallel 1-cells should be equal, and corresponds to being separated wrt a Grothendieck topology.

Higher dimensional automata
A pointed cubical set (C, i) is a cubical set together with a distinguished 0-cell i ∈ C(0). The notion of higher dimensional automaton can be seen as a generaliza- tion of the classical notion of automaton to higher dimensional transition systems:
Definition 1.14 A higher dimensional automaton (or HDA) is a pointed labeled

symmetric cubical set C, the distinguished element i being called the initial state. A morphism of HDA is a morphism between the underlying labeled symmetric cubical sets which preserves the initial state.
Given a category C of cubical sets, we often write C∗ for the corresponding category of pointed cubical sets. We write HDA = LSCSet∗ for the cate- gory of HDA and sHDA = LSPCSet∗ for the category of strict HDA. We also write HDAn = LSCSet∗ for the subcategories for truncated HDA.
A path p : x −→ xj in an HDA C is a finite sequence (yi)0≤i<n of 1-cells of C
such that ∂+(yi) = ∂—(yi+1), ∂—(y0) = x and ∂+(yn) = xj. We write s · t for the
0	0	0	0
concatenation of two paths s and t. A 0-cell x of an HDA is reachable when there
exists a path s : i −→ x, where i is the initial state of the HDA. Since higher dimen- sional cells express the fact that transitions are independent, two paths differing only by a reordering of independent transitions should be considered as equivalent from the concurrency point of view. This is formally expressed by the homotopy relation between paths [10,40], which is defined as the smallest equivalence relation relating two paths s · m· n· t and s · p · q · t where m, n, p and q are 1-cells such that there exists a 2-cell z for which m = ∂—(z), q = ∂+(z), p = ∂—(z) and n = ∂+(z) ; 

graphically,
0	0	1	1









s

In particular, in the situation above, m and q (resp. p and n) are part of the same event. Given two paths s and t, we write s ∼ t when they are homotopic. Two homotopic paths are necessarily parallel (they have the same source and target).
Relating variants of cubical sets.
Suppose given two categories C and D and a functor I : C → D. Every presheaf
C : Dop → Set on C induces a presheaf C ◦ Iop : Cop → Set by precomposition

with I, and this operation extends into a functor
Iˆ : Dˆ → Cˆ from the presheafs

on D to those on C, defined on morphisms α : C → D by (Iˆ(α))A = αI(A). These
functors have many nice properties, some of which useful here are detailed below:
Proposition 1.15 Suppose given two categories C and D, where C is small, and a functor I : C → D between them.
The functor Iˆ : Dˆ → Cˆ admits both a left and a right adjoint and we write T
for the monad induced on Cˆ.
The Kleisli category DT associated to the monad T embeds fully and faithfully into Dˆ.

When I is bijective on objects, the adjunction is monadic which means that the category Dˆ is equivalent to the category CT of algebras for the monad T on Cˆ.
Proof (i) and (ii) are standards properties [23]. In particular, the free presheaf in Dˆ on a presheaf C ∈ Cˆ can be computed as the left Kan extension of C along I (and similarly for the right adjoint).
(iii) This fact does not seem to be very well-known and can be found for exam- ple p. 105 of [3]. We have seen that the functor Iˆ admits a left adjoint. Since it is the bijective on objects it is conservative (it reflects isomorphisms): an isomor- phism between presheaves is simply a natural transformation between them whose
components are all invertible. Moreover, presheaf categories are cocomplete; in par- ticular, they have all equalizers, these are computed pointwise and they are thus preserved by precomposition with U . We can conclude by using Beck’s monadicity theorem [24].	2
Notice that this generalizes in particular the situation described in Section 1.3.
This property is very interesting because, it means that all the forgetful functors between variants of categories of cubical sets admit both left and right adjoint:
functors forgetting structure:
SCSet → CSet,	CSet → PCSet,	PCSet → Set,	etc.
SCSetn → CSetn,	CSetn → PCSetn,	PCSetn → Set,	etc. – truncation functors:
SCSet → SCSetn,	CSet → CSetn,	etc.
These adjoints will allow us to compute for example the free cubical set on a pre- cubical set and so on, and will be used in the following. As an illustration, consider the functor PCSet → PCSetn. Given an n-dimensional precubical set C, the left adjoint sends C to the precubical set D whose k-cells are D(k)= C(k) for k ≤ n and D(k)= ∅ otherwise. The action of the right adjoint is more subtle: it sends C to the precubical set obtained from C by “filling in” all the k-dimensional cubes, with k > n, by a k-cell.
The analogy between the adjunction between sets and pointed sets and the adjunction between precubical sets and sets, can be related with the construction of labeling cubical sets as follows.
Lemma 1.16 The diagram
F  ¸

Set ¸T¸
E
I
SPCSet
J

J∗  H   J 

Set
¸¸⊥	SCSet
G

commutes, in the sense that J ◦ F = H ◦ I and G ◦ J = I ◦ E, where E (resp. H) is the functor which to every symmetric precubical (resp. cubical set) associates its set (resp. pointed set) of events described along with their right adjoints in Sec- tion 1.5, and I (resp. J) is the left adjoint to the forgetful functor Set∗ → Set (resp. SCSet → PCSet).
It could be hoped that previous Lemma would provide the starting point of a lifting of the adjunctions between SPCSet and SCSet to adjunctions between LSPCSet and LSCSet. However this is not the case: morphisms between labels have to be total or partial in both the categories. It is however easy to show that
Proposition 1.17 The forgetful functor LSCSet → wLSPCSet admits both a left and a right adjoint (and other adjunctions mentioned above can be lifted to the labeled case in a similar way). Similar adjunctions also exist between the variants where functions between labels are total.
The choice of partial or total functions between labels in the category of labeled symmetric (pre)cubical sets is thus difficult to handle in a modular way. The choice has to be made once for all and in the following, we deliberately do not explicit which one is made since all the constructions given here work in both cases.
Traditional models for concurrency
Transition systems
Transition systems are one of the oldest semantic models, both for sequential and concurrent systems, in which computations are modeled as the sequence of interac- tions that they can have with their environment. There is a convenient categorical treatment of this model, that we use in the sequel, taken from [43].
Definition 2.1 A transition system is a quadruple (S, i, E, Tran) where
S is a set of states with initial state i,
E is a set of events,
Tran ⊆ S × E × S is the transition relation.
In other words, a transition system is a graph together with a distinguished vertex. Transition systems are made into a category by defining morphisms to be some kind of simulation (for then being able to discuss about properties modulo weak or strong bisimulation, see [22]). The idea is that a transition system T1 simulates a transition system T0 if as soon as T0 can fire some action a in some context, T1 can fire a as well in some related context. A morphism f : T0 → T1 defines the way states and transitions of T0 are related to states and transitions of T1 making transition systems into a category TS.
Definition 2.2 Let T0 = (S0, i0, E0,Tran0) and T1 = (S1, i1, E1,Tran1) be two transition systems. A partial morphism f : T0 → T1 is a pair f = (σ, τ ) where σ : S0 → S1 is a function and τ : E0 → E1 is a partial function such that

σ(i0)= i1,
(s, e, sj) ∈ Tran0 and τ (e) is defined implies (σ(s),τ (e), σ(sj)) ∈ Tran1. Other- wise, if τ (e) is undefined then σ(s)= σ(sj).
As in [43], we can restrict to strict morphisms, i.e. the ones for which τ is a total function, by suitably completing transition systems. Partial morphisms can then be recovered by adding “idle” transitions to the systems, similarly to the construction of the category of sets and partial functions as the Kleisli category associated to the free pointed set monad ? on Set given in Section 1.3.
An idle transition is a transition ∗ which goes from a state s to the same state s. Consider the following completion T∗ = (S∗, i∗, E∗,Tran∗) of a transi- tion system T = (S, i, E, Tran), by setting S∗ = S, i∗ = i, E∗ = E  {∗} and Tran∗ = Tran {(s, ∗, s) | s ∈ S}. Now, by the preceding remarks a total mor- phism (σ, τ ) from (T0)∗ to (T1)∗ such that τ (∗)= ∗ is the same as a partial morphism from T0 to T1. Again, the operation (−)∗ induces a monad on the category sTS of transition systems and strict morphisms, and the category TS can be recovered as the Kleisli category associated to this monad. Likewise, all the models for concur- rency considered in this article admit a “strict” variant, from which the “non-strict” model can be reconstructed by a Kleisli construction. For lack of space we will not detail all the variants here.
Example 2.3 The CCS processes a · (b + c), a · (b|c) and a · (b · c + c · b) respectively induce the following transition systems:



b
y1 ,¸
 y2,
y1 ,¸
 y2,

y,, x
b
y,,
x
b
y,,
x

Asynchronous automata
Asynchronous automata are a nice generalization of both transition systems and Mazurkiewicz traces, and have influenced a lot of other models for concurrency, such as transition systems with independence (or asynchronous transition systems). They have been independently introduced in [35] and [2]. The idea is to decorate transition systems with an independence relation between actions that will allow us to distinguish between true-concurrency and mutual exclusion (or non-determinism) of two actions. For example, the two last transition systems of Example 2.3 do not allow us to distinguish between processes which are arguably different from the concurrency point of view. We actually use a slight modification for our purposes, due to [6], called automaton with concurrency relations:
Definition 2.4 An automaton with concurrency relations (S, i, E, Tran, I) is a quintuple where

(S, i, E, Tran) is a transition system,
Tran is such that whenever (s, a, sj), (s, a, sjj) ∈ Tran, then s = sjj,
I = (Is)s∈S is a family of irreflexive, symmetric binary relations Is on E such that whenever a1 Is a2 (with a1, a2 ∈ E), there exist transitions (s, a1, s1), (s, a2, s2), (s1, a2, r) and (s2, a1, r) in Tran.
A morphism of automata with concurrency relations consists of a morphism (σ, τ )

between the underlying transition systems such that a Is b implies that τ (a) Ij
τ (b)

whenever τ (a) and τ (b) are both defined. This makes automata with concurrency relations into a category, written ACR. We also write sACR for the variant of this category where morphisms are strict morphisms. Again, the category sACR can be constructed from ACR by a Kleisli construction, using ∗-transitions and total morphisms (the condition on the independence relation is then that a Is b implies

τ (a) Ij
τ (b) whenever τ (a) /= ∗ and τ (b) /= ∗).

Example 2.5 The CCS processes a · (b|c) and a · (b · c + c · b) induces the labeled asynchronous transition systems whose underlying transition system are isomorphic and shown in Example 2.3. The independence relation contains ebIyec for the first process (where eb and ec are the events with source y, labeled respectively by b and c) and is empty for the second process.

Event structures
Event structures were introduced in [28,41] in order to abstract away from the precise places and times at which events occur in distributed systems. The idea is to focus on the notion of event and the causal ordering between them. We recall below the definition of (unlabeled prime) event structures.
Definition 2.6 An event structure (E, ≤, #) consists of a poset (E, ≤) of events, the partial order relation expressing causal dependency, together with a symmetric irreflexive relation # called incompatibility satisfying
finite causes: for every event e, the set { ej | ej ≤ e } is finite,
hereditary incompatibility: for every events e, ej and ejj, e # ej and ej ≤ ejj implies
e # ejj.
We write ES for the category of event structures, a morphism between two event structures (E, ≤, #) and (Ej, ≤j, #j) consisting of a partial function f : E → Ej which is such that
if f (e) is defined then { ej | ej ≤ f (e) }⊆ f ({ ejj | ejj ≤ e }),
and if f (e0) and f (e1) are both defined and we have either f (e0) #j f (e1) or
f (e0)= f (e1) then either e0 # e1 or e0 = e1.
A labeled event structure consists of an event structure (E, ≤, #) together with a set L of labels and a labeling function l : E → L which to every event associates a label. A morphism (f, λ) : (E, ≤, #, l, L) → (Ej, ≤j, #j, lj, Lj) of labeled event

structure consists of a morphism f : (E, ≤, #) → (Ej, ≤j, #j) between the underly- ing event structures and a partial function λ : L → Lj between the sets of labels such that lj ◦ f = λ ◦ l. We write LES for the category of labeled event structures. We also write sES (resp. sLES) for the category of strict (labeled) event structures, defined as the subcategory of ES (resp. LES) whose morphisms are total functions – these categories can also be obtained by suitable Kleisli constructions.
Example 2.7 The CCS processes a · (b + c), a · (b|c) and a · (b · c + c · b) respec- tively induce the following labeled event structures (to be read from bottom up, the continuous lines representing the partial order and the dotted ones expressing incompatibilities):
c	b
b		c	b		c	b		c a			a			a
Notice that in the last one, b and c appear twice: this is because we have figured the labels and not the events (and two distinct events can of course have the same label).
Petri nets
Petri nets are a well-known model of parallel computation, generalizing transition systems by using a built-in notion of resource. This allows for deriving a notion of independence of events, which is much more general than the independence relation of asynchronous transition systems. They are numerous variants of Petri nets since they were introduced in [29], and we choose the definition used by Winskel and Nielsen in [43], since this is well-suited for formal comparisons with other models for concurrency:
Definition 2.8 A Petri net N is a tuple (P, M0, E, pre, post) where
P is a set of places,
M0 ∈ NP is the initial marking,
E is a set of events,
pre : E → NP and post : E → NP are the precondition and postcondition func- tions.
When there is no ambiguity, given an event e of a Petri net N , we often write •e for pre(e) and e• for post(e). A marking M is a function in NP , which associates to every place the number of resources (or tokens) that it contains. The sum M1 + M2 of two markings M1 and M2 is their pointwise sum. An event e induces a transition between two markings M1 and M2, that we write M1 −e→ M2, whenever there exists a marking M such that M1 = M + •e and M2 = M + e•.
A morphism of Petri nets (ϕ, ψ) : N → Nj, between the two Petri nets
N = (P, M0, E, pre, post) and Nj = (P j,Mj , Ej, prej, postj), consists of a function

ϕ : Pj → P and a partial function ψ : E → Ej such that for every place p ∈ Pj and event e ∈ E, Mj = M0 ◦ ϕ, •ψ(e)= •e ◦ ϕ and ψ(e)• = e• ◦ ϕ. We write PNet for the category of Petri nets and sPNet for the subcategory whose morphisms have total functions on events. Notice that the partial function ϕ : Pj → P on places goes “backwards”. This might seem a bit awkward at first sight and we explain why this is the “right” notion of morphism in Remark 3.11.
A labeled Petri net is a Petri net together with a set L of labels and a function l : E → L labeling events. The notion of morphism of Petri nets can be extended in a straightforward way to labeled ones and we write LPNet for the category of labeled Petri nets and sLPNet for the subcategory whose morphisms are total functions.
Example 2.9 The CCS processes a · (b + c), a · (b|c) and a · (b · c + c · b) respectively induce the following labeled Petri nets:

In the diagrams above, we have used the usual notation for Petri nets: square nodes represent transitions, circled ones represent places (with dots indicating tokens) and arrows represent pre- and postconditions.
Relating models for concurrency
The purpose of this section is to relate traditional models introduced in Section 2 with the geometric models of Section 1 (mainly HDA).
Transition systems and HDA
In this section, we relate labeled transition systems and HDA. We begin by relating transition systems to the category of 1-dimensional HDA by defining two adjoint functors
F : sHDA1 → sTS	and	G : sTS → sHDA1
We define the functor F as follows. To a 1-dimensional HDA C labeled by L, we associate the transition system (S, i, E, Tran) defined by S = C(0), i being the distinguished element of C, E = L and the transitions being defined by Tran = { (∂—(e), l(e), ∂+(e)) | e ∈ E }. And to any morphism (ϕ, λ): C → D be-
0	0
tween labeled precubical sets, we associate the morphism (σ, τ ) which is defined by

σ = ϕ0 : C(0) → D(0) and τ = λ. The functor is defined in the obvious way on morphisms.
Conversely, the functor G is defined as follows.  To any transition system T = (S, i, E, Tran), we associate the strict 1-dimensional HDA C labeled by E whose underlying precubical set C is such that C(0) = S, C(1) = Tran, the

face morphisms ∂— : C1 → C0 and ∂+
: C1 → C0 are respectively defined by

0	0
∂—(s, e, sj)= s and ∂+(s, e, sj)= sj, the labeling function is defined by l(s, e, sj)= e
0	0
and the distinguished element is the distinguished element i ∈ C(0).  To any
morphism (σ, τ ): (S1, i1, E1,Tran1) → (S2, i2, E2,Tran2) we associate the mor- phism (κ, λ) of HDA, where κ is the morphism of pointed 1-dimensional precubical set whose components are κ0 = σ and κ1 = τ , the morphism λ between labels being τ . The functor is defined in the obvious way on morphisms.
The functors defined above enable us to relate both models:
Theorem 3.1 The functor F : sHDA1 → sTS deﬁned above is left adjoint to the functor G : sTS → sHDA1. The comonad F ◦ G on sTS is the identity and the adjunction restricts to an equivalence of categories between the full subcategory of sHDA1 whose objects are strongly labeled.
Proof Suppose given a transition system T = (S, i, E, Tran) and a 1-dimensional HDA C = (C, i). We construct a natural bijection between morphisms FC → T in sTS and morphisms C → GT in sHDA1. To every morphism (σ, τ ): FC → T of transition systems we associate the morphism ϕC,T (σ, τ ) : C → GT of HDA defined as (κ, λ) where κ0 = σ and κ1 = λ = τ . Conversely, to every morphism (κ, λ) : C → GT of HDA we associate the morphism ψC,T (κ, λ) : FC → T of transition systems defined as (κ0, λ). These operations are mutually inverse and can easily be shown to be natural. The second part of the proposition can be checked directly.	2
Now, recall that the category TS can be defined as the Kleisli category as- sociated to the monad (−)∗ on sTS. Similarly, the adjunction between sHDA1 and HDA1 given in Proposition 1.15 induces a monad ? on sHDA1 which “re- places” the underlying precubical set of an HDA by the cubical set it generates.
Theorem 3.2 The adjunction of Theorem (3.1) lifts to an adjunction between TS and HDA1, which induces an equivalence if we restrict HDA1 to strongly labeled cubical sets.
Proof Consider a strict 1-dimensional HDA consisting of a precubical set C la- beled by l into L. Its image under the left adjoint F : sHDA1 → HDA1 to the forgetful functor HDA1 → sHDA1 is the 1-dimensional HDA whose under- lying cubical set is D defined by D(0) = C(0), D(1) = C(1) C(0) with face maps being ∂α  idC(0) : D(1) → D(0) as face maps and the canonical injec- tion ι0 : D(0) → D(1) as degeneracy maps, whose labeling is obtained by ex- tending l1 : C(1) → (! L)1 to D(1) by l1(x)= (∗) for x ∈ C(0) ⊆ C(1). From this concrete description, it can easily be checked that ? ◦G = G ◦ (−)∗ and that the unit and the multiplication of (−)∗ are sent by G to the unit and multiplication

of T . Finally, we deduce that the adjunction of Theorem 3.1 lifts to an adjunction between the Kleisli categories TS and HDA1 respectively associated to the monads (−)∗ and ? using Proposition 1.5.	2
Remark 3.3 The fact that we have to restrict to a subcategory of sHDA1 in The- orem 3.1 in order to obtain an equivalence of categories can be explained intuitively by remarking that in transition systems there is no distinction between events and labels: in particular, a transition system cannot contain two distinct transitions with the same event between the same source and the same target. For example, the following labeled (pre)cubical set cannot be represented in transition systems:
,y ,,,
a	a
x
More generally, in higher dimensions most models do not have the possibility to “count” the number of commutations between events: usually, two transitions either commute or not. This contrasts with cubical sets where a tile



x1 ,¸
y1
x0


 x2,
y2

can be filled with many 2-cells. This explains why in the following most of the nice adjunctions will be obtained by restricting cubical sets to strongly labeled ones.
By Proposition 1.15, the truncation functor HDA → HDA1 admits a right adjoint. By composing this adjunction with the one of previous theorem, we obtain an adjunction between TS and HDA.
Remark 3.4 The HDA associated by the right adjoint to a transition sys- tem T = (S, i, E, Tran) can be described in a more direct way using Proposi- tion 3.9 as generated by the cubical transition system (S, i, E, l, E  {∗}, t) where l : E → E  {∗} is the canonical injection and t(x, l)= y if l is reduced to an event e and (x, e, y) ∈ Tran, see Section 3.4 for details.

Asynchronous automata and HDA
The adjunction given in previous section, can be extended to an adjunction between the category of strict asynchronous automata sACR and the category of strict 2- dimensional HDA sHDA2.
To any strict 2-dimensional HDA C, the left adjoint F : sHDA2 → sACR asso- ciates the asynchronous automaton whose underlying transition system is induced by the underlying 1-dimensional HDA of C and such that a1 Is a2 when there exists transitions (s, a1, s1), (s, a2, s2), (s1, a2, r) and (s2, a1, r) and a 2-cell y such that

∂—(y)= (s, a1, s1), ∂+(y)= (s2, a1, r), ∂—(y)= (s, a2, s2) and ∂+(y)= (s1, a2, r):
0	0	1	1
a	 r ,a¸

s1 ,¸y
a1
s
 s2,	(6)
a2

The functor is defined in the obvious way on morphisms.
Conversely, an asynchronous automaton A = (S, i, E, Tran, I) is sent by the right adjoint G : sACR → sHDA2 to a strict 2-dimensional HDA C, whose un- derlying 1-dimensional HDA is induced by the underlying transition system of A. The 2-cells are C(2) = I, where I is seen as a subset of E × S × E. Given a pair of events a1 and a2 related by Is for some state s, there exist transitions (s, a1, s1), (s, a2, s2), (s1, a2, r) and (s2, a1, r) and these are uniquely defined by the second property of Definition 2.4 as in (6), face maps are defined on elements y = a1, s, a2 of I by
∂—(y)= (s, a1, s1)	∂+(y)= (s2, a1, r)	∂—(y)= (s, a2, s2)	∂+(y)= (s1, a2, r)
0	0	1	1
and the labeling function is defined by l(a1, s, a2) = (a1, a2). The requirement that I is symmetric induces the symmetry of the HDA. The functor is defined in the obvious way on morphisms.
Theorem 3.5 These functors form an adjunction between sACR and sHDA2. The induced comonad on sACR is the identity and the adjunction induces an equiv- alence of categories if we restrict sHDA2 to the full subcategory of strongly labeled HDA. Moreover, this adjunction lifts to an adjunction between ACR and HDA2 with similar properties.
By composing with an adjunction given by Proposition 1.15, this induces an ad- junction between ACR and HDA.

Event structures and HDA
We construct here an adjunction between sLES and sHDA. This adjunction refor- mulates in the framework of HDA some well-known relations between event struc- tures and transition systems with independence [33]. The study of relations between the two models was initiated in [5] and a similar connection is described in [36].
A conﬁguration of an event structure (E, ≤, #) is a finite downward closed sub- set of compatible events in E. An event e is enabled at a configuration x if e /∈ x and x {e} is a configuration. A functor F : sLES → sHDA2 can be defined as fol- lows. To any labeled event structure (E, ≤, #, l, L), it associates the 2-dimensional HDA C labeled by L whose 0-cells are the configurations of the event structure with the empty configuration as initial state, 1-cells are the pairs (x, e) where x is a configuration and e is an event enabled at x, and 2-cells are the pairs (x, e1, e2) where x is a configuration and e1, e2 are both enabled at x and such that e2 is

enabled at x  {e1} and e1 is enabled at x  {e2}, graphically:
x  {e1, e2}
x  {e1}	(x, e1, e2)	x  {e2}

x
Notice for every 2-cell (x, e1, e2), (x, e2, e1) is also a 2-cell thus inducing a symmetry on the precubical set. The functor is defined in the obvious way on morphisms.
Example 3.6 Consider the event structure (E, ≤, #, l, L), with E = {e1, e2, e3}, with e1 ≤ e2 and e1 ≤ e3, labeled in L = {a, b, c} by l(e1) = a, l(e2) = b and l(e3) = c. This event structure is represented on the left and induces the two HDA on the right when b is respectively incompatible and compatible with c




{a, b}	{a, c}
 ,

{a}
a	,,
a
∅


{a, b}
{a, b, c}
  



{a}
,,
a
∅


{a, c}
  

(for simplicity we simply write e for a 1-cell (x, e) since x can be determined as the source of the cell). The square on the right diagram is filled with two 2-cells: ({a}, b, c) and ({a}, c, b).
Conversely, we define a functor G : sHDA2 → sLES. The intuition is that given an HDA C, the elements of G(C) should be the events of C in the sense of Section 1.1. However, event structures cannot express loops, which should therefore be unfolded [43,40,8]. For example, an HDA of the form

a
(7)

with only one 0-cell and one looping 1-cell should have as image an event structure with a countable totally ordered set of events. A 2-dimensional HDA is unfolded when it is
reachable: every 0-cell x is reachable,
acyclic: any path s : x −→ x with the same source and target is empty,
unshared : any two parallel paths s, t : x −→ xj are homotopic.
This reformulates the notion of occurrence transition system with independence. To any 2-dimensional HDA C with i as initial state and l : C → ! L as labeling

function, one can associate an unfolded 2-dimensional HDA U (C) whose
0-cells are the paths s : i −→ x of C modulo homotopy,
1-cells are the pairs (s, m) where s : i −→ x is a path and m is a 1-cell such that ∂—(m)= x, with ∂—(s, m)= s and ∂+(s, m)= s · m as source and target,
0	0	0
2-cells are pairs (s, z) where s : i −→ x is a path and z is a 2-cell such that ∂—∂—(z) = x, with its faces defined by ∂—(s, z) = (s, ∂—(z)) and
0  0	i	i
∂+(s, z)= (s · ∂— (z), ∂+(z)),
i	1—i	i
the labeling function labels a 1-cell (s, m) by l(m) and a 2-cell (s, z) by l(z).
This operation can easily be extended into a comonad on the category sHDA2. For example, the image of the HDA (7) is


x0   a  x1¸ a  x2¸
a  . .¸. 

Now, to every unfolded 2-dimensional HDA C, one can associate a labeled event structure V (C)= (E, ≤, #, l, L) such that E is the set of events of C in the sense of Section 1.1. We say that an event e occurs in a path s when s contains a 1- cell m such that m ∈ e. Two events e and ej are such that e ≤ ej when for every path s · n : i −→ x with n ∈ ej the event e occurs in s. Two events e and ej are such that e#ej when there is no path s : i −→ x such that both e and ej occur in s. The labeling function is the labeling function of C (recall that we have shown in Section 1.5 that every labeled cubical set induces a labeling function on its events). The operation V is easily extended as a functor V from the category of unfolded 2-dimensional HDA to the category of labeled event structures. Finally, we define the functor G : sHDA2 → sLES as the composite G = V ◦ U .
Theorem 3.7 The composite functor G ◦ F is isomorphic to the identity functor on sLES. Thus sLES embeds fully and faithfully into sHDA2.
Proof The adjunction between labeled event structure and transition systems with independence described [33,25] can be straightforwardly adapted to asynchronous transition systems and one obtains the result by composing with the adjunction described in previous section.	2
Notice that we did not claim that F and G are part of an adjunction, because it is not the case.  Namely, consider the effect of the endofunctor F ◦ G : sHDA2 → sHDA2: we have pictured some HDA (on the left) together with their image under F ◦ G (on the right):


x,2 ,
c
x¸1,,	~
a	b
x0
a

x,3 ,
c






x0

x,4 ,
c
 x2,

x  J ~	x0  a  x1¸a x2¸a . .¸. 



a
x	xj
y,,
~	a
x

y1 	b	 y ,¸¸	b


c	x,3 , b
 ¸
,, ~
c
c
,
 y3¸,¸ c

a
x
b	 x2¸
b	 x2¸

b	_x¸3 ,¸
a

b
 x2,	~
 x2,


x0	x0


In the third example, x is the initial position and in the last two examples all the squares for which it makes sense are filled with 2-cells. These examples are representative of various kinds of behaviors that can happen:
the first two examples show that “shared transitions” are “unshared”, and in particular loops are unrolled;
the third example shows that the unreachable 0-cells of the HDA are removed,
the fourth example shows that if the HDA contains half of a cube then the other half of the cube is created, completing the cube – this is related to the cube axiom which is often used to characterize asynchronous transition systems generated by an event structure [33];
the last example shows that HDA are made strongly labeled.
Notice, if we write C for the HDA in the left of examples, in the first three examples there is a natural arrow TC → C (but not in the other direction), whereas in the last two examples there is a natural arrow C → TC (but not in the other direction). So there is no hope that T would be either a monad or a comonad, and thus that F and G either form an adjunction in either direction.
It can however be shown that G is right adjoint to F if we restrict sHDA2 to the full subcategory whose objects are strongly labeled and satisfy the cube axioms (which state that if an asynchronous transition system contains half of a cube as in fourth example then it also contains the other half of the cube, as well as two other variants of this property). As previously, this adjunction can be extended to the non-strict variants of the models, as well as the whole category HDA. This adjunction can also be extended to an adjunction between general event structures (in which conflict is not necessarily a binary relation) and HDA.

Petri nets and HDA
This section constitutes perhaps the most novel part of the paper. We extend here previously constructed adjunctions between 1-bounded Petri Nets and asynchronous transition systems [43,6,26,39] to an adjunction between general Petri Nets and HDA. For similar reasons as previously, one needs to restrict to strongly labeled HDA in order to obtain a well-defined adjunction. We thus implicitly only consider strongly labeled HDA in the following.
Cubical transition systems. We introduce here a general methodology for as- sociating a symmetric precubical set to a model for concurrent processes, that we will use in order to associate a strict HDA to a Petri net. Since monoidal functors preserve the unit of monoidal categories, all cubical sets generated by cubical ob- jects in Set (i.e. by the functor ! introduced in Section 1.5) contain only one 0-cell. Cubical sets with multiple 0-cells can be generated by actions of the labeling cubical set on the 0-cells, formalized as follows, in the same way that a transition system can be seen as an action of the free monoid on labels over the states. The resulting notion of cubical transition system (or CTS ) generalizes to the setting of cubical set the notion of step transition system [26] which is a variant of transition systems in which multiple events can occur simultaneously.
Definition 3.8 A cubical transition system (S, i, E, t, l, L) consists of
a set S of states,
a state i ∈ S called the initial state,
a set E of events,
a transition function which is a partial function t : S × ! E → S,
a set L of labels,
a labeling function l : E → L,
such that for every state x and every n-cell l of ! E for which t(x, l) is defined,
if l = l1 · l2 for some cells l1 and l2 then t(x, l1) and t(t(x, l1), l2) are both defined and we have t(x, l)= t(t(x, l1), l2),
t(x, ()) is defined and equal to x (where () denotes the 0-cell of ! E),
for every symmetry σ : n → n, t(x, ! E(σ)(l)) is defined and equal to t(x, l).
Cubical transition systems are thus generalized transition systems, which modify state upon incoming events. These differ from traditional transition systems in that they may accept a transition under n events e1,..., en, specified by a transition under the word e1 ··· en ∈ ! E. With this understanding in mind, the axioms have simple interpretations: for example the first one states that the state reached under two simultaneous events e1 and e2 is the same as the state reached under e1 followed by e2.
An n-cell l of ! E is enabled at a position x if t(x, l) is defined. Every such CTS defines a strict HDA C labeled by L whose n-cells are pairs (x, l) where x is a state

and l is an n-cell of ! E which is enabled at x. Source and target functions are defined by ∂—(x, l)= (x, ∂—(l)) and ∂+(x, l)= t(t(x, ei), ∂+(l)) where ei is the i-th
i	i	i	i
element of l and symmetries by σ(x, l)= (x, ! E(σ)(l)). The labeling function is ! l
and the initial state is i.
A morphism (σ, τ, λ): (S1, i1, E1, l1, L1, t1) → (S2, i2, E2, l2, L2, t2) between two CTS consists of
a function σ : S1 → S2,
a function τ : E1 → E2,
a function λ : L1 → L2,
such that i2 = σ(i1), l2 ◦ τ = λ ◦ l1, and for every state x ∈ S1 and cell l of ! E1, t2(σ(x), ! τ (l)) = σ ◦ t1(x, l). Every such morphism induces a morphism (κ, λ): C1 → C2 between the corresponding HDA C1 and C2 defined on n-cells (x, l) of C1 by κn(x, l)= (σ(x), ! τ (l)). We write CTS for the category thus defined.
Proposition 3.9 The functor CTS → sHDA deﬁned above is well-deﬁned.
Remark 3.10 A variant of the notion of cubical transition system can easily be defined in order to generate symmetric cubical sets.
From Petri nets to HDA. Suppose that we are given a labeled Petri net N = (P, M0, E, pre, post, l, L). The pre and post operations can be extended to the cells of ! E by •() = •(∗)= 0, •(l1 ·l2)= •l1 +•l2, ()• = (∗)• =0 and (l1 ·l2)• = l• +l•.
1	2
This enables us to see elements of ! E as generalized events. We also generalize the
notion of transition and given two markings M1 and M2 and an event l ∈ ! E, we

say that there is a transition M1 −→l
M2 whenever there exists a marking M such

that M1 = M + •l and M2 = M + l•. In this case, the event l is said to be enabled at the marking M1. The marking M2 is sometimes denoted M1/l. A marking M is reachable if there exists a transition l such that M = M0/l where M0 is the initial marking of N .
Remark 3.11 As in [43], we have chosen to define morphisms in the opposite direction on places. With the adjunction with HDA in mind, this can be ex- plained as follows. Morphisms of Petri nets should, just as morphisms of HDA, preserve independence of events: if two events e and ej of a net N are independent and (ϕ, ψ) : N → Nj is a morphism of nets, then their images ψ(e) and ψ(ej) should also be independent. By contraposition, this means that if both events ψ(e) and ψ(ej) depend on a common place p, then the events e and ej should depend on a corresponding common place ψ—1(p).
Every labeled Petri net N induces a CTS (S, i, E, t, l, L) whose states S are the reachable markings of the net, with the initial marking M0 as initial state, events E are the events of the net, transition function t(M, l) is defined if and only if l is enabled at M and in this case t(M, l)= M/l, with the set L as set of labels and l : E → L as labeling function.
It is routine to verify that this actually defines a CTS and thus a strict HDA.

The n-cells of hda(N ) consisting of a marking M of the net and a list l of events which is enabled at M . Moreover, any morphism (ϕ, ψ): N → Nj between labeled Petri nets induces a morphism (σ, τ, λ) between the corresponding CTS defined by σ(M )= M ◦ ϕ for any reachable marking M of N , τ = ψ, and λ = ψ. We denote by hda : sLPNet → sHDA the functor thus defined.
From HDA to Petri nets. We first introduce the notion of region of an HDA, which should be thought as a way of associating a number of tokens to each 0- cell of the HDA and a pre- and postcondition to every transition of the HDA, in a coherent way. A pre-region R of a precubical set C is a sequence (Ri)i∈N of functions Ri : C(i) → N × N such that
– for every x ∈ C(0), R0(x)= (0, 0)
– for every x ∈ C(i + 1) and αk ∈ {−, +},

i
Ri+1(x)	=	αk
k=0
where the sum is computed coordinate by coordinate on pairs of integers.
Notice that, by the second property, a region is uniquely determined by the image of 1-dimensional cells in x ∈ C(1). We sometimes omit the index i since it is determined by the dimension of the cell in argument and respectively write Rj(x) and Rjj(x) for the first and second components of R(x), where x is a cell of C. It can be remarked that two 1-cells which are part of the same event necessarily have the same image under a pre-region; a pre-region R thus induces a function from the events of C to N × N, that we still write R. A region of a precubical set consists of a pre-region R together with a function S : C(0) → N such that for every i-cell y ∈ C(i) whose 0-source is x and 0-target is xj, there exists an integer n such that (S(x), S(xj)) = (n + Rj(y),n + Rjj(y)).
Example 3.12 Consider the following precubical set

 x2,
y2
x 	y4	 x ¸

A region (R, S) for this cubical set is for example
R(y0)= (2, 1)	R(y1)= (3, 1)	R(y2)= (3, 1)	R(y3)= (2, 1)	R(y4)= (0, 2)
and
R(z)= (5, 2)	S(x0)=6	S(x1)=5	S(x2)=4	S(x3)=3	S(x4)=8 

Graphically,


 4 ,

(3,1)
6 	(0,2)	 8 ¸

To every strict HDA C, we associate a labeled Petri net pn(C) whose
places are the regions of C,
events are the events of C, labeled as in C,
pre and post functions are given on any event e and any place (R, S) by
e(R, S)= Rj(e) and e•(R, S)= Rjj(e),
initial marking M0 is M0(R, S)= S(x0), where x0 is the initial state of C.
Suppose that (κ, λ): C → D is a morphism of HDA. We define a morphism of labeled Petri nets pn(κ, λ): pn(C) → pn(D) as follows: pn(κ, λ)= (ϕ, ψ, λ), where
ϕ maps every region (R, S) of D to the region ϕ(R, S)= (R ◦ κ, S ◦ κ0), where R ◦ κ denotes the pre-region (Ri ◦ κi)i∈N,
ψ is the map induced on events by κ1 (two 1-cells which are part of the same event are sent to 1-cells which are part of the same event by κ1).
This thus defines a functor pn : sHDA → sLPNet.
The adjunction.
Suppose that we are given an HDA C labeled by l into L, and a labeled net N = (P, M0, E, pre , post , m,M ). We want to exhibit a bijection between mor- phisms pn(C) → N in sLPNet and morphisms C → hda(N ) in sHDA.
To any morphism (ϕ, ψ, λ) : pn(C) → N of labeled Petri nets, we associate a morphism (κ, λ): C → hda(N ) of HDA defined as follows. Given an n-cell x of C, κn(x) should be an n-cell of hda(N ), that is a pair (Mκn(x), lκn(x)) where Mκn(x) is a marking of N and lκn(x) is a list of events of N which is enabled at Mκn(x). These are defined for every place p of N by Mκn(x)(p)= Sϕ(p)(y), where y is the 0-source

of x, and lκ (x) = ! ψ(∂— (x) ··· ∂—
(x)) where y denotes the event associated to

n
a 1-cell x.
ч0	ч(n—1)

Conversely, to any morphism (κ, λ) : C → hda(N ) of HDA, we associate a morphism of labeled Petri nets (ϕ, ψ, λ): pn(C) → N defined as follows. Given an n-cell x, κn(x) is an n-cell of hda(N ), that is a pair (Mκn(x), lκn(x)) as above. For every place p, ϕ(p) is the region (Rϕ(p), Sϕ(p)) of C which is defined on 0-cells x

by Sϕ(p)(x) = Mκ (x)(p) and on n-cells x by Rϕ(p) = (•lκ (x), l•
). Given a 1-

n	n	κn(x)
cell x, its image under κ1(x) is a pair (Mκ1(x), lκ1(x)) where lκ1(x) is reduced to one
1-cell y. It is immediate to check that for any other 1-cell xj such that x ≈ xj, we
have that lκ1(x) ≈ lκ1(x′): it thus makes sense to extend x ◦→ lκ1(x) into a function which to an event e of C associates an event lκ1(e). Given an event e of C, we

define ψ(e)= lκ1(e).
It can be shown that these transformations are well defined, are natural in C
and N , and are mutually inverse. Therefore,
Theorem 3.13 The functor hda : sLPNet → sHDA is right adjoint to the func- tor pn : sHDA → sLPNet.
Proof It is routine to check that the transformations given above are well-defined and natural in C and N . We now show that they are mutually inverse.
Suppose that (ϕ, ψ, λ) : pn(C) → N is a morphism of Petri nets and consider the associated morphisms
(κ, λ): C → hda(N )	and	(ϕj, ψj, λ): pn(C) → N

obtained by successively applying the two transformations above. For any place p of N , ϕj(p) is a place of pn(C), that is a region (Rϕ′(p), Sϕ′(p)) of C. By definition of the transformations, we have that for every 0-cell x of C, Sϕ′(p)(x) = Mκn(x)(p) = Sϕ(p)(x) and for every n-cell y of C, the first component of Rϕ′(p)(x) is

n—1	n—1
lκ (x)(p)= Σ pre ◦ψ(∂—(x))(p)= Σ pre(∂—(x))(ϕ(p)) = Rj

n	i
i=0
i
i=0
ϕ(p)



and similarly l•
n
of C, ψj(e)= ψ(e).
(p) = Rjj
, thus Rϕ′(p) = Rϕ(p). Moreover, for every event e

Conversely, suppose that (κ, λ): C → hda(N ) is a morphism of cubical sets and consider the associated morphisms
(ϕ, ψ, λ): pn(C) → N	and	(κj, λ): C → hda(N )
obtained by successively applying the two transformations above. For any n-cell x
of C, the n-cell κj (x) is an n-cell of hda(N ) consisting of a pair (Mκ′ (x), lκ′ (x)) as
n	n	n
above. By definition of hda(N ), we have Mκ′ (x) = Mκ′ (y), where y is the 0-source
n	n
of x. Moreover, for every place p of N , we have Mκ′ (y)(p)= Sϕ(p)(y)= Mκn(y)(p).
And finally,

—	—	—	—
lκ′ (x) = ! ψ(∂ч0(x) ··· ∂ч(n—1)(x)) = (κ1(∂ч0(x)) ··· κ1(∂ч(n—1)(x))) = lκn(x)
which concludes the construction of the adjunction.	2
Example 3.14 If we restrict to 1-bounded nets, which are nets a place can contain either 0 or 1 token, we can recover the constructions of [43] for constructing an adjunction between asynchronous transition systems and nets. Since the net asso- ciated to an HDA by the functor hda is generally infinite, we will give an example in the case of 1-bounded nets. Consider the asynchronous automaton, depicted on

the left of (8), with an empty independence relation.



f	g


y1 ,¸
e1
x
 y2,
e2
a
i	(8)

The associated 1-bounded Petri net is shown on the right. In this automaton the place d corresponds to the region (R, S) such that R(e1) = (1, 0), R(e2) = (0, 0), S(x)= S(y2)=1 and S(y1)= S(z) = 0. Graphically,
(0,0) 0 ,(¸1,0)
0 ,¸	 1 ,

(1,0)
(0,0)
1

Now, if we consider the same automaton with e1 Ix e2, we obtain the same Petri net with the place h removed. The general (i.e. non-bounded) net associated to an HDA is generally infinite (even for very simple examples) and thus difficult to describe, which is why we did not provide an example in the general case.
This adjunction can easily be lifted into an adjunction between LPNet and HDA.
Conclusion and future work
In this paper, we have made completely formal the relation between HDA and var- ious classical models of concurrent computations: transition systems, asynchronous automata, event structures and Petri nets. This is not only interesting for com- parison purposes, between different semantics of parallel languages, but also, for practical reasons, which will be detailed in a subsequent article.
Stubborn sets [37], sleep sets and persistent sets [14] are methods used for di- minishing the complexity of model-checking using transition systems. They are based on semantic observations using Petri nets in the first case and Mazurkiewicz trace theory in the other one. We believe that these are special forms of “homo- topy retracts” when cast (using the adjunctions we have hinted) in the category of higher-dimensional transition systems. We shall make this statement more formal through these adjunctions, which will allow for new state-space reduction methods.
Last but not least, in [22] is defined an abstract notion of bisimulation. Given a model for concurrency, i.e. a category of models M and a “path category” (a subcategory of M which somehow represents what should be thought of as being paths in the models), then we can define two elements of M to be bisimilar if there exists a span of special morphisms linking them. These special morphisms have a path-lifting property that, we believe, would be in higher-dimensional transition

systems a (geometric) fibration property. We thus hope that homotopy invariants could be useful for the study of a variety of bisimulation equivalences (some work has been done in that direction in [5,7]).

References
A. Arnold. Syst`emes de transitions finis et s´emantique des processus communicants. Masson, 1992.
M. A. Bednarczyk. Categories of asynchronous systems. PhD thesis, 1988.
F. Borceux and G. Janelidze. Galois theories. Cambridge Univ Press, 2001.
R. Brown and P. J. Higgins. On the algebra of cubes. JPAA, (21):233–260, 1981.
G.L. Cattani and V. Sassone. Higher dimensional transition systems. In Eleventh Annual IEEE Symposium on Logic in Computer Science (LICS’96), pages 55–62, 1996.
M. Droste and RM Shortt. Petri nets and automata with concurrency relations—an adjunction. In
Sem. of Prog. Lang. and Model Theory, pages 69–87, 1993.
U. Fahrenberg. A category of higher-dimensional automata. Foundations of Software Science and Computational Structures, pages 187–201, 2005.
U. Fahrenberg. Higher-Dimensional Automata from a Topological Viewpoint. PhD thesis, Aalborg University, 2005.
L. Fajstrup. Loops, ditopology, and deadlocks. Math. Struct. Comput. Sci., 2000.
L. Fajstrup. Dipaths and dihomotopies in a cubical complex. Advances in Applied Mathematics, 35(2):188–206, 2005.
L. Fajstrup, E. Goubault, and M. Raußen. Detecting deadlocks in concurrent systems. CONCUR’98, pages 332–347.
L. Fajstrup, M. Raußen, and E. Goubault. Algebraic topology and concurrency. Theoretical Computer Science, 357(1-3):241–278, 2006.
P. Gaucher. Combinatorics of labelling in higher-dimensional automata. Theoretical Computer Science, 411(11-13):1452–1483, 2010.
P. Godefroid and P. Wolper. Using partial orders for the efficient verification of deadlock freedom and safety properties. volume 575, pages 417–428. LNCS, 1991.
E. Goubault. The Geometry of Concurrency. PhD thesis, 1995.
E. Goubault. Cubical sets are generalized transition systems. Technical report, 2001.
E. Goubault. Labelled cubical sets and asynchronous transistion systems: an adjunction. In Presented at CMCIM’02, volume 2, page 2002, 2001.
E. Goubault and T. P. Jensen. Homology of higher-dimensional automata. In Proc. of CONCUR’92, Stonybrook, New York, August 1992. Springer-Verlag.
M. Grandis. Directed Algebraic Topology; models of non-reversible worlds. CUP, 2009.
M. Grandis and L. Mauri. Cubical sets and their site. TAC, 11(8):185–211, 2003.
J. Hayman, C. Thompson-Walsh, and G. Winskel. Containment in rule-based models. Electronic Notes in Theoretical Computer Science 284 (2012), to appear
A. Joyal, M. Nielsen, and Winskel G. Bisimulation and open maps. In LICS, 1993.
S. Mac Lane and I. Moerdijk. Sheaves in geometry and logic: A first introduction to topos theory. Springer, 1992.
S. MacLane. Categories for the Working Mathematician, volume 5 of Graduate Texts in Mathematics. Springer Verlag, 1971.


S. Mimram. S´emantique des jeux asynchrones et r´e´ecriture 2-dimensionnelle. PhD thesis, PPS, CNRS – Universit´e Paris Diderot, 2008.
M. Mukund. Petri nets and step transition systems. International Journal of Foundations of Computer Science, 3(4):443–478, 1992.
P. Mulry. Lifting theorems for Kleisli categories. In MFPS, pages 304–319, 1994.
M. Nielsen, G. D. Plotkin, and G. Winskel. Petri nets, event structures and domains. In Semantics of Concurrent Computation, pages 266–284, 1979.
C. Petri. Communication with automata, 1966.
V. Pratt. Modeling concurrency with geometry. In Proc. of the 18th ACM Symposium on Principles of Programming Languages. ACM Press, 1991.
M. Raussen. On the classification of dipaths in geometric models for concurrency. Mathematical Structures in Computer Science, August 2000.
Sankaranarayanan S., H. Sipma, and Z. Manna. Petri net analysis using invariant generation. volume 2772 of LNCS, pages 682–701, 2003.
V. Sassone, M. Nielsen, and G. Winskel. Relationships between models of concurrency. In Proceedings of the Rex’93 school and symposium, 1994.
J.P. Serre. Homologie Singuli`ere des Espaces Fibr´es. Applications. PhD thesis, E´cole Normale Sup´erieure, 1951.
M.W. Shields. Concurrent machines. Computer Journal, 28, 1985.
S. Staton and G. Winskel. On the expressivity of symmetry in event structures. In Logic in Computer Science, pages 392–401. Citeseer, 2010.
A. Valmari. A stubborn attack on state explosion. In Proc. of CAV’90. LNCS, 1990.
R. van Glabbeek. Bisimulation semantics for higher dimensional automata. Technical report, Stanford University, 1991.
R. van Glabbeek. Petri nets, configuration structures and higher dimensional automata. Lecture notes in computer science, pages 21–27, 1999.
R. van Glabbeek. On the expressiveness of higher dimensional automata. Theoretical computer science, 356(3):265–290, 2006.
G. Winskel. Event structures. In Advances in Petri Nets, pages 325–392, 1986.
G. Winskel. Event structures with symmetry. Electronic Notes in Theoretical Computer Science, 172:611–652, 2007.
G. Winskel and M. Nielsen. Models for concurrency. In Handbook of Logic in Computer Science, volume 3, pages 1–148. Oxford University Press, 1995.
