Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 328 (2016) 3–16
www.elsevier.com/locate/entcs

On Regular Paths with Counting and Data Tests
Everardo B´arcenas1
CONACYT
Universidad Veracruzana Xalapa, Veracruz, Mexico
Edgard Ben´ıtez-Guerrero2
Facultad de Estad´ıstica e Inform´atica Universidad Veracruzana Xalapa, Veracruz, Mexico
Jesu´s Lavalle3
Benem´erita Universidad Aut´onoma de Puebla Instituto Nacional de Astrof´ısica, O´ptica y Electr´onica Puebla, Puebla, Mexico

Abstract
Regular path expressions represent the navigation core of the XPath query language for semi-structured data (XML), and it has been characterized as the First Order Logic with Two Variables (FO2). Data tests refers to (dis)equality comparisons on data tree models, which are unranked trees with two kinds of labels, propositions from a finite alphabet, and data values from a possibly infinite alphabet. Node occurrences on tree models can be constrained by counting/arithmetic constructors. In this paper, we
identify an EXPTIME extension of regular paths with data tests and counting operators. This extension is characterized in terms of a closed under negation Presburger tree logic. As a consequence, the EXPTIME bound also applies for standard query reasoning (emptiness, containment and equivalence).
Keywords: Modal Logics, XPath, Automated Reasoning, Data Trees, Counting


Introduction
XPath is a W3C standard query language for semi-structured data (XML), and it also takes an important role in many XML technologies, such as, XProc, XSLT,

1 iebarcenaspa@conacyt.mx
2 edbenitez@uv.mx
3 jlavalle@cs.buap.mx

http://dx.doi.org/10.1016/j.entcs.2016.11.002
1571-0661/© 2016 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

and XQuery [19,2]. The navigation core of XPath, also known as regular path queries, has been recently characterized by the First Order Logic of Two Vari- ables (FO2) [19]. Models for this logic are unranked trees, where nodes are labeled by propositions from a finite alphabet. Data tests, also known as data joins in databases community, on XPath queries are expressions of the forms ρ1 ≡ ρ2 and ρ1 /≡ ρ2. These expressions hold whenever data values (propositions from an infinite alphabet) contained in path ρ1 are (dis)equal to data values contained in path ρ2, respectively. Another important constructors on XPath queries concerns counting: ρ1 # ρ2, where # ∈ {≤, >, =, /=}. These expressions hold whenever the number of nodes denoted by ρ1 and ρ2 satisfies constraint #. There are several recent works studying regular path extensions with either data tests or counting [14,4,13,12,2]. However, as far as we know, the current work represent the first study on regular path extensions concerning both constructors, data tests and counting. More pre- cisely, we give a characterization of a regular paths with data test with respect to constants ρ ≡ k (ρ /≡ k) and with counting operators on children paths. For this characterization we use a modal tree logic equipped with a fixed point operator, converse modalities and Presburger arithimetic constraints [3]. Due to this char- acterization, the EXPTIME bound from the logic is imported to standard query reasoning (emptiness, containment, and equivalence) with counting and data tests.

Related works
There are several extensions of FO2 with data tests [16,8,6,7]. In [16], FO2(<, +1, ≡) for data trees is introduced: < stands for descendants and following sibling relations,
+1 refers to child and next sibling relations, and ≡ is a binary predicate for data tests. Decidability, without any complexity analysis, for FO2(<, +1, ≡) in data trees is first shown by a reduction to the reachability problem of a counter tree automata model. Previously in [6], the same result was obtained for data words (one branched tree), more precisely, FO2(<, +1, ≡) for data words was shown decidable by a reduction to reachability problem of Petri nets. A 3NEXPTIME upper bound for FO2(<, +1, ≡) is implied in [6]. Even earlier in [7], FO2(+1, ≡) for trees was introduced and shown decidable also in 3NEXPTIME. Regarding model theoretic results of extensions of FO with data models, in [8] several cases are studied: data words, data trees and data graphs. In another direction, regarding regular paths (XPath navigation core), it is well know data test on full navigation regular paths is undecidable [13]. Several fragments (downward, forward, transitive) of regular path expressions with data tests are studied [11,15,12,13,14]. With their corresponding complexity ranging from EXPTIME to non elementary. Contrastingly, in this paper, instead of restricting navigation on queries, we study the full navigation (children, parents, following and previous sibling, descendants and ancestros) regular path expressions, but we restrict data tests to constants only, that is, expressions of the form ρ ≡ k (ρ /≡ k).
Regarding regular paths with counting, there are several recent studies [19,2,4]. In [19], it was show the extension of regular paths with counting is in general undecidable. EXPTIME fragments (counting with respect to constants) were later

identified in [2,4]. In [2], it is shown regular paths with counting operators on children paths with respect to constants ρ > k is decidable in EXPTIME. The same bound was later shown for the extension of regular paths with counting on full navigation paths, also with respect to constants. In the current work, we study another counting extension ρ1 # ρ2 (# ∈ {≤, >, =, /=}), where expressions ρ1 and ρ2 are restricted to children paths. Several other logics with counting have been proposed in the setting of unranked trees [9,18,10,3,17]. A fragment of ambient logic is shown decidable via a reduction to the Presburger modal logic (modal logik K + Presburger arithmetic) in [9]. Presburger modal logic was later shown to be in PSPACE-complete [10]. In [18], en extension of Presburger modal logic with a fixed point is shown decidable in EXPTIME. The same bound was shown in [3] for a further extension of the logic with converse modalities and nominals (K+Presburger arithmetic+fixed point+converse+nominals). We show in the current paper this Presburger logic can actually characterize regular paths counting on children and data tests (w.r.t. constants). In [17], the EXPTIME bound was further developed for a set of coalegebraic modal logics via a type elimination algorithm. Excepting [5], where the emptiness problem for ranked tree automaton with equality and counting constraints was shown decidable without a further complexity analysis, all the above works study separately data tests and counting. In the current work, we identify an EXPTIME extension of regular paths with both, data tests and counting.

Outline
In Section 2, we introduce some preliminaries, more precisely, we introduce the no- tions of trees and data trees. We later describe a counting and data tests extension of regular paths in Section 3. In Section 4, we describe a modal tree logic with a fixed point, converse modalities and Presburger arithmetic constructors. The main result of this paper, which is a characterization of the regular path exten- sion with counting and data tests in terms of the logic, is described in Section 5. Since the characterization is polynomial and the logic is closed under negation, the EXPTIME bound for the logic can be imported for reasoning (emptiness, contain- ment and equivalence) on regular paths with counting and data tests. We conclude with a summary of this work, together with a brief discussion of further research perspectives in Section 6.

Preliminaries
For the languages described in the current work, unless otherwise stated, we use a fixed alphabet composed by set of propositions PROPS and a a set of modalities MODS = {↓, †, ›, ⭢}. Intuitively, propositions are used in tree models to label nodes, and modalities are interpreted as the children↓, parent †, right siblings ›, and left siblings ⭢ relations.
We now introduce the notion of a tree, which can be seen as a tree-shaped Kripke
structure (transition system).

Definition 2.1 [Tree] A tree T is defined as a tuple (N, R, L), such that
N is a finite set of nodes;
R : N ×MODS ×N is a transition relation among nodes and modalities forming a tree (we often write n ∈ R(nj, m) instead of (nj, m, n) ∈ R); and
L : N × PROPS is a left-total labeling relation (we often write p ∈ L(n) instead of (n, p) ∈ L).
The set of data values are the set of natural numbers N. Data trees can be seen as an extension of trees (Definition 2.1), where nodes are labeled with data values and propositions.
Definition 2.2 [Data tree] A data tree Γ is defined as a tuple (N, R, L, D), such that
(N, R, L) is a tree; and
D : N '→ N is a total function.
Regular Path Queries with Counting and Data Tests
We now describe regular path expressions [19] extended with counting and data tests. Basic path expressions have the form α : p, where the axis α can be the children ↓, the parent †, the right siblings ›, the left siblings ⭢, the descendants ↓٨, and the ancestors †٨. For instance, ↓٨: p selects descendants labeled with proposition
p. Paths ρ1 and ρ2 can also be composed ρ1/ρ2. Consider for example expression
↓٨: p/ ↓: q. This expression navigates to p descendants, and from there, it selects the q children. Also, paths can also be filtered by qualifiers. Expression ↓٨: p[↓: q] selects the p descendants with at least one q children. Other arithmetic constraints can be expressed by qualifiers, but only on children paths. For instance, ↓٨: p[↓: p1 =↓: p2] selects the p descendants with the same number of children named p1 and p2. Data tests also appear as qualifiers. For example, ↓٨: p[↓: q = 5] selects p descendants with at least one q child with data value equal to integer 5.
We now give a precise syntax of regular paths with counting and data tests.
Definition 3.1 [Syntax] We define the RPQCD expressions (queries) by the fol- lowing grammar:
ρ :=T| α | p | α : p | ρ/ρ | ρ[β]
β :=ρ | ρ − ρ # k | ρ ≡ k | ¬β | β ∨ β
where p ∈ PROPS, k ∈ N, # ∈ {>, ≤, =} and α ∈ {↓, †, ›, ⭢, ↓٨, †٨}.
In the case of ρ1 − ρ2 # k, both ρi (i = 1, 2) are restricted to be children paths, that is, they have one of the following forms: ↓, ↓: p, ↓ [β] or ↓: p[β].
RPQCD expressions are interpreted over data trees: T selects the entire set of
nodes; α : p navigates through α and selects the p nodes; ρ1/ρ2 is the compositions of paths; and ρ[β] selects the nodes denoted by ρ satisfying condition β. In particular,

when β is ρ ≡ k, it holds whenever there is a node denoted by ρ whose data value is equal to k. ρ1 −ρ2 # k is true if and only if the number of nodes selected by ρ1 minus the number of nodes selected by ρ2, satisfies constraint #k. Notice some syntactic sugar (notation) as ρ1#ρ2 instead of ρ1 − ρ2#0 can also be defined. Negation and disjunction are interpreted as expected.
We now give a precise description on how RPQCD expressions are interpreted over data trees.
Definition 3.2 [Semantics] Given a data tree Γ = (N, R, L, D), RPQCD expres- sions are interpreted as follows:
[[T]]Γ =N × N
[[p]]Γ = {(n, n) | p ∈ L(n)}
[[α]]Γ = n(n1, n2) | n1 →α n2,
[[α : p]]Γ = n(n1, n2) ∈ [[α]]Γ | p ∈ L(n2),
[[ρ1/ρ2]]Γ = [[ρ1]]Γ ◦ [[ρ2]]Γ
[[ρ[β]]]Γ = n(n1, n2) ∈ [[ρ]]Γ | n2 ∈ [[[β]]]Γ,
[[[ρ]]]Γ = nn | (n, nj) ∈ [[ρ]]Γ,
[[[ρ1 − ρ2 # k]]]Γ = nn | nn1 | (n, n1) ∈ [[ρ1]]Γ, − nn2 | (n, n2) ∈ [[ρ2]]Γ, # k,
[[[ρ ≡ k]]]Γ = nn | (nj, n) ∈ [[[ρ]]]Γ , D(n)= k, [[[¬β]]]Γ =N \ [[[β]]]Γ
[[β1 ∨ β2]]Γ = [[[β1]]]Γ ∪ [[[β2]]]Γ


where n1 →α
n2 holds, if and only if, n1 is related to n2 through α in Γ.

We also interpret RPQCD expressions with respect to a context, more precisely, the interpretation of a RPQCD expression ρ on a data tree Γ from a subset of nodes Nj (of Γ) is defined as follows:
[[ρ]]Γ ′ = nnj | (n, nj) ∈ [[ρ]]Γ ,n ∈ Nj,
We now define the standard query reasoning problems for RPQCD: emptiness, containment and equivalence.
Definition 3.3 [Reasoning]
We say a RPQCD expression ρ is empty, if and only if, for any data tree Γ, we have that [ρ]]Γ /= ∅.
Given two RPQCD expressions ρ1 and ρ2, we say ρ1 is contained in ρ2, written
ρ1 ⊆ ρ2, if and only if, for any data tree Γ, we have that [ρ1]]Γ ⊆ [[ρ2]]Γ.
Given two RPQCD expressions ρ1 and ρ2, we say ρ1 is equivalent to ρ2, if and only if, ρ1 ⊆ ρ2 and ρ2 ⊆ ρ1.

A Presburger Tree Logic
We now describe a modal tree logic, as originally introduced in [3], with a fixed point, converse modalities and Presburger arithmetic operators.
Definition 4.1 [Syntax] We inductively define the set of μTLIC formulas by the following grammar:
φ := p | ¬φ | φ ∨ φ | ⟨m⟩ φ | μx.φ | φ − φ # k
where p ∈ PROPS, m ∈ MODS, # ∈ {>, ≤, =}, and k ∈ N coded in binary form.
μTLIC expressions are interpreted as subset tree nodes: propositions are used as node labels; negation is interpreted as set complement; disjunction as set union; modal formulas ⟨m⟩ φ holds in nodes where there is at least one m transition to a node supporting φ; the fixed point operator μx.φ is interpreted as a recursion operator; and Presburger formulas φ − ψ # k selects nodes whose φ children minus ψ children satisfy constraint # k.
Before formally introduce the interpretation of μTLIC formulas, we first define a valuation function V : X '→ N of set of variables x over a set of nodes of a given tree.
Definition 4.2 [Semantics] Given a tree T = (N, R, L) and a valuation V , μTLIC formulas are interpreted as follows:


[[p]]T
[[¬φ]]T
[[φ ∨ ψ]]T
= {n | p ∈ L(n)}
=N \ [[φ]]T
= [[φ]]T ∪ [[ψ]]T

V	V	V
[[⟨m⟩ φ]]T = nn | R(n, m) ∩ [[φ]]T ,

[[μx.φ]]T
=   nM  | [[φ]]T M

/x]
⊆ M ,

[[φ − φ # k]]T
= nn | R(n, ↓) ∩ [[φ]]T − R(n, ↓) ∩ [[ψ]]T # k,

Without loss of generality, we assume variables can only occur bounded, and in the scope of modal or counting formulas [3]. Furthermore equivalent negated normal forms can also be achieved by traditional De Morgan’s and modal rules:
¬⟨m⟩ φ := [m] ¬φ
¬(φ ∨ ψ) := ¬φ ∧ ¬ψ
¬μx.φ := νx.¬φ [x/¬x]
¬(φ − ψ > k) := φ − ψ ≤ k
¬(φ − ψ ≤ k) := φ − ψ > k
¬(φ − ψ = k) := φ − ψ /= k
¬(φ − ψ /= k) := φ − ψ = k

We conclude this Section recalling the complexity of μTLIC.

Theorem 4.3 ([3]) μTLIC is in EXPTIME-complete.


Logic characterization
In this Section we give a characterization of RPQCD expressions in terms of μTLIC formulas.
First we define a non-data version of data trees. Intuitively, data values in data trees are represented by children nodes labeled by a fresh proposition δ. For instance, if a node has value k, then its non-data version has k children labeled by δ. Then, Presburger formulas can be used to test values in non-data trees.

Definition 5.1 Provided a data tree Γ = (N, R, L, D), we define the tree T (Γ) = (Nj, Rj, Lj) as follows:
let Ni be a set of ki new nodes (N ∩ Ni = ∅) induced by data values of nodes in
N , that is, for each ni ∈ N , D(ni)= ki, then Nj = N ∪  |N | Ni;
let Ri = {ni}× {↓}× Ni, then Rj = R ∪ |N | Ri;
and let Li : Ni×{δ} be left total, then Lj = L∪  |N| Li, provided δ is a proposition not occurring in L, that is, for each n ∈ N , if (n, p) ∈ L, then δ /= p.

Example 5.2 Consider for instance the following data tree Γ:
N = {n0, n1, n2, n3, n4};
n1 ∈ R(n0, ↓), n2, n3, n4 ∈ R(n1, ↓);
p ∈ L(n1), q ∈ L(n2), q ∈ L(n3) and r ∈ L(n4); and
D(n1)= 3, D(ni)=0 (i = 0, 2, 3, 4).
The corresponding tree T (Γ) is then defined as follows:
N = {n0, n1, n2, n3, n4, n5, n6, n7};
n1 ∈ R(n0, ↓), n2, n3, n4, n5, n6, n7 ∈ R(n1, ↓); and
p ∈ L(n1), q ∈ L(n2), q ∈ L(n3), r ∈ L(n4), and δ ∈ L(ni) (i = 5, 6, 7). In Figure 1, it is depicted a graphical representation of Γ and T (Γ).

We now give a precise translation of regular paths with counting and data tests in terms of the logic.

Definition 5.3 We define a translation function F of RPQCD expressions in terms



	
Fig. 1. A data tree Γ on the right with its corresponding tree f (Γ) on the left.
of the logic as follows:
F (T, C) := C л чδ	F (p, C) := p л чδ л C
F (↓, C) := чδ л ⟨†⟩ C	F (†, C) := чδ л ⟨↓⟩ C
F (›, C) := чδ л ⟨⭢⟩ C	F (⭢, C) := чδ л ⟨›⟩ C
F (↓٨, C) := чδ л μx.⟨†⟩ (C V x)	F (†٨, C) := чδ л μx.⟨↓⟩ (C V x) F (α : p, C) := F (α, C) л F (p, T)	F (ρ1/ρ2, C) := F (ρ2,F (ρ1, C)) F (ρ[β], C) := F (ρ, C) л G(β, T)
where δ is a fresh proposition and G is a translation of qualifiers (Definition 5.4).
Definition 5.4 We define a translation of qualifiers in terms of the logic as follows:
G(T, C) := C л чδ	G(α, C) := F (α, C)
G(p, C) := p л чδ л C	G(α : p, C) := F (α, C л p л чδ)
G(ρ1/ρ2, C) := G(ρ1, G(ρ2, C))  G(ρ[β], C) := G(ρ, G(β, T) л C)
G(чβ, C) := чG(β, C)	G(β1 V β2, C) := G(β1, C) V G(β2, C)
G(ρ ≡ k, C) := G≡(ρ ≡ k, C)	G(ρ1—ρ2 # k, C):= G #(ρ1, C)—G #(ρ2, C)# k

G≡(T≡ k, C) := (φδ л ⟨†⟩ G(T, C)= k
G≡(p ≡ k, C) := (φδ л ⟨†⟩ G(p, C)) = k
G≡(α ≡ k, C) := G(α, (φδ л ⟨†⟩ C)= k)
G≡(α : p ≡ k, C) := G(α, (φδ л ⟨†⟩ (C л p)) = k)
G≡(ρ1/ρ2 ≡ k, C) := G(ρ1, G≡(ρ2 ≡ k, C))
G≡(ρ[β] ≡ k, C) := G≡(ρ ≡ k, G(β, T) л C)
φδ := δ л чpj лч ⟨↓⟩T 

G # (↓, C) := C л чδ	G # (↓: p, C) := p л чδ л C
G # (↓ [β], C) := G(β, T) л C	G # (↓: p[β], C) := p л чδ л G(β, T) л C


	
provided that α is the dual relation of α, more precisely, ↓ =†, › =⭢, ↓٨ =†٨, and α = α; and where pj represents all other propositions distinct to δ (recall the set of propositions is finite).
Example 5.5 Consider expression ↓: p evaluated from an arbitrary context T, then its corresponding translation is F (↓: p, T) := чδ Λ ⟨†⟩T Λ p. In the data tree Γ defined in Example 5.2 and depicted in Figure 1, it is easy to see ↓: p selects n1, whereas F (↓: p, T) also selects n1 but in the corresponding tree f (Γ).
Consider now ↓: p[↓: q >↓: r] which is the short form of ↓: p[↓: q— ↓: r > 0]. This query selects the p children with more q children than r ones. See again Example 5.2 and Figure 1 for a data tree model. The corresponding translation is then
F (↓: p[↓: q >↓: r], T) := чδ Λ ⟨†⟩T Λ p Λ ((q Λ чδ) > (r Λ чδ))
We now consider an example with a data test ↓: p[T ≡ 3]. This expression denotes p children with data value equals to 3. The corresponding translation is then computed as follows:
F (↓: p[T≡ 3]) := чδ Λ ⟨†⟩T Λ p Λ (δ Λ чp Λч ⟨↓⟩T Λ ⟨†⟩ T)=3 
In Example 5.2 and in Figure 1 there is an instance model of the corresponding data tree Γ and tree Γ(f ).
Since translation of paths consider a context represented by formulas, we now give a non-data version of formulas. Intuitively, context formulas are indistinguish- ably interpreted over data and non-data trees.
Definition 5.6 [Context formula] Given a formula φ in negated normal form, its corresponding context formula φC is inductively defined as follows:
pC := p	(чp)C := чδ Λ чp
(φ V ψ)C := φC V ψC	(φ Λ ψ)C := φC Λ ψC
(⟨m⟩ φ)C := чδ Λ ⟨m⟩ φC	([m] φ)C := чδ Λ [m] φC
(μx.φ)C := φ μx.φ/x	(νx.φ)C := φ νx.φ/ 
C	C

(φ — ψ # k)C := φC — ψC # k
Lemma 5.7 Given any data tree Γ, for any formula φ and any valuation V , we have that
 φC Γ =  φC f (Γ)
V	V
Proof. By structural induction on φ.
The base cases where the input formula is a proposition or the negation of proposition is straightforward by construction of f (f ) (Definition 5.1). Notice nodes where δ is true does not support any other proposition.
The case of disjunction and conjunction are immediate by induction.

If the input formula is a modal formula ⟨m⟩ ψ or [m] ψ, it is also immediate by induction and by noticing nodes where δ is true are always leaves.
For fixed point cases μx.ψ or νx.ψ, we apply a second induction on the expan- sions ψ μx.ψ/x or ψ νx.ψ/x , which are guaranteed to be equivalent by the Fixed Point Theorem [3]. This second induction is immediate since variables always occur under the scope of a modality or a counting operator.
The case of counting formulas ψ — ϕ # k is also immediate by induction.   2
We now describe the main result of this paper: a sound characterization of regular paths with counting and data tests in terms of Presburger formulas.
Theorem 5.8 (Logic characterization of data queries) For any ρ RPQCD ex- pression, data tree Γ, μTLIC context formula φC, and any valuation V , we have the following:

[[ρ]]Γ	T (Γ)
[[φC ]]V
=  F ρ, φC  f (Γ); and

F ρ, φC  is of polynomial size with respect to q and φC.
Proof. For the first item, we now proceed by induction on the input expression ρ. Base cases where the input expression is either T or p are immediate by Lemma 5.7. Consider now the case of α : p, say α is ↓٨. Then
F ↓٨: p, φC := p л чδ л μx.⟨†⟩ (φC V x)
Since nodes where δ holds are always leaves, then чδ л μx.⟨†⟩ φC V x consistently characterizes descendants (↓٨) of φC. Other base cases are analogous.
For the inductive step, consider now ρ1/ρ2. Then
F ρ1/ρ2, φC := F ρ2,F ρ1, φC 
By induction we know that

[[ρ ]]f
= F ρ , φC  f (Γ)

[[ρ ]]f
= F ρ ,F ρ , φC  f (Γ)

2 [[F (ρ1,φC )]]T (Γ)	2	1	V
then, if we compose ρ1 and ρ2, we obtain

[[ρ /ρ ]]f
=  F ρ ,F ρ , φC  f (Γ)


Consider now the case ρ[β]. We know
F ρ[β], φC := F ρ, φC л G(β, T) By induction we know F ρ, φC corresponds to ρ, that is,

[[ρ]]Γ	T (Γ)
[[φC ]]V
=  F ρ, φC  f (Γ)

If we show β corresponds to G(β, T), that is, [β]]]Γ = [[G(β, T)]]f (Γ), we can clearly then infer the full correspondence of the input expression, that is,

[[ρ[β]]]Γ
= F ρ, φC  f (Γ) ∩ [[G(β, T)]]f (Γ)


Consider first the case where β is ρ[ρ1 — ρ2#k]. Now, recall that
G(ρ1 — ρ2#k, T) :=  G#(ρ1, T) — G#(ρ2, T)  #k
We now proceed by a second induction on the structure of ρi (i = 1, 2). Assume now ρi are ↓: pi, then
G#(ρ1, T) := pi л чδ лT 
Recall nodes where δ holds does not support any other proposition, hence G(↓: p1— ↓: p2#k, T) clearly counts pi children only, and holds where the corresponding counted children satisfy constraint #k, that is,
[[[↓: p1— ↓: p2 # k]]]Γ = [[G(↓: p1— ↓: p2 # k, T)]]f (Γ)
The other base cases, where one of ρi have the form ↓ and the other ρj is ↓: p, are analogous.
Consider now ρi are ↓: pi[βi]. The corresponding formula is then
G#(↓: pi[βi], T)= pi л чδ лTл G(βi, T)
In this case we apply yet another induction on βi to show its correspondence with G(β, T). This induction case is identical to the case of the first induction. It is then clear the correspondence of the arithmetical expression
[[[↓: p1[β1]— ↓: p2[β2]# k]]]Γ = [[G(↓: p1[β1]— ↓: p2[β2]# k, T)]]f (Γ)
For the other inductive cases, where one of ρi has the forms ↓ or ↓: pi and the other
ρj is ↓: pj[βj], we proceed similarly.
We now consider the case when β has the form ρ[ρ0 ≡ k]. Another induction is applied on ρ0. Assume ρ0 have the form ↓٨: p, then
G(↓٨: p ≡ k, T) := G(α, (φδ л G(p, T)) = k
:= μx.⟨↓⟩  δ л чpj лч ⟨↓⟩T л ⟨†⟩ (p л чδ)  = k V x 
This formula navigates recursively through children (descendants), until it finds nodes with k δ children. These children do not support other propositions pj, they are leaves ч⟨↓⟩ T, and its parent is labeled by p. Then clearly
[[[↓٨: p ≡ k]]]Γ = [[G(↓٨: p ≡ k, T)]]f (Γ)
Other base cases are proven analogously.

When ρ0 is ρ1/ρ2, then
G(ρ1/ρ2 ≡ k, T) := G(ρ1, G≡(ρ2 ≡ k, T))
By induction, we know G(ρ1) corresponds to nodes selected by ρ1, that is,
[[ρ1]]f = [[F (ρ1, T)]]f (Γ)
Also by induction, we know G(ρ2 ≡ k, T) selects the same nodes than ρ2 with k δ 
children. Hence if we evaluate ρ1 from the ρ2 ≡ k nodes, we thus obtain
[[[ρ1/ρ2 ≡ k]]]Γ = [[G(ρ1/ρ2 ≡ k, T)]]f (Γ)
Consider now ρ0 has the form ρ[β].
G(ρ[β] ≡ k, T) := G≡(ρ ≡ k, T) Λ G(β, T) By induction we know G≡(ρ ≡ k, T) corresponds to ρ ≡ k:
[[[ρ ≡ k]]]Γ = [[G(ρ ≡ k, T)]]f (Γ)
We now proceed by another induction on β to show G(β, T) corresponds β: [[β]]]Γ = [[G(β, T)]]f (Γ) This induction is identical as the one of the first inductive step. Hence, G(ρ[β] ≡ k, T) precisely selects the ρ nodes satisfying β (ρ[β]) with k δ children:
[[[ρ[β] ≡ k]]]Γ = [[ρ[β] ≡ k]]f (Γ)
In the second inductive step, now consider when β is a negation чβ0. This case goes smoothly by induction by noticing negation on counting and data test expressions are safe, that is, чG(ρ1 — ρ2 = k) is the same than G(ρ1 — ρ2 /= k), and vice-versa, analogously ≤ and ≡ are the dual of > and /≡, respectively.
Finally, disjunction β1 V β2 is immediate by induction.
Regarding the translation size, it is easy to see the resulting formula is of poly- nomial size by noticing the translation function does not introduce duplications, excepting pj, introduced by data tests.	2
An immediate consequence of Theorems 4.3 and 5.8 is an EXPTIME bound for RPQCD reasoning.
Corollary 5.9 Reasoning (emptiness, containment and equivalence) on regular path queries with counting and data tests (RPQCD) is in EXPTIME.
Discussion
We introduced an extension of regular path expressions with counting and data tests. Counting operators express occurrence restrictions on children path expressions,

whereas data tests express (dis)equality relations among paths with respect to their data values. We give a characterization of the extension of regular paths in terms of a Presburger logic originally introduced in [3]. Since the characterization is polynomial and the logic is closed under negation, the EXPTIME bound of the logic is then imported for the emptiness, containment and equivalence of paths with counting and data tests. As a first further research perspective we propose the study of the model checking problem of the Presburger logic (it is known a quadratic-time model checking algorithm for the logic without converse modalities [1]). This would imply complexity bound for the query evaluation of paths with counting and data tests. As another future work, we propose the study of further data test extensions of regular paths, in the setting of expressive modal logics with efficient reasoning Fischer-Ladner algorithms as in [3].

References
B´arcenas, E., E. Ben´ıtez-Guerrero and J. Lavalle, On the model checking of the graded μ-calculus on trees, in: 14th Mexican International Conference on Artificial Intelligence, 2015, pp. 178–189.
B´arcenas, E., P. Genev`es, N. Laya¨ıda and A. Schmitt, Query reasoning on trees with types, interleaving, and counting, in: T. Walsh, editor, IJCAI 2011, Proceedings of the 22nd International Joint Conference on Artificial Intelligence, Barcelona, Catalonia, Spain, July 16-22, 2011 (2011), pp. 718–723.
URL  http://ijcai.org/papers11/Papers/IJCAI11-127.pdf

B´arcenas, E. and J. Lavalle, Expressive reasoning on tree structures: Recursion, inverse programs, Presburger constraints and nominals, in: 12th Mexican International Conference on Artificial Intelligence, 2013, pp. 80–91.
B´arcenas, E. and J. Lavalle, Global numerical constraints on trees, Logical Methods in Computer Science 10 (2014).
URL  http://dx.doi.org/10.2168/LMCS-10(2:10)2014

Bargun˜o´, L., C. Creus, G. Godoy, F. Jacquemard and C. Vacher, Decidable classes of tree automata mixing local and global constraints modulo flat theories, Logical Methods in Computer Science 9 (2013).
URL  http://dx.doi.org/10.2168/LMCS-9(2:1)2013

Bojan´czyk, M., C. David, A. Muscholl, T. Schwentick and L. Segoufin, Two-variable logic on data words, ACM Trans. Comput. Log. 12 (2011), p. 27.
URL http://doi.acm.org/10.1145/1970398.1970403

Bojan´czyk, M., A. Muscholl, T. Schwentick and L. Segoufin, Two-variable logic on data trees and XML reasoning, J. ACM 56 (2009).
URL http://doi.acm.org/10.1145/1516512.1516515
Bojan´czyk, M. and T. Place, Toward model theory with data values, in: A. Czumaj, K. Mehlhorn,
A. M. Pitts and R. Wattenhofer, editors, Automata, Languages, and Programming - 39th International Colloquium, ICALP 2012, Warwick, UK, July 9-13, 2012, Proceedings, Part II, Lecture Notes in Computer Science 7392 (2012), pp. 116–127.
URL  http://dx.doi.org/10.1007/978-3-642-31585-5_14

Dal-Zilio, S., D. Lugiez and C. Meyssonnier, A logic you can count on, in: N. D. Jones and X. Leroy, editors, Proceedings of the 31st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2004, Venice, Italy, January 14-16, 2004 (2004), pp. 135–146.
URL http://doi.acm.org/10.1145/964001.964013
Demri, S. and D. Lugiez, Complexity of modal logics with presburger constraints, J. Applied Logic 8
(2010), pp. 233–252.
URL http://dx.doi.org/10.1016/j.jal.2010.03.001

Figueira, D., Forward-xpath and extended register automata on data-trees, in: L. Segoufin, editor, Database Theory - ICDT 2010, 13th International Conference, Lausanne, Switzerland, March 23- 25, 2010, Proceedings, ACM International Conference Proceeding Series (2010), pp. 231–241.
URL http://doi.acm.org/10.1145/1804669.1804699

Figueira, D., Decidability of downward xpath, ACM Trans. Comput. Log. 13 (2012), p. 34. URL http://doi.acm.org/10.1145/2362355.2362362


Figueira, D., On xpath with transitive axes and data tests, in: R. Hull and W. Fan, editors, Proceedings of the 32nd ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems, PODS 2013, New York, NY, USA - June 22 - 27, 2013 (2013), pp. 249–260.
URL http://doi.acm.org/10.1145/2463664.2463675

Figueira, D., S. Figueira and C. Areces, Model theory of xpath on data trees. part I: bisimulation and characterization, J. Artif. Intell. Res. (JAIR) 53 (2015), pp. 271–314.
URL http://dx.doi.org/10.1613/jair.4658

Figueira, D. and L. Segoufin, Bottom-up automata on data trees and vertical xpath, in: T. Schwentick and C. Du¨rr, editors, 28th International Symposium on Theoretical Aspects of Computer Science, STACS 2011, March 10-12, 2011, Dortmund, Germany, LIPIcs 9 (2011), pp. 93–104.
URL http://dx.doi.org/10.4230/LIPIcs.STACS.2011.93

Jacquemard, F., L. Segoufin and J. Dimino, Fo2(<, +1, ˜) on data trees, data tree automata and branching vector addition systems, Logical Methods in Computer Science 12 (2016).
URL  http://dx.doi.org/10.2168/LMCS-12(2:3)2016

Kupke, C., D. Pattinson and L. Schr¨oder, Reasoning with global assumptions in arithmetic modal logics, in: A. Kosowski and I. Walukiewicz, editors, Fundamentals of Computation Theory - 20th International Symposium, FCT 2015, Gdan´sk, Poland, August 17-19, 2015, Proceedings, Lecture Notes in Computer Science 9210 (2015), pp. 367–380.
URL  http://dx.doi.org/10.1007/978-3-319-22177-9_28

Seidl, H., T. Schwentick and A. Muscholl, Counting in trees, in: J. Flum, E. Gr¨adel and T. Wilke, editors, Logic and Automata: History and Perspectives [in Honor of Wolfgang Thomas]., Texts in Logic and Games 2 (2008), pp. 575–612.
ten Cate, B., T. Litak and M. Marx, Complete axiomatizations for xpath fragments, J. Applied Logic
8 (2010), pp. 153–172.
URL http://dx.doi.org/10.1016/j.jal.2009.09.002
