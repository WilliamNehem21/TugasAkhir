Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 295 (2013) 31–47
www.elsevier.com/locate/entcs

Assembling Components using SysML with Non-Functional Requirements
Samir Chouali, Ahmed Hammad, Hassan Mountassir 1
FEMTO-ST Institute UMR CNRS 6174
16, route de Gray - 25030 Besan¸con cedex, France

Abstract
Non-functional requirements of component based systems are important as their functional requirements, therefore they must be considered in components assembly. These properties are beforehand specified with SysML requirement diagrams. We specify component based system architecture with SysML block definition diagram, and component behaviors with sequence diagrams. We propose to specify formally component interfaces with interface automata, obtained from requirement and sequence diagrams. In this formalism, transitions are annotated with costs to specify non-functional property. The compatibility between components is performed by synchronizing their interface automata. The approach is explained with the example of the electric car CyCab, where the costs are associated to energy consumption of component actions. Our approach verifies whether, a set of components, when composed according to the system architecture, achieve their tasks by respecting their non-functional requirements.
Keywords: Component assembly, interface automata, SysML, non-functional properties, system architecture.


Introduction
The idea in component based software engineering (CBSE) is to develop software applications not from scratch but by assembling various library components. A com- ponent is a unit of composition with contractually specified interfaces and explicit dependencies, [19]. An interface describes the offered and required services without disclosing the component implementation. It is the only access to the information of a component. Interfaces may describe component information at signature (method names and their types), behavior or protocol (scheduling of method calls), semantic (pre and post conditions), and quality of services levels. The success of applying the component based approach depends on the interoperability of the connected components. The interoperability holds between components when their interfaces are compatible.

1 Email: {schouali, ahammad, hmountas}@femto-st.fr

1571-0661 © 2013 Elsevier B.V. Open access under CC BY-NC-ND license.
http://dx.doi.org/10.1016/j.entcs.2013.04.003

The SysML language is an UML profile, that is a language for documenting and graphically specify all aspects of a system consisting of hardware and/or software blocks. SysML has been proposed by the Object Management Group (OMG) [1] to define a general purpose modeling language for systems engineering. SysML enjoys unprecedented popularity both in industry and academia, It is used to harmonize the different actors contributing to the achievement of a system, and to ensure consistency and quality of design. It is a well suited language to model embedded systems.
In this paper, we focus on assembling components specified at the first step with SysML diagrams. In the second step, we propose a formal specification and verifi- cation approach to verify components composition based on the SysML models of the first step. Our approach exploit and adapt the interface automata formalism to verify components composition. The interface automata based approach was proposed by L.Alfaro and T.Henzinger, [2,3]. They have specified component in- terfaces with automata, which are labelled by input, output, and internal actions. These automata describe component information at signature and protocol levels. An interesting verification approach was also proposed to detect incompatibilities at signature and protocol levels between two component interfaces. The verification is based on the composition of interfaces, which is achieved by synchronizing shared actions.
In this context we propose to specify component based system (CBS) architec- ture, components requirements, and component behavior, with SysML diagrams. Our goal is to exploit the graphical formalism of SysML to model CBS. We argue that is a suitable formalism to specify components and to communicate between CBS specifiers and developers on CBS projects. Another goal is to treat CBS Non Functional (NF) requirements, which is facilitated by exploiting SysML requirement diagrams. In order to verify formally the assembly between components, specified with SysML models, we propose to adapt and to exploit the interface automata ap- proach. We propose two adaptations of this approach : (i) The first is to handle the system architecture specified with SysML in the formal specification and verification with interface automata. In fact Interface automata are proposed to specify com- ponent behaviors only and therefore are unable to describe the connection between primitives components and composites (composed of others components), and the hierarchical connections between composites and their sub-components, which also influences component behaviors. (ii) The second is to consider the NF-requirements in the interface automata formalism and in the verification of components compo- sition. These NF-requirements consist in the energy consumption of each services offered or required by components. So, we propose to annotate transitions in inter- face automata with costs, to obtain a king of weighted automata, and we propose to handle this annotations in the verification of components composition.
The paper is organized as follows. In Section 2, we present the example of the CyCab vehicle, and we specify semi-formally system architecture, component behaviors, and NF-requirements, with SysML diagrams. In Section 3, we describe a methodology to specify formally SysML architecture of a component based system.

Section 4 describes the proposed approach combining SysML and interface automata in order to assemble components and to verify their interoperability by considering system architecture and NF-requirements. Related works are described in Section
5. We conclude our work and trace some perspectives in Section 6.


Modeling a CyCab with SysML
In this section we present an example of component based system, and propose SysML diagrams to describe the system. These diagrams are considered as the first step of component based system modeling, which will be exploited in the formal specification and verification step (second step).


CyCab Informal Description
As an example, we consider a CyCab car component-based system (in [6]). The CyCab car is a new electrical means of transportation conceived essentially for free- standing transport services allowing users to displace through pre-installed set of stations. It is totally controlled by a computer system and it can be driven auto- matically according to many modes. The goal of the CyCab is to allow to a clients to use the vehicle to move from one station to another. To illustrate this concept, we consider the following system constraints:
(1) A CyCab has an appropriate road where stations are equipped with sensors and computing units. (2)We propose that the driving of the CyCab is guided by the information received from the stations, which situates the CyCab compared to the stations. (3)There is no obstacle in the road. (4)The vehicle is activated by the starter component. The vehicle has also an emergency halt button, associated to the emergency halt component. The emergency halt button can be activated at every moment during the CyCab moves. It is specified by sending the signal emgcy!.
The CyCab and its environment can be seen as an abstract system composed of two composite components : the vehicle, and the station. The vehicle is also composed by the primitive components : Vehicle Core, Starter, and Emergency Halt (associated to emergency halt button). The station is composed by the primitive components : Sensor, and Computing unit.
We consider also the following constraints :
The station is materialized by a sensor that receives signals from vehicle giving the vehicle position (spos? ). The Sensor converts this position to geographic coordinates and send a message (pos!) to the Computing Unit. After treating the vehicle position, the Computing Unit sends, as consequence, a signal (far! or halt! ), to the corresponding vehicle to indicate if it is far from the station or not.
The vehicle sends also a signal reset! to the component emergency halt in order to reset the system after activating the emergency halt button.

Block Deﬁnition Diagram
SysML provides a structural element called a block. A block can represent any type of component of the system, physical, logical, functional, or human. Blocks are de- clared within a Block Deﬁnition Diagram (BDD ) which describes the structure of the system. The role ofa BDD is to describe the relationships among blocks, which are basic structural elements aiming to specify hierarchies and interconnections of the system to be modeled. Required interfaces (relation uses) and offered (relation implements) of components are also described. Figure 1 shows an example of a


Fig. 1. Block Definition Diagram of CyCab
BDD with eight blocks. It is the first level of modeling of the CyCab. The block named CyCab System represents the system as a whole. It is decomposed into two sub blocks (Vehicle, and Station) and is linked to them by the composition relationship. The component Vehicle is divided into three sub-components which are Starter, Vehicle Core (VC) and Emergency Halt (EH). Station is de- composed into two sub-components that are Sensor and Computer Unit (CU). In this paper we exploit a BDD to specify formally the system architecture, and

exploit this specification in components assembly.
Internal Block Diagram
The Internal Block Diagram (IBD ) allows the designer to refine the structural aspect of the model. The IBD is the equivalent in SysML of the composite structure diagram in UML . In the IBD, parts are basic elements assembled to define how they collaborate to realize the block structure and/or behavior. A part in SysML corresponds to an object in UML . Parts represent the physical components of the block while flow ports represent the interfaces of the block, through which its communicates with other blocks.
The figure 2 shows the IBD of Vehicle . For example in Figure 2, the parts Starter, Vehicle Core (VC) and Emergency Halt (EH) cooperate to achieve the functionality of the component Vehicle. This diagram shows the assembly links between components, so we exploit it to deduce the assembly order between components.





Fig. 2. Internal block diagram of vehicle


Requirement diagram
Requirement specifies capability or condition that must be delivered in the subject (target system). Capability usually refers to the function that the system must support and we call it functional requirement. Condition usually means that the system should be able to run or produce the result in specific constraint, and we call it non-functional requirement The SysML requirement diagram allows several ways to represent requirements relationships. These include relationships for defin- ing requirements hierarchy, deriving requirements, satisfying requirements, verifying



Fig. 3. Requirements diagram




requirements and refining requirements. The relationship can improve the specifi- cation of systems, as they can be used to model requirements. In Figure 3, the requirement GECC, Global Maximal Energy Consuming of CyCab, indicates that the CyCab must not exceed the limit of energy consuming. This requirement con- tains the requirements ECS, Maximal Energy Consuming of the Station component and ECV, Maximal Energy Consuming of the Vehicle component. The requirement ECS contains the requirements ECSS, Maximal Energy Consuming of the Sensor component, and ECCU, Maximal Energy Consuming of the Computing Unit com- ponent. The requirement ECV contains the requirements ECVC, Maximal Energy Consuming of the Vehicle Core component, ECSR, Maximal Energy Consuming of the Starter component, and ECEH, Maximal Energy Consuming of the Emergency Halt component. For example in the requirement ECSS, the identifier Qpos is the number of energy resources necessary to execute the offered service pos by other components, and the identifier Qspos is the maximum of energy resources that the component Sensor could use to execute the required service spos.

Sequence Diagram
The sequence diagram is used to represent the interaction between structural ele- ments of a block, as a sequence of message exchanges, called also component (or block) protocols. In the CyCab system, the Vehicle sends signals spos! to inform the upcoming station about its positions and it receives as consequence signals (far ! or halt !) to know if it steels far from the station or not. The two components Sensor (Ss) and ComputingUnit (Cu) are the subcomponents of the station. The sensor detects a position signal sent from the vehicle and converts it to geographic coor- dinates (pos!) which will be used by the ComputingUnit to compute the distance between the vehicle and the station and decide if they steel far from each other or not. The vehicle is composed by three primitive components: the VehicleCore (Vc), the Starter (Sr ), and the embedded EmergencyHalt (Eh) device. For example, the




Fig. 4. Sequence diagram of computer unit

figure 4 shows the sequence diagram component ComputingUnit. This diagram specifies the component protocols, which exhibits the interaction between the com- ponent and its environment. The environment represent the others components in the system. So the Computing Unit receives the message, pos, from the environ- ment (which is the Sensor component) and responds by sending the messages far or halt the environment (vehicle component).
Formal specification of SysML system architecture
In the previous section, we have proposed to specify component based system archi- tecture with BDD and IBD SysML diagrams. BDD diagram show the system global structure, and the relation between Composite blocks (composite component) and their sub-blocks (sub-components). IBD diagram show the composition links be- tween blocks. In this section, we propose to specify formally this architecture as a graph where nodes correspond to the Blocks of the system and edges represent both

hierarchical relations between composite Blocks and their sub-blocks. The nodes of the graph can be seen as tree if we consider only hierarchical relations. In the CyCab example, we associate the graph described in Figure 5, to model formally the system architecture described by BDD and IBD SysML models. The continu- ous edges represent the hierarchical relations between composite Blocks and their sub-blocks, which are specified in the BDD model. The dashed edges represent the connections between components at the level of composite Blocks. This connection links are specified in IBD models. Two Blocks are connected if and only if there is at least one interaction between their interfaces.
The formal definition of this graph is presented in the definition 1. For a SysML system architecture M, we denote by CM all the (composite and primitive) components composing M.
Definition 1 (Graph Representation of Architecture). A Graph Represen- tation GM = ⟨ NGM , CpGM , CnGM ⟩ of a system SysML architecture M, consists of
a ﬁnite set NGM of nodes representing CM ;
a ﬁnite set CpGM of edges representing the relations between the nodes represent- ing composite blocks and their sub-blocks;
a ﬁnite set CnGM of edges representing the connections between the nodes repre- senting sub-components within a same Block.














Fig. 5. The graph of the CyCab car system

By traversing this graph, we can easily extract the authorized order in which the components of the whole system (composite system) will be composed, then we ex- ploit this information in the verification of the compatibility between components. For example, the order of the composition associated the CyCab system based the tree described in the figure 5 is: (Starter  V ehicleCore  EmergencyHalt)  (Sensor  ComputingUnit). In fact we can see in the figure 5 that the nodes Eh, V c, Sr, associated respectively to the components EmergencyHalt, Vehi-

cleCore, and Starter, are connected with dashed links, and they are also associated to the node, Vehicle, which corresponds to th composite component V ehicle. So they can be assembled together by (Starter  V ehicleCore  EmergencyHalt), in order to obtain the composite Vehicle. We apply the same process on the compo- nents Sensor and ComputingUnit which are associated to the nodes Cu and Ss, and the composite Station, obtained by (Sensor  ComputingUnit). We can see also in the same figure that the node Vehicle is related to the node Station by a dashed link, and they are also related to the whole system. So to obtain a system one have to compose : (Starter  V ehicleCore EmergencyHalt)  (Sensor  ComputingUnit). We consider that the symbol  is the operator of composition. We note that the operation of composition is associative, so the order of composition has no effect in the the verification of the compatibility between components.
Interface automata strengthened by non-functional property and SysML diagrams
In this section we present our formalism based on interface automata to specify formally the component interfaces according to SysML diagrams, in order to verify component interoperability.
Component interfaces based on SysML sequence diagrams and NF require- ments
We propose to specify formally component interfaces by considering component protocols specified by sequence diagrams, and component Non Functional (NF) requirement specified by requirements diagrams. So, we propose to exploit the interface automata formalism, which we enrich with NF requirements in order to model formally SysML sequence diagram and requirement diagram.
Interface automata have been defined by L.Alfaro et al. [2], to model the temporal behavior of software component interfaces. They are considered as labeled transition systems, where the transitions are labeled with the names of actions which are divided into three categories: input, output, and hidden actions. Every component interface is described by one interface automaton where input actions are used to model methods that can be called, and the end of receiving messages from communication channels, as well as the return values from such calls. Output actions are used to model method calls, message transmissions via communication channels, and exceptions that occur during the method execution. Output actions describe the required actions of a component (represented by the symbol ”!”), input actions describe the provided actions of a component (represented by the symbol ”?”), and internal (or hidden) actions inside the component itself describe its local operations (represented by the symbol ”;”). We define by ΣI (s), ΣO(s),
A	A
ΣH (s) the input, output, and internal actions enabled at the state s.
In this section we show how to exploit the interface automata formalism in order to consider energy consumption (non-functional requirements) of each component

action, in the specification and the verification of component assembly. So, we present below a definition of interface automata strengthened by the function that specifies energy consumption. So we define a kind of weighted automata where transitions are annotated with costs which correspond to energy consumption of actions.
Definition 2 (Interface Automata). An interface automaton A= ⟨ SA, IA, ΣI ,
ΣO, ΣH, δA, λA ⟩ consists of
A	A
a ﬁnite set SA of states;
a subset of initial states IA ⊆ SA;

three disjoint sets ΣI , ΣO and ΣH
of inputs, output, and hidden actions, we

A	A	A
denote by ΣA = ΣI ∪ ΣO ∪ ΣH ;
A	A	A
a set δA ⊆ SA × ΣA × SA of transitions between states;
λA : total function that associates to each action the number of energy resources necessary to its execution ΣA → N. This function specifies the values which we associate to the maximum of energy consuming of each component action, specified in the requirement diagram.
When we compose two interface automata, the resulting composite automaton, based on the synchronized product of the both automata, may contain illegal states, where one automaton issues an output action that is not acceptable as input in the other one. The existence of these illegal states is not sufficient to decide the incom- patibility between interfaces . Indeed, the proposed interface automata approach, called also optimistic approach, allows to verify the compatibility between interface automata, based on the fact that there is an environment which provides only legal inputs. The composite interface expects the environment to pass over transitions leading only to legal states. The existence of such legal environment for the compo- sition of two interfaces indicates that there is a way that the components can work together properly.
The interface automata of the primitive components of the CyCab car system are presented in Figure 6 and Figure 7. The energy consumption information are indicated in the interface automata. These automata specifies formally the sequence diagram and requirement diagram described in the previous section. So the inter- face automata of the component Computer Unit described in Figure 7, specifies the protocol of this component,therefore it specifies the sequence diagram of Computing Unit described in Figure 4. We also exploit the NF requirements described with requirement diagram in Figure 3 to annotate transition in the interface automata with cots associated to energy consumption by each actions. For example, in Figure 6, we can see in the interface automaton of the component Vehicle core, that the component offers an action far? which necessitates 5 energy units, and the compo- nent requires an action spos! with at most 6 energy units. These values 5, and 6 correspond respectively to Qfar and Qspos in the requirement ECV in figure 3.


	

Fig. 6. The interface automata of the Vehicle subcomponents


halt





Fig. 7. The interface automata of the Station subcomponents
Blocks Compatibility Veriﬁcation
The verification of the compatibility between a blocks (component C1) and a other block (component C2) is obtained by verifying the compatibility between their interface automata A1 and A2. The verification steps of the compatibility are listed below.
Main algorithm
Input : SysML modelling
Output : the interface automaton of the composite component if the compatibility is satisfied, or an empty automata in other case.
Algorithm steps :
(i) Generating the corresponding tree to the block definition diagram and internal blocks in order to specify formally system architecture : this step is performed by applying transformation rules from BDD and IBD to obtain the tree. These rules are obvious. For example each block corresponds to a tree node, and the links between block are treated in two steps, in order to obtain the links between blocks and their sub-blocks from BDD and the links between the sub-blocks from IBD models. (ii) Formal specification of sequence diagrams and requirement diagram with interface automata enriched with non-functional property: this step is performed by applying transformation rules from sequence diagram and require- ment diagram to obtain interface automata with energy consumption constraints. Rule transformation from sequence diagrams to interface automata are presented in [10] . The originality in this paper is the consideration of the requirement diagrams and the NF-requirements in the interface automata approach. We exploit these diagrams to annotate transitions with costs in interfaces automata. (iii) compatibility verification between interface automata by processing the following

algorithm (Algorithm 2) and considering the system architecture and the NF property.
Algorithm 2
Input : interface automata A1, A2.
Output : A1  A2.
Algorithm steps :
Verify that A1 and A2 are composable. (ii) Compute the product A1 ⊗ A2.
(iii) Compute the set of illegal states in A1 ⊗ A2. (iv) Compute the set of incompatible states in A1 ⊗A2: the states from which the illegal state are reachable by enabling only internal and output actions (one suppose the existence of a helpful environment). (v) Compute the composition A1  A2 by eliminating from the automaton A1 ⊗ A2, the illegal states, the incompatible states, and the unreachable states from the initial states. (vi) If A1  A2 is empty then A1 and A2 are not compatible, therefore C1 and C2 can not be assembled correctly in any environment. Otherwise, A1 and A2 are compatible and their corresponding component can be assembled properly.
In the following, we present the definitions of formal concepts (composition condition, synchronized product...) exploited in the below algorithm by considering NF property.
The composition operation may take effect only if the actions of the two automata are disjoint, except shared input and output actions between them. When we compose them, shared actions are synchronized and all the others are interleaved asynchronously.
Definition 3 (Composition Condition). Two interface automata A1 and A2
are composable if

I  ∩ ΣI
1	2
= ΣO
1
∩ ΣO
2
= ΣH
1
∩ ΣA2
= ΣH
2
∩ ΣA1 = ∅

Shared (A1,A2) = (ΣI
∩ ΣO ) ∪ (ΣI
∩ ΣO ) is the set of shared actions between

A1 and A2.
A1	A2
A2	A1

In the following we present the definition of synchronized product between two interface automata taking into account energy consumption constraints. The intu- ition behind the following definition is, two components can synchronize on shared actions whether one of two interacting components, C1, requires an action sa (out- put action) which consumes x energy units, and the other component, C2, offers the action sa (input action) which consumes y energy units, such that x ≥ y. This is an obvious condition because : First, generally components are reusable, and developed by different teams and companies, so the offered and the required actions of components may not consume the same amount of energy units. Second, for example: C1 can not use the offered action, sa, by C2, if this action necessitates more energy units than those allocated by C1.
Definition 4 (Synchronized product considering Energy Consumption).

Let A1 and A2 be two composable interface automata. The product A1 ⊗ A2 is deﬁned by

SA ⊗A
= SA
× SA
and IA ⊗A
=	IA
× IA ;  ΣI
=	(ΣI	∪

1	2	1	2
1	2	1
2	A1⊗A2	A1

I  )	\	Shared(A1, A2);  ΣO
=	(ΣO
1
∪ ΣO )	\	Shared(A1, A2);

H A1⊗A2
= ΣH
1
∪ ΣH
2
∪ Shared(A1, A2);

((s1, s2), a, (sj , sj )) ∈ δA ⊗A if
1	2	1	2


a /∈ Shared(A1, A2) ∧ (s1, a, sj ) ∈ δA
a /∈ Shared(A1, A2) ∧ (s2, a, sj ) ∈ δA
a ∈ Shared(A1, A2) ∧ (s1, a, sj ) ∈ δA
∧ s2 = sj
∧ s1 = sj
∧ (s2, a, sj ) ∈ δA



∧((λA (a) ≤ λA (a) ∧ a ∈

1	1	2	2	1	2
ΣI (s1) ∧ a ∈ ΣO (sj )) ∨ (λA (a) ≥ λA (a) ∧ a ∈ ΣO (s1) ∧ a ∈ ΣI (sj )))
A1	A2	1	1	2	A1	A2	1

λA1⊗A2
: ΣA1⊗A2
→ N such that ΣA1⊗A2
I A1⊗A2
O A1⊗A2
H A1⊗A2
, to define

λA1⊗A2 we consider the following cases :

· a ∈ ΣA ⊗A	∧ λA ⊗A (a) = λA (a) if a /∈ Shared(A1, A2) ∧ (a ∈ ΣI
∨ a ∈

1	2	1	2	1	A1
O ∨ a ∈ ΣH );
1	1

· a ∈ ΣA ⊗A	∧ λA ⊗A (a) = λA (a) if a /∈ Shared(A1, A2) ∧ (a ∈ ΣI
∨ a ∈

1	2	1	2	2	A2
O ∨ a ∈ ΣH );
2	2
· a ∈ ΣA1⊗A2 ∧ λA1⊗A2 (a)= min(λA1 (a), λA2 (a)) if a ∈ Shared(A1, A2) ∧ ((a ∈

I  ∧ a ∈ Σ0
1	2
) ∨ (a ∈ ΣO
1
∧ a ∈ ΣI
2
)) 2 .

In the following we adapt the definition of illegal states in order to consider energy consumption constraints. So, a state (s1,s2) in the product is considered illegal in the following cases: (i) One component requires a shared action from the state s1 which is not provided from the state s2 in the other component or vice versa.
one component provides a shared action with a value of energy consumption greater than the value of energy consumption of the required action, by the other component.
Definition 5 (Illegal States considering Energy Consumption). Given two composable interface automata A1 and A2, the set of illegal states Illegal (A1, A2)
⊆ SA1 × SA2 of A1 ⊗ A2 is defined by {(s1, s2) ∈ SA1 × SA2 |∃a ∈ Shared(A1, A2).
((a ∈ ΣO (s1) ∧ a /∈ ΣI (s2))∨ (a ∈ ΣO (s2) ∧ a /∈ ΣI (s1))∨ (a ∈ ΣO (s1) ∧ a ∈
A1	A2	A2	A1	A1
ΣI (s2) ∧ λA (a) > λA (a))∨ (a ∈ ΣI (s1) ∧ a ∈ ΣO (s2) ∧ λA (a) > λA (a)))}.
A2	2	1	A1	A2	1	2
Definition 6 (Composition). Given two compatible interface automata A1 and
A2. The composition A1  A2 is an interface automaton deﬁned by: (i ) SA1  A2

= Comp(A1,A2) 3 , (ii ) the initial state is IA  A
= IA1⊗A2
∩ Comp(A1,A2),

ΣA1  A2  = ΣA1⊗A2 , and (iv ) the set of transitions is δA1  A2  = δA1⊗A2  ∩
(Comp(A1,A2) × ΣA1  A2 × Comp(A1,A2)).
The complexity for computing the composition A1  A2 is in time linear on
|A1| and |A2| [2]. The verification steps in this approach are the same as the ones

2 min is a function which returns a minimum value between two positive real numbers
3 The set of compatible states which are not reachable from illegal states.

presented in [2]. However, in our approach we consider energy consumption in the interface automata definition, in the product of two interface automata, and in the definition of the illegal states. Consequently, our approach does not increase the complexity of the verification algorithm.
Illustration on the CyCab
The reader can easily verify that by applying the algorithms described in the section
4.2 on the interface automata of the Vehicle and Station composites (Figures 6 and 7), we obtain the following results. In the interface automaton (Figure 8) obtained by calculating the synchronized product (Vc ⊗ Eh) between the Vehicle Core and the Emergency Halt components, all the states are illegal, this is due to the action emgcy!/6 in Eh automaton which is not compatible with the actions emgcy?/12 in Vc automaton, so the components in the Vehicle composite are incompatible. However the components in the Station composite are compatible because the initial state in the interface automaton Cu ⊗ Ss, is not reachable from the illegal state 4, so the composition Cu  Ss is not empty after eliminating illegal and incompatible states (Figure 9).











Fig. 8. Compatibility verification in the Vehicle composite













Fig. 9. Compatibility verification in the Station composite

Related works
In this section, we present a short survey of existing works about the non-functional properties (NFP) modeling and evaluation on components based system. Specific

to component-based systems, numerous studies have been conducted around the analysis, modeling and management of non-functional properties in components assembly. Analysis models and property theories are integrated to component tech- nology in [17], and they allow one to guarantee, by construction, the predictability of some properties on components assembly. But, they require advanced analysis models and techniques, and are mostly dedicated to specific properties, such as la- tency [17], reliability [15], [4] or memory usage [13]. Some of these models could also be extended to other properties that are related to the system architecture and can be modeled in generic ways that allows to reason on them. In [16], the authors pro- pose assume-guarantee interface algebra for real-time components. In the interface specification, they consider the following properties : an arrival rate function and a latency for each task sequence, and a capacity function for the shared resource. The interface specifies that the component guarantees certain task latencies depending on assumptions about task arrival rates and allocated resource capacities. These properties are considered in the verification of interface compatibility. These last approaches treat non-functional properties in component composition but the ar- chitecture of the whole system is not considered. In [20], the author presents a way to introduce non-functional properties in a system with components expressed with TLA+. The main contribution of this paper is to show how these concepts can be expressed formally. In [9], the authors propose resource interfaces to specify component interfaces with requirements on limited resources. This approach allows verifying if a collection of components when put together exceed the available re- sources. These interfaces communicate with the environment with input and output variables, which decorate automata states, however in our case the communication is performed with input and output actions. In [12], the authors propose an ex- tension of the interface automata approach to capture in addition to component protocols, the timing dimension of component interfaces. Timed interface is en- coded as a timed game between input and output players. A verification algorithm for interfaces compatibility was also proposed. A close formalism to timed interfaces was proposed in [11], were the authors proposed a complete specification framework for real time systems based on timed Input/Output automata formalism. This ap- proach support refinement, consistency checking, and composition. The difference with our approach is, in our case we treat a kind of NF properties which is energy consumptions, this constraint necessitates only to exploit weighted automata (as- sociate a cost to transitions), however in [12], and [11] they exploit weighted timed automata: costs associated to transitions and valued states with clock variables in [11], and valued states with clock variables in [12]. Which increase the complexity of the verification of components composition. In our approach we have also to respect SysML diagrams where state variables are not allowed in the description of components, but only the order of actions and their energy consumptions. Conse- quently, our formalism is different from these formalisms and it is more suitable to model SysML diagrams.
In this section, we present works which treat the combination of graphical and
formal languages to model NFP and to verify them. For example, the work proposed

in [8], the authors present a new approach to component interaction specification and verification process which combines the advantages of architecture description languages and model based formal verification. The approach proposed in [18] aims to endow the UML components to specify interaction protocols between com- ponents. The behavioral description language is based on hierarchical automata inspired from StateCharts. It supports composition and refinement mechanisms of system behaviors. The system properties are specified in temporal logic.In [7], [14], the authors have presented work attempting to merge techniques from software performance engineering with component-based software engineering. They distin- guish two model layers: the software model which represents the logical component structure of a system, and the machinery model which models properties relevant for performance analysis. In [5], this article focuses on the verification of a non- functional property which is a kind of deadline. the system is modeled in the form of data flow diagrams using a subset of the UML activity diagram. This is mapped to hierarchical and modular time Petri nets . This check is performed with the TINA tool. The contribution and the originality of our approach, compared the these related works is the specification of component interfaces with interface automata, which are more general formalism based on rich notations which allow to express more complex component behaviors. We propose also a connection with SysML to verify components composition by taking into account non-functional properties and system architecture.

Conclusion and future work
In this paper, we present an approach which combines formal and semi-formal for- malisms, to compose components and to verify their interoperability. This verifica- tion is performed according to energy consumptions properties specified by SysML requirement diagrams, to a system architecture, specified by SysML block defini- tion diagram, and to component protocols specified by sequence diagrams. This ap- proach use interface automata method to specify component interfaces and to verify interface compatibility. We have adapted this approach to make it more appropri- ate to the formalization of SysML models. So we have considered non-functional properties and exploited BDD, and IBD SysML models, in order to specify system architecture. These models are specified formally by a tree, where nodes correspond to blocks and edges specify connections between blocks. From this tree, we deduce information to adapt interface automata approach in order to verify interface com- patibility by considering the architecture of the whole system. Requirement and sequence diagrams are also exploited to annotate transitions in interface automata with costs corresponding to energy consumption of components services. The adap- tations introduced in interface automata approach do not increase its complexity. We propose to verify whether the energetic consumption of a component based sys- tem is in compliance with the available resources of energy. As future work, We plan to implant the algorithms described in this paper and to evaluate the proposed approach on more realistic case study.

References
http://www.omg.org.
L. Alfaro and T. A. Henzinger. Interface automata. In 9th Annual Symposium on Foundations of Software Engineering, FSE, pages 109–120. ACM Press, 2001.
L. Alfaro and T. A. Henzinger. Interface-based design. In Engineering Theories of Software-intensive Systems, volume 195 of NATO Science Series: Mathematics, Physics, and Chemistry, pages 83–104. Springer, M. Broy, J. Gruenbauer, D. Harel, and C.A.R. Hoare, 2005.
R. R. an H. Schmidt and I. Poernomo. Reliability prediction for component-based software architectures. Journal of Systems and Software, 65(3), 2003.
C. Andr´e, F. Mallet, and M.-A. P. Frati. Non-functional property analysis using UML2.0 and model transformations. Technical report, Reserach Report INRIA, RR-5913., 2006.
G. Baille, P. Garnier, H. Mathieu, and R. Pissard-Gibollet. The INRIA Rhˆone-Alpes CyCab. Technical report, INRIA, 1999.
Bertolino and R. A., Mirandola. Towards component based software performance engineering. In 6th Workshop on Component-Based Software Engineering: Automated Reasoning and Prediction at ICSE 2003, ACM/IEEE (2003) 1?6., 2003.
L. Brim, I. Cˇern´a, P. Vaˇrekov´a, and B. Zimmerova. Component-interaction automata as a verification- oriented component-based system specification. SIGSOFT Softw. Eng. Notes, 31(2):4, 2006.
A. Chakrabarti, L. de Alfaro, T. A. Henzinger, and M. Stoelinga. Resource interfaces. In EMSOFT, pages 117–133, 2003.
S. Chouali and A. Hammad. Formal verification of components assembly based on sysml and interface automata. ISSE, 7(4):265–274, 2011.
A. David, K. G. Larsen, A. Legay, U. Nyman, and A. Wasowski. Timed i/o automata: a complete specification theory for real-time systems. In HSCC’10, pages 91–100, 2010.
L. de Alfaro, T. A. Henzinger, and M. Stoelinga. Timed interfaces. In EMSOFT, pages 108–122, 2002.
E. Eskenazi, A. Fioukov, D. Hammer, and M. Chaudron. Estimation of Static Memory Consumption for Systems Built from Source Code Components. In 9th IEEE Conference and Workshops on Engineering of Computer-Based Systems, 2002.
V. Grassi and R. Mirandola. Towards automatic compositional performance analysis of component- based systems. In In Dujmovic, J., Almeida, V., Lea, D., eds.: Proc. 4th Intl Workshop on Software and Performance WOSP 2004, pages 59–63, California, USA, 2004. ACM Press.
D. Hamlet, D. Mason, and D. Woit. Theory of Software Reliability Based on Components. In
Proceedings of in ICSE 2001. IEEE Computer, 2001., 2001.
T. A. Henzinger. An interface algebra for real-time components. In In Proc. of IEEE Real-Time Technology and Applications Symposium, pages 253–263. Society Press, 2006.
S. Hissam, G. Moreno, J. Stafford, and K. Wallnau. Enabling predictable assembly. Journal of Systems and Software, 65(3), 2003.
S. Moisan, A. Ressouche, and J. Rigault. Behavioral substitutability in component frameworks: A formal approach. In SAVCBS, pages 22–28, 2003.
C. Szyperski. Component Software. ACM Press, Addison-Wesley, 1999.
S. Zschaler. Formal specification of non-functional properties of component-based software systems: A semantic framework and some applications thereof. SoSyM, 9:161–201, Apr. 2009.
