Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 298 (2013) 51–69
www.elsevier.com/locate/entcs

Normalization by Evaluation and Algebraic Effects
Danel Ahman1
Laboratory for Foundations of Computer Science University of Edinburgh

Sam Staton2
Computer Laboratory University of Cambridge


Abstract
We examine the interplay between computational effects and higher types. We do this by presenting a normalization by evaluation algorithm for a language with function types as well as computational effects. We use algebraic theories to treat the computational effects in the normalization algorithm in a modular way. Our algorithm is presented in terms of an interpretation in a category of presheaves equipped with partial equivalence relations. The normalization algorithm and its correctness proofs are formalized in dependent type theory (Agda).
Keywords: Algebraic effects, Type theory, Normalization by evaluation, Presheaves, Monads


Introduction
When studying computer programs it is often appropriate to consider them up to some equations. In this paper we consider an equational theory for impure func- tional programs. By finding a class of normal forms for this equational theory, we are able to understand and manipulate the notions under study directly. Moreover, it has been proposed that normalization algorithms are of use in partial evaluation: if a program fragment with free variables is normalized at compile-time then it will typically run faster.

1 Email: d.ahman@ed.ac.uk
2 Email: sam.staton@cl.cam.ac.uk

1571-0661 © 2013 Elsevier B.V. Open access under CC BY-NC-ND license.
http://dx.doi.org/10.1016/j.entcs.2013.09.007

To be more precise, we introduce a small program in an ML-like language.

(fn (g:(unit -> unit) -> unit)
=> g (if recv()=0 then fn x => send 0 ; h x else fn y => send 1)) (fn (f:unit -> unit) => f () ; f ())	(∗)
Here recv:unit->bit and send:bit->unit are network communication primitives, as in Concurrent ML [41], and h:unit->unit is a free identifier of function type. Notice that we cannot naively compile and run this program to find out what it does, because it has a free identifier h, and because its execution will depend on what is received from the network.
Before we normalize the program, we translate it to an intermediate language which makes the evaluation order clear. We also remove the bit type from the program, since it complicates the normalization process and is orthogonal to what we are investigating. (We return to the issue of sum types in §6). We elimi- nate the need for a bit type by using algebraic operations, following [36]: we re- place (if recv()=0 then M else N ) by inp[M, N ], replace (send 0 ; M ) by out0[M ] and (send 1 ; M ) by out1[M ]. Thus the program (∗) becomes
 fn g:((unit - unit) - unit) ⇒ inp[return fn x ⇒ out0[h x],	(†)


 fn ƒ :(unit - unit) ⇒ ƒ ⟨⟩ to y. ƒ ⟨⟩
 return fn y ⇒ out1[return ⟨⟩]] to ƒ. g ƒ 


The intermediate language (§2) has a straightforward equational theory, includ- ing β- and η-equality. The program (†) is not in normal form for these equations,
e.g. it has a β-redex. Our normalization algorithm yields the following program:
inp[out0[h ⟨⟩ to x. out0[h ⟨⟩ to y. return ⟨⟩]], out1[out1[return ⟨⟩]]]	(‡)
So we discover what the program (∗) does: it inputs a bit from the network. If that bit is 0 then it outputs 0, calls h, outputs 0, and calls h again. If the bit from the network is 1 then it outputs 1 twice.
Notice how we are describing computational effects with an algebraic signature: inp is a binary operation, and out0, out1 are unary operations. A crucial observation is that the same normalization algorithm works if we begin with a different algebraic signature of computational effects. Many other effects have been described in an algebraic way, including non-determinism, probability, memory access [36,35,26] and logic programming [43]. Our framework is a general one for all these examples.

The essence of normalization by evaluation
We define our normalization algorithm in §3 using the paradigm of normalization by evaluation (nbe). The ideas of nbe were first discussed by Martin-L¨of [24] and later developed by Berger and Schwichtenberg [8].

There are two key ingredients: (1) a denotational se- mantics of the programming language in an executable
type theory (Agda 3 ) in which terms are automatically normalized; (2) a “reifica- tion” function which takes inhabitants of the denotational semantics back to terms of the intermediate language in a sub-grammar of normal forms.

Components of our denotational semantics
There are three important components to our denotational semantics for nbe:
Semantics in a functor category : We follow the general paradigm of structuring denotational semantics by finding a category and interpreting types as objects and programs as morphisms between objects. Following [14,3,9], we base our denotational semantics on the category SetRen of functors from a category Ren of contexts and renamings between them, to the category of sets. This category behaves very much like the category of sets, but has extra features that allow us to take care over interpreting terms with free identifiers. The key feature of SetRen is that there is a distinguished object Ren(τ, −) for each type τ of the intermediate language, and this object behaves like a special set of identifiers of type τ .
A residualizing monad : Our intermediate language is a variation on Moggi’s monadic metalanguage, and we structure our denotational semantics using a monad. Following Plotkin and Power [35], we build the monad from operations in the al- gebraic signature describing the computational effects. However, for nbe we must add more into our monad: following Filinski’s pioneering work [13] and subsequent developments [21,5], we also incorporate the effect of applying an identifier of func- tion type to an argument. For instance, in the normal form (‡) above, although the result of the call to h is ignored, the function call may produce side effects, depending on what h stands for. We thus keep the ‘residual’ function call, which cannot be normalized any further.
Using PERs to account for equations on effect terms: In addition to operations in algebraic signatures, many computational effects are described with additional equations specifying their computational behaviour. Following [9,33], we accommodate such effects in our nbe algorithm by considering presheaves whose codomains are equipped with partial equivalence relations (pers). This is a partic- ularly elegant approach because from the perspective of the nbe algorithm, we can naively work with sets, and then refer to the pers when justifying the correctness of the algorithm.

Contributions
Our main contribution is to build a normalization algorithm for our effectful func- tional language out of this semantic analysis. The three components of our denota- tional semantics (§1.2) have not been combined before. By combining (1) and (2) we

3 Agda implementation of our nbe: https://github.com/danelahman/Normalization-By-Evaluation

achieve a clean and modular mathematical account of Filinski’s ideas of residuation in monads. By combining (2) and (3) we are able to analyze equations and normal- ization at the level of effects (§5), separately from equations and normalization of the functional aspects of the language.
We also present a proof of correctness of the normalization algorithm. Our proof uses logical relations, and further exploits the tight connection between the residualizing monad and the syntax of normal forms.


Acknowledgments
We are especially grateful to James Chapman for suggestions on the Agda for- malization. We also thank Andrej Bauer, Sam Lindley, Andy Pitts and Phil Scott for useful discussions. We also thank Pierre Clairambault who pointed us to Okada and Scott’s undecidability result. The core of this work appeared in the first au- thor’s MPhil dissertation.
First author’s participation at the conference was supported by Estonian na- tional scholarship program Kristjan Jaak, which is funded and managed by Archimedes Foundation in collaboration with the Ministry of Education and Re- search.

A programming language with algebraic effects
We introduce the syntax and equational theory for a higher-order programming language which incorporates computational effects using algebraic theories, follow- ing [35]. Our language is based on the call-by-value paradigm. The evaluation order is totally explicit, so it is more of an intermediate language than a front-end. The language is based on Moggi’s monadic metalanguage [29], following the analysis by Levy, Power and Thielecke [20] (see also [17,19,28,40]).

Algebraic effects
We describe simple effects involved in computation using algebraic signatures [36]. For example, we can describe the effects involved in input/output of bits over a fixed communication channel with a binary operation inp and unary operations out0, out1. The algebraic expression inp[M, N ] describes a computation that first reads a bit from the channel and then proceeds as the computation M if it is 0, or as N if it is 1. The expression out0[M ] describes a computation that outputs a bit 0 to the channel and then proceeds as M .
For another example, we can describe the effects of non-determinism with a binary operation ⊕, with the understanding that M ⊕ N describes a computation that behaves either as M or as N .
Formally, an algebraic signature consists of a set Op of operations together with an assignment of arities ar : Op → N. For input/output, let Op = {inp, out0, out1}


def
def
def
def

and ar(inp) = 2, ar(out0) = 1, ar(out1) = 1. For non-determinism, let Op = {⊕}
and ar(⊕) = 2.
One would typically impose equations, such as idempotency, commutativity and associativity of ⊕. We postpone a discussion on this until §5. In §6 we discuss more general kinds of algebraic theories involving value parameters and variable binding.

Extending algebraic effects to a call-by-value language with higher types
The algebraic analysis of effects involves a class of computations of unspecified type. We now describe a typed language, for time being with product and function types:
σ, τ ∈ Ty ::= unit | σ ∗ τ | σ - τ .
We use a harpoon symbol for the function type σ - τ to emphasise that a function may have side effects. (Moggi’s [29] notation for this is σ → T (τ ). Conversely in our language the thunking construction (unit - (−)) is a monad.)
We have not included other types, such as sums or recursive types, because our main aim in this paper is to present a clear underlying framework for nbe for effectful languages with algebraic effects. We return to this in §6.
A typing context is a list of types annotated with variable names x, y, z. We have no need to consider untyped terms, so we immediately provide a rule-based definition of typed terms in context. Following [20], there are two typing judgements: one for values Γ ▶v V : τ and one for producers Γ ▶p M : τ . The idea is that a value is something that has no effects, whereas a producer may have side effects.




Γ,x : τ, Γj ▶v x : τ
Γ ▶v V1 : τ1	Γ ▶v V2 : τ2


Γ ▶v ⟨V1, V2⟩ : τ1 ∗ τ2
Γ,x : σ ▶p N : τ

Γ ▶v fn x:σ ⇒ N : σ - τ





Γ ▶v ⟨⟩ : unit
Γ ▶v V : τ1 ∗ τ2


Γ ▶v #i V : τi
Γ ▶v V : σ - τ	Γ ▶v W : σ

Γ ▶p V W : τ



Γ ▶v V : τ


Γ ▶p return V : τ
Γ ▶p M : σ	Γ,x : σ ▶p N : τ


Γ ▶p M to x. N : τ
Γ ▶p M1 : τ . . . Γ ▶p Mn : τ

Γ ▶p opτ [M1,..., Mn]: τ

There is an instance of the bottom-right rule for each n-ary operation op ∈ Op
and each type τ . For instance, with the input/output signature we have this syntax:


Γ ▶p M : τ	Γ ▶p M : τ


Γ ▶p inp[M, N ]: τ
Γ ▶p M : τ


Γ ▶p out0[M ]: τ
Γ ▶p M : τ

Γ ▶p out1[M ]: τ


Equational theory
The equational theory of this language is built from the βη-equations of the λ-cal- culus, the laws of Kleisli composition (e.g. [20,29]), and algebraicity [40, §3.3]. We

have elided the usual laws of reflexivity, symmetry, transitivity, and congruence.


Γ ▶v V1 : τ1	Γ ▶v V2 : τ2


Γ ▶v #i ⟨V1, V2⟩≡ Vi : τi
Γ ▶v V : τ1 ∗ τ2


Γ ▶v V ≡ ⟨#1 V, #2 V ⟩ : τ1 ∗ τ2
Γ ▶v V : unit

Γ ▶v V ≡ ⟨⟩ : unit



Γ,x : σ ▶p M : τ	Γ ▶v V : σ

Γ ▶p (fn x:σ ⇒ M ) V ≡ M [V/x]: τ
Γ ▶v V : σ - τ

Γ ▶v V ≡ fn x:σ ⇒ (V x): σ - τ



Γ ▶v V : σ	Γ,x : σ ▶p N : τ

Γ ▶p return V to x. N ≡ N [V/x]: τ
Γ ▶p M : τ

Γ ▶p M ≡ M to x. return x : τ

Γ ▶p M : σ	Γ,x : σ ▶p N : τ	Γ,y : τ ▶p P : ρ

Γ ▶p (M to x. N ) to y. P ≡ M to x. (N to y. P ): ρ Γ ▶p M1 : σ. . . Γ ▶p Mn : σ	Γ,x : σ ▶p N : τ
Γ ▶p opσ [M1,..., Mn] to x. N ≡ opτ [M1 to x. N,..., Mn to x. N ]: τ



Denotational semantics
We now recall the general programme of denotational semantics for the language in §2.2–2.3 in a category with sufficient structure [29,20,35]. Given an algebraic signature Op, a monad model is given by a category C with following data:
a chosen cartesian closed structure, i.e. chosen finite products (including a termi- nal object 1), and for all objects A and B an object [A ⇒ B] together with an evaluation morphism ε : [A ⇒ B] × A → B such that for every ƒ : C × A → B there is a unique morphism λƒ : C → [A ⇒ B] such that ƒ = ε ◦ (λƒ × idA).
a strong monad T on C, i.e. for each object A an object T A, and a morphism η : A → T A, and for all objects A and B a morphism str : A × TB → T (A × B), and for each morphism ƒ : A → TB a morphism ƒ∗ : TA → TB (also called the Kleisli extension of ƒ ), satisfying appropriate conditions (e.g. [29]).
for each operation op ∈ Op with ar(op) = n, a natural transformation T-op :
T (−)n → T (−) between functors C → C.
We interpret the intermediate language in a monad model by interpreting types as objects and terms as morphisms. The interpretation of types as objects proceeds

as follows: Junit)
= 1,	Jτ1 ∗ τ2)
= Jτ1) × Jτ2),	Jσ - τ )
= [Jσ) ⇒ T Jτ )].

We interpret a context (x1 : τ1,..., xn : τn) as an object too, as the product of the
interpretations of its consituent types: J(x1 : τ1,..., xn : τn)) = Jτ1) × ··· × Jτn). That is, a context is interpreted as the object of environments for that context.
Value typing judgments Γ ▶v V : τ are interpreted as morphisms JV )v : JΓ) → Jτ ), and producer typing judgments Γ ▶p M : τ as morphisms JM )p : JΓ) −→ T Jτ ).

These morphisms are defined by induction on the structure of derivations:


Jx)v
def
x
Jfn x:σ ⇒ N )v
= λJN )p

J#1 V )v
J#2 V )v
= π1 ◦ JV )v
= π2 ◦ JV )v
JV W )p = ε ◦ ⟨JV )v, JW )v⟩
Jreturn V )p = η ◦ JV )v

J⟨V, W⟩) = ⟨JV ) , JW ) ⟩
def
JM to x. N )  = JN )∗ ◦ str ◦ ⟨id, JM ) ⟩

v	v	v
def
p	p	p
def

J⟨⟩)v = ⟨⟩
Jopτ [M1,..., Mn])p = T-op ◦ ⟨JM1)p,..., JMn)p⟩

Proposition 2.1 (Soundness) In any monad model:
If Γ ▶v V ≡ W : τ then JV )v = JW )v. If Γ ▶p M ≡ N : τ then JM )p = JN )p.
For a simple example of a monad model, let C be the category Set of sets and functions between them. We can associate to any set A the least set T (A) containing A and closed under the operations in Op. This yields a strong monad. The Eilenberg-Moore algebras for this monad can be understood as sets A that are equipped with a function An → A for each n-ary operation op ∈ Op. Unfortunately this set-theoretic model is not good enough for nbe, informally, because it does not support reification at higher types. We build a model suitable for nbe in §3.2.
Normalization by evaluation
The general programme of nbe proceeds in three steps, following Section 1.1: iden- tifying normal forms (§3.1), building a model that supports a denotational semantics (§3.2), and defining a reification from the model to the normal forms (§3.3).
Normal forms
The normal forms for our language are based on the η-long β-normal forms of simply typed lambda calculus. We mutually define judgements of normal values (▶n ), normal
producers (▶n ), atomic values (▶a ) and atomic producers (▶a ).

p	v

Γ ▶n	1	1	n	2	2
p

Γ,x : σ ▶n N : τ

Γ,x : τ, Γj ▶a x : τ
Γ ▶n ⟨V1, V2⟩ : τ1 ∗ τ2


Γ ▶n fn x:σ ⇒ N : σ - τ


Γ ▶a	a	n



Γ ▶n ⟨⟩ : unit
v V : τ1 ∗ τ2


Γ ▶a #i V : τi
Γ ▶v V : σ - τ	Γ ▶v W : σ

Γ ▶a V W : τ


n	a	n
Γ ▶n	n

Γ ▶v V : τ
n
Γ ▶p M : σ	Γ,x : σ ▶p N : τ


n
p M1 : τ . . . Γ ▶p Mn : τ

Γ ▶n

Γ ▶p return V : τ
Γ ▶p M to x. N : τ
p opτ [M1,..., Mn]: τ

The atomic judgements are an auxiliary notion that we use to define normal judgements. Informally, atomic judgements are built from destructors (projections, function application) and normal judgements are built from constructors (pairing, abstraction). The only thing that can be done with an atomic producer is to force

its execution and substitute the result, using to. Atomic values can be substituted for variables without denormalizing a term.
A model of set theory with identiﬁers
Our nbe algorithm works over programs with free variables, that is, open programs. To accommodate this, we build a model of set theory in which there is a ‘set of identifiers’ for each type. We build the model categorically, using the presheaf construction, following [3,9,14]. (Nominal sets [32] are also related from a semantic perspective.)
A category of contexts and renamings
Let Ren be the category whose objects are contexts of our language: lists of types, informally annotated with variables. A morphism (σ1,..., σm) −→ (τ1,..., τn) is given by a function ƒ : m → n such that σi = τf (i) for 1 ≤ i ≤ m. Composition of morphisms is composition of functions.

A category of presheaves
We will consider the category SetRen of (covariant) presheaves. The objects are functors Ren → Set, and the morphisms are natural transformations. We under- stand a functor F : Ren → Set as assigning to each context a set which may depend on the free variables in that context. The functorial action on morphisms accounts for renamings of variables.
A helpful perspective is to think of this category as a model of intuitionistic set theory (e.g. [23]). For any type τ there is a representable presheaf Ren(τ, −) which may be thought of as a ‘set of identifiers’ labelled with the type τ . These identifiers are pure: they cannot be manipulated or compared.
The category SetRen has products, sums and function spaces (e.g. [23, §III.6]).
products: for presheaves F1,..., Fn we let (F1 ×·· ·×Fn)(Γ) = F1(Γ)×·· ·×Fn(Γ).
coproducts: let (F1 + ··· + Fn)(Γ) = F1(Γ)	 Fn(Γ).
cartesian closure: for F, G ∈ SetRen, let [F ⇒ G](Γ) = SetRen(Ren(Γ, −) × F, G).
Syntactic presheaves
For any type τ we have six presheaves Ren → Set built from the syntactic con- structions in §2.2 and §3.1: presheaves of values (VTermsτ ), producers (PTermsτ ), normal values (NVTermsτ ), atomic values (AVTermsτ ), normal producers (NPTermsτ )
def
and atomic producers (APTermsτ ). For example, VTermsτ (Γ) = {V | Γ ▶v V : τ}.
Presheaf actions are given by variable renaming: we let VTermsτ (ƒ )(V )= V [ƒ ].
A residualizing monad
The crux of our semantic analysis is our residualizing monad T on the presheaf category SetRen. We begin with an abstract description of it, and follow with a concrete inductive definition.

We briefly define a residualizing algebra to be a presheaf F : Ren → Set together with a natural transformation Fn → F for each n-ary operation in the signature Op, and also a natural transformation APTermsτ × ([Ren(τ, −) ⇒ F ]) → F for each type τ . The algebraic structure from the signature interprets the effects in the signature, and the additional structure describes sequencing of effects with atomic producers. Recall that atomic producers are function calls involving free identifiers; their effects are undetermined. With suitably defined algebra homomorphisms, we arrive at a category which is monadic over SetRen. That is, the category of residu- alizing algebras is the category of Eilenberg-Moore algebras for a strong monad T on the category SetRen. (This follows from the ‘crude monadicity theorem’.)
The monad T has the following concrete inductive description. Let F : Ren → Set be a presheaf. We define a new presheaf TF : Ren → Set so that the sets TF (Γ) are the least satisfying the following rules:


d ∈ F (Γ)

(T-return d) ∈ TF (Γ)
Γ ▶a M : σ d ∈ TF (Γ, x:σ) (M T-to x. d) ∈ TF (Γ)
d1 ∈ TF (Γ) ... dn ∈ TF (Γ)

T-op(d1,..., dn) ∈ TF (Γ)

The functorial action uses the action of F and the renaming of atomic produc- ers. Note the tight correspondence between the residualizing monad and normal producers (§3.1): there is a natural isomorphism NPTermsτ ∼= T (NVTermsτ ) (see also [21]). Another way to understand this monad is as the coproduct of the free monad generated by the algebraic signature Op and the free monad generated by T-to and T-return, as described by Ghani, Uustalu, Ad´amek and others [1,15].

Proposition 3.1 The category SetRen together with the residualizing monad T forms a monad model in the sense of §2.4.


Reiﬁcation and reflection
Recall that a nbe algorithm has two components: denotational semantics into the model, and reification back to normal forms.
We define reification as two families of natural transformations: v↓τ∈Ty: Jτ ) → NVTermsτ and p↓τ∈Ty: T Jτ ) → NPTermsτ . To account for the con- travariance at function types, the reification functions must be defined mutually with reflection functions, v↑τ∈Ty: AVTermsτ → Jτ ) and p↑τ∈Ty: APTermsτ → T Jτ ).
v↓τ : Jτ ) → NVTermsτ is defined by induction on the structure of types τ :

v↓unit d d=ef ⟨⟩

v↓τ1∗τ2 d d=ef
⟨v↓τ1 (π
d), v↓τ2 (π
d)⟩

Γ	Γ	1	Γ	2

v↓σ~τ d d=ef
fn x:σ ⇒ (p↓τ
(ε ⟨d, (v↑σ
x)⟩))

p↓τ : T Jτ ) → NPTermsτ is defined by induction on the structure of T Jτ ):


p↓τ (T-return d) d=ef
p↓τ (M T-to x. d) d=ef
return (v↓τ d) M to x. (p↓τ	d)

p↓τ (T-op(d ,...,d )) d=ef op [p↓τ d ,..., p↓τ d ]

Γ	1	n
τ	Γ  1	Γ  n

(Notice, (p↓τ ) is derived from the natural isomorphism NPTermsτ ∼= T (NVTermsτ ).)
v↑τ : AVTermsτ → Jτ ) is defined by induction on types τ :

v↑unit V d=ef ⟨⟩

v↑τ1∗τ2 V d=ef
⟨v↑τ1 (π
V ), v↑τ2 (π
V )⟩

Γ
v↑σ~τ V  d=ef
Γ	1
λd. p↑τ
Γ
(V (v↓σ
2
d))

Γ	Γ,x:σ	Γ,x:σ

p↑τ∈Ty: APTermsτ
→ T Jτ ) is defined by p↑τ M d=ef
M T-to x. (T-return (v↑τ
x)).

Since variables are atomic values, the reflection morphisms allow us to map from the object of identifiers Ren(τ, −) into the semantic domain Jτ ), via the composite
v↑τ
Ren(τ, −) −→ AVTermsτ −−→ Jτ ).

Summary of the normalization algorithm
We now combine the denotational semantics with reification to build a normalization algorithm.
Any context Γ = (x1 : τ1 ... xn : τn) has an environment id-envΓ (in the set JΓ)Γ)

in which variables are interpreted as identifiers: let id-env
d=ef ⟨v↑τ1 x ,..., v↑τn x ⟩.

Γ	Γ	1	Γ	n
The normal form of a value judgement Γ ▶v V : τ is found by reifying the in-
terpretation JV )v : JΓ) → Jτ ) in the environment id-envΓ. Similarly the normal form of a producer judgement Γ ▶p M : τ is found by reifying the interpretation JM )p : JΓ) → T Jτ ) in the environment id-envΓ:

nf(V ) d=ef v↓τ (JV )	(id-env ))	nf(M ) d=ef p↓τ (JM )	(id-env ))
Γ	vΓ	Γ	Γ	pΓ	Γ
We establish correctness of this normalization algorithm in Theorem 4.1.
Our normalization algorithm is based on a purely semantic analysis. Another common method for normalization is based on exhaustively rewriting syntactic pro- gram terms to compute their normal forms. To perform rewriting, one considers the equations Γ ▶v V ≡ W : τ and Γ ▶p M ≡ N : τ as rewrite rules. Lindley and Stark [22] have studied normalization for Moggi’s monadic metalanguage in this setting. They developed a TT-lifting based proof method by building on the strong normalization results for simply-typed lambda calculus based on reducibility candidates (see also [11]).

A note on implementation
The algorithm in this section reduces normalization for the programming language to evaluation in set theory. For this to be an effective procedure, we need to under- stand the ‘category of sets’ in a constructive way. We do this using Agda [30], an implementation of Martin-L¨of’s type theory [25]. The structure of our implemen- tation and its correctness proofs closely follow the presentation in this paper.
Correctness of the algorithm
We now show that the normalization algorithm we defined in §3 is correct. Our proof has been formalized in Agda. Similarly to [14], the proof of correctness is divided into three main theorems.
Theorem 4.1
Normalization respects equivalence.
If Γ ▶v V ≡ W : τ then nf(V )= nf(W ). If Γ ▶p M ≡ N : τ then nf(M )= nf(N ).
Normalization preserves normal forms.
If Γ ▶n V : τ then nf(V )= V . If Γ ▶n M : τ then nf(M )= M.
Terms are equivalent to their normal forms.
If Γ ▶v V : τ then Γ ▶v V ≡ nf(V ): τ. If Γ ▶p M : τ then Γ ▶p M ≡ nf(M ): τ.
Item (i) follows immediately from soundness of semantics (Prop. 2.1 and 3.1). Item (ii) is proved by induction on the derivations of normal values/producers. In the remainder of this section we outline a proof of item (iii) using logical relations.

Relating values and producers with their denotations
We begin by defining Kripke logical relations between values/producers and their de-
notations:	τ ⊆ Jτ )(Γ) × VTermsτ (Γ)	and	 τ ⊆ (T Jτ ))(Γ) × PTermsτ (Γ).
We define them by induction:  τ on the structure of τ ,  τ on the structure of T .
v	p


unit
v Γ
def
true

τ1∗τ2
v Γ
def
(π1
τ1	V ) ∧ (π2	τ2

σ~τ
v Γ
def
∀ƒ ∈ Ren(Γ, Γj).∀dj,V j.

j	σ V j =⇒ ε (Jσ - τ )f d, dj)  τ ′ (V [ƒ ]) V j

(T-return d)  τ M
def
∃V. Γ ▶ M ≡ return V : τ ∧ d  τ V

p Γ	p	v Γ

(N T-to x. d)  τ M
def
∃P. Γ ▶ M ≡ N to x. P : τ ∧ d  τ	P


(T-op(d1
... dn
p Γ
 τ	def
p Γ
∃M1
p

... Mn

∈ PTermsτ

(Γ).
p Γ,x : σ

Γ ▶p M ≡ opτ [M1,..., Mn]: τ ∧ d1  τ M1 ∧ ... ∧ dn  τ Mn

Proposition 4.2 The logical relations are invariant under equivalence: If d  τ V

and Γ ▶v V ≡ W : τ then d  τ
W. If d  τ
M and Γ ▶p M ≡ N : τ then d  τ N.

Proposition 4.3 The logical relations are subobjects in SetRen. For ƒ ∈ Ren(Γ, Γj):
If d  τ V then Jτ )f (d)  τ ′ V [ƒ ]. If d  τ M then (T Jτ ))f (d)  τ ′ M [ƒ ].
v Γ	v Γ	p Γ	p Γ
Proposition 4.4 The logical relations interact well with reification and reflection.

If d  τ V then Γ ▶v (v↓τ d) ≡ V : τ. If d  τ
M then Γ ▶p (p↓τ d) ≡ M : τ.

v Γ	Γ
p Γ	Γ

If Γ ▶a V : τ then (v↑τ V )  τ V . If Γ ▶a M : τ then (p↑τ M )  τ M.
v	Γ	v Γ	p	Γ	p Γ
We extend logical relations to environments and simultaneous substitutions. For any context Γ = (x1 : τ1,..., xn : τn), we let SubΓ = VTermsτ1 ×· · · × VTermsτn . An element of SubΓ determines the substitution of a term for each variable in Γ. Given a judgement Γ ▶v V : τ , let V [−] : SubΓ → VTermsτ be defined by substitution. Similarly, given a producer Γ ▶p M : τ , we define M [−]: SubΓ → PTermsτ by substi-

tution. We now define Γ ⊆ JΓ) × Sub as e Γ ρ ⇐⇒ ∀(x : τ ) ∈ Γ. (e x) τ
(ρ x).

v	Γ	v Γ′	v Γ′
Proposition 4.5 (Fundamental lemma of logical relations) If Γ ▶v V : τ and
e  Γ′ ρ then (JV )v e)  τ ′ V [ρ].	If Γ ▶p M : τ and e  Γ′ ρ then (JM )p e)  τ ′

v Γ	v Γ
M [ρ].
v Γ	p Γ


Proof of Theorem 4.1(iii)
We use the logical relations to show that terms are equivalent to their normal forms. Suppose Γ ▶v V : τ . We will show that Γ ▶v V ≡ nf(V ): τ . (Recall that nf(V ) =
v τ (JV )vΓ(id-envΓ)).) Using Prop. 4.4(ii), we deduce that identity environments
and substitutions are related by  Γ′ . By Prop. 4.5, (JV )v id-envΓ)  τ V . From
v Γ	v Γ
Prop. 4.4(i) we conclude Γ ▶v V ≡ nf(V ): τ , as required. The case for producers is
similar.

Equations and effects
The normalization process described in the previous sections is with respect to the equations in §2.3. We now discuss how to accommodate equations between effect terms.

Equations on effects
For a first example, the signature for non-determinism (⊕) is usually considered together with the semilattice equations x ⊕ x = x , x ⊕ y = y ⊕ x , x ⊕ (y ⊕ z)= (x ⊕ y) ⊕ z. To capture this in our language, we extend the equality for producers (Γ ▶p M ≡ N : τ , §2.3) by including these three equations at each type τ :


Γ ▶p M : τ


Γ ▶p M⊕M ≡ M : τ
Γ ▶p M : τ	Γ ▶p N : τ


Γ ▶p M⊕N ≡ N⊕M : τ
Γ ▶p M : τ	Γ ▶p N : τ	Γ ▶p P : τ

Γ ▶p M⊕(N⊕P ) ≡ (M⊕N )⊕P : τ

We also define equivalence relations on normal forms using the following three rules together with reflexivity, symmetry, transitivity and congruence.

n	n	Γ ▶n	n	n

Γ ▶p M : τ
n
Γ ▶p M : τ	Γ ▶p N : τ
n
p M : τ	Γ ▶p N : τ	Γ ▶p P : τ

Γ ▶n

Γ ▶p M⊕M ≡ M : τ
Γ ▶p M⊕N ≡ N⊕M : τ
p M⊕(N⊕P ) ≡ (M⊕N )⊕P : τ

Our nbe algorithm (§3) respects these equations:
Theorem 5.1
If Γ ▶v V ≡ W : τ then Γ ▶n nf(V ) ≡ nf(W ): τ. If Γ ▶p V ≡ W : τ then Γ ▶n nf(M ) ≡ nf(N ): τ.
If Γ ▶n V : τ then nf(V )= V . If Γ ▶n M : τ then nf(M )= M.
If Γ ▶v V : τ then Γ ▶v V ≡ nf(V ): τ. If Γ ▶p M : τ then Γ ▶p M ≡ nf(M ): τ.
Although we do not have to change the nbe algorithm to respect the equiva- lence relations, we have to refine the residualizing model to establish correctness (Theorem 5.1). From a semantic perspective, we change the notion of residual- izing algebra (§3.2), requiring that a residualizing algebra satisfies the semilattice equations. This gives us a different residualizing monad, which is a quotient of the monad in §3.2, so that we have an isomorphism (NPTermsτ /≡) ∼= T (NVTermsτ ).
From the perspective of implementation, however, the types of Agda are in- tensional and they do not permit quotients by equivalence relations. To remedy this we revisit the semantic framework. We understand a ‘set’ as an Agda type equipped with a partial equivalence relation ≈ (per: symmetric, transitive rela- tion), following Cubric, Dybjer, Scott [9] and Pitts [33, §C.1]. For example, the type of functions [X ⇒ Y ] is equipped with the following per: ƒ ≈X→Y g iff
∀x, xj : X. x ≈X xj =⇒ ƒ (x) ≈Y g(xj). We are led to redo category theory in this setting, so that a ‘hom-set’ is actually a type equipped with a per. For more details, see [9] or our Agda implementation.
There is nothing specific about semilattices in our analysis. In general, we accommodate equations on effects using the per on the residualizing monad. Also importantly, the pers are not visible in the constructions of the normalization algorithm. They only play a role in the formalization of the correctness argument (Theorem 5.1).
We mention in passing an alternative way to arrive at a suitable model to ac- commodate equations on effect terms: the setoid construction [7]. A setoid is a type equipped with an equivalence relation (that is also reflexive: ∀x. x≈x). The setoid model has a different cartesian closed structure: the setoid of functions be- tween given setoids X and Y is {ƒ : X → Y | x ≈X xj =⇒ ƒ (x) ≈Y ƒ (xj)}. (This is roughly the same as the domain of the per.) In a proof-relevant system like Agda, a setoid-based implementation of the normalization algorithm would be lit- tered with proof witnesses for all inhabitants of function types. Although the setoid model is well behaved in many ways, the per construction is better for our purposes because it yields an algorithm that is not complicated by proof obligations.

Normalization of effects
In the previous section we only identified normal forms up-to the equations on effect terms. In specific situations we can do better. For example, consider the sig-
def	def
nature for a one-bit memory cell: Op = {lookup, update0, update1}, ar(lookup) = 2,
def	def
ar(update0) = 1, ar(update1) = 1, with the following equations [26,35]:


x = lookup[update0[x], update1[x]]		updatei[updatej [x]] = updatej [x] update0[lookup[x, y]] = update0[x]	update1[lookup[x, y]] = update1[y]
(1)

The idea is that lookup[M, N ] is the program that reads the memory, continuing as M or N depending on the result, and updatei[M ] writes i to the memory before continuing as M .
Rather than equipping the normal producers with a per generated by these equations, we can instead represent effect terms directly in normal form, following Melli`es [26]. We use an auxiliary judgement (▶n'


n'	n'
n'	n'
n'	n'

Γ ▶p M : τ	Γ ▶p N : τ

Γ ▶n
Γ ▶p M : τ	Γ ▶p N : τ
n
Γ ▶p M : τ	Γ ▶p N : τ


n

p lookup[M, N ]: τ
Γ ▶p lookup[update1[M ],N ]: τ
Γ ▶p lookup[M, update0[N ]] : τ


n'	n'

n	a	n

Γ ▶n
Γ ▶p M : τ	Γ ▶p N : τ
Γ ▶v V : τ
n'
Γ ▶p M : σ Γ, x:σ ▶p N : τ

n'

p lookup[update1[M ], update0[N ]] : τ
Γ ▶p return V : τ
Γ ▶p M to x. N : τ

Recall that the residualizing monad is a coproduct of two monads. In the present case we can understand it as a coproduct of the residualizing monad for no ef- fects (§3.2), and the one-bit-state monad [{0, 1}⇒ ({0, 1}× (−))]. Concretely, this coproduct of monads is the following least fixed point (following the definition in [16]):
TF = μG. {0, 1}⇒ {0, 1}× F + Στ (APTermsτ × [Ren(τ, −) ⇒ G]) 

In this monad the quotient by the equations (1) is made in the type, and a per is not needed. Categorically speaking, this monad is isomorphic to the monad with a nontrivial per. Concretely, however, this tailored monad provides a nbe algorithm that not only normalizes higher types, but also partially evaluates the imperative commands as much as possible. For illustration, consider the program (†) in the introduction, but with inp/out replaced by lookup/update. Rather than the normal form (‡), our algorithm also normalizes the effects, minimizing the number of writes:

lookup[h ⟨⟩ to x. lookup[h ⟨⟩ to y. lookup[return ⟨⟩, return ⟨⟩],
update0[h ⟨⟩ to y. lookup[return ⟨⟩, return ⟨⟩]]],
return ⟨⟩].

Remarks on extensions to the language
In this paper we have considered a restricted language with just enough features to demonstrate our contributions. While language features such as recursion and sum types are very important, they can be dealt with by using standard techniques from the literature. We briefly summarize the main ideas.

Recursion
Our nbe algorithm is guaranteed to terminate, because it is written in Agda. Nonetheless, realistic programming languages have the potential for non-termination. This leads us to the long-established connections between partial evaluation and nbe [10,12]. Roughly speaking, in a language with recursion, each sub-expression should be annotated with its ‘binding time’, to explain which parts of the program should be normalized at compile time (since they are somehow assumed to terminate) and which should not be touched until run time. Dybjer and Filinski [12,13] outline how to accommodate this in a monadic metalanguage.

Sum types
Most practical programming languages have sum types. For instance, we might have a type bit of bits with two constants (0, 1) and following typing rule with equations:


Γ ▶v V : bit	Γ ▶p M : τ	Γ ▶p N : τ

Γ ▶p if V then M else N : τ
if i then M0 else M1 ≡ Mi	(i = 0, 1)
M ≡ if x then M [0/x] else M [1/x]
(2)

The semantic analysis based on presheaf categories has been extended to explain nbe with sum types for pure languages without computational effects [2,6]. Filin- ski [13] and Lindley [21] have discussed nbe for effectful languages with sums from a more pragmatic perspective. The languages they consider type case expressions as computations rather than as values, which allows them to use the residualizing monad to treat pattern-matching on atomic values.

Base types and local effects
Our residualizing monad is a monad on a presheaf category. Various authors use monads on presheaf categories to describe local effects and name generation, including local store [27,35,37], π-calculus [42], and logic programming [43]. The second author has recently developed a syntactic framework for these analyses, based on a generalized kind of algebraic theory [28,44], which can be accommodated in our semantic analysis (see also [27,37]). This framework allows us to move closer to the original source program in our introduction, as follows.
We can add to our grammar for types two abstract base types: a type chan of channels and a type bit of communication data. We can then modify our algebraic signature for input/output effects so that the operations take parameters from chan,

specifying which channel to use for communication, and the input operation incor- porates variable binding. This kind of signature is ‘algebraic’ in that it determines a monad ona presheaf category [43]. For input/output, we have this concrete syntax.


Γ ▶v V : chan	Γ,x : bit ▶p M : τ


Γ ▶p inp[V, x. M ]: τ
Γ ▶v V : chan	Γ ▶v W : bit	Γ ▶p M : τ

Γ ▶p out[V, W, M ]: τ

To allow manipulation of the data we add constants 0, 1 of type bit and also an operation if then else to our algebraic signature. In this way the typing rule in (2) arises from the algebraic signature of effects, not as an extra language construction. The equations for if then else (2) can be understood as part of the algebraic theory of the effects [44, §VC]. This suggests a new route to dealing with sum types in nbe, purely by using algebraic effects. We are currently experimenting with different implementations of the residualizing monad for this theory. We hope to recover a standard nbe algorithm for booleans [4] by implementing the monad carefully.
Categorically, this line of work amounts to investigating the free closed Freyd category on a Freyd category, in the terminology of [20,39]. Recall [20,39] that a Freyd category comprises (C, K,J ), where C is a category with finite products, K is a symmetric premonoidal category [38], and J is an identity-on-objects functor C → K that strictly preserves symmetric premonoidal structure and whose image lies in the centre of K. A Freyd category is closed if for all objects A the functor J (A × −): C → K has a right adjoint. In particular, to give a closed Freyd category is to give a category with finite products and a strong monad T on it for which Kleisli exponentials [A ⇒ TB] exist (cf. [39]).
In this sense our investigations are analogous to the investigations by Cubric et al. [9, §7] into decidability for the free cartesian closed category on a category with finite products. However, whereas the βη-theory for free cartesian closed categories is not necessarily decidable, our equational theory is more fine-grained, leading us to make the following conjecture:
Let (C → K) be a Freyd category where C is a free category with products on a set of objects and the word problem for K is decidable. Then the word problem for the free closed Freyd category on (C → K) is decidable.

Handlers of algebraic effects
While algebraic effects give a general way for constructing impure computations, recent developments suggest that it is also profitable to desconstruct computational effects. These ‘effect handlers’ generalize the idea of exception handlers to all alge- braic effects. (See e.g. [34,40,18].)
To keep things simple, we consider the signature with one unary effect, op. We can add effect handlers for op to our language with the following term formation rule.
Γ ▶p M : σ	Γ,x : τ ▶v Hop : τ	Γ,x : σ ▶v Hreturn : τ
Γ ▶v handle M with {op(x) ⇒ Hop | return (x) ⇒ Hreturn} : τ
For an intuition, let op(M ) be a computation that first ‘beeps’ and then continues

as M . The expression handle M with {op(x) ⇒ Hop | return (x) ⇒ Hreturn} then captures each of the beeps in M and replaces them with Hop. For instance, the expression
(handle M with {op(x) ⇒ λ⟨⟩. op(op(x⟨⟩)) | return (x) ⇒ λ⟨⟩. x}) ⟨⟩
replaces each ‘beep’ in M with two beeps.
Mathematically, handler expressions reify the idea that the type (⟨⟩ - τ ) is the free algebra on τ generated by the unary operation op. This intuition suggests the following equations: firstly, that the handlers are homomorphisms between unary algebras:
Γ ▶v handle (return V ) with {op(x) ⇒ Hop | return (x) ⇒ Hreturn}
≡ Hreturn[V/x]: τ
Γ ▶v handle (op(M )) with {op(x) ⇒ Hop | return (x) ⇒ Hreturn}
≡ Hop[(handle M with H)/x]: τ
and secondly, that the handlers provide unique mediating morphisms: Γ,x : unit - σ ▶v V [(λ⟨⟩. op[x⟨⟩])/x] ≡ Hop[(λ⟨⟩.V )/y]: τ
Γ,x : unit - σ ▶v
V ≡ handle (x ⟨⟩) with {op(y) ⇒ Hop | return (z) ⇒ V [(λ⟨⟩. return z)/x]} : τ
However, we conjecture that this equational theory is undecidable. This con- jecture is based on the observation that computations of type unit are essentially natural numbers (thinking of return ⟨⟩ as zero and op(M ) as the successor of M ). Thus our system is close to G¨odel’s System T, in which equality is undecidable (assuming ‘uniqueness of recursors’: see [31]).

Summary
We have investigated normalization by evaluation for a language with higher types and computational effects. The effects are specified by an algebraic signature, so our algorithm works for any notion of computation that can be expressed this way. A key contribution of our work is our clear and modular semantic analysis of normalization by evaluation. At the heart of our analysis is the residualizing monad.
It is a monad on a presheaf category. Following Altenkirch, Cubric, Fiore and others [3,9,14], we use a presheaf category as an alternative to classical set theory because we need to normalize open terms. The presheaf category provides us with well-behaved ‘sets of free identifiers’, while supporting the standard approach to denotational semantics using cartesian closed categories.
The monad is built in a principled and modular way, using the operations and

equations in the algebraic theory that describes the computational effects, follow- ing the ideas of Plotkin, Power and others [35,26].
In addition to algebraic operations, the monad also incorporates additional alge- braic structure describing residualizing function calls, following Filinski [13].
Our normalization algorithm is implemented in the dependently typed language Agda, and also proved correct in Agda. To run our algorithm, we can naively think of sets as Agda types, but in the correctness proof we more properly understand sets as Agda types equipped with pers, following [9].

References
Ad´amek, J., S. Milius, N. Bowler and P. B. Levy, Coproducts of monads on set, in: Proc. LICS (2012),
pp. 45–54.
Altenkirch, T., P. Dybjer, M. Hofmann and P. Scott, Normalization by evaluation for typed lambda calculus with coproducts, in: LICS’01, Washington, DC, USA, 2001, pp. 303–310.
Altenkirch, T., M. Hofmann and T. Streicher, Categorical reconstruction of a reduction free normalization proof, in: CTCS’95, 1995, pp. 182–199.
Altenkirch, T. and T. Uustalu, Normalization by evaluation for λ→,2, in: Proc. FLOPS’04, 2004, pp. 260–275.
Atkey, R., A type checker that knows its monad from its elbow (2011), http://bentnib.org/posts/ 2011-12-14-type-checker.html.
Balat, V., R. Di Cosmo and M. Fiore, Extensional normalisation and type-directed partial evaluation for typed lambda calculus with sums, in: POPL’04 (2004), pp. 64–76.
Barthe, G., V. Capretta and O. Pons, Setoids in type theory, J. Funct. Program. 13 (2003), pp. 261–293.
Berger, U. and H. Schwichtenberg, An inverse of the evaluation functional for typed λ–calculus, in:
Proc. LICS’91, 1991, pp. 203–211.
Cubric, D., P. Dybjer and P. J. Scott, Normalization and the Yoneda embedding, Math. Struct. Comput. Sci. 8 (1998), pp. 153–192.
Danvy, O., Type-directed partial evaluation, in: Proc. Partial Evaluation, 1998, pp. 367–411.
Doczkal, C. and J. Schwinghammer, Formalizing a strong normalization proof for Moggi’s computational metalanguage: a case study in Isabelle/Hol-nominal, in: Proc. LFMTP’09 (2009), pp. 57–63.
Dybjer, P. and A. Filinski, Normalization and partial evaluation, in: Proc. APPSEM 2000 (2002), pp. 137–192.
Filinski, A., Normalization by evaluation for the computational lambda-calculus, in: Proc. TLCA’01, 2001, pp. 151–165.
Fiore, M., Semantic analysis of normalisation by evaluation for typed lambda calculus, in:
Proc. PPDP’02, 2002, pp. 26–37.
Ghani, N. and T. Uustalu, Coproducts of ideal monads, ITA 38 (2004), pp. 321–342.
Hyland, M., G. Plotkin and J. Power, Combining effects: sum and tensor, Theor. Comput. Sci. 357
(2006), pp. 70–99.
Johann, P., A. Simpson and J. Voigtl¨ander, A generic operational metatheory for algebraic effects, in:
Proc. LICS 2010, 2010, pp. 209–218.
Kammar, O., S. Lindley and N. Oury, Handlers in action, in: To appear in Proc. ICFP 2013, 2013.
Kammar, O. and G. D. Plotkin, Algebraic foundations for effect-dependent optimisations, in:
Proc. POPL 2012, 2013, pp. 349–360.

Levy, P. B., J. Power and H. Thielecke, Modelling environments in call-by-value programming languages, Information and Computation 185 (2003), pp. 182–210.
Lindley, S., Accumulating bindings, in: O. Danvy, editor, Informal proceedings of the 2009 Workshop on Normalization by Evaluation, 2009, pp. 49–56.
Lindley, S. and I. Stark, Reducibility and TT-lifting for computation types, in: Proc. TLCA’05 (2005),
pp. 262–277.
Mac Lane, S. and I. Moerdijk, “Sheaves in geometry and logic: A First Introduction to Topos Theory,” Springer-Verlag, 1992.
Martin-L¨of, P., About models for intuitionistic type theories and the notion of definitional equality, in:
S. Kanger, editor, 3rd Scandinavian Logic Symp., North-Holland, 1975 pp. 81–109.
Martin-L¨of, P., An intuitionistic theory of types, predicative part, in: H. E. Rose and J. C. Sheperdson, editors, Logic Colloquium 1973 (1975), pp. 73–118.
Melli`es, P.-A., Segal condition meets computational effects, in: Proc. LICS 2010, 2010, pp. 150–159.
Melli`es, P.-A., Local stores in string diagrams (2011), http://tinyurl.com/mellies-itu-2011.
Møgelberg, R. E. and S. Staton, Linearly-used state in models of call-by-value, in: Proc. CALCO’11, 2011, pp. 298–313.
Moggi, E., Notions of computation and monads, Information and Computation 93 (1991), pp. 55–92.
Norell, U., “Towards a Practical Programming Language Based on Dependent Type Theory,” Ph.D. thesis, Chalmers University of Technology (2007).
Okada, M. and P. Scott, A note on rewriting theory for uniqueness of iteration, Theory and Applications of Categories 6 (1999), pp. 47–64.
Pitts, A. M., Alpha-structural recursion and induction, J. ACM 53 (2006), pp. 459–506.
Pitts, A. M., Structural recursion with locally scoped names, J. Funct. Program. 21 (2011), pp. 235–286.
Plotkin, G. and M. Pretnar, Handlers of algebraic effects, in: Proc. ESOP 2009 (2009), pp. 80–94.
Plotkin, G. D. and J. Power, Notions of computation determine monads, in: Proc. FOSSACS’02 (2002),
pp. 342–356.
Plotkin, G. D. and J. Power, Algebraic operations and generic effects, Applied Categorical Structures
11 (2003), pp. 69–94.
Power, J., Indexed Lawvere theories for local state, in: Models, Logics and Higher-Dimensional Categories, AMS, 2011 pp. 268–282.
Power, J. and E. Robinson, Premonoidal categories and notions of computation, Math. Struct. in Comput. Sci. 7 (1997), pp. 453–468.
Power, J. and H. Thielecke, Closed Freyd- and κ-categories, in: Proc. ICALP’99, Lecture Notes in Comput. Sci. 1644, 1999, pp. 625–634.
Pretnar, M., “The logic and handling of algebraic effects,” Ph.D. thesis, University of Edinburgh (2010).
Reppy, J. H., Concurrent ML, in: Encyclopedia of Parallel Computing, Springer, 2011 pp. 371–377.
Stark, I., Free-algebra models for the pi-calculus, Theor. Comput. Sci. 390 (2008), pp. 248–270.
Staton, S., An algebraic presentation of predicate logic, in: Proc. FOSSACS 2013, 2013, pp. 401–417.
Staton, S., Instances of computational effects: An algebraic perspective, in: Proc. LICS 2013, 2013, pp. 519–519.
