Electronic Notes in Theoretical Computer Science 191 (2007) 25–48	
www.elsevier.com/locate/entcs

Automatic Model-Based Generation of Parameterized Test Cases Using Data Abstraction
Jens R. Calam´e1 Natalia Ioustinova2 Jaco van de Pol3
Dept. of Software Engineering Centrum voor Wiskunde en Informatica
Amsterdam, The Netherlands

Abstract
Developing test suites is a costly and error-prone process. Model-based test generation tools facilitate this process by automatically generating test cases from system models. The applicability of these tools, however, depends on the size of the target systems.
Here, we propose an approach to generate test cases by combining data abstraction, enumerative test generation and constraint-solving. Given the concrete specification of a possibly infinite system, data abstraction allows to derive an abstract system, which is finite and thus suitable for the automatic generation of abstract test cases with enumerative tools. To execute abstract test cases, we have to instantiate them with concrete data. For data selection we make use of constraint-solving techniques.
Keywords: Conformance testing, model-based testing, test case generation, data abstraction, constraint-solving.


Introduction
Software failures can have expensive or dangerous consequences, so assuring the quality of a software product is very important. Software testing as a dynamic ap- proach to validate a software product is widely accepted by academic and industrial communities. Depending on the view on an implementation under test (IUT ), one differentiates between whitebox and blackbox testing. While there is knowledge about internal details of the IUT available for whitebox testing, this knowledge is absent in a blackbox test.
A test process involves the design of a test suite, its implementation and its execution. Each of these phases can be tedious and time-consuming for complex

1 Email: jens.calame@cwi.nl
2 Email: natalia.ioustinova@cwi.nl
3 Email: vdpol@cwi.nl

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.06.019



Fig. 1. The test generation process

real-life systems. Therefore, there is ongoing research to automate each of these phases. In this paper, we provide an approach to automatic model-based test gen- eration for blackbox testing.
Test cases can be generated either from a test model, i.e. a model of the test suite, or from a model of an IUT . In the first case, test cases are designed sepa- rately from the model of the IUT , for instance using frameworks like the UML 2 Testing Profile [27]. This leads to well-tailored test cases, but might also double the modeling effort during development. In the second case, the existing models of the IUT are examined by a test case generator. Model-based test generation is well-developed for conformance testing, which aims at checking whether an IUT conforms with its specification [22,33].
Existing model-based test generators usually rely on the enumeration of the state space of a specification. For open systems consisting of multiple components, com- municating with each other and the system’s environment, enumerative approaches lead to a large (sometimes infinite) number of test cases. Here, we propose an approach combining data abstraction, enumerative test generation and constraint- solving to solve this problem (see Figure 1).
Given the specification of an open system, we apply data abstraction which has already successfully been applied to model-checking open systems (e.g. [30]) to obtain a (finite) abstract system. From the abstracted system, we generate a set of abstract test cases. The generation of these test cases is guided by a test purpose [22], which defines the scenario of interest. The produced abstract test cases contain abstract data that should be concretized prior to test execution.
To instantiate abstract test cases with concrete data, we employ constraint- solving. In parallel to test generation and abstraction we transform the original specification into a rule system, which is used further for data selection. The test suite is transformed into a test oracle in order to retrieve test data. We use the data to instantiate the test case and execute it. While being executed, the IUT might diverge from the selected path. By online constraint-solving, we dynamically adapt the course of the test execution.
This paper is organized as follows: In the following subsection, we discuss papers that are related to our test generation approach. In Section 2, we give an overview

of conformance testing. In Section 3, we describe the syntax and semantics of the specifications, we are working with. Preliminaries for constraint-solving are given in Section 4. In Section 5, we describe our approach for data abstraction, followed by the explanation of test generation in Section 6. We applied our approach to a case study, which is described in Section 7. Finally, we conclude with Section 8. Full proofs for the lemmata in this paper can be found in [4].

Related Work
The closest to our approach is symbolic test generation [8,14,23,29,36]. This method works directly on higher-level specifications given as Input-Output Symbolic Tran- sition Systems without enumerating their state space. Given a test purpose and a specification, their product is built. Those works are founded on the ioco the- ory [32]. The coreachability analysis is in these cases over-approximated by Abstract Interpretation [10]. The concept of test generation with verification techniques (TGV, [22]) is also based on ioco.
The purpose and usage of abstraction techniques in our approach is conceptually different from the one of symbolic test generation, since we use data abstraction to avoid infinity caused by external data. This enables us to use existing enumerative test generation techniques to derive abstract test cases which are instantiated with concrete data derived by constraint-solving. In the symbolic test generation ap- proach, approximate coreachability analysis is used to prune paths potentially not leading to Pass-verdicts. Both approaches are valid for any abstraction leading to an over-approximation of the IUT ’s behavior. They both employ constraint-solving to choose a single testing strategy during test execution. Which approach is actually more suitable for which class of systems can only be revealed by extensive use of the approaches.
Test data determination [17] for whitebox testing has been discussed in several recent papers [16,31,34]. They are mainly based on the technique of symbolic exe- cution [9,24]. The constraint rule systems that we generate to determine test data, are comparable to [28], where also constraint rules are generated encoding the vis- ible inputs and outputs, guards and internal state changes. These rules are used to generate a set of test cases by transforming a whole system specification into Prolog. However, test cases are already present in our case and the rule system is only needed to find concrete test data.
Testing Theory
Our approach is based on conformance testing that validates whether an implemen- tation conforms to its specification. In a theory of conformance testing [32], the notion of conformance is formalized by a conformance relation between specifica- tion and implementation that are assumed to be input output labeled transition systems (IOLTS s). In this paper, we refer to a variant of the theory, described in [22]. Quiescence is not discussed here.
An IOLTS is a tuple (Σ, Lab, →, σinit) with a non-empty set of states Σ, a

dedicated initial state σinit, an alphabet of action labels Lab and a transition relation
→⊆ Σ × Lab × Σ. The set of labels Lab consists of three subsets of actions, LabI, LabO, and {τ} denoting input, output and internal actions. Input and output actions are visible, internal actions are invisible. An IOLTS is deterministic iff there is at most one outgoing transition for each action λ ∈ Lab in each state σ ∈ Σ.
The behavior of an IOLTS M is given by sequences of states and transitions β = σinit → σ1 → ... starting from the initial state. Traces are derived by projecting out the states, i.e. [M ]]trace ⊆ Lab٨ is the set of traces of an IOLTS M . The relation after is defined as the set of states Σ', that can be reached if the system is in state σ and action λ is executed (Σ' = σ after λ). It is also defined for an action λ possibly enabled after executing trace β (Σ' = β after λ).
IOLTS s modeling IUT s are assumed to be input-complete, i.e. the implemen- tation cannot refuse any input from the environment. Given a model MIUT of an implementation and a model MSpec of a specification, the implementation conforms to the specification iff for each trace β in [MSpec]]trace, MIUT after this trace β pro- duces only outputs that can be produced by MSpec after β. In case, MSpec is input complete, conformance is the standard trace inclusion relation 4 .
We are interested in test generation where the test selection is guided by a test purpose [22]. A test purpose is a deterministic IOLTS MTP that is equipped with a non-empty set of accepting states Accept and a set of refusing states Refuse which can be empty. Both accepting and refusing states are trap states, i.e. they cannot be left by any action anymore. Moreover, MTP is complete in all the states except for the accepting and refusing ones. This means that in all states, all actions which are possible in MSpec are enabled.
Assumption 1 (Treatment of Data in Test Purposes) We assume that a test purpose MTP is focused on the control flow of the described scenario only, so that the information about an action carried in the labels of LabTP is limited to the action names. Data parameters should not be subject of value assignment and are thus replaced by the don’t-care parameter ∗.
Test generation guided by a test purpose consists in building a standard syn- chronous product MSP of MSpec with MTP and finally transforming it into a com- plete test graph MCTG by assigning verdicts as possible results of test case ex- ecution (see Definition 2.2). The state space of the synchronous product MSP forms the reachable part of ΣSpec × ΣTP . The set →SP is constructed by match- ing the transitions of MSpec and MTP . The set of accepting states is defined as Σacc = {(s, ACCEPT )|s ∈ ΣSpec}.
Definition 2.1 (Complete Test Graph [22]) A complete test graph CTG is an IOLTS MCTG = (ΣCTG , LabCTG, →CTG, σCTG ) which is determined from the syn- chronous product MSP in the following way:
The set of actions is determined by mirroring the set of actions of MCTG:

4 The difference with ioco [32] is that we do not abstract from τ-steps and that we do not yet consider quiescence.

LabCTG = LabCTG ∪ LabCTG with LabCTG ⊆ LabSpec and LabCTG = LabSpec.
I	O	O	I	I	O
The set of states is divided into four subsets ΣCTG = ΣCTG ∪˙ ΣCTG ∪˙ ΣCTG

and ΣCTG ⊆ ΣCTG which are deﬁned as follows:
L2A
Inconc
Fail

Pass	L2A
Lead to Accept: ΣCTG = {σ ∈ ΣSP |∃β ∈ [[MSP ]]trace(σ →SP σ' ∧σ' ∈ ΣSP )},
L2A	β	acc
Pass: The set ΣCTG ⊆ ΣCTG is deﬁned as ΣCTG = ΣSP . This set may not

be empty.
Pass
L2A
Pass
acc

Inconclusive: ΣCTG	= {σ'|∃σ ∈ ΣCTG , σ' /∈ ΣCTG ,λ ∈ LabSP (σ →λ

σ' ∈→SP )},
Inconc
L2A
L2A	O

Fail: ΣCTG = {σCTG}, σCTG /∈ ΣSP (implicit states).

Fail
Fail
Fail

The set of transitions of the CTG is deﬁned as →CTG =→CTG
CTG
Inconc

∪ →CTG with:
→CTG =→SP ∩(ΣCTG × LabCTG × ΣCTG ),

L2A
L2A
L2A

→CTG =→SP ∩(ΣCTG × LabCTG × ΣCTG ),

Inconc
L2A	I
Inconc

→CTG = {σ →λ σCTG|σ ∈ ΣCTG ∧ λ ∈ LabCTG ∧ σ after λ = ∅}.

Fail
Fail
L2A	I

The reason for mirroring inputs and outputs in the CTG lies in the relation between a test case and the IUT , as the input of the IUT is the output of the test case and vice versa. However, since a test case can normally not test all possible
inputs of an IUT , its set of outputs LabCTG is limited to a subset of the IUT ’s
set of inputs LabSpec by building the synchronous product of MSpec and MTP . The CTG may contain loops and choices between several outputs in the same state or between inputs and outputs. For this reason it is not controllable, i.e. the tester can for example not autoatically decide whether to expect an input from the IUT or to send an output to it.
The sets of accepting and refusing states of MSP induce the sets of accepted and refused traces denoted [MSP ]]atrace and [MSP ]]rtrace respectively. [MSP ]]atrace are those traces that end in a state σ ∈ ΣSP and [MSP ]]rtrace = [[MSpec]]trace\[[MSP ]]atrace. Depending on the trace executed during the actual test, a verdict is assigned to assess the correctness of the IUT .
Definition 2.2 (Sound Verdict) Predeﬁned values for verdicts are: Pass, Inconc, Fail and None. The verdict is set by a function setverdict : [MSP ]]trace → Verdict with:
⎧⎪ Pass	, iff β ∈ [[MSP ]]atrace ∧ |β| > 0

Fail	, iff β /∈ [[MSP ]]atrace ∪ [[MSP ]]rtrace ∧ |β| > 0
⎩ None , iff |β| = 0 

The Pass verdict is assigned to those states of MCTG , which correspond to the final states of traces from [MSP ]]atrace and thus to the accept states in the test purpose. The Inconc verdict is assigned to states from which accepting states are not reachable. In this case, the state is still on a trace of MSpec but the trace does not satisfy the test purpose (traces from [MSP ]]rtrace). All unspecified outputs lead


sort Bool
func T :→ Bool  F :→ Bool map and : Bool × Bool → Bool var b : Bool
rew and(T, b) = b   and(b, T ) = b   and(F, F ) = F
Fig. 2. Data type for booleans

to the Fail verdict.
As we said before, MCTG may contain choices between several outputs and choices between inputs and outputs. The test cases, we treat in this paper, are loopfree and controllable. A controllable test case MTC is derived by resolving the choices mentioned, i.e. the test case does not contain these choices between outputs or between inputs and outputs anymore. A test case is executed in parallel with an IUT . A trace β ∈ [[MTC ]]Pass that leads to a Pass state is chosen. From this trace, several branches with one step lead to Inconc states, which represent traces in the test purpose ending in a refusing state.
Using test purposes as selection criteria, it is possible to generate test cases on-the-fly without generating the whole state space of a specification. However, a complete test graph can – due to all possible data – easily be infinite or at least too large to handle for enumerative techniques.

Syntax and Semantics of Specifications
In this section, we define the syntax and semantics of the systems we are work- ing with. A speciﬁcation Spec is given by a quintuple Spec = (Sort, Fun, Act , Comm, Proc) (for the specification language μCRL see [18]). It specifies an open system that communicates with its environment. Sort defines a set of data types for the declaration of variables. For each sort S there exists a set of constructors, which have the form c :→ S or c : S1 × ... × Sn → S, resp., with S1,..., Sn ∈ Sort . These constructors are used to form values of sort S.
In Fun, functions of the form f :→ S or f : S1 × ... × Sn → S, resp., are declared. Each of these functions is defined by one or more axioms on values of sorts S1,..., Sn. These axioms have the form s = t where s and t are equally typed terms formed by any valid combination of typed variables and function symbols.
Figure 2 shows a sort Bool representing booleans (see sort), that is given by the two constructors T (for true) and F (for false, see func). The function and is de- clared in map with three axioms defining properties of and (see rew). Additionally, b is defined as a variable of sort Bool (see var).
The sets of actions Act and communicating actions Comm are necessary to declare the actions and communication issues necessary for the process definition. However, we will not discuss them here in detail. The process itself is defined as Proc in terms of Linear Process Operators [1]. To enable a graphical representation, however, we give a definition of processes based on the theory of Symbolic Tran-





l −→?s(x) ˆl ∈ Edg	∀v ∈ D
(l, η) −→?s(v) (ˆl, η[x '→v])

Input

l −→g ¢!s(e) ˆl ∈ Edg	[[g]]η = true	[[e]]η = v


(l, η) −→!s(v) (ˆl, η)
l −→g ¢ x:=e ˆl ∈ Edg	[[g]]η = true	[[e]]η = v
(l, η) →τ (ˆl, η[x '→v])
Output Assign



Table 1
Step semantics of process definition P (Spec → M)

sition Systems. A process definition Proc can thus be described by a four-tuple (Var , Loc, σinit, Edg ), where Var denotes a finite set of variables, and Loc denotes a finite set of locations or control states. A mapping of variables to values is called a valuation; we denote the set of valuations by Val = {η | η : Var → D}. Let Σ = Loc × Val be the set of states, where a process has one designated initial state σinit = (linit, ηinit) ∈ Σ. The set Edg ⊆ Loc × Act × Loc denotes the set of edges. An edge describes changes of configurations specified by an action from a set Act . Considering locations as nodes and edges as edges, such a specification can also be graphically represented as a Symbolic Transition System.
As actions, we distinguish (1) input of a signal s with a local variable to which a value can be assigned, (2) output of a signal s together with a value described by an expression, and (3) assignments. Every action except inputs is guarded by a boolean expression g, its guard. The three classes of actions are written as ?s(x), g D!s(e), and g D x := e, respectively, and we use α, α' ... when leaving the class of actions unspecified. For an edge (l, α, ˆl) ∈ Edg , we write more suggestively l −→α ˆl.
The behavior of the process is then given by sequences of states ζ = σinit → σ1 → ... starting from the initial one. The step semantics is given by an IOLTS M = (Σ, Lab, →, σinit), where → ⊆ Σ × Lab × Σ is a labeled transition relation between states. The labels differentiate between internal τ -steps and communication steps, either input or output, which are labeled by a signal and a value being transmitted, i.e. ?s(v) or !s(v), respectively. We assume that the set of signals coming from the environment and the set of signals exchanged within the system are disjoint.
The semantics is given by the inference rules in Table 1. Receiving a signal with a communication parameter x, l −→?s(x) ˆl ∈ Edg , results in an update of the valuation η[x '→ v] according to the parameter of the signal (rule Input). Output, l −→g ¢!s(e)
ˆl ∈ Edg , is guarded, so sending a message involves evaluating the guard and the expression according to the current valuation. It leads to a change of location of the process that sends the message (rules Output). Assignments, l −→g ¢x:=e ˆl ∈ Edg , result in a change of the location and an update of the valuation η[x '→ v], where [[e]]η = v. Assignments are internal, so assignment transitions are labeled by τ (rule Assign).
Although we are working with specifications containing only one process defini-

tion, it does not limit our approach. The realization of our approach works on linear process operators [1]. For these, existing linearization techniques [19] can be used to obtain a single process definition for a parallel composition of a finite number of process definitions by eliminating communication and parallel composition.

Constraint-Solving Preliminaries
In this section we give an overview of notions related to constraint-solving [25].
A constraint domain D consists of a set of n-ary constraint symbols which de- scribe relations and a logical theory T . An example for such a constraint symbol is “≤”. A primitive constraint c(X1,..., Xn) is constructed from a constraint sym- bol and terms in the corresponding value set Vi for every argument position. An example for a primitive constraint is ≤ (X, Y ) defining the relation X ≤ Y .
A constraint is of the form C = c1 ∧ ... ∧ cm where m ≥ 0 and c1,..., cm are primitive constraints. We use vars(C) to denote the set of variables of constraint
C. A valuation θ of a constraint C is a mapping of variables of vars(C) to values of ⟨V1,..., Vn⟩ in D.  A logical theory T determines which constraints hold and
which constraints do not hold under a certain valuation θ. If the constraint C holds for valuation θ under theory T of constraint domain D, this is denoted D |= [[C]]θ. There are two distinct constraints true and false which behave the same for any theory. The tautology true always holds, while the contradiction false never holds. Two problems are associated with C: the solution problem and the satisfaction
problem. The first one determines a particular solution, the latter one determines whether there is at least one solution. Let θ be a valuation for C. θ is a solution for C if [C]]θ holds, i.e. D |= [[C]]θ. A constraint C is satisﬁable if it has at least one
solution.
A constraint solver solv () for a constraint domain D is a decision procedure that takes as an input a constraint C and returns either true, false or unknown. Whenever solv (C) returns true, C is satisfiable. Whenever solv (C) returns false, there is no solution for C and C is unsatisfiable. The value unknown indicates that a solution might exist, but could not be determined.
A user deﬁned constraint is of the form p(t1,..., tn) where p is an n-ary predicate and t1,..., tn are terms (variables, constants or functions) from a constraint domain. An example for a user-defined constraint is a(X, f (Y )), which takes two parameters (the variable X and the function f (Y ), with Y again being a variable). A literal is either a primitive constraint or a user defined constraint. A rule R, for instance in Prolog, is of the form A :− B where A is a user defined constraint and B is a sequence of literals. For example, a(X, f (Y )) :− X > 0,Y < X incorporates the two primitive constraints X > 0 and Y < X in the sequence of literals. A fact is a rule with an empty sequence of literals, i.e. a rule of the form A :− , where is used to denote an empty sequence of literals. A constraint logic program P is a sequence of rules.
A goal or a query G is a sequence of literals, i.e. G = L1,..., Lm with m > 0. If m = 0, then G is an empty query denoted  .  Let query G be of the form

L1,..., L(i—1), Li, L(i+1),..., Lm and Li = p(s1,..., sn). A state in a constraint logic program is given by a pair ⟨G | C⟩ with G being the actual goal and C being the constraint store, storing all relevant conditions for this state. The transitions between these states are derivation steps. A derivation [25] is a full trace from the initial to the final state, ⟨G1 | C1⟩⇒ ... ⇒ ⟨  | C⟩.

Data Abstraction
In this section, we describe the idea of data abstraction to close open systems for test generation. First, we explain the approach, before we discuss the relation between a concrete and an abstracted system.
We do not make any assumptions about the environment of an IUT , i.e. we take the most general one. Signals coming from the environment can thus have any value. This often boosts the state space of the system to infinity. We abstract
data that is directly or indirectly influenced by the environment to one value chaos,
denoted T. Values that are not influenced by the environment remain the original ones, and so they should be treated in the same way as in the original system. This data abstraction was first proposed in [30] for model checking open systems. A system obtained by this approach is a safe abstraction of the original one, meaning,
it shows at least the behavior of the original system [21,30].
We implement data abstraction as a transformation on the level of system spec- ification. Abstraction on the level of specifications is well developed within the Abstract Interpretation framework [10,11,12]. The program transformation imple- menting this data abstraction transforms the signature and the process definition. For each sort S , we introduce a sort S T that consists of two constructors, TS :→ S T and κ : S → S T. The first constructor defines a T value of the sort. The con- structor κ (known) lifts values of sort S to values of sort S T. For each concrete mapping m : S1 ×· · ·×Sn → Sn+1, we define a mapping m T : S T ×· · ·×S T → S T
1	n	n+1
mimicking the original one on the abstracted sorts. In the general case, mimicking is ensured by providing the following rewrite rules for each abstract mapping m T:

m T(κ(x1),..., κ(xn)) = κ(m(x1,..., xn))
m T(x1,..., xn) = TSn+1 if xi is TSi for some i ∈ {1; ...; n}
The transformation of the process specification consists in lifting all variables, expressions and guards to the new sorts. Each occurrence of a variable x of sort S , is substituted by a variable xT of type S T where S T is a safe abstraction of sort S. Each occurrence of an expression e of type S is lifted to the expression e T of sort S T. Thereby, all the newly introduced symbols (constructors and rewrite rules) are used and replace the original ones.
Transformation of guards is similar to the transformation of expressions. Every occurrence of a guard g is lifted to a guard g T of type Bool T. While transforming guards we should ensure that the abstract system shows at least the behavior of the original system. Therefore, the guards valuated to κ(true) or κ(false) behave like


sort Bool T
func TBool : → Bool T
κBool : Bool → Bool T
map and T : Bool T × Bool T → Bool T
γ : Bool T → Bool
var b, b' : Bool
rew and T(κ(b), κ(b')) = κ(and(b, b'))
and T( TBool, κ(F )) = and T(κ(F ), TBool) = κ(F ) and T( TBool, κ(T )) = and T(κ(T ), TBool) = TBool and T( TBool, TBool) = TBool
γ( TBool) = T γ(κ(b)) = b
Fig. 3. Transformed sort BoolT



l —→?s(x) ˆl ∈ Edg


l —→?s( T)—→true ¢ x:= T ˆl ∈ Edg T
l —→g ¢!s(e) ˆl ∈ Edg

SInput T



l —→γ(g T ) ¢!s(eT ) ˆl ∈ Edg T
l —→g ¢ x:=e ˆl ∈ Edg


l —→γ(g T ) ¢ x:=eT ˆl ∈ Edg T
SOutput T


SAssign T



Table 2
Transformation of edges (Spec → Spec T)

guards evaluating to true or false, respectively. The guards valuated to T behave as guards evaluating to true. We implement this by introducing an extra mapping γ : Bool T → Bool that is true whenever a guard is evaluated either to T or to κ(true) and false otherwise. To avoid introducing unnecessary nondeterminism, we apply a more refined, technically speaking a non-strict, transformation to the sort Bool. Its abstraction, sort Bool T, is shown in Figure 3.
Definition 5.1 (May Semantics for Chaotic Guards) While a guard g is de- ﬁned as a function g : Σ → {true, false}, a chaotic guard is deﬁned as a function g T : Σ T → {true, false, T}. To map this three valued logic back to a two valued logic, a may-function γ : {true, false, T} → {true, false} is deﬁned as follows: γ(κ(true)) = true, γ(κ(false)) = false and γ( T) = true.
After transforming the signature and lifting system variables, expressions and guards, we obtain a system that still can receive all possible values from the environ- ment. The environment can influence data only via inputs. We transformed every input l —→?s(x) ˆl from the environment into an input of signal s parameterized by the T-value of the proper sort followed by assigning this T-value to the variable x





l —→?s(x)—→true ¢ x:= T ˆl ∈ Edg T

Input T

(l, η T) —→?s( T) (ˆl, η T	)

l —→γ(g T ) ¢!s(e) ˆl	[[γ(g T)]]η T = true	[[eT]]η T = v

(l, η T) —→!s(v) (ˆl, η T)
l —→γ(g T ) ¢ x:=e ˆl	[[γ(g T)]]η T = true	[[eT]]η T = v
(l, η T) →τ (ˆl, η T[x '→v])
Output T Assign T



Table 3
Step-semantics of transformed edges (Spec T → M T)


(see rule SInput T in Table 2). Assignments and outputs are treated as explained before. The semantics of the transformed system are given by the inference rules in Table 3. Given an IOLTS M , we derive M T by applying data abstraction on the specification of M .
M T can receive only T values from environment, so the infinity of environmental data is collapsed into one value. Basically, the transformed system shows at least the traces of the original system where data influenced by environment are substituted by T values. This means, that M T simulates M . This simulation relation is now defined for concrete and abstracted IOLTS s. It is not a standard relation, since we allow the abstraction of actions. Further, we give an overview of preservation results based on [21,20].
Definition 5.2 (≤-Simulation) Let M1 = (Σ1, Lab1, →1, σ1) and M2 = (Σ2,
Lab2, →2, σ2) be two IOLTSs. (≤a, ≤b) with ≤a⊆ Σ1 × Σ2 and ≤b⊆ Lab1 × Lab2 is
0	 
a simulation, iff ∀σ1, σˆ1, σ2, λ1 ∃σˆ2, λ2 σ1 ≤a σ2 ∧ σ1 →λ1 σˆ1 ⇒ (λ1 ≤b λ2 ∧ σˆ1 ≤a
σˆ2 ∧ σ2 →λ2 σˆ2) , where σ1, σˆ1 ∈ Σ , λ1 ∈ Lab , σ2, σˆ2 ∈ Σ , λ2 ∈ Lab .
1	1	2	2
We write M1 ≤≤ M2 if there is such a relation between M1 and M2, also relating

their initial states σ1
2
init

Before relating traces of the transformed system to the traces of the original system, we define an order relation on the states and on the labels of the systems. To relate states Loc × Val of the original system with the states of the transformed system Loc × Val T, we define the relation ≤S as:
Definition 5.3 (Relation ≤S) Let σ = (l, η) and σ T = (l', η T) be two states of the IOLTSs M and M T with speciﬁcations Spec and Spec T. ≤S: (Loc×Val )×(Loc× Val T) is deﬁned as σ ≤S σ T iff l = l' ∧ ∀x ∈ Var [[x]]ηT = T ∨ [[x]]ηT = κ([[x]]η) .
To relate labels Lab of the original system with the labels of the transformed system Lab T, we define the relation ≤L: Lab × Lab T.
Definition 5.4 (Relation ≤L) Let λ ∈ Lab and λT ∈ Lab T. Then λ ≤L λT is deﬁned as follows:
τ ≤L τ
?s(v) ≤L?s(v') iff either v' = T or v' = κ(v)

!s(v) ≤L!s(v') iff either v' = T or v' = κ(v)
The following lemma states the simulation relation between M and M T (see also the diagram below).
Spec T—a→b. 2 Spec T
Tab. 1⏐	⏐T ab. 3
M ≤≤ M T
Lemma 5.5 Let Spec be a speciﬁcation and Spec T be a speciﬁcation obtained from Spec by the transformation deﬁned in this section. Let M and M T be IOLTSs obtained from respectively Spec and Spec T by the rules in Table 1 or Table 3, re- spectively. Then M ≤≤ M T and (≤S, ≤L) is this simulation.
Proof sketch: The lemma is proven by checking the conditions for simulation in Definition 5.2 separately for input and output actions as well as for τ -steps. 
In the rest of the section, we lift this simulation relation on specifications to the inclusion of accepted and refused traces in the synchronous product of the abstracted system and the test purpose.
Lemma 5.6 Let M, N be IOLTSs with M ≤≤ N based on the simulation (≤S, ≤L). Let P be a test purpose. Then M×P ≤≤' N×P with (≤S' , ≤L) being this simulation. In this case holds: (σM , σP ) ≤S' (σN , σˆP ) iff σM ≤S σN and σP = σˆP . The relation
≤L is the same as deﬁned in Deﬁnition 5.4.
Proof sketch: The proof is analogous to that for Lemma 5.5, extended for the consideration of a synchronous product.	 
Definition 5.7 (≤-inclusion on traces) Let ζ and ρ be traces of IOLTSs M1 and M2. Trace ρ ≤-includes ζ, written ζ ≤ ρ, iff |ζ| = |ρ| and ζλ(i + 1) ≤L ρλ(i + 1) for all i ∈ {0; ... ; |ζ|}.
Definition 5.8 (≤-inclusion on automata) The set of traces generated by IOLTS M2 ≤-includes the set of traces generated by IOLTS M1, written as [[M1]]trace ⊆≤ [[M2]]trace, iff for every trace ζ of M1 there exists a trace ρ in M2 such that ζ ≤ ρ.
Lemma 5.9 Let TP be a test purpose, MSP be a synchronous product of M with
MTP , and M T be a synchronous product of M T with MTP . Then [[MSP ]]atrace ⊆≤
[[M T ]]atrace and [[MSP ]]rtrace ⊆≤ [[M T ]]rtrace .
SP	SP
Proof sketch: To prove the lemma, we have to take Assumption 1 into considera- tion. We first show that the set of accepted and refused traces of MSP in isolation is a subset of the union of accepted and refused traces in M T . Then it is shown that
the accepted traces of MSP and the refused traces of M T do not have a common
intersection. The same is shown for the refused traces of MSP and the accepted
traces of M T .	 

Testing with Abstractions
In this section, we describe the approach of test selection and execution with data abstraction. First, we give an algorithmic overview of the whole process. Then, we describe how the necessary rule system is built and how test selection and execution work. Finally, we review our approach and prove the soundness of verdicts assigned to a test execution.

Test Process Overview

Algorithm	6.1	(SelectAndExecTest(Spec, TP )	:	verdict	∈
{None, Pass, Inconc, Fail})
1	setVerdict(None);
2	Spec T := abstract (Spec);
3	Y£ := buildRuleSystem(Spec);

T
Spec
:= generateLTS (Spec T);

5	MTP := generateLTS (TP );

T
CTG
:= generateCTG(M T
, MTP );

T := selectATC (M T	);
8	while M T /= no testcase
9	(β, θ) := NewPassTrace(no trace, ∅,M T );
10	if (β, θ) /= no solution
11	then
12	ExecTest (β, θ, no trace,M T );
13	terminate;
14	fi

15	M T
16	elihw
:= selectATC (M T	);




Fig. 4. Selection and execution of tests

In Figure 4, the test process is described as an algorithm. Its input parame- ters are a specification Spec and a test purpose TP . Spec is abstracted to Spec T
according to Section 5. Then M T	is generated from Spec T and MTP from TP .
In parallel, a rule system Y£ is built, containing all conditions from Spec.  Y£
will later be needed to parameterize test cases with concrete data. From the two
IOLTS s, the complete test graph M T	is generated using TGV (cf. [3]). M T
may contain choices between several outputs to the IUT or even between inputs
and outputs, so it is not necessarily controllable. Furthermore, M T	is an overap-
proximation of all test cases of the original system which satisfy the test purpose, so it may contain traces leading to unsound verdicts.
Our goal is to obtain parameterizable test cases (for instance in TTCN-3 [13]) together with information about data values to instantiate them. To make tests

repeatable, we are interested in test cases where no nondeterministic choice is pos- sible between several outputs or between inputs and outputs. Therefore, we single
out a subgraph of M T	that contain neither choices between several outputs or
choices between inputs and outputs, nor loops. We refer further to this subgraph
as an abstract test case (ATC), denoted M T .
Even though we are still working on the level of IOLTS s here, we now have to in-
troduce variables for parameterization. In M T , each occurrence of T is substituted
by a unique symbolic variable vij parameterizing inputs and outputs, respectively. The double index is necessary to identify the state, in which the transition with the variable starts (index i) and to uniquely identify this variable within the set of variables on transitions from state i (index j). These variables are embedded into
the transition labels of the IOLTS , but are distinguished as a separate set Var in
remainder of this section.
Definition 6.1 (Parameterizable Test Case) Given a parameterized complete
test graph M T	(Var CTG ) = (Σ, Var CTG, Lab, →CTG, σinit), a parameterized test
case M T (Var TC ) is an input complete IOLTS (Σ, Var TC , Lab,
→TC , σinit) such that Var TC ⊆ Var CTG holds for the sets of symbolic variables of
T  and M T	. The set of states of the test case is a subset of the set of states
of the complete test graph, and the test case shows only Pass, Inconc and Fail traces

possible in the complete test graph, i.e. [[M T
]]Pass ⊆ [[M T
]]Pass, [[M T
]]Inconc ⊆

T
CTG
]]Inconc, and [[M T
]]Fail ⊆ [[M T
]]Fail.

Before a parameterizable test case can be executed, it must be instantiated. This means, that each of the variables vij must be set to a value such that a Pass-state in the test case can be reached with this valuation. In order to do so, a trace to Pass is selected with NewPassTrace (Figure 5). If such a trace exists, it can be executed, otherwise the next possible trace is searched. If no trace can be found in this abstract test case, the next test case is generated and examined for traces to Pass. If no such trace could be determined at all, the algorithm terminates with the final verdict None without executing any test cases.
The algorithm selects only one trace and executes it, where necessary dynam- ically adapting to the IUT ’s reaction on input. A complete test suite consisting of more than one trace (irrespective of possible adaptions), could be executed by introducing a loop which repeats the trace selection and execution actions. The final verdict would then be the upper limit of verdicts for the single tests (see Defi- nition 2.2).
Executing the trace β under a valuation θ does not mean, that this execution is bound to that trace for the whole execution. At some point during test execution, the IUT may nondeterministically leave the precalculated trace. In this case, the
test execution algorithm tries to find another trace to a Pass verdict.  This new
trace, however, must contain the part of β, which has yet been executed, as its prefix. The trace valuation can also only be extended by new values.





l —→g ¢!s(e) ˆl ∈ Edg


s(state(l, Var ), state(ˆl, Var ), param(e)) :— g.
l —→?s(x) ˆl ∈ Edg

ROutput

RInput

s(state(l, Var ), state(ˆl, Var [x '→Y ]), param(Y )).
l —→g ¢ x:=e ˆl ∈ Edg

τ(state(l, Var ), state(ˆl, Var [x '→e]), param) :— g.


RAssign



Table 4
Transformation of specification Spec into rule system Y£


Building the Rule System and Queries
A parameterizable test case may contain traces introduced by data abstraction. Moreover, information about the relationship of symbolic variables or concrete val- ues they can be substituted with is absent. To sort out spurious traces and to obtain valuations for symbolic variables, we employ constraint-solving.
We transform the original specification Spec to a constraint logic program or a
rule system Y£. This rule system forms the basis for test oracles or queries. A Pass-
trace β which is selected from M T is transformed into a query G := Oβ(θ). Here,
θ is a possible (i.e. valid) setting of data values, with which β can be instantiated. Let the set of symbolic variables in the specification be Var symb. If there is no solution for the query, β is a spurious trace introduced by data abstraction and we remove the trace from the test case. If there is a solution θ : Var symb → D in Y£ for the query, β can be mapped to the trace of the original system.
We refer to trace β with symbolic variables substituted according to θ as an instantiated trace denoted β(θ). The instantiated trace β(θ) is a trace of the orig- inal system MSpec. As we will prove later, the verdict assigned by β(θ) is sound. Knowing at least one possible solution for any Pass-trace is already enough to start
executing test case M T , parameterized with this solution θ. Further, we define
the transformation of an original specification into a rule system and obtain a query from a Pass- or Inconc-trace of the test case.
Transformation from the original specification Spec to the rule system Y£ is defined by the inference rules given in Table 4.  These rules map edges of the specification to rules of Y£.  All the rules are of the form rule name(state(l, Var ), state(ˆl, Var '), param(Y )) :— g. The name of the rule is that of the corresponding action (τ for internal assignments). The first state parameter describes the source state of the edge in terms of the specification location and the process variables. The second state parameter describes the changed target state in the same terms. The third parameter param contains all symbolic variables or expressions which form the action parameters.
The rules RInput, ROutput and Assign transform input, output and internal assignment actions to constraint rules. The guard of an output or an internal action forms the body of the corresponding rule. Rules for input actions always holds, since

no guards are specified for inputs. The action parameters param are given by the expression e for an output, or by a variable Y for an input action, while internal actions have no action parameters. Finally, input and internal assignment actions change values of variables. This change is noted in the second state parameter of the respective rule.



oracle(i, r) = 
⎧⎪ [] , iff r = []
⎪ sig (τ )(state(l





init



, Var


), state(l , Var ), param)|oracle(1, r') ,

iff i = 0 ∧ r = [σ →τ σ'|r']

⎪⎨	iff i = 0 ∧ r = σ →?s(Y ) σ'|r' ∨ r = σ →!s(Y ) σ'|r' 
⎪ sig (τ )(state(l , Var ), state(l	, Var	), param)|oracle(i + 1, r') ,
i	i	i+1	i+1
⎪
iff i > 0 ∧ r = [σ →τ σ'|r']

⎪⎩	iff i > 0 ∧ r = σ →?s(Y ) σ'|r' ∨ r = σ →!s(Y ) σ'|r' 



Table 5 Transformation of a trace of M T

into oracle OTC


After the rule system Y£ has been generated, we proceed with choosing a Pass-
trace β in M T and transforming it into an oracle Oβ := oracle(0, β) using the
function given in Table 5. Basically, an oracle is a sequence of rule invocations corresponding to the transitions along the chosen Pass-trace. Each transition along the trace is transformed into a rule invocation, which has the name of the action under consideration given as sig (s). The parameters of this rule invocation are the state of the system where the transition starts (first parameter), the system’s state
after the transition and the action’s parameters. In the first transition, which is characterized by the counter i = 0, the starting state of the transition is set to the initial state of the system. The function oracle then iterates through the trace and appends all rule invocations to one list, which forms the oracle.
In the oracle Oβ, all free variables in the system have not yet been bound to values. This happens by applying the constraint solver to the rule system Y£ and the oracle Oβ using the function θ := solve(Y£, Oβ, θconst).
Definition 6.2 (Partial Valuation) Let vars : [[M ]]trace → Var symb be a function that projects the set of variables Varsymb of M to that subset that is actually used in a given trace from [[M ]]trace.
Given a valuation θ : vars(β) → D and a trace δ, which is a preﬁx of β, we deﬁne the partial valuation [θ♩δ : vars(δ) → D such that ∀x ∈ vars(δ) [θ♩δ(x) = θ(x) .

The parameter θconst ⊆ θ can be used to define a set of constant valuation assignments. For instance, if a prefix δ of β has already been executed during a test and only for the suffix of β a new valuation has to be found, θconst := [θ♩δ can be defined as this set of constant values. In all cases, where this situation is not applicable, i.e. no part of θ has to be constant, the optional parameter θconst can be defined as ∅ and is further ignored. Having calculated a valuation θ for a trace β, the query G := Oβ(θ) can be built and it can be checked, whether < G, true > is solvable.
When describing the test selection process in Section 6, the algorithm NewPassTrace has already been mentioned. Its task is to select a trace β from the abstract test case and find a valuation θ, so that β(θ) is a trace in the original system specification Spec. Therefore, the algorithm makes use of the oracle Oβ and the rule system Y£. In the following lemma, we claim that if an oracle based on Y£ holds under a certain valuation then the corresponding trace under this valuation is a valid trace in MSpec and vice versa.
Lemma 6.3 Let β(θ) be a trace β of the ATC instantiated with the valuation θ. Then: Y£ ▶ Oβ(θ) ⇔ β(θ) ∈ [[MSpec]]trace.
Proof sketch: To prove this lemma, both directions of implications have to be proven separately. For each of the directions, the initial and the general case of a transition in MSpec are regarded separately for input, output and internal assignment actions.	 



Algorithm 6.2 (NewPassTrace(δ, θ, M T
) : (β, θ') ∈ [[M T
]]Pass × {Var symb →

D})
1	β := selectFirst (δ, [[M T ]]Pass);
2	while β /= no trace
3	Oβ := oracle(0, β)
4	θ' := solve(Y£, Oβ, [θ♩δ)
5	G := Oβ(θ')
6	if < G, true > is satisfiable
7	then return (β, θ');
8	else β := selectNext (δ, [[M T ]]Pass);
9	fi
10	elihw
11	return no solution;


Fig. 5. Pass trace selection procedure

The algorithm NewPassTrace, shown in Figure 5, finds a new trace to a Pass
verdict together with a valid valuation. The algorithm takes a trace prefix δ, a
valuation θ and a test case M T	as input parameters and returns a trace β ∈
[[M T ]]Pass as well as an appropriate valuation (here θ'). It iterates over all possible



Algorithm 6.3 (ExecTest(β, θ, δ, M T ) : verdict ∈ {None, Pass, Inconc, Fail})
1	step := next (β, δ);
2	case step
3	no step :
4	if |δ| > 0
5	then setVerdict(Pass);
6	else setVerdict(None);
7	fi
8	τ : ExecTest (β, θ, add (δ, step),M T );
9	!s(X): sendToIUT (s([[X]]θ));
10	ExecTest (β, θ, add (δ, step),M T );
11	?s(X): receiveFromIU T (sig (Y ));
12	if sig = s ∧ [[Y ]] = [[X]]θ;
13	then ExecTest (β, θ, add (δ, step),M T );
14	else
15	δ' := add (δ, sig (Y ));
16	Oδ' := oracle(0, δ');
17	Gδ' := Oδ' ([θ♩δ[X'→[[Y ]]]);
18	if ¬satisﬁable(< Gδ' , true >)
19	then setVerdict(Fail);
20	else
21	(β', θ') := NewPassTrace(δ', [θ♩δ[X'→[[Y ]]],M T );
22	if (β', θ') = no solution
23	then setVerdict(Inconc);
24	else ExecTest (β', θ', δ',M T );
25	fi
26	fi
27	fi
28	esac


Fig. 6. Test execution procedure





traces to Pass with prefix δ in the test case and returns the first, which contains δ as its prefix and satisfies the query G under the valuation θ'. θ' is derived by solving the rule system Y£ for the trace β with a partial solution [θ♩β given. This partial solution cannot be changed anymore, since it gives the (proper) valuation for the already executed trace δ. The new trace found by NewPassTrace must satisfy
< Oβ(θ'), true >. If it does not, then the next possible trace to Pass is selected.

Test Execution
In an IUT , nondeterminism may be induced, for instance, by interleavings of the behavior of single components. In these cases, it is possible that during test execu- tion the IUT leaves a trace to Pass which had been calculated beforehand and which is in principle a valid trace. Test execution then has to be adapted dynamically to the new situation.
Let β be a Pass-trace of M T , θ be a solution for the query obtained from β by
the rules in Table 5, and δ be the already executed prefix of β (initially it is empty). Let next be a function that returns the next step of trace β or no step, if no such step exists. Sending a signal to the IUT happens by the function sendToIUT , receiving by receiveFromIUT . Both functions are parameterized with the signal to
be sent or received.
Test execution is defined by the recursive algorithm in Figure 6. First, the actual step under consideration is calculated. Then, a decision is made, based on the type of this step. If the next step is no step, meaning that the end of the trace has been reached, the algorithm assigns either the None verdict, if no steps have yet been executed, or the Pass verdict. In this case, the test execution finished without finding any failures or inconclusive situations in the IUT . If the actual step is a τ -step, ExecTest is invoked recursively, adding the τ -step to the trace prefix, which has already been executed before. An output step !s(x) is treated similarly, except that the signal s is sent to the IUT . Its parameters are instantiated according to θ.
Handling an input ?s(X) is more complex. First, the input is received from the IUT as ?sig(Y ). If now both the signal sig and the valuation of its parameters [Y ]] are as expected, then the step is just added to δ and a recursive invocation of the execution algorithm happens. If the signal sig or the parameter valuation does not fit the expectations, then it is checked, whether test execution has already left the valid traces of the system specification. In this case, Fail is assigned, otherwise a new trace to Pass with the new valuation is searched. If no such trace exists, Inconc is assigned. Otherwise, the algorithm is invoked recursively and test execution goes on.
Further, we argue the correctness of our approach by proving that the verdicts assigned to the IUT after having applied the algorithm ExecTest, are sound. Let Spec be a specification and TP be a test purpose. Let Spec T be a specification obtained by transforming Spec by the rules in Table 2. Let M T be an IOLTS generated by the rules in Table 3 and Y£Spec be a rule system generated by the rules in Table 4.

First, the synchronous product M T
T
Spec
× MTP is built. From M T , the

abstract complete test graph M T
is derived. From M T
, we get an abstract

controllable test case M T , from which we select a trace β to Pass. This trace is
instantiated with data, which has been derived from a query to Y£Spec. Trace β is
then executed. Its already executed prefix is the trace δ.
Lemma 6.4 (Termination of Test Execution) Given	a	ﬁnite	(non-cyclic) trace β, the test execution algorithm (Figure 6) always terminates assigning a ver-

dict, given that the IUT is deadlock-free.
Proof sketch: Given a finite trace, the algorithm always analyzes the next step in this trace. If there is no next step, i.e. the end of trace is reached, the algorithm terminates with Pass or None, resp. If the verdicts Fail or Inconc are assigned, the algorithm already stops without having reached the end of the trace under consideration. The lemma is proven by pointing out the exit points of the algorithm and the according assignments of verdicts.	 
Lemma 6.5 (Soundness of verdicts) The assignment of the test verdict to a test trace by the test execution algorithm (Figure 6) is sound.
In case, that the verdict Fail is assigned, for δ' = add (δ, sig (Y )) holds:
δ'(θ[X '→[[Y ]]]) /∈ [[MSpec ]]trace .
In case, that the verdict Inconc is assigned, for the executed trace δ holds:
δ ∈ [[MSpec]]trace Λ δ /∈ [[MTC ]]Pass.
If the verdict Pass is assigned, the executed trace δ(θ) ∈ [[MSpec]]trace Λ δ ∈
[[M T ]]Pass Λ |β| > 0.
In case that |β| = 0, None is assigned.
Proof sketch: This lemma is proven by first proving by induction, that any trace β which does not lead to a Fail verdict is a trace of the original system. The assignment of the separate verdicts is then shown by analyzing those points in the algorithm, which lead to the verdict under consideration, as well as the course of the algorithm from its initialization towards this point.	 

CEPS Case Study
In this section, we describe the application of our approach to the case study CEPS (Common Electronic Purse Specifications). These define a protocol for electronic payment using a chip card as a wallet. The specifications consist of the functional requirements [6] and the technical speciﬁcation [7]. A complete electronic purse system covers three roles: a card user, a card issuer (the issuing bank institute, for instance) and a card reader as a connection between these two. The hardware of such a system is given by the purse card itself, the card reader and some network infras- tructure. Software applications are running on the card (CEPCardApp), on the card reader (CERCardReaderApp) and at the site of the card issuer (CEPCardIssuerApp), and these applications are communicating with each other.
In our work on the case study, we aim to evaluate our test generation process by automatically generating parameterizable test cases for the scenario described in Figure 7. We start from a formalized version of the technical specification of the CEPS card application CEPCardApp (Courtesy of the VASY team at INRIA Rhˆone- Alpes, cf. [15]), which we simplified by a live-variable-analysis and realized in μCRL. In this specification, all input variables with an infinite domain are substituted by
T. The generation process itself is guided by the test purpose, which describes the
scenario, we are focusing on.



Fig. 7. Interactions in the test purpose scenario



The abstracted specification is then parsed and an LTS is generated. The re- sulting LTS is minimized using strong minimization. We experimented with two specifications for different scenarios. In the first one, a status variable of the pro- cess was after action CepReply(updateStatus(mSlotInfo,x940A)) updated with value x9409 instead of x940A. In the second specification, the value x940A was used. For the first specification, the whole process of LTS generation and minimization took 16 minutes and 5.088 seconds on a cluster of five 2.2GHz AMD Athlon 64 bit single CPU computers with 1 GB RAM each. The abstracted specification had 3023122 states and 17459807 transitions, which could be reduced by strong mini- mization to 1627 states and 5487 transitions. Finally, two single test cases without loops are generated using TGV, one of them limited to a maximal depth search for its preamble of 100 steps, the other one unlimited. Starting with the minimized abstracted system model and a test purpose of 5 states and 5 transitions, the gener- ated unlimited test case contained 594 states with 597 transitions. The limited test case contained 108 states with 111 transitions. Test case generation took 0.65 sec- onds or 0.42 seconds, resp., on a workstation with one 2.2GHz AMD Athlon XP
32 bit CPU and 1 GB main memory.
For the second specification, whose abstracted version had 168942 states and 232253 transitions (1619 states and 1899 transitions after strong minimization), the generation of the LTS took 69.418 seconds on the cluster. Test generation took
3.453 seconds for a test case of 255 states and 286 transitions (limitation to 100 steps led to identical results as unlimited generation).
Afterwards, a Prolog rule system is derived from the original specification that consists of the functions in the μCRL specification and of the conditions and assign- ments from the summands. This rule system is also reusable like the IUT model so that it potentially does not have to be regenerated each time a test oracle is created. The test oracle itself later delivers possible input and expected output values for the test execution. This oracle sends queries to the rule system to find out, under which variable settings the implemented trace can be executed and which values have to be expected from the IUT .

Conclusion and Future Work
In this paper, we proposed an approach to generate test cases combining data abstraction, enumerative test generation and constraint-solving. Given the concrete specification of an open system, the presented data abstraction allows to derive the appropriate abstract system that is finite with respect to data exchanged with its environment and thus suitable for the automatic generation of abstract test cases with enumerative tools. To execute the ATCs, we have to instantiate them with concrete data. For data selection we make use of constraint-solving techniques: a set of constraints is derived from the system specification and then solved by a constraint solver. The parameterized test cases can then be executed. We have proven the correctness of our approach. To corroborate the applicability of our approach, we applied it to the CEPS case study [5,6,7].
An interesting aspect, especially from a practical viewpoint, is the generation of test cases directly from UML specifications, as it has been proposed in [2,26]. As a future work, we aim to adapt our approach for UML-based test case generation. Doing so, the target language of test case generation is TTCN-3 (Testing and Test Control Notation, version 3), a standardized test specification language, widely accepted by the industrial community [35].

References
Blom, S. C. C., W. J. Fokkink, J. F. Groote, I. A. van Langevelde, B. Lisser and J. C. van de Pol, μCRL: A Toolset for Analysing Algebraic Specifications, in: G. Berry, H. Comon and A. Finkel, editors, Proc. of the 13th Intl. Conf. on Computer-Aided Verification, LNCS 2102 (2001), pp. 250–254.
Briand, L. C. and Y. Labiche, A UML-Based Approach to System Testing, in: Proc. of the 4th Intl. Conf. on The Unified Modeling Language, Modeling Languages, Concepts, and Tools (UML’01), LNCS 2185 (2001), pp. 194–208.
Calam´e, J. R., Specification-based Test Generation with TGV, Technical Report SEN-R0508, Centrum voor Wiskunde en Informatica (2005).
Calam´e, J. R., N. Ioustinova and J. v. d. Pol, Towards Automatic Generation of Parameterized Test Cases from Abstractions, Technical Report SEN-E0602, Centrum voor Wiskunde en Informatica (2006), ISSN 1386-369X.
Calam´e, J. R., N. Ioustinova, J. v. d. Pol and N. Sidorova, Data Abstraction and Constraint Solving for Conformance Testing, in: Proc. of the 12th Asia-Pacific Software Engineering Conf. (APSEC’05) (2005), pp. 541–548.
CEPSCO, “Common Electronic Purse Specifications, Functional Requirements,” (1999), version 6.3.
CEPSCO, “Common Electronic Purse Specifications, Technical Specification,” (2000), version 2.2.
Clarke, D., T. J´eron, V. Rusu and E. Zinovieva, STG: A Symbolic Test Generation Tool, in: Proc. of the 8th Intl. Conf. on Tools and Algorithms for the Construction and Analysis of Systems (TACAS’02) (2002), pp. 470–475.
Clarke, L. A., A System to Generate Test Data and Symbolically Execute Programs, IEEE Transactions on Software Engineering 12 (1976), pp. 215–222.
Cousot, P. and R. Cousot, Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints, in: Proc. of the 4th ACM SIGACT- SIGPLAN Symp. on Principles of programming languages (POPL’77) (1977), pp. 238–252.
Dams, D., “Abstract Interpretation and Partition Refinement for Model Checking,” PhD dissertation, Eindhoven University of Technology (1996).

Dams, D., R. Gerth and O. Grumberg, Abstract Interpretation of Reactive Systems, ACM Transactions on Programming Languages and Systems (TOPLAS) 19 (1997), pp. 253–291.
ETSI ES 201 873-1 V2.2.1 (2003-02), Methods for Testing and Specification (MTS); The Testing and Test Control Notation version 3; Part 1: TTCN-3 Core Language, ETSI Standard.
Frantzen, L., J. Tretmans and T. Willemse, Test Generation Based on Symbolic Specifications, in:
J. Grabowski and B. Nielsen, editors, FATES 2004, number 3395 in LNCS (2005), pp. 1–15.
Garavel, H. and F. Lang, NTIF: A General Symbolic Model for Communicating Sequential Processes with Data, in: Proc. of the 22nd IFIP WG 6.1 Intl. Conf. on Formal Techniques for Networked and Distributed Systems (FORTE’2002), 2002.
Godefroid, P., N. Klarlund and K. Sen, DART: Directed Automated Random Testing, in: Proc. of the 2005 ACM SIGPLAN Conf. on Programming Language Design and Implementation (PLDI’05) (2005), pp. 213–223.
Goodenough, J. B. and S. L. Gerhart, Toward a Theory of Test Data Selection, in: Proc. of the Intl. Conf. on Reliable software (1975), pp. 493–510.
Groote, J. F. and A. Ponse, The Syntax and Semantics of μCRL, Technical report, Centrum voor Wiskunde en Informatica (1990).
Groote, J. F., A. Ponse and Y. S. Usenko, Linearization in parallel pCRL, Journal of Logic and Algebraic Programming 48 (2001), pp. 39–72.
Ioustinova, N., “Abstractions and Static Analysis for Verifying Reactive Systems,” Ph.D. thesis, Free University of Amsterdam (2004).
Ioustinova, N., N. Sidorova and M. Steffen, Synchronous Closing and Flow Abstraction for Model Checking Timed Systems, in: Proc. of the 2nd Intl. Symp. on Formal Methods for Components and Objects (FMCO’03), LNCS 3188 (2004).
Jard, C. and T. J´eron, TGV: Theory, Principles and Algorithms, Intl. Journal on Software Tools for Technology Transfer 7 (2005), pp. 297–315.
Jeannet, B., T. J´eron, V. Rusu and E. Zinovieva, Symbolic Test Selection based on Approximate Analysis, in: Proc. of the 11th Intl. Conf. on Tools and Algorithms for the Construction and Analysis of Systems (TACAS’05), number 3440 in LNCS, Edinburgh (Scottland), 2005.
King, J. C., Symbolic Execution and Program Testing, Commun. of the ACM 19 (1976), pp. 385–394.
Marriott, K. and P. J. Stuckey, “Programming with Constraints – An Introduction,” MIT Press, Cambridge, 1998.
Offutt, J. and A. Abdurazik, Generating tests from uml specifications, in: Proc. of the 2nd Intl. Conf. on The Unified Modeling Language, Modeling Languages, Concepts, and Tools (UML’99), 1999, pp. 416–429.
OMG, “UML 2.0 Testing Profile Specification,” (2003), version 2.0, Final Adopted Specification/finalization phase.
Pretschner, A., O. Slotosch, E. Aiglstorfer and S. Kriebel, Model-based Testing for Real, Intl. Journal on Software Tools for Technology Transfer 5 (2004), pp. 140–157.
Rusu, V., L. d. Bousquet and T. Jeron, An Approach to Symbolic Test Generation, in: Proc. of the Intl. Conf. on Integrating Formal Methods (IFM’00), LNCS 1945, 2000, pp. 338–357.
Sidorova, N. and M. Steffen, Embedding Chaos, in: P. Cousot, editor, Proc. of the 8th Intl. Static Analysis Symp., LNCS 2126 (2001), pp. 319–334.
Tillmann, N. and W. Schulte, Parameterized Unit Tests, in: Proc. of the 10th European Software Engineering Conf. (ESEC/FSE-13), held jointly with 13th ACM SIGSOFT Intl. Symp. on Foundations of Software Engineering (2005), pp. 253–262.
Tretmans, J., Test Generation with Inputs, Outputs, and Repetitive Quiescence, Software - Concepts & Tools 17 (1996), pp. 103–120.
Tretmans, J. and E. Brinksma, TorX: Automated Model-based Testing, in: A. Hartman and K. Dussa- Ziegler, editors, 1st European Conf. on Model-Driven Software Engineering, 2003.


Visser, W., C. S. Pasareanu and S. Khurshid, Test Input Generation with Java PathFinder, in: Proc. of the 2004 ACM SIGSOFT Intl. Symp. on Software Testing and Analysis(ISSTA 2004) (2004), pp. 97–107.
Willcock, C., T. Deiß, S. Tobies, S. Keil, F. Engler and S. Schulz, “An Introduction to TTCN-3,” Wiley, 2005.
Zinovieva-Leroux, E., “M´ethodes symboliques pour la g´en´eration de tests de syst`emes reactifs comportant des donn´ees,” Ph.D. thesis, Universit´e de Rennes (2004).
