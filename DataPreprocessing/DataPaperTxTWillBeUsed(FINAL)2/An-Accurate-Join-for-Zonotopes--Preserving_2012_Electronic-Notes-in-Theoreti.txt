Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 287 (2012) 65–76
www.elsevier.com/locate/entcs

An Accurate Join for Zonotopes, Preserving Affine Input/Output Relations
Eric Goubault, Tristan Le Gall and Sylvie Putot
CEA, LIST, Laboratory for the Modelling and Analysis of Interacting Systems, Point courrier 174, 91191 Gif-sur-Yvette, France.

Abstract
Zonotopes are a convenient abstract domain for the precise analysis of programs with numerical variables. Compared to the domain of convex polyhedra, it is less expensive and may easily handle non-linear as- signments. However, the classical join operator of this abstract domain does not always preserve linear invariants, unlike the convex hull. We present a global join operator that preserves some affine relations. We end up by showing some experiments conducted on the constrained Taylor1+ domain of Apron.
Keywords: Abstract interpretation, zonotopes, affine relations


Introduction
Zonotopic methods have proved useful in a number of contexts in computer science, such as image processing [13], reachability analysis of hybrid systems [9,6] and static analysis by abstract interpretation as implemented in FLUCTUAT [5,12]. Most transfer functions (in particular, the interpretation of arithmetic expressions and assignments) are precise and fast in zonotopes. But set-theoretic functions, such as the meet and join operations, are difficult to characterize and compute, contrarily to most of other sub-polyhedric domains (zones [15], linear templates [18], even polyhedra [4]). Indeed, they are non canonical operations, and can only be over- approximated in the general case.
In [8], we proposed a meet operation for our zonotopic abstract domains. In this article, we propose an improvement of the time and space efficient upper bound operators that we introduced in [10,11,7]. The problem of these upper bound op- erators is that they forget a lot about the relations between values that program variables can take. They are only proved optimal (that is, giving minimal upper

1 Email:firstname.lastname@cea.fr


1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.09.007

bounds) in the case where only one variable differs in the joined states, which is of course fairly disappointing. This paper constructs a much better “global” upper bound, that is proved to be optimal in some situations, involving any number of program variables.

Contributions of the paper
We prove in Section 3 that minimal upper bounds e for constrained affine sets e1 and e2 necessarily satisfy the affine relations between program variables and central noise symbols (used to encode the inputs of the program) satisfied by both e1 and e2. The main contribution of the article is then the definition of a more precise global join operator, that uses the previous component-wise join of [10,11,7] only on part of the variables, and these common affine relations to deduce an upper bound on the other variables. We actually show in Proposition 3.3 that our join is optimal in some important situations.
In Section 4, we show on some applications that problems that would normally involve some form of disjunctive analysis or need some form of “clock domain” [3], can be treated precisely using the zonotopic abstract domain with our new join op- erator. Indeed, the implicit affine relations that may not be visible in the assignment of arithmetic expressions, are explicited - and preserved - by the join operation. We implemented this operation in the APRON [17] domain Taylor1+ [7]: some bench- marks show that while the join is still efficient in terms of time and memory (the abstract domain is unchanged, the sole join operation is modified), it is of similar precision as the polyhedric join.
Previous results on zonotopic abstract domains
Affine arithmetic, zonotopes and affine sets
Affine arithmetic is an extension of interval arithmetic on affine forms, first intro- duced in [2], that takes into account affine correlations between variables. An affine form is a formal sum over a set of noise symbols εi
xˆ d=ef αx + Σ αxεi,
0	i
i=1
with αx ∈ R for all i. Each noise symbol εi stands for an independent component of the total uncertainty on the quantity xˆ, its value is unknown but bounded in [-1,1]; the corresponding coefficient αx is a known real value, which gives the magnitude of that component. The same noise symbol can be shared by several quantities, indicating correlations among them.
The semantics of affine operations is straightforward, they are exact in affine arithmetic. Non affine operations are linearized, and new noise symbols are intro- duced to handle the approximation term. These new noise symbols are indicated as ηj noise symbols: the εi noise symbols model uncertainty in data or parame- ters, while the ηj noise symbols model uncertainty coming from the analysis. For

instance the multiplication of two affine forms defined on εi only (for simplicity of presentation) introduces a new noise symbol, say η1:


x  y	Σ


x  y	y x
,Σn

x  y	Σ
x  y	x  y ⎞

xˆyˆ = α0α0 +

i=1
(αi α0 + αi α0 ) εi + ⎝

i=1
|αi αi | +

i<j
|αi αj + αj αi |⎠ η1.


The coefficient of the new perturbation noise symbol η1 is an over-approximation of the non-linear part of the multiplication.
In what follows, we introduce matrix notations to handle tuples of affine forms. We note M(n, p) the space of matrices with n lines and p columns of real coefficients. A tuple of affine forms expressing the set of values taken by p variables over n noise symbols εi, 1 ≤ i ≤ n, can be represented by a matrix A ∈ M(n + 1, p). We note  tA is the transpose of A, and for any vector e = (e1,..., en) ∈ Rn,
||e||∞ = max1≤i≤n |ei|. We formally define the zonotopic concretization of such tuples by :

Definition 2.1 Let a tuple of affine forms with p variables over n noise symbols be defined by a matrix A ∈ M(n + 1, p). Its concretization is the zonotope
γ(A)= ,⎨ tA , 1 ⎞ | e ∈ Rn, ||e||	≤ 1,⎬ ⊆ Rp .
,	⎝ e ⎠	,

For instance, for n = 4 and
15	p = 2, the gray zonotope is the
concretization of the affine set
10	(xˆ, yˆ), with xˆ = 20 − 4ε1 + 2ε3 +
3ε4, yˆ = 10 − 2ε1 + ε2 − ε4, and
, 20 −4 0 2 3 ⎞
5	x	tA = ⎝	⎠ .

Following the repartition of noise symbols in two sets, we define affine sets as Minkowski sums of a central zonotope, γ(CX ) and of a perturbation zonotope cen- tered on 0, γ(PX ). Central zonotopes depend on central noise symbols εi, which represent the uncertainty on input values to the program. Perturbation zonotopes depend on perturbation symbols ηj which are created along the interpretation of the program and represent the uncertainty due to operations that are not interpreted exactly.
Definition 2.2 We define an affine set X by the pair of matrices
X = (CX,PX ) ∈ M(n + 1, p) × M(m, p).
The affine form Xk = cX + Σn	cXεi + Σm  pX ηj is the symbolic representation
in X of the value of xk (the kth program variable).

Geometric and functional orders
Definition 2.3 Let X be an affine set. Its concretization γ(X) ⊆ Rp is the zono- tope
γ(X)= ,⎨ tCX , 1 ⎞ + tPXη | ε × η ∈ [−1, 1]n+m,⎬ .
,	⎝ ε ⎠	,
If we were only interested in abstractions of current values of variables, the partial order to consider for proving the correctness of the abstract semantic would be subset inclusion of the concretization, as formalized in Definition 2.3.
However, we consider functional abstractions. Classically, input/output func- tional abstractions are handled by adding slack variables corresponding to the ini- tial values of the uncertain inputs. Here, we can see the central (noise) symbol εi of the affine forms as being these slack variables: an affine set for p variables over n input noise symbols defines a function from Rn to Rp.
We thus define a pre-order on affine sets [7,11] which formalizes the fact that the central symbols have a specific interpretation as parameterizing the initial values of input arguments to the analyzed program:
Definition 2.4 Let X = (CX,PX ), Y = (CY ,PY ) be two affine sets  in M(n + 1, p) × M(m, p). We say that X ≤ Y iff
∀u ∈ Rp, ||(CY − CX )u||1 ≤ ||P Y u||1 − ||PXu||1 .

where ||X||1 = Σn
|Xi| is the l1 norm of vector X.

Join operator: preliminaries and motivation for the present work
The least upper bound of two affine sets does not exist, there may be incompara- ble minimal upper bounds. In previous work [10,11], we defined an upper bound for affine sets based on an algorithm that, for each variable taken independently, gives a minimal upper bound in some (most, actually) cases. However, considered globally, this upper bound generally does not give a minimal upper bound: indeed, performing the join operation independently on each variable ignores the relations between variables, and is thus not satisfying.
Let us first recall this join operator over affine sets. For two real numbers α and
β, let α ∧ β denote their minimum and α ∨ β their maximum. We define
argmin|.|(α, β)= {γ ∈ [α ∧ β, α ∨ β] | |γ| minimal}
Let x and y be two intervals. We say that x and y are in generic positions if, whenever x ⊆ y, inf x = inf y or sup x = sup y.
Lemma 2.5 One-dimensional join. [10] Let two affine sets X and Y in M(n + 1, p) ×M(m, p) such that at least p− 1 components are equal: for all l ∈ [1, p], l /= k, Xl = Yl. We deﬁne Z = X H Y by for all l ∈ [1, p], l /= k, Zl = Xl = Yl and Zk = Xk H Yk, such that for all l ∈ [1, p], l /= k, i =1 ∈ [1, n], j ∈ [1, m]:

Z
0,k
= mid (γ(Xk) ∪ γ(Yk))

cZ
= argmin|.|(cX , cY )

i,k
i,k  i,k

pZ
= argmin|.|(pX , pY )

j,k
j,k	j,k

pZ
= sup γ(Xk) ∪ γ(Yk) − cZ
— Σn
|cZ |− Σm
|pZ |

m+k,k
m+k,l =0 
0,k
i=1
i,k
j=1
j,k

Then Z is an upper bound of X and Y such that γ(Zk)= γ(Xk) ∪ γ(Yk). And it is a minimal upper bound whenever γ(Xk) and γ(Yk) are in generic positions.
In words, the center of the affine form Zk is taken as the center of the concretiza- tions of the two affine forms Xk and Yk. Then the coefficients of Zk over the noise symbols present in Xk and Yk are taken as the smallest common dependencies. And finally we add a new noise symbol ηm+k to take into account the uncertainty due
to the join operation, its coefficient is pZ	.
This one-dimensional operator can be extended to obtain a p-dimensional join operator, when all dimensions of the affine sets are joined:
Lemma 2.6 Componentwise join. [11] Let two affine sets X and Y in M(n + 1, p) × M(m, p). We deﬁne Z = X HC Y by: for all k ∈ [1, p], Zk = Xk H Yk. Then Z is an upper bound of X and Y .
The perturbation added to take into account the uncertainty due to the join is a diagonal block p × p: a new noise symbol ηm+k is added for each variable xk, and these new noise symbols are not shared. This join operator thus loses some relation that may exist between variables.
Let us now consider an example, that motivates a global join operator :
Example 2.7

1 float x1 := [1,3];
2 float x2 := [1,3];
3 float x3;
4 if (random()) {
5	x1 = x1 + 2;
6	x2 = x2 + 2; }
7 x3 = x2 − x1;

Joining the two branches supposes to join the two affine sets X and Y defined by (X1 = 2 + ε1, X2 = 2 + ε2) and (Y1 = 4 + ε1, Y2 = 4 + ε2). If we apply the component-wise join defined in Lemma 2.5, we obtain Z such that Z1 = 3 + ε1 + η1 and Z2 =3 + ε2 + η2, where η1 and η2 are two independent new noise symbols. In this case, we do not capture the somehow disjunctive information, that either 0 or 2 is added to both program variables x1 and x2, but that it can not be that 0 is added to x1 and2 is added to x2. And we obtain Z3 = Z2 −Z1 = ε2 + η2 −ε1 −η1 ∈ [−4, 4]. Now, observe that there is a relation between variables which is true for both branches joined. Since we do not preserve it, the final result is inaccurate. Indeed, it is more than simply a relation between variables, it is a relation between variables and inputs of the program, relations that are captured by our functional abstract domain: we have x2 − x1 = ε2 − ε1 in both branches. In order to get a global join operation on X and Y , we can thus use the one-dimensional join operator on

one variable, and naturally deduce the affine form for the second variable by this relation: this gives W such that W1 = 3 + ε1 + η1 as previously, and we deduce W2 = 3 + ε2 + η1. We thus obtain here a minimal upper bound of X and Y , and can deduce the expected result W3 = W2 − W1 = ε2 − ε1 ∈ [−2, 2].
The projection on (x1, x2) of the concretization of X, Y , Z and W are repre- sented Figure 1. The component-wise join gives the box γ(Z) in which no relation is preserved between Z1 and Z2. Whereas the global join gives the zonotope γ(W ), which is here a minimal upper bound of γ(X) and γ(Y ).

0	1	3	5 x1
Fig. 1. X, Y and results Z and W of the component-wise and global join operators on Example 2.7
It now remains to formally define these common relations, and to characterize the join operator preserving these relations.
Preserving affine relations in join operations
Affine relations over affine sets
Let us consider an affine set X = (CX,PX ) over p program variables x1,..., xp, defined over n central noise symbols ε1,..., εn and m perturbation noise symbols η1,..., ηm. An affine relation in X is an affine equation over the p program variables and the n central noise symbols, that holds for any values of the noise symbols, i.e. is given by α1,..., αp, β0,..., βn ∈ R such that:
p	n
Σ αrxr = β0 + Σ βiεi	(1)
r=1	i=1
holds for any ε = t(ε1,..., εn) ∈ [−1, 1]n and η = t(η1,..., ηm) ∈ [−1, 1]m and (x1,..., xp)= tCXε + tPXη.
Note that only central noise symbols appear in the equation, and not the per- turbation noise symbols. Moreover, we cannot have all the αr = 0 without having all the βi = 0 as well. Hence affine relations in an affine set always link the value of at least one xr with other variables or central noise symbols. It is also well known that the set of affine relations defined in Equation 1, identified with the vec- tor (α1,..., αp, β0,..., βn), is a vector space over the reals: sums of any two such vectors, and multiplication of such vectors by any λ ∈ R still define a valid affine

relation. As a sub-vector space of Rp+n+1, it is necessarily of finite dimension, hence generated by a finite basis, i.e. a finite number k of independent affine relations. This k is thus necessarily less or equal to p, since the n noise symbols are linearly independent, and there is a constant term.

Common affine relations
An affine relation common to X and Y is an affine relation in X which is also an affine relation in Y . Consider we have k such affine relations, k being necessarily less or equal to p as previously stated:
p	n
Σ αl,rxr = βl,0 + Σ βl,iεi, ∀l ∈ {1 ... k}.	(2)
r=1	i=1
When the (xr)1≤r≤p are defined by an affine set X = (CX,PX ), we rewrite:

p r=1
αl,rxr = Σn

p r=1
αl,rci,r) εi + Σm

p r=1
αl,rpj,r) ηj, ∀l ∈ {1,..., k}

These relations, being true for every value of the noise symbols εi and ηj, imply that for all 1 ≤ l ≤ k, 0 ≤ i ≤ n and 1 ≤ j ≤ m, we have:

Σ αl,rci,r = βl,i	(3)	and
r=1
Σ αl,rpj,r =0	(4)
r=1

Example 3.1 Consider again the two affine sets joined in Example 2.7:


X1 = 2 + ε1 X2 = 2 + ε2
Y1 = 4 + ε1
and
Y2 = 4 + ε2

We want the affine relations common to X and Y , of the form: α1x1 + α2x2 = β0 + β1ε1 + β2ε2 that hold for all (ε1, ε2) ∈ [−1, 1]. Substituting X and Y in this relation yields β0 = 2α1 + 2α2 = 4α1 + 4α2, β1 = α1 and β2 = α2. The solutions can be parameterized by a λ ∈ R, they are of the form β0 = 0, α1 = β1 = λ, α2 = β2 = −λ. For instance we can choose x2 − x1 = ε2 − ε1.

Reduction to row-echelon form
Up to a renumbering of the variables x1,.. ., xp, we can always suppose the k inde- pendent affine relations common to X and Y are of the form:
xi = Ri(xi+1,..., xp, ε1,..., εn),	(5) where Ri is an affine function, for all i ∈ [1..k].
This can be shown as follows. We first consider the matrix M = t(D1,..., Dk) whose ith row is the vector Di ∈ Rp+n+1 representing the ith of the k independent affine relations common to X and Y . This matrix can be written M = (Mj|Mjj) with Mj a k × k matrix (only the coefficient of the xi appear) and Mjj is the remaining block of size k × (p + n +1 − k).

Now, Mj has an LU decomposition (see e.g. [1]) Mj = LU , where L is lower triangular and ones on the diagonal, U is upper triangular. Then (U|L—1Mjj) is a matrix of affine relations common to X and Y as well: indeed, (U|L—1Mjj)= L—1M and thus (U|L—1Mjj)u = 0 is equivalent to Mu = 0. Now, as the rank of M is k, as it is made of k independent affine relations, U has exactly k non-null elements on the diagonal, giving k independent relations of the form defined in Equation 5.
Deﬁnition of a join operator
Suppose we have two affine sets X and Y defining p variables, our new join operator is defined by Algorithm 1, that we prove correct, and even optimal in some cases, in this section (cf. Proposition 2.6). In what follows, we note X>k the affine set obtained by the projection of X ∈ M(n+1, p)×M(m, p) on its p—k last components xk+1,..., xp.

Algorithm 1 Algorithm for the global join operator Inputs are X = (CX,PX ), Y = (CY ,PY ), output is Z
Form the system of equations in αl,r, βl,i, for 1 ≤ l ≤ p, 0 ≤ i ≤ n, 1 ≤ j ≤ m:


p r=1
p r=1
αl,rcX αl,rpX
p r=1
p r=1
αl,rcY αl,rpY
= βl,i
=0 

Solve this system to get k independent affine relations, i = 1,..., k, using LU decomposition: xi = Ri(xi+1,..., xp, ε1,..., εn)
Define Z = X H Y as:
For rows strictly greater than k: Z>k = X>k HC Y>k (cf. Lemma 2.6) For rows less than k:
for i = k downto 1 do
Zi = Ri(Zi+1,..., Zp, ε1,..., εn)
end for
Basically, the algorithm works as follows: we determine the k independent affine relations between the variables and the input noise symbols εi, that they have in common. We express them as in Equation 2. We thus can choose among the p variables, p — k variables, on which we use the component-wise join of Lemma 2.6, and from there reconstruct an upper bound for the p variables using Equation 5.
The global join of Algorithm 1 is therefore mathematically defined as :
Definition 3.2 Global join. Let X and Y be two affine sets in M(n + 1, p) × M(m, p), which have in common k independent affine relations:
for all i ∈ [1, k], xi = Ri(xi+1,..., xp, ε1,..., εn). We define Z = X HG Y by
Z>k = X>k HC Y>k and for all i ∈ k,..., 1, Zi = Ri(Zi+1,..., Zp, ε1,..., εn).
Note that in Definition 3.2, the operations are ordered: first computation of Z>k, then reconstruction of Zk to Z1. Due to the row-echelon reduction and the reconstruction, the worst-case time complexity of this global join is O(n3 + n2p),

whereas the component-wise join’s complexity is only O(np). However, we introduce less new noise symbols and we are more precise, so this new join operation may speed up fixpoint computations as shown in Section 4.
Proposition 3.3 now proves the correctness of Algorithm 1, as well as optimality in some cases (in particular, when k = p — 1, because of the optimality of the uni-dimensional join in the generic case) :
Proposition 3.3 Z = X HG Y is an upper bound of X and Y , and if Z>k is a minimal upper bound of X>k and Y>k, then Z is a minimal upper bound of X and Y .
A lemma (needed to prove Proposition 3.3) states that relations of Equation 2 are compatible with the functional order. This property shows the necessity to preserve affine input/output relations.
Lemma 3.4 Let X = (CX,PX ) and Y = (CY ,PY ) be two affine sets such that:
X ≤ Y ,
Y satisﬁes the k relations of Equation 2
Then X satisﬁes these k relations.
This join operator is indirectly linked to Karr’s algorithm [14,16], as it com- putes and preserves affine equalities that Karr’s algorithm would infer if applied functionally, that is equalities between variables and inputs (our noise symbols).
Experiments
The APRON [17] library implements different abstract domains, including the affine sets (Taylor1+ domain). We implemented this new join operator in the Taylor1+ abstract domain. We present some results on programs analyzed with Interproc, a static analyzer which allows us to select any APRON abstract domain. First, we focus on comparisons of results of join operators with Taylor1+ using the standard (component-wise) and the global joins. We then show the relative performance of all classical domains and our domains on an example with different discretization steps. We refer to [7,8] for examples which really aim at demonstrating the performance of zonotopic abstract domains in general.
We consider three examples (Fig 5) that illustrate some constructions commonly found in classical programs. Loop counter (Fig 2) is a program in which the value of a variable x depends indirectly on the value of the loop counter. With the global join operator, we infer that x — i = 2 + 2ε1 and the analysis reaches a fix-point without the help of a widening operator. With the classical join operator, the analysis cannot terminate without widening, and terminates with the disappointing x ∈ [0, ∞]. If branches (Fig 3) show what may happen when we join the two branches of an conditional structure that encodes a computation on variables x and y, depending on the current mode (m, considered as a value 0 or 1) of the program. In this example, the difference is more subtle since the results of both join operations

have the same interval concretization. However, the global join is better since it introduces only one new noise symbol instead of three. Linear recurrence (Fig 4) computes a sequence of couples that converges to (14, 14). Without the global join, the static analysis with zonotopic abstract domain cannot find out this limit.



1	float x=[0,4];
2	int i=0;
3	while (i ≤ 5) {
4	i++;
5	x++;}

Fig. 2. Loop counter
1	float x=[0,4];
2	float y=[0,4];
3	bool m = brandom();
4	if (m) {
5	x++; y++;
6	m= not(m);}
7	else {
8	x——; y——;
9	m= not(m);}



1	float x=12;
2	float x1=12;
3	float y=16;
4	float y1=16;
5	while (true) {
6	x=x1;
7	y=y1;
Fig. 3. If branches

8	x1=3∗x/4 + y/4;
9	y1=x/4 + 3∗ y/4;}

Fig. 4. Linear recurrence

Fig. 5. Comparison between standard join and global join


1 float f(float x) {
2	return 2∗x—3; }
4 float g(float x) {
5	return —x+5; }
7 int main() {
8	int i; 
9	float x,y,z, t , u,v;
10	y = f(0); z = g(0);
11	u = f(.75) ; v = g(.25);
12	for (i=1; i<=N; i++) {
13	x=[0,((float)i)/N];
14	y=f(x); z=g(x);
15	u=f(v); v=g(u)/2; }
16	t=y+2∗z;
17	return 0; }


Fig. 6. Program to compare abstract domains of APRON

Finally, we consider a function to challenge the performance and the precision of the APRON abstract domains (Fig. 6). We iterate this function by a Kleene iteration, without widening. The final value does not depend on the parameter N ; increasing N only increases the number of join operations performed. We compared four abstract domains of APRON (boxes, octagons, convex polyhedra, Taylor1+)



180
160
140
120
100
80
60
40
20
0


0	10000	20000	30000	40000	50000	60000






Octagons  Polyhedra  Taylor1+  Taylor1+gj  Box

Value of parameter N

Fig. 7. Comparison of different abstract domains

to the domain Taylor1+ with global join (Taylor1+gj). Taylor1+ with global join provides an analysis slightly faster than classical Taylor1+, and up to 40 percent faster than polyhedra, and even 74 percent faster than octagons (Figure 7). The global join operator on Taylor1+ allows to prove the exact invariant t = 7, that only polyhedra find as well. Boxes find t ∈ [5, 9], octagons t ∈ [5.5, 8.5], Taylor1+ with standard join t ∈ [5, 9].
Conclusion
In this paper, we have proposed a new join operator of zonotopic abstract domains. This addresses the main drawback of the domain, which apart from the join oper- ator, was known for providing precise and fast analyses. This join operator stays in the line of a functional (input/output) analysis, by discovering and preserving some common affine relations holding between program variables and inputs of the program. It also allows to discover some useful properties, that for instance link the current program variables values to loops counters, or even make apparent some disjunctive information. We showed that while improving the accuracy compared to the previous join operation of [7], we still keep a very fast operation. We believe that this approach generalizes easily to the case of constrained affine sets, as intro- duced in [8]. Future work includes the case of inexact common affine relations, for instance to handle the case when they approximate non-linear relations.

References
Rob Beezer. A First Course in Linear Algebra. available at http://linear.ups.edu/online.html, 2006.
J. L. D. Comba and J. Stolfi. Affine arithmetic and its applications to computer graphics. Proceedings of SIBGRAPI, 1993.
P. Cousot, R. Cousot, J. Feret, L. Mauborgne, A. Min´e, D. Monniaux, and X. Rival. The ASTRE´E static analyzer. In ESOP’05, pages 21–30, 2005.


P. Cousot and N. Halbwachs. Automatic discovery of linear restraints among variables of a program. In POPL’78, pages 84–96. ACM Press, 1978.
D. Delmas, E. Goubault, S. Putot, J. Souyris, K. Tekkal, and F. V´edrine. Towards an industrial use of FLUCTUAT on safety-critical avionics software. In FMICS’09, LNCS 5825, pages 53–69. Springer- Verlag, 2009.
G. Frehse, C. Le Guernic, A. Donz´e, S. Cotton, R. Ray, O. Lebeltel, R. Ripado, A. Girard, T. Dang, and O. Maler. Spaceex: Scalable verification of hybrid systems. In CAV’11, LNCS. Springer, 2011.
K. Ghorbal, E. Goubault, and S. Putot. The zonotope abstract domain Taylor1+. In CAV’09, LNCS 5643, pages 627–633. Springer-Verlag, 2009.
K. Ghorbal, E. Goubault, and S. Putot. A logical product approach to zonotope intersection. In
CAV’10, LNCS 6174, pages 212–226, 2010.
A. Girard. Reachability of uncertain linear systems using zonotopes. In HSCC’05, LNCS 3414, pages 291–305. Springer-Verlag, 2005.
E. Goubault and S. Putot. Perturbed affine arithmetic for invariant computation in numerical program analysis. CoRR, abs/0807.2961, available at http://arxiv.org/abs/0807.2961, 2008.
E. Goubault and S. Putot. A zonotopic framework for functional abstractions. CoRR, abs/0910.1763, available at http://arxiv.org/abs/0910.1763, 2009.
Eric Goubault and Sylvie Putot. Static analysis of finite precision computations. In VMCAI’11, LNCS 6530, pages 232–247, 2011.
Leonidas J. Guibas, An Nguyen, and Li Zhang. Zonotopes as bounding volumes. In Proceedings of 14 t h Annual ACM-SIAM Symposium on Discrete Algorithms, 2003.
Michael Karr. Affine relationships among variables of a program. Acta Inf., 6:133–151, 1976.
A. Min´e. A new numerical abstract domain based on difference-bound matrices. In Proceedings of the Second Symposium on Programs as Data Objects, LNCS 2053, pages 155–172. Springer-Verlag, 2001.
Markus Mu¨ller-Olm and Helmut Seidl. A note on Karr’s algorithm. In ICALP, volume 3142 of Lecture Notes in Computer Science, pages 1016–1028, 2004.
APRON Project. Numerical abstract domain library, 2007. http://apron.cri.ensmp.fr.
S. Sankaranarayanan, H. B. Sipma, and Z. Manna. Scalable analysis of linear systems using mathematical programming. In VMCAI’05, LNCS 3385, pages 25–41, 2005.
