	Electronic Notes in Theoretical Computer Science 171 (2007) 117–137	
www.elsevier.com/locate/entcs

Timed Concurrent Constraint Programming for Analysing Biological Systems
Julian Guti´erreza, Jorge A. P´ereza, Camilo Ruedaa and Frank D. Valenciab
a Department of Science and Engineering of Computing Pontificia Universidad Javeriana, Cali, Colombia
b CNRS and LIX, E´cole Polytechnique, Palaiseau, France

Abstract
In this paper we present our first approach to model and verify biological systems using ntcc, a concurrent constraint process calculus. We argue that the partial information constructs in ntcc can provide a suitable language for such systems. We also illustrate how ntcc may provide a unified framework for the analysis of biological systems, as they can be described, simulated and verified using the elements provided by the calculus.
Keywords: Process Calculi, Verification of Biological Systems, Partial Information, Concurrent Constraint Programming (CCP)

Introduction
Partial information arises naturally in the description of biological systems. It is possible to distinguish two main kinds of partial information when modeling those systems: quantitative and behavioral. While partial quantitative information usually involves incomplete information on the state of the system (e.g., the set of possible values that a variable can take), partial behavioral information refers to the uncertainty associated to behavior of interactions (e.g., the unknown relative speeds on which two systems interact). Finding precise ways of expressing these kinds of partial information can help to better understand complex pattern behaviors, frequent in biological systems.
Partial information is a central feature of Concurrent Constraint Programming (CCP) [19], a well-established formalism for concurrency. In CCP, processes interact with each other by telling and asking partial information represented as constraints (e.g., x < 42). Perhaps the most appealing and distinctive feature of CCP is that it combines the traditional operational view of process calculi with a declarative one

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.05.012

based upon logic. In other words, the process terms can be viewed at the same time as computing agents and logic formulas. This combination allows CCP to benefit from the large body of techniques of both process calculi and logic. For these reasons CCP can be a convenient framework to describe and reason about biological systems.
In this paper we propose ntcc [14], a timed process calculus based on CCP, as a suitable language for analyzing biological systems. In ntcc the above-mentioned kinds of partial information are naturally captured. On the one hand, partial quant- itative information is captured by the notion of constraint system, a structure that gives coherence and defines (logic) inference capabilities over constraints. Since constraint systems are parametric to ntcc, by choosing the appropriate constraint system(s) several kinds of conditions, at different levels of detail, can be stated. This could be particularly useful in the description of quantitative information. For instance, one could think of a constraint system over differential equations inter- acting with others over, say, integers or real intervals. On the other hand, partial behavioral information is represented by non-deterministic and asynchronous op- erators available in ntcc. The interplay of these operators in the discrete time of ntcc allows to explicitly describe and reason about the uncertainty in the time occurrence of many biological phenomena.
Furthermore, ntcc provides reasoning techniques to prove that a given process P satisfy a given property F . In fact, the calculus offers a linear-temporal specific- ation logic and its corresponding proof system in which reachability analysis can be formally carried out. Reachability analysis is central in the biological context. Consider, for instance, bacterial transcription: it can be seen as a reachability ana- lysis problem in which one wants to know if there is a gene expression possible in a given gene regulatory network.
We shall take advantage of these features by modeling biological systems as processes and their properties as linear-temporal formulas, all in a single framework. That is, ntcc provides a description language for biological systems that is tightly related to powerful reasoning techniques. An additional advantage of using ntcc for the study of biological systems consists in the possibilities of turning this theoretical framework into software tools. As a matter of fact, the AVISPA Research Group 1 (of which the authors are members) has recently built a prototype tool [2, 3] that admits the description of biological systems expressed as ntcc processes and allows to observe their behavior over time.
The main contribution of this paper is presenting ntcc as a uniﬁed framework for the study of biological systems involving partial information and showing how its constructs naturally capture many biological phenomena. More specifically, we propose the use of constraint systems to represent partial quantitative information and the modeling of partial behavioral information as non-deterministic and asyn- chronous ntcc processes. We take the Sodium-Potassium pump [20], a mechanism that influence active transport in eukaryote cells, as a compelling example of the applicability of our approach. In fact, we will use the inference system to give a

1 URL: http://avispa.puj.edu.co

proof of the occurrence of a general malfunction of the pump in the presence of an unpredictable, malicious agent.

Related Work
The use of certain process calculi, such as the π-calculus [17, 18], BioAmbients [16], the Brane calculus [7], Beta binders [15] and the κ-calculus [8], as description languages for Biology has been studied in recent years. This “language approach” for the analysis of biological systems however, has payed little attention to reasoning techniques based on linear-temporal logic such as those available in ntcc. Other constraint-based calculi have been studied in the biological context. For instance, in [5, 10, 4], the hcc calculus [11] is used to study dynamic systems. However, since hcc does not provide non-deterministic/asynchronous operators, representing partial behavioral information turns out to be difficult. Only in one of such works ( [5]), the logic nature of hcc is exploited, using a model-checking approach for qualitative validation of biological systems. No proof system or similar procedures are used, though. Other works involving the use of logic in the biological context are [1] and [6]. On the one hand, [1] proposes the use of hybrid automata to model and analyze the behavior of biological systems. Supporting tools such as Simpathica [13], allow to query such models using a temporal logic language. On the other hand, in [6] a rule-based language for describing biological systems is proposed. Reasoning techniques include three independent semantic structures (each one with associated logics), which are used depending on the desired level of detail. We believe that by the appropriate use of constraint systems in the description of systems, analysis at several levels of detail are possible, preserving the same uniﬁed framework.

Structure of this document
The ntcc process calculus is described next: the intuitions given above, re- garding the use of ntcc for the modeling and verification of biological systems, are thoroughly explained. Section 3 summarizes the main results concerning specifica- tion and verification for ntcc processes. They will be used in Section 4 where the Sodium-Potassium pump is presented. In that section, we propose an ntcc model of such a system as well as verify a non-trivial property of this model, using the above-mentioned inference system. Section 5 concludes.
ntcc as a Calculus for Describing Biological Systems
In this section we present the ntcc process calculus and, by means of examples, show how it can be an appropriate language for modeling biological phenomena. For the sake of space, some formal details are elided from this presentation; an in-depth description of ntcc is given in [14].
Let us start with an intuitive description of reactive computation in ntcc. In ntcc, time is conceptually divided into discrete intervals (or time units). In a particular time unit, a process P gets an input (an item of information represented as a constraint ) c from the environment, it executes with this input as the initial

store, and when it reaches its resting point, it outputs the resulting store d to the environment. The resting point determines a residual process Q, which is then executed in the next time unit. Information is not automatically transferred from one time unit to the following.
In CCP, a fundamental notion is that of a constraint system. Intuitively, a con- straint system provides a signature from which constraints can be constructed, and an entailment relation which specifies the inter-dependencies among them. More formally, a constraint system is a pair (Σ, Δ) where Σ is a signature of function and predicate symbols, and Δ is a decidable theory over Σ. Given a constraint sys- tem (Σ, Δ), let (Σ, V, S) be its underlying first-order language, where V is a set of variables x, y,.. ., and S is the set of logic symbols ¬, ∧, ∨, ⇒, ∃, ∀, true and false. Constraints c, d,... are formulas over this first-order language. We say that c entails d in Δ, written c |= d, iff c ⇒ d is true in all models of Δ. For operational reasons, we shall require |= to be decidable. Henceforth, C denotes the set of constraints in the underlying constraint system.
A widely known constraint system is FD [12]. In FD variables are assumed to range over finite domains and, in addition to equality, we may have predicates that restrict the possible values of a variable to some finite set. More formally, FD[n] (n > 0) is the constraint system where Σ is given by the constant symbols 0,... ,n − 1 as well as by the equality =, and Δ is given by the axioms of equational theory x = x, x = y ⇒ y = x, x = y ∧ y = z ⇒ x = z, and v = w ⇒ false for each two different constants v, w ∈ Σ. Intuitively FD[n] provides a theory of variables ranging over a finite domain of values {0,... ,n − 1} with syntactic equality over these values.

Process Syntax
Processes P , Q, ... ∈ Proc are built from constraints c ∈ C and variables x ∈ V in the underlying constraint system by:

P, Q,... ::= tell(c)	|	when ci do Pi | P  Q | local x in P
i∈I
|	next (P ) | unless c next P  |  P	| ! P

Below we provide some intuitions regarding the behavior of ntcc processes.

Including and Querying (Partial) Information
Process tell(c), the simplest operation to express partial information, includes a constraint c into the current store, thus making it available to other processes in the same time interval.
In the biological context, tell operations allow to represent at least two kinds of partial information statements: so-called ground rules and state deﬁnition state- ments. The first ones precisely state certain conditions that apply during the life of the biological system. A clear advantage here w.r.t. other calculi for biology is that

these conditions can be expressed by exploiting the available (possibly incomplete) knowledge.
Example 2.1 Let process M = tell(l < pHin < u) represent a rule establishing the acceptable levels of internal pH for some system. It establishes that such a level must fall into some real interval (here given by variables l and u) during the whole experiment or simulation; the exact value of pHin in each time unit could be unknown.
Remarkably, the declarative flavor in this kind of statements could favor the definition of essential properties in (biological) models. Complementary to ground rules, state deﬁnition statements refers to those constraints intended to define the exact values for the variables in the system. This is particularly useful when one exactly knows the set of possible states for the system at a given time; series of such statements (for different time units) thus constitute a detailed view of the behavior of the system. In the context of Example 2.1, M ' = tell(pHin = f (pHold, k)) is a process defining the value for the variable pHin in the current time unit. It associates such a value with a function f applied to a variable and a constant k.
Guarded operations of the form when c do P are complementary to tell opera- tions and constitute the basic means for querying (or asking ) information about the state of a system. Intuitively, a when c do P process queries the current constraint store: if the guard c is present in such a store then the execution of P is enabled. The “presence” of c depends on the inference capabilities associated with the store. That is, a particular constraint could not be explicitly present in the store, but it could be inferred from the available information.
From this description, it is straightforward to interpret when operations as a way of formally expressing the required preconditions for establishing a particu- lar state of the system. The behavior of the system can be precisely stated in this way. Returning to Example 2.1, one could express that when the level of pH reaches a threshold, then the interval for valid values for pHin should reduce, i.e., when pHin > l ∗ 2 do tell(u = u − k1).
Non-deterministic Choices
Non-determinism is a valuable way of representing several possible courses of ac- tion from the same initial state without providing any information on how one of such courses is selected. In ntcc, non-deterministic behavior is obtained by generalizing processes of the form when c do P : a guarded-choice summation i∈I when ci do Pi, where I is a finite set of indexes, represents a process that, in the current time interval, must non-deterministically choose one of the Pj (j ∈ I) whose corresponding constraint cj is entailed by the store. The chosen altern- ative, if any, precludes the others. If no choice is possible then the summation is precluded. We use	P as an abbreviation for the “blind-choice” process i∈I when true do Pi. We use skip as an abbreviation of the empty summation
and “+” for binary summations.
In the biological context, the combination of guarded choices and partial inform-

ation represents an appropriate mechanism to formalize the inherent unpredictability in system interactions. In this sense, non-determinism is one way of explicitly rep- resenting partial behavioral information. The following example illustrates these ideas.
Example 2.2 Process P below is an abstract model of a biological system: in the presence of a certain amount of ATP (i.e., energy) the system releases an enzyme; in the case some ATP is present and the conditions of some electrochemical gradient are appropriate, it emits a positive signal:
when ATP > 0 do tell(releaseEnzyme = 1)
P =	+
when ATP > 0 ∧ elecGradient = 1 do tell(emitSignal = 1).

The evolution of P depends on the information in the current store. The simplest case is with the (empty) store true: P cannot add any further information. In the store d = (ATP ≥ 50), P causes the store to become d ∧ (releaseEnzyme = 1) since in the first alternative it holds that (ATP ≥ 50) |= (ATP > 0) and the guard of the second alternative does not entail from d. The interesting case is when both guards in P are enabled; as in the store e = (ATP > 0) ∧ (elecGradient = 1). Depending on which process is chosen for execution, the final store could be either e ∧ (releaseEnzyme = 1) or e ∧ (emitSignal = 1). Based on partial information, P constitutes a succinct representation of an unpredictable behavior.
Communication
Process P  Q represents the parallel composition of P and Q. In one time unit P and Q operate concurrently, “communicating” via the common store by adding and querying information. We use  i∈I Pi, where I is a finite set of indexes, to denote the parallel composition of all Pi.
Example 2.3 Assume process P as in the Example 2.2 and the following process
Q:
when releaseEnzyme = 1 do tell(promoteReaction = 1)
Q =	+
when emitSignal = 1 do tell(promoteReaction = 0).
Informally, Q promotes a reaction to occur once the presence of an enzyme has been detected and opposes to such a reaction if a particular signaling process has been activated. The parallel composition P   Q in the store e = (ATP > 0) ∧ (elecGradient = 1) behaves as follows. Since the choice in P guarantees the presence of either releaseEnzime = 1 or emitSignal = 1, process P  Q would cause the store to become either e ∧ (releaseEnzyme = 1) ∧ (promoteReaction = 1) or e ∧ (emitSignal = 1) ∧ (promoteReaction = 0).

Local Information
In ntcc, as in most process calculi, there is a construct that restricts the interface through which a process can interact with each other, thus allowing for the modeling of local behavior. Processes of the form local x in P behave like P , except that all the information on x produced by P can only be seen by P and the information on x produced by other processes cannot be seen by P .
In addition to the conventional spirit of this kind of operators, in the context of partial information, local information may represent a valuable help in the analysis of systems. When performing overall analyzes of complex systems, local variables may help to “hide” the behavior of such components that are irrelevant in the interactions to be analyzed.
Example 2.4 Consider a complex system (e.g., a cell) represented by a process
C. Assume that the definition of C involves a set of variables X = {x1, x2,... , xn} which represent some features of interest. In this way, in a “standalone” analysis of C, variables in X would give a comprehensive view of its behavior over time.
Assume now that we are interested in a process T consisting in the interaction of a large number of identical cells, i.e., T = C1  ...  Cm. In this case, as the focus of the analysis has moved from a local level (a single cell) to a global one (a tissue), it is necessary to abstract from the behavior induced by those variables in each Xi (associated with Ci) that do not participate in the interaction that
is being modeled. Let Xi ⊃ X∗ = {x∗, x∗,... , x∗ } be the set containing those
i	1	2	n
“irrelevant” variables 2 . Therefore, each cell Ci could be better represented as
Ci∗ = local x∗, x∗,... , x∗ in Ci 3 , and the process T ∗ = C1∗  ...  Cm∗ would
1	2	n
represent cells’ interaction.
Note that the internal structure of each cell remains unchanged by this hiding. Further, from an operational point of view, such a hiding is required to preserve the coherence in the values observed from P : an inconsistency may arise as each Ci can assign a different value to each xi.
From the example, it is possible to observe how the interplay of hiding and the notion of partial information may allow to analyze systems at different levels of detail.
Basic Timed Behavior
ntcc provides two basic time operators: next (P ) and unless c next (P ). Let us analyze them separately. next (P ) represents the activation of P in the next time interval. Hence, a move of next (P ) is a unit-delay of P . next (P ) can be also considered as the simplest way of expressing the dynamical behavior over time. This is fundamental in ntcc, since information is not automatically transferred from one time interval to the next. Building up on next (P ), it is easy to think

2 Note that X∗ should not contain the same variables that Xi since this would represent that every cell is isolated from each other.
3 Notation local x1,. .. , xn in P abbreviates the process local x1 in (local x2 in (.. . (local xn in P ) .. .)).

in more sophisticated delay constructs: we use nextn (P ) as an abbreviation for
next (next (... next (P )) .. .)), where next is repeated n times.
In the context of partial information, to be able of reasoning about absence of information is both important and necessary. Although sometimes it is possible to predict some of the possible future states for a system, usually there is a strong need of expressing unexpected behavior. In this kind of scenarios, processes of the form unless c next P may come in handy: P will be activated only if c cannot be inferred from the current store. The “unless” processes thus add (weak) time-outs to the calculus, i.e., they wait one time unit for a piece of information c to be present and if it is not, they trigger activity in the next time interval. To illustrate this consider the example below.
Example 2.5 Process R = when a do P1 +when b do P2 +when c do P3 models the prediction of three possible evolutions for a system (i.e., P1, P2 and P3). Notice that since they might be just a small part of a complex behavior that is partially understood, a considerable amount of uncertainty has not been included. Defining a process R∗ = R  unless (a ∨ b ∨ c) next S would ensure that in the case of a stimuli different from a, b or c occurs, a consistent default state in the system (here represented by S) will be preserved.
Definitions following this style of modeling not only allow more complete models but also permit to exploit the advantages of counting with partial information in a safe manner.
Asynchrony
The operator allows to express asynchronous behavior through the time intervals. Process P represents an arbitrary long but finite delay for the activation of P . For example, the process D = tell(enzymeReleased = 1) could represent the eventual presence of a particular enzyme in the environment, but without providing an upper bound on when such a thing will actually occur.
This kind of asynchronous behavior therefore constitutes another instance of partial behavioral information: in addition to the partial information on the vari- ables that are part of the state of the system (and that is expressed by the operators discussed above), the operator allows to express partial information on the time units where processes are executed. This is particularly interesting when describ- ing (biological) processes that interact at unknown relative speeds. For instance, a process D  S (with D defined as above) could represent a flexible representation of the interaction between a system S (which may require the presence of the enzyme) and the process which ensures the arrival of such an enzyme.
The partial information spirit of the asynchronous behavior in ntcc is strengthened by the following derived operator, expressing bounded eventuality :
 [n,m] P = nextn (P )+ nextn+1 (P )+ ··· + nextm−1 (P )+ nextm (P ).
This operator thus represents an additional amount of temporal (partial) inform-

ation, as it ensures that P will be activated at some point within the time units in the closed interval of naturals [n, m]. As in the original operator, there is no additional information of when this restricted eventuality will take place.

Persistent Behavior
Somehow opposed to the eventual behavior enforced by asynchronous behavior, persistent (or infinite) behavior serves to express conditions that are valid during every possible state of the system. The replication operator !P represents P  next (P )  next2(P )  .. ., i.e. unboundedly many copies of P but one at a time. As such, persistent behavior is an appropriate way of enforcing conditions stating ground rules of the systems of interest.
A process illustrating this kind of behavior is D' =! tell(enzymeReleased = 1), the persistent version of the enzyme-related signal. D' simply represents the fact that in every future time unit the constraint it involves will be available. Persist- ent behavior can also be understood as a mechanism that allows to move from static descriptions or conditions (valid only in one state of the system) to dynamic statements that are always valid.
As in the asynchronous case, it is possible to derive a bounded version of the persistent operator:
![n,m] P = nextn (P )  nextn+1 (P )  ···  nextm−1 (P )  nextm (P ).

This operator represents the fact that P is always active during all the time units in the interval [n, m]. As its eventual counterpart, this derived operator (known as bounded invariance) may come in handy when certain additional information regarding the (persistent) execution of P is available.

Operational Semantics
The intuitive behavior for ntcc processes described above is formalized by means of a structural operational semantics (SOS) that considers transitions between process- store conﬁgurations of the form ⟨P, c⟩ with stores represented as constraints. The transitions of the SOS are given by the relations −→ and =⇒. They are formally defined in Appendix A. Intuitively, the internal transition ⟨P, d⟩ −→ ⟨P ', d'⟩ should be read as “P with store d reduces, in one internal step, to P ' with store d' ”. The
(c,d)
observable transition P  ====⇒ R should be read as “P on input c, reduces in
one time unit to R and outputs d”. The observable transitions are obtained from terminating sequences of internal transitions.
Let us now consider an infinite sequence of observable transitions (or run)

P = P1
(s1,r1)
====⇒ P2
(s2,r2)
====⇒ P3
(s3,r3)
====⇒	This sequence can be interpreted as an

interaction between the system P and an environment. Ata time unit i, the envir- onment provides a stimulus si and Pi produces ri as a response. If α = s1.s2.s3 ... 

and α'
= r1.r2.r3 .. ., then the above interaction is represented as P
(α,α')
====⇒ ω.

Alternatively, if α = trueω, we can interpret the run as an interaction among the parallel components in P without the influence of an external environment (i.e., each component is part of the environment of the others). In this case α is called the empty input sequence and α' is regarded as a timed observation of such an interaction in P . We will say that the strongest postcondition of a process P , denoted sp(P ), denotes the set of all infinite sequences that P can possibly output.

More precisely, sp(P )= {α'
| for some α : P
(α,α')
====⇒
ω}.


Specification and Verification for ntcc Processes
In this section we summarize some results regarding to Linear Temporal Logic (LTL) associated to ntcc. This particular LTL expresses properties over sequences of con- straints and we shall refer to it as CLTL. A sound, partially complete proof system for this logic is also described. Further details of this logic (including decidability results) can be found in [14, 21].
The importance of the strong relationship between CLTL and ntcc is that a logic-based methodology for verification of properties of biological systems can be adopted, in addition to the observational approach that is induced by the op- erational semantics given above. That is, simulations of an ntcc process (i.e., its timed observations) could be complemented by proofs of essential properties (stated as temporal formulas).
We begin giving the syntax of LTL formulas and then interpret them with the CLTL semantics. The formulas F, G, ... ∈ F are built from constraints c ∈ C and variables x ∈V in the underlying constraint system by:
F, G,... := c | tr˙ue | fal˙ se | F ∧˙ G | F ∨˙ G | ¬˙ F | ∃˙ x F | ◦F |  F | ♦F

The constraint c (i.e., a first-order formula in the constraint system) represents a state formula. The dotted symbols represent the usual (temporal) Boolean and
existential operators. The dotted notation is needed as in CLTL these operators do not always coincide with those in the constraint system. The symbols ◦,  , and ♦
denote the LTL modalities next, always and eventually. We use F ⇒˙ G for ¬˙ F ∨˙ G.
Below we give the formulas a CLTL semantics. We first introduce some notation and the notion of x-variant. Intuitively, d is an x-variant of c iff they are the same except for the information about x. More formally, given a sequence α = c1.c2   ,
we use ∃xα to denote the sequence ∃xc1∃xc2 ... . We shall use α(i) to denote the
i − th element of α.
Definition 3.1 [x-variant] A constraint d is an x-variant of c iff ∃xc = ∃xd. Sim- ilarly α' is an x-variant of α iff ∃xα = ∃xα'.

Definition 3.2 [CLTL Semantics] We say that α satisfies (or that it is a model

of) F in CLTL , written α |=CLTL F , iff ⟨α, 1⟩ |=CLTL F , where:
⟨α, i⟩ |=CLTL tr˙ue	⟨α, i⟩ |=CLTL fal˙se
⟨α, i⟩ |=CLTL c	iff	α(i) |= c
⟨α, i⟩ |=CLTL ¬˙ F	iff	⟨α, i⟩ |=CLTL F
⟨α, i⟩ |=CLTL F ∧˙ G  iff	⟨α, i⟩ |=CLTL F and ⟨α, i⟩ |=CLTL G
⟨α, i⟩ |=CLTL F ∨˙ G  iff	⟨α, i⟩ |=CLTL F or ⟨α, i⟩ |=CLTL G
⟨α, i⟩ |=CLTL ◦F	iff	⟨α, i + 1⟩ |=CLTL F
⟨α, i⟩ |=CLTL  F	iff	for all j ≥ i ⟨α, j⟩ |=CLTL F
⟨α, i⟩ |=CLTL ♦F	iff	there is a j ≥ i such that ⟨α, j⟩ |=CLTL F
⟨α, i⟩ |=CLTL ∃˙ x F	iff	there is an x-variant α' of α such that ⟨α', i⟩ |=CLTL F.

Define [F ]]={α |α |=CLTL F }. F is CLTL valid iff [F ]] = Cω, and CLTL satisﬁable
iff [F ]] /= ∅.

Process Verification.
Intuitively, P |=CLTL F iff every sequence that P can possibly output, on inputs from arbitrary environments, satisfies F .
Definition 3.3 We say that a process P satisﬁes F , written P |=CLTL F , iff
sp(P ) ⊆ [[F ]].
Example 3.4 Assume R = tell(c) and F = ♦c. Then R |=CLTL F as in every se- quence output by R there must be an e entailing c. Also P = tell(c)+tell(d) |=CLTL c ∨ d and P |=CLTL c ∨˙ d as every e output by P entails either c or d. Notice, how- ever, that Q = tell(c ∨ d) |=CLTL c ∨ d but Q |=CLTL (c ∨˙ d) in general, since Q can output an e which certainly entails c ∨ d and still entails neither c nor d —take c = (x = 42),d = (x /= 42) and e = c ∨ d. Therefore, c ∨˙ d distinguishes P from Q.
In order to reason about statements of the form P |=CLTL F , ntcc is equipped with a proof (or inference) system for assertions of the form P ▶ F . The system is presented in Table 1. We say that P ▶ F iff the assertion P ▶ F has a proof in the system in Table 1. The assertion P ▶ F is intended to be the “counterpart” of P |= F in the sense that P ▶ F should approximate P |=CLTL F as closely as possible (ideally, they should be equivalent). The following proposition from [14] states the correspondence between |= and ▶. We say that a process P is locally independent iff the guards of every non-unary sum in P contains no local variables.
Proposition 3.5 (Soundness) If P ▶ F then P |= F. Furthermore, (Complete- ness) if P is locally-independent and P |= F then P ▶ F.
Hence the proof system is sound, and also complete for locally independent processes —which represent a substantial family of ntcc processes. It is worth noticing that our compelling example is in fact locally independent. Finally, the following lemma will be useful in derivations (see [14] for further details):
Lemma 3.6 For every process P,

1. P ▶ tr˙ue,	2. P /▶ fal˙se,	3.	P ▶ A
P ▶ A	P ▶ B
and	4.	P ▶ A ∧˙ B	.



Table 1
A proof system for (linear-temporal) properties of ntcc processes

Analysing a Biological System in ntcc
In this section we show the use of our approach to model and verify biological systems using the Sodium-Potassium pump as case study. We first give a short biological description of the system and propose an ntcc model representing its behavior. Later, we verify a non-trivial property over this model using the ntcc reasoning techniques.

Biological Description
An ion pump is a natural channel connecting the two sides of a membrane. The function of these pumps is to move ions across the membrane in a process called transport. Depending on the source of the required energy, the transport can be either passive or active. In passive transport ions freely move across the membrane following an electrochemical gradient. As ions move in the direction of the gradient then the cell does not need to provide energy for the transport. Since in active transport ions move against the direction of the gradient, the cell has to supply energy (usually in form of ATP) to accomplish this movement.
In particular, the Sodium-Potassium pump [20] (SP-pump in the sequel) is a system for active transport of ions in animal eukaryotic cells. It exchanges Sodium ions inside the cell with Potassium ions outside of it. The pump is composed of two proteins known as the alpha and beta subunits. The purpose of the pump is to keep the concentration of sodium inside the cell lower than outside. This difference of concentrations generates an electrochemical gradient that leads the passive transport of Sodium ions towards the cytoplasm in the cell. If the pump does not work well then the gradient becomes weak for transport, thus affecting the entrance of required substances into the cell.
The pumping process in the SP-pump can be divided in six phases. At the beginning there is a pump conformation with high affinity for Sodium ions inside the cell (1). This conformation encourages the binding of three Sodium ions with the pump. Then the alpha subunit is phosphorylated by ATP hydrolysis (2), leaving a residual ADP molecule in the cytoplasm. This chemical reaction provides the

needed energy for the pumping process. Once this occurs, the pump conformation changes and then the Sodium ions can leave the cell (3).
At this point, there is a pump conformation with high affinity for Potassium ions outside the cell (4). This results in the binding of two Potassium ions with the pump. Hence, the alpha subunit is dephosphorylated (5) and the pump con- formation returns to the initial state. At this moment Potassium ions can enter the cell (6). The pumping process is always performed regulating the concentration of Sodium in the cell.
In parallel to this active transport movement, there is a passive transport move- ment that allows Potassium and Sodium ions to move against the direction of the active transport. This complementary movement is induced by an electrochemical gradient present in the cell.

An ntcc model of the SP-pump
Here we propose an ntcc model of the SP-pump. We use non-deterministic and asynchronous behavior for modeling partial behavioral information regarding tem- poral responses of certain components. Before entering into the detailed description of the model let us informally describe two encodings for recursive functions and mutable entities that will allow for cleaner model descriptions. A detailed account of their definition can be found in [14].
Recursive Deﬁnitions It is possible to encode recursive definitions of the form q(x) d=ef Pq ; where q is the process name and Pq calls q only once and such a call must be within the scope of a “next”. Moreover, we can rely on the usual intuitions concerning procedure calls in a programming language.
Cells Using the basic ntcc syntax it is possible to provide cells,a basis for the specification and analysis of mutable and persistent data structures. A cell can be thought of as a structure that contains a value, and if tested, it yields this value. A cell keeps its value over the time units until it is modified. We use notations x : v and x := v to represent the initialization and the assignment of a cell x with value v, respectively. Also, we shall use notation x := x + z as an abbreviation of the assignment x := x' + z, where x' is the value of the cell x in the previous time unit and z is a fixed value. The operation x := x − z can be encoded analogously.
We now enter to describe the ntcc model representing the SP-pump, which is presented in Figures 1 and 2. Let us first describe the main principles underlying its modeling. The model assumes a constraint system over finite domains of integers, considering three places for interaction: inside and outside the cell, and an inter- mediate place where ions stay before entering or flowing out of the cell (i.e., the pump). The model involves a series of persistent variables (modeled as cells) that store useful quantities about the pumping process. Output and input operations of the pump are then modeled as modifications over variables representing the number of ions both inside and outside the cell. In particular, variables N aO, N aI, KO and KI represent the amount of Sodium and Potassium ions placed outside and inside the cell, respectively. In addition, a certain amount of each kind of ion needed

for the correct functioning of the cell is assumed. Such amounts are denoted by N aIDEAL and KIDEAL. Finally, the model includes additional variables capturing other details of the pump: OPump represents the orientation of the pump (either inside or outside the cell), Alpha denotes the current binding of the alpha subunit and P ump represents the current content of the pump. These three variables will be instantiated with constants that can be encoded by integers: for instance, pos- sible values for Alpha are P, free and null (note the special font style given to constants). Finally, integer variables AT P and ADP represent the presence of ATP and ADP inside the cell, respectively.
The model in Figures 1 and 2 reflect the complementary nature of active and passive transport in the SP-pump, represented as ActiveT rans and PassiveTrans processes, which are integrated as the NaKPump process. From this process it is then possible to assume some environment in which the pump is placed. This is the intuition behind process System. We now proceed to explain in a greater detail the ideas behind these processes.


Active Transport Phases
Process ActiveT rans integrates sub-processes for the six phases described before; these processes invoke each other. Some processes (i.e., NaPhase1, NaPhase2 and KPhase1) include possible recursive calls to themselves. This intends to represent the possibility that the system remains stuck in certain phases in spite of all the conditions needed to evolve are given. That is, we are trying to model “reversible” phases, a behavior that is represented by non-deterministic choices. As a result, those phases could be executed several times therefore delaying system execution in at least one time unit. Such a delay occurs because the system waits for the presence of some substances at a specific place of the pump. In fact, those substances could be available but not in the required place. This non-deterministic and asynchronous behavior could represent other conditions on component binding, such as an appro- priate physical contact among elements that (chemically) react with components of the pump. Similarly, non-deterministic behavior can also represent some kind of malfunction. For instance, it is possible that in phase NaPhase2 the phosphate could not bind to the alpha subunit, which would result in a malfunction of the system that could be directly observed from the evolution of the pump in time.


Passive Transport Phases
Process PassiveTrans defines two sub-processes: one for the entrance of Sodium ions and another for the output of Potassium ions. It is worth noticing that in the modeling of these sub-processes we are considering partial behavioral information on the actual time when the ion movement really occurs, which is represented by a bounded asynchronous operator.

NaP hase1 d=ef when (NaI > NaIDEAL ∨ KI < KIDEAL) ∧ P ump = Empty ∧ OP ump = In do
(next (NaI := NaI − 3  P ump := Na  tell(unchangedK = 1)  NaP hase2) +
next (NaP hase1  tell(unchangedK = 1)  tell(unchangedNa = 1)))
NaP hase2 d=ef when P ump = Na ∧ Alpha = free ∧ AT P > 0 do
(next (OP ump := Out  Alpha := P  ADP := 1 
tell(unchangedK = 1)  tell(unchangedNa = 1)  NaP hase3)
+ next (NaP hase2  tell(unchangedK = 1)  tell(unchangedNa = 1)))
NaP hase3 d=ef when P ump = Na ∧ OP ump = Out do
next (NaO := NaO +3  P ump := Empty  tell(unchangedK = 1)  KP hase1)
KP hase1 d=ef when P ump = Empty ∧ OP ump = Out do
(next (P ump := K  KO := KO − 2  tell(unchangedNa = 1)  KP hase2) +
next (KP hase1  tell(unchangedK = 1)  tell(unchangedNa = 1)))
KP hase2 d=ef when Alpha = P ∧ P ump = K do
next (OP ump := In  ADP := 0  Alpha := free 
tell(unchangedK = 1)  tell(unchangedNa = 1)  KP hase3)
KP hase3 d=ef when P ump = K ∧ OP ump = In do
next (KI := KI +2  P ump := Empty  tell(unchangedNa = 1)  NaP hase1)
def
ActiveT rans = NaP hase1
Figure 1. An ntcc model for the Sodium-Potassium pump (Part 1 of 2)




Additional Processes
The integration of the above processes as the NakPump process is straightforward. There is an additional process (i.e., Control) which governs the global behavior of the pump w.r.t. the equilibrium of the ions amounts; in the case an equilibrium on the amount of one of the ions is reached, a general system malfunction (denoted as death = 1) is established. As the other processes, the structure of this control process makes it possible the inclusion of additional features. Process Start, which receives a group of six parameters (denoted as σ1...6), is self-explanatory.
A remarkable feature of our model is that it can be parameterized with actual quantitative values extracted from experimentation. In our model ion concentra- tions depend on parameters which make it more accurate; more detailed models involving other biological components (such as, e.g., the electrochemical gradients governing the dynamics of the passive transport and the magnitude of forces re- lated with the physical contact between ions and the pump) would then require the inclusion of more sophisticated numerical parameters. In this sense, considering a constraint system over real numbers would not only allow to include more soph- isticated conditions but also would allow to perform analyzes at different levels of detail.

P assiveNa d=ef unless NaO = NaI next
(next5 (P assiveNa) 
٨[0,5] (unless unchangedNa =1 next (NaI := NaI +3  NaO := NaO − 3) 
when unchangedNa =1 do (NaI := NaI +3  NaO := NaO − 3)))
P assiveK = unless KO = KI next
(next5 (P assiveK) 
٨[0,5] (unless unchangedK =1 next (KI := KI − 2  KO := KO + 2) 
when unchangedK =1 do (KI := KI − 2  KO := KO + 2)))
P assiveT rans d=ef P assiveNa  P assiveK
Control d=ef ! (when NaI = NaO do tell(equilNa = 1) 
when KI = KO do tell(equilK = 1) 
when equilNa =1 ∨ equilK =1 ∨ M do !(tell(death = 1)))
Start(σ1...6) d=ef !(tell(AT P > 0)  tell(NaIDEAL = σ5)  tell(KIDEAL = σ6)) ADP :0  Alpha : free  OP ump : In  P ump : Empty 
NaI : σ1  NaO : σ2  KI : σ3  KO : σ4
NaKP ump d=ef local NaI ,NaO, KI , KO, Alpha, ADP, P ump, OP ump in
Start(σ1...6)  ActiveT rans  P assiveT rans  Control
def
System = NaKP ump  Environment

Figure 2. An ntcc model for the Sodium-Potassium pump (Part 2 of 2)
Proving Properties About Biological Models: A logic-based approach
In this section we give a non-trivial biological example of the reasoning capabilities of ntcc. In particular, the example deals with an inhibition process over the SP-pump. This inhibition may represent both a drug and a disease: to prevent circulatory problems, certain medicines induce a partial inhibition of the pump to augment the strength of heart’s contractions, thus improving blood circulation. On the other hand, certain substances may cause a complete inhibition process over the pump, therefore causing the death of the cell.
The inhibition process example also allows us to take advantage of the flexibility of the presented model. We will assume a (malicious) drug that is present in the environment surrounding the pump. The goal of this drug is to take control of the alpha subunit, thus preventing the phosphate from inducing a conformational change in the pump. In turn, this obstruction will lead to a complete inhibition of the active transport mechanism enforced by the pump. We express this in our model by specifying the Environment process as follows:


Environment  d=ef
Drug	(1)

where Drug  d=ef	when Alpha = free do  !Alpha := null (with n > m).
[m,n]
Note that the actual time unit where Drug will be active is undetermined, because of
the uncertainty induced by the  operator. It is important to remark that although

Drug is the only component explicitly described in the Environment process, other components or systems can be easily included in its definition. In other words, we are focusing on the drug-related part of Environment. We will also denote by Drug' the process obtained from the execution of Drug at a time m ≤ j ≤ n (i.e., Drug' d=ef !Alpha := null). 
By inhibiting the active transport capabilities of the pump, the cell will reach an equilibrium between the internal and external concentrations of Sodium. Such an equilibrium, that causes the death of the cell, is not reversible and will occur in an undetermined future. These facts suggest us the following assertion to be verified:
NaKPump  Drug ▶ ♦  death =1	(2)
where death = 1 represents the death of the cell. Intuitively, we want to form- ally verify that in the presence of the drug described above the cell will die in an undetermined future, with no chance of returning to a previous state.
The complete inhibition of the active transport mechanism can be seen directly on the model. At a certain stage of the process (just after NaPhase1), the alpha subunit will be empty, ready for a binding with some substance (P in the “healthy” case). The inclusion of Drug in the environment adds a new alternative of execu- tion, as both NaPhase2 and Drug have the chance of binding the subunit (with P and null, respectively). In this (implicit) non-deterministic choice, we assume the success of the drug in binding the alpha subunit. Note that this choice precludes the active transport processes from the execution of the system. Therefore, at that point, we can regard the system as the following processes:
Control  PassiveNa  Drug'  RestOf System'	(3)
where RestOf System' d=ef PassiveK  !(tell(AT P > 0)  tell(N aIDEAL = σ5) 
tell(KIDEAL = σ6)). As a result, assertion (2) can be expressed as
Control  PassiveNa  Drug'  RestOf System ▶ ♦ death = 1.	(4) In order to prove (4), we will restrict our attention to the interaction among
Control, PassiveNa and Drug'. Intuitively, due to the absence of the active trans-
port mechanism the passive transport will introduce sodium ions into the cell until reaching an equilibrium (i.e., N aI = N aO). Once that occurs, Control (that has been awaiting the equilibrium) emits equilN a = 1 to the environment. Such a signal is enough to determine the death of the cell.
The proof proceeds as follows. Let us first assume the following abbreviations for processes and guards:
G1 = (G2 ∨ G3 ∨ M )	G2 = (equilN a = 1)	G3 = (equilK = 1)
G4 = (N aI = N aO)	G5 = (KI = KO)	A d=ef when G1 do ! tell(death = 1)
B d=ef when G4 do tell(G2)	C d=ef when G5 do tell(G3)

Consequently, and because of the replicated definition of Control, we have


Control d=ef
! A	! B	! C.

The following proposition represents an intuition derived from the definition of
PassiveNa and Drug'.
Proposition 4.1 PassiveNa  Drug' ▶ ♦G4.
Once Drug' is present in the system and sets the state of Alpha to null for every future time unit, process ActiveT rans does not modify anymore neither N aI or N aO. As a consequence, process PassiveNa decrements N aO and increments NaI until they have the same value (i.e., N aI = N aO). This will take some time units, depending on the value of N aI and N aO when Drug' be active in the system. This behavior can also be verified applying the rules in the operational semantics of ntcc.
Finally, using the proof system in Table 1, it is possible to derive a proof for (4).

Let us first derive !(B  C) ▶  (G4 ⇒˙
G2) (Proposition 4.2):

B ▶ (G4
∧˙ G2) ∨˙ ¬˙ G4
LSUM
C ▶ (G5
∧˙ G3) ∨˙ ¬˙ G5
LSUM

B ▶ G4 ⇒˙ G2	LCONS

C ▶ G5 ⇒˙ G3		LCONS LPAR




With the above result, we can perform the following deductions. Let us first state an auxiliar derivation:


D =
p. 4.1
AR


We then get the following derivation


A ▶ (G1
∧˙  death = 1) ∨˙ ¬˙ G1
LSUM

  A ▶ G1 ⇒˙  death = 1 	LCONS
LREP
!A ▶  (G1 ⇒˙   death = 1)
LCONS
!A ▶  ((G2 ∨˙ G3 ∨˙ M) ⇒˙  death = 1)

LCONS
!A ▶  (G2 ⇒˙  death = 1)	D

LPAR LCONS


Finally, using item 3 in Lemma 1, we obtain
Control  PassiveNa  Drug'  RestOf System ▶ ♦  death =1 hence proving the desired property.

Notice how the partial information constructs helped to better describe the be- havior of the SP-pump. They allow for flexible and extensible system specifications. Moreover, since the associated temporal logic naturally captures the spirit of these constructs, the essential properties to be verified can also involve partial information in an explicit way.

Concluding Remarks
In this paper we have proposed ntcc, a process calculus based on constraints, as a suitable language for modeling and verifying biological systems. We have shown how process constructs in ntcc naturally capture two kinds of partial information: quantitative and behavioral. Descriptions of many biological phenomena that are only partially understood could greatly benefit from the use of these kinds of partial information provided by ntcc.
Furthermore, ntcc provides a single, uniﬁed framework where it is possible to both model and reason about biological systems. This approach was illustrated by modeling an ion transport mechanism and verifying one non-trivial property of such a model. While the use of partial behavioral information statements was crucial to describe and reason about a possible system failure, partial quantitative information statements provided flexibility in the modeling process.

References
M. Antoniotti, C. Piazza, A. Policriti, M. Simeoni, and B. Mishra. Taming the complexity of biochemical models through bisimulation and collapsing: theory and practice. Theor. Comput. Sci., 325(1):45–67, 2004.
A. Arbela´ez, J. Guti´errez, C. Olarte, and C. Rueda. A Generic Framework to Model, Simulate and Verify Genetic Regulatory Networks. In Proc. of 32nd Latin-American Conference on Informatics (CLEI 2006), 2006. Santiago, Chile.
AVISPA Research Group. ntccSim: A simulation tool for timed concurrent processes, 2006. Available at http://avispa.puj.edu.co .
A. Bockmayr and A. Courtois. Using hybrid concurrent constraint programming to model dynamic biological systems. In Peter J. Stuckey, editor, ICLP, volume 2401 of LNCS, pages 85–99. Springer, 2002.
A. Bockmayr, A. Courtois, D. Eveillard, and M. Vezain. Building and Analysing an Integrative Model of HIV-1 RNA Alternative Splicing. In Danos and Sch¨achter [9], pages 43–57.
L. Calzone, N. Chabrier-Rivier, F. Fages, and S. Soliman. Machine learning biochemical networks from temporal logic properties. Transactions on Computational Systems Biology, 2006. CMSB’05 Special Issue (to appear).
L. Cardelli. Brane Calculi. In Danos and Sch¨achter [9], pages 257–278.
V. Danos and C. Laneve. Formal molecular biology. Theor. Comput. Sci., 325(1):69–110, 2004.
V. Danos and V. Sch¨achter, editors. Computational Methods in Systems Biology, International Conference CMSB 2004, Paris, France, May 26-28, 2004, Revised Selected Papers, volume 3082 of LNCS. Springer, 2005.
D. Eveillard, D. Ropers, H. de Jong, C. Branlant, and A. Bockmayr. A multi-scale constraint programming model of alternative splicing regulation. Theor. Comput. Sci., 325(1):3–24, 2004.
V. Gupta, R. Jagadeesan, V. A. Saraswat, and D. G. Bobrow. Programming in hybrid constraint languages. In P. J. Antsaklis, W. Kohn, A. Nerode, and S. Sastry, editors, Hybrid Systems, volume 999 of LNCS, pages 226–251. Springer, 1994.


P. Van Hentenryck, V. Saraswat, and Y. Deville. Design, Implementation, and Evaluation of the Constraint Language cc(FD). In Constraint Programming, volume 910 of LNCS, pages 293–316. Springer, 1994.
B. Mishra, M. Antoniotti, S. Paxia, and N. Ugel. Simpathica: A Computational Systems Biology Tool within the Valis Bioinformatics Environment. In E. Eiles and A. Kriete, editors, Computational Systems Biology. Elsevier, 2005.
M. Nielsen, C. Palamidessi, and F. Valencia. Temporal Concurrent Constraint Programming: Denotation, Logic and Applications. Nordic Journal of Computing, 9:145–188, 2002.
C. Priami and P. Quaglia. Beta Binders for Biological Interactions. In Danos and Sch¨achter [9], pages 20–33.
A. Regev, E. M. Panina, W. Silverman, L. Cardelli, and E. Shapiro. Bioambients: an abstraction for biological compartments. Theor. Comput. Sci., 325(1):141–167, 2004.
A. Regev and E. Shapiro. Cells as Computation. Nature, 419:343, September 2002.
A. Regev and E. Shapiro. Modelling in Molecular Biology, chapter The π-calculus as an abstraction for biomolecular systems, pages 219–266. Natural Computing Series. Springer, 2004.
V. Saraswat, M. Rinard, and P. Panangaden. The semantic foundations of concurrent constraint programming. In POPL ’91, pages 333–352, Jan 1991.
G. Scheiner-Bobis. The sodium pump: Its molecular properties and mechanics of ion transport. Euro.
J. Biochem., 269:2424–2433, 2002.
F. Valencia. Decidability of Infinite-State Timed CCP Process and First-Order LTL. Theor. Comput. Sci., 330(3):577–607, 2005.

A	ntcc Operational Semantics

Table A.1
Rules for internal reduction −→ (upper part) and observable reduction =⇒ (lower part). γ−→ in OBS
holds iff for no γ', γ −→ γ'.

Note that ≡ (structural congruence) is the smallest congruence satisfying: (1)
P  skip ≡ P , (2) P  Q ≡ Q  P , and (3) P  (Q  R) ≡ (P  Q)  R.
In rule OBS, the process R to be executed in the next time interval is equivalent to F (Q), the “future” of Q.
Definition A.1 [Future Function] Let F : Proc - Proc be defined by
⎧⎪ skip		if Q = Σi∈I when ci do Qi F (Q)= 
(local x) F (R)	if Q = (local x, c) R
⎪⎩ R	if Q = next R or Q = unless c next R

Intuitively, F (Q) is obtained by removing from Q summations that did not trigger activity and any local information which has been stored in Q, and by “unfolding” the sub-terms within “next” and “unless” expressions. Notice that F does not need to be total since whenever we need to apply F to a Q (OBS in Table A.1), every tell(c), R and ! R in Q will occur within a “next” or “unless” expression.
