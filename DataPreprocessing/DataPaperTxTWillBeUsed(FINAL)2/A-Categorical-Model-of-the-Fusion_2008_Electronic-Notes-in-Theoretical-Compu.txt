

Electronic Notes in Theoretical Computer Science 218 (2008) 275–293
www.elsevier.com/locate/entcs

A Categorical Model of the Fusion Calculus
Marino Miculan
Department of Mathematics and Computer Science, University of Udine Via delle Scienze 206, I-33100 Udine, Italy. miculan@dimi.uniud.it


Abstract
We provide a categorical presentation of the Fusion calculus. First we give Working in a suitable category of presheaves, we describe the syntax as initial algebra of a signature endofunctor, and the semantics as coalgebras of a “behaviour” endofunctor. To this end, we first give a a new, congruence-free presentation of the Fusion calculus; then, the behaviour endofunctor is constructed by adding in a systematic way a notion of “state” to the intuitive endofunctor induced by the LTS. Coalgebras can be given a concrete presentation as “stateful indexed labelled transition systems”; the bisimilarity over these systems is a congruence, and corresponds to hyperequivalence. Then, we model the labelled transition system of Fusion by abstract categorical rules. As a consequence, we get a semantics for the Fusion calculus which is both compositional and fully abstract: two processes have the same semantics iff they are bisimilar, that is, hyperequivalent.
Keywords: Fusion calculus, presheaves, hyperequivalence, fully abstract categorical model

Introduction
In recent years, Parrow and Victor’s Fusion calculus [20] has emerged as a good foundational model for distributed computation paradigms like web-services and service oriented architectures (SOAs). Fusion calculus is often regarded as a variant of the π-calculus, but actually it has quite distinctive features; the most dramatic difference is that synchronisation does not yield a name substitution, but rather a fusion of names. Fused names have the same meaning and can be used inter- changeably. Several typical concepts of web services and SOAs can be represented via fusions, such as negotiation between client requests and server capabilities, for- warders for objects migrating among locations, etc. Many recent specific calculi for SOAs are directly inspired by the Fusion calculus, such as CC-pi and JoCaML [4,9]. In this paper, we provide a fully abstract categorical model of the (finite) Fusion calculus. More precisely, we describe the syntax of processes as the initial algebra of a suitable signature endofunctor, and the semantics as coalgebras of a suitable “be- haviour” endofunctor. These coalgebras can be concretely presented as a new kind of labelled transition systems, whose labels correspond to those of the Fusion cal- culus, but states are processes together with equivalences over names. Bisimilarity

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.10.017

over these systems corresponds precisely to hyperequivalence. In fact, following the bialgebraic approach of Plotkin and Turi [26], we obtain a semantics which is both compositional and fully abstract, that is, two processes have the same semantics iff they are bisimilar, and hence, hyperequivalent.
In order to achieve these results, we have to solve several technical problems. The first problem is that in the usual presentation of the Fusion calculus, pro-
cesses are taken up-to a structural congruence [20], containing the usual laws such as scope extrusion. This is problematic because this syntax cannot be defined as a free algebra of some functor, which is a requirement for the construction of the fully- abstract, compositional semantics [26]. We circumvent this obstacle by giving in Section 2 a new presentation of the Fusion calculus without structural congruence, and where processes are taken only up-to α-conversion of bound names.
The presence of α-equivalence is not a problem, because languages with binders can be described as free algebras in suitable categories of set-valued functors, that is presheaves. In particular, the category Set F of presheaves over F, the category of finite sets and functions, is commonly used for dealing with languages defined by signatures with binding constructors “a la λ-calculus”, and whose terms are taken up-to α-equivalence [7,14]. This is precisely the situation of the Fusion calculus, hence Set F is the right category where this syntax can be abstractly presented as the presheaf Proc which is the carrier of the initial algebra of a suitable endofunctor ΣF (Section 4.1). We recall the main properties and constructions of Set F in Section 3. Now, in order to define a (fully abstract) semantics for the Fusion calculus, we need to define an object of behaviours in the same category where the syntax lies (Set F, in our case). This object must be defined as the (carrier of the) final coalgebra νB of a suitable endofunctor B; in this way, the semantics is the unique morphism
from Proc to νB given by terminality of νB (and initiality of Proc) [26].
The “behaviour endofunctor” B is typically of the form BX = ℘f (Act × X), where Act is an object of actions, corresponding to the labels of the operational semantics of the calculus; then, B-coalgebras correspond to (finitely branching) labelled transition systems with labels in Act [2]. This construction can be carried out also in category of functors, by taking ℘f the pointwise finite powerset, as in [6]. However, there are two problems in applying this approach to the Fusion calcu- lus. First, the behaviour functor B using the pointwise finite power-object ℘f on Set F does not preserve weak pullbacks, which is required the construction of the
“universal” semantics. We solve the problem by using the K˜ -ﬁnite power object
construction [10,16], which preserves weak pullbacks (Section 3.3).
The second issue is more subtle, and strictly related to the design choices be- hind the Fusion calculus. Using the construction above, we can indeed define an endofunctor D on Set F such that processes of the Fusion calculus are D-coalgebras (see Section 4.2), but it turns out that the bisimulation over these coalgebras do not correspond to the intended equivalence of the Fusion calculus, that is, hyperequiv- alence. The problem is that the Fusion calculus “contains actions akin to updating a shared state” [20]: states are equivalences between names, which can be updated (i.e. extended) by fusions. Notably, this “shared state” is not explicitly represented

in the labelled transition system of Fusion calculus. In this way, inference rules are simpler but, on the other hand, an ad hoc definition of bisimulation is needed.
In the categorical setting, we cannot tinker with the notion of bisimulation; hence we ought to accommodate the notion of behaviour, that is, the behaviour endofunctor. In Section 4.2 we will tackle this problem by adding the notion of state to the endofunctor D in a systematic way, that is, by lifting it along the adjunction underlying the “state monad” GX = (X × E)E, for E a suitable object of states. Thus, the resulting “stateful” behavior functor is B(X) = (D(X × E))E . This approach is general and can be applied with any notions of global state. In the case of the Fusion calculus, the presheaf of states at n is the set of all possible equivalences of n names, that is, the set of coequalizers over n (Section 3.2). Moreover, in Section 4.3 we will present a concrete presentations of coalgebras of this endofunctor as stateful indexed labelled transition system, i.e., transition systems whose nodes are triples (n, P, e) where n is a set of names, P ∈ Pn is a process and e ∈ En is a state. Also coalgebraic bisimulations over the behaviour functor B can be given a concrete definition as a indexed family of relations. Using this characterization, in Section 4.4 we will show that coalgebraic bisimilarity coincides with hyperequivalence.
Finally, in Section 5 we complete our development by providing the “mathemat- ical operational semantics” for the Fusion calculus. We translate the new labelled transition system introduced in Section 2 into an “abstract categorical rule”, that is, a natural transformation between two endofunctors on Set F, using the syntactic and behaviour functors defined in Section 4. This presentation yields a fully-abstract (bialgebraic) semantics, that is, two processes have the same semantics iff they are BF -bisimilar and hence hyperequivalent.
Final remarks and directions for future work are in Section 6.

The Fusion Calculus
In this section we give the syntax, semantics and bisimulations of the Fusion calculus [20]. For our aims, a monadic version of the calculus without replication will suffice; the results we present can be generalized routinely to the polyadic version.
The processes are defined by the following grammar: 1
P, Q ::= 0 | zx.P | z¯x.P | P |Q | (x)P
where x is bound in (x)P . Processes are taken up to α-equivalence.
The semantics of Fusion is defined by a labelled transition relation of the form
P −→α  Q, whose labels are
α ::= xy | x¯y | x(z) | x¯(z) | 1 | x=y
The input xy, output x¯y, the empty fusion 1 and the fusion x=y are called free
actions; the others are called bound actions, because z is bound. 2

1 Sum and fusion prefix can be easily encoded in this fragment.
2 In the polyadic version, objects of communications are lists of names and fusions are lists of equivalences.



Pref
—
α.P −→α

Com
P
P −u→x
P ', Q
{x=y}
u¯y
−→
'

Q'
Par
'
P −→α
P |Q −→α
P '
P '|Q

P |Q −−−−→ P |Q

P −u→x
P ', u ∈/ {x, x¯}
P −→α
P ', x ∈/ n(α)
{x=y}
P −−−−→ P

Open
u(x)
Pass
'
(x)P −→α
(x)P '	Scope	1	'

(x)P −−→ P
(x)P −→ P {y/x}

Congr
P ≡ P ' P ' −→α
α
Q' Q' ≡ Q
(P |Q)|R ≡ P |(Q|R)	P |Q ≡ Q|P	P |0 ≡ P

P −→ Q
(x)0 ≡ 0	(x)(y)P ≡ (y)(x)P	P |(x)P ≡ (x)(P |Q) if x /∈ fn(P )

Fig. 1. Labelled transition system with structural congruence for the Fusion calculus.




P −u→x


P ', Q


u¯y
−→ Q
Pref
—


α.P −→α  P
P −→α P '


P −→α P '

Com
{x=y}
Parl
'	'
P |Q −→α
P '|Q	Parr
Q|P −→α
Q|P '


Open
P −u→x
P |Q −−−−→ P |Q
P ', u ∈/ {x, x¯}
P
−−→ P ,
P −→α

P ', x ∈/ n(α)
{x=y}
P −−−−→ P

Closel	1	'
Closer
'


1	'	'

P |Q −→ P {y/x}|Q	P |Q −→ P |Q {x/y}

u(x)
P
u¯(x)	'

Close


1	'	'

P |Q −→ (x)(P |Q )

Fig. 2. Labelled transition system without structural congruence for the Fusion calculus.

In Figure 1 we report (a monadic variant of) the labelled transition system given in [20]. In the conclusion of the rule Open, x is bound in the label and in the target P ' (like in the “open” rule of the π-calculus). We use u as a wildcard for z and z¯. This system uses a structural congruence ≡ to identify syntactically different presentations of the same agent. At the moment, the theory of mathematical op- erational semantics cannot be applied to semantics using structural congruences; therefore, in Figure 2 we present a new, congruence-free semantics of Fusion. The difference with the previous one is that, in place of the congruence rule, there is a symmetric rule for |, and three new rules Closel, Closer, Close, allowing for
π-calculus-like input, bound output and “scope extrusions”.
This semantics corresponds to that in Figure 1, in the sense that they derive the same transitions, up-to structural congruence, as state by the following result.
Theorem 2.1	(i) If P −→α  Q in the system of Figure 1, then there exist P ', Q'

such that P ' ≡ P, Q' ≡ Q, and P ' −→α
Q' in the system of Figure 2.

(ii) If P −→α
Q in the system of Figure 2, then P −→α
Q in the system of Figure 1.




Proof. (i) By induction on the derivation of P −→α
Q with the system in Figure 1.

The only interesting case is when this derivation ends with an application of the
(Congr) rule. Let P ≡ P1, Q ≡ Q1 and P1 −→α Q1 with the system in Figure 1. By
inductive hypothesis, there exist P ' ≡ P and Q' ≡ Q such that P ' −→α  Q' with
1	1	1	1	1	1
the system in Figure 2. Then, by transitivity of ≡, it is P ≡ P ' and Q ≡ Q' .
1	1
(ii) (Parr) is clearly derivable from (Par) and (Congr). It suffices to prove
that (Close), (Closel), (Closer), are admissible in the system of Figure 1. We will examine the case of (Close), the others being similar (and simpler).

Let P |Q −→1
(x)(P '|Q') be a derivation ending with the (Close) rule; this means

u(x)
that there are two derivations of P −−→
P ' and Q
u¯(x)
−−→
Q', where by α-equivalence

we can suppose that x /∈ fn(u). Now, bound transitions can be introduced only using the (Open) rule (possibly followed by some applications of (Parl), (Parr), (Pass)); hence, without loss of generality, we can suppose that P = (x)P1 and

Q = (x)Q , for some P ,Q , such that there are two derivations P
−u→x
P ' and

1	1	1	1

Q −u¯→x
Q'. Now we prove that P |Q −→1
(x)(P '|Q') is derivable without using (Close),

but using the congruence rule.
Let y be a fresh name; then Q1{y/x

u¯y
} −→

Q'{y/x}, and, by applying (Com),

x=y	1
we have P  |Q  {y/x	P '|Q'{y/x}.  Using (Scope), we get (y)(P  |Q  {y/x}) −→
1	1	} −−→	1	1
(P '|Q'{y/x}){x/y}. Since y is fresh, the source of this transition is equivalent to
P1|(y)Q1{y/x} = P1|(x)Q1, and the target is exactly P '{x/y}|Q'{y/x}{x/y} =

P '|Q'. By applying the (Pass) rule we obtain (x)(P |(x)Q ) −→1
(x)(P '|Q'). Since

x /∈ fn((x)Q1), it is (x)(P1|(x)Q1) ≡ (x)P1|(x)Q1 = P |Q, and hence by an applica- tion of (Congr) we are done.	 


Finally, we recall the notions of bisimilarity and hyperequivalence from [20].
Definition 2.2 We say that a name substitution σ (i.e., a function σ : N → N )
agrees with a fusion ϕ iff ∀x, y : xϕy ⇐⇒ σ(x)= σ(y).
A fusion bisimulation is a symmetric relation S between processes such that
whenever (P, Q) ∈ S, if P −→α  P ' with bn(α) ∩ fn(Q)= ∅, then Q −→α  Q' and
if α is a communication action: (P ', Q') ∈ S;
if α is a fusion: (P 'σ, Q'σ) ∈ S, for some σ agreeing with α.
P and Q are fusion bisimilar if (P, Q) ∈S for some fusion bisimulation S.
A hyperbisimulation is a substitution-closed fusion bisimulation, i.e., an S such that (P, Q) ∈ S implies (P σ, Qσ) ∈ S for any substitution σ. P and Q are hyper- equivalent, written P ∼ Q, if they are related by a hyperbisimulation.
Notice that only hyperequivalence is a congruence, while bisimilarity is not [20].

Categorical framework
Finite sets
We denote by F the (skeleton) category of finite sets and functions. We will use n, m to range over objects of F, and σ, ρ over morphisms of F. Objects of F represent sets of allocated names (or variables), and maps describe how name sets may evolve (e.g., new names can be added and existing names can coalesce, etc.); thus σ : n → m is a substitution of names in n with names in m. F has products and coproducts, defined as usual in Set . In particular, let us denote by δ : F → F the functor δn = n + 1; the two injection maps are old : n → n +1 and new :1 → n + 1, which extend to natural transformations old : IdF → δ, new : K1 → δ (where KS is the constant presheaf (KS)n = S). δ is a monad on F: its unit is old, and the multiplication is contrn : n +1+ 1 → n + 1, mapping the two added elements in the domain to the same element added in the codomain.

Presheaves
Set F is the category of functors from F to Set , called (covariant) presheaves over F; the application of this category to the representation of languages up-to α-conversion has been studied in depth in [14,7,21], among others. The basic idea is that a functor A : F −→ Set can be seen as a family of sets stratified according to different sets of names; e.g., An is the set of “elements of type A using names from n”. For σ : n → m a substitution, the map Aσ : An → Am describes how this substitution acts on the elements of An; for this reason, we will often denote Aσ(a) as a[σ].
As for any presheaf category, Set F is a topos, hence it is cartesian closed. The structure of Set lifts to Set F, which has:
Products and coproducts, computed pointwise (as with all limits and colimits in functor categories); e.g. (P × Q)e = Pe × Qe. The terminal object is the constant functor K1 = y(0), where y : Fop −→ Set F is the (contravariant) Yoneda embedding: K1(e) = 1. The initial object is the constant functor K∅.
A presheaf of names N  y(1). For n in F, it is Nn = F(1, n) =∼ n ∈ Set ; thus
N is the embedding from F into Set .
A dynamic allocation functor δ : Set F −→ Set F, induced by the δ on F as
δ : Set F −→ Set F.
Exponentials are defined as usual in functor categories:
(BA)n  Set F(y(n) × A, B)
(BA)σ(m)  φ ◦ (idA × ( ◦ σ))	for σ : n → m in F,φ : A × F(e, ) −→ B
We will occasionally denote BA also as A ⇒ B.
In particular, exponentials of representable functors have a nice definition:
Proposition 3.1 ([7,14]) For all n ∈ F, B in Set F: By(n) =∼ B +n.

Proof.  (By(n))m = Set F(y(m) × y(n), B) by definition of exponential
=∼ Set F(y(m + n), B)	since y preserves coproducts
=∼ Bm+n	by Yoneda Lemma.	 
This allows us to point out a strict relation between N and δ:
Proposition 3.2 ( )N =∼ δ, and hence	× N E δ.
Proof. Since N = y(1), by Proposition 3.1 we have FN =∼ F1+ = Fδ( ) = δ(F ). The second part is an obvious consequence, because in CCC’s it is always × B E ( )B. 

The presheaf of equivalences For n in F, En denotes the set of equivalences over n, that is, the possible partitions of n. Formally this is the set of coequalizers over n:
En  {coeq(f, g) | k ∈ F, f,g : k ⇒ n}	(1)
Thus the elements of En are surjective substitutions e : n → m, up-to permutations of the codomain. Using the definition (1), an element e ∈ En can be represented by a kernel pair f, g : k ⇒ n, which, akin to fusions in the Fusion calculus, can be explicitly described as a set of k name equations in n, {x1=y1,... , xk=yk}, where xi = f (i) and yi = g(i). In the following we will use both the surjection and the fu- sion notations; in particular, the empty set denotes the identity substitution ∅ = idn. The action of E on morphisms can be described as follows. For σ : n → m, e :
n → q in En: Eσ(e)= coeq(σf, σg) where f, g are such that e = coeq(f, g). In “fusion notation”, it is Eσ({x1=y1,... , xk=yk})= {σ(x1)=σ(y1),... , σ(xk)=σ(yk)}.
We need to introduce some operations on equivalences.
Given two equivalences e1 : n → m1, e2 : n → m2 in En, we define the union e1 ∪ e2 : n → m in En as the pushout of e1, e2; concretely, this can be defined by union of the two sets of equations.
For e1 = coeq(f1, g1) ∈ En, e2 = coeq(f2, g2) ∈ Em, the sum e1 + e2 ∈ En+m is coeq(f1+f2, g1+g2); notice that no new equivalences are introduced. In particular, for e ∈ En we denote by e +1 ∈ En+1 the equivalence e + {∗=∗}; this extends to a natural transformation +1 : E → δE.
Finally, given e : m → k in Em and i : n → m, the restriction of e to n (along i), is defined as e†n = ei : n → ei(n) in En.
Finite power-object
Beside the rich structure shown above, for representing non-determinism of the Fusion calculus we need also a “well-behaved” power-object endofunctor. By “well- behaved” we mean that it can be used for defining functors for which final coalgebras exist, bisimulations are equivalence relations, and the bialgebraic construction of
[26] can be carried out. Basically, this means that we require the power-object endofunctor to be finitary and to preserve weak pullbacks.
One may consider the “ω-bounded powerset endofunctor” Pω : Set F → Set F, that is, the “pointwise finite powerset functor” [6]. Although this functor would

suffice for expressing the non-determinism of the Fusion calculus, it is not satisfac- tory because it does not preserve weak pullbacks [15,24]. Another possibility is the K-ﬁnite powerset : in any topos E, the endofunctor K : E → E is a subfunctor of the full power-object, such that K(A) can be seen as “the object of (Kuratowski) finite subobjects of A”. K is finitary and, if E is Boolean, it preserves weak pullbacks [15, Example 1.4]. Unfortunately, Set F is not Boolean.
The problem with K-finite objects is that they are not closed under subobjects. To circumvent this problem, we can use another “finite powerobject” endofunctor K˜ , introduced by P. Freyd in [10]; here we refer to [16, D5.4] for a detailed presentation.
Definition 3.3 [[16]] In a topos E, for A an object of E, let A˜ be its partial map

classifier (that is,
A˜ > PA is the “object of subobjects of A with at most one

element”). Then, K˜ (A) is the sub-join-semilattice of PA generated by A˜ > P A.


Proposition 3.4 In any topos E , the K˜
endofunctor preserves weak pullbacks.

Proof. This can be proved following the same pattern in [15, Example 1.4] for

the Kuratowski-finite power object; the proof applies to K˜
in E (even if E is not a

Boolean topos) because K˜ (A) is always downward closed asa subobject of PA [16,
Lemma D5.4.21]; hence every subobject of K˜ -finite object is K˜ -finite.	 

Remark 3.5 It is worthwhile giving an explicit description of maps of the form φ : A → K˜ (B). Since K˜ (B) is generated by the subsingletons of B, the map φ corresponds to a finite family of partial maps (φi : A - B)i∈I . Each partial map
φi
→ B, whose left arm is mono [25]; D can be seen as the
subobject of A where φi is defined. In our setting, i.e. E = Set F, this is a span of natural transformations. By unfolding the naturality conditions, it is easy to check that this span of natural transformations corresponds to a family of maps
(φi : An → Bn + 1)n∈F subject to naturality “only where defined”:
for all σ : n → m, for all a ∈ An, if φi (a) ∈ Bn then φi (Aσ(a)) = Bσ(φi (a)) (2)
n	m	n

Notice that such a family is not a natural transformation A → B + 1, since it may happen that φn(a) = ∗ ∈ 1 and still φm(Aσ(a)) ∈ Bm (in general, partial maps A - B are not equivalent to total maps A → B + 1; this holds in Boolean toposes, but Set F is not Boolean). As a consequence, the map φ : A → K˜ (B), described by
the family (φi : A - B)i∈I , can be seen as a family of finite set-valued functions
(φn : An → ℘f (Bn))n∈F	by taking	φn(a)= {φi (a) | i ∈ I, φi (a) ∈ Bn}.	(3)
n	n

Again, this family is not a natural transformation A → ℘f (B), but, by (2), the following “weak naturality” holds:
for all σ : n → m, for all a ∈ An : {Bσ(b) | b ∈ φn(a)} ⊆ φm(Aσ(a)).	(4)

Algebras and coalgebras in Set F
In order to use Set F as an ambient category for giving algebraic and coalgebraic presentations of syntax and semantics of calculi with fusions, we need to use endo- functors on Set F having initial algebras and final coalgebras.
Recall that polynomial endofunctors over a category C is the smallest class of endofunctors over C containing identity, all constant endofunctors, and closed under products and coproducts. It is well-known that any polynomial functor over Set is finitary, and hence has initial algebra and final coalgebra [2]. This result has been generalized to Set F [7,14] in order to deal with syntax with binders up-to α- equivalence; to this end, the class of admitted endofunctor contains also δ. In our case, for defining the final coalgebras for the Fusion calculus, we will need also to
consider the endofunctors K˜ , ( )E : Set F → Set F. Summarizing:
Proposition 3.6	(i) Let T : Set F −→ Set F be a polynomial functor possibly using also δ : Set F → Set F. Then T has an initial algebra.
(ii) Let T : Set F −→ Set F be a polynomial functor possibly using also δ, K˜ , ( )E :
Set F → Set F. Then T has a ﬁnal coalgebra.
Proof. It is easy to check that δ and K˜ are finitary. We prove that ( )E preserves
limits. Let F : D → Set F be a diagram; we prove that (lim(F ))E =∼ lim(( )E ◦ F ). In functor categories, limits and colimits are computed pointwise, so we have to prove that for n ∈ F, ((lim(F ))E )n =∼ lim Gn, where G : F → Set D is defined by currying-uncurrying ( )E ◦ F : D → Set F, that is, (Gn)(d)  ((F (d))E )n.
By expanding the definition of exponents in Set F, we have that ((lim(F ))E )n = Set F(y(n) × E, lim(F )) =∼ lim Set F(y(n) × E, F ), because the Hom functor preserves limits. By noticing that Set F(y(n) × E, F )= (F ( )E)n = Gn, we are done. 
Finally, we recall the notion of coalgebraic bisimulation, as in [2].
Definition 3.7 For an endofunctor B on Set F, a B-bisimulation between two B- coalgebras (A1, α1) and (A2, α2) is a triple (R, f1 : R → A1, f2 : R → A2) such that

⟨f ,f ⟩ : R → A × A
is a strong monomorphism and
A ¸,f1
R 	f2	 A 

1	2	1	2	1	2

there exists a B-coalgebra structure γ : R → BR such
that f1 and f2 are B-coalgebra homomorphism, that is
α1	∃ γ	α2
J	J	J 

the diagram aside in Set F commutes.
BA1 ¸,  BR
 B A2

Modelling syntax and semantics of Fusion calculus
In this section we give a categorical representation of the syntax and semantics of the Fusion calculus, in the category Set F defined in the previous section.

Algebraic syntax of the Fusion calculus
Let us first define the object of processes of the Fusion calculus. This is a free language with λ-like binders, up-to α-equivalence; thus we define the endofunctor

ΣF on Set F as
ΣF (A)  1+ N × N × A + N × N × A + A × A + δA	(5)

0	xy.a
x¯y.a
a|b
(x)a

(ΣF (A))n = ¸x1`˛ + ¸n × nx`× An˛ + ¸n × nx`× An˛ + ¸An x×` An˛ + A¸ xn`+˛1
Each summand correspond to a constructor of the language; in particular, agents with a bound name (i.e., of the form (x)P ) and free names in n are represented as agents with free names in n + 1, where the added name represent the bound name. Then, the presheaf of processes of the Fusion calculus, denoted as Proc, is the (carrier of the) initial ΣF -algebra, which exists in virtue of Proposition 3.6(i). Its
algebra structure is denoted as αF : ΣF Proc →∼ Proc. It is easy to see that:
Proposition 4.1 For all sets of names m, Procm = {P | fn(P ) ⊆ m}.
We will denote by TF : Set F −→ Set F the monad of the free ΣF -algebra, that is,
TF (X)= μY.X + ΣF (Y ). Clearly Proc = TF 0.

Coalgebraic semantics of the Fusion calculus
The domain of the Fusion calculus is defined as the final coalgebra of a suitable “behaviour functor”. As for other models of concurrency, this functor must account for finitely-branching non-determinism; to this end, we will use the K˜ -finite power object defined in Section 3.3, which has the properties required for the successive developments. The behaviour functor must represent all possible actions (label)
that a process can perform in its LTS; thus, looking at the semantics of Figure 2, one could define this functor as


output
input
bound output
bound input	1
fusions

LX  ¸N × Nx`× X˛ + N¸
× Nx`× X˛ +
N¸ ×x`δX˛
+ N¸
×x`δX˛ +¸Xx`˛+ ¸N × Nx`× X˛
(6)

DX  K˜ (LX)	(7)
Each component of functor L corresponds to a possible evolution of a presheaf X, viewed as a stratified set of processes. The various possible transitions are a label and a continuation; in particular,
free transitions (input, output or fusion) have a pair of names as label, and a process in the same stage as continuation;
empty fusions have no label, and a process in the same stage as continuation;
bound transitions (bound input or output) have a single name as label, but the continuation process can use a fresh, local name (as denoted by the δ operator).
However, this semantics does not suffice for representing faithfully the Fusion calculus. The issue is that a fusion performed by a process can be not local, since it applies to any process running in parallel. As said in [20], a fusion “can be thought of as an update of a (not explicitly represented) shared state”.

Hence, our model has to keep track of this global, shared state, which is an equivalence on the names currently defined, i.e., an element of En. A “stateful” behaviour of a process takes a given state e ∈ En, and produces a set of possible transitions, each of which yields a new state e' ∈ En' alongside the continuation.
Thus we have to convert the “stateless” behaviour functor D (7) into a stateful one. We accomplish this by combining D with the “global state monad” [19]:
G : Set F →	F	GX = (X × E)E
D and G can be merged by decomposing the monad G in the corresponding ad- junction × E E ( )E, then, we define BF as the lifting of D along this adjunction:


BF X  (D(X × E))E

BF S_e t
F  ×E z F
¸⊥¸  Set	D
(8)

( )E	¸_
By definition of exponents in Set F, for n object of F we can write this explicitly as (BF X)n = Set F(y(n) × E, D(X × E)). Thus, an element of (BF X)n is a natural transformation φ : y(n) × E → K˜ L(X × E), that is, a family of partial maps
(φi : y(n) × E - L(X × E))i∈I
According to Eq. 3, the behaviour of a process with n names, under the substitution

σ : n → m and the equivalence e on m, is the union of all φi
(σ, e) which are defined:



φm(σ, e)= {φi
(σ, e) | φi
(σ, e) defined,i ∈ I}	(9)



Each φi
(σ, e), if defined, is a single stateful transition, i.e. a tuple containing the

label, the continuation process (the element from X) and the new equivalence (over m names, if the transition is free, m + 1 if it is bound). Naturality of φi ensures that a transition which happens under the substitution σ : n → m is preserved under any further substitutions, but it is not required to correspond to some transition

at n (i.e., φi (id, e) may be undefined and φi
(σ, e[σ]) defined). In other terms,

n	m
transitions are preserved under substitutions but not necessarily reflected (as stated
also by Equation 4).
Indexed labelled transition systems for the Fusion calculus
The interpretation of Fusion processes will be BF -coalgebras, that is, an object “of states” X of Set F, together with a behaviour map β : X → BF (X). BF (X) is a rather complex object (a presheaf of partial natural transformations), but we can simplify this definition, as follows:
Proposition 4.2 The category of BF -coalgebras is equivalent to the following cat- egory:
objects: pairs (X, (βi : X × E - L(X × E))i∈I ), for X in Set F;
a map φ : (X, β) → (Y, γ) is a map φ : X → Y such that φ × idE : X × E → Y × E
is a map of D-coalgebras.

Proof. Follows from adjunction (8), implying that there is a 1-to-1 correspondence


	X −→ BF (X)	
X × E −→ D(X × E)
(10)

and expanding D = K˜ L, a map X × E −→ D(X × E) is a finite family of partial maps X × E - L(X × E).	 
In virtue of this result, we can give an explicit description of BF -coalgebras, by means of a suitable notion of “FE-labelled transition system” (See [5,12,8] for similar kinds of “indexed” labelled transition systems).
Definition 4.3 (FE-LTS) The presheaf of actions Act is
Act  N × N + N × N + N + N +1 + N × N
For each n ∈ F, we denote the elements of Actn as xy, x¯y, x, x¯, 1, x=y, respectively.
An FE-labelled transition system L = (X, −→) is a presheaf X of Set F and a graph −→ such that
nodes are labelled with the elements of X × E, that is, elements of ∫ X × E =
{(n, P, e) | n ∈ F,P ∈ Xn,e ∈ En};

edges are labelled s.t. if (n, P, e) −→α
(m, Q, d) then α ∈ Actn and

if α ∈ {xy, x¯y, 1, x=y} then m = n
if α ∈ {x, x¯} then m = δn = n + 1;
(Closure) for κ ∈ {Id, δ}, if (n, P, e) −→α α[σ]
(n[σ],P [σ], e[σ]) −−→ (κn[σ], Q[κσ], κd[σ])

(κn, Q, κd) then for all σ : n → m :

It is evident that in a transition (n, P, e) −→α  (m', Q, d), m' is completely determined

by n and α; therefore, we will write transitions as (P, e)
−→α n (Q, d). Thus, the

configurations of a FE-LTS are processes together with the state of equivalence of the allocated variables, and the labels are Fusion action.
Proposition 4.4 FE-labelled transition systems are in 1-to-1 correspondence with
BF -coalgebras.
Proof. In virtue of Proposition 4.2, a BF -coalgebra is a pair (X, (φi : X × E - L(X × E))i∈I ). From this, it is easy to construct an FE-labelled transition system (X, −→), whose graph is defind as
(P, e) −→α n (Q, d) ⇐⇒ for some i ∈ I : φi (P, e)= (α, Q, d)
The “partial naturality” of each φi, as in equation (2), corresponds to condition (Closure) in Definition 4.3. The converse correspondence is also easy.	 
We can estabilish a clear relation between FE-LTS and the original semantics of Figure 2. In fact, this LTS induces a FE-LTS on Proc:
Proposition 4.5 For all n in F, let us deﬁne (P, e) −→α n (Q, d) as follows:

P ∈ Procn, e ∈ En, α ∈ Actn;
for α ∈ {xy, x¯y, 1}:


(P, e) −→α
n (Q, d) ⇐⇒ Q ∈ Procn
α[e]
,d = e and P [e] −−→
Q[e];



for α ∈ {x, x¯}:
(P, e) −→α n


(Q, d) ⇐⇒ Q ∈ Procn+1


α[e](z)
,d = e +1 and P [e] −−−−→


Q[e + 1]



where z /∈ fv(α[e]) is the new added name;
x=y


(x=y)[e]

(P, e) −−→n (Q, d) iff Q ∈ Procn,d = e ∪ x=y and P [e] −−−−−→ Q[e];
Then, LF  (Proc, −→) is a FE-LTS.
Notice that we use equivalences e as substitutions, which is correct because an
e ∈ En is a coequalizer, i.e. a surjective map e : n → k, for some k (equation (1)).

Indexed bisimulation
Using FE-labelled transition systems, we can give an explicit description of coalge- braic BF -bisimulations.
Proposition 4.6 The following are equivalent:
A BF -bisimulation on a functor A ∈ Set F (that is, a span between a BF -coalgebra whose carrier is A, and itself );
A family of symmetric relations
(Rn ⊆ (An × En) × (An × En))n∈N
such that, if (P, e)Rn(Q, d), then
if (P, e) −→α n (P ', e') where α ∈ {xy, x¯y, 1, x=y}, then there exists (Q', d') ∈
An × En such that (Q, d) −→α n (Q', d') and (P ', e')Rn(Q', d')
if (P, e) −→α n (P ', e') where α ∈ {x, x¯}, then there exists (Q', d') ∈ An+1 × En+1
such that (Q, d) −→α n (Q', d') and (P ', e')Rn+1(Q', d')
and moreover, for all σ : n → m in F: (P [σ], e[σ])Rm(Q[σ], d[σ]).
The characterization of BF -bisimulations provided by Proposition 4.6 allows us to compare BF -bisimulations with the original notions of fusion bisimulation and hyperbisimulation of Definition 2.2. The clauses in Definition 2.2 about communi- cation actions are covered by clauses (i), (ii) in Proposition 4.6; the condition about bound actions in Definition 2.2 is represented in clause (ii) by the fact that, after a bound transition, the resulting processes are bisimilar via a different relation, on a set of names where the fresh name has been allocated.
In fact, BF -bisimulations over Proc endowed with the FE-LTS LF coincide with hyperequivalences, as shown next.

Theorem 4.7 Two processes P, Q ∈ Procn are hyperequivalent if and only if (P, ∅)
and (Q, ∅) are BF -bisimilar.
Proof. (⇒) Let P, Q ∈ Procn be two hyperequivalent processes; this means that there exists a substitution-closed fusion bisimulation S such that P SQ. Then, we can define a BF -bisimilarity (Rn)n∈N over LF as follows:
for n ∈ N, S,T ∈ Procn, e,d ∈ En :	(S, e)Rn(T, d) ⇐⇒ S[e] S T [d]	(11)
It can be checked that this gives a BF -bisimulation, using Proposition 4.6; in particular, clause (iii) holds because S is closed under substitutions. Obviously (P, ∅)Rn(Q, ∅), hence the thesis.
(⇐) Let (Rn)n∈N be a BF -bisimulation over LF , such that (P, ∅)Rn(Q, ∅). We can define a relation S over processes using the same definition (11) above. Clearly P SQ; we have to check that S is a hyperbisimulation. The only subtle case is that

of fusion transitions. Let T ,T 
∈ Proc
such that T ST
and T
x=y
T '; then, by

1	2	n
1	2	1 −−→ 1

x=y
Proposition 4.5 this means that (T , ∅)
(T ', {x=y}) in L . But T ST
implies

1	−−→n	1
F	1	2

that (T , ∅)R (T , ∅), hence there exists a T ' such that (T , ∅) x=y
(T ', {x=y}),

1	n	2
2	2	−−→n	2

and that (T ', {x=y})Rn(T ', {x=y}). By definition of LF and S, this implies that
1	2
x=y
T
2 −−→ T2 and T1{x=y} S T2{x=y}.
Closure under substitutions is guaranteed by Proposition 4.6(iii).	 

Categorical rules
In this section we describe the GSOS-like 3 labelled transition system in Figure 2 as a natural transformation between suitable endofunctors on Set F, following the approach pioneered by Turi and Plotkin in [26]. The main advantage of such a presentation is that, if the behaviour functor preserves weak pullbacks, we get a compositional fully abstract semantics.
We define a natural transformation S from Σ(Id × B) to BT , which are two endofunctors on Set F. (In this section we omit the index F from ΣF , BF ). This means that we have to define a family of natural transformations
SX : Σ(X × BX) −→ BTX	in Set F

natural in X ∈ Set F. By exploiting the adjunction (10), we can consider instead the following simpler form
SX : Σ(X × BX) × E −→ D(TX × E)	in Set F	(12)
which makes explicit that the computation is “stateful”, the state being represented by the E in the domain and the codomain.

3 These rules are not properly GSOS due to the conditions on bound names in rules Open and P ass.

By expanding Σ, it is easy to see that SX is the product of several transforma- tions, one for each syntactic constructor in the language:


0 :	E −→ D(TX × E)
Sin : N × N × X × BX × E −→ D(TX × E) Sout : N × N × X × BX × E −→ D(TX × E) Spar :X × BX × X × BX × E −→ D(TX × E) Sres :  N × δX × δBX × E −→ D(TX × E)


In turn, each of these natural transformations is defined by collecting the rules which specify the behaviour of the corresponding constructor.
Recall that D = K˜ L; hence, according to Remark 3.5, each Sop is a finite family
of partial natural transformations with codomain L(TX × E); for instance S0 is
X
0 i
a family (SX ) : E - L(TX × E) i∈I . For sake of simplicity, we present such a
family as in Eq. 3, that is, as an F-indexed family of finite-set valued function


 (S0 )n : En → ℘f (L(TX × E)n) 


n∈F



subject to the “weak naturality” of Eq. 4; similarly for Sin, Sout, Spar, Sres.
X	X	X	X
There is no rule for 0, so it is simply (S0 )n(e)= ∅.
For input and output we have only the Pref rule, so Sin and Sout are as follows:
X	X


(Sin)n : n × n × Xn × Set F(y(n) × E, K˜ L(X × E)) × En −→ ℘f (L(TX × E)n) (Sin)n(x, y, P, β, e)= {(xy, P, e)}

(Sout)n : n × n × Xn × Set F(y(n) × E, K˜ L(X × E)) × En −→ ℘
(Sout)n(x, y, P, β, e)= {(x¯y, P, e)}
(L(TX × E)n)


Notice that at n = ∅, these functions are vacuous because the domain is empty.

We can define Spar
as the union of six transformations, corresponding to the

rules Parl, Parr, Com, Closel, Closer and Close:


ρP arl , ρP arr , ρCom, ρClosel , ρCloser , ρClose : X × BX × X × BX × E
−→ K˜ (Act × TX × E)

ρP arl (P, β, Q, γ, e)= {(α, P '|Q, e') | (α, P ', e') ∈ βn(idn, e)}
ρP arr (P, β, Q, γ, e)= {(α, P |Q', e') | (α, Q', e') ∈ γn(idn, e)} ρCom(P, β, Q, γ, e)= {(x=y, P '|Q', e1 ∪ e2 ∪ {x=y}) |
for some z, w ∈ n such that e(z)= e(w): 
((zx, P ', e1) ∈ βn(idn, e) ∧ (w¯y, Q', e2) ∈ γn(idn, e))∨
((z¯x, P ', e1) ∈ βn(idn, e) ∧ (wy, Q', e2) ∈ γn(idn, e))}
ρClosel (P, β, Q, γ, e)= {(1,P '[y/x]|Q', e1†n ∪ e2) | x = newn() and
for some z, w ∈ n such that e(z)= e(w): 
((z, P ', e1) ∈ βn(idn, e) ∧ (w¯y, Q', e2) ∈ γn(idn, e))∨
((z¯, P ', e1) ∈ βn(idn, e) ∧ (wy, Q', e2) ∈ γn(idn, e))}
ρCloser (P, β, Q, γ, e)= {(1,P '|Q'[x/y], e1 ∪ e2†n) | y = newn() and
for some z, w ∈ n such that e(z)= e(w): 
((zx, P ', e1, σ) ∈ βn(idn, e) ∧ (w¯, Q', e2, σ) ∈ γn(idn, e))∨
((z¯x, P ', e1, σ) ∈ βn(idn, e) ∧ (w, Q', e2, σ) ∈ γn(idn, e))}
ρClose(P, β, Q, γ, e)= {(1, (x)(P '|Q'), e1†n ∪ e2†n) | x = newn() and
for some z, w ∈ n such that e(z)= e(w): 
((z, P ', e1) ∈ βn(idn, e) ∧ (w¯, Q', e2) ∈ γn(idn, e))∨
((z¯, P ', e1) ∈ βn(idn, e) ∧ (w, Q', e2) ∈ γn(idn, e))}
Notice that in ρCom, the equivalences in the transitions contain the effects from both subprocesses, and also the equivalence caused by the communication. In the “close” rules, instead, the resulting equivalences do not have fusions caused by the communication, because this acts either as an immediate substitution (in left and right close), or as the (silent) unification of the hidden names (in the last rule). The local name x introduced by bound transitions is removed from the equivalence by the restrictions e1†n, e2†n along the inclusion n ‹→ n + 1.
Finally, Sres is defined in terms of rules Open, Scope and Pass; in fact it can be obtained from the union of the following three transformations:
ρOpen : δX × δBX × E −→ K˜ (Act × δ(TX × E))

ρOpen : Xn+1 × Set F(y(n+1) × E, K˜ L(X×E)) × En −→ ℘
(Actn × (TX)n+1 × En+1)

ρOpen(P, β, e)= {(y, P ', e') | y ∈ n, x = newn(), (yx, P ', e') ∈ βn+1(idn+1, e+1)}
∪{(y¯, P ', e') | y ∈ n, x = newn(), (y¯x, P ', e') ∈ βn+1(idn+1, e+1)}
ρP ass, ρScope : δX × δBX × E −→ K˜ (Act × TX × E)
ρP ass(P, β, e)= {(α, (x)P ', e'†n) | x = newn(), (α, P ', e') ∈ βn+1(idn+1,e + 1)}
ρScope(P, β, e)= {(1,P '[y/x], e'[y/x]) | y ∈ n, x = newn(),
(x=y, P ', e') ∈ βn+1(idn+1,e + 1)}
In ρScope, notice that the process and the state are changed by the substitution

[y/x]: n +1 → n, which replaces the fresh variable x with y.
Checking naturality (as per Eq. 4) of these definition is a tedious but easy task. The most important consequence of this definition is the following result.
Theorem 5.1 There exists a (unique) semantics  ) : Proc −→ νBF in Set F which is both compositional and fully abstract, that is, for all processes P, Q ∈ Procn:
 P )n =  Q)n iff P and Q are BF -bisimilar (and hence hyperequivalent).
Proof. Follows from general results in [26,6] about bialgebras with distributive laws: the semantics exists because Proc can be endowed with a BF -coalgebraic structure, and νBF with a ΣF -algebraic structure. As a consequence,  ) is both the unique map from the initial ΣF -algebra (i.e., Proc) and the unique map to the final BF -coalgebra, which exists in virtue of Proposition 3.6. However, in order to apply this theory, we have to prove that BF on Set F preserves weak pullbacks.
Recall that BF = (K˜ L( × E))E and that L( × E) is defined by a polynomial
containing some δ’s (equation 7). It is well known that in presheaf categories,

polynomial functors preserve weak pullbacks; the same for δ [7]. K˜
preserves weak

pullbacks by Proposition 3.4. It remains to prove that ( )E preserves weak pullbacks. As all limits in presheaf categories, pullbacks are computed pointwise; at n, it is (( )E)n = Set F(y(n) × E, ), and for any A, the hom-functor Set F(A, ): Set F → Set preserves limits.	 

Conclusions
In this paper we have provided a categorical account of the Fusion calculus. First, we have presented a new, congruence-free labelled transition system for the Fusion calculus. Then, we have described the syntax of Fusion as the initial algebra of a suitable signature monad, and the semantics of processes as coalgebras of a be- haviour “stateful” endofunctor, over the category of presheaves over finite sets. An explicit presentation of these coalgebras has been given, as “stateful” FE-labelled transition systems. The coalgebraic bisimulations on these systems turns out to be closed under substitutions (hence a congruence), and corresponding to hyperequiv- alence. Then, we have given a bialgebraic semantics for the Fusion calculus, by modelling the rules of the new labelled transition system as an abstract categorical rule between endofunctors over Set F. As a consequence, we have got a semantics which is both compositional and fully abstract, that is, two processes have the same semantics iff they are coalgebraically bisimilar, and hence hyperequivalent.
The categorical presentation of the Fusion calculus we have given, sheds also some light on the “name equivalence state” which is hidden inside Fusion processes. In fact, the nodes of a FE-labelled transition systems are pairs (P, e), to indicate that a system configuration is not simply a process, but a process together with the state of the equivalence over its names. This is actually confirmed in some offsprings of Fusion, such as the Explicit Fusions Calculus [27] and CC-Pi [4]; in both these calculi, processes have an explicit and clearly identified part which carries the information about the state of name/term equivalence. The same happens in the

bigraphical representations of Fusion processes given in [13]: a specific part of the bigraph representing an agent, encodes the equivalence classes of that agent. It is interesting future work to investigate whether the model and techniques presented in this paper can be applied to model also these similar calculi, and also Fu’s χ-calculus [11], a concurrent computation model similar to Fusion, and the open π-calculus
[22]; in both these calculi, bisimulation is closed under substitution.
Presheaf categories have been widely used for modelling languages with dynam- ically allocable entities, such as (bound) variables, (fresh) names, reference, etc; see
e.g. [23,7,14,6,12,21,18,8]. Maybe the work closest to ours is the treatment of π- calculus in [6]: also in that case, the right behavior functor over Set F is obtained by lifting the “intuitive” endofunctor given over another category, along an adjunction (although not the same as the one considered in this paper).
Finally, we mention that Buscemi and Montanari have given a compositional coalgebraic model of (a fragment of) the Fusion calculus [3]. Their techniques are more set-theoretic, using a first-order approach with a set of names endowed with “permutation” and “shift” and operators, thus akin de Bruijn indexes. We can envisage a connection between their approach and the model presented in this paper, which we leave as future work.
Acknowledgments The author thanks Sam Staton and the anonymous referees, for useful and important comments on the preliminary version of this work.

References
J. Adamek, editor. Coalgebraic Methods in Computer Science, volume 106 of Electronic Notes in Theoretical Computer Science. Elsevier, 2004.
J. Ad´amek. Introduction to coalgebra. Theory and Applications of Categories, 14(8):157–199, 2005.
M. G. Buscemi and U. Montanari. A compositional coalgebraic model of a fragment of fusion calculus.
Electr. Notes Theor. Comput. Sci., 162:135–139, 2006.
M. G. Buscemi and U. Montanari. Cc-pi: A constraint-based language for specifying service level agreements. In R. D. Nicola, editor, Proc. ESOP, volume 4421 of Lecture Notes in Computer Science, pages 18–32. Springer, 2007.
G. L. Cattani and P. Sewell. Models for name-passing processes: interleaving and causal. Inf. Comput., 190(2):136–178, 2004.
M. Fiore and D. Turi. Semantics of name and value passing. In H. Mairson, editor, Proc. 16th LICS, pages 93–104, Boston, USA, 2001. IEEE Computer Society Press.
M. P. Fiore, G. D. Plotkin, and D. Turi. Abstract syntax and variable binding. In Longo [17], pages 193–202.
M. P. Fiore and S. Staton. Comparing operational models of name-passing process calculi. Inf. Comput., 204(4):524–560, 2006.
C. Fournet, F. L. Fessant, L. Maranget, and A. Schmitt. Jocaml: A language for concurrent distributed and mobile programming. In J. Jeuring and S. L. P. Jones, editors, Advanced Functional Programming, volume 2638 of Lecture Notes in Computer Science, pages 129–158. Springer, 2002.
P. Freyd. Numerology in topoi. Theory and Applications of Categories, 16(19):522–528, 2006.
Y. Fu. Variations on mobile processes. Theor. Comput. Sci., 221(1-2):327–368, 1999.
N. Ghani, K. Yemane, and B. Victor. Relationally staged computation in calculi of mobile processes. In Adamek [1].

D. Grohmann and M. Miculan.	Reactive systems over directed bigraphs.	In L. Caires and
V. Vasconcelos, editors, Proc. CONCUR 2007, volume 4703 of Lecture Notes in Computer Science, pages 380–394. Springer-Verlag, 2007.
M. Hofmann. Semantical analysis of higher-order abstract syntax. In Longo [17], pages 204–213.
P. Johnstone, J. Power, T. Tsujishita, H. Watanabe, and J. Worrell. On the structure of categories of coalgebras. Theor. Comput. Sci., 260(1-2):87–117, 2001.
P. T. Johnstone. Sketches of an Elephant (Volume 2). Number 44 in Oxford Logic Guides. Oxford University Press, New York, 2002.
G. Longo, editor. Proceedings, Fourteenth Annual Symposium on Logic in Computer Science, Trento, Italy, 1999. IEEE Computer Society Press.
M. Miculan and K. Yemane. A unifying model of variables and names. In V. Sassone, editor,
Proc. FOSSACS’05, volume 3441 of Lecture Notes in Computer Science, Apr. 2005.
E. Moggi. Notions of computation and monads. Information and Computation, 1, 1993.
J. Parrow and B. Victor. The Fusion calculus: Expressiveness and symmetry in mobile processes. In
Proceedings of LICS ’98, pages 176–185. IEEE Computer Society Press, July 1998.
J. Power and M. Tanaka. Binding signatures for generic contexts. In P. Urzyczyn, editor, TLCA, volume 3461 of Lecture Notes in Computer Science, pages 308–323. Springer, 2005.
D. Sangiorgi. A theory of bisimulation for the π-calculus. Acta Informatica, 33:69–97, 1996.
I. Stark. A fully abstract domain model for the π-calculus. In Proc. LICS’96, pages 36–42. IEEE, 1996.
S. Staton. Name-passing process calculi: operational models and structural operational semantics. PhD thesis, Computer Laboratory, University of Cambridge, 2007.
S. Staton. Personal communication, 2008.
D. Turi and G. Plotkin. Towards a mathematical operational semantics. In Proc. 12th LICS Conf., pages 280–291. IEEE Computer Society Press, 1997.
L. Wischik and P. Gardner. Explicit Fusions. Theor. Comput. Sci., 340(3):606–630, 2005.
