Electronic Notes in Theoretical Computer Science 190 (2007) 33–48	
www.elsevier.com/locate/entcs

On-the-Fly Data Flow Analysis Based on Verification Technology 
Mar´ıa del Mar Gallardo, Christophe Joubert1 and Pedro Merino

University of Ma´laga / Gisum Campus de Teatinos s/n 29071, Ma´laga, Spain
Email: {gallardo,joubert,pedro}@lcc.uma.es


Abstract
The combination of static and dynamic software analysis, such as data flow analysis (Dfa) and model checking, provides benefits for both disciplines. On the one hand, the information extracted by Dfas about program data may be utilized by model checkers to optimize the state space representation. On the other hand, the expressiveness of logic formulas allows us to consider model checkers as generic data flow analyzers. Following this second approach, we propose in this paper an algorithm to calculate Dfas using on-the-fly resolution of boolean equation systems (Bess). The overall framework includes the abstraction of the input
program into an implicit labeled transition system (Lts), independent of the program specification language. Moreover, using Bess as an intermediate representation allowed us to reformulate classical Dfas encountered in the literature, which were previously encoded in terms of μ-calculus formulas with forward and backward modalities. Our work was implemented and integrated into the widespread verification platform Cadp, and experimented on real examples.
Keywords: data flow analysis, model checking, labeled transition system, boolean equation system


Introduction
The last two decades have been the most productive from the point of view of tech- niques and tools for testing and ensuring the reliability of complex software. The investment in formal methods has produced a number of powerful languages, algo- rithms, methodologies and tools to be successfully employed with software models. Today, we can think of applying the same methods to real programs in a transparent way, integrating the verification functionality within the compiler.

٨ This work was supported by Spanish MEC under grant TIN2004-7943-C04. The second author was also supported by a Lavoisier grant from the French Ministry of Foreign Affairs.
1 Current affiliation is: Technical University of Valencia / DSIC / ELP, Camino de Vera s/n, 46022 Valencia, Spain. Email: joubert@dsic.upv.es

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.09.006

This promising scenario is mainly due to the advances in two major techniques: static program analysis and model checking. In a few words, a static analysis carries out a static (abstract) execution of a program in order to extract correct informa- tion about its behavior during execution. This information is typically utilized to discard some programming errors as soon as possible, and to improve the program compilation. Regarding model checking, it is a technique based on exhaustive explo- ration of states produced by (concurrent) programs, to check the satisfiability of a desirable program behavior. Our work exploits the use of model checking as a static analysis implementation method that can be naturally coupled with compilers.
One of the most well used static analyses is data flow analysis (Dfa), which consists in giving the definition and usage of program data, such as variables, ex- pressions, and definitions. This technique usually aims at compiler optimizations,
e.g. dead code elimination, but it can also be used for state space reduction dur- ing explicit program verification, e.g. in software model checking, by keeping only necessary variables at each program point [2].
Example 1.1 We illustrate the classical live variables (LV ) analysis on Figure 1. The goal of LV is to attach each program point (program counter) with the set of variables that may be live at this point [15]. A variable is live at a given point p iff its current value may be used, before being updated, by some program execution starting at p. The C code for the factorial problem on the left hand side of Figure 1
void fact ( int n ) {	
∅	int x = n;
[x]	int y = 1;
[x, y]  while ( x > 0 ) {
[x, y]	y = x * y;
[x, y]	x = x - 1;
}
∅ }

Fig. 1. Classical live variables analysis of a C program for the factorial problem
includes the intended result for the LV analysis. It shows which variables x or y are live on the different program points. For instance, variable y is not live at the first two lines of the program, because its value is updated before being read.
It has been shown that Dfa is solvable using model checking techniques [17], namely using modal μ-calculus. Each analysis is specified as a particular temporal modal formula and then verified using standard model checkers, the output of the equivalent static analysis being the information generated by the model checker. As a consequence, all the necessary work to create a new Dfa tool is reduced to write an adequate temporal formula.
Our approach follows the work of [17] to implement static analysis using model checking. However we focus on a method, which allows us to exploit the benefits of on-the-fly model checking, where the system is solved incrementally and at no time is the complete solution stored in memory. To this aim, this paper presents the use of Boolean Equation System (Bes) as a means of specifying and solving pro-

gram analysis. We illustrate the Bes specification capability by encoding classical Dfas [15]. The resulting Dfas are nicely implemented thanks to a generic algorithm, which evaluates the different Bes encodings over a given program described as an implicit Labeled Transition System (Lts). The algorithm was integrated into the well-known Cadp toolbox [8], and experiments confirmed that it worked efficiently for realistic examples.
Compared with related works, the main contribution of the paper is a method to achieve static analysis using on-the-fly model-checking. This work generalises the local Bes resolution used for influence analysis [4, 5], by introducing a program representation that enables a broader set of analyses than previously described, to- gether with efficient resolution algorithms. Although static analysis is traditionally done with global methods, like in the proposals centered in modal μ-calculus [17], on-the-fly methods are of importance when dealing with realistic complex programs. Indeed, for millions lines projects, constructing and handling the program represen- tation becomes a bottleneck, and dynamic solutions are useful during the design process. In our approach, both Lts and Bes are constructed dynamically, thus saving the generation of unnecessary parts of both structures for the given analysis. The choice of Bes as a unifying representation for static analysis problems is also motivated by its successful application to numerous verification problems, such as equivalence checking, partial order reduction, horn clause resolution, abstract inter- pretation, model checking and conformance test case generation [10]. Its resolution time and memory complexities being linear in the size of the program model [14] make the Bes an appropriate and efficient way to solve Dfas. Another contribution of the paper is the encoding of forward static analyses (e.g., available expressions and reaching definitions analyses) only in terms of forward operators (successor transition), whereas such analyses are defined in the literature using predecessor information.
The reminder of the paper is organized as follows. Section 2 defines the program abstract control flow graph (Cfg) as an Lts. After a brief definition of alternation- free modal μ-calculus and Bes, Section 3 gives the encodings of several classical Dfas, in terms of Bess. Section 4 presents in detail the on-the-fly Dfa algorithm, and its modularity to solve different static analysis problems. Section 5 describes the architecture of the Annotator data flow analyser, together with experimental data evaluating its functionality on standard analysis problems. Finally, Section 6 summarizes the results and indicates directions for future work.

Problem representation
Data flow analyses work on the control flow graph of programs. In this work, we consider the Lts model, which is suitable for concurrent system descriptions, in particular for Cfgs. An Lts is a tuple M = ⟨S, A, T, s0⟩, where S is a finite set of states, A is a finite set of actions, T ⊆ S × A × S is the set of labeled transitions, and s0 is the initial state. A transition (s, a, s') ∈ T , also noted as
s →a s', states that the system can move from s to s' by executing action a (s' is an

a-successor of s). In the sequel, we assume that states in S are program counters of the system to be analyzed, and actions in A are the basic program instructions, that is to say, boolean expressions, assignments of program variables with arithmetical expressions, assertions, and the invisible instruction τ .
Example 2.1 Figure 2(a) shows the C code for the factorial problem and Fig-
ure 2(b) illustrates the corresponding Cfg in terms of an Lts P , where states
store the program counter (an element of set {0, 1, 2, 3, 4, 5}). Actions in P are the boolean expressions and assignments in the code. We remark that, since only the Cfg is kept in the Lts, the current value of program variables in each state is ignored.


void fact ( int n ) { int x = n;
int y = 1;
while ( x > 0 ) { y = x * y;
x = x − 1;

MODIFY x : USE n

}
}	y = x * y



x * y : MODIFY y : USE x y

(a)	(b)	(c)

Fig. 2. C program for the factorial problem (a) with its original (b) and abstract (c) control flow graph

Let M = ⟨S, A, T, s0⟩ be a program Cfg. In general, the goal of a Dfa dfs : S → 2D over M is to attach each program point s ∈ S with a set of denotations dfs(s) ∈ 2D that correctly describe the program data at s during any execution. The type of denotations in D strongly depends on the analysis to be carried out. For instance, D could be the program variable set or the arithmetical and boolean expression set.
In order to make the resulting program description independent from the pro- gram specification language, we now define an abstraction of actions in the Lts to be analyzed. The proposed transformation extracts from each action the aspects relevant for the program property under analysis. By extracting more information out of the original program instructions, our Cfg representation is less abstracted than the Cfg model presented in [4], and allows the computation of a broader set of static analyses. In the new abstract Lts, each action a ∈ A is represented as
a list iw→ , where i identifies its type and w→ is a list of typed values. In particular,
with respect to the classical Dfa problems, we are mainly interested in the set of program variables and expressions that are present in program instructions. Thus, we will use only two types of values, var and expr, denoting the set of program variables and expressions, respectively. Actions on abstract Lts transitions are of the form:
→e : MODIFY →v : USE w→ : (BOOL|ASSERT |AP I)
and represent program instructions, where →e is the list of non-trivial expressions, →v is the list of modified variables in the instruction, and w→ is the list of used (i.e., read)

variables. Moreover, three labels BOOL, ASSERT, and API respectively establish if the corresponding program instruction is a boolean or assignment expression, or a system call to an Api of interest. This information is relevant for some static analyses, like influence analysis [2, 4, 5] and makes possible both property verifica- tions and program optimizations. Such a format further allows to automatically and incrementally construct the (strict necessary parts of the) resulting Lts considering a program Cfg.
Example 2.2 Figure 2(c) gives the complete abstract Lts corresponding to the factorial program presented on Figure 2(a) and 2(b).
Working at the level of an abstract control flow graph allows us to be independent from the input programming language and to focus on developing efficient analysis
algorithms for it. Indeed, a same abstract Cfg can represent a same program
coded in different languages and it can also represent several programs that only differ from each other by arithmetic operators. This formalism enables the Cfg representation of numerous high level programming languages, such as C, Promela, and Lotos, and can serve as a benchmark representation for existing specialized analysis tools.

Data flow analysis as Boolean equation system
In this section, we introduce the Boolean equation system (Bes) formalism and show that specifying Dfas with Bess allows us to construct a general and efficient approach to implement the analyses independently from the data properties being preserved (live variables, busy expressions, etc.). In a first step, we briefly recall how a Dfa problem is equivalent to model checking modal μ-calculus formulas. Then, we introduce optimised Bes resolutions as alternative and uniform techniques to solve on-the-fly Dfas.

Alternation-free modal μ-calculus model checking
The approach of computing data flow analyses by performing a transformation to μ- calculus formulas or systems of modal fixed point equations (Dfa-Mc) was proposed
in [17], and was the basis of a verification component in jAbc [11].  Formulas
of alternation-free modal μ-calculus, noted L1 , and defined over an alphabet of propositional variables X ∈ X , have the following syntax given in positive form:
φ	::=	false | true | φ1 ∨ φ2 | φ1 ∧ φ2 | ⟨a⟩ φ | [a] φ | X | μX.φ | νX.φ
The semantics of a formula φ over an Lts M = ⟨S, A, T, s0⟩ denotes the set of states satisfying φ and it is defined as follows: boolean operators have their usual definition; possibility operator ⟨a⟩ φ (necessity operator [a] φ) define states from which some (all) transitions labeled by action a lead to states satisfying formula φ; minimal (maximal) fixed point operator μX.φ (νX.φ) denotes the least (greatest) solution of the fixed point equation X = φ, interpreted over domain 2S. On-the-fly

model checking determines if the initial state s0 of an Lts satisfies a formula φ and belongs to the set of states denoted by φ.
Example 3.1 We illustrate the LV analysis using model checking on Figure 3. LV analysis can be defined by the following modal μ-calculus formula φ [17]: φ(v) = μZ. ( ⟨a | used(v, a)⟩ true ) ∨ (⟨a | ¬modiﬁed (v, a)⟩ Z), where used(v, a) is true if variable v is used (i.e., read) in instruction a, bool(a) is true if instruction a is a boolean expression, and modiﬁed (v, a) is true if variable v is modified (i.e., defined) on instruction a.	Given the factorial program on the left hand side of Figure 3,
















x * y : MODIFY y : USE x y

Fig. 3. Live variables analysis of the factorial abstract control flow graph using model checking

the analysis consists in evaluating on each state and for each program variable, the corresponding modal μ-calculus formula by a global model checker. The result shows which variables x or y are live on the different states.
Remark 3.2 Although the alternation-free fragment of modal μ-calculus is suffi- cient to describe all Dfas present in this article, we should notice that the value-

based extension of L1
[13] may be of interest when considering a broader set of

Dfas, such as for influence analyses [4, 5].
Alternation-free boolean equation system resolution
A Boolean Equation System (Bes) [1, 12] is a tuple B = ⟨x, M1,... , Mn⟩, where
x ∈ X is a boolean variable, X a set of boolean variables, and Mi are equation

blocks (i ∈ [1, n]). Each block Mi
= {xij
=σi
opij
Xij
}j∈[1,mi]
is a set of minimal

(maximal) fixed point equations with sign σi = μ (σi = ν). The right-hand side of
each equation xij of block Mi is a pure disjunctive or conjunctive formula obtained by applying a boolean operator opij ∈ {∨, ∧} to a set of variables Xij ⊆ X . Boolean constants false and true abbreviate the empty disjunction ∨∅ and the empty conjunction ∧∅ respectively. A variable xij depends upon a variable xkl if xkl ∈ Xij. A block Mi depends upon a block Mk if some variable of Mi depends upon a variable defined in Mk. A Bes is alternation-free if there are no cyclic dependencies between its blocks. The local (or on-the-fly) resolution of an alternation-free Bes B = ⟨x, M1,... , Mn⟩ consists in computing the value of x by exploring the right- hand sides of the equations in a demand-driven way, without explicitly constructing the blocks. Several on-the-fly alternation-free Bes resolution algorithms with linear time and space complexity are available in the literature [13, 12].

To the best of our knowledge, no encodings of Dfas in terms of Bes resolution have been proposed in the literature.
Example 3.3 Following the translation from state to Boolean formulas of Ta- ble 1 [14], the encoding of LV analysis in terms of Bes is straightforward given the corresponding μ-calculus formula as expressed in Example 3.1. The least fixed point
Table 1
Translation from state to Boolean formulas

φ	(φ)p	op(φ)	φ	(φ)p	op(φ)

false
∅
true
φ1 ∨ φ2
∨	⟨a⟩ φ1
∧	[a] φ1
∨	X
∨
a  (φ1)p
∧
∨

φ1 ∧ φ2
(φ1)p ∪ (φ2)p
∧
σX.φ1
{Xp}
op(φ1)


	

operator is stated explicitly by the boolean equation. Forward possibility modality (i.e., ) operator translates into disjunction over all successor states. Boolean ex- pressions over states translate into boolean expressions over actions. The resulting
alternation-free Bes given an Lts M = ⟨S, A, T, s0⟩ describing the program Cfg is
μ	a	a
as follows: X	({true | s → s'∧used(v, a)} ∪{X '	| s → s'∧¬modiﬁed (v, a)}),



















x * y : MODIFY y : USE x y

Fig. 4. Live variables analysis of the factorial abstract control flow graph using boolean equation system

Similarly to model checking μ-calculus formulas (Figure 3), the analysis on Fig- ure 4 consists in solving for each state and program variable, the corresponding Bes by an on-the-fly Bes solver. If Xs,v is true (false), then variable v is live (dead) at state s of the Cfg, and the variable v is added to the set of live (dead) variables returned for state s, as shown by the annotations of the different states with vari- ables x and y on Figure 4. Consequently, we directly obtain dead variables analysis by considering the negation of LV analysis.
Remark 3.4 As for modal μ-calculus formulas, we should notice that the parame- terised extension of alternation-free Bes [13], called Pbes, may be of interest when considering further analyses, such as for influence analyses [4, 5].

Very busy/available expressions and reachable deﬁnitions analyses

Here, we present the encodings of three classical data flow analyses, defined in [16, 15], directly in terms of Bess (Dfa-Bes).

Let M = ⟨S, A, T, s0⟩ be an
Lts representing the program abstract
Cfg to

be analysed. Table 2 shows the Bes encodings of the analysis between M and a program expression e or a program definition (o, v, t) with v ∈ var, modulo three widely-used Dfas: very busy expressions (V BE), reaching deﬁnitions (RD), and available expressions (AE) [15]. LV , V BE, AE and RD analyses are perhaps the most famous examples of flow analyses and are meant to portray backward and forward analyses with least and greatest fixed points.
Each analysis is represented as a Bes with a single ν block defining, for example, for each couple of state and program expression (s,e) ∈ S × expr, a variable Xs,e, which expresses that expression e satisfies the Dfa on state s. We can notice that encodings given in Table 2 are based upon computing successors of states, therefore allowing to construct, on-the-fly, the Lts during Bes resolution.
In this paper, we consider the commonly accepted standard definition of V BE analysis [15]. We first describe it as a modal μ-calculus formula: φ(e) = νZ. isUsed(e) ∨ (¬isM odif ied(e) ∧ true ∧ Z). Then, applying the transfor- mations of Table 1, we give its encoding in terms of Bes in Table 2. Even if Ys,e is a disjunctive variable, it has only one successor: true or false. Hence, like the LV analysis, which only uses disjunctions, we can apply an optimised Bes resolution algorithm based on depth-first search for strictly conjunctive or disjunctive equation blocks, such as algorithm A4 of [14]. If Xs,e is true, then expression e is very busy at state s of the Cfg.
Contrary to backward analyses, such as LV or V BE analyses, forward Dfas cal- culate information about histories. Therefore, they are using backward modalities, which are overlined possibility (i.e., −) and necessity (i.e., −) operators. Such anal- yses cannot be encoded directly in terms of on-the-fly Bes resolution, where only successor information is accessible. Moreover, there is no method to translate over- lined modalities into forward modalities. Hence, instead of testing the final value of a computed boolean variable, i.e., if Xs,e is true then the property is satisfied on state s for element e, we resolve forward analyses with on-the-fly Bes resolutions by computing a specific Bes and by testing the inclusion of a boolean variable of interest in the set of computed variables.

We give a detailed description of such
Bes
transformation for RD analysis.

RD analysis computes for each program point, which assignments may have been made and not overwritten, when program execution reaches this point along some path [15]. We can reformulate this analysis as follows: Let the transition (o,v,t) be a variable deﬁnition to analyse, v ∈ var. To check if definition (o,v,t) is reachable on a given state s of the abstract Cfg M = ⟨S, A, T, s0⟩, we traverse the graph until we encounter (o,v,t) (1). Then, we construct the reachable graph from state t, which does not overwrite definition (o,v,t) (2). Finally, if state s belongs to the reachable graph, then (o,v,t) is a RD on state s (3). Points (1) and (2) are expressed as two

Table 2
Boolean equation system encodings of three widely-used data flow analyses





Ys,e ν
({true | s →a
s'})
e ∈ expr

















tautology boolean variables Xs,(o,v,t) and Ys,(o,v,t) respectively that are always true and use a maximal fixed point to explore all possible paths, as shown on Table 2. Point (3) is achieved by testing the inclusion of Ys,(o,v,t) in the set of computed boolean variables in block Y (computed(Y )).
Example 3.5 Given the program abstract Cfg of Figure 2(c), the result of com- puting RD analysis using our Bes transformation is illustrated on Figure 5.


MODIFY x : USE n
x * y : MODIFY y : USE x y

Fig. 5. Reaching definitions analysis of the factorial abstract Cfg using boolean equation system

Following the same approach, AE analysis can be encoded in terms of the Bes given in Table 2: block X computes for each successor state s' of current state s, either a subgraph of the Lts, where the expression is either unused or modified (i.e., block Y ), or a subgraph of the Lts where the expression is available (i.e., block Z).

Since variable Xs,e is recursively defined in terms of its successors Xs',e, solving Xs,e forces to traverse the whole Lts. Xs,e being a tautology, its final value is always true. Once Xs,e is computed, testing the inclusion of Ys,e in computed(Y ) gives that expression e is not available at state s. If Ys,e is not included in computed(Y ), then testing the inclusion of Zs,e in computed(Z) gives that expression e is available at state s. Otherwise, e is not available at s.
Considering Xs',e∨true (Xs',(o,v,t) ∨true) as an extra disjunctive boolean variable, an optimised depth-first search resolution algorithm for equation blocks containing alternating dependencies between conjunctive and disjunctive variables (e.g., mode 5 of [14]) can be applied on the two later Bess.

On-the-fly data flow analysis algorithm
In order to simplify the presentation, we first discuss the case of LV analysis, and then we extend the method to the other static analyses. Thus, Figure 6(a) shows the implementation of LV on a program abstract Cfg M = ⟨S, A, T, s0⟩ using Bes resolution. We assume that we have already specified the data flow analysis for each program variable v by means of a Bes B = ⟨Xs,v, M1, ··· , Mn⟩, as in Example 3.3, where s is a state of the Lts. We also assume that solve (Xs,v) computes the truth value of variable Xs,v on the Lts M .
Function Analyse is based upon the following principle: starting at the initial state s0, it performs an on-the-fly exploration of the Lts and, for each program state, computes the final value of boolean variable Xs,w (i.e., the result of function solve) considering each program variable w found during the algorithm execution (lines 23–27). If the final value of Xs,w is true, we can conclude that Dfa of state s with variable w is satisfied, that is to say, w is live at s. An annotating function d then keeps track of this result (line 25).
Analyse is more modular than algorithm Influence Analysis presented
in [4], by allowing both the computation of classical Dfas and influence analy-
ses. Moreover, it does not require an a priori computed set of program variables or expressions to be analyzed, since it dynamically constructs these sets on demand, with respect to a given analysis, while traversing the Lts.
We describe below the details of the algorithm. Visited but unexplored states are stored in set visited ⊆ S, whereas explored states are stored in set explored ⊆ S, explored ∩ visited = ∅. The set of variables appearing at each action a in the Lts is denoted with v(a), and added to set pv. At each iteration of the main loop (lines 5– 30), a new state s is extracted from the set visited. In a first step, its unexplored successors are added to visited, and for each new variable w ∈ v(a), the algorithm re-initiates the static analysis for all explored states s' by computing the boolean variable Xs',w (lines 7–22). When all sets of states (i.e., visited and explored) and variables (i.e., pv) are updated, current state s is then analysed (lines 23–27). The algorithm terminates when all states have been explored. After termination of the main loop, the annotating function d, which was computed for all states and variables, is returned (line 31).


(a)	(b)
Fig. 6. On-the-fly program variables (a) or expressions (b) analysis of Lts M = ⟨S, A, T, s0⟩ using Bes
resolution of Xs,w (a) or Xs,z (b)

Figure 6(b) shows the extension and/or modification of the algorithm on Fig- ure 6(a) for analyzing program expressions. The main difference between both ver- sions is the progressive construction of a set pe of arithmetical expressions extracted by e(a) from the actions encountered during the Lts traversal.
By replacing variable Xs,w (Xs,z) in function Analyse by Xs,v (Xs,e), defining LV (V BE) as a Bes in Section 3, we immediately obtain an on-the-fly LV (V BE) analysis algorithm. As a result, backward Dfas can be systematically encoded in terms of Bess and solved by Analyse.

In addition, the same algorithm can also be used for other static analyses modulo a modification of the output signature, because the algorithm is only an intertwined
traversal of the Lts for each program variable or expression. For instance, we
can slightly modify the algorithm Analyse on Figure 6(a) by taking into account variable deﬁnitions, which are triple of state, variable and state (o,v,t), instead of considering only program variables returned by v(a) (lines 14 and 20). By redefining pv : 2S×var×S, v : A → 2S×var×S, and d : S → 2S×var×S, we directly obtain an on- the-fly RD analysis by solving Xs,w (lines 15 and 24) and by testing the inclusion of Ys,w in computed(Y ).
We discuss below the behavior of algorithm Analyse w.r.t. efficiency. Every transition in the Lts is traversed exactly once per program variable or expression. We assume that Bes resolutions are linear in the size of the Lts [14]. Since the constructed Bes is unique for all states given a variable or an expression, resolution of already solved boolean variables is done in constant time. Therefore, each call
to Analyse has a worst-case time complexity O(|S|+|T |), considering that the
number of tested variables and expressions is significantly smaller than the number of states and transitions. The same bound applies for memory consumption, since in the worst case, every state will be stored in set explored, taking in account that Bes resolution has a linear memory complexity.

Table 3
Comparison of three data-flow analysis techniques




As shown by Table 3, the solution using Bes resolution is similar in spirit to the model checking approach, as it enables to directly provide the desired property as
an equation system instead of a μ-calculus formula. Bess being solved on-the-fly,
only relevant program parts are computed for each state, variable or expression. Another advantage of working at the level of Bess is that persistent computation results between subsequent resolution calls can be used to obtain an efficient overall resolution. Indeed, only one structure, the boolean equation system, is computed for a given analysis and variable of interest, whereas on-the-fly evaluation of μ-calculus formulas would compute one formula per state of the Lts, as it is done in [4].

Implementation and experiments
We implemented the Analyse algorithm described in Section 4 in a modular tool,

called
Annotator, which is built within
Cadp [8] upon the primitives of the

Open/Cæsar
[7] environment for on-the-fly exploration of
Ltss and on-the-fly

resolution of Bess. Currently, Annotator achieves four influence analyses [4, 5] and the five Dfas described in Section 3. We briefly describe the architecture of this tool and give some experimental results concerning program analyses.
The ANNOTATOR tool
The static analyser Annotator (see Figure 7) takes as input the Lts associated to the program abstract Cfg together with optional arguments such as the type of the underlying Bes resolution (e.g., breadth-first search), and produces as output the function d as an Xml or textual file.
















Fig. 7. The on-the-fly ANNOTATOR tool
Annotator consists of two parts: a front-end, responsible for encoding the

static analysis of
Lts as a (parameterised)
Bes
resolution, and a back-end, re-

sponsible of (parameterised) Bes resolution, playing the role of verification engine. Back-end is obtained by using algorithms of the Cæsar Solve library [14]. Glob- ally, the approach to on-the-fly static analysis is both to construct on-the-fly the Lts and corresponding (parameterised) Bes and to determine the final value of variables of interest specified by Analyse. Only the part of both graphs that is necessary to perform the static analysis is explored incrementally.
Our resulting data flow analyser can also be slightly extended to become an Open/Cæsar library providing an Application Programming Interface (Api) al- lowing the on-the-fly use of computed function d. Hence, (existing) compilers and

verification tools would directly be able to integrate on-the-fly static analysis into their computation without needing an exhaustive explicit intermediate format (e.g., Xml).
The implementation of the tool including all analyses was done rapidly thanks to the appropriateness of Open/Cæsar Apis to our Dfa problem encoding. Each Bes description is about 600 lines of C code. They are all used from a common part, namely the algorithm Analyse, which is about 2 000 lines of C code. Currently implemented analyses, accessible through command line parameters, should be suf- ficient for a basic use of Annotator. In order to extend the current tool with new analyses, one can think of three possibilities: first, a user could (graphically) specify the expected analysis as an implicit Bes, from which the tool would automatically generate the corresponding analysis module (following the same approach as [18]). Another possibility is to write the analysis as a μ-calculus formula, translated by the tool into a Bes (following the approach of [14]). Otherwise, the description of the Bes in a C file can also be considered. We expect that it should be possible to construct new analyses of comparable complexity in a matter of hours, now that the infrastructure is stable.

Experimentation
We performed several experiments to compare the results of our Dfas with those observed in the literature [15]. We considered twelve classical C program examples showing the interest of using one or the other Dfa to simplify the compilation of the program. We also performed a series of experiments for investigating the effectiveness of influence analysis [4, 5]. Besides Promela examples extracted from the literature [2], we also considered ten other C program examples specific for each one of the implemented influence analyses.
All abstract Cfgs, extracted from the examples, were explicitly described thanks to the Binary Coded Graph (Bcg) [8] format. Since their sizes were rather small, ex- periments returned immediate results allowing us to verify only functionality prop- erties of our prototype, but neither time nor memory statistics.
To show the applicability of our tool to a third specification language, we took a Lotos description of the Dekker mutual exclusion protocol 2 (89 lines of Lotos, 2 processes, 9 variables, 954 states, 1 908 transitions, and 17 labels) on which we tested the nine currently implemented Dfas. The first step was to automatically extract out of the specification a specific Petri net, called network, that can be fur- ther processed to obtain a Cfg of the protocol (25 states, 134 transitions) [9]. The graph was then transformed into our abstract model, by appropriately relabeling the transitions. Finally, the resulting abstract Lts was processed by Annotator. From the results, we conclude that, among the nine variables present in the specifi- cation, none of them were live at all states. This means that an explicit verification of the program can ignore many variables in the state vector at different control point without loosing any information relevant for a formula to be evaluated (as

2 http://www.inrialpes.fr/vasy/cadp/demos

it is done with reset variables analysis [9]). With respect to reaching definitions analysis, 162 program definitions were tested. We have observed that numerous definitions are reaching a majority of the states. Hence, using the set of reaching definitions, a compiler should perform an efficient constant propagation. Finally, among the ten tested program expressions, none of them were neither available at any state, nor very busy at states different from their first use. As a consequence, common sub-expressions cannot be eliminated in the protocol, and code hoisting would be useless. To show the scalability of Annotator, we have been successfully experimenting the tool on very large Cfgs, extracted from the Vlts benchmark 3 , with size up to 106 program counters and instructions, such as the vasy 65 2621 Lts (65 537 states, 2 621 480 transitions). Finally, the Annotator tool is available on http://www.lcc.uma.es/∼joubert/software.html#ANNOTATOR together with result files for all examples, including the Dekker mutual exclusion protocol.

Conclusion and future work
We presented encodings of four classical data flow analyses in terms of Bes reso- lution, and we automatized the program analysis process in conjunction with on- the-fly verification tools. The on-the-fly static analyser Annotator was developed using the Open/Cæsar environment [7] of the Cadp [8] toolbox. It implements static analyses of an application-independent representation of programs given as an Lts. The tool currently offers nine Dfas using optimised Bes resolution algo- rithms. The experiments carried out using this tool on numerous standard examples assess the functionality of the static analysis, and demonstrate that the modular architecture of the tool allows a rapid integration of new static analyses described as Bes resolutions, and a quick connection to existing compilers.
Although our initial goal was to extend compilers with data flow analysis algo- rithms based on model checking, a future work will consist in directly applying the technique on the compiler for certifying it. We also plan to continue our work along two additional directions. First, we would like to show the impact of automatic abstract matching on the explored state space size during verification of programs
described in C code, thanks to the compiler C.Open proposed in [6].  To this
purpose, the static analysis resulting from the interconnection of Annotator and C.Open into Cadp could then be integrated to the model extractor SocketMC [3]. Finally, we will seek solutions to other static analysis problems, such as reset vari- ables analysis [9], by investigating their translation in terms of Bes resolution, and by studying the a priori natural and efficient connection of existing compilers to our abstract Cfg model.

References
Andersen, H. R., Model checking and boolean graphs, Theoretical Computer Sci. 126 (1994), pp. 3–30.

3 http://www.inrialpes.fr/vasy/cadp/resources/benchmark bcg.html


C´amara, P., M. Gallardo and P. Merino, Abstract matching for software model checking, in: A. Valmari, editor, Proceedings of the 13th International SPIN Workshop on Model Checking of Software SPIN’06 (Vienna, Austria), LNCS 3925 (2006), pp. 182–200.
Camara, P., M. Gallardo, P. Merino and D. San´an, Model checking software with well-defined apis: the socket case, in: S. Gnesi, T. Margaria and M. Massink, editors, Proceedings of the 10th International Workshop on Formal Methods for Industrial Critical Systems FMICS’2005 (Lisbon, Portugal) (2005),
pp. 17–26.
Gallardo, M., C. Joubert and P. Merino, Implementing influence analysis using parameterised boolean equation systems, in: Proceedings of the 2nd International Symposium on Leveraging Applications of Formal Methods, Verification and Validation ISOLA’06 (Paphos, Cyprus) (2006).
Gallardo, M., C. Joubert, P. Merino and D. San´an, On-the-fly API influence analysis of software, in:
P. Merino and M. Bakkali, editors, Proceedings of the 2nd International Conference on Science and Technology JICT’07 (Ma´laga, Spain) (2007).
Gallardo, M., P. Merino and D. San´an, Towards model checking c code with open/cæsar, in: J. Barjis,
U. Ultes-Nitsche and J. C. Augusto, editors, Proceedings of the 4th International Workshop on Modelling, Simulation, Verification and Validation of Enterprise Information Systems MSVVEIS’2006 (Paphos, Cyprus) (2006), pp. 198–201.
Garavel, H., Open/cæsar: An open software architecture for verification, simulation, and testing, in:
B. Steffen, editor, Proceedings of the First International Conference on Tools and Algorithms for the Construction and Analysis of Systems TACAS’98 (Lisbon, Portugal), LNCS 1384 (1998), pp. 68–84.
Garavel, H., F. Lang and R. Mateescu, An overview of CADP 2001, Europ. Assoc. for Soft. Sci. and Tech. (EASST) Newsletter 4 (2002), pp. 13–24.
Garavel, H. and W. Serwe, State space reduction for process algebra specifications, Theoretical Computer Science 351 (2006), pp. 131–145.
Joubert, C. and R. Mateescu, Distributed on-the-fly model checking and test case generation, in:
A. Valmari, editor, Proceedings of the 13th International SPIN Workshop on Model Checking of Software (SPIN’06), LNCS 3925 (2006), pp. 126–145.
Lamprecht, A.-L., T. Margaria and B. Steffen, Data-flow analysis as model checking within the jabc, in: A. Mycroft and A. Zeller, editors, Proceedings of the 15th International Conference on Compiler and Construction CC’2006 (Vienna, Austria), LNCS 3923 (2006), pp. 101–104.
Mader, A., “Verification of Modal Properties Using Boolean Equation Systems,” VERSAL 8, Bertz Verlag, Berlin, 1997.
Mateescu, R., Local model-checking of an alternation-free value-based modal mu-calculus, in: A. Bossi,
A. Cortesi and F. Levi, editors, Proceedings of the 2nd International Workshop on Verication, Model Checking and Abstract Interpretation VMCAI’98 (Pisa, Italy), University Ca’ Foscari of Venice, 1998.
Mateescu, R., Caesar solve: A generic library for on-the-fly resolution of alternation-free boolean equation systems, Springer Int. J. on Soft. Tools for Tech. Trans. (STTT) 8 (2006), pp. 37–56.
Nielson, F., H. Nielson and C. Hankin, “Principles of Program Analysis,” 2005.
Schmidt, D. A., Data flow analysis is model checking of abstract interpretations, in: Proceedings of the 25th ACM SIGPLAN-SIGACT symposium on Principles of programming languages POPL’98 (San Diego, USA) (1998), pp. 38–48.
Steffen, B., Data flow analysis as model checking, in: T. Ito and A. R. Meyer, editors, Proceedings of the International Conference on Theoretical Aspects of Computer Software TACS’91 (Sendai, Japan), LNCS 526 (1991), pp. 346–365.
Steffen, B., Generating data flow analysis algorithms from modal specifications, Science of Computer Programming 21 (1993), pp. 115–139.
