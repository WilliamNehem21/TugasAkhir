 Electronic Notes in Theoretical Computer Science 91 (2004) 158–170 
www.elsevier.com/locate/entcs




CHR: A Constructive Relevant Natural-deduction Logic
Neil Leslie 1 ,2
Centre for Logic, Language and Computation & School of Mathematical and Computing Sciences Victoria University of Wellington
Wellington, New Zealand
Edwin D Mares3
Centre for Logic, Language and Computation &
School of History, Philosophy, Political Science and International Relations Victoria University of Wellington
Wellington, New Zealand

Abstract
In this paper we develop a natural-deduction logic which is both constructive and relevant. We use a proof-theoretic argument to justify the rules of the logic. The detailed framework we use to develop our system is modeled on that used to develop Martin-Lo¨f’s Type Theory.
Keywords: Relevant logic, Constructive logic, Proof theory, Natural deduction


Introduction and outline
In this paper we develop a natural-deduction logic which is both constructive and relevant. We use a proof-theoretic argument, in the style of Dummett [6] and Prawitz [15], to justify the rules of the logic.

1 We would like to thank the anonymous referees for their helpful comments.
2 Email: Neil.Leslie@vuw.ac.nz
3 Email: Edwin.Mares@vuw.ac.nz



1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2003.12.011

The informal motivation behind relevant logic is to have a notion of valid argument which requires that the premisses really be used to infer the con- clusion [10]. This imposes restrictions on the form of acceptable proofs in a natural deduction system for a relevant logic. The informal motivation behind constructive logic is that arguments should be effective [5]. This condition also imposes a restriction on the form of acceptable proofs. In both cases we are concerned not merely with what we can prove, but also in how we prove it.
The framework we use to develop our system is modeled on that used to develop Martin-Lo¨f’s Type Theory [11,12]. In using the Curry-Howard analogy to analyse the implicational fragments of relevant logics we follow the lead of Gabbay and de Queiroz [7], Helman [2], Meyer, Bunder and Powers [13], and Restall [17]. Furthermore, the use of the Curry-Howard analogy makes this work applicable to programming languages. The notion of relevance in a proof is related to the notion of strictness of a function [2,3,4].
The paper develops as follows.
In Section 2 we outline the Brouwer-Heyting-Kolmogorov (BHK) [9] inter- pretation of intuitionistic logic, and the related proof-theoretic justification of the logical laws. We pay particular attention to the Curry-Howard terms.
In Section 3 we introduce CHR. For brevity, we only present the proposi- tional fragment.
In Section 4 we outline the proper proof reductions required to show that
CHR proofs are normalisable.
In Section 5 we outline the proof that CHR is a relevant logic.
In Section 6 we present some derivations in CHR.
Our conclusions are presented in Section 7.

Proof-theoretical justifications of the logical laws
We shall only outline the main points of the process that one goes through to give a proof-theoretical justifications of the logical laws. This process is dealt with with in more detail and with more care by, in particular, Michael Dummett and Dag Prawitz (see, for example, [5,6,15]). The process we use differs slightly from that described by Dummett.
The argument usually take some rules as being “self-evident”, typically single-ended introduction rules meeting the complexity condition [8,6].
These rules alone do not define the meanings of the logical constants. We make two observations. First, consider tonk [16]. The constants tonk and
∨ share the same introduction rules, but not the same meaning. Second,

the meanings of the constants of NK and NJ must be different. But, as Gentzen [8] points out, NK is NJ + DN. DN is certainly not an introduction rule.
We claim that the solution for constructivists is to seek harmony in com- putation [5,12,15]. Formally, in Martin-L¨of’s Type Theory we use the com- putation rules to further specify the meanings of the connectives.
The form of the elimination rule for each connective is then defined by the combination of introduction and computation rules.
Consequently we will present slightly different computation rules from those used for intuitionistic logic, and hence produce a natural constructive rele- vant logic.
So, the pattern for each connective we deal with will be:
introduction rule or rules, taken as self-evident;
computation rule or rules, taken to embody relevance;
elimination rule, drawn from the introduction and computation rules.
This pattern is just that used when presenting Martin-L¨of’s Type Theory [11,14]. Our syntax is presented using aritied expressions, as used by Martin- L¨of. The detailed development of a theory of aritied expressions is given in [14], and we will not repeat this here. Similarly our inference rules are presented in a natural deduction format modeled on that of [11]. Our computation rules also follow the format of those in [11].
The following table gives the BHK interpretation of intuitionistic proposi- tional logic. The direct proof tells us what the introduction rule or rules will look like, and the Curry-Howard terms provide us with formal proof objects for valid propositions. Another way to see the Curry-Howard terms is that they are labels which just name the proof. This table is really the starting point for the proof-theoretical justification of the laws of intuitionistic logic, and forms the basis for extending this technique to other logics.

We employ the following definition:
¬A =def A ⊃⊥
Curry-Howard Relevant logic: CHR
Now we start to develop CHR. The obvious starting point is that proofs of relevant implications are strict functions. By this we mean that we can only abstract over variables which actually occur inside the term. Note that this is not exactly the notion of strictness used in functional programming where we treat strictness of a function f as the property that f (⊥) is equal to ⊥, where
⊥ here is a non-terminating term.
Relevant implication
rel
For clarity, we use −→ for relevant implication and λs for strict function
abstraction. Figure 1 is then the introduction rule for relevant implication.
Notice the side-condition.
[x : A]
·
·
·
b(x): B

rel
λs(b): A −→ B
Side condition: b(x) is strict in x.
Fig. 1. Relevant implication introduction

We can see that there is no normal proof 4 of
rel
rel
. Figure 2 is

A −→ B −→ A
a normal-form proof of A ⊃ B ⊃ A in intuitionistic logic, where we see that the formal proof object involves vacuous abstraction.
[x : A]1
⊃ I
λ((y)x): B ⊃ A	⊃ I1
λ((x)λ((y)x)) : A ⊃ (B ⊃ A)
Fig. 2. A non-relevant proof
The rule for funsplit computation is given by Figure 3 5 .

4 Of course this does not preclude their being a proof with a detour, as we have not yet proved that all proofs are normalisable.
5 We have an η rule at the level of syntax, so b is syntactically equal to (x)b(x) (x not
free in b) [14]. In practice, one only ever abstracts over one of the arguments to a non-



f −→ λs(b)	d(b) −→ d'

funsplit(d, f ) −→ d'
funsplit Comp.

Fig. 3. funsplit computation
rel
The rule for −→ elimination, following the pattern of Π-elimination from
[11], is given by Figure 5.




rel
f : A −→ B
[y(x): B[x : A]]
·
·
·
a(y): C  rel
−→ Elim.

funsplit(a, f ): C

rel
Fig. 4.	elimination
We can make the following definition:
apply(f, x) =def funsplit((y)(y(x)),f )
Figure 5 shows how we evaluate apply(f, a). Evaluation of b(a) will involve evaluation of a.

b(a) −→ c

f −→ λs(b)	(y)(y(a))b −→ c


≡,β 
funsplit Comp.

funsplit((y)(y(a)),f ) −→ c

apply(f, a) −→ c
=def

Fig. 5. Evaluating apply(f, a)
rel
We can use apply to give ourselves a derived elimination rule for −→, after
the fashion of Modus Ponens. We use this rule in Figures 27, 28, 29, 31, and
rel
32, where we label it −→ E’.
Conjunctions
We have both an intensional and an extensional conjunction. Figure 6 is the rule for intensional conjunction introduction. There is no side-condition on this rule.
Figure 7 is rule for extensional conjunction introduction. This rule has the side condition that the proofs of both conjuncts share the same free variables.

canonical constant, the one which has the type being eliminated. If this is the right-most argument we can make expressions less cluttered. Hence, for all the non-canonical constants we adopt the convention that the argument which has the type being eliminated appears

a : A	b : B

⟨a, b⟩ : A • B
Fig. 6. Intensional conjunction introduction
a : A	b : B

pair(a, b): A ∧ B
Side condition: FV(a)= FV(b).
Fig. 7. Extensional conjunction introduction
The difference between • and ∧ is further shown in the elimination rules, and this reflects the difference in the computation rules for the two kinds of splitting we have. The rule for spliti computation is given in Figure 8, and the rule for splite computation is given in Figure 9. The difference comes about from whether c is strict or not.
p −→ ⟨a, b⟩	a −→ a'	b −→ b'	c(a', b') −→ c'

spliti(c, p) −→ c'
Fig. 8. spliti computation
spliti Comp.



p −→ pair(a, b)	c(a, b) −→ c'

splite(c, p) −→ c'
splite Comp.

Fig. 9. splite computation

Figures 10 and 11 are the elimination rules for • and ∧, respectively. In
elimination the side-condition is that c is strict in both its arguments, in ∧
elimination c may be non-strict in both arguments.
[x : A, y : B]
·
·
·

p : A • B
c(x, y): C
Elim.

spliti(c, p): C
Side condition: c is strict in both arguments.
Fig. 10. • elimination
Figure 12 is a derivation of A ∧ B ▶ A • B.

as the right-most argument.





p : A ∧ B
[x : A, y : B]
·
·
·
c(x, y): C



splite(c, p): C
Fig. 11. ∧ elimination
∧ Elim.

p : A ∧ B	[x : A]1

splite((x, y)x, p): A
p : A ∧ B	[y : B]2
∧ E.1		 ∧ E.2
splite((x, y)y, p): B

⟨splite((x, y)x, p), splite((x, y)y, p)⟩ : A • B
Fig. 12. A ∧ B ▶ A • B
I.

We can show now that there is no normal proof of A • B ▶ A ∧ B. Such a proof would either be like Figure 13 or Figure 14. Figure 13 fails because the free variables differ, Figure 14 fails because of the strictness condition.
[x : A]1	[y : B]1

p : A • B
pair(x, y): A ∧ B
∧ I.
E.1

spliti((x, y)pair(x, y), p): A ∧ B
Fig. 13. A non-proof of A • B ▶ A ∧ B


p : A • B	[x : A]1

spliti((x, y)x, p): A
p : A • B	[y : B]2
E.1		 • E.2
spliti((x, y)y, p): B

pair(spliti((x, y)x, p), spliti((x, y)y, p)) : A ∧ B
Fig. 14. Another non-proof of A • B ▶ A ∧ B
∧ I.


Disjunction
The rules for ∨ introduction are given in Figures 15 and 16, and the compu- tation rules for when are given by Figures 17 and 18.
a : A



inl(a): A ∨ B
∨ I l 

Fig. 15. ∨ Intro L
Figure 19 is the elimination rule for ∨. This rule has the the side condition that d and e are strict. We may also add the side condition that FV(d)= FV(e) to enable us to prove that CHR is a relevant logic in the sense of Anderson and



b : B


inr(b): A ∨ B
∨ I r 

Fig. 16. ∨ Intro R
f −→ inl(l)	d(l) −→ d'

when(d, e, f ) −→ d'
when Comp

Fig. 17. when computation 1
f −→ inr(r)	e(r) −→ e'

when(d, e, f ) −→ e'
when Comp

Fig. 18. when computation 2
Belnap [1]. We do not, however, know that any irrelevances are derivable if this side condition is omitted. Thus we assume the side-condition henceforth.



f : A ∨ B
[x : A]
·
·
·
d(x): C
when(d, e, f ): C
[y : B]
·
·
·
e(y): C
∨ E

Side condition: d and e are strict
Fig. 19. ∨ elimination


The absurd
There is no introduction rule for ⊥. The computation rule for case{} is given by Figure 20, and the elimination rule for ⊥ by Figure 21.
e −→ e'

case{}
(f ) −→ e' case{} Comp

Fig. 20. case{} computation

f :⊥
⊥ E
case{}(f ): C
Fig. 21. ⊥ elimination
Relevant negation can then be defined in the expected way.

Proof reductions
The normalisation theorem states that a proof with a maximum formula can be converted into a proof of the same thing without a maximum formula. We present the proper proof reductions which give us the core of the normalisation procedure. For brevity we do not present the commuting conversions. As usual we define a single-step of reduction, d1, whose reflexive, transitive closure, d∗, is confluent. The relation d1 is derived from the computation rules, of course. The single-step reductions on proof fragments are given in Figures 22 to 26. Again, for brevity, we do not show the confluence of d∗ here.

[x : A]
·
·
[y(z): B[z : A]]
·
·

[b(x): B[x : A]]
·

·
rel
·	d1	·

λs(b): A −→ B
d(y): C
·
d(b): C

funsplit(d, λs(b)) : C

rel
Fig. 22. Removing a	maximum


·
·
·
a : A
·
·
·
b : B
[x : A, y : B]
·
·
·	d1
·
·
·
a : A	·
·
·
·
b : B

⟨a, b⟩ : A • B
d(x, y): C	·

spliti(d, ⟨a, b⟩): C
d(a, b): C

Fig. 23. Removing a • maximum


·
·
·
a : A
·
·
·
b : B
[x : A, y : B]
·
·
·	d1
·
·
·
a : A	·
·
·
·
b : B

pair(a, b): A ∧ B
d(x, y): C	·

splite(d, pair(a, b)) : C
d(a, b): C

Fig. 24. Removing a ∧ maximum


CHR is a relevant logic
In this section we outline a proof that CHR is a relevant logic in the sense of Anderson and Belnap [1]. To prove this we simply assign a distinct number to each variable which occurs in any proof object in a CHR proof. We then replace each proof object with the set of numbers that occur in it. By a simple



·
·
·
a : A
[x : A]
·
·
·
[y : B]
·
·
·	d1

a : A
·
·


inl(a): A ∨ B
d(x): C
e(y): C
·
d(a): C

when(d, e, inl(a)) : C
Fig. 25. Removing a ∨ left maximum


·
·
·
b : B
[x : A]
·
·
·
[y : B]
·
·
·	d1

b : B
·
·


inr(b): A ∨ B
d(x): C
e(y): C
·
e(b	C

): 
when(d, e, inr(b)) : C
Fig. 26. Removing a ∨ right maximum
induction over the complexity of proofs, we can show that the re-annotated proofs are notational variants of proofs in Anderson and Belnap’s natural deduction system for their logic R of relevant implication [1].
By a slightly more involved process we can show that the set of theorems of CHR is just the set of theorems of the logic LR of Thistlewaite, Meyer and McRobbie [18].

Examples
In Figures 27 to 32 we give examples of some CHR proofs. The theorems proved are:

rel
rel
rel

• Fig. 27 (A • B) −→ C ▶ A −→ (B −→ C)

rel
rel
rel

• Fig. 28 A −→ (B −→ C) ▶ (A • B) −→ C

rel
rel
rel
rel

Fig. 29 A −→ (B −→ C) ▶ B −→ (A −→ C)
Fig. 30 A • B ▶ B • A
rel	rel
Fig. 31 (B • A) −→ C ▶ (A • B) −→ C

rel
rel
rel

Fig. 32 A −→ (A −→ B) ▶ A −→ B

Conclusions
We have presented CHR a constructive, relevant natural-deduction logic. We have justified the rules of the logic an a proof-theoretic fashion, based on the



[x : A]1	[y : B]2
I


rel

⟨x, y⟩ : A • B	f : (A • B) −→ C  rel
−→ E’
apply(f, ⟨x, y⟩): C	rel
−→ I 2
rel
λs((y)(apply(f, ⟨x, y⟩))) : B −→ C	rel
−→ I 1
rel	rel
λs((x)λs((y)(apply(f, ⟨x, y⟩)))) : A −→ (B −→ C)

rel
rel
rel

Fig. 27. (A • B) −→ C ▶ A −→ (B −→ C)

[x : A]2	f :
rel
A −→
rel
(B −→ C)

rel
−→ E’

[y : B]2
apply(f, x): 
rel

B −→ C rel

1	−→ E’

[p : A • B]
apply(apply(f, x), y): C
E2

spliti((x, y)(apply(apply(f, x), y))), p): C	rel
−→ I 1
rel
λs(spliti((x, y)(apply(apply(f, x), y)))) : (A • B) −→ C


rel
rel
rel

Fig. 28. A −→ (B −→ C) ▶ (A • B) −→ C

[x : A]2	f :
rel
A −→
rel
(B −→ C)

rel
−→ E’

[y : B]1
apply(f, x): 
rel

B −→ C rel
−→ E’
apply(apply(f, x), y): C	rel
−→ I 2
rel
λs((x)(apply(apply(f, x), y))) : A −→ C	rel
−→ I 1
rel	rel
λs((y)(λs((x)(apply(apply(f, x), y))))) : B −→ (A −→ C)

rel
rel
rel
rel

Fig. 29. A −→ (B −→ C) ▶ B −→ (A −→ C)
[y : B]1	[x : A]1

p : A • B
⟨y, x⟩ : B • A
I
E1

spliti((x, y)⟨y, x⟩, p): B • A
Fig. 30. A • B ▶ B • A
notion that relevant proof is captured by strict computation. The system we have produced is clear and simple. The proof rules are natural to use, as we have shown in examples. We have outlined how this logic relates to other relevant logics. Because we have developed this logic as a type theory, there is a natural computer science interpretation of propositions in this logic as




[p : A • B]1
[y : B]2	[x : A]2
I
⟨y, x⟩ : B • A	2

E	rel
spliti((x, y)⟨y, x⟩, p): B • A	f : (B • A) −→ C  rel
−→ E’
apply(f, spliti((x, y)⟨y, x⟩, p)) : C	rel
−→ I 1
rel
λs((p)apply(f, spliti((x, y)⟨y, x⟩, p))) : (A • B) −→ C

rel	rel
Fig. 31. (B • A) −→ C ▶ (A • B) −→ C


[x : A]1	f :
rel
A −→
rel
(A −→ B)

rel
−→ E’

[x : A]1
apply(f, x): 
rel

A −→ B rel
−→ E’
apply(apply(f, x), x): B	rel
−→ I 1
rel
λs((x)(apply(apply(f, x), x))) : A −→ B


rel
rel
rel

Fig. 32. A −→ (A −→ B) ▶ A −→ B
specifying strict functions.

References
Anderson, Alan Ross and Nuel D Belnap, Jr, Entailment: The Logic of Relevance and Necessity Volume 1. Princeton University Press, Princeton, New Jersey, USA, 1975.
Anderson, Alan Ross, Nuel D Belnap, Jr and J. Michael Dunn, Entailment: The Logic of Relevance and Necessity, Volume 2. Princeton University Press, Princeton, New Jersey, USA, 1992.
Baker-Finch, Clement A.,  Relevant logic and strictness analysis.  In Workshop on Static Analysis, LaBRI, Bordeaux, pages 221–228. Bigre 81–82, 1992. Available from http://cs.anu.edu.au/~Clem.Baker-Finch/Research/rlsa/, August 2003.
Baker-Finch, Clement A., Relevance and contraction: A logical basis for strictness and sharing analysis. Technical Report ISE RR 34/94, University of Canberra, 1993. Available from http://cs.anu.edu.au/~Clem.Baker-Finch/Research/rcss/, August 2003.
Dummett, Michael, The philosophical basis of intuitionistic logic. In Truth and Other Enigmas, pages 215–247. Duckworth, London, England, 1978. First published in H. E. Rose and J. C. Shepherdson, editors, Logic Colloquium ’73, North-Holland, Amsterdam, The Netherlands,1975.
Dummett, Michael, The Logical Basis of Metaphysics. Duckworth, London, England, 1991.
Gabbay, Dov M. and Ruy J G B de Quieroz, Extending the Curry-Howard interpretation to linear, relevant and other resource logics. Journal of Symbolic Logic, 57(4):1319–1365, 1992.
Gentzen, Gerhard, Investigations into logical deduction. In M E Szabo, editor, The Collected Papers of Gerhard Gentzen, pages 68–131. North-Holland, Amsterdam, The Netherlands, 1969.


Kolmogorov, Andrei, On the interpretation of intuitionistic logic. In Paulo Mancosu, editor, From Brouwer to Hilbert The Debate on the Foundations of Mathematics in the 1920s, pages 324–334. Oxford University Press, Oxford, England, 1998. Originally published in German as Zur Deutung der intuitionistichen Logik, Mathematische Zeitschrift 35:58–65, 1932.
Mares, Edwin, D., Relevance logic. In Dale Jacquette, editor, A Companion to Philosophical Logic, chapter 38, pages 609–627. Blackwell, Oxford, England, 2002.
Martin-Lo¨f, Per, Intuitionistic Type Theory, volume 1 of Studies in Proof Theory Lecture Notes. Bibliopolis, Napoli, Italy, 1984. Notes taken by Giovanni Sambin from a series of lectures given in Padua, June 1980.
Martin-Lo¨f, Per, On the meanings of the logical constants and the justifications of the logical laws. Nordic Journal of Philosophical Logic, 1(1):11–60, 1996. Originally presented at the meeting Teoria della Dimostrazione e Filosofia della Logica, Siena 6–9 April, 1983.
Meyer, Robert K., Martin W Bunder and Larry Powers, Implementing the ‘Fool’s model’ of combinatory logic. Journal of Automated Reasoning, 7:597–630, 1991.
Nordstr¨om, Bengt, Kent Petersson and Jan M Smith, Programming in Martin-Lo¨f ’s Type Theory An Introduction. Clarendon Press, Oxford, England, 1990.
Prawitz, Dag, Meaning and proofs: on the conflict between classical and intuitionistic logic.
Theoria, 77(1):1–40, 1977.
Prior, Arthur, N., The runabout inference-ticket. Analysis, 21:38–39, 1960.
Restall, Greg, An Introduction to Substructural Logics. Routledge, London, England, 2000.
Thistlewaite, Paul B., Michael A McRobbie and Robert K Meyer, Automated theorem-proving in non-classical logics. Research notes in theoretical computer science. Pitman, London, 1988.
