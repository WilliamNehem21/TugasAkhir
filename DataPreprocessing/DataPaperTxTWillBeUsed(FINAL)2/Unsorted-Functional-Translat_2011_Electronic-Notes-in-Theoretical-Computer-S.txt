Available online at www.sciencedirect.com



Electronic Notes in Theoretical Computer Science 278 (2011) 3–16
www.elsevier.com/locate/entcs
Unsorted Functional Translations
Carlos Areces 1
FaMAF, Universidad Nacional de C´ordoba C´ordoba, Argentina
Daniel Gor´ın2
SKS – DFKI Bremen Bremen, Germany

Abstract
In this article we first show how the functional and the optimized functional translation from modal logic to many-sorted first-order logic can be naturally extended to the hybrid language H(@, ↓). The translation is correct not only when reasoning over the class of all models, but for any first-order definable class. We then show that sorts can be safely removed (i.e., without affecting the satisfiability status of the formula) for frame classes that can be defined in the basic modal language, and show a counterexample for a frame class defined using nominals.
Keywords: Automated theorem proving, functional translation, sorts.


Introduction
The functional translation is a tool for automated modal reasoning that appeared independently and almost simultaneously in a number of publications in the late 1980’s and early 1990’s (see, e.g. [12,13,6,20,3,4]). This translation maps formulas from modal languages to first-order logic in a satisfaction preserving way, much like the standard translation does (see [5]). But the functional translation uses a semantic alternative to relational structures, and it has been argued and empirically demonstrated, that it produces formulas that can be much more compact and with a shallower term structure than those obtained with the standard translation [15,9]. The two properties are crucial when attempting to use first-order automated rea- soning. Moreover, and unlike other satisfiability preserving translations tailored for automated reasoning (e.g., the layered translation of [1]), the functional translation

1 Email: carlos.areces@gmail.com
2 Email: daniel.gorin@dfki.de

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.10.002

can be used for reasoning over a wide range of model clases, beside the class of all models. The first result we discuss in this article is that the functional translation extends naturally to cover the hybrid language H(@, ↓) [2].
The functional translation is often introduced using a many-sorted first-order language to simplify presentation. This means, in practice, that we need to either use a theorem prover that handles many-sorted first-order logic (e.g., SPASS [19]) or simulate sorts in unsorted first-order logic introducing additional one-place predicate symbols. Both alternatives might have an impact on performance when we attempt to carry out automated theorem proving.
It is argued in [17], for example, that the simulation of sorts by way of proposition symbols leads to irrelevant inferences. A system like SPASS, avoids these inferences but, on the other hand, the additional complexity of the machinery needed to handle sorted inferences (in the case of SPASS, well-sorted uniﬁcation [18]) needs to be accounted for. It is difficult to properly measure whether sorts help or hinder automated theorem provers, and we will not pursue this matter here. Instead, we will show that in certain cases one can simply safely “erase” all sort annotations without changing the satisfiability status of the formula. That this can be done in the case of the basic modal logic (when reasoning over the class of all models) was already observed by Hustadt and Schmidt in [10], albeit without proof.
In Sections 2 and 3 we introduce the basic and the optimized functional transla- tions. To make the article self contained, we include the original proofs of soundness, with minor corrections and adaptations to accommodate nominals and other hy- brid machinery. Based on these proofs, we develop in Section 4 our main result: when reasoning over any modally definable class of models it is safe to erase sort annotations from formulas obtained using the (optimized) functional translation. In Section 5, on the other hand, we prove that sort erasure is not sound when reason- ing over a class that is definable by a pure, hybrid axiom, by providing a concrete counterexample.

Functional models, functional translation
Through all the article, we will work in the multi-modal hybrid language H(@, ↓). For a fixed signature consisting of a set of proposition symbols Prop, a set of nominals Nom and a set of relation symbols Rel, all pairwise disjoint, its formulas are given by:
ϕ ::= p | i | ¬ϕ | ϕ ∧ ϕ | @iϕ | ↓i.ϕ | [r]ϕ,
where p ∈ Prop, i ∈ Nom and r ∈ Rel. We shall freely employ the typical derived operators ∨, →, ⟨r⟩, etc. with their usual meaning.
For the semantics we take as models pairs ⟨I, g⟩, where I = ⟨W, ·I⟩ is a relational interpretation such that pI ⊆ W for p ∈ Prop, and rI ⊆ W × W , for r ∈ Rel; while g : Nom → W is an assignment for nominals. We can, then, give meaning to formulas of H(@, ↓) via the standard translation to first-order logic. That is, for

w ∈ W and j ∈ Nom not occurring in ϕ, we have:

j
I, g,w |= ϕ ⇐⇒ I |=FO STj(ϕ)[g ].	(1)
The standard translation commutes with boolean connectives and satisfies:
def	def
STj(p) = p(j)	STj(i) = i = j
def	def
STj(@iϕ) = STi(ϕ)	STj(↓i.ϕ) = ∃i.(i = j ∧ STj(ϕ))
def
STj([r]ϕ) = ∀k.(r(j, k) → STk(ϕ))	(k is fresh)
For a class of models C, ϕ is C-satisﬁable (C-valid, notation C |= ϕ) if for some model (for every model) ⟨I, g⟩ in C, I, g,w |= ϕ for some w (for all w). If C is the class of all models, we say that ϕ is satisﬁable (valid, notation |= ϕ). The underlying frame of a model ⟨I, g⟩ is the restriction of I to symbols in Rel (i.e., ignoring Prop). As it is standard in modal logic, we are usually interested in classes defined as those models whose underlying frame satisfy certain condition (e.g., transitivity). Any such class C is said to be defined by a formula ϕ whenever ⟨I, g⟩ is in C iff I, g,w |= ϕ for all
w. See [5] for details.
We can regard the standard translation as a direct encoding in first-order logic of the semantic clauses for the modal operators. The translation is very simple but it is, in general, not suitable for translation-based automated reasoning. It is easy to find simple modal formulas which, when translated into first-order logic using ST and then solved via resolution, result in infinite clause sets (see [1]). This is the main motivation for the, arguably more complex, functional translation we will describe below.
The key to understand the functional translation is an alternative representation of relational structures. Assume for a moment that Rel = {r}. Consider, then, Figure 1a which shows a relational structure with a domain consisting of three elements. One can alternatively represent this particular structure using three total functions f , g and h, and a predicate de, as long as the following property holds:
∀xy. r(x, y) ↔ (¬de(x) ∧ (f (x)= y ∨ g(x)= y ∨ h(x)= y)) .	(2) We use de (for “dead end”) to “mark” those states that have no r-successor, and
f , g and h on each state to “witness” each r-successor. There are many valid arrangements for f , g and h; Figures 1b and 1c show two such representations. It is straightforward to verify they both satisfy condition (2).
Proposition 2.1 Let I be a ﬁnite ﬁrst-order interpretation for a signature with a two-place relation symbol r. Then there exists an interpretation Ij extending I to a signature that additionally contains a one-place relation symbol de and unary function symbols f1, f2,..., fn, such that:
Ij |=FO ∀xy. r(x, y) ↔ (¬de(x) ∧ (f1(x)= y ∨ f2(x)= y ... ∨ fn(x)= y)) .



f	h








(a)
f, g

h
(b)
f, g, h	f
de
g
g, h	de
(c)

Fig. 1. Relational model (a) is expressed in (b) and (c) with functions f, g, h and a predicate de.
Functions f1, f2,..., fn can be alternatively represented using only one binary function f , that takes a function index as an additional argument. This is easily expressed in a language with two sorts ω and ι, the former will refer to proper nodes of the model, the latter to function indices.
Proposition 2.2 Let I be a sorted ﬁrst-order interpretation for a signature with a relation symbol of sort r : ω × ω. Then there exists an interpretation Ij extending I to a signature that additionally contains a relation symbol de : ω and a function symbol f : ι × ω → ω, such that:
∀xy:ω. r(x, y) ↔ (¬de(x) ∧ ∃z:ι.f (z, x)= y) .
Unlike Proposition 2.1, this encoding is suitable for infinite interpretations.
We now have everything in place to define a notion of functional model. First, to each choice of Prop and Rel we assign a functional (sorted) correspondence language with sorts ω and ι, where each p ∈ Prop and each der (r ∈ Rel) is a one-place predicate symbol of sort ω, and where there is a binary function symbol fr : ι×ω → ω for each r ∈ Rel.
Definition 2.3 [Functional models] A functional model is a many-sorted interpre- tation for the functional correspondence language, i.e., a structure I = ⟨W, I, ·£⟩ where W and I are non-empty domains for sorts ω and ι, respectively; p£ ⊆ W for every p ∈ Prop; and, for each r ∈ Rel, fr : I × W → W and der ⊆ W .
Clearly, every functional model induces a relational model such that for every relation r the following holds:
∀x, y:ω.r(x, y) ↔ (¬der(x) ∧ ∃z:ι.f (z, x)= y).	(3)
Therefore, we say that a functional model satisfies a modal formula ϕ if and only if its induced relational model satisfies ϕ. In Section 3 we will be interested in maximal models, that is, functional models where every possible function is realized.
Definition 2.4 [Maximal models] Consider a functional model I = ⟨W, I, ·£⟩ and let r£ be the relation induced by (3) for each r ∈ Rel. We say I is maximal if for each total function γ : W → W such that (w, γ(w)) ∈ r£ for all w ∈ W , there exists an i ∈ I for which fr(i, x)= γ(x), for all x.

Any functional model can be extended to a maximal one without changing the induced relational model. Hence:
Proposition 2.5 A formula of the basic modal logic is satisﬁable iff there exists a (maximal) functional Kripke model that satisﬁes it.
Putting all the pieces toghether, then, we can see the functional translation sim- ply as a “standard” translation to many-sorted first-order logic over the functional correspondence language.
Definition 2.6 [FT ] Let j be variable of sort ω occurring in a term t of the func- tional language. The functional translation to first-order logic FTt maps formulas of H(@, ↓) into first-order logic formulas in the functional correspondence language with a free j as follows (it commutes with boolean connectives):
def	def
FTt(p) = p(t)	FTt(i) = i = t
def	def
FTt(↓i.ϕ) = ∃i:ω.(i = t ∧ FTt(ϕ))	FTt(@iϕ) = FTi(ϕ)
def
FTt([r]ϕ) = ¬der(t) → ∀z:ι.FT fr (z,t)(ϕ)	(z is fresh)
Theorem 2.7 Let ϕ be a formula of H(@, ↓) and let i be a nominal not occurring in ϕ. Then the following hold:
|= ϕ iff |=FO ∀i:ω.FTi(ϕ).
ϕ is satisﬁable iff ∃i:ω.FTi(ϕ) is satisﬁable.
It is straightforward to see that Theorem 2.7 can be extended to the case where we are reasoning with respect to a first-order definable class of models. For example, suppose we require r to be interpreted as a transitive relation, which is expressible in first-order logic as ∀xyz.(r(x, y) ∧ r(y, z) → r(x, z)). By combining it with the equivalence (3) and performing some valid transformations we obtain the functional equivalent:
∀x:ω.(¬de(x) → ∀ab:ι∃c:ι.fr(b, fr(a, x)) = fr(c, x)).	(4)
The formula ϕ in H(@, ↓) will be satisfiable in the class of models where r is tran- sitive if and only if the conjunction of (4) and FT (ϕ) is satisfiable.
Optimized functional translations
Consider the following simple modal formula:
[r](p → ⟨r⟩p).	(5)
By Theorem 2.7, this formula is satisfiable if and only if its functional translation is satisfiable too:
∃i:ω.(¬de(i) → ∀y:ι.(p(f (y, i)) → (¬de(f (y, i)) ∧ ∃z:ι.p(f (z, f (y, i)))))).	(6)


w	w	w
		

p	p
(a)
p	f, g	f, g	p
(b)
p	f, g	f, g	p
(c)

Fig. 2. A model (a) for formula (5) and two models (b) and (c) for its functional translation

By skolemizing i and z we obtain the equisatisfiable formula:
¬de(c) → ∀y:ι.(p(f (y, c)) → (¬de(f (y, c)) ∧ p(f (g(y),f (y, c))))).	(7)
This formula contains two skolem symbols: a constant c and a unary function g. The so-called “optimized functional translation” [14] guarantees that only constants need to be introduced during skolemization. Because skolem functions may cause complex terms to be built up during resolution, the optimized translation may drastically reduce the saturation process. Moreover, this simplifies the development of terminating resolution strategies [16].
To illustrate the idea behind the optimized translation, let us consider again formula (5). Figure 2a shows a model that satisfies (5) at node w. Figure 2b, on the other hand, shows a functional model for (7). It is easy to verify using (3) that this model induces the one of Figure 2a.
Observe now that if i is interpreted as w (notation: i '→ w) there are two possible values for y, namely f and g. If y '→ f , then we must pick z '→ f , while for y '→ g we must select z '→ g. Therefore, the right value for z is effectively a function of y, as witnessed by the skolemization. But here comes the interesting part: we can “rearrange” the assignment of functions in a way that makes the choice of z independent of y. An example is shown in Figure 2c; this model also induces (a) but here the right choice is z '→ g independent of the value of y. In maximal models (cf. Definition 2.4) where all possible “rearrangement” of functions are included, it is always possible to make the interpretation of each variable independent of the others.
Ohlbach and Schmidt [14] take advantage of this observation and prove that it is sound, in terms of satisfiability, to swap two consecutive quantifiers. Therefore one can take a formula obtained using the basic functional translation and simply make all the existential quantifiers come before universal ones, effectively avoiding the introduction of skolem functions. This is exactly what the optimized functional translation does.
Definition 3.1 The optimized functional translation to first-order logic OFT is defined as OFTj(ϕ)= ϑ(FTj(ϕ)), where ϑ(γ) takes γ to prenex normal form and moves all existential quantifiers of sort ι to the front.

The soundness of this translation follows from the next proposition [14].
Proposition 3.2 If γ is a formula in prenex normal form with a quantiﬁer-free matrix δ and γ is equivalent to the functional translation of a modal formula, then γ is satisﬁable iff ∃x:ι∀y:ιδ is satisﬁable too, where all the x and y are existentially and universally quantiﬁed, respectively, in γ.
We will follow the proof given in [14] to verify that the result also holds in the hybrid case. The proof uses a syntactic invariant which functionally translated terms possess, known as “prefix stability” [12] or “unique path property” [4]. Intuitively, what this property says is that we can build a tree (or a forest) out of the set of terms and subterms occurring in a formula such that: i) nodes of the tree are terms,
ii) arcs are labeled with variables of sort ι, iii) t1 is the father of t2 using an arc labeled by y iff t2 = fr(y, t1) for some r ∈ Rel, and iv) every variable of sort ι labels only one arc.
Definition 3.3 [Prefix stability] We say a formula γ is preﬁx-stable if, given the set Tγ of all the terms occurring in γ, it holds that for every variable y of sort ι in Tϕ, there exist a term t and a function symbol f such that if y occurs in a term in Tϕ, then every occurrence of y is of the form f (y, t). We will call f (y, t) the context of y in ϕ.
As an example, consider the variable y that occurs in the functional translation of (5): all its occurrences have the same context, namely, f (y, x). It is straightfor- ward to see that this property follows from the way functional terms are built in the translation.
This syntactic property has a semantic counterpart. Suppose, again, that all occurrences of a variable y of sort ι are in the context f (y, t) for fixed t and f . Then, for any functional model, the function “indexed” by y will be relevant only to determine successors of (the interpretation of) t. This is formally expressed in the following lemma.
Lemma 3.4 Let γ be a preﬁx-stable formula in the functional correspondence lan- guage and let y be a free variable in γ that occurs in context fr(y, t), with all the variables in t free in γ. Furthermore, let I = ⟨W, I, ·£⟩ be a functional model, g a (sorted) assignment and a, b ∈ I such that f£ (a, g(t)) = f£ (b, g(t)), where g(t) is
r	r
the interpretation of term t using I and g. Then we have:

I |=FO
γ[gy] ⇐⇒ I |=
γ[gy]

Proof. The proof is by induction on γ. We look only at the base case. Assume
γ is of the form p(tj), with fr(y, t) a subterm of tj. Let us define ga = gy and
gb = gy. The first thing to observe is that because y does not occur in t, we have ga(t) = gb(t) = g(t). Therefore, we also have ga(fr(y, t)) = gb(fr(y, t)). Finally, again because of prefix-stability, we know there is no other occurrence of y in tj and, therefore, ga(tj)= gb(tj), from which the expected result follows. An analogous reasoning can be used to handle the case where ϕ is an equality of the form t1 = t2. The inductive cases follow simply by inductive hypothesis.	2

This lemma is a corrected version of Lemma 4.6 in [14]. Indeed, in [14] variables
y
in t are explicitly allowed to occur bound in γ, but in that case whether I |=FO γ[g ]
holds need not depend on the value of f£ (a, g(t)). 3 In any case, using Lemma 3.4
one can prove the following result (cf. [14, Theorem 4.7 ]).
Theorem 3.5 Let γ be a preﬁx-stable formula in the functional correspondence language and let y be a free variable in γ that occurs in context fr(y, t), with all the variables in t free in ϕ. Finally, let I = ⟨W, I, ·£⟩ be a maximal functional model. Then, for every assignment g we have:
I |=FO ∀x1 ... xk:ι∃y:ι.γ[g] ⇐⇒ I |=FO ∃y:ι∀x1 ... xk:ι.γ[g].
Proof. The right-to-left implication is already valid in the general case, so we only have to consider the left-to-right one. Suppose, then, that the antecedent holds.  This means there must exist some function α : Ik → I such that,

I |=
γ[gx1 .. .xk y
] holds, for every a1 ... ak ∈ I.	Now, let b ∈ I be

FO	a1	ak α(a1...ak)
such that, f£ (b, gj(t)) = α(a1 ... ak) for gj = gx1 .. .xk .	Such a b must exist
r	a1	ak
since I is a maximal model. Therefore, using Lemma 3.4 we may conclude that

I |=FO
γ[gjy] must hold. But since b is independent of a1 ... ak, we finally obtain

that I |=FO ∃y:ι∀x1 ... xk:ι.γ[g].	2
Theorem 3.6 Let ϕ be an H(@, ↓)-formula and let i be a nominal not occurring in ϕ. Then the following hold:
|= ϕ iff |=FO ∀i:ω.OFTj(ϕ).
ϕ is satisﬁable iff ∃i:ω.OFTi(ϕ) is satisﬁable.
Proof. It is enough to prove that FTi(ϕ) is satisfiable iff ϑ(FTi(ϕ)). The right- to-left implication is valid in general. For the, other direction, suppose then that I |=FO FTi(ϕ)[g] for some I and g. Without loss of generality, we may assume that I is maximal. Let ψ be the result of taking OFTi(ϕ) and moving all existential quantifiers of sort ι after every universal quantifier. Observe that FTi(ϕ) → ψj is universally valid, and, therefore, I |=FO ψ[g]. Now, using Theorem 3.5, we can move every existential quantifier in ψ to the front, one at a time (for there must always exist one such that its bound variable y occurs in a context fr(y, t) and all the variables in t are either universally quantified or their existential quantifiers have been moved to the top already). This process can be repeated only finitely many times and the resulting formula ψj satisfies I |= ψj[g] and is equivalent to ϑ(FTi(ϕ)).	2
The above proof only requires that a maximal model always exists for a sat- isfiable formula. This means that the optimized functional translation also works when we are interested in satisfiability with respect to a first-order definable frame condition.
3 For a counterexample, take £ = ⟨{u, v}, {a, b}, ·I ⟩, f I (u, a) = f I (v, a) = f I (u, b) = v, f I (v, b) = u,
r	r	r	r
pI = {v}; g(w)= v, g(z)= b and γ = 6z:ι.p(fr (y, fr (z, w))), with t = fr (z, w).

Sort erasure on modally definable classes of models
We are ready to discuss the soundness of the erasing sort annotations from the functional translations. Intuitively, what we need to see is that every satisfiable, functionally translated formula is satisfied by a functional model ⟨W, I, ·⟩ where the cardinalities of W and I match. Only maximal models pose a problem here, but we will see that closure under disjoint unions guarantees that one can raise the cardinality of W when needed.
Let us start by properly formalizing what we mean by sort erasure.
Definition 4.1 The sort erasure transformation (·)— takes a many-sorted first- order formula and eliminates all sorts as follows:
a— = a, for a a first-order atom	(ϕ ∧ ψ)— = ϕ— ∧ ψ—
(¬ϕ)— = ¬(ϕ—)	(∃x:α.ϕ)— = ∃x.(ϕ)—.
An unsorted functional model is a model for the resulting signature.
Clearly, ϕ is not equivalent to ϕ— in the general case. But consider again the model of Figure 1a. In Figures 1b and 1c it is “represented” (cf. Section 2) us- ing three functions, but we can certainly represent it with any larger number of functions, since we do not care about duplicated functions.
On the other hand, since one of the nodes of this model has a fan-out of three, it cannot be represented with less than three functions. Because the maximum fan-out (via a relation r) of a relational structure with domain W is |W| we arrive at the following proposition.
Proposition 4.2 For any H(@, ↓)-formula ϕ, the following are equivalent:
ϕ is satisﬁable.
FT (ϕ) is satisﬁable.
FT (ϕ)— is satisﬁable.
Proof. From the previous discussion, FT (ϕ) is satisfiable iff it is satisfiable by a functional model I = ⟨W, I, ·£⟩ such that |W| = |I|. Using any bijection between W and I we define an unsorted model that satisfies FT (ϕ)—.	2
Because the number of possible functions of W → W is |W||W |, this cardinality argument is not compatible with maximal models. However, using classical preser- vation results we show that one can do with a weaker form of maximality: only the realizations of functions for nodes that are “reachable” from the initial point of evaluation are needed.
Definition 4.3 [Generated submodels] Let I = ⟨W, ·£⟩ and Ij = ⟨Wj, ·£′ ⟩ be two relational models, and let g : Nom → W be a valuation. We say that Ij is submodel of I generated by g whenever:
range g ⊆ Wj ⊆ W ,

if w ∈ Wj then either w ∈ range g or it can be reached from v ∈ range g in a finite number of steps through the relations in the model,
if w ∈ Wj and (w, v) ∈ r£ for some r ∈ Rel, then v ∈ Wj,
p£′ = p£ ∩ Wj for each p ∈ Prop,
r£′ = r£ ∩ (Wj × Wj) for each r ∈ Rel.
Definition 4.4 [g-maximal models] Consider an unsorted functional model I =
⟨W, ·£⟩, and let r£ ⊆ W × W be the relation induced by I for each r ∈ Rel. Let g : Nom → W be an assignment and Ig = ⟨Wg, ·£g ⟩ be the generated submodel of I by g. We say that I is g-maximal if for each function α : Wg → Wg such that (v, α(v)) ∈ r£ for all v ∈ Wg, there exists an i ∈ W for which f£ (i, v) = α(v), for
all v ∈ Wg.
Theorem 4.5 Let γ be a preﬁx-stable formula in the unsorted functional corre- spondence language with a free variable y that occurs in context fr(y, t), with all the variables in t free in γ. Then, for every g-maximal model I we have:
I |=FO ∀x1 ... xk∃y.γ[g] iff I |=FO ∃y∀x1 ... xk.γ[g].
The proof is analogous to the one for Theorem 3.5. Proposition 2.5, which states that in the many-sorted case we can assume every satisfiable formula to be satisfied by a maximal model, is a key ingredient in the proof of correctness of the optimized functional translation. For the basic case we have an analogous for g-maximal models:
Proposition 4.6 A formula ϕ of H(@, ↓) is satisﬁable iff there exists an unsorted functional model I such that;
I induces a model that satisﬁes ϕ at some world w,
I is gw-maximal, where gw is the constant assignment gw(x)= w.
Proof. We only need to prove the left-to-right direction. Assume, then, that I, g,w |= ϕ for some I = ⟨W, ·£⟩, w ∈ W and g : Nom → W , and pick any unsorted functional model If = ⟨W, ·£f ⟩ that induces I. For each r ∈ Rel let
Γ = {α : W → W | ∀v . v /∈ de£f ⇒ (v, α(v)) ∈ r£f } and define the set Γ =  Γ .
We then construct an unsorted functional model Ij = ⟨W ∪ Γ, ·£′ ⟩ such that

de£′ = de£f ∪ Γ, p£′ = p£f for all p ∈ Prop, and, for every r ∈ Rel, f£′
is an

r	r	r
£′
arbitrary function that satisfies fr (α, v) = α(v) for all α ∈ Γr and all v ∈ W . It
is straightforward to verify that Ij is gw-maximal. Moreover, the identity on W is partial isomorphism between I and the relational model induced by Ij, so the latter must also satisfy ϕ at w.	2
Using Proposition 4.6 it is simple to reproduce the proof of Theorem 3.6.
Theorem 4.7 Let ϕ be a formula of H(@, ↓). The following are equivalent:
ϕ is satisﬁable.
∃i:ω.OFTi(ϕ) is satisﬁable.

∃i.OFTi(ϕ)— is satisﬁable.
Now, the proof of Proposition 4.6 does not generally work if we are interested in satisfiability for a restricted class of models. For example, it clearly breaks for the class of models defined by the modal axiom [r]p → ⟨r⟩p, since the gw-maximal model obtained in the proof does not satisfy the seriality condition ∀x∃y.r(x, y). We will see next that it is possible to obtain a gw-maximal model that preserves any frame condition that is invariant under disjoint unions. The seriality condition above falls in this category. In fact, by a well-known result due to Goldblatt and Thomason, every class of models that is both first-order and modally definable (that is, definable by a basic modal formula) must be closed under disjoint unions [7].
We begin by defining an operation Ψκ on models. Intuitively, Ψκ(I) is the model obtained by taking κ isomorphic copies of I (in particular, Ψ0(I)= I).
Definition 4.8 Let I = ⟨W, ·£⟩ be a relational model and let κ be an ordinal number; then Ψκ(I) = ⟨W∗, ·∗⟩ is the model such that W∗ = W ∪ (κ × W ), r∗ = r£ ∪ {((a, w), (a, v)) | a ∈ κ and (w, v) ∈ r£} and p∗ = p£ ∪ (κ × p£ ).
Clearly, for basic modal formulas, I, g,w |= ϕ if and only if Ψκ(I), g,w |= ϕ. Moreover, since Ψκ(I) is the disjoint union of κ+1 copies of I, every class of models C that is modally definable, is closed by Ψκ.
Proposition 4.9 Let C be a class of relational models that is closed by Ψκ and let ϕ be a formula of H(@, ↓). Then, ϕ is C-satisﬁable iff there exists an unsorted functional model I∗ such that:
I∗ induces a C-model and satisﬁes ϕ at some world w,
I∗ is gw-maximal, where gw is the constant assignment gw(x)= w.
Proof. The argument is very similar to that of Proposition 4.6. Given a hybrid model I = ⟨W, ·£⟩ such that I, g,w |= ϕ for some g and w, we first build the model Ij = Ψκ(I) with κ = |W||W |. By construction, Ij is in C and as observed above, Ij, g,w |= ϕ. It is now easy to turn any functional model inducing Ij into a gw-maximal one.	2
Corollary 4.10 Let C be a class of modally deﬁnable models and let ϕ be a formula of H(@, ↓). The following are equivalent:
ϕ is C-satisﬁable.
∃i:ω.OFTi(ϕ) is C-satisﬁable.
∃i.OFTi(ϕ)— is C-satisﬁable.
General unsoundness of sort erasure for OFTi
One may wonder if performing sort erasure on the optimized functional translation is sound in the general case, that is, over classes that are not definable in the basic modal language. We give a negative answer to this question by exhibiting a class of models that is definable by a hybrid formula for which sort erasure fails.

i	r	j

r

k	l

Fig. 3. A C-model for ψ (relation s is omitted).
Consider the hybrid axiom ⟨s⟩i. It is well-known that it defines the class of models that satisfy the first-order formula ∀xy.s(x, y) 4 . Since in this class s behaves like a universal modality, we can use the machinery of hybrid logics to impose cardinality conditions on models. For example, the following formula is satisfiable only by models with exactly four elements, labelled i, j, k and l:
[s](i ∨ j ∨ k ∨ l) ∧ @i¬j ∧ @i¬k ∧ @i¬l ∧ @j¬k ∧ @j¬l ∧ @k¬l	(8) Now, let ψ be the conjunction of (8) with the following formulas:
@i(⟨r⟩j ∧ ⟨r⟩k ∧ ⟨r⟩l ∧ [r]¬i)	 @j(⟨r⟩i ∧ ⟨r⟩k ∧ ⟨r⟩l ∧ [r]¬j) @k(⟨r⟩i ∧ ⟨r⟩j ∧ ⟨r⟩l ∧ [r]¬k)	@l(⟨r⟩i ∧ ⟨r⟩j ∧ ⟨r⟩k ∧ [r]¬l)
Clearly, ψ is C-satisfiable. In fact (assuming Prop = ∅) any model for ψ is isomorphic to the one in Figure 3. Finally, let ϕ be the conjunction of:

The model of Figure 3 also satisfies ϕ and, therefore, satisfies ψ ∧ ϕ. Now, consider the formula OFTm(ψ ∧ ϕ), which has to be satisfiable in C as well. We will see that the minimum number of elements of sort ι that a C-model for OFTm(ψ ∧ ϕ) requires is six (in fact, it requires exactly six, but we won’t show the upper-bound). Since such a model cannot have more than four elements of sort ω we will conclude that sorts cannot be safely removed in this case.
The first thing to observe is that there is an upper bound for the number of elements of sort ι required, given by the number of existentially quantified variables in OFTm(ψ ∧ ϕ). The latter is the number of diamonds in ψ ∧ ϕ, namely, eighteen. We need a function to witness each of these existentially quantified variables, and the minimum number of elements of sort ι is simply the minimum number of distinct functions required.
We restrict our attention to diamonds in ϕ. Exactly one diamond occurs in each conjunct; informally, we say that a function is required to account for each of them. In the end, we conclude that six distinct functions are needed.
Let I = ⟨W, ·£⟩ be the model of Figure 3 and assume W = {i, j, k, l}. Moreover, assume g(w) = w for w ∈ W . Consider the conjunct [s]⟨r⟩(i ∨ j); since [s] is a 

4 We can functionally translate the axiom ⟨s⟩i as 6x:ω.¬des(x) ∧ 6xy:ω.∃j:ι.(x = fs(j, y)). This shows that we don’t need any special ad-hoc machinery to deal with the universal modality when we use the functional translation.


Table 1
Requirements for the functions that satisfy OFTm(ϕ).

universal modality, we have have I, g,w |= ⟨r⟩(i ∨ j) for every w ∈ W . Let α1 be the function witnessing the diamond. Then I, g, α1(w) |= (i ∨ j). Since r£ is irreflexive, α1 satisfies α1(i)= j and α1(j)= i. We can do this analysis for all six conjuncts of ϕ; the constraints are shown in Table 1.
Because α1, α2 and α3 differ in the value for i, they must be all distinct functions. Similarly, α4 differs from α1 in the value for j, from α2 in the value for k and from α3 everywhere. From a similar analysis for α5 and α6 we conclude that six distinct functions are needed to satisfy these six formulas.
Conclusions and future work
When dealing with functional translations, many-sorted first-order logic is unde- niably useful for presentation reasons. In this article we discussed in which cases many-sorted logic is needed also for technical reasons. We proved that as long as reasoning is confined to classes of models closed by disjoint unions (e.g., modally definable classes) sorts can be eliminated.
It was shown in [14] that the optimized functional translation can be used also to reason over some modally defined classes that are not first-order, like the class defined by the McKinsey axiom 2 p → 2p. It is easily seen that sorts are not required in that case either.
Of course, the empirical advantages of eliminating sorts need to be assessed. One could in principle pick an off-the-shelf automated prover and benchmark its performance on a number of functionally translated formulas (generated at random or from a given domain), both with and without sort annotations. However, it is not at all clear if one is warranted to extract meaningful conclusions from this sort of black-box experiments. E.g., absence of noticeable differences may be due to a bottleneck in the clausification process, or even a prover implementing an heuristic that amounts to erasing sorts; better execution times for the unsorted case may be due to a deficient handling of larger formulas, etc.
This article shows that the functional translation adapts surprisingly well to the hybrid case (see, for comparison, the case of the layered translation in [8]). Schmidt established in [16] that, when restricted to the basic modal case, any refinement of resolution plus the (eagerly applied) condensing rule [11] is terminating for the out- put of the optimized functional translation. Most first-order theorem provers have factoring and subsumption deletion rules, and hence condensing is in fact implicit when the implementation is fair. This means that any standard (complete and fair)

resolution theorem prover used along with the optimized translation constitutes a decision method for the basic modal language over the class of all models. Termi- nation conditions for some frame classes were also investigated. As future work, it would be interesting to see if termination can be achieved in the case of H(@).

References
C. Areces, R. Gennari, J. Heguiabere, and M. de Rijke. Tree-based heuristics in modal theorem proving. In Proc. of ECAI’2000, pages 199–203, 2000.
C. Areces and B. ten Cate. Hybrid logics. In Handbook of Modal Logics, pages 821–868. Elsevier, 2006.
Y. Auffray and P. Enjalbert. Modal theorem proving: An equational viewpoint. In Proc. of the 11th IJCAI, pages 441–445. Morgan Kaufmann Pub., 1989.
Y. Auffray and P. Enjalbert. Modal theorem proving: An equational viewpoint. J. of Logic and Computation, 2(3):247–295, 1992.
P. Blackburn, M. de Rijke, and Y. Venema. Modal Logic. Cambridge University Press, 2002.
L. Farin˜as del Cerro and A. Herzig. Linear modal deductions. In Proc. of CADE-9, volume 310 of
LNCS, pages 487–499. Springer, 1988.
R. Goldblatt and S. Thomason. Axiomatic classes in propositional modal logic. In Algebra and Logic, volume 450 of Lecture Notes in Mathematics, pages 163–173. Springer, 1975.
D. Gor´ın. Automated reasoning techniques for hybrid logics. PhD thesis, Universidad de Buenos and Universit´e Henri Poincar´e, 2009.
I. Horrocks, U. Hustadt, U. Sattler, and R. Schmidt. Computational modal logic. In Handbook of Modal Logics, pages 181–245. Elsevier, 2006.
U. Hustadt and R. A. Schmidt. An empirical analysis of modal theorem provers. J. of Applied Non- Classical Logics, 9(4):479–522, 1999.
W. Joyner, Jr. Resolution strategies as decision procedures. J. of the ACM, 23(3):398–417, 1976.
H. Ohlbach. A Resolution Calculus for Modal Logics. PhD thesis, Universit¨at Kaiserslautern, 1988.
H. Ohlbach. A resolution calculus for modal logics. In Proc. of CADE-9, volume 310 of LNCS, pages 500–516. Springer, 1988.
H. Ohlbach and R. Schmidt. Functional translation and second-order frame properties of modal logics.
J. of Logic and Computation, 7(5):581–603, 1997.
R. Schmidt. Optimised Modal Translation and Resolution. PhD thesis, Universit¨at des Saarlandes, Saarbru¨cken, Germany, 1997.
R. Schmidt. Decidability by resolution for propositional modal logics. J. of Automated Reasoning, 22(4):379–396, 1999.
C. Walther. Many-sorted inferences in automated theorem proving. In Sorts and Types in Artificial Intelligence, volume 418 of LNCS, pages 18–48. Springer, 1989.
C. Weidenbach. Combining superposition, sorts and splitting. In Handbook of Automated Reasoning, volume 2, chapter 27, pages 1965–2014. Elsevier and MIT Press, 2001.
C. Weidenbach, R. Schmidt, T. Hillenbrand, R. Rusev, and D. Topic. System description: Spass version
3.0. In Proc. of CADE-21, number 4603 in LNAI, pages 514–520. Springer-Verlag, 2007.
N. Zamov. Modal resolutions. Soviet Math, 33(9):23–29, 1989.
