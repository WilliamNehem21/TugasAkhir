

Electronic Notes in Theoretical Computer Science 220 (2008) 79–92
www.elsevier.com/locate/entcs
Cooperative Testing of Timed Systems
Alexandre David1 Kim G. Larsen2 Shuhao Li3 Brian Nielsen4
Center for Embedded Software Systems (CISS) Department of Computer Science
Aalborg University Aalborg, Denmark

Abstract
This paper deals with targeted testing of timed systems whose models may have uncontrollable behavior. The testing activity is viewed as a game between the tester and the system under test (SUT) towards a given test purpose. The SUT is modeled as Timed Game Automaton and the test purpose is specified in Timed CTL formula. We employ a timed game solver UPPAAL-TIGA to check if the test purpose is ture w.r.t. the model, and if yes, to generate a winning strategy and use it for black-box conformance testing of the SUT implementation. Specifically, we show that in case the checking yields a negative result, we can still test the SUT implementation against the test purpose as long as the SUT implementation reacts to our moves in a cooperative style. We present an operational framework of cooperative winning strategy generation, test case derivation and execution. The test method is proved to be sound and complete. Preliminary experimental results indicate that this approach is applicable to non-trivial timed systems.
Keywords: Timed game automata, test purpose, winning strategy, cooperative strategy, test case


Introduction
In the field of model-based testing of real-time systems [7,9,11,19,13,10,16,5,14,18], a considerable proportion of work [9,11,19,13,10,16,5,14] employ timed automata (TA) [1] or timed transition systems (TTS) to model the systems in question. Among them some make the assumptions that the system TA model is output-urgent and has isolated outputs [9,19,10]. “Output-urgent” means that if the system can produce an output, then that output should be produced immediately. “Isolated output” means that anytime when the system can produce an output, it cannot accept inputs and cannot produce a different output at the same time. These two assumptions, together with the determinism assumption, contribute to the testa- bility property [19] of timed automata by ensuring that given an input sequence

1 Email: adavid@cs.aau.dk
2 Email: kgl@cs.aau.dk
3 Email: li@cs.aau.dk
4 Email: bnielsen@cs.aau.dk

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.11.007


Tre



react h!



Fig. 1. The user.


Tidle=20 Tsw=4


x>=Tidle

















Fig. 2. Controllable TA of the light.

fragment there is no more than one output emitted at a precise point in time, or lifted a little higher, by making it possible for an environment to “drive” a timed automaton through all of its transitions. However, in many cases the assumptions of “output urgent” and “isolated outputs”are unnecessarily strong. For example in the simple Smart Light problem [10], the light model with output-urgency and isolated outputs (see Fig. 2) is too demanding in the sense that we should have one TA node exclusively for producing each output, and we should have strict timing of the output.
In this paper we aim to cancel the assumptions of isolated outputs and output- urgency, and present a test method for uncontrollable timed system models, i.e., system models with uncontrollable outputs and timing uncertainty of outputs. By “uncontrollable outputs” we mean that during the course of SUT/tester interac- tions, it is the system under test (SUT) rather than the tester that determines whether or which one of the several possible outputs will occur. By “timing uncer- tainty of outputs” we mean that the SUT can produce an output during a certain time interval rather than only at a fixed time point, or in other words, the timing of outputs is unpredictable by the tester. The benefits of permitting uncontrollable behavior in the system models include allowing the implementors some freedom, providing the tester with high-level or abstract requirements, and yielding more natural and more succinct models.
The behavior of uncontrollable outputs and timing uncertainty of outputs may be modelled by timed game automata (TGA) [17], which is a variant of TA with


Tidle = 20	touch?



















Fig. 3. TIOGA of an ideal light.

their actions partitioned into controllable and uncontrollable ones. For example, Fig. 3 is a TGA of the light, where solid lines carry controllable actions (inputs from environment) and dotted lines uncontrollable actions (outputs to environment).
In a timed control problem, a control program (or “controller”, e.g. Fig. 1) actively offers inputs to and passively observes outputs from a plant that models the system in question (e.g., Fig. 3). A run of the system involves a sequence of
controller-chosen stimuli and plant-produced reactions aiming to satisfy a given test purpose (e.g., “location Bright can always be eventually reached”). Therefore it can be viewed as a timed input/output game where the controller acts as a player and the plant acts as the opponent (adversary). For a given control objective we can possibly synthesize a control strategy, guided by which the control program ensures that the plant will be operating in a desired manner and will thus fulfill the control objective.
The problem of dense-time controller synthesis has been solved using backwards fix-point computation [17]. As an improvement a truly on-the-fly algorithm [6] is proposed and has been implemented in the timed game solver UPPAAL-TIGA [3], which checks whether a user-specified test purpose can be satisfied by a TGA, and if so, it efficiently synthesizes a winning strategy for that test purpose. Specifically, in this paper we address the problem that in case an affirmative test purpose as above is checked to be false due to problematic TIOGA model (see Fig. 4) or too strong test purpose, we can make a “retreat” by relaxing the test purpose such that to some extent the controller requires cooperation from the plant, say, “location Bright can always be eventually reached as long as the system reacts to our moves in some desired manner”. We use UPPAAL-TIGA to check whether this weakened test purpose can be satisfied, and if yes, to synthesize a cooperative winning strategy. Since a (cooperative) strategy is a step-by-step guidance towards the goal states of the model which fulfill the given test purpose, it can be viewed as a test and thus used for conformance testing [8].
From a game point of view, testing of untimed systems has been discussed in


Tidle=20

touch?

x>=Tidle























Fig. 4. TIOGA of a problematic light.


Fig. 5. The framework of strategy-based testing.

[2,21,4], but to our knowledge no similar reported work for timed systems. Although strategy synthesis is inherently more expensive than some other approaches to timed testing, the idea and method proposed in this paper opens up the possibility of testing uncontrollable TA-modeled timed systems.

Test Setup
In this paper we endeavor to test whether a black-box system implementation IMP complies with its specification SPEC with respect to some given test purpose. As illustrated in Fig. 5, there are three steps in our testing framework: game strategy generation, test case generation, and test execution.

Timed I/O Game Automaton
Let X be a finite set of real-valued clocks, then C(X) is the set of constraints generated by grammar ϕ ::= x ∼ k | x − y ∼ k | ϕ ∧ ϕ, where k ∈ Z, x, y ∈X and
∼ ∈ {<, ≤, =, ≥, >}.
A timed automaton (TA) [1] is a tuple S = (L, l0, Act, X, E, Inv) where L is a finite set of locations, l0 ∈ L is the initial location, Act is the set of actions, X is a finite set of real-valued clocks, E ⊆ L × C(X) × Act × 2X × L is a finite set of

transitions, Inv : L → C(X) associates to each location its invariant.
In timed game automaton [17], actions are partitioned into controllable ones and uncontrollable ones. Now we make a further assumption that all output actions Actout are uncontrollable and all input actions Actin are controllable.
A timed I/O game automaton (TIOGA) is a timed automaton with its set of
actions Act partitioned into controllable actions Actc and uncontrollable actions
Actu such that Actc = Actin and Actu = Actout.
This paper uses the simple Smart Light problem [10] as an example. Fig. 1 is a TA of the user or the “environment” of the light (the “controller”). Fig. 4 is a “problematic” TIOGA of the light (the “plant”), where controllable actions (in solid lines) model the inputs from the controller to the plant, and uncontrollable actions (in dotted lines) model the outputs from the plant to the controller. The user interacts with the light by touching a touch-sensitive pad. In Fig. 4, there are three brightness levels for the light: Off, Dim and Bright. The light is initially in location Off. There are uncontrollable behavior in L2, L3, ..., L6.
The semantics of a TA or a TIOGA S = (L, l0, Act, X, E, Inv) is defined as a timed I/O transition system (TIOTS) (S, s0, Actin, Actout, →), where S ⊆ L × RX is the set of semantic states of location and clock vector, s0 = (l0, 0) is the initial state, and →⊆ S × (Actin ∪Actout ∪ R≥0) ×S satisfies the sanity constraints of time determinism and time additivity.
Let s ∈ S, and α ∈ (Act ∪ R≥0). If ∃s' ∈ S.s −α→ s', we write s −α→. Here α can be extended to strings of actions and time delays.
A timed trace σ ∈ (Act ∪ R≥0)∗ is of the form σ = d1a1d2a2 ... akdk+1. We define the set of timed traces of state s as: TTr(s) = {σ ∈ (Act ∪ R≥0)∗|s −σ→}.
For a state s and a timed trace σ, we define the set of states that can be reached after σ: s After σ = {s'|s −σ→ s'}. If the set is a singleton, then we just denote it as the target state. The set of (immediately) observable outputs or delays at state s is defined as: Out(s) = {a ∈ (Actout ∪ R≥0)|s −a→}. The definitions of After and Out can be extended to sets of states as usual.
A run of a TIOGA S is a timed trace in its TIOTS. We use Runs(s, S) to denote the set of all runs of S that start from s ∈ S. Specifically, we denote Runs(s0, S) as Runs(S). If σ is a finite run, then last(σ) denotes the last semantic state of σ.
In this paper we only impose the “determinism” and “strong input-enabledness” restrictions on the TIOGA model of the plant. In particular we do not require the plant model to be output-urgent (thus allowing timing uncertainty of outputs), or have isolated outputs (thus allowing uncontrollable outputs). Such a TIOGA is called an uncontrollable TIOGA, and its corresponding TIOTS is called an uncon- trollable TIOTS.
The parallel compositions of several TIOGA (TA) or several TIOTS’s can be defined in the usual manner.

Timed Conformance Relation
Definition 2.1 (Timed Input-Output Conformance relation, tioco [14]). Let i, s ∈ S be two states of a TIOTS. The timed input-output conformance relation tioco between i and s is defined as:
i tioco s iff ∀σ∈ TTr(s).(Out(i After σ) ⊆ Out(s After σ)).
As test hypothesis we assume that the behavior of the IMP can be modelled by a TIOTS I, which has the same sets of input actions Actin and output actions Actout as the specification TIOGA S. Let the initial state of I be i0, and the initial semantic state of S be s0. If i0 tioco s0, we say that I is a correct implementation of the specification, denoted I tioco TIOTS(S). Furthermore, I is assumed to be deterministic and controllable.
We can also user other timed versions [13,16,18] of Tretmans’ ioco relation [20].

Test Purpose
We aim to conduct targeted rather than comprehensive testing of whether an IMP conforms to a SPEC, thus we use a test purpose [12]. In this paper, we use annotated Timed CTL formulas to specify test purposes, e.g., control: A <> Bright means that whatever uncontrollable outputs the plant may produce according to the SPEC model, the controller can always choose to trigger input transition or to delay such that the system is guaranteed to reach the goal location Bright. In the weakened case we write E <> control: A <> Bright, which means that we can always be guided to reach Bright as long as the plant is willing to cooperate with the controller by producing outputs in some desired manner.

Cooperative Winning Strategy
A reachability control problem is that given a TIOGA S and a set of goal states K of its corresponding TIOTS, we should find a game strategy f such that S supervised by f can reach some states in K. If a state in K is reached, then the play of the game is said to be winning.
A strategy f is a function that during the course of a timed game constantly gives information as to what the player (the “controller”) should do in order to win the game against the opponent (the “plant”). At a given state of the run, the player can be guided either to offer a particular input and bring it to a particular state, or to do nothing at this time point and just wait (denoted “λ”).
When a test purpose ϕ is checked to be true, then there must exist a winning strategy for ϕ. A strategy being winning means that if the controller acts strictly according to what the strategy suggests, then whatever responses the plant might make, the behavior of the plant will fulfill the test purpose.
When a test purpose ϕ is checked to be false, then there does not exist a winning strategy. For example in the TIOGA of Fig. 4, there is no winning strategy for control:  A <> Bright. A counter-example is that in L5 we might be constantly




Fig. 6. Playing games with cooperative winning strategies.

brought back to Off. For this negative case, we make a “retreat” by assuming that the opponent is not too “hostile”. The basic idea is that in order to reach the goal states, we hope that the opponent reacts in favor of us.
The principle of playing games with a cooperative winning strategy is illustrated in Fig. 6. The state space of the timed game is partitioned into three areas: the winning “safe zone”, the possibly winning zone, and the losing “no-hope zone”. For the weakened test purpose in Section 2.3, it means that if the opponent is willing to cooperate, then we can possibly reach a state, from which the goal location Bright is always eventually reachable (the “safe zone”).
Definition 3.1 (Cooperative Strategy). Let S = (L, l0, Act, X, E, Inv) be a TIOGA, (S, s0, Actin, Actout, →) be its TIOTS, where → = →in ∪ →out ∪ →d. A cooperative strategy f over S is defined as a partial function:
f : S → {coop}×(→in ∪ →out ∪ {λ}) ∪ {winning}×(→in ∪ {λ}).
The projection function fstg indicates which stage (“cooperative” or “winning”) f is currently in, and fmov denotes the suggested or desired move of f . For transition t ∈ (→\ →d), let ev(t) be the event, and tgt(t) be the target state. In the cooperative stage, if a strategy-desired output occurs as expected, then the opponent is said to be cooperating, otherwise the strategy is violated.
Definition 3.2 (Supervised Run). Let S = (L, l0, Act, X, E, Inv) be a TIOGA and f a cooperative strategy over S. Let s be a state in the TIOTS of S. The f-supervised runs of S from s is a subset SupRuns(s, f ) ⊆ Runs(s, S) defined as:
s ∈ SupRuns(s, f ),
σ' = (σ −e→ s') ∈ SupRuns(s, f ) if σ ∈ SupRuns(s, f ), σ' ∈ Runs(s, S) and one of the following three conditions holds:
e ∈ Actu and ((fstg(last(σ)) = winning) ∨ ((fstg(last(σ)) = coop) ∧ (e =
ev(fmov(last(σ)))))),
e ∈ Actc and e = ev(fmov(last(σ))),

e ∈ R≥0
and ∀e' ∈ [0, e).∃s'' ∈ S.((last(σ) e'
'') ∧ (f
mov
(s'') = λ)),

σ ∈ SupRuns(s, f ) if σ is an infinite run whose finite prefixes are all included in
SupRuns(s, f ).
Given a TIOGA S = (L, l0, Act, X, E, Inv) and a set of goal states K ⊆ L× RX
of its corresponding TIOTS, let (S, K) be a reachability game. A maximal run σ




Fig. 7. An example cooperative winning strategy.

is either an infinite run, or a finite run such that either last(σ) ∈ K, or (last(σ) ∈/

K) ∧ ((last(σ)
αn
−α→) ⇒ (α = 0)).  A finite or infinite run σ =
α
s0 −→ s
α
1 −→

... sn −→ ... is winning if ∃k ≥ 0.(sk ∈ K). A run σ is losing if σ is maximal and
∀0 ≤ k ≤ min{index(last(σ)), ∞}.(sk ∈/ K). The set of all maximal runs starting from state s is denoted by MaxRuns(s), and the set of all winning runs starting from state s is denoted by WinRuns(s, S, K).
Definition 3.3 (Cooperative  Winning  Strategy).	Let S  = (L, l0, Act, X, E, Inv) be a TIOGA, f a cooperative strategy over S, and s a state in the TIOTS of S. We say f is winning from state s if MaxRuns(s) ∩ SupRuns(s, f ) ⊆ WinRuns(s, S, K). If f is winning from s0, then f is called a cooperative winning strategy.
For the TIOGA in Fig. 4 and the weakened test purpose E <> control: A <> Bright, UPPAAL-TIGA automatically generates a cooperative winning strategy, as is shown in Fig. 7, where the strategy-desired outputs are in dotted lines.
Usually there exists more than one cooperative winning strategy for the same TIOGA and weakened test purpose. We use Strategy(S, ϕ) to denote the set of all cooperative winning strategies for TIOGA S and weakened test purpose ϕ.

Test Case Generation
A test case for uncontrollable reactive systems should be adaptive rather than se- quential preset, thus it should have a tree structure rather than be just a linear I/O sequence. Note that a cooperative winning strategy neither drives the test execu- tion nor issues test verdicts. To have more operational tests, we define a test case as a tree-like TA which permits non-reset clock assignments, and we derive this TA from the TIOGA model S and the strategy f .

Given a TA location l, we use outgoing(l) to denote the set of output actions originating from l. Given a state s in the TIOTS of a TA, we use location(s) to denote the corresponding location of s in the TA.
Definition 4.1 (Test Case). A test case is a TA T = (Lt, l0t, Act, Xt, Et,Invt) where Lt is a set of locations containing those marked pass, fail and inconc, which are all the terminal nodes, l0t ∈ Lt is the initial location, Act = Actin ∪Actout, Xt is a set of clocks, Invt associates to each location its invariant, and Et is the transition relation such that:
T is deterministic,
T has bounded behavior, i.e., ∀σ = σ1σ2σ3 ... ∈ Runs(T ).∃n > 0.(|{i|σi ∈ Actin ∪
Actout}|<∞ ∧ (Σ{σi|σi ∈ R≥0}) < n),
∀lt ∈ (Lt\{pass, fail, inconc}).∀α ∈ Actout.(α ∈ outgoing(lt)).
The basic idea of test case generation is to keep looking up the generated coop- erative winning strategy and the SPEC model to decide when to make what move against the IMP in (forthcoming) test execution, and which decision (pass, fail, in- conc, or to continue on by recursively building the test tree) to make upon every possibly observed output from IMP.
Algorithm 1 TestCase(S, f)
Input: TIOGA speciﬁcation S, cooperative winning strategy f;
Output: a test case TA T ;
Initialization: w := 0; x := 0; h := 0; add node(s0);
Main: BuildTestCase(s0).
Procedure BuildTestCase(s) /*s: state in S, node in T */
if s does not correspond to a conditional branching location then
w := width(fmov(s));
add invariant “x ≤ w” for node s in T ;
for each o ∈ Actout do /* to wake up on every possible output */
if o ∈ outgoing(location(s)) then
if the destination state of this transition is a goal state then

add edge(“
o!
s −→
pass”); /* to add a node pass and an edge in T */

else if (fstg(s) = coop) ∧ (o /= ev(fmov(s))) then /*not desired output*/

add edge(“
o!
s −→
inconc”);

else /* continue on by recursion on a conditional branching location */ add edge(“s o!,h:=x,x:=0 s'”); s' := (s After h) After o; BuildTestCase(s');


else
add edge(“
end for
o!
s −→

fail”);

case fmov(s) of /* to delay a period, offer input, or observe output */ “λ”:
if ((s After w) hits location(s)) ∧ (fmov(s After w) = λ) then

add edge(“s x—=→w fail”); /* acc. to semantics of forced actions */
else
add edge(“s x=w,x:=0 s'”); s' := s After w; BuildTestCase(s');
“to offer input i”:

add edge(“s
x=w,i?
—→ s
'”); s' := tgt(f

mov
(s After w)); BuildTestCase(s');

“to observe output o”:
if (fstg(s) = coop) Λ ({fmov(s)} ∩ →out /= ∅) Λ (no output) then
add edge(“s x—=→w inconc”);
end case
else /* s corresponds to a conditional branching location */ add invariant “x = 0” for s; /* an “urgent” location in 7 */ branching according to f and the value of h;
recursive calls of BuildTestCase();
End Procedure
Let s be a semantic state of £, s0 be the initial state. We use w = width(fmov(s)) to denote the time width of the observing window of the next move according to the strategy. Let x ∈ Xt be a unique clock variable for recording the timing constraints in f and for building invariants and transitions in the test case TA. We use another unique clock variable h ∈ Xt to record the time when a strategy-desired output happens. A location lt of the test case TA is called a conditional branching location if at this location the branching is based on the just-recorded occurrence time h of an output action. Thus lt is the destination location of the transition of an observed output. Algorithm 1 sketches out the main idea of test case derivation. For space reasons we do not elaborate on some tricky parts such as the conditional branching.
A key point of our test generation algorithm is the semantics of forced actions. We adopt the following semantics: if a location invariant of the TIOGA is hit, then we check whether there is some outgoing edge with enabled input action leading to other location, or some self-looping edge with enabled input action and clock resets. If there is no such edge, then we check whether there is some outgoing edge with output action leading to other location, or some self-looping edge with output action and clock resets. If there is also no such edge and the strategy still suggests “delay” when hitting the invariant, then we report fail.
Because the (weakened) test purpose is proved to be satisfiable, the synthe- sized (cooperative) winning strategy is of finite length and it guides us towards the goal states, Algorithm 1 will always terminate. The complexity of this recursive algorithm largely depends on the sizes of the strategy and the Act set.
Fig. 8 gives an example test case TA for the TIOGA in Fig. 4 and the cooper- ative winning strategy in Fig. 7. There are two inconclusive nodes. The node with invariant x == 0 is a conditional branching location.


x<=20

x==20

x<=2


















fail
pass
fail	fail




Test Execution
Fig. 8. An example test case TA.

Definition 5.1 (Test Execution).  Let TIOTS(7 ) = (T, t0, Actin, Actout, →t) be the TIOTS of test case 7 , and assume the IMP may be modeled as another TIOTS I = (I, i0, Actin, Actout, →i). The execution of I with 7 is modeled by the synchronous parallel execution TIOTS(7 )||I which is defined by the rules:


g1,α ' g2,α '
α  '	α  '
d  '	d  '

t−→tt ,i−→ii  α∈Act
,	t−→tt ,i−→ii  α∈Act
,	t−→tt ,i−→ii  d∈ R

g1∧g2,α '  '	in
α  '  '
out
d  '  '	≥0

t||i  −→ t ||i
t||i−→t ||i
t||i−→t ||i

where t, t' ∈ T , i, i' ∈ I, and g1, g2 ∈ C(X).
A test run is a run of the product TIOTS(7 )||I that leads to a state whose left sub-state corresponds to a terminal node of 7 . Formally, σ ∈ Runs(TIOTS(7 )||I) is a test run if ∃i' ∈ I.∃t' ∈ T.((t0||i0 —σ→ t'||i') ∩ (location(t') = pass ∨ location(t') = fail ∨ location(t') = inconc)). In the pass case we say that I passes test run σ. In the fail case we say that I fails σ. The inconc case indicates neither passing nor failing. It simply means that we do not get cooperation and are thus not assured of reaching the goal states.
Given I and 7 , if there is a failing test run of TIOTS(7 )||I, then I fails 7 . If every test run of TIOTS(7 )||I is not failing, we say I passes 7 .

Soundness and Completeness
The soundness property of the test method says that if there exists a failing test run, then the system implementation does not conform to the system specification. The partial completeness property of the test method says that if the system imple- mentation does not conform to the system specification with respect to the specified

weakened test purpose, then we can always find a failing test run.
Let £ = (L, l0, Act, X, E, Inv) be a TIOGA specification with Act = Actin ∪ Actout, TIOTS(£) be its corresponding TIOTS, I = (I, i0, Actin, Actout, →i) be a TIOTS implementation, ϕ be a weakened test purpose such that £ |= ϕ, and £f be the behavior of £ that are constrained by strategy f , then we have:
Theorem 6.1 (Soundness). ∃f ∈ Strategy(£, ϕ).(I fails TestCase(£,f ))	⇒

I ccc
(£).

tioco TIOTS
Proof. (Sketch) Let 7 = TestCase(£,f ) and TIOTS(7 ) = (T, t0, Actin, Actout, →t). By (I fails 7 ) we know that ∃σ ∈ Runs(TIOTS(7 )||I).∃i' ∈ I.∃t' ∈ T.(t0||i0 —σ→ t'||i') ∩ (location(t') = fail). From Algorithm 1 we know that there are two cases of finishing with a fail verdict. The first case is that we observe an invalid output
w.r.t. £ (the first fail verdict in Alg. 1). According to Definition 5.1 and Definition

2.1, we conclude that I ccc
(£). The second case is when we are hitting

the location invariant (the λ-case in Alg. 1). According to the forced semantics of controllable and uncontrollable actions in this circumstance, there should be a forced output. But unfortunately we have not observed it. Thus the conformance

relation has been violated. Therefore comes I ccc
(£).	 

Theorem 6.2 (Partial Completeness). ∃f1 ∈ Strategy(£, ϕ).(I ccc £f )	⇒

∃f2 ∈Strategy(£, ϕ).(I fails TestCase(£, f2)).
tioco	1

Proof. (Sketch) By (I ccc £f ) we know that there exists a timed trace σ such
tioco	1
that σ ∈ TTr(I) and σ ∈/ TTr(£f1 ) according to Definition 2.1. For simplicity, we suppose σ ends with the first violation w.r.t. £f1 . According to Algorithm 1 we know that this has two possible consequences. The first case is that σ has an output action which is disallowed in TIOTS(£). The second case is that σ has an observed quies- cence when hitting a location invariant, but it is disallowed in TIOTS(£). Therefore
we can build another timed trace σ' such that σ' has exactly the same prefix as σ, but σ' ends without a violation w.r.t. TIOTS(£). Therefore, we can generate some cooperative winning strategy f2 from £ and ϕ, and build a test case TIOTS from £ and f2 such that σ' is not a failing run but σ is a failing run. According to Definition 5.1, we can conclude that ∃f2 ∈ Strategy(£, ϕ).(I fails TestCase(£, f2)).	 

Case Study
We consider a simple Leader Election Protocol (LEP) problem [15], where we have one TIOGA for an arbitrary protocol node (the “plant”), and two TA for simulating all other protocol nodes and a buffer with certain capacity for them to exchange messages (the “controller”). The TIOGA has uncontrollable actions in the sense that in the plant node a timeout! event might occur after waiting for a certain period of time without receiving “useful” messages, and an ignore! event might occur due to loss of messages. We defined the following test purposes:
TP1: control:	A <> exists (i:BufferId) (inUse[i]==1)
TP2: control:	A <> (IUT.bufferInfo==1) and IUT.forward

Table 1
Cooperative winning strategy generation for LEP with lossy channels.

Experiment platform: Sun Fire X4100 server, 2×2.4GHz CPU (Dual Core AMD Opteron 275), 4096MB RAM, Suse Linux Enterprise Desktop 10 - 64bit.
TP3: control:	A <> forall (i:BufferId) (inUse[i]==1)
All these test purposes are checked to be false using UPPAAL-TIGA. However, all the weakened test purposes (prefixed with “E <>”) are checked to be true. We carried out the strategy generation experiments on an application server. Table 1 presents the performance results of CPU time overheads and the memory con- sumptions, where / means “out of memory”. Each sub-column corresponds to one parameter configuration, where n means that there are n nodes in the protocol, and there is a message buffer of size n, and the maximum distance between any two nodes is limited to (n — 1). The table indicates that for some test purposes, cooperative winning strategy generation for the LEP protocol with up to 7 nodes takes less than 10 minutes and the memory consumption is not well beyond our expectation considering the complexity of the problem. Since strategy generation is the most computation intensive step in our test framework, our testing method seems not to be only of theoretical value.
Conclusions
We examine black-box conformance testing based on uncontrollable timed system models using a cooperative game-based approach. We model the systems with Timed I/O Game Automata and specify the test purposes with TCTL formulas. We generate cooperative winning strategies, derive test cases, and execute them on the implementation.  The test method is proved to be sound and complete
w.r.t. the test purpose. Preliminary experimental results indicate that it is a viable approach. This opens up the possibility of testing a broader type of properties on uncontrollable TA models that are previously thought of as not testable.
Future work include: 1) more case studies for performance evaluation, test effec- tiveness analysis and method scalability improvement; 2) generalizing state-based strategy to history-based strategy; 3) implementing the test case generation and execution algorithm to build a fully automated strategy-based testing environment;
4) strategy-based testing with partial observability.

References
Alur, R., Dill D.L., “A theory of timed automata,” Theoretical Computer Science, 126 (1994), 183–235.
Alur, R., Courcoubetis, C., Yannakakis M., “Distinguishing tests for nondeterministic and probabilistic

machines,” in: Proc. 27th Ann. ACM Symp. on Theory of Computing (STOC’95), Las Vegas, USA, ACM Press (1995) 363–372.
Behrmann, G., Cougnard, A., David A., Fleury E., Larsen, K.G., Lime, D., “UPPAAL-TIGA: Time for Playing Games!” in: Proc. 19th International Conference on Computer Aided Verification (CAV’07), Berlin, Germany, Springer (2007) 121–125.
Blass, A., Gurevich, Y., Nachmanson, L., Veanes, M., “Play to Test,” in: Proc. 5th International Workshop on Formal Approaches to Software Testing (FATES’05), Edinburgh, UK, Springer (2005) 32–46.
Brand´an Briones, L., Brinksma, E., “A Test Generation Framework for quiescent Real-Time Systems,” in: Proc. 4th International Workshop on Formal Approaches to Software Testing (FATES’04), Linz, Austria, Springer (2004) 64–78.
Cassez, F., David, A., Fleury, E., Larsen, K.G., Lime, D., “Efficient On-the-Fly Algorithms for the Analysis of Timed Games,” in: Proc. 16th International Conference on Concurrency Theory (CONCUR’05), San Francisco, CA, USA, Springer (2005) 66–80.
Clarke, D., Lee, I., “Testing real-time constraints in a process algebraic setting,” in: Proc. 17th International Conference on Software Engineering (ICSE’95), Seattle, Washington, USA, ACM Press (1995) 51–60.
David, A., Larsen, K.G., Li, S., Nielsen, B., “A Game-Theoretic Approach to Real-Time System Testing,” in: Proc. 11th Conference on Design, Automation and Test in Europe (DATE’08), Munich Germany, (2008).
En-Nouaary, A., Dssouli, R., Khendek, F., Elqortobi, A., “Timed Test Cases Generation Based on State Characterization Technique,” in: Proc. 19th IEEE Real-Time Systems Symposium (RTSS’98), Madrid, Spain, IEEE Computer Society Press (1998) 220–229.
Hessel, A., Larsen, K.G., Nielsen, B., Pettersson, P., Skou, A., “Time-Optimal Real-Time Test Case Generation Using UPPAAL,” in: Proc. 3rd International Workshop on Formal Approaches to Testing of Software (FATES’03), Montreal, Quebec, Canada, Springer (2003) 114–130.
Higashino, T., Nakata, A., Taniguchi, K., Cavalli, A.R., “Generating Test Cases for a Timed I/O Automaton Model,” in: Proc. IFIP TC6 12th International Workshop on Testing Communicating Systems (IWTCS’99), Budapest, Hungary, Kluwer (1999) 197–214.
Jard, C., J´eron, T., “TGV: theory, principles and algorithms,” Software Tools for Technology Transfer (STTT), 7 (2005) 297–315.
Khoumsi, A., J´eron, T., Marchand, H., “Test Cases Generation for Nondeterministic Real-Time Systems,” in: Proc. 3rd International Workshop on Formal Approaches to Testing of Software (FATES’03), Montreal, Quebec, Canada, Springer (2003) 131–146.
Krichen, M., Tripakis, S., “Black-box conformance testing for real-time systems,” in: Proc. 11th International SPIN Workshop on Model Checking Software (SPIN’04), Barcelona, Spain, Springer (2004) 109–126.
Lamport, L., “Real-time model checking is really simple,” in: Proc. 13th IFIP WG 10.5 Advanced Research Working Conference on Correct Hardware Design and Verification Methods (CHARME’05), Saarbru¨cken, Germany, Springer (2005) 162–175.
Larsen, K.G., Mikucionis, M., Nielsen, B., “Online Testing of Real-time Systems Using UPPAAL,” in: Proc. 4th International Workshop on Formal Approaches to Software Testing (FATES’04), Linz, Austria, Springer (2004) 79–94.
Maler, O., Pnueli, A., Sifakis, J., “On the synthesis of discrete controllers for timed systems,” in: Proc. 12th Annual Symposium on Theoretical Aspects of Computer Science (STACS’95), Munich, Germany, Springer (1995) 229–242.
Nunez, M., Rodriguez, I., “Conformance Testing Relations for Timed Systems,” in: Proc. 5th International Workshop on Formal Approaches to Software Testing (FATES’05), Edinburgh, UK, Springer (2005) 103–117.
Springintveld, J., Vaandrager, F.W., D’Argenio, P.R., “Testing timed automata,” Theoretical Computer Science, 254 (2001) 225–257
Tretmans, J., “Testing concurrent systems: a formal approach,” in: Proc. 10th International Conference on Concurrency Theory (CONCUR’99), Eindhoven, The Netherlands, Springer (1999) 46–65.
Yannakakis, M., “Testing, optimization, and games,” in: Proc. 31st International Colloquium on Automata, Languages and Programming (ICALP’04), Turku, Finland, Springer (2004) 28–45.
