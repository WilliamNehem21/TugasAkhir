Electronic Notes in Theoretical Computer Science 104 (2004) 163–180 
www.elsevier.com/locate/entcs


Coalgebraic Semantics and Observational Equivalences of an Imperative Class-based OO-Language *

Furio Honsell1	Marina Lenisa2 ,3

Dipartimento di Matematica e Informatica, Universit`a di Udine, Via delle Scienze 206, 33100 Udine, ITALY.

Rekha Redamalla4

Dipartimento di Matematica e Informatica, Universit`a di Udine, Via delle Scienze 206, 33100 Udine, ITALY,
and B.M. Birla Science Center,
Adarsh Nagar, Hyderabad, 500 063 A.P., INDIA.



Abstract
Fickle is a class-based object oriented imperative language, which extends Java with object re- classiﬁcation. In this paper, we introduce a natural observational equivalence on Fickle programs. This is a contextual equivalence on main methods with respect to a given sequence of class defini- tions, i.e. a program. To study it, we use the formal computational model for OO-programming based on coalgebras, which has recently emerged, whereby objects are taken to be equal when the actions of methods on them yield the same observations and equivalent next states. However, in order to deal with imperative features, we need to extend the original approach of H.Reichel and B.Jacobs in various ways. In particular, we introduce a coalgebraic description of objects (states of a class), which induces a coinductive behavioural equivalence on programs. For simplicity, we focus on Fickle objects whose methods do not take more than one object parameter as argument. Completeness results as well as problematic issues arising from binary methods are also discussed.
Keywords: Imperative class-based OO-programming, observational equivalences, coalgebraic semantics, coinductive behavioural equivalences.



1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.08.024

Introduction
In the global computing community, there has been growing interest in class- based object oriented languages. Despite this, however, relatively little work has been done on program equivalence for such languages. This is due prob- ably also to the fact that no formal model for OO-programming has been generally accepted. In recent years, Reichel and Jacobs [13,9] have introduced such a model based on coalgebras. The idea underpinning this approach is that coalgebras, duals of algebras, allow to focus on the behaviour of objects, while abstracting from the concrete representation of Self. This approach has been used mainly for extending logical specification, and program and data refinement techinques to OO-languages (see [10,5]).
This paper intends to initiate an investigation programme into the possi- bility of utilizing the coalgebraic computational model also for program equiv- alence and program transformation. This is a somewhat dual goal w.r.t. the program refinement of Reichel and Jacobs. To this end, we need to address directly critical issues pertaining to imperative features, as well as binary meth- ods, i.e. methods taking more than one object argument as parameter.
We focus on a fragment of the imperative typed class-based language Fickle, [4], which extends Java with re-classiﬁcation. Re-classification allows objects to change class membership dynamically, while retaining their iden- tity. We consider Fickle as a representative of this class of typed imperative class-based object oriented languages, and the results in this paper apply also to Java and similar languages.
We study the (family of) contextual equivalances ≈P (indexed by program P ) on Fickle expressions (i.e, bodies of main methods). To this aim, we utilize a coalgebraic behavioural equivalence on Fickle objects. Our main result is an adequate coalgebraic semantics of Fickle expressions w.r.t. equivalences ≈P .
Coalgebraic semantics originated with Aczel-Mendler, Rutten-Turi, for CCS-like languages, [1,2,15], and it was further generalized to λ-calculus, [6], higher-order imperative languages, [12], object-oriented languages in a func- tional setting, [13,9], π-calculus, [7].
The gist of the coalgebraic semantics paradigm (ﬁnal semantics) is to view the interpretation function from syntax to semantics as a ﬁnal mapping in a suitable category. To this end, the semantics has to be construed as a ﬁnal

 Research supported by the UE project IST-2001-33477 DART, and the MIUR Project COFIN 2001013518 Cometa.
1 Email:honsell@dimi.uniud.it.
2 Email:lenisa@dimi.uniud.it.
3 corresponding author.
4 Email:rrekhareddy@yahoo.com.


coalgebra for a suitable functor F and the syntax has to be cast in form of an F -coalgebra. This approach is driven by the operational semantics of the language, because it is the semantics which determines the structure of the functor F . This is dual to the syntax-driven approach of algebraic semantics (initial, denotational semantics), where syntax is construed as an initial F - algebra and the semantics is defined as an F -algebra. The main advantage of the coalgebraic semantics is that it induces a behavioural equivalence on programs, which can be characterized as a coalgebraic bisimilarity, i.e. as greatest coalgebraic bisimulation. For preliminaries on coalgebraic semantics, we refer to [11].
However, in the original coalgebraic approach only a single class in isolation
is considered and the setting is purely functional.
In dealing with Fickle, the approach of [13,9] needs to be refined to ac- comodate imperative features as well as general programs, i.e. sequences of classes possibly related by inheritance, mutual definitions, etc. Special care needs to be devoted to representing the store, and in defining the evolution of objects, we have to take into account all possible pointers involving them.
For the sake of simplicity, we deal first only with non-binary methods, i.e. methods which take no more than one class argument. Binary methods cannot be treated simplistically, since they produce contravariant occurrences of the variable in the corresponding functor. Extensions of the coalgebraic paradigm to mixed functors have been considered in [14], but such extensions are rather complex and cover only a restricted range of cases. We briefly sketch an alternative approach to dealing with binary methods, based on representing functions as graphs. This approach is completely satisfactory in a purely functional setting. However, in an imperative setting, binary methods bring about further problematic issues which we briefly touch upon.
Interestingly, the coalgebraic equivalence on Fickle objects induces a be- havioural equivalence on Fickle expressions, which can be used to study no- tions of observational equivalences. In this paper we use the coalgebraic equiv- alence to study the contextual equivalence ≈P , that we introduce. This is an equivalence on Fickle expressions, viewed as the bodies of the main method, with respect to a given program P , i.e. a collection of class definitions. Two main methods are equated if and only if they have the same behaviour in any context, w.r.t. the given program P.

Synopsis.
In Section 1, we recall the syntax and the operational semantics of Fickle and we introduce the observational equivalence on expressions (programs). In Section 2, we give the coalgebraic description of Fickle programs, together


with the induced behavioural equivalence. In Subsection 2.1, we discuss bi- nary methods. In Section 3, we compare the coalgebraic equivalence with the observational equivalence on expressions introduced before. Final remarks and directions for future work appear in Section 4.

Acknowledgements.
The authors would like to thank M. Dezani for helpful discussions.

The Language Fickle
In this section, first we recall the syntax and the operational semantics of the language Fickle (see [4] for more details). Then we introduce the observational equivalences on programs which we will study.

Syntax
Fickle syntax is summarized in Table 1. A Fickle program is a collection of (possibly abstract) class definitions. A class definition may be preceded by the keyword state or root. State classes describe the properties of an object while it satisfies some conditions; when it no longer satisfies these conditions, it can be explicitly re-classified to another state class. Root classes abstract over state classes. While (state) classes consist of a sequence of fields and methods, in abstract (root) classes, some methods can only be declared. Any subclass of a state or a root class must be a state class. Objects of a state class c may be re-classified to a class c', where c' must be a subclass of the uniquely defined root superclass of c. Objects of a non-state, non-root class c behave like Java objects, i.e. they are never re-classified. The type of fields may be either boolean or integer or a non-state class. Hence, fields cannot be reclassified. In contrast, the type of this and parameters may be a state or root class, i.e. these variables may be reclassified. However, although these restrictions are important in order to define a sound type system (see [4]), they are not strictly necessary to our purposes.
Objects are created with the expression newc, where c is any class. Re- classification expressions, id ⇓ c, set the class of id to c, where c must be a state class.
Methods declarations have the shape:
t m (t1x1,... , tqxq){c1,... , cn}{ e }
where t is the result type, t1,... , tq are the types of the formal parameters
x1,... , xq and e is the body. The list of root classes c1,... , cn are the effect,


progr	:=	class∗
class	:=	[ state ] class c extends c { field∗ meth∗ } absclass	:=	[ root ] class c extends c { field∗ meth∗ mdecl∗ } field	 :=	 type f
meth	:=	type m (par∗) eff { e }
mdecl	:=	type m (par∗) eff
type	:=	bool | int | c
par	:=	type x
eff	:=	{ c∗ }
expr ( ) e	:=	if e then e else e | var:=e | e;e | sVal | this | var |
new c | e.m(e∗) | id⇓c
var	:=	x | e.f
sVal	:=	true | false | null | 0 | 1 . . . id	:=	this | x
with the following conventions
Table 1 Syntax of Fickle


i.e. the root classes of all objects that may be re-classified by invocation of that method.
For simplicitly, we assume all fields in the classes to be private, i.e. to be accessible from outside the class only through the class methods. On the contrary, we take all methods in a class to be public. Moreover, we assume no local variables in method bodies.
In Table 1, summarizing Fickle syntax, we have omitted the syntax of boolean and integer expressions, which involves the standard operators.
Finally, we assume the inheritance hierarchy to be a tree, root classes to extend only non-root and non-state classes, and state classes to extend either root classes or state classes. For examples of Fickle programs, we refer to [3,4].


Operational Semantics
The operational semantics is given in terms of a SOS “big-step” relation −→, which rewrites pairs of expressions and stores w.r.t. to a program P into pairs of values, exceptions, or errors, and stores. The expression which is evaluated is meant to represent the special method main (external to P ) from which the execution of the program starts. The type of the rewriting relation is:

−→ : progr → expr × store → (val ∪ dev ) × store

where:


object      cobjectc
store      ({this}→ addr ) × (varid →pfin val ) × (addr →pfin object) , 
where sVal is defined in Table 1, varid is the set of variable identifiers, ﬁdc is the set of field identifiers of c, and →pfin denotes the space of partial functions with finite domain. Notice that an element of objectc is in fact a partial function in (ﬁdc →pfin val ).
In particular, stores are partial functions with ﬁnite domain, mapping this to an address, variables of base type to values, variables of class type to addresses, and addresses to objects. Notice in particular that, in the store, addresses point to objects, but not to other addresses. Thus in Fickle, as in Java, pointers are implicit, and there are no pointers to pointers. We denote addresses with ι, stores with σ, values with v, objects with o, exceptions and errors with dv.
Before introducing the rewriting rules, we need to define some operations on objects and stores. For object o  [f1 : v1,... , fl : vl,... fr : vr]c, store σ, value v, address ι, identifier or address z, field identifier f , we define:
ﬁeld access: o(f )  vl   if f = fl for some l ∈ 1,... , r,
Udf  otherwise
	object update: o[v/f ]  [f1 : v1,... , fl : v,... fr : vr]c, where fl = f for some l ∈ 1,... , r,
store update:  σ[v/z](z)= v, σ[v/z](z')= σ(z') if z' /= z.
We use the convention that σ(ι)(f ) = Udf , whenever σ(ι) = Udf , i.e.
ι /∈ dom(σ).
Tables 2 and 3 list the rewriting rules of the operational semantics.
For lack of space, in Table 3 some rules are compressed in a single one (see e.g. the first rule). Notice that the rules as presented in Table 3 are non-deterministic, but common sense suggests how to resolve ambiguities.
The evaluation of the expression new c in a store σ extends σ with a new canonical address. Moreover, all fields of the new object are initialized with canonical values, which we assume, by convention, to be false and 0 for


boolean and integer fields, respectively, and null for fields of class type. The function FS used in the rule for new (and for re-classification) is such that FS(P, c) returns the set of fields defined in the class c, while FS(P, c, f ), used in the rule for reclassification, gives the type of the field f in class c.
In the rule for method call, e0.m(e1,... , en) in Table 2, we use the function M: M(P, c, m) returns the definition of method m in class c going through the class hierarchy (see [4] for more details). Moreover, the premise σn(ι)= [...]c means that, in the store σ' , the address ι refers to an object of the class c.
For re-classification expressions, id ⇓ d, we find the address of id, which points to an object of class c. We replace the original object by a new object of class d. We preserve the fields belonging to the root superclass of c and initialize the other fields of d according to their types (as in the case of new expressions). The term R(P, t), defined by


R(P, t) 
superclass of t
⎪⎩t	otherwise ,

denotes the least superclass of t which is not a state class, if t is a class, and denotes t itself if t is not a class.

Observational Equivalences
Various notions of observational equivalences on Fickle programs are naturally induced by the operational semantics. First of all, one can define a contextual equivalence on main methods w.r.t. a given program P , by evaluating the expressions corresponding to the bodies of the main methods in any expression context C[ ], and by observing the output value. A context is simply an expression with finitely many holes. As observable values, we take values of base types and errors/exceptions, i.e. obsval  sVal ∪ dev . With (e, σ) ⇓P u we abbreviate the fact that there exists σ' such that (e, σ) →P (u, σ'), for u ∈ sVal ∪ dev .
Definition 1.1 (Contextual Equivalence):
∆
Let ≈P ⊆ expr × expr be defined by: e ≈P e'	⇐⇒
∀C[ ] ∀σ ∀u ∈ obsval. (C[e], σ) ⇓P u ⇔ (C[e'], σ) ⇓P u . 

The contextual equivalence ≈P on expressions e, e' induces an equivalence between a program P together with a main method whose body is the expres- sion e, and the same program P together with a main method whose body



(e, σ) −→P (true, σ'')	(e, σ) −→P (false, σ'')
(e1 , σ'') −→P  (v, σ')	(e2, σ'') −→P  (v, σ')
(if e then e1 else e2, σ) −→P  (v, σ')	(if e then e1 else e2 , σ) −→P  (v, σ')

(e, σ) −→P (ι, σ'') (e', σ'') −→P (v, σ''')
σ(x) /= Udf	σ'''(ι)(f ) /= Udf
(e, σ) −→P (v, σ')	σ'  σ'''[σ'''(ι)[v/f ]/ι]
(x := e, σ) −→P (v, σ'[v/x])	(e.f := e', σ) −→P  (v, σ')
(e1 , σ) −→P (v', σ'')	(e, σ) −→P  (ι, σ')
(e2 , σ'') −→P  (v, σ')	σ'(ι)(f ) /= Udf
(e1 ; e2, σ) −→P (v, σ')	(e.f, σ) −→P  (σ'(ι)(f ), σ')
 σ(id) /= Udf			
(id, σ) −→P  (σ(id),σ)	(v, σ) −→P  (v, σ)
FS (P, c)= {f1 ,..., fr }
vl initial for F(P, c, fl) (∀l ∈ {1, ... , r})
 ι is new in σ	
(new c, σ) −→P  (ι, σ[[f1 : v1 ,. .., fr : vr ]c/ι])
(e0 , σ) −→P  (ι, σ0)
(ei, σi−1 ) −→P (vi, σi) (∀i ∈ {1, ..., n}) σn(ι)= [.. .]c
M(P, c, m)= t m(t1x1,... , tnxn) φ { e }
σ' = σn[ι/this, v1 /x1 ,..., vn/xn]
(e, σ') −→P  (v, σ'')
(e0 .m(e1,..., en), σ) −→P  (v, σ''[this '→ σn(this), x1 '→ σn(x1),... , xn '→ σn(xn)])

σ(id)= ι σ(ι)= [.. .]c
FS (P, R(P, c)) = {f1 ,.. ., fr }
vl = σ(ι)(fl) (∀l ∈ {1, ... r})
FS (P, d) \ {f1 ,..., fr } = {fr+1,.. ., fr+q }
 vl initial for FS (P, d, fl) (∀l ∈ {r + 1,. .. r + q})		(id, σ) −→P (null, σ')
(id ⇓ d, σ) −→P (ι, σ[[f1 : v1 ,.. ., fr+q : vr+q ]d/ι])	(id ⇓ d, σ) −→P (null, σ')

Table 2
Operational Semantics: execution without exceptions and errors


is the expression e'. Notice that, by the assumption that all fields in a class are private (see Section 1.1), main methods can only access objects through class methods. In particular, in Definition 1.1 above, field access expressions appear neither in the expressions e, e' nor in the context C[ ].
In the definition of the observational equivalence ≈P above, the program P is fixed. However, in many cases, e.g. in program refinement, we are interested in establishing equivalences between different programs P1, P2, which imple- ment the same program specification. A simple notion of program specification can be taken to be a list of abstract classes with no fields and only a sequence of method declarations. Then a program P1 implements a program specifica-






(e, σ) −→P (v, σ')
(e, σ) −→P (null, σ')
(e.f := e', σ) −→P (nullPntrExc, σ')
(e.f, σ) −→P (nullPntrExc, σ')
( e.m(e1,..., en), σ) −→P  (nullPntrExc, σ')

 v /= true and v /= false		 σ(x)= true or σ(x)= false	 (if e then e1 else e2, σ) −→P (stuckErr, σ')			(x ⇓ c, σ) −→P (stuckErr, σ)
(e, σ) −→P (v, σ')
v /= null
 σ(x)= Udf		 v /∈ addr	 (x, σ) −→P (stuckErr, σ)			(e.f, σ) −→P (stuckErr, σ')
(x := e, σ) −→P (stuckErr, σ)	(e.f := e', σ) −→P (stuckErr, σ') (x ⇓ c, σ) −→P (stuckErr, σ)
(e0, σ) −→P (ι, σ0 )
(ei, σi−1 ) −→P (vi, σi) (∀i ∈ {1, ..., n})
(e, σ) −→P  (ι, σ')	σn(ι)= [.. .]c
σ'(ι)(f )= Udf	 M(P, c, m)= Udf	
(e.f, σ) −→P (stuckErr, σ')	(e0.m(e1,.. ., en), σ) −→P  (stuckErr, σn)
(e0 , σ) −→P (v, σ0)	(e, σ) −→P  (ι, σ'')
v /= null	(e', σ'') −→P  (v, σ')
 v /∈ addr or σ0(v)= Udf		σ'(ι)(f )= Udf
(e0 .m(e1,..., en), σ) −→P  (stuckErr, σ0 )	(e.f := e', σ) −→P  (stuckErr, σ')
(e, σ) −→P (dv, σ') or
((e, σ) −→P (true, σ'') and (e1, σ'') −→P (dv, σ')) or
((e, σ) −→P (false, σ'') and (e2, σ'') −→P (dv, σ')) (if e then e1 else e2, σ) −→P (dv, σ')
(e1, σ) −→P (dv, σ') or ((e1, σ) −→P (v, σ'') and (e2, σ'') −→P (dv, σ')) (e1; e2, σ) −→P (dv, σ')
(e, σ) −→P (ι, σ'')
(e, σ) −→P (dv, σ')	(e', σ'') −→P (dv, σ')
(x := e, σ) −→P (dv, σ')	(e.f := e', σ) −→P (dv, σ') (e.f, σ) −→P (dv, σ')
(e.m(e1,... , en), σ) −→P (dv, σ') (e.f := e', σ) −→P (dv, σ')
(e0, σ) −→P (ι, σ0)
(ei, σi−1) −→P (vi, σi) (∀i ∈ {1,... , q}, q < n)
 (eq+1, σq) −→P (dv, σq+1)	 (e0.m(e1,... , en), σ) −→P (dv, σq+1)
(e0, σ) −→P (ι, σ0)
(ei, σi−1) −→P (vi, σi) (∀i ∈ {1,... , n}) σn(ι)= [.. .]c
M(P, c, m)= t m(t1x1,... , tn : xn) φ { e }
σ' = σn[ι/this, v1/x1,... , vn/xn]
(e, σ') −→P (dv, σ'')
(e0.m(e1,... , en), σ) −→P  (dv, σ''[σn(this)/this, σn(x1)/x1,... , σn(xn)/xn])

Table 3
Operational semantics: generation and propagation of exceptions and errors


tion P , when the method declarations in each class of P1 correspond exactly to the method declarations in P . One could consider a more sophisticated notion of program specification, involving a first-order logic for expressing conditions on the fields. This would be useful for studying program refinement. By way of example, we introduce the following simple equivalence.
Two programs P1, P2, implementing the same program specification P , can be taken to be equivalent, when for any possible main method, they evaluate to the same value:
Definition 1.2 Let P1, P2 implement the same program specification P . We define the equivalence  by:


P1  P2
⇐∆⇒ ∀e ∀u ∈ obsval. (e, ∅) ⇓	u ⇔ (e, ∅) ⇓	u . 


For lack of space, in this paper we will focus only on the contextual equiva- lence ≈P and we will not study the program equivalence of Definition 1.2. We just point out that our coalgebraic description of Fickle objects given in the next section induces also a notion of coalgebraic program equivalence, which would be interesting to compare with the program equivalence .

Coalgebraic Description of Fickle Objects and Pro- grams
In this section, we give a coalgebraic account of Fickle objects (and programs) for the fragment of Fickle consisting of unary methods, i.e. methods which do not take more than one object parameter. Following [13,9], we model classes as coalgebras, where the carrier represents the objects of the classes, and the coalgebra structure is determined by the operational semantics of the methods. The coalgebra structure captures the evolution of the objects under the action of methods.
In order to model the evolution of objects in an imperative setting, we need to account also for sharing of addresses in the store and aliasing of variables. Our coalgebraic model naturally induces a coinductive equivalence on ob- jects of a program P , which we will use in Section 3 to study the contextual
equivalence introduced in Definition 1.1.
Finally, we briefly discuss the general case of binary methods. These are problematic to deal with, since they produce contravariant occurrences of the parameter in the functor modeling the program. We propose two possible approaches, in order to turn contravariant occurrences into covariant ones. The first consists in “freezing” the contravariant occurrence of X to the carrier


of the coalgebra. The second consists in representing binary methods as graphs instead of functions. Under suitable conditions the two approaches coincide.
Moreover, in order to account for the behaviour of objects under binary methods, we need to extend the original approach, by describing not only the behaviour of the objects under application of methods of their class, but also under application of any other binary method in the program which uses such objects as parameters.
Finally, in dealing with binary methods in an imperative setting we need to take care of possible inconsistencies of referenced values by object parameters. We start by defining our representation of imperative objects of a class c.
Definition 2.1 Let refobjectc be the set of pairs (ι, O), where ι ∈ addr , and O ∈ (addr →pfin object) is the least closed function, — i.e. ∀o ∈ range(O). ∀ι ∈ range(o). ι ∈ dom(O) —, such that ι ∈ dom(O) and O(ι) ∈ objectc.
Essentially, a refobject can be viewed as a minimal store induced by an address, when we do not consider the environment part.
In what follows, we simply denote by O an element (ι, O) of	c refobjectc.
Before introducing our coalgebraic semantics, we need to define the notion of consistency between refobjects and stores, the notion of store update with a refobject, and the notion of refobject induced by an address in a store:
Definition 2.2 Let σ ∈ store, O ∈ refobjectc, ι ∈ addr .
O and σ are consistent, written con(O, σ), if for all addresses ι ∈ dom(O), if ι ∈ dom(σ), then O(ι)= σ(ι).
For O and σ consistent, and x ∈ id , we define σ[O/x] the store σ in which the object corresponding to the refobject O has been associated to x, and the rest of the store, if necessary, has b een updated according to O.
Let ι ∈ dom(σ). We denote by σ(ι) the unique refobject (ι, O) included in σ. Let x ∈ varid ∪ {this}. We denote by σ(x), σ(x) itself, if x has base type, the unique refobject (σ(x), O) included in σ, otherwise.
Now we introduce the coalgebraic description of the fragment of Fickle con- sisting of unary methods. To this aim, we endow the set of refobjects of a given program P with a coalgebra structure for the functor induced by the methods in P . A method t0 m(t1x1,... , tqxq) in P , when called on an object together with a list of actual parameters, can either terminate (successfully or with an exception/error) producing a possibly modified object, or not terminate. The behaviour of methods on objects determines the coalgebraic structure:
Definition 2.3 Let P  c1,... , cn, where ci  {fi1; ... fihi ; mi1; ... ; miki }.

Let F : Set → Set be defined by

F      Fij ,

where Fij : Set → Set is determined by the method declaration
t0 mij (t1x1,... , tqxq) {c' ,... , c' }
1	p
of the class ci as follows:
FijX  [[t1]] × ... × [[tq]] → (([[t0]] + dev ) × X + 1) ,


where, for all i = 0,... , q,

[[ti]] =

bool	if ti = bool
int	if ti = int
⎪⎩addr	otherwise .


The definition of Fij on arrows is canonical.
Let us denote	ci refobjectci simply by refobject P . Let αP : refobject P →
F (refobjectP ) be defined by
αP   [⟨αij⟩j]i ,
where αij : refobjectci → Fij(  c' ∈Cij refobjectc' ), for Cij the set of classes to




αij(O)   a '→
(e, ∅[O/this, a/x])−→P (u, σ1)
⎪⎩∗	otherwise ,


where ∗ denotes the only element of 1. Notice that the store ∅[O/this, a/x] is always defined (i.e. there are no consistency problems), since all actual parameters are of base type.

Let [ ]F
: (refobject P
, αP ) → (ΩF , αΩF
) be the coalgebraic semantics, i.e.

the unique F -coalgebra morphism into the ﬁnal F -coalgebra.
By applying the general theory of coalgebraic semantics, we get the fol- lowing coinductive characterization of the equivalence induced by [ ]F :



Proposition 2.4 The coalgebraic semantics [[ ]]F
induces the following be-

havioural equivalence on objects of P: for all O, O' ∈ refobjectc, where c is a class of P,
O∼F O' ⇐⇒
∀ method m(x) in c with body e, ∀ list of arguments a for x,
(e, ∅[O/this , a/x]) −→P (u, σ1)	⇒	(e, ∅[O'/this, a/x]) −→P (u, σ' ) ∧
σ1(this )∼F σ' (this), and conversely.
P  1
Corollary 2.5 ∼F is the greatest ﬁxed point of the following monotone (w.r.t. subset inclusion) operator on relations on refobjects:
Φ(R)  {(O, O') | ∀m(x): e in c, ∀ list of arguments a for x,
(e, ∅[O/this , a/x]) −→P (u, σ1)	⇒	(e, ∅[O'/this, a/x]) −→P (u, σ' ) ∧
σ1(this ) R σ' (this), and conversely } .
In other words, the following coinduction principle for establishing ∼F is sound
and complete:
ORO' ∧ R is a Φ-bisimulation
O ∼F O'
where a Φ-bisimulation R is a relation s.t. R ⊆ Φ(R).
Example 2.6 i) Let Register be a class with just one field containing the integer value of a register, and two methods, getval and setval. The first method returns the contents of the register, the latter sets the contents to a new value passed as parameter, and returns the new value. One can easily check that the coalgebraic equivalence on objects class Register equates two registers if and only if they have the same contents.
Let IntList be a class representing possibly circular lists of integers. The class IntList has two fields, representing the head and the tail of a list, i.e. containing an integer value and a list, respectively, and two methods, returning the head and the tail of a list. Then the coalgebraic equivalence on IntList equates two lists if and only if they have the same value in the head and the same address in the tail.
In order to recover the extensional equivalence on lists, one can define the class IntList by considering just one method, taking an integer n as parameter and returning the value of the n-th element of a list.
The coalgebraic equivalence ∼F equates objects which behave in the same way under method application, for all lists of parameters, in the minimal store. Actually, store minimality is not relevant. Namely, one can easily show that the behaviour of an object only depends on method parameters, and not on the rest of the store, if we assume that the expression new c does not appear in the bodies of class methods. However, we conjecture that the


above assumption can be eliminated. Anyway, we feel that this is not a strong assumption, since usually class methods are used to access or modify objects, while creation of new objects is performed in the main method.
Moreover, in what follows, we tacitly assume also that, if two objects of a root class d are ∼F -equivalent, then their canonical extensions (via re- classification) to objects of a state subclass c are still ∼F -equivalent. This means that in the subclass c there are no extra methods which discriminate solely on the basis of the fields in the superclass d. This is quite a natural hypothesis, which is necessary to deal with re-classification.
Thus we have:
Lemma 2.7
O∼F O' ⇐⇒
∀ method m(x) in c with body e, ∀σ. con(O, σ) ∧ con(O', σ ),			
(e, σ[O/this]) −→P (u, σ1) ⇒ (e, σ[O'/this]) −→P (u, σ' ) ∧ σ1(this)∼F σ' (this),
1	P  1
and conversely.
The equivalence ∼F on refobjects naturally induces an equivalence on
stores, if we take stores to be equivalent on all variables:
Definition 2.8 We define


σ ∼F σ'

	
⇐∆⇒ ∀x ∈ id. σ(x) ∼F σ'(x) .

Another immediate consequence of the fact that object behaviour only depends on method parameters, is that, if two objects are ∼F -equivalent, then they behave in the same way under application of methods on ∼F -equivalent
parameters:
Lemma 2.9
O∼F O' ⇐⇒
∀ m(x): e in c, ∀σ, σ'. σ ∼F σ' ∧ con(O, σ ) ∧ con(O', σ'), (e, σ[O/this]) −→P
(u, σ1) ⇒ (e, σ'[O'/this]) −→P (u, σ' ) ∧ σ1(this)∼F σ' (this), and conversely.
1	P  1

Binary Methods
If a method mij in Definition 2.3 is binary, then clearly the functor Fij (and hence F ) is not covariant. An example of a binary method is the method equal : c × c → bool , which takes another instance of the class as argument. The second occurrence of c produces a contravariant occurrence of X in FX 
... × (X → ((bool + dev ) × X)+ 1) ×   Therefore, the coalgebraic approach
does not apply directly in this case.


A first solution for turning contravariant occurrences in the functor F in covariant ones consists in “freezing” the contravariant occurrence of X to the carrier refobject P of the coalgebra. For example, in the case of the method equal, we could take GX  ... × (refobject P → ((bool + dev ) × X)+ 1) × ... . An alternative approach consists in modeling binary methods as graphs instead of functions, by substituting the powerset functor in place of the func- tion space. In the case of the method equal this would correspond to take
HX  ... × P(X × ((bool + dev ) × X)+ 1) × ... .
Moreover, in both cases, in order to describe correctly the behaviour of objects under application of binary methods, we need to extend the original coalgebraic approach and consider in the definition of the functor also (binary) methods, of possibly different classes, to which the object is supplied as a parameter. Otherwise we loose the analogue of Lemma 2.9. Namely, let us consider the following trivial counterexample. Let A be a class with only one field of type bool, and just one (binary) method m taking as argument another object of the class A, and returning the value of the field of this argument. Then all objects of A are coalgebraic equivalent, if we do not consider the behaviour of objects as (ordinary) arguments of m. However, the method m applied to the same object together with arguments with different values in the field gives non-equivalent results.
In general, the equivalence induced by G is included in the equivalence induced by H, but not vice versa. In order to make the two approaches coincide with the “intended contravariant” equivalence, one has to compensate the “observability deficit” of unary methods. Roughly, one has to add in the class a sufficient number of unary methods allowing to observe all the fields used by binary methods. As a consequence, the coalgebraic equivalence is determined solely by unary methods.
This programme works out smoothly in a functional setting, [8]. However, in our imperative setting, binary methods give rise to the extra issue of possible inconsistencies between the object O and the other object parameters, even in the empty store. In particular, if we consider the natural extension of the coalgebraic semantics of unary methods to binary methods, we get an object equivalence which discriminates on the basis of addresses, both in the case of the freezing functor G and in the case of the graph functor H. Namely, let us focus on freezing, and let us consider the class Register of Example 2.6, extended with the binary method add, which adds the contents of two registers. Then the method add tells apart registers with different addresses but equal contents, when we apply it to a register parameter consistent with
e.g. the first register but not with the second one. To overcome this problem, one could modify the notion of object equivalence, by testing the behaviour


of objects under method application only on parameters consistent with both objects. However, somewhat surprisingly, this is not a transitive relation, in general. A possible solution to the transitivity problem above consists again in compensating the observability deficit of unary methods. However, this deserves further study, and we leave it as an open problem how to give a coalgebraic description of Fickle objects in the general case.

Coalgebraic and Observational Equivalences on Pro- grams
In this section, we introduce a notion of equivalence on expressions w.r.t. a
.
program P , ≈P , which is induced by the coalgebraic equivalence on objects

∼F of Section 2, and we briefly discuss the relationships between .
and the

P	≈P
contextual equivalence ≈P of Section 1.3.
From now on we denote the equivalence ∼F simply by ∼P . The coalgebraic equivalence on objects introduced in the previous section naturally induces a notion of equivalence on expressions representing bodies of main methods
w.r.t. a given program P . Two main methods are equivalent w.r.t. P when, for any store, they produce equivalent values and equivalent stores:
.
Definition 3.1 Let ≈P ⊆ expr × expr be defined by:

e .	'
≈P e  ⇐⇒
∀σ. ((e, σ) →P (u, σ1) =⇒ (e', σ) →P (u', σ' ) ∧ u ∼P u' ∧ σ1 ∼P σ' ),
1	1
and conversely,

where u is u, if u ∈ sVal ∪ dev , and it is σ1(u), if u ∈ addr .


i.e:
.
We conjecture that ≈P is adequate w.r.t. the contextual equivalence ≈P ,

Conjecture 3.2 (Adequacy of
.
≈P ):
.
≈P ⊆≈P .

.
Completeness of ≈P trivially fails, because in the contextual equivalence
there is no way of observing different addresses generated by new expressions. For instance, if the class c in the program P is s.t. only objects with the same address are ∼P -equivalent, then the expressions e  x := new c and
e'  x := new c; x := new c are not ∼P -equivalent. However, there is no
context separating them, since in the observational equivalence ≈P we only observe values of base types. Nevertheless, we can still get a completeness result for the restricted set of expressions not containing new expressions,


under the assumption that in each class of the program there is an observable and modifiable field of base type:
Theorem 3.3 (Completeness of ≈P ): Let P be a program, and let e, e' be main methods for P. If e, e' do not contain new expressions, and in each class c of P there is a ﬁeld f of base type, a method m1, which returns the value of f, and a method m2, which sets the ﬁeld f to a value given as parameter,

then e ≈P
e' =⇒ e .
e' .

Proof. Assume by contradiction e ≈P
e', but e

.
/≈P
e'. The difficult case is

.
when e /≈P
e' because Eσ. (e, σ) →
P (ι, σ1) Λ (e', σ) →P (ι', σ' ), but ι /~P
ι' (if

returned values are equivalent, but Ex. σ1(x) /~P σ' (x), then we proceed as in the previous case by considering C[]  [ ]; x). Let us assume that the objects
to which ι, ι' point in the stores σ1, σ' are of class c. If σ1(ι).f /= σ' (ι').f ,
then the context C[]  [ ].m2(.. .) tells apart e and e', getting a contradiction. Otherwise, if σ1(ι).f = σ' (ι').f , then let z be fresh, and let us consider the store σ[ι/z]. Then the context C[]  z.m2(... a.. .); ([ ].m1(.. .)= z.m1(.. .)), where a is a new value for the field f , tells apart e and e' in the store σ[ι/z]. 
Notice that the assumption of no occurrence of new expressions in e, e' is fundamental in the proof above, since the technique of extending the store with a fresh variable would not work in the case the addresses ι, ι' are generated by new expressions.

Final Remarks and Directions for Future Work
In this paper we have introduced a contextual equivalence on Fickle pro- grams, and we have defined a coalgebraic behavioural equivalence, which we conjecture to be adequate w.r.t. the contextual equivalence, and which is com- plete under suitable restrictions on syntax. To achieve this we had to extend the coalgebraic framework of [13,9] for OO-languages to the imperative case. Object re-classification is captured in a very natural way in the coalgebraic semantics.
In the future, we plan to:
accomodate coalgebraically binary methods in the imperative setting;
introduce coalgebraic equivalences between program implementations of the same specification, which approximate the program equivalence of Defini- tion 1.2;
explore the semantics of types in the coalgebraic setting;


extend the coalgebraic description of Fickle programs of Section 2 to bial- gebras, modeling method constructors as algebra operations;
explore program logics, capitalizing on the coinduction principles supported by the coalgebraic semantics.

References
P.Aczel. Non-well-founded sets, CSLI Lecture Notes 14, Stanford 1988.
P.Aczel. Final Universes of Processes, MFPS’93, Brookes et al. eds., LNCS 802, 1993.
S.Drossopoulou, Three Case studies in Fickle II , Tech. rep., Imperial College. Available from
http://www.di.unito.it/∼damiani/papers/dor.html.
S.Drossopoulou, F.Damiani, M.Dezani-Ciancaglini, P.Giannini. More dynamic object re- classification: FickleII , ACM Transactions On Programming Languages and Systems 24(2), 2002, 153–191.
U.Hensel, M.Huisman, B.Jacobs, H.Tews. Reasoning about Classes in Object-Oriented Languages: Logical Models and Tools, European Symposium on Programming, C.Hankin ed., Springer LNCS 1381, 1998, 105–121.
F.Honsell, M.Lenisa. Final Semantics for Untyped Lambda Calculus, TLCA’95 Conf. Proc., M.Dezani et al.eds., Springer LNCS 902, Berlin 1995, 249–265.
F.Honsell,  M.Lenisa,  U.Montanari,  M.Pistore.  Final  Semantics  for  the  π-calculus,
PROCOMET’98, D. Gries et al. eds, Chapman & Hall, 1998.
F.Honsell, M.Lenisa, R.Redamalla. Coalgebraic Semantics of Binary Methods for a Functional OO-Language, in preparation.
B.Jacobs. Objects and Classes, co-algebraically, Object-Orientation with Parallelism and Book Persistence, B.Freitag et al. eds., Kluwer Academic Publishers, 1996, 83–103.
B.Jacobs. Behaviour-refinement of object-oriented specifications with coinductive correctness proofs, TAPSOFT’97, M.Bidoit, et. al. eds., Springer LNCS 1214, 1997, 787–802.
B.Jacobs, J.Rutten. A tutorial on (co)algebras and (co)induction, Bulletin of the EATCS 62, 1996, 222–259.
M.Lenisa. Final Semantics for a Higher Order Concurrent Language, CAAP’96, H.Kirchner et. al. eds., LNCS 1059, 1996, 102–118.
H.Reichel. An approach to object semantics based on terminal co-algebras, MSCS 5, 1995, 129-152.
H.Tews. Coalgebras for Binary Methods, CMCS’2000, ENTCS 33, 2000.
J.J.M.M.Rutten, D.Turi. REX Conference Proceedings, J.de Bakker et al. eds., LNCS 803, 1994, 530–582.
