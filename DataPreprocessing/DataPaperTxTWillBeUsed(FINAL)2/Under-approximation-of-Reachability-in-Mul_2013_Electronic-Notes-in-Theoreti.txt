Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 299 (2013) 33–51
www.elsevier.com/locate/entcs

Under-approximation of Reachability in Multivalued Asynchronous Networks
Maxime Folschette,a,1 Loïc Paulevé,b Morgan Magnina and Olivier Rouxa
a LUNAM Université, École Centrale de Nantes, IRCCyN UMR CNRS 6597 (Institut de Recherche en Communications et Cybernétique de Nantes)
1 rue de la Noë - B.P. 92101 - 44321 Nantes Cedex 3, France.
b ETH Zürich, Switzerland.
BISON group, Automatic Control Laboratory, ETH Zürich Physikstrasse 3, 8092 Zurich, Switzerland.

Abstract
The Process Hitting is a recently introduced framework designed for the modelling of concurrent systems. Its originality lies in a compact representation of both components of the model and its corresponding actions: each action can modify the status of a component, and is conditioned by the status of at most one other component. This allowed to define very eﬃcient static analysis based on local causality to compute reachability properties. However, in the case of cooperations between components (for example, when two
components are supposed to interact with a third one only when they are in a given configuration), the approach leads to an over-approximated interleaving between actions, because of the pure asynchronous semantics of the model.
To address this issue, we propose an extended definition of the framework, including priority classes for actions. In this paper, we focus on a restriction of the Process Hitting with two classes of priorities and a specific behaviour of the components, that is suﬃcient to tackle the aforementioned problem of cooperations. We show that this class of Process Hitting models allows to represent any Asynchronous Discrete Networks, either Boolean or multivalued. Then we develop a new refinement for the under-approximation of the static analysis to give accurate results for this class of Process Hitting models. Our method thus allows to eﬃciently under-approximate reachability properties in Asynchronous Discrete Networks; it is in particular conclusive on reachability properties in a 94 components Boolean network, which is unprecedented.
Keywords: qualitative modelling, model abstraction, static analysis, asynchronous network


Introduction
Discrete modelling frameworks for biological networks is an active research field where formal methods have proved that they were very powerful. Such a work started in the seventies. It was later enriched in many directions and widely used to elucidate many biological questions. Among these questions, a major one is to

1 Maxime.Folschette@irccyn.ec-nantes.fr


1571-0661 © 2013 Elsevier B.V. Open access under CC BY-NC-ND license.
http://dx.doi.org/10.1016/j.entcs.2013.11.004

understand precisely how biological systems evolve and behave; why and how they change their usual behaviours. . . This leads to questions about the reachability (possible or inevitable) of some states. The ultimate goal is to discover how it could be possible to prevent biological systems from reaching some pathological states.
Of course, such formal models on which analyses are performed are abstract rep- resentations of the actual studied systems. They are associated with parameters that have to be synthesised to give the most faithful representation of the real systems with their observed behaviours. As a matter of fact, the abstractions we get are more or less rough or accurate. Usual formal frameworks for such modelling activities are state-transition systems or process algebras. We developed a quite similar frame- work named the Process Hitting [10], consisting in a restriction where the evolution of a component is determined by the state of at most one other component that does
not evolve. In a sense, these kind of actions are of the form X + Y → X + Z where X
behaves like a catalyst molecule that “hits” another molecule Y and changes it into Z, without being itself changed. Assuming catalysts are always available, this can represent any biochemical system made of monomolecular reactions, and can also represent catalytic networks such as metabolic networks. Our motivation behind this framework was to design a model and analysis techniques adapted to biological mod- elling. These analyses avoid to build the whole state space, which allows to tackle very large systems (that would have led to a huge number of states, hopelessly too huge to be analysed). They are based on the fact that most biological models have few levels of expression per component: in Boolean networks [8,13] there are only two levels per component and in its multivalued equivalent, Asynchronous Discrete Networks [5], components rarely have more that four levels.
Besides, one further objective of our work is now to improve the accuracy of the description of the studied systems dynamics. The idea for this is to introduce timing features into models: we are interested in taking into account some knowledge about the relative length of some phenomena as it is a way to refute some models (or parameters) that are inconsistent with the observed dynamic behaviours. In this paper, we are dealing with these timing properties through priorities, that are based on the simple founding idea that prioritised actions have to be processed before the other ones. Indeed, due to the Process Hitting framework restrictions, bimolecular reactions are not immediately available, but one can simulate them with an encoding called “cooperation”. That encoding however introduces extra reactions, and this is where the priorities become useful, if not necessary. The extra reactions can be given “infinite speed” (high priority) so that they do not affect the behaviour of “normal” (low priority) reactions, including the bimolecular ones.
Until now, such a priority scheduling of the actions was not studied extensively in the different formal modelling frameworks dedicated to systems biology. Never- theless, such an attempt has been carried out for Petri nets by F. Bause [1], and the concept of priority relations among the transitions of a network has also more recently been introduced by A. K. Wagler et al. [15,14] in order to allow modelling deterministic systems for biological applications. The concept of priority is much straightforward in the approach of process algebras as it was shown by R. Cleaveland

and M. Hennessy in [2,4] and their abstractions and equivalences were studied in [3]. It was later extended for applications in the field of systems biology by M. John et al. [7].


Contributions
Since our formalism (the Process Hitting) can be considered as a subset of Cal- culus of Communicating Systems, our work is related to such semantic ramifications of extending traditional process algebras with the concepts of priority that allow for some transitions to be given precedence over others. The concept is derived in two directions: dynamic versus static, the difference being naturally that the former one refers to a semantics where priority values may change during execution according to some evolution rules. In our work, actions exhibit a two-level static priority struc- ture, some of them being designated as “prioritised” and others as “unprioritised”.
In this paper, we introduce a new extension to the semantics of Process Hitting by partitioning actions into classes of priorities. One of the objectives is to reach an accurate representation of cooperating components in the model, that was not fulfilled with the initial semantics. We then develop an efficient under-approximation of the reachability of the state of components on a subclass of this new framework, thus allowing to compute efficient static analysis. This local reachability under- approximation can be also easily extended to study the reachability of a global state. Finally, as the subclass of models studied proves to be bisimilar to Asynchronous Discrete Networks, we state to have developed an efficient method to compute the reachability of a state and thus study the behaviour of such models.
The method developed in this paper has been implemented into the existing Pint library and tested on a large-scale biological model containing 94 components. The under-approximation turned out to be conclusive in all cases and results were computed in hundredths of seconds, thus overtaking the efficiency of usual model- checkers.
Our paper is organised as follows. The Process Hitting framework is defined in section 2; we introduce static analysis of the Process Hitting in section 3; section 4 illustrates the approach on an example before the discussion and conclusion in section 5.


Notations
If A is a finite set, |A| is the cardinality of A and ℘(A) is the power set of A. N is the set of natural numbers, N∗ = N \ {0} is the set of positive natural numbers and Jx; y) = {x, x + 1,...,y − 1, y} is the set of natural numbers from x to y included. If x = (xi)i∈J1;n) is a sequence of elements indexed by i ∈ J1; n), Ix = J1; n) is the set of indexes of this sequence. We also denote by ε the empty sequence. If A and B are sets, f : A → B denotes an application f that maps the elements of A to elements of B. lfp{x0} (x '→ xj) is the least fixed point of the function x '→ xj which is greater than x0. The Cartesian product is denoted ×.

The Process Hitting Framework
We give in this section the definition and the semantics of the Process Hitting (PH) with priorities, which is an extension of the basic semantics given in [10]. Then we describe the modelling of cooperation between components and discuss how the new aforementioned semantics makes this modelling more accurate. Finally, in order to perform a static analysis adapted to this new semantics, we give several criteria to restrict the class of models that we can study, and give several theorems that follow. This class of models is equivalent to Asynchronous Discrete Networks.

Definition of the Process Hitting with k classes of priorities
A PH with k classes of priorities (Def. 2.1), also simply called “PH” in the following when it is not ambiguous, gathers a finite number of concurrent processes divided into a finite set of sorts. A process belongs to a unique sort and is noted ai where a is the sort and i the identifier of the process within the sort a. Each process stands for a kind of “activity level” of its sort; a state of the PH thus corresponds to a set of processes containing exactly one process of each sort.
The concurrent interactions between processes are defined by a set of actions divided into classes of priorities. Actions describe the replacement of a process by another of the same sort conditioned by the presence of at most one other process and by the fact that no other action of higher priority can be played in the considered state of the PH. An action is denoted by ai → bj F bk where ai, bj, bk are processes of sorts a and b. It is required that bj /= bk and that a = b ⇒ ai = bj. An action h = ai → bj F bk is read as “ ai hits bj to make it bounce to bk”, and ai, bj, bk are called respectively hitter, target and bounce of the action, and can be referred to as hitter(h), target(h), bounce(h), respectively.
Definition 2.1 [Process Hitting with k classes of priorities] If k ∈ N∗, a Process Hitting with k classes of priorities is a triplet PH = (Σ; L; H⟨k⟩), where H⟨k⟩ = (H(1); ... ; H(k)) is a k-tuple and:
Σ =Δ {a, b, . . . } is the finite set of sorts,
L =Δ × La is the finite set of states, where La = {a0,..., al } is the finite set
a
a∈Σ
of processes of sort a ∈ Σ and la ∈ N∗. Each process belongs to a unique sort:
∀(ai; bj) ∈ La × Lb,a /= b ⇒ ai /= bj,
∀n ∈ J1; k), H(n) =Δ {ai → bj F bl | (a; b) ∈ Σ2 ∧ (ai; bj; bl) ∈ La × Lb × Lb ∧ bj /=
bl ∧ a = b ⇒ ai = bj} is the finite set of actions of priority n.

We call Proc =Δ
all actions.

a∈Σ
La the set of all processes, and H =Δ S

n∈J1;k)
H(n) the set of

The sort of a process ai is referred to as Σ(ai)= a. Given a state s ∈ L, the process of sort a ∈ Σ present in s is denoted by s[a], that is the a-coordinate of the state s. If ai ∈ La, we define the notation ai ∈ s ⇔Δ s[a]= ai. The override of a state s by a

process ai is defined in Def. 2.2 as the same state in which the process of sort a has been replace by ai, which then allows to define the dynamics of a PH in Def. 2.3.
Definition 2.2 [A : L× Proc → L] Given a state s ∈L and a process ai ∈ Proc, (s A ai) is the state defined by: (s A ai)[a] = ai ∧ ∀b /= a, (s A ai)[b] = s[b]. We also extend this definition to a set of processes ps given that all processes are from different sorts by the override of each process: ∀as ⊆ Σ, ∀ps ∈  × La,s A ps =
a∈as

s  A
ai∈ps
ai.

Definition 2.3 [Dynamics of a PH (→PH )] An action h = ai → bj F bk ∈ H(n) of priority n is playable in s ∈ L if and only if s[a] = ai, s[b] = bj and ∀m < n, ∀g ∈ H(m), hitter(g) ∈/ s∨ target(g) ∈/ s. In such a case, (s· h) stands for the state resulting from the play of the action h in s and is defined by: (s·h)= sAbounce(h). Moreover, we denote: s →PH (s · h).
If s ∈ L, a scenario δ from s is a sequence of actions of H that can be played successively in s. The set of all scenarios from s is noted Sce(s).
In Def. 2.4, we define the n-reduction of a given PH as the PH with n classes of priorities in which only actions of priority lower or equal to n are considered.
Definition 2.4 [PH n-reduction] If PH = (Σ; L; H⟨k⟩) is a Process Hitting with k classes of priorities and n ∈ J1; k), we denote PH n the n-reduction of PH. PH n = (Σ; L; Hj⟨n⟩) is a PH with n classes of priorities with:
Hj⟨n⟩ = (H(1); ... ; H(n))
Furthermore, we denote: Sce n(s) the set of scenarios from s in PH n.
Example 2.5 Fig. 1 gives an example of PH with 2 classes of priorities where:
Σ= {a, b, c, ab} ,
La = {a0, a1} ,	Lb = {b0, b1} ,
Lc = {c0, c1} ,	Lab = {ab00, ab01, ab10, ab11} .
There also is especially: {ab11 → c0 F c1, a1 → a1 F a0, a0 → b0 F b1}⊆ H(2).

Modelling cooperation
Cooperation between processes to make another process bounce can be expressed in PH by building a cooperative sort, as described in [10]. Fig. 1 shows an example of cooperation between processes a1 and b1 to make c0 bounce to c1: a cooperative sort ab is defined with 4 processes (one for each sub-state of the presence of processes a1 and b1). For the sake of clarity, the processes of ab are indexed using the sub- state they represent. Hence, ab10 represents the sub-state ⟨a1, b0⟩, and so on. Each process of sort a and b hit ab to make it bounce to the process reflecting the status of the sorts a and b (e.g., a1 → ab00 F ab10 and a1 → ab01 F ab11). Then, to represent









1

0









Figure 1. An example of PH with 2 classes of priorities. Sorts are represented as labelled boxes and processes as circles with their identifier on the side. Actions of H(1) are represented by thick arrows and
actions of H(2) are represented by single arrows; the hit part of each action in drawn in plain line and the bounce part is in dotted line. Greyed processes stand for a possible state s = ⟨a1, b0, c0, ab10⟩.

the cooperation between a1 and b1, the process ab11 hits c0 to make it bounce to c1
instead of independent hits from a1 and b1.
We note that cooperative sorts are standard PH sorts and do not involve any special treatment regarding the semantics of related actions. Furthermore, it is possible to “factorise” cooperative sorts in order to decrease the number of processes created within each cooperative sort. For example, if three processes x1, y1 and z1 cooperate, it is preferable to create a cooperative sort xy with 4 processes to state the presence of x1 and y1 and a second cooperative sort xyz with 4 processes to state the presence of xy11 and z1, rather than a unique cooperative sort with 8 processes stating the presence of x1, y1 and z1. This “factorisation” allows to prevent the combinatorial explosion of the number of processes in cooperative sorts, especially for cooperations between more than three processes. It may have computational consequences as the static analysis method developed in Sect. 3 does not suffer from the number of sorts but from the number of processes in each sort.
The construction of cooperation in PH allows to encode any Boolean function between cooperating processes [10]. Due to the introduction of priorities into the PH framework, it is possible to build cooperations with no temporal shift by defining actions updating the cooperative sorts with the highest class of priority. This allows to gain the same expressivity in PH than in Boolean networks, as stated in Sub- sect. 2.2. The aim of this paper is to allow the static analysis of the dynamics to be

handled on PH models comprising such higher priority actions updating cooperative sorts.

Restrictions
In the scope of this paper, we focus on a specific class of PH models. We define here the restrictions that lead to this class of models and show that they are equivalent to discrete networks.
Criterion 2.6 allows to distinguish two kinds of actions: unprioritised actions
modelling the non-determinacy of biological evolutions and prioritised actions used to model non-biological behaviours in the model, namely the update of cooperative sorts. Criterion 2.7 states that the dynamics of the studied model PH contains no infinite sequence of prioritised actions. As these actions can be considered as non-biological and therefore instantaneous, we thus prevent the existence of any Zeno-like behaviour which would allow the play of an infinite sequence of prioritised actions in “zero time”.
Criterion 2.6 (2 classes of priorities) In this paper, we only consider Process Hitting with 2 classes of priorities: PH = (Σ; L; H⟨2⟩).
Criterion 2.7 (Bounded termination) The dynamics of PH 1 contains no cy- cles: ∃N ∈ N, ∀s ∈ L, ∀δ ∈ Sce 1(s), |δ|≤ N.
In Def. 2.8 we define a well-formed component as a sort that is hit only by unprioritised actions, or that no action hits.
Definition 2.8 [Well-formed component (Γ)] A sort a ∈ Σ is a well-formed compo- nent if and only if:
∀h ∈ H, Σ(target(h)) = a ⇒ prio(h)=2 .
We call Γ the set of well-formed components.
Def. 2.9 defines chains of prioritised actions, and Criterion 2.10 prevents the presence of cycles in these chains.
Definition 2.9 The set of chains of actions H(a, b) between two sorts a, b ∈ Σ is defined as below:
H(a, b)= {(hi)i∈J1;s+1) ∈ (H(1))s+1 | s ∈ N
∧ Σ(hitter(h1)) = a ∧ Σ(target(hs+1)) = b
∧ ∀i ∈ J1; s), Σ(target(hi)) = Σ(hitter(hi+1))}

where (H(1))s+1 is the Cartesian product of s +1 times the set H(1).
Criterion 2.10 (Cycle-freeness in prioritised actions) There is no cycles in chains of actions: ∀a ∈ Σ, H(a, a)= ∅.

In Def. 2.11 we define the notion of neighbouring sorts and actions of a given sort. The set of neighbouring sorts VΣ(a) of a sort a is the set of components that can interact with it through prioritised actions. The set of neighbouring actions VH(a) of a is the set of prioritised actions influencing a. These definitions are permitted by the previous restrictions (Criterion 2.6 and 2.10).
Definition 2.11 [VΣ :Σ → ℘(Σ); VH :Σ → ℘(H)] For all sort a ∈ Σ,
VΣ(a)= {b ∈ Γ | H(b, a) /= ∅}
VH(a)= {h ∈ H(1) | ∃b ∈ VΣ(a), ∃hs ∈ H(b, a),h ∈ hs}
Finally, we introduce the notion of local steady-state of a sort from a given state. This local steady-state is the set of processes towards which the sort tends to evolve to, and stay in, when playing only prioritised actions. We denote lsts(a) this set of processes for a sort a in state s (Def. 2.12), and we derive from this the notion of well-formed cooperative sort (Def. 2.13). A well-formed cooperative sort models a cooperation between sorts as presented in Subsect. 2.2; therefore, it must be only hit by prioritised actions, in a way that its local steady-states efficiently represent all configurations of its neighbouring sorts.
Definition 2.12 [lst :Σ → ℘(Proc)] For all a ∈ Σ,
lsts(a)= {ai ∈ La | ∃δ ∈ Sce 1(s), (s · δ)[a]= ai
∧ ∀bi → cj F ck ∈ VH(a), (s · δ)[b] /= bi ∨ (s · δ)[c] /= cj}
Of course, if a ∈ Γ, then lsts(a)= {s[a]}.
Definition 2.13 [Well-formed cooperative sorts (Δ)] A sort a ∈ Σ is a well-formed cooperative sort if and only if:
∃b ∈ Σ, H(b, a) /= ∅
∀s ∈ L, ∃ai ∈ La, lsts(a)= {ai}
∀ai ∈ La, ∃s ∈ L, lsts(a)= {ai}
We call Δ the set of well-formed cooperative sorts.
Because of Def. 2.13(ii), we denote in the following: lsts(a)= ai. Furthermore, because of Def. 2.13(iii), we denote procState(ai) the set of sub-states represented by the process ai of any cooperative sort a (Def. 2.14).
Definition 2.14 [procState : Proc → ℘(Proc)] If a ∈ Δ and ai ∈ La, we define:


procState(ai)= {ps ∈	×
b∈VΣ(a)
Lb | ∀s ∈ L, lstsAps(a)= ai}

In the following we simply write “component” (resp. “cooperative sort”) instead of “well-formed component” (resp. “well-formed cooperative sort”). Finally, Crite- rion 2.15 states that the set of sorts of the considered PH must be divided between components and cooperative sorts.

Criterion 2.15 (Components & cooperative sorts partition)
Σ=Γ ∪ Δ ∧ Γ ∩ Δ= ∅
Example 2.16 The PH in Fig. 1 contains three components a, b and c and a cooperative sort ab that models cooperation between sorts a and b.
The criteria given in this subsection allow to define a class of PH models that is (weakly) bisimilar to Asynchronous Boolean Networks or, more generally, to the mul- tivalued version of this framework, called Asynchronous Discrete Networks (ADN). A translation of ADN into PH is given in Appendix B, alongside with a demonstra- tion of the weak bisimulation.
Consequences of the restrictions
In this subsection, we give several general theorems that can be derived from the restrictions of Subsect. 2.2, and which will help building the static analysis of Sect. 3.
We first denote by update(s) the state equivalent to s but in which all cooperative sorts are updated (Def. 2.17). This state is unique due to the properties of lst given
in the previous subsection. Then, Theorem 2.18 states that from any state, there exists a scenario updating the cooperative sorts of this state.
Definition 2.17 [update : L→ L] For all s ∈ L, we define:
update(s)= s A {lsts(a) | a ∈ Δ} .
Theorem 2.18 ∀s ∈ L, ∃δ ∈ Sce 1(s),s · δ = update(s)
Proof Let a be a cooperative sort so that s[a] /= lsts(a). Given the definition of lsts(a), there exists a scenario δ updating a in s so that ∀δj ∈ Sce 1(s · δ), (s · δ · δj)[a]= lsts(a). As there is no cycle of actions between the cooperative sorts (Criterion 2.10) and given that an updated cooperative sort cannot evolve, at most
|Δ| updates have to be performed.	2
Theorem 2.19 states that for a given state s, and for any action h = ai → bj F bk where a and b are components, if s[a]= ai and s[b]= bj, then h can always be played after a series of hits (and these hits do not prevent it to be fired). Theorem 2.20 states the same if a is a cooperative sort, under the condition that a is updated in s.
Theorem 2.19 ∀s ∈ L, ∀a, b ∈ Γ, ∀h = ai → bj F bk ∈ H,
(s[a]= ai ∧ s[b]= bj) ⇒ (∃δ ∈ Sce 1(s), (s · δ) →PH (s · δ · h))
Proof From Theorem 2.18, there exists a scenario δ with: (s · δ)= update(s). As a, b ∈ Γ, ai ∈ (s · δ) and bj ∈ (s · δ). Finally, by definition of update(s), no prioritised action can be played in (s · δ), thus h can be played in (s · δ).	2
Theorem 2.20 ∀s ∈ L, ∀h = ai → bj F bk ∈ H,a ∈ Δ,b ∈ Γ
(s[a]= ai ∧ s[b]= bj ∧ lsts(a)= ai) ⇒ (∃δ ∈ Sce 1(s), (s · δ) →PH (s · δ · h))
Proof Similar to the proof of Theorem 2.19; as ai ∈ lsts(a), ai ∈ (s · δ).	2

Static Analysis
The aim of this section is to define the problem of reachability in a PH, and propose an under-approximation allowing to efficiently solve it. The static analysis presented here is inspired from [11].

Preliminary definitions
The reachability of a process aj of a given sort a from another process ai is called an objective and is denoted ai F∗ aj (Def. 3.1).
Definition 3.1 [Objective (Obj)] If a ∈ Γ, the reachability of a process aj from a process ai is called an objective, noted ai F∗ aj. The set of all objectives is called Obj =Δ {ai F∗ aj | a ∈ Γ ∧ (ai, aj) ∈ L2}. For an objective P = ai F∗ aj ∈ Obj, we define: Σ(P )= a, target(P )= ai, bounce(P )= aj, and P is said trivial if ai = aj.
We define an objective sequence as a sequence of objectives in which each objec- tive target must be equal to the previous objective bounce of the same sort, if it exists. The set of all objective sequences is denoted by OS.
A context (Def. 3.2) extends the notion of state to a set of possible initial states.
We also extend the override operator to contexts (Def. 3.3).
Definition 3.2 [Context (Ctx)] A context ς associates to each sort in Σ a non- empty subset of its processes: ∀a ∈ Σ,ς[a] ⊆ La ∧ ς[a] /= ∅. Ctx is the set of all contexts.
Definition 3.3 [A : Ctx × ℘(Proc) → Ctx] For any ς ∈ Ctx and set of processes
ps ∈ ℘(Proc), the override of ς by ps is noted ς A ps and is defined by:

∀a ∈ Σ, (ς A ps)[a]=	{p ∈ ps | Σ(p)= a}	if ∃p ∈ ps, Σ(p)= a,
ς[a]	else.

For a given context ς, we note ai ∈ ς if and only if ai ∈ ς[a], and for all ps ∈ ℘(Proc) or ps ∈ L, ps ⊆ ς ⇔Δ ∀ai ∈ ps, ai ∈ ς. A sequence of actions δ is playable in a context ς if and only if ∃s ⊆ ς, δ ∈ Sce(s). We denote then: δ ∈ Sce(ς), and the play of δ in ς is ς · δ = ς A end(δ), where end(δ) is the set containing the last process in the sequence δ (hitter or bounce) of every sort mentioned in δ.
Finally, a bounce sequence on a sort a (Def. 3.4) is a sequence of actions hitting a in which the bounce process of each action is the hitter process of the following action. Bounce sequences are used to find local solutions to a given objective. A bounce sequence on a can be abstracted into sets of all its hitters that are not in sort a (Def. 3.5). This abstraction allows to propagate an objective on the sort a into objectives on other sots. In the following, we denote: Sol = ℘(Proc).
Definition 3.4 [Bounce sequence (BS)] A bounce sequence ζ is a sequence of ac- tions so that ∀n ∈ Iζ,n < |ζ|, bounce(ζn) = target(ζn+1). BS denotes the set of

all bounce sequences, and BS(P ) denotes the set of bounce sequences solving an objective P :
BS(ai F∗ aj)= {ζ ∈ BS | target(ζ1)= ai ∧ bounce(ζ|ζ|)= aj} .
BS(ai F∗aj)= ∅ if there is no way to reach aj from ai and ε ∈ BS(ai F∗ai).
Definition 3.5 [BSΛ : Obj → ℘(Sol)] The abstractions of bounce sequences of an objective P , denoted by the set BSΛ(P ), are the sets of hitters of bounce sequences solving P :
BSΛ(P )= {ζΛ ∈ Sol | ζ ∈ BS(P ), ∄ζj ∈ BS(P ),ζjΛ Ç ζΛ} ,
where ζΛ = {hitter(ζn) | n ∈ Iζ ∧ Σ(hitter(ζn)) /= Σ(P )}.

Under-approximation
We denote γς (ω) the set of scenarios concretising an objective sequence ω in the context ς. In Def. 3.6, we define lς (ω) as equal to γς (ω) if and only if γς (ω) contains scenarios starting from all states s ⊆ ς. Theorem 3.7 is used to over-approximate the initial context ς.
Definition 3.6 [lς : OS → ℘(Sce)]

l (ω)=  γς (ω)	if ∀s ∈ L,s ⊆ ς, ∃δ ∈ γς (ω),δ ∈ Sce(s)
∅	else.
Theorem 3.7 ς ⊆ ςj ∧ lς′ (ω) /= ∅ =⇒ lς (ω) /= ∅.
For any objective P and context ς, Def. 3.8 gives the set of processes of sort
Σ(P ) that are required to solve P in ς, given by maxContς (Σ(P ),P ).
Definition 3.8 [maxContς :Σ × Obj → ℘(Proc)]
maxContς (a, P )= {p ∈ Proc | ∃ps ∈ BSΛ(P ), ∃bi ∈ ps, b = a ∧ p = bi
∨ b /= a ∧ p ∈ maxContς (a, bj F∗ bi) ∧ bj ∈ ς[b]} .
The graph of local causality [Bω| = (V, E) defined in Def. 3.9 is a graph where
V ⊆ Proc∪Obj∪Sol and E ⊆ V ×V . A node in Proc is a required process, a node in Obj is an objective to reach a given process and a node in Sol is a set of processes required for the solving. An objective P ∈ Obj is solvable if the abstractions of bounce sequences BSΛ(P ) ∈ Sol (Def. 3.5) can be reached (Eq. (4)), thus leading to several required processes (Eq. (5)). If a ∈ Γ, the reachability of one of its process ai is approximated by the ability to solve all objectives aj F∗ ai ∈ Obj for all aj in the initial context (Eq. (6)); if a ∈ Δ, the reachability of ai is simply solved by the set of processes procState(ai) (Def. 2.14) that it represents (Eq. (7)). The solving of an objective P may require a process of Σ(P ), i.e. maxCont(Σ(P ),P ) /= ∅ (Def. 3.8); in this case, P is re-targeted (Eq. (8)). Eq. (1), (2) and (3) ensure that all required

nodes are in V ω. Finally, as the active process of every sort may evolve, [Bω| is
ς	ς
obtained by iteratively saturating with every process it contains, i.e. by overriding its initial context ς by procs(V, E), defined by:
procs(V, E)= (V ∩ Proc) ∪ {target(P ), bounce(P ) | P ∈ V ∩ Obj}
Definition 3.9 The graph of local causality [Bω| = ([V ω|, [Eω|) is defined as:
ς	ς	ς


ς	ς	ς
ς

ω ⊆ V ω


(1)

P ∈ V ∩ Proc ⇒ bounce(P ) ∈ V ω
(x, y) ∈ E ⇒ y ∈ V ω
P ∈ V ∩ Obj ∧ ps ∈ BS(P ) ⇒ (P, ps) ∈ Eω ps ∈ V ∩ Sol ∧ ai ∈ ps ⇒ (ps, ai) ∈ Eω
a ∈ Γ ∧ ai ∈ V ∩ Proc ∧ aj ∈ ς ⇒ (ai, aj F∗ ai) ∈ Eω a ∈ Δ ∧ ai ∈ V ∩ Proc ∧ ps ∈ procState(ai) ⇒ (ai, ps) ∈ Eω
P ∈ V ∩ Obj ∧ q ∈ maxContς (Σ(P ),P ) ⇒ (P, q F∗ bounce(P )) ∈ Eω
(2)
(3)
(4)
(5)
(6)
(7)
(8)


In the graph of local causality, an edge (p, ps) ∈ Proc × Sol is said coherent (Def. 3.10) if none of the processes in ps conflict with the children processes of ps. Then, Theorem 3.11 gives a sufficient condition for the concretization of a sequence of objectives in a given context, which is derived immediately from the graph of local causality. A proof of this theorem is given in Annex A.
Definition 3.10 [Coherent edge] An edge (x, y) ∈ Eω is said coherent if and only if: (x, y) ∈ [Eω|∩ (Proc × Sol) ⇒ y has no children process aj ∈ [V ω|∩ Proc so
ς	ς
that ∃ai ∈ y, ai /= aj.
Theorem 3.11 (Under-Approximation) If the graph [Bω| contains no cycle, all objectives have at least one solution and all edges are coherent, then lς (ω) /= ∅.
Computing the graph of local causality is polynomial in the number of sorts in PH and exponential in the number of processes in one sort. Checking the properties allowing to apply Theorem 3.11 is polynomial in the size of the graph. Furthermore, it is possible to compute only a subset of V ∩ Sol; in this case, the overall method turns out to be exponential in the number of solutions to each objective. Our method can thus be considered as efficient compared to regular model-checking which is usually PSPACE-complete [6].
Example 3.12 Let PHj = (Σ, L, Hj⟨1⟩) be the “flattened” version of the PH in Fig. 1, that is: Hj⟨1⟩ = H(1) ∪ H(2), which is equivalent to a PH in the semantics without priorities. Due to spurious behaviours inherent to the cooperative sorts in this semantics, the original under-approximation developed in [11] concludes that c1 is reachable in PHj from ς = ⟨a1, b0, c0, ab10⟩.

Such unwanted behaviours are palliated by the semantics of PH with priorities proposed in this paper. Indeed, the under-approximation given in Theorem 3.11 does not conclude regarding the reachability of c1, as one of the edges of the resulting graph of local causality is not coherent (Def. 3.10), as shown in in Fig. 2. (However, from the inconclusiveness of Theorem 3.11, one cannot conclude about the unreach- ability of c1. Such analysis should be driven for instance with over-approximation methods developed in [11].)
However, if a0 → b0 F b1 and b0 → a0 F a1 are replaced by a0 → a0 F a1 and
b0 → b0 F b1, then Theorem 3.11 concludes that c1 is reachable from ς.

c0 F∗ c1




ab11



a1	b1


a0 F∗ a1
a1 F∗ a1
b0 F∗ b1 b1 F∗ b1


	
b0


b1 F∗ b0
b0 F∗ b0

a0 F∗ a0
F∗ a0


	
Figure 2. The graph of local causality of the PH model in Fig. 1. Rectangular nodes containing a single process are elements in Proc, nodes containing a couple of processes are elements in Obj and circle nodes are elements in Sol. Theorem 3.11 is inconclusive on this example as edge (ab11, {a1, b1}) ∈ Proc × Sol (here represented with a double line) is not coherent (Def. 3.10). Indeed, a0 ∈ Proc is a child of {a1, b1}, but a0 /= a1 (and the same also stands for b0).


Reachability of a state
The semantics of PH with 2 classes of priorities studied in this paper allows to model cooperative sorts accurately representing a coherent configuration of a set of sorts. Therefore, we can derive a new method to conclude about the reachability of a state (considering only components). Indeed, let PH = (Σ, L, (H(1), H(2))) be

a PH and suppose that we want to study the reachability of a state s ∈ L. Let PHj = (Σj, Lj, (Hj(1), Hj(2))) with: Σj = Σ ∪ {τ, σ} and Lj = L× Lτ × Lσ, where τ is a cooperative sort on all components Γ of PH (thus Lτ = × La) and σ is a
a∈Γ
component with Lσ = {σ0, σ1}; furthermore, Hj(1) is the set H(1) completed with all actions updating the cooperative sort τ , and Hj(2) = H(2) ∪ {lsts(τ ) → σ0 F σ1}. Given an initial context ς, the reachability of s in PH is equivalent to the con- cretization of σ0 F∗ σ1 in PHj from the initial context ς ∪ {σ0} (the initial state of τ does not matter), which can be efficiently under-approximated using Theorem 3.11. Indeed, the additional action lsts(τ ) → σ0 F σ1 in Hj(2) allows to conclude on the
reachability of process lsts(τ ), that is, on the reachability of the state s (considering
only the components).
It is also possible to compute the reachability of a set of states S ⊆L by creating several actions τs → σ0 F σ1 in H(2) for each state s ∈ S.

Large-scale Biological Example
In order to support the scalability and applicability of our under-approximation of reachability, we apply our new approach for the analysis of large-scale model of the T-cell receptor (TCR) signalling pathway [12]. This model gathers 94 interact- ing components and is specified as a Boolean network. The under-approximation presented in this paper has been implemented in the existing Pint software 2 .
The Boolean model has been automatically encoded into a Process Hitting with 2 classes of priority 3 . Then, we verified the reachability for the independent ac- tivation of 4 outputs of the signalling cascade (SRE, AP1, NFkB, NFAT) from all possible input combinations (CD45, CD28, TCRlib) using our new reachability under-approximation (answering either yes or inconclusive) and a previously defined reachability over-approximation [11] (answering either no or inconclusive). All re- sult in conclusive decisions, and the under-approximation has been satisfied in 12 cases (over 32) proving the satisfiability of the concerned reachability property in the encoded Boolean network (and non-satisfiability in the other cases).
Computations times are in the order of a few hundredths of a second on a 2.4GHz processor with 2GB of RAM. To give a comparison, we did the same experiments with a standard symbolic model-checker, libDDD [9], known for its good perfor- mances, the input model being the Boolean network expressed as a Petri net. How- ever, due to the large scale of the model, the program runs out of memory for all the experiments.
While ensuring a low complexity for the analysis of reachability in Boolean and discrete networks, our under-approximation method reveals to be conclusive in nu- merous cases when applied to real large-scale biological models, which were not tractable with exact model-checking.

2 Pint is freely available at http://process.hitting.free.fr.
3 Model	and	scripts	are	available	at	http://www.irccyn.ec-nantes.fr/~folschet/ underapprox-tcrsig94.zip.

Discussion & Conclusion
We introduced a new semantics to include priorities into the Process Hitting frame- work, which prove especially useful to model cooperations. Then, we developed a method to efficiently perform a reachability analysis of a sequence of objectives in a restricted class of Process Hitting models, but it is also useful to establish the reachability of a partial state. This analysis is based on an under-approximation of the true reachability solutions.
We showed that the class of Process Hitting models that can be handled by the aforementioned method are equivalent to Asynchronous Discrete Networks, and therefore to Asynchronous Boolean Networks. This allows to efficiently compute reachability results on large biological models provided that they are equivalent to Asynchronous Discrete Networks and that a translation from the original framework into a Process Hitting model is possible. Such a translation for interaction graphs of Thomas modelling was proposed in [10].
Further work can be derived from what have been presented in this paper. The over-approximation on Process Hitting models without priorities proposed in [11] is still accurate in the framework with priorities (by “flattening” all actions), but may be refined given the restrictions proposed in this paper, and a specific search of key processes or cut sets may be derived. Furthermore, a more general under- approximation could be developed in order to handle a larger class of Process Hitting models, that is, models with more than two classes of priorities, that do not only contain components of cooperative sorts, or whose behaviour may contain cycles or cyclic attractors. Finally, in order to take into account quantitative data in transition delays, the overall approximation method could be extended to handle evolutions that are chronometric instead of only chronologic.

References
Bause, F., Analysis of Petri nets with a dynamic priority method, in: P. Azéma and G. Balbo, editors, Application and Theory of Petri Nets 1997, Lecture Notes in Computer Science 1248, Springer Berlin Heidelberg, 1997 pp. 215–234.
Cleaveland, R. and M. Hennessy, Priorities in process algebras, Information and Computation 87
(1990), pp. 58–77, special Issue: Selections from 1988 IEEE Symposium on Logic in Computer Science.
Cleaveland, R., G. Lüttgen and V. Natarajan, Priority and abstraction in process algebra, Information and Computation 205 (2007), pp. 1426–1458.
Cleaveland, R., G. Lüttgen and V. Natarajan, Priorities in process algebra (1999).
De Jong, H., Modeling and simulation of genetic regulatory systems: a literature review, Journal of computational biology 9 (2002), pp. 67–103.
Harel, D., O. Kupferman and M. Y. Vardi, On the complexity of verifying concurrent transition systems, Information and Computation 173 (2002), pp. 143–161.
John, M., C. Lhoussaine, J. Niehren and A. Uhrmacher, The attributed pi-calculus with priorities, in: C. Priami, R. Breitling, D. Gilbert, M. Heiner and A. Uhrmacher, editors, Transactions on Computational Systems Biology XII, Lecture Notes in Computer Science 5945, Springer Berlin Heidelberg, 2010 pp. 13–76.
Kauffman, S. A., Metabolic stability and epigenesis in randomly constructed genetic nets, Journal of theoretical biology 22 (1969), pp. 437–467.

LIP6/Move, the libDDD environment (libDDD), http://ddd.lip6.fr.
Paulevé, L., M. Magnin and O. Roux, Reﬁning dynamics of gene regulatory networks in a stochastic π-calculus framework, in: Transactions on Computational Systems Biology XIII, Springer, 2011 pp. 171–191.
Paulevé, L., M. Magnin and O. Roux, Static analysis of biological regulatory networks dynamics using abstract interpretation, Mathematical Structures in Computer Science 22 (2012), pp. 651–685.
Saez-Rodriguez, J., L. Simeoni, J. A. Lindquist, R. Hemenway, U. Bommhardt, B. Arndt, U.-U. Haus,
R. Weismantel, E. D. Gilles, S. Klamt and B. Schraven, A logical model provides insights into t cell receptor signaling, PLoS Comput Biol 3 (2007), p. e163.
Thomas, R., Boolean formalization of genetic control circuits, Journal of Theoretical Biology 42 (1973),
pp. 563 – 585.
Wagler, A. and J.-T. Wegener, On minimality and equivalence of Petri nets, in: L. Popova-Zeugmann, editor, CS&P, CEUR Workshop Proceedings 928 (2012), pp. 382–393.
Wagler, A. and R. Weismantel, The combinatorics of modeling and analyzing biological systems, Natural Computing 10 (2011), pp. 655–681.

Proof of Under-approximation (Theorem 3.11)
In the following, we denote: [Eω|X = [Eω|∩ (X × Y ), with X, Y amongst Proc,

Obj and Sol.
ς  Y	ς

Proof We note maxς = ς A procs([Bω|) the context supported by [Bω|.
ς	ς
Let (ai, ps) ∈ [Eω|Proc be an edge linking the required process of a cooperative
ς  Sol
sort to a solution set and suppose all children of ps are concretisable. We label all processes of ps by an integer: ps = {pn}n∈Ips . Let us prove by induction that for all n ∈ Ips, there exists a scenario δn so that: ∀i ∈ J1; n), (s · δn)[Σ(pi)] = pi.
It is straightforward for δ0 = ε.
Suppose such δn exists and let q = (s · δn)[Σ(pn+1)]. By hypothesis, (ai, ps) is coherent (Def. 3.10) and all processes of ps are processes of components; this means that none of the processes needed to solve pn+1 is another process of the
same sort than another process of ps. Therefore, there exists δj ∈ ls·δ (q F∗ pn+1),
so that ∀i ∈ J1; n + 1), (s · δn · δj)[Σ(pi)] = pi. Finally, by Theorem 2.18, there exists a scenario δjj ∈ Sce 1(s · δn · δj) so that, if we denote δn+1 = δn · δj · δjj, we have: update(s · δn · δj)= s · δn+1 and the same property about processes (by
Theorem 2.20).
Therefore, δ = δ|ps| exists, and given its properties, we have: (s · δ)[a] = ai and
update(s · δ)= s · δ.
As there is no cycle in [Bω|, we show by induction that ∀s ∈ L, s ⊆ maxς, for all objective P in [V ω|∩ Obj so that target(P ) ∈ s, ∃δ ∈ ls(P ).
If (P, ∅) ∈ [Eω|Obj, either target(P )= bounce(P ) and δ = ε; or ∀ζ ∈ BS(P ),ζ ∈
ς  Sol
Sce(s) ∧ Σ(ζ)= {Σ(P )} and δ = δ1 · ζ1 · ... · δ|ζ| · ζ|ζ| is a valid sequence given by
Theorem 2.19.
Suppose all children objectives of P are concretizable.  If ∃(P, Q) ∈ [Eω|Obj,
ς  Obj
then by hypothesis, ls(target(P ) F∗target(Q) :: Q) /= ∅, thus ls(P ) /= ∅. Else,
by Def. 3.8, the concretizations of the children of P require no process of sort

Σ(P ). Furthermore, there exists ζ ∈ BS(P ) so that (P, ζΛ) ∈ [Eω|Obj. We show
ς  Sol
by induction that for all n ∈ Iζ, there is a scenario δn so that (s · δn)[Σ(P )] =
bounce(ζn).
Suppose that δn exists and let ζn = bi → aj F ak. By hypothesis there exists

δj ∈ ls·δ
(  F∗ bi) with Σ(P ) ∈/ Σ(δj) (by Def. 3.8). By Theorem 2.18 there exists

δjj ∈ Sce 1(s·δj) so that update(s·δj)= s·δj ·δjj. Furthermore, (s · δj · δjj)[b]= bj
(by Theorem 2.19 if b ∈ Γ or Theorem 2.20 if b ∈ Δ).  Therefore, δn+1 =
δn · δj · δjj · ζn. Thus, δ|ζ| ∈ ls(P ).
Finally, as lmaxς (ω) /= ∅, lς (ω) /= ∅ (Theorem 3.7).	2

Weak Bisimulation of Asynchronous Discrete Networks (Subsect. 2.2)
We exhibit an encoding of Asynchronous Discrete Networks (ADN) with the Process Hitting using two classes of priorities, and prove a weak bisimulation relation.
A Discrete Network gathers a finite number of components i ∈ J1; n) having a discrete finite domain Fi that we note Fi = J1; li). For each component i ∈ J1; n), a map F → Fi is defined, where F = F1 × · · · × Fn, giving the next value of the component with respect to the global state of the network. Typically fi depends on a subset of components that we denote dep(fi). In the case of Asynchronous Discrete Networks (ADN), a transition relation →ADN ⊆ F × F is defined such that x →ADN xj if and only if there exists a unique i ∈ J1; n) such that xj[i]= fi(x) and
∀j ∈ J1; n),j /= i, xj[j] = x[j], i.e. one and only one component has been updated.
This is formalised in Def. B.1.
Definition B.1 [Asynchronous Discrete Network (ADN)] An ADN is defined by a couple (F, ⟨f 1,...,fn⟩) where F = F1 ×· · ·× Fn, and ∀i ∈ J1; n), fi : F → Fi with Fi = J1; li). Given two states x, xj ∈ F, the transition relation →ADN is given by
x →ADN xj ⇐⇒ ∃i ∈ J1; n),fi(x)= xj[i] ∧ ∀j ∈ J1; n),j /= i, x[j]= xj[j] ,
where x[i] is the i-th component of x. We note dep(fi) ⊆ J1; n) the set of components on which the value of fi depends: ∀x, xj ∈ F such that ∀j ∈ dep(fi), x[j] = xj[j], necessarily fi(x)= fi(xj).
Let us denote the encoding of the ADN (F, ⟨f 1,.  ,fn⟩) in Process Hitting with 2
classes of priorities by PH(F, ⟨f 1,...,fn⟩) (Def. B.2). For each component i ∈ J1; n) of the ADN, two sorts are built: ai acting for the component value, and fi acting for a cooperative sort between the components dep(fi). Sorts ai have one process ai
per element in k ∈ Fi. Sorts fi have one process fi per state ς ∈	×	Laj . Two
j∈dep(fi)
classes of actions are then defined: H(1) is the set of actions updating the cooperative
sorts according to the current state of the components: if j ∈ dep(fi), aj hits each

process fi where ς[aj] /= aj to make it bounce to the process fi
. H(2) is the set

ς	k	ςAaj

of actions encoding the transitions in the ADN: fi hits the processes of sort ai to make them bounce to the process ai ′ if and only if kj = fi(Jς)); Jς) being the ADN state corresponding to the PH (partial) state ς (note that fi(Jς)) is fully defined because Jς) specifies the state for all the components in dep(fi)).
Definition B.2 PH(F, ⟨f 1,...,fn⟩) = (Σ, L, (H(1), H(2))) is the Process Hitting with 2 classes of priority encoding the ADN (F, ⟨f 1,...,fn⟩), with:
Σ = {a1,..., an}∪ {f 1,...,fn}, the sorts for components (ai) and cooperative sorts (fi);

L =	×
Lai ×	×
Lfi , where Lai  = {ai ,..., ai }, and Lfi  = {fi
| ς ∈

i∈J1;n)
i∈J1;n)
0	li	ς

×
j∈dep(fi)
Lai } if dep(fi) /= ∅, otherwise Lfi = {fi};

H(1) = {aj → fi F fi | i ∈ J1; n) ∧ j ∈ dep(fi) ∧ aj ∈ Laj ∧ fi ∈ Lfi ∧ ς[aj] /=
k	ς	ς′	k	ς
aj ∧ ςj[aj]= aj ∧ (ςj[al]= ς[al], ∀l ∈ J1; n),l /= j)}, the set of actions with priority
k	k
1 that update cooperative sorts;

H(2) = {fi → ai F ai ′ | i ∈ J1; n)∧fi ∈ Lfi ∧ai
∈ Lai ∧k /= kj ∧fi(Jς))= kj}, the

ς	k	k	ς	k
set of actions with priority 2 for updating the components using their respective
discrete maps. Jς) is defined below.
Given a state s ∈L of the Process Hitting, Js) = x is the corresponding state in the
ADN: ∀i ∈ J1; n), s[ai]= ai ⇒ x[i]= k.
Given a state x ∈ F of the ADN, Qx¢ = s is the corresponding state in the Process
Hitting: ∀i ∈ J1; n), x[i]= k ⇒ s[ai]= ai and ∀i ∈ J1; n), s[fi]= fi with fi ∈ Lfi
k	ς	ς
and ∀j ∈ dep(fi),ς[j]= s[aj].
Theorem B.3 states the weak bisimulation relation between an ADN and its encoding in PH with 2 classes of priorities. Intuitively, actions updating cooperative sorts being prioritised, actions updating component sorts follow strictly the possible transitions of the ADN.
Theorem B.3 ((F, ⟨f 1,...,fn⟩) ≈ PH(F, ⟨f 1,...,fn⟩))

∀x, xj ∈ F, x →ADN xj =⇒ Qx¢ →∗
Qxj¢, where →∗
is a finite sequence of

→PH  transitions.
∀s, sj ∈ L, s →PH sj =⇒ Js) = Jsj) ∨ Js) →ADN Jsj) .
Proof (i) From Def. B.1, x →ADN xj ⇒ ∃i ∈ J1; n),fi(x)= xj[i] ∧ ∀j ∈ J1; n),i /=
j, x[j] = xj[j]. Let us assume (without loss of generality) that fi(x) = kj, x[i] = k

and ς ∈	×
j∈dep(fi)
Laj such that ∀j ∈ dep(fi),ς[j] = aj
. From Def. B.2, h = fi →

ai F ai ′ ∈ H(2). From the definition of Qx¢, ai ∈ Qx¢ and fi ∈ Qx¢; moreover, as
k	k	k	ς
there is no action in H(1) applicable in Qx¢, h is applicable in Qx¢: Qx¢ →PH Qx¢ · h. In Qx¢ · h, the only applicable actions of priority 1 are those having ai ′ as hitter and hitting cooperative sorts, giving a finite number of transitions towards Qxj¢.
(ii) s →PH sj only if there exists an action h applicable in s such that s · h = sj. If prio(h)= 1, then, by definition of H(1), Js) = Jsj). If prio(h)= 2, then ∀i ∈ J1; n),

if s[fi]= fi, then, 6j ∈ dep(fi),ς[aj]= s[aj]. Let i ∈ J1; n) such that s[ai] /= sj[ai] (i is unique for this transition). By Def. B.2, if sj[ai]= ai ′ , necessarily fi(Js))= kj, hence Js) →ADN Jsj).	2
