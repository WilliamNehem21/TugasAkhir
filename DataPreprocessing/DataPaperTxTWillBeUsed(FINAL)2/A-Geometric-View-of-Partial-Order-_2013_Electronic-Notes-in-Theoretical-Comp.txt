Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 298 (2013) 179–195
www.elsevier.com/locate/entcs
A Geometric View of Partial Order Reduction
Eric Goubault Tobias Heindel Samuel Mimram1
CEA, LIST
Gif-sur-Yvette, France

Abstract
Verifying that a concurrent program satisfies a given property, such as deadlock-freeness, is computationally difficult. Naive exploration techniques are facing the state space explosion problem: they consider an exponential number of interleavings of parallel threads (relative to the program size). Partial order reduction is a standard method to address this difficulty. It is based on the observation that certain sets of instructions, called persistent sets, are not affected by other concurrent instructions and can thus always be explored first when searching for deadlocks. More recent models of concurrent processes use directed topological spaces: states are points, computations are paths, and equivalent interleavings are homotopic. This geometric approach applies theoretical results of algebraic topology to improve verification. Despite the very different origin of the approaches, the paper compares partial-order reduction with a construction of the geometric approach, the category of future components. The main result, which shows that the two techniques make essentially the same use of persistent transitions, is of foundational interest and aims for cross-fertilization of the two approaches to improve verification methods for concurrent programs.

Verifying concurrent programs is a computationally difficult task because one has to check that the desired safety properties are valid for any possible scheduling of the program and, typically, the number of schedulings is exponential in the size of the program. For instance, consider the following concurrent program, consisting of two processes in parallel, each of which is modifying the contents of two memory cells:
x:=1;y:=2	|	y:=3;z:=4	(1)
In the following, we assume that the execution model is sequentially consistent, so that an execution of the program (1) will interleave the instructions of the two processes and thus corresponds to one of the following six sequential programs.

(2)

In order to verify that the program (1) is correct, one could thus use traditional verification techniques on the six programs (2), which can also be pictured as the

1 The authors gratefully acknowledge support from the project PANDA ANR-09-BLAN-0169.

1571-0661 © 2013 Elsevier B.V. Open access under CC BY-NC-ND license.
http://dx.doi.org/10.1016/j.entcs.2013.09.013

x02
z:=4
x01
x:=1
x12
z:=4
x11
y:=2


y:=2
x22
z:=4
x21

z:=4

y:=3	y:=3	y:=3
y:=3

x00
x:=1
x10
y:=2
x20
x:=1	y:=2


Fig. 1. Asynchronous transition semantics and geometric model of (1).
paths from x00 to x22 on the left of Figure 1. However, this approach will not scale up because the number of sequential programs corresponding to a concurrent one grows very fast: this phenomenon is called state space explosion. In order to avoid it, techniques of state space reduction have been invented that exploit the inherent dependencies between instructions. For instance, the order in which x:=1 and y:=3 are executed is not relevant for most program properties: both possible executions result in the same memory state in the end. We use tiles (marked by ) on the left of Figure 1 to indicate when instructions can be switched in this way, and say that the instructions commute. Formally, the graph with tiles forms an asynchronous transition system or ats for short [19].
Notice that, in this program, the instruction x:=1 is persistent in the sense that it commutes with all possible instructions running in parallel with it (forming the second process). Without loss of generality, we might thus suppose that it is executed first and we are left to verify that the program x:=1;(y:=2|y:=3;z:=4) is valid. This program gives rise to only three possible executions, compared to the six of (2): we can avoid examining the paths going through the states x01 and x02. Of course we can iteratively use this procedure to reduce the program further, which results in removing paths going through the state x12. This procedure, introduced by Valmari and developed by Godefroid [7], is called partial order reduction (por) and has lead to a wide variety of successful tools such as SPIN [14] (where the above mentioned persistent sets are complemented with other techniques such as sleep sets). These tools have been originally devised to optimize deadlock detection (and have been extended afterwards in various ways). Thus, we shall focus on deadlock detection, though the intended range of application is wider (full reachability will be detailed in future works); moreover, we shall mainly be concerned with acyclic systems, which is also a common restriction in techniques of partial order reduction (see for example [6]).
Independently of advances of por, work on topological semantics of concurrent programs has lead to new techniques based on similar observations, but formulated in a much different context [8,9]. In this line of research, concurrent programs are modeled as directed topological spaces [4]. For instance, on the right of Figure 1, we see the space associated to the program (1): ignoring the curvy paths at this point, the space is essentially a filled square with a square hole (rendered in gray). Notice the strong resemblance between the space and the asynchronous transition system on the left: in some precise sense, the topological model is actually the geometrical counterpart of the ats (viz, its geometric realization): constructions in one setting can be reformulated in the other; avoiding the formal details about topology, we appeal to geometric intuition to illustrate the main ideas.

In the geometric approach, program executions are modeled as paths in a space, as shown in Figure 1. For instance the path that passes underneath the hole corresponds to the first possible scheduling in (2). Notice that paths should always be monotone when projected to a coordinate; this captures progression in time of each thread of a program. This is why topological spaces of the model need to be endowed with a notion of direction [13]. In these topological models, two interleavings that can be obtained from each other by repeatedly switching commuting instructions are represented as dihomotopic paths, i.e. paths which can be continuously deformed into each other. For instance, on the right of Figure 1, the two paths that pass on top of the hole are dihomotopic, but none of them is dihomotopic to the one that passes underneath; the reason is that the hole is an obstacle to continuous deformation of paths below and above the hole.
The interest of defining a program semantics in terms of topological spaces, is that it allows one to reuse concepts and tools coming from algebraic topology. This has enabled the formulation of state space reduction methods as follows. From a concurrency point of view, a path is inessential if it does not change the possible future paths, up to homotopy: such a path corresponds to an execution where neither the program has made a significant choice (such as choosing a branch of a conditional choice) nor the scheduler (such as ordering two concurrent actions which do not commute). Using a suitable formalization, one is naturally lead to consider the category of paths in the topological semantics of a program, quotiented by inessential paths in order to only retain the structure which is relevant for studying the program up to commutation of instructions, i.e. define a notion of reduced state space. This category, introduced in [11], is called the category of future components and is used in the tool ALCOOL [4,9], which has been successfully used in an industrial context [2] for deadlock detection.
Even though there is a striking similarity between the notions of persistent sets and inessential paths, the relationship between the two has never been formally studied and the purpose of this article is to fill this gap, in order for partial order reduction and geometric techniques to improve each other and combine their potential to alleviate the state space explosion problem. As a result, we are able to show that, under fairly reasonable assumptions, persistent transitions are the algebraic counterpart of inessential paths. Despite the fact that the analogy is intuitive, it turns out that the theoretical comparison is sometimes technically involved. On a more practical side, a preliminary comparison, based on experiments, was started in [4].
In Section 1, we begin with a review of the models of computations used here to formalize persistent sets: labeled transitions systems with independence (ltsi), which are generalized into asynchronous transitions systems (ats). In Section 2, we conservatively extend the original definition of persistent sets from ltsi to ats, which are closer to geometric models, and show that they retain their fundamental reduction potential to prune the search space for deadlock detection. Finally, we develop in Section 3 a first conceptual link between partial order reduction and directed algebraic topology; in Theorem 3.10, we make precise in what sense persistent

singletons are essentially the same as inessential morphisms, thus identifying a common concept of geometrical and partial order reduction methods (amongst the host of techniques and heuristics that are used in both approaches). This is further discussed in our summary in Section 4, together with venues for future research.
Models of concurrent computation
We shall use two models for concurrent computations: labeled transitions systems with independence (ltsi), as traditionally used in the por technique, and asyn- chronous transition systems (ats), which can be seen as algebraic counterparts of the directed topological spaces of the geometric point of view. Both of these formalize the state spaces of programs, such as the example given in Figure 1.

Labelled transition systems with independence
A labeled transition system (lts) is a triple (S, Λ, →) where S is a set of states,Λ is
a set of transition labels, and → ⊆ S × Λ × S is a transition relation. We write s −→t  sj

whenever (s, t, sj) ∈ → and s −→t
when t ∈ Λ is enabled in s, i.e. when there exists

a state sj such that s −→t
sj. We shall here consider only deterministic transition

systems, i.e. s −→t
sj and s −→t
sjj imply sj = sjj.

Two (labels of) transitions are considered to be independent if the relative order in which they are performed does not matter, in the sense that both schedulings are essentially the same computation and in particular yield the same result. This notion of independence motivates the following definition [7].
Definition 1.1 (Independence) A labeled transition system with independence (ltsi) consists of an lts (S, Λ, →) with an independence relation  , which is a symmetric, irreflexive relation  ⊆ Λ × Λ such that for each pair (t1, t2) ∈  and every reachable state s,

t1	j
j t2	t2

if s −→ s then s −→ iff s −→; and
t1	t2	jj
if both s −→ and s −→ hold, there exists a unique s  such that (for a unique
t1	t2	jj	t2	t1	jj

pair of states s1, s2 ∈ S) both s −→ s1 −→ s  and s −→ s2 −→ s
hold.

Asynchronous transition systems
Geometric models for concurrency have been introduced with the idea to apply tools developed in algebraic topology to the analysis of concurrent programs [8]; those programs are considered as directed topological spaces, in which (directed) paths correspond to particular executions of the program, and dihomotopy between paths is an equivalence of executions (relating schedulings of a concurrent program that lead to the same result). For the analysis of concurrent systems, the topological formalization can be replaced by its algebraic counterpart, namely asynchronous transition systems (or more generally precubical sets), which brings us closer to the formalism of ltsi as we recall here, see [12] for a detailed comparison between those

models.
Recall that a graph G = (V, E, src, tgt) consists of a set V of vertices, a set E of edges, and two functions src, tgt: E → V , which associate to each edge its source and target, respectively. A path u from vertex x to vertex y, denoted by u : x → y, is a sequence of consecutive edges; the empty path on a vertex x is denoted by εx : x → x. The concatenation of two paths u : x → y and v : y → z is denoted by u · v : x → z.
Definition 1.2 (Asynchronous transition system) An asynchronous transition system, or ats for short, is a pair (G, ⬦) where G is a graph (whose vertices are called positions and edges are called transitions) and ⬦ is a relation on the set of paths of length two that have the same source and target, i.e. (u, v) ∈ ⬦ only if u, v : x → y. The elements of ⬦ are called tiles. Two transitions m : x → y and n : x → z are independent, written m  n, if there exist transitions mj and nj such that (m · nj) ⬦ (n · mj), i.e. we have the tile as in (3), on the right below.

To formalize the fact that we can reschedule independent events in the run of a concurrent system without changing the actual computation that is performed, we use the following definition of trace, which refines Mazurkiewicz’s notion and is the algebraic counterpart of homotopy in topological spaces.
m	·	n′



(3)

Definition 1.3 (Trace) Two paths u, v : x → y are homotopic, written u ∼ v, if u can be obtained from v by repeatedly replacing path fragments m ·nj by mj ·n whenever there exists a tile (3), i.e. the relation ∼ is the smallest congruence w.r.t. path composition that extends ⬦. A trace is an equivalence class w.r.t. ∼ and we write [u] for the equivalence class of a path u.
Definition 1.4 (Trace category) The trace category associated to an ats (G, ⬦) has the vertices of G as objects and traces [u] with u : x → y as morphisms from x to y. Composition is the operation induced on traces by path concatenation and identities are empty traces [εx].
In order to relate this model with the one introduced in previous section, we should remark that each ltsi (Definition 1.1) naturally induces an ats as follows.


Definition 1.5 (Induced ATS) Let (S, ) be an ltsi
where S  = (S, Λ, →).	Its induced ats, denoted by
(s,t1,s1)	s1

(s1,t′ ,s′)

atsS
= (G, ⬦), has vertices as positions and edges as tran-
s	sj

sitions, i.e. V  = S and E = →; moreover, for each
j	j	(s,t2,s2)	(s2,t′ ,s′)
e = (s, t, s ) ∈ E we have src(e) = s, tgt(e) = s , and	s2	1
⬦ contains a tile as pictured on the right whenever t1  t2
t1	t2
and s −→ and s −→.
Example 1.6 Consider the ltsi on the left below with  = {(a, c), (c, a)}; its associated ats is shown in the middle. Notice that no ltsi can generate the ats on the right, because to generate its transitions, we would have to generate the “full cube” as stated in Lemma 2.11. In this sense, ats are more general than ltsi.


a	b

c
a
c

b


A labeled variant of ats can easily be defined and all the constructions performed on ats in this article can be generalized to the labeled case (see [12] for the precise relations between those models). However, the labels of transitions are not really needed since a suitable notion of transition label can be recovered abstractly as its associated event:
Definition 1.7 (Event) Let (G, ⬦) be an ats. Two transitions m and mj are parallel, written m 2 mj, if they form opposite sides of some tile (3), i.e. if there exists a tile (m · nj,n · mj) ∈ ⬦ for some transitions n and nj. An event is an equivalence class w.r.t. the least equivalence relation on transitions that contains 2.
For instance, in the middle ats in Example 1.6, the two vertical transitions on the left are elements of the same event, while the rightmost is not: considering the ltsi on the left, since b and c are not independent, performing c before or after b does not correspond to the same event – even though they carry the same label.
Remark 1.8 In the sequel, we shall restrict to ats that have unique ways to “close” tiles, and “switchings” of transitions are uniquely defined. Formally, the former means that (m · p) ⬦ (n · q) and (m · pj) ⬦ (n · qj) imply p = pj and q = qj while the latter says that u ⬦ v and u ⬦ w imply v = w. All ats that are induced by ltsi satisfy this property.
Persistent sets in asynchronous transition systems
Persistent sets are one of the most well-known techniques to reduce the number of executions to be explored to check that a concurrent program cannot lead to a deadlock state. Here, we generalize their definition to ats to compare it with geometric reduction techniques in Section 3. We begin by recalling Godefroid’s original definition [7].
Definition 2.1 (Persistent set) Given an ltsi (S, Λ, →, ) and a state s ∈ S, a set R ⊆ Λ of transition labels that are enabled in a state s ∈ S is persistent in s, if for all nonempty transition sequences


t1	t2
tn−1	tn

s = s1 −→ s2 −→ s3 ... −−−→ sn −→ sn+1
from s that satisfy ti ∈/ R (1 ≤ i ≤ n), tn  t holds for every transition t ∈ R.
A single transition can be considered persistent whenever it can be pulled back to the state at which it was first enabled by permuting it with independent (not necessarily persistent) transitions. More generally, persistent sets typically comprise the actions of a conditional choice of some concurrent component, as illustrated in the following example.

Example 2.2 Consider the programs below, with their respective ltsi semantics.


if (z<0)
y:=2	·

x:=1



x:=1 | y:=2
x:=1 | y:=2 else
·	·
(4)

y:=3
x:=1
·		y:=2 y:=3
·

In the ltsi on the left, we have x:=1 and y:=2 running completely in parallel; thus, both {x:=1} and {y:=2} are persistent sets at the initial state. In contrast, in the system on the right, the transitions x:=1 and y:=2 are in conflict with y:=3; the only persistent set consists of a “monolithic” component with no threads running concurrently, i.e. {x:=1, y:=2, y:=3} is the only persistent set at the initial state. As a final example, in Figure 1, {x:=1} and {x:=1, y:=3} are persistent in the initial state while the set {y:=3} is not.
Recall that a deadlock is a state in which no transition is enabled. As explained before, the main interest of persistent sets is to narrow the search for deadlocks in a concurrent program: given a choice of persistent set for each state, a reachable deadlock is always reachable by a path containing only transitions in the chosen persistent sets; it is therefore sufficient to explore a system “along” persistent sets:
Proposition 2.3 (Persistent deadlock reachability [7, Theorem 4.3]) Given a choice of a non-empty persistent set Rs at each state s that is not a deadlock, for

t0	tn
t′	j
j  t′

each path s0 −→ s1 ... sn −→ d to a deadlock d, there exists a path s0 −→0
s1 ... sn
−→n  d

such that tj ∈ Rs for all i ∈ {0,..., n}.
The proof of the preceding proposition is based on the following observation: for each path u : s → d leading to a deadlock d and persistent set R at s, there exists a path v ∈ [u] (i.e. v ∼ u) whose initial transition is in R. This motivates our generalization of the definition of persistent sets, based on the following definitions:
Definition 2.4 Let (G, ⬦) be an ats. Given a path u : x → z, a transition m : x → y is initial modulo homotopy if there exists a path v : y → z such that u ∼ m · v; the set of all transitions that are initial modulo homotopy in u is denoted by ˜ı(u). Two paths u : x → y and v : x → z with common source x are compatible, written u ↑ v, if there exist paths wy : y → xj and wz : z → xj with common target xj such that u · wy ∼ v · wz.
Thus, in particular all transitions that are initial modulo homotopy in some path are pairwise compatible. These notions enable us to generalize persistence to ats as follows:
Definition 2.5 (Homotopy persistent set) Let R be a set of transitions in an ats (G, ⬦) that share a state x as common source. The set R is homotopy persistent, if each path u : x → z is compatible with all transitions in R provided that no transition in R is amongst its homotopy initial ones, i.e.
∀u : x → z,	R ∩ ˜ı(u)= ∅	⇒	∀m ∈ R. u ↑ m.

Remark 2.6 A persistent singleton (a persistent set with a single element) corre- sponds to a transition that is compatible with all paths with the same source.
Example 2.7 The singleton {o → y} is an homotopy persistent set in the ats below in (5). Note that the transition o → y is compatible with the transition o → x even though the two transitions are not “independent”.


Situations like this typically arise in consumer pro-	z	yj
ducer problems where n-ary semaphores are used to
ensure that an exhausted resource is not used, such
as when implementing a queue with limited size. For	x  o
instance, suppose that we have a queue in which we
can put at most two elements (if there are already two	x
elements, the put operation blocks until an element is
taken from the queue).


o¯j x¯


 x¯j


(5)

The following program generates the above ats (the arrow subscripts indicate the direction of the corresponding transitions).
put†	|	if (...)	{take) | put→} else {takes | put→}
It remains to show that the notion of homotopy persistent set is in fact a conservative extension of the original one (Definition 2.1). The proof is based on the observation that in each ats that is induced by an ltsi, a transition m : x → y has a unique residual path u/m : y → zj after a compatible path u : x → z; we say this kind of ats has compatible residuals. The residual u/m of m after u has intuitively the “same effect” as u, once m has been performed. The assumption made in Remark 1.8 is necessary for the following definition to be sound.
Definition 2.8 (Residual) Let m : x → y be a transition, let u : x → z be a path. The residual of u after m, denoted by u/m, and the residual of m after u, denoted by m/u, are deﬁned by induction on the length of u as follows.
εx/m = εy and m/εx = m
(m · uj)/m = uj and m/(m · uj)= ε
If n /= m, (n · u)/m = nj · (u/mj) where mj and nj are transitions such that
m · nj ⬦ n · mj as in (3) (where mj is uniquely determined by Remark 1.8).
m


m	m/u ε
ε	ε	ε
m/v

x1	x2
x3 ·· ·xk—1
u
xk	yk
m/u
yk+1··· yl—1	yl
v

Remark 2.9 The residual m/u of a transition m after a path u (when it exists) is either a transition or empty (as illustrated above). It is straightforward to extend the definition to the residual v/u of a path v : x → z after a path u : x → y.

The fact that every ats that is induced by an ltsi has compatible residuals can be deduced from the fact that they satisfy a particular di- agrammatic property; it can be ex- pressed as follows [17].



q
x
′


p  ⇒ p
y






q



(6)

Definition 2.10 (Forward Cube Property)
An ats has the Forward Cube Property (or fcp) if for every three tiles as shown on the left in (6) there exist three matching tiles as shown on the right in (6).
Lemma 2.11 The induced ats of an ltsi has the fcp property.
Our main interest in this property is the following property [16]:
Proposition 2.12 (Residuation) An ats with the fcp has compatible residuals.
This proposition is the main tool to show that in fact our definition of persistent set is a conservative extension of the original one:

Proposition 2.13 (Homotopy persistent is persistent) Let (S, Λ, →, ) be an
ltsi, let x be a position, and let R ⊆ Λ be a set of transitions that are all enabled
at x. The set R is persistent at x if and only if the set Rj = {(x, t, y) | t ∈ R, x −→t y}
is homotopy persistent at x in atsS.
Proof. If R is persistent, it is easy to show that Rj is homotopy persistent since if a transition label in R is independent with all transitions labels on the path, it is in particular compatible with the corresponding transitions (by Definition 2.8).
Conversely, assume that Rj is homotopy persistent. Since atsS has the fcp by Lemma 2.11, for every path u : x → z, we can use Proposition 2.12 to show that either some residual of a transition in Rj occurs in u (if ˜ı(u) ∩ Rj /= ∅), or we have residuals of all transitions in Rj after u (if u is compatible with all transitions in Rj).
It can easily be checked that the residual of any transition in Rj always carries the same label as the “original” in Rj.	2
With this result at hand, we refer to homotopy persistent sets in ats as persistent ones from now on. Moreover, we have a further successful “soundness check” for our generalization of persistent sets, namely, the fundamental fact about reachability of deadlocks “along” persistent sets, namely Proposition 2.3, lifts to any ats.
Lemma 2.14 Let G = (G, ⬦) be an ats, let u : x → d be a path such that d is a deadlock and let R be a non-empty persistent set at x. Then R contains some of the initial transitions of u (i.e. u ∼ m · v for some m ∈ R and a suitable path v).
Proof. Consider a path u : x → d leading to a deadlock d. Suppose that u is compatible with all transitions in R. Because R is non-empty, there exists some transition m : x → y in R and paths uj : d → z and v : y → z such that u · uj ∼ m · v. Since d is supposed to be a deadlock, we necessarily have uj = εd and z = d.

Therefore u ∼ m · v, i.e. m ∈ ˜ı(u) and we conclude. Otherwise, u is incompatible with some transition m : x → y of R. Since R is homotopy persistent, R ∩˜ı(u) /= ∅.2
Corollary 2.15 (Persistent deadlock reachability) Let (G, ⬦) be an ats with
V and E as set of vertices and edges respectively, let R : V → ℘(E) be a function such that for all non-deadlocking states x ∈ V , the set Rx is a non-empty persistent set at x. Given a deadlock d ∈ V reachable by a path u : x0 → d, there exists a path v : x0 → d such that u ∼ v and every transition m : x → y occurring in v is persistent at x, i.e. m ∈ Rx.
Note that for arbitrary safety properties, persistent sets alone do not suffice, and one has to use extra techniques similar to the sleep sets of [7].
Finally, the following technical lemma will be useful in the following:
Lemma 2.16 In the trace category associated to an ats which satisﬁes the fcp every morphism is epi, that is for every paths u : x → y and v, w : y → z, [u · v]= [u · w] implies [v]= [w].
Comparing POR and categories of future components
In this section, we relate the notion of persistent set with the construction of the category of future components [10], which gives a condensed representation of (geometric models of) concurrent programs by eliminating states that enable only “inessential” transitions. We first reformulate this construction in the setting of ats, as well as related properties: we introduce the notion of future-reflecting trace, and the category of future components is then defined as the quotient of the category of traces by a consistent set of future-reflecting traces. After that, the crucial point is to make precise which transitions are considered as inessential. Intuitively, one might expect that all persistent transitions are inessential. However, the general definition of ats allows peculiar situations which do not occur in ats that are generated by usual programs (for instance persistent transitions might not be stable under residuation). Nevertheless, we will show, for suitably “well-behaved” ats, that inessential transitions are the same as persistent ones and that the category of future components does only contain states that do not enable persistent transitions.
The first requirement for inessential transitions is that they do not influence any choices that might lead to deadlocks. Intuitively, choices available in the future before and after performing an inessential transition should be the same: they should be future reflecting in the following sense.
Definition 3.1 (Future-reflecting trace) A trace [u] : x → y is future-reflecting if for each position z reachable from y (i.e. there exists a path y → z), precomposition with [u] induces a bijection between traces from y to z and traces from x to z.


z
x  y
[u]

⇒	x  y
[u]
z
[v]	~	x
z

[u]

Example 3.2 (Future-reflecting transition) Reconsider the ats in Figure 1. The only important choice for scheduling the transitions concerns the relative order of the instructions y:=3 and y:=2. Namely, the transition x00 → x10 (with label x:=1) does not influence the choice and thus is intuitively “inessential”. In fact, it reflects all futures according to the definition. For example, the two traces from x10 to x22 factor uniquely through x00 → x10. In contrast, the transition x10 → x20 (with label y:=2) does not reflect futures as there is only one trace from x20 to x22 while there are two traces from x10 to x22.
In other words, if a trace is future-reflecting, all choices in the future are already present at their source. The notion of future-reflecting transition is close to the notion of persistent transition; however, the two do not generally coincide as seen in the following examples.
Example 3.3 Consider the cube on the right.  All pairs of transitions are independent except for o → oj and
→ y (the front face of the cube is not a tile). Now, both
transitions o → y and o → oj are persistent since they are compatible with all other transitions from o. However neither of them is a future-reflecting trace. To see that
→ y is not a future-reflecting trace, consider the trace
[y → yj]. There is only one trace from y to yj but two from o to yj. The argument for o → oj is symmetric. The important point to notice in this example, is that the associated trace category is not a poset (it might have more than one morphism between two objects). In fact, it can be shown that when the trace category is a poset (this is the case for event structures), all persistent transitions are future-reflecting.
In the ats on the right, the transition o → y is persistent. However, it is not a future-reflecting trace since the trace [o → x] does not factor through [o → y]. Also note that this ats is actually induced by an ltsi.
The basic idea of state space reduction used in the category of future components is that future-reflecting transitions are not informative from a concurrency point of view and thus need not be represented explicitly. So, starting from an ats, one might be tempted to consider the associated trace category (Definition 1.4) and quotient it by all the future-reflecting traces, which amounts to formally turn them into identities. It turns out that this crushes too much information about traces (see [5], in particular there is no equivalence between the quotient and the fraction category and no compositionality result via Van Kampen theorems). A suitable solution is to quotient wrt a subset of all future-reflecting traces, namely those that are closed under composition and “residuals”; the formal details are as follows.
Definition 3.4 (System of inessentials) Let (G, ⬦) be an ats, and let Σf be a set of traces. The set Σf is a system of inessentials (soi) if
each element of Σf is a future-reflecting trace;
Σf contains all empty traces and is closed under composition;

Σf is stable under pushout, i.e. for every trace σ : x → z ∈ Σf and for any

[u′]
j σ′
σ	[u]

trace [u] : x → y, there exists a pushout z −−→ x
σj ∈ Σf .
→− y of z →− x −→ y such that

We recall that the pushout of two morphisms f : A → B and g : A → C in a category C is a pair of morphisms gj : B → D and fj : C → D such that fj ◦ g = gj ◦ f and moreover for any other pair of morphisms h : B → Dj and k : C → Dj that satisfy k ◦ g = h ◦ f , there exists a unique morphism
f	B
f′
g
C
h

D  Dj

k

l : D → Dj such that both k = l ◦ fj and h = l ◦ gj (as illustrated to the right).
Definition 3.5 (Inessential trace) A trace is inessential if it belongs to the union of all systems of inessentials of an ats (which is a non-empty soi which is maximal wrt inclusion).
In fact, in most of the following examples, the pushout of an inessential trace along another one is just its residual. The following example shows that the set of future-reflecting transitions need not be closed under residuals and thus the maximal soi does not contain all future-reflecting traces.
Example 3.6 Consider the ats on the right, in which all faces	zj
but the back face are tiles. The transition o → oj is future- xj	yj
reflecting. Its residual after o → x, namely x → xj, is not future-	oj
reflecting (and not even persistent). In fact, the largest soi	z
is the closure of {oj → xj, oj → yj,y → z, y → yj} by residuals,	x	y
composition, and identities.
Note that the ats of this example does not satisfy the Forward Cube Property. Nevertheless, the category of future components is well-defined.
Definition 3.7 (Category of future components) The category of future com- ponents of an ats is its trace category quotiented by inessential traces.
This construction amounts to forgetting inessential transitions by considering them as identities. Another point of view, formalized by the following proposition, is that this construction removes states which enable inessential transitions: informally, passing through them does not bring any new information about possible future traces (as no important choice can be made by the program or the scheduler). This agrees with the informal explanations of the introductory example in Figure 1; the state space reduction removes states x01, x02 and x12.
Proposition 3.8 Let (G, ⬦) be an ats, let Σ be the maximal soi. If Σ is ﬁnite, the category of future components is the full subcategory of the category of traces that is induced by all states that do not enable any transition in Σ.
Finally, we give sufficient conditions which imply that the category of future compo- nents yields the expected state space. The final condition is the absence of d´eja` vus (cf. Example 3.3).
Definition 3.9 (D´ej`a vu) A d´ej`a vu is a transition m : x → y such that there exists a path u : yj → x and a transition mj : xj → yj in u that is the same event as

m. The ats is d´ej`a vu free if none of its transitions are d´ej`a vus.
In other words, an ats is d´eja` vu free if none of its paths contains two transitions that are instances of the same event. For example, in the second ats of Example 3.3, the transition x → z is a d´eja` vu since the path o → xj → x → z contains two occurrences of the same event: (x → z) 2(o → y) 2(x → xj). Similarly, any cyclic ats has d´ej`a vus though d´ej`a vus need not necessarily be cycles. With this final proviso, we obtain a formal correspondence between inessential and persistent transitions (i.e. transitions m : x → y such that {m} is a persistent set at x).

Theorem 3.10 (Inessential vs. persistent transitions) In any d´eja` vu free ats that has the forward cube property, a transition is persistent iff it belongs to some soi (and in particular the maximal one). If the trace category of the ats is ﬁnite, the category of future components is the full subcategory containing all objects that do not enable persistent transitions.

Proof. Assume that Σf is a soi and m ∈ Σf a transition. We want to show that {m} is a persistent set. For any path coinitial with m, we have a pushout of m along u because Σf is closed under pushouts. Thus m ↑ u and m is persistent by Remark 2.6.
Conversely, let Σj be the set of traces that consist only of persistent transitions. It suffices to show that Σj is a soi. To show that Σj is stable under pushouts, let m1 ··· mk ∈ Σj and let u be a path coinitial with m1. We successively take residuals of mi along u using the fcp, Remark 2.6, and Proposition 2.12, and verify that the composite of the residuals is a pushout. Next, we show that persistent transitions are future-reflecting. Let m : x → y be a persistent transition and z a state reachable from y. Since the ats is supposed to have the fcp, the transition m is an epimorphic trace by Lemma 2.16, i.e. for every paths u and v such that [m · u] = [m · v] we have [u]= [v]. Namely, in this case we have u = (m · u)/m ∼ (m · v)/m = v, the middle homotopy being justified by the fact that m · u ∼ m · v and residuation is compatible with homotopy [16]. Precomposition with m with traces from y to z is thus injective and it remains to show that it is surjective. Given a path u : x → z, we have to show that u factors through m. The transition m is compatible with u by Remark 2.6, and thus we can pushout [m] along [u], which is just the residual of m after u; it must be the identity as we would obtain a d´eja` vu otherwise and thus, in fact, [u] factors as [m] · [uj] where [uj] is the pushout of [u] along [m].	2
Thus, in a large class of common systems, including those generated by event structures or Petri nets with acyclic causality, persistent singletons are in fact the same as inessential morphisms. Thus, despite the huge gap between the origins of the geometric approach and the por technique, in a large class of systems, we do not have only “obvious” similarities, but in fact, a formal argument that inessential transitions are exploited in the same way.

Conclusion
We have developed a conservative extension of persistent sets to asynchronous transition systems (Definition 2.5) that coincides with the original concept on ltsi (Proposition 2.13). This extension forms the base of our comparison of the partial order reduction technique and the geometric approach to state space reduction, since ats are the algebraic counterpart of geometrical models. In particular, we have shown that our definition retains the main application of persistent sets which consists in pruning the search for deadlocks (Corollary 2.15).
These preliminaries are crucial for our main contribution, which demonstrates the practical relevance of the theoretical construction of the category of future components and further results in [10], where state space reduction is performed for general directed topological spaces. Glossing over details, Theorem 3.10 says that inessential transitions are the same as persistent singletons. As a direct consequence, the construction of the category of future components roughly amounts to the application of the por technique when we use only persistent singletons. Thus, we have found a common core of the geometric approach and the por technique, while both approaches have additional heuristics and methods to improve performance. There are favorable examples for the geometric approach [4], which motivates future research.
In theory, a fully general correspondence between persistent singletons and inessential transitions is impossible (as witnessed by Example 3.3), which is not surprising given the difference of origins. To gauge the advantages of each of the approaches in practice, a systematic practical comparison of por and the geometric approach is called for. We further plan extensions of the geometric approach using methods and tools from Petri nets [3,15]. This is motivated by the fact that Petri nets are closer to both – the geometric approach and the por techniques – as witnessed by the study of so-called stubborn sets in Petri nets [18], which are a particular case of persistent sets [7]. The addition of Petri net inspired techniques is based on the observation that the category of future components bears similarities with the facet abstraction for occurrence nets [1] and that recent advances of the geometric approach in [4] use a notion of “weak causality”, which is tightly related to classical models such as event structures and Petri net processes [19]. In the end, we expect to obtain representative experimental results, which will complement the theoretical results of the present paper.
References
S. Balaguer, T. Chatain, and S. Haar. Building tight occurrence nets from reveals relations. In ACSD, pages 44–53. IEEE, 2011.
R. Bonichon and al. Rigorous evidence of freedom from concurrency faults in industrial control software.
Computer Safety, Reliability, and Security, pages 85–98, 2011.
	J.-M. Couvreur, D. Poitrenaud, and P. Weil. Branching processes of general petri nets. In Applications and Theory of Petri Nets, volume 6709 of LNCS, pages 129–148. Springer, 2011.
L. Fajstrup, E. Goubault, E. Haucourt, S. Mimram, and M. Raußen. Trace spaces: An efficient new technique for state-space reduction. In ESOP, pages 274–294, 2012.

L. Fajstrup, E. Goubault, E. Haucourt, and M. Raußen. Components of the fundamental category.
Applied Categorical Structures, 12(1):81–108, 2004.
C. Flanagan and P. Godefroid. Dynamic partial-order reduction for model checking software. In
POPL’05, pages 110–121, 2005.

	P. Godefroid. Partial-Order Methods for the Verification of Concurrent Systems: An Approach to the State-Explosion Problem, volume 1032 of Lecture Notes in Computer Science. Springer, 1996.

	E. Goubault. Geometry and concurrency: a user’s guide. Mathematical Structures in Computer Science, 10(4):411–425, 2000.

E. Goubault and E. Haucourt. A practical application of geometric semantics to static analysis of concurrent programs. In Proc. of CONCUR’05, volume 3653 of LNCS, pages 503–517. Springer, 2005.

	E. Goubault and E. Haucourt. Components of the Fundamental Category II. Applied Categorical Structures, 15(4):387–414, 2007.

	E. Goubault, E. Haucourt, and S. Krishnan. Future path-components in directed topology. In MFPS, volume 265 of ENTCS, pages 325–335, sep 2010.

E. Goubault and S. Mimram. Formal relationships between geometrical and classical models for concurrency. ENTCS, 2012.

	M. Grandis. Directed Algebraic Topology: Models of Non-Reversible Worlds, volume 13 of New Mathematical Monographs. Cambridge University Press, 2009.
G. Holzmann. The Model Checker SPIN. IEEE Trans. Soft. Eng., 23(5):279–295, 1997.

V. Khomenko and A. Mokhov. An Algorithm for Direct Construction of Complete Merged Processes. In Applications and Theory of Petri Nets, volume 6709 of LNCS, pages 89–108. Springer Berlin, 2011.

S. Mimram. S´emantique des jeux asynchrones et r´e´ecriture 2-dimensionnelle. PhD thesis, Universit´e Paris Diderot, UFR d’Informatique, 2008.

R. Morin. Concurrent Automata vs. Asynchronous Systems. In MFCS, volume 3618 of LNCS, pages 686–698. Springer, 2005.

	A. Valmari. Stubborn sets for reduced state space generation. In Applications and Theory of Petri Nets, pages 491–515, 1989.

G. Winskel. Handbook of Logic in Computer Science, volume 4: Semantic Modelling, chapter 1: Models for concurrency. Oxford University Press, 1995.

A  Characterizing the category of future components

Proof. Let D ⊆ C be the maximal full subcategory such that for all σ : A → B ∈ Σ, if A ∈ D then σ = idA.
Now we define a candidate for a “quotient” functor Q : C → D. For each object A ∈ C, consider all arrows in Σ with domain A. Since Σ is finite, we can take the colimit of the corresponding diagram (using successive pushouts) to obtain the colimit object Q(A); moreover, we have a unique arrow σA : A → Q(A) ∈ Σ for each A ∈ C. For each arrow f : A → B, we know how to construct the arrow σA : A → Q(A);

f′	j  σ′
σA	f

to define Q(f ), let Q(A) −→ B →− B be the pushout of Q(A) →−− A −→ B. By
pushout-stability σj ∈ Σ. Moreover, we have the arrow σB′ : Bj → Q(Bj)= Q(B) (as Σ is “confluent”). Define Q(f ) := σBj ◦ fj. It easily be verified that Q is actually

a functor: the relevant diagram for composition is

f	g
A  B  C
σ	′	′′
A	A

Q(A)	Bj
f′
g¯	C¯

σ ′	σ′
B

Q(B)
Cj
g′
σC′

Q(C)


where we have Q(f )= σB′ ◦fj and Q(g)= σC′ ◦gj, and Q(g ◦f )= (σC′ ◦σj ′ )◦(g¯◦f j), by definition of Q; the latter implies Q(g) ◦ Q(g)= Q(g ◦ f ). Moreover the functor Q is epi and in fact a section of the inclusion D ⊆ C. This implies that D satisfies the universal property of the quotient category C/Σ and thus D ∼= C/Σ.	2
Residuals, Pushouts and Epimorphic Transitions
This section mainly concerns ats that are induced by ltsi. Thus, we will assume that we have normal tiles, i.e. in all atss that we consider, switchings are unique and pairs of co-final and co-initial transitions in each tile have different transitions as components.
Definition B.1 (Switching Distance) Let s, t : x → y be parallel paths that are homotopic s ∼ t. The switching distance of s and t, written s, t , is the minimal

number i such that s (∼1 )i t where r ∼1
(v, vj) ∈ ⬦.
Clearly, we have s, t = t, s .
rj if r = u · v · w and rj = u · vj · w for some



y
m
(n/m)
⇒	x
t

r
xjj  xj


z	s
Fig. B.1. Illustration of Lemma B.2

Lemma B.2 (Residuals of Compatible Transitions) Let (G, ⬦) be an ats with the fcp. Let m : x → y and n : x → z be two different co-initial transitions; further let t : y → xj and s : z → xj be co-ﬁnal paths such that m · t ∼ n · s. In this situation, m  n and there exists a path r : xjj → xj such that t ∼ (n/m) · r, (m/n) · r ∼ s, and
m · t, n · s = t, (n/m) · r +1+ (m/n) · r, s .	(B.1)

Proof. The proof is by induction on the distance m ·t, n ·s , which is not zero as we
have m =/	n by assumption and the convention that in each ats, the pairs of co-final
and co-initial transitions in each tile have different transitions as components.
m · t, n · s   = 1: In this case, again as m =/	n, necessarily m	n. Thus there exists
a path r : xjj → xj such that t = (n/m) · r = (m/n) · r = s, which implies (B.1).
 m · t, n · s  > 1: Now there are paths u0, u1,..., ui with i = m · t, n · s  such that

u0 = m · t and ui = n · s, and uj ∼1
the following two cases.
uj+1 for all j ∈ {0,i − 1}. Now we distinguish

There is some k ≥ 0 such that for all j > k, there exists uj such that uj = n ·uj
j	j
and for all j ≤ k, there exists uj such that uj = m · uj . Thus, there exists a

path r : xjj → xj such that
uk = m · (n/m) · r ∼1

n · (m/n) · r = uk+1.

This already implies (B.1).
For some i > j > 0, the first transition of uj is neither m nor n. Thus let j

be the maximal index such that uj+1 factors as n · uj
. Thus, there exists

o such that o  n, and a path r¯: x¯ → xj such that uj = o · (n/o) · r¯ and
uj+1 = n · (o/n) · r¯.
At this point, we have m · t ∼ o · (n/o) · r¯ and, in fact, we can use the induction hypothesis to derive that m  o. Thus, there exists rj such that t ∼ (o/m) · rj and (m/o) · rj ∼ (n/o) · r¯. Using the convention of unique switchings in every ats, we see that (m/o) /= (n/o). Thus, using the induction hypothesis once more, we obtain r : x˜ → xj such that rj ∼ ((n/o)/(o/m)) · r and ((o/m)/(n/o)) · r ∼ r¯. Finally, we apply the fcp property to the relevant cube starting with transitions n, m and o. From this, we can conclude that r is in fact a suitable path as the “two ways to go around a cube” take the same number of switchings, namely three.
2
This lemma is already enough to show that any ats that is induced by an ltsi has compatible residuals (using a straightforward induction on the length of paths). Moreover, we have the following two corollaries.
Corollary B.3 Every transition is epimorphic.
Proof. Suppose that m · t ∼ m · s. We have to show that t ∼ s. Now there are paths u0, u1,..., ui with i ≥ 0 such that u0 = m · t and ui = m · s. If all uj have m as initial transition, we obtain the desired from the assumption of normal tiles (cf. Remark 1.8), and in particular there is no tile (m · p, m · q). Thus, suppose there is at least one uj such that uj = n · uj . Now we apply Lemma B.2 twice to obtain t ∼ (n/m) · r, (m/n) · r ∼ (m/n) · rj and (n/m) · rj ∼ s. Thus t ∼ s.	2
Corollary B.4 Residuals are pushouts.
