Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 312 (2015) 19–50
www.elsevier.com/locate/entcs

A Dependent Type Theory with Abstractable Names
Andrew M. Pittsa,1,2, Justus Matthiesen a,3,4 and Jasper Derikxb,5
a Computer Laboratory, University of Cambridge, Cambridge CB3 0FD, UK
b Radboud University, 6500 GL Nijmegen, Netherlands

Abstract
This paper describes a version of Martin-L¨of’s dependent type theory extended with names and constructs for freshness and name-abstraction derived from the theory of nominal sets. We aim for a type theory for computing and proving (via a Curry-Howard correspondence) with syntactic structures which captures familiar, but informal, ‘nameful’ practices when dealing with binders.
Keywords: binding, dependent types, names, nominal sets


Introduction
We aim to develop a constructive version of nominal logic [15] as a dependent type theory. From a programming point of view we would like to combine Agda/Coq style theorem-proving (particularly inductively defined indexed families of types and dependent pattern-matching) with FreshML [21] style meta-programming for syntax with binding operations. Achieving these aims requires a constructive treatment of the nominal sets notion of freshness [16, Chapter 3]. Here we give one such treatment as an extension of Martin-L¨of type theory.
The functional programming language FreshML is impure: it ensures freshness of names via generativity and (hence) avoids checking that a locally scoped name

1 Partially supported by the UK EPSRC program grant EP/K008528/1, Rigorous Engineering for Main- stream Systems (REMS).
2 Email: andrew.pitts@cl.cam.ac.uk
3 Supported by the UK EPSRC leadership fellowship (Peter Sewell) grant EP/H005633/1, Semantic Foun- dations for Real-World Systems.
4 Email: justus.matthiesen@cl.cam.ac.uk
5 Email: jasperderikx@gmail.com

http://dx.doi.org/10.1016/j.entcs.2015.04.003
1571-0661/© 2015 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

does not occur in the support of the meaning of the expression in which it is used. The original version of the language, ‘FreshML 2000’ [17], attempted to carry out such checks by inferring freshness information as part of the type system, but was found to be too restrictive in the context of a Turing-powerful language – the main difficulty being how to decide whether a name n is fresh for a (higher-order) function f , written n # f . Within nominal sets [16], the definition of the freshness relation involves quantification over finite sets of names: n # f means that there exists a finite set of names supporting f that does not contain the name n. In practice, one often relies upon the fact that this relation is invariant under permuting names and uses the following sound method that reflects on a concrete, meta-theoretic version of freshness, viz. non-occurrence:
To prove n # f , pick a name nj that does not occur in the current context (that is, one that is meta-theoretically fresh) and prove (n nj) · f = f , which in the presence of function extensionality, is equivalent to showing (∀x) (n nj) · (f x)= f ((n nj)·x). (As usual, (n nj)·x denotes the result of transposing names n and nj in an element x of a nominal set.) Since nj # f holds by choice of nj, applying the permutation (n nj) that swaps n and nj we get n = (n nj) · nj # (n nj) · f = f , as required.
This proof principle was adopted by nominal algebra [9]/nominal equational logic [5] and emphasised particularly in Clouston’s thesis [4] and the recent work of Crole and Nebel [7], which both make freshness assertions
Γ ▶ n # t : T
equivalent to equality judgements of the form
Γ[nj : N ] ▶ (n nj) . t = t : T	(1)
where (n nj). is the (object-level) name-swapping operation, the context Γ contains hypotheses about freshness of names for free variables and Γ[n : N ] 6 adds to Γ an extra freshness hypotheses for a (meta-theoretically) new name n of some sort N . Equality jugements, such as (1), will be axiomatized by the type theory introduced in Sect. 2.
We call this delegation of freshness to definitional equality deﬁnitional fresh- ness. It means that equality judgements get intertwined with typing judgements in an extra way from what already happens in dependently typed systems. The advantage of this approach is that we can give ‘pure’ versions of locally scoped names and concretion of name-abstractions with a semantics just using nominal sets, rather than, for example, nominal restriction sets [16, section 9.1]. The next section describes such a dependent type theory with abstractable names. Since it is an extension of Martin-L¨of’s Type Theory with many of the features of FreshML, we call it FreshMLTT. Section 3 describes the intended model of FreshMLTT; we

6 Instead of using the ‘flattened’ contexts {n1 # x1 : T1, n2 # x2 : T2,.. .} from [24,9,5,4,7], here we will use ‘bunched’ ones, as in [19,18,3], because they fit better with the ‘telescopic’ nature of contexts in dependent type theory.

organise nominal sets into an instance of Dybjer’s notion of category with families (CwF) [8] and develop a dependent version of the nominal sets notion of name ab- straction. The interpretation of FreshMLTT in this CwF is given in Sect. 4, together with its soundness (Theorem 4.2). Section 5 surveys previous work on combining nominal sets with dependent types and Sect. 6 outlines what needs to be done to develop FreshMLTT further. In particular, the question as to whether FreshMLTT has decidable type-checking is open.

FreshMLTT
In this paper we consider an extension of Martin-L¨of Type Theory [14] with names that can be swapped, compared for equality, locally scoped and abstracted. We call it FreshMLTT. The syntax of its expressions is given in Fig. 1. There are two sorts of bindable identifier, variables (x) and names (n), and expressions are identified up to α-equivalence: the binding forms are ν[n : N ] ,	[n : N ] , Π(x : T ) , α[n : N ] and λ(x : T ) . We write fv(e) for the finite set of free variables of an expression e and fn(e) for its finite set of free names. Capture-avoiding substitution of e for all free occurrences of a variable x in ej is denoted ej(e/x); names are not subject to substitution (see Sect. 2.1). We write dom(Γ) for the finite set of variables and names that are declared in a context Γ. We adopt Agda-style notation for multiple context extensions and write Γ[n nj : N ] rather than Γ[n : N ][nj : N ], for example.
The forms of judgement of FreshMLTT are given in Fig. 2. The rules for deriving valid instances of these judgements are listed in Appendix A. We discuss them in the following sections (2.1–2.3).

Names
FreshMLTT is intended to be used as a meta-language for describing, and comput- ing with, the syntax and semantics of various languages. These ‘object languages’ typically involve various sorts of name (for example, names of variables, commu- nication channels, etc.). Therefore FreshMLTT has a countably infinite collection N, Nj,... ∈ Nsort of distinguished types 7 , called name sorts


Γ ▶ ok Γ ▶ N

(n-form)

the terms of which stand for object-language names. The usual rules of Martin-L¨of Type Theory for extending a context


Γ ▶ T	x ∈/ dom(Γ) Γ(x : T ) ▶ ok

(ctx-ext-v)
Γ ▶ ok	(x : T ) ∈ Γ Γ ▶ x : T

(v-intro)



7 It would be natural to allow name sorts to be parameterised by the elements of other types, but for simplicity we do not do that here.


names n ∈ Name	(countably infinite set)
name sorts N ∈ Nsort	(countably infinite set)
variables x ∈ Var	(countably infinite set) expressions e ∈ Exp ::= Γ | T | t
contexts Γ ∈ Ctx ::= ⬦	empty
|  Γ(x : T )	extend with variable
| Γ[n : N ]	extend with fresh name types T ∈ Type ::= N	 sort of names
|  (n n) . T	name swapping
|  ν[n : N ] T	locally scoped name
|	[n : N ]T	name-abstraction type
|  Π(x : T )T	dependent function type
...	(other constructs of MLTT) terms t ∈ Term ::= x	variable
|  n	name
|  (n n) . t	name swapping
|  if t = n then t else t branch on name equality
|  ν[n : N ] t	locally scoped name
|  α[n : N ]t	name-abstraction
|  t @ n	concretion
|  λ(x : T )t	λ-abstraction
|  tt	application
...	(other constructs of MLTT)

Fig. 1. Syntax of FreshMLTT


allow one to hypothesise a variable (that is, an unknown element) of some type
T ; and so when T = N , we hypothesise an unknown object-level name of sort
N . However in FreshMLTT, in addition to variables x, y, . . . ∈ Var , there is a disjoint kind of bindable identifier, meta-level names n, m, ... ∈ Name, together

Judgements take the form Γ ▶ J , where
J ::= ok	well-formed context

Fig. 2. Judgements of FreshMLTT
with associated context extension and introduction rules:


Γ ▶ ok	n ∈/ dom(Γ) Γ[n : N ] ▶ ok

(ctx-ext-n)
Γ ▶ ok	[n : N ] ∈ Γ Γ ▶ n : N

(n-intro)

The difference between a variable of type N and a name of type N is that the latter has a fixed, context-insensitive identity: if n and nj are different names, then the Boolean expression n = nj is convertible to false; whereas if x and xj are different variables, then the Boolean expression x = xj is neutral. For simplicity we do not introduce a type of Booleans explicitly and instead use test-and-branch expressions at each type


Γ ▶ t : N	Γ ▶ n : N	Γ ▶ t1 : T	Γ ▶ t2 : T
Γ ▶ if t = n then t1 else t2 : T

(ifeq)



together with the definitional equalities
if n = n then t else tj = t  ⎫
if n = nj then t else tj = tj ⎭



(if-comp)	(where n /= nj).

Because of those equalities, the validity of the judgements of FreshMLTT is not preserved under the operation of substituting a term for a name, whereas substitu- tion of terms for variables does preserve validity, as usual. Instead, names obey a weaker substitution discipline familiar from the work on nominal logic: validity of judgements is preserved under permutation of names and in particular, under the operation of swapping two names.
Deﬁnitional freshness
When computing with object languages involving names, the relation of not oc- curring free in a language expression is of crucial importance. In particular one frequently has to introduce names that are not free in the current context. This

is supported in FreshMLTT by the context extension rule (ctx-ext-n) mentioned above: in the context Γ[n : N ] it is intended that any variables declared in Γ are restricted to range over object-level entities in which the name n does not occur free. The nominal sets relation of freshness (a # x) [16, Chapter 3] provides a syntax- independent meaning for ‘does not occur free’, the constructive properties of which are formalised by FreshMLTT. To do so, there are expressions for the operation of swapping two names in types or terms

Γ ▶ n : N	Γ ▶ nj : N
Γ ▶ T


Γ ▶ (n nj) . T



(swap-typ)
Γ ▶ n : N	Γ ▶ nj : N
Γ ▶ t : T
Γ ▶ (n nj) . t : (n nj) . T



(swap-term)

and definitional equalities


Γ ▶ T	ΓΔ ▶ ok [n : N ], [nj : N ] ∈ Δ


ΓΔ ▶ (n nj) . T = T



(fresh-hyp-typ)
Γ ▶ t : T	ΓΔ ▶ ok [n : N ], [nj : N ] ∈ Δ


ΓΔ ▶ (n nj) . t = t : T



(fresh-hyp-term)

that formalize a basic property of freshness: a # x ∧ aj # x ⇒ (a aj) · x = x [16, Proposition 3.1]. Another key property of freshness is that given any element x of a nominal set, there is some atom a with a # x. A consequence of this are structural rules for eliminating unused fresh-name assumptions, taken from the work on nominal equational logic [5] and algebra [9]:


ΓΔ ▶ T	ΓΔ ▶ T j Γ[n : N ]Δ ▶ T = T j ΓΔ ▶ T = T j



(n-elim-typ)
ΓΔ ▶ t : T	ΓΔ ▶ tj : T
Γ[n : N ]Δ ▶ t = tj : T
ΓΔ ▶ t = tj : T



(n-elim-term)

As explained in the Introduction, FreshMLTT can make judgements about whether a name is fresh for an expression via definitional equalities involving swap- ping with a name that is known to be fresh from the context:


Γ ▶ n : N	Γ ▶ T
Γ[nj : N ] ▶ (n nj) . T = T
Γ ▶ (n : N ) # T



(fresh-typ)
Γ ▶ (n : N ) # T
Γ[nj : N ] ▶ (n nj) . t = t : T
Γ ▶ (n : N ) # t : T



(fresh-term)

Such deﬁnitional freshness judgements are needed to express the properties of name abstraction, to which we turn in the next section.
Remark 2.1 Note that definitional freshness can hold even if a name n is not meta-theoretically fresh for an expression e, that is, even if n occurs free in e. For example n occurs free in the term if n = nj then n else nj, but nevertheless
⬦[n nj : N ] ▶ (n : N ) # (if n = nj then n else nj): N
is a valid judgement in FreshMLTT, because of the definitional equality (if-comp) mentioned above.

Abstracting and locally scoping names
The usual formation and introduction rules for dependent functions


Γ(x : T ) ▶ T j
Γ ▶ Π(x : T )T j (Π-form)
Γ(x : T ) ▶ tj : T j
Γ ▶ λ(x : T )tj : Π(x : T )T j (Π-intro)

discharge a variable from the context. In FreshMLTT there are formation and introduction rules for name abstractions, which involve discharging a fresh name from the context:


Γ[n : N ] ▶ T
(
Γ ▶	[n : N ]T

-form)
Γ[n : N ] ▶ t : T
(
Γ ▶ α[n : N ]t :	[n : N ]T

-intro)


Name abstraction types can be used to indicate that a syntactical construct in some object language is a binder. For example, assuming FreshMLTT is augmented with data types for finite lists [14, Chapter 10], one might introduce a dependent type Term(l) for λ-terms whose free variables are in the list l : List(N ) (using the name sort N to represent variables in λ-terms). Then the operation for forming λ- abstractions could be given type Π(l : List(N )) ( [n : N ]Term(cons nl)) ⭢ Term(l).
The notation for name abstraction types,	[n : N ]T , is chosen to suggest
its Curry-Howard relationship with the freshness quantifier of nominal logic [16, Sect. 3.2]; see Remark 3.7. Simultaneously it formalizes a dependent version of the nominal sets notion of name abstraction [16, Chapter 4]; see Sect. 3.6. In partic- ular the elimination rule for name abstractions uses a special form of application, called concretion and written t @ n. We know from the theory of nominal sets that to be meaningful such a concretion requires the name n to be fresh for the ab- straction to be concreted, t : [nj : N ]T ; and since types can depend upon names, we should also require n to be fresh for the type T . So the hypotheses of the - elimination rule will be definitional freshness judgements Γ[nj : N ] ▶ (n : N ) # T and Γ ▶ (n : N ) # t : [nj : N ]T . What should be the type of the concretion t @ n in its conclusion? For dependent functions, Π-elimination involves making a substitution to get the result type of a function application:
Γ ▶ t : Π(xj : T j)T	Γ ▶ tj : T j
(Π-elim)
Γ ▶ t t : T (t /x )
We cannot do the same for concretion and take its result type to be T (n/nj), because as we mentioned at the end of Sect. 2.1, validity of FreshMLTT judgements is not preserved in general by name-substitutions, only by name-permutations. 8  This

8 Cheney’s DNTT [3] does use name-substitution (see Fig. 9 in that paper), but constrains concreting names n to be meta-theoretically fresh for T , so that T (n/n′) is equal to the result of permuting n and n′ in T . Definitional freshness is a weaker and hence more expressive constraint on concreting names.

suggest that we use the result type (n nj) . T and the following elimination rule:

Γ[nj : N ] ▶ (n : N ) # T	Γ ▶ (n : N ) # t :	[nj : N ]T
Γ[nj : N ] ▶ t @ n : (n nj) . T	(2)

Note that the context in the conclusion has to be Γ[nj : N ] rather than just Γ, because the bound name nj in [nj : N ]T becomes a free name in (n nj) . T . However, from the hypotheses of (2) (together with properties of name-swapping up to definitional equality) one can deduce Γ[nj : N ] ▶ (nj : N ) # (n nj) . T and (hence) Γ[nj njj : N ] ▶ (n  nj) . T = (n  njj) . T . In other words the result type (n nj) . T of the concretion in (2) is independent up to definitional equality of the choice of bound name nj in [nj : N ]T . It is important, from the point of view of expressivity of the system, to capture this fact linguistically. We can do so by using a form of local scoping for names in expressions, which we write as ν[n : N ] e. Such expressions can be introduced by the rules


Γ[n : N ] ▶ (n : N ) # T
Γ ▶ ν[n : N ] T

(local-typ)
Γ[n : N ] ▶ (n : N ) # t : T
Γ ▶ ν[n : N ] t : ν[n : N ] T

(local-term)


and manipulated with the computation rules


Γ[n : N ] ▶ (n : N ) # T
Γ[n : N ] ▶ ν[n : N ] T = T

(local-typ-comp)



Γ[n : N ] ▶ (n : N ) # t : T
Γ[n : N ] ▶ ν[n : N ] t = t : T

(local-term-comp)


We will see later (Proposition 3.5 and Theorem 4.2) that these rules have a sound interpretation in terms of nominal sets. They formalize the form of locally fresh name commonly used in syntax-manipulating constructions, where the meaning of a construction depending upon some fresh names is (provably) independent of which particular fresh names are chosen; see [16, Sect. 3.3]. When the constructions involve first-class functions, it is important to have a linguistic form for this kind of name scoping, since an expression like λ(x : T )ν[n : N ] t is not in general definitionally equal to ν[n : N ] λ(x : T )t and so the local scoping cannot float to the top-level and become implicit in the context.
Using locally scoped names, we strengthen (2) to get FreshMLTT’s rule for
-elimination:


Γ[nj : N ] ▶ (n : N ) # T	Γ ▶ (n : N ) # t :	[nj : N ]T

Γ ▶ t @ n : ν[nj : N ] (n nj) . T	(

-elim)



Γ ▶ n : N	Γ ▶ T
Γ ▶ ⟨⟨n : N ⟩⟩T

(abs-form)
Γ ▶ n : N	Γ ▶ t : T
Γ ▶ ⟨n : N ⟩t : ⟨⟨n : N ⟩⟩T

(abs-intro)



Γ ▶ (n : N ) # t : ⟨⟨nj : N ⟩⟩T
Γ ▶ t @ n : (n nj) . T

(abs-elim)



Γ ▶ n : N	Γ ▶ (nj : N ) # t : T
Γ ▶ (⟨n : N ⟩t) @ nj = (n nj) . t : (n nj) . T

(abs-comp)



Γ ▶ (n : N ) # t : ⟨⟨n : N ⟩⟩T
Γ ▶ ⟨n : N ⟩(t @ n) = t : ⟨⟨n : N ⟩⟩T

(abs-uniq)


Fig. 3. Admissible rules for non-binding name abstraction


The associated computation and uniqueness (η) rules are:


Γ[nj : N ] ▶ (n : N ) # t : T	n /= nj
Γ ▶ (α[nj : N ]t) @ n = ν[nj : N ] (n nj) . t : ν[nj : N ] (n nj) . T (

-comp)



Γ ▶ t :	[n : N ]T	n ∈/ fn(t)
(
Γ ▶ t = α[n : N ](t @ n):	[n : N ]T

-uniq)


We will see in Sect. 4 that they are sound for the nominal set semantics developed in Sect. 3.


Non-binding name abstraction
FreshML [21] uses a non-binding form of name abstraction which is definable in FreshMLTT as follows:

⟨⟨n : N ⟩⟩T	[nj : N ](n nj) . T	(3)
⟨n : N ⟩t   α[nj : N ](n nj) . t	(4)


(where nj ∈/
fn(n, T, t)). Note that n occurs free in ⟨⟨n : N ⟩⟩T and ⟨n : N ⟩T ,

whereas it is bound in	[n : N ]T and α[n : N ]t. Admissible rules for this form of
name abstraction are shown in Fig. 3.
If Γ[n nj : N ] ▶ t : T , then it is a consequence of (fresh-hyp-typ) and the conversion properties of the swapping operation (n nj) . that Γ[n nj : N ] ▶ (n nj) . T = T j and Γ[n nj : N ] ▶ (n nj) . t = tj : T j, where tj and T j are the expressions obtained from t

and T by transposing occurrences of n and nj. It follows that


Γ[n : N ] ▶ T


Γ ▶	[n : N ]T = ν[n : N ] ⟨⟨n : N ⟩⟩T
Γ[n : N ] ▶ t : T
Γ ▶ α[n : N ]t = ν[n : N ] ⟨n : N ⟩t :	[n : N ]T
(5)

(6)


are admissible rules. Conversely, one could take the non-binding form of name abstraction as primitive, with rules as in Fig. 3, and then define the binding form from it using locally scoped names as in (5) and (6).
Non-binding name abstractions in the FreshMLTT meta-language are used when one has to refer to an object-level bound name in more than one textual location. Here is an example.

Example 2.2 As usual we write T ⭢ T j for the non-dependent function type, that is, for Π(x : T )T j when x ∈/ fv(T j). For non-dependent name abstractions we write
⟨⟨N ⟩⟩T	[n : N ]T	where n ∈/ fn(T )	(7) (which is definitionally equal to the non-binding abstraction ⟨⟨n : N ⟩⟩T when n ∈/ 
fn(T )). In the nominal sets semantics given below, the type ⟨⟨N ⟩⟩T is modelled by a nominal set of name abstractions [16, Chapter 4]. These are known to commute with exponentiation up to isomorphism in the category of nominal sets (see [16, Proposition 4.14]); and indeed we can express an isomorphism ⟨⟨N ⟩⟩(T ⭢ T j) ∼=
⟨⟨N ⟩⟩T ⭢ ⟨⟨N ⟩⟩T j within FreshMLTT. In fact we can give a dependently typed
generalisation of this isomorphism

[n : N ] Π(x : T ) T j ∼= Π(y :	[n : N ]T ) [n : N ] T j(y @ n/x)	(8) as follows. Define
T1	[n : N ] Π(x : T )T j
T2   Π(y :	[n : N ]T ) [n : N ]T j(y @ n/x)
i   λ(z : T1) λ(y :	[n : N ]T ) α[n : N ] (z @ n)(y @ n)
j   λ(f : T2) α[n : N ] λ(x : T ) f (⟨n : N ⟩x) @ n

Using the derived rules in Fig. 3 one can show that if

Γ[n : N ] ▶ T
Γ[n : N ](x : T ) ▶ T j

are provable in FreshMLTT, then so are

Γ ▶ i : T1 ⭢ T2
Γ ▶ j : T2 ⭢ T1
Γ(z : T1) ▶ j(iz) = z : T1
Γ(f : T2)) ▶ i(j f ) = f : T2
Note that in the subexpression f (⟨n : N ⟩x) @ n of j we use the non-binding name abstraction ⟨n : N ⟩x, rather than α[n : N ]x (which is equal up to α-equivalence to α[nj : N ]x for any nj), because after applying the function f we have to concrete at the same name n in order for the typing to work out.

Families of Nominal Sets
We will give a semantics to FreshMLTT using nominal sets with sorted atoms. Thus we assume there is a fixed set A of atoms, partitioned into countably infinitely many subsets A = N∈Nsort AN , indexed by the sorts of name N ∈ Nsort in FreshMLTT. Each subset AN is countably infinite. We write a, b,... for typical elements of A.
Let G be the group of permutations π of A that respect sorts (π a ∈ AN , if a ∈ AN ) and are finite (in the sense that π a = a for all but finitely many a ∈ A). A nominal set is a set X equipped with a G-action with respect to which every element has a finite support. This means that for each x ∈ X there is a finite subset A ⊆fin A satisfying (∀π ∈ GA) π · x = x, where GA  {π ∈ G | (∀a ∈ A) π a = a}. Nominal sets are the objects of a category that we will denote by Nom and whose morphisms are equivariant functions (f (π · x) = π · (f x)), with composition and identities as in the category of sets. We refer the reader to [16] for an introduction to nominal sets and in particular to Sect. 4.7 of that book for the many-sorted version we use here.

Nom as a category with families
To model FreshMLTT we will endow Nom with the structure of a category with families (CwF) [8]. In general a CwF is specified by a category C with a terminal object 1, together with the following structure:
For each object X ∈ C, a collection C(X), whose elements are called families
over X.
For each object X ∈ C and family E ∈ C(X), a collection C(X ▶ E) of elements
of the family E over X.
Operations for re-indexing families and elements along morphisms in C


E ∈ C(X)	f ∈ C(Y, X)


E[f ] ∈ C(Y )
e ∈ C(X ▶ E)	f ∈ C(Y, X)


e[f ] ∈ C(Y ▶ E[f ])

satisfying

For each family E ∈ C(X), a comprehension object X.E ∈ C equipped with a projection morphism p ∈ C(X.E, X), a generic element v ∈ C(X.E ▶ E[p]) and a pairing operation
f ∈ C(Y, X)	E ∈ C(X)	e ∈ C(Y ▶ E[f ])
⟨f , e⟩ ∈ C(Y, X.E)
satisfying
p ◦ ⟨f , e⟩ = f	(13)
v[⟨f , e⟩]= e	(14)
⟨f , e⟩◦ g = ⟨f ◦ g , e[g]⟩	(15)
⟨p , v⟩ = idX.E	(16)
Definition 3.1 We make the category Nom of nominal sets and equivariant func- tions into a CwF as follows:
The collection Nom(X) of families of nominal sets E over a nominal set
X ∈ Nom consists of X-indexed families of sets (Ex | x ∈ X) equipped with a dependent G-action
act E ∈  x∈X  π∈G Ex ⭢ Eπ·x	(17)
satisfying a finite support property given below. We will write π · e for the appli- cation of act E to x ∈ X, π ∈ G, e ∈ Ex, leaving E and x as implicit arguments. To qualify as an action (17) has to satisfy for all x ∈ X, π, πj ∈ G and e ∈ Ex


πj · (π · e) = πjπ · e Eπ′·(π·x) = Eπ′π·x

and
ι · e = e Eι·x = Ex

(18)

(where ι denotes the identity permutation). In addition act is required to satisfy the following finite support property: for every x ∈ X and e ∈ Ex there isa finite set A ⊆fin A of atoms satisfying
(∀π ∈ GA) π · x = x ∧ π · e = e

(so that in particular A supports x in X and hence Eπ·x = Ex for any π ∈ GA). In this case we will say that A is a ﬁnite support for e dependent upon x.

The collection Nom(X ▶ E) of elements of a family E ∈ Nom(X) consists of those dependent functions e ∈ x∈X Ex that are dependently equivariant, in the sense that π · (e x)= e(π · x) ∈ Eπ·x, for all x ∈ X and π ∈ G.
The re-indexing of E ∈ Nom(X) along f ∈ Nom(Y, X) is the Y -indexed family of sets E[f ]  (Efy | y ∈ Y ) with dependently-typed G-action inherited from E: if e ∈ E[f ]y = Ef y, then we get π · e ∈ Eπ·(f y) = Ef (π·y) = E[f ]π·y (using the fact f , being a morphisms in Nom, is equivariant). Similarly, the re-indexing of e ∈ Nom(X ▶ E) along f ∈ Nom(Y, X) is e[f ]  λ(y ∈ Y ) ⭢ e(f y), which is in Nom(Y ▶ E[f ]), because e is dependently equivariant and f is equivariant.
For each E ∈ Nom(X), the comprehension object X.E ∈ Nom is the nominal set given by the disjoint union of sets   E equipped with the G-action mapping (x, e) ∈  x∈X Ex to π · (x, e) = (π · x, π · e), given by the G-action of X in the first component and the dependent G-action of E in the second component. Note that by definition of Nom(X), every (x, e) ∈  x∈X Ex is finitely supported with respect to this G-action and hence X.E is indeed a nominal set.
The projection morphism p ∈ Nom(X.E, X) is given by first projection: p(x, e) x. The generic element v ∈ Nom(X.E ▶ E[p]) is given by second projection: v(x, e)  e ∈ Ex = E[p](x,e). Given E ∈ Nom(X), the pair- ing of f ∈ Nom(Y, X) and e ∈ Nom(Y ▶ E[f ]) is the equivariant function
⟨f,e⟩ ∈ Nom(Y, X.E) given by mapping each y ∈ Y to ⟨f,e⟩ y  (f y, e y) ∈ X.E.
It is easy to check that these definitions satisfy (9)–(16) and so make Nom into a CwF.
Remark 3.2 For each object X ∈ C of a CwF, one can make C(X) into a category by taking, for each E, Ej ∈ C(X), the set of morphisms C(X)(E, Ej) to be C(X.E ▶ Ej[p]) with identities given by generic elements and composition given by ej ◦ e ej[⟨p , e⟩]. Then the mapping E ∈ C(X) '→ p ∈ C(X.E, X) extends to a full and faithful functor to the slice category
C(X) → C/X	(19)
E →e Ej '→ X.E ⟨p,e⟩ /X¸.Ej

X
The re-indexing operations are mapped to pullback functors between slices, since for each E ∈ C(X) and f ∈ C(Y, X)


Y.E[f ]  ⟨f○p,v⟩  /X¸.E
(20)


p	p
  
Y 	/X¸
f
is a pullback in C; see [11, Proposition 3.9]. When C = Nom, the functors (19) are not only full and faithful, but also essentially surjective and hence equivalences. This



E ∈ C(X)	F ∈ C(X.E) Π EF ∈ C(X)
f ∈ C(X.E ▶ F ) lam f ∈ C(X ▶ Π EF )

f ∈ C(X ▶ Π EF )	e ∈ C(X ▶ E) app f e ∈ C(X ▶ F [⟨idX , e⟩])

(Π EF )[g]= Π(E[g])(F [⟨g ◦ p , v⟩])
(lam f )[g]= lam f [⟨g ◦ p , v⟩] (app f e)[g]= app (f [g]) (e[g]) app (lam f ) e = f [⟨idX , e⟩]
lam(app (f [p]) v) = f

Fig. 4. Π-types in a CwF
is because, given p : E → X in Nom/X, the X-indexed family of sets (p−1{x} | x ∈ X) inherits a dependent G-action from the G-action of E (since p is equivariant); and for each x ∈ X, if A ⊆fin A supports e in E and pe = x, then it is a support for e ∈ p−1{x} dependent upon x, in the sense of Definition 3.1. So (p−1{x} | x ∈ X) is an object of Nom(X). It is sent by the functor (19) to
π1 :  x∈X p−1{x} = {(x, e) | pe = x} → X
which is isomorphic in Nom/X to p : E → X via the second projection function
π2 : (x, e) '→ e, whose inverse is e '→ (p e, e).

Π-types in Nom
The contexts, types-in-context, terms-in-context and term-substitutions of Martin- L¨of Type Theory are interpreted in a CwF by its objects, families, elements and morphisms respectively; see [11, Sect. 3.5]. CwFs provide an essentially algebraic formulation of Type Theory syntax in nameless (de Bruijn index) style and conse- quently one can translate each type-forming construct to an equivalent structure within CwFs. For example, the extra structure (Π, lam, app) corresponding to Π- types is given in Fig. 4. Since Nom is a topos and hence is in particular locally cartesian closed, it follows from Remark 3.2 that as a CwF Nom has this structure. We can describe (Π, lam, app) in this case as follows:
Π: given E ∈ Nom(X) and F ∈ Nom(X.E), first note that we get a dependent


f ∈  e∈Ex

F(x,e) to π · f  λ(e ∈ Eπ·x) ⭢ π · (f (π−1 · e)). To get a family Π EF ∈
 

consisting of those f that have a finite support dependent upon x with respect to the above action.

lam: if f ∈ Nom(X.E ▶ F ), then for each x ∈ X one can check that lam f x  λ(e ∈ Ex) ⭢ f (x, e) ∈  e∈Ex F(x,e)
is supported (dependently upon x) by any finite subset A ⊆fin A supporting
x in X; hence lam f x ∈ (Π EF )x. Furthermore x '→ lam f x is dependently equivariant (because f is) and hence lam f ∈ Nom(X ▶ Π EF ).
app : if f ∈ Nom(X ▶ Π EF ) and e ∈ Nom(X ▶ E), then for each x ∈ X we have f x ∈ (Π EF )x ⊆  e∈Ex F(x,e) and ex ∈ Ex; hence
app f e x  (f x)(e x) ∈ F(x,e x) = F [⟨id , e⟩]x
and one can check that x '→ app f e x is dependently equivariant, because f and
e are. So we get app f e ∈ Nom(X ▶ F [⟨id , e⟩]).
It is easy to see that these operations satisfy the properties in Fig. 4.

Name objects in Nom
For each sort of names N ∈ Nsort , the set AN of atoms of that sort becomes a nominal set once we endow it with the G-action given by function application, π · a  π a, with respect to which each a ∈ AN is supported by {a}.
From Remark 3.2 we have that the category Nom(1) of families over the terminal object 1 is equivalent to Nom. For each X ∈ Nom we will not make a notational distinction between a nominal set Y and the corresponding family in Nom(X) which is constant with value Y . In particular, for each sort of names N ∈ Nsort , we just write AN ∈ Nom(X) for an object of names regarded as a constant family over X. The elements a ∈ Nom(X ▶ AN ) of this family are just the equivariant functions a ∈ Nom(X, AN ).
To interpret branching on name equality we will use the following operation in the CwF Nom:


a, b ∈ Nom(X ▶ AN )	e, f ∈ Nom(X ▶ E) ifeq(a, b, e, f ) ∈ Nom(X ▶ E)
(21)



where

ifeq(a, b, e, f ) x	ex	if ax = bx 
f x	otherwise

(x ∈ X)	(22)


Swapping names in context
If a, b ∈ AN are atoms of the same sort N , as usual we write (a b) for the permu- tation in G that interchanges a with b, leaving all other atoms fixed. We lift the action x '→ (a b) · x from elements of nominal sets to families and their elements in the CwF Nom as follows

The operation


a, b ∈ Nom(X ▶ AN )	E ∈ Nom(X) (a b) · E ∈ Nom(X)
(23)

is defined by
((a b) · E)x  E(bx a x)·x	(x ∈ X) with dependent G-action
act (a b)·E xπ e  act E ((bx a x) · x) πe	(x ∈ X, π ∈ G, e ∈ ((a b) · E)x)
∈ Eπ·(bx a x)·x
= E(b(π·x) a(π·x))·π·x	(using equivariance of a and b)
= ((a b) · E)π·x
In other words, the action of π on e ∈ ((a b)·E)x is the action of π on e ∈ E(bx a x)·x
given by the family E. 9
Similarly, the operation


a, b ∈ Nom(X ▶ AN )	e ∈ Nom(X ▶ E) (a b) · e ∈ Nom(X ▶ (a b) · E)
(24)

is defined by
((a b) · e) x  e((bx a x) · x)	(x ∈ X)
∈ E(bx a x)·x = ((a b) · E)x
which is dependently equivariant with respect to the above dependent G-action, since ((a b)·e) (π·x)  e((b(π·x) a(π·x))·(π·x)) = π·e((bx a x)·x)= π·((a b)·e) x, using equivariance of a, b and dependent equivariance of e.
Freshness in context
If X ∈ Nom, x ∈ X and a ∈ A, we write a # x for the usual nominal sets freshness relation: by definition it means that there is a finite subset A ⊆fin A supporting x in X with a ∈/ A; see [16, Sect. 3.1]. If E ∈ Nom(X), then the freshness relation for the nominal set X.E corresponds to a dependent version of freshness: if x ∈ X and e ∈ Ex, then by Definition 3.1, there is some finite subset A ⊆fin A − {a} supporting e dependent upon x iff a # (x, e) holds for the nominal set X.E. In this case it is tempting to write ‘a # e’, but will avoid doing so, because it is easy to forget that a # x is also required for this to make sense.

9 We write (bx a x) · x in the above, rather than (ax b x) · x, to indicate that when using equivariant functions valued in general permutations rather than just transpositions, we should define (π · E)x to be E(π x)−1 ·x. Of course (bx a x) · x = (ax b x) · x, since transpositions are self-inverse.

As well as freshness for elements of families, we will need a notion of freshness for families themselves. Given E ∈ Nom(X) and x ∈ X, it makes no sense to write ‘a # Ex’ because, given the way we have defined families of nominal sets, Ex is not an element of a nominal set. Instead we use the fact that the freshness relation can be characterised equationally: a # x holds iff (a b) · x = x holds for some (or indeed, any) fresh b. In the CwF Nom we can replace ‘fresh b’ with use of the separated product [16, Sect. 3.4]:
X ∗ AN  {(x, a) ∈ X × AN | a # x}	(25) This is a nominal subset of the product: the G-action on X ∗ AN is well-defined by
π · (x, a)= (π · x, π a) (since the freshness relation is equivariant); and with respect
to this action (x, a) is finitely supported by A ∪ {a}, if A ⊆fin A supports x in X. This separated product will be used to model the extension of typing contexts with a fresh name. First and second projection yield


The first will be used to model weakening a judgement from a typing context to one extended with a fresh name and the second will model the fresh name itself.

Definition 3.3 Given a ∈ Nom(X ▶ AN ), using the operations in (26) and (27) we get a[p],ν ∈ Nom(X ∗ AN ▶ AN ). Then for any family E ∈ Nom(X) and any element e ∈ Nom(X ▶ E), using the swapping operations from Sect. 3.4 we define

a #X E   (a[p] ν) · E[p] = E[p] ∈ Nom(X ∗ AN )	(28)
a #X e   a #X E ∧ (a[p] ν) · e[p] = e[p] ∈ Nom(X ∗ AN ▶ E[p])	(29)

Note that the equality of families of nominal sets in (28) means not only that for all (x, b) ∈ X ∗ AN the sets E(ax b)·x and Ex are equal, but also that the dependent G-actions on these two families of sets are equal.
The following result follows easily from Definition 3.3:
Proposition 3.4 Suppose a, aj ∈ Nom(X ▶ AN ) and e ∈ Nom(X ▶ E). Then

a #X E ⇒ aj #X (a aj) · E	(30)
a #X e ⇒ aj #X (a aj) · e	(31)
ν #X∗AN e[p]	(32)

2

Proposition 3.5 (name restriction) There are operations


E ∈ Nom(X ∗ AN )	ν #X∗AN E


res E ∈ Nom(X)
e ∈ Nom(X ∗ AN ▶ E)	ν #X∗AN  e
res e ∈ Nom(X ▶ res E)
(33)

(34)

satisfying
(res E)[p] = E ∈ Nom(X ∗ AN )	(35)
(res e)[p] = e ∈ Nom(X ∗ AN ▶ E)	(36)
We call res E a name restricted family and res e a name restricted element (of a name restricted family).
Proof. From definition (28) we have that ν #X∗AN E implies that E(x,a) = E(x,b)
for all x ∈ X and a, b # x (and the dependent G-actions on each family are equal).
So res E is well-defined by
(res E)x  E(x,a) where a # x   (x ∈ X)	(37)
and clearly satisfies (res E)[p] = E. Similarly, if ν #X∗AN e, then definition (29) implies that e(x, a)= e(x, b) ∈ E(x,b) = E(x,a) for all x ∈ X and a, b # x. So res e is well-defined by
(res e) x  e(x, a) where a # x  (x ∈ X)	(38) and clearly satisfies (res e)[p] = e.		2
The form of locally scoped name embodied by the above proposition might seem
trivial, but it is exactly the kind that occurs in connection with concreting name abstractions, as we see next.
Dependent name abstraction
We next describe structure in the CwF Nom that enables us to model dependently typed name abstraction, generalizing the usual notion of name abstraction for nom- inal sets [16, Chapter 4] and putting into the context of CwFs the fibred category

construct Σ∗
from [18, Sect. 3.3.2].

Definition 3.6 Given E ∈ Nom(X ∗ AN ), consider the X-indexed family of sets
N E, where for each x ∈ X
( N E)x  {(a, e) | a ∈ AN ∧ a # x ∧ e ∈ E(x,a)}/ ≈x
is a quotient set. The equivalence relation ≈x relates (a, e) and (aj, ej) iff (b a) · e = (b  aj) · ej ∈ E(x,b) holds for some b ∈ AN with b /= a, b /= aj, b # (x, e) and

b # (x, ej), or equivalently, for any such b. We will write the ≈x-equivalence class of (a, e) as ⟨a⟩xe. We get a well-defined dependent G-action on N E by defining π · ⟨a⟩xe  ⟨π a⟩π·x(π · e). If A ⊆fin A supports e ∈ E(x,a) dependent upon (x, a), then it also supports ⟨a⟩xe ∈ ( N E)x. (In fact A − {a} supports ⟨a⟩xe, as the next lemma shows.) So we get an operation


E ∈ Nom(X ∗ AN )


N E ∈ Nom(X)
(39)

that we call dependent name abstraction for families of nominal sets.
Remark 3.7 (Curry-Howard for ) If X ∈ Nom and ϕ(a, x) is a property of elements of AN × X that is equivariant (that is, (∀π ∈ G) ϕ(a, x) ⇒ ϕ(π a,π · x)), then the freshness quantiﬁer ( a ∈ AN ) ϕ(a, x) means that ϕ(a, x) holds for some a ∈ AN with a # x, or equivalently, for any such a; see [16, Sect. 3.2]. There is a form of Curry-Howard correspondence between this quantifier and dependent name abstraction. For we can regard each family E ∈ Nom(X) as an equivariant property ϕE(x) of elements x ∈ E, by defining ϕE(x) to hold iff Ex is inhabited. Then ϕ N E (x) holds iff ( a ∈ AN ) ϕE(x, a).
Lemma 3.8 Suppose E ∈ Nom(X ∗ AN ) and x ∈ X.
For all ⟨a⟩xe ∈ ( N E)x and aj ∈ AN , aj # (x, ⟨a⟩xe) ∈ X.  N E iff either
aj = a, or aj # ((x, a), e) ∈ (X ∗ AN ).E.
For each f ∈ ( N E)x and a ∈ AN with a # (x, f ) ∈ X. N E, there is a unique
f @x a ∈ E(x,a), called the concretion of f at a, such that f = ⟨a⟩x(f @x a).
Proof.
The proof is similar to the proof of [16, Proposition 4.5].
Existence: by definition of N E, f is of the form ⟨aj⟩xe for some aj # x and e ∈ E(x,a′). If aj = a, we can take f @x a = e; otherwise, by part (i) we have a # ((x, aj), e) and hence (a aj) · e ∈ E(x,a) with (aj, e) ≈x (a, (a aj) · e). Therefore f = ⟨aj⟩xe = ⟨a⟩x(a aj) · e and we can take f @x a = (a aj) · e.
Uniqueness: if ⟨a⟩xe = ⟨a⟩xej ∈ ( N E)x, then (a, e) ≈x (a, ej) and hence for a suitably fresh b we have (b a) · e = (b a) · ej and therefore e = ej.


There is a name abstraction operation for elements of families
e ∈ Nom(X ∗ AN ▶ E) abs e ∈ Nom(X ▶	N E)
2



(40)



which is well-defined by

abs ex  ⟨a⟩xe(x, a) where a # x	(41)

since the right-hand side is independent of the choice of a ∈ AN satisfying a # x
and does give a dependently equivariant function.

We next lift the process of concreting a name abstraction at a fresh atom to an operation in the CwF Nom. This involves using the version of name restriction given by Proposition 3.5. Suppose f ∈ Nom(X ▶ N E) and a ∈ Nom(X ▶ AN ) satisfy a #X f and hence also a #X N E. From the latter it follows that E ∈ Nom(X ∗ AN ) satisfies a[p] #X∗AN E and hence by Proposition 3.4 that ν #X∗AN (a[p] ν) · E. So as in Proposition 3.5 we can form res (a[p] ν) · E ∈ Nom(X). For each x ∈ X, picking any b # x, by Lemma 3.8 we get (f x) @x b ∈ E(x,b) and hence (ax b)·((f x)@x b) ∈ E((ax b)·x,a x) = (res (a[p] ν) · E)x, by (37). Furthermore, this element of (res (a[p] ν) · E)x is independent of the choice of of b, because a #X f . To see this, suppose bj # x and let e  (f x) @x b and ej  (f x) @x bj. Thus f x = ⟨b⟩xe = ⟨bj⟩xej.  From a #X f , that is (a[p]  ν) · f [p] = f [p], we get f ((ax b) · x)= f x = f ((ax bj) · x) and hence ⟨a x⟩x(ax b) · e = (ax b) · f x =
⟨a x⟩x(ax bj) · ej; therefore (ax b) · e = (ax bj) · ej, by definition of ≈x.
In this way we get an operation


f ∈ Nom(X ▶	N E)	a ∈ Nom(X ▶ AN )	a #X f


conc f a ∈ Nom(X ▶ res (a[p] ν) · E)
(42)

well-defined by:
conc f a x  (ax b) · (fx @x b) where b # x	(43)
It is not hard to see that	N , abs and conc are stable under re-indexing
( N E)[g]=	N (E[g ∗ AN ])	(44)
(abs e)[g]= abs(e[g ∗ AN ])	(45)
(conc f a)[g]= conc(f [g])(a[g])	(46) and satisfy the following forms of β- and η-conversion:
conc(abs e) a = res((a[p] ν) · e)	(47)
abs(conc(f [p]) ν)= f	(48)
Remark 3.9 (adjoint characterization of N ) The non-dependent name ab- straction [AN ]Y discussed in [16, Sect. 4.7] is the special case of (39) when X =1 and E = Y [p] for some Y ∈ Nom(1) ∼= Nom. The functor [AN ]( ) : Nom → Nom can be characterised as the right adjoint to the separated product function ( ) ∗ AN : Nom → Nom; see [16, Theorem 4.12]. Similarly, N E can be given a characterization as a right adjoint, as follows:
For each X ∈ Nom there is a functor ( ) ∗ AN : Nom(X) → Nom(X ∗ AN ) which takes an object E ∈ Nom(X) to the family given by
(E ∗ AN )(x,a)  {e ∈ Ex | a # (x, e) ∈ X.E}   ((x, a) ∈ X ∗ AN )  (49) with dependent G-action inherited from that for E: π ∈ G, e ∈ (E∗AN )(x,a) '→ π·e ∈
(E ∗AN )(π·x,π a). The functor takes morphisms f ∈ Nom(X)(E, Ej)= Nom(X.E ▶

Ej[p]) to f ∗ AN ∈ Nom(X ∗ AN )(E ∗N AN , Ej ∗ AN )= Nom((X ∗ AN ).(E ∗ AN ) ▶
(Ej ∗ AN )[p]), where
(f ∗ AN )((x, a), e)  f (x, e)	(((x, a), e) ∈ (X ∗ AN ).(E ∗ AN ))	(50)
(which is well-defined, because f is dependently equivariant and hence satisfies a # (x, e) ∈ X.E ⇒ a # (x, f (x, e)) ∈ X.Ej). The functor ( ) ∗ AN : Nom(X) → Nom(X ∗ AN ) is in fact full and faithful: faithfulness is immediate (since for any (x, e) ∈ X.E we can always find some a ∈ AN with a # (x, e)); fullness amounts to the fact that since g ∈ Nom((X ∗ AN ).(E ∗ AN ) ▶ (Ej ∗ AN )[p]) satisfies
a # (x, e) ∈ X.E ⇒ a # (x, g((x, a), e)) ∈ X.Ej
we get a well-defined f ∈ Nom(X.E ▶ Ej[p]) by defining
f (x, e)  g((x, a), e) where a # (x, e)
and f ∗ AN = g.
We claim that the dependent name abstraction N E is the value at E ∈ Nom(X) of a right adjoint to ( ) ∗ AN : Nom(X) → Nom(X ∗ AN ). The counit of the adjunction at E

εE ∈ Nom(X ∗ AN )( N E ∗ AN , E)= Nom((X ∗ AN ).( N E ∗ AN ) ▶ E[p])
is given by the concretion operation from Lemma 3.8(ii):
εE((x, a),f )  f @x a	(((x, a),f ) ∈ (X ∗ AN ).( N E ∗ AN ))
This is an isomorphism (necessarily, because ( ) ∗ AN is full and faithful), whose inverse is given by the element of Nom((X ∗ AN ).E ▶ ( N E)[p]) that maps each ((x, a), e) ∈ (X ∗ AN ).E to ⟨a⟩xe ∈ ( N E)x. It has the universal property needed for the right adjoint at E: for each
f ∈ Nom(X ∗ AN )(Ej ∗ AN , E)= Nom((X ∗ AN ).(Ej ∗ AN ) ▶ E[p])


we have

well-defined by
fˆ ∈ Nom(X)(Ej,  N E)= Nom(X.Ej ▶ ( N E)[p])

fˆ(x, ej)  ⟨a⟩xf ((x, a), ej) where a # (x, ej) ∈ X.Ej

Then εE ◦(fˆ∗AN )= f , because concretion satisfies (⟨a⟩xe)@xa = e (by Lemma 3.8); and fˆ is the unique such morphism in Nom(X)(Ej, N E), because concretion sat- isfies f = ⟨a⟩x(f @x a) (by the same lemma).





 ⬦)   1 ∈ C
 Γ)   X ∈ C	 Γ ▶ T )  E ∈ C(X)	x ∈/ dom(Γ)

 Γ(x : T ))   X.E ∈ C

 Γ ▶ T )   E ∈ C(X)	 Γ(x : T ) ▶ T j)   Ej ∈ C(X.E)
 Γ ▶ Π(x : T )T j)   Π E Ej ∈ C(X)
 Γ ▶ T )  E ∈ C(X)	x ∈/ dom(Γ)
 Γ(x : T ) ▶ x)   v ∈ C(X.E ▶ E[p])
 Γ ▶ x)   e ∈ C(X ▶ E)	xj ∈/ dom(Γ)	 Γ ▶ T j)   Ej ∈ C(X)
 Γ(xj : T j) ▶ x)   e[p] ∈ C(X.Ej ▶ E[p])
 Γ ▶ T )   E ∈ C(X)	 Γ(x : T ) ▶ t)   e ∈ C(X.E ▶ F )
 Γ ▶ λ(x : T )t)   lam e ∈ C(X ▶ Π EF )
 Γ ▶ t)  f ∈ C(X ▶ Π EF )	 Γ ▶ tj)  e ∈ C(X ▶ E)
 Γ ▶ t tj)  app f e ∈ C(X ▶ F [⟨id , e⟩])

Fig. 5. Semantics of MLTT in a CwF


Nominal Set Semantics of FreshMLTT
Hofmann [11, Sect. 3.5] (following Streicher [22]) gives the semantics of Martin-L¨of Type Theory in a CwF C. It takes the form of a partial interpretation function ) mapping contexts to objects, types-in-context to families and terms-in-context to elements of families. For simplicity we just consider Π-types, but other constructs
of conventional Martin-L¨of Type Theory can be interpreted similarly. Specifically, given a CwF C with Π-types (see Fig. 4), Fig. 5 inductively defines the graph of the interpretation function using relations of the following form, where Γ ranges over context expressions, T over type expressions, t over term expressions, X over C-objects, E over C-families and e over elements of C-families:

 Γ)  X ∈ C
 Γ ▶ T )   E ∈ C(X)
 Γ ▶ t)   e ∈ C(X ▶ E)

Here, we take Γ)  X ∈ C to mean that Γ) is defined (written as Γ)↓) and equal to X ∈ C, etc. Hofmann [11, Theorem 3.35] sketches the proof of the following soundness properties of the interpretation with respect to the provable judgements

of Martin-L¨of Type Theory:
Γ ▶ ok ⇒ (∃X) Γ)   X ∈ C	(51)
Γ ▶ T ⇒ (∃X, E) Γ ▶ T )   E ∈ C(X)	(52)
Γ ▶ t : T ⇒ (∃X, E, e) Γ ▶ T )   E ∈ C(X) ∧  Γ ▶ t)   e ∈ C(X ▶ E)
(53)
Γ ▶ T = T j ⇒ (∃X, E) Γ ▶ T )  E ∈ C(X) ∧ Γ ▶ T j)  E ∈ C(X)	(54) Γ ▶ t = tj : T ⇒ (∃X, E, e) Γ ▶ t)  e ∈ C(X ▶ E) ∧
 Γ ▶ tj)   e ∈ C(X ▶ E)	(55)
Taking C to be the CwF Nom discussed in Sect. 3, the interpretation par- tial function can be extended to the expressions of FreshMLTT. Fig. 6 gives the additional rules. Types of names are interpreted as name objects (Sect. 3.3) and dependent name abstraction types by the operation (39). Name swapping on types and terms is interpreted using the operations in Sect. 3.4. Locally scoping names in types and terms is interpreted using (33) and (34). Terms for branching on name equality, for name abstraction and concretion are interpreted using (21), (40) and (42).
Lemma 4.1 (weakening) If ΓΓj)↓ ∈ Nom and ΓΔΓj)↓ ∈ Nom, we can deﬁne a generalised projection morphism P(Γ, Δ, Γj) ∈ Nom( ΓΔΓj), ΓΓj)) as follows:
P(Γ, ⬦, ⬦)= id
P(Γ, Δ(x : T ), ⬦)= P(Γ, Δ, ⬦) ◦ p
P(Γ, Δ[n : N ], ⬦)= P(Γ, Δ, ⬦) ◦ p
P(Γ, Δ, Γj(x : T )) = ⟨P(Γ, Δ, Γj) ◦ p , v⟩
P(Γ, Δ, Γj[n : N ]) = P(Γ, Δ, Γj) ∗ AN

Then for any term t and any type T, we have 10
 ΓΔΓj ▶ T ) ≡ ΓΓj ▶ T )[P(Γ, Δ, Γj)]
 ΓΔΓj ▶ t) ≡ ΓΓj ▶ t)[P(Γ, Δ, Γj)]
Furthermore, the generalised projection morphisms P(Γ, ⬦[n : N ], Γj) are surjective, since p ∈ Nom(X ∗ AN ,X) (26) is surjective (because given x ∈ X we can always pick some atom a not in its support and hence with p(x, a)= x).	2
Theorem 4.2 (soundness) The soundness properties (51)–(55) of the interpre- tation of Martin-L¨of Type Theory in Nom continue to hold when it is extended to FreshMLTT. In addition, the following soundness properties for deﬁnitional fresh-
10 We write x ≡ y the Kleene equality of two potentially undefined expressions, i.e. if one side is defined so is the other and then x = y.

 Γ)   X ∈ Nom	n ∈/ dom(Γ)
 Γ[n : N ])   X ∗ AN ∈ Nom
 Γ)   X ∈ Nom
 Γ ▶ N )   AN ∈ Nom(X)

 Γ ▶ x)   e ∈ Nom(X ▶ E)	nj ∈/ dom(Γ)
 Γ[n : N ] ▶ x)  e[p] ∈ Nom(X ∗ AN′ ▶ E[p])
 Γ)   X ∈ Nom	n ∈/ dom(Γ)
 Γ[n : N ] ▶ n)   ν ∈ Nom(X ∗ AN ▶ AN )
 Γ ▶ n)   e ∈ Nom(X ▶ AN )	xj ∈/ dom(Γ)	 Γ ▶ T j)   Ej ∈ Nom(X)
 Γ(xj : T j) ▶ n)   e[p] ∈ Nom(X.Ej ▶ AN )
 Γ ▶ n)   e ∈ Nom(X ▶ AN )	nj ∈/ dom(Γ)
 Γ[n : N ] ▶ n)  e[p] ∈ Nom(X ∗ AN′ ▶ AN )
 Γ ▶ t)   a ∈ Nom(X ▶ AN )	 Γ ▶ n)   b ∈ Nom(X ▶ AN )
 Γ ▶ t1)  e ∈ Nom(X ▶ E)	 Γ ▶ t2)  f ∈ Nom(X ▶ E)
 Γ ▶ if t = n then t1 else t2)  ifeq(a, b, e, f ) ∈ Nom(X ▶ E)
 Γ ▶ T )   E ∈ Nom(X)
 Γ ▶ n)   a ∈ Nom(X ▶ AN )	 Γ ▶ nj)   b ∈ Nom(X ▶ AN )
 Γ ▶ (n nj) · T )   (a b) · E ∈ Nom(X)
 Γ ▶ t)   e ∈ Nom(X ▶ E)
 Γ ▶ n)   a ∈ Nom(X ▶ AN )	 Γ ▶ nj)   b ∈ Nom(X ▶ AN )
 Γ ▶ (n nj) · t)   (a b) · e ∈ Nom(X ▶ (a b) · E)
 Γ[n : N ] ▶ T )  E ∈ Nom(X ∗ AN )	ν #X∗AN E
 Γ ▶ ν[n : N ] T )   res E ∈ Nom(X)
 Γ[n : N ] ▶ t)   e ∈ Nom(X ∗ AN ▶ E)	ν #X∗AN  e
 Γ ▶ ν[n : N ] t)   res e ∈ Nom(X ▶ res E)
 Γ[n : N ] ▶ T )   E ∈ Nom(X ∗ AN )
 Γ ▶	[n : N ]T )	N E ∈ Nom(X)
 Γ[n : N ] ▶ t)   e ∈ Nom(X ∗ AN ▶ E)
 Γ ▶ α[n : N ]t)   abs e ∈ Nom(X ▶	N E)
 Γ ▶ t)  f ∈ Nom(X ▶	N E)	 Γ ▶ n)  a ∈ Nom(X ▶ AN )	a #X f
 Γ ▶ t @ n)  conc f a ∈ Nom(X ▶ res (a[p] ν) · E)
Fig. 6. Additional rules for the semantics of FreshMLTT

ness hold with respect to the relations a #X E and a #X e from Deﬁnition 3.3:
Γ ▶ (n : N ) # T ⇒ (∃X, a, E) Γ ▶ n)   a ∈ Nom(X ▶ AN ) ∧
 Γ ▶ T )   E ∈ Nom(X) ∧ a #X E	(56)

Γ ▶ (n : N ) # t : T ⇒ (∃X, a, E, e) Γ ▶ n)   a ∈ Nom(X ▶ AN ) ∧
 Γ ▶ T )   E ∈ Nom(X) ∧  Γ ▶ t)   e ∈ Nom(X ▶ E) ∧ a #X e  (57)
Proof. (sketch) The proof is done by mutual induction on the judgements of the FreshMLTT type system. We omit the induction steps for those judgements that already appear in MLTT, since a detailed proof (using contextual categories) can be found in [22, Chapter 3]. The remaining induction steps follow from the properties of the CwF Nom established in Sect. 3. We give details for the interesting cases.
Case


ΓΔ ▶ T	ΓΔ ▶ T j Γ[n : N ]Δ ▶ T = T j ΓΔ ▶ T = T j



(n-elim-typ)
ΓΔ ▶ t : T	ΓΔ ▶ tj : T
Γ[n : N ]Δ ▶ t = tj : T
ΓΔ ▶ t = tj : T



(n-elim-term)

Assuming ΓΔ ▶ T and ΓΔ ▶ T j, we apply the induction hypothesis to obtain
 ΓΔ)  X ∈ Nom, ΓΔ ▶ T )  E ∈ Nom(X) and ΓΔ ▶ T j)  Ej ∈ Nom(X). Assuming also Γ[n : N ]Δ ▶ T = T j, gives us Γ[n : N ]Δ)  Xj ∈ Nom and E[P(Γ, ⬦[n : N ], Δ)] = Ej[P(Γ, ⬦[n : N ], Δ)] ∈ Nom(Xj) using the Weakening Lemma (4.1). Then E = Ej ∈ Nom(X) follows from the fact that projection morphisms are surjective.
The induction step for (n-elim-term) similarly follows from the surjectivity of projection morphisms.
Case


Γ ▶ n : N	Γ ▶ T	Γ[nj : N ] ▶ (n nj) . T = T
Γ ▶ (n : N ) # T

(fresh-typ)

Supposing Γ ▶ n : N and Γ ▶ T , we obtain  Γ)   X ∈ Nom,  Γ ▶ n)   a ∈
Nom(X ▶ AN ) and  Γ ▶ T )   E ∈ Nom(X) using the induction hypothesis.
It follows from the Weakening Lemma that Γ[nj : N ] ▶ T )   E[p] ∈ Nom(X ∗
An). Therefore
 Γ[nj : N ] ▶ (n nj) . T )   (a[p] ν) · E[p] ∈ Nom(X ∗ AN )
with (a[p] ν) · E[p] = E[p], i.e. a #X E.

Case


Γ ▶ T	ΓΔ ▶ ok	[n : N ], [nj : N ] ∈ Δ ΓΔ ▶ (n nj) . T = T

(fresh-hyp-typ)

Suppose that Γ ▶ T , ΓΔ ▶ ok and [n : N ], [nj : N ] ∈ Δ. We only consider the case where n /= nj and Δ = Δ1[n : N ]Δ2[nj : N ]Δ3. Using the induction hypothesis we get Γ)↓, Δ)↓, ΓΔ)↓ ∈ Nom and Γ ▶ T )  E ∈ Nom( Γ)). We have ν #JΓΔ )∗A E[P(Γ, Δ1, ⬦)][p] by (32) and hence a #ΓΔ Ej via the Weakening Lemma, where a   ν[P(ΓΔ1[n : N ], Δ2[nj : N ]Δ3, ⬦)] and Ej   E[P(Γ, Δ, ⬦)].
Similarly, aj #ΓΔ Ej with aj  ν[P(ΓΔ1[n : N ]Δ2[nj : N ], Δ3, ⬦)]. It follows from Definition 3.3 and the properties of dependent G-actions that
Ej[p]= (aj[p] ν) · (a[p] ν) · Ej[p]
= (a[p] aj[p]) · (aj[p] ν) · Ej[p]
= (a[p] aj[p]) · E[p]
= ((a aj) · Ej)[p]
Since the projection function, p, is surjective, (a aj) · Ej and Ej are equal families over ΓΔ) ∈ Nom.
Case


Γ[n : N ] ▶ (n : N ) # T
Γ[n : N ] ▶ ν[n : N ] T = T

(local-typ-comp)

Suppose that Γ[n : N ] ▶ (n : N ) # T . Then we obtain Γ[n : N ])  X ∗ AN ∈ Nom and Γ[n : N ] ▶ T )  E ∈ Nom(X ∗AN ) satisfying ν #X∗AN E by applying the in- duction hypothesis and hence Γ ▶ ν[n : N ]T )  res E ∈ Nom(X). Consequently,
 Γ[n : N ] ▶ ν[n : N ]T )   (res E)[p] ∈ Nom(X ∗ AN ) by the Weakening Lemma and (res E)[p]= E ∈ Nom(X ∗ AN ) by (35).
Case


Γ[nj : N ] ▶ (n : N ) # T	Γ ▶ (n : N ) # t :	[nj : N ]T

Γ ▶ t @ n : ν[nj : N ] (n nj) . T	(

-elim)

Suppose Γ[nj : N ] ▶ (n : N ) # T . Applying the induction hypothesis gives  Γ[nj :
N ])   X ∗ AN ∈ Nom,  Γ[nj : N ] ▶ T )   E ∈ Nom(X ∗ AN ),  Γ[nj : N ] ▶
n)   a[p] ∈ Nom(X ∗ AN ▶ AN ) and a[p] #X∗AN  E. It follows from (32) that

ν #x∗AN
(a[p] ν) · E. Hence, Γ ▶ ν[n : nj](n nj) . T )   res (a[p] ν) · E ∈ Nom(X)

by (33).

Supposing further that Γ ▶ (n : N ) # t :  [nj : N ]T , we obtain Γ ▶  [nj : N ]T )   N Γ[nj : N ]T ) = N E ∈ Nom(X) and Γ ▶ t)  f ∈ Nom(X ▶  N E) with a #X f from the induction hypothesis. Hence, Γ ▶ t @ n)  conc fa ∈ Nom(X ▶ res (a[p] ν) · E).
Case


Γ[nj : N ] ▶ (n : N ) # t : T	n /= nj

Γ ▶ (α[nj : N ]t) @ n = ν[nj : N ] (n nj) . t : ν[nj : N ] (n nj) . T (

-comp)

Suppose Γ[nj : N ] ▶ (n : N ) # t : T with n /= nj. The induction hypothesis provides us with Γ[nj : N ])   X ∗ AN ,  Γ[nj : N ] ▶ n)   a[p] ∈ Nom(X ∗ AN ▶ AN ),
 Γ[nj : N ] ▶ T )   E ∈ Nom(X ∗ AN ) and  Γ[nj : N ] ▶ t)   e ∈ Nom(X ∗ AN ▶
E) satisfying a[p] #X∗AN e. It follows from (40) and (42) that conc(abs e) a ∈ Nom(X ▶ res (a[p] ν) · E) and from (31) and (34) that res (a[p] ν) · e ∈ Nom(X ▶ res (a[p] ν) · E). Hence, conc(abs e) a = res (a[p] ν) · e by (47).
Case


Γ ▶ t :	[n : N ]T	n ∈/ fn(t)
(
Γ ▶ t = α[n : N ](t @ n):	[n : N ]T

-uniq)

Suppose Γ ▶ t :  [n : N ]T . We obtain  Γ)   X ∈ Nom,  Γ ▶  [n : N ]T ) N E ∈ Nom(X) and Γ ▶ t)  f ∈ Nom(X ▶ N E) by applying the induction hypothesis. Then Γ[n : N ] ▶ t)  f [p] ∈ Nom(X ∗ AN ▶ N (E[p ∗ AN ])) by the Weakening Lemma and conc(f [p]) ν ∈ Nom(X ∗ AN ▶ res (ν[p] ν) · E[p ∗ AN ]) by
(42) using Proposition 3.4. We have res (ν[p] ν) · E[p ∗ AN ]= E ∈ Nom(X ∗ AN ) by (28) and hence abs(conc(f [p]) ν) ∈ Nom(X ▶  N E). Thus abs(conc(f [p]) ν)= f ∈ Nom(X ▶ N E) by (48).	2
Related Work
The first work on a dependent type theory with features inspired by the nominal sets treatment of names and binding was by Sch¨opp and Stark [19,18]. They make use of a ‘bunched’ structure for typing contexts, whose semantics combines the usual cartesian product with the separated product X ∗ Y = {(x, y) ∈ X × Y | x # y} of nominal sets [16, Sect. 3.4]; and they develop an abstract view of separated products and its adjoints using fibred category theory, together with a corresponding version of Martin-L¨of’s extensional Type Theory [13]. Here we are less ambitious, since we only consider the special case of X ∗ Y when Y = AN is a nominal set of names. We also use categories with families rather than fibred categories, but to a large extent that is a matter of personal taste (of the first author). However, we also target the intensional version of Martin-L¨of Type Theory [14], aiming for a system that is not

only implementable, but also reasonably simple from a user point of view. This is also one of the aims of Cheney’s DNTT [3], which was partly inspired by the work of Sch¨opp and Stark and is the system most closely related to the one presented here. Syntactically, DNTT adds to LF [10] names and dependent name abstraction types, with associated abstraction and concretion terms. However, the rule for forming concretions in DNTT has a strong hypothesis involving meta-theoretic freshness of the concreting name, rather than the ‘definitional freshness’ we have adopted from Crole and Nebel [7]. In our notation, the rule is
Γ ▶ t :		[n : N ]T	Γ[n : N ]Δ ▶ ok Γ[n : N ]Δ ▶ t @ n : T
and, for example, it is not strong enough to type the term j in Example 2.2. As explained in Sect. 2.3, the FreshMLTT rules for concretion involve extra syntactic constructs, namely terms for swapping names and for locally scoping names. The latter in particular should make FreshMLTT more expressive than existing ‘nominal’ type theories for encoding syntax-manipulating algorithms involving the creation of fresh names with a static scope – a common feature when it comes to manipulating binders with explicit names. Neither DNTT, nor the ‘calculus of nominal induc- tive constructions’ (CNIC) of Westbrook et al. [26,25] feature constructs for locally scoped names. 11 There are of course other approaches than the nominal one for dealing with issues to do with object-language binders in logical frameworks; we refer the reader to [3, Sect. 2] for a brief survey.
Future Work
We plan to develop a notion of normal form for FreshMLTT expressions, together with an algorithmic version of the rules and an implementation of them. In par- ticular, we hope to show that FreshMLTT has decidable type-checking. So far we have normal forms and a (currently partial) normalization result via normalization by evaluation [1] for a simply typed version of FreshMLTT. For simplicity, we have presented our theory of dependently typed name abstraction within Martin-L¨of’s open-ended type theory. An implemented version will need a closed system; and to be reasonably expressive that system should have universes and inductively de- fined families of types. As the Agda system shows, the usefulness of the latter is much enhanced by introducing dependently typed patterns [6]. We do not yet know whether these can be enhanced with FreshML-style name abstraction patterns [20, Sect. 2.4]. In any case, the use of dependent name abstraction within inductively defined families of types seems to offer interesting possibilities. For example, the CwF Nom supports the interpretation of inductively defined types for propositional freshness, which relate to definitional freshness in the same way that propositional equality types relate to definitional equality. Such types should allow one to develop constructive versions of some theorems of nominal logic [15] via the Curry-Howard

11 In particular, the ν types in CNIC are a form of name abstraction, not local scoping.

correspondence. As well inductive types, dually, it seems worth investigating the interaction between dependent name abstraction and coinductively defined types; see for example [12].
We have given a semantics for FreshMLTT by identifying appropriate structure in the particular CwF of nominal sets. It should be possible to axiomatize that structure as a generalised algebraic theory [2] extending the one for categories with families given by Dybjer [8, Sect. 2.2]. In this way one would obtain an algebraic version of the type theory we study in this paper.

References
Berger, U. and H. Schwichtenberg, An inverse of the evaluation functional for typed λ-calculus, in: 6th Annual Symposium on Logic in Computer Science (1991), pp. 203–211.
Cartmell, J., Generalised algebraic theories and contextual categories, Annals of Pure and Applied Logic 32 (1986), pp. 209–243.
Cheney, J., A dependent nominal type theory, Logical Methods in Computer Science 8 (2012), p. (1:08).
Clouston, R. A., “Equational Logic for Names and Binders,” Ph.D. thesis, University of Cambridge (2009).
Clouston, R. A. and A. M. Pitts, Nominal equational logic, in: L. Cardelli, M. Fiore and G. Winskel, editors, Computation, Meaning and Logic, Articles dedicated to Gordon Plotkin, Electronic Notes in Theoretical Computer Science 172, Elsevier, 2007 pp. 223–257.
Coquand, T., Pattern matching with dependent types, in: B. Nordstr¨om, K. Petersson and G. D. Plotkin, editors, Proceedings of the 1992 Workshop on Types for Proofs and Programs, B˚astad, Sweden, 1992,
pp. 66–79.
Crole, R. L. and F. Nebel, An internal language for FM-cartesian closed categories (the nominal lambda calculus) (2013), in Michael Mislove, editor, Proceedings of Mathematical Foundations of Programming Semantics (MFPS XXIX), New Orleans, LA, 2013. To appear.
Dybjer, P., Internal type theory, in: S. Berardi and M. Coppo, editors, Types for Proofs and Programs, Lecture Notes in Computer Science 1158, Springer Berlin Heidelberg, 1996 pp. 120–134.
URL  http://dx.doi.org/10.1007/3-540-61780-9_66

Gabbay, M. J. and A. Mathijssen, Nominal (universal) algebra: Equational logic with names and binding, Journal of Logic and Computation 19 (2009), pp. 1455–1508.
Harper, R., F. Honsell and G. D. Plotkin, A framework for defining logics, Journal of the Association for Computing Machinery 40 (1993), pp. 143–184.
Hofmann, M., Syntax and semantics of dependent types, in: A. M. Pitts and P. Dybjer, editors, Semantics and Logics of Computation, Publications of the Newton Institute, Cambridge University Press, 1997 pp. 79–130.
Kurz, A., D. L. Petrisan, P. Severi and F.-J. de Vries, Nominal coalgebraic data types with applications to lambda calculus, Logical Methods in Computer Science 9(4:20) (2013).
Martin-L¨of, P., “Intuitionistic Type Theory,” Bibliopolis, Napoli, 1984, 91 pp.
Nordstrom, B., K. Petersson and J. M. Smith, “Programming in Martin-L¨of’s Type Theory,” Oxford University Press, 1990.
Pitts, A. M., Nominal logic, a first order theory of names and binding, Information and Computation
186 (2003), pp. 165–193.
Pitts, A. M., “Nominal Sets: Names and Symmetry in Computer Science,” Cambridge Tracts in Theoretical Computer Science 57, Cambridge University Press, 2013.
Pitts, A. M. and M. J. Gabbay, A metalanguage for programming with bound names modulo renaming, in: R. Backhouse and J. N. Oliveira, editors, Mathematics of Program Construction. 5th International Conference, MPC2000, Ponte de Lima, Portugal, July 2000. Proceedings, Lecture Notes in Computer Science 1837 (2000), pp. 230–255.

Sch¨opp, U., “Names and Binding in Type Theory,” Ph.D. thesis, University of Edinburgh (2006).
Sch¨opp, U. and I. D. B. Stark, A dependent type theory with names and binding, in: Computer Science Logic, CSL04, Karpacz, Poland, Lecture Notes in Computer Science 3210 (2004), pp. 235–249.
Shinwell, M. R. and A. M. Pitts, Fresh Objective Caml user manual, Technical Report UCAM-CL-TR- 621, University of Cambridge Computer Laboratory (2005).
Shinwell, M. R., A. M. Pitts and M. J. Gabbay, FreshML: Programming with binders made simple, in: Eighth ACM SIGPLAN International Conference on Functional Programming (ICFP 2003), Uppsala, Sweden (2003), pp. 263–274.
Streicher, T., “Semantics of Type Theory,” Birkha¨user, 1991.
Univalent Foundations Program, T., “Homotopy Type Theory: Univalent Foundations for Mathematics,” http://homotopytypetheory.org/book, Institute for Advanced Study, 2013.
Urban, C., A. M. Pitts and M. J. Gabbay, Nominal unification, Theoretical Computer Science 323
(2004), pp. 473–497.
Westbrook, E., “Higher-Order Encodings with Constructors,” Ph.D. thesis, Washington University in St Louis (2008).
Westbrook, E., A. Stump and E. Austin, The calculus of nominal inductive constructions: an intensional approach to encoding name-bindings, in: Proceedings of the Fourth International Workshop on Logical Frameworks and Meta-languages: Theory and Practice (LFMTP 2009), Montreal, Canada, ACM International Conference Proceeding Series (2009), pp. 74–83.

A	The Rules of FreshMLTT
We only give the rules involving the new features of FreshMLTT. For the usual rules of Martin-Lo¨f Type Theory see [14], [11, Sect. 2], or [23, Appendix A.2].

Structural rules

Γ ▶ ok	ΓΔ ▶ J	n ∈/ dom(ΓΔ) Γ[n : N ]Δ ▶ J 

(wkg)

ΓΔ ▶ T	ΓΔ ▶ T ′
Γ[n : N ]Δ ▶ T = T ′


ΓΔ ▶ T = T ′


(n-elim-typ)
ΓΔ ▶ t : T	ΓΔ ▶ t′ : T
Γ[n : N ]Δ ▶ t = t′ : T


ΓΔ ▶ t = t′ : T


(n-elim-term)

Well-formed types


Γ ▶ ok
(n-form)
Γ ▶ N
Γ ▶ n : N	Γ ▶ n′ : N	Γ ▶ T


Γ ▶ (n n′) . T

(swap-typ)

Γ[n : N ] ▶ (n : N ) # T


Γ ▶ ν[n : N ] T

(local-typ)
Γ[n : N ] ▶ T
(
Γ ▶  [n : N ]T

-form)

Typing relation


Γ ▶ ok	[n : N ] ∈ Γ Γ ▶ n : N

(n-intro)
Γ ▶ n : N	Γ ▶ n′ : N	Γ ▶ t : T


Γ ▶ (n n′) . t : (n n′) . T

(swap-term)

Γ ▶ t : N	Γ ▶ n : N	Γ ▶ t1 : T	Γ ▶ t2 : T (ifeq)
Γ ▶ if t = n then t1 else t2 : T
Γ[n : N ] ▶ (n : N ) # t : T


Γ ▶ ν[n : N ] t : ν[n : N ] T

(local-term)

Γ[n : N ] ▶ t : T
(
Γ ▶ α[n : N ]t :  [n : N ]T

-intro)
Γ[n′ : N ] ▶ (n : N ) # T	Γ ▶ (n : N ) # t : [n′ : N ]T
Γ ▶ t @ n : ν[n′ : N ] (n n′) . T	(

-elim)


Deﬁnitional freshness for types


Γ ▶ n : N	Γ ▶ T	Γ[n′ : N ] ▶ (n n′) . T = T


Γ ▶ (n : N ) # T

(fresh-typ)

Deﬁnitional freshness for terms


Γ ▶ (n : N ) # T	Γ[n′ : N ] ▶ (n n′) . t = t : T


Γ ▶ (n : N ) # t : T

(fresh-term)


Deﬁnitionally equal types


Γ ▶ T	ΓΔ ▶ ok	[n : N ], [n′ : N ] ∈ Δ ΓΔ ▶ (n n′) . T = T

(fresh-hyp-typ)

Γ[n : N ] ▶ (n : N ) # T


Γ[n : N ] ▶ ν[n : N ] T = T

(local-typ-comp)


(cong-typ): congruence properties for
(n n′) . T , ν[n : N ] T and [n : N ]T (omitted).

(swap-typ-comp): computational properties of swapping, with well-formedness hypotheses omitted:
(n n) . T = T
(n n′) . (n n′) . T = T
(n n′) . (m m′) . T = ((n n′)m (n n′)m′) . (n n′) . T
(where (n n′)m is n′ if m = n, is n if m = n′ and is m otherwise) (n n′) . N = N
(n n′) . ν[n′′ : N ] T = ν[n′′ : N ] (n n′) . T where n′′ /= n, n′
(n n′) . [n′′ : N ]T =  [n′′ : N ](n n′) . T where n′′ /= n, n′
(n n′) . Π(x : T )T ′ = Π(x : (n n′) . T ) (n n′) . T ′((n n′) . x/x)


Deﬁnitionally equal terms
Γ ▶ t : T		ΓΔ ▶ ok	[n : N ], [n′ : N ] ∈ Δ ΓΔ ▶ (n n′) . t = t : T


(fresh-hyp-term)

Γ[n : N ] ▶ (n : N ) # t : T


Γ[n : N ] ▶ ν[n : N ] t = t : T

(local-term-comp)

Γ[n′ : N ] ▶ (n : N ) # t : T	n /= n′
Γ ▶ (α[n′ : N ]t) @ n = ν[n′ : N ] (n n′) . t : ν[n′ : N ] (n n′) . T (

-comp)

Γ ▶ t :  [n : N ]T	n ∈/ fn(t)
(
Γ ▶ t = α[n : N ](t @ n):  [n : N ]T

-uniq)

(cong-term): congruence properties for
(n n′) . t, if t = n then t′ else t′′, ν[n : N ] t, α[n : N ]t and t @ n (omitted).
(swap-term-comp): computational properties of swapping, with well-formedness hypotheses and types omitted:
(n n) . t = t
(n n′) . (n n′) . t = t
(n n′) . (m m′) . t = ((n n′)m (n n′)m′) . (n n′) . t
(where (n n′)m is n′ if m = n, is n if m = n′ and is m otherwise) (n n′) . n′′ = (n n′)n′′
(n n′) . (if t=n′′ then t′ else t′′)=if (n n′) . t=(n n′)n′′ then (n n′) . t′ else (n n′) . t′′
(n n′) . ν[n′′ : N ] t = ν[n′′ : N ] (n n′) . t where n′′ /= n, n′ (n n′) . α[n′′ : N ]t = α[n′′ : N ](n n′) . t where n′′ /= n, n′ (n n′) . λ(x : T )t = λ(x : (n n′) . T ) (n n′) . t((n n′) . x/x) (n n′) . t t′ = ((n n′) . t)((n n′) . t′)

(if-comp): computational properties of conditionals, with well-formedness hypotheses and types omitted: if n = n then t else t′ = t
if n = n′ then t else t′ = t′ (where n /= n′)
