EURO Journal on Computational Optimization 9 (2021) 100004

		




The Steiner bi-objective shortest path problem
Hamza Ben Tichaa, Nabil Absi a,âˆ—, Dominique Feilleta, Alain Quilliotb
a Ecole des Mines de Saint-Etienne, Univ Clermont Auvergne, CNRS, UMR 6158 LIMOS, Centre CMP, Departement SFL, F-13541, Gardanne, France
b LIMOS, Institut SupÃ©rieur dâ€™Informatique de ModÃ©lisation et leurs Applications, ISIMA, Campus des CÃ¨zeaux, AubiÃ¨re Cedex, France


a r t i c l e	i n f o	a b s t r a c t

	

Keywords:
Aâˆ— algorithm
Multiple destinations
Vehicle routing with road-network information
graph ğº = (ğ‘‰ , ğ´), with a subset ğ‘‡ âŠ‚ ğ‘‰ of terminals. Arcs are labeled with travel time and cost. The goal is to find In this paper, we introduce the Steiner Bi-objective Shortest Path Problem. This problem is defined on a directed a complete set of eï¬ƒcient paths between every pair of nodes in ğ‘‡ . The motivation behind this problem stems from
with a multi-objective Aâˆ— search strategy guiding the search towards the terminals. Computational results based data preprocessing for vehicle routing problems. We propose a solution method based on a labeling approach
on instances generated from real road networks show the eï¬ƒciency of the proposed algorithm compared to state-of-art approaches.





Introduction

The Vehicle Routing Problem (VRP) can be described as the prob- lem of designing a set of routes that start and end at a depot and that visit a number of geographically dispersed locations, called customers. In the standard version of the problem, the road network of the geo-
graph ğº = (ğ‘‡ , ğ·) is introduced, where ğ‘‡ is composed of the depot and graphic area at hand is not explicitly considered. Instead, a directed the customers, and ğ· represents all the possible connections between these nodes: ğ· = {(ğ‘–, ğ‘—) âˆ¶ ğ‘– âˆˆ ğ‘‡ , ğ‘— âˆˆ ğ‘‡ â§µ {ğ‘–}}. A weight ğ‘ğ‘–ğ‘— is then associ- ated with every arc (ğ‘–, ğ‘—) âˆˆ ğ· to indicate travel costs (distances) between
nodes.
Weights ğ‘ğ‘–ğ‘— are assumed to be precomputed using the road-network
structure, which can very easily be done with shortest path algorithms.
for each arc in ğ· (e.g., algorithm Aâˆ—, Hart et al. Hart et al. (1968)), by This can be performed by applying a goal directed search independently solving one-to-all shortest paths starting from each node in ğ‘‡ (e.g., Di-
jkstraâ€™s algorithm, Dijkstra (1959)), or by computing all-to-all shortest paths (e.g., Floydâ€™s algorithm, Floyd (1962)). All these algorithms admit a polynomial-time complexity and generally allow a very fast compu- tation of the data in view of the limited number of customers in VRP applications (rarely more than a few hundreds). A large amount of liter- ature exists to accelerate these algorithms for large-scale networks (see, e.g., Bast et al. (2016)), but none of them are really necessary in this context.
In many real-world routing problems however, and in most variants of the VRP, this model is not accurate enough to determine optimal so- lutions (Ben Ticha et al., 2018). Indeed, road segments usually have at
least two attributes, time and distance, and nodes in ğ‘‡ may be connected
together using many different paths with different trade-offs in distance and time. The VRP with Time Windows (VRPTW) gives a good illustra- tion of this diï¬ƒculty. In the VRPTW, vehicle routes are constrained by time windows that define the earliest and latest possible starting times of the service for customers. The objective is to minimize the total traveled
distance. The min-distance path between any pair of customers ğ‘– and ğ‘—
from ğ‘– to ğ‘— on the cost function. However, depending on the arrival time should usually be preferred because it minimizes the impact of traveling to ğ‘–, a fastest path could sometimes be required to reach customer ğ‘— on
time. As it depends on the complete sequence of customers in the route, deciding which path should be preferred between two successive cus- tomers cannot be determined in advance. The preprocessing approach described above is thus not appropriate.
To handle this situation, a more effective model has been proposed by Garaix et al. (2010). It consists in representing road network infor-
mation with a multigraph. The node set is still ğ‘‡ but the arc set is re-
placed by an arc multiset ğ· constructed as follows. Given two nodes in ğ‘‡ , a complete set of eï¬ƒcient paths is computed between these two nodes. Then, an arc is added to ğ· for every path in the complete set.
Arc weights (travel distance, travel time) are defined to their value in the corresponding path. An example of a multigraph is depicted on Figure 1. In this small example, pairs of nodes are connected by at most two arcs: in some cases the min-cost and min-time paths coin- cide, in other cases they are distinct and two parallel arcs are added. More generally, the size of the Pareto front, i.e. the number of Pareto optimal objective vectors, can be much larger and many parallel arcs could be inserted. All these eï¬ƒcient solutions are essential because they might all offer the best compromise to minimize costs and satisfy time constraints.


âˆ— Corresponding author.
E-mail addresses: hamza.ben-ticha@emse.fr (H. Ben Ticha), absi@emse.fr (N. Absi), feillet@emse.fr (D. Feillet), alain.quilliot@isima.fr (A. Quilliot).

https://doi.org/10.1016/j.ejco.2021.100004
Received 30 August 2020; Received in revised form 3 March 2021; Accepted 3 March 2021
2192-4406/Â© 2021 The Author(s). Published by Elsevier Ltd on behalf of Association of European Operational Research Societies (EURO). This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/)


Fig. 1. Road-network graph and multigraph for a simple example with one depot, three cus- tomers and two attributes (arcs labeled with (dis- tance,time)).











This new model opens important research perspectives that re- cently started receiving a strong interest (e.g., Lai et al. (2016), Letchford et al. (2014), Huang et al. (2017), Ben Ticha et al. (2017)). Among others, it opens the question of the tractability of computing the multigraph. Clearly, the arc multiset and their weights cannot be ob- tained by solving simple shortest path problems. The aim of the Steiner Multi-objective Shortest Path Problem is to deliver this information. It
of nodes in ğ‘‡ . In what follows, we adopt the standard terminology of consists in computing complete sets of eï¬ƒcient paths between every pair Steiner tree problems and call the nodes in ğ‘‡ terminals.
In this paper, we introduce the Steiner Multi-objective Shortest Path Problem and propose a solution approach for its solution. We limit our study to the case of two attributes (Steiner Bi-objective Shortest Path Problem, Steiner BSPP). The proposed approach is based on a dynamic
programming algorithm with an Aâˆ— guiding strategy. In addition to the
introduction of this new problem, the contributions of the paper are:
An original implementation of the Aâˆ— strategy that simultaneously
drives the search towards all the terminals.
An experimental study giving new insights on how eï¬ƒciently multi- graph data can be computed for vehicle routing problems.
The rest of this paper is organized as follows. In Section 2, we present an overview of the related literature. Section 3 formally introduces the Steiner BSPP and useful notation. It also reports some basic properties that will be helpful for the remainder of the paper. In Section 4, we describe our solution method. In Section 5, we propose some enhance- ments when the problem is addressed in the context of the VRPTW. Finally, numerical results are reported in Section 6.
Literature review

The Steiner BSPP is related to two types of problems: bi-objective shortest path problems (BSPPs) and â€œSteiner-likeâ€ problems:
BSPPs are multi-objective extensions of standard shortest path prob- lems (SPPs). Every arc of the graph receives two weights (that cor- respond to two criteria) and the goal is to generate eï¬ƒcient paths. Three variants can naturally be considered: the one-to-one BSPP, the one-to-all BSPP and the all-to-all BSPP, where eï¬ƒcient paths are searched between one origin and one destination, one origin and all destinations, all origins and all destinations, respectively. All three variants are NP-hard (Serafini, 1987).
lem. Given a weighted graph ğº = (ğ‘‰ , ğ´) and a set of terminals ğ‘‡ âŠ‚ ğ‘‰ , â€¢ Steiner problems originate from the well-known Steiner Tree Prob-
all the nodes in ğ‘‡ . It generalizes the minimum spanning tree prob- the Steiner tree problem consists in finding a min-cost tree covering
lem, where all nodes have to be covered. Following this terminology, the Steiner Traveling Salesman Problem was introduced and inves- tigated by several authors (CornuÃ©jols et al., 1985; Letchford et al.,
tices in ğ‘‡ âŠ‚ ğ‘‰ is sought. It generalizes the Traveling Salesman Prob- 2013)). In this problem, a minimum cost cycle visiting all the ver- lem (case ğ‘‡ = ğ‘‰ ). Following the same trend, we called our problem
Steiner BSPP because we are only interested in shortest paths be-
paths. It generalizes the all-to-all shortest path problem (ğ‘‡ = ğ‘‰ ) and tween a subset of nodes (the terminals) instead of all-to-all shortest the one-to-one shortest path problem (|ğ‘‡ | = 2)

If the relationship with Steiner problems is important to understand the name given to our problem, the Steiner BSPP is essentially a variant of BSPPs. Actually, solving the all-to-all BSPP also solves the Steiner BSPP. Equivalently, solving a one-to-all BSPP starting from each node
in ğ‘‡ or solving a one-to-one BSPP for each pair of nodes in ğ‘‡ also solves
the Steiner BSPP. Clearly our point here is to propose a more eï¬ƒcient
approach.
BSPPs (and more generally Multi-objective SPPs) have been widely studied in the literature, as acknowledged by several literature reviews (ClÃ­maco and Pascoal, 2012; Ehrgott and Gandibleux, 2000; Skriver, 2000)). A first important matter concerns the size of solution sets, which directly translates to the number of arcs that would have to be added to the multigraph in our VRP context. Hansen (1980) shows that, in the worst case, this number can be exponential in the size of graph
ğº. MÃ¼ller-Hannemann and Weihe (2006) and Mandow and PÃ©rez de la
Cruz (2009) however show that much better behaviors can be observed
in practice. Evaluating the typical size of the solution sets in our context will be a meaningful output of the paper.
A second important information that can be derived from the liter- ature concerns exact solution methods. The prominent approaches to solve BSPPs are labeling algorithms. These algorithms all follow the same principle (Hansen, 1980; Martins, 1984b). A label represents a par- tial path in the graph. The most elementary operation in the algorithm is to select a label and extend the associated partial path with an additional arc. It results in a new label that can be dominated or kept for further extensions. Algorithms differ in the order in which these elementary la- bel extensions are performed and in the data structures that are used to eï¬ƒciently manage label selection and dominance. Labeling algorithms can solve one-to-one and one-to-all BSPPs. Algorithms applied to solve all-to-all SPPs have a very different nature and, as far as we know, have never been extended to the bi-objective or multi-objective case. Also, the presence of nonpositive arc weights can complicate a lot the problems, especially when elementary paths are required (see, e.g., Martins and Santos (1999), Irnich and Desaulniers (2005) or Feillet et al. (2004)). Seeing that we are only interested in positive weights in our context, we focus on this case hereafter.
Regarding the one-to-all BSPP, two main label selection heuris- tics are employed in the literature. In a node-selection strategy e.g., (Brumbaugh-Smith and Shier, 1989), all labels representing paths end- ing at a same node are selected and extended to all successors of this



node. In a label-selection strategy, a single label is selected, based on its value. Again this label is extended to all the successors of the ending node of the path that it represents (e.g., Tung and Chew (1992)). Several computational studies evaluated various variants of these two strategies and gave a slight advantage to node-selection techniques (Guerriero and Musmanno, 2001; PaixÃ£o and Santos, 2013).
with a destination-driven selection rule, following the principle of Aâˆ— In the one-to-one BSPP, the label-selection strategy is employed but
algorithm (Mandow and PÃ©rez de la Cruz, 2010; Stewart and White III, 1991). Labels are selected according to an optimistic evaluation of the cost that paths reaching the destination from this label could have. In order to eï¬ƒciently select labels and add new labels to the set of labels in wait, a heap is generally used. In Mandow and PÃ©rez de la Cruz (2010), all label evaluations (which are actually composed of a value for each criterion) are compared and a label with a non-dominated evaluation is selected. In Tung and Chew (1992), the two components of the eval- uation are added and the label with the smallest sum is selected. The evaluation measure is given by the actual cost of the label completed, for both components, by the mono-criterion shortest path cost to reach the destination.
Another category of solution methods is based on ranking. They determine paths progressively, in a non-decreasing order of one of the objectives (Climaco and Martins, 1982; Raith and Ehrgott, 2009). Martins (1984a) proposed a ranking method based on path deletion. In this method, the shortest path according to a selected criterion is de- termined at each iteration. This path is then eliminated from the net- work for the next iteration. The algorithm stops when the expected number of path is found or when no more eï¬ƒcient paths are found. Huarng et al. (1996) however showed that this ranking method was not competitive compared to labeling approaches.
Another approach was proposed by Mote et al. Mote et al. (1991). It is organized in two phases. In the first phase, extreme solutions in
We introduce the subset ğ‘‡ âŠ‚ ğ‘‰ of terminals. The Steiner BSPP aims at
finding a complete set of eï¬ƒcient paths between every pair of terminals.
A few definitions are given below, to clarify what a complete set of eï¬ƒcient paths is. We consider in these definitions that all paths have the same starting and ending points.
Definition 1. Dominance
A vector (ğ‘1 , ğ‘2 ) dominates a vector (ğ‘1 , ğ‘2 ) if and only if ğ‘1 â‰¤ ğ‘1 and
ğ‘2 â‰¤ ğ‘2 with at least one inequality being strict.
Definition 2. Efficient path
A path ğ‘ƒ1 is eï¬ƒcient if there does not exist any path ğ‘ƒ2 whose cost vector (ğ‘‘(ğ‘ƒ2 ), ğ‘¡(ğ‘ƒ2 )) dominates (ğ‘‘(ğ‘ƒ1 ), ğ‘¡(ğ‘ƒ1 )).
Definition 3. Set of non-dominated cost vectors (also called Pareto front)
The set of all non-dominated cost vectors is the set of vectors
(ğ‘‘(ğ‘ƒ ), ğ‘¡(ğ‘ƒ )) obtained from eï¬ƒcient paths.
Definition 4. Complete set of efficient paths
vector (ğ‘‘, ğ‘¡) admits at least one path ğ‘ƒ âˆˆ P such that (ğ‘‘, ğ‘¡) = (ğ‘‘(ğ‘ƒ ), ğ‘¡(ğ‘ƒ )). A set P of eï¬ƒcient paths is complete if every non-dominated cost
A complete set is minimal if none of its subsets is complete.
For the remainder of the paper, we denote |ğ‘‰ | = ğ‘›, |ğ´| = ğ‘š and |ğ‘‡ | =
ğ‘›ğ‘‡ .
3.2. Additional notation and basic properties

that will be useful in next sections. We first recall that a vector ğ‘  = We now introduce additional notation and some simple properties (ğ‘1 , ğ‘2 ) is lexicographically smaller than a vector ğ‘ = (ğ‘1 , ğ‘2 ), denoted by
ğ‘ < ğ‘, if either ğ‘ < ğ‘ or both ğ‘ = ğ‘ and ğ‘ < ğ‘ . Similarly, we say
ğ‘™ğ‘’ğ‘¥
that a path ğ‘ƒ1 is lexicographically smaller than a path ğ‘ƒ2, denoted by
ğ‘ƒ1 < ğ‘ƒ2 , if and only if (ğ‘‘(ğ‘ƒ1 ), ğ‘¡(ğ‘ƒ1 )) < (ğ‘‘(ğ‘ƒ2 ), ğ‘¡(ğ‘ƒ2 )). The lexicographic

the convex hull of the BSPP solution space are computed by solving
ğ‘™ğ‘’ğ‘¥
ğ‘™ğ‘’ğ‘¥

the LP relaxation of the problem. In the second phase, an enumerative method is used to determine the set of eï¬ƒcient paths. The main idea is to restrict enumeration thanks to the information extracted from the first phase. Raith and Ehrgott (2009) studied more deeply this two-phase ap- proach. They investigated different combinations of methods for the two
order defines a total order between paths.
Let P(ğ‘¢, ğ‘£) denote the set of all paths linking two nodes ğ‘¢ and ğ‘£ in
ğ‘‡ and let Pğ‘œğ‘ğ‘¡ (ğ‘¢, ğ‘£) = (ğ‘ƒ1 , ğ‘ƒ2 , ..., ğ‘ƒğ‘Ÿ ) be a complete set of eï¬ƒcient paths between ğ‘¢ and ğ‘£. Without loss of generality, we assume that Pğ‘œğ‘ğ‘¡ (ğ‘¢, ğ‘£) is minimal and that paths in Pğ‘œğ‘ğ‘¡ (ğ‘¢, ğ‘£) are sorted according to the lexico-
graphic order, i.e., ğ‘ƒ1 < ğ‘ƒ2 < ... < ğ‘ƒğ‘Ÿ . As a consequence:

phases: a network simplex method and single objective label setting and
ğ‘™ğ‘’ğ‘¥
ğ‘™ğ‘’ğ‘¥
ğ‘™ğ‘’ğ‘¥

label correcting algorithms were tested in Phase 1 and, ranking and bi- objective labeling approaches were explored in Phase 2. They compared the two-phase method with purely labeling approaches and a ranking method. Computational experiments carried out on different instance sets showed the competitiveness of the two-phase method with the dif- ferent configurations. In their conclusions, Raith and Ehrgott (2009) no- ticed that the eï¬ƒciency of solution methods depends a lot on network
ğ‘‘(ğ‘ƒ1 ) < ğ‘‘(ğ‘ƒ2 ) < ... < ğ‘‘(ğ‘ƒğ‘Ÿâˆ’1 ) < ğ‘‘(ğ‘ƒğ‘Ÿ )
ğ‘¡(ğ‘ƒ1 ) > ğ‘¡(ğ‘ƒ2 ) > ... > ğ‘¡(ğ‘ƒğ‘Ÿâˆ’1 ) > ğ‘¡(ğ‘ƒğ‘Ÿ )
Using this notation, we can recall the following simple properties:
Property 1. ğ‘ƒ1 is the shortest path in distance from ğ‘¢ to ğ‘£ in ğº: ğ‘‘(ğ‘ƒ1) =

structure.
ğ‘šğ‘–ğ‘›
ğ‘ƒ
ğ‘‘(ğ‘ƒ ).

Besides these exact methods, many heuristic algorithms have also been applied to BSPPs, such as evolutionary algorithms (e.g.,
âˆˆP(ğ‘¢,ğ‘£)
Property 2. ğ‘ƒğ‘Ÿ is the shortest path in time from ğ‘¢ to ğ‘£ in ğº: ğ‘¡(ğ‘ƒğ‘Ÿ ) =

Pangilinan and Janssens (2007)) or ant colony optimization algorithms
ğ‘šğ‘–ğ‘›
ğ‘ƒ
ğ‘¡(ğ‘ƒ ).

(e.g., Ghoseiri and Nadjari (2010)). These algorithms are however out of the scope of this research as we focus on exact solution.
âˆˆP(ğ‘¢,ğ‘£)
Proof. For each non-eï¬ƒcient path ğ‘ƒ âˆˆ P(ğ‘¢, ğ‘£) â§µ P

ğ‘œğ‘ğ‘¡
(ğ‘¢, ğ‘£), at least one



Problem definition, notation and basic properties

Problem definition

We consider a directed graph ğº = (ğ‘‰ , ğ´) modeling a road network. Arcs (ğ‘–, ğ‘—) âˆˆ ğ´ represent road segments and are tagged with two positive weights ğ‘‘ğ‘–ğ‘— and ğ‘¡ğ‘–ğ‘— . We define a path ğ‘ƒ in ğº as an ordered list of nodes
ğ‘ƒ = (ğ‘¢0 , ğ‘¢1 , ..., ğ‘¢ğ‘ ) such that (ğ‘¢ğ‘˜ , ğ‘¢ğ‘˜+1 ) âˆˆ ğ´ for ğ‘˜ âˆˆ {0, ..., ğ‘ âˆ’ 1}. The cost
vector of path ğ‘ƒ is the sum of its arc weights:
path ğ‘ƒğ‘˜ âˆˆ Pğ‘œğ‘ğ‘¡ (ğ‘¢, ğ‘£) exists such that ğ‘‘(ğ‘ƒğ‘˜ ) â‰¤ ğ‘‘(ğ‘ƒ ) and ğ‘¡(ğ‘ƒğ‘˜ ) â‰¤ ğ‘¡(ğ‘ƒ ). Con-
sequently, for each path ğ‘ƒ âˆˆ P(ğ‘¢, ğ‘£), we have ğ‘‘(ğ‘ƒ1) â‰¤ ğ‘‘(ğ‘ƒ ) and ğ‘¡(ğ‘ƒğ‘Ÿ ) â‰¤
ğ‘¡(ğ‘ƒ ).  â–¡
In the remainder of this paper, we denote by (ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘¢, ğ‘£), ğ‘¡ğ‘šğ‘ğ‘¥(ğ‘¢, ğ‘£)) the cost vector associated with the shortest path in distance in Pğ‘œğ‘ğ‘¡ (ğ‘¢, ğ‘£) and we denote by (ğ‘‘ğ‘šğ‘ğ‘¥(ğ‘¢, ğ‘£), ğ‘¡ğ‘šğ‘–ğ‘›(ğ‘¢, ğ‘£)) the cost vector associated with the shortest path in time in Pğ‘œğ‘ğ‘¡ (ğ‘¢, ğ‘£). Note that any eï¬ƒcient path ğ‘ƒ âˆˆ P(ğ‘¢, ğ‘£) is such that ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘¢, ğ‘£) â‰¤ ğ‘‘(ğ‘ƒ ) â‰¤ ğ‘‘ğ‘šğ‘ğ‘¥(ğ‘¢, ğ‘£) and ğ‘¡ğ‘šğ‘–ğ‘›(ğ‘¢, ğ‘£) â‰¤ ğ‘¡(ğ‘ƒ ) â‰¤ ğ‘¡ğ‘šğ‘ğ‘¥(ğ‘¢, ğ‘£).

Solution algorithm

(ğ‘‘(ğ‘ƒ ), ğ‘¡(ğ‘ƒ )) =
(
âˆ‘
ğ‘˜âˆˆ{0,...,ğ‘âˆ’1}
ğ‘‘ğ‘¢ğ‘˜ ğ‘¢ğ‘˜+1
âˆ‘
,
ğ‘˜âˆˆ{0,...,ğ‘âˆ’1}
)
ğ‘¡ğ‘¢ğ‘˜ ğ‘¢ğ‘˜+1
The core mechanism of our solution algorithm is similar to the label setting algorithm proposed, first, by Martins (1984b) which is, in turn, based on Dijkstraâ€™s algorithm (Dijkstra, 1959). It essentially follows a



one-to-all solution framework, with the difference that, in our adapta- tion, we are only interested in the eï¬ƒcient paths arriving to nodes in
ğ‘‡ and we guide the search towards this direction. To solve the Steiner
BSPP, this algorithm is repeated several times, once for each terminal
defined as a starting point
In what follows, the starting node is named ğ‘£0. A label represents a path ğ‘ƒ from ğ‘£0 to a certain node ğ‘¢ âˆˆ ğ‘‰ and is defined with the following
information:
ğ¿ = (ğ‘™ğ‘ğ‘ ğ‘¡(ğ¿), ğ‘‘(ğ¿), ğ‘¡(ğ¿), ğ‘“ğ‘ğ‘¡â„ğ‘’ğ‘Ÿ(ğ¿))
where ğ‘™ğ‘ğ‘ ğ‘¡(ğ¿) = ğ‘¢, ğ‘‘(ğ¿) = ğ‘‘(ğ‘ƒ ), ğ‘¡(ğ¿) = ğ‘¡(ğ‘ƒ ) and ğ‘“ğ‘ğ‘¡â„ğ‘’ğ‘Ÿ(ğ¿) is the la- bel from which ğ¿ was extended (âˆ… for the initial label). Following previous definitions, we say that a label ğ¿1 dominates another label
ğ¿2 if (ğ‘‘(ğ¿1 ), ğ‘¡(ğ¿1 )) dominates (ğ‘‘(ğ¿2 ), ğ‘¡(ğ¿2 )). We say that ğ¿1 is lexico- graphically smaller than ğ¿2 , denoted by ğ¿1 < ğ¿2 , if (ğ‘‘(ğ¿1 ), ğ‘¡(ğ¿1 )) <
sociated with shortest paths in distance and, ğ‘‘ğ‘šğ‘ğ‘¥(ğ‘£0 , ğ‘£) and ğ‘¡ğ‘šğ‘–ğ‘›(ğ‘£0 , ğ‘£)
indicating distances and times associated with shortest paths in time.
Using Dijkstraâ€™s algorithms in backwards from all nodes ğ‘  âˆˆ ğ‘‡ (that
distance and in time from all nodes ğ‘£ âˆˆ ğ‘‰ to destination nodes ğ‘  âˆˆ ğ‘‡ . is, with the arcs implicitly reversed), we compute shortest paths in Four series of tables are obtained: ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘£, ğ‘ ) and ğ‘¡ğ‘šğ‘ğ‘¥(ğ‘£, ğ‘ ) indicating
distances and times associated with shortest paths in distance and,
ğ‘‘ğ‘šğ‘ğ‘¥(ğ‘£, ğ‘ ) and ğ‘¡ğ‘šğ‘–ğ‘›(ğ‘£, ğ‘ ) indicating distances and times associated with
shortest paths in time.

isons are based on the lexicographical order < . Thanks to that, we have In both forward and backward Dijkstraâ€™s algorithms, label compar-
ğ‘™ğ‘’ğ‘¥
the guarantee that all the computed paths are eï¬ƒcient.
Algorithm MDAâˆ— mainly relies on the two following structures:

ğ‘™ğ‘’ğ‘¥
ğ‘™ğ‘’ğ‘¥
Set allLabels contains all the labels that have to be extended. It is

(ğ‘‘(ğ¿2 ), ğ‘¡(ğ¿2 )); we say that the two labels are equal if (ğ‘‘(ğ¿1 ), ğ‘¡(ğ¿1 )) =
(ğ‘‘(ğ¿2), ğ‘¡(ğ¿2)), even if the father nodes can differ.
In Section 4.1, we detail the solution method. In Section 4.2, we
prove that the proposed algorithm correctly provides the expected set of eï¬ƒcient paths. We then give, in Section 4.3, more details on the data structures and report on the complexity.
The multi-destination-Aâˆ— algorithm

Algorithms 1 and 2. We call this algorithm multi-destination-Aâˆ— algo- The solution method and its preprocessing are described in rithm (MDAâˆ—). It provides a minimal complete set of eï¬ƒcient paths be- tween ğ‘£0 and ğ‘ .

Algorithm 1 Preprocessing
1: compute ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘£0 , ğ‘£), ğ‘¡ğ‘šğ‘–ğ‘›(ğ‘£0 , ğ‘£), ğ‘‘ğ‘šğ‘ğ‘¥(ğ‘£0 , ğ‘£) and ğ‘¡ğ‘šğ‘ğ‘¥(ğ‘£0 , ğ‘£) for all ğ‘£ âˆˆ ğ‘‰
2: for all ğ‘  âˆˆ ğ‘‡ do
3:	compute ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘£, ğ‘ ), ğ‘¡ğ‘šğ‘–ğ‘›(ğ‘£, ğ‘ ), ğ‘‘ğ‘šğ‘ğ‘¥(ğ‘£, ğ‘ ) and ğ‘¡ğ‘šğ‘ğ‘¥(ğ‘£, ğ‘ ) for all ğ‘£ âˆˆ ğ‘‰
4: end for



Algorithm 2 Multi-destination-Aâˆ— algorithm for the Steiner BSPP
1: ğ¿ = (ğ‘£0, 0, 0, âˆ…)
2: ğ‘ğ‘™ğ‘™ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ .ğ‘ğ‘‘ğ‘‘(ğ¿)
3: ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ [ğ‘£0].ğ‘ğ‘‘ğ‘‘(ğ¿)
4: while ğ¾(ğ‘ğ‘™ğ‘™ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ .ğ‘€ğ‘–ğ‘›()) â‰¤ ğ‘šğ‘ğ‘¥ğ¾ ğ‘šğ‘ğ‘¥ do
ğ‘ âˆˆğ‘‡
5:	ğ¿ = ğ‘ğ‘™ğ‘™ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ .ğ‘’ğ‘¥ğ‘¡ğ‘Ÿğ‘ğ‘ğ‘¡ğ‘€ğ‘–ğ‘›()
6:	ğ‘¢ = ğ‘™ğ‘ğ‘ ğ‘¡(ğ¿)
7:	for all (ğ‘¢, ğ‘£) âˆˆ ğ´ do
8:	ğ¿â€² = (ğ‘£, ğ‘‘(ğ¿) + ğ‘‘ğ‘¢ğ‘£ , ğ‘¡(ğ¿) + ğ‘¡ğ‘¢ğ‘£ , ğ¿)
9:	if ğ¿â€² is not dominated nor equal to a label in ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ [ğ‘£] then
10:	ğ‘ğ‘™ğ‘™ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ .ğ‘ğ‘‘ğ‘‘(ğ¿â€²)
11:	ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ [ğ‘£].ğ‘ğ‘‘ğ‘‘(ğ¿â€²)
12:	if a label ğ¿â€²â€² âˆˆ ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ [ğ‘£] is dominated by ğ¿â€² then
13:	ğ‘ğ‘™ğ‘™ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ .ğ‘Ÿğ‘’ğ‘šğ‘œğ‘£ğ‘’(ğ¿â€²â€²)
14:	ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ [ğ‘£].ğ‘Ÿğ‘’ğ‘šğ‘œğ‘£ğ‘’(ğ¿â€²â€²)
15:	end if
16:	end if
17:	end for
18: end while
future labels to the starting position ğ‘£0 (Lines 1â€“2). When a label used for label selection. It is initialized with a single label anchoring
with a new non-dominated cost vector is created, it is added to this set (Line 10). When a label is selected for extension or dominated, it is removed (Lines 5 and 13)
nodes ğ‘£ âˆˆ ğ‘‰ . It is used for dominance. It is initially empty for all â€¢ Vector Labels[v] contains all the eï¬ƒcient paths that are known for nodes but ğ‘£0 (Line 3). Labels with new non-dominated cost vectors
are added (Line 11), newly dominated labels are removed (Line 14).

At each iteration, a label ğ¿ is selected in allLabels (Line 5) and ex- tended to all the successors of ğ‘™ğ‘ğ‘ ğ‘¡(ğ¿) (Line 7). If new promising la-
bels are found (Line 9), the different label sets are updated as explained above.
to lead the most quickly to one of the nodes in ğ‘‡ . This is where the Label selection function extractMin() aims at finding the label apt innovation of our algorithm stands. In the standard Aâˆ— strategy, the
search is guided to a single destination. In Dijkstraâ€™s algorithm, all des- tinations are given the same priority. In order to guide the search to
a subset of primary destinations (the set ğ‘‡ of terminals), we select the
label ğ¿ = (ğ‘¢, ğ‘‘(ğ¿), ğ‘¡(ğ¿), ğ‘“ğ‘ğ‘¡â„ğ‘’ğ‘Ÿ(ğ¿)) that minimizes value:
ğ‘šğ‘–ğ‘›(ğ‘‘(ğ¿) + ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘¢, ğ‘ ) âˆ’ ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘£ , ğ‘ ))
ğ‘ âˆˆğ‘‡
We denote ğ¾(ğ¿) this value and call it the key of the label. For a given node ğ‘ , ğ‘‘(ğ¿) + ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘¢, ğ‘ ) âˆ’ ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘£0 , ğ‘ ) is the minimum detour that could be achieved when extending label ğ¿ to ğ‘ , compared to the shortest path in distance between ğ‘£0 and ğ‘ . The key thus gives the minimal value among detours to all destinations in ğ‘‡ , that is, it prioritizes labels that could
potentially lead to one of the destinations effectively. Actually, with this key, the algorithm will first explore the min-distance paths leading to
nodes in ğ‘‡ (the key is zero for these paths), then it will progressively
deviate from these paths. Note that distances computed in preprocessing
are used when computing the key.
time paths have been generated for all terminals in ğ‘‡ . Indeed, The algorithm should terminate when the labels representing min-
any label with a larger detour would necessarily be dominated by these labels: both time and distance would be larger. More for-
mally, the min-time path between ğ‘£0 and ğ‘  is given by label ğ¿ğ‘  =
(ğ‘ , ğ‘‘ğ‘šğ‘ğ‘¥(ğ‘£0 , ğ‘ ), ğ‘¡ğ‘šğ‘–ğ‘›(ğ‘£0 , ğ‘ ), ğ‘“ğ‘ğ‘¡â„ğ‘’ğ‘Ÿ(ğ¿ğ‘  )). In ğ¿ğ‘  , the detour is ğ‘‘ğ‘šğ‘ğ‘¥(ğ‘£0 , ğ‘ ) âˆ’
ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘£0 , ğ‘ ). Therefore, the stopping criterion is that the key of the selected
label is larger than maxğ‘ âˆˆğ‘‡ ğ¾ ğ‘šğ‘ğ‘¥ with ğ¾ ğ‘šğ‘ğ‘¥ = ğ‘‘ğ‘šğ‘ğ‘¥(ğ‘£0 , ğ‘ ) âˆ’ ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘£0 , ğ‘ ).

ğ‘ 	ğ‘ 

19: Compute path set Pğ‘œğ‘ğ‘¡ (ğ‘£0 , ğ‘ ) from all labels in ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ [ğ‘ ], for all ğ‘  âˆˆ ğ‘‡
20: return Pğ‘œğ‘ğ‘¡ (ğ‘£0 , ğ‘ ) for all ğ‘  âˆˆ ğ‘‡

The preprocessing is important to implement the Aâˆ— mechanism. It works as follows:

and in time from node ğ‘£0 to all nodes ğ‘£ âˆˆ ğ‘‰ . Four tables are con- â€¢ Using Dijkstraâ€™s algorithm, we compute shortest paths in distance structed: ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘£0 , ğ‘£) and ğ‘¡ğ‘šğ‘ğ‘¥(ğ‘£0 , ğ‘£) indicating distances and times as-
The selected label is given by function Min(), which indicates the label with minimal key, i.e., the label that would be returned using function extractMin() (Line 4).

Proof of optimality

Theorem 1. Algorithm MDAâˆ— provides minimal complete sets of efficient paths from source node ğ‘£0 to all destination nodes ğ‘  âˆˆ ğ‘‡ .




eï¬ƒcient path ğ‘ƒ from the source node ğ‘£0 to a destination node ğ‘  âˆˆ ğ‘‡ such Proof. Let us assume that at the end of Algorithm 2 there exists an that (ğ‘‘(ğ‘ƒ ), ğ‘¡(ğ‘ƒ )) does not belong to the set of non-dominated vector costs
returned by the algorithm. Under this assumption, the set of eï¬ƒcient
Theorem 2. The complexity of algorithm MDAâˆ— is in ğ‘‚(ğ‘šÎ”2 ğ‘™ğ‘œğ‘”(ğ‘›Î”)).
Proof. Given a node ğ‘£ âˆˆ ğ‘‰ , a label ğ¿ arriving at node ğ‘£ has a chance to lead to an eï¬ƒcient path at one of the destination nodes ğ‘  âˆˆ ğ‘‡ if ğ‘‘(ğ¿) +
ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘£, ğ‘ ) â‰¤ ğ‘‘ğ‘šğ‘ğ‘¥(ğ‘£ , ğ‘ ). Therefore every label ğ¿ maintained at node ğ‘£ dur-

paths between ğ‘£0 and ğ‘  is incomplete. We show that it cannot happen.
Let (ğ‘¢ , ğ‘¢ , ..., ğ‘¢ ) be the sequence of nodes visited along path ğ‘ƒ with
0
ing the labeling procedure verifies ğ‘‘(ğ¿) â‰¤ ğ‘šğ‘ğ‘¥(ğ‘‘
ğ‘šğ‘ğ‘¥
(ğ‘£0, ğ‘ ) âˆ’ ğ‘‘
ğ‘šğ‘–ğ‘›
(ğ‘£, ğ‘ )).

0  1	ğ‘Ÿ
ğ‘ âˆˆğ‘‡

ğ‘¢0 = ğ‘£0 and ğ‘¢ğ‘Ÿ = ğ‘ . Let us denote by ğ‘ƒ0ğ‘– and ğ‘ƒğ‘–ğ‘  the paths respectively defined by node sequences (ğ‘¢0 , ..., ğ‘¢ğ‘– ) and (ğ‘¢ğ‘– , ..., ğ‘¢ğ‘Ÿ ) for all ğ‘– âˆˆ {0, ..., ğ‘Ÿ}. Let ğ¿ğ‘– be the label associated with path ğ‘ƒ0ğ‘– . Due to the Principle of
Optimality Martins (1984b), label ğ¿ğ‘– can never be dominated by la-
In addition, ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘£0 , ğ‘£) â‰¤ ğ‘‘(ğ¿), and, seeing that distances are assumed
the distance, the number of labels in list ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ [ğ‘£] is bounded by ğ›¿(ğ‘£). to be integer and that at most one label is kept for every value of
Equivalently, the total number of labels in heap ğ‘ğ‘™ğ‘™ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘  is bounded by

bels in ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ [ğ‘¢ğ‘– ]. Consequently, the reason why ğ‘ƒ is not found by
âˆ‘
ğ‘£âˆˆğ‘‰
ğ›¿(ğ‘£) â‰¤ ğ‘›Î”.

Algorithm 2 is that:
either the algorithm stops before ğ‘ƒ is generated, that is, there exists
ğ‘— âˆˆ {1, ..., ğ‘Ÿ âˆ’ 1} such that ğ¾ (ğ¿ğ‘— ) > ğ‘šğ‘ğ‘¥ğ¾ ğ‘šğ‘ğ‘¥;
ğ‘  âˆˆğ‘‡
The complexities of the main procedures performed during the search are as follows:
The extraction of the label with smallest key value requires
ğ‘‚(ğ‘™ğ‘œğ‘”(ğ‘›Î”)) operations;

or there exists ğ‘— âˆˆ {1, ..., ğ‘Ÿ âˆ’ 1} such that a label ğ¿ âˆˆ ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ [ğ‘¢ğ‘— ] is
equal to ğ¿ğ‘— .
In the second case, let ğ‘ƒ â€² be the path obtained from ğ¿ by extending it with path ğ‘ƒğ‘—ğ‘ . Seeing that (ğ‘‘(ğ‘ƒ â€²), ğ‘¡(ğ‘ƒ â€²)) = (ğ‘‘(ğ‘ƒ ), ğ‘¡(ğ‘ƒ )) we fall into a situation similar to that of ğ‘ƒ and, inductively, we eventually arrive to
the first case.
Without loss of generality, let us thus assume that label ğ¿ğ‘— ob-
tained from path ğ‘ƒ is such that ğ¾(ğ¿ ) > ğ‘šğ‘ğ‘¥ğ¾ ğ‘šğ‘ğ‘¥. We know that ğ‘‘(ğ‘ƒ ) =
For each new label ğ¿â€² = (ğ‘£, ğ‘‘(ğ¿â€²), ğ‘¡(ğ¿â€²), ğ‘“ğ‘ğ‘¡â„ğ‘’ğ‘Ÿ(ğ¿â€²)), the dominance
in list ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ [ğ‘£] and the removal of dominated labels from ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ [ğ‘£] check which implies the insertion of the new (non-dominated) label and from the heap ğ‘ğ‘™ğ‘™ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ , requires ğ‘‚(ğ›¿(ğ‘£)ğ‘™ğ‘œğ‘”(ğ‘›Î”)) operations.
The extension of a selected label ğ¿ = (ğ‘¢, ğ‘‘(ğ¿), ğ‘¡(ğ¿), ğ‘“ğ‘ğ‘¡â„ğ‘’ğ‘Ÿ(ğ¿))
through all outgoing arcs (ğ‘¢, ğ‘£) âˆˆ ğ´ requires ğ‘‚(âˆ‘   (1 + ğ‘™ğ‘œğ‘”(ğ‘›Î”) +
ğ›¿(ğ‘£)ğ‘™ğ‘œğ‘”(ğ‘›Î”)) operations: the first term in the sum corresponds to the
generation of the new label, the second term corresponds to the in-

ğ‘—	ğ‘ â€²âˆˆğ‘‡  ğ‘ â€²

ğ‘‘(ğ¿ğ‘— ) + ğ‘‘(ğ‘ƒğ‘—ğ‘ ). From properties 1 and 2, we also know that ğ‘‘(ğ‘ƒ ) â‰¤
ğ‘‘ğ‘šğ‘ğ‘¥(ğ‘£0 , ğ‘ ), i.e.:
ğ‘‘(ğ¿ğ‘— ) + ğ‘‘(ğ‘ƒğ‘—ğ‘ ) â‰¤ ğ‘‘ğ‘šğ‘ğ‘¥(ğ‘£0 , ğ‘ )
sertion of the new label into the heap and the third term corresponds to the dominance check.
Since every label arriving at a node ğ‘£ and that is in the

heap  is  selected  once  and  ğ‘‚(âˆ‘	(1 + ğ‘™ğ‘œğ‘”(ğ‘›Î”) + ğ›¿(ğ‘£)ğ‘™ğ‘œğ‘”(ğ‘›Î”))) â‰¤

Then,
âˆ‘	(ğ‘¢,ğ‘£)âˆˆğ´

ğ‘‚(
(ğ‘¢,ğ‘£)âˆˆğ´ ğ›¿(ğ‘£)ğ‘™ğ‘œğ‘”(ğ‘›Î”), the total complexity of the algorithm is given by:

ğ‘‘(ğ¿ğ‘— ) + ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘¢ğ‘— , ğ‘ ) â‰¤ ğ‘‘ğ‘šğ‘ğ‘¥(ğ‘£0 , ğ‘ )
complexity of MDA*

and, so,
ğ‘‘(ğ¿ ) + ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘¢ , ğ‘ ) âˆ’ ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘£ , ğ‘ ) â‰¤ ğ‘‘ğ‘šğ‘ğ‘¥(ğ‘£ , ğ‘ ) âˆ’ ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘£ , ğ‘ )
(
âˆ‘
= ğ‘‚
(
âˆ‘
ğ‘™ğ‘œğ‘”(ğ‘›Î”) +
))
âˆ‘
ğ›¿(ğ‘£)ğ‘™ğ‘œğ‘”(ğ‘›Î”)

ğ‘—	ğ‘—	0	0	0
ğ‘¢âˆˆğ‘‰ ğ¿âˆˆğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ [ğ‘¢]
ğ‘£âˆˆğ‘‰ ;(ğ‘¢,ğ‘£)âˆˆğ´

Seeing that ğ‘‘(ğ¿ ) + ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘¢ , ğ‘ ) âˆ’ ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘£ , ğ‘ ) = ğ¾(ğ¿ ) and that ğ‘‘ğ‘šğ‘ğ‘¥(ğ‘£ , ğ‘ ) âˆ’	(	âˆ‘	âˆ‘	)

ğ‘—	ğ‘—
0	ğ‘—	0

ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘£0 , ğ‘ ) = ğ¾ ğ‘šğ‘ğ‘¥, we obtain
ğ¾(ğ¿ ) â‰¤ ğ¾ ğ‘šğ‘ğ‘¥ â‰¤ ğ‘šğ‘ğ‘¥ğ¾ ğ‘šğ‘ğ‘¥
â‰¤ ğ‘‚
ğ‘›Î”ğ‘™ğ‘œğ‘”(ğ‘›Î”) +
ğ¿âˆˆğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ [ğ‘¢] (ğ‘¢,ğ‘£)âˆˆğ´
(	2	)
Î”ğ‘™ğ‘œğ‘”(ğ‘›Î”)

ğ‘—	ğ‘ 
ğ‘ â€² âˆˆğ‘‡
ğ‘ â€²
â‰¤ ğ‘‚ ğ‘›Î”ğ‘™ğ‘œğ‘”(ğ‘›Î”) + ğ‘šÎ” ğ‘™ğ‘œğ‘”(ğ‘›Î”)

which contradicts our assumption and proves that the algorithm pro- vides complete sets of eï¬ƒcient paths. In addition, these sets are minimal because the algorithm prevents from having two labels with the same vector cost attached to the same node. â–¡

Complexity analysis
We analyze the complexity of algorithm MDAâˆ— with structures
ğ‘ğ‘™ğ‘™ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘  and ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ [ğ‘£] implemented as follows:
Structure ğ‘ğ‘™ğ‘™ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘  is a heap; it embeds the following methods:
ğ‘€ğ‘–ğ‘›() returns the label ğ¿ at the top of the heap, i.e., with the smallest ğ¾(ğ¿) value; its complexity is in ğ‘‚(1);
ğ‘’ğ‘¥ğ‘¡ğ‘Ÿğ‘ğ‘ğ‘¡ğ‘€ğ‘–ğ‘›() extracts the label ğ¿ at the top of the heap; its com- plexity is in ğ‘‚(ğ‘™ğ‘œğ‘”(|ğ‘ğ‘™ğ‘™ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ |));
ğ‘ğ‘‘ğ‘‘(ğ¿) inserts label ğ¿ into ğ‘ğ‘™ğ‘™ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ ; its complexity is in
ğ‘‚(ğ‘™ğ‘œğ‘”(|ğ‘ğ‘™ğ‘™ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ |));
ğ‘Ÿğ‘’ğ‘šğ‘œğ‘£ğ‘’(ğ¿) removes label ğ¿ from ğ‘ğ‘™ğ‘™ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ . its complexity is in
ğ‘‚(|ğ‘ğ‘™ğ‘™ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ |).
Structure ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ [ğ‘£] is a chained list for each ğ‘£ âˆˆ ğ‘‰ ; it gives access to
the following methods:
ğ‘ğ‘‘ğ‘‘(ğ¿) adds label ğ¿ to ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ [ğ‘£]; the complexity is in ğ‘‚(1);
ğ‘Ÿğ‘’ğ‘šğ‘œğ‘£ğ‘’(ğ¿) removes label ğ¿ from the list; it is performed in
ğ‘‚(|ğ¿ğ‘ğ‘ğ‘’ğ‘™ğ‘ [ğ‘£]|).
Without loss of generality, we assume that data are integer. If it is not the case, data can be multiplied by a power of ten. Let us introduce
â‰¤ ğ‘‚(ğ‘šÎ”2 ğ‘™ğ‘œğ‘”(ğ‘›Î”))
â–¡

Steiner BSPP with time windows

As already explained, this work is motivated by the computation of multigraph data in the context of vehicle routing problems. When two attributes (e.g., time and distance) are present, it generally implies addi- tional constraints on routes. For example, in the VRPTW, time windows limit customer visit times. These constraints can be exploited in the com- putation, as we now show for the VRPTW.
Let ğ‘’ğ‘  and ğ‘™ğ‘  denote respectively the earliest starting service time and
the latest starting service time for a terminal ğ‘  âˆˆ ğ‘‡ . It is not allowed to reach customer ğ‘  after time ğ‘™ğ‘  ; arriving before ğ‘’ğ‘  is possible but implies waiting for the opening time ğ‘’ğ‘  . For the depot, this window corresponds
ing time. A path ğ‘ƒ between two terminals ğ‘¢ and ğ‘£ is feasible with respect to the time horizon: starting time from the depot, latest allowed return- to time windows if and only if ğ‘’ğ‘¢ + ğ‘¡(ğ‘ƒ ) â‰¤ ğ‘™ğ‘£ . Therefore, sets of eï¬ƒcient
paths can be limited to paths satisfying this condition.
node ğ‘£0 âˆˆ ğ‘‡ . We denote by ğ‘‡ +(ğ‘£0 ) the subset of terminals reachable from We consider the computation of eï¬ƒcient paths starting from a given
ğ‘£0 within their time windows: ğ‘‡ +(ğ‘£0 ) = {ğ‘  âˆˆ ğ‘‡ âˆ¶ ğ‘’ğ‘£0 + ğ‘¡ğ‘šğ‘–ğ‘›(ğ‘£0 , ğ‘ ) â‰¤ ğ‘™ğ‘  } âŠ‚
ğ‘‡ . Only destination nodes in ğ‘‡ +(ğ‘£0) should be considered during the
search procedure. To do this, we propose the following enhancements:
The key of a label ğ¿ = (ğ‘¢, ğ‘‘(ğ¿), ğ‘¡(ğ¿), ğ‘“ğ‘ğ‘¡â„ğ‘’ğ‘Ÿ(ğ¿)) is evaluated regarding

ğ›¿(ğ‘£) = ğ‘šğ‘ğ‘¥(ğ‘‘ğ‘šğ‘ğ‘¥(ğ‘£0 , ğ‘ ) âˆ’ ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘£0 , ğ‘£) âˆ’ ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘£, ğ‘ )) for every node ğ‘£ âˆˆ ğ‘‰ , and
only reachable destination nodes: ğ¾(ğ¿) =  ğ‘šğ‘–ğ‘›
(ğ‘‘(ğ¿) + ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘¢, ğ‘ ) âˆ’

ğ‘ âˆˆğ‘‡
let Î” = ğ‘šğ‘ğ‘¥(ğ›¿(ğ‘£)).
ğ‘£âˆˆğ‘‰
ğ‘‘ğ‘šğ‘–ğ‘›(ğ‘£0 , ğ‘ ));
ğ‘ âˆˆğ‘‡ + (ğ‘£0 )

Road network characteristics.


outgoing arcs
Number of instances for each road network.

number of terminals




The  algorithm  should  terminate  once  labels  ğ¿ğ‘  = (ğ‘ , ğ‘‘ğ‘šğ‘ğ‘¥(ğ‘£0, ğ‘ ), ğ‘¡ğ‘šğ‘–ğ‘›(ğ‘£0, ğ‘ ), ğ‘“ğ‘ğ‘¡â„ğ‘’ğ‘Ÿ(ğ¿ğ‘ ))  have  been  generated  for destination nodes ğ‘  âˆˆ ğ‘‡ +(ğ‘£0). Thus, the stopping criterion is that
nodes ğ‘› and the number of arcs ğ‘š, respectively. The last two columns
give the minimum and the maximum number of outgoing arcs over all
nodes in the road network.

the selected label key is larger than  ğ‘šğ‘ğ‘¥
ğ¾ğ‘šğ‘ğ‘¥;
From each road network, we generated 50 instances by randomly

ğ‘ âˆˆğ‘‡ +(ğ‘£0 ) ğ‘ 
path should be considered. Every node ğ‘¢ such that ğ‘’ğ‘£0 + ğ‘¡ğ‘šğ‘–ğ‘›(ğ‘£0, ğ‘¢) + 3. Only nodes that are apt to lead to a destination node with a feasible
ğ‘¡ğ‘šğ‘–ğ‘›(ğ‘¢, ğ‘ ) > ğ‘™ğ‘  for all destination nodes ğ‘  âˆˆ ğ‘‡ +(ğ‘£0) is discarded from
graph ğº.
Due to the first enhancement, label keys increase more quickly dur- ing the labeling procedure. The second enhancement tightens the stop- ping condition. Combined with the first enhancement, it limits the num- ber of labels generated during the search. The third enhancement is per- formed in preprocessing and permits reducing the size of the graph.

Computational experiments

In this section, we present the computational experiments carried out to evaluate the eï¬ƒciency of the proposed solution method. First, we present the benchmark problems used in the experiments. Then, we re- port the computational results and we analyse the impact of considering the time windows on the algorithm performance.
All algorithms are implemented in the C++ programming language and tests are run on an Intel Xeon(R) CPU E5-2620v2 2.1 GHz computer with 32GB of memory.

Test problems

Since we are interested in computing paths for transportation prob- lems, we conducted our computational experiments on the basis of two series of real-world road networks:
Two road networks (AIX-1 and AIX-2) were constructed based on spatial data from the city of Aix-en-Provence1 in France provided by OpenStreetMapâ‹‡c 2 database. Each road segment is defined by a length, a maximum allowed speed and a travel direction. Travel times were then computed using speeds and lengths.
Four road networks (DC, DE, RI and AK) were extracted by Schultes (2005) from US Census3 and correspond to Washington D.C., Delaware, Rhode Island and Alaska, in the United States, respec- tively. In these networks, each road segment is given with a distance and a travel time. Note that, the road networks in the original data are undirected and we converted them into directed networks by duplicating all arcs.
Table 1 reports the main characteristics of these 6 road networks. For each road network, the first two columns indicate the number of

1 Aix-en-Provence is a city-commune in the region of Provence-Alpes-Cote dâ€™Azur in the south of France, about 30 km north of Marseilles
2 OpenStreetMap is a collaborative project wich creates and distributes freely
available geospatial data. www.openstreetmap.org/
3 US Census 2000 TIGER/Line Files. U.S. Census Bureau, Washing- ton, DC, Geography Division. http://www.census.gov/geo/www/tiger/ tigerua/uatgr2k.html
selecting terminals among the network nodes. We considered different terminal set sizes and two different configurations:
Random: terminals are randomly drawn on the whole road network graph.
Centered: all terminals but one are randomly selected in the center of the network (a fourth of the area covered by the network, centered). The remaining terminal is randomly selected near the south-west corner of the network. It represents the standard situation of urban deliveries from a distant depot.

each value of ğ‘›ğ‘‡ . For each configuration, 10 instances are generated: 5 Table 2 details the number of instances for each road network and for
random instances and 5 centered instances. It amounts to a total of 300 instances.

Computational results

its results to those of three state-of-the-art algorithms: Aâˆ—, LSET and In order to evaluate the performance of our algorithm, we compare
LCOR.
Aâˆ— follows the classical guided-search mechanism. The core algo-
origin to a single destination. Contrary to MDAâˆ—, the key of a label is rithm solves the bi-objective shortest path problem from a single
given by the minimal distance to reach the destination. It is repeated for all pairs of terminals.
LSET is a one-to-all label setting algorithm. The search is not guided. At each iteration, the minimum label according to the lexicographic
order is selected. The stopping criterion defined for MDAâˆ— is used.
The algorithm is repeated for all possible origin points in ğ‘‡ .
LCOR is a one-to-all label correcting algorithm. The search is not
guided either. At each iteration, a node is selected and the labels associated with this node are extended to successor nodes. Nodes
repeated  for  all  possible  origin  points  in  ğ‘‡ . reenter the queue when their label list is modified. The algorithm is
For each instance, MDAâˆ— is also applied ğ‘›ğ‘‡ times, once for each node in ğ‘‡ selected as the source node, so that complete sets of eï¬ƒcient paths
are obtained between all pairs of terminals.
Results for random instances are presented in Tables 3, 5, 7, 9, 11 and 13, for road networks AIX-1, AIX-2, DC, DE, RI and AK, respectively. Re- sults for centered instances are presented in Tables 4, 6, 8,10, 12 and 14, for road networks AIX-1, AIX-2, DC, DE, RI and AK, respectively.
Columns â€œMDAâˆ—â€, â€œAâˆ—â€, â€œLSETâ€ and â€œLCORâ€ report total computing
times (in seconds) for the four algorithms. The average number of eï¬ƒ-
cient paths between pairs of terminals is presented in column â€œ#pâ€.
A first observation in these tables is that, apart from a few exceptions, results are homogeneous among the 5 instance replications for a given
value ğ‘›ğ‘‡ and a given configuration (random or centered).
Comparing MDAâˆ— and Aâˆ—, the latter is consistently beaten. Aâˆ— is only competitive for small values of ğ‘›ğ‘‡ , when the number of executions of

Computing times for AIX-1 - Random.	Computing times for AIX-2 - Random.


Computing times for AIX-1 - Centered.
ğ‘›ğ‘‡	MDAâˆ—	Aâˆ—	LSET	LCOR	#p

























the one-to-one core algorithm remains limited. Clearly, the advantage
of ğ‘›ğ‘‡ increases and reaches values that are practically meaningful in the of driving the search to a single direction is quickly lost when the size
context of vehicle routing.
Similarly, except for a few exceptions, LSET is more eï¬ƒcient than
of the analysis we focus on MDAâˆ— and LSET. Except for the smaller graph LCOR, sometimes very significantly. For that reason, in the remainder (AIX-1), MDAâˆ— is always many times faster than LSET, often up to 10 times. Not surprisingly, MDAâˆ— is specially interesting when ğ‘›ğ‘‡ is small.
In this case indeed, being able to limit the search to some promising directions really makes a difference, compared to an algorithm that in-
smaller ğ‘›ğ‘‡ , the larger the benefits achieved with MDAâˆ—. differently explores all directions. Globally, the larger the graph and the
Result tables for Centered instances even strengthen these observa- tions. Let us recall that this setting is particularly relevant in practice, as it typically corresponds to the situation encountered by urban logis-
customers is indeed particularly beneficial for MDAâˆ—. When the source tics providers. Having a distant depot (south-west corner) with centered node (ğ‘£0) is the depot, all destination nodes are clustered and the search
is very eï¬ƒciently guided. When the source node is any other terminal, all destination nodes but one are close; the best paths to these nodes
also eï¬ƒciently computed thanks to the Aâˆ— mechanism. On the contrary, can eï¬ƒciently be found; the best paths to the last node (the depot) are
LSET always needs to compute best paths to a large part of the network before being able to stop the search.
Tables 3 to 14 also give interesting insights on the size of complete
this value only slightly depends on value ğ‘›ğ‘‡ , as could be expected, but sets of eï¬ƒcient paths in the different networks. For a given network,

Computing times for DC - Random.	Computing times for DE - Random.



Table 8
Computing times for DC - Centered.
Table 10
Computing times for DE - Centered.




is different for the Random and Centered configurations. In the Cen- tered configuration, the average distance between terminals is smaller and one could expect a more limited number of eï¬ƒcient paths. This is confirmed by experiments, but, surprisingly, the reduction factor is ex- tremely dependent on the network (almost null for DC, very large for DE or AK). Anyway, one can see that the average size of eï¬ƒcient sets approximately varies between 3 and 40, which can be interpreted in two different manners. On the one hand, it remains very limited compared to the theoretical exponential-size that these sets could have. On the other hand, time and distance are strongly correlated and it is generally ad- mitted that the longer the distance, the longer the traveling time. Values of #p show that it is not completely true and that the number of eï¬ƒ- cient paths between two terminals in a road-network can be relatively important.
Results in the context of the VRPTW

We now evaluate the impact of the enhancements proposed in Section 5 when time windows are introduced. For the sake of brevity, we limit our experiments to the 25 AIX-2 instances and the 25 DC instances, with nodes randomly drawn. Time windows are added as follows:
A node, denoted ğ‘ 0, is randomly selected in ğ‘‡ to represent the depot;
other terminals represent customers.
The depot time window [0, ğ‘™0] defines the time horizon and is set such that every node in ğ‘‡ â§µ {ğ‘ 0} can be visited on a back-and-forth
route.
A feasible VRP solution is then constructed with a simple greedy algorithm.



Table 11
Computing times for RI - Random.
ğ‘›ğ‘‡	MDAâˆ—	Aâˆ—	LSET	LCOR	#p

Table 13
Computing times for AK - Random.


Table 12
Computing times for RI - Centered.
ğ‘›ğ‘‡	MDAâˆ—	Aâˆ—	LSET	LCOR	#p

26	1	148.7	660.6	1996.1	12324.5	27.0



Table 14
Computing times for AK - Centered.

2	111.9	409.1	1699.6	11821.7	29.4
3	87.9	218.8	1464.7	7863.0	18.6
ğ‘›ğ‘‡
MDAâˆ—	Aâˆ—	LSET	LCOR	#p






















Finally, time windows [ğ‘’ğ‘ , ğ‘™ğ‘ ] are defined for all customers ğ‘  âˆˆ ğ‘‡ â§µ
{ğ‘ 0}, centered on the visit time in the greedy solution and with a
width equal to ğ‘™0 (truncated to make sure that ğ‘’ â‰¥ 0 and ğ‘™ â‰¤ ğ‘™ ).
ğ‘ 	0

â€œ|ğ‘‡ +(ğ‘£0)|â€ reports the average number of reachable destinations; Col- Results are presented in Tables 15 and 16. In these tables, Column
umn â€œ# removedâ€ indicates the average number of nodes that could be removed. Column â€œCPU %â€ indicates the average impact on computing time (in %), including preprocessing. Column â€œ#pâ€ indicates the average impact on the number of eï¬ƒcient paths found between two terminals (in %). Note that this gap is not null because it compares the number of paths with or without time windows.
ber of considered destinations |ğ‘‡ +(ğ‘£0)| is significantly reduced: approxi- From these tables, we notice that, with our enhancements, the num-
Table 15
Impact of enhancements on network AIX-2 - Ran- dom.




Table 16
Impact of enhancements on network DC.



mately divided by 2 on average. We also see that the number of removed nodes is relatively important. Regarding computing times, it clearly ap- pears that the algorithm is faster when the enhancements are used. Re- garding the number of paths, one can observe that the size of complete sets of eï¬ƒcient paths is divided by more than 2.
Conclusion

In this paper, we introduced and investigated the Steiner bi-objective shortest path problem. The particularity of this problem is to seek for complete set of eï¬ƒcient paths linking a subset of nodes in the net- work, the so-called terminals. We developed an exact solution approach
based on a labeling algorithm combined with a modified ğ´âˆ— algorithm.
The proposed approach is based on a goal-directed search strategy that
guides labels simultaneously towards all terminals and allows stopping the search quickly once all eï¬ƒcient paths have been found. The moti- vation for this new problem stems from the preprocessing of travel in- formation for vehicle routing problems and we proposed and evaluated several enhancements in the case of the VRPTW.
Computational experiments were carried out on a large panel of in- stances based on real road networks. Results show that the proposed al-
gorithm performs very well for all tested instances. The MDAâˆ— algorithm
largely outperforms state-of-the-art algorithms. Additional savings are
obtained when taking into account time windows.
Experiments also give insights on the solution of vehicle routing problems with multigraphs. They show that multigraphs of acceptable size should be obtained and that these graphs could be computed in a reasonable amount of time for road-network graphs with dozens of thousand of nodes and hundreds of customers.
Would these computing times be considered too high in practice, several possible adaptations of our algorithms could be possible. For example, computations might be simplified a lot by only keeping the min-time and min-cost paths. Also, some heuristic rules might be intro- duced in the dynamic programming algorithm to limit the number of labels. Mono-objective shortest path problems with different weighted sums for travel time and cost could also be solved. Of course, with all these approaches, the theoretical guarantee of optimality would be lost for the subsequent vehicle routing problem.
Declaration of Competing Interests

The authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.
Acknowledgements

The first author was supported by the Labex IMobS3, by the Euro- pean Fund for Regional Development (FEDER Auvergne region) and by the Auvergne Region. The authors thank anonymous referees for their careful reading, thorough reviews and valuable comments that helped us improving the quality of the paper.
References

Bast, H., Delling, D., Goldberg, A., MÃ¼ller-Hannemann, M., Pajor, T., Sanders, P., Wag- ner, D., Werneck, R.F., 2016. Route planning in transportation networks. In: Algo- rithm Engineering. Springer, pp. 19â€“80.

Ben Ticha, H., Absi, N., Feillet, D., Quilliot, A., 2017. Empirical analysis for the VRPTW with a multigraph representation for the road network. Comput. Oper. Res. 88, 103â€“116.
Ben Ticha, H., Absi, N., Feillet, D., Quilliot, A., 2018. Vehicle routing problems with road-
-network information: State of the art. Networks 72 (3), 393â€“406.
Brumbaugh-Smith, J., Shier, D., 1989. An empirical investigation of some bicriterion short- est path algorithms. Eur. J. Oper. Res. 43 (2), 216â€“224.
ClÃ­maco, J.C., Pascoal, M., 2012. Multicriteria path and tree problems: Discussion on exact algorithms and applications. Int. Trans. Oper. Res. 19 (1-2), 63â€“98.
Climaco, J.C.N., Martins, E.Q.V., 1982. A bicriterion shortest path algorithm. Eur. J. Oper.
Res. 11 (4), 399â€“404.
CornuÃ©jols, G., Fonlupt, J., Naddef, D., 1985. The traveling salesman problem on a graph and some related integer polyhedra. Math. Program. 33 (1), 1â€“27.
Dijkstra, E.W., 1959. A note on two problems in connexion with graphs. Numerische Math- ematik 1 (1), 269â€“271.
Ehrgott, M., Gandibleux, X., 2000. A survey and annotated bibliography of multiobjective combinatorial optimization. OR-Spektrum 22 (4), 425â€“460.
Feillet, D., Dejax, P., Gendreau, M., Gueguen, C., 2004. An exact algorithm for the ele- mentary shortest path problem with resource constraints: Application to some vehicle routing problems. Networks 44 (3), 216â€“229.
Floyd, R.W., 1962. Algorithm 97: Shortest path. Commun. ACM 5 (6), 345.
Garaix, T., Artigues, C., Feillet, D., Josselin, D., 2010. Vehicle routing problems with al- ternative paths: An application to on-demand transportation. Eur. J. Oper. Res. 204 (1), 62â€“75.
Ghoseiri, K., Nadjari, B., 2010. An ant colony optimization algorithm for the bi-objective shortest path problem. Appl. Soft Comput. 10 (4), 1237â€“1246.
Guerriero, F., Musmanno, R., 2001. Label correcting methods to solve multicriteria short- est path problems. J. Optim. Theory Appl. 111 (3), 589â€“613.
Hansen, P., 1980. Bicriterion path problems. In: Multiple Criteria Decision Making Theory and Application. Springer, pp. 109â€“127.
Hart, P.E., Nilsson, N.J., Raphael, B., 1968. A formal basis for the heuristic determination of minimum cost paths. IEEE Trans. Syst. Sci. Cybern. 4 (2), 100â€“107.
Huang, Y., Zhao, L., Van Woensel, T., Gross, J.-P., 2017. Time-dependent vehicle routing problem with path flexibility. Transportation Research Part B: Methodological 95, 169â€“195.
Huarng, F., Pulat, P., Shih, L., 1996. A computational comparison of some bicriterion shortest path algorithms. J. Chin. Inst. Ind. Eng. 13 (2), 121â€“125.
Irnich, S., Desaulniers, G., 2005. Shortest path problems with resource constraints. In: Column Generation. Springer, pp. 33â€“65.
Lai, D.S., Demirag, O.C., Leung, J.M., 2016. A tabu search heuristic for the heterogeneous vehicle routing problem on a multigraph. Transp. Res. Part E: Logist. Transp. Rev. 86, 32â€“52.
Letchford, A.N., Nasiri, S.D., Oukil, A., 2014. Pricing routines for vehicle routing with time windows on road networks. Comput. Oper. Res. 51, 331â€“337.
Letchford, A.N., Nasiri, S.D., Theis, D.O., 2013. Compact formulations of the Steiner trav- eling salesman problem and related problems. Eur. J. Oper. Res. 228 (1), 83â€“92.
Mandow, L., PÃ©rez de la Cruz, J.L., 2009. A memory-eï¬ƒcient search strategy for mul- tiobjective shortest path problems. In: Annual Conference on Artificial Intelligence. Springer, pp. 25â€“32.
Mandow, L., PÃ©rez de la Cruz, J.L., 2010. Multiobjective Aâˆ— search with consistent heuris-
tics. J. ACM (JACM) 57 (5), 27.
Martins, E.Q.V., 1984. An algorithm for ranking paths that may contain cycles. Eur. J. Oper. Res. 18 (1), 123â€“130.
Martins, E.Q.V., 1984. On a multicriteria shortest path problem. Eur. J. Oper. Res. 16 (2), 236â€“245.
Martins, E. Q. V., Santos, J., 1999. The labeling algorithm for the multiobjective short- est path problem. Departamento de Matematica, Universidade de Coimbra, Portugal, Tech. Rep. TR-99/005.
Mote, J., Murthy, I., Olson, D.L., 1991. A parametric approach to solving bicriterion short- est path problems. Eur. J. Oper. Res. 53 (1), 81â€“92.
MÃ¼ller-Hannemann, M., Weihe, K., 2006. On the cardinality of the Pareto set in bicriteria shortest path problems. Ann. Oper. Res. 147 (1), 269â€“286.
PaixÃ£o, J.M., Santos, J.L., 2013. Labeling methods for the general case of the multi-ob- jective shortest path problemâ€“a computational study. In: Computational Intelligence and Decision Making. Springer, pp. 489â€“502.
Pangilinan, J.M.A., Janssens, G.K., 2007. Evolutionary algorithms for the multiobjective shortest path problem. World Acad. Sci. Eng. Technol. Int. J. Math. Comput. Phys. Electr. Comput. Eng. 1 (1), 7â€“12.
Raith, A., Ehrgott, M., 2009. A comparison of solution strategies for biobjective shortest path problems. Compute. Oper. Res. 36 (4), 1299â€“1331.
Schultes, D., 2005. Tiger road networks for 9th DIMACS implementation challengeâ€“ shortest path. http://users.diag.uniroma1.it/challenge9/data/tiger.
Serafini, P., 1987. Some considerations about computational complexity for multi ob- jective combinatorial problems. In: Recent Advances and Historical Development of Vector Optimization. Springer, pp. 222â€“232.
Skriver, A.J., 2000. A classification of bicriterion shortest path (BSP) algorithms. Asia Pac.
J. Oper. Res. 17 (2), 199â€“212.
Stewart, B.S., White III, C.C., 1991. Multiobjective Aâˆ—. J. ACM (JACM) 38 (4), 775â€“814.
Tung, C.T., Chew, K.L., 1992. A multicriteria Pareto-optimal path algorithm. Eur. J. Oper.
Res. 62 (2), 203â€“209.
