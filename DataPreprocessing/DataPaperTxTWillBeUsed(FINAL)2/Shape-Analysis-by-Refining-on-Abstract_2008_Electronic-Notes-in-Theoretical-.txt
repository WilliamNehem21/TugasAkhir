	Electronic Notes in Theoretical Computer Science 207 (2008) 137–151	
www.elsevier.com/locate/entcs

Shape Analysis by Refining on Abstract Evaluation Path 1
Xiaodong Ma	Ji Wang	Wei Dong
{xd.ma, wj}@nudt.edu.cn	dong.wei@263.net
National Laboratory for Parallel and Distributed Processing, P. R. China

Abstract
This paper presents a novel method for shape analysis, which can deal with complex expressions in C language. It supports taking addresses of fields and stack variables. The concept of abstract evaluation path (AEP) is proposed, which is generated from the expression in the language. AEP is used to refine the abstract shape graph (ASG) to get a set of more precise ASGs, on which the semantics of the statement can be defined easily. The results can be used to determine “shape invariants” and detect memory leak
conservatively. A prototype has been implemented and the results of the experiment are shown.
Keywords: shape analysis, memory leak, AEP

Introduction
Shape analysis algorithms statically analyze a program to determine information about the heap-allocated data structures that the program manipulates. It is an important methods used to understand or verify programs [7,8,9,10,11,12,13,14]. Abstraction is needed if we want to do shape analysis efficiently. There are many abstraction methods, such as k-limited heap abstraction [8], shape graph and refer- ence counts [11], 3-valued logic abstraction [12].
Shape analysis can also be used to detect Memory leak. Memory leak is one of the most common errors in programs written in languages with pointers. Occurring in large, memory intensive, long-time running programs, it can exhaust the available memory and cause the programs to fail. Many models and methods are proposed to detect memory errors. In [1,2,3,4,5] an ownership model is used to detect memory errors. Hackett et al [6] uses region based method to detect memory errors. Escape

1 This work is supported by National Natural Science Foundation of China(60673118 and 90612009), Na- tional 863 project of China(2006AA01Z429), National Basic Research Program of China(973) under Grant 2005CB321802 and Program for New Century Excellent Talents in University under grant No. NCET-04- 0996

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.090

analysis is used in [16] to detect memory leaks. Dor et al [15] defines cleanness conditions to check memory leaks by pointer shape analysis.
Complex expressions–where all the operators, including &, * and →, may occur– make shape analysis more difficult. Based on the work of [12], we present a shape analysis algorithm which can deal with many kinds of complex expressions. We have implemented the algorithm and used it to detect memory leak errors in some typical but complex, pointer intensive programs.
The difficulty in dealing with complex expressions lies in the fact that the value of a complex expression cannot be easily defined in the abstract shape graph (ASG). We can get the value of a basic type datum, such as an integer, by accessing the cor- responding memory. However, if we want to know the value of a pointer expression, we must access several memories along a path. In this paper, we proposed abstract evaluation path (AEP) to deal with this problem. AEP is an abstract access path of the expression. It denotes how the l-(r-)value of an expression can be defined. In other words, it shows all the possible access paths along which the value of an expression can be defined in an ASG. we call these paths evaluation paths. AEP can be used to refine the ASG to make the defining of the value of an expression easily.
Using AEP, we can deal with most expressions in programming languages like
C. We take a more aggressive materialization strategy in doing shape analysis. By supporting taking addresses of fields and stack variables, our method allows pointers into the middle of structures, not just the beginning of structures. Our method is also conservative, which means it may generate more shape graphs than the program really generates.
Outline. The rest of the paper is organized as follows. Section 2 gives the definition of concrete shape graph(CSG). Section 3 defines AEP and shows our algorithms of refining ASGs based on AEP. In Section 4, we give the abstract se- mantics of the statements on ASGs. Section 5 shows the results of our experiments. Section 6 lists some related work and gives the conclusion of our work.

Concrete Shape Graph
A shape graph is a directed graph which consists of a set of nodes and edges. It is used to represent memory structures and the connectivity between them. It is different from ordinary directed graph since it may have many types of nodes, which are used to represent different data structures.
We classify the data types in C into two main kinds: the basic type and the composite type. The basic type includes all the basic data types in C programs,
e.g. integer, float, pointer; the composite type consists of structures which may have multiple fields. A node in a CSG may have several cells, each cell’s name is in the form of NName.FName, where NName is the name of the node and FName is
the name of the field. The node of a basic type datum has just one cell, whose name is NName.bas, where bas denotes the basic and only field of the node. The node of a composite type datum has several cells, one for each field, plus an additional one

x
struct node{
node *n; int d;
}
struct node *x, **y; (1)


x y





(3)

*y = NULL;

lapath(*y) = y.bas->AC; (4)


x	x

y	y

(5)	(6)

Fig. 1. (1): data structure definition. (2): a concrete shape graph. (3): the abstract shape graph of (2) where dashed lines denote the value of the corresponding edge predicate is 1/2. (4): assignment statement and the lapath of it’s left hand side. (5): the shape graph of (3) after split of node t on lapath(∗y). (6): the shape graph of (5) after cut operation.

whose name is NName.bas, which is not a field of the datum but denotes the basic address of the structure. We call the node memory location and the field memory cell. All the memory cells within the same node have the same NName. A cell expression is an expression whose value is a memory cell. Figure 1.(2) is a simple CSG whose data structures are defined in Fig.1.(1). x is a pointer of structure node and y points to pointer. In Fig.1.(2) y points into a field of structure node. Others subgraphs of Fig.1 will be explained later.
A CSG consists of a set of nodes and a set of predicates. The predicates used in this paper are listed in the following.
xi(v): xi is the name of some variable, xi(v) = 1 if and only if node v denotes the memory location which stores the value of xi, i.e. v is the l-value of xi.
rcell(v): cell is the basic cell of a pointer variable or the pointer field cell of a structure variable. It denotes the reachability of memory location v from cell. If rcell(v) = 1, then there is a path from cell to any memory cell of node v, which may have multiple memory cells.
typei(v): we use an integer to denote a structure type. Different memory loca- tions may have different structures. typei(v) = 1 if and only if memory location v belongs to type i. All the basic data types are classified into one type and different structures are classified into different types.
shared(v): it denotes whether the basic cell of the memory location v is the target of two or more edges.
unique(v): it is only used in the definition of ASG. In order to make the nodes in the shape graph finite, some node in the ASG may denote a set of concrete nodes. For concrete shape graphs, for all addresses, v, unique(v) = 1.
edge(cell0, cell1): it is true if and only if there is an edge from cell0 to cell1.

In Fig.1.(2), if we encode int type as 0 and node type as 1, then we can get:  y(s) = 1, rs.bas(u) = 1, type1(u) = 1, shared(u) = 0, unique(u) = 1 and
edge(u.n, v.bas) = 1.
Definition 2.1 [CSG] A CSG is a four tuple: GC = (VC, edge, Type, Map) where:
VC is the set of nodes in the graph and there are two special nodes: null and value. null is the null memory in C language and value denotes all the possible values of the non-pointer basic type data in C language.
For every cell0, there is at most one memory cell1 which satisfies edge(cell0, cell1)
= 1.
Type is a set of predicates typei. For each node v, there is one and only one predicate typei which satisfies typei(v) = 1.
M ap consists of all the predicates xi. For each predicate xi, there is one and only one node v which satisfies xi(v) = 1.
Using the node value, all the variables can be viewed as pointers. Figure 1.(2) is an example.
CSG can faithfully represent the memory state of C programs without unions. Every expression has l-value and right value except that it is null dereferenced or uninitialized. The semantics on CSGs is also obvious.
Refining ASG Based On AEP
Abstract interpretation [20] is a good method to deal with infinite systems; it can also be used to generate finite number of ASGs from any possible infinite number of CSGs. There are two reasons which cause the program states to be infinite: first, some variables may have infinite values, e.g. integer variables, float variables; sec- ond, the memories dynamically allocated may be infinite. Since we have introduced the abstract memory location value, the infinite values are reduced to one abstract value. A set of predicates are used to classify the possible infinite memory locations into different classes. All the memory locations in the same class should have the same value for any predicate in the set. Since the number of predicates is finite, the number of classes is also finite.

Abstract Shape Graph
The predicates used to classify the memory locations, called core predicates, are among the ones listed in Section 2. The predicates used in ASG are 3-valued [19]. We also define a partial order ± on truth values to reflect information content: l0 ± l1 denotes that l0 has more definite information than l1. l0 ± l1 if l0 = l1 or l1 = 1/2. Symbol H denotes the least upper bound operation with respect to ±, such as 1 H 0 = 1/2, 0 H 1/2 = 1/2.
Definition 3.1 [ASG] An ASG is a triple: GA = (VA, pcore, pinst) where:
VA is a set of abstract nodes, including null and value.

pcore = {xi, rcell, typei}, is a set of unary predicates. There are some con- straints: first, the truth value of predicate xi must be definite and there is one and only one memory location v which satisfies xi(v) = 1; second, for any node v, the truth value of typei(v) is definite. This is the set of core predicates.
pinst = {unique, shared, edge}. unique(v) can be 1 or 1/2, but never 0.

Figure 1.(3) is an ASG of a linked list. The set of pcore predicates are {x, y, rr.bas, rs.bas, type0, type1}
An ASG GA = (VA, pcore, pinst) is minimal if and only if for any two nodes in VA, there is a predicate in pcore which can distinguish them. It can be described formally as: ∀ v1, v2 ∈ VA ∃p ∈ pcore : (p(v1) /= p(v2)). Since there are finite predicates and truth values, all the possible minimal ASGs of a given program are also finite. It can be easily seen that the predicates rcell, shared can also be evaluated in a CSG. For any node v in a CSG, unique(v) = 1.

Definition 3.2 A CSG GC = (VC, edgeC,TypeC,MapC) is embedded in an ASG GA = (VA, pcore, pinst) if there is surjective function f : VC → VA, and the following conditions are satisfied, where ACells(G) denotes all the memory cells in graph G:
For any unary predicate p except unique predicate, ∀v ∈ VC : p(v) ± p(f (v)).
If formula ∃v0, v1 ∈ VC : f (v0) = f (v1) = v' ∧ v0 /= v1 evaluates to false, then
unique(v') = 1, else unique(v') = 1/2.
There is a function g : ACells(GC) → ACells(GA) derived from f , which is: g(v.fx) = f (v).fx, where v ∈ VC and fx denotes any field of v. The only binary predicate edge satisfies: edge(c1, c2) ± edge(g(c1), g(c2)), where c1, c2 ∈ ACells(GC).

The value of expression v0 = v1 is also 3-valued. It evaluates to true if and only if v0 and v1 are the same unique node. In other words, it is equivalent to v0 = v1 ∧ unique(v0) ∧ unique(v1).
A minimal ASG GA can be generated from any shape G (whether it is a CSG or an ASG) through the following steps.
The core predicates are used to classify the nodes in G. The nodes which cannot be distinguished by the predicates in pcore are classified into one class.
For each class, there is a corresponding node in GA and GA contains no more nodes. We use a function f : V → VA to define the corresponding relation between nodes. As described in Definition 3, a function g can also be derived. The truth value of any unary predicate p except unique in GA is defined as: p(v) = H{p(ui)|f (ui) = v}; unique(v) = 1 only if formula ∃v0, v1 : f (v0) = f (v1) = v ∧ v0 /= v1 evaluates to false, else unique(v) = 1/2. edge(c' , c' ) = 
0  1
H{edge(c0, c1)|g(ci) = c',i = 0, 1}.
Figure 1.(3) is a minimal ASG and Fig.1.(2) can be embeded into it.

Algorithms of Reﬁnement
In order to make the shape graphs finite, abstraction must be used. However, some constraints in CSGs are not applicable to ASGs, e.g. one memory cell in an ASG may have several output edges (the truth value of the corresponding predicate edge is 1/2), which makes it difficult to define the semantics of the statements on ASGs. AEP is introduced to solve this problem. As described in Section 1, AEP denotes all the evaluation paths in an ASG. Based on AEP, we can refine an ASG into a set of ASGs in which an expression’s l-(r-)value can be defined as in CSGs.
An expression may have several l-(r-)values in an ASG which makes it difficult to define the semantics of the statements. Our method is called reﬁnement by AEP. Starting from a memory cell of some variable, we can go along some evaluation
paths in the ASG to get an expression’s l-(r-)value. We refine the ASG at each step along the path and the l-(r-)value of an expression is a unique node in every ASG in the result ASG set after refining. No matter how complex an expression is, an AEP can be generated from it and the semantics can be defined easily on the result ASGs after refining.
An AEP is an evaluation path where every node is an abstract node named “AL” instead of a concrete node name except the head of the path where the node name is the name of a variable, or in some cases, there is no occurrence of nodes at all, just a symbol “AC” to denote an abstract cell.
Definition 3.3 [AEP]

The left AEP is defined in the following.
lapath(const) = ⊥
lapath(null) = ⊥
lapath(x) = x.bas	x is a variable
lapath(&e) = ⊥
lapath(∗e) = π → AC	iff lapath(e) = π
lapath(e→f ) = π → (AL.bas, AL.f )	iff lapath(e) = π
(x.bas, x.f )	if lapath(e) = x.bas
lapath(e.f ) = 
⎩ π → (AL.bas, AL.f )	else, where lapath(e) = π → AC
The right AEP:
rapath(const) = value
rapath(null) = null
rapath(x) = x.bas → AC
rapath(&e) = lapath(e)
rapath(∗e) = π → AC	iff lapath(∗e) = π

rapath(e→f ) = π → AC	iff lapath(e→f ) = π
rapath(e.f ) = π → AC	iff lapath(e.f ) = π
An AEP is independent of any graph. For example,
lapath((∗x) → n)) = x.bas → AC → (AL.bas, AL.n)
rapath((∗x) → n)) = x.bas → AC → (AL.bas, AL.n) → AC
We define the semantics of statements on ASGs by transfer functions whose input is an ASG and output is a set of ASGs. In the definition of the statement’s semantics on CSGs, we can evaluate the l-(r-)value of an expression and change the current CSG to get the result CSG. This method cannot be used directly on ASGs, because a cell expression may have more than one l-(r-)value along different evaluation path. How can we deal with this problem? First, we compute the left AEP of the left expression and use it to refine the ASG and get a set of ASGs, then we use the right AEP to refine the result set of ASGs. During the refinement of an ASG, we may change the value of some edge(cellx, celly) from 1/2 to 1 on the path or create some nodes to make the l-(r-)value of a left(right) expression the cell of a unique node (whose truth value of predicate unique is 1) and all the nodes along the path unique nodes. After the two stages of the refinement, we can get a set of more precise ASGs where them both the left and the right expressions of the statement can be evaluated to unique cells. Thus, we can define the semantics of the statements on ASGs in the way as on CSGs.
The algorithm is described in Algorithm 1. There are some new functions. Every graph has a current attribute which identifies the current memory cell. Function node maps the memory cell to its node. split is used to generate a new node from a non-unique node and cut is used to delete the inconsistent edges and graphs.
Algorithm 1
function refine(GA, π)
input GA: An ASG; π: An AEP
output AnswerSet: a set of refined shape graphs
begin
W orkSet = φ
AnswerSet = {GA}
while π /= φ do
let π = w → π'; π = π'
W orkSet = AnswerSet;	AnswerSet = φ
while W orkSet /= φ do
let W orkSet = G1 ∪ W orkSet'
switch w
case ⊥:
AnswerSet = φ
return AnswerSet
case null, value:
current(G1)= w
AnswerSet = {G1}
return AnswerSet
case x.bas, (x.bas, x.f ): /*where x represents a variable*/
current(G1)= v.bas where x(v)=1 
insert G1 into AnswerSet
case AC, (AL.bas, AL.f ):
let cell0 = current(G1)
if Ecell1 : edge(G1)(cell0, cell1) > 0
current(G1)= cell1
if unique(node(cell1)) == 1
edge(G1)(cell0, cell1)=1 
AnswerSet = AnswerSet∪cut(G1)
elseif unique(node(cell1)) == 1/2

G' = G1[unique(node(cell1))/1]
1
32.	'
edge(G1)(cell0, cell1)=1 
AnswerSet = AnswerSet∪cut(G' )
AnswerSet = AnswerSet∪cut(split(G1, cell0, cell1))
endif
endif
endswitch
W orkSet = W orkSet'
endwhile
if w = (AL.bas, AL.f ) or w = (x.bas, x.f )
foreach G2 in AnswerSet
current(G2)= node(current(G2)).f
endif
endwhile
end
In the refine algorithm, we start from the variable node in an ASG and go along the AEP π. It is required that all the nodes we reach must be unique. If it does(line 29), we just step further; else we first consider it as unique(G' in line 33), and then split a new unique node from it(line 36). Every cell of a unique node has at most one output edge. We guarantee this property by generating more graphs, which is done in the cut algorithm.
The idea behind the algorithm split is simple: we just split a new unique node from a non-unique node and the new node inherits most properties of the old one. The current memory cell is transferred from the cell of the old node to the corresponding cell of the new one. Algorithm 2 shows the algorithm split. After splitting, there may be many redundant edges. We use the cut operation to delete the impossible edges and graphs.
Algorithm 2
function split(GA, cell0, cell1)
input GA: An ASG; cell0, cell1: cells of the ASG
output A result shape graph
begin
Create a unique node v1 in GA with the same typei, shared, xi and reachable property
as node(cell1)
current(GA)= v1.fx iff cell1 = node(cell1).fx
edge(GA)(cell0, current(GA))=1 
edge(GA)(cell0, cell1)=0 
foreach edge in GA where edge(cell2, cell1) > 0
edge(GA)(cell2, v1.fx)= edge(GA)(cell2, cell1)
foreach edge in GA where edge(cell1, cell3) > 0
edge(GA)(v1.fx, cell3)= edge(GA)(cell1, cell3)
return GA
end
Figure 1.(5) shows the result shape graph of Fig.1.(3) after splitting a unique node t' from node t when dealing with statement in Fig.1.(4). t' inherits all the in/out edges of t.
Due to the limit of the space, we just list the main steps of the cut algorithm.
Algorithm 3
function cut(GA)
input GA: An ASG
output AnswerSet: A set of ASGs
begin
AnswerSet = φ
if a cell of a unique node has a definite output edge, then delete all other
output edges whose truth value is 1/2
if an unshared basic cell has a definite input edge, then delete all other input edges
whose truth value is 1/2
AnswerSet = duplicate GA so every unique cell has at most one output edge
foreach G in AnswerSet
check the consistency of the reachable predicates and the shared predicates
of G and delete it from AnswerSet if there is any conflict.
return AnswerSet


end
If a unique cell has more than one output edge in graph G, then we use a graph set S to replace G. For each graph G' in S, every unique cell has at most one output edge. The total number of the graphs in S is the multiplication of the number of output edges of each unique cell. The reachable predicates are conflict in the following two conditions: (1) rcell(v) = 1, but there are no paths from the cell to v;
(2) there is a definite path (all the edges along the path have truth value of 1) from a variable cell to node v, but the corresponding reachable predicate for v has truth value of 0. The share predicates are conflict in two conditions: (1) shared(v) = 1, but there are no input edges to v.bas or just an input edge from a unique cell; (2) shared(v) = 0, but there are more than one definite input edges to v.bas.
Figure 1.(6) shows the result shape graph of Fig.1.(5) after the cut operation. We explain the disappearance of edge (r.bas, t.bas). It is clear that variable x has at most one output edge. If (r.bas, t.bas) exists, then (r.bas, t'.bas) can’t exists–which conflicts with the fact that t' is reachable from x.
Due to the fact that our cut operation is not very powerful, there is a redundant edge (t.n, t'.bas) in Fig.1.(6). It can be deleted by a more powerful cut algorithm. Since t' is reachable from r.bas, then edge(r.bas, t'.bas) must be definite true. We also know that t' is not a shared node, then we can say that (t.n, t'.bas) does not exist. We plan to improve our cut algorithm in the future.

Abstract Semantics on ASGs
Given a statement and an ASG GA, the steps needed to define the semantics are listed in the following.
step 1: use the left AEP to refine GA;
step 2: use the right AEP to refine the results of step 1 individually;
step 3: if the results of step 2 are empty, then there may be a null dereference, else the l-(r-)value of the left(right) expression is a unique memory cell and we can define the transfer function as in the concrete semantics;
step 4: for each result graph of step 3, we recompute the truth value of the predicates which have been possibly changed;
step 5: collapse the result graphs of step 4.
step 5 needs more explanations. Given two ASGs G = (V, pcore, pinst) and G' = (V ', pcore', pinst'), they are said to be isomorphic if the following conditions are satisfied:
There is a bijection f from V to V ' and for each node v in V , the type of v is the same as that of f (v), which also means that there is a bijection g from the cells in V to the cells in V '.
The truth value of each predicate on nodes or cells in G is the same as that of the predicate on the corresponding parameters generated by f or g in G'.
The collapse operation reduces each ASG into a minimal ASG and collapses the isomorphic graphs.

Table 1
Graph-Update that defining the abstract semantics of e ← malloc(i)

Our method is conservative, that is, all the possible shape graphs the program may generate are preserved in the results of the analysis.
The abstract semantics of the statement is also a transfer function. [statement]A: ASGs → ASGs. Supposing GA = (VA, pcore, pinst) is the input graph and GA = (V ' , pcore', pinst') is the output graph. After refinement, the values of all the expressions in the statement are unique cells in GA. The abstract semantics is defined as follows.
The abstract semantics of e ← malloc(i).
Assume: the unique memory cell of the l-value of expression e in GA is celll; Result: [e ← malloc(i)]A(GA) = G' . (See Table 1).
The abstract semantics of free(e).
Assume: the unique memory cell of the right value of expression e is v.bas; Result: [free(e)]A(GA) = G' . (See Table 2).
The abstract semantics of e0 ← e1.
Assume: the unique memory cell of the l-value of expression e0 is celll and that of the right value of expression e1 is cellr.  This statement is divided into two
steps: e0 ← null; e0 ← e1.  We introduce an intermediated graph G'' and the
transfer operations can be written as [e0 ← null]A(GA) = G'' . (See Table 3).
[e0 ← e1]A(G'' ) = G' . (See Table 4).
A	A
Note that the logic in the abstract semantics is 3-valued, so the logic operator is

Table 2
Graph-Update that defining the abstract semantics of free(e)

Table 3
Graph-Update that defining the abstract semantics of e0 ← null


also 3-valued. The equivalence between two memory cells is defined similar to that between two memory nodes in Section 3.1.
We lift the operations on graphs to the operations on sets of graphs in the natural way.

(1)


op(XS) = 
s∈XS
op(s)

The collecting semantics is expressed as the least fix-point of equation (2) over the variables GraphSet(n). Let FG be the control flow graph; let n be a vertex of the FG, which could be a statement or two special vertexes: start and exit; E(F G) denotes the set of edges in the control flow graph; As(F G) denotes the set of assignment statements, including malloc and free statements, and there are no

Table 4
Graph-Update that defining the abstract semantics of e0 ← e1 (after e0 ← null)

left expression in the free statement and no right expression in the malloc statement; T b(F G) and F b(F G) denote the subset of edges in FG that represent the true and false branches of some conditional statements respectively; cond(m) denotes the truth value of the condition expression at statement m.
GraphSet(n) = 
⎧⎪ φ	:	if n = start
⎪
⎪   m→n∈E(F G),m∈As(F G){collapse([st(w)]A(refine(refine(G, πl), πr)))|


(2)
⎪⎨ G ∈ GraphSet(m)}  m→n∈T b(F G){collapse(G)|G ∈ GraphSet(m) and
⎪ (cond(m) = 1 or 1/2)}  m→n∈F b(F G){collapse(G)|G ∈ GraphSet(m)
⎪
⎪⎪⎩ and (cond(m) = 0 or 1/2)}	:	otherwise
Since we generate all the possible graphs, we can detect the memory leak errors

conservatively. There are two cases in which memory leak may occur.
case 1: there is an ASG in the fix-point of vertex n which has such a node v: the truth value is false or unknown for any reachable predicate.
case 2: it is similar to case 1, the only difference is that the truth value of every reachable predicate is false.
In fact, our method can be used to determine the truth value of some conditional

Table 5
The results of the experiments



statements in some cases, such as whether an expression points to null. We can also assume all conditional expressions’ truth values are 1/2 for simplicity.


Experiments
We have implemented a prototype of the presented method and performed some experiments. The results are shown in Table 5. The first column lists the programs in our experiments. The first four programs are from [21] which operate on linked lists. The last two programs operate on trees. The fifth is from [22] and the sixth is from [23]. There are some complex expressions in the last program, such as (∗t)→right and m→left→right. The second and third columns show the memory leak error alarms corresponding to the conditions in case 1 and case 2 respectively. The fourth column shows the number of the real errors. The last column is the number of the total shape graphs in the fix-point of all the vertexes in the control flow graph.
Our experiments lead to several interesting observations. First, minimization is not always efficient. Minimization is used to make the computation of the pro- gram feasible, but it also introduces imprecision. We use collapse operation in
(2) to get the minimal ASGs at each vertex in the control flow graph. For the bintree rotate left program, since it doesn’t contain while statement, we can get the fix-point without the collapse operation and the number of ASGs is less than that with the collapse operation. The number of total graphs shown in Table 5 of the bintree rotate left program is computed without the collapse operation.
Second, different programs may need different core predicates. The core pred- icates can be different from the definition in this paper. Actually, we add shared into the core predicate set in dealing with the elem merge program and the total number of shape graphs is greatly reduced. But if we also add shared into the core predicate set in dealing with the last two programs, the total number of shape graphs will increase.
It can be proved that any real memory leak is alarmed either as case 1 error or case 2 error. From Table 5, we can see that case 2 error is more precise than case 1 error. There can also be memory leaks in case 1 but not in case 2.

Related Work
The shape-analysis problem was originally investigated by Reynolds for a Lisp-like language with no destructive updating [7]. They treated the problem as one of simplifying a collection of set equations. [8] uses a similar method, but for an imperative language supporting non-destructive manipulation of heap-allocated ob- jects, which treated the problem as solving a collection of equations using regular tree grammars. In the work of [9,10,11,17,18], they all developed shape analysis methods that associate each program point with a single shape graph, which will be less precise but more compact representations. [11] uses storage shape graphs to do abstraction. It can distinguish between the heap cells directly pointed to by variables and “summary nodes” are used for the “deeper” heap cells. Heap reference counts are used for summaries. The work most similar to ours is in [12,13]. [12] is a parametric framework for shape analysis. It provides the basis for generating different shape analysis algorithms by varying the instrumentation predicates used. This paper provides a special method which can deal with arbitrary expressions and defines the conditions of memory leak. Our split method is similar to the mate- rialization method in [13]. While their method can materialize a summary node, which can be seen as the non unique node in our method. Our split method only materializes a unique node, which makes the value of each expression a unique cell.
[15] also uses a method similar to [12] and provides the “cleanness” conditions for absence of memory errors. [6] presents an inter-procedural shape analysis algorithm for languages with destructive updates and formulates it as dataflow analysis. It is a scalable demand-driven analysis that tracks heap objects and can precisely ana- lyze some acyclic list implementations. [16] uses Boolean satisfiability to add path sensitivity to static memory leak detection. Their results demonstrate very good false-positive ratios. [1] also presents a sound method that can find memory leaks and double deletions of objects held in lists, stacks, maps and arrays. Their method is based on the concept of object ownership, which holds the exclusive right and obligation either to delete the object or to transfer the obligation.




Conclusion
In this paper, we present a shape analysis method which can deal with complex expressions. This method also allows pointers into the middle of structures. AEP is generated from arbitrary expression in C language and is used to refine the ASG. The semantics of a statement can be easily defined on the result shape graphs after the refinement. Memory error conditions can be checked on the ASGs. In the future, we plan to improve the efficiency of our method and provide more thorough experimental evaluations. We will also apply our shape analysis results to verify the correctness of programs in C language.

References
David L. Heine and Monica S. Lam. Static Detection of Leaks in Polymorphic Containers. In 28th International Conference on Software Engineering (ICSE’06), May 2006.
David L. Heine and Monica S. Lam. A Practical Flow-Sensitive and Context-Sensitive C and C++ Memory Leak detector. In ACM SIGPLAN Conference on Programming Language Design and Implementation, June 2003.
C. Boyapati, R. Lee, and M. Rinard. Ownership types for safe programming: preventing data races and deadlocks. In Proceedings of OOPSLA 2002: Object-Oriented Programming Systems, Languages and Applications, pages 211-230, November 2002
D. Clarke. An object calculus with ownership and containment. In The 8th International Workshop on Foundations of Object-Oriented Languages, January 2001.
D. Clarke and S. Drossopoulou. Ownership, encapsulation and the disjointness of type and effect. In Proceedings of OOPSLA 2002: Object-Oriented Programming Systems, Languages and Applications, pages 292-310, November 2002.
B. Hackett and R. Rugina. Region-based shape analysis with tracked locations. In The 32nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL’05), pages 310-323, January 2005.
J. C. Reynolds. Automatic computation of data set definitions. In Information Processing 68: Proceedings of the IFIP Congress, pages 456-461, New York, NY, 1968.
Neil D. Jones, Steven S. Muchnick: Flow Analysis and Optimization of Lisp-Like Structures. In S.S. Muchnick and N.D.Jones, editors, Program Flow Analysis: Theory and Applications, chapter 4, pages 102-131. Prentice-Hall, 1981.
Neil D. Jones and Steven S. Muchnick. A flexible approach to interprocedural data flow analysis and programs with recursive data structures. In ACM Symposium on Principles of Programming Languages, pages 66-74, 1982.
J. R. Larus and P. N. Hilfinger. Detecting conflicts between structure accesses. In SIGPLAN Conference on Programming Languages Design and Implementation, pages 21-34, 1988.
David R. Chase, Mark Wegman, and F. Kenneth Zadeck. Analysis of pointers and structures. In Proc. of the ACM SIGPLAN’90 conf. on Programming Language Design and Implementation, June 1990.
Mooly Sagiv, Thomas Reps and Reinhard Wilhelm. Parametric shape analysis via 3-valued logic. In
ACM Transactions on Programming Languages and Systems (TOPLAS), 2002.
Mooly Sagiv, Thomas Reps and Reinhard Wilhelm. Solving Shape-Analysis Problems in Languages with Destructive Updating. In 23rd Annual ACM SIGPLANSIGACT Symposium on Principles of Programming Languages, January 1998.
Radu Rugina. Quantitative Shape Analysis. In Proceedings of the Static Analysis Symposium, pages 228-245, August 2004
N. Dor, M. Rodeh, and S. Sagiv. Checking cleanness in linked lists. In Proceedings of the Static Analysis Symposium, pages 115-134, July 2000.
Y. Xie and A. Aiken. Context- and path-sensitive memory leak detection. In Proceedings of ESEC/FSE 2005, September 2005.
J. R. Larus. Restructuring Symbolic Programs for Concurrent Execution on Multiprocessors. PhD thesis, University of California, 1989.
J. Stransky. A lattice for abstract interpretation of dynamic (Lisp-like) structures. Information and computation, 101(1): 70-102, November 1992.
S. Kleene. Introduction to Metamathematics, Second Ed. North-Holland, Amsterdam, 1987.
P. Cousot and R. Cousot. Abstract interpretation: A unified lattice model for static analysisof programs by construction of approximation of fixed points. In Symposium on Principles of Programming Languages, ACM, New York, 238-252, 1977.
Nurit Dor. Detecting Memory Errors via Static Pointer Analysis. M.Sc. Thesis, Tel-Aviv University, 1999.
Mark Allen Weiss. Data Structures and Algorithm Analysis in C. Second Ed., chapter 4, Addison- Wesley Longman Publishing Co., Inc., 1996.
http://home.gna.org/gdsl/
