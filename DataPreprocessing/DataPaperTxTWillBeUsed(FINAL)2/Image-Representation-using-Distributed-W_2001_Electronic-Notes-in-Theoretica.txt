Electronic Notes in Theoretical Computer Science 46 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume46.html 16 pages


Image Representation using Distributed Weighted Finite Automata

Y. Sivasubramanyam 1,2 and Kamala Krithivasan 3
Department of Computer Science and Engineering Indian Institute of Technology, Madras
Chennai, India


Abstract
Weighted finite automata (WFA) define real functions, in particular, grayness func- tions of graytone images. Inference algorithm that converts an arbitrary function (graytone image) into a WFA that can regenerate it is given in [7]. In this pa- per we define the theoretical construct of Cooperating Distributed Weighted Finite Automata with n-components(n-WFA) and study the power of this construct in various modes of acceptance. We give an inference algorithm and the de-inference algorithm for the n-WFA.


Introduction
Weighted finite automata (WFA) have been introduced in [7]. They compute real functions of n-variables [6], more precisely functions [0, 1]n → R. For n = 2 such a function can be interpreted as the grayscale function of an image. For a theoretical study of WFA see [6]. In [7] an inference algorithm for the WFA is given, that for a function (image) given in table (pixel) form finds a WFA with a small number of states that approximates the given function. A recursive algorithm that infers a relatively small WFA which provides a good approximation of any given real life image has been given in [8]. [9,10] give a comprehensive treatment of WFA and their applications to image compression. Distributed computing plays a major role in this era of computing. The theory of grammar systems is a grammatical model for the distributed compu- tation. A grammar system is a set of grammars working in unison, according to a specified protocol, to generate one language. The grammar systems can be

1 The financial support from the Department of Science and Technology, India is acknowl- edged
2 Email: siva@cs.iitm.ernet.in
3 Email: kamala@iitm.ernet.in
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


either sequential(Cooperating Distributed) or parallel(Parallel Communicat- ing) in nature.A comprehensive treatment of grammar systems and a survey of the recent developments in this area can be found in [2]. The notion of sequential grammar systems was extended to automata in [1,12].
In this paper we define a new theoretical construct namely, the Coop- erating Distributed Weighted Finite Automata with n-components (n-WFA) which is a collection of weighted finite automata working sequentially to ac- cept the input string. Here the protocol followed is that of the Cooperating Distribution. We study the power of this construct in various modes of ac- ceptance. We also give an inference algorithm and the de-inference algorithm for the n-WFA and illustrate with examples how images are represented using n-WFA.
When the images are represented using n-WFA the weight matrices will be sparse and hence the amount of storage required will be small. This might give a better compression ratio. Also the inferencing and de-inferencing al- gorithm will be faster in most cases as the matrix computations involved in the inference and de-inference algorithms are much faster than in the classical case.
In Section 2 we give the preliminary definitions of the weighted finite au- tomata and its applications to digital images. In Section 3 we introduce the construct of Cooperating distributed weighted finite automata and study the acceptance power of this construct in various modes of acceptance. In this sec- tion we also deal with the representation of gray-scale images using n-WFA and give an inference algorithm and the de-inference algorithm for the n-WFA. Section 4 deals with the conclusions of this paper.

Weighted Finite Automata and Gray-Scale Images
In this section we give the basic definitions needed for this paper.
Definition 2.1 A weighted finite automaton M [10] is speciﬁed by
Q a ﬁnite set of states.
Σ a ﬁnite set of alphabets.
Wα : Q × Q −→ R for all α ∈ Σ  {ϵ}, the weights of edges labeled α.
I : Q −→ (−∞, ∞), the initial distribution.
F : Q −→ (−∞, ∞), the ﬁnal distribution.
Here Wα is an n×n matrix where n =| Q |. I is considered to be an 1 ×n row vector and F is considered to be an n×1 column vector. When representing the WFAs as figure, we follow a format similar to FSAs. Each state is represented by a node in a graph. The initial distribution and final distribution of each state is written as a tuple inside the state. A transition labeled α is drawn as a directed arc from state p to q if Wα(p, q) /= 0. The weight of the edge is written in brackets on the directed arc. The notation Iq(Fq) is used to refer

to the initial(final) distribution of state q. Wα(p, q) refers to the weight of the transition from p to q. Wα(p) refers to the pth row vector of the weight matrix Wα. It gives the weights of all the transitions from state p labeled α in a vector form. Also Wx refers to the product Wα1 · Wα2 ··· Wαk where x = α1α2 ··· αk.
Definition 2.2 A WFA is said to be deterministic if its underlying FSA is deterministic.
Definition 2.3 A WFA M deﬁnes a function f : Σ∗ −→ R, where for all
x ∈ Σ∗ and x = α1α2 ··· αk,
f (x)= I · Wα1 · Wα2 ··· Wαk · F
where the operation ’·’ is matrix multiplication.
Definition 2.4 A path P of length k is deﬁned as a tuple (q0q1 ··· qk, α1α2 ··· αk)
where qi ∈ Q, 0 ≤ i ≤ k and αi ∈ Σ, 1 ≤ i ≤ k such that αi denotes the label of the edge traversed while moving from qi−1 to qi.
Definition 2.5 The weight of a path P is deﬁned as
W (P )= Iq0 · Wα1 (q0, q1) · Wα2 (q1, q2) ··· Wαk (qk−1, qk) · Fqk
The function f : Σ∗ −→ R represented by a WFA M can be equivalently defined as follows

f (x)=	Σ
P is a path of M labeledx
W (P ), x ∈ Σ∗.

Definition 2.6 A function f : Σ∗ −→ R is said to be average preserving
if

1
f (w)= 
m
Σ f (wα)
α∈Σ

for all w ∈ Σ∗ where m =| Σ |.
Definition 2.7 A WFA M is said to be average preserving if the function that it represents is average preserving.
The general condition to check whether a WFA is average preserving is given in [10]. A WFA M is average preserving if and only if
Σ Wα · F = mF,
α∈Σ
where m =| Σ |.
Definition 2.8 A WFA is said to be i-normal [13] if the initial distribution of every state is 0 or 1 i.e. Iqi =0 or Iqi =1 for all qi ∈ Q.
Definition 2.9 A WFA is said to be f-normal [13] if the ﬁnal distribution of every state is 0 or 1 i.e. Fqi =0 or Fqi =1 for all qi ∈ Q.

Definition 2.10 A WFA is said to be I-normal if there is only one state with non-zero initial distribution.
Definition 2.11 A WFA is said to be F-normal if there is only one state with non-zero ﬁnal distribution.
Representation of Gray-Scale Images using WFA
A gray-scale digital image of finite resolution consists of 2m by 2m pixels (typically 7 ≤ m ≤ 11) each of which takes a real value (practically digitized to a value between 0 and 2m − 1, typically m = 8). By a multi-resolution image, we mean a collection of compatible 2n by 2n resolution images for n = 0, 1, ·· ·. We will assign to each pixel at 2n by 2n resolution a word of the length n over the alphabet Σ = {0, 1, 2, 3}. A word x of length less than k will address a sub-square of resolution 2k by 2k where k' < k.
Then we can define our finite resolution image as a function fI : Σk −→ R, where fI(x) gives the value of the pixel at address x. A multi-resolution image is a function fI : Σ∗ −→ R. It is shown in that for compatibility, the function fI should be average preserving i.e.
1
fI(x)= 4 [fI(x0) + fI(x1) + fI(x2) + fI(x3)].
A WFA M is said to represent a multi-resolution image if the function fM
represented by M is the same as the function fI of the image.

0,1,2,3(1/2)





3(1/2)
0,1,2,3(1)



WFA	2x2	4x4	128x128
Example 2.12 Consider the 2 state WFA shown in figure [10]. The I = (1, 0) and F = ( 1 , 1) and the weight matrices are

 1 0 
 1 1 
 1 1 
 1 1 

W0 =  2
 , W1 =  2
4  , W2 =  2
4  , and W3 =  2
2  .

			
Then we can calculate the values of pixels as follows. f (03) = sum of weights all paths labeled 03.


1	1
f (03) = 1 ·  ·  ·
2	2
1	1	1
 +1 ·  · 
2	2	2
1	1	3
· 1=  +  = 
8	4	8

similarly for f (123) we have f (123) =  1 + 1 + 1 + 1 =  9 . The images obtained
16	8	8	4	16
by this WFA are shown for resolutions 2 × 2, 4 × 4 and 128 × 128 in the above

figure.
Thus we have seen how WFAs can be used for representing gray-scale images.
Cooperating Distributed Weighted Finite Automata
Deﬁnitions
Definition 3.1 A Cooperating Distributed Weighted Finite Automata with n- components , n-WFA is a 5-tuple Γ = (Q, Σ, Wα, I,F ) where,
Q is an n-tuple (Q1, Q2, ··· , Qn) where each Qi is the set of states corre- sponding to the ith component.
Σ is the ﬁnite set of alphabet.
Wα is an n-tuple (W 1,W 2, ··· ,Wn) of weight matrices (weights of edges
α	α	α
labeled α for each α ∈ Σ ∪ {ϵ} where each
i  : Qunion × Qunion −→ R, 1 ≤ i ≤ n
I : Qunion −→ (−∞, ∞) is the initial distribution.
F : Qunion −→ (−∞, ∞) is the ﬁnal distribution. where Qunion = ∪iQi.
Each of the component WFA of the n-WFA is of the form Mi = (Qi, Σ,Wi ),
1 ≤ i ≤ n. Note that here Qi 's need not be disjoint.
Each of Wi is an m×m matrix where m =| Qunion | and these matrices are sparse matrices. I is considered to be an 1 ×m row vector and F is considered to be an m × 1 column vector. When representing the n-WFAs as a figure, we follow the format similar to that of the WFAs. The transitions from one component to another are indicated by dotted lines.
Definition 3.2 A n-WFA is said to be deterministic if each of its compo- nent WFA is deterministic.
Definition 3.3 A n-WFA M deﬁnes a function f : Σ∗ −→ R, where for all
x ∈ Σ∗ and x = α1α2 ··· αk,
f (x)= I · Wi1 · Wi2 ··· Wik · F
α1	α2	αk
where the operation ’·’ is matrix multiplication and 1 ≤ i1, i2, ik ≤ n.
The definitions of a path, weight of a path and average preserving function of n-WFA are defined in similar terms as those of a WFA.
We consider different modes of acceptance depending on the number of steps the system has to go through in each of the n-components. The different modes of acceptance are t-mode, *-mode, ≤ k-mode, ≥ k-mode, and = k- mode. Description of each of the above modes of acceptance is as follows: t-mode acceptance: The automaton which has a state with the non-zero

initial distribution begins the processing of the input string. Suppose that the system starts from the component i. In the component i the system follows

its transition function given by it’s weight matrix Wi
as any “stand alone”

WFA. The control is transfered from the component i to component j only if the system arrives at a state q /∈ Qi and q ∈ Qj. The selection of j is nondeterministic if q belongs to more than one Qj. This process is repeated and we accept the string if the system after reading the entire string reaches any one of the states which has a non-zero final state distribution. It does not matter in which component the system is in.
Definition 3.4 The instantaneous description of the n-WFA (ID) in the t- mode is given by a 3-tuple (q, w, i) where q ∈ Qunion, w ∈ Σ∗, 1 ≤ i ≤ n.
In this ID of the n-WFA, q denotes the current state of the whole system, w the portion of the input string yet to be read and i the index of the component in which the system is currently in.
The transition between the ID’s is defined as follows:
(q, aw, i) ▶ (q', w, i) iff Wi(q, q') /= 0 where q ∈ Qi, q' ∈ Qunion, a ∈
Σ ∪ {ϵ}, w ∈ Σ∗, 1 ≤ i ≤ n
(q, w, i) ▶ (q, w, j) iff q ∈ Qj − Qi
Let ▶∗ be the reflexive and transitive closure of ▶ (when we consider as a graytone picture Σ = {0, 1, 2, 3} and w is the address of a pixel).
Definition 3.5 The language accepted by the n-WFA Γ = (Q, Σ, Wα, I,F )
working in t-mode is deﬁned as follows,
	 (q0, w, i) ▶ (qf , ϵ, j) for some qf with non-zero	
Lt(Γ) = w ∈ Σ∗ ﬁnal distribution , 1 ≤ j, i ≤ n and q ∈ Q	
i
	 also fΓ(w)= weight of the string w and fΓ(w) > 0 
*-mode acceptance: The automaton which has a state with the non-zero initial distribution begins the processing of the input string. Suppose the system starts the processing from the component i. Unlike the termination mode(t-mode), here there is no restriction. The automaton can transfer the control to any other component at any time if possible, i.e, if there is some j such that q ∈ Qj then the system can transfer the control to the component
j. The selection is done nondeterministically if there is more than one j. The instantaneous description and the language accepted by the system in *-mode can be defined analogously. The language accepted in *-mode is denoted as L∗(Γ).
=k-mode( ≤ k-mode, ≥ k-mode) acceptance: The component which has a state with the non-zero initial distribution begins the processing of the input string. Suppose the system starts the processing from the component i. The system transfers the control to the other component j only after the completion of exactly k( k'(k' ≤ k), k'(k' ≥ k)) number of steps in the component i, i.e, if

there is a state q ∈ Qj then the transition from component i to the component j takes place only if the system has already completed k(k'(k' ≤ k), k'(k' ≥ k)) steps in component i. If there is more than one choice for j the selection is done nondeterministically.
The instantaneous description of n-WFA in the above three modes of derivations and the language generated by the them are defined as follows,
Definition 3.6 The instantaneous description of the n-WFA (ID) is given by a 4-tuple (q, w, i, j) where q ∈ Qunion, w ∈ Σ∗ , 1 ≤ i ≤ n, j is a non negative integer.
In this ID of the n-WFA, q denotes the current state of the whole system, w the portion of the input string yet to be read; i the index of the component in which the system is currently in, and j denotes the number of steps for which the system has been in the ith component. We accept the strings only if the n-WFA reaches a state with non-zero final distribution in some component i after reading the string and provided it has completed k steps in the component i in the case of = k-mode of acceptance (it has completed some k'(k' ≤ k) steps in the component i in the case of ≤ k-mode of acceptance or it has completed some k'(k' ≥ k) steps in the component i in the case of
≥ k-mode of acceptance). The languages accepted by the n-WFA Γ in the respective modes are denoted as L=k(Γ), L≤k(Γ) and L≥k(Γ).

Power of acceptance of different modes
Notation: The family of languages accepted by WFA is denoted by L(WFA).

Theorem 3.7 For any n-WFA Γ working in t-mode, the function deﬁned by it can be deﬁned by a single WFA.
Proof Let Γ	=	(Q, Σ, Wα, I,F ) be a n-WFA working in t-mode where
Wα  = (W 1,W 2, ··· ,Wn) and the components have states Q1, Q2, ··· , Qn.
α	α	α
Consider the WFA M  = (Q', Σ,W' , I',F') where,
Q' = {[q, i] | q ∈ Qunion, 1 ≤ i ≤ n}∪ {q' }
I' : Q' −→ (−∞, ∞) is an I-normal initial distribution such that
I'(q' ) = 1 and I'(q) = 0 for all other q ∈ Q'
F ' : Q' −→ (−∞, ∞) is such that F '(q' ) = 0
and F '([q, i]) = F (q), q ∈ Qunion, 1 ≤ i ≤ n.
' ,the weight matrices are defined as follows,
'	'	'
Wє (q0, [q0,i ]) = I(q0) such that q0 ∈ Qi'
for each qk such that Wi(qj, qk) /= 0,a ∈ Σ ∪ {ϵ}, 1 ≤ i ≤ n,
if qk ∈ Qi then W' ([qj, i], [qk, i]) = Wi(qj, qk)
a	a
if qk ∈ Qj − Qi then W' ([qj, i], [qk, j] = Wi(qj, qk)
a	a


The construction of WFA clearly shows that
L(M ) = Lt(Γ)
and so Lt(Γ) ∈ L(WF A).
Moreover for any string w = a1a2 ··· ak ∈ Σ∗ let P = (q0q1 ··· qk, a1a2 ··· ak) be a path of length k in the n-WFA Γ. The weight of this path P is W (p) =

Iq · Wi1 (q0, q1) · Wi2 (q1, q2) ··· Wik (qk−1, qk)Fq
, 1 ≤ i1, i2, ··· ik ≤ n. The path

0	a1	a2	ak	k
followed by this string w in the WFA M, is given P ' = (q' q0 ··· qk, a1a2 ··· ak)

and the weight of this path P ' is W'(p')	=	Iq'
· I[q ,i] · W'
([q0, i], [q1, i]) ·

'	'	'	'
0	0	a1

Wa2 ([q1, i], [q2, j]) ··· Wak ([qk−1,i ][qk,j ])F[qk,j']. By the above construction it
is clear that W (P ) = W'(P ') and so the function fΓ defined by the n-WFA is equal to the function fM defined by the WFA M. i.e. fΓ(w) = fM (w) for w ∈ Σ∗.

Theorem 3.8 For any n-WFA Γ working in *-mode, we have L∗(Γ) ∈ L(WFA). Also the function deﬁned by the n-WFA Γ working in ∗-mode can be deﬁned by a single WFA.
Proof Let Γ  =  (Q, Σ, Wα, I,F ) be a n-WFA working in *-mode where
Wα  = (W 1,W 2, ··· ,Wn) and the components have states Q1, Q2, ··· , Qn.
α	α	α
Consider the WFA M  = (Q', Σ,W' , I',F') where,
Q' = {[q, i] | q ∈ Qunion, 1 ≤ i ≤ n}∪ {q' }
I' : Q' −→ (−∞, ∞) isa I-normal initial distribution such that
I'(q' ) = 1 and I'(q) = 0 for all other q ∈ Q'
F ' : Q' −→ (−∞, ∞) is such that F '(q' ) = 0 and
F '([q, i]) = F (q), q ∈ Qunion, 1 ≤ i ≤ n.
' ,the weight matrices are defined as follows,
W'(q' , [q0, i]) = I(q0) such that q0 ∈ Qi, 1 ≤ i ≤ n,
є	0
for each qy such that Wi(qs, qy) /= 0,a ∈ Σ ∪ {ϵ}, 1 ≤ i ≤ n, W' ([qs, i], [qy, j] = Wi(qs, qy), 1 ≤ j ≤ n andqy ∈ Qj
a	a
The construction of the WFA clearly shows that
L(M )= L∗(Γ)
and so L∗(Γ) ∈ L(WF A).
Also for any string w ∈ Σ∗ we have fΓ(w) = fM (w) where fΓ is the function defined by the n-WFA, Γ and fM is the function defined by the WFA, M. ✷


Theorem 3.9 For any n-WFA Γ, n ≥ 1 working in = k-mode, we have
L=k(Γ) ∈ L(WF A).
The function deﬁned by the n-WFA Γ working in = k-mode can deﬁned by a single WFA.

Proof Let Γ = (Q, Σ, Wα, I,F ) be a n-WFA working in = k-mode where
Wα  = (W 1,W 2, ··· ,Wn) and the components have states Q1, Q2, ··· , Qn.
α	α	α
Consider the WFA M  = (Q', Σ,W' , I',F') where,
Q' = {[q, i, j] | q ∈ Qunion, 1 ≤ i ≤ n, 0 ≤ j ≤ k}∪ {q' }
I' : Q' −→ (−∞, ∞) isa I-normal initial distribution such that
I'(q' ) = 1 and I'(q) = 0 for all other q ∈ Q'
F ' : Q' −→ (−∞, ∞) is such that F '(q' ) = 0 and
F '([q, i, j]) = F (q) for all q ∈ Qunion, 1 ≤ i ≤ n, 0 ≤ j ≤ k
' the weight matrices are defined as follows,
'	'	'
Wє (q0, [q0,i , 0]) = I(q0) such that q0 ∈ Qi'
for each qy such that Wi(qs, qy) /= 0, qs ∈ Qi, a ∈ Σ ∪ {ϵ}, 1 ≤ i ≤
n, 0 ≤ j ≤ k
if j < k then W' ([qs, i,j − 1], [qy, i, j]) = Wi(qs, qy)
a	a
if j = k then W'([qs, i, k], [qs, j', 0]) = 1, 1 ≤ j' ≤ n and
qs ∈ Qj' .
The construction of WFA clearly shows that
L(M )= L=k(Γ)
and so L=k(Γ) ∈ L(WF A).
Also for any string w ∈ Σ∗ we have fΓ(w) = fM (w) where fΓ is the func- tion defined by the n-WFA, Γ and fM is the function defined by the WFA, M.✷

Theorem 3.10 For any n-WFA Γ in ≤ k-mode, we have L≤k(Γ) ∈ L(WF A). The function deﬁned by the n-WFA Γ working in ≤ k-mode can be deﬁned by a single WFA.
Proof Let Γ = (Q, Σ, Wα, I,F ) be a n-WFA working in ≤ k-mode where
Wα  = (W 1,W 2, ··· ,Wn) and the component states are Q1, Q2, ··· , Qn.
α	α	α
Consider the WFA M  = (Q', Σ,W' , I',F') where,
Q' = {[q, i, j] | q ∈ Qunion, 1 ≤ i ≤ n, 0 ≤ j ≤ k}∪ {q' }
I' : Q' −→ (−∞, ∞) isa I-normal initial distribution such that
I'(q' ) = 1 and I'(q) = 0 for all other q ∈ Q'
F ' : Q' −→ (−∞, ∞) such that F '(q' ) = 0 and
F '([q, i, k']) = F (q) for all q ∈ Qunion, 1 ≤ i ≤ n, 1 ≤ k' ≤ k
' the weight matrices are defined as follows,
'	'	'
Wє (q0, [q0,i , 0]) = I(q0) such that q0 ∈ Qi'
for each qy such that Wi(qs, qy) /= 0, qs ∈ Qi, a ∈ Σ ∪ {ϵ}, 1 ≤ i ≤ n,
0 ≤ j ≤ k +1 
if j − 1 < k then
W' ([qs, i,j − 1], [qy, i, j]) = Wi(qs, qy) where qy ∈ Qi, 1 ≤ i ≤ n
a	a


W' ([qs, i,j − 1], [qy, i'', 0]) = Wi(qs, qy) where qy ∈ Qi'' , 1 ≤ i, i'' ≤
a	a
n, i /= i''
if j − 1= k then W'([qs, i,j − 1], [qs, j', 0]) = 1, 1 ≤ j' ≤ n and qs ∈
Qj' .
The construction of WFA clearly shows that,
L(M ) = L≤k(Γ)
and so L≤k(Γ) ∈ L(WFA)
Moreover for any string w ∈ Σ∗ we have fΓ(w) = fM (w) where fΓ is the function defined by the n-WFA, Γ and fM is the function defined by the WFA,
M.	✷

Theorem 3.11 For any n-WFA Γ in ≥ k-mode, we have L≥k(Γ) ∈ L(WF A). The function deﬁned by the n-WFA Γ working in ≥ k-mode can be deﬁned by a single WFA.
Proof Let Γ = (Q, Σ, Wα, I,F ) be a n-WFA in ≥ k-mode where Wα  = (W 1,W 2, ··· ,Wn) and the component states Q1, Q2, ··· , Qn.
α	α	α
Consider the WFA M	=	(Q', Σ,W' , I',F') where, Q'	=	{[q, i, j] | q ∈
QUnion, 1 ≤ i ≤ n, 0 ≤ j ≤ k}∪ {[q, i] | q ∈ Qunion, 1 ≤ i ≤ n}∪ {q' }
I' : Q' −→ (−∞, ∞) isa I-normal initial distribution such that
I'(q' ) = 1 and I'(q) = 0 for all other q ∈ Q'
F ' : Q' −→ (−∞, ∞) such that F '(q' ) = 0 and
F '([q, i, j]) = F '([q, i]) = F (q) for all q ∈ Qunion
' the weight matrices are defined as follows,
'	'	'
Wє (q0, [q0,i , 0]) = I(q0) such that q0 ∈ Qi'
for each qy such that Wi(qs, qy) /= 0, qs ∈ Qi, a ∈ Σ ∪ {ϵ}, 1 ≤ i ≤ n,
0 ≤ j ≤ k +1 
if j − 1 < k then W' ([qs, i,j − 1], [qy, i, j]) = Wi(qs, qy), qy ∈ Qi
a	a
if j − 1= k then
W' ([qs, i,j − 1], [qy, i]) = Wi(qs, qy), qy ∈ Qi
a	a
W' ([qs, i,j − 1], [qy, j', 0]) = Wi(qs, qy), 1 ≤ j' ≤ n, j' /= i, and
a	a
qy ∈ Qj'
W' ([qs, i], [qy, i]) = Wi(qs, qy), qy ∈ Qi
a	a
W' ([qs, i], [qy, j', 0]) = Wi(qs, qy), 1 ≤ j' ≤ n, j' /= i, and qy ∈ Qj'
a	a
The construction of WFA clearly shows that,
L(M ) = L≥k(Γ)
So L≥k(Γ) ∈ L(WFA)
Moreover for any string w ∈ Σ∗ we have fΓ(w) = fM (w) where fΓ is the func- tion defined by the n-WFA, Γ and fM is the function defined by the WFA, M.✷


Thus we find for the n-WFA the different modes of acceptance are equiva- lent and the function defined by an n-WFA can be defined by a single WFA. The n-WFA accepts only those languages accepted by the WFA. In what follows, we use only ∗-mode of computations for the image representation.

Representation of Gray-Scale Images using n-WFA
We know that a WFA can be used to represent a gray-scale image. Similarly a n-WFA can be used to represent a gray-scale image.
A n-WFA M is said to represent a multi-resolution image if the function fM
represented by M is the same as the function fI of the image.


2- WFA computing the linear grayness function
Example 3.12 Consider the 2-WFA shown in figure. The I = (1, 0) and
F = ( 1 , 1) and the weight matrices corresponding to the 2 components are as

follows
1 0
 1 1 
 
 1 1 
 
 1 1 
 

W 1 =  2
, W 1 =  2
4 , W 1 =  2
4 , W 1 =  2
2 ,

0 0 
 0 0 
0 0 
 0 0 
0 0 
 0 0 
0 0 
 0 0 

W 2 =	2	2
0 1	0 1 
2
3
0 1	0 1 


In the figure the dotted lines correspond to the change in the control from one component to another. Then we can calculate the values of pixels as follows. f (13) = sum of weights of all paths labeled 13.


1
f (13) = 1 · 
2
1	1	1	1
·  ·  +1 ·  · 
2	2	2	2
1
· 1+1 · 
4
1	1	1	5
· 1 · 1=  +  +  = 
8	4	4	8

similarly for f (123) we have f (123) =  1 + 1 + 1 + 1 =  9 . The images obtained
16	8	8	4	16
by this 2-WFA are shown for resolutions 2 × 2, 4 × 4 and 128 × 128 in the
above figure.
Thus we have seen how n-WFAs can be used for representing gray-scale images. Though the number of matrices in the n-WFA are more than the usual WFA the advantage of using the n-WFAs is that most of the matrices

are sparse matrices and thus the matrix computations are much faster than in the usual WFA case.

Inferencing and De-Inferencing
In this subsection we give algorithms for inferencing and de-inferencing of a
n-WFA.
Inferencing
Let I be a digital gray scale multi resolution image given by the average preserving function f  : Σ∗ −→ R. We construct an average preserving m-WFA M such that fM = f . During the construction
N is the index of the last state created,
L denotes the index of the component in which the state is in 1 ≤ L ≤ m,
i is the index of the first unprocessed state,
γ : Qunion −→ Σ∗ is a mapping of the states to subsquares,
φp is the image represented by the state p and
fw represents the subimage at the subsquare labeled w
Algorithm 1 Infer m-WFA
Input : Image I given by an average preserving function, f : Σ∗ −→ R
and m-the number of components of the m-WFA to be constructed
Output : m-WFA M representing the image I
Begin
Set N ←− 0,i ←− 0, component ←− 1,L ←− 1,F ([q0, L]) = f (ϵ) and
γ([q0, L]) ←− ϵ
Process qi, i.e. for w = γ(qi, L]) and each α ∈ {0, 1, 2, 3} do
begin for
If there are c0, c1, ··· , cN such that
fwα = c0φ0 + c1φ1 + ··· + cN φN , where φj = f[qj,s] for some s, 1 ≤
s ≤ m, 0 ≤ j ≤ N
then set WL([qi, L], [qj, s]) ←− cj, for 0 ≤ j ≤ N
else
if component ≤ m then
begin elseif(then)
γ([qN+1,L + 1]) ←− wα, F[qN +1,L+1] ←− f (wα)
WL([qi, L], [qN+1,L + 1]) ←− 1 and N ←− N +1 
component ←− component+1
end elseif(then)
else

γ([qN+1, L]) ←− wα, F[qN +1,L] ←− f (wα)
WL([qi, L], [qN+1, L]) ←− 1 and N ←− N +1 
end elseif end for
Set i ←− i + 1, if i ≤ N then go to Step (ii)
Set I(q0)	=	1, I(qj)	=	0 for j = 1, ··· ,N, where I is the initial distribution of M
end



The 3-WFA infered from the diminishing triangles figure using the above al- gorithm is given below.




















,3(1)


0,1,2,3(1/2)



The 3-WFA infered from the given diminishing triangles figure

The initial distribution of the state q[0,1] is 1 and at all other states the initial distribution is 0. The final distribution at each state is the average intensity of the image of that state.


De-Inferencing
Assume, we are given a m-WFA M (I, F, Wi,Wi,Wi,Wi), 1 ≤ i ≤ m and
0	1	2	3
we want to construct a finite resolution approximation of the multi-resolution
image represented by M . Let the image to be constructed be I of resolution 2k × 2k. Then for all x ∈ Σk, we have to compute f (x) = I.Wx.F . The algorithm is as follows. The algorithm computes φp(x) for p ∈ Q for all x ∈ Σi, 0 ≤ i ≤ k. Here φp is the image of state p.
Algorithm 2 De Infer m-WFA
Input :WFA M = (I, F, Wi,Wi,Wi,Wi), 1 ≤ i ≤ m.
0	1	2	3
Output :f (x), for all x ∈ Σk.
begin
Set φp(ϵ) ←− Fp for all p ∈ Qunion
For j = 1, 2, ··· , k, do the following
begin
For all p ∈ Qunion, x ∈ Σj−1 and α ∈ Σ compute

φp(αx) ←−	Σ
q∈Qunion
Wi (p, q) · φq(x), where the state p belongs to the com-

ponent i
end for
For each x ∈ Σk, compute

f (x)= Σ Iq · φq(x).
q∈Q
Stop
end

The time complexity of this de-inferencing algorithm is O(n24k), where n is the total number of states in the m-WFA and 4k = 2k · 2k is the number of pixels in the image. We know that f (x) can be computed either by summing the weights of all the paths labeled x or by computing I · Wx · F . Finding all paths labeled of length k takes k · (4k)n time. Since n  k we prefer the matrix multiplication over this.

Conclusions
In this paper we have defined a new theoretical construct namely, the dis- tributed weighted finite automata and studied the power of this construct in the various modes of acceptance. We have shown that the power of this con- struct is no more than the classical weighted finite automata in all modes of acceptance and hence proved that all the modes of acceptance are equivalent. We have used this construct for the representation of gray scale images and have given an inferencing and a de-inferencing algorithm for the distributed weighted finite automata. The weight matrices produced for this construct us- ing the inference algorithm are mostly sparse matrices which occupy less space and thus the matrix computations involved in inferencing and de-inferencing are much faster when compared to the usual weight martices in the WFA.

References
M. Sakthi Balan. Distributed Processing in Automata. Master’s thesis, Indian Institute of Technology, Madras, April 2000.
E. Csuhaj-Varju, J. Dassow, J. Keleman, and Gh. Paun. Grammar Systems: A Grammatical Approach to Distribution and Cooperation. Gordon and Breach, London, 1994.
Vesa Halava and Tero Harju. Languages accepted by integer weighted finite automata. Technical Report TR-216, TUCS, 1998.
John E. Hopcroft and Jeffrey D. Ullman. Introduction to Automata Theory, Languages and Computation. Addison-Wesley, 1979.
K. Culik II and S. Dube. Rational and affine expressions for image description.
Discrete Applied Mathematics, 41:85–120, 1993.


K. Culik II and J. Karhumaki. Automata computing real functions. SIAM J. on Computing, 23:789–814, 1994.
K. Culik II and J. Kari. Image compression using weighted finite automata.
Computer and Graphics, 17:305–313, 1993.
K. Culik II and J. Kari. Image-data compression using edge-optimizing algorithm for wfa inference. Journal of Information Processing and Management, 30:829–838, 1994.
K. Culik II and J. Kari. Inference algorithms for wfa and image compression. In Yuval Fisher, editor, Fractal Image Compression, Theory and Application, chapter 13, pages 243–258. Springer-Verlag, 1994.
K. Culik II and J. Kari. Handbook of Formal languages, chapter 10. Digital Images and Formal Languages. Springer-Verlag, 1997.
Karel Culik II and Jarrko Kari. Finite state transformation of images. Comput. & Graphics, 20(1):125–135, 1996.
K. Krithivasan, M. Sakthi Balan, and P. Harsha.  Distributed processing in automata. International Journal of Foundations of Computer Science, 10(4):443–464, 1999.
S. V. Ramasubramanian and Kamala Krithivasan. Finite automata and digital images. IJPRAI, 14(4):501–524, 2000.
Derick Wood. Theory of Computation. Harper & Row, Publishers, Inc, 1987.
