Electronic Notes in Theoretical Computer Science 192 (2007) 29â€“44	
www.elsevier.com/locate/entcs


Bi-inductive Structural Semantics
(Extended Abstract)

Patrick Cousot1
DÂ´epartement dâ€™informatique, EÂ´cole normale supÂ´erieure, 45 rue dâ€™Ulm, 75230 Paris cedex 05, France
Radhia Cousot2
CNRS & EÂ´cole polytechnique, 91128 Palaiseau cedex, France

Abstract
We propose a simple order-theoretic generalization of set-theoretic inductive definitions. This generalization covers inductive, co-inductive and bi-inductive definitions and is preserved by abstraction. This allows the structural operational semantics to describe simultaneously the finite/terminating and infinite/diverging be- haviors of programs. This is illustrated on the structural bifinitary small/big-step trace/relational/operational semantics of the call-by-value Î»-calculus.
Keywords: fixpoint definition, inductive definition, co-inductive definition, bi-inductive definition, structural operational semantics, SOS, trace semantics, relational semantics, small-step semantics, big-step semantics, divergence semantics, abstraction.


Introduction
The connection between the use of fixpoints in denotational semantics [17] and the use of rule-based inductive definitions in axiomatic semantics [10] and structural operational semantics (SOS) [19,20,21] can be made by a generalization of inductive definitions [1] to include co-inductive definitions [8]. It is then
possible to generalize natural semantics describing finite input/output behaviors
[12] so as to also include infinite behaviors [7]. This is necessary since the definition of the infinite behaviors cannot be derived from the finite big-step SOS behaviors.

1 Patrick.Cousot@ens.fr, www.di.ens.fr/Ëœcousot/
2 Radhia.Cousot@polytechnique.fr, www.polytechnique.edu/Radhia.Cousot/

1571-0661 Â© 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.08.015

Example 1.1 Let us consider the choice operator E1 | E2 where the evaluation of E1 either terminates (returning the value a, written E1 =â‡’ a) or does not terminate (written E1 =â‡’ âŠ¥). Similarly, the big-step semantics of E2 is E2 =â‡’ b for a terminating evaluation returning b or E2 =â‡’ âŠ¥ for non-termination. Let us consider several possible semantics for the choice operator:
Nondeterministic: an internal choice is made initially to evaluate E1 or to evaluate
E2;
Parallel: evaluate E1 and E2 concurrently, with an unspecified scheduling, and return the first available result a or b;
Mixed left-to-right: evaluate E1 and then either return its result a or evaluate E2
and return its result b;
Mixed right-to-left: evaluate E2 and then either return its result b or evaluate E1
and return its result a;
Eager: evaluate both E1 and E2 and return either results if both terminate.
The corresponding finite big-step behaviors, as described in natural semantics [12], are all defined as follows:
a | b =â‡’ a	a | b =â‡’ b	.
But for the case âŠ¥ | âŠ¥ =â‡’ âŠ¥, the infinite behaviors are all different:

Since the natural semantics defines the finite behaviors but not the diverging behav- iors, an interpretation of the big-step evaluation rules as Horn clauses implemented in Prolog [2,9] will have its diverging behaviors determined by the implementation (e.g. Prolog interpreter with left-to-right evaluation).	 
The paper develops and illustrates the use of â€bi-inductiveâ€ definitions in opera- tional semantics which enable both finitary and infinitary behaviors to be described simultaneously [7,8].
The general methodology consists in extending Hilbert proof systems [1] by replacing the powerset âŸ¨â„˜(U ), âŠ†âŸ© of the universe U by a partial order âŸ¨D, Â±âŸ©. Beyond the classical inductive definitions âŸ¨â„˜(U ), âŠ†âŸ©, this extension includes the co-inductive definitions âŸ¨â„˜(U ), âŠ‡âŸ© and bi-inductive definitions mixing inductive and co-inductive definitions [7,8]. This extension also copes with compositional structural definitions as found in denotational semantics or SOS. This is illustrated

by definitions of the semantics of the call-by-value Î»-calculus.
We introduce an original big-step trace semantics that gives operational mean- ing to both convergent and divergent behaviors of programs. The compositional structural definition mixes induction for finite behaviors and co-induction for infinite behaviors while avoiding duplication of rules between the two cases. This big-step trace semantics excludes erroneous behaviors that go wrong. The other semantics are then systematically derived by abstraction.
The big-step trace semantics is first abstracted to a relational semantics and then to the standard big-step or natural semantics. These abstraction are sound and complete in that the big-step trace and relational semantics describe the same converging or diverging behaviors while the big-step trace and natural semantics describe the same finite behaviors. The big-step trace semantics is then abstracted into a small-step semantics, by collecting transitions along traces. This abstraction is sound but incomplete in that the traces generated by the small-step semantics describes convergent, divergent, but also erroneous behaviors of programs. This shows that trace-based operational semantics can be much more informative that small-step operational semantics.

Bi-inductive structural definitions and their abstrac- tion
Structural order-theoretic inductive deï¬nitions
We introduce different forms of structural order-theoretic inductive definitions and prove their equivalence.
We formalize the syntax of a language L as a binary relation â‰º on L to be understood as the â€œstrict syntactic subcomponentâ€ relation on L. âŸ¨L, â‰ºâŸ© is therefore a well-founded set, â‰º is irreflexive (inducing the reflexive â€œ), and â‰º has finite left images âˆ€l âˆˆ L : |{l' âˆˆ L | l' â‰º l}| âˆˆ N (|S| is the cardinality of set S, N is the set of
natural numbers). Hence we can write l ::= l1,..., ln for the tuple of elements

  l'â‰ºl l' = l1,..., ln such that {l1,..., ln} = {l' âˆˆ L | l' â‰º l}.
For example, fo.r the language L of lambda terms a, b, ... ::= x | Î» x
. a | a b, we

can define a â‰º Î» x a, a â‰º a b and b â‰º a b so a b ::= a, b. In case no structural i.e.
syntax-directed reasoning is needed, L can be chosen as a singleton and â‰º as false. For each â€œsyntactic componentâ€ l âˆˆ L, we consider a semantic domain âŸ¨Dl, Â±l,
âŠ¥l, HlâŸ© which is assumed to be a directed complete partial order (dcpo).
For each â€œsyntactic componentâ€ l âˆˆ L, we consider variables Xl, Yl, . . . ranging over the semantic domain Dl. We drop the subscript l when the corresponding semantic domain is clear from the context (e.g. the semantic domain is the same for all â€œsyntactic componentsâ€ i.e. âˆ€l âˆˆ L : Dl = D).
For each â€œsyntactic componentâ€ l âˆˆ L, we let Î”l be indexed sequences (totally ordered sets). We write  iâˆˆÎ”Ã† xi when considering the sequence âŸ¨xi, i âˆˆ Î”lâŸ© âˆˆ Î”l 'â†’ S of elements of a set S as a vector of  iâˆˆÎ”Ã† S.
For each element i âˆˆ Î”l of the sequence, we consider transformers F i âˆˆ Dl Ã—

Dl1 .. .Ã—Dln 'âˆ’â†’ Dl where n = |{l âˆˆ L | l â‰º l}| and {l1,..., ln} = {l âˆˆ L | l â‰º l}.
'	'	'	'
When n = 0, we have F i âˆˆ Dl 'âˆ’â†’ Dl.
The transformers are assumed to be Â±l-monotone in their first parameter, that is âˆ€i âˆˆ Î”l, l1,..., ln â‰º l, X, Y âˆˆ Dl, X1 âˆˆ Dl1 ,..., Xn âˆˆ Dln : X Â±l Y =â‡’ F i(X, X1,..., Xn) Â±l F i(Y, X1,..., Xn).

l	l
For each â€œsyntactic componentâ€ l âˆˆ L, the join Y
âˆˆ (Î”l 'âˆ’â†’ Dl) 'âˆ’â†’ Dl is

assumed to be componentwise Â±l-monotone (âˆ€âŸ¨Xi, i âˆˆ Î”lâŸ© : âˆ€âŸ¨Yi, i âˆˆ Î”lâŸ© : (âˆ€i âˆˆ
Î”l : Xi Â±l Yi) =â‡’ jl (  Xi) Â±l jl (  Yi)). The join operator is used to gather
iâˆˆÎ”Ã†	iâˆˆÎ”Ã†

alternatives in formal definitions. For brevity, we write YÃ† (  Xi)= jl
Xi, leaving

iâˆˆÎ”Ã†	iâˆˆÎ”Ã†
implicit the fact that the Xi should be considered in the total order given by the sequence Î”l.
Most often, the order of presentation of these alternatives in the formal definition is not significant. In this case, Î”l is just a set and the join may often be defined in term of a binary join Y âˆˆ (Dl Ã— Dl) 'âˆ’â†’ Dl, which is assumed to be associative,

commutative, and
Ã†
Â±l-monotone, as Y
( 
iâˆˆÎ”Ã†
Xi)
l iâˆˆÎ”Ã†
Xi. The binary join may be

different form the least upper bound (lub) Hl of the semantic domain Dl.
A ï¬xpoint deï¬nition has the form

âˆ€l âˆˆ L : S
JlK = lfpÂ±Ã† Î» X . j F i(X,  S
Jl'K)

Æ’	l	l
iâˆˆÎ”Ã†
Æ’
l'â‰ºl

where lfpÂ± is the partially defined Â±-least fixpoint operator on a poset âŸ¨P, Â±âŸ©. To emphasize structural composition, we also let {l1,..., ln} = {l' âˆˆ L | l' â‰º l} and write

âˆ€l âˆˆ L : S
Jl ::= l1,...,l K = lfpÂ±Ã† Î» X . j F i(X, S Jl1K,..., S Jl
K) .

Æ’	n	l	l	Æ’	Æ’  n
iâˆˆÎ”Ã†

Lemma 2.1 âˆ€l âˆˆ L : SÆ’ JlK is well deï¬ned.
as Djefinitions needing no fixpoint or join can wjithal be encompassed as fixpoints such
F i(S Jl1K,..., S Jl K) = lfpÂ±Ã† Î» X .	F i(S Jl1K,..., S Jl K) or without

l	l	Æ’	Æ’  n
iâˆˆÎ”Ã†
l	l	Æ’	Æ’  n
iâˆˆÎ”Ã†

join F i(S Jl1K,..., S Jl
K) = lfpÂ±Ã† Î» X . j F i' (S Jl1K,..., S Jl
K).

l	Æ’	Æ’  n
l	l	Æ’	Æ’  n
i'âˆˆ{i}

An equational deï¬nition has the form:
âŸ¨Se l , l âˆˆ LâŸ© is the componentwise Â±l-least âŸ¨Xl, l âˆˆ LâŸ© satisfying the system of equations
â§âª Xl = j F i(Xl,  '	Xl' )
âªâ© l âˆˆ L	.

A constraint-based deï¬nition has the form:
âŸ¨Se l , l âˆˆ LâŸ© is the componentwise Â±l-least âŸ¨Xl, l âˆˆ LâŸ© satisfying the system of constraints (inequations)

â§âª j
F i(Xl,  '
Xl' ) Â±l Xl

âªâ© l âˆˆ L	.
A rule-based deï¬nition is a sequence of rules of the form


Xl
F i(Xl,   SrJl'K)
Â±Ã†	l âˆˆ L,i âˆˆ Î”l

l'â‰ºl

where the premise and conclusion are elements of the âŸ¨Dl, Â±lâŸ© cpo. When under- standing the rule in logical form (where the premise is a statement that is assumed to be true and from which a conclusion can be drawn), the following form might be preferred.


	Xl Â±l SrJlK	
F i(Xl,  SrJl'K) Â±l SrJlK

l âˆˆ L, Xl

âˆˆ Dl,i âˆˆ Î”l

l'â‰ºl

If F i does not depend upon the premise Xl, it is an axiom. In such presentations,
the join Y of the alternatives is left implicit 3 . To make it explicit, we rewrite such definitions in the form

	Xl Â±l SrJlK	

(1)


l iâˆˆÎ”Ã†

F i(Xl,
 

l'â‰ºl

SrJl'K) Â±l SrJlK
Â±Ã†	l âˆˆ L, Xl âˆˆ Dl .

The formal definition of the join makes explicit whether the order of presentation of the rules does matter, or not. When it doesnâ€™t, the join can be defined using a binary associative and commutative join. This binary join can even be left implicit and, by associativity and commutativity, the rules can be given in any order. This will be the case for our examples.
A D âˆˆ Dl is provable if and only if it has a proof that is a transfinite sequence 4


Â±l	l
F i(.
DÎ²,   SrJl'K).

iâˆˆÎ”Ã†
Î²<Î´
l'â‰ºl

The meaning of a rule-based definition (1) is

3 This is the case in classical Hilbertâ€™s formal systems.
4 In the classical case [1], the fixpoint operator is continuous whence proofs are finite.


SrJlK  .l{D âˆˆ Dl | D is provable} .
The above order-theoretic inductive definitions are all equivalent:
Theorem 2.2 âˆ€l âˆˆ L : SJlK  SÆ’ JlK = SeJlK = ScJlK = SrJlK.
This generalization of [1] could also include a game-theoretic version. The closure-condition version [1] is also easy to adapt.
Example 2.3 The classical inductive definition [1] of the subset S of a universe U by rules  Pi  i âˆˆ I, where Pi âŠ† U and ci âˆˆ U , i âˆˆ I can be written 	X âŠ† S	 âŠ†,
i âˆˆ I or Pi âŠ† X,  X âŠ† S âŠ†, i âˆˆ I that is Pi âŠ† S âŠ†, i âˆˆ I for short. So âŸ¨L, â€œâŸ©  âŸ¨â€¢, =âŸ©,
ci âˆˆ S	ci âˆˆ S 
âŸ¨Dâ€¢, Â±â€¢, âŠ¥â€¢, Hâ€¢âŸ©  âŸ¨â„˜(ğ¶), âŠ†, âˆ…, âˆªâŸ©, Î”â€¢  I, F i âˆˆ â„˜(U ) 'â†’ â„˜(U ) is F i(X)  {ci |

Pi âŠ† X} and
jâ€¢ 
â€¢
thus defining S = lfpâŠ† Î» X
â€¢
{ci | i âˆˆ I âˆ§ Pi âŠ† X}.	 


Bi-semantic domains
To account for terminating/finite and diverging/infinite program behaviors, we consider bi-semantic domains consisting, for each l âˆˆ L, of a finitary semantic domain
(of finite program behaviors) âŸ¨D+, Â±+, âŠ¥+, .+âŸ© and a infinitary semantic codomain
(of infinite program behaviors) âŸ¨Dâˆ’, Â±âˆ’, âŠ¥âˆ’, .âˆ’âŸ© which are assumed to be dcpos
[17] (respectively complete lattices). They are combined into a bi-semantic domain (of bifinite program behaviors) Dl thanks to a projection Ï€+ âˆˆ Dl 'â†’ D+, a coprojection
l	l
Ï€âˆ’ âˆˆ Dl 'â†’ Dâˆ’, and a constructor Ï€l âˆˆ D+ Ã— Dâˆ’ 'â†’ Dl satisfying âˆ€x âˆˆ D+,y âˆˆ
l	l	l	l	l
Dâˆ’ : Ï€+(Ï€l(x, y)) = x and Ï€âˆ’(Ï€l(x, y)) = y while âˆ€X âˆˆ D : Ï€l(Ï€+(X), Ï€âˆ’(X)) = X.
l	l	l	l	l
Examples are the Cartesian product, disjoint union or union of disjoint sets. The bi-semantic domain âŸ¨Dl, Â±l, âŠ¥l, HlâŸ© is then a dcpo (respectively a complete lattice) by defining X+   Ï€+(X), Xâˆ’   Ï€âˆ’(X), X Â±l Y   (X+ Â±+ Y +) âˆ§ (Xâˆ’ Â±âˆ’ Y âˆ’),
and . Xi  Ï€l(.+ X+, .âˆ’ Xâˆ’).

l iâˆˆI

Abstraction
l iâˆˆI
i		l	i iâˆˆI

We consider a simple form of abstraction based on a continuous abstraction function
Î± [6], which includes the particular case of a Galois connection [5] (denoted âŸ¨P,
g	g
â€œâŸ© âˆ’â†âˆ’âˆ’âˆ’âˆ’â†’âˆ’ âŸ¨Q, Â±âŸ©, or âŸ¨P, â€œâŸ© âˆ’â†âˆ’âˆ’âˆ’âˆ’â†’âˆ’â†’âˆ’ âŸ¨Q, Â±âŸ© when Î± is onto, where âŸ¨P, â€œâŸ© and âŸ¨Q, Â±âŸ©
are poÎ±sets, and âˆ€x âˆˆ P : âˆ€y âˆˆÎ± : Î±(x) Â± y â‡â‡’ x â€œ Î³(y)).
Q

For all l âˆˆ L, we let âŸ¨D , Â± , âŠ¥ , H âŸ© be dcpos, i
'âˆ’â†’ D
	


l	l	l	l
F l âˆˆ Dl Ã— Dl1 ... Ã— Dln	l



i âˆˆ Î”l be monotone in their first parameter, and define the abstract semantics SÆ’ l
in one of the equivalent forms of Th. 2.2.
If Î±l âˆˆ Dl 'âˆ’â†’ Dl, we say that the abstract semantics âŸ¨S l , l âˆˆ LâŸ© is sound with respect to the concrete semantics âŸ¨S l , l âˆˆ LâŸ© if and only if âˆ€l âˆˆ L : Î±l(S l ) Â±l S l . If is complete whenever âˆ€l âˆˆ L : SJlK Â±l Î±l(SJlK).

Structural order-theoretic inductive definitions of the semantics of the call-by-value Î»-calculus
The syntax of the Î»-calculus with constants is

x, y, z,...  âˆˆ  X	variables
c âˆˆ C	constants (X âˆ© C = âˆ…)
c ::= 0 | 1 | ... 
v âˆˆ V	values
v ::= c | Î» x . a
e âˆˆ E	errors
e ::= c a | e a 
a, a', a1,..., b,,... âˆˆ T	terms
a ::= x | v | a a'

We write a[x â† b] for the capture-avoiding substitution of b for all free occurrences of x within a. We let FV(a) be the free variables of a. We define the call-by-value
semantics of closed terms.(without free variables).T  {a âˆˆ T | FV(a)= âˆ…}.
The application (Î» x a v) of a function Î» x a to a value v is evaluated by
substitution a[x â† v] of the actual parameter v for the formal parameter x in the
function body a. This cannot be understood as induction on the pro.gram syntax
since a[x â† v] is not in general a strict syntactic subcomponent of (Î» x a v). Hence
the various semantics below cannot be defined by structural induction of the syntax of Î»-expressions. So the framework of Sect. 2.1 is instantiated with L = {â€¢} and â‰º is defined to be false on L which prevents the use of structural induction on program syntax. For brevity we omit the void syntactic component â€¢ writing e.g. F for F â€¢ , D for Dâ€¢, Î” for Î”â€¢, etc.
We introduce a maximal trace semantics describing terminating and diverging computations. The trace semantics is then abstracted into a relational [20] and then an operational semantics [15]. Each semantics can be defined using small steps or big steps of computation. Each semantics can be defined in fixpoint or rule-based form.
Semantics	Fixpoint definition	Rule-based definition
big-step	small-step	big-step	small-step

Trace	â†’S	lfpÂ± Fâ†’
lfpÂ± fâ†’
Z=â‡’	Z â‡’

Relational	Ã±	lfpÂ± Ã±
Operational	S
lfpÂ± Ã±
lfpâŠ† f = gfpâŠ† f
=â‡’	â‡’
âˆ’A .

Big-step maximal trace semantics of the call-by-value
Î»-calculus
We let TÙ¨ (resp. T+, TÏ‰, Tğ–º and Tâˆ) be the set of finite (resp. nonempty finite, infinite, finite or infinite, and nonempty finite or infinite) sequences of terms where Ïµ is the empty sequence Ïµ â€¢ Ïƒ = Ïƒ â€¢ Ïµ = Ïƒ. We let |Ïƒ| âˆˆ N âˆª {Ï‰} be the length of Ïƒ âˆˆ Tğ–º.
|Ïµ| = 0. If Ïƒ âˆˆ T+ then |Ïƒ| > 0 and Ïƒ = Ïƒ0 â€¢ Ïƒ1 â€¢ ... â€¢ Ïƒ|Ïƒ|âˆ’1. If Ïƒ âˆˆ TÏ‰ then |Ïƒ| = Ï‰
and Ïƒ = Ïƒ0 â€¢ ... â€¢ Ïƒn â€¢ .. .. Given S, T âˆˆ â„˜(Tâˆ), we define S+  S âˆ© T+, SÏ‰  S âˆ© TÏ‰ and S Â± T  S+ âŠ† T + âˆ§ SÏ‰ âŠ‡ T Ï‰, so that the trace domain âŸ¨â„˜(Tâˆ), Â±, TÏ‰, T+, H, HâŸ© is a complete lattice. For a âˆˆ T and Ïƒ âˆˆ Tâˆ, we define a@Ïƒ to be Ïƒ' âˆˆ Tâˆ such that âˆ€i < |Ïƒ| : Ïƒ' = a Ïƒi and similarly Ïƒ@a is Ïƒ' such that âˆ€i < |Ïƒ| : Ïƒ' = Ïƒi a.
i	i

Fixpoint big-step maximal trace semantics

The bifinitary trace semantics â†’S âˆˆ â„˜(Tâˆ) of the closed call-by-value Î»-calculus T
can be specified in fixpoint form
â†’S  lfpÂ± Fâ†’


where the set of traces transformer Fâ†’ computation

	
âˆˆ â„˜(Tâˆ) 'â†’ â„˜(Tâˆ) describes big steps of



Fâ†’ (S)  {v âˆˆ Tâˆ | v âˆˆ V}âˆª	(a)
{(Î» x . a) v â€¢ a[x â† v] â€¢ Ïƒ | v âˆˆ V âˆ§ a[x â† v] â€¢ Ïƒ âˆˆ S}âˆª	(b)
{Ïƒ@b | Ïƒ âˆˆ SÏ‰}âˆª	(c)
{(Ïƒ@b) â€¢ (v b) â€¢ Ïƒ' | Ïƒ /= Ïµ âˆ§ Ïƒ â€¢ v âˆˆ S+ âˆ§ v âˆˆ V âˆ§ (v b) â€¢ Ïƒ' âˆˆ S}âˆª	(d)
{a@Ïƒ | a âˆˆ V âˆ§ Ïƒ âˆˆ SÏ‰}âˆª	(e)
{(a@Ïƒ) â€¢ (a v) â€¢ Ïƒ' | a, v âˆˆ V âˆ§ Ïƒ /= Ïµ âˆ§ Ïƒ â€¢ v âˆˆ S+ âˆ§ (a v) â€¢ Ïƒ' âˆˆ S} .	(f)
The definition of Fâ†’ has (a) for termination, (b) for call-by-value Î²-reduction, (c)
and (d) for left reduction under applications and (e) and (f) for right reduction under applications, corresponding to left-to-right evaluation. (b), (d) and (f) cope both with terminating and diverging traces. In the framework of Sect. 2.1, we have Î”â€¢  {a, b, c, d, e, f } where Fâ†’ i(S), i âˆˆ Î”â€¢ is defined by equation (i). The join operator is chosen in binary form as Yâ€¢  âˆª.
We observe that (S+  S âˆ© T+, SÏ‰  S âˆ© TÏ‰ so S+ âˆ© SÏ‰ = âˆ…)


(2)
âªâ¨ â†’S+ = Fâ†’ (â†’S+) = lfpâŠ† Fâ†’ +	where

Fâ†’ +(S)  Fâ†’ (S+)

âªâ© â†’SÏ‰ = (Fâ†’ (â†’S+ âˆª â†’SÏ‰))Ï‰ = gfpâŠ† Fâ†’ Ï‰	where
Fâ†’ Ï‰(S)  (Fâ†’ (â†’S+ âˆª SÏ‰))Ï‰ .


The bifinitary trace semantics â†’S is suffix-closed in that


âˆ€Ïƒ âˆˆ Tâˆ : a â€¢ Ïƒ âˆˆ â†’S =â‡’ Ïƒ âˆˆ â†’S .

The bifinitary trace semantics â†’S is total in that it excludes intermediate or result errors

âˆ€a âˆˆ T :/ ğ–¤Ïƒ, Ïƒ' âˆˆ Tğ–º, e âˆˆ E : a â€¢ Ïƒ â€¢ e â€¢ Ïƒ' âˆˆ â†’S .
The finite maximal traces are blocking in that the result of a finite computation is always a final value


âˆ€Ïƒ âˆˆ Tâˆ âˆª {Ïµ} : Ïƒ â€¢ b âˆˆ â†’S+ =â‡’ b âˆˆ V .

Rule-based big-step maximal trace semantics
The maximal trace semantics â†’S can also be defined as follows
a[x â† v] â€¢ Ïƒ âˆˆ â†’S
v âˆˆ â†’S,	v âˆˆ V
(Î» x  a) v â€¢ a[x â† v] â€¢ Ïƒ âˆˆ â†’S







Â±,	v âˆˆ V

Ïƒ âˆˆ â†’SÏ‰ Ïƒ@b âˆˆ â†’S Ïƒ âˆˆ â†’SÏ‰ a@Ïƒ âˆˆ â†’S



Â±





Â±,	a âˆˆ V
Ïƒ â€¢ v âˆˆ â†’S+, (v b) â€¢ Ïƒ' âˆˆ â†’S
(Ïƒ@b) â€¢ (v b) â€¢ Ïƒ' âˆˆ â†’S
Ïƒ â€¢ v âˆˆ â†’S+, (a v) â€¢ Ïƒ' âˆˆ â†’S
(a@Ïƒ) â€¢ (a v) â€¢ Ïƒ' âˆˆ â†’S

Â±,	v âˆˆ V


Â±,	v, a âˆˆ V .

Defining â†’S a  {a â€¢ Ïƒ | a â€¢ Ïƒ âˆˆ â†’S}, â†’S+ a  {a â€¢ Ïƒ | a â€¢ Ïƒ âˆˆ â†’S+}, and â†’SÏ‰ a  {a â€¢ Ïƒ |
a â€¢ Ïƒ âˆˆ â†’SÏ‰}, we can also write for brevity



v âˆˆ â†’SJvK,	v âˆˆ V

Ïƒ âˆˆ â†’SÏ‰JaK
Ïƒ âˆˆ â†’SJa[x â† v]K
(Î» x . a) v â€¢ Ïƒ âˆˆ â†’SJ(Î» x . a) vK
Ïƒ â€¢ v âˆˆ â†’S+JaK, Ïƒ' âˆˆ â†’SJv bK

Â±,	v âˆˆ V


Ïƒ@b âˆˆ â†’SJa bK Ïƒ âˆˆ â†’SÏ‰JbK a@Ïƒ âˆˆ â†’SJa bK
Â±





Â±,	a âˆˆ V

(Ïƒ@b) â€¢ Ïƒ' âˆˆ â†’SJa bK
Ïƒ â€¢ v âˆˆ â†’S+JbK, Ïƒ' âˆˆ â†’SJa vK
(a@Ïƒ) â€¢ Ïƒ' âˆˆ â†’SJa bK
Â±,	v âˆˆ V


Â±,	a, v âˆˆ V .

Observe that the inductive definition of â†’SJaK shou.ld neither be understood as a
structural induction on a (since a[x â† v] /â‰º (Î» x a) v) nor as action induction
[16] (because of infinite traces). The definition could be split in inductive rules for

termination and co-inductive rules for divergence, as shown in (2), but the above bi-inductive definition avoids the duplication of common rules. Defining a =â‡’ Ïƒ Ïƒ âˆˆ â†’SJaK, we can also write
	a[x â† v] Z=â‡’ Ïƒ	

v Z=â‡’ v,	v âˆˆ V
(Î» x . a) v Z=â‡’ (Î» x . a) v â€¢ Ïƒ
Â±,	v âˆˆ V

	a Z=â‡’ Ïƒ	
a b Z=â‡’ Ïƒ@b
	b Z=â‡’ Ïƒ	
a b Z=â‡’ a@Ïƒ

Â±,	Ïƒ âˆˆ T Ï‰


Â±,	a âˆˆ V,Ïƒ âˆˆ T Ï‰
a Z=â‡’ Ïƒ â€¢ v,	v b Z=â‡’ Ïƒ' a b Z=â‡’ (Ïƒ@b) â€¢ Ïƒ'
b Z=â‡’ Ïƒ â€¢ v,	a v Z=â‡’ Ïƒ' a b Z=â‡’ (a@Ïƒ) â€¢ Ïƒ'

Â±,	v âˆˆ V,Ïƒ âˆˆ T


Â±, a, v âˆˆ V,Ïƒ âˆˆ T	.

Abstraction of the big-step trace semantics into the big-step relational semantics of the call-by-value Î»- calculus
The relational abstraction of sets of traces is
(3)	Î± âˆˆ â„˜(Tâˆ) 'â†’ â„˜(T Ã— (T âˆª {âŠ¥}))
Î±(S)  {âŸ¨Ïƒ0, Ïƒnâˆ’1âŸ© | Ïƒ âˆˆ S âˆ§ |Ïƒ| = n}âˆª {âŸ¨Ïƒ0, âŠ¥âŸ© | Ïƒ âˆˆ S âˆ§ |Ïƒ| = Ï‰}
Î³ âˆˆ â„˜(T Ã— (T âˆª {âŠ¥})) 'â†’ â„˜(Tâˆ)
Î³(T )  {Ïƒ âˆˆ Tâˆ | (|Ïƒ| = n âˆ§ âŸ¨Ïƒ0, Ïƒnâˆ’1âŸ© âˆˆ T ) ğ–µ (|Ïƒ| = Ï‰ âˆ§ âŸ¨Ïƒ0, âŠ¥âŸ© âˆˆ T )}

so that


âŸ¨â„˜(Tâˆ



g
, âŠ†âŸ© â†âˆ’âˆ’âˆ’âˆ’ âŸ¨â„˜	Ã—	âˆª {âŠ¥}  , âŠ†âŸ© .
Î±


The biï¬nitary relational semantics Ã± Î±(â†’S) âˆˆ â„˜(T Ã— (T âˆª {âŠ¥})) is the relational abstraction of the trace semantics mapping an expression to its final value or âŠ¥ in case of divergence.
Fixpoint big-step biï¬nitary relational semantics
The bifinitary relational semantics Ã±  Î±(â†’S)= Î±(lfpÂ± Fâ†’ ) can be defined in fixpoint
form as lfpÂ± Ã± where the big-step transformer Ã±	(T Ã— (T âˆª {âŠ¥})) 'â†’ â„˜(T Ã— (T âˆª

F
{âŠ¥})) is
F âˆˆ â„˜

F (T )  {âŸ¨v, vâŸ© | v âˆˆ V}âˆª 
{âŸ¨(Î» x . a) v, râŸ© | v âˆˆ V âˆ§ âŸ¨a[x â† v], râŸ© âˆˆ T }âˆª 
{âŸ¨(a b), âŠ¥âŸ© | âŸ¨a, âŠ¥âŸ© âˆˆ T }âˆª 

{âŸ¨(a b), râŸ© | âŸ¨a, vâŸ© âˆˆ T + âˆ§ v âˆˆ V âˆ§ âŸ¨(v b), râŸ© âˆˆ T }âˆª 
{âŸ¨(a b), âŠ¥âŸ© | a âˆˆ V âˆ§ âŸ¨b, âŠ¥âŸ© âˆˆ T }âˆª 
{âŸ¨(a b), râŸ© | a, v âˆˆ V âˆ§ âŸ¨b, vâŸ© âˆˆ T + âˆ§ âŸ¨(a v), râŸ© âˆˆ T } .



Theorem 5.1 We have Î±(Fâ†’ (S)) = Ã± (Î±(S)) and so Ã±
  Î±(â†’S) = Î±(lfpÂ± Fâ†’ ) =

F	S
lfpÂ± Ã± .

Rule-based big-step biï¬nitary relational semantics
The big-step bifinitary relational semantics =â‡’ is defined as a =â‡’ r  âŸ¨a, râŸ© âˆˆ Î±(â†’S a ) where a âˆˆ T and r âˆˆ T âˆª {âŠ¥}. It is

a[x â† v] =â‡’ r

v =â‡’ v,	v âˆˆ V

(Î» x
. a)	v =â‡’ r
Â±,	v âˆˆ V, r âˆˆ V âˆª {âŠ¥}

a =â‡’ âŠ¥ a b =â‡’ âŠ¥ b =â‡’ âŠ¥ a b =â‡’ âŠ¥ 



Â±





Â±,	a âˆˆ V
a =â‡’ v,	v b =â‡’ r a b =â‡’ r
b =â‡’ v,	a v =â‡’ r a b =â‡’ r

Â±,	v âˆˆ V, r âˆˆ V âˆª {âŠ¥}


Â±,	a âˆˆ V, v âˆˆ V, r âˆˆ V âˆª {âŠ¥} .

Agai.n this should neither be understood as a structural induction (since a[x â† v] /â‰º
(Î» x a) v) nor as action induction (because of infinite behaviors). The abstraction
Î±(T )  T âˆ© (T Ã— T) yields the classical natural semantics [12] (where all rules with âŠ¥ are eliminated and Â± becomes âŠ† in the remaining ones). The abstraction Î±(T )  T âˆ© (T Ã— {âŠ¥}) yields the divergence semantics (keeping only the rules with
âŠ¥, Â± is âŠ‡, and a =â‡’ âŠ¥ is written a =âˆâ‡’ in [15]).
Observe that both the maximal trace semantics of Sec. 4.1 and the above bifinitary relational semantics of Sec. 5 define the semantics of a term that â€œgoes wrongâ€ as empty.
The above big-step bifinitary relational semantics =â‡’ is equivalent but not identical to the standard big-step semantics which bifinitary generalization would be


v =â‡’ v,	v âˆˆ V

a =â‡’ âŠ¥ 
Â±
a b =â‡’ âŠ¥ 
a =â‡’ Î» x . c,	b =â‡’ v',	c[x â† v'] =â‡’ r
a b =â‡’ r a =â‡’ v,	b =â‡’ âŠ¥ 
Â±,	v âˆˆ V
a b =â‡’ âŠ¥ 

Â±,	v, v' âˆˆ V,
r âˆˆ V âˆª {âŠ¥}

We have chosen to break evaluations of applications in smaller chunks instead so as to enforce evaluation of the function before that of the arguments and to make explicit the reduction step in the trace semantics.
Abstraction of the big-step trace semantics into the small-step operational semantics of the call-by-value Î»-calculus
The one-step reduction semantics abstracts the trace semantics by collecting all transitions along any trace.
The small-step abstraction of traces is
Î±s âˆˆ â„˜(Tâˆ) 'â†’ â„˜(T Ã— T)
Î±s(S)  {âŸ¨Ïƒi, Ïƒi+1âŸ© | Ïƒ âˆˆ S âˆ§ 0 â‰¤ i âˆ§ i +1 < |Ïƒ|} .
Since the bifinitary trace semantics is suffix-closed, we can also use
Î± âˆˆ â„˜(Tâˆ) 'â†’ â„˜(T Ã— T)
Î±(S)  {âŸ¨Ïƒ0, Ïƒ1âŸ© | Ïƒ âˆˆ S âˆ§ |Ïƒ| > 1}
so that we have Î±s(S)= Î±(S) whenever S is suffix-closed. By defining â„˜(Tâˆ) to be the set of suffix-closed and blocking subsets of Tâˆ and Î³(Ï„ ) to be the set of maximal traces generated by the transition relation Ï„ âˆˆ â„˜(T Ã— T) that is
Î³+(Ï„ )  {Ïƒ âˆˆ T+ | âˆ€i < |Ïƒ| : âŸ¨Ïƒi, Ïƒi+1âŸ© âˆˆ Ï„ âˆ§ âˆ€a âˆˆ T : âŸ¨Ïƒ<|Ïƒ|âˆ’1, aâŸ© /âˆˆ Ï„ }
Î³Ï‰(Ï„ )   {Ïƒ âˆˆ TÏ‰ | âˆ€i âˆˆ N : âŸ¨Ïƒi, Ïƒi+1âŸ© âˆˆ Ï„ }
Î³(Ï„ )   Î³+(Ï„ ) âˆª Î³Ï‰(Ï„ ) ,
we have

âŸ¨â„˜(Tâˆ
g
, âŠ†âŸ© â†âˆ’âˆ’âˆ’âˆ’ âŸ¨â„˜	\	Ã—	, âŠ†âŸ© .
Î±

Small-step operational semantics
The small-step operational semantics or transition semantics S is defined by Î±- overapproximation Î±s(â†’S) = Î±(â†’S) of the bifinitary trace semantics â†’S.


(4)
S  lfp f
f (Ï„ )  {âŸ¨(Î» x . a) v, a[x â† v]âŸ©}âˆª {âŸ¨a0 b, a1 bâŸ© | âŸ¨a0, a1âŸ© âˆˆ Ï„ }âˆª 
{âŸ¨v b0, v b1âŸ© | âŸ¨b0, b1âŸ© âˆˆ Ï„ } .

The rule-based presentation of (4) has a call-by-value Î²-reduction axiom plus two context rules for reducing under applications, corresponding to left-to-right evaluation [20]. a âˆ’A b stands for âŸ¨a, bâŸ© âˆˆ S.




((Î» x
. a) v) âˆ’A a[x â† v]
a0 âˆ’A a1
âŠ†
a0 b âˆ’A a1 b
b0 âˆ’A b1
âŠ† .
v b0 âˆ’A v b1


The inductive definition of S can also be understood as co-inductive since lfpâŠ† f =
gfpâŠ† f .
We have Î± â—¦ Fâ†’ â—¦ Î³ âŠ†Ë™ f . Indeed Î± â—¦ Fâ†’ â—¦ Î³ Ë™ f since a single transition
cannot anticipate whether the future computation can â€œgo wrongâ€. For example
((Î» x . x 0) 0) âˆ’A	(0 0) âˆˆ f â—¦ f (âˆ…) while ((Î» x . x 0) 0) âˆ’A	(0 0) /âˆˆ Î± â—¦ Fâ†’ â—¦ Î³ â—¦
Î± â—¦ Fâ†’ â—¦ Î³(âˆ…) since there is no trace of the form Ïƒ â€¢ ((Î» x . x 0) 0) â€¢ (0 0) â€¢ Ïƒ' in
Fâ†’ â—¦ Î³ â—¦ Î± â—¦ Fâ†’ â—¦ Î³(âˆ…). It follows that the small-step operational semantics or
transition semantics S is sound but incomplete in that the set Î³(S) of maximal traces generated by the transition relation S includes the bifinitary trace semantics
â†’S plus spurious traces for computations that can â€œgo wrongâ€ that is terminate with a runtime error e âˆˆ E.

	Small-step maximal trace semantics of the call-by- value Î»-calculus
The small-step maximal trace semantics âˆ’âˆA  of a transition relation âˆ’A  is defined as
âˆ’nA	  {Ïƒ âˆˆ T+ | |Ïƒ| = n > 0 âˆ§ âˆ€i :0 â‰¤ i < n âˆ’ 1: Ïƒi âˆ’A  Ïƒi+1}	partial traces
âˆ’nA	  {Ïƒ âˆˆ âˆ’nA  | Ïƒnâˆ’1 âˆˆ V}	maximal execution traces of length n
âˆ’+A	   âˆ’nA	maximal finite execution traces
n>0
âˆ’Ï‰A	  {Ïƒ âˆˆ TÏ‰ | âˆ€i âˆˆ N : Ïƒi âˆ’A Ïƒi+1}	infinite execution traces
âˆ’âˆA	  âˆ’+A âˆª âˆ’Ï‰A	maximal finite and diverging execution traces.

Fixpoint small-step maximal trace semantics
To express the small-step maximal trace semantics âˆ’âˆA in fixpoint form, let us define the junction ; of set of traces as
S ; T   SÏ‰ âˆª {Ïƒ0 â€¢ ... â€¢ Ïƒ|Ïƒ|âˆ’2 â€¢ Ïƒ' | Ïƒ âˆˆ S+ âˆ§ Ïƒ|Ïƒ|âˆ’1 = Ïƒ' âˆ§ Ïƒ' âˆˆ T } ,
and the small-step set of traces transformer fâ†’ âˆˆ â„˜(Tâˆ) 'â†’ â„˜(Tâˆ)


(5)
fâ†’(T )  {v âˆˆ Tâˆ | v âˆˆ V
2
}âˆª âˆ’X

describing small steps of computation. We have



âˆ’âˆA	= lfpÂ± fâ†’ . 
The big-step and small-step trace semantics are the same
â†’S = âˆ’âˆA  .

Rule-based small-step maximal trace semantics
The maximal trace semantics â†’S = âˆ’âˆA = lfpÂ± fâ†’ where fâ†’ is defined by (5) can be defined inductively with small-steps as



v âˆˆ â†’S,	v âˆˆ V
a âˆ’A b,	b â€¢ Ïƒ âˆˆ â†’S
Â±
a â€¢ b â€¢ Ïƒ âˆˆ â†’S


that is, writing a Z â‡’ Ïƒ for Ïƒ âˆˆ â†’S and Ïƒ0 = a

 a âˆ’A b,	b  â‡’ Ïƒ 
Z â‡’ ,	âˆˆ V	a	a
Z â‡’	â€¢ Ïƒ

Small-step bifinitary relational semantics of the call- by-value Î»-calculus
The bifinitary relational semantics was defined as Ã±  Î±(â†’S) (where Î± is the relational abstraction of sets of traces (3)) and given in big-step form in Sec. 5. It can be given in small-step form by abstraction of the small-step bifinitary maximal trace semantics of Sec. 7.1.

Fixpoint small-step biï¬nitary relational semantics
The bifinitary relational semantics Ã±  Î±(â†’S)= Î±(lfpÂ± fâ†’) can be defined in fixpoint
form as lfpÂ± Ã± where the small-step transformer Ã±	(T Ã— (T âˆª {âŠ¥})) 'â†’ â„˜(T Ã—

f
(T âˆª {âŠ¥})) is
f âˆˆ â„˜


f (R)  {âŸ¨v, vâŸ© | v âˆˆ V}âˆª 
{âŸ¨(Î» x . a) v, râŸ© | v âˆˆ V âˆ§ âŸ¨a[x â† v], râŸ© âˆˆ R}âˆª 
{âŸ¨a0 b, râŸ© | a0 âˆ’A  a1 âˆ§ âŸ¨a1 b, râŸ© âˆˆ R}âˆª 
{âŸ¨v b0, râŸ© | b0 âˆ’A  b1 âˆ§ âŸ¨v b1, râŸ© âˆˆ R} .

Rule-based small-step biï¬nitary relational semantics
The bifinitary rule-base form is (a â‡’ b stands for âŸ¨a, b

â€” and r âˆˆ V âˆª {âŠ¥})




Conclusion


v â‡’ v,	v âˆˆ V
âŸ© âˆˆ S

a âˆ’A b,	b â‡’ r
Â±
a â‡’ r

Divergence/nonterminating behaviors are needed in static program analysis [18] or typing [3,15]. Such divergence information is part of the classical order-theoretic fixpoint denotational semantics [17] but not explicit in small-step/abstract-machine- based operational semantics [19,20,21] and absent of big-step/natural operational semantics [12]. A standard approach is therefore to generate an execution trace semantics from a (labelled) transition system/small-step operational semantics, using either an order-theoretic [4] or metric [23] fixpoint definition or else a categorical definition as a final coalgebra for a behaviour functor (modeling the transition relation) up to a weak bisimulation [11,14,22] or using an equational definition for re- cursion in an order-enriched category [13]. However, execution traces are not always at an appropriate level of abstraction. Finite and infinite behaviors can be both handled by SOS when extended to bi-inductive structural bifinitary small/big-step trace/relational/operational semantics. Sound (and sometimes complete) abstrac- tions are essential to establish this hierarchy of semantics [4]. This should satisfy the need for formal finite and infinite semantics, at various levels of abstraction and using various equivalent presentations (fixpoints, equational, constraints and inference rules) needed in static program analysis.
Acknowledgement
We thank the anonymous referees for their helpful comments and suggestions.

References
	P. Aczel. An introduction to inductive definitions. In J. Barwise, editor, Handbook of Mathematical Logic, volume 90 of Studies in Logic and the Foundations of Mathematics, pages 739â€“782. Elsevier, 1977.
I. Attali, J. Chazarain, and S. Gilette. Incremental evaluation of natural semantics specifications. In M. Bruynooghe and M. Wirsing, editors, Proc. 4th Int. Symp. PLILP â€™92, Leuven, BE, 26â€“28 Aug. 1992, LNCS 631, pages 87â€“99. Springer, 1992.
	P. Cousot. Types as abstract interpretations, invited paper. In 24th POPL, pages 316â€“331, Paris, FR, Jan. 1997. ACM Press.
P. Cousot. Constructive design of a hierarchy of semantics of a transition system by abstract interpretation. Theoret. Comput. Sci., 277(1â€”2):47â€“103, 2002.

	P. Cousot and R. Cousot. Systematic design of program analysis frameworks. In 6th POPL, pages 269â€“282, San Antonio, TX, 1979. ACM Press.


	P. Cousot and R. Cousot. Abstract interpretation frameworks. J. Logic and Comp., 2(4):511â€“547, Aug. 1992.
P. Cousot and R. Cousot. Inductive definitions, semantics and abstract interpretation. In 19th POPL, pages 83â€“94, Albuquerque, NM, US, 1992. ACM Press.
	P. Cousot and R. Cousot. Compositional and inductive semantic definitions in fixpoint, equational, constraint, closure-condition, rule-based and game-theoretic form, invited paper. In P. Wolper, editor, Proc. 7th Int. Conf. CAV â€™95, Li`ege, BE, LNCS 939, pages 293â€“308. Springer, 3â€“5 Jul. 1995.
Th. Despeyroux. TYPOL: a formalism to implement natural semantics. Tech. rep. RT-0094, INRIA Sophia Antipolis, Mar. 1988.
	C.A.R. Hoare. An axiomatic basis for computer programming. Comm. ACM, 12(10):576â€“580, Oct. 1969.
	B. Jacobs and J. Rutten. A tutorial on (co)algebras and (co)induction. EATCS Bulletin, 62:222â€“269, 1997.
	G. Kahn. Natural semantics. In K. Fuchi and M. Nivat, editors, Programming of Future Generation Computers, pages 237â€“258. Elsevier, 1988.
	B. Klin. Adding recursive constructs to bialgebraic semantics. J. Logic and Alg. Prog., 60-61:259â€“286, Jul.â€“Dec. 2004.
B. Klin. Bialgebraic methods in structural operational semantics. ENTCS, 175(1):33â€“43, May 2007.
	X. Leroy. Coinductive big-step operational semantics. In P. Sestoft, editor, Proc. 15th ESOP â€™2006, Vienna, AT, LNCS 3924, pages 54â€“68. Springer, 27â€“28 Mar. 2006.
	R. Milner. Operational and algebraic semantics of concurrent processes. In J. van Leeuwen, editor, Formal Models and Semantics, volume B of Handbook of Theoretical Computer Science, chapter 19, pages 1201â€“1242. Elsevier, 1990.
	P.D. Mosses. Denotational semantics. In J. van Leeuwen, editor, Formal Models and Semantics, volume B of Handbook of Theoretical Computer Science, chapter 11, pages 575â€“631. Elsevier, 1990.
A. Mycroft. The theory and practice of transforming call-by-need into call-by-value. In B. Robinet,
editor, Proc. 4th Int. Symp. on Programming, Paris, FR, 22â€“24 Apr. 1980, LNCS 83, pages 270â€“281. Springer, 1980.
G.D. Plotkin. A structural approach to operational semantics. Technical Report DAIMI FN-19, Aarhus University, DK, Sep. 1981.
	G.D. Plotkin. The origins of structural operational semantics. J. Logic and Alg. Prog., 60â€“61:3â€“15, Jul.â€“Dec. 2004.
	G.D. Plotkin. A structural approach to operational semantics. J. Logic and Alg. Prog., 60â€“61:17â€“139, Jul.â€“Dec. 2004.
D. Turi and G.D. Plotkin. Towards a mathematical operational semantics. In Proc. 12th LICS â€™1997, pages 280â€“291, Warsaw, PL, 29 June â€“ 2 Jul. 1997. IEEE Comp. Soc. Press.
F. van Breugel. An introduction to metric semantics: operational and denotational models for programming and specification languages. Theoret. Comput. Sci., 258:1â€“98, 2001.
