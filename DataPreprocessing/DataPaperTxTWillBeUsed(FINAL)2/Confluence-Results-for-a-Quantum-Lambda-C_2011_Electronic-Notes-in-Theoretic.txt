

Electronic Notes in Theoretical Computer Science 270 (2) (2011) 251–261
www.elsevier.com/locate/entcs
Confluence Results
for a Quantum Lambda Calculus with Measurements 1
Ugo Dal Lago2
Dipartimento di Scienze dell’Informazione Universit`a di Bologna
Andrea Masini3 Margherita Zorzi4
Dipartimento di Informatica Universit`a di Verona

Abstract
A strong confluence result for Q∗, a quantum λ-calculus with measurements, is proved. More precisely, confluence is shown to hold both for finite and infinite computations. The technique used in the confluence proof is syntactical but innovative. This makes Q∗ different from similar quantum lambda calculi, which are either measurement-free or provided with a reduction strategy.
Keywords: Quantum computation, lambda calculus, confluence


Introduction
It is well known that the measurement-free evolution of a quantum system is de- terministic. As a consequence it is to be expected that a good measurement-free quantum lambda calculus enjoys confluence. This is the case of Q, by the authors [4] and of the lambda calculus recently introduced by Arrighi and Dowek [1]. The sit- uation becomes more complicated if we introduce a measurement operator. In fact measurements break the deterministic evolution of a quantum system.

1 The authors are partially supported by PRIN project “CONCERTO” and FIRB grant RBIN04M8S8, “Intern. Inst. for Applicable Math.”
2 Email:dallago@cs.unibo.it
3 Email:andrea.masini@univr.it
4 Email:margherita.zorzi@univr.it

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.01.035

An explicit measurement operator in the syntax allows an observation at an intermediate step of the computation: this feature is needed if we want, for example, to write algorithms such as Shor’s factorization. In quantum calculi the intended meaning of a measurement is the observation of a (possibly superimposed) quantum bit, giving as output a classical bit; the two possible outcomes (i.e., the two possible values of the obtained classical bit) can be observed with two probabilities summing to 1. Since measurement forces a probabilistic evolution in the computation, it is not surprising that we need probabilistic instruments in order to investigate the main features of the language.
In this paper, we study an extension of Q obtained by endowing the language of terms with a suitable measurement operator and coherently extending the reduction relation, which becomes probabilistic for the reasons we have just explained. We investigate the resulting calculus, called Q∗, focusing, in particular, on confluence. In Q∗ and Q, states are formalized by conﬁgurations, i.e., triples in the form [Q, QV,M ], where M is a lambda term, Q is a quantum state, and QV is a set of names of quantum variables. So, control is classical (M is simply a term) while
data is quantum (Q is an element of a finite-dimensional Hilbert space).
We are interested in the following question: what happens to properties such as confluence in presence of measurements? And moreover: is it possible to preserve confluence in the probabilistic setting induced by measurements? Apparently, the questions above cannot receive a positive answer: as we will see in section 3, it is possible to exhibit a configuration C such that there are two different reductions starting at C and ending in two essentially different configurations in normal form [1, ∅, 0] and [1, ∅, 1]. In other words, confluence fails in its usual form. But the ques- tion now becomes: are the usual notions of computations and confluence adequate in this setting?
In Q∗, there are two distinct sources of divergence:
	On the one hand, a redex involving the measurement operator can be reduced in two different ways, i.e., divergence can come from a single redex.
	On the other hand, a term can contain more than one redex and Q∗ is not endowed with a reduction strategy. As a consequence, some configurations can be reduced in different ways due to the presence of distinct redexes in a term.
We cannot hope to be confluent with respect to the first source of divergence, but we can anyway ask ourselves whether all reduction strategies are somehow equivalent. More precisely, we say that Q∗ is confluent if for every configuration C and for every configuration in normal form D, there is a fixed real number p such that the probability of observing D when reducing C is always p, independently of the reduction strategy.
This notion of confluence can be easily captured by analyzing rewriting on mixed states rather than rewriting on configurations. A mixed state is a probabilistic distribution on configurations whose support is finite. Rewriting on configurations naturally extend to rewriting on mixed states. Rewriting on mixed states is not a probabilistic relation, and confluence is the usual confluence coming from rewriting theory [13].

In this paper, we prove that Q∗ is indeed confluent in this sense. Technically, confluence is proved in an innovative way. The key point is that we need a new definition of computation. The usual notion of computation as a sequence of con- figurations is not adequate here. A notion of probabilistic computation replaces it, as something more general than a linear sequence of configurations but less general than the reduction tree: a probabilistic computation is a (possibly) infinite tree, in which binary choice (a node can have at most two children) corresponds to the two possible outcomes of a measurement. This new notion of computation is needed, because proving confluence directly on mixed states is non-trivial. As by-products, we prove other results in the style of confluence.
Another important property of any quantum lambda calculus with measure- ments is the importance of infinite computations. In the case of standard lambda calculus, the study of infinite computations is strongly related to the study of infi- nite lambda terms. This is not the case of Q∗ (and in general of quantum calculi with measurements). This phenomenon forced us to extend the study of conflu- ence to the case of infinite probabilistic computations. The proposed analysis is not standard and is based on new techniques.
Up to our knowledge, the only paper about confluence in a quantum setting is [6]. The authors claim to have studied confluence for an extension of Van Ton- der’s quantum lambda calculus λq [14] obtained by endowing λq with explicit qubits and a family of measurement operators. The main result consists in showing that confluence and the consistency of the operational semantics hold in the extended calculus, here called λM , provided the same holds in λq. This could be a promis- ing result, weaker but similar to the one presented in this paper. In our opinion, however, [6] has some problems, which prevent us from properly evaluate it:
	The significance of the main result is not completely clear. The crucial point is that λM is not an extension of λq, the main difference being the absence of a strategy (see, for example, the proof of Theorem 3.13 in [6], where the authors assume that reduction can happen under the scope of a λ-abstraction or when the argument to a β-redex is not a value), whereas the reduction relation on λq is completely deterministic, since λq is a call-by-value-calculus [14]. Moreover, the syntax of λM seems to be more restrictive than the one of λq in some respects,
e.g. in λM “since measurement is linear, promotion to non-linear expression is disallowed” ([6], page 12, line 16) but in λq every term can be promoted (see [14], Figure 10).
	Some crucial definitions about the syntax of λM are ambiguous in [6]. The rules in Figure 2 allow to prove the well-formedness of syntactical objects which are not terms. Take, for example, the superposition rule: its conclusion is a syntactic object which cannot be derived from the rules in Figure 1, since e.g. !|0⟩ is not a qubit constant. Moreover, it seems that syntactic objects like t1 ⊗ t2 (where t1 and t2 are not qubit constants) cannot be terms. The authors themselves observed that in Note 1. Now, look at the definition of alice in Algorithm 2: what is ((Hr) ⊗ w)? It cannot be a term. Actually, we believe that λM as described in [6] cannot express the teleportation scheme.

The rest of this paper is structured as follow:
in Section 2 the quantum λ-calculus Q∗ is introduced;
in Section 3 we introduce the confluence problem in an informal way;
in Section 4 we give the definition of a probabilistic computation;
in Section 5 a strong confluence result on probabilistic computations is given;
	in Section 6 mixed states and mixed computations are introduced, and we give a confluence theorem for mixed computations.
An extended version with all proofs is available [3].
A Brief Introduction to Q∗
In [4] we have introduced a measurement–free, untyped quantum λ–calculus, called Q, based on the quantum data and classical control paradigm (see e.g. [10,11]). In this paper we generalize Q by extending the class of terms with a measurement operator, obtaining Q∗. Space limitations prevent us from being exhaustive, and when needed, we will make reference to our paper [4] and to the literature.
Q∗ is based on the notion of a conﬁguration, namely a triple [Q, QV,M ] where Q is a quantum register 5 , QV is a finite set of names, called quantum variables, and M is an untyped term based on the linear lambda-calculus defined by Wadler [15] and Simpson [12]. Conf denotes the set of all such configurations.
Quantum registers are systems of n qubits, that, mathematically speaking, are normalized vectors of finite dimensional Hilbert spaces. In particular, a quantum register Q of a configuration [Q, QV,M ], is a normalized vector of the Hilbert space l2({0, 1}QV ), denoted here with H(QV). 6 Roughly speaking, the reader not familiar with Hilbert spaces could think that quantum variables are pointers to qubits in the quantum register.
There are three kinds of operations on quantum registers: (i) the new oper- ation, responsible of the creation of qubits; (ii) unitary operators: each unitary operator U∗∗q1,...,qn⟩⟩ corresponds to a pure quantum operation acting on qubits with names q1,..., qn (mathematically, a unitary transform on the Hilbert space H({q1,..., qn}), see [4]); (iii) one qubit measurement operations Mr,0, Mr,1 re- sponsible of the probabilistic reduction of the quantum state plus the destruction of the qubit referenced by r: given a quantum register Q∈ H(QV), and a quantum variable name r ∈ QV, we allow the (destructive) measurement of the qubit with name r 7 .
The other main component of a configuration is a term. The set of terms is built from (i) a denumerable set of classical variables, ranged over by x, x0,.. .;

5 the “empty” quantum register will be denoted with the scalar number 1.
6 see [4] for a full discussion of H(QV) and [9] for a general treatment of l2(S) spaces.
7 More precisely, for every quantum variable r we assume the existence of two linear measurement operators, Mr,0, Mr,1 : H(QV) → H(QV − {r}) enjoying the completeness condition Mr,0†Mr,0 + Mr,1†Mr,1 = id H(QV) and such that, given a quantum register Q ∈ H(QV), the measurement of the qubit with name r in Q gives the outcome c (with c ∈ {0, 1}) with probability pc = ∗Q|Mr,c†Mr,c|Q⟩ and produces the new quantum register Mr,c Q ; see [8,7] for a detailed discussion of general pure measurements and [3] for
pc
formal definitions and detailed results about Mr,0 and Mr,1.

(ii) a denumerable set of quantum variables, ranged over by r, r0,.. .; (iii) a finite or at most denumerable set of names corresponding to unitary operators; (iv) the boolean constants 0, 1 and (v) the operators new and meas. An environment Γ is a (possibly empty) finite set in the form Λ, !Δ, where Λ is a (possibly empty) set of classical and quantum variables, and !Δ denote a (possibly empty) set of patterns
!x1,..., !xn. We impose that in an environment, each classical variable x occurs at most once (either as !x or as x). A judgement is an expression Γ ▶ M , where Γ is an environment and M is a term. We say that a judgement is well-formed if it is derivable by means of the well-forming rules in Figure 1.





!Δ ▶ C
const


!Δ,r ▶ r
qvar


!Δ,x ▶ x
cvar


!Δ, !x ▶ x
der

!Δ ▶ M


!Δ ▶!M

prom
Λ1, !Δ ▶ M  Λ2, !Δ ▶ N


Λ1, Λ2, !Δ ▶ MN 

app
Λ1, !Δ ▶ M1 ··· Λk, !Δ ▶ Mk

Λ1,..., Λk, !Δ ▶ ∗M1,..., Mk⟩

tens

Γ ▶ M

Γ ▶ new(M )

new
Γ, x1,..., xn ▶ M


Γ ▶ λ∗x1,..., xn⟩.M

lam1
Γ,x ▶ M


Γ ▶ λx.M

lam2
Γ, !x ▶ M


Γ ▶ λ!x.M

lam3

Γ ▶ M

Γ ▶ meas(M )

meas
Λ ▶ N  !Δ ▶ M1 !Δ ▶ M2
if
Λ, !Δ ▶ if N then M1 else M2



Fig. 1. Well–Forming Rules
Let L = {Uq, new, l.β, q.β, c.β, l.cm, r.cm, if1, if0, measr}. For every α ∈ L and

for every p ∈ R
[0,1]
, we define a relation →p ⊆ Conf × Conf by the set of rewriting

rules contractions in Figure 2, plus standard closure rules. The notation C →α D

stands for C →1
D. In order to be consistent with the so-called non-cloning and




[Q, QV, (λx.M )N ] →1
[Q, QV,M{N/x}]	[Q, QV, (λ!x.M )!N ] →1
[Q, QV,M{N/x}]

[Q, QV, (λ∗x1,..., xn⟩.M )∗r1,..., rn⟩] →1
[Q, QV,M{r1/x1,..., rn/xn}]

[Q, QV, if 1 then M1 else M2] →1
1
[Q, QV, if 0 then M1 else M2] →1
1
[Q, QV, M1]
[Q, QV, M2]

[Q, QV,U∗ri1 , ..., rin ⟩] →1
[U((ri1

,...,rin
⟩⟩Q, QV, ∗ri1 , ..., rin ⟩]

[Q, QV, meas(r)] →measr [Mr,c(Q), QV − {r}, !c]	(c ∈ {0, 1} and pc ∈ R	)
pc	[0,1]
[Q, QV, new(c)] →1 [Q⊗ |r '→ c⟩, QV ∪ {r}, r]	(r is fresh)

[Q, QV, L((λπ.M )N )] →1
[Q, QV, ((λπ.M )N )L] →1
[Q, QV, (λπ.LM )N ]
[Q, QV, (λπ.ML)N ]



Fig. 2. Contractions.
non-erasing properties, we adopt surface reduction [12,4]: reduction is not allowed in the scope of any ! operator. Furthermore, as usual, we also forbid reduction in N and P in the term if M then N else P . Observe that contractions include two commutative rules l.cm and r.cm (see Figure 2): they come from Q, where they were essential to get quantum standardization [4]. We distinguish three particular subsets

of L , namely K = {l.cm, r.cm}, N = L −(K ∪{measr}) and nM = L −{measr}. In the following, we write M →α N meaning that there are Q, QV, R and RV such that [Q, QV,M ] →α [R, RV,N ]. Similarly for the notation M →S N where S is a subset of L .
The Confluence Problem: an Informal Introduction
The confluence problem is central for any quantum λ-calculus with measurements, as stressed in the introduction.
Let us consider the following configuration:
C = [1, ∅, (λ!x.( if x then 0 else 1))(meas(H(new(0))))].
If we focus on reduction sequences, it is easy to check that there are two different reduction sequences starting with C, the first ending in the normal form [1, ∅, 0] (with probability 1/2) and the second in the normal form [1, ∅, 1] (with probability 1/2). But if we reason with mixed states, the situation changes: the mixed state
{1 : C} (i.e., the mixed state assigning probability 1 to C and 0 to any other configuration) rewrites deterministically to {1/2 : [1, ∅, 0], 1/2 : [1, ∅, 1]} (where both [1, ∅, 0] and [1, ∅, 1] have probability 1/2). So, confluence seems to hold.

Confluence in Other Quantum Calculi.
Contrarily to the measurement-free case, the above notion of confluence is not an expected result for a quantum lambda calculus. Indeed, it does not hold in the quan- tum lambda calculus λsv proposed by Selinger and Valiron [11]. In λsv , it is possible to exhibit a configuration C that gives as outcome the distribution {1 : [1, ∅, 0]} when reduced call-by-value and the distribution {1/2 : [1, ∅, 0], 1/2 : [1, ∅, 1]} if re- duced call-by-name. This is a real failure of confluence, which is there even if one uses probability distributions in place of configurations. The same phenomenon cannot happen in Q∗ (as we will show in Section 5): this fundamental difference can be traced back to another one: the linear lambda calculus with surface reduction (on which Q∗ is based) enjoys (a slight variation on) the so-called diamond prop- erty [12], while in usual, pure, lambda calculus (on which λsv is based) confluence only holds in a weaker sense.
Finite or infinite rewriting?
In Q∗, an infinite computation can tend to a configuration which is essentially differ- ent from the configurations in the computation itself. For example, a configuration C = [1, ∅,M ] can be built 8 such that:
after a finite number of reduction steps C rewrites to a distribution in the form

1 1<i≤n 2i
: [1, ∅, 0], 1 − Σ
1 1<i≤n 2i
: D}

only after infinitely many reduction steps the distribution {1: [1, ∅, 0]} is reached.

8 M ≡ (Y!(λ!f.λ!x if x then 0 else f (meas(H(new(0))))))(meas(H(new(0)))), where Y is a fix point op- erator.

Therefore finite probability distributions of finite configurations could be obtained by means of infinite rewriting. We believe that the study of confluence for infinite computations is important.

Related Work.
In the literature, probabilistic rewriting systems have been already analyzed. For example, Bournez and Kirchner [2] have introduced the notion of a probabilistic abstract rewriting system as a structure A = (|A|, [· ~ ·]) where |A| is a set and
[· ~ ·] is a function from |A| to R such that for every a ∈ |A|, Σ	[a ~ b] is
either 0 or 1. Then, they define a notion of probabilistic confluence for a PARS:
such a structure is probabilistically locally confluent iff the probability to be locally confluent, in a classical sense, is different from 0. Unfortunately, Bournez and Kirch- ner’s analysis does not apply to Q∗, since Q∗ is not a PARS. Indeed, the quantity

b∈|A|
[a ~ b] can in general be any natural number. Similar considerations hold

for the probabilistic lambda calculus introduced by Di Pierro, Hankin and Wiklicky
in [5].

A Probabilistic Notion of Computation
We represent computations as (possibly) infinite trees. In the following, a (possibly) infinite tree T will be an (n + 1)-tuple [R, T1,..., Tn], where n ≥ 0, R is the root of T and T1,..., Tn are its immediate subtrees.
Definition 4.1 A set of (possibly) infinite trees S is said to be a set of proba- bilistic computations if P ∈ S iff (exactly) one of the following three conditions holds:
P = [C] and C ∈ Conf .
P = [C, R], where C ∈ Conf , R ∈ S has root D and C →nM D
P = [(p, q, C), R, Q], where C ∈ Conf , R, Q ∈ S have roots D and E, C →p

q measr
E and p, q ∈ R
[0,1];

The set of all (respectively, the set of finite) probabilistic computations is the largest
set P (respectively, the smallest set F ) of probabilistic computations with respect to set inclusion. P and F exist because of the Knapster-Tarski Theorem.
We will often say that the root of P = [(p, q, C), R, Q] is simply C, slightly diverging from the above definition without any danger of ambiguity.
Definition 4.2 A probabilistic computation P is maximal if for every leaf C in P , C ∈ NF. More formally, (sets of) maximal probabilistic computations can be defined as in Definition 4.1, where clause 1 must be restricted to C ∈ NF.
We can give definitions and proofs over ﬁnite probabilistic computations (i.e., over F ) by ordinary induction. An example is the following definition. Notice that the same is not true for arbitrary probabilistic computations, since P is not a well-founded set.

Definition 4.3 Let P ∈ P be a probabilistic computation. A finite probabilistic computation R ∈ F is a sub-computation of P , written R ± P iff one of the following conditions is satisfied:
R = [C] and the root of P is C.
R = [C, Q], P = [C, S], and Q ± S.
R = [(p, q, C), Q, S], P = [(p, q, C), U,V ], Q ± U and S ± V .
Let δ : Conf → {0, 1} be a function defined as follows: δ(C) = 0 if the quantum register of C is 0, otherwise, δ(C)= 1.

Quantitative Properties of Computations.
The outcomes of a probabilistic computation P are given by the configurations which appear as leaves of P . Starting from this observation, the following definitions formalize some quantitative properties of probabilistic computations.
For every ﬁnite probabilistic computation P and every C ∈ NF we define P(P, C) ∈
R[0,1] and N (P, C) ≤ ℵ0 by induction on the structure of P :
P([C], C)= N ([C], C)=1 and P([C], D)= N ([C], D) = 0 whenever C /= D.
P([C, P ], D)= P(P, D) and N ([C, P ], D)= N (P, D).
P([(p, q, C), P, R], D)= pP(P, D)+qP(R, D) and N ([(p, q, C), P, R], D)= N (P, D)+
N (R, D).
Informally, P(P, C) is the probability of observing C as a leaf in P , and N (P, C) is the number of times C appears as a leaf in P .
The definitions above can be easily modified to get the probability of observing any configuration (in normal form) as a leaf in P , P(P ), or the number of times any configuration appears as a leaf in P , N (P ). Since R[0,1] and N ∪ {ℵ0} are complete lattices (with respect to standard orderings), we extend the above notions to the case of arbitrary probabilistic computations, by taking the least upper bound over all finite sub-computations. If P ∈ P and C ∈ NF, then P(P, C)= supR±P P(R, C), N (P, C) = supR±P N (R, C),	P(P ) = supR±P P(R),	N (P ) = supR±P N (R).
The quantities above exists because R[0,1] and N ∪ {ℵ0} are complete lattices.

A Strong Confluence Result
In this Section, we will give a strong confluence result in the following form: any two maximal probabilistic computations P and R with the same root have exactly the same quantitative and qualitative behaviour, that is to say, the following equations hold for every C ∈ NF:  P(P, C) = P(R, C), N (P, C) = N (R, C), P(P ) = P(R), and N (P )= N (R).
Remark 5.1 Please notice that equalities like the ones above do not even hold for the ordinary lambda calculus. For example, the lambda term (λx.λy.y)Ω is the root of two (linear) maximal computations, the first having one leaf λy.y and the second having no leaves. This is the reason why the confluence result we prove here is dubbed as strong.

Before embarking in the proof of the equalities above, let us spend a few words to explain their consequences. The fact P(P, C)= P(R, C) whenever P and R have the same root can be read as a confluence result: the probability of observing C is independent from the adopted strategy. On the other hand, P(P ) = P(R) means that the probability of converging is not affected by the underlying strategy. The corresponding results on N (·, ·) and N (·) can be read as saying that the number of (not necessarily distinct) leaves in any probabilistic computation with root C does not depend on the strategy.
Q∗ enjoys a form of quasi-one-step confluence. As an example, if C →N D and C →N E then there is F with D →N F and E →N F . If, on the other hand, C →N D and C →K E then either E →N D or there is F as above. As another interesting example, if C →N D and C →measr E then there is F as above. The only problematic case is when C →measr D and C →measr E, which cannot be solved. Lack of space prevents us from formally stating and proving quasi-one- step confluence, which can anyway be found in [3]. Quasi-one-step confluence is an essential ingredient towards strong confluence. Unfortunately, quasi-one-step confluence does not translate into an equivalent result on mixed states, because of commutative reduction rules. As a consequence, it is more convenient to first study confluence at the level of probabilistic computations.
We define the weight W(P ) and the branch degree B(P ) of every ﬁnite proba- bilistic computation P by induction on the structure of P :
W([C]) = 0 and B([C]) = 1.
B([C, P ]) = B(P ).  Moreover, let D be the root of P .  If C →K  D, then
W([C, P ]) = W(P ), otherwise W([C, P ]) = B(P )+ W(P ).
B([(p, C), P, R]) = B(P )+B(R), while W([(p, C), P, R]) = B(P )+B(R)+W(P )+
W(R).
Please observe that B(P ) ≥ 1 for every P .
Now we propose a probabilistic variation on the classical strip lemma of the λ- calculus. It will have a crucial rˆole in the proof of strong confluence (Theorem 5.4).
Lemma 5.2 (Probabilistic Strip Lemma) Let P be a ﬁnite probabilistic com- putation with root C and positive weight W(P ).
	If C →N D, then there is R with root D such that W(R) < W(P ), B(R) ≤ B(P ) and for every E ∈ NF, it holds that P(R, E) ≥ P(P, E), N (R, E) ≥ N (P, E), P(R) ≥ P(P ) and N (R) ≥ N (P ).
	If C →K D, then there is R with root D such that W(R) ≤ W(P ), B(R) ≤ B(P ) and for every E ∈ NF, it holds that P(R, E) ≥ P(P, E), N (R, E) ≥ N (P, E), P(R) ≥ P(P ) and N (R) ≥ N (P ).

q
measr
D and C →p
E, then there are R and Q with roots D and E such

that W(R) < W(P ), W(Q) < W(P ), B(R) ≤ B(P ), B(Q) ≤ B(P ) and for every
E ∈ NF, it holds that qP(R, E)+ pP(Q, E) ≥ P(P, E), N (R, E)+ N (Q, E) ≥
N (P, E), qP(R)+ pP(Q) ≥ P(P ) and N (R)+ N (Q) ≥ N (P ).
Proof. By induction on the structure of P . The proof can be found in [3].	 
The following Proposition follows from the probabilistic strip lemma. It can be

read as a simulation result: if P and R are maximal and have the same root, then
P can simulate R (and vice versa).
Proposition 5.3 For every maximal probabilistic computation P and for every ﬁ- nite probabilistic computation R such that P and R have the same root, there is a ﬁnite sub-computation Q of P such that for every C ∈ NF, P(Q, C) ≥ P(R, C) and N (Q, C) ≥ N (R, C). Moreover, P(Q) ≥ P(R) and N (Q) ≥ N (R).
Proof. The proof goes by induction on (W(R), nR), ordered lexicographically. De- tails can be found in [3].	 
The main theorem is the following:
Theorem 5.4 (Strong Confluence) For every maximal probabilistic computa- tion P, for every maximal probabilistic computation R such that P and R have the same root, and for every C ∈ NF, P(P, C)= P(R, C) and N (P, C)= N (R, C). Moreover, P(P )= P(R) and N (P )= N (R).
Proof. See [3].	 
Computing with Mixed States
Definition 6.1 A mixed state is a function M : Conf → R[0,1] such that there is a finite set S ⊆ Conf with M (C) = 0 except when C ∈ S and, moreover,

C∈S
M (C)= 1. Mix is the set of mixed states.

In this paper, a mixed state M will be denoted with the linear notation {p1 : C1,..., pk : Ck} or as {pi : Ci}1≤i≤k, where pi is the probability M (Ci) associated to the configuration Ci, and where {C1,..., Ck} is the set S of the above definition.
Definition 6.2 The reduction relation e⇒= between mixed states is defined in the following way: {p1 : C1,..., pm : Cm} e⇒= M iff there exist m mixed states

M1 = {qi : Di }1≤i∈n ,..., Mm = {qi
: Di }1≤i≤n
such that:

1	1	1	m	m	m
For every i ∈ [1, m], it holds that 1 ≤ ni ≤ 2;
If ni = 1, then either Ci is in normal form and Ci = D1 or Ci →nM D1;

If n
= 2, then C →p	D1, C →q
D2, p, q ∈ R
i	i
, and q1 = p, q2 = q;

i	i	meaΣsr m i	i	measr	i
[0,1]	i	k

∀D ∈ Conf . M (D)=	i=1 pi · Mi(D).
Given the reduction relation e⇒=, the corresponding notion of computation (that we call mixed computation, in order to emphasize that mixed states play the role of configurations) is completely standard.
Given a mixed state M and a configuration C ∈ NF, the probability of observing C in M is defined as M (C) and is denoted as P(M, C). Observe that if M e⇒= MJ and C ∈ NF, then P(M, C) ≤ P(MJ, C). If {Mi}i<ϕ is a mixed computation, then
sup P(Mi, C)
i<ϕ
always exists, and is denoted as P({Mi}i<ϕ, C).

Please notice that a maximal mixed computation is always infinite. Indeed, if
M = {pi : Ci}1≤i≤n and for every i ∈ [1, n], Ci ∈ NF, then M e⇒= M .
Proposition 6.3 Let {Mi}i<ω be a maximal mixed computation and let C1,..., Cn
be the conﬁgurations on which M0 evaluates to a positive real. Then there are maxi-
mal probabilistic computations P1,..., Pn with roots C1,..., Cn such that supj<ϕ Mj(D)= 

n i=1
(M0(Ci)P(Pi, D)) for every D.

Proof. See [3].	 
Theorem 6.4 For any two maximal mixed computations {Mi}i<ω and {MJ}i<ω
such that M0 = MJ, the following condition holds: for every C ∈ NF, P({Mi}i<ω, C)= 
P({MJ}i<ω, C)
Proof. A consequence of Proposition 6.3.	 

References
P. Arrighi and G. Dowek. Linear-algebraic lambda-calculus: higher-order, encodings, and confluence. In
A. Voronkov, editor, Rewriting techniques and applications, volume 5117 of Lecture Notes in Comput. Sci., pages 17–31. Springer, 2008.
O. Bournez and C. Kirchner. Probabilistic rewrite strategies. Applications to ELAN. In Rewriting techniques and applications, volume 2378 of Lecture Notes in Comput. Sci., pages 252–266. Springer, Berlin, 2002.
U. Dal Lago, A. Masini, and M. Zorzi. Confluence results for a quantum lambda calculus with measurements. 2009. Available from http://arxiv.org/abs/0905.4567.
U. Dal Lago, A. Masini, and M. Zorzi. On a measurement-free quantum lambda calculus with classical control. Mathematical Structures in Computer Science, 19(2):297–335, April 2009.
A. Di Pierro, C. Hankin, and H. Wiklicky. J. Logic Comput., 15(2):159–179, 2005.
A. D´ıaz-Caro, P. Arrighi, M. Gadella, and J. Grattage. Measurements and confluence in quantum lambda calculi with explicit qubits. Available from http://arxiv.org/abs/0806.2447v2, 2008.
P. Kaye, R. Laflamme, and M. Mosca. An introduction to quantum computing. Oxford University Press, Oxford, 2007.
M. A. Nielsen and I. L. Chuang. Quantum computation and quantum information. Cambridge University Press, Cambridge, 2000.
S. Roman. Advanced linear algebra, volume 135 of Graduate Texts in Mathematics. Springer, New York, third edition, 2008.
P. Selinger. Towards a quantum programming language. Mathematical Structures in Computer Science, 14(4):527–586, 2004.
P. Selinger and B. Valiron. A lambda calculus for quantum computation with classical control. Math. Structures Comput. Sci., 16(3):527–552, 2006.
A. Simpson. Reduction in a linear lambda-calculus with applications to operational semantics. In Term rewriting and applications, volume 3467 of Lecture Notes in Comput. Sci., pages 219–234. Springer, Berlin, 2005.
Terese. Term rewriting systems, volume 55 of Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, Cambridge, 2003.
A. van Tonder. A lambda calculus for quantum computation. SIAM J. Comput., 33(5):1109–1135 (electronic), 2004.
P. Wadler. A syntax for linear logic. In Mathematical foundations of programming semantics (New Orleans, LA, 1993), volume 802 of Lecture Notes in Comput. Sci., pages 513–529. Springer, Berlin, 1994.
