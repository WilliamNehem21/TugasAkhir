Electronic Notes in Theoretical Computer Science 130 (2005) 401–418 
www.elsevier.com/locate/entcs


Integrating Time and Resource into Circus 1
Geguang Pu, Qiu Zongyan2
LMAM and Department of Informatics, School of Math.
Peking University, Beijing 100871, China
He Jifeng2
International Institute for Software Technology, United Nations University Macau, China

Abstract
In this paper, a formal model is introduced for reasoning about resource allocation and scheduling in real-time systems. We extend the concurrent refinement language Circus [19] through integrating continuous time and resource information. This model reflects resource issues when modelling the behavior of a system, and allows temporal properties to be accurately determined. We also apply the model to the problem of partitioning in co-design, and show how the partitioned programs preserve the behavior of the specification correctly.
Keywords: Timed Circus, UTP, resource reasoning, denotational semantics.


Introduction
The timing behavior of real-time systems depends on not only process syn- chronization, but also the availability of resources provided by systems. Many timed models are proposed for the design and verification of real-time systems, for example, TAM [15], Timed CSP [2], Timed CCS [17,9], TCOZ [12] and Real-Time Refinement [4]. These models have the implicit assumption that unbounded resources are available. However, in practice, real-time systems are

1 Supported by NNSF of China (No.60173003).
2 Email: ggpu@math.pku.edu.cn, zyqiu@pku.edu.cn, jifeng@iist.unu.edu



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.03.020


always restricted by the resources. To deal with this problem, researchers pro- posed some methods to combine real-time programs with the scheduling and resource allocation, and thus, to facilitate the reasoning about systems that are sensitive to deadlines, process communication and resource availability.
Gerber and Lee [3] proposed a language CCSR, to reason about resource requirements in real-time systems. Their model is operational, based on CCS and extended to model priorities. Gavin Lowe [8] proposed a compositional denotational model based on TAM [15]. This model can reason about sched- ulers which allocate resources to tasks. The model is only suitable to analyze asynchronous systems, as TAM is an asynchronous language. Jin and He [7] proposed a hierarchy of resource models to handle the resource allocation and reclamation. However, their models are relatively abstract, and is not compo- sitional.
In this paper we present a series of semantic models that can reason about resource allocation in real-time systems. The models are based upon Circus, a well-defined specification language combining the features of CSP and Z. Circus has a formal semantics based on the Unifying Theories of Program- ming(UTP) [5]. We extend the core languages of Circus by adding time infor- mation for reasoning about real-time programs. Moreover, we introduce the resource information into the model, and make it possible in analyzing the resource allocation of real-time systems, for example, the resource conflict, where two parallel programs access the same resource simultaneously.
Sherif and He [16] did the first step to add time into Circus, and they used discrete time in their model. Though discrete time models are easily imple- mented by computer systems, it is more natural to adopt the continuous time as the nature of time in the real world is continuous. Like other studies, such as TAM [15], Real-Time Refinement [4], Timed CSP [2], we use continuous time in our models and go further than [16]. When integrating time into Cir- cus, a number of healthiness conditions are posed on the continuous model in order to specify its correct behavior.
This paper is organized as follows. Section 2 describes the semantic space adopted in our models. Continuous time is integrated into Circus in Section
3. Section 4 introduces two resource models based on the time model, and explores the relations among them. In Section 5, we present an example from co-design field to show how these models are applied to verify the correctness of program. We conclude in Section 6 with a discussion on future work.

Semantic Space for Timed Circus
To define a time model, we adopt a simple language CT , which is a subset of Circus and introduced in [16]. For simplicity, we only consider actions, guarded commands and assignment as the basic actions, other constructs of the lan- guage, such as abstractions and declarations, have little effect over the model. CT is also extended with timed structures, such as idle d, deadline d, idle etc. The informal description about CT will be given later with the semantics. The syntax of CT is as follows:
Action	::=Skip | Stop | Chaos | idle d | idle
| deadline d | widle d
| Communication → Action | b & Action
| Action; Action | Action  Action | Action H Action
| Action |[ CS ]| Action | Action \ CS | Command
| [d] Action | µ N • Action
Communication::=N CParameter∗ CParameter	::=? N | ! e | . e
Command	::=N+ := e | Action  b D Action
The semantic space is introduced here. The continuous time is adopted to express the behaviors of the system at the design stage. Moreover, through the appropriate mapping from continuous model to discrete one, the system specification can be implemented by computers. We use the similar semantic space from [5]. The behaviors of Timed Circus are defined by means of pred- icative semantics. Here are some observational variables used in our models.
ok, ok ': when boolean variable ok is true, the program has been properly started, ok = false means that the program has never started and even the initial state is unobservable; ok ' = true means that the current state of pro- gram is stable. It can distinguish the stable case of program from the one with infinitely internal computation.
wait, wait ': boolean variable wait can tell waiting state of program from its terminated state. If wait ' is true, the program stays in intermediate observa- tions, and does not terminate, otherwise, it reaches in terminated state.
t : time is modelled by nonnegative real numbers:
Time =^ {r : R | 0 ≤ r < ∞}
where R is the set of real numbers including infinities, and operators on the reals are extended to allow infinite arguments. We use t and t ' to represent


the start time and current time respectively, and allow t ' to take the value infinity.
t ' ∈ Time∞ =^ Time ∪ {∞}
v : variable v is modelled as a function from time to value. With the adoption of continuous time, the super dense computation might be involved, which means at time point t , a number of computation steps may take place. To deal with this phenomenon, the value of v at t is designed artificially as a pair of observations, v (t ) = ⟨e1, e2⟩, where e1 and e2 are called the left value and right value of v at time t , and denoted as v (t ).l and v (t ).r respectively. The possibly internal values between e1 and e2 are invisible. The similar technique was used in [10]. For simplicity, we also use v to represent a list of program variables.
tr , ref : variable tr records the communications of a program with its envi- ronment, tr ∈ TR = Time → Seq (Time × Event ). tr (t ) records the his- toric observations happened so far, which is a sequence of timed events. A timed event (t, e) denotes the observation of event e at time t . For example, tr (3.2) = ⟨(1, a), (2, b), (3.2, c)⟩ means that there are 3 events already hap- pened up to time point 3.2, where events a, b and c take place at time 1, 2 and 3.2 respectively. To track the set of events refused by a program, we introduce ref ∈ Time → P(Event ) to model the set of events refused at time t .
Denotational Semantics of Timed Circus
Healthiness Conditions
In this section, we introduce some healthiness conditions, which distinguish feasible descriptions of reality from infeasible ones. Healthiness conditions can reject a specifications if it makes implementation demonstrably impossible in the target programming languages. We list four healthiness conditions which are satisfied by all feasible Timed Circus programs. Some predicates which will be used in this paper are defined as follows:
flow (t, tr ) =^ t ≤ t ' ∧∃ tr0 ∈ TR • tr (t ')= tr (t ) - tr0 ∧
∀ t1, t2 ∃ n ∈ N • t ≤ t2 ≤ t1 ≤ t ' ⇒ (#tr (t1) − #tr (t2)) ≤ n
flow (t, tr ) asks that no program can ever make time go backwards or change what did happen before it starts. Condition (#tr (t1) − #tr (t2)) ≤ n ensures that no infinitely many events can occur within a finite interval of time.
stable(w ) =^ w (t ')= w (t )


stable(w ) denotes that timed variable w keeps the same from the at the start and current time. As our semantics is based on observations, the start and current states of program are interested and the middle states between them are not observable. w can be a list of variables.
Four healthiness conditions are introduced as follows.
H1. P = P ∧ flow (t, tr )
It states that any timed Circus program should satisfy predicate flow (t, tr ).
H2. P = (¬ok ∧ flow (t, tr )) ∨ P
If the program has never started, the initial values are even unobservable.
H3. P = II  wait D P

where II
=^ (¬ok ∧ flow (t, tr )) ∨ (ok ' ∧ stable(tr , v, ref ) ∧ wait' = wait )

This condition enables the sequential composition to work normally. As all intermediate observations of P are also the intermediate observations of P ; Q , only when P terminates, the control can be passed to Q .
H4. P = P ∨ P [false/ok ']
This condition is designed for the upward closure of variable ok '. It formally encodes the fact that we cannot require a process to abort.
Property 1. P = P ∨ P [false/ok '] iff [P [false/ok '] ⇒ P [true/ok ']]
Proof: P = P ∨ P [false/ok ']
≡ P [false/ok ']= P [false/ok '] ∨ P [false/ok '] ∧
P [true/ok ']= P [true/ok '] ∨ P [false/ok ']
≡ P [true/ok ']= P [true/ok '] ∨ P [false/ok ']
≡ [P [false/ok '] ⇒ P [true/ok ']]	 
The following property introduces another form for healthiness condition
H4.
Property 2. [P [false/ok '] ⇒ P [true/ok ']] iff P = P ; J ,
where J = (ok ⇒ ok ') ∧ stable(tr , ref , v ) ∧ wait ' = wait
We use H (P ) to denote that program P satisfies all the healthiness conditions. Notice that P satisfying a healthiness condition means that P is a fixed point of an equation corresponding to the condition. For example, If P satisfies H1, H2 and H3, it is a fixed point of R1, R2 and R3 respectively
R1(X ) =^ X ∧ flow (t, tr )
R2(X ) =^ (¬ok ∧ flow (t, tr )) ∨ X

R3(X ) =^ II  wait D X
From Properties 1 and 2, when P satisfies H4, it is a fixed point of R4 R4(X ) =^ X ; J
By means of these constructions of equation, we have the following theorem.
Theorem 3.1 All predicates which satisfy the four healthiness conditions form a complete lattice.
Proof: As all predicates form a complete lattice in the implication ordering, according to Tarski’s fixed point theorem and the commutativity of the idem- potents Ri (i = 1, 2, 3, 4), the set of fixed points of monotonic functions Ri (i = 1, 2, 3, 4) on a complete lattice is also a complete lattice.	 
In the following subsections, the semantics of Timed Circus is given. We use [P ]]t to denote the timed semantics of program P .

Basic Actions
Action Skip terminates immediately and does not change any timed variables. [[Skip]] =^ H (ok ' ∧ ¬wait ' ∧ stable(tr , v ) ∧ t = t ')
Action Stop just waits for ever and does not communicate with its environ- ment. It does not change any timed variables as well.
[[Stop]] =^ H (ok ' ∧ wait ' ∧ stable(tr , v ))
The behavior of action Chaos is totally unpredictable. We denote it as true. [[Chaos]]t =^ H (true)
Assignment v := e does not consume time and updates the right value of v
at time t simultaneously.
[[v := e]] =^ H (ok ' ∧ ¬wait ' ∧ stable(tr ) ∧ v (t ').r = e[v/v (t ).l ] ∧ t = t ')

Timed Actions
Timed actions are introduced here. They are somewhat interesting. Action
idle d just consumes d time units and has no effect on state variables.

[[idle d ]]t
=^ H (((ok ' ∧ wait ' ∧ t ' − t < d ) ∨ (ok ' ∧ ¬wait ' ∧ t ' − t = d ))
∧ stable(tr , v ))  d < ∞ D [[Stop]]t

Action idle may take time and the behavior is similar to that of action idle d .

[[idle]]t =^ ∃ d • [[idle d ]]t
If two programs have the same behaviors, but run in different speed, we prefer the fast program to the slow one on the performance. But for two simple programs, idle 3 and idle 4, we cannot conclude that idle 3 is better than idle 4 from the definition of [idle d ]]t . To solve this problem, we introduce a weak idle operation and denote it as widle d :
[[widle d ]]t =^ ∃ e ≤ d • [[idle e]]t
From this definition, the following implication ordering is valid. [[widle 3]]t ⇒ [[widle 4]]t
The deadline action allows a time deadline to be specified. The check of
deadline can be embedded in program compiler to ensure whether the deadline is met by the generated code. This suggests that a timing path analysis is required to show the deadline action always finishes before its deadline. If t ' is greater than d when executing the deadline action, the behavior of the program is like Chaos.

[[deadline d ]]t
=^ H ((ok ' ∧ ¬wait ' ∧ stable(v, tr ) ∧ t = t '))
  (t ' ≤ d ) D H (true)

The action [d ]P executes P but gives it a deadline of d , this means that we are interested only in those executions of P that terminate before time d . In terms of the deadline action, we can easily define it:
[[[d ]P ]]t =^ [[P ; deadline d ]]t
The definition of sequential composition will be given later.
Communication Actions
Here we model the behavior of communication actions. The state of c!e has two possible behaviors: one is in waiting state (maybe in deadlock if event c is in ref ), the other is to communicate with its ready partner and terminates.
[[c!e]]t =^ ( [idle]]t ∧ H (c ∈/ ref (t ))) ∨
H (ok ' ∧ ¬wait ' ∧ tr (t ')= tr (t ) - ⟨t ', c⟩∧ 
stable(v ) ∧ t ' = t + ε)
The behavior of c?v is similar to c!v , except that it changes the variable v on termination.


[[c?v ]]t =^ ( [idle]]t ∧ H (c ∈/ ref (t ))) ∨
H (ok ' ∧ ¬wait ' ∧ tr (t ')= tr (t ) - ⟨t ', c⟩∧ 
v (t ').r = e[v/v (t ).l ] ∧ t ' = t + ε)
We introduce symbol ε to denote a very short time period the communication actions consume, in order to separate two consecutive events. We assume mε< a for all reasonable m ∈ N (set of natural numbers) and a ∈ R+. Thus, ε is regarded as a kind of “infinitesimal”. The similar view is taken implicitly in Timed CSP [2].

Composition
Conditional Choice. The conditional choice P b D Q executes P if b evaluates as true, otherwise executes Q instead. We assume that the evalua- tion of b takes no time. Actually, this assumption can be removed by adding idle action before P and Q respectively.
[[P  b D Q ]]t =^ (b ∧ [[P ]]t ) ∨ (¬b ∧ [[Q ]]t )
Sequential Composition. As all predicates under consideration satisfy the healthiness condition H2, we can follow the standard definition of sequential composition in relational calculus, with some small modifications for the super dense computation. The sequential composition connects the right values of variables in P to the left values of them in Q .
[[P ; Q ]]t =^ [[P ]]t ◦ [[Q ]]t
[[P ]] ◦ [[Q ]] =^ ∃ ok0, wait0, t0, v0 • [[P (ok ', wait ', t ', v (t ').r/ok0, wait0, t0, v0)]]
∧ [[Q (ok, wait, t, v (t ).l/ok0, wait0, t0, v0)]]t
For example, from this definition, we can prove the equation like follows: [[v := v + 1; v := v + 2 ]t = [[v := v + 3 ]t
Two assignments take place at the same time, and according to the definition
of sequential composition, the middle state is hidden from observers.
Guarded Action. A guarded action is enabled only if the condition g holds. If g holds, the action behaves as P ; otherwise it behaves like Stop. We also assume the evaluation of g does not consume time.
[[g &P ]]t =^ [[P  g D Stop]]t


Internal Choice. Internal choice denotes the non-determinism of the obser- vations. It is a very important concept in the design of parallel programs.
[[P H Q ]]t =^ [[P ]]t ∨ [[Q ]]t
External Choice. The behavior of an external choice can be observed in two points: before the choice is made and after the choice is made. Before the choice, the system is in waiting state and only internal actions can take place. Moreover, an event is refused only if it is refused by both P and Q . After the choice is made, the rest of the behavior is described by either that of P or Q, depending on which action corresponds to the first event.
[[P  Q ]]t =^ ( [P ]]t ∧ [[Q ]]t ∧ [[idle]]t )

'
∨ ([[P ]]t ∨ [[Q ]]t ∧ H (¬wait
∨ ¬stable(tr )))

Recursion. From Theorem 3.1, all the Timed Circus actions form a com- plete lattice with respect to the implication relation. So we can define the recursion as a weakest fixed point of set {X | X ⇒ F (X )}, that is,
µ X • F (X ) =^ H {X | X ⇒ F (X )}
Hiding. When the set cs of events is hidden, any event in cs is hidden from the environment, then, events in cs take place automatically and instantaneously without any additional conditions. Hiding operator \ defined as follows

[[P \ cs]]t
=^ H (∃ tr0, ref0 • [[P ]] [tr0, ref0/tr (t '), ref (t ')] ∧
tr (t ') − tr (t )= (tr0 − tr (t )) T (Event − cs) ∧ ref (t')= ref0 ∪ cs)

T is the restriction operator defined in CSP, and Event is the set of all events.


Parallel Composition
The parallel composition is a little complicated. It is defined in terms of the merge parallel composition introduced in [5]. The parallel composition of two actions terminates whilst both components do. The action idle in the following definition just plays a role for this observation.
[[P |[ cs ]| Q ]]t =^ ∃ tr0 • H (tr0 = tr (t )) ∧ (([[P ; idle]]t  M (cs) [[Q ]]t ) ∨
([[P ]]t  M (cs) [[Q ; idle]]t ))
Operation M (cs) merge the separate copies of the shared variables in P and Q into the final values, where cs represents the set of events the two components should synchronize on. The merge operation is defined as follows,

M (cs) =^ H ( ok ' = (0.ok ∧ 1.ok )
∧	wait ' = (0.wait ∨ 1.wait )
∧	v (t ')= 0.v (t ) ⊕ 1.v (t )
∧	ref (t ') = ((0.ref (t ) ∪ 1.ref (t )) ∩ cs) ∨ ((0.ref (t ) ∩ 1.ref (t )))

∧	(tr (t ') − tr ) ∈ (0.tr (t ) − tr 
1.tr (t ) − tr0)

∧	t ' = t )
Note that the merging style between variables is based on the definition of merging operator ⊕ for some specific application. Now we define the operator
m . We use tr1 and tr2 to stand for two traces. Let xi (i = 1, 2...) denote members of cs, and yi (i = 1, 2...) denote events that do not belong to cs. Operator m is defined by following rules:
tr1 m tr2 = tr2 m tr1
⟨⟩ m ⟨⟩ = {⟨⟩}
⟨⟩ m ⟨(t2, x )⟩ = {}
⟨⟩ m ⟨(t2, y )⟩ = ⟨(t2, y )⟩
⟨(t1, x )⟩ - tr1 m ⟨(t2, y )⟩ - tr2 = {⟨(t2, y )⟩ - tr3 | tr3 ∈ ⟨(t1, x )⟩ - tr1
 m tr2}	if t2 ≥ t1
⟨(t1, x )⟩ - tr1 m ⟨(t2, y )⟩ - tr2 = {}	if t2 < t1
⟨(t, x )⟩ - tr1 m ⟨(t, x )⟩ - tr2 = {⟨(t, x )⟩ - tr3 | tr3 ∈ tr1 m tr2}
⟨(t1, x )⟩ - tr1 m ⟨(t2, x )⟩ - tr2 = {}	if t1 /= t2
⟨(t1, x1)⟩ - tr1 m ⟨(t2, x2)⟩ - tr2 = {}	if x1 /= x2
⟨(t, y1)⟩ - tr1 m  ⟨(t, y2)⟩ - tr2 = {⟨(t, y1)⟩ - tr3 | tr3 ∈ tr1
 m ⟨(t, y2)⟩ - tr2}∪ {⟨(t, y2)⟩ - tr3 | tr3 ∈ ⟨(t, y1)⟩ - tr1 m ⟨(t, y2)⟩ tr2}
⟨(t1, y1)⟩ - tr1 m ⟨(t2, y2)⟩ - tr2 = {⟨(t1, y1)⟩ - tr3 | tr3 ∈ tr1
 m ⟨(t2, y2)⟩ - tr2}  t1 < t2 D {⟨(t2, y2)⟩ - tr3 | tr3 ∈ ⟨(t1, y1)⟩ - tr1
 m ⟨(t2, y2)⟩ tr2}

Properties of Timed Circus Actions
The following theorem shows that the healthy actions are closed under se- quential composition, disjunction, conjunction, external choice, and parallel.

Theorem 3.2 The set of Timed Circus actions is a {∧, ∨, ; ,  , |[cs]|}-closure

for four healthiness conditions.
Proof: Here we prove only the closure property of conjunction.
H1
P ∧ Q ∧ flow (t, tr )
= P ∧ Q ∧ flow (t, tr ) ∧ flow (t, tr )
= (P ∧ flow (t, tr )) ∧ (Q ∧ flow (t, tr )) = P ∧ Q
H2
(P ∧ Q ) ∨ (¬ok ∧ flow (t, tr ))
= (P ∨ (¬ok ∧ flow (t, tr )) ∧ Q ∨ (¬ok ∧ flow (t, tr ))) = P ∧ Q
H3
II  wait D (P ∧ Q )
=(II  wait D P ) ∧ (II  wait D Q )= P ∧ Q
H4
(P ∧ Q ) ∨ (P ∧ Q )[false/ok ']
= (P ∧ Q ) ∨ (P [false/ok '] ∧ Q [false/ok '])
= ((P ∧ Q ) ∨ P [false/ok ']) ∧ ((P ∧ Q ) ∨ Q [false/ok '])
= ((P ∨ P [false/ok ']) ∧ (Q ∨ P [false/ok '])) ∧
((P ∨ Q [false/ok ']) ∧ Q ∨ P [false/ok '])
= (P ∧ (Q ∨ P [false/ok '])) ∧ (Q ∧ (P ∨ Q [false/ok ']))
= (P ∧ Q ) ∧ (Q ∨ P [false/ok ']) ∧ (P ∨ Q [false/ok ']) ⇒ (P ∧ Q )
Therefore
P ∧ Q = (P ∧ Q ) ∨ (P ∧ Q )[false/ok ']	 
The next theorem shows that initial value of tr (t ) in the predicates may be replaced by an arbitrary one.

Theorem 3.3 If P is an action in timed Circus, then P satisﬁes the condition
P (tr (t ), tr (t ')) = .	P (s, s - ⟨tr (t ') − tr (t )⟩).	 

Resource Model in Timed Circus
In this section, we extend the model of the previous section in order to rep- resent the resources used by actions. Two resource models are proposed here, one is an unlimited resource model, and the other is a limited resource model. The latter is a natural extension of the former. In the unlimited model, we assume resources in the real-time environment are enough for the execution of any action.


The usage of resource r during time interval [t, t '] is denoted by ⟨[t, t '], r, n⟩, which means that n units of resource r is used in time interval [t, t']. Formally, we define the space TResource as
TResource =^ Interval × Rname × N
where Interval denotes time interval, Rname is a set of resource names.
Two observable variables Rre and Rav are used in our models, which stand for the resources required by an action, and the resources available, respectively. To compute Rre, a function φ is introduced to calculate the resources required by actions. It can be regarded as a global scheduler to monitor resource occupation. For example, if action P requires one unit of r1 and two units of r2 during execution in time interval [t, t '], we have Rre = φ(t )= {⟨[t, t '], r1, 1⟩, ⟨[t, t '], r2, 2⟩}. The definition of φ depends on not only the real environment, but also the command executed at the time. Fox example, x := 1 and x := x + 1 take different resource during their execu- tion. The later requires an adder to perform the action, while the former only involves memory update. For simplicity, single parameter t is referred by function φ. When the resource models are used to analyze real-time systems, a concrete definition of φ should be given.
Rav ∈ P(Resource) where Resource is Resource =^ Rname × N

Unlimited Resource Model
We use [P ]]ut to denote the semantics of action P under the unlimited re- source model. Most of the definitions here are simple extensions of ones in the previous section.
Basic Actions. Actions Skip, Stop do not consume resources: [[Skip]]	=^ H (ok ' ∧ ¬wait ' ∧ stable(tr , v ) ∧ t = t ' ∧ Rre = ∅) [[Stop]]	 =^ H (ok ' ∧ wait ' ∧ stable(tr , v ) ∧ Rre = ∅)
The behavior of Chaos is totally unpredictable, and also has no predication on resources. We denote it as true.
[[Chaos]]ut =^ H (true)
Assignment uses resources φ(t ) in the execution

[[v := e]]ut
=^ H (ok ' ∧ ¬wait ' ∧ stable(tr ) ∧ v (t ').r = e[v/v (t ).l ]
∧ t = t ' ∧ Rre = φ(t ))

Timed Actions. The deadline timed actions do not consume resources, but other timed actions may need resources during execution. For example, idle d may consume CPU resources, even it does not make any progress.



[[idle d ]]ut
=^ H (((ok ' ∧ wait ' ∧ t ' − t < d ) ∨ (ok ' ∧ ¬wait ' ∧ t ' − t = d ))
∧ stable(tr , v ) ∧ Rre = φ(t ))  d < ∞ D [[Stop]]t

[[deadline d ]]ut
=^ H (ok ' ∧ ¬wait ' ∧ t = t ' ∧ stable(tr , v ) ∧ Rre = ∅)
  (t ' ≤ d ) D H (true)

Communication Actions. The behaviors of communication actions are similar to those in the time model, except that they consume resources.
[[c!e]]  =^ ( [idle]] ∧ H (c ∈/ ref (t '))) ∨
H (ok ' ∧ ¬wait ' ∧ tr (t ')= tr (t ) - ⟨(t ', c)⟩
∧ stable(v ) ∧ t ' = t + ε ∧ Rre = φ(t )) [[c?v ]] =^ ( [idle]] ∧ H (c ∈/ ref (t '))) ∨
H (ok ' ∧ ¬wait ' ∧ tr (t ')= tr (t ) - ⟨(t ', c)⟩∧ Rre = φ(t )
∧ t ' = t + ε ∧ v (t ').r = e[v/v (t ).l ])
Sequential Composition. The resource requirements of sequential compo- sition are the union of the resource requirements of the two components.

[[P ; Q ]]ut =^ ∃ ok0, wait0, t0, v0 Rre1, Rre2 •
[[P (ok ', wait ', t ', v (t ').r , Rre/ok0, wait0, t0, v0, Rre )]] ∧
1  t
[[Q (ok, wait, t, v (t ).l , Rre /ok0, wait0, t0, v0, Rre2 )]]t ∧
H (Rre = Rre1 ∪ Rre2)
Parallel Composition. We only need to modify the merge operation defined in the time model.
M (cs) =^ H (ok ' = (0.ok ∧ 1.ok ) ∧ wait ' = (0.wait ∨ 1.wait )
∧ v (t ')= 0.v (t ) ⊕ 1.v (t )
∧ ref (t ') = ((0.ref (t ) ∪ 1.ref (t )) ∩ cs) ∨ ((0.ref (t ) ∩ 1.ref (t )))

∧ (tr (t ') − tr0) ∈ (0.tr (t ) − tr0 
∧ t ' = t ∧ Rre = 0.Rre ∪ 1.Rre)
1.tr (t ) − tr0)

Other composition operators, such as conditional, nondeterministic choice, recursion, are the same with those defined in the time model.

Limited Resource Model
The assumption that the resources are unlimited is somehow unreasonable in reality, because it is not true in many cases. A limited resource model can be formalized as an extension of the unlimited model. We use [P ]]lt to denote the semantics of P in limited resource model. We only need to modify the definitions of basic actions and some composition structures.


Operator Lea(Rre) returns the name and the amount of the resources re- quired. For instance, Lea({⟨[t, t '], r1, 1⟩, ⟨[t, t '], r2, 2⟩})= {⟨r1, 1⟩, ⟨r2, 2⟩}. Let Patom be those atomic actions, including basic and communication actions etc. We define:

[[Patom ]]lt
=^ ( [Patom ]]ut
∧ H (R'
= Rav − Lea(Rre)))

  (Lea(Rre) ⊆ Rav ) D [[Stop]]t
We just modify the definitions of sequential and parallel compositions by adding in the information of Rav . The final value of Rav in P is also passed on as the initial value of Rav in Q, which is only an intermediate state of P ; Q and unobservable by the environment. The following is the modified definition of sequential composition for limited resource model.
[[P ; Q ]]lt =^ ∃ ok0, wait0, t0, v0 Rre1, Rre2 Rav0 •
[[P (ok ', wait ', t ', v (t ').r , Rre, R' /ok0, wait0, t0, v0, Rre , Rav0)]] ∧
av	1	t
[[Q (ok, wait, t, v (t ).l , Rre , Rav /ok0, wait0, t0, v0, Rre2 , Rav0)]]t ∧
H (Rre = Rre1 ∪ Rre2)
The merge operation in parallel composition needs to be modified as well:
M (cs) =^ H (ok ' = (0.ok ∧ 1.ok ) ∧ wait ' = (0.wait ∨ 1.wait )
∧ v (t ')= 0.v (t ) ⊕ 1.v (t )
∧ ref (t ') = ((0.ref (t ) ∪ 1.ref (t )) ∩ cs) ∨ ((0.ref (t ) ∩ 1.ref (t )))
∧ t ' = t ∧ Rre = 0.Rre ∪ 1.Rre
∧ (R' = 0.Rav ∪ 1.Rav − Rav )  (Lea(Rre ) ⊆ Rav ) D [[Stop]] )
t
As the shared variable Rav is replaced by two variables 0.Rav and 1.Rav , we need to subtract the initial value of Rav in the merge operation.

Reﬁnement of Programs
The development of a program is often split into a series of steps, each of which focuses on different requirements. For example, the initial design may care about the functional requirements of the specification, and the time and resource requirements come afterwards. [16] discussed how to separate func- tional requirements of real-time program from the time model, and pointed out that the time model and untime model form a Galois Connection by con- structing a pair of left and right adjoint functions. To analyze timed and resource model, we have the following theorem, which shows that program P in resource model preserves the behaviors of it in the corresponding time model.
Theorem 4.1 [[P ]]ut ⇒ [[P ]]t

Proof: By structural induction.	 
This theorem shows that a resource model can be regarded as a refinement of the time model, if we neglect variable Rre . From the definition of the limited resource model, we have the following lemma:
'
Lemma 4.2 [[P ]]lt ⇒ (([[P ]]ut	= Rav − Lea(Rre ))
  (Rav ⊇ Lea(Rre)) D [[Stop]]t )	 
From above lemma, we have the following theorem disclosing the relation between limited resource model and unlimited resource model.
Theorem 4.3 (Rav ⊇ Lea(Rre )) ⇒ ([[P ]]lt ⇒ [[P ]]ut )	 
That is, if the resources in the system are enough for a program P , the behavior of P is the same as that of P in the unlimited resource model.

Case Study
In this section, we will show how the semantic model with resources can be applied to verify the correctness of specifications in the field of co-design, specially the hardware/software partitioning stage. Co-design studies sys- tematically design of systems containing both hardware/software components. Hardware/software partitioning is one of the key steps in co-design [18], which intends to partition a specification into hardware and software components. Most of the approaches proposed earlier are based on heuristic searching [14,11]. One of the key problem here is to preserve the behavior of the specification after partitioning. Some authors introduce algebraic methods to handle this issue [13,6], but they did not consider, for example, time and resources. We can use our resource models to verify the correctness of the partitioning pro- cess.
Here we adopt a simple model of partitioning. Suppose a specification contains a series of actions. The partitioning divides these actions into two sets, where actions belong to each set are put into software and hardware respectively. The actions in software and hardware need to communicate with each other.
To justify our method, we use a simple example. The initial specification
is:
IniSpe =^ x := 1; x := x + 2; widle 3; widle 4; y := x +1 The partitioned program is as follows:
Progra =^ ((x := 1; x := x + 2; widle 3; c!x → Skip) |[ c ]| (c?m → Skip; widle 4; y := m + 1)) \ {c}


Suppose the left side of the parallel structure is put into the software, and the right side into the hardware. As c is an internal event, it is hidden from the environment. Suppose the total resources in hardware is 10 units known in ad- vance. The assignment and weak idle actions both consume one unit of control resources, and communication action consumes two units of control resources in hardware. If a program is put into software, the resources consumed are regarded as memory. Here we assume that the memory resources are enough for the program. Now we would like to identify the following implication:
[[Progra]]lt ⇒ [[IniSpe]]t
As (Lea(Req ) ⊆ Rav ) is satisfied, from Theorem 4.1, we need to prove: [[Progra]]ut ⇒ [[IniSpe]]t
For simplicity, we omit the healthiness function H in the following proof. From
the definition of composition operator, we have
[[x := 1; x := x + 2; widle 3; widle 4; y := x + 1 ]t
= [[x := 1; x := x + 2 ]t ◦ [[widle 3; widle 4; y := x + 1 ]t
= (∃ t0, v0 • ok ' ∧ ¬wait ' ∧ v0 =1 ∧ t0 = t ∧ x (t ').r = v0 +2 ∧ t ' = t0) ◦
[[widle 3; widle 4; y := x + 1 ]t
= (ok ' ∧ ¬wait ' ∧ x (t ').r = 3) ◦ [[widle 3; widle 4; y := x + 1 ]t
= ok ' ∧ ¬wait ' ∧ x (t ').r =3 ∧ y (t ').r =4 ∧ (t ' − t ) ≤ 7 ∧ stable(tr )
As the initial specification does not involve communication, the refusal set need not to be considered. By the definition of the merging operator, we have
[[Progra]]ut
= [[(x := 3; widle 3; c!x → Skip)]]ut  M (cs)
[[c?m → Skip; widle 4; y := m + 1 ]ut \ {c}
⇒ (ok ' ∧ ¬wait ' ∧ x (t ').r =3 ∧ y (t ').r =4 ∧ t ' − t ≤ 4+ ε ∧
tr (t ') − tr (t )= {(tm, c)}∧ ref (t ')= ref (t )) \ {c}	{def. of hiding}
⇒ ok ' ∧ ¬wait ' ∧ x (t ').r =3 ∧ y (t ').r =4 ∧
t ' − t ≤ 4+ ε ∧ stable(tr )	{t ' − t ≤ 4+ ε ⇒ t ' − t ≤ 7}
⇒ ok ' ∧ ¬wait ' ∧ x (t ').r =3 ∧ y (t ').r =4 ∧ t ' − t ≤ 7 ∧ stable(tr )
Thus, we have verified that the final partitioning result is a refinement of the initial specification, that is, [Progra]]lt ⇒ [[IniSpe]]t . The behavior of Progra is similar to that of IniSpe except that it might run faster.

Discussion and Conclusion
In this paper, we proposed an approach to integrate time and resource infor- mation into the specification language Circus, which can help us to analyze and reason about resource in real-time systems. We also give an example from co-design field to show that the model can be used to prove the correctness of refinements. A proof-assistant tool is being developed based on our semantic model.
In these limited resource models, an implicit assumption is that the re- sources provided by environment are not reusable, as the required resources of process P are removed from the available resources. However, in the real- ity, the characters of resource and the policies of management do diverse. In many cases resources can be reused, or some kinds of resources can, others can’t. How to integrate different kinds of resources into the timed model is an interesting topic as well.
Another issue we would like to do in the next step is to give a set of refinement laws for our models. Circus is a good language for refinements [19]. Woodcock and Cavalcanti [1] discussed the refinement strategy for Circus. The refinement laws enable us to develop the program more easily, and to make the procedure of verification of the real-time systems automatically. We hope to develop a set of refinement laws based upon our models as one part of the future work.
Acknowledgement: The authors wish to thank Dr.Tang Xinbei for her help- ful comments on the draft.

References
Cavalcanti, A. L. C., A. Sampaio and J. C. P. Woodcock, A reﬁnement strategy for Circus, Formal Aspects of Computing 15 (2003), pp. 146–181.
Davies, J. and S. Schneider, A brief history of timed CSP, Theoretical Computer Science 30
(1995), pp. 243–271.
Gerber, R. and I. Lee, Speciﬁcation and analysis of resource-bound real-time systems, in: Proceedings of Real-Time: Theory in Practice (1992), pp. 371–396.
Hayes, I. J., Reasoning about real-time repetitions: terminating and nonterminating , Science of Computer Programming 43 (2002), pp. 161–192.
Hoare, C. A. R. and J. He, “Unifying Theories of Programming,” Prentice-Hall International, 1998, 1th edition.
Iyoda, J., A. Sampaio and L. Silva, ParTS: A partitioning transformation system, in: World Congress on Formal Methods 1999 (1999), pp. 1400–1419.
Jin, N. and J. He, Resource Semantic Models for Programming Languages, Technical Report 277, UNU-IIST (2003).


Lowe, G., Scheduling-oriented models for real-time systems. , The Computer Journal 38 (1995),
pp. 443–456.
Moller, F. and C. Tofts, A temporal calculus of communicating systems, in: Proceedings of Concur ’90(LNCS 458) (1990), pp. 401–415.
Pandya, P. K., H. Wang and Q. Xu, Toward a theory of sequential hybrid program, in: Proceedings of PROCOMET’98, 1998, pp. 366–384.
Pu, G., D. V. Hung, J. He and Y. Wang, An optimal approach to hardware/software partitioning for synchronous model, in: IFM 2004(LNCS 2999) (2004), pp. 363–381.
Qin, S., J. S. Dong and W.-N. Chin, A semantic foundation for TCOZ in unifying theories of programming, in: FME 2003(LNCS 2805) (2003), pp. 321–340.
Qin, S. and J. He, An algebraic approach to hardware/software partitioning, in: Proc. of the 7th IEEE International Conference on Electronics, Circuits and Systems (2000), pp. 273–276.
Quan, G., X. Hu and G. W. Greenwood, Preference-driven hierarchical hardware/software partitioning, in: Internatitional conference on Computer Design (1999), pp. 652–657.
Scholefield, D., H. Zedan and J. He, A speciﬁcation oriented semantics for the reﬁnement of real-time systems , Theoretical Computer Science 131 (1994), pp. 219–241.
Sherif, A. and J. He, Towards a time model for Circus, in: Proceedings of the 4th International Conference on Formal Engineering Methods (LNCS 2495) (2002), pp. 613–624.
Wang, Y., Real-time behaviour of asynchronous agents , in: Proceedings of Concur ’90(LNCS 458) (1990), pp. 502–520.
Wolf, W., Hardware-Software co-design of embedded system , Proc. of the IEEE 82 (1994),
pp. 967–989.
Woodcock, J. C. P. and A. L. C. Cavalcanti, The semantics of Circus , in: ZB2002(LNCS 2272)
(2002), pp. 184–203.
