

Electronic Notes in Theoretical Computer Science 229 (5) (2011) 97–117
www.elsevier.com/locate/entcs

Idioms are Oblivious, Arrows are Meticulous, Monads are Promiscuous
Sam Lindley, Philip Wadler and Jeremy Yallop1
Laboratory for Foundations of Computer Science, School of Informatics, University of Edinburgh, 10 Crichton Street, Edinburgh EH8 9AB, United Kingdom

Abstract
We revisit the connection between three notions of computation: Moggi’s monads, Hughes’s arrows and McBride and Paterson’s idioms (also called applicative functors). We show that idioms are equivalent to arrows that satisfy the type isomorphism A ~ B ' 1 ~ (A → B) and that monads are equivalent to arrows that satisfy the type isomorphism A ~ B ' A → (1 ~ B). Further, idioms embed into arrows and arrows embed into monads.
Keywords: applicative functors, idioms, arrows, monads




idi,o,ms
static tcarrows


,˛	 arrows ,˛	 
mon,,ads
ct
higher-order arrows

(A~B ' 1 ~ (A → B))	(A~B ' A → (1 ~B))

Fig. 1. Idioms, arrows and monads
Introduction
Assumptions and guarantees
The Internet Robustness Principle states [3]
Be conservative in what you do; be liberal in what you accept from others.
In other words, robust systems make the weakest possible assumptions about input and give the strongest possible guarantees about output.  Programs that

1 Email: Sam.Lindley@ed.ac.uk, wadler@inf.ed.ac.uk, J.D.Yallop@ed.ac.uk

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.02.018

accept only integers are less flexible than programs that accept all kinds of number. Contrariwise, programs that may output any kind of number are less flexible than programs that are guaranteed to output only integers.
To follow the principle we need to know which sets of values generalise which other sets. While there are certainly more numbers than integers, the ordering is not so obvious at higher-order types, such as function and computation types. Can a program that manipulates arrow computations be made more flexible by specifying that the input must be an idiom rather than an arrow ? Can a library that exposes an idiom instance be made more flexible by exposing an arrow instance instead? In his original work on arrows [1], Hughes shows how each monad gives rise to an arrow, and gives an extended arrow interface, ArrowApp, that is equivalent to the monad interface. In their later work introducing idioms (also called applicative functors) [6], McBride and Paterson show how to obtain an idiom from either a monad or an arrow, and how to combine an idiom and an arrow to yield another arrow. However, the precise relationship between the three notions of computation has remained obscure. In particular, McBride and Paterson informally describe idioms as
an abstract notion of effectful computation lying between Arrow and Monad in strength
which we show in the following pages to be mistaken: idioms are, in fact, weaker than both arrows and monads. The diagram in Figure 1 gives a high-level view of the situation: idioms correspond to a language which may be extended to obtain arrows; a further extension yields a language corresponding to monads.
The main contributions of this paper are:
A presentation of idioms, arrows and monads as variations on a single calculus.
A precise characterisation of the relationship between the three notions of computation which shows that, in contrast to the folklore ordering, idioms are less powerful than arrows.
The remainder of this paper is organised as follows. Section 2 introduces the notion of equational equivalence, a generalisation of equational correspondence [11]. Section 3 defines standard equational theories corresponding to idioms, arrows and monads, and a more convenient equational theory for arrows which highlights how arrows meticulously maintain the distinction between terms and commands. Sec- tion 4 gives an informal comparison of the expressive power of the three notions of computation by means of an example. Section 5 presents idioms as a variant of arrows, characterised by either a type isomorphism or an additional equation, in which commands are oblivious to input. Section 6 presents monads as a variant of arrows, characterised by either a type isomorphism or an additional operator and accompanying equations, which allay the distinction between terms and commands, resulting in a promiscuous admixture. Section 7 concludes.

Preliminaries
Definition 2.1 A typed equational theory T consists of the following
variables x, y, z
types A, B, C
terms L, M, N
type environments Γ ::= ·| x : A, Γ
typing judgements Γ ▶T M : A
equational judgements Γ ▶T M = N : A
Equational judgements must be well-formed: if Γ ▶T M = N : A then Γ ▶T M : A and Γ ▶T N : A. We present the equational judgements via laws relating terms, writing M = N as shorthand for Γ ▶T M = N : A for all Γ,A in T such that Γ ▶T M : A and Γ ▶T N : A. The equational theory is defined as the contextual and equivalence closure of the laws.
Definition 2.2 Let S, T be equational theories, with a compositional translation on terms and types J−) from S to T that preserves typing,
Γ ▶S M : A implies JΓ) ▶T JM ) : JA)

for all Γ, M,A in S, and with an inverse translation ⟨[−]⟩ from T to S that also preserves typing,
Γ ▶T M : A implies ⟨[Γ]⟩ ▶S ⟨[M ]⟩ : ⟨[A]⟩
for all Γ, M,A in T . Further, translating a type from S to T and back yields a type isomorphic to the original type,
fA : A ' ⟨[JA)]⟩
for all A in S (that is, for each type A a pair of functions on terms fA : A → ⟨[JA)]⟩
and f−1 : ⟨[JA)]⟩ → A in S such that f−1(fA(M )) =S M for all M of type A and
A	A
fA(f−1(N )) =S N for all N of type ⟨[JA)]⟩). Similarly, translating a type from T to
S and back yields a type isomorphic to the original type,
gA : A ' J⟨[A]⟩)
for all A in T . We say these translations form an equational equivalence (S ∼ T ) if
The translation from S to T preserves equations,
Γ ▶S M = N : A implies JΓ) ▶T JM ) = JN ) : JA)
for all Γ, M, N,A in S.
The translation from T to S preserves equations,
Γ ▶T M = N : A implies ⟨[Γ]⟩ ▶S ⟨[M ]⟩ = ⟨[N ]⟩ : ⟨[A]⟩

for all Γ, M, N,A in T .
Translating from S to T and back yields a term isomorphic to the original term,
Γ ▶S M : A implies Γ ▶S ⟨[JM )]⟩[Γ := f (Γ)] = fA(M ): ⟨[JA)]⟩
writing f (Γ) for fA1 (x1),..., fAn (xn), given Γ = x1 : A1,..., xn : An.
Translating from T to S and back yields a term isomorphic to the original term, Γ ▶T M : A implies Γ ▶T J⟨[M ]⟩)[Γ := g(Γ)] = gA(M ): J⟨[A]⟩)
(This definition amounts to saying that we have an equivalence of categories [5], where J−) is left adjoint to ⟨[−]⟩ with unit fA and counit g−1.)
Note that in general this definition does not require the isomorphisms to be terms of the object languages. Indeed, there is no requirement that the object languages include function types. However, for reasons of simplicity we will use object-language terms for the isomorphisms defined in this paper.
The special case of an equational equivalence where both isomorphisms are the identity is an equational correspondence.
Definition 2.3 An equational correspondence between theories S and T (S ∼= T ) is an equational equivalence with translations J−) : S → T, ⟨[−]⟩ : T → S where both fA and gA are the identity at each type A. (This amounts to saying that we have an isomorphism of categories [5] given by the translations J−) : S → T and
⟨[−]⟩ : T → S.)
We also introduce the notion of equational embedding, a map from a weaker into a stronger theory. An equational embedding of a theory S into a theory T may be defined as an equational equivalence between S and a subtheory of T . We will instead use the following more direct definition, which is more convenient in practice.
Definition 2.4 Let S, T be equational theories with a compositional translation on terms and types J−) from S to T that preserves typing,
Γ ▶S M : A implies JΓ) ▶T JM ) : JA)
for all Γ, M,A in S, and with an inverse compositional translation ⟨[−]⟩ from JS) to
S that also preserves typing,
JΓ) ▶T JM ) : JA) implies ⟨[JΓ)]⟩ ▶S ⟨[JM )]⟩ : ⟨[JA)]⟩
for all Γ, M,A in S. Further, translating a type from S to T and back yields a type isomorphic to the original type,
fA : A ' ⟨[JA)]⟩
for all A in S. We say these translations form an equational embedding of S into T
(S ‹→ T ) if

The translation from S to T preserves equations,
Γ ▶S M = N : A implies JΓ) ▶T JM ) = JN ) : JA)
for all Γ, M, N,A in S.
The translation from JS) to S preserves equations,
JΓ) ▶T JM ) = JN ) : JA) implies ⟨[JΓ)]⟩ ▶S ⟨[JM )]⟩ = ⟨[JN )]⟩ : ⟨[JA)]⟩ for all Γ, M, N,A in S.
Translating from S to JS) and back yields a term isomorphic to the original term,
Γ ▶S M : A implies Γ ▶S ⟨[JM )]⟩[Γ := f (Γ)] = fA(M ): ⟨[JA)]⟩
writing f (Γ) for fA1 (x1),..., fAn (xn), given Γ = x1 : A1,..., xn : An.
We further say that an equational embedding of S into T is strict if there exists no equational embedding of T into S.
The following proposition allows us to view an equational embedding as half an equational equivalence.
Proposition 2.5 Let S, T be equational theories. There is an equational equiva- lence between S and T iff there is an equational embedding of S into T and an equational embedding of T into S.
Proof. Given an equational equivalence J−), ⟨[−]⟩, f,g between S and T , it is im- mediate that J−), ⟨[−]⟩,f is an equational embedding of S into T and ⟨[−]⟩, J−),g is an equational embedding of T into S. The converse is more interesting.
Suppose the translations a : S → T , b : a(S) → S and type isomorphism c : A ' b(a(A)) form an equational embedding of S into T , and similarly the translations p : T → S, q : p(T ) → T and type isomorphism r : A ' q(p(A)) form an equational embedding of T into S. Then
JA) = q(p(a(A)))
JM ) = q(p(a(M )))
⟨[A]⟩ = b(a(p(A)))
⟨[M ]⟩ = b(a(p(M )))
f : A ' b(a(p(q(p(a(A)))))) fA(M )= cp(q(p(a(A))))(p(ra(A)(a(M ))))

f−1(M )= c−1(b(r−1
(r−1
(q(c−1
(M ))))))

A	A	a(A)
q(p(a(A)))
p(q(p(a(A))))

g : A ' q(p(a(b(a(p(A)))))) gA(M )= ra(b(a(p(A))))(a(cp(A)(p(M ))))

g−1 = r−1(q(c−1
(c−1
(b(r−1
(M ))))))

A	A	p(A)
b(a(p(A)))
a(b(a(p(A))))

form an equational equivalence between S and T .	 

Theories
This section outlines theories for simply-typed lambda calculus extended with pairs and unit: λ→×1, idioms: I, monads: M and two different theories for arrows: C and A.
Figure 2 (page 7) gives a standard definition of the theory of typed lambda calculus extended with pairs and unit, λ→×1. We use this definition as a starting point for each of the theories which follow. For convenience we define a number of functions, such as id.
Figure 3 (page 8) defines the theory of idioms, I [6]. Idioms extend λ→×1 with a unary type constructor I for computations of type I A which return a value of type
A. There are two constants: pure, which takes a value and constructs a computation which returns the value, and (⊗), which combines two computations, applying the value returned by the first to the value returned by the second. There are four laws which, together with the laws of the lambda calculus, define the equivalence relation of the theory. For idioms to serve as a useful programming language we would additionally need constants for constructing basic computations. These play no significant role in the theory, so we omit them here.
Figure 4 (page 8) defines the theory of arrows [1,9], C, which (following [4]) we refer to as classic arrows. Classic arrows extend λ→×1 with a binary type construc- tor ~ for computations with input and output and three constants for creating and composing computations. The first constant, arr, constructs a computation from a function. The second, (>>>), combines two computations, passing the output of the first as input to the second. The third, ﬁrst, transforms a computation to pass through additional data untouched. These primitives make it possible to construct a wide range of combinators for computations. Finally, there are nine laws which, together with the laws of the lambda calculus, define the equivalence relation of the theory.
Figure 5 (page 9) defines the arrow calculus A [4]. Arrow calculus extends λ→×1 with four constructs satisfying five laws. As with C, the type A ~ B denotes a computation that accepts a value of type A and returns a value of type B, possibly performing some side effects. There are now two syntactic categories: terms, ranged over by L, M, N , and commands, ranged over by P, Q, R. In addition to the terms of λ→×1, there is one new term form: arrow abstraction λ•x. Q. There are three command forms: arrow application L • M , arrow unit [M ] (analogous to arr), and arrow bind let x = P in Q.
In addition to the term typing judgement Γ ▶ M : A we now also have a command typing judgement
Γ; Δ ▶ P ! A.
An important feature of the arrow calculus is that the command typing judgement has two environments, Γ and Δ, where variables in Γ come from ordinary lambda abstractions λx. N , while variables in Δ come from arrow abstractions λ•x. Q. The

Types	A, B, C ::= B| 1 | A × B | A → B
Terms	L, M, N ::= x | ⟨⟩| ⟨M, N⟩| fst L | snd L | λx. N | L M 
Environments	Γ	::= x1 : A1, ..., xn : An


Types

(x : A) ∈ Γ

Γ ▶ ⟨⟩ :1 



Γ ▶ x : A


Γ ▶ M : A	Γ ▶ N : B
Γ ▶ L : A × B
Γ ▶ L : A × B


		


Γ ▶ ⟨M, N⟩ : A × B
Γ ▶ fst L : A
Γ ▶ snd L : B


Γ, x : A ▶ N : B	Γ ▶ L : A → B	Γ ▶ M : A

Γ ▶ λx. N : A → B	Γ ▶ L M : B
Definitions


id : A → A
id = λx. x
dup : A → A × A
dup = λx. ⟨x, x⟩
swap : A × B → B × A
swap = λz. ⟨snd z, fst z⟩
fst : A × B → A
fst = λz. fst z
snd : A × B → B
snd = λz. snd z
(×) : (A → C) → (B → D) → (A × B → C × D)
(×) = λf. λg. λz. ⟨f (fst z),g (snd z)⟩
(·) : (B → C) → (A → B) → (A → C)
(·) = λf. λg. λx. f (g x)
(;) : (A → B) → (B → C) → (A → C)
(;) = λf. λg. λx. g (f x)
assoc : (A × B) × C → A × (B × C)
assoc = λz. ⟨fst (fst z), ⟨snd (fst z), snd z⟩⟩
apply : ((A → B) × A) → B
apply = λz. (fst z (snd z))



Laws

(β×)	fst ⟨M, N⟩ = M
(β×)	snd ⟨M, N⟩ = N
(η×)	⟨fst L, snd L⟩ = L
(β→)	(λx. N ) M = N [x := M ]
(η→)	λx. (L x) = L
(η1)	⟨⟩ = M

Fig. 2. Lambda calculus, λ→×1



Syntax Constants

Types	A, B, C ::= ··· | I A 

pure : A → I A 
(⊗) : I (A → B) → I A → I B 



Laws

(I1)	u = pure id ⊗ u
(I2)	pure f ⊗ pure p = pure (f p)
(I3)	u ⊗ (v ⊗ w) = pure (·) ⊗ u ⊗ v ⊗ w
(I4)	u ⊗ pure x = pure (λf. f x) ⊗ u

Fig. 3. Idioms, I


Syntax
Types	A, B, C ::= ··· | A ~ B


Constants

arr : (A → B) → (A ~ B)
(>>>) : (A ~ B) → (B ~ C) → (A ~ C)
ﬁrst : (A ~ B) → (A × C ~ B × C)



Definitions

second : (A ~ B) → (C × A ~ C × B)
second = λf. arr swap >>> ﬁrst f >>> arr swap
(&&&)	: (C ~ A) → (C ~ B) → (C ~ A × B) (&&&)	= λf. λg. arr dup >>> ﬁrst f >>> second g



Laws

(~1)	arr id >>>f = f
(~2)	f >>> arr id = f
(~3)	(f >>> g) >>>h = f >>> (g >>> h)
(~4)	arr (g · f ) = arr f >>> arr g
(~5)	ﬁrst (arr f ) = arr (f × id)
(~6)			ﬁrst (f >>> g) = ﬁrst f >>> ﬁrst g (~7)	ﬁrst f >>> arr (id × g) = arr (id × g) >>> ﬁrst f (~8)		ﬁrst f >>> arr fst = arr fst >>>f 
(~9)	ﬁrst (ﬁrst f ) >>> arr assoc = arr assoc >>> ﬁrst f
Fig. 4. Arrows, C

Types	A, B, C ::= ··· | A ~ B
Terms	L, M, N ::= ··· | λ•x. Q
Commands	P, Q, R  ::= L • M | [M ] | let x = P in Q
Types


Γ; x : A ▶ Q ! B


Γ ▶ λ•x. Q : A ~ B
Γ ▶ L : A ~ B	Γ, Δ ▶ M : A

Γ; Δ ▶ L • M ! B

Γ, Δ ▶ M : A



Γ; Δ ▶ [M ]! A

Γ; Δ ▶ P ! A	Γ; Δ, x : A ▶ Q ! B

Γ; Δ ▶ let x = P in Q ! B

Laws
(β~)	(λ•x. Q) • M = Q[x := M ]
(η~)	λ•x. (L • x) = L
(left)	let x = [M ] in Q = Q[x := M ]
(right)	let x = P in [x] = P
(assoc)	let y = (let x = P in Q) in R = let x = P in (let y = Q in R)

Fig. 5. The arrow calculus, A


meticulousness of the title refers to the careful maintenance of this distinction in the typing rules.
Figure 6 (page 10) defines the theory of monads, M [8]. Like idioms, monads extend λ→×1 with a unary type constructor M for computations of type M A which return a value of type A. The constant return is analogous to the idiomatic pure, while >>= constructs a computation from a computation and a computation- constructing function, supplying the value returned by the former as argument to the latter. (We might just as well have used Moggi’s computational metalanguage [8] instead of adding constants to C, but we chose to define constants for consistency with our treatment of idioms and classic arrows.)
We find it convenient to use the arrow calculus rather than classic arrows as a basis for comparison. The following result allows us to move freely between the two

Syntax
Types	A, B, C ::= ··· | M A 


Constants

return : A → M A 
(>>=) : M A → (A → M B) → M B 

Laws
(M1)	return a >>= f = f a 
(M2)	m >>= return = m
(M3)	(m >>= k) >>= h = m >>= (λx.k x >>= h)
Fig. 6. Monads, M
theories.
Proposition 3.1 The theories of arrow calculus and classic arrows are in equa- tional correspondence: A ∼= C.
(Here and throughout we elide the deﬁnition of the homomorphic translations on terms of the lambda calculus.)
Arrow calculus to classic arrows:
JA) = A
Jλ•x. Q) = JQ)x

where
JΓ; Δ ▶ P ! A) =Γ ▶ JP )Δ :Δ ~ A
JL • M )Δ = arr (λΔ. JM )) >>> JL) J[M ])Δ = arr (λΔ. JM ))
Jlet x = P in Q)Δ = (arr id &&& JP )Δ) >>> JQ)Δ,x Classic arrows to arrow calculus:
⟨[A]⟩ = A
⟨[arr]⟩ = λf. λ•x. [f x]
⟨[(>>>)]⟩ = λf. λg. λ•x. let y = f • x in g • y
⟨[ﬁrst]⟩ = λf. λ•z. let x = f • (fst z) in [⟨x, snd z⟩]
Further details may be found in [4]. Note that despite the special form of typing judgement for commands, we do not need to generalise our definition of equational correspondence as we only care about equational correspondence between terms. However, the proof [4] does rely on showing a correspondence property involving commands: Γ ▶ ⟨[JP )Δ]⟩ = λ•Δ.P :Δ ~ A.

Note that an arrow calculus term judgement maps into a classic arrow judgement Γ ▶ M : A maps to Γ ▶ JM ) : A
while an arrow calculus command judgement maps into a classic arrow judgement Γ; Δ ▶ P ! A maps to Γ ▶ JP )Δ :Δ ~ A.
In JP )Δ, we take Δ to stand for the sequence of variables in the environment, and in Δ ~ A we take Δ to stand for the left-nested product of the types in the environment. The denotation of a command of type A is an arrow whose arguments correspond to the environment Δ and whose result has type A.
The translation uses the notation λΔ.N , which is given the obvious mean- ing: λx. N stands for itself, λx1, x2.N stands for λz. N [x1 := fst z, x2 := snd z], λx1, x2, x3.N stands for λz. N [x1 := fst (fst z), x2 := snd (fst z), x3 := snd z], and so on.
Example
We now turn to an informal comparison of idioms, arrows and monads, in order to illustrate the relative expressive power of each before returning to a more formal investigation in Sections 5 and 6.
In Section 3 we presented the theories of idioms, arrows and monads. However, in actual programs we do not simply use monads, arrows or idioms in the abstract, but particular instances of these interfaces in which the type expressions A ~ B, M A or I A denote concrete types. For example, we can use the well-known state monad with integers as the encapsulated state by instantiating M A to the type Int → Int×A and providing additional constants for reading and writing the state:
get : 1 → M Int put : Int → M 1
(We give a slightly non-standard type for get in order to simplify the translation to arrows and idioms in what follows. The type of our get is isomorphic to the more common M Int and the behaviour of our get ⟨⟩ identical to that of the standard get.) We can then use these constants along with the standard monad operators return and (>>=), to write programs such as the following, which uses the encapsulated state to generate fresh names (given a type of names Name and a name-construction function makeName : Int → Name):

freshName : M Name
freshName = get ⟨⟩ >>= λs. put (s + 1) >>= λu. return (makeName s)
or the following, which branches on the current state in order to choose which of

two computations to execute:

ifZero : (M A × M A) → M A 
ifZero = λk. get ⟨⟩ >>= λs. if s =0 then fst k else snd k

or the following, which reads, transforms and returns the current state:

getTransformed : (Int → A) → M A 
getTransformed = λf. get ⟨⟩ >>= λs. return (f s)

We can obtain an arrow from the state monad using the standard Kleisli con- struction [1], setting A ~ B to A → M B:

arr : (A → B) → (A ~ B)
arr = λf. λa. return (f a)
(>>>) : (A ~ B) → (B ~ C) → (A ~ C)
(>>>) = λf. λg. λa. f a >>= g
ﬁrst : (A ~ B) → (A × C ~ B × C)
ﬁrst = λf. λa. f (fst a) >>= λb. return ⟨b, c⟩

The constants get and put now have the following types

get~ : 1 ~ Int put~ : Int ~ 1
and we can use them to write an arrow equivalent of freshName:

freshName~ : 1 ~ Int
freshName~ = get~ >>> arr (λx. ⟨x + 1, x⟩) >>> ﬁrst put~ >>> arr snd
or an arrow equivalent of getTransformed:

getTransformed~ : (Int → A) → 1 ~ A
getTransformed~ = λf. (get~ >>> arr f )
However, there is no way to write an arrow equivalent of ifZero. This is due to the “first-orderness” of arrows: the arrow interface does not provide a method for running a computation received as input.
Similarly, we can obtain a state idiom from the state monad using standard

techniques [6], setting I A to M A:
pure : A → I A 
pure = return
(⊗) : I (A → B) → (I A → I B)
(⊗) = λf. λp. f >>= λg. p >>= λq. return (g q)
The constants get and put now have the following types
getI : 1 → I Int putI : Int → I 1
and we can use them to write getTransformed idiomatically:
getTransformedI : (Int → A) → I A 
getTransformedI = λf. pure f ⊗ getI ⟨⟩
However, we cannot write either freshName or ifZero using the idiom operations since, as we show in the next section, the idiom interface does not provide a means for one computation to depend on the value returned by another. The putI func- tion is therefore much less useful than its monad and arrow counterparts, since its argument cannot be a value arising from the computation of which it forms part.
Since monads are the most powerful of the three notions, the question naturally arises whether it might not be better to use monads in every case. In fact, it is precisely because monads are more expressive that they are not suitable for every situation: they offer more to users, but demand more of implementers. There are consequently many interesting instances of the idiom and arrow interfaces which do not satisfy the more stringent requirements for monad instances [1,2,6,9,10].
Relating idioms and arrows
In order to compare idioms and arrows we formalise static arrow computations. First, we describe a variant of classic arrows that supports static computation CS by adding an extra constant and two laws. Then, we introduce a variant of the arrow calculus, static arrows S, by adding one command and one law. We show that CS and S are in equational correspondence. We then give an equational embedding of static arrows into arrow calculus and show that idioms are equationally equivalent to static arrows.
In the arrow calculus, A, computations accept input via the command applica- tion operation L• M . The semantics of a computation in S is independent of input. We capture this property with an additional command that allows an arrow com- putation to be run before supplying it with an input, and an additional equation which treats computations with input as equivalent to computations without input. Thus static arrow computations are oblivious to their inputs.

Definition 5.1 The theory CS of classic arrows with delay is the extension of theory
C with the constant
delay : (A ~ B) → (1 ~ (A → B))
and the additional laws:
(~S1)	force (delay (a)) = a
(~S2)	delay (force (a)) = a
where
force : (1 ~ (A → B)) → (A ~ B)
force = λf.(arr (λx. ⟨⟨⟩, x⟩) >>> ﬁrst f >>> arr (apply))
Definition 5.2 The theory S of static arrows is the extension of the theory A with an additional syntactic construct given by the typing rule:
Γ ▶ L : A ~ B

Γ; Δ ▶ run L ! A → B
and the additional law:
(oblivious)	let x = L • M in [⟨⟩] = let y = run L in [⟨⟩]
Proposition 5.3 The theories of static arrows and classic arrows with delay are in equational correspondence: S ∼= CS.
The translations are each extended with an extra clause. Static arrows to classic arrows with delay:
Jrun L)Δ = arr (const ⟨⟩) >>> delay JL)
Classic arrows with delay to static arrows:
⟨[delay]⟩ = λx. λ•u. run x
(By convention we use the variable u to bind variables of type 1.)
Proposition 5.4 The theories of idioms and static arrows are equationally equiv- alent: I ∼ S.
(Here and throughout we elide the deﬁnition of the homomorphic translations on types and the corresponding type isomorphisms.)
Idioms to static arrows:
JI A) =1 ~ JA)
Jpure) = λx. λ•u. [x]
J(⊗)) = λf. λa. λ•u. let g = f • ⟨⟩ in let x = a • ⟨⟩ in [g x]

Static arrows to idioms:

⟨[A ~ B]⟩ = I(⟨[A]⟩→ ⟨[B]⟩)
⟨[λ•x. P ]⟩ = ⟨[P ]⟩x

where

⟨[Γ; Δ ▶ P ! A]⟩ = ⟨[Γ]⟩▶ ⟨[P ]⟩Δ : I(⟨[Δ]⟩→ ⟨[A]⟩)
⟨[L • M ]⟩Δ = pure (λl. λΔ.l ⟨[M ]⟩) ⊗ ⟨[L]⟩
⟨[run L]⟩Δ = pure (λl. λΔ. l) ⊗ ⟨[L]⟩
⟨[[M ]]⟩Δ = pure (λΔ. ⟨[M ]⟩)
⟨[let x = P in Q]⟩Δ = pure (λp. λq. λΔ.q ⟨Δ,p Δ⟩) ⊗ ⟨[P ]⟩Δ ⊗ ⟨[Q]⟩Δ,x

Type isomorphism on idioms:

fI(A) : I(A) ' I(1 → A)
fI(A) = λa. pure (λx. λu. x) ⊗ a

−1
I(A)
= λa. pure (λx. x ⟨⟩) ⊗ a


Type isomorphism on static arrows:

gA~B : (A ~ B) ' (1 ~ (A → B))
gA~B = λa. λ•u. run a

−1
A~B
= λa. λ•x. let f = a • ⟨⟩ in [f x]

Remark 5.5 The type isomorphism gA~B : (A ~ B) ' (1 ~ (A → B)) gives an alternative characterisation of static arrows. The type isomorphism and run L are inter-definable. The definition of gA~B in terms of run L is given above. The definition of run L in terms of gA~B follows.

run L ≡ (gA~B L) • ⟨⟩

Proposition 5.6 There is an equational embedding of static arrows into arrow calculus: S ‹→A 
Static arrows to arrows:

JA ~ B) =1 ~ (JA) → JB))
Jλ•x. P ) = λ•u. JP )x

where

JΓ; Δ ▶ P ! A) = JΓ); ·▶ JP )Δ ! JΔ) → JA)
JL • M )Δ = let l = JL) • ⟨⟩ in [λΔ.l JM )]
Jrun L)Δ = let f = JL) • ⟨⟩ in [λΔ.f ]
J[M ])Δ = [λΔ. JM )]
Jlet x = P in Q)Δ = let p = JP )Δ • ⟨⟩ in
let q = JQ)Δ,x • ⟨⟩ in [λΔ.q ⟨Δ,p Δ⟩]

JS) to static arrows:

⟨[1 ~ (A → B)]⟩ = ⟨[A]⟩ ~ ⟨[B]⟩
⟨[λ•u. P ]⟩ = λ•x. ⟨[P ]⟩x

where

⟨[Γ; Δ ▶ P ! A]⟩ = ⟨[Γ]⟩; ⟨[Δ]⟩▶ ⟨[P ]⟩Δ ! ⟨[A]⟩
⟨[L • M ]⟩Δ = run ⟨[L]⟩
⟨[[M ]]⟩Δ = [⟨[M ]⟩ Δ]
⟨[let x = P in Q]⟩Δ = let x = ⟨[P ]⟩Δ in let q = ⟨[Q]⟩Δ,x in [λΔ.q ⟨Δ, x⟩]

Type isomorphism on static arrows: f : A ' A is the identity isomorphism.
In fact the embedding of static arrows into arrow calculus is strict. If there were an equational equivalence between static arrows and arrow calculus it would be possible to construct a type isomorphism gA~B : (A ~ B) ' (1 ~ (A → B)) for the full arrow calculus and hence for any arrow. But there exist arrows for which this isomorphism does not hold, such as the state monad interpreted as a Kleisli arrow (see Section 4).


idio,ms,I
~
 r
static a,rro,ws S
∼=
classic acrrtows
with delay CS


,˛	 ar row ca,lc,ulus A
∼=
 r
classic arrows C

In summary: idioms are equationally equivalent to static arrows, which embed into arrow calculus.

Relating arrows and monads
In order to compare monads and arrows we consider arrows extended with applica- tion. First, we describe Hughes’s theory of classic arrows with apply Capp by adding an extra constant and three laws. We then introduce an extension of the arrow calculus, higher-order arrows H, that is in equational correspondence with Capp, by adding one command and one law.
An arrow with apply permits us to apply an arrow that is itself yielded by another arrow. As explained by Hughes [1] an arrow with apply is equivalent to a monad. It is equipped with an additional constant
app : ((A ~ B) × A) ~ B
which is an arrow analogue of function application.
For the arrow calculus, equivalent structure is provided by a second version of arrow application, where the arrow to apply may itself be computed by an arrow.

Γ; Δ ▶ R ! A ~ B	Γ, Δ ▶ M : A

Γ; Δ ▶ R • M ! B

This lifts the central restriction on arrow application. Now the arrow to apply may be the result of a command, and the command denoting the arrow may contain free variables in both Γ and Δ. We therefore dub arrows with apply promiscuous (in the broader sense of undiscriminating ), to highlight the departure from the careful maintenance of the distinction between the two environments in the standard arrow calculus. Indeed, Moggi’s metalanguage for monads is exactly like the arrow calculus but with no distinction between Γ and Δ, λx. N and λ•x. , or L M and L • M , and with A ~ B replaced by A → M B.
In this section we re-derive Hughes’s result in the arrow calculus to give an equational equivalence between monads and arrows with apply.
Definition 6.1 The theory Capp of classic arrows with apply is the extension of theory C with the constant
app : ((A ~ B) × A) ~ B
and the additional laws:
(~H1)	ﬁrst (arr (λx. arr (λy. ⟨x, y⟩))) >>> app = arr id
(~H2)	ﬁrst (arr (g>>>)) >>> app = second g >>> app
(~H3)	ﬁrst (arr (>>>h)) >>> app = app >>>h 
Definition 6.2 The theory H of higher-order arrows is the extension of the theory
A with an additional syntactic construct given by the typing rule:

Γ; Δ ▶ R ! A ~ B	Γ, Δ ▶ M : A

Γ; Δ ▶ R • M ! B


with the additional law:

(βapp)	[λ•x. Q] • M = Q[x := M ]

Proposition 6.3 The theories of higher-order arrows and classic arrows with apply are in equational correspondence: H ∼= Capp.
The translations are each extended with an extra clause. Higher-order arrows to classic arrows with apply:
JR • M )Δ = (JR)Δ &&& arr (λΔ. JM ))) >>> app Classic arrows with apply to higher-order arrows:
⟨[app]⟩ = λ•p. [fst p] • snd p
Remark 6.4 The proof of (βapp) requires the laws (~H1) and (~H3), but not (~H2). Since (~H1), (~H2) and (~H3) all follow from (βapp) together with the other arrow laws, this means that (~H2) is redundant. We believe we are the first to observe that Hughes’s three laws for app can be reduced to two. The details appear in [4].
Proposition 6.5 The theories of monads and higher-order arrows are equationally equivalent: M∼ H.
Monads to higher-order arrows:
JM A) =1 ~ JA)
Jreturn) = λx. λ•u. [x]
J(>>=)) = λa. λf. λ•u. let x = a • ⟨⟩ in [f x] • ⟨⟩
Higher-order arrows to monads:
⟨[A ~ B]⟩ = A → M ⟨[B]⟩
⟨[λ•x. P ]⟩ = λx. ⟨[P ]⟩
where
⟨[Γ; Δ ▶ P ! A]⟩ = ⟨[Γ, Δ]⟩▶ ⟨[P ]⟩ : M ⟨[A]⟩
⟨[L • M ]⟩ = ⟨[L]⟩ ⟨[M ]⟩
⟨[R • M ]⟩ = ⟨[R]⟩ >>= λr. r ⟨[M ]⟩
⟨[[M ]]⟩ = return ⟨[M ]⟩
⟨[let x = P in Q]⟩ = ⟨[P ]⟩ >>= λx. ⟨[Q]⟩

Type isomorphism on monads:
fM (A) : M (A) ' 1 → M (A)
fM (A) = λa. λu. a

−1
M (A)
= λf. f ⟨⟩

Type isomorphism on higher-order arrows:
gA~B : A ~ B ' A → (1 ~ B) gA~B = λa. λx. [a] • x

−1
A~B
= λf. λ•x. [f x]

Remark 6.6 The type isomorphism gA~B : A ~ B ' A → (1 ~ B) gives an alternative characterisation of higher-order arrows. The type isomorphism and R • M are inter-definable. The definition of gA~B in terms of R • M is given above. The definition of R • M in terms of gA~B follows.
R • M ≡ let r = R in [gA~B r M ]
Proposition 6.7 There is an equational embedding of arrow calculus into higher- order arrows: A ‹→ H.
The translation J−) : A → H is an injection, ⟨[−]⟩ : A → A is the identity translation and f is the identity isomorphism.
Proof. Clearly, J−) preserves equality, as every equation of A is an equation of H. It remains to show that ⟨[−]⟩ preserves equality.
Both the rewriting theories of the arrow calculus and of higher-order arrows are strongly normalising and confluent [4]. We establish that ⟨[−]⟩ preserves equality by examining normal forms. The normal form for arrow calculus commands is:
let x1 = L1 • M1 in ... let xn = Ln • Mn in [N ]
where L1,.. .n, M1,..., Mn, N are all in normal form. The normal form for higher- order arrow calculus commands is:
let x1 = [L1] • M1 in ... let xn = [Ln] • Mn in [N ]
where L1,.. .n, M1,..., Mn, N are all in normal form. Since L • M = [L] • M it is the case that both J−) and ⟨[−]⟩ map distinct normal forms to distinct normal forms, hence ⟨[−]⟩ preserves equality.	 
In fact the embedding of arrow calculus into higher-order arrows is strict. If there were an equational equivalence between arrow calculus and higher-order arrows it would be possible to construct a type isomorphism gA~B : A ~ B ' A → (1 ~ B) for the arrow calculus and hence for any arrow. But there exist many arrows for which this isomorphism does not hold, such as stream processor arrows [1].





,˛	 
mona,ds,M
~
 r

arrow ca,lcu,lus A
∼=
  
classic arrows C
higher-orde,r ,arrows H
∼=
classic arrocwts with
application Capp

In summary: monads are equationally equivalent to higher-order arrows, and there is an equational embedding of arrow calculus into higher-order arrows.
Conclusions and future work
We have characterised idioms, monads and arrows as variations on a single calculus, establishing the relative order of strength as idiom, arrow, monad in contrast to the putative order of arrow, idiom, monad. The variations that bring the arrow calculus into correspondence with idioms and with monads may be characterised either by type isomorphisms or by extensions to the equational theory.
The arrow calculus is the analogue for arrows of Moggi’s computational meta- language [8]. For the future, we plan to investigate analogues for arrows and idioms of the computational lambda calculus [7].
Acknowledgement
We thank Robert Atkey for illuminating discussions, Ezra Cooper, Ben Moseley and Brent Yorgey for comments on a draft of this paper, and Conor McBride and anonymous reviewers for helpful feedback.

References
Hughes, J., Generalising monads to arrows, Sci. of Comput. Program. 37(1–3) (2000), pp. 67–111.
Hughes, J., Programming with arrows, in: V. Vene and T. Uustalu, eds., “Revised Lectures from 5th Int. Summer School on Advanced Functional Programming, AFP 2004 (Tartu, Aug. 2004),” Lecture Notes in Computer Science 3622, Springer, 2005, pp. 73–129.
IETF, Transmission Control Protocol, RFC 793, 1981. Available at http://tools.ietf.org/html/ rfc793.
Lindley, S., P. Wadler and J. Yallop, The arrow calculus, Technical Report EDI-INF-RR-1258, University of Edinburgh, 2008.
Mac Lane, S., “Categories for the Working Mathematician,” 2nd ed., Graduate Texts in Mathematics
5, Springer, 1998.
McBride, C. and R. Paterson, Applicative programming with effects, J. of Funct. Program. 18(1) (2008),
pp. 1–13.
Moggi, E., Computational lambda-calculus and monads, in: “Proc. of 4th Ann. IEEE Symp. on Logic in Computer Science, LICS ’89 (Pacific Grove, CA, June 1989),” IEEE CS Press, 1989, pp. 14–23.
Moggi, E., Notions of computation and monads, Inform. and Comput. 93(1) (1991), pp. 55–92.

Paterson, R., A new notation for arrows, in: “Proc. of 6th ACM SIGPLAN Int. Conf. on Functional Programming, ICFP ’01 (Florence, Sept. 2001),” ACM Press, 2001, pp. 229–240.
Paterson, R., Arrows and computation, in: J. Gibbons and O. de Moor, editors, “The Fun of Programming”, Cornerstones of Computing, Palgrave, 2003, pp. 201–222.
Sabry, A. and M. Felleisen, Reasoning about programs in continuation-passing style, LISP and Symb. Comput. 6(3–4) (1993), pp. 287–358.
