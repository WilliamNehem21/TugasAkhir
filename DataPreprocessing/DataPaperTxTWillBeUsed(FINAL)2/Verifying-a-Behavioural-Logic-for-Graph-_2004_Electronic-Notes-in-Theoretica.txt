Electronic Notes in Theoretical Computer Science 104 (2004) 5–24	
www.elsevier.com/locate/entcs


Verifying a Behavioural Logic for Graph Transformation Systems 1
Paolo Baldan2
Dipartimento di Informatica, Universita` Ca’ Foscari di Venezia, Italy
and Andrea Corradini3
Dipartimento di Informatica, Universita` di Pisa, Italy
and Barbara Ko¨nig4
Institutsverbund Informatik, University of Stuttgart, Germany
and Bernhard Ko¨nig5
Department of Mathematics, University of California, Irvine, USA

Abstract
We propose a framework for the verification of behavioural properties of systems modelled as graph transformation systems. The properties can be expressed in a temporal logic which is basically a µ-calculus where the state predicates are formulae of a monadic second order logic, describing graph properties. The verification technique relies on an algorithm for the construction of finite over-approximations of the unfolding of a graph transformation system.
Keywords: Graph transformation systems, unfolding semantics, temporal logic, verification.



1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.08.018

Introduction
Graph transformation systems (GTSs) are recognised as a powerful specifica- tion formalism for concurrent and distributed systems [12], generalising Petri nets. Their truly concurrent behaviour has been deeply studied and a consol- idated theory of concurrency is now available. In particular, several seman- tics of Petri nets, like process and unfolding semantics, have been extended to GTSs (see, e.g., [8,26,1,2]). However, concerning automated verification, while several approaches exist for Petri nets, ranging from the calculus of in- variants [25] to model checking based on finite complete prefixes [23], the rich literature on GTSs does not contain many contributions to the static analysis of such systems (see [20,21,14]). Interestingly, several formalisms for concur- rency and mobility can be encoded as graph transformation systems, in a way that verification techniques for graph transformation systems potentially carry over such formalisms.
This paper describes a framework, developed in [5,6,4], where behavioural properties of a system described as a GTS can be specified and verified.
A Logic for Behavioural Properties of GTSs. The logic used here to specify behavioural properties of GTSs is the temporal logic µL2, which can be seen as a variation of the µ-calculus. The formulae of µL2 are generated by closing state predicates under temporal modalities ( and ), fixed-point operators (µ and ν), and standard logical connectives. Negation is classi- cal. In turn, state predicates, which are used to express the graph properties of interest, are formed according to the monadic second-order logic L2 on graphs, where quantification is allowed over (sets of) edges (see, e.g., [9].) In- teresting graph properties can be expressed in L2, like the non-existence or non-adjacency of edges with specific labels, and the absence of certain paths or of certain cycles. Such properties may be used to represent in the graph transformation model relevant properties of the system at hand, like security properties or deadlock-freedom.
Approximating the Behaviour of GTSs. A basic ingredient for the ver- ification of µL2 is a technique, proposed in [5,6], for approximating the be- haviour of GTSs by means of finite Petri net-like structures, in the spirit of abstract interpretation of reactive systems [22]. More precisely, an approx-

1 Partially supported by the Italian MIUR Project COFIN 2001013518 CoMeta, the EU FET – GC Project IST-2001-32747 agile and the EC RTN 2-2001-00346 SegraVis.
2 Email: baldan@dsi.unive.it
3 Email: andrea@di.unipi.it
4 Email: koenigba@fmi.uni-stuttgart.de
5 Email: bkoenig@math.uci.edu


imated unfolding construction maps any given GTS G to finite structures, called coverings of G, which provide “effective” (over-)approximations of the behaviour of G.
The accuracy of the approximation can be chosen by the user and arbi- trarily increased. Essentially one can require the approximation to be exact up to a certain causal depth k, thus obtaining the so-called k-covering Ck(G) of G. The coverings are Petri graphs, i.e., structures consisting of a Petri net with a graphical structure over places. Each Ck(G) over-approximates the behaviour of G in the sense that every computation of G is mapped to a valid computation of Ck(G) and every graph reachable from the start graph can be mapped homomorphically to (the graphical component of) Ck(G) and its image is reachable in the Petri graph. Therefore, given a property over graphs reflected by graph morphisms, if it holds for all states reachable in the abstraction Ck(G) then it also holds for all reachable graphs in G.
Verifying Behavioural Properties of GTSs. Relying on the approxima- tions of the unfolding, we propose a technique for reducing the verification of a µL2 formula over a GTS G to the verification of a corresponding multiset formula over (the Petri net component of) a covering of G. More specifically, fixed a covering Ck(G), we define a constructive translation of formulae in µL2 into formulae over the Petri net underlying the abstraction Ck(G). This is done in two steps.
First, any state predicate F in L2 is mapped to a formula Fˆ over markings such that a marking satisfies Fˆ if and only if the graph it represents satisfies
F . The translation is a kind of quantifier elimination procedure which encodes monadic second-order logic formulae into propositional formulae on markings, containing only predicates of the form #s ≤ c (the number of tokens in place s is smaller than or equal to c). This somehow surprising fact can be understood by recalling that the graph underlying Ck(G) is finite and fixed after computing the abstraction.
Then any temporal formula in µL2 over G is translated to a temporal formula over the Petri graph by simply translating its L2-subformulae as sketched above, and keeping the “temporal part” untouched.
Altogether, these results allow us to verify behavioural properties of a GTS, expressed in a suitable fragment of µL2, by reusing existing model-checking techniques for Petri nets. In fact, consider a formula T in µL2 (i.e., not containing in the temporal part the modality  nor negation) to be checked
over a GTS G. If the state predicates in T are reflected by graph morphisms, by the construction mentioned above we can translate T into a formula Tˆ over the Petri net underlying a covering of Ck(G) of G. (The restriction to  µL2 is


necessary because Ck(G) over-approximates G.) Then, by general results from abstract interpretation [22], Tˆ can be checked over the Petri net underlying Ck(G). A type inference system is introduced which characterises a subclass of formulae in the logic L2 which are reflected by graph morphisms. Hence,
the requirement over state predicates in T can be verified by checking that any such predicate can be typed as “reflected” in the mentioned type system. We recall that temporal state-based logics over Petri nets, i.e., logics where basic predicates have the form #s ≤ c, are not decidable in general, but
important fragments of such logics are [17,16,18].
For the sake of simplicity, although the approximation method of [5,6] was designed for hypergraphs, in this paper we stick to directed graphs. More- over, although not discussed in this document, a dual theory involving under- approximations of the behaviour of GTSs has been developed (see [4]).
In the rest of the paper, after introducing the class of graph transformation systems handled by our approach, we will present the monadic second-order logic L2 of graph formulae, and the temporal logic built on it, called µL2. Next we shall summarise the approximation technique for GTSs developed in [5], briefly mentioning some results from [6]. Finally we will propose a method for verifying µL2 formulae over GTS’s: this makes use of a type system characterising a subclass of formulae in L2 which are reflected by graph morphisms (and which can thus be checked on the covering), as well as of an encoding of these formulae into quantifier-free multiset formulae on the markings of Petri nets.

Graph Transformation Systems
In this section we introduce the class of graph transformation systems consid- ered in this paper, which are basically graph rewriting systems in the double- pushout approach [11], with some restrictions.
We first define graphs and structure-preserving morphisms on graphs. We will assume that Λ denotes a fixed and finite set of labels.
Definition 2.1 (Graph, graph morphism) A graph G = (VG, EG, sG, tG, lG)  consists of a set VG of nodes, a set EG of edges, source and target functions sG, tG: EG → VG and a function lG: EG → Λ labelling the edges.
A graph morphism ϕ: G1 → G2 is a pair ⟨ϕV : VG1 → VG2 , ϕE: EG1 → EG2  ⟩ of mappings such that ϕV ◦sG1 = sG2 ◦ϕE, ϕV ◦tG1 = tG2 ◦ϕE and lG1 = lG2 ◦ϕE for each edge e ∈ EG1 . A morphism ϕ will be called edge-bijective if ϕE is a bijection. The subscripts in ϕE and ϕV will be usually omitted.
We next define the notion of graph transformation system and the corre-



Fig. 1. Start graph of RPh with a process and two free resources.
sponding rewriting relation.
Definition 2.2 (Graph transformation system) A graph transformation system (GTS) (G0, R) consists of an initial graph G0 and a set R of rewriting rules of the form r = (L, R, α), where L, R are graphs, called left-hand side and right-hand side, respectively, and α: VL → VR is an injective function.
A match of a rewriting rule r in a graph G is a morphism ϕ: L → G which is injective on edges. We can apply r toa match ϕ in G obtaining a new graph
H, written G ⇒r H. The target graph H is defined as follows
VH = VG  (VR − α(VL))	EH = (EG − ϕ(EL))  ER
and, defining ϕ : VR → VH by ϕ(α(v)) = ϕ(v) if v ∈ VL and ϕ(v) = v
otherwise, the source, target and labelling functions are given by

Intuitively, the application of r to G at the match ϕ first removes from G the image of the edges of L. The resulting graph is extended by adding the new nodes in R (i.e., the nodes in VR − α(VL)) and all the edges of R. Observe that the (images of the) nodes in L are preserved, i.e., they are not affected by the rewriting step.
Example 2.3 Consider a variant of the Dining Philosopher system where processes compete for resources R1 and R2, a process needs both resources in order to perform some task, but processes are not organised in a cyclic structure and they can reproduce themselves. The system is represented as a
GTS RPh as follows. We consider edges labelled by R1, R2, Rf , Rf standing for
1	2
assigned and free resources, respectively, and P1, P2 and P3 denoting a process
waiting for the first resource, a process waiting for the second resource, and a process holding both resources, respectively. Furthermore, edges labelled by D1 and D2 connect the target node of a process and the source node of a resource when the process is asking for the resource. When the target node of a resource coincides with the source node of a process, this means that the resource is assigned to that process. The initial scenario for RPh is represented in Fig. 1, with a single process P1 asking for both resources.


Fig. 2. Rewriting rules of the GTS RPh.
The rewriting rules of RPh are defined with the aim of avoiding deadlocks in the form of vicious cycles. There are three kind of rules, depicted in Fig. 2:
(1) a process Pi can acquire a free resource Rf whenever i = j and it becomes Pi+1, (2) P3 can release its resources and (3) processes of the form P1 can fork creating more processes of the same kind competing for the same resources. The natural numbers 1, 2, 3,... which decorate nodes in the left- and right- hand side of rules implicitly represent the mapping α.
With the given rules, deadlocks are avoided by forcing each process to acquire the resources in a fixed ordering: first R1 and then R2. An additional rule, analogous to rule 1 but with i = 1 and j = 2, would possibly lead to a vicious cycle with circular demand for resources, in two steps (see Fig. 3).

A Logic for Graph Transformation Systems
This section presents a behavioural logic for GTSs. It is essentially a vari- ant of the propositional µ-calculus (i.e., a temporal logic enriched with fixed- point operators) where propositional symbols range over arbitrary state predi- cates, characterising static graph properties, which are expressed in a monadic second-order logic.

A Monadic Second-Order Logic for Graphs
We first introduce the monadic second-order logic L2 for specifying graph properties, i.e., “static” properties of system states. Quantification is allowed over edges, but not over nodes (as, e.g., in [9]).





f	D1	P1

3	D2

D1

f	D2
1
i = 1,j =1 

P1








1
i = 1,j =2 




Fig. 3. A vicious cycle representing a deadlock.
Definition 3.1 (Graph formulae) Let X1 = {x, y, z,.. .} be a set of (first- order) edge variables and X2 = {X, Y, Z,.. .} be a set of (second-order) vari- ables ranging over edge sets. The set of graph formulae of logic L2 is defined as follows, where l ∈ Λ
F	::=	x = y | s(x)= s(y) | s(x)= t(y) | t(x)= t(y) |
lab(x)= l | x ∈ X |	(Predicates)
F ∨ F | F ∧ F | F ⇒ F | ¬F |	(Connectives)
∀x.F | ∃x.F | ∀X.F | ∃X.F	(Quantifiers)
We denote by free(F ) and Free(F ) the sets of first-order and second-order variables, respectively, occurring free in F .
The notion of satisfaction is defined in a straightforward way.
Definition 3.2 (Satisfaction) Let G be a graph, let F be a graph formula in L2, let σ : free(F ) → Et and Σ : Free(F ) → P(Et) be valuations for the free first- and second-order variables of F , respectively. The satisfaction relation G |=σ,Σ F is defined inductively, in the usual way; for instance:
G |=σ,Σ x = y ⇐⇒ σ(x)= σ(y)
G |=σ,Σ s(x)= s(y) ⇐⇒ sG(σ(x)) = sG(σ(y)) G |=σ,Σ lab(x)= l ⇐⇒ lG(σ(x)) = l
G |=σ,Σ x ∈ X ⇐⇒ σ(x) ∈ Σ(X)
G |=σ,Σ ∀X.F ⇐⇒ G |=σ,Σ' F for any Σ' such that Σ'(Y )= Σ(Y )
for Y ∈ X2 − {X}, and Σ'(X) ∈ P(EG),
Example 3.3 The formula NC l below states that a graph does not contain


a cycle including two distinct edges labelled l, a property that will be used to express the absence of vicious cycles in our system RPh. It is based on the formula NP (x, y), which says that there is no path connecting the edges x and y, stating that a set that contains at least all edges reachable from x does not contain y necessarily.
NP (x, y)= ¬∀X.(∀z.(t(x)= s(z) ∨ ∃w.(w ∈ X ∧ t(w)= s(z))) ⇒ z ∈ X) ⇒ y ∈ X)
NC Æ = ∀x.∀y.(lab(x)= l ∧ lab(y)= l ∧ ¬(x = y) ⇒ NP (x, y) ∨ NP (y, x))
A standard compactness argument shows that NC l cannot be stated in first-order logic, a fact which motivates our choice of considering a second- order logic.

Introducing a Temporal Dimension
The behavioural logic for GTSs, called µL2, is a variant of the propositional
µ-calculus where propositional symbols range over formulae from L2.
Definition 3.4 (Logic over GTSs) The syntax of µL2 formulae is the fol- lowing:
f ::= A | X |  f |  f | ¬f | f1 ∨ f2 | f1 ∧ f2 | µX.f | νX.f
where A ranges over closed formulae in L2 and X ∈ X are proposition vari- ables.
The formulae are evaluated over a graph transition system T = (Q, →), i.e., a transition system where the set of states Q consists of (isomorphism classes of) graphs. This can be thought of as the abstract representation of the behaviour of a graph grammar. Intuitively, an atomic proposition A holds in any state q satisfying A according to Definition 3.2. A formula f / f holds in a state q if some / any single step leads to a state where f holds. Note that (as in [22]) the operators and only refer to the next step and not (as defined elsewhere) to the whole computation. The connectives ¬,∨, ∧ are interpreted in the usual way. The formulae µX.f and νX.f represent the least and greatest ﬁxed point over X, respectively. When a transition system T has a distinguished initial state q0, we say that T satisﬁes a (closed) formula f , written T |= f , if the initial state q0 of T satisfies f . Since the logic is classical,
  and ν could be defined in terms of  and µ. All the operators are inserted
explicitly since later we will restrict to negation-free fragments of µL2.
The fragment of µL2 without negation and box operator is denoted by
 µL2. By dropping negation and the diamond operator we obtain the frag- ment µL2. Some typical liveness properties of the form “eventually A” (i.e., µX.(A ∨ X)) can be expressed in the fragment µL2, whereas some typical safety properties of the form “always A” (i.e., νX.(A ∧  X)) can be expressed

in the fragment  µL2.
Example 3.5 Consider the system RPh in our running example. We would like to express the fact that, according to the design intentions, RPh is deadlock- free. This is formalised by the requirement that all reachable graphs do not contain a vicious cycle, i.e., a cycle of edges where P2-labelled edges (processes holding a resource and waiting for a second resource) occur twice. Notice that this is a safety property which can be encoded in  µL2 as follows:
TNC = νϕ.(NC P2 Λ  ϕ )
where NCl is the formula considered in a previous example.

Approximated Unfolding Construction
In this section we sketch the algorithm, introduced in [5,6], for the construc- tion of finite over-approximations of the unfolding of a graph transformation system. This plays a crucial role in the verification process of the logic µL2.

Petri Graphs
In order to approximate graph transformation systems we will use Petri net- like structures, called Petri graphs, originally introduced in [5].
To deal with Petri nets we first need to recall some basic notation con- cerning multisets. Given a set A we will denote by A⊕ the free commutative monoid over A, whose elements will be called multisets over A. We will sometimes identify A⊕ with the set of functions m: A → N such that the set
{a ∈ A | m(a) /= 0} is finite. E.g., in particular, m(a) denotes the multi- plicity of an element a in the multiset m. Sometimes a multiset will be also
identified with the underlying set, writing, e.g., a ∈ m for m(a) /= 0. Given a function f : A → B, by f ⊕: A⊕ → B⊕ we denote its monoidal extension, i.e.,
f ⊕(m)(b)= Σ	m(a) for every b ∈ B.
Petri graphs over a given graph transformation system G are basically Petri
nets equipped with an additional graphical structure where the places play the role of edges, while the transitions represent applications of the rules of G.
Definition 4.1 (Petri graph) Let G = (G0, Y) be a GTS. A Petri graph P
(over G) is a tuple (G, N, m0) where G is a graph and
N = (Et, TN , •(), ()•, pN ) is a Petri net, where the set of places Et is the edge set, TN is the set of transitions, •(), ()•: TN → E⊕ specify the post-set and pre-set of each transition and pN : TN → Y is the labelling function, mapping each transition to a corresponding rule;








Gj
graphG(mj)	Petri graph P = (G, N ) with marking mj
morphism
ψ





Fig. 4. A pair (G', m') contained in a simulation.
m0 ∈ (Et)⊕ is the initial marking of the Petri graph, satisfying m0 = ι⊕(Et ) for a suitable graph morphism ι : G0 → G (i.e., m0 must properly correspond to the initial state of the GTS G).
We shall write m [r⟩ m' if a transition labelled by r is enabled at marking

m and its firing produces m'. A marking m ∈ E⊕
will be called reachable

(coverable) in P if it is reachable (coverable) from the initial marking in the Petri net underlying P .
A marking m of a Petri graph can be seen as an abstract representation of a graph in the following sense.
Definition 4.2 Let (G, N, m0) be a Petri graph and let m ∈ E⊕ be a marking of N. The graph generated by m, denoted by grapht(m), is the graph H without isolated nodes (unique up to isomorphism) such that there exists a morphism ψ: H → G injective on nodes with ψ⊕(EH) = m. More explicitly, the graph H is defined as: VH = {v ∈ Vt | ∃e ∈ m: (st(e)= v ∨ tt(e)= v)}, EH = {(e, i) | e ∈ m Λ 1 ≤ i ≤ m(e)}, sH((e, i)) = st(e), tH((e, i)) = tt(e) and lH ((e, i)) = lt(e).
An example of Petri net marking and the corresponding generated graph can be found in Fig. 4.

Approximated Unfolding Algorithm
Given a GTS (G0, Y), with some minor constraints on the format of rewriting rules (see [5,6]), for any k ∈ N we can construct a Petri graph approximation of (G0, Y), called (k-)covering and denoted by Ck(G0, Y). Intuitively, the k- covering is exact up to causal depth k, i.e., any computation consisting of less than k (possibly concurrent) steps, is represented in Ck(G0, Y) without any loss of information.
In order to make this more formal, given a Petri graph P = (N, G), let the causal relation < be the least transitive relation over transitions such that, if t1• ∩ •t2 /= ∅ then t1 < t2. Then define the depth of a transition t to be the length of the longest sequence t0 < t1 < ... < tn < t. The depth of an edge is the maximum among the depths of transitions which contain the edge in their








unfolding










folding 2x



Fig. 5. An unfolding and two folding steps.
post-set.
Then the covering Ck(G0, Y) is produced by the last step of the following (terminating) algorithm which generates a sequence Pi = (Gi, Ni, mi) of Petri graphs.
P0 = (G0, N0, m0), where the net N0 contains no transitions and m0 =
Et0 .
As long as one of the following steps is applicable, transform Pi into Pi+1, giving precedence to folding steps.
Unfolding. Find a rule r = (L, R, α) ∈ Y and a match ϕ: L → Gi such that ϕ(E⊕) is coverable in Pi. Then extend Pi by “attaching” R to Gi according to α and add a transition t, labelled by r, describing the application of rule r.
Folding. Find a rule r = (L, R, α) ∈ Y and two matches ϕ, ϕ': L → Gi, at depth greater than or equal to k, such that
ϕ⊕(EL) and ϕ'⊕(EL) are coverable in Ni and
the second match causally depends on the transition unfolding the first match.
Then merge the two matches by setting ϕ(e) ≡ ϕ'(e) for each e ∈ EL and factoring through the resulting equivalence relation ≡.
For instance, an unfolding step involving rule 3 is depicted in Fig. 5. Tran- sitions are represented as black rectangles and the Petri net structure is ren- dered by connecting edges (places) to transitions with dashed lines. The label



Fig. 6. The Petri graph C0(RPh) computed as covering of RPh.
n for dashed lines represents the weight with which the target/source place occurs in the post-set (pre-set); when the weight is 1, the label is omitted. In the resulting Petri graph we can find three occurrences of the left-hand side of rule 3. The latter two are causally dependent on the first, which means that they can be merged in two folding steps. The algorithm, starting from the start graph in Fig. 1, terminates producing the Petri graph C0(RPh) in Fig. 6, where the initial marking is represented by tokens.
The covering Ck(G0, Y) is an abstraction of the original GTS (G0, Y) in the following sense.
Proposition 4.3 (Abstraction) Let G = (G0, Y) be a graph transformation system and let Ck(G)= (G, N, m0) be its k-covering. Furthermore, let G be the set of graphs reachable from G0 in G and let M be the set of reachable markings in Ck(G). Then there exists a simulation S ⊆ G × M with the following properties:
(G0, m0) ∈ S;

whenever (G', m') ∈ S and G' ⇒r
m [r⟩ m'' and (G'', m'') ∈ S;
G'', then there exists a marking m'' with

for every (G', m') ∈ S there exists an edge-bijective graph morphism ϕ: G' →
grapht(m').
The above result will allow us to use existing results concerning abstrac- tions of reactive systems [7,22]. Consider the property TNC in Example 3.5 expressing the absence of dead-locks in system RPh. Observe that the graph property NC P2 , i.e., the absence of vicious cycles where P2-labelled edges (processes holding one resource and waiting for a second one) occur twice is reflected by edge-bijective graph morphisms. Hence, by using Proposition 4.3, if we can prove it on the covering C0(RPh) of Fig. 6, we could deduce that it holds for the original system RPh as well. Observe that actually, in this case,


even the stronger property “#e ≤ 1”, i.e., “e contains at most one token”, where e is the edge labelled P2, holds for all reachable markings as it can be easily verified by drawing the coverability graph of the Petri net. This is an ad hoc proof of the property, which instead, by the results in this paper, will follow as an instance of a general theory.
Verifying µL2 on Graph Transformation Systems
In this section we show how the verification of properties of a GTS G, expressed in the logic µL2, can be reduced to the verification of suitable properties of the Petri net underlying a covering of G. This is done by viewing our technique as a specific instance of abstract interpretation [10,19], and exploiting some results from [22].
The idea is the following. Let G be a GTS and let Ck(G) be its k-covering. By Proposition 4.3, Ck(G) = (G, N, m0) “approximates” G via a simulation consisting of pairs (G', m') such that G' can be mapped to grapht(m') (see, e.g., Fig. 4) via an edge-bijective morphism. Given a formula on graphs F in L2, expressing a state property in G, a corresponding formula M(F ) on the markings of Ck(G) is constructed such that, for any pair in the simulation,
m' |= M(F ) ⇒ G' |= F
and thus, in a sense, F can be safely checked over the approximation Ck(G). This will be obtained in two steps. First, we will define a type system which allows us to identify formulae F which are reflected by edge-bijective morphisms, ensuring that grapht(m') |= F implies G' |= F . Then, we will encode F into a propositional formula M(F ) on multisets such that m' |= M(F ) ⇐⇒ grapht(m') |= F .
Finally, consider the temporal logic µL2 over GTSs. For suitable fragments of such logics, e.g., the fragment µL2 without negation and the “possibility operator” , by Proposition 4.3 and exploiting general results in [22], a tem- poral formula T over G, where state predicates can be typed as “reflected”, can be translated to a formula M(T ) over markings (translating the state predicates as described above), such that, if Ck(G) |= M(T ) then G |= T , i.e., T is valid for the original GTS.
Preservation and Reflection of Graph Formulae
Preservation and reflection of graph formulae by graph morphisms are defined as follows.
Definition 5.1 Let F be a formula in L2 and ϕ : G1 → G2 be a graph morphism. We say that F is preserved (resp. reflected) by ϕ if for all valuations


s(x)= s(y), s(x)= t(y), t(x)= t(y): →	x = y, lab(x)= l, x ∈ X: ↔

F : d−1
¬F : d
F1, F2 : d

F1 ∨ F2, F1 ∧ F2 : d
F : d
F1 : d−1,  F2: d F1 ⇒ F2: d
F : d
F : d
∀x.F : d
F : d


∃x.F : d


	
∀X.F : d	∃X.F : d
Fig. 7. A type system for preservation and reflection of L2 formulae by edge-bijective morphisms.
σ : free(F ) → Et1 and Σ : Free(F ) → P(Et1 ), G1 |=σ,Σ F implies (resp. is implied by) G2 |=q◦σ,q◦Σ F .
We are interested in syntactic criteria characterising classes of graph for- mulae reflected, respectively preserved, by all edge-bijective graph morphisms. Similar considerations on reflection and preservation on morphisms can be found in [15]. Here we provide a technique which works for general second- order monadic formulae. It is based on the type system of Fig. 7 which allows to prove judgements of the form F :→ (resp. F :←), meaning that the L2- formula F is preserved (resp. reflected) by all edge-bijective graph morphisms. In the typing rules, it is intended that →−1=← and ←−1=→. Moreover F :↔ is a shorthand for F :→ and F :←, while F1, F2 : d stands for F1 : d and F2 : d.
Example 5.2 The judgements NP (x, y): ← and NC l: ← are provable using the type system of Fig. 7, thus the absence of paths and of vicious cycles is reflected by edge-bijective morphisms.
The proposed type system can be shown easily to be correct, but it is not complete. In fact, it is possible to show that the set of closed first-order formulae which are preserved (resp. reflected) by edge-bijective morphisms is undecidable. Therefore, a fortiori, not all L2-formulae which are preserved or reflected are captured by the above type system.

A Propositional Logic on Multisets
In order to characterise markings of Petri nets we use a propositional logic on multisets. We consider a fixed universe A over which all multisets are formed.
Definition 5.3 (Multiset formulae) The set of multiset formulae, ranged over by M, is defined as follows, where a ∈ A and c ∈ N
M  ::= #a ≤ c | ¬M  | M ∨ M ' | M Λ M '.
Let m be a multiset with elements from A. The satisfaction relation m |= M is defined, on basic predicates, as m |= (#a ≤ c) ⇐⇒ m(a) ≤ c. Logical connectives are dealt with as usual.


We will consider also derived predicates of the form #a ≥ c and #a = c with the obvious meaning. E.g., (#a ≥ c) stands for ¬(#a ≤ c − 1) if c > 0 and for true otherwise.

Encoding Graph Logic into Multiset Logic
We show how graph formulae can be encoded into “equivalent” multiset for- mulae. More precisely, for a fixed Petri graph P = (G, N, m0) the aim is to find an encoding M1 of L2-formulae into multiset formulae such that grapht(m) |= F ⇐⇒ m |= M1(F ) for every marking m of P and every closed graph formula F .
We actually propose two encodings: an inductive one, which works only for first-order formulae, and a general one which works for the whole set of graph formulae.
Inductive Encoding. The encoding M1 of first-order graph formulae is based on the following observation. Every graph grapht(m) for some marking m of P can be generated from the finite “template graph” G in the following way: some edges of G might be removed and some edges might be multiplied, generating several parallel copies of the same template edge. Whenever a formula has two free variables x, y and grapht(m) has n copies e1,..., en of the same edge, it is not necessary to associate x and y with all edges, but it is sufficient to assign e1 to x and e2 to y (first alternative) or e1 to both x and y (second alternative). Thus, whenever we encode a formula F , we have to keep track of the following information: a partition Q on the free variables free(F ), telling us which variables are mapped to the same edge, and a mapping ρ from free(F ) to the edges of G, with ρ(x)= e meaning that x will be instantiated with a copy of the template edge e. Since there might be several different copies of the same template edge, two variables x and y in different sets of Q can be mapped by ρ to the same edge of G. Whenever we encode an existential quantifier ∃x, we have to form a disjunction over all the possibile choices for x: either x is instantiated with the same edge as another free variable y, and in this case x and y should be in the same set of the partition Q. Or x is instantiated with a new copy of an edge in G. In this case, a new set {x} is added to Q and we have to make sure that enough edges are available by adding a suitable predicate.
We need the following notation. We will describe an equivalence relation on a set A by a partition Q ⊆ P(A) of A, where every element of Q represents an equivalence class. We will write xQy whenever x, y are in the same equiv- alence class. Furthermore we assume that each equivalence Q is associated with a function rep : Q → A which assigns a representative to every equiva-


lence class. The encoding given below is independent of any specific choice of representatives.
Given a function f : A → B such that f (a)= f (a') for all a, a' ∈ A with aQa' and a fixed b ∈ B we define nQ,ƒ (b) = |{k ∈ Q | f (rep(k)) = b}|, i.e., nQ,ƒ (b) is the number of sets in the partition Q that are mapped to b.
Definition 5.4 (Encoding of first-order graph formulae) Let G be a finite directed graph, let F be a graph formula in the first-order fragment of L2, let ρ : free(F ) → Et and let Q ⊆ P(free(F )) be an equivalence relation such that xQy implies ρ(x)= ρ(y) for all x, y ∈ free(F ). The encoding M1 is defined as follows:
M1[¬F, ρ, Q]= ¬M1[F, ρ, Q]
M1[F1 ∨ F2, ρ, Q]= M1[F1, ρ, Q] ∨ M1[F1, ρ, Q]
M1[F1 ∧ F2, ρ, Q]= M1[F1, ρ, Q] ∧ M1[F1, ρ, Q]
M [x = y, ρ, Q]=	true if xQ y
false otherwise
M [lab(x) = l, ρ, Q]=	true if lG(ρ(x)) = l
false otherwise
M [s(x) = s(y), ρ, Q]=	true if sG(ρ(x)) = sG(ρ(y))
false otherwise
formulae t(x) = t(y) and s(x) = t(y) are treated analogously
M1[∃x.F, ρ, Q]=	(M1[F, ρ ∪ {x '→ ρ(rep(k))}, Q\{k}∪ {k ∪ {x}}]) ∨
k∈Q
(M1[F, ρ ∪ {x '→ e},Q ∪ {{x}}] ∧ (#e ≥ nQ,ρ(e)+ 1))
e∈EG
M1[∀x.F, ρ, Q]=	(M1[F, ρ ∪ {x '→ ρ(rep(k))}, Q\{k}∪ {k ∪ {x}}]) ∧
k∈Q
((#e ≥ nQ,ρ(e)+ 1) ⇒ M1[F, ρ ∪ {x '→ e},Q ∪ {{x}}])
e∈EG

If F is closed (i.e., without free variables), we define M1(F )= M1[F, ∅, ∅].

General Encoding. General monadic second-order graph formulae in L2 can be encoded into multiset formulae, but differently from the first-order case, the encoding is not defined inductively, even if quantifier elimination is still possible.
Proposition 5.5 Let G be a ﬁxed ﬁnite template graph. A closed graph for- mula F in L2 can be encoded into a logical formula M2(F ) on multisets as follows. For any multiset k ∈ E⊕, let Ck be the conjunction over the following

formulae:
#e = k(e) for every e ∈ Et satisfying k(e) < qd1(F ) · 2qd2 (F ) and
#e ≥ k(e) for every e ∈ Et satisfying k(e)= qd1(F ) · 2qd2(F ).
where qd1(F ) and qd2(F ) denote the ﬁrst and second order quantiﬁer depth of F, deﬁned in the obvious way. Let M2(F ) be the disjunction of all Ck such that k ∈ E⊕, grapht(k) |= F and k(e) ≤ qd1(F ) · 2qd2 (F ) for every e ∈ Et.
Then grapht(m) |= F ⇐⇒ m |= M2(F ) for every m ∈ E⊕.
Intuitively, for every first-order quantifier we have to try every edge of the template graph. Furthermore we have to try every possible membership to the sets assigned to second-order variables, of which there are at most qd2(F ), hence there are at most 2qd2(F ) possible membership combinations.
Although a formal complexity analysis is beyond the scope of this paper, we mention that the inductive encoding offers the advantage of generally pro- ducing smaller propositional formulae, easier to simplify.

Veriﬁcation of Temporal Formulae of µL2
We need to recall some concepts from [22], the more basic one being the formalisation of abstraction given in terms of Galois connections.
Definition 5.6 (Galois connection) Let Q1 and Q2 be two sets of states. A Galois connection from P(Q1) to P(Q2) is a pair of monotonic functions (α, γ), with α : P(Q1) → P(Q2) (abstraction) and γ : P(Q2) → P(Q1) (concretisation), such that id P(Q1 ) ⊆ γ ◦ α and α ◦ γ ⊆ id P(Q2).
Galois connections can be defined on general partial orders, but in this context we only need to consider them over powerset lattices. Next we in- troduce ⟨α, γ⟩-simulations which turn out to coincide with simulations in the sense of Milner.
Definition 5.7 (⟨α, γ⟩-simulation) Let Ti = (Qi, →i) with i ∈ {1, 2} be transition systems, where Qi is a set of states and →i⊆ Qi×Qi is the transition relation. Let furthermore (α, γ) be a Galois connection from P(Q1) to P(Q2).
We say that T2 ⟨α, γ⟩-simulates T1, written T1 ±⟨α,γ⟩ T2, if α ◦ pre[→1] ◦ γ ⊆ pre[→2], where the function pre[→i] : P(Qi) → P(Qi) is defined by pre[→i](Q)= {q ∈ Qi | ∃ q' ∈ Q : q →i q'}.
Let T1, T2 be transition systems and let ϕ : T1 → T2 be a transition system morphism, i.e., a function ϕ : Q1 → Q2 such that for any q, q' ∈ Q1 if q →1 q' then ϕ(q) →2 ϕ(q') (in other words, ϕ is a special kind of simulation). Then the pair (ϕ, ϕ−1) is a Galois connection and furthermore T1 ±⟨q,q−1 ⟩ T2.


These definitions allow us to interpret the approximations of the behaviour of a graph grammar in this context. In fact, let us identify any graph grammar G with the obvious graph transition system generated by G (as described after Definition 3.4). Observe that also a Petri graph (G, N, m0) over G can be seen as a graph transition system, by simply identifying any marking m with the graph grapht(m). In this view, it can be shown that for any k ∈ N, for suitable α and γ
G ±⟨α,γ⟩ Ck(G).
By exploiting the results of [22] regarding the preservation and reflection of modal µ-calculus formulae on transitions systems and the results in this paper we have the following.

Proposition 5.8 Let G = (G0, Y) be a GTS, and let T be a µL2-formula. Consider the formula M2(T ) obtained by replacing any state predicate A in T by the multiset formula M2(A) as deﬁned in Proposition 5.5. Then if T ∈
 µL2 and for any state predicate A in T the judgement A :← is provable using the type system of Fig. 7, then for any k ∈ N
Ck(G) |= M2(T )	⇒	G |= T

The above result shows how to reduce the analysis of the full transition system of a graph grammar to the analysis of simpler transition systems, generated by Petri nets (underlying Petri graphs). These transition systems might still have infinitely many states, but there are several decidability re- sults for fragments of the modal µ-calculus and other forms of temporal log- ics [13,17,18]. Analogous result can be proved by restricting state predicates to the first-oder fragment of L2 and using the encoding M1.
For instance, consider the safety property TNC over system RPh of Ex- ample 3.5, i.e., the absence of vicious cycles including two distinct P2 pro- cesses in all reachable graphs. The formula TNC can be translated into a formula over markings, by translating its graph formula components accord- ing to the techniques described in Sections 5.3. This will lead to the formula M2(TNC)= νϕ.(M2(NC P2 ) Λ ϕ ). Since TNC belongs to the  µL2 fragment and the basic predicate NCP2 can be typed as “reflected”, i.e., the judge- ment NCP2 :← is provable in the type system of Fig. 7, by Proposition 5.8, if Ck(RPh) |= M2(TNC) then RPh |= TNC. Therefore the formula TNC can be checked by verifying M2(TNC) on the Petri net component of the approxi- mated unfolding. In this case it can be easily verified that M2(TNC) actually holds in C0(RPh) and thus we conclude that RPh satisfies the desired property.

Conclusions
We have presented a logic for specifying graph properties, useful for the veri- fication of graph transformation systems. A type system allows us to identify formulae of this logic reflected by edge-bijective morphisms, which can there- fore be verified on the covering, i.e., on the finite Petri graph approximation of a GTS. Moreover, fixed an approximation of the original system, we can perform quantifier-elimination and encode these formulae into boolean com- bination of atomic predicates on multisets. Combined with the approximated unfolding algorithm of [5], this gives a method for the verification and analysis of graph transformation systems. This form of abstraction is different from the usual forms of abstract interpretation since it abstracts the structure of a system rather than its data. Maybe the closest relation is shape analysis, abstracting the data structures of a program [24,27].
Some natural generalisations of the approach presented in this paper are under development. Firstly, we intend to extend the approach to general hy- pergraph rewriting, also considering the fact that the approximation method of [5,6] was indeed designed for hypergraphs. The extension to general hyper- graphs will require some basic changes to the graph logic L2. Furthermore, we intend to consider wider classes of GTSs where it is possible to specify that an hyperedge is preserved by a rule: this will require to consider Petri graphs having an underlying contextual Petri net [3].

References
P. Baldan, A. Corradini, and U. Montanari. Concatenable graph processes: relating processes and derivation traces. In Proceedings of ICALP’98, volume 1443 of LNCS, pages 283–295. Springer Verlag, 1998.
P. Baldan, A. Corradini, and U. Montanari. Unfolding and Event Structure Semantics for Graph Grammars. In W. Thomas, editor, Proceedings of FoSSaCS ’99, volume 1578 of LNCS, pages 73–89. Springer Verlag, 1999.
P. Baldan, A. Corradini, and U. Montanari. Contextual petri nets, asymmetric event structures and processes. Information and Computation, 171(1):1–49, 2001.
P. Baldan, B. K¨onig, and B. K¨onig. A logic for analyzing abstractions of graph transformation systems. In R. Cousot, editor, Proceedings of SAS’03, volume 2694 of LNCS, pages 255–272. Springer Verlag, 2003.
Paolo Baldan, Andrea Corradini, and Barbara K¨onig. A static analysis technique for graph transformation systems. In Proc. of CONCUR ’01, pages 381–395. Springer-Verlag, 2001. LNCS 2154.
Paolo Baldan and Barbara Ko¨nig. Approximating the behaviour of graph transformation systems. In Proc. of ICGT ’02 (International Conference on Graph Transformation), pages 14–29. Springer-Verlag, 2002. LNCS 2505.
Edmund M. Clarke, Orna Grumberg, and David E. Long. Model checking and abstraction.
ACM Transactions on Programming Languages and Systems, 1999.


A. Corradini, U. Montanari, and F. Rossi. Graph processes. Fundamenta Informaticae, 26:241– 265, 1996.
B. Courcelle. The expression of graph properties and graph transformations in monadic second- order logic. In G. Rozenberg, editor, Handbook of Graph Grammars and Computing by Graph Transformation, Vol.1: Foundations, chapter 5. World Scientific, 1997.
P. Cousot. Abstract interpretation. ACM Computing Surveys, 28(2), 1996.
H. Ehrig. Introduction to the algebraic theory of graph grammars. In V. Claus, H. Ehrig, and
G. Rozenberg, editors, Proceedings of the 1st International Workshop on Graph-Grammars and Their Application to Computer Science and Biology, volume 73 of LNCS, pages 1–69. Springer Verlag, 1979.
H. Ehrig, J. Kreowski, U. Montanari, and G. Rozenberg, editors. Handbook of Graph Grammars and Computing by Graph Transformation, Vol. 3: Concurrency, Parallelism and Distribution. World Scientific, 1999.
J. Esparza. Decidability of model-checking for infinite-state concurrent systems. Acta Informatica, 34:85–107, 1997.
R. Heckel. Compositional verification of reactive systems specified by graph transformation. In
E. Astesiano, editor, Proceedings of FASE’98, volume 1382 of LNCS, pages 138–153. Springer Verlag, 1998.
Wilfrid Hodges. Model Theory. Cambridge University Press, 1993.
R. Howell and L. Rosier. Problems concerning fairness and temporal logic for conflict-free Petri net. Theoretical Computer Science, 64:305–329, 1989.
Rodney R. Howell, Louis E. Rosier, and Hsu-Chun Yen. A taxonomy of fairness and temporal logic problems for Petri nets. Theoretical Computer Science, 82:341–372, 1991.
Petr Jan˘car. Decidability of a temporal logic problem for Petri nets. Theoretical Computer Science, 74:71–93, 1990.
N.D. Jones and F. Nielson. Abstract interpretation: a semantics-based tool for program analysis. In S. Abramsky, Dov M. Gabbay, and T.S.E. Maibaum, editors, Handbook of Logic in Computer Science, Vol. 4: Semantic Modelling, pages 527–636. Oxford University Press, 1995.
M. Koch. Integration of Graph Transformation and Temporal Logic for the Speciﬁcation of Distributed Systems. PhD thesis, Technische Universit¨at Berlin, 2000.
B. K¨onig. A general framework for types in graph rewriting. In Proc. of FST TCS 2000, volume 1974 of LNCS, pages 373–384. Springer Verlag, 2000.
Claire Loiseaux, Susanne Graf, Joseph Sifakis, Ahmed Bouajjani, and Saddek Bensalem. Property preserving abstractions for the verification of concurrent systems. Formal Methods in System Design, 6:1–35, 1995.
K.L. McMillan. Symbolic Model Checking. Kluwer, 1993.
Flemming Nielson, Hanne Riis Nielson, and Chris Hankin. Principles of Program Analysis. Springer-Verlag, 1999.
W. Reisig. Petri Nets: An Introduction. EACTS Monographs on Theoretical Computer Science. Springer Verlag, 1985.
L. Ribeiro. Parallel Composition and Unfolding Semantics of Graph Grammars. PhD thesis, Technische Universit¨at Berlin, 1996.
Mooly Sagiv, Thomas Reps, and Reinhard Wilhelm. Parametric shape analysis via 3-valued logic. TOPLAS (ACM Transactions on Programming Languages and Systems), 24(3):217–298, 2002.
