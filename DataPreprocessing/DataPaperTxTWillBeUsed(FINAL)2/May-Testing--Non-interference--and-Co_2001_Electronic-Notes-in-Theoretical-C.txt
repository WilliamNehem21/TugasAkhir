URL: http://www.elsevier.nl/locate/entcs/volume40.html  31 pages


May Testing, Non-interference, and Compositionality

Steve Schneider
Department of Computer Science Royal Holloway, University of London Egham, Surrey, TW20 0EX


Abstract
This paper uses CSP to introduce a characterisation of non-interference in terms of the deductions that may be made about high level processes by low level tests. May testing yields classic noninference, and has a concise formulation in CSP. It is preserved by a wider range of composition operators than are normally considered in the context of non-interference, and thus also composes under the operators traditionally studied with non-interference. The CSP characterisation of may non- interference also permits some attractive and simple compositionality proofs.

Introduction
Compositionality of non-interference properties is essential for constructing secure systems out of secure components. This argument was made by Mc- Cullough [8] as motivation for his definition of restrictiveness,a property which ensures non-interference and which is also preserved by system composition. In the literature, there are a number of formulations of non-interference (see for example [4,8,18,9,2]), which tend to use state machines or event systems as their system models,and which define notions of system composition with respect to the semantic framework they have set up.
Process algebra provides a mature theory for the modelling of systems built out of a number of components, and offers a number of compositional operators for constructing systems. It is naturally suited to the description of concurrent systems, and provides a framework for their analysis with respect to particular requirements,with established techniques for reasoning.
This paper investigates the notion of non-interference from the point of view of may testing,a technique used in process algebra to characterise process equivalence. One motivation for starting from may testing is that it provides a natural and intuitive understanding of the property that we aim to investigate, and of the systems to which this investigation will apply.
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.

In the context of non-interference, we might wish to claim that a system provides non-interference between a high level interface H and a low level interface L if no interactions at the low level can provide any information about any user at the high level. This is formalised as the requirement that no low level test on the system can distinguish between any two high level users.
This definition is intuitively appealing, but is too cumbersome to work with directly in the analysis of alleged non-interfering systems. We are able to characterise this non-interference property in terms of conditions on the system without explicit reference to high level users. It turns out that corresponds to the property ‘noninference’ considered by O’Halloran [11] and more recently investigated by Focardi and Gorrieri [3], though we have given a more direct motivation for it,and thus provide additional insight into their formulations. We investigate its composability through a wide range of CSP composition operators, including forms of parallel combination, sequencing, and hiding. The process-algebraic framework we use yields surprisingly simple proofs of compositionality,generally four or five lines of algebra. The external combina- tors typically used in studies of non-interference—cross product,cascade,and feedback—can be expressed in terms of the CSP compositions,and so results
about these external combinators are easily derived.

Notation
Process algebras provide a particular approach to the study of concurrency and interaction. This paper bases its discussion within the framework of the process algebra CSP (Communicating Sequential Processes). A full account of this process algebra can be found in [14,17]. It provides a language for describing interacting systems, together with a semantic theory for under- standing them. This section provides a brief reminder of those aspects most relevant to this paper.
The language of CSP is constructed around events: instantaneous synchro- nisations which provide the communication primitive. Events may have some structure, the most common communication being a channel communication of the form c.v , where c is the channel name, and v is the value communi- cated. The set of all events is denoted Σ. If c is a channel name, and T is a set of messages, then c.T denotes the set of all channel communications of messages from T passing along c: c.T = {c.v | v ∈ T}
Processes are used to describe possible patterns of interaction. In CSP, a process P has an alphabet,or interface, α(P ) ⊆ Σ: the set of events it is able to synchronise on. The process a → P describes a process which is initially prepared to engage in the event a, and then subsequently behave as P . The process c!v → P describes a process which is prepared to output v on channel c, and behave subsequently as P . The input c?x : T → P (x ) may take in some value v of type T along channel c and behave subsequently as P (v ).

The choice P H Q may behave non-deterministically either as P or as Q . The choice P ✷ Q offers a choice between all the events offered by the processes P and Q . The choice is resolved on the occurrence of the first event in favour of the process that performs it.

Processes may be put in parallel: P
 Q behaves as P running concur-
A

rently with Q , synchronising on events in A, and performing other events
independently. Often, A will be the intersection of the alphabets of P and Q . Values are passed between parallel processes by means of synchronisations on the channels,linking an output channel of one to an input channel of another. An interleaving of two processes, P ||| Q , simply executes P and Q concur- rently without any communication occurring between them. The abstraction mechanism P \ A describes the process P with all occurrences of A occurring internally in the resulting process. The process Stop can perform no events at

all. Thus P
 Stop behaves as the process P with all occurrences of A blocked.
A

This is different from P \ A in which all occurrences of events in A are made
internal. The process RunA has alphabet A,and it is always ready to perform any event from the set A. Processes may also be recursively defined,by giving equations which contain the name of the process being defined as a subterm of the process expression. For example,the process
Copy = in?x : N → out !x → Copy
defines a buffer process Copy as one which repeatedly alternates input and output. Indexed processes may also be mutually recursively defined using families of equations.
The semantics of processes are given in terms of observations. A process is identified with the set of behaviours that may possibly be observed of it, where the kind of behaviour considered determines the nature of the model.
The Traces Model is concerned with the traces of CSP processes: the (finite) sequences of events that they can perform during some execution. A trace is written as a finite sequence of events within angled brackets. The empty trace is denoted ⟨⟩,and tr1 - tr2 is the concatenation of traces tr1 and tr2. For example,
traces(Copy )= 
{⟨⟩, }
∪ {⟨in.v⟩| v ∈ V }
∪ {⟨in.v, out.v⟩| v ∈ V }
∪ {⟨in.v, out.v, in.w⟩| v ∈ V , w ∈ W }
.
where V is the type of the channels in, out . The Traces Model and trace semantics for the CSP operators introduced here is included in Appendix A. The traces model is sufficient for the purposes of this paper. More sophis-

(P
Q )  Stop = (P
A	B
 Stop)  (Q
B	A
 Stop)
B

α(P ) ∩ B = ∅ ⇒ (P
 (Q  Stop)) = P
A	B
	Q
A∪B

P \ (A ∪ B )= (P \ A) \ B

(P
 Stop)= (P
A
 Stop) \ A
A

A ∩ B = ∅ ⇒ (P
Q ) \ B = (P
A
 Stop)  (Q
B	A
 Stop)
B

P \ A ± P
 Stop
A

(P \ B )
 Stop ± (P
A
 Stop) \ B
A

(P \ B )
 (Q \ B ) ± (P
A
Q ) \ B
A

(P \ B ) ||| (Q \ B )= (P ||| Q ) \ B

P \ (A ∪ B ) ± (P
 Stop) \ B
A

α(P ) ∩ B = ∅ ⇒ (P ||| RunB )
P ± Q ∧ Q ± P ⇒ P = Q


A∪B
Q = P  Q
A

Fig. 1. Some algebraic laws of the CSP traces model

ticated models are used to handle phenomena such as deadlock, divergence, and nondeterminism.
Processes are considered equivalent in a semantic model if they have the same set of behaviours in that model. Thus if P and Q have the same traces, then they are equivalent in the traces model,written P =traces Q . This means that if only their traces are examined, then they cannot be distinguished. A process P is refined by a process Q in the traces model if all the traces of Q are also traces of P . This is written P ±traces Q . All of the CSP operators are monotonic with respect to refinement: refinement of components in a CSP combination will result in a refinement of the combination. In this paper we are concerned only with the traces model,and so we will drop the subscript from the equality symbol and the refinement symbol. The traces model supports a number of algebraic equations and refinement relationships. Those used in the proofs later in this paper are given in Figure 1.
One approach to comparing processes is in terms of testing. A test T
is a particular kind of process, with some Success states. We consider the

execution of T in conjunction with a process P and if (P
T ) \ Σ can reach
Σ

a success state then we say that ‘P may T ’. If P may T whenever Q may T
and vice versa for all possible tests T ,then P and Q are equivalent under may testing. It turns out that this will be the case precisely when P and Q have the same traces. For further information on testing see [5].
Finally, for the purposes of this paper it will be useful to characterise in


Fig. 2. Testing U through P
the traces model what is meant by a process always being willing to accept any event from a set A:
Definition 2.1 A process P is open on A if
∀ tr ∈ traces(P ), a ∈ A • tr - ⟨a⟩∈ traces(P )
Non-interference and may testing
We are concerned with a system P whose interface is partitioned into a set of high level events H and a set of low level events L. The intention is that observing or interacting with the system only at the low level should not provide information about what is going on at the high level. In this paper, we adopt the convention that all pictures in the figures of systems P with partitioned interfaces will have high level events to the left, and low level events to the right of the process,as for P in Figure 2.
In this paper, non-interference will be considered from the point of view of whether a low level agent interacting with P may distinguish between two arbitrary processes U1 and U2 which are interacting with P at the high level. The high level user might or might not be able to observe low level activity directly,and we will consider both of these possibilities. In fact they turn out to be equivalent for may testing.
The first definition considers the high level agents to be concerned only with high level events. This is pictured in Figure 2. In defining a notion of non- interference on a process P with respect to a high level interface H ⊆ Σ anda low level interface L ⊆ Σ,we will assume that H ∩ L = ∅ and α(P ) ⊆ H ∪ L. In this case,we make the following definition:
Definition 3.1 P is may non-interfering with respect to (H,L), or may-NI wrt (H,L),if for any test T ,and any two high level users U1 and U2 :

(U1 
H
P ) \ H may T ⇔ (U2 
H
P ) \ H may T

An alternative definition is concerned with the situation in which high level agents are able to observe low level events,as long as they cannot prevent low level events from occurring. This condition is necessary since otherwise high


Fig. 3. Strong testing U through P : U can observe low level events
level agents could be distinguished by a low level test through no fault of P . For example, the test l → Success could tell the difference between two high level processes U1 = l → Stop and U2 = Stop through system P = l → Stop, since U2 blocks l .
Definition 3.2 P is strong may non-interfering with respect to (H,L) if for any test T , and any two high level users U1 and U2 which are open on L:

(U1


H ∪L
P ) \ H may T ⇔ (U2


H ∪L
P ) \ H may T

In fact as we shall see, the two definitions on a system P are equivalent for may testing,although they correspond to different situations.
These definitions state that P will prevent interference if no low level activity can ever distinguish between two different high level processes: if some low level activity is possible for one,then it is also possible for the other. A key point is that high level users should be indistinguishable, rather than high level activity. This means that some possible high level traces can still be ruled out on observing low level behaviour,even if high level processes
cannot be distinguished.
Example 3.3 The process
P1 = (l → Stop ✷ h → Stop)
is may-NI wrt ({h}, {l}). Any low level view is going to see either an l or just the empty trace; and the possibility of the l cannot be prevented by any high level process. Thus no low level test will distinguish any two high level processes. On the other hand,observation of l informs us that h cannot have occurred in that same execution, so it does convey some information about the particular high level activity (i.e. that h has not occurred). Conversely, observation of the empty trace does not convey any information about the high level activity.
Example 3.4 The process
P2 = h → l → Stop

is not may-NI wrt ({h}, {l}). In this case,there are two users, h → Stop and Stop, which can be distinguished by the test l → Stop. If h is required for l to be possible, then observation of l allows the deduction that h must have occurred,and hence that the high level user was able to perform h.
Thus if high level activity is required for particular low level activity,then this definition states that there is interference. But if high level activity leads only to absence of or reduced low level activity (or equivalently that absence of high level activity is required for low level activity) then this definition allows that there is no interference. Any high level user is able to engage in absence of high level activity! This reflects the fact that,in the traces model, U = U H Stop.
Thus identifying a capacity for not performing high level events does not distinguish high level processes,since all high level users have that capacity.

Characterisation in the traces model
It turns out that may non-interference coincides with the property of non- inference proposed by O’Halloran [11]: that if tr ∈ traces(P ) then tr \ H ∈ traces(P ). This may also be expressed as the following equation on P : (Stop 

P ) = (P \ H ).
Theorem 3.5 P is may-NI wrt (H , L) if and only if P \ H = P the traces model.
H

 Stop in
H

Proof. It is a standard result that ∀ T • P may T ⇔ Q may T exactly characterises traces equivalence: P =traces Q .
If P is may-NI wrt (H , L),then given any two users U1 and U2,


(U1 
H
P ) \ H may T ⇔ (U2 
H
P ) \ H may T



for any test T , and so (U1 
H
P ) \ H = (U2 
H
P ) \ H . This is therefore true

for the two particular high level users Stop and RunH ,and so

(Stop 
H
P ) \ H = (RunH
P ) \ H
H

which simplifies to
P  Stop = P \ H
H

Conversely,suppose that Stop 
H
that
RunH ± U ± Stop
P = P \ H . Then any high level user U has

It follows by monotonicity of the CSP operators that


(RunH
P ) \ H ± (U
H
P ) \ H ± (Stop 
H	H
P ) \ H

and hence that


P \ H ± (U
P ) \ H ± Stop  P
H	H



Since P \ H = P
 Stop it follows that all three processes are equal for
H

arbitrary U . Thus all high level users in parallel with P present the same low
level view,and so


(U1 
H
P ) \ H = (U2 
H
P ) \ H

and so they may pass the same tests T . Thus P is may-NI wrt (H , L).	✷
Corollary 3.6 P is may-NI wrt (H , L) if and only if


(U1 
H
P ) \ H = (U2 
H
P ) \ H

for any two high level processes U1 and U2.
The same characterisation also holds for strong may non-interference with respect to (H , L):
Theorem 3.7 P is strongly may non-interfering with respect to (H , L) if and only if


P \ H = P
 Stop
H

Proof. The proof is similar to that for may non-interference with respect to (H , L).
Firstly,if P is strongly may non-interfering wrt (H , L),then the high level users (open on L) RunH ∪L and RunL cannot be distinguished,so (RunH ∪L	

P ) \ H and (RunL

H ∪L
H ∪L
P ) \ H have the same traces. These reduce to P \ H

and P
Stop respectively,so we obtain P \ H = P
H
Stop.
H

Conversely,suppose that P \ H and P
 Stop have the same traces.
H

For any process U open on L and with alphabet H ∪ L we have that
RunH ∪L ± U ± RunL
Hence by monotonicity

(RunH ∪L


H ∪L
P ) \ H ± (U


H ∪L
P ) \ H


i.e.
± (RunL


H ∪L
P ) \ H



P \ H ± (U
and thus
P \ H = (U


H ∪L


H ∪L
P ) \ H ± P


P ) \ H = P
 Stop
H


 Stop
H

Since this is true for any U open on L, it follows that no low level test can distinguish any two high level processes.	✷
Corollary 3.8 Strong may non-interference with respect to (H , L) and may non-interference with respect to (H , L) are equivalent on any process.
As a result of this corollary,we need only investigate one of these forms of non-interference for the rest of this paper; we will use may non-interference.
Signals and high level outputs
The above characterisation of may non-interference assumes a framework in which all high level events are synchronisations between the system and the high level user, and thus that the high level user has a veto over all such events. Low level evidence that such events have occurred thus indeed provide information about the activity of the high level user.
However, there are situations where high level events are required to pass information from the system to the high level process, but where the high level process cannot prevent such events from occurring. Examples include high level signals (such as writing to a screen) or outputs (in I/O automata). They cannot in themselves yield any information about high level user activity, yet their occurrence can be deduced from the low level events. In this paper, signals are another term for non-blockable output events.
For example,a high level output ho might precede low level activity:
P = ho → l → Stop
If ho cannot be refused by the high level, then the occurrence of l gives no information about the high level process. Yet the above characterisation of

may-NI fails: ⟨l⟩ is possible for P \ {ho} but not for P


{ho}
Stop.

For a treatment which allows for high level signals,we must split the high
level interface H into two disjoint sets: signals HO ,and synchronisations HI . In this case, some restrictions must be introduced to the kind of high level user U1 and U2 that should be indistinguishable by low level may testing. In

particular, they should always be able to accept any high level output event
HO . Thus U1 and U2 must be open on HO .
In the presence of high level signals,we enhance the interface information carried in the non-interference property.
Definition 3.9 P is may non-interfering with respect to ((HI,HO),L), or may-NI wrt ((HI, HO), L), if for any test T , and any two high level users U1 and U2 open on HO :

(U1 
H
P ) \ H may T ⇔ (U2 
H
P ) \ H may T

Observe that ‘may-NI wrt ((H , ∅), L)’ is the same as ‘may-NI wrt (H , L)’.
Theorem 3.10 P is may-NI wrt ((HI , HO ), L) if and only if


(Stop 
HI
P ) \ HO = P \ H

Proof. If P is may-NI wrt ((HI , HO ), L), then the two HO -open high level users RunHO and RunH have that

(RunHO
P ) \ H may T ⇔ (RunH
H
P ) \ H may T
H

for any T ,and so


(Stop 
HI
P ) \ HO = P \ H

This means that if tr is a trace of P , then there is a trace of P with the same low level presentation, no high level inputs, and possibly different high level outputs: if tr ∈ traces(P ) then tr \ H ∈ traces(P \ H ) and so

tr \ H ∈ traces((Stop 
HI
P ) \ HO ) and so tr \ H ∈ traces(P \ HO ).

Conversely, assume (P 
HI
Stop) \ HO = P \ H . Any HO -open user U

must have all traces of RunHO as possible traces. Thus
traces(RunH ) ± traces(U ) ± traces(RunHO ) and so by monotonicity

P \ H = (RunH
P ) \ H
H

± (U
P ) \ H
H


and thus
± (RunHO
\ H = (P
H
 Stop) \ HO
HI



(U1 
H
P ) \ H = (U2 
H
\ H

for any two HO -open users U1 and U2—so they may pass exactly the same tests.	✷

In principle, the low level interface L could also be divided into low level signals LO and low level synchronisations LI , with tests restricted to those that can always accept events from LO . In fact this makes no difference— this more restricted set of tests is as discriminating, since any test T that distinguishes two high level users can be transformed into a LO open test T ||| RunLO that also distinguishes them (since the component RunLO does not introduce any more success states.)
Examples
In this section we consider some examples that illustrate various aspects of may non-interference.
Consider the following one-place buffer inputting on a channel l and out- putting on a channel h:
B 1= l ?x : T → h!x → B 1
If h is a high level signal, then B 1 has complete control over when messages on h are sent, and so B 1 exhibits may-NI. In particular, B 1 is may-NI wrt (({}, {h}), {l}).
On the other hand,if h is a high level synchronisation which can be blocked by the high level environment of B 1,then B 1 is not may non-interference. In other words, it is not may-NI wrt ({h}, {l}). In particular, the occurrence of a second low-level message indicates that the high level user has accepted a high level input. In testing terms, a low level test l !0 → l !0 → Success can distinguish the high level user Stop from h?x : T → Stop. In terms of the the characterising trace equivalence,the process B 1 \ h.T = Runl.T ,whereas

B 1 
h.T
Stop = l ?x : T → Stop. Thus B 1 \ h.T /= B1

h.T
Stop: B 1 does not

meet the characterising equation for may-NI.
In order to regain may-NI in the case where h is not a signal,it is necessary to allow further inputs along l even if output on h has not yet occurred. One way of achieving this is to give the buffer infinite capacity:
B 2= B 2⟨⟩
B 2⟨⟩ = l ?x : T → B 2⟨x⟩
B 2⟨v⟩-s = l ?x : T → B 2⟨v⟩-s-⟨x⟩
✷ h!v → B 2s
This process reliably passes all messages from l to h, and is may-NI wrt ({h}, {l}). Any test at the low level cannot tell whether a high level user has picked up any messages or not.
However, if the buffer is restricted to any finite capacity, so that further inputs are blocked when the buffer is full,then may-NI is lost.
To make a finite-capacity buffer may-NI, it is necessary to allow for some messages to be lost when inputs are received into a full buffer, since inputs must always be possible. For example, the following one-place buffer allows

its contents to be overwritten: B 3= l ?x : T → B 3(x ) B 3(x )= l ?y : T → B 3(y )
✷ h!x → B 3
This process is may-NI on ({h}, {l}), but at the cost of possibly losing mes- sages. Worse, a high level user cannot tell from the messages passed along h whether any messages have been lost.
This latter problem can to some extent be addressed by including addi- tional information with the high level output. For example, the number of messages that have been lost since the last high output might be of use to the high level process:
B 4= l ?x : T → B 4(x, 0)
B 4(x, n)= l ?y : T → B 4(y, n + 1)
✷ h!(x.n) → B 4
The type of channel h is T × N. In this example, messages can still be lost, but the high level user will at least know how many (if any) between any two messages. B 4 is also may-NI wrt ({h}, {l}).
Composability
The characterisation of may non-interference allows us to examine which CSP composition operators preserve it. In the non-interference literature, systems are generally composed so as to preserve the classification level of events (see e.g. [9,19]). In this paper we consider such compositions, but we go further and also consider compositions in which parts of one process’ high level interface are connected to parts of another’s low level interface. Thus each process P will be associated with its own classification of events from its interface into high level events HP = HIP ∪ HOP ,and low level events LP .
Interleaving
Two processes are interleaved if they run side by side without any direct interaction. This situation is pictured in Figure 4. The sets HP and HQ can overlap,as can LP and LQ . However,high and low level sets must be disjoint from each other: (HP ∪ HQ ) ∩ (LP ∪ LQ )= ∅).
Theorem 5.1 If P is may-NI wrt (HP , LP ) and Q is may-NI wrt (HQ , LQ ), then P ||| Q is may-NI wrt (HP ∪ HQ , LP ∪ LQ ).


Proof. We show that (P ||| Q ) \ H = (P ||| Q ) 
H
Let H = HP ∪ HQ .
(P ||| Q ) \ H = (P \ H ) ||| (Q \ H )
= (P \ HP ) ||| (Q \ HQ )
Stop.


Fig. 4. P and Q side by side

= (P
 Stop) ||| (Q
HP
 Stop)
HQ

= (P
 Stop) ||| (Q 
H	H
Stop)

= (P ||| Q ) 
H
Stop
✷

The more general case additionally considers high level signals. It requires the additional property that high level events must not be treated as signals by one process and synchronisations by the other.
Theorem 5.2 If P is may-NI wrt ((HIP , HOP ), LP ) and Q is may-NI wrt ((HIQ , HOQ ), LQ ), and (HIP ∪ HIQ ) ∩ (HOP ∪ HOQ ) = ∅, then P ||| Q is may-NI wrt ((HIP ∪ HIQ , HOP ∪ HOQ ), LP ∪ LQ ).
Proof. Let HP = HIP ∪ HOP ,and HQ = HIQ ∪ HOQ .

We show that (P ||| Q ) \ HP ∪ HQ = (P ||| Q )
HOQ ).
(P ||| Q ) \ HP ∪ HQ = (P \ HP ) ||| (Q \ HQ )


HIP ∪HIQ
Stop \ (HOP ∪

= (P


HIP
Stop) \ HOP ||| (Q


HIQ
Stop) \ HOQ

= ((P ||| Q )


HIP ∪HIQ
Stop) \ HOP ∪ HOQ

as required. The last step used the condition that (HIP ∪ HIQ ) ∩ (HOP ∪
HOQ )= ∅.	✷

Chaining
In a chaining composition P  Q , the low level interface of one process is connected to the high level interface of the other. Their resulting common

interface is then hidden. The situation is pictured in Figure 5. The sets H , M , and L are pairwise disjoint. P has alphabet H ∪ M with H as high level events and M as low level,and Q has alphabet M ∪L with M as its high level

events and L as low level. The chain P   Q is defined to be (P
\ M .
M

In this situation, it is in fact sufficient for either one of these processes to
be may-NI for their combination to be may-NI.
Theorem 5.3 If P is may-NI wrt (H , M ), or Q is may-NI wrt (M , L), then P  Q is may-NI wrt (H , L).
Proof. We are concerned with the may-NI wrt (H , L) properties of (P 

Q ) \ M .
((P 
M

\ M ) \ H = ((P \ H ) 
M
M

Q ) \ M

= ((P
 Stop) 
H	M
Q ) \ M


The step
= ((P
Q ) \ M ) 
M	H
Stop



((P \ H ) 
M
Q ) \ M = ((P 
H
Stop) 
M
\ M

is justified in one of two ways, depending on whether it is P or Q that is may-NI:

If it is P ,then (P \ H )= (P
 Stop) and the result follows.
H

If it is Q , then (U
Q ) \ M = (U ' 
M	M
Q ) \ M for any U and U ' by

Corollary 3.6,and the step provides a particular instantiation.
In the presence of signals, where H = HI ∪ HO as before, if P is may-NI on ((HI , HO ), M ),then P  Q is may-NI on ((HI , HO ), L):

(P  Q ) \ M \ H = (P \ H ) 
M	H
Q \ M

= ((P
 Stop) \ HO 
HI	M
Q ) \ M

= ((P
Q ) \ M
M
 Stop) \ HO
HI

Furthermore, if Q is may-NI wrt ((MI , MO ), L) (where M = MI ∪ MO ), and P is open on MO ,then P  Q is may-NI on (H , L) for any H for which α(P ) ⊆ H ∪ M and H ∩ M = ∅. The following reasoning establishes this:

(P  Q ) \ M \ H = ((P \ H ) 
M	M
Q ) \ M

= ((P 
H
Stop) 
M
Q ) \ M	since Q is may-NI

= (P 
M
Q ) \ M
 Stop
H


	H			L	




Fig. 5. P and Q in a chain
since if P is open on MO then so too is P \ H and P

 Stop.
H

However, if P is not open on MO then P   Q need not be may-NI wrt
(H , L),even if Q is. For example
P = h → mo → Stop
Q = mo → l → Stop
Here, Q is may-NI wrt ((∅, {mo}), {l}). However, the fact that P can block mo until after h occurs allows information to flow from high to low. In this case P  Q = h → l → Stop, which is not may-NI wrt (H , L), as observed in Example 3.4.
Of course,if P is also may-NI then we have previously shown that P  Q must be,so any counterexample must make use of some P which is not itself may-NI.	✷

Synchronisation
In the general case, P and Q can synchronise on both high level and low level events. Let H = HP ∪HQ and L = LP ∪LQ with H ∩L = ∅. Observe that HP and HQ can overlap,as can LP and LQ . Let I ⊆ H ∪L be any synchronisation set between P and Q . Then P in parallel with Q on this set will be may-NI whenever P and Q both are.
Theorem 5.4 If P is may-NI wrt (HP , LP ) and Q is may-NI wrt (HQ , LQ ),

then P 
I
Proof.
Q is may-NI wrt (HP ∪ HQ , LP ∪ LQ ).

(P  Q ) \ HP ∪ HQ ± (P \ HP ∪ HQ ) 
I	I
(Q \ HP ∪ HQ )

= (P \ HP ) 
I
(Q \ HQ )

= (P
 Stop) 
HP	I
(Q  Stop)
HQ

= (P


HP ∪HQ
Stop) 
I
(Q	
HP ∪HQ
Stop)

= (P
 Q )	
I	HP ∪HQ
Stop

But (P
 Q )	
I	HP ∪HQ
Stop ± (P
Q ) \ HP ∪ HQ ,so they must be equal.	✷
I


Fig. 6. Some synchronisation between P and Q

This composition covers a variety of cases. In general, P and Q may synchronise on some events and interleave on others. They may have events in common on which they do not synchronise: interleaving (above) is a special case where I = ∅.
When the component processes allow high level signals, the composition preserves may-NI provided none of the signals are involved in any synchroni- sation. In this case, H ∩I must be a subset of HI = HIP ∪HIQ ,and we obtain the following theorem (in which HO = HOP ∪ HOQ ):
Theorem 5.5 If P is may-NI wrt ((HIP , HOP ), LP ) and Q is may-NI wrt

((HIQ , HOQ ), LQ ), and I ∩ (HOP ∪ HOQ ) = ∅ then P
((HIP ∪ HIQ , HOP ∪ HOQ ), LP ∪ LQ ).
 Q is may-NI wrt
I



Proof. We compare (P
Q ) \ H and ((P
I
 Q )	
I	HIP ∪HIQ
Stop) \ HOP ∪ HOQ

and show that each is a refinement of the other.

((P
 Q )	
I	HIP ∪HIQ
Stop) \ HOP ∪ HOQ

= ((P


HIP ∪HIQ
Stop) 
I
(Q	
HIP ∪HIQ
Stop)) \ HOP ∪ HOQ

= ((P


HIP
Stop) 
I
(Q	
HIQ
Stop)) \ HOP ∪ HOQ

= (P


HIP
Stop) \ HOP ∪ HOQ
 (Q	
I	HIQ
Stop) \ HOP ∪ HOQ

since I ∩ (HOP ∪ HOQ )= ∅

= (P \ HP ) 
I
(Q \ HQ )

= (P \ HP ∪ HQ ) 
I
(Q \ HP ∪ HQ )

± (P
Q ) \ HP ∪ HQ
I

but we also have that

(P  Q ) \ HIP ∪ HIQ ∪ HOP ∪ HOQ
I

± ((P
 Q )	
I	HIP ∪HIQ
Stop) \ HOP ∪ HOQ

and hence the two sides are equal, and P
 Q is may-NI with respect to
I

((HIP ∪ HIQ , HOP ∪ HOQ ), LP ∪ LQ ).	✷
However,the result does not hold when the system allows synchronisation on high level signals.
Example 5.6 For example, the following processes have that P is may-NI wrt ((∅, {ho}), {l}) and Q is may-NI wrt (({hi }, {ho}), ∅):
P = ho → l → Stop
Q = hi → ho → Stop
When these two processes are required to synchronise on {ho}, then the re- sulting process behaves as hi → ho → l → Stop which can perform l only after the occurrence of the high level input hi , allowing information to flow from high to low.
Restricted synchronisation
Two special cases of synchronisation obtain when a process Q restricts the behaviour of a process P which is may-NI wrt (HP , LP ), on just one of its interfaces. These two special cases are pictured in Figure 7.
Restriction of the high level behaviour of P is an example of synchroni- sation in which α(Q ) = I ⊆ HP . It immediately follows that Q is may-NI wrt (I , ∅),whatever its definition,since it can perform only high level events.

Hence P
 Q will be may-NI wrt (HP , LP ) whenever P is. Introducing restric-
I

tions to the high level behaviour of P preserves non-interference.
However, the result for this special case does not hold in general in the presence of high level signals, unless there is no synchronisation on them, as was the case for synchronisation composition given above. The processes given in Example 5.6 provide a counterexample here as well.
Similarly, introducing restrictions to the low level behaviour of P also preserves non-interference. If α(Q ) = I ⊆ LP , then Q is may-NI wrt (∅, I ),

and so P
 Q will be may-NI wrt (HP , LP ) whenever P is. This is also true in
I

the presence of high level signals, since in this case Q is only concerned with
low level events,and so there can be no synchronisation on high level signals. Hence Theorem 5.4 is applicable here.
Hiding
The hiding operator abstracts some of the channels in a process interface. In general, these can be both high and low level. This abstraction will always

  HP	









Fig. 7. Restricting P on high and low interfaces


Fig. 8. Hiding inputs and outputs
preserve may-NI: by restricting the interface through which high level users can interact with P , and by restricting the interface through which low level tests can be carried out. This is pictured in Figure 8, where a set A of high and low level events is hidden.
Theorem 5.7 If P is may-NI wrt (H , L), then so too isP \ A.
Proof. The proof is straightforward. (P \ A) \ H = (P \ H ) \ A

= (P 
H
Stop) \ A

± (P \ A) 
H
Stop

But also (P \ A) \ H ± (P \ A) 
H
Stop,and so the two are equal.

If P allows high level signals, then the result still holds, and the proof is
as follows:

((P \ A) 
HI
Stop) \ HO ± (Stop 
HI
\ A \ HO

  HP	

HQ
	LP	
M
LQ



Fig. 9. P and Q in a high-low connection


= (Stop 
HI
\ HO \ A



But P \ A \ H ± (Stop 
HI
= (P \ H ) \ A
= (P \ A) \ H
(P \ A)) \ HO and so the two are equal.	✷


High-low connection
If some of the low level outputs of P are provided as some high level inputs to Q , then may-NI is not preserved in general. The situation is pictured in Figure 9. High-low connection allows some low level output from P as input into Q (with such channels hidden),but with some other low outputs from P remaining available to the low level (unlike chaining, a special case which we have already seen does preserve may-NI).
Example 5.8 The following processes provide an example of a pair of may-NI processes whose composition is not may-NI:
P = m → l → Stop
Q = h → m → Stop
P is may-NI wrt (∅, {m, l}),since it has only low level events. Q is may-NI wrt ({h, m}, ∅), since it has only high level events.

However, (P


{m}
\ {m} = h → l → Stop, which is not may-NI with

respect to any (H , L) for which h ∈ H and l ∈ L.

Observe that P


{m}
Q is not may-NI either—the visibility of {m} makes

no difference (either as a high level set,a low level set,or (for larger interface
sets) divided across the two levels of the resulting process).
Although high-low connection in the general case does not preserve may- NI,this is not altogether surprising since it allows in some sense a downgrading of information from high to low.



  HP	

HQ

M
LQ



Fig. 10. P connected to Q ’s high level interface
Limited high-low connection 1
If P does not have any low level interface apart from that with Q ,as pictured in Figure 10,then if Q is may-NI then so too is the combination of P and Q . P restricts a part of Q ’s high level interface (as in restricted synchronisation above) and also has some independent high level activity)
Theorem 5.9 If HP and HQ are disjoint, P has alphabet HP ∪ M, and Q is

may-NI wrt (HQ ∪ M , L), then (P
\ M is may-NI wrt (HP ∪ HQ , L).
M



Proof. We are considering the system ((P 
M
Q ) \ M ).

(P  Q ) \ M
M


HP ∪HQ
Stop

= ((P
 Stop)
HP


M ∪HQ
Q ) \ M ∪ HQ

= ((P \ HP )


M ∪HQ
Q ) \ M ∪ HQ

= (((P \ HP ) ||| RunHQ )


M ∪HQ
Q ) \ M ∪ HQ	since Q is may-NI

= ((P \ HP ) 
M
Q ) \ M ∪ HQ

= ((P
Q ) \ M ) \ HP ∪ HQ
M

The result also holds when P and Q allow signal events in HP and HQ . In this case, HP is partitioned into HIP and HOP ,and HQ is partitioned into HIQ and HOQ . In the proof we will use the characterisation for may-NI for

Q ,that (U1
U1 and U2.


M ∪HIQ
Q ) \ M ∪ HQ = (U2


M ∪HIQ
Q ) \ M ∪ HQ for any processes

(((P 
M
Q ) \ M )


HIP ∪HIQ
Stop) \ HOP ∪ HOQ

= (((P


HIP
Stop) 
M
(Q	
HIQ
Stop)) \ M ) \ HOP ∪ HOQ

= ((P


HIP
Stop)


M ∪HIQ
Q ) \ M ∪ HIQ ∪ HOQ ∪ HOP

= ((P \ HIP ||| RunHIQ )


M ∪HIQ
Q ) \ M ∪ HIQ ∪ HOQ ∪ HOP

  HP	
	LP	
M
LQ




Fig. 11. Q connected to P ’s low level interface


= ((P \ HIP ) 
M
Q ) \ M ∪ HIQ ∪ HOQ ∪ HOP

= ((P
Q ) \ M ) \ HIP ∪ HIQ ∪ HOP ∪ HOQ
M

This completes the proof for this case.	✷

Limited high-low connection 2
If all of the output from P is provided as input to Q ,as pictured in Figure 11, then may-NI of the combination follows purely from that of P . In fact, Q can be any process and need not itself provide non-interference. This setup is much easier to verify than the previous one.
Theorem 5.10 If P is may-NI wrt (HP , M ∪LP ), and Q has alphabet M ∪LQ ,

then (P
Q ) \ M is may-NI wrt (HP , LP ∪ LQ ).
M



Proof. We are concerned with (P 
M
Q ).

(P  Q ) \ HP = ((P \ HP )  Q )
M	M

= (P
 Stop)  Q
HP	M

= (P
 Q ) 
M	HP
Stop

In the case where there are high level signals, with P being may-NI on ((HIP , HOP ), LP ),we have
(P  Q ) \ HIP ∪ HOP = ((P \ HIP ∪ HOP )  Q )
M	M

= ((P


HIP
Stop) \ HOP )  Q
M

= ((P
 Q ) 
M	HIP
Stop) \ HOP
✷

Thus may-NI is retained by the combination in this case too.


Fig. 12. Cross product of P and Q


Fig. 13. Cascade of P and Q
External composition
The three composition constructs most frequently considered in the literature with regard to composability of non-interference properties are cross-product, cascade,and feedback. The descriptions of [12] will be considered here. In that context,high and low events are classified into inputs and outputs. These can be considered in terms of the compositions that have been discussed already.
Cross-product
The cross product of two systems simply considers one as high level and the other as low level, with no communication between them. It can be pictured as in Figure 12.
In this situation, P has alphabet H and Q has alphabet L. They are therefore both may-NI wrt (H , L). Their combination may be considered as an interleaving P ||| Q , yielding may-NI. Alternatively, they may be considered

as a chain (P 
M
Q ) \ M , (where neither of them ever performs events on the

common channel M ,or where M is empty). This also yields may-NI.
Cascade
A cascade allows both high and low level communication between P and Q , as pictured in Figure 13.

In CSP terms, there will be some intersection HI = HP ∩ HQ between the high level interfaces HP and HQ of P and Q , and also LI = LP ∩ LQ between their low level interfaces LP and LQ . A cascade will then be a parallel combination of P and Q , with their common interfaces treated as internal channels:


(P	
HI ∪LI
Q ) \ (HI ∪ LI )

Since parallel combination (synchronisation) preserves may-NI , and so does hiding,it follows that cascade also preserves may-NI.
Feedback
Feedback is the most complicated of the three composition operators, and in general its definition varies depending on the framework being used for analysis, and can be quite complicated. In [12], some of the output of P is supplied as input to Q ,and similarly the output from Q is provided as input to P . P also accepts input from and provides output to its environment. Messages may be transformed when passing between P and Q . We will use processes RH and RL to describe such transformations. Events are categorised (as high or low) the same way by both processes, so there is no connection from one process’ high events to another’s low events.
In the CSP framework one way of describing this form of feedback is as follows:


(P ||| Q ) 
H
RH ) 
L
RL) \ I

for suitable RH and RL which describe the transformations on the messages passing between P and Q . This is pictured in Figure 14. Since this is com- posed entirely using operations which preserve may-NI (provided there are no signals), it follows that the resulting system is may-NI. Indeed, even if the processes RH and RL were absent, and the processes P and Q connected up directly,this is still true.
In this description a feedback composition in CSP is not much more com- plicated than a cascade: it is simply a parallel combination of two systems with some additional process behaviour at the high and the low level, with some channels hidden. It follows that it preserves may-NI.
Synchronous I/O semantic frameworks describe a form of pure feedback which connects an output of a process directly to one of its own inputs. This form of feedback,in which an output synchronises with an input of the same process,cannot be modelled directly in CSP, since each event in a process ex- ecution is independent. However,a buffered feedback loop is easy to describe. Figure 15 pictures a high level output ho being fed into a high level input hi . This is an example of restricted synchronisation discussed above: the result will be may-NI wrt (H , L) whenever P does wrt (H ∪ {hi , ho}, L).


Fig. 14. CSP view of Feedback between P and Q











Fig. 15. CSP view of Buffered Feedback on P

Discussion
This paper has formulated a non-interference property, may non-interference and has shown that it is compositional in the sense that it is preserved by a wide range of CSP composition operators, including interleaving, synchro- nising parallel (under certain conditions), restriction, hiding, chaining, and forms of high-low connection. As a result it is also preserved by the external operators typically considered in studies of non-interference: cross product, cascade, and forms of feedback. These results hold both when all events are considered as synchronisations,and when high level outputs are considered as signals that cannot be blocked.
The use of a process algebraic approach was originally motivated by the fact that concurrency theory provides a mature framework for defining and analysing properties, and for reasoning about combinations of components. This has resulted in a wide range of results,and in simple proofs.

Semantic frameworks
There have been a large number of approaches to non-interference. To some extent compositionality results must depend on the semantic framework used to model systems, and its composition operators, as well as the characterisa- tion of the non-interference properties within that framework. For example, Wittbold and Johnson [18] and McLean [9] consider processes as sets of traces in which all system inputs and outputs occur in each step. Systems to be composed thus proceed in synchronous lockstep. On the other hand,Goguen and Meseguer [4], McCullough [8] and O’Halloran [11] consider sets of traces in which high and low level inputs and outputs occur independently of each other, as we do in this paper. Zakinthinos and Lee [19] also consider such traces,but require that processes are open on all of their inputs. Noninterfer- ence properties in these frameworks generally take the form that if the system has an execution with a particular low level projection, then there must be other executions,with different high level activity and with the same low level projection. For example,noninference [11] requires that if an execution has a particular low level projection,then there must be some other execution with that same projection but no high level activity at all. Forward correctability, described in [18], requires that it must be possible to alter any high level in- put value, and obtain another trace exactly the same except possibly for the values of subsequent high level outputs. Separability [9] requires that for any low level projection of any execution, and any high level projection of any execution, there must be some execution which combines exactly those two views. These definitions (and others) are motivated by the philosophy that the low level view of an execution should not give away certain information about what has occurred at the high level. Composition results for these prop- erties are obtained in the state machine or event system frameworks in which they are defined and analysed, but the definitions of system composition in these different semantic frameworks will be different to each other, and it is not clear how to compare them,or how to apply results from one approach to another.

Process algebras
There are also a number of approaches which make use of process algebraic techniques, based on CSP [16,15,7], CCS [2], or the (asynchronous) π-calculus [6]. These are often concerned with issues such as nondeterminism, and gen- erally use failures information (traces together with possible refusals) [16,15], bisimulation information (whether processes can match executions by passing through matching states) [2], or testing [6] to characterise non-interference properties. Thus if some high level activity can possibly lead to different low level offers being made, then such characterisations will identify this even if the low level trace does not provide that information.
For example,the process

P = (l → h → Stop) ✷ (h → (Stop H l → Stop))
can perform l and h in either order, but if h occurs first then there is a non- deterministic possibility that l will not be offered; the refusal of l will provide information that h has occurred. However, each of its low level traces ⟨⟩ and
⟨l⟩ is compatible with each of its high level traces ⟨⟩ and ⟨h⟩. Some infor- mation other than traces is required to identify the possibility of information flow via the refusal.
Ryan proposed a generalisation of the Goguen and Meseguer unwinding characterisation of non-interference,[16] by stipulating that the set of refusal events and the set of possible next events for any state are the same for traces whose low level views match. This property is violated by P above, since initially (on the trace ⟨⟩) it cannot refuse l ,but it can refuse l after occurrence of the first h (on the trace ⟨h⟩).
More recently, Roscoe, Woodcock, and Wulf [15] proposed that a process exhibits non-interference if its low level behaviour is deterministic whenever its high level behaviour is abstracted. This means that whatever high level behaviour occurs, the low level view will be unaffected. This property also incorporates refusal information, since this is required to identify nondeter- minism. The process P above does not meet this property, since when h is abstracted the resulting low level process can both perform and refuse to per- form l . This definition is very strong, and is preserved by refinement (unlike the majority of non-interference properties), but it rules out many processes which contain some nondeterminism,even if there is no information flow.
To allow nondeterminism, and motivated by the desire to find a property preserved by refinement,Lowe [7] recently proposed a definition which essen- tially requires that any resolution of nondeterminism in the process yields a process that meets Ryan’s unwinding conditions. P fails to meet this property as well.
In the context of CCS, Focardi and Gorrieri [3] propose that a system Q does not allow information flow if Q prevented from performing H is ‘equiva- lent’ to Q with all occurrences of H hidden: a low level user should not be able to tell whether events in H have occurred or not. By varying the notion of ‘equivalence’ to cover a variety of failure and bisimulation equivalences, this gives rise to a variety of forms of non-interference. Our characterisation of may-NI is the same as their notion instantiated with trace equivalence or may testing equivalence. The process P above does not meet their definition when failures equivalence is used: the possibility of l ’s refusal after the occurrence of h is identified. By using bisimulation equivalence, yet more subtle properties can also be identified.
For example,the process
P' = l1 → l2 → Stop ✷ l1 → l3 → Stop
✷ h → l1 → (l2 → Stop H l3 → Stop)
is able to perform l1 at the low level followed nondeterministically by either

l2 or l3. This is consistent with h either present or absent at the high level. However,if h is performed,then the nondeterministic choice between l2 and l3 is not resolved until after l1,whereas if h is not performed,then it is resolved on the occurrence of l1.	This is the kind of distinction that bisimulation equivalence picks up, and so by using (weak) bisimulation as the equivalence for non-interference, we find that P' allows interference since h can interfere with the point at which a choice is resolved. If this kind of information is available to a low level user,then there will have been some information flow. Even in cases where this equivalence is stronger than required,bisimulation equivalence is often efficient to check, and in cases where it does hold it will
imply weaker properties that are required.
Testing
Testing equivalences are also considered by Focardi and Gorrieri,though they use such equivalences directly in their definition,that P blocked on H should be testing equivalent to P with H hidden. This is the characterisation arrived at in this paper, but it was obtained from a simpler starting point in a def- inition of non-interference. This paper thus provides additional insight into their definition.
A formulation similar to the starting point taken in this paper is proposed by Hennessy and Riely [6] in the context of the more expressive asynchronous π-calculus. They formulate conditions (using types) on P and Q which guar- antee a non-interference property: that if P and Q are equivalent under may testing at a particular security level, then P | H and Q | K are equivalent under may testing for arbitrary top level processes H and K . Our formulation uses a single process in place of P and Q ,requiring that P | H and P | K are indistinguishable, but this is a minor difference. The greater expressiveness of the π-calculus over CSP allows dynamic process creation, and network re- configuration, which may provide more opportunities for information to flow from high to low. Questions as to which systems exhibit non-interference are thus different to those for CSP. However, the formulation of non-interference in terms of the impact of the system,in conjunction with a high level user or process,on its low level environment,is strikingly similar to that presented in this paper.
Must testing
The process P described above allows information about occurrence of the high level event h to be deduced from a low level refusal of l . The may testing characterisation of non-interference presented in this paper is not fine enough to capture this, and in fact the process P is may-NI. However, it is easy to imagine a scenario in which the event l is blocked during an execution, and that this is observed at the low level. It would seem that a formulation of non-interference which is sensitive to refusal information would be of benefit.

The form of testing which corresponds to failures/divergences equivalence in CSP is must testing . This states that P must pass a test T if all (maximal)

executions of (P
T ) \ Σ reach a success state of T . Then P and Q are
Σ

equivalent under must testing if they must pass exactly the same tests T .
This form of testing seems to offer some opportunity for making the kind of distinctions we wish to make. It would be natural to state that P is must-NI

if U1 
H
P is must equivalent to U2 
H
P for any two high level processes U1 and

U2. For example, the test T = l → Success is able to distinguish Stop	P
h

from h → Stop
P through must testing: the first process must pass T , but
h

the second might not,since the l might be prevented from occurring. However,
must-NI does not exhibit such pleasant properties as may-NI.
Firstly,it turns out that must-NI and strong must-NI (in which high level users can observe, though not prevent, low level events directly) are distinct. For example,the system
P = l1 → ( (Stop H l2 → Stop) ✷ h1 → l2 → Stop)
✷ h1 → l1 → (Stop H l2 → Stop)
is must-NI because at the low level it is always guaranteed to initially offer l1, and then either refuse l2 or offer it. If a high level process in the configuration of Figure 2 can initially refuse h1 then this will not be affected by the occurrence of l1, and so both alternatives must be possible. If it can initially perform h1 then this might occur before l1 and hence again lead to the two possibilities.
On the other hand, P is not strong-NI. The high level process
l1 → ((h1 → l2 → Stop) ✷ (l2 → Stop))
in the configuration of Figure 3 is able to make h1 available precisely after l1 has occurred,so that l2 cannot be refused after l1. On the other hand,a high level process Stop is not able to do this. Thus the low level test l1 → l2 → Success will distinguish between these two possibilities.
Conversely,if a process is strong must-NI,then it is must-NI.
With regard to compositionality,must-NI is not preserved by many of the CSP operators, not even by interleaving (and hence not by general parallel composition)! For example,we have seen that process P above is must-NI. So too is
Q = l3 → h3 → Stop
However, P ||| Q is not must-NI. A high level process h3 → h1 → Stop can provide some information concerning the occurrence of h1.
Consider the low level behaviour (⟨l1, l3⟩, {l2}) of P ||| Q . This is possible if the high level process is Stop, but not if it is h3 → h1 → Stop, since the occurrence of l3 after l1 ensures that h1 can only occur after l1, and hence ensures that l2 cannot be refused after ⟨l1, l3⟩. Thus the test l1 → l3 → l2 →

Success allows those two high level processes to be distinguished under must testing.
The situation is fractionally better with regard to strong must-NI. This counterexample does not hold, because P is not itself strong must-NI. It is currently an open question as to whether or not strong must-NI is preserved by interleaving (let alone general parallel composition).
Although both forms of must-NI are initially plausible definitions,it is not clear what they correspond to in an intuitive sense. Furthermore, the rather bizarre examples given above seem to indicate that they are not straight- forward. When a system is examined for information flow, we are generally concerned with what might leak during a single execution. We do not gen- erally assume that the low level agent has the opportunity to interact with the system, from the same state, as many times as is necessary to exercise all of its possibilities. Yet this is the situation encapsulated by must testing. For the kind of property we are concerned with,it would be more appropriate to include some notion of refusal test [13,10] so that the refusal information obtained during a single execution can be accounted for in a semantic model that deals with this directly, perhaps in conjuction with an extended notion of may testing. This is the subject of current research.

Acknowledgements
This work has benefitted from discussions with Peter Ryan, and from the careful reading and comments of the anonymous referees. The work has also received financial support from DERA.

References
J. W. Davies and S. A. Schneider. Recursion induction for real-time processes.
Formal Aspects of Computing, 5(6), 1993.
R. Focardi and R. Gorrieri. A classification of security properties for process algebras. Journal of Computer Security, 3(1), 1994/5.
R. Focardi and R. Gorrieri. The compositional security checker: A tool for the verification of information flow security properties. IEEE Transactions on Software Engineering, 23(9), 1997.
J. A. Goguen and J. Meseguer. Security policies and security models. In IEEE Symposium on Security and Privacy, 1982.
M. Hennessy. Algebraic Theory of Processes. MIT press, 1988.
M. Hennessy and J. Riely. Information flow vs. resource access in the asynchronous pi-calculus. In 27th International Colloquium on Automata, languages and programming, number 1853 in LNCS. Springer-Verlag, 2000.

G. Lowe. Defining information flow. Technical Report 1999/3, University of Leicester, 1999.
D. McCullough. Specifications for multi-level security and a hook-up property. In IEEE Symposium on Security and Privacy, 1987.
J. McLean. A general theory of composition for trace sets closed under selective interleaving functions. In IEEE Symposium on Research in Security and Privacy, 1994.
A. Mukkaram. A Refusal testing Model for CSP. D.Phil, Oxford University, 1993.
C. O’Halloran. A calculus of information flow. In Proceedings of European Symposium on Research in Information Security, 1990.
R. V. Peri, W. A. Wulf, and D. M. Kienzle. A logic of composition for information flow properties. In 9th IEEE Computer Security Foundations Workshop, 1996.
I. Phillips. Refusal testing. Theoretical Computer Science, 50(3), 1987.
A. W. Roscoe. The Theory and Practice of Concurrency. Prentice-Hall, 1997.
A. W. Roscoe, J. Woodcock, and L. Wulf. Non-interference through determinism. In European Symposium on Research in Computer Security, 1994.
P. Y. A. Ryan. A CSP formulation of non-interference and unwinding. Cipher, 1991.
S. A. Schneider. Concurrent and Real Time Systems: the CSP approach. John Wiley, 1999.
J. T. Wittbold and D. M. Johnson. Information flow in nondeterministic systems. In Symposium on Research on Security and Privacy, 1990.
A. Zakinthinos and E. S. Lee. A general theory of security properties. In IEEE Symposium on Security and Privacy, 1997.

A	The Traces Model
There is a universal set of events Σ. A trace is a finite sequence of events drawn from Σ. A set of traces S is in the traces model MT if and only if:
S is non-empty;
S is prefix closed: whenever tr1 - tr2 ∈ S ,then tr1 ∈ S
The function traces : CSP → MT maps CSP process descriptions to sets of traces in MT . It is defined compositionally for each of the operators provided by CSP. Here we give the definitions for the operators introduced in this paper.

traces(Stop)= {⟨⟩}
traces(a → P )= {⟨⟩} ∪ {⟨a⟩ - tr | tr ∈ traces(P )}
traces(c!v → P )= {⟨⟩} ∪ {⟨c.v⟩ - tr | tr ∈ traces(P )}
traces(c?x : T → P (x )) = {⟨⟩} ∪ {⟨c.v⟩ - tr |v ∈ T ∧tr ∈ traces(P (v ))}
traces(P H Q )= traces(P ) ∪ traces(Q )
traces(P ✷ Q )= traces(P ) ∪ traces(Q )

traces(P
 Q )= {tr | ∃ trP , trQ . trP ∈ traces(P ) ∧ trQ ∈ traces(Q )
A

∧ tr ∈ trP
trQ }
A

traces(P ||| Q )= {tr | ∃ trP , trQ . trP ∈ traces(P ) ∧ trQ ∈ traces(Q )
∧ tr ∈ trP  trQ }
∅
traces(P \ A)= {tr T (Σ \ A) | tr ∈ traces(P )}
traces(RunA)= {tr | tr ∈ A∗}
where tr T A is the projection of the trace tr onto the set A ⊆ Σ: the maximal subsequence of tr all of whose events appear in A.

The set of traces tr1
 tr2 is defined inductively as follows:
A

⟨⟩ ∈ ⟨⟩  ⟨⟩
A

tr ∈ tr1  tr2 ∧ a ∈ A	⇒	⟨a⟩ - tr ∈ (⟨a⟩ - tr1) 
A
tr ∈ tr1  tr2 ∧ b /∈ A	⇒	⟨b⟩ - tr ∈ (⟨b⟩ - tr1) 
A
(⟨a⟩ - tr2)
tr2

tr ∈ tr1  tr2 ∧ b /∈ A	⇒	⟨b⟩ - tr ∈ tr1
 (⟨b⟩ - tr2)
A

It is the set of traces which agree with both tr1 and tr2 on events in the set
A,and which interleave on the events from tr1 and tr2 not in the set A.
For a process P defined by a recursive equation P = F (P ), the traces of
P are given by:
traces(P )=   traces(Fn(Stop))
n∈N
For a family of processes ⟨Pi ⟩i∈I defined by a family of recursive equations
Pj = Fj (⟨Pi ⟩i∈I ) (where each Fj is a function on the entire vector of Pi

processes),we define the function F : M I
→ M I
as follows:

F (⟨Xi ⟩i∈I )= ⟨Fj (⟨Xi ⟩i∈I )⟩j∈I
Then the traces of all the Pi are given by:
traces(Pi )=   traces((Fn(⟨Stop⟩i∈I ))k )
n∈N
A fuller explanation of the semantics of mutual recursion in CSP can be found in [1].
