Electronic Notes in Theoretical Computer Science 72 (2007) 31–44	
www.elsevier.com/locate/entcs

Inequational Deduction as Term Graph Rewriting 1
Andrea Corradini2 and Fabio Gadducci2
Dipartimento di Informatica, Universita` di Pisa, Italy
Wolfram Kahl3
Department of Computing and Software, McMaster University, Canada
Barbara Ko¨nig4
Institut fu¨r Informatik, Technische Universita¨t Mu¨nchen, Germany

Abstract
Multi-algebras allow to model nondeterminism in an algebraic framework by interpreting operators as functions from individual arguments to sets of possible results.
We propose a simple inequational deduction system, based on term graphs, for inferring inclusions of derived relations in a multi-algebra, and we show that term graph rewriting provides a sound and complete implementation of it.
Keywords: Multi-algebra, nondeterminism, inequational deduction system, term-graph rewriting


Introduction
The extension of algebraic specification techniques for the treatment of nondeter- minism is the topic of numerous contributions to the literature in the last two decades (see [10] for an overview). It is recognised that nondeterminism shows up not only in the specification of intrinsically nondeterministic systems, like concur- rent systems, but also when the system is deterministic and one wants to abstract

1 This work has been partially supported by the Italian MIUR project cometa (Computational Metamod- els); and by EU within the FET – Global Computing initiative, project agile IST-2001-32747 (Architectures for mobility ). The funding bodies are not responsible for any use that might be made of the results presented here.
2 Email: {andrea, gadducci}@di.unipi.it
3 Email: kahl@cas.mcmaster.ca
4 Email: koenigb@in.tum.de

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2002.09.004

away from implementation details or, in general, from information that would be necessary for a complete description of the system (like timing considerations, in- ternals of the states, etc.).
Many extensions of specification techniques to nondeterminism strive for being non-intrusive or conservative, namely, they try not to change the existing frame- work for deterministic specifications, and in particular they reduce to the standard theory when only deterministic operations are considered [11]. This fact possibly explains the success of multialgebras among the other algebraic approaches, such as
e.g. power algebras. Generalising standard partial algebras, in multi-algebras an operator of the signature is interpreted as a function from individual arguments to sets of possible results.
However, the matter concerning deduction systems for (in)equational specifica- tions is not yet fully settled. Problems are of a syntactical nature, and they are tightly related to the so-called lack of substitutivity. Roughly, this means that term equivalence is not preserved under the substitution of free variables. This fact sug- gested to look for alternative presentations of derived operators in a multialgebra, as well as for developing ad hoc inference systems.
In [2] a functorial semantics for multialgebras is proposed, extending the classical results concerning algebraic theories. A side result was precisely the characterisation of a simple syntactical device for representing derived operators in a multialgebraic specification, namely, by means of term graphs. In fact the notion of sharing, which is implicit in the framework, allows for an immediate representation both of non- determinism and domain-restriction, thus obtaining an effective tool for specification in this setting.
In this paper we move a step further, proposing the use of inequations based on term graphs for specifying the inclusion between derived relations in a multi-algebra. We present a deduction calculus for such inequations, proving its soundness (while its completeness is still an open problem). More interestingly, we prove that term graph rewriting [9] provides an adequate implementation of inequational deduction, in the sense that F ± G can be deduced if and only if F rewrites to G. This provides an original application of term graph rewriting, which is defined in this paper according to the well-known double-pushout approach in the category of dag’s, even if the format of our rules is more general than the format usually considered in the literature [8].

Multi-algebras and relations
The interpretation of a signature operators as relations allows for modeling in an al- gebraic framework some sort of nondeterministic behaviour [10]. For multi-algebras, the relation associated with an operator is a function mapping each input value to a set of (possible) output values. Quite obviously, this is equivalent to the usual definition of relations as subsets of the direct product.
Definition 2.1 (relations) Let A and B be two sets. A relation R : A ↔ B
is a function R : A → P(B), where P is the power-set operator. A relation is

total if |R(a)| ≥ 1 for all a ∈ A; it is univalent (functional) if |R(a)| ≤ 1 for all a ∈ A. Given two relations P, R : A ↔ B, P is included in R (written P ⊆ R) if P (a) ⊆ R(a) for all a ∈ A.
Therefore a univalent relation is a partial function R : A - B, while a univalent and total relation is just a function R : A → B. We shall consider the following operations on relations.
Definition 2.2 (union and composition on relations) For a set A, let Ai de- note the direct product of i copies of A. Given two relations P : Aj ↔ Ai and R : Al ↔ Ak, their union is the relation P ⊕ R : Aj+l ↔ Ai+k deﬁned as P ⊕ R(⟨a1,... aj+l⟩)= {⟨b1,... bi+k⟩| ⟨b1,... bi⟩∈ P (⟨a1,... aj⟩) ∧ ⟨bi+1,... bi+k⟩∈ R(⟨aj+1,... aj+l⟩)}.
Given two relations P : A ↔ B and R : B ↔ C, their composition P ; R : A ↔ C denotes the relation obtained by composing P with R+ : P(B) → P(C), the additive extension of R.
For the sake of simplicity, throughout the paper we restrict our analysis to one- sorted signatures, and we denote by Σ an arbitrarily fixed one.
Definition 2.3 (multi-algebras) A multi-algebra A over a (ﬁnite) signature Σ= 
i∈N Σi is a pair ⟨|A|, ρA⟩, where the carrier |A| is a set, and ρA = {fA | f ∈ Σ} is a family of relations such that, for every f ∈ Σi, fA : |A|i ↔ |A|.
Moreover, we define arity(f )= i iff f ∈ Σi, for all operators f ∈ Σ.

Term Graph Rewriting
This section introduces term graphs and some operations on them following [1], as well as term graph rewriting. To avoid possible confusion, let us anticipate that we shall consider three different kinds of “term graphs”:
Directed acyclic graphs (dag’s) are the basic ones: we shall introduce the category DAG where they live, and “term graph rewriting” will be defined according to the double-pushout approach in this category.
Ranked dag’s are dag’s equipped with chosen root and variable nodes.
Term graphs are isomorphism classes of ranked dag’s.
While dag’s are the objects to be rewritten, their ranked counterparts will be used to define suitable operations over dag’s. In fact, they will be needed to characterise the derived operators of a multialgebraic specification.
Definition 3.1 (directed acyclic graphs and morphisms) A  directed acyclic graph (dag) (over Σ) is a triple d = ⟨N (d), ld, sd⟩, where N (d) is a set of nodes, ld : N (d) - Σ is a partial function called the labeling function, and
sd : N (d) - N (d)∗ is a partial function called the successor function, such that the following conditions are satisﬁed:
dom(ld)= dom(sd);

R = (dL (	l
g
v
dG (	d
dK	r
k v dD
b
) dR)

h
v
) dH


Figure 1. Rewriting step as double-pushout construction.

for each node n ∈ dom(ld), arity(ld(n)) = length(sd(n));
d has no cycles (deﬁned in the expected way).
A node n ∈ N (d) is called empty if n /∈ dom(ld). We let N∅(d) denote the subset of empty nodes of N (d), and NΣ(d)= N (d)\N∅(d).
A (dag) morphism f : d → d' is a function f : N (d) → N (d') that preserves labeling and successors; it is an isomorphism if in addition f is a bijection and also its inverse function f −1 : N (d') → N (d) is a dag morphism. We shall denote by DAG the category having dag’s as objects and dag morphisms as arrows.
A dag morphism f : d → d' is Σ-injective if its restriction to NΣ(d) is injective; it is strongly acyclic if for all a1 ∈ N∅(d) and a2 ∈ NΣ(d) there is no path from f (a1) to f (a2) in d'; and it is plain if it is both Σ-injective and strongly acyclic. It is easy to verify that Σ-injective morphisms compose, as well as strongly acyclic
ones.
The rewriting formalism that we shall use is the standard algebraic double- pushout approach [6] in the category of dag’s. We first introduce the general definition of rewriting. Next in Section 5 we shall concentrate on a specific format of rules, for which we shall investigate the adequacy with respect to its representation of inequational deduction.
Definition 3.2 (dpo rewriting in the category of dag’s) A	(term	graph
l	r
rewriting) rule R = (dL ← dK → dR) is a span of dag morphisms. The dag’s dL, dK, and dR are called the left-hand side, the interface, and the right-hand side of R, respectively. A (term graph) rewriting system R is a set of rules.
Given a dag dG, a rule R = (dL  l	K →r  dR), and a match (i.e., a dag
← d
morphism) g : dL → dG, we say that dG rewrites to dH (using R and g) if the diagram in Figure 1 can be constructed, where both squares are pushouts in category DAG. In this case, dD is called the context (dag), and we write dG ⇒R,g dH ,

possibly omitting the subscripts. We write dG ⇒∗
dH if there is a possibly empty

sequence of rewriting steps from G to H, using rules in R.
As usual with dpo presentations, also an operational description of the rewriting mechanism is available. However, it differs from the standard construction holding
e.g. in the category of graphs, and for more details we refer the reader to [4], as well as to Lemma 5.4, to be presented later on.
Definition 3.3 (ranked dag’s and term graphs) A (j, i)-ranked dag is a triple g = ⟨r, d, v⟩, where d is a dag with exactly j empty nodes, r : i → N (d)

is a function 5 called the root mapping, and v : j → N∅(d) is a bijection (be- tween j and the empty nodes of d) called the variable mapping. If g = ⟨r, d, v⟩ and g' = ⟨r', d', v'⟩ are two equally-ranked dag’s, a ranked dag morphism ϕ : g → g' is a dag morphism ϕ : d → d' such that ϕ ◦ r = r' and ϕ ◦ v = v'.
A (j, i)-ranked term graph G is an isomorphism class of (j, i)-ranked dag’s.
There are two natural operations on term graphs, defined as follows.
Definition 3.4 (composition and union of term graphs) Let Gj , Hi be term
k	j
graphs. Their composition is the term graph Gj ; Hi of rank (k, i) obtained by ﬁrst
k	j
taking the disjoint union of the graphs underlying G and H, and then gluing the
roots of G with the corresponding variables of H.

Let Gi , Hk be term graphs. Their union is the term graph Gi ⊕ Hk
of rank

j	l	j	l
(j + l, i + k) obtained by ﬁrst taking the disjoint union of the graphs underlying G
and H, and then concatenating the roots (variables) of G with the roots (variables) of H. 6
The drawing below shows four term graphs. Empty nodes are represented by the natural numbers corresponding to their position in the list of variables, and are depicted as a vertical sequence on the left; nonempty nodes are represented by their labels, from where the edges pointing to the successors leave; the list of numbers on the right represent pointers to the roots: a dashed arrow from j toa node indicates that it is the j-th root. For example, the first term graph G1 has e.g. rank (2, 4), five nodes (two empty, 1 and 2, and three nonempty, f , g and k), the successors of g are the variables 2 and 1 (in this order), the successors of f are g and 2, the
successor of k is 2, and the four roots are g, f , k, and f .	1 2  g	1
1	1
2	f
1
1	1	3	k	3
2	4	h	4
3	5  2	5
4	6

G1	G2
G3 = G1 ; G2
G4 = G1 ⊕ G2

These conventions facilitate the understanding of the two basic operations on term graphs. The composition of two term graphs is obtained by first matching the roots of the first term graph with the variables of the second, and then eliminating these variables. Term graph G3 is e.g. the composition of G1 and G2. The union is essen- tially their disjoint union, where the lists of variables and roots are concatenated. Term graph G4 is the union of G1 and G2.



5 For a natural number k we assume k = {1, . .., k}, thus 0 = ∅.
6 Let Gj = ⟨[r, d, v⟩] and Hi = ⟨[r', d', v']⟩. Then, G; H = ⟨[r'', d'', v'']⟩, for d'' the disjoint union of d and
k	j
d', modulo the equivalence on nodes induced by r(x)= v'(x) for all x ∈ j, and r'' : dr → d'', v'' : dv → d''
the uniquely induced arrows. Let Gi = ⟨[r, d, v]⟩ and Hk = ⟨[r', d', v']⟩. Then, G ⊕ H = ⟨[r'', d'', v'']⟩, for
j	l
d'' the disjoint union of d and d', and r'' : i + k → d'', v'' : j + l → d'' the uniquely induced arrows.

Term Graph Inequational Deduction
As standard first-order terms denote derived operations in total algebras, so term graphs are particularly suited for denoting derived relations in a multi-algebra (see [2] for a detailed discussion about this).
Definition 4.1 (relation represented by a term graph) Given  a  multi- algebra A over Σ and a term graph G of rank (j, i), by GA we denote the relation GA : |A|j ↔ |A|i deﬁned as follows. Let ⟨r, d, v⟩ be any ranked dag in G, such that N (d)= {n1,... , np}; then




∃xn1



... xnp
⟨b1,... bi⟩∈ GA(⟨a1,... aj⟩) ⇔
⎧⎪ ∀n ∈ N (d) . xn ∈ |A| ∧	⎫⎪
. ⎪⎨ ∀k ∈ j . xv(k) = ak ∧	⎬

⎪⎩ ∀h ∈ i . xr(h) = bh
d	d	d
⎪⎭

wher sd(m) ↑ i denotes the i-th element of the sequence sd(m), for each node m ∈
NΣ(d) and i = 1,... , arity(ld(m)).
In other words, we take an element of the carrier of the multi-algebra A for each node of the term graph. The tuples of elements corresponding to roots and variables of G are in relation GA if each element corresponding to a node m such that ld(m)= f ∈ Σk belongs to f A(m1,... , mk), where m1,... , mk are the successors of
m. It is easy to prove that the definition is well-given, in the sense that it does not depend on the concrete representative chosen for G.
As an example, consider the term graph G3 above. It has rank (2, 1), thus GA
is a function from |A|2 to P(|A|), defined as follows:
b ∈ GA(a1, a2) ⇔
∃x1, x2, xg, xf , xh, xk ∈ |A| .  x1 = a1 ∧ x2 = a2 ∧ xg ∈ gA(x2, x1) ∧
xf ∈ f A(xg, x2) ∧ xh ∈ hA(xg, xf ) ∧ xk ∈ kA(x2) ∧ b = xh}
where f A, gA, hA and kA are the fundamental relations corresponding to the inter- pretation of the operators of the signature in the multialgebra A.
As further examples, let us consider now two (quite degenerate) term graphs that will play some roˆle in a moment. By !j (a discharger ) we shall denote the only discrete term graph of rank (j, 0), thus having j variable nodes and no roots. By
∇j (a duplicator ) we shall denote the discrete term graph of rank (j, 2j) such that variable k is both the k-th and the (k + j)-th root, for k ∈ j. By applying the general formula above, one easily gets (denoting ⟨⟩ the only element of |A|0) that for all a1,... , aj ∈ |A|,
!A(a1,... , aj)= {⟨⟩}, and
∇A(a1,... , aj)= {⟨a1,... , aj, a1,... , aj⟩}

In particular, notice that both relations are total and univalent, that is, they are just functions.
Quite importantly, the mapping ( )A from term graphs to derived relations over A can be easily shown to be a homomorphism with respect to the operations intro- duced in Definition 2.2 and Definition 3.4.
Lemma 4.2 Let A be a multialgebra and F, G be two term graphs. Then (F ⊕G)A =
FA ⊕ GA and (F ; G)A = FA ; GA.	 

Having chosen term graphs to denote derived relations in a multi-algebra, we can explore their use in specification. Following a well-established tradition in the theory of multi-algebras, we shall consider inequations, which are naturally interpreted as inclusions between the corresponding relations.
Definition 4.3 (term graph specifications) A (term graph) inequation over Σ
is a pair ⟨F, G⟩ of equally-ranked term graphs, usually written F ± G.
Given a multi-algebra A over Σ, we say that inequation F ± G holds in A (and we write A |= F ± G) if FA ⊆ GA. Given a class A of multialgebras, the same inequation holds in A (written A |= F ± G) if it holds for all A ∈ A.
A (term graph inequational) specification is a pair ⟨Σ, Φ⟩, where Φ is a set of term graph inequations over Σ. Given a speciﬁcation ⟨Σ, Φ⟩, the class of its models is MAlgΣ,Φ = {A ∈ MAlgΣ | A |= ϕ for all ϕ ∈ Φ}
In other words, an inequation F ± G holds in A if relation FA is included in relation GA. The next step is to try and characterise syntactically the inclusion of derived relations in a multialgebra satisfying a given set of inequations.
Definition 4.4 (term graph inequational deduction) Let ⟨Σ, Φ⟩ be a term graph inequational speciﬁcation. Then, an inequation F ± G is deduced from the speciﬁcation, written as Φ ▶ F ± G, if the inequation can be obtained by the follow- ing set of axioms and inference rules
[axiom]
ϕ ∈ Φ
Φ ▶ ϕ
[structural axioms] For all term graphs G of rank (j, i),

Φ ▶ G; !i ±!j	Φ ▶ G; ∇i ± ∇j; (G ⊕ G)
[reflexivity and transitivity] For all G, H, K of rank (j, i),




Φ ▶ G ± G
Φ ▶ G ± H,	Φ ▶ H ± K
Φ ▶ G ± K

[substitutivity] For all G1, H1 of rank (j, i) and G2, H2 of rank (i, k),
Φ ▶ G1 ± H1,	Φ ▶ G2 ± H2
Φ ▶ G1; G2 ± H1; H2

[congruence] For all G1, H1 of rank (j, i) and G2, H2 of rank (k, l),
Φ ▶ G1 ± H1,	Φ ▶ G2 ± H2
Φ ▶ G1 ⊕ G2 ± H1 ⊕ H2
Let us comment on the structural axioms. As discussed above, for every multi- algebra A the interpretation of !A is fixed, and it is the total function from |A|j to the singleton set |A|0. Therefore, whatever is the relation GA : |A|j ↔ |A|i, the composition GA ; !A is a possibly partial function to a singleton set, thus (G ; !i)A ⊆
!A necessarily holds.
Concerning the second structural axiom, it formalises the fact that if we take twice (using the duplicator) the result of evaluating the non-deterministic expression represented by G, in general we obtain less results than evaluating it twice, because the two evaluations may deliver different results (see [3] for more details about this). Note also that the closure with respect to the operations explicitly ensures that substitutivity holds. Given this explanation of the structural axioms and Lemma
4.2, it comes as no surprise that the above calculus is sound.
Theorem 4.5 (soundness of term graph inequational deduction) Let
⟨Σ, Φ⟩ be an inequational speciﬁcation, and F ± G an inequation over Σ:
Φ ▶ F ± G	=⇒	MAlgΣ,Φ |= F ± G

We were not able to prove the completeness of the calculus. We conjecture it is indeed so, as far as suitable restrictions on the specifications are imposed (see also Definition 5.1).
We conclude this section by showing some examples of inequations, and describ- ing the induced properties on the corresponding derived relations.
Proposition 4.6 (specifying with term graph inequations) Let A be a Σ- multi-algebra, and G a term graph of rank (j, i). Then
A |= !j ± G ; !i   iff GA is a total relation.
A |= ∇j; (G ⊕ G) ± G; ∇i    iff GA is univalent.
Furthermore, let us consider the term graph H of rank (j, k). Then, the derived operator F = ∇j; (G⊕(H; !k)) represents a domain restriction of G wrt. the domain of deﬁnition of H, that is, for all multialgebras A, both FA ⊆ GA and dom(F A)= dom (HA) ∩ dom(GA) hold. Then, we have
A |= ∇j; (G ⊕ (H; !k)) ± G.
A |= G ± ∇j; (G ⊕ (H; !k))	iff dom(GA) ⊆ dom(HA).	 

Term Graph Rewriting for Inequational Deduction
In this section we show how to transform a term graph specification into a term graph rewriting system, in such a way that an inequation F ± G can be deduced

using the system of Definition 4.4 if, and only if, F rewrites to G according to the associated rewriting system.
The relationship between rewriting and logical deduction that we are going to describe follows the same pattern of the relationship between term rewriting and rewriting logic, which is “folklore”, and that is extended to some generalizations of rewriting and logics for example in [7].
We shall consider term graph inequations with a restricted format. Firstly, according to Definition 4.3, both sides of an inequation must have the same rank. Secondly, rules must be proper, a condition generalising the requirement, usual in term rewriting, that a rule cannot have a variable as left-hand side.
Definition 5.1 (proper inequations) A term graph F is proper if no variable node in F is also a root; an inequation F ± G is proper if F is.
Now, we can describe our encoding.
Definition 5.2 (from inequations to rules) Given a term graph F, we shall de- note by |F | an arbitrarily chosen, unranked dag belonging to F. Let F ± G be a proper inequation, both of whose term graphs have rank (j, i). The associated rule
F	l	r
L	K	R
dL and dR are the unranked dag’s |F | and |G|, respectively;
the interface dK is a discrete graph containing i + j nodes;
the morphisms l and r map the i + j nodes of dK consistently to the i roots and the j variables of dL = |F | and dR = |G|, respectively. 7
Example 5.3 The deduction system of the previous section includes the (struc- tural) inequations F ;! ± ! and F ; ∇ ± ∇; (F ⊕ F ). Assuming that F is a term graph including only one root labeled by a k-ary operator f ∈ Σ and k distinct
variables, the two corresponding rules, that we denote R! and R∇, respectively,
have the shape depicted in Figure 2 and Figure 3.
The dag on the left-hand side (center, right-hand side) is dL (dK and dR, re- spectively). The xi, yj’s indicate empty nodes, and are used to intuitively describe the span of dag morphisms: as an example, in rule R∇ the nodes identified by yf1
and yf2, distinct in dK, are coalesced into f in dL.
Note that the left morphism l might not be injective: this happens in the en- coding of a proper inequation F ± G exactly when two roots in F coincide (like in rule R∇).





7 Informally, we assume here that we kept track of which nodes of |F | (|G|) were roots or variables in F
(G, respectively).

x1 ¸,1 ,,, f	x1	x1
, ,,2 , ccc

x2
...
 
kc
ccc
x2
...
x2
...

 c jc	xk	xk


Figure 2. The rewriting rule R!
encoding inequation Gf ;! ± !.



x1 ¸,1 ,,, f
x1	yf 1
x1 ,¸¸,1 ¸,,, f

,,2 , cc	¸¸,¸2 , ee

x2   ,cc	x2
k
c
x2 ¸¸ , 1 ¸,k e
2 ¸e¸¸ ¸

... cc
...	yf2
...
eee
¸¸ f

 c jc
k	xk
ee ,k ,,,,
k


Figure 3. The rewriting rule R∇ encoding inequation Gf ; ∇ ± ∇; (Gf ⊕ Gf ).
The next lemma summarises some results concerning the existence of relevant pushouts and pushout complements, needed to perform the dpo construction in DAG using rules in the format described above. We shall consider plain morphisms only as matches (see Definition 3.1) in view of Lemma 7.3.
Lemma 5.4 (pushout complements in DAG) Let l : dK → dL and r : dK → dR be as in Deﬁnition 5.2, and let m : dL → dG be a plain match which satisﬁes the dangling condition. 8 Then:
If l is injective, then there exists a lattice of pushout complements of l and

m, ordered by existence of a commuting morphism. If dK k	D  d
G is

the minimal pushout complement, 9 then the pushout of k : dK → dD and
r : dK → dR exists.
If l is not injective, then there is a non-empty family of lattices of pushout complements, and each of these lattices enjoys the same property as in the previous point.	 
Since term graph rewriting has been defined over unranked dag’s, but term graph inequations are ranked, we have the need to “encode” in some way the rank inside the structure of a simple dag.
Definition 5.5 (rewriting of ranked term graphs) For each k ∈ N, let kˆ be
an operator of arity k not in Σ, and let Gkˆ be the term graph of rank (k, 1) having one non-variable node labeled by kˆ and k variable nodes.
Let F, H be term graphs (over Σ) of rank (j, k). We say that F rewrites to H

ˆ	∗	ˆ
ˆ def

if |F | ⇒R |H|, where F = F ; Gkˆ.

8 This is a standard application condition for dpo approach: formally, for each node n ∈ N (dL)\l(N (dK )),
'	'
if m(n) ∈ sdG (n ) then n ∈ m(N (dL)). The reader familiar with the dpo approach may note that the
identification condition is ensured by the Σ-injectivity of m.
9 It is still open if this pushout complement can be characterized as the “natural” one, i.e., being a pullback, as in [5].

Note that |Fˆ| ⇒∗
|Gˆ| implies |F | ⇒∗
|G|, but the converse does not hold,

because of the dangling condition. We are now ready to state the main result.
Theorem 5.6 (inequational deduction as rewriting) Let ⟨Σ, Φ⟩ be an inequa- tional speciﬁcation, and let R(Φ) be the set of rules including the structural rules
! and R∇ for all f ∈ Σ (see Example 5.3), and one rule for each inequation ϕ ∈ Φ
as for Deﬁnition 5.2. Then
Φ ▶ F ± G	iff	|Fˆ| ⇒∗	|Gˆ|

A sketch of the proof can be found in the Appendix.

Conclusions and Further Works
The main goal of our paper was to find evidences for supporting the claim that term graphs should play for the specification of multi-algebras the same rˆole that standard terms play for total algebras. The technical justification of this comes from a functorial presentation of multi-algebras, originally proposed in [2], where term graphs are proved to be a suitable syntactical tool for the presentation of derived operators in multialgebras.
Our claim was substantiated by presenting a calculus for term graph inequational deduction, and proving its soundness. In particular, the calculus takes full advantage of the use of term graphs, because an unrestricted substitutivity rule holds (which does not hold for other calculi for multi-algebras). More importantly, we proved that the calculus can be implemented by means of term graph rewriting, in such a way that rewriting steps mimic inequational deduction.
As future work, the first problem we would like to tackle is the completeness of the calculus. At the same time, we would also like to compare our calculus with other proposals from the literature with respect to both the complexity of rules, and the expressive power.
Further extensions we foresee include Horn clause logic, and some limited form of negation which appears to be needed in order to have the expressive power to specify satisfactorily, for example, a non-deterministic choice operator (see, e.g., [11]).

References
A. Corradini and F. Gadducci. An algebraic presentation of term graphs, via gs-monoidal categories.
Applied Categorical Structures, 7:299–331, 1999.
A. Corradini and F. Gadducci. A functorial semantics for multi-algebras and partial algebras, with applications to syntax. Theoret. Comput. Sci., 2002. To appear. Available at http://www.di.unipi.it/~ gadducci/papers.
A. Corradini, F. Gadducci, and W. Kahl. Term graph syntax for multi-algebras. Technical Report TR-00-04, University of Pisa, Department of Informatics, 2000.
A. Corradini and F. Rossi. Hyperedge replacement jungle rewriting for term rewriting systems and logic programming. Theoret. Comput. Sci., 109:7–48, 1993.

H. Ehrig and H.-J. Kreowski. Categorical approach to graphic systems and graph grammars. In
G. Marchesini and S.K. Mitter, editors, Mathematical Systems Theory, volume 131 of Lecture Notes in Economics and Mathematical Systems, pages 323–351. Springer, 1976.
H. Ehrig, M. Pfender, and H.J. Schneider. Graph-grammars: an algebraic approach. In R.V. Book, editor, Switching and Automata Theory, pages 167–180. IEEE Computer Society Press, 1973.
F. Gadducci. On the Algebraic Approach to Concurrent Term Rewriting. PhD thesis, University of Pisa, Department of Informatics, 1996.
D. Plump. Term graph rewriting. In H. Ehrig, G. Engels, H.-J. Kreowski, and G. Rozenberg, editors, Handbook of Graph Grammars and Computing by Graph Transformation, volume 2, pages 3–61. World Scientific, 1999.
M.R. Sleep, M.J. Plasmeijer, and M.C.J.D. van Eekelen, editors. Term Graph Rewriting: Theory and Practice. Wiley, 1993.
M. Walicki and S. Meldal. Algebraic approaches to nondeterminism: An overview. ACM Computing Surveys, 29:30–81, 1997.
M. Walicki and S. Meldal. A complete calculus for the multialgebraic and functional semantics of nondeterminism. ACM Trans. Program. Lang. Syst., 17:366–393, 1997.

Appendix
We present here some proof sketches of the main results of the paper. We begin with a technical lemma.
Lemma 7.1 (pushouts in DAG) Let f : d → d'be a dag morphism, and let its associated substitution be the function ϕf : N∅(d) → TΣ(N∅(d')), mapping each variable node n to the term over (Σ, N∅(d')) obtained by “unraveling” f (n).
' f	g	''

Given a span d ← d → d
in DAG, its pushout exists if and only if substitutions

ϕf and ϕg unify.	 
For a proof, see Proposition 1.18 of [4], where the statement is proved for cate- gory JungleΣ, which is equivalent to category DAG. We can now provide a proof skecth of Lemma 5.4.
Proof sketch of Lemma 5.4. For point (i), informally, the minimal pushout complement object dD is obtained from dG by deleting all nodes in m(N (dL)\l(N (dK )), and by making the labeling and successor functions undefined
k'	'
on the nodes in m(l(N (dK ))\N∅(dL)). Given two pushout complements dK → dD
k''	''

and dK
→ dD , their join is their pushout, and their meet is determined by the

pullback of the injections in the pushout.
The existence of the right pushout of Figure 1 for the minimal pushout comple- ment follows from the previous lemma, by observing that out of the j + i nodes of dK , j are mapped by r to distinct variables of dR (by construction), and the other i are mapped by k to distinct variables of dD, thus the corresponding substitutions unify.
For point (ii), intuitively, if l(n)= l(n'), then in a pushout complement object the references to node m(l(n)) in dG can be split in an arbitrary way as refer- ences to k(n) or to k(n'), and each such a choice determines a lattice of pushout complements.	 

The rest of the section is devoted to sketch the proof of our main result, Theo- rem 5.6. We first start with an auxiliary definition.
Definition 7.2 (term graph contexts) A (term graph) context C[j, i] is a well- formed, ranked term graph expression (using term graphs as constants, and the operators ⊕ and ; ) containing exactly one (ranked) place-holder [j, i] (for some i, j ∈ N). If C[j, i] is a context and G is a term graph of rank (j, i), then by C[G] we denote the term graph obtained by evaluating the expression C after replacing [i, j] by G.
Now, we have two technical lemmas. The first relates the connection between plain matches satisfying the dangling condition and contexts; building on that, the second, fundamental lemma states that any rewriting step obtained by applying a rule R is equivalent to embedding R in a context.
Lemma 7.3 (plain morphisms and contexts) Let F be a term graph of rank

(j, i), let dK →l
dL be the left component of a rule RF
(as for Deﬁnition 5.2) and

let dG = |G| be a chosen dag in a term graph G. Then there is a context C[j, i] such that G = C[F ] if and only if there is a plain morphism m : dL → dG satisfying the dangling condition with respect to l.	 

Lemma 7.4 (rewriting as contextualization) Let RF
be the rule associated

with the proper inequation F  ± G, and let S, T be two term graphs.	Then

|Sˆ| ⇒ F
G
|Tˆ| if and only if there exists a context C such that S = C[F ] and

T = C[G].	 
Finally, we can provide the outline of the proof the main result.
Proof  sketch of Theorem 5.6.	[Deduction implies rewriting] If Φ ▶ F ± G,
we show that |Fˆ| ⇒∗	|Gˆ| by induction on the last rule used for the deduc-
tion. For structural axioms, their effect in deduction can be simulated by repeated
applications of the auxiliary rules of Example 5.3. The reflexivity and transitiv- ity rules are handled in the obvious way. For substitutivity and congruence, we exploit the last lemma. If Φ ▶ G1 ± H1 and Φ ▶ G2 ± H2, by induction hy-

pothesis we have |Gˆ1| ⇒∗
|Hˆ1| and |Gˆ2| ⇒∗
|Hˆ2|. From this it follows that

|G1| ⇒∗
|H1|. Consider now the context C = G1; [j, i], where (j, i) is the rank

of G2. By Lemma 7.4, and by induction on the length of |Gˆ2| ⇒∗	|Hˆ2|, we
obtain that |C[ˆG2]| ⇒R(Φ) |C[ˆH2]|, thus |G1ˆ; G2| ⇒R(Φ) |G1ˆ; H2|. Acting symmet-
rically with context [k, j]; H2, where (k, j) is the rank of G1, one obtains the desired
rewriting sequence. Similarly for ⊕.
[Rewriting implies deduction] One first shows that a single rewriting step corresponds to a deduction. This is trivial for steps corresponding to the rules of R(Φ). For a general rewriting, by Lemma 7.4 this is equivalent to putting the rule in a term graph context. The proof then goes by induction on the syntactical structure of the context, observing that term graphs used as constants correspond to the reflexivity rule, while operations ⊕ and ; correspond to the application of the congruence and substitutivity rules. Next, rewriting sequences consisting of more

than one step correspond to the application of the transitivity rule.	 
