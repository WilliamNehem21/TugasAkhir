

Electronic Notes in Theoretical Computer Science 249 (2009) 3–18
www.elsevier.com/locate/entcs
Continuous Functions on Final Coalgebras
Neil Ghani1 Peter Hancock2
Department of Computer and Information Sciences, University of Strathclyde,
Glasgow, UK
Dirk Pattinson3
Department of Computer Science, Imperial College,
London, UK

Abstract
In a previous paper we gave a representation of, and simultaneously a way of programming with, continuous functions on streams, whether discrete-valued functions, or functions between streams. We also defined a combinator on the representations of such continuous functions that reflects composition. Streams are one of the simplest examples of non-trivial final coalgebras. Here we extend our previous results to cover the case of final coalgebras for a broader class of functors than that giving rise to streams. Among the functors we can deal with are those that arise from countable signatures of finite-place untyped operators. These have many applications. The topology we put on the final coalgebra for such a functor is that induced by taking for basic neighbourhoods the set of infinite objects which share a common ‘prefix’, a la Baire space. The datatype of prefixes is defined together with the set of ‘growth points’ in a prefix, simultaneously. This we call beheading. To program and reason about representations of continuous functions requires a language whose type system incorporates the dependent function and pair types, inductive definitions at types Set,
I → Set and (Σ I : Set) SetI , coinductive definitions at types Set and I → Set, as well as universal arrows for such definitions.
Keywords: Continuous functions, final coalgebras, containers


Introduction
Eating Streams: A stream of elements of a set A is a simple example of an “infinite object”. An infinite object is an inhabitant of a final coalgebra, in this case the coalgebra Aω of the functor X '→A × X or (A×) 4 . The natural notion of map whose domain is an infinite object is that of a continuous function. Informally

1 Email: ng@cis.strath.ac.uk
2 Email: hancock@spamcop.net
3 Email: dirk@doc.ic.ac.uk
4 We make heavy use of section notation for infix operators.

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.081

we can think of continuity as meaning that output is produced after only a finite amount of information about the input is known. This is naturally formalised using topology: if the set A is given the discrete topology, then the product (or ‘Baire’) topology on Aω is generated by the family {N (c)|c : A∗} of basic opens where
N : A∗ → P(Aω)
N (c) =Δ { α ∈ Aω | α(len c) = c } .
where P(X) = X → Set, len c is the length of a list c and α(n) is the truncation of a stream α after n elements. With respect to the Baire topology, a discrete-valued function f : Aω → B is continuous if and only if it is everywhere locally constant meaning that for all α ∈ Aω there exists a finite prefix c ∈ A∗ of α such that the image of f throughout N (c) is the singleton { f (α) }. As is well-known, any such function can be represented by a particular type of wellfounded tree, that is
Δ
an element of the set TA(B) = (μX) B + XA. Such a tree can be interpreted as a
program that consumes, or eats, finitely many values from a stream of A’s, and then
terminates yielding a value of type B. This representation of continuous functions as finite trees directly encodes the intuition that continuous functions require only a finite amount of input to produce their output.
Continuity of functions whose values are themselves streams means, informally, that each element of the output stream is produced after a finite amount of the input. Topologically, continuity means that the inverse image of a value-neighbourhood is a union of argument-neighbourhoods. In a previous paper [11], we defined a repre- sentation of continuous functions between streams as trees, proved completeness in
that every continuous function can be represented by such a tree, and defined an
operation on the representations of two continuous functions between streams that yields a representation of their composite. The trees we used for our representation were non-wellfounded trees pieced together from well-founded trees: formally, we took the set of trees to be PA(B) = (ν X) TA(B×X). Such a tree can be interpreted as a program to read a finite amount of a stream of A’s and then produces a B and another such tree. Again, the intuition that continuity means a function requires only a finite amount of information about the input to produce each successive element of the output is hard-wired into this notion of tree.
Generalisation: The subject of this paper is the extension of our previous work to the representation to functions on final coalgebras for the broad class of endofunctors on the category Set known as containers. This class of functors in-
cludes besides the functor (A×), polynomial functors as X '→1 + 2 × X + X2 or
power-series functors X '→Σ	Cn × Xn for some family of sets C : ω → Set. It
also includes all the strictly positive types and the normal functors of Girard [10]. The final coalgebra of such a functor can be obtained as the projective limit of the ω-sequence 1 ←− F (1) ←− F 2(1) ←− ... starting with a terminal object 1. In that
case, the elements of the final coalgebra behave sufficiently like streams that one can topologise the final coalgebra much as Baire space. We find this streamification of the final coalgebras of containers to be both illuminating and necessary to tame
the complexity of the ensuing mathematical constructions.Containers were intro-

duced in [2], [1] and [3] and, importantly, are closed a plethora of operations, such as constants, +, ×, →, ·, Σ, Π, and least and greatest fixed points. Working with container technology seems to be much cleaner than the alternative of working with power-series functors. With the latter, operators are collected by their cardinality which is, for most purposes, unnecessarily bureaucratic.
Metatheory and Implementation: To write type-checked programs which implement continuous functions on final coalgebras of the kind we are considering
requires, in general, a dependent type system 5 This means that types may be
indexed by data. We also make use of initial algebras and final coalgebras for certain endofunctors on a category of families of sets indexed over a given set. Finally, we make use of a principle known as ‘induction-recursion’, which guarantees an initial algebra for certain endofunctors on a category of families of sets in which the index set is not fixed. For the most part, our definitions and results can be established in a form of Martin-Lo¨f’s type theory, with one universe, with inductive definitions amounting to an indexed version of the W-type.
There are some exceptions: At some points, particularly those concerned with completeness, our results depend on classical logic, and strong forms of the axiom of choice. We regard these passages as partial justification for changing the definition of continuity (in certain cases) to a more intensional one, pivoting on an inductive definition (of covering). In connection with initial algebras and final coalgebras, most of the definitions can be made with only weakly initial algebras. Completeness results about these definitions often require uniqueness of the universal arrow for an initial or final construction. The use we make of induction recursion is extremely weak, and must be in some sense eliminable. What we require is only a principle for forming a universe (a family of sets) closed under a slightly unusual form of Σ-quantifier. It seems likely that the finite ordinals can serve as such a universe.
History: The basic idea for this analysis of continuity emerged from expositions ([7], [16], [12], [13]) of Brouwer’s notion of choice sequence and associated principles of continuity and Bar induction. There are many notions akin to choice sequence (lawless sequence for example), and the connection between streams and choice- sequences is not entirely clear 6 . Yet the principle of Bar induction can clearly be used to model continuous functions on streams, and universal quantification over streams. What we have done is, perhaps, broaden the scope of Bar induction to admit other types of infinite object than streams. It is not surprising that this can be done, as roughly speaking we can analyse these infinite objects into streams of their approximating neighbourhoods. A different extension was made by Spector
[14] to bar-recursion on streams of objects of higher, non-discrete type.
The structure of the paper is as follows: Section 2 contains preliminaries and

5 In some particular cases, such as X '→ A×XB, only polymorphic recursion is needed, such as is available in the programming language Haskell. What is crucial here is that there are no coproducts; with coproducts the number of meals remaining can change in irregular ways as successive slices through an infinite object are consumed.
6 One connection between streams and choice sequences may lie in the idea that (in the angel/demon terminology of the refinement calculus [6]) inputs are chosen by the demon, while the outputs are chosen by the angel. However, choice sequences in intuitionism can involve choices to obtain further terms using a continuous function: this seems to have no explicit counterpart in the refinement calculus.

notation, Section 3 discusses containers, and Section 4 discusses the final coalgebras of containers. Then Section 5 discusses continuous functions with discrete codomain while Section 6 discusses continuous functions whose codomains are final coalgebras. Finally, Section 7 contains our conclusions.

Preliminaries
Initial algebras and final coalgebras: μ and ν: Let (μX) F (X) = μF and (ν X) F (X) = νF denote the initial and final coalgebras for an endofunctor F on an ambient category of sets. In general we use in for the structure map into the carrier of an initial algebra. Thus in : F (μF ) → μF . Given an algebra C, γ : FC → C, let fold (C; γ), or simply fold (γ), be the unique morphism δ : μF → C such that
δ · in = γ · Fδ : F (μF ) → C . 
We use in−1 for fold (F in) : μF → F (μF ), which is the inverse of in.
Ex1 Finite lists A∗ =Δ (μX)1 + A × X.  We use • and (; ) as constructors

associated with ∗, so




Ex2 Wellfounded trees TA


1 	•	 A ∗
A × A∗ 	(;)	 A ∗
in = [•|(; )] : 1 + A × A∗ → A∗
(B) =Δ (μX) B + XA, branching over A and termi-

nating in B. TA(B) is a bifunctor, covariant in B, and contravariant in
A. TA : Set → Set is the free monad over the functor ( )A (alias (A →), known as the reader monad). We write F∗ for the free monad over a functor F , so that TA = (A →)∗. TA is also known as the tree monad. We use Ret and Get for the constructors associated with TA. Thus
B 	Ret	 T (B)
(TA(B))A 	Get	 T (B)
in = [Ret|Get] : B + (TAB)A → TAB
Ex3 A more complex example of an initial algebra is for an endofunctor on the category Fam(Set=) with set-indexed families of sets as objects, and hom-sets consisting of pullback squares. It is provided by the family ⟨Sq : Set,Pq : Sq → Set⟩ defined in section 4. A family of sets defined in this way is said to be defined by induction-recursion. Induction-recursion is described for example in [9] and [8].
Ex4 A different example, generalising TA from the category Set to the category SetSq , is provided by Bar defined in section 4. In this case the initial algebra category is that of sets over an index set Sq, and the endofunctor is an example of an indexed container.
Final coalgebras: In general we use out for the structure map on the carrier of a final coalgebra. Thus out : νF → F (νF ). Given a coalgebra C, γ : C → FC, we

use unfold (C; γ), or simply unfold (γ) (sometimes called coiteration of γ) to denote the unique morphism δ : C → νF such that
out · δ = Fδ · γ : C → F (νF ) .
We use out−1 for unfold (F out ) : F (νF ) → νF , which is the inverse of out . For readability, we sometimes suppress notation for the isomorphisms out and out−1.
Ex1 Streams Aω = (ν X) A × X. We use hd and tl to access components of a stream. out = ⟨hd, tl ⟩ : Aω → A × Aω, while out−1⟨a, α⟩ = a; α.

Ex2 Stream processors PA
(B) =Δ (ν X) T
(B × X) is a bifunctor, covariant in

B, and contravariant in A.
Ex3 A more complex example, is provided by the function Live in section 6.
In this case the category is that of sets over an index set Sq.
Terminal sequences and topology: To construct a weakly final coalgebra νF for an endofunctor F on a category with a terminal object 1, one commonly takes the limit of a certain inverse ω-chain

1 ¸, !	 F 1 ¸, F !	 F 21 ¸,F 2!
··· 

The limit exists in a category such as Set: take the object part of the limit to be

the set of α ∈ 

n∈ω
Fn(1) that satisfy the equations αn = Fn(!)(αn+1), and take

the cone of projections to be { α '→αm | m : ω }.
For well behaved functors the limit of this chain will be a final coalgebra for
F . In such a case, there is a natural topology on νF . This is in fact the topology induced by the rational-valued ultrametric distance or apartness |α − β| = 1/2n where n is least such that αn /= βn. Define α ∼0 β to be vacuously true, and α ∼n+1 β to mean that α and β lie within 1/2n of each other. Such a sequence of shrinking equivalence relations is a separating family in the sense of [15] if their
intersection coincides with equality.


Containers: (S  P )
What are Containers? Containers are representations of certain endo-functors on a category. A (unary) container is given by a set S whose elements are conventionally called ‘shapes’, and a family of sets P : S → Set, giving the possible ‘positions’ p : P (s) within each shape s : S at which data may be accessed or stored. As an alternative to the talk of shapes and positions, one may also think of s ∈ S as symbols for (untyped) multi-place operators, with each of which is associated a set of argument places. The data S, P represents an endofunctor (S  P ) as follows.

( ) : (Π S : Set) (S → Set) → (Set → Set) (S  P )X =Δ (Σ s : S) P (s) → X

Some examples of containers are:

Here Fin(s) is the set of predecessors {0 ··· (s − 1)} ⊆ ω of a natural number
s ∈ ω. Container morphisms represent natural transformations between container
functors.	To be precise, the category Cont =Δ  Fam(Setop) of containers and
container morphisms is fully and faithfully embedded in the functor category SetSet
by the mapping S, P '→(S P ). The category Cont has a rich algebraic structure [3], [1]. It has 0 and +, 1 and ×, ·, Σf , Πf , Δf , μ and ν, not to mention some linear logic connectives and connections with the Newton-Leibnitz differential calculus. This is the basis for a powerful theory of datastructures, and polymorphic functions.

Weighted containers: (S  C P ) Notions of power series are of two styles.
In the first Σ XB(a), which is ‘cardinal-free’, we may have several summands a,
'	a	'	Σ	n
a  with the same arity B(a) = B(a ).  In the second	n C(n) × X , which is
‘bureaucratic’, or bean-counting, we collect together the arities by their cardinal number, and put all the information into the coefficient sets C(n). The notion of a weighted container - which we introduce in this paper - is a compromise. The coefficients or weights allow us to track separately information in a shape which does not affect the position sets.
  : (Π S : Set) (PS)2 → (Set → Set)
(S   P )X =Δ (Σ s : S) C(s) × (P (s) → X)
Examples of weighted containers are:

The notion of a weighted container is clearly connected with the notion of a left Kan extension, namely of C along P .

Note that weighted containers support various maps
(S  C P )X → Σ(S, C)	Ignore power of X
(S  C P )X → (S  P )X	Ignore coefficient
(S  C P )X ∼= (Σ(S, C)  ⟨s, ⟩ '→P (s))X Move coefficient to shape

Final coalgebras of containers
We want to capture the idea of finite information about a point in the final coalgebra ν(S P ). We express finite information in trees of bounded depth, where there are special leaf nodes (all at the same distance from the root) where new growth is possible. The trees grow (ie. the neighbourhoods shrink) ‘salami style’. In each step, a layer of new nodes of depth one is grown at formerly leaf positions.

Finite neighbourhoods: (Sq,Pq) We define an operator on families of sets
⟨S, P⟩ (with S : Set and P : S → Set). We write the result of this operation (Sq,Pq). Beware! Sq depends on P as well as S, and the very type of Pq depends on S. 7 The type of our operator is:
Fam(Set) −→ Fam(Set)
where Fam(X) = (Σ S : Set) S → X. An element s of Sq plays the role here that finite sequences play in the stream case, namely it is intended to represent a finite approximation to, or neighbourhood of points, in ν(S P ). The elements of Pq(s) are locations at which the approximation s can be further refined. The operator can be defined in several ways.
One definition is by induction-recursion. In induction recursion, one defines a set inductively, while at the same time defining a (typically set-valued) function on that set, that may be mentioned in the inductive clauses. The solution is an initial algebra for an endofunctor on a category of families. The reason that this is an induction recursive definition of a family of sets, rather then a plain inductive definition, followed by a recursive definition of sets is that the second component of the operand family is used in the definition of the first component of the output family. For an explanation of the principles underlying induction recursion see the papers [9] [8] by Dybjer and Setzer and the references therein. The constructors and their associated decoding functions are as follows:
: Sq
Pq(•) =Δ 1 
(; ) : (Π s : Sq) (Pq(s) → S) → Sq
Pq(s; σ) =Δ (Σ p : Pq(s)) P (σ(p))

7 A more ‘logical’ sotation might be N (S, P ) for the neighbourhoods Sq and L(S, P ) for the locations Pq.

We think that the container of finite neighbourhoods is an interesting example of an inductive-recursive definition that arises ‘in nature’, albeit one that doesn’t exploit the peculiar power of that definitional scheme, eg no ‘negative’ quantifiers or connectives like Π or → are used in defining the values of Pq. Usually, trees are grown by constructing a root for a forest. The inductive-recursive definition allows trees to grow at the leaves. The recursion scheme this induces has a com- putational behaviour which is appropriate in connection with the bar theorem, when typically the ‘business end’ of a formal neighbourhood is the one at which the finer distinctions are made.
One can also define Sq,Pq by using a universe closed under Σ and 1. First define F : ω → Fam(Set) by recursion into our universe. We write F (n) =
⟨Sq(n),Pq(n)⟩. In the base case

Sq(0) = 1,
Pq(0, ) = 1,
F (0) = (1  1) = id .

In the step case

Sq(n + 1) = (Σ s : Sq(n)) Pq(n, s) → S,
Pq(n + 1, ⟨s, σ⟩) = (Σ p : Pq(n, s)) P (σ(p)), F (n + 1) = F (n) · (S  P ) .
Second, set Sq = (Σ n ∈ ω) Sq(n) and Pq⟨n, s⟩ = Pq(n, s).  The endofunctor
Sq  Pq is the coproduct (not colimit of a chain!) (Σ n : ω) (S  P )n.
Of course, unless the position sets are restricted to be finite such a tree may contain more than finite information, and in that case the topology is unrealistic. The question arises of whether we can choose neighbourhoods (and the associated relations of refinement and covering) in some other way to yield a useful topology when the cardinal of the index set can be countable or worse. We think there is room for speculation — the question is more subtle than it appears at first sight.

Meals : ν(S P ) We use the term ‘meal’ for an element of the final coalgebra of a container, and usually use Greek letters for meal variables and names. The foodstuff a meal most resembles is perhaps broccoli, except that unlike normal broccoli, it may have infinitely long stems. Meals are so called because (as we will see) they are ‘eaten’, as it were in mouthfuls, a slice at a time, when the implementation of a continuous function is run on a meal.
M : Set
M = ν(S  P )

The final coalgebra gives us the following destructors:
hd : M → S
tl : (Π α : M ) P (hd (α)) → M
We have out (m) = ⟨hd (m), (λp : P (hd (m))) tl (m, p)⟩.
The elements of Sq are formal neighbourhoods for points in M . We write m |= s to mean that s is a neighbourhood of m. If m |= s, we define m[ ]s : Pq(s) → M . This gives a notion of location ‘inside’ m.
(m |= •) =Δ True
m[ ]• = const (m) : 1 → M
(ie • is the topmost neighbourhood, containing all points in the space).
(m |= s; σ) =Δ (m |= s) ∧ hd · m[ ] = σ : Pq(s) → S
m[ ]  =Δ ⟨p, p'⟩ '→tl (m[p] , p') : Pq(s; σ) → M
(ie for any p : Pq(s), the symbol/shape in m at location p is σ(p)).
We can define a reflexive and transitive relation (±) of inclusion between neigh- bourhoods, without quantification over M , so that s ± s' ⇐⇒ (Π α : M ) α |= s → α |= s'. This relation holds when s is a prefix of s', or s' is a refinement of s.

Representation of continuous functions with discrete co-domain
We begin by defining an inductive family of sets Bar (B) : Sq → Set, parametrised by a given family of sets B : Sq → Set. If one regards the set valued functions as predicates, the operation Bar can be recognised as a familiar closure operation that, as it were, fills in any concavity present in the predicate B (the convex closure). The very paradigm of this operation is present in Brouwer’s principle of bar-induction, which explains our choice of its name. The operation can also be recognised as a form of the construction of a free monad over a functor, in this case a functor intrinsic to the topology of a final coalgebra.
Bar : PSq → PSq

Bar (B) =Δ
(μX : PSq) (λs : Sq)
B(s)+ (Π σ : Pq(s) → S) X(s; σ)

If B : PSq and s : Sq, then an element of Bar (B, s) is a program that implements (via the function eat below) a continuous function from the product space MP q (s) to the discrete space (Σ s ∈ Sq) B(s). The point is that we have to define the entire family of representation functions simultaneously. Crucially, it is the use of the dependent function space that makes this possible.
Just as TA  is the free monad over the functor A, Bar is the free monad Bar∗
over the following endofunctor Bar 1 on the category of families of sets indexed over

Sq.
Bar 1 : PSq → PSq
Bar 1(B, s) = (Π σ : Pq(s) → S) B(s; σ) .
If we regard Sq as a category with edges between s and s; σ for σ : Pq(s) → S, then we can shed more light (categorically) on Bar 1B. It is simply 1 → B where the exponential is of objects in the category Sq → Set and thus Bar is simply (1 →)∗ since Bar is just
(μX : PSq) B + Bar 1(X) .
where the coproduct is again in Sq → Set and is thus taken pointwise. As a predi- cate, Bar 1(B) says of s that B holds in one refinement step, while Bar (B, s) 8 says of s that it is barred by B, meaning that B will inevitably hold sooner or later in any sufficiently prolonged sequence of successive refinements. One says that any m with m |= s inevitably ‘enters the bar’ 9 , ie there is a refinement s' ± s such that B(s') and m |= s'.
Now fix a family of discrete sets B : PSq.
eat : (Sq  Bar (B) Pq)(M ) → (Sq  B Pq)(M )
eat ⟨s, Ret(b), m⟩ = ⟨s, b, m⟩
eat ⟨s, Get(φ), m⟩ = eat ⟨s; σ, φ(σ), m'⟩
where σ : Pq(s) → S
σ(p) = hd (m(p))

m' : Pq(s; σ) → M
m'⟨p, p'⟩ =Δ tl (m(p), p')
The definition of eat can be justified in various ways. One is by the principle of structural recursion corresponding to the inductive definition of Bar . In fact this is bar-recursion [14]. Another exploits the freeness of the monad Bar = Bar∗ on PSq. To use the latter, we define a natural transformation from the functor Bar 1 to the functor
R : PSq → PSq
R(B, s) =Δ  MP q (s) → (Sq   Pq)(M )
The latter is the underlying functor of a monad. This monad can be seen as a generalisation in some sense of the simply-typed state monad B '→Q → (B × Q) where the state Q is { MP qs | s : Sq }.

8 In Sambin’s notation for formal topology one would write this set in the iconic form s Q B. Unfortunately, with container notation we already use the symbol Q infix at type (S : Set) → PS → Set → Set for the container extension operation.
9 No doubt to partake of an alcoholic refreshment. A monotone bar is one that you cannot leave.

It is convenient to introduce a notion of ‘untidy’ eating, that simply throws away the residue, or lets it fall to the floor. When a machine has run into its final state, we are interested only in the result.
eat † : (Π s : Sq) Bar (B, s) → MP q (s) → (Σ s : Sq) B(s)
eat † = (⟨s, b, ⟩ '→s,⟨b⟩) · eat
Definition 5.1 If s : Sq, and φ : MP q (s) → (Σ s : Sq) B(s) is extensionally equal to eat †(s, t) for some t : Bar (B, s), then t is said to represent φ at s, or to be a representative of it. The representation is the function eat †.
Theorem 5.2 (Completeness of representation for discrete codomain) Given s : Sq, and a function φ : MP q (s) → (Σ s : Sq) B(s) with no representative t : Bar (B, s) at s, we can ‘construct’ (ie. prove the classical existence of) α : M such that α |= s and φ is not continuous at α[ ]s.

Representatives of continuous functions with general codomain.
We consider now the problem of finding data-structures that can represent (using a suitable interpreter) functions between final coalgebras of containers. However the task is more complicated than it at first appears. Let ⟨S, P⟩ and ⟨Q, R⟩ be a pair of containers. In order to represent functions of type
ν(S  P ) −→ ν(Q  R)
we need to devise a representation for an entire doubly indexed family of such functions, namely
(Pq(s) → ν(S  P )) −→ (Rq(q) → ν(Q  R))
where s : Sq and q : Qq. The reason is that we want our representation to be compositional. As our representation ‘munches’ its way through an infinite object in ν(S P ), it is faced at successive stages with an indexed family of subobjects, having a type of the form
Pq(s) → ν(S  P )
where s : Sq is the prefix of the infinite object that has been eaten so far. Con- sider now the output side of our program, and imagine now that there is another such program, ‘upstream’, expecting output of successive ‘slices’ through an infinite object in ν(Q  R). Our representation has to produce successive slices of this kind.
The interpreter eat ∞ we need to define will have type
(Π q : Qq,s : Sq) Pos qs → (Pq s → ν(S  P )) → (Rq q → ν(Q  R))
where Pos is a doubly indexed family of sets, that we have yet to define, whose type is
Pos : Qq → Sq → Set .

Here is an isomorphic variant of the type our interpreter will inhabit [(Σ q : Qq) (Sq  Pos q Pq)(ν(S  P )) × Rq q] → ν(Q  R)
Since this type is a function space with a codomain which is a final coalgebra ν(Q  R), we will define it using the universal property of final coalgebras. So we set


and define
C : Set =Δ (Σ q : Qq) (Sq	Pq)(ν(S  P )) × Rq q

eat ∞ : C → ν(Q  R)
eat	=Δ unfold (γ)

where the coalgebra γ : C → (Q  R)C is yet to be defined.
It is time to define our family of programs.
Definition 6.1 Define Pos : Qq → Sq → Set as the following final coalgebra
Pos =Δ (νW : Qq → Sq → Set) { q : Qq | Bar{ s' : Sq | (Σ τ : Rq q → Q) W (q; τ ) s' }} 
This definition has been devised to yield the fixed point isomorphism (for q : Qq, at type Sq → Set):
Pos q ∼=  Bar{ s' : Sq | (Σ τ : Rq q → Q) Pos (q; τ ) s' }
The direction of this isomorphism we shall need is the function
out : (Π q : Qq,s : Sq) Pos(q, s) → Bar ({ s' : Sq | (Σ τ : Rq(q) → Q) Pos(q; τ, s') }, s)
Note that on account of this isomorphism discrete eating (section 5) gives us a function inhabiting
(Sq  Pos q Pq)(ν(S  P )) −→ (Sq	q	q	Pq)(ν(S  P ))
What remains now is to define our coalgebra γ : C → (Q  R)C. The idea is perhaps best conveyed first with a diagram.
C =Δ (Σ q : Qq) (Sq	Pq)(ν(S  P )) × Rq q
eat
J 
(Σ q : Qq) (Sq  { s:Sq | (Σ r :Rq q→Q) Pos (q;r ) s } Pq)(ν(S  P )) × Rq q
⟨q, s, τ, p, f, r⟩ '→
J⟨τ  r, (λr') ⟨q; τ, s, p, f, ⟨r, r'⟩⟩⟩
(Σ q : Q) Rq → (Σ q' : Qq) (Sq  Pos q' Pq)(ν(S  P )) × Rq q'
Δ
=
J 
(Q  R)C
The definition can be written more formally as follows.
γ : C → (Q  R)C γ⟨q, ⟨s, p, f⟩, r⟩
=Δ ⟨τ (r), (λr' : R(τ (r))) ⟨q; τ, eat ⟨s, out (q, s, p),f⟩, ⟨r, r'⟩⟩

Thus we have the coalgebra we want and hence the representation of continuous functions between final coalgebras.
We have not proved that this representation is complete, but conjecture that this can be accomplished along the lines of the proof of the simpler completeness result in section 3.3 of our earlier paper on stream processors.


Composition
In the previous section, we defined a doubly indexed family of datatypes
{ Pos qs | q : Qq,s : Sq }
to represent functions in the doubly indexed family of function types
{ (Pq s → ν(S  P )) → (Rq q → ν(Q  R)) | q : Qq,s : Sq }
together with a function eat ∞ that interprets a datastructure as a function of the appropriate type. Our representations should consume successively deeper ‘slices’ of type Pq s → S through an infinite object of type ν(S P ) presented to it as input, and produce successively deeper such slices of type Rq q → Q through an infinite object of type ν(Q R), generated by it as output. The form of the representation was motivated by the goal that our representation should be compositional: it should be possible to arrange two such representations of appropriate type in series so as to represent the composition of the represented functions.
In this section, we define an operation (‘⊗’) directly on our datastructures that represents the composition of the functions they represent. Suppose we have three container functors (Q R), (S P ) and (U T ), giving the types ν(Q R) of our ultimate output object, ν(S P ) of an intermediate object, and ν(U T ) of our original input object respectively. The type of the operation is as follows.
⊗ : (Π q : Qq,s : Sq,u : Uq) Pos qs → Pos su → Pos qu 
To alleviate notation, we leave the first three arguments of ⊗ implicit, and write it as an infix operator between its final two arguments. We aim that
eat ∞(post ⊗q,s,u pre) = eat ∞post · eat ∞pre
where q : Qq, s : Sq, u : Uq, post : Pos qs and pre : Pos s u. Although the underlying idea is quite simple, the details of the definition are necessarily rather technical, so we merely sketch how the function is defined. Since the codomain of the operation
⊗ is a final coalgebra of a certain functor on doubly indexed families, we define the operation using an unfold . The functor at issue is that which takes a doubly indexed family U : Qq → Uq → Set to
{ (Σ f : Rqq → Q) U (q; f ) s | q : Qq,u : Uq }
, and so we seek a coalgebra
γ : (Π q : Qq,u : Uq) Cq u → (Σ f : Rqq → Q) C(q; f ) s

for this functor. Experience with the corresponding operator on stream functions suggests that we take the define the carrier C of our coalgebra as follows.
C : Qq → Uq → Set

Cq u =Δ
(Σ s : Sq) Bar{ s' : Sq | (Σ g : Rq q → Q) Pos(q; g)s' } s×
Bar{ u' : Uq | (Σ h : Pq s → S) Pos(s; h)u' } u

When the coalgebra γ has been defined, we can then define ⊗ as follows
post ⊗ pre =Δ (unfoldγ)⟨out post, out pre⟩ .
It should be emphasised that we do not suggest that this is the only way to define our composition operator. Indeed, there are other methods, some of which are quite elegant, though not entirely straightforward to describe.
It remains to define the coalgebra γ. Since the domain of this function has as its principal feature two occurrences of the family transformer Bar , we define it using fold , which is to say bar-recursion.  The form of the definition is with
an outer recursion on the postponent, and an inner recursion on the preponent. Precise definitions are given in the accompanying type code - here we describe in operational terms what this amounts to. We evaluate the postponent to weak head normal form, which will be either Ret, or Get. In the former case (the base of the outer recursion), the arguments of the constructor have type (Σ g : Rq q → Q) Pos(q; g)s' for some s' : Sq. In that case, we form an element of γ’s codomain by emitting the ‘slice’ g : Rq q → Q, and forming the new state by applying out to the body of the Σ (so as to get an element of the postponent’s type, and pairing this value with the preponent. In the latter case, when the postponent has form Get, we turn our attention to the preponent, and evaluate it to weak head normal form. Should the preponent have the form Ret, with an argument of type (Σ h : Pq s → S) Pos(s; h)u' for some u' : Uq, we feed the ‘slice’ h to the argument of the postponents Get (this ‘going down’ in the outermost recursion), thus making an internal communication from preponent to postponent, and proceed with what remains. Should the preponent on the other hand have the form Get, then both postponent and preponent are reading and the value of γ also has Get form.
It should be noted that the operator we have defined is lazy, in that if the postponent is ready to output a ‘slice’ of ν(Q  R), so is the component, whether or not the preponent is ready to input a slice of ν(S  P ). Another variant can be defined which is greedy, in that as long as the preponent is ready to read, the composite will read, whether or not the postponent is prepared to write. The definition is however still a nested recursion of the same general form: an outer recursion on the postponent, with inner recursion on the preponent.
In fact, the definitions at which we arrived are merely an elaboration of the cor- responding definitions in section 4.1 of our previous paper on stream processors [11]. A formal definition, type checked in a version of Agda can be found at the following url: http://www.cis.strath.ac.uk/∼ng/cont-eat.agda. We have not actually carried out a formal proof of the equation above expressing the correctness of the operator ⊗, but we expect that this can be done along the lines of section 4.2 of

our paper on stream processors, albeit with heavier technical machinery.

Conclusion
We have defined a system of representatives for functions on final coalgebras of functors expressible as containers. When those functors are finitary, their final coalgebras support a simple topology. The notion of continuity then makes sense for functions on such arguments. We proved that our representatives implement exactly the continuous functions in the discrete valued case, and conjecture it in the case that the values are in final coalgebras for finitary container. We have also defined a combinator on representatives that represents composition of the represented functions. This involved a careful analysis of the types involved. We used types indexed over neighbourhoods for the final coalgebra of the container. The mathematical techniques involve working with indexed families of sets, to represent functors F via containers, and to represent neighbourhoods of νF using in particular a weak form of inductive-recursion to define such families. We also used mixed inductive and coinductive types in our work.
As with streams, our representations are not unique. There are many different representations of even the identity function. Indeed, representations of the iden- tity function are among the most interesting, as they correspond to non-reordering sequential channels, buffering, or wires. One might say that a representation de- notes the extensional identity function, but expresses a buffering policy. It seems probable that one can define a equivalence relation directly between representations to coincide exactly with extensional equality of functions on streams.
Final coalgebras of indexed containers impose a form of sort-constraint on infi- nite terms (in which the indices are type identifiers). Our definition of composition has the smell of cut-elimination, except that no sort-structure is present. With a sort-structure, the source of this aroma can be investigated. There may be connec- tions here with continuous cut-elimination and continuous normalisation and the repetition rule of Mints: see also [5].
It is striking that we now have an analysis of continuous functions on spaces of the form F∞B = (ν X) B × F (X), ie cofree comonad over F . These spaces, and
other such as (ν X) F (B×X) can be useful for modelling the states of hierarchically accessed stores such as file-systems or sequentially accessed stores such as the tape of a Turing machine. Equipped with a cursor (a ‘one-hole context’ [4]) that navigates up and down the tree, one has an updatable store, that can be used for shared- memory communication. A storage device is a particularly well-behaved kind of state-machine, and indeed a state machine can be identified with an infinite object
of a type such as (ν X) S × (P → X) = (P →)∞S (in the case of a Moore machine
with output S and input P ). An alternative is (ν X) PS × XS = (S →)∞(S → P ) for a Mealy machine with input S and output P . Another kind of infinite object that we can now model is (ν X) A + X, which has the connotation: maybe I’ll give you a A, maybe I won’t. When combined with a suitable account of ‘hiding’ delay, this may useful for modelling partial functions that may ‘fail’ to produce

output. Finally, it is possible that one can formulate higher order eating to analyse continuity at higher types.

References
Michael Abbott, Thorsten Altenkirch, and Neil Ghani. Categories of containers. In Proceedings of Foundations of Software Science and Computation Structures, 2003.
Michael Abbott, Thorsten Altenkirch, and Neil Ghani. Representing nested inductive types using W- types. In Automata, Languages and Programming, 31st International Colloqium (ICALP), pages 59 – 71, 2004.
Michael Abbott, Thorsten Altenkirch, and Neil Ghani. Containers - constructing strictly positive types.
Theoretical Computer Science, 342:3–27, September 2005. Applied Semantics: Selected Topics.
Michael Abbott, Thorsten Altenkirch, Conor McBride, and Neil Ghani. ∂ for data: Differentiating data structures. Fundamenta Informaticae, 65(1-2):1–28, 2004.
Klaus Aehlig and Felix Joachimski. On continuous normalization. In CSL ’02: Proceedings of the 16th International Workshop and 11th Annual Conference of the EACSL on Computer Science Logic, pages 59–73, London, UK, 2002. Springer-Verlag.
Ralph-Johan Back and Joakim von Wright. Refinement calculus, A systematic introduction. Graduate Texts in Computer Science. Springer-Verlag, New York, 1998.
M. Dummett. Elements of intuitionism. Clarendon Press, Oxford, 2000. 2nd edition.
Peter Dybjer and Anton Setzer. Induction-recursion and initial algebras. Annals of Pure and Applied Logic, 124:1 – 47, 2003.
Peter Dybjer and Anton Setzer. Indexed induction-recursion. Journal of Logic and Algebraic Programming, 66:1 – 49, 2006.
J-Y. Girard. Normal functors, power series and lambda-calculus. Ann. Pure Appl. Logic, 37(2):129–177, 1988.
Peter Hancock, Neil Ghani, and Dirk Pattinson. Representations of stream processors using nested fixed points. Logical Methods in Computer Science, 2009 (to appear).
G. Kreisel and A.S. Troelstra. Formal systems for some branches of intuitionistic analysis. Annals of Pure and Applied Logic, 1:229–387, 1970. Addendum in APAL 3, pp. 437–439.
Per Martin-L¨of. Notes on Constructive Mathematics. Almquist and Wiksell, Stockholm, 1965.
Clifford Spector. Provably recursive functionals of analysis: a consistency proof of analysis by an extension of principles in current intuitionistic mathematics. In F. D. E. Dekker, editor, Proc. Symposia in Pure Mathematics: Recursive Function Theory, volume 5, pages 1–27. American Mathematical Society, 1962.
Viggo Stoltenberg-Hansen, Ingrid Lindstr¨om, and Edward R. Griffor. Mathematical theory of domains. Cambridge University Press, New York, NY, USA, 1994.
A.S. Troelstra and D. van Dalen. Constructivism in Mathematics. North-Holland, 1988. 2 volumes.
