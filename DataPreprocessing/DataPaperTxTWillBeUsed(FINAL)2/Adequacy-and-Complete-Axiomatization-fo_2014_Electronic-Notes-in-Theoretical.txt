Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 308 (2014) 183–210
www.elsevier.com/locate/entcs

Adequacy and Complete Axiomatization for Timed Modal Logic
Samy Jaziri1	Kim G. Larsen2	Radu Mardare2	Bingtian Xue2

1Lab. Sp´ecification & V´erification, ENS Cachan, France	2Aalborg University, Denmark

Abstract
In this paper we develop the metatheory for Timed Modal Logic (TML), which is the modal logic used for the analysis of timed transition systems (TTSs). We solve a series of long-standing open problems related to TML. Firstly, we prove that TML enjoys the Hennessy-Milner property and solve one of the open questions in the field. Secondly, we prove that the set of validities are not recursively enumerable. Nevertheless,
we develop a strongly-complete proof system for TML. Since the logic is not compact, the proof system contains infinitary rules, but only with countable sets of instances. Thus, we can involve topological results regarding Stone spaces, such as the Rasiowa-Sikorski lemma, to complete the proofs.
Keywords: Non-compact modal logics, complete axiomatization, timed modal logic.

Introduction
In the areas of embedded and cyber-physical systems, more than two decades of research have been dedicated to developing quantitative modeling and specification formalisms that allow for the construction of systems with guaranteed functional and non-functional properties. In particular, many embedded systems are highly safety critical, with hard constraints on real-time behaviors being essential. Here, the notion of timed transition system and timed automata [4] have proven extremely convenient for modeling purposes and are now routinely used for the analysis of real- time communication protocols and control programs.
Accompanying the timed transition systems, a variety of timed temporal logics have been introduced as convenient ways of capturing requirements to real-time systems. These logics include MTL [14], MITL [5], TPTL [7, 8] and ECL [22] all providing timed extensions of LTL. Similarly TCTL [2], Tμ [13] and Lν [17] provide timed extensions of CTL and the modal μ-calculus. Emphasis has been on detailed inves- tigation of decidability and complexity of model checking and satisfiability checking,

http://dx.doi.org/10.1016/j.entcs.2014.10.011
1571-0661/© 2014 Elsevier B.V. All rights reserved.

identifying the importance of (absence of) punctual constraints in the logic [5, 16] as well as of the choice of semantics of timed automata (point-wise or continu- ous) [18–20]. Also, with the purpose of gaining decidability, satisfiability checking given constraints on number of clocks and size of constants in a satisfying timed automata has been considered [17]. In all of the aforementioned logics, quantitative requirements are either obtained by decorating modalities with timing constraints, or by using clocks in formulas.
The presence of time in all these settings makes it difficult to address fundamental meta-theoretical questions regarding the timed logics, such as adequacy 1 or the development of complete proof systems. Regarding the axiomatization, there exists a series of results proved in very restricted settings, such as for TPTL [12] that only looks to models with discrete time, or for ECTL [23] under the restriction of models with finite variability – only finitely many state changes can occur in a finite amount of time. Other attempts, such as [9], failed already in achieving soundness results, as argued in [23].
In this paper we take the challenge of developing a strongly-complete proof system for the most basic Timed Modal Logic (TML) defined for the most general model of real-time systems, without any restriction on the nature of time. Our models are timed labelled transition systems (TTSs), which generalize timed automata [1]: their transitions are labeled with actions or time delays (real numbers). Our logic is the non-recursive fragment of Lν [17], which generalizes the logic of [1]. In these settings we solve a series of open problems.
Firstly, we prove that TML is adequate not only for timed automata, but in general, for entire class of TTSs. This settles an open problem and disproves a belief often found in the literature, e.g., [1] – that such a logic is not sufficiently expressive to characterize timed-bisimulation. In proving this result, we use a novel exploitation of formulas with free clock variables.
Secondly, we prove that the satisfiability problem for TML is undecidable despite its restrictive expressive power, thus generalizing the known undecidability result of satisfiability for TCTL [2]. Moreover, we show that the set of TML-validities is not recursively-enumerable. This implicitly means that any complete proof system will generate a non-recursively enumerable set of provable formulas, and makes one wonder whether this logic can, in fact, be axiomatized at all - see e.g., the discussion in [6].
We prove that TML can be axiomatized and we develop a proof system for it that is strongly-complete 2 for the TTS-semantics. However, TML is not compact : there exists an infinite set of formulas that admits no model while all its finite subsets have models. For this reason our axiomatization must contains infinitary proof rules; they reflect Archimedean properties of the rational numbers used to interpret

1 A logic is adequate when its semantical equivalence over the class of models coincides with bisimilarity.
2 Strong completeness means that [Φ ▶ φ iff Φ |= φ], where Φ |= φ denotes that all the models of the set Φ of formulas are also models of the formula φ; and Φ ▶ φ denotes that φ is provable from Φ.

clocks. Due to these infinitary rules, the proofs of our system cannot be enumerated. Nevertheless, these rules have countable sets of instances.
Our axioms provide a set of sufficient conditions that characterizes the concept of time in models like TTSs and timed automata. They reflect properties such as persistence, continuity, linearity, density of time, synchronization, or the fact that all clocks measure the same time flow. Most of these axioms are similar to axioms seen in other modal logics and these relations open interesting further questions.
An other important contribution of the paper is the construction of the canoni- cal model, which generalizes for the case of a (non-compact) higher-order modal logic the classic filtration construction usually used for propositional modal logics. This follows the line opened by the second and the third author in collaboration with Panangaden and Kozen in [15]; it involves complex topological and model- theoretical arguments, such as the Rasiowa-Sikorski lemma, which are essential in achieving the main results and are pointing to a general methodology for construct- ing canonical models for non-compact modal logics.
This paper does not aim at addressing problems related to timed automata, nor to model verification, model construction or model checking. Our purpose is to clarify the open problems of model theory for TML. The interesting questions regarding timed automata-semantics will be addressed in a future work.

Preliminaries
Hereafter we fix the notation used in the paper.
Kleene equality. Given a partial function f : X → Y , we write f (x) =~ f (xj) for x, xj ∈ X to denote the fact that f (x) and f (xj) are simultaneously well-defined and whenever they are well-defined, they are equal.
Orders on reals. We use Ð and Ḏ to range over the set {≤, ≥} such that {Ð, Ḏ} =
{≤, ≥}; this means that Ð can either be interpreted as ≤ or as ≥; if Ð represents one of the two, then Ḏ denotes the other. Similarly, we use  and D to range over the set {<, >} such that { , D} = {<, >}. Moreover, x  y means [x Ð y and x /= y], and similarly for D and Ḏ. We use da to denote to an arbitrary element of the set {≤, ≥, <, >}.
Interpretations on reals. Given a set K, an interpretation of K (on non-negative reals) is a function i : K → R≥0; if x ∈ K and r ∈ R≥0, we denote by i[x '→ r] the interpretation j of K such that j(x)= r and j(y)= i(y) for y /= x. The arithmetic operations on interpretations are defined pointwise; 0 is used for the constant null interpretation and [x '→ r] denotes 0[x '→ r].
The Rasiowa-Sikorski Lemma [11, 21] is a result with important applications in logic.

Definition 2.1 Let B be a Boolean algebra and let T ⊆ B such that T has a greatest lower bound  T in B. An ultrafilter (maximal filter) U is said to respect
T if T ⊆ U implies that V T ∈ U .
If T is a family of subsets of B, we say that an ultrafilter U respects T if it respects every member of T .
Lemma 2.2 (Rasiowa–Sikorski [21]) For any Boolean algebra B and any count- able family T of subsets of B, each member of which has a meet in B, and for any nonzero x ∈ B, there exists an ultraﬁlter in B that contains x and respects T .

Timed Transition Systems
A timed transition system (TTS) [1] is a labeled transition system that uses both actions and time delays as transition labels. The delay transitions describe the time flow and consequently are continuous and deterministic. Here we propose an equivalent definition for TTS that encodes the time in an algebraic format and simplifies our future developments.
Definition 3.1 [Timed Transition System] A timed labeled transition system (TTS) is a tuple W = (M, Σ, θ, ⊕) where M is a non-empty set of states, Σ a non-empty set of actions, θ : M × Σ → 2M is the action-labelling function and ⊕ : R≥0 × M - M is a partial function that encodes the delay transitions; for arbitrary m ∈ M and d, dj ∈ R≥0,
0 ⊕ m = m;
d ⊕ (dj ⊕ m) =~ (d + dj) ⊕ m.
Whenever it is defined, d ⊕ m denotes a time delay d applied to the state m. Condition 1 guarantees that a zero-delay is always well-defined and it does not change the state of the system; and condition 2 expresses that time is both additive
and deterministic. As usual, instead of mj ∈ θ(m, a) we will write m −→a  mj.
In the rest of this paper we fix the set Σ and omit it in the description of TTSs.
A timed bisimulation is a relation that equates states of a TTS with identical be- haviours.
Definition 3.2 [Timed Bisimulation] Given a TTS W = (M, θ, ⊕), a timed bisim- ulation is an equivalence relation R ⊆ M × M such that whenever (m, n) ∈ R, for all a ∈ Σ and d ∈ R≥0,
if m −→a  mj, then there exists nj ∈ M s.t. n −→a  nj and (mj, nj) ∈ R;
if d ⊕ m is well-defined, then d ⊕ n is well-defined and (d ⊕ m, d ⊕ n) ∈ R.
As for the other types of bisimulation, the previous definition can be extended to define the time bisimulation between distinct TTSs by considering bisimulation relations on their disjoint union. Time bisimilarity is the largest time-bisimulation

relation; if Wi = (Mi, θi, ⊕i), mi ∈ Mi for i = 1, 2 and m1 and m2 are bisimilar, we write (m1, W1) ∼ (m2, W2).


Timed Modal Logic

In this section we introduce the Timed Modal Logic (TML) that encodes properties of TTSs. It is defined for a countable set K of clocks that we consider fixed in what follows. It contains Henessy-Milner operators [a]φ for the actions a ∈ Σ, where Σ is the fixed set of actions for which we have defined TTSs in the previous section. In addition, it is endowed with time inequalities of type x Ð r for rational values r that evaluate the clock x ∈ K at the current state; with delay quantiﬁers ∀ φ that predicate properties for any time-delay of the current state; and clock quantiﬁers
∀x.φ that predicate properties for any interpretation of the clock x at the current state.
Definition 4.1 [Syntax] For arbitrary r ∈ Q≥0 and a ∈ Σ,
L :	φ := ⊥ | x Ð r | φ → φ | [a]φ | ∀ φ | ∀x.φ.


Let  (K) be the set of interpretations of K. The semantics of TML is defined for an arbitrary TTS M = (M, θ, ⊕), m ∈ M and i ∈  (K) as follows.
M, m, i |= ⊥ – never;
M, m, i |= x Ð r if i(x) Ð r;
M, m, i |= φ → ψ if M, m, i |= ψ whenever M, m, i |= φ;
M, m, i |= [a]φ if [for any mj ∈ M s.t. m −→a  mj, M, mj,i |= φ];
M, m, i |= ∀ φ if [for any d ∈ R≥0 s.t. d ⊕ m is well-defined, M, d ⊕ m, i + d |= φ];
M, m, i |= ∀x.φ if [for any t ∈ R≥0,M, m, i[x '→ t] |= φ].
We also use, in addition, all the boolean operators defined as usual and the De
df	df	df
Morgan duals of the modal operators: ⟨a⟩φ = ¬[a]¬φ, x D r = ¬(x Œ r), ∃ φ =
df
¬( ∀∀ ¬φ), and ∃x.φ = ¬(∀x.¬φ). Other derived operators used in what follows are:
df	df
(x = r) = (x ≤ r) ∧ (x ≥ r) and ∀(x da r).φ = ∀x.(x da r → φ), da∈ {≤, ≥, <, >}.
In TML we can express the reset operator used in [1, 13, 17] by
df
x in φ = ∀x.(x =0 → φ).
Whenever it is not the case that M, m, i |= φ, we write M, m, i |= φ. We say that a formula φ is satisﬁable if there exists at least one TTS that satisfies it in one of its states under at least one interpretation; φ is a validity if it is satisfied in all states of any TTS under any interpretation - in this case we write |= φ. For an arbitrary set Φ ⊆ L, we write Φ |= φ if all the models of all the formulas in Φ are also models of φ.

4.1	Undecidability of TML.
Individual formulae of TML express properties which only depend on the behaviour of a TTS up to a finite action-depth, thus making TML significantly less expressive than TCTL [3]. In a number of papers it has been shown how recursive extensions of TML – e.g. extensions with the ability to define logical properties recursively – enable the encoding of TCTL, while maintaining decidability of model-checking.
As stated in the theorem below, despite its limited expressive power the question of satisfiability for TML is (highly) undecidable, as is the case of TCTL. Formally, given an arbitrary TML formula φ ∈ L, it is undecidable whether there exists a TTS (M, θ, ⊕) with m ∈ M and interpretation i ∈  (K) such that M, m, i |= φ.
Theorem 4.2 (Undecidability of TML) The satisﬁability question for TML is
Σ1-hard, hence undecidable.
Proof. We show that we can reduce the TML satisfiability question into the ques- tion as to whether a non-deterministic 2-counter machines has a computation with the initial location being visited infinitely often. This last question is known to be Σ1-hard. Our proof is similar to the one in [3] and for this reason it is presented in the Appendix.	 

The undecidability of satisfiability for TML implies, as usual, the undecidability of validity for TML. In fact, Theorem 4.2 proves that the set of validities is not recursively enumerable.

Adequacy of TML
The Hennessy-Milner property (H-Mp), which states for a logic that bisimilarity of the models coincides with the semantic equivalence induced by the logic, is currently an open problem for timed logic. In [1] it was proven that the closed formulas (without free clock variables) cannot characterize bisimilarity. In this section we prove the H-Mp for TML, therefore we solve the adequacy problem.
Before proceeding with the proof, observe the essential role of interpretations in the semantics of TML. Consider the two TTSs depicted in Figure 1, where the horizontal lines represent the time flow from the initial states m and mj respectively. The two systems in the initial states can delay forever and they can both take an a-transition

to states that satisfy END after each delay 2 −  2
and 2 +  2
for each integer n > 0.

However, the two systems differ: m can take an a-transition after the delay 2, while
mj cannot.
If we consider an interpretation i ∈  (K) s.t. i(x) /∈ Q≥0 for any x ∈ K, one can notice that m and mj satisfy exactly the same formulas. However, this is not true if we consider an interpretation ij s.t. ij(x) = 0 for some x ∈ K, since m, ij |= ∃ (x =2 ∧ ⟨a⟩T) and mj, ij |= ¬( ∃ (x =2 ∧ ⟨a⟩T)).


END


m	m1
mj
1
mj




END END
Fig. 1. non-bisimilar TTSs
To clarify this situation, we start from analysing how the formulas satisfied by a model under a certain interpretation change when we change the interpretation.
It is useful in what follows to identify the set K(φ) of the free clocks in a formula
φ ∈ L, defined by: K(⊥) = ∅, K(x da r) = {x}, K(φ → ψ) = K(φ) ∪ K(ψ),
K([a]φ)= K( ∀ φ)= K(φ), K(∀x.φ)= K(φ) \ {x}.
For a clock variable y ∈K that does not appear in the syntax of φ and x ∈ K(φ), we denote by φ{y/x} the formula obtained by uniformly substituting all the occurrences of x in φ by y.
Definition 5.1 Given two rational interpretations f—, f+: K → Q and a bijection σ : K → K, for any formula φ ∈L let φ +σ f−/f+ be defined as follows, where x da t for t < 0 should be read as x ≥ 0:

⊥ +σ f−/f+
(φ ∧ ψ) +σ




f−/f+
=df ⊥
=df (φ +



f−/f+

) ∧ (ψ +σ



f−/f+ )

(x ≤ r) +σ

f−/f+
=df σ(x) ≤ (r + f
(x))
(x ≥ r) +σ

f−/f+
=df σ(x) ≥ (r + f
(x))

(¬φ) +σ

f−/f+
=df ¬(φ +
f+/f−)
([a]φ) +σ

f−/f+
=df [a](φ +
f−/f+ )

( ∀ φ) +σ

f−/f+
=df
∀ (φ +σ
f−/f+ )

(∀x.φ) +σ

f−/f+
=df ∀σ(x).(φ +
f−[x '→ 0]/f+
[x '→ 0])

Whenever f— = f+ = f , we write +σf ; whenever σ is the identity on K, we write
+f−/f+ .
The following lemma, which can be proved by induction over the structure of formu- las, and its corollaries characterize the relationships between the formulas satisfied by the same model under different interpretations.
Lemma 5.2 Let M = (M, θ, ⊕) be a TTS, σ : K → K, δ : K → R and f—, f+ : K → Q s.t. f— ≤ δ ≤ f+. Then for any m ∈ M, φ ∈ L and i ∈ (K), if i + δ ≥ 0 then:
M, m, i |= φ =⇒ M, m, (i + δ) ◦ σ—1 |= φ +σ f−/f+.

The implication from right to left is not always true, since f— and f+ are approxi-

mations of δ. However we have equivalences in some concrete cases.
Corollary 5.3 Let M = (M, θ, ⊕) be a TTS and f : K → Q. Then for any m ∈ M, φ ∈L and i ∈ (K), if i + f ≥ 0 then:
M, m, i |= φ ⇐⇒ M, m, i + f |= φ + f.
Corollary 5.4 Let M = (M, θ, ⊕) be a TTS and δ : K → R. Then for any m ∈ M, φ ∈L and i ∈ (K), if i + δ ≥ 0 and for any x ∈ K(φ), δ(x)= 0, then:
M, m, i |= φ ⇐⇒ M, m, i + δ |= φ.

With these, we can proceed with the proof of the H-Mp. We say that a TTS M = (M, θ, ⊕) has the ﬁnite image property if for any action a ∈ Σ and any m ∈ M , θ(m, a) is finite.
Theorem 5.5 (Hennessy-Milner Theorem) Consider a TTS M = (M, θ, ⊕)
satisfying the ﬁnite image property. Then for any m, n ∈ M:
m ∼ n	iff	∀i ∈  (K),φ ∈ L, M, m,i |= φ ⇔ M, n, i |= φ.

Proof. (⇐): We prove that R is a bisimulation
R = {(m, n) | ∀i, ∀φ, M, m, i |= φ ⇔ M, n, i |= φ}.

Supp. that m −→a
mj. If there exists no nj ∈ M s.t n −→a
nj, then M, n, i |= [a]⊥,

implying M, m, i |= [a]⊥ - contradicting the assumption. Let F = {nk
| n −→a
nk},

which is finite since the TTS is image finite. Suppose that (mj, nk) /∈ R for any k. Then, there exists ik ∈  (K) and φk ∈ L s.t. M, mj, ik |= φk and M, nk, ik |= ¬φk, for any k. For every x ∈ K(φk), consider a new variable xk distinct from all the
other variables. Let φj = φk{xk/x}, for every k and let ij ∈  (K) s.t. ij(xk)= ik(x)
k	j j	V	j	j	j

M, m, ij |= ⟨a⟩ Vk
j and M, n, ij |= [a]  ¬φj - contradiction.

Supp. that mj = d ⊕ m. For r ∈ Q≥0, r ≥ d, M, m, i[x '→ r − d] |= ∃ (x = r), which implies M, n, i[x '→ r − d] |= ∃ (x = r). Hence, there exists nj ∈ M
s.t. nj = d ⊕ n. We prove that (mj, nj) ∈ R. For any i ∈  (K) and φ ∈ L, M, mj,i |= φ implies, using Corollary 5.4, that M, mj, i[x '→ 0] |= φ for any x /∈ K(φ); further, applying Corollary 5.3, M, mj, i[x '→ 0] + r |= φ + r. Then, M, m, i[x '→ 0] + r − d |= ∃ (x = r ∧ (φ + r)) and M, n, i[x '→ 0] + r − d |= ∃ (x = r ∧ (φ + r)). Consequently, M, n, i[x '→ 0] + r − d |= ∀ (x = r → (φ + r)). This implies that M, nj, i[x '→ 0] + r |= x = r → (φ + [d|) ([d| denotes the smallest natural number bigger than d), which implies M, nj, i[x '→ 0] + r |= (φ + r). So M, nj,i + r |= φ + r, and using Corollary 5.3, M, nj,i |= φ.
The symmetry of R proves the other cases.	 

Metatheory for TML
In this section we develop a proof system for TML. We prove that TML is not com- pact and consequently requires infinitary rules. However, we demonstrate that our

proof system is strongly-complete for the TTS-semantics. The completeness proofs consist of the construction of a canonical model. Being the role of interpretations in the semantics of TTS, the canonical model is not constructed from maximal consistent sets, as for other modal logics. This is because a maximal consistent set does not identify a state of a TTS; it identifies a set in the presence of a fixed interpretation. Moreover, the same maximal consistent set might be satisfied by non-bisimilar models under different interpretations. To cope with all this complex situation we propose a new method for constructing canonical models.

Axiomatization for TML
Modal preﬁxes are words w ∈ Mod∗ over the alphabet
Mod = {[a] | a ∈ Σ}∪ { ∀∀ } ∪ {∀x. | x ∈ K},
e.g., ∀x.[a] ∀ [b][c], ∀x. ∀ , [a],ε ∈ Mod∗, where ε is the empty word. A context is a word formed by a modal prefix w ∈ Mod∗ concatenated with the metavariable X; e.g., [a]X, ∀x. ∀ X, ∀x.[a] ∀ [b][c]X are contexts. To emphasize the presence of the metavariable we will use the functional representation of type C[X] for contexts; this will allow us to instantiate the metavariable with elements from L. For example, if C[X]= ∀x.[a] ∀ [b][c]X is a context, then C[(x ≥ r)] = ∀x.[a] ∀ [b][c](x ≥ r) ∈ L. Also ε[X] is a context - the empty one - and for φ ∈ L, ε[φ]= φ.
The axiomatic system of TML includes, in addition to the axioms and the rules of propositional logic, the axioms and the rules in Table 1. They are stated for arbitrary φ, ψ ∈ L, r, s, t ∈ Q≥0, a ∈ Σ, o ∈ Mod and arbitrary context C[X].
A formula φ is provable, denoted by ▶ φ, if it can be proven from the given axioms and rules. We say that φ is consistent, if φ → ⊥ is not provable. Given a set Φ of formulas, we say that Φ proves φ, Φ ▶ φ, if from the formulas of Φ and from the axioms one can prove φ, eventually using Boolean or infinitary-Boolean reasoning. In other words, we assume that the provability is closed under the rule
Φ ∪ {φ}▶ ψ iff Φ ▶ φ → ψ,
for arbitrary (possibly infinite) sets Φ ⊆ L. Φ is consistent if it is not the case that Φ ▶ ⊥.
The axioms (A1)-(A3) state simple facts about the clock values. The axiom (A4) reflects the fact that action-transitions in a TTS happen instantaneously.
The axioms (A5)-(A10) describe the nature of time in TTSs. Thus, (A5) states that the time is linear and 0-delays do not perturb the system; (A6) that the time is persistent; (A7) that the flow of time is unidirectional (the past and the future are disjoint); (A8) that the time is deterministic; (A9) and (A10) that the time is continuous. The axiom (A11) guarantees that all the clocks measure the same time flow.
The axiom (A12) together with the infinitary rule (R4) describe the fact that the information provided by a clock variable x in a formula prefixed by ∀x is superfluous.



(A1): ▶ x ≥ 0

(A2): ▶ (x ≥ r) ∨ (x ≤ r)
(A3): ▶ x ≤ r → ¬(x ≥ s), r < s
(A4): ▶ x Œ r → [a](x Œ r) (A5): ▶ ∀ φ → φ ∧ ∀ ∀ φ
(A6): ▶ ∀ φ → ∀ (r ≤ x ≤ s → φ), r ≤ s
(A7): ▶ x ≥ r → ∀ (x ≥ r)
(A8): ▶ ∃ (x = r ∧ φ) → ∀ (x = r → φ)
(A9): ▶ ∃ (x ≤ r ∧ ∀ φ) →
∀ (x ≥ r → φ)
(A10): ▶ ∃ (x ≤ r) ∧ ∃ (x ≥ r) →
∃ (x = r)
(A11): ▶ x Œ r ∧ y Œ s →
∀ (x Œ r + t → y Œ s + t) (A12): ▶ ∀x.φ → φ + [x '→ r]/[x '→ s], r ≤ s
(A13): ▶ ∀(x ≤ r). ∀ (x = s → φ) →
∀(x = r). ∀ (s ≤ x ≤ s + r → φ) (A14): ▶ o(φ → ψ) → (oφ → oψ) (R1): If ▶ φ, then ▶ oφ

(R2): {C[x Œ r] | r D s}▶ C[x Œ s]
(R3): {C[x ≥ r] | r ∈ Q≥0}▶ C[⊥] (R4): {C[φ + [x '→ r]/[x '→ s]] | r ≤ s}
▶ C[∀x.φ]
(R5): {C[ ∀ (x ≤ s → φ)] | s ∈ Q≥0}
▶ C[ ∀ φ]

Table 1
The Axiomatic System of TML
The role of (A13) is to characterize the interaction between the two types of universal quantifiers.
The axiom (A14) and the rule (R1) state that all the box-like operators of TML are normal.
The rules (R2)-(R5) are infinitary and have instances for any possible context. For instance, the formulas below are instances of the rules (R2) and (R3) respectively.
{[a](x ≥ r) | r < s}▶ [a](x ≥ s),
{ ∀∀ [a](x ≥ r) | r ∈ Q≥0}▶ ∀ [a]⊥.
The rule (R2) reflects the Archimedean property of rationals. (R3) guarantees that the value of any clock is finite in any model under any interpretation.
By induction on the structure of possible proofs, we prove the soundness.
Theorem 6.1 (Soundness) The axiomatic system in Table 1 is sound with re- spect to the TTS-semantics, i.e., for arbitrary Φ ⊆ φ and φ ∈ L,
Φ ▶ φ implies Φ |= φ.

Non-Compactness of TML
We have seen in Section 4 that the set of validities of TML are not recursively enu- merable. This means that any complete axiomatization of TML must be infinitary.

Otherwise, we could enumerate all the proofs and the set of provable formulas, which in a complete logic coincides with the set of validities, is recursively enumerable - contradiction!
There is also a model theoretic result that ensures us the necessity of having infini- tary rules:
Theorem 6.2 (Non-Compactness of TML) TML with the TTS-semantics is not compact, i.e., there exists an inﬁnite set Φ ⊆ L such that each ﬁnite subset of Φ admits a model but Φ does not admit any model.

Proof. The result derives from the soundness of the infinitary rules and each rule can be used to produce examples of such sets. Consider, for example, s ∈ Q≥0 and the set
Φ= {x ≥ r | r < s}∪ {x < s}.
Since for any i ∈  (K), i(x) ≥ r for each r < s implies i(x) ≥ s, Φ does not admit any model. However, it is not difficult to construct a model for just any finite subset of Φ.	 


Canonical Model and Completeness
In this section we prove that the axiomatic system of TML is not only sound, but also complete for the TTS-semantics, meaning that for arbitrary Φ ⊆L and φ ∈ L, Φ |= φ iff Φ ▶ φ. To complete this proof it is sufficient to show that any consistent formula has a model. In the following we construct a canonical model, which is a TTS such that each consistent formula is satisfied at some state under some interpretation. In modal logics such a construction is usually done using maximally consistent sets of formulas as states.
For some set S ⊆ L, we say that Φ ⊆L is S-maximally consistent if Φ is consistent and no formula of S can be added to Φ without making it inconsistent. Φ is maximally-consistent if it is L-maximally-consistent.
The aforementioned technique to construct canonical models cannot be applied directly for TML because to the same state of a given TTS corresponds different maximally-consistent sets of formulas under different interpretations. We generalize this construction to cope with the complexity of TML. To the best of our knowledge, the following construction is original.
For the beginning, we observe that given a maximally-consistent set of formulas, the information contained about a given clock is complete.
Let Ω be the set of L-maximally consistent sets.
Lemma 6.3 For arbitrary Λ ∈ Ω and x ∈ K,
sup{r ∈ Q+ | x ≥ r ∈ Λ} = inf{r ∈ Q+ | x ≤ r ∈ Λ}∈ R≥0.

Proof. Let A = {r ∈ Q+ | x ≥ r ∈ Λ} and B = {r ∈ Q+ | x ≤ r ∈ Λ}. (A1) guarantees that A /= ∅ and if B = ∅, we can derive a contradiction from (R3) for C[X]= X.
Since the two sets are non-empty, the sup and inf exist. Moreover, (R3) can also be used to prove that sup A < ∞. Let sup A = u and inf B = v. If u < v, there exists r ∈ Q+ such that u < r < v. Hence, x ≤ r ∈ Λ, which contradicts r ≤ v. If v < u, there exists r1, r2 ∈ Q+ such that v < r1 < r2 < u. Hence, x ≤ ri,x ≥ ri ∈ Λ for i = 1, 2. Since r2 − r1 > 0, (A3)▶ x ≥ r2 → ¬(x ≤ r1), which proves the inconsistency of Λ - contradiction.	 

The previous lemma demonstrates that to each maximally-consistent set corre- sponds a unique interpretation of clocks that we will identify in what follows using the function I :Ω −→ (K) defined for arbitrary Λ ∈ Ω and x ∈K by
I (Λ)(x)= sup{r ∈ Q+ | x ≥ r ∈ Λ}∈ R≥0.
Since I (Λ) synthesize only the information in Λ regarding the clocks, there exist disjoint sets Λ1, Λ2 ∈ Ω s.t. I (Λ1) = I (Λ2); this equality defines an equivalence relation on Ω and the equivalence classes are in one to one correspondence with the interpretations in (K).
Observe that any state in a model of TML corresponds to a function from  (K) to Ω: given a model, each interpretation identifies a maximally-consistent set of formulas satisfied by that model under the given interpretation. Consequently, to construct the canonical model we will have to take as states not maximally-consistent sets of formulas, but functions from interpretations to maximally-consistent sets. However, not just any function γ :  (K) → Ω is a good candidate for a model, because between the maximally-consistent sets associated to a model under different interpretation there are certain coherence conditions as the ones described in Lemma 5.2 and corollaries 5.3 and 5.4. For S ⊆ L, δ : K → R, let
S ☒ δ = {φ + f−/f+ | φ ∈ S, f—, f+ : K → Q s.t. f— < δ < f+}.
These coherences are formally described in the next definition.
Definition 6.4 A function γ :  (K) → Ω is coherent, if for any i, ij ∈  (K),
(I ◦ γ)(i)= i;
γ(i) ☒ (ij − i) ⊆ γ(ij).
Lemma 6.5 For any S ⊆ L, δ, δ0, δ2 : K → R s.t. δ = δ1 + δ2, then
S ☒ δ = (S ☒ δ1) ☒ δ2.
Proof. (⇒) Suppose ψj ∈ S ☒ δ. Then there must exist ψ ∈ S, f—, f+ : K → Q s.t. f— < δ < f+ and ψj = ψ + f−/f+. Since δ = δ1 + δ2, there exist g—, g+, h—, h+ : K → Q s.t. g— < δ1 < g+, h— < δ < h+ and f— = g— + h—, f+ = g+ + h+. So ψj = ψ + g− + h−/g+ + h+ = ψ + g−/g+ + h−/h+. Since ψ + g−/g+ ∈ S ☒ δ1 by definition, we have ψ + g−/g+ + h−/h+ ∈ (S ☒ δ1) ☒ δ2. Hence, ψj ∈ (S ☒ δ1) ☒ δ2.
(⇐) Suppose ψj ∈ (S ☒ δ1) ☒ δ2. Then there must exist ψ ∈ S, g—, g+, h—, h+ : K → 
Q s.t. g— < δ1 < g+, h— < δ < h+ and ψj = ψ + g−/g+ + h−/h+. Since δ = δ1 + δ2,

there exist f—, f+ : K → Q s.t. f— < δ < f+ and f— = g— + h—, f+ = g+ + h+. So
ψj = ψ + g− + h−/g+ + h+ = ψ + f−/f+ . Hence, ψj ∈ S ☒ δ.	 

We say that a set C ⊆ Ω is coherent if there exists a set T ⊆  (K) and a bijection γ : T →C that satisfies the two conditions of Definition 6.4. C is maximally-coherent if T = (K). Observe that the bijection that defines a maximally-coherent set is a coherent function in the sense of Definition 6.4.
Lemma 6.6 Let Λ1, Λ2 ∈ Ω and {Λ1, Λ2} be coherent with each other. Then for any i ∈ (K),
Λ1 ☒ (i − i1)= Λ2 ☒ (i − i2), where i1 = I (Λ1), i2 = I (Λ2).

Proof. (⇒) Λ1 ☒ (i − i1)= Λ1 ☒ ((i2 − i1)+ (i − i2)), which implies Λ1 ☒ (i − i1)= (Λ1☒(i2−i1))☒(i−i2)) by Lemma 6.5. Since {Λ1, Λ2} is coherent, Λ1☒(i2−i1) ⊆ Λ2. So (Λ1 ☒ (i2 − i1)) ☒ (i − i2)) ⊆ Λ2 ☒ (i − i2).
(⇐) Similar as above.	 

With the above lemmas, we now can prove the first fundamental result, which says that any maximally-consistent set Λ belongs to the image γ( (K)) of some coherent function γ. After constructing the canonical model on the set of coherent functions, this result will guarantee that any maximally-consistent set is satisfied by some model under some interpretation.
Lemma 6.7 For any Λ ∈ Ω, there exists a coherent function γ s.t. γ(I (Λ)) = Λ.
Proof. We prove the lemma by the following three steps:
Firstly, observe that C ⊆ Ω is coherent iff for any Λ1, Λ2 ∈ C, with i1 =
I (Λ1), i2 = I (Λ2),
Λ1 ☒ (i2 − i1) ⊆ Λ2 and Λ2 ☒ (i1 − i2) ⊆ Λ1, Moreover, Λ1 ☒ (i2 − i1) ⊆ Λ2 iff Λ2 ☒ (i1 − i2) ⊆ Λ1.
Secondly, we observe that all the infinitary rules of our axiomatization have countable sets of instances, which means that L satisfies the conditions of Rasiowa- Sikorski lemma. Hence, the completion of L also satisfies the conditions of Rasiowa- Sikorski lemma. Since any consistent set S of L corresponds to a non-zero element S in the completion, by applying Rasiowa-Sikorski lemma to the completion of L, we obtain that there exists an ultrafilter u of the completion containing	S. This is equivalent to the fact that there exists an unltrfilter u∩L of L that includes
S [10]. This result will be used in III and IV.
We prove that if i = I (Λ) and ij ∈  (K), then there exists Λj ∈ Ω s.t. I (Λj)= ij and {Λ, Λj} is coherent. To prove this, we firstly use Definition 5.1 and the axioms to prove that Λ ☒ (ij − i) is consistent. Then, we can conclude that

Λ ☒ (ij − i) must have a maximal-consistent extension Λj by what we discussed in
II. Since Λ ☒ (ij −i) ⊆ Λj, we also have Λj ☒ (i−ij) ⊆ Λ. Hence, {Λ, Λj} is coherent.
IV. Suppose C = {Λ0, Λ1,..., Λk,.. .} is a coherent set (possibly infinite), is = I (Λs), s = 1,..., k, ... and j ∈ (K). The same as the above case, we can prove that Λs ☒ (j − is) is consistent. By Lemma 6.6, we have that Λ1 ☒ (j − i1) = Λ2 ☒ (j − i2)= ... = Λk ☒ (j − ik)= ... Hence, in order to get a coherent function γ, we only need to get Λ ☒ (ij − i) for any ij ∈ (K), and extend it to maximal- consistent set Λi′ by what we discussed in II. Let γ(ij)= Λi′ . It is obvious that γ is a coherent function.	 

In what follows we define a TTS using the set
Γ= {γ : (K) → Ω | γ is a coherent function} as the support-set of the model and the structure

γ −→a
γj if [∀i ∈  (K), [a]φ ∈ γ(i) ⇒ φ ∈ γj(i)];

γj = d ⊕ γ if [∀i, ∀ φ ∈ γ(i) ⇒ φ ∈ γj(i + d)].
Theorem 6.8 (Canonical Model) The tuple Γ = (Γ, θ, ⊕) deﬁned above is a TTS.

Proof. We prove the theorem by the following steps:
Firstly, we prove that γ1 = d ⊕ γ and γ2 = d ⊕ γ implies γ1 = γ2.
For any ∀i ∈ (K) and x ∈ K\ K(φ), φ ∈ γ1(i) implies x = [d|∧φ ∈ γ1(i[x '→ [d|]), where [d| denote the smallest integer larger than d. Since γ1 = d ⊕ γ,
∃ (x = [d|∧ φ) ∈ γ(i[x '→ [d|] − d), which further implies, due to (A8), that
∀ (x = [d|→ φ) ∈ γ(i[x '→ [d|] − d).
x = [d| → φ ∈ γ2(i[x '→ [d|]) since γ2 = d ⊕ γ. Then φ ∈ γ2(i[x '→ [d|]), which implies φ ∈ γ2(i) because x /∈ K(φ). Hence for any i ∈ (K), γ1(i) ⊆ γ2(i). Similarly, γ2(i) ⊆ γ2(i).
Observe now that due to (A5), ∀ φ ∈ γ(i) implies φ ∈ γ(i), for any γ ∈ Γ and
i ∈  (K). Hence, 0 ⊕ γ = γ.

Now we prove that d ⊕ (dj ⊕ m) =~ (d + dj) ⊕ m, i.e. ∃γ ,γ 
s.t. γ
= dj ⊕ γ,

γ2 = d ⊕ γ1 iff ∃γ3 s.t. γ3 = (d + dj) ⊕ γ.
1	2	1

(⇒) Suppose ∃γ1, γ2 s.t. γ1 = d ⊕ γ, γ2 = dj ⊕ γ1. From (A5), ∀ φ ∈ γ(i) implies
∀ ∀ φ ∈ γ(i) and since γ1 = d ⊕ γ, ∀ φ ∈ γ1(i + d). This implies φ ∈ γ2(i + d + dj) because γ2 = dj ⊕ γ1. Hence, there exists γ3 = (d + dj) ⊕ γ and, in fact, γ3 = γ2.
(⇐) Supp. that ∃γ3 s.t. γ3 = (d + dj) ⊕ γ.
Firstly, we prove that there exists γ1 s.t. γ1 = dj ⊕ γ by constructing it. For each i ∈  (K), γ(i) ☒ dj ⊆ γ1(i + dj). It is not difficult to verify that for arbitrary i, j ∈  (K), γ(i) ☒ (dj + (j − i)) ⊆ γ(j) ☒ dj and

x∈K{x Ð r | r ∈ Q+, i(x) Ð r}⊆ γ(i) ☒ dj.
Now, we can use a similar construction as in Lemma 6.7 to construct entire γ1.
Secondly, we need to prove that there exists d ⊕ γ1. For any i ∈ (K), ∀ φ ∈ γ1(i) implies x ≤ r ∧ ∀ φ ∈ γ1(i) for r ∈ Q+ s.t. i(x) ≤ r ≤ i(x)+ d. Then,
x ≤ (r + [dj|) ∧ ∀ (φ + [dj|) ∈ γ1(i + [dj|).
Now because γ1 = dj ⊕ γ, we obtain
∃ (x ≤ (r + [dj|) ∧ ∀ (φ + [dj|)) ∈ γ(i + [dj|− dj).
From this we get, by applying (A9), that
∀ (x ≥ (r + [dj|) → ∀ (φ + [dj|)) ∈ γ(i + [dj|− dj).
Since γ3 = (d + dj) ⊕ γ,
x ≥ (r + [dj|) → ∀ (φ + [dj|) ∈ γ3(i + [dj| + d).
And because r ≤ i(x)+ d, x ≥ (r + [dj|) ∈ γ3(i + [dj| + d). We then get that
∀ (φ + [dj|) ∈ γ3(i + [dj| + d), implying ∀ φ ∈ γ3(i + d), which using (A5) gives
φ ∈ γ3(i + d). Hence, there exists d ⊕ γ1 = γ3.	 
Lemma 6.9 (Truth Lemma) For any ψ ∈ L, i ∈  (K) and γ ∈ Γ,
Γ, γ,i |= ψ iff ψ ∈ γ(i).

Proof. Induction on ψ.
[The case ψ = ∀x.φ]: Γ, γ,i |= ∀x.φ iff Γ, γ, i[x '→ u] |= φ for any u ∈ R≥0, i.e.,
φ ∈ γ(i[x '→ u]) for all u ∈ R≥0.
(=⇒) φ ∈ γ(i[x '→ u]) implies φ+[x '→ r]/[x '→ s] ∈ γ(i) for all r, s ∈ Q s.t r ≤ u−i(x) ≤
s. This must happen for any u ∈ R≥0, so for any r, s ∈ Q, φ + [x '→ r]/[x '→ s] ∈ γ(i). Hence, ∀x.φ ∈ γ(i) by rule (R4).
(⇐=) Using (A12), ∀x.φ ∈ γ(i) implies φ+[x '→ r]/[x '→ s] ∈ γ(i[x '→ u) for any u ∈ R≥0 and r, s ∈ Q s.t. r ≤ u − i(x) ≤ s. Consequently, ∀x.φ ∈ γ(i[x '→ u]) by (R4). And (A12), φ ∈ γ(i[x '→ u]) for all u ∈ R≥0.
[The case ψ = ∀∀φ]: Γ, γ,i |= ∀ φ iff [for any d ∈ R≥0 and γj ∈ Γ s.t. γj = d ⊕ γ, Γ, γj,i + d |= φ] iff φ ∈ γj(i + d) by the inductive hypothesis.
(=⇒) φ ∈ γj(i + d) implies (x = r) ∧ φ ∈ γj((i + d)[x '→ r]), for any r ∈ Q+, r ≥ d. Applying (A8), ∀ (x = r → φ) ∈ γ(i[x '→ r − d]) , for any r ∈ Q+, r ≥ d. This implies x ≤ r → ∀ (x = r → φ) ∈ γ(i[x '→ u]) for any u ∈ R≥0. Then, ∀(x ≤ r). ∀ (x = r → φ) ∈ γ(i). Applying (A13), ∀(x = r). ∀ (r ≤ x ≤ 2r → φ) ∈ γ(i), which further implies ∀(x = 0). ∀ (0 ≤ x ≤ r → φ) ∈ γ(i) by (A12) and (R4). Using (R5), ∀(x = 0). ∀ (x ≥ 0 → φ) ∈ γ(i), which implies
∀(x = 0). ∀ (x ≥ 0 → φ) ∈ γ(i[x '→ 0]). So, x =0 → ∀ (x ≥ 0 → φ) ∈ γ(i[x '→ 0]), which implies ∀ (x ≥ 0 → φ) ∈ γ(i[x '→ 0]). Using (A1), ∀ φ ∈ γ(i[x '→ 0]) and further, ∀ φ ∈ γ(i).
(⇐=) derives from the definition of ⊕.

[The case ψ = [a]φ]: Γ, γ,i |= [a]φ iff for any γj ∈ Γ s.t. γ −→a φ ∈ γj(i) by induction.
γj, Γ, γj,i |= φ, iff

(=⇒) Supp. ⟨a⟩¬φ ∈ γ(i). Let A = {γj | γ −→a  γj}, B = {¬φ}∪{ψ | [a]ψ ∈ γ(i)}∪Δ
i	i
and Bj = {ψ | [a]ψ ∈ γ(j)}∪ Δi for any j /= i, where Δk =  x∈ K{x ≤ r | r ≥

i(x)}∪ {x ≥ r | r ≤ i(x)}.
{ψ | [a]ψ ∈ γ(i)}∪ Δi and Bj, j /= i are consistent.
Suppose that Bi is inconsistent. Then, there exists a set F ⊆ Bi s.t. F ▶ φ. If F is finite, (R1) guarantees that [a]F ▶ [a]φ, where [a]F = {[a]ρ | ρ ∈ F}. Otherwise, F ▶ φ is (modulo Boolean reasoning possible involving infinite meets) an instance of one of the rules (R2)-(R5); in all these cases, [a]F ▶ [a]φ is an instance of the same rule for the context C[X]= [a]X. Since F ⊆ Bi, [a]F ⊆ γ(i) implying [a]φ ∈ γ(i), which contradicts the consistency of γ(i). Hence, Bi is consistent.
Now we prove that for any j, jj ∈ I(K), Bj and Bj′ are such that Bj +(jj −j) ⊆ Bj′ . If j /= i, then for arbitrary ρ ∈ Bj either [a]ρ ∈ γ(j), or ρ = x Œ r. In the first case, [a]ρ + f−/f+ ∈ γ(jj), for all f— ≤ jj − j ≤ f+. So, ρ + f−/f+ ∈ Bj′ . In the second case, since ρ = x Œ r is closed under any interpretation transformation, for any f— ≤ jj − j ≤ f+, ρ + f−/f+ ∈ Bj′ .
If j = i, consider an arbitrary ρ ∈ Bj. If ρ /= ¬φ, we get a similar case as above. Otherwise, ⟨a⟩ρ ∈ γ(i), which implies ⟨a⟩ρ + f−/f+ ∈ γ(j) for all f— ≤ j − i ≤ f+. So, ρ + f−/f+ ∈ Bj.
At this point we can use a similar strategy as in Theorem 6.7 to prove that there exists γjj ∈ Γ s.t. for any j ∈ I(K), Bj ⊆ γjj(j). But then, γjj ∈ A, which implies φ ∈ γjj(i) - contradiction!
Hence, [a]φ ∈ γ(i).
(⇐=) derives from the definition of θ.	 
Corollary 6.10 If Φ ⊆ L is consistent, there exists γ ∈ Γ and i ∈  (K) s.t.
Γ, γ,i |= Φ.

Proof. Because the infinitary rules of TML have countable sets of instances, the Rasiowa-Sikorski lemma guarantees the existence of some Λ ∈ Ω s.t. Λ ⊇ Φ. Lemma
6.7 guarantees that there exists γ ∈ Γ s.t. Λ = γ(I (Λ)). Hence Γ, γ, I (Λ) |=Φ by applying Lemma 6.9.	 

Corollary 6.10 is a well known equivalent formulation of the strong completeness theorem.
Theorem 6.11 (Strong Completeness) TML is strongly-complete with respect to the TTS-semantics, i.e., for arbitrary Φ ⊆L and φ ∈ L,
Φ |= φ implies Φ ▶ φ.

Conclusions
In this paper we addressed and solved a series of open problems regarding the timed logics and real-time systems. We develop the metatheory for the Timed Modal Logic (TML), which is the most basic logic used in practice for specifying and analyzing timed transition systems (TTSs).

In this paper we demonstrate that TML is adequate for the TTS semantics. We show that its satisfiability problem is undecidable and the set of the validities is not recursively enumerable. Despite this, we develop a strongly-complete proof system for TML. Because TML is not compact, the proof system contains necessarily infinitary rules and these rules also explain why the set of validities is not recursively enumerable. Our axioms characterize the concept of time used in the definition of TTS. Our completeness proof is based on a novel method that generalizes the classic filtration technique used in modal logics for the construction of canonical models. Essential in the proof is the use of the Rasiowa-Sikorski lemma.
All these results open new perspective on real-time systems and on their analysis and reveal new research directions. The proof system contains similar axioms to those of other well-known logics, which makes one think about other possible connections and research perspectives.

References
Luca Aceto, Anna Ing´olfsd´ottir, Kim Guldstrand Larsen, and Jiri Srba. Reactive Systems: modelling, specification and verification. Cambridge University Press, 2007.
Rajeev Alur, Costas Courcoubetis, and David L. Dill. Model-checking in dense real-time. Information and Computation, 104(1):2–34, May 1993.
Rajeev Alur, Costas Courcoubetis, and David L. Dill. Model-checking in dense real-time. Inf. Comput., 104(1):2–34, 1993.
Rajeev Alur and David L. Dill. A theory of timed automata. Theoretical Computer Science, 126(2):183–235, April 1994.
Rajeev Alur, T´omas Feder, and Thomas A. Henzinger. The benefits of relaxing punctuality. Journal of the ACM, 43(1):116–146, January 1996.
Rajeev Alur and Thomas A. Henzinger. Logics and models of real time: A survey. In REX Workshop, volume 600, pages 74–106. Springer, 1991.
Rajeev Alur and Thomas A. Henzinger. Real-time logics: Complexity and expressiveness. Information and Computation, 104(1):35–77, May 1993.
Rajeev Alur and Thomas A. Henzinger. A really temporal logic. Journal of the ACM, 41(1):181–203, January 1994.
Howard Barringer, Ruurd Kuiper, and Amir Pnueli. A really abstract concurrent model and its temporal logic. In POPL, pages 173–183. ACM Press, 1986.
Steven Givant and Paul Halmos. Introduction to Boolean Algebras. Springer, 2009.
R. Goldblatt. On the role of the Baire category theorem in the foundations of logic. Journal of Symbolic logic, pages 412–422, 1985.
Thomas A. Henzinger. Half-order modal logic: How to prove real-time properties. In Cynthia Dwork, editor,
PODC, pages 281–296. ACM, 1990.
Thomas A. Henzinger, Xavier Nicollin, Joseph Sifakis, and Sergio Yovine. Symbolic model checking for real-time systems. In LICS, pages 394–406, 1992.
Ron Koymans. Specifying real-time properties with metric temporal logic. Real-Time Systems, 2(4):255– 299, 1990.
Dexter Kozen, Kim G. Larsen, Radu Mardare, and Prakash Panangaden. Stone duality for markov processes. In LICS, pages 321–330. IEEE Computer Society, 2013.
Salvatore La Torre and Margherita Napoli.	A decidable dense branching-time temporal logic.	In
FSTTCS’00, volume 1974, pages 139–150. Springer-Verlag, 2000.


Fran¸cois Laroussinie, Kim Guldstrand Larsen, and Carsten Weise. From timed automata to logic - and back. In MFCS, volume 969, pages 529–539. Springer, 1995.
Jo¨el Ouaknine and James Worrell. On the decidability of metric temporal logic. In LICS’05, pages 188–197. IEEE Comp. Soc. Press, 2005.
Jo¨el Ouaknine and James Worrell. On metric temporal logic and faulty Turing machines. In FoSSaCS’06, volume 3921, pages 217–230. Springer-Verlag, 2006.
Jo¨el Ouaknine and James Worrell. On the decidability and complexity of metric temporal logic over finite words. Logicical Methods in Computer Science, 3(1), March 2007.
H. Rasiowa and R. Sikorski. A proof of the completeness theorem of Go¨del. Fund. Math, 37:193–200, 1950.
Jean-Franc¸ois Raskin and Pierre-Yves Schobbens. Real-time logics: Fictitious clock as an abstraction of dense time. In TACAS, volume 1217, pages 165–182. Springer, 1997.
Pierre-Yves Schobbens, Jean-Fran¸cois Raskin, and Thomas A. Henzinger. Axioms for real-time logics.
Theor. Comput. Sci., 274(1-2):151–182, 2002.

Appendix
This appendix contains the details of the proofs of the major results presented in the paper.
Proof. [Proof of Theorem 4.2] Our reduction is similar to the one in [3]. The question as to whether a non-deterministic 2-counter machine has a computation with the initial location being visited infinitely often is Σ1-hard. We show how to
reduce this problem into a TML satisfiability question.
Let M be a 2-counter machine with counters X and Y and with n + 1 program instructions l0,..., ln. The instruction ln represents termination, and each instruc- tion li (i < n) is either an increment of the form [li : X := X + 1; goto lj] or a decrement of the form [li : if X /= 0 then X := X − 1; goto lj else goto lk] or a non-deterministic jump of the form [li : goto lj or lk]. A configuration of M is a triple ⟨li, x, y⟩, where x and y are natural numbers representing the current values of X and Y . A computation of M is a “valid” sequence of configurations starting in ⟨l0, 0, 0⟩ and ending in some configuration of the type ⟨ln, x, y⟩.
We encode the computation of M in TML using the actions Σ = {l0,..., ln, X,Y }. We say that a state m of a given TTS T encodes the configuration ⟨li, x, y⟩ in the interval [a, b), with a, b ∈ R+ and a < b, iff the following holds:
(d ⊕ m) −X→ for exactly x distinct time-points d in (a, b);
(d ⊕ m) −Y→ for exactly y distinct time-points d in (a, b);
(d ⊕ m) li  for d = a;
lj
(d ⊕ m) −→ for all time-points d in (a, b) and for all j.
Let {⟨li(j), xj, yj⟩ : j ≥ 0} be a computation of M (i.e. i(0) = 0). We may construct a (closed) TML formula φM , such that for any TTS T and any state m, T ,m |= φ if and only if m encodes the j’th configuration over the interval [j, j + 1) for all j ≥ 0. Also φM will ensure that m encodes a computation where l0 is visited infinitely often. The formula φM is obtained as the conjunction of a formula expressing the

initial configuration, a formula expressing infinite repetition of the initial location and a formula for each instruction of M ensuring that states (d ⊕ m) of T being separated by a delay of 1 correctly encodes the given instruction. The following formula ensures that instructions of M are unique:
∀ (⟨li⟩T → [lj] ⊥), for all i /= j (uniqueness);
The initial configuration is encoded as the conjunction of the following TML for- mulae:
⟨l0⟩T;
x in ∀ (0 < x < 1 → [li] ⊥), for all i ≥ 0;
x in ∀ (0 < x < 1 → ([X] ⊥ ∧[Y ] ⊥)).
An increment statement of the form [li : X := X + 1; goto lj] is reflected by the conjunction of the following formulae relating the behaviour in a unit-interval

{(d ⊕ m): d ∈ [j, j + 1)} with (j ⊕ m) li
∀ ⟨li⟩T → x in ∃ (x =1 ∧ ⟨lj⟩)T ;
with the successor unit-interval:
 

(iii) ∀ ⟨li⟩T → x in ∀ (x < 1 ∧ ⟨X⟩T → y in ∃ (y =1 ∧ ⟨X⟩T)) ;
y in ( ∃ (y > 1 ∧ x < 2 ∧ ⟨X⟩T))∧
y in ( ∀ (y > 1 ∧ x < 2 ∧ ⟨X⟩T → z in ∀ (z > 0 ∧ x < 2 → [X] ⊥))))
Here (1) encodes the goto of the instruction. (2) ensures that li actions are only possible at integer-points. (3) ensures that all X actions in the interval [j, j + 1) are copied to the successor interval [j + 1,j + 2). The most involved formula (4) ensures that exactly one additional X action is inserted in [j + 1,j + 2) after the copy of the last X action in [j, j + 1). The formulae for decrement and non-deterministic choice are similar (and simpler). Infinite repetition of l0 is easily expressed as
∀ [⟨l0⟩→ x in ∃ (x > 0 ∧ ⟨l0⟩T)].	 

Proof. [Proof of Lemma 5.2] Induction on φ.
[The case x ≥ r]: (x ≥ r) +σ f−/f+ = σ(x) ≥ (r + f—(x)). M, m, i |= x ≥ r implies i(x) ≥ r. Then ((i + δ) ◦σ—1)(x) ≥ r + δ(x) ≥ r + f—(x). Hence M, m, (i + δ) ◦σ—1 |= (x ≥ r) +σ f−/f+.
[The case x > r]: (x > r) +σ f−/f+ = σ(x) > (r + f—(x)). M, m, i |= x > r implies i(x) > r. Then ((i + δ) ◦σ—1)(x) > r + δ(x) ≥ r + f—(x). Hence M, m, (i + δ) ◦σ—1 |= (x > r) +σ f−/f+.
[The case x ≤ r]: (x ≤ r) +σ f−/f+ = σ(x) ≤ (r + f+(x)). M, m, i |= x ≤ r implies i(x) ≤ r. Then ((i + δ) ◦σ—1)(x) ≤ r + δ(x) ≤ r + f+(x). Hence M, m, (i + δ) ◦σ—1 |= (x ≤ r) +σ f−/f+.
[The case x < r]: (x < r) +σ f−/f+ = σ(x) < (r + f+(x)). M, m, i |= x < r implies i(x) < r. Then ((i + δ) ◦σ—1)(x) < r + δ(x) ≥ r + f+(x). Hence M, m, (i + δ) ◦σ—1 |= (x < r) +σ f−/f+.
[The case φ ∧ ψ]: M, m, i |= φ ∧ ψ implies M, m, i |= φ and M, m, i |= ψ. By

inductive hypothesis, M, m, (i + δ) ◦ σ—1 |= φ +σ f−/f+ and M, m, (i + δ) ◦ σ—1 |= ψ +σ f−/f+, which imply M, m, i + δ |= (φ +σ f−/f+) ∧ (ψ +σ f−/f+). Hence M, m, (i + δ) ◦ σ—1 |= (φ ∧ ψ) +σ f−/f+.
[The case φ ∨ ψ]: M, m, i |= φ ∨ ψ implies M, m, i |= φ or M, m, i |= ψ. By inductive hypothesis, M, m, (i + δ) ◦ σ—1 |= φ +σ f−/f+ or M, m, (i + δ) ◦ σ—1 |= ψ +σ f−/f+, which imply M, m, (i + δ) ◦ σ—1 |= (φ +σ f−/f+) ∨ (ψ +σ f−/f+). Hence M, m, (i + δ) ◦ σ—1 |= (φ ∨ ψ) +σ f−/f+.

[The case [a]φ]: M, m, i |= [a]φ implies for any mj ∈ M s.t. m −→a
mj, M, mj,i |= φ.

By inductive hypothesis, M, mj, (i + δ) ◦ σ—1 |= φ +σ f−/f+, which implies M, m, (i +
δ) ◦ σ—1 |= [a](φ +σ f−/f+). Hence M, m, (i + δ) ◦ σ—1 |= ([a]φ) +σ f−/f+.

[The case ⟨a⟩φ]: M, m, i |= ⟨a⟩φ implies exists mj ∈ M s.t. m −→a
mj and M, mj,i |=

φ. By inductive hypothesis, M, mj, (i+δ)◦σ—1 |= φ+σf−/f+, which implies M, m, (i+
δ) ◦ σ—1 |= ⟨a⟩(φ +σ f−/f+). Hence M, m, (i + δ) ◦ σ—1 |= (⟨a⟩φ) +σ f−/f+.
[The case ∀∀φ]: M, m, i |= ∀ φ implies for any d ∈ R+ and mj ∈ M s.t. mj = d⊕m, M, mj,i |= φ. By inductive hypothesis, M, mj, (i + δ) ◦ σ—1 |= φ +σ f−/f+, which implies M, m, (i+δ)◦σ—1 |= ∀ (φ+σ f−/f+). Hence M, m, (i+δ)◦σ—1 |= (∀ φ)+σ f−/f+.
[The case ∃∃φ]: M, m, i |= ∃ φ implies exists d ∈ R+ and mj ∈ M s.t. mj = d ⊕ m, M, mj,i |= φ. By inductive hypothesis, M, mj, (i + δ) ◦ σ—1 |= φ +σ f−/f+, which implies M, m, (i+δ)◦σ—1 |= ∃ (φ+σ f−/f+). Hence M, m, (i+δ)◦σ—1 |= (∃ φ)+σ f−/f+.
[The case ∀x.φ]: M, m, i |= ∀x.φ implies for any t ∈ Q+, M, m, i[x '→ t] |= φ. By inductive hypothesis, M, mj, (i[x '→ t]+ δ[x '→ 0]) ◦ σ—1 |= φ +σ f−[x '→ 0]/f+[x '→ 0], which implies M, mj, ((i + δ) ◦σ—1)[x '→ t] |= φ +σ f−[x '→ 0]/f+[x '→ 0]. Then M, m, (i + δ) ◦ σ—1 |= ∀x.(φ +σ f−[x '→ 0]/f+[x '→ 0]). Hence M, m, (i + δ) ◦ σ—1 |= (∀x.φ) +σ f−/f+.
[The case ∃x.φ]: M, m, i |= ∃x.φ implies exists t ∈ Q+ s.t. M, m, i[x '→ t] |= φ. By inductive hypothesis, M, mj, (i[x '→ t]+ δ[x '→ 0]) ◦ σ—1 |= φ +σ f−[x '→ 0]/f+[x '→ 0]. So M, mj, ((i + δ) ◦ σ—1)[x '→ t] |= φ +σ f−[x '→ 0]/f+[x '→ 0]. Then M, m, (i + δ) ◦ σ—1 |=
∃x.(φ +σ f−[x '→ 0]/f+[x '→ 0]). Hence M, m, (i + δ) ◦ σ—1 |= (∃x.φ) +σ f−/f+.	 

Proof. [Proof of Corollary 5.3] (⇒): from Lemma 5.2. (⇐): Since i + f − f ≥ 0,
M, m, i + f |= φ + f implies M, m, i + f − f |= φ + f − f due to lemma 5.2.	 

Proof. [Proof of Corollary 5.4] Let f—, f+ : K → Q be such that f— ≤ δ ≤ f+ and
f—(x)= f+(x) = 0 for any x ∈ Kφ). Then, φ + f−/f+ = φ + — f+/— f− = φ. (⇒): derives from Lemma 5.2.
(⇐): Since i + δ − δ ≥ 0, M, m, i + δ |= φ implies M, m, i + δ − δ |= φ using Lemma
5.2.	 


Proof. [Proof of Theorem 5.5] (⇒): Induction on φ.
[The Case [a]φ]: M, m, i |= [a]φ implies for any mj ∈ M s.t. m −→a

mj, M, mj,i |= φ.

Since m ∼ n, so exists nj ∈ M s.t. n −→a
nj and mj ∼ nj. By inductive hypothesis,

M, mj,i |= φ implies M, nj,i |= φ. Hence M, m, i |= [a]φ implies M, n, i |= [a]φ. Similarly M, n, i |= [a]φ implies M, m, i |= [a]φ.

[The Case
∀∀ φ]: M, m, i |= [a]φ implies for any d ∈ R≥0 and mj ∈ M s.t.

mj = d ⊕ m, M, mj,i |= φ. Since m ∼ n, so exists nj ∈ M s.t. nj = d ⊕ n and mj ∼ nj. By inductive hypothesis, M, mj,i |= φ implies M, nj,i |= φ. Hence M, m, i |= ∀ φ implies M, n, i |= ∀ φ. Similarly M, n, i |= ∀ φ implies M, m, i |= ∀ φ.
[The Case ∀x.φ]: M, m, i |= ∀x.φ iff for any j = i[x '→ t] and t ∈ R≥0, M, m, j |= φ. By inductive hypothesis, M, m, j |= φ iff M, n, j |= φ. Hence M, m, i |= ∀x.φ iff M, n, i |= ∀x.φ.	 

Proof. [Proof of Lemma 6.3] First, the sets A = {r ∈ Q+ | x ≥ r ∈ Γ} and B = {r ∈ Q+ | x ≤ r ∈ Γ} are both non-empty: Axiom (A2) guarantees that for any r ∈ Q+, either x ≥ r ∈ Γ or x ≤ r ∈ Γ. Suppose that there exists r ∈ Q+ such that x ≥ r ∈ Γ. Then, A /= ∅. Suppose that B = ∅, then (A2) implies that for any r ∈ Q+, x ≥ r ∈ Γ. Using (R3) for C[X]= X, we derive that ⊥∈ Γ - contradiction. Consequently, B /= ∅. Similarly can be proven that B /= ∅ implies A /= ∅.
Since the two sets are non-empty, the sup and inf exist. Suppose that sup A = ∞. Then applying (A3) we obtain that Q+ ⊆ A and (R2) for C[X] = X proves the inconsistency of Γ - contradiction. Similarly one can prove that inf B ∈ R+.
Let sup A = u and inf B = v. We prove u = v. If u < v, there exists r ∈ Q+ such that u < r < v. Since u < r, x ≥ r /∈ Γ and (A2) guarantees that x ≤ r ∈ Γ. But this contradicts the fact that r ≤ v. If v < u, there exists r1, r2 ∈ Q+ such that v < r1 < r2 < u. Since r1 > v, x ≤ ri ∈ Γ for i = 1, 2 (applying (A3)), and similarly, ri < u implies x ≥ ri ∈ Γ for i = 1, 2. Since r2 − r1 > 0, we apply (A3) and obtain ▶ x ≥ r2 → ¬(x ≤ r1). This shows that Γ is inconsistent - contradiction.
Consequently, u = v.	 

Proof. [Proof of Lemma 6.7] We prove the lemma by the following three steps:
I. Firstly, observe that C ⊆ Ω is coherent iff for any Λ1, Λ2 ∈ C, with i1 =
I (Λ1), i2 = I (Λ2),
Λ1 ☒ (i2 − i1) ⊆ Λ2 and Λ2 ☒ (i1 − i2) ⊆ Λ1,
Moreover, Λ1 ☒ (i2 − i1) ⊆ Λ2 iff Λ2 ☒ (i1 − i2) ⊆ Λ1. We prove it as follows: Suppose Λ1 ☒ (i2 − i1) ⊆ Λ2 but Λ2 ☒ (i1 − i2) /⊆ Λ1, i.e., there exist ψ ∈ Λ2 and f—, f+ : I(K) → Q s.t. f— < i1 − i2 < f+ and ψ + f−/f+ /∈ Λ1. Since Λ1 is maximal, ¬(ψ + f−/f+) ∈ Λ1. So ¬ψ + f+/f− ∈ Λ1. Since −f+ < i2 − i1 < −f—, we have (¬ψ + f+/f−)+ — f+/— f− ∈ Λ2. Then ¬ψ ∈ Λ2 - contradiction! Hence Λ2 ☒ (i1 − i2) ⊆ Λ1.
Similarly for the other direction.
III. We prove that if i = I (Λ) and ij ∈  (K), then there exists Λj ∈ Ω s.t. I (Λj)= ij and {Λ, Λj} is coherent. To prove this, we firstly prove the following two properties:

For arbitrary φ ∈ Λ, and f—, f+ : K → Q s.t. for any x ∈ K(φ), either
f—(x)= f+(x)=0 or f—(x) < (ij − i)(x) < f+(x). Then,
▶ (φ + f−/f+ )+ — f−/— f+ → φ.
For any x Œ r ∈ L,
{(x Œ r)+ f−/f+ | f—, f+ : K → Q, f— < 0 < f+}▶ x Œ r.

[Proof of (a)]: Induction on φ.
[The Case x ≥ r]:
If f—(x)= f+(x) = 0, then obviously
((x ≥ r)+ f−/f+ )+ — f−/— f+ = x ≥ r.


(x ≥ r)+ f



−/f+
= ⎧⎨ x ≥ (r + f—(x)), r + f—(x) ≥ 0
⎩ x ≥ 0,	otherwise

If r + f—(x) ≥ 0:
((x ≥ r)+ f−/f+)+ — f−/— f+ = (x ≥ (r + f—(x))) + — f−/— f+ = x ≥ r;
If r + f—(x) < 0, −f—(x) ≥ 0:
((x ≥ r)+ f−/f+)+ — f−/— f+ = (x ≥ 0) + — f−/— f+ = x ≥ −f—(x).
r + f—(x) < 0 implies −f—(x) > r, which further implies x ≥ r;
(ii). If r + f—(x) < 0, −f—(x) < 0:
then r < 0 – contradiction!
So ▶ ((x ≥ r)+ f−/f+ )+ — f−/— f+ → (x ≥ r).
[The Case x ≤ r]: If f—(x)= f+(x) = 0, then obviously
((x ≤ r)+ f−/f+ )+ — f−/— f+ = x ≤ r.
Otherwise,
x ≤ r ∈ Λ implies r ≥ i(x). And since f+(x) ≥ (ij − i)(x), we have that f+(x)+ r ≥
ij(x) ≥ 0.
So (x ≤ r)+ f−/f+ = x ≤ (r + f+(x)).
Then ((x ≤ r)+ f−/f+ )+ — f−/— f+ = x ≤ r. So ▶ ((x ≤ r)+ f−/f+ )+ — f−/— f+ → (x ≤ r).
[The Case x > r and x < r]: similar as the above two.
[The Case φ ∧ ψ and φ ∨ ψ]: Obviously.
[The Case [a]φ]: (([a]φ)+ f−/f+ )+ — f−/— f+ = [a]((φ + f−/f+ )+ — f−/— f+). By inductive hypothesis: ▶ (φ + f−/f+ )+ — f−/— f+ → φ. By (R1) and (A5) ▶ [a]((φ + f−/f+ )+ — f−/— f+) → [a]φ.
Hence ▶ (([a]φ)+ f−/f+ )+ — f−/— f+ → [a]φ.
[The Case ⟨a⟩φ]: ((⟨a⟩φ)+ f−/f+ )+ — f−/— f+ = ⟨a⟩((φ + f−/f+ )+ — f−/— f+). By inductive hypothesis: ▶ (φ + f−/f+ )+ — f−/— f+ → φ. So ▶ ¬φ → ¬((φ + f−/f+ )+ 
— f−/— f+). By (R1) and (A5), ▶ [a]¬φ → [a]¬((φ + f−/f+ )+ — f−/— f+). Then
▶ ⟨a⟩((φ + f−/f+ )+ — f−/— f+) → ⟨a⟩φ. Hence ▶ ((⟨φ⟩)+ f−/f+ )+ — f−/— f+ → ⟨a⟩φ.
[The Case ∀∀ φ]: (( ∀ φ)+ f−/f+ )+ — f−/— f+ = ∀ ((φ + f−/f+ )+ — f−/— f+).
By inductive hypothesis: ▶ (φ + f−/f+ )+ — f−/— f+ → φ. By (R2) and (A7) ▶
∀ ((φ + f−/f+ )+ — f−/— f+) → ∀ φ.
Hence ▶ (( ∀ φ)+ f−/f+ )+ — f−/— f+ → ∀ φ.
[The Case ∃∃φ]: (( ∃ φ)+ f−/f+ )+ — f−/— f+ = ∃ ((φ + f−/f+ )+ — f−/— f+). By

inductive hypothesis: ▶ (φ + f−/f+ )+ — f−/— f+ → φ. So ▶ ¬φ → ¬((φ + f−/f+ )+ 

— f−/— f+).  By (R2) and (A7) ▶
∀∀ ¬φ →
∀∀ ¬((φ + f−/f+ )+ — f−/— f+). Then

▶ ∃ ((φ + f−/f+ )+ — f−/— f+) → ∃ φ.
Hence ▶ (( ∃ φ)+ f−/f+ )+ — f−/— f+ → ∃ φ.
[The Case ∀x.φ]:
((∀x.φ)+ f−/f+ )+ — f−/— f+ =
∀x.((φ + f−[x '→ 0]/f+ [x '→ 0])+ (—f−)[x '→ 0]/(—f+ )[x '→ 0]). By inductive hypothesis: ▶
(φf−[x '→ 0]/f+ [x '→ 0])+ (—f−)[x '→ 0]/(—f+ )[x '→ 0] → φ.
By (R3), (R6) and (A13) ▶ ∀x.((φ + f−[x '→ 0]/f+ [x '→ 0])+ (—f−)[x '→ 0]/(—f+ )[x '→ 0]) →
∀x.φ.
Hence ▶ ((∀x.φ)+ f−/f+ )+ — f−/— f+ → ∀x.φ.
[The Case ∃x.φ]:
((∃x.φ)+ f−/f+ )+ — f−/— f+ =
∃x.((φ + f−[x '→ 0]/f+ [x '→ 0])+ (—f−)[x '→ 0]/(—f+ )[x '→ 0]).
By inductive hypothesis: ▶ (φ + f−[x '→ 0]/f+ [x '→ 0])+ (—f−)[x '→ 0]/(—f+ )[x '→ 0] → φ.
So ▶ ¬φ → ¬((φ + f−[x '→ 0]/f+ [x '→ 0])+ (—f−)[x '→ 0]/(—f+ )[x '→ 0]). By (R3), (R6) and
(A13), we have ▶ ∀x.(¬φ) → ∀x.¬((φf−[x '→ 0]/f+ [x '→ 0])+ (—f−)[x '→ 0]/(—f+ )[x '→ 0]). Then ▶ ∃x.((φ + f−/f+ )+ — f−/— f+) → ∃x.φ.
Hence ▶ ((∃x.φ)+ f−/f+ )+ — f−/— f+ → ∃x.φ.
[Proof of (b)]: [The Case x ≥ r]:


(x ≥ r)+ f



−/f+
= ⎧⎨ x ≥ (r + f—(x)), r + f—(x) ≥ 0
⎩ x ≥ 0,	otherwise

For any r + f—(x) ≥ 0, we have x ≥ (r + f—(x)). Since f—(x) < 0, we have exists
s ∈ Q s.t. s = r + f—(x) < r and x ≥ s. By rule (R2), x ≥ r.
So {(x ≥ r)+ f−/f+ | for any f—, f+ : K → Q s.t. for any
x ∈ K, f—(x) < 0 < f+(x)}▶ (x ≥ r).
[The Case x ≤ r]:


(x ≤ r)+ f



−/f+
= ⎧⎨ x ≤ (r + f+(x)), r + f+(x) ≥ 0
⎩ x ≥ 0,	otherwise

For any r + f+(x) ≥ 0, we have x ≤ (r + f+(x)). Since f+(x) > 0, we have exists
s ∈ Q s.t. s = r + f+(x) > r, x ≤ s. By rule (R2), x ≤ r. So {(x ≤ r)+ f−/f+ | for any f—, f+ : K → Q s.t. for any x ∈ K, f—(x) < 0 < f+(x)}▶ (x ≤ r).
[The Case x > r and x < r]: similar as the above two.
Now we are ready to prove that there exists Λj ∈ Ω s.t. I (Λj)= ij and Λ+(ij −i) ⊆
Λj.
Suppose not, i.e., for any Λj ∈ Ω, either A /⊆ Λj or A ⊆ Λj but I (Λj) /= ij, where
A =Λ ☒ (ij − i).
* Suppose A /⊆ Λj, i.e., A ▶ ⊥ (otherwise by applying Rasiowa-Sikorski Lemma as we discussed in II, there exists one maximal consistent set that includes it). Let B = {φ + — f−/— f+ | φ ∈ A}, where f— < ij − i < f+. Then B ▶ ⊥. For any φ ∈ Λ, φ + f−/f+ + — f−/— f+ ∈ B. By property (a), φ ∈ B. So Λ ⊆ B. Since Λ is maximal,

Λ= B. So Λ ▶⊥ - contradiction!
* Suppose A ⊆ Λj but I (Λj) /= ij.
First we prove x Œ r /∈ A implies ¬(x Œ r) ∈ A for any x ∈ K and r ∈ Q+ as follows: x Œ r /∈ A implies (x Œ r)+ — f−/— f+ /∈ Λ for any f— < ij − i < f+. So
¬((xŒr)+ — f−/— f+) ∈ Λ since Λ is maximal, which implies ¬(xŒr)+ — f+/— f− ∈ Λ.

— f+
f'	'
j	j	j

Then (¬(x Œ r)+ 
/— f−)+ −/f+ ∈ A for any f— < i − i < f+. So ¬(x Œ r)+ 

f' — f+  '	j	j
−	/f+ — f− ∈ A, where f— − f+ < 0 < f+ − f—. By property (b), ¬(x Œ r) ∈ A.
That is to say that A is maximal of all the time inequalities x Œ r.
Then for all r ≥ i(x) ≥ 0, suppose x > r ∈ Λj. So x > r ∈ A by the above result. Then x > r − f—(x) ∈ Λ, which implies r − f—(x) ≤ i(x). Hence r ≤ i(x)+ f—(x) < ij(x) - contradiction! So x ≤ r ∈ Λj.
For all 0 < r ≤ i(x), suppose x < r ∈ Λj. Then x < r ∈ A by the above result. Then x < r − f+(x) ∈ Λ, which implies r − f+(x) ≥ i(x). Then r ≥ i(x)+ f+(x) > i(x)- contradiction! So x ≥ r ∈ Λj.
If r = 0, apparently x ≥ 0 ∈ Λj.
So I (Λj)= ij - contradiction!	 

Proof. [Proof of Theorem 6.8] We need to prove that ⊕ is well-defined and satisfies the required conditions 1 and 2 in Definition 3.1. That is to prove the following three conditions:
⊕ is a well-defined partial function: R≥0 ×Γ → Γ, i.e. if γ1 = d⊕γ and γ2 = d⊕γ, then γ1 = γ2.
For any ∀i ∈ I(K), φ ∈ γ1(i) implies x = [d|∧φ ∈ γ1(i[x '→ [d|]), where x ∈ K\K(φ) is a new clock different from those in φ. It implies that ∀ (x = [d|→ φ) ∈ γ(i[x '→ [d|] − d) because γ1 = d ⊕ γ and axiom (A10). So x = [d| → φ ∈ γ2(i[x '→ [d|]) because γ2 = d ⊕ γ. Then φ ∈ γ2(i[x '→ [d|]), which implies φ ∈ γ2(i) since x ∈ K\K(φ).
Hence for any i ∈ I(K), γ1(i) ⊆ γ2(i). Similarly γ2 ⊆ γ2(i). Then for any i ∈ I(K),
γ1(i)= γ2(i). Hence γ1 = γ2.
For any γ ∈ Γ, 0 ⊕ γ = γ, i.e. for any i ∈ I(K), ∀ φ ∈ γ implies φ ∈ γ. It is obviously true by (A9).

d ⊕ (dj ⊕ m) =~ (d + dj) ⊕ m, i.e. ∃γ ,γ 
s.t. γ
= dj ⊕ γ, γ
= d ⊕ γ
iff ∃γ
s.t.

γ3 = (d + dj) ⊕ γ.
1	2	1
2	1	3

(⇒): suppose ∃γ1, γ2 s.t. γ1 = d ⊕ γ, γ2 = dj ⊕ γ1. Then for any i ∈  (K), for any
∀ φ ∈ γ(i) implies ∀ ∀ φ ∈ γ(i) by (A8). So ∀ φ ∈ γ1(i + d) because γ1 = d ⊕ γ, which further implies φ ∈ γ2(i + d + dj) because γ2 = dj ⊕ γ1. Hence ∃γ3 = γ2 s.t. γ3 = (d + dj) ⊕ γ.
(⇐): suppose ∃γ3 s.t. γ3 = (d + dj) ⊕ γ.
First, we prove: if γ3 = (d + dj) ⊕ γ then ∃γ1 s.t. γ1 = dj ⊕ γ.

For any i ∈ I(K), let λi = {φ | ∀ φ ∈ γ(i)}, Δi =	x∈K{x Œ r | i(x) Œ r, r ∈ Q+}
and Θi+d′ = {φ | λi ∪ Δi+d′ ▶ φ}. We construct γ1 according to the following steps:
We prove Θi+d′ is consistent.
We only need to show that λi ∪ Δi+d′ is consistent. Suppose not, i.e. λi ∪ Δi+d′ ▶ ⊥. Since both λi and Δi+d′ are consistent, exists ρ ∈L s.t. λi ▶ ¬ρ and Δi+d′ ▶ ρ.
λi ▶ ¬ρ implies ∀ λi ▶ ∀∀¬ρ by rule (R2) or (R4), which further implies ∀∀¬ρ ∈ γ(i). Δi+d′ ▶ ρ implies ρ ∈ γj(i + dj) for any γj ∈ Γ.
Let δ = (i + dj)[K(ρ) '→ [dj|] − (i + dj), f—, f+ : K → Q defined as:


f—(x)= 
⎧⎨ [dj|− rx, x ∈ K(ρ)
⎩ 0,	otherwise

f=(x)= 
⎧⎨ [dj|− sx, x ∈ K(ρ)
⎩ 0,	otherwise

where rx  = max{r  |  x  ≥  r in ρ with ¬ on atoms}, sx  = min{s  |  x  ≤
s in ρ with ¬ on atoms}.
Then ρ + f−/f+ ∈ γj((i + dj)[K(ρ) '→ [dj|]), which implies ρ + f−/f+ ∈ γj(ij[K(ρ) '→ [dj|]) for any ij ∈ I(K). Then	(x = [dj|) → ρ + f−/	∈ γj(ij) for any γj and
ij. By rule (R2) ∀ (Vx∈K(ρ) (x = [dj|) → ρ + f−/f+ ) ∈ γj(ij).
x ≤ [dj| ∈ γ(i[K(ρ) '→ [dj|− dj]) for any x ∈ K(ρ). Then	(x ≤ [dj|) ∈
γ(i[K(ρ) '→ [dj| − dj]).  And similarly	(x ≥ [dj|) ∈ γ(i[K(ρ) '→ [dj| − 
dj]+ (d + dj)), which implies ∃ (	(x ≥ [dj|)) ∈ γ(i[K(ρ) '→ [dj|− dj]). So
 x ∈K(ρ)(x ≤ [dj|) ∧ ∃∃( x∈K(ρ)(x ≥ [dj|)) ∈ γ(i[K(ρ) '→ [dj|−dj]). By axiom (A11)

Together with ∀ ( x∈K(ρ) (x = [dj|) → ρ + f−/f+ ) ∈ γ(i[K(ρ) '→ [dj|]), we get
∃ (ρ + f−/f+ ) ∈ γ(i[K(ρ) '→ [dj|]) by axiom (A10).
So ∃ ρ ∈ γ(i) - contradict that ∀∀ ¬ρ ∈ γ(i). Hence λi ∪ Δi+d′ is consistent, which implies Θi+d′ is consistent.
Extend to maximal consistent set Λi for each i ∈ I.
If there exists x ∈ K s.t. i(x) ≥ dj and i(x) ∈ Q+, Θi is maximal, i.e. for any
φ ∈ L, φ /∈ Θi implies ¬φ ∈ Θi.
By definition of Δi, x = i(x) ∈ Δi ⊆ Θi. Together with φ /∈ Θi, x = i(x) → φ /∈ Θi. By definition of λi—d′ , ∀ (x = i(x) → φ) ∈ γ(i − dj) implies x = i(x) → φ ∈ λi—d′ ⊆ Θi. So ∀ (x = i(x) → φ) /∈ γ(i − dj). Since γ(i − dj) is maximal and
¬( ∃ (x = i(x) ∧ ¬φ)) = ∀ (x = i(x) → φ), we have ∀ (x = i(x) → φ) /∈ γ(i − dj) implies ∃ (x = i(x) ∧ ¬φ) ∈ γ(i − dj). By (A10) ∀ (x = i(x) → ¬φ) ∈ γ(i − dj). So x = i(x) → ¬φ ∈ λi—d′ ⊆ Θi by the definition of λi—d′ . Then we have ¬φ ∈ Θi.
So Λi = Θi, if there exists x ∈K s.t. i(x) ≥ dj and i(x) ∈ Q+.
If for all x ∈ K, i(x) ≥ dj and i(x) ∈ R≥0 but /∈ Q+, define the following function, which given an interpretationi and finite set of clocks Kf , maps to another interpretation:

iKf = ⎧⎨ i(x) x ∈ Kf
[dj|  otherwise
Then we define Λi = Kf @K{φ | K(φ)= Kf , φ ∈ ΠiKf }.
Now we prove that Λi above is maximal consistent.
Obviously for any x ∈ Kf and any finite Kf ⊂ K, iKf (x) − dj ≥ 0. And according to the first case, ΛiKf is maximal consistent. So Λi is maximal.
Suppose Λi is not consistent, i.e. Λi ▶ ⊥. Suppose Ψ ⊆ Λi s.t. Ψ ▶ ⊥, and K(Ψ) is the set of clocks of Ψ. Since even in the infinitary rules, the number of the clocks is finite, K(Ψ) is finite. For any ψ ∈ Ψ, ψ ∈ ΛiK(ψ) by the definition of Λi.
By the first case, ΛiK(ψ) = ΘiV(ψ) , so λiK(ψ)−d′ ∪ ΔiK(ψ) ▶ ψ. Suppose Ψj ⊆ λiK(ψ)−d′ ∪
ΔiK(ψ) s.t.  Ψj ▶ ψ.  Ψj{y /y} ▶ ψ for any y ∈ K(Ψ)\K(ψ), yj /∈ K(Ψ).  Since
'
Ψj{y'/y} has no clocks in K(Ψ)\K(ψ), and iK(Ψ) and iK(ψ) only differ for the clocks in K(Ψ)\K(ψ), it is easy to have Ψj{y'/y} ∈ λiK(Ψ)−d′ ∪ ΔiK(Ψ) . Then ψ ∈ ΘiK(Ψ) . Hence Ψ ⊆ ΘiK(Ψ) , which implies ΘiK(Ψ) ▶⊥ - contradiction.
If for all x ∈ K, i(x) < dj. Λi = {φ | φ + [dj|∈ Λi+[d′|}.
Obviously Λi is a consistent set since Λi+[d′| is consistent. Now we prove Λi is also maximal. Suppose φ /∈ Λi, so φ + [dj| /∈ Λi+[d′|, which implies ¬(φ + [dj|) ∈ Λi+[d′| since Λi+[d′| is maximal. Then we have ¬φ ∈ Λi. So Λi is maximal.
Let γ1(i)= Λi.
We prove that γ1 is a coherent function, i.e., γ1 satisfies the two conditions in Definition 6.4. The first condition holds obviously.
Before we prove γ1 satisfies the second condition, we first prove the following:
For any δ : K → R s.t. ∀x ∈ K, i(x) ≥ dj, i(x)+ δ(x) ≥ dj, and any f—, f+ :
K → Q s.t. f— < δ < f+, we have: φ ∈ Θi ⇒ φ + f−/f+ ∈ Θi+δ.
φ ∈ Θi implies λi—d′ ∪ Δi ▶ φ. Because γ is interpretation coherent, so λi—d′ ☒ δ ⊆ λ(i+δ)—d′ . Δi ☒ δ ⊆ Δi+δ by the definition of Δi. So we have λ(i+δ)—d′ ∪ Δi+δ ▶ φ + f−/f+. Hence φ ∈ Θi ⇒ φ + f−/f+ ∈ Θi+δ.
For any δ : K → R s.t. ∀x ∈ K, i(x) ≥ dj, i(x)+ δ(x) ≥ dj, and any f—, f+ :
K → Q s.t. f— < δ < f+, we have: φ ∈ Λi ⇒ φ + f−/f+ ∈ Λi+δ.
If Λi = Θi, it’s the (a) case.
If not, φ ∈ ΛiK(φ) = ΘiV(φ) . i(x)+ δ(x) ≥ 0 implies iK(φ)(x)+ δK(φ)(x) ≥ 0, so by the first case, φ + f−/f+ ∈ ΘiK(φ)+δK(φ) .
(iK(φ) + δK(φ))(x) = iK(φ)(x)+ δK(φ)(x) = iK(φ+f−/f+ )(x)+ δK(φ+f−/f+ )(x) (because
K(φ)= K(φ + f−/f+ )) = (i + δ)K(φ+f−/f+ )(x).

So we have φ + f−/f+ ∈ Θ(i+δ)K(φ+f−/f+ ) . Hence φ ∈ Λi ⇒ φ + f−/f+ ∈ Λi+δ.
Now we are ready to prove the second condition: for any δ : K → R s.t. i + δ ≥ 0, we have γ(i) ☒ δ ⊆ γ(i + δ), i.e., for any f—, f+ : K → Q s.t. f— < δ < f+, we have: φ ∈ γ(i) ⇒ φ + f−/f+ ∈ γ(i + δ).
If i ≥ dj and i + δ ≥ dj, it’s the (b) case above.
If i /≥ dj and i + δ ≥ dj:
φ + [dj| ∈ γ1(i + [dj|) by the definition of γ1. Let ij = i + [dj|, δj = δ − [dj|,

′	j	′	j
j	j j	j	j

f— = f— − [d | and f+ = f+ − [d |. Then we have i
≥ d ,i + δ = i + δ ≥ d . So

j	f'	'	j	j	f−

we have (φ + [d |)+ −/f+ ∈ γ1(i + δ ), which implies φ +
If i ≥ dj and i + δ /≥ dj:
Then φ + f− + [d'|/f + [d'| ∈ γ (i + δ + [dj|). Induction on φ:
[The case x ≥ r]:
/f+ ∈ γ(i + δ).


(x ≥ r)+ f−/f+ + [dj| =
⎧⎨ x ≥ r + f—(x)+ [dj|,  if r + f—(x) ≥ 0
⎩ x ≥ [dj|,	otherwise

So (x ≥ r)+ f−/f+ + [dj|∈ γ1(i + δ + dj).
[The case x > r]: similar as above.
[The case x ≤ r]:


(x ≤ r)+ f−/f+ + [dj| =
⎧⎨ x ≤ r + f+(x)+ [dj|,  if r + f+(x) ≥ 0
⎩ x ≤ [dj|,	otherwise

So (x ≤ r)+ f−/f+ + [dj|∈ γ1(i + δ + dj).
[The case x < r]: similar as above. Other cases hold obviously.
So we have φ + f−/f+ ∈ γ1(i + δ).
If i /≥ dj and i + δ /≥ dj:
φ ∈ γ1(i) implies φ + [dj|∈ γ1(i + [dj|). Then (φ + [dj|)+ f−/f+ ∈ γ1(i + [dj| + δ). So φ + f− + [d'|/f+ + [d'| ∈ γ1(i + [dj| + δ). Then we can do the same deduction as the above case.
So we proved that there exists γ1 constructed as above, s.t. γ1 = dj ⊕ γ.
- Now we prove that: ∃γ2 s.t. γ2 = d ⊕ γ1.
In the following we prove that γ3 = d ⊕ γ1, i.e. for any i ∈ I(K), ∀ φ ∈ γ1(i) implies
φ ∈ γ3(i + d).

Secondly we need to prove that exists γ2 s.t. γ2 = d⊕γ1. We prove that γ3 = d⊕γ1,
i.e. for any i ∈ I(K), for any ∀ φ ∈ γ1(i) implies φ ∈ γ3(i + d).
For any i ∈ I(K), ∀ φ ∈ γ1(i) implies x ≤ r ∧ ∀ φ ∈ γ1(i) for r ∈ Q+ s.t. i(x) ≤ r ≤ i(x)+ d. Then x ≤ r + [dj|∧ ∀ (φ + [dj|) ∈ γ1(i + [dj|). Since γ1 = dj ⊕γ, we get ∃ (x ≤ r + [dj|∧ ∀ (φ + [dj|)) ∈ γ(i + [dj|− dj). By (A9), ∀ (x ≥ r + [dj|→ 
∀ (φ + [dj|)) ∈ γ(i + [dj|−dj). So x ≥ r + [dj|→ ∀ (φ + [dj|) ∈ γ3(i + [dj| + d) since γ3 = (d + dj) ⊕ γ. And r ≤ i(x)+ d, which implies x ≥ r + [dj| ∈ γ3(i + [dj| + d). Then ∀ (φ + [dj|) ∈ γ3(i + [dj| + d). Hence ∀ φ ∈ γ3(i + d).
So there exists γ2 = γ3 s.t. γ2 = d ⊕ γ1.
Hence W = (Γ, θ, ⊕) defined above is a timed labeled transition system.	 
