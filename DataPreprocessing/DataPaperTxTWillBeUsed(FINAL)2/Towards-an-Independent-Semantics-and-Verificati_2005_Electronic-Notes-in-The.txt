Electronic Notes in Theoretical Computer Science 135 (2005) 59–77  
www.elsevier.com/locate/entcs


Towards an Independent Semantics and Verification Technology for the HLPSL Specification Language
Alexey Gotsman 1	Fabio Massacci 1	Marco Pistore 1
Dip. Informatica e Telecom.
Universit`a di Trento Trento, Italy

Abstract
We present an algorithm for the translation of security protocol specifications in the HLPSL lan- guage developed in the framework of the AVISPA project to a dialect of the applied pi calculus. This algorithm provides us with two interesting scientific contributions: at first, it provides an in- dependent semantics of the HLPSL specification language and, second, makes it possible to verify protocols specified in HLPSL with the applied pi calculus-based ProVerif tool. Our technique has been implemented and tested on various security protocols. The translation can handle a large part of the protocols modelled in HLPSL.
Keywords: Security protocols, verification, specification languages, process algebras


Introduction
The last decades have seen a major interest in the verification of security protocols. In almost every theoretical computer science conference there are papers on (un)decidability results and automated reasoning and security con- ferences show a steady stream of papers on applying this or that verification technology to this or that security protocol.
This steady stream of results has been matched by an equally tumultuous and unruly family of languages for protocol specification. These proposals

1 Email: {gotsman, massacci, pistore}@dit.unitn.it



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.06.004


have essentially flowed from a shared concern [2]:
... the formal verification of security protocols became the subject of intense research in the last decade. . .
However, it became apparent that the formalization process itself was a serious bottleneck in the design process. At first, formalizing a protocol was hardly doable by somebody different from the proposer of the formal method itself. Second, the ambiguity of the goals of the protocol made it possible to find “attacks” with formal methods that security analysts will never regard as such [... ]. Indeed, a security analyst can easily define a “security violation” in terms of sent, received and missing messages, while the language gap between him and the formal method makes it difficult for him to formally and exactly capture what is needed.
So the aim of specification languages was essentially to close the gap be- tween the informal languages in which protocols are specified in security re- search papers and standard bodies and the formal languages used by experts in formal verification. Among the uncountable number of specification languages proposed in the literature, we cite ALSP [2], BRUTUS [11], CAPSL and its variants [8,9] or its intermediate format CIL [12], CASPER [19], CVS [14], HLPSL [10], NAPTRL [21], the applied pi calculus-based specification lan- guages including ProVerif [6] just to name a few proposals based on different target verification technologies.
Looking retrospectively at these specification languages, it is fair to say that they seldom enjoyed a wide diffusion beyond the proposers or their close scientific collaborators. At first one may think that this was due to the differ- ent expressive power of the various languages. However, this would only be justified for general programming languages. Instead, here we have many dif- ferent languages for the same specialized application domain and, moreover, for almost the same identical set of protocols. We argue that the major reason behind the lack of diffusion of many speciﬁcation languages was the lack of an independently motivated and documented semantics. Loosely speaking, the only available translation was the (not-so-well-documented) translation into the authors’ own favorite formal method. In some cases (e. g. CASPER), the protocol description required the direct knowledge and input of construct from the authors’ target method. The consequence was that using a different method as a target would be fairly difficult.
The High Level Protocol Specification Language (HLPSL) developed in the framework of the AVISPA project 2 is somehow of an exception. Indeed, while it maintains the customary translation from the protocol description language

2 http://www.avispa-project.org


to the proposers’ “proprietary” format (the IF language), it has a first draft of an independently motivated semantics, namely based on Lamport’s temporal logic of actions [18].
The HLPSL language is the input language of the AVISPA tool. In more detail, the AVISPA tool takes as input an HLPSL specification, translates it to IF and analyzes the result by invoking state-of-the-art back-ends, which return attacks (if any) to the user. Since different tools are suited for solving different problems, it is relevant to integrate HLPSL with other tools for verification of security protocols. So far the available back-ends of the AVISPA tool have been based on three different technologies that cover a large share of the research arena in security protocol verification:
bounded model checking and satisfiability [3];
on-the-fly model checking [5];
term rewriting [17];
abstraction-based verification [7].
Letting aside static verification technologies, the major absence in this list is an approach based on a process algebra.
In this paper we propose a way to translate specifications in a subset of HLPSL to the dialect of the applied pi calculus that is supported by the ProVerif tool [6]. This makes it possible to verify secrecy, weak authentica- tion, and strong authentication properties of HLPSL specifications by invoking ProVerif on the result of the translation. It completes the number of available formalisms and technologies available for HLPSL.
It has a further advantages: building on the available draft TLA specifi- cations we provide an independent semantics based on the applied pi-calculus translation of HLPSL. This independent semantics can be used also to clarify a number of ambiguities in the original draft specifications. Indeed, our trans- lation work, done with the support of the University of Genova’s members of the AVISPA project, has pointed out a number of semantical issues in the specification and an error in the initial draft semantics for the freshness of nonces.
Our translation is directly based on the source HLPSL language and the TLA semantics rather than the “proprietary” IF language because some at- tacks can be lost while translating to the IF language. This approach makes it possible to independently check for semantical bugs in the specifications of HLPSL as well as in the translation from HLPSL to IF: protocol attacks must be reflected both in the original AVISPA tools and in our proposed combined verification technology.
The paper is organized as follows. Section 2 introduces the subset of

role B(F) played by pl def=	role P (F) def= init Init	const C
local L	composition
accept Acc	R1(A1) ∧ ... ∧ Rn(An)
transition	end role
lb1. ev1 =|> act1 lb2. ev2 =|> act2
... 
lbn. evn =|> actn
end role
Fig. 1. Generic structure of HLPSL roles
HLPSL that we use. In section 3 we describe the dialect of the applied pi calculus to which the translation is performed. Section 4 describes the al- gorithm of the translation. Section 5 explains how ProVerif can be used to verify the outcome of the translation while section 6 gives some details of the implementation and the experimental results on a selection of cryptographic protocols that were modelled in HLPSL in the framework of the AVISPA project.

The HLPSL Language
In this section we briefly describe the subset of HLPSL that is handled by our translation algorithm. We refer the reader to [10] for a fuller description of the language.
Protocol specifications in HLPSL are divided into roles. Some roles (the so-called basic roles) serve to describe the actions of one single agent in a run of the protocol or subprotocol. Others (composed roles) instantiate basic roles to model an entire protocol run, a session of the protocol between multiple agents, or the protocol model itself. This latter role is called the main role.
Figure 1 shows the structure of a basic role (denoted with B) and of a composed role (denoted with P ) in HLPSL. F is the set of formal arguments, L is the set of local variables, pl is the agent playing B. We require that F ∩ L = ∅.
In HLPSL, both variables and constants are typed. We will use the fol- lowing types: agent, channel, public key, text, nat, bool, symmetric key, message, function, protocol id. Certain types (text and channel) may have attributes enclosed within parentheses. For example, text(fresh) rep- resents the type of freshly generated nonces and channel(dy) the type of channels that correspond to Dolev-Yao (DY) intruder model [13]. In our


t ::=	HLPSL terms
V	variable
V '	new value of the variable V c	constant
t1.t2	concatenation of t1 and t2
{t1}t2	encryption of the message t1 by the key t2
f (t)	application of the function stored in the variable or constant f (of type function) to the term t
inv(t)	the private key corresponding to the public key t
Fig. 2. The syntax of HLPSL terms


subset of HLPSL we consider only DY-channels, so by default all channels implicitly have the dy attribute.
Terms in HLPSL are constructed as it is shown in figure 2. Here V ' is used to denote the value of the variable V after the execution of a transition, while V denotes the value of the variable before the execution. Besides, for a variable V with the fresh attribute V ' denotes a newly generated value for this variable. Note also that {t1}t2 is considered to be public-key encryption, if t2 is x or inv(x), where x is a variable or a constant of the type public key and shared-key encryption otherwise. In the former case t2 is called a public-key expression.
The init section assigns initial values to local variables and has the fol- lowing structure:

n
Δ
=
i=1

i = ci)

where Vi are variables, ci are constants. Let I be the set of variables assigned values in the init section. We require that I ⊆ L.
A transition is defined by a label lbi, a trigger event evi, and an action acti. Each transition is triggered whenever its guard event predicate is satisfied and fires immediately. In case when a few events are satisfied, one of the transitions corresponding to them is chosen non-deterministically and executed.
We require that each basic role have a local variable State of type nat
that intuitively represents the state of the participant of the protocol and that

evi and acti have the following form





Δ
act	State' = s
Δ
evi = State = s ∧ Comp ∧ RMsg

∧ SMsg ∧ Ass ∧ W itness ∧ W Request ∧ Request ∧ Secret

i =	1
(the order of conjuncts is not fixed, but the set of conjuncts is). We will also require that State ∈ I.
It is worth noting that the HLPSL specification does not make such a restriction on the form of transitions but we found this assumption extremely useful. The requirement that each role have its own state explicitly declared allows us to optimize the translation of HLPSL specifications and map back the results of the verification into the protocol domain. Furthermore, we found out that all publicly available HLPSL specifications are defined using the State variable in the way just said.
Let us now describe the parts of a transition.
Comp is a set of comparisons and is defined to be

Comp Δ  (t = m )
=	i	i
i=1
where ti and mi are HLPSL terms without primed variables.
RMsg and SMsg are the sets of receive actions and send actions respec- tively. They have the following form:

RMsg Δ  c (t )
=	i  i
i=1

SMsg Δ  d (m )
=	i	i
i=1
where ci and di are variables or constants of type channel, ti and mi are HLPSL terms.
Ass is the set of assignments of new values to variables and has the fol- lowing structure:
Ass Δ   (V ' = m )
=	i	i
i=1
where Vi are variables, mi are HLPSL terms.
W itness, W Request, Request, and Secret are conjunctions of expressions of the forms witness(a, b, p, m), wrequest(a, b, p, m), request(a, b, p, m), and secret(m, a) respectively.  These expressions are called goal facts and are


used to express correctness requirements. Intuitively, a goal fact is a pred- icate that becomes true at the moment he appears on the right-hand side of the transition being executed. Here a and b are variables or constants of the type agent, m is an HLPSL term and p is a protocol identifier – a con- stant of the type protocol id that is declared in the main role and is used to determine the correctness requirement that corresponds to the goal fact. Intuitively, witness(a, b, p, m) means that the agent a wants to execute the protocol with the agent b using m as the value for the authentication identifier
p. wrequest(a, b, p, m) or request(a, b, p, m) mean that the agent a accepts the value m and now relies on the guarantee that b exists and agrees with him on this value for the authentication identifier p. Whether to use wrequest or request depends on the type of correctness requirement being formulated (see section 5). We use wrequest when we verify weak authentication and request when we verify strong authentication. secret(m, a) means that the honest player of the role claims that the term m is a secret that the agent a is allowed to know.
The accept section has the form

Δ
Acc = State = sa
where sa is the state corresponding to the successful completion of the protocol in which the role is participating.
In composed roles we have no transition section. Rather, we have a section entitled composition that instantiates other roles Ri (with sets of arguments Ai) running in parallel. Besides, a composed role may define a set of constants C.
In addition, the main role must have declared a constant i of the type agent that represents the intruder. It may also have a declaration of the form knowledge(i) = K, which describes the initial knowledge of the intruder. Here K is a set of HLPSL terms.
Correctness requirements for the protocol, which are called goals, are given in their own section. Three types of goals are supported:
Secrecy of an HLPSL term m: secrecy of m. This means that m must not be known to the intruder.
Weak authentication: A weakly authenticates B on p. This means that whenever an agent b playing the role B executes wrequest(b, a, p, m), it is true that either a = i or a is an agent playing the role A and witness(a, b, p, m) has been executed previously. This corresponds to Lowe’s notion of non-injective agreement [20].
Strong authentication: A authenticates B on p. In comparison with the


t ::=	terms
x	variable
f (t1,... , tn)	constructor application

P ::=	processes
nil	deadlock
x!⟨t⟩.P	output
x?(y).P	input
if t1 = t2 then P else Q	comparison
if t1 /= t2 then P else Q	comparison
P1|P2	parallel composition
P1 + P2	choice
(νx)P	restriction
let x = g(t1,... , tn) in P else Q	destructor application
event e(t1,... , tn).P	event e
event ex e(t1,... , tn)	executed event e
Fig. 3. The syntax of the target language
previous goal this adds the requirement that each wrequest executed by an agent playing B correspond to unique witness executed by an agent playing A. This corresponds to Lowe’s notion of injective agreement [20].

The Target Applied Pi Calculus
As the target language of our translation we use a dialect of the applied pi calculus similar to the one presented in [1]. This dialect extends the classical pi calculus defining cryptographic primitives by reduction relations. Its syntax is reported in figure 3.
The variable x is bound in P in the processes x?(y).P , (νx)P , and
let x = g(t1,... , tn) in P else Q
We will use (νł), where ł = {x1,... , xn}, as syntactic sugar for (νx1) ... (νxn)


Tuples
Constructor: tuple, ntuple(t1,... , tn)
Destructors:  projections, ithn(ntuple(t1,... , tn)) → ti
Shared-key encryption
Constructor: encryption of t1 by the key t2, sencrypt(t1, t2) Destructor: decryption, sdecrypt(sencrypt(t1, t2), t2) → t1 Public-key encryption
Constructors: encryption of t1 by the public key t2, pencrypt(t1, t2) the private key, corresponding to the public key t, inv(t)
Destructor: decryption, pdecrypt(pencrypt(t1, t2), inv(t2)) → t1
One-way hash functions
Constructor: application of the function f to the term t, hashfun(f, t)
Fig. 4. Constructors and destructors
and let x = g(t1,... , tn) in P as syntactic sugar for
let x = g(t1,... , tn) in P else nil
The syntax assumes that a set of constructors, destructors, and events are defined. Constructors are used to build terms. Destructors are used in processes to manipulate terms. They are partial functions on terms that processes can apply. The process let x = g(t1,... , tn) in P else Q tries to evaluate g(t1,... , tn); if this succeeds, then x is bound to the result and P is executed, else Q is executed. Evaluation of g is defined by a set of reduction rules of the form g(t1,... , tn) → t.
We use destructors rather than equational theories of the applied pi cal- culus because this approach allows for more efficient verification and is used in the ProVerif tool with which the outcome of our translation is verified.
For purposes of our translation we define constructors and destructors for representing data structures and cryptographic primitives as it is shown in figure 4. We define let (x1,... , xn)= t in P as syntactic sugar for
let x1 = 1thn(t) in ... let xn = nthn(t) in P
Moreover, we will abbreviate ntuple(t1,... , tn) to (t1,... , tn).


(P |Q)|R ≡ P |(Q|R)	P |0 ≡ P
(νa1)(νa2)P ≡ (νa2)(νa1)P	!P ≡ P |!P
(P + Q)+ R ≡ P + (Q + R)	P +0 ≡ P
(νa)(P |Q) ≡ P |(νa)Q, if a is not free in P
Fig. 5. Structural congruence

a!⟨t⟩.Q|a?(x).P → Q|P {t/x}	P → Q ⇒ P |R → Q|R
P ' ≡ P, P → Q, Q ≡ Q' ⇒ P ' → Q'	P → Q ⇒ (νa)P → (νa)Q if t = t then P else Q → P	let x = t in P → P {t/x} if t1 = t2 then P else Q → Q, if t1 /= t2	P → Q ⇒ P + R → Q + R if t /= t then P else Q → Q
if t1 /= t2 then P else Q → P , if t1 /= t2
let x = g(t1,... , tn) in P else Q → P {t'/x} if g(t1,... , tn) → t'
let x = g(t1,... , tn) in P else Q → Q
if there exists no t' such that g(t1,... , tn) → t'
event e(t1,... , tn).P → event ex e(t1,... , tn)|P
Fig. 6. Reduction
Events are used in authentication goals. The constructs event ex are use- ful to remember what events were executed. We define three events (witness, wrequest, and request) with four arguments each, which correspond to HLPSL goal facts with the same names. In addition, we define event player(a, r) mean- ing that the agent a plays the role r. The roles of these events will become clear in the latter sections.
Formal semantics of the applied pi calculus is given in terms of structural congruence and reduction. The structural congruence for the applied pi cal- culus is the smallest congruence that satisfies the equations in figure 5. The axioms for the reduction are listed in figure 6. We also let inv(inv(t)) = t.

Translation algorithm
The translation of the composed roles in an HLPSL specification is done by flattening their structure starting from the main role. In this way we obtain

only instantiations of basic roles with constants as arguments.
Our translation of basic roles uses the State variable. A basic role is translated to a set of processes each acting as the role in a particular state.
There are two important details to note about the translation algorithm. First, since we are using DY intruder model, it is irrelevant from which channel we receive a message or to which channel we send it. Therefore, in the translation of receive and send actions we receive messages from and send messages to a predefined channel c, which is a free constant unknown to the
intruder.
Second, we will use the restriction operator of the pi calculus to model the generation of new values for variables with the fresh attribute.
Now we will describe the translation algorithm. We will denote the trans- lation of a fragment R of an HLPSL specification as R) and will use the notation for parts of an HLPSL specification introduced in section 2.
First of all we describe the translation of HLPSL terms. Their translation is defined according to their structure:

Δ	'  Δ	Δ	Δ
 V )
= V,  V ) = V,  c) = c,  t1. ... .tn) = ( t1),... , tn))
 {m}t) Δ ⎧⎨ pencrypt( m), t)), if t is a public-key expression;
⎩ sencrypt( m), t)), otherwise
Δ	Δ
 f (t)) = hashfun( f ), t)),  inv(t)) = inv( t))
The instantiations of the composed roles in an HLPSL specification form a tree with the main role as the root. To translate the composed roles we flatten this tree by repeatedly substituting the texts of composed roles for their instantiations and actual arguments for formal arguments, and using the parallel composition operator of the pi calculus to translate parallel composi- tions of role instantiations. Besides, we rename all the constants declared in the composed roles to avoid name clashes and declare them as free constants unknown to the intruder. In addition, for each basic role instantiation we in- troduce a constant representing an identifier for this instantiation. We add a formal argument SID to each basic role and assign the instantiation identifier to this argument in each instantiation. The instantiation identifier we be used while translating strong authentication goals.
Having done these preliminary steps, we can generate the translation of the main role (and all the composed roles) in the following way:
First, we generate the process that outputs the initial knowledge of the



intruder on the channel c:


where {t1,... , tk} = K.

c!⟨t1⟩	c!⟨tk⟩

Second, for each basic role R we introduce a free constant unknown to the intruder representing an identifier for this role. Since after flattening we obtain only the instantiations of basic roles with constants as arguments, we can determine (using played by declaration) for each basic role the set of agents playing the role. For each basic role identifier r and each agent a playing the role denoted with r we generate the processes of the form
event player(a, r)
and join them (as well as the process obtained on the previous step) with the . operator.
Finally, we output the result of flattening of the tree of composed roles using the let operator to assign values to formal arguments of basic roles.
A basic role B is translated to the following process:
Δ
B = (νL\I)(Bs0 {c1/V1,... , cn/Vn})
where s0 is the value given to the State variable in the init section, Vi are the variables initialized in the init section by ci.
For each of the values s of the State variable, assigned to it in the HLPSL text of the role we create a process Bs acting as the role in the state s. Let T r(s) be the set of all the transitions that have the conjunction State = s on their left-hand sides and let Nk be the set of fresh variables updated by the k-th transition (i. e. the set of those variables that have the fresh attribute and are primed on the right-hand side of the transition). Then

B Δ  Σ
 ev )(νN ) act )

s =	k	k	k
k∈Tr(s)
The translation of events and actions is defined as follows:
Δ
 State = s ∧ Comp ∧ RMsg) = Comp) RMsg)

Δ
 State = s1 ∧ SMsg ∧ Ass ∧ W itness ∧ W Request ∧ Secret) =
 W itness). Ass) SMsg). W Request). Request). Secret ∧ State = s1)
In addition, we define Bsa = nil where sa is the value of the State variable in the accept section.

Let us describe the translation of parts of a transition. The translation of Comp is the following:

Δ
 Comp) = if  t1) = m1) then ... if  tn) = mn) then
In our translation of receive actions we first receive messages to newly cre- ated variables (using the applied pi calculus primitives) and then match their structures against the ones given in the HLPSL specification. This latter part of the process is defined by the mapping M(·, ·), in which the first argument is the name to which the received term is bounded and the second argument is the HLPSL term describing its structure. I. e.
 RMsg) Δ c?(t∗). ... .c?(t∗ ).M(t∗,t ). ... .M(t∗ ,t )
=	1	n	1  1	n  n
If ti is a primed variable, then t∗ is this variable without the prime. Other- wise, it is a new variable that has not been used previously in the process of translation. M(·, ·) is defined according to the structure of HLPSL terms in the following way:



M(m, m	m
Δ
M(m, V ) = if m = V then
Δ
M(m, c) = if m = c then
Δ	m∗,... , m∗ )= m in M(m∗,m ) ... M(m∗ ,m )

1	n) = let (  1	n	1	1	n	n
Δ
M(m, {t}x) =
⎧ let t∗ = pdecrypt(m, inv(x)) in M(t∗, t), if x is a public-key expression;
let t∗ = sdecrypt(m, x) in M(t∗, t),	otherwise
m∗ and t∗ are defined as before (with respect to mi and t). Besides, M(m, V ') yields the empty formula and is discarded.
The translation of SMsg is defined as follows:

Δ
 SMsg) = c!⟨ m1)⟩	c!⟨ mn)⟩
We define the translation of Ass to be
Δ
 Ass) = let V1 = m1) in ... let Vn = mn) in
witness and wrequest goal facts are translated in the following way

Δ
 witness(a, b, p, m)) = event witness(a, b, p, m))

Δ
 wrequest(a, b, p, m)) = event wrequest(a, b, p, m))

A request goal fact has the following translation

Δ
 request(a, b, p, m)) =
c!sencrypt((a, b, p, m, SID), sidkey).event request(a, b, p, m)) Here sidkey is a free constant unknown to the intruder.
A conjunction G1 Λ ... Λ Gn of witness, wrequest, and request goal facts
Gi is translated to  G1). ... . Gn).
The translation of the remaining part of a transition is defined by the following recursive equations:

Δ
 secret(m, a1) Λ ... secret(m, an) Λ R) =
if a1 /= i then ... if an /= i then (c!sencrypt(rm, m)). R))
else  R) ... else  R)
Δ
 State = s1) = Bs1
Here R is a conjunction of HLPSL expressions, rm is a special constant cre- ated for each message m declared secret and used in formulating secrecy goals. While translating Secret we group secret goal facts by the expression that is being made secret. Note, that we have to guard each event with the restric- tion that neither of the participants is the intruder i because the correctness requirements are meaningless in the this case. We can create an additional process defined as R) to avoid the duplication of the code.
It is worth noting that currently the semantics of HLPSL is not clearly defined. Therefore, in some cases we had to make the decision of how to interpret HLPSL constructs. In this cases we tried to follow the semantics that is implemented in the AVISPA tool.
For example, in our subset of HLPSL it is not possible to model a situation in which a role receives a private key through a channel and then decrypts a message using this private key, i. e. a role has static knowledge. This is due to the fact that the private key must be known to the role at the beginning of its execution and written in the text of the role using the inv constructor. This is compatible with the AVISPA tool, which does not support processing of such a situation at the moment.
One more issue that we had to resolve was whether the values for vari- ables with the fresh attribute should be generated each time the transition containing the variable is performed or each time the role is instantiated. In our translation we create the values as fresh names in the applied pi calculus each time the transition is performed.

Verification with ProVerif
The result of the translation described in the previous section can be veri- fied with the ProVerif tool [6], which is a theorem proving system based on an intermediate representation of the protocol by a set of Horn clauses (a logic program). ProVerif has the input language similar to the one described in section 3. The differences between these two languages are the following. ProVerif does not support the + operator, but offers built-in unification in the let operator. Besides, ProVerif allows for declaring free names in specifica- tions, which can be public (known to the intruder) and private (unknown to the intruder). The model of the intruder in ProVerif is DY with the exception that some constructors can be declared private, so that the intruder cannot use them to create new messages. Moreover, ProVerif allows for specifying equations between terms. However, the treatment of equations in ProVerif is still preliminary, which may result in non-termination of the tool in certain cases.
ProVerif allows for specifying different types of goals (which are called queries). For our translation we will use only some of them.
Queries are build out of facts, which can have the following form:
attacker:t – is true if and only if the intruder may know t.
t1 = t2 – is true if and only if the terms t1 and t2 are equal.
ev:f (x1,... , xn) – is true if and only if the event f (x1,... , xn) has been executed.
Given facts F and Fi,j (1 ≤ i ≤ k, 1 ≤ j ≤ ki) we can construct a query
F ==> (F1,1 & ... & F1,j1 ) | ... | (Fk,1 & ... & Fk,jk )
which is true if and only if, when F is true, then for some i Fi,m is true for all
m such that 1 ≤ m ≤ ji. The query can also be a fact F . For example, the query
query attacker:t
is true when the intruder may know t and the query
query ev:f1(x1,... , xn) ==> ev:f2(y1,... , yn)
is true when, if the event f1(x1,... , xn) has been executed, then the event
f2(y1,... , yn) must have been executed before it.
In our translation we declare inv as a private constructor with the equation inv(inv(x)) = x, the channel c as a public free name and all the other constants as private free names.

A secrecy goal secrecy of m in HLPSL is translated to
query attacker:rm
since from the translation algorithm it follows that the intruder can know rm if and only if it knows m. The need for rm is due to the fact that one needs a free name to be used in query and the terms declared secret cannot be used for this purpose because they are created inside processes.
A weak authentication goal A weakly authenticates B on p in HLPSL is translated to the set of queries of the form
query ev:wrequest(b, y, p, x) ==>
(ev : witness(y, b, p, x)& ev:player(y, aid)) | y = i.
for each agent b playing the role B. Here aid is the role identifier of the role
A. Agents playing roles and role identifiers are determined while translating composed roles. We have to put the variable y as the second argument to wrequest in this query instead of an agent playing the role A because we have to take into account the situation in which wrequest is executed with a non-existing agent (created by the intruder) as its second argument.
A strong authentication goal A authenticates B on p is translated to the set of queries including those for the corresponding weak authentication goal (with request substituted for wrequest) and queries of the form
query attacker:(sencrypt((b, a, p, x, y1), sidkey),
sencrypt((b, a, p, x, y2), sidkey)) ==> y1 = y2.
for each agent b playing the role B and agent a playing the role A. Since the messages of the form sencrypt((b, a, p, x, y), sidkey) are sent only when the corresponding request event is executed, these additional queries ensure that no data will be used twice for authentication in two different sessions (defined by different SID values y1 and y2) and, hence, ensure strong authentication. We have to use the queries of the form query attacker:t because ProVerif does not allow for using conjunctions of facts on the left-hand side of the ==> operator. We have to encrypt the data used in the request event with sidkey unknown to the intruder so that the intruder cannot use them.
Our implementation translates HLPSL specifications from the subset of HLPSL described in section 2 to the language of ProVerif. Since ProVerif does not support the + operator, the translation can be performed only for the roles that have the conjunct State = s at most in one transition for each
s. However, this is sufficient to verify most of the protocols that were modelled in HLPSL.

Implementation and Experiments
We have implemented the translation described in the previous sections and used ProVerif to verify the generated specifications.
Our experimental results are summarized in figure 7. The implementation was tested on some of the protocols modelled in HLPSL as a part of the AVISPA project [4]. For each protocol the table shows its short name (as it appears in [4]), the time it took to translate it to the applied pi calculus and verify it with ProVerif, the number of properties verified, the type of the authentication goals (weak or strong) and whether any attacks have been found. The tests have been performed on a computer with 2 Intel Xeon
3.2Ghz processors running Red Hat Enterprise Linux 3.0. Our translator was implemented in GNU C++ and we used ProVerif 1.13 compiled with Ocaml 3.08.
ProVerif has not terminated on the specification of ISO3 protocol. For all the other protocols we found known attacks against flawed protocols, and proved the correctness of the correct ones. The attacks were the same as the attacks found by the AVISPA tool (using OFMC as the back-end).
¿From figure 7 it can be concluded that the verification is very efficient for all protocols except ISO3. Non-termination of ProVerif on ISO3 is due to the fact that ProVerif is a theorem proving system that may not terminate in some cases.

Conclusions and Future Work
We have described an algorithm for the translation of HLPSL specifications to the dialect of the applied pi calculus supported by the ProVerif tool and presented its implementation. We illustrated the usability of the algorithm and the implementation by reasoning on a variety of HLPSL specifications.
The algorithm provides us with two interesting scientific contributions: at first it provides an independent semantics of the HLPSL specification language and second makes it possible to verify protocols specified in HLPSL with the ProVerif tool.
Our current research activity proceeds on the following directions.
First, we are extending the translator to deal with the whole HLPSL. In particular, we intend to add support for complex types, sequential composition of roles, and the translation of roles with forks in computation.
Second, we are going to formally prove our translation algorithm correct. It is not possible at the moment because both syntax and semantics of HLPSL are currently under development. We intend to provide such a proof on the


Fig. 7. Experimental results
basis of the formal definition of the HLPSL semantics in temporal logic of actions [18] that is currently under development.
Finally, we are working to identify more sophisticated protocols to assess the scalability of our approach and to use other verification engines for the applied pi calculus. A possible approach is to use the HAL model checker [16,15]. This approach is particularly convenient since HAL can handle fresh names generation in an effective way.

References
M. Abadi and B. Blanchet. Analyzing security protocols with secrecy types and logic programs.
J. ACM, 52(1):102–146, 2005.
L. C. Aiello and F. Massacci. Verifying security protocols as planning in logic programming.
ACM Trans. Comput. Logic, 2(4):542–580, 2001.
A. Armando and L. Compagna. SATMC: a SAT-based model checker for security protocols. In Proceedings of the 9th European Conference on Logics in Artiﬁcial Intelligence (JELIA 2004), volume 3229 of LNCS, pages 730–733. Springer-Verlag, 2004.
AVISPA. Deliverable D6.2: Specification of the problems in the high-level specification language, 2005. http://www.avispa-project.org/d6-2.pdf.
D. Basin, S. Modersheim, and L. Vigano. An on-the-fly model-checker for security protocol analysis. In Proceedings of the 8th European Symposium on Research in Computer Security (ESORICS 2003), pages 253–270, 2003.


B. Blanchet. Automatic verification of cryptographic protocols: a logic programming approach. In PPDP ’03: Proceedings of the 5th ACM SIGPLAN international conference on Principles and practice of declaritive programming, pages 1–3. ACM Press, 2003.
Y. Boichut, P.-C. Heam, O. Kouchnarenko, and F. Oehl. Improvements on the Genet and Klay technique to automatically verify security protocols. In Proceedings of the 3rd International Workshop on Automated Veriﬁcation of Inﬁnite States Systems (AVIS’04), pages 1–11, 2004.
S. Brackin, C. Meadows, and J. Millen. CAPSL interface for the NRL protocol analyzer. In Proceedings of IEEE Symposium on Application-Speciﬁc Systems and Software Engineering Technology (ASSET-99). IEEE Computer Society Press, 1999.
S. H. Brackin. An interface specification language for automatically analyzing cryptographic protocols. In Proceedings of the Symposium on Network and Distributed System Security, pages 40–51, 1997.
Y. Chevalier, L. Compagna, J. Cuellar, P. Hankes Drieslma, J. Mantovani, S. Modersheim, and L. Vigneron. A high level protocol specification language for industrial security-sensitive protocols. In Proceedings of Workshop on Speciﬁcation and Automated Processing of Security Requirements (SAPS 2004), 2004.
E. M. Clarke, S. Jha, and W. Marrero. Verifying security protocols with Brutus. ACM Trans. Softw. Eng. Methodol., 9(4):443–487, 2000.
G. Denker, J. K. Millen, A. Grau, and J. Kuster Filipe. Optimizing protocol rewrite rules of CIL specifications. In Proceedings of 13th IEEE Computer Security Foundations Workshop (CSFW-13), pages 52–62, 2000.
D. Dolev and A. Yao. On the security of public-key protocols. IEEE Transactions on Information Theory, 2(29):198–208, 1983.
A. Durante, R. Focardi, and R. Gorrieri. CVS: a compiler for the analysis of cryptographic protocols. In Proceedings of the 12th IEEE Computer Security Foundations Workshop, pages 203–212, 1999.
G. Ferrari, S. Gnesi, U. Montanari, and M. Pistore. A model-checking verification environment for mobile processes. ACM Trans. Softw. Eng. Methodol., 12(4):440–473, 2003.
G. Ferrari, S. Gnesi, U. Montanari, M. Pistore, and G. Ristori. Verifying mobile processes in the HAL environment. In Proceedings CAV’98, volume 1427 of LNCS. Springer Verlag, 1998.
F. Jacquemard, M. Rusinowitch, and L. Vigneron. Compiling and verifying security protocols. In Proceedings of 7th International Conference on Logic for Programming and Automated Reasoning (LPAR’2000), volume 1955 of LNCS, pages 131–160. Springer-Verlag, 2000.
L. Lamport. The temporal logic of actions. ACM Transactions on Programming Languages and Systems, 16(3):872–923, May 1994.
E. G. Lowe. Casper: A compiler for the analysis of security protocols. J. Comput. Security, 6:18–30, 53–84, 1998.
G. Lowe. A hierarchy of authentication specifications. In CSFW ’97: Proceedings of the 10th Computer Security Foundations Workshop (CSFW ’97), page 31. IEEE Computer Society, 1997.
P. Syverson and C. Meadows. A formal language for cryptographic protocol requirements.
Des. Codes Cryptography, 7(1-2):27–59, 1996.
