

Electronic Notes in Theoretical Computer Science 241 (2009) 35–55
www.elsevier.com/locate/entcs
Session-based Choreography with Exceptions
Marco Carbone1,2
Department of Computer Science Queen Mary University of London London, United Kingdom

Abstract
Choreography has recently emerged as a pragmatic and concise way of describing communication-based systems such as web services and financial protocols. Recent studies have investigated the transition from the design stage of a system to its implementation providing an automatic way of mapping a choreograhy into executable code.
In this work, we focus on an extension of choreography with a communication-based (interactional) ex- ception mechanism by giving its formal semantics. In particular, we discuss through some examples how interactional exceptions at choreography level can be implemented into end-point code.
Keywords: Choreography, web servicesm, interactional exceptions


Introduction
Due to fast-evolving technologies, applications based on communication are becom- ing vital in the practical world. Such communication-centred applications are often called Web Services, the first major programming trend which positions communi- cation as a key element of high-level programming.
An emerging paradigm for programming communication is the so-called Chore- ography. This discipline focuses on the fact that an architect, when designing a distributed system, no longer describes the behaviour of each single interacting peer (end-point behaviour ) but establishes how the various inter-participant interactions happen by giving a global description (choreography) of the system. In a traditional approach, the architect would describe each communication operation, e.g. an input to be performed at one particular peer. Unfortunately, this makes it very difficult to have a global view of how the whole system being designed works. On the other hand, a global description offers a view of where and when a communication has

1 I would like to thank Kohei Honda, Nobuko Yoshida and the anonymous referees for their helpful sug- gestions. This work is partially supported by EP/F002114.
2 Email: carbonem@dcs.qmul.ac.uk

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.06.003

to happen. The architect will now decide that e.g. there will be a message from A to B and no longer think how this will be implemented at A (sending a message) or B (waiting to receive a message). Choreography can offer a vantage view of the system facilitating the design stage and leaving the implementation details to the (possibly automated) process of generating a sound end-point code, called end-point projection.
Exceptions are a mechanism widely adopted in modern programming languages (e.g. Java, C#) for dealing with exceptional system behaviours i.e. they are de- signed to handle the occurrence of some conditions interrupting the normal flow of execution of a program 3 . While the classical notion of exception is bound to the local flow of a process, in communication-centred programming exceptions are about the flow of interactions where a sudden interruption must involve all inter- acting participants. We shall call this kind of exception an interactional exception [5].
This work studies an extension of choreography with exceptions in the setting of session-based communication and session types [6]. In particular, we shall see how exceptions are naturally interactional in choreography (choreography is about interactions) while they require an exception propagation mechanism at end-point level.
Contributions of the paper. Below, we list the contributions of this paper:
syntax, reduction semantics and typing of the global calculus with exceptions;
syntax, reduction semantics and typing of the end-point calculus with exceptions and locations;
a discussion through examples of the requirements for guaranteeing a sound map- ping from the global calculus to the end-point calculus (end-point projection).
Outline. The remainder of the paper is divided as follows: Section 2 introduces the extension of the global calculus with exception primitives and discusses the new typing system where a new type for exceptions, the try-catch type is introduced; Section 3 adapts the results found in [5] to a calculus with locations; Section 4 discusses with examples the end-point projection and how it changes in presence of exception constructs; Section 5 concludes the paper.


Extending Choreography with Exceptions
Syntax. The global calculus [3,4] is a model of choreography based on WS-CDL 4
[10]. We hereby extend it with new terms for describing exceptions. The syntax of


3 Note that exceptions is not necessarily associated to unwanted/erroneous behaviour: “Exception (han- dling) is a programming language construct or computer hardware mechanism designed to handle the oc- currence of a condition that changes the normal flow of execution” - Wikipedia
4 WS-CDL is a description language developed by W3C WS-CDL Working Group based on the notion of choreography and it is mainly used for business protocols.

a global description (or choreography) I is defined as:


a, b, c,... range over service channels which may be considered as public services; s, t, r, u range over session channels, the communication channels freshly generated for each session; A, B, C range over participants who are equipped with their local variables denoted by x, y, z .. .; op is a label denoting an operation (as in standard session types [6]); e is an arithmetic or other first order expression containing vari- ables; and X ranges over term variables used for recursion. The free session channels and term variables of a global description I (denoted by fn(I) and fv(I) respectively) are defined in the usual way.
Most of the terms are similar to [3]. (com) models in-session communication between participants A and B: the result of evaluating message e at A will be stored in variable y located at B while op indicates the type of operation required in the interaction (e.g. a method) [10]. (cond) is the standard conditional operator where the guard e is evaluated at A. (rec) and (recVar) are respectively recursion and recursion variable while (sum) is non-deterministic choice. The term (par) is the parallel composition of choreographies.
In the syntax above, the terms (throw) and (init) are novel. (throw) denotes the throwing of an exception. (init) describes a system where participant A invokes a service b located at participant B and starts a session s (in the rest of the paper
A ≠ B).  The novelty is in the triple [t˜, I, J]: choreography I, called the default
choreography, describes the normal (or default) behaviour of the system, while J is the exception handler i.e. the way the system shall behave when an exception is thrown. Vector t˜, containing already established sessions, has a pivotal roˆle: if there is a throw in I then any other handler belonging to an embedding triple [t˜j, Ij, Jj] ([t˜, I, J] is in Ij) such that t˜j ⊆ t˜ must be discarded. We call vector t˜ a reﬁnement in the sense that channels t˜j in t˜ are refined i.e. a new handler J replaces the old ones. We also let s itself be included in t˜ which is convenient for typing. As an example, the choreographies
A → B : b(s)[s,	B → C : c(t)[t, I, J]	, Jj]
A → B : b(s)[s,	B → C : c(t)[(s, t), I, J]	, Jj]
describe different systems. In the first case, the raising of an exception in I, would only concern the interactions on t between B and C while the second choreography would also affect the interactions on s. In the latter case, a throw in I would execute handler J discarding Jj. Note that, in the implementation, this condition means that an exception on any ti has to be propagated to all the elements of t˜. Unfortunately, a refinement (s, t, r) inside an outer default choreography with refinement (s, t, tj) would

create an inconsistency as the latter says that an exception should be propagated over s, t and tj while the inner refinement would only consider propagation over s and t in addition to the new tj. For consistency, we make the following assumption:
Assumption 1 For any C → D : a(sj)[t˜j, Ij, Jj] occurring in A → B : b(s)[t˜, I, J]
and for any ti e t˜ we have ti e t˜j implies t˜ ⊆ t˜j.
For having consistent operational semantics, we also stipulate the following syn- tactic constraints: (i) recursions should be guarded, i.e. I in rec X . I is prefixed by
(init) or (com); and (ii) in A → B : b(s)[t˜, I, J], a free term variable never occurs in I or J. Further, in A → B : b(s)[t˜, I, J], we shall exclude refinements on ti in J. As well, we do not allow top-level throws in handlers. This prevents a handler from
throwing a further exception in the same session.
Example 2.1 (A simple Financial Protocol) This example and the following one [5] are typical scenarios in financial protocols. Consider a customer Buyer who wishes to pur- chase a product from a company Seller. Buyer starts a session with Seller who repeatedly sends quote updates about the product price. When Buyer decides to accept a particular quote, without explicitly notifying Seller, it throws an exception. At this point, Seller and Buyer move together to a new stage (exceptional stage with respect to the ordinary se- quence of actions) where they exchange information for successfully terminating the trans- action e.g. credit card details for payment and receipt. A global calculus representation of the protocol which uses the interactional exception mechanism is given:

Buyer → Seller : chSeller(s) [s,
rec X . Seller → Buyer : s(update, quote, y) . ⎫⎪ default

if (y < 100)@Buyer then throw else X,

Seller → Buyer : s(conf, cnum, x) .
Buyer → Seller : s(data, credit, x) ]
⎪⎭

⎪ handler
⎪⎪⎭


In line 1, Buyer invokes service chSeller from Seller. Line 2 and 3 compose the default choreography: the interaction Seller → Buyer : s(update, quote, y) models the sending of a quote quote from Seller to Buyer who will store the received value at variable y. In line 3, variable y is checked by Buyer and if its value is less than 100, an exception will be thrown otherwise the course of action will go back to line 2. Lines 4 and 5 describe how the system will handle an exception: Seller will send a confirmation cnum and Buyer will reply with its credit card credit. Note that variable x denotes two different variables in lines 4 and 5: the first one is located at Buyer while the second is located at Seller.
The behaviour described by the choreography above may also be represented by replac- ing the throw operator with the code in the handler, i.e.:
rec X . Seller → Buyer : s(update, quote, y) .
if (y < 100)@Buyer then {... as in handler .. .} else X,

Although this is a legitimate way of describing the protocol, the choreography above in- creases the burden of the implementation. An end-point representation would require a hack i.e. that Buyer notifies Seller of its guard evaluation at each iteration while our solu- tion can be implemented with end-point interactional exceptions thus automatically guar- anteeing the propagation of the exceptional state. Hence, the user (or architect) could be allowed to write exception-free descriptions as the above but then a tool would have to translate them into something like the one with exceptions.
Example 2.2 (A Financial Protocol with Broker) We extend the protocol above in- cluding a third participant, a broker Broker whose roˆle is to buy from Seller and resell to Buyer (a typical situation in financial protocols). In this scenario, Buyer will invoke Broker rather than Seller and act almost identically as in the previous example. On the other hand Broker, after being invoked by Buyer and checking his reputation, will invoke Seller and act as Buyer in the previous example. As before, Buyer can raise an exception in case of quote acceptance but also Broker can throw if Buyer’s reputation is not satisfactory before even invoking Seller. This can be written in the global calculus as:



Buyer → Broker : chBroker(s) [s,
Buyer → Broker : s(identify, id, x) .
if bad(x)@Broker then throw
else Broker → Seller : chSeller(t)[(s, t), rec X .
Seller → Broker : t(update, quote, y) . ⎫⎪
Broker → Buyer : s(update, 1.1 ∗ y, y) . ⎪⎬⎪ default
⎪

⎫⎪
⎪
⎪
⎪
⎪
⎪
⎪⎬⎪ default

if (y < 100)@Buyer then throw else X,	⎭	⎪
Seller → Broker : t(conf, cnum, x) .	⎫⎪	⎪

Broker → Buyer : s(conf, x, x) .
Buyer → Broker : s(data, credit, x) .
Broker → Seller : t(data, x, x)],
⎬⎪
⎪⎪⎪

⎪
⎪⎪⎪

Broker → Buyer : s(reject, reason, x) ]	} handler

In lines 1 and 2, Buyer invokes service chBroker and sends its identity id to Broker who, in line 3, will check whether Buyer is bad or not. If Buyer is not trusted, Broker will raise an exception which will take both Buyer and Broker to an abortion procedure in line 12. Note that in this case, Buyer and Broker are the only participants involved so far and the only ones who will move to another conversation for handling the exception.

If Buyer can be trusted, Broker invokes service chSeller and forwards to Buyer all quotes received from Seller increasing them by 10%. As before, Buyer will throw an exception whenever s/he decides to accept a quote. In this case, as the participants involved are now Buyer, Broker and Seller, the handler to be executed is the inner one where Broker will forward messages between Buyer and Seller (lines 8-11). This event will also discard the handler in line 12 which, after session initiation in line 4, has become inactive.
Semantics. Above, we have shown how interactional exceptions can be exploited for expressing systems such as financial protocols. Now, we shall formalise the exception mechanism by defining a reduction semantics for the global calculus that can handle exceptions.
In order to give semantics to the new exception operations, we need to extend the syntax with the following terms (called run-time syntax):
I, J	::=	...	|	try(s˜) { I } catch { J }	|	{I}}	|	(νs) I
The term on the left, called try-catch block, reads: “The system is behaving as choreography I; if an exception is thrown the system will start behaving as described by choreography J”. This realises at run-time the default choreography and the handler found in session initialisation. When an exception is thrown, we need to make sure that handlers do not get brutally terminated by an embedding try-catch block. This is ensured by a wrap term {{I}} which reads “an exception has been thrown and part of the system is behaving as I”. Term (νs) I is the standard restriction. In addition, as terms may reduce inside try-catch blocks, we need a notion of (run-time) context, defined as:
C[−] ::= try(s˜) { C[−] } catch { J }	|	I | C[−]	|	{C[−]}}	|	(νs) C[−]	|	−
Table 1 contains the rules generating the reduction relation −→. A reduction
s˜	j
(I, σ) −→ (J,σ ) says that a global description I in a state σ (which is the collection of all local states of the participants) evolves into description J with a new state σj. Intuitively, the reduction semantics of choreography will change the state σ by updating local variables as a consequence of each interaction. Label s˜ is used for discarding embedding try-catch blocks (due to refinement) on some si after an exception has been thrown. We shall often omit the label when equal to the empty set ∅.
We now discuss the reported rules. Rule (G-Init) transforms session initial- isation into a try-catch term i.e. the term A → B : a(s)[t˜, I, J] is rewritten into
(νs) (try(t˜) { I } catch { J }) denoting the generation of the session channel s (now
under restriction) and the use of a try-catch block. The state σ remains unchanged. Rule (G-Com) is about intra-session communication: participant A is sending mes- sage v (the result of evaluating expression e in the A-part of state σ) over session channel s and B will receive and assign v to its local variable x. As a result of this communication, state σ will become σ[x@B ›→ v]. Rule (G-Thr) handles the raising of an exception: when a throw is top-level in a try-catch block then the


(G-Init)	–
(σ, A → B : a(s)[t˜, I, J]) –→ (σ, (νs) try(t˜) { I } catch { J })


(	σj = σ[x@B ›→ v]  σ s e@A ↓ v
try(t˜) { throw | I } catch { J }  (Ij, s˜)

G-Com) (σ, A → B : s(op, e, x) . I) –→ (σj , I)	(G-Thr)	˜
t˜∪s˜	j

(σ, try(t) { throw | I } catch { J }) –→ (σ, I )



(G-Clean)
s˜ ⊆ t˜,  (σ, I)  t˜  (σj, Ij)	and	Ij   (Ijj, r˜)


(σ, try(s˜) { I } catch { J }) t˜∪r˜ (σ, Ijj)



(G-Context)
(σ, I) s˜ (σj, Ij)
s˜ ¢ fn(C[–])

(G-Res)
(σ, I)  s˜  (σ, J)



(σ, C[I])  s˜
(σj , C[Ij])
(σ, (νt) I) s˜\{t} (σ, (νt) J)



(G-IfT) 	σ s e@A ↓ tt	
(σ, if e@A then I1 else I2) –→ (σ, I1)

σ s e@A ↓ ff

(G-Sum)


(σ, I1 + I2) –→ (σ, I1)

(σ, I1) –→ (σj, Ij )

(G-IfF)


(σ, if e@A then I1 else I2) –→ (σ, I1)
(G-Par) 	1	
(σ, I1 | I2) –→ (σj , Ij | I2)




(G-Rec)
(σ, I{rec X.I/X}) –→ (σj, Ij)
(σ, rec X.I) –→ (σj , Ij)	G-Struct
I ≡ Ijj (σ, I) –→ (σj, Ij) Ij ≡ Ijjj

(σ, Ijj) –→ (σj , Ijjj)



Table 1
Semantics Rules for the Global Calculus with Exceptions

default choreography terminates and the handler J is run (wrapped). The rule uses a different relation I (Ij, s˜) called meta reduction. The initial choreography I is transformed into Ij, the result of erasing and wrapping nested try-blocks and catch-
blocks respectively. s˜ denotes all those session channels affected by the exception
from nested try-catch blocks. This relation is indispensable in interactional excep- tions: choreography I may contain wraps or other try-catch blocks which should
not be brutally erased and an exception should also be raised. Meta reduction is the minimum relation defined by the rules in Table 2. (G-MTry) is the most relevant rule. Whenever a try-catch block must be meta reduced, we need to apply meta reduction to its default choreography first. If this contains a refinement of s˜
then we just need to discard the current try-catch block. Otherwise, we need to take the parallel composition of the result Ij and the wrapping of the handler J. The set t˜ is used for keeping track of nested refinements. (G-MWrap) leaves a wrapped global description unchanged while rule (G-MPar) applies meta reduction to the components of parallel composition and returns the composition of the results to- gether with the union of the session channel sets. Finally, (G-MNil) meta reduces any other choreography to the inaction 0.
The semantics rules reported in Table 1 also include (G-Clean). Using the information contained in the label of the reduction relation, this rule discards refined




(G-MTry)  I

(Ij, t˜)

→	try

(s˜)

{ I } catch { J
⎧ (Ij, t˜)	if s˜ ⊆ t˜
⎪⎩ ({{J}} | Ij, t˜∪ s˜)	otherwise

(G-MWrap)  {{J}}   ({{J}}, ∅)

(G-MPar)  I   (Ij, s˜) and J   (Jj, t˜)	→	I | J   (Ij | Jj, s˜ ∪ t˜)
(G-MNil)  I   (0, ∅)  if I e (inact),(init), (com), (cond), (recursion), (throw) }



Table 2
Rules for meta reduction for the global calculus

embedding try-catch blocks. Note that we apply meta reduction as I may also contain other try-catch blocks in parallel where an exception needs to be raised. (G-Res) removes session channels on the labels when there is a restriction. The context rule (G-Context) allows to compose try-catch blocks whenever the throw is not over refined channels (condition s˜ g fn(C[–])). Rules (G-Rec) and (G-Par) are standard rules for recursion and parallel composition. Finally, (G-Struct) allows to use the standard structural congruence, defined as the least congruence relation ≡ on I such that | and + are commutative monoids and it satisfies alpha-
conversion and scope-opening (νs) I1 | I2 ≡ (νs) (I1 | I2) for s not in I2. The remaining
rules in Table 1 are standard [4].
Example 2.3 (Semantics of Financial Protocol with Broker) We now show how the rules work in our second example. When bad(x) holds, we have that

(νs) try (s) { if bad(x) then throw else . . . lines 4-9. . . } catch { J } –→–→ (νs) {{ J }}

where J = Broker → Buyer : s(reject, reason, x) . I. In the other case, when Buyer wishes to accept the quote (y < 100 holds), we have:
(νs) (νt) try (s) {
try (t, s) {
if (y < 100) then throw

else {... as line 4. . . }
} catch {... as lines 8-9. . . }
} catch { J }
–→–→	{{ {... as lines 8-9. . . } }}

where the first arrow corresponds to the reduction of the conditional to throw (for the sake of space we do not report the contractum term) with rules (G-IfT) and (G-Context); and the second arrow is then obtained by applying rules (G-Thr) and (G-Clean).
Types. The type discipline for the calculus is based on session types as in [3,4]. The grammar of types is as follows:



α ::=  ↓ Σiopi(θi) . αi |  † Σiopi(θi) . αi | α{{β}} | end | rec t . α | t

α is called session type while θ is a first-order value type (not a session type). The try-catch type α{{β}} is novel: it is the abstraction of a try-catch block where α denotes the type of a service in the default choreography while β the type in the exception handler. From now on in α{{β}}, we stipulate that α and β do not contain any try-catch type.
The typing judgements have the form Γ s I  Δ where Γ is the service environment
and Δ is the session environment. They are formally defined as:


In a service typing, a@A : α{{β}} says that a is located at A and offers a service interface α{{β}}; x@A : θ says that a variable x located at A may store values of type θ; finally, X : Δ says that when the interaction recurs to X, it should have the typing Δ.
In session typing, the assignment s[A, B]: α says that a session channel s, be- longing to a session between A and B, has the session type α when seen from the viewpoint of B.
The entailment relation s is defined by the rules reported in Table 3. (G-TInit)

Γ s I  .i ti[Ai, Bi] : αi{{βi}}	Γ s a@Bj : αj{{β j}}
Γj s J  .i ti[Ai, Bi] : βi	Γj ⊆ Γ	fv(Γj) = θ

(G-TInit)
Γ s Aj → Bj : a(t j)[t˜, I, J]  .i≠ j ti[Ai, Bi] : αi{{βi}}

(G-TCom) Γ s I  Δ · s[A, B] : αj  Γ s e@A : θj  Γ s x@B : θj  j e K
Γ s A → B : s(op, e, x) . I  Δ · s[A, B] : ↓ ΣieK (θi) . αi

(G-TCom–1) Γ s I  Δ · s[B, A] : αj  Γ s e@A : θj  Γ s x@B : θj  j e K
Γ s A → B : s(op, e, x) . I  Δ · s[B, A] : † ΣieK (θi) . αi


(G-TThr) 	fv(Γ) = θ	
Γ s throw	i si[Ai, Bi] : αi
(G-TRec) Γ, X : Δ s I  Δ
Γ s rec X . I  Δ
(G-TVar) Γ, X : Δ well-formed
Γ, X : Δ s X  Δ



(G-TIf)  Γ s e@A : bool	Γ s Ii  Δ  Γ s if e@A then I1 else I2  Δ
(G-TPar) 	Γ s Ii  Δi	
Γ s I1 | I2  Δ1  Δ2
(G-TSum)   Γ s Ii  Δ 
Γ s I1 + I2  Δ


(G-Zero) 	Γ well-formed	si, tj distinct	
Γ s 0  Πi si[Ai, Bi] : end · Π j t j[Aj , Bj ] : end{{β j}}
j  j


Table 3
Typing Rules for the Global Calculus

types session initiation. In the service environment, if channel a is located at Bj and has session type αj{{β j}} then we must make sure that channel t j is used as βj in the handler J and as αj{{β j}} in the default choreography (we carry βj because of refinement). Note that βj has no try-catch type nested: this follows from the assumption that in any type of the form α{{β}}, none of its subterms is a try-catch type. As a consequence, (G-TInit) ensures that t j is not refined in the handler. Moreover, assumption fv(Γj) = θ, guarantees that there is no recursion variable occurring free in J. (G-Comm) and (G-Comm–1) type in-session communication: they prefix the type of a session channel with an input and output type respectively. We need two typing rules because communication types can be expressed from the viewpoint of the sender (A) or the receiver (B). The operation † ΣieK(θi) . αi creates optional several branches (like in standard session types) and it is read as († ΣieK(θi) . αj){{β}} whenever αj = αj {{β}}. In (G-TThr), term throw is typed such
i	j
that any session channel si can have any type because this operation can interrupt any conversation. Rule (G-Par) uses disjoint union in order to guarantee linearity [6]. Rule (G-Zero) allows to start typing (bottom-up) with inactive sessions (end for handlers) or inactive try-catch types (end{{β}} for default choreographies). The remaining rules are standard.
Example 2.4 (Typing of Financial Protocol with Broker) As an example, the types of services chSeller and chBroker are (rec t. † update(int) . t){{† conf(int) . ↓ data(int)}} and (↓ identify(int) . rec t. † update(int) . t){{† conf(int) . ↓ data(int) + † reject(string)}} respectively.	□
Types for Run-Time Choreography. In order to also type run-time terms and state subject reduction, we need two additional rules for typing try-catch blocks and wrapped choreographies. First, we enhance the type of session channels by redefining the session environment:
Δ	::=	θ	|	Δ · s[A, B] :n α
Above, channel s is protected if n = 1, unprotected if n = 0. Session channels are protected whenever they occur inside a try-catch block or a wrap. Finally, the additional rules for typing the run-time syntax are:
Γ s I . j t j :1 αj · .i si :mi αi{{βi}}	m e {0, 1}
Γj s J d .i κi :0 βi	Γj ⊆ Γ, fv(Γj) = θ
(G-TTry) Γ sA try(s˜) { I } catch { J } . t j :1 αj · . s :1 α {{β }}
i  i	i	i

Γ s J d . j t j :1 αj{{β j}} · .i si :0 βj
(G-TWrap)	.	.
i	i


(G-TRes) Γ s I  Δ · s[A, B] : α{{β}}
Γ s (νs) I  Δ

Rule (G-TTry) types try-catch blocks and carries conditions similar to (G-TInit). The main difference lies on the typing of I where any session channel ti not in s˜ must be protected i.e. there is a try-catch block on ti. As a result, also channels in s˜ become protected. We impose this condition because we want to avoid to brutally terminate unprotected sessions, operation that would not have a real end-point implementation. In (G-TWrap), all those unprotected session channels become protected where their type becomes a try-catch type whose left-hand side is ran- domly chosen (αj). (G-TRes) is standard.
In the sequel, Γ s σ means that Γ s x@A : θ for all x@A in σ. The expected property of subject reduction holds like in the original version without exceptions.
Theorem 2.5 (Subject Reduction) Assume Γ s σ and let I be derived from a non- run-time global description. Then Γ s I  θ and (σ, I) → (σj, Ij) imply Γ s σj and Γ s Ij  θ.

End-Point Interactional Exceptions
End-point interactional exceptions were first introduced in [5]. In this section, we briefly introduce the formalism enhanced with locations and such that branch- ing/selection are embedded in standard communication (as in [4]).
Syntax.  The syntax of processes (often called programs) and networks in the
asynchronous end-point calculus with exceptions is reported below:


where κ, λ denote polarised session channels s+, s–. The term (service) denotes a service c which, when invoked, will initiate a session κ with a default process P and a handler Q (to be used when an exception is thrown). Dually, term (request) represents the invocation of service c with session channel λ, default process P and handler Q. The vector κ˜ is used for refinement similarly to the choreography case. The remaining terms are standard. In the end-point calculus, we shall make the same assumptions about refinement and recursion done for the global calculus. Free session channels and term variables are also defined similarly.
A network N is the parallel composition of participants denoted by A[ P ]σ where
A is the participant’s name and P is the process running at such location in a state



(E-MTry)  P  (Pj, κ˜j)	→

⎧⎪⎨ (Pj, κ˜j)	if κ˜ ⊆ κ˜j



(E-MWrap)
try(κ˜) { P } catch { Q } 
⎩ (κ˜{{Q}} | P , κ˜ ∪ κ˜)	otherwise
κ˜{{Q}}  (κ˜{{Q}}, θ)


(E-MPar)  P   (Pj, κ˜1) and Q   (Qj, κ˜2)	→	P | Q   (Pj | Qj, κ˜1 ∪ κ˜2)
(E-MNil)  R   (0, θ)  if R e ⎧⎪⎨ (zero),(request), (input), (output), (branch), ⎫⎪⎬
⎪⎩ (select), (cond), (recursion), (throw)	⎪⎭


Table 4
Rules for Meta Reduction for the End-Point Calculus

σ. The latter is similar to the global case but it only maps variables (now local) to values.
Semantics. In this subsection, we report the meta reduction and the reduction semantics for the end-point calculus with exceptions and locations (participants). Similarly to the global case, we need to extend the syntax with run-time terms:

P ::=  ...	|	try(s˜) { P } catch { P }	|

N ::= ...	|	κ ‹→φ κ : L	|	(νs) N
L ::=	s	|	op(v) :: L	|	† :: L
s˜{{P}}

The try-catch block try(s˜) { P } catch { P } denotes a run-time (local) process running the default (local) process with a (local) handler ready to be executed if an exception is thrown (locally or remotely). Networks are extended with restriction and queues which are needed for implementing asynchronous messaging [7,5]. In a queue κ ‹→φ κ : L, κ denotes the dual of κ i.e. s– = s+ and s+ = s– and L is a list denoting the content of the queue. The special message † denotes the throwing of an exception.
Similarly to the global calculus, also the end-point calculus features a meta reduction relation which is defined by the rules given in Table 4. (E-MTry), the

most relevant rule, creates the wrapped handler only if κ˜ otherwise it returns the meta reduced subterm Pj.
was not refined in P,

As try-catch blocks can be nested, it is necessary to introduce evaluation contexts (at process level) defined by the following grammar:
E[–] ::= try(κ˜) { E[–] } catch { Q }	|	P | E[–]	|	κ˜{{E[–] }	|	–
In the sequel, the function wraps(E[–]) returns the set of polarised session names
that occur under a wrap in E[–] e.g. κi e wraps(κ˜{{Q | –}}).
The rules defining the reduction semantics of the end-point calculus with excep-
tions and locations are reported in Table 5. Rule (E-Init) initiates a session between two participants A and B running processes !a(s–)[P, Q] (service) and a(s+)[κ˜, Pj, Qj] (request) respectively. The reduction will result into the parallel composition of two try-catch blocks (corresponding to service and request) and two queues for

(E-Init)	A[ !a(s–)[P, Q] | Pj ]σ || B[ E[a(s+)[κ˜, Pj, Qj]] ]σj  –→
( s) ⎛⎜ A[ !a(s–)[P, Q] | try(s–) { P } catch { Q } | Pj ]σ || s– ‹→0 s+ : s || ⎞⎟

(E-Out)			σ s e ↓ v	 A[ E[κ!op(e) . P] ]σ || κ ‹→φ κ : L –→ A[ E[P] ]σ || κ ‹→φ κ : (op(v) :: L)
(	κ e wraps(C) iff φ = 1	L = Lj :: op(v)

E-In)
A[ E[κ?Σiop (xi).Pi] ] || κ ‹→φ κ : L –→ A[ E[P{v/x}] ]
|| κ ‹→0 κ : Lj

i	σ	σ


(E-Thr)
Pj  (R, κ˜)	outerTry(Pj, κ1)	Pj = Ej[try(κ˜) { throw | P } catch { Q }]


A[ E[Pj] ]σ || Πκeκ˜j κ ‹→φκ κ : Lκ –→ A[ E[R] ]σ || Πκeκ˜j κ ‹→φκ κ : († :: Lκ)

(E-RThr)			P  (R, κ˜)	outerTry(P,κj)	 A[ E[P] ]σ || κ j ‹→0 κ j : (L :: †) || Πκeκ˜ κ ‹→φκ κ : Lκ –→ A[ E[R] ]σ || κ j ‹→1 κ j : L || Πκeκ˜ κ ‹→φκ κ : († :: Lκ)

(E-WVal)	A[ E[κ˜{{Q}}] ]σ || κi ‹→0 κi : (L :: op(v)) –→
A[ E[κ˜{{Q}}] ]σ || κi ‹→0 κi : L
(E-WThr) A[ E[κ˜{{Q}}] ]σ || κi ‹→0 κi : (L :: †) –→ A[ E[κ˜{{Q}}] ]σ || κi ‹→1 κi : L
(E-IfTT) 	σ s e ↓ tt	
A[ E[if e then P else Q] ]σ –→ A[ E[P] ]σ
(E-IfFF) 	σ s e ↓ ff	
A[ E[if e then P else Q] ]σ –→ A[ E[Q] ]σ


(E-Par)

N –→ Njj
N || Nj –→ Njj || Nj	E-Res
N –→ Nj

(νs) N –→ (νs) Nj

N1 ≡ Nj  N1 –→ N2  N2 ≡ Nj
(E-Sum)  A[ E[P ⊕ Q] ]σ –→ A[ E[P] ]σ	(E-Struct)	1	j	j	2
N1 –→ N2
(	A[ E[P{rec X . P/X}] ]σ –→ A[ E[Pj] ]σ

E-Rec)
A[ E[rec X . P] ]σ
–→ A[ E[Pj] ]σ


Table 5
Rules for the Reduction Semantics of the End-Point Calculus with Exceptions


asynchronous communication. Note that the rule requires the (service) term to be top-level (no context) because of the service channel principle (SCP) [4] (service channels can be shared and invoked repeatedly). (E-Out) implements the asyn- chronous output consisting in putting v, the evaluation of the expression e in the state σ (σ s e ↓ v), into the queue together with the operation op (used for selecting branches). Rule (E-In) defines the dual operation of consuming an element op j(v) from the queue and selecting one of the branches opi. Note that if the input term is in a try-catch block (over κ) then the queue level must be 0 whereas a queue level equal to 1 requires that the input term is in a wrap (over κ). This ensures that if an exception occurs only those messages sent after the throw are read. Comparing to the original version in [5], we do not allow queues to enter try-catch blocks (in here we have locations). Local throwing of exceptions is defined by (E-Thr). To- gether with (E-RThr), this rule uses the end-point meta reduction relation  and

outerTry. The predicate outerTry(P, κ) is used for finding the outermost try-catch block which is connected to κ by refinement. Formally,



outerTry(P, κ)
⎪ true
j	jj	j

=	if P = try(κ ) { E[try(κ˜) { P
∧ κ, κj e κ˜
⎪
} catch { Q }] } catch { Q }

⎪⎩ false otherwise

In the following example, we have outerTry(P, κ) and ¬outerTry(Pj, κ):
P = try(κj) { try(κ, κj) { P } catch { Q }} catch { Qj };
Pj = try(κ, κj) { try(κ, κj, κjj) { P } catch { Q }} catch { Qj }.
Using the above definition assumes the existence of a try-catch block over a single κj which is refined in another nested try-catch block where it is coupled with κ. This is always true whenever we consider processes derived from programs i.e. syntax in pag. 11.
The predicate outerTry is necessary because the throwing of an exception can happen nested in a try-catch block which is a refinement of an outer one. Like in the financial protocol with broker, the latter needs to be discarded. Hence, we need to apply meta reduction to the outermost block.
After applying meta reduction, the special message † is put into the queue. Simmetricaly, Rule (E-RThr) is applicable when † is on the queue hence meaning the presence of a remote throw. In this case, the exception is propagated to the
other channels and the queue level where the exception was received is now set to 1 so that new messages, asynchronously put after †, are only delivered to the wrapped handler. (E-WVal) and (E-WThr) take care of removing all those messages sent
before an exception was thrown and setting the queue level to 1 when removing † respectively. The rest of the rules is standard. Rule (E-Struct) uses a standard structural congruence ≡. The relation is defined as the least congruence on processes such that (≡, ⊕), (≡, +) and (≡, |) are commutative monoids. ≡ is then extended to
networks such that (|, s) is a commutative monoid and
A[ P ]σ ≡ A[ Q ]σ (if P ≡ Q)	(νs) s ≡ s
(νs1) (νs2) M ≡ (νs2) (νs1) M	(νs) M | N ≡ (νs) (M | N) (if s g fn(N)) Types. The syntax of session types is identical to the global case. Typing judge- ments for networks, processes and expressions have the forms Γ s N  Δ, Γ sA P  Δ
and Γ s e : θ respectively where Γ is a service typing, which typically maps service
channels to service types and Δ is a session typing which typically maps session channels to session types. For n e {0, 1} and ρ e {p, u}, typings are defined as
(Session Typing)	Δ ::= θ | Δ, κ :n α | Δ, (κ, κ): α | Δ, (κ, κ) :±
(Service Typing)	Γ ::= θ | Γ, c : (α{{β}}) | c : bool | Γ, X : Δ






(E-TReq)


0 
u
j	0	+
u
Γ s c : (αj{{β j}})	Γj ⊆ Γ, fv(Γj) = θ



(E-TServ)

Γ sA P  s– :0 α{{β}}
Γ sA Q  s– :0 β	fv(Γ) = θ

Γ sA c(s+)[κ˜, P, Q] . κi :0 αi{{β }}


Γ, a : (α{{β}}) sA !a(s–)[P, Q] d θ



(E-Part) Γ sA P Δ	Γ s σ@A
Γ s A[ P ]σ  Δ
i≠ j	u	i


(E-Par) Γ s N1 Δ1	Γ s N2  Δ2
Γ s N1 || N2  Δ1 s Δ2



Table 6
Selected typing rules for the end-point calculus
In session typings, κ :n α says that: at a polarised session channel κ, there is a
session of type α. The natural number n is equal to 1 if there is a wrap on κ, 0 otherwise. A session channel with respect to its type is unprotected if ρ = u (no try- catch nor wrap on κ occurs) and protected if ρ = p (there is a try-catch or a wrap
on κ). This is needed in the try-catch and wrap typing as well as in the merging with the queue types (κ, κ): α and (κ, κ): ± used for typing a queue from κ to κ (the type of a queue is composed with the type of a process in which case the queue’s type becomes ±).
In the service typing, c either has type α{{β}} (a service using a session channel with default behaviour of type α and with a handler of type β) or an atomic type such as bool.
The typing system for programs is identical to the one given in [5]. In Table 6 we report the typing rules for process terms (request) and (init), and the ones for
networks A[ P ]σ and N || Nj. Rule (E-TReq) types a service request. The typing system makes sure that κ˜ is not wrapped in P and Q as well as it is unprotected in the handler Q (we do not allow re-try in the catch part). (E-TServ) is its dual
rule. The rules for network are identical to the ones found in [4].
Subjected reduction also holds for this version of the end-point calculus with exceptions and locations. In the following, –→∗ denotes the reflexive and transitive closure of –→.
Theorem 3.1 (Subject Reduction) Let N be a program such that Γ s N  θ. If N –→∗ Nj then Γ s Nj  θ.
On the End-Point Projection
In this section, we discuss the main issues regarding the procedure of generating end-point code from a given choreography known as end-point projection (EPP). EPP is not always feasible as the global calculus allows to write global interac- tions without a reasonable implementation. Enforcing some extra conditions on the global calculus allows to design systems which enjoy a sound EPP. In the sequel, we analyse, through some examples, the three algorithmically-checkable conditions introduced in [4].
Connectedness. Connectedness is about causality of interactions. The choreogra-

phy A → B : s(op, e, x) . C → D : t(opj, ej, y) describes a system where participant A is sending a message to participant B and, once this communication has happened, participant C will send a message to participant D. If we think of a possible im- plementation of the described system we need to make sure that we implement a notification from A or B to C or D which will trigger the second communication. In order to avoid this, we require that sequential interactions are connected i.e. at least one participant between A and B also occurs in the second interaction.
In [4], a very strong notion of connectedness is used (in the above example, B must be equal to C). We believe that the notion should be relaxed to a softer form, at least allowing choreographies such as the one below
A → B : b(s)[t˜,
B → A : s(op1, e1, x) . B → A : s(op2, e2, y), A → B : s(op3, e3, z)]
Above, the default choreography describes a system where participant B sends two messages, one immediately after the other, without waiting for an acknowledge- ment from A. This is a common scenario in communication-centred programming that, we believe, should also be allowed. As another example, also consider the financial protocol shown in the previous sections (also without Broker) where Seller repeatedly sends a quote.
In general, we want a connectedness condition requiring that either i) B = C or
A = C and B = D 5 in A → B : s(op, e, x) . C → D : t(opj, ej, y).
Well-Threadedness. Well-threadedness is also a causality condition but more subtle than connectedness. Rather than being related to which participants are performing an interaction, well-threadedness also considers how sessions are used. As an example, consider the following global description:


A → B : b(s)[s, B → C : c(r)[r, C → A : a(u)[u,

2
 __________________xsx__________________˛), J ], J ], J ]

x________________________________________________˛	x

Regardless of Ji, the description above is unrealisable at end-points.  In fact, the first action tells that a thread (local process) in A invokes B. Such a thread then becomes inactive in part 1 where service c at A is invoked. In part 2, A communicates with B via s, the session channel created in the initial action. If we try to write the behaviour above as an end-point calculus term, taking into account the service channel principle mentioned in the previous section, we have (for some σA, σB and σC):

A[  b(s)[s, s!op(v), Q1]	|	!a(t)[0, Q2]	]σA	|

B[ !b(s)[ c(u)[u,  s?op(x) . Pj, Q4] , Q3] ]σB	|
C[ !c(t)[ a(u)[u, 0, Q5], Q6]	]σC

5 This differs from the definition given in [4] where we only consider condition i)


At A, the process on the left invokes b and sends v with operation op in the same session, while the one on the right is a service and by SCP this channel should constantly be ready to receive invocations. Note that s!op(v) cannot be located under a, as it belongs to a session s. When the three processes interact, first, A invokes b, then B invokes c following the original global scenario. However, at this point, the action s?op(x) is free to react with its dual action s!op(v) thus violating the sequencing in the global description. Whenever a global description is free from such false dependency, we say it is well-threaded [4].
Well-threadedness is based on thread annotation of global descriptions. Threads are denoted by identifiers denoting which actions belong to the same processes. For instance, in the example above, b(s)[s, s!op(v), Q1] and !a(t)[0, Q2] denote two different threads, both running at the same location A.
In general, we extend the syntax of the global calculus to annotated interactions.
As for the new constructs introduced in this paper, we would have:
R ::= ... | Aτ1 → Bτ2 : b(s)[t˜, R, Rj]
| try(t˜) {R} catch { Rj }
| throwA,τ
where each τi is a natural number. We call τ, τj,... occurring in an annotated interaction, threads.
Example 4.1 Below, we shows a possible but not unique annotation of the financial protocol with broker.
Buyer1 → Broker2 : chBroker(s) [s,
Buyer1 → Broker2 : s(identify, id, x) .
if bad(x)@Broker2 then throwBroker, 2
else Broker2 → Seller3 : chSeller(t)[(s, t),

Seller	3	2
⎫⎪	⎪

rec X3	. Seller → Broker
: t(update, quote, y) .
⎪⎬	⎪

Broker2 → Buyer1 : s(update, y + 10%, y) .
⎪ default ⎪⎪⎬



Seller3 → Broker2 : t(conf, cnum, x) .	⎫	⎪
⎪

Broker2 → Buyer1 : s(conf, x, x) .
Buyer1 → Broker2 : s(data, credit, x) .
Broker2 → Seller3 : t(data, x, x)],
⎪⎪⎬ handler
⎪⎪⎭
⎪
⎪⎪⎭

Broker2 → Buyer1 : s(reject, reason, x) . R ]	} handler
□
Thread Projection and Coherence. In this subsection, we discuss, together with the definition of coherence, the notion of thread projection i.e. given an anno- tated global description I, how can we generate the end-point behaviour associated to each of its threads.
As an example, the choreography A1 → B2 : s(op, e, x) contains two threads (thread 1 and 2). The projection of thread 1 is an output of expression e on session channel s with operation op i.e. s!op(e). On the other hand, the projection of thread 2 is s?op(x).

Unfortunately, when adding the exception mechanism to the global calculus, projection is not so straightforward when it comes to the thread projection of the
session initiation A1 → B2 : b(s)[t˜, I, J]. In fact, such an operation also contains the refinement t˜. Now, consider the following possible projection, for κ˜ being a polarised
version of t˜:

(thread 1)	b(s+)[κ˜, projection(I, 1), projection(I, 1)]
(thread 2)	!b(s–)[projection(I, 2), projection(I, 2)]
Is the above projection correct? Unfortunately, global interaction I could further refine t˜ in a service invocation from B to a third participant and the thread above would not be ready to deal with a refined handler. A similar argument could be done for thread 2. In order to further clarify, let us consider the following annotated choreography:

A1 → B2 : b(s)[s,
B2 → C3 : c(t)[(t, s),
C3 → B2 : t(op1, e1, x1) . B2 → A1 : s(op2, e2, x2),
C3 → B2 : t(op3, e3, x3) . B2 → A1 : s(op4, e4, x4) ],
B2 → A1 : s(op5, e5, x5) ]

When we project thread 1, we must take into consideration that, after the refine- ment in line 2, such a thread is involved in another handler in the line 4 besides the outermost handler in line 5. Therefore, we must make sure that the thread projection of 1 provides a single handler ready to input with both operations op4 and op5 (lines 4 and 5). The solution is to merge the outermost handler in the fifth line with any other nested handler involving thread 1. In [4], thread merging is a partial operation between threads that allows differences in branches which do not overlap. If two end-point behaviours are mergeable, we can merge them and obtain a single process which simulates both of the two behaviours, by combining missing branches from the both. For instance, in the above example the projection of thread 1 would result into

b(s+)[s+,	s+?op2(x2),	merge(s+?op5(x5), s+?op4(x4)) ]

where merge(s+?op5(x5), s+?op4(x4)) = s+?{op5(x5) + op4(x4)).
As mentioned above, merging is not always feasible e.g. in the example above op5 = op4 would not be allowed. In general, a well-threaded, consistently annotated interaction is coherent if for each of its threads, the thread projection is well-defined.
We conclude this section by showing the thread projection of the Financial Protocol with Broker.
Example 4.2 (Thread Projection of Financial Protocol with Broker). Hereby, we apply the projection function to generate the end-point code for the three threads reported

in the previous section annotating the financial protocol with broker. For thread 1, we have that TP(Protocol, 1) is:

chBroker(s+)[s+,
s+!identify(id) . rec X . s+?update(y) . if (y < 100) then throw else X,
merge(s+?conf(x) . s+!data(credit), s+?reject(x) . P) ] 

where the merging merge(s+?conf(x) . s+!data(credit), s+?reject(x) . P) is equal to s+?(conf(x) . s+!data(credit) + reject(x) . P) where P is the thread projection of 1 in R. The projection of thread 2, TP(Protocol, 2) is

∗chBroker(s–)[
s–?identify(x) . if bad(x) then throw	⎫⎪



else chSeller (t+)[(s–, t+),
}	⎪⎪⎬ default

rec X . t+?update(y) . s–!update(y + 10%) . X
default

t+?conf(x) . s–!conf(x) . s–?data(x) . t+!data(x)],	}
handler ⎪⎭

s–!reject(reason) . R ]	} handler

Finally, thread 3 has the following projection:

∗chSeller(t–)[ rec X . t–!update(quote) . X, t–!conf(cnum) . t–?data(x) ] 

Note that thread projection is not participant projection. In fact, each partici- pant may contain more than one single service (unlike this example meant to focus on the exception aspect of choreography).
Conclusions
We have introduced the notion of exception for choreography. In particular, we have extended the syntax of the global calculus [3,4] with the exception mechanism and given its formal semantics. The aim of this work was to show how exceptions can be used at choreography level and, with examples, how they can be mapped to end-points. In the global calculus, exceptions are a simple form of transferring execution to a different choreography. But, together with a sound end-point pro- jection, choreography becomes a powerful tool for designing end-point behaviour where the raising of an exception will transfer the execution of all end-points to an exception handling interaction.
Future Work. The global calculus with exceptions introduced in this work is still limited to some basic operators and only includes values in messages. One point that needs further investigation is to allow the passing of service and session channels although this problem should also be carefully studied at end-point level.

The end-point projection has only been analysed through examples but it has been revealed that it does not follow directly from the work done in [4]. However, the three conditions for guaranteeing end-point projection need to be formally defined and a theorem stating the correctness of the EPP must be proved. In particular, we need to understand how to formally define the thread projection of run-time terms such as try-catch blocks and queues.
Related Work. The global calculus was first introduced in [3]. The version in- troduced in this work is an extension of the previous one in the fact that it also models interactional exceptions. The end-point projection has already been studied for choreography in general (e.g. [4,2]). The ideas contained in this work follow strictly the ones in [4] but propose further relaxations which have not been con- sidered before. Exceptions in general have been studied for many programming languages including communication-based ones: in concurrent programming of dis- tributed objects, [11] proposes an algorithm to resolve multiple kinds of exceptions among concurrently running objects is proposed; [1] introduces a model for long- running transactions which treats failures by restoring the initial state and firing a compensation process; the calculus for web services called COWS [8] provides an operation to kill processes except those protected by wraps similar to our exception mechanism; [9] introduces a calculus for web services by extending the π-calculus with exceptions. None of the aforementioned works relays on interactional excep- tions, where conversations among peers together move to different ones when an exceptions is thrown.

References
L. Bocchi, C. Laneve, and G. Zavattaro. A calculus for long-running transactions. In FMOODS’03, LNCS, pages 124–138. Springer, 2003.
N. Busi, R. Gorrieri, C. Guidi, R. Lucchi, and G. Zavattaro. Choreography and orchestration conformance for system design. In Coodination’06, volume 4038 of LNCS, pages 63–81, 2006.
M. Carbone, K. Honda, and N. Yoshida. A calculus of global interaction based on session types. In
2nd Workshop on Developments in Computational Models (DCM), ENTCS, 2006.
M. Carbone, K. Honda, and N. Yoshida. Structured Communication-Centred Programming for Web Services. In 16th European Symposium on Programming (ESOP’07), volume 4421 of LNCS, pages 2–17. Springer, 2007.
M. Carbone, K. Honda, and N. Yoshida. Structured interactional exceptions for session types. In 19th International Conference on Concurrency Theory (Concur’08), LNCS, pages 402–417. Springer, 2008.
K. Honda, V. T. Vasconcelos, and M. Kubo. Language Primitives and Type Disciplines for Structured Communication-based Programming. In 7th European Symposium on Programming (ESOP’98), volume 1381 of LNCS, pages 22–138. Springer-Verlag, 1998.
K. Honda, N. Yoshida, and M. Carbone. Multiparty asynchronous session types. In 35th Symposium on Principles of Programming Languages (POPL’08), pages 273–284. ACM, 2008.
A. Lapadula, R. Pugliese, and F. Tiezzi. A calculus for orchestration of web services. In 16th European Symposium on Programming (ESOP’07), volume 4421 of LNCS, pages 33–47. Springer, 2007.
H. Vieira, L. Caires, and J. Seco. The conversation calculus: A model of service oriented computation. In 17th European Symposium on Programming (ESOP’08), volume 4421 of LNCS, pages 269–283. Springer, 2008.
Web Services Choreography Working Group. http://www.w3.org/2002/ws/chor/.

J. Xu, A. B. Romanovsky, and B. Randell. Concurrent exception handling and resolution in distributed object systems. IEEE Trans. Parallel Distrib. Syst., 11(10):1019–1032, 2000.
