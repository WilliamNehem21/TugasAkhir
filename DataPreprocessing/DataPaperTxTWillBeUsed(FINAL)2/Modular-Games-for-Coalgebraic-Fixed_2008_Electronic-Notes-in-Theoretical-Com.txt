Electronic Notes in Theoretical Computer Science 203 (2008) 71–92	
www.elsevier.com/locate/entcs

Modular Games for Coalgebraic Fixed Point Logics
Corina Cˆırstea1,2
School of Electronics and Computer Science University of Southampton
Mehrnoosh Sadrzadeh1,3
Laboratoire PPS Universit´e Paris Diderot - Paris 7

Abstract
We build on existing work on finitary modular coalgebraic logics [3,4], which we extend with general fixed points, including CTL- and PDL-like fixed points, and modular evaluation games. These results are gener- alisations of their correspondents in the modal μ-calculus, as described e.g. in [19]. Inspired by recent work of Venema [21], we provide our logics with evaluation games that come equipped with a modular way of building the game boards. We also study a specific class of modular coalgebraic logics that allow for the
introduction of an implicit negation operator.
Keywords: coalgebra, modal logic, fixed point logic, parity games


Introduction
Modular coalgebraic logics were introduced in [3,4], where it was shown that the syntax and semantics of logics for T-coalgebras, with T an ω-accessible Set functor, can be defined modularly by exploiting the structure of T, and moreover, that expressiveness of the resulting logics w.r.t. behavioural equivalence, as well as sound and complete proof systems for these logics, can also be derived modularly. In terms of expressivity, these logics are more expressive than logics induced by monadic predicate liftings, as considered in [16], but are as expressive as logics induced by finitary polyadic predicate liftings, as defined in [17].

1 Research supported by the EPSRC grant EP/D000033/1.
2 Email: cc2@ecs.soton.ac.uk
3 Email: mehrs@comlab.ox.ac.uk

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.05.020

Coalgebraic fixed point logics were first considered in the work of Venema [21], where a finitary version of the coalgebraic logic of Moss [14] was used as the underly- ing modal language. Our motivation for considering fixed point logics over different modal languages is rooted in our interest in verification techniques for systems modelled as coalgebras. In this setting, the logics obtained through the modular techniques described in [3] appear to be better suited as specification logics.
The syntax of modular coalgebraic logics is based on the notion of syntax con- structor [3], while their semantics uses a notion of one-step semantics for a syntax constructor [3], which generalises the predicate liftings of [16]. The logics obtained
from syntax constructors are originally boolean, but in order to ensure that fixed points have a well-defined semantics, we leave out negation from these languages. However, for the specific class of syntax constructors which are closed under duals
(that is, for each modality they specify, a semantically dual modality is also speci- fied), a safe negation becomes definable in the language, and thus the expressivity of the logic stays as before. For this class of syntax constructors, we also introduce a general way of defining CTL- and PDL-like fixed points, and illustrate their applica- bility via examples. For instance, we obtain the fixed points of Dynamic Epistemic Logic [2] via the coalgebraic semantics for this logic described in [5]. In standard model checking terminology, these fixed points are referred to as ‘alternation-free’,
and enjoy a linear-time model checking algorithm based on parity games [8].
The results concerning the implicit negation and the alternation-free fragments of our logics make use of the notion of an S-modality (of some finite arity), with S a syntax constructor with an associated one-step semantics. This notion also allows us to relate logics induced by sets of polyadic predicate liftings, as considered in [17], with logics induced by syntax constructors. As a result, we obtain a way to add fixed points to logics of the former type.
In [21], deciding about the satisfaction of formulae by states of a coalgebra is achieved through deciding the winner of so-called evaluation games. These are parity games that generalize those for the modal μ-calculus [15,7,10,19,20,22], by replacing the usual single moves of either the verifier or the refuter in positions that correspond to modal formulae by two consecutive moves: a move of the verifier, who has to exhibit a relation between sub-formulae of the original formula and states of the coalgebra, that witnesses the satisfaction of the given modal formula by a state of the coalgebra, and a move of the refuter, who has to choose an element of this relation. These two consecutive moves are, in turn, inspired by similar moves in the bisimulation game of Baltag [1].
We introduce a variant of the evaluation games of [21] tailored to our fixed point logics, and prove their adequacy w.r.t. the standard coalgebraic semantics. The only difference w.r.t. [21] is in the moves corresponding to modal positions, where the one-step semantics for the syntax constructor defining the underlying modal language is used to define the valid moves. The distinctive feature of our games, however, is that they come equipped with one-step games. These adequately replace the two consecutive moves, of the verifier followed by the refuter, in modal positions, by an equivalent sub-game played between the verifier and the refuter.

The use of one-step games has some advantages: on the one hand, it provides a way to construct the board of the evaluation games by induction on the structure of the signature functor ; on the other hand, only witnessing relations that are relevant to deciding the winner of an evaluation game are accounted for in the one-step games, thus significantly reducing the size of the resulting parity games.

Preliminaries
Existing work [3] shows how to modularly derive coalgebraic modal logics for inductively-defined classes of endofunctors, including the class of so-called poly- nomial functors (that is, functors defined inductively on the identity, constant, powerset and discrete probability distribution functors, using products, coproducts, exponentiation and functor composition). A modal language with finitary modali- ties can be defined using a syntax constructor [3], that is, an inclusion-preserving, ω-accessible set endofunctor S : Set → Set. Given a syntax constructor S, the (negation-free) modal language LS it induces is the least set of formulae which is closed under finite (including empty) conjunctions and disjunctions and under the application of S. Equivalently (using the ω-accessibility of S), LS is defined induc- tively by:
LS e φ := ff | tt | φ ∨ φ | φ ∧ ψ | Ψ
where Ψ ∈ S(F ) with F ⊆ LS finite.
Simple syntax constructors can be used to define modal languages for (coalgebras of) the constant, identity, powerset and discrete probability distribution functors, as follows:
SA(L)= {a, ¬a | a ∈ A} SId(L)= {◯φ | φ ∈ L} SP(L)= { φ, φ | φ ∈ L}
SD(L)= {Lpφ, Gpφ | φ ∈ L, p ∈ [0, 1] ∩ Q}
In the definition of SD, Lpφ is to be read as “φ holds in the next state with probability at least p”, whereas Gpφ is to be read as “φ holds in the next state with probability greater than p”.
Syntax constructors can be combined to obtain modal languages for (coalgebras of) functors structured using products, coproducts, exponentiation with constant exponent E and functor composition, as follows:

(S1 ⊗ S2)(L)= {[πi]φ | φ ∈ Si(L),i = 1, 2}
(S1 ⊕ S2)(L)= {[κi]φ, ⟨κi⟩φ | φ ∈ Si(L),i = 1, 2}

(S ⊙ E)(L)= {[e]φ | e ∈ E, φ ∈ S(L)}

(S1 ◎ S2)(L)= S1(S2(L))
where · denotes closure under finite (including empty) conjunctions and disjunc- tions. For a polynomial functor, the resulting syntax can be expressed using a BNF with multiple levels, one for each ingredient of the functor [3,4].

Example 2.1 An alternative way of associating a syntax constructor with each ω-accessible, weak pullback preserving endofunctor T : Set → Set is to take S = T. This is the approach followed in [14] 4 .
We note that all of the above definitions are negation-free variants of the defini- tions in [3]. The restriction to negation-free fragments is a common way to ensure that fixed point logical operators defined on top of these languages have a well- defined (fixed point) semantics, see e.g. [19].
Given a functor T and a syntax constructor S, a semantics for the modal lan- guage LS w.r.t. T-coalgebras can be obtained from a one-step semantics for S
w.r.t. T [3]. Given a set L (of formulae) and a set X (of points), a one-step seman- tics [[S]] for S w.r.t. T maps interpretations of the formulae in L over the elements
of X (given by functions d : L → PX, or equivalently, by relations |= ⊆ X × L) to interpretations of the formulae in SL over the elements of TX (given by func- tions d' : SL → PTX, or by relations |=' ⊆ TX × SL), see [3] for details. (Here,
P : Set → Set also denotes the powerset functor, but a different notation is em-
ployed when this functor is not used as a signature functor.) The interpretation of formulae in LS over the states of a T-coalgebra (C, γ) is then defined inductively on the structure of formulae, by
c |= Ψ	iff	γ(c) ( [S]] |=Base(Ψ))Ψ 

and the usual definitions for finite conjunctions and disjunctions, where for Ψ ∈ S(F ) with F ⊆ LS, Base(Ψ) is the smallest F with this property, while
|=Base(Ψ) is the restriction of the relation |= ⊆ C × LS to C × Base(Ψ) (and thus
([[S]] |=Base(Ψ)) ⊆ TC × S(Base(Ψ))).
One-step semantics for the syntax constructors SA, SId, SP and SD can be defined in a natural way. Specifically, they map a relation |= ⊆ X×L to the relations [SA]] |=, [[SId]] |=, [SP]] |=, [SD]] |= defined as follows:

μ ([[SD]] |=) Lpφ	iff	μ(x) ≥ p
x|=φ
μ ([[SD]] |=) Gpφ	iff	μ(x) > p 
x|=φ
Also, one-step semantics for syntax constructors built using  ⊗ ,  ⊕ ,  E and
◎ , w.r.t. functors built using products, coproducts, exponentiation with constant exponent E and respectively functor composition, can be modularly derived from

4 The restriction regarding the ω-accessibility of T is not present in [14]. Here it is required since we are concerned with languages with finitary modalities.

one-step semantics for the ingredient syntax constructors [3]. Concretely, if [Si]] is a one-step semantics for Si w.r.t. Ti, with i = 1, 2, then the one-step semantics [[S1 ⊗ S2 ] for S1 ⊗ S2 w.r.t. T1 × T2, [[S1 ⊕ S2 ] for S1 ⊕ S2 w.r.t. T1 + T2, [[S1 ⊙ E]]
for S1 ⊙ E w.r.t. T1E and [S1 ◎ S2 ] for S1 ◎ S2 w.r.t. T1 ◦ T2 are defined by:

where ιi : TiX → T1X + T2X are the coproduct injections, and ([[S1 ◎ S2]] |=) = ([[S1]][[S2]] |=)
for each |= ⊆ X × L, where [[S2]] |= ⊆ T2X × S2L denotes the natural extension of
the relation ([[S2]] |=) ⊆ T2X × S2L to formulae containing finite conjunctions and disjunctions. (See [3] for further details.)
Example 2.2 Given an ω-accessible endofunctor T, a one-step semantics for the syntax constructor S = T w.r.t. the functor T can be defined by mapping each relation |= ⊆ X ×L to the relation |=T ⊆ TX × TL defined by t |=T Φ iff there exists w ∈ (T |=) such that Tπ1(w) = t and Tπ2(w) = Φ. (Here, π1 : X × L → X and π2 : X × L → L denote the canonical projections.)
Example 2.3 Transition systems with spatial structure were proposed in [13] as a general model for spatial logic. They are defined as coalgebras of the functor T = P×(1+P◦(Id×Id)), where 1 denotes the constant functor induced by a one-element set. Thus, T-coalgebras incorporate non-deterministic structure, through the first component of T, as well as spatial structure, through the second component of T. As far as the spatial structure is concerned, a one-step observation of 0 ∈ 1 corresponds to inactive states, whereas a one-step observation in P◦(Id×Id) describes the spatial structure of active states; for the latter, the empty set describes states which are local, i.e. have no spatial structure. By applying the modular techniques described in [3] to this functor, one arrives at a modal language with the following (multi- sorted) syntax, where the formula sort of interest is L1 and the remaining sorts are merely used to define this sort:
L1 e φ ::= ff | tt | φ1 ∨ φ2 | φ1 ∧ φ2 | [π1]ψ | [π2]χ	(ψ ∈ L2,χ ∈ L3) L2 e ψ ::= ff | tt | ψ1 ∨ ψ2 | ψ1 ∧ ψ2 | φ |  φ		(φ ∈ L1) L3 e χ ::= ff | tt | χ1 ∨ χ2 | χ1 ∧ χ2 | [κ1]ξ | [κ2]ζ | ⟨κ1⟩ξ | ⟨κ2⟩ζ  (ξ ∈ L4,ζ ∈ L5) L4 e ξ ::= ff | tt | ξ1 ∨ ξ2 | ξ1 ∧ ξ2 | 0 | ¬0
L5 e ζ ::= ff | tt | ζ1 ∨ ζ2 | ζ1 ∧ ζ2 | [π1]φ | [π2]φ	(φ ∈ L1)

Both the temporal and the spatial modalities defined in [13] can now be recovered, namely by defining:  φ := [π1] φ,  φ := [π1] φ, 0 := [π2]⟨κ1⟩0, φ1 | φ2 := [π2]⟨κ2⟩ ([π1] ◯ φ1 ∧ [π2] ◯ φ2) (where the notation for the  ,  and 0 modalities has been overloaded in order to maintain the notation of [13]). We note that the

above language is a negation-free version of the language of [13], but, as we will see in Section 3.3, this does not lead to a loss in expressivity.
Example 2.4 Simple Segala systems [18] can be modelled as coalgebras of the functor (P ◦ D)E . The one-step observations one can make about the states of such systems consist of non-deterministic transitions into discrete probability distribu- tions over states. This mirrors the original definition of simple Segala systems, which divides the states into non-deterministic and probabilistic ones, the former being observed through non-deterministic transitions into the latter, and the latter being observed through probabilistic transitions back to the former. The language induced by (SP ◎ SD) E is a negation-free variant of the language considered in [11], and contains modalities of the form [e] Lp and [e] Gp with e ∈ E.

Modular Coalgebraic Fixed Point Logics
From now on we restrict our attention to syntax constructors with an associated one-step semantics that is monotonic in the following sense.
Definition 3.1 (Monotonic one-step semantics) Given interpretations d, d' : L → PX, we write d ⊆ d' if d(φ) ⊆ d'(φ) for each φ ∈ L. A one-step semantics [[S]] for a syntax constructor S is said to be monotonic if, for each d, d' : L → PX, we have that d ⊆ d' implies [[S]](d) ⊆ [[S]](d').
It is easy to check that all syntax constructors considered in Section 2 are monotonic:
Proposition 3.2 SA, SId, SP and SD are monotonic. Moreover, if S1 and S2 are monotonic, so are S1 ⊗ S2, S1 ⊕ S2, S1  E and S1 ◎ S2.
Syntax
By adding fixed point formulae to the language LS, we obtain the following lan- guage:
μLS(V) e φ := ff | tt | φ ∨ φ | φ ∧ ψ | Ψ | x | μx.φ | νx.φ
where V is a set of variables, x ∈ V, and Ψ ∈ S(F ) with F ⊆ μLS(V) finite.
Example 3.3 The fixed point languages of SP and SP ⊙ E are the mono- and multi-modal propositional μ-calculi (of e.g. [19]), respectively.

Semantics
The interpretation of formulae in μLS(V) over the states of a T-coalgebra (C, γ) is defined w.r.t. a valuation V : V → P(C), as follows:
c |=V Ψ ∈ S(F )	iff	γ(c) ( [S]]|=V,Base(Ψ))Ψ 
c |=V x	iff	c ∈ V (x)
c |=V μx.φ	iff	 c ∈  B ⊆ C | [[φ]]V [B/x] ⊆ B} c |=V νx.φ	iff	c ∈  B ⊆ C | B ⊆ [[φ]]V [B/x]}

where
[[φ]]V = c ∈ C | c |=V φ} V [B/x](y) = 
V (y)	o.w.

and the relation |=V,Base(Ψ) ⊆ C × Base(Ψ) gives the interpretation of formulae in
Base(Ψ) over the states of (C, γ).
The absence of negation in the language and the monotonicity of the one-step semantics [S ] ensure that the semantics for fixed point formulae is well-defined:
Lemma 3.4 (Monotonicity) Let (C, γ) be a T-coalgebra, φ ∈ μLS(V), and V, V ' : V → P(C) two valuations such that V (x) ⊆ V '(x) for all x ∈ V. Then, for c ∈ C, we have: c |=V φ implies c |=V ' φ.
Proof (Sketch) The statement is proved by structural induction on φ. The case where φ ∈ SF with F ⊆ μLS(V) finite uses the monotonicity of [S]].	 
The previous lemma ensures that, for a T-coalgebra (C, γ), a valuation V : V → P(C) and a formula φ ∈ μLS(V), the map X ∈ P(C) '−→ [[φ]]V [X/x] ∈ P(C) is a monotone map on the complete lattice P(C), and therefore by the Knaster-Tarski theorem, this map has a least and a greatest fixed point; these fixed points can be computed as the intersection of all pre-fixed points and the union of all post-fixed points, respectively.
Example 3.5 [[SP ] and [SP ⊙ E ] provide semantics for the languages of mono- and multi-modal propositional μ-calculus (of e.g. [19]), interpreted over transition systems and labelled transition systems, respectively.

Simulating Negation
It is worth noting that, for languages where the semantic dual of each modal operator is also in the language, we do not lose any expressivity by leaving out the negation operator. We will show that, in this case, negation can be implicitly defined. To this end, we introduce the notions of an S-modality, and of a dual modality.
Definition 3.6 (S-modality) For a syntax constructor S and n ∈ ω, an S- modality of arity n is an element of S(n) which does not belong to any of S(1),..., S(n − 1) 5 .
Thus, an S-modality a of arity n is a modal operator which takes n arguments; the set n = {0,...,n − 1} is used to define the placeholders for the arguments of a.
Next, we define what it means to apply an S-modality of arity n to a set of n
formulae.
Definition 3.7 If a is an S-modality of arity n and φ1,..., φn ∈ μLS(V), we deﬁne a(φ1,..., φn) as S([φ1,..., φn])(a) ∈ μLS(V), where [φ1,..., φn] : n → {φ1,..., φn} maps i to φi+1 for i = 0,...,n − 1.

5 Recall that S is inclusion-preserving.

We also note that a one-step semantics [S ] for S w.r.t. T automatically provides a (coalgebraic) semantics for each S-modality.
Example 3.8 The  and  operators specified by the syntax constructor SP are unary SP-modalities, when identified with the two elements of SP(1).
Example 3.9 For the spatial transition systems of Example 2.3, the modal oper- ator 0 is an S-modality of arity 0, the temporal operators   and   are unary S-modalities, while the spatial operator | is a binary S-modality.
Incidentally, the notion of S-modality allows us to relate languages induced by finitary polyadic predicate liftings, as considered in [17], on the one hand, and languages induced by syntax constructors with associated one-step semantics on the other. To this end, we write Pˆ : Set → Set for the contravariant powerset functor. Given a set Λ of ﬁnitary polyadic predicate liftings for a functor T (that is, natural transformations λ : Pˆn → PˆT with n ∈ ω), a syntax constructor SΛ : Set → Set can be defined by
SΛ(L) = {λ(φ1,..., φn) | λ ∈ Λ has arity n, φi ∈ L for i = 1,..., n}
while a one-step semantics [SΛ ] for S w.r.t. T can be defined by mapping an inter- pretation d : L → PX to the interpretation d' : SΛL → PTX given by
d'(λ(φ1,..., φn)) = λX (d(φ1),..., d(φn)) for φ1,..., φn ∈ L
Thus, SΛ-modalities of arity n are exactly the n-ary predicate liftings of Λ and, as expected, the semantics of these modal operators agree with each other. Now monotonicity of the one-step semantics [SΛ ] amounts to the predicate liftings λ : (Pˆ)n → PˆT being monotonic in all arguments. Consequently, our approach can be used to add fixed points to logics induced by sets of monotonic predicate liftings.
We now return to the issue of simulating negation in the language μLS(V). For a given set of formulae L, we introduce a syntactic negation for the formulae of L via the set Lc := {φc | φ ∈ L}. Now for a given set of points X, an interpretation relation |= ⊆ X × L is extended to negated formulae in Lc via the relation |=c ⊆ X × Lc given by

x |=c φc	iff	x /|= φ	for x ∈ X and φ ∈ L
Definition 3.10 (Closure under duals) A syntax constructor S with a one-step semantics [[S]] is said to be closed under duals if, for each S-modality a, there exists an S-modality a of arity n, called the dual of a, such that for each relation
|= ⊆ X × L, the relation |=' = [[S]](|= ∪ |=c) ⊆ TX × S(L ∪ Lc) satisﬁes
t |=' a(φ1,..., φn)	iff	t /|=' a(φc,..., φc )
1	n
Thus, S is closed under duals if, whenever it specifies a modality, then it also specifies its semantic dual.

Example 3.11 The syntax constructors SA, SId, SP and SD with their associated one-step semantics are closed under duals. In particular, we have a = ¬a, ◯ = ◯,
  =  and Lp = G1−p for 0 ≤ p ≤ 1.
Proposition 3.12 If the syntax constructors for all the ingredients of a polynomial functor T (with their respective one-step semantics) are closed under duals, then so is the combined syntax constructor for T (with the one-step semantics deﬁned modularly from the one-step semantics w.r.t. its ingredients).
Proof (Sketch) The statement follows from the definitions of S1 ⊗ S2, S1 ⊕ S2, S1 E and S1 ◎ S2 and of the associated one-step semantics, together with the observations that, if ai is an Si-modality, for i = 1, 2, then [πi]ai = [πi]ai, [κi]ai =
⟨κi⟩ai and [e]ai = [e]ai, and that the dual of an S1 ◎ S2-modality can be defined in terms of the duals of S1- and S2-modalities; for example, if ai is a unary Si-modality, with i = 1, 2, then a1a2 = a1 a2.	 
As a consequence of Proposition 3.12, the modal language for spatial transition systems described in Example 2.3 is closed under duals.
We now observe that any Ψ ∈ S(F ) with F finite is of the form a(φ1,..., φn), with a an S-modality. If Base(Ψ) = {φ1,..., φn}, then since S(Base(Ψ)) is iso- morphic to S(n) (via S([φ1,..., φn])), there must exist an a ∈ S(n) such that Ψ = S([φ1,..., φn])(a), that is, Ψ = a(φ1,..., φn). Moreover, by the minimality of
Base(Ψ), it follows that a can not come from any of S(1),..., S(n − 1). Thus, a is an S-modality of arity n.
We note in passing that the above argument also applies to the case S = T, that is, to the finitary version of Moss’ coalgebraic logic [14]. Thus, when T is ω- accessible, the finitary version of the ∇ modality, considered in [21], can be regarded as a shorthand for an infinite number of modalities, each with a specific finite arity.
The previous observation is used in the following definition.
Definition 3.13 (Negation) For a syntax constructor S which is closed under duals, the negations of formulae in μLS(V) are deﬁned inductively as follows:
ffc := tt	ttc := ff
(φ ∨ ψ)c := φc ∧ ψc	(φ ∧ ψ)c := φc ∨ ψc
(a(φ1,..., φn))c := a(φc,..., φc )	xc := x
1	n
(μx.φ)c := νx.φc	(νx.φ)c := μx.φc
Proposition 3.14 For a state c of a T-coalgebra (C, γ), a valuation V : V → P(C), and a formula φ ∈ μLS(V) we have
c |=V φ	iff	c /|=V c φc
where V c : V → P(C) is given by V c(x) = C \ V (x) for x ∈ V.
Proof. The statement follows from Definitions 3.10 and 3.13 and the definition of
|=V .	 

In order to account for some interesting examples, we now introduce the notion of a derived S-modality. Intuitively, a derived modality involves applications of S- modalities as well as of boolean operators, with nested applications of S-modalities not being allowed.
Definition 3.15 (Derived S-modality) For a syntax constructor S and n ∈ ω, a derived S-modality of arity n is an element of S(n), which does not belong to any of S(1),..., S(n − 1).
It follows easily that, when S is closed under duals, for each derived S-modality one can also define a semantic dual, again as a derived S-modality.
Example 3.16 In the case of spatial transition systems, that is, coalgebras of the functor T = P × (1 + P ◦ (Id × Id)), | tt, tt | ∈ ST(1) ⊆ ST(1) are derived ST- modalities of arity 1 (where the binary modality | was defined in Example 2.3). Their duals are (semantically equivalent to) [π2][κ2] [π1] ◯ and [π2][κ2] [π2] ◯ , respectively.
We conclude this section by looking at conjunction-preserving modalities. These will play a roˆle when defining until- and dynamic-like fixed points in the next section.
Proposition 3.17 For a syntax constructor S with an associated one-step seman- tics [[S]], a (derived) S-modality of arity n preserves conjunctions if and only if its dual preserves disjunctions.
Proof. Follows from Definitions 3.10 and 3.13 and Proposition 3.14.	 
Example 3.18 ◯ is both conjunction- and disjunction-preserving, whereas is conjunction-preserving. The SD-modalities are neither conjunction- nor disjunction- preserving, with the exception of L1 ≡ G0, defined as

where L1 is conjunction-preserving and its dual G0 is disjunction-preserving.
Example 3.19 The modalities	| tt, tt |	of Example 3.16 are disjunction- preserving, whereas their duals are conjunction-preserving.
Conjunction-preserving S1 ⊗ S2-, S1 ⊕ S2-, S1  E- and S1 ◎ S2-modalities can be derived from conjunction-preserving S1- and S2-modalities, as shown next.
Proposition 3.20 Let Si be a syntax constructor with one-step semantics [[Si]], for i = 1, 2. If ai is a conjunction-preserving (derived) Si-modality, for i = 1, 2, then so are [πi]ai (as an S1 ⊗ S2-modality), [κi]ai (as an S1 ⊕ S2-modality), [e]a1 (as an S1  E-modality) and, in the case of modalities of arity 1, also a1a2 (as an S1 ◎ S2-modality).
Proof (Sketch) The conclusion follows by noting that [πi], [κi] and [e] are conjunction-preserving (by the definitions of [S1 ⊗ S2]], [[S1 ⊕ S2]] and [[S1  E]]), and that the successive application of conjunction-preserving modalities is itself conjunction-preserving.	 

Macros
As in the propositional μ-calculus, one can distinguish fragments of our coalgebraic fixed point logics that have desirable properties, for example the independent ﬁxed point fragment IμLS(V) and the alternation-free fragment AμLS(V). For σ1, σ2 ∈
{μ, ν} and writing Subf (φ) for the set of sub-formulae of a formula φ ∈ μLS(V), these fragments are defined as follows:
φ ∈ IμLS(V) iff σ1 x.φ1 ∈ Subf (φ) and σ2 y.φ2 ∈ Subf (φ) implies that x is not free in φ2 and y is not free in φ1;
φ ∈ AμLS(V) iff μ x.φ1 ∈ Subf (φ) and ν y.φ2 ∈ Subf (φ) implies that x is not free in φ2 and y is not free in φ1.
While the IμLS(V)-fragment does not allow any dependency among the fixed point sub-formulae of a formula, the AμLS(V)-fragment allows dependency as long as the fixed points are of the same type. These fragments relate to each other as follows:

IμLS(V) ⊆ AμLS(V) ⊆ μLS(V)

The two well-known independent fixed point fragments of the propositional μ- calculus are CTL with its until fixed points, and PDL with its dynamic fixed points, see [19] for details. The definitions of these special fixed point formulae can be ex- tended to our general coalgebraic fixed point logic μLS(V).
Definition 3.21 Given a functor T, a syntax constructor S with a one-step seman- tics [[S]] w.r.t. T such that S is closed under duals, and a ﬁnite set α of conjunction- preserving, unary S-modalities 6 , until and dynamic fixed point formulae are deﬁned as follows:
A(φ Uα ψ) := μx.(ψ ∨ (φ ∧  a tt ∧  a x))

a∈α
E(φ Uα ψ) := μx.(ψ ∨ (φ ∧	a x))
a∈α
[ ]∗ φ := νx.(φ ∧  a x)
a∈α

a∈α
⟨ ⟩∗ φ := μx.(φ ∨  a x)
a∈α
where x ∈ V, φ, ψ ∈ μLS(V), x does not occur free in φ, ψ, and for a ∈ α, a is the dual of a.
We motivate our conjunction-preservation condition on the set α of S-modalities in Definition 3.21 by noting that, under this condition, the S-modality defined by
 αx := a∈α ax is itself conjunction-preserving, and thus can be regarded as a generalisation of the -modality used in the standard definitions of the until and dynamic modalities.

6 Derived S-modalities can also be considered here.

Proposition 3.22 The until and dynamic ﬁxed point formulae deﬁned above belong to the IμLS(V)-fragment of μLS(V).
Proof. Since x does not occur free in φ and ψ, neither will it occur free in any fixed point formulae that might occur in Subf (φ) or Subf (ψ).	 
Intuitively, the formula E(φ Uα ψ) is read as “there exists a route described by modalities in α along which φ holds until ψ holds”, whereas the formula A(φ Uα ψ) is read as “along all routes described by modalities in α, φ holds until ψ holds”. Particular choices for the set α can be obtained using Example 3.18 and Proposi- tion 3.20. Below we mention some choices for α which give us known fixed points.
Example 3.23 In the case of labelled transition systems, that is, coalgebras of the functor PE, the until operators of CTL (as defined e.g. in [19]) are recovered as A(φ Uα ψ) and E(φ Uα ψ) with α = {[e]  | e ∈ E}.
Example 3.24 In the case of spatial transition systems, taking α to consist of the duals of the two derived modalities of Example 3.16 yields the somewhere modality of spatial logic (as used e.g. in [6]):
φ = E(tt Uα φ) := μ x. (φ ∨ (tt | x) ∨ (x | tt))

Also, by taking α = { }, where  was defined in Example 2.3, one recovers the
sometime modality of spatial logic:
φ = E(tt Uα φ) := μ x. (φ ∨  x)
The duals of the above two modalities, defined using Definition 3.13 as (E(tt Uα φc))c for the respective choices of α, are the everywhere and respectively every time modalities of [6].
Example 3.25 As shown in previous work [5], coalgebras of the functor T = PE × (1+Id)E' ×C (subject to additional axioms) provide semantics for epistemic update. The language LS induced by S = (SP  E) ⊗ ((1 ⊕ SId)  E') ⊗ SC gives rise to a modular coalgebraic logic for T, which is shown in [5] to be equivalent to the Dynamic Epistemic Logic (DEL) of [2]. By extending this language to μLS(V) and taking α = {[π1][e]  | e ∈ E}, one obtains a dynamic fixed point [ ]∗ φ, which is equivalent to the common knowledge fixed point of DEL. At the same time, taking α' = {[π2][e'][κ2] | e' ∈ E'} provides us with the update fixed point of DEL. Moreover, taking α ∪ α' provides us with a new dynamic modality that quantifies over both knowledge and update transitions.
Example 3.26 In the case of simple Segala systems, by taking α = {[e] L1 | e ∈ E}, the resulting until operator A(φ Uα ψ) requires that along every path (alternat- ing between non-deterministic and probabilistic transitions), φ holds until ψ holds (in the non-deterministic states reached along the path). In contrast, E(φ Uα ψ) requires the existence of a path along which φ holds until ψ holds.

Games
In this section we present a game-theoretic approach to deciding satisfaction between states of coalgebras and formulae of our fixed point logics.
Evaluation Games
We first recall the main definitions from the theory of two-player infinite games (see e.g. [8]). A graph game played between two players, here referred to as E and 6, is defined by:
a set Pos of positions, with each position belonging to exactly one player,
for each position of the game, a set of possible moves from that position,
an initial position.
A play in a graph game is a (finite or infinite) sequence of positions, such that the first position is the initial position, and each subsequent position is obtained by a valid move from the position immediately preceding it. A full play is either an infinite play or a finite play where there are no possible moves from the last position. A winning condition for a graph game associates, to each infinite play, a winner and a loser. (Finite plays are always lost by the player who can not move.) The winner of an infinite play can be defined e.g. via a parity winning condition – this involves defining a parity map Ω : Pos → ω with finite range, and letting E win exactly those infinite plays for which the maximum of those values Ω(p) that occur infinitely often in that play is even. A strategy for a player in a graph game maps partial plays ending in positions associated to that player to next moves for that player. A strategy is history-free if it only depends on the current position. A player is said to use a strategy in a play if all of his moves in that play obey the rules in the strategy. A strategy is winning for a player P from a position p ∈ Pos if P wins all plays starting in p by using the strategy.
Following [21], we now define a (parity) graph game for evaluating a formula of
μLS(V) in a state of a T-coalgebra.
Definition 4.1 (Evaluation game) Given a pointed T-coalgebra C = (C, γ, c0), a valuation V : V → У(C) and a clean 7 formula φ0 ∈ μLS(V), the evaluation

game SC,V
0
is an inﬁnite two-player game, played between E (who aims to verify the

statement c0 |=V φ) and 6 (who aims to refute this statement) as follows:
The positions of the game are elements of the set Pos = (C × Subf (φ0)) H (TC × Subf (φ0)) H У(C × Subf (φ0)). We use the superscript ( )o (for “observations”) for positions in TC × Subf (φ0), whenever we need to distinguish such positions from positions in C × Subf (φ0) 8 .
The possible moves are as follows 9 :

7 A formula φ is called clean if no variable occurs both free and bound in φ, and if different occurrences of fixed point operators do not bind the same variable.
8 As noted by one of our referees, this distinction is needed in the case when T = Id, to prevent several unfoldings of the coalgebra map in consecutive moves.
9 Whenever no player is associated to a position, this is because there is only one possible move from that


where σ ∈ {μ, ν} and for a variable x, μx.φx or νx.φx is the subformula of φ
which binds x.
The winning conditions of the game are as follows:
ﬁnite plays are lost by the player who can not move,
inﬁnite plays are won by E (respectively 6) if the outermost variable that is unfolded inﬁnitely often in that play 10 is a ν-variable (μ-variable).
In what follows, we will write Sc0 for SC,V whenever C and V are clear from the

context.
φ0	φ0

The only difference w.r.t. the evaluation games of [21] is the set of moves of E
in positions of type (t, ψ) ∈ TC × S(μLS(V)) – here, the one-step semantics of S
w.r.t. T is used to determine when a relation Z ⊆ C × Subf (φ0) can be regarded as a witness for (t, ψ). Indeed, the evaluation game of [21] can be obtained as a particular case, namely by taking S = T and [S ] as in Example 2.2.
We note that the winning condition of Sc0 for infinite plays can be reformulated
0
as a parity condition. This is done by first defining a map Ω : Subf (φ0) → ω subject
to the following constraints:
Ω(φ) = 0 unless φ = x with x ∈ BV ar(φ0),
for x ∈ BV ar(φ0), Ω(x) is odd if x is a μ-variable, and even if x is a ν-variable,
Ω(x) ≤ Ω(y) whenever the formula binding x is a subformula of the formula binding y.
A map Ω' : Pos → ω can then be defined by letting Ω'(c, φ) = Ω(φ). It can easily be

seen that the winning condition of Sc0
0
for infinite plays is equivalent to the parity

winning condition induced by Ω'; that is, the outermost variable that is unfolded
infinitely often in a play is a ν-variable iff the maximum of the values Ω'(c, x) which occur infinitely often in that play is even.
According to general results, see e.g. [7,15,19], and since the above evaluation games are parity games, they enjoy the history-free determinacy property, that is, in each position of the game, either E or 6 has a history-free winning strategy.
We now prove an adequacy result (of the evaluation game w.r.t. the semantics of fixed point formulae), which generalises a similar result in [21].

position, and thus it does not matter which player moves in such a position.
10 Since φ is clean, this variable is uniquely defined; see e.g. [21] for the proof of a similar result.

Theorem 4.2 (Adequacy of evaluation game) For  a  pointed  T-coalgebra
(C, γ, c), a valuation V : V → У(C), and a clean formula φ ∈ μLS(V) we have
c |=V φ iff	E has a history-free winning strategy in Sc from position (c, φ),
c /|=V φ iff	6 has a history-free winning strategy in Sc from position (c, φ).
Proof. The proof of the “only if” direction of the first statement is done by con- structing history-free winning strategies for E by induction on the structure of φ. The construction for non-modal formulae is as for the modal μ-calculus, and fol- lows the same line as the proof of the adequacy result in [21]. For formulae in S(μLS(V)), assume we are at position (c, Ψ) with Ψ ∈ SF and F ⊆ μLS(V) finite. Since c |=V Ψ, we have t ([[S]] |=V,Base(Ψ)) Ψ, where t = γ(c). A strategy for E in the game starting at position (t, Ψ) is obtained by extending the strategy coming from the induction hypothesis with the rule ‘at (t, Ψ) choose |=V,Base(Ψ) as Z’. This is a legitimate move, since t ([[S]] |=V,Base(Ψ)) Ψ and therefore (t, Ψ) ∈ [[S]](Z). To show that the resulting strategy is a winning strategy for E in the game starting at (c, Ψ), we show that it is impossible for 6 to win if E follows this strategy. Assume that, at position Z, 6 chooses (c', ψ) ∈ Z as the next position. (If Z is empty, then 6 loses immediately.) By the choice of Z, we have c' |=V ψ. Now by the induction hypothesis, E has a winning strategy starting from (c', ψ). We have thus proved that E wins in the game starting at (c, Ψ).
The proof of the “if” direction is also done by induction. For the modal case, assume we are at position (c, Ψ) with Ψ ∈ S(μLS(V)) and E has a winning strategy in the game starting at (c, Ψ). This strategy provides a certain Z ⊆ C × Subf (φ0) such that (t, Ψ) ∈ [[S]]Z, where t = γ(c). By the induction hypothesis, c' |=V ψ for all (c', ψ) ∈ Z, and thus Z ⊆ |=V . Now by the monotonicity of [S ] we have [S]]Z ⊆ [[S]] |=V , and hence (t, Ψ) ∈ [[S]] |=V . We have thus proved that t ([[S]] |=V ) Ψ, and therefore c |=V Ψ.
The second statement follows easily, since if c /|= φ, then by the first statement E does not have a (history-free) winning strategy in (c, φ), and by the determinacy property of parity games, 6 has a history-free winning strategy in (c, φ).	 
As a consequence of Theorem 4.2, we obtain a result about the implicit negation of a fixed point formula. Before stating this result, we define the complement of an evaluation game.
Definition 4.3 (Complement game) For a T-coalgebra C = (C, γ, c0), a val- uation V : V → У(C) and a clean formula φ0 ∈ μLS(V), the complement of the
c
evaluation game SC,V is the evaluation game SC,V , where φc is as in Deﬁnition 3.13
φ0	c
and V c is as in Proposition 3.14.
Analysing the definition of the complement of SC,V , we see that this game is ob-
0

tained from SC,V
0
by complementing the formulae defining the positions of SC,V ,
0

complementing the valuation V , and reversing the roles of E and 6.
Corollary 4.4 For a syntax constructor S with a one-step semantics [[S]] such that
S is closed under duals, a pointed T-coalgebra (C, γ, c0), a valuation V : V → У(C)

and a clean formula φ0 ∈ μLS(V), a player does not have a history-free winning

strategy in SC,V
0
iff he has a history-free winning strategy in its complement SC,V c .
0

Proof. From Proposition 3.14 it follows that c0 |=V φ0 iff c0 /|=V c φc. Then, by Theorem 4.2 and respectively the determinacy property, E has a history-free winning
strategy at (c0, φ0) in SC,V iff 6 has a history-free winning strategy at (c0, φc) in
SC,V c iff E does not have a history-free wining strategy at (c , φc) in SC,V . The case
c	0	c
0	0
for 6 is proved similarly.	 


One-Step Games
The evaluation game Sc0
0

has the drawback that in a position of type (t, ψ) ∈

OC × S(μLS(V)), some of the possible moves of E are not relevant when it comes to deciding the winner of the game. Indeed, only relations Z which are minimal among those with the property that (t, ψ) ∈ [[S]](Z) are relevant, as shown next.
Definition 4.5 Given a position (t, ψ) ∈ OC×SμLS(V) in the game Sc0 , a relation
0
Z ⊆ C×μLS(V) with the property that (t, ψ) ∈ [[S]](Z) is said to be minimal relative to (t, ψ) if there is no Z' ⊆ C × μLS(V) such that Z' Ç Z and (t, ψ) ∈ [[S]](Z').

Lemma 4.6 Let S˜c0
0
be the game obtained from Sc0
0
by only allowing relations Z

which are minimal relative to (t, ψ) as possible moves of E in positions of type

(t, ψ) ∈ OC × SμLS(V). Then E has a winning strategy in Sc0
0
iff he has a winning

strategy in S˜c0 .
0
Proof. Assume first that E has a winning strategy in Sc0 . This strategy provides,
0
for each position of type (t, ψ) ∈ OC ×SμLS(V), a relation Z ⊆ C ×μLS(V). Then, there exists Z' ⊆ Z (not necessarily unique) such that (t, ψ) ∈ [[S]](Z') and Z' is
minimal relative to (t, ψ). Thus, Z' is a legitimate move in the game S˜c0 . Since

6’s choices in Z'
are a subset of his choices in the position	φ0 c0 , and
0

since E had a winning strategy from each z ∈ Z in Sc0 , it follows that E also has a winning strategy from each z ∈ Z' in S˜c0 . We have thus proved that E has a winning strategy from (t, ψ) in S˜c0 . Now assume that E has a winning strategy in
S˜c0 . Since by always using this strategy when playing in Sc0 , the game stays inside
φ0	φ0
S˜c0 , it follows that E can also win in Sc0 with this strategy.	 
φ0	φ0
However, even if E’s moves are limited to the minimal Zs, it is not straight-
forward to identify these relations in the case of a complex functor O with an associated syntax constructor S and a one-step semantics [S ] for S w.r.t. O. To overcome this, we replace the two moves (of E followed by 6) from a position of type (t, ψ) ∈ OC × S(μLS(V)) to a position of type (c, φ) ∈ C × μLS(V), by a sequence of moves in a “sub-game” played by E and 6. This sequence of moves essentially constructs the minimal relations Z by induction on the structure of the functor O.
Moreover, E has a winning strategy in the modified game if and only if he has a winning strategy in the original one. The concept of a one-step game is used to define the above-mentioned sequence of moves.

Definition 4.7 (One-step game) A one-step game w.r.t. a functor O and a syn- tax constructor S is a graph game between E and 6, whose positions include positions of type (t, ψ) ∈ OX × SL and of type (x, φ) ∈ X × L, with X and L being arbitrary sets, and such that positions of type (x, φ) ∈ X × L are terminal, that is, they are not associated with either E or 6 and there are no moves deﬁned for these positions.
For each simple polynomial functor with corresponding syntax constructor and one-step semantics, we associate a one-step game which, when played instead of the two moves, of E followed by 6, in positions of type (t, ψ) ∈ OX × SL of the game S˜c0 , has the same effect as these two moves in terms of the positions being
0
reached. Moreover, we show how to obtain one-step games for functors built using
products, coproducts, exponentiation and functor composition by combining one- step games for the ingredient functors, and that these combinations preserve the adequacy property w.r.t. the original evaluation games.
Example 4.8  (i) A one-step game GA w.r.t. A and SA is given by:

A one-step game GId w.r.t. Id and SId is given by:

A one-step game GP w.r.t. P and SP is given by:

A one-step game GD w.r.t. D and SD is given by:

The above one-step games have been obtained by unfolding the definitions of [[SA]], [[SId]], [[SP]] and [[SD]], requiring minimality of the Zs in E’s moves, and sim- plifying the resulting one-step games by making implicit those steps where the sets of possible moves are singletons. For example, at position (t, φ) in GP, the only player that can move is 6, since in the original game E has no choice of a minimal relation but to move to {(t, φ) | φ ∈ Φ}. Similarly, at position (t, φ), only E can move, since all the minimal relations he can choose are singletons and thus 6 is left with no choice. It is also worth noting that, for O = P, the moves of the one-step

game are similar to the moves corresponding to modal positions in the games for the modal μ-calculus, see e.g. [19]. Finally, the game GD still requires two moves, one of E and one of 6, to go from positions of type (μ, ψ) ∈ DX × SDL to positions of type (x, φ) ∈ X × L. The underlying reason for this is that the modalities Lp and Gp are neither conjunction- nor disjunction-preserving, and thus both E and 6 have a real choice to make.
We now show how to obtain one-step games for complex endofunctors, by com- bining the one-step games for their ingredients.
Definition 4.9 (Combining one-step games) For i = 1, 2, let Gi be a one-step game w.r.t. Oi and Si.
A one-step game G1 ⊗ G2 w.r.t. O1 × O2 and S1 ⊗ S2 is obtained by adding the following moves to the union of the moves of G1 and G2:

A one-step game G1 ⊕ G2 w.r.t. O1 + O2 and S1 ⊕ S2 is obtained by adding the following moves to the union of the moves of G1 and G2:

A one-step game G  E w.r.t. OE and S  E is obtained by adding the following moves to the moves of G:

A one-step game G1 ◎ G2 w.r.t. O1 ◦ O2 and S1 ◎ S2 is given by the union of the moves of G1 and G2 and the following moves:

The moves corresponding to finite conjunctions and disjunctions in the defini- tions of G1⊗G2, G1⊕G2, G1 E and G1◎G2 have the roˆle of dealing with conjunctions and disjunctions occurring at inner levels in the structure of formulae in L(S). For example, if O = P × (1 + P ◦ (Id × Id)), (and thus O-coalgebras are spatial transition systems), the language induced by SP ⊗ (S1 + SP ◎ (SId ⊗ SId)) contains formulae of form [π2]⟨κ2⟩ ([π1] ◯ φ1 ∧ [π2] ◯ φ2). The binary conjunction in this formula will be dealt with in a move from a position of type P(X × X) × SIdL ⊗ SIdL. This is accounted for by the additional moves of 6 in the game GId ⊗ GId.

In what follows, we make formal the relationship between one-step games and minimal relations relative to specific positions in the game Sc0 .
0
Definition 4.10 (Play tree) Let G be a one-step game w.r.t. O and S. A play tree in G is a tree labelled by nodes of G with the following properties:
the root of the tree is some (t, ψ) ∈ OX × SL, and the leaves of the tree are (terminal) nodes of type (x, φ) ∈ X × L;
each E node has only one successor, taken from the set of G-moves of E in that node;
the successors of a 6 node are all G-successors of that node.
The notion of adequacy of a one-step game now captures the necessary conditions for the recovery of minimal relations via one-step games.
Definition 4.11 (Adequacy of one-step game) Given a one-step semantics [[S]] for S w.r.t. O, a one-step game G w.r.t. O and S is called adequate for [S]] if for any t ∈ OX and ψ ∈ SL, minimal relations Z ⊆ X × L relative to (t, ψ) are in one-to-one correspondence with sets of leaves of play trees in G.
Example 4.12 Let O be the signature functor for spatial transition systems, that is,	=	(1+	(	)). Consider the position (	( )) [	]	([	]
[π2] ◯ φ2)	in the one-step game GP ⊗ (G1 ⊕ GP ◎ (GId ⊗ GId)). Here, X ∈ PC,
Y ∈ P(C×C), whereas the formula corresponds to φ1 | φ2, as defined in Example 2.3.
The play trees starting from this position are of the form:


 (X, ι2(Y )), [π2]⟨κ2⟩  ([π1] ◯ φ1 ∧ [π2] ◯ φ2) 
 ι (Y ), ⟨κ ⟩ ([π ] ,	[π ] ◯ φ ) 

 Y,  ([π1]
, 
◯ φ1 ∧ [π2
E

] ◯ φ2) 

(y, [π ]
   6 
(y, [π ] ◯ φ ) ¸ j
, 
◯ φ1 ∧
π2] ◯ φ )
¸¸¸¸¸¸¸6¸¸¸¸¸¸
y, [π


2] ◯ φ2)

(π (y),   )	(π (y),   )
1	, ◯φ1	2	, ◯φ2
(π (y,)  )	(π (y,)  )
1	, φ1	2	, φ2
with y ∈ Y . The first two moves in such play trees are uniquely determined. Follow- ing these, E chooses an element y ∈ Y to witness Y, ([π1]◯φ1∧[π2] ◯ φ2) . Once this choice has been made, both of 6’s possible next moves have to be taken into account when defining a minimal relation relative to (  ( ))	. This cor- responds to the intuition that, in order to provide a witness for  (X, ι2(Y )), φ1 | φ2 , E has to choose an element y ∈ Y such that both φ1 holds in π1(y) and φ2 holds in

π2(y).
Proposition 4.13	(i) GA, GId, GP and GD are adequate for [[SA]], [[SId]], [[SP]] and
[[SD]] respectively.
(ii) If Gi is adequate for [[Si]], for i = 1, 2, then G1 ⊗ G2, G1 ⊕ G2 and G1 ◎ G2 are adequate for [[S1 ⊗ S2]], [[S1 ⊕ S2]] and [[S1 ◎ S2]], respectively.
Proof (Sketch) Follows directly from the definitions of the corresponding one-step semantics.	 
Theorem 4.14 (One-step adequacy) If G is adequate for [[S]], then E has a win-
ning strategy in Sc0 if and only if he has a winning strategy in the game obtained
φ0
from	c0	.
Sφ0 by replacing the last two moves in Deﬁnition 4.1 by the moves of G
Proof (Sketch) Assume first that E has a winning strategy in the original game. This strategy provides, for each position of type (t, ψ) ∈ OC × SL, a relation Z ⊆ C ×L s.t. (t, ψ) ∈ [[S]](Z). By Lemma 4.6, we can assume that Z is minimal relative to (t, ψ). We construct a winning strategy for E in the modified game by replacing E’s move given by the winning strategy in a position of type (t, ψ) ∈ OC × SL with moves in the modified game. By adequacy of G for [S]], for each minimal Z ⊆ C ×L relative to (t, ψ) ∈ [[S]](Z), there exists a corresponding play tree starting in (t, ψ). The moves of E in the modified game are obtained directly from this play tree. Specifically, in each E position that belongs to the play tree, E chooses the only move that keeps the play inside the play tree. Now since the play tree contains all possible 6 moves in the modified game, a move of 6 will itself keep the play inside the play tree. Since the Z move of E in the original game was part of a winning strategy, so is the newly built strategy in the modified game.
Now assume that E has a winning strategy in the modified game. This strategy can be used to define, for each position of type (t, ψ) ∈ OC × SL, a play tree in G – this is done by using E’s strategy in each E position, and collecting all of 6’s G-moves in each 6 position, repeatedly until a terminal position in G is reached. By adequacy of G for [S]], to each such play tree in G there corresponds a minimal Z relative to (t, ψ). The resulting relations Z and the winning strategy of E in the modified game can now be used to define a winning strategy for E in the original game – this is done by replacing E’s moves in positions of type (t, ψ) ∈ OC ×SL by the moves resulting from the play trees.	 

Summary and Future Work
We have extended the modular coalgebraic logics of [3,4] with general fixed points, of which until- and dynamic-like fixed points are an instance. Following [21], we have provided the resulting fixed point logics with a game semantics (by defining evaluation games for formulae and states of coalgebras), and have shown the ade- quacy of this semantics w.r.t. the standard fixed point semantics. Furthermore, we have shown that the moves corresponding to modal positions in these evaluation games can be replaced by so-called one-step games, whose boards can be built in-

ductively on the structure of the underlying signature functors, and whose moves simulate exactly those moves of the evaluation games which are relevant to deciding the existence of winning strategies for E (and thus the satisfaction of formulae by states of coalgebras).
Existing temporal logics for probabilistic systems (as described e.g. in [9]) allow the formalisation of properties of the kind “with probability at least p, φ holds until ψ holds”. Such languages, interpreted over Markov chains (which are exactly the D-coalgebras), are not recovered as fragments of our fixed point logic for the functor
D. We believe that this is due to our choice of modalities Lp and Gp and of their semantics. Ongoing work aims to address this by changing the underlying modal language.
Developing proof systems for coalgebraic fixed point logics is a natural and routine extension of this paper, but proving completeness of these proof systems requires more work. Proof systems are obtained in two steps: (1) the proof system constructors of [4] are used to derive a complete set of axioms and rules for the underlying modal language, and (2) a generalization of Kozen’s induction rule for fixed points [12] is added to the proof system. The subtlety of the first step is that proof system constructors are functors operating on a category of boolean theories, which for the purpose of well-definedness of our fixed points have to be restricted to theories closed under conjunction and disjunction.
Our adequacy theorem shows that deciding about the satisfaction of a formula by a pointed coalgebra is equivalent to deciding whether E has a history-free winning strategy in the evaluation game. The time complexity of the latter is exponential in the size of the game board [19]. However, it is well known that if one restricts the fixed points to the alternation-free fragment, the complexity reduces to polynomial time [19]. Our game boards are generalizations of those for the propositional μ- calculus, and the exact impact this has on complexity deserves further study. How- ever, we conjecture that by only using minimal relations (Definition 4.5) as possible moves of E, similar complexity results to those for the propositional μ-calculus can be obtained.

Acknowledgement
Thanks are due to James Worrell for useful discussions on games for the modal μ-calculus, and to the anonymous referees for several suggestions on improving the paper.

References
A. Baltag. A logic for coalgebraic simulation. In H. Reichel, editor, Coalgebraic Methods in Computer Science, volume 33 of Electronic Notes in Theoretical Computer Science, pages 41–60, 2000.
A. Baltag and L.S. Moss. Logics for epistemic programs. Synthese, 139, 2004.

C. Cˆırstea. A compositional approach to defining logics for coalgebras. Theoretical Computer Science, 327:45–69, 2004.


C. Cˆırstea and D. Pattinson. Modular construction of complete coalgebraic logics. Theoretical Computer Science, 388:83–108, 2007.
C. Cˆırstea and M. Sadrzadeh. Coalgebraic epistemic update without change of model. In Proceedings of the 2nd Conference on Algebra and Coalgebra in Computer Science, volume 4624 of Lecture Notes in Computer Science, pages 158–172. 2007.
L. Cardelli and A.D. Gordon. Anytime, anywhere: modal logics for mobile ambients. In POPL ’00: Proceedings of the 27th ACM SIGPLAN-SIGACT symposium on Principles of programming languages, pages 365–377. ACM, 2000.
E.A. Emerson and C.S. Jutla. Tree automata, mu-calculus and determinacy. In Proceedings of the 32nd IEEE Symposium on Foundations of Computer Science, pages 368–377. IEEE Computer Society Press, 1991.
E. Graedel, W. Thomas, and T. Wilke, editors. Automata, Logic, and Infinite Games, volume 2500 of
Lecture Notes in Computer Science. 2002.
H. Hansson and B. Jonsson. A logic for reasoning about time and reliability. Formal Aspects of Computing, 6(5):512–535, 1994.
D. Janin and I. Walukiewicz. Automata for the modal μ-calculus and related results. In Proceedings of the 20th International Symposium on Mathematical Structures in Computer Science, volume 969 of Lecture Notes in Computer Science, pages 552–562. 1995.
B. Jonsson, K.G. Larsen, and W. Yi. Probabilistic extensions of process algebras. In J.A. Bergstra et al, editor, Handbook of Process Algebra, pages 685–710. Elsevier, 2001.
D. Kozen. Results on the propositional mu-calculus. Theoretical Computer Science, 27:333–354, 1983.
L. Monteiro. A noninterleaving model of concurrency based on transition systems with spatial structure. In Proceedings of the Workshop on Coalgebraic Methods in Computer Science, volume 106 of Electronic Notes in Theoretical Computer Science, pages 261–277. Elsevier, 2004.
L.S. Moss. Coalgebraic logic. Annals of Pure and Applied Logic, 96:241–259, 1999.
D. Niwinski. Fixed point characterization of infinite behavior of finite-state systems. Theoretical Computer Science, 189, 1997.
D. Pattinson. Coalgebraic modal logic: soundness, completeness and decidability of local consequence.
Theoretical Computer Science, 309:177–193, 2003.
L. Schr¨oder. Expressivity of coalgebraic modal logic: The limits and beyond. In V. Sassone, editor, Foundations of Software Science and Computation Structures, volume 3441 of Lecture Notes in Computer Science, pages 440–454, 2005.
R. Segala. Modelling and Verification of Randomized Distributed Real-Time Systems. PhD thesis, Massachusetts Institute of Technology, 1995.
C. Stirling. Modal and Temporal Properties of Processes. Springer, 2001.
M. Vardi. Alternating automata: Checking truth and validity for temporal logics. In Proceedings of the 14th International Conference on Automated Deduction. 1997.
Y. Venema. Automata and fixed point logic: a coalgebraic perspective. Information and Computation, 204:637–678, 2006.
T. Wilke. Alternating tree automata, parity games, and modal μ-calculus. Bulletin of Belgian Mathematical Society, 8:359–391, 2002.
