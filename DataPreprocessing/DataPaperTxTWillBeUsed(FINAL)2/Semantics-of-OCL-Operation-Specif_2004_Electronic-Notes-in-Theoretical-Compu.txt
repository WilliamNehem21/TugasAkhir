Electronic Notes in Theoretical Computer Science 102 (2004) 111–132 
www.elsevier.com/locate/entcs


Semantics of OCL Operation Specifications
Rolf Hennicker, Alexander Knapp and Hubert Baumeister
Ludwig-Maximilians-Universita¨t Mu¨nchen
Institut fu¨r Informatik, Oettingenstraße 67, 80 538 Mu¨nchen, Germany
+(49) 89 2180 9184
{hennicke,knapp,baumeist}@pst.informatik.uni-muenchen.de

Abstract
The semantics of OCL operation specifications is discussed from a model theoretic perspective. It is argued that the semantics of operation specifications as defined in the OCL 2.0 proposal is not compatible with the view of operation specifications as contracts between a client and a supplier. As a solution, a semantics of OCL operation specifications based on standard model theory is presented. This semantics introduces the concept of a model over a UML class signature — which is a labelled transition system with output — together with a notion of the satisfiability of an OCL operation specification w.r.t. a model. The models respect the OCL features for methods with and without results, constructors, and queries. Regarding inheritance, the combination of several OCL operation specifications is introduced based on a lattice structure on models with respect to generalisation and refinement. Satisfiability is parametric in the underlying signature, and thus the notion can be transferred from UML class signatures to signatures including invariants.
Keywords: UML, OCL, model theoretic semantics, transition system


Introduction
An important application area of the “Object Constraint Language” (OCL [13]) is the specification of preconditions and postconditions of operations occur- ring in UML static structure diagrams. Although much work has been done to formalise the semantics of the OCL expression language (see, e.g., [17,18,4]), much less effort is still spent on a detailed semantics of operation specifica- tions which is needed for an unambiguous interpretation of precondition and

 This research has been partially supported by the GLOWA-Danube project (07GWK04) sponsored by the German Federal Ministry of Education and Research and the EC 5th Framework project AGILE: Architectures for Mobility (IST-2001-32747).


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2003.09.006


postcondition constraints. Important questions that arise here concern the meaning of operation specifications in the context of local and global invari- ants, the combination of constraints, the inheritance of constraints, and the meaning of constructor and query specifications.
Suggestions for the semantics of OCL operation specifications have been provided by Bickford and Guaspari [2], Richters and Gogolla [15], Hennicker, Hußmann, and Bidoit [9], Brucker and Wolff [3], and the OCL 2.0 specification itself [13] based on Richters [14]. Given a constraint of the form C::op(... ) pre: P post: Q, these approaches can be classified by two styles of interpret- ation, in the following called the “P ⇒ Q” style and the “P ∧ Q” style (see also [3]). The P ⇒ Q style ([2,15,9]) basically requires that if the precondi- tion P is satisfied in the state σ before the operation is performed then the postcondition is satisfied in the state σ' after the execution of the operation. If the precondition is not satisfied in σ then the operation yields an arbitrary result. On the other hand, the P ∧ Q style ([3,13,14]) considers relations (or state transitions) between pre- and poststates which simply do not contain any pair (σ, σ') where the precondition is not satisfied in the prestate σ. (For the time being, we deliberately neglect the issue of termination and the semantic variants considered in [9].)
To discuss which approach is more appropriate, one needs a simple, intu- itive background which we believe is provided by the notion of a contract as described by Meyer [12]. The contract principle assumes two actors, a client who uses (i.e. calls) an operation and an implementor who realises the opera- tion. Both actors have responsibilities. The client has the responsibility to call an operation only in a state where its precondition is satisfied. On the other hand, an implementor can assume that the precondition is valid and must en- sure that after execution of the operation its postcondition is satisfied. If both actors fulfill their responsibilities it is guaranteed that the system is executing correctly. Both views on a system, the client’s view and the implementor’s view should be reflected by the semantics of an operation specification which should characterise the correct system runs.
Indeed, it turns out that the P ⇒ Q style fits perfectly with the imple- mentor’s view, but does not take into account the obligations of the client because (arbitrary) state transitions are possible if the precondition of the op- eration is not satisfied. Hence this kind of semantics subsumes also incorrect system runs which can never occur if the client fulfils his responsibilities. Such incorrect transitions are excluded in the P ∧ Q style to the semantics of op- eration specifications, which is adopted by the OCL 2.0 specification. In this semantics, the following two specifications Spec1 and Spec2 are semantically equivalent since they describe the same state transitions (given by state pairs

(σ, σ') such that σ satisfies P and (σ, σ') satisfies Q):
Spec1 = context C::op(... ) pre: P  post: Q
Spec2 = context C::op(... ) pre: true post: P @pre and Q
where P @pre denotes the expression obtained from P by replacing each prop- erty name a occurring in P by a@pre.
However, when viewed as contracts, both specifications yield different ob- ligations for the client and the implementor of the specifications. In the case of Spec1 the client has to establish the precondition P while the implementor has to establish the postcondition Q under the assumption that P holds. In the case of Spec2 the client has no obligation since the precondition is true. The implementor, however, must in any situation satisfy the postcondition of Spec2 which may well be impossible if P is a proper precondition differ- ent from true. Then the implementor can not fulfil his responsibility which means that Spec2 is not satisfiable. In practice, satisfiability is particularly important in the connection with invariants which impose further constraints on correct realisations. The semantics according to the P ∧ Q style does not reflect the important notion of satisfiability because it is simple to construct specifications Spec1 and Spec2 such that Spec1 is satisfiable but Spec2 is not, but nevertheless both specifications are equivalent according to the P ∧ Q style.
In this paper we present a semantics of OCL operation specifications that has the benefits of the P ∧ Q style and incorporates the view of pre- and postcondition specifications as contracts, which allows us to distinguish Spec1 and Spec2. The solution is based on model theory and mathematical logic where satisfiability is a standard notion. Satisfiability of a formula ϕ means that there is a model of ϕ, i.e. a structure for the chosen logic which satisfies ϕ. Hence we have to investigate in the context of OCL appropriate notions of formula, model, and satisfaction relation: Formulas are OCL operation spe- cifications over a UML class signature; models are a special class of labelled transition systems with output that respect the contract view. Furthermore, we investigate the concept of correct realisations of operation specifications and relate them to the notion of models (Sect. 3). The class of models shows a lattice structure with respect to a generalisation ordering which provides the means for combining operation specification, in particular in view of inherit- ance of operation specifications (Sect. 4). Incidentally, the satisfaction relation following from the notion of models can be taken to be parameterised in the class of signatures. Extending UML class signatures with invariant specifica- tions, the notion of formulas and models can be reused to include invariants (Sect. 5).


Besides employing Meyer’s contract paradigm, our approach combines sev- eral well-known principles and results for operation specifications from formal specification languages like Z, Object-Z, or VDM with OCL. Jones [10] makes the case of implicit preconditions that may render a postcondition not satis- fiable for some states allowed in the explicit precondition, which has become known as the satisfiability principle (cf. also [11]). The notion of generalisa- tion between models corresponds to the refinement relation as discussed by Derrick and Boiten [6].

Preliminaries
We briefly sketch the necessary prerequisites for interpreting OCL expressions. More detailed accounts of a formal semantics for OCL’s navigational expres- sion language have been given by, e.g., Gogolla and Richters [17], Schmitt [18], Cengarle and Knapp [4], and the OCL 2.0 proposal [13] itself. However, we pay special attention to undefined and null values and their semantics in connection with attributes and queries. This is to ensure that attribute and query valuations in states may only mention objects that are indeed part of the state. Moreover, we distinguish between attributes and queries in states, treating states as being uniquely defined by their instances and attribute valu- ations, but assigning queries a derived status.
OCL expressions are built inductively over a class signature and variables. An OCL expression is evaluated over an environment, binding the expression’s free variables; a prestate and a poststate that are used to retrieve the values of attributes and opposite association ends; and a query interpretation.


Syntax.
A class signature Σ is defined over a UML static structure diagram. It contains sort symbols T for all classes T of the UML diagram, the predefined OCL basic types like Integer, the OCL collection types like Set(T ), and the OCL tuple types. The OCL type conformance rules are represented by a partial order ≤, the type subsumption relation, on the sort symbols. Finally, a class signature contains operations. These operations comprise the predefined OCL standard operations, like _->includes(_) : Collection(T ) × T → Boolean, and operations induced by attributes, opposite association ends, and queries from the UML static structure diagram. For example, if a is an attribute of class C with type D and multiplicity 1, then the class signature contains an operation _.a : C → D.

Semantic domains.
Each sort symbol T of a class signature Σ is mapped into a semantic domain of values T . The semantic domain of values over a class signature Σ is denoted by ValueΣ and it is required that the domains T are included in ValueΣ. Every such domain T contains the special value ⊥ for undeﬁned. For sort symbols induced by classes, we assume infinite sets of object identiﬁers as semantic domains together with a constant null denoting null. We require that T ≤ T ' implies T ⊆ T ' . In particular, this means that an object identifier for a class D is also an object identifier for class C if D is a subclass of C.
A state defines a finite set of existing instances, or objects, for each class type and the valuation of object attributes and association ends. The semantic domain of states over a given class signature Σ is written as StateΣ. Given a class type C, we write C σ for the finite set of instances of C that exist in state σ together with the null constant; in particular ⊥ ∈/ C σ, but null ∈ C σ. For an OCL basic type T we set T σ = T \ {⊥}. These definitions on class and OCL basic types are extended canonically to OCL collection and tuple types. An attribute _.a : C → T is evaluated on an object (identifier) o ∈ C), written as σ(o.a), yielding a value in T )σ. We additionally require σ(o.a)= ⊥ if, and only if o ∈/ C)σ \ {null }.

Evaluation.
We assume suitable interpretations .. . for the OCL predefined opera- tions and term formers, like _->iterate(... ) or _->exists(... ). These operations do not depend on a state. Their interpretation has to be strict,
i.e. whenever an argument is undefined then the result is undefined. The only exceptions to this general rule are the boolean connectives _and_, _or_, and
_implies_, such that, for instance, _and_)(⊥, false)= false (see e.g. [17,4]).
An environment over a class signature Σ maps variables into values of the semantic domain corresponding to the variable’s type, they are written as [x '→ v, y '→ v'] where x, y are variables and v, v' are values.
A query interpretation over a class signature Σ is a function that maps each query operation symbol to a function on a state and the query arguments yielding a value. If q : C ×T1 ×· · ·×Tn → T0 is an operation symbol in a class signature Σ induced by a query of the UML static structure diagram, then a query interpretation I maps q to a function in StateΣ× C × T1 ×·· ·× Tn → T0 such that I(q)(σ, o, v1,..., vn)= ⊥ if (o, v1,..., vn) ∈/ (( C σ \ {null }) × T1 σ × · · · × Tn σ) and I(q)(σ, o, v1,..., vn) ∈ T0 σ ∪ {⊥} otherwise. By abuse of notation, we write qI(σ, o, v1,..., vn) instead of I(q)(σ, o, v1,..., vn). The evaluation of an OCL expression e over a class signature Σ is written



context Account::withdraw(a : Real) pre: balance >= limit
post: balance = balance@pre-a and balance >= limit

Fig. 1. UML/OCL specification for account example
as e β,σ,σ',I where β is an environment, σ and σ' are states over Σ, and I is a query interpretation over Σ. Note that the selection of the appropriate query interpretation for a query call on an object depends on the dynamic type of an object. For example, if x is a variable of type Integer, x= 0 [x'→0],σ,σ',I = true for all states σ, σ' and for all query interpretations I; and if q : C → Integer is a query, self.q@pre() + self.q() β,σ,σ',I = qI(σ, β(self)) + qI(σ', β(self)).

Semantics of OCL Operation Specifications
The semantics of OCL operation specifications is modelled on Meyer’s con- tract view of operation specifications [12]: The user, or client, of an operation has to meet the operation’s precondition, the implementor, or supplier, of an operation has to meet the operation’s postcondition, if the precondition has been satisfied. More concretely, we take operation calls to induce transitions between states of a system. In the semantics, a transition between states may only exist if both the client and the supplier of the operation specification corresponding to the operation call have met their respective duties, i.e., in the source state the precondition holds and in the target state the postcon- dition holds. In fact, the postcondition may refer both to the source and the target state. However, it may well be impossible to find a state satisfying the postcondition depending on the source state. We are thus lead to conditions on the satisfiability of OCL operation specifications when viewed as contracts: On the one hand, the client should be able to call the operation. On the other hand, the supplier must be able to reach a state where the postcondition is sat- isfied, whenever the precondition holds. The latter condition corresponds to the well-known satisﬁability or feasibility principle for operation specifications as advocated by Jones [10].
Consider the (simple) example of an account specification in Fig. 1. In fact, the operation specification of withdraw violates the feasibility principle, as subtracting an arbitrary amount from balance may make it impossible to


satisfy balance >= limit. According to the contract view, no transition system should be a model of this operation specification. When, however, the pre- condition of withdraw is strengthened to balance >= limit and balance-a >= limit, the operation specification becomes satisfiable.
We first define the particular notion of labelled transitions with output that forms the general semantic domain of the semantics of OCL operation specifications. Then we define the sets of states where a given precondition or postcondition is satisfied. With these tools, we define the models of an operation specification and the notion of satisfiability of an operation specific- ation. The models of an operation specification allow the precondition to be weakened and the postcondition to be strengthened. However, we prove that a canonical model can be chosen as the semantics of a satisfiable operation specification. This canonical model exactly reflects the contract view. Finally, we define the possible implementations of a satisfiable operation specification.

Labelled Transition Systems with Output
A labelled transition system with output over a class signature Σ describes transitions between states in a system. The states are given by StateΣ. The transitions represent the possible changes of state induced by a call to an operation. Each transition is labelled by the operation name, the callee, and the actual arguments. As operation calls may return a result, these outcomes are recorded in an additional field of the labelled transition system.
For OCL, actually, the labels may take different forms, depending on which kind of behavioural feature is called. We define the set Label Σ to comprise the following: For each method (with or without a result) or query of class C with parameter types T1,..., Tn the labels o.op(v1,..., vn) with o ∈ C and v1 ∈ T1 ,..., vn ∈ Tn . For each constructor of class C with parameter types T1,..., Tn the labels C(v1,..., vn) with v1 ∈ T1 ,..., vn ∈ Tn . Analogously, result kinds may differ. We define the set Result Σ to comprise ValueΣ and a special result ∗ that is used for methods without an explicit result.
Formally, a labelled transition system with output (ltso) over the class signature Σ is a subset of StateΣ × Label Σ × StateΣ × Result Σ. The do- main of a Σ-ltso S is given by dom(S) = {(σ, l) | ∃(σ', r) . (σ, l, σ', r) ∈ S}. The codomain of a Σ-ltso S for a set M ⊆ StateΣ × Label Σ is given by S(M ) = {(σ', r) | ∃(σ, l) ∈ M . (σ, l, σ', r) ∈ S}. We also write S(σ, l) for S({(σ, l)}).
We define a generalisation relation ± between Σ-ltsos S, S' as follows:
S ± S' if
dom(S') ⊆ dom(S)

S(σ, l) ⊆ S'(σ, l) for all (σ, l) ∈ dom(S').
The generalisation relation corresponds to the reﬁnement relation for Z spe- cifications (cf. [6]) and is a partial order on Σ-ltsos. Moreover, the ordering induces universal meet (conjunction) and join (disjunction) operations H and H for Σ-ltsos: The meet of a family of Σ-ltsos is a Σ-ltso that is less or equal than every single member and the largest Σ-ltso fulfilling this condition, the join of Σ-ltsos affords the dual construction. Meet and join of a family of Σ-ltsos (Sj)j∈J are explicitly given by



j∈J
Sj = {(σ, l, σ', r) | (σ, l) ∈ 
(σ', r) ∈ 
dom(Sj),


Sk(σ, l)} ,

.	Sj = {(σ, l, σ', r) | (σ, l) ∈ 
k∈{k∈J|(σ,l)∈dom(Sk )}
dom(Sj),

j∈J
j∈J
'
k∈{k∈J|(σ,l)∈dom(Sk )}
Sk(σ, l)} .

As it stands, the notion of Σ-ltsos does not include the interpretation of queries. A query interpretation, in fact, presents a direct, functional way of expressing possible transitions in a system. The functional interpretation of query operations in Σ must therefore be compatible with the transitions of a Σ-ltso, when both are applicable. We thus define a system over a class signature Σ as a pair (S, I) of a Σ-ltso and a query interpretation I over Σ such that if qI(σ, o, v1,..., vn) = v0 then (σ, o.q(v1,..., vn), σ, v0) ∈ S. The partial order ± on Σ-ltsos is extended canonically to a partial order ± on Σ-systems: (S, I) ± (S',I'), if S ± S' and I and I' coincide. Note that for a fixed query interp.retation I, mee.t and join of fam.ilies of system.s (Sj,I)j∈J
are well-defined by	j∈J (Sj,I)=(  j∈J Sj,I) and	j∈J (Sj,I)=(  j∈J Sj,I),
respectively.

Precondition and Postcondition Domains
The precondition and postcondition domains of an operation specification yield the set of states or pairs of states where the precondition or postcondition of the operation specification holds. The definition of the precondition and the postcondition domain is by case analysis on the form of the operation spe- cification. The differences between OCL operation specifications for methods with result, methods without result, constructors, and queries are marginal, but warrant separate consideration for a complete treatment. In the follow- ing, we detail the precondition and the postcondition domain for operations specifications for methods with result; the remaining cases are summarised in Table 1.


Method without result ϕ = context C::op(x1 : T1, ... , xn : Tn)
pre: P	post: Q
Side condition: fv(P ) ⊆ {self, x1,..., xn}, fv(Q) ⊆ {self, x1,..., xn}
preI (ϕ)= {(σ, o.op(v1,..., vn)) | σ ∈ StateΣ,o ∈  C)σ \ {null },
v1 ∈ T1)σ,..., vn ∈ Tn)σ,
 P )[self'→o,x1'→v1,...,xn'→vn],σ,σ,I = true}
postI (ϕ)= {(σ, o.op(v1,..., vn), σ', ∗) | σ, σ' ∈ StateΣ,o ∈ C)σ \ {null },
v1 ∈ T1)σ,..., vn ∈ Tn)σ,
 Q)[self'→o,x1'→v1,...,xn'→vn],σ,σ',I = true}


Constructor ϕ = context C(x1 : T1, ... , xn : Tn) pre: P	post: Q
Side condition: fv(P ) ⊆ {x1,..., xn}, fv(Q) ⊆ {self, x1,..., xn}
preI (ϕ)= {(σ, C(v1,..., vn)) | σ ∈ StateΣ,
v1 ∈ T1)σ,..., vn ∈ Tn)σ,
 P )[x1'→v1,...,xn'→vn],σ,σ,I = true}
postI (ϕ)= {(σ, C(v1,..., vn), σ', r) | σ, σ' ∈ StateΣ,
v1 ∈ T1)σ,..., vn ∈ Tn)σ,r ∈ C)σ' \ {null },r ∈/ C)σ,
 Q)[self'→r,x1'→v1,...,xn'→vn],σ,σ',I = true}


Query ϕ = context C::op(x1 : T1, ... , xn : Tn) : T0
pre: P	post: Q
Side condition: fv(P ) ⊆ {self, x1,..., xn},
fv(Q) ⊆ {self, x1,..., xn, result}
preI (ϕ)= {(σ, o.op(v1,..., vn)) | σ ∈ StateΣ,o ∈  C)σ \ {null },
v1 ∈ T1)σ,..., vn ∈ Tn)σ,
 P )[self'→o,x1'→v1,...,xn'→vn],σ,σ,I = true}
postI (ϕ)= {(σ, o.op(v1,..., vn), σ, r) | σ ∈ StateΣ,o ∈  C)σ \ {null },
v1 ∈ T1)σ,..., vn ∈ Tn)σ,r ∈ T0)σ,
 Q)[self'→o,x1'→v1,...,xn'→vn,result'→r],σ,σ,I = true}

Table 1
Precondition and postcondition domains


An operation specification ϕ over a class signature Σ for a method op with result takes the general form
context T ::op(x1 : T1, ..., xn : Tn) : T0
pre: P
post: Q
where the OCL expression P may contain as free variables fv(P ) only self and x1,..., xn, the OCL expression Q may contain as free variables fv(Q) only self, result, and x1,..., xn. The reserved variable result is used to refer to the result value of a method call. (This is in contrast to constructors where self denotes the newly constructed object and thus the result of a constructor call.)
The precondition domain of ϕ w.r.t. a query interpretation I defines a set of states and labels that satisfy the precondition P of ϕ as follows:
preI (ϕ)= {(σ, o.op(v1,..., vn)) | σ ∈ StateΣ,o ∈  T )σ \ {null },
v1 ∈ T1)σ,..., vn ∈ Tn)σ,
 P )[self'→o,x1'→v1,...,xn'→vn],σ,σ,I = true}

In particular, the precondition domain only takes into account such values that indeed exist in the current state σ (where for the sake of simplicity the value null is assumed to exist in every state). For evaluating the precondition P the single state σ is used as prestate and poststate.
The postcondition domain of ϕ w.r.t. I likewise defines a set of pairs of states, labels, and results that satisfy the postcondition of ϕ:
postI (ϕ)= {(σ, o.op(v1,..., vn), σ', r) | σ, σ' ∈ StateΣ,o ∈  T )σ \ {null },
v1 ∈ T1)σ,..., vn ∈ Tn)σ,r ∈ T0)σ' ,
 Q)[self'→o,x1'→v1,...,xn'→vn,result'→r],σ,σ',I = true}

This definition and its companions in Table 1 do not cover all possible parameter kinds for operation specifications that could occur in the UML. We restrict ourselves to in-parameters and a single return-parameter. The treatment of in-out-parameters and out-parameters would call for reference types and locations; several return-parameters can be handled by the OCL tuple types.

Models of OCL Operation Speciﬁcations
A model of an OCL operation specification over a class signature Σ is a Σ- system that respects the contract view of the operation specification: The


precondition domain using the Σ-system’s query interpretation must not be empty, in order to ensure that the operation is usable from the client’s point of view. The precondition domain must be included in the domain of the Σ-system’s ltso, in order to ensure that when the operation is called within its precondition domain the operation is realisable from the implementor’s point of view. Finally, all possible transitions in the Σ-system’s ltso from the precondition domain must be covered by the postcondition domain, in order to ensure that the postcondition indeed has been established when the operation has been executed.
Let Σ be a class signature and let ϕ be an operation specification over Σ.
A Σ-system (S, I) is a Σ-model of ϕ, written as (S, I) |=Σ ϕ, if
preI (ϕ) /= ∅;
preI (ϕ) ⊆ dom(S);
{(σ, l, σ', r) ∈ S | (σ, l) ∈ preI (ϕ)} ⊆ postI (ϕ).
Σ	Σ
In accordance with general model theory we call an operation specification ϕ
Σ-satisﬁable, if ϕ has a Σ-model.
Note that an operation specification is not only unsatisfiable due to un- satisfiable pre- or postconditions, but also when the postcondition implicitly restricts the domain of the operation specification. Consider
ϕ = context C::op() pre: P  post: Q . 
The implicit precondition domain of the operation specification ϕ is given by the set {(σ, l) | ∃(σ', r) . (σ, l, σ', r) ∈ postI (ϕ)}. A necessary condition for ϕ to be satisfiable is that the precondition domain preI (ϕ) is a subset of the implicit precondition domain. For instance, taking up the account example in Fig. 1, the operation specification for withdraw indeed is not satisfiable due to the implicit precondition balance -a >= limit.

Semantics of OCL Operation Speciﬁcations
The class of Σ-models satisfying an operation specification, if non-empty, en- joys the property that there is a maximal model with respect to a given query interpretation. This distinguished model can be used to define the semantics of satisfiable operation specifications and the equivalence of operation specific- ations.
In the maximal model, the application domain of an operation meets its precondition domain and the application range includes all possible outcomes of the operation as defined by its postcondition domain, representing full non- determinism.


Lemma 3.1 Let Σ be a class signature and let ϕ be a satisﬁable operation speciﬁcation over Σ, i.e. there exists a Σ-system (S, I) such that (S, I) |=Σ ϕ. Then
S = {(σ, l, σ', r) ∈ postI (ϕ) | (σ, l) ∈ preI (ϕ)}
Σ	Σ

is the unique Σ-ltso such that (S, I) |=Σ ϕ and (S',I) ± (S, I) for all Σ- systems (S',I) with (S',I) |=Σ ϕ.
Proof. First of all, note that ∅ /= preI (ϕ) by the satisfiability of ϕ. Fur- thermore, preI (ϕ) = dom(S) since for every (σ, l) ∈ preI (ϕ) there are σ'
Σ	Σ
and r such that (σ, l, σ', r) ∈ postI (ϕ), again by the satisfiability of ϕ, and
dom(S) ⊆ preI (ϕ) by definition of S. In particular, (S, I) |=Σ ϕ.
In order to prove that (S, I) is maximal, let (S',I) be some Σ-system with (S',I) |=Σ ϕ. Then dom(S) = preI (ϕ) ⊆ dom(S'). Furthermore, if (σ, l) ∈ dom(S), then S'(σ, l) ⊆ postI (ϕ)(σ, l)= S(σ, l). Thus (S',I) ± (S, I). The uniqueness of S follows from ± being a partial order on Σ-systems. 
In fact, the construction of the lemma coincides with .{(S, I) | (S, I) |=Σ ϕ} with respect to a fixed query interpretation I. However, the Σ-satisfiability of ϕ is crucial, as the disjunction over the empty family does not constitute a Σ-model of ϕ.
For a given query interpretation I, we thus define the semantics  ϕ)I of
a Σ-satisfiable operation specification ϕ as the maximal Σ-model (S, I) with (S, I) |=Σ ϕ. Two operation specifications ϕ1, ϕ2 are equivalent with respect

to a query interpretation I, written as ϕ1  I
ϕ2, if both are Σ-satisfiable and

I	I
ϕ1 Σ = ϕ2 Σ. Note that the precondition domains of equivalent, satisfiable
operation specifications coincide by construction of the maximal model.
Provided that the operation specification ϕ is satisfiable, our definition of the semantics of an operation specification coincides with the semantics of the OCL 2.0 proposal [13] and Brucker and Wolff [3]. However, if ϕ is not satisfiable, our semantics of ϕ is undefined while the OCL 2.0 semantics is still defined. Consider again the two operation specifications from the introduction (Sect. 1):
ϕ1 = context C::op() pre: P  post: Q	and
ϕ2 = context C::op() pre: true post: P @pre and Q
On the one hand, if ϕ1 is satisfiable then ϕ1)I is defined and yields the same
relation between pre- and poststates as in the P ∧ Q style. On the other
hand, satisfiability of ϕ1 does not imply satisfiability of ϕ2 as, in general,

condition (ii) in Sect. 3.3 cannot be fulfilled, thus making ϕ2)I
undefined.

Correct Realisations of OCL Operation Speciﬁcations
An implementor of a class signature Σ provides for each operation op in Σ an interpretation of op in terms of a state transition function (possibly with result) for a non-query method and a function on states for a query operation. This gives rise to the notion of a Σ-interpretation extending the notion of a query interpretation over Σ given in Sect. 2. To answer the question, when an implementor of a class signature Σ has correctly implemented an operation specifications ϕ, i.e. provided a correct Σ-interpretation, we first define the Σ-system (SZ, IZ) induced by a Σ-interpretation Z. Then Z is considered a correct realization of ϕ if (SZ, IZ) is a Σ-model for ϕ.
A Σ-interpretation Z of a class signature Σ is given by a query interpreta- tion IZ of the query operations together with a set of state transition functions for the operations and constructors in Σ. Let op : C × T1 ×· · · × Tn → T be an operation with result in Σ. An interpretation of op is a function:
opZ : StateΣ × C) × T1) ×· · ·× Tn) → (StateΣ × T )) ∪ {⊥}
such that for all σ ∈ StateΣ, o ∈ C), v1 ∈ T1),..., vn ∈ Tn):
opZ (σ, o, v1,..., vn)= ⊥
if (o, v1,..., vn) /∈ C σ × T1 σ ×· · ·× Tn σ, o = null , or opZ (σ, o, v1,..., vn) /∈
T σ' ∪{⊥} otherwise. Similarly, an operation without a result (op : C ×T1 ×
··· × Tn) and a constructor C : T1 ×· · ·× Tn → C are interpreted as functions
opZ : StateΣ × C) × T1) ×· · ·× Tn) → StateΣ ∪ {⊥}


and

CZ : StateΣ × T1) ×· · ·× Tn) → (StateΣ × C)) ∪ {⊥} ,

respectively. Non-termination and exceptions are modelled by the value ⊥.
A Σ-interpretation Z gives rise to the Σ-system (SZ, IZ) defined by: (σ, o.op(v1,..., vn), σ', r) ∈ SZ iff opZ (σ, o, v1,..., vn)= (σ', r) /= ⊥
for all operation symbols with result from Σ and for all σ, σ' ∈ StateΣ, v1 ∈ T1 σ, ... , vn ∈ Tn σ, and r ∈ T σ' . The labels for operation symbols without result, constructors, and query operations are defined in a similar way (cf. Sect. 2 for query operations).
Note that there is a one-to-one correspondence between Σ-interpretations and deterministic Σ-systems. A deterministic Σ-system is a Σ-system where for each state σ all outgoing transitions have different labels.

A Σ-interpretation Z is a correct realisation of an operation specification ϕ
if (SZ, IZ) |= ϕ or, equivalently, if (SZ, IZ) ± ϕ)IZ for the Σ-system (SZ, IZ)
induced by Z.
Note that with our definition of a correct realisation, an implementation correctly realising an operation specification may be defined on more states and arguments than on the states and arguments for which the precondition holds. This is in accordance with the implementor’s view of the contract prin- ciple and corresponds to the P ⇒ Q style (as has been observed by Brucker and Wolff [3]). Hence our definition of a correct realisation differs from the corresponding definition in the OCL 2.0 proposal where the domain of a cor- rect operation realisation has to coincide with the precondition domain of the operation specification.


Sets of OCL Operation Specifications and Inheritance
Operations may be specified not by a single OCL operation specification only, but by several operation specifications. The contract view can be extended to include sets of operation specifications for a single operation by the following reasoning: As every single operation specification forms a contract, the client may choose to fulfil the precondition of some operation specification out of the set in order to meet his duties and may expect the postcondition of the chosen contract. The supplier, however, is bound by all contracts simultaneously, i.e., when the operation is called in a state of the precondition domain of some contract, he has to establish all postconditions of the contracts whose preconditions the state satisfies. Inheritance of operations forms a special case of sets of operation specifications, if both the superclass and the subclass define an operation specification for an operation. The operation specification of the superclass yields a contract for the operation in the subclass, too, since all instances of the subclass are also instances of the superclass.
Consider the extended example of an account specification in Fig. 2. When calling withdraw on an instance of CheckingAccount with an argument such that both, identical, preconditions are satisfied, both postconditions, changing the balance and increasing the withdraw counter have to be established. If we replaced the precondition of withdraw in CheckingAccount by true, the withdraw counter would have to be increased on every call of withdraw on an instance of CheckingAccount, independently of changing the balance. For calls of withdraw on instances of SavingsAccount only the contract inherited from Account is in force.




context Account::withdraw(a : Real) pre: balance-a >= limit
post: balance = balance@pre-a and balance >= limit
context CheckingAccount::withdraw(a : Real) pre: balance-a >= limit
post: count = count@pre+1

context CheckingAccount::payCharge() pre: balance-count*charge >= limit
post: balance = balance@pre-count*charge and count = 0 


Fig. 2. UML/OCL specification for extended account example
Models of Sets of OCL Operation Speciﬁcations
In line with the model-theoretic view of operation specifications, a set of op- eration specifications is considered as the conjunction of the single operation specifications. In particular, a set of operation specifications is considered sat- isfiable if all operation specifications in the set are satisfiable simultaneously. Let Σ be a class signature, and let Φ = {ϕ1,..., ϕn} be a set of operation specifications over Σ. A Σ-system (S, I) isa Σ-model of ϕ, written as (S, I) |=Σ Φ, if (S, I) |=Σ ϕi for all 1 ≤ i ≤ n. Accordingly, Φ is called Σ-satisﬁable, ifΦ 
has a Σ-model.
Necessarily, if a set of operation specifications is satisfiable, all elements of the set are satisfiable as there is a common model. The reverse direction, however, does not hold: Even if both
ϕ1 = context C::op() pre: P  post: Q	and
ϕ2 = context C::op() pre: P  post: not Q
are satisfiable, there is, in general, no common model for {ϕ1, ϕ2} since there will be no postcondition state satisfying both Q and not Q.

Semantics of Sets of OCL Operation Speciﬁcations
As for a single satisfiable operation specification, a satisfiable set of operation specification has a maximal model that we will use as its semantics.
Lemma 4.1 Let Σ be a class signature and let Φ = {ϕ1,..., ϕn} be a set of operation speciﬁcations over Σ such that (S, I) |=Σ Φ for a Σ-system (S, I). Then
S = {(σ, l, σ', r) | (σ, l) ∈	preI (ϕi),
(σ', r) ∈  {postI (ϕi)(σ, l) | (σ, l) ∈ preI (ϕi), 1 ≤ i ≤ n}}
Σ	Σ

is the unique Σ-ltso such that (S, I) |=Σ Φ and (S',I) ± (S, I) for all Σ- systems (S',I) with (S',I) |=Σ Φ.

Proof. We first show that (S, I) |=Σ ϕi for all 1 ≤ i ≤ n. Indeed, preI (ϕi) /=
∅ by the satisfiability of Φ and thus the satisfiability of ϕi. Furthermore, for every (σ, l) ∈ preI (ϕi) there is a σ' and an r such that (σ', r) ∈ S(σ, l) ⊆
Σ
I	I

postΣ(σ, l). By the satisfiability of Φ, we have S(σ, l) ⊆
 
j∈J

(σ,l)
postΣ(ϕj)(σ, l)



with J(σ,l) = {j | (σ, l) ∈ preI (ϕj)}. Thus,	preI (ϕi) = dom(S). As


j∈J(σ,l)
Σ
postI (ϕj)(σ, l)= S(σ, l) for all (σ, l) ∈
1≤i≤n
1≤i≤n
Σ
preI (ϕi), consequently

(S, I) |=Σ Φ.
With the same reasoning, but replacing (S, I) by an arbitrary Σ-system



(S',I) with (S',I) |=Σ Φ, it follows that dom(S)= 
 

1≤i≤n
preI (ϕ) ⊆ dom(S')



and S'(σ, l) ⊆
j∈J(σ,l)
postI (ϕj)(σ, l) = S(σ, l) for all (σ, l) ∈ dom(S) and

thus (S',I) ± (S, I).	 
Extending the definition for a single operation specification, we define the
semantics Φ)I of a Σ-satisfiable set of operation specifications Φ with respect
to a query interpretation I as the maximal Σ-model (S, I) with (S, I) |=Σ Φ. Two sets of operation specifications Φ1, Φ2 are equivalent with respect to a

query interpretation I, written as Φ1  I
Φ2, if both are Σ-satisfiable and

I	I
 Φ1)Σ = Φ2)Σ.
By the construction of the lemma, the semantics of a Σ-satisfiable set of operation specifications is

 {ϕ1,..., ϕn})Σ
= .1≤i≤n
 ϕi)Σ

for a fixed query interpretation I. The semantics thus induces a normal form
ϕ for the Σ-satisfiable set of operation specifications {ϕ1,..., ϕn} given by
ϕi = context C::op() pre: Pi  post: Qi


such that {ϕ}  I {ϕ1,..., ϕn}: The preconditions are combined disjunctively,
while the postconditions are combined conjunctively for those preconditions
which are fulfilled simultaneously:
ϕ = context C::op() pre: P1 or ... or Pn
post: P1@pre implies Q1 and ... and Pn@pre implies Qn
For instance, in the extended account example in Fig. 2, the normal form for the operation withdraw in the context of CheckingAccount becomes:
context CheckingAccount::withdraw(a : Real) pre: balance-a >= limit
post: (balance@pre-a >= limit@pre) implies
(balance = balance@pre-a and balance >= limit and
count = count@pre+1)

as the contract for withdraw in the context of Account is inherited to CheckingAc- count.

Combining OCL Operation Specifications with In- variants
Class invariants constrain the possible states under which objects of a class can be viewed from other objects. These state constraints also influence the satisfaction of operation specifications, as both the preconditions and the post- condition are implicitly strengthened by the class invariants.
Consider the example of a seminar specification in Fig. 3, see also [7,8]. The invariant of Instructor requires an instructor to be qualified for all as- signed courses. When calling changeCourse on a session that has already been assigned to an instructor but using a course which the instructor is not qual- ified for, the invariant would be violated, if only the course is changed. A realisation of changeCourse would not only have to modify its course but also the sessions of the instructor, removing this session. However, such a solution is hardly viable in the present system as the multiplicity 1 of the association end at Instructor requires each session to have an Instructor assigned. A more appropriate solution is to strengthen the precondition of changeCourse into instructor.qualifiedFor->includes(c).
We take class invariants in a UML static structure diagram to extend the induced class signature Σ into a specification (Σ, A) with the class invariants as axioms A. This extension leads to a refined notion of precondition and postcondition domains, as only states have to be considered that satisfy all



1

*


sessions




qualifiedFor 1

sessions




context Session::changeCourse(c : Course) pre: true
post: course = c
context Instructor
inv: qualifiedFor->includesAll(sessions.course)


Fig. 3. UML/OCL specification for seminar example
invariants in A. The notions of model and satisfiability defined for plain class signatures Σ can be transferred to specifications (Σ, A). All properties, like existence of a maximal model of a satisfiable operation specification or the combination of sets of operation properties can be replayed in the extended setting.
Semantics of OCL Operations Speciﬁcations with Invariants
An OCL invariant specification ψ over a class signature Σ takes the form
context C inv: V
where C is a class in Σ and V may contain only self as a free variable. We define the invariant domain of ψ with respect to a query interpretation I over Σ as
invI (ψ)= {σ ∈ StateΣ | ∀o ∈ C)σ \ {null } . V )[self'→o],σ,σ,I = true} .
This definition is extended to sets of invariant specifications A by invI (A)= 
Σ
invI (ψ).
Given a class signature Σ, a set of invariant specifications A, and a query interpretation I over Σ, we define the precondition and the postcondition do- main of an operation specification in the context of the invariant specifications A by
preI	(ϕ) = preI (ϕ) ∩ (invI (A) × Label Σ)
(Σ,A)	Σ	Σ
postI	(ϕ)= postI (ϕ) ∩ (invI (A) × Label Σ × invI (A) × Result Σ)
(Σ,A)	Σ	Σ	Σ
A Σ-system (S, I) is a (Σ, A)-model of ϕ, written as (S, I) |=(Σ,A) ϕ, if



preI
preI
(ϕ) /= ∅;
(ϕ) ⊆ dom(S);

{(σ, l, σ', r) ∈ S | (σ, l) ∈ preI
(ϕ)} ⊆ postI
(ϕ).

An operation specification ϕ is (Σ, A)-satisﬁable, if ϕ has a (Σ, A)-model.
All consequences from the notion of Σ-satisfiability remain valid for the extended notion of (Σ, A)-satisfiability. In particular, we define the semantics
 ϕ)(Σ,A) of a (Σ, A)-satisfiable operation specification ϕ with respect to a query interpretation I as the maximal Σ-system (S, I) with (S, I) |=(Σ,A) ϕ.
Hierarchical Invariants
The effect of an invariant of some class on operation specifications requires to check that all operations, also of remote classes, respect all invariants. An alternative approach is discussed by Baumeister, Hennicker, Knapp, and Wirs- ing [8]: Navigating class invariants, i.e., class invariants using object properties that are not under exclusive control of the class are forbidden. Instead, nav- igating invariants have to be attached not to a class but to a higher-level container, called a component. Operations are classified into being private, component-private, and component-public. Only component-public opera- tions are visible to the outside of the component, private operations are not visible outside their owning class. This classification and the lifting of navigat- ing invariants to components simplifies the obligations for the different types of operations: Private operations need not respect any invariants, component- private operations have to respect the corresponding class invariants, while only component-public operations have to respect all class invariants and the component invariants. In the example above, the static structure would be enclosed in a subsystem Seminar lifting the invariant of Instructor to Seminar:
context Seminar
inv: Instructor.allInstances()->forAll(i : Instructor | i.qualifiedFor->includes(i.sessions.course))

If changeCourse is defined to be only component-private, it need not re- spect the component invariant of Seminar, as it can only be called inside the component.
This hierarchical approach to combining invariants with operation specific- ations can be modelled in the current setting by extending the signature of operations with private, component private, and component public tags for operations and splitting the invariants into class invariants and component invariants. The semantics of operation specifications is now defined by re- stricting the precondition and postcondition domains only to those invariants that have to be respected by the specific operation type.

Conclusions and Future Work


We have discussed the semantics of OCL operation specifications from the viewpoint of contracts interpreting an operation specification’s precondition and postcondition as obligations for a client and a supplier. A model of an operation specification contract is a labelled transition system with output respecting the contract’s obligations, an operation specification is satisfiable if it has a model. The semantics of a satisfiable operation specification is defined as the maximal model with respect to a general refinement relation. The refinement relation is also used to define correct realisations for operation specifications as deterministic labelled transition systems with output. The general model-theoretic treatment of operation specification entails a seamless integration of the semantics of sets of operation specifications, the semantics of operation-specification inheritance, and the combination of operation spe- cifications with invariants.
The semantics of a single satisfiable operation specification coincides with the transition relation semantics defined in the OCL 2.0 proposal [13] and also by Brucker and Wolff [3]. However, pursuing the contract view, the notion of a model of a contract makes use of the explicit OCL precondition and leads to a more fine-grained distinction between operation specifications based on satisfiability. Moreover, the notion of labelled transition systems with output yields a global view on the totality of interacting and collaborating objects, whereas the transition relation semantics is geared towards a single opera- tion. The implementation-oriented notion of correct realisations of operation specifications loosens the too restricted definition in the OCL 2.0 [13], allow- ing implementations to be defined on a wider domain than required by the precondition.
In our account of the semantics of OCL operation specifications, we have striven to be precise on at least the essential features and peculiarities of OCL. However, though the definitions distinguish between methods with and without result, constructors, and queries and respect queries as integral part of OCL, we have not included all different kinds of parameters, like in-out- parameters, and also have neglected feature overloading. Notwithstanding these omissions, an integration into a formal proof environment like HOL- OCL [3] may seem of interest. More importantly from a modelling perspective, we have not included a discussion of the proof obligations that result from operation specifications. Here, integration in the KeY environment [1] or the USE tool [16] remains future work.

Acknowledgement.
We would like to thank Michel Bidoit for useful suggestions for improve- ments.

References
Ahrendt, W., T. Baar, B. Beckert, M. Giese, R. H¨ahnle, W. Menzel, W. Mostowski and
P. H. Schmitt, The KeY System: Integrating Object-Oriented Design and Formal Methods, in: M. Ojeda-Aciego, I. P. de Guzm´an, G. Brewka and L. M. Pereira, editors, Europ. Wsh. Logics in Artiﬁcal Intelligence, Lect. Notes Artif. Intell. 1919 (2002), pp. 21–36.
Bickford, M. and D. Guaspari, Lightweight Analysis of UML, Draft NAS1-20335/10, Odyssey Research Assoc. (1998), http://www.omg.org/cgi-bin/doc?ad/98-10-01.
Brucker, A. D. and B. Wolff, HOL-OCL: Experiences, Consequences and Design Choices, in: J.-M. Jezequel, H. Hussmann and S. Cook, editors, Proc. 5th Int. Conf. UML, Lect. Notes Comp. Sci. 2460 (2002), pp. 196–210.
Cengarle, M. V. and A. Knapp, OCL 1.4/5 vs. 2.0 Expressions — Formal Semantics and Expressiveness, Software and Systems Modelling (2003), to appear.
Clark, T. and J. Warmer, editors, “Advances in Object Modelling with the OCL,” Lect. Notes Comp. Sci. 2263, Springer, Berlin, 2002.
Derrick, J. and E. Boiten, “Refinement in Z and Object-Z — Foundations and Advanced Applications,” Formal Approaches to Computing and Information Technology, Springer, London–&c., 2001.
D’Souza, D. F. and A. C. Wills, “Object, Components, Frameworks with UML: The Catalysis Approach,” Addison-Wesley, Reading, Mass., &c., 1998.
Hennicker, R., H. Baumeister, A. Knapp and M. Wirsing, Specifying Component Invariants with OCL, in: K. Bauknecht, W. Brauer and T. Mu¨ck, editors, Proc. GI/OCG-Jahrestagung, books@ocg.at 157/I, O¨ GI (Austrian Computer Society), 2001, pp. 600–607.
Hennicker, R., H. Hußmann and M. Bidoit, On the Precise Meaning of OCL Constraints, in: Clark and Warmer [5] pp. 70–85.
Jones, C. B., “Systematic Software Construction Using VDM,” Prentice Hall, Upper Saddle River, New Jersey, 1990.
Lano, K., “Formal Object-Oriented Development,” Formal Approaches to Computing and Information Technology, Springer, London–&c., 1995.
Meyer, B., “Object-Oriented Software Construction,” Prentice-Hall, Upper Saddle River, New Jersey, 1997.
Response to OMG RfP ad/00-09-03 “UML 2.0 OCL”, 2nd revised submission, OMG (2003),
http://www.omg.org/cgi-bin/doc?ad/03-01-07.
Richters, M., “A Precise Approach to Validating UML Models and OCL Constraints,” Ph.D. thesis, Universit¨at Bremen (2001).
Richters, M. and M. Gogolla, A Semantics for OCL Pre- and Postconditions, in: T. Clark and
J. Warmer, editors, Proc. UML’2000 Wsh. UML 2.0 — The Future of OCL, York, 2000.
Richters, M. and M. Gogolla, Validating UML Models and OCL Constraints, in: A. Evans,
S. Kent and B. Selic, editors, Proc. 3rd Int. Conf. UML, Lect. Notes Comp. Sci. 1939 (2000),
pp. 265–277.


Richters, M. and M. Gogolla, OCL — Syntax, Semantics and Tools, in: Clark and Warmer [5]
pp. 38–63.
Schmitt, P. H., A Model Theoretic Semantics of OCL, in: B. Beckert, R. France, R. H¨ahnle and
B. Jacobs, editors, Proc. Wsh. Precise Modelling and Deduction for Object-Oriented Software Development, Technical Report DII 07/01 (2001), pp. 43–57.
