	Electronic Notes in Theoretical Computer Science 201 (2008) 127–154	
www.elsevier.com/locate/entcs


Simulation-based Verification for Invariant Properties in the OTS/CafeOBJ Method
Kazuhiro Ogata1 Kokichi Futatsugi2
School of Information Science
Japan Advanced Institute of Science and Technolog 1-1 Asahidai, Nomi, Ishikawa 923-1290

Abstract
The OTS/CafeOBJ method is a formal method to model systems, specify models and verify that models satisfy properties. We propose a way to verify that a state machine S satisfies invariant properties based on a simulation from S to another state machine, which is more abstract than S, in the OTS/CafeOBJ method. Three communication protocols are used as examples to demonstrate the proposed method.
Keywords: algebraic specifications, equations, rewriting, proof scores


Introduction
We have been developing the OTS/CafeOBJ method [17,15,6], in which we mainly use induction on the structure of the reachable state spaces of state machines to verify that state machines satisfy invariant properties. The verifi- cation method is called the induction-based (invariant) verification method in this paper. In the OTS/CafeOBJ method, observational transition systems, or OTSs are used as state machines, and CafeOBJ, an algebraic specification language and system, is used to specify OTSs and verify that OTSs satisfy properties. A number of cases studies have been conducted, among which are [14,16,11].

1 Email: ogata@jaist.ac.jp
2 Email: kokichi@jaist.ac.jp



1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.02.018

This paper proposes another way to verify that state machines satisfy in- variant properties. The proposed method is based on simulations from OTSs to OTSs. A simulation from an OTS S to an OTS SA is a relation between the reachable sates of S and those of SA that satisfies some conditions. The pro- posed method is called the simulation-based (invariant) verification method. We first define simulations from OTSs to OTSs and then prove a theorem saying that if there exists a simulation r from an OTS S to another OTS SA, which is more abstract than S, then a state predicate p is invariant with respect to (wrt) S when a state predicate pA is invariant wrt SA and p is deduced from pA assuming r. The proposed simulation-based verification method is based on the theorem. We then prove another theorem saying that the composition s ◦ r of a simulation r from S to SA and a simulation s from SA to SB is a
simulation S to SB.
In this paper, we use three communication protocols (an abstract protocol called BCP, an intermediate protocol called SCP and a concrete protocol called ABP) as examples and report on two case studies on the protocols. In the first case study, we prove that there exists a simulation r1 from SCP to BCP, and in the second case study, we prove that there exists a simulation r2 from ABP to SCP, which implies that the composition r2 ◦ r1 is a simulation from ABP to BCP.
The rest of the paper is organized as follows. Section 2 describes OTSs. Section 3 introduces CafeOBJ. Section 4 defines simulations from OTSs to OTSs. Section 5 proposes the simulation-based invariant verification method. Section 6 defines compositions of simulations from OTSs to OTSs. Section 7 mentions some related work. Section 8 concludes the paper.

Observational Transition Systems (OTSs)
We suppose that there exists a universal state space denoted Υ and that each data type used in OTSs is provided. The data types include Bool for Boolean values. A data type is denoted D with a subscript such as Do1 and Do.
Definition 2.1 An OTS S is ⟨O, I, T⟩ such that
O : A finite set of observers.  Each observer ox1:Do1,...,xm:Dom  : Υ → Do is an indexed function that has m indexes x1,..., xm whose types are Do1,..., Dom. For brevity, we suppose that the name o of each observer ox1:Do1,...,xm:Dom :Υ → Do is distinct from each other. Therefore, the name o may be used to refer to the observer. The equivalence relation (υ1 =S υ2) between two states υ1, υ2 ∈ Υ is defined as ∀o : O.∀x1 : Do1 ... ∀xm : Dom. (ox1,...,xm (υ1)= ox1,...,xm (υ2)).

I : The set of initial states such that I ⊆ Υ.
T : A finite set of transitions. Each transition ty1:Dt1,...,yn:Dtn : Υ → Υ is an indexed function that has n indexes y1,..., yn whose types are Dt1,..., Dtn provided that ty1,...,yn (υ1) =S ty1,...,yn (υ2) for each equivalence class c ∈ Υ/=S of the quotient set of Υ by =S , each υ1, υ2 ∈ c and each yk : Dtk for k = 1,..., n. Each transition ty1,...,yn has the condition c-ty1:Dt1,...,yn:Dtn : Υ → Bool, which is called the effective condition of the transition. If c-ty1,...,yn (υ) does not hold, then ty1,...,yn (υ) =S υ. For brevity, we suppose that the name t of each transition ty1:Dt1,...,yn:Dtn : Υ → Υ is distinct from each other. Therefore, the name t may be used to refer to the transition and the name c-t may be used to refer to the effective condition. 
The definition of each transition looks like:
ty ,...,y (υ)  υ' if c-ty ,...,y (υ) s.t.
... 
ox ,...,x  (υ')= ... 
... 
where c-ty1,...,yn (υ)   ... 
The definition says that if c-ty1,...,yn (υ) holds for a given state υ, then ty1,...,yn
moves υ to υ' that satisfies all equations between s.t. and where, and

if c-ty ,...,y
(υ) does not, then ty ,...,y
does not change υ.	If ox ,...,x
(υ')

1	n	1	n	1	m

equals ox ,...,x
(υ), the corresponding equation “ox ,...,x
(υ') = ox ,...,x
(υ)”

1	m	1	m	1	m
can be omitted.	The definition of c-ty1,...,yn  is written after where.	If
c-ty1,...,yn (υ) holds for an arbitrary state υ, then “if c-ty1,...,yn (υ)” and “where
c-ty1,. ,yn (υ)	” may be omitted.
Given an OTS S and two states υ, υ' ∈ Υ, if there exist t ∈T and yk : Dtk
'	'	'
for k = 1....,n such that ty1,...,yn (υ) =S υ , we write υ ~S υ  and call υ

a successor state of υ with respect to (wrt) S. ~∗
is a reflexive transitive

closure of ~S . When k time applications of transitions move υ to υ', we write

υ ~k
υ'. That is, υ ~0
υ' such that υ =S υ', and υ ~k+1 υ' if there exists

υ'' ∈ Υ such that υ ~k υ'' and υ'' ~S υ'.
Definition 2.2 Given an OTS S, reachable states wrt S are inductively de- fined:
Each υ ∈I is reachable wrt S.
For each υ, υ' ∈ Υ such that υ ~S υ', if υ is reachable wrt S, so is υ'.
Let RS be the set of all reachable states wrt S.	 
Proposition 2.3 Given an arbitrary OTS S and arbitrary two states υ, υ' ∈
Υ such that υ ~∗ υ', if υ is reachable wrt S, then so is υ'.

Proof. By induction on k in υ ~k υ'. If k is 0, it is trivial. If υ ~k+1 υ',
there exists υ'' such that υ ~k υ'' and υ'' ~S υ'. Since υ'' is reachable wrt S
from the induction hypothesis, so is υ' from Definition 2.2.	 
Predicates whose types are Υ → Bool are called state predicates.	All properties considered in this paper are invariant properties.
Definition 2.4 Any state predicate p :Υ → Bool is called invariant wrt S if
p holds in all reachable states wrt S, i.e. ∀υ : RS . p(υ).	 
Example 2.5 Let us consider a communication protocol, which directly de- livers natural numbers from the sender to the receiver. The communication protocol is called a bare communication protocol (BCP). Figure 1 shows a snap- shot of BCP. The sender has a natural number variable (index) and the receiver has a list (list) of natural numbers. Initially, index is 0 and list is nil. What BCP does is as follows:
send: index is added to list and incremented. The OTS SBCP modeling BCP is as follows:
OBCP  {index : Υ → Nat, list : Υ → List} IBCP  {υ | index(υ)=0 ∧ list(υ)= nil} TBCP  {send : Υ → Υ}
where Nat and List are the data types for natural numbers and lists of natural numbers, respectively. The transition send is defined as follows:
send(υ)  υ' s.t.
index(υ') = index(υ)+1 list(υ') = (index(υ) list(υ))
The juxtaposition operator is used as the constructor of non-nil lists. That is, index(υ) list(υ) is the list obtained by adding index(υ) to list(υ) at the top.
One desired property that BCP should satisfy is as follows: when the receiver receives N natural numbers, they are the first N natural numbers that the sender has sent and the order in which the N natural numbers has been sent is preserved. The property is called the reliable communication property in this paper. The property can be formalized as an invariant property wrt SBCP with the state predicate that is defined as follows:
rc0(υ)  mk(index(υ)) = (index(υ) list(υ))
where mk(0) equals nil and mk(k + 1) equals (k + 1 mk(k)). The verification that BCP satisfies the reliable communication property is equivalent to the proof of ∀υ : RSBCP . rc0(υ).	 

Se,nde,r	Re,ceiv,er
 / J	send	) / J

/	/

index: 3 /\
/\	list: (2, 1, 0)

/  \	/  \



CafeOBJ
Fig. 1. A snapshot of BCP

CafeOBJ 3 [4] is an algebraic specification language mainly based on order- sorted algebras and hidden algebras [8,5]. A specification written in CafeOBJ is basically a set of equations. One functionality provided by the CafeOBJ sys- tem (which is an implementation of CafeOBJ and simply referred as CafeOBJ) is a rewrite engine, which reduces a given term by regarding equations as left- to-right rewrite rules. The executability makes it possible to use CafeOBJ as an interactive proof assistant.
Data types are specified in terms of order-sorted algebras, and state ma- chines such as OTSs are specified in terms of hidden algebras. Algebraic specifications of state machines are called behavioral speciﬁcations. There are two kinds of sorts in CafeOBJ: visible sorts and hidden sorts. A visible sort denotes a data type, while a hidden sort denotes the state space of a state machine. There are three kinds of operators (or operations) wrt hidden sorts: hidden constants, action operators and observation operators. Hidden con- stants denote initial states of state machines, action operators denote state transitions of state machines, and observation operators let us know the sit- uation where state machines are located. Both an action operator and an observation operator take a state of a state machine and zero or more data. The action operator returns the successor state of the state wrt the state tran- sition denoted by the action operator plus the data. The observation operator returns a value that characterizes the situation where the state machine is located.
Basic units of CafeOBJ specifications are modules. CafeOBJ provides built-in modules. One of the most important built-in modules is BOOL in which propositional logic is specified. BOOL is automatically imported by al- most every module unless otherwise stated. In BOOL and its parent modules, declared are the visible sort Bool, the constants true and false of Bool, and operators denoting some basic logical connectives. Among the operators are not_, _and_, _or_, _xor_, _implies_ and _iff_ denoting negation (¬),

3 See http://www.ldl.jaist.ac.jp/cafeobj/.

conjunction (∧), disjunction (∨), exclusive disjunction (xor), implication (⇒) and logical equivalence (⇔), respectively. An underscore _ indicates the place where an argument is put such as B1 and B2. The operator if_then_else_fi corresponding to the if construct in programming languages is also declared. CafeOBJ uses the Hsiang term rewriting system [9] as the decision procedure for propositional logic, which is implemented in BOOL. CafeOBJ reduces any term denoting a proposition that is always true (false) to true (false). More generally, a term denoting a proposition reduces to an exclusively disjunctive normal form of the proposition.
SBCP is used as an example to describe specification in CafeOBJ and ver- ification with CafeOBJ.
Speciﬁcation in CafeOBJ
The data types used are first specified. Natural numbers are specified in the module PNAT:
mod! PNAT { [Nat]
op 0 : -> Nat op s : Nat -> Nat op _=_ : Nat Nat -> Bool {comm} vars X Y : Nat
eq (X = X) = true . eq (0 = s(X)) = false . eq (s(X) = s(Y)) = (X = Y) .
}
The keyword mod! indicates that the module is a tight semantics declaration, meaning the smallest model (implementation) that respects all requirements written in the module. Visible sorts are declared by enclosing them with [ and ]. Nat is the visible sort of natural numbers. The keyword op is used to declare (non-observation and action) operators, and ops to declare more than one such operator simultaneously. The operator 0 denotes zero and the operator s is the successor function of natural numbers. Operators with no arguments such as 0 are called constants. The operator _=_ checks if two natural numbers are equal. The keyword comm specifies that the operator _=_ is commutative. The keyword var is used to declare variables, and vars to declare more than one variable simultaneously. X and Y are variables of Nat. The keyword eq is used to declare equations, and ceq to declare conditional equations. Equations and conditional equations are used to define operators and specify properties of operators.
Generic lists are specified in the module List:
mod! LIST(M :: EQTRIV) { [List]
op nil : -> List    op   : Elt.M List -> List

op hd : List -> Elt.M op tl : List -> List op _=_ : List List -> Bool {comm}
vars L L1 L2 : List vars X Y : Elt.M eq hd(X L) = X .	eq tl(X L) = L .
eq (L = L) = true . eq (nil = X L) = false . eq (X L1 = Y L2) = (X = Y and L1 = L2) .
}
The constant nil denotes the nil list and the juxtaposition operator   is the constructor of non-nil lists. The operators hd and tl are the usual functions of lists. The operator _=_ checks if two lists are equal.
LIST has the (formal) parameter M. Given a module that respects all the requirements in the module EQTRIV as an actual parameter, List is instanti- ated. EQTRIV is as follows:
mod* EQTRIV { [Elt]
op _=_ : Elt Elt -> Bool {comm}
}
The keyword mod* indicates that the module is a loose semantics declaration, meaning an arbitrary model (implementation) that respects all requirements written in the module.
Lists of natural numbers are specified in the module PNAT-LIST:
mod! PNAT-LIST { pr(LIST(PNAT))
op mk : Nat -> List var X : Nat
eq mk(0) = 0 nil . eq mk(s(X)) = s(X) mk(X) .
}
LIST(PNAT) is the instance of LIST with PNAT. The keyword pr is used to import modules. The operator mk takes a natural number k and makes the list (k, k − 1,..., 0).
Now that we have all data types used in SBCP, SBCP is next specified in the module BCP:
mod* BCP { pr(PNAT-LIST) *[Sys0]* op init : -> Sys0
bop index : Sys0 -> Nat bop list : Sys0 -> List bop send : Sys0 -> Sys0
var S : Sys0
eq index(init) = 0 . eq list(init) = nil . eq index(send(S)) = s(index(S)) .
eq list(send(S)) = index(S) list(S) .

}
Hidden sorts are declared by enclosing them with *[ and ]*. Sys0 is the hidden sort denoting Υ. The hidden constant init denotes an arbitrary initial state of SBCP. The keyword bop is used to declare observation and action operators, and bops to declare more than one such operator simultaneously. The observation operators index and list correspond to the observers index and list, respectively. The action operator send corresponds to the transition send. The first two equations define init and the last two equations define the transition send.

Veriﬁcation with CafeOBJ
We describe the verification that BCP satisfies the property.
The module INV is first declared:
mod INV { pr(BCP)
op BCP-inv1 : Sys0 -> Bool var S0 : Sys0
eq BCP-inv1(S0) = (index(S0) list(S0) = mk(index(S0))) .
}
The keyword mod is used to declare modules, which are not parts of (system) specifications. The operator BCP-inv1 corresponds to the state predicate rc0. The proof of ∀υ : RSBCP . rc0(υ) is done by induction on υ. Therefore, the module ISTEP is declared:
mod ISTEP { pr(INV) ops s0 s0’ : -> Sys0
op BCP-istep1 : -> Bool
eq BCP-istep1 = BCP-inv1(s0) implies BCP-inv1(s0’) .
}
The constant s0 denotes an arbitrary state and the constant s0’ is used to denote a successor state of s0 in proofs written in CafeOBJ. The term BCP-inv1(s0’) is the formula to prove in each induction case, and the term BCP-inv1(s0) is the induction hypothesis.
The proof written in CafeOBJ is as follows:
open INV
red BCP-inv1(init) . close
open ISTEP
eq s0’ = send(s0) .



υ ∈ I 
ˆ
r
。v
υ ∈ RS	
ˆ	S
r
υ' ∈ RS
ˆ
r

υA ∈ IA
υA ∈ RSA	SA
'
A
∈ RSA

Condition (i)	Condition (ii)
Fig. 2. A simulation r from S to SA
red BCP-istep1 . close
Such proofs are called proof scores. The keyword open makes a temporary module that imports a given module and the keyword close destroys such a temporary module. Each fragment enclosed with open and close in proof scores is called a proof passage. The proof score consists of two proof passages. CafeOBJ returns true for each of the two proof passages, which means that
∀υ : RSBCP . rc0(υ) has been proved.
A survey of proof scores in CafeOBJ is described in [7].

Simulations from OTSs to OTSs
Simulations from OTSs to OTSs are defined as follows:
Definition 4.1 Given OTSs S and SA, r : RS RSA → Bool is called a simu- lation from S to SA if it satisfies the following conditions:
For each υ ∈ I, there exists υA ∈ IA such that r(υ, υA).
For each υ, υ' ∈ RS and υA ∈ RS  such that r(υ, υA) and υ ~S υ', there

exists υ' ∈ RS  such that r(υ', υ' ) and υA ~∗
υ' .

A	A	A
SA	A

Note that if υA ∈ RS
and υA ~∗	υ' , then υ' ∈ RS
from Proposition 2.3. 

A	SA	A	A	A
Figure 2 shows the diagrams corresponding to the two conditions in Defi- nition 4.1. When there exists a simulation r from S to SA, we may say that S is simulated by SA (in terms of r), or SA simulates S (in terms of r).
Since Definition 4.1 does not say explicitly that for each υ ∈ RS , there exists υA ∈ RSA such that r(υ, υA), we need to have the following proposition:
Proposition 4.2 Given arbitrary OTSs S, SA such that there exists a sim- ulation from S to SA and an arbitrary such simulation r, for each υ ∈ RS , there exists υA ∈ RSA such that r(υ, υA).

Se,nde,r	Re,ceiv,er
send1	zz rec2
  J	cell1	zzza  J

bit1: f
// 
z zzz
//  bit2: t

index: 2 /\
rec1
z
 c 
send2	/\
list: (2, 1, 0)

/  \	cell2	/  \
Fig. 3. A snapshot of SCP
Proof. By induction on υ ∈ RS . If υ ∈ I, then there exists υA ∈ RSA such
that r(υ, υA) from Definition 4.1 (i). If υ ~S υ', then there exists υA ∈ RS
A
such that r(υ, υA) from the induction hypothesis. Then, from Definition 4.1

(ii), there exists υ' ∈ RS  such that r(υ', υ' ) and υA ~∗
υ' .	 

A	A	A
SA	A

Then, we have the theorem that guarantees the correctness of the proposed invariant verification method.
Theorem 4.3 Given arbitrary OTSs S and SA such that there exists a sim- ulation from S to SA, an arbitrary such simulation r and arbitrary state pred- icates p, pA such that pA(υA) ⇒ p(υ) for arbitrary states υ, υA with r(υ, υA), if ∀υA : RSA . pA(υA), then ∀υ : RS . p(υ).
Proof. For an arbitrary υ ∈ RS , there exists υA ∈ RSA with r(υ, υA) from Proposition 4.2. Therefore, p(υ) holds from the assumption.	 
Example 4.4 Let us consider another communication protocol, which is a simplified version of the alternating bit protocol (ABP). The communication protocol is called a simple communication protocol (SCP). SCP uses unreliable cells as communication channels, while ABP uses unreliable queues. Cells used are unreliable in that their contents can be lost. Figure 3 shows a snapshot of SCP. The sender intends to send the receiver natural numbers from 0 in increasing order. SCP uses two cells: one (cell1) is used for sending pairs of Boolean values and natural numbers from the sender to the receiver, and the other (cell2) for sending Boolean values from the receiver to the sender. The sender has a Boolean variable (bit1) and a natural number variable (index), and the receiver has a Boolean variable (bit2) and a list (list) of natural numbers. Initially, both cell1 and cell2 are empty, both bit1 and bit2 are false, index is 0, and list is nil.
What the sender does is as follows:
send1: The sender repeatedly puts a pair of bit1 and index into cell1.
rec1: The sender gets a Boolean value b from cell2 when it is not empty. If
b is different from bit1, bit1 is complemented and index is incremented.
What the receiver does is as follows:

send2: The receiver repeatedly puts bit2 into cell2.
rec2: The receiver gets a pair of a Boolean value b and a natural number n from cell1 when it is not empty. If b is the same as bit2, bit2 is complemented and n is added to list.
The unreliability of the two cells is realized as follows:
drop1: cell1 becomes empty if it is not empty.
drop2: cell2 becomes empty if it is not empty. The OTS £SCP modeling SCP is as follows:
0SCP  {cell1 : Υ → PCell, cell2 : Υ → BCell, bit1 : Υ → Bool, index : Υ → Nat, bit2 : Υ → Bool, list : Υ → List}
fSCP  {υ | cell1(υ) = empty Λ cell2(υ)= empty Λ bit1(υ) = false Λ
index(υ)=0 Λ bit2(υ) = false Λ list(υ)= nil}
7SCP  {send1 : Υ → Υ, rec1 : Υ → Υ, send2 : Υ → Υ, rec2 : Υ → Υ, drop1 : Υ → Υ, drop2 : Υ → Υ}
where PCell and BCell are data types for cells of pairs of Boolean values and natural numbers and for cells of Boolean values, respectively.
The six transitions are defined as follows:
send1(υ)  υ' s.t.
cell1(υ')= c(⟨bit1(υ), index(υ)⟩)
rec1(υ)  υ' if c-rec1(υ) s.t.
cell2(υ') = empty
bit1(υ')= if bit1(υ) = get(cell2(υ)) then bit1(υ) else чbit1(υ) index(υ')= if bit1(υ) = get(cell2(υ)) then index(υ) else index(υ)+1 where c-rec1(υ)  cell2(υ) /= empty
send2(υ)  υ' s.t.
cell2(υ') = c(bit2(υ))
rec2(υ)  υ' if c-rec2(υ) s.t.
cell1(υ') = empty
bit2(υ')= if bit2(υ) = fst(get(cell1(υ))) then чbit2(υ) else bit2(υ) list(υ')= if bit2(υ) = fst(get(cell1(υ)))
then (snd(get(cell1(υ))) list(υ)) else list(υ)
where c-rec2(υ)  cell1(υ) /= empty
drop1(υ)  υ' if c-drop1(υ) s.t.
cell1(υ') = empty
where c-drop1(υ)  cell1(υ) /= empty

drop2(υ)  υ' if c-drop2(υ) s.t.
cell2(υ') = empty
where c-drop2(υ)  cell2(υ) /= empty
where c is the constructor of cells, get gets the content of a given cell if it is not empty, and fst and snd extract the first and second elements of a given pair, respectively.
The reliable communication property wrt SCP can be formalized as an invariant property wrt £SCP with the state predicate that is defined as follows:
rc1(υ)  (bit1(υ) = bit2(υ) ⇒ mk(index(υ)) = (index(υ) list(υ))) Λ
(bit1(υ) /= bit2(υ) ⇒ mk(index(υ)) = list(υ))
The verification that SCP satisfies the reliable communication property is equivalent to the proof of 6υ : YSSCP . rc1(υ).
If we find a simulation r1 from £SCP to £BCP such that rc0(υ0) ⇒ rc1(υ1) for arbitrary states υ0, υ1 with r1(υ1, υ0), then completed is the verification that SCP satisfies the property. One candidate for such simulations is as follows:
r1(υ1, υ0)  (if bit1(υ1) = bit2(υ1)
then index(υ1) = index(υ0) else index(υ1) + 1 = index(υ0))
Λ (list(υ1) = list(υ0))
We describe the proof of rc0(υ0) ⇒ rc1(υ1) for arbitrary states υ0, υ1 with r1(υ1, υ0) and the proof that the candidate is really a simulation from £SCP to
£BCP in the coming section.	 

Simulation-based Invariant Verification
The simulation-based invariant verification method proposed in this paper is described. When we want to verify that an OTS £ satisfies an invariant property p, namely to prove 6υ ∈ YS . p(υ), all we have to do is as follows:
To make another OTS £A, which is more abstract than £ and seems clearly to satisfy an invariant property pA that corresponds to p.
To verify that £A satisfies pA, namely to prove 6υA : YSA . pA(υA).
To conjecture a simulation candidate r from £ to £A such that pA(υA) implies p(υ) for each υ, υA such that r(υ, υA).
To prove that r is a simulation from £ to £A.
We describe the verification that SCP satisfies the reliable communication property by proving rc0(υ0) ⇒ rc1(υ1) for arbitrary states υ0, υ1 with r1(υ1, υ0) and that r1 is a simulation from £SCP to £BCP.

Speciﬁcation of SCP
£SCP is specified in the module SCP. In the module, declared are the following hidden sort, hidden constant, observation operators and action operators:
*[Sys1]*
The set of equations defining init is as follows:
eq cell1(init) = empty . eq cell2(init) = empty . eq bit1(init) = false . eq bit2(init) = false . eq index(init) = 0 .   eq list(init) = nil .
In this paper, the set of equations defining rec2 is shown:
op c-rec2 : Sys1 -> Bool
eq c-rec2(S) = not(cell1(S) = empty) . ceq cell1(rec2(S)) = empty if c-rec2(S) . eq cell2(rec2(S)) = cell2(S) .
eq bit1(rec2(S)) = bit1(S) .
ceq bit2(rec2(S)) = (if bit2(S) = fst(get(cell1(S))) then not bit2(S) else bit2(S) fi) if c-rec2(S) .
eq index(rec2(S)) = index(S) .
ceq list(rec2(S))  = (if bit2(S) = fst(get(cell1(S))) then (snd(get(cell1(S))) list(S)) else list(S) fi)
if c-rec2(S) .
ceq rec2(S)	= S if not c-rec2(S) .
S is a CafeOBJ variable of Sys1.

Veriﬁcation of SCP on the Reliable Communication Property
In the module INV shown in Subsection 3.2, the module SCP is imported and the following things are declared:
op SCP-inv1 : Sys1 -> Bool eq SCP-inv1(S1)
= (bit1(S1) = bit2(S1)
implies (index(S1) list(S1)) = mk(index(S1))) and

(not(bit1(S1) = bit2(S1))
implies list(S1) = mk(index(S1))) .
where S1 is a CafeOBJ variable of Sys1, which is declared in INV. The operator
SCP-inv1 corresponds to the state predicate rc1.
The module SIM is then declared:
mod SIM { pr(INV)
op SCP2BCP-sim1 : Sys1 Sys0 -> Bool var S1 : Sys1 var S0 : Sys0
eq SCP2BCP-sim1(S1,S0)
= (if bit1(S1) = bit2(S1) then index(S1) = index(S0)
else s(index(S1)) = index(S0) fi) and (list(S1) = list(S0)) .
}
The operator SCP2BCP-sim1 corresponds to the simulation candidate r1 from
£SCP to £BCP.
We first describe the proof of rc0(υ0) ⇒ rc1(υ1) for arbitrary states υ0, υ1 with r1(υ1, υ0). The proof is done by case splitting. The case is split into five sub-cases. Each sub-case is characterized by a set of equations in proof scores. The five sets of equations for the five sub-cases are as follows 4 :
(list(s1) = list(s0)) = false
list(s1) = list(s0), bit1(s1) = bit2(s1), index(s1) = index(s0)
list(s1) = list(s0), bit1(s1) = bit2(s1), (index(s1) = index(s0)) = false
list(s1) = list(s0), (bit1(s1) = bit2(s1)) = false, index(s0) = s(index(s1))
list(s1) = list(s0), (bit1(s1) = bit2(s1)) = false, (index(s0) = s(index(s1))) = false
where s0 and s1 are constants of Sys0 and Sys1, respectively, denoting arbi- trary states.
The proof passage of the second sub-case is shown:
open SIM
op s1 : -> Sys1 . op s0 : -> Sys0 .
eq list(s1) = list(s0) . eq bit1(s1) = bit2(s1) . eq index(s1) = index(s0) .
red SCP2BCP-sim1(s1,s0)

4 Note that s in s(index(s1))) is the successor function of natural numbers.

implies (BCP-inv1(s0) implies SCP-inv1(s1)) .
close
CafeOBJ returns true for the proof passages, and also for the remaining four proof passages.
For the proof that r1 is a simulation from £SCP to £BCP, one more module called SIM-ISTEP is declared:
mod SIM-ISTEP { pr(SIM)
ops s1 s1’ : -> Sys1 ops s0 s0’ : -> Sys0 op SCP2BCP-istep1 : Sys0 -> Bool
var S0’ : Sys0
eq SCP2BCP-istep1(S0’)
= SCP2BCP-sim1(s1,s0) implies SCP2BCP-sim1(s1’,S0’) .
}
The module is used for checking the second condition in Definition 4.1. The constants s1, s0, s1’ and s0’ correspond to υ, υA, υ' and υ' , respectively. The CafeOBJ variable S0’ in the term SCP2BCP-istep1(S0’) is interpreted as existentially quantified. SCP2BCP-istep1(S0’) is the formula to prove for each transition of £SCP (or each action of SCP) for the second condition. SCP2BCP-sim1(s1,s0) corresponds to the assumption r(υ, υA) in the second condition, and the assumption υ ~S υ' in the second condition is written in each proof passage for checking the second condition.
The proof passage of the first condition is shown:
open SIM
red SCP2BCP-sim1(init,init). close
CafeOBJ returns true for the proof passage.
The proof of the second condition is first split into the six cases that correspond to the six transitions of £SCP (or six actions of SCP), respectively. We describe the case for rec2 in this paper.
The case for rec2 is split into eight sub-cases. The eight sets of equations for the eight sub-cases are as follows:
cell1(s1) = c(< b,n >), bit1(s1) = bit2(s1), (bit2(s1) = b) = false
cell1(s1) = c(< b,n >), bit1(s1) = bit2(s1),
bit2(s1) = b, index(s1) = n, ((b xor true) = b) = false
cell1(s1) = c(< b,n >), bit1(s1) = bit2(s1), bit2(s1) = b, index(s1) = n, (b xor true) = b

cell1(s1) = c(< b,n >), bit1(s1) = bit2(s1), bit2(s1) = b, (index(s1) = n) = false
cell1(s1) = c(< b,n >), (bit1(s1) = bit2(s1)) = false, b = bit1(s1)
cell1(s1) = c(< b,n >), (bit1(s1) = bit2(s1)) = false, (b = bit1(s1)) = false, b = bit2(s1)
cell1(s1) = c(< b,n >), (bit1(s1) = bit2(s1)) = false, (b = bit1(s1)) = false, (b = bit2(s1)) = false
c-rec2(s1) = false
where the constants b and n denote an arbitrary Boolean value and an arbi- trary natural number, respectively. Note that the equation cell1(s1) = c(< b,n >) is equivalent to the equation c-rec2(s1) = true.
The proof passage of the second sub-case is as follows:
open SIM-ISTEP
op b : -> Bool . op n : -> Nat .
eq cell1(s1) = c(< b,n >) . eq bit1(s1) = bit2(s1) . eq bit2(s1) = b . eq index(s1) = n .
eq ((b xor true) = b) = false .
eq s1’ = rec2(s1) . eq s0’ = send(s0) . red SCP2BCP-istep1(s0’) .
close
The equation s1’ = rec2(s1) corresponds to the assumption υ ~S υ' in the second condition. CafeOBJ returns true for the proof passage.
The proof passage of the third sub-case is as follows:
open SIM-ISTEP
op b : -> Bool . op n : -> Nat .
eq cell1(s1) = c(< b,n >) . eq bit1(s1) = bit2(s1) .
eq bit2(s1) = b . eq index(s1) = n . eq (b xor true) = b . eq s1’ = rec2(s1) . eq s0’ = s0 .
red eqbool-lemma1(b) implies SCP2BCP-istep1(s0’) . close
The proof passage uses the lemma eqbool-lemma1 on Boolean values. The lemma is as follows:
eq eqbool-lemma1(B) = not((not B) = B) .
where B is a CafeOBJ variable of Bool. CafeOBJ returns true for the proof passage.
The proof passage of the fourth sub-case is as follows:

open SIM-ISTEP
op b : -> Bool . op n : -> Nat .
eq cell1(s1) = c(< b,n >) . eq bit1(s1) = bit2(s1) . eq bit2(s1) = b . eq (index(s1) = n) = false .
eq s1’ = rec2(s1) . eq s0’ = s0 .
red SCP-inv3(s1) implies SCP2BCP-istep1(s0’) . close
The proof passage uses the invariant property SCP-inv3 wrt £SCP. The in- variant property declared in the module INV is as follows:
eq SCP-inv3(S1) = (not(cell1(S1) = empty) and
bit2(S1) = fst(get(cell1(S1)))
implies index(S1) = snd(get(cell1(S1)))) .
CafeOBJ returns true for the proof passage.
The proof passages of the remaining four sub-cases can be written likewise. The proof passage of the sixth sub-case uses the invariant property SCP-inv4 wrt £SCP. The invariant property declared in the module INV is as follows:
eq SCP-inv4(S1) = (not(cell1(S1) = empty) and
bit2(S1) = fst(get(cell1(S1)))
implies bit1(S1) = fst(get(cell1(S1)))) .
The proof passages of the other sub-cases use neither lemmas nor invariant properties.
The proof passages of the remaining cases for send1, rec1, send2, drop1 and drop2 can be written likewise. The case for send1 uses two lemmas on Boolean values and one invariant property wrt £SCP. The two lemmas are as follows:
eq eqbool-lemma2(B1,B2,B3) = (B1 = B2 or B1 = B3 or B2 = B3) . eq eqbool-lemma3(B1,B2)
= (not (B1 = B2)) implies (B1 = (not B2)) .
The invariant property declared in the module INV is as follows:
eq SCP-inv2(S1) = ((cell2(S1) = empty) or
bit1(S1) = get(cell2(S1)) or bit2(S1) = get(cell2(S1))) .
The other cases use neither lemmas nor invariant properties.

Compositions of Simulations from OTSs to OTSs
The composition s ◦ r : A C → Bool of two relations r : A B → Bool and
s : B C → Bool is defined as follows: for each a ∈ A and c ∈ C, s ◦ r(a, c) if

Se,nde,r	Re,ceiv,er
send1	zz rec2

  J 
queue1
zzza  J

bit1: f
//  z zzz
//  bit2: t

index: 2 /\
rec1
z
 c 
send2	/\
list: (2, 1, 0)

/  \	queue2	/  \
Fig. 4. A snapshot of ABP
and only if there exists b ∈ B such that r(a, b) and s(b, c).
Lemma 6.1 Given arbitrary OTSs £, £A and £B such that there exist a sim- ulation r from £ to £A and a simulation s from £A to £B, for each υ, υ' ∈ YS

and υB ∈ YSB
such that s ◦ r(υ, υB) and υ ~S υ', there exists υ'
such that

s ◦ r(υ', υ' ) and υB ~∗  υ' .
B	SB	B
Proof. There exists υA ∈ YSA such that r(υ, υA) and s(υA, υB) because of

s ◦ r(υ, υB). There also exists υ'
∈ YSA
such that υA ~∗
' and r(υ', υ' )

because r is a simulation from £ to £A. All we have to do is to show that

there exists υ' ∈ YS  such that s(υ' , υ' ) and υB ~∗
υ' . This is proved by

B	B	A	B
SB	B

induction on k in υA ~k	υ' .

If k is 0, υB is a witness. If υA ~k+1 υ' , there exists υ'' ∈ YS
such that

SA	A	A	A

υA ~k	υ''
and υ'' ~S	υ' . There also exists υ'' such that s(υ'' , υ'' ) and

SA	A
A	A	A
B	A	B

υB ~∗  υ'' from the induction hypothesis. Therefore, we have υ' ∈ YS
such

SB	B	B	B
that s(υ' , υ' ) and υ'' ~∗  υ' because s is a simulation from £A to £B. Then,
A	B	B	SB	B
' is a witness.	 
Theorem 6.2 Given arbitrary OTSs £, £A and £B such that there exist a simulation r from £ to £A and a simulation s from £A to £B, the composition s ◦ r is a simulation from £ to £B.
Proof. For each υ ∈ f, there exists υB ∈ fB such that s ◦ r(υ, υB) because for each υ ∈ f, there exists υA ∈ fA such that r(υ, υA) and for each υA ∈ fA, there exists υB ∈ fB such that s(υA, υB). Then, the first condition that s ◦ r is such a simulation is fulfilled. The second condition is also satisfied thanks to Lemma 6.1.	 
We describe the verification that £ABP is simulated by £BCP by showing that there exists a simulation from £ABP to £SCP.
Modeling ABP
A snapshot of ABP is shown in Figure 4. Queues used are unreliable in that their contents can be lost and duplicated. Like BCP and SCP, the sender intends to send the receiver natural numbers from 0 in increasing order. The

only difference between ABP and SCP is that ABP uses two unreliable queues, while SCP uses two unreliable cells. Initially, both queue1 and queue2 are empty, both bit1 and bit2 are false, index is 0, and list is nil.
What the sender does is as follows:
send1: The sender repeatedly puts a pair of bit1 and index into queue1.
rec1: The sender gets a Boolean value b from queue2 when it is not empty. If b is different from bit1, bit1 is complemented and index is incremented.
What the receiver does is as follows:
send2: The receiver repeatedly puts bit2 into queue2.
rec2: The receiver gets a pair of a Boolean value b and a natural number n from queue1 when it is not empty. If b is the same as bit2, bit2 is complemented and n is added to list.
The unreliability of the two queues is realized as follows:
drop1: The top element of queue1 is deleted if it is not empty.
dup1: The top element of queue1 is duplicated if it is not empty.
drop2: The top element of queue2 is deleted if it is not empty.
dup2: The top element of queue2 is duplicated if it is not empty. The OTS £ABP modeling ABP is as follows:
0ABP  {queue1 : Υ → PQueue, queue2 : Υ → BQueue, bit1 : Υ → Bool, index : Υ → Nat, bit2 : Υ → Bool, list : Υ → List}
fABP  {υ | queue1(υ) = empty Λ queue2(υ) = empty Λ bit1(υ) = false Λ
index(υ)=0 Λ bit2(υ) = false Λ list(υ) = nil}
7ABP  {send1 : Υ → Υ, rec1 : Υ → Υ, send2 : Υ → Υ, rec2 : Υ → Υ, drop1 : Υ → Υ, dup1 : Υ → Υ, drop2 : Υ → Υ, dup2 : Υ → Υ}
where PQueue and BQueue are data types for queues of pairs of Boolean values and natural numbers and for queues of Boolean values, respectively.
The eight transitions are defined as follows:
send1(υ)  υ' s.t.
queue1(υ') = put(queue1(υ), ⟨bit1(υ), index(υ)⟩)
rec1(υ)  υ' if c-rec1(υ) s.t.
queue2(υ') = get(queue2(υ))
bit1(υ')= if bit1(υ) = top(queue2(υ)) then bit1(υ) else чbit1(υ) index(υ')= if bit1(υ) = top(queue2(υ)) then index(υ) else index(υ)+1 where c-rec1(υ)  queue2(υ) /= empty
send2(υ)  υ' s.t.

queue2(υ') = put(queue2(υ), bit2(υ))
rec2(υ)  υ' if c-rec2(υ) s.t.
queue1(υ') = get(queue1(υ))
bit2(υ')= if bit2(υ) = fst(top(queue1(υ))) then чbit2(υ) else bit2(υ) list(υ')= if bit2(υ) = fst(top(queue1(υ)))
then (snd(top(queue1(υ))) list(υ)) else list(υ)
where c-rec2(υ)  queue1(υ) /= empty
drop1(υ)  υ' if c-drop1(υ) s.t.
queue1(υ') = get(queue1(υ))
where c-drop1(υ)  queue1(υ) /= empty
dup1(υ)  υ' if c-dup1(υ) s.t.
queue1(υ') = top(queue1(υ)) , queue1(υ)
where c-dup1(υ)  queue1(υ) /= empty
drop2(υ)  υ' if c-drop2(υ) s.t.
queue2(υ') = get(queue2(υ))
where c-drop2(υ)  queue2(υ) /= empty
dup2(υ)  υ' if c-dup2(υ) s.t.
queue2(υ') = top(queue2(υ)) , queue2(υ)
where c-dup2(υ)  queue2(υ) /= empty
where the comma in top(queuei(υ)) , queuei(υ) for i = 1, 2 is the constructor of non-empty queues, top returns the top element of a given queue if it is not empty, get returns the queue obtained by deleting the top element from a given queue if it is not empty, and put returns the queue obtained by adding a given element to a given queue at the end.
The reliable communication property wrt ABP can be formalized as an invariant property wrt £ABP with the state predicate that is defined as follows:
rc2(υ)  (bit1(υ) = bit2(υ) ⇒ mk(index(υ)) = (index(υ) list(υ))) Λ
(bit1(υ) /= bit2(υ) ⇒ mk(index(υ))= list(υ))
The verification that ABP satisfies the reliable communication property is equivalent to the proof of 6υ : YSABP . rc2(υ).
A simulation candidate r2 from £ABP to £SCP is as follows:
r2(υ2, υ1)  (bit1(υ2) = bit1(υ1)) Λ (bit2(υ2) = bit2(υ1)) Λ
(index(υ2) = index(υ1)) Λ (lits(υ2) = list(υ1)) Λ
6pq : PQueue. ((queue1(υ2)= ⟨bit1(υ2), index(υ2)⟩ , pq )
⇒ (cell1(υ1)= c(⟨bit1(υ2), index(υ2)⟩))) Λ 6bq : BQueue. ((queue2(υ2)= bit2(υ2), bq )
⇒ (cell2(υ1) = c(bit2(υ2))))

We prove from Theorem 6.2 that ∃υ1 : YSSCP . r2(υ2, υ1) Λ r1(υ1, υ0) is a sim- ulation from £ABP to £BCP by proving that r2 is a simulation from £ABP to
£SCP because r1 is a simulation from £SCP to £BCP.
The remaining thing to do so as to prove 6υ : YSABP . rc2(υ) is to prove rc0(υ0) ⇒ rc2(υ2) for arbitrary states υ0, υ2 with ∃υ1 : YSSCP . r2(υ2, υ1) Λ r1(υ1, υ0) or to prove rc1(υ1) ⇒ rc2(υ2) for arbitrary states υ1, υ2 with r2(υ2, υ1). Either proof can be straightforwardly done.

Speciﬁcation of ABP
£ABP is specified in the module ABP. In the module, declared are the following hidden sort, hidden constant, observation operators and action operators:
*[Sys2]*
The set of equations defining init is as follows:
eq queue1(init) = empty . eq queue2(init) = empty . eq bit1(init)  = false . eq bit2(init)  = false . eq index(init) = 0 .   eq list(init)  = nil .
In this paper, the set of equations defining rec2 is shown:
op c-rec2 : Sys2 -> Bool
eq c-rec2(S) = not(queue1(S) = empty) .
ceq queue1(rec2(S)) = get(queue1(S)) if c-rec2(S) . eq queue2(rec2(S)) = queue2(S) .
eq bit1(rec2(S))	= bit1(S) . ceq bit2(rec2(S))
= (if bit2(S) = fst(top(queue1(S)))
then not bit2(S) else bit2(S) fi) if c-rec2(S) . eq index(rec2(S)) = index(S) .
ceq list(rec2(S))
= (if bit2(S) = fst(top(queue1(S)))
then (snd(top(queue1(S))) list(S)) else list(S) fi) if c-rec2(S) .

ceq rec2(S)	= S if not c-rec2(S) .
S is a CafeOBJ variable of Sys2.
Veriﬁcation that ABP is Simulated by BCP
In the module INV, the module ABP is imported. In the module SIM, the following things are declared:
op ABP2SCP-sim1 : Sys2 Sys1 PQueue BQueue -> Bool eq ABP2SCP-sim1(S2,S1,PQ,BQ)
= (bit1(S2) = bit1(S1)) and (bit2(S2) = bit2(S1)) and (index(S2) = index(S1)) and (list(S2) = list(S1)) and (queue1(S2) = < bit1(S2),index(S2) >,PQ
implies cell1(S1) = c(< bit1(S1),index(S1) >)) and (queue2(S2) = bit2(S2),BQ
implies cell2(S1) = c(bit2(S1))) .
where S2, PQ and BQ are CafeOBJ variables of Sys2, PQueue and BQueue, respectively, which are declared in SIM. In the module, also declared are the constants pq and bq of PQueue and BQueue denoting arbitrary values of PQueue and BQueue, respectively.
In the module SIM-ISTEP, the following things are declared:
op ABP2SCP-istep1 : Sys1 PQueue BQueue -> Bool
eq ABP2SCP-istep1(S1’,PQ,BQ) = ABP2SCP-sim1(s2,s1,PQ,BQ)
implies ABP2SCP-sim1(s2’,S1’,PQ,BQ) .
s2 and s2’ are constants of Sys2, and S1’ is a CafeOBJ variable of Sys1. The constants and the variable are declared in the module.
The proof passage of the first condition is shown:
open SIM
red ABP2SCP-sim1(init,init,pq,bq) . close
CafeOBJ returns true for the proof passage.
The proof of the second condition is first split into the eight cases that cor- respond to the eight transitions of £ABP (or eight actions of SCP), respectively. We describe the case for rec2 in this paper.
The case for rec2 is split into 11 sub-cases. The 11 sets of equations for the 11 sub-cases are as follows:
queue1(s2) = < b10,n10 >,pq10, (bit2(s2) = b10) = false
queue1(s2) = < b10,n10 >,pq10, bit2(s2) = b10, (bit1(s2) = b10) = false

queue1(s2) = < b10,n10 >,pq10, bit2(s2) = b10, bit1(s2) = b10, (index(s2) = n10) = false
queue1(s2) = < b10,n10 >,pq10, bit2(s2) = b10,
bit1(s2) = b10, index(s2) = n10, (bit2(s1) = b10) = false
queue1(s2) = < b10,n10 >,pq10, bit2(s2) = b10, bit1(s2) = b10, index(s2) = n10, bit2(s1) = b10, (list(s1) = list(s2)) = false
queue1(s2) = < b10,n10 >,pq10, bit2(s2) = b10, bit1(s2) = b10, index(s2) = n10, bit2(s1) = b10, list(s1) = list(s2), (index(s1) = n10) = false
queue1(s2) = < b10,n10 >,pq10, bit2(s2) = b10, bit1(s2) = b10, index(s2) = n10, bit2(s1) = b10,
list(s1) = list(s2), index(s1) = n10, (bit1(s1) = b10) = false
queue1(s2) = < b10,n10 >,pq10, bit2(s2) = b10, bit1(s2) = b10, index(s2) = n10, bit2(s1) = b10, list(s1) = list(s2), index(s1) = n10, bit1(s1) = b10, (cell1(s1) = c(< b10,n10 >)) = false
queue1(s2) = < b10,n10 >,pq10, bit2(s2) = b10, bit1(s2) = b10, index(s2) = n10, bit2(s1) = b10, list(s1) = list(s2), index(s1) = n10, bit1(s1) = b10, cell1(s1) = c(< b10,n10 >), b10 = true
queue1(s2) = < b10,n10 >,pq10, bit2(s2) = b10, bit1(s2) = b10, index(s2) = n10, bit2(s1) = b10, list(s1) = list(s2), index(s1) = n10, bit1(s1) = b10, cell1(s1) = c(< b10,n10 >), b10 = false
c-rec2(s2) = false
where the constants b10, n10 and pq10 denote an arbitrary Boolean value, an arbitrary natural number and an arbitrary queue of pairs of Boolean values and natural numbers, respectively. Note that the equation queue1(s2) = < b10,n10 >,pq10 is equivalent to the equation c-rec2(s1) = true.
The proof passage of the first sub-case is as follows:
open SIM-ISTEP
op b10 : -> Bool . op n10 : -> Nat . op pq10 : -> PQueue . eq queue1(s2) = < b10,n10 >,pq10 .
eq (bit2(s2) = b10) = false .
eq s2’ = rec2(s2) . eq s1’ = send1(s1) . red ABP2SCP-istep1(s1’,pq,bq) .
close

CafeOBJ returns true for the proof passage.
The proof passage of the second sub-case is as follows:
open SIM-ISTEP
op b10 : -> Bool . op n10 : -> Nat . op pq10 : -> PQueue . eq queue1(s2) = < b10,n10 >,pq10 .
eq bit2(s2) = b10 . eq (bit1(s2) = b10) = false . eq s2’ = rec2(s2) . eq s1’ = s1 .
red ABP-inv3(s2) implies ABP2SCP-istep1(s1’,pq,bq) . close
The proof passage uses the invariant property ABP-inv3 wrt £ABP. The in- variant property declared in the module INV is as follows:
eq ABP-inv3(S2)
= (not(queue1(S2) = empty)
and bit2(S2) = fst(top(queue1(S2)))) implies
(bit1(S2) = fst(top(queue1(S2)))
and index(S2) = snd(top(queue1(S2)))) .
CafeOBJ returns true for the proof passage.
The proof passage of the eighth sub-case is as follows:
open SIM-ISTEP
op b10 : -> Bool . op n10 : -> Nat . op pq10 : -> PQueue . eq queue1(s2) = < b10,n10 >,pq10 .
eq bit2(s2) = b10 . eq bit1(s2) = b10 . eq index(s2) = n10 . eq bit2(s1) = b10 . eq list(s1) = list(s2) .
eq index(s1) = n10 . eq bit1(s1) = b10 . eq (cell1(s1) = c(< b10,n10 >)) = false . eq s2’ = rec2(s2) . eq s1’ = s1 .
red ABP2SCP-sim1(s2,s1,pq10,bq) implies ABP2SCP-istep1(s1’,pq,bq) .
close
The proof passage uses another instance ABP2SCP-sim1(s2,s1,pq10,bq) of ABP2SCP-sim1(s2,s1,PQ,BQ). CafeOBJ returns true for the proof passage. The proof passages of the remaining eight sub-cases can be written likewise.
The proof passage of the third sub-case uses the invariant property ABP-inv3
wrt £ABP, while the others use neither lemmas nor invariant properties.
The proof passages of the remaining cases for send1, rec1, send2, drop1, dup1, drop2 and dup2 can be written likewise. The case for send1 uses one invariant property wrt £SCP:

eq ABP-inv2(S2) = (not(queue2(S2) = empty)
and not(bit1(S2) = top(queue2(S2)))) implies (bit2(S2) = top(queue2(S2))) .
The invariant property is declared in the module INV. The other cases use neither lemmas nor invariant properties.

Related Work
Simulations have been intensively used to prove that I/O automata satisfy trace properties [12]. In I/O automata, actions are largely classified into exter- nal and internal ones, which the definitions of simulations from I/O automata to I/O automata take into consideration. Traces are sequences of external actions. That an I/O automaton satisfies a trace property that is a set of traces means that every trace generated by the I/O automaton is a member of the set. On the other hand, there is only one kind of transition in OTSs and every OTS transition corresponds to internal actions in I/O automata.
(Bi)simulations have also been used to prove that a process is equivalent to another in a sense in process algebras such as CCS [13]. In process algebras, actions are also classified into external and internal ones.
Refinement has been explored in some formal specification languages such as Z [3], B [1] and VDM [10]. In this paper, we take a look at refinement in Event-B [2] because discrete models in Event-B are similar to OTSs. When each event (transition) in a concrete model N is supposed to refine a certain event in an abstract model M, there is one constraint (called REF1) to prove:
P (s, c) Λ I(s, c, v) Λ Q(s, t, c, d) Λ J (s, t, c, d, v, w) Λ
H(s, t, c, d, w) Λ S(s, t, c, d, w, w')
⇒ G(s, c, v) Λ ∃v'. (R(s, c, v, v') Λ J (s, t, c, d, v', w'))
where v is a collection of variables in M, s and c are carrier sets and constants in the context C that M sees, P (s, c) is properties that characterize C, I(s, c, v) is invariant properties wrt M, w is a collection of variables in N, t and d are newly added carrier sets and constants in the context D that N sees (namely that s and t are carrier sets in D, and c and d are constants in D), Q(s, t, c, d) is properties that characterize D, J (s, t, c, d, v, w) is the gluing invariant that glues the state of N to that of M, G(s, c, v) and R(s, c, v, v') are the guard and before-after predicate of the event in M, v' is a collection of variables in M after the event, H(s, t, c, d, w) and S(s, t, c, d, w, w') are the guard and before-after predicate of the event in N, and w' is a collection of variables in N after the event.
When new events are introduced in a refinement, there are three con-

straints (called REF2, REF3 and REF4) to prove. REF2 is concerned with invariant properties, while REF3 and REF4 with reachability (or leads-to) properties. Since this paper is only interested in invariant properties, REF2 is only shown:
P (s, c) Λ I(s, c, v) Λ Q(s, t, c, d) Λ J (s, t, c, d, v, w) Λ
H(s, t, c, d, w) Λ S(s, t, c, d, w, w')
⇒ J (s, t, c, d, v, w')
where H(s, t, c, d, w) and S(s, t, c, d, w, w') are the guard and before-after pred- icate of the newly introduced event in N.
REF1 and REF2 correspond to the second condition in Definition 4.1. Since OTSs are made as closed systems and do not have any contexts, the second condition in Definition 4.1 does not have anything that corresponds to P (s, c) and Q(s, t, c, d). J (s, t, c, d, v, w) corresponds to r in Definition 4.1. Although Definition 4.1 does not mention explicitly any invariant properties wrt £ and £A, we can (and need to) use invariant properties wrt £ and/or £A, which can exclude non-reachable states, so as to prove that r is really a simu- lation from £ to £A. I(s, c, v) and part of J (s, t, c, d, v, w) correspond to such invariant properties. One concrete event corresponds to one or zero abstract event in a refinement of Event-B, while one concrete transition corresponds to zero or more abstract transitions (or a sequence of abstract transitions) in a simulation from OTSs to OTSs. Moreover, one concrete transition may corre- spond to multiple sequences of abstract transitions in a simulation from OTSs to OTSs. In Subsection 5.2, we have described the case for rec2 in the proof of the second condition, which is split into eight sub-cases. We have shown the proof passages of the three sub-cases out of eight. The first proof passage says that the concrete transition (action) rec2 corresponds to the abstract transition (action) send, while the second and third proof passages say that rec2 corresponds to the empty sequence.
We make a comparison of the OTS/CafeOBJ method with I/O automata, Z, B, VDM and Event-B on one more point: whether do events (or transitions or actions) have guards (outside which events cannot occur), preconditions (outside which events can occur but their outcomes are not defined) or both. Actions have guards in I/O automata and events have preconditions in Z, B and VDM, while Event-B has both gourds and preconditions. Effective conditions that transitions have in the OTS/CafeOBJ method are more similar to guards than preconditions, but are not exactly the same as guards. In the OTS/CafeOBJ method, transitions can be applied in any state even if their effective conditions do not hold in the state. If transitions are applies in a state where their effective conditions do not hold, however, nothing changes.

Conclusion
We have proposed a way to verify that an OTS £ satisfies invariant properties based on a simulation from £ to another OTS, which is more abstract than
£, in the OTS/CafeOBJ method. Two case studies have been described, in which we prove that SCP is simulated by SCP, and ABP is simulated by SCP and BCP.
One inevitable question is as follows: which of the simulation-based ver- ification method or the induction-based verification method should be used to verify that an OTS satisfies an invariant property? This must depend on the OTS and the invariant property. When the cost of the tasks (i), (ii), (iii) and (iv) in the simulation-based invariant verification method is smaller than the cost of the proof of 6υ : YS . p(υ) by induction on υ, the former can be rewarded. In the case studies described in the paper, however, we did not find any clear evidence showing that one method is superior to the other. The reason is as follows. The first case study needs three invariant properties wrt
£SCP and three lemmas on Boolean values. When we prove 6υ : YSSPC . rc1(υ) by induction on υ, we need exactly the same invariant properties wrt £SCP and lemmas on Boolean values. The second case study needs two invariant properties wrt £ABP. When we prove 6υ : YSABC . rc2(υ) by induction on υ, we need exactly the same invariant properties wrt £ABP.
One piece of our future work is to apply the proposed simulation-based verification method to the Mondex electronic purse system and compare it with the case study described in [11] where the induction-based verification method is used.

References
Abrial, J.-R., “The B Book – Assigning Programs to Meanings,” Cambridge University Press, 1996.
Abrial, J.-R., Reﬁnement, decomposition and instantiation of discrete models, in: 12th International Workshop on Abstract State Machines (12th ASM), 2005, pp. 17–40.
Davies, J. and J. Woodcock, “Using Z: Specification, Refinement, and Proof,” Prentice Hall, 1996.
Diaconescu, R. and K. Futatsugi, “CafeOBJ report: The Language, Proof Techniques, and Methodologies for Object-Oriented Algebraic Specification,” AMAST Series in Computing 6, World Scientific, 1998.
Diaconescu, R. and K. Futatsugi, Behavioural coherence in object-oriented algebraic speciﬁcation, Journal of Universal Computer Science 6 (2000), pp. 74–96.
Diaconescu, R., K. Futatsugi and K. Ogata, CafeOBJ: Logical foundations and methodologies, Computing and Informatics 22 (2003), pp. 257–283.
Futatsugi, K., Verifying speciﬁcations with proof scores in CafeOBJ, in: 21st International Conference on Automated Software Engineering (ASE 2006) (2006), pp. 3–10.

Goguen, J. and G. Malcolm, A hidden agenda, Theoretical Computer Science 245 (2000),
pp. 55–101.
Hsiang, J. and N. Dershowitz, Rewrite methods for clausal and nonclausal theorem proving, in: 10th EATCS International Colloquium on Automata, Languages, and Programming (10th ICALP), LNCS 154 (1983), pp. 331–346.
Jones, C. B., “Systematic Software Development Using VDM,” Prentice Hall, 1990.
Kong, W., K. Ogata and K. Futatsugi, Algebraic approaches to formal analysis of the Mondex electronic purse system, in: 6th International Conference on Integrated Formal Methods (6th IFM), LNCS 4591 (2007), pp. 393–412.
Lynch, N. A., “Distributed Algorithms,” Morgan-Kaufmann, 1996.
Milner, R., “Communication and Concurrency,” Prentice Hall, 1989.
Ogata, K. and K. Futatsugi, Formal analysis of the iKP electronic payment protocols, in: 1st International Symposium on Software Security (1st ISSS), LNCS 2609 (2003), pp. 441–460.
Ogata, K. and K. Futatsugi, Proof scores in the OTS/CafeOBJ method, in: 6th IFIP WG6.1 International Conference on Formal Methods for Open Object-Based Distributed Systems (6th FMOODS), LNCS 2884 (2003), pp. 170–184.
Ogata, K. and K. Futatsugi, Equational approach to formal analysis of TLS, in: 25th International Conference on Distributed Computing Systems (25th ICDCS) (2005), pp. 795– 804.
Ogata, K. and K. Futatsugi, Some tips on writing proof scores in the OTS/CafeOBJ method, in: Algebra, Meaning, and Computation: A Festschrift Symposium in Honor of Joseph Goguen, LNCS 4060 (2006), pp. 596–615.
