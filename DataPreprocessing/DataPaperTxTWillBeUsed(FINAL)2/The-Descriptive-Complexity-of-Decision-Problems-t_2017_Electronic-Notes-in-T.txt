Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 332 (2017) 113–130
www.elsevier.com/locate/entcs

The Descriptive Complexity of Decision Problems through Logics with Relational Fixed-Point and Capturing Results 1
Marcia Farias2, Ana Teresa Martins3
Department of Computation Federal University of Cear´a
P.O. Box 12166, Fortaleza, CE, Brazil
Francicleber Ferreira4
Federal University of Cear´a, Campus de Quixad´a 63902-580, Quixad´a, CE, Brazil

Abstract
In this work, we generalize the classical fixed-point logics using relations instead of operators in order to capture the notion of nondeterminism. The basic idea is that we use loops in a relation instead of fixed- points of a function, that is, X is a fixed-point of the relation R in case the pair (X, X) belongs to R. We introduce the notion of initial fixed-point of an inflationary relation R and the associated operator rifp. We denote by RIFP the first-order logic with the inflationary relational fixed-point operator rifp and show that it captures the polynomial hierarchy using a translation to second-order logic. We also consider the fragment RIFP1 with the restriction that the rifp operator can be applied at most once. We show that RIFP1 captures the class NP and compare our logic with the nondeterministic fixed-point logic proposed by Abiteboul, Vianu and Vardi in [4].
Keywords: descriptive complexity, fixed-point logic, relational fixed-point logic, expressiveness.


Introduction
The characterization of the complexity classes through logics is the central theme of Descriptive Complexity [17]. Such characterizations establish that sentences in some logic define decision problems on finite structures that belong to a specific

1 This work was partially supported by CAPES(DS), CNPq (305980/2013-0, 474821/2012-9), CAPES/CNPq (552578/2011-8), CAPES(PROCAD/NF 789/2010) and FUNCAP.
2 Email: roberta@lia.ufc.br
3 Email: ana@lia.ufc.br
4 Email: fran@lia.ufc.br

http://dx.doi.org/10.1016/j.entcs.2017.04.008
1571-0661/© 2017 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

complexity class and vice versa, that is, problems in this complexity class can be defined by sentences of the language. This kind of result builds bridges between Finite Model Theory [9] and Complexity Theory [20] and opens up the possibility to use methods and results from one area to solve problems of the other. It also enables relationships between logical resources (e.g., quantification, number of vari- ables, higher-order quantification, fixed-point operators, etc.) and computational resources (e.g., number of processors, nondeterminism, alternation, time, space, etc.).
The relational model of databases introduced by Codd [8] made explicit the close relation between database theory and finite model theory. Databases can be seen as finite structures and query languages as logical languages [1]. Interest in logical languages has grown rapidly, since such languages, with the associated semantics, provides a strong theoretical background for database theory, especially on query processing, and a large amount of techniques from model theory can be applied. On its turn, this interest on the logical approach to databases promoted an intensive development of Finite Model Theory.
An obvious candidate for a query language is the first-order logic (FO). First- order logic was developed in the last century as a result of the efforts to provide a logical foundation to Mathematics. In this setting, infinite structures play an important role and, indeed, the methods of the model theory of first-order logic rely on the fact that structures can be infinite [7,15]. Although FO is very well suited for mathematical reasoning, its expressive power with respect to finite models is rather limited. Many problems, such as deciding whether a graph is connected or not, cannot be expressed in FO, even when restricted to finite structures. Such limitations derive from the fact that FO is not able to express inductive definitions. This lack of expressiveness was fulfilled with the introduction of fixed-point operators to improve the expressive power of FO. Aho and Ullman [2] introduced the idea of extending the relational algebra, which is basically first-order logic in algebraic fashion, with fixed-point operators. The idea was followed by Chandra and Harel [6], giving rise to an extension of first-order logic with the least fixed-point
operator, known as the least fixed-point logic LFP.
An operator is a function F : P(A) → P(A). When F is a monotone operator (that is, X ⊆ Y ⇒ F (X) ⊆ F (Y )), it has a least fixed-point lfp(F ). The least fixed- point logic extends the language of first-order logic with expressions that define the least fixed-point of suitably chosen monotone operators (see the precise definition in Section 2). The least fixed-point logic is strictly more expressive than FO. For instance, graph properties like connectivity and reachability can be expressed by LFP sentences. Other fixed-point logics can be defined by changing the type of operators considered and the type of fixed-point chosen.
Given a sentence of some logic, the set of its finite models defines a decision problem. Once we use sentences in some language to express decision problems, the immediate question is: What is the complexity of such problems? This question has been answered for several logics, see [17]. First-order logic, for example, corresponds to the logarithmic-time hierarchy. One of the first results relating logical expressive

power and computational complexity is the celebrated Fagin’s Theorem [11]. Ac- cording to Fagin’s Theorem, the existential fragment of second-order logic defines exactly the problems in NP (nondeterministic polynomial time, see [20]), and it was used by Stockmeyer [21] to show that second-order logic corresponds to the polynomial hierarchy. An earlier result, due to Bu¨chi [5], shows that the monadic second-order logic on strings defines exactly the class of regular languages. LFP has an intermediate expressive power between first-order and existential second-order logic. On the class of ordered structures, LFP corresponds to the decision problems in the class P of problems that can be solved in polynomial time [17].
Most fixed-point logics are defined in the way sketched above for the case of LFP. In particular, they use operators (functions) and their fixed-points to define inductive sets. We are interested in extending this notion considering not only oper- ators but relations. Instead of a function F : P(A) → P(A) and its fixed-points, we consider a relation R⊆ P(A)×P(A) and its loops, that is, X such that (X, X) ∈ R. Our motivation is to try to cope with nondeterminism using relations, inspired by the use of functions in fixed-point logics to formalize determinism. This generaliza- tion opens up new possibilities for the definition of fixed-point of relations and the corresponding logics. As in the case of operators used in the traditional fixed-point logics, suitable conditions on the kind of relations and fixed-points considered can be used to define several logics in different ways.
We will focus on a specific type of relation which we call inflationary (see Section 3) and can be seen as the relational counterpart of inflationary fixed-point logic [9,13]. In Section 2, we recall the fundamentals of fixed-point theory and logics. In Section 3, we define some important concepts about relational fixed-point theory. In Section 4, we present the relational inflationary fixed-point logic RIFP with its syntax and semantics, and we also show examples of how to express problems in this logic. In Section 5, we demonstrate that the RIFP logic captures the polynomial hierarchy complexity class through a translation of RIFP to second-order logic, and vice versa. In Section 6, we define a fragment of RIFP logic called RIFP1 which contains only one application of rifp operator, and we show that this logic captures NP. In Section 7, we compare RIFP with NIFP, a logic defined by Abiteboul, Vianu and Vardi [4]. Finally, we conclude this work and we show future topics of research in Section 8.

Fixed-Point Logics and Descriptive Complexity
In this section, we review the basics concepts of first-order logic and descriptive complexity that we will use in this paper.
We follow the notation from [10,9].   A symbol-set is a set S  =
{R1,..., Rl, f1,..., fk, c1,..., cm} of relation, function and constant symbols. Each Ri is a relation symbol of arity ai and fj is a function symbol of arity rj. An S-structure is a pair A = (A, σ) where A is a set and σ is a map that associates each relation symbol R ∈ S of arity k toa relation σ(R)= RA ⊆ Ak, each function symbol f to a function σ(f )= f A, and each constant c ∈ S to an element σ(c)= cA.

We define STRUCT[S] to be the set of finite S-structures. An ordered structure is a structure in a symbol set S containing a relation symbol < which is interpreted as a linear order.
An S-interpretation I is a pair (A, β) consisting of an S-structure and an assign- ment β which associates to each first-order variable x an element β(x) ∈ A, and to each relation variable X of arity k a relation β(X) ⊆ Ak.
The languages and semantics of first-order and second-order logics are defined as usual. A formula whose symbols belong to some symbol-set S is called an S- formula. We call formulas with free relation variables, but without second-order quantification as first-order formulas, since they are first-order in essence. If x is a
first-order variable and a ∈ A, then β a is the assignment defined as β a (y) = a if
y = x and β a (y)= β(y) otherwise. Analogously, if X is a second-order variable of
arity k and X ⊆ Ak, then β X (Y )= X if Y = X and β X (Y )= β(Y ) otherwise.
X	X
Inductive sets can be defined as fixed-points of certain operators. Let A be a
set and F : P(A) → P(A) and operator on A. The sequence of stages of F is the sequence
F0(= ∅), F1,... 
where Fi+1 = F (Fi) and Fi is called the i-th stage of F . An operator F is called inductive if its stages form an increasing chain (Fi ⊆ Fi+1). F is said inflationary if X ⊆ F (X), for all X ∈ P(A), and it is monotone if X ⊆ Y implies F (X) ⊆ F (Y ), for all X, Y ∈ P(A). We denote by F∞ the stage Fi which is a fixed-point of F , if it exists, and ∅ otherwise. The sequence of stages of inductive (and of inflationary and monotone, since they are inductive) operators reaches a fixed-point at some stage of the sequence. If F is inductive, the inductive ﬁxed-point of F is defined as ind(F ) = F∞. If F is inflationary, the inflationary ﬁxed-point of F is defined as ifp(F )= F∞. A monotone operator always has a least ﬁxed-point (w.r.t. inclusion
⊆) defined as lfp(F ) = F∞. For F an arbitrary operator, we call F∞ the partial ﬁxed-point of F and denote it by pfp(F )= F∞.
Fixed-point logics are created extending the FO language with syntactical con- structs that denote fixed-points of operators defined in the language. Let φ(X, x) be a formula of some language where X is a relational symbol of arity k and x = x1,..., xk. The formula φ defines an operator on the domain of an inter- pretation I as
φI(X)= {a ∈ Ak | I X, a |= φ(X, x)}.
X, x
A formula is positive on a relational variable iff this variable does not occur inside the scope of an odd number of negations (when we consider only the connectives
∧ and ∨). If φ is positive on X, then φI is monotone. If φ is of the form φ =
Xx ∨ φj(X, x), then φI is inflationary.
The least fixed-point logic is obtained extending the FO language with the fol- lowing rule:
if X is a k-ary relational variable, x = x1,..., xk and φ(X, x) is an LFP-formula positive on X, then [lfpX,x φ(X, x)](t) is an LFP-formula, where t = t1,..., tk is a tuple of terms of length k.

Given an interpretation I, the satisfaction relation for the new formulas is defined
as
I |= [lfpX,x φ(X, x)](t) iff (tI,..., tI) ∈ lfp(φI).
1	k
The inflationary fixed-point logic is defined similarly:
if X is a k-ary relational variable, x = x1,..., xk and φ(X, x) is an IFP-formula, then [ifpX,x φ(X, x) ∨ Xx](t) is an IFP-formula, where t = t1,..., tk is a tuple of terms of length k.
The satisfaction relation is defined as:
I |= [ifpX,x φ(X, x)](t) iff (tI,..., tI) ∈ ifp(φI).
1	k
Another important fixed-point logic is the partial fixed-point logic:
if X is a k-ary relational variable, x = x1,..., xk and φ(X, x) is a PFP-formula, then [pfpX,x φ(X, x)](t) is a PFP-formula, where t = t1,..., tk is a tuple of terms of length k.
And the corresponding satisfaction relation:
I |= [pfpX,x φ(X, x)](t) iff (tI,..., tI) ∈ pfp(φI).
1	k
LFP and IFP have the same expressive power. This result was proved for finite structures by Gurevich and Shelah [14]. Later, the restriction on the cardinality of the structures was dropped by Kreutzer [18].
We are interested in the characterization of complexity classes using logics. We can define a logic as a pair L = (L, |=), where L is a language and |= is its satisfi- ability relation. An S-sentence from L defines a decision problem on S-structures. Let φ be an S-sentence. We define the class of finite models of φ as the class of S-structures that satisfies φ:
Mod(φ)= {A ∈ STRUCT[S] | A |= φ}.
The decision problem defined by a class of structures is called a query, following the database jargon.
Finite structures can be coded as inputs for a computation model (see [17] for details). Hence, we may ask whether a class of structures is computable or not, and what is the complexity of solving it. Thus, we may consider to which complexity class, if any, the queries defined by some logic belong.
Definition 2.1 (L captures C) Let L be a logic and C a complexity class. We say that L captures C (L = C) iff
for each sentence φ ∈ L, the class of structures Mod(φ) is in C (L⊆ C), and,
for each class of structures Q in C there is a sentence φ ∈L such that Q = Mod(φ) (C ⊆ L).
Fagin showed that the existential fragment of second-order logic (∃SO) captures the class of queries that can be solved in nondeterministic polynomial time (NP)

[11].
Theorem 2.2 (∃SO = NP) ∃SO captures NP.
Restricted to ordered structures, LFP, and equivalently IFP, defines exactly the queries in PTIME ([16,22]).
Theorem 2.3 (LFP = PTIME, on ordered structures) A class of ordered structures can be deﬁned in LFP iff that class is in PTIME.
The role of order is important here since LFP cannot define all queries in PTIME on unordered structures. Actually, even simple polynomial problems, as deciding whether a structure has a domain of even cardinality, cannot be defined in LFP [19]. On unordered structures, we only have the containment LFP ⊆ PTIME, but not the converse.
With respect to PFP, we have that PFP captures PSPACE, the class of decision problems that can be solved using polynomial space, on ordered structures:
Theorem 2.4 (PFP = PSPACE, on ordered structures) A class of ordered structures can be deﬁned in PFP iff that class is in PSPACE [3,22].
Many other capturing results have been proved for several logics and complexity classes. See [17] for details. We have the following relations among the logics mentioned above:
LFP = IFP ⊆ ∃SO ⊆ PFP,
where the last inclusion only holds for ordered structures. We want to generalize the fixed-point operators considered in the traditional fixed-point theory in order to explore new ways to define logics aiming at the characterization of complexity classes through logics in the spirit of descriptive complexity. We will introduce the relational approach in the next section.
Relational Fixed-Point Theory
As we have seen, the traditional fixed-point theory is based on the concept of the operator, which is essentially a function. Our proposal is to consider relations instead of functions in order to capture nondeterminism.
Given a finite domain A, let R ⊆ P(Ak) × P(Ak) be a (second-order) relation. We say that a binary relation R is total if for all X ∈ P(Ak) there is a Y ∈ P(Ak) such that (X, Y ) ∈ R. A chain in R is a sequence X0, X1,..., Xm such that X0 = ∅, Xi ⊆ Xi+1 and (Xi, Xi+1) ∈ R.
We can define conditions on relations that resemble those used to define the types of fixed-point operators that we have seen before. We say that a relation R
⊆ P(Ak) × P(Ak) is an inflationary relation if, for all (X, Y ) ∈ R, we have X
⊆ Y . Given an arbitrary relation R ⊆ P(Ak) × P(Ak), we define an inflationary, total relation RInf from R as follows:
RInf = {(X, X ∪ Y ) ∈ P(Ak)2 | (X, Y ) ∈ R} ∪
(1)
{(X, X) ∈ P(Ak)2 | ∄Y : (X, Y ) ∈ R}.

We say that a relation R ⊆ P(Ak) × P(Ak) is inductive if any sequence X0, X1, ..., Xm, such that X0 = ∅ and (Xi, Xi+1) ∈ R, 0 ≤ i ≤ m − 1, is a chain in R.
Lemma 3.1 If R is inflationary then it is inductive.
A set X ∈ P(Ak) is a fixed-point of the relation R if R(X, X). A fixed-point X of R is called inductive if there is a chain X0, X1,..., Xm such that Xm = X. We denote by IndFP(R) the set of inductive fixed-points of R. We say that a fixed-point X is an initial fixed-point of R if there is a chain X0, X1,..., Xm such that Xm = X and no Xj, j < m, is a fixed-point of R. Denote by IniFP(R) the set of all initial fixed-points of R.
A set X is an inflationary fixed-point of R if X is an inductive fixed-point of RInf. We say that X is an initial inflationary fixed-point of R if X is an initial fixed-point of RInf. We denote by rifp(R) the set of all initial inflationary
fixed-points of R, that is, rifp(R)= IniFP(RInf).
Lemma 3.2 Let A be a ﬁnite set. If a relation R ∈ P(Ak) × P(Ak) is total and inductive, then any chain X0 = ∅, X1,..., Xm with sufficiently large m contains a ﬁxed-point, where m ≤ |A|k.
It is easy to see that operators are particular cases of relations. Indeed, given an operator F : P(Ak) → P(Ak), its graph is the relation
RF = {(X, Y ) ∈ P(Ak) × P(Ak) | Y = F (X)}.
Hence, the relational approach can be used to represent the functional one.
We will develop a logic which is able to talk about the initial inflationary fixed- points of a relation and we will see that this logic will capture some nondeterministic complexity classes.
The Relational Fixed-Point Logic - RIFP
In this section, we will add to first-order logic the ability to define relations that correspond to the union of initial inflationary fixed-points of defined relations. This extension will be called Relational Inflationary Fixed-Point Logic (RIFP). It will increase the expressive power beyond that of inflationary fixed-point logic.
Let φ(X, Y ) be an S-formula with free relation variables X and Y of arity k, and I an S-interpretation. The formula φ(X, Y ) defines the relation
Rφ,I = {(V ,V ) ∈ P(Ak) × P(Ak) | I V1, V2 |= φ(X, Y )}.
1	2	X, Y
If φ(X, Y ) has no free variables other than X and Y then, given a structure A, the relation Rφ,I is the same for all interpretations I on A. Thus, we write Rφ,A instead.
The language of RIFP extends the language of first-order logic with the following rule:



if X and Y are relation variables of arity k, t = t1,..., tk are terms and φ(X, Y ) is an S-formula, then


is an S-formula of RIFP.
[rifpX,Y φ(X, Y )](t)

The satisfaction relation is defined using the inflationary relation Rφ,I
gener-

ated by Rφ,I. Given an interpretation I we define
I |= [rifpX,Y φ(X, Y )](t) iff (tI,..., tI) ∈ [ rifp(Rφ,I)= [ IniFP(Rφ,I ).
1	k	Inf
4.1	Examples
In the following, we will show how to use RIFP to express some queries.
Example 4.1 (Even Cardinality) The Even query corresponds to the class of
structures whose domains have even cardinality. Note that a set A has even cardi- nality if there is a partition {Aj, Ajj} of A and a bijection f : Aj → Ajj. We will use the rifp operator to construct such a bijection (actually, a binary relation which is the graph of the bijection). Let Y and X be binary relation variables and consider the following formulas:

FUNC(Y ) = ∀x∀y∀z[Y xy ∧ Y xz → y = z], INJ(Y )  = ∀x∀y∀z[Y xy ∧ Y zy → x = z], TOT(Y ) = ∀x∃y[Y xy ∨ Y yx],
DIS(Y )  = ∀x¬[∃yY xy ∧ ∃zY zx],

where TOT(Y ) says that each element occurs in some pair in Y .
Let φ(X, Y ) be the formula
φ(X, Y )= (X = ∅) ∧ FUNC(Y ) ∧ INJ (Y ) ∧ TOT (Y ) ∧ DIS(Y ).

Let A be an structure and Rφ,A be the relation deﬁned by φ(X, Y ) on A. A pair (B, Bj) belongs to Rφ,A iff B = ∅ and Bj is the graph of a bijection on a partition of the domain A of A. Such bijection exists if and only if A has even cardinality. The

relation Rφ,A
contains Rφ,A and the pairs (B, B) for all B ⊆ A2 such that B /= ∅.

If A has odd cardinality, then any chain on Rφ,A
has length 1 and the only initial

inflationary ﬁxed-point is ∅. If A has even cardinality, then any chain of length 2
reaches an initial inflationary ﬁxed-point which is the graph of a bijective function, as described above. It follows that S rifp(Rφ,A) is empty iff A has odd cardinality.
The sentence
ψEven = ∃u∃v[rifpX,Y φ(X, Y )](u, v)
is satisﬁed by A iff S rifp(Rφ,A) is nonempty. It only occurs if A has even cardi-
nality. Hence, ψEven deﬁnes the Even query.	2

Example 4.2 (Satisfiability) The SAT problem consists of the set of formulas of propositional logic in conjunctive normal form (CNF) that are satisﬁable. A formula α in CNF has the form
α = C1 ∧ ... ∧ Cm,
where each Ci is a clause, that is, a disjunction like
Ci = l1 ∨ ... ∨ ls

and each lj is a literal, that is, it is either a propositional symbol pk, and we say that pk occurs positive in Ci, or a negated propositional symbol ¬pk, and we say that pk occurs negative in Ci.
As we want to use formulas to express decision problems, we often have to rep- resent problem inputs as ﬁnite structures. Let Aα be a structure on the symbol-set S = {P, N} where P and N are binary relations. Let r be the number of propo- sitional symbols that occur in α and A = {1,..., max{m, r}}. Let P A = {(i, j) | pj occurs positive in Ci} and N A = {(i, j) | pj occurs negative in Ci}. The ﬁrst position of P and N represents a clause and the second one a propositional sym- bol. Without loss of generality, we consider that any formula has at least as many clauses as propositional symbols, which can be achieved by adding dummy clauses (p0 ∨ ¬p0) to a formula without changing its satisﬁability.
We will write an RIFP-formula that is satisﬁed by those structures Aα such that α is satisﬁable. We use the rifp operator to construct ternary relations whose tuples represent the truth value of propositional symbols, clauses and the formula according to some valuation of propositional symbols. We use triples (a, b, c) such that a can assume the values 0, 1 or 2, according to whether it refers to a propositional symbol, a clause or a formula, respectively, b represents the index of a clause or propositional symbol, and c can be 0 or 1, for true or false, respectively. This relation will be constructed in three stages. First, we put the triples that represent a valuation. Let PVAL(Y ) be the formula
PVAL(Y )= ∀x∀y∀z(Y xyz → x = 0) ∧ ∀y((Y 0y0 ∨ Y 0y1) ∧ ¬(Y 0y0 ∧ Y 0y1)),
and φ0(X, Y ) be the formula
φ0(X, Y )= (X = ∅) ∧ PVAL(Y ).

Two relations X, Y satisfy φ0(X, Y ) iff X = ∅ and Y represents a valuation, where (0, i, 1) means that proposition symbol i has value true, similarly for (0, i, 0). In the second step, we include those triples corresponding to the truth values of clauses. We may consider that X contains those triples that represent a valuation and were included in the ﬁrst step. Consider the formula CVAL(Y )
CVAL(Y )= ∀x∀y∀z(Y xyz → x = 1) ∧ ∀y((Y 1y0 ∨ Y 1y1) ∧ ¬(Y 1y0 ∧ Y 1y1)),
and the formula CL(X, Y )

CL(X, Y )= CVAL(Y ) ∧ ∀y(Y 1y1 ↔ ∃p((P yp ∧ X0p1) ∨ (Nyp ∧ X0p0))).
Let φ1(X, Y ) be the formula
φ1(X, Y )= PVAL(X) ∧ CL(X, Y ).

If X and Y satisfy φ1(X, Y ) then X corresponds to a valuation and Y represents the truth values of clauses according to the valuation X. The last step calculates the truth value of the formula based on the truth values of its clauses. Let FVAL(Y ) be the formula
FVAL(Y )= ((Y 200 ∨ Y 201) ∧ ¬(Y 200 ∧ Y 201)).
The formula FVAL(Y ) means that Y either have the tuple (2, 0, 0), indicating that the input of SAT is not satisﬁable, or the tuple (2, 0, 1), otherwise. Let FOR(X, Y ) be the formula


and
FOR(X, Y )= Y 201 ↔ (∀yX1y1)

φ2(X, Y )= FVAL(Y ) ∧ FOR(X, Y ).

Finally, let φ(X, Y ) = φ0(X, Y ) ∨ φ1(X, Y ) ∨ φ2(X, Y ). A pair (X, Y) satisﬁes
φ(X, Y ) iff it satisﬁes some φ (X, Y ), 0 ≤ i ≤ 2. In particular, (2, 0, 1) ∈ Y iff the formula α is satisﬁable. It follows that (2, 0, 1) ∈ S rifp(Rφ,Aα ) iff α is satisﬁable.
Let
ψSat = [rifpX,Y φ(X, Y )](201).
Then Aα |= ψSat iff α is satisﬁable.	2
We end this section with the following Theorem that relates the expressive power of RIFP and IFP.
Theorem 4.3 (IFP ⊆ RIFP) An IFP-formula has an equivalent one in RIFP.
Proof. Let ψ be the following IFP-formula:
ψ := [ifpX,xφ(X, x)](t).
Let I be an interpretation and φI be the operator defined by φ on I. Let
φI(= ∅), φI, φI,... 
0	1	2
be the sequence of stages of φI. We will define a formula θ(X, Y ) such that the only chain in Rθ,I leading to an initial fixed-point coincides with the stages sequence of φI. Let θ(X, Y ) be the formula

θ(X, Y ) = ∀x(Y x ↔ φ(X, x)).

The relation Rθ,I is exactly the graph of the operator φI. Hence, any finite initial segment of the sequence of stages of φI is a chain of Rθ,I and vice versa. Moreover,

since φI is inflationary, then Rθ,I = Rθ,I
. It follows that Rθ,I
has only one initial

fixed-point and it is equal to the inflationary fixed-point of φI. Thus, the formula
ψj = [rifpX,Y θ(X, Y )](t)
is equivalent to ψ.
2
RIFP Captures PH
In this section, we will show that the expressive power of RIFP is equivalent to that of SO. Since SO captures the polynomial hierarchy (PH) [21], we have that RIFP also captures PH. To show that the expressive power of RIFP is the same as that of SO, we will give translations between the two languages. Consider the following translation from SO to RIFP:
Tr(t0 ≡ t1)	:= t0 ≡ t1
Tr(Rt1 ... tk) := Rt1 ... tk
Tr(Xt1 ... tk) := Xt1 ... tk Tr(¬φ)	:= ¬Tr(φ)
Tr(φ1 ∧ φ2)	:= Tr(φ1) ∧ Tr(φ2) Tr(∃xφ)	:= ∃xTr(φ)
Tr(∃Y φ(Y )) := ∃x[rifpX,Y ψ(X, Y )] (x) ∨ Tr(φ(∅)) where ψ is the formula
ψ(X, Y )= (X = ∅∧ Tr(φ(Y ))).
Lemma 5.1 Let φ ∈ SO. Then φ ≡ Tr(φ) [12].
The proof is by induction. The interesting case is the case of the second-order
existential quantifier. Note that a pair (V1, V2) is in Rφ,I  iff V1 = ∅ and I V2 |=

φ(Y ). We have two cases: i) I  $
|= φ(Y ) and in this case, I V2
|= Tr(φ(∅)), or ii)

V2 /|= φ(Y ). In this case, we have that any chain in Rφ,I
, if there is some, has

size two, and any initial fixed-point is a non-empty relation V2 that satisfies φ(Y ). Conversely, any such relation V2 is in some chain and it is an initial fixed-point.
It follows that I V2 |= ∃x[rifpX,Y ψ(X, Y )] (x) since, by the inductive hypothesis,
Tr(φ(Y )) is equivalent to φ(Y ). Hence the equivalence follows.
For the converse, that is, the definition of the translation from RIFP to SO, we have to be able to reconstruct the chains that give rise to the initial inflationary fixed-points using second-order logic. The key fact is the inflationary property of the

relation Rφ,I
that guarantees that any initial fixed-point can be reached through

a chain of sufficiently short length.

Let φ(X, Y ) be a formula with X and Y k-ary relation variables, and I an interpretation whose domain has cardinality n. Let X0, X1,..., Xm be a chain in

φ,I
Inf
and Xm an initial fixed-point. As Rφ,I
is inflationary, m is at most nk

(Lemma 3.2). Suppose < is a 2k-ary relation on I which is an ordering on k-tuples
of elements in I and, for 1 ≤ i ≤ nk, let ti the i-th k-tuple with respect to <. Let
Xj be a 2k-ary relation defined as:

Xj = {(ti, a) ∈ A2k | a ∈ Xi}.


We use the first k positions ofa tuple in Xj to indicate the index i of a relation Xi in the chain, and the other k positions to represent a k-tuple in Xi. We can use existential quantification to check the existence of a relation like Xj that witnesses the existence of a chain that reaches an initial fixed-point. We have to guarantee

that successive relations in the chain are pairs in Rφ,I
. Consider the following

formula:
COMPUTE(φ, Xj, t) := ∃tj∃X ∃Y (tj = t +1 ∧
φ(X, Y ) ∧ ¬φ(X, X)∧
∀a(Xjt, a ↔ Xa) ∧

∀b(Xjtj, b ↔ Y b ∨ Xb)).

The formula COMPUTE(φ, Xj, t) means that t and tj are consecutive with respect
to <, the projections of Xj at t and tj form a pair in Rφ,I , and the projection at t
is not a fixed-point.
The formula START(Xj) means that the relation X1 of the chain is the projec- tion of Xj at t1 (recall that X0 = ∅ in a chain):

START(Xj) := ∃Y (φ(∅,Y ) ∧ ∀a(Xjt1a ↔ Y a)).


Finally, the formula

END(Xj, tpf, z) := ∃X(∀a(Xjtfpa ↔ Xa) ∧ φ(X, X)) ∧ Xtfpz


means that the projection of Xj on tfp is a fixed-point and that z belongs to this projection.
Let Ord(<) be a first-order formula stating that < is a linear order on k-tuples.

Consider the following translation from RIFP to SO:
Trj(t0 ≡ t1)	:= t0 ≡ t1
Trj(Rt1 ... tk)	:= Rt1 ... tk
Trj(Xt1 ... tk)	:= Xt1 ... tk
Trj(¬φ)	:= ¬Trj(φ)
Trj(φ1 ∧ φ2)	:= Trj(φ1) ∧ Trj(φ2)
Trj(∃xφ)	:= ∃xTrj(φ)
Trj([rifpX,Y φ(X, Y )](u)) := ∃ < ∃Xj ∃tfp(Ord(<) ∧ START(X) ∧
∀t(t < tpf → COMPUTEj(X, t)) ∧
END(X, tpf, u)).
where COMPUTEj(X, t) is obtained from COMPUTE(X, t) replacing φ with
Trj(φ).
Lemma 5.2 Let φ ∈ RIFP. Then φ ≡ Trj(φ) [12].
The proof is by induction and the interesting case, that of the fixed-point oper- ator, is exactly the explanation given above.
Theorem 5.3 (RIFP = SO) RIFP and SO have the same expressive power.
It follows immediately from Theorem 5.3 and the fact that SO captures the polynomial hierarchy [21] that:
Corollary 5.4 (RIFP = PH) RIFP captures the polynomial hierarchy PH.
RIFP1 captures NP
From Theorem 5.3, we have that RIFP is equivalent to SO. Fagin’s theorem shows that the existential fragment of SO captures NP. The existential fragment of SO has formulas of the form
∃X1 ... ∃Xqφ
where φ is a first-order formula. There is a syntactically defined fragment of RIFP that corresponds to the existential fragment of SO. We call RIFP1 the fragment of RIFP consisting of the formulas of the form
∃x1 ... ∃xk[rifpX,Y φ(X, Y )](u) where φ(X, Y ) is first-order.
The translations between RIFP and SO presented above do not directly give us the result we want, because they do not map the existential fragment of SO into RIFP, and vice versa. Let us consider the translation Tr from SO to RIFP. According to the translation, each existential quantifier will be replaced by an rifp

construct. Hence, an existential formula may be mapped into an RIFP-formula with several nested rifp operators. To overcome this difficulty, given an existential formula with a block of existential quantifiers, we can transform it in an equiva- lent formula with only one existential quantifier. Then, each existential formula is equivalent to an RIFP-formula with only one rifp operator. However, by definition, we have:
Tr(∃Y φ(Y )) = ∃x[rifpX,Y ψ(X, Y )] (x) ∨ Tr(φ(∅)),
which is not in the exact shape of an RIFP1-formula.	But we can see that
Tr(∃Y φ(Y )) is equivalent to

∃x[rifpX,Y ψj(X, Y )] (x),


where

ψj(X, Y )= (X = ∅∧ Y /= ∅∧ Tr(φ(Y ))) ∨ (φ(∅) ∧ Y x).

We conclude:
Lemma 6.1 (∃SO ⊆ RIFP1) The existential second-order logic is contained in RIFP1.
On the other hand, the translation Trj from RIFP to SO when applied to formulas in RIFP1, also does not give us an existential formula. Obviously, it can be put in the prenex form but, if we consider the last clause of the definition of Trj

Trj([rifpX,Y φ(X, Y )](u)) := ∃ < ∃Xj ∃tfp(Ord(<) ∧ START(X) ∧
∀t(t < tpf → COMPUTEj(X, t)) ∧
END(X, tpf, u)),

the subformula ∀t(t < tpf → COMPUTEj(X, t)) implies that we will have a universal first-order quantifier before the existential second-order quantifiers in COMPUTEj. However, first-order quantifiers can be pushed inside the first-order part.  For example, the formula ∀x∃Xφ, where X has arity k, is equivalent to
∃Xj(∀xφj), where Xj has arity k + 1 and φj is obtained from φ by replacing any atomic subformula Xt with Xjxt. We conclude:
Lemma 6.2 (RIFP1 ⊆ ∃SO) RIFP1 is contained in the existential second-order logic.
Theorem 6.3 (RIFP1 = ∃SO) RIFP1 has the same expressive power as existen- tial second-order logic.
Therefore,
Corollary 6.4 (RIFP1 = NP) RIFP1 captures NP.

Comparisons between RIFP1 and the Nondetermin- istic Inflationary Fixed-Point Logic
In 1997, Abiteboul, Vianu, and Vardi [4] introduced the nondeterministic inflation- ary fixed-point logic NIFP where two first-order operators are defined and applied in any possible order.
Let Φ1, Φ2 : P(Ak) → P(Ak) be two operators. They give rise to sequences of sets
S0, S1,..., 
where each Si ⊆ Ak, S0 = ∅, and Si+1 = Φ1(Si) or Si+1 = Φ2(Si). A local ﬁxed-point of Φ1, Φ2 is a set Sm in some sequence as above such that Sm = Φ1(Sm)= Φ2(Sm). Let nifp(Φ1, Φ2) be the set of local fixed-points of Φ1, Φ2. The nondeterministic inflationary fixed-point logics extends FO with formulas of the form
[nifpX,xφ1(X, x), φ2(X, x)](t),

where φ1 and φ2 are first-order formulas of the form φ(X, x) V Xx, that is, they define inflationary first-order operators. The semantics of NIFP is defined as
I |= [nifpX,xφ1(X, x), φ2(X, x)](t) iff (tI,..., tI) ∈ [ nifp(φI, φI).

In 1997, Abiteboul, Vianu, and Vardi [4] also showed that NIFP captures NP on ordered structures. Then, using Theorem 6.3 and Fagin’s theorem, we have that NIFP has the same expressive power as RIFP1 on ordered structures. In the following, we will present a translation from NIFP to RIFP1.
Let Φ1, Φ2 : P(Ak) → P(Ak) be two operators. They give rise to a binary relation as follows:
Y = {(X, Φ1(X)) | X ∈ P(Ak)}∪ {(X, Φ2(X)) | X ∈ P(Ak)}.

A local fixed-point X of the pair Φ1, Φ2 is a fixed-point of Y, as Φ1(X) = Φ2(X) = X, but, if X = Φ1(X) /= Φ2(X) or X = Φ2(X) /= Φ1(X), X is a fixed- point of Y but not a local fixed-point of Φ1, Φ2. We have the following cases:
Case 1: Sm = Φ1(Sm)= Φ2(Sm) is a local fixed-point of Φ1, Φ2 and a fixed-point of Y;
Case 2: Sm = Φ1(Sm) and Sm /= Φ2(Sm) is a fixed-point of Y;
Case 3: Sm /= Φ1(Sm) and Sm = Φ2(Sm), similar to the previous case;
Case 4: Sm /= Φ1(Sm) and Sm /= Φ2(Sm) is neither a local fixed-point of Φ1, Φ2 nor a fixed-point of Y.
We have to define a relation which coincides with Y, except that it does not have the fixed-points that correspond to the cases 2 and 3 above. A fixed-point of Φ1 and Φ2 can be verified using the formulas C1 and C2 below, where φ1 and φ2

are first-order formulas that define Φ1 and Φ2:
C1(X) := ∀x(Xx ↔ φ1(x, X))

C2(X) := ∀x(Xx ↔ φ2(x, X))
We can use these formulas to include the pair (X, Φi(X)) if X is not a fixed-point of Φi, i = 1, 2, or if it is a fixed-point of both Φ1 and Φ2. Let ψ(X, Y ) be the following formula:
ψ(X, Y ) := [¬C1(X) ∧ ∀xY x ↔ φ1(x, X)] V
[¬C2(X) ∧ ∀xY x ↔ φ2(x, X)] V
[C1(X) ∧ C2(X) ∧ ∀xXx ↔ Y x].
A set X is an initial inflationary fixed-point of Yψ,I iff it is a local fixed-point of Φ1, Φ2. The formula
φ = [nifpS,x φ1(S), φ2(S)] (t)
from NIFP is equivalent to the formula
ψ = [rifpX,Y ψ(X, Y )] (t)
from RIFP. Since φ1 and φ2 are first-order, then ψ is in RIFP1. Hence we have proved that:
Theorem 7.1 (NIFP ⊆ RIFP1) NIFP is contained in RIFP1.
In general, the converse translation from RIFP1 to NIFP is not possible as the equivalence between RIFP1 and NIFP only holds for ordered structures. To show that NIFP is less expressive than RIFP1 we use the fact that the query Even is

RIFP1-definable, but it is not definable in the infinitary logic Lω
. We can translate

NIFP to Lω
. Therefore, we have that RIFP1 /⊆ NIFP. We use Lω
to build a

formula that expresses a local nondeterministic fixed-point of a pair of first-order operators. Let us see how such formula is defined.
An application sequence is an infinite sequence w = w1, w2,... such that wi ∈
{1, 2} for i ∈ N∗, where both numbers 1 and 2 appear infinitely many times. Let Φ1, Φ2 : P(Ak) → P(Ak) be inflationary operators and w an application sequence. The sequence of stages of Φ1, Φ2 based on w is the infinite sequence (Φ1, Φ2)w =

S0, S1,... of subsets of Ak such that S0 = ∅ and Si+1 = Φw

i+1
(Si). We call Si the ith

stage of the sequence (Φ1, Φ2)w, denoted by (Φ1, Φ2)w. A sequence of stages always
reaches a local nondeterministic fixed-point of Φ1, Φ2 at some stage (Φ1, Φ2)w . Let φ1(X, x) and φ2(X, x) be first-order formulas and let w be an application sequence. Each stage of a sequence of stages can be defined by a first-order formula. For every i ∈ N, there is a first-order formula ψw(x) such that for every interpretation I, ψw(x) defines the i-th stage (φIφI)w of the sequence of stages (φI, φI)w based on
i	1 2 i	1	2
the application sequence w. There is a formula ψw(x) in Lω	such that, for every
interpretation I, ψw(x) defines the local nondeterministic fixed-point reached by
the sequence of stages (φIφI)w based on the application sequence w. Let ψw(x) be
1 2

defined as ψw(x) =  {ψw(x) | i ∈ N}. Similarly, there is a formula ψφ1,φ2 ∈ Lω
expressing the nondeterministic fixed-point operators defined by φ1 and φ2. Let ψφ1,φ2 be defined as ψφ1,φ2 (x) = {ψw(x) | for every application sequence w}. It follows that:

Theorem 7.2 (NIFP ⊆ Lω
) Every NIFP formula has an equivalent formula in

ω
∞ω
Therefore we have:
Theorem 7.3 (RIFP1 /⊆ NIFP) RIFP1 is not contained in NIFP.

Conclusions and Future Works
We investigated first-order logic with relational fixed-point operators whose seman- tics differs from the semantics of classical fixed-point logics using relations instead of operations. We call it Relational Inflationary Fixed Point Logic — RIFP. Our approach generalizes that of traditional fixed-point logics adding to them expressive power to cope with nondeterminism.
We characterized the expressive power of RIFP showing that RIFP is equivalent to SO, that is, each formula of RIFP has an equivalent in SO, and vice versa. It follows that RIFP captures the polynomial hierarchy PH. We provide translations mapping formulas in one language to equivalent formulas in the other language. We also investigated the RIFP1 fragment of formulas of the form
∃z[rifpX,Y φ(X, Y )](t),
where φ(X, Y ) is a first-order formula. Small changes in the translations given show that RIFP1 is equivalent to the existential fragment of SO and, hence, it captures NP, the class of problems solved in nondeterministic polynomial time.
We also compared our logic with nondeterministic inflationary logic NIFP. NIFP generalizes traditional fixed-point logics using a pair of first-order operators to con- struct fixed-points through sequences obtained by successively applying the oper- ators. NIFP captures NP on ordered structures [4] and therefore has the same expressive power of RIFP1. We showed how to construct an RIFP1-formula equiv- alent to a given NIFP-formula.
The framework here presented can be used to explore other kinds of relational fixed-point logics. In the same way that new fixed-point logics are defined imposing some conditions on the operators used, we can define other relational fixed-point logics restricting the relations considered. Using this approach, several logics can be defined in a uniform way. We conclude by giving some natural next steps in this line of research, namely:
To define the partial fixed-point version of the relational operator: The equiv- alence between RIFP and SO strongly depends on the fact that relations are inflationary. Removing this condition should lead to an increase of expressive power;

To investigate the restriction of logic to monadic fragment of RIFP logic: The monadic fragment of RIFP is obtained restricting the rifp operator to formulas φ(X, Y ) where X and Y are monadic relations. The translation from SO to RIFP maps monadic formulas from SO to monadic formulas in RIFP. The translation from RIFP to SO does not preserve the arity of the relations involved;
To analyze the application of relational operators for higher-order logics beyond SO;
To apply RIFP and its fragments to problems in the scope of Database Theory.
References
S. Abiteboul, R. Hull, and V. Vianu. Foundations of Databases. Addison-Wesley Publishing Co., Reading, Massachusetts, 1995.
A. V. Aho and J. D. Ullman. Universality of data retrieval languages. In Proceedings of the 6th ACM SIGACT-SIGPLAN symposium on Principles of programming languages, pages 110–119. ACM, 1979.
S. Abiteboul and V. Vianu. Datalog extensions for database queries and updates. Journal of Computer and System Sciences, 43(1):62–124, 1991.
S. Abiteboul, M. Vardi, and V. Vianu. Fixpoint logics, relational machines, and computational complexity. Journal of the ACM, 44 - 1:30–56, 1997.
J. R. Bu¨chi. Weak second-order arithmetic and finite automata. Mathematical Logic Quarterly, 6(1- 6):66–92, 1960.
A. K. Chandra and D. Harel. Structure and complexity of relational queries. Foundations of Computer Science 21st Annual Symposium on, 1980.
C. C. Chang and H. J. Keisler. Model Theory. North-Holland, Amsterdam, 3rd edition, 1990.
E. F. Codd. A relational model for large shared data banks. Communications of the ACM, 13(6):377– 387, June 1970.
H. D. Ebbinghaus and J. Flum. Finite Model Theory. Springer, 1999.
H. D. Ebbinghaus, J. Flum, and W. Thomas.	Mathematical Logic.	Undergraduate Texts in Mathematics. Springer-Verlag, Berlin, 2nd edition, 1994.
R. Fagin.	Generalized first-order spectra and polynomial-time recognizable sets.	SLAM-AMS Proceedings, 7:43–73, 1974.
M. R. F. Farias. Complexidade Descritiva de L´ogicas de Ponto Fixo Relacionais. PhD thesis, Federal University of Cear´a, 2016.
E. Gr¨adel, P. G. Kolaitis, L. Libkin, M. Marx, J. Spencer, M. Y. Vardi, Y. Venema, and S. Weinstein.
Finite Model Theory and its applications (Vol.2). Heidelberg: Springer, 2007.
Y. Gurevich and S. Shelah. Fixed-point extensions of first-order logic. Annals of pure and applied logic, 32:265–280, 1986.
W. Hodges. Model Theory, volume 42 of Encyclopedia of Mathematics and Its Applications. Cambridge University Press, 1993.
N. Immerman. Relational queries computable in polynomial time. Proceedings of the 14th Annual ACM Symposium on Theory of Computing, 1982.
N. Immerman. Descriptive Complexity. Springer, 1999.
S. Kreutzer. Pure and applied fixed-point logics. PhD thesis, Bibliothek der RWTH Aachen, 2002.
P. G. Kolaitis and M. Y. Vardi. On the expressive power of variable-confined logics. In Logic in Computer Science, 1996. LICS’96. Proceedings., Eleventh Annual IEEE Symposium on, pages 348–
359. IEEE, 1996.
C. H. Papadimitriou. Computational Complexity. Addison Wesley Longman, 1994.
L. J. Stockmeyer. The polynomial-time hierarchy. Theoretical Computer Science, 3(1):1–22, 1976.
M. Y. Vardi. The complexity of relational query languages. Proceedings of the 14th Annual ACM Symposium on Theory of Computing, pages 137–146, 1982.
