Electronic Notes in Theoretical Computer Science 116 (2005) 241–252 
www.elsevier.com/locate/entcs


Validating Component Integration with C-TILCO
A Case Study
P. Bellini P. Nesi D. Rogai1
Dipartimento di Sistemi e Informatica Universit`a degli Studi di Firenze Firenze, Italy
Via S. Marta 3, 50139 Firenze, Italy, tel.: +39-055-4796523, fax.:+39-055-4796363

Abstract
Temporal logics are typically used to specify and verify properties and thus requirements, to de- scribe the system and to prove whether such formalization meets the expected behavior. In this paper, C-TILCO temporal logic is considered. C-TILCO is an extension of TILCO temporal logic which provides compositional and communication primitives. TILCO specifications of system be- havior can be directly used as implementations since they can be directly executed in real-time by using the TILCO executor. The validation phase can be applied to both the single components and their integration in order to validate the entire solution. In this article, a case study about specification of a communicating system is presented together with some important property proofs taken from the validation phase.
Keywords: formal specification language, first order logic, temporal interval logic, real-time systems, temporal operators, theorem provers, validation, components integration, communicating system.


Introduction
The specification of real-time systems implies the adoption of a specific formal model for the definition of temporal constraints among events and actions [6],

1 This work has been partially supported by the Italian Ministry of University and Research within the framework of the COFIN 2001 project ”Quack: a platform for the quality of new generation integrated embedded systems”


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.02.080


[1], [7]. These formal methods are typically used for describing properties of invariance, precedence amongst events, periodicity, liveness and safety condi- tions, etc. For this purpose, several temporal logics have been used [1], or timed state machine, Petri Nets, etc. When the system under specification is not trivial its specification needs to be performed by decomposing the prob- lems in smaller segments or components devoted to solve specific identified sub-problems [10], with the aim of obtain the whole system for composition.
The adoption of compositional models for the systems specification has to be supported by formal methods for the verification of components and composed systems [9]. The verification is performed by using model check- ing approaches on the operational description of the system, in others the verification is performed by validating the formal composition and thus the compositional behavior.
The approach proposed in this paper is based on TILCO (Temporal Logic with Compositional Operators) and its compositional version called C-TILCO. Please note that C in TILCO acronym is referred to the composition of tempo- ral constraints. TILCO presents a uniform model for time from past to future and unique operators for stating facts and events along the time axis [8], together with extended temporal operators (TILCO-X) [5] and process com- munication support (C-TILCO) [4]. The process communication of C-TILCO allows to specify a complex system by decomposing it in several processes and it allows to model inter-process communication between them. TILCO lan- guage can be directly executed, such executability consists in using the spec- ification as an implementation of the real-time system, thus allowing (in each time instant) the on-line generation of system outputs on the basis of current inputs (including those concerning communication) and internal state. In this sense, TILCO-Executor, presented in [3], can execute a fragment of TILCO specifications.
This paper presents a case study where C-TILCO has been used for the specification and validation. C-TILCO permits the description of the (i) inter- nal properties of each process involved in the architecture and (ii) the external properties suitable for a correct interaction of the components.

C-TILCO Overview
A system specification in C-TILCO is a hierarchy of communicating process components whose specifications are written in TILCO. TILCO is a logic lan- guage which can be used to specify temporal constraints in either a qualitative or a quantitative way [5]; the meaning of a TILCO formula is given with re- spect to current time. Time is discrete and linear and the temporal domain


is the set of integers . The minimum time interval corresponds to one in- stant, the current time instant is represented by 0 and positive (negative) numbers represent future (past) time instants. The basic entity in TILCO is temporal interval, the boundaries of which can be either included or excluded using the usual notation with squared, (“[”, “]”) or round (“(”, “)”) brackets, respectively.
The basic TILCO temporal operators are:
“ @ ”, universal quantification (∀) over a temporal interval;
“ ? ”, existential quantification (∃) over a temporal interval;
“until”, to express that either a predicate will always be true in the future,
or it will be true until another predicate becomes true;
“since”, to express that either a predicate has always been true in the past, or it has been true since another predicate became true.
TILCO has been extended to provide some more expressive operators cre- ating the TILCO-X language [5]. The dynamic intervals allow to define an interval using boundaries which are dependent on TILCO expression. For ex- ample, A@(0, +B] asserts that A is true since the next time instant to the instant when B occurs for the first time since now; such instant is included in the expression. Similarly a boundary like −B refers to the last time B
occurred in the past.
In C-TILCO many instances of the same process component specification can be arranged in the global architecture. Processes can have some parame- ters and every instance has its own distinct values. The communication among processes is based on a CSP like typed synchronous input/output ports con- nected through channels. The connection is 1:1, each output port is connected to at most one input port and vice-versa.
A C-TILCO process is externally characterized by a set of external input ports used to acquire information from the outside; a set of external output ports used to produce information to the outside; a set of external variables used to give some general information about the process state or to simplify the exter- nal behavior specification; a set of external parameters used to permit general process specification so as to make process reuse easier, since different process instances may have different parameter; a set of external TILCO formulæ de- scribing the external process behavior through the messages exchanged and the constraints on the external variables.
C-TILCO is internally characterized by: a set of C-TILCO subprocesses; a set of internal input ports, used to get information from subprocesses; a set of internal output ports used to send information to subprocesses; a set of in- ternal variables; a set of internal TILCO formulæ, which describe the internal behavior of the process.


The ports of subprocesses can be directly connected to the containing process ports (of the same type, input to input and output to output) or can be connected through channels to the complementary internal ports (output to input and input to output). The use of internal ports permits the realization of partial decompositions, when the process behavior is only partially specified by subprocesses and, thus, some interactions with the subprocesses are stated by means of the TILCO formulæ of the internal specification.
In TILCO formulæ, the dot notation is used to access process components. Since there can be many instances of the same process in the system, its specification is valid for all of them. By means of a colon operator applied to process components, process and local variables can be easily distinguished in the specification.
Since in TILCO the time axis is infinite in both directions there, is not a time instant that can be regarded as the start time instant of the execution process. In the system specification, it is natural to consider a reference time instant when the process starts its work: before that time, all signals are stable. For this reason, a Boolean variable process start has been introduced to each process. This variable is true only in one time instant for each process. It should be noted that each process has its own start instant and a formula of the internal specification is used to define the start time instant of its subprocesses. Typically when a process starts, its subprocesses start as well.
Communication primitives
C-TILCO provides synchronous ports, the basic operators on these ports are: Send (!!) and Receive (??):
<outPort> !! <expr> [<whileExpr>];; <thenExpr> sends through output port <outPort> the value obtained by evaluating expression <expr>. When the communi- cation ends, TILCO expression <thenExpr> is asserted. While waiting, the temporal expression <whileExpr> is asserted.
<inPort> ?? [<whileExpr>];; <thenExpr> waits for a message (if not already arrived) from input port <inPort>. When message arrives, the TILCO expression
<thenExpr> is evaluated as a function of the value received. While waiting, the expression <whileExpr> is asserted.

Operators: outP !! and inP ?? have been introduced to specify that a pro- cess has not to send a message on a port or that the process has not to ask for a message. These conditions cannot be specified by using ¬(inP !! v [P ];; W )
which has a different meaning.

Using C-TILCO to specify a communication protocol
The following case study is presented to show how C-TILCO can help in the formal verification of a component-based architecture.
The system under specification is a communication system, based on a well know protocol. The communication system is composed of several nodes which are connected in a ring structure (see Fig 1).

Fig. 1. The communication system

This communication basically aims at being robust against a single node failure and at distributeing the communication priority uniformly on the nodes. Two concentric rings are provided: the main ring where information is passed along the elements, and the backup ring which recovers a main ring failure connection and allows to perform the communication until the system is re- stored. The main ring is marked with A letter and the backup with B. Input and output port for each ring are required. The communication system is the result of the proper connection of the nodes. A fixed information (called token) is received and retransmitted by every node to the adjacent. If a node needs to transmit a data, it waits for the token, then it transmits the data to the adjacent while keeping the token and, when the transmitted message returns back to the sender, it releases the token. A node recognizes a fault communication after a time-out and it redirects the communication in the backup ring which works in the opposite direction of the main ring.
The system is realized in terms of communication nodes; over each one a higher level communication interface is typically connected. These nodes perform only simple data communication and protocol management. The token is considered as boolean and it is transmitted over a dedicated channel. The message is treated as a structured type that includes the origin and the destination node ID.
The data communication structure is as follows:



struct DATAPACK { int srcID; int dstID;
char data[MAX_LENGHT];
}







System requirements
The node basically performs the following operations:
it waits for the token;
when the token is received, it can transmit data on the ring without releasing the token, otherwise it must retransmit the token along the node chain;
if the adjacent node does not reply, it has to redirect the same information (token or data) on the back up ring which works in the opposite direction;
when the transmitted data comes back from the ring, the node releases the token so as to allow the other to transmit their own data.
any data received on the backup channel has to be retransmitted without any check, just redirecting it on the main ring if the adjacent node does not replay.



Communication Node
The node must ensure the communication and a particular attention should be given to the token passing. When a wrong behavior is observed on a node, the basic token transmission has to be granted in order to keep communication alive. For this reason, the node system is decomposed in sub-systems. The decomposed communication node is shown in Fig. 2 and it presents three sub-systems:
Communication Manager: it grabs the token and performs the commu- nication protocol on the main ring;
Token Repeater: it repeats the token to the next node when the token reaches the communication node; it is used by the backup ring;
Data Repeater: like the Token Repeater, simply it handles data.
The main component is the Communication Manager the specification of which is made of several parts, so as to assure a better understanding of their meanings.


	
inData	outData


 sendData sendToken
recData  recToken





 recTokenBack recDataBack
sendTokenBack  sendDataBack


Fig. 2. The decomposition of the communication node


The following TILCO-X specification expresses the basic token passing inside the communication manager.
: readyF orT oken =dd
: recT oken ?? [¬ : readyF orT oken ∧¬ : transmitAnything];; (¬ : readyF orT oken∧
(: dataBuf ferEmpty ⇒
(: transmitT oken ∧ ¬∃any. : transmitData(any)) @ [0, + : readyF orT oken))∧
(: getDataBuf fer(d) ⇒
(: transmitData(d) ∧¬ : transmitT oken) @ [0, + : readyF orT oken)))
A “ready” predicate, initialized when the node process starts, puts the system in a wait status for receiving. While the node is waiting for the token, it can transmit nothing (neither token nor data).
When a token comes, two different choices are available: to re-transmit the token or to transmit the data buffered from the inData port.
Concerning the data transmission the requirements specify that a new data is received from the higher layer input port and it is stored in a specific buffer until the token is grabbed by the node. An asynchronous communication in this direction is used to avoid any unnecessary delay time in the ring com- munication: in this way the token is not grabbed till nedded, which is to say when there is a data to transmit. With a non-empty buffer and the grabbed token the transmission can start as it is specified in the following formulas. A simple rule, providing a token (or a data) redirection on the backup ring whenever the main fails, has to be considered. The sendingToken (or send- ingData) predicate asserts that a transmission attempt is on (until the node receive the ACK signal from the adjacent after a successful transmission). Thus the time-out condition can be evaluated as:
¬ : reset @ (−((: sendingT oken∨ : sendingData) @ (−10, 0]), 0) ⇐⇒ : brokenChannel


The transmission of a token which occurs after a received token is specified by the following formulae:
: transmitT oken ∨ ∃any. : transmitData(any) =⇒: transmitAnything up(: transmitT oken ∧¬ : brokenChannel) =dd
¬ : readyF orT okenB @ [0, + : brokenChannel]∧
: sendT oken !! [sendingT oken ∧¬ : readyF orT okenA]; ;
¬ : sendingT oken @ [0, +(: transmitT oken∨ : repeatT oken))∧
: readyF orT okenA ∧¬ : transmitAnything up(: transmitT oken∧ : brokenChannel) =dd
: sendT okenBack !! [¬ : readyF orT okenB]; ;
: readyF orT okenB ∧¬ : transmitAnything
: readyF orT okenA∨ : readyF orT okenB  ⇐⇒ : readyF orT oken
The following expressions specify the behavior after the activation of a transmitData(d). Therefore the node has to transmit the data d to the adja- cent (it is very similar to the token transmission, previously described).
up(: transmitData(d) ∧¬ : brokenChannel) =dd
¬ : readyF orT okenB @ [0, + : brokenChannel]∧
: sendData !! d [sendingData ∧¬ : readyF orT okenA]; ;
¬ : sendingData @ [0, +∃next.(: transmitData(next)∨ : repeatData(next)))∧
: readyF orT okenA ∧¬ : transmitAnything up(: transmitData(d)∧ : brokenChannel) =dd
: sendDataBack !! d [¬ : readyF orT okenB]; ;
: readyF orT okenB ∧¬ : transmitAnything
In these formulas, a failed attempt of communication on a broken channel is recovered using the backup ring; if both channels are broken the node cannot communicate anymore. Two different predicates can determine the ready state after a successful transmission (readyForT okenA, readyForT okenB) on one of the available channels. It has to be noticed that a broken channel will freeze the port on the send state, waiting forever for the remote synchronization.
The management of incoming data is specified with a similar structure. The process initialization puts in a waiting status all the system’s receiving ports. Therefore in order to complete the specification, specific predicates have been introduced to assert that no data or token is sent until the apposite predicate is activated. The initialization expression is as follows:
: process start =⇒
: readyF orT oken∧ : readyF orData∧
¬ : transmitAnything ∧¬ : repeatAnything∧
: readyF orT okenBack∧ : readyF orDataBack∧
¬ : sendingT oken @ (−∞, +(: transmitT oken∨ : repeatT oken))∧
¬ : sendingData @ (−∞, +∃d.(: transmitData(d)∨ : repeatData(d)))


The other sub-components have not been described in this paper; the specification of these parts usually reuses formulæ from the communication manager and it introduces different features in a less complex behavior to help component reuse.

Validating the specification
In order to prove properties at single process level and for the whole system the inference rules defined for C-TILCO and for TILCO-X could be used. The validation reported here is only a small part of the whole validation.
The following two theorems have to be considered in order to prove prop- erties for a single process :

▶t p !! v [Ws]; ; Ps
▶t until0 Ps Ws
▶t p ?? [Wr];; Pr
▶t ∃v. until0 Pr(v) Wr

These two theorems allow to substitute a Send/Receive operator with a
weak until operator in the premises of a goal.
In the theorems used to prove properties for connected processes, the RWait operator plays an important role. It summarizes the communication status saying if a message was received in the past and it has not been ac- knowledged yet. These two main theorems are as follows:




d
I |= out → in
▶t in ?? [Wr]; ; Pr
▶t+ts out !! v [Ws]; ; Ps
▶t in ?? @[ts − d, 0) ts < −d
▶t Pr (v)
▶t+d Ps
▶t Ws@[ts, d)
▶t out !! @(ts, d)
▶t+1 in.RWait
▶t in.RWait
d
I |= out → in
▶t in ?? [Wr]; ; Pr
▶t+ts out !! v [Ws]; ; Ps
▶t in ?? @[ts − d, 0)
▶t out !! @[−d, ts)
−d ≤ ts


▶t+ts+d Pr (v)
▶t+ts+2d Ps
▶t Wr @[0, ts + d)
▶t+ts Ws@[0, 2d)
▶t in ?? @(0, ts + d)
▶t+ts in !! @(0, 2d)
▶t+ts+d+1 in.RWait

Which means in the premises of the left-side theorem: if two ports are connected with a delay d, a Receive is asserted at time t, and a Send is asserted ts instants before the Receive. In the implication on the left-side: the message is received at time t, Ps is true after d time instants, the wait formula of Send is true since the Send time instant to the end of communication time instant, and at t +1 RWait is true stating that no message is pending.


The theorem on the right-side copes with the opposite case: when there is no pending message, the Send is done after the Receive or within the delay.
The Communication Node safeness properties about token/data transmis- sion can be proved for single processes level. The readyForT oken predi- cate cannot be asserted together with the transmission attempt of token/data (transmitT oken and transmitData). This can be stated as:
: process start =⇒ (: readyF orT oken ⇒ (¬ : transmitT oken ∧ ¬∃any. : transmitData(any)))@[0, +∞)
it can be transformed into:
: process start =⇒: readyF orT oken ∧¬ : transmitAnything
: readyF orT oken ∧¬ : transmitAnything =⇒¬ : transmitAnything @ [+ : readyF orT oken]
which can be proved using the specification.
Moreover, out of this result a safeness property can be derived: token and data cannot be transmitted simultaneously (¬B @ [0, +∞)). This can be stated as:
: process start =⇒ ¬(: transmitT oken ∧ ∃any. : transmitData(any))@(0, +∞)
In order to demonstrate that such a critical condition cannot be met, an initial induction-like strategy has been adopted to branch the main goal:
: process start =⇒ : readyF orT oken
: readyF orT oken =⇒ (¬BAD) @ (0, + : readyF orT oken]
where BAD =: transmitT oken ∧ ∃any. : transmitData(any) asserts the bad condition. The first part is trivially derived from the specification. The second impli- cation needs a further step to separate the singular point at the end of the dynamic interval. This can be written as follows:
: readyF orT oken =⇒ (¬BAD) @ (0, + : readyF orT oken)∧
: readyF orT oken =⇒ (¬BAD) @ [+ : readyF orT oken]
The second sub-goal is directly solved by the safeness condition
: readyForT oken ⇒ ¬ : transmitAnything;
Whereas the first subgoal can be proved by looking at the specification ruling the system when it waits for the token and after it has arrived. From the expression written at page 7 the following proof status can be achieved:








▶t : readyF orT oken
▶t+1 : recT oken ?? [¬ : readyF orT oken ∧¬ : transmitAnything]; ; (¬ : readyF orT oken∧
(: dataBuf ferEmpty ⇒
(: transmitT oken ∧ ¬∃any. : transmitData(any)) @ [0, + : readyF orT oken))∧
(: getDataBuf fer(d) ⇒
(: transmitData(d) ∧¬ : transmitT oken) @ [0, + : readyF orT oken)))
▶t(¬BAD) @ (0, + : readyF orT oken)

The specification must be validated against the integration of the com- ponent. The property which grants the token passing, ensures a balanced communication priority for every node of the ring. The token passing is quick and, on the basis of a small delay of port communication, it is performed


inside a single time sample. An integration property asserts that if the com- munication channel is broken, a token is passed along the backup ring.
Considering two adjacent nodes (n1, n2) what has been supposed is that n1 is attempting to transmit the token (n1.sendingT oken) and n2 is waiting for a token. The waiting status of n2 can be expressed as:

n1 .sendT oken !! @ [−n2 .readyForT oken, 0)
Moreover it must be asserted that ¬n1.brokenChannel ∧ n2.brokenChannel;
n2.buff erEmpty is true, meaning that on n2 no message has to be sent.
The synchronization between the connected ports n1.sendT oken and n2.recT oken activates n2.transmitT oken; the broken channel condition en- ables the trasmission of the token on the n2.sendT okenBack port. The con- nected port n1.recT okenBack, which was waiting for a synchronization can propagate the token in the backup ring.

Conclusions and Future Work
Verification and validation is very important for systems which are built on the basis of components. C-TILCO allows the specification of the whole system in sub-components and the primitives to control communication among them. After a proper formalization of the component-based architecture integration tests can be performed by means of properties proofs. This validation requires dedicated tools to work out easily a considerable amount of proofs. To this end, an implementation of TILCO temporal logic (including TILCO-X and C-TILCO features) in the PVS theorem prover is in progress.

References
P. Bellini, R. Mattolini and P. Nesi, Temporal logics for real-time system speciﬁcation, ACM Computing Surveys 31 (2000).
P. Bellini, M. A. Bruno, P. Nesi, Veriﬁcation of External Speciﬁcations of Reactive Systems, IEEE Trans. on Systems Man and Cybernetics - Part A, 30-6(2000), pp. 692–709.
P. Bellini, A. Giotti and P. Nesi, Execution of tilco temporal logic speciﬁcations, Proc. of the 8th IEEE Intl. Conference on Engineering of Complex Computer Systems, Greenbelt, (Maryland, USA) (2002).
P. Bellini and P. Nesi, Communicating TILCO: a model for real-time system speciﬁcation, in: Proc of the 7th ”IEEE International Conference on Engeneering of Complex Computer Systems”,ICECCS’01.
P. Bellini and P. Nesi, TILCO-X: an extension of TILCO temporal logic, in: Proc. of the 7th ”IEEE International Conference on Engeneering of Complex Computer Systems”,ICECCS’01.
G. Bucci, M. Campanai and P. Nesi, Tools for specifying real-time systems, Journal of Real-Time Systems 8 (1995), pp. 117–172.
A. Coen-Porisini, C. Ghezzi and R. Kemmerer, Speciﬁcation of real-time systems using ASTRAL, IEEE Trans. on Soft. Eng., 23 (1997) 572-598


R. Mattolini and P. Nesi, An interval logic for real-time system speciﬁcation, IEEE Trans. on Soft. Eng., March-April (2001).
G. Leavens and M. Sitaraman. Foundations of component-based systems. Cambridge University Press, (2000).
L. Mariani, A fault taxonomy for component-based software, proc. of International Workshop on Test and Analysis of Components Based Systems, TACOS2003, (M. Pezze, Ed.), Warszawa, April, 2003.
