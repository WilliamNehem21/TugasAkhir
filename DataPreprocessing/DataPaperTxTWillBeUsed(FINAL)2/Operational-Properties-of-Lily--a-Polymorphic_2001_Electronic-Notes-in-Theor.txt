Electronic Notes in Theoretical Computer Science 41 No. 3 (2000)
URL: http://www.elsevier.nl/locate/entcs/volume41.html pages 70–88


Operational Properties of Lily, a Polymorphic Linear Lambda Calculus with Recursion*

G.M. Biermana A.M. Pittsb C.V. Russob
a Department of Computer Science, Warwick University, Coventry CV4 7AL, UK
b Computer Laboratory, Cambridge University, Cambridge CB2 3QG, UK


Abstract
Plotkin has advocated the combination of linear lambda calculus, polymorphism and fixed point recursion as an expressive semantic metalanguage. We study its expressive power from an operational point of view. We show that the naturally call-by-value operators of linear lambda calculus can be given a call-by-name seman- tics without affecting termination at exponential types and hence without affecting ground contextual equivalence. This result is used to prove properties of a logi- cal relation that provides a new extensional characterisation of ground contextual equivalence and relational parametricity properties of polymorphic types.


Introduction
When giving denotational semantics of programming languages using domain theory, use is often made of metalanguages in which to phrase the seman- tic descriptions [16,14]. The attraction of such an approach is that it allows the semantically relevant constructs and proof principles inherent in the do- main theory to be abstracted from the often quite complicated mathematical details. Restricting attention to the denotational semantics of deterministic languages (i.e. excluding the use of various kinds of powerdomain), Plotkin [23] makes a convincing case for polymorphic linear lambda calculus with recursion as an expressive denotational metalanguage. In particular, the powerful na- ture of impredicative polymorphism permits the plethora of domain-theoretic constructs to be defined in terms of remarkably few primitive type-forming
operations, namely ∀-types, ∀α. τ , linear function types, τ  τ', and expo- nential types, !τ : see Fig. 1, which uses the domain-theoretic terminology of [8]. (Plotkin [23] chooses to make intuitionistic function types primitive rather than exponential types; we prefer to express the former in terms of !

  Research supported by UK EPSRC grant GR/M04716.
◯c 2000 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


Lifting	τ⊥  !τ
Functions	τ → τ '  !τ   τ '
Strict functions	τ ◦→ τ '  τ   τ '
Smash product	τ ⊗ τ '  ∀α.(τ  τ '  α)  α Coalesced sum	τ ⊕ τ '  ∀α. !(τ  α)  !(τ '  α)  α Product	τ × τ '  ∀α.((τ  α) ⊕ (τ '  α))  α
Separated sum	τ + τ '  !τ ⊕ !τ '
Existential	∃ α. τ (α)  ∀β.(∀α. τ (α)   β)   β
Truth values	T  ∀α. !α   !α   α
Flat naturals	N⊥  ∀α. !α   !(!α   α)   α
Inductive	µα. τ (α)  ∀α. !(τ (α)   α)   α	(α +ve in τ (α))
Co-inductive	να. τ (α)  ∃ α. !(α   τ (α)) ⊗ α	(α +ve in τ (α))
Recursive	rec α. τ (α, α)  να. τ (µβ. τ (α, β), α)	(α +ve in τ (α, β),
β −ve in τ (α, β))

Fig. 1. Lily as a denotational metalanguage
and  using Girard’s famous decomposition: τ → τ' = !τ  τ'.) The defini- tions in Fig. 1 only have weak properties if one works up to β-convertibility of terms. To get stronger properties, such as category-theoretic universal prop- erties, it should suffice to work with a notion of equality of terms that makes
∀-types relationally parametric in the sense of Reynolds [24]. In theory, one
way to generate such a notion of equality is via a suitable model: Plotkin [23] sketches one using strict, inductive partial equivalence relations on a domain model of the untyped lambda calculus. However, in practice, as far as we know, the details of this relationally parametric model of polymorphic linear lambda calculus with recursion have not been worked out in detail. We take
a different 1 and more computational approach: we make polymorphic linear
lambda calculus with recursion into a programming language (we call it Lily) by endowing it with an operational semantics; we choose a particular notion of contextual equivalence derived from the operational semantics; and we prove that this notion of term equality is relationally parametric with respect to a suitable notion of binary relation. This strategy has been applied successfully by the second author to the combination of polymorphism with PCF [21] and with call-by-value PCF [20]. However, it is not so easy to apply the strategy

1 It should also be noted that Lily’s exponential types give a more refined treatment of usage and strictness properties than does lifting (−)⊥ in the domain model, because the latter happens to have an extra contraction property that we do not assume for !-types in Lily.


to linear lambda calculus, as we now explain.
Recall that two terms of a programming language are contextually equiv- alent if interchanging them in any complete program does not affect the ob- servable results of evaluating the program. Even if we fix the operational semantics of the language, we may or may not get different notions of con- textual equivalence depending upon what we decide constitutes a ‘complete program’ and what we observe of evaluation. Consider the classic example of call-by-name PCF. Taking programs to be closed terms of ground type and observing convergence to ground values, we get the notion of ground contextual equivalence studied in the seminal paper by Plotkin [22]; whereas if we ob- serve termination of evaluation of closed terms of any type we get a different, lazy contextual equivalence analogous to that for the ‘lazy’ lambda calculus of Abramsky [1]. Lazy contextual equivalence for linear lambda calculi is studied in [5,4]. For Lily we work with ground, rather than lazy, contextual equiva- lence, in order for the definitions in Fig. 1 to be correct; for example, with lazy contextual equivalence the linear function type τ  τ' would not represent a domain of strict continuous functions τ ◦→ τ', but rather its lift (τ ◦→ τ')⊥.
Before the work presented here, very little was known about the properties of ground contextual equivalence for linear lambda calculus: see [4, Sect. 7]. For example it was not even known whether it is different from lazy contextual equivalence (we show that it is—see Example 3.7). Roughly speaking, what was lacking was a sufficiently powerful analysis of the properties of linear func- tions whose codomains are ‘observable’ types (ones at which ground contextual equivalence distinguishes divergent terms from ones in canonical form). We provide such an analysis, and much more besides. The contributions of this paper are as follows.
A Strictness Theorem. The conventional wisdom [2, p 16] is that oper- ational semantics of linear lambda calculus is ‘naturally’ call-by-value in some parts (e.g. for  , ⊗, and ⊕) and call-by-name in others (e.g. for !, →, and ×). We show that the naturally call-by-value operators can be given a call-by-name semantics without affecting termination at exponential types (Theorem 2.3) and hence without affecting ground contextual equivalence. This technical result turns out to be the key to developing a rich operational theory for Lily.
A Parametric Logical Relation. Using the Strictness Theorem, we show that Lily ground contextual equivalence coincides with a particular logical relation (Theorem 3.2), involving parameters that are ‘admissible’ term- relations similar to those used previously by the second author [20,21]. As a corollary we obtain new extensionality results for linear lambda calculus (Corollary 3.5). The logical relation also allows us to prove results that validate the definitions in Fig. 1 and indicate the expressive power of Lily’s combination of linear lambda calculus with impredicative polymorphism and fixpoint recursion (see Remark 3.8, Example 3.9 and Remark 3.10).

A Common Intermediate Language for Strict and Lazy. From a pro- gramming language perspective Lily has the potential to be a common intermediate language for both strict and lazy functional programming. To realise that potential one would need to work at a more intensional level than we do in most of this paper (cf. [27]). However we do indicate how to replace the call-by-name semantics of terms involving exponential types in Lily (which subsumes fixpoint recursion) with a call-by-need semantics without affecting ground contextual equivalence (see Sect. 4). Details will appear elsewhere, along with an exploration of translations of the pure core of ML and Haskell into Lily.

A Strictness Theorem
Lily combines a term calculus for Plotkin’s dual intuitionistic linear logic [3] with fixpoint recursion and impredicative polymorphism. In the presence of the latter it turns out that we can cut down to just linear function and ex- ponential types without losing expressive power. The types and terms of the Lily language are given in Fig. 2, together with its type assignment relation. We find it convenient to employ a syntactic distinction between intuitionistic variables x ∈ IVar , that may be duplicated and discarded, and linear vari- ables a ∈ LVar , that must be used exactly once. ∀α.( ), λa : τ.( ), Λα.( ),
!(x = ( ) : τ ), and let !x = M in ( ) are variable-binding constructs and we identify types and terms up to renaming of bound variables. The notations ftv ( ), fiv ( ), flv ( ) are used to denote the sets of free type variables, free in- tuitionistic variables and free linear variables of an expression. We use the notation −[−/−] to indicate capture-avoiding substitution.

Recursively defined thunks
A syntactic novelty of Lily is the absorption of fixpoint recursion into the terms of exponential type. A recursively defined thunk !(x = M : τ ) is a canonical form introducing a recursively defined non-linear term as a suspended computation. The corresponding eliminator let !x = M in M' evaluates the term M to such a recursive thunk, substitutes an unfolding of the thunk’s body for the intuitionistic variable x and evaluates the body M' (see Fig. 3 below; and see Sect. 4 for an alternative, call-by-need semantics). Since a thunk’s body may be duplicated during the evaluation of the let construct, potentially duplicating linear variables, the typing rules ensure that thunks contain no free linear variables. We can get conventional fixpoint terms by defining
fix x : τ. M   let !x = !(x = M : τ ) in M
and non-recursive thunks (of type !τ ) by defining
!M   !(x = M : τ )	(x ∈/ fiv (M )).




Types  τ ::= α	type variable (α ∈ TyVar )
τ   τ	linear function type
∀α. τ	∀-type
!τ	exponential type
Terms M ::= a	linear variable (a ∈ LVar )
x	intuitionistic variable (x ∈ IVar )
λa : τ. M	abstraction
M M	application
Λα. M	generalisation
M τ	specialisation
!(x = M : τ )	recursively defined thunk
let !x = M1 in M2	exponential eliminator
Type assignment relation Γ;∆ ▶α M : τ is inductively generated by the following rules. (Γ is a finite function from intuitionistic variables to types with domain dom(Γ); ∆ is a finite function from linear variables to types with domain dom(∆), and α is a finite set of type variables.)

ftv (Γ,τ ) ⊆ α	x /∈ dom(Γ) Γ,x : τ ; ∅ ▶α x : τ
ftv (Γ,τ ) ⊆ α


Γ; a : τ ▶α a : τ

Γ; ∆,a : τ ▶α M : τ'	a /∈ dom(∆)
Γ;∆ ▶α λa : τ. M : τ   τ'
Γ; ∆1 ▶α M1 : τ  τ'	Γ; ∆2 ▶α M2 : τ	dom(∆1) ∩ dom(∆2) = ∅ Γ; ∆1, ∆2 ▶α M1 M2 : τ'

Γ;∆ ▶α,α M : τ	α /∈ α ∪ ftv (Γ, ∆) Γ;∆ ▶α Λα. M : ∀α. τ
Γ;∆ ▶α M : ∀α. τ	ftv (τ') ⊆ α


Γ;∆ ▶α M τ' : τ [τ '/α]

Γ,x : τ ; ∅ ▶α M : τ	x /∈ dom(Γ) Γ; ∅ ▶α !(x = M : τ ) : !τ
Γ; ∆1 ▶α M1 : !τ		Γ,x : τ ; ∆2 ▶α M2 : τ' x /∈ dom(Γ)	dom(∆1) ∩ dom(∆2) = ∅ Γ; ∆1, ∆2 ▶α let !x = M1 in M2 : τ'

Fig. 2. Lily syntax and type assignment


Conversely, recursively defined thunks could have been expressed in terms of non-recursive thunks and fixpoints, by taking !(x = M : τ ) to be !(fix x : τ. M ) (see Corollary 3.6). There is perhaps not much to choose between the two formulations. We prefer the compactness of the one we have presented. It easily generalises to mutually recursive thunks !(x1 = M1 : τ1,..., xn = Mn : τn) whose type !(τ1,..., τn) is equivalent to !τ1 ⊗· · · ⊗ !τn.

Ground contextual equivalence
Recall from the Introduction that we wish to identify terms if they give the same evaluation behaviour in all contexts of ground type, such as types of booleans and natural numbers. But there are no such types in Lily as we have defined it! In fact this ground contextual equivalence is the same as the contextual equivalence determined by observing the termination properties of evaluation at exponential types !τ (and then the ground types are definable, modulo ground contextual equivalence, as in Fig. 1). To see this, consider adding to Lily a type bool together with truth-values and conditionals

Γ; ∅ ▶α true : bool		Γ; ∅ ▶α false : bool Γ; ∆1 ▶α M1 : bool	dom(∆1) ∩ dom(∆2) = ∅ Γ; ∆2 ▶α M2 : τ			Γ; ∆2 ▶α M3 : τ
Γ; ∆1, ∆2 ▶α if M1 then M2 else M3 : τ
Then for any closed term M of exponential type !τ , let !x = M in true is a closed term of type bool that evaluates to true if and only if M evaluates (in the operational semantics to be described below) to some thunk. Conversely, for any closed term B of type bool, B evaluates to true if and only if the closed term if B then !(x = x : τ ) else Ω (!τ ) of type !τ evaluates to some thunk. Here Ω is a generic divergent term
Ω  let !x = !(x = x : ∀α. α) in x
whose type is ∀α. α. (Using the macro in equation (1) for fixpoint expressions, this takes on the more familiar form Ω = fix x : (∀α. α). x.) Thus contextual equivalence based upon observing convergence to true at type bool is the same as that based upon observing convergence to canonical form at expo- nential types. (This is different from observing convergence at all types: see Example 3.7 below.)
When defining a contextual equivalence for linear lambda calculi one has to refine the traditional formulation, in which ‘holes’ in contexts have implicit parameters (namely the binding variables within whose scope the hole lies), since it matters whether these parameters are linear or not. The first author discusses one such refinement in [4, Sect. 3.1] using second-order variables to give a more explicit treatment of holes (see also [19,5,15]). An attractive alternative (because it doesn’t require the introduction of extra syntactic ma- chinery) is to avoid the use of contexts completely and define the equivalence


to be the largest substitutive congruence relation on well-typed open terms having the required convergence property for closed terms of exponential type. This ‘relational’ approach to contextual equivalence is taken in [10,21] and will be used in the full version of this paper. However, in order to simplify the exposition in this extended abstract, we will restrict attention to ground con- textual equivalence of closed terms (of closed types), for which we can side-step these issues about contexts and use the following definition. It depends upon the notion of a closed term M of closed exponential type converging to (some) canonical from, which we write as M ⇓! and define below (see Corollary 2.4).
Definition 2.1 (Ground contextual equivalence for closed terms) Let Typ denote the set {τ | ftv (τ ) = ∅} of closed types; and for τ ∈ Typ, let Term(τ ) denote the set {M |∅ ; ∅ ▶∅ M : τ} of closed terms of type τ . Given M, M' ∈ Term(τ ), we write M =gnd M' : τ to mean:
for any x, N, τ' satisfying x : τ ; ∅ ▶∅ N : !τ ', it is the case that N [M/x] ⇓! if and only if N [M'/x] ⇓! ; and
for any a, N, τ' satisfying ∅ ; a : τ ▶∅ N : !τ ', it is the case that N [M/a] ⇓! if and only if N [M'/a] ⇓! .

Operational semantics
Figure 3 gives two possible evaluation relations for closed Lily terms, dif- fering in their treatment of the application of a linear function to an argument. The strict (or call-by-value) relation ⇓s corresponds to the ‘natural’ opera- tional interpretation of intuitionistic linear logic advocated by Abramsky [2, p 16] and used by others (such as [27,4]); whereas the other relation, ⇓n , used for a linear lambda calculus by Crole in [5], gives all constructs a non-strict (or call-by-name) semantics. The two relations give rise to two termination relations
strict termination relation:    M ⇓s   ∃ V. M ⇓s V
non-strict termination relation: M ⇓n ∃ V. M ⇓n V. These are different relations, as the following simple example shows. Example 2.2 Choose any closed types τ, τ' ∈ Typ. Define
E  λa : τ. λf : τ   τ'.f a.
Then E (Ω τ ) ∈ Term((τ  τ')  τ') and E (Ω τ ) ⇓n but E (Ω τ ) /⇓s. (Here Ω is the generic divergent term defined at (3).)
However, as the following slightly surprising theorem shows, the two termi- nation relations do coincide if we restrict our attention to terms of exponential type.
Theorem 2.3 (Strictness Theorem) For all τ, τ' ∈ Typ, M ∈ Term(τ ), and open terms of exponential type, ∅ ; a : τ ▶∅ N : !τ '
N [M/a] ⇓n ⇔∃ V. M ⇓s V & N [V/a] ⇓n.

Common rules:

λa : τ. M ⇓ λa : τ. M	Λα. M ⇓ Λα. M	!(x = M : τ ) ⇓ !(x = M : τ )
M ⇓ Λα. M'	M'[τ/α] ⇓ V M τ ⇓ V
M1 ⇓ !(x = M : τ )	M2[(let !x = !(x = M : τ ) in M )/y] ⇓ V
let !y = M1 in M2 ⇓ V
Strict evaluation, M ⇓s V , is inductively generated by the common rules plus
M1 ⇓s λa : τ. M	M2 ⇓s V	M [V/a] ⇓s V '
M1 M2 ⇓s V '
Non-strict evaluation, M ⇓n V , is inductively generated by the common rules plus
M1 ⇓n λa : τ. M	M [M2/a] ⇓n V M1 M2 ⇓n V

Fig. 3. Evaluating closed Lily terms
Hence in particular for M ∈ Term(!τ ), M ⇓n ⇔ M ⇓s.
Proof (sketch) The intuition for why the theorem holds is that if N [M/a] converges (under either semantics), then its canonical form must be a thunk of type !τ ', and this thunk must be a residual of one of the original thunks in N [M/a]. Since none of those thunks can mention a linear variable (by the typing rule for thunks), the residual thunk cannot suspend any linear ar- guments, so each linear argument within N [M/a] must have been evaluated before reaching the canonical form. Thus, when evaluating to a thunk, it makes no difference to termination behaviour whether we choose to postpone or force the evaluation of function arguments, since, in either case, the ar- guments must be evaluated before reaching the canonical form. That’s the intuition, but we found it surprisingly hard to give a formal proof. In this extended abstract we merely sketch the structure of our proof. Among the terms N having a free linear variable a, we single out those for which a occurs in a position where it will be immediately evaluated in the non-strict seman- tics. The structure of these evaluation contexts can be analysed as a nested stack F [a] = F1[F2[··· Fn[a] ·· ·]] of ‘frames’ Fi[−] of the form (− M ), (− τ ), or (let !x = − in M ). The advantage of this frame stack formulation is that it permits us to give a direct inductive definition of the non-strict termination relation F [M ] ⇓n that follows the syntactical structure of the frame stack F and the term M . Arguing by structural induction for this relation, we prove that for F [N ] of exponential type and containing a free linear variable a it is the case that
(F [N ])[M/a] ⇓n ⇒∃ V. M ⇓s V & (F [N ])[V/a] ⇓n.


(There are two subcases, proved simultaneously, according to whether a occurs in F , or in N . It is of course crucial that we are restricting attention to terms F [N ] of exponential type; for example, a base case of the induction is when F is the empty frame stack and N is in canonical form, of exponential type, and hence necessarily not involving a, rendering this case trivial.) Taking F to be the empty frame stack in the above implication, we obtain the left-to-right half of the theorem. The other half of the theorem we deduce from a result of independent interest, namely a version of the Mason-Talcott ‘ciu’ theorem [12] for Lily ground contextual equivalence. For τ ∈ Typ and M, M' ∈ Term(τ ) define ciu-equivalence, M =ciu M' : τ , to mean that for all closed frame stacks F mapping from τ to an exponential type, we have F [M ] ⇓n ⇔ F [M'] ⇓n . Then it is the case that =ciu coincides with =gnd and hence in particular is a congruence. (There are by now a number of means for establishing this kind of result; we prefer one that is an adaptation of the method of proving congruence due to Howe [9].) Using the congruence property of =ciu it is simple enough to prove
M ⇓s V ⇒ N [M/a] =ciu N [V/a]
by induction on the derivation of M ⇓s V . The right-to-left half of the theorem follows from this and the definition of =ciu.	✷
Corollary 2.4 If we take the notion of convergence at exponential type, M ⇓!, used in the definition of ground contextual equivalence (Definition 2.1) to be either M ⇓s or M ⇓n, we get the same equivalence relation on Lily terms.
Remark2.5 (‘Computational’ types) Do other types apart from expo- nentials enjoy the strictness property of Theorem 2.3? Call a type κ ‘compu- tational’ if for all τ ∈ Typ, M ∈ Term(τ ) and open terms ∅ ; a : τ ▶∅ N : κ it is the case that
N [M/a] ⇓n ⇔∃ V. M ⇓s V & N [V/a] ⇓n.
Thus the theorem says that !τ ' is computational, for any τ' ∈ Typ. Using the definitions in Fig. 1, we conjecture that all closed types in the grammar given by
κ ::= α | !τ | κ ⊗ κ | κ ⊕ κ | τ + τ | T | N⊥
|	µα. κ(α) | να. κ(α) | rec α. κ(α, α) are computational.
A Parametric Logical Relation
We are going to show that ground contextual equivalence of Lily terms, =gnd (Definition 2.1), coincides with a certain logical relation that, by construc- tion, has various extensionality and parametricity properties that we wish to establish for =gnd. The following definition gives some operations on binary relations between Lily terms that we need to achieve this.


Definition 3.1 For each closed type τ ∈ Typ, let Test (τ ) denote the set of closed linear function abstractions λa : τ. M of type τ  !τ ' for some τ' ∈ Typ. For τ, τ' ∈ Typ, define the set of term-relations to be
Rel (τ, τ') { r | r ⊆ Term(τ ) × Term(τ ') } and the set of test-relations to be
Rel ∗(τ, τ')  { s | s ⊆ Test (τ ) × Test (τ') } .
We define the following operations on term-relations and test-relations:
Given r ∈ Rel (τ, τ'), define rT ∈ Rel ∗(τ, τ') to be
rT  { (V, V ') | ∀(M, M') ∈ r. V M ⇓! ⇔ V ' M' ⇓! } .
Given s ∈ Rel ∗(τ, τ'), define sT ∈ Rel (τ, τ') to be
sT  { (M, M') | ∀(V, V ') ∈ s. V M ⇓! ⇔ V ' M' ⇓! } .
Given r1 ∈ Rel (τ1,τ' ) and r2 ∈ Rel (τ2,τ' ),
1	2
define r1   r2 ∈ Rel (τ1   τ2,τ'   τ' ) to be
1	2
r1   r2   { (M, M') | ∀(M1,M' ) ∈ r1. (M M1,M' M' ) ∈ r2 } .
1	1
Given a family (R(r) ∈ Rel (τ [σ/α],τ'[σ'/α']) | σ, σ' ∈ Typ,r ∈ Rel (σ, σ')) of term-relations, define ∀r. R(r) ∈ Rel (∀α. τ, ∀α'.τ') to be
∀r. R(r)  { (M, M') | ∀σ, σ' ∈ Typ,r ∈ Rel (σ, σ'). (M σ, M' σ') ∈ R(r) } .
Given r ∈ Rel (τ, τ'), define !r ∈ Rel (!τ, !τ ') to be
!r  { (!(x = M : τ ), !(x' = M' : τ')) | (fix x : τ. M, fix x' : τ'.M') ∈ r } .
(Fixpoint terms such as fix x : τ. M were defined in (1).)
The operation r '→ rTT derived from the above definition is a closure operation on term-relations whose fixed points r = rTT turn out to have good properties (they respect =gnd and are suitable for a syntactic version of fixpoint induction) that we exploit to get the following theorem. We omit its proof in this extended abstract, because it is quite involved; although the structure of the proof is similar to [21, Sect. 4] the details are different. 2
Theorem 3.2 (Relational parametricity for =gnd) For each Lily type τ
and each list α→ = α1,..., αn of distinct type variables containing the free
type variables of τ, we define a function from tuples of term-relations, →r =
r1,..., rn, to term-relations
r1 ∈ Rel (τ1,τ' ),..., rn ∈ Rel (τn,τ' ) '→ ∆τ (→r/α→ ) ∈ Rel (τ [→τ /α→ ],τ [→τ '/α→ '])
1	n
by induction on the structure of τ using the operations of Definition 3.1, as follows:
∆αi (→r/α→ )  ri

2 For one thing, the Strictness Theorem 2.3 is needed in several places; for another, the use of linear function abstractions rather than evaluation contexts as ‘tests’ in Definition 3.1 means we have to work harder to prove the theorem—the reward being a richer collection of TT-closed relations and hence a better ability to prove properties of =gnd.


∆τ1 τ2 (→r/α→ )  ∆τ1 (→r/α→ )  ∆τ2 (→r/α→ )
∆6α. τ (→r/α→ )  ∀r. ∆τ (→r, rTT/α→ , α)
∆!τ (→r/α→ )  (!∆τ (→r/α→ ))TT.

When τ is closed, we can take α→
and →r to be empty and get ∆τ  ∆τ (∅/∅) ∈

Rel (τ, τ ). Then for all M, M' ∈ Term(τ )
(M, M') ∈ ∆τ ⇔ M =gnd M' : τ. 
As part of the proof of the above theorem, one needs to establish the following technical property of the parametric logical relation which we state separately because it is useful in its own right.


Lemma 3.3 For each Lily type τ, with free type variables in α→ term-relation r in →r satisfies r = rTT, then so does ∆τ (→r/α→ ).
say, if each

Corollary 3.4 (Kleene equivalences) For τ ∈ Typ, write Val (τ ) for the subset of Term(τ ) consisting of the closed terms in canonical form—the terms which appear of the right-hand side of the evaluation relations in Fig. 3, namely abstractions, generalisations and recursively defined thunks (cf. Fig. 2). If M, M' ∈ Term(τ ) are Kleene equivalent, i.e. satisfy ∀V ∈ Val (τ ).M ⇓n V ⇔ M' ⇓n V , then M =gnd M' : τ. (Similarly for ⇓s.) Hence
(λa : τ. M ) N =gnd M [N/a] : τ'
(Λα. M ) σ =gnd M [σ/α] : τ [σ/α]
let !y = !(x = N : τ ) in M =gnd M [(fix x : τ. N )/y] : τ'.
Moreover, if M, M' ∈ Term(τ ) are doth divergent (say M /⇓s and M' /⇓s), then
M =gnd M' : τ.
Proof. It follows from Lemma 3.3 and the definition of (−)T that ∆τ (→r/α→ ) respects Kleene equivalence. Hence so does =gnd; and being reflexive, this implies that it also contains Kleene equivalence.	✷
Corollary 3.5 (Extensionality properties of =gnd)
M =gnd M' : τ   τ' ⇔ ∀V ∈ Val (τ ).M V =gnd M' V : τ'
M =gnd M' : ∀α. τ ⇔ ∀σ ∈ Typ.M σ =gnd M' σ : τ [σ/α]
M =gnd M' : !τ ⇔ (M /⇓! & M' /⇓!) ∨∃ x, N, x',N'.
M ⇓s !(x = N : τ ) & 
M' ⇓s !(x' = N' : τ ) & 
fix x : τ. N =gnd fix x' : τ. N' : τ
Proof. These properties follow by combining Theorem 3.2 with Lemma 3.3, the definition of ∆, and the Strictness Theorem 2.3. For example, to prove (4) first observe that
M =gnd M : τ   τ	⇔ ∀N ∈ Term(τ ).(M N, M N ) ∈ ∆τ'


holds by a standard argument for such logical relations, using the facts that
=gnd coincides with ∆ and that ∆τ  τ' = ∆τ   ∆τ' . By Lemma 3.3, ∆τ' = (∆τ' )	and so the right-hand side of equation (7) is equivalent to
∀N ∈ Term(τ ). ∀(F, F ) ∈ (∆τ' ) .F (M N) ⇓! ⇔ F (M N ) ⇓! .
By the Strictness Theorem 2.3 (and Corollary 2.4)
F (M N) ⇓! ⇔ ∃ V. N ⇓s V & F (M V ) ⇓!
and similarly for F '. Therefore (8) is equivalent to
∀V ∈ Val (τ ). ∀(F, F ) ∈ (∆τ' ) .F (M V ) ⇓! ⇔ F (M V ) ⇓!
i.e. to ∀V ∈ Val (τ ).(M V, M V ) ∈ (∆τ' )  , i.e. to ∀V ∈ Val (τ ).(M V, M V ) ∈
∆τ' . So replacing the right-hand side of equation (7) with this and applying Theorem 3.2 again, we get the desired extensionality property (4) of terms of linear function type.	✷
Corollary 3.6 Any recursively defined thunk, !(x = M : τ ) ∈ Val (!τ ), can be expressed as a non-recursive thunk (2) of a fixpoint term (1) up to ground contextual equivalence:
!(x = M : τ ) =gnd !(fix x : τ. M ) : !τ.
So in particular every element of Val (!τ ) is ground contextually equivalent to
!N for some N ∈ Term(τ ).
Proof. By the extensionality property (6) in Corollary 3.5, equation (9) holds if


where x' ∈/
fix x' : τ. fix x : τ. M =gnd fix x : τ. M : τ
fiv (fix x : τ. M ); but this does hold, by unfolding the left-hand

side using the last Kleene equivalence in Corollary 3.4:
fix x' : τ. fix x : τ. M =gnd (fix x : τ. M )[(fix x' : τ. fix x : τ. M )/x']
=	fix x : τ. M.
✷
Example 3.7 (Ground and lazy contextual equivalences differ) Con- sider the generic divergent term Ω (see equation (3)) and the generic family of divergent terms Ω':
Ω   fix x : (∀α. α).x   Ω'   Λα. fix x : α. x.
These are both closed terms of type ∀α. α. For any τ ∈ Typ it is not hard to see that Ω τ /⇓s and Ω' τ /⇓s. Hence Ω τ =gnd Ω' τ : τ , by Corollary 3.4. Therefore by the extensionality property (5) in Corollary 3.5 we have Ω  =gnd  Ω' :
∀α. α. However, these two terms are evidently not equated by lazy contextual equivalence, where one observes convergence in contexts of all types, not just
of exponential types; for Ω' is in canonical form whereas Ω diverges, so that we can observe a difference between them using the identity context. Similar examples can be given using function types and property (4) rather than using
∀-types, thus settling an open problem in [4, Sect. 7].


Remark3.8 (Relational parametricity for ∀-types) As a consequence of Theorem 3.2, terms of ∀-types enjoy relational parametricity properties mod- ulo ground contextual equivalence. For since any M ∈ Term(∀α. τ ) satisfies M =gnd M : ∀α. τ , by the theorem we have (M, M ) ∈ ∆6α. τ . Hence from Definition 3.1 we get that for any σ, σ' ∈ Typ and r ∈ Rel (σ, σ') satisfying r = rTT, it is the case that (M σ, M σ') ∈ ∆τ (r/α). Then one can use the definition of ∆τ (r/α) to infer properties of M . Of course, to use this method one needs a rich source of term-relations satisfying r = rTT. Such a source arises from the fact that the graph {(M, M') | F M =gnd M' : σ'} of any linear function F ∈ Term(σ  σ') is such a term-relation. This allows one to establish many ‘free theorems’ [28] to do with (di)naturality properties of the Lily type constructors with respect to linear functions (which play the role in this theory that strict continuous functions do in domain theory). Indeed, if we make definitions of types as in Fig. 1, the expected category-theoretic properties of these types can be established up to ground contextual equiva- lence. Example 3.9 shows this for coalesced sums; the categorical properties of the other type constructors in Fig. 1 will be treated in the full version of this paper.
Example 3.9 (Categorical coproducts) Consider the category whose ob- jects are closed Lily types, τ ∈ Typ, and whose morphisms from τ to τ' are ground contextual equivalence classes of closed Lily terms of type τ  τ'. The composition of morphisms represented by M ∈ Term(τ  τ') and M' ∈ Term(τ '  τ '') is the morphism represented by M' ◦ M ∈ Term(τ  τ ''), where
M' ◦ M   λa : τ. M' (M a).
The identity morphism for τ is represented by Idτ ∈ Term(τ   τ ), where
Idτ   λa : τ. a.
(The validity of β-conversion for ground contextual equivalence (Corollary 3.4) and the extensionality property (4) in Corollary 3.5 are needed to see that these definitions do yield a category.) For closed types τ1, τ2 ∈ Typ, we claim that
τ1 ⊕ τ2   ∀α. !(τ1   α)   !(τ2   α)   α
is the coproduct of τ1 and τ2 in this category, with coproduct injections repre- sented by Inl ∈ Term(τ1  τ1 ⊕ τ2) and Inr ∈ Term(τ2  τ1 ⊕ τ2), where
Inl   λa1 : τ1. Λα. λb1 : !(τ1   α). λb2 : !(τ2   α).
let !x1 = b1 in let !x2 = b2 in x1 a1
Inr   λa2 : τ2. Λα. λb1 : !(τ1   α). λb2 : !(τ2   α).
let !x1 = b1 in let !x2 = b2 in x2 a2.
To establish this claim, first note that given any object τ ∈ Typ and any


morphisms represented by Fi ∈ Term(τi   τ ) (i = 1, 2), then
[F1, F2]   λa : τ1 ⊕ τ2.aτ (!F1)(!F2)
represents a morphism from τ1 ⊕ τ2 to τ satisfying



 [F1, F2] ◦ Inl =gnd F1 : τ1   τ
 [F1, F2] ◦ Inr =gnd F2 : τ2   τ

(using Corollaries 3.4 and 3.5). So we just have to see that [F1, F2] is the unique such morphism. It is now that we use the relational parametricity properties of ∀-types mentioned in Remark 3.8. We can show, for any G ∈ Term(τ1 ⊕ τ2   τ ) and M ∈ Term(τ1 ⊕ τ2), that
G(M (τ1 ⊕ τ2)(!Inl )(!Inr )) =gnd M τ !(G ◦ Inl ) !(G ◦ Inr ) : τ
(where we are using the notation for non-recursive thunks introduced in equa- tion (2)). Postponing the proof of this naturality property for a moment, let us see how it yields the required uniqueness property of τ1 ⊕ τ2, namely
(G1 ◦ Inl =gnd G2 ◦ Inl : τ1   τ ) & (G1 ◦ Inr =gnd G2 ◦ Inr : τ2   τ )
⇒ (G1 =gnd G2 : τ1 ⊕ τ2   τ ).
Given any Fi ∈ Term(τi  τ ) (i = 1, 2), taking G = [F1, F2] in equation (12) and using equations (11), we get
[F1, F2](M (τ1 ⊕ τ2)(!Inl )(!Inr )) =gnd M τ (!F1) (!F2) : τ
and hence by definition of [F1, F2] (and validity of β-conversion for =gnd) (M (τ1 ⊕ τ2)(!Inl )(!Inr )) τ (!F1) (!F2) =gnd M τ (!F1) (!F2) : τ.
So for any τ ∈ Typ and Vi ∈ Val (!(τi  τ )), using Corollary 3.6 to express Vi
as !Fi for suitable (fixpoint) expressions Fi, we deduce that (M (τ1 ⊕ τ2)(!Inl )(!Inr )) τ V1 V2 =gnd M τ V1 V2 : τ.
Therefore by Corollary 3.5 we have
M =gnd M (τ1 ⊕ τ2)(!Inl )(!Inr ) : τ1 ⊕ τ2
for any M ∈ Term(τ1 ⊕ τ2). So given any G1, G2 ∈ Term(τ1 ⊕ τ2  τ ) and any V ∈ Val (τ1 ⊕ τ2), from equations (14) and (12) we get
Gi V =gnd Gi (V (τ1 ⊕ τ2)(!Inl )(!Inr )) =gnd V τ !(Gi ◦ Inl ) !(Gi ◦ Inr ) : τ. So if G1 and G2 satisfy the antecedent of equation (13), we get G1 V =gnd
G2 V  : τ for all V , and so the conclusion of equation (13) holds by Corol-
lary 3.5 (together with the congruence properties of =gnd that are inherent in its definition).
Thus the coproduct property of τ1 ⊕ τ2 is a consequence of property (12).
To prove (12), consider the term-relation
r   { (M, M') | GM =gnd M' : τ }∈ Rel (τ1 ⊕ τ2,τ ).
As in Remark 3.8, applied to the particular ∀-type that defines τ1 ⊕τ2 in (10),


each M ∈ Term(τ1 ⊕ τ2) satisfies
(M (τ1 ⊕ τ2),M τ ) ∈ (!(∆τ   r))TT   (!(∆τ   r))TT   r.
It is not hard to see that (Inl,G ◦ Inl ) ∈ ∆τ1   r and that ∆τ1   r =
TT	TT
(∆τ1   r)	(the latter because r = r	); from these facts it follows that

(!Inl, !(G ◦ Inl )) ∈ !(∆τ1
  r) and hence (!Inl, !(G ◦ Inl )) ∈ (!(∆τ1
  r))TT.

TT
Similarly, we have (!Inr, !(G ◦ Inr )) ∈ (!(∆τ2   r))	. So from (15) we get
(M (τ1 ⊕ τ2)(!Inl )(!Inr ) , M τ !(G ◦ Inl ) !(G ◦ Inr )) ∈ r
from which (12) follows by definition of r.
Remark3.10 (Defining types up to ground contextual isomorphism) Instead of making a definitional extension of Lily as in Fig. 1, one can con- sider extending the syntax and semantics of Lily with term-formers, typing and evaluation rules for tensor product, sum, product, existential, inductive, co-inductive, and recursive types. One can prove the key Theorems 2.3 and 3.2 for this extended version of Lily (and in doing so, one sees for which of the term-formers is it the case that strict and non-strict operational semantics are equivalent for =gnd: for example tensor products M ⊗ M' can be eval- uated strictly, but pairs (M, M') cannot). Then one can use the relational parametricity property mentioned in Remark 3.8 to prove the following defin- ability result for types.
We say that two types τ and τ' are ground contextually isomorphic if there are functions I ∈ Term(τ   τ') and J ∈ Term(τ '   τ ) whose compositions J ◦ I and I ◦ J are ground contextually equivalent to the identity functions for τ and τ' respectively. Then in the extended version of Lily, the new types are all definable in terms of , ∀ and ! up to ground contextual isomorphism, using the formulas on the right-hand side in Fig. 1.
Details of the proof (which is quite involved, especially when it comes to recursive types, where ideas due to Freyd [7] and Plotkin [6] are needed) will appear in the full version of this paper.

A Lazy Version of Lily
In Sect. 2, we investigated the equivalence of call-by-value and call-by-name evaluation strategies for arguments to linear functions. Nothing is gained by adopting a call-by-need (or lazy) strategy for linear function application, since a linear argument is either suspended, or evaluated exactly once. However, in the operational semantics in Fig. 3, when evaluating let !y = M1 in M2, the value of M1 is eliminated by substituting the same unfolding of its body for each occurrence of y in M2. As there is no restriction on the number of occurrences, this duplicates computations that could be shared. For Lily to merit serious consideration as an intermediate language for both strict and lazy source languages, we should provide a call-by-need operational semantics for such terms. Furthermore, to apply the results of this paper to this Lazy Lily


we must show that ground contextual equivalence is unaffected by the switch from call-by-name to call-by-need semantics.
Environments A ::= []	empty [x = M ] A	binding.
Call-by-need evaluation, ⟨M, A⟩ ↓ ⟨V, A'⟩, is inductively generated by the following rules:

⟨λa : τ. M, A⟩↓ ⟨λa : τ. M, A⟩

⟨Λα. M, A⟩↓ ⟨Λα. M, A⟩

⟨!(x = M : τ ), A⟩↓ ⟨!(x = M : τ ), A⟩
⟨M1, A1⟩↓ ⟨λa : τ. M, A2⟩	⟨M [M2/a], A2⟩↓ ⟨V, A3⟩
⟨M1 M2, A1⟩↓ ⟨V, A3⟩
⟨M, A1⟩↓ ⟨Λα. M', A2⟩	⟨M'[τ/α], A2⟩↓ ⟨V, A3⟩
⟨M τ, A1⟩↓ ⟨V, A3⟩
⟨M, A1 [x = M ] A2⟩↓ ⟨V, A3 [x = M'] A4⟩
⟨x, A1 [x = M ] A2⟩↓ ⟨V, A3 [x = V ] A4⟩

⟨M1, A1⟩↓ ⟨!(x = M : τ ), A2⟩	x = fresh(dom(A2))
⟨M2[x/y], [x = M ] A2⟩↓ ⟨V, A3⟩

⟨let !y = M1 in M2, A1⟩↓ ⟨V, A3⟩

Fig. 4. Lazy Evaluation of closed Lily terms
Fig. 4 defines an evaluation relation for Lazy Lily in the style of [11]. An environment (or heap) is an association list mapping (distinct) intuitionistic identifiers to suspended terms, similar to an explicit substitution. (The no- tation A1 [x = M ] A2 denotes the (list) concatenation of A1 and [x = M ] A2.) The lazy evaluation relation  ↓  relates configurations pairing a term and an initial environment to configurations pairing a canonical form and a final environment. The variable x is evaluated by looking up its suspended term M in the initial environment, evaluating that term in the same environment, and then returning its value V along with the final environment, updated to record the value of x. Since the environment is threaded through a derivation, the result of the first computation of M is cached and recalled in subsequent refer- ences to x: the computation is shared. Evaluating a let !y = M1 in M2 term evaluates M1 to a canonical form !(x = M : τ ), binds the body of this thunk to a fresh renaming of y (creating a cycle in the environment), and continues with the evaluation of the renamed body M2[x/y]. Assuming that the initial


configuration is closed with respect to the domain of the environment—a prop- erty that is preserved by evaluation—choosing an x that is fresh for dom(A2) avoids the capture of free variables.
Formulating the lazy semantics is easy, but proving it correct for the non- strict semantics is not. The correctness results in [11] are with respect to a denotational model. To get a more direct operational proof, we hoped to make use of the ‘small-step’ abstract machine semantics formulated by Ses- toft [26] and the operational techniques in [15] that are based on it. As it turned out, the ‘big-step’ style of [11] proved more amenable. Seaman and Iyer [25] give an operational proof of correctness for Lazy PCF using this style of operational semantics, but their semantics only shares the evaluation of function arguments, not recursive terms, whose evaluations are duplicated by unfolding (as for the call-by-name relation ⇓n in Fig. 3). Moreover, Seaman and Iyer report that they were unable to extend their proof technique to a semantics that shares evaluations of recursive terms. The problem is that sharing these computations creates cycles in the environment, violating an otherwise decreasing measure that they use in their inductive proof. Fortu- nately, we have identified a more robust measure that allows us to extend the proof technique to the setting of both Lazy Lily and Lazy PCF with shared recursion. Since linearity is not the issue, and the result for Lazy PCF is of wider interest, this result will be reported elsewhere. (The rules in Fig. 4 are very similar to those of Seaman and Iyer [25] for Lazy PCF; to cater for cycles, our variable rule evaluates the suspended term with respect to the entire envi- ronment A1 [x = M ] A2, not just the remainder A2: this is just the alternative semantics of fixpoints proposed, but not proved correct, in [25].)

Conclusion
The material presented in this paper establishes some powerful techniques and results for exploring the surprisingly great expressive power that arises from the combination of linear lambda calculus, polymorphism and recursion. In principal, one can give semantics to a wide range of programming languages via compositional translations into the Lily language, using its versions of the standard constructs of Scott-Strachey denotational semantics (Fig. 1) and using the results presented here as the basis for proofs of correctness properties of the translations. In fact Lily terms modulo ground contextual equivalence give a more refined treatment of strictness and usage properties than does the model based on domains and strict continuous functions—for lifting (−)⊥ in the latter has a contraction property that we have not built into Lily’s !- types. Accordingly, much remains to be done to explore the properties of such translations. For example, it would be interesting to explore properties of Lily versions of the semantics of Idealised Algol given by O’Hearn [17]; or of the lazy state threads of Peyton Jones and Launchbury [18] (to make computational effects implicit in translations to Lily, one could consider combining it with


the calculus of monads of Moggi [13]).

References
S. Abramsky. The lazy λ-calculus. In D. A. Turner, editor, Research Topics in Functional Programming, chapter 4, pages 65–117. Addison Wesley, 1990.
S. Abramsky. Computational interpretations of linear logic. Theoretical computer Science, 111:3–57, 1993.
A. Barber. Linear Type Theories, Semantics and Action Calculi. PhD thesis, Department of Computer Science, University of Edinburgh, 1997.
G. M. Bierman. Program equivalence in a linear functional language. J. Functional Programming, 10:167–190, 2000.
R.L. Crole. How linear is Howe? In G. McCusker, A. Edalat, and S. Jourdan, editors, Advances in Theory and Formal Methods, pages 60–72. Imperial College Press, 1996.
M. Fiore and G. D. Plotkin. An axiomatization of computationally adequate domain theoretic models of FPC. In 9th Annual Symposium on Logic in Computer Science, pages 92–102. IEEE Computer Society Press, Washington, 1994.
P. J. Freyd. Remarks on algebraically compact categories. In M. P. Fourman,
P. T. Johnstone, and A. M. Pitts, editors, Applications of Categories in Computer Science, Proceedings LMS Symposium, Durham, UK, 1991, volume 177 of LMS Lecture Note Series, pages 95–106. Cambridge University Press, 1992.
C. A. Gunter and D. S. Scott. Semantic domains. In J. van Leeuwen, editor, Handbook of Theoretical Computer Science, volume B, pages 633–674. North- Holland, 1990.
D. J. Howe. Proving congruence of bisimulation in functional programming languages. Information and Computation, 124(2):103–112, 1996.
S. B. Lassen. Relational reasoning about contexts. In A. D. Gordon and A. M. Pitts, editors, Higher Order Operational Techniques in Semantics, Publications of the Newton Institute, pages 91–135. Cambridge University Press, 1998.
J. Launchbury. A natural semantics for lazy evaluation. In 20th Symp. on Principles of Programming Languages, pages 144–154, Charleston, South Carolina, 1993. ACM.
I. A. Mason and C. L. Talcott. Equivalence in functional languages with effects.
Journal of Functional Programming, 1:287–327, 1991.
E. Moggi. Notions of computation and monads. Information and Computation, 93(1):55–92, 1991.


E. Moggi. Metalanguages and applications. In A. M. Pitts and P. Dybjer, editors, Semantics and Logics of Computation, Publications of the Newton Institute, pages 185–239. Cambridge University Press, 1997.
A. K. Moran and D. Sands. Improvement in a lazy context: An operational theory for call-by-need. In Proc. 26th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, pages 43–56. ACM Press, 1999.
P. D. Mosses. Denotational semantics. In J. van Leeuwen, editor, Handbook of Theoretical Computer Science, volume B, pages 577–632. North-Holland, 1990.
P. W. O’Hearn and J. C. Reynolds. From Algol to polymorphic linear lambda- calculus. Journal of the ACM, 47(1):167–223, 2000.
S. L Peyton Jones and J. Launchbury. State in Haskell. Lisp and Symbolic Computation, 8:293–341, 1995.
A. M. Pitts. Some notes on inductive and co-inductive techniques in the semantics of functional programs. Notes Series BRICS-NS-94-5, BRICS, Department of Computer Science, University of Aarhus, 1994.
A. M. Pitts. Existential types: Logical relations and operational equivalence. In K. G. Larsen, S. Skyum, and G. Winskel, editors, Automata, Languages and Programming, 25th International Colloquium, ICALP’98, Aalborg, Denmark, July 1998, Proceedings, volume 1443 of Lecture Notes in Computer Science, pages 309–326. Springer-Verlag, Berlin, 1998.
A.  M.  Pitts.	Parametric  polymorphism  and  operational  equivalence.
Mathematical Structures in Computer Science, 10:321–359, 2000.
G. D. Plotkin. LCF considered as a programming language. Theoretical Computer Science, 5:223–255, 1977.
G. D. Plotkin. Second order type theory and recursion. Notes for a talk at the Scott Fest, February 1993.
J. C. Reynolds. Types, abstraction and parametric polymorphism. In R. E. A. Mason, editor, Information Processing 83, pages 513–523. North-Holland, Amsterdam, 1983.
J. Seaman and S. Purushothaman Iyer. An operational semantics of sharing in lazy evaluation. Science of Computer Programming, 27(3):289–322, 1996.
P. Sestoft. Deriving a lazy abstract machine. Journal of Functional Programming, 7:231–264, 1997.
D. N. Turner and P. Wadler.	Operational interpretations of linear logic.
Theoretical Computer Science, 227:231–248, 1999.
P. Wadler. Theorems for free! In Fourth International Conference on Functional Programming Languages and Computer Architecture, London, UK, 1989.
