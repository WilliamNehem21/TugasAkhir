

Electronic Notes in Theoretical Computer Science 259 (2009) 207–223
www.elsevier.com/locate/entcs

Refining Emergent Properties
J. W. Sanders1 ,2
International Institute for Software Technology
United Nations University Macao, SAR China
Graeme Smith3
School of Information Technology and Electrical Engineering The University of Queensland
Australia

Abstract
Systems which exhibit emergent behaviour, i.e., behaviour not determined by the behaviours of the con- stituents when considered in isolation, are becoming more common due to increasing use of distributed and decentralised designs. There have been claims that formal methods, and particularly refinement, can not be used to derive systems with emergent behaviour. In this paper, however, we argue that they can. To prove the point, we perform a refinement of an oft-cited example of emergence: the ‘glider’ pattern from Conway’s Game of Life.
Keywords: Refinement, emergence, cellular automata, Game of Life.


Introduction
The ongoing decrease in size and cost of microprocessors and storage devices is lead- ing to the development of increasingly distributed and decentralised systems. Com- ponents of such systems have limited access or often no access to global information and must operate on local information gained via interaction with neighbouring components. Often these systems exhibit emergent behaviour: global behaviour that is not determined by the behaviours of the constituents when considered in isolation.

1 J. W. Sanders acknowledges financial support from the ARC Centre for Complex Systems (ACCS), Aus- tralia, and the Macao Science and Technology Development Fund under the PEARL project, grant number 041/2007/A3.
2 Email: jeff@iist.unu.edu
3 Email: smith@itee.uq.edu.au

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.12.026

Reluctance to adopt formal methods when engineering such systems has arisen partly from their similarities with complex systems. The research on complex sys- tems, however, has focussed on the modelling of existing systems (both natural and man-made, e.g., the Internet), and the prediction of their global properties. When we model an existing system, unknown discontinuities in behaviour may not be modelled, and hence proof techniques may not be successful in uncovering emer- gent behaviour. Furthermore, it is claimed that some complex systems exhibit strong emergence [1] (e.g., the mind) and therefore, by definition, proofs of how their behaviour arises cannot be constructed.
When we engineer new systems, however, we are not trying to prove the existence of emergent behaviours. Rather we start with the emergent behaviour we require (which may include the avoidance of undesirable behaviours), and develop a design which gives rise to it. To provide assurance that a design is sufficient, the emergent behaviour must be a consequence of the component interactions within the design. Hence, we are interested only in systems where that is the case, i.e., systems which exhibit weak emergence [1]. Note that many classic examples of emergence from the field of Complex Systems, such as ant foraging and bird flocking behaviours, are examples of weak emergence.
So are standard formal methods, and in particular refinement, applicable to the engineering of systems with (weak) emergent properties? Polack and Stepney [9] argue that they are not. They posit the emergent behaviour of the ‘glider’ pattern of Conway’s Game of Life 4 [6,2] as an example where refinement cannot be used.
Conway’s Game of Life is a cellular automaton which simulates the evolution of a grid of cells. The cells evolve according to the following four rules.
A live cell with less than two live neighbours dies (of isolation).
A live cell with more than three live neighbours dies (of overcrowding).
A live cell with two or three live neighbours remains a live cell.
A dead cell with exactly three live neighbours becomes a live cell.
A live cell is represented by a cell which is on and a dead cell by one that is off. The grid of cells is infinite, although this is usually represented in implementations using a finite grid arranged as a torus, or by simply having the finite grid surrounded by cells which cannot turn on.
Many different patterns can be formed in the Game of Life including dynamic patterns such as the glider which translates itself across the grid. Polack and Step- ney argue that an abstract specification of the movement of a glider cannot be refined to the rules of the Game of Life shown above. Their justification is that when an implementation exhibits emergence, the specification and implementation (and even the languages in which they are expressed) must be too disparate.
In this paper, however, we show how the abstract behaviour of the glider may be

4 An executable version can be found at http://www.bitstorm.org/gameoflife/ .

specified and subsequently refined to an array of cells following the rules of the Game of Life using the simplest possible standard refinement techniques. Our approach builds on ideas proposed in [8], elaborated in [11] and exemplified in [12].
To provide a simple illustration of our approach, we begin in Section 2 with the specification and refinement of dynamic patterns, including a glider, in a one- dimensional Game of Life. To show that in making that simplification we have not inadvertently brought together the two levels of abstraction, in Section 3 we provide a specification and refinement of the glider in the full two-dimensional Game of Life. The approach is the same, only the complexity of the detail is increased. We conclude with a discussion of related work relating to the question of refining emergent properties in Section 4.

One-dimensional Game of Life
Speciﬁcation
To describe one-dimensional patterns we consider a system whose state is a Boolean- valued function on Z . Thus at any (discrete) time t : N the state at n : Z is either true or false; we write it
x [n, t ]: B .
By abuse of notation we think of a location n : Z whose state is true as being
‘occupied’ and one whose state is false as being ‘vacant’. In preparation for the implementation to come, a location is also called a ‘cell’. Note however that imple- mentations that do not use cells are also possible: the location is just a discrete point on some plane (the minimum information needed to describe movement formally). A glider is thought of informally as a ‘cell moving right from the origin, one location per time step and starting from the origin at time 0 (but with all other
locations vacant)’. It is specified:
glider := ∀ n : Z, t : N · x [n, t ]= (n = t ) .
Implementation
The implementation we are interested in is composed of cells, one for each integer. However since the cells are updated synchronously, we consider state to be a func- tion, x : Z → B, whose value at the next time step is x ' : Z → B. The state of a cell before update is x [n] and afterwards is x '[n]. The connection to the nota- tion of Section 2.1 is that in a context where each cell has executed t consecutive transitions,
x '[n]= x [n, t + 1] .	(1)
We impose a constraint of locality: each cell’s state at the next time step, x '[n], 

is defined in terms of the current states of itself x [n] and its immediate neighbours
x [n − 1] and x [n + 1] .
A simple choice of design, conveniently expressed by (a deterministic) transition predicate, is
x '[n] = x [n − 1] ∧ ¬x [n] ∧ ¬x [n + 1] .
Thus a cell ‘appears to move one location to the right’ if in the current state it is
occupied but the next two cells to its right are vacant. There are many alternatives to this particular equation, given the specification. Reasons for each refinement step lie outside the formalism; they are typically motivated by considerations of computational efficiency and features of the target implementation language. This particular step ensures that the specification is met by a straightforward implemen- tation.
The implementation has the initial state
init := ∀ n : N · x [n] = (n = 0)
with only the cell at the origin occupied. Thereafter, at each time step all cells are updated simultaneously according to their transition equation. We express this using the following naive notation (in order to remain independent of a formalism— but it can be expressed simply in any of the usual formalisms) for the resulting one-dimensional cellular automaton


ca1 := init o
do true → ∀ n : Z · x [n] := x '[n] od .

Reﬁnement
The required refinement is
glider ± ca1
but in fact we can show equality in this simple (deterministic) case by a straight- forward induction over time as follows.
For time t =0 we have
init = glider [0/t ] .
Assuming that the glider condition holds at some time t : N
∀ m : Z · x [m, t ] = (m = t )	(2)
we wish to infer that it also holds at time t +1 . Now if n : Z and t : N are arbitrary
then
x [n, t + 1]

=	(1)
x '[n]
=	definition of transition equation
x [n — 1] л чx [n] л чx [n + 1]
=	induction hypothesis (2)
(n — 1= t ) л (n /= t ) л (n +1 /= t )
=	calculus
(n = t + 1) .
Generalising over n : Z we infer (2) with t replaced by t +1 as required.
Although it embodies the principle being made here —that the implementation is a refinement of the specification— this design is simple because it is strongly influenced by the desired invariant (which may be thought of as emergent).
We now consider two slightly more complex alternatives.

Variation 1
A ‘floater’ is a pattern in which, at time step t : N, cell x [t ] is occupied and all cells to its right are vacant; but the cells to the left of x [t ] are unconstrained:
floater := 6 n, t : N · (n ≥ t ) ⇒ x [n, t ]= (n = t ) .
The implementation is the cellular automaton with the same initial condition as
before, but transition predicate
x '[n] = x [n] /= x [n — 1]
and the proof of correctness is no more complicated than before, in view of the implication in the specification.
It is also possible to prove further emergent properties of this implementation. For example, it can be shown that after the first time step, x [0] is always vacant, x [1] is always occupied, but that x [2] alternates between being vacant and occupied:
6 t : N1 · чx [0] л x [1] л x [2] = even(t ) .
With the usual initialisation, the following alternative implementation can also
be shown to implement a floater:
x '[n] = odd (#{x [n — 1], x [n], x [n + 1]}) .

In this case, the emergent properties are quite different. From initialisation, x [0] is always occupied, and x [t — 1] alternates between being vacant and occupied:
6 t : N · x [0] л x [t — 1] = odd (t ) .
Variation 2
A k -glider, for k : N, is thought of as ‘a cell moving right one location per time step starting from the origin at time k , whose immediate neighbours are always vacant but with other locations unconstrained’. (Note that there k is a parameter.) In other words:
k -glider := 6 n : Z, t : N·
t —k —1 ≤ n ≤ t —k +1 ⇒ x [n, t ]= (n = t —k л n ≥ 0) .
Evidently a simple glider is a 0-glider.
A ‘glider gun’ is a state which periodically produces gliders. It can be specified:
∃ p : N ·6 k : N · k mod p =0 ⇒ k -glider .
This specification is nondeterministic in the period p with which gliders are pro-
duced. Note that for p = 2 it is infeasible (not enough vacant cells!) but for p ≥ 3 it is feasible.
Choosing the simplest implementation, we set

x '[n] = x [n — 1] л чx [n] л чx [n + 1]
  n /=0 D
чx [n — 1] л чx [n] л чx [n + 1] .
The condition which determines when x '[0] is occupied simplifies to чx [—1] л
чx [0] л чx [1] and hence is satisfied when each glider reaches location 2. There- fore, every third time step a glider is produced.

Two dimensions
In this section we consider the integer plane Z2 and the standard rules for the Game of Life, as given in the Introduction. The state of Game of Life consists again of a function, this time x : Z2 → Z2, whose state pointwise (or cell-wise) is written
x [m, n] and whose state pointwise after a transition is written x '[m, n].


Fig. 1. Labels for four important types of cell in the Game of Life.
The rules

The neighbourhood of a cell (m, n) : Z2 consists of (m, n) and its eight adjacent cells
N (m, n) := {(i , j ): Z2 | | m — i | < 2 л | n — j | < 2} .
The number of occupied neighbours of a cell (m, n) consists of the number of occu- pied cells in N (m, n) not including (m, n) itself
ν(m, n) := #{(i , j ) ∈ N (m, n) | (i , j ) /= (m, n) л x [i , j ]} .
Evidently 0 ≤ ν(m, n) ≤ 8.
The state of the Game of Life is a function from locations to Booleans, x : Z2 →
B, and its transition rules simplify to this:

'
x [m, n] :=  ν(m, n)= 3
V
ν(m, n)= 2 л x [m, n] .
(3)

For example, if a cell has at most one occupied neighbour then its next state is
unoccupied, regardless of its current state; similarly, if a cell has at least 4 occupied neighbours. Thus
ν(m, n) /= 2, 3 ⇒ чx '[m, n] .
A cell x [m, n] satisfying ν(m, n) /= 2, 3 we say is of type a. For the analysis of particular configurations, it is convenient to document the remaining cases by
introducing four further types of cell. Their definition is given in Figure 1 and an example appears in Figure 2.
time. If A ⊆ Z2 is the set of all occupied cells then σA consists of all cells that are We wish to think, as in one dimension, in terms of the movement of shapes with occupied after a transition:


Fig. 2. An initial configuration of the two-dimensional glider with cells labelled using the convention of Figure 1.



A0		A1











 (1,0) o 
2








 (1,−1) A0

3




Fig. 3. Relationships between glider configurations. The origin, marked as a dot, lies at the centre of each 5 × 5 array.
σA := {(m, n) | x '[m, n]} .	(4)
The iterate σk of the function σ gives the cells that are occupied after k transitions.
For example we shall see later that with these sets, depicted in Figure 3,
A0 := {(—1, 1), (0, 0), (0, —1), (1, 0), (1, 1)}	(5)
A1 := {(—1, 0), (0, —1), (1, —1), (1, 0), (1, 1)}	(6)
A2 := {(0, 1), (0, —1), (1, 0), (1, —1), (2, 0)}	(7)
A3 := {(0, —1), (1, 1), (1, —1), (2, 0), (2, —1)}	(8)
we have
σA0 = A1	(9)
σA1 = A2	(10)
σA2 = A3 .	(11)
although σA is well defined by (4), it need not have an interpretation in terms of Note that we have assumed A to be ‘the set of all occupied cells’. Otherwise,

movement in the plane. We could have chosen to impose that condition on A later, but have chosen to facilitate the physical interpretation from the start.
To express the relationship between σA3 and A0 some ‘domain-specific’ (in this case study, geometric) results are helpful.  The need arises simply because two
dimensions are a little more complicated than one.
Helpful geometric results
The function ρ that reflects the plane in the anti-diagonal through the origin is
ρ : Z2 → Z2
ρ(m, n) := (—n, —m)
and it is lifted pointwise to subsets of the plane.
For any (k , l ): Z2, the function τ(k,l) that translates the plane by (k , l ) is
τ(k,l ) : Z2 → Z2
τ(k,l )(m, n) := (m + k , n + l )
and again it is lifted pointwise to subsets of the plane.
For example we can now see pictorially, from Figure 3, how to identify σA3 (a proof is given in Theorem 3.2),
σA3 = τ(1,−1)A0	(12)
and observe two further relationships (self-evident because they do not involve state
transition) between the Ai (with ◦ for functional composition):
A2 = (τ(1,0) ◦ ρ)A0	(13)
A3 = (τ(1,0) ◦ ρ)A1 .	(14)
Useful straightforward geometric properties are as follows.
Theorem 3.1 Writing ◦ for functional composition,
τ(k 0,l 0) ◦ τ(k 1,l 1) = τ(k 0+k 1,l 0+l 1)
σ ◦ τ(k,l) = τ(k,l) ◦ σ
σ ◦ ρ = ρ ◦ σ
τ(k,l ) ◦ ρ = ρ ◦ τ(−l,−k )
(ρ ◦ ρ)(m, n)= (m, n) .
Proof.	The first property follows straight from the definition:

(τ(k 0,l 0) ◦ τ(k 1,l 1))(m, n)
=	definition, twice
(m+k 1+k 0, n+l 1+l 0)
=	arithmetic
(m+k 0+k 1, n+l 0+l 1)
=	definition
τ(k 0+k 1,l 0+l 1)(m, n) .
Since the shape of neighbourhoods, and adjacency, is translation invariant,
τ(k,l ) ◦ σ = σ ◦ τ(k,l ) ,
so the second property holds. The third property is similar.
The fourth property follows by naive calculation:
(τ(k,l ) ◦ ρ)(m, n)
=	definition of ◦ and ρ
τ(k,l )(—n, —m)
=	definition of τ
(—n+k , —m+l )
=	arithmetic
(—(n — k ), —(m — l ))
=	definition of ρ
ρ(m—l , n—k )
=	definition of τ and ◦
ρ ◦ τ(−l,−k)(m, n) .
Finally the last property is trivial.	 
Applying geometry
Let us establish the remaining results of Figure 3: Laws (9) to (12).
Theorem 3.2 Laws (9) to (12) hold.
Proof.	For Law (9) refer to Figure 2, in which cells are labelled using the a, b, c
unoccupied and so, in particular, the complement of N (0, 0) remains unoccupied. notation from Figure 1. The subsequent state of each cell labelled either a or b is Furthermore, from Figure 1 and the labels of cells interior to that array, Law (9)
follows.

Similar reasoning establishes Law (10). For Law (11),
σA2
=	Law (13)
σ ((τ(1,0) ◦ ρ)A0)
=	Theorem 1 (2),(3)
(τ(1,0) ◦ ρ)(σA0)
=	Law (9)
(τ(1,0) ◦ ρ)A1
=	Law (14)
A3 .
Finally, Law (12) is roughly similar
σA3
=	Law (14)
σ((τ(1,0) ◦ ρ)A1)
=	Theorem 1 (2),(3)
(τ(1,0) ◦ ρ)(σA1)
=	Law (10)
(τ(1,0) ◦ ρ)A2
=	Law (13)
(τ(1,0) ◦ ρ)((τ(1,0) ◦ ρ)A0)
=	definition of ◦
(τ(1,0) ◦ ρ ◦ τ(1,0) ◦ ρ))A0
=	Theorem 1 (4)
(τ(1,0) ◦ ρ ◦ ρ ◦ τ(0,−1)))A0
=	Theorem 1 (5)
(τ(1,0) ◦ τ(0,−1)))A0
=	Theorem 1 (1)
τ(1,−1)A0 .
 

Headings
Following the approach of Section 2, for (m, n): Z2 we let
x [m, n, t ]: B
denote the state of a cell at time t : N.
We use time t to specify desired behaviour, but use cells updated by transition rules (i.e., cellular automata) for implementations. Refinement reasoning leads us from one to the other. The following notation suffices to describe the simple temporal behaviours we are concerned with here.
A rectangle in the plane is a Cartesian product of two finite intervals [m0, n0) and [m1, n1):
[m0, n0) × [m1, n1) = {(i , j ): Z2 | m0 ≤ i < m1 л n0 ≤ j < n1} .
A subset B of the plane is said to be bounded iff it is contained in some rectangle.
If B ⊆ Z2 is bounded then rect (B ) denotes the smallest rectangle containing
B . A containing rectangle exists because B is bounded, and the smallest one exists because the set of all rectangles containing any set is closed under intersection.
For example from their definitions (5) to (8) we see
rect (A0) = rect (A1) = N (0, 0) = [—1, 2) × [—1, 2)
rect (A2) = rect (A3) = N (1, 0) = [0, 3) × [—1, 2) .
Also, from the definition of τ we have
rect (τ(1,−1)A0) = N (1, —1) = [0, 3) × [—2, 1)
and so infer a property that is useful for our refinement in Section 3.6:
A1 ∪ A2 ∪ A3 ⊆ rect (A0 ∪ τ(1,−1)A0) = [—1, 3) × [—2, 2) .	(15)
A bounded subset A (of occupied cells) is said to have heading h(n, k , l ), where n : N and k , l : Z, iff for each t : N, after nt time steps A has ‘moved’ by vector (kt , lt ), and moreover at intermediate times u ∈ (nt , n(t + 1)), σu A lies within the smallest rectangle containing σnt A and σn(t+1)A:
σnt A = τ(kt,lt )A	(16)
nt < u < n(t + 1) ⇒ σu A ⊆ rect (σnt A ∪ σn(t+1)A) .	(17) In that case we write A ∈ h(n, k , l ).
This definition is important because (16) relates the n-fold transition (on the
left) to a simple translation (on the right). As a result, the union on the right of
(17) can also be rewritten as a union of translations. Typically n is the (finite) period of the finite state machine formed by A, in which case it suffices to replace that implication in (17) by its special case t = 0.

For example if the (one-dimensional) simple glider were to be embedded in the integer plane via the natural identification of the integers with
{(n, 0) : Z2 | n ∈ Z}
h(1, 1, 0). The usual glider of the Game of Life (whose first four steps are given then the simple glider (but with one-dimensional rules) would have heading in Figure 3 and to which we come next) is stationary every second time step, and
h(4, 1, 1). Evidently such a glider can be rotated to produce gliders with the other when it moves does so alternatively (say) right and down; it thus has heading three diagonal headings of ‘magnitude’ 4.
Not all headings are feasible for the Game of Life whose rules ensure that a cell cannot move further than one position each time step. (That does not hold for variants in which, for example, the next state of a cell depends on the current states
of cells more distant than its immediate neighbours.) For example h(1, 2, 2) is not feasible. A necessary condition for h(n, k , l ) to be feasible is that
|k /n|, |l /n| ≤ 1 .
Sufficiency is more subtle; for instance h(1, 1, 1) does not seem possible for a 3 × 3 set A.

Two-dimensional gliders
In two dimensions, shapes that move diagonally are called ‘gliders’ (compared, for example, with ‘spaceships’ which move orthogonally [2], page 821). Our specifica- tion of a glider is a little more abstract than its implementation, because of the actual—at first sight, slightly erratic—stepwise behaviour of the implementation. However we follow the methodology of Section 2 to reach an implementation by refinement.
A (two-dimensional) glider is defined to consist of a subset A of N (0, 0) with a positive number of occupied cells and heading h(4, 1, —1):
⎛ { } ⊂ A ⊆ N (0, 0) ⎞

glider (A) :=
⎝ A ∈ h(4, 1, —1)
⎠ .	(18)

The definition allows A, σ1A, σ2A and σ3A to have different numbers of occupied cells, provided they lie within the rectangle rect (A ∪ σ4A).

Reﬁnement
We seek an implementation that is a Z2 cellular automaton in which each cell obeys the transition rules of the Game of Life, (3). As in the one-dimensional case we

represent the implementation with an initial condition
init := 6(m, n): Z2 · x [m, n]= ((m, n) ∈ A0) ,
where A0 is given by (5), and an initialised loop that updates all cells synchronously


ca2 := init o
do true → 6(m, n): Z2 · x [m, n] := x '[m, n] od .

Our top-down refinement begins with simple calculus:
glider (A)
=	Definition (18)
⎛ { } ⊂ A ⊆ N (0, 0) ⎞
⎝ A ∈ h(4, 1, —1)	⎠
=	Definitions (16, 17)
⎛ { } ⊂ A ⊆ N (0, 0)	⎞
⎜	⎛ σ4t A = τ	A	⎞ ⎟

⎜⎝ 6 t : N · ⎝
(t,−t )
4t < u < 4(t + 1) ⇒ σu A ⊆ rect (σ4t A ∪ σ4(t+1)A)
⎠ ⎟⎠

⇐	calculus, with Definition (5)
⎛ A = A0	⎞
⎜	⎛ σ4t A = τ	A	⎞ ⎟

⎜⎝ 6 t : N · ⎝
(t,−t )
4t < u < 4(t + 1) ⇒ σu A ⊆ rect (σ4t A ∪ σ4(t+1)A)
⎠ ⎟⎠

=	calculus (noting that (σ4t A = τ(t ,−t )A0)[0/t ] is A = A0)
⎛ σ4t A = τ(t,−t )A0	⎞
6 i : {1, 2, 3} ·  σ4t+i A ⊆ rect (σ4t A0 ∪ σ4(t+1)A0) ⎠
=	calculus
⎛ σ4t A = τ(t,−t )A0	⎞
6 i : {1, 2, 3} · σ4t+i A ⊆ rect (τ(t,−t)A0 ∪ τ(t+1,−(t+1))A0) ⎠
⇐	calculus, with Definition (15)
⎛ σ4t A = τ(t,−t )A0	⎞
6 i : {1, 2, 3} · σ4t+i A = τ(t,−t )Ai ⎠
=	calculus

6 t : N · σt A = τ(t div 4,−t div 4) At mod 4 .
The remainder of the refinement is performed as an induction over time as in
the one-dimensional case. When t = 0, the invariant above simplifies to
A = A0 .
For the inductive case, we argue with the invariant in the following equivalent
form to reflect the four cases of i = t mod 4:
σ4t +i A0 = τ(t,−t ) Ai .	(19)
Assuming (19) with arbitrary t and i , for the case t +1 we have
σ4(t +1)+i A0
=	calculus
σ4 ◦ σ4t +i A0
=	induction hypothesis (19)
σ4 ◦ τ(t,−t )Ai
=	Theorem 1 (2)
τ(t,−t ) ◦ σ4Ai
=	Laws (9) to (12)
τ(t,−t ) ◦ τ(1,−1)Ai
=	Theorem 1 (1)
τ(t +1,−(t +1))Ai
as required for (19) with substitution of t +1 for t .
Conclusion
Polack and Stepney [9] are not the only authors to have claimed that it is not possible to do what we have done. In the multi-agent systems field, Zambonelli and Omicini [15] as well as De Wolf and Holvoet [4] make similar claims based on arguments of Wegner [13]. Wegner, using G¨odel’s incompleteness theorem, argues that models of interactive systems are necessarily incomplete and therefore that proofs of the nonexistence of incorrect behaviour are generally impossible. The argument, however, applies equally to single-component reactive systems as it does to multi-agent systems. Hence, this is not a new problem, and has not precluded the successful use of formal methods for reactive systems.
Edmonds and Bryson [5] have also argued that formal methods, and in particular refinement, are not relevant to multi-agent systems. Their argument is based on the undecidability of the refinement process. This does not preclude refinement,

however, only its automation. Again their argument applies to systems other than multi-agent systems to which formal methods have been applied.
Finally, Bedau [1] defines weak emergence as global behaviour that can be de- rived from the states and interactions of the components of a system “but only by simulation.” Does simulation occur in our development? Only in part of the proof of Laws (9) and (10); the other laws are established by geometric reasoning. It is important to note that even in proving (9) and (10), we have done something more
abstract than simulation: for example most cells in the complement of N (0, 0) are reasoned about in the same way; and those within it are divided into classes to ab-
breviate the reasoning (Figure 1). Simulation proceeds by brute-force application of the rules; our reasoning does little more than apply their definition.
Our development (refinement) has been leisurely; the essential points fit com- fortably on one page. We have been careful to establish every property just in order to explore what exactly is required if a systematic (rather than simulation-based) approach is taken. The fact that we have succeeded is not surprising because of the way that ‘emergent functionality’ of a loop can be reasoned about using a loop invariant and so does not require simulation of the loop. That, in fact, is the basis of the approach taken here. It works because the cellular automaton can be expressed as a loop, and its emergent behaviour reasoned about using the loop invariant.
By making time explicit in the specification, it is possible to describe emer- gent behaviour which is not expressible at the level of abstraction of the unilateral behaviour of the cells (which does not include time).
How does this extend to other systems with emergent behaviour? Gruner [7] has shown that generalised cellular automata (GCA) where cells may have differing numbers of neighbours, and more states than just on and off, can be used to model mobile agent systems. While our current approach could be extended for GCA, we could also look to the wealth of experience, and formal techniques, for systolic algorithms [10]. A systolic algorithm relies on steadily-moving data being at the right place at the right time. Hence, such techniques could inform an approach to the temporal behaviour of GCA.
Also, Cucker and Smale [3] have recently provided a mathematical proof for the emergence of bird flocking behaviour, and we have presented a refinement of the emergent self-organising behaviour of an algorithm for modular robots [12]. These developments indicate that refinement is indeed more widely applicable to systems with emergent behaviour.

References
M. A. Bedau. Downward causation and autonomy in weak emergence. Principia, 6:5–50, 2003.
E. R. Berlekamp, J. H. Conway and R. K. Guy. Winning Ways for your Mathematical Plays, volume 2,
Games in Particular. Academic Press, London, 1982.
F. Cucker and S. Smale. On the mathematics of emergence. Japanese Journal of Mathematics, 2:197– 227, 2007.

T. De Wolf and T. Holvoet. Towards a methodology for engineering self-organising emergent systems. In
H. Czap, R. Unland, C. Branki and H. Tianfield, editors, Self-Organization and Autonomic Informatics (I), volume 135 of Frontiers in Artificial Intelligence and Applications. IOS Press, 2005.
B. Edmonds and J. Bryson. The insufficiency of formal design methods—The necessity of an experimental approach for the understanding and control of complex MAS. In International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS’04), 938–945. IEEE Computer Society, 2004.
M. Gardner. Mathematical games: The fantastic combinations of John Conway’s new solitaire game “life”. Scientific American, 223:120–123, 1970.
S. Gruner. Mobile agent systems and cellular automata. Autonomous Agent Multi-Agent Systems, Online First. Springer-Verlag, 2009.
http://www.springerlink.com/content/c3m2m85p3h678825/fulltext.pdf

J. Hu, Z. Liu, G. M. Reed and J. W. Sanders. Ensemble engineering and emergence. In [14], 162–178, 2008.
F. Polack and S. Stepney. Emergent properties do not refine. Electronic Notes in Theoretical Computer Science, 137:163–181, 2005.
P. Quinton and Y. Robert. Systolic Algorithms and Architectures. Prentice-Hall, 1990.
J. W. Sanders and G. Smith. Formal ensemble engineering. In [14], 132–138, 2008.
G. Smith and J. W. Sanders. Formal development of self-organising systems. In J. Gonz´alez Nieto,
W. Reif, G. Wang and J. Indulska, editors, International Conference on Autonomic and Trusted Computing (ATC-09), volume 5586 of LNCS, 90–104. Springer-Verlag, 2009.
P. Wegner. Why interaction is more powerful than algorithms. Communications of the ACM, 40(5):80– 91, 1997.
M. Wirsing, J.-P. Banˆatre, M. H¨olzl and A. Rauschmayer, editors, Software-Intensive Systems and New Computing Paradigms: Challenges and Visions, volume 5380 of LNCS. Springer Verlag, 2008.
F. Zambonelli and A. Omicini. Challenges and research directions in agent-oriented software engineering.
Autonomous Agents and Multi-Agent Systems, 9(3):253–283, 2004.
