Electronic Notes in Theoretical Computer Science 72 (2007) 17–29	
www.elsevier.com/locate/entcs

Lifting Infinite Normal Form Definitions From Term Rewriting to Term Graph Rewriting
Stefan Blom1
CWI
Amsterdam, The Netherlands

Abstract
Infinite normal forms are a way of giving semantics to non-terminating rewrite systems. The notion is a generalization of the B¨ohm tree in the lambda calculus. It was first introduced in [2] to provide semantics for a lambda calculus on terms with letrec. In that paper infinite normal forms were defined directly on the graph rewrite system. In [5] the framework was improved by defining the infinite normal form of a term graph using the infinite normal form on terms. This approach of lifting the definition makes the non- confluence problems introduced into term graph rewriting by substitution rules much easier to deal with. In this paper, we give a simplified presentation of the latter approach.
Keywords: Term rewriting, normal form, term graph rewriting, Bh¨m tree, lambda calculus


Introduction
A simple way of representing term graphs is to use the letrec syntax. By using this syntax, we can derive term graph rewrite systems from term rewrite systems. For example, from the β-rule in the lambda calculus
(λx.M ) N −→β  M [x := N ] ,

we can derive

(λx.M ) N	−−β→◦  letrec x = N in M ;

(1)
letrec x = M, D in C[x] −−e→s
letrec x = M, D in C[M ] ;

(letrec D in M ) N	−−→ letrec D in (M N ) .
(See [4] for details on exactly how this rewrite system may be derived.) We will refer to these derived systems as cyclic extensions.

1 Email: sccblom@cwi.nl

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2002.09.003

The B¨ohm tree and the L´evy-Longo tree are nice notions of semantics for the lambda calculus. It is easy to extend the theory of these trees to the simple cyclic extension given above. In [3] these notions were generalized to the notion of infinite normal form and two more complicated cyclic extensions and L´evy-Longo trees for them were studied as examples. These examples proved to be quite complicated, because the cyclic extensions each included forms of the substitution rules
letrec x = M, D in C[x]	−−e→s letrec x = M, D in C[M ] ; letrec x = M, y = C[x],D in N −→ letrec x = M, y = C[M ],D in N ; letrec x = C[x],D in N	−−c→s letrec x = C[C[x]],D in N .
The problem is that with these three rules the rewrite system is no longer confluent. The classical example is:
letrec x = F (x) in x	es	letrec x = F (x) in F (x)
cs	cs
letrec x = F (F (x)) in x	letrec x = F (F (x)) in F (x)
The two terms at the bottom do not have a common reduct. (Every reduct of the left term has an even number of F symbols, every reduct of the right term an odd number.)
The non-confluence causes a number of technical problems. Unfortunately, the way in which infinite normal forms were defined in [2,3] means that for every different infinite normal form that is defined, one has to deal with these problems all over. In [5] an improved framework was given in which the substitution related problems are separated from the rewrite system related problems. This separation is achieved by relating the infinite normal form of a term graph to the infinite normal form of the unwinding of the term graph. The price for the separation is that we have to assume that the infinite normal form of a graph is the infinite normal form of the unwinding of that graph. In the context of modeling programming languages, this means that the letrec cannot be used to model sharing sensitive side-effects such as assignment. However, one can first model the sharing sensitive side-effects in a non-recursive setting and then use the letrec to add recursion.
Overview. After the preliminaries, we will define the notion of infinite normal form. In the next section, we extend rewrite relations and infinite normal forms from terms to graphs. Using these extensions, we then identify a class of term graph rewrite systems for which we define extensions of infinite normal forms from terms to term graphs.

Preliminaries
The set of terms T is given by:
T ::= x | λx.T | F (T , ··· , T ) ,

where x ranges over a set of variables and F ranges over a set of function symbols including the constant Ω and the binary symbol @. We write st for @(s, t). Com- binatory Reduction Systems (see [8]) are defined on terms with a single binding operator, so one may think of a CRS whenever we mention a rewrite system on terms.
We define the partial order ≤Ω on terms as the least transitive, reflexive, com- patible relation such that ∀s ∈ T :Ω ≤Ω s. That is, a term s is smaller than a term t if s can be obtained from t by replacing sub-terms with Ω.
We define the downward closure of a set S as:
↓ S = {s ∈ T | ∃s' ∈ S : s ≤Ω s'} .
The set of possibly infinite terms T ∞ is the ideal completion of (T , ≤Ω). That is, a term S ∈ T ∞ is a subset of T , such that
S =↓ S and ∀s, t ∈ S : ∃u ∈ S : s ≤Ω u ∧ t ≤Ω u .
The set of terms is embedded in the set of infinite terms by means of the map
s '→ ↓{s} .
We define the set of cyclic terms T ◦ as:
T ◦ ::= x | λx.T ◦ | F (T ◦, ··· , T ◦) | letrec D in T ◦ ;
D  ::= x1 = T ◦, ··· , xn = T ◦ .
Given a rewrite system (T , −→), we denote the reflexive closure of −→ by −→≡, the transitive reflexive closure by −→ and the transitive, reflexive and symmetric closure by ←−→. We say that −→ is monotonic if
∀s, s',t : s −→ t ∧ s ≤Ω s' =⇒ ∃t' : s' −→ t' ∧ t ≤Ω t' .
Not every CRS is monotonic. For example, if we have the η-rule for the lambda calculus, we have λx.(Ω y) x −→η Ω y, but λx.(x y) x contains no η-redex. The prob- lem is that the η-rule requires that a variable does not occur in a sub-term. By expanding an Ω we introduced an occurrence of a variable that destroyed the redex. To get monotonicity we therefore need rewrite rules in which no non-occurrence requirements are used. Such rewrite rules are called fully-extended in [7].

Infinite Normal Forms
In this section, we give a simple presentation of the notion of infinite normal form. This notion is an abstract version of the Bo¨hm tree definition of L´evy (See [9]). A first version of the notion of infinite normal form is presented in [2,3]. The theory was extended in [5]. In these papers the theory is presented on the level of abstract reduction systems. To keep matters simple, we restrict our presentation to a subset of the theory in [5] and we present the theory on the level of lambda terms.
The idea behind the notion of infinite normal form is that the result of an infinite computation is an infinite term, which is built piece-by-piece during the computation. For example, the Bo¨hm tree of (λx.λy.y (x x)) (λx.λy.y (x x)) is the

limit of the bold parts of the terms in the following reduction of the term: (λx.λy.y (x x)) (λx.λy.y (x x))
−→β λy.y ( (λx.λy.y (x x)) (λx.λy.y (x x)) )
−→β λy.y λy.y ( (λx.λy.y (x x)) (λx.λy.y (x x)) )
.
λy.y λy.y λy.y (·· ·)
If more than one computation is possible then the results over all possible reductions are gathered. The key to formalizing the notion is the approximation function. This function computes the information content of a term, which is the prefix of the eventual infinite term that has already been computed. The infinite normal form of a term is then defined as the set of all prefixes that can be computed by reducing the term. Uniqueness is an important property of the infinite normal form: it states that any two convertible terms have the same infinite normal form. Uniqueness implies that if a term is reduced then any prefix, which may be computed form a term, can also be computed from the reduct. Formally:
Definition 3.1 Given T x ∈ {T , T ∞, T ◦} and a rewrite system (T x, −→), we say that a function ω : T x → T ∞ is an approximation function if
∀s, t ∈ T x : s −→ t =⇒ ω(s) ⊆ ω(t) .
Given an approximation function ω : T x → T ∞, we define the inﬁnite normal form
of a term as:
−→
Infω (s)= ∪{ω(t) | s−→t} .
We say that infinite normal forms are unique if
∀s : Infω(s) ∈ T ∞ and ∀s, t : s ←−→ t : Infω(s)= Infω(t) .
The superscript −→ is sometimes omitted if it is clear which relation is meant. Due to the natural orders on terms (≤Ω) and sets (⊆), we can talk about mono- tonicity of approximation function and infinite normal forms.
Example 3.2 The prefix, which is important for the Bo¨hm Tree is the head normal form. Thus, it seems natural to define the B¨ohm Tree information content of a term
as:


ωBT
= ⎧⎨ λx1 ··· xn.x ωBT(s1) ··· ωBT(sm), if s ≡ λx1 ··· xn.x s1 ··· sm
⎩ Ω	, otherwise

To show that this function is an approximation function, we use the fact that ωBT(s) is the normal form of s with respect to the following rewrite rules:
(λx.M ) N −−ω−B−→T Ω ; λx.Ω   −−ω−B−→T Ω ; Ω M	−−ω−B−→T  Ω .

We also define −−→Ω  by
∀M ∈ T : Ω −−→Ω M .
Note that M ≤Ω N if and only if M −−→Ω→N .
By a simple case distinction, we can show that the following diagram holds:
Ω


ωBT	ωBT

Ω
From the diagram and the fact that −−ω−B−→T ⊂−−→Ω , we conclude that ωBT is monotonic with respect to ≤Ω. If C[(λx.M ) N ] −→β  C[M [x := N ]] then C[(λx.M ) N ] −−ω−B−→T C[Ω]. Hence , we have
ΩBT(C[(λx.M ) N ]) = ΩBT(C[Ω]) ≤Ω ΩBT(C[M [x := N ]]) .
The conclusion is that ΩBT is an approximation function.
The following theorem formally states three important facts: confluence implies uniqueness of infinite normal forms, monotonicity of the approximation function and the rewrite relation implies monotonicity of infinite normal forms and if infinite normal forms are unique then they are infinite terms:
Theorem 3.3 Given T x ∈ {T , T ∞, T ◦}, a rewrite system R ≡ (T x, −→) and an approximation function ω.
If R is confluent then Infω inﬁnite normal forms are unique.
If −→ and ω are monotonic then Infω is monotonic.
If Infω inﬁnite normal forms are unique then ∀s ∈ T x : Infω(s) ∈ T ∞.
Proof.
Given s ←−→ t and a ∈ Infω(s). We can find s', such that s−→s' and a ∈ ω(s'). By confluence we can find t', such that s'−→s' and t−→t'. Because ω is an approximation function, we have ω(s') ⊆ ω(t'). Thus, we have:
a ∈ ω(s') ⊆ ω(t') ⊆ Infω(t) .
Given s ≤ Ωt and a ∈ Infω(s). We can find s', such that s−→s' and a ∈ ω(s'). Due to monotonicity of −→ we can find t', such that t−→t' and s' ≤Ω t'. Due to monotonicity of ω, we have ω(s') ⊆ ω(t'). Thus, we have:
a ∈ ω(s') ⊆ ω(t') ⊆ Infω(t) .
For any term ∀s ∈ T x, we must show that the set Infω(s) is an ideal:
Given a ∈ Infω(s) and a' ≤ Ωa. We can find t, such that s−→t and a ∈ ω(t). Because ω(t) is downward closed by definition, we have a' ∈ ω(t) and hence a' ∈ Infω(s).
Given a1, a2 ∈ Infω(s), we can find t, such that s−→t and a1 ∈ ω(t). Because of uniqueness, Infω(s)= Infω(t), so we can find t', such that t−→t' and a2 ∈ ω(t').

Because ω is an approximation function, we also have that a1 ∈ ω(t'). Because ω(t'), we can then find a3 ∈ ω(t'), such that a1 ≤Ω a3 ∧ a2 ≤Ω a3. We also have that a3 ∈ Infω(s).

Both uniqueness and monotonicity are used in the extensions of infinite normal forms from terms to graphs. If all of these properties hold then we talk about a regular rewriting system with approximations:
Definition 3.4 A Regular Rewriting System with Approximations (RRSA) is a structure (T , −→, ω), where (T , −→) is a rewrite system, −→ is monotonic and ω is a monotonic approximation function, such that Infω is unique and monotonic.
Not all of these properties are needed for every stage in the development of infinite normal forms for infinite terms and term graphs, but having all of them simplifies the presentation.
Below, we define the unwinding of a term graph as an infinite normal form of the rewrite system (T ◦, −−→). Because the unwinding is important in the remainder, we use a different notation for the infinite normal form:

Definition 3.5 Given the rewrite system (T ◦, −−→). Let nfω
normal form of M with respect to the rewrite rule

unw
(M ) denote the

letrec x1 = M1, ··· , xn = Mn in M −−ω−u−n→w  M [x1 := Ω, ··· , xn := Ω]
The function ωunw : T ◦ → T ∞ is defined by ωunw(M ) =↓ {nfω	(M )}. The unwinding of a term M is given by:
−−e→s
Unw(M )= Infωunw (M ) .
We use M =unw N as shorthand for Unw(M ) = Unw(N ). It is easy to verify that nfωunw is an approximation function. Because −−e→s is confluent it is also easy to prove that Unw is a unique infinite normal form by applying Thm. 3.3.

Infinitary Extension
One of the motivations to study infinitary rewriting is to give the semantics of graph rewriting by means of infinitary rewriting. For this purpose Corradini defined a rewriting system on infinite terms that performs a complete development of an infinite set of redexes in one step [6]. We use a liberal extension of his definition to express the requirements under which we can extend an infinite normal form definition from term rewriting to graph rewriting. Our extension lifts any rewrite relation from terms to infinite terms, by stating that S rewrites to T if every term in S can be extended to another term in S, which in turn rewrites to a term in T . Moreover, every term in T is the prefix of a term in T , which can be obtained by rewriting a term in S. Corradini’s definition extends only a specific relation and requires that every prefix of S rewrites to a prefix of T . Formally:

Definition 4.1 The rewrite extension operator [·⟩ : 2T ×T → 2T ∞×T ∞ is given by
∀S, T ∈ T ∞, →⊆ T × T :

S[−→⟩T ⇐⇒
∀s ∈ S : ∃s' ∈ S, t' ∈ T : s ≤Ω s' ∧ s' → t'

⎩ ∧ ∀t ∈ T : ∃s' ∈ S, t' ∈ T : s' → t' ∧ t ≤Ω t'
The transitive reflexive closure of [·⟩ is [·⟩⟩. Note that if a ‘spanning’ subset of
S rewrites to a ‘spanning’ subset of T , we have that S rewrites to T :
Proposition 4.2 Given S, T ∈ T ∞, →⊆ 2T ×T , an index set I and si, ti ∈ T such that si → ti for i ∈ I.
S =↓ {si | i ∈ I} and T =↓ {ti | i ∈ I} =⇒ S[→⟩T .
This simple observation is very useful for showing that an infinite term rewrites to another infinite term. The following example illustrates a few possibilities of the [·⟩ operator:
Example 4.3 Let us consider the TRS
A(X) −→ X	B(X) −→ X .
We use the following notation:
A0(x)= x;	B0(x)= x;	AB0(x)= x;
An+1(x)= A(An(x)); Bn+1(x)= B(Bn(x)); ABn+1(x)= A(B(ABn(x)));
Aω = {An | n ∈ N};	Bω = {Bn | n ∈ N};	ABω = ↓{ABn | n ∈ N}.
We then have:
A(B(ABω))[−→⟩A(ABω), because A(B(ABn(Ω)) −→ A(ABn(Ω))  ;
ABω[−→⟩Aω, because ABn(Ω)−→An(Ω) ;
Aω[−→⟩Ω, because An(Ω)−→Ω ;
ABω[−→⟩Bω[−→⟩Ω .
One may ask the question if confluence of −→ implies confluence of [−→⟩. The answer is no, one will have to impose some restrictions. For example, with the confluent rule


we get both
A(A(X)) −→2 X

Aω[−→⟩Ω and Aω[−→⟩A(Ω) .

2	2
The [·⟩ operator extends a rewrite relation form terms to infinite term. If on the terms, we have an infinite normal form Infω defined then we want to extend the infinite normal form to infinite terms as well. The simplest way to do this is to extend the function Infω. Because infinite terms are sets of terms and the co-domain of Infω is sets of terms already, we only extend the domain:
Definition 4.4 Given a RRSA (T , −→, ω), the direct extension of Infω is defined as:
Inf∞(S)= ∪{Infω(s) | s ∈ S} .

The direct extension is a proper extension in the sense that for finite terms Infω
and Inf∞ yield the same result:
Proposition 4.5 Given a RRSA (T , −→, ω), we have that:
∀t ∈ T : Infω(t)= Inf∞(↓ {t}) .
Proof. We distinguish two cases:
”⊆”: Follows from the fact that t ∈↓ {t}.
”⊇”: From monotonicity if follows that for every s ∈↓ {t}, we have that
Infω(s) ⊆ Infω(t) .

Hence, we have that

Inf∞(↓ {t}) ⊆ Infω(t) .


The direct extension is also unique in the following sense:
Proposition 4.6 Given a RRSA (T , −→, ω), we have that:
∀S, T ∈ T ∞ : S[−→⟩T =⇒ Inf∞(S)= Inf∞(T ) .
ω	ω
Proof. We distinguish two cases:
”⊆”:	Given s ∈ S, we can find s' ∈ S, t' ∈ T , such that s ≤ s' and s'−→t'. By monotonicity and uniqueness respectively we then have that
Infω(s) ⊆ Infω(s') and Infω(s')= Infω(t') .
From these two statements and the definition of Inf∞ we can derive that
Inf∞(S) ⊆ Inf∞(T ) .
ω	ω
”⊇”: Similar to the previous case.

Although the direct extension has the right properties (see the previous two propositions), it isn’t satisfactory in the sense that it is not defined by means of an approximation function. Nevertheless, we need it to prove that the approximation function for infinite terms, we will define next, yields unique infinite normal forms.
Definition 4.7 Given a RRSA (T , −→, ω), we define the derived extension of Infω
with respect to ⇒= ⊆ T × T as:
ω∞(S) =↓ {ω(s) | s ∈ S}

=⇒
Infω∞
(S) = ∪{ω∞(T ) | S[=⇒⟩⟩T }

We want to prove that the direct extension is equal to the derived extension. To do so, we need to lift a reduction on terms to a reduction on infinite terms. This is possible for monotone reduction relations:
Lemma 4.8 Given a rewrite system (T , →). If → is monotone then
∀s, t ∈ T ,S ∈ T ∞ : s → t ∧ s ∈ S =⇒ ∃T ∈ T ∞ : S[→⟩T ∧ t ∈ T .

Proof. Given s, t ∈ T ,S ∈ T ∞, such that s → t and s ∈ S. Because S is a countable set and an ideal, we can find a sequence
s ≡ s0 ≤Ω s1 ≤Ω ··· , such that S =↓ {si | i ≥ 0} .
Because → is monotonic we can find a sequence ti, such that si → ti and ti ≤Ω ti+1. We then have that
S [→⟩ ↓{ti | i ≥ 0} .

With this lemma, we can prove the equality of the two extensions:
Theorem 4.9 Given a RRSA (T , −→, ω), we have that
∀S ∈ T ∞Inf∞(S)= Inf−→ (S) .
ω	ω∞
Proof. We distinguish two cases:
−→
”⊇”: Given a ∈ Infω∞ (S). According to Def. 4.7 we can find a sequence
S ≡ S0[−→⟩S1[−→⟩ ··· Sn, such that ∃sn ∈ Sn : a ∈ ω(sn) .
From a ∈ ω(sn) we get that a ∈ Infω(sn). By applying Def. 4.1 we can find

sn−1 ∈ Sn−1, s'
∈ Sn, such that sn ≤Ω s'
and s'
←−− sn−1. By monotonicity

and uniqueness we have that Infω(sn) ⊆ Infω(s' ) and Infω(s' )= Infω(sn−1), so
n	n
Infω(sn) ⊆ Infω(sn−1). By repeating this argument we can find s0 ∈ S0 such that
Infω(sn) ⊆ Infω(s0). We conclude that
a ∈ Infω(sn) ⊆ Infω(s0) ⊆ Inf∞(S0) .
”⊆”: Given a ∈ Inf∞(S). We can find an s ∈ S such that a ∈ Infω(s). Hence, we can find t ∈ T , such that s−→t and a ∈ ω(t). By repeatedly applying Lemma 4.8, we can find T ∈ T ∞, such that t ∈ T and S [−→⟩⟩ T . Because [−→⟩ ⊆ [−→⟩ and a ∈ ω(t) ⊆ ω∞(T ), we have
−→
a ∈ Infω∞ (S) .

A very easy corollary of this theorem is that the derived infinite normal form is unique.
−→
Corollary 4.10 Given a RRSA (T , −→, ω), we have that Infω∞  inﬁnite normal
forms are unique.

Cyclic Extension
A cyclic extension of a rewrite system on terms is nothing but a rewrite system on cyclic terms that has somehow been derived from the rewrite system on terms. For the purpose of this paper it is not important how this derivation was done. Only the properties of the derivation matter. The most important property is infinitary soundness, which says that any reduction on cyclic terms can be projected to a reduction on the unwindings of the terms:

Definition 5.1 A cyclic extension (T ◦, −−−→◦ ) of a rewrite system (T , −−→) is infini-

tarily sound if
R	R

∀M, N : M −−R−→◦  N =⇒ Unw(M )[−−→R→⟩Unw(N ) .

One way of deriving a cyclic extension is to begin with modifying the right-hand sides of the given rewrite rules to use letrecs for substitutions. Next, rewrite rules that do not modify the unwinding may be added. Finally, some completion must be done. The simple cyclic extension of the lambda calculus in the introduction (1) was derived in this way. If a cyclic extension of an orthogonal CRS is derived in this way then the following theorem, which was proven in [5], might be useful to show infinitary soundness:
Theorem 5.2 Given a cyclic extension R◦ ≡ (T ◦, −−−→◦ ) of an orthogonal CRS
(T , −−→R ). If −−R−→◦ ⊆=unw ∪(=unw ◦ −−→R  ◦ =unw) then the cyclic extension is inﬁnitarily sound.
Through the unwinding of a cyclic term, we can give a direct extension of an infinite normal form from terms to cyclic terms:
Definition 5.3 Given a RRSA (T , −−→, ω) and a cyclic extension (T ◦, −−−→◦ ), we
R	R
define the direct extension of Infω as
Inf◦ (M )= Inf∞(Unw(M )) .
ω	ω
This extension is unique in the following sense:
Proposition 5.4 Given a RRSA (T , −−→R , ω) and an inﬁnitarily sound cyclic exten- sion (T ◦, −−−→◦ ), we have
R
∀M, N ∈ T ◦ : M −−−→ N =⇒ Inf◦(M )= Inf◦(N ) .
Proof. Follows from infinitary soundness and Prop. 4.6.	 
A derived extension is also possible:
Definition 5.5 Given a RRSA (T , −−→R , ω) and an infinitarily sound cyclic extension (T ◦, −−−→◦ ), the derived extension of Infω is defined by the approximation function
ω◦(M ) =↓ {ω(s) | s ∈ Unw(M )} .
To prove that the derived extension is equal to the direct extension and hence unique, we will need a notion of completeness. The perfect situation would be that if an approximation s of the unwinding of a cyclic term M rewrites to a term t then M rewrites to a cyclic term N such that t is an approximation of the unwinding of
N . However, we cannot expect this due to the fact that a rewrite step on a cyclic term often corresponds to more than one step on an approximation. The matter of completeness is discussed in depth in [5]. In this paper, we merely present the solution.
Definition 5.6 Given a RRSA (T , −−→, ω). A cyclic extension (T ◦, −−−→◦ ) is complete

up to information content if ∀s, t ∈
R
T ,M 
R
∈ T ◦:

s ∈ Unw(M ) ∧ s−−→t =⇒ ∃N ∈ T ◦, t' ∈ Unw(N ): M −−−→N ∧ ω(t) ⊆ ω(t').
R	R◦

We can make the notion of completeness stronger by replacing ω(t) ⊆ ω(t') with t−−→t'. The resulting stronger notion is usually easier to prove, but it doesn’t always hold and the weak notion is sufficient to imply that the derived and direct infinite normal forms are the same.
Definition 5.7 Given a RRSA (T , −−→, ω). A cyclic extension (T ◦, −−−→◦ ) is regular
R	R
if it is infinitarily sound and complete up to information content.
Theorem 5.8 Given a RRSA R≡ (T , −−→, ω) and a regular cyclic extension (T ◦, −−−→◦

), we have that
R	R

∀M ∈ T ◦ : Infω◦ (M )= Inf◦ (M ) .

Proof. We distinguish two cases:
”⊆”:	From infinitary soundness it follows that Infω◦ (M ) ⊆ Infω∞ (Unw(M )). Hence, by Thm. 4.9 it follows that
Infω◦ (M ) ⊆ Inf◦ (M ) .
”⊇”:  Given a ∈ Inf◦ (M ). By definition Inf◦ (M )= Inf∞(Unw(M )) = ∪{Inf(s) |
ω	ω	ω
s ∈ Unw(M )}, so we can find s ∈ Unw(M ) such that a ∈ Infω(s). Thus, we can
also find t ∈ T such that s−−→R→t and a ∈ ω(t). Due to completeness, we can find
an N ∈ T ◦, t' ∈ Unw(N ) such that M −−−→◦ N and ω(t) ⊆ ω(t'). Hence:
a ∈ ω(t) ⊆ ω(t') ⊆ ω◦(N ) ⊆ Infω◦ (M ) .

Uniqueness of the derived infinite normal form is an easy corollary of this theo- rem.
Corollary 5.9 Given a RRSA R ≡ (T , −−→R , ω) and a regular cyclic extension
(T ◦, −−−→◦ ), we have that Infω◦ inﬁnite normal forms are unique.

Syntactic continuity and congruence relations.
This section gives a brief sketch of how congruence results can be lifted from term rewriting to cyclic term rewriting. Due to space limitations the full details cannot be included here. They can be found in [5].
To prove that Inf(M ) = Inf(N ) =⇒ Inf(C[M ]) = Inf(C[N ]) L´evy used the notion of syntactic continuity. Syntactic continuity expresses that to compute the infinite normal form of a context filled with a term , everything you need to know about that term is contained in the infinite normal form of that term:
Definition 5.10 Given a rewrite system (T , −−→R ) and an approximation function
ω : T → T ∞, we have syntactic continuity of Infω if
Infω(C[s]) = ∪{Infω(C[a]) | a ∈ Infω(s)} .
To extend congruence results from terms to cyclic terms, we will also need the notion of substitutive continuity, which expresses that to compute the infinite normal

form of a substitution applied to a term, everything you need to know about that term is contained in the infinite normal form of that term:
Definition 5.11 Given a rewrite system (T , −−→R ) and an approximation function
ω : T → T ∞, we have substitutive continuity of Infω if
Infω(sσ)= ∪{Infω(aσ) | a ∈ Infω(s)} .
Note that, if the β-rule is present substitutive continuity follows immediately from syntactic continuity due to the fact that
Infω(s[x1 := t1, ··· , xn := tn]) = Infω(C[s]) ,
where C ≡ (λx1 ··· xn.  ) t1 ··· tn .
Given substitutive and syntactic continuity of a suitable CRS, we can prove that any regular cyclic extension has syntactic continuity:
Theorem 5.12 Given a RRSA (T , −−→R , ω), where (T , −−→R ) is a fully-extended or-
thogonal CRS, and a regular cyclic extension (T ◦, −−−→◦ ), we have that syntactic and
R	◦
substitutive continuity of Infω imply syntactic continuity of Infω.
Conclusion
We have presented a framework for lifting infinite normal form definitions from term rewrite systems to term graph rewrite systems. The non-confluence problems, which had to be dealt with for proving uniqueness of infinite normal forms in [1] are now dealt with in a proof of infinitary soundness. The advantage is that in a proof of infinitary soundness we can use known results about rewrite rules that preserve the unwinding of a term. The framework does not supersede the notion of skew confluence ([1]). This notion is still useful to prove results about rewrite rules that preserve the unwinding of a term.
Acknowledgments We thank Vincent van Oostrom for his help on Combinatory Reduction Systems and Jaco van de Pol for proof reading this paper.

References
Abadi, M. and T. Ito, editors, “Theoretical Aspects of Computer Software,” Lecture Notes in Computer Science 1281, Springer Verlag, 1997.
Ariola, Z. M. and S. Blom, Cyclic lambda calculi, in: Abadi and Ito [1], pp. 77–106.
Ariola, Z. M. and S. Blom, Skew confluence and the lambda calculus with letrec, Annals of Pure and Applied Logic 117 (2002), pp. 95–168.
URL
http://www.sciencedirect.com/science/article/B6TYB-45V6X48-3/1/44088914c39bfba322cebd6e8cf7ffae
Ariola, Z. M. and J. W. Klop, Lambda calculus with explicit recursion, Information and computation
139 (1997), pp. 154–233.
Blom, S., “Term Graph Rewriting - syntax and semantics,” Ph.D. thesis, Vrije Universiteit Amsterdam (2001).
Corradini, A., Term rewriting in ctσ , in: Proc. CAAP ’93, Lecture Notes in Computer Science 668
(1993), pp. 468–484.

Hanus, M. and C. Prehofer, Higher-order narrowing with definitional trees, in: H. Ganzinger, editor,
RTA, Lecture Notes in Computer Science 1103 (1996), pp. 138–152.
Klop, J. W., V. van Oostrom and F. van Raamsdonk, Combinatory reduction systems: Introduction and survey, Theoretical Computer Science 121 (1993), pp. 279–308, a Collection of Contributions in Honour of Corrado B¨ohm on the Occasion of his 70th Birthday, guest eds. M. Dezani-Ciancaglini, S. Ronchi Della Rocca and M. Venturini-Zilli.
L´evy, J.-J., “R´eductions Correctes et Optimales dans le Lambda-Calcul,” Ph.D. thesis, Universite Paris VII (1978).
