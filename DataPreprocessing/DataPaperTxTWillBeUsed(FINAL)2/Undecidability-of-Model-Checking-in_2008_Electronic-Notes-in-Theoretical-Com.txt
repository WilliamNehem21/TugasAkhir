

Electronic Notes in Theoretical Computer Science 192 (2008) 23–37
www.elsevier.com/locate/entcs

Undecidability of Model Checking in Brane Logic
Giorgio Baccia and Marino Miculana,1
a Department of Mathematics and Computer Science, University of Udine, Italy

Abstract
The Brane Calculus is a calculus intended to model the structure and the dynamics of biological membranes. In order to express properties of systems in this calculus, in previous work we have introduced a temporal- spatial logic called Brane Logic. A natural question of great practical importance is if model checking of this logic is decidable, that is, if it is possible to check automatically whether a given system satisfies a given formula. We have already shown that model checking is decidable for replication-free systems and guarantee-free formulas. In this paper, we show that admitting replication in systems, or any guarantee constructor in formulas (and quantifiers), leads model checking to be undecidable. Moreover, we give also a correspondence result between membranes and systems, showing that any system can be obtained by a canonical one where all information are contained on a membrane enclosing an empty compartment.
Keywords: Biological and bio-inspired computation, brane calculus, spatial logics.


Introduction
The Brane Calculus [3] is a calculus of mobile nested processes intended to model the dynamics of biological membranes. At this level of abstraction, a biological sys- tem is seen as a hierarchy of compartments, which can interact by changing their position. A process of Brane Calculus represents a system of nested membranes; the evolution of a process corresponds to membrane interactions (phagocytosis, endo/exocytosis, . . . ). Differently from similar spatial calculi (notably, Mobile Am- bients and BioAmbients), in Brane Calculus the computational activity takes place on membranes, not inside them. Moreover, reactions preserve bitonality, that is, the even/odd parity with which components are nested inside membranes; as a con- sequence, fluids from inside and outside a membrane never actually mix (but can be safely “wrapped” in other membranes). This property is commonly observed in cellular-scale living systems, but not ensured in not biologically inspired calculi.

1 Email: miculan@dimi.uniud.it

1571-0661© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.10.025

In previous work [10] we have introduced the Brane Logic, a modal logic designed for expressing properties about systems described using the Brane Calculus. Like Ambient Logic, our logic features spatial and temporal modalities for expressing properties about the topology and the dynamic behaviour of nested systems. How- ever, differently from Ambient Logic, we have also a logic for expressing properties of membranes themselves. Membranes are more similar to CCS than to Ambients; as a consequence, the logic for membranes is similar to Hennessy-Milner logic [8], extended with spatial connectives as in [2]. These spatial connectives are useful for expressing properties about a system when it is put in a particular context, i.e., inside a membrane or close to another system. A particularly expressive form of spatial constructors are the “guarantees”, e.g., “A D B” means “whenever the system comes close to another one satisfying A, the whole system satisfies B.” Its importance in biological applications should be evident (think, e.g., of A as being a virus, and B of evolving to a virus-free system).
Now, a problem of great importance is whether model checking is decidable for this logic. In [10], we have presented a model checking algorithm for a guarantee-free fragment of the logic against replication-free systems. In this paper, first we show that model checking of guarantee-free formulas against systems with replication is undecidable. Then, we show that also admitting any guarantee constructor in formulas (and in presence of quantifiers), leads model checking to be undecidable. We give also a correspondence result between membranes and systems, showing that any system with arbitrarily nested compartments can be obtained by a canonical one composed by an empty compartment enclosed by a membrane carrying all the information.
Summary of Brane Calculus and Brane Logic
Brane Calculus In this paper we focus on the basic version of Brane Calculus with- out communication primitives and molecular complexes. For a description of the intuitive meaning of the language and the reduction rules, we refer the reader to [3].
Syntax of (Basic) Brane Calculus Systems Π :	P, Q ::=  | σ  P  | P  Q |!P Membranes Σ :		σ, τ ::= 0 | σ|τ | a.σ |!σ
Actions Ξ :	a, b ::= n |  n(σ) | n |  n | (σ)

where n is taken from a countable set Λ of names. We will write a, P  and σ  , instead of a.0, 0P  and σ  , respectively. The set of free names of a system P , of a membrane σ and of an action a, denoted by FN(P ), FN(σ), FN(a) respectively, are defined as usual; notice that in this syntax there are no binders.
Systems can be rearranged according to a structural congruence relation (≡); the intended meaning is that two congruent terms actually denote the same “semantic” system.

Structural Congruence

With respect to the structural congruence of [3], we have added the possibility of rearranging the sub-membranes contained in co-phago and pino actions (last three rules of the table above). Decidability of structural congruence can be proved as for Mobile Ambients [5] (actually our situation is simpler because we do not have restriction on names). In particular, in the structural congruence of membranes, co-phago and pino actions can be treated as “ambient-like” constructors, since they “embed” a membrane within another.
The dynamic behaviour of Brane Calculus is specified by means of a reduction relation (“reaction”) between systems P  Q, whose rules are the following:
Operational Semantics
n(ρ).τ |τ0  Q  n.σ|σ0  P τ |τ0  ρσ|σ0  P   Q	(React phago)

P  Q
σ P	σ Q
P  Q
P	R	Q	R
(React loc, React comp)

P ≡ P '	P '  Q'	Q' ≡ Q
(React equiv)



We denote by ∗ the usual reflexive and transitive closure of .
As in [3], the Mate-Bud-Drip calculus is easily encoded, as follows:
Derived membrane constructors and reaction
Mate : maten.σ  n.n' .σ	maten.τ	n( n' .n'' ). n'' .τ
maten.σ|σ0  P   mate.τ |τ0  Q ∗ σ|σ0|τ |τ0  P  Q
Bud : budn.σ  n.σ	budn(ρ).τ  ( n(ρ).n' ).  n' .τ
bud (ρ).τ |τ0  budn.σ|σ0  P   Q ∗ ρσ|σ0  P   τ |τ0  Q
Drip : dripn.(ρ).σ  (  (ρ).n). n.σ
drip (ρ).σ|σ0  P  ∗ ρ  σ|σ0  P 

Instead of using this encoding, in the following, we consider mate, bud and drip

actions as atomic actions to be appended to the Phago-Exo-Pino calculus. Notice that, due to this choice, we will use  instead of ∗ in mate, bud and drip reac- tions, and we will not explicitly deal with the freshness of auxiliary names used in the encoding.
Brane Logic has been introduced in [10] for expressing properties of systems in Brane Calculus. Notice that the actions take place on membranes, not only in systems. Thus, there are actually two spatial logics, interacting with each other: one for reasoning about membranes (called membrane logic) and one for reasoning about systems (the system logic).
The syntax of the Brane Logic is the following:
Syntax of Brane Logic
System formulas Φ
A, B ::= T | ¬A|A ∨ B	(classical propositional fragment)
 |M A | A@M (void system, compartment, compartment adjoint)
A  B | A D B	(spatial composition, composition adjoint)
A| A	(eventually modality, somewhere modality)
∀x.A	(quantification over names)
Membrane formulas Ω
M, N ::= T | ¬M|M ∨ N (classical propositional fragment)
0	(void membrane)
M|N | M ► N	(spatial composition, composition adjoint)
αM	(action modality)
Action formulas Θ


Given a formula A, its free names FN(A) are easily defined, since there are no binders for names. Similarly, we can define the set of free variables FV(A), noticing that the only binder for variables is the universal quantifier. As usual, a formula A is closed if FV(A)= ∅. For sake of simplicity, we will use the shorthands M and α in place of M and α0 respectively.
For an intuitive explanation of these logical constructors, see [10].
The meaning of a formula is defined by means of a family of satisfaction relations, one for each syntactic sort of logical formulas 2
▶⊆ Π × Φ	▶⊆ Σ × Ω	▶⊆ Ξ × Θ

2 We use the same symbol ▶ for the three relations, since it is easily distinguishable from the context.

These relations are defined by (mutual) induction on the syntax of the formulas. Let us start with satisfaction of system formulas. First, we have to introduce the subsystem relation P ↓ Q (read “Q is an immediate subsystem of P ”):
P ↓ Q  ∃ '	≡ σ  Q|P '
We denote by ↓∗ the reflexive-transitive closure of ↓.
Satisfaction of System Formulas
∀P :Π	P ▶ T
∀P : Π, A :Φ	P ▶ ¬A	  P $ A
∀P : Π, A, B :Φ	P ▶ A∨B   P ▶ A∨ P ▶ B
∀P :Π	P ▶ 	 P ≡ 
∀P : Π, A : Φ, M :Ω P ▶ MA  ∃P ' : Π,σ : Σ.P ≡ σ  P '  ∧ P ' ▶ A∧ σ ▶ M
∀P : Π, A, B :Φ	P ▶ A  B	  ∃P ',P '' : Π.P ≡ P '  P '' ∧ P ' ▶ A∧ P '' ▶ B
∀P : Π, A : Φ,x : ϑ	P ▶ ∀x.A	  ∀m : Λ.P ▶ A{x ← m}
∀P : Π, A :Φ	P ▶ A	  ∃P ' : Π.P ∗ P ' ∧ P ' ▶ A
∀P : Π, A :Φ	P ▶ A	  ∃P ' : Π.P ↓∗ P ' ∧ P ' ▶ A
∀P : Π, A : Φ, M :Ω P ▶ A@M  ∀σ : Σ.σ ▶ M⇒ σ  P  ▶ A
∀P : Π, A, B :Φ	P ▶ A D B  ∀P ' : Π.P ' ▶ A⇒ P  P ' ▶ B

This definition relies on the satisfaction of membrane formulas, which we define next.
Satisfaction of membrane formulas
∀σ :Σ	σ ▶ T
∀σ : Σ, M :Ω	σ ▶ ¬M	  σ $ M
∀σ : Σ, M, N :Ω	σ ▶ M∨N  σ ▶ M∨ σ ▶ M
∀σ :Σ	σ ▶ 0	  σ ≡ 0
∀σ : Σ, N , M :Ω	σ ▶ M|N	  ∃σ', σ'' : Σ.σ ≡ σ'|σ'' ∧ σ' ▶ M∧ σ'' ▶ N
∀σ : Σ,α :Θ	σ ▶ αM	  ∃σ', σ'' : Σ.∃a : Γ.σ ≡ (a.σ')|σ'' ∧ a ▶ α ∧
σ'|σ'' ▶ M
∀σ : Σ, M, N :Ω	σ ▶ M ► N  ∀σ' : Σ.σ' ▶ M⇒ σ|σ' ▶ N

In particular, the truth of the action modality αM is defined using satisfaction of action formulas a ▶ M, which we have to define next.
Satisfaction of action formulas
∀a : Γ,n :Λ	a ▶ n	  a = n
∀a : Γ,n : Λ, M :Ω	a ▶	n(M)   ∃σ : Σ.a =	n(σ) ∧ σ ▶ M
∀a : Γ,n :Λ	a ▶ n	  a = n
∀a : Γ,n :Λ	a ▶	n	 a =	n
∀a : Γ, M :Ω	a ▶ (M)   ∃σ : Σ.a = (σ) ∧ σ ▶ M
Notice that the satisfaction of action formulas is defined in terms of the satisfaction of membrane formulas, therefore these are two mutually defined judgments.

In a given membrane or system, even if infinite, only a finite number of names can appear, because Brane Calculus processes cannot create fresh names (differently from, e.g., π-calculus). As a consequence, for instance, some formulas quantifying over all possible names cannot be satisfied (e.g., ∀x.xT is satisfied by systems which can perform a phago on all possible names, which is clearly impossible). However, this kind of formulas may become satisfiable in future extensions of the Brane Calculus, incorporating the possibility of generating fresh names (as it is already possible in Beta-binders [15]).
Undecidability of satisfaction in presence of replica- tion
Using the approach of [4] we show that if the processes have unbound replication either on the membranes or on the systems, model checking for the Brane Calculus against the Brane Logic is undecidable. In fact, the fragment of the logic needed for this result is very restricted: it contains only propositional connectives, tempo- ral and spatial modalities and the compartment connective. There is no need of quantifiers or adjoint connectives.
The undecidability proof is done by a reduction of the Post Correspondence
∗
Problem (PCP). In the following we use α, β, γ for words in {a, b} , σ for letters
in {a, b} and ϵ for the empty word. An instance of PCP is a set of pairs of words
∗
{(α1, β1),..., (αn, βn)} over the two-letter alphabet {a, b} (that is, αi, βi ∈ {a, b} ).
The question is whether there exists a sequence i0, i1,..., ik (1 ≤ ij ≤ n for all 0 ≤ j ≤ k) such that αi0 · ...· αik = βi0 · ...· βik , where · denotes word concatenation. It is well known that PCP is undecidable [13].
The idea of the reduction is to construct for a given instance of PCP a system PCP whose reductions simulates all possible concatenations of pairs of words in the instance. Then we have only to check if a system representing two equal words is reachable. This approach is used both for showing the undecidability in the case of replication on systems, and in the case of replication on membranes. To discriminate the two distinct cases we define PCPS for systems (where we admit replication only on systems); PCPm for membranes (where we admit replication only on membranes).
Replication on systems
The system PCPS is defined as the composition
PCPS  matestart  Word1(ϵ)  Word2(ϵ)  End  Concatenate  Compare
where Wordi(γ) is a system representing the word γ.
Before giving the definition of the entire system, we briefly describe the lead- ing idea. Concatenate is the system responsible for concatenating pairs of words from the given instance of PCP: a pair (αi, βi) is nondeterministically choosen and Word1(α)  Word2(β) is rewritten to Word1(αi · α)  Word2(βi · β); this is done

again and again. Compare is the system deputed to check if the two words rep- resented by Word1 and Word2 are equal. This is done by nondeterministically choosing the letter a or b and trying to delete it simultaneously from both words; this is repeated until both words are empty or they starts with a different letter. In this way, an instance of PCP has a solution if and only if there exists a (nonempty) execution of PCPS that ends with the representation of two empty words.
Word1 and Word2 are enveloped in a “protective” membrane designed to per- mit only a kind of manipulation per time, i.e. Compare could enter and work on the words if and only if Concatenate has terminated is job and viceversa. This membrane is also used for synchronization during the concatenation process. End is the system responsible for the final step of all jobs: it waits for a signal (in the form of a small membrane) from the manipulator system, then recreates the protective membrane giving it the capability to accept the new manipulation.
Given an instance {(α1, β1),..., (αn, βn)}, then Concatenate is defined as fol- lows
Concatenate  !Concatenate(α1, β1)  ... !Concatenate(αn, βn)
where Concatenate(αi, βi) is one of the infinite replications which performs the concatenation: one (and only one) Concatenate(αi, βi) enters the protective mem- brane and then do the requested concatenation. Actually, the following property holds

mate
Word (α)  Word (β)  End  Concatenate(α ,β )	∗

start	1	2	i	i
matestart  Word1(αi · α)  Word2(βi · β)  End
Intuitively, a string γ = σ1 ... σk in {a, b}∗ is represented by an ordered nesting of membranes such that each membrane shows an action labelled with the character σi. In order to distinguish Word1 from Word2 we envelope the strings-encoding in a membrane “labelled” with a fresh such as wi.
Definition of Wordi(γ) Wordi(γ)		matewi String(γ) String(ϵ)		mateop 
String(σα)		mateop  mateσ  String(α)

Notice that, since the strings are represented as a nested structure, if we want to concatenate two words we need to insert the fist string into the other. For this reason we include in the encoding the ability to attach actions on strings, therefore, a string could be programmed by a process to move into another string: this is the task of the membrane mateop  ....

Definition of Concatenate(α, β)
Concatenate(α, β)		matestart. start 
matew . Patch(α)  String'(α, Signal (αR)
1	w1	'	1
R
matew2 . w2 Patch(β)	String (β, Signal2(β  )
Patch(γ)		mateop.MoveIn(γ)
MoveIn(ϵ)		mateop.0
MoveIn(σα)		σ.MoveIn(α)
String'(ϵ, P)		P

String'(σα, P)	 
(mate
make).  op
mate
make.
String'(α, P)

Signali(ϵ)		wi .matewi matesi 
Signali(σα)		σ.mateσ  op.mateop  Signali(α)


Concatenate(αi, βi) enters the protective membrane that envelops the two words, and leads the strings in Word1 and Word2 respectively inside αi and βi, which are the instances of PCP it carries. Each concatenation takes place in two dis- tinct membranes (the two membranes that cover and give the name to the words), so that each activity is disjunct from the other. Patch “programs” the string in Word attaching a list of actions (MoveIn) that forces it to enter String'. String' differs from the previously given encoding of a string: it is defined such that it will become a string (in the sense of our encoding) only after the string concatenation process is done. To make possible this transformation only after the concatenation process is finished, we have defined String' with an auxiliary process Signal in it, that reconstructs the right encoding and releases a signal to End.
Definition of End
End	!(mates1 .mates2 .start.matestart  )

End waits for the signal from the two concatenation processes and, only if both correctly terminate, it recomposes the original state of the protective external mem- brane, in order to recreate the initial conditions that permits a new concatenation process.
The comparison is carried out by the process Compare Compare   !Consume(a)!Consume(b)
Consume(σ) is the system which deletes the first character both in Word1(α) and Word2(β) if α = σα' and β = σβ', otherwise terminates. Consume(σ) is defined such that the following property holds
matestart  Word1(σα)  Word2(σβ)  End  Consume(σ)	∗
matestart  Word1(α)  Word2(β)  End

Definition of Consume(σ)
Consume(σ)		matestart. start 
matew1 . w1  DelChar(σ, Signal1)
matew2 . w2  DelChar(σ, Signal2)
DelChar(σ, P)		mateop. op. exit  mateσ . σ. exit  Patch  Del  P Patch		mateop.del.mateop 

Consume enters the external protective membrane, and works separately on the two words. DelChar attacks the encoding of the string, enters the first two membranes (i.e. the two membrane that represent the first character) releasing three subprocess: Patch, Del and Signal. Patch attaches on the surface of the substring (i.e., the string without the first character) the actions that force it to enter Del, which moves the substring out of the membrane representing the first character. Now the substring and the first character are separated. Finally Signal exits from what remains of the double compartment (the first character) and from the membrane that covers the whole word; then, it releases to End the signal that the character has been completely cancelled. It is interesting to note that Signal also dissolves the double compartment, thus deleting what remains of the first character. If End receives both signals from the two deletion processes (i.e. the comparison is successful), it restores the original state of the protective membrane.
We have the following theorem:
Theorem 3.1 The model checking problem for Brane Calculi with replication on systems against the Brane Logic is undecidable.
Proof. Let PCPS the system defined above (note that the definition of PCPS depends on the instance of PCP). We have already seen that the instance has a solution if and only if there exists an execution of PCPS starting with the concate- nation of at least one pair and ending in a configuration representing the pair of empty words. This can be represented by the formula
A   (nonempty(w1) ∧ (empty(w1) ∧ empty(w2)))
where
nonempty(wi)   matewi mateop mateaT ∨ matebT
empty(wi)  matewi mateop 
Here wi is a name used in the encoding of the process Wordi(γ), and the formula mateop mateaT ∨ matebT is matched by (the encoding of) the first letter in the word γ. It is easy to check that, for systems obtained from the translation PCPS, it is nonempty(wi) ⇐⇒ ¬empty(wi).

Then, PCPS ▶ A if and only if the instance of PCP has a solution.	 

Replication on membranes
For the case of replication on membranes, we do not directly define the system PCPm as done for the case of replication on systems, but we will reduce its definition to the definition of PCPS. In fact, we show that given any system P , there exists a single empty “bubble” σ  , with the correct membrane, which reduces exactly to P . This allows to reduce the model checking for membranes to that for systems.
This special membrane, which we denote by Generateφ(P ) where φ :Π → Λ is an injective labeling function from systems to names, can be generated by induction on the structure of P , as follows:
Definition of Generateφ(P )
Endoφ()		0

Endoφ
(τ Q)		0	if Q ≡ 
drip(φ(τ Q).Generateφ(Q))	otherwise

Endoφ(P  Q)		Endoφ(P )|Endoφ(Q)
Endoφ(, σ)		σ

Endoφ
(τ Q, σ)		(τ ).σ	if Q ≡ 
φ(τ Q )(τ ).σ	otherwise

Endoφ(P  Q, σ)		Endoφ(P, Endoφ(Q, σ))


The special capabilities of this membrane is due to the following property:
Proposition 3.2 Let P a replication-free system and φ : Π → (Λ \ FN(P )) an injective labeling function, then:
Generateφ(P ) ∗ P;
Generateφ(!P ) ∗ Generateφ(!P )  P.
The first part of this proposition can be easily proved by induction on the struc- ture of P . Note that the labeling function φ uses only names not in FN(P ) so that the generation process does not influence the evolution of the system P .
The second part of Proposition 3.2 can be seen as a variant of the equivalence
!P ≡!P  P . Indeed, using this result we can replace replication on systems with replication on membrane, since Generateφ(!P ) = !Generateφ(P ) (the substitu- tion must be done only using labeling functions φ that does not use names in FN(P )).

Bacci, miculan
G. Bacci, M. Miculan / Electronic Notes in Theoretical Computer Science 192 (2008) 23–37	33
1

4
P =	
5  2
10
Endo (2 ... , Endo (3 ... , 1))
m(2).  n(3).1

9	3
7
6



m.Generate(4 ...	5 ... )
n.Generate(6	7 )

Endo (2 ... , Endo (3 ... ,1)) Generate(P)

drip
Endo(2 ...)
Endo(3 ... )

phago
2	1


















1






P

Fig. 1. Generate(P ) reduces to P (m, n are names not in FN(P ))

The fact that any system of the Brane Calculus can be generated from a single membrane enclosing an empty compartment, is due to the expressive power of the endo-actions: phago and pino actions carry a “membrane patch” which will become a nested membrane in the reaction, modifying at the same time the tree structure of the system. See Fig. 1 for an example of generation.

Note that a Generate-like membrane could also be defined using only (well-
)nested pino actions and drip actions, without using phago (so without use a labeling function φ). However this is not easy to define by induction on systems, so we prefer the previous one.
Using Proposition 3.2(ii), in the definition of system PCPm we can replace on systems with replication on membrane. So the following result holds, in virtue of Theorem 3.1.
Theorem 3.3 The model checking problem for Brane Calculi with replication on membranes against the Brane Logic is undecidable.

Undecidability in presence of guarantee and quanti- fiers
In this section we consider the problem of model checking the finite state Brane Calculus (i.e., without replication) against formulas that may contain guarantee and quantifiers. As observed in [10] the logic with guarantee can express the satisfiability of a formula via the AF operator, defined as AF  A D F; it is easy to check that P ▶ ¬(AF) if and only if A is satisfiable. Therefore, the model checking problem subsumes the satisfiability problem of formulas: if we can decide P ▶ ¬(AF) then we can decide whether A is satisfiable. We will show now that the satisfiability problem for brane formulas (even without guarantee) is an undecidable problem; this is obtained by reducing to it the finite-model problem for first-order logic. As a consequence, also model checking is undecidable.
Let us consider the set FO of first-order formulas defined on a countable set of variables x, y, z, . . . and some relational symbols {R1, R2,..., Rk}, each having strictly positive arity. Formulas from FO are interpreted over structures; a structure S over some domain D is simply a set containing objects of the form Ri(a1,..., an) where Ri is an n-ary relational symbol and a1,..., an are elements of D. We say that a structure S is ﬁnite whenever its domain D is finite. For first-order formula ϕ and a structure S with domain D, a valuation σ is a mapping from the free variables of ϕ to D. A structure S is a model for a formula ϕ under a valuation σ if S,σ ▶ ϕ (defined as usual). Then, it is undecidable to know whether a given first-order formula ϕ has a finite model [17].
We use this result to prove that satisfiability on Brane Logic with guarantee and quantifiers is undecidable. We give a translation ·) of FOL in the logic for Brane Calculus; thus, we prove that a first-order formula ϕ admits a finite model if and only if there exists a Brane Calculus system P (without replication) that satisfies
 ϕ) in the Brane Logic.
 Ri(x1,..., xk))		ri  x1  x2  ... xk  ...  T

This encoding identifies first-order variables with Brane Logic variables. Let us consider the semantics: if S is a model for ∃x.ϕ, the first-order quantificator ranges over the domain D of the structure but, in the encoding ∃x. ϕ), the Brane Logic quantificator ranges over a countable set of names. This imply that the encoding is correct only if we consider first-order semantical structure with countable domains. In the following we consider only finite structure, so the encoding is correct.
The key idea of this encoding is to think the composition of Brane Calculus as a (multi-)set constructor. Then, the finite domain D, as well as the structure S are encoded in a straightforward way using simply action names d for elements of D and action names ri for relational symbols Ri in S. We now define the relation ~Sys between finite structures and brane processes without replication. For a system P and structure S whose domain is D, P ~Sys S if:
∃P '.P ≡ d  a   P ' iff a ∈D 
if a1,..., ak ∈D then ∃P ''.P ≡ r a ... a  ...  P ''
iff Ri(a1,..., ak) ∈S 
We denote with ~Struct the symmetric relation of ~Sys.
Proposition 4.1 Let ϕ a ﬁrst-order formula of FO, then the following holds:
let S a ﬁnite structure over a domain D and σ a valuation for the free variables of ϕ. If S,σ ▶ ϕ and S ~Sys P, then P ▶ ϕ)σ;
let P a system of ﬁnite state Brane Calculus and σ a mapping from free vari- ables of ϕ to action names. If P ▶ ϕ)σ and P ~Struct S, then S,σ ▶ ϕ.
The proof is a trivial induction on the structure of ϕ.
As a result of the last proposition, the following lemma holds.
Lemma 4.2 A closed ﬁrst-order formula ϕ of FO admits a ﬁnite model if and only if there exists a ﬁnite state Brane Calculus system P such that P ▶ ϕ).
It is easy to see that Lemma 4.2 and undecidability of the existence of finite models for first-order logic yield the undecidability of the satisfiability problem of the logic without guarantee over finite state brane systems, hence holds the following theorem:
Theorem 4.3 The model checking problem of ﬁnite states Brane Calculus against formulas with guarantee is undecidable.
Note that the encoding uses only a little fragment of the logic, and the only use of guarantee and quantification it is enough to yield undecidability.

Conclusions
In this paper, we have shown the undecidability of model checking of the fragment of Brane Logic without quantifiers and adjoints, in presence of the replication (either on systems or on membranes). This result has been obtained by reducing the Post Correspondence Problem to the model checking problem, following [4]. Also, we

have shown the undecidability of model checking of the fragment of Brane Logic with quantifiers and adjoints, in absence of replication. This result has been obtained by reducing the existence of finite models for first-order formulas, to the model checking problem. Beside this, we have given a correspondence between membranes and systems, showing that any system can be obtained by a canonical one where all information are contained on a membrane enclosing an empty compartment. We think that these results can be readily transposed to other variants of the Brane Calculus (with enough expressive power), such as the Projective Branes [6].
At this point, we plan to look for some weaker logical connectives to be used in place of adjoints, but yielding a decidable logic. In this direction, the work about epistemic logics [9] seems very promising. Also the comparison with customary first order temporal logics can be fruitful. Actually, a quite natural attempt is to consider a first order temporal logic extended with indexed modalities for describing
Δ
nesting properties (e.g., P ▶ ⟨|M|⟩A ⇐⇒ ∃σ, Q, R.P ≡ σ  QR∧σ ▶ M∧Q ▶ A);
however, it seems that the fragments of Brane Logics we have considered, are strictly more expressive than a first order temporal logic with nesting modalities, due to the presence of spatial connectives.
Another possibility is to look for subsets of the calculus for which the satisfaction problem is dedidable. In particular, we can consider restricted forms of replication or movement, like the Mate-Bud-Drip calculus; it is already known that these sub- calculi have nice decidability properties [1], although they are not as expressive as the full one.
We can also consider different notions of quantifier, in place of the classical “forall” quantifier. Recently, several logics for process algebras use some “freshness” quantifier, like Miller-Tiu’s “nabla” [11] or Gabbay-Pitts’ “new” [12], to represent freshness of local names. For instance, ∇x.A(x)  B(x) could represent processes which can be split in two parts, sharing a private name (which can be seen as a bound site connecting the two parts). In these cases, we want to express that the bound is private, i.e., the name used in the connection does not clash with those in the context; this is impossible to achieve with the forall/exists quantifier, but would be possible with nabla and new operators.
One may consider the logical equivalence induced by Brane Logic over mem- branes and systems. As for Ambient Logic [16], we could give a coinductive char- acterization of logical equivalence; however, our feeling is that logical equivalence is very close, if not equal, to structural congruence.

References
Busi, N., Deciding behavioural properties in brane calculi., in: Priami [14], pp. 17–31.
Caires, L., Behavioral and spatial observations in a logic for the pi-calculus., in: I. Walukiewicz, editor,
FoSSaCS, Lecture Notes in Computer Science 2987 (2004), pp. 72–89.
Cardelli, L., Brane calculi., in: Danos and Schachter [7], pp. 257–278.
Charatonik, W., S. Dal-Zilio, A. D. Gordon, S. Mukhopadhyay and J.-M. Talbot, Model checking mobile ambients, Theor. Comput. Sci. 308 (2003), pp. 277–331.

Dal-Zilio, S., Spatial congruence for ambients is decidable, in: ASIAN ’00: Proceedings of the 6th Asian Computing Science Conference on Advances in Computing Science (2000), pp. 88–103.
Danos, V. and S. Pradalier, Projective brane calculus., in: Danos and Schachter [7], pp. 134–148.
Danos, V. and V. Schachter, editors, “Computational Methods in Systems Biology, International Conference CMSB 2004,” Lecture Notes in Computer Science 3082, Springer, 2005.
Hennessy, M. and R. Milner, Algebraic laws for nondeterminism and concurrency, J. ACM 32 (1985),
pp. 137–161.
Mardare, R. and C. Priami, Decidable extensions of Hennessy-Milner logic, in: E. Najm, J.-F. Pradat- Peyre and V. Donzeau-Gouge, editors, Proc. FORTE, Lecture Notes in Computer Science 4229 (2006),
pp. 196–211.
Miculan, M. and G. Bacci, Modal logics for brane calculus, in: Priami [14], pp. 1–16.
Miller, D. and A. Tiu, A proof theory for generic judgments, ACM Trans. Comput. Log. 6 (2005),
pp. 749–783.
Pitts, A. M., Nominal logic, a first order theory of names and binding, Information and Computation
186 (2003), pp. 165–193.
Post, E. L., Recursively enumerable sets of positive integers and their decision problems, Bulletin of the American Mathematical Society 50 (1944), pp. 284–316.
Priami, C., editor, “Computational Methods in Systems Biology, International Conference, CMSB 2006, Trento, Italy, October 18-19, 2006, Proceedings,” Lecture Notes in Computer Science 4210, Springer, 2006.
Priami, C. and P. Quaglia, Beta binders for biological interactions, in: V. Danos and V. Sch¨achter, editors, Proc. CMSB, Lecture Notes in Computer Science 3082 (2004), pp. 20–33.
Sangiorgi, D., Extensionality and intensionality of the ambient logics, in: Proc. POPL, 2001, pp. 4–13.
Trakhtenbrot, B. A., The impossibility of an algorithm for the decision problem for finite models, Doklady Akademii Nauk SSR 70 (1950), pp. 569–572.
