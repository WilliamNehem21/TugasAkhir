	Electronic Notes in Theoretical Computer Science 140 (2005) 101–111	
www.elsevier.com/locate/entcs

Why the Usual Candidates of Reducibility Do Not Work for the Symmetric λμ-calculus
Ren´e David
Equipe de Logique, Universit´e de Savoie 73376 Le Bourget du Lac, France
Karim Nour
Equipe de Logique, Universit´e de Savoie 73376 Le Bourget du Lac, France

Abstract
T'he symmetric λμ-calculus is the λμ-calculus introduced by Parigot in which the reduction rule
μ , which is the symmetric of μ, is added. We give examples explaining why the technique using
the usual candidates of reducibility does not work. We also prove a standardization theorem for this calculus.
Keywords: λμ-calculus, reducibility.


Introduction
Since it has been understood that the Curry-Howard isomorphism relating proofs and programs can be extended to classical logic, various systems have been introduced: the λc-calculus (Krivine [11]), the λexn-calculus (de Groote [6]), the λμ-calculus (Parigot [17]), the λSym-calculus (Barbanera & Berardi [1]), the λΔ-calculus (Rehof & Sorensen [23]), the λμμ˜-calculus (Curien & Herbelin [3]), ...

1 Email: david@univ-savoie.fr
2 Email: nour@univ-savoie.fr




1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.06.020

The first calculus which respects the intrinsic symmetry of classical logic is λSym. It is somehow different from the previous calculi since the main connector is not the arrow as usual but the connectors or and and. The symmetry of the calculus comes from the de Morgan laws.
The second calculus respecting this symmetry has been λμμ˜. The logical part is the (classical) sequent calculus instead of natural deduction.
Natural deduction is not, intrinsically, symmetric but Parigot has intro- duced the so called Free deduction [16] which is completely symmetric. The λμ-calculus comes from there. To get a confluent calculus he had, in his ter- minology, to fix the inputs on the left. To keep the symmetry, it is enough to keep the same terms and to add a new reduction rule (called the μ'-reduction) which is the symmetric rule of the μ-reduction and also corresponds to the elimination of a cut. We get then a symmetric calculus that is called the symmetric λμ-calculus.
The μ'-reduction has been considered by Parigot for the following rea- sons. The λμ-calculus (with the β-reduction and the μ-reduction) has good properties : confluence in the un-typed version, subject reduction and strong normalization in the typed calculus. But this system has, from a computer science point of view, a drawback: the unicity of the representation of data is lost. It is known that, in the λ-calculus, any term of type N (the usual type for the integers) is β-equivalent to a Church integer. This no more true in the λμ-calculus and we can find normal terms of type N that are not Church integers. Parigot has remarked that by adding the μ'-reduction and some simplification rules the unicity of the representation of data is recovered and subject reduction is preserved, at least for the simply typed system, even though the confluence is lost.
Barbanera & Berardi proved the strong normalization of the λSym-calculus by using candidates of reducibility but, unlike the usual construction (for ex- ample for Girard’s system F ), the definition of the interpretation of a type needs a rather complex fix-point operation. Yamagata [24] has used the same technique to prove the strong normalization of the βμμ'-reduction where the types are those of system F and Parigot, again using the same ideas, has extended Barbanera & Berardi’s result to a logic with second order quantifi- cation.
The following property trivially holds in the λμ-calculus:
If (λxM N P1...Pn) d∗ (λxM ' N ' P '...P ' ) d (M '[x := N '] P '...P ' ), then we may
1	n	1	n
start the reduction by reducing the β redex, i.e (λxM N P1...Pn) d (M [x :=
P1...Pn) d∗ (M '[x := N '] P '...P ' ). This point is the key in the proof of two
1	n
results for this calculus:
If N and (M [x := N ] P1...Pn) are in SN , then so is (λxM N P1...Pn). Sim-

ilarly, if N and (M [α =r N ] P1...Pn) are in SN , then so is (μαM N P1...Pn). They are at the base of the proof of the strong normalization of the typed calculus.
The standardization theorem.
Even though this result remains (trivially) true in the symmetric λμ- calculus and the standardization theorem still holds in this calculus, point
(1) above is no more true. This simply comes from the fact that an infinite reduction of (λxM N ) does not necessarily reduce the β redex (and similarly for (μαM N )) since it can also reduce the μ' redex.
The other key point in the proof of the strong normalization of typed calculus is the following property which remains true in the symmetric λμ- calculus.
If M1, ..., Mn are in SN , then so is (x M1... Mn).
This paper is organized as follows. Section 2 defines the symmetric λμ- calculus and its reduction rules. We give the proof of (3) in section 3. Section 4 gives the counter-examples for (1). Finally we prove the standardization theorem in section 5.

The symmetric λμ-calculus
The set (denoted as T ) of λμ-terms or simply terms is defined by the following grammar where x, y, ... are λ-variables and α, β, ... are μ-variables:
T ::= x | λxT | (T T ) | μαT | (α T )
Note that we adopt here a more liberal syntax (also called de Groote’s calculus) than in the original calculus since we do not ask that a μα is imme- diately followed by a (β M ) (denoted [β]M in Parigot’s notation).
Even though this paper is only concerned with the un-typed calculus, the λμ-calculus comes from a Logic and, in particular, the μ-constructor comes from a logical rule. To help the reader un-familiar with it, we give below the typing and the reduction rules.
The types are those of the simply typed λμ-calculus i.e. are built from atomic formulas and the constant symbol ⊥ with the connector →. As usual
¬A is an abbreviation for A →⊥.
The typing rules are given by figure 1 below where Γ is a context, i.e. a set of declarations of the form x : A and α : ¬A where x is a λ (or intuitionistic) variable, α is a μ (or classical) variable and A is a formula.




Γ,x : A ▶ M : B
ax
Γ,x : A ▶ x : A
Γ ▶ M : A → B	Γ ▶ N : A

Γ ▶ λxM : A → B →i
Γ,α : ¬A ▶ M : ⊥
Γ ▶ μαM : A	⊥e
Γ ▶ (M N ): B	→e
Γ,α : ¬A ▶ M : A
Γ,α : ¬A ▶ (α M ): ⊥ ⊥i
Figure 1.

Note that, here, we also have changed Parigot’s notation but these typing rules are those of his classical natural deduction. Instead of writing
M : (Ax1 , ..., Axn ▶ B, Cα1 , ..., Cαm )

we have written
1	n	1	m

x1 : A1, ..., xn : An, α1 : ¬C1, ..., αm : ¬Cm ▶ M : B
The cut-elimination procedure corresponds to the reduction rules given below. There are three kinds of cuts.
A logical cut occurs when the introduction of the connective → is immedi- ately followed by its elimination. The corresponding reduction rule (denoted by β) is:
(λxM N ) d M [x := N ]
A classical cut occurs when ⊥e appears as the left premiss of a →e. The corresponding reduction rule (denoted by μ) is:
(μαM N ) d μαM [α =r N ]
where M [α =r N ] is obtained by replacing each sub-term of M of the form (α U ) by (α (U N )).
A symmetric classical cut occurs when ⊥e appears as the right premiss of a
→e. The corresponding reduction rule (denoted by μ') is:
(M μαN ) d μαN [α =l M ]
where N [α =l M ] is obtained by replacing each sub-term of N of the form (α U ) by (α (M U )).
Remark
It is shown in [17] that the βμ-reduction is confluent but neither μμ' nor βμ' is. For example (μαx μβy) reduces both to μαx and to μβy. Similarly (λzx μβy) reduces both to x and to μβy.

The following property is straightforward.
Theorem 2.1  If Γ ▶ M : A and M d M ' then Γ ▶ M ' : A.
If M1, ..., Mn are in SN , then so is (x M1... Mn)
The proofs are only sketched. More details can be found in [10] where an arithmetical proof of the strong normalization of the βμμ'-reduction for the simply typed calculus is given.
Definition 3.1  •  cxty(M ) is the number of symbols occurring in M .
We denote by N ≤ M (resp. N < M ) the fact that N is a sub-term (resp. a strict sub-term) of M .
The reflexive and transitive closure of d is denoted by d∗.
If M is in SN i.e. M has no infinite reduction, η(M ) will denote the length of the longest reduction starting from M .
We denote by N < M the fact that N ≤ M ' for some M ' such that M d∗ M '
and either M d+ M ' or N < M '. We denote by ≤ the reflexive closure of <.
Lemma 3.2	(i) If (M N ) d∗ λxP, then M d∗ λyM1 and M1[y := N ] d∗ λxP.
(ii) If (M N ) d∗ μαP, then either (M d∗ λyM1 and M1[y := N ] d∗ μαP) or (M d∗ μαM1 and M1[α =r N ] d∗ P) or (N d∗ μαN1 and N1[α =l M ] d∗ P).
Proof	Easy.	 
Lemma 3.3 Assume M, N ∈ SN and (M N ) /∈ SN. Then, either (M d∗ λyP and P [y := N ] /∈ SN) or (M d∗ μαP and P [α =r N ] /∈ SN) or (N d∗ μαP and P [α =l M ] /∈ SN).
Proof   By induction on η(M )+ η(N ).	 
Lemma 3.4  The term (x M1 ... Mn) never reduces to a term of the form
λyM.
Proof   By induction on n. Use lemma 3.2.	 
Definition 3.5 • Let M1, ..., Mn be terms and 1 ≤ i ≤ n. We will denote by M [α =i (M1 ... Mn)] the term M in which every sub-term of the form (α U ) is replaced by (α (x M1 ... Mi−1 U Mi+1 ... Mn)) .
We will denote by Σx the set of simultaneous substitutions of the form

[α1 =i
(M 1 ... M 1), ..., αk =i (Mk ... Mk)].

1	1	n	k	1	n
Lemma 3.6  Assume (x M1 ... Mn) d∗ μαM. Then, there is an i such that
Mi d∗ μαP and P [α =i (M1 ... Mn)] d∗ M.

Proof	By induction on n. Use lemmas 3.2 and 3.4.	 
Lemma 3.7  Assume M1, ..., Mn ∈ SN and (x M1 ... Mn) /∈ SN. Then, there is an 1 ≤ i ≤ n such that Mi d∗ μα U and U [α =i (M1 ... Mn)] /∈ SN.
Proof	Let k be the least such that (x M1 ... Mk−1) ∈ SN and (x M1 ... Mk)
/∈ SN . Use lemmas 3.3, 3.4 and 3.6.	 
Lemma 3.8  Let M be a term and σ ∈ Σx. If M [σ] d∗ μαP (resp. M [σ] d∗
λxP), then M d∗ μαQ (resp. M d∗ λxQ) for some Q such that Q[σ] d∗ P.
Proof   By induction on M .	 
The next lemma is the key of the proof of theorem 3.10. Though intuitively clear (if the cause of non SN is the substitution δ =i (P1...Pn), this must come from some (δ M ') < M ) its proof is rather technical.
Lemma 3.9 Let M be a term and σ ∈ Σx. Assume δ is free in M but not free in Im(σ). If M [σ] ∈ SN but M [σ][δ =i (P1...Pn)] /∈ SN, there is M ' < M and σ' such that M '[σ'] ∈ SN and (x P1...Pi−1 M '[σ'] Pi+1...Pn) /∈ SN.
Proof   See [10] for more detail.	 
Theorem 3.10  Assume M1, ..., Mn are in SN. Then (x M1 ... Mn) ∈ SN.
Proof  We prove a more general result.  Let M1, ..., Mn be terms and σ1, ..., σn be in Σx. If M1[σ1], ..., Mn[σn] ∈ SN , then (x M1[σ1] ... Mn[σn]) ∈ SN . This is done by induction on (Ση(Mi), Σcxty(Mi)). Assume (x M1[σ1]
... Mn[σn]) /∈ SN . By lemma 3.7, there is an i such that Mi[σi] d∗ μα U and U [α =i (M1[σ1] ... Mn[σn])] /∈ SN . By lemma 3.8, Mi d∗ μαQ for some Q such that Q[σi] d∗ U . Thus Q[σi][α =i (M1[σ1] ... Mn[σn])] /∈ SN . By lemma 3.9, let M ' < Q ≤ Mi and σ' be such that M '[σ'] ∈ SN and (x M1[σ1]...Mi−1[σi−1] M '[σ'] Mi+1[σi+1]...Mn[σn]) /∈ SN . This contradicts the induction hypothesis since (η(M '), cxty(M ')) < (η(Mi), cxty(Mi)).	 

The counter-examples

Definition 4.1  Let U and V be terms.
U ‹→ V means that each reduction of U which is long enough must go through V , i.e. there is some n0 such that, for all n > n0, if U = U0 d U1 d
... d Un then Up = V for some p.
U a V means that U has only one redex and U d V .
Remark

It is easy to check that if U ‹→ V (resp. U a V ) and V ∈ SN , then
U ∈ SN .
Definition 4.2	• Let M0 = λx(x P 0) and M1 = λx(x P 1) where 0 = λxλyy, 1 = λxλyx, P = λxλyλz (y (z 1 0) (z 0 1) λd1 Δ Δ) and Δ = λx(x x).
Let M = ⟨(x M1), (x M0)⟩, M ' = ⟨(β λx(x M1)), (β λx(x M0))⟩ where
⟨T1, T0⟩ denotes the pair of terms, i.e. the term λf (f T1 T0) where f is a fresh variable.
Let N = (α λz(α z)).
Lemma 4.3	(i) (M1 M0), (M0 M1) /∈ SN.
(ii) (M0 M0), (M1 M1) ∈ SN.
Proof
Assume i /= j, then
(Mi Mj) d∗ (P P j i)
d∗ (j (i 1 0) (i 0 1) λd1 Δ Δ)
d∗ (0 λd1 Δ Δ)
d∗ (Δ Δ) and thus (Mi Mj) /∈ SN .
It is easy to check that (Mi Mi) ‹→ (1 λd1 Δ Δ) a (λyλd1 Δ Δ) a
(λd1 Δ) a 1.	 

Proposition 4.4  M [x := μαN ] ∈ SN but (λxM μαN ) /∈ SN.
Proof	(a) Since M [x := μαN ]= ⟨(μαN M1), (μαN M0)⟩, by theorem 3.10, to show that M [x := μαN ] ∈ SN , it is enough to show that (μαN Mi) ∈ SN .
(μαN Mi) a μα(α(λz(α (z Mi))Mi))
a μα(α (α (Mi Mi)))
‹→ μα(α (α 1))
(b)
(λxM μαN ) d∗ μα(α (λxM λz(α (λxM z))))
d∗ μα(α (λxM λz(α ⟨(z M1), (z M0)⟩)))
d∗ μα(α ⟨(α ⟨(M1 M1), (M1 M0)⟩), (α ⟨(M0 M1), (M0 M0)⟩)⟩)
d∗ μα(α ⟨(α ⟨1, (Δ Δ)⟩), (α ⟨1, (Δ Δ)⟩)⟩)
and thus (λxM μαN ) /∈ SN .

Proposition 4.5  M '[β =r μαN ] ∈ SN but (μβM ' μαN ) /∈ SN.
Proof	(a) (λx(x Mi) μαN ) has two redexes thus either
(λx(x Mi) μαN ) d (μαN Mi)
a μα(α(λz(α (z Mi)) Mi))
a μα(α (α (Mi Mi)))
‹→ μα(α (α 1))
or
(λx(x Mi) μαN ) d μα(α(λx(x Mi) λz(α (λx(x Mi) z))))
‹→ μα(α (α (Mi Mi)))
‹→ μα(α (α 1))
Thus (λx(x Mi) μαN ) ‹→ μα(α (α 1)) and, by theorem 3.10, it follows that
M '[x := μαN ]= ⟨(β (λx(x M1) μαN )), (β (λx(x M0) μαN ))⟩∈ SN .
(b)
(μβM ' μαN ) d∗ μα(α (μβM ' λz(α (μβM ' z))))
d∗ μα(α (μβM ' λz(α μβ⟨(β (z M1)), (β (z M0))⟩)))
d∗ μα(α μβ⟨(β (α μβ⟨(β 1), (β (Δ Δ))⟩)),
(β (α μβ⟨(β (Δ Δ)), (β 1)⟩))⟩)
and thus (μβM ' μαN ) /∈ SN .

Standardization
In this section we give a standardization theorem for the βμμ'-reduction. It also holds for the μμ'-reduction and its proof simply is a restriction of the other one.
Definition 5.1	(i) The sequence (Mi)1≤i≤n is standard iff one of the fol- lowing cases hold:
For all i, Mi = λxNi (resp. Mi = μαNi, Mi = (x Ni), Mi = (α Ni)) and the sequence (Ni)1≤i≤n is standard
There are standard sequences (Ni)1≤i≤k and (Pi)k≤i≤n such that, for 1 ≤ i ≤ k, Mi = (Ni Pk) and, for k ≤ i ≤ n, Mi = (Nk Pi).
There is a standard sequence (Ni)1≤i≤k and Q such that,
either, for 1 ≤ i ≤ k, Mi = (Ni Q) and Nk = λxP and Nk−1 does not begin with λ and Mk+1 = P [x := Q] and the sequence (Mi)k+1≤i≤n is standard.

or, for 1 ≤ i ≤ k, Mi = (Ni Q) and Nk = μαP and Nk−1 does not begin with μ and Mk+1 = P [α =r Q] and the sequence (Mi)k+1≤i≤n is standard.
or, for 1 ≤ i ≤ k, Mi = (Q Ni) and Nk = μβP and Nk−1 does not begin with μ and Mk+1 = P [β =l Q] and the sequence (Mi)k+1≤i≤n is standard.
(ii) M dst M ' iff there is a standard sequence (Mi)1≤i≤n such that M = M1
and M ' = Mn.
Remarks and notation
The clauses in 1 above correspond to a definition by induction on the ordered pair (n, cxty(M1)).
It is easy to check that, restricted to the λ-calculus, this definition is equiv- alent to the usual definition of a standard reduction.
Clearly, if M dst M ' then M d∗ M '. In this case, we will denote the length of the reduction by lg(M dst M ').
Lemma 5.2 Assume M dst P and N dst Q. Then : (a) μαM dst μαP, (b) λxM dst λxP, (c) (M N ) dst (P Q), (d) M [x := N ] dst P [x := Q] and (e) for j ∈ {l, r}, M [α =j N ] dst P [α =j Q].
Proof  (a), (b) and (c) are immediate. (d) and (e) are proved by induction on (lg(M dst P ), cxty(M )) and a straightforward case analysis on the definition of a standard sequence bringing from M to P .	 
Lemma 5.3  Assume M dst P and P d Q. Then M dst Q.
Proof  This is proved by induction on (lg(M dst P ), cxty(M )) and by case analysis on the reduction M dst P . The only case which is not immediate is the following: M = (M1 M2) d∗ (N1 M2) d∗ (N1 N2) = P where M1 dst N1 and M2 dst N2. If the redex reduced in P d Q is in N1 or N2 the result follows immediately from the induction hypothesis. Otherwise, assume, for example that N1 = μαR and Q = R[α =r N2]. Let the reduction M1 dst N1 be as follows: M1 dst μαR1 dst μαR where μαR1 is the first term in the reduction that begins with μ. It follows then from lemma 5.2 that the following reduction is standard. M = (M1 M2) dst (μαR1 M2) d μαR1[α =r M2] dst μαR[α =r N2].
 
Theorem 5.4  Assume M d∗ P. Then M dst P.
Proof  By induction on the length of the reduction M d∗ M1. The result follows immediately from lemma 5.3.	 

References
F. Barbanera and S. Berardi. A symmetric lambda-calculus for classical program extraction. In
M. Hagiya and J.C. Mitchell, editors, Proceedings of theoretical aspects of computer software, TACS’94. LNCS (789), pp. 495-515. Springer Verlag, 1994.
R. Constable and C. Murthy. Finding computational content in classical proofs. In G. Huet and G. Plotkin, editors, Logical Frameworks, pp. 341-362, Cambridge University Press, 1991.
P.L. Curien and H. Herbelin. The duality of computation. Proc. International Conference on Functional Programming, September 2000, Montral, IEEE, 2000.
J.-Y. Girard. A new constructive logic: classical logic. MSCS (1), pp. 255-296, 1991.
P. de Groote. A CPS-translation of the lambda-mu-calculus. In S. Tison, editor, 19th International Colloquium on Trees in Algebra and Programming, CAAP’94, volume 787 of Lecture Notes in Computer Science, pp. 85-99. Springer, 1994.
P. de Groote. A simple calculus of exception handling. In M. Dezani and G. Plotkin, editors, Second International Conference on Typed Lambda Calculi and Applications, TLCA’95, volume 902 of Lecture Notes in Computer Science, pp. 201-215. Springer, 1995.
R. David. Normalization without reducibility. Annals of Pure and Applied Logic (107), pp. 121-130, 2001.
R. David and K. Nour. A short proof of the strong normalization of the simply typed lambda mu calculus. Schedae Informaticae n12, pp. 27-34, 2003.
R. David and K. Nour. A short proof of the strong normalization of classical natural deduction with disjunction. The Journal of Symbolic Logic n 68.4, pp. 1277-1288, 2003.
R. David and K. Nour. Arithmetical proofs of strong normalization results for the symmetric
λμ-calculus. To appear in TLCA’05.
J.-L. Krivine. Classical logic, storage operators and 2nd order lambda-calculus. Annals of Pure and Applied Logic (68), pp. 53-78, 1994.
C.R. Murthy. An evaluation semantics for classical proofs. In Proceedings of the sixth annual IEEE symposium on logic in computer science, pp. 96-107, 1991.
K. Nour. La valeur d’un entier classique en λμ-calcul. Archive for Mathematical Logic (36),
pp. 461-471, 1997.
K. Nour. A non-deterministic classical logic (the λμ++-calculus). Mathematical Logic Quarterly (48), pp. 357-366, 2002.
K. Nour and K. Saber. A semantical proof of the strong normalization theorem of full propositionnal classical natural deduction. Manuscript 2004.
M. Parigot. Free Deduction: An analysis of ”computations” in classical logic. Proceedings. Lecture Notes in Computer Science, Vol. 592, Springer, pp. 361-380, 1992.
M. Parigot. λμ-calculus: An algorithm interpretation of classical natural deduction. Lecture Notes in Artificial Intelligence (624), pp. 190-201. Springer Verlag, 1992.
M. Parigot. Strong normalization for second order classical natural deduction. In Proceedings, Eighth Annual IEEE Symposium on Logic in Computer Science, pp. 39-46, Montreal, Canada, 19–23 June 1993. IEEE Computer Society Press.
M. Parigot. Classical proofs as programs. In G. Gottlob, A. Leitsch, and D. Mundici, eds., Proc. of 3rd Kurt Godel Colloquium, KGC’93, vol. 713 of Lecture Notes in Computer Science,
pp. 263-276. Springer-Verlag, 1993.
M. Parigot. Proofs of strong normalization for second order classical natural deduction. Journal of Symbolic Logic, 62 (4), pp. 1461-1479, 1997.

E. Polonovsky. Substitutions explicites, logique et normalisation. PhD thesis, Paris 7, 2004.
W. Py. Confluence en λμ-calcul. PhD thesis, University of Chamb´ery, 1998.
N.J. Rehof and M.H. Sorensen. The λΔ-calculus. In M. Hagiya and J.C. Mitchell, editors, Proceedings of the international symposium on theoretical aspects of computer software, TACS’94, LNCS (789), pp. 516-542. Springer Verlag, 1994.
Y. Yamagata. Strong normalization of second order symmetric lambda-mu calculus. TACS 2001, Lecture Notes in Computer Science 2215, pp. 459-467, 2001.
