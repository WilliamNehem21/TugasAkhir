 Electronic Notes in Theoretical Computer Science 99 (2004) 205–227 
www.elsevier.com/locate/entcs




Specification and Verification of Protocols With Time Constraints 1

Margherita Napoli†	Mimmo Parente†	Adriano Peron‡
† Dipartimento di Informatica e Applicazioni, Universtit`a degli Studi di Salerno, I-84041 Baronissi(Salerno).
‡ Dipartimento di Scienze Fisiche,
Universit`a di Napoli Federico II, Via Cintia, I-80126 Napoli.


Abstract
In this paper we face the problem of specifying and verifying security protocols where temporal aspects explicitly appear in the description. For these kinds of protocols we have designed a spec- ification formalism, which consists of a state-transition graph for each participant of the protocol, with edges labelled by trigger/action clauses. The specification of a protocol is translated into a Timed Automaton on which standard techniques of model checking can be exploited (properties to be checked can be expressed in a linear/branching untimed/timed temporal logic). Along all the presentation we use, as running example, a two parties non-repudiation protocol for which we show how our framework applies in the verification of the fairness property for the protocol (establishing whether there is a step of the protocol in which one of the two participants can take any advantage over the other).
Keywords: Specification, Model-Checking, Timed Automata, Non-Repudiation Protocol


Introduction
From the early 90s, formal methods have been profitably used in various phases of the design of cryptographic protocols (specification, construction and ver- ification) since a number of examples have shown that their informal design is error prone. Many works have been then devoted to formal specification

1 This work was supported by the MURST in the framework of the project “Metodi Formali per la Sicurezza ed il Tempo” (MEFISTO).

1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.02.009

and analysis of cryptographic protocols, leading to a number of different ap- proaches and encouraging results (e.g. see [8]). However, most of the proposed techniques consider cryptographic protocols where concrete information about timing of events is not crucial (e.g. delay, timeout, timed disclosure or expi- ration of information do not determine the correctness of the protocol) and details on some low level timing aspects of the protocol are abstracted (e.g. timestamps, duration of channel delivery etc).
In this paper we focus on the problem of specifying and verifying security protocols where temporal aspects explicitly appear in the specification and are considered in the verification. The formal basic notation we use is that
of Timed Automata [2] and the approach to verification is model checking. A 
variety of tools have been proposed in recent years for the verification of real- time systems described by means of Timed Automata. For instance, the tool KRONOS [4] developed at VERIMAG, supports model checking of branching time requirements. The UPPAAL toolkit [7] allows checking of safety and bounded liveness properties.
Unfortunately, the formalism of Timed Automata, is a rather low level formalism, unsuitable to express a high level specification of security proto- cols and it would be hard for the protocol designer to use it as a specification language. Timed Automata lacks the ability of explicitly representing paral- lelism and communication between parallel components (each participant to a protocol is naturally described as a component of the specification acting in parallel with other component/participants). Moreover, the specification of a security protocol usually requires the description of structured messages ex- changed by participants possibly composed by using cryptographic primitives (encryption, hashing, signature etc).
In this paper we propose a specification formalism called Message pass- ing Timed Automata (MTA, for short) which retains the graphical nature of
Timed Automata (state-transition diagrams) and allows the specification of a cryptographic protocol in a style which is very close to the way a protocol designer is accustomed to use. In particular, MTA allow the explicit rep- resentations of the protocol parties and the communication among parties. Parties communicate by sending/receiving structured messages belonging to a term algebra suitable to express cryptographic primitives and concepts (e.g. public/private keys, encryption/decryption, hashing, nonces etc). As concerns timing aspects, three kinds of temporal constraints can be differently expressed in the formalism: temporal constraints of the control flow (e.g. usual delays and timeouts associated with performing some action), temporal constraints over the availability and usability of (communicated) pieces of information (i.e. disclosure and expiration of messages) and duration of channel delivery.

The connection with the more basic formalism of Timed Automata is not lost. In fact, the semantics of the specification language is given in terms of Timed Automata thus obtaining an executable and verifiable (in the standard framework of model checking) specification. The Timed Automaton obtained by compiling a protocol specification encodes in its states all the detailed infor- mation (including temporal aspects) necessary for proving relevant properties of the protocol.
The idea of using Timed Automata for specifying real time systems and proving security properties is not new (e.g. see [3,6]). Our approach differs in that Timed Automata are not the specification language itself but the front- end of a new specification language specialized for security protocols. From this perspective, our work is closer to [5], where the specification language is a timed process algebra. The two approaches differ in the treatment of time (discrete versus continuous) and in the verification techniques.
To support our formalism, we provide an application to a very well-known non-repudiation protocol, see [9]. In this protocol Alice sends a message to Bob and at the end no one of them can claim not having sent or received the message. More precisely at the end of the protocol Bob has collected enough information to prove that Alice is the source of the message, and Alice has enough information as well to prove that Bob has indeed received her message. Thus no one can claim the false (not having sent that message and not having received it), as the other will provide evidences of the contrary. Based on this
protocol we model-check the following fairness property: there is no step in
which if the protocol would stop, one of the two parties has an “advantage” on the other.
The rest of the paper is organized as follows: in the next section we re- call the non-repudiation protocol of Zhou and Gollmann [9]. In section 3.1 we present the specification language along with the resulting MTAs for the example protocol and in section 4 we show the translation into Timed Au- tomata. Finally we conclude with the verification of the fairness property for the example protocol in section 5 and some conclusions in the last section.

The Zhou-Gollmann efficient non-repudiation proto- col
In this section we briefly recall the Zhou-Gollmann protocol of [9]. Given two parties, Alice and Bob, a non-repudiation protocol aims at giving to both parties evidences of the sending and the receipt of the message. More precisely, when the protocol run to deliver a message from Alice to Bob terminates, the following properties are fulfilled:

Non-repudiation of Origin (NRO) Bob, interacting with Alice collects enough information to provide evidence of origin of the message and can use such an evidence as a proof if Alice denies having sent it;
Non-repudiation of Receipt (NRR) Alice interacting with Bob, collects enough information to provide evidence of the receipt of the message and can use such an evidence as a proof if Bob denies having received it.
To efficiently implement the non-repudiation property, the authors considered another party in the protocol, a Trusted Third Party, that intervenes only if a party cannot get the expected non repudiation evidence, providing the impaired party with the desired evidence.
Fairness Property. The protocol satisfies the fairness property: it provides the sender and the receiver with valid irrefutable evidence after its completion,
without giving a party any advantage over the other at any stage of the pro- tocol [ZG97]. As the evidence of the sending is given by the message itself (or something else shipped along with it), the originator needs an acknowledge-
ment of the receipt of the message. Fairness can be broken for two reasons: either the communication channel is faulty and a transmitted message is never delivered or a party does not play fair by not adhering to the protocol rules. We will assume that the channel is resilient, that is, it is never faulty and always delivers the message transmitted in a finite unknown amount of time. By paraphrasing [9], the main idea of the protocol is to split the message into two parts, a commitment and a key K, which is sent both to B and to the TTP . If a dispute occurs, both the parties have the ability to retrieve the key from the TTP . Let us first give some notation necessary to describe the protocol: M is the message sent from A to B, T is the timeout, K is the key
of A, C is the commitment (i.e., M cyphered with K), L is a unique label chosen by A to identify a protocol run, f is a flag indicating the purpose of a message, SA and SB are A’s and B’s private keys, sK(M ) is the signature
of message M with key K, EOO is the evidence of origin of C, EOR is the
evidence of receipt of C, sub K is the evidence of submission of K and finally,
con K is the evidence of confirmation of K issued by the TTP .
Moreover, the specification of the protocol exploits the following short- hands:
EOO = sSA(fEOO ,B,L,T,C) EOR = sSB(fEOR ,A,L,T,C) EOO K = sSA(fEOO K ,B,L,K) EOR K = sSB(fEOR K ,A,L,K) sub K = sSA(fSUB ,B,L,K)

con K = sSTTP (fCON ,A,B,L,K)
The specification is now as follows:
A → B : fEOO , B, L,T, C, EOO
B → A : fEOR , A, L, EOR
A → B : fEOO K , B, L, K, EOO K
B → A : fEOR K , A, L, EOR K
If B does not receive the key K, at step 3, the protocol halts satisfying the fairness property. On the other side, if A does not receive the message of step 4, then she starts the following recovery phase:
3’ A → TTP : fSUB , B, L, K, sub K
4’ B ↔ TTP : fCON , A, B, L, K, con K
4’ A ↔ TTP : fCON , A, B, L, K, con K
Evidences. If the protocol stops legally, then A and B get the non-repudiation evidences (EOR and EOR K for A, and EOO and EOO K for B). Otherwise, if something goes wrong, A starts the recovery phase and both get the evi- dences with the help of the TTP (EOO and con K for A, and EOR and con K, for B). Let us note that the parameter L is needed to specify a protocol run (it is chosen by Alice at the very beginning along with T ). For a more detailed presentation of the protocol the reader is referred to [9].

Specification
In this section we first introduce the formalism of Message passing Timed Automata giving its intuitive semantics (the formal semantics is given in sec- tion 4), and then we specify the Zhou-Gollman non-repudiation protocol in the defined setting.

Message passing Timed Automata
We start by defining the algebra allowing to express structured messages used in the communication among participants to a protocol section. The algebra has operations corresponding to the most widely used cryptografic primitives (e.g. encryption, decryption, hashing, signature etc.) and operations for as- sociating temporal constraints to messages (e.g. timed disclosure, expiration etc.).
Let M, K, PK, I, and N be pairwise disjoint alphabets for messages, keys, public keys, identities and nonces, respectively, and let Σ = K∪ PK ∪ M∪ I ∪ N .

Definition 3.1 Let X be an alphabet of formal parameters. The set of struc- tured messages over Σ and X , denoted by SMΣ,X , is inductively defined as follows:
m ∈ SMΣ,X , for any m ∈ Σ ∪X ;
!X ∈ SMΣ,X , for any X ∈ X ;
(m, m') ∈ SMΣ,X , for any m, m' ∈ SMΣ,X ;
{m}K ∈ SMΣ,X , for any m ∈ SMΣ,X and K ∈K ∪ PK;
h(m), †(m), signid(m) ∈ SMΣ,X , for any m ∈ SMΣ,X and id ∈ I;
∆τ (m), Θτ (m),Iτ2 (m) ∈ SMΣ,X , for any m ∈ Σ, and τ, τ1, τ2 ∈ Q≥0 with
0 < τ1 ≤ τ 2.
A structured message m is ground if any formal parameter symbol occurring in m is within the scope of a ! symbol. The set of ground messages will be denoted by SMΣ,∅. A message is timed if it contains any occurrence of a (sub)message of the form ∆τ (m), Θτ (m) or Iτ2 (m).

In the above definition !X can be interpreted as the ground message (if any) associated with the formal parameter X, {m}K as the encryption of message m with a private or public key K; h(m) as the hash of the message m; signid(m) as the signature of message m with the identity id. Pairing of (m, m') of messages m and m' allows to construct structured messages. As concerns timing messages, we have the following: ∆τ (m) represents the fact that m is disclosed only at the elapsing of an interval of time τ since the communication of m, Θτ (m) that m expires after an interval of time τ (since the communication of m), and Iτ2 (m) the fact that m is disclosed after τ1 and expires after τ2; †(m) represents the fact that m is expired.
Notice that temporal constraints can be associated only with non-structured messages (i.e. messagges in Σ).
Each participant in a protocol execution collects evidences by receiving structured messages sent by the other participants. In the following, for and identity id, we define a relation ▶id describing the set of evidences (namely, masseges known to or composable by a participant of identity id) which can derived (or composed) from a collection of structured messages.
For an identity symbol id ∈ I, the relation of evidence derivation ▶id⊆
2SMΣ,X × SMΣ,X is recursively defined by the following rules (for simplicity we use infix notation):
Kw ▶id m if m ∈ Kw;
Kw ▶id K if K ∈ PK;
Kw ▶id h(m) if Kw ▶id m;

Kw ▶id signid(m) if Kw ▶id m;
Kw ▶id m if Kw ▶id signid' (m);
Kw ▶id (m1, m2) if Kw ▶id m1 and Kw ▶id m2;
Kw ▶id m1 and Kw ▶id m2 if Kw ▶id (m1, m2);
Kw ▶id {m}K if Kw ▶id m and Kw ▶id K;
Kw ▶id m if Kw ▶id {m}K and Kw ▶id K;
Kw ▶id m if Kw ▶id Θτ (m);
Kw ▶id m if Kw ▶id †(m).
Notice that any public key is known; a message can be hashed and signed (with identity id); pair of messages can be coupled and component messages of a couple can be extracted; an encrypted message can be decrypted if the encryption key is known, and a message can be encrypted by a known key; a message with expiration time is known, whereas a message with a (non null release time) is not.
Participants to a protocol are described by state transition diagrams where transition are labelled by events representing sending and receiving a struc- tured message along a channel, called trigger and action, respectively.
More formally, given a set Γ of channels, the set of triggers over Γ, written
TriggerΓ, is the set

{True}∪ {?α(m) : with α ∈ Γ, and m ∈ SMΣ,X }.
The set of actions over Γ, written ActionΓ, is the set:

{Nil}∪ {!α(m) : with α ∈ Γ, and m ∈ SMΣ,X }.
Definition 3.2 A Message passing Timed Automaton, MTA for short, over an alphabet Σ, a set of parameters X and a set of channels Γ, is a tuple
⟨C1,..., Cn, λ, η⟩, where
λ : Γ → Q≥0 × (Q≥0 ∪ {ω}) is the timing channel function;
η : {1,... , n}→I is the identity (injective) function;
any sequential component Ci, with 1 ≤ i ≤ n, is a tuple
⟨Si, Ii, δi, Kwi⟩, where
Si is the (finite) set of states (we assume that Si ∩ Sj = ∅, for i /= j);
Ii ⊆ Si is the set of input states;
δi ⊆ Si × TriggerΓ × ActionΓ × S∆ × SΘ × Si is the transition relation,
i	i
where, for a set of states S, S∆ is the set {(s, τ ) : s ∈ S, τ ∈ Q≥0} and SΘ

is the set {(s, τ ) : s ∈ S, τ ∈ Q≥0 ∪ {ω}};
Kwi : Ii → 2Σ is the initial evidence function.
In the above definition, the timing channel function, gives for a channel α, the endpoints of an interval bounding the time required for delivering a message. For instance, if λ(α) = (2, 5), then α is an operational channel which takes at least time 2 to deliver a message and which is known to deliver the message within time 5; if λ(α) = (0, ω), then α is a resilient channel which delivers the mesage in a finite but unpredictable amount of time.
The identity function is an injective fuction naming each sequential con- ponent by an identity symbol.
Each sequential component of the MTA is a state transition diagram de- scribing a participant in the protocol. It consists of a finite set of states, a subset of which, are input states (i.e. initial states for a protocol execution). The initial evidence function Kwi, assignes, to each initial state, the set of evidence (i.e. private keys, identities, nonces, unstructured messages) which are supposed to be known by the participant at the beginning of the execution of a protocol. The actual set of evidences known by a participant to a protocol section can be augmented (from its initial state) by receiving messages from other participants, and it is reset to the initial conditions every time an input state is reached.
Any transition transition from a state s1 to s2 is a tuple of the form

⟨s1, trigger, action, delay, timeout, s2⟩, labelled by
a triggering event: if the trigger is an expression of the form ?α(m), the transition is enabled to fire when it receives a message along the channel α; if the trigger equals True, the transition is unconditionately enabled to fire;
an action which is taken when the transition fires: if the action is an ex- pression of the form !α(m), a message m is sent in the channel α; if the action equals Nil, no action is performed;
a delay having the form (s, τ ), with s ∈ Si, meaning that the transition can be performed only an amount of time τ after the last entering of state s;
a timeout having the form (s, τ ), with s ∈ Si, meaning that the transition can be performed only within an amount of time τ after the last entering of state s.
Notice that the performance of a transition is conditioned to the fulfilment of two kinds of constraints: the trigger of a communication event, and the temporal constraints imposed by a delay and/or a timeout.
Sequential components communicate by synchronously sending and receiv-

ing messages along channels (one to one handshaking). Asynchronous sending is not allowed. Communication has also to preserve the structure of expected messages. A message m occurring in a receiving event ?α(m) is a structured message usually containing formal parameters. On the contrary, a message m' sent by an action !α(m') is a ground message. A synchronization of ?α(m) with !α(m') can take place only if m and m' have compatible structure, i.e. they are unifiable.
For instance, a message m of the form (X, SignA(X)), with X a parameter symbol, is unifiable with a message of the form (m, SignA(m)), and it is not unifiable with a message of the form (m1, SignA(m2)), with m1 /= m2. In the former case, the side effect of a synchronization is the binding of the actual value m to the formal parameter X.
The outlined notions of unifiability of terms and assignment of actual val- ues to formal parameters, are formalized by the message unification relation defined as follows.
For a set of keys T ⊆ K, and a function ρ : X → SMΣ,∅, the message unification relation =⇒T,ρ ⊆ SMΣ,X × SMΣ,∅ × SMΣ,X × 2X ×SMΣ,∅ associates, with a couple of messages m1 and m2 (with m2 ground), a couple consisting of a unifying message mu and a partial fuction σu from parameters to (ground)
messages (for readability, we shall write (m1, m2) =⇒T,ρ  (mu, σu) instead
of (m1, m2, mu, σu) ∈=⇒T,ρ . The relation =⇒T,ρ is inductively defined as
MU	MU 
follows:

(m1, m2) =⇒T,ρ
(m2, ∅) if m1 is ground and m1 = m2;

(X, m2) =⇒T,ρ
(!X, m2) =⇒T,ρ
(m2, {(X, m2)}) with X ∈ X ; (m2, ∅) if ρ(X) = m2;

({m1}K, {m2}K) =⇒T,ρ ({mu}K, σu) if K ∈ T ∪ PK and
(m1, m2) =⇒T,ρ (mu, σu);

(Signid(m1), Signid(m2)) =⇒T,ρ
(Signid(mu), σu)

if (m1, m2) =⇒T,ρ (mu, σu);
((m1, m2), (m3, m4)) =⇒T,ρ ((m' , m''), σ' ∪σ'') if (m1, m3) =⇒T,ρ (m' , σ' ),
MU	u	u	u	u	MU	u	u
(m2, m4) =⇒T,ρ (m'', σ'') and σ' ∪ σ'' is a partial function.
MU	u	u	u	u
The parameter T in the unification relation is the set of private keys which are supposed to be known when the messages are unified. For instance, a message {X}K can be unified with a message {m}K only if either K is a public key or K is a known private key. (Notice that this restriction prevents from disclosing an encrypted message by unification.) For the same reason, a message h(X) cannot be unified with a message h(m). The condition for the unification of a pair of messages ensures that two different actual values are

not assigned to the same formal parameter.
Performing transitions is not, in general, instantaneous. A transition t1 labelled by a trigger ?α(m) and an action !β(m') can be performed when a synchronization with a transition t2 (in a parallel component) labelled by an action !α(m'') is possible. The synchronization is instantaneous and releases immediately t2. On the other hand, the completion of the enabled transition t1, may be deferred by two factors which contributes to the overall duration of the transition:
t1 may be forced to wait the completion of the transmission of message
m'' which takes a time belonging to the interval λ(α);
a synchronization is required for the action !β(m').
A consequence of such a semantics for transitions, is that a transition labelled by a trigger ?α(m) and an action !β(m') can be equivalently replaced by the sequentialization of two transitions, the former labelled by ?α(m) with a Nil action and the latter labelled by a trigger True and action !β(m'). For the sake of simplicity, in the following we shall consider sequential components having transitions labelled in such a restricted way.
More formally, a transition is unidirectional if it has one of the following forms:
⟨s, γ, Nil, (s1, τ1), (s2, τ2), s'⟩, for some γ ∈ Trigger(Γ) (a receiving transi- tion);
⟨s, True, β, (s, 0), (s, ω), s'⟩ for some β ∈ Action(Γ) (a sending transition). It is easy to transform a MTA into a MTA having unidirectional transi-
tions.
Given a sequential component C = ⟨S, I, δ, Kw⟩, we denote by U nidir(C) the sequential machine (with unidirectional transitions) ⟨S0 ∪ S1, I0, δ, Kw⟩, where
Si = {(s, i) : s ∈ S, with i ∈ {0, 1}} are two disjoint copies of S;
I0 = {(s, 0) : s ∈ I};

δ = {⟨(s, 0), γ,Nil, ((s1, 0),τ '), ((s2, 0),τ ''), (s, 1)⟩,
⟨(s, 1),True, β, ((s, 1), 0), ((s, 1), ω), (s', 0)⟩ :
⟨s, γ, β, (s1,τ '), (s2,τ ''), s'⟩∈ δ};

Kw = {((s, 0), A)) : (s, A) ∈ Kw}.
For a MTA C = ⟨C1,... , Cn, λ, η⟩, U nidir(C) is the automaton
⟨U nidir(C1),... ,Unidir(Cn), λ, η⟩.

The MTA for the Non-Repudiation Protocol

In this subsection we present the MTA describing the the protocol presented in the previous section. The MTA consists of three sequential components, one for each participant, depicted in Figure 1, 2, and 3.
For description pourposes, triggers and actions of transitions are decorated by labels o the form Ai (for Alice in Figure 1) Bi (for Bob in Figure 2) and Ti (for TTP in Figure 3). Null delays and unbounded timeouts are omitted, whereas a label ≤ T stands for a timeout (s0,T ), with s0 the initial state. The channel α connects Alice and Bob, β connects Alice to the TTP, and γ connects Bob to the TTP. We assume that channels are resilient, that is, the timing channel function λ is such that λ(α) = λ(β) = λ(γ) = (0, ω). Moreover, we assume that the identity function η assigns A to Alice, B to Bob and TT to the TTP. Symbols M , L, T and all the flags of the form fn (with n the flag name) are messages; K is a key of A and C is the structured message {M }K; X, V , Y , Z, W , and H are formal parameters.
Let us consider in more detail the sequential component for Alice in Fig- ure 1. Alice starts the protocol execution by sending the evidence EOO (notice that the trigger A1 is True). The structured message corresponding to EOO is signA(fEOO, B, L,T, C) (for the sake of simplicity we forget pairing and,
for instance, we write fEOO, B, L,C instead of (fEOO, (B, (L, (T, C))))). With reference to Figure 2, Bob is waiting for the corresponding parametric message labelled by B1. Notice that the ground messages L and C sent by Alice will be unified with the formal parameters X and Y , respectively.
The list of the other shorthands used in Figure 1, is the following:
EOR has the form signB(fEOR, A, L,T, C); EOO K has the form signA(fEOOK , B, L, K); EOR K has the form signB(fEORK , A, L, K); sub K has the form signA(fsub K, B, L, K);
con K has the form signTT (fCON , B, L, K).
According to the protocol description, from now on all the steps of Alice have to complete within time T . Once she has received from Bob the first
part of the aimed evidence (EOR ), she sends the last part of the evidence (EOO K ) to Bob.

Alice has then to wait for the last part of evidence (EOR K ). If this evidence is not delivered (either because Bob did not send it or because the channel is delaying the message too much), she has to invoke the TTP within the given

s0
A1 A2

A3
<= T
A4



TRUE

(f	,B,L,T,C,EOO)
EOO



 (f EOR,A,L,EOR)
 (f	,B,L,K,EOO_K)
EOO k



A5	 (f	,A,L,EOR_K)
EOR k
A6	Nil


<= T
A7 A8
<= T
TRUE
 (f	,B,L,K,sub_K)
SUB k



stop



<= T

A9 (f CON,A,B,L,K,con_K)

A10 Nil

stop

Fig. 1. The sequential component for Alice

time T , chosen in advance before starting the protocol. This is represented by a branch of the sequential component: on the left branch Alice waits for the EOR K , on the right one she invokes the intervention of the TTP within time T .
The sequential components for Bob and the TTP (see Figures 2 and 3) are simpler. We only observe that the sequential component of Bob has a branching point dealing with the situation in which he may receive either
EOO K from Alice or con K from the TTP, or both.
The list of shorthands used in the sequential components for Bob and the TTP are the following:
EOO -B has the form signA(fEOO, B, X,T,Y ); EOR -B has the form signB(fEOR, A, X,T,Y ); EOO K -B has the form signA(fEOOK , B, X,W ); EOR K -B has the form signB(fEORK , A, X,W );
con K − B has the form signTT (fCON , A, B, !X, W );

sub K − T has the form signA(fsub K, B, V,H); con K − T has the form signTT (fCON , A, B, V,H).
Notice that the sequential component for Bob receives the identifier of the protocol run L in the parameter X in the trigger B1, and then forces Alice to use the same identifier in the following steps by exploiting !X in the trigger B3 and B4.

s0
B1  (f EOO,B,X,T,Y,EOO−B) B	(f	,A,X,EOR−B)
EOR


B3   (f	,B,!X,W,EOO_K−B)
EOO k
(f	,A,X,EOR_K−B)
4	EOR k
B5
B6
<= T
 (f CON,A,B,!X,W,con_K−B)
Nil

<= T
stop	stop

Fig. 2. The sequential component for Bob



s0

<= T





<= T


T 1   (f	,B,V,H,sub_K−T)
SUB k
(f	,A,B,V,H,con_K−T)
2	CON




T 3  True
T 4  (f CON,A,B,V,H,con_K−T)


stop

Fig. 3. The sequential component for TTP

From MTA to Timed Automata
The semantics of MTA’s is given by translation into the well known setting of Timed Automata [2]. The translation is performed in two steps: we first translate a sequential component into a (open) Timed Automaton with tran- sition labelled by symbols for incomplete communications; then, we take the product of the so obtained sequential components and we synchronize incom- plete communications. In general, the resulting translation is not guaranteed to be a Timed Automaton since the set of locations resulting from our trans- lation may be infinite. Fortunately, in the cases of interest it is easy to find syntactical constraints which are sufficient to guarantee finiteness of locations. For instance, a sufficient condition which could be naturally enforced is that each cycle in sequential component should contain at least an input state.
For sake of completeness, we start defining Timed Automata and their semantics.
Definition 4.1 A Timed Automaton over an alphabet S is a tuple

⟨L, L0, CK,I, δ⟩, where
L is a finite set of locations;
L0 ⊆ L is a set of initial locations;
CK is a finite set of clocks;
I : L → Φ(CK) is the invariant map associating a clock constraint with each location, where the set of clock constraints Φ(CK) is defined by the following grammar:
φ := True | z ≤ c | c ≤ z | z < c | c < z | φ1 ∧ φ2,

with z a clock in CK and c a constant in Q≥0;
δ ⊆ L ×S × Φ(CK) × 2CK × L is the transition relation.
An element ⟨s, a, φ, λ, s'⟩∈ δ, written also s a,φ,λ s', represents a transition from the location s to the location s' on symbol a; the clock constraints φ specifies when the transition is enabled, and the set λ ⊆ CK gives the clocks to be reset when the transition is performed.
We recall now, rather informally, the semantics of Timed Automata refer- ing the reader to the literature for the standard definition.
The semantics of a Timed Automaton A = ⟨L, L0, CK,I, δ⟩, is defined by associating a transition system TSA. A state of TSA is a pair ⟨s, ν⟩ such that s is a location of A and ν is a clock valuation of CK (i.e. a mapping from

CK to Q≥0) such that ν satisfies the invariant I(s). A state is an initial state if s is an initial location and ν(z) = 0, for all clocks z. There are two types of transitions in TSA:
State change due to elapse of time: for a state ⟨s, ν⟩ and a time incre-

ment γ ∈ Q≥0, ⟨s, ν
γ
⟩ −→ ⟨
s, ν + γ⟩, if for all 0 ≤ γ' ≤ γ, ν + γ' satisfies the

invariant I(s) (ν + γ denotes the clock valuation which maps each clock z
to ν(z) + γ);
State change due to a location transition: for a state ⟨s, ν⟩ and a tran- sition ⟨s, a, φ, λ, s'⟩ such that ν satisfies φ, ⟨s, ν⟩ −a→ ⟨s, ν[λ := 0]⟩ (ν[λ := 0] denotes the clock valuation which assigns 0 to each z ∈ λ and agrees with ν over the rest of the clocks).
In the following we assume that MTA’s have unidirectional transitions.
For a map ρ : X → SMΣ,∅, we denote by ρˆ the extension of the map ρ to elements of SMΣ,X : for an element m ∈ SMΣ,X , ρˆ(m) gives the simultaneous replacement in m of any occurrence of a submessage of the form !X or X by ρ(X).
For a sequential component Ci = ⟨S, I, δ, Kw⟩, of a MTA ⟨C1,... , Cn, λ, η⟩, we define a Timed Component TC(Ci) = ⟨TS, TSI, CK,TI,Tδ⟩ (i.e. a Timed Automaton), where TS is the set of locations, TSI is the set of initial locations, CK is the set of clocks, TI is the invariant fuction, and Tδ is the transition relation.
A location in TS is a tuple ⟨KwS, Ch, s, ρ⟩, where
KwS is the collection of evidences (i.e. ground messages) known in that location;
Ch keeps trace of the set of messages the component is receiving from com- munications which have been established but which are not yet completed (due to transmission duration); each incomplete interaction is described by the channel name, the (parametric) expected message and the ground sent message; the pair of expected and sent messages allows to bind formal parameters with messages at the transmission completion;
s ∈ S is the current state of the component Ci;
ρ is a partial map which binds parameters to messages. More formally, the timed component TC(Ci) is as follows:
TS = {⟨KwS, Ch, s, ρ⟩ : KwS ⊆ SMΣ,∅, Ch ⊆ Γ × SMΣ,χ × SMΣ,∅,
s ∈ S, ρ ⊆X × SMΣ,∅};
TSI = {⟨Kw(s), ∅, s, ∅⟩ : s ∈ I};
CK = {cks : s ∈ S}∪ {ckη(i),m : m ∈ M} ∪ {ckη(i),α : α ∈ Γ};

TI is such that TI(⟨KwS, Ch, s, ρ⟩) = φ1 ∧ φ2 ∧ φ3 with
φ1 is the conjunction of the set of clock constraints
{True} ∪ {cks ≤ τ : cks ≤ τ occurs in the clock constraint of a transition t ∈ Tδ departing from location ⟨KwS, Ch, s, ρ⟩}.
φ2 is the conjunction of the set of clock constraints
{True} ∪ {ckη(i),m ≤ τ : there is m' ∈ KwS ∪ π3(Ch) with an occurrence of a message of the form ∆ (m) or Θ (m) or Iτ' (m)} (π
τ	τ	τ	j
is the extension to sets of the standard projection function along the
j-th component);
φ3 is the conjunction of the set of clock constraints
{True} ∪ {ckη(i),α ≤ τ2 : λ(α) = (τ1, τ2),α ∈ π1(Ch)};
Tδ is the union of the following sets:
{⟨KwS, Ch, s, ρ⟩ !α(ρˆ(m)),T rue,{cks' } ⟨KwS, Ch, s', ρ⟩ :
⟨s, True, !α(m), (s, 0), (s, ω), s'⟩∈ δ, s' /∈ I, ρˆ(m) is a ground message and KwS ▶η(i) ρˆ(m)};
{⟨KwS, Ch, s, ρ⟩ !α(ρˆ(m)),T rue,{cks' } ⟨KwS', ∅, s', ∅⟩ :
⟨s, True, !α(m), (s, 0), (s, ω), s'⟩∈ δ, KwS' = Kw(s'), s' ∈ I, ρˆ(m) is a ground message and KwS ▶ ρˆ(m)};
{⟨KwS, Ch, s, ρ⟩ Nil,T rue,{cks'} ⟨KwS, Ch, s', ρ⟩ :
⟨s, True, Nil, (s, 0), (s, ω), s'⟩∈ δ, s' /∈ I };
{⟨KwS, Ch, s, ρ⟩ Nil,T rue,{cks'} ⟨KwS', ∅, s', ∅⟩ :
⟨s, True, Nil, (s, 0), (s, ω), s'⟩∈ δ, KwS' = Kw(s'), s' ∈ I };
{⟨KwS, Ch, s, ρ⟩ ?α(m),φ∆∧φΘ,Clocks ⟨KwS, Ch', s', ρ⟩ :
⟨s, ?α(m),Nil, (s1, τ1), (s2, τ2), s'⟩∈ δ, Ch' = Ch ∪ {⟨α, m, m'⟩}, s' /∈ I, there is no tuple t in Ch having α as first component,

(m, m') =⇒T,ρ
(mu, ρu) with T = {K ∈K : KwS ▶η(i) K},

there is no timed atomic submessage of mu occuring timed in KwS, φ∆ = cks1 ≥ τ1, φΘ = True if τ2 = ω and φΘ = cks2 ≤ τ2 otherwise, Clocks = {cks' , ckη(i),α}∪ {ckη(i),m : m ∈ M is a timed submessage of m'} } 
{⟨KwS, Ch, s, ρ⟩ ?α(m),φ∆∧φΘ,{cks' } ⟨KwS', ∅, s', ∅⟩ :
⟨s, ?α(m),Nil, (s1, τ1), (s2, τ2), s'⟩∈ δ, s' ∈ I,
there is no tuple t in Ch having α as first component,

(m, m') =⇒T,ρ
(mu, ρu) with T = {K ∈K : KwS ▶η(i) K},

there is no timed atomic submessage of mu occuring timed in KwS; KwS' = Kw(s'), φ∆ = cks1 ≥ τ1, φΘ = True if τ2 = ω and φΘ = cks2 ≤ τ2 otherwise }
{⟨KwS, Ch, s, ρ⟩ True,φ∆∧φΘ,{cks' } ⟨KwS, Ch, s', ρ⟩ :

⟨s, True, Nil, (s1, τ1), (s2, τ2), s'⟩∈ δ, s' /∈ I,
φ∆ = cks1 ≥ τ1, φΘ = True if τ2 = ω and φΘ = cks2 ≤ τ2 otherwise }
{⟨KwS, Ch, s, ρ⟩ True,φ∆∧φΘ,{cks' } ⟨KwS', ∅, s', ∅⟩ :
⟨s, True, Nil, (s1, τ1), (s2, τ2), s'⟩∈ δ, s' ∈ I, KwS' = Kw(s'),
φ∆ = cks1 ≥ τ1, φΘ = True if τ2 = ω and φΘ = cks2 ≤ τ2 otherwise }

{⟨KwS, Ch, s,ρ 
є,φ,∅
KwS', Ch', s, ρ'⟩ :

⟩ −→ ⟨
φ = τ1 ≤ ckη(i),α ≤ τ2 if λ(α) = (τ1, τ2) and φ = τ1 ≤ ckη(i),α if
λ(α) = (τ1, ω),
⟨α, m, m'⟩∈ Ch, KwS' = KwS ∪ {mu},

with (m, m') =⇒T,ρ
(mu, ρu) and T = {K ∈K : KwS ▶η(i) K},

Ch' = Ch \ {⟨α, m, m'⟩},
ρ' = ρu ∪ {(X, m) : (X, m) ∈ ρ, ρu is not defined for X} },
{⟨KwS, Ch, s, ρ⟩ є,ckη(i),m' =τ,∅ ⟨KwS', Ch, s, ρ⟩ :
KwS' = KwS \ {m}∪ {m[m'|∆ (m'), Θτ' (m')| τ '	' ]}, for some
τ	Iτ (m )
m ∈ KwS with m having a submessage either of the form ∆τ (m') or
Iτ' (m') }
{⟨KwS, Ch, s, ρ⟩ є,ckη(i),m' =τ,∅ ⟨KwS', Ch, s, ρ⟩ :
KwS' = KwS \ {m}∪ {m[†(m )|Θ (m')]}, for some m ∈ KwS with m
τ

having a submessage of the form Θτ (m') }
{⟨KwS, Ch, s, ρ⟩ є,ckη(i),m' =τ,∅ ⟨KwS, Ch', s, ρ⟩ :
Ch' = Ch \{⟨α, m'', m⟩} ∪ {⟨α, m'', m[m'|∆ (m'), Θτ' (m')| τ '


' ]⟩}, for

τ	Iτ (m )
some ⟨α, m'', m⟩∈ Ch with m having a submessage either of the form
∆ (m') or Iτ' (m') }
τ	τ
{⟨KwS, Ch, s, ρ⟩ є,ckη(i),m' =τ,∅ ⟨KwS, Ch', s, ρ⟩ :
Ch' = Ch \ {⟨α, m'', m⟩} ∪ {⟨α, m'', m[†(m')|Θ (m')]⟩}, for some
⟨α, m'', m⟩∈ Ch with m having a submessage of the form Θτ (m') }.
The set of clocks CK of the component provides a distinct clock name for each state in S, each ground message and each channel name. With reference to the transition relation Tδ we have:
a is the set of transitions corrisponding to a sending action and leading to a non input state; the action of sending does not affect the collection of evidences and the binding of parameters; notice that only ground (derivable) evidences can be sent;
b is the set of transitions corresponding to a sending action and leading to an input state; the collection of evidences and the binding of parameters is reset; moreover, incomplete messages are lost;
c-d are the set of transitions corresponding to a Nil action leading to a non

input state and input state, respectively;
e is the set of transitions corresponding to a receiving action (leading to a non input state); for the sake of compositionality, the set includes a transition for each ground message m' unifiable with m provided that m' is not sent in a busy channel (i.e. still involved in an incomplete communication) and m' does not retime timed ground messages already belonging to the collection of evidences; since a communication might take time, the received messages is added to the compomente Ch of the location unaffecting the collection of evidences or the binding of variables; φ∆ and φΘ translates the delay and timeout, respectively, of the sequential component transition into suitable conditions on clocks;
f is the set of transitions corresponding to a receiving action leading to an input state;
g-h is the set of transitions corresponding to a True triggered transition lead- ing to a non input state and input state, respectively;
i is the set of transitions representing the completion of the transmission of a message (the transition checks the clock associated with the transmis- sion channel α against the expected transmission duration of the channel given by λ(α)); the location is altered by removing the message from the component Ch and by updating accordingly the set of evidences KwS;
j is the set of transitions which handle the disclosure of a (sub)message of the form ∆ (m) or Iτ' (m); after the disclosure, m belongs to the set of (derived)
τ	τ
evidences;
k is the set of transitions which handle the expiration of a (sub)message of the form Θτ (m); after the expiration, m is replaced in the set of (derived) evidences by †(m);
l-m are the sets of transitions which handle the disclosure and expiration, respectively, of messagges in Ch (i.e messages whose transmission has not yet been completed).
Moreover, notice that location invariants ensure that completion of commu- nication, disclosure and expiration of messages are not delayed beyond their specified timeout.
Let us consider now the translation of a MTA G = ⟨C1,..., Cn, λ, η⟩. Assuming that TC(Ci) = ⟨TSi,TSIi, CKi,TIi,Tδi⟩, the Timed Automa-
ton associated with G is

TG = ⟨T Q, T Q0, CK,TI,Tδ⟩, where

TQ = {⟨ts1,... , tsn⟩ : tsi ∈ TSi, 1 ≤ i ≤ n};

T Q0 = {⟨ts1,... , tsn⟩ : tsi ∈ TSIi, 1 ≤ i ≤ n};
CK =  n	CKi;

TI is such that TI(⟨ts1,... , tsn⟩) =  n
(TIi(tsi));

Tδ is the union of the following sets of transitions:
α,φ1∧φ2 ,β1∪β2
{⟨ts ,... , ts ⟩	⟨ts' ,... , ts' ⟩ : there are i and j (1 ≤ i, j ≤
1	n	−→	1	n
n) such that tsi = ⟨KwSi, Chi, si, ρi⟩ and tsj = ⟨KwSj, Chj, sj, ρj⟩,

?α(m),φi,βi	'
!α(m'),φj,βj	'

there are transitions tsi
−→	tsi and tsj
−→	tsj ,

ts' = ⟨KwS', Ch', s', ρ'⟩ with ⟨α, m, m', ⟩∈ Ch', and
i	i	i	i	i	i
tsk = ts' , for any k /= i and k /= j};

{⟨ts ,... , ts
є,φi,λi
ts' ,... , ts' ⟩ : there is i such that ts
a,φi,γi ts' ,

1	n⟩
−→ ⟨ 1	n
i −→	i

with a ∈ {ϵ, True, Nil} and tsk = ts' , for any k /= i.

Verification
In this section we present the translation of the MTA for the considered Non- Repudiation Protocol into the corresponding Timed Automaton, and then we show how the fairness property can be checked on the Timed Automaton itself. With reference to Figure 4, in each node-location li, with 1 ≤ i ≤ 6,
the knowledge of the participants is denoted by kwj , where P ∈ {A, B} and j
is used to remark the change (in particular the increase) of the knowledge of
P . Note that this knowledge increases after any occurences of a receive action (labelled by a question mark on the incoming edge). The timed automaton is developed according to the matchings of the actions in the MTA: l1 is the starting location, then Alice sends the commitment C to Bob (action
A2) yielding to l2 and so on until localtion l6 is reached. At this point the designers of the protocol have given two options, either the optimistic one in
which Alice and Bob cooperates, there are no delays on the involved channels and both get their own evidence or something goes wrong (a channel delay or a participant is dishonest) and the TTP must intervene. Here is where our tool plays a crucial role, as these two scenarios may interleave leading to an undesired or better, an unpredictable run of the protocol (see Figure 5 where we have exploited the labels introduced in the specification of the protogol given in Figure 1, 2 and 3). Note that the triggers/actions A8 < T1 < T2 may interleave with B3 < B4, where the symbol < is a precedence relation over the set of triggers and actions, (that is for example meaning that A8 must occur before T1). In the figure we have omitted the locations where the protocol halts for simplicity reasons. Actually, we have drawn only one of these locations (l11), namely the one indicating that both Alice and Bob have received the evidences from the TTP. The dotted edges indicates that, from

that point on, A5, B5 and A9 may interleave: for instance, Alice may receive
EOR K from Bob while Bob is receiving con K from the TTP.












l4	l5	l6
Fig. 4. The first part of the resulting Timed Automata


Fig. 5. The last part of the resulting Timed Automata


Verification of the fairness property. We have modelled a protocol by a Timed Automaton. A run of the protocol is a (finite) sequence of states of the TA, where each state is determined by both a location and the current values of the clocks. If we label the locations with sets of atomic propositions,

we can check properties of the runs, expressed as (T)CTL formulas. In the example of non-repudation protocol we have considered, we are interested in verifying whether the fairness property is satisfied. Recall from section 2 that
the fairness property requires that no party can get any advantage over the
other: if one receives the desired evidence (either the evidence of the origin or that one of the receipt), then eventually the other party receives her/his evidence, too. The atomic propositions (AP) mark whether a participant in a given location has got a fragment of his/her evidence:
AP = {EOR , EOR K , EOO , EOO K , CONA K , CONB K }.
Each location is labelled with those atomic propositions which evaluates to true in it and inherits the propositions from its ancestors (note that the TA is a dag). For example, the location l2 and the successive locations are labelled
by EOO , denoting that Bob has got the evidence of the origin, the location
l4 and its successors are labelled by EOR , the successors of l7 are labelled by EOO K , and those of l11 are labelled by CONA K . Note that this labelling can be automatically deducted from the knowledge of the participants.
Verifying the fairness property for Alice amounts to check the following CTL formula:

∀ (NRO =⇒ ∀  NRR , where
NRO = EOO ∧ (EOO K ∨ CONB K ) and
NRR = EOR ∧ (EOR K ∨ CONA K )
This formula expresses the requirement that, for each run of the protocol, whenever Bob gets his evidence, constituted by NRO , then eventually Alice gets her evidence NRR . Viceversa, the fairness property for Bob is given by the following formula, expressing the requirement that if Alice gets her evidence, NRR , then eventually Bob gets his evidence NRO :

∀ (NRR =⇒ ∀  NRO ).

To check fairness property for Alice assume, for simplicity, that she has an honest behaviour: upon the receipt of a message, she immediately sends the message according to the protocol specification. Bob, instead, may delay
sending the message. Clearly, the TTP acts immediately upon the receipt of the request of its intervention. As regards the channels, let us make first the somewhat realistic assumption that all channels are resilient: there is an unknown finite bound on the time elapsing between the sending and the re- ceiving of a message on a channel. Under this hypothesis the fairness property is not ensured to hold. Let us see how our setting automatically detects this drawback.

Consider a run going through the location l7, taking the transition A8 at time T − d for some d > 0, and getting stuck in l8 for a period of time greater than d (this is possible since the channel β is resilient and, moreover, Bob may delay the action B4). The run then stops, since no further transition can be taken (recall that the transitions are triggered by the time constraint
Ck ≤ T ). In this run the fairness property is not satisfied as NRO holds in a
state with location l7, whatever values the clocks have, but there are no states in the run satisfying NRR , since no locations labelled by EOR K or CONA K are reachable from l7 (see Figure 5).
Assume now that channels β and γ are operational and let δ be the max- imum delay for β (the maximum time a message can take to be transmitted over β). The timed automaton obtained from the specification of the protocol turns out to be slightly different, as there are now time constraints in some locations (for example in l8) forcing the run to exit within δ time units. It is easy see that also with this modification there is a run for which the fairness property does not hold: consider the transition A8 from l7 taken at a time T − d, for some d < δ, and let a run idle in l8 for a time dR, with d < dR < δ. Similar arguments can be used for channel β.
Thus, we can conclude that in both cases the given specification leads to unfair behaviours, even when an operational channel is considered to link both Alice and Bob to the TTP. In a correct specification the actions A8 and A4 must be triggered within a time-out of T − 2δ. In this way a run going
through l8 eventually reaches a location labelled by EOR K or CONA K . Let
us remark that these modifications on the protocol are sufficient also to ensure the fairness property for Bob.

Conclusions
In this paper we have introduced a simple, graphical specification formalism to specify security protocols. There are two main advantages of this approach. First, the specification language is very close to the specification style of the protocol designer and allows the explicit representations of protocol parties and communication among parties. Moreover, a protocol specified with this formalism can be automatically translated into a Timed Automaton, in such a way that a security property, expressed by formulas in a temporal logic, can be checked using standard model checking techniques.
In the non-repudiation protocol considered in this paper, an adversary can be seen as a dishonest party. Some kinds of dishonest behaviour of one party can be modelled by an augmentation phase (implemented as preprocessing) before the translation from the MTA into a resulting TA. For instance, a

dishonest behaviour could be the one in which each party can take any action of the protocol whenever he/she wants, disregarding the order dictated by the protocol.
It is our intention to enrich in the future the specification language in such a way that an adversary can be taken into consideration in any other kinds of protocols.
In Timed Automata, transitions are constrained with timing requirements where only numerical constants can appear. With Parametric Timed Au- tomata (see [1]), whose transitions are constrained with parametric timing requirements, more realistic situations can be described. We claim that this model is attractive also when security protocol are dealt with and thus the translation of our specification language into a subclass of Parametric Timed Automata can be an interesting further extension of our work.

References
R. Alur, T. Henzinger, M. Vardi, Parametric real-time reasoning, STOC 1993, pp.592-601.
R. Alur, D. Dill, A theory of timed automata, Theoretical Computer Science, 126, pp. 183-235, 1994.
R. Barbuti, N. De Francesco, A. Santone, L. Tesei, A Notion of Non-Interference for Timed Automata, Fundamente Informaticae ,51 2003 pp. 1 -11.
C. Daws, A. Olivero, S. Tripakis, S. Yovine, The tool KRONOS, In Hybrid Systems III: Verification and Control, LNCS 1066, pp. 208-219, 1996.
R. Gorrieri E. Locatelli, F. Martinelli, A simple Language for Real Time Cryptographic Protocol Analysis, ESOP 2003, LNCS 2618, pp. 114-128, 2003-03-27
R. Lanotte, A. Maggiolo-Schettini, S. Tini, Timed Information Flow for Timed Automata, submitted.
K. Larsen, P. Petterson, W. Yi, UPPAL in a nutshell, Springer International Journal of Software Tools for Technology Transfer, 1, 1997.
C. Meadows, Formal methods for cryptographic protocol analysis: emerging issues and trends.
IEEE Journal On Selected Area in Communications, 21, 2003
J. Zhou, D. Gollmann, An Efficient Non-repudiation Protocol, 10-th Computer Security Foundation Workshop (CSFW’97), Rockport, Massachusets, USA, 126–132, 1997.
