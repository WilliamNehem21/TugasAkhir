Electronic Notes in Theoretical Computer Science 125 (2005) 13–23  
www.elsevier.com/locate/entcs


A Practical Approach to Partial Functions in CVC Lite *
Sergey Berezina Clark Barrettb Igor Shikanianb Marsha Chechikc  Arie Gurfinkelc  David L. Dilla
a Stanford University, {berezin,dill}@stanford.edu
b New York University, {barrett,chikania}@cs.nyu.edu
c University of Toronto, {chechik,arie}@cs.toronto.edu


Abstract
Most verification approaches assume a mathematical formalism in which functions are total, even though partial functions occur naturally in many applications. Furthermore, although there have been various proposals for logics of partial functions, there is no consensus on which is “the right” logic to use for verification applications. In this paper, we propose using a three-valued Kleene logic, where partial functions return the “undefined” value when applied outside of their domains. The particular semantics are chosen according to the principle of least surprise to the user; if there is disagreement among the various approaches on what the value of the formula should be, its evaluation is undefined. We show that the problem of checking validity in the three-valued logic can be reduced to checking validity in a standard two-valued logic, and describe how this approach has been successfully implemented in our tool, CVC Lite.
Keywords: CVC, Kleene, partial functions, three-valued logic


Introduction
First-order logic is an invaluable tool for modeling properties and behaviors of systems. Recent progress in automated reasoning and theorem proving has led to a broader and more successful application of logic as a tool for analyzing

 This research was supported by GSRC contract DABT63-96-C-0097-P00005, and by Na- tional Science Foundation CCR-0121403. The content of this paper does not necessarily reflect the position or the policy of GSRC, NSF, or the Government, and no official en- dorsement should be inferred.


1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.06.064


systems. Most standard approaches to theorem proving and deduction using first-order logic assume that all functions and predicates are total. However, many applications are more naturally modeled using partial functions and predicates.
Although it is generally agreed that a logic which can accommodate partial functions is useful for a wide variety of applications, there is general disagree- ment on which logic should be used. An overview of the different approaches can be found in [4,7]. Of the approaches which take partiality seriously as opposed to attempting a work-around, there are two main alternatives. The first allows terms to be undefined, but requires that all formulas be either true or false. The unusual feature of this approach is that a predicate applied to an undefined term is defined to be false. Although this logic preserves some nice features of classical logic (the deduction theorem, for instance), in a cer- tain sense there is a loss of information because the undefinedness does not propagate to formulas. For example, if we assume the term 1/0 is undefined, then the formula ¬P (1/0) will be valid.
The second approach is based on Kleene’s strong three-valued logic [8], and allows both terms and formulas to be undefined. This approach is more conservative in the sense that any formula which is valid in the second ap- proach will be valid in the first approach, but there are some formulas, such as ¬P (1/0), which may be valid in the first approach but will be undefined in the second.
Although a previous implementation of our theorem prover adopted the first approach [13], we prefer the second approach based on a principle of least surprise. That is, a formula should be valid only when there is no disagreement on whether that is a reasonable conclusion. This is particularly important in
verification applications, as the integrity of a system may be judged by whether a theorem about the system is valid. Furthermore, it is our experience that any theorem which really should be valid can be formulated in such a way that it is valid according to this second approach.
A more pragmatic issue that must be dealt with is that most theorem- provers are based on classical logic. Various approaches have been advocated for modifying standard theorem-proving to accommodate logics with partial functions [6,7,9,14]. However, we are interested in finding a method for sup- porting partiality without modifying the theorem prover. One way to do this is by building over- and under-approximations for the formula. This technique has been successfully applied for three-valued model-checking [3,5].
PVS (Prototype Verification System [11]) uses a completely different ap- proach which involves constructing and proving additional formulas called type correctness conditions (TCCs). The validity of TCCs guarantees that all the


relevant terms and formulas are always defined. However, TCCs in PVS can yield surprising results. For example, it is possible to have a formula of the form A ⇒ B with a valid TCC whose contrapositive ¬B ⇒ ¬A has an invalid TCC.
In this paper, we propose a technique for checking the validity of a formula in three-valued logic by reducing the problem to checking two formulas in stan- dard two-valued logic. Similarly to PVS, we construct a TCC formula whose validity implies that the original formula is always defined. After checking the TCC, we check the original formula. Both of these checks can be done using
standard two-valued logic. Note that, unlike in PVS, our method is precise in
the sense that if a TCC is invalid, the validity of the original formula is indeed undefined in the three-valued semantics.
The paper is organized as follows. Section 2 gives the syntax and semantics for our three-valued logic. Section 3 gives two fundamental theorems which justify the reduction to two-valued logic. Section 4 describes results obtained by implementing these ideas in the theorem prover CVC Lite, and Section 5 concludes.

Three-Valued Logic: Syntax and Semantics
Syntax.
Let Σ = (S, F, P, C) be a signature, where S = {s1,.. .} is a set of sorts, F = {f1,.. .}, P = {p1,.. .} and C = {c1,.. .} are sets of function, predicate, and constant symbols. Each symbol has a type built out of the sorts in Σ. Define a term t as follows:
t ::= x | c | f (t1,... , tn) | if φ then t1 else t2 endif ,
where x is a variable, and the symbols c and f are from Σ, and φ in the conditional operator is a formula. A formula φ is defined as follows:
φ ::= true | false | p(t1,... , tn) | t1 = t2 | φ1 ∨ φ2 | ¬φ1 |
if φ0 then φ1 else φ2 endif | ∃x : s. φ1,
where p is a predicate from Σ. We also use the usual syntactic abbreviations for φ1 ∧ φ2, φ1 ⇒ φ2, φ1 ⇔ φ2, and ∀x : s. φ. It is straightforward to check that a term or formula is well-sorted. We ignore this issue and simply assume that all terms and formulas are well-sorted.
It is important to distinguish the two versions of the if-then-else operator: the one for terms, and the other for formulas. Also note that the if-then-else operators are not expressible in terms of other operators or logical connectives in 3-valued logic. 1

1  The obvious 2-valued translations (φ0 ⇒ φ1)∧(¬φ0 ⇒ φ2) and (φ0∧φ1)∨(¬φ0 ∧φ2) are ac-


For our purposes, we will assume that included with every signature Σ is a set ∆ of domain formulas, one for each function and predicate symbol in Σ. The domain formula for a function symbol f is a Σ-formula with k free variables where k is the arity of f and is denoted δf [x1,... , xk]. The domain formula for a predicate symbol p of arity k is defined similarly and is denoted δp[x1,... , xk]. An instantiation of a domain formula δf with terms t1,... , tk is written δf [t1,... , tk] and denotes the result of replacing each xi with ti in the domain formula δf [x1,... , xk].
Intuitively, the domain formula for f defines the set of points where f is defined. Note that our approach assumes this set is always first-order de- finable. Fortunately, for the practical cases we consider, this is always the case. In order to have an unambiguous semantics, it is important that the domain formulas themselves always be defined. One simple way to ensure this is to require that if s is a function or predicate symbol appearing in a domain formula, then δs[x1,... , xn] = true.


Three-valued semantics with partial functions.
Given a signature Σ, a model is a pair M = ⟨A, I⟩ where A is an S-indexed family of nonempty carrier sets A = {As | s ∈ S} for each sort s in Σ, and I is an interpretation, which is a mapping from constant symbols c : s, function
symbols f : s1 × ··· × sn → s, and predicate symbols p : s1 × ··· × sn → bool
in Σ to elements cM ∈ As, partial functions f M : As1 × ··· × Asn → As, and relations pM ⊆ As1 × ··· × Asn , respectively.
Given a model M and a variable assignment e which maps each variable to an element of some As, the value of an expression (a term or a formula) α is denoted [α]]M e and is defined in Figure 1. The value of a term may be an element of some As or a distinguished value ⊥t not in any As. The value of a
formula may be true, false, or ⊥φ. We will use ⊥ to represent both ⊥t and ⊥φ
since terms and formulas are always syntactically separated from each other, and the particular kind of ⊥ is always clear from the context.
A model is required to satisfy the following additional condition imposed by the domain formulas ∆:
[[δf [x1,... , xk]]]M e = true	iff	f M is defined at ( [x1]]M e,... , [[xk]]M e).

We say that two expressions α and β are logically equivalent, and write
α ≡ β if [α]]M e = [[β]]M e for every model M and variable assignment e.

tually over- and under-approximations of the 3-valued operator if φ0 then φ1 else φ2 endif.


[[c]]M e = cM	[[x]]M e = e(x)	[true]]M e = true	[[false]]M e = false


[[f (t1,... , tn)]]M e = ⎪⎨
⎪
if [ti]]M e /= ⊥ for all i ∈ [1..n] and [δf [t1,... , tn]]]M e = true;



[[ if φ then t1
⎪⎩ ⊥	otherwise.
⎪ ⊥,	if [φ]]M e = ⊥;

else t2 endif ]]M e = ⎪⎨ [[t1]]M e, if [φ]]M e = true;
⎪⎪⎩ [[t2]]M e, if [φ]]M e = false.



[[p(t1,... , tn)]]M e = ⎪⎨
⎪
if [ti]]M e /= ⊥ for all i ∈ [1..n] and [δp[t1,... , tn]]]M e = true;



[[t1


= t2]]M
⎪⎩ ⊥	otherwise.
e = ⎨ [[t1]]M e = [[t2]]M e, if [t1]]M e /= ⊥ and [t2]]M e /= ⊥;
⎧⎩ ⊥	otherwise.
⎪⎪⎨ true, if [φ1]]M e = true or [φ2]]M e = true;

[[φ1 V φ2]]M e =
false if [φ1]]M e = false and [φ2]]M e = false;
⎪⎪⎩ ⊥	otherwise.
⎪ true, if [φ]]M e = false;

[[чφ]]M e = ⎪⎨ false if [φ]]M e = true;
⎪⎪⎩ ⊥	if [φ]]M e = ⊥.
[[ if φ then φ1	⎧⎪ ⊥,	if [φ]]M e = ⊥;
else φ2 endif ]]M e = ⎪⎨ [[φ1]]M e, if [φ]]M e = true;
⎪⎪⎩ [[φ2]]M e, if [φ]]M e = false.
[[Ex : s. φ]]M e = ⎪⎨ false, if for all a ∈ As: [[φ]]M e[x ← a] = false;
⎪⎪⎩ ⊥	otherwise.
Fig. 1. Three-valued semantics: [φ]]M e.


Semantics of if-then-else.
Notice that the interpretation of the if-then-else operator (for terms) is undefined if the condition is undefined, even if the other two children evaluate to the same value. One reason for this choice of the semantics is simply that it turns out to be practical in real applications. In real programs, if a partial function is applied to an argument outside of its domain, the program may crash or raise an exception; in other words, it results in an abnormal behavior. Therefore, detecting a possible ⊥ value in the condition of an if- then-else provides the user with useful information, namely, that the program may crash during execution under certain conditions. For example, consider the following piece of C code:
int *p = malloc(sizeof(int)); int x = (*p > 0)? y : z;
In this example, the if-then-else operator (which is (·)? ·:· in C) will cause the program to crash if p happens to be NULL, even if y = z in this particular program state. Here *p is a partial function defined over non-null pointers to integers, and returning an integer.
The logical if-then-else is defined similarly to the term if-then-else, so that DeMorgan law for negation and the if-lifting properties for any predicate sym- bol p in Σ are preserved:
ч(if φ then φ1 else φ2 endif ) ≡ if φ then чφ1 else чφ2 endif
p(if φ then t1 else t2 endif ) ≡ if φ then p(t1) else p(t2) endif

Three-Valued Validity.
The three-valued semantics can be extended to validity of formulas in the following way. A formula is considered valid, if in all models M and for all variable assignments e, [[φ]]M e = true. A formula is invalid if there is at least one such model M and one such assignment e that [φ]]M e = false. Otherwise (if the formula always evaluates to either true or ⊥) the validity is undefined.
We denote the three-valued validity as |= φ, which may hold, not hold, or be undefined.

Reduction from Three-Valued to Two-Valued Logic
Suppose we wish to determine the three-valued validity of some Σ-formula φ. Our general strategy is first to compute a formula called a Type Correctness Condition (TCC) which can be used to check whether φ can ever be undefined. If this check succeeds, that is, φ is always defined, we can then check the original formula. Both of these checks can be done using standard two-valued


logic. To justify this claim, we first introduce TCCs and then show how they can be used to determine three-valued validity.

Type correctness conditions (TCCs).
A Type Correctness Condition for a formula φ of our three-valued logic is a formula which evaluates to true iff φ is not undefined.
First, observe that if we have a term f (x), then by definition its TCC is simply δf [x]. We can generalize this to arbitrary terms or formulas quite easily. Figure 2 gives a recursive definition of Dφ, the TCC for an arbitrary formula φ.
Dx ≡ true Dc ≡ true
n
Df(t1 ,...,tn) ≡ δf [t1,... , tn] ∧  Dti
i=1
Dif φ then t1 else t2 endif ≡ Dφ ∧ (if φ then Dt1 else Dt2 endif )
Dif φ then φ1 else φ2 endif ≡ Dφ ∧ (if φ then Dφ1 else Dφ2 endif )
Dp(t1 ,...,tn) ≡ δp[t1,... , tn] ∧   Dti
i=1
Dt1 =t2 ≡ Dt1 ∧ Dt2 D¬φ ≡ Dφ
Dφ1∨φ2 ≡ (Dφ1 ∧ φ1) V (Dφ2 ∧ φ2) V (Dφ1 ∧ Dφ2 )
D∃x. φ ≡ (Ex. Dφ ∧ φ) V (∀x. Dφ)
Fig. 2. Definition of TCCs for terms and formulas.

The TCC not only identifies whether or not the formula φ is defined, but it can also be used to reduce the three-valued evaluation of φ to an evaluation in standard two-valued logic with total models.

Suppose M is a model of Σ. Let Σˆ
be equivalent to Σ except that all of

its domain formulas are true (we call such a signature a total signature and
a corresponding model a total model). Let Mˆ be a (total) model of Σˆ whose
interpretation of function and predicate symbols agrees with M wherever the

domain formulas of M are true (we call Mˆ
an extension of M ).  Finally,

let [S]]2 e denote the evaluation of an expression S in the model Mˆ
using

standard two-valued semantics. The following two theorems justify our use of TCCs. The proofs are by a straightforward induction over the structure of the formula, and are omitted due to their simplicity.



Theorem 3.1 Let S be any Σ-term or formula, and let Mˆ extension of a Σ-model M to a total model over Σˆ. Then:
[[DS]]2 e = true	⇒	[[S]]2 e = [[S]]M e.
denote an arbitrary

Mˆ	Mˆ

Theorem 3.2 Let S be any Σ-term or formula, and let Mˆ extension of a Σ-model M to a total model over Σˆ. Then:
[[DS]]2 e = false	⇒	[[S]]M e = ⊥.
denote an arbitrary

Another important property of Dφ is that if φ is represented as a DAG, then the worst-case size of Dφ as a DAG is linear in the size of φ. This is because at each step of the computation of Dφ, only a constant number of additional nodes are introduced in addition to those already in φ. This is critical for many applications where the size of φ may be very large, and even a quadratic increase over the size of φ may be unacceptable.
In practice, things are usually even better. Often, the instances of partial functions are relatively sparse, and Dφ is very small relative to φ.

Checking validity.
Theorems 3.1 and 3.2 and the procedure for constructing Dφ effectively provide an algorithm for checking whether a formula is valid (true for all
variable assignments) in a (partial) model M . All we have to do is construct a decision procedure DP that can determine whether the formula is valid in Mˆ , an arbitrary extension of M .
Suppose we want to determine whether φ is true in M . We first check Dφ, the TCC of φ. If DP(Dφ) is false, then [Dφ]]2 e = false for some assignment e, so [φ]]M e = ⊥ by Theorem 3.2. Thus, φ is not valid in M . On the other hand,
if DP(Dφ) is true, then [Dφ]]2 e = true for all e, so [[φ]]2 e = [[φ]]M e for all e by
Mˆ	Mˆ
Theorem 3.1. Thus, DP(φ) effectively determines the validity of φ in M .
This property is extremely useful from a practical implementation point of view, as we can build a decision procedure for any convenient extension of M in which all functions are total. Since evaluation and simplification are common steps in decision procedures, this eliminates the need to handle partial functions as special cases, and we can just evaluate or simplify them as we would any other function.
As a specific example, consider the model of arithmetic with division, where division by zero is undefined. Decision procedures for arithmetic often require being able to put terms in a normal form. In particular, it is desirable to be able to evaluate constant expressions to obtain constants. In the standard model where division is a partial function, there is no correct way to evaluate


1/0, but if we extend that model, say by defining division by 0 to be 0, then all constant expressions can easily be evaluated. Our approach shows that a decision procedure with this additional assumption can be used to decide validity in the model where division is a partial function.

Implementation in CVC Lite
We have implemented the three-valued Kleene semantics described above in our tool, CVC Lite [2]. CVC Lite checks the validity of formulas with respect
to a specific combination of first-order theories. The tool takes a formula φ as an input and returns Valid or Invalid.
CVC Lite is based on standard techniques for combining first-order deci- sion procedures [1,10,12], and currently supports several theories, including uninterpreted functions, arrays, and linear real arithmetic. It also has some limited support for quantifiers.
The input language of CVC Lite is typed, with support for predicate sub- typing, that is, types of the form τ ' = {x : τ | φ(x)}, where τ is a type, and
φ(x) is a quantifier-free formula over the variable x. The type τ ' is called a subtype of τ with type predicate φ. The values of any term t of type τ ' are restricted to those of type τ which also satisfy φ(t). For example, the division operator over reals is a function of type:
div : real × {y : real | y /= 0}→ real.
Note that such a function can also be considered as a partial function from (real × real) to real which is undefined when the second argument is 0.
In fact, since precise typechecking in the presence of predicate subtypes involves manipulating arbitrary logical formulas, typechecking proper is re- stricted to matching only the base types of function arguments and terms
(that is, the maximal supertypes). In particular, div(x, 0) will be type-correct, since 0 is of type real, which is the base type of the second argument.
The more precise checking of whether an input formula φ is always defined is done separately by computing Ðφ and checking for its validity. If the validity of Ðφ cannot be established, CVC Lite returns a type error.
If Ðφ is valid, then φ is checked for validity as if it is a formula in the classical two-valued logic where all functions are total. As described above, the decision procedure for arithmetic can extend div to be a total function without compromising the correctness of the result. As an example, consider
the following formula:
φ0 ≡ div(x, y) = div(x, y),


where x and y are variables of type real. This formula is clearly valid in classical two-valued logic. However, the TCC for this formula, Ðφ0 ≡ y /= 0, is not valid, and therefore, the validity of φ0 in the three-valued semantics in undefined. CVC Lite detects this and returns a type error.
However, adding a condition that y /= 0 makes the formula valid in three- valued semantics:
φ1 ≡ y /= 0 ⇒ div(x, y) = div(x, y),

since its TCC:
Ðφ1 ≡ (true л ч(y /= 0)) V (y /= 0 л div(x, y) = div(x, y)) V (true л y /= 0) is trivially true due to the first and the last disjuncts. 2
In fact, the contrapositive of that formula is also valid in the three-valued semantics for exactly the same reason, even though this version of the formula may look somewhat startling to a mathematician:
φ2 ≡ div(x, y) /= div(x, y) ⇒ y = 0.
CVC Lite correctly proves that both formulas are indeed Valid.
From the implementation point of view, the approach was extremely easy to code: it took only a few hours to implement and debug. Furthermore, checking TCCs does not noticeably affect the performance of the tool on clas- sical examples (without subtypes or partial functions), as the TCCs of such formulas immediately simplify to true. How it affects the performance on large examples with partial functions still remains to be seen.

Conclusion
We have proposed a three-valued Kleene logic for use in applications which are most naturally modeled using partial functions. We have shown how the question of checking validity of formulas in this logic can be solved by checking the formula and a Type Correctness Condition whose size is linear in the size of the original formula. Both of these checks can be done using standard two-valued semantics.
We have a prototype implementation of these ideas in the theorem-prover CVC Lite. Our implementation was able to determine three-valued validity

2 Recall, that ψ1 ⇒ ψ2 ≡ (чψ1 V ψ2), and the TCC for the implication is the same as the TCC for the corresponding disjunction.


and invalidity of small examples. We plan to use these ideas to test larger examples in CVC Lite.
Future work includes using these ideas to develop a more general notion of validity in the presence of theories with sorts and sub-sorts and dealing with non-strict functions and predicates (those which, like the Boolean operators л and V do not have the property that if one of their children evaluates to ⊥, then the whole expression evaluates to ⊥).

References
C. Barrett. Checking Validity of Quantiﬁer-Free Formulas in Combinations of First -Order Theories. PhD thesis, Stanford University, 2003.
Clark Barrett and Sergey Berezin. CVC Lite: A new implementation of the cooperating validity checker. In Proceedings of the 16th International Conference on Computer Aided Veriﬁcation (CAV), April 2004. To appear.
G. Bruns and P. Godefroid. “Model Checking Partial State Spaces with 3-Valued Temporal Logics”. In Proceedings of Proceedings of 11th International Conference on Computer-Aided Veriﬁcation (CAV’99), volume 1633 of LNCS, pages 274–287, Trento, Italy, 1999. Springer.
William M. Farmer. A Partial Functions Version of Church’s Simple Theory of Types. The Journal of Symbolic Logic, 55(3):1269–1291, 1990.
A. Gurfinkel and M. Chechik. “Multi-Valued Model-Checking via Classical Model-Checking”. In Proceedings of 14th International Conference on Concurrency Theory (CONCUR’03), volume 2761 of LNCS, September 2003.
M. Kerber and M. Kohlhase. A Mechanization of Strong Kleene Logic for Partial Functions. In A. Bundy, editor, 12th International Conference on Automated Deduction, volume 814 of LNAI, pages 371–385. Springer Verlag, 1994.
M. Kerber and M. Kohlhase. Mechanising Partiality without Re-Implementation. In 21st Annual German Conference on Artiﬁcial Intelligence, volume 1303 of LNAI, pages 123–134. Springer Verlag, 1997.
S. C. Kleene. Introduction to Metamathematics. New York: Van Nostrand, 1952.
Francisca Lucio-Carrasco and Antonio Gavilanes-Franco. A First Order Logic for Partial Functions. In Proceedings STACS’89, volume 349 of LNCS, pages 47–58. Springer, 1989.
G. Nelson and D. Oppen. Simplification by cooperating decision procedures. ACM Transactions on Programming Languages and Systems, 1(2):245–57, 1979.
N. Shankar, S. Owre, and J. M. Rushby. PVS Tutorial. Computer Science Laboratory, SRI International, Menlo Park, CA, 1993. Also appears in Tutorial Notes, Formal Methods Europe’93: Industrial-Strength Formal Methods, pages 357–406, Odense, Denmark, April 1993.
R. Shostak. Deciding combinations of theories. Journal of the Association for Computing Machinery, 31(1):1–12, 1984.
Aaron Stump. Checking Validities and Proofs with CVC and flea. PhD thesis, Stanford University, 2002.
Pawel Tichy. Foundations of partial type theory. Reports on Mathematical Logic, 14:59–72, 1982.
