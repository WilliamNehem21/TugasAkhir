Electronic Notes in Theoretical Computer Science 179 (2007) 31–46	
www.elsevier.com/locate/entcs

Through Modeling to Synthesis of Security Automata1
Fabio Martinell2
Istituto di Informatica e Telematica - C.N.R., Pisa, Italy
Ilaria Matteucci3
Istituto di Informatica e Telematica - C.N.R., Pisa, Italy
Dipartimento di Scienze Matematiche ed Informatiche, Universit`a degli Studi di Siena

Abstract
We define a set of process algebra operators, that we call controller operators, able to mimic the behavior of security automata introduced by Schneider in [17] and by Ligatti and al. in [3]. Security automata are mechanisms for enforcing security policies that specify acceptable executions of programs.
Here we give the semantics of four controllers that act by monitoring possible un-trusted component of a system in order to enforce certain security policies. Moreover, exploiting satisfiability results for temporal logic, we show how to automatically build these controllers for a given security policy.
Keywords: partial model checking, safety properties, automated synthesis of controllers.


Overview
Recently, several papers tackled the formal definition of mechanisms for enforcing security policies (e.g., see [2,3,6,10,11,17]). A security policy specifies acceptable executions of programs. Examples of security policies are information flow, avail- ability, access control and so on (see [17]).
The focus of this paper is the study of enforcement mechanisms introduced by Schneider in [17] and security automata developed by Ligatti and al. in [3,6]. Security automata monitor execution steps of some system, herein called the target,

1 Work partially supported by CNR project “Trusted e-services for dynamic coalitions” and by EU-funded project “Software Engineering for Service-Oriented Overlay Computers”(SENSORIA) and by EU-funded project “Secure Software and Services for Mobile Systems ”(S3MS).
2 Email: Fabio.Martinelli@iit.cnr.it
3 Email: Ilaria.Matteucci@iit.cnr.it

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.08.029

and terminate the target’s execution if it is about to violate the security policy being enforced.
Here we model these security automata by process algebra operators (see [12]), acting as controller operators. We propose a logical approach to the problem of monitoring systems in order to enjoy security policies. As matter of fact, we express security policies by a temporal logic formula and we exploit a huge theory of process algebra and temporal logic in order to synthesize controller operators.
In [17], Schneider defined security automata as a triple (Q, q0, δ) where Q is a set of states, q0 is the initial state and, being Act the set of security-relevant actions, δ : Act × Q → 2Q is the transition function. A security automaton processes a sequence of actions a1a2 ... one by one. For each action, the current global state
Q' is calculated, by initially starting from {q0}. As each ai is read, the security automaton changes Q' in  q∈Q' δ(ai, q). If the automaton can make a transition on a given action, i.e. Q' is not empty, then the target is allowed to perform that action. The state of the automaton changes according to transition rules. Otherwise
the target execution is terminated. A security property that can be enforced in this way corresponds to a safety property (according to [17], a property is a safety one, if whenever it does not hold in a trace then it does not hold in any extension of this trace).
Starting from the work of Schneider described above, Ligatti and al. in [3,6] have defined four different kinds of security automata which deal with finite sequences of actions: the truncation automaton which can recognize bad sequences of ac- tions and halts program execution before a security property is violated, but cannot otherwise modify program behavior. The behavior of these automata is similar to the behavior of security automata of Schneider. The suppression automaton can suppress individual program actions without terminating the program outright in addition to being able to halt program execution. The third automaton is the insertion automaton. It is able to insert a sequence of actions into the program actions stream as well as terminate the program. The last one is the edit auto- maton. It combines the power of suppression and insertion automaton hence it is able to truncate actions sequences and can insert or suppress security-relevant actions at will.
In this paper we introduce four process algebra operators Y dK X, where X is the target, Y is the program controller, i.e. the process that controls the behavior of the target, and K is the name of the corresponding automaton. These operators are able to mimic the behavior of the security automata briefly described above.
In order to express security policies we use μ-calculus formulae because many properties of systems are naturally specified by means of fixed points and it is very expressive.
Exploiting a huge theory for security analysis based on process algebra and using satisfiability procedure for the μ-calculus, we show how to automatically synthesize program controllers Y , depending on the kind of security automata one chooses. Moreover for truncation automata we show a method to build the maximal model.
This work represents a significant contribution to the previous works (see [3,6,7,17]),

where the synthesis problem for the security automata was not addressed. In fact, most of the related works deal with the verification rather than with the synthesis problem.
Moreover, other approaches deal with the problem of monitoring the component X to enjoy a given property, by treating it as the whole system of interest. However, often not all the system needs to be checked (or it is simply not convenient to check it as a whole). Some components could be trusted and one would like to have a method to constrain only the un-trusted ones (e.g. downloaded applets). Similarly, it could not be possible to build a reference monitor for a whole distributed architecture, while it could be possible to have it for some of its components.
In our approach we actually start from a property φ that a system S must enjoy also when it is composed with a possibly untrusted component X. By using the partial model checking technique, the property φ is projected on another one, say φ', depending only on S and φ, that only the component X must satisfy. This allows
one to monitor only the necessary/untrusted part of the system, here X. Thus we can now force X to enjoy φ' by using an appropriate controller Y DK X. (Note that as a special case we have the opportunity to treat X as a whole system as in other approaches).
This paper is organized as follows. Section 2 presents the necessary background on process algebras and (Generalized) Structured Operational Semantics (GSOS), logic and security automata. Section 3 describes some process algebra operators (controllers) corresponding to security automata under investigation. Section 4 shows how to automatically build controller programs that enforce desired security policies. Section 5 shows how to build the maximal model for truncation automata. Section 6 shows a simple example and Section 7 concludes the paper.

Background
Operational semantics and process algebras
We recall a formal method for giving operational semantics to terms of a given language. This approach is called Generalized Structured Operational Semantics (GSOS) (see [4]). It permits to reason compositionally about the behavior of pro- grams (terms).
GSOS format
Let V be a set of variables, ranged over by x, y,... and let Act be a finite set of actions, ranged over by a, b,c.. .. A signature Σ is a pair (F, ar) where:
F is a set of function symbols, disjoints from V ,
ar : F '→ N is a rank function which gives the arity of a function symbol; if f ∈ F
and ar(f )= 0 then f is called a constant symbol.
Given a signature, let W ⊆ V be a set of variables. It is possible to define the set of Σ-terms over W as the least set such that every element in W is a term and if f ∈ F , ar(f ) = n and t1,... , tn are terms then f (t1,... , tn) is a term. It is also

possible to define an assignment as a function γ from the set of variables to the set of terms such that γ(f (t1,... , tn)) = f (γ(t1),... γ(tn)). Given a term t, let V ars(t) be the set of variables in t. A term t is closed if V ars(t)= ∅.
Now we are able to describe the GSOS format. A GSOS rule r has the following format:

aij
{x
y }1≤i≤k
bij
{x
1≤i≤k

i −→
ij 1≤j≤mi
i /−→}1≤j≤ni
(1)

f (x1,... ,x ) −→c
g(x, y)

where all variables are distinct; x and y are the vectors of all xi and yij variables
respectively; mi, ni ≥ 0 and k is the arity of f . We say that f is the operator of the rule (op(r)= f ) and c is the action. A GSOS system G is given by a signature and a finite set of GSOS rules. Given a signature Σ = (F, ar), an assignment ζ is effective for a term f (s1,... , sk) and a rule r if:
ζ(xi)= si for 1 ≤ i ≤ k;
aij
for all i, j with 1 ≤ i ≤ k and 1 ≤ j ≤ mi, it holds that ζ(xi) −→ ζ(yij);
bij
for all i, j with 1 ≤ i ≤ k and 1 ≤ j ≤ ni, it holds that ζ(xi) −→,
The formal semantics of terms is described by a labelled transition system (LTS, for short). that is is a pair (E , T ) where E is the set of terms and T is a ternary relation T ⊆ (E × Act × E), known as a transition relation. The transition relation among
closed terms can be defined in the following way: we have f (s1,... , sn) −→c	s iff
there exists an effective assignment ζ for a rule r with operator f and action c such that s = ζ(g(x, y)). There exists a unique transition relation induced by a GSOS system (see [4]) and this transition relation is ﬁnitely branching.
An example: CCS process algebra
CCS of Milner (see [13]) is a language for describing concurrent systems. Here, we present a formulation of Milner’s CCS in the GSOS format.
The main operator is the parallel composition between processes, namely E  F because, as we explain better later, it permits to model the parallel composition of processes. The notion of communication considered is a synchronous one, i.e. both processes must agree on performing the communication at the same time. It is modeled by a simultaneous performing of complementary actions that is represented by a synchronization action (or internal action) τ .
Let L be a finite set of actions, L¯ = {a¯ | a ∈ L} be the set of complementary actions where¯is a bijection with a¯ = a, Act be L∪ L¯ ∪ {τ }, where τ is a special
action that denotes an internal computation step (or communication) and Π be a set of constant symbols that can be used to define processes with recursion. To give a formulation of CCS dealing with GSOS, we define the signature ΣCCS = (FCCS, ar) as follows.
FCCS = {0, +, } ∪ {a.|a ∈ Act}∪ {\L|L ⊆L ∪ L¯} ∪ {[f ]|f : Act '→ Act}∪ Π.
The function ar is defined as follows: ar(0) = 0 and for every π ∈ Π we have
ar(π)= 0,  and + are binary operators and the other ones are unary operators.

Prefixing:	a	Choice:
a.x −→ x
x −a→ x'
x + y −a→ x'
y −a→ y'
x + y −a→ y'

Parallel:
x −a→ x'
y −a→ y'
x −→l
x'	y	¯l	y'

x −a→ x'	x −a→ x'

Restriction:
x\L −a→ x'\L	Relabeling:
f (a)  '

x[f ] −→ x [f ]

Table 1
GSOS system for CCS.

The operational semantics of CCS closed terms is given by means of the GSOS system in table 1 and it is described by an LTS. We denote by Der(E) the set of derivatives of a (closed) term E, i.e. the set of process that can be reached through the transition relation. Informally, a (closed) term a.E represents a process that performs an action a and then behaves as E. The term E + F represents the non- deterministic choice between the processes E and F . Choosing the action of one of the two components, the other is dropped. The term E  F represents the parallel composition of the two processes E and F . It can perform an action if one of the two processes can perform an action, and this does not prevent the capabilities of the other process. The third rule of parallel composition is characteristic of this calculus, it expresses that the communication between processes happens whenever both can perform complementary actions. The resulting process is given by the parallel composition of the successors of each component, respectively. The process
E\L behaves like E but the actions in L ∪ L¯ are forbidden. To force a synchroniza-
tion on an action between parallel processes, we have to set restriction operator in conjunction with parallel one. The process E[f ] behaves like the E but the actions are renamed viaf .

Behavioral relation: Simulation
It is often necessary to compare processes that are expressed using different terms in order to understand if there exists some behavioral relation between two processes and which one (see [13]).
We present the notion of observational relation as follows.
E ⇒τ E' (or E ⇒ E') if E →τ ∗ E' (where τ ∗ is the reflexive and transitive closure

of the →τ
relation); E ⇒a
E' if E ⇒τ →a ⇒τ
E'. 4

Now we are able to give the following definition.
Definition 2.1 Let (E , T ) be an LTS of concurrent processes, and let R be a binary relation over a set of process E. Then R is said to be a simulation (denoted by ≤)
if, whenever (E, F ) ∈ R, if E →a E' then ∃F ' ∈E s.t. F ⇒a F ' and (E',F ') ∈ R.

4	τ	a	'  τ	'	'
Note that it is a short notation for E ⇒ Eτ → Eτ ⇒ E where Eτ and Eτ denote intermediate states (not relevant in our framework).



 T)' = S	 F)' = ∅	 X)' = ρ(X)	 A1 ∧ A2)' =  A1)' ∩ A2)'
ρ	ρ	ρ	ρ	ρ	ρ
 A1 ∨ A2)' =  A1)' ∪  A2)'	 ⟨a⟩A)' = {s | ∃s' : s →a s' and s' ∈  A)' }
ρ	ρ	ρ	ρ	ρ

 [a]A)'
= {s | ∀s' : s →a
s' implies s' ∈  A)' }

We use H to represent union of disjoint environments. Let ρ be the environment ( a function from variables to values) and σ be in {μ, ν}, then σU.f (U ) represents the σ fixpoint of the function f in one variable U .
 ϵ)ρ = []   X =σ AD')ρ = D')(ρH[U '/X]) H [U '/X]

where U ' = σU. A)'
'	and ρ'(U )= D')(ρH[U/X]).

(ρH[U/X]Hρ (U ))
It informally says that the solution to (X =σ A)D is the σ ﬁxpoint solution U ' of
 A) where the solution to the rest of the lists of equations D is used as environment.


Table 2 Equational μ-calculus
Equational μ-calculus and partial model checking
Equational μ-calculus is a process logic well suited for specification and verification of systems whose behavior is naturally described using state changes by means of actions. It permits to express a lot of interesting properties like safety and liveness properties, as well as allowing to express equivalence conditions over LTS. In order to define recursively the properties of a given system, this calculus uses fixpoint equations. Let a be in Act and X be a variable ranging over a finite set of variables
V . As we have already said, equational μ-calculus is based on fixpoint equations that substitute recursion operators. X =μ A is a minimal fixpoint equation, where A is an assertion (i.e. a simple modal formula without recursion operator), and X =ν A is a maximal fixpoint equation. The syntax of the assertions (A) and of the lists of equations (D) is given by the following grammar:
A ::= X | T | F | A1 ∧ A2 | A1 ∨ A2 | ⟨a⟩A | [a]A D ::= X =ν AD | X =μ AD | ϵ
where the symbol T means true and F means false; ∧ is the symbol of the standard
conjunction of formulae, i.e. A1 ∧ A2 holds iff both of the formulae A1 and A2 hold, and ∨ is the disjunction of formulae, so A1 ∨A2 holds when at least one of A1 and A2 holds. Moreover ⟨a⟩A is the (possibility operator). It means that “exists a transition labeled by a after that A holds”. On the other hand, [a]A is the (necessity operator) and means “for all transitions labeled by a, A holds”. Roughly, the semantics D) of the list of equations D is the solution of the system of equations corresponding to D . According to this notation, D)(X) is the set of values of the variable X, and E |= D ↓ X can be used as a short notation for E ∈ D)(X). The formal semantics is in Table 2. The following standard result of μ-calculus will be useful in the reminder of the paper.
Theorem 2.2 ([18]) Given a formula φ it is possible to decide in exponential time



X//[f ]= X	⟨a⟩A//[f ]= b:f (b)=a⟨b⟩(A//[f ])
[a]A//[f ]=  b:f (b)=a[b](A//[f ])	A1 ∧ A2//[f ]= (A1//[f ]) ∧ (A2//[f ])
A1 ∨ A2//[f ]= (A1//[f ]) ∨ (A2//[f ])	T//[f ]= T	F//[f ]= F

Table 3
Partial evaluation function for relabeling operator.

in the length of φ if there exists a model of φ and it is also possible to give an example of such model.
Partial model checking (pmc) is a technique that was originally developed for compositional analysis of concurrent systems (processes) (see [1]). In order to ex- plain how partial model checking works, we give the intuitive idea underlying it describing pmc w.r.t. the parallel operator as follows: proving that E  F satisfies a formula φ (E  F |= φ) is equivalent to proving that F satisfies a modified specifica- tion φ//E (F |= φ//E ), where //E is the partial model checking function w.r.t. the parallel composition operator (see [1] for the formal definition). The formula φ is specified by the use of the equational μ-calculus. A useful result on partial model checking is the following.
Lemma 2.3 ([1]) Given a process E  F and a formula φ we have: E  F |= φ iff
F |= φ//E .
The reduced formula φ//E depends only on the formula φ and on the process
E. No information is required on the process F which can represent a possible enemy. Thus, given a certain system E, it is possible to find the property that the enemy must satisfy to successfully attack the system. It is worth noticing that partial model checking function may be automatically derived from the semantics rules used to define a language semantics. Thus, the proposed technique is very flexible.
A lemma similar to Lemma 2.3 holds for a great range of process algebra op- erators modeled by GSOS (see [1,8]). The partial model checking functions for relabeling operator is given in Table 3.
Characteristic formulae
A characteristic formula is an equational μ-calculus formula that completely char- acterizes the behavior of a (state in an) LTS modulo a chosen notion of behavioral relation. Following the reasoning used in [5,14], we characterize a process w.r.t. simulation as follows.
Definition 2.4 Given a finite state process E, its characteristic formula (w.r.t.
simulation) DE ↓ XE is defined by the following equations: for every E' ∈ Der(E),

XE' =ν  a∈Act([a]( E

a
:E ⇒E
'' XE'' )).

The following proposition holds.

Lemma 2.5 Let E be a ﬁnite-state process and let φE,≤ be its characteristic formula
w.r.t. simulation, then F ≤ E ⇔ F |= φE,≤.
Enforcement mechanisms and Security automata
In this paper we choose to follow the approach given by Ligatti and al. in [3] to describe the behavior of four different kinds of security automata.
A security automaton at least consists of a (countable) set of states, say Q, a set of actions Act and a transition (partial) function δ. Each kind of automata has a slightly different sort of transition function δ, and these differences account for the variations in their expressive power. The exact specification of δ is part of the definition of each kind of automaton. We use σ to denote a sequence of actions, · for the empty sequence and τ 5 to represent an internal action.
The execution of each different kind of security automata K is specified by a labeled operational semantics. The basic single-step judgment has the form (σ, q) −a→K (σ', q') where σ' and q' denote, respectively, the action sequence and the state after that the automaton takes a single step, and a denotes the action produced by the automaton. The single-step judgment can be generalized to a
γ	6	'	'
multi-step judgment (σ, q) =⇒K	(σ ,q ), where γ is a sequence of actions, as fol-
lows.

(σ, q) −a→K
''	''
''	''	γ K	'	'

.	(Reflex)
a;γ	'	'
(Trans)

(σ, q) =⇒K (σ, q)
(σ, q) =⇒K (σ ,q )

The operational semantics for each security automaton is given below.
Truncation automaton. The operational semantics of truncation automata is: if σ = a; σ' and δ(a, q)= q'
(σ, q) −a→T (σ', q')	(T-Step)


otherwise
(σ, q) −τ→T (·, q)	(T-Stop)

Suppression automaton. It is defined as (Q, q0, δ, ω) where ω : Act×Q → {−, +} indicates whether or not the action in question should be suppressed (-) or emitted (+).
if σ = a; σ' and δ(a, q)= q' and ω(a, q)=+ 
(σ, q) −a→S (σ', q')	(S-StepA) if σ = a; σ' and δ(a, q)= q' and ω(a, q)= −
(σ, q) −τ→S (σ', q')	(S-StepS)

5 In [3] internal actions are denoted by ·. According to the standard notation of process algebras, we use
τ to denote an internal action.
6 Consider a finite sequence of visible actions γ = a1, ... , an. Here we use ⇒ to denote automata compu- tations. Before we use the same notation for process algebra computations. The meaning of the symbol will be clear from the context.

otherwise

(σ, q) −τ→S (·, q)	(S-Stop)

Insertion automaton. It is defined as (Q, q0, δ, γ) where γ : Act ×Q → Act ×Q that specifies the insertion of an action into the sequence of actions of the program. It is necessary to note that in [3,6] the automaton inserts a finite sequence of actions instead of only one action, i.e., using the function γ, it controls if a wrong action is performed. If it holds, the automaton inserts a finite sequence of actions, hence a finite number of intermediate states. Without loss of generality, we consider that it performs only one action. In this way we openly consider all intermediate states. Note that the domain of γ is disjoint from the domain of δ in order to have a deterministic automata.
if σ = a; σ' and δ(a, q)= q'
(σ, q) −a→I (σ', q')	(I-Step)
if σ = a; σ' and γ(a, q)= (b, q')
(σ, q) −→b  I (σ, q')	(I-Ins)


otherwise

(σ, q) −τ→I (·, q)	(I-Stop)

Edit automaton. It is defined as (Q, q0, δ, γ, ω) where γ : Act ×Q → Act ×Q that specifies the insertion of a finite sequence of actions into the program’s actions sequence and ω : Act × Q → {−, +} indicates whether or not the action in question should be suppressed (-) or emitted (+). Also here ω and δ have the same domain while the domain of γ is disjoint from the domain of δ in order to have a deterministic automata.
if σ = a; σ' and δ(a, q)= q' and ω(a, q)=+ 
(σ, q) −a→E (σ', q')	(E-StepA) if σ = a; σ' and δ(a, q)= q' and ω(a, q)= −
(σ, q) −τ→E (σ', q')	(E-StepS)
if σ = a; σ' and γ(a, q)= (b, q')
(σ, q) −→b  E (σ, q')	(E-Ins)


otherwise

(σ, q) −τ→E (·, q)	(E-Stop)

Modeling security automata with process algebra
In this section we give the semantics of some process algebra operators, denoted by Y dK X where K ∈ {T, S, I, E} 7 , that act as controller operators. These permit to control the behavior of the (possibly untrusted) component X, given the behavior of the control program Y .

Our controller operators in process algebra
Here we define our controller operators by showing their behavior trought semantics rules. We denote with E the program controller and with F the target. We work, without loss of generality, under the additional assumption that E and F never perform the internal action τ .


Truncation automata: dT

E →a

E' F →a F '

E dT F →a
E' dT F '

This operator models the truncation automaton that is similar to Schneider’s auto- maton (when considering only deterministic automata, e.g., see [3,6]). Its semantics rule states that if F performs the action a and the same action is performed by E (so it is allowed in the current state of the automaton), then E dT F performs the action a, otherwise it halts.


Proposition 3.1 Let Eq =

Σa∈Act\{τ }
,⎨ a.Eq' iff δ(a, q)= q'
, 0 othw

be the control process and let F be the target. Each sequence of actions that is an output of a truncation automaton (Q, q0, δ) is also derivable from Eq dT F and vice-versa.

Suppression automata: dS

E →a
E' F →a F '
E −−→a
E'	F →a F '

E dS F →a
E' dS F '
E dS F →τ
E' dS F '

where −a is a control action not in Act (so it does not admit a complementary action). As for the truncation automaton, if F performs the same action performed by E also E dS F performs it. On the contrary, if F performs an action a that E does not perform and E can perform the control action −a then E dS F performs the action τ that suppresses the action a, i.e., a becomes not visible from external observation. Otherwise, E dS F halts.


7 We choose these symbols to denote four operators that have the same behavior of truncation, suppression, insertion and edit automata, respectively.


Proposition 3.2 LetEq,ω = Σ




a∈Act\{τ }
,	q',ω	'
⎪⎨ −a.Eq' ,ω iff ω(a, q)= − and δ(a, q)= q'
⎪⎪, 0 othw

be the control process and let F be the target. Each sequence of actions that is an output of a suppression automaton (Q, q0, δ, ω) is also derivable from Eq,ω dS F and vice-versa.

Insertion automata: dI
E →a E'	F →a F '	E /→a E'	E −+→a.b E'	F →a F '
			 8

E dI F →a
E' dI F '
E dI F →b
E' dI F

where +a is an action not in Act. If F performs an action a that also E can perform, the whole system makes this action. If F performs an action a that E does not perform and E detects it by performing a control action +a followed by an actio b, then the whole system perform b. It is possible to note that in the description of insertion automata in [3] the domains of γ and δ are disjoint. In our case, this is guarantee by the premise of the second rule in which we have that
E −a→ E', E −+→a.b E'. In fact for the insertion automata, if a pair (a, q) is not in the
domain of δ and it is in the domain of γ it means that the action a and the state q
are not compatible so in order to change state an action different from a must be performed. It is important to note that it is able to insert new actions but it is not able to suppress any action performed by F .


Proposition 3.3 Let Eq,γ = Σ


a∈Act\{τ }
⎪⎨ +a.b.Eq' ,γ iff γ(a, q)= (b, q')
⎪⎪, 0 othw

be the control process and let F be the target. Each sequence of actions that is an output of an insertion automaton (Q, q0, δ, γ) is also derivable from Eq,γ dI F and vice-versa.

Edit automata: dE
In order to do insertion and suppression together we define the following controller operator. Its rules are the union of the rules of the dS and dI .


E →a
E'	F →a F '
E −−→a
E'	F →a F '
E →/ a
E'	E +→a.b E'	F →a F '

E dE F →a
E' dE F '
E dE F →τ
E' dE F '
E dE
F →b
E' dE F

This operator combines the power of the previous two ones.

8	+a	b	'
This means E −→ Ea −→ E . However we consider +a.b as a single action, i.e. the state Ea is hide and we do not consider it in Der(E).

Proposition 3.4 Let


Σ


,⎪ a.Eq' ,γ,ω	iff δ(a, q)= q' and ω(a, q)=+ 
⎪⎨ −a.Eq' ,γ,ω	iff δ(a, q)= q' and ω(a, q)= −

Eq,γ,ω =
q',γ,ω	'
a∈Act\{τ }
⎪, 0	otherwise

be the control process and let F be the target. Each sequence of actions that is an output of an edit automaton (Q, q0, δ, γ, ω) is also derivable from Eq,γ,ω dE F and vice-versa.
It is important to note that we introduced the control action −a in the semantics of dS and +a in the semantics of dI in order to find operators that were as similar as possible to suppression and insertion automata, respectively. Other definitions could be possible, although some attempts we made failed on defining a tractable semantics.

Synthesis of controller programs
Exploiting our framework we can build a program controller Y which allows to enforce a desired security property for any target system X. We present an extension of [10]. Here we have four different operators and in particular we have to deal with control actions.
Let S be a system, and let X be one component that may be dynamically changed (e.g., a downloaded mobile agent) that we consider a possibly untrusted one. We would like that for any actual behavior of X, the system S  X enjoys a security property expressed by a logical formula φ, i.e., ∀X (S  X) |= φ.
In order to protect the system we might simply check the correctness of each process X before it is executed or, if this is not possible (or not desirable), we may define a controller that, in any case, forces each process to behave correctly. Here, we study here how to build a program controller in order to force the unknown component to behave correctly. Thus, we want to find a control program Y such that:
∀X	(S  Y dK X) |= φ	(2)
By using the partial model checking approach proposed in [9], we can focus on the properties of Y dK X, i.e.:
∃Y ∀X (Y dK X) |= φ'	(3)
where φ' = φ//S.
In order to manage the universal quantification in (3), we prove the following proposition.

Proposition 4.1 For every K ∈ {T, S, I, E} Y dK X ≤ Y [fK] holds, where fK is a relabeling function depending on K. In particular, fT is the identity function on Act 9 and

f (a)= ,⎨ τ if a = −a
, a  othw
f (a)= ,⎨ τ if a = +a
, a  othw
f (a)= ,⎨ τ if a ∈ {+a, −a}
, a  othw

Now we restrict ourselves to a subclass of equational μ-calculus formulae that is denoted by Frμ. This class consists of equational μ-calculus formulae without
⟨ ⟩. It is easy to prove that this set of formulae is closed under the partial model checking function and the following result holds.
Proposition 4.2 Let E and F be two ﬁnite state processes and φ ∈ F rμ. If F ≤ E
then E |= φ ⇒ F |= φ.
At this point in order to satisfy the formula (3) it is sufficient to have:
∃Y	Y [fK] |= φ'
To further reduce the previous formula, we can use the partial model checking function for relabeling operator. Hence, for every K ∈ {T, S, I, E} we calculate

''	'
K	//[fK ]
. Thus we obtain:

∃Y	Y |= φ''

10	(4)

In this way, we obtain a satisfiability problem in μ-calculus that can be solved by Theorem 2.2.

Synthesis of Maximal Model
In the previous section we have shown a method to synthesize a program controller for each of controller operators defined in section 3.1. As matter of fact, we find a deterministic process that does not perform τ actions and that is a model for a given μ-calculus formula.
In this section we define the notion of maximal model w.r.t. the simulation relation and show how it is possible to synthesize a maximal program controller Y for the operator Y dT X.
We define the notion of maximal model w.r.t. the relation of simulation as follows.
A process E is a maximal model for a given formula φ iff E |= φ and ∀E' s.t. E' |= φ, E' ≤ E (see [15,16]). Informally, the maximal program controller Y is the process that restricts as little as possible the activity of the target X.

9 Here the set Act must be consider enriched by control actions.
10 Even if the process Y performs some actions τ it is possible to obtain from Y another process Y ' with only visible actions that is a deterministic model of φ.

In order to find the maximal model we exploit the theory developed by Walukiewicz in [19].
Usually the discovered model is a non-deterministic process. In order to find a deterministic model we consider a subset of formulae of F rμ without ∨. This set of formulae is called the universal conjunctive μ-calculus formulae, ∀∧μC. It is easy to prove that ∀∧μC is closed under the partial model checking function (see [5]).
Proposition 5.1 Given a formula φ ∈ ∀∧μC, a maximal deterministic model E of this formula exists.

In order to generate the maximal model E, we find a model for φ ∧ ψ where ψ = X, X =ν  α∈Act\{τ }([α]F∨ (⟨α⟩X ∧[α]X)). The formula ψ permits us to check all the actions in Act. Exploiting the theory of Walukievicz, we find a deterministic
model E for φ ∧ ψ that does not perform τ actions. It is obviously a model of φ. The following lemma holds.
Lemma 5.2 Let E' |= φ with φ ∈ ∀∧μC. Then the model of φ ∧ ψ E, is such that
E' ≤ E.
Hence E is the maximal model for φ.

A simple example
consider the following equational definition φ = Z where Z =ν [τ ]Z ∧ [a]W and W =ν [τ ]W ∧ [c]F. It asserts that after every action a, an action c cannot be performed. Let Act = {a, b, c, τ, a¯, ¯b, c¯} be the set of actions. Applying the partial
evaluation for the parallel operator we obtain, after some simplifications, the fol- lowing system of equation, that we denoted with D.
Z//S =ν [τ ]Z//S ∧ [a¯]Z//S' ∧ [a]W//S ∧ W//S'	Z//0 = T W//S' =ν [τ ]W//S' ∧ [¯b]W//0 ∧ [c]F	W//0 = T Z//S' =ν [τ ]Z//S' ∧ [¯b]Z//0 ∧ [a]W//S'
W//S =ν [τ ]W//S ∧ [a¯]W//S' ∧ [c]F where S −a→ S' so S' is b.0.
The information obtained through partial model checking can be used to enforce
a security policy. In particular, choosing one of the four operators and using its definition we simply need to find a process Y [fK], where K depend on the chosen controller, that is a model for the previous formula.
In this simple example we choose the controller operator dS. Hence we apply the partial model checking for relabeling function fS to the previous formula, that we have simplified replacing W//0 and Z//0 by T (and assumed that Y can only suppress c actions). We obtain D//fS as follows.

Z//S,f =ν [τ ]Z//S,f ∧ [−c]Z//S,f ∧ [a¯]Z// '	∧ [a]W//S,f ∧ W// '
W	'	=ν [τ ]W	'	∧ [−c]W	'	∧ [¯b]T ∧ [c]F
S ,fS	S ,fS	S ,fS
Z	'	=ν [τ ]Z	'	∧ [−c]Z	'	∧ [¯b]T ∧ [a]W	'
S ,fS	S ,fS	S ,fS	S ,fS

W//S,f
=ν [τ ]W//S,f
∧ [−c]W//S,f
∧ [a¯]W	'
S ,fS
∧ [c]F

We can note the process Y = a. − c.0 is a model of D//f
. Then, for any component

X, we have S  (Y dS X) satisfies φ. For instance, consider X = a.c.0. Looking at
the first rule of dS, we have:
(S  (Y dS X)) = (a.b.0  (a. − c.0 dS a.c.0)) −a→ (a.b.0  (−c.0 dS c.0))
Using the second rule we eventually get:
(a.b.0  (−c.0 dS c.0)) −τ→ (a.b.0  0 dS 0)
and so the system still preserves its security since the actions performed by the component X have been prevented from being visible outside.

Conclusion and Future work
We illustrated some results towards a uniform theory for enforcing security proper- ties. With this work, we extended a framework based on process calculi and logical techniques, that have been shown to be very suitable to model and verify several security properties, to tackle also synthesis problems of secure systems.
As future work we plan to implement the theory here showed in order to gen- erate the program controllers and to extend it in other application scenarios as the time-based ones.

Acknowledgement
We thank the anonymous referees of STM06 for valuable comments that helped us to improve this paper.

References
Andersen, H. R., Partial model checking, in: LICS ’95: Proceedings of the 10th Annual IEEE Symposium on Logic in Computer Science (1995), p. 398.
Bartoletti, M., P. Degano and G. Ferrari, Policy framings for access control, in: Proceedings of the 2005 workshop on Issues in the theory of security, Long Beach, California, 2005, pp. 5 – 11.
Bauer, L., J. Ligatti and D. Walker, More enforceable security policies, in: I. Cervesato, editor, Foundations of Computer Security: proceedings of the FLoC’02 workshop on Foundations of Computer Security (2002), pp. 95–104.
Bloom, B., S. Istrail and A. R. Meyer, Bisimulation can’t be traced, J.ACM 42 (1995).
Gnesi, S., G. Lenzini and F. Martinelli, Logical specification and analysis of fault tolerant systems through partial model checking, International Workshop on Software Verification and Validation (SVV), ENTCS. (2004).
Ligatti, J., L. Bauer and D. Walker, Edit automata: Enforcement mechanisms for run-time security policies, International Journal of Information Security 4 (2005).

Ligatti, J., L. Bauer and D. Walker, Enforcing non-safety security policies with program monitors, in:
10th European Symposium on Research in Computer Security (ESORICS), 2005.
Martinelli, F., “Formal Methods for the Analysis of Open Systems with Applications to Security Properties,” Ph.D. thesis, University of Siena (1998).
Martinelli, F., Partial model checking and theorem proving for ensuring security properties, in: CSFW ’98: Proceedings of the 11th IEEE Computer Security Foundations Workshop (1998).
Martinelli, F. and I. Matteucci, Partial model checking, process algebra operators and satisfiability procedures for (automatically) enforcing security properties, Presented at the International Workshop on Foundations of Computer Security (FCS05) (2005).
Martinelli, F. and I. Matteucci, Modeling security automata with process algebras and related results (2006), presented at the 6th International Workshop on Issues in the Theory of Security (WITS ’06) - Informal proceedings.
Milner, R., Synthesis of communicating behaviour, in: Proceedings of 7th MFCS, Poland, 1978.
Milner, R., “Communicating and mobile systems: the π-calculus,” Cambridge University Press, 1999.
Mu¨ller-Olm, M., Derivation of characteristic formulae, in: MFCS’98 Workshop on Concurrency, Electronic Notes in Theoretical Computer Science (ENTCS) 18 (1998).
Riedweg, S. and S. Pinchinat, Maximally permissive controllers in all contexts, in: Workshop on Discrete Event Systems, Reims, France, 2004.
Riedweg, S. and S. Pinchinat, You can always compute maximally permissive controllers under partial observation when they exist., in: Proc. 2005 American Control Conference., Portland, Oregon, 2005.
Schneider, F. B., Enforceable security policies, ACM Transactions on Information and System Security
3 (2000), pp. 30–50.
Street, R. S. and E. A. Emerson, An automata theoretic procedure for the propositional μ-calculus, Information and Computation 81 (1989), pp. 249–264.
Walukiewicz, I., “A Complete Deductive System for the μ-Calculus,” Ph.D. thesis, Institute of Informatics, Warsaw University (1993).
