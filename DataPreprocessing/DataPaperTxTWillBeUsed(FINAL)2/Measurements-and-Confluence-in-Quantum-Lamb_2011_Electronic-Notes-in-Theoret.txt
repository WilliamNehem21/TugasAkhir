

Electronic Notes in Theoretical Computer Science 270 (1) (2011) 59–74
www.elsevier.com/locate/entcs

Measurements and Confluence in Quantum Lambda Calculi With Explicit Qubits
Alejandro D´ıaz-Caroa,1, Pablo Arrighib,2, Manuel Gadellac,3 and Jonathan Grattageb,4
a Departamento de Ciencias de la Computaci´on, Universidad Nacional de Rosario, Argentina
b Laboratoire d’Informatique de Grenoble, Universit´e de Grenoble, France
c Departamento de F´ısica Te´orica, At´omica y O´ptica, Universidad de Valladolid, Spain

Abstract
This paper demonstrates how to add a measurement operator to quantum λ-calculi. A proof of the consis- tency of the semantics is given through a proof of confluence presented in a sufficiently general way to allow this technique to be used for other languages. The method described here may be applied to probabilistic rewrite systems in general, and to add measurement to more complex languages such as QML [5] or Lineal [2][3], which is the subject of further research.
Keywords: Quantum lambda calculus, Measurement, Confluence, Probabilistic rewrite system


Introduction
In the quest to develop quantum programming languages, quantum extensions of functional languages provide a promising route, hence the explosion of works on quantum lambda calculi and quantum functional languages [3][5][9][10]. The current language proposals can be split into two categories. In the first category, qubits are manipulated as pointers towards a quantum memory [7][9], thus the syntax does not provide an explicit description of the qubits. It does, however, together with a linear type system, give a convenient and coherent way to handle operations on qubits. A drawback is that the semantics of quantum operations cannot be given intrinsically in the syntax, as this would require the actual state of the quantum memory to be

1 Email: alejandro.diaz-caro@imag.fr
2 Email: pablo.arrighi@imag.fr
3 Email: gadella@fta.uva.es
4 Email: jonathan.grattage@ens-lyon.fr

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.01.006

known. In the second category of languages [3][5][10] the description of the qubits is part of the programming language, and no type system is required. An advantage here is that the entire semantics can be expressed simply as a rewrite system between terms of the language. This turns into a weakness regarding measurements, because the inherently probabilistic nature of measurement makes it difficult to express as part of a rewrite system. In fact, neither category of languages allow this feature. [3][10]
The case of Altenkirch and Grattage’s QML [5] is not so clear-cut, but it does illustrate this difficulty. QML includes measurements with an operational semantics given in terms of quantum circuits. However, the corresponding algebraic theory [1] stands only for a pure quantum subset of the language, with classical-control and measurement omitted.
Van Tonder’s λq [10] is a higher-order untyped lambda calculus which includes quantum properties. This calculus carries a history track to keep the necessary information to invert reductions, to ensure that the global computation process is unitary. It is closely related to linear logic, with the syntax being a fragment of the one introduced by Wadler [11], extended with constants to represent quantum entities such as qubits and gates. Linearity concepts are used to distinguish definite terms from arbitrary superposition terms. These syntactic markers constitute the main difference with Arrighi and Dowek’s Lineal [2][3], which is more permissive. As mentioned previously, measurement is not included in these two proposals.
The work presented here shows how to add measurement to a quantum lambda calculus with explicit qubits in an elegant manner. This is done with full details for the λq-calculus, with a proof that confluence, and hence the consistency of the operational semantics, is preserved by this extension. Although this calculus does not need a proof of confluence in the original setting, due to the fixed reduction strategy, this proof is necessary in the presence of measurement. Furthermore, it is non-trivial and has the novelty of showing the confluence in a probabilistic setting with the branching produced by the measurement. The methods illustrated here are general, and applying these techniques to QML and Lineal is in progress.

In contrast to measurement in classical mechanics, which gives the value of a given observable with an associated error, measurements in quantum mechanics have an intrinsically probabilistic character. That is, a quantum measurement can give, a priori, a certain number of results, each one with some finite probability. Moreover, the state of the system after the measurement is changed in an irreversible manner by the act of measurement. This unintuitive behaviour is of acute importance in quantum information processing.
Measurement is a key property in many quantum information processing tasks, such as quantum cryptography, superdense coding, and in quantum search algo- rithms. Not having measurements can lead to misinterpretations. Consider as an example the quantum teleportation algorithm with deferred measurement [10] as defined in Fig. 1. Here it is unclear if Alice and Bob can be physically separated, as all the channels used are quantum channels. An obvious question arises: why use

this algorithm if there is a quantum channel between Alice and Bob? Measuring the final state will result in the original logical-qubit having been transferred to Bob. The problem is not one of correctness, but of interpretation.
Secondly, understanding measurement is essential to avoid misinterpreting quan- tum computation as a whole (e.g. why quantum computation does not lead straight- forwardly to an exponential jump in complexity). This work takes the view that in order to understand the possibilities and limitations of quantum computation, measurement needs be formalised in an elegant manner. Note that the projective measurement discussed in this paper is not the only possibility for a quantum mea- surement, but it is one of the simplest. In addition, any quantum measurement can be reproduced by the action of a unitary mapping and a projective measurement.


teleport q → let (e1, e2)= epr in
let (q′, y′)= alice (q, e1) in
bob (q′, y′, e2)
where
alice (q, e1) → let (q′, y′)= cnot (q, e1) in
((H q′), y′)
bob (q′, y′, e2) → let (y′′, e′ )= cX (y′, e2) in
	 

q
|0⟩
0⟩
_  _ _ 
 
 

2	2
(q′′, y′′, e′′)
epr ≡ cnot ((H 0), 0)
Circuit for the quantum teleportation algorithm with deferred measurement


Fig. 1. Teleportation algorithm in non-extended λq .


In the second section of this paper, the process of adding measurement is shown with full details for van Tonder’s λq. The section concludes with an implementation of the teleportation algorithm in extended λq. Section 3 discusses and proves con- fluence for extended λq. Finally, section 4 closes with details of ongoing and future work.
Adding measurement
Adding a measurement operator to a quantum lambda calculus can be achieved with only small changes to the grammar. In this section we show how to change the syntax, add well-formedness rules for terms, and give the operational semantics.
Syntax
To account for measurements, the grammar of λq must be extended with a family of measurement operators MI , which measure the qubits indicated by the set I. In addition, it is necessary to make the syntax for qubits precise, because their “shape” is needed by the measurement operator. This is achieved in a manner following on from Lineal [3] and QML [5]. Regarding van Tonder’s original syntax, the only sig- nificant change is to split “constants” into qubit-constants, measurement-constants and gate-constants. The extended syntax is shown in Figure 2 and the added rules of well-formedness are given in Figure 3.

A term is a pre-term produced by the syntax in Figure 2 which follows the rules for well-formedness given by van Tonder [10] plus the rules in Figure 3. Amongst these rules note that M and Gate state that MI and cU are simply constant sym- bols. Zero and One force |0⟩ and |1⟩ respectively to be non-linear terms. Tensor and !Tensor allow tensorial products between qubits to be written. Although terms like (cU q) ⊗ q are not allowed, they are a contraction for cU⊗I (q ⊗ q). Superpo- sition provides a way of writing qubits in superpositions, and Simpliﬁcation allows subterms with the scalar factor 0 to be removed.
Note that a term with a pattern !q ⊗ q is not well-formed, but there is always an equivalent term which can express this in a well-formed way. For example, the term ! |0⟩ ⊗ (α! |0⟩ + β! |1⟩) is not well-formed, however, it is equivalent to α(! |0⟩ ⊗! |0⟩)+ β(! |0⟩ ⊗! |1⟩) which is well-formed.



t ::=	Pre-terms:
x	variable
(λx.t)	abstraction
(t t)	application
!t	nonlinear term
(λ!x.t)	nonlinear abstraction
cU	gate-constant
q	qubit-constant
MI	measurement-constant
q ::=	Qubit-constants:
|0⟩ | |1⟩	base qubit
(q ⊗ q)	tensorial product
(q + q)	superposition
α(q)	scalar product
cU ::=	Gate-constants:
H | cnot | X | Z | ... 

Fig. 2. Syntax for extended λq .



 I ⊂ N  M
▶ MI

▶ cU

Gate



Zero	One
▶! |0⟩	▶! |1⟩


 Γ ▶ q1	Δ ▶ q2 
Γ, Δ ▶ q1 ⊗ q2

2nΣ−1
Tensor	 Γ ▶!q1	Δ ▶!q2 
Γ, Δ ▶!q1⊗!q2

!Tensor


i=0
|αi|
=1	αi ∈ C,i = 0 ... 2n − 1

Superposition

▶ α0(! |0⟩ ⊗ ··· ⊗! |0⟩)+ ··· + α2n−1(! |1⟩ ⊗ ··· ⊗! |1⟩)


αr = 0,r ∈ {0,..., 2n − 1}	Γ ▶
2nΣ−1

i=0
αiqi


Simplification

Γ
i=0 i/=r
αiqi



Fig. 3. Rules for well-formedness added to λq .

Note 1 The usual let construction will be used as a useful shorthand, deﬁned as:

let x = t in u gives (λx.u) t
let !x = t in u gives (λ!x.u) t

It is interesting to note that a cloning machine such as λx.(let y = x in y ⊗ y) is syntactic-sugar for λx.((λy.y ⊗ y) x), which is forbidden by the well-formedness rules since y is linear (it cannot appear twice), and moreover there is no way to tensor variables: they can only be qubit-constants.
let can also be used over lists, as per van Tonder’s (x, y), but they are written here as a tensor product. For example, the term let x ⊗ y = M{1,2} (q1 ⊗ q2) in t is the same as let (x, y)= (M{1} q1, M{1} q2) in t. Additionally, note that x ⊗ y is used following van Tonder’s (x, y); it is an overloading of the operator ⊗, denoting both the tensor product between qubits and also list constructors.

Operational Semantics
Measurement in quantum systems is an inherently probabilistic operation. Fol- lowing Di Pierro et al. [4], where a probabilistic rewrite system is defined over a λ-calculus, the operational semantics for measurement in extended λq is defined as

follows:




M:
; (M


q =
q) →


2m−1
u=0


αuq(u)
Σ





αu  q(u)	∀i ∈ I, 1 ≤ i ≤ m



where
H	I	pw

u∈C(w,m,I)
√pw

w = 0,..., 2|I| − 1.
q(u) =!q(u)⊗!q(u) ⊗· · · ⊗!q(u) with !q(u) =! |0⟩ or ! |1⟩ for k = 1 ... m.
C(w, m, I) is the set of binary words of length m such that they coincide with w
on the letters of index I.

pw =
u∈C(w,m,I)
|αu| .

The notation t →p tj means that t goes to tj with probability p. It is instructive to look at an example of this rule in action:

2Σ5−1
 5	(u)
(u)

Example 2.1 Let m = 5, I = {2, 3, 5} and q =
u=0
αu(
!qk  ) with !qk	=! x
k=1

and x is the kth bit in the binary representation of u. According to the previous rule,
(MI q) will generate 2|I| = 8 different outputs (corresponding to the different possi- ble values of the qubits 2, 3 and 5, which are measured). Take as an example the out- put w = 2 (its 3-bit binary representation is 010). Hence, C(2, 5,I)= {4, 6, 20, 22} which are the numbers u between 0 and 25 − 1 whose binary representation is of the form x01y0 (so they coincide with w, if we compare the bits 2, 3 and 5 of u with the bits 1, 2 and 3 of w). Then, the final term is:
 α4  q(4) +  α6  q(6) +  α20 q(20) +  α22 q(22)
√p2	√p2	√p2	√p2

where
q(4) = ! |0⟩ ⊗! |0⟩ ⊗! |1⟩ ⊗! |0⟩ ⊗! |0⟩ q(6) = ! |0⟩ ⊗! |0⟩ ⊗! |1⟩ ⊗! |1⟩ ⊗! |0⟩ q(20) = ! |1⟩ ⊗! |0⟩ ⊗! |1⟩ ⊗! |0⟩ ⊗! |0⟩ q(22) = ! |1⟩ ⊗! |0⟩ ⊗! |1⟩ ⊗! |1⟩ ⊗! |0⟩

p2 =
u∈C(2,5,I)
|αu| = |α4| + |α6| + |α20| + |α22|

which represents the following quantum state:


1
√p2
(α4 |00100⟩ + α6 |00110⟩ + α20 |10100⟩ + α22 |10110⟩)

Conditional statements
Measurement as a feature is only useful if the result of the measurement can be used to determine the future evolution of the program. Hence a conditional statement similar to that given in QML is needed. However, in contrast to QML’s if statements [5], only base-qubits are allowed in the condition. This is all that is required, as the if structure is only needed to provide a way to read the output of measurements. Conditional statements are realised by adding the following to the syntax:
if t1 then t2 else t3
and the operational semantic is given by:

if ! |0⟩ then t else t → t	IF- |0⟩


if ! |1⟩ then t else t → t	IF- |1⟩
Note that as the condition may be not be a base-qubit, it is not guaranteed that the whole term will reduce.
This addition is required, as without such an if statement such as this being added to the language, this extension to measurements would have been equivalent to a simple extension from unitary constants to quantum operation constants.
Example: Teleportation algorithm
With the rules developed so far, the teleportation algorithm can be rewritten as shown in Fig. 4.
teleport q →1 let x ⊗ y = epr in


where
let b1 ⊗ b2 = M{1,2} alice q x in
bob b1 b2 y
q	•
 	,, . ,,,

alice q x →1 let r ⊗ w = cnot q ⊗ x in
((H r) ⊗ w)
bob b1 b2 y →1 zed b1 (ex b2 y)
ex b x →1 if b then (X y) else y
|0⟩	H	• r,~¸~ ,
|0⟩	r,~¸~ ,
ı   	,, . ,,,
˜`
q

zed b x →1 if b then (Z x) else x
epr ≡ cnot ((H ! |0⟩)⊗! |0⟩)
Circuit for the original quantum teleportation algorithm


Fig. 4. Teleportation algorithm in extended λq

Confluence
When defining a language, a grammar must also be provided (how to construct terms), and a semantics (how these terms compute). The semantics can be denota- tional (terms are mapped to elements of a semantic domain, each corresponding to

what is computed by the term) or operational (terms are mapped into other terms, with each transition corresponding to a computational step). Clearly it must be proved that the semantics provided is unambiguous and consistent. For example, the semantics will usually induce an equational theory upon terms (via equality in the semantics domain or by equating two terms if one reduces to the other), and it is important that this theory should not equate all terms.
In λq a consistent equational theory is given. However, adding measurement does not correspond to a simple system for equational reasoning. It is not possible to proceed by replacing terms by equal terms according to any equational theory, since measurement is a probabilistic operation, and each reduction instance could produce different terms that are impossible to reconcile in the system. In the presence of an operational semantics, a usual method of proving the consistency result is to provide a proof of confluence. This property states that the order in which the transition rules are applied does not matter to the end result, thus removing any ambiguity. In this section it is shown how such a study of confluence can still be carried through, even in the presence of probabilities. As λq provides a fixed reduction strategy, proving confluence in the original language is trivial, because there is only one possible reduction at each step. However, this is not the case in the presence of measurement, where proving confluence is non-trivial.

Deﬁnitions and lemmas
Whilst the above-mentioned probabilistic reductions are an elegant and concise way to present the operational semantics, the study of confluence is not immediate in this setting. For confluence, it is necessary to prove that if any term t can reduce to u and to v, then there exists a w such that u → w∧v → w. However, in a probabilistic calculus it could be that t →p u and t →q v, where p and q represent the probability of the respective reduction occurring, and there is no w that both u and v could reduce to. For example, given M{1}, a measurement operator in the computational basis, it follows that M{1} (α |0⟩ + β |1⟩) →|α|2 |0⟩ and M{1} (α |0⟩ + β |1⟩) →|β|2 |1⟩. However, there is no w such that |0⟩ →p w and |1⟩ →q w.
A na¨ıve way to deal with this would be to assume that if there is some normal form that can be reached with a certain probability, then by following any path it must to be possible to reach the same normal form with the same probability. How- ever, this definition is not rigorous, and not applicable to terms without a normal form. Hence, it does not allow the development of a formal proof of confluence.
Probabilistic transitions need to be abstracted out in order to allow only one possible normal form for each term, and to deal with terms without normal form. With this aim, the following definition gives a notion of confluence for probabilistic calculi:
Definition 3.1 A term ensemble {⟨ti, αi⟩} is defined as a collection of terms ti, each with an associated probability αi, such that  αi = 1.
i
Note that given a term t, it may be considered as a term ensemble {⟨t, 1⟩}.

Example 3.2 Consider the term ensemble {⟨t1, 1 ⟩, ⟨t1, 1 ⟩, ⟨t2, 1 ⟩}, where the
term t1 appears twice. By summing the probabilities of any equivalent terms, this ensemble can be identified with the more compact ensemble {⟨t1, 3 ⟩, ⟨t2, 1 ⟩}.
Remark 3.3 Throughout this paper the symbol = will be used for both α- equivalences and equalities. When referring to a set, i.e. where each element appears once, it is considered to be modulo α-equivalence.
The appropriate steps such that {⟨t, α⟩, ⟨t, γ⟩} is identified with {⟨t, α + γ⟩}
need to be taken. Definition 3.4 formalises this equivalence:
Definition 3.4 Let first be a function that takes a term ensemble and returns a set defined by
first({⟨ti, αi⟩})= {ti}
As the co-domain is a set, it allows only one instance of each element.
Let sumprob be a function that takes a term and a term ensemble and returns the sum of the probabilities associated to each instance of the term in the ensemble:
sumprob(s, {⟨ti, αi⟩})=	Σ	αj
j∈{i|ti=s}

Finally, let min be a function that takes a term ensemble and returns a term ensemble defined by

min(τ )=	 
t ∈ first τ
{⟨t, sumprob(t, τ )⟩}

A term ensemble ω1 is thus said to be equivalent to a term ensemble ω2, ω1 ≡ ω2,
iff min(ω1)= min(ω2).

Note that the definition of min is correct, as	Σ
sumprob(t, τ ) trivially sums

to 1.
t ∈ first τ

A deterministic transition rule between term ensembles can also be defined:
Definition 3.5 If X is a probabilistic rewrite system over terms, let Det(X) be
X
the deterministic rewrite system over term ensembles written → and defined as


X
{⟨t , α ⟩}

{⟨tj , α γ
⟩} iff, for each i, t →	tj ∧ Σ γ

= 1.

i	i	→
ij	i ij
i	γij ij		ij j

where all the reductions between single terms are produced by following any rule in
X, or none.
Lemma 3.6 Given a probabilistic rewrite system P, then Det(P ) preserves ensem- bles.

P
Proof. Let	t , α	and	t , α γ	be term ensembles such that	t , α	→
{⟨tjij , αiγij ⟩}. Then, by definition 3.5, ∀i Σ γij = 1.
Hence, Σ αiγij = Σ αi Σ γij = Σ αi = 1.	2
i,j	i	j	i
Using these concepts, (strong) confluence for a probabilistic rewrite system can be expressed as show in definition 3.7.
Definition 3.7 Let R be a probabilistic rewrite system. R is said to be confluent
R	R
if, for each term ensemble τ such that τ →∗ μ∧ τ →∗ ν, there exist equivalent term
R	R
ensembles ω1 and ω2 such that μ →∗ ω1 ∧ν →∗ ω2. R is said to be strongly confluent
R	R
if, for each term ensemble τ , such that τ → μ ∧ τ → ν, there exist equivalent term
R	R
ensembles ω1 and ω2 such that μ → ω1 ∧ ν → ω2.
Note that strong confluence of R implies the confluence of R, and also that the confluence of R implies the strong confluence of R∗. It is possible to extend the Hindley-Rosen lemma [6][8] to these notions of confluence, as follows:
Proposition 3.8 Let R and U be strongly confluent probabilistic rewrite systems.
R
If R and U strongly commute, that is if for each term ensemble τ such that τ → μ ∧
U	U	R
τ → ν, there exist equivalent term ensembles ω1 and ω2 such that μ → ω1 ∧ ν → ω2,
therefore R ∪ U is strongly confluent.
Theorem 3.9 allows the remaining proofs to be simplified, by showing that it is enough to prove strong confluence (commutation) for a single-term term ensemble.
Theorem 3.9 Let S and T be probabilistic rewrite systems such that:


S
∀t {⟨t, 1⟩} → μ1
{⟨t, 1⟩} → ν1
,⎬ ⇒∃ ω1 ≡ ω2 s.t.
,

T
μ1 → ω1
, ν1 → ω2


S	T
Then ∀τ, μ and ν such that τ → μ and τ → ν, there exist equivalent ω1 and ω2
T	S
such that μ → ω1 and ν → ω2.
Proof. Let τ = {⟨ti, αi⟩}, μ = {⟨uij , αiδij ⟩} and ν = {⟨vik , αiϕik ⟩} such that
S	T
τ → μ and τ → ν, i.e. for each i:


ti →S δ


uij
∧ Σ δij
j

= 1 and ti →T ϕ


vik
∧ Σ ϕik
k

=1	(1)

Consider the single term term-ensembles τi = {⟨ti, 1⟩}, and the term ensembles
μi = {⟨uij , δij ⟩} and ν = {⟨vik , ϕik ⟩}. By equation (1), for each i, τi → μi and

T	i
τi → νi. By our hypothesis, for each i there exist equivalent term ensembles ω1 =

i	i	i	i	i
T	i	S	i

{⟨w1jl , δij σjl ⟩} and ω2 = {⟨w2ks , ϕik γks ⟩} such that μi → ω1 and νi → ω2.
By taking ω1 = {⟨wi , αiδi σi ⟩} and ω2 = {⟨wi  , αiϕi γi ⟩}, it follows that

1jl
T	S
jl
i	i
2ks
ks

μ → ω1 and ν → ω2. As ∀i ω1 ≡ ω2, it is trivially the case that ω1 ≡ ω2.	2

Lemma 3.10 guarantees that equivalence between term ensembles is a congruence by adding identical context to each term in both of the ensembles:
Lemma 3.10 Given two equivalent term ensembles ω1 = {⟨ti, αi⟩} and ω2 =
{⟨sj, γj⟩} and any context C, the term ensembles τ1 = {⟨C[ti/x], αi⟩} and τ2 =
{⟨C[sj/x], γj⟩} are also equivalent.
Proof. ω1 ≡ ω2 ⇒ min(ω1)= min(ω2), defined as equal to {⟨wk, δk⟩}, then

min(τ1)=	 
t ∈ first(τ1)
{⟨t, sumprob(t, τ1)⟩}


= min
⎞
{⟨C[t/x], sumprob(t, ω1)

⎝t ∈ first(ω1)
= min ({⟨C[wk/x], δk⟩})
⟩}⎠


= min

⎝t ∈ first(ω2)
⎞
{⟨C[t/x], sumprob(t, ω2)⟩}⎠

=	 
t ∈ first(τ2)
= min(τ2)
{⟨t, sumprob(t, τ2)⟩}

and hence τ1 ≡ τ2.	2

Strong confluence for {(M), IF- |0⟩ , IF- |1⟩}
The strong confluence of the added rules is formally expressed and proved by theo- rem 3.11.
Theorem 3.11 The probabilistic reduction rules system T = {(M), IF- |0⟩ , IF- |1⟩}
is strongly confluent.
Proof. Given term ensembles τ = {⟨t, 1⟩}, μ and ν, where μ /= ν, and such that
T	T
τ → μ and τ → ν, then by proving there exist equivalent term ensembles ω1 and
T	T
ω2 such that μ → ω1 and ν → ω2, theorem 3.9 shows that this system is strongly
confluent.
This result is proved here using structural induction over t.
t = x | cU | q | MI | !tj ⇒ ∄ μ /= ν. Note that there is no rule in T that can reduce t in this case, and hence only Id is applicable, producing μ = τ . Therefore there cannot exist any ν /= μ.

ν = τ . Hence ω1 = ω2 = μ.
t = λx.tj.
Let μ = {⟨λx.ui, αi⟩} where (tj






→αi



ui), with	αi = 1, and let ν =
i

{⟨λx.vj, γj⟩} where (tj →T γ
vj) with	γj = 1.
j

By induction, there exist equivalent term ensembles ω1j
= {⟨w1 , αiβi ⟩} and

T
ωj = {⟨w2 , γjσj ⟩} such that ui →β	w1 and vj →σ
ik	k
w2 .

Hence ω1 = {⟨λx.w1 , αiβi ⟩} and ω2 = {⟨λx.w2 , γjσj ⟩} can be taken, which

are equivalent by lemma 3.10.
t = λ!x.tj, analogous to case (iii).
t = (t1 t2). Consider the following cases:
Let μ = {⟨(t1 ui), αi⟩} where t2 →T α



ui, with	αi = 1, and
i

let ν = {⟨(t1 vj), γj⟩} where t2 →T γ
vj, with	γj = 1.
j

This case is analogous to case (iii), as lemma 3.10 is applicable.
Let μ = {⟨(ui t2), αi⟩} and ν = {⟨(vj t2), γj⟩}. This follows case (a).
Let μ = {⟨(ui t2), αi⟩} and ν = {⟨(t1 vj), γj⟩}, then take ω1 = ω2 =

{⟨(ui vj), αiγj⟩}
Let t = (MI q), μ = {⟨qi, αi⟩} where (MI q) →T α
follows case (ii). ω1 = ω2 = μ.
qj, with
αi = 1. This
i

t = if t1 then t2 else t3. Consider the following cases:
Let μ = {⟨ if t1 then t2 else ui, αi⟩} where t3 →T α

ui, with	αi = 1 and
i

let ν = {⟨ if t1 then vj else t3, γj⟩} where t2 →T γ
vj, with	γj = 1.
j

This is analogous to (v.c). In fact, any combination that implies that μ
and ν are obtained by the reduction of t1, t2 or t3, is analogous to one of the subcases of case (v).
Let μ = {⟨t2, 1⟩}, and let ν = {⟨ if t1 then t2 else vj, γj⟩} where t3 →T γ

vj, with Σ γj = 1. Then take ω1 = ω2 = μ. (Analogous if t2 →T γ
μ = {⟨t3, 1⟩}).
j
vj and

Let μ = {⟨t2, 1⟩}, and let ν = {⟨ if t1 then vj else t3, γj⟩} where t2 →T γ
vj, with	γj = 1. Then take ω1 = ω2 = {⟨vj, γj⟩}. (Analogous for t3).
2

Preserving confluence
Before formalising the confluence for the whole calculus, some key examples are presented:
Cloning arguments: (λx.(x x)) (M{1} ( √1 ! |0⟩ + √1 ! |1⟩))

The problem here is that if copying a measurement is allowed, this may give different results for each measurement. However, by measuring first and then applying the abstraction, both measurements are the same. In λq, these kinds of terms are disallowed by the well-formedness rules [10]; a linear argument can appear only once in the body of a function.
Copying arguments: (λ!x.(x x)) (M{1} ( √1 ! |0⟩ + √1 ! |1⟩))
When the argument is linear, there is no rule in the operational semantics of λq that allows the application of a non-linear abstraction to a linear term. Hence, M{1} must apply first, producing a non-linear output (either ! |0⟩ or ! |1⟩).
Promoting arguments: (λ!x.(x x)) !(M{1} ( √1 ! |0⟩ + √1 ! |1⟩))
In this case copying the measurement operation twice is allowed, and this is the only applicable reduction strategy because !t terms are values in λq.

In light of the above statements, a formal proof of confluence for the entire system is required.
Lemma 3.12 ensures that, under some hypotheses, measurement is independent of context:
Lemma 3.12 Let x be a variable and let t be a linear term with only one linear

instance of x. If m
(M )
→ p v, then t[m/x]
(M )
→ p t[v/x].

Proof. Structural induction over t
Let t be such that x ∈/ V(t) ⇒ t[m/x]= t = t[v/x].
(M )
Let t = x. x[m/x]= m → p v = x[v/x].

Let t = λy.tj. By induction λy.tj[m/x] (M )
λy.tj[v/x].

Let t = λ!y.tj. Analogous to case (iii).
Let t = (t1 t2), with x	(t1).  Then (t1 t2)[m/x] = (t1[m/x] t2) and by
(M )
induction, (t1[m/x] t2) → p (t1[v/x] t2), which is equal to (t1 t2)[v/x].
Let t = (t1 t2), with x ∈ V(t2). Analogous to case (v).
Let t = if t1 then t2 else t3. Analogous to case (v).
2
Next, it is proved that the original reduction rules system from λq and the new rules for measurements strongly commute. This is suggestive of the confluence of the whole system
Theorem 3.13 The probabilistic reduction rules systems S = {(APP1), (APP2),
(β), (!β1), (!β2), (U )} and T = {(M), IF- |0⟩ , IF- |1⟩} strongly commute.
Proof. If it is proved that given term ensembles τ = {⟨t, 1⟩}, μ and ν, μ /= ν, such
S	T
that τ → μ and τ → ν, then this implies that there exist equivalent term ensembles
T	S
ω1 and ω2 such that μ → ω1 and ν → ω2, then S and T verify the hypotheses for

theorem 3.9, which proves strong commutation between them. This result is proved here using structural induction over t.
t = x | cU | q | MI | !t ⇒ ∄ μ /= ν. Note that there is no rule in T nor S that can reduce t in this case, hence only Id is applicable, producing μ = τ . Therefore there cannot exists any ν /= μ.
ν = τ . Hence ω1 = ω2 = μ. (Analogous for μ = τ ).
S	T
t = λx.tj, μ = {⟨λx.u, 1⟩} and ν = {⟨λx.vj, γj⟩} such that τ → μ and τ → ν.
By induction, there exist equivalent ωj = {⟨w1, δs⟩} and ωj = {⟨w2, σj⟩} such
1	s	2	j
T	S
that {⟨u, 1⟩} → ωj and {⟨vj, γj⟩} → ωj . Then take ω1 = {⟨λx.w1, δs⟩} and
ω2 = {⟨λx.w2, σj⟩} which are equivalent by lemma 3.10.
t = λ!x.tj. Analogous to case (iii).
t = (t1 t2). Consider the following cases:
μ = {⟨(t1 u), 1⟩} and ν = {⟨(t1 vj), γj⟩}. Analogous to case (iii); note that lemma 3.10 also holds in this case.
μ = {⟨(u t2), 1⟩} and ν = {⟨(vj t2), γj⟩}. Analogous to subcase (a).
μ = {⟨(u t2), 1⟩} and ν = {⟨(t1 vj), γj⟩}. Take ω1 = ω2 = {⟨(u vj), γj⟩}
(Similarly if t2 →1 u and t1 →γj vj).
t = (cU q) and μ = {⟨qj, 1⟩}, This follows case (ii). Note that if instead of t2 = q an expression like t2 = (MI q) is given, it is subcase (b) which applies, where u = t1 = cU .
t = (MI q) and μ = τ . This follows the analogous to case (ii).
t1 = λx.tj, μ = {⟨tj[t2/x], 1⟩}, ν = {⟨(λx.tj vj), γj⟩}. By lemma 3.12, ω1 = ω2 = {⟨tj[vj/x], γj⟩} can be taken. Note that if t1 = λ!x.tj, with the same μ, then t2 must be non-linear due to the well-formedness rules and hence in this situation it is the subcase (d).
t1 = if tj1 then tj2 else tj3. Then μ has to be obtained by the reduction of tj1, tj2, tj3 or t2, hence, it is analogous to previous cases. Note that if, for instance, ν = {⟨(tj2 t2), 1⟩} and suppose that μ is obtained by the reduction of tj3 (it cannot be the application of the if statement to t2 because there is not any rule that performs such a reduction) then ω1 = ω2 = ν.
t = if t1 then t2 else t3. Consider the following cases:
Let μ  = {⟨ if t1 then t2 else u, 1⟩} where t3 →1 u and let ν  =

{⟨ if t1 then vj else t3, γj⟩} where t2 →γj
vj and	γj = 1. Analogous
j

to (v.c). In fact, any combinations that implies that μ and ν are obtained
by reduction of t1, t2, or t3, is analogous to one of the subcases of case (v).
Let μ = {⟨ if t1 then t2 else u, 1⟩} where t3 →S 1 u and ν = {⟨t2, 1⟩}, then take ω1 = ω2 = ν. Analogous if t2 →S 1 u and ν = {⟨t3, 1⟩}.
Let μ = {⟨ if t1 then u else t3, 1⟩} where t2 →S 1 u and ν = {⟨t2, 1⟩}, then take ω1 = ω2 = {⟨u, 1⟩}. Similarly if t3 →S 1 u and ν = {⟨t3, 1⟩}.
2

It has been shown that T and S strongly commute, and hence T∗ and S∗ strongly commute. Moreover, T is confluent, and hence T∗ is strongly confluent.
Now, supposing S is confluent, it follows that S∗ is strongly confluent. Propo- sition 3.8 entails that S∗ ∪ T∗ is strongly confluent, and therefore that S ∪ T is confluent. Therefore, the extension of van Tonder’s calculus presented here pre- serves confluence.
Conclusions
This paper extends the quantum lambda calculus λq, defined by van Tonder, with a family of measurement operations MI , which measure the qubits indicated by the set I, and an if structure which allows reading of the output of these measurements. By defining the notion of ensembles of terms, and extending the rewrite system to a deterministic system between term ensembles, a proof of confluence for this extended calculus is presented. The extended calculus is therefore confluent, and retains the simplicity of van Tonder’s original calculus.
The proof of confluence follows a method which can be applied to other calculi that make use of probabilistic transition rules. For example, this method could be applied to both Lineal and to QML, and this is the subject of ongoing research.
The addition of a measurement operation to λq, which preserves confluence, is a significant development. This allows a more natural expression of quantum algo- rithms that intrinsically make use of measurement, such as quantum teleportation, superdense coding, and quantum search algorithms. Moreover, having an opera- tional semantic for measurements gives a way for understanding the behaviour of this quantum procedure, and this is a possible topic for future work.
Acknowledgement
A. D´ıaz-Caro would like to thank Pablo E. Mart´ınez L´opez for useful comments and helpful suggestions on an early draft of this paper, and the CAPP (QCG) group at the Laboratoire d’Informatique de Grenoble for their hospitality. The authors would also like to thank Simon Perdrix for fruitful discussions.

References
Altenkirch, T., J. J. Grattage, J. K. Vizzotto and A. Sabry, An algebra of pure quantum programming, Electronic Notes in Theoretical Computer Science 170 (2007), pp. 23–47.
Arrighi, P. and G. Dowek, A computational definition of the notion of vectorial space, Electronic Notes in Theoretical Computer Science 117 (2005), pp. 249–261.
Arrighi, P. and G. Dowek, Linear-algebraic lambda-calculus: higher-order, encodings and confluence, in: B. Buchberger, editor, Term Rewriting and Applications, 19th International Conference, RTA-08, To appear in LNCS (2008), eprint available at arXiv:quant-ph/0612199.
Di Pierro, A., C. Hankin and H. Wiklicky, Probabilistic λ-calculus and quantitative program analysis, Journal of Logic and Computation 15 (2005), pp. 159–179.
Grattage, J. and T. Altenkirch, A functional quantum programming language, in: LICS ’05: Proceedings of the 20th Annual IEEE Symposium on Logic in Computer Science (2005), pp. 249–258.

Hindley, J. R., “The Church-Rosser property and a result in combinatory logic,” Ph.D. thesis, University of Newcastle-upon-Tyne (1964).
Prost, F., Taming non-compositionality using new binders, in: S. G. Akl, C. S. Calude, M. J. Dinneen,
G. Rozenberg and T. Wareham, editors, UC, Lecture Notes in Computer Science 4618 (2007), pp. 150–162.
Rosen, B. K., Tree-manipulating systems and Church-Rosser theorems, Journal of the ACM 20 (1973),
pp. 160–187.
Selinger, P. and B. Valiron, A lambda calculus for quantum computation with classical control, Mathematical Structures in Computer Science 16 (2006), pp. 527–552.
van Tonder, A., A lambda calculus for quantum computation, SIAM Journal on Computing 33 (2004),
pp. 1109–1135.
Wadler, P., A syntax for linear logic, in: S. D. Brookes, M. G. Main, A. Melton, M. W. Mislove and
D. A. Schmidt, editors, Proceedings of the 9th International Conference on Mathematical Foundations of Programming Semantics (1994), pp. 513–529.
