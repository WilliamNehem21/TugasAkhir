Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 319 (2015) 183–198
www.elsevier.com/locate/entcs
Unguarded Recursion
on Coinductive Resumptions 1
Sergey Goncharov Christoph Rauch Lutz Schr¨oder
Department of Computer Science, Friedrich-Alexander-Universit¨at Erlangen-Nu¨rnberg

Abstract
We study a model of side-effecting processes obtained by starting from a monad modelling base effects and adjoining free operations using a cofree coalgebra construction; one thus arrives at what one may think of as types of non-wellfounded side-effecting trees, generalizing the infinite resumption monad. Types of this kind have received some attention in the recent literature; in particular, it has been shown that they admit guarded iteration. Here, we show that they also admit unguarded iteration, i.e. form complete Elgot monads, provided that the underlying base effect supports unguarded iteration.
Keywords: Recursion, coalgebra, coinduction, complete Elgot monad, resumptions.


Introduction
Following seminal work by Moggi [17], monads are widely used to represent com- putational effects in program semantics, and in fact in actual programming lan- guages [28]. Their main attraction lies in the fact that they provide an interface to a generic notion of side-effect at the right level of abstraction: they subsume a wide variety of side-effects such as state, non-determinism, random, and I/O, and at the same time retain enough internal structure to support a substantial amount of generic meta-theory and programming, the latter witnessed, for example, by the monad class implemented in the Haskell basic libraries [19].
In the current work, we study a particular construction on monads motivated partly by the goal of modelling generic side-effects in the semantics of reactive processes. Specifically, given a base monad T and objects (types) a, b, we have, assuming enough structure on T and the base category, a family of final coalgebras
T bX = νγ. T (X + a × γb)

1 Work supported by the DFG under project HighMoon (SCHR 1118/8-1)

http://dx.doi.org/10.1016/j.entcs.2015.12.012
1571-0661/© 2015 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

for each object X. These final coalgebras can be seen as arising in two ways: on the one hand, one may start from reactive processes sending messages of type a and receiving messages of type b (possibly terminating with results of type X), modelled as non-wellfounded a-labelled b-branching trees (with leaves labelled in X), i.e. inhabitants of νγ. (X + a × γb), and then add generic side-effects encapsulated by T to the model (e.g. non-determinism or access to a global shared memory). On the other hand, one may see a and b as the types of an uninterpreted side-effect f : a → b added to the base monad T , e.g. an I/O-operation (in fact, the interactive input and output monads originally considered as examples by Moggi [17] can be seen as generated by uninterpreted effects of this kind); if one wishes to model non- terminating programs that use f as well as side-effects from T , one obtains infinite trees of exactly the kind given by T bX. The construction of T bX from T is an infinite
a	a
version of the generalized resumption transformer introduced by Cienciarelli and
Moggi [9]. It has been termed the coinductive generalized resumption transformer by Pir´og and Gibbons [20,21], who show that on the Kleisli category of T , T b is the
free completely iterative monad generated by T (a × b).
The result that T b is a completely iterative monad brings us to the contribution of the current paper. Recall that complete iterativity of T b means that for every

morphism
e : X → T b(Y + X),

read as an equation defining the inhabitants of X, thought of as variables, as terms over the defined variables (from X) and parameters from Y , has a unique solution
e† : X → T bY
in the evident sense, provided that e is guarded. The latter concept is defined in terms of additional structure of T b as an idealized monad, which essentially allows distinguishing terms beginning with an operation from mere variables. Guardedness of e then means that recursive calls can happen only under a free operation. Similar results on guarded recursion abound in the literature; for example, the fact that T b admits guarded recursive definitions can also be deduced from more general results by Uustalu on parametrized monads [27].
The central result of the current paper is to remove the guardedness restriction in the above setup. That is, we show that a solution e† : X → T bY exists for every morphism e : X → T b(X + Y ). Of course, the solution is then no longer unique (for example, we admit definitions of the form x = x); moreover, we clearly need to make additional assumptions about T . Our result states, more precisely, that T b allows for a principled choice of solutions e† satisfying standard equational laws for recursion [25], thus making T b into a complete Elgot monad [3] 2 . The assumption on T that we need to enable this result is that T itself is an Elgot monad (e.g. partiality, nondeterminism, or combinations of these with state), i.e. we show that

2 We modify the original definition of Elgot monad, which requires the object X of variables to be a finitely presentable object in an lfp category, by admitting unrestricted objects of variables. This change is owed mostly to the fact that we do not assume the base category to be lfp, and in our own estimate appears to be technically inessential, although we have not checked details for the obvious variants of our results that arise by replacing complete Elgot monads with Elgot monads.

the class of Elgot monads is stable under the coinductive generalized resumption

transformer. We show moreover that the structure of T b
as an Elgot monad is

uniquely determined as extending that of T .
The motivation for these results is, well, to free non-wellfounded recursive def- initions from the standard guardedness constraint. Note for example that in [20], it was necessary to assume guards in all loop iterations when interpreting a while- language with actions originally proposed by Rutten [24] over a completely iterative monad. Contrastingly, given that T b is a (complete) Elgot monad, one can now just write unrestricted while loops. We elaborate this example in Section 5, and recall a standard example of unguarded recursion in process algebra in Section 6.
Preliminaries
According to Moggi [17], a notion of computation can be formalized as a strong monad T over a Cartesian category (i.e. a category with finite products). In order to support the constructions occurring in the main object of study, we work in a dis- tributive category C, i.e. a category with finite products and coproducts (including a final and an initial object) such that the natural transformation

[id × inl,id × inr]
X × Y + X × Z −−−−−−−−−−−−→ X × (Y + Z)
is an isomorphism [10], whose inverse we denote distX,Y,Z. Here we denote injections into binary coproducts by inl : A → A + B, inr : B → A + B. The projections from binary products are denoted fst : A × B → A, snd : A × B → B; pairing is denoted by ⟨, ⟩, and copairing of f : A → C, g : B → C by [f, g] : A + B → C. Unique morphisms A → 1 into the terminal object are written !A, or just !. We write |C| for the class of objects of C. Distributivity essentially allows using context variables in case expressions, i.e. in copairing.
We shall also require existence of certain exponentials, i.e. objects Xa adjoint to Cartesian products a × X, which means that for any X and Y , there is an isomorphism


curryX,Y : HomC(X × a, Y ) ∼= HomC(X, Y a),
natural in X and Y . We write uncurryX,Y for the inverse map curry−1


. The evalu-

ation morphism evX : Xa ×a → X (natural in X) is obtained as uncurryXa,X(idXa ).
We omit indices on natural transformations where this is unlikely to cause confusion.
Remark 2.1 The role of exponents in Xa is to capture a notion of arity of algebraic operations generating effects, e.g. a = 2 would correspond to binary operations such as nondeterministic choice. A more general setup would involve categories enriched over a symmetric monoidal closed category V whose objects are then treated as arities (and coarities, i.e. objects used for indexing families of operations) [13,12]. Instead of assuming existence of exponentials Xa one assumes existence of tensors a × X and cotensors Xb with a, b ∈ |V|. Cotensors are adjoint to tensors in the

same way as exponentials are adjoint to products with a constant object. We expect that our main results extend to this setting.
Recall that a monad T over C can be given by a Kleisli triple (T, η, ٨) where T is an endomap of |C| (in the following, we always denote Kleisli triples and their functor parts by the same letter, with the former in blackboard bold), the unit η is a family of morphisms ηX : X → TX, and the Kleisli lifting ٨ maps f : X → TY to f ٨ : TX → TY , subject to the equations
η٨ = id	f ٨ ◦ η = f	(f ٨ ◦ g)٨ = f ٨ ◦ g٨.

This is equivalent to the presentation in terms of an endofunctor T with natural transformations unit and multiplication. A monad is strong if it is equipped with a natural transformation τX,Y : X × TY → T (X × Y ) called strength, subject to a number of coherence conditions (e.g. [17]). Strength enables interpreting programs over more than one variable, and allows for internalization of the Kleisli lifting, thus legitimating expressions like λx. (f (x))٨ : X → (TY → TZ) for f : X → (Y → TZ), which encodes curry(uncurry(f )٨ ◦ τ ). Strength is equivalent to the monad being enriched over C [14]; in particular, every monad on Set is strong. Henceforth we shall use the term ‘monad’ to mean ‘strong monad’ unless explicitly stated otherwise.
The standard intuition for a monad T is to think of TX as the set of terms in some algebraic theory, with variables taken from X. In this view, the unit converts variables into terms, and a Kleisli lifting f ٨ applies a substitution f : X → TY to terms over X. In our setting, the ‘terms’ featuring here are often infinite; nevertheless, we sometimes call them algebraic terms for distinction from the terms in our metalanguage.
The Kleisli category CT of a monad T has the same objects as C, and C- morphisms X → TY as morphisms X → Y . The identity on X in CT is ηX; and the Kleisli composite of f : X → TY and g : Y → TZ is g٨ ◦ f .

Complete Elgot Monads
As indicated in the introduction, we will be interested in recursive definitions over a monad T; abstractly, these are morphisms
f : X → T (Y + X)
thought of as associating to each variable x : X a definition f (x) in the shape of an algebraic term from T (Y + X), which thus employs parameters from Y as well as the defined variables from X. The latter amount to recursive calls of the definition. This notion is agnostic to what happens in the case of non-terminating recursion. For example, T might identify all non-terminating sequences of recursive calls into a single value ⊥ signifying non-termination; at the other extreme, T might be a type of infinite trees that just records the tree of recursive calls explicitly.

To a recursive definition f as above, we wish to associate a solution
f† : X → TY,

which amounts to a non-recursive definition of the elements of X as terms over Y only. As we do not assume any form of guardedness, this solution will in general fail to be unique. We thus require a coherent selection of solutions f† for all equa- tions f , where by coherent we mean that the selection satisfies a standard set of (quasi-)equational properties. Formally:
Definition 3.1 (Complete Elgot monads) A complete Elgot monad is a strong monad T equipped with an operator †, called iteration, that sends any f : X → T (Y + X) to f† : X → TY satisfying the following conditions:
unfolding: [η, f†]٨ ◦ f = f†;
naturality: g٨ ◦ f† = ([T inl ◦ g, η ◦ inr]٨ ◦ f )† for any g : Y → TZ;
dinaturality: ([η ◦ inl, h]٨ ◦ g)† = [η, ([η ◦ inl, g]٨ ◦ h)†]٨ ◦ g for any g : X →
T (Y + Z) and h : Z → T (Y + X);
codiagonal: (T [id, inr] ◦ g)† = (g†)† for any g : X → T ((Y + X)+ X);
uniformity: f ◦ h = T (id +h) ◦ g implies f† ◦ h = g† for any g : Z → T (Y + Z) and h : Z → X.
Additionally, iteration must be compatible with strength in the following sense: for any f : X → T (Y + X), τ ◦ (id ×f†)= (T dist ◦ τ ◦ (id ×f ))†.
Remark 3.2 The above definition is inspired by the axioms of parametrized uni- form iterativity [25], which goes back to Bloom and E´sik [8]. Ad´amek et al. [3] define Elgot monads by means of a slightly different system of axioms: the co- diagonal and dinaturality axioms are replaced with the Beki´c identity. Both ax-
iomatizations are however equivalent, which is essentially a result about iteration theories [8, Section 6.8]. Moreover, the iteration operator in [3] is defined only for f : X → T (Y + X) with finitely presentable X, under the assumption that C is lo- cally finitely presentable; hence our use of the term ‘complete Elgot monad’ instead of ‘Elgot monad’. We have the impression that this difference is not technically essential but have not checked details for the finitary variant of our results.
In the further development, examples of complete Elgot monads will arise either as so-called ω-continuous monads (Definition 3.3) or as extensions thereof with free operations, i.e. via the coinductive generalized resumption transformer.
If T supports an iteration operator † then it is always possible to parametrize it with an additional argument to be carried over the recursion loop, i.e. we derive an operator ‡ sending f : Z × X → T (Y + X) to f‡ : Z × X → TY by
f‡ = ÄT (snd + id) ◦ (T dist) ◦ τ	◦ ⟨fst	ä†	(1) We call the derived operator ‡ strong iteration.

As indicated above, an important class of examples of complete Elgot monads arises via a suitable order-enrichment of the Kleisli category.
Definition 3.3 (ω-continuous monad) An ω-continuous monad consists of a monad T and an enrichment of the Kleisli category CT of T over the category ωCppo of ω-complete partial orders with bottom and (nonstrict) continuous maps, satisfying the following conditions:
strength is ω-continuous: τ ◦ (id × .i fi)= .i(τ ◦ (id ×fi));
copairing in CT is ω-continuous in both arguments: î.i fi, .i gió = .i[fi, gi];
bottom elements are preserved by strength and by postcomposition in CT:
τ ◦ (id ×⊥)= ⊥, f ٨ ◦⊥ = ⊥.
Example 3.4 Many of the standard computational monads on Set [17] are ω- continuous, including nontermination (TX = X + 1), nondeterminism (TX = P(X)), and the nondeterministic state monad (TX = P(X × S)S for a set S of states). On ωCppo, lifting (TX = X⊥) and the various power domain monads are ω-continuous.
Remark 3.5 As observed by Kock [14], monad strength is equivalent to enrichment over the base category. One consequence of this fundamental fact is that if C is enriched over the category ωCpo of bottomless ω-complete partial orders and ω- continuous maps (i.e. C is an O-category in the sense of Wand [29] and Smyth and Plotkin [26]), with the bicartesian closed structure enriched in the obvious sense, then CT is also enriched over ωCpo, since T , underlying a strong monad, is an ωCpo-functor (aka locally continuous functor [26]). Then T is ω-continuous in the sense of Definition 3.3 iff each Hom(X, TY ) has a bottom element preserved by strength and postcomposition in CT. This allows for incorporating numerous domain-theoretic examples by taking C to be a suitable category of predomains, and T, in the simplest case, the lifting monad TX = X⊥ (from which one builds more complex examples by the construction explored next).
If T is an ω-continuous monad, then the endomap
h '→ [η, h]٨ ◦ f

on the hom-set HomC(A, TB) is continuous because copairing and Kleisli composi- tion in T are continuous, and hence has a least fixpoint by Kleene’s fixpoint theorem. We can define an iteration operator by taking f† to be this fixpoint; in other words, f† is defined to be the smallest solution of the unfolding equation as per Defini- tion 3.1. The verification of the remaining identities is tedious but straightforward; in summary,
Theorem 3.6 On every ω-continuous monad, deﬁning iteration by taking least ﬁx- points determines a complete Elgot monad structure.
This result is unsurprising in the light of analogous facts known for so-called ω- continuous theories [8, Theorem 8.2.15, Exercise 8.2.17].

Remark 3.7 Every complete Elgot monad T can express unproductive divergence
as the generic effect
Ä	η ◦ inr	ä†
This computation never produces any effects, i.e. behaves like a deadlock. If T is ω-continuous, then unproductive divergence coincides with the least element of Hom(X, TY ), for which reason we use the same symbol ⊥ for the above morphism, but in general, there is no ordering in which unproductive divergence could be a least element.

The Coinductive
Generalized Resumption Transformer
We proceed to recall the definition of the coinductive generalized resumption trans- former [20]; for simplicity, we consider a version with only one family of free oper- ations (rather than a whole signature or, even more generally, an arbitrary endo- functor on the base category). We then prove our main result, stability of the class of complete Elgot monads under this construction (Theorem 4.5).
Given a, b ∈ |C| such that exponentials of the form Xb exist and a monad T on
C, we put
()b = a × b	and	T bX = νγ. T (X + γb);
a	a	a
i.e. T bX is the final coalgebra of T (X + (  )b ), which we assume to exist. The
a	a
assignment ()b is clearly a functor, i.e. applies also to morphisms. Intuitively, T bX
a	a
is a type of possibly non-terminating computation trees, with each node consisting
of a computation with side-effects specified by T that either returns a value in X or continues with one of a-many free operations each combining b-many subsequent computations. Let
outX : T bX → T (X + (T bX)b )
a	a	a
be the final coalgebra structure, and let coit(g) : Y → T bX denote the final mor-
phism induced by a coalgebra g : Y → T (X + Y b):
	coit(g)	
Y	zTa,X
g	outX
,	, 
T (X + Y b)	zT (,X + (T bX)b ).
a	T (X+(coit(g))b )	a	a

Intuitively, coit(g) encapsulates (in T bX) a computation tree that begins by exe- cuting g, terminates in a leaf of type X if g does, and otherwise (co-)recursively continues to execute g, forming a new tree node for each recursive call. It is easy to verify that outX is natural in X. By Lambek’s lemma, out is a natural isomorphism.
Thus, T maps into T b via
ext = T 	T inl	zT,(Id +(T b)b )	out-1	zT,b .
a a	a

We record explicitly that T b is a strong monad:
Lemma 4.1 Given a monad T and a, b ∈ |C|, T b is the functorial part of a monad
Tb , with the monad structure characterized by the following properties.
The unit ην : X → T bX is deﬁned by out ◦ ην = η ◦ inl (i.e. ην = out−1 ◦ η ◦ inl).
Given f : X → T bY , the Kleisli lifting f§ : T bX → T bY is the unique solution

a
of the equation out ◦f§
= îout ◦f, η ◦ inr(f
§ b óa٨
a
out.

Given f : X → T bY , let g = [f, ην]: X +Y → T bY ; then g§ is a ﬁnal morphism
a	§	Ä	b	b a	٨	ä
of coalgebras, namely g = coit [T (id +(Ta inr)a) ◦ out ◦g, η ◦ inr] ◦ out .
The strength τ ν : X × T bY → T b(X × Y ) is the unique solution of out ◦ τ ν =
a	a
T (id +(τ ν)b ) ◦Tδ ◦τ ◦ (id × out) where δ : X × (Y + (T bY )b ) → (X ×Y )+ (X ×
a	a	a
T bY )b is the obvious distributivity transformation:

a	a

X × T bY


  (Tδ)τ(id × out) 
zT,(X × Y + (X × T Y ) )

a	a	a

τ ν	T (id +(τ ν )b )
,	, 
T b(X × Y ) 	out	zT,(X × Y + T b(X × Y )b ).
a	a	a


This justifies calling Tb
the coinductive generalized resumption monad (over T).

The proof of Lemma 4.1 is facilitated by the fact that T (X + (  )b ) can be shown

to be a parametrized monad, which implies that Tb
is a monad [27, Theorems 3.7

and 3.9]. Alternatively, the fact that Tb
is a monad can be read off directly from

the results of [20]. What is new here is that we show that Tb is, in fact, strong, and
hence supports an interpretation of the standard computational metalanguage [17]. This amounts to showing that the strength defined in the last item satisfies the requisite laws [17]. One fact of potentially independent interest used in the (quite involved) proof of these laws is
Lemma 4.2 For any functor G : B → C, outG : T bG → T (G +(T bG)b ) is the ﬁnal

T (G + Idb )-coalgebra in [B, C].
a	a	a

Following Uustalu [27] (and other work [20,1]), we next introduce a notion of guard- edness.
Definition 4.3 (Guardedness) A morphism f : X → T b(Y + Z) is guarded if there is u : X → T (Y + T b(Y + Z)b ) such that out ◦f = T (inl + id) ◦ u:
a	a

X	f	zT b,(Y + Z)

u
b , 


b 	z,
out
,	b

T (Y + Ta(Y + Z)a)
T (inl + id)
T ((Y + Z)+ (T b(Y + Z)) ).


Guardedness of f : X → T b(Y +Z) intuitively means that any call to a computation of type Z in f occurs only under a free operation, i.e. via the right hand summand

in T ((Y + Z)+ (T b(Y + Z))b ). A familiar instance of this notion occurs in process
a	a
algebra [7], illustrated in simplified form as follows.

Example 4.4 Let T be the countable powerset monad over a suitable category, i.e.
TX = Pω X = {Y ⊆ X | |Y |≤ ω}. The object T 1X = νγ. Pω (X + A × γ) can be
1	A	1
considered as the domain of possibly infinite countably nondeterministic processes
over actions from A with final results in X. A morphism n → T 1(X +n) can be seen as a system of n mutually recursive process definitions; the latter is guarded in the sense of Definition 4.3 iff every recursive call of a process is preceded by an action, which coincides with the standard notion of guardedness from process algebra. We recall an example of an unguarded definition in this setting in Section 6.

The following result is the main technical contribution of the paper; it states es- sentially that iteration operators, i.e. Elgot monad structures, propagate uniquely along extensions T → Tb .

Theorem 4.5 Let T be a complete Elgot monad. Given a, b ∈ |C|, let Tb
be the

monad identiﬁed in Lemma 4.1, i.e. the coinductive generalized resumption monad
over T.

There is a unique iteration operator making Tb
a complete Elgot monad that

extends iteration in T in the sense that for f : X → T b(Y + X) and g : X →
T (Y + X), if
out ◦f = (T inl) ◦ g

(i.e. f = out−1 ◦(T inl) ◦ g) then

out ◦f† = (T inl) ◦ g†.

For any guarded morphism f : X → T b(Y + X), f† is the unique morphism satisfying the unfolding property [ην,f†]§ ◦ f = f†.

Proof. (Sketch) Uustalu already proves that guarded morphisms f have unique iterates f† [27, Theorem 3.11]. The key step is then to define f† for unrestricted f in a consistent manner. For f : X → T b(Y + X), let Df : X → T b(Y + X) be the
a	a
composite


w†	b	b
X −−−−→ T (Y + Ta(Y + X)a)
T (inl + id)	b	b
−−−−−−−→ T ((Y + X)+ Ta(Y + X)a)
out-1	b
−−−−−→ Ta(Y + X)

(guarded by definition), where w is the composite

f	b
X −−−→ Ta(Y + X)
−−o−ut→ T ((Y + X)+ T b(Y + X)b )
a	a
−−T−π−→ T ((Y + T b(Y + X)b )+ X)
a	a
with π = [inl + id, inl inr]. That is, Df makes f guarded by iterating
out ◦f : X → T ((Y + X)+ T b(Y + X)b )
a	a
(in the complete Elgot monad T) over the middle summand of the result. It is easy to check that Df = f when f is guarded. We hence can define
f† = (Df )†
(in Tb ). Further (nontrivial) calculations show that this definition indeed satisfies the axioms of complete Elgot monads.
To establish uniqueness, we first show that any morphism f : X → T b(Y + X) can be decomposed into two morphisms g : X → T b(Z +X) and h : Z → T b(Y +X),
a	a
where Z = Y + T b(Y + X)b , as
a	a
f = [h, ην ◦ inr]§ ◦ g
with g completely unguarded, i.e. out ◦g = (T inl) ◦ gj for some gj; that is, we split
f into a guarded part and a completely unguarded one, with iteration on the latter

part being determined by the requirement that iteration on T b
extend iteration

on T . Next we show that for any choice of Elgot monad structure † on T b,
f† = (h§ ◦ g†)†


and that
h§ ◦ g† = Df.

In summary, we then obtain that f† = (h§ ◦g†)† = (Df )†, i.e. our previous definition of f† is the only possible one with the given properties, as Df is guarded and therefore (Df )† is determined uniquely already by the unfolding property.    □

The following results characterize Tb
within the (overlarge) category CElg(C) of

complete Elgot monads over C and (strong) monad morphisms [16] preserving it-
eration in the evident sense:
Definition 4.6 A complete Elgot monad morphism ξ : R → S between complete Elgot monads R, S is a morphism ξ between the underlying strong monads (i.e. ξ ◦ η = η, ξ ◦ f ٨ = (ξ ◦ f )٨ ◦ ξ for f : X → RY , and ξ ◦ τ = τ ◦ (id ×ξ)) additionally satisfying


for g : X → R(Y + X).
(ξ ◦ g)† = ξ ◦ g†

Lemma 4.7 The natural transformation ext : T → Tb
is a complete Elgot monad

morphism.
Theorem 4.8 Suppose that CElg(C) has an initial object L. Then
Lb is the free complete Elgot monad over the signature functor ()b : C → C;
For any complete Elgot monad T, the coinductive generalized resumption

monad Tb
is the coproduct of T and Lb
in CElg(C), with left injection

ext : T → Tb
(in particular, ext is a morphism in CElg(C)).

The crucial step in proving Theorem 4.8 is the following statement, which is inter- esting in its own right.
Lemma 4.9 Let a, b ∈ |C| and let T, S be two complete Elgot monads. Given a complete Elgot monad morphism ρ : T → S and a Kleisli morphism u : a → Sb, the transformation ζ† : T b → S with ζ deﬁned componentwise as the composite


b	out
b	b	[η◦inl,λ⟨x,f ⟩.S(inr ◦f)u(x)]s◦ρ	b

Ta X −−−−−→ T (X + a × (Ta X) ) −−−−−−−−−−−−−−−−−−−−→ S(X + Ta X)
extends to a complete Elgot monad morphism. Conversely, any ξ : Tb → S induces
ξ ext : T → S and


out-1 ◦ η ◦ inr ◦ ⟨id,λ . η⟩
b	ξb

a −−−−−−−−−−−−−−−−→ Ta b −−−−→ Sb.
These two passages are mutually inverse and thus witness a bijection between com-

plete Elgot monad morphisms Tb
→ S and pairs consisting of Kleisli morphisms

a → Sb and complete Elgot monad morphisms T → S.
The existence and the exact shape of the initial complete Elgot monad L mentioned in Theorem 4.8 depend on the properties of C. Recall that C is hyperextensive [2] if it has countable coproducts that are disjoint and universal (i.e. stable under pullbacks), and coproduct injections are, as subobjects, closed under countable disjoint unions. Examples include Set, ωCpo, and bounded complete metric spaces as well as all presheaf categories.
Theorem 4.10 Let C be hyperextensive. Then the monad L given by LX = X+1 is ω-continuous. Equipped with the arising complete Elgot monad structure according to Theorem 3.6, L is the initial complete Elgot monad over C.
Proof. The base category C is, a fortiori, extensive; in any extensive category, L is the partial map classifier for partial morphisms whose domains are coproduct injections. Thus, the Kleisli category of L inherits orderings on its hom-sets from the extension ordering on partial functions; the fact that coproduct injections are closed under unions in C then guarantees that these orderings are ω-complete (note that any ascending chain of coproduct injections qua subobjects can, using universality of coproducts, be transformed into a disjoint union of coproduct injections). Using the properties of hyperextensive categories, one can show that this induces an ωCppo- enrichment of CL that satisfies all additional conditions imposed in Definition 3.3.

To see initiality, note that any complete Elgot monad T for any X ∈ |C| possesses

a global element ⊥X = δ†
:1 → TX where δX = η ◦ inr :1 → T (X + 1). It follows

by naturality of iteration that ⊥X is actually natural in X. Moreover, ⊥ is preserved by complete Elgot monad morphisms. It is easy to see that ξX = [η, ⊥X] yields a complete Elgot monad morphism ξ : L → T. On the other hand it is the only such because for any other complete Elgot monad morphism θ : L → T one would have θ ◦ inl = θ ◦ η = η = ξ ◦ inl and θ ◦ inr = θ ◦⊥ = ⊥ = ξ ◦ inr implying θ = ξ.   □

Example: Unrestricted While Loops
We use a simple while-language with actions proposed by Rutten, given by the grammar
P, Q ::= A | P ; Q | if b then P else Q | while b do P
and, following Pir´og and Gibbons [20], interpreted in the Kleisli category of a monad M. Here, A ranges over atomic actions interpreted as Kleisli morphisms JA) : n → Mn for some fixed object n, and b over atomic predicates, interpreted as Kleisli morphisms Jb) : n → M (1 + 1) (with the left-hand summand read as ‘false’). We say that A is of output type if JA) has the form (M fst) ◦ τ ◦ ⟨idn, p⟩ for some p : n → M 1, and of input type if JAi) factors through ! : n → 1. Sequential composition P ; Q is interpreted as Kleisli composition JQ)٨ ◦ JP ), and
Jif b then P else Q) = [JQ) ◦ fst, JP ) ◦ fst]٨ ◦ M dist ◦τ ◦ ⟨id, Jb)⟩.
The key point, of course, is the interpretation of the while loop, given in the presence of iteration † by
Jwhile b do P ) = Ä[(M inl) ◦ η ◦ fst, (M inr) ◦ JP ) ◦ fst]٨ ◦ M dist ◦τ ◦ ⟨id	ä†
It has been observed by Pir´og and Gibbons that if one instantiates M with a com- pletely iterative monad, one needs to guard every iteration of the while loop, i.e. change the semantics of while to be
Jwhile b do P ) = Ä[(M inl) ◦ η ◦ fst, (M inr) ◦ JP ) ◦ fst]٨ ◦ M dist ◦τ ◦ ⟨id, Jb)⟩◦ γä†
where γ : n → Mn is guarded, as otherwise the iteration may fail to be defined. If we instantiate M with an Elgot monad, such as Tb for an Elgot monad T, then the guard is unnecessary, i.e. we can stick to the original semantics (2). As an example, consider a simple-minded form of processes that input and output symbols from n and have side effects specified by T; i.e. we work in M = (T1 )n meaning to use the adjoined free effects 1 → n to capture output and those of type n → 1 to capture input. We assume an atomic action write that outputs a symbol from n, and an atomic action read that inputs a symbol. We interpret write as being of output type, i.e. by Jwrite) = (M fst) ◦ τ ◦ ⟨idn, w⟩ where
w = ext ◦ out−1 ◦ η ◦ inr ◦⟨idn, ην◦ !n⟩ : n → (T 1)n(1)
n 1

(ην being the unit of T1 ), while read is of input type, i.e. Jread ) = r ◦ !n where
r = out−1 ◦ ην ◦ inr ◦⟨id1, r0⟩ :1 → (T 1)nn
n 1
and r0 :1 → (T 1)n(n)n is obtained by currying ηM ◦ snd :1 × n → (T 1)n(n) (ηM
n 1	n 1
being the unit of M). Moreover, assume a basic predicate b whose interpretation is
largely irrelevant to the example as long as it may take both truth values; for exam- ple, b might just pick a truth value non-deterministically or at random, depending on the nature of the base monad T. Consider the program
read ; while true do if b then skip else write
where skip is an atomic action interpreted as Jskip) = ηM : n → M n. It is possible for the loop to not perform any write operations, as b might happen to always pick the left-hand branch; that is, the loop body fails to be guarded. Since M is an Elgot monad and not just completely iterative, the semantics of the loop is defined (by (2)) nonetheless.

Example: Simple Process Algebra
It is shown in [5, Theorem 5.7.3] that a simple process algebra BSP featuring finite choice and action prefixing can express all countable transition systems if unguarded recursion is allowed. The idea of the proof is to introduce variables Xik for i, k ∈ N representing the k-th transition of the i-th state, with Xi0 representing the i-th state itself, and (unguarded) recursive equations
Xik = bik.Xj(i,k),0 + Xi,k+1	(3) where the k-th transition of the i-th state performs action bik and reaches the
j(i, k)-th state. (It is then stated explicitly that the use of unguarded recur- sion is essential.) To model this phenomenon using the coinductive general- ized resumption transformer, we take T = Pω1 , the countable powerset monad on Set (see Example 4.4), and an operation act with interpretation Jact ) = out−1 ◦ η ◦ inr ◦ ⟨ida, ην!a⟩ : a → T 11, where a is the type of actions. That is, we regard (unbounded) nondeterminism as part of the base effect, and add action prefixing via coinductive generalized resumptions. Then the definition (3) is rep-
resented by the map g = out−1 ◦f : N × N → T 1(N × N) ∼= T 1(0 + N × N) with
a	a
f : N × N → T ((N × N)+ a × T 1(N × N)) (eliding the exponent 1) given by
f (i, k)= {inr(bik, ην(j(i, k), 0)), inl(i, k + 1)}.

Again, our result that T1 is an Elgot monad guarantees that this equation has a solution g†; the choice † of solutions in T1 is uniquely determined as extending the usual structure of T = P as an Elgot monad via taking least fixed points.

Related Work
The above results benefit from extensive previous work on monad-based axiomatic iteration. In particular we draw on the concept of Elgot monad studied by Ad´amek et al. [3]; the construction of the free Elgot monad over a functor [4] is strongly related to Theorem 4.8.i, and we do not claim this result as a contribution of this paper. There is extensive literature on solutions of (co)recursive program schemes [6,1,15,11,20,21], from which our present work differs primarily in that we do not restrict to guarded systems of equations. In particular, as mentioned in the introduction, Pir´og and Gibbons [20] actually work with the same monad trans- former, the coinductive generalized resumption transformer. Pir´og and Gibbons [21, Corollary 4.6] also prove a characterization of the coinductive generalized resump- tion transformer as taking coproducts of monads similar to our Theorem 4.8.ii; but again, this takes place in a different category, that is, in completely iterative mon- ads (admitting guarded recursive definitions) rather than complete Elgot monads (admitting unrestricted corecursive definitions). One consequence of this is that the second summand in our coproduct result is a free complete Elgot monad and not a free completely iterative monad over a × b, and hence has a built-in notion of divergence. Technically, results on T b being a completely iterative monad are in- comparable to our result on T b being a complete Elgot monad – we prove a stronger recursion scheme for T b but need to assume that T is an Elgot monad, while T b is
a	a
completely iterative without any assumptions on T .
We construct solutions of unguarded recursive equations from solutions of guarded recursive equations, for the latter relying crucially on results by Uustalu on guarded recursion over parametrized monads [27], which in particular has allowed us to make do without idealized monads.
The axiomatic treatment of iteration via Elgot monads is essentially dual to the axiomatic treatment of recursion by Simpson and Plotkin [25], who work in a category D with a parametrized uniform recursion operator HomD(Y × X, X) → HomD(Y, X) and a subcategory S of strict functions in D. Given a distributive category C equipped with a complete Elgot monad, we can take S = Cop and D = (CT)op. Then the iteration operator over CT sending f : X → T (Y + X) to f† : X → TY induces precisely a parametrized uniform recursion operator for the pair (D, S) in the sense of Simpson and Plotkin.

Conclusions and Future Work
We have developed semantic foundations for non-wellfounded side-effecting recursive definitions, in the form of iteration, specifically for recursive definitions over the so- called coinductive generalized resumption transformer that constructs from a base monad T the monad T b = νγ. T (+a×γb). While previous work on the same monad transformer was focussed on guarded corecursive definitions, in the framework of completely iterative monads, we work in the setting of (complete) Elgot monads, which admit unrestricted recursive definitions. Our main results state that

T b is a complete Elgot monad if T is a complete Elgot monad;
the structure of T b as a complete Elgot monad is uniquely determined as ex- tending the one of T ;
if the underlying category C admits an initial complete Elgot monad L (typi-

cally L =  + 1) then T b ∼= T + Lb
in the category of complete Elgot monads

a	a
on C.
In particular this requires proving the equational laws of complete Elgot monads for the solution operator that we construct on T b. We have implemented a formal verification of our results, which are technically quite involved, in the Coq proof assistant, see https://git8.cs.fau.de/redmine/projects/corque.
We conjecture that our results generalize to monads of the form νγ. T (X + Hγ) for any (strong) functor H in place of a × (--)b. Besides the fact that applying the coinductive resumption monad transformer to a complete Elgot monad T again yields a complete Elgot monad Tb , the resulting object obviously has a richer struc- ture provided by the adjoined free operations. One topic for further investigation is to identify (and possibly axiomatize) this structure. We aim to use this struc- ture for programming definitions of free operations as morphisms T bX → TX in a similar spirit as in the paradigm of handling algebraic effects [23]. In conjunction with iteration this actually produces a recursion operator that is more expressive than iteration. This however requires going beyond the first-order setting of this paper (which was sufficient for iteration), as call-by-value recursion is known to be an inherently higher-order concept.
Acknowledgement
The authors wish to thank Stefan Milius and Paul Blain Levy for useful discussions.

References
Aczel, P., J. Ad´amek, S. Milius and J. Velebil, Infinite trees and completely iterative theories: a coalgebraic view, Theoret. Comput. Sci. 300 (2003), pp. 1 – 45.
Ad´amek, J., R. Borger, S. Milius and J. Velebil, Iterative algebras: How iterative are they?, Theory Appl. Cat. 19 (2008), pp. 61–92.
Ad´amek, J., S. Milius and J. Velebil, Equational properties of iterative monads, Inf. Comput. 208
(2010), pp. 1306–1348.
Ad´amek, J., S. Milius and J. Velebil, Elgot theories: a new perspective of the equational properties of iteration, Math. Struct. Comput. Sci. 21 (2011), pp. 417–480.
Baeten, J., T. Basten and M. Reniers, “Process algebra: equational theories of communicating processes,” Cambridge University Press, 2010.
Bartels, F., Generalised coinduction, Math. Struct. Comput. Sci. 13 (2003), pp. 321–348.
Bergstra, J., A. Ponse and S. Smolka, editors, “Handbook of Process Algebra,” Elsevier, 2001.
Bloom, S. and Z. E´sik, “Iteration Theories,” Springer, 1993.
Cenciarelli, P. and E. Moggi, A syntactic approach to modularity in denotational semantics, in: Category Theory and Computer Science, CTCS 1993, 1993.

Cockett, R., Introduction to distributive categories, Math. Struct. Comput. Sci. 3 (1993), pp. 277–307.
Goncharov, S. and L. Schr¨oder, A coinductive calculus for asynchronous side-effecting processes, Inf. Comput. 231 (2013), pp. 204 – 232.
Hyland, M., G. Plotkin and J. Power, Combining effects: Sum and tensor, Theoret. Comput. Sci. 357
(2006), pp. 70–99.
Hyland, M. and J. Power, Discrete lawvere theories and computational effects, Theoret. Comput. Sci.
366 (2006), pp. 144–162.
Kock, A., Strong functors and monoidal monads, Arch. Math. 23 (1972), pp. 113–120.
Milius, S., L. Moss and D. Schwencke, Abstract GSOS rules and a modular treatment of recursive definitions, Log. Methods Comput. Sci. 9 (2013).
Moggi, E., An abstract view of programming languages, Technical Report ECS-LFCS-90-113, Univ. of Edinburgh (1989).
Moggi, E., A modular approach to denotational semantics, in: Category Theory and Computer Science, CTCS 1991, LNCS 530 (1991), pp. 138–139.
Moggi, E., Notions of computation and monads, Inf. Comput. 93 (1991), pp. 55–92.
Peyton-Jones, S., ed, “Haskell 98 Language and Libraries — The Revised Report,” Cambridge University Press, 2003, also: J. Funct. Prog. 13 (2003).
Pir´og, M. and J. Gibbons, Monads for behaviour, in: Mathematical Foundations of Programming Semantics, MFPS 2013, ENTCS 298, pp. 309 – 324, Elsevier, 2013.
Pir´og, M. and J. Gibbons, The coinductive resumption monad, in: Mathematical Foundations of Programming Semantics, MFPS 2014, ENTCS 308, pp. 273–288, Elsevier, 2014.
Plotkin, G. and J. Power, Semantics for algebraic operations, in: Mathematical Foundations of Programming Semantics, MFPS 2001, ENTCS 45, pp. 332–345, Elsevier, 2001.
Plotkin, G. and M. Pretnar, Handlers of algebraic effects, Log. Methods Comput. Sci. 9:4 (2013).
Rutten, J., A note on coinduction and weak bisimilarity for while programs, Inform. Th´eor´et. Appl.
33 (1999), pp. 393–400.
Simpson, A. and G. Plotkin, Complete axioms for categorical fixed-point operators, in: Logic in Computer Science, LICS 2000, pp. 30–41, IEEE Computer Society, 2000.
Smyth, M. and G. Plotkin, The category-theoretic solution of recursive domain equations, in:
Foundations of Computer Science, FOCS 1977, pp. 13–17, IEEE, 1977.
Uustalu, T., Generalizing substitution, Inform. Th´eor´et. Appl. 37 (2003), pp. 315–336.
Wadler, P., How to declare an imperative, ACM Comput. Surv. 29 (1997), pp. 240–263.
Wand, M., Fixed-point constructions in order-enriched categories, Theoret. Comput. Sci. 8 (1979),
pp. 13–30.
