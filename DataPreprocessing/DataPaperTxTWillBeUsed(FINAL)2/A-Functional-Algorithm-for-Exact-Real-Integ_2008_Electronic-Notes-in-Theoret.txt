

Electronic Notes in Theoretical Computer Science 218 (2008) 337–353
www.elsevier.com/locate/entcs

A Functional Algorithm for Exact Real Integration with Invariant Measures
Adam Scriven1
School of Computer Science University of Birmingham Birmingham, England

Abstract
We develop an algorithm for exact real integration over a class of self-similar spaces and measures defined by Hutchinson. We construct the algorithm in an idealised lazy functional programming language and prove its correctness using domain theory. The work generalises an algorithm developed by Alex Simpson for exact Riemann integration over the real line. We implement the algorithm in the functional language Haskell and give some preliminary results.
Keywords: Exact real number computation; integration; self-similarity; iterated function system; domain theory; lazy functional programming; Haskell.


Introduction
Exact real number computation is useful from both a practical and theoretical point of view. On the practical side, it allows calculations to be made without the propa- gation of errors inherent in floating point arithmetic, albeit at the inevitable loss of efficiency. Theoretically, the study of exact real arithmetic sheds light on questions regarding the computability of real numbers and function(al)s. One functional that has been the focus of detailed study is integration. Edalat and Escardo´ [3], and later Simpson [15] constructed algorithms for exact integration over the reals. They used different methods, but both cases made essential use of the following identity:


1	1
f dx = 2
∫ 1

1
f (x/2) dx + 2
∫ 1

f ((x + 1)/2) dx	(1)



1 Email: a.scriven.03@cantab.net

1571-0661© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.10.020

Intuitively, the idea is to recursively apply (1) splitting the integrand into simpler and simpler fragments until constants can be extracted using (2).
In this paper we generalise Simpson’s algorithm [15] over a large class of mea- surable spaces. The measures/spaces in question are the so called invariant mea- sures/spaces [10], which we discuss in Section 2.6. Informally these spaces have
the defining characteristic that when a segment is viewed, it resembles the origi- nal space topologically. Consequently these spaces can be defined in a recursive manner, making them computationally appealing. Such spaces arise naturally in mathematics: The real line exhibits this property, as do many fractal spaces such as the Sierpinski gasket and Falconers fractal. Indeed in this this study we show why it is precisely this property of invariance that allows the algorithms in [3,15] to work.
This paper is a condensed version of the masters thesis by the author[14].

Related Work
As we have already mentioned, algorithms for exact integration on the reals exist in the literature, but differ in their implementation. In [3], Edalat and Escardo´ used the programming language RealPCF, a form of PCF augmented with an extensional datatype real representing the reals. This language required special primitive con- structs to work with the abstract dataset real. In particular parallel constructs were found to be a necessary component. Moreover in order to compute (1) it was necessary to evaluate both sub-integrals in parallel. This non-sequentiality made their integration algorithm difficult to implement in practice, and it was unclear how a sequential equivalent could be constructed - indeed Gianantonio conjectured in his thesis that no such algorithm existed [6]. Simpson [15] later achieved a sequential integration algorithm using an intensional data type, representing the reals as a stream of digits. This language required no additional primitives, as arithmetic was performed directly on the representations and through the use of Berger’s universal quantifier [2]. The work in this study closely follows the style of Simpsons paper.
Background
Computational model
We develop our algorithm in an informal lazy functional programming language, much like that used in [15]. As Simpson remarks, such languages “provides a nat- ural implementation style for exact real algorithms”, as well as being readable and intuitive. Our informal language has the following type structure:
σ, τ ::= Int | Bool | σ × τ | σ → τ | [σ]
where Int and Bool are the Integer and Boolean datatypes respectively. The con- structors → and × are the familiar application and product, the term [σ] denotes the datatype of lazy streams of elements of type σ. For clarity, we shall also make use of finite types in this paper. The stream datatypes have the usual constants

head : [σ] → σ, tail : [σ] → [σ] and cons : σ × [σ] → [σ], the latter having infix form (:).
Being an informal language, the denotational semantics is also informal. Suffices to say it follows the standard interpretation from the Scott model of partial contin- uous functionals P , which form a Cartesian closed category of dcpos. The ground types have interpretation PInt = N and PBool = B := {tt, ff}. The subset of total elements is denoted Tσ ⊆ Pσ. We assume the reader is familiar with domain theory, and refer them to [1,8,16] for a detailed survey. Denotationally, streams of type [σ] can be interpreted as elements of type PInt → Pσ. Thus, in proving correctness we treat our programs as expressions in PCF interpreted in the Scott model, thus maintaining full mathematical rigour. Informally, we may consider our functional programming language to be PCF extended with lazy streams.

Denotation of streams
For a set X, denote the set of finite sequences of elements in X by X∗, and the set of infinite sequences by Xω. We write X∞ := X∗ ∪ Xω for the set of all sequences. For a sequence α ∈ X∞ we write |α| for the (possibly infinite) length of α. For 0 ≤ i < |α|, the ith element of α is denoted by αi. The concatenation of a finite sequence α ∈ X∗ and an arbitrary sequence β ∈ X∞, is denoted αβ. We write α[n for the largest prefix β, of α, such that |β|≤ n. As with domains, for a finite stream α we denote the set of all streams with α as a prefix by ↑α, and define α =↑α∩Xω to be the subset of infinite streams with α as a prefix. Finally, for x ∈ X, we write xω for the infinite constant sequence of x’s. In our denotational semantic, we interpret [[[σ]]] as [σ]]∞, the finite elements of which are the finite sequences of finite elements of [σ]].

Universal quantiﬁcation on streams
In a recent paper, Escardo´ [4] showed how to extend Berger’s universal quantifier to the class of so called exhaustible spaces. Briefly, a set K ⊆ D is exhaustible if there exists a computable functional ∀K : (D → B) → B such that for every predicate p ∈ (D → B) defined on K,


∀ (p) =	true	if p(x) = tt , for all x ∈ K
K	false	if p(x) = ff for some, x ∈ K,

(3)


that is, universal quantification is computable. Escardo´ showed that the generalised Cantor spaces over n objects, nω, is exhaustible, by supplying an algorithm cantor,
type Quantifier a = (a → Bool) → Bool cantor : N → Quantifier (N → N)
such that, for all n ∈ N, cantor(n) satisfies (3) with K = nω. We shall make use of this algorithm in Section 3 to develop our generalised integration algorithm.

Exact real arithmetic
There are numerous approaches to representing the real numbers within a compu- tational framework. Some methods seek to represent the reals extensionally i.e. as an abstract datatype such as the interval domain, while others are intensional in that the reals are represented using existing type structures (see e.g. [7,5] for a summary). We favour the latter approach, in particular infinite streams of digits as studied by Kreitz et. al. [11].
For our purposes, a representation of X is a surjective (partial) map δ : A ⊆ F → X, where F = (N → N) ≡ Nω. The Baire space F has the product topology, which coincides with the subspace topology of the Scott topology on N∞. Given representations δ : A → X, γ : B → Y we say that a continuous f : A → B is
real 2 if there exists a continuous f˜ : X → Y , such that γ · f = δ · f˜. We call f the
realization of f˜ (w.r.t. δ and γ). Furthermore we say f is real-total if it is total and the restriction to the total function is real. The following definition is due to Kreitz et. al. [11]
Definition 2.1 Let (X, τ ) be a T0-space with countable base. A representation δ :⊆ F → X is admissible (with respect to τ ) if it is continuous and for all continuous functions φ :⊆ F → X, there exists a continuous θ : F → F such that φ = δ · θ.
Admissible representations have remarkable properties: Given representations δ : A → X and γ : B → Y with γ admissible, every continuous g : X → Y is realized by some continuous f : A → B. Moreover, the quotient topology induced on Y by δ corresponds precisely to the existing topology on Y , i.e. the representation preserves topological structure. Many typical representations such as decimal expansions and Cauchy sequences fail to be admissible. A typical counter example is the lack of a continuous (and hence computable) algorithm for multiplication by 3 in the decimal representation ( see e.g. [7]).

The signed binary representation
One of the simplest admissible representation is the signed binary representation
q : 3ω → [−1, 1], where 3 := {−1, 0, 1}, and q(α) = Σ∞ αi2−i. This representation
has been used successfully by many people in studying exact arithmetic [13,15]. In our lazy functional language 3ω can be implemented via the type interval:
type three = {-1,0,1}
type interval = [three]
Thus [interval]] = 3∞, where only the (total) elements 3ω are interpreted as real numbers. Similarly, only the (total) functions f : 3∞ → 3∞ correspond to functions on real numbers. If this were to be implemented in PCF say, then 3∞ would be interpreted as a (closed) subset of (N → N), and the corresponding (partial) functionals would only be necessarily defined on 3∞.

2 this terminology stems from [15]

The admissibility of the signed binary representation allows us to guarantee that every continuous real valued function has a continuous real-total counterpart in the domain model. The following results are generalisations of those given in [15, Proposition 1].
Lemma 2.2
Given representations δ : A → X, any continuous θ : X → [0, 1] can be realised by a map φ : A → 3ω such that θ · δ = q · φ.
Let σ be a type in our language. Then for any continuous φ : Tσ → 3ω, there exists a total φ : Pσ → 3∞ such that φ restricts to θ.
Proof.
Since q : 3ω → [−1, 1] is admissible, for any surjective f :⊆ F → [−1, 1] there exists a continuous φ : F → F such that f = q · φ on dom(f ). Taking f = δ · θ suffices.
Immediate from Tσ being dense in Pσ, and 3∞ being a Scott domain and therefore densely injective.


Invariant spaces and measures
Many interesting spaces can be constructed by repeatedly applying a set of simple transformations to an initial space. For example, the Cantor space embedded in R, as shown in Figure 1, can be constructed by repeatedly applying the following set of maps
C = {S1 : x '→ x , S2 : x '→ x+2 } where dom(Si) = [0, 1]	(4)
3	3

	S1			S2	
 S1S2 	 S2S1 
S1S2S1	S2 S2S2

Fig. 1. Partial illustration of the first 3 iterations for embedding the Cantor space in the real line.

These spaces were studied by Hutchinson [10], to whom the following definition is attributed.
Definition 2.3 Let (X, d) be a complete metric space. A closed, bounded, non- empty K ⊆ X is called invariant w.r.t a (finite) set of contraction maps S =
{S1, ..., Sn} if:
n
K =	Si(K)
i=1

The set S is often referred to as an Iterated Function System or IFS [9]. The startling result discovered by Hutchinson in [10] is that a (unique) invariant set always exists for any given S .
Theorem 2.4 Let (X, d) be a complete metric space. Then for any (ﬁnite) set of contractions S on X, there exists a unique closed bounded non-empty K ⊆ X which is invariant w.r.t S . Moreover K is compact.
Throughout this paper we denote the invariant space w.r.t S by |S |, or by K
when there is no ambiguity as to the IFS.

The co-ordinate map
In order to perform constructive analysis on invariant spaces, we need a suitable representation. The co-ordinate map π : nω → |S | is a natural candidate, defined by
∞
{π(α)} =	Sα1...αi (X)
i=1
This map is well-defined, surjective and therefore a representation of |S |. Moreover it is continuous w.r.t the product topology on nω and the subspace topology on |S | inherited from the metric space (X, d). However, in general π is not admissible, an obvious example being the familiar binary representation π : 2ω → [0, 1] where S1 : x '→ x and S2 : x '→ x+1 . Fortunately this is not a problem, as we shall see in
2	2
Section 3.

Invariant measures
Hutchinson showed that just as |S | is exhibited as the fixed point of S applied to X, a natural measure exists on |S | as the fixed point of an analogous application of S on M, the set of Borel regular measures on X having bounded support and finite mass. Hutchinson originally used these “invariant measures” to distinguish between IFS’s that gave the same invariant space but were inherently different. However the same measures are also natural candidates for integration.
Suppose we have a set ρ = {ρ1, ..., ρn} such that ρi ∈ (0, 1) and  ρi = 1. Given
a set of contractions S , define (S , ρ) : M→M by:

n
−1
i
i=1
It is clear from the definition that M ((S , ρ))(μ) = M (μ) so the map restricts to (S , ρ) : M1 → M1, where M1 ⊆ M is the subset of measures having mass M (μ) = 1. Intuitively we interpret ρi as the weight/mass of the component Si(K) of K.
Theorem 2.5 There exists a unique μ ∈ M1 such that (S , ρ)μ = μ.

We denote the unique μ by S ,ρ  . As an immediate corollary we obtain the following identity, which motivates the next section.

∫|S |

f d  S ,ρ  =
Σi=1
ρi ∫



|S |

(f · Si) d  S ,ρ 	(5)

Exact integration on invariant spaces
The definition of invariant spaces captures the property of the real line used by [15,3] to compute integration. Indeed equation (5) generalises the identity (1). This special case is arguably the simplest form of integration on a self-similar space, where it suffices to only compute the average of two real numbers. For general invariant spaces, it is clear from (5) that we need an algorithm for weighted sums of arbitrarily many real numbers. In order to develop such an algorithm, we need to consider an alternative representation of the unit interval.

A “streams-of-streams” representation of the unit interval
In order to be able to develop a Riemann integration algorithm, Simpson needed the averaging algorithm to have the property that |avg(x, y)|≥ min(|x|, |y|) i.e. for every digit of input from x and y, avg outputs at least a single digit. We will call such programs (computationally) stable. Simpson showed that no stable algorithm for averaging existed in the signed binary expansion, and solved the problem by making use of an intermediate representation, namely, the dyadics D := Qd ∩ [−1, 1]
with representation qd : Dω → [−1, 1] defined by qd(α) = Σn	αi2−i as a natural
extension of q.  In our more general setting, we need yet another intermediate
representation, as the following result illustrates.
Lemma 3.1 There is no stable algorithm for performing weighed averaging in the signed binary or dyadic arithmetic.
Proof. The existence of a stable weighted averaging algorithm would also imply the existence of a stable multiplication algorithm. A simple counter example is to consider the width of the interval q( 11) × q( 10) = [ 1 , 3 ].	 
8 4
It is clear that this problem is not unique to the signed binary expansion, but relates to carry overs inherent in the arithmetic. While a possible solution would be to expand the digit set to include all of Q ∩ [−1, 1], allowing multiplication to be performed digit-wise, this can lead to “integers explosion” in the numerator. To sidestep this problem, we make use of a stream-of-streams representation i.e. our digits are themselves streams representing real numbers.
Definition 3.2 Define the space 3ωω := (3ω)ω and the representation qω : 3ωω →
[−1, 1] by,
∞
qω(α) =	q(αi)2−i
i=1

Since 3ωω has the same cardinality as the continuum it can embedded in F and the machinery from [12] carries over with little difficulty. In particular, qω is admissible: it is continuous, and for any continuous φ :⊆ F → [−1, 1], there is a continuous θ : F → F such that φ = q · θ, thus φ = qω · θω where θω(α) = θ(α)ω . We implement 3ωω in our functional programming language using the datatype:
type w-interval = [interval]
Under this representation it is possible to implement stable multiplication and ad- dition, presented in Figure 2, from which weighted sums can be computed.
mul :: interval → w-interval → w-interval
a ‘mul’ (b : y) = (a ∗ b : a ‘mul’ y)
add :: w-interval → w-interval → w-interval (a : x) ‘add’ (b : y) = (a + b : (x ‘add’ y) )
sum :: N → (N → w-interval) → w-interval sum 1 f = f (1)
sum n f = f (n) ‘add’ sum(n − 1,f )
Fig. 2. The operators + and ∗ denote addition and multiplication on the datatype interval respectively, as implemented in e.g. [13]. Note that there is no bounds checking on add.


Lemma 3.3
[mul]] is real-total and stable, with qω([[mul]](a, α)) = q(a)×qω(α) for all a ∈ 3ω,
α ∈ 3ωω.
sum is real-total and correct.	That is, for f ∈ (N → w-interval) with

n i=1
f˜i|≤ 1, [[sum]]nf ∈ 3ωω and [˜[sum]]nf˜ = Σn
f˜i.

sum is stable, i.e. |[[sum]]nf | ≥ min
1≤i≤n
|fi|, where here the “digits are elements

of 3ω.
We can easily convert from w-intervals to intervals using the algorithm shift in Figure 3. We make use of a secondary nine-digit representation q' : 9ω → [−1, 1]

given by q'(α) = Σ∞
αi2−(i+2).

Lemma 3.4
For all α ∈ 9ω, coerce(α) ∈ 3ω and [[c˜oerce]] = id i.e. q([[coerce]](α)) = q'(α).
For all γ ∈ 3ωω, shift(γ) ∈ 3ω, and [[˜shift]] = id i.e. q([[shift]](γ)) = qω(γ).
Proof. It is a simple exercise to show (i). Whence for (ii) it suffices to prove that shift’ is real-total with [[s˜hift’ ] = id. Since shift’ outputs one digit for every two digits 3 input, it is total. Finally, let γ = ((a : b : α) : (c : β) : δ), then:

3 where here a digit is an element in 3ω.

qω(γ)= 1 q(a : b : α)+ 1 q(c : β)+ 1 qω(δ)
2	4	4

1 a + 1 b + 1 q(α)
1 c + 1 q(β)
qω(δ)

= 2	4	4
2
1
+  2	2	 +
4
1  q(α) ⊕ q(β)


4
qω(δ) 

= 8 (2a + b + c)+ 2	2	+	2
= 1 d + 1 qω([[avg]](α, β) : δ)
8	2
where d = 2a + b + c. The result follows.	 
It is worth noting that we could have used the dyadic representation in place of 9. The only modification to the algorithm would be that shift’ outputs d/4 rather than d. We can convert from dyadics to signed binary using Simpson’s coerce algorithm [15]. This approach has the added benefit of greater computational ef- ficiency in performing multiplication, however we favour the nine digit method for its simplicity.

A ﬁrst integration algorithm
With an intensionally stable weighted sum algorithm, we are now able to produce a generalised integration program over any (computable) invariant space. We present this algorithm in Figure 4.
Proposition 3.5 Let ρ : N → 3ω be such that ρ˜(i) ∈ [0, 1] for i = 1, ..., n and

n i=1
ρ˜(i) = 1. Then, for any continuous real-total φ : nω → 3ω it holds that

[[integrate]](n, ρ)φ ∈ 3w and

q([[integrate]](n, ρ)φ) =	φ˜ dμ
K
where μ =  S ,ρ  is the invariant measure of K.
type nine = {−4, −3, −2, −1, 0, 1, 2, 3, 4}
type nine-stream = [nine]
coerce :: nine-stream → interval coerce(a:b:x) = let c = 2 ∗ a + b in cases
c < −4   then −1:coerce(c + 8:x) c > 4	then 1:coerce(c − 8:x) otherwise then 0:coerce(c:x)
shift’ :: w-interval → nine-stream
shift’( (a : b : x) : (c : y) : z ) = let d = 2a + b + c in
d:shift’( (x ‘avg‘ y) : z) shift = coerce.shift’
Fig. 3. An algorithm for converting from 3ωω to 3ω. Here avg is an algorithm for computing the average
of two signed binary streams, see e.g. [13].

type Baire = [N]
w-int :: (N , N → interval) → (Baire → interval) → w-interval w-int (n,p) = λf. let d = head(f (1ω)) in
if (cantor(n))(λv.head(f (v)) == d)
then dωω : w-int((n,p) tail.f )
else sum(n,λi. pi ‘mul’ w-int((n,p) λv.f (i : v)) integrate = shift.w-int
Fig. 4. The generalised integration algorithm: Here Baire has denotation [[Baire]] = N∞ and so is the datatype containing the Baire space Nω. cantor(n) is the universal quantifier over the Cantor space on nω.

Note that Lemma 2.2 guarantees that any continuous function f : K → [0, 1] has a continuous real-total realizer of the form φ : nω → 3ω . The proof is similar in concept to a sketch given in [15].
Proof. For convenient, write the functional [w-int]](n, ρ) as simply [w-int]].
integrate is total since shift is total and both sum and mul are stable. By Lemma
3.4 it is sufficient to prove qω([[w-int]](φ)) = K φ˜ dμ. We will prove by induction
on m that

 qω([[w-int]](φ))[m− ∫

φ˜(x) dμ ≤ 2−m
 

Where we have used the abuse of notation qω(α)[m:=	Σm  q(αi)2−i  for
convenience 4 The case m = 0 is trivial.  For m > 0, consider h(φ) : nω → 3
defined by h(φ)(α) = head(φ(α)). Since φ is total, so is h(φ). We now proceed by inner induction on emc(h(φ)), the extensional modulus of continuity (see e.g. [14,15]. If emc(h(φ)) = 0 then h(φ) = d is constant. In particular, for all v
φ(v)= d : [[tail]](φ(v))	(6)
⇒ φ˜(v)= 1 d + 1 [[˜tail]](φ˜(v))	(7)
2	2
In this case, w-int outputs:

w-int(φ) = d : w-int(tail.φ)

Thus,
[[w-int]](φ)[m = d : [[w-int]](tail.φ)[m−1	(8)
⇒ qω([[w-int]](φ))[m = 1 d + 1 qω([[w-int]](tail.φ))[m−1	(9)
2	2
Where we have again used the notation q(α)[m to denote the partial evaluation

m i=1
αi2−i. By the inductive hypothesis on m.



4 it should be noted that we are not extending q over 3∞, this is discussed in e.g [7].

 qω([[w-int]]([[tail]](φ)))[m−1− ∫
[[t˜ail(φ)]] dμ ≤ 21−m
 

by 6 and 8 2qω([[w-int]](φ))[m+d − ∫
(2φ˜(x) − d) dμ ≤ 21−n
 

 qω([[w-int]](φ))[m− ∫

φ˜(x) dμ ≤ 2−m
 

Because μ ∈ M1 i.e. μ(K) = 1, we have the identity,

f (x)+ c dμ =	f (x) dμ + c	(10)
K	K

For emc(h(φ)) > 0, we have:
w-int((n, p)f ) = sum(n, λi. pi mul w-int(n, p)λv.f (i : v))
Since emc(f.consi) < emc(f ), it follows by the inner inductive hypothesis that

qω([[w-int]](φ · consi)) = for all m:
(φ˜ · [[c˜onsi]])(x) dμ. By Lemma 3.3 we can deduce that,
K

 Σ	∫	˜

By (5) the result now follows.	 

A more general integration algorithm
Most “interesting” functions of the form f : |S | ⊆ Rm → R are very hard to realize in the form f : nω → 3ω. One solution to this problem would be to find an algorithm that implemented the co-ordinate map π : nω → X. If such an algorithm existed, then functions of the form f : X → 3ω could be automatically converted to the form g = f · π : nω → 3ω which can be integrated by integrate. This approach is discussed briefly in Section 4.1, in this section we adopt a different approach.
The algorithm can be modified to integrate over (a representation of) the metric space X containing |S |. This still gives the same result, as the measure has support spt(  S ,ρ  ) = |S |. The only condition on the representation of X is that it is exhaustible, as discussed in Section 2.3, in order that we may quantify over it.
The modified algorithm is given in Figure 5. The data type IFS defined therein encapsulates the essential information necessary to perform integration. Observe the original algorithm can be obtained from x-integrate given input S = (0ω, cantor(n), n, λi.consi, ρ), so we may think of x-integrate as a gen- eralisation of integrate.
There is a subtle complication to be addressed here: When K is represented by nω, the contractions Si are realized as the functions consi, which is vital for the inductive step in reducing the emc of the integrand. That is, for a given represen- tation q we need the Si to be such that |Si(x)| > |x|. This is a strengthening of the

type IFS a =
(a, Quantifier a, N, N → (interval → interval), N → interval)
x-int :: IFS a → (Baire → interval) → w-interval x-int S = λf. let d = head(f (ι)) in
if ∀X (λv.head(f (v)) == d)
then dωω : x-int(S tail.f )
else sum(n,ρ,λi. ρi ‘mul’ x-int(S f.Si)) where (ι, ∀X, n, S, ρ) = S

x-integrate = shift.x-int
Fig. 5. A more practical integration algorithm.


stability condition discussed in Section 3.1. We call such functions computationally contractive with respect to q, or simply computationally contractive (c.c.) when there is no ambiguity as to the representation.
Unfortunately, under a general representation δ :⊆ F → X, the maps S are not guaranteed to be c.c. under δ. For example the map x '→ x has no c.c. representation in the signed binary arithmetic. This would seem to potentially limit the success of using an arbitrary representation space - a new result is needed:

Theorem 3.6 Given any set of functions Si : 3∞ → 3∞ corresponding to an IFS S , as well as coefficients ρ, we can construct a set of computationally contractive functions S ', and a set of coefficients ρ' such that:
S and S ' induce the same invariant space i.e. |S '| = |S |
S ,ρ and S ', ρ' induce the same invariant measure i.e.  S ', ρ'  =  S ,ρ 

In short this result states that any invariant space we care to define can be generated by a set of contractions that have c.c. realizations. We shall prove the result in section 3.5, but for now satisfy ourselves with some examples.


Experimental results
We implemented x-integrate in Haskell and ran some initial experiments on various functions.  For our experiments we took X = [−1, 1]2, represented by q2 : 3ω × 3ω → [−1, 1]2 ; q2 : (α, β) '→ (q(α), q(β)).  The integrand itself was f : (x, y) '→ x2, and we implemented c.c. IFS’s for the Sierpinski gasket, and Falconers Fractal (see Figure 7) as follows: For the Sierpinski gasket,
SS = (x, y) '→  x−1 , y+1 , (x, y) '→  x−1 , y−1 , (x, y) '→  x+1 , y−1 , 

Space	Partial output	Approx. value	Analytic value	Time (secs)	Memory (bytes)

Falconer	[1, −1, 1, −1, 1]	0.34375 ±  1 
Sierpinski	[1, −1, 1, 0, 1]	0.40625 ±  1 
1/3	20.65	7.1 · 108
11/27	113.39	4.2 · 109

Fig. 6. Results from the integration program applied to various self-similar spaces: The tests were run on

a machine with 4, 2.40 GHz Intel⃝R
XeonTM CPU’s, with 4GB’s of RAM and 8GB’s of swap.

with coefficients ρS = { 1 , 1 , 1 }, and
3 3 3

 				
(x, y) '→ x−3 , y+3 , (x, y) '→  x−3 , y−3 , 
for Falconers fractal, with coefficients ρF = { 1 , 1 , 1 , 1 , 1 }. The results are given in

Figure 6.
2 8 8 8 8



Falconers Fractal

A variant of the Sierpinski gasket.
Fig. 7. Invariant spaces used in the preliminary experiments


Proof of Theorem 3.6
We now give a proof to Theorem 3.6. The is proof constructive, which is essential from a practical point of view: If we simply knew that a suitable S ' existed but did not know how to construct it, then we would be no better off than before. We shall prove Theorem 3.6 in an informal manner, consisting of two steps:
We firstly show how, given any set of contractions S , we can produce an equiv- alent (albeit larger) set of contractions with arbitrarily small contractivity.
Next, we show how the realizer of a function with sufficiently small contractivity can be manipulated so that it is computationally contractive.

Step 1
We start first with some definitions from [10]: Let I be a finite subset of finite ordered tuples i.e. I ⊆ {1, ..., n}∗. Define Iˆ = {α1...αp...|αi ∈ I} ⊆ nω where we are concatenating finite tuples from I in the obvious way. We say I is secure if for

every β ∈ nω there exists a α ∈ I such that α ± β i.e. α is a prefix of β. Moreover
I is tight if this α is unique to β. The following result is due to Hutchinson [10].
Theorem 3.7 Let I be a ﬁnite set as above and S a set of contractions,
Let SI = {Sα |α ∈ I}. Then |SI| = {kβ |β ∈ Iˆ} where kα := ∞ Sα ...α (K).

Let ρ be coefficients inducing a measure on S . Deﬁne ρI : I → (0, 1) by ρI (i1, ..., ip) = ρ(i1)...ρ(ip). Then if I is tight one can check that  α∈I ρI (α) = 1 and furthermore SI, ρI  =  S ,ρ  .
So now given a set S with L  =  maxi=1,..,n Lip(Si)  <  1,  let I  =
{all permutations of ⟨1, ..., m⟩} for some integer m > 0. Then I is tight, |SI| = |S |, SI, ρI  =  S ,ρ  for any suitable ρ and LI := maxα∈I Lip(Sα) = Lm. Since L is necessarily less than 1, we can therefore make LI arbitrarily small.

Step 2
For the second step, we start by outlining some preliminary results. The functions
addone and subone in Figure 8 have the following properties (see e.g. [13,15]):
addone,subone :: interval → interval
addone (1:x) = 1ω
addone (0:x) = 1:addone(x) addone (−1:x) = 1:x

subone (1:x) = −1:x
subone (0:x) = −1:subone(x) subone (−1:x) = −1ω
Fig. 8. The addone and subone algorithms.

Lemma 3.8 For all x ∈ [−1, 1].

(i)

(ii)
[[s˜ubone]](x) =	x − 1	when x > 0
−1	otherwise
[[a˜ddone]](x) =	x +1	when x < 0
1	otherwise

Proof. See e.g. [13]	 
Next define the q-equivalence relation, x ≡q y ⇐⇒ q(x) = q(y). From Lemma
3.8 the following result is apparent,
Corollary 3.9 For any x ∈ 3ω,
if q(x) ≥ 0 then 1 : p-one(x) ≡q x
if q(x) ≤ 0 then −1 : p-negone(x) ≡q x

p-one, p-negone, p-zero :: interval → interval
p-one(0:x) = subone(x) p-one(1:x) = x

p-negone(1:x) = addone(x) p-negone(−1:x) = x

p-zero(0:x) = x
p-zero(1:x) = addone(x) p-zero(−1:x) = subone(x)

if − 1 ≤ q(x) ≤ 1 then 0 : p-zero(x) ≡q x
2	2
Now suppose we have a function S : 3∞ → 3∞ with contractivity strictly less than 1 . Let c = 4S(0ω)0 + 2S(0ω)1 + S(0ω)2.
If c ≥ 3 then q(S(0ω)) ≥ 1 and since S has contractivity strictly less than 1
it follows that q(S(x)) > 0 for all x ∈ 3ω . Thus the function S' ≡ λx. − 1 : p-negone · S(x) is q-equivalent to S i.e. S' ≡q S. Moreover S' is computationally contractive.
Similarly if c ≤ −3 then q(S(0ω)) ≤ − 1 and S ≡q λx.(1 : p-one · S(x))
Finally if −2 ≤ c ≤ 2 then − 1 ≤ q(S(0ω)) ≤ 1 and S ≡q λx.(0 : p-zero · S(x))
4	4
So for suitably contractive functions, we can find an equivalent c.c. set of realizers. Thus provided we have prior knowledge as to the contractivity of each Si ∈ S
we can construct an equivalent SI with contractivity < 1 and then manipulate
these functions into a computationally contractive form. This makes x-integrate universally applicable on the condition that we have some domain knowledge, which is not an unreasonable assumption.
The crucial point here is that given any S we can either find a suitable c.c. rep- resentation of the functions in ((3∞)n → 3∞) or, failing that, generate an equivalent
c.c. set that induces the same invariant space and measure.

Conclusion
In this study we have extended Simpson’s algorithm over the computable invariant spaces. This is a purely theoretical result, and to the best of our knowledge is the first instance of such an algorithm. In proving correctness we made essential use of domain theory, in particular for proving totality.
The crucial step in this study was the use of an intermediate “streams-of- streams” representation, in order to compute multiplication digit-wise and thus make the algorithm total. We have shown how the signed binary arithmetic cannot contain a suitable multiplication algorithm, and indicated how this may generalise to other representations. We may think of our stream-of-streams representation as

the natural extension of the dyadics, as used by Simpson, to achieve integration in [15].
The characteristic of the real line that motivated the integration algorithms in [15,3] is a fundamental trait of all invariant spaces. Moreover it is the defining characteristic of the invariant measures on invariant spaces i.e. every space that can be integrated in this way is an invariant space w.r.t some S and conversely so.
From a practical point of view, the algorithm x-int provides more flexibility in the definition of the integrands, and so is more applicable. Experimental results indicate that the algorithm can compute reasonably quickly on standard hardware.

Further Work
Theorem 3.6 was originally part of an algorithm that implemented the co-ordinate map π : nω → X, for an arbitrary representation X. The intention was to use the original integration algorithm integrate and convert the integrand f : X → 3ω to g = f · π : nω → 3ω. However, the additional complexity of g proved to be unacceptable in practice. From a theoretical perspective, the existence of an algorithm for π is of interest in itself, and we hope to explore this approach in later work.
Acknowledgments
I am deeply grateful to Mart´ın Escard´o for the time, effort and continued encour- agement he has given me. In particular I would like to credit him with the original idea for the algorithm integrate, and the idea of using the stream-of-streams rep- resentation. I would also like to thanks the reviewers for their helpful comments and suggestions.

References
Abramsky, S. and A. Jung, Domain theory, Handbook of Logic in Computer Science 3, Clarendon Press, 1994 pp. 1–168.
Berger, U., “Totale Objecte und Mengen in Bereichstheorie,” Ph.D. thesis, University of Munich (1990), phD Thesis.
Edalat, A. and M. Escard´o, Integration in Real PCF, Information and Computation 160 (2000),
pp. 128–166.
Escard´o, M., Infinite sets that admit fast exhaustive search, Proceedings of LICS’2007 (2007), pp. 443– 452.
Geuvers, H., M. Niqui, B. Spitters and F. Wiedijk, Constructive analysis, types and exact real numbers, Mathematical Structures in Computer Science 17 (2007), pp. 3–36.
Gianantonio, P. D., “A Functional Approach to Computability on Real Numbers,” Ph.D. thesis, University of Pisa, Udine (1993).
Gianantonio, P. D., Real number computability and domain theory, Information and Computation 127
(1996), pp. 12–25.
Gierz, G., K. Hofmann, K. Keimel, J. Lawson, M. Mislove and D. Scott, “Continuous Lattices and Domains,” Cambridge University Press, 2003.

Hoggar, S. G., “Mathematics for Computer Graphics,” Cambridge University Press, 1994.
Hutchinson, J. E., Fractals and self similarity, Indiana University Mathematics Journal 30 (1981),
pp. 713–747.
Kreitz, C. and K. Weihrauch, Theory of representations, Theoretical Computer Science 38 (1985),
pp. 35–53.
Kreitz, C. and K. Weihrauch, Representations of the real numbers and of the open subsets of the set of real numbers., Annals of Pure and Applied Logic 35 (1987), pp. 247–260.
Plume, D., A calculator for exact real number computation (1998), 4th year project.
Scriven, A., “Functional algorithms for Exact Real Integration over Invariant Measures,” Master’s thesis, Department of Computer Science, University of Birmingham (2007).
Simpson, A. K., Lazy functional algorithms for exact real functionals, Lecture Notes in Computer Science 1450 (1998), pp. 456–465.
Streicher, T., “Domain-Theoretic Foundations of Functional Programming,” World Scientific Publishing, 2006.
