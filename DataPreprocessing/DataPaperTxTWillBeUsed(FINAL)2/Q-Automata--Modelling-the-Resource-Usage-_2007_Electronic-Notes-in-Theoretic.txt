	Electronic Notes in Theoretical Computer Science 175 (2007) 153–167	
www.elsevier.com/locate/entcs

Q-Automata: Modelling the Resource Usage of Concurrent Components 1
Tom Chothia2
CWI, Kruislaan 413, Amsterdam, The Netherlands
Jetty Kleijn3
LIACS, Leiden University, P.O.Box 9512, NL-2300 RA Leiden, The Netherlands

Abstract
Q–automata are introduced to model quality aspects of component-based software. We propose Q-algebras as a general framework that allows us to combine and choose between quality values. Such values are added to the transitions of automata, which represent components or channels. These automata can be composed by a product construction yielding a more complex Q-automaton labelled with the combined costs of its components. Thus we establish compositionality of quality of service based on an algebra of quality attributes associated with processes represented by automata.
Keywords: Q-Automata, component-based systems, concurrency, quality of service, compositionality


Introduction
This paper introduces Q-automata, which are designed to model trust and quality aspects of component-based software. Quality of Service (QoS) aspects concern non-functional properties such as availability, response time, memory usage, etc. Following work on constraint semirings [10,15], we propose a general framework for a range of trust and quality values, which we call a Q-algebra. These algebras define a framework for quality values that could be combined with many kinds of automata or calculi. With the aim of making our system suitable for the kinds of applications we expect to model and of making our system more easily understandable, we have chosen to base our work on automata. These provide a concrete, intuitively clear, model of computation, and a structural approach to the analysis of the behaviour

1 Research supported by the ITEA project Trust4All
2 Email: Tom.Chothia@cwi.nl
3 Email: kleijn@liacs.nl

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.03.009

of components and their composition. There is also a large amount of theoreti- cal and implementational work on using automata for representing components in distributed and reactive systems, which may be of use.
Components will be represented by automata, in a similar way to other work [7,14,17,20,21], but the transitions of our automata will have an additional cost label to indicate the impact of taking that transition on the quality attributes of the system. The resulting Q-automata can be composed using a product construc- tion, leading to a new (higher-level) Q-automaton. Most automata models do not distinguish between the interleaving of two actions and their possible concurrent occurrence, however in the model proposed here it is possible that concurrent com- ponents perform their actions simultaneously without having to synchronise (e.g., in a communication). This is because, for multi-threaded programs, the resource usage of an application can be quite different depending on whether the smallest units of abstraction happen at the same time or one after the other. For instance, given two transitions, both of which “cost” a certain amount of bandwidth, mea- sured in kbit/s, running both at the same time will require (or “cost”) the sum of the two individual costs, whereas running them one after the other will only cost the maximum of the two individual costs. Time costs on the other hand will sum sequentially, but not concurrently and we may choose to model memory allocation costs by summing them both concurrently and sequentially.
Semirings have been proposed as a framework for composing and relating QoS parameters [10,15,19]. Assuming a suitable level of abstraction for managing QoS constraints and a metric for the actual QoS values, constraint semirings provide an algebraic structure with two operations, one to select among values and the other to combine values into a new QoS value. Thus compositionality of QoS values is guar- anteed in this approach. We extend constraint semirings to Q-algebras, which have one more operator to combine QoS values. In this way, it becomes possible both to combine costs when they occur sequentially and also when they occur concurrently. Moreover, the costs of such different realisations can be compared within the alge- bra. In general QoS values are tuples with each component representing a particular aspect: the entries can be of different kinds (numerical to indicate latency, access rights of a service, memory usage, etc.) and, as is the case for constraint semirings, a finite number of Q-algebras may be combined leading to tuples of values, since the product of Q-algebras is again a Q-algebra.
We consider automata with QoS values added as additional labels to the in- dividual transitions indicating their use of resources when executed. A product construction is defined to combine the resulting Q-automata into more complex Q-automata. The product can perform any combination of actions of the original automata simultaneously and it can synchronise matching input and output actions to become an internal action. This most general product accommodates many dif- ferent styles of communication between components; to enforce one particular style of communication, such as requiring a single end point for each communication channel, a restriction operator may be applied to remove certain transitions.
The components’ transitions are combined into new transitions the costs of which

are computed from the costs of their constituent transitions. The algebraic structure of the costs domain makes it possible to compare costs, to compute the cost of a transition path (a computation) in a Q-automaton, and to compose the costs of multiple transitions taken concurrently in a composite automaton.
The contributions of this paper are:
a new model of composable automata, which includes a concept of concurrent transitions for modelling concurrent, communicating components,
an extended cost algebra to compute different combinations of costs,
combining the automata and the algebra, leading to the framework of Q- automata,
and showing how both ordinary components and different types of communication channels can be modelled in this framework.
Weighted automata have a simple weight or cost on each transition and have been extensively studied since the early days of computer science [16,26]. These automata have been shown to have practical applications, an example of which is the work of Mohri et al. on speech processing [23,24]. Buchholz and Kemper
[12] describe a method of model checking the class of these automata that only use positive weights. The work we present here differs from weighted automata by using a Q-algebra to provide the costs; this allows us to define a truly compositional model of the resource usage of components.
Timed automata models label transitions with costs representing the time they take [1]. Probability values also combine well with automata, for example Segala
[27] adds simple probabilities to transitions and, more recently, Baier and Wolf look at Markov style probabilistic time delays as labels for constraint automata [6]. We hope that at least some of these costs can be subsumed into our cost algebra framework.
Priced or weighted timed automata [2,9] model time using clocks and have costs on states and transitions. The cost of each transition is paid each time the transition is made whereas the costs of each state is paid once for each time unit the automata spends in that state. This provides an expressive model of costs and time that is, in many cases, undecidable [11].
The automata model we propose is similar to team automata [7,8,17] and related models like I/O automata [20,21] and interface automata [14]. A number of systems attempt to model quantitative aspects of computation by adding semiring costs to process calculi, [5,15,25], these do not distinguish between the concurrent and sequential compositions of costs.
This paper is intended to be a first presentation of our notions and ideas and so, also due to lack of space, it is relatively informal with only a preliminary sketch of initial results. In the next section we introduce our cost algebra and then in Section 3 we define our automata. Restriction and channel communication are discussed in Section 4 where it is shown how the synchronous style of communication between automata can be used to model various kinds of channels. Finally in the concluding Section 5 we briefly discuss how, as future work, the possibly infinite maximum cost

of an automaton can be calculated in finite time and how the maximum cost of the product of two automata is limited by their individual costs.

Q-Algebra
To compute and analyse QoS values in a standard way we develop a general frame- work as in the approach of De Nicola et al. [15]. First we recall the concept of a constraint semiring:
Definition 2.1 A constraint semiring is a structure R = (C, ⊕, ⊗, 0, 1) where C is a set, 0, 1 ∈ C, and ⊕ and ⊗ are binary operations on C such that:
⊕ is commutative, associative, idempotent and has identity 0
⊗ is associative and has identity 1
⊗ distributes over ⊕ and has 0 as an absorbing (zero) element
Note that for a constraint semiring (or c-semiring, for short) as above, the operation ⊕ induces a partial order ≤ on C defined by a ≤ b if and only if a ⊕ b = b. Moreover, two elements are comparable with respect to ≤ if and only if application of ⊕ to these elements yields one (the larger w.r.t. ≤) of the two. Actually, ⊕ always yields the least upper bound of the elements to which it is applied.
Constraint semirings can be used to compose QoS values with “addition” ⊕ to select among values and “multiplication” ⊗ to combine them. Given an action of cost c1 and another action with cost c2 then the cost of both actions together is c1 ⊗ c2, whereas ⊕ returns the least upper bound of c1 and c2. The 0 element, as the identity of ⊕, is the least possible cost value and the 1 element, as the identity of ⊗, is the neutral cost value.
A few examples:
(shortest) time: (R+ ∪ {∞}, min, +, ∞, 0)
bandwidth: (N ∪ {∞}, min, max, ∞, 0)
data encrypted: ({true, false}, ∨, ∧, false, true)
access control: (2U , ∪, ∩, ∅,U ), where U is the set of all users and 2U the set of all subsets of users
Constraint semirings work well when there is just one way to combine quality values. We may use these values to represent the cost of a method call, a sequence of reduction steps or the cost to execute an entire program. When dealing with a number of concurrent processes these steps may take place sequentially or in parallel and these two ways of combining actions might have very different overall results on the resource usage of the system. For instance, two processes that both require a certain number of CPU cycles per second will require a higher number of cycles per second when run at the same time than when run one after the other. We can model these different ways of combining values by adding a new multiplicative operator:
Definition 2.2 A Q-algebra is a structure R = (C, ⊕, ⊗, , 0, 1) such that R⊗ = (C, ⊕, ⊗, 0, 1) and R  = (C, ⊕,  , 0, 1) are c-semirings. C is called the domain of R.

The  operator is used to combine two values concurrently, c1  c2 is the cost of c1 and c2 at the same time. The ⊗ operator combines values sequentially; c1 ⊗ c2 is the cost of c1 followed by c2. Combining costs concurrently or sequentially will not affect the least or neutral cost elements so the two operations share their identities. As before, ⊕ is used to select between values. For example:
(shortest) time: (R+ ∪ {∞}, min, +, max, ∞, 0)
bandwidth: (N ∪ {∞}, min, max, +, ∞, 0)
The product of two Q-algebras is defined component-wise:
Definition 2.3 Given two Q-algebras R1 = (C1, ⊕1, ⊗1,  1, 01, 11) and R2 = (C2, ⊕2, ⊗2, 2, 02, 12), their product R = (C, ⊕, ⊗, , 0, 1) is the Q-algebra de- fined by
C = C1 × C2,
(c1, c2) ⊕ (c' , c' )= (c1 ⊕1 c' , c2 ⊕2 c' ),
1  2	1	2
(c1, c2) ⊗ (c' , c' )= (c1 ⊗1 c' , c2 ⊗2 c' ),
1  2	1	2
(c1, c2)  (c' , c' )= (c1  1 c' , c2  2 c' ),
1  2	1	2
0 = (01, 02),
1 = (11, 12).
It is easy to see that the product of two Q-algebras is indeed a Q-algebra. Sometimes elements of a product in two different Q-algebras represent the same resource. When we take the product of these algebras we do not want to replicate these entries, but rather combine them. This can be achieved by using a Q-algebra with members that are tuples of labelled elements. The following definitions add labels to the algebra, which can be used for comparison when the product of two (labelled) Q-algebras is calculated. These definitions allow us to write values such as: (power:2, cpu:10) and (power:7, errors:1), rather than (2,10) and (7,1) and for their product to be the (power:9, cpu:10, errors:1) rather than (2,10,7,1). These products are only defined if the operations on identically labelled algebras are the same.
Definition 2.4 Let n ≥ 1 and let for each 1 ≤ i ≤ n, Ri = (Ci, ⊕i, ⊗i, i, 0i, 1i) be a Q-algebra. We associate a distinct label li with each Ri (li /= lj if i /= j).
Then R = (C, ⊕, ⊗,  , 0, 1) is a labelled Q-algebra (over (l1 : R1),... , (ln : Rn)) if
C = ({l1}× C1) × ... × ({ln}× Cn); thus each element c ∈ C is a labelled tuple of the form c = (l1 : c1,... , ln : cn) with ci ∈ Ci for all 1 ≤ i ≤ n,
0 = (l1 : 01,... , ln : 0n),
1 = (l1 : 11,... , ln : 1n),
(l1 : c1,... , ln : cn) ⊕ (l1 : c' ,... , ln : c' )= (l1 : (c1 ⊕1 c' ),... , ln : (cn ⊕n c' )),
1	n	1	n
(l1 : c1,... , ln : cn) ⊗ (l1 : c' ,... , ln : c' )= (l1 : (c1 ⊗1 c' ),... , ln : (cn ⊗n c' )),
1	n	1	n
(l1 : c1,... , ln : cn)  (l1 : c' ,... , ln : c' )= (l1 : (c1  1 c' ),... , ln : (cn  n c' )).
1	n	1	n
A labelled Q-algebra is also a Q-algebra. Given a labelled Q-algebra R as speci- fied above, its set of labels {l1,... , ln} is denoted by labels(R). We use the notation projl where l ∈ labels(R), to extract from R the Q-algebra identified by the label l, e.g. projli (R) = Ri. Note that the ordering is arbitrary; up to the ordering of the underlying Q-algebras and their labels, the labelled Q-algebra as just defined

is unique. In the sequel, we will therefore identify any two n-dimensional labelled Q-algebras R and R˜ whenever labels(R)= labels(R˜) and projl(R)= projl(R˜) for all labels l ∈ labels(R).

We say that two labelled Q-algebras R and R˜
are consistent whenever

projl(R)= projl(R˜) for every common label l ∈ labels(R) ∩ labels(R˜).

Definition 2.5 Let R and R˜
be two consistent, labelled Q-algebras. Then the

labelled product of R and R˜, denoted by R da R˜, is the labelled Q-algebra with
labels(R)∪labels(R˜) as its set of labels and defined by projl(R da R˜)= projl(R) if l ∈ labels(R) and projl(R da R˜)= projl(R˜) if l ∈ labels(R˜).
Observe that R da R˜ as above is a labelled Q-algebra. Moreover, as desired, when taking the product of two consistent, labelled Q-algebras, underlying Q-algebras with the same label are not replicated. Finally, it should be noted that the ordinary product of (unlabelled) QoS algebras can be viewed as a special case of the labelled product, namely by giving each algebra its own label. In the rest of this paper we will be dealing only with labelled Q-algebras, even when not referring explicitly to labels.

Q-Automata
In this section we introduce Q-automata. These consist of an initialised labelled transition system together with a (labelled) Q-algebra to specify the cost of each transition. Note that each transition is labelled with a multiset of actions as a representation of simultaneous and multiple occurrences of actions: A multiset over a set X is a function m : X → N and the set of all multisets over X is denoted by
M(X). For two multisets m1 and m2 over X, their sum m1 + m2 is the multiset over X defined by (m1 + m2)(x)= m1(x)+ m2(x) for all x ∈ X.
Definition 3.1 A Q-automaton is a structure P = ⟨S, t, A, R, T ⟩ where:
S is a set of states,
t ∈ S is its initial state,
A is a (finite) set of action names,
R = (C, ⊕, ⊗,  , 0, 1) is a labelled QoS algebra with domain C of costs,
and T ⊆ S × M(Act) × C × S is the set of transitions.
The set of actions of P , written Act, is derived from the set of action names A in the following way: each name a ∈ A can occur as an input action (denoted a?), an output action (denoted a!) or as an internal action (also denoted by a). We thus obtain AO = {a!: a ∈ A}, the set of output actions of P , AI = {a?: a ∈ A}, the set of input actions of P , and Aτ = A the set of internal actions of P . The sets AO, AI , and Aτ are assumed to be pairwise disjoint. Finally, we set Act = AO ∪ AI ∪ Aτ .
The (finite) computations of Q-automata are defined in the standard way.
Definition 3.2 Let P be a Q-automaton specified as in Definition 3.1. A computa- tion (of length n ≥ 0) starting from a state s0 ∈ S is a sequence (s0, m1, c1, s1),... ,

(sn−1, mn, cn, sn) with (si, mi, ci, si+1) ∈ T for all 0 ≤ i ≤ n − 1. If n = 0, then the computation is the empty sequence.
Based on the Q-algebra and the costs of the transitions, we can compute the cost for each computation.
Definition 3.3 Let γ = (s0, m1, c1, s1),... , (sn−1, mn, cn, sn) be a computation as specified in Definition 3.2. Then the cost of γ is 1, if n = 0 and c1 ⊗ ... ⊗ cn if n ≥ 1.
So, the cost of a computation (a sequence of transitions) is computed using the “sequential multiplication” operator ⊗. Note that to compare the costs of different computations, the additive (selection) operation ⊕ can be used since it yields the least upper bound of the given values. “Concurrent multiplication”  is used when Q-automata collaborate in a composite automaton (their product). This product automaton has as its Q-algebra the product of the Q-algebras of its components. Its state space is the Cartesian product of the state spaces of its components and its transitions are combinations of the components’ transitions, as defined below.
In contrast with the traditional synchronous product as applied in the com- position of I/O automata and interface automata and its generalisation in team automata, a product of Q-automata is not based on combined executions of single actions (synchronisation) but rather allows simultaneous occurrence of multiple ac- tions. In addition, similar to the communication set-up of CCS [22] or CSP [18], pairs of input and output actions a? and a! may synchronise (communicate) and together become the internal action a. A product automaton has all possible com- binations of its components’ transitions. Thus, when two components in a certain combination of states can perform matching input and output actions, their product will have from this combined state a communicating transition, but also a transition with those two actions separate and non-communicating (hence still available for communication with other components). Moreover, transitions in which only one of the components is active (either with an input or with an output action) will also be present in the product. For each new transition obtained as a combination of components’ transitions, its cost is computed from the costs of its constituents using the  operator of the product algebra.
In the formal definition of product automata, we use an auxiliary function sync, which in turn uses a relation ⇒ over pairs of multisets of actions such that the pair on the left equals the pair on right except one input on a name in one multiset and one output on the same name in the other multiset have been removed and a communication on that name has been added.
Definition 3.4 Let A be a set of action names, Act be its associated set of ac- tions as defined in Definition 3.1 and m1 and m2 be two multisets over Act. Then
(m1, m2) ⇒ (m' , m' ) if either there exists an a ∈ A such that:
1	2
— m1(a?) ≥ 1 and m2(a!) ≥ 1
— m' (a)= m1(a)+1 and m' (a?) = m1(a?) − 1,
1	1
— m' (a!) = m2(a!) − 1,


	


P	P:

{process}




{stdout!}





{pt}
−6,5


{ps,pt}




{s!,s?}


{s} 7,2

{s?} 6,1

{stdout?}
m:6,c:1
4,30
{s?} 6,1
{pt}
−6,5
7,2
{print} m:−6,c:5



{process} m:10,c:25
{stdout!}
m:1,c:1



{ps,s?}	{s!,pt}
m:16,c:26	m:−5,c:6

Fig. 1. Simple Automata and Their Product
and m' (b)= m1(b) and m' (b)= m2(b) for all other actions b ∈ Act.
1	2
or if (m2, m1) ⇒ (m' , m' ) as above.
2	1
Let ⇒∗ be the reflexive, transitive closure of ⇒. Then
sync(m1, m2)= {m' + m' : for all m' , m' such that (m1, m2) ⇒∗ (m' , m' )}.
1	2	1	2	1	2
Thus sync(m, m') is the set of all multisets that can be obtained by adding m
and m' with any possible combination of communications between them.
Definition 3.5 Let P1 = ⟨S1, t1, A1, R1, T1⟩ and P2 = ⟨S2, t2, A2, R2, T2⟩ be two Q-automata such that R1 and R2 are consistent. Then their product, denoted by P1 ☒ P2, is the Q-automaton defined as P1 ☒ P2 = ⟨S, t, A, R, T ⟩ with
S = S1 × S2,
t = (t1, t2),
A = A1 ∪ A2,
R = R1 da R2,
T = T new ∪ T new ∪ T joint where:
1	2
T new = {((s, t), m, c, (s', t)) : (s, m, c, s') ∈ T1 and t ∈ S2},
T new = {((s, t), m, c, (s, t')) : s ∈ S1 and (t, m, c, t') ∈ T2}, and
T joint = {((s, t), m, c, (s', t')) : ∃(s, m1, c1, s') ∈ T1, (t, m2, c2, t') ∈ T2 such that m ∈ sync(m1, m2) and c = c1  c2}.
As an example of Q-automata and their products we give a simple system in

Figure 1. The automaton P1 listens on the channel stdout and then prints to the screen (an internal action). Automaton P2 does some internal processing and then sends a message over the stdout channel. Each of these actions assigns a certain amount of memory and requires a certain amount of the CPU. The P1 automaton assigns the memory it needs when it receives a request and frees this memory while printing.
The product of P1 and P2 is also displayed in Figure 1, to make this more readable we drop the labels and shorten the action names in the centre of the figure. The automaton P1 ☒ P2 can still receive messages from other automata on the channel stdout. This is just as it should be; all components should be able to print to the screen, not just the first component to be added. The product automaton contains concurrent actions, we see that if P1 receives a call from some third party then P1 ☒ P2 might process and print at the same time. This is of particular interest because it produces the most CPU expensive transition of the whole system and so might make a good test case when testing an implementation of these automata.
We also note that even if automaton P1 sends a message on channel stdout at the same time that P2 receives a message on stdout, it does not automatically mean that P1 and P2 have communicated. Indeed, P1 may receive a message on channel stdout from some other component while P2 sends a message to some other component over the same channel. This is the difference between the {stdout} and the {stdout?, stdout!} action sets and it allows us to prove that constructing products of Q-automata is associative.

Restriction and Communication via Channels
In some cases we may want to impose a more restrictive model of communication on our automata, for instance we might want to require that only a single automa- ton can receive on a given channel or we might want to test our automata in the knowledge that no other automaton will ever be listening on some channel. We can do this by blocking all transitions that involve a given (internal, input, or output) action.
Definition 4.1 Let P = ⟨S, t, A, R, T ⟩ be a Q-automaton and let α ∈ AO ∪ AI ∪ Aτ
be an action of P . Then P \α, the restriction of P with respect to α, is the Q-
automaton ⟨S, t, A, R, T ' ⟩ with T ' = {(s, m, c, s') : (s, m, c, s') ∈ TP and m(α) = 
P	P
0}. For a set of actions X = {α1, α2, ..., αn}, we define P \X as (..(P \α1)\α2)...\αn).
Examples of restrictions are given in Figure 2 (unreachable states are not drawn). The first product automaton is restricted with respect to the stdout! output, to model the situation in which only P1 receives on the stdout channel. Thus P2’s output cannot be received by any other component. The second example restricts with respect to both input and output on stdout and demonstrates how the “closed” product P1 ☒ P2 would run on its own. This results in a small automaton that may be more useful for testing purposes.

P1  P2\stdout!:
{process}

m:10,c:25







{stdout?}
m:6,c:1

{pt}
−6,5



{ps,pt}

4,30






{s?} 1,1






{pt} 5,5

{stdout?} 6,1
{stdout} 7,2






{print} m:−6,c:5


{process}

m:10,c:25



{ps,s?}
m:16,c:26
P1  P2  \{stdout!,stdout?}:


P1 :
Fig. 2. Restricted Products
P2 :

{asrc !} c 1
{asrc !} c 2
{ask ?} c 3
{ask ?} c 4





C1:
{a ?,a !}
c 5

c 6



c 6	c 6
Fig. 3. Automata as Channels
Channel communication
The product construction for automata enforces synchronous communication: an input and output can only communicate and become an internal action if both

happen at the same time. Moreover only one input may synchronise with only one output. To model a wider range of communication styles including asynchronous, lossy and multicasting, we explicitly model channels as automata (in a similar way as for constraint automata [3]).
Component automata will write to the “source” of a channel and read from its “sink”; if two components want to communicate on a channel a, one of them out- puts on the source of a with the action asrc! and the other inputs on the sink of a with the action ask?. Here asrc and ask are different names, associated only by a naming convention, so the product operation does not allow them to synchronise with each other. For a communication to take place the components must use an- other automaton that represents the channel running between them. Such channel automaton will listen on the source of the channel it represents and send on its sink: asrc? and ask!. The two components can then communicate via this channel. Most channel types have one source end and one sink end, but some, such as the synchronous drain which may be used to synchronise two actions, have two source ends or two sink ends and multicast channels may have an arbitrary number of sink ends.
Channel and component automata are illustrated in Figure 3. The component automaton P1 repeatedly sends on the source of the channel a, with cost c1 or c2. The other component automaton P2 may receive on the sink of the channel a with cost c3 or in another way with cost c4. The automata C1, C2 and C3 define three types of channels that the components might use to communicate.
The channel automaton C1 has a single transition that receives on the source of a channel a while at the same time sends on its sink, i.e., this automaton defines a synchronous communication channel. The channel automaton C2 first receives on the source of a and then, some time later, sends on its sink. So this defines an asynchronous channel with a buffer large enough to hold one message. Finally the channel automaton C3 defines a lossy, two-buffer, asynchronous channel. The possibility of losing a message is shown by the τ actions that allow a message that has been received on the source of the channel not to be forwarded to its sink.
As an example of one of these channels being used, Figure 4 shows the closed version of the product P1 ☒ C1 ☒ P2. This represents the two components, P1 and P2 using the channel C1. The double internal action {asrc, ask} represents the communication via a. There are four possible combinations depending on how the components P1 and P2 perform their communications. These different possibili- ties yield different costs. The (open) product P1 ☒ C1 ☒ P2 would have a looping transition with the label {asrc?, ask!} with costs c5. This product automaton could also perform the actions asrc! and ask?, so making it possible for the components to communicate using some other channel that might be added later. Further- more, independent actions might happen concurrently adding more transitions to the product.
In general, the multitude of transitions defined for a product automaton, is nec- essary in order to avoid an “a priori” ruling out of certain kinds of communication. However a restriction to just one kind of communication is possible by automatically

{a sk,asrc }
c2  c5  c4







{a sk,asrc }	{a sk,asrc }
c1  c5  c3	c1  c5  c4






{a sk,asrc }
c2  c5  c3

Fig. 4. P1 ☒ C1 ☒ P2\(inputs ∪ outputs)
applying a restriction to the product.
As an example we may consider a system in which every channel has unique end points, i.e., only one component may read from a channel’s sink and only one component may write to a channel’s source. As we know that inputs and outputs are unique we may close an input and output action once it has had a chance to synchronise. This is done by the following refinement of the product definition:
Definition 4.2 Given Q-automata P1 and P2, their point-to-point product is the Q-automaton
P1 ☒p P2 = P1 ☒ P2\({a!: ∃(s, m, c, t) ∈ (TP1 ∪ TP2 ) such that m(a?) ≥ 1}
∪ {a?: ∃(s, m, c, t) ∈ (TP1 ∪ TP2 ) such that m(a!) ≥ 1}
When modelling such systems, using this definition of product automatically removes many inputs and outputs that we know will not synchronise to become communications and so makes our state space smaller and easier to model check. The restriction operator can also be used to define similar restrictive product oper- ators for other types of communication.

Mobile channels
Mobile channels, such as those implemented in the MoCha mobile channel commu- nication package [4], allow components to be linked by channels whose end points can be moved between locations. In this setting components have a number of unique ports on which they may send and receive messages and channels link these ports to allow communication to take place.
We can model these systems using automata to model components and channels, as described in the last subsection, and we can model the mobility aspects of these channels by allowing the channels to move between states that link different end


{a?,b!}
c


{move?} c2
{move?} c2

{a?,c!}
c



Fig. 5. A Mobile Channel that Moves Between B and C
points. For example, in Figure 5 we have components B and C that listen for input on ports b and c and another component A that sends messages on port a and may also send a move signal. Each of these components would be represented by a suitable automaton, for the sake of simplicity we abstract away their details in the figure.
The automaton in the centre of the figure represents a channel that starts off by linking the output port of A to the input port of B, using the transition with the label {a?, b!}. This performs the same function as the synchronous channel described in the last section, however this channel may also receive a move signal from component A, at which point it will change to linking the output on a to the input on c, so moving the channel end from component B to component C. In this way we can define a wide range of channels that can move their end points between any number of predefined ports.

Conclusion and Further work
We have presented an automata model in which actions are labelled with trust or quality values. We have defined Q-algebras as a general model of these values and we have showed how these automata and the values on the transitions could be meaningfully combined.
Q-automata were conceived as part of the analysis methods developed within the Trust4All project. This is an ITEA project aimed at developing a program- ming environment for “trusted” components that will come with information on their resource usage. We hope that the automata model presented here will be suitable for model checking these components and that ultimately we will be able to automatically generate test data.
We are particularly interested in the maximum possible cost of an automaton and the computations leading to that cost. In general, there may be infinitely many computations starting at a given state and so an infinite number of costs to apply the ⊕ to in order to find the maximum. However, in the case of a finite set of state,

an infinite number of computations can only be generated by looping. A single loop may either add a fixed cost to a computation (leading to a potentially infinite cost), or may set a new, level cost, or might have no effect at all. Therefore a single traverse round a loop is enough to tell you what the effect of an infinite number of traversals of that loop will be. This means that we can calculate the maximum cost in finite time, even if that cost is infinite.
We would also like to develop methods of predicting the behaviour of the product from its individual parts. For instance, we expect that the least upper bound of the concurrent and sequential combination of the maximum cost of two automata is an upper bound on the maximum cost of their product, i.e., if P1 and P2 have the maximum costs c1 and c2 then the maximum cost of P1 ☒ P2 is less than or equal to (c1 ⊗ c2) ⊕ (c1  c2).
Maude [13] is a high level language based on equational and rewriting logic. It provides an easy framework in which to implement Q-automata and model check a few basic properties 4 . We define a Maude module for each kind of cost and for each automaton. The cost modules include equational definitions of ⊕, ⊗ and
 . We define automata in Maude by using constructors to give the states and then defining rewrite rules between these states using the rl command. We may then check cost based properties using Maude’s search command that performs a breadth first search of all the costed states. For instance, we may check that the memory allocated by a given program never goes above 100k. We will continue this development work with the aim of making our prototype more powerful and user friendly.
Acknowledgements
We are indebted to our local colleagues in this project for many fruitful discussions and in particular to Farhad Arbab, Frank de Boer, Marcello Bonsangue, Andries Stam, and Frank Atanassow. We are also grateful to the referees for their construc- tive criticism.

References
R. Alur and D. L. Dill. A theory of timed automata. Theor. Comput. Sci., 126(2):183–235, 1994.
R. Alur, S. La Torre, and G.J. Pappas. Optimal paths in weighted timed automata. Theor. Comput. Sci., 318(3):297–322, 2004.
F. Arbab, C. Baier, J. J. M. M. Rutten, and M. Sirjani. Modeling component connectors in Reo by constraint automata: (extended abstract). Electr. Notes Theor. Comput. Sci., 97:25–46, 2004.
F. Arbab, F. de Boer, J. Guillen Scholten, and M. Bonsangue. Mocha: A middleware based on mobile channels. In COMPSAC, pages 667–673, 2002.
B. Aziz. A semiring-based quantitative analysis of mobile systems. Electr. Notes Theor. Comput. Sci., 157:3–21, 2006.
C. Baier and V. Wolf.	Stochastic reasoning about channel-based component connectors.	In
Coordination 2006, volume 4038 of Lectures Notes in Computer Science, pages 1–15, 2006.

4 The Maude code for the example automata described in this paper are available on-line at:
http://homepages.cwi.nl/∼ chothia/QAutoMaude


M.H. ter Beek, C.A. Ellis, H.C.M. Kleijn, and G. Rozenberg. Synchronizations in team automata for groupware systems. CSCW - The Journal of Collaborative Computing, 12(1):21–69, 2003.
M.H. ter Beek and H.C.M. Kleijn. Team automata satisfying compositionality. In Formal Methods’03, volume 2805 of Lecture Notes in Computer Science, pages 381–400, 2003.
G. Behrmann, A. Fehnker, T. Hune, K. Guldstrand Larsen, P. Pettersson, J. Romijn, and F.W. Vaandrager. Minimum-cost reachability for priced timed automata. In 4th International Workshop on Hybrid Systems, volume 2034 of Lecture Notes in Computer Science, pages 147–161, 2001.
S. Bistarelli, U. Montanari, and F. Rossi. Semiring-based constraint satisfaction and optimization. J. of the ACM, 44(2):201–236, 1997.
P. Bouyer, T. Brihaye, and N. Markey. Improved undecidability results on weighted timed automata.
Inf. Process. Lett., 98(5):188–194, 2006.
P. Buchholz and P. Kemper. Model checking for a class of weighted automata. CoRR, cs.LO/0304021, 2003.
M. Clavel, F. Dur´an, S. Eker, P. Lincoln, N. Mart´ı-Oliet, J. Meseguer, and C. Talcott. The maude 2.0 system. In Rewriting Techniques and Applications 2003, number 2706 in Lecture Notes in Computer Science, pages 76–87, 2003.
L. de Alfaro and T. A. Henzinger. Interface automata. In Proceedings of the Ninth Annual Symposium on Foundations of Software Engineering, pages 109–120. ACM Press, 2001.
R. De Nicola, G. Ferrari, U. Montanari, R. Pugliese, and E. Tuosto. A process calculus for QoS-aware applications. In Coordination 2005, volume 3454 of Lectures Notes in Computer Science, pages 33–48, 2005.
S. Eilenberg. Automata, Languages, and Machines. Academic Press, Inc., 1976.
C.A. Ellis. Team automata for groupware systems. In GROUP’97, pages 415–424. ACM Press, 1997.
C.A.R. Hoare. Communicating sequential processes. Commun. ACM, 26(1):100–106, 1983.
W. Kuich and A. Salomaa. Semirings, Automata, Languages. Springer-Verlag, 1986.
N.A. Lynch. Distributed Algorithms. Morgan Kaufmann, 1996.
N.A. Lynch and M.R. Tuttle. An introduction to input/output automata. In CWI-Quarterly, volume 2(3), pages 219–246, 1989.
R. Milner. A Calculus of Communicating Systems. Springer-Verlag, 1982.
M. Mohri, F. Pereira, and M. Riley. Weighted automata in text and speech processing. In ECAI’96 Workshop on Extended Finite State Models of Language, pages 46–50, 1996.
M. Mohri, F. Pereira, and M. Riley. The design principles of a weighted finite-state transducer library.
Theor. Comput. Sci., 231(1):17–32, 2000.
V. Natarajan and R. Cleaveland. An algebraic theory of process efficiency. In Proceedings of the 11th Annual IEEE Symposium on Logic in Computer Science, page 63. IEEE Computer Society, 1996.
M. P. Schu¨tzenberger. On the definition of a family of automata. Information and Control, 4(2-3):245– 270, 1961.
R. Segala. Modeling and Verification of Randomized Distributed Real-Time Systems. PhD thesis, MIT, Dept. of Elec. Eng. and Comp. Sci., 1995.
