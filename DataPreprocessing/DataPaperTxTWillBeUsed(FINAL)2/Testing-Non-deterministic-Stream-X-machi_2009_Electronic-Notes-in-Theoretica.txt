

Electronic Notes in Theoretical Computer Science 227 (2009) 113–126
www.elsevier.com/locate/entcs

Testing Non-deterministic Stream X-machine Models and P systems
Florentin Ipate 1
Department of Computer Science University of Pitesti
Str Targu din Vale 1, 110040 Pitesti, Romania
Marian Gheorghe2
Department of Computer Science University of Sheffield
Regent Court, Portobello Street, Sheffield S1 4DP, UK

Abstract
Under certain well defined conditions, the stream X-machine testing method can produce a test set that is guaranteed to determine the correctness of an implementation. The testing method has originally assumed that an implementation of each processing function or relation is proven to be correct before the actual testing can take place. Such a limitation has been removed in a subsequent paper, but only for determin- istic X-machines. This paper extends this result to non-deterministic stream X-machines and considers a conformance relationship between a specification and an implementation, rather than mere equivalence. Furthermore, it shows how this method can be applied to test a P system by building a suitable stream X-machine from the derivation tree associated with a partial computation.
Keywords: testing, correctness, X-machines, P systems, finite state machines, non-determinism.


Introduction
The stream X-machine (SXM ) [10] is a form of extended finite state machine (FSM). It describes a system as a finite set of states and a number of transitions between states. In addition, a SXM contains an internal store, called memory. A transition is triggered by an input value, produces an output value and may access and/or alter the memory. A transition diagram of a SXM is a finite automaton (called an associated automaton) in which the arcs are labelled by relation names (referred to as processing relations). Under certain well defined design for test conditions, it is

1 Email: florentin.ipate@ifsoft.ro
2 Email: m.gheorghe@dcs.shef.ac.uk

1571-0661/© 2008 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.107

possible to produce a test set that is guaranteed to determine the correctness of an implementation under test (IUT ) [14,10,2,12,16].
Traditional extended finite-state machine test generation methods [3,17] rely on the construction of an equivalent finite state machine, where states are the state/memory pairs of the original SXM. For complex specifications, this leads to a known state explosion problem; the SXM testing method does not perform such a construction. Instead, however, the method assumes that the processing functions (relations) are correctly implemented and reduces testing of a SXM to testing of its associated automaton. Therefore, it is fair to say that the method only tests the integration of the implementation of processing functions (relations). In practice, the correctness of an implementation of a processing function (relation) is checked by a separate process [10], using the SXM testing method or alternative functional methods. The method (called in what follows SXM integration testing) was first developed in the context of deterministic SXMs (i.e. those SXMs in which all labels represent partial functions rather than relations and an input can trigger at most one transition in any state and for any memory value). The deterministic SXM (DSXM ) integration testing method [14,10] was extended to the non-deterministic case (NSXM integration testing) in paper [15]. Conformance testing for SXMs has been previously considered in [8] for a subclass of quasi-non-deterministic SXMs; later work [9] uses a rather general definition of conformance, but requires an im- plementation to compute a function (this paper assumes a non-deterministic IUT). The applicability of the mentioned integration testing methods is limited by the assumption that the implementation of each processing function (relation) can be tested in isolation from the rest of the system. This is not always a realistic assumption. This limitation has been removed [11] in the context of deterministic SXMs, so that testing of functions can be performed along with the integration testing. This paper extends [11] for non-deterministic SXMs. This is called complete NSXM testing. Such an extension is not trivial for the following reasons: (a) in a non-deterministic SXM an input sequence may potentially produce an infinite number of output sequences, while a test set will be applied to an IUT for a limited number of times (as few as possible); (b) in a non-deterministic SXM some paths
may never be exercised.
Since their introduction in 1998 [19], P systems have been intensively studied and developed, in particular with regard to the computational power of different variants and their capability to solve hard problems. In the last years there have also been significant developments in using the P systems paradigm to model, simu- late and formally verify various systems [5]. Suitable classes of P systems have been associated with some of these applications and software packages have been devel- oped. Although formal verification has been applied to different models based on P systems [10], testing is completely neglected in this context. Testing is an essential part of software development and all software applications, irrespective of their use and purpose, are tested before being released. Two recent papers provide initial steps towards building a P system testing theory: based on rule coverage [7] and on FSM conformance techniques [13]. In this paper we develop a testing method

for non-deterministic SXMs and show how this can be applied to P systems: a way of deriving a SXM from a P system is provided and the method is applied to the obtained model. This approach significantly extends the previous testing methods for P systems by considering (1) a SXM model of a P system instead of a simple FSM and also (2) non-determinism, a widely spread characteristic of P systems.
Preliminaries
This section introduces the notation and the formalisms used in the paper: finite state machines, stream X-machines and P systems.
For a finite alphabet A, A∗ denotes the set of all finite sequences with members in A; ϵ denotes an empty sequence. For a, b ∈ A∗, ab denotes the concatenation of sequences a and b; an is defined by a0 = ϵ and an = an−1a for n ≥ 1. For U, V ⊆ A∗, UV = {ab | a ∈ U, b ∈ V }; Un is defined by U 0 = {ϵ} and Un = Un−1U for n ≥ 1. For a relation f : A ←→ B, dom(f ) denotes the domain of f and Im(f ) denotes the image of f . If a ∈/ dom(f ), we write f (a)= ∅. For U ⊆ A, f (U )= ∪a∈U f (a) and f | U : U ←→ B denotes the restriction of f to U , i.e. f | U (a)= f (a), ∀a ∈ U . For two relations f, g : A ←→ B, we use f ± g to denote that dom(f ) = dom(g) and for any a ∈ dom(f ), f (a) ⊆ g(a). For φ : M × Σ ←→ Γ × M and m ∈ M we define

φ :Σ ←→ Γ by ωφ (σ)= πΓ
(φ(m, σ)), σ ∈ Σ, where πΓ
: Γ × M −→ Γ denotes the

projection function. We shall also use the projection function πM :Γ × M −→ M . For a finite set A, #A denotes the number of elements of A.
Definition 2.1 A finite automaton ( FA for short) is a tuple (Σ, Q, F,I), where Σ is a ﬁnite input alphabet; Q is a ﬁnite set of states; F is a (partial) next state function, F : Q×Σ −→ 2Q; I is a set of initial states, I ⊆ Q; all states are assumed terminal.
Function F is usually described by a state transition diagram. A FA is called deterministic if there is one initial state (I = {q0}) and F maps each state/input pair into at most one state (F : Q × Σ −→ Q). The next state function can be extended to a partial function F∗ : Q × Σ∗ −→ Q defined by F∗(q, ϵ)= q, ∀q ∈ Q; F∗(q, sσ) = F (F∗(q, s), σ)), ∀q ∈ Q, s ∈ Σ∗,σ ∈ Σ. For q ∈ Q, LA(q) = {s ∈ Σ∗ | (q, s) ∈ dom(F∗)}. If q = q0 then the set is simply denoted LA and called the language accepted by A. A state q ∈ Q is called accessible if ∃s ∈ Σ∗ such that F∗(q0, s) = q. A is called accessible if ∀q ∈ Q, q is accessible. For U ⊆ Σ∗, two states q1, q2 ∈ Q are called U-equivalent if LA(q1) ∩ U = LA(q2) ∩ U ; otherwise, q1 and q2 are called U-distinguishable. If U = Σ∗ then q1 and q2 are simply called equivalent or distinguishable. A is called reduced if ∀q1, q2 ∈ Q, ((q1 /= q2) =⇒ (q1 and q2 are distinguishable)). A deterministic FA A is called minimal if any other FA that accepts the same language as A has at least the same number of states as
A. The reader is assumed to be familiar with basic automata theory, for details see
for example [6].
Given a FA specification A and a class of implementations C, a test set of A
w.r.t. C is a set of input sequences that, when applied to any implementation
A' in the class C, will detect any response in A' that does not conform to the

response specified by A, i.e. ∀A' ∈ C, (LA ∩ Y = LA' ∩ Y =⇒ LA = LA' ). The class C is identified by the assumptions we can make about an implementation A'. If no information is available, a test set may not exist for even very simple FA specifications. There are a number of more or less realistic assumptions that one can make about the form and size of an implementation and these, in turn, give rise to different techniques for generating test sets [17]. One of the least restrictive assumptions refers to the number of states of A' and is the basis for the W method [4,1]: the difference between the number of states of an implementation and that of a specification has to be at most k, a non-negative integer estimated by a tester.
The W -method involves the selection of two sets of input sequences, a transition cover P and a characterization set W defined as follows:
Definition 2.2 S ⊆ Σ∗ is called a state cover of A if ϵ ∈ S and ∀q ∈ Q \ {q0},
∃s ∈ S such that F∗(q0, s) = q. P ⊆ Σ∗ is called a transition cover of A if S ∪ SΦ ⊆ P for some state cover S of A. W ⊆ Σ∗ is called a characterisation set of A if any two distinct states q1, q2 ∈ Q, q1 /= q2, are W-distinguishable.
Note that a state cover, a transition cover and a characterisation set exist if A is minimal.
Theorem 2.3 [1] Let A be a deterministic FA having input alphabet Σ, n the num- ber of states of A, m ≥ n and Cm the set of deterministic FAs with an input alphabet Σ and each with a maximal number of states m. If P is a transition cover and W a characterisation set of A then Ym−n = P (Σm−n ∪ Σm−n−1 ∪ ... ∪ {ϵ})(W ∪ {ϵ}) is a test set of A w.r.t. Cm.
The above theorem is the theoretical basis for the W -method in the context of partially specified deterministic FA. The reason ϵ is included in W is to ensure that if an IUT has ignored the last element σ of a sequence of inputs verifying the existence of a transition triggered by σ, this will be detected.
A SXM is a form of extended FSM as defined next.
Definition 2.4 A SXM is a tuple Z = (Σ, Γ, Q, M, Φ, F,I, m0), where Σ and Γ are ﬁnite sets called an input alphabet an output alphabet respectively; Q is a ﬁnite set of states; M is a (possibly) inﬁnite set called memory; Φ, called the type of Z, is a ﬁnite set of distinct processing relations that the machine can use. A processing relation is a non-empty relation of the form φ : M × Σ ←→ Γ ×M. Often Φ is a set of (partial) functions. F is the (partial) next state function, F : Q× Φ −→ 2Q. In a similar way to ﬁnite automata, F is usually described by a state transition diagram. I is a set of initial states, I ⊆ Q; m0 is the initial memory value, m0 ∈ M.
It is sometimes helpful to think of a SXM as a finite automaton with the arcs labelled by relations from the type Φ. The FA AZ = (Φ, Q, F,I,T ) over an alphabet Φ is called the associated FA of Z.
Definition 2.5 Given a sequence p ∈ Φ∗, p induces the relation |p | : M × Σ∗ ←→ Γ∗ × M deﬁned as follows: (1) (m, ϵ) | ϵ | (ϵ, m), ∀m ∈ M, (2) ∀p ∈ Φ∗,φ ∈ Φ, (m, sσ) | pφ | (gγ, m'), where ∀m, m' ∈ M, s ∈ Σ∗,g ∈ Γ∗,σ ∈ Σ,γ ∈ Γ are such that ∃m'' ∈ M with (m, s) | p | (g, m'') and (m'', σ)φ(γ, m').

A sequence | p | can be considered a relation between a (memory, input string) pair and the (output string, memory) pairs produced by a consecutive application of the relations in p. It is easy to see that if Φ is a set of (partial) functions rather than relations then | p | is a also a (partial) function.
Definition 2.6 A SXM Z is called deterministic if the following three conditions hold: (1) the associated FA of the machine Z is deterministic, i.e. Z has only one initial state (I = {q0}) and the next state function maps each pair of (state, processing function) onto at most one state (F : Q × Φ −→ Q); (2) Φ is a set of (partial) functions rather than relations; (3) any two distinct processing functions that label arcs emerging from the same state have disjoint domains, i.e. ∀φ1, φ2 ∈ Φ, ((∃q ∈ Q with (q, φ1), (q, φ2) ∈ dom(F )) =⇒ (φ1 = φ2 or dom(φ1) ∩ dom(φ2)= ∅)).
From the above definition, NSXMs can have three types of non-determinism: state non-determinism if #I > 1 or ∃q ∈ Q, φ ∈ Φ with #(F (q, φ)) > 1; oper- ator non-determinism if some elements of Φ are relations but not partial func- tions; domain non-determinism if there exist q ∈ Q, φ1, φ2 ∈ Φ, φ1 /= φ2 with (q, φ1), (q, φ2) ∈ dom(F ) and dom(φ1)∩dom(φ2) /= ∅. It is not necessary to consider the case of state non-determinism since it can easily be eliminated by rewriting a NSXM using standard algorithms that take a non-deterministic FA and produce an equivalent deterministic FA; in general, this transformation may introduce domain non-determinism. Further, NSXMs are assumed to be free of state non-determinism and are denoted by a tuple Z = (Σ, Γ, Q, M, Φ, F, q0, m0) where F is a partial func- tion and q0 is the initial state. The associated deterministic FA is then a tuple AZ = (Φ, Q, F, q0). In general, a non-deterministic SXM computes a relation since the application of an input sequence may produce more than one output sequence. The exact correspondence between an input sequence and an output produced is defined next.
Definition 2.7 A SXM Z, computes a relation fZ : Σ∗ ←→ Γ∗ deﬁned by : s fZ g
if there is p ∈ Φ∗,m ∈ M such that p ∈ LA	and (m0, s) | p | (g, m).
When a path p is important, we will write s fp g. Note that for a SXM featuring domain non-determinism, p may not be uniquely identified by s. If Z is a deter- ministic SXM, then fZ is a (partial) function rather than a relation. We define a computation of Z as any subset of fZ that associates each input sequence s with output sequences produced when a machine exercises every path in Z that can be traversed by s at least once.
Definition 2.8 A relation k : Σ∗ ←→ Γ∗ is called a computation of Z if the following two conditions hold: (1) ∀ s ∈ Σ, g ∈ Γ, s k g =⇒ s fZ g; (2) ∀ s ∈ Σ, g ∈ Γ, p ∈ Φ∗, s fp g =⇒ (s fp g' and s k g' for some g' ∈ Γ).
Z	Z
The set of all computations of Z is denoted by HZ. It is easy to see that fZ ∈ HZ and ∀ k ∈ HZ, k ± fZ. If Φ is a set of (partial) functions (such as when Z is a DSXM) then HZ = {fZ}, because in this case for each path through the machine there is only one sequence of possible outputs.
The following definition refers to one of the many variants of P systems, namely

cell-like P system, which uses non-cooperative transformation and communication rules [20]. Since now onwards we will refer to this model as simply P system.
Definition 2.9 A P system is a tuple Π= (V, μ, w1, ..., wn, R1, ..., Rn), where
V is a ﬁnite set, called alphabet;
μ deﬁnes the membrane structure; a hierarchical arrangement of n compartments called regions delimited by membranes; these membranes and regions are identi- ﬁed by integers 1 to n;
wi, 1 ≤ i ≤ n, represents the initial multiset occurring in region i;
Ri, 1 ≤ i ≤ n, denotes the set of rules applied in region i.
The rules in each region have the form a → (a1, t1)...(am, tm), where a, ai ∈ V , ti ∈ {in, out, here}, 1 ≤ i ≤ m. When such a rule is applied to a symbol a in the current region, the symbol a is replaced by the symbols ai with ti = here; symbols ai with ti = out are sent to the outer region (or environment when the current region is the most external) and symbols ai with ti = in are sent into one of the regions contained in the current one, arbitrarily chosen. In the following definitions and examples all the symbols (ai, here) are used as ai. The rules are applied in maximally parallel mode which means that they are used in all the regions in the same time and in each region all symbols that may be processed, must be. A configuration of the P system Π is a tuple c = (u1, ..., un), ui ∈ V ∗, 1 ≤ i ≤ n. A derivation of a configuration c1 to c2 using the maximal parallelism mode is denoted by c1 =⇒ c2.

NSXM Integration Testing
This section presents the theoretical basis for the NSXM integration testing method [15]. This method generates a test set from a non-deterministic SXM specification, providing that the system components (i.e. processing relations) are implemented correctly. Therefore, it is assumed that the IUT is a NSXM having the same type (processing relations) as a specification. The concepts and results in this section are largely from [15], the presentation of which has been slightly modified to fit with other published work in the area [8,11]. The essence remains unchanged.
In order to test non-deterministic implementations, one usually makes a so-called complete-testing assumption [18]: it is possible, by applying a given input sequence s to an implementation for a finite number of times, to exercise all the paths of the implementation that can be traversed by s. Without such an assumption, no test suite can guarantee full fault coverage of non-deterministic implementations. For testing of an IUT Z' against a specification Z, we apply elements of a test set X a number of times, so as to ensure that both a specification and an implementation traverse all paths they can. During a test, only a subset of a (potentially infinite) set of outputs is observed from a non-deterministic implementation; for this reason, a possible computation k' of Z' is observed (k' | X). If all outputs of Z' in response to X can be produced by Z, it means that Z performed a computation k and

k | X = k' | X. In this case, we should be able to conclude that for any sequence of inputs Z' will produce an output which is allowed by Z. This justifies the following.

Definition 3.1 Let Z be a SXM and C a set of SXMs having the same input alphabet (Σ) and output alphabet (Γ) as Z. Then a ﬁnite set X ⊆ Σ∗ is called a test set of Z w.r.t. C if ∀Z' ∈ C, k | X = k' | X for some k ∈ HZ, k' ∈ HZ' implies fZ = fZ' .
It is assumed that an IUT is a NSXM having the same input alphabet, output alphabet, memory and an initial memory value as a specification; additionally, a SXM specification has to satisfy three conditions: input-completeness, output- distinguishability and observability.
Definition 3.2 Two SXMs Z and Z' are called weak testing compatible if they have identical input alphabets, output alphabets, memory sets and initial memory values. Two weak testing compatible SXMs are called testing compatible if they have identical types.
Φ is called input-complete if ∀φ ∈ Φ,m ∈ M, ∃σ ∈ Σ such that (m, σ) ∈ dom(φ).
Φ is called output-distinguishable if ∀φ1, φ2 ∈ Φ, (there are m ∈ M, σ ∈ Σ such
that ωφ1 (σ) ∩ ωφ2 (σ) /= ∅), then φ = φ (ωφ was introduced in Sect. 1).
m	m	1	2	m
Φ is called observable if ∀φ ∈ Φ,σ ∈ Σ,γ ∈ Γ, m, m1, m2 ∈ M, ((γ, m1) ∈ φ(m, σ),
(γ, m2) ∈ φ(m, σ) implies m1 = m2).
These three conditions (input-completeness, output-distinguishability and ob- servability) are generally known as “design for test conditions” [10,14]. 3 With- out them, it would be extremely difficult to test a system properly. The input- completeness condition ensures that all sequences of processing relations in the associated FA can be attempted using appropriate inputs, so they can be tested against the implementation. The output-distinguishability condition ensures that any processing relation can be identified from the machine computation by examin- ing the outputs produced. When Φ is observable, the next memory value computed by relations can be determined. Note that if Φ is a set of (partial) functions then it is already observable, so this condition is not explicitly stated when considering such SXMs (such as DSXMs).
The basic idea of the testing method is to translate a test set of an associated FA into a test set of an IUT. In order to do this, we need a mechanism, called a test function, that converts sequences of processing relations into sequences of inputs.
Definition 3.3 Let Z = (Σ, Γ, Q, M, Φ, F, q0, m0) be a SXM with an input-complete type Φ. A test function of Z t : Φ∗ −→ Σ∗ is deﬁned as follows. First of all, t(ϵ)= ϵ; for n > 0 and φ1,..., φn ∈ Φ, t(φ1 ... φn)= σ1 ... σk, where σ1,..., σk ∈ Σ are such that (m0, σ1 ... σk) ∈ dom(| φ1 ... φk |). In order to determine the value k ≤ n, two cases are considered, (1) φ1 ... φn ∈ LAZ , in which case k = n; (2) φ1 ... φn ∈/ LAZ and for 0 ≤ i < n there is φ1 ... φi ∈ LAZ such that φ1 ... φi+1 ∈/ LAZ , in which case k = i + 1.

3 The design for test conditions for a deterministic SXM have been relaxed in [12] and [16]

In other words, for any sequence v = φ1 ... φn of processing relations, t(v) is a sequence of inputs that exercises the longest prefix φ1 ... φi of v that is a path in a specification NSXM and, if i < n, also exercises φi+1, the relation that follows after this prefix. Note that since Φ is input-complete there always exist σ1,..., σk as above, but these are not necessarily uniquely defined.
The result below is the theoretical basis for NSXM integration testing.
Theorem 3.4 [15] Let Z be a SXM having type Φ input-complete, output- distinguishable and observable and C a set of SXMs testing compatible with Z. If t is a test function of Z and Y ⊆ Φ∗ a test set of AZ w.r.t. AC, where AC = {AZ' | Z' ∈ C}, then X = t(Y ) is a test set of Z w.r.t. C.
Since C is a set of (non-deterministic) SXMs testing compatible with Z, it is assumed that the processing relations are implemented correctly, i.e. an IUT uses the same set of processing relations as a specification. Therefore, the method only tests the integration of processing relations. The correctness of implementation of these relations is checked by separate testing processes, as discussed in [15].
We can now use theorems 3.4 and 2.3 to generate a test set of Z w.r.t. Cm, the set of NSXMs testing compatible with Z whose number of states does not exceed m ≥ n. This is Xm−n = t(Ym−n), where Ym−n = P (Φm−n ∪ ... ∪ {ϵ})(W ∪ {ϵ}), n is the number of states in Z, P is a transition cover and W a characterisation set of AZ and t is a test function of Z. More details about the applicability of the NSXM integration testing method can be found in reference [15].

Theoretical Basis for Complete NSXM Testing
This section presents the theoretical basis for the complete NSXM testing method. Unlike integration testing, no assumption is made here regarding the correctness of the implementation of processing relations. Therefore, the general case is considered when a specification and an IUT may have different types (i.e. are weak testing compatible). Furthermore, an IUT will be checked for conformance to a specification rather than for equivalence. An IUT Z' conforms to Z if Z' is defined on all inputs on which Z is defined and the behaviour of Z' is a subset of the behaviour of Z that traverses every path of Z at least once.
Definition 4.1 Let Z and Z' be two SXMs having the same input alphabet (Σ) and output alphabet (Γ). We say that Z' conforms to Z, written Z' ± Z, if fZ' ± fZ and HZ ∩ HZ' /= ∅.
The definition of a test set is revised to reflect the more general situation.
Definition 4.2 Let Z be a SXM and C a set of SXMs with the same input alphabet (Σ) and output alphabet (Γ) as Z. Then a ﬁnite set X ⊆ Σ∗ is called a conformance test set of Z w.r.t. C if ∀Z' ∈ C, k | X = k' | X for some k ∈ HZ, k' ∈ HZ' implies Z' ± Z.
Obviously, any test set of Z w.r.t. C is also a conformance test set of Z w.r.t. C. If Z is a deterministic SXM then the notions of a test set and a conformance test

set coincide.
The output-distinguishability condition has to be updated for the situation where a specification and an implementation may have different types.
Definition 4.3 Let  Z    =   (Σ, Γ, Q, M, Φ, F, q0, m0)  and  Z'   = (Σ, Γ, Q', M, Φ',F', q' , m0) be two weak testing compatible SXMs having types Φ and Φ', respectively. Then Φ is called output-distinguishable w.r.t. Φ' if there exists a bijective function c : Φ −→ Φ' such that the following holds:
∀φ ∈ Φ, φ' ∈ Φ', ((∃m ∈ M, σ ∈ Σ such that ωφ (σ) ∩ ωφ' (σ) /= ∅) =⇒ φ' = c(φ)).
m	m
This says that, for a processing relation φ in Φ, we must be able to identify a corresponding relation φ' = c(φ) in Φ' by examining outputs. Naturally, if Φ is output-distinguishable then Φ is also output-distinguishable w.r.t. itself. In the

conditions of Def. 4.3 we denote by A−c
= (Φ, Q',F'
, q' ) the FA obtained by

substituting each arc c(φ) in AZ' with φ, i.e. F ' (q', φ) = F'(q', c(φ)). Obviously,
for φ1,..., φn ∈ Φ, φ1 ... φn ∈ LA−c iff c(φ1) ... c(φn) ∈ LAZ' .
Z
Design for test conditions imply two important properties of computations, (1) the HZ ∩ HZ' /= ∅ condition of Def. 4.1 requires AZ and AZ' to be equivalent

(reference [9] permits L '
Z
⊆ LAZ rather than LA'
= LAZ as considered here, but

restricts consideration to integration testing of an IUT which computes a function);
(2) an equivalent definition to Def. 4.1 can be written as domfZ' = domfZ ∧ fZ' ∈ HZ.
Since the method does not assume that processing relations are correctly imple- mented, we will have to test their implementations in addition to their integration. Therefore, a test set has to contain two components: an integration test set (from the previous section) and a set for testing processing relations (called a relation test set ). The latter is defined below.
Definition 4.4 Let  Z   =   (Σ, Γ, Q, M, Φ, F, q0, m0)  and  Z'   = (Σ, Γ, Q', M, Φ',F', q' , m0) be two weak testing compatible SXMs.  Then for
φ ∈ Φ and m ∈ M, a ﬁnite set Σφ ⊆ Σ is called an m conformance test set

of φ w.r.t. Φ' if the following holds: ∀φ' ∈ Φ', (if ψ | Σφ
= ψ' | Σφ
for some

ψ, ψ' :Σ ←→ Γ, ψ ± ωφ , ψ' ± ωφ' then φ' ± φ).
m	m
φ  is called a m test set of φ w.r.t.	Φ' if the following holds: ∀φ' ∈ Φ, (if
'
ψ | Σφ = ψ' | Σφ for some ψ, ψ' :Σ ←→ Γ, ψ ± ωφ , ψ' ± ωφ then φ' = φ).
m	m	m	m
An m (conformance) test set of φ w.r.t. Φ' is a finite set of inputs that checks φ
(for conformance or equivalence) against any processing relation in Φ'.
Definition 4.5 Let Z be a SXM having type Φ. Then a set V = {v1,..., vk}⊆ Φ∗
is called a relation cover of Z if Φ can be written as Φ= {φ1,..., φk} such that the
following hold: (1) v1 = ϵ and φ1 ∈ LAZ ; (2) for any 2 ≤ i ≤ k, vi ∈ {φ1,..., φi−1}
∗
and viφi ∈ LAZ .
In the above definition, vi is a sequence containing only the relations φ1,..., φi−1
that reach a state in a specification from which an arc with φi is defined. Therefore,
V reaches every processing relation in AZ using sequences of relations that have already been accessed. ¿From Def. 4.5, it follows that a relation cover of Z exists if

for any proper subset Φ0 of Φ, LAZ \Φ /= ∅. This happens if AZ is accessible and all
∗
processing relations in Φ are actually used as labels in AZ (i.e. πM (dom(F )) = Φ), as can be expected in practice.
Definition 4.6 Let  Z   =   (Σ, Γ, Q, M, Φ, F, q0, m0)  and  Z'   = (Σ, Γ, Q', M, Φ',F', q' , m0) be two weak testing compatible SXMs, Φ= {φ1,..., φk} input-complete, V = {v1,..., vk} a relation cover of Z and t a test function of

Z. Then XΦ = ∪k
t(vi)Σi
is called a relation test set of Z w.r.t. Φ' if for any

1 ≤ i ≤ k, mi ∈ πM (| vi | (m0, t(vi))) and Σi	is an mi conformance test set of φi
w.r.t. Φ' such that {mi}× Σi	∩ dom(φi) /= ∅.
For simplicity, in the expression of XΦ we used t(vi) instead of {t(vi)}. A relation test set of Z exists if a relation cover of Z exists and Φ is input-complete. Due to non-determinism, relations can produce any possible values of memory; in order
to test any given relation φi, it is necessary to attempt all values from Σi	for
some value mi of memory. If t(vi) reaches different values of memory every time it is attempted, this cannot be done. For this reason, we have to strengthen the complete-testing assumption by requiring that there is an output sequence that can always (i.e. eventually) be produced by a NSXM in response to an input sequence. From the observability condition, this ensures the existence of mi which can be
reached #Σi	times by t(vi).
The idea behind the construction of a relation test set is to access and test every relation in AZ using sequences of relations that have already been tested. Therefore, a relation test set is used to test the processing relations of a SXM specification against their implementations, as shown by the result below.
Lemma 4.7 Let Z and Z' be two weak testing compatible SXMs having types Φ and Φ', respectively, such that Φ is input-complete, output-distinguishable w.r.t. Φ' and observable. If XΦ is a relation test set of Z w.r.t. Φ' and k | XΦ = k' | XΦ for some k ∈ HZ, k' ∈ HZ' , then there exists a bijective function c :Φ −→ Φ' such that for any φ ∈ Φ, c(φ) ± φ.


Proof. Let Φ = {φ1,..., φk}, V = {v1,..., vk} and XΦ = ∪k
t(vi)Σi
be as in

Def. 4.6. Let also c :Φ −→ Φ' be as in Def. 4.3. For simplicity, we use c : Φ∗ −→ Φ'∗ to denote the free-semigroup morphism induced by c. We prove by induction on
1 ≤ i ≤ k the following statement: c(φi) ± φi and c(viφi) ∈ LA ' .

For i = 1 this is c(φ1) ± φ1 and c(φ1) ∈ LA
' . Let σ1 ∈ Σ1
and γ1 ∈ Γ, such

that γ  ∈ k(σ ) ∩ ωφ1 (σ ). Since k(σ ) = k'(σ ), ∃φ' ∈ Φ' such that φ' ∈ L

1	1	m0	1	1	1
AZ'

such that γ
∈ k'(σ ) ∩ ωφ' (σ ), so γ
∈ ωφ1 (σ ) ∩ ωφ' (σ ). Since Φ is output-

1	1	m0	1
1	m0	1
m0	1

distinguishable w.r.t.  Φ', we have φ' = c(φ1), so c(φ1) ∈ LA ' .  Furthermore,
we define o1 : Σ1	←→ Γ by σ1 o1 γ1 for all σ1 and γ1 as above and define

ψ , ψ' : Σ ←→ Γ by ψ (σ) = o (σ), σ ∈ Σ1
, ψ (σ) = ωφ1 (σ), σ ∈ Σ \ Σ1 ,

1	1	1	1
m0	1	m0	m0

'
ψ' (σ) = o (σ), σ ∈ Σ1 , ψ' (σ) = ωφ (σ), σ ∈ Σ \ Σ1
. It is easy to verify that

1	1	m0	1	m0	m0

ψ  ± ωφ1 , ψ'
φ'
± ω 1
and ψ
| Σ1
= ψ'
| Σ1
. Since Σ1
is an m
conformance

1	m0	1	m0
1	m0
1	m0
m0	0

test set of φ1 w.r.t. Φ', we have c(φ1) ± φ1.

Assume the statement true for 1 ≤ j ≤ i − 1, i > 1. Let si = t(vi), gi ∈ Γ∗,

σ ∈ Σi
, γ ∈ Γ such that g γ
∈ k(s σ ) ∩ ω|viφi|(s σ ). Since Φ is observable, there

i	mi	i
i i	i i
m0	i  i

is an unique mi ∈ M such that (gi, mi) ∈| vi | (m0, si). ¿From k(siσi)= k'(siσi) it
' '
follows that ∃v' ∈ Φ'∗, φ' ∈ Φ' such that v'φ' ∈ L	and g γ ∈ k'(s σ )∩ω|v φ |(s σ ),

i	i	AZ'	i i
i i	m0	i i

' '
so g γ ∈ ω|viφi|(s σ ) ∩ω|v φ |(s σ ). Since Φ is output-distinguishable w.r.t. Φ',Φ is
i i	m0	i i	m0	i i
observable and ∀1 ≤ j ≤ i, c(φj) ± φj, we have (1) v' = c(vi) and (2) mi ∈ M is the unique memory value such that (gi, mi) ∈ | c(vi) |(m0, si). Furthermore, c(vi)φ' ∈

L	and γ
∈ ωφ' (σ ), so γ
∈ ωφi (σ )∩ωc(φi)(σ ). Since Φ is output-distinguishable

AZ'
i	mi	i
i	mi	i	mi	i

w.r.t. Φ', we have φ' = c(φi), so that c(viφi) ∈ LA ' . Similarly to the base case,
we define oi : Σi	←→ Γ by σi oi γi for all σi and γi; ψi, ψ' :Σ ←→ Γ are defined

by ψ (σ)= o (σ), σ ∈ Σi  , ψ (σ)= ωφi (σ), σ ∈ Σ \ Σi
, ψ'(σ)= o (σ), σ ∈ Σi  ,

i	i	mi	i	mi
mi	i	i	mi

ψ'(σ)= ωφ' (σ), σ ∈ Σ \ Σi
. Then ψ
± ωφi , ψ' ± ωφ'
and ψ
| Σi
= ψ' | Σi  .

i	mi
mi	i
mi	i	mi
i	mi
i	mi

Since Σi	is an mi conformance test set of φi w.r.t. Φ', we have c(φi) ± φi.	 
Note that if Φ is observable/output-distinguishable and (∀φ ∈ Φ, c(φ) ± φ) then Φ' is also observable/output-distinguishable.
We can now prove the result we are after. Theorem 4.8 is the theoretical basis for the complete NSXM testing method.
Theorem 4.8 Let Z be a SXM having type Φ and C a set of SXMs weak test- ing compatible with Z having type Φ' such that Φ is input-complete, output- distinguishable w.r.t. Φ' and observable. If t is a test function of Z, Y ⊆ Φ∗ is

a test set of A
w.r.t. A−c, where A−c = {A−c | Z' ∈ C} and X
is a relation test

Z	C	C	Z'	Φ
set of Z w.r.t. Φ', then X' = t(Y ) ∪ XΦ is a conformance test set of Z w.r.t. C.
Proof. Let Z' ∈ C and k ∈ HZ, k' ∈ HZ' such that k | X' = k | X'. Then we have to prove that Z' ± Z. For simplicity, we use c to denote both the bijective function c :Φ −→ Φ' and the free-semigroup morphism c : Φ∗ −→ Φ'∗ induced by it. ¿From Lemma 4.7 it follows that ∀φ ∈ Φ, c(φ) ± φ. Let v ∈ Y . We prove that v ∈ LAZ iff
c(v) ∈ LA ' .
“if”: Assume v ∈ LAZ . Then from k(t(v)) = k (t(v)) it follows that ∃v ∈ Φ
'	'	'∗
such that ω|v| (t(v)) ∩ ω|v'|(t(v)) /= ∅. Since Φ is observable, output-distinguishable
m0	m0
w.r.t. Φ' and ∀φ ∈ Φ, c(φ) ± φ, we have v' = c(v), so c(v) ∈ LA ' .
“only if:” Assume v ∈/ LAZ and c(v) ∈ LA ' . Then let v = φ1 ... φn and let
1 ≤ k ≤ n be such that φ1 ... φk−1 ∈ LAZ and φ1 ... φk ∈/ LAZ . By definition of t, (m0, t(v)) ∈ dom(| φ1 ... φk |). Since ∀φ ∈ Φ, c(φ) ± φ we have that (m0, t(v)) ∈

dom(| c(φ1) ... c(φk) |). Since c(v) ∈ LA
' , we have c(φ1) ... c(φk) ∈ LA
' , hence

from k(t(v)) = k'(t(v)) it follows that ∃v' ∈ Φ∗ such that v' ∈ LA
and ω|v'|(t(v)) ∩

ω|c(φ1)...c(φk )|(t(v)) /= ∅. Since Φ is observable, output-distinguishable w.r.t. Φ'
and (∀φ ∈ Φ, c(φ) ± φ), we have v' = φ1 ... φk, so φ1 ... φk ∈ LA , which is a

contradiction.
Therefore (v ∈ Y and v ∈ LAZ ) iff (v ∈ Y and c(v) ∈ LA

' ), hence (v ∈ Y and

v ∈ LAZ
) iff (v ∈ Y and v ∈ L−c
Z
). Since Y is a test set of AZ w.r.t. A−c, it follows

that v ∈ LAZ
iff v ∈ L−c
Z
. Therefore, v ∈ LAZ
iff c(v) ∈ LA '
. We have just proven

that there exists a bijective function c :Φ −→ Φ' such that ∀φ ∈ Φ, c(φ) ± φ and
c(LA )= LA ' . From this it follows easily that Z' ± Z.	 
Corollary 4.9 In the conditions of theorem 4.8, if all Σi	are mi test sets (rather
than mi conformance test sets) of φi w.r.t. Φ' then X' = t(Y ) ∪ XΦ is a test set of
Z w.r.t. C.
Proof. Since all Σi	are mi test sets of φi w.r.t. Φ', from the proof of Lemma 4.7
it follows that ∀φ ∈ Φ, φ = c(φ). ¿From this and the proof of Theorem 4.8 it follows that LAZ = LA ' . Hence fZ = fZ' .	 
Applying complete NSXM testing to P systems
In this section we discuss how Theorem 4.8 (or Corollary 4.9) and Theorem 2.3 can be applied to generate (conformance) test sets for a P system specification. In this respect we show how to build a stream X-machine from a P system. We will use the approach described in [7] to build a derivation tree for a predefined number of steps,
k. Using the approach described here we not only develop a new testing method for P systems, but provide a clear way of ensuring that (1) each rule is correctly implemented and (2) each rule or set of rules expected to be applied are actually applied.
The proposed P system testing approach consists of two major steps: (1) deriving a SXM from a P system and (2) applying the NSXM testing method for the resulting model. In order to obtain the SXM model, it is necessary to: (a) build a derivation tree for a given number of steps, k; (b) consider this tree as the underlying structure of the SXM, in which the states of the machine are the nodes of the tree and the arcs are labelled by tuples of multisets of rules (This structure can be minimised as shown in [13]); (c) define the functions from Φ as follows: for each distinct node from the derivation tree there is a derivation step
(x1x' ,..., xnx' ) =⇒ (y1x' ,..., ynx' )
1	n	1	n
where xi, 1 ≤ i ≤ n, represents the part of the multiset xix' which will derive into yi by applying rules from Ri and x' is the multiset which is not changed in this step; if this derivation step is labelled by l then the processing function associated with l is defined by: for every x' , 1 ≤ i ≤ n, and for given xi, yi, 1 ≤ i ≤ n, as above,
φl((x1x' ,... xnx' ), (x1,... xn))= ((y1,... yn), (y1x' ,... ynx' )).
1	n	1	n
The application of the NSXM testing method involves the following de- tailed steps: (a) checking the conditions imposed for testing (mainly output- distinguishability as discussed below); (b) obtaining test sets for the processing functions from Φ; (c) deriving the overall test set.
As Φ contains only processing functions (rather than relations), observability is outright satisfied. Furthermore, by construction, all processing functions can be exercised (using appropriate inputs) from any memory value that is attainable in the

test generation process, so, for testing purposes, Φ can be considered to be input- complete. Thus, only the output-distinguishability of Φ needs to be examined. The test set of each processing function will typically include the input that triggers the function (in the given memory value) as well as other values (outside the domain of the processing function, for which other transitions will actually be triggered) - this will ensure that the processing functions are correctly implemented. As Φ is a set of processing functions (not relations), these are test sets (rather than conformance test sets). Finally, a test set for the overall system will be derived using Corollary
4.9 and Theorem 2.3.
Note that, in order to properly adapt the NSXM testing approach to the case of P systems, we need to consider a specific testing strategy for SXMs based on breakpoints, which requires stopping the testing process in each state in order to observe the input. This is necessary in this case because we do not have proper inputs and they are identified from the current multisets as being those submultisets that are associated to rewriting rules.
Consider, for example, the two compartment P system Π= ({s, a, b, c}, [1[2]2]1, s, λ, R1, R2),
where
R1 = {r1 : s → sa(b, in), r2 : s → ab}; R2 = {r1 : b → bc, r2 : b → c}
and its derivation tree for k = 3. Due to space constraints the derivation tree is not given here. It is not difficult to verify that the example satisfies the output- distinguishability property. Consequently, in this case, we can build a test set based on the methodology presented in this paper for SXMs and, according to this, we can identify at any moment the rule or set of rules applied. However, this property is not true for any P system. Indeed, let us consider a one compartment P system consisting of the following four rules r1 : a1 → a2, r2 : a2 → a1, r3 : a1 → a1, r4 : a2 → a2 and the initial multiset a1a2. In this case we can either apply the multiset r1r2 or r3r4. Obviously the two functions are associated with different rules and consequently they should be different, but they are not output-distinguishable. Designing P systems for which the output-distinguishability condition is always met will require further investigations.
Finally, note that the approach developed here for testing P systems uses func- tions instead of relations. In fact, the more general NSXM approach can be applied to P systems by also considering all the branches emerging from the same node as defining a relation.

Conclusions
The complete NSXM testing method presented here generalises the NSXM inte- gration testing method. It no longer requires implementations of the processing relations to be proved correct before integration testing can take place. Instead, the testing of processing relations is performed along with the integration testing. This is an important advance since often implementations of the processing rela-

tions are not separate units of code (procedures, methods, etc.) that can be tested in isolation from the rest of the system.
The paper also shows how a SXM model of a P system can be obtained and how the NSXM testing approach can be applied to generate conformance test sets for the P system. Further work will involve devising alternative approaches for deriving SXM models of P systems as well as aspects related to the application of NSXM testing to P systems (e.g. designing P systems that meet the design for test conditions).
References
B˘al˘anescu, T., Gheorghe, M., Ipate, F., Holcombe, M., Formal black box testing for partially specified deterministic finite state machines, Foundations of Computing and Decision Systems 28 (1) (2003) 17–28.
Bogdanov, K., Holcombe, M., Ipate, F., Testing methods for X-machines, a review, Formal Aspects of Computing 18(1) (2006), 3–30.
Cheng, K.-T., Krishnakumar, A.S., Automatic functional test generation using the extended finite state machine model, Proceedings of the 30th Design Automation Conference (1993) 86–91.
Chow, T. S., Testing software design modeled by finite state machines, IEEE Transactions on Software Engineering 4(3) (1978) 178–187.
Ciobanu, G., P˘aun, Gh., P´erez-Jim´enez, M. J. (eds), “Applications of membrane computing”. Springer, Berlin, 2006.
Eilenberg, S., “Automata, languages and machines”, Vol. A, Academic Press, New York, 1994.
Gheorghe, M., Ipate, F., On testing P systems, Proceedings of WMC (2008) 173–188.
Hierons, R.M., Harman, M., Testing conformance to a quasi-non-deterministic stream X-machine,
Formal Aspects of Computing 12(6) (2000) 423–442.
Hierons, R., Harman, M., Testing conformance of a deterministic implementation against a non- deterministic stream X-machine, Theoretical Computer Science 323(1-3) (2004) 191–233.
Holcombe, M., Ipate, F., “Correct Systems: Building a business process solution. Springer Verlag”, Berlin, 1998.
Ipate, F., Complete deterministic stream X-machine testing, Formal Aspects of Computing 16(4)
(2004) 374–386.
Ipate, F., Testing against a non-controllable stream X-machine using state counting, Theoretical Computer Science 353(1-3) (2006) 291–316.
Ipate, F., Gheorghe G., Finite state based testing of P systems, Natural Computing, to appear.
Ipate, F., Holcombe, M., An integration testing method that is proved to find all faults, International Journal of Computer Mathematics 63 (1997) 159–178.
Ipate, F., Holcombe, M., Generating test sequences from non-deterministic generalized stream X- machines, Formal Aspects of Computing 12(6) (2000) 443–458.
Ipate F., Holcombe M., Testing data processing-oriented systems from stream X-machine specifications,
Theoretical Computer Science 403(2-3) (2008) 176–191.
Lee, D., Yannakakis, M., Principles and methods of testing finite state machines - a survey, Proceedings of the IEEE 84(8) (1996) 1090–1123.
Luo, G., v. Bochmann, G., Petrenko, A., Test selection based on communicating non-deterministic finite-state machines using a generalised Wp-method, IEEE Transactions on Software Engineering 20(2) (1994) 149–161.
P˘aun Gh., Computing with membranes, Journal of Computer and System Sciences 61(1) (2000) 108– 143.
P˘aun, Gh., “Membrane computing. an introduction”, Springer, Berlin, 2002.
