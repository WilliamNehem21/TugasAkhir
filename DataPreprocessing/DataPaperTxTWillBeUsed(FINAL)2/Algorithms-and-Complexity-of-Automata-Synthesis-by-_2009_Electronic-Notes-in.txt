

Electronic Notes in Theoretical Computer Science 229 (2009) 3–18
www.elsevier.com/locate/entcs

Algorithms and Complexity of Automata Synthesis by Asynhcronous Orchestration With Applications to Web Services Composition
Philippe Balbiani1 Fahima Cheikh2 Guillaume Feuillade3
Universit de Toulouse
CNRS, Institut de recherche en informatique de Toulouse 118 route de Narbonne, 31062 Toulouse CEDEX 9 (France)

Abstract
Composition of services is necessary for realizing complex tasks on the Web. It has been characterized either as a plan synthesis problem or as a software synthesis problem: given a goal and a set of Web services, generate a composition of the Web services that satisfies the goal. We propose algorithms for performing automated Web service composition. We also examine the composition of services from the perspective of computational complexity.
Keywords: Service composition, controller synthesis, computational complexity.


Introduction
The development of service oriented architectures for implementing distributed soft- ware systems demands that organizations make their abilities accessible via the In- ternet through Web service interfaces. The web services are published using Web service standards like WSDL [3] or the abstract WS-BPEL [2,15]. In most cases, Web services are nothing more than elementary components in a client-server ar- chitecture. Their importance lies in the fact that we can compose them to create complex business processes, using Web service standards like concrete WS-BPEL [2] and WS-CDL [14,23]. The WS-CDL is used to specify the choreography between

1 Email: Philippe.Balbiani@irit.fr
2 Email: Fahima.Cheikh@irit.fr
3 Email: Guillaume.Feuillade@irit.fr

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.06.036

services and concrete WS-BPEL is used for the orchestration of services. Com- position of Web services involves multifarious difficulties and requires to formally define the semantics of the input services. If one tries to compose complex business processes from given input services then plan synthesis algorithms from artificial in- telligence or software synthesis algorithms from computer science can be employed. There exist many approaches to the composition problem [17]. Characterizing Web service composition as a plan synthesis problem forces us to devise algorithms tack- ling incomplete information and uncertain effects. Different automated techniques have been proposed to solve the composition/plan problem [21,22,25]. Nevertheless, their computational complexity has not been investigated in details. Characterizing Web service composition as a software synthesis problem compels us to devise algo- rithms working with behavioural descriptions given in terms of automata. Different automated techniques have been proposed to solve the composition/software prob- lem [5,6,7,9,10,24]. Nevertheless, their completeness rests on syntactical restrictions that prevent them from being fully applicable.
Although services might be considered as non autonomous agents which know only about themselves, service oriented architectures and multi-agent systems share many characteristics [12]. To illustrate the truth of this, one has only to mention the fact that several researchers have recently advocate the use of Web service tech- nology to build multi-agent systems accessible through the Web [16] or the use of multi-agent-based coalition formation approaches for Web service composition [18]. In this paper, we propose a solution for the compositon/software problem. More precisely, we propose algorithms for performing automated Web service composi- tion. We also examine the composition of services from the perspective of compu- tational complexity. The differences between the work presented in this paper and the works done in [7,10,24] are the following. First, we do not consider the same relation between the goal and the available services. We consider the bisimulation relation whereas the papers mentioned above consider the simulation relation. In- tuitively, the bisimulation relation does not allow the available services to perform sequences of actions not performed by the goal. In practice, this is important. For example, from a security point of view, if one wants to prohibit sequences of actions that allow services to guess secret information. The second difference is that we consider internal actions and communication actions as well. More precisely, the communication actions are performed through bounded channels. We impose this constraint since otherwise the composition problem will be undecidable. In other respect, in [7], the authors consider that the goal and the available services are deterministic. This restriction, that we do not consider in our paper, is also usually considered in the theory of controller and greatly simplifies the synthesis problem. Finally, in [7,10,24], there are guards/conditions on the transitions. Nevertheless, our result still hold if we add guards/conditions on transitions.
The section-by-section breakdown of the paper is as follows. Section 2 recalls the notion of finite automata and establishes the concept of Web service. In section 3, basic definitions are given and preliminary results are proved. These definitions and these results will be used in great depth in the remaining sections. Section 4 intro- duces the composition problem: given a goal and a set of Web services, generate a

composition of the Web services that satisfies the goal. In section 5, we examine the composition of services from the perspective of computational complexity. Two ways of solving the composition problem are presented in section 6. In section 7, we talk about some open problems.

Web services as finite automata
In this section, the notion of finite automata is recalled and the concept of Web service is established.

Finite automata
Let Σ be a finite set of actions. A finite automaton over Σ is a structure A = (S, Δ, sin) where S is a finite set of states, Δ is a function
Δ: S × Σ → 2S,
sin ∈ S is an initial state. For all Σ' ⊆ Σ, the relation →Σ' ⊆ S × S describes
how the finite automaton can move from one state to another in 1 step under some
action in Σ'. It is defined formally as follows: s →Σ' t iff there exists a ∈ Σ' such

that
Δ(	). Furthermore, let
A
Σ' ٨
Σ' .

t ∈	s, a
→A	be the reflexive transitive closure of →A

For all Σ' ⊆ Σ, we shall say that A loops over Σ' iff for all a ∈ Σ', →{a} = IdS.

Products
Let A1 = (S1, Δ1, sin) and A2 = (S2, Δ2, sin) be finite automata over Σ. By A1⊗A2,
1	2
we denote the asynchronous product of A1 and A2, i.e. the finite automaton A = (S, Δ, sin) over Σ such that S = S1 × S2, Δ is the function defined by
(t1, t2) ∈ Δ((s1, s2), a) iff either t1 ∈ Δ1(s1, a) and t2 = s2 or t1 = s1 and t2 ∈
Δ2(s2, a),
sin = (sin, sin). By A1 × A2, we denote the synchronous product of A1 and A2,
1	2
i.e. the finite automaton A = (S, Δ, sin) over Σ such that S = S1 × S2, Δ is the
function defined by
(t1, t2) ∈ Δ((s1, s2), a) iff t1 ∈ Δ1(s1, a) and t2 ∈ Δ2(s2, a), sin = (sin, sin).
1	2
Bisimulations
Let A1 = (S1, Δ1, sin) and A2 = (S2, Δ2, sin) be finite automata over Σ. For all Σ'
1	2
⊆ Σ, a relation Z ⊆ S1 ×S2 such that (sin, sin) ∈ Z is called a bisimulation between
1	2
A1 and A2 modulo Σ', notation Z: A1 ←→ A2 (Σ'), iff the following conditions are satisfied for all (s1, s2) ∈ Z and for all a ∈ Σ \ Σ':

for all t
∈ S , if s →Σ' ٨◦ →{a} ◦→Σ' ٨ t
then there exists t ∈ S such that s

1	1	1	A1
A1	A1	1
2	2	2

→Σ' ٨◦ →{a} ◦→Σ' ٨ t
and (t ,t ) ∈ Z,

A2	A2
A2	2	1  2

for all t
∈ S , if s →Σ' ٨◦ →{a} ◦→Σ' ٨ t
then there exists t ∈ S such that s

2	2	2	A2
A2	A2	2
1	1	1

→Σ' ٨◦ →{a} ◦→Σ' ٨ t
and (t ,t ) ∈ Z.

A1	A1
A1	1	1  2

Furthermore, for all Σ' ⊆ Σ, if there is a bisimulation between A1 and A2 modulo Σ' then we write A1 ←→ A2 (Σ').

Fig. 1.

Web services
Let Π be a finite set of channels. Following the line of reasoning suggested by [5,6,9], we model Web services on finite automata with input and output. Web services communicate by sending asynchronous messages through channels. Communication through channels can be assumed to be reliable so that messages, once they are sent, do not get lost during their transmission. In this paper, for simplicity, we abstract from message contents and we consider that channels cannot contain, at all times, more than 1 message. Formally, a Web service over Π and Σ is a finite automaton over ({!, ?}× Π) ∪ Σ. For all π ∈ Π, the send action !π consists of adding a message at channel π whereas the receive action ?π consists of taking away a message at channel π. The action !π can be executed provided the channel is not full (i.e. π must contain exactly 0 message) whereas the action ?π can be executed provided the channel is not empty (i.e. π must contain exactly 1 message). This motivates the following definition. Let A = (S, Δ, sin) be a finite automaton over ({!, ?}× Π) ∪ Σ. By F A(A), we denote the finite automaton A' = (S', Δ', sin') over ({!, ?}× Π) ∪ Σ of exponential size such that S' = S × 2Π, Δ' is the function defined by
(t, Q) ∈ Δ'((s, P ), !π) iff t ∈ Δ(s, !π), Q = P ∪ {π}, π /∈ P ,
(t, Q) ∈ Δ'((s, P ), ?π) iff t ∈ Δ(s, ?π), Q = P \ {π}, π ∈ P ,
(t, Q) ∈ Δ'((s, P ), a) iff t ∈ Δ(s, a), Q = P ,

Fig. 2.
sin' = (sin, ∅). Intuitively, F A(A) is the finite automaton obtained from A when the status of channels is included into states. Remark that one can construct F A(A)

in exponential time. Take the case of A, the finite automaton from figure 1. Then
F A(A) is the finite automaton from figure 2.

Basic definitions and preliminary results
In this section, basic definitions are given and preliminary results are proved. These definitions and these results will be used in great depth in the remaining sections.

Basic deﬁnitions
It is convenient to take a finite set Π◦ of channels such that (Σ ∪ Π) ∩ Π◦ = ∅ and Card(Π) = Card(Π◦) and to use a bijection π '→ π◦ from Π to Π◦. By L◦, we mean the finite automaton A' = (S', Δ', sin') over {!, ?}× Π◦ such that S' = {0}, Δ' is the function defined by
Δ'(0, !π◦) = {0} and Δ'(0, ?π◦) = {0},
sin' = 0. Let A = (S, Δ, sin) be a finite automaton over ({!, ?}× (Π ∪ Π◦)) ∪ Σ. By Del◦(A), we denote the finite automaton A' = (S', Δ', sin') over ({!, ?}× Π) ∪ Σ such that S' = S, Δ' is the function defined by
Δ'(s, !π) = Δ(s, !π) ∪ Δ(s, !π◦) and Δ'(s, ?π) = Δ(s, ?π) ∪ Δ(s, ?π◦),
Δ'(s, a) = Δ(s, a),
sin' = sin. By F A◦(A), we denote the finite automaton A' = (S', Δ', sin') over ({!, ?}× (Π ∪ Π◦)) ∪ Σ of exponential size such that S' = S × 2Π, Δ' is the function defined by
(t, Q) ∈ Δ'((s, P ), !π) iff t ∈ Δ(s, !π), Q = P ∪ {π}, π /∈ P and (t, Q) ∈
Δ'((s, P ), ?π) iff t ∈ Δ(s, ?π), Q = P \ {π}, π ∈ P ,
(t, Q) ∈ Δ'((s, P ), !π◦) iff t ∈ Δ(s, !π◦), Q = P ∪ {π}, π /∈ P and (t, Q) ∈
Δ'((s, P ), ?π◦) iff t ∈ Δ(s, ?π◦), Q = P \ {π}, π ∈ P ,
(t, Q) ∈ Δ'((s, P ), a) iff t ∈ Δ(s, a), Q = P ,
sin' = (sin, ∅). Remark that one can construct F A◦(A) in exponential time. Let A = (S, Δ, sin) be a finite automaton over {!, ?}× Π. By Ren◦(A), we denote the finite automaton A' = (S', Δ', sin') over ({!, ?}× (Π ∪ Π◦)) ∪ Σ such that S' = S, Δ' is the function defined by
Δ'(s, !π) = {s} and Δ'(s, ?π) = {s},
Δ'(s, !π◦) = Δ(s, !π) and Δ'(s, ?π◦) = Δ(s, ?π),
Δ'(s, a) = {s},
sin' = sin. Obviously, Ren◦(A) loops over ({!, ?}× Π) ∪ Σ.

Preliminary results
Now, we present some useful lemmas.

Lemma 3.1 Let A1 = (S1, Δ1, sin) be a ﬁnite automaton over ({!, ?}× Π) ∪ Σ and A2 = (S2, Δ2, sin) be a ﬁnite automaton over {!, ?}× Π. Then, F A(A1 ⊗ A2) is isomorphic to Del◦(F A◦(A1 ⊗ L◦) × Ren◦(A2)).
Proof. States in F A(A1 ⊗ A2) are of the form ((s1, s2),P ) with s1 ∈ S1, s2 ∈ S2 and P ⊆ Π whereas states in Del◦(F A◦(A1 ⊗ L◦) × Ren◦(A2)) are of the form (((s1, 0),P ), s2) with s1 ∈ S1, P ⊆ Π and s2 ∈ S2. Obviously, the bi- jection ((s1, s2),P ) '→ (((s1, 0),P ), s2) is an isomorphism from F A(A1 ⊗ A2) to Del◦(F A◦(A1 ⊗ L◦) × Ren◦(A2)).	 
Lemma 3.2 Let A1 = (S1, Δ1, sin) be a ﬁnite automaton over ({!, ?} × Π) ∪ Σ and A2 = (S2, Δ2, sin) be a ﬁnite automaton over ({!, ?}× (Π ∪ Π◦)) ∪ Σ looping over ({!, ?}× Π) ∪ Σ. Then, Del◦(F A◦(A1 ⊗ L◦) × A2) is isomorphic to F A(A1 ⊗ Del◦(L◦ × A2)).
Proof. States in Del◦(F A◦(A1 ⊗ L◦) × A2) are of the form (((s1, 0),P ), s2) with s1 ∈ S1, P ⊆ Π and s2 ∈ S2 whereas states in F A(A1 ⊗ Del◦(L◦ × A2)) are of the form ((s1, (0, s2)),P ) with s1 ∈ S1, s2 ∈ S2 and P ⊆ Π. Obviously, the bijection (((s1, 0),P ), s2) '→ ((s1, (0, s2)),P ) is an isomorphism from Del◦(F A◦(A1⊗L◦)×A2) to F A(A1 ⊗ Del◦(L◦ × A2)).	 
Lemma 3.3 Let A1 = (S1, Δ1, sin) be a ﬁnite automaton over ({!, ?}× Π) ∪ Σ and Π' ⊆ Π. Then, one can construct in polynomial time a modal μ-calculus formula f (A1, Π') over ({!, ?} × (Π ∪ Π◦)) ∪ Σ of polynomial size such that for all ﬁnite automata A2 = (S2, Δ2, sin) over ({!, ?}× (Π ∪ Π◦)) ∪ Σ, A1 ←→ Del◦(A2) ({!, ?}× 
Π') iff A2 |= f (A1, Π').
Proof. See [8] for details.	 
By lemmas 3.1, 3.2 and 3.3, we infer immediately the following theorem.
Theorem 3.4 Let A = (SA, ΔA, sin) and B = (SB, ΔB, sin) be ﬁnite automata over
A	B
({!, ?}× Π) ∪ Σ and Π' ⊆ Π. Then, the following conditions are equivalent:
There exists a ﬁnite automaton C over {!, ?}×Π such that F A(A) ←→ F A(B⊗ C) ({!, ?}× Π').
There exists a ﬁnite automaton C over ({!, ?} × (Π ∪ Π◦)) ∪ Σ looping over
({!, ?}× Π) ∪ Σ and such that F A(A) ←→ Del◦(F A◦(B⊗L◦) ×C) ({!, ?}× Π').
There exists a ﬁnite automaton C over ({!, ?} × (Π ∪ Π◦)) ∪ Σ looping over
({!, ?}× Π) ∪ Σ and such that FA◦(B⊗ L◦) ×C |= f (F A(A), Π').
This theorem will be used in section 6 to define decision procedures for the composition problem of Web services.
Composition of Web services
This section considers issues that arise when addressing the task of combining and coordinating a set of Web services. We assume the process of Web service com- position to be goal oriented: given a goal and a set of Web services, generate a

composition of the Web services that satisfies the goal. According to [21,22,25], goals are conditions on the behaviour of the composition that can be expressed in the EaGLe language. In this approach, service composition boils down to the task of combining and coordinating the available Web services into a complex busi- ness process satisfying the given condition. According to [5,6,9], goals are finite automata with input and output, i.e. Web services as defined in section 2.4. In this approach, service composition boils down to the task of combining and coordinating the available Web services into a complex business process that can simulate the given finite automaton with input and output. In this paper, we automate compo- sition as defined in the second approach. This brings us to the following decision problem:
CP : given a finite set Σ of actions, a finite set Π of channels, finite automata A =
(SA, ΔA, sin) and B1 = (SB , ΔB , sin ), .. ., Bn = (SB , ΔB , sin ) over ({!, ?}×Π)∪
A	1	1	B1	n	n	Bn
Σ and Π' ⊆ Π, determine whether there exists a finite automaton C = (SC, ΔC, sin)
over {!, ?}× Π such that F A(A) ←→ F A(B1 ⊗ ... ⊗ Bn ⊗ C) ({!, ?}× Π').
In CP , A plays the role of the given finite automaton with input and output and B1,
.. ., Bn play the role of the available Web services. As for the finite automaton C, it plays the role of the Web service that will combine and coordinate the available Web
services into a complex business process that can simulate the given finite automaton with input and output. Take the case of A, B1, B2, the finite automata from figure 3. Then the finite automaton C from figure 4 is such that F A(A) ←→ F A(B1 ⊗B2 ⊗C)

Fig. 3.

({!, ?}× {π1, π' , π2, π' }).
1	2

Fig. 4.

Lower bound
Now, we are ready to announce the first result of this paper:
CP is EXPTIME-hard.
Let Σ be a finite set of actions. A Petri net over Σ is a structure of the form N
= (P, T, F, l) where P is a finite set of places, T is a finite set of transitions, F ⊆
(P × T ) ∪ (T × P ) is a relation, l is a function
l: T → Σ.
The Petri nets considered in this paper are 1-safe, that is to say: their places cannot contain more than one token (see [19] for details). For all t ∈ T , let the preset denoted •t be the set of all p ∈ P such that p F t and the postset denoted t• be the set of all p ∈ P such that t F p. By F A(N ), we denote the finite automaton A' = (S', Δ', uin') over Σ such that S' = 2P , Δ' is the function defined by
v' ∈ Δ'(u', a) iff there exists t ∈ T such that l(t) = a, •t ⊆ u' and v' = (u' \• t) ∪t•, uin' = ∅. Let us consider the following decision problem:
PN : given a finite set Σ of actions and Petri nets N = (PN , TN , FN , lN ), O = (PO, TO, FO, lO) over Σ, determine whether F A(N ) ←→ F A(O) (∅).
Seeing that PN is EXPTIME-hard [13], it suffices to reduce PN to the restriction of CP where n = 1, in order to demonstrate that CP is EXPTIME-hard.

Fig. 5.
Given a finite set Σ of actions and Petri nets N = (PN , TN , FN , lN ), O = (PO, TO, FO, lO) over Σ, we are asked whether F A(N ) ←→ F A(O) (∅). The in- stance ρ(Σ, N, O) of CP that we construct is given by the finite set Σe of actions, the finite set Π of channels, the finite automata A = (SA, ΔA, sin) and B = (SB, ΔB, sin)
A	B
over ({!, ?}× Π) ∪ Σe and Π' ⊆ Π defined by
Σe = Σ ∪ {ae, ae, ae, ae} where ae, ae, ae and ae are new actions,

1	2	3	4
Π = PN ∪ PO,
Π' = PN ∪ PO,
1	2	3	4

A is the finite automaton from figure 6,
B is the finite automaton from figure 7.



Fig. 6.

Fig. 7.

In order to understand how the flower-form parts of A and B are defined, the reader is invited to consult figure 5. This figure shows that the firing of the transition a empties the places P1,..., P|•t| that are in the preset of the transition and fills up
the places P',...,P' •  that are in the postset of this transition. This transition is
1	|t |
represented in the automata A and B by the following sequence of actions: receive messages on the channels P1,..., P|•t| corresponding to the places in the preset of the transition, which has the effect to empty the channels, then the transition a
followed by the emission of messages in the channels P',...,P' • corresponding
1	|t |
to the places in the postset of the transition, which has the effect to fill up these channels. The actions sequences of the automata A and B containing the actions

ae, ae, ae or ae
ensure that no mediator can interfere with the simulation of the

1	2	3	4
1-safe Petri nets N and O. This completes the construction. The flower part of A (resp. of B) will be denoted A' (resp. B'). The construction of A and B is done such that F A(A') and F A(N ) are isomorphic modulo {!, ?}× Π'. In the same way, F A(B') and F A(O) are isomorphic modulo {!, ?}× Π'. Obviously, ρ can be computed in logarithmic space. Moreover, F A(N ) ←→ F A(O) (∅) iff there exists a finite automaton C = (SC, ΔC, sin) over {!, ?}× Π such that F A(A) ←→ F A(B⊗ C)
({!, ?}× Π').

Concerning the left to right implication, suppose that the Petri nets N and O are bisimilar. Hence, F A(A') and F A(B') are bisimilar modulo {!, ?}× Π'. Let C be the finite automaton that does nothing, i.e. C contains only one state (its initial state) and has no transition. With such a C, the automata F A(B) and F A(B⊗ C) are isomorphic. Thus, it is enough to prove that F A(A) and F A(B) are bisimilar modulo {!, ?}× Π'. Indeed, F A(A') and F A(B') are bisimilar modulo {!, ?}× Π'. Moreover, in F A(A) and F A(B), the transitions labelled !p and ae are executable for all places p ∈ PN ∪PO whereas, in F A(B), the transitions labelled ?p, ae and ae are
4	3
executable for no place p ∈ PN ∪PO. Hence, with such a C, F A(A) ←→ F A(B⊗ C) ({!, ?}× Π').
Concerning the right to left implication, suppose that the Petri nets N and O are not bisimilar and that there exists a finite automaton C such that F A(A) and F A(B) are bisimilar modulo {!, ?}× Π'. In the case C is the automaton that does nothing, the fact that F A(A) and F A(B⊗ C) are bisimilar modulo {!, ?}× Π' implies that F A(A') and F A(B') are bisimilar modulo {!, ?}× Π'. This contradicts the fact that N and O are not bisimilar. Hence, C has, at least, a !p transition or a ?p transition starting from its initial state for some place p ∈ PN ∪ PO. If C has a !p transition starting from its initial state, then, in F A(B⊗ C), the transitions !p (executed by C),
?p (executed by B) and ae (executed by B) can be executed from the initial state, whereas no sequence in F A(A) ends with a transition labelled ae. This contradicts the fact that F A(A) and F A(B ⊗ C) are bisimilar modulo {!, ?}× Π'. If C has a
?p transition starting from its initial state, then, in F A(B⊗ C), the transitions !p (executed by B), ?p (executed by C), ae (executed by B), !p (executed by B) and ae (executed by C) can be executed from the initial state, whereas no sequence in F A(A) ends with a transition labelled ae. This contradicts the fact that F A(A) and F A(B⊗ C) are bisimilar modulo {!, ?}× Π'.
Hence, CP is EXPTIME-hard.

Upper bound
Whether CP is in EXPTIME or not is not known to us. Now, we are ready to announce the second result of this paper:
CP is in 2EXPTIME.

A 2EXPTIME decision procedure based on controller synthesis
Let us consider the following decision problem:
CS: given a finite set Σ of actions, a finite set Π of channels, a finite automaton B = (SB, ΔB, sin) over ({!, ?}× (Π ∪ Π◦)) ∪ Σ and a modal μ-calculus formula φ over ({!, ?}× (Π ∪ Π◦)) ∪ Σ, determine whether there exists a finite automaton C
= (SC, ΔC, sin) over ({!, ?}× (Π ∪ Π◦)) ∪ Σ looping over ({!, ?}× Π) ∪ Σ and such that B× C |= φ.
Arnold et al. [4] have proposed a decision procedure to resolve this problem. This procedure is based on modal μ-calculus. The language of modal μ-calculus cannot

express the fact that a finite automaton over ({!, ?} × (Π ∪ Π◦)) ∪ Σ loops over ({!, ?}× Π) ∪ Σ. That is why Arnold et al. [4] extend it in such a way that looping becomes expressible. This extension is called modal-loop μ-calculus. It consists in associating with each θ ∈ ({!, ?}× Π) ∪ Σ a proposition λθ whose interpretation is that a state s of a finite automaton A = (S, Δ, sin) over ({!, ?}× (Π ∪ Π◦)) ∪ Σ satisfies λθ iff Δ(s, θ) = {s}. Thus, one can construct in polynomial time a modal- loop μ-calculus formula g(Π, Σ) over ({!, ?} × (Π ∪ Π◦)) ∪ Σ of polynomial size such that for all finite automata A = (S, Δ, sin) over ({!, ?}× (Π ∪ Π◦)) ∪ Σ, A |= g(Π, Σ) iff A loops over ({!, ?}× Π) ∪ Σ. Moreover, given a finite automaton B = (SB, ΔB, sin) over ({!, ?}× (Π ∪ Π◦)) ∪ Σ and a modal μ-calculus formula φ over ({!, ?}× (Π ∪ Π◦)) ∪ Σ, Arnold et al. [4] show how to construct in polynomial time a modal μ-calculus formula φ/B over ({!, ?}× (Π ∪ Π◦)) ∪ Σ of polynomial size such that for all finite automata C = (SC, ΔC, sin) over ({!, ?}× (Π ∪ Π◦)) ∪ Σ, B× C |= φ iff C |= φ/B. Hence, CS is equivalent to the following decision problem:
given a finite set Σ of actions, a finite set Π of channels, a finite automaton B = (SB, ΔB, sin) over ({!, ?}× (Π ∪ Π◦)) ∪ Σ and a modal μ-calculus formula φ over ({!, ?}× (Π ∪ Π◦)) ∪ Σ, determine whether φ/B∧ g(Π, Σ) is satisfiable.
Now, let us go back to CP and take a finite set Σ of actions, a finite set Π of channels, finite automata A = (SA, ΔA, sin) and B1 = (SB , ΔB , sin ), .. ., Bn =
A	1	1	B1

(SBn
, ΔBn
, sin ) over ({!, ?} × Π) ∪ Σ and Π' ⊆ Π. To determine whether there
n

exists a finite automaton C = (SC, ΔC, sin) over {!, ?}× Π such that F A(A) ←→
F A(B1 ⊗ ... ⊗ Bn ⊗ C)({!, ?}× Π'), we consider the following algorithm:
Compute φ = f (F A(A), Π').
Compute B = F A◦(B1 ⊗ ... ⊗ Bn ⊗ L◦).
Compute φ' = φ/B∧ g(Π, Σ).
If φ' is satisfiable then return the value true else return the value false.
By theorem 3.4, the above algorithm returns the value true iff there exists a finite automaton C over {!, ?}×Π such that F A(A) ←→ F A(B1 ⊗.. .⊗Bn ⊗C) ({!, ?}×Π'). It can be implemented in double exponential time. More precisely:
In step (i), the computation of F A(A) takes exponential time in the size of Π whereas the computation of φ (the existence of which is implied by lemma 3.3) takes polynomial time in the size of F A(A). Moreover, the size of F A(A) is exponential in the size of Π whereas the size of φ is polynomial in the size of F A(A).
In step (ii), the computation of B1⊗,..., ⊗Bn ⊗ L◦ takes exponential time in the size of B1,..., Bn whereas the computation of B takes exponential time in the size of Π. Hence, the computation of B takes exponential time in the size of B1,..., Bn and in the size of Π. Moreover, the size of B is exponential in the size of B1,..., Bn and in the size of Π.
In step (iii), the computation of φ' can be done in polynomial time in the size of
φ, B, Π and Σ. Moreover, the size of φ' is polynomial in the size of φ, B, Π and

Σ. Hence, the size of φ' is exponential in the size of A, B1,..., Bn and Π.
Step (iv) can be executed in deterministic exponential (with respect to the size of φ') time, seeing that the satisfiability problem for the modal-loop μ-calculus is in EXPTIME.

A 2EXPTIME decision procedure based on ﬁltration
Let us consider the following decision problem:
FIL: given a finite set Σ of actions, a finite set Π of channels, a finite automaton
A = (SA, ΔA, sin) over ({!, ?} × Π) ∪ Σ, a finite automaton B = (SB, ΔB, sin)
A	B
over ({!, ?}× (Π ∪ Π◦)) ∪ Σ and Π' ⊆ Π, determine whether there exists a finite automaton C = (SC, ΔC, sin) over ({!, ?}×(Π∪Π◦))∪Σ looping over ({!, ?}×Π)∪Σ and such that A ←→ Del◦(B× C) ({!, ?}× Π').
Suppose that we are given a finite set Σ of actions, a finite set Π of channels, a finite automaton A = (SA, ΔA, sin) over ({!, ?}× Π) ∪ Σ, a finite automaton B = (SB, ΔB, sin) over ({!, ?}× (Π ∪ Π◦)) ∪ Σ and Π' ⊆ Π. Let C = (SC, ΔC, sin) be a 
B	C
finite automaton over ({!, ?}× (Π ∪ Π◦)) ∪ Σ looping over ({!, ?}× Π) ∪ Σ and such that A ←→ Del◦(B× C) ({!, ?}× Π'). Hence, there exists a bisimulation Z between
A and Del◦(B× C) modulo ({!, ?}× Π') such that sin Z (sin, sin). Let ≡ ⊆ SC × SC
A	B	C
be the binary relation such that for all s1 , s2 ∈ SC ,
C	C
s1 ≡ s2 iff for all sA ∈ SA and for all sB ∈ SB, sA Z (sB, s1 ) iff sA Z (sB, s2 ).
C	C	C	C
Note that ≡ is an equivalence relation. Let sC ∈ SC . The set of all states in SC equivalent to sC modulo ≡, in symbols | sC |, is called the equivalence class of sC in SC modulo ≡ with sC as its representative. The set of all equivalence classes of SC modulo ≡, in symbols SC/ ≡, is called the quotient set of SC modulo ≡. Suppose
that Cf = (S f , Δ f , sin ) is the finite automaton over ({!, ?}× (Π ∪ Π◦)) ∪ Σ looping
C	C	Cf
over ({!, ?}× Π) ∪ Σ and such that SCf = SC/ ≡, ΔCf is the function such that
| tC | ∈ ΔCf (| sC |, ϑπ◦), ϑ ∈ {!, ?} and π◦ ∈ Π◦, iff for all sA ∈ SA and for all sB, tB ∈ SB, if tB ∈ ΔB(sB, ϑπ◦) and sA Z (sB, sC ) then there exists tA ∈ SA such that tA ∈ ΔA(sA, ϑπ) and tA Z (tB, tC ),
in = | sin |. Then Cf is called the greatest filtration of C through A and B. Let
Zf ⊆ SA × (SB × SCf ) be the binary relation such that for all sA ∈ SA and for all (sB, | sC |) ∈ SB × SCf , sA Zf (sB, | sC |) iff sA Z (sB, sC ). It is a simple matter to check that Zf : A ←→ Del◦(B× Cf ) ({!, ?}× Π'). For our purpose, the crucial
property of the greatest filtration is that the following conditions are equivalent:
there exists a finite automaton C = (SC, ΔC, sin) over ({!, ?}×(Π∪Π◦))∪Σ looping over ({!, ?}× Π) ∪ Σ and there exists a relation Z ⊆ SA × (SB × SC ) such that Z: A ←→ Del◦(B× C) ({!, ?}× Π'),
there exists a finite automaton C = (SC, ΔC, sin) over ({!, ?}×(Π∪Π◦))∪Σ looping over ({!, ?}× Π) ∪ Σ and there exists a relation Z ⊆ SA × (SB × SC ) such that Z:
A ←→ Del◦(B× C) ({!, ?}× Π') and (C1) SC ⊆ 2SA×SB ,

(C2) tC ∈ ΔC (sC, ϑπ◦), ϑ ∈ {!, ?} and π◦ ∈ Π◦, iff for all sA ∈ SA and for all sB, tB ∈ SB, if tB ∈ ΔB(sB, ϑπ◦) and (sA, sB) ∈ sC then there exists tA ∈ SA such that tA ∈ ΔA(sA, ϑπ) and (tA, tB) ∈ tC ,
(C3) sA Z (sB, sC ) iff (sA, sB) ∈ sC .
Hence, we can give a simple algorithm for solving FIL:
Compute the finite automaton C0 = (S0, Δ0 , sin0) over ({!, ?}× (Π ∪ Π◦)) ∪ Σ
C	C	C
looping over ({!, ?}× Π) ∪ Σ and the relation Z0 ⊆ SA × (SB × S0) such that
S0 = 2SA×SB ,
tC ∈ Δ0 (sC, ϑπ◦), ϑ ∈ {!, ?} and π◦ ∈ Π◦, iff for all sA ∈ SA and for all sB, tB
∈ SB, if tB ∈ ΔB(sB, ϑπ◦) and (sA, sB) ∈ sC then there exists tA ∈ SA such that tA ∈ ΔA(sA, ϑπ) and (tA, tB) ∈ tC ,
sA Z0 (sB, sC ) iff (sA, sB) ∈ sC .
For all non negative integers n, compute the set an of all sC ∈ SC n such that for some sA ∈ SA and for some sB ∈ SB such that sA Zn (sB, sC ), there exists ϑ ∈ {!, ?} and there exists π◦ ∈ Π◦ such that one of the following cases holds:
there exists tA ∈ ΔA(sA, ϑπ) such that for all tB ∈ ΔB(sB, ϑπ◦) and for all
tC ∈ Δn(sC, ϑπ◦), not tA Zn (tB, tC ),
there exists tB ∈ ΔB(sB, ϑπ◦) and there exists tC ∈ Δn(sC, ϑπ◦) such that for
all tA ∈ ΔA(sA, ϑπ), not tA Zn (tB, tC ).
For all non negative integers n, compute the finite automaton Cn+1 = (Sn+1, Δn+1, sinn+1) over ({!, ?}× (Π ∪ Π◦)) ∪ Σ looping over ({!, ?}× Π) ∪ Σ
C	C	C
and the relation Zn+1 ⊆ SA × (SB × Sn+1) such that
Sn+1 = Sn \ an,
C	C
tC ∈ Δn+1(sC, ϑπ◦), ϑ ∈ {!, ?} and π◦ ∈ Π◦, iff for all sA ∈ SA and for all
sB, tB ∈ SB, if tB ∈ ΔB(sB, ϑπ◦) and (sA, sB) ∈ sC then there exists tA ∈ SA
such that tA ∈ ΔA(sA, ϑπ) and (tA, tB) ∈ tC ,
sA Zn+1 (sB, sC ) iff (sA, sB) ∈ sC .
The following lemma shows that the above algorithm returns the value true iff there exists a finite automaton C = (SC, ΔC, sin) over ({!, ?}× (Π ∪ Π◦)) ∪ Σ looping over ({!, ?}× Π) ∪ Σ and such that A ←→ Del◦(B× C) ({!, ?}× Π').
Lemma 6.1 Let C = (SC, ΔC, sin) be a ﬁnite automaton over ({!, ?}× (Π ∪ Π◦)) ∪ Σ
looping over ({!, ?}× Π) ∪ Σ and Z ⊆ SA × (SB × SC ) be a relation such that Z:
A ←→ Del◦(B× C) ({!, ?}× Π') and
(C1) SC ⊆ 2SA×SB ,
(C2) tC ∈ ΔC (sC, ϑπ◦), ϑ ∈ {!, ?} and π◦ ∈ Π◦, iff for all sA ∈ SA and for all sB, tB
∈ SB, if tB ∈ ΔB(sB, ϑπ◦) and (sA, sB) ∈ sC then there exists tA ∈ SA such that
tA ∈ ΔA(sA, ϑπ) and (tA, tB) ∈ tC,
(C3) sA Z (sB, sC ) iff (sA, sB) ∈ sC.
Then, for all sC ∈ SC and for all non negative integers n, sC ∈ SC n.
Proof. Let sC ∈ SC . If there exists a non negative integer n such that sC ∈ SC n and
sC /∈ SC n+1 then for some sA ∈ SA and for some sB ∈ SB such that sA Zn (sB, sC ),

there exists ϑ ∈ {!, ?} and there exists π◦ ∈ Π◦ such that one of the following cases holds:
there exists tA ∈ ΔA(sA, ϑπ) such that for all tB ∈ ΔB(sB, ϑπ◦) and for all tC ∈
Δn(sC, ϑπ◦), not tA Zn (tB, tC ),
there exists tB ∈ ΔB(sB, ϑπ◦) and there exists tC ∈ Δn(sC, ϑπ◦) such that for all
tA ∈ ΔA(sA, ϑπ), not tA Zn (tB, tC ).
The reader may easily verify that both cases lead to a contradiction.	 
An obvious analysis of the complexity of the above algorithm yields the following facts:
there exists a non negative integer n such that n ≤ 2Card(SA)×Card(SB ) and Cn+1
= Cn,
for all non negative integers n, Cn+1 can be obtained from Cn in time polynomial in the size of Cn.
Hence, the above algorithm can be implemented in exponential time. Now, let us go back to CP and take a finite set Σ of actions, a finite set Π of channels, finite
automata A = (SA, ΔA, sin) and B1 = (SB , ΔB , sin ), .. ., Bn = (SB , ΔB , sin ) over
A	1	1	B1	n	n	Bn
({!, ?}× Π) ∪ Σ and Π' ⊆ Π. To determine whether there exists a finite automaton C = (SC, ΔC, sin) over {!, ?}× Π such that F A(A) ←→ F A(B1 ⊗ ... ⊗ Bn ⊗ C), we consider the following algorithm:
Compute A' = F A(A).
Compute B' = FA◦(B1 ⊗ ... ⊗ Bn ⊗ L◦).
If there exists a finite automaton C = (SC, ΔC, sin) over ({!, ?}× (Π ∪ Π◦)) ∪ Σ looping over ({!, ?}× Π) ∪ Σ and such that A' ←→ Del◦(B' × C) ({!, ?}× Π') then return the value true else return the value false.
By theorem 3.4, the above algorithm returns the value true iff there exists a finite automaton C over {!, ?}×Π such that F A(A) ←→ F A(B1 ⊗.. .⊗Bn ⊗C) ({!, ?}×Π'). It can be implemented in double exponential time.

Conclusion and open problems
We have presented a framework in which Web services are described as message passing automata. Deterministic algorithms that check a composition’s existence and return one if it exists have been proposed. In order to ensure their termina- tion in a finite number of steps, we have characterized the computational complexity (EXPTIME-hardness and membership in 2EXPTIME) of the composition prob- lem. Our main results are that CP is EXPTIME-hard and CP is in 2EXPTIME. An interesting (and still open) question is to evaluate the exact complexity of Web service composition: is CP in EXPTIME or is CP 2EXPTIME-hard? Variants of CP can be considered as well. For instance, one may consider that the given automata are deterministic or that the channels they use can contain more than 1 message at a time. Concerning the second variant, the results obtained in this pa-

per remain true. The only difference is in the construction of F A(A), for which the construction will also be done in exponential time. More precisely, if for some pos- itive integer k, the channels used by automaton A can contain at most k messages at a time, then states in F A(A) will be pairs of the form (q, (k1,..., km)), where q is a state of the automaton A, m is the cardinality of the set Π of all channels and (k1,..., km) is a sequence of m integers in {0,..., k}. Take another example: one may replace “bisimulation” by “trace equivalence”. What is the complexity of Web service composition in this case? Let us remark that the construction used in sec- tion 5 for the case of bisimulation can also be used for the case of trace equivalence. Seeing that trace equivalence between 1-safe Petri nets is EXPSPACE-hard [13], it follows that Web services composition is EXPSPACE-hard in the case of trace equivalence. In other respects, we have not considered which message is actually sent/received when performing a messaging action. To enrich our formalism that way, we may augment each send/receive action with an additional first-order term indicating what kind of message is exchanged. Henceforth, a message exchange ac- tion consists of a channel π and a first-order term t which indicate that a message of the form t is sent or received through channel π. For which classes of messages is Web service composition decidable? When this problem is decidable, how complex is it?

Acknowledgement
The work presented in this paper was partially supported by the FP7-ICT-2007-1 Project no. 216471, “AVANTSSAR: Automated Validation of Trust and Security of Service-Oriented Architectures” (www.avantssar.eu). We are also grateful for the support of the project ANR-05-SSIA-0007-01 Cops financed by the “Agence nationale de la recherche” (www.irit.fr/COPS/Accueil.htm).

References
Alvarez, C., Balc´azar, J., Gabarr´o, J., S´antha, M.: Parallel complexity in the design and analysis of concurrent systems. In: PARLE ’91, Parallel Architectures and Languages Europe. Springer-Verlag (1991) 288–303.

Andrews, T., F. Curbera , H. Dholakia , Y. Goland, J. Klein, F. Leymann, K. Liu, D. Roller, D. Smith, S. Thatte, I. Trickovic, S. Weerawarana. ‘Business Process Execution Language for Web services (BPEL4WS)’. www-106.ibm.com/developerworks/library/ws-bpel/, (2004).
Ariba, Microsoft, IBM. ‘Web Services Description Language (WSDL)’. www.w3.org/TR/2001/ NOTE-wsdl-20010315, (2001).
Arnold, A., A. Vincent, I. Walukiewicz, Games for synthesis of controllers with partial observation. Theoretical computer science 303 (2003) 7–34.

Berardi, D., D. Calvanese, G. De Giacomo, R. Hull, M. Mecella, ‘Automated composition of transition- based semantic Web services with messaging’. In: ‘Proceedings of the 31st International Conference on Very Large Data Bases’. VLDB Endowment (2005) 613–624.

Berardi, D., D. Calvanese, G. De Giacomo, M. Lenzerini, M. Mecella, ‘Automatic composition of e- services that export their behavior’. In: ‘Service-Oriented Computing — ICSOC 2003’. Springer (2003) 43–58.


Berardi, D., F. Cheikh, G. De Giacomo, F. Patrizi, ‘Automatic service composition via simulation’. In: ‘International Journal of Foundations of Computer Science’. World Scientific Publishing 19 (2008) 429–451.
Berwanger, D., E. Gr¨adel, G. Lenzi, The variable hierarchy of the μ-calculus is strict. Theory of Computing Systems 40 (2007) 437–466.
Cheikh, F., G. De Giacomo, M. Mecella, ‘Automatic Web services composition in trust-aware communities’. In: ‘Proceedings of the 3rd ACM Workshop on Secure Web Services’. Association for Computing Machinery (2006) 43–52.
De Giacomo, G., M. De Leoni, M. Mecella, F. Patrizi, ‘Automatic workflows composition of mobile services’. In:‘Proceedings of the IEEE International Conference on Web Services’. International Conference on Web Services (2007) 823–830.
Fitting, M., ‘Proof Methods for Modal and Intuitionistic Logic’. Reidel (1983).
Huhns, M., Agents as Web services. IEEE Internet Computing 6 (2002) 93–95.
Jategaonkar, L., A. Meyer, Deciding true concurrency equivalences on safe, finite nets. Theoretical computer science 154 (1996) 107–143.
Kavantzas, N., D. Burdett, et al. ‘Web Services Choreography Description Language (WS-CDL)’. www. w3.org/TR/2004/WD-ws-cdl-10-20041217/, (2004).
K¨onig, D., N. Lohmann, S. Moser, C. Stahl, K. Wolf, ‘Extending the compatibility notion for abstract WS-BPEL processes’. In: ‘Proceedings of the seventeenth International Conference on World Wide Web’. World Wide Web (2008) 785–794.
Melliti, T., S. Haddad, A. Suna, A. El Fallah Seghrouchni, ‘W eb − MASI: multi-agent systems interoperability using a Web services based approach’. In: ‘Proceedings of the IEEE/WIC/ACM International Conference on Intelligent Agent Technology 2005’. IEEE (2005) 739–742.
Milanovic, N., M. Malek, Current solutions for Web service composition. IEEE Internet Computing 8
(2004) 51–59.
Mu¨ller, I., R. Kowalczyk, P. Braun, ‘Towards agent-based coalition formation for service composition’. In: ‘Proceedings of the IEEE/WIC/ACM International Conference on Intelligent Agent Technology 2006’. IEEE (2006) 73–80.
Murata , T., Petri nets: Properties, analyses and applications. Proceedings of the IEEE 17 (1989) 541–574.
Papadimitriou, C., ‘Computational Complexity’. Addison-Wesley (1994).
Pistore, M., F. Barbon, P. Bertoli, D. Shaparau, P. Traverso, ‘Planning and monitoring Web service composition’. In: ‘Artificial Intelligence: Methodology, Systems, and Applications’. Springer (2004) 106– 115.
Pistore, M., A. Marconi, P. Bertoli, P. Traverso, ‘Automated composition of Web services by planning at the knowledge level’. In: ‘Proceedings of the Nineteenth International Joint Conference on Artificial Intelligence’. International Joint Conferences on Artificial Intelligence (2005) 1252–1259.
Ross-Talbot S., ‘Web services choreography and Process Algebra’. www.daml.org/services/swsl/ materials/WS-CDL.pdf, (2004).
Sardin˜a, S., F. Patrizi, G. De Giacomo, ‘Automatic synthesis of global behavior from multiple distributed behaviors’. In:‘Proceedings of the Twenty-Second AAAI Conference on Artificial Intelligence’. Conference on Artificial Intelligence (2007) 1063–1069.
Traverso, P., M. Pistore, ‘Automated composition of semantic Web services into executable processes’. In: ‘The Semantic Web — ISWC 2004’. Springer (2004) 380–394.
