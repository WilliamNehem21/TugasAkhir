

Electronic Notes in Theoretical Computer Science 192 (2008) 59–70
www.elsevier.com/locate/entcs

A Calculus for Interaction Nets Based on the Linear Chemical Abstract Machine
Ian Mackie
LIX, CNRS UMR 7161, E´cole Polytechnique, 91128 Palaiseau Cedex, France
Shinya Sato
Himeji Dokkyo University, Faculty of Econoinformatics, 7-2-1 Kamiohno, Himeji-shi, Hyogo 670-8524, Japan

Abstract
Interaction nets are graph rewriting systems which are a generalisation of proof nets for classical linear logic. The linear chemical abstract machine (CHAM) is a term rewriting system which corresponds to classical linear logic, via the Curry-Howard isomorphism. We can obtain a textual calculus for interaction nets which is surprisingly similar to linear CHAM based on the multiplicative fragment of classical linear logic. In this paper we introduce a framework based on the linear CHAM to model interaction net reduction. We obtain a textual calculus for interaction nets that is closer to the graphical representation than previous attempts.
Keywords: Interaction net, linear logic, chemical abstract machine, CHAM

1	Introduction
Interaction nets are graphical rewriting systems, defined in a very similar way to term rewriting systems: they are user-defined by giving a signature and a set of rules over the signature. At the origin, interaction nets were inspired by linear logic proof nets [7], specifically the multiplicative part. Since interaction nets were introduced by Lafont in 1990 [8] there has been a wealth of theory and applications developed (see for instance [3,6,4,10,12,9] for just a sample).
In the study of the theory of interaction nets, various textual calculi have been
proposed for interaction nets. Although these calculi destroy the graphical advan- tages, they do allow an easy way of writing them. In particular, they can provide a basis of a programming language [11], and they also serve to provide a language that is more familiar to develop proofs of properties. In [5] a calculus of interaction nets was proposed, based in part on the syntax that Lafont gave.

1571-0661© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.10.027

The purpose of this current paper is to investigate alternative calculi for inter- action nets, with the aim of providing the following:
a calculus which is close, with as few overheads as possible, to the graphical syntax;
provide a first analysis of the cost of interaction net reduction, so that we can build up a cost model of interaction nets.
With respect to the first point, we see this paper as an increment on previous work. With respect to the second point, this paper is a first step towards the study of cost models for interaction nets, which, in the future, will give the ability to compare different interaction net encodings of languages in a formal setting.
The rest of this paper is structured as follows. In the next section we recall some basics on interaction nets. In Section 3 we review the linear chemical abstract machine. Section 4 is devoted to representing interaction nets in the linear chemical abstract machine. Section 5 is about cost models, and we conclude the paper in Section 6.
2	Interaction nets
Here we review the basic notions of interaction nets. We refer the reader to [8] for a more detailed presentation. Interaction nets are specified by the following data:
A set Σ of symbols. Elements of Σ serve as agent (node) labels. Each symbol has an associated arity ar that determines the number of its auxiliary ports. If ar(α) = n for α ∈ Σ, then α has n+1 ports: n auxiliary ports and a distinguished one called the principal port.

We may use labels a1, a2, ..., b1, b2, ... in order to distinguish each auxiliary port.
A net built on Σ is an undirected graph with agents at the vertices. The edges of the net connect agents together at the ports such that there is only one edge at every port. A port which is not connected is called a free port.
Two agents (α, β) ∈ Σ × Σ connected via their principal ports form an active pair (analogous to a redex). An interaction rule ((α, β) → N ) ∈ Rin replaces the pair (α, β) by the net N . All the free ports are preserved during reduction, and there is at most one rule for each pair of agents. The following diagram illustrates the idea, where N is any net built from Σ.




We use the notation N1 −→ N2 for the one step reduction and −→∗ for its



Fig. 1. An example of a system of interaction nets
transitive and reflexive closure.
Figure 1 shows an example of a system of interaction nets, which corresponds to the usual term rewriting system for addition on the natural numbers. Interaction nets have the following property [8]:
Strong Confluence: Let N be a net. If N −→ N1 and N −→ N2 with N1 /= N2, then there is a net N3 such that N1 −→ N3 and N2 −→ N3.
We say that a net is deadlock-free if it does not have any vicious cycles of principal ports.
3  Linear chemical abstract machine
In this section we introduce a framework which is a generalisation of the linear chem- ical abstract machine (linear CHAM), introduced by Abramsky [1]. This framework is specified by the following data:
We assume a set N of names, ranged over by x, y, z, ..., x1, x2, .... We use x¯, y¯, ...
to range over sequences of names.
A set Σ of symbols. Elements of Σ serve as constructors of terms. Each symbol has an associated arity ar that determines the number of its arguments.
Terms built on Σ have one of the forms:  t ::= x | α(t1, ..., tn), where t1, ..., tn are terms, α ∈ Σ and ar(α) = n. When ar(α) = 0, we omit brackets, i.e., we write just α. We use t, s, u, ... to range over terms and t¯, s¯, u¯, ... to range over sequences of terms.
Coequations have the form:   t⊥s, where t, s are terms.  Coequations are the
molecules, which are the elements of computation.	Given t¯ = t1, ..., tk, s¯ =
s1, ..., sk, we write t¯⊥s¯ to denote the list t1⊥s1, ..., tk⊥sk. We use Θ, Ξ to range over sequences of coequations.
Conﬁgurations have the form:  Θ; t¯, where Θ is a sequence of coequations and t¯ is a sequence of terms. In a configuration Θ; t¯, we call Θ a solution and t¯ the main body. Main bodies are used for recording the result of the computation. We use P, Q to range over configurations.



Fig. 2. Rules of Linear CHAM

Rewriting rules have the form:  α(t1, ..., tn)⊥β(s1, ..., sk) −→ Θ, where α, β ∈ Σ, t1, ..., tn, s1, ..., sk are meta-variables for terms and Θ is a sequence of coequations. Moreover, t1, ..., tn, s1, ..., sk must be distinct, occur once in Θ respectively and there should be at most one rule between α and β. We use Rcham for a set of these rules.

Definition 3.1 (Free and bound) When a name x occurs twice in a term t, then the occurrences are said to be bound for t and all other occurrences are free for t. When every name occurs twice in a term t, then t is said to be linear. We extend this notion into name occurrences in sequences of terms, coequations and so on.

The linear CHAM is a rewriting system for configurations. The rules of the linear CHAM are divided into three kinds: structural rules which describe the “magical mixing” [2], reaction rules which describe the actual computation steps, and a cleanup rule which records the result of the computation in the main body. In Figure 2 we give the structural rules, the reaction rules and a cleanup rule. We define P ⇓ Q by P −→∗ Q where Q is a −→-normal form.

Example 3.2 In this framework the rules of Figure 1 can be represented as the following two rules:
add(t1, t2)⊥S(u) −→ t1⊥S(x),  add(x, t2)⊥u,
add(t1, t2)⊥Z −→ t1⊥t2

and the computation can be performed as follows:
add(y, Z)⊥S(Z); y −→ y⊥S(x), add(x, Z)⊥Z; y −→
y⊥S(x), x⊥Z; y −→ x⊥Z; S(x) −→ ; S(Z).
From now on we identify P1 and P2 such that P1 ≡ P2, which is defined as follows:
Definition 3.3 (Structural equivalence) A renaming is a permutation ρ : N ∼= N . This is extended to a substitution on terms, coequations, configurations etc. in the usual way. The structural equivalence of configurations P ≡ Q is defined by:
∃ρ.(ρ(P )  ∗ Q).
This framework has the following properties, using the same ideas as [1].
Theorem 3.4 Assume a set of rules Rcham and a linear conﬁguration P:
Linearity: If P −→ Q, then Q is also linear.
Strong Confluency: If P −→ Q1, P −→ Q2 and Q1 /= Q2, then for some R, Q1 −→ R and Q2 −→ R.
Determinacy: If P ⇓ Q1 and P ⇓ Q2, then Q1 = Q2.
4  From interaction nets to linear CHAM
In this section we introduce a translation T from interaction nets into the linear chemical framework. First, we define a translation TN from nets into configurations, where we restrict nets to be deadlock free (consequently, there are no vicious circles).
Free ports: for every free port, we connect a principal port of a fresh agent whose arity is 0. We use T, S, U,... to range over these fresh agents. This is a pre-processing step that must be performed on the net being translated.
Agents: for every agent whose symbol is α, we introduce a term α(x1, ..., xn) where each x1, ..., xn is a fresh name. In this translation, the occurrence of the term α(x1, ..., xn) is corresponding to the principal port of the agent α, and each occurrence of x1, ..., xn corresponds to the auxiliary ports respectively.
Connections between principal ports: we assume that terms for these prin- cipal ports are α(t¯) and β(s¯). For this connection, we introduce a coequation α(t¯)⊥β(s¯).
Connections between a principal port and an auxiliary port: we assume that terms for a principal port and an auxiliary port are α(t¯) and x respectively. For this connection, we replace the occurrence of x by α(t¯).
Connections between auxiliary ports: we assume that names for these aux- iliary ports are x and y respectively. For this connection, we introduce a fresh name z and we replace the occurrence of x by z, and the occurrence of y by z.
Finalization: we make a configuration in the following way:
· for the solution, collect coequations generated by this translation.

· the main body must be empty because all free principal ports are connected to principal ports of fresh agents.
For example, each net in the example of reductions in Figure 1 is represented as follows:
add(T, Z)⊥S(Z); ,	T⊥S(x), add(x, Z)⊥Z; ,	T⊥S(Z); .
The following lemma holds because every occurrence of a coequation is caused as a result of a connection between principal ports:
Lemma 4.1 When N has no vicious circle, then all coequations obtained by TN [N ]
have forms t⊥u where t and u are not names.	 
Next we define a translation TR of a rule ((α, β) → N ) ∈ Rin.
TR[(α, β) → N ] = α(t1, ..., tn)⊥β(s1, ..., sk) −→ Θ where α(t1, ..., tn)⊥β(s1, ..., sk) and Θ are the results obtained from TN [(α, β)] and TN [Θ] assuming each free port is connected to principal ports t1, ..., tn, s1, ..., sk respectively.
We may write TR[(α, β) → N ] = α(t1, ..., tn)⊥β(s1, ..., sk) −→ Θ(t1, ..., tn, s1, ..., sk), where Θ(t1, ..., tn, s1, ..., sk) means that meta variables t1, ..., tn, s1, ...sk occur in Θ respectively.
For example, each rule in Figure 1 is represented as follows:
add(t1, t2)⊥S(s1) −→ t1⊥S(x),  add(x, t2)⊥s1,
add(t1, t2)⊥Z −→ t1⊥t2.

Correctness
Next we examine the correctness of the translation. In Figure 1, the first net in the example reduction is reduced to the last net by using rules obtained from the translation T as follows:
add(T, Z)⊥S(Z); −→ T⊥S(x), add(x, Z)⊥Z; −→ T⊥S(x), x⊥Z; −→ T⊥S(Z); .
This correspondence shows the correctness of the translation for the case of Figure 1. We can show the correctness for the other cases:
Theorem 4.2 When N1 −→ N2 by using a rule R ∈ Rin and N1, N2 does not contain vicious circles, then TN [N1] −→∗ TN [N2].
Proof. We argue only a simple case such that ((α, β) → N ) ∈ Rin where ar(α) = 1,
ar(β) = 2, and TR[(α, β) → N ] = α(t)⊥β(s1, s2) −→ Θ(t, s1, s2).

This is just for the sake of concrete argument, and the other cases are also shown in a similar way.
We use P −→Binding Q iff P −→ Q can be derived by using the Binding rule.
We check connections of free ports of (α, β):

No free port is connected: N1 is just a net (α, β).

Then, by the construction of Θ(t, s1, s2):

TN [N1] = α(T)⊥β(S1, S2); −→ Θ(T, S1, S2); = TN [N2]


One free port is connected: We assume that the leftmost free port is connected.
to a principal port: A principal port of an agent γ is connected as follows:

Because the principal port of γ is represented as a term, we can show
TN [N1] = α(γ(T))⊥β(S1, S2); −→ Θ(γ(T), S1, S2); = TN [N2].
to an auxiliary port: An auxiliary port of an agent γ is connected.
Case 1: In the right hand side of the rule, the auxiliary port of γ is connected to a principal port:
Let TR[(α, β) → N ] = α(t)⊥β(s1, s2) −→ t⊥σ(u), Θ'(s1, s2).
Then, TN [N1] = T⊥γ(x), α(x)⊥β(S1, S2); −→ T⊥γ(x), x⊥σ(u), Θ'(S1, S2);
−→Binding T⊥γ(σ(u)), Θ'(S1, S2); = TN [N2].
Case 2: In the right hand side of the rule, the auxiliary port of γ is connected to an auxiliary port:
Let the translation of the rule be as follows:
TR[(α, β) → N ] = α(t)⊥β(s1, s2) −→ Θ(t, s1, s2).
Then, TN [N1] = T⊥γ(x), α(x)⊥β(S1, S2);  −→ T⊥γ(x), Θ(x, S1, S2);
= TN [N2].
Case 3: In the right hand side of the rule, the auxiliary port of γ is connected to a free port.


  	  
Let TR[(α, β) → N ] = α(t)⊥β(s1, s2) −→ t⊥s1, Θ''(s2).
Then, TN [N1] = T⊥γ(x), α(x)⊥β(S1, S2);  −→ T⊥γ(x), x⊥S1, Θ''(S2);
−→Binding T⊥γ(S1), Θ''(S2); = TN [N2].
Many free ports are connected: In the case that some free ports are connected to principal ports, we can show the correspondence as same as the case that one free port in (α, β) is connected to a principal port because these principal ports are represented as terms and such connections are realized as replacing the occurrence of names for the free ports by these terms.
In the case that some ports are connected to auxiliary ports, we can also show the correspondence as same as the case that one free port in (α, β) is connected to an auxiliary port because the Binding rules can be performed safely by using the Lemma 4.1.
For example, we show a complicated case that two free ports are connected to auxiliary ports of an agent and the another port is connected to a principal port of an agent as follows:

Let TR[(α, β) → N ] = α(t)⊥β(s1, s2) −→ s1⊥α2(u), Θ'(t, s2), where the term corresponding to the occurrence of σ1 is included in Θ', and u is a term created by TR as a connection between an auxiliary port of σ2 and a free port of N'.
Then, TN [N1] = α(x2)⊥β(x1,τ (S)), γ(x1, x2)⊥T;
−→ x1⊥σ2(u), Θ'(x2,τ (S)), γ(x1, x2)⊥T;
−→Binding Θ'(x2,τ (S)), γ(σ2(u), x2)⊥T; = TN [N2].
The other cases are also shown in a similar way. We note that nets such as the following are not treated because there exists a vicious circle in N2:

 

Relation between graphical and textual representations
Here we ask how close our representation of interaction nets are to the graphical ones. The number of reductions may be more than the number of reductions in interaction nets. For example, in Figure 1, the number of reductions is two, but in the linear chemical framework, the total number of reductions is three, even though the number of reductions by using the Change rule is two. This reason for this is because we have to introduce names for connections between auxiliary ports, and consequently the number of reductions for these names can be increased to the number of these connections. We introduce a weight for the number which can be increased:
For a net N , a weight |N| is the number of connections between auxiliary ports.
For a rule ((α, β) → N ) ∈ Rin, a weight |(α, β) → N| is |N|.
When N1 ⇓ N2, the sum of |N1| and |r| for each rule r which is applied in order to obtain N2 is the number of reductions which can be increased in the case of the translation T. As an example, in Figure 1, in the net of the right-hand side in the rule between add and S, one name is introduced. Therefore the number of reductions is increased by one.
On the other hand, this redundancy is needed for parallel computation. For example, in the following net, there are two active pairs whose auxiliary ports are connected together:

When these reductions are performed simultaneously, there becomes no informa- tion about the connection between these auxiliary ports. For this reason, we need some device for preserving this information. In the case of our calculus, this net is represented as add(T, Z)⊥S(x), add(x, Z)⊥Z; then, after these reductions that can be done simultaneously, we can rewire these auxiliary ports together. Therefore, we can think that this redundancy is the price that we have to pay for parallel computations.

Related work
In [5] a textual calculus for interaction nets was proposed. The main difference be- tween this calculus and our calculus is in the way the rewrite rules are represented. In the textual calculus, fresh names are introduced according to occurrences of names in a rule, even if the occurrences are not for connections between auxil- iary ports. Therefore, the number of reductions will be increased according to the number of names which are not for connections between auxiliary ports in rules at most.

For example, the rules in Figure 1 are defined as follows:
add(S(y), x) 0 S(add(y, x))	add(x, x) 0 Z.
The rewritings are performed as follows:
⟨ a | add(a, Z) = S(Z) ⟩ −→⟨ a | a = S(x'), Z = y', Z = add(x', y') ⟩
−→ ⟨ S(x') | Z = y', Z = add(x', y') ⟩ −→⟨ S(x') | Z = add(x', Z) ⟩
−→ ⟨ S(x') | x' = x'', Z = x'' ⟩ −→⟨ S(x'') | Z = x'' ⟩ −→⟨ S(Z) | ⟩.
Compared with the number of reductions in our calculus, we find that the number of reductions has increased by two (see Example 3.2). This is because the name x is used not only for connections between auxiliary ports in these rules respectively and therefore some substitutions for these names are needed.

Cost models
In this section we briefly outline how we propose to measure the cost of an interaction net computation using the calculus. The main point is that we can use the calculus to give a precise measure.
In the graphical notation, for the rule between add and S in Figure 1, we may estimate that the cost should be three times of the cost of a rewire of ports intu- itively:

However, each cost of rewires are different. For example, as a result of a rewire, the types of connectors determine whether a new active pair can be created. Therefore, it is difficult to estimate the cost.
In our calculus, we can divide rewires into two sorts: one is creation of an active pair, another is just a re-connection. When considering agents, we introduce the following constants of costs:
α: the cost of creation of each agent and name,
ϵ: the cost of erasing of each agent and name,
θ: the cost of creation of an active pair,
ω: the cost of rewire.
and we estimate cost of a rule as the sum of creation costs of the right-hand side of the rule. As an example, for the rule add(t1, t2)⊥S(u) −→ t1⊥S(x), add(x, t2)⊥u, the cost for the first coequation t1⊥S(x) can be estimated as the sum of the cost of one creation of a name x, one rewire of x to S and two rewires of both t1 and S(x) to a coequation cell ⊥, thus α + 3ω + θ. For the next coequation add(x, t2)⊥s1,

the cost can be the sum of the cost of one rewires of x to add, one creation of a coequation cell ⊥ and two rewires of both add(x, t2) and s1 to the coequation cell ⊥, thus 3ω + θ. Therefore, the cost can be α + 6ω + 2θ. For the another rule add(t1, t2)⊥Z −→ t1⊥t2, the cost can be estimated as the sum of the cost of eliminations of agent add and Z, one creation of a coequation cell ⊥ and two rewires of both t1 and t2 to the coequation cell ⊥, thus 2ϵ + θ + 2ω. If we can reuse a coequation cell in the left-hand side, these costs can be reduced to α + 6ω + θ and 2ϵ + 2ω respectively.
This cost model is suitable for the calculation models that treat an active pair as a data object of two cells and store each information of connections between auxiliary ports into a buffer.
Conclusions
In this paper we have given a new calculus for interaction nets that we believe is closer to the graphical framework than extant calculi. We have also made a first attempt to study the cost of an interaction net computation. Current work is now devoted to building programming languages around this framework, and also using the framework to show properties of existing systems of interaction.

References
S. Abramsky. Computational interpretations of linear logic. Theoretical Computer Science, 111:3–57, 1993.
G. Berry and G. Boudol. The chemical abstract machine. In Conference Record of the 17th Annual Symposium on Principles of Programming Languages, pages 81–94, San Francisco, California, January 1990.
M. Fern´andez and I. Mackie. Coinductive techniques for operational equivalence of interaction nets. In Proceedings of the 13th Annual IEEE Symposium on Logic in Computer Science (LICS’98), pages 321–332. IEEE Computer Society Press, June 1998.
M. Fern´andez and I. Mackie. Interaction nets and term rewriting systems. Theoretical Computer Science, 190(1):3–39, January 1998.
M. Fern´andez and I. Mackie. A calculus for interaction nets. In G. Nadathur, editor, Proceedings of the International Conference on Principles and Practice of Declarative Programming (PPDP’99), volume 1702 of Lecture Notes in Computer Science, pages 170–187. Springer-Verlag, September 1999.
M. Fern´andez and I. Mackie. A theory of operational equivalence for interaction nets. In G. Gonnet,
D. Panario, and A. Viola, editors, LATIN 2000. Theoretical Informatics. Proceedings of the 4th Latin American Symposium, Punta del Este, Uruguay, volume 1776 of Lecture Notes in Computer Science, pages 447–456. Springer-Verlag, April 2000.
J.-Y. Girard. Linear logic. Theoretical Computer Science, 50:1–102, 1987.
Y. Lafont. Interaction nets. In 17th Annual Symposium on Principles of Programming Languages, pages 95–108, San Francisco, California, 1990. ACM Press.
S. Lippi. λ-calculus left reduction with interaction nets. Mathematical Structures in Computer Science, 12(6), 2002.
I. Mackie. Interaction nets for linear logic. Theoretical Computer Science, 247(1):83–140, September 2000.
I. Mackie. Towards a programming language for interaction nets. Electronic Notes in Theoretical Computer Science, 127(5):133–151, May 2005.


J. S. Pinto. Sequential and concurrent abstract machines for interaction nets. In J. Tiuryn, editor, Proceedings of Foundations of Software Science and Computation Structures (FOSSACS), volume 1784 of Lecture Notes in Computer Science, pages 267–282. Springer-Verlag, 2000.
