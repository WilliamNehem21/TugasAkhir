Available online at www.sciencedirect.com



Electronic Notes in Theoretical Computer Science 276 (2011) 263–289
www.elsevier.com/locate/entcs

2-Dimensional Directed Type Theory
Daniel R. Licata and Robert Harper1,2
Carnegie Mellon University

Abstract
Recent work on higher-dimensional type theory has explored connections between Martin-Löf type theory, higher-dimensional category theory, and homotopy theory. These connections suggest a generalization of dependent type theory to account for computationally relevant proofs of propositional equality—for example, taking IdSet A B to be the isomorphisms between A and B. The crucial observation is that all of the familiar type and term constructors can be equipped with a functorial action that describes how they preserve such proofs. The key benefit of higher-dimensional type theory is that programmers and mathematicians may work up to isomorphism and higher equivalence, such as equivalence of categories.
In this paper, we consider a further generalization of higher-dimensional type theory, which associates each type with a directed notion of transformation between its elements. Directed type theory accounts for phenomena not expressible in symmetric higher-dimensional type theory, such as a universe set of sets and functions, and a type Ctx used in functorial abstract syntax. Our formulation requires two main ingredients: First, the types themselves must be reinterpreted to take account of variance; for example, a Π type is contravariant in its domain, but covariant in its range. Second, whereas in symmetric type theory proofs of equivalence can be internalized using the Martin-Löf identity type, in directed type theory the two- dimensional structure must be made explicit at the judgemental level. We describe a 2-dimensional directed type theory, or 2DTT, which is validated by an interpretation into the strict 2-category Cat of categories, functors, and natural transformations. We also discuss applications of 2DTT for programming with abstract syntax, generalizing the functorial approach to syntax to the dependently typed and mixed-variance case.
Keywords: type theory, category theorey, dependent types, homotopy type theory


Introduction
In type theory, it is standard to define a type A by introduction, elimination, and equality rules. The introduction and elimination rules describe how to construct and use terms M of type A, and the equality rules describe when two terms are equal. Intensional type theories distinguish two different notions of equality: a judgement of definitional equality (M ≡ N : A), containing the β- and perhaps some η-rules for the various types, and a type of propositional equality (IdA M N ), which allows additional equalities that are justified by explicit proofs. The type theory ensures

1 This research was sponsored in part by the National Science Foundation under grant number CCF- 0702381 and by the Pradeep Sindhu Computer Science Fellowship. The views and conclusions contained in this document are those of the author and should not be interpreted as representing the oﬃcial policies, either expressed or implied, of any sponsoring institution, the U.S. government or any other entity.
2 Email: {drl,rwh}@cs.cmu.edu

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.09.026

that all families of types x :A ▶ C type respect equality, in the sense that equal terms M and N determine equal types C[M/x] and C[N/x]. Definitionally equal terms give definitionally equal types, whereas propositionally equal terms induce a coercion between C[M/x] and C[N/x]:
x :A ▶ C type	P : IdA M N	Q : C [M /x ]
substC P Q : C [N /x ]
The nature of this coercion is explained by the groupoid interpretation of type the- ory given by FIXME. A closed type is interpreted as a groupoid (a category in which all morphisms are invertible), where the objects of the groupoid are the terms of the type, and the morphisms are proofs of propositional equality between terms. Open types and terms are interpreted as functors, whose object parts are (roughly) the usual types and terms of the set-theoretic semantics, and whose morphism parts show how those types and terms preserve propositional equality. An identity type IdA M N is interpreted using the Hom set of A. Many types, such as natural numbers, are interpreted by discrete groupoids, where the only proofs of proposi- tional equality are identities. Such types satisfy uniqueness of identity proofs (UIP) (see FIXME for an introduction), which states that all terms of type IdA M N are themselves equal. However, the groupoid interpretation also permits types of higher dimension that have a non-trivial notion of propositional equality.
One example of a higher-dimensional type is a universe, set, a type whose ele- ments are themselves classifiers: associated to each element S of set, there is a type El(S) classifying the elements of S. The groupoid interpretation permits sets to be considered modulo isomorphism, by taking the propositional equalities between S1 and S2 to be invertible functions El(S1) → El(S2). Semantically, set may be inter- preted as the category of sets and isomorphisms. 3 This interpretation of set does not satisfy UIP, as there can be many different isomorphisms between two sets. Given this definition of propositional equality, subst states that all type families respect iso-
morphism: for any x : set ▶ C : set, A ∼= B implies C[A] ∼= C[B]. Computationally,
the lifting of the isomorphism is given by the functorial action of the type family C.
The groupoid interpretation accounts for types of dimension 2, but not higher. For example, while the groupoid interpretation permits a universe of sets modulo isomorphism, it does not provide the appropriate notion of equality for a universe containing a universe, where equality should be categorical equivalence, which may be described as “isomorphism-up-to-isomorphism”. Recent work has generalized this interpretation to higher dimensions, exploiting connections between type theory and homotopy theory or higher-dimensional category theory (which, under the homotopy hypothesis [5] are two sides of the same coin). On the categorical side, FIXME generalizes the groupoid interpretation to a class of 2-categories where the 2-cells are invertible. FIXME and FIXME show that the syntax of intensional type theory forms a weak ω-category. On the homotopy-theoretic side, FIXME show how to interpret intensional type theory into abstract homotopy theory (i.e. Quillen model

3 This works if the sets S themselves are discrete; otherwise, set can be interpreted as the groupoid of small groupoids, which permits non-trivial maps between elements of sets.

categories), and Voevodsky’s equivalence axiom [36] equips a type theory with a notion of homotopy equivalence, which provides the appropriate notion of equality for types of any dimension.
However, the groupoid interpretation, and all of these generalizations of it, make essential use of the fact that proofs of equivalence are symmetric, interpreting types as groupoids or homotopy spaces. For some applications, it would be useful to consider types with an asymmetric notion of transformation between elements. For example, functors have proved useful for generic programming, because every functor provides a way for a programmer to apply a transformation to the components of a data structure. If we consider a universe set whose elements are sets S and whose morphisms are functions f : El(S1) → El(S2), then any dependent type
x :set ▶ C type describes such a functor, and subst can be used to apply a function
f to the components of the data structure described by C.
Another application concerns programming with abstract syntax and logical derivations. In the functorial approach to syntax with binding [3,20,14], the syn- tactic expressions in context Ψ are represented by a family of types indexed by Ψ—e.g. a type prop(Ψ) classifying formulas in a first-order logic with free vari- ables in Ψ—where Ψ: Ctx is a representation of a context (e.g. a list of sorts). Structural properties, such as weakening, exchange, contraction, and substitution can be cast as showing that prop(−) is the object part of a functor from a context category. The context category has contexts Ψ as objects, while the choice of mor- phisms determines which structural properties are provided: variable-for-variable substitutions give weakening, exchange, and contraction; term-for-variable substi- tutions additionally give substitution. However, these context morphisms are not in general invertible, and therefore describing syntax functorially requires general, non-groupoidal, categories.
In this paper, we propose a new notion of directed type theory, which generalizes existing symmetric type theory by permitting an asymmetric notion of transforma- tion between the elements of a type. This extends the connection between type theory, higher-dimensional category theory, and homotopy theory to the directed case. Our formulation requires two interesting technical ingredients: First, directed type theory differs from conventional type theory in that it must account for vari- ances of families of types. In conventional symmetric type theory there is no need to account for variance, because the proofs of equivalence of two indices are invert- ible. To relax this restriction requires that the syntax distinguish between co- and contra-variant dependencies. This has implications for the type structure as well, so that, for example, dependent function types are contravariant in the domain and covariant in their range. Second, directed type theory exposes higher-dimensional structure at the judgemental, rather than the propositional level. In particular the Martin-Löf identity type is no longer available, because the usual elimination rule implies symmetry, which we explicitly wish to relax. Moreover, in the absence of invertibility, the identity type cannot be formed as a type. We must instead give a judgemental account of transformations, and make explicit the action of transfor- mations on families of types.

Here, we consider only the two-dimensional case of directed type theory, and define a type theory 2DTT (Section 2). 2DTT admits a simple interpretation in the category Cat of categories, functors, and natural transformations (Section 3). The syntax of 2DTT reflects the fact that Cat is a strict 2-category, in that various associativity, unit, and functoriality laws hold definitionally, rather than proposi- tionally. Although it is not necessary for the applications we consider here, it seems likely that 2DTT could be extended to higher dimensions, and that more general interpretations are possible. Our main motivating application of 2DTT, which we sketch in Section 4, is extending functorial syntax [21,14] to account for dependently typed and mixed variance syntax.


Syntax
In this section, we give a proof theory for 2DTT. 2DTT has three main judgements, defining contexts Γ, substitutions θ, and transformations δ. In the semantics given below, these are interpreted as categories, functors, and natural transformations, respectively. Using the terminology of 2-categories, we will refer to a context Γ as a “0-cell”, a substitution as a “1-cell”, and a transformation as a “2-cell”. Each of these three levels has a corresponding contextualized version, which is judged well-formed relative to a context Γ. Contextualized contexts and substitutions are dependent types A and terms M , while contextualized transformations are asym- metric analogue of propositional equality proofs. As discussed above, the two main ingredients in 2DTT are these transformation judgements, and variance annotations on assumptions in the context. To summarize, the judgement forms of 2DTT are
Contexts: Γ ctx
Substitutions: Γ ▶ θ :Δ (where Γ ctx and Δ ctx)
Transformations: Γ ▶ δ : θ =⇒Δ θj (where Γ ctx and Δ ctx and Γ ▶ θ, θj : Δ)
Dependent Types: Γ ▶ A type (where Γ ctx)
Terms: Γ ▶ M : A (where Γ ctx and Γ ▶ A type)
Term Transformations: Γ ▶ α : M =⇒A Mj (where Γ ctx and Γ ▶ A type and
Γ ▶ M , M j : A)
Because 2-cell structure is not commonly described type-theoretically, we have chosen to make many rules derivable, rather than admissible, so that the typing rules give a complete account of the theory. For example, we make use of explicit substitutions, which internalize the composition principles of a 2-category, rather than treating substitution as a meta-level operation. The defining equations of sub- stitutions are included as definitional equality rules. However, we leave weakening admissible, as the de Bruijn form that results from explicit weakening is difficult to read. The treatment of dependent types in FIXME’s survey article provides an introduction to this style of syntax, with an explicit substitution judgement and internalized composition principles.





 Γ ctx 
Γop ctx
Γop ▶ θ : Δop Γ ▶ θop :Δ 
Γop ▶ δ : θ′op =⇒Δop θop

Γ ▶ δop : θ =⇒Δ θ′


(Γop)op ≡ Γ 0-involution (θop)op ≡ θ 1-involution (δop)op ≡ δ 2-involution



Γ ⊇ Δ
Γ ▶ idΔ :Δ 
Γ2 ▶ θ2 : Γ3 Γ1 ▶ θ1 : Γ2 Γ1 ▶ θ2 [θ1]: Γ3
Γ ▶ θ :Δ  Γ0 ▶ δ : θ1 =⇒Γ θ2

Γ0 ▶ θ[δ]: θ[θ1] =⇒Δ θ[θ2]


θ0 [θ[θ′]]  ≡ θ0 [θ][θ′] 1-subst assoc/unit
θ0 [idΓ]	≡ θ0
idΓ[θ]	≡ θ

θ[δ[δ′]]	≡ θ[δ][δ′]  1-resp assoc
θ[reflθ' ]	≡ reflθ[θ' ] 1-resp preserves refl.
θ[θ′][δ]	≡ θ[θ′[δ]]  1-resp for 1-subst


idop
≡ idΓop	op interactions

(θ1 [θ2])op ≡ θop[θop]
1  2
(θ[δ])op	≡ θop[δop]






Γ ▶ reflΔ : θ =⇒Δ θ
Γ ▶ δ1 : θ1 =⇒Δ θ2
Γ ▶ δ2 : θ2 =⇒Δ θ3

Γ ▶ δ2 ◦ δ1 : θ1 =⇒Δ θ3
Γ ▶ δ : θ =⇒Δ θ′
Γ0 ▶ δ0 : θ0 =⇒Γ θ′


Γ0 ▶ δ[δ0]: θ[θ0] =⇒Δ θ′[θ′ ]


(δ3 ◦ δ2) ◦ δ1	≡ δ3 ◦ (δ2 ◦ δ1)  trans assoc/unit
(δ ◦ refl)	≡ δ
(refl ◦ δ)	≡ δ

δ0 [δ[δ′]]	≡ δ0 [δ][δ′]	2-resp assoc/unit
δ0 [reflid]	≡ δ0
reflidΓ [δ]	≡ δ

(δ1 ◦ δ2 )[δ3 ◦ δ4] ≡ δ1 [δ3] ◦ δ2 [δ4] interchange



θ
2	1
1  2


Fig. 1. 2DTT: Identity, Composition, and Involution Principles (1)







Γ ▶ θ :Δ  Δ ▶ A type


Γ ▶ A[θ] type
Δ ctx Δ ▶ C type Γ ▶ δ : θ1 =⇒Δ θ2 Γ ▶ M : C [θ1 ] Γ ▶ mapΔ.C δ M : C [θ2 ]
A[θ[θ′]] ≡ A[θ][θ′]	0-subst assoc/unit
A[idΓ] ≡ A


mapΔ.C reflθ M ≡ M	0-resp functoriality
mapΔ.C (δ2 ◦ δ1) M ≡ mapΔ.C δ2 (mapΔ.C δ1 M)
(mapΔ.C δ M )[θ0] ≡ mapΔ.C δ[reflθ0 ] M [θ0]	1-subst for map
(mapC (δ : θ1 =⇒ θ2 ) M )[δ′ : θ′ =⇒ θ′ ] ≡ resp (x.mapC (δ[reflθ' ]) x) (M [δ′]) 1-resp for map
1	2	2
mapΔ.C [θ : Δ' ] δ M ≡ mapΔ'.C reflθ[δ] M	def. map for A[θ]



Γ ▶ θ : Δ Δ ▶ M : A Γ ▶ M [θ]: A[θ]
	Δ ▶ M : A Γ ▶ δ : θ1 =⇒Δ θ2	
Γ ▶ M [δ]: (mapΔ.A δ (M [θ1])) =⇒A[θ2 ] M [θ2]

M [θ[θ′]] ≡ M [θ][θ′] 1-subst assoc/unit
M [idΓ]  ≡ M

M [δ[δ′]] ≡ M [δ][δ′] 1-resp assoc/unit M [reflθ] ≡ reflM [θ] 1-resp preserves refl. M [θ][δ] ≡ M [θ[δ′]] 1-resp for 1-subst



Γ ▶ α1 : M1 =⇒A M2
Γ0 ▶ δ0 : θ0 =⇒Γ θ′

Γ ▶ α2 : M2 =⇒A M3	Γ ▶ α : M =⇒A N
M














(α1 ◦ α2 )[δ3 ◦ δ4] ≡ α1 [δ3] ◦ resp (x.map δ3 x) (α2 [δ4]) interchange
reflM [δ]	≡ M [δ]	delegate

Fig. 2. 2DTT: Identity, Composition, and Involution Principles (2)








All judgements respect equality:


Γ ≡ Γ′ Δ ≡ Δ′ Γ′ ▶ θ : Δ′ Γ ▶ θ :Δ 
Γ ≡ Γ′  Γ′ ▶ A type


Γ ▶ A type
Γ ≡ Γ′ Γ ▶ A ≡ A′ type Γ′ ▶ M : A′ Γ ▶ M : A

Γ ≡ Γ′ Δ ≡ Δ′ Γ ▶ θ1 ≡ θ′ : A Γ ▶ θ2 ≡ θ′ : A Γ′ ▶ δ : θ′ =⇒Δ' θ′
1	2	1	2
Γ ▶ δ : θ1 =⇒Δ θ2
Γ ≡ Γ′  Γ ▶ A ≡ A′ type Γ ▶ M ≡ M ′ : A Γ ▶ N ≡ N ′ : A Γ′ ▶ α : M ′ =⇒A' N ′
Γ ▶ α : M =⇒A N


Equality respects equality: Each equality judgement has an analogous respect-for-equality rule, which says that it respects equality in the context and classifier.
Congruence: Each equality judgement is a congruence, specified by reflexivity, symmetry, transitiv- ity rules, and a compatibility rule for each term constructor.
Empty context:

· ctx  Γ ▶ · : ·  Γ ▶ · : · =⇒· ·

θ	≡ · 1-η
δ	≡ · 2-η
·op  ≡ · 0,1,2-involution
id·  ≡ · identity
·[θ] ≡ · 1-subst
·[δ] ≡ · 1-resp
refl· ≡ · reflexivity
·◦· ≡ · trans
·[δ] ≡ · 2-resp


Fig. 3. 2DTT: General equality rules; Empty Context
Involution, Identity, and Composition Principles
In Figures 1 and 2, we present the generic involution, identity, and composition principles that define the basic structure of the theory.
The involution rules say that there is a dualizing operation op on contexts, sub- stitutions, and transformations. The equations say that this dualization operation is involutive. The rule for θop says that the opposite of a substitution proves the opposite of the contexts. To avoid specializing the context in the conclusion of the rules, we phrase this as an “elimination” rule, removing op from the two premise contexts. However, because op is an involution, an “introduction” rule which con- cludes Γop ▶ θop : Δop from Γ ▶ θ :Δ is derivable. The dual of a transformation not only dualizes the contexts and substitutions, but also reverses the direction of the transformation.




Covariant term variables:



Γ ctx Γ ▶ A type


Γ , x :A+ ctx

x :A+ ∈ Γ Γ ▶ x : A

Γ ▶ θ :Δ Γ ▶ M : A[θ] Γ ▶ θ, M +/x : Δ, x : A+
Γ ▶ δ : θ =⇒Δ θ′
Γ ▶ α : (mapΔ.A δ M) =⇒A[θ' ] N


Γ ▶ (δ, α+/x): (θ, M +/x) =⇒Δ,x :A+ (θ′, N +/x)

idΓ,x:A+ [θ, M +/x] ≡ θ	1-β
x [θ, M +/x] ≡ M	1-β
θ : (Γ , x :A+) ≡ idΓ[θ], x [θ]+/x	1-η
idΓ,x:A+ [δ, α+/x] ≡ δ	2-β
x [δ, α+/x] ≡ α	2-β
δ : θ =⇒(Γ,x :A+) θ′ ≡ idΓ[δ], x [δ]+/x	2-η

idΓ,x :A+ ≡ idΓ, x +/x	1-id
(θ, M +/x )[θ0] ≡ θ[θ0], M [θ0 ]+/x	1-subst
(θ, M +/x )[δ0] ≡ θ[δ0], M [δ0 ]+/x	1-resp
reflθ,M +/x ≡ reflθ, reflM + /x	refl
(δ2, α2 +/x) ◦ (δ1, α1 +/x) ≡ (δ2 ◦ δ1), (α2 ◦ resp (x .mapΔ.A δ2 x ) α1 )+/x trans
(δ, α+/x )[δ0] ≡ δ[δ0], α[δ0 ]+/x	2-resp
(Γ , x :A+)op ≡ Γop , x :A-	0-invol
(θ, M +/x)op ≡ θop, M -/x	1-invol
(δ, α+/x)op ≡ δop, α-/x	2-invol

Contravariant term variables:



Γ ctx  Γop ▶ A type

Γ , x :A- ctx

Γ ▶ θ :Δ Γop ▶ M : A[θop] Γ ▶ θ, M -/x : Δ, x : A-
Γ ▶ δ : θ =⇒Δ θ′
Γop ▶ α : (mapΔop .A (δop) N) =⇒A[θ] M


Γ ▶ (δ, α-/x): (θ, M -/x) =⇒Δ,x :A- (θ′, N -/x)

idΓ,x:A- [θ, M -/x] ≡ θ	1-β
θ : (Γ , x :A-) ≡ idΓ[θ], x [θop]-/x	1-η
idΓ,x:A- [δ, α-/x] ≡ δ	2-β

Γ
δ : θ =⇒(Γ,x :A-) θ′
≡ idΓ[δ], x [δ
op]-/x	2-η

idΓ,x :A- ≡ idΓ, x -/x	1-id
(θ, M -/x )[θ0] ≡ θ[θ0], M [θop]-/x	1-subst
-	0 -
(θ, M /x )[δ0] ≡ θ[δ0], M [δop] /x	1-resp
reflθ,M -/x ≡ reflθ, reflM -/x	refl
(δ2, α2 -/x) ◦ (δ1, α1 -/x) ≡ (δ2 ◦ δ1), (α2 ◦ resp (x .mapΔop .A δop x ) α1 )-/x trans
-	op -	2
(δ, α /x )[δ0] ≡ δ[δ0], α[δ0 ] /x	2-resp
(Γ , x :A-)op ≡ Γop , x :A+	0-invol
(θ, M -/x)op ≡ θop, M +/x	1-invol
(δ, α-/x)op ≡ δop, α+/x	2-invol


Fig. 4. 2DTT: Co- and Contravariant Term Variables

Dependent functions:


Γop ▶ A type
Γ , x :A- ▶ B type

Γ ▶ Π x :A. B type

Γ , x :A- ▶ M : B


Γ ▶ λ x . M :Π x :A. B

Γ ▶ M1 :Π x :A. B Γop ▶ M2 : A Γ ▶ M1 M2 : B [M2 /x ]

Γ , x :A- ▶ α : (M x ) =⇒B (N x )
Γ ▶ α : M =⇒Π x:A. B N  Γop ▶ β : N1 =⇒A M1



Γ ▶ λ x .α : M =⇒Π x:A. B N
Γ ▶ α M1 N1 β : map1
β (MM1) =⇒B[N1 /x] (NN1)


(Π x :A. B )[θ0]	≡ Π x :A[θop]. B [θ0 , x -/x ]	0-subst
mapΔ.Π x:A. B δ M  ≡ λ x . mapΔ,x :A-.B (δ, refl) (M (mapΔop .A δop x )) 0-resp
(λ x . M )[θ0]	≡ λ x . M [(θ0 , x -/x )]	1-subst
(M1 M2 )[θ0]	≡ (M1 [θ0 ]) (M2 [θ0 ])	1-subst
(λ x . M )[δ]	≡ λ x . M [δ, refl]	1-resp
(M N )[δ]	≡ M [δ] N [δ]	1-resp

reflM	≡ λ x . reflMx	refl
(λ x . α2 ) ○ (λ x . α1 ) ≡ λ x . α2 ○ α1	trans
(λ x :A. α)[δ0]	≡ λ x :A[θ′]. α[δ0 , refl/a]	2-resp
α1 α2 [δ0]	≡ (α1 [δ0 ]) (α2 [δ0 ])	2-resp

Fig. 5. 2DTT: Dependent Function Types
Identity and Composition for Substitutions
The next three rules define identity and composition for substitutions. To make weakening admissible, id is really the composition of the identity substitution with projections that forget any number of variables. We write Γ ⊇ Δ to mean that Δ is obtained from Γ by dropping some number of variables:


Γ ⊇ · done
Γ ⊇ Γj
Γ , x :A± ⊇ Γj
skip	Γ ⊇ Γj
Γ , x :A± ⊇ Γj , x :A±
keep

We do not require a rule for op because op can always be expanded away using equalities. All judgements of the form Γ ▶ J satisfy the following: If Γ ▶ J and Γj ⊇ Γ then Γj ▶ J .
Composition of substitutions θ2 [θ2], which we refer to as 1-substitution, is stan- dard in explicit substitution calculi. The additional composition operation, θ[δ], forces substitutions to respect transformation: substitution instances by trans- formable substitutions are transformable. For this reason, we refer to it as 1- resp(ect). The first three equations say that 1-substitution is associative and unital. In the second equation, idΓ can in fact be a weakening, in which case θ is tac- itly weakened in the right-hand side. The third equation only makes sense when Γ ▶ id : Γ, which we notate by idΓ. The next two rules say that 1-resp associates with 2-resp (δ[δj]), which is the analogous operation for transformations (defined


Dependent pairs:


Γ ▶ A type
Γ , x :A+ ▶ B type
Γ ▶ Σ x :A. B type

Γ ▶ M1 : A Γ ▶ M2 : B [M1 /x ] Γ ▶ (M1 , M2 ): Σ x :A. B

Γ ▶ M :Σ x :A. B

Γ ▶ fst M : A

Γ ▶ M :Σ x :A. B

Γ ▶ snd M : B [fst M /x ]


Γ ▶ α1 : fst M =⇒A fst N

Γ ▶ α2 : (map1
α1 (snd M )) =⇒B[fst N /x] snd N
Γ ▶ α : M =⇒
Σ x :A. B N

Γ ▶ (α1 , α2 ) : M =⇒Σ x:A. B N	Γ ▶ fst α : fst M =⇒A fst N
	Γ ▶ α : M =⇒Σ x:A. B N	
Γ ▶ snd α : (map1 (fst α) (snd M )) =⇒B[fst N /x] snd N
fst (M , N )	≡ M	1-β
snd (M , N )	≡ N	1-β
M :Σ x :A. B	≡ (fst M , snd M )	1-η
fst (α1 , α2 )	≡ α1	2-β
snd (α1 , α2 )	≡ α2	2-β
α : M =⇒Σ x:A. B N ≡ (fst α, snd α)	2-η

(Σ x :A. B )[θ0]	≡ Σ x :A[θ0 ]. B [θ0 , x +/x ]	0-subst
mapΔ.Σ x :A. B δ M  ≡ (mapΔ.A δ (fst M ), mapΔ,x :A+.B (δ, reflmap δ (fst M )) (snd M )) 0-resp
((M1 , M2 ))[θ0]	≡ (M1 [θ0 ], M2 [θ0 ])	1-subst
(fst M )[θ0]	≡ fst (M [θ0 ])	1-subst
(snd M )[θ0]	≡ snd (M [θ0 ])	1-subst
(M , N )[δ]	≡ (M [δ], N [δ])	1-resp
(fst M )[δ]	≡ fst M [δ]	1-resp
(snd M )[δ]	≡ snd M [δ]	1-resp

reflM	≡ (reflfst M , reflsnd M )	refl
(α2 , α′ ) ○ (α1 , α′ ) ≡ (α2 ○ α1 , α′ ○ resp (x .mapΔ.A (refl, α1 ) x ) α′ )	trans
2	1	2	1
(α1 , α2 )[δ0]	≡ (α1 [δ0 ], α2 [δ0 , refl])	2-resp
(fst α)[δ0]	≡ fst α[δ0 ]	2-resp
(snd α)[δ0]	≡ snd α[δ0 ]	2-resp

Fig. 6. 2DTT: Dependent Pairs

below), and preserves identities refl(defined below). The next three rules say that op preserves identities (and projections), and distributes over compositions. As will often be the case, the second rule (for 1-cells) is necessary to type-check the third (for 2-cells).

Identity and Composition For Transformations
The next three rules define identity and composition for transformations. Trans- formations are always reflexive (refl) and transitive (δ2 ◦ δ1). Additionally, transfor- mations themselves respect transformation (δ[δ0]), which we call 2-resp. The equa- tions say that: Transitivity is associative and unital with reflexivity. 2-resp is also associative and unital. However, the unit of 2-resp is not an arbitrary reflθ—which







Sets and elements:

	  Γ ▶ S : set 


Γ , x :El (S )+ ▶ M : El (S′)




Γ ▶ α : M =⇒El(S) N



Γ ▶ set type
Γ ▶ El (S ) type
Γ ▶ x .M : S =⇒set S′	Γ ▶ ٨ : M =⇒El(S) M
Γ ▶ M ≡ N : El (S )


mapEl(S) δ M [θ1] ≡ M [θ2]	def. El(—)
α : S =⇒set S′ ≡ x .mapa:Set.El(a) (·, α) x	2-η
α : M =⇒El(S) N ≡ ٨	2-η

set[θ0] ≡ set	0-subst
(El (S ))[θ0] ≡ El(S [θ0])
mapΔ.set δ M ≡ M	0-resp
mapΔ.El(S) δ M ≡ N [id, M +/x] if S [δ] ≡ x .N
reflS : set ≡ x .x	refl
reflM : El (S ) ≡ ٨	refl
(x .M1 ) ○ (x .M2 ) ≡ x .M2 [M1 /x ]	trans
٨ ○ ٨ ≡ ٨	trans
(x .M )[δ0] ≡ x .mapΔ.S' δ0 M [θ, x +/x ] if Δ , x :El (S )+ ▶ M : El (S′) and δ0 : θ =⇒ θ′ 2-resp
٨M [δ0] ≡ M [δ0]	2-resp

Fig. 7. 2DTT: General Rules for Sets and Elements
would still require adapting a transformation δ : θ =⇒ θj to θ[θ0] =⇒ θ[θ0]—but
only Γ ▶ reflidΓ : idΓ =⇒Γ idΓ (by above, θ[idΓ] equals θ). As above, the second
rule holds when id is in fact a projection, but the third requires that it really be the
identity. The interchange law relates 2-resp and transitivity: transitivity followed by 2-resp is the same as 2-resp followed by transitivity. It has a variety of useful special cases:

θ[δ ◦ δj] ≡ θ[δ] ◦ θ[δj]	1-resp preserves transitivities
(δ ◦ δj)[reflθ] ≡ δ[reflθ] ◦ δj[reflθ]	2-resp preserves transitivities

(δ : θ1 =⇒ θ2 )[δj : θj
=⇒ θj ] ≡ reflθ
[δj] ◦ δ[reflθ′ ] 2-resp interchange 1

(δ : θ1 =⇒ θ2 )[δj : θj =⇒ θj ] ≡ δ[reflθ′ ] ◦ reflθ
[δj] 2-resp interchange 2

1	2	2	1
The first two equations say that resp preserves transitivities. The next two state that a 2-resp is equivalent to holding one part fixed while doing one transformation, then holding the other fixed while doing the other—in either order. Returning to the figure, the rule delegate delegates 2-resp at reflexivity to 1-resp. The final three rules say that op preserves identities and compositions, reversing the order of composition in the case of transitivity.



Γop ▶ S : set
Γ , x :El (S )- ▶ S′ : set
Γ ▶ Π x :S . S′ : set
Γ ▶ S : set
Γ , x :El (S )+ ▶ S′ : set
 
Γ ▶ Σ x :S . S′ : set	Γ ▶ 0, 1, 2 : set

Γ ▶ S : set Γ ▶ M , N : El (A) Γ ▶ IdS M N : set



Γ ▶ M :Σ x :El (S ). El (S′)


Γ ▶ in M : El (Σ x :S . S′)
Γ ▶ M : El (Σ x :S . S′)


Γ ▶ out M :Σ x :El (S ). El (S′)

Γ ▶ M :Π x :El (S ). El (S′)


Γ ▶ in M : El (Π x :S . S′)
Γ ▶ M : El (Π x :S . S′)


Γ ▶ out M :Π x :El (S ). El (S′)


  
Γ ▶ () : El (1) Γ ▶ true : El (2) Γ ▶ false : El (2)
Γ± ▶ M : El (0)


Γ ▶ abort M : C
Γ± ▶ M : El (0)


Γ ▶ abort M : M1 =⇒C M2




Γ± ▶ M : El (2)
Γ ▶ M1 : C [true±/x ] Γ , x :2± ▶ C type
Γ ▶ M2 : C [false±/x ]


Γ ▶ ifx±.C (M , M1 , M2 ): C [M ±/x ]
Γ± ▶ M : El (2)
Γ , x :2± ▶ C type
Γ , x :2± ▶ M1 , M2 : C
Γ ▶ α1 : M1[true±/x] =⇒C[true±/x] M2[true±/x] Γ ▶ α2 : M1[false±/x] =⇒	±	M2[false±/x]

Γ ▶ ifx±.C (M , α1 , α2 ): M1[M ±/x] =⇒C[M ±/x] M2[M ±/x]


(Π x :S . S′)[δ : θ =⇒ θ′] ≡ x .in (mapΠ x :El (S ). El (S' ) δ (out M ))
(Σ x :S . S′)[δ : θ =⇒ θ′] ≡ x .in (mapΣ x :El (S ). El (S' ) δ (out M ))
IdS M N [δ : θ =⇒ θ′]  ≡ x .idi ٨


Fig. 8. 2DTT: Some Sets (1)
We do not define 2-subst, δ[θ], directly, as this composition is definable as δ[reflθ]. Alternatively, we could take δ[θ] as primitive and define δ[δj] using the interchange law. However, it is in fact no harder to define δ[δj], as the rules for the binary version also proceed compositionally in the term, just like ordinary substitution with a single θ would. This fact suggests that it may be possible to treat 2-resp as a meta-operation, which may be a helpful implementation technique.

Dependent Types
In Figure 2, we define identity and composition for dependent types, terms, and term transformations. A dependent type A can be pre-composed with a substitution, written A[θ]; and has a functorial action mapΔ.A δ M , which is the analogue of the subst elimination rule for propositional equality described above. map says that a



Rules for transformation elims for positives:

ifx.C (true, α1 , α2 ) ≡ α1	β
ifx.C (false, α1 , α2 ) ≡ α2
α[(reflM : 0 )±/x] ≡ abort M	η α[(reflM : 2 )±/x] ≡ if (M , α[refltrue/x ], α[reflfalse/x ])

(abort M )[δ : θ1 =⇒ θ2] ≡ abort M [θ2 ]	2-resp
if (M , α1 , α2 )[δ : θ1 =⇒ θ2] ≡ if (M [θ2 ], α1 [δ], α2 [δ])

Fig. 9. 2DTT: Some Sets (2)
transformation θ1 =⇒ θ2 allows a term of type A[θ1] to be coerced to a term of type A[θ2]. This says that dependent types respect transformation. We refer to these as 0-subst and 0-resp; there are no 0-subst/resp for contexts because contexts are not dependent.
The equations say: Substitution into types (0-subst) is associative with unit refl. map is functorial, preserving reflexivity and transitivity. The next two rules define 1-subst and 1-resp for map, which reassociate the 1-subst/1-resp with the 0-resp. The next rule defines map for a composition, again by reassociating.
Interactions between map and 2-resp are derivable from the above equations for transitivity, using the interchange law:


mapC (δ : θ1 =⇒ θ2 )[δj : θj =⇒ θj ] M ≡ mapC (δ[reflθ′ ]) (mapC reflθ
[δj] M )

1	2	2	1

mapC (δ : θ1 =⇒ θ2 )[δj : θj
=⇒ θj ] M ≡ mapC (reflθ
[δ]) (mapC δ[reflθ′ ] M )

The interchange rule, along with the following, form the Godement calculus of functors and natural transformation composition [18]:
(reflθ[θ′])[δ] ≡ reflθ[reflθ′ [δ]]
This rule is derivable because reflθ○θ′ ≡ reflθ[reflj ] by 1-resp-preserves-refl and asso-
ciativity.
There is also a right unit law for resp and reflid:
reflθ[reflid] ≡ reflθ
It is derivable using 1-resp preserves refl. and unit of id.

Terms
Like all contextual judgements, terms are closed under substitution (M [θ]) and respect transformation (M [δ]). Because terms are dependent on the context, the latter requires “adjusting” M [θ1] by δ so that it lives in the same type as M [θ2]. The equality rules are analogous to those for substitutions: 1-subst is associative and unital, and 1-resp is associative and preserves reflexivities.
An associativity rule for 1-subst followed by 1-resp in a term is derivable, using 1- resp-preserves-refl, congruence, and delegate and associativity for 2-resp (see below):
M [θ][δ] ≡ M [reflθ[δ]]	1-resp for M [θ]
Using interchange, we can derive that M preserves transitivities from the above interaction with 2-resp:
reflM [δ ◦ δj] ≡ reflM [δ] ◦ (resp (x.map δ x) (reflM [δj]))
Term Transformations
The rules for term transformations are entirely analogous to the rules for trans- formations, specifying reflexivity, transitivity, and 2-resp. The equations say that transitivity is associative and unital, that 2-resp is associative and unital, and that the order of trans and 2-resp can be interchanged. The interchange rule uses the derived form resp , which is explained below.

General equality rules
Figure 3 collects a variety of general equality rules: Each judgement, including equality, respects equality of its indices, and is a congruence.
Contexts
With the basic setup in hand, we are ready to define some concrete context formers. The general methodology for defining a context is to specify (1) A formation rule for Γ. (2) A substitution rule θ : Γ, and a hypothesis rule for one of the other judgements

(e.g. the term rule for x for the context former Γ , x :A+). These function as the introduction and elimination rules for the context, which are products of some sort, eliminated by first projections (which are implicit in id) and variables (representing projections). (3) A transformation rule for δ : θ =⇒Γ θj (4) Equations defining


βη βη for θ
βη βη for δ
0-involution Γop 1-involution θop 2-involution δop
identity idΓ 1-subst θ[θj] 1-resp	θ[δj]
reflexivity reflθ transitivity δ ◦ δj 2-resp	δ[δj]

In general, refl and δ ◦ δj are defined in a type-directed manner, by giving one rule that covers arbitrary arguments. On the other hand, the subst/resp principles are defined in a syntax-directed manner, giving one rule for each syntactic construct.
In Figure 3 and Figure 4 we carry out this methodology for the basic contexts:

Empty context
The empty context has a trivial substitution into it, and a trivial transformation from this substitution to itself. Since the substitutions and transformations are singletons, the equations are all trivial.

Covariant context extensions
Next, we present the rules for covariant context extension: if A is a type well- formed in Γ, then Γ can be extended with a variable of type A. A covariant variable can be used as a term; the typing rule checks that the variable is in the context:
x : A+ ∈ Γ
x : A+ ∈ (Γ, A+)	x : A+ ∈ (Γ , y :B±)
As with weakening, we do not include a rule for op, which can be expanded away. The substitution into an extended context Δ , x :A+ is a pair of a substitution θ into Δ and a term of type A, adjusted by θ (this is analogous to the usual intro- duction rule for a Σ-type). A transformation between such substitutions is a pair of transformations, one between the substitutions, and the other between the terms (adjusted by the first component). As these substitutions and transformations are pairs, the first set of rules gives the expected βη rules, for the projections given by id and variables. The next rules define the identity, composition, and involution operations componentwise. The involution rules turn covariant context extension into contravariant context extension, which is defined below.
The familiar resp congruence rule derives respect for the last variable in the context:
Γ ▶ α : M =⇒A N	Γ ▶ B type	Γ , x :A+ ▶ F : B
Γ ▶ resp F α : F [M/x] =⇒B F [N/x]
by resp F α = F [idid, α+/x]. This is well-typed because map id cancels.

We will also make use of the corresponding rule for map, a derived form for transforming the last variable in the context:
Γ, x :A+ ▶ B type Γ ▶ α : M1 =⇒A M2 Γ ▶ M : B [M1 +/x ]

Γ ▶ map1
x :A .B
α M : B [M2 +/x ]

This is defined by map1

+.B
α M = mapΓ,x :A+.B id, α+/x M .

Contravariant context extensions
Next, we present the rules for contravariant context extension: if A is a type well-formed in Γop, then Γ can be extended with a variable of type A. For the most part, these are analogous to covariant context extension, except for the following: First, there is no rule for using a contravariant variable. This is because we reduce contravariant terms to covariant terms using op, and using the rules for Γ , x :A-op, a contravariant variable becomes a covariant variable. Second, the transformation rule reverses the order of M and N in the premise. Third, various op’s are inserted on substitutions and transformations to make the types work out.
A contravariant last-variable map rule is also definable:
Γ, x :A- ▶ B type Γop ▶ α : M2 =⇒A M1 Γ ▶ M : B [M1 -/x ]
Γ ▶ map1 -	α M : B [M2 -/x ]
x :A .B
by map1 -	α M = mapΓ,x :A-.B (id, α-/x) M .
x :A .B

Types
With contexts in hand, we can move on to types and terms. In general, a type is specified by (1) A formation rule for A. (2) Introduction and elimination term rules, defining M : A. (3) Introduction and elimination transformation rules, defining α : M =⇒A Mj. (4) Equations defining


1-βη βη for M

substitution A[θ]
substitution M [θ]
reflexivity reflM
transitivity α ◦ αj

βη βη for α
0-resp	mapA δ M  1-resp	M [δ]
2-resp	α[δ]


Dependent functions
In Figure 5, we give the rules for dependent functions. The formation rule is standard, except that the domain is well-formed contravariantly in Γ, and thus assumed as a contravariant assumption. The intro and elim rules then insert the appropriate op’s. The transformation introduction rule says that a transformation at Π can be introduced by giving a family of transformations that work for each element—the extensionality rule. A transformation is eliminated by applying to transformable arguments. The symmetric variants of these transformation rules, and the equations for them described below, have been considered in prior categorically- motivated accounts of functionally extensional propositional equality [17].

The βη-rules are the expected rules for functions, both at the term and trans- formation levels. We write M [N/x] to abbreviate M [id, N/x]. Substitution into a Π-type proceeds compositionally, though we always op the substitution in con- travariant positions. mapΠ x :A. B is given by pre- and post-composition. Note that the definition of transformation at Δ, x : A- is just right so that δ, refl works as the post-composition. 1-subst and 1-resp are both defined compositionally, as is 2-resp. The rule for refl says that the identity at all elements is the identity. In the definition of transitivity, we again cheat by assuming the transformations are in introductory form, which makes sense because of η, but we could equivalently use the elimination rule instead.

Dependent pairs
The rules for Σ-types are mostly unsurprising, essentially a contextualized ver- sion of the rules for covariant context extension. The formation rule is analogous to Π, but the first component is well-formed covariantly, and the typing of the sec- ond component uses covariant context extension. The term rules are standard; the transformation rules say that a transformation between a pair is a pair of transfor- mations. map is defined componentwise; in this case, the definition of transformation at Δ, x : A+ is just right so that δ, refl works as the second component. The βη-rules are standard, and the substitution rules are all defined compositionally. Identity and composition are defined componentwise.

Sets and elements
As our first example of a base type with non-trivial transformations, we consider a universe set that contains discrete types. That is, each term S : set will represent a type El(S) whose elements have no non-identity transformations between them. However, set itself is not a discrete type: we take a transformation from S to Sj to be a function from El(S) to El(Sj). Consequently, any type s : set ▶ C type will admit a lifting of a function from El(S) to El(Sj) to a transformation from C[S/s] to C[Sj/s]. This is the common functor interface used in many programming languages. This universe of sets is extensional, in that transformation at sets satisfies equality reflection and definitional uniqueness of identity proofs—one can work with these sets as one would work in extensional type theory.
We populate the types El(S) determined by a universe by giving inference rules for the members of these types. It is simpler to specify a set, than a type, because the transformations between elements are always only reflexivity. A set is specified by: (1) A formation rule for S : set, with equations for (2) 1-substitution S [θ] and 1-resp S [δ]. (3) Terms defining M : El(S), as well as equations defining βη-rules, 1-substitution, and 1-resp. The equations for 1-resp for each S define the functorial action of the set former—which is used by map.
Sets and Elements. In Figure 7, we present the generic rules that apply to all sets: set is a type, as is El(S) if S has type set. A transformation at set is a function from the elements of one to the elements of the other. The only transformation

between elements of sets is reflexivity, and such transformations are eliminated by equality reflection.
The first equation says that the 1-resp action of elements of sets is an equality, which is true because El(S) is a discrete type: if M : El (S ) then M takes trans- formable arguments to equal results. The next two equations η-expand a transfor- mation at set into a map, and a transformation at El(S) into reflexivity. The rules for 0-subst are compositional.
map at set is a no-op, because set is a constant functor. map at El(S) applies the function (open term) given by 1-resp of S, S [δ]. We will give rules for each set- former defining S [δ]. Reflexivity and transitivity are defined in the expected way for sets, and trivially for elements. The 2-resp rule for set says that a function x .M respects a transformation δ by running M at the source and then applying δ. The 2-resp rule for El(−) is analogous to delegate.
Basic Sets: Rules. In Figures 8 and 9, we present the rules for some basic sets: Π, Σ, 0 (the empty set), 1 (the unit set), 2 (booleans), and Id (identity between two elements of a set). In symmetric type theory, given Γ and Γ ▶ A type and Γ ▶ M , N : A, one can define a type Γ ▶ IdA M N type, whose functorial action on an equality δ : IdΓ θ1 θ2 is given by pre-composition with an equality determined from M [δ] and post-composition with an equality determined from N [δ]. However, this construction uses symmetry: the precomposition needs to be with with (M [δ])—1. In the directed setting, this is not necessarily possible, which motivates the judge- mental approach to transformations that we take in this paper. However, when A is in fact groupoidal, one can internalize transformations as an identity type, whose functorial action is given as in symmetric type theory. The type IdS M N defined here is a special case where El(S) is discrete, and therefore trivially groupoidal. A more general alternative would be to consider a directed Hom-type, whose first argument is a contravariant position, which internalizes the notion of a dinatural
transformation. However, the syntactic rules for such a type require further study.
The rules for Π and Σ express that they are isomorphic to Π/Σ types of discrete elements. In fact, the domain of a Π need not be restricted to a set: Π x :A. S is a set even if A is higher-dimensional. However, in our present theory types are both higher-dimensional than sets, and of higher size than sets: set itself is a type. So such a quantifier would not only be higher-dimensional, but impredicative. If additionally we had a universe typ of small types, then it would be appropriate to allow Π’s to range over A : typ.
0, 1, 2 are introduced by the usual rules. The elimination rules for 0 and 2 have one subtlety: they allow elimination of both co- and contravariantly well-formed terms—we abbreviate a choice between Γ and Γop by Γ±. The reason for this is that the natural deduction rules for positive types build in a cut, and the appropriate notion of cut includes both co- and contra-variant cut formulas (cf. the fact that substitutions allow for both co- and contravariant variables). These types can also be eliminated towards transformation judgements, so we add rules for eliminating El(0) and El(2) towards M =⇒A N .
The rules for the identity type express an isomorphism with the corresponding

term transformations.
Basic Sets: Equalities. 1-subst into each set is as expected. 1-resp is the identity for constant sets, defined in terms of Π and Σ types for Π and Σ, and computation- ally trivial for identity (the verification that the right-hand-side is well-typed uses symmetry of equality). Next, in Figure 9, the βη rules express the isomorphisms for Π and Σ and Id, and the usual equations for 0,1,2. 1-subst (and 2-resp for ide ) are defined compositionally. The 1-resp rules are computationally trivial, but the fact that they are well-typed is interesting: e.g. the rule for in M requires showing that if two terms are transformable at Σ x :El (S ). El (Sj) then they are equal—which is true because the transformation provides equalities of each component. The 1-resp rule for if uses the transformation elimination form for booleans. The remaining rules state that the rules eliminating 0, 1, 2 towards transformations satisfy similar βη and 2-resp laws.

Semantics
In this section, we sketch a semantics of 2DTT in Cat, the 2-category of categories, functors, and natural transformations, referring the reader to FIXMEChapter 7]li- cata11thesis for details.
The intuition for this interpretation is that a context, or a closed type, is in- terpreted as a category, whose objects are the members of the type, and whose morphisms are the transformations between members. Thus, a substitution (an “open object”) is interpreted as a functor—a family of objects that preserves trans- formations. A transformation (an “open morphism”) is interpreted as a natural transformation—a family of morphisms that respects substitution. More formally, the context, substitution, and transformation judgements are interpreted as follows: [Γ]] is a category. [[Γ ▶ θ : Δ ] is a functor [[θ]]: [[Γ ] −→ [[Δ ]. [[Γ ▶ δ : θ1 =⇒Δ θ2]] is
a natural transformation [[δ]]: [[θ1]] =⇒ [[θ2]]: [[Γ ] −→ [[Δ ].
The judgement Γ ▶ A type represents an open type. Correspondingly, it should be interpreted as a functor that assigns a closed type to each object of Γ, preserving transformations. Since closed types are represented by categories, this is modeled by a functor [[A]]: [[Γ ] −→ Cat. Here we take Cat to be the category of large categories, to interpret the type set.
As a notational convention, we will overload notation so that the semantics looks just like the syntax: First, we use the same letter for a piece of syntax and for the semantic concept it is interpreted as; e.g. we will write Γ for a category, θ for a functor, A for a functor into Cat, etc. Second, we use the same symbols as we use in the syntax for the 2-category structure on Cat: we write the identity functor as id, functor composition as θ[θj], vertical composition of natural transformations as δ ◦δj, horizontal composition as δ[δj], and the identity natural transformation as idθ, and the action of op as Γop, etc. Additionally, we abbreviate Γ −→ Cat by Ty Γ.
The set of terms Γ ▶ M : A is isomorphic to the one-element substitutions
Γ ▶ id, M +/x : Γ , x :A+, and Γ , x :A+ is interpreted as the total category of the
Grothendieck construction, ∫ A, with projection map p : ∫ A −→ Γ. Thus, we can

define the interpretation of a term Γ ▶ M : A to be a functor [[M ]] : Γ −→ ∫

[[Γ]]
[[A]]

such that the Γ part of the functor is the identity—which we can formalize by saying that [[M ]] is a section of p: p ◦ [[M ]] = id. However, following FIXME, it is more convenient to use an equivalent explicit definition:
Definition 3.1 For a category Γ and a functor A :Γ −→ Cat, the set of terms over
Γ of type A, written Tm Γ A, consists of pairs (Mo, Ma) such that
For all γ ∈ Ob(Γ), Mo(γ) ∈ Ob(A(γ))
For all c : γ1 −→Γ γ2, Ma(c) : A(c)(Mo(γ1)) −→A(γ2) Mo(γ2).	Moreover,
Ma(id)= id and Ma(c2 ◦ c1)= Ma(c2) ◦ A(c)(Ma(c1)).
Similarly, we define the semantic counterpart of Γ ▶ α : M =⇒A N :
Definition 3.2 Given a category Γ, A : Ty Γ, and M , N : Tm Γ A,a dependent nat- ural transformation α : M =⇒ N consists of a family of maps αγ such that
for γ ∈ Ob(Γ), αγ : M (γ) −→A(γ) N (γ)
for c : γ1 −→Γ γ2, N (c) ◦ A(c)(αγ1 ) = αγ2 ◦ M (c)
The interesting part of the interpretation is showing that each inference rule is true: given the semantic domains corresponding to the premises, we can construct the semantic domain corresponding to the conclusion. Once we have defined the operations, we can validate each equation on the semantic counterparts of the terms in question. Taken together, these constructions and proofs represent the inductive steps of the interpretation. Then, we tie these pieces together with a soundness theorem, which is described in technical detail in FIXME.
Theorem 3.3 Soundness. There are total functions [[−]] that for each derivation
D :: J yield a semantic entity of type [[J ]], validating the definitional equalities.
We describe the inductive steps here:


Involution, Identity, and Composition
The involutions are interpreted by the 2-functor −op : Cat −→ Catco which sends each category to its opposite category. Γop is the action on objects; θop is the action on 1-cells; and δop is the action on 2-cells. The identity and composition principles for substitutions and transformations are interpreted as the identity, hori- zontal composition, and vertical composition operations of the 2-category Cat. The equations for them follow from the definition of a 2-category. A type is interpreted as a functor, and A[θ] as functor composition. map is an instance of whiskering a functor (into Cat) with a natural transformation, which can be thought of as the functorial action of the type on the transformation. It is simple to check that a term Tm Δ A and a functor Γ −→ Δ can be composed as indicated by M [θ]. Seman- tic identity and vertical and horizontal composition for term transformations are

defined as follows:
(reflM )σ = reflM(σ)
(α2 ◦ α1)σ = α2σ ◦ α1σ
(α[δ])σ = N (δσ) ◦ A(c)(α(θ(σ)))
In the final equation, we use N and A and θ as in the typing rule for the left-hand side.

Interpretation of Contexts
The empty context is interpreted as the category 1, which has one object and its
identity morphism. Γ , x :A+ is interpreted by the Grothendieck construction ∫ A.
Γ , x :A- is interpreted as (∫ op A)op.
Γ


Interpretation of Types
Π-types are defined as in FIXME: we follow their construction, checking that everywhere they depend on symmetry of equality, we have inserted the appropriate op’s. For a category Γ and a A : Ty Γop, we abbreviate semantic contravariant context
extension (∫ op A)op by Γ.A-. Given a B : Ty Γ.A- and an object σ ∈ ObΓ, we define
Bσ : Ty A(σ) by
(Bσ)(σj)= B(σ, σj)
(Bσ)(c)= B(idσ, c)
For any Γ and A, the Tm Γ A are the objects of a category with morphisms given by term transformations α. This lets us define a Π type as follows:
(Π A B)σ = Tm A(σ)op Bσ
Functoriality is given by pre- and post-composition: the contravariance of A en- sures that the pre-composition faces the right direction. λ and application and βη rules are interpreted by giving a bijection between Tm Γ.A- B and Tm Γ ΠAB. The transformation intro and elim and βη rules express a bijection between
M =⇒ N :Γ −→ ΠAB and M v =⇒ N v : Γ.A- −→ B , where v : Tm (∫ A) (A[p]) is
defined by second projection from ∫ A. The proof follows	Γ Section 5.3,
FIXME,
which observes that the groupoid interpretation justifies functional extensionality.
Because both subcomponents of Σ x :A. B are covariant, the interpretation given in FIXME adapts to our setting unchanged.
The type set is interpreted as the constant functor returning Sets, the category of sets and functions. Because the action on morphisms of a constant functor is the identity, Tm Γ set is bijective with Γ −→ Sets. Thus, we can represent El(S) semantically by discrete ◦ S. As usual, we overload notation and write El(S) for discrete ◦ S. The transformation rule for set expresses (half of) an isomorphism
between, on the one hand, natural transformations between two functors into Sets,
and, on the other, terms Tm (∫ (El(S))) (El(Sj)), which is given by currying.

More details on this soundness theorem, including the interpretation of particular sets and the outer induction that ties it all together, is described in FIXME.

Applications and Extensions
Dependently Typed and Mixed Variance Syntax
First, we explain how 2DTT can be deployed to generalize the functorial approach to syntax [20,14,3] to dependently typed and mixed variance syntax. These examples are discussed in more detail in [24, Chapter 8].

Dependently Typed Syntax
To illustrate the approach to representing dependently typed syntax, we repre- sent a judgement Ψ ▶ A as a type nd Ψ A, where the proposition A can mention the variables in Ψ. Stating the structural properties for such judgements is tricky, because the substitution into the derivation must prove the substitution into the type: substitution maps derivations of Ψ ▶ A to derivations of Ψj ▶ A[θ], given a substitution θ from Ψ to Ψj.
First, we define a type Ctx representing object-language contexts Ψ. For example, if the variables in Ψ are unsorted then the terms of type Ctx could be natural numbers, with variables represented by inhabitants of fin(Ψ)—numbers less than Ψ—
i.e. we use dependent de Bruijn indices [9,8]. Transformations at Ctx are taken to be substitutions Ψ ▶ Ψj, which are chosen to give the desired structural properties. For example, representing substitutions by a function fin(Ψj) → fin(Ψ) gives weakening, exchange, and contraction, but not substitution; term-for-variable substitutions give substitution as well.
Next, we represent propositions by a set
Γop ▶ Ψ: Ctx Γ ▶ propo Ψ: set
This typing says that propositions are contravariantly functorial in Ψ, meaning that
w :Ψ =⇒Ctx Ψj	φ : propo Ψj (mapψ-.propo ψ (w -/ψ) e): propo Ψ
Moreover, the functoriality equations for map stipulate that renaming by the identity is the identity, weakening by a composition is composition of the renamings, and so on. We will sometimes abbreviate mapψ-.propo ψ w -/ψ e by map w e when the meaning is clear from context.
Finally, we represent natural deduction derivations by a type
Γop ▶ Ψ: Ctx	Γ ▶ φ : propo Ψ Γ ▶ nd Ψ φ : set

The type-generic rule for map specializes to the appropriate renaming principle:
s :Ψ =⇒Ctx Ψj	e : nd Ψj φ
(mapψ-,a+.nd ψ a (s-/ψ, id+/a) e): nd Ψ (map s φ)
As desired, this principle says that the renaming/substitution into the derivation proves the renaming/substitution of the judgement. Thus, 2DTT’s notion of trans- formation at a Σ-type naturally accounts for the structural properties of dependently typed syntax.

Mixed Variance
2DTT also accounts for mixed variance syntax, which mixes admissibility and derivability [26,25]—such as a logic with the infinitary ω-rule for eliminating natural numbers. For example, in the rule
Ψ ▶ P (0)	Ψ ▶ P (1)	... 
Ψ ▶ ∀x.P (x)
the infinitely many premises may be thought of as a function that yields P (n) for each n, likely defined by induction. This will be encoded in 2DTT as a datatype constructor
omega : (Π n:nat. nd Ψ (subst P n)) → nd Ψ (all P )
where subst substitutes n for the last variable in P , and is defined using map. This datatype constructor can be used in existing dependent type theories. The advantage of 2DTT is that we can obtain the structural properties for free even for a logic with such a rule, because Π is equipped with a functorial action given by pre- and post- composition.
Extensions
Putting the above ideas into practice will require some interesting extensions of 2DTT: To define higher-dimensional types such as set and Ctx, we require an ana- logue of quotient types, where programmers specify a type by giving an internal category —a description of a category inside the theory. To define types such as propo and nd internally to the theory, we require an inductive datatype mechanism, adapting W -types [29] or indexed containers [2].
The connection between functorial syntax and higher-order abstract syntax is that in the category of presheaves, the exponential expexp : Ctx → Sets is isomorphic to the type family exp(− + 1) which adds an extra de Bruijn in- dex [14,20]. We can reproduce this result in 2DTT, but the exponential is not the contravariant Π we have considered so far, but a second, covariant, Πco. A term ψ : Ctx ▶ M : exp ψ →co exp ψ, is explicitly parametrized over extensions in ψ (c.f. the Kripke interpretation of implication) and its functorial action is given by composing transformations—not by pre- and post-composition. This permits the argument position of a function to be treated as a covariant position, internalizing an assumption x : A+.

Given these extensions, which are described in more detail in FIXMEChapter 8]licata11thesis, 2DTT will afford an extremely general logical framework, in which programmers can specify logics using dependently typed and mixed-variance defini- tions, and automatically obtain implementations of the structural properties derived from the generic notion of functoriality built in to the calculus.
Another interesting avenue for future work is an Aop modality on types, given by the point-wise opposite of A, which may be useful for internalizing a directed Hom type, as discussed above. We also plan to consider generalizations to dimensions higher than 2, which will expose connections with weak ω-categories and directed homotopy theory, and to recover undirected type theory as a special case of directed type theory, by defining a universe of groupoids. On the semantic side, it will be interesting to consider semantics in 2-categories other than Cat.



Related Work
Of the many categorical accounts of Martin-Löf type theory [19], our approach to the semantics of 2DTT most closely follows the groupoid interpretation [21]. Recent work connecting (symmetric) type theory with homotopy theory and higher- dimensional category theory [17,27,35,4,37,15,36] will be useful in generalizing 2DTT to additional models and higher-dimensions. An early connection between λ-calculus and 2-categories was made by FIXME, who shows that simply-typed λ-calculus forms a (non-groupoidal) 2-category, with terms as 1-cells and reductions as 2-cells. Functoriality of simple and polymorphic type constructors has been studied in previous work on generic traversals of data structures [23,7] and compilation of sub- typing [12]; our work generalizes this to the dependently typed case. In tactic-based proof assistants, it is possible to construct a library of tactics for showing that types and terms respect equivalence relations and order relations, such as Jackson’s library for NuPRL [22] and setoid rewriting in Coq [11]. Our approach here is akin to build- ing these tactics into the language, equipping every type and term with an action on transformations. This allows the computational content and equational behavior of these actions to be drawn out. Another application of functors in dependent type theory is indexed containers [2,16], a mechanism for specifying inductive families. Whereas we associate a functorial action with every type constructor, containers are deliberately restricted to strictly positive functors, which are useful for speci- fying datatypes. Also, 2DTT allows types indexed by an arbitrary category, but a
container denotes a type indexed by a set.
Variance annotations on variables are common in simply-typed subtyping sys- tems [13,10,34]. In the dependently typed case, variance annotations have been used to support termination-checking using sized types, as in MiniAgda [1].
Many systems support programming with dependently typed abstract syn- tax [30,31,32]; 2DTT will enable us to go beyond this previous work by generating the structural properties automatically for mixed-variance definitions.

Conclusion
We introduce directed type theory, which equips types with an asymmetric notion of transformation between their elements. Examples include a universe of sets with functions between them, and a type of variable contexts with renamings or sub- stitutions between them. We show that the groupoid interpretation of type theory generalizes to the directed case, giving our language a semantics in Cat. We have dis- cussed an application to dependently typed and mixed variance syntax, and sketched some exciting avenues of future work.
Finally, we speculate on some additional applications of our theory. First, we may be able to recover existing examples of directed phenomena in dependent type systems, such variance annotations for sized types [1], implicit coercions [6], and coercive subtyping [28]. For example, we may consider a translation of coercive subtyping into our system, using functoriality to model the lifting of a coercion by the subtyping rules. Because uses of map are explicit, our approach additionally supports non-coherent systems of coercions, and it will be interesting to explore applications of this generality; but the coherent case may provide a guide as to when instances of map can be inferred. Second, directed type theory may be useful as a meta-language for formalizing directed concepts, such as reduction [33], or category theory itself. Third, directed type theory may be useful for reasoning about effectful programs or interactive systems, which evolve in a directed manner (FIXME connects homotopy theory and concurrency). For example, we could define a type of interactive processes with transformations given by their operational semantics, or a type of processes with the transformations given by simulation.

Acknowledgement
We thank Steve Awodey, Peter Lumsdaine, Chris Kapulkin, Kristina Sojakova, and Thorsten Altenkirch for helpful conversations about this work.

References
Abel, A., Miniagda: Integrating sized and dependent types, in: A. Bove, E. Komendantskaya and
M. Niqui, editors, Workshop on Partiality And Recursion in Interative Theorem Provers, 2010.
Altenkirch, T. and P. Morris, Indexed containers, in: IEEE Symposium on Logic in Computer Science
(2009), pp. 277–285.
Altenkirch, T. and B. Reus, Monadic presentations of lambda terms using generalized inductive types, in: CSL 1999: Computer Science Logic (1999).
Awodey, S. and M. Warren, Homotopy theoretic models of identity types, Mathematical Proceedings of the Cambridge Philosophical Society (2009).
Baez, J. C. and M. Shulman, Lectures on n-categories and cohomology (2007), available from http:
//arxiv.org/abs/math/0608420v2.
Barthe, G., Implicit coercions in type systems, in: International Workshop on Types for Proofs and Programs (1996), pp. 1–15.
Bellè, G., C. Jay and E. Moggi, Functorial ML, in: H. Kuchen and S. Doaitse Swierstra, editors, Programming Languages: Implementations, Logics, and Programs, Lecture Notes in Computer Science 1140, Springer Berlin / Heidelberg, 1996 pp. 32–46.

Bellegarde, F. and J. Hook, Substitution: A formal methods case study using monads and transformations, Science of Computer Programming 23 (1994), pp. 287–311.
Bird, R. S. and R. Paterson, De Bruijn notation as a nested datatype, Journal of Functional Programming 9 (1999), pp. 77–91.
Cardelli, L., Notes about F ω (1990), unpublished.
Coq Development Team, “The Coq Proof Assistant Reference Manual, version 8.2,” INRIA (2009), available from http://coq.inria.fr/.
Crary, K., Typed compilation of inclusive subtyping, in: ACM SIGPLAN International Conference on Functional Programming, 2000.
Duggan, D. and A. Compagnoni, Subtyping for object type constructors, in: Workshop On Foundations Of Object-Oriented Languages, 1999.
Fiore, M., G. Plotkin and D. Turi, Abstract syntax and variable binding, in: IEEE Symposium on Logic in Computer Science, 1999.
Gambino, N. and R. Garner, The identity type weak factorisation system, Theoretical Computer Science
409 (2008), pp. 94–109.
Gambino, N. and M. Hyland, Wellfounded trees and dependent polynomial functors, in: Types for Proofs and Programs, Springer LNCS, 2004 pp. 210–225.
Garner, R., Two-dimensional models of type theory, Mathematical. Structures in Computer Science 19
(2009), pp. 687–736.
Godement, R., “Théorie des faisceaux,” Hermann, Paris, 1958.
Hofmann, M., Syntax and semantics of dependent types, in: Semantics and Logics of Computation
(1997), pp. 79–130.
Hofmann, M., Semantical analysis of higher-order abstract syntax, in: IEEE Symposium on Logic in Computer Science, 1999.
Hofmann, M. and T. Streicher, The groupoid interpretation of type theory, in: Twenty-ﬁve years of constructive type theory (1998).
Jackson, P., The nuprl proof development system (version 4.2) reference manual and user’s guide
(1996), available from http://www.nuprl.org/documents/Jackson/Nuprl4.2Manual.html.
Laemmel, R. and S. Peyton Jones, Scrap your boilerplate: a practical approach to generic programming, in: ACM SIGPLAN-SIGACT Symposium on Types in Language Design and Implementation, 2003.
Licata, D. R., “Dependently Typed Programming with Domain-Specific Logics,” Ph.D. thesis, Carnegie Mellon University (2011), available from http://www.cs.cmu.edu/~drl/pubs/thesis/thesis.pdf.
Licata, D. R. and R. Harper, A universe of binding and computation, in: ACM SIGPLAN International Conference on Functional Programming, 2009.
Licata, D. R., N. Zeilberger and R. Harper, Focusing on binding and computation, in: IEEE Symposium on Logic in Computer Science, 2008.
Lumsdaine, P. L., Weak ω-categories from intensional type theory, in: International Conference on Typed Lambda Calculi and Applications, 2009.
Luo, Z., Coercive subtyping, Journal of Logic and Computatio 9 (1999).
Nordström, B., K. Peterson and J. Smith, “Programming in Martin-Löf’s Type Theory, an Introduction,” Clarendon Press, 1990.
Pfenning, F. and C. Schürmann, System description: Twelf - a meta-logical framework for deductive systems, in: H. Ganzinger, editor, International Conference on Automated Deduction, 1999, pp. 202– 206.
Pientka, B., A type-theoretic foundation for programming with higher-order abstract syntax and ﬁrst- class substitutions, in: ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, 2008, pp. 371–382.
Poswolsky, A. and C. Schürmann, Practical programming with higher-order encodings and dependent types, in: European Symposium on Programming, 2008.


Seely, R., Modeling computations: a 2-categorical framework, in: IEEE Symposium on Logic in Computer Science, 1987, pp. 65–71.
Steffen, M., “Polarized Higher-Order Subtyping,” Ph.D. thesis, Universitaet Erlangen-Nuernberg (1998).
van den Berg, B. and R. Garner, Types are weak ω-groupoids (2010), available from http://www.dpmms. cam.ac.uk/~rhgg2/Typesom/Typesom.html.
Voevodsky, V., The equivalence axiom and univalent models of type theory (2010), available from
http://www.math.ias.edu/~vladimir/Site3/home_files/.
Warren, M. A., “Homotopy theoretic aspects of constructive type theory,” Ph.D. thesis, Carnegie Mellon University (2008).
