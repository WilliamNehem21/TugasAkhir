

Electronic Notes in Theoretical Computer Science 265 (2010) 389–402
www.elsevier.com/locate/entcs

Modelling Local Variables: Possible Worlds and Object Spaces
Guy McCusker 1,2 John Power3
Department of Computer Science University of Bath
Bath BA2 7AY, United Kingdom

Abstract
Local variables in imperative languages have been given denotational semantics in at least two fundamentally different ways. One is by use of functor categories, focusing on the idea of possible worlds. The other might be termed event-based, exemplified by Reddy’s object spaces and models based on game semantics. O’Hearn and Reddy have related the two approaches by giving functor category models whose worlds are object spaces, then showing that their model is fully abstract for Idealised Algol programs up to order two. But the category of object spaces is not small, and so in order to construct a functor category that is locally small, and hence Cartesian closed, they need to work with a restricted collection of object spaces. This weakens the connection between the object spaces model and the functor-category model: the Yoneda embedding no longer provides a full embedding of the original category of object spaces into the functor- category. Moreoever the choice of the restricted collection of object spaces is ad hoc. In this paper, we refine the approach by proving that the finite objects form a small dense subcategory of a simplified object-spaces model. The functor category over these finite objects is therefore locally small and Cartesian closed, and contains the object-spaces category as a full subcategory. All this work is necessarily enriched in Cpo. We further refine their full abstraction result by showing that full abstraction fails at order three.
Keywords: Denotational semantics, programming languages, imperative programming, algol-like languages, local state, possible worlds, category theory.


Introduction
Over recent decades, there have been at least two major ways in which local variables in imperative languages have been given denotational semantics. One approach, developed in particular by O’Hearn and Tennent, building heavily upon the work of others such as Oles, has been based on functor categories: one constructs a small category W of worlds and models the language in the functor category SetW or perhaps in CpoW to include recursion. The various small categories W of worlds

1 This document in an output from the PMI2 Project funded by the UK Department for Innovation, Universities and Skills (DIUS) for the benefit of the Japanese Higher Education Sector and the UK Higher Education Sector. The views expressed are not necessarily those of DIUS, nor British Council.
2 Email: G.A.McCusker@bath.ac.uk
3 Email: A.J.Power@bath.ac.uk

1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.08.023

have gradually become of increasing sophistication in order to model increasingly sophisticated features of local variables, as outlined in the collection of articles [13]. The other approach we have in mind here has been that most associated with Reddy [14]. He developed object spaces to model interference-controlled Algol, recording the behaviour of stateful objects using traces. Reddy’s model has been an important precursor of the game semantics of imperative programs [1,2], which provided the first fully abstract models of Idealised Algol. These models were not given by functor categories but rather directly in terms of natural but sophisticated
structures on sets.
This leaves the question whether the two approaches can be unified. O’Hearn and Reddy made a start on that question in [12], providing a fully faithful em- bedding of a variant of Reddy’s category into a functor category, and describing a model of Idealised Algol in that category. Although a substantial step forward, that still leaves a substantial step, indeed from a category-theoretic perspective, a fundamental step, unresolved. Specifically the problem is one of size: Reddy’s category is locally small but not small. If, as O’Hearn and Reddy do, one makes an ad hoc restriction to a small subcategory, one loses fundamental category-theoretic structure such as completeness and cocompleteness properties. But if one starts with a category W that is not small, then the functor category SetW typically will not be locally small, again causing major disruption, for instance not allowing one to conclude cartesian closedness.
We resolve that difficulty in this paper. Specifically, we address it by the study of density: a small full subcategory D of a category C is dense if a canonical functor embeds C fully into the functor category SetD, which is necessarily locally small. Density is a fundamental notion within category theory [7] and its use brings us to a very satisfactory situation: we have a functor-category model of Idealised Algol, an object-spaces model of interference-controlled Algol with no unnatural size restriction, and a full embedding between them. There is one complication with this: we provably need not just density but an enriched version of density, with enrichment in the category Cpo. We provide a counter-example to show that ordinary density is insufficient in Section 5, then show that we have the Cpo- enriched density we seek. The enriched notion of density is a standard part of enriched category theory [6].
Our work is not a direct refinement of O’Hearn and Reddy’s, because we do not work with the original formulation of the category of object spaces, but with a sim- plification of it, along the lines developed in [8,10], which abandons the coherence- space structure exploited by Reddy. The resulting category of worlds has the ad- vantage of being simpler to describe than Reddy’s category: it is the category of free quantales over finite sets. It nevertheless gives rise to the same model of interference- controlled Algol as Reddy’s category, and the functor-category possesses the same full abstraction properties as claimed in O’Hearn and Reddy’s work.
As an additional contribution, we refine O’Hearn and Reddy’s full abstraction result. In their paper, it was shown that the functor-category model was fully abstract up to order two, that is, that for terms of order two and below, equality

in the model coincides with contextual equivalence in an appropriate operational semantics. Their argument for full abstraction carries almost directly over to our model. We give a counterexample to full abstraction at order three, showing that this result is as far as one can go.

Two Algol-like Languages
This section briefly presents the syntax of a version of Idealised Algol, and its interference-controlled variant. We omit details of the operational semantics, which may be found in the literature; O’Hearn and Tennent’s edited collection of articles is particularly useful [13].
The languages are built over three base types: comm, the type of commands; nat, the type of natural-number valued expressions; and var, the type of assignable variables. Idealised Algol itself is an applied simply-typed lambda-calculus over these base types. Its types are therefore generated from the base types via product and function operations, and its syntax is that of the lambda-calculus together with a stock of constants for imperative programming with recursion, as follows.


0 : nat
succ : nat → nat
pred : nat → nat
ifzeroB : nat × B × B → B
YA : (A → A) → A
skip : comm
assign : var × nat → comm
deref : var → nat
seqB : comm × B → B
while : nat × comm → comm
new : (var → comm) → comm
mkvar : (nat → comm) × nat → var

where B ranges over base types and A over all types.
The constants in the left column provide for arithmetic and recursion, just as in PCF for example. The remainder provide a language of imperative programs: skip is the do-nothing command; assign(V, N ) stores the value of expression N in variable V ; deref(V ) returns the value stored in V ; seq(C, M ) executes command C and then evaluates M — note that the variant where B is comm is the familiar sequential composition of commands, while the others allows expressions of type nat or var to have side-effects on the store; while(M, C) repeatedly executes C until M becomes non-zero; ifzeroB provides for conditional branching; and new(λx : var.C) executes command C in an environment where identifier x has been bound to a fresh memory cell. Finally mkvar is a “variable constructor” which builds an expression of type var out of a “write-method” of type nat → comm and a “read method” of type nat. This object-oriented view of variables was proposed by Reynolds in his paper The Essence of Algol [16] and is by now standard. Indeed, some presentations including that of O’Hearn and Reddy go as far as identifying var with the product type (nat → comm) × nat. It has been shown that the presence of mkvar makes no difference to the notion of program equivalence in this language [9].
Interference-controlled Algol consists of the affine lambda-calculus, with prod-

ucts, over the same base types, with the same stock of constants, except that Y is excluded. The affine lambda-calculus restricts function application so that function and argument cannot share any identifiers. This leads to a situation in which dis- tinct identifiers can never be bound to interfering program phrases, which makes program analysis more straightforward and was Reynolds’s motivation for introduc- ing the restricted language in Syntactic Control of Interference (SCI) [15]. The SCI type system was later refined by O’Hearn et al. [11], but we focus on the basic sys- tem here. Note that in this system, the two components of a product may still share identifiers and thus interfere, so the typing of constants such as while means that executing the body of a loop may have an impact on future execution of the guard. This is of course essential if one is to retain any interesting imperative programs.
These two languages can be equipped with an operational semantics, given in terms of stores: functions from locations to natural numbers. The operational semantics consists of judgements s, M ⇓ s',N , stating that term M in store s evaluates to term N , altering the store to s'. Terms M and M' are contextually equivalent if, for every context C[−] such that C[M ] and C[M'] are closed terms of type comm, C[M ] ⇓ skip if and only if C[M'] ⇓ skip; there are no stores in these judgements because closed terms operate in empty stores.

Object spaces (simplified)
Reddy’s object spaces model of interference-controlled Algol [14] was the first to in- terpret higher-order imperative programs not using functions from starting states to finishing states, but by recording the behaviour of stateful objects using traces. As such, it is an important precursor of the game semantics of imperative programs[1,2] which were the first fully abstract models of Idealised Algol. Perhaps more surpris- ingly, Reddy’s model is itself fully abstract for interference-controlled Algol, though this was not known until more recently [8]. In this section we present a simplified version of Reddy’s category, which does away with the coherence relation at the ex- pense of allowing nondeterminism into the model. Nondeterminism is a conservative extension of Idealised Algol, in both its regular and interference-controlled flavours, so this makes no difference to our results on full abstraction, while simplifying the technical details considerably.
Let A, B and C be sets. We use PA to denote the power-set of A, and A∗ for the set of finite sequences drawn from A. Let f : A → PB∗ and g : B → PC∗ be any functions. Define the composite g ◦ f : A → PC∗ as follows. For any a ∈ A, (g ◦ f )(a) is the set
{s1 ··· sn | ∃b1,..., bn.b1 ... bn ∈ f (a) ∧ ∀i ∈ {1,..., n}si ∈ g(bi)}
where s1 ··· sn is the concatenation of sequences s1,..., sn.
This notion of composition is associative, and the map A → PA∗ which sends each a to {[a]}, the singleton set containing the singleton sequence, is an identity for it. We therefore have a category FQ, so named because it turns out to be the category of free quantales over sets.
Alternatively we may present this category as the Kleisli category SetPT , where

T is the monad delivering the free monoid on a set. The composite functor PT
itself becomes a monad by virtue of a distributive law
λ : TP −→ PT
whose action is as follows. For any set A, λA takes a sequence [S1,..., Sn] of subsets of A to the set of sequences
{a1 ... an | ∀i ∈ 1,..., n.ai ∈ Si.}
The first author has shown that the opposite of this category gives rise to a model of interference-controlled Algol which is essentially the same as Reddy’s ob- ject spaces model, and that this model is fully abstract [8,10]. This presentation also has much in common with the development of Engeler-style models of the lambda- calculus in [5], and with the relational models presented in [3]; the connections remain to be explored.
In fact when modelling interference controlled Algol, it turns out to be more convenient to work with (the opposite of) the Kleisli category for P on T -Alg, the category of algebras for the monad T , that is, the category of monoids. This gives access to some additional objects which makes the formulation of the model simpler.
However, for all intents and purposes FQop is the category which houses the fully
abstract model of interference-controlled Algol in op. cit., and so it is this category we shall use.

Semantics of Interference-Controlled Algol
We now review the semantics of the types and constants of the language in FQop. Objects of the category are sets, and a map A → B can be seen as a relation between A∗ and B. Disjoint union of sets gives a product in this category (because it gives a coproduct in Set and hence also in SetPT ). The larger category (T−AlgP )op has a monoidal closed structure, where the tensor product is given by cartesian product of sets, and the internal hom A ( B is given by the set A∗ × B. In FQop the monoidal structure is not available, but the function types are, and this is enough to enable us to model the language.
The types are interpreted as shown below, where N denotes the set of natural numbers:
[[nat]] = N [[comm]] = {∗}
[[var]] = {write(n), read(n) | n ∈ N}
[[A × B]]= [[A]] + [[B]]
[[A → B]]= [[A]]∗ × [[B]].
(In some later calculations, we will identify the base types comm, nat and var with the sets they denote in this model.)
We now turn our attention to the constants. For each constant c : A we define [[c ] as an element of [A]]. We use juxtaposition to denote concatenation of sequences, and identify a singleton sequence with its single element. When working with dis- joint unions of sets, as in the semantics of product types, we use superscripts to

indicate which component of the disjoint union a given element belongs to, so that for example in N + N + N, n3 is the value n in the rightmost component.
Note that a sequence s ∈ var∗ consists of elements write(n) and read(m). We say that such a sequence is a cell-trace if the value in each read(−) entry matches the most recent write(−) entry: the kind of behaviour one would associate with a memory cell. If no write(−) has yet occurred, we allow read(0) to occur, modelling a cell with the default initial value of zero. Cell traces are therefore generated by the regular expression
read(0)∗ · (Σn∈Nwrite(n) · (read(n)∗))∗ .
Armed with this, we give the semantics of constants as follows.
[[0]] = 0
[[succ]] = {(n, n + 1) | n ∈ N}
[[pred]] = {(n + 1, n) | n ∈ N}
[[ifzeroB]] = {(01v2, v) | v ∈ B}∪ {(n1v3, v) | n ∈ N,n /= 0,v ∈ B}
[[skip]] = ∗
[[assign]] = {(n2write(n)1, ∗) | n ∈ N}
[[deref]] = {(read(n), n) | n ∈ N}
[[seqB ]] = {(∗1v2, v) | v ∈ B}
[[while]] = {01 ∗2 01 ∗2 ... 01 ∗2 m1, ∗) | m ∈ N,m /= 0}
[[new]] = {((s, ∗), ∗) | s is a cell-trace}.
[[mkvar]] = {(n2, read(n)) | n ∈ N}∪ {((n... n, ∗)1, write(n)) | n ∈ N}
In the semantics of while, the expression 01 ∗2 01 ∗2 ... 01∗2 denotes any element of the regular language (01∗2)∗, including the empty sequence; and similarly n...n in the semantics of mkvar denotes any sequence of the form nnnnn . . . n.

O’Hearn and Reddy’s model of Algol
In [12], O’Hearn and Reddy present a model of full Idealised Algol obtained from Reddy’s object-spaces model by means of the (enriched) Yoneda embedding. The approach is as follows. To model Idealised Algol, one requires:
a Cartesian closed category, to model the typed lambda-calculus
a stock of objects to interpret the base types of the language, together with maps between them to interpret the constants forming the simple imperative language at the core of Idealised Algol
a fixed point combinator to interpret recursion: for each type A, a map [[[A]] ⇒
[[A]]] → [[A ] with appropriate properties
a map [[[var]] ⇒ [[comm]]] → [[comm ] to interpret new.
The object spaces model gives us enough to interpret the base types and the simple constants, but is not Cartesian closed: though it has products, it lacks exponentials;

and in the absence of exponentials it does not make sense to ask whether fixed points and new can be interpreted.
O’Hearn and Reddy’s proposed solution involves embedding the category of ob- ject spaces in a Cartesian closed category, using the Yoneda embedding. The idea is that an appropriate category of presheaves over the object-spaces model is Carte- sian closed and contains the object spaces as a full subcategory. This immediately satisfies the first two requirements on a model. Fixed points are obtained by work- ing with Cpo-enriched categories, and it turns out that direct consideration of the interpretation of var → comm allows the construction of the semantics of new.
Setting aside recursion for now, let us illustrate the semantics of new in the func- tor category SetFQ. FQop embeds fully in this category via the Yoneda embedding, with an object A represented by the covariant hom-functor FQ(A, −). Products are given pointwise. Apart from a size issue, which we will address later, the category would have exponentials: given functors F and G : FQ → Set, the exponential [F ⇒ Q] is the functor taking an object X to the set of natural transformations
FQ(X, −) × F −→ G.
In particular, [[[var]] ⇒ [[comm]]](X) is the set of natural transformations
FQ(X, −) × FQ([[var]], −) −→ FQ([[comm]], −).
Since FQ has coproducts given by disjoint union of sets, and using the Yoneda lemma again, this is the same as the hom-set
FQop(X + [[var]], [[comm]]).
So our interpretation of new must give, for each X and in a natural way, a map from elements of this hom-set, that is, relations between
(X + {read(n), write(n) | n ∈ N})∗  and  {∗}
to elements of [comm]][X] = FQop(X, {∗}), that is, relations between X∗ and the singleton set. We define [new ] as follows:
[[new]][X](f ) = {(s T X, ∗) | (s, ∗) ∈ f, s T [[var ] is a cell-trace}.
Note both the similarity with the interpretation of new in the object-spaces model, and the difference: the key distinction that in this model, the sequence s contains not only the variable-events for reading and writing, but also events from the set X, in an interleaved fashion. It is this that makes the interpretation of Algol work: events from X interrupt the flow of events in the variable, and allow us to record interfering behaviour.
However, there is an important size issue to overcome. When claiming that exponentials exist, we asserted that [F ⇒ G](X) is given by the set of natural transformations FQ(X, −) × F −→ G. Since FQ is not a small category, there is no reason to believe that this collection of natural transformations is a set at all. In the absence of a detailed argument to this effect, we cannot claim that SetFQ is Cartesian closed, so we cannot use it to model Idealised Algol.
O’Hearn and Reddy are aware of the size issue: their paper clearly states that the functor-category construction they use applies only to small categories. But

the category of object spaces is not small, and as written, their work applies the construction directly to this category, so the essential property of Cartesian closure for their model has not been established.
The category of object spaces is locally small (hom-sets really are sets), so one could remedy this situation straightforwardly by restricting attention to the full subcategory on some set of objects. But what set should we choose? At this point a tension emerges between the desire to make the construction work and the desire to have a mathematically natural and appealing model. A quick fix could be provided by restricting to (for instance) just those objects used in the interpretation of base types and their products, but immediately one loses the distinction between the syntax and its model: good models should be constructed entirely independently of syntactic considerations.
A more satisfying path to solution lies in identifying a small dense subcategory C of FQop and considering the functor category SetC. This is the approach we take in the remainder of the paper.

A small dense subcategory
Let C be a category with a small full subcategory D, with inclusion functor J : D ‹→ C. Recall that D is dense in C if the functor C → SetDop taking X to C(J−,X) is full and faithful. Equivalently, every object of C arises as a colimit of D-objects in a canonical way; see Mac Lane [7].
Our goal is to find a small dense subcategory of FQop closed under finite prod- ucts. The category of presheaves over this will then be Cartesian closed, and FQop will fully embed in this category in a product-preserving fashion. We will then be able to provide semantics for Idealised Algol along the lines indicated above.
As a first attempt, consider the full subcategory of FQop whose objects are finite sets. We call this category FQop. It can equivalently be given as the subcategory with objects the natural numbers, that is, finite sets of the form {0, 1,..., n} for some n ∈ N, which is clearly a small category. Every object of FQop is a colimit of a diagram of these objects. Given sets A and B with A ⊆ B, the relation taking an element a ∈ A to the singleton sequence [a] provides maps in FQop from A to B and back:
inA,B : A → B = {([a], a) | a ∈ A}
outB,A : B → A = {([a], a) | a ∈ A}
Note that outB,A ◦ inA,B = idA, and that if A ⊆ B ⊆ C then inA,C = inB,C ◦ inA,B, and similarly for the out maps. Now given any object X of FQop, the diagram consisting of all finite subsets of X and all inA,B maps between them has colimit X, with the maps inA,X forming the colimiting cone. Thus one might expect that the finite sets are dense in FQop, but unfortunately this is not the case, as the following counterexample shows.
Consider the set R of real numbers.  If FQop is to be dense in FQop, there
should be a bijective correspondence between maps R → 1 in FQop and natural

transformations
FQop(J−, R) → FQop(J−, 1)
where 1 is the singleton set. Given such a natural transformation α and sets X ⊆ Y ⊆ R, naturality implies that α(inY,R) ◦ inX,Y = α(inY,R ◦ inX,Y ) = α(inX,R). Thus the maps α(inX,R) : X → 1 form a cocone over the inX,Y , and hence there is a unique map f : R → 1 such that f ◦ inX,R = α(inX,R) for every finite X ⊆ R. Density of FQop amounts to the statement that α(g) = f◦g for all maps g : X → R, rather than just for the in maps.
We now define a natural transformation α for which this does not hold. Given a finite set X and a map f : X → R in FQop, α(f ) is the relation on X∗ × 1 defined by
{(s, ∗) | (s, x) ∈ f for uncountably many x}.
To see that this is natural, consider any f : X → R and g : Y → X. If some (t, ∗) ∈ α(f ) ◦ g, there must be (s, ∗) ∈ α(f ) such that s = x1 ... xn, t = t1 ... tn and for each i, (ti, si) ∈ g. This means there are uncountably many x such that (s, x) ∈ f , and hence also (t, x) ∈ f ◦g for uncountably many x, so that (t, ∗) ∈ α(f ◦g). Hence α(f ) ◦ g ⊆ α(f ◦ g). For the other inclusion, suppose (t, ∗) ∈ α(f ◦ g) for some t. Then there are uncountably many x such that (t, x) ∈ f ◦g. For each such x there is some sx such that (sx, x) ∈ f , and sx = sx ... sx, t = tx ... tx with each (tx, sx) ∈ g.
1	n	1	n	i	i
But the sx are drawn from the countable set X∗, so there must be some s such that sx = s for uncountably many x. It follows that (s, x) ∈ f for uncountably many x, hence (s, ∗) ∈ α(f ) and then (t, ∗) ∈ α(f ) ◦ g as required.
However, for every finite X ⊆ R, α(inX,R) = ∅. The unique mediating map f : R → 1 is also the empty relation, but it is clearly not the case that α(g) = ∅◦ g for all g. Hence FQop is not dense in FQop.
We do not know of a straightforward way to remedy this situation in the non- enriched case. Fortunately, as should be clear from the above counterexample, the failure of density results from a discontinuity in the components of the natural transformation α, which can be eliminated by working with Cpo-enriched categories rather than ordinary categories. Since we intended all along to move to the Cpo setting, so as to recover a semantics of recursion, this is harmless, though the picture is perhaps more delicate than one would like.
We let Cpo denote the category of directed-complete partial orders, possibly without bottom element, and continuous functions. Recall that a Cpo-category has
hom-cpos rather than hom-sets, with composition being a continuous function on hom-cpos. The categories FQ, FQop and FQop can be seen as a Cpo-categories: given sets X and Y , FQ(X, Y ) is the collection of relations between X and Y ∗, ordered by inclusion. It is straightforward to verify that composition is continuous.
The Cpo-functor-category CpoFQ has as its objects all Cpo-functors from FQ to Cpo, that is, functors whose actions on morphisms are continuous. Maps between Cpo-functors boil down to ordinary natural transformations between the underlying ordinary functors; but note that the components of such natural transformations
are maps in Cpo and therefore continuous functions. In this setting, FQop is a

dense subcategory of FQop.
Theorem 5.1 FQop is dense in FQop. Dense here means that the functor from FQop to CpoFQf taking an object X to FQop(J−,X) : FQf → Cpo is fully faithful as a Cpo-functor, i.e. that each of its actions on hom-cpos is an order isomorphism.
Proof. We must show that the action of the functor in question on hom-cpos is injective, surjective and reflects order.
For injectivity, observe that if f, g : X → Y are distinct maps of FQop, there
must be some pair (s, y) ∈ X∗ × Y that appears in f but not g (or vice versa). We must show that the natural transformations FQop(J−,f ) and FQop(J−, g) are distinct. Let A ⊆ X be any finite subset that contains all the elements of s. Instantiating the natural transformations at A and applying to the morphism inA,X
gives the two maps f ◦ inA,X and g ◦ inA,X , and one of these contains the pair (s, y)
while the other does not, as required. A similar argument shows that the functor’s action on hom-cpos reflects order.
More interesting is the question of surjectivity. Let α : FQop(J−,X) → FQop(J−,Y ) be any natural transformation. Just as in the non-enriched case, there is a unique f : X → Y such that α(inA,X ) = f ◦ inA,X for all finite A ⊆ X: concretely, this f consists of all those pairs (s, y) such that (s, y) ∈ α(inA,X ) for some A. It remains to show that α = FQop(J−,f ), that is, that α(g) = f ◦ g for any finite set A and map g : A → X.
But for any finite B ⊆ X, applying the naturality square for α

FQop(JB, X)	αB
FQop(JB, Y )



FQop(outX,B ◦ g, X)

FQop(JA, X)
A
FQop(outX,B ◦ g, Y )

FQop(JA, Y )

to the element inB,X  of FQop(JB, X) means that αA(inB,X ◦ outX,B ◦ g)  =
αB(inB,X ) ◦ outX,B ◦ g = f ◦ inB,X ◦ outX,B ◦ g. The set of maps
{inB,X ◦ outX,B ◦ g : A → X | B ⊆ X, B finite}
is directed, with supremum g. Hence by continuity of αA, αA(g) = f◦g as required.2
The situation at which we have arrived is satisfactory, but somewhat delicate. The functor category CpoFQf is locally small and Cartesian closed, and contains FQop as a full subcategory, so we are in a position to give semantics to Idealised Algol as explained by O’Hearn and Reddy. The move to Cpo-categories was on the agenda from the outset, because of the desire to model recursion using fixed points.
However, Cpo-enrichment plays a double role, because FQop fails to be dense
without it; this makes the construction less flexible, and the fact that we have used directed completeness rather than ω-completeness in the density argument raises difficulties, because Cpo is not locally presentable while ωCpo is. Nevertheless, we
have identified a small category of “worlds”, namely FQf, whose functor category

provides a model of Idealised Algol.
Theorem 5.2 The model of Idealised Algol in CpoFQf is fully abstract up to order two.
Proof. The proof follows that of O’Hearn and Reddy. Some small alterations are needed because FQop lacks the coherence structure of Reddy’s original object spaces model, so contains some nondeterministic elements. However, adding nondetermin- ism to Idealised Algol is a conservative extension (see [10] for instance) so this makes no difference to the result.	2

Failure of full abstraction at order 3
We now give a counterexample to full abstraction, that is to say, a pair of terms which are contextually equivalent in Idealised Algol but have distinct denotations in the functor-category model. The type of these two terms are of third order, so we have a sharp result: the model is fully abstract to order two, but no further.
The terms are of the form λf : (comm → comm) → comm.Mi where M1 and M2
are defined by:
M1 = new(λx.f (λc.x := 0; c; x :=!x + 1; c; if !x ≥ 2 then Ω else x := 0)
M2 = f (λc.c; c)
Here we make use of some syntactic sugar, using infix operators ; and := in place of the functions seq and assign, ! for deref, and standard arithmetic and boolean operations which are readily definable.
Lemma 6.1 The terms λf.M1 and λf.M2 are contextually equivalent.
Proof. Equivalence of these terms is established by analysing their denotations in the fully abstract game semantics [2]. We shall not detail the games model here, but give the equivalence proof for those readers familiar with the model.
The game denotation of the term
f (λc.x := 0; c; x :=!x + 1; c; if !x ≥ 2 then Ω else x := 0) is a strategy on the game
((comm4 → comm3) → comm2) × var → comm1.
Subscripts on the comm games are used to identify the four occurrences, and we tag their run and done moves similarly. The strategy plays as follows:
when O plays run1, play run2
when O plays done2, play done1
when O plays run3, play write(0), and when O then plays ok, play run4. We refer to this occurrence of run4 as a ﬁrst invocation of the move.
when O plays done4 in response to a first invocation of run4, play read; O then plays some value n, and P plays write(n + 1); O then plays ok, and P plays run4
— this is a second invocation.

when O plays done4 in response to a second invocation of run4, play read; when O plays a value n, play write(0) if n ∈ {0, 1}, otherwise make no response; when O plays ok, play done3.
If we strip out all the var moves from these plays, we obtain the strategy for the term f (λc.c; c). Therefore, to establish equivalence we need only show that if O’s play in var is a cell-trace, then O’s answer n to the read in the final paragraph above is always 0 or 1. This is done by induction on the length of a play according to the above strategy: we show that
when a first invocation of run4 is played, the last write carried value 0
when a second invocation of run4 is played, the last write carried value 1
when done4 is played in response to a first invocation, the last write carried value 0
when done4 is played in response to a second invocation, the last write carried value 0 or 1
when done3 is played, the last write carried value 0.
The interesting cases concern the done4 moves. When done4 is played, the previous move must have been either run4, so the last write was either 0 (for a first invocation) or 1 (for a second invocation); or done3, in which case the last write was 0. Thanks to the bracketing discipline for question and answer moves in the games model, these are the only two possibilities, so the proof is complete.	2
Lemma 6.2 The denotations of λf.M1 and λf.M2 are distinct in the model in
CpoFQf .
Proof. The terms will be distinguished by applying them to a particular element of the denotation of (comm → comm) → comm). This is most readily described as a natural transformation α : [[comm → comm]] −→ [[comm]]. Its component at X is the map
αX : FQop(X + comm, comm) −→ FQop(X, comm)
f	f
which takes a map g to the relation
{(s1s' s2s' s3s' , ∗) | (s1 ∗ s2 ∗ s3, ∗) ∈ g, (s' ∗ s' ∗ s' , ∗) ∈ g}.
1	2	3	1	2	3
It is straightforward to verify that this is a natural transformation.
The denotation of the argument term
λc.x := 0; c; x :=!x + 1; c; if !x ≥ 2 then Ω else x := 0
is the natural transformation [var]] → [[comm → comm ] whose component at X is given by the map FQop(X, var) → FQop(X + comm, comm) which takes a map h to the set of pairs (s1 ∗ s2s3 ∗ s4, ∗) where h contains (s1, write(0)), (s2, read(m)), (s3, write(m + 1)) and (s4, n) for some m ∈ N and n ∈ {0, 1}.
Composing these two gives us the denotation of
f (λc.x := 0; c; x :=!x + 1; c; if !x ≥ 2 then Ω else x := 0)
when f is bound to α.  It is the natural transformation [var]] → [[comm ] whose

component at X is the map FQop(X, var) → FQop(X, comm) taking h to the relation consisting of all pairs (s1s' s2s3s' s' s4s' , ∗) where h contains the pairs (s1, write(0)),
1	2 3	4
(s' , write(0)), (s2, read(m)), (s' , read(m')), (s3, write(m + 1)), (s' , write(m' + 1)),
1	2	3
(s4, n) and (s' , n') for some m, m' ∈ N and n, n' ∈ {0, 1}.
By our density result, this natural transformation must correspond to an element of FQop(var, comm), and the appropriate element is the relation containing all pairs
(write(0)write(0)read(m)write(m + 1)read(m')write(m' + 1)read(n)read(n'), ∗) where m, m' ∈ N and n, n' ∈ {0, 1}. This relation is the denotation of
λx.f (λc.x := 0; c; x :=!x + 1; c; if !x ≥ 2 then Ω else x := 0).
Finally, applying new to this results in the empty set, because none of the sequences of var-actions in the above relation is a cell-trace. We therefore conclude that applying [λf.M1]] to α results in the empty relation.
On the other hand, a similar and much simpler calculation shows that applying [[λf.M2]] to α gives the relation {(ε, ∗)} (the denotation of skip), which is non- empty, completing the proof.	2
Corollary 6.3 The model of Idealised Algol in CpoFQf is not fully abstract for terms of order 3.
Future work
Taking our lead from O’Hearn and Reddy, we have shown how a small and simple category may be used as a category of worlds in a functor-category model of Idealised Algol. As O’Hearn and Reddy remarked, these “worlds” are of a rather different character to others in the literature, which generally correspond to the possible shapes of the store. We suggest that worlds in our model be understood as describing possible observations one can make of programs. Perhaps there are other notions of world following this idea which give rise to interesting and useful models, and connections with presheaf models of concurrency [4].
Though we claim that our simplified notion of object space gives rise to essen- tially the same model as O’Hearn and Reddy’s approach, it is nevertheless natural to ask whether one can find a small dense subcategory of Reddy’s original category of object-spaces. We believe that a similar approach will work, though we have not studied it in detail. Perhaps more interesting is to ask whether the fully abstract games models can be reconciled with the functor category approach: is there a fruitful way of viewing the games model as a functor category?

References
Abramsky, S. and G. McCusker, Linearity, sharing and state: a fully abstract game semantics for Idealized Algol with active expressions (extended abstract), in: Proceedings of 1996 Workshop on Linear Logic, Electronic notes in Theoretical Computer Science 3 (1996), pp. 2–14.
Abramsky, S. and G. McCusker, Linearity, sharing and state: a fully abstract game semantics for Idealized Algol with active expressions, in: O’Hearn and Tennent [13] pp. 297–329 of volume 2.


Bucciarelli, A., T. Ehrhard and G. Manzonetto, A relational model of a parallel and non-deterministic λ-calculus, in: LFCS ’09: Proceedings of the 2009 International Symposium on Logical Foundations of Computer Science (2009), pp. 107–121.
Cattani, G. L. and G. Winskel, Presheaf models for concurrency, in: Computer Science Logic: 10th International Workshop Proceedings, Lecture Notes in Computer Science 1258 (1997), pp. 58–75.
Hyland, M., M. Nagayama, J. Power and G. Rosolini, A category-theoretic formulation of engeler-style models of the untyped λ-calculus, in: Proc. MCFSIT 2004, Electronic Notes in Theoretical Computer Science volume 161, 2006, pp. 43–57.
Kelly, G. M., “Basic Concepts of Enriched Category Theory,” Cambridge University Press, 1982.
Mac Lane, S., “Categories for the Working Mathematician,” Springer-Verlag, Berlin, 1971.
McCusker, G., A fully abstract relational model of syntactic control of interference, in: Proceedings, Computer Science Logic (CSL) 2002, Lecture Notes in Computer Science 2471 (2002), pp. 247–261.
McCusker, G., On the semantics of the bad variable constructor in Algol-like languages, in: S. Brookes and P. Panangaden, editors, Proceedings, Nineteenth Conference on the Mathematical Foundations of Programming Semantics, Montreal 2003, Electronic Notes in Theoretical Computer Science (2003).
McCusker, G., A graph model of imperative computation, Logical Methods in Computer Science 6
(2010), pp. 1–35, doi:10.2168/LMCS-6(1:2)2010.
O’Hearn, P. W., A. J. Power, M. Takeyama and R. D. Tennent, Syntactic control of interference revisited, Theoretical Computer Science 228 (1999), pp. 211–252.
O’Hearn, P. W. and U. Reddy, Objects, interference and the Yoneda embedding, in: M. Main and S. Brookes, editors, Mathematical Foundations of Programming Semantics: Proceedings of 11th International Conference, Electronic Notes in Theoretical Computer Science (1995), pp. 487–514.
O’Hearn, P. W. and R. D. Tennent, editors, “Algol-like Languages,” Birkhau¨ser, 1997.
Reddy, U. S., Global state considered unnecessary: Object-based semantics for interference-free imperative programs, Lisp and Symbolic Computation 9 (1996), pp. 7–76.
Reynolds, J. C., Syntactic control of interference, in: Conf. Record 5th ACM Symposium on Principles of Programming Languages, 1978, pp. 39–46.
Reynolds, J. C., The essence of Algol, in: Proceedings of the 1981 International Symposium on Algorithmic Languages (1981), pp. 345–372.
