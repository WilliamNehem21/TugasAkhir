	Electronic Notes in Theoretical Computer Science 92 (2004) 3–15	
www.elsevier.com/locate/entcs




Time-dependent Networks as Models to Achieve Fast Exact Time-table Queries
Gerth Stølting Brodal1
Department of Computer Science, University of Aarhus, Ny Munkegade, DK-8000 A˚rhus C, Denmark.
Riko Jacob2
Institute of Theoretical Computer Science, ETH Zu¨rich

Abstract
We consider efficient algorithms for exact time-table queries, i.e. algorithms that find optimal itineraries for travelers using a train system. We propose to use time-dependent networks as a model and show advantages of this approach over space-time networks as models.
Keywords: Timetable, time-dependent network, shortest path, traveler information system, modeling, algorithm


Introduction
Finding the optimal itinerary for a traveler using public transportation is an algorithmic challenge. Using standard algorithms to solve itinerary queries on timetables of interesting detail and size easily leads to unacceptably slow answers, even on modern computers. In practice this problem is overcome by using a heuristic solver, that is a solver that quickly computes results, that are not guaranteed to be optimal. Our focus here is instead to produce optimal itineraries.

1 BRICS (Basic Research in Computer Science, www.brics.dk, funded by the Danish Na- tional Research Foundation), E-mail: gerth@brics.dk Partially supported by the IST Programme of the EU under contract number IST-1999-14186 (ALCOM-FT).
2 E-mail: rjacob@inf.ethz.ch, Work done while staying at BRICS.

1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2003.12.019


The nature of an optimal itinerary query is that of a shortest path ques- tion. The natural approach to solve it is to transform the timetable into some weighted graph (modeling as a space-time graph [9,10]), on which a short- est path corresponds to an optimal itinerary. This seems to be a standard approach, taken for example in [11,6,12]. In this setting we propose to use as a model time-dependent graphs instead of weighted graphs. This kind of model is closer to the time-table itself and allows the algorithm to immediately disregard large portions of the time-table.
The key idea in a time-dependent network is that the time-delay of a link depends on the point in time the link is used. This model is natural in several other situations, for example data-packets on the Internet or cars on a road network. This models the phenomenon, that the delay a link induces depends on the path that is used to reach this link. In general shortest path questions on such networks are hard to answer, but important special cases allow for fast algorithms. These kind of networks have been considered in the literature, see for example [7,8] for a survey. The use of this type of modeling for routing passengers is described in [1], where the focus is on travelers using cars on the road network.
In [11] the authors address the question, whether it is feasible to compute optimal itineraries for the German railway system. This question is also the example in [12]. They propose several heuristic running time improvements that allow for sufficiently quick answers. Our modeling is compatible to these heuristics, they can immediately be applied in the time-dependent algorithms as well. We expect that our modeling and algorithmic approach will lead to significant running time improvements that allow for a bigger or more detailed network (including local busses, extending to all of Europe). For our lack of real world data the analysis of our approach is a theoretical comparison against [11]. The modification of the network considered in [12] also modifies only the station-aspect of the used graph, our algorithms proposed here can easily adopt the speed-up techniques of [12].
We also consider an extensions of the algorithmic problem, that allows to restrict transfer.
Some simple calculation about problem sizes and modern hardware shows that it can be feasible to precompute the answers to all possible queries and store the result on a hard-disk. If the network size allows this, it can be a viable alternative to an algorithmic solution. This should be the case if the network is not too big. Of course this approach still needs to find fast itinerary in a preprocessing step.

The algorithmic problem
As already stated, we want to be able to produce optimal itineraries for pas- sengers. That is, given the time-tables of all trains in the country, we want to pre-process this data in a way, that allows us to answer queries fast. We consider queries of the form “given that the traveler is at station A at time

t, when is the earliest time he can be at station B, (and how can this be achieved)?” For simplicity we assume that changing trains has no induced costs, i.e. takes no time and can be done as often as necessary. (We will address a more detailed modeling in Section 5.)
We assume that we have a set T that represents time, like the real numbers, the integers (e.g. seconds since 1.1.2000), or the set {0:00, 0:01,..., 23:59}. We only assume that we have a total ordering of the elements in T. Sometimes we additionally assume that there is an addition operation defined over T.
A time-table T is a set of train-connections. It is valid for a certain time- period, its (time-)horizon. This is an interval of T. An event is a pair (a, t) where a ∈ S for some finite set S of stations, and t ∈ T. A train-connection is a pair (e1, e2), e1 = (a1, t1) the departure event and e2 = (a2, t2) the arrival event. We have that the time of the arrival event is not before the time of the departure event, i.e. t1 ≤ t2.
An itinerary in T is a sequence of events, more precisely an alternating se- quence of train departure and arrival events e1, e2,..., ek. Two events e2i−1, e2i have to be consecutive departure and arrival events of some train in T , two events e2i, e2i+1 have to be arrival and departure events at the same station.
It will be common that T is not given explicitly, but for example as the time-table for one day and the additional information that this day is repeated throughout a certain period. Note that in a periodic schedule there will be over-night connections that are not possible if the horizon is restricted to one day.
These definitions have some severe restrictions. At a station we can not distinguish between continuing in the same train and transfer. We also dis- allow the traveler to use any other means of transportation like walking 200 meters from one station to another. In Section 5 we will address these is- sues, allowing us to impose restrictions on the maximum number of transfers or accounting for the time it takes to walk inside the station as part of a transfer.

Using a space-time network
The approach we describe here is straightforward given how we made the algorithmic problem precise. It is a direct transformation of a time-table into a directed weighted graph. Paths in this graph are almost itineraries. To calculate the weights it is important that T allows for addition and subtraction. Given a time-table T we construct the graph G = (V, E) in the following way: V is the set of all events of T . There is an edge from event e at station a to the first event at station a after e. If the schedule is periodic, this can be reflected by having a link from the last event of the day at station a to the first event of the day at station a. If a pair of events (e1, e2) is in T , there is a directed edge from e1 to e2. The weight of an edge in the weighted graph model is given by the time-difference of its endpoints, i.e. the traveling time

or the waiting time at a station.
This type of model can be seen as a space-time network as described in [9]. It is the model used in [11] and therefore important for us because we use it for a running time comparison we will present in Section 4.
In [11] this model is used and augmented with different heuristics that improve the running time. These heuristics immediately transfer to the time- dependent approach, and achieve running times that allow exact time-table queries for the German railway system in a reasonable time. As we can strictly improve over this model this do-ability statement remains valid. The detailed comparison of the two approaches is given in Section 4. We have also reason to believe that our approach scales better, so we would expect it to be fast enough on even bigger or more detailed networks, e.g. including local buses and train as well and/or being precise about changing trains.
In [11] the authors observe that “CPU time looks linear to the number of nodes (and thereby edges) explored.” This statement can be explained by cache behavior. If we assume that the priority queue stays small enough to fit into the CPU-cache, whereas the graph is to big for that, we get that the CPU-times are dominated by the cache-misses that correspond to accessing the graph.
Be aware that there are some obvious alternatives to this model. For example, one could deviate from the cycle of edges at one station and explicitly have an edge if a passenger can actually change trains as suggested by a combination of arrival/departure events. This model uses in general a lot more edges, but it allows for a much more detailed modeling. We could for example make sure that the walking inside the station actually allows the transfer.

Time-dependent networks
In this section we develop the terminology for time-dependent networks (or graphs, which is precisely the same) and proof the correctness of a fastest path algorithm, that works in the situation we have here. We omit a discussion of the feasibility of shortest path questions in the more general setting, allowing negative delays and/or non-monotonic functions. In this more involved set- ting, it is important to specify a waiting policy. See [7,8] for a discussion of this type of network.
The domain of time is a linearly ordered set T. In this section we do not assume that there is an addition operation defined on T. Typical examples for the set T are the real numbers and the integers, but also finite sets are interesting.
A time-dependent network is a directed graph G = (V, E), where every edge e has an associated link-traversal function fe: T → T.
Let f : T → T be a function. If f satisfies f (t) ≥ t for all t, we say that
f has non-negative delay. If for t ≤ t' we have f (t) ≤ f (t'), we say that f is

monotonic.
Here we use the following simple definition of a timed path in G: A se- quence v1, v2,..., vk ∈ V of nodes in G and a sequence t1, t2,..., tk ∈ T of times form a timed path if e = (vi, vi+1) ∈ E is an edge of G and ti+1 = fe(ti). The vertex v1 is called the departure location or source of the path, t1 the departure time, vk the destination and tk the arrival time.
The earliest arrival question for a source node s, a destination d, and a departure time t asks for a timed path p from s to d of which the arrival time is minimal. Similarly the latest departure question is well defined if we fix an upper bound for the arrival time, i.e. we ask for a path that has the latest departure time at s under the constraint that the arrival time is not after the specified arrival time.
Assume that we can (efficiently) evaluate the link-traversal functions of a graph and (efficiently) perform comparisons of elements in T. Then it is reasonable to consider a variant of Dijkstra’s algorithm to solve the earliest arrival question. It is natural to analyze its running time as a number of function evaluations, comparisons and operations of a (comparison based) priority queue over T.
Lemma 3.1 (All earliest arrival paths are simple) Let G be a finite time- dependent network with monotonic and non-negative delay edge traversal func- tions. Let p be a timed path in G departing at time t at node s and arriving at time t' at node d. Then there exists a simple timed path in G departing at time t at node s and arriving at time t'' at node d such that t'' ≤ t'.
Corollary 3.2 (Earliest arrival path are well defined) Let G be a finite time-dependent network with monotonic and non-negative delay edge traversal functions. Let s and d be two nodes of G, and a departing time t ∈ T. Then there exists t' ∈ T achieving the minimum arrival time at d over all timed paths from s to d.

Label setting algorithm
This algorithm is an already known modification Dijkstra’s shortest path al- gorithm. We state it for the sake of completeness.
Let Q be a priority queue over pairs from V × T that allows to extract a pair with a minimal element from T, i.e. a priority queue of points in time annotated with nodes.
1: Static Input: G = (V, E), and for every e ∈ E a monotonic, non-negative delay link-traversal function fe: T → T.
2: Dynamic Input: source node s ∈ V , destination node d ∈ V , departure time t ∈ T
3: a[v] := ∞ for all v ∈ V
4: a[s] := t
5: S := ∅
6: Q := {(s, t)}

7: while Q /= ∅ do
8:	(u, t''):= extract min( Q )
9:	S := S ∪ {u}
10:	break while-loop if u = d
11:	for each edge (u, v) ∈ E such that v /∈ S do
12:	t' := fuv(a[u])
13:	if a[v] > t' then
14:	if a[v]= ∞ then
15:	insert( Q, v, t')
16:	else
17:	update( Q, v, t')
18:	end if
19:	a[v] := t'
20:	pred[v] := u
21:	end if
22:	end for
23: end while
24: v := d
25: p := (v, a[v])
26: while v /= s do 27:	v := pred[v] 28:	p := (v, a[v]).p 29: end while
30: Output: p
The above algorithm is correct for monotonic, non-negative delay link- traversal functions. This is based on the same kind of argument as the one showing Dijkstra’s algorithm correct for non-negatively weighted graphs. A proof of correctness can be found in [3].
Modeling a time-table lookup with a time-dependent network
Let T be a time-table. We describe how to construct a time-dependent network G = (V, E, f ). We chose the set of nodes V to be the set of stations appearing in T . Let u and v be two stations. Define
Cuv =  (t, t') |  (u, t), (v, t')  ∈ T ,
that is for every direct connection from u to v there is a pair of times in Cuv.
If Cuv is empty, there is no arc from u to v. Otherwise we define
fuv(t) = min{t'' | (t', t'') ∈ Cuv and t ≤ t'}.
This function is monotonic and of non-negative delay.
Let I be an itinerary. Then we find a timed path p in G that is never later at a certain station than I is. The path p is therefore a timed path that does not arrive later at the destination than I does.

Let p be a timed path in G. By the definition of the link traversal func- tions we know, that every link traversal of p corresponds to an entry of T . Concatenating those entries yields a valid itinerary.
All in all we can answer an itinerary query from s at time t to d on T by solving the earliest arrival problem on G with source s at time t and destination d.

Implementation issues
There are several speed-up techniques known for Dijkstra’s algorithm. Two classes of such techniques are on-the-fly potential and pruning, as for example used in [11,12].
One well known potential technique is to modify the value that is used in the priority queue by a lower bound on the remaining path-length to the destination. If the network is embedded into the plane, this can be an ap- propriate multiplicative of the Euclidean distance to the destination. One way to convince oneself about the correctness of this method is to think of modifying the edge weights of the graph according to some potential, i.e.
'	= wuv + p(v) − p(u). Adding any potential to a graph does not change
the relative weight of paths in the graph—if path p is longer than path q in
G, then path p is also longer than path q on G', the graph with modified weights. Adding a potential that does not create negative weights does not influence the correctness of Dijkstra’s algorithm. If we cleverly choose the potential, we can improve the running time of the algorithm significantly. If we by chance manage to use the shortest path distances to d as the potential p, we get that precisely all edges that are on some shortest path toward d have weight 0. If the shortest path happens to be unique, the algorithm only looks at the nodes on the shortest path and the outgoing edges from these nodes. This situation is of course not what we expect to find, if we already have the shortest path potential we do not even need Dijkstra’s algorithm to determine shortest paths. But if we have a good, conservative approximation of such a potential we can hope to significantly reduce the part of the graph that is inspected by the algorithm. Of course this is only useful if this potential can easily be computed. This is for example true for the Euclidean distance to the destination.
Another, more direct way to reduce the size of the inspected part of the graph is to remove edges and nodes that are not relevant, i.e. not on a shortest path for the current s and d. In the extreme, again, we might have precom- puted a shortest path for all possible choices of s and d, and stored the resulting path. Now we can on the fly disregard all the edges that cannot be on the current path. The algorithm will then only explore the path itself. Again, in this situation there is no need to run an algorithm anymore. The interesting versions of this method are those where we do not need a lot of memory to store the result of the precomputation, and where evaluating whether a link can be disregarded is easy. A good example is the pruning technique used

in [11]. There we have for every edge some geometric information for which kind of s and d the edge is relevant.
In [11] the point is made that a combination of these speed-up techniques reduces the running time of Dijkstra’s algorithm in a space-time network enough to compute optimal itineraries on a complete German railway time- table on-line. We observe that these speed-up techniques are just as powerful on the time-dependent network, and that using the time-dependent approach can significantly reduce the size of the inspected part of the network and by this the size of the priority queue.
In the following we will analyze the running time of different time-table query algorithms. This is as a comparison the space-time graph based algo- rithm and then different implementations of the link-traversal functions. The parameters determining the running time are
The size of the inspected part of the graph in nodes, this is where the algorithm annotates with estimates and tree-edges, that is nodes v in Line 3 of the algorithm.
The size of the inspected part of the graph in edges. This are memory accesses/function evaluations.
Size of the priority queue
Number of extract min operations. This is the number of times we explore
a node u, i.e. we have that the node is u in Line 3 of the algorithm.
Here we do not consider the time the algorithm spends maintaining the priority queue. There are several results in the literature discussing how to obtain fast priority queues in this context, for example using the fact that edge weights are integers. This kind of priority queue can be used for the time- dependent networks as well, if we restrict time to be integers. We note that even a more substantial change to the shortest path algorithm as proposed in [5] can easily incorporated into the time-dependent algorithm.
We consider the time-table query from s at time t to d. Let t' be the arrival time at d of a fastest itinerary.
The base of the comparison: algorithm on the space-time network
We follow a run of Dijkstra’s algorithm on the space-time network. We ob- serve, that we never update a distance estimate (the a[v]) for any node v. This is because the node has a time build in, we reach it equally fast on all possible paths. This can be exploited to speed up the priority queue. Consider a station a. The algorithm explores all events at a, starting from the earliest arrival time at a up to t'. How many events these actually are heavily depends on the station. But we can see that for a long itinerary, i.e. for big t', there is the possibility of futile work: Assume s itself is a busy station that has hourly non-stop connections to 10 cities. Assume t' is 4 hours after t. Then we usefully explore the events for the 10 connections in the first hour after t. But afterward we continue exploring nodes at s where the updated node on

the other side of the arc is already known to be reachable (but presumably not yet in Q).
The other algorithms avoid these futile exploration steps at some other cost. This trade-off is what we are investigating in the following.

General piecewise linear functions
If we take a modular approach, we will implement the link-traversal functions completely independent of each other. That is, we will have a procedure that produces the value fuv(t) given t. This can easily be achieved with log2(k) comparisons if k is the number of connections from u to v, i.e. k = |Cuv|.
Now we do not unnecessarily explore nodes, but we might consider arcs that in the space-time network were not considered because the departure event is after t'. Additionally we waste time by doing independent searches for the different outgoing arcs.
Note that this approach can easily handle large time-horizons when the schedule is basically periodic, but has many exceptions arbitrarily spread over the timetable. The important feature of this situation is that the link-traversal functions have a small (in terms of space) representation, that still allows for fast evaluation.

Combining searches
To avoid the repetition of searches in the for-loop of Line 3–3, one can combine all the events into one data-structure. More precisely we have at every node a balanced search tree that has as leafs the times of all outgoing events. In a preprocessing step we annotate these leafs with a list of outgoing events, for every arc the next in time. Then every exploration of one node costs one binary search plus the update operation on the other side of the arcs.
This approach still performs one search per node and it uses additional space, at one node we have a multiplicative blow-up of its out-degree.

Avoiding the space-overhead (list-lookup)
Let d be the out-degree of the node in the time-dependent network correspond- ing to a. To avoid the space-overhead, we can put all the outgoing events of a station a into one array A sorted by their departure time. We can do this in the following way: we place d such events (so called primary entries), then we leave d empty spaces, then the next d events, and so on. Let t'' be the time of the last event before some empty spaces. Then we put for every outgoing direction the next event after t'' into the so far empty entries of A (secondary entries). We put all primary entries into one balanced search tree.
When we explore node a, we find the next primary entry of A and scan the next 2d entries of A. Then we are sure that all all the next outgoing events in all outgoing directions are among the scanned entries.

This approach uses asymptotically the same space as a space-time graph.
It still performs one search per exploration of a node.

Avoiding the search
If we watch the algorithm we see that when we perform an update operation, we have our hands on an event-pair e of the time-table. In particular we have one particular arrival time t'' at one particular node a. In addition to e we can store a pointer into the array of outgoing events at a, namely to the first primary element after time t''. If we make this pointer part of the data structure stored in the priority queue, there is no need for a search to explore a node.

Avoiding to consider connections that depart after t'
There is still one aspect in which the space-time graph might be superior to the time-dependent network approach: It will never consider a link whose departure time is after the arrival time t' at the destination station.
We can also achieve this in the time-dependent network. Assume we did not do the space-saving, that is we have a list of outgoing events for every relevant time at a node. We slightly change this list such that it is no longer ordered by the time of the departure event, but by the time of the arrival event on the other side of the arc. Instead of inserting all the arrival events of the list into the priority queue at once, we only insert the first event and a pointer to the next event of the list. Only when we extract this first event, we insert the second event of the list and so on. With this we inspect less entries of the time-table than the space-time graph algorithm does, we asymptotically never perform more work than that algorithm.

Cache behavior
Even so the last presented algorithm is the fastest algorithm if we consider asymptotic worst-case running time on the unit cost RAM, it might not be the fastest in practice. One thing is that the possibility to save constant factors in the running time is hard to foresee and an important factor in actual running time. More importantly we should also consider that the running time on a real machine can be heavily influenced by cache-faults. In this respect the last algorithm might not really be a good idea: It could lead to one cache miss for every item we place in the priority queue, whereas the lookup in the list could use the locality of the used entries. If additionally the the priority queue is small enough to fit into cache, we would expect the list-lookup to be faster.
The actual cache behavior seems to be too hard to predict to really make a statement about what should be the fastest algorithm without performing experiments. We leave this with the statement that there should be some possibilities to adapt the above algorithms to a specific cache size.

Of course there is also the priority queue to be considered in tuning the algorithm. This might not be an issue if the time-table happens to be such, that the priority queue is always very small and the overall running time is dominated by the cache misses stemming from accessing the network.

Concluding remarks on algorithms
Instead of using an array with primary and secondary entries we can consider the list of next events as a persistent linked list that (in the preprocessing) changes as time progresses. See [4] for details on this idea. This construction gives the same asymptotic behavior. It has the additional advantage that it can easily carried over to the exploration saving idea of Section 4.6.
We can see all the algorithms presented here as some clever way to on- demand create the important part of some space-time graph. Again this is only a different point of view.
Note that we can solve as well latest departure questions for a given arrival time. For this we just invert the direction of time and departing and arriving in the timetable.
All the algorithms presented here can additionally perform the on-line network pruning techniques suggested in [11]. The theoretical analysis carried out here suggests, that the algorithms presented here should be faster, on realistic networks presumably significantly faster, than the explicit space-time graph algorithm used in [11]. The statement that these algorithms are fast enough to produce optimal answers for time-tables of interesting size, should therefore carry over to even bigger (or more detailed) networks, if we use the algorithms presented here. Of course only experiments with real world data can give a conclusive answer whether or not these statements really hold.

Extensions
More realistic transfer
The algorithmic problem discussed so far made the unrealistic assumption, that transfer between trains is assumed to take no time and no cost. It seems, that we do not get a more realistic modeling of transfer for free. For a start we try to include some time for the walking inside the station in the itinerary, extending the network by as little as we can. We consider every platform to be a station of its own right. Then we connect the platforms by walking links, either following the geometry of the station or with a star to the concourse of the station. The link traversal functions for the walking links have constant delay, i.e. they are of the form f (t) = t + c for some constant c that reflects the walking distance. (This assumes that we have addition for our set T.)

Limiting the number of transfers in an itinerary
The above modeling of train changes can also be used to count the number of changes. Without extending the network further we do not consider a change of trains, if it does not involve moving from one platform to another. If we want to be more precise, we can introduce virtual platforms, one for every train-line. Then we do not capture changing of trains within a train line, which is no restriction, as it can always be avoided. Note that we basically return to the explicit network if every train has to be considered as a train line of its own.
To find all Pareto-optimal solutions, i.e. for every bound on the number of transfers the earliest arrival itinerary, we do the following:
First we find the fastest path without an upper bound on the number of changes. This will have some number k of transfers, and is the solution if the bound on the number of transfers is ≥ k. It is left to find the earliest arrival itinerary under the restriction, that we have at most k − 1,k − 2,..., 0 transfers. We take k copies (levels) of the original network with the twist that all walking links (i.e. all links that stand for a transfer) connect level i with level i + 1. On this network we search for a path from s at level 1 to some copy of node d. If we find this, we found the fastest path with at most k − 1 transfers, the level l of the endpoint of the path tells us how many transfers we actually have. Note that it might be that the fastest connection uses 5 transfers, but insisting on 4 transfers is slower than doing only 2 transfers. Then we delete all levels above and including l and continue our search to some copy of d at the remaining levels. We continue until we found a solution without transfer or we found that we can not reach the destination with less then l transfers. In practice we might want to stop this process as soon as insisting on few transfers results in unreasonably long travel times.
Connection to regular expressions
The above procedure can be seen as searching for a fastest path under a regular expression constrained. If we think of arcs in the network that stand for using a train being labeled with t and transfer links being labeled with w, the constraining regular expression is (w∗t∗w∗)k. It is easily possible to compute earliest arrival questions under general regular expression constraints (we only need to construct a nondeterministic finite automaton and build the cross product with the network). This might be a powerful tool express different kinds of restrictions on the itinerary. See [2] for a discussion on the complexity of imposing formal language constraints onto (shortest) paths questions.
Concluding on extensions
The extensions mentioned here are also applicable if the time-table is modeled using a space-time graph. The point we want to make here is that using a time-dependent network as a model actually allows for an easy description.

References
Chris Barrett, Keith Bisset, Riko Jacob, Goran Konjevod, and Madhav Marathe. Classical and contemporary shortest path problems in road networks: Implementation and experimental analysis of the TRANSIMS router. In ESA 2003, volume 2461 of Lecture Notes in Computer Science, pages 126–138, 2002.
Chris Barrett, Riko Jacob, and Madhav Marathe. Formal language constrained path problems.
SIAM J. Comput., 30(3):809–837, 2000.
Gerth Stølting Brodal and Riko Jacob. Time-dependent networks as models to achieve fast exact time-table queries. Technical Report ALCOMFT-TR-01-176, ALCOM-FT, September 2001.
James R. Driscoll, Neil Sarnak, Daniel D. Sleator, and Robert E. Tarjan. Making data structures persistent. In Proceedings of the Eighteenth Annual ACM Symposium on Theory of Computing, pages 109–121, 1986.
Andrew V. Goldberg. A simple shortest path algorithm with linear average time. In Algorithms
- ESA 2001, volume LNCS 2161, pages 230–241, 2001.
Matthias Mu¨ller-Hannemann and Karsten Weihe. Pareto shortest paths is often feasible in practice. In Algorithm Engineering, WAE 2001, volume LNCS 2141, pages 185–197, 2001.
Ariel Orda and Raphael Rom. Shortest-path and minimum delay algorithms in networks with time-dependent edge-length. Journal of the ACM, 37(3):607–625, 1990.
Ariel Orda and Raphael Rom. Minimum weight paths in time-dependent networks. Networks: An International Journal, 21, 1991.
Stefano Pallottino and Maria Grazia Scutell`a. Shortest path algorithms in transportation models: classical and innovative aspects. Technical Report TR-97-06, University of Pisa, 14, 1997.
Stefano Pallottino and Maria Grazia Scutell`a. Shortest path algorithms in transportation models: classical and innovative aspects. In P. Marcotte and S. Nguyen, editors, Equilibrium and Advanced Transportation Modelling, pages 245–281. Kluwer Academic Publishers, 1998.
Frank Schulz, Dorothea Wagner, and Karsten Weihe. Dijkstra’s algorithm on-line: An empirical case study from public railroad transport. In Algorithm Engineering, volume LNCS 1668, pages 110–123, 1999.
Frank Schulz, Dorothea Wagner, and Christos Zaroliagis. Using multi-level graphs for timetable information in railway systems. Lecture Notes in Computer Science, 2409:43–??, 2002.
