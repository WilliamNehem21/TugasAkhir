Electronic Notes in Theoretical Computer Science 194 (2008) 57–76	
www.elsevier.com/locate/entcs
Coordination Models Orc and Reo Compared
Jos´e Proen¸ca1,2 and Dave Clarke2
CWI
P.O. Box 94079, NL-1090 GB Amsterdam, The Netherlands

Abstract
Orc and Reo are two complementary approaches to the problem of coordinating components or services. On one hand, Orc is highly asynchronous, naturally dynamic, and based on ephemeral connections to services. On the other hand, Reo is based on the interplay between synchronization and mutual exclusion, is more static, and establishes more continuous connections between components (services). The question of how Orc and Reo relate to each other naturally arises. In this paper, we present a detailed comparison between the two models. We demonstrate that embedding non-recursive Orc expressions into Reo connectors is straightforward, whereas recursive Orc expressions require an extension to the Reo model. For the other direction, we argue that embedding Reo into Orc would require significantly more effort. We conclude with some general observations and comparisons between the two approaches.
Keywords: Reo, Orc, Coordination languages, Software Connectors.


Introduction
Although the field of coordination languages and models has been around for some time, the recent interest in Service-oriented Computing (SoC) and Web-service choreography and orchestration 3 has precipitated greater interest in the field, resulting in both new models and new application domains for existing models. Service-oriented computing is based on the idea that software is composed of ser- vices which reside on third party machines. Web services are a common realization of this idea. Since the conception of SoC, research has focussed on developing languages to compose or coordinate services into either composite services or appli- cations.
Coordination languages and models are based on the philosophy that an appli- cation or system should be divided into the parts that perform computation and

1 Supported by FCT grant 22485 – 2005, Portugal.
2 Email: Jose.Proenca@cwi.nl and D.G.Clarke@cwi.nl
3 We take the words choreography and orchestration to fall under the more general notion of coordination.

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.099

the parts that coordinate the results and resources required to perform the compu- tations. The original coordination language, Linda [17], played only a passive roˆle in coordination, by providing a blackboard (tuple space) to which data could be written and read. Since then many coordination models have been proposed [22,3], and the trend is towards developing models that play a more active roˆle in the coor- dination process. Two recent interesting coordination models, Orc [20] and Reo [4], sit diametrically opposite of each other in their approaches to coordinating services or components. This paper sets out to explore these in detail.
Orc is a simple orchestration language designed by Misra and Cook [20], based on a three connectives, and the simple notion of a site call to model computations—the external actions to be orchestrated. Central to Orc’s design is the idea that accessing (web) sites is an asynchronous activity which can fail, and so the connectives are designed to be asynchronous and not susceptible to failure.
Reo is a channel-based coordination language designed by Arbab [4] that is based on a simple notion of channel composition. It differs from existing models in that composition propagates synchronization and exclusion constraints through connec- tors. In combination with stateful channels, an expressive coordination language emerges.
This paper presents a comparison between Orc and Reo. By choosing two coor-
dination languages at different ends of the spectrum for our comparison, we hope to gain insight into the design choices and the advantages and disadvantages of various approaches. In the long run, we should hope for a synthesis of the two approaches, to get the best of both worlds. We present a number of examples, compare features
and the underlying philosophies and design choices, and formally embed Orc into
Reo. We also discuss the difficulties of embedding in the other direction. Section 2 describes our encoding of Orc into Reo. Section 3 argues that the encoding in the other direction is not as trivial. Section 4 compares the two models on a variety of points. Section 5 discusses some related work, and Section 6 concludes and discusses future work. But first, we introduce Orc and Reo, and give a small example.

Orc
In this section we present Orc’s syntax and reduction semantics, and simple examples of Orc expressions. In work by Misra and others [20,18] Orc’s semantics is described in more detail.
Orc expressions have the following syntax, where E is an expression name, M is a site name, x is a variable, v is a constant value, and p is a tuple of p’s:
f, g, h ∈ Expr ::= 0 | M (p) | E(p) | f >x> g | f |g | f where x :∈ g p ∈ Actual ::= x | v
Deﬁnition ::= E(x) d=ef f
An Orc program consists on an Orc expression together with a set of definitions. Basic services, such as data manipulation, are assumed to be provided by primitive sites. An Orc expression can be a primitive site call, a reference to another Orc expression, or a composition of Orc expressions.

A site call is written as M (p), where p is a tuple of arguments which can be constants or variables. When executed all variables have to be instantiated, that is, evaluation is strict, and the site returns at most one value. Examples of primitive sites are 0, which never responds, and let(v), which responds value v. We use E to range over possibly recursive definitions of Orc expressions.
Three combinators exist for composing expressions f and g: symmetric compo- sition, written as f | g; sequential composition, written as f >x> g; and asymmetric composition, written as f where x :∈ g. The combinator f | g executes f and g independently in parallel; f >x> g executes f and several threads of g, one for each result returned by f (where each value of f is substituted for x in a new g); and f where x :∈ g executes f and g in parallel, replacing x in f by the first returned value of g, returning only the values of f . 4
Instead of the standard, asynchronous semantics for Orc, we present a syn- chronous semantics which allows multiple events to occur at the same time. This approach enables a simpler formal comparison with Reo, without really changing

the essence of Orc. The reduction rules for Orc expressions have the form f
and are presented below. Here a is a set of observations of the following type:
BaseEvent ::= τ | Mk(v) | k?v | !v
−→a  g

We use the silent observation τ mainly to represent the binding of a variable to a value. Mk(v) represents the call to site M , indexed by a fresh k and with arguments
v. k?v represents the return of value v by the site call indexed with k. !v repre- sents that a value v was published. Finally, we use a and b to range over sets of

observations, following the convention that −→∅
rules:
denotes −→τ . Here are the reduction



k fresh
M (v)
−−−−→?k

(SiteCall)

let(v) −!→v  0
(Let)

?k −k−?→v

let(v)
(SiteRet)

f −→a f'
g −→a g'
f −→a f'  g −→b g'

f | g −→a  f' | g
(Sym1)
f | g −→a f | g'
(Sym2)
a,b
f | g −−→ f
| g'
(Sym3)

g −→a g'
f −→b f' !w ∈/ b

g where x :∈ f −→a g' where x :∈ f
(Asym1N)
g where x :∈ f −→b
g where x :∈ f'
(Asym2)

g −→a g'  f −→b
f' !w ∈/ b

(Asym3N)
!v,b
f −−→ f

(Asym1V)

a,b
g where x :∈ f −−→
g' where x :∈ f'
g where x :∈ f −→τ
[v/x].g

g −→a
!v,b
−−→ f

(Asym2V)
!v ,..,!v ,a
−−−−−−−−→
f' !w ∈/ a n ≥ 0

(Seq)

g where x :∈ f −→a
[v/x].g'
f >x> g −→a
f' >x> g | [v1/x].g | .. | [vn/x].g

Consider the following two examples, introduced by Kitchin et al. [18]:

EmailNews(d) = (CNN (uk, d) | BBC(uk)) >x> email(me, x) EmailNewsOnce(d) = email(me, x) where x :∈ (CNN (uk, d) | BBC(uk))

4 These operations appear to be closely related to Friedman and Wise’s frons constructor [16].

Here, uk and me are constant values, x and d are variables, and CNN (uk, d), BBC(uk) and email(me, x) are site calls that retrieve the news for UK on the day d from CNN, retrieve the news for UK from BBC for today, and send an email to me with value x. Thus EmailNews(d) and EmailNewsOnce(d) invoke the news service from CNN and BBC and send the content by e-mail to me. The difference between these two expressions is that EmailNews sends the news from both CNN and BBC (when the services reply), while EmailNewsOnce e-mails only the value of the first reply, ignoring the second reply.
The expression EmailNewsOnce reduces as follows. Here we assume a and b are fresh, v is the value returned by the BBC site, and v' is the value returned by the Email site.

email(me, x) where x :∈ (CNN (uk, d) | BBC(uk))
BBCa(uk)
−−−−−−→ email(me, x) where x :∈ (CNN (uk, d) | ?a)
−−−a−?−v −→	email(me, x) where x :∈ (CNN (uk, d) | let(v))
−−−τ−−→	email(me, v)
Emailb(me,v)
−−−−−−−−→ b
b?v'	'
−−−−−→	let(v )
!v'
−−−−−→
Infinite behaviour can be described by recursive definitions, as the following example shows.

Metronome = Signal | (Rtimer(1) >x> Metronome) EmailNewsFrequently(d) = Metronome >x> EmailNewsOnce(d)
Metronome is an Orc expression that sends a signal returned by Signal every time unit. The site Rtimer(t) waits t time units before returning a signal. Therefore, EmainNewsFrequently calls EmainNewsOnce every time unit, which in turn sends me an email from either CNN or BBC.

Reo
Reo is a powerful coordination model arising from the propagation of synchroni- sation and other constraints imposed by individual channels through connectors formed by plugging channels together, in combination with mutual exclusive data merging and synchronous data replication through nodes. A key characteristic of Reo is that synchrony is propagated through composition. We present the semantics of Reo connectors in an adaptation of the Q-automata model [11], which in turn extends constraint automata [8].
Firstly, we assume that connectors are defined over a denumerable set of port names, Port .  Each connector C will have a set of input ports I ⊆ Port , and



Table 1
Arities and behaviour of some Reo primitives

a (disjoint) set of output ports, O ⊆ Port . 5 The input and output ports of a connector define its arity, denoted C : I → O. We define Names(C) to be I ∪ O.
The semantics of a connector C is given as a reduction relation of the form C −N→ C', where N is a (partial) map from the set of boundary nodes to the values that flow through those nodes. For example, we write I(v), O(v) to denote the map
from the boundary nodes I and O to the value v, and we write nodes(N ) to denote the domain of N . We say that C evolves to C' and fires nodes nodes(N ). C' is
the connector resulting from the particular step. Typically, C and C' will have the same primitives, just in different states. Table 1 presents some Reo primitives, their arity, and axioms describing their behaviour. Each axiom gives a valid reduction of
the corresponding primitive.
The composition of connectors C and C' is denoted by C ∗ C'. Well-formedness of the composition and the calculation of its arity is given by the following rule:
C : I → O	C' : Is → Os

Iss def
s	ss def	s	s



C ∗ C' : (Iss \ Oss) → Oss

This rule expresses that output and input nodes are plugged 1 : n, i.e., each output node can be plugged into multiple input nodes. Regarding the behaviour, output

5 For the purpose of this paper, we assume that primitive connectors are not plugged into themselves.

nodes act as n-replicators, where data must flow to every connected input channel end. If n = 0, we assume that the data is consumed. The formal description we present differs slightly from the original description of Reo, without fundamentally changing anything, in order to simplify our formal results.
Notation 1 Given a map N and a set P. With a slight abuse of notation, deﬁne
def	def
N ∩ P = {(n, d) ∈ N | n ∈ P} and N \ P = {(n, d) ∈ N | n ∈/ P}.
The following two rules give the semantics for the composition of connectors C1 : I1 → O1 and C2 : I2 → O2. Note that a node set can only fire if it fires in both C1 and C2, with the same data value flowing in both cases.

C  N1	'
N2	'
N1	'

 1 −−→ C1  C2 −−→ C2  N1 ∩ Names(C2)= N2 ∩ Names(C1)	 C1 −−→ C1 N1 ∩ Names(C2)= ∅ 

C ∗ C
N1 ∪N2
C' ∗ C'
C ∗ C
N1 C' ∗ C

1	2 −−−−−→ 1	2	1	2 −−→ 1	2
Note that we do not address causality issues here, because the connectors we will build deliberately avoid causal loops. These can be trivially dealt with. We also introduce a restriction operator that hides the output nodes of a connector. Given a connector C : I → O and a set of nodes Ω, define C TΩ= C : I → (O\Ω).
Consider the services Politics, Sports and Email, that return news about pol- itics or news about sport, or sends an email of a given message, respectively. In Fig. 1 we present a connector that coordinates these three services. Initially the connector receives data from the Politics and then the Sport services, and forwards data from Politics to the Email in a single step. After that, the data previously sent by the Sport service is sent to the Email. This way we guarantee that the two services alternate, and that we can only have politics news if there is also sports news.

Fig. 1. Example of a Reo connector

Formally, we consider two different states of the connector:
Ord = (FIFO1Sport,X ∗ SDrainPolitics,Sport ∗ MergerPolitics,X,Email) TEmail  and
Ord(x) = (FIFO1Sport,X (x) ∗ SDrainPolitics,Sport ∗ MergerPolitics,X,Email) TEmail. The former corresponds to the connector depicted in Fig 1, while the latter cor-
responds to the same connector when the FIFO1 channel has data is full with data x.  Using the rules above, we can calculate the connector’s arity, Ord :
{Politics, Sport}→ Email, and behaviour:
Ord Politics(v),Sport(w),Email(v) X(w),Email(w)
Ord x −−−−−−−−−−→ Ord.

These transitions represent the only possible behaviour of the connector, given the axioms of each primitive and the reduction rules. The first transition goes to a state where the buffer is full, and indicates that data is flowing on the nodes Politics,

Sport, and Email. The second transition goes back to the original state, and indicates that data is flowing on nodes X and Email.

A Static Encoding of Orc in Reo
We present two translations of Orc into Reo. The first translation, the merged-output encoding, attempts to directly model Orc expressions, in particular, by merging the multiple results of a sequential composition. The second encoding, the multiple- output encoding, takes an alternative approach, duplicating the circuitry for each output of the Orc expression. Note that we can only encode non-recursive Orc expressions into a finite Reo connector. For the remainder of the paper, we restrict ourselves to non-recursive Orc expressions, denoted Orc−. Basically, we assume that every invocation of a definition has been expanded. We also assume the existence of a Reo component, with one input and one output node, for each primitive site. Initially, the component is ready to receive some data over the input node; after an unspecified amount of time, it may return a result over the output node.
Before presenting the encodings, we will introduce some useful Reo connectors. We give some formal properties concerning the second encoding on Section 2.4, and use weak bisimulation to prove its soundness with respect to Orc’s semantics.

Warming up
We now introduce the Reo connectors used in the translations. Each connector is defined by presenting its arity and axioms, although they could equally have been defined as the composition of primitives. 6 The connectors are defined in Table 2.
Table 2 is divided into two parts. In the upper part we present three connectors, which play a roˆle similar to nodes in that they connect a single output node to multiple input nodes, except that their behaviour differs. Firstly, an Exclusive Router receives data in the input node and sends data to exactly one of the output nodes synchronously. If more than one output node can receive the data, a non- deterministic choice is made. Secondly, an Inclusive Router is a variation of the Exclusive Router that can send data to multiple output nodes instead of performing a non-deterministic choice. Third is a connector which acts like a node for one step, and then prevents flow for eternity, by becoming the connector in the fourth row.
Now consider the lower part of Table 2.  Connector Tn tuples n values.  It is a synchronous connector, i.e., inputs and outputs succeed at the same time. Connector Cp always return a constant value p. Connectors Var and Var(x) represent a (possibly undefined) variable. It is a buffer that replaces its content when new data arrives to the connector, and can output its content as many times as required. The last connector, Pn, coordinates n inputs into a single output. Data flows only if one or more input nodes and the output node can flow.
Before continuing with the encoding, an issue regarding the use of variables in
Reo needs to be resolved. A variable can be read by multiple connectors, all at

6 The tupling connector is an exception, as none of our primitives are capable of data manipulation.



Table 2
Definition of some Reo connectors.

the same time or just some at each time. To coordinate access to a variable, we propose two different approaches in Fig. 2: (a) replicate the output of the variable when necessary, or (b) replicate the input and create a variable connector for each possible access. The second approach has the advantage that the access to a variable does not require any synchronisation between the connectors that may also access the variable. Although more storage locations are required, it reduces the cost of coordination.

(a)	(b)
Fig. 2. (a) Replication after the storage of a variable. (b) Replication of the storage of a variable.


Merged-Output Encoding
This section presents an encoding of an Orc− expression into a connector which merges the multiple outputs of a parallel composition via a single output node. This is the most natural approach, but it is, as we shall see, problematic. We therefore only give an informal presentation, reserving a completely formal description for our second encoding.
An expression h ∈ Orc− is encoded as a connector with arity {I, X1,..., Xn}→ 
O, depicted in Fig. 3(a), where the Xi corresponds to the free variables of h. For ex- ample, the encoding of the expression (CNN (uk, d) | BBC (uk)) >x> email(me, x)

is presented in Fig. 3(b), recalling that d is a variable, whereas uk and me are constants. The connector starts by receiving data on input node I and buffering it. Site BBC can then be called, while site CNN needs to wait until data is available on node D to be called. The results from the site calls are stored in the RVar com- ponent one at a time, which subsequently provides the value to site email, once for each value returned by BBC and CNN .


(a)	(b)
Fig. 3. Encodings into Reo connectors with a single output: (a) a general Orc expression; (b) a specific Orc expression (CNN (uk, d) | BBC (uk)) >x> email(me, x). RVar is a resettable variable. It acts like a variable (e.g., Var from Section 2.1), but it cannot be updated until the reset (top) node is fired, removing the value of the variable.



The example encoding reveals the main problem of this approach. The outputs of CNN (uk, d) | BBC (uk) are forwarded to a single instance of email, serializ- ing the execution of email. As a consequence, it is possible that CNN finishes before BBC , but that site email hangs on the result of CNN , preventing email from even getting the result from BBC . The semantics of Orc [18], however, dic- tate that (CNN (uk, d) | BBC(uk)) >x > email(me, x) is strongly bisimilar to (CNN (uk, d) >x> email(me, x)) | (BBC(uk) >x> email(me, x)), which means that email is not serialized and could respond to either results from CNN or BBC irrespective of their ordering or failure. This, however, is not true for the connec- tors resulting from the encoding. In the next section, we overcome this problem by duplicating parts of the connector.
Another solution for this termination problem is possible by introducing some observational behaviour corresponding to when a service cannot return any value, as done by Bruni et al. in their encoding of Orc into Petri Nets [7]. This could be achieved, for example, by adding timeouts to each primitive site call. An extension for Reo that includes connectors capable of dealing explicitly with time was proposed by Arbab et al. [1]. The authors introduce the Timed Constraint Automata, which can be used to formally model the timeouts in Reo, allowing a precise definition of a component that fails to return any value. In our case we could attach a timeout connector to the input node of each site call, such as an expiring FIFO1 channel, which loses the contents of the buffer after a certain time. Using these ideas we could also encode recursive Orc expressions, but we chose not to use this approach because we consider it to be less faithful to Orc’s semantics, where the failure to return a value cannot be observed.

Multiple-Output Encoding
A more faithful encoding of Orc− expressions presented in this section. The encoding of an expression such as f >x> g duplicates g for each output of f . The encoding is possible because we can obtain an upper bound on the number of outputs of an Orc− expression—this is not possible with full Orc. The following lemma captures this property.
Lemma 2.1 Deﬁne function (#) on Orc− expressions (and internal representa- tions: ?k, let(v) and 0), and on sets of output actions as follows:


#(f | g)	= #(f )+ #(g)
#(f >x> g)	= #(f ) × #(g)
#(g where x :∈ f ) = #(g) #(M (v1,..., vn))	= 1
#(?k)	= 1
#(let(v))	= 1
#0	= 0 

#(!v1,..., !vn, a) = n
where !w ∈/ a


This function gives an upper bound on the number of outputs produced by an Orc−
expression, i.e., for any Orc− expression h, h −→a  h' implies #h ≥ #a + #h'.
Proof Outline. Straightforward induction, observing that substitution of values for variables has no effect on the maximum number of outputs produced.	 

Corollary 2.2 Let f ∈ Orc−, and f
Then #f ≥ #a1 + ··· + #an + #f (n).
−a→1
f' −a→2
· · · −a→n
f (n) be a possible trace.

We now define a function [· ] which converts an expression f ∈ Orc− into a Reo connector. The arity of resulting connector will be {I}∪ V → O, where I denotes the main input node, V denotes a set of nodes corresponding to the free variables of f , and O is the set of output nodes. Node I is used to initiate the connector, though nodes in V can be fired beforehand, which corresponds to the setting of these variables. The function [· ] is defined inductively on the shape of Orc expressions, in such a way that the number of output nodes is given by function (#) defined above. The encoding is defined in Fig. 4, based on the following primitives.

Symmetric Parallel Composition:
 θ,α,β : I → {If , Ig}
Initially θ = α = β = 0. The intuition behind the connector θ,α,β, illustrated in Fig. 4(a), is that it is initialized by flow in node I, after which sends an initialization signal on nodes If and Ig. The data is buffered in buffers that can fired nodes If and Ig as soon as they are ready to be fired. As [f | g]] =  0,0,0 ∗ F ∗ G, firing If and Ig will trigger the connectors F and G. The behaviour of θ,α,β is depicted in the diagram below.


[[f | g]] = (F ∗ 0,0,0 ∗ G) TOf ∪Og	where


 θ,α,β :
I → {If , Ig}
:=	F := [f ]] : {If }∪ Vf → Of
G := [g]] : {Ig}∪ Vg → Og



(a)
[[f >x> g]] = (F ∗ |⟩x|⟩0,⟨0,...,0⟩ ∗ G1 ∗· · · ∗ Gn) TSn





Ogi 

|⟩x|⟩θ,⟨α1,...,αn⟩ : {I, Of1,..., Ofn}
→ {If , Ig1,..., Ign, X1,..., Xn}
where
:=	F := [f ]] : {If

}∪ Vf









[[g where x :∈ f ]] = (Wx






(b)
∗ F ∗ G) TOg
→ {Of1,..., Ofn}
for j ∈ {1,..., n}:
Gj := [[[xj/x].g]] :
{Igj}∪ Vg → Ogj
⎩ xj is a fresh variable name


where

x θ,α,β,δ
: {I, Of1,..., Ofn} :=
→ {If , Ig,X}

F := [f ]] : If ∪ Vf
→ {Of1,..., Ofn}
G := [g]] :
Ig ∪ Vg → Og


(c)
[[M (x1,..., xn, v1,..., vm)]] = (M0,⟨0,...,0⟩,V,0,0 ∗ Mk) T!k
where
Mθ,⟨α1,...,αn⟩,V,β,δ : {I, X1,..., Xn, ?k} :=	V = ⟨v1,..., vm⟩

→ {Mk, !k}









(d)
x1,..., xn are variables v1,..., vm are values for j ∈ {1,..., n}:
:=	0 if θ = αj = 0 1 otherwise
Mk : Mk →?k
:= Reo component of site M
k is fresh


Fig. 4. Definition of the encoding function [· ] from Orc into Reo, where α, β, θ, and δ stand for the value of buffers (FIFO’s or One Time nodes), whose value can be 0 (no value), 1 (some value), or a constant value. Nodes in the environment are associated with the variable with the same name in lower case.

 ,	I(v)
r ~  ~ 
1,v,v ¸  ¸¸¸
If (v)
r, ~¸  ~ ,

Ig (v)
¸I¸f¸(v¸),Ig(v)
¸¸¸¸
Ig (v)

r~ J 
If (v)
¸z˛J 

,¸ 1,v,0~ ,
r, ~¸  ~ ,


Sequential Composition:
|⟩x|⟩θ,⟨α1,...,αn⟩ : {I, Of1,..., Ofn}→ {If , Ig1,..., Ign, X1,..., Xn}
The connector is illustrated in Fig. 4(b). The main idea is to execute the encoding of f when data flows though the input node I, and to buffer each of its outputs in a different FIFO1 channel. Each of these FIFO1 channels is connected to a different instance of the encoding of g, which can be executed in parallel after the corresponding FIFO1 channel is filled.
To make the behaviour easier to describe, we partition |⟩x|⟩θ,⟨α1,...,αn⟩ into n +1 different connectors corresponding to unconnected parts of the main connector:

|⟩x|⟩θ,⟨α ,...,α ⟩ = |⟩x|⟩F ∗ |⟩x|⟩G1 ∗· · ·∗ |⟩x|⟩Gn,
1	n	θ	α1	αn

where |⟩x|⟩F : I → I , |⟩x|⟩Gj : O
→ {I
,X }, and 1 ≤ j ≤ n. Initially θ = α =

θ	f	αj	fj 
gj	j	1

... = αn = 0. The possible behaviour of each of the subparts is the following:

|⟩x F
I(v),If (v)
x|⟩F

|⟩0 −−−−−−→ |⟩	1

|⟩x|⟩Gj
Ofj (v),Xj (v)
x|⟩Gj
Igj (v)
x|⟩Gj,

0 −−−−−−−−→ |⟩	v −−−→ |⟩	0
where 1 ≤ j ≤ n. This means that |⟩x|⟩0,⟨0,...,0⟩, when triggered by node I, also triggers the input node of F. For each output of F (in node Ofj), the connector
|⟩x|⟩Gj fires also node Xj (making the contents of variable x available in G), and
evolves to a configuration where the input node of Gj can be fired when possible.
Asymmetric Parallel Composition:

x θ,α,β,δ
: {I, Of1,..., Ofn}→ {If , Ig,X}

The connector is illustrated in Fig. 4(c). The intuition is that the encodings of f (F) and g (G) are executed in parallel, as described in the symmetric parallel composition. The output nodes of G are merged in such a way that only the first output value will flow through node X, which will be connected to F where the
value of x is used. The output nodes of the connector Wx	are only the output

nodes of F.
To make the behaviour easier to describe, we partition Wx
into two different

connectors corresponding to unconnected parts of the main connector:

x θ,α,β,δ
←
θ,α,β
∗ W→,

where W←	: I → {If , Ig} and W→ : {Of1,..., Ofn} → {X}. Initially θ = α =
β = δ = 0. The behaviour of W←	is the equivalent to the behaviour of  0,0,0. The

possible behaviour of W→ is the following:

W→ O,X(vk)	→
0 −−−−−→ W1 ,
where O ⊆ {Of1(v1),..., Ofn(vn)}, and vk ∈ {v1,..., vn} such that Ofk(vk) ∈ O. The choice of which node in {Of1(v1),..., Ofn(vn)} will write into node X is made
by connector Pn (see Table 2). This means that Wx	∗ F ∗ G behaves similarly
to  0,0,0 ∗ F ∗ G, except that the output nodes of F trigger the connector W→. The
output nodes of Wx	are restricted to the output nodes of F. This connector
allows data to flow to node X, which is part of the environment of G and is made
available to this instance.

Site call:
Mθ,Σ,V,β,δ : {I, X1,..., Xn, ?k}→ {Mk, !k}
The connector is illustrated in Fig. 4(d). The main idea is to tuple all the arguments required by site M before the site is executed. As in previous cases, we partition this connector into two different connectors corresponding to unconnected parts of M to make the behaviour easier to describe:

Mθ,Σ,V,β,δ = M←
→
β,δ

Initially θ = β = δ = 0 and Σ = ⟨0,..., 0⟩. The behaviour of each of the subparts is described below:

M←	−N−→1  M←	N2
Nj  M←
I(v),Mk(v) M←

0,Σ0,V
0,Σ1,V
−−→ · · · −−→
0,Σj ,V
−−−−−−→
1,∅

M→  Mk(v)	→  !k(v)	→
0,0 −−−→ M1,v −−−→ M1,0
where v = ⟨v1,..., vn⟩ is a tuple of data values, and for each i ∈ {0,..., j}, Ni ⊆
{X1(v1),..., Xn(vn)}, ∪iNi = {X1(v1),..., Xn(vn)}, Σj = ⟨α' ,..., α' ⟩ such that,
1	n
for i ∈ {1,..., n}, α' /= 0, and for each Xm(vm) ∈ Ni, Σi = [vm/αm].Σi−1. This
means that initially the empty FIFO1 channels in M←	need to become full by
the firing of the corresponding nodes. Only then node I can be fired, together with node Mk which triggers component Mk. When this component returns data on node
?k, the value is stored in a FIFO1 channel, and in the next step the value is output by node !k.
Example revisited
Recall the Orc expression (CNN (uk, d) | BBC(uk)) >x> email(me, x) presented in Section 1.1. We presented its encoding with merged-outputs in Section 2.2. Fig. 5 presents the connector [[(CN N (uk, d) | BBC(uk)) >x> email(me, x)]]. Data flowing through the input node I corresponds to the start of execution of the Orc expression, and flowing data through the input node D corresponds to the binding of variable d.
Note that the resulting connector is not the most simple one, in the sense that there are consecutive FIFO1 channels that could be merged into a single one, and



Fig. 5. Example of the encoding of (CNN (uk, d) | BBC(uk)) >x> email(me, x)

there are some redundant One Time Nodes. If we wanted to actually run the encoding of an Orc expression we could remove the One Time Nodes, relying on the assumption that site calls only return once, and the encoded connector is only executed once. Without these assumptions, the One Time Nodes are needed to derive a bisimulation between Reo and Orc−.

Soundness
In this section we provide several important results about the translation presented in Fig. 4 that are required to understand and prove the main result, namely that every h ∈ Orc− is weakly bisimilar to its encoding in Reo.
Define the function · to map labels in Reo’s operational semantics to base events
of Orc as follows:	^


M^(v) = M (v)
?^k(v) = k?v	!^k(v) = !v

k	k
^∅ = ∅	a^, b = ^a ∪ ^b	^a = τ otherwise,
where Mk, ?k and !k correspond to nodes in the Reo connector obtained from the translation of a site call M .
Lemma 2.3 Let h ∈ Orc−. Each node in Names([[h]]) can be ﬁred at most once.
This result can be proved by structural induction. It follows from the presence of One Time Nodes connected to input and output nodes, and from the dependence between input and output nodes.
Using this property, we relate the order in which input and output nodes are fired in Lemma 2.4.
Lemma 2.4 Let h ∈ Orc− and [[h]] = H : {I} ∪ V  → O.	For any trace
⟨a0, a1, a2,.. .⟩ of sets of ﬁred boundary nodes of [[h]], we claim that:
I ∈ an	⇒	O ∩ an = ∅, and for 0 ≤ j < n, aj ⊆ V and O ∩ aj = ∅.

This lemma can also be proved by structural induction on h. It is enough to verify that, for each case of the encoding function, the firing of the main input must precede the firing of the output node. By Lemma 2.4, the input and output nodes can be fired only once, so every action a occurring before the input node is fired is such that a = ∅ or a = τ , because a can only refer to input or output nodes.

Since the main input node of the encoding of an Orc− expression can only be fired once, we introduce some notation to distinguish the states of the connector before and after the input node is fired. This simplifies the comparison of the evolution of Orc− expressions with different configurations of the encoded connector.
Definition 2.5 Let f ∈ Orc− and F = [[f ]] : {If } ∪ Vf → Of . We define two partitions of reachable configurations of F :

F−I =  F' | F −a→1
F +I = F' | F −a→1
· · · −a→n
· · · −a→n
F' ∧ If F' ∧ If
∈/ nodes(a ∪ ... ∪ a ) ∧ n ≥ 0
∈ nodes(a1 ∪ ... ∪ an) ∧ n ≥ 1}.

The first set consists on the configurations of F after zero or more steps until the input node is fired, and the second set consists on the possible configurations after the input node is fired. Combining Definition 2.5 with Lemmas 2.3 and 2.4, we arrive at the following corollary.
Corollary 2.6 Let f ∈ Orc− and F = [[f ]] : {If }∪ Vf → Of . Then:

If H ∈ F−I, then H
−→a
H' implies nodes(a) ∩ Of = ∅, and for H'' ∈ F−I,

H'' −→a
H implies that either a = ∅ or a = τ, and I
∈/ nodes(a).

^	^	f

The main result of this section is the existence of a weak bisimulation between an Orc− expression and its translation into Reo. We define the notion of weak transition and weak bisimulation inspired by Milner’s definition of weak bisimilarity [21].
Definition 2.7 Let Q and Q' be Orc expressions (or Reo connectors), and a be a set

of actions. We write Q =a⇒ Q' to denote Q(−→τ )∗ a'
(−→τ )∗Q', whenever a' = a ∪ {τ }

or a' = a\{τ}, i.e., Q evolves to Q' after performing a transition a ∪ {τ } or a\{τ},
and any number of τ transitions before or after this transition. When a = {τ}, then
=a⇒d=ef (−→τ )∗.
Definition 2.8 Let f be an Orc expression, C be a a connector, and a ⊆ BaseEvents. Define weak bisimulation ∼ as a relation between Orc expressions and connector (configurations), such that f ∼ C whenever:
a	'	'	b	'	'	'
if f −→ f , then ∃b, C such that ^b = a, C =⇒ C and f ∼ C ; and
if C −→a  C', then there is an expression f' such that f =ba⇒ f' and f' ∼ C'.
We introduce Lemma 2.9 to capture that substituting a variable in an Orc ex- pression is the same as triggering the input node associated with the corresponding variable.
def
Lemma 2.9 Let h ∈ Orc− and hv = [v/x].h, where x is a free variable in h, and v
is a data value. Substitution does not change the behaviour of the translation, i.e.,


If h ∼ [[h]] and [[h]] X(v)
Hv then hv
~ Hv,

where Hv is obtained by sending value v in node X.

Proof Outline. We start by verifying that the only relevant case is when h = M (p), and x ∈ p, because that is the only place where x can be used. We prove that, in this case, the possible behaviour of [h ] is the same as Hv, concluding that h ∼ [[h]] implies hv ∼ Hv.	 
Theorem 2.10 is the main result of this section, which relates Orc expressions with their Reo encodings. The proof uses the lemmas introduced above, in par- ticular, Corollary 2.6 deals with inductive applications of the construction, and Lemma 2.9 handles the base case.
Theorem 2.10 Let h ∈ Orc−. We claim that h ∼ [[h]] : I ∪ V → O, where V
contains only nodes associated to free variables of h.
Proof Outline. This theorem follows by induction on the structure of h. For each case, we define the relation ∼, and prove that it is a bisimulation.	 

Encoding Reo into Orc
The encoding from Reo connectors into Orc expressions is more complex and, unlike the dual encoding, cannot be achieved in a compositional manner. Due to lack of space, we only present a brief discussion of this encoding, providing enough intuition for the limitations.
The expressiveness of Orc is closely related to the set of base primitive sites
considered. An example use of more complex primitive site calls can be found in the work by Cook et al. [14], where the authors encode in Orc the set of workflow patterns proposed by Van der Aalst [2]. A similar approach could be attempted
to encoding Reo into Orc, using higher level primitive site calls that can synchro- nize with each other, but the encoding will not be compositional. For example, C(SyncA,B ∗ M ergerB,C,D) does not correspond to C(SyncA,B) | C(M ergerB,C,D), since in the second case it is possible for data to flow from A to B, whereas in Reo this could not occur if there was also data flowing from C to D.
In any case, the encoding would correspond roughly to the implementation of one of the known algorithms to combine the synchronous constraints imposed by Reo primitives, such as Connector Colouring [9]. The main troublesome issues are: inversion of control : in Orc the sites cannot initiate contact with the orchestrator, which is the opposite of how Reo is; data structures for colouring tables, channels, connector topology, etc.: Orc provides no data structures which could be required to manage the possible behaviours in a Reo connector; propagation of synchrony : as Orc is highly asynchronous, implementing the synchrony propagation in Reo either needs transactions or global consensus, which cannot be implemented without adding sufficiently expressive primitives to Orc, and both are fragile in the presence of failure; handling failure: if external sites implement key ingredients required to encode Reo, these sites must be responsive and must avoid failure.
The encoding of Orc into Reo is local, in the sense that each Orc combinator and each site call in an Orc expression can be independently translated, and the composition yields the encoding of the main expression. On the other hand, we

anticipate that encoding of Reo into Orc would be global, since each Reo connector needs to be considered as whole, and the encoding becomes an implementation of a Reo engine. An interesting question is to determine precisely which set of Orc primitives would be needed to give a local encoding of Reo in Orc.
Cook et. al. presented a synchronous semantics to Orc [13] where all events other than external response are processed as soon as possible. This allows, for example, to impose an order by which two primitive sites are called, which was not possible with the asynchronous semantics. However, it is still not possible to describe atomic blocks that can either succeed or rollback if one of the actions is not possible. A stronger model, for example, a transactional model, is required to capture the synchrony imposed by Reo semantics.
These issues regarding synchronous and asynchronous communication can also be found in the context of the π-calculus. To have synchrony in the π-calculus means that it is possible to constrain a fixed-sized tuple of more than one channel such that each element can only be executed if all the other elements of this tuple can also be executed. This notion of synchrony is closely related to synchrony in Reo, since Reo allows for the definition of constraints regarding the firing of more than one port in the same step. Unlike Reo, the π-calculus does not propagate synchrony through composition. In this area Palamidessi [23] compared the expressiveness of synchronous and asynchronous π-calculus, saying that the synchronous π-calculus cannot be encoded in the asynchronous π-calculus. Carbone and Maffeis [12] ex- tended this result proving that the expressive power of synchronous π-calculus that can synchronize at most n channels is less than of the one that can synchronize at most n + 1 channels. These results suggest that Reo cannot be encoded in Orc, because Orc is asynchronous whereas Reo can synchronize an arbitrary number of ports.

Discussion
We now compare Orc and Reo on some issues of philosophy and design.
Focus of Control In Orc control lies with the orchestrator: an Orc expression initiates contact with external sites. On the other hand, Reo assumes that con- trol is initiated externally to a connector by a component. The take or write is subsequently handled by the connector. This is how Reo coordinates, by control- ling when takes and writes succeed, though from the perspective of web services, control is inverted.
Component/Service Instantiation In Reo components are attached externally to a connector, whereas Orc can dynamically initiate contact with services. Orc is thus more dynamic, although it is tightly bound to the actual sites being called. These limitations seem easy to lift.
One-off interaction vs streams Orc expressions unfold over their life-time, so each piece of syntax is reduced once and each site call is performed once. On the other hand, Reo establishes rigid connections between parties, as it makes the

assumption that parties will continuously communicate.
Dynamics As an Orc expression reduces, its ‘configuration’ changes dynamically. For instance, f >x> g, creates a new instance of g for each value produced by
f . This was encoded in Reo by calculating a bound on the number of values produced by f and duplicating the circuitry for g. As Reo’s connectivity is more or less fixed, and Orc expressions ‘fire’ only once, our encoding introduces a lot of circuitry that is used only once. Reo does offer some operations for plugging
and unplugging primitive connectors, but no decent high-level abstractions for dynamic reconfiguration and subsequent garbage collection of connectors exist. In recent work by Koehler et al. [19] the authors present a high level approach
to the rewriting of connectors, which can be the basis for more dynamically reconfigurable connectors.
Asynchrony vs synchrony Orc offers highly asynchronous connectives that gracefully deal with failing sites. Reo is highly synchronous and susceptible to fail- ure. Recall that failure can also be handled with timed connectors, as mentioned in Section 2.2, although this solution is less transparent, as failure must explicitly be handled. In principle, synchrony (or in any case, atomicity) can form the basis of high-level abstractions. Much of this work remains to be done. In fact, the jury is still out regarding whether synchrony is a good idea in a distributed setting, even though it has the potential to offer better abstractions.

Related Work
Bruni et al. [7] present a static encoding of Orc into Petri nets. Their encoding is not, however, faithful to the Orc model, as it assumes that each primitive site returns either a valid value or some value to state that it will not return a value. Orc, on the other hand, gracefully deals with sites which do not return values. Our encoding into Reo more faithfully handles the absence of dataflow. Our encoding also considers the data values passed around, in contrast to Bruni et al.’s encoding, which passes only Petri net tokens. Bruni et al. also present an encoding of full Orc into the Join calculus—an expressive calculus for concurrent processes based on the homonymous process calculus. The Join calculus provides a simple support for distributed programming, intentionally avoiding some communication constructs that are difficult to implement in a distributed setting. This calculus supports some synchrony, by introducing patterns that correspond to multiple events which must be all present so the pattern can be recognized. However, the Join-calculus is not highly synchronous like Reo, as it does not propagate synchrony through composition. The relation between the Join calculus and Reo is left for future work.
Many other coordination languages exist, and these are compared in some ear- lier surveys [22,3]. We can fairly safely say that few (coordination) languages of- fer the degree of synchrony that Reo offers. Obvious exceptions are synchronous languages such as Esterel [5]. Such languages are useful for programming reactive systems, though seem not to be directly useful for coordinating distributed systems. To remedy this situation, the GALS (globally asynchronous, locally synchronous)

model [10] has been adopted, whereby local computation is synchronous and com- munication between different machines is asynchronous.
As with Orc, the GALS model adopts the arguably correct view that distributed systems must be programmed asynchronously.  Reo is also able to express such
distinctions, and more, through the many choices of synchrony or asynchrony—the result depends upon how a connector is deployed to a distributed system. Reo claims that instead of synchrony, it is really implementing atomicity, and hence a
simple form of transaction [4]. This has not yet been convincingly demonstrated. A method for comparing expressiveness was proposed by de Boer and
Palamidessi [15], where they introduce a notion of language embedding refined with
some “reasonable” conditions. Brogi and Jaquet used this method to compare co- ordination models with Linda-like operations and a shared dataspace [6]. However, it is not clear how Reo or Orc would fit this setting.
Conclusion and Future Work
We have briefly compared Orc and Reo, by encoding Orc− expressions into Reo, by discussing the encoding the other way, and by comparing a number of design decisions. Orc is highly asynchronous and deals well with failure. Reo supports a high degree of synchrony, and potentially high-level abstractions. There is a lot more we could have said. An obvious omission is a comparison of the efficiency of the two models. Unfortunately, both implementations are too preliminary for this to have any real meaning. To extend our encoding to full Orc requires either recursively-defined or dynamically reconfigurable Reo connectors. These extensions to Reo are interesting on their own, and are the subject of future work.

References
Farhad Arbab, Christel Baier, Frank de Boer, and Jan Rutten. Models and temporal logical specifications for timed component connectors. Software and Systems Modeling (SoSyM), 6(1):59–82, March 2007.
W. M. P. Van Der Aalst, A. H. M. Ter Hofstede, B. Kiepuszewski, and A. P. Barros. Workflow patterns.
Distrib. Parallel Databases, 14(1):5–51, 2003.
Jean-Marc Andreoli, Chris Hankin, and Daniel Le Metayer, editors. Coordination Programming: Mechanisms, Models and Semantics. Imperial College Press, 1996.
Farhad Arbab. Reo: a channel-based coordination model for component composition. Mathematical Structures in Computer Science, 14(3):329–366, 2004.
G. Berry. The Foundations of Esterel. MIT Press, 2000.
Antonio Brogi and Jean-Marie Jacquet. On the expressiveness of coordination via shared dataspaces.
Sci. Comput. Program., 46(1-2):71–98, 2003.
Roberto Bruni, Hern´an C. Melgratti, and Emilio Tuosto. Translating Orc features into Petri nets and the Join calculus. In Mario Bravetti, Manuel Nu´n˜ez, and Gianluigi Zavattaro, editors, WS-FM, volume 4184 of Lecture Notes in Computer Science, pages 123–137. Springer, 2006.
Christel Baier, Marjan Sirjani, Farhad Arbab, and Jan Rutten. Modeling component connectors in Reo by constraint automata. Science of Computer Programming, 61(2):75–113, 2006.
Dave Clarke, David Costa, and Farhad Arbab. Connector Colouring I: Synchronisation and context dependency. Sci. Comput. Program., 66(3):205–225, 2007.


D. M. Chapiro. Globally-Asynchronous Locally-Synchronous Systems. PhD thesis, Stanford University, October 1984.
Tom Chothia and Jetty Kleijn. Q-automata: Modelling the resource usage of concurrent components. In The 5th International Workshop on Foundations of Coordination Languages and Software Architectures (FOCLASA 2006), 2006.
Marco Carbone and Sergio Maffeis. On the expressive power of polyadic synchronisation in pi-calculus.
Nord. J. Comput., 10(2):70–98, 2003.
William R. Cook and Jayadev Misra. Computation orchestration, a basis for wide-area computing.
Software and Systems Modeling, 6(1):83–110, 2007.
William R. Cook, Sourabh Patwardhan, and Jayadev Misra. Workflow patterns in Orc. In Paolo Ciancarini and Herbert Wiklicky, editors, COORDINATION, volume 4038 of Lecture Notes in Computer Science, pages 82–96. Springer, 2006.
Frank S. de Boer and Catuscia Palamidessi. Embedding as a tool for language comparison. Information and Computation, 108(1):128–157, 1994.
Daniel P. Friedman and David S. Wise. An indeterminate constructor for applicative programming. In Conference Record of the Seventh Annual ACM Symposium on Principles of Programming Languages, Las Vegas, Nevada, pages 245–250, January 1980.
David Gelernter. Generative communication in Linda. ACM Trans. Program. Lang. Syst., 7(1):80–112, 1985.
David Kitchin, William R. Cook, and Jayadev Misra. A language for task orchestration and its semantic properties. In Christel Baier and Holger Hermanns, editors, CONCUR, volume 4137 of Lecture Notes in Computer Science, pages 477–491. Springer, 2006.
Christian Koehler, Alexander Lazovik, and Farhad Arbab. Connector rewriting with high-level replacement systems. In The 6th International Workshop on Foundations of Coordination Languages and Software Architectures (FOCLASA 2007), 2007.
Jayadev Misra and William R. Cook. Computation orchestration: A basis for wide-area computing.
Software and Systems Modeling, 6(1):83–110, March 2007.
Robin Milner. Communicating and Mobile Systems: the Pi-Calculus. Cambridge University Press, June 1999.
George A. Papadopoulos and Farhad Arbab. Coordination models and languages. In M. Zelkowitz (Ed.), The Engineering of Large Systems, volume 46 of Advances in Computers, pages 329–400. Academic Press, 1998.
Catuscia Palamidessi. Comparing the expressive power of the synchronous and the asynchronous pi- calculus. In Proc. of the 24th ACM Symposium on Principles of Programming Languages (POPL), pages 256–265, 1997.
