Electronic Notes in Theoretical Computer Science 211 (2008) 39–50	
www.elsevier.com/locate/entcs

Towards a Notion of Transaction in Graph Rewriting 1
P. Baldana A. Corradinib F.L. Dottic L. Fossb,d,2 F. Gadduccib
L. Ribeirod
a Dipartimento di Informatica, Universita` Ca’ Foscari di Venezia, Venice, Italy
b Dipartimento di Informatica, Universita` di Pisa, Pisa, Italy
c Faculdade de Inform´atica, Pontif´ıcia Universidade Cato´lica do Rio Grande do Sul, Porto Alegre, Brazil
d Instituto de Informa´tica, Universidade Federal do Rio Grande do Sul, Porto Alegre, Brazil

Abstract
We define transactional graph transformation systems (t-gtss), a mild extension of the ordinary framework for the double-pushout approach to graph transformation, which allows to model transactional activities. Generalising the work on zero-safe nets, the new graphical formalism is based on a typing discipline which induces a distinction between stable and unstable items. A transaction is then a suitably defined minimal computation which starts and ends in stable states. After providing the basics of t-gtss, we illustrate the expected results, needed to bring the theory to full maturity, and some possible future developments.
Keywords: Graph transformations, zero-safe nets, transactions.


Introduction
Graphs and graph transformations represent the core of most visual languages [2]. In fact, graphs can be naturally used to provide a structured representation of the states of a system, which highlights their subcomponents and their logical or physical interconnections. Then, the events occurring in the system, which are responsible for the evolution from one state into another, are modelled as the application of transformation rules. Such a representation is not only precise enough to allow the formal analysis of the system under scrutiny, but it is also amenable of an intuitive, visual representation, which can be easily understood also by a non-expert audience.

1 Research partially supported by the CNPq-CNR Project IQ-Mobile II, the EC RTN 2-2001-00346 Seg- raVis, the EU IST-2004-16004 SEnSOria and the MIUR Project ART.
2 Supported by CAPES and CNPq.

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.028

A graph transformation system (gts) consists of a set of rewriting rules, also called graph productions [14]. In their basic formulation, gtss do not provide mechanisms for synchronising or structuring computations, even if, since the left- hand side of productions can be arbitrarily large, a kind of synchronisation among items in the state (graph items) can be expressed.
Along the years several enrichments of the basic framework have been proposed, extending gtss with mechanisms for expressing synchronisation between produc- tions as well as for tackling modularity and refinement issues, which are features deemed necessary for a high-level specification formalism.
Instead, to our knowledge, scarce attention has been devoted to the idea of extending gtss in order to allow the specification of transactional activities. Ab- stractly, a transaction is an activity, involving the execution of a group of events, which can either bring the system to a successful state or fail. In the last case the partial execution of the transaction is discarded and has no effect on the system. In concrete implementations this is achieved with a roll-back mechanism which restores the starting state when a failure is detected.
In this paper we face, from a foundational perspective, the problem of equip- ping graph transformation with mechanisms for modelling transactions. More pre- cisely, we propose a mild extension to the double-pushout (dpo) approach to graph transformation, introducing transactional graph transformation systems (t-gtss), a framework which provides a simple way of expressing transactional activities. Our formalism is influenced by and generalises the zero-safe nets proposal, introduced in [3] to solve an analogous modelling problem in the setting of Petri nets.
The basic tool is a typing mechanism for graphs which induces a distinction be- tween stable and unstable graph items. Given a typed graph, representing a system state, we identify a subgraph which represent its “stable” part, i.e., the fragment of the state which is visible from an external observer. The “valid” computations of a t-gts may start from a completely stable graph, evolve through graphs with unstable items and end up in a new stable state; and the valid computations which are minimal, in a sense to be made precise in the paper, represent transactions.
The paper introduces the t-gtss formalism, provides the basic concepts and illustrates a simple case study. In a concluding section we outline how the internal structure of transactions can be abstracted away by considering the so-called ab- stract gts associated to a t-gts, where unstable items disappear and each distinct transaction becomes a single atomic production, which rewrites the starting stable state to the final stable state. Thus “unfinished” transactions have no counterpart at the abstract level. Finally, we outline future venues of research, pointing out the technical issues which need to be further elaborated upon, such as the precise functorial correspondence between a t-gts and its abstract counterpart.

Typed Graph Transformation Systems
In this section we introduce the basics of the double-pushout (dpo) algebraic ap- proach to graph rewriting [9]. We remark that, although our approach will be

developed for dpo rewriting over directed (multi-)graphs, it could have been easily adapted to other approaches to graph rewriting, e.g., to the single-pushout approach and to different notions of graph (e.g., to hypergraphs, which are used indeed in the example in Section 4).
An essential ingredient of our theory is a typing discipline for graphs which will allow us to distinguish between stable and unstable items in a given graph. Typing for graphs (e.g., [5]) can be seen as a labelling technique, which allows to label each graph over a structure that is itself a graph (called the type graph). The labelling function is required to be a graph morphism.
Formally, a graph is a tuple ⟨V, E, s, t⟩, where V and E are sets of nodes and edges, and s, t : E → V are the source and target functions. Given a graph T , a typed graph G over T is a graph |G|, together with a total graph morphism tG :
|G| → T . A morphism between T -typed graphs f : G1 → G2 is a graph morphism f : |G1| → |G2| consistent with the typing, i.e., such that tG1 = tG2 ◦ f . The category of T -typed graphs and typed graph morphisms is denoted by T -Graph.
Rewriting rules, called (T -typed) productions, are of the kind

lq	rq
q = Lq ← Kq → Rq,
where Lq, Kq and Rq are T -typed graphs (called the left-hand side, the interface and the right-hand side of the production, respectively), and lq, rq are injective morphisms. A rule intuitively specifies that an occurrence of the left-hand side Lq in a larger graph can be rewritten into the right-hand side graph Rq, preserving the interface Kq. Formally, given a typed graph G, a production q, and a match g : Lq → G, a direct derivation δ from G to H using q and g exists, written
q,g
δ : G =⇒ H, if the diagram
lq	rq
q : Lq ,r  Kq 	zR,q
g	k	h
,	,	, 
G ,r  D 	zH,
b	d
can be constructed, where both squares are pushouts in T -Graph.
A graph transformation system is then defined as a collection of rules, over a fixed graph of types.
Definition 2.1 [graph transformation system] A T -typed graph transformation system (gts) is a tuple G = ⟨T, P, π⟩, where T is a graph, P is a set of production names and π is a function mapping production names in P to T -typed productions.
A derivation in a gts G is a finite sequence of direct derivations:

q1,g1
q2,g2
qn,gn

G0 =⇒ G1 =⇒ ... ... =⇒ Gn.

Transactional Graph Transformation Systems
In this section we introduce the basics of transactional graph transformation sys- tems. After discussing the typing discipline which allows to distinguish between

stable and unstable items in a given typed graph, we show how this can be used to define a notion of transaction.
The distinction between stable and unstable items is induced by specifying a subgraph of the type graph, which is intended to represent the stable types.
Definition 3.1 [transactional gts] A transactional gts is a pair ⟨G, Ts⟩, where G is a T -typed gts and Ts is a subgraph of the type graph T of G, called the stable type graph.
Given a graph G typed over T we can single out its stable part S(G), i.e., the subgraph consisting of its stably-typed items only. Formally, S(G) can be defined as the graph typed over Ts obtained by considering the pullback
|S(G)|,˛ι	z|G,|


,,˛	
Ts
, 
zT ,

Without loss of generality, we will assume a concrete choice for S(G), by impos- ing that the morphism ι in the pullback diagram above is an inclusion.
We say that a graph is stable if it consists only of stable items. This is formalised in the next definition.
Definition 3.2 [stable graph] A T -typed graph G is called stable if |S(G)| = |G| (i.e., if the morphism ι in the pullback diagram above is the identity). It is called unstable otherwise.
It can be shown that the above transformation is functorial: given a morphism of T -typed graphs f : G → H, the transformation above uniquely induces a morphism S(f ): S(G) → S(H) (which is, given the concrete choice for S(G), the restriction of f to S(G)). The corresponding functor S : T -Graph → Ts-Graph is called stabilising functor.
The stabilising functor can be applied point-wise to any production of a given
t-gts, thus producing a gts typed over the stable type graph.
Definition 3.3 [stabilised gts] Given a T -typed t-gts ⟨G, Ts⟩, the stabilised gts
S(G) is given by ⟨Ts, P, π'⟩, where π'(q)= S(π(q)) for any q ∈ P .
The functor S, when applied to a derivation in a given t-gts ⟨G, Ts⟩, produces a derivation in S(G). An indirect proof of this fact can be obtained by observing that there exists a typed gts morphism f : G → S(G), in the sense of [1], which essen- tially forgets about the non-stable items. Then, using the fact that gts morphisms are simulations, one can infer the result below.

q1,g1
q2,g2
qn,gn

Proposition 3.4 Let ⟨G, Ts⟩ be a
be a derivation in G. Then
t-gts and let d = G0 =⇒ G1 =⇒ ... =⇒ Gn

S(d)= S(G0)
is a derivation in S(G).
q1,S(g1)
=⇒  S(G1)
q2,S(g2)
=⇒  ... 
qn,S(gn)
=⇒	S(Gn)

L ,lr1
K   r1 zR,		
1	1 ¸¸
L ,lr2
  
K  r2 zR,


g1	k1
s	  ¸¸
¸
       
 

k2	h2

,˛ r
h1  ¸¸
  g2
r, 

,	r¸˛r	, 
G ,r  D1 	zX,,r	 D2 	zH,
b1	d1	b2	d2
Fig. 1. Sequential independent derivations.
Let us come to the definition of a transaction in a t-gts ⟨G, Ts⟩. Our proposal is inspired by the approach for Petri nets, originally introduced in [3] and later extended to nets with read arcs in [4]. In the following we discuss about stable steps, stable transactions and abstract stable transactions, considering, for the sake of presentation, a fixed t-gts ⟨G, Ts⟩.
A stable step is, intuitively, a computation which starts and ends in stable states. Moreover, once generated, stable items are “frozen”, in the sense that they cannot be read or consumed by other productions inside the same step. Therefore, the dependencies among productions occurring in a step are induced by unstable items: this implies that at the abstract level, where unstable items are forgotten, all such productions will be applicable in parallel.
To give a formal definition we need to briefly review some notions. A derivation
q1,g1	q2,g2
G =⇒ X =⇒ H as in Figure 1 is called sequential independent [6] if there are two
morphisms s : L2 → D1 and u : R1 → D2 such that d1 ◦ s = g2 and b2 ◦ u = h1. Intuitively, the images in X of the left-hand side of q2 and of the right-hand side of q1 overlap only on items that are preserved by both derivation steps. In this case we can apply the two productions either in the reverse order, obtaining derivation

q2,g'
' q1,g'
q +q ,gz 

G =⇒ X =⇒ H, or concurrently, obtaining a parallel direct derivation G
q1,g1
H.
q2,g2

Definition 3.5 [stable step] A stable step is a derivation d = G0
q ,g
... =⇒ Gn which enjoys the following properties:
G0 and Gn are stable graphs;
=⇒ G1 =⇒

the	derivation	S(d)	is	equivalent	to	a	parallel	direct	derivation
S(G )q0 +...+qn,Sz(g )S(G ) in S(G).
q1,g1
Definition 3.6 [stable transaction] A stable transaction is a stable step d = G0 =⇒

q2,g2
qn,gn
q0+...+qn,Sz(g )

G1 =⇒ ... =⇒ Gn such that, if S(G0)	S(Gn) in S(G) is the induced
parallel derivation, then
g is an epimorphism;
any intermediate graph Gi (i /= 0, n) is not stable.
By condition (i), the start graph contains exactly what the transaction needs to be brought to a successful end, while by condition (ii) no sub-derivation of d is a transaction, thus guaranteeing atomicity.
Actually, since we are considering a concurrent model of computation, the fact that all the intermediate graphs are not stable should not be related to the specific order in which productions are applied. Rather, this property should still hold for


	
Fig. 2. The type graph (left) and its stable component (right).

any derivation which is obtained from the original one by exchanging independent steps of computation, i.e., any shift-equivalent derivation (see, e.g., [13,6]). When combining shift-equivalence with an equivalence which abstracts also with respect to the concrete identities of items in the involved graphs, i.e., which considers graphs up to isomorphism, we obtain the so-called abstract truly-concurrent equivalence [6]. The equivalence class of a derivation d with respect to such equivalence will be denoted by [d]c and called abstract trace.
Definition 3.7 [abstract stable transaction] An abstract stable transaction is an abstract trace [d]c, such that for any d' ∈ [d]c the derivation d' is a stable transaction.
It follows from the definition that if two abstract stable transactions can be applied in parallel to a stable graph, then all the direct derivations of either of them are independent of the direct derivations of the other one. Thus, as desired, the transactions can be interleaved in an arbitrary way.
Clearly, a more manageable characterisation of abstract stable transactions would be desirable: even if the corresponding theory is not yet completely de- veloped, we will sketch in the concluding section how such a characterisation could be obtained by means of suitable graph processes.

A simple example on integer equality
We now present a simple gts for testing the equality between integer expressions involving natural numbers represented as sequences S(S(... S(0) .. .)) and a sum operator. Despite its small size we hope that this example will pinpoint the key features of our approach.
The type (hyper-)graph and its stable subgraph are depicted in Figure 2. Explic- itly stated, the dashed items (dashed boxes representing (hyper-)edges and dashed circles for nodes) are not stable. Notice that, as usual for hypergraphs, each edge is connected to an ordered list of nodes. The order is implicit in our drawings: the first connection leaves the edge from the top, and the others follow counter-clockwise.
As a sample expression to be evaluated we consider S(S(0)) + S(0)= S(0), as represented by the stable graph G0 on the left of Figure 5. For the sake of simplicity, G0 is a tree, but the system also works for acyclic graphs, where subexpressions can



Fig. 3. Productions for the equality operator and for garbage collection.

be shared. In order to ensure that a shared subexpression is not affected by the evaluation of an outer expression, some rules duplicate the part of the structure that needs to be accessed in a destructive manner.
Let us consider the production p1 in Figure 3: the graph on the left (center, right) represents the left-hand side (interface and right-hand side, respectively) of the production. Note that, according to the shape of the type graph, an unstable operator can be connected to a stable node only through an additional unstable node and a C-labelled edge. In order to simplify the presentation, such node and the C-labelled edge will be omitted in the figures. For instance, production p1 should be read as
Intuitively, a computation proceeds as follows. The only production that can be applied to a stable graph like G0 is p1, which starts a transaction by replacing the stable edge = with its unstable, dashed counterpart = . Next, the equality operator traverses the expression (see production p2.1), triggering, whenever it is needed, the evaluation of the sum operators by generating an unstable copy of them (production p6.1). In turn, the evaluation of the sum generates a chain of unstable successor operators (see productions p12.1 and p11.1 in Figure 4), recursively triggering the evaluation of nested additions (as in production p9.1), and stopping
















Fig. 4. Productions for the sum operator.

when both arguments are zero (as in production p10.1). The equality operator can then proceed, consuming the chain of unstable successors generated by the sum, till when either one or two zeros are reached. At this point the boolean result is generated (as in productions p3.2), and, if needed, the “garbage collection” of the remaining unstable items is started (productions p4.2, p7 and p8).
The presence of stable and unstable versions for operators and constants mo- tivates the existence of several variants for each production. For example, all the productions p2.1, p2.2 and p2.3 (as well as the symmetric p2.4 which is not depicted) basically replace the subexpression S(x)= S(y) by the equivalent x = y. Such pro- ductions do not have the same structure, because stable S-edges have to be pre- served, as they may belong to a shared subexpression, while unstable S-edges must be deleted, as they should not appear in the final state: this can be done safely, because unstable S-edges are generated in a way guaranteeing they are never shared. The same observation applies to other groups of productions, like p3. (modelling
0 = 0 ~ true), p4. (modelling S(x)= 0 ~ false), and so on. Note that several rules have a symmetric version (obtained by exchanging the left and right arguments of the main binary operator) which is not depicted. For example the productions in the missing p5. family model the evaluation of 0 = S(x) to false. They are obtained from the p4. productions by exchanging the arguments of the equality operator.
Some states of the derivation starting from S(S(0)) + S(0)= S(0) and reaching the final state, which represents the result false, are depicted in Figure 5. From the starting state productions p1, p6.1 and p12.1 are applied, reaching the second state; next, applying productions p12.1, p11.1, p10.1 and p2.3 the third state is reached; then, applying p4.3 the fourth state is reached; and finally the application of p7 and p8 produces the final state. All intermediate states are unstable, due to the presence of at least one unstable item, hence, the only visible states in the derivation, which can be shown to be a stable transaction, are the initial and final ones.
The corresponding abstract stable transaction includes all the derivations which are obtained by switching sequential independent direct derivations, such as the one which applies the productions in the order p1, p6.1, p12.1, p2.3, p12.1, p4.3, p11.1, p10.1, p7 and p8. It can be shown that each abstract stable transaction performs the



Fig. 5. An expression (left), some unstable states (center), and the result (right).

evaluation of exactly one equality operation, building as an unstable intermediate structure the result of the sum operators, and destroying them at the end.

Future perspectives
This paper introduces transactional graph transformation systems, a formalism en- riching the classical dpo approach to graph rewriting with a built-in notion of transaction. Our work so far outlined the basic notions underlying the framework, and further results are now needed to bring the theory to full maturity.

Abstract GTS associated to a transactional GTS
A first line of research concerns the definition of the abstract gts associated to a t-gts. As discussed in the paper, a t-gts can be seen at two different levels of abstraction. It can be viewed as a standard graph transformation system, where both stable and unstable states are visible, and thus also the internal structure of transactions is observable. But we can also abstract away from the unstable states and observe only complete transactions. Formally, this gives rise to another gts, whose definition requires the notion of the production induced by a derivation sequence, a known construction in the literature. The production induced by a derivation d : G0 ⇒∗ Gn has G0 as left-hand side and Gn as right-hand side. The interface graph is the subgraph of G0 which, intuitively, consists of all the items which are preserved by all the direct derivations occurring in the sequence.
Definition 5.1 [Abstract gts] Let ⟨G, Ts⟩ be a t-gts. Given an abstract stable transactions [d]c, a production induced by d is called abstract production for the transaction [d]c.
The abstract gts associated to the given t-gts, denoted by A(⟨G, Ts⟩), is the gts ⟨Ts,P ', π'⟩ where P ' is the set of abstract stable transactions [d]c and π'([d]c) is an abstract production for the transaction [d]c.
As an example, the abstract production that corresponds to the transaction depicted in Figure 5 is shown in Figure 6.



Fig. 6. The abstract production induced by the transaction of Figure 5.

As it should be evident from the proposed example, the abstract gts associated to a t-gts can have, in general, an infinite number of productions. Indeed, the notion of transaction allows one to model an abstract system with infinitely many productions by means of a lower level system, with a finite number of productions.
From a theoretical point of view the definition of the abstract gts associated to a t-gts might not be yet fully satisfactory, since it lacks an extensional presentation, as it is offered by categorical means in terms of adjunctions.
However, note that any gts G can be naturally seen as a t-gts ⟨G,T ⟩ by con- sidering the entire type graph T as stable. Hence, turning the classes of gtss and of t-gtss into categories GTS and TGTS, respectively, there would be an obvious inclusion functor of GTS into TGTS. Thus, a solid justification for the construc- tion of the abstract gts associated to a t-gts could come from a characterisation of the mapping A (Def. 5.1) as a functor from the category of t-gtss to the category of gtss, right adjoint to the inclusion functor in the opposite direction. Intuitively, this would mean that, given a t-gts ⟨G, Ts⟩, the abstract gts A(⟨G, Ts⟩), given in Definition 5.1, is the “best approximation” of ⟨G, Ts⟩ in the category GTS.
We foresee two possible ways of proving a result of this kind:
Freely generated category of systems with transactions as productions. Inspired by the work on zero-safe Petri nets [3], the idea consists of freely generating complex computations of a t-gts, starting and ending in stable states, by suit- ably composing its original productions. The considered composition operation should act differently on the stable and unstable items, composing the former in parallel and the latter sequentially. Moreover, it should be subject to axioms which identify computations differing only for the order of independent steps. In this setting transactions would be identified as computations that cannot be decomposed as the parallel composition of (non trivial) computations.
Transactions as special processes. Graph processes [5] are structures which provide a truly concurrent representation of a deterministic computation in a given gts, by explicitly representing the start and ending state, as well as all the intermediate items produced in the computation and their causal dependencies. A transaction can be characterised as a process which starts and ends in stable states, where only direct causal dependencies between stable items exist, and

which satisfies suitable atomicity properties.
In both cases, it seems that the appropriate choice of morphisms in the category of t-gts should be that of implementation or refinement morphisms [10,11], which allow to map a single production into a computation.

Multi-level transactional GTSs
Another issue to be addressed concerns the “binary” distinction between stable and unstable items, which can be unsatisfactory in certain situations. In fact, a system can be viewed at several levels of abstractions, and what appears to be as an atomic production can be refined to a computation at a lower level and can be the building block of more complex transactions at a higher-level. In the proposed framework, the situation could be recast by replacing the stable/unstable dichotomy by a multi-layered structure, consisting of a set of graphs T0, T1, . . . , Tn such that Ti+1 is a subgraph of Ti, representing the stable types for layer i.
The functorial characterisation of abstract gtss that we envision could also be helpful to provide a modular semantics to the multi-layered t-gtss.

Relations with refinement and modularity for GTSs
We do believe that our semantical analysis of transactional mechanisms in graph transformation is original. However, the same notion of abstract gts calls for a comparison with the approaches to refinement and modularisation proposed in the literature (see [12] and the references therein).
Transactions could be exploited to simulate modules, since the atomicity of some computations is induced by the fact that some states are classified as non-observable or unstable at the abstract level. We leave to future work the further elaboration of these ideas, as well as a comparison with the literature.

Acknowledgement
We are mostly grateful to Roberto Bruni for insightful discussions and his careful reading of a preliminary version of this paper.

References
Baldan, P., A. Corradini and U. Montanari, Unfolding of double-pushout graph grammars is a coreflection, in: Ehrig et al. [7], pp. 145–163.
Bardohl, R., M. Minas, A. Schurr and G. T¨antzer, Application of graph transformation to visual languages, in: Ehrig et al. [8] pp. 105–180.
Bruni, R. and U. Montanari, Zero-safe nets: Comparing the collective and individual token approaches, Info. & Co. 156 (2000), pp. 46–89.
Bruni, R. and U. Montanari, Transactions and zero-safe nets, in: H. Ehrig, G. Juh´as, J. Padberg and
G. Rozenberg, editors, Advances in Petri Nets: Unifying Petri Nets, LNCS 2128, Springer, 2001 pp. 380–426.
Corradini, A., U. Montanari and F. Rossi, Graph processes, Fundamenta Informaticae 26 (1996),
pp. 241–265.

Corradini, A., U. Montanari, F. Rossi, H. Ehrig, R. Heckel and M. L¨owe, Algebraic approaches to graph transformation I: Basic concepts and double pushout approach, in: Rozenberg [14] pp. 163–245.
Ehrig, G., G. Engels, H. Kreowski and G. Rozenberg, editors, “Proceedings of the International Workshop on Theory and Application of Graph Transformations,” LNCS 1764, Springer, 1999, 145–163 pp.
Ehrig, H., G. Engels, H.-J. Kreowski and G. Rozenberg, editors, “Handbook of Graph Grammars and Computing by Graph Transformation, Vol. 2: Applications, Languages and Tools,” World Scientific, 1999.
Ehrig, H., M. Pfender and H. Schneider, Graph-grammars: An algebraic approach, in: R. Book, editor,
IEEE Conf. on Automata and Switching Theory (1973), pp. 167–180.
Grosse-Rhode, M., F. Parisi Presicce and M. Simeoni, Refinement of graph transformation systems via rule expressions, in: Ehrig et al. [7], pp. 368–382.
Heckel, R., A. Corradini, H. Ehrig and M. L¨owe, Horizontal and vertical structuring of graph transformation systems, Mathematical Structures in Computer Science 6 (1996), pp. 613–648.
Heckel, R., H. Ehrig, G. Engels and G. T¨antzer, Classification and comparison of module concepts for graph transformation systems, in: Ehrig et al. [8] pp. 669–689.
Kreowski, H.-J., “Manipulation von Graphmanipulationen,” Ph.D. thesis, Technische Universit¨at Berlin (1977).
Rozenberg, G., editor, “Handbook of Graph Grammars and Computing by Graph Transformation, Vol. 1: Foundations,” World Scientific, 1997.
