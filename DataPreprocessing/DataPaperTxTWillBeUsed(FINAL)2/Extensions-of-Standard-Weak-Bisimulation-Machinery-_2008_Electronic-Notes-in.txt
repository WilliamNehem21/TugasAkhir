	Electronic Notes in Theoretical Computer Science 209 (2008) 83–106	
www.elsevier.com/locate/entcs

Extensions of Standard Weak Bisimulation Machinery: Finite-state General Processes, Refinable Actions, Maximal-progress and Time
Mario Bravetti 1,2
Dipartimento di Scienze dell’Informazione Universit`a di Bologna
Bologna, Italy

Abstract
We present our work on extending the standard machinery for weak bisimulation to deal with: finite- state processes of calculi with a full signature, including static operators like parallel; semantic action refinement and ST bisimulation; maximal-progress, i.e. priority of standard actions over unprioritized actions; representation of time: discrete real-time and Markovian stochastic time. For every such topic we show that it is possible to resort simply to weak bisimulation and that we can exploit this to obtain, via modifications to the standard machinery: finite-stateness of semantic models when static operators are not replicable by recursion, as for CCS with the standard semantics, thus yielding decidability of equivalence; structural operational semantics for terms; a complete axiomatization for finite-state processes via a modification of the standard theory of standard equation sets and of the normal-form derivation procedure.
Keywords: CCS, Weak bisimulation, Action refinement, Maximal Progress, Timed actions


Introduction
This paper presents work that we have done on how to extend standard machinery to cope with several extensions of standard process algebra. Every extension is presented by using the same structure: basic ideas on how to resort to standard machinery and definition of operational semantics; set of axioms that compose the axiomatization; technique to prove completeness: variation to the standard theory of standard equation sets and to the procedure for deriving normal forms from terms.

1 Research partially funded by EU Integrated Project Sensoria, contract n. 016004.
2 Email: bravetti@cs.unibo.it

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.005

The standard machinery for basic CCS with recursion [16], i.e. for a calculus with prefix α.P (where α is either a visible action a or τ ), choice P +Q and recursion recX.P , and full CCS without recursion [15], i.e. when also static operators like parallel P|Q and restriction P\L are considered, is presented at the beginning of the paper (in Sect. 2).
We then show (in Sect. 3) how to extend such machinery to finite-state processes of a full calculus that includes both static operators and recursion, more precisely to processes such that static operators are not replicable by recursion [2,3,1]. The basic idea is to express hiding mechanisms explicitly via an hiding operator P/L (like e.g. the hiding mechanism that is part of the CCS parallel operator) and to introduce a new axiom for exchange of hiding and recursion and a new normal-form derivation procedure that combines unguardedness removal with static operator elimination in an inductive way. The work presented in Sect. 3 has been done in cooperation with Jos Beaten.
The approach is further extended (in Sect. 4) to deal with actions that can be refined by means of a semantic action reﬁnement operator “P [a ~ Q]”, where every visible action “a” executed by P is refined by a term “Q” [7,5]. The basic idea is to express weak ST bisimulation (needed to get a congruence in the presence of refinement) via standard weak bisimulation by using: the dynamic name technique or the stack technique to obtain semi-actions with indexes in semantic models in a way that preserves finite-stateness and the levelwise reindexing technique to be able to express the two semantics above in a compositional way (in Structural Operational Semantics and in axioms for parallel).
We then (in Sect. 5) endow basic CCS (with recursion) with an unprioritized action σ to express maximal progress [8,5,9]. The basic idea is to introduce an auxiliary operator pri(P ) that denotes the scope of priority. Such an operator is used to produce a new version for the axioms that allow weak unguardedness to be removed: a new unguardedness removal procedure is produced. The work presented in Sect. 4 and 5 has been done in cooperation with Roberto Gorrieri.
Finally, (in Sect. 6) we extend the basic calculus with maximal progress above with static operators by interpreting σ actions to be timed actions [4,9]. More precisely, we consider two different kinds of time: discrete real-time (see, e.g., [12]), where σ is a “tick” and Markovian stochastic time (see, e.g., [14,13,6]), where σ is a positive real number representing a rate of an exponential distribution. The basic ideas are: make use of a parallel operator that (for both kinds of time) is compatible with standard weak bisimulation, i.e. is such that a process can execute a σ action only when other processes in parallel with it can explicitly execute a σ action too; show that in this context we can use, when merging guarded standard equation sets, a simpler reformulation of standard weak bisimulation that considers just strong “σ” moves instead of weak “σ” moves (by exploiting maximal progress, guardedness and non-idempotence of sum over timed actions due to time determinism in discrete real time and stochastic delay summation in Markovian stochastic time); and perform τ saturation after σ preﬁxes in normal forms before showing that they are equated by the axiomatization via standard equation sets.

The paper is concluded (in Sect. 7) by reporting possible applications and ex- tensions of the machinery produced.

Standard Machinery
The set of action names A is ranged over by a, b, c, . . . . The set of actions Act = A∪ {a | a ∈ A} ∪ {τ}, which includes co-actions and the silent action τ denoting an internal move, is ranged over by α, α',.   The set of term variables is Var , ranged
over by X, Y, . . . . The set E of CCS behavior expressions, ranged over by E, F is defined by the following syntax.
E ::= 0 | X | α.E | E + E | E|E | E\L | E[ϕ] | recX.E

The meaning of the operators is the standard one of [15,16], where “recX.E” denotes recursion. Closed terms are terms that do not include free variables (i.e. variables X not bound by a “recX.E” operator) and are called processes, ranged over by P ,Q.
A variable X is serial in E if every free occurrence of X in E (if any) is in the scope of operators α.F , F' + F '' or recY.F (for any variable Y ) only. Furthermore, a variable X that is serial in E is also: weakly guarded if every free occurrence of X in E is in the scope of an operator α.F , strongly guarded (or simply guarded) if it additionally holds that α /= τ , fully unguarded if it is not weakly guarded, fully unguarded if it is not strongly guarded.
Basic CCS is the calculus considered in [16], i.e. the set of terms of CCS obtained by considering a restricted syntax where static operators (i.e. “E|E”, “E\L” and “E[ϕ]”) are not included. In particular here we will distinguish between basic CCS without recursive definitions (i.e. excluding from the CCS syntax also the “recX.E” operator and variables X), simply called basic CCS and denoted by BCCS, and basic CCS with recursive definitions, denoted by BCCSrec. A recursion “recX.F ” occurring in a BCCSrec term E is a guarded recursion if X is guarded in F . We use BCCSgrec to denote the subset of BCCSrec terms that include guarded recursive definitions only.
The standard structural operational semantics for BCCSrec operators and CCS static operators is presented in Tables 1 and 2, respectively. type(α) yields the name in A of the action α or τ if α is the silent action.
As in [16] we use −α→∗ to denote computations composed of all −α→ transitions
whose length is possibly zero. Let =α⇒ denote −τ→∗ −α→ −τ→∗. Moreover we define

=α⇒ˆ
= =α⇒ if α /= τ and
=τ⇒ˆ
= −τ→∗.

Definition 2.1 A relation β over processes is a weak bisimulation if, whenever (P, Q) ∈ β:

If P
−α→ P' then, for some Q', Q =α⇒ˆ
Q' and (P ', Q') ∈ β.

If Q −α→ Q' then, for some P', P
=α⇒ˆ
P' and (P ', Q') ∈ β.



Table 1
Structural operational rules for BCCSrec

Table 2
Structural operational rules for static operators

Two processes P , Q are weakly bisimilar, written P ≈ Q, iff (P, Q) is included in some weak bisimulation.
Definition 2.2 Two processes P , Q are observationally congruent, written P  Q, iff:

If P
−α→ P' then, for some Q', Q =α⇒ Q' and P' ≈ Q'.

If Q −α→ Q' then, for some P', P =α⇒ P' and P' ≈ Q'.

Both weak bisimulation and observational congruence are extended to open terms in the standard way [16,15] so to have that: two (open) terms E and F are equivalent if for every substitution of free variables for closed terms, the closed terms obtained by applying the (same) substitution to E and F are equivalent.

Completeness for BCCS with Recursive Deﬁnitions
The Axioms
The standard axiomatization is composed by the axioms in Tables 3, 4 and 5. As we observed in [2], an alternative equivalent smaller axiomatization can be obtained by replacing the axioms (WUng1) and (WUng2) with the unique axiom:
(WUng) recX.(τ.(X + E)+ F ) = recX.(τ.(E + F ))



Table 3 Axioms for BCCS

Table 4
Unfolding and folding recursion axioms

Table 5
Axioms for unguarded recursion

Completeness for BCCS with Guarded Recursive Deﬁnitions
Completeness for observational congruence over BCCSgrec terms is shown by re- sorting to standard equation sets.
Definition 2.3 (Equation Sets) An equation set with formal variables X˜ =
{X1,..., Xn} and free variables W˜  = {W1,..., Wm}, where X˜ and W˜  are dis-
joint, is a set S = {Xi = Hi | 1 ≤ i ≤ n} of equations such that the terms Hi
(1 ≤ i ≤ n) have free variables in X˜ ∪ W˜ .
A solution of the equation set is a set of terms E1,..., En such that: for every 1 ≤ i ≤ n we have that Ei = Hi{Ej/Xj | 1 ≤ j ≤ n} 3 can be shown by using the axiomatization above. A single term E is said to be a solution of the equation set if there exists a solution E1,..., En such that E ≡ E1.
Definition 2.4 (Standard Equation Sets) An equation set S = {Xi = Hi |
1 ≤ i ≤ n}, with formal variables X˜ = {X1,..., Xn} and free variables W˜  =
{W1,..., Wm}, is standard if each term Hi (1 ≤ i ≤ n) is of the form: 4
Hi ≡ Σ αi,j.Xf (i,j) + Σ Wg(i,k)
j∈Ji	k∈Ki

3 The notation used here stands for the syntactical replacement of Ej for every occurrence of Xj (for every
j) inside Hi.

4 We assume P

j∈J
E ≡ 0 if J = ∅.


As in [16], for a standard equation set S, we let Xi −α→S X stand for “α.X occurs
in Hi”. −α→S + denotes a non-zero length sequence of −α→S .

Definition 2.5 A standard equation set S with formal variables X˜ is guarded if there is no cycle Xi −τ→+Xi.
= {X1,..., Xn}

It is crucial to observe that guarded standard equation sets have one and only one solution. More precisely we have the following properties:
Existence of a solution for standard equation sets, i.e. generalization of (U nf old) axiom: given a standard equation set it is always possible to build a set of BCCSgrec terms which constitutes its (canonical) solution.
Unicity of the solution for guarded standard equation sets, i.e. generalization of (Fold) axiom: different solutions of the same guarded standard equation set can be equated by using the axiomatization above (it is shown that every solution can be equated to the canonical one).
Finally, the completeness result is obtained by showing: that every BCCSgrec term can be represented by a guarded standard equation set (for which the term is a solution) and that for every pair of guarded standard equation sets satisfied by observationally bisimilar BCCSgrec terms we can build a common guarded standard equation set that is satisfied by both terms.
Proposition 2.6 (representability) For every BCCSgrec term E there is a guarded standard equation set that is satisﬁed by E.
Proposition 2.7 (mergeability) Let E, F be BCCSgrec terms. If E  F then, given a guarded standard equation set satisﬁed by E and a guarded standard equation set satisﬁed by F, there exists a common guarded standard equation set satisﬁed by both E and F.

Completeness Technique
The standard completeness technique is based on two steps.
Completeness for BCCSgrec (open) terms presented above.
Normal form derivability: BCCSgrec terms can always be derived as “normal” forms by using the axiomatization.
Proposition 2.8 (normal form derivability) For every BCCSrec term E there exists a BCCSgrec term F such that E = F.
Normal form derivability (i.e. the proof of the proposition) involves elimination of unguarded recursion by using the (FUng) and (WUng) axioms of Table 5 (see [16]).
In general the two step schema above is used to prove completeness over (un- guarded) terms of a full calculus by turning them into normal form.

Completeness for Full CCS without Recursive Deﬁnitions
The Axioms
The axiomatization is composed by the following axioms.
The axioms for BCCS of Table 3.
Axioms for static operators elimination (this requires the introduction of auxiliary operators like left merge and synchronization merge for parallel).
The axioms in the last item guarantee that, for each static operator, when the static operator is applied to BCCS term(s) E, a BCCS term can be obtained by applying the axioms.

Completeness Technique
The standard completeness technique is, again, based on two steps.
Completeness over BCCS terms.
Normal form derivability: BCCS terms can always be derived as “normal” forms by using the axiomatization.
Proposition 2.9 (normal form derivability) For every CCS term P there ex- ists a BCCS term Q such that P = Q.
Normal form derivability (i.e. the proof of the proposition) involves elimination of static operators by an inductive structural bottom-up transformation.

Finite State General Processes
In this section we report about work on extending the standard weak bisimulation machinery to deal with both recursion and static operators [2,1]. For example the following observationally congruent CCS terms
( (recX.a.X) | (recX.a.X)) \{a}  recX.τ.X   τ.0
cannot be equated by using the standard axioms presented before. The idea here is that, if we just deal with terms whose semantics is finite-state like the above one, we can still develop a complete axiomatization by extending the standard machinery.
Technically, the problem with the term above arises from the hiding behavior of the CCS parallel operator which can generate new τ actions and, as a consequence, weakly unguarded recursions. In order to solve this problem we need to express such a hiding behavior explicitly by a separate hiding operator (we use the operator
E/L which hides all the actions in the set L) and to introduce the new axiom (recX.E)/L = recX.(E/L) that allows us to exchange recursion and hiding, so to evaluate the effect of hiding inside serial terms E. The CCS parallel is then
expressed as a combination of ACP parallel and hiding.
The focus of [2] is on producing a general process algebra such that all the operators of CCS, CSP and ACP can be expressed as a combination of the operators of such an algebra, so, e.g., in addition to ACP parallel and hiding also sequencing

“E1; E2” and successful termination “1” are considered (in addition to prefixing and 0, that now represent just deadlocked termination).
In [2] we consider the following syntactical characterization for closed terms E of the general process algebra, which guarantees finite-stateness. For any subterm recX.F of E, (free) occurrences of X in F must not be in the scope of static operators (i.e. operators E'|E'', E'\L, E'/L, E'[ϕ]) or on the left-hand side of the sequencing operator “E; E”.

The Axioms
The axiomatization is composed by the following axioms.
The axioms for BCCSrec of Tables 3, 4 and 5, where the “X serial in E” require- ment is added in the folding axiom (Fold): the new requirement “X serial in E” makes the existing requirement “X guarded in E” well defined on the extended syntax.
The new axiom (RecHid) for recursion and hiding exchange: (RecHid) (recX.E)/L = recX.(E/L)	X serial in E
Axioms for static operator elimination (including sequencing operator “E; E”).
The axioms in the last item are of the same kind of those considered in Section 2.2.1: they guarantee static operators (or sequencing) to be eliminated when applied to (non-recursive) BCCS terms. Concerning the general process algebra above, they guarantee that, for each static operator (including the sequencing operator), when
the operator is applied to term(s) E of the form 5 Σi∈I αi.Ei (or Σi∈I αi.Ei + 1),
where Ei are unrestricted general terms, a term of the same form can be obtained by applying the axioms.
Completeness Technique
Completeness over finite-state terms belonging to the syntactical characterization above is obtained as usual (see Section 2.1.3) in two steps.
Completeness for BCCSgrec terms presented in Sect. 2.1.2 (successful termination can be just seen as a special new action used in BCCSgrec terms).
Normal form derivability: BCCSgrec terms can always be derived from terms belonging to the syntactical characterization above as “normal” forms by using the axiomatization.
Concerning normal form derivability, terms belonging to the syntactical charac- terization above are shown to be transformable into normal form by combining unguarded recursion elimination of BCCSrec (see Sect. 2.1.3) with static operator elimination of CCS (see Sect. 2.2.2). In particular an inductive structural bottom- up transformation of terms into normal form is performed.  The inductive step

5 We assume Pi∈I E ≡ 0 if I = ∅.

consists in generating a term in normal form by applying some operator to term(s) in normal forms. This is done as follows:
Only in the case of a recursion or hiding operator: we remove generated unguarded recursion via the standard (WUng) and (FUng) axioms plus the new axiom (RecHid) (and the other standard elimination axioms for hiding). In the case of recursion, this is done just as in the standard case (Sect. 2.1.3).  In case of hiding, we preliminarily propagate structurally the hiding operator top-down until leaves and then again bottom-up to the top-level to introduce new taus in the previous normal form (obtained as the effect of hiding) and then remove generated unguarded recursion.
We then obtain a normal form by applying, if necessary, the unfolding and the static operator elimination axioms and then the folding axiom: each state of the finite-state operational semantics of the term is first turned into a sum of prefixes leading to other states and then into a variable of a system of equations, that is expressed by recursion.

Refinable Actions
In this section we show how to extend the standard machinery for weak bisimu- lation in order to deal with refinable actions, i.e. actions which can be refined by means of an action refinement operator “P [a ~ Q]” that performs the semantic refinement of “a” executed by “P ” into “Q” [7,5]. It is well known that ST bisimu- lation [11] is the coarsest bisimulation equivalence that is a congruence with respect to semantic action refinement. Weak ST bisimulation matches visible (non-τ ) ac- tions of concurrent systems as if they had a duration. In particular, actions are not treated as being executed atomically like in standard interleaving semantics, but the execution of an action is split into the two distinguished events of action start and action termination (pair of semi-actions). Moreover, enough information is included in semantic models so that the event of an action termination uniquely determines to which event of action start it refers to, even in the situation of auto- concurrency (i.e., multiple actions of the same type being in execution at the same time). Weak ST Bisimulation over terms of a process algebra can be expressed in several equivalent ways by using different combination of “semantics+equivalence” definitions (see [7] and the references therein). Here we consider definitions of ST semantics (taken from [7]) that allow us to obtain weak ST bisimulation by just using standard weak bisimulation on the generated special transition systems. This allows us to deal with weak ST bisimulation by a smooth extension of the standard machinery and to obtain a complete axiomatization over finite-state terms. More precisely, since the definitions of ST semantics of [7] yield finite-state transition sys- tems for all terms which are finite-state with the standard interleaving semantics, we obtain a axiomatization which is complete for observational congruence over terms satisfying the syntactical characterization previously presented in Sect. 3.
The process algebra considered in [7] is an extension of BCCSrec that (apart from the action refinement operator “P [a ~ Q]”) is similar to the general process


Table 6
Structural operational rules for refinable actions

algebra of Sect. 3, with the difference that the CSP parallel E S E, where the actions in the set S are required to synchronize (while other actions are executed independently), is employed instead of ACP parallel and restriction. In particular, like in Sect. 3 we consider hiding, sequencing “E1; E2” and successful termination “1” (it is well known that distinguishing between deadlocked termination and successful termination 1 is necessary for the semantic action refinement operator to be a congruence).
Here we consider two definitions of ST semantics from [7], corresponding to two different techniques for associating action termination events to action start events:
Dynamic name technique: action termination is associated to action start by using a common unique name (positive integer index), generated at the moment of action start with a fixed rule.
Stack technique: action termination is associated to action start by a pointer
(positive integer index).
The dynamic name technique is based on the idea of dynamically assigning, dur- ing the evolution of the system, a new name to each action that starts execution, on the basis of the names assigned to the actions already started. Names are indexes i ∈ IN+ that distinguish actions of the same type. In particular the event of starting of a visible action a is represented in semantic models by a transition labeled by a+ where i is the minimum index not already used by the other actions a that have started but not terminated yet. This rule for computing indexes guarantees that names are reused and that finite models can be obtained also in the presence of re- cursion. The termination of the action is simply represented by a transition labeled by a−, where the “identifier” i uniquely determines which action a is terminating. Since the method to compute the index for a starting action is fixed, it turns out that actions of processes that perform the same execution traces of actions get the same names. As a consequence, ST bisimilarity can simply be checked by applying standard bisimilarity to the semantic models of processes.
In order to obtain a smooth extension of standard machinery, the ST semantic models that assign indexes to semi-actions a+ and a− according to the dynamic name technique explained above must be obtained by a simple extension of standard

structural operational semantics, hence in a compositional way. To do this, we make use of our idea of levelwise reindexing of actions. For obtaining compositionality, it is necessary to determine, e.g. in the case of the parallel composition operator, the computations of P  S Q from the computations of P and Q.  This is done by parameterizing in state terms each parallel operator with a mapping M . For
every action a ∈/ S started by P  S,M Q, M records the association between the
name ai, generated according to the fixed rule above for identifying a at the level of P  S,M Q, and the name aj (which in general is different from ai), generated according to the same rule for identifying the same action a inside P (or Q). In this way when, afterwards, such an action a terminates in P (or Q) the name aj can be re-mapped to the correct name ai at the level of P  S,M Q, by exploiting the information included in M . In M the action a of P  S,M Q which gets index i is
uniquely identified by expressing the unique name j it gets in P or in Q and the “location” of the process that executes it: left if P , right if Q. Such an association is, therefore, represented inside M by the triple (a, i, locj) with a ∈ A, indexes

i, j ∈
IN+ and location loc ∈ Loc = {l, r}, where “l” stands for left and “r” for

right. In the following we use a : (i, locj) to stand for (a, i, locj) ∈ M . Formally, we denote by ia an index association, whose elements are associations (i, locj). ia ranges over the set IA of partial bijections from IN+ to Loc × IN+. A mapping M is a relation from A to IN+ × (Loc × IN+) such that ∀a ∈ A. M (a) ∈ IA, i.e. M is a
set including an independent index association for each different action type.
The non-standard structural operational semantics rules for terms are those pre- sented in Table 6 (plus symmetrical ones, where “li” is replaced by “ri”). According to what we explained above, we assume new (M, a) = min{k | k ∈/ dom(M (a))}, upd+(M, a, li) = M ∪ {a : (new (M, a), li)} and upd−(M, a, li) = M − {a : (j, li)}, with j the only index such that a : (j, li) ∈ M . Note that, for expressing the ST semantics we need to use an extended syntax for state terms that includes semi- action prefixes and the extended CSP parallel operator P  S,M Q, where we consider P  S,∅ Q to stand for P  S Q in the initial term.
The ST semantics via dynamic name presented above has all the required char- acteristics to be used as a smooth extension of the standard machinery to deal with refinable actions, but one: in general it does not preserve finite-stateness when the semantic action refinement operator “P [a ~ Q]” is applied (supposing both terms P and Q to be finite state). With our approach the semantics of P [a ~ Q] can be simply defined, in terms of simpler operators, as
(P [a ↔ e] {e},∅!(e+; Q; e−))/{e}
1	1
where: e is a distinguished action not occurring in the set of action names A; the bijective relabeling α ↔ α' is defined by α ↔ α' = {(α, α'), (α', α)}∪ {(α'', α'') | α'' ∈ A ∪ {e}∧ α'' ∈/ {α, α'}}; the bang operator “!P ” may either terminate success- fully or execute “P ” in such a way that a new copy of !P in parallel is produced after an initial action of “P ” is executed; the semantics of action start semi-actions prefixes e+.P is defined in the obvious way (they generate a corresponding “e+”
1	1
transition to reach state P ); and trailing “1” are omitted from prefixes, i.e. e+ and
e− stand for e+.1 and e−.1.
1	1	1

The problem with finite stateness is related to the fact that the number of paral- lel operators generated by the bang operator grows as new actions to be refined start and terminate; therefore in the absence of an elimination rule for the terminated parallel processes (and the involved parallel operator itself) we get infinite state systems even when refining very simple recursive terms. The dynamic name tech- nique however does not allow to introduce elimination of trailing terminated parallel processes due to “holes” in the generated set of action dynamic names (see [7]), i.e. if in a state the current set of indexes of actions a in execution (started but not terminated) is {1, 3}, we have a “hole” in the position 2.
In order to obtain finite-stateness also in the presence of the action refinement operator and to produce an axiomatization which is complete over terms that include such an operator, the more complex “stack technique” must be used, which is based on the idea of avoiding the generation of such “holes” in the sequence of started action indexes upon action termination. In particular, started actions of a given type are organized as a stack of coins over a table where the coin on the top of the stack is the action with index 1 and the other actions are indexed in increasing order from top to bottom. When a new action starts the corresponding coin is put on the top of the stack (and the old actions are renumbered accordingly). When an action terminates the corresponding coin is removed and the hole is “eliminated by gravity” (causing a renumbering of all the actions below it). Since the index of a started action change dynamically while other actions start and terminate, this technique is not based on names (seen as identifiers for actions) but is more similar
to a pointer. In particular, the event of starting of an action a is represented in semantic models by a transition labeled with a+ (so no index is observable) whilst the event of termination of an action a is represented by a transition labeled with a− where i is the current position of the action on the stack.
Like the dynamic name technique, the stack technique is expressed composition- ally in structural operational semantics by using the idea of levelwise reindexing. In particular the non-standard rules are those of Table 6, where: indexes are elim- inated from a+ semi-actions (in prefixes and labels), i.e. the new function is no longer used; upd+(M, a, li) modifies M by adding a : (1, l1), by incrementing the indexes k, k' occurring inside every triple a : (k', lk) and by incrementing the index k' inside every triple a : (k', rk) for any k; and upd−(M, a, li) modifies M by remov- ing a : (j, li), with j the only index such that a : (j, li) ∈ M , by decrementing the indexes k, k' occurring inside every triple a : (k', lk) such that k' > j (or equivalently k > i) and by decrementing the index k' inside every triple a : (k', rk) such that k' > j (k is arbitrary).

The Axioms
The axiomatization is composed of the following axioms.
The axioms for BCCSrec of Tables 3, 4 and 5, where α ranges over semi-actions
a+ (a+ for the stack technique), a− and τ and the “X serial in E” requirement
i	i
is added in the folding axiom (Fold).

The new axiom a.E = a+.a−.E (for the dynamic name technique) or a.E =
1	1
a+.a−.E (for the stack technique).
The (RecHid) axiom.
Axioms for static operators elimination (including operator “E; E”): left merge and synchronization merge must be parameterized by a mapping M like in the case of parallel and in their axioms we use compositional levelwise reindexing like in the S.O.S. rules.
In the case of the stack technique, the axiom that turns semantic action refinement into parallel:
P [a ~ Q] = (P [a ↔ e] {e},∅!(e+; Q; e−))/{e}
an axiom for turning the bang operator into a combination of left merge and recursion and an axiom for elimination of trailing terminated parallel processes.
Completeness Technique
Completeness over finite-state terms belonging to the syntactical characterization presented in Sect. 3 (where, in the case of the stack technique, also the semantic action refinement operator is considered as a static operator) is obtained as usual (see Section 2.1.3) in two steps.
Completeness for BCCSgrec terms presented in Sect. 2.1.2 (successful termination can be just seen as a special new action used in BCCSgrec terms).
Normal form derivability: BCCSgrec terms can always be derived from terms belonging to the syntactical characterization above as “normal” forms by using the axiomatization.
Concerning normal form derivability, terms belonging to the syntactical characteri- zation above are shown to be transformable into normal form by adopting the same procedure as that of the previous Sect. 3.2. Note that in the current context this means that during the inductive structural bottom-up transformation of terms, ac- tion are reindexed at every level as an effect of the axioms for the elimination of the parallel operator.
Maximal Progress
In this section we deal with the problem of extending standard process algebra with special actions σ whose execution is unprioritized with respect to standard actions [8,5,9]. As we will see, we can use such actions to represent the passage of time. In this context the precedence of standard action execution over time is often termed “maximal progress”. More precisely, since we consider visible actions to represent just potential for execution (e.g. in CCS the actual execution depends on the environment executing a corresponding co-action) and we regard them to be actually executable only when they become τ , we assume just τ actions to actually preempt σ actions. In this section we will consider the basic process algebra BCCSrec and we will show how to adjust the standard machinery to deal with the



Table 7
Axioms for unguarded recursion


unprioritized actions σ. Concerning the definition of syntax, we just add σ ∈/ A to the set of actions Act; regarding semantics of “σ” actions, we replace the standard rules for the “+” operator with the rule

E —σ→ E'
τ
F /—→

E + F
—σ→ E'

and its symmetric. This means that the semantic model of “σ.P +τ.Q” is isomorphic to that of “τ.Q”.
The modification of the operational semantics of BCCSrec does not affect the congruence property of standard observational congruence (where σ is treated as a standard visible action). However, as far as producing a complete axiomatization for observational congruence over BCCSrec terms is concerned, the standard machinery needs to be modified. The main reason is that the axiom
(WUng1) recX.(τ.X + E) = recX.(τ.E) is no longer sound! For instance if E is σ.F we would obtain:
recX.(τ.X + σ.F )	/	τ.σ.F
The modification to the standard machinery that is required (new set of axioms considered plus new completeness proof) is far from trivial. The basic idea is to use an auxiliary operator “pri(E)” to express the scope of priority. The semantics of pri(P ) is just defined by


P —α→ P'

α /= σ

pri (P ) —α→ P'

and represents how the behavior of P is modified in the presence of an alternative initial τ transition, i.e. all initial “σ” actions (and consequent behaviors) are pre- empted in P . In this way the axiom (WUng1) can be replaced by the new sound axiom
(WUng1) recX.(τ.X + E) = recX.(τ.pri(E)) that allows to remove weakly guarded recursion in a similar way.



Table 8
Axioms for the “pri” operator

The Axioms
The axiomatization is composed by the following axioms.
The axioms for BCCS in Table 3.
Unfolding and folding recursion axioms in Table 4 where the “X serial in E” requirement is added in the folding axiom (Fold).
The axiom (MPro) expressing maximal-progress:
(MPro) τ.E + F = τ.E + pri (F ) Note that from this axiom we can derive: τ.E + σ.F = τ.E.
The modified axioms for unguarded recursion in Table 7 (an additional axiom
“(WUng3)” similar to the old ‘(WUng2)” is needed to remove weakly unguarded occurrences of pri(X) terms).
The axioms for the “pri(E)” operator in Table 8.

Completeness for BCCS with Guarded Recursive Deﬁnitions
In order to prove completeness for observational congruence over BCCSgrec terms we need to introduce prioritized standard equation sets.
Definition 5.1 (Prioritized Standard Equation Sets) A standard equation
set S = {Xi = Hi | 1 ≤ i ≤ n}, with formal variables X˜ = {X1,..., Xn} and
free variables W˜ = {W1,..., Wm}, where we assume terms Hi (1 ≤ i ≤ n) to be represented by 6
Hi ≡ Σ αi,j.Xf (i,j) + Σ Wg(i,k)

is prioritized if:
j∈Ji


∃j ∈ Ji : αi,j = τ ⇒ ∃/
k∈Ki


j ∈ Ji : αi,j = σ . 


A (not involved) adaptation of the standard machinery allows us to establish one and only one solution, representability and mergeability for prioritized standard equation sets (see [8,5,9]).

6 We assume Pj∈J E ≡ 0 if J = ∅.

Completeness Technique
Completeness over (closed) BCCSrec terms is, as usual, obtained in two steps.
Completeness for BCCSgrec terms presented above.
Normal form derivability: BCCSgrec terms can always be derived as “normal” forms by using the axiomatization.
The proof of normal form derivability (which involves elimination of unguarded recursion via the modified “WUng” axioms) is the most involved change with respect to standard machinery (see [8,5,9]).

Time
In this section we present the work on using unprioritized “σ” actions of the previous section to represent time in process algebra [4,9]. More precisely, we consider timed full calculi (that with respect to the basic language BCCSgrec consider also static operators, like parallel) that preserve compatibility with the standard notion of observational congruence, i.e. that allow terms that do not include “σ” actions to be matched as with observational congruence without loosing the congruence property. In this way we are able to adapt the standard machinery for weak bisimulation to deal also with time.
In particular, we will consider two full calculi, each for a different “kind” of time: discrete real-time and Markovian stochastic time (where time is probabilistic and is expressed via exponential probability distributions). These two kinds of time (as opposed to continuous real-time and stochastic time with arbitrary probability distributions) can be expressed simply by “atomic” σ actions: in the case of discrete real-time we see σ actions as a delay of a time unit, a “tick”; in the case of Markovian stochastic time we see σ actions as positive real numbers, i.e. σ ∈ IR+, representing the parameter σ of an exponentially distributed delay (σ is also called “rate” of the distribution). The calculi that we use are based on the Hennessy-Regan ap- proach [12] of considering time to be allowed to pass for a process, by executing “σ” transitions, only if every other process that is in parallel with it, explicitly allow time to pass via “σ” transitions as well. By taking such an approach, processes that cannot execute “σ” actions are interpreted as time deadlocked processes that block evolution of time in all the system, hence, e.g., it is correct to consider 0 to be equivalent to recX.τ.X (that blocks the execution of time as well by executing an infinite sequence of prioritized τ transitions) as in standard weak bisimulation.
In the following two subsections we present the two calculi that we consider, i.e. a calculus for real-time like that in [12] and a revisitation of the calculus of Interactive Markov Chain [13] that makes it compatible with standard weak bisimulation. Both calculi are endowed with a special “timed” prefix αt.P and choice P +t Q that, like in [12], allow time to evolve via explicit execution of “σ” transitions as required by parallel (see above). Such operators are different from the “standard” prefix and choice operators of BCCSrec that we considered in the previous Sect. 5 and here we will use the “t” superscript to distinguish them. The idea is that “timed” prefix

and choice and the other operators of the timed full calculi are used to specify timed systems, i.e. the two timed full calculi are speciﬁcation level calculi, while the basic BCCSrec calculus with maximal progress (plus an auxiliary delay hiding operator H(P ) in the case of Markovian delays) is used to express normal forms for them and to produce an axiomatization. Such an axiomatization will be complete over finite-state terms belonging to a syntactical characterization (on the specification level calculus) analogous to that presented in Sect. 3.


Discrete Real-time
Concerning discrete real-time, we consider the approach of [12]. For a specification calculus with prefix, summation, hiding and CSP parallel operator, in addition to the usual rules for standard action transitions we have also the rules in Table 9 for σ transitions 7 . Moreover we assume the calculus to be also endowed with a recursion recX.P operator with the standard operational rule (that holds for σ transitions as well).
The transition systems obtained with the operational semantics are time de- terministic: in every state at most one outgoing σ transition is derivable by the structural operational rules (where different ways of deriving σ transitions leading to the same target states are considered as originating multiple transitions, i.e., as violating time determinism).
Standard weak bisimulation (where σ is considered as a standard visible action) is a congruence with respect to all the operators above, apart summation, as ex- pected. However, in order to obtain a congruence with respect to all the operators we have to consider an equivalence notion that is finer than standard observational congruence: the “root” condition of the equivalence (where standard transitions are matched as in standard observational congruence) can be “left” only by executing standard transitions (and not by executing σ transitions).

Definition 6.1 A relation β over processes is a rooted discrete real-time weak bisimulation if, whenever (P, Q) ∈ β:

If P
—α→ P' with α /= σ then, for some Q', Q =α⇒ Q' and P' ≈ Q'.

If Q —α→ Q' with α /= σ then, for some P', P =α⇒ P' and P' ≈ Q'.

If P
—σ→ P' then, for some Q', Q —σ→ Q' and (P ', Q') ∈ β.

If Q —σ→ Q' then, for some P', P —σ→ P' and (P ', Q') ∈ β.
Two processes P , Q are discrete real-time observationally congruent, written P  DRT
Q, iff (P, Q) is included in some rooted discrete real-time weak bisimulation.



7 Differently from [12] here we consider the CSP parallel operator, that allows us to keep the hiding and par- allel operations expressed in a separated way. This is needed, e.g., for producing a complete axiomatization via the (RecHid) axiom (see Sect. 3).



Table 9
Rules for Discrete Real-Time

Markovian Stochastic Time
Concerning Markovian stochastic time, we consider Revisited Interactive Markov Chains [4,9]. For a specification calculus with prefix, summation, hiding and CSP parallel operator, in addition to the usual rules for standard action transitions we have also the rules in Table 10 for σ ∈ IR+ transitions. In the operational rule for
prefix, σ˜ is any rate: since, as we will see, equivalence over terms abstract from
the rate of selfloops (transitions going from one state to itself) of σ transitions the particular choice of σ˜ ∈ IR+ is not important. Note that, the interleaved execution
of σ actions in parallel and choice is justified by the Markov property of exponential probability distributions, and correctly represents independent passage of time both in P and Q. Moreover we assume the calculus to be also endowed with a recursion recX.P operator with the standard operational rule (that holds for σ transitions as well).
The equivalence that we consider is a simple stochastic extension of weak bisim- ulation, called weak Markovian Bisimulation [4,9], where equivalent terms P and Q are required to have matching weak transitions of σ actions as for standard visible actions and we also have a quantitative requirement about the values of σ of matching weak transitions that is derived from (selfloop insensitive) Marko- vian bisimulation: sums of alternative σ moves that reach same equivalence classes (excluded the equivalence class that includes P and Q themselves) must match.
The selfloop insensitive variant of Markovian bisimulation that we introduced in [4,9] is, in turn, a coarser variant of standard strong Markovian bisimulation [14] (which instead considers also the equivalence class that includes P and Q them- selves) that preserves the steady state behaviour of the underlying Continuous Time Markov Chains. The transient behavior and the performance evaluation of the model in general is not changed, provided that the termination events of individ-
ual timed σ actions are considered to be unobservable, e.g. successive execution of
two timed actions is not distinguished from the execution of a single correspond- ing timed action: the equivalence just guarantees correspondence in terms of the probabilistic distribution of the overall amount of time passed.
Weak Markovian bisimulation is a congruence with respect to all the operators above, apart summation, as expected. In order to obtain a congruence with respect to all the operators we have to introduce a “root” condition in a similar way as for the discrete real-time case: the “root” of the equivalence, where standard transitions are matched as in standard observational congruence and σ actions are matched as



Table 10
Rules for Exponentially Timed Moves

in (strong) selfloop insensitive Markovian Bisimulation, can be left only by executing standard transitions (and not by executing σ transitions). We call this equivalence Markovian stochastic time observational congruence, written MST (see [4,9] for a precise definition).
We would like to note explicitly that, the possibility of adopting a coarser equiv- alent notion with respect to standard Markovian Bisimulation, where Markovian delays are considered as unobservable, is a consequence of the adoption of the time choice operator “P +t Q” instead of the standard operator “P + Q” of the basic BCCSrec calculus (and of all the other Markovian calculi like e.g. [13]): while in “P + Q”, where σ actions resolve the choice, an initial selfloop of σ actions in- side P or Q becomes a σ transition that changes the system state, this does not happen in “P +t Q”. Technically, this allows “P +t Q” to be a congruence with respect to “ MST ” that is selfloop insensitive. The adoption of a selfloop insensi- tive equivalence besides being convenient (in that is coarser) is also adequate for the definition of the semantics of operator “αt.P ” where we do not want the actual system behavior to be dependent on the particular σ˜ that is chosen.

The Axioms
Producing a complete axiomatization for the two full timed calculi requires them to be extended to encompass new operators so to be able to express normal forms of terms (e.g. the operators of the basic BCCSrec calculus) and manage and derive them (e.g. the pri(P ) operator and left and synchronization merge operators).
More precisely, in the case of the discrete time calculus, we use as terms for normal forms the terms of the basic BCCSgrec calculus whose semantics is time deterministic. Note that, including operators of the BCCSrec calculus requires real-time observational congruence to be extended so that it is also defined over terms whose semantics is not time deterministic. Such an extension is performed by making the equivalence sensible to the number of derivable σ transitions that states can execute, so that it preserves the property of time determinism (i.e. a term equivalent to a time deterministic one is time deterministic).
In the case of the Markovian stochastic time calculus, we consider observable
Markovian delays, denoted by σo (to distinguish them from unobservable ones used in the specification calculus) to be used in normal forms: in the BCCSrec syntax and in the rules of Table 1 we consider α to range over standard actions in A∪ {τ} plus σo actions (with σ ∈ IR+), instead of σ actions. Markovian stochastic time ob-

servational congruence is consistently extended to deal with observable Markovian delays σo as well: in equivalent terms P and Q, σo (weak) transitions are matched like σ (weak) transitions, with the only difference that the target selflooping equiv- alence class that includes P and Q themselves is not excluded when matching sums of σo rates, as in standard Markovian bisimulation [14]. Normal forms also make use of a delay hiding operator H(P ) defined by:

P —α→ P'

α∈A∪ {τ }
o
P —→ P'


H(P ) —α→ P'	H(P ) —σ→ P'
Intuitively, H(P ) turns every observable exponential action that is executed by P as an initial action into an unobservable one with the same rate. Terms used as normal forms are terms that include guarded recursive definitions only and belong to the following basic calculus two-level syntax:
E ::= 0 | X | H(S) | recX.E S ::= S + S | a.E | τ.E | σo.E
The idea is that, by exploiting the delay hiding operator H(P ), we can express terms of the Markovian stochastic calculus, which use unobservable Markovian delays, in terms of normal forms which use observable Markovian delays and the standard “+” operator which is compatible with them.
The axiomatization for the discrete real-time calculus is composed of the follow- ing axioms.
The axioms in Sect. 5.1 of the axiomatization of BCCSrec with maximal progress where:
· The axioms (A3) and (FUng) expressing idempotence of “+” are replaced by the axioms
(A3)	E + pri(E) = E
(FUng)  recX.(X + pri(E)) = recX.pri(E)
This is due to time determinism, i.e. in a time deterministic term P + Q, σ actions cannot be executed by both P and Q, so full idempotence would not preserve the property of time determinism as required by the equivalence.
The (Tau1) and (Tau3) axioms are restricted to α ∈ A∪{τ} instead of a general
α action (that would include also timed actions).
We consider an additional τ elimination axiom for time:
(Tau4)   α.F{σ.τ.E/X} = α.F{σ.E/X}    α∈A∪{τ} and X serial in F This axiom is a restricted version of old axiom (Tau1) of the axiomatization of
BCCSrec with maximal progress in the case α = σ, that now we have excluded. The restriction accounts for the new extended root condition of equivalence. No timed counterpart is, instead, included for the axiom (Tau3), due to the property of time determinism (as we will justify in the following).
Note that a consequence of the modification of (A3) and (FUng) is that (WUng2) is now derivable from (WUng3).

The (RecHid) axiom.
Axioms for elimination of timed prefix “αt.E”, choice “E +t E” and static oper- ators by means of auxiliary operators like, e.g., left merge and synchronization merge for the parallel operator. In the case α /= σ, “αt.E” is eliminated by the single axiom (that exploits maximal progress of“+”):
(TPre1)  αt.E = recX.(σ.X + α.E)	α∈A∪{τ}
in the case α = σ by the trivial axiom, called (TPre2), “σt.E = σ.E”.
The axiomatization for the Markovian stochastic time calculus is composed of the following axioms.
The same modification to the axioms in Sect. 5.1 of the axiomatization of BCCSrec with maximal progress considered for the discrete real-time calculus (with the only difference that, due to the structure of the basic calculus used for normal forms described above, terms used in axioms are also endowed with delay hiding oper- ators 7(P ), σo actions are used instead of σ actions, and the definition of serial variable is extended to also admit the variable to be in the scope of operators 7(P )) plus the following two axioms:
(Exp)	σo.E + σo.E = (σo + σo).E
1	2	1	2
(ExpRec)	recX.7(σo.X + σo.E + F ) = recX.7(σo.E + F )
1	2	2
Axiom (Exp) characterizes stochastic delay summation performed by standard Markovian bisimulation. Axiom (ExpRec) characterizes the self-loop insensitivity property of our coarser notion of Markovian bisimulation.
Note that, while in the context of discrete real-time the modification of axioms (A3) and (FUng) expressing idempotence of “+” and the exclusion of axiom (Tau3) in the case α = σ is due to the time determinism property, here the same modification is due to the stochastic delay summation property that similarly causes non-idempotence of “+” over timed actions.
The (RecHid) axiom.
Axioms for elimination of timed prefix “αt.E”, choice “E +t E” and static op- erators. These axioms are different from the discrete real-time case due to the different treatment of timed actions (here they are interleaved instead of being synchronized). Included in the set of axioms provided for the elimination of ev- ery static operator here we must consider also an axiom for the operator 7(P ), besides the other operators of BCCS. For timed prefix “αt.E” we have the single axiom
(TPre)  αt.E = recX.7(σo.X + α.E)
that corresponds to the axioms (TPre1) and (TPre2) presented for the discrete real-time calculus. (TPre2) is obtained from (TPre) by using the selfloop insensi- tivity axiom (ExpRec). Note that here the positive real value of σo is universally quantified: any choice is acceptable due to selfloop insensitivity.

Completeness for Timed Basic Terms with Guarded Recursive Deﬁnitions
In order to prove completeness of the axiomatization for timed observational con- gruence over the class of timed basic terms with guarded recursive definitions to be used as normal forms (defined in the previous Sect. 6.3) we make use of timed prioritized standard equation sets.
Timed prioritized standard equation sets are defined as a variant of prioritized standard equation sets (presented in Sect. 5.2) where (non-free) variables are clas- siﬁed in two types depending if they are “reached” from the initial variable by just executing timed actions or not (i.e. if they are involved in the root condition of equivalence applied to the terms represented by the equation sets or not).
More precisely, for discrete real-time we have in addition a constraint related to time determinism: in every equation there can be at most one σ action. For Markovian stochastic time we have in addition that sums of actions in equations are enclosed into a delay hiding operator 7(P ) and that timed actions in the equations are observable σo actions.
A (not involved) adaptation of the standard machinery allows us to establish one and only one solution and representability for (guarded) timed prioritized standard equation sets. Concerning the proof of mergeability, the standard machinery must be significantly modified. We need to resort to:
Preliminary “saturation” of τ actions after σ prefixes in basic terms: given two equivalent terms we have to add τ prefixes after σ prefixes not involved in the root condition (by using the (Tau4) axiom) before representing them with timed prioritized equation sets.
Development of a simpler reformulation weak bisimulation over terms with guarded recursive definitions to be used when merging guarded timed prioritized standard equation sets:
· We start by considering a simplified form of weak bisimulation definition where
=σ⇒ transitions of a term Q to be matched to —σ→ transitions of a term P are
replaced by —σ→ —τ→∗ transitions and the check is performed only if Q cannot
execute τ transitions: this can be done due to maximal progress (i.e. priority of τ over σ) and to guardedness. Such a simplified form comes from the machinery related to the BCCSrec calculus with maximal progress presented in Sect. 5.
· We then show that we can further turn —σ→ —τ→∗ transitions into strong —σ→
moves, due to discrete time determinism (for the discrete real-time calculus) or stochastic delay summation (for the stochastic Markovian time calculus). This justifies the absence of a correspondent of axiom (Tau3) for timed actions (case α = σ in (Tau3) axiom).

Completeness Technique
Completeness over finite-state terms belonging to the syntactical characterization presented in Sect. 3 (where, in the case of the “P +t Q” operator, free occurrences of X in P and Q are required to occur guarded by a standard action, i.e. in the scope of an “αt.P ” prefix with α ∈ A∪ {τ }) is obtained as usual (see Section 2.1.3)

in two steps.
Completeness over the classes defined in Sect. 6.3 of timed basic terms with guarded recursive definitions, as presented in Sect. 6.4
Normal form derivability: timed basic terms with guarded recursive definitions can always be derived from terms belonging to the syntactical characterization above as “normal” forms by using the axiomatization.
Concerning normal form derivability, terms belonging to the syntactical charac- terization above are shown to be transformable into normal form by adopting the same procedure as that of the previous Sect. 3.2 that combines unguarded recur- sion elimination of basic terms with static operator elimination by performing an inductive bottom-up transformation of terms. More precisely, here unguarded re- cursion elimination in basic terms is performed as for the calculus BCCSrec with maximal progress (see Sect. 5.3) with some modifications due, e.g., to non general idempotence of “P + Q” operator.
Note that, in the case of real-time, the axiomatization, being it sound with re- spect to real-time observational congruence, preserves the time determinism prop- erty, hence we are guaranteed that the basic terms that we get at the end of the transformation above are actually time deterministic. In the case of Markovian stochastic time, normal forms in the two-level syntactical form of Sect. 6.3 are obtained by an unfolding and folding procedure like that performed in the transfor- mation of Sect. 3.2 when eliminating static operators.

Conclusion
The most direct consequence of the work presented in this paper is the development of the extension of the standard machinery for weak bisimulation to deal with calculi for continuous real-time and general Stochastic time: this can be done by combin- ing the calculus with refinable ST actions with the calculus with (maximal-progress and) time, by considering unprioritized σ actions as ST actions, similarly to what we did in [10,5]. Note that, as shown by the machinery in [5], usage of ST actions in the context of general Stochastic time allows, not only to correctly represent systems with generally distributed delays, but also to support their refinement with terms made up of exponentially distributed delays (approximation via phase-type distributions). Finally, future work could be done in extending the completeness results to all finite-states term (not only terms of the considered syntactical char- acterization, i.e. static operators are not replicable by recursion): this would lead to a corresponding enlargement of the completeness result for any of the considered calculi.

References
J.C.M. Baeten, M. Bravetti “A generic process algebra”, in Proc. of the meeting Algebraic Process Calculi: The First Twenty Five Years and Beyond (PA’05), ENTCS 162:65-71, Bertinoro (Italy), August 2005

J.C.M. Baeten, M. Bravetti “A Ground-Complete Axiomatization of Finite State Processes in Process Algebra”, in Proc. of the 16th Int. Conf. on Concurrency Theory (CONCUR’05), LNCS 3653:248-262,
San Francisco (CA, USA), August 2005
J.C.M. Baeten and M. Bravetti “A ground-complete axiomatization of finite state processes in process algebra”, Technical Report CS Report 05-18, Technische Universiteit Eindhoven, Department of Mathematics and Computer Science, 2005.
M. Bravetti, “Revisiting Interactive Markov Chains”, in Proc. of the 3rd Int. Workshop on Models for Time-Critical Systems (MTCS 2002), ENTCS 68(5), Brno (Czech Republic), August 2002
M. Bravetti, “Specification and Analysis of Stochastic Real-Time Systems”, PhD Thesis, University of Bologna (Italy), February 2002
M. Bravetti and M. Bernardo. “Compositional asymmetric cooperations for process algebras with probabilities, priorities, and time”, in Proc. of the 1st Workshop on Models for Time-Critical Systems (MTCS 2000) , ENTCS 39(3), 2000
M. Bravetti, R. Gorrieri, “Deciding and Axiomatizing Weak ST Bisimulation for a Process Algebra with Recursion and Action Refinement”, in ACM Transactions on Computational Logic 3(4):465-520, 2002
M. Bravetti, R. Gorrieri, “A Complete Axiomatization for Observational Congruence of Prioritized Finite-State Behaviors”, in Proc. of the 27th Int. Colloquium on Automata, Languages and Programming (ICALP 2000), U. Montanari, J.D.P. Rolim and E. Welzl editors, LNCS 1853:744- 755, Geneva (Switzerland), July 2000
M. Bravetti, R. Gorrieri, “A Uniform Approach for Expressing Time in Process Algebra”, submitted to Theoretical Computer Science.
M. Bravetti, R. Gorrieri, “The Theory of Interactive Generalized Semi-Markov Processes”, in Theoretical Computer Science 282(1):5-32, 2002
R.J. van Glabbeek, F.W. Vaandrager, “Petri Net Models for Algebraic Theories of Concurrency”, in Proc. of the Conf. on Parallel Architectures and Languages Europe (PARLE ’87), LNCS 259:224-242,
Eindhoven (The Netherlands), 1987
M. Hennessy, T. Regan, “A Process Algebra for Timed Systems”, in Information and Computation, 117(2):221-239, 1995
H. Hermanns, “Interactive Markov Chains”, Ph.D. Thesis, Universit¨at Erlangen-Nu¨rnberg (Germany), 1998
J. Hillston, “A Compositional Approach to Performance Modelling”, Cambridge University Press, 1996
R. Milner, “Communication and Concurrency”, Prentice Hall, 1989.
R. Milner, “A complete axiomatization for observational congruence of finite-state behaviours”, in Information and Computation 81:227-247, 1989
