Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 348 (2020) 125–145
www.elsevier.com/locate/entcs

Indexed and Fibred Structures for Hoare Logic
U. E. Wolter1
Department of Informatics - University of Bergen - Bergen - Norway
A. R. Martini 2
Av. Marechal Andrea 11/210 - Porto Alegre - Brazil
E. H. H¨ausler3
Departamento de Ciˆencia da Computa¸c˜ao - PUC-Rio - Rio de Janeiro - Brazil

Abstract
Indexed and fibred categorical concepts are widely used in computer science as models of logical systems and type theories. Here we focus on Hoare logic and show that a comprehensive categorical analysis of its axiomatic semantics needs the languages of indexed category and fibred category theory. The structural features of the language are presented in an indexed setting, while the logical features of deduction are modeled in the fibred one. Especially, Hoare triples arise naturally as special arrows in a fibred category over a syntactic category of programs, while deduction in the Hoare calculus can be characterized categorically by the heuristic deduction = generation of cartesian arrows + composition of arrows.
Keywords: Hoare logic, weakest liberal precondition, indexed categories, institution, fibrations, Grothendieck construction


Introduction
A logic for reasoning about programs has to rely on a logic for reasoning about states and other specific concepts, such as environments and memory locations. Besides that, everything has to fit compositionally in a way that deduction on properties on states can be directly used on deduction on statements that must be combined in order to derive properties on programs. Each constituent at the syntactic level

1 Email: Uwe.Wolter@uib.no
2 Email: alfio.martini@gmail.com
3 Email: hermann@inf.puc-rio

https://doi.org/10.1016/j.entcs.2020.02.008
1571-0661/© 2020 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

of the language should correspond to a semantic concept and this correspondence has to preserve structure and logic.
It is known that functors naturally preserve the structure, but they do not have to preserve logic properties. Usually, if one wants to preserve logical properties, a certain notion of universality has to be used. A widely used concept for providing this notion of universality is the concept of cartesian arrow. Although cartesian arrows are embedded in the definition of fibred categories, any indexed category also provides these cartesian arrows as well, albeit with more structural information [1,4].
The interplay between fibred and indexed constructions, we will rely on in this paper, is quite well-known for the Category and the Logic community. Indexed families of sets ({Ai}i∈I ) and display mappings (d : i∈I Ai → I) can be considered as the motivating set-theoretical concepts for their categorical counterparts, indexed and fibred categories (fibrations), respectively. In set theory, these counterparts are logically equivalent, but fibred and indexed categories are formally equivalent only when they are taken from a 2-category point of view (see, for instance, [13]).
The aim of the paper is neither to replace traditional set-theoretical descriptions of logics by a corresponding categorical generalization nor to coin an axiomatization of just another abstract categorical framework for logics in the line of (partial) hyperdoctrines [8], institutions [6], and context institutions [11]. Our aim is, in contrast, to demonstrate how indexed and fibred structures can be used, in a flexible and creative way, to model and reason about logical systems and to present how the syntactic and the semantic constituents of logical systems interplay with each other.
Hoare logic [7] is presented in the literature in quite diverse ways. The weakest liberal precondition [3], for example, can be defined in a semantic way by predicate transformers or in a syntactic way. The semantics of programs can be defined by partial state transition functions or by predicate transformers. As the main result of the paper we show how all these diverse and divergent features of Hoare logic can be described in a smooth, systematic and uniform way using the language of indexed categories and the language of fibred categories. Our analysis shows that a highly appropriate way to deal with axiomatic semantics, at least in the format of Hoare logic, is to use both categorical tools in a way that the structural features of the language are presented in an indexed setting and the features of deduction in the fibred one. This underlines, especially, that a good understanding of the correlations between indexed and fibred concepts can be very helpful in order to present, analyze and use these logics in an appropriate way.
The paper is organized as follows. To provide a unified and common ground for our categorical analysis we recapitulate, first, in Section 2 basic concepts and constructions from domain theory, the IMP language, and Hoare Logic. We also provide a list with the essential categories used throughout the text. Section 3 analyzes the structural features of the Hoare logic by means of indexed concepts. Especially, we are concerned about a categorical account of the weakest liberal pre- condition. In Section 4 we transform, by means of the Grothendieck construction,

the indexed account into a fibred one and we discuss Hoare triples and Hoare deduc- tion calculus in the light of the corresponding fibred categories. We close the paper by a summary of the essential ideas treated in this discussion, that is to say, that the structural features of the language are presented in indexed categories while the features of deduction are in the fibred one.
Preliminary Concepts
The material in this section is, for the most part, well-known and it is included here in order to fix notation and to improve readability of the paper.

A Small Imperative Language
The IMP language is a simple imperative language with only three data types. The set B = {true, false} of boolean values, ranged over by metavariables u, v, . . . The set Z = {..., −2, 1, 0, 1, 2,.. .} of integer numbers, ranged over by metavari- ables m, n, ... The countably infinite set Loc of memory locations, ranged over by metavariables x, y, . . . We use the terms locations, variables and identifier in- terchangeably. Also, we consider programs that use a finite number of locations and we assume there are enough locations available for any program. The gram- mar for IMP comprises three syntactic categories. AExp, arithmetic expressions, ranged over by a, aj,... BExp, boolean expressions, ranged over by b, bj,... Prg, programs, ranged over by c, cj,... The following productions define the abstract syntax of IMP :

a ∈ AExp ::= n | x | a0 + a1 | a0 − a1 | a0 × a1
b ∈ BExp ::= v | a0 = a1 | a0 ≤ a1 | ¬b | b0 ∨ b1 | b0 ∧ b1
c ∈ Prg	::= skip | x := a | c0; c1 | if b then c0 else c1 fi | while b do c od
In order to evaluate an expression or to define the execution of a command, we need the notion of a memory state. A memory state σ is an element of the set Σ, which contains all functions from locations to integers: σ ∈ Σ= (Loc → Z). Given a state σ, we denote by σ[x '→ n] the memory where the value of x is updated to n, i.e.,
σ[x '→ n](y)=	n	if y = x
σ(y) if y /= x
In order to define the denotational semantics of expressions and programs, we use the metalanguage of the lambda calculus enriched with boolean and arithmetic constants (operations). Besides lambda abstraction and function application, we have the conditional operator t → t0, t1, which returns t0 if t = true and t1, if t = false. The interpretation functions are defined by structural recursion over the

abstract syntax for expressions and programs. For any set D, we have the flat CPO
D⊥ , D ∪ {⊥} (where ⊥ /∈ D) such that d ±D  dj iff d = dj or d = ⊥. The element
⊥D represents undefinedness or a divergence in a computation. Given a function f : D → E⊥, we define its lifting f∗ : D⊥ → E⊥, such that f∗(d)= f (d) for all d ∈ D and f∗(⊥D) = ⊥E. Every function in (D⊥ → E⊥) and (D → E⊥) is continuous. We take for granted the standard denotation functions E[[·]] : AExp → Σ → Z and B[[·]] : BExp → Σ → B and assume they are defined elsewhere.

P[[·]] : Prg → Σ → Σ⊥

P[[x := a]] = λσ. σ[x '→ E[[a]]σ]
P[[ skip ]] = λσ. σ

P[[c0; c1]] = λσ. (P[[c1]]∗(P[[c0]]σ)
P[[if b then c0 else c1 fi]] = λσ. B[[b]]σ → P[[c0]]σ, P[[c1]]σ

P[[while b do c od]] = fix(Γb,c)= .

n≥0
Γn (⊥Σ→Σ
),  where

Γb,c : (Σ → Σ⊥) → (Σ → Σ⊥)= λϕ. λσ. B[[b]]σ → ϕ∗(P[[c]]σ),σ 

Hoare Logic
The central feature of Hoare logic are the Hoare triples or, as they are often called, partial correctness assertions. We use both expressions interchangeably. A triple describes how the execution of a piece of code changes the state of the computation. A Hoare triple is of the form {P} c {Q}, where P, Q are assertions in a specification language and c ∈ Prg is a IMP program. P is called the precondition and Q the postcondition of the triple. An informal understanding about the meaning of a Hoare triple can be given as follows: any terminating execution of c from a state satisfying P ends up in a state satisfying Q.
Our specification logic is built of boolean expressions which are enriched with quantifiers and a countably infinite set of integer (logical) variables IVar. The ex- tended language of arithmetic expressions AExpV and the specification language of program assertions Assn are defined by the following abstract syntax, where i, j,... range over integer variables, P, Q, R, ... over program assertions, aop ∈ {+, −, ×}, bop ∈ {∧, ∨, →}.

a ∈ AExpV ::= n | x | i | a0 aop a1
P ∈ Assn	::= a0 ≤ a1 | a0 = a1 | ¬P | P0 bop P1 | ∀i. P | ∃i. P
The set of free variables in arithmetic expressions is comprised by the integer variables that occur in it. Free variables in program assertions are comprised by all integer variables which are not in the scope of existential and universal quantifiers, as presented in any introduction to first order logic. Both sets of free variables (FV ) are easily defined by structural induction. For instance, FV (x = i ∧ y = j)= {i, j}

and FV (∀i. ∀j. (i ≥ 0 ∧ j > 0 → i = xb + y ∧ 0 ≤ y < j)) = ∅, assuming x, y are locations.
An environment for the (free) integer variables in an expression is a function env : IVar → Z. The set of all such enviroments is Env = (IVar → Z). The extended interpretation function E[[·]] : AExpV → Env → Σ → Z receives now an additional argument. The definition is analogous to the case of arithmetic expressions AExp. The only interesting cases are E[[i]] env σ = env(i) and E[[x]] env σ = σ(x).
In order to define satisfaction and validity of Hoare triples, we need an analogous definition for program assertions, i.e., we have to define σ |=env P for every program assertion P ∈ Assn, arbitrary environments env : IVar → Z and states σ ∈ Σ⊥. The definition is standard and is done by structural induction on the structure of P as is usually done in logic. We assume that ⊥ |=env P .
A program assertion P is valid in an environment env : IVar → Z, written
|=env P , iff ∀σ ∈ Σ⊥. σ |=env P . A program assertion P is called (arithmetic) valid, written |= P , iff ∀ env : IVar → Z. |=env P . We say that Q is a logical consequence of P in an environment env : IVar → Z, written P |=env Q, iff
∀σ ∈ Σ⊥. σ |=env P → σ |=env Q. Moreover, we say that Q is a logical consequence
of P , written P |= Q iff ∀σ ∈ Σ⊥. ∀ env : IVar → Z. σ |=env P → σ |=env Q.
A categorical treatment of Hoare Logic needs more precise definitions of Hoare Logic concepts. We say that a triple {P} c {Q} is true at a state σ ∈ Σ⊥ and in an env : IVar → Z, written σ |=env {P} c {Q} iff σ |=env P implies P[[c]]∗σ |= Q. The triple is valid in an environment env : IVar → Z, written |=env {P} c {Q} iff
∀σ ∈ Σ⊥. σ |=env {P} c {Q}. Finally, a partial correctness assertion is (arithmetic)
valid, written |= {P} c {Q}, iff ∀ env : IVar → Z. |=env {P} c {Q}.
Let env : IVar → Z be an environment and P an assertion. Then the extension of the assertion P w.r.t. env, written as Penv is defined as Penv , {σ ∈ Σ⊥ | σ |=env P}. Then it follows that P |= Q iff ∀ env : IVar → Z. Penv ⊆ Qenv. By the same token, we have |= {P} c {Q} iff ∀ env : IVar → Z. P[[c]]∗(Penv) ⊆ Qenv.
Let c ∈ Prg,Q ∈ Assn and env : IVar → Z. Then the semantic weakest liberal precondition, written wlpenv[[c, Q]], of Q with respect to c in env is defined by wlpenv[[c, Q]] , {σ ∈ Σ⊥ | P[[c]]∗σ |=env Q} = (P[[c]]∗)−1(Qenv). Thus we have
|= {P} c {Q} iff ∀ env : IVar → Z. Penv ⊆ wlpenv[[c, Q]].
The following rules of the Hoare Proof Calculus define inductively the partial correctness relation ▶⊆ Assn × Prg × Assn, where the expression Q[x/a] means the simultaneous replacement of every ocurrence of the location x in the assertion Q by the arithmetic expression a.




▶ {P}skip{P}
Skip 	 Assn
▶ {Q[x/a]}x := a{Q}
▶ {P}c1{Q}  ▶ {Q}c2{R}

▶ {P}c1; c2{R}

Comp



▶ {P ∧ b}c1{Q} ▶ {P ∧ ¬b}c2{Q}

▶ {P} if b then{c1} else {c2} fi {Q}

IfElse
▶ {P ∧ b}c{P}

▶ {P} while b do c od {P ∧ ¬b}

PWhile



▶ P → Q  ▶ {Q}c{R}

▶ {P}c{R}

PreStr
▶ {P}c{Q}	▶ Q → R


▶ {P}c{R}

PosWk


Let {P} c {Q} be a partial correctness assertion. Then the Hoare calculus is sound, i.e., every theorem is a valid formula.

▶ {P } c {Q}	only if	|= {P} c {Q}
For each program c and assertion Q we assume there is an assertion wlp(c, Q) ∈ Assn. Intuitively, it is the weakest precondition that ensures that if the execution of c terminates, then Q holds in the final state, i.e., with the property that |=
{wlp(c, Q)} c {Q}. We also assume that for any env : IVar → Z that the program assertion language is expressive enough, i.e.,

wlp(c, Q)env = wlpenv[[c, Q]]	(1)

Categories
The reader is assumed to be familiar with the basic notions of category theory, such as adjunctions, fibrations and indexed categories [1]. To improve readability, Table 1 lists all categories introduced and used in the paper.
Table 1
Categories used and introduced in the paper


Hoare Logic and Indexed Categories
As exemplified in the last section, Hoare Logic addresses state based systems and is concerned with the behavior of programs. In our example of a sequential imper- ative programming language, we are dealing with systems with a single component system, i.e., a single program or algorithm. In general, however we may consider also systems constituted by different components.
In the following, we analyze Hoare Logic with both indexed and fibred categorical structures as developed, for example, in [10]. We intend to give an answer to the fundamental question “What are the characteristic structural features of Hoare Logic?” and use these structures to give a categorical presentation for it.
In the present section we will lift this insight onto a more abstract and structured level. We will develop, step by step, an abstract categorical presentation of the Hoare logic of IMP by means of indexed categorical concepts and constructions. Hoare Logic arises in two steps: First, a “logic of states” is defined and, based on this, a “logic of programs” is developed.

Logic of States
In this subsection we analyze the concept of states in IMP as well as the language and semantics of assertions about states. Parallel to this analysis we develop a general structure of a “logic of states”.
System structure and States: In the simple language IMP, we can describe programs on a single “machine”. In our categorical presentation we will use the identifier C to denote this unique component. The semantics of a system component is given by its states. In case of IMP, the semantics of the unique component C is the cpo Σ⊥ = (Loc → Z)⊥. If we consider now the very simple category Str consisting only of the object C and its identity we can state that the definition of the concept of a state for IMP can be captured by the definition of a functor st : Strop → Cpo with st(C) , Σ⊥ = (Loc → Z)⊥, where Cpo is the category with complete partial orders as objects and continuous functions as morphisms.
Note that Str has only one object since we consider, following the traditional exposition, programs only in the context of all program variables (locations). In case we would consider programs in the context of finite subsets of Loc, the category Strop would turn into a finite product category ([12]).
Contexts and Environments: Any categorical analysis and presentation of logics emphasizes the importance of local contexts for expressions and formulas. In our case, this “categorical imperative” suggests that it is not fully appropriate to take the countably infinite set IVar as the only (default) context for all assertions about states. Instead, it is more appropriate to work with finite subsets of IVar as “local contexts”. Following this insight, contexts in our categorical presentation of IMP are given by the (syntactic) partial order category Cont , (℘fin(IVar), ⊆).
The semantics of contexts is given by environments, i.e., by a functor env :
Contop → Set with env(γ) , (γ → Z) for all contexts γ ∈ ℘fin(IVar) and with

env(γ ⊆ γj) = pγ′,γ : (γj → Z) → (γ → Z) a projection map given by pre- composition pγ′,γ (ej) , inγ,γ′ ; ej for all environments ej ∈ (γj → Z) where inγ,γ′ : γ → γj is the inclusion map corresponding to the inclusion γ ⊆ γj.
Assertions: In case of IMP, all assertions are statements about the states of the unique system component, and their definition is based on locations for this single component. In our categorical analysis, we abstract from locations and define
assn(γ) , {P ∈ Assn | free(P ) ⊆ γ},  for all γ ∈
℘fin(IVar)
where free(P ) ⊆ IVar is the finite set of all free integer variables in P . This defines a functor assn : Cont → Set. For any inclusion γ ⊆ γj the corresponding inclusion map assn(γ ⊆ γj) : assn(γ) → assn(γj) just states that for any assertion P the inclusion free(P ) ⊆ γ entails the inclusion free(P ) ⊆ γj.
Generalization Assertions: In case of a system with more components we should have assertions for each single component. For example, different components should have different locations (addresses). Moreover, we should be able to translate statements about a subsystem into statements about the corresponding compound system (but not the other way around). Therefore we propose to assume for the general case a functor assn : Str × Cont → Set.
Satisfaction: The inductive definition of satisfaction in Section 2.2 can be easily modified to take into account finite contexts. We will get, in such a way, satisfac- tion for IMP as a family of ternary relations between states, environments, and assertions indexed by contexts γ ∈ |Cont|
|=γ ⊆ Σ⊥ × env(γ) × assn(γ).
Moreover, the definition of satisfaction for IMP ensures compatibility w.r.t. context extensions:
Proposition 3.1 (Satisfaction is compatible w.r.t. context extension) For any inclusion γ ⊆ γj, any state σ ∈ Σ⊥, any environment ej ∈ env(γj) and any as- sertion P ∈ assn(γ) we have
(σ, env(γ ⊆ γ )(e )) = (σ, pγ′,γ (e )) |=γ P	iff	(σ, e ) |=γ′ P.
Generalization Satisfaction: In the general setting we have the functors st : Strop → Cat, env : Contop → Cat, and assn : Str × Cont → Set. Cat is the category of all small categories and all functors between them where a category C is small iff its collection of morphisms (and thus also its collection of objects) is a set. Satisfaction is defined as a family of ternary relations between states, environments, and assertions indexed by objects C ∈ |Str| (component identifiers) and contexts γ ∈ |Cont|
|=C,γ ⊆ |st(C)|× |env(γ)|× |assn(C, γ)|.
Moreover, the following compatibility condition should be satisfied: For any con- text morphism i : γ → γj, any morphism r : C → Cj in Str, any state σj ∈

|st(Cj)|, any environment ej ∈ |env(γj)| and any assertion P ∈ assn(γ) we have (st(r)(σj), env(i)(ej)) |=C,γ P  iff (σj, ej) |=C′,γ′ assn(r, i)(P ).
Extension and Semantic Entailment: We can combine the two functors st : Strop → Cpo and env : Contop → Set into a functor st ⊗ env : (Str × Cont)op → Set with (st ⊗ env)(C, γ) , st(C) × env(γ) = Σ⊥ × env(γ) for all pairs of objects
(C, γ) ∈ |Str×Cont| and with (st⊗env)(idC,γ ⊆ γj) , idΣ  ×pγ′,γ : Σ⊥×env(γj) →
Σ⊥ × env(γ) for all pairs of morphisms (idC,γ ⊆ γj) in Str × Cont.
By applying the contra-variant power set construction we obtain then a functor (st ⊗ env)—1 : Str × Cont → Po, where Po is the category of partial orders and monotone functions, with (st ⊗ env)—1(C, γ) , (℘(Σ⊥ × env(γ)), ⊆) for all pairs of objects (C, γ) ∈ |Str × Cont| and with
(st ⊗ env)  (idC,γ ⊆ γ ) , (idΣ⊥ × pγ′,γ )  : ℘(Σ⊥ × env(γ)) → ℘(Σ⊥ × env(γ ))
for all pairs of morphisms (idC,γ ⊆ γj) in Str × Cont, i.e., for all E ⊆ Σ⊥ × env(γ) we have
(idΣ⊥ × pγ′,γ )	(E )= {(σ, e ) ∈ Σ⊥ × env(γ ) | (σ, pγ′,γ (e )) ∈ E}.
Remark 3.2 [Logic of States as an Institution] A closer look at the development so far shows that we have described actually an institution ST [6]. The category of abstract signatures is the product category Str × Cont. Our sentence functor is the functor assn : Str × Cont → Set and the two functors st : Strop → Cat and env : Contop → Cat can be combined into a functor st ⊗ env : (Str × Cont)op → Cat with (st ⊗ env)(C, γ) , st(C) × env(γ) for all pairs of objects (C, γ) ∈ |Str × Cont| and with (st ⊗ env)(r, i) , st(r) × env(i) : st(Cj) × env(γj) → st(C) × env(γ) for all pairs of morphisms (r : C → Cj,i : γ → γj) in Str × Cont.
The family of ternary satisfaction relations can be considered as a family of binary satisfaction relations in ST and the satisfaction condition above becomes the satisfaction relation in ST.
Based on the development so far, we can define for any context γ ∈ |Cont| a map extγ : assn(γ) → ℘(Σ⊥ × env(γ)) providing for each assertion P ∈ assn(γ) its extension
extγ(P ) , {(σ, e) ∈ Σ⊥ × env(γ) | (σ, e) |=γ P}.
We will denote here semantic entailment by P H Q instead of P |= Q as in Section
2.2. Semantic entailment for single assertions P, Q ∈ assn(γ) with finite context γ
is defined then by
P Hγ Q  iff  extγ(P ) ⊆ extγ(Q)	(2)
In categorical terms, this means that we extend assn(γ) to a preorder assnH(γ) , (assn(γ), Hγ) such that extγ turns into a monotone function extγ : (assn(γ), Hγ) → (℘(Σ⊥ × env(γ)), ⊆).
Remark 3.3 [Cartesian Closed Category] The preorder category (assn(γ), Hγ), for any context γ, is Cartesian closed with products ∧, sums ∨ and exponentiation →, i.e., we have

P ∧ Q Hγ R	iff	P Hγ (Q → R).	2
Proposition 3.1 ensures now, that for any context inclusion γ ⊆ γj the corre- sponding mapping assn(γ ⊆ γj) is monotonic w.r.t. semantic entailment, i.e., we obtain a functor
assn(γ ⊆ γ ): (assn(γ), Hγ) → (assn(γ ), Hγ′ ).
Globally, we get, in such a way, a functor assn : Str × Cont → Pre where Pre is the category of preorders and monotone functions. Moreover, compatibility of satisfaction ensures that extensions behave in a “natural way”:
Proposition 3.4 The family of functors extγ : (assn(γ), Hγ) → (℘(Σ⊥×env(γ)), ⊆
) with γ ∈ |Cont| constitutes a natural transformation ext : assn ⇒ (st ⊗ env)—1 :
Str × Cont → Pre, where we recall that Po is a subcategory of Pre.


C	γ	Σ,⊥ ,
env,(γ,)	(℘(Σ⊥
× env(γ)), ⊆) ¸e,xtγ
(assn(γ), Hγ)

idC
⊆	idΣ⊥
 j
pγ′,γ

j
(idΣ⊥
×pγ′,γ )−1

   j

¸ex,tγ′
assn(γ⊆γ′)

 j 

C	γ	Σ⊥
env(γ )
(℘(Σ⊥ × env(γ )), ⊆)	(assn(γ ), Hγ′ )

Generalization Extension and Semantic Entailment: The general case works completely analogously: The two functors st : Strop → Cat and env : Contop → Cat can be combined into a functor st ⊗ env : (Str × Cont)op → Cat with
(st ⊗ env)(C, γ) , st(C) × env(γ)
a product of categories for all pairs of objects (C, γ) ∈ |Str × Cont| and with (st ⊗ env)(r, i) , st(r) × env(i): st(Cj) × env(γj) → st(C) × env(γ)
for all pairs of morphisms (r : C → Cj,i : γ → γj) in Str × Cont.
The functor (st ⊗ env)—1 : Str × Cont → Po is obtained by applying the contra- variant power construction for categories. That is, we consider for all pairs of objects (C, γ) ∈ |Str × Cont| the partial order of all subcategories of st(C) × env(γ):
(st ⊗ env)—1(C, γ) , (℘(st(C) × env(γ)), ⊆)
and for all pairs of morphisms (r, i): (C, γ) → (Cj, γj) in Str × Cont we consider the pre-image functor
(st ⊗ env)—1(r, i) , (st(r) × env(i))—1.
For any component identifier C ∈ |Str| and any context γ ∈ |Cont| we get a map extC,γ : assn(C, γ) → ℘(st(C) × env(γ)) with extC,γ(P ) the full subcategory of st(C) × env(γ) given by the set of objects
|extC,γ(P )| , {(σ, e) ∈ |st(C) × env(γ)|| (σ, e) |=C,γ P}.

Semantic entailment for single assertions is defined by	P HC,γ Q	iff	extC,γ(P ) ⊆
extC,γ(Q).
This means that we extend assn(C, γ) to a preorder category assnH(C, γ) ,
(assn(C, γ), HC,γ) such that extC,γ turns into a full functor
extC,γ : (assn(C, γ), HC,γ) → (℘(st(C) × env(γ)), ⊆).
Compatibility of satisfaction ensures, that for any context morphism i : γ → γj and any morphism r : C → Cj in Str the corresponding mapping assn(r, i) is monotonic w.r.t. semantic entailment, i.e., we have a functor
j	j
assn(r, i): (assn(C, γ), HC,γ) → (assn(C ,γ ), HC′,γ′ ).
Globally, we get, in such a way a functor assn : Str × Cont → Pre. Moreover, compatibility of satisfaction ensures that the functors extC,γ constitute a natural transformation ext : assn ⇒ (st ⊗ env)—1. Note, that the pre-image of a full subcategory w.r.t. a functor is a full subcategory as well.


C	γ	st(C)	env(γ)	(℘(st(C) × env(γ)), ⊆) ¸ext,C,γ
assn
(C, γ)

,,
r	i	st(r)
,,
env(i)

(st(r)×env(i))−1
H
assn(r,i)

	
 j	 j	j	j
j	j	ex¸tC,′,γ′

  j	j

C	γ	st(C )
env(γ )
(℘(st(C ) × env(γ )), ⊆)	assnH(C ,γ )

Logic of Programs
Here we extend our analysis to programs in IMP and their semantics. Based on this we give an indexed categorical account of partial correctness assertions based on the concept of the weakest liberal precondition.
Programs: Programs in IMP are defined in a way that we can naturally consider them as arrows in a syntactic category Prg with C the only object. The identity on C can be considered as the program skip and composition in Prg is given by sequential composition of programs.
The categories Str and Prg do have the same object and the definition of the denotational semantics of programs based on the equations
[[ skip ]]σ = σ	and	[c1; c2]]∗σ = [[c2]]∗([[c1]]σ)	(3) means that we extend the functor st : Strop → Cpo to a functor sem : Prgop → Cpo
with sem(c) , [[c]]∗ : Σ⊥ → Σ⊥ for all the “program arrows” c in Prg. Extension means that we have st(C)= sem(C)= Σ⊥ = (Loc → Z)⊥.
Generalization Programs: Analogously, we extend Str to a category Prg with
|Str| = |Prg| by introducing new arrows which represent programs/methods and we extend the functor st : Strop → Cat to a functor sem : Prgop → Cat.
Weakest Liberal Precondition: In the same way as before we can combine the two functors sem : Prgop → Cpo and env : Contop → Set into a functor sem ⊗ env :

(Prg × Cont)op → Set with
(sem ⊗ env)(C, γ) , sem(C) × env(γ)= Σ⊥ × env(γ) for all pairs of objects (C, γ) ∈ |Prg × Cont| = |Str × Cont| and
(sem ⊗ env)(c, γ ⊆ γ ) , [[c]] × pγ′,γ : Σ⊥ × env(γ ) → Σ⊥ × env(γ)
for all pairs of morphisms (c, γ ⊆ γj) in Prg × Cont. The elements in Σ⊥ × env(γ) are our “states” while the maps [c]]∗ × pγ′,γ are “state transition functions”. By applying the contra-variant power construction we obtain a functor (sem⊗env)—1 :
Prg × Cont → Po which extends the functor (st ⊗ env)—1. That is, we have
(sem ⊗ env)—1(C, γ) , (℘(Σ⊥ × env(γ)), ⊆) for all pairs of objects (C, γ) ∈ |Prg × Cont| = |Str × Cont| and
(sem ⊗ env)	(c, γ ⊆ γ ) , ([[c]] × pγ′,γ )
for all pairs of morphisms (c, γ ⊆ γj) in Prg × Cont. The elements in ℘(Σ⊥ ×env(γ)) are our “predicates” while the maps ([[c]]∗ × pγ′,γ )—1 are “predicate transformers”.
The “predicate transformer” functor (sem ⊗ env)—1 provides just another way to present the semantic weakest liberal precondition from Section 2.2.
Lemma 3.5 Given a program morphism c in Prg, a context γ ∈ |Cont|, and an assertion Q ∈ assn(γ), we have for any state σ ∈ Σ⊥ and any environment e ∈ env(γ)
σ ∈ wlpe[[c, Q]]	iff	(σ, e) ∈ ([[c]]∗ × idγ)—1(extγ(Q))
The quest for a weakest liberal precondition and, especially, the interplay be- tween the semantic and the syntactic version of weakest liberal precondition can be presented now in our indexed framework as follows:
Indexed categorical quest for weakest liberal precondition: Extend the functor assn : Str × Cont → Pre to a functor wlp : Prg × Cont → Pre such that the family of functors
extγ : (assn(γ), Hγ) → (℘(Σ⊥ × env(γ)), ⊆)
with γ ∈ |Cont| constitutes also a natural transformation	ext : wlp ⇒ (sem ⊗
env)—1.


C	γ	Σ,⊥ ,
env,(γ,)	(℘(Σ⊥
× env(γ)), ⊆) ¸e,xtγ
(assn(γ), Hγ)

c	⊆	[[c]]∗
 j
pγ′,γ

j
([[c]]∗×pγ′,γ )−1

   j

¸ex,tγ′
wlp(c,γ⊆γ′)?

 j 

C	γ	Σ⊥
env(γ )
(℘(Σ⊥ × env(γ )), ⊆)	(assn(γ ), Hγ′ )

Analysis of the Indexed categorical quest for weakest liberal precondi- tion: Any arrow (c, γ ⊆ γj) in Prg × Cont can be decomposed into (c, idγ); (idC,γ ⊆

γj) with (idC,γ ⊆ γj) an arrow in Str × Cont. Since we require that wlp is an ex- tension of assn we have wlp(idC,γ ⊆ γj)= assn(γ ⊆ γj). So the new requirement is actually that we have functors wlp(c, idγ) : (assn(γ), Hγ) → (assn(γ), Hγ). For notational convenience we will use for these ”new functors” the notation wlpγ(c) , wlp(c, idγ).
The requirement that wlpγ(c) isa map with wlpγ(c); extγ = extγ; ( [c]]∗×idenv(γ))—1 is equivalent to condition (1) and comprises the requirement that our language of assertions is expressive. The additional requirement that wlpγ(c) becomes a functor means that the syntactic weakest liberal precondition is monotonic w.r.t. semantic entailment.
To validate that the naturality requirements wlpγ(c); extγ = extγ; ( [c]]∗×idenv(γ))—1 for the new arrows (c, idγ) in Prg × Cont are sufficient to ensure naturality for all arrows in Prg × Cont, we have to check if the following cube commutes:


(℘(Σ⊥ × en,v,(γj)), ⊆)
¸,



(2)
extγ′
(assn(γj), Hγ′ )
  ,,

(℘(Σ
× env(γ)), ⊆) ¸e,xtγ (assn(γ), H )

⊥	,,	,, γ

([[c]]∗×idenv(γ′))−1
(1)
([[c]]∗×idenv(γ))−1
wlpγ (c)
(4)
wlpγ′ (c)

(℘(Σ⊥

× env(γ)), ⊆) ¸e,xtγ (assn(γ), H )
(3)


(℘(Σ⊥ × env(γ

extγ′
z˛
(assn(γ ), Hγ′ )


That the small inner and the big outer square commute is the naturality requirement for the new functors wlpγ. Left square (1) commutes due to the functoriality of the contra-variant power set construction and the equalities ([[c]]∗ × idenv(γ)); (id × pγ′,γ ) = ( [c]]∗ × pγ′,γ ) = (id × pγ′,γ ); ([[c]]∗ × idenv(γ)). Top square (2) and bottom square (3) commute since the functors envγ constitute a natural transformation ext : assn ⇒ (st⊗env)—1 (see Subsection 3.1). That the right square (4) commutes means that the weakest liberal precondition of an assertion P should only depend on the free variables in P . This requirement is satisfied for any traditional Hoare logic since those logics usually rely on the finite set of free variables in P as the implicit finite context of P .
Compositionality of Weakest Liberal Precondition: Traditional logical de- duction systems are defined based on (and can only provide) logical equivalence. In our indexed setting this is reflected by the observation that it is nearly im- possible to define/deduce syntactic weakest liberal preconditions in such a way that we have compositionality up to syntactic identity. That is, for an assertion P ∈ assn(γ) and programs c1, c2 we will, in general, not have wlpγ(c1; c2)(P ) = 
wlpγ(c2)(wlpγ(c1)(P )). We will only have that wlpγ(c1; c2)(P ) and wlpγ(c2)(wlpγ(c1)(P)) are logical equivalent, i.e., isomorphic in (assn(γ), Hγ). This means that our “in- dexed categorical quest” has to be relaxed to become reasonable.

Relaxed Indexed categorical quest for weakest liberal precondition: Ex- tend the functor assn : Str × Cont → Pre to a pseudo functor wlp : Prg × Cont → Pre such that the family of functors

extγ : (assn(γ), Hγ) → (℘(Σ⊥ × env(γ)), ⊆)

with γ ∈ |Cont| constitutes also a natural transformation  ext : wlp ⇒ (sem ⊗
env)—1.


Hoare Logic and Fibrations
The traditional presentation of the structural features of Hoare logic, as outlined in Section 2.2, is essentially an indexed one. In the last section we have elucidated this observation by lifting the traditional presentation to a more general and structured presentation based on indexed categories. There are now, at least, two reasons to move from the indexed setting to a fibred one:
A more structural reason is that it is technically quite uncomfortable to work with pseudo functors. To work, in those cases, with the fibred equivalent of pseudo functors is more reasonable.
The essential reason in light of logic is, however, that we need a “technological space” where logical deduction can take place.


Syntactic Fibrations
The Grothendieck construction is the main technique for providing a fibred category from an indexed category. We do not include a general definition of this construction but describe in detail all the four special cases we consider in this section. By applying the appropriate variant of the Grothendieck construction we obtain out of the functor assn : Str × Cont → Pre a category of assertions about states:

Definition 4.1 [Category Assn] The category Assn of “state assertions” is defined as follows:
objects: all pairs (γ.P ) with a context γ ∈ |Cont| and an assertion P ∈ assn(γ).
arrows: from (γ.P ) to (γj.Q) are pairs (γj ⊆ γ, Hγ) with γj ⊆ γ an arrow in Cont
and P Hγ Q = assn(γj ⊆ γ)(Q) an arrow in assn(γ).
identities: the identity on object (γ.P ) is (idγ, =).
composition: composition of two arrows (γj ⊆ γ, Hγ) : (γ.P ) → (γj.Q) and (γjj ⊆ γj, Hγ′ ) : (γj.Q) → (γjj.R) is the arrow (γjj ⊆ γ, Hγ) : (γ.P ) → (γjj.R). Composition is ensured by the monotonicity of context extensions w.r.t. semantic

entailment and the associativity of semantic entailment.


C,,
idC
γ,,
⊆
(assn(γ), Hγ)	P Hγ Q,,Hγ R,,
assn(γ′⊆γ)

C,,
idC
C
γj
,,
⊆
γjj
(assn(γj), Hγ′ )
,,
assn(γ′′⊆γ′)
(assn(γjj), Hγ′′ )
_
Q Hγ′
_
R,,

_
R


Moreover, we obtain a projection functor Fassn : Assn → (Str × Cont)op with
Fassn(γ.P ) , (C, γ) and Fassn(γj ⊆ γ, Hγ) , (idC, γj ⊆ γ).
The general properties of Grothendieck constructions provide:
Theorem 4.2 The functor Fassn : Assn → (Str × Cont)op is a (split) ﬁbration where (γj ⊆ γ, Hγ) : (γ.P ) → (γj.Q) is a cartesian arrow if, and only if, P and Q = assn(γj ⊆ γ)(Q) are equivalent w.r.t. semantic entailment, i.e., isomorphic in (assn(γ), Hγ).
Remark 4.3 The presentation of assertions about states as a fibration makes evi- dent that the deductive apparatus on those assertions is essentially based on substi- tution (changing of context) and propositional reasoning in the fibres (assn(γ), Hγ

—1
assn
(C, γ) (compare Remark 3.3). That we have a fibration ensures that every

first-order variable is universally quantified and that the reasoning on them is sound.
On the other hand, existentially quantified assertions have their sound semantics provided by the cartesian structure of the fibration.	2

In the same way, the pseudo functor wlp : Prg × Cont → Pre gives rise to a category of partial correctness assertions:
Definition 4.4 [Category Pca] The category Pca of “partial correctness assertions” is defined as follows:
objects: all pairs (γ.P ) with a context γ ∈ |Cont| and an assertion P ∈ assn(γ).
arrows: from (γ.P ) to (γj.Q) are triples (c, γj ⊆ γ, Hγ) with c an arrow in Prg,
γj ⊆ γ an arrow in Cont and P Hγ wlp(c, γj ⊆ γ)(Q) an arrow in assn(γ).
identities: the identity on object (γ.P ) is (idC, idγ, =).
composition: composition of two arrows (c1, γj ⊆ γ, Hγ) : (γ.P ) → (γj.Q) and (c2, γjj ⊆ γj, Hγ′ ) : (γj.Q) → (γjj.R) is the arrow (c1; c2, γjj ⊆ γ, Hγ) : (γ.P ) → (γjj.R). Composition is ensured by the monotonicity of the weakest liberal pre- condition w.r.t. semantic entailment, by the assumption that wlp is a pseudo functor, i.e., wlp(c1, γj ⊆ γ)(wlp(c2, γjj ⊆ γj)(R)) and wlp(c1; c2, γjj ⊆ γ)(R) are equivalent w.r.t. semantic entailment, and by the associativity of semantic entail-

ment.
C


γ,,


P	Hγ wlp(c1, γj ⊆ γ)(Q)	Hγ wlp(c1; c2, γjj ⊆ γ)(R)


c1	⊆
	γj
,,
c2	⊆
	jj
,,
wlp(c1,γ′⊆γ)
_
Q	Hγ′
,,
wlp(c1,γ′⊆γ)
_
wlp(c2, γjj ⊆ γj)(R)
wlp(c2,γ′′⊆γ′)
_

C	γ	R
Moreover, we obtain a projection functor Fpca : Pca → (Prg×Cont)op with Fpca(γ.P ) ,
(C, γ) and Fpca(c, γj ⊆ γ, Hγ) , (c, γj ⊆ γ).
Theorem 4.5 The functor Fpca : Pca → (Prg × Cont)op is a ﬁbration where (c, γj ⊆ γ, Hγ): (γ.P ) → (γj.Q) is a cartesian arrow if, and only if, P and wlp(c, γj ⊆ γ)(Q) are equivalent w.r.t. semantic entailment.
For the rest of the paper we have to keep in mind that we have by construction

Assn	⊆	 Pc¸a
|Assn| = |Pca|.	Moreover, the commu- tative triangle assn =⊆; wlp of functors

Fassn
Fpca
is transformed by the Grothendieck con-

(Str ×   )op 	⊆	 (P¸rg ×   )op
struction into a pullback in the category

Cont
Cont
of categories.

Hoare Triples and Hoare Proof Calculus
Hoare Triples (Partial Correctness Assertions): We can consider Assn as a subcategory of Pca since assn(γj ⊆ γ) = wlp(idC, γj ⊆ γ) for all inclusions γj ⊆ γ. Moreover, any arrow (c, γj ⊆ γ, Hγ) : (γ.P ) → (γj.R) in Pca can be decomposed into an arrow (γj ⊆ γ, Hγ) : (γ.P ) → (γj.Q) in Assn and an arrow (c, idγ′ , Hγ′ ): (γj.Q) → (γj.R) in Pca.


C,,
γ,,
P Hγ Q,,Hγ wlp(c, γj ⊆ γ)(R)

idC
C,,
c
C
⊆
γj
,,
idγ′
γj
assn(γ′⊆γ)
_
Q	Hγ′
assn(γ′⊆γ)
_
wlpγ′ (c)(R)
,,
wlpγ′ (c)
_
R

That is, we need only the ”new” arrows of type (c, idγ, Hγ) : (γ.P ) → (γ.Q) to extend Assn to the category Pca.
A comparison with the definition and the semantics of Hoare triples (partial correctness assertions) makes immediately evident that a Hoare triple {P} c {Q} is just another notation for arrows of type (c, idγ, Hγ): (γ.P ) → (γ.Q), i.e., for the relations P Hγ wlpγ(c)(Q). So, the task of a deduction calculus for a Hoare logic

has the sole purpose of deriving all the arrows of type (c, idγ, Hγ): (γ.P ) → (γ.Q) in Pca.
Hoare Proof Calculus: In view of the two syntactic fibrations a proof calculus for Hoare triples has, in such a way, two features:
One constructs for each pair of an object (γ.Q) in |Assn| = |Pca| and of a new arrow in Prg, i.e., a program c, a corresponding new cartesian arrow in Pca (|= {wlp(c, Q)} c {Q}):
(c, idγ, Hγ): wlpγ(c)(Q) → (γ.Q) These are the rules Assn, IfElse, and PWhile.
One closes everything under composition
by composing new arrows in Pca with new arrows in Pca (rule Comp) and
by pre- and post-composing new arrows in Pca with old arrows from Assn
(rules PreStr and PosWk).
After these crucial observations we are ready to formulate our syntactic fibred quest:
Syntactic Fibred categorical quest for weakest liberal precondition:
Extend the fibration Fassn : Assn → (Str × Cont)op to a fibration Fpca : Pca → (Prg × Cont)op such that the diagram on the left be-

Assn 	⊆	 Pc¸a
comes a pullback in the category of categories.

Fassn
Fpca
Note, that the pullback requirement means that

(Str ×   )op 	⊆	 (P¸rg ×   )op we are not allowed to introduce in Pca new en-

Cont
Cont
tailments between assertions, i.e., the logic of assertions about states is encapsulated in Assn.

Semantic Fibrations
In our syntactic fibred quest the semantics of assertions and programs are not incorporated. To have a full fibred picture and to be able, especially, to talk about soundness and completeness of deduction, we have to transfer also our semantic indexed categories and the indexed extension functors to the fibred setting.
By applying the Grothendieck construction we obtain out of the functor (st ⊗
env)—1 : Str × Cont → Po a category of the semantics of states:
Definition 4.6 [Category St] The category St of “state predicates” is defined as follows:
objects: all pairs (γ.E ) with a context γ ∈ |Cont| and a set E ∈ ℘(Σ⊥ × env(γ)).
arrows: from (γ.E ) to (γj.Ej) are pairs (γj ⊆ γ, ⊆) such that E ⊆ (idΣ	×
pγ,γ′ )—1(Ej).
identities: the identity on (γ.E ) is (idγ, =).
composition: two arrows (γj ⊆ γ, ⊆): (γ.E ) → (γj.Ej) and (γjj ⊆ γj, ⊆): (γj.Ej) →
(γjj.Ejj) compose to the arrow (γjj ⊆ γ, ⊆) : (γ.E ) → (γjj.Ejj).  Composition

is ensured by the monotonicity of preimage formation w.r.t. inclusions, by the functoriality of preimage formation and by the associativity of inclusions.


C,,
γ,,	E	⊆ (idΣ⊥
× pγ,γ′ )—1(Ej)	⊆  (idΣ
,,	⊥
× pγ,γ′′ )—1(Ejj)
,,

idC	⊆
	
(idΣ⊥
×pγ,γ′ )−1
_
(idΣ⊥
×pγ,γ′ )−1
_

C,,	γj
Ej	⊆
(idΣ⊥
× pγ′,γ′′ )—1(Ejj)
,,

idC

C
⊆

γjj
(idΣ⊥
×pγ′,γ′′ )−1
_
Ejj

Moreover, we obtain a projection functor Fst : St → (Str × Cont)op with Fst(γ.E ) ,
(C, γ) and Fst(γj ⊆ γ, ⊆) , (idC, γj ⊆ γ).
Theorem 4.7 The functor Fst : St → (Str × Cont)op is a (split) ﬁbration where
the cartesian arrows are exactly the arrows (γj ⊆ γ, =) : (γ.(idΣ  × pγ,γ′ )—1(Ej)) →
(γj.Ej) for all inclusions γj ⊆ γ and all sets Ej ∈ ℘(Σ⊥ × env(γj)). These are the only Cartesian arrows since inclusion ⊆ is anti-symmetric.
In the same way, the functor (sem ⊗ env)—1 : Prg × Cont → Po provides a category of predicate transformers:
Definition 4.8 [Category Sem] The category Sem of “predicate transformers” is defined as follows:
objects: all pairs (γ.E ) with a context γ ∈ |Cont| and a set E ∈ ℘(Σ⊥ × env(γ)).
arrows: from (γ.E ) to (γj.Ej) are triples (c, γj ⊆ γ, ⊆) such that E ⊆ ([[c]]∗ ×
pγ,γ′ )—1(Ej).
identities: the identity on (γ.E ) is (idC, idγ, =).
composition: two arrows (c1, γj ⊆ γ, ⊆) : (γ.E ) → (γj.Ej) and (c2, γjj ⊆ γj, ⊆) : (γj.Ej) → (γjj.Ejj) compose to the arrow (c2; c1, γjj ⊆ γ, ⊆) : (γ.E ) → (γjj.Ejj). Composition is ensured by the monotonicity of preimage formation w.r.t. inclu- sions, by the functoriality of program semantic and preimage formation, and by the associativity of inclusions.


C,,
γ,,
E	⊆ ([[c1]]∗ × pγ,γ′ )—1(Ej)	⊆ ([[c1; c2]]∗ × pγ,γ′′ )—1(Ejj)


c1
C,,
c2
C


⊆
γj
,,
⊆

γjj
,,
([[c1]]∗×pγ,γ′ )−1
_
Ej	⊆
,,
([[c1]]∗×pγ,γ′ )−1
_
([[c2]]∗ × pγ′,γ′′ )—1(Ejj)
,,
([[c2]]∗×pγ′,γ′′ )−1
_
Ejj

Moreover, we obtain a projection functor Fsem : Sem → (Prg × Cont)op with
Fsem(γ.E ) , (C, γ) and Fsem(c, γj ⊆ γ, ⊆) , (c, γj ⊆ γ).

Theorem 4.9 The functor Fsem : Sem → (Prg × Cont)op is a (split) ﬁbration where the cartesian arrows are exactly the arrows (c, γj ⊆ γ, =) : (γ.([[c]]∗ ×pγ,γ′ )—1(Ej)) → (γj.Ej) for all programs c, all inclusions γj ⊆ γ and all sets Ej ∈ ℘(Σ⊥ × env(γj)).

St 	⊆	 Se¸m

Fst	Fsem
(Str ×   op 	⊆	 (P¸rg ×  op

For the rest of the paper we have to keep in mind that we have by construction
|St| = |Sem|. Moreover, the diagram to the left is a pullback in the category of categories. Note, that the pullback property says, analogously to the syntactic case, that Sem does not change the semantics of states.

Extensions and Soundness
The Grothendieck construction extends also to indexed functors (natural transfor- mations) and transforms an indexed functor into a morphisms between the corre- sponding two fibrations, i.e., into a functor making the resulting triangle of functors commutative.
In the indexed setting, the assignments P '→ extγ(P ) provide functors extγ : (assn(γ), Hγ) → (℘(Σ⊥ × env(γ)), ⊆), and the family of these functors constitute as well an indexed functor ext : assn ⇒ (st ⊗ env)—1 as an indexed functor ext : wlp ⇒ (sem ⊗ env)—1.
Correspondingly, the assignments (γ.P ) '→ (γ.extγ(P )) provide, in the fibred setting, as well a functor extassn : Assn → St as a functor extpca : Pca → St. The functor extassn maps the arrow (γj ⊆ γ, Hγ) : (γ.P ) → (γj.Q) in Assn into the arrow (γj ⊆ γ, ⊆): (γ.extγ(P )) → (γj.extγ′ (Q)) in St. Note, that the definition of semantic entailment in (2) means nothing but that the functor extassn is full. It is easy to check that we have Fassn = extassn; Fst.
To extend the assignments (γ.P ) '→ (γ.extγ(P )) to a functor extpca : Pca → St we have to assign to the arrow (c, γj ⊆ γ, Hγ) : (γ.P ) → (γj.Q) in Pca the arrow (c, γj ⊆ γ, ⊆): (γ.extγ(P )) → (γj.extγ′ (Q)) in Sem. For the special case γj = γ this means that

P Hγ wlpγ(c)(Q)	implies	extγ(P ) ⊆ ([[c]]∗ × idenv(γ))—1(extγ(Q)).
That is, the requirement that extassn : Assn → St extends to a functor extpca : Pca → Sem is the fibred formulation of the requirement that the syntactic weakest liberal precondition is sound.
This last observation gives us the last brick to formulate our final quest:
Full fibred categorical quest for weakest liberal precondition:
















Fas



(Str
Extend the fibration Fassn : Assn → (Str × Cont)op to a fibration Fpca : Pca →
(Prg × Cont)op in a way
that the resulting commutative square ⊆; Fpca = Fassn; ⊆ of functors is a pullback, and
that the functor extassn : Assn → St extends to a functor extpca : Pca → Sem
with extassn; ⊆=⊆; extpca and Fpca = extpca; Fsem.
We want to close our categorical analysis by the remark that completeness of weakest liberal precondition can be reflected in the fibred setting by the additional requirement that extpca becomes a full functor.
Conclusion
The traditional presentation of the structural features of Hoare logic is essentially an indexed one. We lifted this insight into a more general and abstract level by developing a categorical presentation of the structural features of Hoare logic based on indexed categories. We outlined that the categorical presentation paves naturally a way for an extension of Hoare Logic from the traditional one program (component) setting into a multi-program (compound system) environment.
By translating the indexed categorical presentation into a fibred presentation, we have been able to formalize precisely the intuition that Hoare triples are a kind of fibred entity, i.e., Hoare triples arise naturally as special arrows in a fibred category over a syntactic category of programs. Moreover, deduction in Hoare calculi can be characterized categorically by the heuristic

The paper concludes that an appropriate way to deal with axiomatic semantics, at least in the format of Hoare logic, is to use both categorical tools, fibred cate- gories, and indexed categories, in a way that the structural features of the language are presented in indexed categories and the features of deduction in the fibred one. As a further work, we would like to extend our categorical model to deal with finite contexts of program variables. This is a departure from the usual textbook presen- tation, but it is in accordance with the current state of the art proof technology for

programming languages and verification systems based or inspired by Hoare logic [9,2,5].

References
Barr, M. and C. Wells, “Category Theory for Computing Science,” Series in Computer Science, Prentice Hall International, London, 1990.
Bubel, R. and R. H¨ahnle, Key-hoare, in: Deductive Software Verification - The KeY Book - From Theory to Practice, 2016 pp. 571–589.
Dijkstra, E. W. and C. S. Scholten, “Predicate calculus and program semantics,” Texts and monographs in computer science, Springer, 1990, I-X, 1-220 pp.
Fiadeiro, J., “Categories for Software Engineering,” Springer, Berlin, 2005.
Filliˆatre, J.-C., One Logic To Use Them All, in: CADE 24 - the 24th International Conference on Automated Deduction (2013).
Goguen, J. A. and R. M. Burstall, Institutions: Abstract Model Theory for Specification and Programming, Journal of the ACM 39 (1992), pp. 95–146.
Hoare, C. A. R., An axiomatic basis for computer programming, Commun. ACM 12 (1969), pp. 576– 580.
Knijnenburg, P. and F. Nordemann, Partial hyperdoctrines: categorical models for partial function logic and hoare logic, Mathematical Structures in Computer Science, Cambridge University Press Volume 4, Issue 02 (1994), pp. 117–146.
Leino, R., Dafny: An automatic program verifier for functional correctness, in: 16th International Conference, LPAR-16, Dakar, Senegal (2010), pp. 348–370.
Martini, A., U. Wolter and E. H. Haeusler, Fibred and Indexed Categories for Abstract Model Theory, Journal of the IGPL 15 (2007), pp. 707–739.
Pawlowski, W., Context institutions, in: M. Haveraaen, O. Owe and O.-J. Dahl, editors,
COMPASS/ADT, Lecture Notes in Computer Science 1130 (1995), pp. 436–457.
Pitts, A. M., Categorical Logic, in: S. Abramsky, D. M. Gabbay and T. S. E. Maibaum, editors, Handbook of Logic in Computer Science, Volume 5. Algebraic and Logical Structures, Oxford University Press, 2000 pp. 39–128.
Street, R., Fibrations in bicategories, Cahiers Topologie G´eom. Diff´erentielle 21, no. 2 (1980), pp. 111–
160.
