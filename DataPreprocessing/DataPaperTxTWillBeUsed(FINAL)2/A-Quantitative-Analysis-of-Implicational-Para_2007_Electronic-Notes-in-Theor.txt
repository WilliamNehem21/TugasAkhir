Electronic Notes in Theoretical Computer Science 169 (2007) 87–97	
www.elsevier.com/locate/entcs

A Quantitative Analysis of Implicational Paradoxes in Classical Mathematical Logic
Yuichi Goto1
Department of Information and Computer Sciences Saitama University
Saitama, 338-8570, Japan
Jingde Cheng2
Department of Information and Computer Sciences Saitama University
Saitama, 338-8570, Japan

Abstract
Classical mathematical logic includes a lot of “implicational paradoxes” as its logic theorems. This paper uses the property of strong relevance as the criterion to identify implicational paradoxes in logical theorems of classical mathematical logic, and enumerates logical theorem schemata of classical mathematical logic that do not satisfy the strong relevance. This quantitative analysis shows that classical mathematical logic is by far not a suitable logical basis for automated forward deduction.
Keywords: Knowledge representation and reasoning, Automated forward deduction, Relevant logics, Strong relevance


Introduction
A forward deduction engine is an indispensable component for any knowledge-based system to discover new knowledge or predict future incidents. Since any automated forward deduction for discovery or prediction has no explicitly specified proposition or theorem given previously as goal, intrinsically, to apply all inference rules to all given premises and previously deduced conclusions is the only way to deduce new knowledge or predictions. This naturally requires that a forward deduction engine deduces only conclusions that are certainly relevant to given premises.

1 Email: gotoh@aise.ics.saitama-u.ac.jp
2 Email: cheng@aise.ics.saitama-u.ac.jp

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.07.031

Within the framework of classical mathematical logic, CML for short, the con- clusion of a valid deduction is not necessarily relevant to its premises, because CML is established based on the classical account of validity. It is well known that logical theorems of CML include a lot of “implicational paradoxes” [1,2]. On the other hand, relevant logics and strong relevant logics rejected those implicational para- doxes as their logical theorems and are adopted as the logical basis for automated forward deduction [1,2,3,4,5]. However, until now no one investigated quantitatively how CML is “bad” and/or how relevant logics are “good” for automated forward deduction. This paper presents the result of our quantitative analysis of implica- tional paradoxes in CML and explains its implications. We use the property of the strong relevance as the criterion to identify implicational paradoxes in logical theorems of CML, and enumerate logical theorem schemata of CML that do not satisfy the strong relevance. This quantitative analysis shows that CML is by far not a suitable logical basis for automated forward deduction.
The rest of this paper is organized as follows: Section 2 gives a very simple introduction to implicational paradoxes in CML and the mention of the strong relevance. Section 3 gives how to analyze and analysis. Some concluding remarks are given in Section 4.

Implicational paradoxes
Implicational paradoxes in Classical Mathematical Logic
In logic, a sentence in the form of “if ... then .. .” is usually called a conditional proposition or simply conditional. A conditional must concern two parts which are connected by the connective “if ... then .. .” and called the antecedent and the consequent of that conditional. The truth of a conditional depends not only on the truth of its antecedent and consequent but also, and more essentially, on a neces- sarily relevant and/or conditional relation between its antecedent and consequent. In CML, the notion of conditional, which is intrinsically intensional but not truth-functional, is represented by the truth-functional extensional notion of ma-
terial implication (denoted by → in this paper) that is defined as A → B =df
¬(A ∧ ¬B) or A → B =df ¬A ∨ B, where ∧, ∨, and ¬ denote the connectives of con- junction, disjunction, and negation, respectively. However, the material implication
is intrinsically different from the notion of conditional in meaning (semantics). It is no more than an extensional truth-function of its antecedent and consequent but
its antecedent and consequent, i.e. the truth-value of the formula A → B depends does not require that there is a necessarily relevant and conditional relation between only on the truth-values of A and B, though there could exist no necessarily relevant
and conditional relation between A and B. It is this intrinsic difference in meaning between the notion of material implication and the notion of conditional that leads to the well-known “implicational paradox problem” in CML. The problem is that if one regards the material implication as the notion of conditional and regards ev-
number of logical axioms and logical theorems of CML, such as A → (B → B), ery logical theorem of CML as an entailment or valid reasoning form, then a great

B → (¬A ∨ A), and so on, present some paradoxical properties and therefore they have been referred to in the literature as “implicational paradoxes” [1,2].
Note that any classical conservative extension or non-classical alternative of CML where the classical account of validity is adopted as the logical validity cri- terion and the notion of conditional is directly or indirectly represented by the material implication has the similar problems as the above problems in CML [3].
In the framework of CML and its various conservative extensions, even if a deduction is valid in the sense of CML, neither the necessary relevance between its premises and conclusion nor the truth of its conclusion in the sense of conditional can be guaranteed necessarily. Therefore, any forward deduction engine cannot deduce only conclusions that are certainly relevant to given premises based on CML or its various conservative extensions.

Strong Relevance
Relevant logics, RL for short, were constructed to obtain a notion of implica- tion which is free from the implicational paradoxes [1,2]. However, although RL have rejected those paradoxes of implication, there still exist some “conjunction- implicational paradoxes” and “disjunction-implicational paradoxes” in logical theo- rems of RL [3,4,5]. Cheng has proposed some strong relevant logics, SRL for short, which do not include the paradoxes [4,5]. In the framework of SRL, if a reason- ing is valid in the sense of SRL, then both the relevance between its premises and conclusions and the validity of its conclusions in the sense of conditional can be guaranteed in a certain sense of strong relevance.
Strong relevance is one of property in RL and SRL: every propositional variable (or pattern variable) in a formula (or formula schema) occurs at least once as an antecedent part and at least once as a consequent part [1]. The definition of an antecedent part and a consequent part is as follows, let A, B and C be well-formed formulas or their schemata,
A is a consequent part of A,
if ¬B is a consequent part (antecedent part) of A, then B is an antecedent part (consequent part) of A,
if B → C is a consequent part (antecedent part) of A, then B is an antecedent part (consequent part) of A, and C is consequent (antecedent part) of A,
if B ∧ C or B ∨ C is a consequent part (antecedent part) of A, then both B
and C are consequent parts (antecedent parts) of A.
The strong relevance is a property which formally guarantees the relationship between antecedent and consequent so that any theorem of SRL satisfies the strong relevance [4,5] and any theorem in the implication-negation fragments of RL also satisfies it [1]. On the other hand, implicational paradoxes in logical theorems of CML and conjunction-implicational paradoxes and disjunction-implicational para- doxes in logical theorems of RL do not satisfy the strong relevance. We therefore can distinguish implicational paradoxes from logical theorems of CML by checking

whether a formula (schema) satisfies the strong relevance or not.

A Quantitative Analysis
Preparation
In this paper, we focus our discussion on the axiomatic system of CML with only the connectives of implication and negation on propositional calculus because it is possible to represent all logical theorems of CML with the connectives of implication and negation. We define well-formed formulas we investigate in this paper as follows.

Definition 3.1	(i) A propositional variable p is a well-formed formula, wff for short,
¬A is a wff, if A is a wff,
A → B is a wff, if both A and B are wffs,
Only i ∼ iii are wffs.
Definition 3.2 A sub-wff is a part of a wff and is itself a wff. Each wff is regarded
as a sub-wff of itself.
such as ¬(¬A) whose A is a wff, as their sub-wff in our analysis. Note that we are not concerned with the wffs which include double negation,
By other hand, the number of propositional variables is infinite so that the set of
logical theorems of CML is the infinite set. Hence we deal with the set of schemata of logical theorem.
Definition 3.3 A schema of a wff is a formula that replaced all propositional vari- able in the wff with pattern variables.
Pattern variables are variables for which it can substitute certain propositional variables. They are symbols with order relation and are not included the vocabulary of CML.
Definition 3.4 A logical theorem schema of CML is a schema of a logical theorem of CML.
tive of implication (→) of A.  deg→(A)= k is defined as follows. Definition 3.5 Let deg→(A)= k denote that k is the degree of nested the connec-
if there is no occurrence of → in A, then deg→(A)= 0,
deg→(¬A)= deg→(A),
deg→(A → B)= 1 + max (deg→(A), deg→(B)).
Definition 3.6 A is a kth degree logical theorem schema of CML iff A is a logical
theorem schema of CML and deg→(A)= k.
(1   ≤   j    ≤   k),   and   denoted   by   Fk. Definition 3.7 kth degree schemata fragment is the set of all jth degree schemata

theorem schemata of CML (1 ≤ j ≤ k), and denoted by T hk. Definition 3.8 The kth degree fragment of CML is the set of all jth degree logical
T hk can be classified into two sets: the set of all implicational paradoxes in T hk, denoted by IPk, and the set of all paradox-free theorems, denoted by T hSk. The relationship amount T hk, IPk, and T hSk is as follows;
(1)	T hk = IPk ∪ T hSk.
We distinguish between implicational paradoxes and others by checking whether
a logical theorem schema satisfies the strong relevance or not. We can therefore enumerate the paradoxes by 3 steps;
get all schemata in Fk,
classify Fk into two sets: T hk and others, by checking whether each schema in
Fk is logical theorem or not.
classify T hk into T hSk and IPk by using strong relevance as the criterion.
Analysis
At first, we produced all schemata in F3. Any schema can be represented by rooted tree structure; the connective of implication is an internal node which can have one parent and must have two children; the connective of negation is other internal node
on leaves. For example (¬(α → β) → γ) is can be represented by a rooted tree like which can have one parent and must have one child; pattern variables are labels put figure 1, whose → and ¬ are the connectives of implication and negation respectively
and α, β, γ are pattern variables. All schemata can be grouped by trunks of rooted
trees. We define a trunk is a part of a tree which consists of only internal nodes without leaves, e.g., in figure 2. We can produce all schemata in Fk from all kinds of trunks which occur in F (k) and all kinds of permutations of pattern variables whose length are from 1 to 2k.
A
( (  			
	

Fig. 1. An example of a rooted tree

Algorithm 1 Produce all kinds of trunks which occur in F (k).

τ0 =df {‘¬’, ‘ ’ (blank)}, whose both ‘¬’ and ‘ ’ (blank) are representations of trunks when no → occurs,
i ← 1
loop from iv to xviii,

A
trunk

leaf



antecedent sub-tree	consequent sub-tree

Fig. 2. Structure of rooted tree
τi ← φ,
loop from vi to xvii,
pick up a trunk ζ from τi−1,
loop from viii to xi,
pick up a trunk η from τj (0 ≤ j ≤ i − 2),
create four new trunks: (ζ → η), (η → ζ), ¬(ζ → η), ¬(η → ζ),
add those trunks into τi,
repeat from viii until picking up all elements of τj as η,
loop from xiii to xvi,
pick up a trunk θ from τi−1,
create two new trunks: (ζ → θ), ¬(ζ → θ),
add those trunks into τk,
repeat from xiii until picking up all elements of τi−1 as θ,
repeat from vi until picking up all elements of τi−1 as ζ,
i ← i +1 then repeat from iv until k = i.
Algorithm 2 Create all kinds of permutation of pattern variables whose length is
from 1 to k.
ρ1 =df {‘a0, ’} whose an (1 ≤ n ≤ 2k) is a pattern variable,
i ← 2
loop from iv to xiii,
ρi ← φ,
loop from vi to xii,
pick up a permutation λ from ρi−1,
loop from viii to xi,
j ← 1
create a new permutation by connecting λ with aj, such as ‘λ, aj’,

add the permutation into ρi,
	j ← j +1 then repeat from viii until j = m, whose m is the maximum number of the subscript of the pattern variable which occurs in λ,
repeat from vi until picking up all elements of ρi−1 as λ,
i ← i +1 then repeat from iv until k = i.
We then distinguished logical theorem schemata and others in the set of pro-
duced schemata by checking whether a schema is universally true or not. After that, we judged whether these logical theorem schemata satisfy strong relevance or
not. Table 1 shows the number of elements of Fk, IPk and T hSk (1 ≤ k ≤ 3).
Table 1
The number of elements of Fk, IPk, and T hSk


Table 2
The number of elements of Fk
degree	Fk
4	2.92 × 1019
5	1.63 × 1045
6	4.29 × 10103
7	1.02 × 10235
8	8.15 × 10527
In our enumeration method, we cannot deal with Fi when i is more than 3,
(4 ≤ k ≤ 8). Fk becomes large exponentially against k becomes large linearly. because F4 is too large amount. Table 2 shows the number of elements of Fk Note it is possible to calculate the number of elements of Fk but difficult to get all
elements of the set.
The number of elements of Fk can be calculated as follows. T i denotes the kinds of trunks of rooted trees in Fk while the number of leaves of the all trees are i and the degree of nested implications is k. Let Pi be the kinds of permutations of pattern variables put on leaves of a certain rooted tree as labels while the number of the leaves is i. Then the number of elements of Fk is can be calculated from T i
and Pi.
T i is defined as follows,
T 1 = 2,

T 2 = 8,
T i = 0, (0 ≤ k, i < k + 1, 2k < i),
2(k−1) k−2	2(k−1)

(2)
T i =4 Σ
j=k
j k−1
e=0
T i−j +2 Σ
j=k
j k−1
T i−j , (2 < k).

i=1	2	3	4
















Fig. 3. The kinds of permutations of pattern variables
Figure 3 is the relationship between the number of leaves and the kinds of permutations of pattern variables. In the figure, pattern variables are represented by Greek alphabet. Let Pi be the kinds of permutations of pattern variables when the number of leaves is i. P1 is 1 kind. P2, P3, and P4 are 2 kinds, 5 kinds, and 15 kinds, respectively. We can see that same combinations that enclose them with the square in the figure appear many times. Hence Pi is defined as follows,
P1 = 1,
i−1
Pi = Σ(j + 1) · Sj , (2 ≤ i).

j=1
The coefficient Sn
in equation (3) is the stirling numbers of the second kind. The

stirling numbers of second kind is defined as follows,
S1 = Sm = 1, (1 ≤ m),
m	m
Sn	= Sn−1 + n · Sn , (1 < m < n).
m+1	m	m
From equation (2) and equation (3), the number of elements of Fk is defined as follows,
2j
T i · Pi.
j=1 i=j+1
Table 1 shows that the IP3 is 16.13 times as large as T hS3. We think that this rate becomes larger as the degree of nested implications becomes larger. All logical theorem schemata in T hk can be grouped by trunks of rooted trees. The number of elements in a set of logical theorem schemata which are grouped by a certain trunk

of a rooted tree is as same as the kinds of permutations of pattern variables which can put on leaves of the tree as labels. The difference between amount of IPk and that of T hSk causes the kinds of permutations of pattern variables which can put on leaves of a rooted tree as labels.
Under a certain trunk of a rooted tree, the kinds of permutations of pattern variables which appear in elements of IPk is by far more than that of T hSk when k is large. In representation of rooted tree, we call antecedent (consequent) of a logical theorem schema antecedent (consequent) sub-tree of it. Note we call same
rule if root of a tree is negation in this paper, e.g., in figure 2. A → B is a logical
theorem schemata of CML iff the truth-value of A and B are follows,
case 1 the truth-value of A is universally false and the truth-value of B is univer- sally true,
case 2 the truth-value of A is universally false and truth-value of B is not univer- sally true,
case 3 the truth-value of A is not universally false and the truth-value of B is universally true,
case 4 the truth-value of A is not true if the truth-value of B is false, and both of them are contingent.
Similarly if ¬(A → B) is logical theorem schemata of CML then as follows,
case 5 the truth-value of A is universally true, and the truth-value of B is univer-
sally false,
If A is an element of IPk then it can put any kind of permutations of pattern variables on leaves of its consequent sub-tree when the truth-value of its antecedent sub-tree is universally false. Similarly, if A is an element of IPk then it can put any kind of the permutations of pattern variables on leaves of its antecedent sub-tree when the truth-value of its consequent sub-tree is universally true. However, if A is an element of T hSk iff only kinds of permutations of pattern variables satisfying the strong relevance.
Let us discuss about the case that the truth-value of its consequent sub-tree is universally true. On the case, it is large that the difference between the kinds of permutations of pattern variables which appear in elements of IPk and that of T hSk under a certain trunk of a rooted tree. While the number of antecedent parts is a, and the number of consequent parts is c of antecedent sub-tree, the kinds of permutation of pattern variables which appear in an element of T hSk is calculated as follows,


min(a,c)

j=1
R(j, a) · R(j, c) · j!.

R(m, n) is a function that calculates the kinds of permutation of pattern variables,
whose n is the number of leaves and m is the kinds of pattern variables. R(m, n) is defined as follows,
R(m, n)= 1, (n = m),

= Σ j, (n = m + 1),
j=1 m


j n−m−1
, (m +1 < n).

j=1
Let m be the kinds of pattern variables. δf

is defined as follows,

m
f
1



k=f
δf = Σ k · δk
, (1 < e, 1 ≤ f ≤ m).

e
k=f
e−1

Under a trunk of a rooted tree, equation (3) gives the kinds of the permutations which appear in the antecedent sub-tree of elements of IPk. In contrast, the kinds of permutations which appear in the antecedent sub-tree of elements of T hSk is given by from equation (3) as maximum value to equation (6) as minimum value. Note equation (6) is minimum when a + c = n, a = c in this assumption, whose a is the number of antecedent part, and n is the number of leaves. Table 3 shows the difference between the value of equation (3) and that of equation (6) if a + c = n, a = c. The value of equation (3) becomes larger than that of equation (6) as the number of leaves becomes large. The larger the number of leaves becomes, the larger the degree of nested implication becomes.
The same thing may be said of the other cases. We therefore consider that the difference between amount of IPk and that of T hSk becomes larger as the degree of nested implications becomes larger.
Table 3
The kinds of permutation of pattern variables



Concluding remarks
We enumerated implicational paradoxes in logical theorem of classical mathemati- cal logic, CML for short. On the axiomatic system of CML with the connective of implication and negation, our analysis results showed that the number of implica-
tional paradoxes in the set of 1st ∼ 3rd degree logical theorem schemata of CML is
16.13 times as many as the number of paradox-free logical theorems in the set. The

difference between amount of implicational paradoxes and that of paradox-free log- ical theorems of CML becomes larger as the degree of nested implications becomes larger.
With only connectives of entailment and negation, any logical theorem of rele- vant logics, RL for short, and strong relevant logics, SRL for short, is an element of paradox-free logical theorems of CML, if we regard material implication in CML and entailment in RL and SRL as a same connective to represent the notion of conditional. Hence, it is quite likely that a forward deduction engine based on CML deals with conclusions at least 16 times as many as conclusions which a forward deduction engine based on RL or SRL deal with. Therefore, as the logic systems underlying forward deduction, RL and SRL are quantitatively more suitable by far than CML. The same thing may be said of its various conservative extensions of CML which include all logical theorems of CML as their logical theorems.
In this paper, we investigated the implicational paradoxes in the axiomatic sys- tem of CML with only implication and negation. This is only a quantitative com- parative study between CML and the intersection between SRL and RL. As future work, we should investigate whether SRL is quantitative suitable logic systems to underlie automated forward deduction than RL or not by quantitative comparative study between RL and SRL.

References
Anderson, A. R. and N. D. B. Jr., “Entailment: The Logic of Relevance and Necessity, vol. 1,” Princeton University Press, 1975.
Anderson, A. R., N. D. B. Jr. and J. M. Dunn, “Entailment: The Logic of Relevance and Necessity, vol. 2,” Princeton University Press, 1992.
Cheng, J., The fundamental role of entailment in knowledge representation and reasoning, Journal of Computing and Information 2 (1996), pp. 853–873.
Cheng, J., A strong relevant logic model of epistemic processes in scientific discovery, in: E. Kawaguchi,
H. Kangassalo, H. Jaakkola and I. A. Hamid, editors, Information Modelling and Knowledge Bases XI, IOS Press, Amsterdam, 2000 pp. 136–159.
Cheng, J., Strong relevant logic as the universal basis of various applied logics for knowledge representation and reasoning, in: Y. Kiyoki, H. Jaakkola and H. Kangassalo, editors, Information Modelling and Knowledge Bases XVII, IOS Press, Amsterdam, 2006 pp. 310–320.
