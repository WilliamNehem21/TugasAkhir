Electronic Notes in Theoretical Computer Science 206 (2008) 23–40	
www.elsevier.com/locate/entcs

A New Proposal Of Quasi-Solved Form For Equality Constraint Solving 1
Javier A´lvez2	Paqui Lucio3
Lenguages y Sistemas Informa´ticos Basque Country University
San Sebastian, Spain

Abstract
Most well-known algorithms for equational solving are based on quantifier elimination. This technique iteratively eliminates the innermost block of existential/universal quantifiers from prenex formulas whose matrices are in some normal form (mostly DNF). Traditionally used notions of normal form satisfy that every constraint (in normal form) different from false is trivially satisfiable. Hence, they are called solved forms. However, the manipulation of such constraints require hard transformations, especially due to the use of the distributive and the explosion rules, which increase the number of constraints at intermediate stages of the solving process. On the contrary, quasi-solved forms allow for simpler transformations by means of a more compact representation of solutions, but their satisfiability test is not so trivial. Nevertheless, the total cost of checking satisfiability and manipulating constrains using quasi-solved forms is cheaper than
using simpler solved forms. Therefore, they are suitable for improving the efficiency of constraint solving procedures. In this paper, we present a notion of quasi-solved form that provides a good trade-off between the cost of checking satisfiability and the effort required to manipulate constraints. In particular, our new quasi-solved form has been carefully designed for efficiently handling conjunction and negation, which are the main Boolean operations necessary to keep matrices of formulas in normal form.
Keywords: free equality theory, term algebra, constraint solving, satisfiability, solved form


Introduction
The theory of first order language L where equality (denoted by ≈) is the unique predicate symbol was introduced by Malcev in [12] and it is known as the Free Equality Theory (abbreviated by FETL). Here, we focus on the case for the algebra of finite trees (or Herbrand domain) and finite number of function symbols. The Free Equality Theory is axiomatized by the usual equality axioms, the set of axioms E∗ (see [3]) and the Domain Closure Axiom (DCA), which was first defined in [14] for finite Herbrand domains and extended in [9] for infinite ones. FETL was shown

1 This work has been partially supported by Spanish Project TIN2004-079250-C03-03.
2 Email: javier.alvez@ehu.es
3 Email: paqui.lucio@ehu.es

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.073

to be decidable in [10] (see also [6]) and, besides, it is also a well-known result that FETL is non-elementary (see [7,16]). The inherent complexity of the satisfiability problem of equality constraints (i.e. where the quantifier prefix is of the form 6∗ E∗) for finite signatures is studied in [13].
The problem of solving equality constraints without negation is known as uniﬁ- cation and has been widely studied. However, unification problems lack of expres- siveness since the equality constraint 6v (x /≈ f (v, v)) cannot be transformed into a finite negation-free first order formula ([8]). Otherwise, if negation is allowed, then the problem is known as disuniﬁcation or (general) equality constraint solving.
Most well-known algorithms for equality constraint solving (see [6,11,12]) and later extensions to richer theories (see [15]) are based on quantifier elimination. This method keeps formulas in some prenex normal form and iterates a procedure that, at each step, eliminates the innermost block of existential/universal quanti- fiers of the prefix. Most of the decision methods for FETL represents formulas in disjunctive or conjunctive normal form, eliminating the innermost block of existen- tial and universal quantifiers respectively. Regarding the first ones, the innermost block of existential quantifiers can be eliminated by simply removing all the equa- tions/disequations involving their variables. However, when the innermost block is universal, double negation is applied in order to turn the block into existential. Hence, these decision methods require the transformation of formulas into disjunc- tive normal form before and after the elimination of universal quantifiers.
The above easy elimination of the innermost block of existential quantifiers is only correct if each conjunction of equations and disequations is individually satisfi- able. Traditional normal forms in equality constraint solving are trivially satisfiable (if different from the constant false) and are thus called solved forms, but require much effort on transformations. In particular, they require many applications of distribution, which drastically increases the size of formulas. On the contrary, other normal forms facilitate transformations but are not trivially satisfiable, requiring the resolution of hard satisfiability problems. Therefore, a good balance between easy transformations and easy satisfiability checks is highly desirable.
For unification problems, the most commonly used solved form is a finite con- junction of equations defining an idempotent substitution: simple formulas (see [5,10]). In order to deal with negation, disunification requires more sophisticated (quasi-)solved forms. We classify them into existential and universal forms, depend- ing on whether they allow universal quantification or not. Among the existential forms, we find two similar notions: basic formulas (see [4,5]) and deﬁnitions with constraints (see [6]). The satisfiability test on these existential forms is trivial, since any constraint syntactically different from false is always satisfiable. How- ever, satisfiability checking on universal forms usually requires the resolution of hard satisfiability problems. The universal form notions of substitutions with excep- tions and constrained substitutions are defined in [2], where the authors introduce a method for solving a system of equations and disequations with the proviso that a satisfiability test on substitutions with exceptions is given. In [2], they also show that, for testing satisfiability, it is not enough to check that a substitution is an

instance of another. Instead, it is necessary to check whether each instance of the former is an instance of the latter substitution that, in general, requires an infinite number of checks. However, any substitution with exceptions can be easily trans- formed into a disjunction of quasi-solved forms, as the proposed in this paper, for checking its satisfiability. Other universal forms were already used in [8,10]: implicit representations and Boolean combinations of simple formulas, respectively.
In this paper, we present a notion of normal form that combines two features: it enables very easy transformations, while testing satisfiability is not hard. Hence, we say that our normal form is a quasi-solved form. This notion of quasi-solved form is an improvement of the one introduced in [1]. In particular, it minimizes the application of distribution by means of a more compact representation of so- lutions. The basic transformations for this new quasi-solved form —conjunction and negation— are very similar to the transformations in [1]. Hence, in this work, we pay special attention to the satisfiability test, which is strongly based on the procedure presented in [8] for transforming implicit representations of sets of terms into explicit.
Outline of the paper. In the next section, we give some notations and preliminary results. Section 3 introduces the notion of quasi-solved form, called QSNF, and its basic operations. In Section 4, we describe an efficient satisfiability test on QSNFs. Finally, in Section 5, we give some conclusions and discuss future work.

Preliminaries
In this section, we recall some basic notions and introduce some notations. For concepts that we do not state here, the reader is referred to [6].
Along the paper, the equality predicate is written using the symbol ≈ in order to avoid confusion with the meta-language equality, which is denoted by =.
Tuples of objects are denoted using a bar. For example, x denotes a tuple of variables. Concatenation of tuples is denoted by ·, that is the expression x·y denotes the tuple that is obtained from concatenating the elements of x and y. Besides, some classical operations of sets are used for tuples with the obvious meaning (∩, ∪, .. .). In order to treat tuples of terms and single terms in a uniform way, we use a fresh function symbol c as tuple constructor. By abuse of notation, c can construct tuples of any arity m > 0. By convenience, we will treat the tuple constructor c as just another function symbol, but considering that c /∈ FL.
An equality constraint (or, simply, a constraint) is an arbitrary first-order formula consisting of function symbols from a first order language L, equality as the unique predicate symbols and variables from a denumerable set X . As usual, first order formulas are built using the constants true and false, the connectives ¬, ∧, ∨, →, ↔ and the quantifiers E, 6. The expressions Var(O) and Free(O) respectively denote the variables and the free variables (excluding the quantified ones) occurring in the syntactic object O. Besides, c∃\w and c∀\w are abbreviations for Ev (c) and 6v (c) respectively, where v = Var(c) \ w.
A term t is said to be ground if no variable occurs in t. Besides, t is said to be

linear if there is no variable repetition. The expression HL stands for the algebra of all ground terms or Herbrand universe that can be construct using the language L, whereas TL(X ) denotes the set of all possible terms.
If s and r are terms, then s ≈ r is an equation and s /≈ r is a disequation. Equations and disequations are said to be collapsing if at least one of the its terms is a variable. The expressions EQCE and UQCD are abbreviations for existentially quantified collapsing equation and universally quantified collapsing disequation re- spectively.
A substitution is a mapping from a finite set of variables x ⊂ X , called do- main, into TL(X ), called range. It is assumed that any substitution behaves as the identity for the variables outside its domain. Given any substitution σ, domain(σ) and range(σ) respectively denote the domain and range of σ. The composition of substitutions is denoted by juxtaposition, i.e. αβ denotes the composition of α and β. The restriction of a substitution σ to a set of variables x, denoted by σ†w, is defined as { (x ← t) | (x ← t) and x ∈ x }. Besides, a substitution σ is said to be linear if range(σ) has no repeated variables and σ is said to be an assignment if Var(range(σ)) = ∅.
The most general unifier of a set {O1,... , On}, denoted by mgu(O1,... , On) is an idempotent substitution σ such that Oiσ = Ojσ for every 1 ≤ i, j ≤ n and, for any other substitution θ with the same property, θ = σα for some substitution α. If mgu(O1,... , On) does (not) exist, then the objects O1,... , On are said to be (non-)uniﬁable. Besides, the most general common instance of a unifiable set of objects {O1,... , On}, denoted by mgi(O1,... , On), is Oiσ for any 1 ≤ i ≤ n, where σ = mgu(O1,... , On).
An assignment σ is said to be a solution of the constraint c if domain(σ) ⊆ Free(c) and FETL |= cσ. A constraint c is said to be satisﬁable if it has at least one solution, and the constraint c is said to be non-satisﬁable otherwise. Besides, two constraints c1 and c2 are said to be equivalent if, for every assignment σ, σ is a solution of c1 iff σ is a solution of c2.
The characteristic term of an equation w ≈ r or a disequation w /≈ r w.r.t. a set of variables w such that w ∈ w is the term c(w)σ where
σ = (θ ∪ {w ← rθ})
w' = w \ {w} and θ = {w' ← z} for some fresh z. For example, the characteristic term of w1 ≈ f (w2,f (v, v)) is
c(w){w1 ← f (z, f (v, v)), w2 ← z}

where w = w1 · w2. Note that the equations ( w1 ≈ f (w2,f (v, v)) )∃\w and ( c(w) ≈ c(w){w1 ← f (z, f (v, v)), w2 ← z} )∃\w (resp. the disequations ( w1 /≈ f (w2,f (v, v)) )∀\w and ( c(w) /≈ c(w){w1 ← f (z, f (v, v)), w2 ← z} )∀\w) are equiva- lent. Besides, ChT(ϕ, w) denotes the set of characteristic terms {c(w)σ1, ... , c(w)σn}
w.r.t. w that is obtained from the disjunction (resp. conjunction) of n EQCEs (resp.
UQCDs) ϕ.

A New Notion of Quasi-Solved Form
In this section, we introduce a new notion of quasi-solved form, abbreviated by QSNF, and its basic operations: that is, the transformation from a conjunction of QSNFs or a negated QSNF into an equivalent disjunction of QSNFs. Besides, we compare the above transformations to the ones for basic formulas, which is the simplest notion of solved form for unification problems.
Whereas basic formulas simply consist in a conjunction of equations and dise- quations, QSNFs are formally defined as follows.
Definition 3.1 Let x ⊆ X be a tuple of pairwise distinct variables. A QSNF for the variables x is either an atom true/false or a formula Ew ( a(x, w) ), where a(x, w) is a conjunction of the form
n	li	oi



x ≈ t ∧
  [  ( wi /≈ rij )∀\w ∧   ( wi ≈ sik )∃\w ]

such that
n, l1, ... , ln ≥ 0,
o1, ... , on ≥ 1,
i=1
j=1
k=1

the set of variables w = Var(t) is disjoint from x,
rij ∈ w if rij is a variable,
each sik is a linear term such that (w ∩ Var(sik)) = ∅.
Besides, the variables w are called auxiliary variables.	 

Note that every disjunction of equations on existential variables is non-empty. Otherwise, such disjunction (and, hence, the QSNF) would be equivalent to false . Besides, each variable in a term sij is existential and only occurs in sij. Hence, a disjunction of equations on an auxiliary variable w may consist of a single equation Ez (w ≈ z), which is equivalent to true. For technical convenience, we assume that there are always m equations in every QSNF for any m-tuple of variables x and, hence, we add a UQCD of the form x ≈ w if x does not occur in the QSNF , where w is a fresh variable from X .
There are two main differences between QSNFs and basic formulas: on one hand, QSNFs allow for a restricted kind of universal quantification. On the other hand, QSNFs are not pure DNF formulas because of the disjunctions of equations on aux- iliary variables. By means of these two features, QSNFs obtain a more compact representation of solutions than basic formulas, which (as we will show) increases the performance of constraint solving. The next two examples show the compactness of QSNFs for representing solutions.
Example 3.2 Let FL = {a/0, g/1, f/2}. The QSNF
Ew ( x ≈ f (w, a) ∧ 6v (w /≈ g(g(v))) ∧ 6v (w /≈ f (f (v1, v2), g(v3))) )



Fig. 1. Transformation Rules Involving Universal Quantification
is equivalent to the following disjunct of 7 basic formulas.
(x ≈ f (a, a)) ∨ (x ≈ f (g(a), a)) ∨ Ey (x ≈ f (g(f (y1, y2)), a)) ∨
(x ≈ f (f (a, a), a)) ∨ Ey (x ≈ f (f (a, f (y1, y2)), a)) ∨
Ey (x ≈ f (f (g(y), a), a)) ∨ Ey (x ≈ f (f (g(y1),f (y2, y3)), a)).	 
Example 3.3 Let FL = {a/0, g/1, f/2}. The QSNF
Ew ( x ≈ f (w1, w2) ∧ w1 /≈ w2 ∧
[ Ez (w1 ≈ g(f (z1, z2))) ∨ Ez (w1 ≈ f (g(z1), z2)) ] ∧
[ Ez (w2 ≈ g(f (z1, z2))) ∨ Ez (w2 ≈ f (z1, g(z2))) ] ) is equivalent to the following disjunct of 6 basic formulas
Ey (x ≈ f (g(f (y1, y2)), g(f (y3, y4)))) ∧ y1 /≈ y3) ∨
Ey (x ≈ f (g(f (y1, y2)), g(f (y3, y4)))) ∧ y2 /≈ y4) ∨
Ey(x ≈ f (g(f (y1, y2)),f (y3, g(y4)))) ∨
Ey(x ≈ f (f (g(y1), y2)), g(f (y3, y4))) ∨
Ey(x ≈ f (f (g(y1), y2),f (y3, g(y4))) ∧ y2 /≈ g(y4)) ∨
Ey(x ≈ f (f (g(y1), y2),f (y3, g(y4))) ∧ y3 /≈ g(y1)).	 
QSNFs have been proposed for improving the efficiency of general equality con- straint solving methods based on the quantifier elimination technique. For solving any formula, these methods keep, at each step, the matrix of the formula as a disjunction of the form i=1 ai, where each ai is a satisfiable constraint in some quasi-solved form. If the innermost block of quantifiers is existential, then it can be easily eliminated. However, when the innermost block is universal, double negation

is applied as follows
n	n


n	li


m  nj	m	o

ч   ai
i=1
'—→
  чai
i=1
(i)
'—→
    bij
i=1 j=1
'—→
    bjk
j=1 k=1
(ii)
'—→
    cjh
j=1 h=1

involving both (i) negation and (ii) conjunction on the selected quasi-solved form. The notion of QSNFs has been designed to improve the above transformation by means of its two main features. On one hand, disjunctions of equations on auxiliary variables minimize the use of distribution in many cases. On the other hand, uni- versal quantification drastically reduces the use of the explosion rule by means of the rule (UD) (see Figure 1). Roughly speaking, the rule (UD) splits a universally quantified formula into two parts, turning universal quantification into existential in the second subformula. Thus, by successive applications, the scope of each universal quantifier can be restricted to a single disequation. Hence, the rule (UD) is exten- sively used for both transformations on QSNFs: conjunction and negation. Besides, the two subformulas that are obtained by the rule (UD) are complementary, which is an important feature regarding conjunction: that is, because of the combination of negation and conjunction in the quantifier elimination technique, we often often has to simplify a conjunction of disjunctions of QSNFs that have been obtained by application of the rule (UD). Therefore, the complementary nature of the QSNFs in each disjunction easily reduces to false many of the combinations that are obtained by distribution.
In the next two subsections, we claim that negation and conjunction operations on QSNFs can be efficiently performed using some examples. Besides, we compare these operations on QSNFs with the same operations on basic formulas.

Negation
The syntactic form of QSNFs has been especially designed to deal with negation in a efficient way. The main advantages of using QSNFs for dealing with negation are shown in the next example:
чЕw ( x ≈ f (w1, w2) Λ 6v (w1 /≈ g(f (v, v))) Λ 6v (w1 /≈ f (a, v)) Λ
6v (w1 /≈ f (v, a)) Λ [ (w2 ≈ a) V Еz (w2 ≈ f (z1, z2)) ] )
On one hand, the restricted kind of universal quantification in QSNFs provides us an straightforward method for transforming the negated conjunction of equations into a disjunction of QSNFs, using the rule (UD). That is, the application of (UD) in the above negated QSNF yields
чЕw (x ≈ f (w1, w2)) V
Еw ( x ≈ f (w1, w2) Λ ч( 6v ( w1 /≈ f (v, v)) Λ 6v (w1 /≈ f (a, v)) Λ
6v (w1 /≈ f (v, g(a))) Λ [ (w2 ≈ a) V Еz (w2 ≈ f (z1, z2)) ] )
where the subformula (1) is already a QSNF for the variable x
Еw ( x ≈ w Λ 6v (w /≈ f (v1, v2)) ).

Therefore, the first part of QSNFs can be easily negated.
Regarding the second subformula, negated disjunctions of equations are trivially transformed into conjunctions of UQCDs and, besides, negated conjunctions of UQCDs are turned into disjunctions of equations. Hence, we only need to split each dis- junction of equations according to its characteristic terms. In our example, the only UQCD in subformula (2) with a non-linear characteristic term is 6v ( w1 /≈ f (v, v) ), thus its negation Ev ( w1 ≈ f (v, v) ) is distributed over the subformula. After simplification, we already obtain a QSNF for the variable x
Ew2 · v ( x ≈ f (f (v, v), w2) ).
Besides, just by distribution, we also get the following two QSNFs: 
Ew ( x ≈ f (w1, w2) Λ [ Ev (w1 ≈ f (a, v)) V Ev (w1 ≈ f (v, g(a))) ] )
Ew ( x ≈ f (w1, w2) Λ (w2 /≈ a) Λ 6z (w2 ≈ f (z1, z2)) )
Hence, the result of negating the initial QSNF is the disjunction consisting of (3),
(4), (5) and (6). Note that transformation of this disjunction into a disjunction of basic formulas would also require several applications of the explosion rule in QSNFs
(3) and (6), and also distributing the disjunction of EQCEs on v of (5).
Conjunction
Conjunction requires some basic transformation steps that are common for every (quasi-)solved form consisting in a conjunction of equations and disequations. Af- ter these common transformations, conjunction require more transformations ac- cording to the characteristics of each (quasi-)solved form. In this subsection, we will show these transformation steps by means of the following example. Let FL = {a/0, g/1, f/2}, we are going to transform the conjunction of
Ey ( x1 ≈ y1 Λ x2 ≈ f (y1, y2) Λ 6v (y1 /≈ f (a, v)) Λ 6v (y1 /≈ g(f (v1, v2))) Λ
[ Ez (y1 ≈ f (z, g(a))) V Ez (y1 ≈ f (f (g(z1), z2), z3)) ] Λ
6v (y2 /≈ f (v, a)) Λ 6v (y2 /≈ g(v)) Λ
[ Ez (y2 ≈ f (f (z1, a), z2)) V Ez (y2 ≈ f (g(z1), z2)) ] ) Λ
with the following QSNF
Ew ( x1 ≈ f (w1, a) Λ x2 ≈ w2 Λ 6v (w1 /≈ f (g(v1), v2)) Λ w1 /≈ g(a) Λ
[ Ez (w1 ≈ f (z1,f (z2, z3))) V Ez ( w1 ≈ g(f (z1, z2)))] Λ
6v (w2 /≈ f (a, v)) Λ 6v (w2 /≈ f (v1, g(v2))) Λ
[ Ez (w2 ≈ f (g(z1), a)) V Ez (w2 ≈ f (f (f (z1, z2), z3), z4)) ] )
into an equivalent disjunctions of QSNFs. This transformation is easily generalizable conjunctions of n QSNFs for arbitrary n ≥ 2.
First, we check if the equational parts of the QSNFs unify. In our example, the most general unifier is σ = {y1 ← f (w1, a), w2 ← f (f (w1, a), y2)}. In case the most general unifier does not exist, the whole conjunction is reduced to false. Otherwise, the formula is transformed into the most general instance of the equational parts

in conjunction with all the disequational parts, applying the most general unifier of the equational parts.
Then, the next transformation steps depend on the particular features of each (quasi-)solved form. Dealing with basic formulas and since their disequational part consists of existentially quantified disequations, the next transformations combine disunification and distribution. For QSNFs, the treatment of UQCDs is almost the same since universal quantification does not affect to disunification and distribution is possible by means of the rule (UD). Further, the formulas that are obtained from most general unifiers are simpler in the case of UQCDs. That is, every mapping from a universal variable to any term can be removed, because such mappings yield disequations that are trivially equivalent to false. Such a transformation is applied to the first UQCD in (7):
6v (y1 /≈ f (a, v))σ = 6v (f (w1, a) /≈ f (a, v)) '→ ( w1 /≈ a V 6v (v /≈ a)) 
'→ (w1 /≈ a)
Besides, when the most general unifier does not exist, the UQCD is replaced by true, as it occurs with the second UQCD in (7):
6v (y1 /≈ g(f (v1, v2)))σ = 6v (f (w1, a) /≈ g(f (v1, v2))) '→ true
Unlike basic formulas, QSNFs allow disjunctions of equations in the second part of the formula, which have to be transformed combining unification and distribution. In this way, the disjunction of EQCEs in (8) is transformed as follows:
Ez (y1 ≈ f (z, g(a)))σ V Ez ( y1 ≈ f (f (g(z1), z2), z3) )σ
= Ez (f (w1, a) ≈ f (z, g(a))) V Ez ( f (w1, a) ≈ f (f (g(z1), z2), z3)) 
'→ false V Ez (w1 ≈ f (g(z1), z2) Λ z3 ≈ a)
'→ Ez (w1 ≈ f (g(z1), z2))
Since (domain(σ) ∩ {y2, w1})= ∅, the UQCDs in (9, 11) and the disjunctions of EQCEs in (10, 12) do not change. However, σ affects to the UQCDs in (13) and the EQCEs in (14). In the former, the first UQCD in (13) is replaced with true since the most general unifier does not exist:
6v ( w2 /≈ f (a, v) )σ = 6v ( f (f (w1, a), y2) /≈ f (a, v)) '→ true
Whereas the second UQCD in (13) is transformed in the following way:
6v (w2 /≈ f (v1, g(v2)))σ = 6v (f (f (w1, a), y2) /≈ f (v1, g(v2)))
'→ 6v (v1 /≈ f (w1, a) V y2 /≈ g(v2))
'→ 6v2 (y2 /≈ g(v2))
In the latter, the disjunction of EQCEs in (14) is transformed as follows:
Ez (w2 ≈ f (g(z1), a))σ V Ez (w2 ≈ f (f (f (z1, z2), z3), z4))σ
'→ Ez (f (f (w1, a), y2) ≈ f (g(z1), a)) V
Ez (f (f (w1, a), y2) ≈ f (f (f (z1, z2), z3), z4))
'→ false V Ez (w1 ≈ f (z1, z2) Λ z3 ≈ a Λ y2 ≈ z4)

'→ Ez (w1 ≈ f (z1, z2))
Finally, the conjunction of disjunctions of EQCEs on the same variables have to be transformed into a single disjunction. In our example, there is only one disjunction of EQCEs on y2 (subformula (10)), but we have a conjunction of three disjunctions of EQCEs on w1 (subformulas (16, 12, 18)), which is equivalent to
Ez ( w1 ≈ f (g(z1),f (z2, z3)) ).
Therefore, the initial conjunction of two QSNFs is equivalent to: 4
Ey ( x1 ≈ f (w1, a) Λ x2 ≈ f (f (w1, a), y2) Λ
(11)	6v (w1 /≈ f (g(v1), v2)) Λ w1 /≈ g(a) Λ
(15, 19)	w1 /≈ a Λ [ Ez (w1 ≈ f (g(z1),f (z2, z3)))) ] Λ
6v (y2 /≈ f (v, a)) Λ 6v (y2 /≈ g(v)) Λ
[ Ez (y2 ≈ f (f (z1, a), z2)) V Ez (y2 ≈ f (g(z1), z2)) ] )
Note that, since QSNFs includes disjunctions of EQCEs on auxiliary variables, the use of distribution can be delayed during the solving process, only performing the transformations that are needed to keep the constraint in normal form.

Satisfiability Test on QSNFs
In exchange for compact representation, a QSNF syntactically different from false may be non-satisfiable. That is, given a QSNF with auxiliary variables w, it may occurs that no assignment of domain w satisfies the conjunction of UQCDs and dis- junctions of EQCEs. Hence, checking the satisfiability on QSNFs (or checking the existence of such an assignment) has to be easy in order to efficiently solving gen- eral equality constraints.
In this section, we give a procedure a procedure for checking the satisfiability of a QSNF. This test is strongly based on the algorithm uncover (see Figure 2) that was introduced in [8], where the authors study the notions of explicit and implicit representations of sets of terms. An explicit representation of a set of terms simply consists of a finite disjunction of terms, whereas an implicit representation of a set of terms is an expression t/{t1 V ... V tn} that represents those ground instances of t that are not instances of ti for any 1 ≤ i ≤ n. Obviously, an explicit representation is also an implicit representation. However, implicit representations cannot be always transformed into an explicit representation. For example, being FL = {a/0, b/0, f/1}, the implicit representation
c(w1, w2)/{c(v1, a) V c(b, v2) V c(v3, g(v4))}
is refined to the explicit one {c(a, b), c(g(z), b)}, whereas c(w1, w2)/{c(v, v)} cannot be explicitly represented.

4 Note that the second UQCD in (9) and the one in (17) are equal modulo renaming.



Fig. 2. The algorithm uncover
In [8], the authors propose the algorithm uncover that decides if an implicit representation can be transformed into an explicit one, returning an explicit rep- resentation or an irreducible implicit representation respectively. The algorithm uncover decides on the basis of the following two results from [8].
Proposition 4.1 If the substitution θi is not linear for some 1 ≤ i ≤ n, then the implicit representation t/{tθ1 V ... V tθn} has no equivalent explicit representation.
Proof. See Proposition 4.6 in [8].
Proposition 4.2 If the substitution θi is linear for every 1 ≤ i ≤ n, then the implicit representation t/{tθ1 V ... V tθn} has an equivalent explicit representation.
Proof. See Proposition 4.8 in [8].
The original formulation in [8] is based on the notion of restriction of an instance tθ w.r.t. the term t. That is, an instance tθ is said to be restricted w.r.t. the term t if any variable appears more than once in the terms x1θ,... , xlθ, where Var(t)= 
{x1,... , xl}. For example, f (x1, x2){x1 ← x2} is restricted w.r.t. f (x1, x2) since the variable x2 appears twice in the terms x1{x1 ← x2} and x2{x1 ← x2}. Under the proviso that domain(θ)= Var(t) (and therefore (range(θ)∩Var(t)) = ∅), an instance tθ is restricted w.r.t. the term t iff θ is non-linear. That proviso is always reachable

since, given any instance tθ, we can find a substitution θ' such that tθ' is a renaming of tθ and domain(θ') = Var(t): we just need to transform θ into β ∪ {x ← z} for each variable x ∈ (Var(t) ∩ range(θ)), where domain(β)= domain(θ), range(β)= range(θ){x ← z} and z is a fresh variable from X . For example, this transformation yields f (x1, x2){x1 ← z, x2 ← z} for the above instance f (x1, x2){x1 ← x2}. From now on, we will assume that domain(θ)= Var(t) for any instance tθ and, therefore, we use the results of [8] but testing linearity instead of checking if instances are restricted.
For our purposes, we next redefine the notion of explicit representation for tuples of variables.
Definition 4.3 An explicit representation for an m-tuple of variables x is a set of linear terms of the form c(s1,... , sm) such that si ∈ TL(X ) for each 1 ≤ i ≤ m. 
Intuitively, explicit representations use variables for finitely representing an infi- nite universe of ground terms. Hence, the ground/non-ground nature of terms in an explicit representation relates to the finite/infinite nature of the represented universe of ground terms. Explicit representations are denoted by capital Greek letter Δ, possibly with sub-scripts, followed by the tuple of variables between brackets. For example, Δ[x1, x2, x3], Δ0[x2, x3] and Δ1[x1, x3] are three explicit representations, each one for a different tuple of variables.
Besides, we introduce two operations on explicit representations. The first op- eration is the projection of an explicit representation to a subset of its variables.

Definition 4.4 Let Δ[x] be an explicit representation for the n-tuple of variables x and z ⊆ x a m-tuple of variables. The projection of the explicit representation Δ[x] to z, denoted by Δ[z], consists of a term c(si1 ,... , sim ) for each c(s1,... , sn) ∈ Δ[x] such that every xij ∈ z.	 
The second operation is the Cartesian product of two explicit representations for pairwise disjoint tuples of variables. The generalization to the Cartesian product of n explicit representations for pairwise disjoint tuples of variables is trivial.
Definition 4.5 Let x and z respectively be an n-tuple and an m-tuple of variables such that x ∩ z = ∅. The Cartesian product of the explicit representations Δ1[x] and Δ2[z], denoted by Δ1[x] × Δ2[z], is the explicit representation that consists of all the terms of the form c(s1,... , sn, r1,... , rm) such that c(s1,... , sn) ∈ Δ1[x] and c(r1,... , rm) ∈ Γ2[z].	 
As a initial approach to the QSNFs satisfiability test, we first explain a very simple method using the algorithm uncover: let us consider a QSNF of the form
n

Ew ( x ≈ t Λ   [ ϕi Λ ψi ]) 
i=1
where w is the n-tuple of auxiliary variables, each ϕi is a conjunction of UQCDs and
each ψi is a disjunction of EQCEs such that its characteristic term is linear. The












Fig. 3. A Generalization of uncover for Sets

method proceeds in two steps. First, we obtain an explicit representation for the variables w from i=1 ψi in the following way: Δ0[w =] = Δ0[w1] × ... × Δ0[wn], where Δ0[wi] = ChT(wi, ψi) for each 1 ≤ i ≤ n. Note that the characteristic term of every EQCE in ψi is linear. Second, Δ0[w] is refined using the algorithm uncover according to the UQCDs. For simplicity, we provide the algorithm set uncover (see
Figure 3) that conveniently invokes uncover. Thus, all the calls to uncover can
be summed up as set uncover(Δ0[w], ChT(w,  n	ϕi)).  The call to set uncover
returns an explicit or an implicit representation, so the given QSNF is decided to be satisfiable unless set uncover returns an empty explicit representation. Note that, when set uncover returns an implicit representation, there exist infinitely many assignments that satisfy the given QSNF , which cannot be finitely enumerated.
The correctness of the above satisfiability test is directly given by the following result.
Theorem 4.6 The algorithm uncover ﬁnds an equivalent explicit representation for the implicit representation t/{tθ1 V ... V tθn} if one exists. Otherwise, the algorithm uncover terminates with an implicit representation.
Proof. See Theorem 4.1 in [8].
This initial approach to the satisfiability test uses all the UQCDs in the given QSNF to refine the explicit representation as much as possible, and refinement is a very time-consuming task. However, many of the UQCDs in a QSNF may not affect satisfiability. Hence, the satisfiability test on QSNFs can be optimized by exclusively performing the refinements that are strictly necessary to decide satisfiability. This is the underlying idea of our QSNF satisfiability test, which is described in Figure 4. Our refined test also works in two steps. At the first step, the conjunction of UQCDs on each auxiliary variable ϕi is split into two conjunctions, separating the UQCDs with a linear characteristic term from the ones with a non-linear characteristic
term into ϕ1 and ϕ2 respectively. Then, the initial explicit representation for each
i	i
auxiliary variable, which is obtained from its disjunction of EQCEs as before, is refined
according to the conjunction of UQCDs with a linear characteristic term. Linearity ensures that set uncover returns an empty or non-empty explicit representation (see Proposition 4.2). If the returned explicit representation for some auxiliary variable is empty, then the test stops and decides that the given QSNF is not satisfiable, since there is no possible assignment for that variable. Otherwise, we obtain a non-empty



Fig. 4. A QSNF Satisfiability Test

explicit representation for the auxiliary variables w by the Cartesian product of each explicit representation, which have to be refined using the conjunction of UQCDs with a non-linear characteristic term. In the next definition, we provide some conditions that allow to focus this refinement on some (not necessarily all) of the auxiliary variables, also excluding some of the UQCDs from ϕ2.
Definition 4.7 Let ϕ be a conjunction of UQCDs with non-linear characteristic term and Δ[w] a non-empty explicit representation for the variables w = Free(ϕ). The monotonic operator Vϕ,Δ[w] : 2w → 2w is defined by the following rule: given a variable z ∈ w and a subset of variables x ⊆ w, z ∈ Vϕ,Δ[w](x) iff for every term t in the projection Δ[z] there exists some 6v ( z /≈ r ) in ϕ such that
Free(r) ⊆ x
t and r are unifiable and mgu(t, r) is a linear substitution

mgu(t, r)†Free(r) is ground
range(mgu(t, r)) ∩ Free(r)= ∅
Besides, the set of variables GERVar(Δ[w], ϕ) denotes the greatest subset of w that is obtained as the union of all the iterative application of Vϕ,Δ[w] on the empty tuple.	 
It is easy to see that, if w' = GERVar(Δ[w], ϕ) and w'' = w \ w', then uncover invokes partition at least once for each term in the projection Δ[w'] in order to refine Δ[w] according to ϕ. Hence, the projection Δ[w'] could become empty. But, on the contrary, there exists at least one term t in the projection Δ[w''] that cannot be removed, because t and s are not unifiable or θ = mgu(t, s) is non-linear for each s ∈ ChT(ϕ, w''). Therefore, the projection Δ[w''] cannot become empty and the variables w'' can be discarded. Obviously, if we can exclude all the variables, then the test stops and returns satisfiable. Otherwise, the test proceeds to the second step with the set of non-discarded variables. Besides, some of the UQCDs with a non-linear characteristic term can also be discarded. In fact, we exclude all the UQCDs where some discarded variable occurs.
Definition 4.8 Let ϕ be a conjunction of UQCDs such that w = Free(ϕ) and z a subset of w. The conjunction of UQCDs VarUCDs(ϕ, z) is given by
{ 6v ( w /≈ r ) | 6v ( w /≈ r ) ∈ ϕ and (Var( w /≈ r ) \ v) ⊆ z }.	 
In order to discard more variables, we could defined stronger conditions than the ones in Definition 4.7. However, analizing more complicated conditions would become as expensive as the call to uncover with all the remaining UQCDs. Hence, we choose the condition in Definition 4.7 because it is not difficult to check and, besides, the set of discarded variables is optimal in most of the cases.
At the second step, the test refines the projection of the explicit representation to the tuple of non-discarded variables using the conjunction of non-excluded UQCDs Finally, our test decides that the input QSNF is satisfiable unless the refinement returns an empty explicit representation.
Next, we illustrate the application of our refined test to some QSNFs in the following two examples.
Example 4.9 Let us consider JL = {a/0, g/1, f/2} and the following QSNF
Ew ( x ≈ f (w1, w2) Λ w1 /≈ a Λ 6v (w1 /≈ g(v)) Λ 6v (w1 /≈ f (v, v)) Λ
6v (w1 /≈ f (w2, v)) Λ [ Ez (w1 ≈ g(z)) V Ez (w1 ≈ f (z1, z2)) ] Λ
6v(w2 /≈ g(g(v))) Λ 6v (w2 /≈ f (v1, v2)) Λ w2 /≈ g(w1) Λ
6v (w2 /≈ f (g(v, v))) Λ [ w2 ≈ a V Ez (w2 ≈ f (f (z1, a), z2)) ] )
According to the disjunctions of EQCEs in (21) and (23), the initial explicit repre- sentations are:
Δ0[w1] = {g(z), f (z1, z2)}
Δ0[w2] = {a, f (f (z1, a), z2)}

Then, we deal with the conjunctions of UQCDs such that its characteristic term is linear, which are ϕ1 = w1 /≈ a Λ 6v ( w1 /≈ g(v) ) (the two first UQCDs in (20)) and ϕ2 = 6v ( w2 /≈ g(g(v)) ) Λ 6v ( w2 /≈ f (v1, v2) ) ( the two first UQCDs in (22)). The calls set uncover(Δ0[w1], ChT(w1, ϕ1)) and set uncover(Δ0[w2], ChT(w2, ϕ2)) respectively return
Δ1[w1] = {f (z1, z2)}
Δ1[w2] = {a}
thus Δ[w1, w2] = {c(f (z1, z2), a)} is non-empty. Hence, we have to check if we can discard some of the variables w1 or w2 according to the remaining UQCDs: ϕ1 = 6v (w1 /≈ f (v, v))Λ6v (w1 /≈ f (w2, v)) (the last UQCD in (20) and the one in (21)) and ϕ2 = w2 /≈ g(w1) Λ 6v (w2 /≈ f (g(v, v))) (the last UQCD in (22) and the one in (23)).
On one hand, mgu(f (z1, z2),f (v, v)) is non-linear and mgu(f (z1, z2),f (w2, v))†w1·w2 is non-ground, hence conditions (2) and (3) in Definition 4.7 are respectively violated. On the other hand, the term a ∈ Δ1[w2] does not unify with neither g(w1) or
f (g(v, v)), thus it violates condition (1) in Definition 4.7. Hence, w1 and w2 together with all the remaining UQCDs are discarded and the input QSNF is decided to be satisfiable at the first step.	 
Example 4.10 Let us consider JL = {a/0 , g/1, f/2} and the following QSNF
Ew ( x ≈ f (w, a) Λ 6v (w /≈ g(v)) Λ [ w ≈ g(a) V Ez (w ≈ g(g(z))) ] ).
The initial explicit representation that is obtained from the disjunction of EQCEs is Δ0[w] = {g(a), g(g(z))} and the call set uncover(Δ0[w], ChT(w, 6v ( w /≈ g(v) ))) returns an empty explicit representation, thus the input QSNF is decided to be unsatisfiable at the first step.	 
QSNF satisfiability test has a poor worst case performance. Actually, it is an NP-complete problem (see [13]). However, our test performs efficiently in practice because of several structural reasons that can be summed up as follows. In general, QSNFs having expensive computations in both steps are unlikely. If the input QSNF contains a lot of UQCDs to be treated in the first step, then the explicit representation for some variable usually becomes empty and the test stops. However, when few UQCDs are treated at the first step, it is usual that we discard most of the auxiliary variables and, thus, the second step becomes unnecessary or very cheap. On the contrary, the worst case occurs when every w ∈ w has a large explicit represen- tation, but every possible assignment violates some UQCDs. In our experience, the combination of both properties requires a lot of UQCDs to be expressed.

Conclusions and Future Work
QSNFs have been proposed as a tool for efficiently solving equality constraints, with the aim of avoiding the repetition of many (and unnecessary) transformations when using the quantifier elimination technique. Roughly speaking, QSNFs provide a more compact representation, which allows to delay many distribution transformations. Besides, we have shown that testing satisfiability on UQCDs is not hard in practice.

Thus, the sequence of conjunction and negation transformations that is the basis a the general equality constraint solver can be more efficiently performed than using less compact normal forms.
Other improvements on general equality constraint solving using QSNFs , which may be studied in future works, are related to the initial transformation of general constraints into prenex formulas whose matrices are a disjunction of QSNFs and, also, to the use of strategies along the quantifier elimination process. Here, we briefly discuss both issues.
On one hand, the pre-process of the initially given constraint is a critical task that dramatically affects the perfomance of the solving process. Two features of this preliminary treatment are of great interest. First, the application of some simpli- fication rules, such as the rules proposed in [6], eliminates superfluous information and serves to reduce the number of QSNFs in the matrix. The second feature is the minimization of the number of variables in the prefix of formulas. That is, the proposed quasi-solved form allows both existential and universal quantifiers. Thus, some quantifiers in the initial formula may be translated into auxiliary quantifiers of a QSNF, instead of being moved to the prefix of the formula. Such a preliminar treatment of formulas could reduce (i) the number of quantifier elimination steps that are necessary for solving general equality constraint, and also (ii) the number of equations/disequations in the matrix of formulas. A combination of both fea- tures yields a more compact representation of formulas, which optimizes the solving process.
On the other hand, the cost of resolution grows exponentially with the size of constraints, due to the combination of conjunction and negation. Thus, it is desir- able to limitate the maximum size of formulas to be solved. The size of a formula may be given by the number of (a) quantifiers, (b) equations/disequations, (c) vari- ables, or any combination of them. Then, in order to solve formulas that exceed the maximum size, we may apply the classical Divide and Conquer technique. That is, if size limitation does not hold, then we first split the formula into subformulas satisfying the maximum size. For solving purposes, if the scope of some variable quantifier Ex/6x is more than one subformula, then the variable x is consider as a free variable in each subformula where x occurs. Then, each subformula is turned into prenex form and its matrix is transformed into a disjunction of QSNFs for the variables in the prefix and the variables that occur free. After solving all these subformulas, we combine the disjunctions of QSNFs obtained by resolution. For the combination phase, it may be necessary to apply the resolution method again if some quantifiers remain in the formula. Locally solving formulas in this way, that is applying the Divide and Conquer technique, is several times faster than global resolution.

References
A´lvez, J. and P. Lucio, Equational constraint solving via a restricted form of universal quantification, in: J. Dix and S. J. Hegner, editors, Foundations of Information and Knowledge Systems, Proceedings of the 4th International Symposium, FoIKS 2006, Budapest, Hungary, February 14-17, 2006, Lecture Notes in Computer Science 3861 (2006), pp. 2–21.


Buntine, W. L. and H.-J. Bu¨rckert, On solving equations and disequations, J. ACM 41 (1994), pp. 591– 629.
Clark, K. L., Negation as failure, in: H. Gallaire and J. Minker, editors, Logic and Data Bases (1978),
pp. 293–322.
Colmerauer, A., Equations and inequations on finite and infinite trees, in: FGCS, 1984, pp. 85–99.
Comon, H., Disunification: A survey, in: J. Lassez and G. Plotkin, editors, Computational Logic - Essays in Honor of Alan Robinson, 1991, pp. 322–359.
Comon, H. and P. Lescanne, Equational problems and disunification, J. Symb. Comput. 7 (1989),
pp. 371–425.
Compton, K. J. and C. W. Henson, A uniform method for proving lower bounds on the computational complexity of logical theories, Ann. Pure Appl. Logic 48 (1990), pp. 1–79.
Lassez, J.-L. and K. Marriott, Explicit representation of terms defined by counter examples, J. Autom. Reasoning 3 (1987), pp. 301–317.
Lloyd, J. W. and R. W. Topor, A basis for deductive database systems, J. Log. Program. 2 (1985),
pp. 93–109.
Maher, M. J., Complete axiomatizations of the algebras of finite, rational and infinite trees, in: LICS ’1988: Proceedings of the Third Annual Symp. on Logic in Computer Science, 5-8 July 1988, Edinburgh, Scotland, UK (1988), pp. 348–357.
Maher, M. J., Equivalences of logic programs, in: Foundations of Deductive Databases and Logic Programming, Morgan Kaufmann, 1988 pp. 627–658.
Malcev, A. I., Axiomatizable classes of locally free algebras, in: B. F. Wells, editor, The Metamathematics of Algebraic Systems (Collected Papers: 1936-1967), Studies in Logic and the Foundations of Mathematics 66, North-Holland, 1971 pp. 262–281.
Pichler, R., On the complexity of equational problems in cnf, J. Symb. Comput. 36 (2003), pp. 235–269.
Reiter, R., On closed world data bases, in: H. Gallaire and J. Minker, editors, Logic and Data Bases
(1978), pp. 55–76.
Rybina, T. and A. Voronkov, A decision procedure for term algebras with queues, ACM Trans. Comput. Log. 2 (2001), pp. 155–181.
Vorobyov, S. G., An improved lower bound for the elementary theories of trees, in: M. A. McRobbie and J. K. Slaney, editors, CADE-13: Proceedings of the 13th International Conference on Automated Deduction, Lecture Notes in Computer Science 1104 (1996), pp. 275–287.
