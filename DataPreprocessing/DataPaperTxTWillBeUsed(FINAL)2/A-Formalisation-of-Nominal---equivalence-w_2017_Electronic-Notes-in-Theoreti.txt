Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 332 (2017) 21–38
www.elsevier.com/locate/entcs

A Formalisation of Nominal α-equivalence with A and AC Function Symbols 1
Mauricio Ayala-Rinc´on†,‡, Washington de Carvalho-Segundo‡, Maribel Fernandez∗ and Daniele Nantes-Sobrinho†2
Departamentos de †Matem´atica e ‡Ciˆencia da Computa¸c˜ao	∗Department of Informatics Universidade de Bras´ılia, Brazil	King’s College London, England, UK

Abstract
A formalisation of soundness of the notion of α-equivalence in nominal abstract syntax modulo associative
(A) and associative-commutative (AC) equational theories is described. Initially, the notion of α-equivalence is specified based on a so called “weak” nominal relation as suggested by Urban in his nominal development in Isabelle/HOL. Then, it is formalised in Coq that this equality is indeed an equivalence relation. After that, general α-equivalence with A and AC function symbols is specified and formally proved to be an equivalence relation. As corollaries, the soundness α-equivalence modulo A and modulo AC is obtained. Finally, an algorithm for checking α-equivalence modulo A and AC is proposed. General α-equivalence problems are log-linearly solved while AC and the combination of A and AC α-equivalence problems have the same complexity as standard first-order approaches. This development is a first step towards verification of nominal matching, unification and narrowing algorithms modulo equational theories in general.
Keywords: Nominal logic; Alpha Equivalence, Equivalence modulo A and AC.


Introduction
Matching, unification and, more generally, checking the validity of equational prob- lems involving existential and universal quantification is a fundamental issue in automatic deduction. Roughly speaking, two terms s and t are syntactically equiva- lent (resp. matchable, uniﬁable) if s = t (resp. if there is a substitution σ such that sσ = t, or a substitution that applied to s and t simultaneously makes them equal: sσ = tσ). These notions can be extended to equational theories such as α-equivalence, commutativity, associativity, idempotence, etc. More generally, we consider equiva- lence, matching and uniﬁcation modulo E, where E is a set of equational axioms. In particular, α-equivalence plays a fundamental role in the λ-calculus [5] where it captures the notion of irrelevance of the names used as bound variables.

1 Partially supported by CNPq Universal grant 476952/2013-1.
2 Email: ayala@unb.br, wtonribeiro@gmail.com, maribel.fernandez@kcl.ac.uk, dnantes@mat.unb.br

http://dx.doi.org/10.1016/j.entcs.2017.04.003
1571-0661/© 2017 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

Adequate manipulation of bound variables was a main motivation for the devel- opment of Nominal Logic [20] and other formal developments including, nominal uniﬁcation [2,9,19,25,26], that is, unification modulo ≈α, nominal rewriting [16,17,18], deduction systems [11], programming languages [8,22,23] and reasoning frame- works [3,24]. In nominal syntax instead of variables one uses atoms that are differentiated by their names and used to build abstractions. Additionally, the notion of freshness is made explicit through inference rules that define whether atoms are free or not in a nominal term. Renaming of variables is defined through swappings of atoms that are essential components of permutations acting over terms. Finally, the notion of α-equivalence is made concrete through inference rules that specify whether, under some freshness constraints, terms are α-equivalent or not. This differs from the usual treatment in frameworks such as the λ-calculus, where α-equivalence is implicitly abstracted through assumptions such as Barendregt’s variable convention [5].
The best known and most complete formal development of nominal syntax was specified in Isabelle/HOL by Urban et al. ([25,26]): firstly, a relation ≈α is specified and proved to be sound, that is, proved to be an equivalence relation; secondly, a nominal unification algorithm is specified, which uses α-equivalence, and verified to be correct and complete. In particular, in [25], Urban describes in detail how to prove that the nominal ≈α relation is in fact an equivalence relation using an intermediate weak α-relation denoted as ∼ω.
Contribution. A formalisation in Coq of the soundness of α-equivalence in nominal syntax is described. The distinguishing feature of this development is that for the first time, to the best of our knowledge, we advance further and also check nominal α-equivalence with A and AC operators. The development can be enlarged with other equational theories. The main steps of the formalisation are described below.
	Initially, the notions of α-equivalence ≈α and the weak equivalence ∼ω are specified following Urban’s proof style [25]. Then it is formally proved that ∼ω is an equivalence relation. Using ∼ω it is then proved that the specified notion of α-equivalence is sound. Although this property is usually taken for granted, its formalisation is not straightforward, since it relies on a non trivial induction on terms in which the induction hypothesis cannot be directly established for convenient (α) renaming of proper sub-terms of the term to which the induction is applied. Other crucial, non-trivial properties needed are: preservation of freshness, equivariance of ≈α, preservation of permutation action.
An α-equivalence relation for terms with A and AC operators, denoted ≈{A,AC}, is specified and proved sound. The soundness of α-equivalence modulo A (≈α,A) and modulo AC (≈α,AC ) is inferred from the soundness of ≈{A,AC}. These relations are specified in a parameterised manner, which will simplify the treatment and combination of α-equivalence with other equational theories. Function symbols are annotated to indicate whether they are A or AC. The relation ≈{A,AC} uses the rules of α-equivalence and it is proved that restricting it to α-equivalence corresponds to ≈α. Thus, using correctness of ≈α, the relation ≈{A,AC} is checked by applying the algebraic properties of A and AC operators and, in addition

properties of preservation of freshness and equivariance for ≈{A,AC}.
	An algorithm, based on the Coq specifications, for deciding ≈{A,AC} is given. When checking equivalence, the decision whether or not to apply nominal inference rules specialised for A or AC symbols is done in a natural manner using the function symbol annotations. Assuming a pre-computation of the flat form of terms headed with function symbols, it is proved that the cost of deciding α-equivalence only modulo A is log-linear on the size of the problem, whereas α-equivalence modulo AC behaves as the algorithm presented by Benanav, Kapur and Narendran [6] for the case of pure AC-equivalence.
Related Work. Equational problems have been extensively explored since the early development of modern abstract algebra (see, e.g., the E-unification survey by Baader et al [4]). Specifically, regarding AC unification and according to Boudet, Contejan and Devie [7] “AC unification is a main issue in term rewriting and automated deduction in general”. The treatment given to the problem of deciding AC equality in usual first-order syntax reduces to the problem of searching for a perfect matching in a bipartite graph, as shown in [6].
In addition to the Isabelle/HOL formalisation, there are also formal nominal developments in Coq and PVS. Ayala-Rinc´on, Fern´andez and Rocha-Oliveira [2] formalised ≈α-equivalence in PVS without using the auxiliary relation ∼ω, following the proof sketches proposed in [16], and provided a formalisation of correctness of a nominal unification algorithm. Aydemir, Bohannon and Weirich developed nominal reasoning techniques in Coq [3]. In contrast to the current development, that approach does not take into account a formal verification of nominal equality, because it identifies α-equivalent terms by indexation of the occurrences of bound variables as natural numbers according to their position in the term.
Recently, Copello et al. [12] presented a nominal approach, based essentially on nominal swapping and freshness, used to deal in a concrete manner with α- conversion in the λ-calculus. This was used to formalise in Agda principles of α-structural induction and recursion through this nominal concrete implementation of Barendregt’s variable convention. Also, Schmidt-Schauss et al. [21] presented nominal unification and matching algorithms for λ-expressions with a recursive let instruction. They proved that both problems are NP-complete and transferring the method, they proved that nominal commutative unification is also NP-complete.
Outline. Section 2 presents necessary background on nominal abstract syntax. Sections 3 and 4 respectively present the formalisations of soundness of α-equivalence and its version with A and AC operators. Before concluding, Section 5 discusses algorithms for deciding ≈{A,AC}, extracted from the Coq specification, that is available at https://github.com/wtonribeiro/nominal-ac.
Nominal Syntax
This section introduces nominal syntax following [25,16].
Given a signature Σ of function symbols and countably infinite sets V and A of
variables and atoms, respectively, the set T (Σ, A, V) of nominal terms is generated

by the following grammar:

s, t ::=	⟨⟩ | a | [a]t | ⟨s, t⟩ | f E t | π.X

Atoms only differ in their names, so for atoms a and b the expression a /= b is redundant. A permutation is a bijection on A with a finite domain. A swapping is defined as a pair of atoms (a b) and a permutation π is represented by a finite list of swappings of the form (a1 b1) :: ... :: (an bn) :: nil, where nil denotes the identity permutation. The reverse list of swapings representing π, corresponds to π−1, the inverse of π. The composition of permutations π and πj is denoted as πj ⊕ π. Unary permutations (a b) :: nil will be abbreviated as (a b). A variable X ∈V as a term object should always be decorated by some permutation π suspended on X, π.X. For brevity, terms of the form nil.X will be written as X.
Permutations act on nominal terms, but suspend over variables. The empty tuple or unit is denoted as ⟨⟩ and non empty tuples are built using pairs of terms of the form ⟨s, t⟩, where s and t might be also pairs. Notice that this syntax does not allow construction of unary tuples. The notation a represents the atom a as a term object. [a]t is an abstraction of an atom a in a term t. The notation f E t represents the application of f E ∈ Σ to t. The scripts E and k in the function symbol f E are
k	k
respectively used to distinguish the equational properties of the function symbol and
the indexation of the function symbol between the class of operators with the same equational properties. These scripts will be omitted when no confusion arises.

In the specification the grammar is written as above. Operators Ut, At, Ab, Pr, Fc and Su specify the unit, atoms as term objects, abstractions, pairs, function applications and suspended variables, respectively. For the Fc constructor, the first and second nat arguments represent the super and subscripts of the applied function symbol. In the specification, the function symbols f A and f AC are repre-
j	k
sented respectively by Fc 0 j and Fc 1 k, both having type term → term. All other
superscripts are representing the empty equational theory.
An atom as an object term a, is written in Coq as (At a). When necessary, this syntax is used in the pseudo-code describing the specification, otherwise standard nominal syntax will be adopted. Notice that although in nominal syntax two atoms a and d are different by definition, (At a) and (At d) could be the same atom, since in the Coq specification a and d are used as meta-variables ranging over atoms.

Definition 2.1 The action of a permutation over terms is specified as the homeomorphic extension of the action of lists of swappings over single atoms:


nil · a	:= a
⎧⎪ if c = a then πj·d
⎧π · ⟨⟩	→ ⟨⟩
π · a	→ (At π · a)
⎨π · f E t	→ f E (π · t)

((c d) :: πj)·a := ⎪⎨
⎧⎨ if d = a then πj·c
π · t :=
⎪π · ⟨u, v⟩	→ ⟨π · u, π · v⟩

⎪⎪⎩else ⎩
else πj·a
π · ([a]t)	→ [π · a](π · t)
⎪⎪⎩π · (πj .X) → (πj ⊕ π) .X 


The action of a permutation over an atomic term object a, e.g., nil · a, gives as result a term. This is specified as nil · (At a), which gives as result a, that is, (At a), and not the atom a. The action of the permutation π over the suspended variable πj.X gives as result the term π · (πj.X) = (πj ⊕ π).X. Notice that permutation composition works in the opposite direction.
The permutation (a b) :: π acting over the term [a]⟨b, πj.X⟩ will have as result [π · b]⟨At (π · a), (πj ⊕ ((a b) :: π)).X⟩.
The native notion of equality on nominal terms is α-equivalence, which is defined using swappings and a notion of freshness. A freshness constraint is a pair a # t of an atom and a nominal term t. Intuitively, a # t means that a is fresh in t, that is, if a occurs in t then it must do so under an abstractor [a]. An α-equality constraint is a pair s ≈α t of two terms s and t. A freshness context, is a set of freshness constraints.
∇ will range over freshness contexts. A freshness judgement is a tuple of the form
∇▶ a # t whereas an α-equivalence judgement is a tuple of the form ∇▶ s ≈α t.
Table 1
Rules for the freshness relation

The derivable freshness and α-equivalence judgements are defined by the rules in Tables 1 and 2. We write ds(π, πj)#X as an abbreviation of {a # X | a ∈ ds(π, πj)},
where ds(π, πj)= {a | π · a =/	πj · a} is the set of atoms where π and πj differ (the
difference set). A set P of constraints is called a problem. We write ∇▶P when proofs of the judgment ∇▶ P exist for each P ∈ P, using rules of Tables 1 and 2.
The rules for abstractions and suspensions are the interesting ones. For example,
∇ ▶ a # ⟨[a](⟨a, b⟩), π.X⟩ can be derived only if π—1 · a#X is in ∇. There are two rules for abstractions in Table 2: [≈α-ab1] and [≈α-ab2]. The latter, for abstractions built with different atoms, swaps the atoms in one of the abstractions, provided the atom is fresh.

Table 2
Rules for α-equivalence






Formalisation of soundness of the ≈α relation
Using the Coq specification, alpha equiv (that is, ≈α of Table 2) was formally proved to be an equivalence relation. This section describes the formalisation.
Standard proofs use a measure on terms to prove that ≈α is symmetric and then prove that ≈α is transitive [2,16,19,26]. We use an alternative proof proposed by Urban in [25]: initially a so called “ weak” equivalence relation ∼ω is defined, as given in Table 3. Afterwards, ∼ω is proved to be an equivalence relation, which is straightforward and gives an intermediate transitivity result for ≈α: ∇▶ t1 ≈α t2 and t2 ∼ω t3 implies ∇▶ t1 ≈α t3. Finally, this result is used in conjunction with some auxiliary lemmas to prove firstly the transitivity and then the symmetry of
≈α. The final part of the formalisation relies on three main auxiliary lemmas:
Freshness preservation of ≈α: ∇▶ a # t and ∇▶ t ≈α tj imply ∇▶ a # tj;
Equivariance of ≈α: ∇▶ t ≈α tj implies ∇▶ π · t ≈α π · tj;
Invariance of ≈α under the action of permutations: (∀a ∈ ds(π, πj), ∇▶ a # t) iff
∇▶ π · t ≈α πj · t.
Table 3
Rules for weak α-equivalence

For checking α-equivalence modulo A and AC, ≈{A,AC}, one uses soundness of ≈α. Thus, one could adopt any approach for checking ≈α maintaining the approach for checking ≈{A,AC}. More specifically, we specify an inductive relation equiv(S), where S is a set of indices, each one associated with a different equational theory. In particular, the relation equiv(∅) excludes from the specification of equiv, all specialised inference rules for any equational theory. The relation equiv(∅) is formally proved to be equivalent to the relation ≈α: ∇▶ t ≈α tj ⇔ equiv(∅)(∇, t, tj).

Lemma 3.1 (Intermediate transitivity for ≈α with ∼ω) If ∇▶ t1 ≈α t2 and
t2 ∼ω t3 then ∇▶ t1 ≈α t3 .
The proof is by induction on ≈α. It uses basic properties of nominal terms and expansions of the inference rules in the definition of ≈α, except for the rule [≈α -ab2] whose analysis requires the application of the equivariance property for ∼ω and preservation of freshness under ∼ω. Namely, in the inductive step of this case one has as premises ∇ ▶ t1 ≈α (a b) t2, ∇ ▶ [a]t1 ≈α [b]t2, [b]t2 ∼ω t3, ∇ ▶ a # t2 and as IH: for all t0, (a b) t2 ∼ω t0 implies ∇ ▶ t1 ≈α t0; and one needs to conclude that ∇ ▶ [a]t1 ≈α t3 (some non relevant premises are omitted). By properties of
∼ω, [b]t2 ∼ω t3, t3 should be of the form [b]tj . Thus, one needs to conclude that

∇ ▶ [a]t1 ≈α [b]tj . Additionally, one has t2 ∼ω tj
and, by equivariance of ∼ω, it

3	3
follows that (a b)t2 ∼ω (a b) tj . Also, by preservation of freshness under ∼ω one has
∇▶ a # tj . Instantiating the IH with (a b) tj , one has that ∇▶ t1 ≈α (a b) tj . From
3	3	3
this, applying rule [≈α -ab2], one finally concludes that ∇▶ [a]t1 ≈α [b]tj .
Lemma 3.2 (Freshness preservation of ≈α) If ∇▶ a # t and ∇▶ t ≈α tj then
∇▶ a # tj.
The proof is by induction on ≈α. The interesting case is the analysis of the [≈α-ab2] rule, whose hypotheses are a0 /= b0, ∇ ▶ t ≈α (a0 b0) tj, ∇ ▶ a0 # tj, and
∇ ▶ a # [a0]t.  By IH ∇ ▶ a # t ⇒ ∇ ▶ a # (a0 b0) tj.  One should prove that
∇▶ a # [b0]tj. For doing this, the three cases: a = a0, b0 = a /= a0 and b0 /= a /= a0 should be analysed. The difficult case is the last one, which is solved by application of the [#ab2] rule with the use of a technical lemma about the freshness relation.
Lemma 3.3 (Equivariance of ≈α) If ∇▶ t ≈α tj then ∇▶ π · t ≈α π · tj .
The formalisation is by induction on ≈α. The tricky case is when one has as hypotheses a /= b, ∇▶ t ≈α (a b) tj and ∇▶ a # tj. The IH is ∇▶ π · t ≈α π · ((a b) tj). It should be proved that ∇ ▶ π · ([a]t) ≈α π · ([b]tj). Applying the definition of the permutation action and the [≈α-ab2] rule, three subgoals have to be proved: π · a /= π · b, ∇▶ (π · t) ≈α ((π · a) (π · b)) (π · tj) and ∇▶ (π · a)# (π · tj). The first and the last are trivially solved by technical lemmas. For the second sub goal, Lem. 3.1 instantiating t2 with π · ((a b) tj) is applied. Then one of the new subgoals is the IH and the other one is (π · ((a b) t)) ∼ω ((π · a) (π · b)) (π · tj). The latter is an instance of a technical lemma about the distribution of a permutation among swappings.
The next result will be applied in the proof of Lem. 3.5 and in proofs related with symmetry, as preservation of α-equivalence under swappings, e.g., ∇▶ (a b) · t ≈α (c d) · t with ∇▶ a, b, c, d # t.
Lemma 3.4 (Invariance of terms under ≈α and action of permutations)
(∀a ∈ ds(π, πj), ∇▶ a # t) iff ∇▶ π · t ≈α πj · t.
This lemma is proved by induction on t under arbitrary permutations.
Lemma 3.5 (Second intermediate transitivity lemma) If ∇ ▶ t1 ≈α t2 and
∇▶ t2 ≈α π · t2 then ∇▶ t1 ≈α π · t2.

The proof is by induction on ≈α in the hypothesis ∇▶ t1 ≈α t2. The interesting
case is for abstractions, that is t1 = [a]tj and t2 = [b]tj . Several cases are to be
considered according to whether a and b, a and π · a, b and π · b as well as a and
π · b are or not equal.
Lemma 3.6 (Reflexivity of ≈α) ∇▶ t ≈α t .
This lemma is proved by routine induction over the structure of t.
Lemma 3.7 (Transitivity of ≈α) If ∇ ▶ t1 ≈α t2 and ∇ ▶ t2 ≈α t3 then ∇ ▶ 
t1 ≈α t3.
The formalisation is by induction in ∇▶ t1 ≈α t2 with generalisation of t3. The

difficult case occurs when t1 = [a]tj , t2 = [b]tj and t3 = [c]tj , with a /= b =/
c /= a.

1	2	3

The IH is given as ∀t0, ∇ ▶ tj
≈α t0 ⇒ ∇ ▶ tj ≈α t0, and the other hypotheses

are: ∇▶ tj ≈α (a b) tj , ∇▶ a # tj , ∇▶ tj ≈α (b c) tj and ∇▶ b # tj . It should be
1	2	2	2	3	3
concluded that ∇▶ [a]tj ≈α [c]tj .

Applying the rule [≈α-ab2] to the goal one obtains the subgoals ∇▶ a # tj
and

∇▶ tj ≈α (a c) tj . The former is proved by Lem. 3.2. Applying IH over the latter
subgoal, it remains to prove ∇ ▶ (a b) tj ≈α (a c) tj . So, it is needed to prove the
intermediate statement ∇ ▶ [(b c) :: (a b)] · tj ≈α [(b c) :: (a b) :: (b c)] · tj , that is
possible by application of Lem. 3.4. Manipulating swappings and using Lem. 3.5 one
infers ∇▶ (a b) tj ≈α [(b c) :: (a b) :: (b c)] · tj . Finally, applying Lem. 3.1 with t2 :=

[(b c) :: (a b) :: (b c)] · tj
only remains to prove that [(b c) :: (a b) :: (b c)] · tj
∼ω (a c) tj ,

that can be done using properties of ∼ω such as its equivalence and equivariance.
Lemma 3.8 (Symmetry of ≈α) If ∇▶ t ≈α tj then ∇▶ tj ≈α t .
The proof is by induction on ≈α over ∇▶ t ≈α tj. The non-trivial case is when

a =/
b and the hypotheses are ∇▶ t0 ≈α (a b) tj , ∇▶ a # tj and ∇▶ (a b) tj
≈α t0,

0	0	0
with the subgoal ∇▶ [b]tj ≈α [a]t0. This is proved by application of the rule [≈α-ab2]
and then by a double application of Lem. 3.7 instantiated with t2 := (a b) t0 and
t2 := [(a b) :: (a b)] · t0. The remaining subgoals are treated using Lem. 3.3.
Formalising soundness of ≈{A,AC}, ≈α,A  and ≈α,AC
The generic relation equiv(S) mentioned at the end of Sec. 3 takes into account A and AC function symbols if 0 ∈ S and 1 ∈ S, respectively.
Namely, equiv({0}), equiv({1}) and equiv({0, 1}) choose the specialised in- ductive rules in the definition of equiv for the relation ≈α modulo A, AC and A combined with AC function symbols, respectively. In this way one builds the relations ≈α,A, ≈α,AC and ≈{A,AC}. Function symbols with superscripts 0 and 1 will be interpreted as A and AC operators respectively, only when the parameter S includes 0 or/and 1. Using the parameter S = {0} and function symbols with arbitrary superscripts, including 0, and only function symbols with superscript 0, respectively general and elementary α-equational modulo A problems are expressed ([4]). The same happens for AC problems. The formalisations given here are for

general α-equivalence problems. For simplicity, instead 0 and 1 we will use A and AC in the sequel.

Operations over tuples
The inductive rules for A and AC operators in the definition of the relation ≈{A,AC} use three auxiliary operators that deal with arguments of function symbols. Arguments of a function symbol f are terms or tuples built using the constructor for pairs and the arguments of terms headed by the same function symbol f . These operators, specified as in Fig. 1, extract the relevant information of the arguments to which a(n A or AC) symbol f is applied and specify the length or number of arguments, t  f , and the selection and deletion of the ith argument, respectively, t(i) and t[٨i] .
⎧⎪⟨s, u⟩→ s f + u f	⎧⎪⟨s, u⟩→ ⎧⎨ if i ≤ s f then s

⎪⎪⎪⎨
⎪⎪⎧ if g = f
⎪⎪⎪⎨
⎧⎩ else u(i—s f )f
(i)f

t f :=	gs →	then s f
⎪	⎪
t(i)f := ⎪ gs → ⎨ if g = f then s(i)f

⎪⎪⎩  
⎪⎩ else 1
→ 1
⎪⎪⎩  
⎩ else gs 
→ t

⎧⎪	⎧⎪

if i ≤ s f
then ⎧⎨

if  s

f =1 then u

⎪ ⟨s, u⟩→ ⎨	⎧
⎩ else ⟨s[٨i]f , u⟩

t[٨i]f := ⎪⎨
⎪⎪⎩ else ⎨
if u f =1 then s
else ⟨s, u[٨(i—s f )]f ⟩

⎪ gs → ⎧⎨
⎪	⎩
if gs f =1 then ⟨⟩
[٨i]f

⎪⎪⎩  

→ ⟨⟩
else g (s	)


Fig. 1. Specification of operators for the length of the tuple or arguments, selection and deletion of the ith
argument regarding the function symbol f

To simplify notation, the scripts of f will be omitted in these operators when clear from the context. The behaviour of these operators is illustrated below
Example 4.1 For the number of arguments. • f⟨⟩  f = ⟨ ⟩f = 1. • f ⟨a, b⟩f =  ⟨a, b⟩f = 2, but g ⟨a, b⟩f = 1; • f ⟨[a](π · X),f ⟨b,g ⟨a,f ⟨a, b⟩⟩⟩⟩f = [a](π · X)  f + b  f + g ⟨a,f ⟨a, b⟩⟩f = 3.
Example 4.2 For the selection of the ith argument. • t(0)f = t(1)f and, if i >  t  f then t(i)f = t(  t  f )f . • If  t  f = 1 and t is not headed by f then t(1)f = t, but (f f t)(1)f = t; • (f ⟨[a](π · X),f ⟨b,g ⟨a,f ⟨a, b⟩⟩⟩⟩)(3)f = (f ⟨b,g ⟨a,f ⟨a, b⟩⟩⟩)(2)f = (g ⟨a,f ⟨a, b⟩⟩)(1)f = g ⟨a,f ⟨a, b⟩⟩.

Example 4.3 For the deletion of the ith argument.  • t[٨0]  = t[٨1]  and if i >  t  f then t[٨i]ƒ  = t[٨  t  ƒ ]ƒ . • If  t  f = 1 then t[٨1]ƒ  = ⟨ ⟩; • (f ⟨[a](π · X),f ⟨b,g ⟨a,f ⟨a, b⟩⟩⟩⟩)[٨2]ƒ = f ⟨[a](π · X), (f ⟨b,g ⟨a,f ⟨a, b⟩⟩⟩)[٨1]ƒ ⟩
= f ⟨[a](π · X),f (g ⟨a,f ⟨a, b⟩⟩)⟩.
It should be clear to the reader that the specification follows the lines of nominal syntax in which function symbols have no fixed arity. Thus for any A or AC symbol it should be interpreted apart what means its application to the unit (⟨⟩) and to a single argument, for instance, with the usual interpretation for operator symbols,
∧⟨⟩, ∨⟨⟩, +⟨⟩ and ×⟨⟩ might be specified as “false”, “true”, 0 and 1, respectively.
Using these operators has two advantages: first, no additional data structure (e.g. list, sequence, array) or flattening operator is needed to express associativity; second, the approach is generic: the grammar and the given rules can be extended to manipulate operators from various equational theories, in a natural way. If function symbols with different equational properties occur in a term, the specialised inference rules that deal with their equational properties are used. This simplifies the treatment of α-equivalence modulo A and AC, and other equational theories.
In Table 4 a few formalised results are listed, from a much longer list of for- malised lemmas related with these operators. These results will be referenced in the description of the lemmas related with E-equivalence and for brevity they are presented free of universal quantifiers.
Table 4
Basic properties of the operators over terms:  ƒ ,	( )f and [s  ]f




Extension of ≈α-rules
New rules [equiv A] and [equiv AC] for associativity and commutativity are intro- duced. These rules will be combined with those from Table 2 for ≈α, with the following modification: [≈α-fc] will be replaced by [equiv Fc] and applies whenever the function symbol f E is such that E ∈/ S; otherwise, when E = A or E = AC and E ∈ S, rules [equiv A] or [equiv AC] apply. Thus in the case f is neither an A nor an AC function symbol or A, AC ∈/ S, the behaviour of [equiv Fc] and [≈α-fc] would be exactly the same. These rules define an extended calculus for general α-equivalence modulo A and AC ([4]), denoted by the relation ≈{A,A&} (specified as equiv({0, 1})). Other equational theories might be included similarly. Below, s ≈{A,A&} t denotes that s and t are α-equivalent modulo A and AC.
Rule [equiv A] applies when the terms compared are headed by the same A function symbol and A ∈ S. It verifies recursively if the first arguments on the left (lhs) and right-hand sides (rhs) are related by ≈{A,A&} as well as the result of applying the root function symbol to the respective tuples without the first argument.







Fig. 2. [equiv Fc]-rule for ≈{A,A&}









Fig. 3. [equiv A]-rule for A function symbols







Fig. 4. [equiv AC]-rule for AC function symbols
Rule [equiv AC] behaves similarly to rule [equiv A]: the fundamental difference is that the first argument on the lhs can be compared modulo ≈{A,A&} with any arbitrary argument on the rhs. If there exists such argument, say the ith, it remains to check that the terms obtained applying the function symbol to the tuples deleting the first and the ith arguments to the right and to the left are related by ≈{A,A&} .
Example 4.4 ∇ ▶ f ⟨t1, gAC ⟨t2, gAC⟨t3, t4⟩⟩⟩ ≈{A,A&}  f ⟨t1, gAC ⟨⟨t4, t3⟩, t2⟩⟩, where g is AC, f is a function symbol that allows only α-equivalence and AC ∈ S.
Checking ≈{A,AC}, ≈α,A and ≈α,AC
An interesting aspect of checking ≈α,A& is that it follows the general lines of formali- sation of α-equivalence but using as “weak” relation ≈α instead of ∼ω: after proving an intermediate transitivity lemma for ≈{A,A&} (Lem. 4.5), one proves freshness preservation and equivariance (Lemmas 4.6, 4.7) of ≈{A,A&} and then, transitivity before symmetry (Lemmas 4.10 4.11). By using the parameter set S on the equiv(S) relation and renaming superscripts of function symbols, one obtains as corollary of the soundness ≈{A,A&} the soundness of ≈α,A and ≈α,A& .
In addition to preservation of freshness and equivariance, the intermediate transitivity lemma (Lem. 4.5) is relevant to guarantee some key properties on swappings and permutations acting over ≈{A,A&}-related terms as for instance,
∇▶ t ≈{A,A&} (a aj) tj ⇒∇▶ (aj a) t ≈{A,A&} tj.
Lemma 4.5 (Intermediate transitivity for ≈{A,A&} with ≈α) If  ∇    ▶
s ≈{A,A&} t and ∇▶ t ≈α u then ∇▶ s ≈{A,A&} u.
The formalisation is obtained as follows: after generalisation of u, induction

is applied on deduction rules of ≈{A,A&} for ∇ ▶ s ≈{A,A&} t. In some cases it is required inversion of ∇ ▶ t ≈{A,A&} u; for instance, in the case in which one has t = ⟨t1, t2⟩, inversion is applied to obtain that u = ⟨u1, u2⟩ with ∇▶ t1 ≈{A,A&} u1 and ∇▶ t2 ≈{A,A&} u2, according to the inference rule [≈α-pr].
Lemma 4.6 (Freshness preservation under ≈{A,A&}) If ∇ ▶ a # s and ∇ ▶
s ≈{A,A&} t then ∇▶ a # t.
The proof is by induction on ≈{A,A&}, using some technical results about the freshness relation for dealing with cases related with rules [≈α-ab1] and [≈α-ab2] for the case in which s and t are abstractions.
Lemma 4.7 (Equivariance of ≈{A,A&}) If ∇▶ s≈{A,A&} t then ∇ ▶π·s≈{A,A&} π·t.
Equivariance follows by induction in the inference rules of ≈{A,A&}. For the case of abstractions, specifically for the case of the rule [≈α-ab2], Lem. 4.5 is required; indeed, when one has ∇▶ [a]sj ≈{A,A&} [b]tj, initially it is necessary to prove that
∇▶ π · sj ≈{A,A&} π · ((a b) · tj) and ∇▶ π · ((a b) · tj) ≈α (π · a π · b) · (π · tj) and then apply that lemma to obtain ∇▶ π · sj ≈{A,A&} (π · a π · b) · (π · tj).
Lemma 4.8 (Reflexivity of ≈{A,A&}) ∇▶ t ≈{A,A&} t .
Reflexivity is easily proved by induction on t. The next lemma generalises the way in which arguments used in the rule [equiv AC] are combined.
Lemma 4.9 (Combination of AC arguments) If ∇ ▶ t  ≈{A,A&}  tj then

∀(0 <i ≤ t  ƒ
)∃(0 <j ≤ t  ƒ
)∇▶ t(i)ƒ
≈{A,A&} tj
ƒ
and ∇▶ t[٨i]ƒ
≈{A,A&} tj	.
ƒ

The proof is by induction on t  f using simple auxiliary lemmas and properties of the operators  t  f , t(i)ƒ and t[٨i]ƒ . We explain the particular case for i = 1:
j	j	j
∇ ▶ t ≈{A,A&} t ⇒ ∃(0<j≤t′  ƒ ), ∇ ▶ t(1)ƒ ≈{A,A&} t(j)ƒ  ∧ ∇ ▶ t[٨1]ƒ ≈{A,A&} t[٨j].
The complicated case happens when t f > 2: after applying the auxiliary lemma for

terms f t and f tj one obtains ∇▶ t(1)
≈{A,A&} tj
0 ƒ
and ∇▶ f t[٨1]ƒ
≈{A,A&} f tj	,
0 ƒ

for some i0. If i = 1, the result follows trivially. For i > 1, induction applies for

the terms t0 = f t[٨1]ƒ
and tj
= f tj[٨i ]
with argument i1 = i − 1. Notice that

the IH is given as ∀( t
< t  , t′ , 0<i ≤t
)∃j1, ∇▶ t0(i )
≈{A,A&} tj
and ∇ ▶ 

0 ƒ	ƒ  0
1	0 ƒ
1 ƒ	0(j1)ƒ

t0[٨i1]ƒ
≈{A,A&} tj
ƒ
. Then, applying IH, a witness j is obtained such that, with

the pre-conditions:  f t[٨1]ƒ
 f <  t  f and ∇▶ f t[٨1]ƒ
≈{A,A&} f tj[٨i ]
, one obtains

∇▶ f t(i)ƒ
≈{A,A&} f tj(j)
and ∇▶ f t[٨(i)]ƒ
≈{A,A&} f tj[٨j]
. The first pre-condition

is solved by an application of the definition of  and an auxiliary lemma for the
operators t  f and t[٨i]ƒ . The second is exactly the assumption. Then one just needs to consider two cases: i0 ≤ j1 or i0 > j1. One instantiates j respectively as j1 +1 or j1 and concludes using properties of the operators t  f , t(i)ƒ and t[٨i]ƒ .
Lemma 4.10 (Transitivity of ≈{A,A&}) If ∇▶ t1 ≈{A,A&} t2 and ∇▶ t2 ≈{A,A&}
t3 then ∇▶ t1 ≈{A,A&} t3 .
The formalisation is by induction on the size of t1, where the size of the specified nominal terms is given by their components according to the data structure built

inductively from their syntax. The terms t2 and t3 are generalised, and inversions from the equational inference rules are applied to both ∇ ▶ t1 ≈{A,A&} t2 and
∇▶ t2 ≈{A,A&} t3. The difficult cases are those of rules [≈α-ab2] and [equiv A] or

[equiv AC]. For [≈α-ab2], an interesting subcase is when a =/
aj /= aj
/= a: the

premisses are ∇▶ t ≈{A,A&} (a aj) tj ∧ ∇ ▶ a # tj and ∇▶ tj ≈{A,A&} (aj aj ) tj
∧ ∇ ▶

0	0
aj # tj , the IH is given as ∀(s ,s ,s ), |s1| < |t|∧ (∇▶ s1 ≈{A,A&} s2 ∧∇ ▶ s2 ≈{A,A&}
0	0	1 2 3
s3) ⇒ ∇ ▶ s1 ≈{A,A&} s3, and one should conclude that ∇ ▶ [a]t ≈{A,A&} [aj ]tj .
0 0
Applying [≈α-ab2] it remains to prove that ∇▶ a # tj and ∇▶ t ≈{A,A&} (a aj ) tj .
0	0	0
The former is obtained by freshness preservation, and the latter by IH with application
of Lem. 4.5, equivariance and freshness preservation.
For rules [equiv A] or [equiv AC], the following context is reached at some point of the formalisation, where for the case of [equiv A], i = i0 = 1: the premisses are

∇▶ t(1)
≈{A,A&} tj
∧∇ ▶ f E t[٨1]
≈{A,A&} f E tj
, and ∇▶ tj(1)
≈{A,A&}

ƒE	(i) E
k	k
k	ƒ E
k
k  [٨i] E	ƒ E
k	k

tj	∧∇ ▶ f E tj[٨1]
≈{A,A&} f E tj
, the IH is given by ∀(s ,s ,s ), |s1| <

0(i0)ƒ E
k
k	ƒ E
k
k  0[٨i0]ƒ E
k
1 2 3

|f E t|∧ (∇ ▶ s1 ≈{A,A&} s2 ∧∇ ▶ s2 ≈{A,A&} s3) ⇒ ∇ ▶ s1 ≈{A,A&} s3, and one
should conclude that ∇ ▶ f E t ≈{A,A&} f E tj . Applying [equiv A] and the IH
k	k  0
the case in which E = A is easily proved. When E = AC, one uses Lem. 4.9

and the second premise above, obtaining a third premise: ∃i1, ∇▶ tj(i)
k
≈{A,A&}

j
0(i1)ƒ E
k
∧∇ ▶ tj[٨i]
k
≈{A,A&} tj
ƒ E
k
. Then, applying [equiv AC] instantiated with

i1, the resulting subgoals are ∇▶ t(1) E
ƒk
≈{A,A&} tj
ƒ E
k
and ∇▶ f E t[٨1]
k
≈{A,A&}

f E tj
, and from the first and third premises above, both subgoals are solved.

k  0[٨i1]ƒ E
k
Lemma 4.11 (Symmetry of ≈{A,A&}) If ∇▶ t ≈{A,A&} tj then ∇▶ tj ≈{A,A&} t .
The formalisation is by induction on ≈{A,A&} applying lemmas 4.5, 4.8 and 4.10, freshness preservation and equivariance. In particular, the use of Lem. 4.10 is crucial: in the [≈α-ab2] case one should poof that ∇▶ [b]tj ≈{A,A&} [a]t having as hypotheses
∇▶ t ≈{A,A&} (a b) tj and ∇▶ a # tj, with IH ∇▶ (a b) tj ≈{A,A&} t. Then, Lem. 4.10 is applied twice instantiating t2 as (a, b) t and as (a b) (a b) tj, that allows the use of Lemmas 4.5 (with properties of ≈α) and equivariance to conclude.
To check ≈α,A and ≈α,A& one uses the following corollary. Remember that ≈α,A,
≈α,A& and ≈{A,A&} are specified as equiv({0}), equiv({1}) and equiv({0, 1}.
Corollary 4.12 For S ⊆ {0, 1}, equiv(S) is also an equivalence relation.
The formalisation is obtained by the manipulation of the superscritps in S—1 =
{0, 1}− S. For a general equivalence problem equiv(S)(∇, t1, t2), one replaces all superscripts of the operators in the terms t1 and t2 inside the set S—1 for new ones

that neither belong to {0, 1} nor occur in t1 and t2 obtaining respectivelly tj
and

tj . Then, by induction on the inference rules for equiv, one easily proves that
equiv(S)(∇, t1, t2) ⇔ equiv(S)(∇, tj , tj ) ⇔ equiv({0, 1})(∇, tj , tj ). Thus, using
1  2	1  2
that equiv({0, 1}) is an equivalence relation one concludes.

Algorithms for general ≈α,A, ≈α,AC , ≈{A,AC} problems
This section is concerned with checking the validity of α-equivalence constraints in the presence of A and AC symbols, by applying simplification rules.
For example, using the simplification rules given in [26], a constraint of the form [a]X ≈α [b]X reduces to the set of constraints a # X, b # X; therefore, a # X, b # X ▶ [a]X ≈α [b]X.  Similarly, assuming + is an AC function symbol, the equality
∇▶ +⟨s, +⟨t, [a]X⟩⟩ ≈α,A& +⟨+⟨[b]X, s⟩, t⟩ holds whenever the freshness constraints
a # X, b # X belong to ∇. Equational problems are written as pairs (∇,P ), where
∇ is a set of freshness constraints and P a set of equations.
The complexity of checking validity of α-equivalence constraints has been studied in [10], where an algorithm to test α-equivalence of nominal terms (both ground or non-ground), derived from a core algorithm to solve matching problems modulo α, is provided. The matching algorithm is linear in the size of the problem, when adopting “lazy permutations”, for the ground case (i.e., when matching a term s against a ground term t) and therefore α-equivalence is also linear in this case. If both terms are non-ground, then α-equivalence is log-linear in the size of the problem, whereas matching is log-linear if the pattern is linear and quadratic otherwise.
The mutually recursive functions Check and CheckAC (Algorithms 1 and 2) give the algorithm for checking α-equivalence of a problem (∇,P ) modulo A and AC.
Remark 5.1 Lines 10 to 14, regarding the application of the rule [≈α-ab2], have a secondary check for freshness constraints in a # tj. This requires an algorithm for validating freshness constraints based on simplification rules for freshness (Table 1 bottom up) which is linear in (∇,a # tj). To avoid repeatedly computations, (for instance the check for a # tj may appear several times in the computation) one could append valid freshness constraints in ∇, that is, line 12 becomes Check(∇∪ 
{a # tj}, {sj ≈{A,A&} (a b)tj}∪ Pj). Special care has to be taken with (a b) · tj (line 12, rule [≈α-ab2]), since it is not a term in our syntax, the permutation has to be propagated in tj and this introduces an aditional linear factor on the complexity of checking α-equivalence. However, adopting the approach in [10], where the syntax is enlarged with suspended permutations over terms and they are propagated in a “lazy” way, this linear factor is avoided obtaining a log-linear algorithm for α-equivalence.
Example 5.2 Assuming ∇ = {a # X, b #X} it follows that
(∇, {[a]g⟨a, X⟩ ≈α [b]g⟨b, X⟩}) =⇒Line 12 (∇, {g⟨a, X⟩ ≈α (a b)g⟨b, X⟩})
= (∇, {g⟨a, X⟩ ≈α g⟨a, (a b)X⟩}) =⇒Line 34 (∇, {⟨a, X⟩ ≈α ⟨a, (a b)X⟩})
=⇒Line 8 (∇, {a ≈α a, X ≈α (a b)X}) =⇒Line 6,16 (∇, ∅) =⇒T 
Algorithm 2 deals with equations headed by AC-function symbols. The call
CheckAC(∇,f ACsj ≈{A,A&} f ACtj, 1) in line 30 of Algorithm 1 will check equality
k	k
of the first argument on the left-hand side of the equation with the first, second,
third, etc. of the right-hand side until this check succeeds, and also check of the equality of the whole terms eliminating the first argument on the left-hand side and the respective ith argument of success on the right-hand side, otherwise the search



Algorithm 1 Checking for α-equivalence modulo A and AC
1: function Check(∇,P ) 2:	if P = ∅ then T
3:	else let s ≈{A,A&} t ∈ P and P ′ = P \ {s ≈{A,A&} t} in
4:	case s ≈{A,AC} t of
5:	(⟩ ≈{A,AC} (⟩ : Check(∇,P ′)	d rule [≈α-ut]
6:	a ≈{A,AC} a : Check(∇,P ′)	d rule [≈α-at]
7:	(s1, s2⟩ ≈{A,AC} (t1, t2⟩ :
8:	Check(∇, {s1 ≈{A,A&} t1, s2 ≈{A,A&} t2}∪ P ′)	d rule [≈α-pr]
9:	[a]s ≈{A,AC} [a]t : Check(∇, {s′ ≈{A,A&} t′}∪ P ′)	d rule [≈α-ab1] 10:	 [a]s ≈{A,AC} [b]t :
11:	if ∇▶ a # t′ then
12:		Check(∇, {s′ ≈{A,A&} (a b) · t′}∪ P ′)	d Remark 5.1 13:	else ⊥
14:	end if	d rule [≈α-ab2]
15:	π.X ≈{A,AC} π .X :
16:	if For all a ∈ ds(π, π′),a # X ∈∇ then Check(∇,P ′) 17:	else ⊥
18:	end if	d rule [≈α-su]
19:	f As ≈{A,AC} f At :
k	k
20:	let ns = ||s′||ƒ A and nt = ||t′||ƒ A in

k
21:	if ns /= nt then	⊥
22:	else
23:	if Check(∇, {(f As′)(1)
f k
k


≈{A,A&}(f At′)(1)
f k

}) then

24:	if ns =1 or Check(∇, {(f A s)[s1]
f k
25:	else ⊥
26:	end if
27:	else ⊥
28:	end if
29:	end if
30:	f ACs  ≈{A,AC} f ACt  :
≈{A,A&} (f A t)[s1]
f k
}) then Check(∇,P ′)

k	k
31:	if CheckAC(∇,f A& s′ ≈{A,A&} f A& t′, 1) then	Check(∇,P ′)
k	k
32:	else ⊥
33:	end if
34:	f Es ≈{A,AC} f Et : Check(∇, {s′ ≈{A,A&} t′}∪ P ′)	d rule [equiv Fc]
k	k
35:	 : ⊥	d otherwise
36:	end if
37: end function

continues recursively.

Algorithm 2 Checking α-equivalence modulo A and AC - AC-function symbol case
1: function CheckAC(∇,f A& s ≈{A,A&} f A& t, i)
k	k
2:	if ||s||ƒ AC /= ||t||ƒ AC then ⊥	d Check the length of the tuples
k	k
3:	else if not 1 ≤ i ≤ ||s|| AC then ⊥
k
4:	else	d apply rule [equiv AC]

5:	if Check(∇, {(f A& s)(1)

f AC k
≈{A,A&} (f A& t)(i)

f AC k
}) then

6:	if ||s||ƒ AC =1 or Check(∇, {(f A& s)[s1]
k
) ≈{A,A&} (f A& t)[si]
f k
)}) then T

7:	else CheckAC(∇,f A& s ≈{A,A&} f A& t, i + 1)
k	k
8:	end if
9:	else CheckAC(∇,f A& s ≈{A,A&} f A& t, i + 1)
k	k
10:	end if
11:	end if
12: end function


Example 5.3 Check(∅, {f AC([a]a, π · X) ≈{A,A&} f AC(πj · Y, [b]b)}) calls CheckAC,
k	k

which will proceed as follows:
CheckAC(∅,f AC⟨[a]a, π · X⟩ ≈{A,A&} f AC⟨πj · Y, [b]b⟩, 1)
k	k
=⇒Line 9 CheckAC(∅,f AC⟨[a]a, π · X⟩ ≈{A,A&} f AC⟨πj · Y, [b]b⟩, 2)
k	k
=⇒Line 6 Check(∅, {f AC π · X ≈{A,A&} f AC πj · Y }), since [a]a ≈{A,A&} [b]b
k	k
=⇒Line 31, Alg. 1 CheckAC(∅,f AC π · X ≈{A,A&} f AC πj · Y, 1)
k	k
=⇒Line 5 Check(∅, {π · X ≈{A,A&} πj · Y }) =⇒Line 35, Alg.1 ⊥
Theorem 5.4 Checking the validity of α-equivalence modulo A and AC of a problem of the form (∇,P )
can be done log-linearly in (∇,P ), whenever the problem does not include AC-function symbols;
	and has complexity bounded by the size (i.e., |(∇,P )| = |∇| + |P |, where |P | is the sum of the size of terms in equations in P and |∇| is the number of atoms and variables occurring in ∇) to the fourth, otherwise.
Proof. (sketch) To obtain these complexities we assume the use of suspended permutations over terms and of lazy propagation of permutations (see Remark 5.1).
For simplicity consider a problem of the form (∇, {s ≈{A,A&} t}) where s and t do not contain AC-function symbols. For all maximal subterms of s and t that are headed by A-function symbols one can linearly pre-compute their arguments. This can be done using sequences of arrays of terms in which arguments of A-functions are flattened. The lines 30 to 33 of the function Check, that correspond to the AC case, will never be executed since the input problem has not and will not generate other problems with AC symbols. The other lines correspond to the α-equivalence verifica- tion, except those lines for the case of A-function symbols: lines 19 to 29. For the A case, since arguments were pre-computed the problem can be directly decomposed, similarly to rule [≈-pr], into a new problem with ns new disjunct equational sub- problems, that is a problem of the form (∇,P ∪{f Asj ≈{A,A&} f Atj}) becomes directly

a problem of the form ∇,P ∪ {sj
k
≈{A,A&} tj
k
,..., sj
≈{A,A&} tj
}).

(1)ƒ A
k
(1)ƒ A
k
(ns)ƒ A
k
(ns)ƒ A
k

The analysis proceeds as for syntactic α-equivalence.
Let (∇, {s ≈{A,A&} t}) be a problem that contains AC-function symbols. As- suming the flat representation of all maximal subterms of s and t that are headed with AC-function symbols is pre-computed, lines 30-33 of Check, verify if for sub- terms sj and tj in s and t headed by an AC-function symbol, say f AC, the tuple of arguments in sj contains arguments that are related by α-equivalence modulo AC to arguments of the tuple of arguments in tj. These arguments are not necessarily in the same positions in the tuples of arguments of sj and tj. In the worst case
scenario, for each argument of the tuple of arguments regarding f AC in sj, say

sj
ƒ A&
k
, the procedure has to go over the whole tuple regarding f AC in tj, checking

(∇, {sj
ƒ A&
k
≈{A,A&} tj
(j)ƒ A&
k
}), for i, j ≤ ||sj|| A& . In case it is true, the algorithm
k

eliminates these two arguments, and repeats the procedure for the remaining argu-
ments of the tuples of arguments of sj and tj. For the steps of Check (except by

lines 30 - 33) one already knows that the procedure is log-linear on (∇,P ). The complexity of CheckAC essentially falls in the problem of searching a perfect matching in the bipartite graph that consists of vertices V labelled by the ns arguments of the left and the right-hand sides and edges, E, between vertices labelled with terms that match, as it was proved in [6], using the usual first-order syntax. This problem is known to have solutions of complexity O(|V | |E|), that is the same as O(|V |3) since in the worst case one has O(|V |2) edges [13]. One concludes that searching for a perfect matching is bounded cubically on the size of the problem, since the number of arguments, ||sj|| A& , is linearly bounded in size of the problem.	2
k
Note that the algorithm proposed can check validity of α-equivalence constraints modulo A and/or AC (≈{A,A&}) with multiple occurrences of function symbols, some that might be A and some AC, at once. This is due to the fact that different function symbols are not compared and also that distributive properties from one symbol to the other are not considered.
Conclusion and Future Work
The soundness of nominal α-equivalence and its extension to the equational theories A, AC and A + AC were formalised in Coq. The grammar of nominal terms was specified in such a way that in addition to A and AC rules one can easily add other inference rules to express properties such as idempotency (I), neutral (U) and inverse elements (Group theory), and their combinations A, AC, AI, ACI, ACU, ACUI, etc. Enriching nominal α-equality with equational theories formally, will provide an effective framework for dealing not only with nominal α-equivalence, but also with other related fundamental relations such as nominal uniﬁcation and narrowing in concrete applications. Examples of such applications can be found in several contexts such as the one of integrity of cryptography protocols [1,14,15]. A further interesting analysis would be the classification of the related “nominal α-unification modulo” problems regarding their unification type and complexities. In particular, a nominal
α-unification problem might give rise to infinite solutions.

References
	M. Ayala-Rinco´n, M. Ferna´ndez, and D. Nantes-Sobrinho. Nominal narrowing. In LIPIcs Proc. 1st Int. Conf. on Formal Structures for Computation and Deduction (FSCD), vol. 52, pages 11:1 –11:17, 2016.
	M. Ayala-Rinco´n, M. Ferna´ndez, and A. C. Rocha-oliveira. Completeness in PVS of a Nominal Unification Algorithm. In Logical and Semantic Frameworks with Appl. 2015 (LSFA), ENTCS 323:57-74, 2016.
	B. Aydemir, A. Bohannon, and S. Weirich. Nominal Reasoning Techniques in Coq. Electronic Notes in Theoretical Computer Science, 174(5):69–77, 2007.
F. Baader, W. Snyder, P. Narendran, M. Schmidt-Schauß, and K. U. Schulz. Unification Theory. Handbook of logic in artificial intelligence and logic programming, 2001.
H. Barendregt. The Lambda Calculus: Its Syntax and Semantics, revised ed., vol. 103 of Studies in Logic and the Foundations of Mathematics, 1984.
	D. Benanav, D. Kapur, and P. Narendran. Complexity of Matching Problems. J. Symb. Comput., 3(1/2):203–216, 1987.


	A. Boudet, E. Contejean, and H. Devie. A New AC Unification Algorithm with an Algorithm for Solving Systems of Diophantine Equations. Fifth Annual IEEE Symposium on Logic in Computer Science (LICS), pages 289–299, 1990.
	W. E. Byrd and D. P. Friedman. αKanren: A Fresh Name in Nominal Logic Programming. In Proc. of the Workshop on Scheme and Functional Programming, pages 79–90, 2007.
C. F. Calv`es and M. Fern´andez. Implementing Nominal Unification. ENTCS, 176(1):25–37, 2007.
	C. F. Calv`es and M. Fern´andez. Matching and alpha-equivalence check for nominal terms. Journal of Computer and System Sciences, 76(5):283 – 301, 2010.
J. Cheney. α Prolog Users Guide & Language Reference Version 0.3 DRAFT, 2003.
	E. Copello, A´ . Tasistro, N. Szasz, A. Bove, and M. Fern´andez. Principles of Alpha-Induction and Recursion for the Lambda Calculus in Constructive Type Theory. In Logical and Semantic Frameworks with Applications 2015 (LSFA), ENTCS 323:109-124, 2016.
T. H. Cormen, C. E. Leiserson, R. Rivest, and C. Stein. Introduction to Algorithms. MIT Press, 2009.
V. Cortier, S. Delaune, and P. Lafourcade. A survey of algebraic properties used in cryptographic protocols. Journal of Computer Security, 14(1):1–43, 2006.
S. Escobar, C. Meadows, and J. Meseguer. Maude-npa: Cryptographic protocol analysis modulo equational properties. Foundations of Security Analysis and Design V, FOSAD 2007/2008/2009, 5705:1–50, 2007.
M. Fernandez and M. J. Gabbay. Nominal rewriting. Information and Comp., 205(6):917–965, 2007.
M. Ferna´ndez and M. J. Gabbay. Closed nominal rewriting and efficiently computable nominal algebra equality. Elect. Proc. in Theoretical Computer Science, 34:37–51, 2010.
	M. Ferna´ndez, M. J. Gabbay, and I. Mackie. Nominal rewriting systems. Int. conference on Principles and practice of declarative programming, pages 108–119, 2004.
R. Kumar and M. Norrish. (Nominal) Unification by Recursive Descent with Triangular Substitutions.
Interactive Theorem Proving, pages 51–66, 2010.
	A. M. Pitts. Nominal Logic : A First Order Theory of Names and Binding. Int. Symposium on Theoretical Aspects of Computer Software, 2215:219–242, 2001.
	M. Schmidt-Schauß, T. Kutsia, J. Levy, and M. Villaret. Nominal Unification of Higher Order Expressions with Recursive Let. RISC Report Series TR no. 16-03, Research Institute for Symbolic Computation (RISC), Johannes Kepler University Linz, Austria, 2016.
M. R. Shinwell. The Fresh Approach: functional programming with names and binders. Technical report, University of Cambridge, 2005.
	M. R. Shinwell, A. M. Pitts, and M. J. Gabbay. FreshML: Programming with binders made simple. Int. Conference on Functional Programming, pages 263–274, 2003.
C. Urban. Nominal Techniques in Isabelle/HOL. Journal of Automated Reasoning, 40(4):327–356, 2008.
C. Urban. Nominal Unification Revisited. Int. Work. on Unification, pages 513–527, 2010.
	C. Urban, A. M. Pitts, and M. J. Gabbay. Nominal unification. Theoretical Computer Science, 323(1-3):473–497, 2004.
