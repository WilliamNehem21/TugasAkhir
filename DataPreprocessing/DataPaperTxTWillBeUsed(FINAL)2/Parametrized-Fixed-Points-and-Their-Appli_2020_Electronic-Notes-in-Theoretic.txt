Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 352 (2020) 149–172
www.elsevier.com/locate/entcs

Parametrized Fixed Points and Their Applications to Session Types
Ryan Kavanagh1
Computer Science Department Carnegie Mellon University
Pittsburgh, Pennsylvania, United States of America

Abstract
Parametrized fixed points are of particular interest to denotational semantics and are often given by “dagger operations” [10–12]. Dagger operations that satisfy the Conway identities [10] are particularly useful, because these identities imply a large class of identities used in semantic reasoning. We generalize existing techniques to define dagger operations on ω-categories and on O-categories. These operations enjoy a 2-categorical structure that implies the Conway identities. We illustrate these operators by considering applications to the semantics of session-typed languages.
Keywords: O-categories, ω-categories, fixed points, dagger operations, Conway identities.


Introduction
Recursive types are ubiquitous in functional languages. For example, in Standard ML we can define the type of (unary) natural numbers as:
datatype nat = Zero | Succ of nat
This declaration specifies that a nat is either zero or the successor of some natural number. Semantically, we can think of nat as a domain D satisfying the domain equation D ∼= (Zero : {⊥}) ] (Succ : D), where ] forms the labelled disjoint union of domains. Equivalently, we can think of D as a fixed point of the functor Fnat(X)= (Zero : {⊥}) ] (Succ : X) on a category of domains.
Mutually-recursive data types give rise to a similar interpretation. Consider, for example, the types of even and odd natural numbers:
datatype even = Zero | E of odd and odd	= O of even

1 Email: rkavanagh@cs.cmu.edu

https://doi.org/10.1016/j.entcs.2020.09.008
1571-0661/© 2020 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

This declaration specifies that an even number is either zero or the successor of an odd number, and that an odd number is the successor of an even one. The types even and odd respectively denote solutions De and Do to the system of domain equations:
De ∼= (Zero : {⊥}) ] (E : Do)	and	Do ∼= (O : De).
These are solutions to the system of equations:
Xe ∼= Feven(Xe, Xo)	(1)
Xo ∼= Fodd(Xe, Xo)	(2)
where Feven and Fodd are the functors Feven(Xe, Xo)= (Zero : {⊥}) ] (E : Xo) and Fodd(Xe, Xo) = (O : Xe). We can use Bekiˇc’s rule [4, § 2] to solve this system of equations. To do so, we think of eq. (1) as a family of equations parametrized by Xo. If we could solve for Xe, then we would get a parametrized family of solutions

†
even
(Xo) such that:


†
even


(Xo) ∼= Feven(F†

(Xo), Xo)	(3)

for all domains Xo. Substituting this for Xe in eq. (2) gives the domain equation


Xo ∼= Fodd(F†
(Xo), Xo).

Solving for Xo gives the solution Do. Substituting Do for Xo in eq. (3), we see that

De	even
(Do) is the other part of the solution.

The above example motivates techniques for solving parametrized domain equations. These are well understood. For example, given a suitable functor F : D × E → E on suitable categories of domains, [1, Proposition 5.2.7] gives a recipe for constructing a functor F† : D → E such that for all objects D of D, F†D ∼= F (D, F†D). Is the mapping F '→ F† functorial? Semantically, substitution is typically interpreted as composition [15, § 3.4]. If the interpretations of recursive types are to respect substitution, then the mapping F '→ F† must be natural in D. Is it? What other properties does it satisfy?
Families of parametric fixed points arise elsewhere in mathematics. An external dagger operation [12, Definition 2.6, 10, p. 7] on a cartesian closed category C is a family †A,B : C(A × B, B) → C(A, B) of set-theoretic functions for each pair of objects A and B in C. Of particular interest are dagger operations that satisfy the (cartesian) Conway identities. These identities imply many other identities [10, § 3.3] useful for semantic reasoning, such as Bekiˇc’s rule. They are also of independent interest. They axiomatize a decidable theory [9], and dagger operations that satisfy them are closely related to the trace operator [22, 20, Theorem 7.1, 5, p. 281]. Does the above dagger operation satisfy the Conway identities?
In this paper, we present dagger operators in two different categorical settings. In sections 3 to 5, we work with ω-cocontinuous functors between categories with sufficiently many ω-colimits. In section 6, we work with locally continuous functors between O-categories. O-categories [37] generalize categories of domains to provide

just the structure required to compute fixed points of functors. In both cases, these dagger operators will enjoy a 2-categorical structure that will imply the Conway identities. As an application, in section 7 we see that properties of our dagger operation are essential for defining and reasoning about semantics of session- typed languages with recursion. An extended version of this paper is available at https://arxiv.org/abs/2006.08479.

Background and Notation
We review some standard definitions and fix our notation. Our results use concepts from 2-category theory. Readers unfamiliar with 2-category theory may replace the words “2-category”, “2-functor”, and “2-natural transformation” by “category”, “functor”, and “natural transformation” throughout to obtain weaker forms of our results. Fiore [16, Chapter 2] and Kelly and Street [25] give surveys of 2-category theory.
A 2-category C has objects A, B, . . . , arrows (horizontal morphisms) f : A → B, and 2-cells (vertical morphisms) α : f ⇒ g : A → B drawn as:

f
A  ⇓α  B
g

Objects and arrows form a category C0 called the underlying category of C; we write ◦ for its composition. Each pair of objects A and B gives rise to a category C(A, B) whose objects are arrows A → B and whose morphisms are 2-cells between them; we call its composition operator “·” vertical composition. Objects and 2-cells form a category CellC; we call its composition operator “∗” horizontal composition. Vertical and horizontal composition satisfy the middle four interchange and identity laws: whenever

f	g
⇓α	⇓γ
A  B  C	and	A ⇓idf B ⇓idg C
⇓β	⇓δ
f	g

we have (δ · γ) ∗ (β · α)= (δ ∗ β) · (γ ∗ α) and idg ∗ idf = idg◦f , respectively. Thanks to the identity law, we can adopt the convention of writing f for the identity 2-cell idf : f ⇒ f : A → B.
The prototypical 2-category is Cat, the category of small categories, where objects are small categories, horizontal morphisms are functors, and vertical morphisms are natural transformations. Given 2-cells ϵ : F ⇒ G : C → D and η : H ⇒ I : D → E in Cat, their horizontal composition η ∗ ϵ : HF ⇒ IG is given by the equal natural transformations Iϵ ◦ ηF = ηG ◦ Hϵ. Given a morphism f : K → L in C, we abuse notation and write η ∗ f : FK → GL for the naturality square
Ff	ηL	ηK	Gf
FK −−→ FL −→ GL = FK −−→ GK −−→ GK.

Let C and D be 2-categories. A 2-functor F : C → D sends objects of C to objects of D, arrows of C to arrows of D, and 2-cells of C to 2-cells of D while preserving all identities, compositions, domains, and codomains. A 2-natural transformation η : F ⇒ G : C → D is a natural transformation η : F ⇒ G that is 2-natural, i.e., such that for each 2-cell α : f ⇒ g : A → B in C, we have the following equality in D:


Ff 
ηB
FA ⇓Fα FB 


ηA
GB = FA
Gf
GA ⇓Gα

GB.

	
Fg	Gg

A modification ρ : α → β : F ⇒ G : C → D is a morphism of 2-natural transfor- mations. It assigns to each object A of C a 2-cell ρA : αA ⇒ βA such that for all f : A → B we have the following equality in D:


αA
Gf
FA ⇓ρA GA

βA

Ff 
GB = FA 
αB

FB ⇓ρB
βB

GB.


Various constructions give new 2-categories from old. The dual 2-category Cop of a 2-category C is determined by Cop(A, B)= C(B, A), where arrows are reversed but not 2-cells between them. The product 2-category C × D is given by the usual product-category construction, where objects are pairs (C, D) of objects C of C and D of D, and all morphisms, compositions, and identities are given component-wise. Every 2-category C is equipped with a hom 2-functor C(−, −): Cop×C → CAT, where CAT is the 2-category of locally small categories. It takes objects (A, B) to categories C(A, B), arrows (f, g): (A, B) → (Aj, Bj) to functors g◦−◦f : C(A, B) → C(Aj, Bj), and 2-cells (α, β) : (f, g) ⇒ (fj, gj) : (A, B) → (Aj, Bj) to natural transformations α ∗ id— ∗ β : g ◦−◦ f ⇒ gj ◦−◦ fj : C(A, B) → C(Aj, Bj). If D is a locally small category, then we overload notation and write D(−, −): Dop ×D → Set for the hom functor. If a category E has an internal hom, then we write E[−→ −] or just [−→ −] for it. Given category C and D and an object D of D, let ΔD : C → D be the constant functor onto the object D. When C and D are the same small category, this action on objects induces the diagonal functor Δ: C → Cat[C → C]. A 2-category C is 2-cartesian closed if CellC is cartesian closed [12, p. 97].
In elementary terms [16, p. 24], this means that C has a terminal object, binary
2-products, and 2-exponentials, where
the terminal object of C is an object 1 of C with a 2-natural isomorphism
C(−, 1) ∼= Δ1, where 1 is the terminal category;
the 2-product of objects A and B of C is an object A × B of C with a 2-natural transformation C(−, A) × C(−, B) ∼= C(−,A × B);
	the 2-exponential of objects A and B of C is an object [A → B] of C with a 2-natural transformation C(−× A, B) ∼= C(−, [A → B]).

We write ⊥C or just ⊥ for the initial object of a category C. We also write ⊥
for the unique cone ⊥C ⇒ idC witnessing the initiality of ⊥C.
Let ω be the category with natural numbers as objects and with at most one arrow between each pair of objects, where n → m if and only if n ≤ m. An ω-chain in K is a diagram J : ω → K. An ω-category [26, Definition 5] is a category with all colimits of ω-diagrams. We warn the reader that the definition of ω-category varies in the literature. Some [28, Definition 2.4] additionally require the existence of an initial object; we call such categories IFP-categories. This name stems from the fact that IFP-categories have the structure required for ω-functors to have initial fixed points (see corollary 3.9 below). An ω-functor [28, Definition 2.5] is a functor that preserves all existing colimits of ω-diagrams. Small ω-categories and ω-functors between them form a 2-cartesian-closed subcategory ω-Cat of Cat. Small IFP-categories and ω-functors between them form a 2-cartesian-closed subcategory IFP of ω-Cat. A parameterized ω-functor is a functor F : C × D → E such that F (C, −): D → E is an ω-functor for all objects C of C.
Many categories of interest are not small, so they are not objects in Cat. We can work around this by using a hierarchy of universes [33, § 3] to treat them as small categories.
We frequently work with cocones, morphisms of cocones, and colimits. Given a small category J, a locally small category C, and a functor F : J → C, there exists [32, Definition 3.1.5] the cocone functor Cone(F, −) : C → Set take an objects C of C to the set of cocones on F with summit C. Given a morphism f : C → Cj and a cocone (λ : F ⇒ C) ∈ Cone(F, C), Cone(F, f )(λ)= f ◦ λ. Given a diagram F : J → C, the category of cocones on F is the category of elements
∫ Cone(F, −). Its objects are pairs (α, A) where α ∈ Cone(F, A). Morphisms
f : (α, A) → (β, B) are morphisms f : C → D in C such that Cone(F, f )(α)= β, i.e., such that f ◦ α = β. The colimit [32, Definition 3.1.6] of F is the initial object
of ∫ Cone(F, −).
Functoriality of Fixed Points
We show that constructing fixed points of ω-functors is itself a functorial operation. The initial fixed point of an ω-functor F on an ω-category is given by the colimit of the ω-chain ⊥→ F⊥→ F 2⊥→ · · · . Other fixed points can be constructed using a different “first link”, i.e., by taking the colimit of a chain K → FK → F 2K → ··· generated by a link k : K → FK.
Definition 3.1 Fix an ω-category K. Links form a category LinksK where
objects are triples (K, k, F ) called “links”, where K is an object of K, F : K → K
is an ω-functor, and k : K → FK is a morphism in K;
morphisms (K, k, F ) → (L, l, G) are pairs (f, η) where f : K → L is a morphism of K, η : F ⇒ G is a natural transformation, and f and η satisfy l ◦f = (η ∗f ) ◦k : K → GL;
composition is given component-wise: (g, ρ) ◦ (f, η)= (g ◦ f, ρ ◦ η).

The condition on morphisms between links provide the structure required to define morphisms between the ω-chains they generate. If K has an initial object ⊥, then the initial object in LinksK is the link (⊥, ⊥, Δ⊥). The category LinksK is ω-cocomplete, and the following proposition characterizes its ω-colimits:
(f0,η0)	(f1,η1)
Proposition 3.2 Let J = (K0, k0, F0) −−−−→ (K1, k1, F1) −−−−→ · · · be an ω-chain
f0	F1
in LinksK. Let (κ, K∞) be the colimit of the ω-chain K = K0 −→ K1 −→ · · · in K.
η0	η1
Let (φ, F∞) be the colimit of the ω-chain Φ= F0 −→ F1 −→ · · · in ω-Cat[K → K].
Then there exists a k∞ : K∞ → F∞K∞ such that (κ, φ) : J ⇒ (K∞, k∞, F∞) is colimiting in LinksK.
Proof (sketch). Let 2 be the category (• → •). We can recognize each link
kn
(Kn, kn, Fn) as a 2-diagram ΔKn ==⇒ Fn ◦ (ΔKn) in ω-Cat[K → K]. Then J
induces a diagram Jˆ : ω → Cat[2 → ω-Cat[K → K]]:


ΔK0
k0
F0 ◦ (ΔK0)
Δf0


η0∗(Δf0)
ΔK1
k1
F1 ◦ (ΔK1)
Δf1


η1∗(Δf1)
ΔK2
k2
F2 ◦ (ΔK2)
Δf2


η2∗(Δf2)
··· 

··· 

Colimits in functor categories are determined point-wise, so the top row has colimit (Δκ, ΔK∞). The bottom row has colimit (φ ∗ κ, F∞ ◦ (ΔK∞)) by [28, Lemma 4.3]. Let k = (kn : ΔKn → Fn ◦ (ΔKn)) be the natural transformation from the top row to the bottom row. Then ((φ ∗ κ) ◦ k, F∞ ◦ (ΔK∞)) is a cocone on the top row, so there exists a unique cocone morphism k∞ : (Δκ, ΔK∞) → ((φ∗κ) ◦k, F∞ ◦ (ΔK∞)). In particular, k∞ : ΔK∞ ⇒ F∞ ◦ (ΔK∞) is a natural transformation between two constant functors, so it is given by a single morphism K∞ → F∞K∞ in K. We conclude that (K∞, k∞, F∞) is an object of LinksK. A straightforward check shows that (κ, φ): J ⇒ (K∞, k∞, F∞) is colimiting in LinksK.	2
There exists a functor Ω : LinksK → [ω → K] that produces the ω-chain
k	Fk	2	F 2k
K −→ FK −−→ F K −−→ · · · from a link (K, k, F ). Its action on morphisms uses the
horizontal iteration of natural transformations. Consider functors H, G : C → C and a natural transformation η : H ⇒ G. We define the family of horizontal iterates η(i) : Hi ⇒ Gi, i ∈ N, by recursion on i. When i = 0, H0 = G0 = idC and we define η(0) to be the identity natural transformation on idC. Given η(i), we set η(i+1) = η ∗ η(i).
We define the functor Ω : LinksK → [ω → K]. The action of Ω(K, k, F ) on morphisms n → n + k is defined by induction on k.
Ω(K, k, F )(n)= FnK	(4)
Ω(K, k, F )(n → n)= idF nK	(5)
Ω(K, k, F )(n → n + k + 1) = Fn+kk ◦ Ω(K, k, F )(n → n + k)	(6)
Ω(f : K → L, η : F ⇒ G)n = η(n) ∗ f : FnK → GnL	(7)

Proposition 3.3 generalizes the functor S : [C → C] → [ω → C] of [29, § 3, 28, Lemma 4.2] to form chains with an arbitrary initial link in an ω-cocontinuous manner.
Proposition 3.3 Equations (4) to (7) deﬁne an ω-functor Ω : LinksK →
ω-Cat[ω → K].
General Fixed Points
We define a generalized-fixed-point ω-functor, i.e., an ω-functor GFIX : LinksK → K such that for each link (K, k, F ), there is an isomorphism GFIX(K, k, F ) ∼= F (GFIX(K, k, F )). We assume that whenever K is an ω-category, an ω-colimit has been chosen for each ω-chain. This choice determines an ω-colimit functor colimω : ω-Cat[ω → K] → K, itself an ω-functor. The following result generalizes [28, Theorem 4.1]:
Proposition 3.4 Let K be an ω-category. The following composition deﬁnes an
ω-functor:
GFIX = colimω ◦ Ω: LinksK → K.
We claim that the isomorphism GFIX(K, k, F ) ∼= F (GFIX(K, k, F )) is natural in the link (K, k, F ). To show this, we begin by defining an “unfolding” functor:
Proposition 3.5 Let K be an ω-category. The following deﬁnes an ω-functor
UNF : LinksK → K:
On objects: UNF(K, k, F )= F (GFIX(K, k, F )),
on morphisms: UNF(f, η)= η ∗ GFIX(f, η).
We now construct a natural isomorphism GFIX ∼= UNF. Each of its components is a mediating morphism of cocones induced by “shifting” the ω-chain the link generates. When J : ω → K, write ►J for the ω-chain induced by shifting J by one, i.e., by taking ►J(n)= J(n + 1). Observe that inclusion determines a natural transformation dJ : J ⇒ ►J, and every cocone (γ, G) on ►J induces a cocone (γ ◦ dJ , G) on J. Also observe that ►Ω(K, k, F ) = F Ω(K, k, F ). Building on these observations, we get the desired natural isomorphism:
Proposition 3.6 Let K be an ω-category. There exists a natural isomor- phism unfold : GFIX ⇒ UNF with inverse fold : UNF ⇒ GFIX. Where κ : Ω(K, k, F ) ⇒ GFIX(K, k, F )) is colimiting, the (K, k, F )-component of unfold is the unique morphism (κ, GFIX(K, k, F )) → (Fκ ◦ dΩ(K,k,F ),F (GFIX(K, k, F ))) in
Cone(Ω(K, k, F ), −).
Proof (sketch). Fix some arbitrary link (K, k, F ) and let unfold(K,k,F ) be as in the statement. Let κ+ be the restriction of κ to F Ω(K, k, F ), i.e., κ+ = κn+1. Because F is an ω-functor, Fκ : F Ω(K, k, F ) ⇒ F (GFIX(K, k, F )) is also colimiting. Let fold(K,k,F ) : (Fκ, F (GFIX(K, k, F ))) → (κ+, GFIX(K, k, F )) be given by initiality in Cone(F Ω(K, k, F ), −). To show that that fold(K,k,F ) ◦ unfold(K,k,F ) = idGFIX(K,k,F ), we observe that fold(K,k,F ) ◦ unfold(K,k,F ) is a cocone morphism (κ, GFIX(K, k, F )) →

(κ, GFIX(K, k, F )) in ∫ Cone(Ω(K, k, F ), −). The desired equality follows from the fact that (κ, GFIX(K, k, F )) is initial and that idGFIX(K,k,F ) is also such a cocone mor- phism. An analogous argument gives that unfold(K,k,F ) ◦ fold(K,k,F ) = idF (GFIX(K,k,F )). So unfold(K,k,F ) is an isomorphism for all (K, k, F ).
To see that unfold is natural, let (f, η) : (K, k, F ) → (L, l, G) be an arbitrary morphism of Linksk, and let (κ, GFIX(K, k, F )) and (λ, GFIX(L, l, G)) respectively be the colimiting cocones of Ω(K, k, F ) and Ω(L, l, G). Consider the following diagram in K:


Ω(K, k, F )
dΩ(K,k,F )
F Ω(K, k, F )


unfold(K,k,F )
GFIX(K, k, F )  F (GFIX(K, k, F ))

Ω(f,η)
GFIX(f,η)

unfold(L,l,G)
UNF(f,η)=η∗GFIX(f,η)
η∗Ω(f,η)


Ω(L, l, G)
GFIX(L, l, G)  G(GFIX(L, l, G))
dΩ(L,l,G)

GΩ(L, l, G)

Each of the trapezoids commutes, as does the outer perimeter. The inner rect- angle then describes two cocone morphisms (κ, GFIX(K, k, F )) → (Gλ ◦ dΩ(L,l,G) ◦ Ω(f, n), G(GFIX(L, l, G))) in Cone(Ω(K, k, F ), −). Because (κ, GFIX(K, k, F )) is
initial, these two cocone morphisms must be equal, i.e., the inner rectangle commutes. We conclude that unfold is natural.	2
Applications to semantics motivate functor algebras. Given a functor F : C → C, an F -algebra is a pair (A, a) where A and a are respectively an object and a morphism FA → A in C. A morphism f : (A, a) → (B, b) of F -algebras is a morphism f : A → B in C such that f ◦ a = b ◦ Ff . Such a morphism is called an F -algebra homomorphism. These objects and morphisms form a category CF of F -algebras.
We can specialize the above constructions to produce initial algebras. Indeed, given an IFP-category K, the category IFP[K → K] embeds fully and faithfully into LinksK via the functor that maps objects F : K → K to the link (⊥, ⊥,F ) and natural transformations η : F ⇒ G to the morphism (id⊥, η). We define the initial-fixed-point functor FIX : IFP[K → K] → K as the composition [K → K] ‹→
GFIX
−−−→ K. The following proposition is standard:
Proposition 3.7 ([28, Theorem 4.1]) The initial-ﬁxed-point functor FIX	:
IFP[K → K] → K is an ω-functor.
We use the close relationship between cocones and functor algebras to show that FIX does indeed produce initial fixed points. Write Fω : ω → K for Ω(⊥, ⊥,F ). The following proposition tells us that every F -algebra induces a cocone on Fω. This construction of cocones from algebras is not new, and it appears in the proofs of [37, Lemma 2, 2, Theorem 3.5]. However, to the best of our knowledge, the fact that this action on objects extends to a full and faithful functor, and the initiality result

are new. These facts will be used repeatedly in proofs below.
Proposition 3.8 Let K a category with an initial object, and let F : K → K
be a functor. The following deﬁnes a full and faithful functor ConeF : KF →
∫ Cone (Fω, −):
on objects: ConeF (A, a) = (α, A) where α : Fω ⇒ A is inductively deﬁned by
α0 = ⊥A and αn+1 = a ◦ Fαn
on morphisms: ConeF f = f.
If F is an ω-functor and K is an IFP-category, then ConeF FIX(F ), fold(⊥,⊥,F ) is initial.
Proof (sketch). An inductive argument shows ConeF (A, a) is a cocone, and it is easy to check that the action on morphisms defines a faithful functor. To see that it is full, let (A, a) and (B, b) be arbitrary F -algebras, and let f : ConeF (A, a) → ConeF (B, b) be arbitrary. We show that f : (A, a) → (B, b) is an F -algebra homomorphism, i.e., that f ◦ a = b ◦ Ff . Consider the following diagram:



FA 
F⊥A
Ff 

F⊥  FB 
F⊥B

a	⊥F⊥	b
A	B


The left and right squares commute by definition of ConeF (A, a) and ConeF (B, b). The bottom circular segment commutes by initiality, while the top circular segment commutes because functors preserve commuting diagrams. So the whole diagram commutes. We conclude that f : (A, a) → (B, b) is an F -algebra homomorphism and that ConeF is full. To show that ConeF FIX(F ), fold(⊥,⊥,F ) is initial, we show that it is a colimiting cocone. That it is colimiting follows by induction and the definition of fold(⊥,⊥,F ).	2
The following corollary is again standard, but its proof is new and its statement clarifies the nature of the mediating F-algebra homomorphism:
Corollary 3.9 ([37, Lemma 2, 2, Theorem 3.5]) Let K be an IFP-category. The initial algebra of an ω-functor F : K → K is (FIX(F ), fold(⊥,⊥,F )). Given any other F-algebra (A, a), the unique F-algebra homomorphism (FIX(F ), fold(⊥,⊥,F )) → (A, a) is the unique cocone morphism ConeF (FIX(F ), fold(⊥,⊥,F )) → ConeF (A, a).
Proof. The cocone ConeF (FIX(F ), fold(⊥,⊥,F )) is initial in ∫ Cone (Fω, −) by propo- sition 3.8. Recall that initial objects are given by the limit of the identity functor [32, Lemma 3.7.1], and that full and faithful functors reflect any limits that are present in its codomain [32, Lemma 3.3.5]. Because ConeF is full and faithful, it follows that FIX(F ), fold(⊥,⊥,F ) is initial and that the unique morphism is as described.2

2-Categorical Structure of Parametrized Fixed Points
In this section, we explore the 2-categorical properties of the parametrized-fixed- point functor given by Lehmann and Smyth [29, § 3]. This 2-categorical structure is, to the best of our knowledge, new. From these properties, we deduce that the parametrized-fixed-point functor defines a dagger operation that satisfies the Conway identities.
We begin by observing that their parametrized-fixed-point functor is a 2-natural transformation. This answers the first question of the introduction: the definition of (·)† : IFP[D × E → E] → IFP[D → E] is natural in D. In fact, naturality does not require D to be an ω-category. Given a category D and an IFP-category E, let Cat[D × E →ω E] be the category of parametrized ω-functors F : D × E → E, i.e., functors such that F (D, −): E → E is an ω-functor for all objects D of D.
Proposition 4.1 Let E an ω-category. The following family of functors forms a 2-natural transformation (·)† : Cat[−× E →ω E] ⇒ Cat[−→ E]: Catop → Cat:


(·)†
= Cat[idD → FIX] ◦ Λ: Cat[D × E →ω E] → Cat[D → E].

It restricts to a 2-natural transformation (·)† : IFP[−× E → E] ⇒ IFP[− → E]: 
IFPop → IFP.
Explicitly, given an F : D×E →ω E and an object D of D, F† D = FIX(F (D, −)). Proposition 4.1 implies that (·)† defines an external dagger operation on horizontal morphisms in IFP:
Definition 4.2 Let C be a cartesian category. An external dagger operation in product form [10, § 3.1, 12, Definition 2.6] is a family of set-theoretic functions † = (†A,B) indexed by pairs of objects A, B in C, where †A,B : C(A × B, A) → C(B, A) is a function of hom-sets. Given an external dagger operation †A,B : C(A × B, B) → C(A, B) and a morphism f : A × B → B, we write f† for †A,B(f ).
We will show that (·)† produces parametrized fixed points. To do so, we begin by defining a family of functors that gives their unrollings:
Proposition 4.3 Let E an ω-category. The following family of functors forms a 2- natural transformation UNR(·): Cat[−× E →ω E] ⇒ Cat[−→ E]: Catop → Cat, where D ranges over small categories:
UNRD(F )= F ◦ ⟨idD,F†⟩
UNRD(η)= η ∗ ⟨idD, η†⟩
It restricts to a 2-natural transformation UNR(·): IFP[−× E → E] ⇒ IFP[− → 
E] : IFPop → IFP.
We usually expect a dagger operations to satisfy the fixed-point identity [10, p. 7]. It states that f† = f ◦ ⟨idA,f†⟩ for all f : A × B → B, i.e., that a dagger operation gives parametrized fixed points. The fixed-point identity does not hold in general

for dagger operations on functors: F† and F ◦ ⟨id,F†⟩ need not be equal on the nose. However, it holds up to natural isomorphism, giving an analog of proposition 3.6 for solutions to parametrized equations. Proposition 4.4 gives a new 2-categorical formulation of the fixed-point identity. Not only do we have a natural isomorphism F† ∼= F ◦ ⟨id,F†⟩ for each F , but these natural isomorphisms assemble to form a modification, i.e., a morphism between the 2-natural transformations (·)† and UNR.
Proposition 4.4 (Fixed-Point Identity) Let E be an IFP-category. There is a modiﬁcation
Unfold : (·)† → UNR : Cat[−× E →ω E] ⇒ Cat[−→ E]: Catop → Cat
that is an isomorphism; we call its inverse Fold. For each category D, parametrized ω-functor F : D × E →ω E, and object D of D, the corresponding component is the isomorphism
(UnfoldF )D = unfold(⊥,⊥,F (D,—)) : F†D → F (D, F†D)
given by proposition 3.6. Unfold restricts to a modiﬁcative isomorphism (·)† → UNR :
IFP[−× E → E] ⇒ IFP[−→ E]: IFPop → IFP.
Proof (sketch). We must show that for each small category D, we have a 2-cell


UnfoldD : (·)†
⇒ UNRD : Cat[D × E →ω E] → Cat[D → E]

such that for all G : C → D, the two following 2-cells are equal:



Cat[D × E →ω E]
(·)†
⇓UnfoldD
UNRD

Cat[D → E]

Cat[G→E]

Cat[C → E],




Cat[D × E →ω E]

Cat[G×E→ω E]

Cat[C × E →ω E]
(·)†
⇓UnfoldC
UNRC

Cat[C → E].

It follows easily from proposition 3.6 that UnfoldD is a 2-cell. To see that it satisfies the desired equality, consider some arbitrary F : D × E →ω E and object C of C. Then the F, C-component of the top 2-cell is

 UnfoldF G 
= UnfoldF 
= unfold(⊥,⊥,F (GC,—))

= unfold(⊥,⊥,(F◦(G×idE
))(C,—)) =  UnfoldF◦(G×idE)  ,

which we recognize as the F, C-component of the bottom 2-cell. Because F , C, and G were chosen arbitrarily, we conclude the desired equality and that Unfold is a modification. It is clearly an isomorphism, and the restriction clearly has the desired properties.	2

Proposition 4.4 abstracts considerable information. We unpack its definitions to get several corollaries. The first corollary is a special case of [30, Theorem 4.4.8] when N and M are identity functors. It will be key to defining the interpretations of recursive session types in section 7.

Corollary 4.5 Let D be a small category. Then UnfoldF
and FoldF
are natural in

F, i.e., given any natural transformation η : F ⇒ G : D × E → E, the two following squares commute:


UnfoldF
F†
F ◦ ⟨id,F†⟩	F ◦ ⟨id,F†⟩
FoldF
 F†

η†
UnfoldG
η∗⟨id,η†⟩
η∗⟨id,η†⟩

η†
FoldG

G†	D
G ◦ ⟨id, G†⟩	G ◦ ⟨id, G†⟩
D	G†


Corollary 4.6 gives identities that will be useful in section 7. Equations (8) to (10) are immediate from the definitions of 2-natural transformation and proposition 4.1. Equations (11) and (12) are immediate from the definition of modification and proposition 4.4.
Corollary 4.6 (Parameter Identity) Let C and D be small categories and let E be an IFP-category. Let F, H : D × E → E be parametrized ω-functors and let G, I : C → D be functors. Set FG = F ◦ (G × idE): C × E → E, and analogously for HI. Let φ : F ⇒ H and γ : G ⇒ I be natural transformations. Then
F† = F† ◦ G : C → E,	(8)
FG ◦ ⟨idC,F† ⟩ = F ◦ ⟨idD,F†⟩◦ G : C → E,	(9)
(φ ∗ (γ × idE))† = φ† ∗ γ : F† ⇒ H†,	(10)
G	I
FoldFG = FoldF G : FG ◦ ⟨idC,F† ⟩⇒ F† ,	(11)
C	D	G	G
UnfoldFG = UnfoldF G : F† ⇒ FG ◦ ⟨idC,F† ⟩.	(12)
C	D	G	G
Proposition 4.7 generalizes corollary 3.9 to parametrized fixed points. Given a horizontal morphism f : A × B → B in a 2-cartesian category, an f -algebra [12, Definition 2.3] is a pair (g, u) where g : A → B is a horizontal morphism and u : f ∗ ⟨idA, g⟩ ⇒ g is vertical. An f -algebra homomorphism (g, u) → (h, v) is a vertical morphism w : g ⇒ h such that w · u = v · (f ∗ ⟨idA, w⟩). These f -algebras and f -algebra homomorphisms form a category. If we restrict our attention to the 2-cartesian category Cat, we get the parametrized F -algebras of [16, Definition 6.1.8]. By additionally requiring A = 1, we recover the usual notion of F -algebras.
Proposition 4.7 Let D be a category and E be an IFP-category. Let F : D × E →ω E be a parametrized ω-functor. The initial F-algebra is F†, FoldF . Given any other F-algebra (G, γ), the mediating morphism φ : F† → G is a natural transformation. The component φD is the unique F (D, −)-algebra homomorphism
 F†D, FoldF   → (GD, γD) given by corollary 3.9.

Proof (sketch). Let (G, γ) be an arbitrary F -algebra. We must show that φ : F† ⇒ G is natural and unique. We begin by naturality. Let f : A → B be arbitrary in D; we must show that Gf ◦φA = φB ◦F†f . Write FD for the partial application F (D, −). Let (νA, GA)= ConeFA (GA, γA) and (νB, GB)= ConeFB (GB, γB) be cocones on Fω and Fω, respectively, induced by proposition 3.8, and let α : Fω ⇒ F†A and
A	B	A
β : Fω → F†B be colimiting. By proposition 3.8, φA and φB are cocone morphisms
φA : (α, F†A) → (νA, GA) and φB : (β, F†B) → (νB, GB). Write Ff for the natural transformation ΛFf : FA ⇒ FB. We then have the following diagram in E:


F†A


φA
F†f


ω
ω	f	ω
A	B
F†B

φB

	
Gf
GA	GB.

The triangles and trapezoids all commute. It follows that φB ◦ F†f and Gf ◦ φA are both mediating morphisms from the cocone (α, F†A) to the cocone (νB ◦ Fω, GB).
Because (α, F†A) is initial, it follows that they are equal, i.e., that φ is natural. To see that φ is unique, observe that every F -algebra homomorphism ρ : F†, FoldF  →
†	F	D
for each object D of D. Because F†D, FoldF   is the initial FD-algebra, it follows
that ρD = φD and ρ = φ.	2
Proposition 4.7 presents the converse of a class of external daggers on horizontal morphisms considered in [12, § 2.2]. Given a horizontal morphism f : A × B → B in a 2-cartesian category, they define f† = g where (g, v) is the initial f -algebra. They do not consider the action of this dagger on vertical morphisms. In contrast, we gave a dagger operation that determines initial f -algebras. It induces an action on both horizontal and vertical morphisms. By proposition 4.4 and corollary 4.6, its action on vertical morphisms coheres with its action on horizontal morphisms.
Conway Identities
Semantics of programming languages should, ultimately, help users reason about programs. To this end, it is useful to have an arsenal of identities for the mathematical objects used to define the semantics. In our case, the semantics of recursive types motivated the definition of a dagger operation in section 4. In that section, we studied its 2-categorical properties. We now show how these 2-categorical properties imply a large class of identities useful for reasoning about recursive types. In particular, we show that they imply the Conway identities [10, 12] up to isomorphism. The Conway identities in turn imply a class of identities useful in the semantics of programming languages.
The Conway identities are also of independent interest. For example, the (carte-

sian) Conway identities together with an additional identity axiomatize the class of iteration theories [10, Remark 3.4]. Moreover, Hasegawa [20, Theorem 7.1] and Hyland independently discovered [5, p. 281] that a cartesian category has a trace operator [22] if and only if it has an external dagger operator satisfying the (cartesian) Conway identities.
We begin by presenting the Conway identities. The identities’ names vary in the literature. We give those of Bloom and E´sik [10, 12] and of Simpson and Plotkin [35, Definitions 2.2 and 2.4]. An external dagger † satisfies:
the parameter identity or naturality if for all f : B × C → C and g : A → B, (f ◦ (g × idC))† = f† ◦ g.
the composition identity or parametrized dinaturality if for all f : P ×A → B
and g : P × B → A, (g ◦ ⟨πP ×A,f⟩)† = g ◦ ⟨idP , (f ◦ ⟨πP ×B, g⟩)†⟩.
P	P
	the double dagger identity or diagonal property if for all f : A × B × B → B, (f†)† = (f ◦ (idA × ⟨idB, idB⟩))†.
the abstraction identity if the following diagram commutes:


[A × B × C → C]
†A×B,C
[idA×⟨πB,evB,C ⟩→idC ]
[A × [B → C] × B → C]
Λ

[A × B → C]
Λ	†A,[B→C]
[A → [B → C]]	[A × [B → C] → [B → C]]

the power identities if for all f : A × B → B and n > 1, (fn)† = f†, where
fn : A×B → B is inductively defined by f 0 = πA×B and fn+1 = f ◦⟨πA×B,fn⟩.
B	A
An external dagger satisfies the cartesian Conway identities if it satisfies proper- ties i to iii. It satisfies Conway identities if it additionally satisfies property iv. Theorem 5.1 answers the last question of section 1:
Theorem 5.1 The external dagger operation of proposition 4.1 satisﬁes the Conway identities and the power identities up to isomorphism.
Proof. The category IFP is 2-cartesian closed. By proposition 4.7, each ω-functor F : D × E → E in IFP has an initial F -algebra F†, FoldF . By corollary 4.6, these
D
†	F
algebra for each G : C → D. It then follows by [12, Theorem 7.1] that the external dagger operator induced by proposition 4.1 satisfies the Conway identities and the power identities up to isomorphism.	2
The Conway identities imply the pairing identity, sometimes called Bekiˇc’s identity [10, p. 10], which relates the two main approaches for solving systems of simultaneous equations. Consider such a system
B ∼= F (A, B, C)
C ∼= G(A, B, C).
We can solve it by pairing F and G, and solving the single equation (B, C) ∼=
⟨F, G⟩(A, B, C). Alternatively, we can use a Gaussian-elimination-style approach,

e.g., as we did in section 1 for the functors defining data types even and odd. The pairing identity tells us that these two approaches yield isomorphic solutions:
Corollary 5.2 (Pairing Identity) Let A, B, and C be small IFP-categories, and let F : A × B × C → B and G : A × B × C → C be ω-functors. Set
⟨idA,G†⟩	F
H = A × B −−−−−→ A × B × C −→ B. Then
⟨F, G⟩† ∼= ⟨G† ◦ ⟨idA,H†⟩,H†⟩ : A → B × C.

The Conway identities also imply the left zero identity [10, p. 10]. Semantically, it describes the interplay between weakening and the formation of recursive types.
Corollary 5.3 (Left Zero Identity) Let A and B be small IFP-categories, and let F : B → A be an ω-functor. Then


πB	F
 † ∼	F


Canonical and Parametrized Fixed Points for O- Categories
In this section, we consider an order-theoretic of variation sections 3 and 4. We do so in the setting of O-categories and locally continuous functors, which generalize categories of domains to provide just the amount of order-theoretic structure required for taking fixed points of functors. O-categories are more concrete than ω-categories, and their order-theoretic characterization of ω-colimits and of ω-functors is useful in applications. They also have enough structure to have canonical fixed points.
Background on O-categories
We refer the reader to [1, 19, Chapter 10, 37] for additional background on O- categories and domain theory.
We write ↑A for the directed supremum of a directed set A. If C has a terminal object isomorphic to its initial object, we call the initial object the zero object 0C. C has zero morphisms if for all objects A and D there exists a fixed morphism 0AD : A → D, and if this family of morphisms satisfies 0BD ◦ f = 0AD = g ◦ 0AC for all morphisms f : A → B and g : C → D. C has zero morphisms whenever it has a zero object: 0AB = A → 0 → B.
An O-category [37, Definition 5] is a category K where every hom-set K(C, D) is a dcpo, and where composition of morphisms is continuous with respect to the partial ordering on morphisms. A functor F : D → E between O-categories is locally continuous if the maps f '→ F (f ): D(D1, D2) → E(F (D1),F (D2)) are continuous for all objects D1, D2 of D. Small O-categories form a 2-cartesian closed category O, where horizontal morphisms are locally continuous functors and vertical morphisms are natural transformations. Examples of O-categories include DCPO and functor categories Cat[C → D] whenever D is an O-category.

An embedding-projection pair (e-p-pair) [37, Definition 6] (e, p) is a pair of morphisms e : D → E and p : E → D such that p ◦ e = idD and e ◦ p ± idE. We call e an embedding and p a projection. Given an embedding e : D → E, we write ep : E → D for its associated projection. Given a projection p : E → D, we write pe : D → E for its associated embedding. When K is an O-category, we write Ke for the subcategory of K whose morphisms are embeddings. The category Ke is not in general an O-category under the induced ordering [37, p. 768].
A cocone κ : J ⇒ A in Ke is an O-colimit [37, Definition 7] if (κn ◦ κp ) is
an ascending chain in K(A, A) and .↑	κn ◦ κp = idA. K is O-cocomplete if
every ω-chain in Ke has an O-colimit in K. Our interest in O-colimits is due to proposition 6.1, which appears as [37, Propositions A and D] and as part of the proof of [37, Proposition A]. Parts can also be found in the proof of [19, Theorem 10.4] or specialized to DCPO as [1, Theorem 3.3.7]. This result gives us an explicit characterization of colimits in O-categories.
Proposition 6.1 ([37, Propositions A and D]) Let K be an O-category, Φ an
ω-chain in Ke, and α :Φ ⇒ A a cocone in K.

If β : Φ ⇒ B is a cocone in Ke, then (αn
p
n n∈N
is an ascending chain in

K(B, A) and the morphism θ = .↑	αn ◦ βp is mediating from β to α.
If β :Φ ⇒ B is an O-colimit, then θ is an embedding.
If α is an O-colimit, then α is colimiting in both K and Ke.
If α is colimiting in K, then α lies in Ke and is an O-colimit.
The concept of O-colimit dualizes to give O-limits, and proposition 6.1 dualizes to give the corresponding result for projections, cones, limits, and O-limits.
Local Continuity and ω-Continuity
Locally continuous functors preserve O-colimits. Every locally continuous functor F : D → E restricts to a functor Fe : De → Ee [37, Lemma 4]. When D is O-cocomplete, Fe is an ω-functor [37, Theorem 3] and De is an ω-category by proposition 6.1. These observations raise the question: why not use LinksKe and the results of sections 3 and 4 to study fixed points of locally continuous functors? The reason is that such an approach does not handle all natural transformations between locally continuous functors, but only for those between functors on Ke. This is because natural transformations η : F ⇒ G do not in general restrict to natural transformations Fe ⇒ Ge. By adapting the techniques of the previous sections to O-categories and locally continuous functors, we get fixed-point operators defined on all natural transformations between locally continuous functors. The fixed-point
operators are also themselves locally continuous.
Canonical Fixed Points
By slightly modifying our category of links, we can construct canonical fixed points. Given a functor F : K → K, we say that a fixed point f : FX ∼= X is canonical

if (X, f ) is an initial F -algebra and (X, f—1) is a terminal F -coalgebra. Given an
O-category K, let OLinksK be the category where
objects are triples (K, k, F ) called “links”, where K is an object of K, F : K → K
is locally continuous, and k : K → FK is an embedding;
morphisms and composition are defined as before.
Proposition 6.2 Equations (4) to (7) deﬁne a locally continuous functor Ω : OLinksK → O[ω → K]. For all links (K, k, F ), Ω(K, k, F ) : ω → Ke. The natural transformation Ω(f, η) lies in Ke whenever f and η do.
Let O[ω → Ke ‹→ K] be the subcategory of O[ω → K] whose objects are functors ω → Ke and whose morphisms are natural transformations in K. It is an O-category.
Proposition 6.3 Let K be an O-cocomplete O-category. A choice of O-colimit in K for each diagram ω → Ke ‹→ K deﬁnes the action on objects of a locally continuous functor colimω : [ω → Ke ‹→ K] → K.
Proof (sketch). The action of colimω on morphisms follows immediately from proposition 6.1. Indeed, where φ : Φ ⇒ colimω Φ and γ : Γ ⇒ colimω Γ are the chosen O-colimits in K, a natural transformation η : Φ ⇒ Γ induces a cocone γ ◦ η :Φ ⇒ colimω Γ. By proposition 6.1, the unique mediating morphism of cocones is then:
colimω(η :Φ ⇒ Γ) = .↑γn ◦ ηn ◦ φp .
n∈N
This action on morphisms is easily seen to be locally continuous.	2
Proposition 6.4 Let K be an O-cocomplete O-category. The functor GFIX = colimω ◦ Ω: OLinksK → K is locally continuous and its image lies in Ke.
The recipe given by proposition 3.5 gives a locally continuous functor UNF : OLinksK → K whose image lies in Ke. These functors GFIX and UNF are related by the same natural isomorphism as proposition 3.6.
We say that an O-category K has strict morphisms if it has zero morphisms and 0AB is the least element of K(A, B) for all objects A and B. We say that K supports canonical fixed points if it has an initial object, strict morphisms, and is O-cocomplete. Let CFP be the full subcategory of O whose objects are O-categories that support canonical fixed points. It is 2-cartesian closed [16, Theorem 7.3.11].
Assume K supports canonical fixed points. Then ⊥ is also the initial object of Ke, and we can fully and faithfully embed O[K → K] into LinksK using the same approach as before. This embedding is locally continuous. We define the locally continuous canonical-fixed-point functor CFIX : CFP[K → K] → K as the
GFIX
−−−→ K. The following result is standard:
Proposition 6.5 If K supports canonical ﬁxed points and F is a locally continuous functor on K, then fold : F (CFIX(F )) → FIX(F ) is a canonical ﬁxed point.

We can mimic the results of sections 4 and 5, generally replacing FIX by CFIX, ω-Cat by O, IFP by CFP, and ω-functor by locally continuous functor. In particular, the parametrized fixed point functor (·)† is locally continuous and again satisfies the Conway identities up to isomorphism. It also produces canonical parametrized families of fixed points:
Proposition 6.6 Let D and E be O-categories, and assume E supports canonical ﬁxed points. Let F : D × E → E be a locally continuous functor. Then (F†, Fold) and (F†, Unfold) are respectively the initial F-algebra and terminal F-coalgebra.
Given any other F-algebra (G, γ), the mediating morphism φ : F† → G is a natural family of embeddings. The component φD is the unique FD-algebra homomorphism (F†D, FoldD) → (GD, γD).
	Given any other F-coalgebra (Γ, γ), the mediating morphism ρ :Γ → F† is a natural family of projections. The component ρD is the unique FD-coalgebra homomorphism (GD, γD) → (F†D, UnfoldD).

Applications to Semantics of Session Types
We illustrate our results by applying them to denotational semantics for session-typed languages. In particular, we show that they are essential both for defining and for reasoning about the denotations of recursive session types. Session types specify communication protocols between processes. We consider the restricted setting of two processes S (the server) and C (the client). They independently perform computation and communicate with each other over a wire c (a channel). This bidirectional communication on c satisfies a protocol specified by a session type A that evolves over the course of execution. We can think of S as a function from its input on c to its output on c, and of C as a function from its input on c to its output on c. To do so, we imagine c as a pair (c—, c+) of wires carrying unidirectional communications: a wire c— that carries communications from C to S, and a wire c+
c+
that carries communication from S to C. This gives rise to the picture S	C.
c−
We interpret a session type A as a Scott domain JA) whose elements are the bidirectional communications permitted by the protocol A. To interpret the picture, we decompose JA) into a pair of Scott domains JA)— and JA)+. The domain JA)+ contains the left-to-right unidirectional communications on c+ that A permits, and symmetrically for JA)—. We then interpret S and C as continuous functions JS) : JA)— → JA)+ and JC) : JA)+ → JA)—. We can think of this interpretation as a generalization of Kahn’s stream-based semantics for deterministic networks [23] to allow for bidirectional, session-typed communication channels. The details of process interpretations are beyond the scope of this paper and can be found in [24]. However, these process interpretations ensure that channels are used linearly: channels cannot be duplicated or discarded. In the more general setting of [24], processes can also communicate over multiple channels.
The decomposition of JA) into JA)— × JA)+ introduces “semantic junk”. Indeed,

JA)— × JA)+ contains pairs (a—, a+) of unidirectional communications that do not correspond to bidirectional communications a ∈ JA). We use an embedding Q A ¢ : JA) → JA)— × JA)+ to pick out the pairs (a—, a+) that correspond to genuine bidirectional communications.
We illustrate this semantic approach by giving interpretations to recursive session types. Though we only consider recursive session types here, we note that this approach works for a rich class of session types, including internal choice (A ⊕ B), external choice (A & B), channel transmission (A⊗ B and A  B), synchronization (↑ A and ↓ B), etc.
Assume that recursive session types ρα.A are formed using the following rules. The judgment Ξ ▶ A means that A is a session type in the presence type variables Ξ= α1,..., αn (n ≥ 0).




Ξ,α ▶ α
(CVar)	Ξ,α ▶ A
Ξ ▶ ρα.A
(Cρ)

To handle open types, we generalize from triples of domains and a single embed- ding to a 2-cell whose components are embeddings. Let M be the O-category of Scott domains where morphisms are strict continuous meet-preserving functions. It sup-
ports canonical fixed points. Let Jα1,..., αn) be the category  n	M. Then Ξ ▶ A
denotes a 2-cell ⟨Q Ξ ▶ A ¢—, Q Ξ ▶ A ¢+⟩ : JΞ ▶ A) ⇒ JΞ ▶ A)—×JΞ ▶ A)+ : JΞ) → M in CFP where each component of the natural transformation ⟨Q Ξ ▶ A ¢—, Q Ξ ▶ A ¢+⟩ is an embedding in M. The interpretation of Ξ ▶ A is defined by induction on its derivation. We note that all session types, including A  B, are interpreted using covariant functors. This is in contrast to what happens with computational interpretations of linear logic, where A  B denotes a bifunctor that is contravariant in one component. The difference in variance stems from the fact that closed session types denote domains of communications instead of domains of values.
The functors interpreting (CVar) are projection of the α component:

JΞ,α ▶ α) = JΞ,α ▶ α)— = JΞ,α ▶ α)+ = πn+1,	Q Ξ,α ▶ α ¢— = Q Ξ,α ▶ α ¢+ = id.

The functors interpreting Ξ ▶ ρα.A are defined using the dagger operation of section 6. We cannot simply apply the dagger operation to the interpretation of the premise Ξ,α ▶ A. Doing so would give a 2-cell with the wrong codomain: its codomain would be JΞ,α ▶ A)— × JΞ,α ▶ A)+ †, and it is not true general that (F × G)† ∼= F† × G†. Instead, set

JΞ ▶ ρα.A) = JΞ,α ▶ A)† ,	JΞ ▶ ρα.A)p = (JΞ,α ▶ A)p)† (p ∈ {−, +}).

Abbreviate Ξ ▶ ρα.A by ▶ ρα.A and Ξ,α ▶ A by α ▶ A. Instantiating η in the right diagram of corollary 4.5 by Q α ▶ A ¢p for p ∈ {−, +} and expanding the definition

of the horizontal composition η ∗ ⟨id, η†⟩ gives:


Jα ▶ A) ◦ ⟨idJΞ), J▶ ρα.A)⟩
Jα▶A)⟨id,(Q α▶A ¢p)†⟩
Jα ▶ A) ◦ ⟨idJΞ), J▶ ρα.A)p⟩
FoldJα▶A)




FoldJ▶ρα.A)p ◦Q α▶A ¢p⟨id,J▶ρα.A)p⟩
J▶ ρα.A)
(Q α▶A ¢p)†
J▶ ρα.A)p


The category of Jα ▶ A)-algebras has products, so there exists a mediating morphism
⟨(Q α ▶ A ¢—)†, (Q α ▶ A ¢+)†⟩ : J▶ ρα.A) ⇒ J▶ ρα.A)— × J▶ ρα.A)+ .
It is a natural family of embeddings by proposition 6.6, so we define:
Q ▶ ρα.A ¢ = ⟨(Q α ▶ A ¢—)†, (Q α ▶ A ¢+)†⟩.
The parameter identity implies that these denotations respect substitution (cf. [24, Proposition 41]):
Proposition 7.1 Let Ξ= α1,..., αn. If Ξ ▶ A and Θ ▶ Bi for 1 ≤ i ≤ n, then for
p ∈ {−, +},
Q Θ ▶ [B/α]A ¢p = Q Ξ ▶ A ¢p ∗ ⟨Q Θ ▶ Ai ¢p⟩1≤i≤n.
Proof (sketch). By induction on the derivation Ξ ▶ A. The variable case is clear. Consider the case where Ξ ▶ ραn+1.A is formed by (Cρ). Let Bn+1 = αn+1, so Θ, αn+1 ▶ αn+1 by (CVar). By the induction hypothesis, Q Θ, αn+1 ▶ [B, αn+1/α, αn+1]A ¢p = Q Ξ, αn+1 ▶ A ¢p ∗ ⟨Q Θ, αn+1 ▶ Bi ¢p⟩1≤i≤n+1. By a weaken- ing lemma, Q Θ, αn+1 ▶ Bi ¢p = Q Θ ▶ Bi ¢pπΘ for 1 ≤ i ≤ n. By a property of prod- ucts, it follows that Q Θ, αn+1 ▶ [B, αn+1/α, αn+1]A ¢p = Q Ξ, αn+1 ▶ A ¢p ∗ (⟨Q Θ ▶ Bi ¢p⟩1≤i≤n × id). By the parameter identity and the interpretation of (Cρ), we conclude that Q Θ ▶ [B/α]ραn+1.A ¢p = Q Ξ ▶ ραn+1.A ¢p ∗ ⟨Q Θ ▶ Bi ¢p⟩1≤i≤n.   2
Propositions 4.4 and 7.1 and corollary 4.6 imply that the above denotations respect syntactic folding and unfolding of recursive up-to-isomorphism, e.g.,
JΞ ▶ ρα.A) ∼= JΞ,α ▶ A) ◦ ⟨idJΞ), JΞ ▶ ρα.A)⟩ = JΞ ▶ [ρα.A/α]A) .

Related Work
Scott [34] introduced inverse limit constructions to construct fixed points of functors. In particular, Scott used an inverse limit of a chain of projections to construct a continuous lattice D ∼= [D → D]. Until this point, the only tools for constructing fixed points were variations on Tarski’s least fixed-point theorem [27, p. 9]. Lehmann
[27] generalized these ideas to find fixed points of ω-cocontinuous functors on ω- cocomplete categories. These ideas were further explored by Lehmann and Smyth [28, 29] to give semantics to data types. We built on these ideas to define a general fixed-point functor GFIX. Using GFIX, we were able to show that a functor’s fixed

points assemble into a natural isomorphism. Their fixed-point functor is exactly FIX, while their parametrized fixed-point functor is our (·)†.
Wand [40] introduced the definitions of O-categories and locally continuous functors. Smyth and Plotkin [36, 37] introduced O-(co)limits and generalized Scott’s limit-colimit coincidence theorem to O-categories. O-categories generalize categories of domains to provide just the structure required to solve recursive domain equations in a categorical setting. Smyth and Plotkin’s “basic lemma” [37, Lemma 2] gives a recipe for constructing fixed points of covariant locally continuous functors on O-categories.
Some took the existence of fixed points of functors as their starting point. Freyd
[17] studied algebraically complete categories, that is, categories C where every covariant functor T : C → C has a an initial T -algebras. Freyd also studied properties of functors on algebraically complete categories. Freyd [18] extended this analysis to algebraically compact categories, i.e., algebraically complete categories where initial algebra and terminal co-algebras are canonically isomorphic.
Fiore [16] investigated axiomatic categorical domain theory for application to the denotational semantics of deterministic programming languages. In chapter 6, Fiore used initiality to define a dagger operation on functors between certain algebraically complete O-categories. Under certain conditions, this dagger operation is functorial. It satisfies the parameter identity on functors, i.e., it satisfies eq. (8) above. Our category CFP appears as the category Kind [16, Definition 7.3.11].
Dagger operation and the Conway identities arose in a separate line of research. Iteration theories [11] were introduced to study the syntax and semantics of flowchart algorithms, and they are defined in terms of a dagger operation. Bloom and E´sik [10] studied external dagger operations on cartesian closed categories and showed that
for many of the categories used in semantics, the least fixed point operator induces a dagger operation satisfying the Conway identities. They generalized this work to 2-cartesian closed categories in [12] and gave sufficient conditions for a dagger on horizontal morphisms to satisfy the Conway identities. They did not explore the 2-cartesian structure of daggers or the action of daggers on vertical morphisms.
Simpson and Plotkin [35] gave an axiomatic treatment of dagger operations satisfying Conway identities. They gave a purely syntactic account of free iteration theories. They give a precise characterization of the circumstances in which the iteration theory axioms are complete for categories with an iteration operator.
Honda [21] and Takeuchi, Honda, and Kubo [38] introduced session types to describe sessions of interaction. Caires and Pfenning [13] observed a proofs-as- programs correspondence between the session-typed π-calculus and intuitionistic linear logic. Wadler [39] built on this correspondence to give “Classical Processes” (CP), a proofs-as-programs interpretation of classical linear logic. These proofs-as- programs correspondences have several denotational semantics. For example, Atkey
[3] gave a denotational semantics for CP, where types are interpreted as sets and processes are interpreted as relations over these. Castellan and Yoshida [14] gave a game semantics interpretation of the session π-calculus with recursion. Kavanagh
[24] gave the first denotational semantics for a full-featured, functional language

with session-typed concurrency and general recursion.
Linear logic enjoys other proofs-as-programs interpretations. Benton [7, 8] introduced the LNL calculus, a mixed linear and non-linear calculus. It is interpreted by an “LNL” or “adjoint” model: a symmetric monoidal closed category and a cartesian closed category related by a pair of adjoint functors. Benton and Wadler
[6] used this model to relate translation of the λ-calculus in Moggi’s computational metalanguage [31] and translations of intuitionistic logic into intuitionistic linear logic. Lindenhovius, Mislove, and Zamdzhiev [30] introduced the “linear/non-linear fixpoint calculus” (LNL-FPC), a type system with mixed linear and non-linear recursive types. They use the dagger operator of [28] to model arbitrary recursive types in a linear category and non-linear recursive types in a cartesian category. These two interpretations are strongly related by suitable mediating functors and natural isomorphisms, which allow them to define substructural operations on non-linear types. To give fixed points to contravariant functors, they used standard order- theoretic techniques [28, Theorem 3] to reduce contravariant functors to covariant functors.
Conclusion and Acknowledgments
We gave a generalized-fixed-point functor and a functorial dagger operation on ω-categories. We explored the 2-categorical structure of the dagger operation, and showed how the Conway identities follow from this 2-categorical structure. We showed that these constructions also hold for O-categories, and we explored their order-theoretic properties. In section 7, we saw that the Conway identities and the dagger operation’s order-theoretic properties were essential for defining the semantics of recursive session types.
The presentation of these results has changed considerably since the conference. The original version frequently relied on order-theoretic reasoning in O-categories to establish results. MFPS attendees, Vladimir Zamdzhiev in particular, suggested that it might be possible to generalize from locally continuous functors on O-categories to ω-functors on ω-categories. Doing so greatly elucidated our results, and we are grateful to the attendees for their helpful comments and suggestions.
This work is funded in part by a Natural Sciences and Engineering Research Council of Canada Postgraduate Scholarship. The author thanks Stephen Brookes, Frank Pfenning, Vladimir Zamdzhiev, the anonymous reviewers, and MFPS attendees for their helpful comments.
References
	Abramsky, Samson and Achim Jung. “Domain Theory”. In: Handbook of Logic in Computer Science. Vol. 3: Semantic Structures. Ed. by S. Abramsky, Dov M. Gabbay, and T. S. E. Maibaum. 5 vols. Oxford University Press Inc., New York, June 15, 1995, pp. 1–168. isbn: 0-19-853762-X.
	Ada´mek, Jiˇr´ı, Stefan Milius, and Lawrence S. Moss. “Fixed Points of Functors”. Journal of Logical and Algebraic Methods in Programming 95 (2018), pp. 41–81. issn: 2352-2208. doi: 10.1016/j.jlamp.
2017.11.003.

	Atkey, Robert. “Observed Communication Semantics for Classical Processes”. In: Programming Languages and Systems. 26th European Symposium on Programming. ESOP 2017 (Uppsala, Sweden, Apr. 22–29, 2017). Ed. by Hongseok Yang. Lecture Notes in Computer Science 10201. Springer Berlin Heidelberg, Berlin, 2017, pp. 56–82. isbn: 978-3-662-54434-1. doi: 10.1007/978-3-662-54434-1.
	Beki´c, Hans. “Definable Operations in General Algebras, and the Theory of Automata and Flowcharts”. In: Bekiˇc, Hans. Programming Languages and Their Definition. Selected Papers. Ed. by C. B. Jones. With an intro. by Cliff B. Jones. Lecture Notes in Computer Science 177. Springer-Verlag Berlin Heidelberg, 1984, pp. 30–55. isbn: 978-3-540-38933-0. doi: 10.1007/bfb0048939.
	Benton, Nick and Martin Hyland. “Traced Premonoidal Categories”. RAIRO - Theoretical Informatics and Applications 37 (2003), pp. 273–299. issn: 1290-385X. doi: 10.1051/ita:2003020.
	Benton, Nick and Philip Wadler. “Linear Logic, Monads and the Lambda Calculus”. In: Proceedings. 11th Annual IEEE Symposium on Logic in Computer Science. LICS’96 (New Brunswick, New Jersey, July 27–30, 1996). IEEE Computer Society Technical Committee on Mathematical Foundations of Computing. IEEE Computer Society Press, Los Alamitos, California, 1996, pp. 420–431. isbn: 0-8186-7463-6. doi: 10.1109/LICS.1996.561458.
	Benton, P. N. A Mixed Linear and Non-Linear Logic: Proofs, Terms and Models. Preliminary Report. Tech. rep. UCAM-CL-TR-352. Cambridge, United Kingdom: Computer Laboratory, University of Cambridge, Oct. 1994. 65 pp.
	Benton, P. N. “A Mixed Linear and Non-Linear Logic: Proofs, Terms and Models”. Extended Abstract. In: Computer Science Logic. 8th Workshop, CSL ’94. Annual Conference of the European Association for Computer Science Logic, CSL ’94 (Kazimierz, Poland, Sept. 25–30, 1994). Ed. by Leszek Pacholski and Jerzy Tiuryn. Lecture Notes in Computer Science 933. Springer-Verlag Berlin Heidelberg, 1995, pp. 121–135. isbn: 978-3-540-49404-1. doi: 10.1007/BFb0022251.
Bern´atsky, L. and Z. E´sik. “Semantics of Flowchart Programs and the Free Conway Theories”.
Informatique th´eorique et Applications / Theoretical Informatics and Applications 32 (1998), pp. 35–
78. issn: 0988-5004.
	Bloom, Stephen L. and Zolta´n E´sik. “Fixed-Point Operations on ccc’s. Part I”. Theoretical Computer Science 155 (1996), pp. 1–38. issn: 0304-3975. doi: 10.1016/0304-3975(95)00010-0.
	Bloom, Stephen L. and Zolta´n E´sik. “Iteration Theories. The Equational Logic of Iterative Processes”. EATCS Monographs on Theoretical Computer Science. Springer-Verlag Berlin Heidelberg, 1993. xv+630 pp. isbn: 978-3-642-78034-9. doi: 10.1007/978-3-642-78034-9.
	Bloom, Stephen L. and Zolta´n E´sik. “Some Equational Laws of Initiality in 2CCC’s”. International Journal of Foundations of Computer Science 6 (1995), pp. 95–118. doi: 10.1142/S0129054195000081.
	Caires, Lu´ıs and Frank Pfenning. “Session Types as Intuitionistic Linear Propositions”. In: CONCUR 2010 — Concurrency Theory. 21st International Conference, CONCUR 2010 (Paris, France, Aug. 31– Sept. 3, 2010). Ed. by Paul Gastin and Franc¸ois Laroussinie. Lecture Notes in Computer Science 6269. Springer-Verlag Berlin Heidelberg, 2010, pp. 222–236. isbn: 978-3-642-15374-7. doi: 10.1007/978-3- 642-15375-4 16.
	Castellan, Simon and Nobuko Yoshida. “Two Sides of the Same Coin: Session Types and Game Semantics. A Synchronous Side and an Asynchronous Side”. In: Proceedings of the ACM on Pro- gramming Languages. 46th ACM SIGPLAN Symposium on Principles of Programming Languages (Cascais, Portugal, Jan. 13–19, 2019). Vol. 3. POPL. Association for Computing Machinery, New York, New York, Jan. 2, 2019, 27:1–27:29. doi: 10.1145/3290340.
	Crole, Roy L. “Categories for Types”. Cambridge University Press, Cambridge, United Kingdom, 1993. xvii+335 pp. isbn: 0-521-45701-7.
Fiore, Marcelo P. “Axiomatic Domain Theory in Categories of Partial Maps”. PhD thesis. The University of Edinburgh Department of Computer Science, Oct. 1994. v+282 pp.
Freyd, Peter. “Algebraically Complete Categories”. In: Category Theory. Category Theory ’90 (Como, Italy, July 22–28, 1990). Ed. by Aurelio Carboni, Maria Cristina Pedicchio, and Giuseppe Rosolini. Lecture Notes in Mathematics 1488. Springer-Verlag Berlin Heidelberg, 1991, pp. 95–104. isbn: 978-3-540-46435-8. doi: 10.1007/BFb0084215.
	Freyd, Peter. “Remarks on Algebraically Compact Categories”. In: Applications of Categories in Computer Science (Durham, United Kingdom). Ed. by M. P. Fourman, P. T. Johnstone, and A. M. Pitts. London Mathematical Society Lecture Note Series 177. Cambridge University Press, Cambridge, United Kingdom, 1992, pp. 95–106. isbn: 0-521-42726-6. doi: 10.1017/CBO9780511525902.006.
Gunter, Carl A. “Semantics of Programming Languages. Structures and Techniques”. The MIT Press, Cambridge, Massachusetts, 1992. 419 pp. isbn: 0-262-07143-6.
	Hasegawa, Masahito. “Recursion from Cyclic Sharing”. In: Models of Sharing Graphs. A Categorical Semantics of let and letrec. Distinguished Dissertations. Springer-Verlag London Limited, June 1999. Chap. 7, pp. 83–101. isbn: 978-1-4471-0865-8. doi: 10.1007/978-1-4471-0865-8 7.
Honda, Kohei. “Types for Dyadic Interaction”. In: CONCUR’93. 4th International Conference on Concurrency Theory (Hildesheim, Germany, Aug. 23–26, 1993). Ed. by Eike Best. Lecture Notes in Computer Science 715. Springer-Verlag Berlin Heidelberg, Berlin, 1993, pp. 509–523. isbn: 978-3-540-47968-0. doi: 10.1007/3-540-57208-2 35.

	Joyal, Andr´e, Ross Street, and Dominic Verity. “Traced Monoidal Categories”. Mathematical Pro- ceedings of the Cambridge Philosophical Society 119 (1996), pp. 447–468. issn: 1469-8064. doi: 10.1017/s0305004100074338.
	Kahn, Gilles. “The Semantics of a Simple Language for Parallel Programming”. In: Information Processing 74. 6th IFIP Congress 1974 (Stockholm, Sweden, Aug. 5–10, 1974). Ed. by Jack L. Rosenfeld. International Federation for Information Processing. North-Holland Publishing Company, 1974, pp. 471–475. isbn: 0-7204-2803-3.
	Kavanagh, Ryan. A Domain Semantics for Higher-Order Recursive Processes. May 10, 2020. arXiv: 2002.01960v3 [cs.PL].
Kelly, G. M. and Ross Street. “Review of the Elements of 2-categories”. In: Category Seminar. Sydney Category Theory Seminar (Sydney, NSW, Australia, 1972–1973). Ed. by Gregory M. Kelly. Lecture Notes in Mathematics 420. Springer-Verlag Berlin Heidelberg, 1974, pp. 75–103. isbn: 978-3-540-37270-7. doi: 10.1007/BFb0063101.
Lehmann, Daniel J. “Categories for Fixpoint Semantics”. PhD thesis. Coventry, United Kingdom: Department of Computer Science, University of Warwick, 1976. 75 pp.
	Lehmann, Daniel J. “Categories for Fixpoint-Semantics”. In: 17th Annual Symposium on Foundations of Computer Science. Formerly called the Annual Symposium on Switching and Automata Theory. 17th Annual Symposium on Foundations of Computer Science. FOCS’76 (Houston, Texas, Oct. 25– 27, 1976). IEEE CH1133-8 C. IEEE Computer Society’s Technical Committee on Mathematical
Foundations of Computing. Institute of Electrical and Electronics Engineers, Long Beach, California, 1976, pp. 122–126. doi: 10.1109/SFCS.1976.9.
	Lehmann, Daniel J. and Michael B. Smyth. “Algebraic Specification of Data Types: a Synthetic Approach”. Mathematical Systems Theory 14 (1981), pp. 97–139. issn: 1433-0490. doi: 10.1007/ bf01752392.
	Lehmann, Daniel J. and Michael B. Smyth. “Data Types”. Extended Abstract. In: 18th Annual Symposium on Foundations of Computer Science. Formerly called the Annual Symposium on Switching and Automata Theory. 18th Annual Symposium on Foundations of Computer Science. FOCS’77 (Providence, Rhode Island, Oct. 31–Nov. 2, 1977). IEEE 77 CH1278-1 C. IEEE Computer Society’s Technical Committee on Mathematical Foundations of Computing. Institute of Electrical and Electronics Engineers, Long Beach, California, 1977, pp. 7–12. doi: 10.1109/SFCS.1977.10.
	Lindenhovius, Bert, Michael Mislove, and Vladimir Zamdzhiev. “Mixed Linear and Non-Linear Recursive Types”. Proceedings of the ACM on Programming Languages 3 111 (2019), pp. 1–29. issn: 2475-1421. doi: 10.1145/3341715.
Moggi, Eugenio. “Notions of Computation and Monads”. Information and Computation 93 (1991),
pp. 55–92. issn: 0890-5401. doi: 10.1016/0890-5401(91)90052-4.
Riehl, Emily. “Category Theory in Context”. Dover Publications, Inc, Mineola, New York, 2016.
isbn: 978-0-486-80903-8.
Schubert, Horst. “Categories”. Trans. from the German by Eva Gray. Springer-Verlag Berlin Heidel- berg, 1972. xi+385 pp. isbn: 978-3-642-65364-3. doi: 10.1007/978-3-642-65364-3.
Scott, Dana. “Continuous Lattices”. In: Toposes, Algebraic Geometry and Logic. Connections Between Category Theory and Algebraic Geometry & Intuitionistic Logic (Dalhousie University, Halifax, Nova Scotia, Jan. 16–19, 1971). Ed. by F. W. Lawvere. Lecture Notes in Mathematics 274. Springer Berlin Heidelberg, 1972, pp. 97–136. isbn: 978-3-540-37609-5. doi: 10.1007/BFb0073967.
	Simpson, Alex and Gordon Plotkin. “Complete Axioms for Categorical Fixed-Point Operators”. In: 15th Annual IEEE Symposium on Logic in Computer Science. 15th Annual IEEE Symposium on Logic in Computer Science. LICS’00 (Santa Barbara, California, June 26–28, 2000). IEEE Computer Society Technical Committee on Mathematical Foundations of Computing. IEEE Computer Society, Los Alamitos, California, 2000, pp. 30–41. isbn: 0-7695-0725-5. doi: 10.1109/LICS.2000.855753.
	Smyth, M. B. and G. D. Plotkin. “The Category-Theoretic Solution of Recursive Domain Equations”. Extended Abstract. In: 18th Annual Symposium on Foundations of Computer Science. Formerly called the Annual Symposium on Switching and Automata Theory. 18th Annual Symposium on Foundations of Computer Science. FOCS’77 (Providence, Rhode Island, Oct. 31–Nov. 2, 1977). IEEE 77 CH1278-1 C. IEEE Computer Society’s Technical Committee on Mathematical Foundations of Computing. Institute of Electrical and Electronics Engineers, Long Beach, California, 1977, pp. 13–17. doi: 10.1109/SFCS.1977.30.
Smyth, M. B. and G. D. Plotkin. “The Category-Theoretic Solution of Recursive Domain Equations”.
SIAM Journal on Computing 11 (1982), pp. 761–783. doi: 10.1137/0211062.
Takeuchi, Kaku, Kohei Honda, and Makoto Kubo. “An Interaction-Based Language and Its Typing System”. In: PARLE’94. Parallel Architectures and Languages Europe. 6th International PARLE Conference (Athens, Greece, July 4–8, 1994). Ed. by Costas Halatsis et al. Lecture Notes in Computer Science 10201. Springer-Verlag Berlin Heidelberg, Berlin, 1994, pp. 398–413. isbn: 978-3-540-48477-6.
doi: 10.1007/3-540-58184-7 118.
Wadler, Philip. “Propositions As Sessions”. Journal of Functional Programming 24 (2014), pp. 384–
418. issn: 1469-7653. doi: 10.1017/s095679681400001x.
Wand, Mitchell. Fixed-Point Constructions In Order-Enriched Categories. Tech. rep. 23. Bloomington, Indiana: Computer Science Department, Indiana University, Oct. 1977. 32 pp.
