Electronic Notes in Theoretical Computer Science 192 (2008) 3–15	
www.elsevier.com/locate/entcs

Ad-Hoc Threshold Broadcast Encryption with Shorter Ciphertexts
Vanesa Daza1
Dept. D’Enginyeria Informa`tica i Matema`tiques Universitat Rovira i Virgili
Av. Pa¨ısos Catalans 26, E-43007 Tarragona, Spain
Javier Herranz2
IIIA, Artificial Intelligence Research Institute CSIC, Spanish National Research Council Campus UAB s/n, E-08193 Bellaterra, Spain

Paz Morillo, Carla R`afols3
Dept. Matema`tica Aplicada IV Universitat Polit`ecnica de Catalunya
C. Jordi Girona 1-3, E-08034 Barcelona, Spain

Abstract
In a threshold broadcast encryption scheme, a sender chooses (ad-hoc) a set of n receivers and a threshold t, and then encrypts a message by using the public keys of all the receivers, in such a way that the original plaintext can be recovered only if at least t receivers cooperate.
This kind of scheme has many applications in mobile ad-hoc networks, characterized by their lack of in- frastructure as well as for the high dynamism of their nodes. Threshold broadcast encryption schemes are much more appropriate for mobile ad-hoc scenarios than standard threshold public key encryption schemes, where the set of receivers and the threshold for decryption must be known in advance (and remain the same for the rest of the protocol).
Previously proposed threshold broadcast encryption schemes have ciphertexts which contain at least n group elements. In this paper, we propose a new scheme where the ciphertexts contain essentially n − t group elements. The construction uses secret sharing techniques and the ElGamal public key cryptosystem as basic tools. We formally prove the security of the scheme, by reduction to the security of ElGamal cryptosystem.
Keywords: Threshold encryption, ad-hoc and dynamic groups, ElGamal cryptosystem.


1 Email: vanesa.daza@urv.cat
2 Email: jherranz@iiia.csic.es
3 Email: paz@ma4.upc.edu, crafols@ma4.upc.edu

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.05.002

In a threshold public key encryption scheme a message is encrypted and sent to a group of receivers, in such a way that the cooperation of at least t of them (where t is the threshold) is necessary in order to recover the original message. Such schemes have many applications in situations where one wants to avoid that a single party has all the power/responsibility to protect or obtain some critical information. The usual strategy to implement this idea is the following: the set of receivers, which is set from the beginning, runs an interactive setup protocol which takes as input a threshold (chosen by themselves) and outputs a public key for the set and shares of the matching secret key.
The fact that the set of receivers and the threshold are decided from the begin- ning can limit the applications of these schemes in real life. One can imagine that the sender of the message, who wants to protect some information, may want to decide who will be the designated receivers in an ad-hoc way, just before encrypting the message, and also decide the threshold of receivers which will be necessary to recover the information. With this motivation in mind, a scheme for this situation would have the following properties:
There is no setup phase or fixed groups. Each potential receiver has his own pair of secret/public keys.
The sender chooses (ad-hoc) the set of receivers P and the threshold t for the decryption. Then he encrypts the message by using the public keys of all the players in P.
A ciphertext corresponding to the pair (P, t) can only be decrypted if at least t members of P cooperate by using their secret keys. Otherwise, it is computationally infeasible to obtain any information about the plaintext.

Application to Mobile Ad-hoc Networks
This kind of schemes are specially useful in order to guarantee security in mobile ad-hoc networks. A mobile ad-hoc network (also known as MANET) is created on the fly. It consists of a set of self-organized and mobile nodes (e.g. PDAs, laptops or cellular phones) without any fixed infrastructure. The topology of a MANET changes rapidly and unpredictably over time. Such dynamism can be due to new nodes joining the network, whereas at the same time others leave it or just fail because they move to a region that is not in the cover range of the network. Standard threshold public key encryption schemes - where threshold and set of receivers are decided at the setup stage- are not always an ideal solution for this very general scenario. Imagine for example that a sender wants to send a message to a group of receivers in a mobile ad-hoc network, where a considerable number of these receivers are newcomers, that is, they have just entered into the network. To use standard threshold encryption techniques, a public key for the set of receivers and a threshold for decryption must have been set up in a protocol which is either interactive among the receivers, or executed by an external entity; both situations are typically not desirable in ad-hoc networks. Each time someone wants to encrypt

a message with a different set of receivers or a different threshold, which is likely to happen quite often in a MANET, the interactive setup protocol should be run again. This does not fit in with the computational and energy constraints of an ad-hoc network.
We emphasize that, unlike in threshold public key encryption schemes, in a threshold broadcast encryption scheme the sender can decide the set of receivers in an ad-hoc way, for example depending on the set of nodes he is directly connected with. Not only this, he can also decide the threshold of receivers which will be necessary to recover the information, for example depending on the secrecy level of the specific message he wants to send.

Related work
Note that, when t = 1, the resulting scheme will be a broadcast encryption scheme [10], where a sender encrypts a message in such a way that any member of the set of receivers can decrypt it. For this reason, we have decided to use the name
threshold broadcast encryption scheme (TBE scheme, for short) to refer to this
kind of schemes. Other possible names could be dynamic threshold encryption (as
used in [11]) or ad-hoc threshold encryption. To the best of our knowledge, only two works have dealt with this extension of the concept of broadcast encryption. In [11] the authors propose a scheme based on RSA; even if the authors claim that the length of the ciphertexts is constant, the ciphertext contains an integer modulo N , where N is the product of all the RSA moduli of the receivers. Therefore, the actual length of the ciphertext is at least n times the length of a standard RSA modulus, where n is the number of receivers. In [7], the authors propose a TBE scheme for identity-based scenarios; again, the ciphertexts contain at least n group elements.

Our contribution
In this paper we propose a new threshold broadcast encryption scheme where the length of the ciphertexts is essentially n − t, being n the number of receivers and t the threshold for the decryption. The idea is to use some techniques related to secret sharing and combine them with some suitable public key encryption scheme. In this work we use ElGamal encryption scheme [9]. We formally prove that the proposed TBE scheme has the same security level as ElGamal cryptosystem.
The rest of the work is organized as follows. In Section 2 we recall some tools (secret sharing, public key encryption) that will be necessary for the construction of our scheme. In Section 3 we give the general definitions of the protocols of a threshold broadcast encryption scheme, along with the description of the formal security model for such schemes. We propose our scheme in Section 4, and we prove that the scheme is secure, by reduction to the security of ElGamal encryption scheme. We conclude our work in Section 5.

Preliminaries
Threshold Secret Sharing Schemes
The idea of secret sharing schemes was independently introduced by Shamir [12] and Blakley [5]. A (d, N )-threshold secret sharing scheme is a method by means of which a special figure, called usually dealer, distributes a secret s among a set P = {P1,... , PN } of N players. Each player Pi privately receives from the dealer a piece of information si (or share). Then, those subsets with at least d players can recover the secret s from their shares, while subsets containing less than d players do not obtain any information at all about the secret.
Shamir’s secret sharing scheme [12] solves this problem by means of polynomial interpolation. Let GF (q) be a finite field with q > N elements, and let s ∈ GF (q) be the secret to be shared. The dealer picks a polynomial f (x) of degree at most d − 1, where the constant term of f (x) is s and all other coefficients aj are selected from GF (q), uniformly and independently, at random. That is, f (x) has the form
d−1	j
j=1
Every player Pi is publicly and uniquely associated to a field element αi. The dealer privately sends to player Pi his share si = f (αi), for i = 1,... ,N .
Now, players in a set A ⊂ P such that |A| ≥ d can recover the secret s = f (0), by using Lagrange interpolation. Actually, players in A can compute the value of the polynomial f (x) evaluated on any point αj, with the formula:
f (αj)= Σ λAf (αi)= Σ λAsi,

ij
Pi∈A
ij
Pi∈A



where

A
ij
PÆ∈A,l/=i
αj − αl . αi − αl

On the other hand, it can be proved that players in a subset B ⊂ P such that
|B| < d do not obtain any information about the polynomial f (x), apart from their shares {f (αk)}Pk ∈B , of course.
Standard Public Key Encryption
A public key encryption scheme PKE= (PKE.KG, PKE.Enc, PKE.Dec) consists of three algorithms:
The probabilistic key generation algorithm PKE.KG takes as input a security parameter k and returns a pair (pk, sk) consisting of a public key pk and a matching secret key sk; we denote an execution of this protocol as (pk, sk) ← PKE.KG(1k).
The probabilistic encryption algorithm PKE.Enc takes as input a public key pk
and a message m, and returns a ciphertext C; we write C ← PKE.Enc(pk, m).
The deterministic decryption algorithm PKE.Dec takes the secret key sk and a ciphertext C as input, and outputs either the corresponding message or a special

symbol ⊥. We write m˜ ← PKE.Dec(sk, C).
We recall the standard notion of security for public key encryption schemes in terms of indistinguishability. We consider both chosen-plaintext and chosen- ciphertext attacks. For this, we consider the following game that an attacker Aatk plays against a challenger:
(pk, sk) ← PKE.KG(1k)
(St, m ,m ) ← AO1(·)(find, pk)
0	1	atk
b ← {0, 1} at random; C∗ ← PKE.Enc(pk, mb)
b' ← AO2(·)(guess,C∗, St).
In both phases (find and guess) of the attack, the attacker Aatk can have access to a decryption oracle with respect to sk for ciphertexts of his choice, depending on the considered kind of attacks. Namely, if atk is a chosen plaintext attack (CPA), then there is no access at all, which we write as O1 = O2 = ϵ. If atk is a partial chosen ciphertext attack (CCA1), then O1 = PKE.Dec(sk, ·) and O2 = ϵ. Finally, if atk is a full chosen ciphertext attack (CCA2), then O1 = O2 = PKE.Dec(sk, ·). In this last case, ACCA2 is not allowed to query the oracle O2 with the challenge ciphertext C∗. The advantage of such an adversary Aatk is defined as


Adv(A

atk
)= Pr[b = b] −  .

2 
A public key encryption scheme is said to be ε-indistinguishable under atk at- tacks if Adv(Aatk) < ε for any attacker Aatk which runs in polynomial time.
ElGamal Public Key Encryption Scheme
ElGamal public key encryption scheme, EG PKE= (EG PKE.KG, EG PKE.Enc, EG PKE.Dec), works as follows (see [9] for the original proposal):
EG PKE.KG takes as input a security parameter k and generates two prime numbers p and q such that q is k bit long and q|p − 1. Then a cyclic subgroup G = ⟨g⟩ of Zp is chosen, with order q. All these values are made public. The secret key sk of the user is chosen at random in Z∗, whereas the matching public
key is pk = gsk mod p.
EG PKE.Enc takes as input a public key pk and a message m ∈ G; then a random value a ∈ Z∗ is chosen, and the ciphertext C = (r, s) is computed as r = ga mod p and s = m · pka mod p.
EG PKE.Dec takes the secret key sk and a ciphertext C = (r, s), and outputs
s/rsk mod p = m.
ElGamal cryptosystem is known to be indistinguishable under CPA attacks, assuming the hardness of the Decisional Diffie-Hellman (DDH) problem. It is also known that this scheme is not indistinguishable under CCA2 attacks, because of its homomorphic properties. Nothing has been proved about indistinguishability of ElGamal encryption scheme under CCA1 attacks.

Threshold Broadcast Encryption
Roughly speaking, the operations of a threshold broadcast encryption scheme work as follows: the sender chooses a set of receivers and a threshold t, and then encrypts a message by using the public keys of these receivers. Given the resulting ciphertext, the original message can be recovered by any set of at least t of the designated receivers: they use their secret keys to compute partial decryptions which are then combined to obtain the message.
More formally, a threshold broadcast encryption scheme TBE= (TBE.Setup, TBE.KG, TBE.Enc, TBE.PartDec, TBE.Dec) consists of five algorithms:
The randomized setup algorithm TBE.Setup takes as input a security parameter k and outputs some public parameters params, which will be common to all the users of the system. We write params ← TBE.Setup(1k).
The randomized key generation algorithm TBE.KG takes as input some public parameters params and returns a pair (pk, sk) consisting of a public key and a matching secret key; we denote an execution of this protocol as (pk, sk) ← TBE.KG(params).
The randomized encryption algorithm TBE.Enc takes as input a set of public keys {pki}Pi∈P corresponding to a set P of n players, a threshold t satisfying 1 ≤ t ≤ n, and a message m. The output is a ciphertext C, which contains the description of P and t; we write C ← TBE.Enc(P, {pki}Pi∈P , t, m).
The (possibly randomized) partial decryption algorithm TBE.PartDec takes as input a ciphertext C for the pair (P, t) and a secret key ski of a player Pi ∈ P. The output is a partial decryption value m˜ i or a special symbol ⊥. We denote with m˜ i ← TBE.PartDec(C, ski) an execution of this protocol.
The deterministic final decryption algorithm TBE.Dec takes as input a ciphertext C for the pair (P, t) and t partial decryptions {m˜ i}Pi∈A corresponding to players in some subset A ⊂ P. The output is a message m or a special symbol ⊥. We write m˜ ← TBE.Dec(C, {m˜ i}Pi∈A, A).
An important parameter of such schemes is the length of the ciphertext C. When measuring this length (in our proposal, but also in previous proposals), we do not consider the description of the set P: in some cases, the description can consist of the list of all the public keys, which already has length n. In some other cases, the description can be much simpler, for example if the set of receivers is formed by the workers of a company. For the previous TBE schemes in the literature [11,7], the ciphertexts contain at least n group elements, for some mathematical group (usually large). In this paper we will propose a new scheme where the ciphertexts contain essentially n − t group elements.

Security of Threshold Broadcast Encryption Schemes
When formalizing security of standard public key encryption schemes, one usually considers a single challenged public key, as in the definition we provide in Section

2.2. This is because it has been shown [1] that security in this model is equivalent to security in a model which considers many public keys.
In threshold broadcast encryption schemes, however, we must consider many public keys when we formalize security, because each encryption and decryption in the system involve many public/secret keys. An attacker can corrupt different users, in two possible ways: registering new public keys for such users, or obtaining the secret key matching with the public key of some previously honest users. The final goal of the attacker is to obtain any information about a message which has been encrypted for a pair (P∗, t∗) such that the number of corrupted players in P∗ is less than t∗.
One remark to be done is how to deal with the first kind of corruptions, those where the attacker registers new public keys. In the real world, certification author- ities (should) require users to prove the knowledge of the secret key which matches with the public key they are registering. This can be done by means of a Proof of Knowledge [3]. In the game which models the security of threshold broadcast encryption schemes, the attacker will be required to perform such a Proof of Knowl- edge of the secret keys which match with the new public keys he wants to register. Because of the ‘proof of knowledge’ property of the employed Proof of Knowledge system [3], this is equivalent to require the adversary to supply also the matching secret key, each time he registers a public key. This approach has already been followed in other works [2,4].
For simplicity, when analyzing our scheme we will consider only the first kind of corruption. If both kinds of corruption are considered, the scheme can be still be proved secure, but the proof becomes a bit more confusing. Taking all this into consideration, indistinguishability for threshold broadcast encryption schemes is defined by considering the following game that an attacker Batk plays against a challenger:
params ← TBE.Setup(1k)
For players Pi ∈ U1, run (pki, ski) ← TBE.KG(params)
Batk can register public keys at any time: for players Pj ∈ U2, he runs (pkj, skj) ← TBE.KG(params) and broadcasts (Pj, pkj, skj)
(St, P∗, t∗,m ,m ) ← BO1(·)(find, params, {pk }	)

0	1	atk
i Pi∈U1

b ← {0, 1} at random; C∗ ← TBE.Enc(P∗, {pki}P ∈P∗ , t∗, mb)
b' ← BO2(·)(guess,C∗, St).
Of course, in order to consider meaningful and successful such an attack, we require |P∗ ∩ U2| < t∗. Otherwise, Batk knows the secret key of at least t∗ players in P∗ and can decrypt C∗ by himself, obtaining mb.
Depending on the considered kind of attacks, Batk can also have access to a decryption oracle for tuples (P, t,C) of his choice. As answer, Batk receives all the information that would be broadcast in a complete decryption process for this tuple; this includes all the partial decryption values. If atk is a chosen plaintext attack (CPA), then there is no access at all, i.e. O1 = O2 = ϵ. If atk is a partial chosen ciphertext attack (CCA1), then O1 = TBE.PartDec(·) ∪ TBE.Dec(·) and

O2 = ϵ. Finally, if atk is a full chosen ciphertext attack (CCA2), then O1 = O2 = TBE.PartDec(·) ∪ TBE.Dec(·). In this last case, BCCA2 is not allowed to query the oracle O2 with the challenge tuple (P∗, t∗,C∗).
The advantage of such an adversary Batk is defined as


Adv(B
)= Pr[b = b] −  .

atk	2 
A threshold broadcast encryption scheme is said to be ε-indistinguishable under
atk attacks if Adv(Batk) < ε for any attacker Batk which runs in polynomial time.
A	Threshold	Broadcast	Encryption	Scheme	with
|C|≈ n − t
Our threshold broadcast encryption scheme is based on ElGamal.  We denote it as EG TBE = (EG TBE.Setup, EG TBE.KG, EG TBE.Enc, EG TBE.PartDec,
EG TBE.Dec), where the five algorithms work as follows.
EG TBE.Setup. Given a security parameter k, it generates two prime numbers p and q such that q is k bits long and q|p − 1. Then a cyclic subgroup G = ⟨g⟩ of Zp is chosen, with order q. We will use a collision-resistant hash function h :
{0, 1}∗ → Z∗ which assigns one different element in Z∗ to each potential player, to
q	q
apply Shamir’s secret sharing techniques. Therefore, the output of the protocol is
params = (p, q, G, g, h).
EG TBE.KG. Each player Pi chooses at random his secret key ski ∈ Z∗. The matching public key is pki = gski mod p. (From now on in the paper, we will sometimes omit the explicit mod p, since all the operations will be performed modulo p.)
EG TBE.Enc. In this phase of the scheme, a sender wants to encrypt a message addressed to some set of receivers that he chooses ad-hoc, in such a way that the message can be recovered only if the number of receivers that cooperate to decrypt is equal to or greater than a certain threshold that is also chosen by the sender.
In order to encrypt a message m ∈ G addressed to some set P = {P1,... , Pn} of n players, with threshold t ≤ n for the decryption, the idea is to set up an (n, N )-threshold secret sharing scheme, where N = 2n − t. Let λP be the Lagrange coefficients defined in Section 2.1, useful to compute the value of the polynomial in the point α0 = 0 from the value of the polynomial in the points {αi}Pi∈P , where αi = h(Pi). The sender must act as follows.

Compute PK =
P
pk i0 mod p.

i
Pi∈P
Choose a set P˜ of n − t (dummy) players, such that P˜ ∩ P = ∅. For each

Pj ∈ P˜, compute αj = h(Pj ) and then define pkj =
λP
pk ij mod p.

i
Pi∈P
Choose at random a ∈ Z∗ and compute r = ga mod p.

Compute s = m · PKa mod p.
For each Pj ∈ P˜, compute m˜ j = pka mod p.
Define the ciphertext as C = (P, t, P˜, r, s, {m˜ j }P ∈P˜).
Note that the sender has used ElGamal encryption scheme with a public key PK such that the corresponding secret key SK = logg PK is not known by any single player. On the other hand, any subset of n players in P ∪ P˜ could recover SK from their own secret keys ski, by using Lagrange interpolation, if we implicitly define skj = logg pkj, for all Pj ∈ P˜. In the particular case of threshold decryption, since the ciphertext C already includes n − t partial decryptions, only t new partial decryptions, coming from P, will be necessary to recover the plaintext. Note also that a ciphertext C, excluding the description of the sets P and P˜, contains n − t+2 group elemtents (in Zp). The description of the set P˜ can be actually very short; for example, the sender can look for an interval of n − t integers J = {j0, j0 + 1,... , j0 + n − t − 1} (modulo q) such that αi ∈/ J for all Pi ∈ P, and define the set P˜ simply as the n − t dummy users Pj verifying αj ∈ J. Note that in this case, the value j0 is enough to describe the set P˜. The resulting ciphertexts are then shorter than those in all the previously proposed schemes, for any value of t satisfying 2 ≤ t ≤ n.
EG TBE.PartDec. Given a ciphertext C = (P, t, P˜, r, s, {m˜ j }P ∈P˜), any player Pi ∈P can compute his partial decryption m˜ i = rski mod p.
It would be possible to add robustness techniques in order to detect invalid partial decryptions. For example, each player Pi can be required to add to his partial decryption a zero-knowledge proof that DiscLogr (m˜ i)= DiscLogg (pki). This robust variant of our scheme, that we do not consider for the sake of simplicity, can also be proved secure.
EG TBE.Dec. Given a ciphertext C = (P, t, P˜, r, s, {m˜ j }P ∈P˜) and a set of t partial decryptions m˜ i, corresponding to a subset A ⊂ P with |A| = t, a combiner algorithm considers the whole set of partial decryptions, from B = A ∪ P˜, and then
computes
a P λB sk

κ =
P ∈B
λB
m˜ i
i0  i
Pi∈B	=

= gaSK = PKa.
Then the plaintext m is recovered by computing m = s/κ mod p.
Efficiency of the Scheme
To encrypt a message for a subset P of n receivers, with threshold t for decryption, the sender must perform n + n(n − t + 1) + 1 modular exponentiations. However, there are only n bases for these exponentiations (i.e. the values pki, for Pi ∈ P) and so pre-computation techniques can be used to speed up the final computation time of this phase.
For the partial decryption of a ciphertext, any of the t receivers involved in the decryption must locally compute a modular exponentiation. Finally, the combiner

algorithm must perform n modular exponentiations to recover the plaintext from the ciphertext and the partial decryptions.
Our Scheme is as Secure as ElGamal Cryptosystem
In this section we prove that our threshold broadcast encryption scheme is essentially as secure as ElGamal public key encryption scheme. As it happens with ElGamal, our scheme is not secure under CCA2 attacks. With respect to CPA and CCA1 attacks, we are going to show that a successful attack against our scheme implies a successful attack against ElGamal.
As we remarked in Section 3.1, we consider for simplicity only the first kind of corruption, and not the corruptions where the attacker asks for the secret key of a previously registered public key. If this second type of corruption is considered, the proof is still possible (with a slightly worse reduction factor) but becomes more cumbersome: the public keys of the users are defined in two different ways, depend- ing on a probability distribution. For one of the ways, the matching secret key is known and so the corruption queries can be correctly answered for these users. For the other way, the secret key is not known, but a hypothetical attack involving this public key can be transformed into an attack against ElGamal cryptosystem.
Theorem 4.1 For atk =CPA,CCA1, if there exists an attacker Batk against our threshold broadcast encryption scheme with Adv(Batk) ≥ ε, then there exists an attacker Aatk against ElGamal public key encryption scheme with Adv(Aatk) ≥ ε/4.
Proof. We are going to deal with the CCA1 case, obviously the CPA case can be proved in a similar (but simpler) way. Let us assume therefore the existence of a CCA1 attacker B against our TBE scheme, and let us construct a CCA1 attacker A against ElGamal. A receives an ElGamal public key (p, q, G, g, y) as initial input.
Now A prepares the initialization of the hypothetical attacker B. Namely, for each player Pi ∈ U1, A chooses at random βi ∈ Z∗ and computes pki = yβi mod p. Finally, A chooses a collision-resistant hash function h : {0, 1}∗ → Z∗. The public parameters for B will be params = (p, q, G, g, h). The attacker A initializes the attack B by sending him (params, {pki}Pi∈P ).
B can register new public keys, for players Pj ∈ U2: he must broadcast the
resulting pairs (pkj, skj). Now B can make decryption queries, for ciphertexts C =

(P, t, P˜, r, s, {m˜ j }P ∈P˜), where P, P˜
⊂ U1 ∪ U2. The attacker A has to simulate

the information that B would obtain in the whole decryption procedure for this
ciphertext (including all the partial decryption values m˜ i for Pi ∈ P). To do this, remember that A has access to his own ElGamal decryption oracle.
For each player Pj ∈ P ∩ U2, the value skj is known so the partial decryption
m˜ j = rskj mod p can be computed and broadcast by A. Note that if r = ga mod p, we can write

⎛	λP ⎞	⎛


λP sk
⎞a ⎛
a
λP β

s = m
Pi∈P
pki
i0 ⎠
= m	g j0
Pj∈P∩U2
j ⎠ ⎝
y k0 k	.
Pk∈P∩U1

Let	us	denote	M	=	m 

Pj∈P∩U2
gλP skj a,	then	we	have	s	=

M 
yλP β  a.

The goal of A is now to compute the values m˜ i = rski = pka mod p, for players
Pi ∈P ∩ U1, where we have pki = yβi .
First of all, A sends to his ElGamal decryption oracle the ciphertext

P
(rPk ∈P∩U1
λP βk
, s). The plaintext that A obtains from his oracle is exactly M .

Then, for each player Pi ∈P ∩U1, A sends to his ElGamal decryption oracle the
P	λP βk −λP βi

k0
ciphertext (rPk ∈P∩U1
aβiλP
i0
, s). The plaintext that A obtains from his oracle is

My	i0 . Since A already knows the value M , he can extract from this answer the
desired value yaβi = pka = m˜ i mod p. So A can perfectly simulate the answers to the decryption queries that B makes.
Now B outputs (P∗, t∗, m0, m1), where P∗ contains n∗ ≥ t∗ players and m0 and m1 are two messages with the same length. Since we assume that the attack performed by B is meaningful, there must be at least one non-corrupted player in P∗; that is, P∗ ∩ U1 /= ∅. A chooses α0, α1 ∈ G at random and sends the messages α0 · m0 and α1 · m1 to his ElGamal challenger, who sends back to A an encryption (r, s) of message αb · mb for a random bit b ∈ {0, 1} that A has to guess. Therefore, we have (r, s)= (gw, αbmbyw) for some w ∈ Z∗. At this point A makes a first guess by choosing at random ˜b ∈ {0, 1}, and compute the value z = s/α˜bm˜b. Note that if
˜b = b, then we have that z = yw. Anyway, A sets r∗ = r and
∗	⎛	w λP∗ sk ⎞ ⎛	λP∗ β ⎞

s = m˜b	(g
Pj ∈P∗∩U2
) j0
j ⎠ ⎝
z i0
Pi∈P∗∩U1
i ⎠ .

Now A can choose a set P˜∗ ⊂ U1 ∪ U2 of n∗ − t∗ dummy players Pl, such that
P˜∗ ∩ P∗ = ∅, and compute their partial decryption values m˜ l = (r∗)skÆ = pkw. For
these dummy players, we have

λP	⎛
sk  λP ⎞ ⎛
β λP ⎞

pkl =

Pi∈P
pki iÆ =	(g
Pi∈P∩U2
i ) iÆ ⎠ · ⎝
(y
Pi∈P∩U1
i ) iÆ ⎠ .

Therefore, the desired partial decryptions are computed as

m˜ l = r
PP ∈P∩U2

λP ski
· zPP ∈P∩U1

λP βi ,

which again are correct if ˜b = b.
Finally, A sends to B the resulting challenge ciphertext C∗ = (P∗, t∗, P˜∗, r∗, s∗,
{m˜ k}P ∈P˜∗ ). The attacker B eventually outputs a bit b'. If b' = ˜b, then A outputs
k  '
this bit b ; otherwise, A outputs a random bit.
Let us compute the success probability of A. Note that if his first guess ˜b is correct, then the challenge ciphertext C∗ is consistent and by hypothesis B will

guess the correct bit with probability 1/2+ ε. On the other hand, if ˜b /= b, then we have that z = yw αbmb is a completely random value. Therefore, the information
α˜bm˜b
that У receives in the challenge ciphertext C∗ is completely independent of the bit b; for this reason, we can assume that У’s guess b' is correct with probability 1/2. In this case, A will see b' /= ˜b and will choose at random his own final guess on b,
succeeding with probability 1/2. Summing up, we have

Pr[A wins his game] = Pr[˜b = b ΛA wins his game]+Pr[˜b /= b ΛA wins his game] ≥

1 ·  1 + ε  +  1 — ε  · 1  + 1 ·  1 · 1  = 1 + ε .
2	2	2	2	2	2  2	2	4

Conclusion
Threshold broadcast encryption (TBE) schemes differ from traditional threshold public key encryption schemes [13,6] because the group of receivers and the threshold for decryption are not decided from the beginning, but chosen (ad-hoc) by the entity who encrypts each message. This difference makes TBE schemes more suitable for some applications in real life, specially regarding mobile ad-hoc networks.
In this work we have designed a TBE scheme with shorter ciphertexts than previous proposals, and whose security level is proved to be the same as in ElGamal cryptosystem (at most CCA1 security). In a subsequent work [8], we have designed a different scheme which achieves maximum security (under CCA2 attacks) with ciphertexts which have length n — t, as well. However, the scheme employs bilinear pairings, which makes it less efficient. An interesting open problem is to study if the bound of n — t for the length of the ciphertexts can still be lowered.

References
M. Bellare, A. Boldyreva and S. Micali. Public-key encryption in a multi-user setting: security proofs and improvements. Proceedings of Eurocrypt’00, Lecture Notes in Computer Science 1807 (2000), 259–274.
M. Bellare, A. Boldyreva and J. Staddon. Randomness reuse in multi-recipient encryption schemes. Proceedings of PKC’03, Lecture Notes in Computer Science 2567 (2002), 85–99.
M. Bellare and O. Goldreich. On defining proofs of knowledge. Proceedings of Crypto’92, Lecture Notes in Computer Science 740 (1992), 390–420.
M. Bellare, T. Kohno and V. Shoup. Stateful public-key cryptosystems: how to encrypt with one 160-bit exponentiation. Proceedings of CCS’06, ACM Press (2006), 380–389.
G.R. Blakley. Safeguarding cryptographic keys. Proceedings of the National Computer Conference, American Federation of Information, Processing Societies Proceedings 48 (1979), 313–317.
R. Canetti and S. Goldwasser. An eﬃcient threshold public key cryptosystem secure against adaptive chosen ciphertext attack. Proceedings of Eurocrypt’99, Lecture Notes in Computer Science 1592 (1999), 90–106.

Z. Chai, Z. Cao and Y. Zhou. Eﬃcient ID-based broadcast threshold decryption in ad hoc network. Proceedings of IMSCCS’06, Volume 2, IEEE Computer Society (2006), 148–154.
V. Daza, J. Herranz, P. Morillo and C. R`afols. CCA2-secure threshold broadcast encryption with shorter ciphertexts. Proceedings of ProvSec’07, Lecture Notes in Computer Science 4784 (2007), 35–50.
T. ElGamal. A public key cryptosystem and a signature scheme based on discrete logarithms. IEEE Trans. Information Theory, 31 (1985), 469-472.
A. Fiat and M. Naor. Broadcast encryption. Proceedings of Crypto’93, Lecture Notes in Computer Science 773 (1994), 480–491.
H. Ghodosi, J. Pieprzyk and R. Safavi-Naini. Dynamic threshold cryptosystems: a new scheme in group oriented cryptography. Proceedings of Pragocrypt’96, CTU Publishing house (1996), 370–379.
A. Shamir. How to share a secret. Communications of the ACM, 22 (1979), 612–613.
V. Shoup and R. Gennaro. Securing threshold cryptosystems against chosen ciphertext attack. Journal of Cryptology, 15 (2) (2002), 75–96.
