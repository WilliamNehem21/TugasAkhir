Electronic Notes in Theoretical Computer Science 176 (2007) 85–97	
www.elsevier.com/locate/entcs

Modelling Calculi with Name Mobility using Graphs with Equivalences
Paolo Baldan1
Dipartimento di Informatica, Universita` Ca’ Foscari di Venezia, Italy
Fabio Gadducci2 and Ugo Montanari3
Dipartimento di Informatica, Universita` di Pisa, Italy

Abstract
In the theory of graph rewriting, the use of coalescing rules, i.e., of rules which besides deleting and generating graph items, can coalesce some parts of the graph, turns out to be quite useful for modelling purposes, but, at the same time, problematic for the development of a satisfactory partial order concurrent semantics for rewrites. Rewriting over graphs with equivalences, i.e., (typed hyper)-graphs equipped with an equivalence over nodes provides a technically convenient replacement of graph rewriting with coalescing rules, for which a truly concurrent semantics can be easily defined. The expressivity of such a formalism is tested in a setting where coalescing rules typically play a basic role: the encoding of calculi with name passing as graph rewriting systems. Specifically, we show how the (monadic fragment) of the solo calculus, one of the dialect of those calculi whose distinctive feature is name fusion, can be encoded as a rewriting system over graph with equivalences.
Keywords: Concurrent graph rewriting, dpo approach, graphical encoding of nominal calculi, graph process semantics.


Introduction
Recent years have seen an increasing use of graphical formalisms for the modelling of concurrent and distributed systems. Graph-like structures naturally provide a for- mal yet flexible view of system states, while the rewriting rules suitably model local state transformations. Among the different formalisms proposed in the literature, the so-called double pushout (dpo) approach offers a large variety of theoretical and

٨ Research partially supported the EC RTN 2-2001-00346 SegraVis, the EU IST-FP6-16004 SEnSOria
and the MIUR project ART.
1 Email: baldan@dsi.unive.it
2 Email: gadducci@di.unipi.it
3 Email: ugo@di.unipi.it

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.10.028

practical tools for the visual specification of a system (see, e.g., [16,7]), abstract- ing away from the unnecessary details of the state representation. As an example, the dpo rewriting techniques for simulating reductions in nominal calculi [14,2], as presented in [8,9], view a (possibly recursive) process as a graph, thus modelling reductions by rewrites. The use of graphs gets rid of the problems concerning the implementation of reduction over the structural congruence, such as α-conversion of (bound) names, since equivalent processes are mapped into isomorphic graphs.
However, the diffusion of the formalism raises unresolved issues concerning the analysis of its concurrency aspects. Consider again the graphical encodings for nom- inal calculi mentioned above: a concurrent semantics for the graph rewriting formal- ism would provide a concurrent semantics for process reduction, but unfortunately these encodings fall outside the canon of dpo concurrent semantics. More specifi- cally, the matching morphisms (those morphisms identifying the occurrence of the left-hand side of a rule into the graph to be rewritten) are forced to be injective. More importantly, the right-hand side of the rules resulting from the encoding are specified by non-injective morphisms (operationally, they force some node coalesc- ing in the graph to be rewritten). On the one hand, such features prevents the development of a satisfactory partial order concurrent semantics of rewrites; on the other hand, they are general enough to deserve to be addressed.
In order to allow the use of coalescing rules, while retaining a satisfactory theory of concurrency, we advocate the use of rewriting over a family of structures, called graphs with equivalences: ordinary (hyper-)graphs equipped with an equivalence relation over their nodes. The underlying intuition is simple: the coalescing of nodes is replaced by the handling of equivalence classes over nodes. Avoiding the fusion of these graph items (and thus preserving the identities of the nodes involved in a computation) allows to recover the theoretical results associated to the concurrent features of the dpo approach.
Here we present the basics of rewriting over graphs with equivalences and we il- lustrate the main ideas by testing the formalism against the encoding of the monadic solo calculus [13], one of the dialects of those nominal calculi whose distinctive fea- ture is name fusion [11,15]. This is intended to suggest that the formalism of graphs with equivalences is expressive enough to properly recast the graphical encodings of nominal calculi proposed in e.g. [8,9]. The presentation is mainly of informal nature. A more detailed presentation, including the development of the concurrency theory for the formalism can be found in [1] (where, however, only the specification of a fragment of the solo calculus was presented).
The paper has the following structure. Section 2 describes the formalism of graphs with equivalences, which is amenable to the dpo approach to rewriting. Section 3 presents an encoding of the processes of the solo calculus into graphs with equivalences, which guarantees a correspondence between process reductions and graph derivations. Finally, Section 4 concludes the paper, discussing open issues and directions of future research.

Rewriting Graphs with Equivalences
This section introduces graphs with equivalences, i.e., graphs endowed with an equivalence over the set of nodes. Rewriting systems over such structures are pro- posed as a replacement of rewriting over ordinary graphs with node coalescing rules.
The Category of Graphs with Equivalences
A (hyper-)graph G is a tuple ⟨VG, EG, cG⟩ for VG the set of nodes, EG the set of edges and cG : EG → V ∗ the connection function. A (hyper-)graph morphism f : G → H is a pair f = ⟨fV : VG → VH, fE : EG → EH⟩ satisfying cH (fE(e)) = f ∗ (cG(e)) for
any e ∈ EG. The corresponding category is denoted by Graph.
Definition 2.1 (graphs with equivalences) A graph with equivalences (e- graph) is a pair G = ⟨G, ∼G⟩ where G is a graph and ∼G⊆ VG×VG is an equivalence over the set of nodes. Given two e-graphs G and H, a morphism f : G → H is a graph morphism f : G → H such that for all n, n' ∈ VG, if n ∼G n' then f (n) ∼H f (n'). The category of e-graphs and their morphisms is denoted by EGraph.
An e-graph G provides an alternative representation for the graph G/∼G ob- tained by quotienting G with respect to ∼G. Formally, we can define a quotient func-
'
tor Q : EGraph → Graph defined on objects as Q(G) = G/∼G = ⟨V /∼G , E, c ⟩
where c'([e]∼ ) = [v1]∼ ... [vn]∼	if c(e) = v1 ... vn. Given f : G → H we have
G	G
Q(f ) defined by Q(f )([v]∼G ) = [f (v)]∼G . An example of graph with equivalences can be found in Fig. 5(a). Equivalence classes are represented by a dotted rectan-
gle, encompassing those nodes belonging to the class. In the example there are four equivalence classes: {y1, y2}, {x1, x2}, {z1, z2} and {w, w1, w2}. The corresponding quotient graph, obtained by collapsing equivalent nodes, is depicted in Fig. 5(b).
In order to define rewriting over e-graphs some considerations are in order. Observe that monos in EGraph are morphisms f : G → H such that f :
G → H is a mono in Graph. Regular monos are monos f : G → H which reflect
as well as preserve the equivalences of nodes, i.e., such that for all n, n' ∈ VG if f (n) ∼H f (n') then n ∼G n'. Note that regular monos over e-graphs induce monos over the corresponding quotient graphs, i.e., if f : G → H is regular mono then Q(f ): Q(G) → Q(H) is injective.
The category EGraph has all pushouts, which are computed by taking the pushout in Graph, endowed with the equivalence arising as the “union” of the equivalences of the components.
Rewriting e-graphs
We next define rewriting systems over e-graphs according to the algebraic double- pushout (dpo) approach to rewriting, as presented in [4,5]. For technical reasons it is convenient to work with typed e-graphs, which are e-graphs labelled over a structure that is itself an e-graph (see, e.g., [3] for the idea of graph typing).
Given an e-graph T, the category of e-graphs typed over T is the slice category
EGraph ↓ T, later denoted T-EGraph. Explicitly, the objects of the category are



mL	mR



Fig. 1. A direct derivation.


the e-graph morphisms f : G → T with target T, and arrows are e-graph morphisms making the obvious diagram commutes. Given a T-typed e-graph G, we write |G| for the underlying e-graph and tG for the typing arrow tG : |G|→ T.
Rewriting systems over typed e-graphs will be used as a replacement of rewrit- ing systems over ordinary graphs where rules can coalesce nodes. Intuitively, the coalescing of nodes in rewriting systems over graphs becomes the generation of an equivalence between such nodes in the setting of e-graphs.
Definition 2.2 (e-graph production) A T-typed e-graph production is a span

L ←l
K →r
R in T-EGraph such that l and r are mono. It is called left-linear if l is

regular mono. A typed e-graph transformation system ( e-gts) is a tuple ⟨T, P, π⟩ where T is a ﬁxed graph, P is a set of production names, and π is a function mapping each name to a T-typed production. An e-gts is called left-linear if all its productions are left-linear.
Q(l)	Q(r)
Given a left-linear production p, in the production Q(L) ←− Q(K) −→ Q(R) the left morphism is mono, while the right morphism may coalesce nodes.
An example of left-linear e-graph production can be found in Fig. 7. Note that the right morphism is mono, but not regular mono since node equivalence is not reflected: the equivalence classes {y} and {w1, w2} in the interface are “merged” in a single class {y, w1, w2} in the right-hand side e-graph.
Definition 2.3 (derivation) Given a T-typed production p : L ←l− K −r→ R, a match of p in a T-typed e-graph G is a morphism mL : L → G.A direct derivation from G to H via production p at a match m is a diagram as depicted in Fig. 1, where (1) and (2) are pushout squares in T-EGraph. It is called strict if the match

is regular mono. We write G =p/m H, where m = ⟨m
, mK
, mR
⟩, or simply G =⇒ H.

Roughly, concerning the graphical part, the application of a production p first removes all the items of G matched by L − l(K), leading to the context graph D. Then the items of R − r(K) are added to D, thus obtaining H.
Concerning the equivalence part, being l a regular mono intuitively means that equivalences among nodes are never deleted, that is, two nodes which are equivalent in the e-graph L will still be equivalent in the e-graph R. Hence, the equivalence in D is just the restriction of the equivalence in G. Instead, whenever r is not regular mono, as an effect of taking the second pushout, some nodes which were not equivalent in D might become equivalent in H. On the formal side, the regular mono requirement for l ensures that the pushout complement, when it exists, is unique.
In several applications it is necessary to consider injective matches only. For e-graphs, this property corresponds to the requirement of having regular mono

P | Q = Q | P	P | 0 = P	P | (Q | R)= (P | Q) | R
(νx)[y = w]P = [y = w](νx)P for x /∈ {y, w}
(νx)(νy)P = (νy)(νx)P	(νx)(P | Q)= P | (νx)Q for x /∈ fn(P )
Fig. 2. Structural axioms for the solo calculus.
matches. For this reason, the rest of the paper will focus on strict derivations and left-linear e-gts, hence both qualifications “strict” and “left-linear” will be omitted. A drawback of the approach is given by the fact that a single node of a “stan- dard” graph can be represented in an e-graph by an equivalence class of possibly unbounded size. Therefore, in order to model node deletion, an unbounded num- ber of rules deleting equivalence classes of arbitrary size should be inserted into a transformation system. However, note that for modelling purposes, it is often not restrictive to consider only rules which never delete nodes: indeed, this happens on most graphical encodings of process calculi. Node deletion is then simulated by leav- ing a node isolated, thus assuming a mechanism for performing garbage collection.

Encoding a simple process calculus
In this section we put the e-graph formalism at work, showing that it allows for encoding a simple (the simplest available, in fact) process calculus, namely, the monadic solo calculus [13], one of the dialects of those nominal calculi whose dis- tinctive feature is name fusion [11,15].

The monadic fragment of the solo calculus
We shortly introduce the monadic variant of the solo calculus, its structural equiv- alence and the associated reduction semantics.
Definition 3.1 (processes) Let U be a set of names, ranged over by x, y, w,.. .. The set of processes Proc is generated by the syntax
P ::= 0, σ, (νx)P, P1 | P2, [x = y]P	for σ ∈ {x(y), xy}
We let P, Q, R,... range over the set Proc of processes.
The operators x(y) and xy are denoted as input and output, respectively, even if their symmetric behaviour makes the distinction (typical of most calculi) imma- terial; collectively, each instance of them is called a solo, to emphasise its lack of connections, except for name sharing, with the other components. Finally, the first argument of the two operators, indicated by x, is usually called the channel where the communication of information takes place.
We assume the standard definitions for the set of free names of a process P , denoted by fn(P ). Similarly for α-convertibility, with respect to the restriction operators (νy)P : the name y is bound in P , and it can be freely α-converted. Using these definitions, the behaviour of a process P is described as a relation obtained by closing a set of basic rules under a suitable congruence.

y /= w
(νw)(x(y) | xw | P ) → P {y/w
y /= w
} (r1)	[x = x]P → P (r4)
P → Q

(νy)(x(y) | xw | P ) → P {w/ } (r2)
x(y) | xy → 0 (r3)
(νx)P → (νx)Q (r5)
P → Q
P | R → Q | R (r6)

Fig. 3. Inference rules for the solo calculus.

Definition 3.2 (reduction semantics) The reduction relation for processes is the relation Rσ ⊆ Proc × Proc, closed under the structural congruence ≡ induced by the set of equations in Fig. 2, generated by the set of inference rules in Fig. 3, where P → Q means that ⟨P, Q⟩ ∈ Rσ.
Rules (r1) and (r2) characterise the communication between restricted processes. Consider, for instance, rule (r2): the process xw is ready to communicate the (possi- bly global) name w along the channel x; it then synchronises with the process x(y), and the bound name y is thus substituted by w on all the occurrences inside the residual process P . Hence, communication has a global effect affecting the process as a whole. Rule (r3) expresses the fact that there is no reason to bind a name during a reduction, if no substitution has actually to occur. Rule (r4) removes those matches that hold true. Finally, rules (r5) and (r6) simply state the closure of the reduction relation with respect to the operators of restriction and parallel composition.
There are two differences with respect to the operational semantics for the monadic fragment of the calculus proposed in [13]. The first difference, of a syntac- tical nature, is the explicit presentation of the four reduction rules, which in [13] are summarised as a unique rule equipped with constraints on the substitution in- duced by the name fusion. The second difference is the lack of two axioms, namely, [x = x]P = P and (νx)0 = 0, which are responsible for the garbage collection of useless operators. However, the calculus is essentially the same. In fact, let =e denote the equivalence on processes induced by extending the structural axioms of Fig. 2 with the previously mentioned laws for match and restriction, and let →e be the induced reduction relation. Then, if P →e Q, there exists a process R such that P → R and R =e Q.
We conclude with a remark on the expressiveness of the calculus. Despite their simple syntax and operational semantics, both the monadic variant and the dyadic variant without match (solos come with two names, besides the channel) are as expressive as the full fusion calculus (as proved in [13]), which in turn is a symmetric version of the foremost nominal calculi, the π-calculus [14].

The graphical encoding of solos
This section presents an encoding of the solo calculus based on e-graphs. It resembles the encoding using standard graphs presented in [10, Section 5], but here node coalescing rules are replaced with rules generating node equivalences. We do not



Fig. 4. The type graph Tσ .
provide a formal definition of the encoding, which, however, can be easily obtained by adapting the proposals for mobile ambients and π-calculus in [8,9].
In order to help intuition, we begin with a description of a suitable normal form for structurally congruent processes. Let us say that a process is basic if it contains no restriction operator; and it is disjoint if it is basic and all the names occurring in its operators are different.
Lemma 3.3 (normal form) Any process P is equivalent to a process of the shape
(νx1) ... (νxn)B where all xi’s are different and B is a basic process.
A process in normal form is denoted as (νX)B, where X = {x1,... , xn} is a set of names, since the order of the restriction operators is immaterial.
Definition 3.4 (disjoint normal form) Let P be a process and let (νX)B be its normal form. We call disjoint normal form of P an expression of the kind (νX)Dξ, where D is a disjoint process, such that X ∩ fn(D)= ∅ and ξ : fn(D) → fn(B) is a surjective name substitution satisfying Dξ = B.
After renaming the basic process, the substitution ξ picks a representative for each equivalence class of names. For example, the process Pe = (νw)(x(y) | xw | w(z) | yz) is described by the disjoint normal form (νw)Deξe where De = x2(y2) | x1w2 | w1(z2) | y1z1 and ξe is the obvious substitution.
The above characterisation naturally suggests a representation for processes
based on typed e-graphs. For technical reasons, the graph underlying the e-graph representation of a process will be completely disconnected, i.e., all edges will be incident to distinct nodes.
The type e-graph Tσ is represented in Fig. 4. It includes two nodes: intuitively the black node correspond to the sort of processes, while the white node correspond to the sort of names. Nodes typed over such items will be called process nodes and name nodes, respectively. Additionally, Tσ includes four different edges, corresponding to the operators of the calculus. The equivalence on nodes is the identity, i.e., Tσ is essentially a standard graph. The typing for nodes will be represented by using the shape of the nodes themselves, while for edges we will use labels in, out, c and m. Let P be a process, and (νX)Dξ its disjoint normal form. Then, in the typed e- graph GP associated to P any name occurring in D becomes a name node. Moreover solos and all operators, except parallel, become edges. Note that in this simple calculus almost all the edges are connected to a single process node (intuitively the process they belong to). The only exception is the match operator which has a continuation and thus the corresponding edge is connected to two process nodes. Since all the edges must be disconnected from each other, GP has as many process


	

(a)
(b)

Fig. 5. (a) The e-graph encoding of process Pe and (b) the quotient graph Q(Pe).
Fig. 6. The e-graph encoding of the process Pm.
nodes as the occurrences of solos and restriction operators, plus twice those of the match operators. The effect of the substitution ξ is represented by the equivalence
∼GP between name nodes: given two nodes x and y we have x ∼GP y iff ξ(x)= ξ(y) or ξ(x) = y. Similarly, the topological structure is represented by the equivalence on process nodes.
Consider again the process Pe = (νw)(x(y) | xw | w(z) | yz) and its disjoint normal form. Its encoding is represented in Fig. 5(a), where name nodes, for the sake of clarity, are additionally equipped with the name they represent, in order to make the correspondence between the disjoint normal form and the encoding clearer. Some intuition may be gained by looking at the quotient graph Q(GPe ) depicted in Fig. 5(b), obtained by collapsing equivalent nodes: it directly corresponds to the basic process Pe, which is already in normal form, and this was indeed the encoding proposed for process Pe in [10, Fig. 11].
The encoding of process Pm = (νw)([y = w].0 | x(y) | x¯w) can be found in Fig. 6. A disjoint normal form, in this case, can be Pm = (νw)Dmξ, where Dm = [y2 = w2].0 | x1(y1) | x¯2w1 and ξ is the obvious substitution.
Encoding the rules
We now introduce the e-gts Gσ in Tσ-EGraph. It basically contains just four productions (i.e., one for each rule of the reduction system), plus some “instances” of them. The first production pσ is depicted in Fig. 7: the e-graph on the left-hand
side (center, right-hand side) is Lσ (Kσ and Rσ, respectively). The effect of the rule
1	1	1
is described by the names of the nodes: as an example, the nodes identified by y
and wi’s, which are distinct in Lσ, are made equivalent in Rσ. Please note that the
1	1
node identifiers are of course arbitrary: they correspond to the actual elements of
the set of nodes, and they are used just to represent the span of morphisms.








Fig. 7. A production of Gσ encoding reduction (r1).

Fig. 8. A production of Gσ encoding reduction (r3).


•	•	•

Fig. 9. A production of Gσ encoding reduction (r4).

The rule mimics (a disjoint variant of) rule (r1) in the reduction semantics (see Definition 3.2). Constraining the matches to be regular monos ensures that the production is not applied to a graph where nodes y and wi’s are equivalent. This is too restrictive, since a reduction step can be performed if name x coincides with either y or w. Hence, two additional productions are needed: they are variations of pσ, where nodes xi’s are equivalent either to the node y or to the nodes wi’s. We leave these productions unnamed, since they play a minor role in the paper. An analogous production pσ (an the corresponding instances) is needed for rule (r2).
Correspondingly to rule (r3) we introduce a production pσ. Note that nodes y and wi’s are already coalesced and the restriction operator is not required, as depicted in Fig. 8. Additionally, an instance where the two names coincide, and the corresponding nodes are thus equivalent, has to be included.
Finally, production pσ, depicted in Fig. 9, mimics the removal of a match opera- tor as expressed by rule (r4) in the reduction semantics. The correct application of the rule is ensured by the fact that e-graph morphisms must preserve equivalences. Observe that, during the reductions, some nodes might be left isolated. These correspond to names that are not referred to anymore by any operator. Hence, a process P is actually related to a class of e-graphs, including GP and all the e-graphs
which differ from GP for the presence of additional isolated nodes.
There is no graphical translation of the context rules since the graph rewriting mechanism allows to apply graph productions in any context (more precisely, a graph production can be applied only if the so-called dangling condition asking that no edge is left dangling is satisfied, but this condition is vacuous here since nodes are never deleted).











Fig. 10. The e-graphs obtained by applying to GPe in Fig. 5(a) first pσ and then pσ.
1	3

Fig. 11. The e-graphs obtained by applying to GPm in Fig. 6 first pσ and then pσ.
Simulating reductions
Consider again the process Pe = (νw)(x(y) | xw | w(z) | yz), and its graphical depiction GPe in Fig. 5(a). A possible derivation consists of the two steps below, applying rules r1 and r3, respectively:
(νw)(x(y) | xw | w(z) | yz)	→	(w(z) | yz){y/w} = y(z) | yz	→	0
Being the context rules immaterial, we end up by applying to the graph in the left-hand side of Fig. 10 first the rule pσ, and then the rule pσ. The derivation (the
1	3
derived graphs) is shown in Fig. 10.
Consider now the process Pm = (νw)([y = w].0 | x(y) | x¯w), whose e-graph representation can be found in Fig. 6. Again a derivation consisting of two steps is possible, applying rules (r1) and (r5):
(νw)([y = w].0 | x(y) | x¯w)  →  (νw)([w = w].0)  →  0
The graphs produced in the corresponding e-graph derivation, using rules pσ and
pσ, can be found in Fig. 11.
We next state the sound and complete correspondence between graph derivations and process reduction semantics, after introducing some notation. First, note that for any process P , the graph GP has an equivalence class that can be seen as the root of the graph (intuitively, in the quotient, this is the node representing the process P ). Then, we say that a rule application to GP is a top derivation if the image of the match involves a node in the root.
Proposition 3.5 (derivations vs reductions) Let P be a process. (i) if P → Q, then Gσ entails a top derivation GP =⇒ d via a regular mono match, and d is isomorphic to GQ, up-to the occurrence of isolated nodes. Vice versa, (ii) if Gσ entails a top derivation GP =⇒ d via a regular mono match, then there exists a process Q such that P → Q, and d is isomorphic to GQ, up-to the occurrence of



Fig. 12. The e-graph encoding of the process P ' .


Fig. 13. The e-graphs obtained by applying to GP '  in Fig. 12 first pσ and then pσ.
m	1	5

isolated nodes.

Intuitively, a reduction step is simulated by applying an enabled production, i.e., by finding a match covering a sub-graph containing a root node. The “garbage collection” phase is needed in order to remove all those name nodes that are not re- ferred to anymore by an operator. Similarly, the restriction to top derivations forces the match to be applied to top operators, forbidding the occurrence of a reduction inside the outermost match operators. This constraint could be “embedded” in the graphical representation by using a special mark (e.g., a “go” edge) which is required and then propagated by the graph rewriting rules (see, e.g., [8,9]).
In the paper [1] a partial order concurrent semantics on rewrites is developed for graphs with equivalences, which is thus inherited by process calculi encoded in this formalism. A detailed description of these aspects is outside the scope of this paper. Let us only notice that in the derivation considered for process Pm (see Fig. 11) the two steps are causally related. In fact, the production pσ requires the nodes y2 and w2 to be equivalent, and such equivalence is generated by the application of pσ.
Consider now the process P ' = (νw)([y = y].0 | x(y) | x¯w), which differs from
the process Pm because the match is already satisfied, and its graphical representa-
tion in Fig. 12. The same sequence of rule applications as for the derivation depicted in Fig. 11 can now be replicated, and the result (the derived graphs) is presented

in Fig. 13. With respect to the derivation in Fig. 11, production pσ
now reads

the equivalence class containing {y2, y3}, which is in the initial graph, and thus no casual dependency holds between the production occurrences. Formally, the compo- nents of the derivation are sequentially independent, since the coalescing of nodes corresponding to the names y and w is not needed for the second direct derivation.

Conclusions and further works
This paper discusses the expressiveness of a novel formalism for the analysis of dis- tributed systems, graphs with equivalences: (hyper-)graphs equipped with an equiv- alence relation over their nodes. The formalism has been introduced in [1], and it has been shown there to be amenable to the usual tools of the dpo approach to graph transformation (in particular, the theoretical results associated to the con- current features of the approach). In this paper we test the formalism against the encoding of a simple process calculus with name mobility, the solo calculus, proving it suitable for the purpose of simulating the reduction semantics of the calculus.
An obvious strand of research we are currently pursuing it to properly establish the connection between the category of graphs and of graphs with equivalences, making precise the correspondence briefly hinted at in Section 2. On a related note, observe that e-graphs resemble the so-called structures, as defined in [6]. Indeed, along the same lines of [12, Section 6], the category EGraph can be proved quasi- adhesive, thus inheriting part of the rich theory developed for such formalism.

References
P. Baldan, F. Gadducci, and U. Montanari. Concurrent rewriting for graphs with equivalences. In
C. Baier and H. Hermanns, editors, Concurrency Theory, volume 4137 of Lecture Notes in Computer Science, pages 279–294. Springer, 2006.
L. Cardelli and A. Gordon. Mobile ambients. Theoretical Computer Science, 240:177–213, 2000.
A. Corradini, U. Montanari, and F. Rossi. Graph processes. Fundamenta Informaticae, 26:241–265, 1996.
A. Corradini, U. Montanari, F. Rossi, H. Ehrig, R. Heckel, and M. L¨owe. Algebraic approaches to graph transformation I: Basic concepts and double pushout approach. In Rozenberg [16], pages 163–245.
F. Drewes, A. Habel, and H.-J. Kreowski. Hyperedge replacement graph grammars. In Rozenberg [16], pages 95–162.
H. Ehrig, A. Habel, H.-J. Kreowski, and F. Parisi-Presicce. Parallelism and concurrency in high-level replacement systems. Mathematical Structures in Computer Science, 1:361–404, 1991.
H. Ehrig, J. Kreowski, U. Montanari, and G. Rozenberg, editors. Handbook of Graph Grammars and Computing by Graph Transformation, Vol. III: Concurrency, Parallelism and Distribution. World Scientific, 1999.
F. Gadducci. Term graph rewriting and the π-calculus. In A. Ohori, editor, Programming Languages and Semantics, volume 2895 of Lecture Notes in Computer Science, pages 37–54. Springer, 2003.
F. Gadducci and U. Montanari. A concurrent graph semantics for mobile ambients. In S. Brookes and
M. Mislove, editors, Mathematical Foundations of Programming Semantics, volume 45 of Electronic Notes in Theoretical Computer Science. Elsevier Science, 2001.
F. Gadducci and U. Montanari. Graph processes with fusions: concurrency by colimits, again. In H.-J. Kreowski, U. Montanari, F. Orejas, G. Rozenberg, and G. Taentzer, editors, Formal Methods (Ehrig Festschrift), volume 3393 of Lecture Notes in Computer Science, pages 84–100. Springer, 2005.
P. Gardner and L. Wischik. Explicit fusion. In M. Nielsen and B. Rovan, editors, Mathematical Foundations of Computer Science, volume 1893 of Lecture Notes in Computer Science, pages 373–382. Springer, 2000.
S. Lack and P. Sobocin´ski. Adhesive and quasiadhesive categories. Informatique Th´eorique et Applications/Theor. Informatics and Applications, 39:511–545, 2005.
C. Laneve and B. Victor. Solos in concert. Mathematical Structures in Computer Science, 13:675–683, 2002.


R. Milner, J. Parrow, and D. Walker. A calculus of mobile processes. Part I and II. Information and Computation, 100:1–77, 1992.
J. Parrow and B. Victor. The fusion calculus: Expressiveness and simmetry in mobile processes. In
V. Pratt, editor, Logic in Computer Science, pages 176–185. IEEE Computer Society Press, 1998.
G. Rozenberg, editor. Handbook of Graph Grammars and Computing by Graph Transformation, Vol. I: Foundations. World Scientific, 1997.
