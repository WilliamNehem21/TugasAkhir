

Electronic Notes in Theoretical Computer Science 230 (2009) 161–187
www.elsevier.com/locate/entcs

Sheaves and Geometric Logic and Applications to Modular Verification of Complex Systems 1
Viorica Sofronie-Stokkermans2
Max-Planck Institut fu¨r Informatik, Stuhlsatzenhausweg 85, Saarbru¨cken, Germany

Abstract
In this paper we show that states, transitions and behavior of concurrent systems can often be modeled as sheaves over a suitable topological space. In this context, geometric logic can be used to describe which local properties, of individual systems, are preserved, at a global level, when interconnecting the systems. The main area of application is to modular verification of complex systems. We illustrate the ideas by means of an example involving a family of interacting controllers for trains on a rail track.
Keywords: Geometric logic, sheaves, modular verification


Introduction
Complex systems, consisting of several components that interact, arise in a natural way in a wide range of applications. The components may be complex themselves (they may e.g. contain a database; may have their specific internal logic and an appropriate inference mechanism; a planning mechanism, etc.), or may be simple - but even then their composition can complicated because of the necessity to take into account the interaction between the single components. One of the main problems that arise in the verification of such complex systems is the state explosion problem: the state space can grow exponentially with the number of components. Symbolic representations of states and symbolic model checking have greatly increased the size of the systems that can be verified. However, many realistic systems are still too large to be handled. It is therefore important to find techniques that can be used to

1 This work was partly supported by the German Research Council (DFG) as part of the Transregional Collaborative Research Center “Automatic Verification and Analysis of Complex Systems” (SFB/TR 14 AVACS). See www.avacs.org for more information.
2 Email: sofronie@mpi-inf.mpg.de

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.02.024

further extend the size of the systems that can be verified. One possibility is to check properties in a modular way (i.e. verify them for the individual components, infer that they also hold in the system obtained by the interconnection of the individual components, and then use them to deduce additional properties of the system). Not all properties are preserved by interconnection: for instance deadlocks might occur when interconnecting deadlock free systems. The main goal of this paper is to offer an answer to an important question in verification:
Which properties of complex systems can be checked in a modular way?
To answer such questions, in this paper we use an analogy with phenomena in topology and algebraic geometry, where sheaves are used to describe locally defined objects which can be patched together into a global object. Thus, sheaf theory allows to establish links between “local” and “global” properties. We show that, given a family of interacting systems, states, actions, transitions, behavior in time can often be modeled by sheaves over a suitable topological space (where the topol- ogy expresses how the interacting systems share the information). Many properties of systems can be expressed as assertions about states, actions, transitions, behavior in time. The sheaf semantics allows us to prove, by using results from geometric logic, that those properties of systems that can be expressed by cartesian axioms are preserved after interconnecting the systems.
The starting point of our research is the work of Goguen [6], who uses sheaves to model behavior in an ’interval of observation’, and Monteiro and Pereira [13], where behavior is modeled by sheaves of monoids. The idea of modeling states, actions and transitions by sheaves with respect to a topological space, and of using geometric logic for studying the link between properties of the components and properties of the systems that arises from their interconnection occurs, to the best of our knowledge, for the first time in our previous work [16,17,18]. We present an overview of our results in [17,18] together with new results which illustrate how sheaf theory can be used for the modular verification of complex systems. We illustrate all the notions introduced by means of a running example involving a family of interacting controllers controlling a subsets of consecutive trains on a linear, loop- free, rail track. The main contributions of the paper are summarized below:
We start with a presentation of our previous results described in [16,17,18], where we showed that states, parallel actions, transitions and behavior in time can be modeled by sheaves. Concerning these topics, the main contribution of this paper consists in illustrating the various notions we use (definition of systems, states, parallel actions, transitions, conditions on transition relations, categorical constructions, covers, gluing and sheaf properties) by means of a running example.
In addition to the model of behavior we considered in [16,17,18], we also analyze a description of behavior by traces of execution (modeled by free monoids and partially commutative monoids). We analyze gluing and sheaf properties also in this context. We pay special attention also in this case to identifying situations when the stalks of the sheaves are isomorphic to the behavior of the individual systems, whereas the global sections are isomorphic to the behavior of the colimit

of these systems. For this, we use results on sheaf representation in universal algebra. We establish links with existing results in the study of Petri nets and Mazurkiewicz traces [3] and on modeling behavior by sheaves of monoids [13].
We use geometric logic for describing properties which can be checked modularly. We illustrate the ideas on the running example, and describe a simple complex system for trains for which safety and lifeness can be checked in a modular way.
Structure of the paper. The paper is structured as follows. In Section 2 we present a model for systems (including also their states, parallel actions and transitions). Section 3 contains the definition of a category of systems and the description of pullbacks and colimits in this category. In Section 4 we give a model for complex, interacting systems, and motivate the use of sheaf theory. Sections 5–8 describe our sheaf-theoretic semantics for states, parallel actions, transitions and behavior. In Section 9 geometric logic is used to test preservation of ’local’ properties under connection of systems. Several examples are given in Section 10.

Systems
Our aim is to model interconnected systems. We assume systems are described by:
a set X of control variables of the system, a set Γ of constraints on X expressed in a language L,
a set A of atomic actions, and a set C of constraints on A.
Let Σ = (Sort, O,P ) be a signature, consisting of a set Sort of sorts, a set O of operation symbols and a set P of predicate symbols. For a (many-sorted) set of variables X = {Xs}s∈Sort let FmaΣ(X) be the set of formulae over Σ.
A Σ-structure is a structure M = ((Ms)s∈Sort, {fM }f∈O, {RM }R∈P ) where if f ∈ O has arity s1 ... sn → s then fM : Ms1 × ... × Msn → Ms and if R ∈ P has arity s1 ... sn then RM ⊆ Ms1 × ... × Msn . The class of all Σ-structures is denoted StrΣ. If M ∈ StrΣ, s : X → M is a sort-preserving assignment, and φ ∈ FmaΣ(X), (M, s) |= φ (abbreviated by s |= φ) is defined in the usual way (cf. [1], Ch. 1).
Definition 2.1 A system S is a tuple (Σ, X, Γ, M, A,C), where
Σ = (Sort, O,P ) and X = {Xs}s∈Sort are as specified above; together they define the language LS of the system S;
Γ ⊆ FmaΣ(X) is a set of constraints, which is closed with respect to the se- mantical consequence relation 3 |=M ;
M ∈ StrΣ;
A is a set of actions; for every a ∈ A, a set Xa ⊆ X of variables on which a depends, and a transition relation Tra ⊆ Sta × Sta, where Sta = {s|Xa | s : X → M, s |= Γ} are specified;

3 The relation |=M is defined by Γ |=M φ if and only if for every assignment s : X → M of values in M to the variables in X, if s |= γ for every γ ∈ Γ, then s |= φ.

C is a set of constraints on actions, expressed by boolean equations over FB(A) (the free boolean algebra generated by A) stating e.g. which actions can (or have to) be executed in parallel, and which cannot; C must contain all boolean equations that can be deduced from C.
In what follows, we may refer to any of the components of a system S by adding S as a subscript, e.g. ΣS for its signature. Xa will denote the minimal set of variables on which a ∈ AS depends, and Tra the transition relation associated with a.
For the sake of simplicity, in the examples below we will only mention explicitly the axioms in Γ and C and not all their consequences.
Example 2.2 We consider a system consisting of n consecutive trains on a linear track controlled by a radio controller (cf. also [8]). The trains report their position to the controller at fixed time intervals Δt. The controller analyzes the distances between successive trains (we assume that certain security distance treshholds l0 < l1 < ··· < lm < ... and corresponding maximal speed limits maxSpeed(1) < ··· < maxSpeed(m) < . . . , deemed to be safe for the trains, are known) and updates the movement modes of trains accordingly. A train with movement mode k can move in the next time interval Δt with an arbitrary speed between a minimal speed and the maximal speed limit of mode k, maxSpeed(k). The system is modeled as follows:
Language: Σ = (Sort, O,P ), where Sort = {real, nat};
O = {+, −, minSpeed, maxSpeed, succ}, where +, −:real, real→real, minSpeed is a constant of sort real, maxSpeed a function of arity nat → real, and succ of arity nat → nat.
P = {≤}, where ≤ has arity real, real.

n
i=1
{TrainIndexi, ActualPosi, RepPosi, Modei}, where TrainIndexi con-

trols the number of train i on the line track, and ActualPosi, RepPosi and
Modei control the actual, resp. reported position and the movement mode of
train i respectively.
Constraints: Γ = {succ(TrainIndexi) = TrainIndexi+1 | i ∈ {1,...,n − 1}}.
Model M =(Mnat, Mreal, +, −, minSpeed, maxSpeed, succ, ≤), where Mnat = N; Mreal = R; +, − are addition and subtraction on R, succ : N → N is the successor function, minSpeed ∈ R, maxSpeed : N → R associates with a mode k ∈ N the maximal allowed speed in mode k; ≤ is the order relation on R.
Actions: A = {reporti | i ∈ {1,..., n}}∪ {update}∪ {movei | i ∈ {1,..., n}}.
reporti depends on the variables Xri = {ActualPosi, RepPosi, Modei}.
If s, s' : X → M then (s|Xri , s' r ) ∈ Trri iff s(Modei) = 0 

|X i
s'(RepPosi) = s(ActualPosi)
s'(ActualPosi) = s(ActualPosi).

update depends on Xu =  i∈{1,...,n}{ActualPosi, RepPosi, Modei}.
If s, s' : X → M then (s|Xu , s' u ) ∈ Trri if and only if for all i ∈ {1,..., n}
the following hold:	(i) s(Modei) = 0,  (ii) s'(ActualPosi) = s(ActualPosi),
(iii) s'(RepPosi) = s(ActualPosi), and (iv) s'(Modei) is updated according to the following rules: s'(Mode1) > 0 and for all i ≥ 2:

if lk < s(RepPosi−1) − s(RepPosi) ≤ lk+1 then s'(Modei) = k + 1.
movei depends on Xmi = {ActualPosi, Modei}. It is enabled at a state s iff s(Modei) > 0 for all i ∈ {1,..., n}; it changes ActualPosi according to the value of Modei as follows, for i ∈ {1,..., n}:
s'(ActualPosi)∈[RepPosi+Δt∗minSpeed, RepPosi+Δt∗maxSpeed(s(Modei))]; and it updates the value of Modei to 0: s'(Modei) = 0 for i ∈ {1,..., n}.
Constraints on actions: C = {report1 = report2 = ··· = reportn = update}∪ 
{reporti ∧ movei = 0 | i ∈ {1,..., n}}∪ {move1 = ··· = moven}.

States, parallel actions
It is important to describe the states of a system and the actions which can be performed in parallel (which we here name admissible parallel actions).
Definition 2.3 Let S = (Σ, X, Γ, M, A,C) be a system.
A state of S is an assignment s : X → M satisfying all formulae in Γ. The set of states of the system S is St(S) = {s : X → M | s |= Γ}.
The admissible parallel actions of S are sets of actions, represented by maps f : A → {0, 1} that satisfy all constraints in C. The set of admissible parallel actions of S is the set P a(S) = {f : A → {0, 1}| f satisfies C}.
Below we restrict our attention to ﬁnite systems, i.e. systems whose signatures, sets of control variables and sets of actions are finite; this suffices for practical appli- cations and avoids having to consider infinitely many actions occurring in parallel.

Example 2.4 Consider the system S in Example 2.2 with n ≥ 2. A state is a map
s : X → M which satisfies Γ. For instance, any map s : X → M such that:
s(TrainIndex1) = 1, s(TrainIndex2) = 2,..., s(TrainIndexn) = n or
s(TrainIndex1) = 100, s(TrainIndex2) = 101,..., s(TrainIndexn) = 100+ (n − 1). is a state of S. If s(TrainIndex1) = 1 and s(TrainIndex2) = 3, s cannot be a state.
An admissible parallel action is a map f : A → {0, 1} which satisfies the constraints in C. Examples of admissible parallel actions are
f (report1) = f (report2) = ··· = f (reportn) = f (update) = 1, and 0 otherwise,
f (move1) = ··· = f (moven) = 1 and 0 otherwise.
Any map f with f (move1) = f (report1) = 1, or with f (reporti) = 0 but f (update) = 1, is not an admissible parallel action, since it does not satisfy the constraints in C.

Transitions
Let S  = (Σ, X, Γ, M, A,C) be a system.	Let TrS(a)  =  {(s1, s2)  | s1, s2 ∈
St(S), (s1|Xa , s2|Xa ) ∈ Tra, s1(x) = s2(x) if x /∈ Xa}.  We extend the notion of

transition to parallel actions. For this we present two (non-equivalent) properties of transitions that express compatibility of the actions in an admissible parallel action:
(Disj)	Let f ∈ P a(S),s ∈ St(S) such that for every a ∈ f−1(1) there is an sa ∈
St(S) with (s|Xa , sa a ) ∈ Tra. Then for all a, b ∈ f−1(1) and x∈Xa∩Xb,
sa(x) = sb(x) (the new local states agree on intersections). Then,
TrS(f ) = {(s, t) | s, t ∈ St(S), (s|Xa , t|Xa ) ∈ Tra for every a such that

f (a) = 1 and s(x) = t(x) if x /∈ 

a,f (a)=1
Xa}.

The property (Disj) applies when a parallel action f : A → {0, 1} is admissible iff its components do not consume common resources. This happens e.g. if for all a1, a2 ∈ A with f (a1) = f (a2) = 1, either a1 = a2 ∈ C or Xa1 and Xa2 are disjoint.
In concurrency theory, this property is called “real parallelism” or “independence”.
Example 2.5 Consider the example in Section 2.2. Let f : A → {0, 1} be an admissible parallel action. We have two possibilities:
f (report1) = ··· = f (reportn) = f (update) = 1 and 0 otherwise.
The transition relation of this parallel action updates the value of each vari- able RepPosi according to the transition relation of reporti, resp. update. The changes are not contradictory, since the effect of update agrees with the effect of report1,..., reportn on the variables in Xu ∩ Xri . Thus, (Disj) holds.
f (report1) = ··· = f (reportn) = f (update) = 0 and f (move1) = ··· =
f (moven) = 1 and f is 0 otherwise. As the actions movej,j = 1,...,n de-
pend on disjoint sets of variables, (Disj) is satisfied also in this case.
The transition relation of this parallel action updates the value of each variable ActualPosi. Since the sets of variables these actions depend upon, namely Xmi , are mutually disjoint, these changes cannot be contradictory.

(Indep) Assume that if a = b ∈ C then Xa = Xb and Tra = Trb, and a and b can both be identified with one action: the parallel execution of a, b. Let f ∈ P a(S),s ∈ St(S). We identify all a, b ∈ A with a = b ∈ C
and f (a) = f (b) = 1. Let {b1,..., bm}⊆ f−1(1). We assume that:
g : A → {0, 1}, defined by g(a) = 1 iff a ∈ {b1,..., bm}, is in P a(S);
if s→b1 s1→b2 s2→... →sm−1 b→m t then for every permutation σ of {1,..., m},

there exist states tσ,..., tσ
with
bσ(1)tσbσ(2)tσ→ ... →tσ
bσ(m)
→ t

1	m−1
s → 1 → 2
m−1

Then TrS(f ) = {(s, t) | s, t ∈ St(S), and ∃s0, s1,..., sn−1, sn ∈ St(S) s.t. s0 = s, sn = t, and (si−1, si) ∈ TrS(ai), for all 1 ≤ i ≤ n}.

It is easy to see that if (s, t) ∈ TrS(f ) then s(x) = t(x) for every x /∈ 

a,f (a)=1
Xa.

The property (Indep) reflects how transitions are interpreted when actions to be performed in parallel do consume common resources. It applies if the state reached after executing an action is uniquely determined: the fact that all components of a parallel action f : A → {0, 1} can be applied at a state s is a necessary condition for f to be applicable at state s, but in general not sufficient (in addition, one

has to ensure that there are enough resources to perform all actions). Condition (Indep)(i) holds e.g. if C is the set of all consequences of a set C0 consisting only of formulae of the form a1 = a2 and a1 ∧ a2 = 0. Condition (Indep)(ii) states that the final state does not depend on the order in which the actions are executed (it is related to the notions of interleaving and permutable actions used in concurrency).
Example 2.6 We consider a variant of Example 2.2, in which we assume that there is no control unit, but all trains have access to all information about the positions of all trains. The trains report all together and move all together. The actions are
A = {report1,..., reportn}∪ {move1,..., moven}, with constraints C = {report1 =
··· = reportn}∪ {move1 = ··· = moven}∪ {reporti ∧ movei = 0 | i ∈ {1,..., n}}. Let f : A → {0, 1} be an admissible parallel action. Then f−1(1) is either ∅ or
{report1,..., reportn} or {move1,..., moven}. As in all cases the actions in f−1(1)
depend on disjoint sets of variables, the final state does not depend on the order in which the actions would be performed sequentially.
A category of systems
Essential to our model for communication is that systems have common subsystems through which information exchange is made. Let S, T be two systems. We say that S is a subsystem of T (denoted S >→ T ) if ΣS ⊆ ΣT , XS ⊆ XT , AS ⊆ AT , the constraints in ΓS (resp. CS) are consequences of the constraints in ΓT (resp. CT ), and MS = MT |ΣS (the reduct of MT to the signature ΣS).
Let S >→ T . If we regard a transition in T from the perspective of S, some variables in S may change their values with no apparent cause, namely if some action in AT but not in AS is performed, which depends on variables in XS. If this cannot be the case, we call the subsystem S >→ T transition-connected. Formally:
Definition 3.1 S is a transition-connected (t.c.) subsystem of T (denoted S ‹→ T ) if S >→ T and the following two conditions hold:
(T1) If a ∈ AT and Xa ∩ XS /= ∅ then a ∈ AS, and Xa = Xa ∩ XS.
T	S	T
(T2) If a ∈ AS, s1, s2 ∈ St(T ), and (s1|Xa , s2|Xa ) ∈ Tra then (s1|Xa , s2|Xa ) ∈ Tra .
T	T	T	S	S	S
It is easy to see that the relation ‹→ is a partial order on systems.
Example 3.2 Consider the system S = (Σ, X, Γ, M, A,C) in Example 2.2. Let 1 ≤
k ≤ l ≤ n and I = {k,..., l}. Consider the restriction Sl = (Σ,Xl , Γl , M, Al , Cl )
k	k	k	k	k
of S to the consecutive trains controlled by the variables in {TrainIndexi | i ∈ I}.
Xl =  i∈I{TrainIndexi, ActualPosi, RepPosi, Modei},
l = {succ(TrainIndexi) = TrainIndexi+1 | i ∈ {k,...,l − 1}},
l = {reporti | i ∈ I}∪ {update}∪ {movei | i ∈ I}, and
l is the restriction of C to the actions in Al :
Cl = {reporti=update | i∈I}∪ {reporti∧movei=0 | i∈I}∪ {movek= ... =movel}.
Condition (T1) obviously holds: if an action of S depends on variables known in Sl ,

then the action is known in Sl . Condition (T2) obviously holds for {reporti | i ∈ I}∪ {movei | i ∈ I} and, for update, for all trains which follow a train known in Sl . For the first train (T2) is a consequence of the fact that the mode update restrictions
in S are stronger than those in Sl (any mode allowed in S is still allowed in Sl ).
We define a category TcSys having as objects systems, and a morphism S ‹→ T between S and T whenever S is a t.c. subsystem of T . TcSys has pullbacks (infimums with respect to this order of t.c. subsystems of a given system; we will denote this operation by ∧) and colimits of diagrams of t.c. subsystems of a given system.
Proposition 3.3 The category TcSys has pullbacks.
Proof : Let S1 ‹→ S and S2 ‹→ S, where S = (Σ, X, Γ, M, A,C), Si = (Σi, Xi, Γi, Mi, Ai, Ci). Then Mi = M|Σ , and for every a ∈ Ai, Xa = Xa ∩Xi (i = 1, 2) Hence,
i	i	S
for every a ∈ A1 ∩ A2, Xa ∩ X2 = Xa ∩ X1 = Xa ∩ X1 ∩ X2.
1	2	S
Let S12 = (Σ1∩Σ2, X1∩X2, Γ1∩Γ2, MS|Σ1∩Σ2 , A1∩A2, C1∩C2), and such that
for every a ∈ A1∩A2, Xa  = Xa∩X2 = Xa∩X1 = Xa∩X1∩X2, and Tra	=
12	1	2	S	12
{(s1|Xa , s2|Xa ) | s1, s2 ∈ St(S1), (s1|Xa , s2|Xa ) ∈ Tra }∪ {(s1|Xa , s2|Xa ) | s1, s2 ∈

12	12
1	1	S1
12	12

St(S2), (s1|Xa , s2|Xa ) ∈ Tra }. It is easy to see that S12 is a transition-connected
2	2	S2
subsystem of both S1 and S2, and has the universality property of a pullback. 
Proposition 3.4 Let S = (Σ, X, M, Γ, A,C) be a system and {Si ‹→ S | i ∈ I} a family of transition-connected subsystems of S, where for every i ∈ I, Si = (Σi, Xi, Mi, Γi, Ai, Ci). The colimit of this family in SYSil is the system S with
ΣS =  i∈I Σi, XS =  i∈I Xi, MS = M| S	Σi , ΓS = ( i∈I Γi)  (the family of
•
			

all logical consequences of 
Γ ), A
= i ∈I
A ,C 
= ( 
C )• (the family

i∈ I i	S
i∈I	i	S
i∈I	 

of all logical consequences of	i∈I Ci), and where for every a ∈	i∈I Ai Xa  =
S
a	a

a∈A
Xi , and Tr  = {(s1|X a , s2|X a ) | s1, s2 ∈ St(S), and for every i ∈ I with a ∈

i	S	S	S
Ai, (s1|Xa , s2|Xa ) ∈ Tra }.
i	i	Si
Proof : (Sketch) One needs to show that for every i ∈ I, Si is a transition-connected subsystem of S, and that S satisfies the universality property of a colimit. The proof is long, but straightforward.	 
Example 3.5 Consider the system S in Example 2.2, and two restrictions S1 = Sn
and S2 = Sl constructed as in Example 3.2. The pullback of S1 and S2 is S12 = Sl
1	k
(defined as in Example 3.2 if k ≤ l, or the system with the empty set of control variables and actions if l < k). The colimit S of the diagram {S1, S2, S12} (with
transition-connected morphisms Sl ‹→ Sn, Sl ‹→ Sl has the following components:

ΣS = Σ; MS = M ;
k	k	k	1

XS =   i∈{1,...,l}∪{k,...,n}{TrainIndexi, ActualPosi, RepPosi, Modei},
ΓS = {succ(TrainIndexi) = TrainIndexi+1 | i ∈ {1,...,l − 1}∪ {k,...,n − 1}}•,
AS =  i∈{1,...,l}∪{k,...,n}{reporti, movei}∪ {update};
CS = ({reporti = update | i ∈ {1,..., l}∪ {k,..., n}}∪ {reporti ∧ movei = 0 | i ∈
{1,..., l}∪ {k, ..., n}}∪ {move1 = ··· = movel}∪ {movek = ··· = moven})•.


	
If k ≤ l then S coincides with S. If l < k − 1 then XS /= X, so S is obviously different from S. Assume now that l = k − 1. Then XS = X, AS = A, CS = C, but ΓS /= Γ (the constraint succ(TrainIndexk−1) = TrainIndexk cannot be recovered from
Γl ∪ Γn), hence S is different from S also in this case.
1	k


Modeling families of interacting systems
When analyzing concrete complex systems, we tend to be interested in a subcategory of TcSys, containing only the systems relevant for a given application. To this end, we assume a family InSys of interacting systems is specified, fulfilling:

All S ∈ InSys are transition-connected subsystems of a system S with AS finite.
InSys is closed under all pullbacks S1 ∧ S2 of t.c. subsystems S1, S2 of S.
(InSys, ∧) is a meet-semilattice.
The first condition enforces the compatibility of models on common sorts and the finiteness of AS for every S ∈ InSys; the second and third condition ensure that all systems by which communication is handled are taken into account. A system obtained by interconnecting some elements of InSys can either be seen as the set of all elements of InSys by whose interaction it arises (a subset of InSys which is downwards-closed with respect to ‹→) or as the colimit of such a family of elements. We define Ω(InSys) as consisting of all families of elements of InSys which are closed under transition connected subsystems. Clearly, Ω(InSys) is a topology on InSys.
Note: Ω(InSys) is the Alexandroff topology associated with the dual of the poset (InSys, ‹→). Since we assumed that InSys is finite and closed under pullbacks, this topology coincides with the Scott topology associated with the dual of (InSys, ‹→).

Example 4.1 Consider now the extension of the example in Section 2.2 considered in Example 3.5: Let k ≤ l ∈ {1,..., n}, let I1 = {k,..., n}, I2 = {1,..., l}, I12 =
{k,..., l}, and let InSys = {S1, S2, S12} be the family consisting of the subsys-
tems of S = (Σ, X, Γ, M, A,C) described in Section 2.2 corresponding to the sets
of trains with indices in I1, I2 and I12 respectively: S1 = Sn, S2 = Sl , S12 = Sl .
k	1	k
Then InSys satisfies conditions (i), (ii) and (iii) above.  The system obtained by
interconnecting S1, S2, S12 can be regarded either as the set {S1, S2, S12} or as the colimit of the diagram defined by these systems, which coincides with the sys- tem S defined in Section 2.2. In this case, Ω(InSys) consists of the following sets
{∅, {S12}, {S1, S12}, {S2, S12}, {S1, S2, S12}}.

Our goal is to express the links between components of a system and the result of their interconnection. We start from the observation that compatible local states can be ’glued’ into a global state (similar for parallel actions, transitions). For expressing such gluing condition in a general setting, we use sheaf theory.

4.1	Sheaf theory: An introduction
In what follows, notions from category theory are assumed known. For details cf.
[9] or [12]. Categories and sheaves will be denoted in sans-serif style, e.g. Set, Sh(I).
Let I be a topological space, and Ω(I) the topology on I.
Definition 4.2 A presheaf on I is a functor P : Ω(I)op → Sets. Let U ⊆ V be
open sets in I, and iV : U ‹→ V the inclusion morphism in Ω(I). The restriction to
U , P (iV ) : P (V ) → P (U ) is denoted by ρV .
U	U
A sheaf on I is a presheaf F : Ω(I)op → Sets that satisfies the following condition:
for each open cover (Ui)i∈I of U and family of elements si∈F (Ui) s.t. for all

i, j, ρUi
i	j
(si)=ρUj
(sj), there is a unique s∈F (U ) with ρU (s)=si for all i.

The morphisms of (pre)sheaves are natural transformations. We denote by PreSh(I) the category of presheaves over I and by Sh(I) the category of sheaves over I.
Definition 4.3 The stalk of a sheaf F on I at a point i ∈ I is the colimit Fi =

lim
−→i∈U
F (U ), where U ranges over all open neighborhoods of i.  The assignment

F '→ Fi defines the stalk functor at i, Stalki : Sh(I) → Set.
Sheaves can be defined also in a different way. An indexed system of sets (Fi)i∈I

can alternatively be regarded as a map f : F = 

i∈I
Fi → I, with the property that

for every x ∈ F , f (x) = i if and only if x ∈ Fi. If the index set I has a topology, then the set F can be endowed with a topology such that f is continuous (i.e. the sets in the family (Fi)i∈I are continuously indexed).
Definition 4.4 A bundle over I is a triple (F, f, I) where F and I are topological spaces and f : F → I is continuous. For every i ∈ I, f−1(i) will be denoted by Fi.
Then F =	Fi. Let (F, f, I) and (G, g, I) be two bundles over I. A morphism
between (F, f, I) and (G, g, I) is a continuous map h : F → G such that g ◦ h = f . The category of bundles over I is denoted Sp/I.
Let LH/I be the full subcategory of Sp/I with objects (F, f, I), where f : F → I a local homeomorphism (i.e. for every a ∈ F there are open neighborhoods U and U' of a respectively f (a) such that f : U → U' is a homeomorphism).
Definition 4.5 Let (F, f, I) be a bundle over I. A partial section defined on a open subset U ⊆ I is a continuous map s : U → F with the property that f ◦ s is the inclusion U ⊆ I. A section defined on I is called global section. The set of all partial sections over the open subset U of I will be denoted by Γ(F, f )(U ).
The following links between (pre)sheaves and bundles exist:
For every bundle (F, f, I) let Γ(F ) = {s : I → F | s continuous and f ◦ s = idI}, the set of all global sections of F . This defines a functor Γ : Sp/I → PreSh(I).
Let F be a presheaf on I. For every i ∈ I let Fi be the stalk of F at a point i ∈ I. The collection of stalks (Fi)i∈I is an I-indexed family of sets. Let D(F ) denote the disjoint union of the stalks, and let π : D(F ) → I be the canonical

projection on I defined by π(x) = i iff x ∈ Fi. For s ∈ F (U ) and i ∈ U , let si be the image of s in Fi. The map s : U → D(F ), s(i) = si defines a partial section of π : D(F ) → I; we impose on D(F ) the coarsest topology for which all such sections are continuous. D(F ) = (D(F ), π,I) is a bundle. This construction defines a functor D : PreSh(I) → Sp/I.
Theorem 4.6 (cf. [9,12]) The functor D : PreSh(I) → Sp/I preserves ﬁnite lim- its and is left adjoint to Γ : Sp/I → PreSh(I). The functors D, Γ restrict to an equivalence of categories between Sh(I) and LH/I.
Γ ◦ D : PreSh(X) → Sh(X) is known as the sheaﬁﬁcation functor.
Theorem 4.7 (cf. [9,12]) The inclusion Sh(X)→PreSh(X) has a left adjoint,
Γ◦D : PreSh(X)→Sh(X). The sheaﬁﬁcation functor Γ◦D preserves all ﬁnite limits.
States, partial actions
Let InSys be a family of systems satisfying conditions (i), (ii), (iii) in Section 4, and Ω(InSys) be the topology on InSys consisting of all subsets InSys which are closed under t.c. subsystems. We define functors modeling states and parallel actions:
(St) St : Ω(InSys)op → Set is defined as follows:
Objects:	St(U ) = {(si)Si∈U | si ∈ St(Si), and if Si ‹→ Sj then si = sj|X };
ι	i
Morphisms: if U1⊆U2, St(ι):St(U2)→St(U1) is St(ι)((si)Si∈U2 )=(si)Si∈U1 .
(Pa) Pa : Ω(InSys)op → Set is defined as follows:
Objects:	Pa(U ) = {(fi)Si∈U | fi ∈ P a(Si), and if Si ‹→ Sj then fi = fj|A };
ι	i
Morphisms: if U1⊆U2, Pa(ι):Pa(U2)→Pa(U1) is Pa(ι)((fi)Si∈U2 )=(fi)Si∈U1 .
Example 5.1 Consider the family InSys = {S1, S12, S2} in Example 3.5.
States. Any tuple (s1, s2, s12), where si ∈ St(Si) for i ∈ {1, 2, 12} and s1|X12 =
s2|X12 = s12, is an element in St(InSys). Assume first that k ≤ l.
Let si : XSi → M be such that s(TrainIndexi) = i for all i ∈ {1,..., l}, and such that s1|X12 = s2|X12 = s12. Then (s1, s2, s12) ∈ St(InSys).
Let s1 : XS1 → M be defined by s(TrainIndexi) = i for all i ∈ {1,..., l}, and s2 : XS2 → M be defined by s(TrainIndexi) = i + 1 for all i ∈ {k,..., n}. s1 ∈ St(S1), s2 ∈ St(S2), but they do not agree on the common control variables (in particular,

s1(TrainIndexk) = k, s2(TrainIndexk) = k + 1). So (s1, s2, s1|XS
) /∈ St(InSys).

Assume now that l < k. Then S12 is the system with an empty set of control variables. Hence, s1 : XS1 → M defined by s(TrainIndexi) = i for all i ∈ {1,..., l}, and s2 : XS2 → M , defined by s(TrainIndexi) = i + 1 for all i ∈ {k,..., n}, agree on
the common variables. Therefore (s1, s2, s1|XS  ) ∈ St(InSys).
Let U = {S1, S12, S2} and U1 = {S1, S12} be the two sets in Ω(InSys) which contain S1, and let i be the inclusion between U1 and U . Then St(i) : St(U ) → St(U1) is defined by St(i)(s1, s2, s12) = ρU (s1, s2, s12) = (s1, s12).

Parallel Actions. Any tuple (f1, f2, f12), where fi ∈ P a(Si) for i ∈ {1, 2, 12} and
f1|A12 = f2|A12 = f12, is an element in Pa(InSys). In particular:
(f1, f2, f12) with f−1(1) = {reporti | i ∈ Ij} ∪ update. These are admissible parallel actions in the corresponding systems, and f1|A12 = f2|A12 = f12. Then (f1, f2, f12) ∈ Pa(InSys).
Tuples (f1, f2, f12) which do not satisfy these conditions are not in Pa(InSys):
(f1, f2, f12) with f−1(1) = {reporti | i ∈ Ij}∪ update ∪ {movei | i ∈ Ij} is not in
Pa(InSys), because the components are not admissible parallel actions.
(f1, f2, f12) with f−1(1) = {reporti | i ∈ I1}∪update and f−1(1) = {movei | i ∈ I2}
1	2
is not in Pa(InSys), because the components do not agree on A12.


Theorem 5.2 ([18]) The functors St and Pa are sheaves on InSys. For each Si∈InSys, the stalk at Si of St (resp. Pa) is in bijection with St(Si) (resp. P a(Si)). Moreover, for each U ∈ Ω(InSys), St(U ) (resp. Pa(U )) is in bijection with St(SU ) (resp. P a(SU )), where SU is the colimit of the diagram deﬁned by U.


Example 5.3 Let InSys = {S1, S12, S2} as defined in Example 4.1 (with k ≤ l):
An example of an open cover for U = {S1, S2, S12} is {U1, U2, U12}, where U1 =
{S1, S12}, U2 = {S2, S12}, U12 = {S12}.  Let (s1, s12) ∈ St(U1) and (t2, t12) ∈
St(U2) be such that ρU1 (s1, s12) = ρU2 (t2, t12). Then s12 = t12 and there is
U12	U12
a unique element (s1, t2, s12) ∈ St(U ) such that ρU (s1, t2, s12) = (s1, s12) and
ρU (s1, t2, s12) = (t2, t12). Similar for Pa.

The stalk of St at S  is the colimit of the diagram St(U )St(i)
(U )St(id)St(U )

1
and hence in bijection with St(U1). Similarly for Pa.
→ St	1  →	1

It can be seen that St(U ) is in bijection with St(S), where S is the system in the example in Section 2.2: Let (s1, s2, s12) ∈ St(U ). Then s : X → M defined by s(x) = si(x) iff x ∈ Xi is well defined (due to the definition of St(U )) and in St(S). Conversely, if s ∈ St(S), then (sX1 , sX2 , s|X12 ) ∈ St(U ).
Also Pa(U ) is in bijection with P a(S): If (f1, f2, f12) ∈ Pa(U ) then f : A →
{0, 1} defined by f (x) = fi(x) iff x ∈ Ai is well defined (due to the definition of Pa(U )). It can also be checked that if f1 |= C1 and f2 |= C2 then f |= C. Thus, f ∈ P a(S). The converse is immediate.
Assume now that S1, S2, S12 are as in Example 3.5 but l < k, say l = k − 1. The open cover and stalk construction in (1) and (2) above are the same. However, St(U ) is in bijection with St(S), where S is the colimit of the diagram defined by U as described in Example 3.5 which in this case is different from S. In particular, s : X → M with s(TrainIndex1) = 1, s(TrainIndex2) = 2,..., s(TrainIndexk−1) = k−1 and s(TrainIndexk) = k + 1,..., s(TrainIndexn−1) = n is a state of S, but not of S.

Transitions
Let InSys be a family of systems satisfying conditions (i), (ii), (iii) in Section 4. We define a functor modeling transitions:
(Tr) Tr : Ω(InSys)op → Set is defined as follows:
Objects:	Tr(U ) = {(f, s, s') | f = (fi)S ∈U ∈ Pa(U ),s = (si)S ∈U ∈ St(U ),
i	i
s' = (s')S ∈U ∈ St(U ), (si, s') ∈ TrS (fi), for all Si ∈ U};
i  i	i	i
ι
Morphisms: if U1 ⊆ U2,	Tr(ι) : Tr(U2) → Tr(U1) is defined by
Tr(ι)((f, s, s')) = (Pa(ι)(f ), St(ι)(s), St(ι)(s')),
where, for every Si in InSys and fi ∈ P a(Si), TrSi (fi) is the transition relation associated to fi in Si as explained in Section 3.

Example 6.1 Consider the family {S1, S12, S2} in Example 4.1. With the notation introduced in Example 4.1, let:
sj(ActualPosi) = ai, sj(RepPosi) = ri, sj(Modei) = mi, for i ∈ Ij;
fj be such that f−1(1) = {reporti | i ∈ Ij}∪ update, and
s' be defined by: s' (ActualPosi) = ai, s' (RepPosi) = ai, s' (Modei) = m', where
j	j	j	j	i
m' is computed according to the transition rules for update in Example 2.2.
Then:	fi ∈ P a(Si), si, s' ∈ St(Si), (si, s') ∈ Tr(Si) for i ∈ {1, 2, 12},
i	i
f1|A12 = f2|A12 = f12 and s1|X12 = s2|X12 = s12.
Hence, ((f1, s1, s' ), (f2, s2, s' ), (f12, s12, s' )) is in Tr(InSys).
1	2	12
Theorem 6.2 ([18]) The functor Tr : Ω(InSys)op → Set is a subsheaf of Pa×St×St. Moreover:
For every Si ∈ InSys, the stalk of Tr at Si is in bijection with Tr(Si) = {(f, s, s') |
(s, s') ∈ TrS (f )}.
If the transitions obey either (Disj) or (Indep), then, for every U ∈ Ω(InSys),

Tr(U ) is in bijection with Tr(SU ) = {(f, s, s') | (s, s') ∈ TrS
the colimit of the diagram deﬁned by U.
(f )}, where SU is


Example 6.3 Consider	the	family	{S1, S12, S2}	in	Example	4.1.	Let
((f1, s1, s' ), (f2, s2, s' ), (f12, s12, s' )) ∈ Tr(U ). Let f : A → {0, 1} be defined by
1	2	12
f (x) = fi(x) iff x ∈ Ai is well defined. Then f ∈ P a(S). Similarly, s, s' : X → M , defined by (s(x) = si(x) and s'(x) = s'(x)) iff x ∈ Xi are well defined and in St(S). As shown in Example 2.5, the transitions in all systems S1, S2, S12 obey condition (Disj). The changes of the components of parallel actions are not contradictory and affect only the variables the actions depend upon. Thus, (s, s') is in the transition
induced (according to rule (Disj)) by f . Hence, (s, s') ∈ TrS(f ). The converse is an immediate consequence of the fact that, as showed in Example 3.2, S1, S2, S12 are transition-connected subsystems of S.

Behavior in time
In [6], the behavior of a given system S in time is modeled by a functor F :
T op → Set, where T is the basis for the topology on N consisting of all the sets
{0, 1,..., n},n ∈ N. Intuitively, for every T ∈ T , F (T ) represents the succession of the states of the systems “observed” during the interval of time T . We analyze various alternative possibilities of modeling behavior.

Behavior as successions of states and actions
Since we are interested in actions as well as states, we present a different description of behavior. Let T consist of N together with all sets {0, 1,..., n},n ∈ N. The behavior in an interval T ∈ T of a complex system obtained by interconnecting a family InSys (satisfying conditions (i)–(iii) in Section 4) is modeled by all successions of pairs (state, action) of the component subsystems that can be observed during T , i.e. by the functor BT : Ω(InSys)op → Set defined as follows:
Objects:  for U ∈ Ω(InSys), BT (U )={h:T→St(U )×Pa(U )|K(h, T )},
ι
Morphisms: for U1 ⊆ U2 by BT (ι):BT (U2)→BT (U1), where if h ∈ BT (U2),
B (ι)(h)=(St(ι)×Pa(ι))◦h : T −h→ St(U )×Pa(U ) St(ι)×Pa(ι) St(U )×Pa(U ).

T	2	2
−−−−−−→	1	1

Here K(h, T ) expresses the fact that for every n, if n, n +1 ∈ T and h(n) = (s, f ),
h(n + 1) = (s',f') then (f, s, s') ∈ Tr(U ).
Example 7.1 We illustrate the definition above.	Let T  = N, and let U  =
{S1, S2, S12} as in Example 4.1. We represent an element h in BT (InSys) as a table (first row: arguments i of h, second row: the value h(i), i.e. a pair of tuples):




Theorem 7.2 ([18]) Let BT (S) = {h : T → St(S) × P a(S) | KS(h, T )}, where KS(h, T ) expresses the fact that for every n, if n, n + 1 ∈ T and h(n) = (s, f ), h(n + 1) = (s',f') then (s, s') ∈ TrS(f ). Then:
For every T ∈T , BT : Ω(InSys)op → Set is a sheaf.
For every Si ∈ InSys, the stalk at Si is in bijection with BT (Si).

If the transitions obey (Disj) or (Indep), then, for every U ∈ Ω(InSys), BT (U )
is in bijection with BT (SU ), where SU is the colimit of the diagram deﬁned by U.

Behavior: Admissible Parallel Actions as Words
If we ignore the states, the behavior of any system S can be expressed by a subset
LS of the free monoid P a(S)∗ over the set of possible actions of S, where:
LS = {f1 ... fn | ∃h : {0,..., n}→ St(S) × P a(S), ∃si ∈ St(S), s.t.
∀i ∈ {0,...,n − 1}, (si, si+1) ∈ TrS(fi)}⊆ P a(S)∗.
Consider the family {P a(Si)∗ | Si ∈ InSys}. If Si, Sj ∈ InSys and Si ‹→ Sj, let
Sj  : P a(Sj) → P a(Si) be the restriction to Si.  The restriction extends to a
homomorphism of monoids, pj : P a(Sj)∗→P a(Si)∗. If there is no risk of confusion,

in what follows we will abbreviate pj(wj) by wj
|Si
. Let M (InSys) be defined by:

M (InSys) = {(wi)S ∈InSys | wi ∈ P a(Si)∗ and ∀Si ‹→ Sj, pj(wj) = wi}.
i	i
It can be seen that M (InSys) is the limit of the diagram {P a(Si)∗ | Si ∈ InSys}
(with the morphisms pj for every Si ‹→ Sj).
Theorem 7.3 Let M : Ω(InSys)op → Sets be deﬁned as follows:
Objects:	M (U ) = {(wi)S ∈V | wi∈P a(Si)∗, wi|S = wj for every Sj ‹→ Si},
Morphisms: if ι : U1 ⊆ U2, M (ι) : M (U2) → M (U1) is deﬁned for every
(wi)Si∈U2  by M (ι)((wi)Si∈U2 ) = (wi)Si∈U1 .
Then M is a sheaf of monoids. M (V ) is the limit of the diagram {P a(Si)∗ | Si ∈ V }
(with morphisms pj : P a(Sj)∗→P a(Si)∗ whenever Si ‹→ Sj).
Proof : Let U ∈ Ω(InSys) and {Uk | k ∈ K} be a cover for U . Let {wk}k∈K be
a family of elements, such that for every k ∈ K, wk = (wi )S ∈U  and for every

k1, k2 ∈ K, if Si ∈ Uk1
∩ Uk2
then wi
1
= wi .
2
k  i	k

We define w = (wi)Si∈U as follows: for every Si ∈ U , Si ∈ Uk for some k. Then wi is defined to be wi . Note that wi is well defined because of the compatibility of the family {wk}k∈K, and pU (w) = wk for every k ∈ K. The uniqueness of w
follows from the fact that for every w' = (w')S ∈U such that pU (w') = wk for every
i  i	Uk
k ∈ K we have w' = wk for every Si ∈ Uk.
i	i
The fact that M (V ) is the limit of the diagram {P a(Si)∗ | Si ∈ V } (with the
corresponding morphisms) can be checked without difficulty.	 
Remark: Let S be the colimit of the diagram defined by U . The connection between P a(S)∗ and M (U ) is rather loose: Let p : P a(S)∗ → M (U ) be defined by p(f1 ... fn) = ((f1 ... fn)|Si )Si∈U ∈ M (U ). If we identify the empty action with the empty word ϵ, p may not be injective as can be seen from the following example:
Example 7.4 Let S1 and S2 be as defined in Example 4.1, where trains are indexed by I1 = {k1,..., n} and I2 = {1,..., k2} and k2 < k1, with the difference that update is omitted as in Example 2.6. Let InSys = {S1, S2, ∅}. Let w1 = f1f2 and w2 = f2f1, where f−1(1) = {reporti | i ∈ I1} and f−1(1) = {movej | j ∈ I2}. Note
1	2

that f1−1 (1) = {reporti | i ∈ I1}, f2−1 (1)=f1−1 (1)=∅, and f2−1 (1) = {movej | j ∈

|A1
|A1
|A2
|A2

I2}. Thus, p(w1) = ((f1f2)|S1 , (f1f2)|S2 , (f1f2)|∅) = ((f1|A1 f2|A1 ), (f1|A2 f2|A2 ), ϵ) = (f1ϵ, ϵf2, ϵ) = (ϵf1, f2ϵ, ϵ) = ((f2|A1 f1|A1 ), (f2|A2 f1|A2 ), ϵ) = p(w2), but w1 /= w2.
The next example shows that p : P a(S)∗ → M (U ) is not necessarily onto: There may exist compatible families (even if we only consider singleton parallel actions) of sequences of actions that cannot be “glued together” to a sequence of actions on P a(S). A similar result appears in [13] (in that case, no parallelism is allowed).
Example 7.5 Let S1, S2, S3 be three systems all having the same language, the same constraints on variables and the same model for the variables, such that
AS1 = {a, b, d},	AS2 = {b, c, e},	AS3 = {a, c, f}
CS1 = {a ∧ b = 0}	CS2 = {b ∧ c = 0}	CS3 = {a ∧ c = 0}
Let S be the system obtained by interconnecting S1, S2, S3.  Then AS  =
{a, b, c, d, e, f}, CS = {a ∧ b = 0,b ∧ c = 0,a ∧ c = 0}. Consider w1 = ab ∈ P a(S1)∗, w2 = bc ∈ P a(S2)∗, w3 = ca ∈ P a(S3)∗. It is easy to see that p1 (w1) = p2 (w2) = b,
12	12
p2 (w2) = p3 (w3) = c, p1 (w1) = p3 (w3) = a, but there is no w ∈ P a(S)∗ such
23	23	13	13
that w|Si = wi,i = 1, 2, 3.
We investigate therefore other ways of modelling behavior for which tighter links between local and global behavior exist.

Behavior: Partially Commutative Monoids
In what follows we assume that the constraints on actions are all of the form ai∧aj = 0 (they state which actions cannot be performed in parallel).
Definition 7.6 Let S be a system with the property that the constraints on actions are all of the form ai ∧ aj = 0. The dependence graph of S is the graph (AS, DS) having as set of vertices AS, and where DS is defined by (a1, a2) ∈ DS if a1 = a2 or a1 ∧ a2 = 0 ∈ CS.
For every system S with dependence graph (AS, DS) we denote by M (S) =
M (AS, DS) the free partially commutative monoid defined by (AS, DS), i.e. the
quotient of A∗ by the congruence relation generated by a1a2 = a2a1 for every
(a1, a2) ∈ (AS × AS)\DS.  For basic properties of (free) partially commutative
monoids we refer e.g. to [3], pp.9-29 and 67-79.
For every Si ∈ InSys\∅, let M (Si) = A∗ /θi (where θi is the congruence defined as explained above from (ASi × ASi )\DSi ) be the partially commutative monoid associated with the dependence graph of Si. Let S be the colimit of the diagram

defined by InSys. Then AS = 
Si∈InSys
Ai and DS = 
Si∈InSys
Di. Hence, for every

Si ∈ InSys there is a canonical projection pi : M (S) → M (Si) which is onto. Let
ker(pi) be the kernel of pi. Then M (Si)  M (S)/ker(pi).
If Si ‹→ Sj, then we denote the canonical projection by pj : M (Sj) → M (Si), and

if Si, Sj ∈ S, then pj
: M (Sj) → M (Si ∩ Sj), and pi
: M (Si) → M (Si ∩ Sj) are

the canonical mappings. Note that all homomorphisms pi : M (Si) → M (Sj) and
i : M (Si) → M (Si ∩ Sj) are onto. We know that for all Sj ‹→ Si, pi ◦ pi = pj.
Example 7.7 Consider a family of two systems of trains S1, S2 over disjoint sets I1, I2 of trains as in Example 4.1 but with l < k. We simplify the description by replacing all actions that need to be executed at the same time with one action. The system Si (i ∈ {1, 2}) obtained this way has two actions updatei and movei The constraints are Ci = {updatei ∧ movei = 0}. Thus θi = id, so M (Si) = A∗ .
Let S be the system obtained by the interconnection of S1 and S2. AS = {update1, update2, move1, move2} and CS = C1 ∪ C2.
DS = {(update1, update1), (update2, update2), (move2, move2), (move1, move1), (update1, move1), (move1, update1), (update2, move2), (move2, update2)}
(AS × AS)\DS = {(update1, update2), (update2, update1), (update1, move2), (move2, update1), (move1, update2), (update2, move1), (move1, move2), (move2, move1)}
Thus, M (S) = A∗ /θ, where θ is the congruence generated by (AS × AS)\DS.

Applying a method due to [2] (cf. Appendix A) – where sheaves of algebras are constructed, whose stalks are quotients of a given algebra – we deduce for partially commutative monoids results similar to those given in [13] for monoids. The results are similar to results on Petri Nets and Mazurkiewicz traces presented in [3].

Let (F, f, InSys) be defined by F = 

Si∈InSys
M (Si), and f : F → InSys be the

natural projection. Assume that a subbasis for the topology on F is SB = {[m](U ) |
U ∈ Ω(InSys),m ∈ M (S)}, where [m](U ) = {pi(m) | i ∈ U}.
We first show that Ω(InSys) has the property that for every m1, m2 ∈ M (S), if pi(m1) = pi(m2) then there exists an open neighborhood U of Si in Ω(InSys) such that for every Sj ∈ U , pj(m1) = pj(m2) (i.e. it is an S-topology).
Lemma 7.8 Ω(InSys) is a S-topology (cf. Deﬁnition A.2).
Proof : We show that for every m1, m2 ∈ M (S), if pi(m1) = pi(m2) then there exists an open neighborhood U of Si in Ω(InSys) s.t. for every Sj ∈ U , pj(m1) = pj(m2). Let m1, m2 ∈ M (S) with pi(m1) = pi(m2). Let U = ↓Si = {Sj ∈ InSys | Sj ‹→ Si}. U ∈ Ω(InSys) and pj(m1) = pi (pi(m1)) = pi (pi(m2)) = pj(m2) for every Sj ∈ U . 
j	j
Let α : M (S) → Γ(I, FA) be defined by α(m) = ([m]θi )i∈I . Since Ω(InSys) is an S-topology, by Theorem A.1 and Corollary A.3 in Appendix A we have:
(F, f, InSys) is a sheaf of algebras,
The stalk at Si ∈ InSys is isomorphic to M (Si),

In M (S) →α
Γ(InSys,F ) ≤ 
M (S ) →πi M (S )

Si∈InSys	i	i
(3.i) πi ◦ α is an epimorphism,
(3.ii) M (S) is a subdirect product of {M (Si)}Si∈InSys iff α is a monomorphism.

Lemma 7.9 Let s : InSys → 

Si∈InSys
M (Si) be such that s(Si) ∈ M (Si) for every

Si ∈ InSys. Let m ∈ M (S) and U ∈ Ω(InSys). Then Si ∈ s−1([m](U )) if and only if
Si ∈ U and s(Si) = pi(m).
Proof : Note that s−1([m](U )) = {Si ∈ InSys | s(Si) ∈ [m](U )} = {Si ∈ InSys | s(Si) ∈ {pj(m) | Sj ∈ U}}. We first prove the direct implication. Assume that Si ∈ s−1([m](U )). Then s(Si) = pj(m) for some Sj ∈ U . Since f ◦ s(Si) = Si, it follows that Si = f (s(Si)) = f (pj(m)) = Sj, hence Si ∈ U and s(Si) = pi(m). To prove the converse, assume that Si ∈ U and s(Si) = pi(m). Then s(Si) ∈ {pj(m) | Sj ∈ U}, hence Si ∈ s−1([m](U )).	 

Lemma 7.10 Let τ be the topology on F = 


Si∈InSys
M (Si) generated by SB =

{[m](U ) | U ∈ Ω(InSys),m ∈ M (S)} as a subbasis.	Then s : InSys →

Si∈InSys
M (Si) such that for every Si ∈ InSys, s(Si) ∈ M (Si) is continuous if

and only if for every Si, Sj ∈ InSys such that Sj ‹→ Si, pi (s(Si)) = s(Sj).

Proof : Since SB is a subbasis for the topology on F = 
M (Si), s : InSys →

S ∈InSys M
(Si
) is continuous iff for every [m
](U )
Si∈InSys
∈ SB, s−1([m
](U )) ∈
Ω(InSys).

i
We first prove the direct implication. Assume that s : InSys →
S ∈InSys M (Si) is

continuous. Let Si, Sj ∈ InSys be such that Sj ‹→ Si. We prove that pi (s(Si)) =
s(Sj). Let U = ↓Si ∈ Ω(InSys) and let m ∈ M (S) be such that pi(m) = s(Si) (the existence of m is ensured by the fact that pi : M (S) → M (Si) is onto). From the continuity of s we know that s−1([m](↓Si)) ∈ Ω(InSys). Obviously, Si ∈ s−1([m](↓Si)). Therefore, since Sj ‹→ Si, Sj ∈ s−1([m](↓Si)), hence, by Lemma 7.9, s(Sj) = pj(m). Therefore, s(Sj) = pj(m) = pi (pi(m)) = pi (s(Si)).
j	j
Conversely, assume that for every Si, Sj ∈ InSys such that Sj ‹→ Si it holds
that pi (s(Si)) = s(Sj). We prove that s is continuous. Let [m](U ) ∈ SB, where m ∈ M (S) and U ∈ Ω(InSys). We prove that s−1([m](U )) ∈ Ω(InSys). Let Si ∈ s−1([m](U )). Then Si ∈ U and s(Si) = pi(m). Let Sj ‹→ Si. Then Sj ∈ U and by
the hypothesis, s(Sj) = pi (s(Si)) = pi (pi(m)) = pj(m). Thus, Sj ∈ s−1([m](U )).
j	j
Therefore s−1([m](U )) ∈ Ω(InSys).	 
Lemma 7.11 The set Γ(InSys,F ) of global sections of F has the form
Γ(InSys,F ) = {(mi)S ∈InSys | mi ∈ M (Si) and ∀Sj ‹→ Si ∈ InSys, pi (mi) = mj}.

i
Proof : We know that Γ(InSys,F ) = {s : InSys → 


Si∈InSys
j
M (Si) | s continuous and

s(Si) ∈ M (Si), ∀Si ∈ InSys}. (The elements of Γ(InSys,F ) are tuples (s(Si))Si∈InSys.) Let first s ∈ Γ(InSys,F ). Then s is continuous and, by Lemma 7.10, for all Si, Sj ∈
InSys with Sj ‹→ Si, pi (s(Si)) = s(Sj). Conversely, let (mi)S ∈InSys be such that for
j	i
every Si, Sj ∈ InSys, mi ∈ M (Si) if Sj ‹→ Si then pi (mi) = mj. Let s : InSys →
j
S ∈InSys M (Si) be defined by s(Si) = mi for every Si ∈ InSys. Then, whenever
Sj ‹→ Si ∈ InSys, pi (s(Si)) = s(Sj) and, by Lemma 7.10, s is continuous.	 
Theorem 7.12 Let (F, f, InSys) be deﬁned as above. Then (F, f, InSys) is a sheaf space of algebras. The stalk at Si ∈ InSys is isomorphic to M (Si); the set of global sections is Γ(InSys,F ) = {(mi)S ∈InSys | mi ∈ M (Si), and ∀Si ‹→ Sj, pj(mj) = mi}.
i	i
Additionally the following hold:

If InSys is ﬁnite, then
M (S) ‹→ Γ(InSys,F ) ≤ 

M (S ) →πi M (S ) is a subdirect product.

Si∈InSys	i	i
The embedding M (S) ‹→ Γ(InSys,F ) is an isomorphism iff every chordless cycle in the dependence graph GS of S is a cycle in a subgraph GSi for some Si ∈ InSys.
If InSys is inﬁnite, and if for every a ∈ AS there are at most ﬁnitely many Si ∈
InSys with a ∈ Ai, then there is an injective morphism M (S) →	M (Si),

where 
M (  ) =  (	)
(  )	=
Si
a.e.

Si	Si	{ wi i∈I | wi ∈ M Si , wi	ε	} is the weak product of
the family {M (Si)}Si∈ InSys.

Proof : The form of Γ(InSys,F ) follows from Lemma 7.11. (1)(i) and (2) are a consequence of Theorem B.1 and the subsequent comments in Appendix B. (1)(ii) is a direct consequence of Theorem 3.3.2 in [3].	 

Example 7.13 First consider the family of systems in Example 7.7. The depen- dency graph of S, GS = (AS, DS) contains the following non-trivial chordless cycles:
(update1, move1, update1) and (move1, update1, move1) (all cycles in GS1 )
(update2, move2, update2) and (move2, update2, move2) (all cycles in GS2 ). Thus, in this case the embedding in Theorem 7.12(1)(ii) is an isomorphism.
Example 7.14 Consider the systems in Example 7.5. The dependency graphs are:
GS1 = (A1, D1), with D1 = {(a, a), (b, b), (d, d), (a, b), (b, a)},
GS2 = (A2, D2), with D2 = {(b, b), (c, c), (e, e), (b, c), (c, b)},
GS3 = (A3, D3), with D3 = {(a, a), (c, c), (f, f ), (a, c), (c, a)}).
GS = (A1 ∪ A2 ∪ A3, D1 ∪ D2 ∪ D3) contains the chordless cycle (a, b, c, a) which is not contained in any of the subgraphs GSi ,i ∈ {1, 2, 3}. Thus, the embedding in Theorem 7.12(1)(ii) is not an isomorphism.


Other concepts and their sheaf semantics
Time. One possibility for expressing time internally in the category Sh(InSys) is to model time by the sheafification N of the constant presheaf N : Ω(InSys)op → Set (defined for every U by N (U ) = N), which can be constructed as follows:
Let N + : Ω(InSys)op → Sets, defined by N +(U ) = N if U /= ∅ and N +(∅) = 1 (for the empty cover there is exactly one matching family; the empty one).
Let N = (N +)+ : Ω(InSys)op → Sets. An element of (N +)+(U ) is an equivalence class of sets of elements ij ∈ N (Uj) for some open covering {Uj | j ∈ J} of U , which match (ij1 = ij2 ) whenever the overlap Uj1 ∩ Uj2 is nonempty. Thus, these elements “glue” together to give a function i : U → N, with the property that every point of U has some open neighborhood on which the function is constant.

For every U ∈ Ω(InSys), N(U ) = {i : U → N | f locally constant 4 }. There exist

Sh(InSys)-arrows 1 →0
N →s
N; the sheaf N is the natural number object in Sh(InSys).

Other constructions. Various other sheaves and natural transformations can be defined by using standard categorical constructions in Sh(InSys). We can e.g.
define a natural transformation BN × N →a  St × Pa whose components BN(U ) ×

N(U ) aU
St(U ) × Pa(U ) are defined by aU
(h, (ni)Si∈U
) = ((si)S ∈U
, (fi)
Si∈U
), for

every U ∈ Ω(InSys), where for every Si ∈ U , h(ni) = ((si )S ∈U , (fi)S ∈U ). 5
j	j	j	j
Theorem 8.1 ([18]) For every Si ∈ InSys, StalkSi (a) is (up to isomorphism) the
aSi
map B (S ) × N	St(S ) × P a(S ), deﬁned by a (h, n) = h(n).
T	i	→	i	i	Si

Geometric logic and properties of systems
We provide interpretations for properties of systems (i.e. statements about states, actions, behavior) both concretely (in the category of sets) and in a category of sheaves, and establish links between the set-theoretical (both for individual systems and for their interconnections) and the sheaf-theoretical interpretation. These links are then used to prove preservation of truth when interconnecting systems.
Many-sorted ﬁrst order languages and their interpretation in Sh(I)
Let L be a many-sorted first-order language consisting of a collection of sorts and collections of function and relation symbols. Terms and atomic formulae from L are defined in the standard way; compound formulae are constructed by using the connectives ∨, ∧, ⇒, ¬ and the quantifiers ∃, ∀, for every sort X. An interpretation M of L in Sh(I) is constructed by associating:
a sheaf XM on I to every sort X,
a subsheaf RM ⊆ XM ×· · ·×XM to every relation symbol R of arity X1×· · ·×Xn,
1	n
an arrow f M : XM ×· · ·× XM → Y M in Sh(I) to every function symbol f with
1	n
arity X1 × ··· × Xn → Y .
Each term t(x1,..., xn) of sort Y is (inductively) interpreted as an arrow tM :
M × · · · × XM  → Y M ; and every formula φ(x1,..., xn) with free variables
FV (φ) ⊆ {x1,..., xn}, where xi is of sort Xi, gives rise to a subsheaf {(x1,..., xn) |
φ(x1,..., xn)}M ⊆ XM ×· · · × XM . For details we refer to [12], Ch. X.
1	n
Definition 9.1 A geometric formula is a formula built from atomic formulae by using only the connectives ∨ and ∧ and the quantifier ∃. A geometric axiom is a formula of the form (∀x1,..., xn)(φ ⇒ ψ) where φ and ψ are geometric formulae.

4 f :U→X is locally constant if ∀x∈U there is an open neighborhood U1⊆U of x on which f is constant. This means that ’local clocks’ of the systems in U synchronize for systems sharing common subsystems.
5 The map aU has as arguments a behaviour along N of the family of systems in U , h ∈ BN(U ), and a tuple consisting of ’local clocks’ of the systems in U which synchronize on systems sharing common subsystems.
aU returns the pair ((si)S ∈U , (fi)S ∈U ) where (si,fi) is the pair state/parallel action in the behavior
i  i	i  i	i  i
corresponding to the system Si in U , at the time point indicated by the local clock ni of Si.

Let T be a theory in the language L. A variable in a geometric formula is called T-provably unique if its value in every model of T is uniquely determined by the values of the remaining free variables.
A cartesian formula w.r.t. T is a formula constructed from atomic formulae using only the connective ∧ and the quantifier ∃ over T-provably unique variables. A cartesian axiom w.r.t. T is a formula of the form (∀x)(φ(x) ⇒ ψ(x)) where φ and ψ are cartesian formulae w.r.t. T. A cartesian theory is a theory whose axioms can be ordered such that each is cartesian w.r.t. the preceding ones.
A geometric axiom (∀x1 ... xn)(φ⇒ψ) is satisﬁed in an interpretation M in Sh(I) if {(x1,..., xn)|φ}M is a subobject of {(x1,..., xn)|ψ}M in Sh(I).
Stalk functors, global section functors; preservation of truth
Stalk functors. For every Si ∈ InSys let fi : {∗} → InSys be defined by fi(∗) = Si.
The inverse image functor corresponding to fi, the stalk functor StalkSi = f	:
∗
Sh(InSys) → Set, associates to every sheaf F ∈ Sh(InSys) the stalk at Si, FSi . For all Si ∈ InSys, f∗ preserves the validity of geometric axioms. The stalk functors f∗
i	i
are collectively faithful, so they reflect the validity of geometric axioms.
Global section functor. Consider the unique map g : InSys → {∗}. The direct im- age functor, g∗ : Sh(InSys) → Set, is the global section functor g∗(F ) = F (InSys) for every F ∈ Sh(InSys). Thus, the global section functor preserves the interpretation of every cartesian axiom.
A geometric logic for reasoning about complex systems
Let L be a fixed many-sorted language including at least sorts like st(ate), pa(rallel- action), b(ehavior), t(ime); constants like s0 : st (initial state), 0 : t (initial moment of time); function symbols like appl : b × t → st × pa, p1 : st × pa → st, p2 : st × pa → pa; relation symbols like tr(ansition) ⊆ pa × st × st, =X⊆ X × X for every sort X, etc. Let M be an interpretation of L in Sh(InSys) such that stM = St, paM = Pa, bM = BN, t = N, applM = a, p1M = π1, p2M = π2 (the canonical projections), trM = Tr. For every sort X, we interpret =X : X × X → Ω as usual.
Theorem 9.2 ([18]) Sh(InSys) satisﬁes a geometric axiom in the interpretation M if and only if Set satisﬁes it in all interpretations f∗(M ). If Sh(InSys) satisﬁes a cartesian axiom, this is also true in Set in the interpretation g∗(M ) (f∗(M ) and
g∗(M ) interpret a sort X as f∗(XM ) resp. g∗(XM )).
From Theorems 6.2 and 7.2 we know that for every Si ∈ InSys, f∗(St) = StS
St(Si) and f∗(Pa) = PaS   P a(Si); if S is the system obtained by interconnecting
all elements in InSys, g∗(St) = St(InSys)  St(S), and g∗(Pa) = Pa(InSys)  P a(S). The same holds for Tr and BT . Moreover, f∗(N) = N, g∗(N) = N(InSys), and, by
Theorem 8.1, f∗(appl) = aS  : BN(Si) × N → St(Si) × P a(Si). Hence, statements
about states, actions and transitions in Sh(InSys) are translated by f∗ (resp. g∗) to
corresponding statements about states, actions and transitions in Si (resp. S).

We illustrate the ideas above by several classes of properties of systems (adapted from [11]) which we express in the language L. For instance, if h is a possible behavior and j a moment in time, then h(j) can be expressed in L by appl(h, j); the

state of h at j can be expressed by s(h, j), where s = p
appl : b × t appl st × pa p1 st.

1	→	→
Safety properties are of the form (∀h : b)(∀j : t)(P (s(h, 0)) ⇒ Q(s(h, j))), where P and Q are formulae in L. As examples we mention:
partial correctness:  (∀h : b)(∀j : t)[(P (s(h, 0)) ∧ Final(s(h, j))) ⇒ Q(s(h, j))];
global invariance of Q: (∀h : b)(∀j : t)[P (s(h, 0)) ⇒ Q(s(h, j))].
Liveness properties have the form (∀h : b)[P (s(h, 0)) ⇒ (∃j : t)Q(s(h, j))]. With s0 denoting the initial and sf a final state, examples are: total correctness and termination:  (∀h : b)[P (s(h, 0)) ⇒ (∃j : t)(Final(s(h, j)) ∧ Q(s(h, j)))];
accessibility: (∀h : b)[(s(h, 0) = s0) ⇒ (∃j : t)(s(h, j) = sf )].
Precedence properties: (∀h : b)(∀j : t)[(P (s(h, 0))∧A(s(h, j)))⇒Q(s(h, j))].
Theorem 9.3 ([18]) Assume that the following conditions are fulﬁlled:
The ﬁnal states form a subsheaf Stf ⊆ St interpreting a sort stf of L. (This happens e.g. if in the deﬁnition of a system ﬁnal states are speciﬁed by addi- tional constraints, and in deﬁning colimits this information is also used.)
The properties P, Q, A can be expressed in L (using the sorts, constants, func- tion and relation symbols mentioned at the beginning of Section 9), and can be interpreted in Sh(InSys) and also in Set (to express, for every Si in InSys, the corresponding property of Si, or S).
The truth of formulae describing safety, liveness and precedence properties (as in (a),(b),(c) above) is preserved under inverse image functors if in the deﬁnitions of the property P (c.q. Q, A) only conjunction, disjunction and existential quantiﬁca- tion occur. The truth of these formulae is additionally preserved by direct image functors if only conjunction and unique existential quantiﬁcation occur in them.

Example 1: Safety of train systems controlled by a radio controller
Consider the example in Section 4.1: Let k ≤ l ∈ {1,..., n}, I1 = {k,..., n}, I2 =
{1,..., l}, and I12 = {k,..., l}. Let InSys = {S1, S2, S12} be the family consisting of the subsystems of S described in Section 2.2 corresponding to the sets of trains
with indices in I ,I and I . Let Γj, j ∈ {1, 2, 12} be the following constraints
1  2	12	s
encoding collision freeness of Sj (where ⇒ denotes logical implication):

Γj = {succ(TrainIndex ) = TrainIndex
⇒ ActualPosi<ActualPosk−L | i, k ∈ Ij}.

For every S
j ∈ {1, 2, 12} let SafeSt(Sj) = {s : Xj → Mj | s |= Γj ∪ Γj} be the

set of safe states of Sj 6 . Let SafeState : Ω(InSys) → Sets be defined on objects
by SafeState(U ) = {(sj)Sj∈U | sj ∈ SafeSt(Sj), and sj|X = si whenever Si ‹→ Sj},
and on morphisms by restriction. We can define a set of similar constraints Γs and a similar set of safe states SafeSt(S) for the system S, where:

6 We denote by Γj the restriction of Γ (cf. Definition 2.2) to Xj

Γs={succ(TrainIndexi)=TrainIndexk ⇒ ActualPosi<ActualPosk−L | i, k∈{1,..., n}}. If I1 ∩ I2 /= ∅ then Γ1 ∪ Γ2 = Γs 7 . Analogously to Theorem 6.2 we can show:
s	s
Theorem 9.4 The following hold:
SafeState is a sheaf. Moreover, SafeState is a subsheaf of St.
For each Si∈InSys, the stalk of SafeState at Si is in bijection with SafeSt(Si).
SafeState(InSys) is in bijection with SafeSt(S).
Collision freeness can be expressed as follows:
CollFree	(∀h : b)(∀j : t) [SafeState(s(h, 0)) ⇒ SafeState(s(h, j))].
This formula contains only atomic formulae and the implication symbol. Therefore, by Theorem 9.3, its truth is preserved both under inverse image functors and under direct image functors, and it is reflected by the stalk functors:
Assume that S1, S2, S12 satisfy CollFree.  Then for all h ∈ BN(Sj), t ∈ N, if
π1(h(0)) ∈ SafeSt(Sj) then π1(h(t)) ∈ SafeSt(Sj). Due to the form of the formula
CollFree, its truth is reflected by the stalk functors f∗ : Sh(InSys) → Set. It
therefore follows that Sh(InSys) satisfies, internally, the formula CollFree.
The truth of CollFree is preserved by the global section functor g∗ : Sh(InSys) →
Set, defined by g(F ) = F (InSys). Therefore, (in Set) the following holds:
∀h∈BN(InSys), ∀t∈N(InSys) [π1(h(0))∈SafeState(InSys)⇒π1(h(t))∈SafeState(InSys)] As, by Theorems 9.4 and 7.2, SafeState(InSys) is in bijective correspondence with
SafeSt(S) and BN(InSys) is in bijective correspondence with BN(S), we obtain:
∀h ∈ BN(S), ∀t ∈ N, if π1(h(0)) ∈ SafeSt(S) then π1(h(t)) ∈ SafeSt(S).
Corollary 9.5 Consider a family of consecutive trains on a linear track without loops. Assume that each train i controls both its position and the position of its predecessor, and accordingly determines its movement mode. We obtain a family
{Si | i ∈ {2,..., n}} of systems consisting of two successor trains each (each deﬁned as in Example 2.2 for n = 2). Let U consist of this family of systems together with their intersections. The colimit of this family is the system S described in Example 3.5. By Theorem 9.3, if collision freeness can be guaranteed for all the systems in U, then the system S is collision free.
For suitably chosen minSpeed, maxSpeed and update interval Δt all 2-train systems are collision free (for an automatic proof ideas from [8] can be used). Therefore, the n-train system in Example 2.2 can be proved to be collision free for these values.
Remark: The condition that the systems consist of successive trains and overlap over one extremity is needed for recovering the successor constraints on trains for the colimit. We obtain similar links between global and local properties also with a cover consisting of one-train systems. However, then the colimit of the system

7 Note that if I1 ∩ I2 = ∅ then some of the constraints of Γs cannot be deduced from Γ1 and Γ2
s	s

defined by such a cover is different of the system S; we would obtain a link between the safety of the systems consisting of one train only and the safety of a system in which all trains are on independent tracks.
Example 2: Lifeness
We adapt the example in the previous section and give an example of lifeness prop- erty which can be expressed by means of a cartesian theory, and thus can be checked
modularly. Assume that the constraints Γ' on for system Sj consist of Γj (defined

as Γl
in Example 3.2) and the constraint ( 
j
Modei = 0) ∨ ( 

i∈Ij
Modei > 0).

As in Theorem 9.4 we can prove that this defines a subsheaf St' of St; the following
constraints define subsheaves of St' with properties similar to those of SafeState:
Γj = Γ' ∪ Γj ∪ {Mode = 0 | i ∈ I } defines a sheaf SafeStateUpdate;
su	j	s	i	j

j
CanMove
Γj
= Γ' ∪ {Modei > 0 | i ∈ Ij} defines a sheaf CanMove;
= Γ' ∪ {Modei = 0 | i ∈ Ij} defines a sheaf CannotMove.

CannotMove	j
For Si ∈ InSys let Minimal(Si) = {(h, j) | s(h, j) ∈ CanMove(Si) and ∀k(s(h, k) ∈ CanMove(Si) → k ≥ j)}, characterizing the minimal moment in time j w.r.t. a behavior h at which all trains in system Si can move. These definitions can be used to define a subsheaf MinimalCanMove ⊆ BN × N with properties similar to those of St, Pa, Tr, B. A form of lifeness can be expressed by the following cartesian axioms:
∀h : b (SafeStateUpdate(s(h, 0)) → ∃j : t MinimalCanMove(h, j))
∀h : b, ∀i : t (MinimalCanMove(h, i) → CanMove(s(h, i)))
∀h : b, ∀i, k : t (MinimalCanMove(h, i) ∧ CanMove(s(h, k)) → i ≤ k)
(where the existential quantified variable in the first axiom is provably unique mod- ulo the second and third axiom), and can thus be checked modularly.
Conclusion
We showed that a family InSys of interacting systems closed under pullbacks can be endowed with a topology which models the way these systems interact. States, parallel actions, transitions, and behavior can be described as sheaves on this topo- logical space. We then used geometric logic to determine which kind of properties of systems in InSys are preserved when interconnecting these systems. The main advantage of our approach is that it enables us to verify properties of complex sys- tems in a modular way. We illustrated the ideas by means of a running example, involving systems of trains controlled by interacting controllers. In future work we plan to look at other applications, including geographically distributed systems, controlled by geographically fixed controllers, whose domains overlap.
We think that there should exist relationships between the approach described in this paper and other new approaches to the study of concurrency such as, for in- stance, higher dimensional automata (cf. [14,15]) or approaches based on meth- ods from geometry and algebraic topologicy in particular homotopic methods (cf. [7]). Links between algebraic topology and concurrency as well as links with higher dimensional automata between have been studied e.g. by Gaucher, Goubault, Fa-

jstrup, and Raussen (cf. e.g. [5,4]). We would like to compare our approach with the methods mentioned above. Using homological and especially homotopic methods seems to be the next natural step after the sheaf semantics given in this paper.

Acknowledgement
Many thanks to the referees for their helpful comments.


References
C.C. Chang and H.J. Keisler. Model Theory. North-Holland, Amsterdam, 3rd edition, 1990.
B.A. Davey. Sheaf spaces and sheaves of universal algebras. Math. Zeitschrift, 134:275–290, 1973.
V. Diekert. Combinatorics on Traces. In LNCS 454. Springer Verlag, 1990.
L. Fajstrup, M. Raussen, E. Goubault. Algebraic topology and concurrency, I. Theoretical Computer Science 357, pages 241–278, 2006.
P. Gaucher, E´. Goubault. Topological Deformation of Higher Dimensional Automata. Homology, Homotopy, Appl., 5(2):39–82, 2003.
J.A. Goguen. Sheaf semantics for concurrent interacting objects. Mathematical Structures in Computer Science, 11:159–191, 1992.
M. Herlihy, N. Shavit.. The topological structure of asynchronous computation. Journal of the ACM, 46: 858-923, 1999.
S. Jacobs and V. Sofronie-Stokkermans. Applications of hierarchical reasoning in the verification of complex systems. Electronic Notes in Computer Science 174(8), pages 39-54, 2007. (Selection of the papers presented at the IJCAR’06 workshop Pragmatics of Decision Procedures in Automated Reasoning (PDPAR’06).)
P. Johnstone. Stone Spaces. Cambridge Studies in Advanced Mathematics 3. Cambridge University Press, 1982.
P.H. Krauss and D.M. Clark. Global subdirect products. Memoirs of the AMS, 17(210):1–109, 1979.
F. Kr¨oger. Temporal Logic of Programs, volume 8 of EATCS Monographs on Theoretical Computer Science. Springer Verlag, 1987.
S. Mac Lane and I. Moerdijk. Sheaves in Geometry and Logic. Universitext. Springer Verlag, 1992.
L. Monteiro and F. Pereira. A sheaf theoretic model for concurrency. Proc. Logic in Computer Science (LICS’86), 1986.
V. Pratt. Modeling concurrency with geometry. Proc. 18th Symposium on Principles of Programming Languages pages 311-322, ACM Press New York USA, 1991.
V. Pratt. Higher-dimensional automata revisited. Mathematical Structures in Computer Science, 10(4), 2000.
V. Sofronie. Towards a sheaf theoretic approach to cooperating agents scenarios. In J. Calmet, J.A. Campbell, and J. Pfalzgraf, editors, Proc. of the International Conference Artificial Intelligence and Symbolic Mathematical Computation (AISMC-3), LNCS 1138, pages 289–304. Springer Verlag, 1996.
V. Sofronie-Stokkermans. Fibered Structures and Applications to Automated Theorem Proving in Certain Classes of Finitely-Valued Logics and to Modeling Interacting Systems. PhD thesis, RISC- Linz, J. Kepler University Linz, 1997.
V. Sofronie-Stokkermans and K. Stokkermans. Modeling Interaction by Sheaves and Geometric Logic. In G. Ciobanu and Gh. Paun eds, Proc. International Conference Fundamentals of Computation Theory (FCT’99), LNCS 1684, pages 512-523, Springer Verlag, 1999.

A  Appendix. Sheaves of algebras
Let A be an algebra of similarity type Σ, (θi)i∈I a family of congruences on A, and τ a topology on I. The following problem was addressed and solved in [2]: In which situation does a sheaf exist with fibers Ai = A/θi such that for every a ∈ A the

map [a] : I → 

i∈I
Ai is a global section? Two constructions are possible:

Construction 1 Let (FA, f,I) be defined by FA = 

i∈I
A/θi, and f : FA → I

be the natural projection.  Assume that a subbasis for the topology on FA is
{[a](U ) | U ∈ τ, a ∈ A}, where [a](U ) = {[a](i) | i ∈ U} = {[a]θi | i ∈ U}.
Construction 2 Let GA : τ → ΣAlg be defined on objects by GA(U ) = A/θU ,
where θU =	θi and on morphisms, for every V ⊆ U by the canonical mor-
phism GA(U ) = A/θU → A/θV = GA(V ), aθU '→ aθV .
Let Gi = lim	GA(U ) be the stalks of GA, and for every i ∈ I let gi : Gi → Ai
be the unique morphism that arises from the universality property of the colimit.
Note that gi(ρU (a)) = aθ for every U ∈ τ and every i ∈ I. GA is a presheaf of
algebras. Let (SGA, g,I) be the associated sheaf.
In Construction 1, the stalk at i is isomorphic to Ai, but (FA, f,I) might be not a sheaf space. In Construction 2, (SGA, g,I) is a sheaf space, but gi : Gi → Ai may not be an isomorphism.
Theorem A.1 ([2]) The following conditions are equivalent:
If [a]θi = [b]θi then there is an open neighborhood U of i such that for every
j ∈ U, [a]θj = [b]θj .
(FA, f,I) is a sheaf of algebras.
For every i ∈ I, gi : Gi → Ai is an isomorphism.
Definition A.2 If (θi)i∈I is a family of congruences on an algebra A, then any topology on I that satisfies (1) is called an S-topology.
Corollary A.3 ([2]) Assume that the topology on I is an S-topology with respect to the family of congruences (θi)i∈I. Then (FA, f,I) and (SGA, g,I) are isomorphic sheaves of algebras for which
The stalk at i is isomorphic to Ai = A/θi,
The map α : A → Γ(I, FA) deﬁned by α(a) = ([a]θi )i∈I is a homomorphism,

In A →α
Γ(I, FA

i∈I
p
A/θi →
A/θi:

pi ◦ α is an epimorphism, and
A is a subdirect product of the family (A/θi)i∈I iff 
(i.e. iff α is a monomorphism).
The coarsest S-topology on I can be constructed as follows:


i∈I

θi = ΔA

Lemma A.4 ([2], [10]) Let A ‹→ 

i∈I
p
Ai → Ai
be a subdirect product. The coars-

est S-topology on I is generated by the sets E(a, b)={i∈I | pi(a)=pi(b)} as a subbasis.

Lemma A.5 ([10]) Let A ‹→ 
A  pi  A be a subdirect product and τ ,τ  be

i∈I	i →	i	1  2
two topologies on I. If τ1 ⊆ τ2 and τ1 contains the equalizer topology induced by A
(generated by the sets E(a, b) as a subbasis), then Γ(FA, (I, τ1)) ⊆ Γ(FA, (I, τ2)).

Even if the topology on I is an S-topology, A is not necessarily isomorphic to the algebra Γ(I, FA). A necessary and sufficient condition for A to be isomorphic to an algebra of global sections of a sheaf with fibers Ai = A/θi, for i ∈ I is given below:
Definition A.6 A family (ci)i∈I of elements of A is said to be global with respect
to (θi)i∈I if for every i ∈ I there exist ai ,..., ai , bi ,..., bi ∈ A such that:

1
(ai , bi ) ∈ θi for every j = 1,..., n,
n  1	n

j	j
If (ai , bi ) ∈ θk for every j = 1,...,n then (ck, ci) ∈ θk.
j	j
Theorem A.7 ([2]) Let (θi)i∈I be a family of congruences on an algebra A such that A is a subdirect product of (A/θi)i∈I. Endow I with its coarsest S-topology. Then α : A → Γ(I, FA) is an isomorphism iff for every family of elements (ci)i∈I global with respect to (θi)i∈I, there is a c ∈ A with (c, ci) ∈ θi for every i ∈ I.
B  Appendix. Partially commutative monoids
If G = (A, D) is a dependency graph, we denote by M (G) the quotient A∗/θ, where θ is the congruence generated by {(a1a2, a2a1) | (a1, a2) /∈ D} (a free partially commutative monoid).
Theorem B.1 (Corollary 1.4.5  in [3]) Let G be an undirected graph and {Gj |
j ∈ J} be a finite family of subgraphs of G. For j ∈ J let πj : M (G) → M (Gj) be
the canonical projection and π : M (G) →	M (Gj) be the homomorphism into

the direct product deﬁned by
( ) = (	( ))
j∈J
is injective iff	=	.

π t	πj t
j∈J . Then π
G	j∈JGj

If {Mj | j ∈ J} is a family of non-trivial free partially commutative monoids then

j∈J
Mj is free partially commutative iff J is finite [3]. If {Gj | j ∈ J} is not finite,

then – assuming that for every vertex x of G there are finitely many j ∈ J such that
x is a vertex of Gj – there is an injective morphism M (G) ‹→	M (Gj), where

(	) =  (	)
(	) for all
j∈J
=	a.e.	[3], p.27.

j∈J M Gj	{ mj
j∈J | mj ∈ M Gj
j ∈ J, mj	ε	8 }



















8 a.e. means almost everywhere
