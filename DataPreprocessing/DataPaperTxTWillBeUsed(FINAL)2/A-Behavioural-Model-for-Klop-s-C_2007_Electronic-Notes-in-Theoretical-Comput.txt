Electronic Notes in Theoretical Computer Science 169 (2007) 19–32	
www.elsevier.com/locate/entcs

A Behavioural Model for Klop’s Calculus
Mariangiola Dezani-Ciancaglini3 ,1
Dipartimento di Informatica, Universita` degli Studi di Torino corso Svizzera 185, 10149 Torino, Italy

Makoto Tatsuta2
National Institute of Informatics
2-1-2 Hitotsubashi, 101-8430 Tokyo, Japan


Abstract
A model characterising strong normalisation for Klop’s extension of λ-calculus is presented. The main technical tools for this result are an inductive definition of strongly normalising terms of Klop’s calculus and an intersection type system for terms of Klop’s calculus.
Keywords: Klop’s extension of λ-calculus, strong normalisation, intersection types, inverse limit lambda models.


Introduction
Klop’s extended λ-calculus [5] is a generalisation of Nederpelt’s calculus [8]: it was introduced to infer strong normalisation from weak normalisation. We recall that strong normalisation means that all reductions are terminating, while weak
normalisation means that at least one reduction to normal form is terminating.
The basic idea of Klop’s calculus is very simple and elegant: a redex (λx.M )N with
x not in the free variables of M reduces to the pair [M, N ], instead of reducing to
M . In this way no subterm is discarded, and strong normalisation coincides with weak normalisation, as proved in [5]. More precisely we use the variant of Klop’s λ-calculus discussed by Boudol in [2]: we call it λ∗-calculus.

1 e-mail:  dezani@di.unito.it
2 e-mail:  tatsuta@nii.ac.jp
3 Partially supported by FP6-2004-510996 Coordination Action TYPES and Cofin’04 project McTafi.

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.07.026

In [4] Honsell and Lenisa give the inverse limit construction HL∞ which solves the domain equation
D = [D →⊥ D]
where [D →⊥ D] is the set of strict continuous functions from D to D (a continuous function f is strict if f (⊥)= ⊥). In the companion paper [9] we proved that HL∞ characterises strong normalisation of λ-terms. In the present paper we interpret the λ∗-calculus in HL∞ and we show that HL∞ also characterises strong normalisation of λ∗-terms. More precisely our results are:
a λ∗-term S is strongly normalising iff HL∞ does not interpret S as bottom in the environment which associates top to all variables;
a λ∗-term S is persistently strongly normalising iff HL∞ interprets S as top in the environment which associates top to all variables;
where a λ∗-term S is persistently strongly normalising if, for all n and all strongly normalising λ∗-terms T1,... , Tn, the application ST1,... , Tn is strongly normalising too.
This proof is based on:
an inductive definition of the sets of strongly normalising and persistently strongly normalising λ∗-terms;
an extension of the intersection type assignment system of [4] for λ-terms to
λ∗-terms using the rule for typing pairs of [2].
As proved in [4], we can give a finitary logical description of HL∞ using inter- section types. In other words, we can define the intersection type theory HLwhich is the Stone dual of HL∞ in the sense of [1]. This allows us to express the interpre- tation of a λ∗-term S in the model HL∞ by means of the types derivable for S in the type system HL∗ induced by the theory HL.
The present paper is organised as follows. In Section 2 we introduce Klop’s extended λ-calculus and we discuss the inductive definition of strongly normalising and persistently strongly normalising λ∗-terms. In Section 3 we define the model
HL∞ and the intersection type assignment system HL∗ , and finally we prove the characterisation results.

Klop’s extended λ-calculus
Following [5] we extend the syntax of λ-terms with a pairing operator [ , ], i.e. we have the following syntax for λ∗-terms:
S ::= x | λx.S | SS | [S, S].
Λ∗ is the set of λ∗-terms.
In writing λ∗-terms we use vector notation in the standard way, i.e. λ→x.ST→

denotes λx1 ... xn.ST1 ... Tm, where →x is x1,... , xn and T→ lh( ) to denote the vector length.
is T1,... , Tm. We use

Following [2] we use [S, T1,... , Tn] and [S, T→ ] as short for [... [[S, T1], T2],... Tn]: it becomes S for n =0 and T→ empty.
On Λ∗ Boudol [2] defines the following reduction rules:
[λx.S, U1,... , Un]T →κ [S[x := T ], U1,... , Un]
if x ∈ FV (S)
[λx.S, U1,... , Un]T →κ [S, U1,... , Un,T ]
if x /∈ FV (S)
The relation →κ is the contextual closure of these rules and the relation →∗ is the
reflexive, transitive closure of →κ.
For example BOΔ →κ (λyz.O(yz))Δ →κ λz.O(Δz) →κ λz.[λt.t, Δz] →κ
λz.[λt.t, zz], where B = λxyz.x(yz), O = λvt.t,Δ = λu.uu.
A λ∗-term S is a κ-normal form if there does not exist a λ∗-term T such that
S →κ T .
A λ∗-term is weakly normalising if it has a finite reduction sequence to normal form. A λ∗-term is strongly normalising if all reduction sequences starting from it are finite. Let WN∗ and SN∗ be the set of weakly normalising and of strongly
normalising λ∗-terms, respectively.
In [2] Boudol shows:
Theorem 2.1 SN∗ = WN∗.
We prove that the application of nested pairs to a sequence of λ∗-terms is strongly normalising iff the application of the first element of the innermost pair to that sequence is strongly normalising and the second elements of all pairs are strongly normalising.
Lemma 2.2 [S, T→ ]U→ ∈ SN∗ iff SU→ , T→ ∈ SN∗.
Proof. We will prove both directions of this claim simultaneously by induction on

lh(U→ ). If U→
is empty, the claim clearly holds. Let U→
= U W→ . By Theorem 2.1 we

can assume that S, T→ , U, W→
are κ-normal forms.

If part. If S is a λ-free term, then [S, T→ ]U W→
is a κ-normal form. Otherwise let

S = [λx.V, P→ ]. If x ∈ FV (V ), then there is only one possible reduction step out of
[S, T→ ]U W→ , i.e. [S, T→ ]U W→ →κ [V [x := U ], P→ , T→ ]W→ . By SU W→ →κ [V [x := U ], P→ ]W→ ,
and the induction hypothesis for the if part, we conclude [V [x := U ], P→ , T→ ]W→ ∈ SN∗.
If x /∈ FV (V ), then there is only one possible reduction step out of [S, T→ ]U W→ ,
i.e. [S, T→ ]U W→ →κ [V, P→ , T→ , U ]W→ . By SU W→ →κ [V, P→ , U ]W→ and the induction
hypothesis for the only-if part, we have [V, P→ ]W→ ∈ SN∗. By the induction hypothesis
for the if part, we conclude [V, P→ , T→ , U ]W→ ∈ SN∗.

Only if part. If S is a λ-free term, then SU W→
is a κ-normal form. Otherwise let

S = [λx.V, P→ ]. If x ∈ FV (V ), then there is only one possible reduction step out of
SU W→ , i.e. SU W→ →κ [V [x := U ], P→ ]W→ . By the induction hypothesis for the only-if
part we conclude, since [S, T→ ]U W→ →κ [V [x := U ], P→ , T→ ]W→ . If x /∈ FV (V ), then
there is only one possible reduction step out of SU W→ , i.e. SU W→ →κ [V, P→ , U ]W→ .

From [S, T→ ]U W→ →κ [V, P→ , T→ , U ]W→ we get [V, P→ , T→ , U ]W→ ∈ SN∗. By the induction
hypothesis for the only-if part, we have [V, P→ ]W→ ∈ SN∗. We conclude [V, P→ , U ]W→ ∈
SN∗ by the induction hypothesis for the if part.	 
We define the set PSN∗ of persistent strongly normalising λ∗-terms as the set of λ∗-terms which preserve the strong normalisation property under application to an arbitrary number of strongly normalising λ∗-terms, i.e. S ∈ PSN∗ if for all X1,... , Xn ∈ SN∗ we get SX1 ... Xn ∈ SN∗.
The pairing of λ∗-term in PSN∗ with a λ∗-term in SN∗ remains in PSN∗ and the
application of a λ∗-term in SN∗ to a λ∗-term in PSN∗ remains in SN∗. These are the claims of the following lemma, respectively: the proof is given in [9].
Lemma 2.3  (i) S ∈ PSN∗ and T ∈ SN∗ imply [S, T ] ∈ PSN∗.
(ii) S ∈ SN∗ and T ∈ PSN∗ imply ST ∈ SN∗.
Similarly to [9] we also consider the class SN∗ of λ∗-terms which preserves the
strong normalisation property under application to n strongly normalising λ∗-terms,
i.e.	S ∈ SN∗ if for all X1,... , Xn ∈ SN∗ we get SX1 ... Xn ∈ SN∗.  Clearly
n
SN∗ = SN∗.
0
Figure 1 defines the sets PSN and SN : all rules but the last two are similar to the rules of [9] which give the inductive definition of the corresponding sets restricted to Λ. The last two rules are justified thinking that the functional behaviour of [S, U ] is the functional behaviour of S.
In the remaining of the present section we will show the correctness of our inductive definitions.
Theorem 2.4 PSN = PSN∗ and SN  = SN∗ .
To prove this, we need another theorem and a few lemmas, which we can obtain by extending the results in [9] to λ∗-terms in a straightforward way.
We call the following theorem “Substitution Theorem”, since it allows to sub- stitute different λ∗-terms in SN∗, instead of the same λ∗-term in SN∗, for different variables preserving the strong normalisation property.
Theorem 2.5 (Substitution Theorem for SN∗) If S[xi := X, xj := X] ∈ SN∗ for all X ∈ SN∗ for all i, j (1 ≤ i, j ≤ n), then S[x1 := X1,... , xn := Xn] ∈ SN∗ for all X1,... , Xn ∈ SN∗.
Proof. The proof of the same statement for λ-terms given in [9] extends without essential changes to λ∗-terms.	 
The first lemma shows a property of the set SN∗, which easily follows from Theorem 2.1 and Lemma 2.2.

Lemma 2.6 Let lh(→x) = lh(T→ ), then S[→x := (λ→x.S)T→ U→ ∈ SN∗.
T→ ]U→
∈ SN∗ and T→
∈ SN∗ iff

Proof. If x ∈ FV (S), the if part clearly holds and the only-if part follows from Theorem 2.1. If x /∈ FV (S), from (λx.S)T →κ [S, T ] we get the if part, and the

λ→x.S ∈ PSN (∀S ∈ S→)	lh(→x)= n	x ∈ →x λ→x.xS→ ∈ SN 

λ→x.S ∈ SN  (∀S ∈ S→)	y /∈ →x	lh(→x)= m
	m	
λ→x.yS→ ∈ SN 

λ→x.S ∈ SN	lh(x→ )= n	lh(y→) > 0
	n	
λ→x.λ→y.S ∈ SN 

λ→x.S[y := T ]V→ ∈ SN	y ∈ FV (S)	λ→x.[S, T ]V→ ∈ SN	y /∈ FV (S)
	n			n	

λ→x.(λy.S)T V→
SN 
n
λ→x.(λy.S)T V→
SN 
n


λ→x.S ∈ SN  (∀S ∈ S→)	lh(→x)= n	y /∈ →x
	n	
λ→x.yS→ ∈ PSN 


λ→x.S[y := T ]V→
∈ PSN	y ∈ FV (S)
λ→x.[S, T ]V→
∈ PSN	y /∈ FV (S)

λ→x.(λy.S)T V→
∈ PSN 
λ→x.(λy.S)T V→
∈ PSN 


λ→x.ST→ ∈ SN	λ→x.U ∈ SN	lh(x→ )= m
	n	m	
λ→x.[S, U ]T→ ∈ SN 

λ→x.ST→ ∈ PSN	λ→x.U ∈ SN	lh(x→)= n
	n	
λ→x.[S, U ]T→ ∈ PSN 

Fig. 1. Inductive definition of SN  and PSN .
only-if part follows from Theorem 2.1 and Lemma 2.2.	 
The following lemma, which is the key result for proving the completeness of the given inductive definition, uses in a crucial way the “Substitution Theorem” for SN∗, Theorem 2.5.
Lemma 2.7 If λ→x.xS→ ∈ SN∗ , where x ∈ →x and lh(→x) = n, then λ→x.S ∈ PSN∗ for

all S ∈ S→.
Proof. For arbitrary X→

∈ SN∗ with lh(X→ ) = n, we have (xS→)[→x := X→ ] ∈ SN∗ by

Lemma 2.6. Suppose lh(S→) = m and y /∈ FV (xS→). By Theorem 2.5, (yS→)[→x :=
X→ , y := Y ] ∈ SN∗ holds for all X→ , Y ∈ SN∗. For Si (1 ≤ i ≤ m), we will show
(λ→x.Si)X→ Z→ ∈ SN∗ for arbitrary X→ , Z→ ∈ SN∗. Let Y be λ→z.ziZ→ . Then we have

(yS→)[→x := X→ , y := Y ]= (λ→z.ziZ→ )S→[→x := X→ ] →∗ Si[→x := X→ ]Z→ . Hence Si[→x := X→ ]Z→ ∈
κ
∗	→ →	∗	∗
SN . By Lemma 2.6, we have (λ→x.Si)XZ ∈ SN . Therefore λ→x.Si ∈ PSN .	 

We can now show the soundness and completeness of the given inductive char- acterisations.

Proof of Theorem 2.4 [9] shows that PSN = PSN∗ and SN  = SN∗ holds when
∗	n	n	∗

we restrict to λ-terms, i.e. it shows PSN
∩ Λ= PSN ∩ Λ and SN ∩ Λ= SN
∩ Λ.

The present proof and that of [9] are similar.
We will show that the rules generate ONLY terms which satisfy the given condi-
tions, that is, PSN ⊆ PSN∗ and SN ⊆ SN∗ . This claim is proved by induction on
the formation rules. It suffices to show that if the statement holds for the premises
then it holds for the conclusion for each rule with ∗ instead of . For example for the rule
λ→x.S ∈ PSN (∀S ∈ S→)	lh(→x)= n	x ∈ →x λ→x.xS→ ∈ SN 
it is enough to show (λ→x.xS→)X→ ∈ SN∗ for all X→ ∈ SN∗ of length n. By the induction
hypothesis, we have λ→x.S ∈ PSN∗. Then S[→x := X→ ] ∈ PSN∗ by Lemma 2.6. Let
xj = x. By Lemma 2.3(ii), we have XjS→[→x := X→ ] ∈ SN∗. By Lemma 2.6, we have
(λ→x.xS→)X→ ∈ SN∗, so we conclude λ→x.xS→ ∈ SN∗ .
We also consider the rule:
λ→x.ST→ ∈ SN	λ→x.U ∈ SN	lh(x→ )= m
	n	m	
λ→x.[S, U ]T→ ∈ SN 
We assume m ≥ n, the proof for m < n being similar. By the induction hypothesis,
λ→x.ST→ ∈ SN∗ , and λ→x.U ∈ SN∗ . For arbitrary X→ ∈ SN∗ of length n, we have
→ →	n	∗	→m	∗	→ →
(λ→x.ST )X ∈ SN , and (λ→x.U )X ∈ SN . By Lemma 2.6 we get S[→x := X]T [→x :=
X→ ] ∈ SN∗ and U [→x := X→ ] ∈ SN∗, then by Lemma 2.2 [S[→x := X→ ],U [→x := X→ ]]T→ [→x :=

X→ ] ∈ SN∗. Again by Lemma 2.6 we get (λ→x.[S, U ]T→ )X→ λ→x.[S, U ]T→ ∈ SN∗ .
∈ SN∗, so we conclude

We will show that the rules generate ALL terms which satisfy the given condi-
tions, that is, PSN ⊇ PSN∗ and SN  ⊇ SN∗ . First notice that the conclusions of
the given rules cover all possible shapes of λ∗-terms but λ→x.xS→ with lh(→x)= n and

x ∈ →x for both PSN and SN 
with n < m. This is sound since in this case we can

always find λ-terms X→
such that (λ→x.xS→)X→
does not have normal form. We refer

to the proof of Theorem 4.9 in [9] for this construction.
The proof is by a double induction on the length of the longest reduction se- quence to normal form and on the structure of terms. We show that if the statement holds for the conclusion then it must hold for the premises in each rule with ∗ in- stead of . The induction hypothesis applies since either the terms in the premises
are obtained by reducing the term in the conclusion or they are smaller than the term in the conclusion.

The most interesting case is that of the rule
λ→x.S ∈ PSN (6S ∈ S→)	lh(→x)= n	x ∈ →x λ→x.xS→ ∈ SN 
By Lemma 2.7 λ→x.xS→ ∈ SN∗ implies λ→x.S ∈ PSN∗ for all S ∈ S→.
Another interesting case is the rule:
λ→x.ST→ ∈ SN	λ→x.U ∈ SN	lh(x→ )= m
	n	m	
λ→x.[S, U ]T→ ∈ SN 
whose proof follows from Lemma 2.2. The proof for the last rule is similar.

The model 7L∞
We start by recalling the definition of the Ð∞-model 7L∞ introduced in [4] to analyse perpetual strategies in λ-calculus.
Let Ð0 be the three point lattice ⊥ ± s ± T and Ð1 = [Ð0 →⊥ Ð0] be the set of strict continuous functions from Ð0 to Ð0, where a continuous function f is strict if f (⊥)= ⊥. Moreover let i0 be the initial projection defined by:
i0(⊥)= ⊥ ⇒ ⊥	i0(s)= T ⇒ s	i0(T)= s ⇒ T,
where d1 ⇒ d2 denotes the step function defined by
( d1 ⇒ d2)(e)= if e ± d1 then d2 else ⊥.
The inverse limit construction 7L∞ obtained starting from Ð0 and i0 is a model of the λI-calculus and of the λNK-calculus as shown in [4]. The interpretation of λ-terms in 7L∞ is defined in the standard way:
[[x]]ρ   = ρ(x)
[[MN ]]ρ = F[[M ]]ρ[[N ]]ρ
[[λx.M ]]ρ = G(λλ d ∈ 7L∞. if d /= ⊥ then [M ]]ρ[ d/x] else ⊥),
where (F, G) is a strict retraction from [7L∞ →⊥ 7L∞] to 7L∞. We recall that a pair of functions (f, g) is a strict retraction from Ð to S if they satisfy all the following conditions: f and g are continuous; f : S → Ð; g : Ð → S; f ◦ g = idD; g ◦ f (⊥E )= ⊥E .
We can easily extend the interpretation to λ∗-terms by the clause:
[[[S, T ]]]ρ = if [T ]]ρ /= ⊥ then [S]]ρ else ⊥.
This clause is quite natural in view of the fact that S is the meaningful term in [S, T ], while T is only recorded since it could have an infinite computation.
As proved in [4], we can give a finitary logical description of 7L∞ using inter- section types. In other words we can define an intersection type theory 7L which is the Stone dual of 7L∞ in the sense of [1].

σ ≤ σ ∩ σ	σ ∩ τ ≤ σ	σ ∩ τ ≤ τ σ ≤ σ', τ ≤ τ ' ⇒ σ ∩ σ' ≤ τ ∩ τ '
σ' ≤ σ, τ ≤ τ ' ⇒ σ → τ ≤ σ' → τ '
(σ → τ ) ∩ (σ → ζ) ≤ σ → τ ∩ ζ
ϕ ~ ω → ϕ	ω ~ ϕ → ω	ω ≤ ϕ σ ≤ σ	σ ≤ τ, τ ≤ ζ ⇒ σ ≤ ζ
Fig. 2. Type preorder
The set of types of 7L is build out of the constants ϕ and ω by the arrow and intersection constructors:
τ ::= ϕ | ω | τ → τ | τ ∩ τ.
We define a preorder relation on types whose axioms and rules are justified by:
viewing “→” as the function space constructor and “∩” as the set intersection,
considering the types ϕ and ω in correspondence with the elements s, T, respec- tively, but reversing the partial order in 7L∞ (this correspondence will be made explicit by the mapping m defined below).
Figure 2 defines the preorder ≤: we write τ ~ σ as short for τ ≤ σ and σ ≤ τ .
Notice that ω and ϕ are the smallest and the biggest types, respectively.
We recall that filters of types are sets of types upper closed and closed under intersection. Let J be the set of all filters: it is easy to check that J is an ω-algebraic complete lattice with respect to set theoretic inclusion, whose bottom element is the empty set and whose top element is the set of all types. Moreover as shown in [4] J is isomorphic to 7L∞ through the mapping:
mˆ(X)= . m(τ )
τ ∈X
where m(ϕ)= s, m(ω)= T, m(τ1 → τ2)= m(τ1) ⇒ m(τ2), m(τ1 ∩ τ2)= m(τ1) H m(τ2). We extend the intersection type assignment system of [4] to λ∗-terms: we call
7L∗ the resulting system. We use Γ to denote a basis, i.e. a mapping from variables to types. The typing rules are shown in Figure 3: they are standard, but the typing rule for pairs of λ∗-terms which is given in [2]. We denote by ▶ derivability in this system. It is easy to verify that strengthening and weakening are admissible rules in this system:

Γ,x : σ ▶ S : τ	x /∈ FV (S) Γ ▶ S : τ
Γ ▶ S : τ	x /∈ Γ Γ,x : σ ▶ S : τ

The type assignment system enjoys a Generation Lemma whose restriction to Λ is proved in [3]. The proof of the last clause which is the only new clause follows easily by induction on deductions.

(Ax)

(→ I)
(x : σ) ∈ Γ Γ ▶ x : σ
Γ,x : σ ▶ S : τ

Γ ▶ λx.S : σ → τ
([ , ])

(→ E)
Γ ▶ S : τ Γ ▶ T : σ
Γ ▶ [S, T ]: τ
Γ ▶ S : σ → τ Γ ▶ T : σ
Γ ▶ ST : τ

(≤)
Γ ▶ S : σ σ ≤ τ
Γ ▶ S : τ
(∩I)
Γ ▶ S : σ Γ ▶ S : τ
Γ ▶ S : σ ∩ τ

Fig. 3. Typing rules
Lemma 3.1 (Generation Lemma)	(i) Γ ▶ x : τ iff there is σ such that x : σ ∈ Γ
and σ ≤ τ.
Γ ▶ ST : τ iff there is σ such that Γ ▶ S : σ → τ and Γ ▶ T : σ.
Γ ▶ λx.S : σ → τ iff Γ,x : σ ▶ S : τ.
Γ ▶ [S, T ]: τ iff Γ ▶ S : τ and there is σ such that Γ ▶ T : σ.
We can now formulate Stone duality for the model 7L∞ generalising the result proved in [4] for λ-terms.
Theorem 3.2 (Stone Duality) Let Γ |= ρ if x : σ ∈ Γ implies m(σ) ± ρ(x). We
have
[[S]]ρ = .{m(τ ) | ∃Γ |= ρ.Γ ▶ S : τ }.
Proof. The proof is by induction on S. The same statement restricted to λ-terms is proved in [4]. Therefore we only need to consider the case of pairs, i.e. let
S = [T, V ]. By the induction hypothesis [T ]]ρ = .{m(τ ) | ∃Γ |= ρ.Γ ▶ T : τ } and
[[V ]]ρ = .{m(τ ) | ∃Γ |= ρ.Γ ▶ V : τ }.
[[[T, V ]]]ρ = if [V ]]ρ /= ⊥ then [T ]]ρ else ⊥
= if ∃Γ |= ρ.Γ ▶ V : σ for some σ then .{m(τ ) | ∃Γ |= ρ.Γ ▶ T : τ }
else ⊥ by the induction hypothesis
= .{m(τ ) | ∃Γ |= ρ.Γ ▶ [T, V ]: τ } by Lemma 3.1(iv).

Let ρT be the environment which associates T to all variables. We can char- acterise strongly normalising and persistently strongly normalising λ∗-terms in the model 7L∞ as the λ∗-terms whose meaning in the environment ρT is different from
⊥ and equal to T, respectively. I.e. we have:
Theorem 3.3 (Main Theorem)  (i) A λ∗-term S is strongly normalising iff
[[S]]ρT /= ⊥.
(ii) A λ∗-term S is persistently strongly normalising iff [[S]]ρT = T.
The proof of this theorem uses the above discussed isomorphism between 7L∞
and J. The theorem in fact can be reformulated as follows:
Theorem 3.4 Let Γω = {x : ω | x ∈ Var }.

A λ∗-term S ∈ SN∗ iff Γω ▶ S : ϕ.
A λ∗-term S ∈ PSN∗ iff Γω ▶ S : ω.
The remaining of the present section is devoted to the proof of this theorem. Subsection 3.1 shows the if parts of the claims (i) and (ii) by means of a realizability interpretation of intersection types. The only if parts of these claims can be shown using the inductive definitions of SN∗ and PSN∗ given in Section 2: this proof is the
content of Subsection 3.2.
Proof of Theorem 3.4 (⇐)
In order to develop the reducibility method we consider Λ∗ as the applicative struc- ture whose domain is the set of λ∗-terms and whose application is just the applica- tion of λ∗-terms.
We first define a mapping between types and sets of λ∗-terms.
Definition 3.5 The interpretation of types is the mappping [ ] defined by: [[ϕ]]  = SN∗
[[ω]]   = PSN∗
[[σ → τ ]] = {S ∈ Λ∗ | 6T ∈ [[σ]] ST ∈ [[τ ]]}
[[σ∩τ ]]	= [[σ]] ∩ [[τ ]].
We extend to Λ∗ the standard definition of saturated set, as given for example in Krivine [6], [7].
Definition 3.6 A set S ⊆ Λ∗ is saturated if for all S, T, U→ ∈ Λ∗:
S[x := T ]U→ ∈ S & x ∈ FV (S) ⇒ (λx.S)T U→ ∈ S 
[S, T ]U→ ∈ S & x /∈ FV (S) ⇒ (λx.S)T U→ ∈ S 

SU→ ∈ S & T ∈ SN∗ ⇒ [S, T ]U→
∈ S.

We can show that all sets in the range of our interpretation of types are saturated.
Lemma 3.7 For all types τ the set [[τ ]] is saturated.
Proof. The proof is by structural induction on types. The third condition for atomic types follows from Lemmas 2.2 and 2.3(i).

The more interesting case is that of arrow types.	Suppose S[x := T ]U→
∈ [[τ →

σ]] and x ∈ FV (S). Let V ∈ [[τ ] be arbitrary. By Definition 3.5 S[x := T ]U→ V ∈
[[σ ]. Then by the induction hypothesis (λx.S)T U→ V ∈ [[σ]]. Since V was arbitrary,

according to Definition 3.5 we get (λx.S)T U→
∈ [[τ → σ]]. Similarly one can show

the remaining two conditions.	 
The preorder on types agrees with the set theoretic inclusion between type in- terpretations.

Lemma 3.8 If τ ≤ σ, then [[τ ]] ⊆ [[σ]].
Proof. By induction on the length of the derivation of τ ≤ σ. The definition of
PSN∗ and Lemma 2.3(ii) justify the axioms for atomic types.	 
We define the valuation of λ∗-terms [[−]]θ : Λ∗ → Λ∗ and the semantic satisfi- ability relation |=, which connects the type interpretation and the term valuation, as follows.
Definition 3.9 Let θ : Var → Λ∗ be a valuation of term variables in Λ∗. Then
[−]]θ : Λ∗ → Λ∗ is deﬁned by
[[S]]θ = S[x1 := θ(x1),... , xn := θ(xn)], where FV (S)= {x1,... , xn};
θ |= S : τ	if	[[S]]θ ∈ [[τ ]];
θ |=Γ	if	(6(x : τ ) ∈ Γ)	θ |= x : τ;
Γ |= S : τ	if	(6θ |= Γ)	θ |= S : τ.
We can prove that our type assignment system is sound for the above semantic satisfiability.
Theorem 3.10 (Soundness)
Γ ▶ S : τ ⇒ Γ |= S : τ.
Proof. By induction on the derivation of Γ ▶ S : τ .
Case 1. The last step is (Ax), i.e. Γ,x : τ ▶ x : τ . Then Γ,x : τ |= x : τ by Definition 3.9(iii).
Case 2. The last step is ([ , ]), i.e. Γ ▶ S : τ, Γ ▶ T : σ ⇒ Γ ▶ [S, T ] : τ . By the induction hypothesis [S]]θ ∈ [[τ ]] and [[T ]]θ ∈ [[σ ], which implies [T ]]θ ∈ SN∗ by Lemma 3.8. We conclude by Lemma 3.7.
Case 3. The last step is (→ E), i.e. Γ ▶ S : τ → σ, Γ ▶ T : τ ⇒ Γ ▶ ST : σ. Then by the induction hypothesis Γ |= S : τ → σ and Γ |= T : τ . Let θ |= Γ, then [[S]]θ ∈ [[τ → σ]] and [[T ]]θ ∈ [[τ ]. Therefore [ST ]]θ ≡ [[S]]θ[[T ]]θ ∈ [[σ]].
Case 4. The last step is (→ I), i.e. Γ,x : τ ▶ S : σ ⇒ Γ ▶ λx.S : τ → σ. By the
induction hypothesis Γ,x : τ |= S : σ. Let θ |=Γ and let T ∈ [[τ ]. We can assume
x /∈ θ(y) for all y ∈ FV (S).
If x ∈ FV (S), we define θ[x := T ](x) = T, θ[x := T ](y) = θ(y) for x /= y. Then
θ[x := T ] |= Γ, since x ∈/ Γ, and θ[x := T ] |= x : τ , since T ∈ [[τ ]].	There-
fore θ[x := T ] |= S : σ, i.e.  [S]]θ[x := T ] ∈ [[σ ], which means by Definition 3.9(i)
that S[→y := θ(→y)][x := T ] ∈ [[σ]], where →y = FV (S) \ {x}. By Lemma 3.7 we have
(λx.S[→y := θ(→y)])T ∈ [[σ]]. Then [[λx.S]]θT ∈ [[σ]], since x ∈/ FV (λx.S). We conclude [[λx.S]]θ ∈ [[τ → σ]], since T ∈ [[τ ] was arbitrary.
If x /∈ FV (S), notice that by Lemma 3.8 T ∈ [[τ ] implies T ∈ SN∗. Therefore from [[S]]θ ∈ [[σ ] by Lemma 3.7 we get [ [S]]θ,T ] ∈ [[σ ], which implies (λx.[[S]]θ )T ∈ [[σ]] by the same lemma. We conclude [[λx.S]]θ ∈ [[τ → σ]], since T ∈ [[τ ] was arbitrary.
Case 5. The last step is (∩I), i.e. Γ ▶ S : τ, Γ ▶ S : σ ⇒ Γ ▶ S : τ ∩ σ. Then by
the induction hypothesis Γ |= S : τ and Γ |= S : σ. Let θ |= Γ, then [S]]θ ∈ [[τ ]] and

[[S]]θ ∈ [[σ ]. Therefore [S]]θ ∈ [[τ ∩ σ ], i.e. Γ |= S : τ ∩ σ.
Case 6. The last step is (≤), i.e. Γ ▶ S : τ, τ ≤ σ ⇒ Γ ▶ S : σ. By the induction hypothesis Γ |= S : τ . Let θ |= Γ, then [S]]θ ∈ [[τ ]. According to Lemma 3.8 [[τ ]] ⊆ [[σ]], so it follows that [[S]]θ ∈ [[σ ], i.e. Γ |= S : σ.	 
Proof of Theorem 3.4(⇐) . Let Γω ▶ S : ϕ. By soundness (Theorem 3.10) we have that if θ |= Γω, then [S]]θ ∈ [[ϕ]] = SN∗. We can take θ1(x)= x, being θ1 |= Γω, because all variables belong to PSN∗. Obviously, θ1(S) = S for every λ∗-term S. Therefore we get that S ∈ SN∗. Similarly from Γω ▶ S : ω we get S ∈ PSN∗. 
Notice that this proof is an extension of the proof given in [4] for Λ to Λ∗.
Proof of Theorem 3.4 (⇒)
It is useful to have the invariance of typing under subject expansion. This property has been proved in [4] for Λ.
Theorem 3.11 (Subject Expansion)	(i) If Γ ▶ S[x := T ]: τ and x ∈ FV (S), then Γ ▶ (λx.S)T : τ.
(ii) If Γ ▶ [S, T ]: τ and x /∈ FV (S), then Γ ▶ (λx.S)T : τ.
Proof. The proof of (i) done in [4] for Λ extends to Λ∗.
For (ii) let Γ ▶ [S, T ]: τ . By Lemma 3.1(iv) we get Γ ▶ S : τ and Γ ▶ T : σ for some type σ. Since x /∈ FV (S) by strengthening and weakening we derive Γ,x : σ ▶ S : τ . We conclude using rules (→ I) and (→ E).	 
The proof of Theorem 3.4 (⇒) can be done using the inductive definitions of SN∗ and PSN∗ given in Section 2. More precisely it easily follows from the following lemma, whose restriction to Λ is proved in [9].
Lemma 3.12  (i) If S ∈ PSN , then Γω ▶ S : ω.
(ii) If S ∈ SN , then Γω ▶ S : ϕn → ϕ where ϕn → ϕ = ϕ → ... ϕ → ϕ.
`	˛¸	x
Proof. The proof of the same Lemma done in [9] for Λ considers all rules in Figure 1 but those in the lines four, six, seven, and eight, so we only need to consider these rules.
For the rule
λ→x.S[y := T ]V→ ∈ SN	y ∈ FV (S)
	n	

λ→x.(λy.S)T V→
SN 
n

by the induction hypothesis we know that Γω ▶ λ→x.S[y := T ]V→
: ϕn → ϕ.	Let

m = lh(→x). We suppose m ≤ n, since the case m > n is similarly proved.  By
Lemma 3.1(iii) we get Γω, →x : ϕ→ ▶ S[y := T ]V→ : ϕn−m → ϕ. By Lemma 3.1(ii) there exists →τ such that Γω, →x : ϕ→ ▶ S[y := T ]: →τ → ϕn−m → ϕ and Γω, →x : ϕ→ ▶ Vi : τi for 1 ≤ i ≤ h, where h = lh(V→ ). This implies Γω, →x : ϕ→ ▶ (λy.S)T : →τ → ϕn−m → ϕ by Theorem 3.11(i) and so we conclude Γω ▶ λ→x.(λy.S)T V→ : ϕn → ϕ by the rules (→ E) and (→ I).

For the rule

λ→x.[S, T ]V→ ∈ SN	y /∈ FV (S)

	n	

λ→x.(λy.S)T V→
SN 
n

by the induction hypothesis we know that Γω ▶ λ→x.[S, T ]V→
: ϕn → ϕ.	Let

m = lh(→x). We suppose m ≤ n, since the case m > n is similarly proved.	By
Lemma 3.1(iii) we get Γω, →x : ϕ→ ▶ [S, T ]V→ : ϕn−m → ϕ. By Lemma 3.1(ii) there
exists →τ such that Γω, →x : ϕ→ ▶ [S, T ]: →τ → ϕn−m → ϕ and Γω, →x : ϕ→ ▶ Vi : τi for
1 ≤ i ≤ h, where h = lh(V→ ). This implies Γω, →x : ϕ→ ▶ (λy.S)T : →τ → ϕn−m → ϕ by Theorem 3.11(ii) and so we conclude Γω ▶ λ→x.(λy.S)T V→ : ϕn → ϕ by the rules (→ E) and (→ I).
For the rule
λ→x.ST→ ∈ SN	λ→x.U ∈ SN	lh(x→ )= m
	n	m	
λ→x.[S, U ]T→ ∈ SN 
by the induction hypothesis we know that Γω ▶ λ→x.ST→ : ϕn → ϕ and Γω ▶ λ→x.U :
ϕm → ϕ. We suppose m > n, since the case m ≤ n is similarly proved. Let
→x1→x2 = →x and lh(→x1) = n. By Lemma 3.1 we have Γω, →x1 : ϕ→, →x2 : →ω ▶ S : →τ → ϕ, and Γω, →x1 : ϕ→, →x2 : →ω ▶ Ti : τi (1 ≤ i ≤ lh(T→ )), and Γω, →x1 : ϕ→, →x2 : →ω ▶ U : ϕ. We conclude using the rules ([ , ]), (→E), and (→I). The proofs for the remaining rules are similar.	 

Concluding remarks
We have shown that for a λ∗-term S the following four conditions are equivalent:
SX1 ... Xn is strongly normalising for all n and all strong normalising
X1,... , Xn.
S ∈ PSN as defined in Figure 1.
Γω ▶ S : ω in the intersection type assignement system 7L∗.
[S]]ρT = T in the model 7L∞.
As an application of the “Substitution Theorem” we get that:
∃X1,... , Xn ∈ SN∗.SX1 ... Xn /∈ SN∗ ⇒ ∃X ∈ SN∗.S X .. . X /∈SN∗
` ˛n¸ x
therefore we plan to investigate consequences of this theorem in the study of infinite reductions.

References
Samson Abramsky. Domain Theory in Logical Form. Ann. Pure Appl. Logic, 51(1-2):1–77, 1991.
G´erard Boudol. On Strong Normalization in the Intersection Type Discipline. In Martin Hofmann, editor, TLCA’03, volume 2701 of LNCS, pages 60 –74. Springer-Verlag, 2003.
Mariangiola Dezani-Ciancaglini, Furio Honsell, and Yoko Motohama. Compositional Characterization of λ-terms using Intersection Types. Theoret. Comput. Sci., 340(3):459–495, 2005.

Furio Honsell and Marina Lenisa. Semantical Analysis of Perpetual Strategies in λ-calculus. Theoret. Comput. Sci., 212(1-2):183–209, 1999.
Jan Willem Klop. Combinatory Reduction Systems. PhD thesis, Utrecht University, 1980. Appeared as Mathematical Centre Tracts 127, Kruislaan 413, 1098 SJ Amsterdam.
Jean-Louis Krivine. Lambda-calcul, types et mod`eles. Masson, Paris, 1990.
Jean-Louis Krivine. Lambda-calculus, types and models. Ellis Horwood, New York, 1993. Translated from the 1990 French original by Ren´e Cori.
Robert Pieter Nederpelt. Strong Normalisation for a Typed Lambda Calculus with Lambda Structured Types. PhD thesis, Eindhoven University, 1973.
Makoto Tatsuta and Mariangiola Dezani-Ciancaglini. Normalisation is Insensible to Lambda-term Identity or Difference. In LICS’06, 2006. to appear.
