Electronic Notes in Theoretical Computer Science 72 (2007) 45–58	
www.elsevier.com/locate/entcs

A Higher-Order Calculus for Graph Transformation 1
Maribel Ferna´ndez and Ian Mackie2 ,3
Department of Computer Science, King’s College, Strand, London WC2R 2LS
Jorge Sousa Pinto4
Departamento de Inform´atica, Universidade do Minho, 4710-057 Braga, Portugal

Abstract
This paper presents a formalism for defining higher-order systems based on the notion of graph transfor- mation (by rewriting or interaction). The syntax is inspired by the Combinatory Reduction Systems of Klop. The rewrite rules can be used to define first-order systems, such as graph or term-graph rewriting systems, Lafont’s interaction nets, the interaction systems of Asperti and Laneve, the non-deterministic nets of Alexiev, or a process calculus. They can also be used to specify higher-order systems such as hierarchical graphs and proof nets of Linear Logic, or to specify the operational semantics of graph-based languages.
Keywords: Higher-order system, graph transformation, Combinatory Reduction System, graph rewriting system


Introduction
Rule-based transformations of graphs have been used in many areas of computer science, including the specification and development of software systems, the defini- tion of visual languages, the implementation of programming languages (see [5,25]). The notion of interaction, which can be seen as a particular kind of graph trans- formation, has been used to model concurrent systems [23], to give a semantics to (linear) logic proofs [11], as a programming discipline [17], and as an implementation technique for functional languages [3]. In each case, a syntax and an operational semantics (a calculus) has been defined, often independently.

1 Partially supported by TMR LINEAR.
2 Email: maribel@dcs.kcl.ac.uk
3 Email: ian@dcs.kcl.ac.uk
4 Email: jsp@di.uminho.pt

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2002.09.005

In this paper we present a higher-order language that can serve to specify in- teraction systems as well as graph and term-graph rewriting systems. The syntax is inspired by the Combinatory Reduction Systems (CRSs) of Klop [16], and can be seen as a generalization of the equational notation for term-graph rewriting [2]. We demonstrate its use by giving several examples of application, including the definition of hierarchical graphs (where it is possible to abstract subgraphs, see [4] for more details), a first-order interaction language together with its operational semantics (all in the same language), and the specification of higher-order program transformations and optimization schemes. The latter will be defined for Lafont’s interaction nets [17].
¿From a practical point of view, the higher-order syntax can be used as a tool in the design and implementation of graphical languages: it allows us to express not only graphical programs but also their operational semantics (including evaluation strategies and optimization schemes), type systems, and transformations used in the proof of meta-theoretical properties of programs. An instance of the latter kind of transformation is the packing operator defined by Lafont [19] to prove the universality of the interaction combinators (a specific system of interaction nets in which every interaction net can be encoded). Other packing and unpacking operations have been described in [9], and they can all be formally defined using higher-order rules in our system.
Another aspect where the higher-order syntax presents advantages is for struc- turing and modularizing programs defined by graphs (or nets). Hierarchical defini- tions are very useful in the framework of graph rewriting [4], and the same techniques can be exported to interaction nets using the higher-order syntax. In particular, the operation that combines two interaction nets to produce a new net where one or more edges have been connected together (the analogous of application in functional programming) is currently a meta-operation. We show how to internalize it using the higher-order language, and give examples where this technique is used to write modular programs. Once we have the ability to model the combination of nets, it is straightforward to express a notion of higher-order interaction nets, where a net depends on another net. As with functional programming, this technique can be used to write recursive nets: nets which depend on themselves.
Related Work. Our syntax is inspired by CRSs, but similar results can be ob- tained by using other higher-order systems, such as Nipkow’s Higher-order Rewrite Systems [22], or Khasidashvili’s Expression Reduction Systems [13]. The three for- malisms are closely related [26]. CRSs have been used in previous work on interac- tion nets: Laneve [20] defined Interaction Systems as CRSs, and in [7] a translation function is given from interaction nets to CRSs.
Van Raamsdonk [27] defines a class of higher-order rewrite systems with a gen- eral notion of substitution and shows the encoding of several languages, including Interaction Systems and Proof Nets of linear logic. Our goal is more specific: our higher-order textual notation has been designed to represent graph-based transfor- mations, and therefore the calculus contains specific graph-oriented features. The notation used to represent graphs in the calculus is a generalization of the equational

graph rewriting systems studied by Ariola, Klop and Blom (see for instance [2,15]). Some of the higher-order features defined in this paper could also be defined in Generalized Interaction Nets [10], by defining an interaction language where agents can carry nets. However, the higher-order calculus gives a uniform language to
define higher-order agents and higher-order rewrite rules.
Organization. Section 2 briefly reviews CRSs, graph and term-graph rewriting, and interaction nets. Section 3 introduces the syntax of our higher-order systems, and Section 4 shows how to represent graph and term-graph rewriting systems, interaction nets, interaction systems and non-deterministic nets. In Section 5 we then go on to define different sets of higher-order rules. Section 6 contains a simple example of application. We conclude the paper in Section 7.

Background
Combinatory Reduction Systems. CRSs [16] combine the usual first-order term rewriting systems with the presence of bound variables as in the λ-calculus. We recall the basic definitions.
Metaterms over an alphabet Σ are defined by the grammar:
t ::= x | [x]t | f (t1,... , tn) | Zn(t1,... , tn)
where x denotes a variable, f ∈ Σ is a function symbol of arity n, Zn is a metavari- able and the binary operator [·]· denotes abstraction. Terms are metaterms that do not contain metavariables.
A rewrite rule is a pair l → r of closed metaterms, where l has the form f (s1,... , sn), the metavariables that occur in r occur also in l, and the metavari- ables Zk that occur in l occur only in the form Zk(x1,... , xk), where x1,... , xk are
i	i
pairwise distinct variables.
The metavariables in metaterms can be thought of as holes that must be instan- tiated by terms. In other words, rules act as schemes defining a reduction relation on terms. Formally, to define the rewrite relation we have to consider a notion of substitution using substitutes and valuations.
An n-ary substitute is an expression of the form λx1 ... xn.t, where t is a term and x1,... , xn are different variables (n ≥ 0). It can be applied to an n-tuple s1,... , sn of terms, and the result is the term t where x1,... , xn are simultaneously replaced by s1,... , sn. A valuation σ is a map that assigns an n-ary substitute to each n-ary metavariable. This is extended to a mapping from metaterms to terms: given a valuation σ and a metaterm t, first we replace all metavariables in t by their images in σ and then we perform the developments of the β-redexes created by this replacement. When making a substitution, we must take care of bound variables as usual.
A rewrite step is defined as follows: if l → r is a rewrite rule, σ a valuation, and
C[ ] the usual notion of a context, then C[lσ] → C[rσ].
Interaction Nets. This is a graphical rewriting framework for programming intro- duced in [17]. Let Σ be a set of agents, each with a fixed arity which is the number of

its auxiliary ports, and one principal port (depicted by an arrow) where interaction can take place.
x1	···	xn
 ,/,
 vJ
A net is an undirected graph whose vertices are agents in Σ, and whose edges join different ports in the same or in different agents. A net may be empty, or consist just of edges without agents. Ports that are not connected to other ports in the net are called free, and marked with edges that have a free extreme. The interface of a net is the (ordered) set of free extremes of edges.
Interaction rules are net rewriting rules where the left-hand side consists of two agents connected on their principal ports (this is called an active pair, written α da β), and the right-hand side is an arbitrary net with the only constraint that it must have the same interface as the left-hand side. There is at most one rule for each pair of agents. As an example, in Fig. 1 we show Lafont’s interaction combinators [19].
An interaction step on a net W replaces an active pair (i.e. the occurrence of a left-hand side of an interaction rule) by the corresponding right-hand side, plugging the edges in the interface of the right-hand side to the corresponding ports in W . We write interactions as a binary relation W =⇒ W ', =⇒∗ denotes its reflexive and transitive closure.

 ,/,
,ˆ,,ˆ,
 ,/,
 ,/,

ц	δ	δ	ц	δ

 vJ	 J/ J
 vJ
 vJ

ˆ =⇒	 /
ˆ =⇒
ˆ	=⇒

,,	,ц /, ,ц ,
,,	,,
δ

/ J
 vJ vJ
/ J
/ J



 ,ц /,
 vJ



,ˆ,,ˆ,
 ,/,
δ
=⇒
,,
,ˆ,,ˆ, vJ=⇒

,ˆ,	ϵ	ϵ
,ˆ,	ϵ	ϵ
,ˆ,

ϵ	 J J	ϵ	 J J	ϵ

Fig. 1. Interaction Combinators

Graph and Term-Graph Rewriting. We recall the standard definition of graph- rewriting using edge-labelled hypergraphs. Let L be a label alphabet where each label has a fixed arity. A hypergraph H over L consists of a finite set VH of nodes, a finite set EH of hyperedges, a labelling function labH : EH → L and an attachment func-

tion attH : EH → V ∗
such that for each hyperedge e, |attH(e)| = arity(labH(e)).

We assume that VH and EH are disjoint. A sequence of nodes, called points, may be designated as the interface of the hypergraph (where it may be glued with other

hypergraphs).
In the following we simply write graph and edge instead of hypergraph and hyperedge. Due to space limitations, we give an informal definition, taken from [12], of a simple kind of graph transformation.
A graph transformation rule P → R consists of a pattern P and a replacement graph R. A transformation step G =⇒ H using the rule P → R is defined as follows:
Find a subgraph P ' of G that is a copy of P (i.e., that matches the left-hand side of the rule);
Check that every node in P ' that is linked to an edge outside P ' corresponds to a point of P (this is called the no dangling links condition);
Remove P ' from G up to its points, to obtain a context graph C,
Glue a copy R' of R to C by identifying the points of P ' with the corresponding points of R', obtaining H.
The relation =⇒∗ is the reflexive-transitive closure of =⇒.
A hierarchical graph is a graph where some edges contain hierarchical graphs. Formally, the class H = i≥0 Hi of hierarchical graphs consists of triples H = (G, F, cts) such that G is a graph, F ⊆ EG is the set of frame edges, and cts : F →H assigns to each frame f ∈ F its contents cts(f ) ∈ H. The sets Hi are defined inductively as follows: H = (G, F, cts) ∈ H0 if F = ∅, and for i > 0, H ∈ Hi if cts(f ) ∈ Hi−1 for every f ∈ F .
The definition of graph transformation generalizes to hierarchical graphs. We refer to [12,4] for more details.
Term-graphs are particular graphs which can be seen as trees with shared sub- trees. In the definition we use the notion of result (see [24]): v0 is the result node of the edge e in a graph G if attG(e)= v0 ... vn. Let Σ be a set of function symbols with fixed arities and X an infinite set of variables (symbols of arity 0). A graph G over Σ is a term-graph if there is a node rootG from which each node is reachable, G is acyclic, and each node is the result of a unique edge.

A Higher-Order Calculus for Graph Transformations
The syntax of our higher-order systems is inspired by CRSs. We first define an appropriate language, and then show examples of application.
Terms and Metaterms. Our language will be many-sorted. For each sort we will have a different set of meta-variables as shown:
Iterm for terms, with metavariables {T A→ | n ≥ 0}
Eq for equations (pairs of terms), with metavariables {EA→ | n ≥ 0}
TList for lists of terms, with metavariables {IA→ | n ≥ 0}
EqList for lists of equations, with metavariables {ΔA→ | n ≥ 0}
Conﬁg for configurations (representing nets or graphs), with metavariables {CA→ |

n ≥ 0}
The set of sorts may contain other (user-defined) sorts. For each metavariable, say T A→ , A→ = A1 × ... × Ak (with the Ai sorts and k ≥ 0) is its signature, which can be determined by examining the metaterm where it occurs. Thus, as is usual for CRSs, we will omit these and furthermore T0, T1, T2,... will often be written T, T ',T '',... The alphabet also contains a set F of function symbols including:
A set Σ of agents with fixed arities. Each agent α with arity n has the signature
Iterm × ... × Iterm → Iterm
n
· = · with signature Iterm × Iterm → Eq
⟨·| ·⟩ with signature TList × EqList → Conﬁg (to represent nets)
{·| ·} with signature TList × TList → Conﬁg (to represent graphs)
tl with signature Iterm → TList
el with signature Eq → EqList
·  · with signature TList × TList → TList
·∗ · with signature EqList × EqList → EqList
η with signature Conﬁg → Conﬁg
comb with signature Conﬁg × Conﬁg → Conﬁg
Finally, our language contains also a set {x, y, z, ·· ·} of variables, the abstraction
binary operator [ ] , and the symbols ‘(’, ‘)’, and ‘,’.
Definition 3.1 Metaterms are formed as follows, and then a term is a metaterm with no occurrences of metavariables.
a variable is a metaterm of sort Iterm
if t is a metaterm of sort s and x is a variable, then [x]t is a metaterm of sort s
if t1,... , tn are metaterms of sorts A1,... , An respectively, and F is a function symbol with signature A1 × ... × An → B, then F (t1,... , tn) is a metaterm of sort B.

if t1,... , tk are metaterms of sorts A1,... , Ak respectively, and M A→
is a meta-

variable of sort B, with A→ = A1 × ... × Ak (and k ≥ 0), then M A→ (t1,... , tk) isa 
metaterm of sort B.
A list of interaction terms is of the form (... (tl (t1)  tl (t2))	 tl (tn)) but we
will simply write it as t1, t2,.	, tn. A list with a single term tl (t) will be written as
t. The same conventions apply to lists of equations, formed with the ·∗ · operator. We remark that reduction will be defined modulo associativity and commuta- tivity of · · and ·∗ ·, and also modulo commutativity of · = ·. This justifies the previous notational conventions, and will give us the desired meaning for multisets
of terms (used in the interface of configurations) and for multisets of equations.
Notation 3.2 [x1][x2] ... [xn]C will be written as [x1, x2,.	, xn]C, and we write a

term like η[x1, x2,... , xn]C simply as ηx1 ... xn.C. We will also use the notation →x for a list of variables x1, x2,... , xn; →x→y denotes concatenation of lists →x and →y. We will in particular abstract variables in conﬁgurations, to represent internal links.
Rewrite Rules. Metaterms are used as the left- and right-hand side of rewrite rules. The metavariables contained in them indicate places where terms can be substituted, as in CRSs.
Definition 3.3 A rewrite rule is a pair l → r of closed metaterms such that the metavariables in r occur also in l.
Note that left-hand sides of rules may contain patterns of the form Z(t) where Z is a meta-variable and t a term. This will allow us to write contextual rules (such as the optimization rules in Section 5). The Context-sensitive Reduction Systems defined in [14] allow this use of metavariables.
The definition of rewrite step given for CRSs still applies in this generalized set- ting, but since we have some associative and commutative symbols in the alphabet we need to use pattern-matching modulo. More precisely: if l → r is a rewrite rule, σ a valuation, C[] a context, and t = lσ modulo associativity and commutativity of ·  · and ·∗ ·, and modulo commutativity of · = ·, then C[t] → C[rσ].

Representing First-Order Systems
Here we show that graph and term-graph rewriting systems, interaction nets and other first-order systems of interaction can be represented in our language.
Graph Rewriting. A hypergraph H = (VH, EH , labH , attH) will be represented by a term of the form η→x.{s | t} of sort Conﬁg (a configuration for short), where s represents the points (interface) of the graph, and t is a list containing a term α(x1,... , xn) for each hyperedge e ∈ EH such that labH(e) = α, and attH(e) = x1,... , xn. In other words, nodes are represented by variables and edges by agents (named as the label). The purpose of the binder η at the head of the configuration is to hide all the nodes xi that are not in the interface.
The representation of graph transformation rules is straightforward: Let P → R be a rule, where the pattern graph P is represented by the configuration η→x.{→y | l} and the replacement graph R is represented by the configuration η→x.{y→' | r}. We assume that →y, y→' are lists of variables, defining a mapping between the points of P and R; the mapping is not necessarily injective since some points of P might be identified in R. Then in the calculus we write a rule:
η→z→x.{I(Y→ ) | l∗,Z(Y→ , →z)}→ ηz→'.{I(Y→ ') | r∗,Z(Y→ ', z→')}
where the metavariables in Y→ ' occur in Y→ , l∗ and r∗ are obtained from l and r by replacing each free variable y by a metavariable Y (this is necessary because rules are pairs of closed metaterms), →x contains the internal nodes of the pattern l, →z contains the internal nodes of the rest of the graph, and z→' contains the internal nodes of r and of the rest of the graph. Note that the condition no dangling links can be easily checked: →x must be different from →z.

Term-Graph Rewriting. Since term-graphs are particular cases of graphs, we could use the previous representation. But we could also give a more direct encod- ing, inspired by the equational encoding of term-graphs (see for instance [15]): A term-graph G = (VG, EG, labG, attG) with root rootG will be represented by a configuration of the form η→x.⟨rootG | t⟩ of sort Conﬁg where t contains an equation x = f (x1,... , xn) for each edge e ∈ EG such that labG(e) = f and attG(e) = x, x1,... , xn, and →x contains all the variables that occur twice in t (i.e. the internal nodes).
Interaction Nets. An interaction net will be represented by a term η→x.⟨s | t⟩ of sort Conﬁg (a configuration for short). To obtain the configuration representing a given net, we proceed as in [8]: A term α(t1,... , tn) of sort Iterm built out of agents in Σ and variables represents a tree, with the free principal port of α at the root and all the principal ports of the agents in t1,... , tn facing in the same direction. To represent active pairs (a connection between two principal ports) we use equations. Therefore, any interaction net can be represented by a list t of equations (a term of sort EqList) and a list s of free variables (the interface of the net). All the other variables, representing internal edges, are bound by η. A configuration η→x.⟨s | t⟩ must satisfy three constraints: every variable occurs twice in ⟨s | t⟩; each variable occurs at most once in the interface; and all the variables that do not occur in the interface are explicitly bound by η.
Note that α-conversion applies to variables bound in configurations, both for nets and graphs. In nets these typically correspond to edges, whereas in hypergraphs they correspond to nodes. Free variables occurring in the interface can be used for structuring programs, as will be shown in Section 5.
Interaction Systems. Laneve [20] defines Interaction Systems as a subclass of CRSs representing intuitionistic interaction nets. The syntax defined above allows us to write the rules of an interaction system directly as rewrite rules.
Non-deterministic Interaction Nets and Process Calculi. Alexiev [1] defined a gen- eralization of Lafont’s nets in which agents can have multiple principal ports. A textual calculus for these nets was defined in [6], in which an agent α of arity n with m principal ports is represented by a term of the form (l1,... , lm)α(t1,... , tn). This can be transformed into a term in our system, for instance by defining a function symbol of arity n + m associated to α. The (finitary) π-calculus can be encoded in Alexiev’s system (using agents with multiple principal ports to simulate the non- deterministic communication between processes [1]) therefore we can give a system of rules defining the interaction and communication between concurrent processes.

Higher-Order Rewriting: Applications
Operational Semantics of Interaction Nets. The operational semantics of a pro- gram in an interaction net system (Σ, R) is given by a set of computation rules on configurations in [8]. The computation rules can be specified in our calculus as higher-order rules:

Interaction: For each interaction rule in R, we will have a rewrite rule in our system. The interaction rule for the agents α and β of arities n and m respectively will be written:
η→x.⟨I | α(T1(→x),... , Tn(→x)) = β(T '(→x),... ,T ' (→x)), Δ(→x)⟩ −→
1	m
η→xx→'.⟨I | T1(→x)= t1,... , Tn(→x)= tn,T '(→x)= s1,... ,T ' (→x)= sm, Δ(→x)⟩
1	m
where t1,... , tn, s1,... , sm encode the right-hand side of the graphical interaction rule for α and β and the bound variables in the vector x→' represent edges in the right-hand side of the (graphical) interaction rule.
Indirection: η→xz.⟨I | z = T (→x), Δ(→x, z)⟩ −→ η→x.⟨I | Δ(→x, T (→x))⟩
The Indirection rule is a “bureaucratic rule” in the sense that it does not corre- spond to any modification of the underlying (graphical) net.
As an example, we give the Interaction rewrite rule δ da ϵ in Fig. 1:
η→x.⟨I | δ(T (→x),T '(→x)) = ϵ, Δ(→x)⟩ −→ η→x.⟨I | T (→x)= ϵ, T '(→x)= ϵ, Δ(→x)⟩
Specifying Strategies. Most functional language evaluators stop at weak head nor- mal form. The corresponding notion for interaction nets is called interface normal form [8]. The idea is to reduce the net until all the free ports are either principal ports, or will never become principal ports. We can specify a lazy reduction strat- egy that computes interface normal forms by modifying the computation rules, so that equations are reduced only if their reduction can affect the terms associated to interface variables. For instance, Interaction will only be applied to active pairs that are directly connected to the interface of the net. This can be easily expressed by rewriting equations that contain a variable occurring in the interface of the config- uration. An interaction is then specified in two steps: the first selects the equation and the second one performs the actual interaction.
η→x.⟨Z, I | E(Z, →x), Δ(→x)⟩ −→ inter([→x](E(Z, →x), ⟨Z, I | Δ(→x)⟩))
inter([→x](α(T1(→x),... , Tn(→x)) = β(T '(→x),... ,T ' (→x)), ⟨Z, I | Δ(→x)⟩)) −→
1	m
η→xx→'.⟨Z, I | T1(→x)= t1,... , Tn(→x)= tn,T '(→x)= s1,... ,T ' (→x)= sm, Δ(→x)⟩
1	m
where Z is a metavariable of sort Iterm to be instantiated by a variable (in the
interface of a configuration) in a rewrite step, and the terms t1,... , tn, s1,... , sm
represent the right hand side of the rule for α da β as before.
Indirection is only performed when the equations involved contain variables oc- curring in the interface. Again this condition can be expressed directly in the higher-order syntax:
η→xz.⟨Y, I | E(z, →x, Y ),z = T (→x), Δ(→x)⟩ −→ η→x.⟨Y, I | E(T (→x), →x, Y ), Δ(→x)⟩
η→xz.⟨Y, I | E(z, →x),z = T (Y, →x), Δ(→x)⟩ −→ η→x.⟨Y, I | E(T (Y, →x), →x), Δ(→x)⟩
Property 5.1 The interaction net conﬁgurations that are irreducible in this system are interface normal forms.
It is therefore easy for language-designers and compiler-writers to define and compare different strategies of evaluation using the calculus. In the case of interac- tion nets all that needs to be done is to change two rewrite rules.

Modularity and Dependence: Combining Nets. The comb function is used for build- ing configurations modularly by composing two smaller configurations.
comb(η→x.⟨Z1,. .., Zn,I | Δ(Z1,.. ., Zn, →x)⟩, ηx→' .⟨Z1, ... , Zn,I' | Δ'(Z1,. .., Zn, x→')⟩)
−→ η→xx→'z1 .. . zn.⟨I, I' | Δ(z1 .. . zn, →x), Δ'(z1 . .. zn, x→')⟩
All the free variables of the same name occurring in the interface of both ar- guments of comb are pairwise connected together. Since these variables disappear from the interface, they must necessarily be bound in the resulting configuration (variables z1,... , zn). Note that in this rule the variable convention is used to avoid name clashes: if the same variable is bound in both arguments of comb, α-conversion is used to change that variable in one of the terms before the rule is applied.
One of the main uses of combine that we foresee is as a programming tool for an interaction net programming language. We give an example of this in Section 6, where we show how we can write names for nets, and combine them together to build larger programs. This very same feature also allows us to express a notion of higher-order nets: nets depending on nets. Additional features, such as rule templates, can be seen as specific instances of this idea. For example the rules for ц dа ϵ and δ dа ϵ shown in Fig. 1 are the same modulo the names of the agents. We can write them in a compact way:
ϵ = X(T1, T2) −→ ϵ = T1,ϵ = T2
Net Transformation: Optimization Rules. In certain contexts (such as Asperti’s safe operators for the optimal reduction of λ-terms [3], or that of garbage-collection of non-terminating or deadlocked nets) interaction net reduction can be greatly improved by admitting rules which fall outside the strict scope of interaction. For example, the following rules involve only two agents and the interface is preserved. The difference with respect to interaction rules is that in a redex an auxiliary port of an agent is connected to the principal port of the other.
Eqδє: δ(ϵ, T ) −→ T and δ(T, ϵ) −→ T
Eqγє: Δ(ц(ϵ, T )) −→ Δ(ϵ),T = ϵ
The first is an optimization rule: when an erasing agent is connected to an auxiliary port of a duplicator we can replace both agents by an edge. The second rule allows to garbage-collect non-terminating nets. Note that since Δ is a metavariable (we need to modify the context where ц(ϵ, t) occurs) this rule is not allowed in CRSs, but it could be replaced by a set of CRS’s rules.
Other Meta-operations: Packing Nets. In different contexts it has been necessary to define global operations on nets. One typical problem is that of copying a net by using a duplicator agent δ. Since active pairs cannot be copied and the δ agent does not duplicate itself (see Fig. 1), some transformation is required to produce a packed net which can be copied (we refer the reader to [19,9] for details). These packing operations can be formally defined using rules in our system. As an example we show the δ-extraction operation used to prove the universality of the interaction combinators in [19]. It removes all occurrences of the δ agent, collects together

in three sequences their n principal ports and their left and right auxiliary ports, and uses three multiplexing nets of arity n to bundle these sequences into three edges, which are added to the interface of the packed net. Unpacking proceeds by connecting a δ agent to these three ports. We define extractδ and extrδ with signature Conﬁg → Conﬁg :
δ-Extraction1 (y is a fresh variable)
extractδ(η→x.⟨I | Δ(δ(T '(→x),T ''(→x)), →x)⟩) −→
extrδ(η→xy.⟨pp(y), a(T '(→x)), b(T ''(→x)),I | Δ(y, →x)⟩)
δ-Extraction2 (y is a fresh variable)
'	''	'	''
extrδ (η→x.⟨pp(Tδ (→x)), a(Tδ (→x)), b(Tδ (→x)),I | Δ(δ(T (→x),T (→x)), →x)⟩) −→
extrδ(η→xy.⟨pp(γ(Tδ (→x), y)), a(γ(T '(→x),T '(→x))), b(γ(T ''(→x),T ''(→x))),I | Δ(y, →x)⟩)
δ	δ
δ-Extraction3
extrδ(η→x.⟨pp(Tδ(→x)), a(T '(→x)), b(T ''(→x)),I | Δ(→x)⟩) −→
δ	δ
η→x.⟨xδ, x' , x'',I | Δ(→x), xδ = Tδ(→x), x' = T '(→x), x'' = T ''(→x)⟩
δ	δ	δ	δ	δ	δ
Rules δ-Extraction1 and δ-Extraction2 extract (step-by-step) occurrences of the δ agent from the list of equations Δ. The first rule builds multiplexing nets of arity one (edges), and the second rule uses ц agents to build bigger multiplexers.
The rule δ-Extraction3 is only used when δ-Extraction2 no longer applies (a strategy would force this). Its role is to remove the extrδ operator and to introduce (free) names in the interface for the multiplexing nets. It is easy to see that the unpacking net consists of a single δ agent:
Property 5.2 Let Nuδ be η⟨xδ, x' , x'' | xδ = δ(x' , x'')⟩. For every interaction net
δ	δ	δ	δ
conﬁguration c, comb(Nuδ, extractδ(c)) −→∗ c.
Proof Nets of Linear Logic. The encodings of proof nets in interaction nets that can be found in the literature are of two kinds: either boxes (which are nets containing nets) are defined by agents which contain a proof net as label, therefore we need an infinite set of agents in the system (see for instance [18]), or a first-order encoding of binders is used to model the box and its contents, and this can be done with a finite number of agents (see for instance [21]). In the first case, the Dereliction Cut Elimination step is performed in one rewrite step, using an infinite rewrite system, whereas in the second case it is performed in several steps using a finite system.
Using a higher-order syntax we can model this Cut Elimination step with a single rule and a finite number of agents. We would write this as:
d(Y )= box(η→x.⟨Z, I | Δ(→x)⟩,I) −→ η→x.⟨Y, I | Δ(→x),Y = Z⟩
where d, box ∈ Σ and d : Iterm → Iterm, box : Conﬁg × TList → Iterm.
Hierarchical Graph Rewriting Systems. We show the representation of a hierarchical graph H = (G, F, cts) in the higher-order system. For this, it is sufficient to add to the alphabet a function symbol f : Conﬁg ×Iterm ×.. .×Iterm → Iterm to represent frames in F . More precisely, frames are represented by terms that have an argument of type Conﬁg carrying a graph. We write configurations as in the case of standard

graphs: each standard edge is represented as shown in Section 4 and each frame f such that cts(f ) = H' is represented by a term f (η→x.{→y | T (→x)}, z1,... , zn) where η→x.{→y | T (→x)} is the configuration associated to H'. For some applications, we may require that the interface of the configuration H' coincide with z1,... , zn (the attachment nodes of the frame).
As an example, we give the specification of the flattening operation that trans- forms a hierarchical graph H into a standard graph flat(H), by gluing ctsH(f ) to attH(f ) for each frame in H (recursively). To simplify the definition we assume that attH(f ) coincides with the interface of ctsH(f ).
flat(η→x.{I | f (η→z.{→x | T (→x, →z)}, →x), Δ(→x)}) −→ flat(η→x→z.{I | T (→x, →z), Δ(→x)})
The rule eliminates one frame at the time, replacing it by its contents, until no more frames remain.


An Example
We show a simple system of interaction, and use the modularity features of the higher-order calculus to simplify the writing of nets. We can encode integers (not uniquely though) by a pair of natural numbers z = (p, q) which we interpret as the difference p − q. This is encoded into interaction nets as shown in Fig. 2 (left). The


,ˆ,
 I J
⎧ ,ˆ,,ˆ,⎫



,ˆ,

⎪    J  J⎪
   J

p ⎪⎨	.	.	⎪⎬ q
ˆ,,ˆ,
,, ,
 vJ vJ

⎪⎩ S J S J⎪⎭
N1	N2



Fig. 2. Encoding integers (left) and addition (right)


agent S (of arity 1) is interpreted as successor. The representation of an integer simply takes two chains of length p and q, and connects them together as shown, using the agent I (of arity 2). Although this representation is not unique, we can talk about canonical forms when p =0 or q = 0. If N1 and N2 are the net representations of z1 = (p1 − q1) and z2 = (p2 − q2) respectively, then we can use the configuration to encode addition shown in Fig. 2 (right). The following are the only rules of this

system, where the agent I∗ is used to implement addition in constant time:

 ,/,
 vJ
,,
 vJ

ˆ	=⇒	ˆ =⇒
,,	,,
/ J	 J
In our calculus, we can write this system in the following way:
I(T1, T2)= I∗(T3, T4) −→ T1 = T4, T2 = T3
S(T1)= S(T2)	−→ T1 = T2
Add(X, Y, Z) −→ ηabc.⟨X, Y, Z | X = I(a, b),Y = I∗(b, c),Z = I∗(c, a)⟩
We can then define numbers as follows:
Two(X) −→ ηa.⟨X | X = I(S(S(a)), a)⟩
and use them to build a program in a modular way:
comb(comb(Add(a, b, c), Two(b)), Two(c)) where a represents the result of the addition.
Conclusions
We have shown a higher-order rewrite framework which can express several systems of graph reduction. The power of the framework can be seen for the particular case of interaction nets, where we can write a program together with its evaluator, all in the same language. We see two main uses of this framework. First, as a tool for the design and implementation of graphical languages: the language, its semantics and metaoperators, can all be defined using the same language. Second, as a tool for adding structure to graphical programs: the higher-order features can be used to write hierarchical systems, and to name and reuse different components of the program.
Some further work that we foresee includes the development of a programming environment for interaction nets. Since interaction nets are also used as an im- plementation language for functional languages, this will allow for fast prototyping of functional compilers, facilitating the definition and comparison of strategies of evaluation and optimization techniques.

References
V. Alexiev. Non-deterministic Interaction Nets. PhD thesis, University of Alberta, 1999.
Z. M. Ariola and J. W. Klop. Equational term graph rewriting. Fundamenta Informaticae, 26(3– 4):207–240, 1996.
A. Asperti and S. Guerrini. The Optimal Implementation of Functional Programming Languages, volume 45 of Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, 1998.

F. Drewes, B. Hoffmann, and D. Plump. Hierarchical graph transformation. Journal of Computer and System Science (to appear), 2002.
H. Ehrig, G. Engels, H.-J. Kreowski, and G. Rozenberg, editors. Handbook of Graph Grammars and Computing by Graph Transformation, Vol. II: Applications, Languages and Tools. World Scientific, Singapore, 1999.
M. Fern´andez and L. Khalil. Interaction nets with McCarthy’s amb. In Proc. Express’02, Electronic Notes in Theoretical Computer Science, 2002.
M. Fern´andez and I. Mackie. Interaction nets and term rewriting systems. Theoretical Computer Science, 190(1):3–39, 1998.
M. Fern´andez and I. Mackie. A calculus for interaction nets. In Proc. Int. Conf. Principles and Practice of Declarative Programming (PPDP’99), volume 1702 of Lecture Notes in Computer Science, pages 170–187. Springer, 1999.
M. Fern´andez and I. Mackie. Packing interaction nets: Applications to linear logic and the lambda calculus. In Proc. WAIT’01, volume 30 of Anales JAIIO, pages 91–107, 2001.
M. Fern´andez, I. Mackie, and J. S. Pinto. Combining interaction nets with externally defined programs. In Electronic proceedings of the APPIA-GULP-PRODE Joint Conference on Declarative Programming, Portugal, 2001.
J.-Y. Girard. Towards a geometry of interaction. In J. W. Gray and A. Scedrov, editors, Categories in Computer Science and Logic, volume 92 of Contemporary Mathematics, pages 69–108. American Mathematical Society, 1989.
B. Hoffmann. From graph transformation to rule-based programming with diagrams. In M. Nagl,
A. Schrr, and M. Mnch, editors, Applications of Graph Transformation with Industrial Relevance (AGTIVE’99) - Selected Papers, pages 165–180. Springer, 2000. Lecture Notes in Computer Science Vol. 1779.
Z. Khasidashvili. Expression reduction systems. In Proceedings of I.Vekua Institute of Applied Mathematics, volume 36, pages 200–220, Tbisili, 1990.
Z. Khasidashvili and V. van Oostrom. Context-sensitive Conditional Reduction Systems. Electronic Notes in Theoretical Computer Science, Volume 2, Proc. SEGRAGRA’95, 1995.
J. Klop. Term graph rewriting. In Higher-Order Algebra, Logic, and Term Rewriting, Second International Workshop, HOA’95, Selected Papers, number 1074 in LNCS, Paderborn, Germany, 1995.
J.-W. Klop. Combinatory Reduction Systems, volume 127 of Mathematical Centre Tracts. Mathematischen Centrum, 413 Kruislaan, Amsterdam, 1980.
Y. Lafont. Interaction nets. In Proc. 17th ACM Symposium on Principles of Programming Languages (POPL’90), pages 95–108. ACM Press, 1990.
Y. Lafont. From proof nets to interaction nets. In Advances in Linear Logic, number 222 in London Mathematical Society Lecture Note Series, pages 225–247. Cambridge University Press, 1995.
Y. Lafont. Interaction combinators. Information and Computation, 137(1):69–101, 1997.
C. Laneve. Optimality and Concurrency in Interaction Systems. PhD thesis, Dipartmento di Informatica, Universit`a degli Studi di Pisa, 1993.
I. Mackie. Interaction nets for linear logic. Theoretical Computer Science, 247(1):83–140, 2000.
R. Mayr and T. Nipkow. Higher-order rewrite systems and their confluence. Theoretical Computer Science, 192:3–29, 1998.
R. Milner. Communication and Concurrency. Prentice Hall, 1989.
D. Plump. Term Graph Rewriting. In Handbook of Graph Grammars and Computing by Graph Transformation, Volume 2: Applications, Languages and Tools, Chapter 1, eds. H. Ehrig, G. Engels, H.-J. Kreowski and G. Rozenberg. World Scientific, 1999.
G. Rozenberg, editor. Handbook of Graph Grammars and Computing by Graph Transformation, Vol. I: Foundations. World Scientific, Singapore, 1997.
V. van Oostrom and F. van Raamsdonk. Comparing combinatory reduction systems and higher-order rewrite systems. In Proc. HOA’93, volume 816 of LNCS, Amsterdam, 1993.
F. van Raamsdonk. Confluence and Normalization for Higher-Order Rewriting. PhD thesis, Vrije Universiteit, Amsterdam, 1996.
