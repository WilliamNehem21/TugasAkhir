Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 331 (2017) 71–85
www.elsevier.com/locate/entcs


Software Watermarking:
A Semantics-based Approach
Mila Dalla Preda1,2,4  Michele Pasqua1,3
Department of Computer Science University of Verona
Strada le Grazie 15, 37134, Verona, ITALY

Abstract
Software watermarking is a defence technique used to prevent software piracy by embedding a signature, i.e., an identifier reliably representing the owner, in the code. When an illegal copy is made, the ownership can be claimed by extracting this identifier. The signature has to be hidden inside the program and it has to be diﬃcult for an attacker to detect, tamper or remove it. In this paper we show how the ability of the attacker to identify the signature can be modelled in the framework of abstract interpretation as a completeness property. We view attackers as abstract interpreters that can precisely observe only the properties for which they are complete. In this setting, hiding a signature in the code corresponds to inserting it in terms of a semantic property that can be retrieved only by attackers that are complete for it. Indeed, any abstract interpreter that is not complete for the property specifying the signature cannot detect, tamper or remove it. The goal of this work is to introduce a formal framework for the modelling, at a semantic level, of software watermarking techniques and their quality features.
Keywords:  Software Watermarking, Abstract Interpretation, Program semantics, Program transformation


Introduction
Software developers are interested in protecting the intellectual property of their products against software piracy, namely to prevent the illegal reuse of their code. Software watermarking is a technique for embedding a signature, i.e., an identifier reliably representing the owner, in a cover program. This allows software developers to prove their ownership by extracting their signature from the pirated copies. In the last two decades researchers have developed a variety of software watermarking techniques (e.g., [3,4]) that can be classified in three main categories according to their extraction process:  static, dynamic and abstract watermarking.  Static

1 We would like to thank Roberto Giacobazzi for the initial discussions on this work and Isabella Mastroeni for the discussions on high-order abstract non-interference.
2 Email: mila.dallapreda@univr.it
3 Email: michele.pasqua@univr.it
4 This work has been supported by the MIUR FIRB 2013 project FACE RBFR13AJFT.

http://dx.doi.org/10.1016/j.entcs.2017.02.005
1571-0661/© 2017 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

watermarking inserts signatures in the cover program either as data or code and then extracts them statically, namely without executing the code [4]. Conversely, dynamic watermarking inserts signatures in the program execution state (i.e., in its semantics) and the extraction process requires the execution of the program, often on a special enabling input [4]. Abstract watermarking, introduced in [10], encodes the signature in such a way that it could be extracted only by a suitable abstract execution of the program. A watermarking scheme is typically evaluated w.r.t. the following features: credibility (how strongly it proves authorship), secrecy (how difficult it is to extract the mark), transparence (how difficult it is to realize that a program is marked), accuracy (observational equivalence of the marked and original program), resilience to attacks (how difficult it is to compromise the correct extraction of the signature) and data-rate (amount of information that can be encoded). The quality of each existing watermarking technique is specified in terms of their features that are typically claimed to hold w.r.t. the peculiar embedding and extraction methods. There exists a variety of embedding and extraction algorithms that often work on different objects (control flow graph, variables, registers, etc.) and this makes it difficult to compare the efficiency of different watermarking systems. It is therefore difficult to formally prove and compare limits and potentialities of the different watermarking systems and to decide which one is better to use in a given scenario.
These problems derive also by the fact that, at the state of the art, there is a poor theoretical investigation about software watermarking. The concept was formally defined in [1] and, in the same work, the authors showed that the existence of indistinguishability obfuscators implies that software watermarking cannot exist. Furthermore the recent candidate construction of an indistinguishability obfuscator
[12] lowers the hope of building meaningful watermarking scheme. Fortunately this impossibility result relies on the fact that the signed program computes the same function as the original program. Indeed, in [1] the authors suggested that if we relax this last constraint, i.e., we require that the watermarking process has only to preserve an “approximation” of original program’s functionality, then positive results may be possible. This naturally leads to reason about software watermarking at semantic level, as we do in the present work.
A first attempt to provide a formal definition, in the semantics setting, of a watermarking system has been proposed in [13]. Here the author introduced the idea that static and dynamic watermarking are instances of abstract watermarking. Intuitively, the latter can be seen like static watermarking because the extraction of the signature requires no execution. But, at the same time, it can be seen like dynamic watermarking because the signature is hidden in the semantics. So all these three types of techniques could be seen as particular instances of a common watermarking scheme based on program semantics and abstract interpretation.
In this work, we start from that intuition and we transform the scheme proposed in [13] in a formal and consistent definition of what a software watermarking system is. The idea is to model the embedding of the secret signature s as the encoding of s in a semantic property M(s) that is then inserted in the semantics of the cover pro- gram. In this setting, the extraction process requires an analysis of the marked code



that has to be at least as precise as M(s). This notion of precision of the extraction corresponds to the notion of completeness of the analysis in abstract interpretation. This means that in order to extract the signature it is necessary to know how it is encoded. In this view the semantic property for which the analysis has to be com- plete in order to extract the signature plays the role of an extraction key. Indeed, the signature is hidden to any observer of the program’s semantics which is not complete for M(s), namely which does not know the “secret key”. Based on these ideas we provide a formal semantics-based definition of a watermarking system. Moreover, we provide a specification of the features of a watermarking system in the semantic framework in terms of semantic program properties (this problem was not addressed at all in [13]). For example, it turns out that a watermarking scheme is transparent
w.r.t. an observer when the embedding process preserves the program properties in which the observer is interested. Moreover, the resilience of a watermarking scheme to collusive attacks, that attempt to remove the signature by comparing different marked programs, can be modelled as a property of abstract non-interference among programs.
Finally we do a more precise validation than the one done in [13] (which is just sketched). We take into account two known watermarking techniques and we define them in our framework. Our investigation and study in this direction has led to the following contributions.
Specification of a formal framework based on program semantics and abstract interpretation for the modelling of software watermarking. The framework refines and extends the one proposed in [13].
Formalization of the features (resilience, secrecy, transparence, accuracy) used to measure the quality of a watermarking system in the framework.
Validation of the framework on two watermarking techniques.


Preliminaries
Mathematical notation
Given two sets S and T , we denote with ℘(S) the powerset of S, with S \ T the set- difference between S and T , with S ⊂ T strict inclusion and with S ⊆ T inclusion. Let S⊥ be set S augmented with the undefined value ⊥, i.e., S⊥ = S ∪ {⊥}. ⟨P, ≤⟩ denotes a poset P with ordering relation ≤, while a complete lattice P , with ordering
≤, least upper bound (lub) ∨, greatest lower bound (glb) ∧, greatest element (top) T, and least element (bottom) ⊥ is denoted by ⟨P, ≤, ∨, ∧, T, ⊥⟩. ± denotes the pointwise ordering between functions. If f : S −→ T and g : T −→ Q then g ◦ f : S −→ Q denotes the composition of f and g, i.e., g ◦ f = λx.g(f (x)).
: P −→c	Q on posets is (Scott)-continuous when f preserves lub of countable
chains in P . f : C −→ D on complete lattices is additive [co-additive] when, for any Y ⊆ C, f (∨CY ) = ∨Df (Y ) [f (∧CY ) = ∧Df (Y )]. The right [left] adjoint of a function f is f + d=ef λx. W{y | f (y) ≤ x} [f− d=ef λx. V{y | x ≤ f (y)}].

Abstract Interpretation
Abstract interpretation is based on the idea that the behaviour of a program at different levels of abstraction is an approximation of its (concrete) semantics [7,8]. The concrete program semantics is computed on the concrete domain ⟨C, ≤C⟩, while approximation is encoded by an abstract domain ⟨A, ≤A⟩. In abstract interpretation abstraction is specified as a Galois connection (GC) (C, α, γ, A), namely as an ab- straction map α : C −→ A and a concretization map γ : A −→ C that are monotone and that form an adjunction: ∀y ∈ A, x ∈ C : α(x) ≤A y ⇔ x ≤C γ(y) [7,8]. α [resp. γ] is the left[right]-adjoint of γ [α] and it is additive [co-additive], i.e. it preserves the lub [glb] of all the subsets of the domain (empty set included). Abstract domains can be equivalently formalized as upper closure operators on the concrete domain [8]. An upper closure operator, or closure, on a poset ⟨C, ≤⟩ is an operator ϕ : C −→ C that is monotone, idempotent and extensive (i.e. ∀c ∈ C : c ≤ ϕ(c)). Closures are uniquely determined by the set of their fixpoints ϕ(C). The set of all closures on C is denoted by uco(C). The lattice of abstract domains of C is therefore isomorphic to uco(C) [7,8]. If C is a complete lattice, then ⟨uco(C), ±, ⊆, H, λx.T, id⟩ is a complete
lattice, where id d=ef λx.x and for every ρ, η ∈ uco(C), ρ ± η iff ∀y ∈ C : ρ(y) ≤ η(y)
iff η(C) ⊆ ρ(C).
Precision of an abstract interpretation is typically defined in terms of complete- ness. Depending on where we compare the concrete and the abstract computa- tions we obtain two different notions of completeness [15]. If we compare the re- sults in the abstract domain, we obtain what is called backward completeness (B- completeness) while, if we compare the results in the concrete domain, we obtain the so called forward completeness (F-completeness). Formally, if f : C −→ C and ρ, η ∈ uco(C), then ⟨ρ, η⟩ is a pair of B[F]-complete abstractions for f if ρ◦f = ρ◦f◦η [f ◦ η = ρ ◦ f ◦ η] (equivalently, we say that f is B[F]-complete for ⟨ρ, η⟩). The least fixpoint (lfp) of an operator F on a poset ⟨P, ≤⟩, when it exists, is denoted by lfp≤F , or by lfpF when ≤ is clear. Any continuous operator F : C −→ C on a complete
lattice ⟨C, ≤, ∨, ∧, T, ⊥⟩ admits a least fixpoint: lfp≤F = n∈N F i(⊥), where for any i ∈ N and x ∈ C: F 0(x)= x; F i+1(x)= F (F i(x)).

Semantics of programs
We consider an imperative programming language Imp, similar to the one described in [9], equipped with a command input X that receives an input value from the user. The input stream given to the program is modelled as a sequence of values. At the beginning this sequence contains all the input values given, in order, to the program from its first element to its last. Each statement input “consumes” the first element of the sequence and so when the sequence is empty there are no more values that can be passed to the program. The small-step operational semantics of Imp induces a transition system ⟨Σ, S⟩, where Σ is the set of possible program states. A program state is a pair ⟨C, ζ⟩ where C is the command that has to be executed in the context ζ = ⟨ρ, ι⟩ that specifies both the assignment of values to variables ρ and the input stream ι that still needs to be consumed. As usual, the transition relation

S ∈ Σ −→ ℘(Σ) over program states specifies the set of states that are reachable from a given state. Let us denote with ΣP the set of states of a program P , and with SP : ΣP −→ ℘(ΣP ) the transition relation over states of P . As usual Σ+ denotes the set of all possible finite non-empty sequences of states and ϵ the empty sequence. Given a sequence of states σ = ς0 ... ςn—1 ∈ Σ+, let |σ| = n ∈ N denote its length and σi its i-th element. A trace σ ∈ Σ+ is a sequence of states ς0 ... ςn—1 such that:
∀i ∈ [1, n) . ςi ∈ S(ςi—1).
A state ς is a blocking state, for the program P , when SP (ς) = ∅. Let ΣT be
the set of blocking states of P . A maximal finite trace of P , is a finite trace of P where the last state is blocking. The maximal finite traces semantics P + of the program P is given by the union of all maximal finite traces of length n > 0 and can be expressed as the least fixpoint of the transfer function F+ ∈ ℘(Σ+) −m→ ℘(Σ+)

defined as: F+ d=ef
λS . ΣT
∪ {ςςjσ | ςj ∈ SP (ς) ∧ ςjσ ∈ S}.  We can define the

def
maximal input semantics function QP ¢+= λX.{σ ∈ QP ¢ | σ0 ∈ X} that returns the
set of maximal traces with initial state in X. It is possible to compute QP ¢+(X)
as λX.lfp≤F X, where the fixpoint of function F X : ℘(Σ+) −→c	℘(Σ+), defined on
∅  +	+
the DCPO ⟨℘(Σ+), ≤, ≤, ∅⟩, is the maximal finite traces semantics starting from
X. The partial order ≤ ⊆ ℘(Σ+) × ℘(Σ+) is defined as: X ≤ Y ⇔ (∀σ ∈ X ∃σj ∈ Y . σ ∈ pref(σj)) ∧ ((∀σj ∈ Y ∃σ ∈ X. σ ∈ pref(σj)) ⇒ Y ⊆ X). Here pref : Σ+ −→ ℘(Σ+) is a function that returns the set of prefix of a given trace, so
pref(σ) d=ef {σj ∈ Σ+ ∪ {ϵ} | ∃σjj ∈ Σ+ .σ = σjσjj}. The least upper bound  is
bottom element is ∅ ∈ ℘(Σ+). Finally F X d=ef λS . {ς ∈ ΣP | ς ∈ X}≤ {σςjς | ς ∈
SP (ςj) ∧ σςj ∈ S}. We have: lfp≤F X =	F Xn(∅)= {σ ∈ QP ¢	| σ0 ∈ X}.
Semantics can be abstracted by computing the least fixpoint of the best correct approximation (bca) of the corresponding transfer function on the desired abstract domain. Given the concrete domain ⟨℘(Σ+), ⊆, ∪, ∩, Σ+, ∅⟩, the bca of QP ¢+ in

ρ ∈ uco(℘(Σ+)) is QP ¢ρ
domain, the bca of QP ¢
d=ef lfp⊆ρ ◦ F+ ◦ ρ. Let ⟨℘(Σ+), ≤, ≤, ∅⟩ be the concrete in ρ is: QP ¢ρ d=ef λS . lfp≤ρ ◦ F S ◦ ρ.


Abstract non-interference
Abstract non-interference (ANI) [14] is a natural weakening of non-interference by abstract interpretation. In order to model non-interference in code transforma- tions, such as software watermarking, we consider an higher-order version of ANI (HOANI), where the objects of observations are programs instead of values. Hence, we have a part of a program (semantics) that can change and that is secret, and the environment which remains the same up to an observable property. Let P be the set of cover programs, Q the set of secret programs and I : Imp × Imp −→ Imp an integration function. As usual, the attacker is modelled as a couple ⟨η, ρ⟩, with η, ρ ∈ uco(℘(Σ+)), that represents the input and output public observation power. In contrast, φ ∈ uco(℘(Σ+)) is the property of the secret input. We say that the integration I, given η, φ, ρ ∈ uco(℘(Σ+)), satisfies HOANI w.r.t. ⟨η, φ, ρ⟩ and ⟨P, Q⟩,
denoted as H[η]I(φ ⇒ ρ)bca, if ∀P1, P2 ∈ P ∀Q1, Q2 ∈ Q: QP1¢η = QP2¢η ∧ QQ1¢φ =

φ	ρ	ρ
Q2 + ⇒ I(P1, Q1) + = I(P2, Q2) +. This means that the integration function permits to the attacker to distinguish nothing more than the property φ of the se-
cret programs. As done in [14] for ANI, we provide a characterization of the most concrete attacker for which a program is safe. Consider η, φ, ρ ∈ uco(℘(Σ+)) and an integration function I, such that H[η]I(φ ⇒ ρ)bca does not hold. We define the higher-order abstract secret kernel as the most concrete ρˆ more abstract than ρ such
that H[η]I(φ ⇒ ρˆ)bca holds, namely KH+	d=ef λρ . .{β | ρ ± β ∧ H[η]I(φ ⇒ β)bca}.
+	I,η,(φ)	+

Semantics-based Software Watermarking
We follow the nomenclature introduced in [10] for describing the basic components of a watermarking technique for programs written in Imp and signatures s ∈ S.
Stegomarker M : S −→ Imp, a function that generates a program which is the encoding of a given signature s ∈ S, i.e., it generates the stegomark M(s) ∈ Imp
Stegoembedder L : Imp × Imp −→ Imp, a function that generates a program which is the composition of a stegomark and a cover program, the stegoprogram L(P, M(s)) ∈ Imp.
Stegoextractor F : Imp −→ S, a function that extracts the signature from a stegoprogram; for all s ∈S it must be s = F(L(P, M(s))).
When L and M are clear from the context we denote the stegoprogram L(P, M(s)) as Ps. The stegoextractor takes a stegoprogram, analyses it either statically or dynamically or by abstract interpretation and then it returns the signature encoded in the stegomark. It is well known [8] that static analysis can be modelled in the context of abstract interpretation, where a property is extensionally represented as a closure operator representing the abstract domain of data satisfying it. In particular, static analysis is performed as an abstract execution of programs, namely as the (fixpoint) semantics computation on the abstract domain. Instead, dynamic analysis can be modelled as an approximated observation of a potentially abstract execution since it describes partial knowledge of the execution (only on certain inputs). This means that, in all cases, the encoded signature can be seen as a property of the stegomark’s semantics and therefore of the stegoprogram’s semantics. In this view a stegoextractor is an abstract interpreter that executes the stegoprogram in the abstract domain β ∈ uco(℘(Σ+)) that allows it to observe the hidden signature. In order to deal with dynamic watermarking we need to model the enabling input that allows to extract the signature. Since in our model the residual input stream is part of the program state, the enabling input can be modelled as a state property η ∈ uco(℘(Σ)). We consider a set P ⊆ Imp of cover programs and we specify a watermarking system as a tuple ⟨L, M, β⟩.

Definition 3.1 [Software Watermarking System] Given L : Imp × Imp −→ Imp, M : S −→ Imp and β ∈ uco(℘(Σ+)), the tuple ⟨L, M, β⟩ is a software watermarking system for programs in P and signatures in S if M is injective and there exists

η ∈ uco(℘(Σ)) such that ∀P ∈P ∀s ∈ S:


QL(P, M(s))¢+= λX .
β
+
QP ¢+(X)	otherwise

X ∈ η(℘(Σ)) ⇒ QM(s)¢β (X)= QM(s)¢β

This means that when computing the semantics in the abstract domain β, the stegoprogram L(P, M(s)) behaves like the stegomark M(s) on the enabling inputs,
and like the cover program P otherwise. Here QM(s)¢β is precisely the information
representing the watermark at semantic level, namely the property of the stegomark where the signature is hidden. It is clear that, in this setting, it is possible to reduce the precise extraction of the signature to a completeness problem. To this end we
associate the stegomarker M with its semantic counterpart M : S −→ uco(℘(Σ+)),
which encodes a signature in a semantic program property. In particular, given the watermarking system ⟨L, M, β⟩ we define M d=ef λs.{∅, M(s) β , Σ+} 5 . Indeed, M(s) provides a semantic representation of the signature s. Observe that, by con- struction, we have that ∀s ∈S .β ± M(s) and this ensures that β is precise enough
for extracting the signature.
Moreover, the abstract semantics computed on β of the stegoprogram reveals the
watermark information QM(s)¢β ∈ M(s) under the enabling input X ∈ η only if it
is F-complete for η and M(s). This means that the stegoembedder makes programs
in a way that the stegoextractor has a full comprehension of their semantics and so it is able to extract the property which represents the signature.
If QPs¢β is F-complete then QPs¢β ◦η = M(s) ◦ QPs¢β ◦η holds. When the input
X belongs to η, we have that QPs¢β (X) = M(s) ◦ QPs¢β (X) and consequently we
have that QPs¢β (X) ∈ M(s). This means that QPs¢β (X) is an element of M(s) and,
excluding the non interesting case where X = ∅ or X = Σ, it is precisely M(s) β , so it represents the signature s. If X does not belong to η, the system should
guarantee that the abstraction of the stegoprogram doesn’t reveal the signature, so we have to chose β in a way that M(s)(  P  β (X)) = Σ+ minimizes false positive. Note that if the abstract semantics of the stegoprogram is complete, it may well happen that the concrete semantics of the stegoprogram is not complete, i.e., QPs¢+ is not F-complete for η and M(s). This means that the knowledge of the stegomark may not be sufficient in order to extract the signature without knowing the semantic property used to embed it.
The different kinds of software watermarking techniques can be seen as instances of Definition 3.1.
Static and abstract watermarking correspond to a system where η = id and β is decidable (i.e., implementable with static analysis). This captures the fact that the interpretation of the stegoprogram always reveals the stegomark, independently from the input.

5 This is the atomic closure of QM(s)¢β .

Dynamic watermarking corresponds to a system where η /= id and β is a generic (concrete) interpreter. In this case the concrete semantics of the stegoprogram reveals the stegomark only when a particular input sequence is given.
Now we provide a semantic formalization of the features typically used to measure the quality of a watermarking system. Of course there are features strictly related to implementation, like data-rate [5] or credibility, for which we do not provide a characterization.

Resilience
Resilience concerns the capacity of a software watermarking system to be immune to attacks. There exist four types of attacks [4]: distortive attacks, that change the stegoprogram in order to compromise the extraction of the stegomark; collusive attacks, that compare different stegoprograms of the same cover program in order to obtain information on the stegomark; subtractive attacks, that try to eliminate the stegomark from the stegoprogram; additive attacks, that add another stegomark into the stegoprogram. Observe that subtractive attacks and collusive attacks are related to the localization of the stegomark and the resilience to these attacks reduces to problems of secrecy (explained below). In fact, following [4], we denote as subtractive only the attacks which locate, in some way, the stegomark. Those which perform a subtractive attack without knowing anything about the embedded watermark by creating a functionally equivalent program without the signature, in our work are considered as distortive attacks (they can be seen as distortive attacks which preserve the denotational semantics). Resilience to additive attacks is very difficult to obtain; in fact, if an attacker adds another signature (with another technique) it is practically impossible to prove which stegomark was inserted first. For this reason in the following we focus on the resilience to distortive attacks.
A distortive attack can be seen as a program transformer t : Imp —→ Imp that modifies programs preserving their functionality. So there will be program properties that the attacker preserves and others that it does not preserve. According to [11] we denote with δt ∈ uco(℘(Σ+)) the most concrete property preserved by transformation t on program semantics,  namely such that 6P ∈ Imp . δ ( P  ) = 
δt( t(P ) +). Observe that when δt ± .{M(s) | s ∈ £} it means that the attacker
preserves the semantic encoding of all the signatures and therefore the watermarking system is resilient against t. Otherwise, it could be that t preserves M(s) for only certain signatures, in particular for those which δt ± M(s). So we can characterize
which stegoprograms are immune to t and which are not. In the worst case, when 6s ∈ £ . δt /± M(s), the software watermarking system is not able to fend off the attacker t. This leads to the definition of the following levels of resilience.
Definition 3.2 [t-resilience] A software watermarking system ⟨L, M, β⟩ is:
t-resilient, when δt ± .{M(s) | s ∈ £}

t-vulnerable, when Es ∈£ . δt /± M(s)
t-ineffective, when 6s ∈£ . δt /± M(s)

Often distortive attacks use code obfuscation for modifying programs while pre- serving their functionality, and obfuscating transformations typically preserve the denotational semantics of programs, DenSem ∈ uco(℘(Σ+)) 6 . For this reason we say that a watermarking system is resilient when it is t-resilient to all those distortive
attacks t that preserve DenSem, i.e., when DenSem ± .{M(s) | s ∈ £}. A software
watermarking system which exhibits such behaviour has not yet been found and it is an open research topic to demonstrate its existence or not 7 .
This formalization of resilience allows us to compare two watermarking systems
w.r.t. resilience. Given two software watermarking systems A1 = ⟨L1, M1, β1⟩ and
A2 = ⟨L2, M2, β2⟩, if  it holds that .{M1(s) | s ∈ £}± .{M2(s) | s ∈ £} then we
have that {t | δt ± {M1(s) | s ∈ £}} is contained in {t | δt ± {M2(s) | s ∈ £}}. Therefore A2 is, in general, more resilient than A1.
Secrecy
Secrecy concerns the difficulty of recovering the stegomark embedded in a stegopro- gram. A watermarking system is secret when it is impossible to extract the signature from a stegoprogram without knowing the stegoextractor. In practice, secrecy can be seen as the ability of the watermarking system to make indistinguishable to the attacker a set of signatures embedded in a program. This clearly relates to the re- silience to collusive attacks, which requires that an attacker is not able to distinguish between stegoprograms that embed different signatures in the same cover program. This notion can be formalized in terms of HOANI where the private input is the set of possible stegomarks Q = {M(s) | s ∈ £}, while the public input is the set of cover programs P = P. Let φ ∈ uco(℘(Σ+)) be a property that represents some stegomarks, and indeed some signatures. We assume that the attacker doesn’t have access to cover programs, so the abstraction of the public input is id.
Definition 3.3 [φ-secrecy] A software watermarking system ⟨L, M, β⟩ is φ-secret
w.r.t. an attacker ρ if H[id]L(φ ⇒ ρ)bca holds, i.e., if 6P ∈ P 6Q1, Q2 ∈ Q we have
that: QQ1¢φ = QQ2¢φ ⇒ QL(P, Q1)¢ρ = QL(P, Q2)¢ρ .
This means that if we mark a cover program with two different signatures that are equivalent in φ, then the attacker ρ does not distinguish between the two generated stegoprograms. Thus, any signature with the same property φ can be used for generating stegoprograms resilient to collusive attacks from the attacker ρ. We say that a system is secret when it is T-secret, meaning that the set of indistinguishable signatures is £. Given a property φ, specifying a set of signa- tures, we can characterize the most concrete observer ρˆ for which H[id]L(φ ⇒ ρˆ)bca holds, called most powerful φ-secret attacker. It can be characterized in terms of the secret kernel of higher-order abstract non-interference. Indeed it corresponds to the most concrete domain ρˆ more abstract than id such that H[id]L(T⇒ ρˆ)bca

6 This domain can be obtained from maximal finite traces semantics with the abstraction DenSem(X) = 
{σ ∈ Σ+ | ∃σ′ ∈ X . σ0 = σ′ ∧ σ|σ|−1 = σ′	}.
0	|σ|−1
7 The results in [1] and recently in [12] about impossibility of watermarking seem to lead to a negative answer.

holds, i.e., ρˆ = KH+	(id). For example, the most powerful T-secret attacker is

H+
L,id,(T)
(id)= {X ∈ ℘(Σ+) | P ∈ P,X =  Q∈QQL(P, Q)¢+}∪{Σ+} and it abstracts

in the same object the traces of all possible stegoprograms related to the same cover program. Of course, any attacker with at least the same precision of the extractor β violates the secrecy property. Thus, the secrecy level of a watermarking system
is given by the most abstract property φ and by the most concrete observer ρˆ for which non-interference H[id]L(φ ⇒ ρˆ)bca holds. The more φ is abstract, the more the system is secret. Vice versa, more ρˆ is concrete and more the system is secret. Observe that φ can range from id (all the signatures are distinguishable) to T (no signature is distinguishable). When the most powerful φ-secret attacker ρˆ is equal
to T then every attacker is able to distinguish the signatures. Otherwise, the more
ρˆ is concrete, the more secret the system is.
This formalization of secrecy allows us to compare two watermarking sys- tems w.r.t. secrecy.  Given two watermarking systems A1 = ⟨L1, M1, β1⟩ and A2 = ⟨L2, M2, β2⟩ we consider their most powerful φ-secret attackers ρˆ1 and ρˆ2.
If ρˆ1 ± ρˆ2 we have that A1 is more secret than A2 w.r.t. φ. Indeed a stronger
attacker is necessary in order to violate φ-secrecy in A1 than in A2.

Transparence
Transparence concerns the ability to make hard to discover if a generic program is a stegoprogram. A watermarking system is invisible w.r.t. an observer if the latter is not able to distinguish a generic cover program from every stegoprogram generated starting from it.
Definition 3.4 [Transparence] A software watermarking system ⟨L, M, β⟩ is trans-
parent w.r.t. an attacker ρ ∈ uco(℘(Σ+)) if 6P ∈P 6s ∈£ . QP ¢ρ = QL(P, M(s))¢ρ .
The greatest is the set of observers for which the system is transparent, the greatest is the level of transparence. So the characterization of the most concrete observer ρ˜ for which the system is invisible is a good measure of the transparence of the software watermarking system. This observer ρ˜ is called most powerful transpar- ent attacker. This attacker can be characterized with a slightly differentiation of the most powerful T-secret attacker. In fact a system, in order to be invisible w.r.t. an attacker has clearly to be also T-secret w.r.t. that attacker. Clearly the system is not invisible for the extractor β.
Similarly to what we have done for secrecy, given two software watermarking systems A1 and A2, if ρ˜1 ± ρ˜2 we have that A1 is more transparent than A2.

Accuracy
A watermarking system is accurate if it preserves the functionality of the cover program, i.e., the cover program and the stegoprogram have to exhibit the same observable behaviour. This concept can be defined as “behaviour as experienced by the user” [5]. Precisely, the stegoprogram can do something that the cover program doesn’t do, but this side-eﬀects must be not visible to the user. Clearly this definition

is very loose and it depends on what the user is able to observe of program execution. We formalize this by requiring that the stegoprogram and the original program have the same observable denotational semantics. This means that, fixed what the user wants to (or is able to) observe, the stegoprogram and the cover program must exhibit the same input/output behaviour, w.r.t. the fixed observation level.
Definition 3.5 [Accuracy] Given a poset ⟨DO, ≤O⟩ and an observational abstrac- tion αO : ℘(Σ) —→ DO such that (⟨℘(Σ), ⊆⟩, αO, α+, ⟨DO, ≤O⟩) is a GC, we have that a watermarking system ⟨L, M, β⟩ is accurate, w.r.t. αO, if for each program P ∈ P and for each signature s ∈ £ it holds that αO(QL(P, M(s))¢DenSem) = αO (QP ¢DenSem). 8
So the accuracy says that, for a fixed observational abstraction αO, every cover program P is αO-observationally equivalent (in the sense of [9]) to any stegoprogram Ps embedding a generic signature s.
As regarding accuracy, this is a property that is not directly comparable among different watermarking techniques since it is defined w.r.t. the observational abstrac- tion of interest. Namely, we can say that a system is accurate and another system is not accurate, w.r.t. an observational abstraction, but we cannot say that a system is more accurate than another. However, the proposed formal framework provides the right setting for formally proving the accuracy of a watermarking system w.r.t. a specific observational property.

Model Validation
In order to validate our model we have formalized two known watermarking tech- niques, one dynamic and one static, in our framework (the case of abstract water- marking is immediate). Doing so we want emphasise our main claim, i.e., that static and dynamic watermarking are instances of abstract watermarking.

Path-based watermarking
One dynamic technique, conceived by Collberg et al.[2], that encodes the signature (a natural number) in the sequence of choices (true/false) made at conditional state- ments during a particular execution of the program. This execution is generated by a particular sequence of enabling input values. The embedder takes the program code and it adds bogus branches in order to generate the desired false/true sequence when executed on the enabling input.
Let I0, I1,... Ik be the enabling input, i.e., the sequence of input values which
“activates” the watermark. The embedder takes the program and it adds bogus branches in a way that the sequence of choices at conditional statements during the execution on the enabling input is equal to the binary encoding of the signature.

8 Here QP ¢DenSem is the angelic denotational semantics of [6].  Note that QP ¢DenSem is isomorphic to
DenSem(QP ¢+), so both formulations indicate the denotational semantics of P .

Let Bin : N —→ {0, 1}٨ be a function that returns the binary encoding of a number and Branch : Σ+ —→ {0, 1}٨ be a function that extracts the sequence of choices at conditional statements in a trace. For example, for a tt guard it can be assigned the value 1 and it can be assigned the value 0 for a ff guard.  Let E : N —→ ℘(Σ+) be the function E d=ef λk . {σ ∈ Σ+ | |σ| = n +1 ∧ Branch(σ) = 
Bin(k) ∧ σn = ⟨C, ⟨ρ, ι⟩⟩ ∧ top(ι) = ϵ} 9 . The semantics QP ¢β has to extract the
sequence of choices at conditional statements for the program P , so the domain β is β d=ef {X ∈ ℘(Σ+) | k ∈ N,X = E (k)}∪ {∅, Σ+} and it contains all the sets of traces which have done the same choices, when all the input values are consumed. With Ws = E (s) we indicate the set of traces for which, when all the input values are
consumed, the sequence of choices at conditional statements codify the signature s. This is a dynamic technique, so η = ℘(I) ∪ {Σ}, where I represents the set of states enabling the watermark, i.e., I d=ef {ς ∈ Σ | ς = ⟨C, ⟨ρ, ι⟩⟩ ∧ |ι| = |I|∧ 6j ∈
[0, |I|) . top(next(ι)j) = Ij}. Clearly QM(s)¢β = Ws and so M(s)= {∅, Ws, Σ+}.
Let N d=ef {⊥, N}∪N. The domain β can be defined as β d=ef βγ◦βα where βα : ℘(Σ+) —→
N and βγ : N —→ ℘(Σ+) are





def
βα = λX .
⎧⊥	if X = ∅
⎨k ∈ N  if ∀σ ∈ X :

|σ| = n + 1, σn


= ⟨C, ⟨ρ, ι⟩⟩,




def
βγ = λk .

⎧∅	if k = ⊥
E (k)  if k ∈ N

⎪⎪⎩

N	otherwise
top(ι)= G, Branch(σ)= Bin(k)
⎪⎩Σ+	otherwise

If X ∈ η(℘(Σ)) then X ⊆ I, therefore the choices at conditional statements made by L(P, M(s)) starting from states in X are equal to Bin(s), i.e., L(P, M(s))β (X)= Ws. The same reasoning can be done for M(s), because it codifies the signature by
design (starting from the sets of input states which encode the enabling input) and therefore QM(s)¢β (X)= Ws for every X ∈ η(℘(Σ)).
If X ∈/ η(℘(Σ)) then X /⊆ I and therefore the choices at conditional state-
ments made by L(P, M(s)) starting from states in X are not equal to Bin(s). So,
when the set of initial states X encodes the enabling input, we have that both
β	β
L(P, M(s))+(X) and M(s)+(X) are equal to Ws, which represents the signa- ture s. We can also note that, as expected, for every signature s, we have that L(P, M(s))+ is F-complete for η and M(s). The system is not resilient since it is not immune to distortive attacks that preserve the denotational semantics, i.e.,
DenSem /± .{M(s) | s ∈ £}. Indeed the system is vulnerable to control flow obfus-
cation techniques (like edge-flipping and opaque predicate insertion attacks).
Static graph-based watermarking
One static technique, conceived by Venkatesan et al.[16], that codifies the signature (a natural number) as a graph which is added to the CFG (Control Flow Graph) of the cover program while preserving its semantics. In particular, a program whose CFG is equal to the graph generated starting from the signature is derived and then

9 top(ι) returns the current input value to be passed to the program and next(ι) returns the tail of the input sequence ι.

added to the cover program’s CFG, in a way that its semantics remains unmodified. The nodes of the added graph are marked before the embedding, in order to be identifiable at extraction time.
The embedder takes the program and it adds bogus code in a way that the CFG of the transformed program contains a graph which is the encoding of the signature. The basic blocks that form this graph are marked, in order to be distinguishable from the basic blocks of the original program.
Let E : N —→ G be a function that codify a signature in a graph. Let Mark :
Σ+ —→ G be a function that, given a trace σ, outputs the marked subgraph of the
CFG of σ for a certain marking criterion 10 . The semantics P β extracts the marked subgraph of the CFG of P , so the extraction domain β is β d=ef {X ∈ ℘(Σ+) | Eg ∈
G .X = {σ ∈ Σ+ | Mark(σ) = g}} ∪ {∅, Σ+}. In β there are all the sets of traces whose CFG contains the same marked graph. With Ws d=ef {σ ∈ Σ+ | E (s)= Mark(σ)}
we indicate the set of traces whose CFG contains the marked graph which codify
the signature s. This is a static technique so η = id. Clearly QM(s)¢β = Ws and
so M(s) = {∅, Ws, Σ+}. Let G d=ef {⊥, G}∪ G. The domain β can be defined as
β d=ef βγ ◦ βα where βα : ℘(Σ+) —→ G and βγ : G —→ ℘(Σ+) are




def
βα = λX .
⎧⊥  if X = ∅
if ∀σ ∈ X. g = Mark(σ)
⎪⎩G  otherwise



def
βγ = λg .
⎧∅	if g = ⊥
{σ ∈ Σ+ | g = Mark(σ)}  if g ∈ G
⎪⎩Σ+	otherwise

The input domain is id so there is not an enabling input, or equivalently, all the inputs reveal the watermark. Thus, for every possible set of initial states, the CFG of L(P, M(s)) is the same, i.e., it exists g ∈ G such that 6σ ∈ L(P, M(s)) + we have
g = CFG(σ). For how the technique is designed, into g there is a marked subgraph
equal to E (s). So we have that L(P, M(s))β (X) = Ws for every possible set of initial states. Now, the CFG of M(s) is exactly E (s) and it is marked by design, so QM(s)¢β (X) = Ws for every possible set of initial states. So, for every set of initial states X, we have that both QL(P, M(s))¢β (X) and QM(s)¢β (X) are equal to
Ws, which represents the signature s. We can also note that, as expected, for every
signature s, QL(P, M(s))¢β is F-complete for η and M(s).
The system is not resilient, since it is not immune to distortive attacks that preserve the denotational semantics, i.e., DenSem /± .{M(s) | s ∈ £}. Indeed the
system is vulnerable to control flow obfuscation techniques (like a CFG flattening attack).

Conclusion
In this paper we introduce a semantics-based definition of software watermarking and of its qualifying features that is general enough to allow the specification of the static, abstract and dynamic watermarking techniques. Indeed, all these techniques can be seen as the exploitation of a completeness hole for the insertion of the signature in

10 Building the CFG and locating its marked nodes are both tasks easily implementable by analysing program traces.

an efficient way. Only attacks that are complete w.r.t. the semantic encoding of the signature are able to observe the signature and potentially tamper with it. This means that the abstract domain used for the semantic encoding of the signature M(s) acts like a secret key that allows to disclose the signature to attackers that are complete w.r.t. M(s).
Regarding the quality of a watermarking scheme our general framework provides a formal setting in which to prove the efficiency of a watermarking scheme w.r.t. re- silience, secrecy, transparence and accuracy. To validate our theory we have proved the efficiency of two known watermarking systems. Thus, we provide a general the- ory where researchers can reach a formal evidence of the quality of the watermarking system that they propose. We believe that this is an important contribution that can be considered as the first step towards a formal theory for software watermarking where new and existing techniques can be certified w.r.t. their efficiency.

References
B. Barak, O. Goldreich, R. Impagliazzo, S. Rudich, A. Sahai, S. P. Vadhan, and K. Yang. On the (im)possibility of obfuscating programs. In CRYPTO ’01: Proceedings of the 21st Annual International Cryptology Conference on Advances in Cryptology, pages 1–18. Springer-Verlag, 2001.
C. Collberg, E. Carter, S. Debray, A. Huntwork, J. Kececioglu, C. Linn, and M. Stepp. Dynamic path-based software watermarking. SIGPLAN Not., 39(6):107–118, 2004.
C. Collberg and C. Thomborson. Watermarking, tamper-proofing, and obduscation-tools for software protection. IEEE Trans. Software Eng., pages 735–746, 2002.
C. Collberg and C. D. Thomborson. Software watermarking: models and dynamic embeddings. In POPL ’99: Proceedings of the 26th ACM SIGPLAN-SIGACT symposium on Principles of programming languages, pages 311–324. ACM, 1999.
C. Collberg, C. D. Thomborson, and D. Low. A taxionomy of obfuscating transformations. Technical Report 148, Department of Computer Science, The University of Auckland, 1997.
P. Cousot. Constructive design of a hierarchy of semantics of a transition system by abstract interpretation. Theor. Comput. Sci., 277(1-2):47–103, 2002.
P. Cousot and R. Cousot. Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. In Conference Record of the 4th ACM Symposium on Principles of Programming Languages (POPL ’77 ), pages 238–252. ACM Press, 1977.
P. Cousot and R. Cousot. Systematic design of program analysis frameworks. In Conference Record of the 6th ACM Symposium on Principles of Programming Languages (POPL ’79 ), pages 269–282. ACM Press, 1979.
P. Cousot and R. Cousot. Systematic design of program transformation frameworks by abstract interpretation. In Conference Record of the Twentyninth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 178–190. ACM Press, 2002.
P. Cousot and R. Cousot. An abstract interpretation-based framework for software watermarking. In Conference Record of the Thirtyﬁrst Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 173–185. ACM Press, New York, NY, 2004.
M. Dalla Preda and R. Giacobazzi. Semantic-based code obfuscation by abstract interpretation.
Journal of Computer Security, 17(6):855–908, 2009.
Sanjam Garg, Craig Gentry, Shai Halevi, Mariana Raykova, Amit Sahai, and Brent Waters. Candidate indistinguishability obfuscation and functional encryption for all circuits. IACR Cryptology ePrint Archive, 2013.
R. Giacobazzi. Hiding information in completeness holes - new perspectives in code obfuscation and watermarking. In Proc. of The 6th IEEE International Conferences on Software Engineering and Formal Methods (SEFM’08), pages 7–20. IEEE Press., 2008.


R. Giacobazzi and I. Mastroeni. Abstract non-interference: Parameterizing non-interference by abstract interpretation. In Proc. of the 31st Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages (POPL ’04), pages 186–197. ACM-Press, 2004.
R. Giacobazzi, F. Ranzato, and F. Scozzari. Making abstract interpretation complete. Journal of the ACM, March 2000.
Ramarathnam Venkatesan, Vijay Vazirani, and Saurabh Sinha. A graph theoretic approach to software watermarking. In Ira Moskowitz, editor, Information Hiding, volume 2137 of Lecture Notes in Computer Science, pages 157–168. Springer Berlin / Heidelberg, 2001.
