Electronic Notes in Theoretical Computer Science 136 (2005) 103–116 
www.elsevier.com/locate/entcs


Lazy Strong Normalization
Luca Paolini1 ,2
Dipartimento di Informatica Universit`a di Torino (ITALIA)
Elaine Pimentel1 ,2
Departamento de Matema´tica Universidade Federal de Minas Gerais (BRASIL)
Dipartimento di Informatica Universit`a di Torino (ITALIA)
Simona Ronchi Della Rocca1 ,2
Dipartimento di Informatica Universit`a di Torino (ITALIA)

Abstract
Among all the reduction strategies for the untyped λ-calculus, the so called lazy β-evaluation is of particular interest due to its large applicability to functional programming languages (e.g. Haskell [3]). This strategy reduces only redexes not inside a lambda abstraction.
The lazy strongly β- normalizing terms are the λ-terms that don’t have infinite lazy β-reduction sequences.
This paper presents a logical characterization of lazy strongly β-normalizing terms using intersec- tion types. This characterization, besides being interesting by itself, allows an interesting connec- tion between call-by-name and call-by-value λ-calculus.
In fact, it turns out that the class of lazy strongly β-normalizing terms coincides with that of call-by-value potentially valuable terms. This last class is of particular interest since it is a key notion for characterizing solvability in the call-by-value setting.
Keywords: λ-calculus, lazy evaluation, lazy strong normalization


1 Email: paolini@di.unito.it, pimentel@di.unito.it, ronchi@di.unito.it
2 Paper partially supported by IST-2001-33477 DART Project, MIUR-Cofin’02 PROTO- COLLO Project. Pimentel is also supported by CNPq.


1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.06.013

Introduction
An evaluation is called lazy if the body of a function is evaluated only when an argument is supplied. In the λ-calculus setting, this kind of evaluation is modelled by a reduction strategy that does not reduce β-redexes occurring under the scope of a λ-abstraction. Lazy evaluation has been introduced by Plotkin [6] in order to capture into λ-calculus the conceptual difference between the notion of evaluation and that one of code optimization. 3
The notion of strong β-normalization can be extended to the lazy case in a natural way (see [8]). Namely: a lazy β-redex is a β-redex not occurring under the scope of a λ-abstraction, and a term is in lazy β-normal form if and only if it has no occurrences of lazy β-redexes. So a term is lazy strongly β- normalizing if and only if it has lazy β-normal form and there are not infinite lazy β-reduction sequences starting from it.
In this paper we give a complete characterization of the class of lazy strongly β-normalizing terms in a logical way, using a suitable intersection type assignment system.
This characterization, besides being interesting by itself, allows an inter- esting connection between call-by-name and call-by-value λ-calculus. Let us remember that the classical λ-calculus is a model for the call-by-name eval- uation, while the call-by-value evaluation can be modelled by a variant of λ-calculus, the λβv-calculus, introduced in [6]. The λβv-calculus is obtained from the λ-calculus by restricting the β-rule to the case where the argument is a value, i.e., it is either a variable or a λ-abstraction. The fact that all the λ-abstractions are values, independently from their bodies, implies that the natural evaluation for such a calculus is a lazy one. Some syntactical properties of the λβv-calculus have been studied in [5], where the notion of solvability has been adapted to this calculus, and the set of solvable terms has been completely characterized, in a logical way.
In particular, in order to give such a characterization, an intermediate class of terms has been introduced: the potentially valuable terms. A term M is potentially valuable if and only if there is a substitution s, replacing free variables by closed values, such that s(M ) reduces to a value. The importance of such a class becomes clearer when we note that, in the λβv-calculus, the restriction to the β-rule imposes that every term (or subterm), in order to be manipulated, must be first transformed into a value. The potentially valuable terms have been completely characterized in a logical way in [5], and it has been proved that the call-by-value solvable terms form a proper subclass of

3 This must not be confused with the notion of lazy evaluation used in functional program- ming corresponding to a call-by-need evaluation strategy.

the class of the potentially valuable terms.
It turns out that the class of potentially valuable terms coincides with the class of strongly β-normalizing terms. We think that this relationship is an interesting bridge between the call-by-name and the call-by-value evaluation. Besides, the type assignment used in the present work for the character- ization of lazy β-strong normalization, if enriched by a suitable subtyping relation, coincides with the one in [4], which induces a filter model for the call-by-value λ-calculus. This is a further semantic witness of the relationship
between call-by-name and call-by-value evaluation.

Language
Definition 2.1 Let Var be a countable set of variables. The set Λ of λ-terms is defined by the following grammar:
M ::= x | MM | λx.M
As usual, terms will be considered modulo α-conversion, i.e., modulo names of bound variables. α-conversion will be denoted by ≡. We will use the syntactic conventions as in [2]. λ-terms will be ranged over by Latin capital letters.
The evaluation of a term is said lazy if no reduction is made under the scope of a λ-abstraction. It is possible to define directly the lazy reduction, as shown in the next definition.
Definition 2.2  i) The β-rule is defined as (λx.M )N → M [N/x].
The β-reduction is the contextual closure of the β-rule. We will denote

by →β the β-reduction, by →∗
its reflexive and transitive closure, and

by =β its symmetric, reflexive and transitive closure.
The lazy β-reduction is the applicative closure of the β-rule. We will

denote by →βl the lazy β-reduction, by →∗
its reflexive and transitive

closure, and by =βl its symmetric, reflexive and transitive closure.
The η-reduction is defined as the contextual closure of the following rule:
λx.M x →y M
and →∗ is its reflexive and transitive closure.
Notice that the definition of lazy β-reduction, at point iii), is not stand- ard. In fact, the reduction is defined by closing the reduction rule only under application, while in the standard case the closure is under abstraction too.


The notion of normal form can be adapted for the lazy β-reduction in the following way.
Definition 2.3	i) A term M is in lazy β-normal form if and only if it has no occurrences of β-redexes, but under the scope of a λ-abstraction.
ii) A term M has lazy β-normal form if and only if there is a term N in lazy
β-normal form such that M →∗ N .
Clearly β-normal forms are lazy β-normal form.
Note that the lazy β-normal form of a term, if there exists, may not be

unique. In fact, (λxy.x)(II) →∗
λy.II and (λxy.x)(II) →∗
λy.I where both

λy.II and λy.I are lazy β-normal forms.
Now we can define the key notion of βl-strong normalization.
Definition 2.4 A term M is βl-strongly normalizing if and only if it has lazy β-normal form, and moreover there is not an infinite sequence of lazy β-reductions starting from it.

An intersection type assignment system
Definition 3.1  i) Let C be a countable set of type-constants (ranging over
α, β, ..) containing at least the type constant ν.
The set T (C) of types, ranging over by σ, τ, π, ρ, .. is inductively defined as follows:
σ ∈ C	⇒	σ ∈ T (C)
σ, τ ∈ T (C)	⇒	(σ → τ ) ∈ T (C)
σ, τ ∈ T (C)	⇒	(σ ∧ τ ) ∈ T (C).
Types will be considered modulo associativity, commutativity and idem- potency of the constructor ∧ (i.e., modulo an equivalence  which is the contextual, reflexive and transitive closure of the following rules: σ ∧ τ   τ ∧ σ, σ   σ ∧ σ and (σ ∧ τ ) ∧ π   σ ∧ (τ ∧ π)). We use the convention that the constructor ∧ take precedence over →.
A basis is a partial function from Var to T (C) having a finite domain of definition. If B is a basis then B[σ/x] denotes the basis such that
⎧⎪⎨ σ	if y ≡ x,

B[σ/x](y)= 
⎪⎩ B(y)	otherwise.

Furthermore, the basis B such that dom(B) = {x1, ..., xn} and B(xi) = 
σi, for 1 ≤ i ≤ n will be denoted by [σ1/x1, ..., σn/xn].
The type assignment system ▶ν is a formal system proving typing judg- ments of the shape:
B ▶ν M : σ
where M is a term, σ ∈ T (C) and B is a basis.
The type assignment system ▶ν consists of the following rules:


B[σ/x] ▶ν x : σ B[σ/x] ▶ν M : τ
(var)
B ▶ν λx.M : ν B ▶ν M : σ → τ	B ▶ν N : σ
(ν)



B ▶ν λx.M : σ → τ
(→I)
B ▶ν MN : τ
(→E)

B ▶ν M : σ	B ▶ν M : τ B ▶ν M : σ ∧ τ
B ▶ν M : σ ∧ τ

B ▶ν M : σ

(∧I)


(∧El)


B ▶ν M : σ ∧ τ B ▶ν M : τ






(∧Er )

If B, B' are bases then B ∩ B' is the basis defined as follows:
⎧	'	'

⎪ B(y)	if B(y) is defined and B'(y) is undefined,
B'(y)	if B'(y) is defined and B(y) is undefined,
⎪⎩ undefined	otherwise.
The type assignment system ▶ν enjoys some interesting properties.
Lemma 3.2 (Generation)
If B ▶ν M : σ then B ∩ B' ▶ν M : σ, for any basis B'.
If B ▶ν MN : σ then there are types ρi and τi with 1 ≤ i ≤ n, such that
σ  ρ1 ∧ ... ∧ ρn, B ▶ν M : τi → ρi and B ▶ν N : τi.
B ▶ν λx.M : σ → τ if and only if B[σ/x] ▶ν M : τ.
Proof
Easy, by induction on the derivation d proving B ▶ν M : σ.
Easy, b induction on the derivation d proving B ▶ν MN : σ.

(⇐) By rule (→ I).
(⇒) It is easy to prove that B ▶ν λx.M : σ → τ ∧ π1 ∧ ... ∧ πn (n ∈ N) implies B[σ/x] ▶ν M : τ , by induction on derivations.	 
The type system ▶ν enjoys the subject-reduction property and a restricted form of subject-expansion.
Property 3.3 (Subject-reduction)
If B ▶ν M : σ and M →β N then B ▶ν N : σ.
Proof Standard.	 
Property 3.4 (Typed subject-expansion)
Let C[.] be a context. Then B ▶ν C[P [Q/x]] : σ and B' ▶ν Q : τ imply
B ∩ B' ▶ν C[(λx.P )Q]: σ.
Proof The proof is by induction on C[.]. Let d be a derivation proving B ▶ν C[P [Q/x]] : σ. We may assume, without loss of generality, that B is undefined on x and that all typings in d have the same basis B. Indeed, (→ I) is the only rule having a basis, in the premises, different from the basis in the conclusion; but we can assume that free and bound variables have different names in M .
In case C[.]= [.], there are two cases to analyze.
Suppose that either x /∈ FV(P ) (hence P [Q/x] ≡ P ) or Q occurs in sub- terms of P which are subjects of an application of the rule (ν).
In both cases, B ▶ν P : σ; therefore B[τ/x] ▶ν P : σ, by Lemma 3.2.i). Then B ▶ν λx.P : τ → σ, by rule (→ I) and, by Lemma 3.2.i), both B ∩ B' ▶ν λx.P : τ → σ and B ∩ B' ▶ν Q : τ . Hence, by rule (→ E),
B ∩ B' ▶  (λx.P )Q : σ.
Suppose that Q occurs in P [Q/x] and there is a subderivation of d hav- ing Q as subject of the typing of its conclusion. The derivation d can be transformed into a derivation d' proving B[τ/x] ▶ν P : σ by performing the following operations.
Replace each typing B ▶ν Q : τ occurring in the derivation d by:
B[τ/x] ▶ν x : τ (var).
Replace each typing B ▶ν P '[Q/x]: µ occurring in the derivation d by the typing B[τ/x] ▶ν P ' : µ.
It is easy to see by induction on d that d' is well defined. Thus the proof proceeds as in case (a).


For the general case, where C[.] = λx.C'[.] or C[.] = C1[.]C2[.], the result follows easily by induction.	 
Note that typing in the type assignment system ▶ν is not preserved by η-expansion if the set C has any type constants other than ν. Besides, ▶ν is not preserved by η-reduction. In fact,
∅ ▶ν λy.xy : ν
while x : ν is not provable from the empty context.
Moreover, the η-reduction is not valid even in the case that we consider only terms having a functional type, as shown in the next example.
Example 3.5 Let π = (σ → τ0) ∧ (σ → τ1) and B = [π/x, σ/y]. Then [π/x] ▶ν λy.xy : σ → τ0 ∧ τ1 since:




B ▶ν x : π
(var)

(∧El)


(var)


B ▶ν x : π
(var)

(∧Er )


(var)

B ▶ν x : σ → τ0
B ▶ν xy : τ0
B ▶ν y : σ

(→E)
B ▶ν x : σ → τ1
B ▶ν xy : τ1
B ▶ν y : σ

(∧I)

(→E)

B ▶ν xy : τ0 ∧ τ1


[π/x] ▶ν λy.xy : σ → τ0 ∧ τ1

(→I)

But it is easy to check that there isn’t a derivation proving [π/x] ▶ν x : σ →
τ0 ∧ τ1.
It occurs that the standard proofs of the strong normalization property usually depend on the fact that the considered system enjoys a restricted form of η-reduction, namely that the η-reduction holds in the case of arrow types.
A similar situation can be found in, for example, Pottinger [7], that solved the problem by adding to the type system an explicit η-rule. We use a differ- ent technical approach to this problem noting that, although typings are not preserved by η-reduction, typability is preserved.
Lemma 3.6 Let B ▶ν M : σ and x /∈ FV (M ).

If M →∗
−→
P [Q/x] Q and B	ν
Q : ρ then there is a term M ' such that

M ' →∗ (λx.P )
−→
QQ and B
∩ B' ▶ν
M ' : σ.

Proof The proof is by induction on the number m of η-reductions with sub- ordinate induction on the derivation d proving B ▶ν M : σ. If m = 0 then the result follows from Property 3.4.
Let m ≥ 1. There are three cases to analyze.

M ≡ P '[Q'/x −→' with P ' →∗ P , Q' →∗ Q and −→' →∗ −→

]Q	y
follows from Property 3.4.
y	Q	y
Q . Then the result

M ≡ (λu.M¯ u)−→' where −→' is a sequence of n > 0 terms and ¯ −→' →∗
Q	Q	MQ	y
−→

P [Q/x] Q . Then,
M →	¯ −→' →∗ P [Q/x −→

βl MQ	y	] Q

hence B ▶
−→
ν MQ : σ by Property 3.3. The proof follows by induction.

M ≡ λx .M¯ x with λx .M¯ x → M¯ →∗ P [Q/x −→.
1	1	1	1	y	y	] Q
Then the last rule applied in d can only be: (→ I), (∧I), (∧El), (∧Er) or
(ν). The only not trivial case is the first one. So suppose that σ  π → µ
and d ends with

B[π/x1] ▶ν M¯ x1 : µ
B ▶ν λx1.M¯ x1 : π → µ

(→I)

Clearly Mx →∗ P [Q/x −→
, thus by inductive hypothesis on d there exists

1	y	] Q x1

a term M '' such that M '' →∗ (λx.P )
−→
QQ x1
and B[π/x1] ∩ B' ▶ν
M '' : µ.

Without loss of generality, we may assume that B'(x1) is undefined; so
B[π/x1] ∩ B' = (B ∩ B')[π/x1] and (B ∩ B')[π/x1] ▶ν M '' : µ.
Therefore B ∩ B' ▶ν λx1.M '' : π → µ, by rule (→ I). The proof is done,

since
''	∗	−→

λx1.M
→y (λx.P )QQ. 


Consider the type assignment system obtained from ▶ν by erasing the rule (ν): it is well known that it characterizes the β-strongly normalizing terms (see [7]). We will prove that the whole system ▶ν characterizes the βl-strong normalizing terms.
Theorem 3.7 There are B, σ such that B ▶ν M : σ if and only if M is
βl-strongly normalizing.
Proof The proof is given in Subsections 3.1 and 3.2.	 

Typability in ▶ν implies βl-strong normalization
Let S(B, σ, M ) be the following predicate:“M is βl-strongly normalizing and there exists a λ-term M ' such that M ' →∗ M and B ▶ν M ' : σ”.
The following property holds.
−→	−→
Property 3.8 S(B, σ →	) and S (B', σ,N ) imply S(B ∩	'	).

τ, xM
−→
B , τ, xMN 

Proof Trivial, since M and N are independent.	 


The predicate S is used to define a computability predicate.
Definition 3.9
The predicate Comp is defined by induction on types as follows:
Comp(B, α, M ) if and only if S(B, α, M ), for all α ∈ C;
Comp(B, σ → τ, M ) if and only if, for all N ∈ Λ, B' ▶ν N : σ and
Comp(B', σ,N ) imply Comp(B ∩ B', τ,MN );
Comp(B, σ ∧ τ, M ) if and only if Comp(B, σ, M ) and Comp(B, τ, M ).
Comp is closed under βl-reduction and under a restricted form of βl- expansion.
Property 3.10 Let Q be βl-strongly normalizing.
If Comp(B, σ, P [Q/x −→) and B' ▶  Q : µ then Comp(B' ∩ B, σ, (λx.P )  −→ .
QQ )
Proof The proof is given by induction on the structure of types.
−→
Assume σ ∈  . Then, by definition, Comp(B, σ, P [Q/x] Q ) implies that there

exists a term M →∗
−→
P [Q/x] Q
such that B ▶ν
−→
−→
M : σ and P [Q/x] Q is
−→

βl-strongly normalizing. As (λx.P )QQ =βl P [Q/x] Q and Q is βl-strongly
−→
normalizing, we have that (λx.P )QQ is also βl-strongly normalizing and by

Lemma 3.6 there exists M ' →∗ (λx.P )
−→
QQ such that B ▶ν
M ' : σ . Hence,

−→
Comp(B, σ, (λx.P )QQ ) by definition.
−→
Let σ  τ → ρ. Then Comp(B, τ → ρ, P [Q/x] Q ) implies that ∀N such that
B' ▶  N : τ and Comp(B', τ,N ) we have Comp(B ∩ B', ρ,P [Q/x −→  ).

ν	−→
] QN 

Hence Comp(B ∩B', ρ, (λx.P )QQN ) by induction, and therefore by definition

Comp(B ∩ B',τ → ρ, (λx.P )
−→
QQ ).

The case σ  τ ∧ ρ is trivial, by induction.	 
We prove that B ▶ν M : σ implies Comp(B, σ, M ), which in turn implies
S(B, σ, M ).
−→	−→
Lemma 3.11	i) S(B, σ, xM ) implies Comp(B, σ, xM ).
ii) Comp(B, σ, M ) implies S(B, σ, M ).
Proof The proof is done by mutual induction on σ.
The only not obvious case is when σ   τ → ρ
We will prove that Comp(B', τ,N ) and B' ▶ν N : τ imply Comp(B ∩
'	−→	−→
B , ρ, xMN ), thus Comp(B, τ → ρ, xM ) follows by definition.
Comp(B', τ,N ) implies S(B', τ,N ), by induction on ii).



By hypothesis S(B, τ →
−→	'
); thus S(B∩
−→
) by Property 3.8.

The proof follows, since by induction Comp(B ∩	'	−→  ).
B , ρ, xMN 
Let z /∈ FV(M ), and let B be such that B(z) is undefined. Note that, for any x, [τ/x] ▶ν x : τ ; so in particular, S([τ/z], τ, z). Hence Comp([τ/z], τ, z) by induction on i). Thus Comp(B[τ/z], ρ,M z) by defin- ition of Comp and this implies S(B[τ/z], ρ,M z), by induction. That is, Mz is βl-strongly normalizing and clearly also M is βl-strongly normal- izing. Moreover, there exists a term M ' such that both M ' →∗ Mz and
B[τ/z] ▶ν M ' : ρ. Hence B ▶ν λz.M ' : τ → ρ and since
λz.M ' →∗ λz.M z → M
S(B, τ → ρ, M ) follows by definition.

Lemma 3.12 Let FV(M ) ⊆ {x1, ..., xn} and B = B∗[σ1/x1, ..., σn/xn]. If Comp(Bi, σi, Ni), Bi ▶ν Ni : σi (1 ≤ i ≤ n) and B ▶ M : τ, then
Comp(B∗ ∩ B ∩ ... ∩ B , τ,M [N /x , ..., N /x ]).

Proof By induction on the derivation d of B ▶ M : τ . The most interesting case is when the last rule applied of d is (→ I). Let M ≡ λx.M ', τ  µ → ρ

and
B[µ/x] ▶ M ' : ρ
'


(→I)

B ▶ λx.M : µ → ρ
Let Comp(B', µ,N ) and B' ▶ν N : µ. So S(B', µ,N ) by Lemma 3.11.ii); hence
N is βl-strong normalizing. By induction
Comp(B∗ ∩ B' ∩ B ∩ ... ∩ B , ρ,M '[N /x , ..., N /x , N/x])
which implies Comp(B∗ ∩ B' ∩ B1 ∩ ... ∩ Bn, ρ, (λx.M '[N1/x1, ..., Nn/xn])N ) by Property 3.10. Hence, Comp(B∗ ∩ B1 ∩ ... ∩ Bn,µ → ρ, M [N1/x1, ..., Nn/xn]) by definition of Comp. All other cases follow directly from the inductive hypothesis.	 

Proof of Theorem 3.7 (⇒ part).
Suppose that B ▶ν M : σ and let FV(M ) ⊆ {x1, ..., xn}, and B(xi) = σi. Since Comp(B, σi, xi) (1 ≤ i ≤ n) by Lemma 3.11.i), then Comp(B, σ, M ) by Lemma 3.12. Hence the proof is done due to Lemma 3.11.ii).	 


βl-strong normalization implies typability in ▶ν
Let M be in lazy β-normal form. It is easy to see that either M ≡ λx.M ' or M ≡ xM1 ... Mn with n ≥ 0 where Mi are in lazy β-normal form for all 1 ≤ i ≤ n.
Lemma 3.13 If M is in lazy β-normal form, then there are a basis B and a type σ ∈ T (C) such that B ▶ν M : σ.
Proof Let M be in lazy β-normal form. The proof is done by induction on the shape of M . If M ≡ λx.M ' then B ▶ν M : ν for any basis B.
Let M ≡ xM1 ... Mn. If n = 0, then M is a variable and




x : σ ▶ν x : σ
(var)

for any σ ∈ T (C).	Suppose n > 0.	By inductive hypothesis there are
B1,... , Bn and σ1,... , σn such that:
Bi ▶ν Mi : σi
Then M has type σ in the basis B' = B1 ∩ ... ∩ Bn ∩ [σ1 → ... → σn → σ/x] since:


B' ▶ν
x : σ1
→ ... → σn
→ σ (∧Er )/(var)	B' ▶
Mi : σi


(→E)

B' ▶ν xM1 ... Mn : σ


Remember that a lazy β-redex is a β-redex that does not occur under the scope of a λ-abstraction.
Property 3.14 Let M be not in lazy β-normal form.
Then there are subterms P, Q of M such that Q in lazy β-normal form and
(λx.P )Q is a lazy β-redex of M.
Proof The proof is by induction on M .	 

Proof of Theorem 3.7 (⇐ part).
Suppose that M is βl-strong normalizing, that is, there is not an infinite sequence of βl-reductions starting from M .
Without loss of generality, by Property 3.14, we can assume that there is a lazy β-reduction sequence
M ≡ M0 →βl ... →βl Mn ≡ N


reducing only lazy β-redexes of the shape (λx.P )Q such that Q in lazy β- normal form.
The proof is given by induction on n.
If n = 0, the result follows from Lemma 3.13. Suppose n ≥ 1. By induction hypothesis, there are a base B1 and a type σ such that B1 ▶ν M1 : σ. Moreover, there is a basis B2 and a type τ such B2 ▶ν Q : τ by Lemma 3.13. Then the result follows trivially from Property 3.4.	 

βl-strong normalization and call-by-value solvability
The notion of βl-strong normalization allows for stating an interesting rela- tionship between call-by-name and call-by-value evaluation of λ-calculus.
Let us recall the definition of call-by-value λ-calculus [6].
Definition 4.1 Let the set Val of values be Var ∪ {λx.M | M ∈ Λ}.
The βv-reduction (→βv) is the contextual closure of the following rule:
(λx.M )N → M [N/x] if and only if N ∈ Val.

→∗
and =βv
are respectively the reflexive and transitive closure of →βv

and the symmetric, reflexive and transitive closure of →βv .
The λβv-calculus is the language Λ equipped with the βv-reduction
Plotkin proved that the λβv-calculus is confluent. The notion of solvability can be extended to the λβv-calculus in the following way.
−→
Definition 4.2 A term M is βv-solvable if and only if there is a sequence P

of values such that:
−→
(λx1...xn.M ) P =βv I

where FV(M )= {x1, ...xn} and I = λx.x is the identity term.
The main problem on reasoning in an operational way in the λβv-calculus has to do with the fact that every term (or subterm) must be transformed into a value in order to be manipulated. In fact, in [5], in order to prove syntactical properties of the λβv-calculus, it was introduced the key notion of potential valuability.
Definition 4.3  i) A term M is valuable if and only if it βv-reduces to a term belonging to Val.
ii) A term M is potentially valuable if and only if there is a substitution s, replacing variables by closed terms belonging to Val, such that s(M ) is valuable.


In [5] it was proved that the set of βv-solvable terms is a proper subset of the set of potentially valuable terms. Moreover, a logical characterization of both the potentially valuable and the βv-solvable terms is given, through an intersection type assignment system which is equivalent (with respect to typ- ability power) to the system ▶ν. More precisely, the system in [5] is obtained from ▶ν by restricting the set of types, allowing the use of the intersection only in the left side of an arrow. It is well known that two intersection type assign- ment systems related to each other by this relation have the same typability power (see for example [1]).
In order to show this characterization, we need to introduce a definition.
Definition 4.4 A type σ is proper if it is of the following shape:
σ  τ1 → ... → τn → α
where n ≥ 0 and α is a type constant different from ν.
The following theorem holds.
Theorem 4.5 [5]
M is potentially valuable if and only if there are B, σ such that B ▶ν M :
σ.
M is βv-solvable if and only if there B, σ such that σ is proper and B ▶ν
M : σ.
On the basis of this result, and of the Theorem 3.7, we can state the following relation between call-by-name and call-by-value λ-calculi.
Corollary 4.6 M is βl-strongly normalizing if and only if M is potentially valuable.

References
van Bakel, S., “Intersection type assignment systems,” Theoretical Computer Science, 38(2):246-269, Elsevier, (1997).
Barendregt, H.P., “The Lambda Calculus: its syntax and semantics,” N.103 in Studies in Logic and the Foundations of Mathematics (revised edition), North-Holland, Amsterdam (1994).
Bird, R., “Introduction to Functional Programming using Haskell,” Series in Computer Science (2nd edition), Prentice Hall, (1998)
Egidi, L., Honsell, F., and Ronchi della Rocca, S., “Operational, denotational and logical descriptions: a case study,” Fundamenta Informaticae, 16(2) (1992) 149–170.
Paolini, L., Ronchi Della Rocca, S., “Call-by-value Solvability,” Theoretical Informatics and Applications, 33(6) (1999) 507-534.


Plotkin G.D., “Call-by-name, call-by-value and the λ-calculus,” Theoretical Computer Science, 1 (1975) 125-159.
G. Pottinger, “A type assignment for the strongly normalizable λ-terms”, in To H.B. Curry: essays on combinatory logic, lambda calculus and formalism, pp.561-577, Academic Press, London, 1980.
Ronchi Della Rocca S., Paolini L., “The Parametric λ-calculus: a meta-model for computation”, Computer Science-Monograph, Springer Verlag, to appear.
