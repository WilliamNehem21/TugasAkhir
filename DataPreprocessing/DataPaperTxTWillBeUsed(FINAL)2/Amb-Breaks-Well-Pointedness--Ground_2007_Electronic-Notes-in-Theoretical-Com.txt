

Electronic Notes in Theoretical Computer Science 173 (2007) 221–239
www.elsevier.com/locate/entcs

Amb Breaks Well-Pointedness, Ground Amb Doesn’t
Paul Blain Levy 1
University of Birmingham, Birmingham B15 2TT, U.K.

Abstract
McCarthy’s amb operator has no known denotational semantics, and its basic operational properties - the context lemma, the compatibility of refinement similarity and convex bisimilarity - have long been open. In this paper, we give a single example program that demonstrates the failure of each of these properties. This shows that there cannot be any well-pointed denotational semantics.
However, we show that, if amb is given at ground type only, then all of these operational properties do hold.
Keywords: McCarthy’s amb, applicative simulation, Howe’s method, fixpoint, CIU theorem, context lemma


Introduction
The Questions
McCarthy’s amb [14] is a kind of fair nondeterminism: M amb M ' can return any value that M or M ' can return, and can diverge only if both M and M ' can diverge. This differs from ordinary (erratic) nondeterminism M H M ', which can diverge if either M or M ' can diverge. Despite its apparent simplicity, amb has been something of an embarrassment for semantics research. It has resisted both denotational modelling and a satisfactory operational treatment, leading to two substantial open problems [6].
The first problem arises from the notion of applicative bisimulation, introduced in [1] in the untyped setting and later studied in the typed setting [3]. Applicative bisimilarity was shown to be a congruence by an ingenious method [5]. This method works in both the deterministic and the erratically nondeterministic setting, but as explained in [8], it does not work in the presence of amb. So it has remained open whether applicative bisimilarity, in the presence of amb, is a congruence.

1 Email: pbl@cs.bham.ac.uk



1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.02.036

A second problem is contextual equivalence, where we treat both convergence and divergence as observable. In the nondeterministic setting, this is known to be coarser than applicative bisimulation. The context lemma states that two terms M and M ' that are contextually equivalent in any environment (i.e. under any closing substitution) must be contextually equivalent. This was shown in [5,6] in the erratically nondeterministic setting, but whether it holds in the presence of amb has remained open.
In this paper, we give a single example that simultaneously answers these questions—and some variants using preorders rather than equivalence relations—in the negative. We give two programs M and M ' that in any environment must be re- garded as equivalent, even when we use the finer relation of applicative bisimilarity. On the other hand, there is a context C[·] such that C[M ] may diverge and C[M '] cannot. This shows that, in the setting of amb, it is impossible to regard a term as being a function from environments to behaviours. No denotational semantics founded on such a principle can work.
In order to formulate this example, we need to make use of amb at non-ground type. In a calculus that provides amb with ground type only, we shall show that the open questions can be answered affirmatively.
The structure of the paper is as follows. In Sect. 2, we describe our results using a small call-by-name (CBN) calculus, without function types. This makes the example program easy to understand. Then, in Sect. 3–4, to prove our positive results, we move to a call-by-value (CBV) calculus with function types and recursive types.
Remark 1.1 Our example program works for typed calculi (which may include recursive types). This is by contrast with [7], where the untyped lazy λ-calculus with amb is studied. For that calculus, our example does not work (unless sequencing is added), and the open questions remain open.

Small Call-By-Name Calculus
The Questions
In this section, we consider a call-by-name calculus with ground types and unary sum types, as shown in Fig. 1–2. We write L for the unary sum type constructor, and pm as an abbreviation for “pattern-match”. We write diverge for rec x. x. The operational semantics as displayed in Fig. 2 follows the formulation of [16].
For each type A, we define a set [A] as follows:
[bool]= P{true, false, ⊥}
[1] = P{Т, ⊥}
[LA]= P({up B | B ∈ [A]}∪ {⊥})
(We could choose to exclude the empty set from the powersets, but this does not substantially affect our argument.) For each closed term M : A we define its oper- ational meaning [M ] ∈ [A] by induction on A:



Types	A ::=	bool | 1 | LA
Terms

Γ, x : A ▶ M : A



Γ ▶ x : A
(x : A) ∈ Γ


Γ ▶ rec x.M : A



Γ ▶ M : A	Γ ▶ M ' : A


Γ ▶ M H M ' : A
Γ ▶ M : A	Γ ▶ M ' : A

Γ ▶ M amb M ' : A





Γ ▶ top :1 
Γ ▶ M :1	Γ ▶ N : B

Γ ▶ M ; N : B



Γ ▶ M : A

Γ ▶ up M : LA
Γ ▶ M : LA	Γ, x : A ▶ N : B

Γ ▶ pm M as up x. N : B

Fig. 1. Syntax of Call-By-Name Language

def
if M : bool then [M ] = {true | M ⇓ true}∪ {false | M ⇓ false}∪ {⊥ | M ⇑}
def
if M :1 then [M ] = {top | M ⇓ top}∪ {⊥ | M ⇑}
def
if M : LA then [M ] = {up [N ] | M ⇓ up N }∪ {⊥ | M ⇑}.
We say two terms M, M ' : A are convex bisimilar when [M ]= [M ']. If A is a ground type, we say they are behaviourally equivalent.
Convex bisimilarity is robust, because of the following result, whose proof we defer to Sect. 3.
Proposition 2.1 If closed terms ▶ M, M ' : A are convex bisimilar then C[M ] and
C[M '] are convex bisimilar for any context C[·] of any type, with hole of type A.
Suppose we wish to identify closed ground terms precisely when they are be- haviourally equivalent. As explained in [9], domain semantics, in which diverge ≤ true, cannot be used. For then
true H diverge ≤ true H true = true

but, if amb is monotone, we also have
true = if (false amb diverge) then diverge else true
≤ if (false amb true) then diverge else true
= true H diverge
Hence true H diverge = true, contradicting behavioural equivalence. So in any domain semantics of nondeterminism, either true H diverge and true are identified (as in Hoare’s theory), or amb is not monotone (as in the theories of Smyth and Plotkin). In fact, no denotational model of ground behavioural equivalence for this calculus is known.
We say that two open terms Γ ▶ M, M ' : B are



The following closed terms are terminal
T ::=	true | false | top | up M

Convergence Relation M ⇓ T —Inductive Definition

Divergence Predicate M ⇑—Coinductive Definition


Fig. 2. Big-Step Semantics For A Call-By-Name Calculus

−−→
' −−→

convex applicatively bisimilar when M [N/x] and M [N/x] are bisimilar for
−−→
every Γ-environment N/x
contextually equivalent when C[M ] and C[M '] are behaviourally equivalent for every ground context C[·] with hole inhabiting Γ ▶ B

−−→
' −−→

CI equivalent (CI stands for “closed instantiation”) when M [N/x] and M [N/x]
−−→
are observationally equivalent for every Γ-environment N/x.
The two open problems of [6], stated there in a rich setting with function types and recursive types, are as follows.
Is convex applicative bisimilarity a congruence?
Does CI equivalence imply contextual equivalence? (Such a result is called a
context lemma or a CI theorem.)
There are also variants of these questions using preorders rather than equivalence relations. In the setting of erratic choice, all of these questions have been affirma- tively answered [5,6,12]. But it did not seem possible to adapt these techniques to amb [8]. So the questions have remained open.
The Counterexample
We will now give a single example that answers both these questions (and the preorder variants) negatively. Define the terms x : L1 ▶ M, M ' : L1 as follows.
def
M = (up top) amb (pm x as up z.up (top H z))
' def
M = up (top H pm (x amb up top) as up y.y)
def
M  = M H M
For any closed term ▶ N : L1, the terms M [N/x] and M ''[N/x] are behaviourally equivalent. (This is true even if we introduce a constant at each type representing the empty set.)
Neither is able to diverge.
Both are able to return up P , for some P such that P ⇓ top but P /⇑.
Neither is able to return up P , for some P such that P /⇓ top.
Both are able to return up P , for some P such that P ⇓ top and P ⇑, precisely if N is able to return up Q for some Q such that Q ⇑.
Thus M and M '' are convex applicative bisimilar. Hence, by Prop. 2.1, they are also CI equivalent. But they are not contextually equivalent; for example, they can be distinguished by the context

def
C[·] = pm (up top amb (rec x.[·])) as up u. u  :1 
We first observe that
if rec x.M ⇓ up N , then, by induction on the evaluation, we have N = (top H )n top, and so N cannot diverge

rec x.M '' ↓ up (top H C[M '']) by taking the right-hand choice.
gives us C[M ] /⇑. To show C[M '] ⇑, we consistently take the right-hand choice. Formally, we have
{CM '', top H CM ''} ±⇑
by simple coinduction, using (ii).
This example rules out any denotational semantics that is well-pointed, i.e. in which the semantics of a term is a function from environments. Opera- tionally, M and M '' describe the same endofunction f on [L1], mapping C to
{up {Т}, up {Т, ⊥}} if ED ∈ [1]. (⊥ ∈ D Λ up D ∈ C), and to {up {Т}} other- wise. But f has two fixpoints, viz. {up {Т}} and {up {Т}, up {Т, ⊥}. And the operational argument shows us that [rec x.M ] is the former, and [rec x.M ''] the latter. So there is no right way of computing the recursive fixpoint. (Cf. the fixpoint example in [13].)

Uses
A use is a special kind of ground context that can be applied to a closed term.
A use of bool is a ground context if [·] then N else N '.
A use of 1 is a ground context [·]; N .
A use of LA is a ground context pm [·] as up x. N .
Two closed terms ▶ M, M ' : A are uses equivalent when C[M ] and C[M ]' are be- haviourally equivalent for every use C[·] of A.	More generally, two open terms
'	——→	' ——→

Γ ▶ M, M
: A are CIU equivalent when C[M [V /x]] and C[M [V /x]] are behaviourally
——→

equivalent for every Γ-environment V /x and every use C[·] of A.
A uses theorem states that uses equivalence implies contextual equivalence. A CIU theorem is the conjunction of a CI theorem and a uses theorem, stating that CIU equivalence implies contextual equivalence. This theorem (and preorder vari- ants) is known to hold in the deterministic [18] and erratically nondeterministic [6] settings.
Like the CI theorem, the uses theorem fails in the presence of amb. To see this, define terms ▶ M, M ' : L1 as follows:
def
M = diverge H up top
' def
M = M H up (top H diverge)
Now for any ground term x :1 ▶ N : C, the terms M to x. N and M ' to x. N both diverge. Moreover, they converge to the same things, because M and M ' are “may contextually equivalent” (see e.g. [6]). So M and M ' are uses equivalent. But they are not contextually equivalent; for example, they can be distinguished by
C[·]= pm ([·] amb up top) as x. x  :1 
C[M '] may diverge, whereas C[M ] cannot.

Ground Amb
In the examples in Sect. 1.1–2.3, crucial use was made of amb at the non-ground type L1. If we allow amb at ground type only, then all the questions can be answered affirmatively. We prove this in Sect. 4.

Strong and Weak Divergence
As suggested in [17], if we are concerned with branching-time behaviour, it might be reasonable to distinguish different kinds of divergence. When a term diverges, either
convergence remains possible throughout, or
it is eventually the case that only divergence is possible.
These two kinds of divergence are called weak and strong respectively. For example, the program Pn
Choose n + 1 booleans. If they’re all true, then terminate, else: choose n + 2 booleans. If they’re all true, then terminate, else:
choose n + 3 booleans. If they’re all true, then terminate, else:
.. .
can weakly diverge, but cannot strongly diverge. The same is true of C[M '']. Our claim that M [N/x] and M ''[N/x] have the same range of behaviours for any
N continues to hold even if we distinguish these kinds of divergence. And it seems likely that Prop. 2.1 could be adapted to a finer notion of bisimulation that makes this distinction. So the distinction does not destroy our example.
In order to encode λ-calculus with amb into the π-calculus, [2] takes this a step further: not merely distinguishing strong from weak divergence, but disregarding weak divergence entirely. Our example is not then applicable, because C[M ''] cannot strongly diverge.
Remark 2.2 If we treat the boolean choices as probabilistic, with 0.5 probability of true, then the program Pn diverges with probability greater than > 1—2−n, which is close to 1 if n is large. It seems hard to justify disregarding this divergence, if one cares about divergence in the first place.

A Call-By-Value Calculus
For the operational techniques in this paper, it is easiest to work with call-by-value. They can be adapted to call-by-push-value, and hence to call-by-name, but at the cost of some complication. The types of our calculus are as follows:
coinductive definition	A ::=	Σi∈IAi | 1 | A × A | A → A

where I ranges over countable sets. We make the type syntax coinductive so that we get equirecursive types (i.e. equality μx.A = A[μX.A/X] rather than mere iso- morphism). We define the ground types coinductively by
C ::=	Σ	Ci | 1 | C × C
We omit rules for 1 as they are analogous to those for ×.
We use a fine-grain call-by-value calculus 2 that explicitly distinguishes values from ordinary terms. So there are two judgements: Γ ▶ M : B means that M is a term of type B, and Γ ▶v V : B means that V is a value of type B. The syntax is defined inductively in Fig. 3.




Γ, x : A, Γ' ▶v x : A
Γ ▶v V : A	Γ, x : A ▶ M : B

Γ ▶ let V be x. M : B



Γ ▶v V : A

Γ ▶ return V : A
Γ ▶ M : A	Γ, x : A ▶ N : B

Γ ▶ M to x. N : B



Γ ▶v V : A	Γ ▶v V ' : A'

Γ ▶v ⟨V, V '⟩ : A × A'
Γ ▶v V : A × A'	Γ, x : A, y : A' ▶ M : B

Γ ▶ pm V as ⟨x, y⟩. M : B



Γ ▶v V : Aˆı
Γ ▶v V : Σ
Ai	Γ, x : Ai ▶ Mi : B (∀i ∈ I)

Γ ▶v ⟨ˆı, V ⟩ :

i∈I
ˆı ∈ I
	i∈I	
Γ ▶ pm V as {⟨i, x⟩.Mi}i∈I : B



Γ, f : A → B, x : A ▶ M : B

Γ ▶v rec fλx.M : A → B
Γ ▶v V : A → B	Γ ▶v W : A

Γ ▶ VW : B



Γ ▶ Mi : B (∀i ∈ I) Γ ▶ choose i∈I.Mi : B
Γ ▶ Mi : B (∀i ∈ I) Γ ▶ amb i∈I.Mi : B


Fig. 3. Syntax Of Fine-Grain CBV With Countable Nondeterminism
The operational semantics is given in Fig. 4. Instead of defining ↓ coinductively, we define its complement ↓ inductively. That is clearly equivalent, but makes reasoning easier.
Remark 3.1 We can treat the CBN calculus of Sect. 2 in precisely the same way as our CBV calculus. Indeed, the former is a fragment of the latter via the standard thunking transformation [4], translating LA as 1 → A. But this only works because the CBN calculus lacks function types.

2 For comparison with similar calculi such as Moggi’s monadic metalanguage [15], see [11].

If we wished to include CBN function types, or, more generally, to work with call-by-push-value [10], we would require other techniques. As this is not specific to amb, we do not treat it in this paper.
May Convergence (inductive definition)


M [W/x] ↓ V
let W be x. M ↓ V
M [rec fλx.M/f, W/x] ↓ V

(rec fλx.M )W ↓ V




return V ↓ V
M ↓ W	N [W/x] ↓ V M to x. N ↓ V



Mˆı[W/x] ↓ V
pm ⟨ˆı, W ⟩ as {⟨i, x⟩.M }
ˆı ∈ I
↓ V
M [W/x,W '/y] ↓ V

pm ⟨W, W '⟩ as ⟨x, y⟩. M ↓ V

i i∈I


Mˆı ↓ V	ˆı ∈ I
choosei∈IMi ↓ V
Mˆı ↓ V	ˆı ∈ I
ambi∈IMi ↓ V

Must convergence (inductive definition)




return V ↓ 
M ↓	∀W (M ↓ W ⇒ N [W/x] ↓ )

M to x. N ↓ 



M [W/x] ↓ 

let W be x. M ↓ 
M [rec fλx.M/f, W/x] ↓ 

(rec fλx.M )W ↓ 



Mˆı[W/x] ↓ 
pm ⟨ˆı, W ⟩ as {⟨i, x⟩.M }
ˆı ∈ I
↓
M [W/x,W '/y] ↓ 

pm ⟨W, W '⟩ as ⟨x, y⟩. M ↓

i i∈I


Mˆı ↓	ˆı ∈ I
choosei∈IMi ↓ 
Mi ↓  (∀i ∈ I)
ˆı ∈ I
ambi∈IMi ↓ 


Fig. 4. Big-Step Semantics For Fine-Grain CBV

Definition 3.2  (i) A closed relation R associates to each type A a binary relation on the closed terms inhabiting it, and a binary relation on the closed values inhabiting it.
An open relation R associates to each sequent Γ ▶ A a binary relation on the terms inhabiting it, and to each value sequent Γ ▶v A a binary relation on the values inhabiting it, such that if Γ ▶ M R M ' : B and Γ ⊆ Γ' then Γ' ▶ M R M ' : B, and similarly for values.

We write id for the identity relation on terms and values, and idf for the identity relation restricted to identifiers.
We write E for the universal relation on terms and values (relating everything to everything).
We write ; for relational composition, in diagrammatic order.
We write R∗ for the reflexive transitive closure of R.
If R is an open relation, we write R0 for the restriction of R to closed terms and closed values.
Let R be a closed relation. We define R◦ (the open extension of R) to be the
——→	——→
open relation that relates two terms Γ ▶ M, N : B when M [V /x] RN [V /x] for
——→
any substitution V /x from Γ to the empty context.
Let R be a closed relation. We define Rw (the weakening extension of R) to be the open relation that relates two terms Γ ▶ M, N : B when M and N are both closed and M R N .
Definition 3.3	(i) Let R and S be open relations. We define R[S] (the substi- tution of S into R) to be the open relation consisting of the pairs of terms
——→	——→
Δ ▶ M [V /x],N [W/x] : B for every pair of terms Γ ▶ M, N : B and pair of
−−→	−−→

substitutions Γ  V /x  Δ and Γ  W/x  Δ such that M R N and V
S Wx
for each

(x : A) ∈ Γ.
(ii) An open relation S is substitutive when idf ⊆S and S[S] ⊆ S.
Definition 3.4 Let R be an open relation.
We define R^ (the compatible reﬁnement of R) to be the open relation that
relates two terms θ{Mi}i∈I and φ{Nj}j∈J when θ = φ (hence I = J ), and
Mi R Ni for each i ∈ I.
S is compatible when S^ ⊆ S.
We define RSC (the substitutive compatible closure of R) to be the least sub- stitutive compatible relation containing R.

Lemma 3.5 Let R be a closed relation. Then RwSC
^wSC
⊆ Rw
^
∪ R	. Hence R	0 ⊆

R ∪ R	0.


Proof.

RwSC = Rw[RwSC

^
] ∪ R

⊆ Rw

^
[E] ∪ R

⊆ Rw

^wSC


For reasoning about operational semantics, the following variant of —^ is useful.
Definition 3.6 If R is an open relation, we define R` to be the closed relation that relates
let V be x.M to let V ' be x. M ', where V R V ' and M R M '

return V to return V ', where V R V '
M0 to x. M1 to M ' to x. M ' , where M0 R M ' and M1 R M '
0	1	0	1
pm ⟨V0, V1⟩ as ⟨x, y⟩. M to pm ⟨V ',V '⟩ as ⟨x, y⟩. M ', where V0 R V ' and V1 R V '
0	1	0	1
and M R M '
pm ⟨ˆı, V ⟩ as {⟨i, x⟩. Mi}i∈I to pm ⟨ˆı, V '⟩ as {⟨i, x⟩. M '}i∈I where V R V ' and
Mi R M ' for each i ∈ I
(rec fλx.M )V to (rec fλx.M ')V ' where M R M ' and V R V '
choose i∈I. Mi to choose i∈I. M ', where Mi R M ' for each i ∈ I
i	i
amb i∈I. Mi to amb i∈I. M ', where Mi R M ' for each i ∈ I.
i	i
Definition 3.7 Let R be a closed relation.
R respects tuples when

⟨ˆı, V ⟩ R ⟨ˆı',V '⟩ : Σ
i∈I
Ai implies ˆı = ˆı' and V R V ' : Aˆı,

⟨V0, V1⟩ R ⟨V ',V '⟩ : A0 × A1 implies V0 RV ' : A0 and V1 RV ' : A1.
0	1	0	1
R respects functions when V R V ' : A → B implies VW R V 'W : B for every closed value W : A
We say that R is a lower applicative simulation when it respects tuples and functions, and M R M ' and M ↓ V implies M ' ↓ V ' for some V ' such that V R V '. If, moreover, M R M ' and M ⇑ implies M ' ⇑, then R is a lower+divergence applicative simulation.
We say that R is a lower (resp. lower+divergence) applicative bisimulation
op
when R and R	are both lower (resp. divergence) simulations.
We say that R is a lower+divergence applicative sesquisimulation when it is a lower+divergence simulation and a lower bisimulation.
The dual of a lower+divergence simulation is called a reﬁnement simulation
in [6].
We define lower applicative similarity to be the greatest lower applicative sim- ulation, and so forth for the other kinds of simulation.
It is convenient to define contextual equivalence (and inequality) without for- mally defining contexts.
Definition 3.8 Let R be a closed relation.
R is may-preadequate when, if M R M ' : A where A is a ground type, and M ↓ n
then M ' ↓ n. It is may-adequate when both R and Rop are may preadequate.
R is preadequate when it is preadequate and, if M R M ' : A where A is a ground type, and M ⇑ then M ' ⇑. It is adequate when both R and Rop are preadequate.
Definition 3.9 Let Γ ▶ M, M ' : A be terms. Write R(M,M') for the substitutive compatible closure of the open relation that only relates Γ' ▶ M, M ' : A for Γ' ⊇ Γ. We say
M ±o M ' when R(M,M')0 is may-preadequate

M  o M ' when R(M,M ')  is may-adequate
M ±⇑ M ' when R(M,M ')  is preadequate
M  ⇑ M ' when R(M,M')  is adequate.
Definition 3.10  (i) Let M, M ' : A be closed terms. We say M ±⇑U M ' when for any ground type C and term z : A ▶ P : C, the behaviours (values or divergence) of M to z. P are contained in the behaviours of M ' to z. P .
(ii) Let V, V ' : A be closed values. We say V ±⇑U V ' when for any ground type B and term z : A ▶ P : B, the behaviours (values or divergence) of P [V /z] are contained in the behaviours of P '[V /z].
Clearly contextual inequality ±⇑ is contained in ±⇑U ◦.
The only task that we have in the setting of general amb is proving Prop. 2.1, or rather a corresponding statement in our CBV setting.
Definition 3.11 A closed relation R is said to be ground on functions when
V R V ' : A → B implies that A is a ground type.
Proposition 3.12 (i) Let R be a lower+divergence applicative simulation that is ground on functions. Then RwSC0 is a lower+divergence applicative simulation.
(ii) Let R be a lower+divergence applicative bisimulation that is ground on func- tions. Then RwSC0 is a lower+divergence applicative bisimulation.
Proof.
Clearly RwSC0 respects functions, and it is easy to show that it respects tuples. Hence if W RwSC W ' : A and A is a ground type, then W = W '. This is by induction on W .
We next show that RwSC0 ⊆ R ∪ Rw`SC.	Suppose M RwSC0 M '.	By

Lemma 3.5, either M R M '
^
or M R
M '. In the latter case, we show that

either M R M ' or M Rw`SCM ', by case analysis.
Suppose M	=	(rec fλx.M0)W	and M '	=	(rec fλx.M ' )W ' and
rec fλx.M0 RwSC rec fλx.M ' and W RwSC W '. By Lemma 3.5, either
M0 RwSC M ' , in which case we are done, or
rec fλx.M0 R rec fλx.M ' , in which case W has ground type so W = W '
by the first paragraph. Hence M R M ', since R respects functions.
The other cases are trivial, using the fact that RwSC respects tuples.
We next show that RwSC0 is a lower applicative simulation. We need to show that if M ↓ V and M RwSC0 M ' then there exists V ' such that M ' ↓ V ' and V RwSC0 V '. We do this by induction on M ↓ V . The case that M R M ' is trivial, so we suppose that M Rw`SC M ', and go through the various cases of
M . We omit the details, which are straightforward.
We next show that if M ' ↓ and M RwSC M ' then M ↓ ; we do this by induction on M ' ↓ . The case that M R M ' is trivial, so we suppose that M Rw`SC M '.



Suppose M = M0 to x. M1 and M ' = M '
to x. M '
and M0 RwSC M '
and

M1 RwSC M ' .	Then M '
↓ , which gives us M0 ↓ .	If M0 ↓ W , then,

1	0

since RwSC0 is a lower simulation, there exists W ' such that M '
↓ W ' and

W RwSC W ', and we have M ' [W '/x] ↓ . Since M1[W/x] RwSC M ' [W '/x] we
1	1
have M1[W/x] ↓  by inductive hypothesis. Hence M0 to x. M1 ↓ .
A corollary of (i).

Ground Amb
Aims
Our aim is to prove the following results.
Proposition 4.1 When we restrict the use of amb to ground type,
divergence applicative similarity is a substitutive precongruence
divergence applicative sesquisimilarity is a substitutive precongruence
divergence applicative bisimilarity is a substitutive congruence.
±⇑ and ±⇑U ◦ coincide, i.e. ±⇑U ◦SC  is preadequate.
Decomposing Over A Relation
The following will be useful in the following sections.
Definition 4.2 An open relation S decomposes over a closed relation R when S ⊆ S^; R◦.
Proposition 4.3 Let S be an open relation that decomposes over a closed relation
R. Suppose that S respects tuples and R respects functions. Then S0, restricted to terms (i.e. not values), is contained in S`; R.
Proof. Suppose M S0 M '. Since S decomposes over R, there exists M '' such that
M S^ M '' and M '' RM '. We then reason by cases.
Suppose M = VW and M '' = V 'W ' and V S V ' and W S W '.	Then V  =

rec fλx.M0, so, by decomposition, there exists M ''
such that M0 S M ''
and

rec fλx.M '' RV '. Since R respects functions, (rec fλx.M '')W ' RV 'W ' RM '.
0	0
In all other cases, M S`M '', using the fact that S respects tuples.

Divergence Similarity Is A Precongruence
The goal of this section is to prove Prop. 4.1.
Definition 4.4 An open relation S is Howe-suitable over a closed relation R when
S decomposes over R.

S is reflexive, substitutive and respects functions
S; R◦ ⊆S 
Proposition 4.5 Let R be a closed preorder and let S be an open relation Howe- suitable over R.
R◦ ⊆S 
If S0 ⊆ R (e.g. if (S∗)0 ⊆ R), then R◦ = S = S∗.
If R respects tuples then so does S.
Proof.
R◦ = id; R◦ ⊆ S; R◦ ⊆S 
For any open relation S, we have S ⊆ S[id] ◦. In our case, since S is reflexive
and substitutive, we have S ⊆ S0◦ ⊆ R◦.
Suppose ⟨ˆı, V ⟩ S0 ⟨ˆı',V '⟩.	Then there exists V '' such that V S0 V '' and
⟨ˆı, V ''⟩ R ⟨ˆı',V '⟩. Because R respects values, ˆı = ˆı' and V '' RV ' so V S V '. Similarly at product types.

Definition 4.6 A closed relation R is an upper simulation when it respects values and tuples and M R M ' and M ↓  implies M ' ↓  Λ∀V '.(M ' ↓ V ' ⇒ EV.(M ↓ V Λ V R V '))
Proposition 4.7 Let S be an open relation Howe-suitable over a closed relation R
respecting functions and tuples.
If R is a lower simulation, then so is S0, and hence so is S∗.
op
If R is an upper simulation and S0 is may-preadequate, then S0 is an upper
simulation, and hence so is S∗.
Proof. S respects functions by definition, and respects tuples by Prop. 4.5(iii). Hence Prop. 4.3 applies.
Suppose that R is a lower simulation. We have to show that M S0 M ' and M ↓ V implies M ' ↓ V '' for some V '' such that V S0 V ''. We proceed by induction on M ↓ V . This is standard.
Suppose that R is an upper simulation. We have to show that M S0M ' and M ↓ implies M ' ↓ Λ∀V '.(M ' ↓ V ' ⇒ EV.(M ↓ V Λ V R V ')) We prove this by induction on M ↓ .
We know that there exists M '' such that M S`M '' and M '' RM '.
Suppose M = amb i∈IMi and M '' = amb i∈IM ' and Mi S M ' for all i ∈ I.
i	i
Then there exists ˆı ∈ I such that Mˆı ↓ . So M ' ↓ , so M '' ↓ , so M ' ↓ . If

M ' ↓ n, then, since M S
ˆı
M ' and Sop

0
we know that n S n.
0 is may-preadequate, we have M ↓ n, and

Otherwise, we proceed as follows. We first show M '' ↓ Λ∀V ''.(M '' ↓ V '' ⇒ EV.(M ↓ V Λ V R V '')) in the following way.



Suppose that M = M0 to x. M1 and M '' = M '
to x. M '
and M0 S M '
and

M1 S M ' . We have M0 ↓ , so M ' ↓ . If M '
↓ W ', then by the inductive

1	0	0
hypothesis there exists W such that M0 ↓ W and W S W '. So M1[W/x] ↓ ,
and M1[W/x] S M ' [W 'x], so M ' [W '/x] ↓  .

If M '
1
to x. M '
1
↓ V '', then there exists W ' such that M '
↓ W ' and

M ' [W '/x] ↓ V ''. Then there exists W such that M0 ↓ W and W S W '. Since
M1[W/x] S M ' [W 'x], there exists V such that M1[W/x] ↓ V and V S V ''.
The other cases are similar. It follows that:
M ' ↓ , as required
if M ' ↓ V ', then there exists V '' such that M '' ↓ V '' and V '' RV ', so there exists V such that M ↓ V and V S V '', so V S V ', as required
 
Proposition 4.8 Let R be a closed relation. Then there exist relations R→ and
R← such that
R→ is Howe-suitable over R
R←op is Howe-suitable over Rop
R→∗ = R←∗
R→ ∩ R← is compatible.
Proof. See [12]. For finitary syntax, one can use the standard Howe extension for
R→ and the dual construction for R←.	 
To prove Prop. 4.1(i), let R be divergence similarity. Then R→ is Howe-suitable over a lower simulation (viz. R), so R→0∗ is a lower simulation, and hence may- preadequate. Hence R←0, as it is contained in a preadequate relation (viz. R←∗) is

may-preadequate.
R←op  is Howe-suitable over the upper simulation Rop

, and R←

0 is may-

op ∗
preadequate, so R←0	is an upper simulation.
Since R→∗ is both a lower simulation and the opposite of an upper simulation, it is a divergence simulation, hence contained in R. By Prop. 4.5(ii), we have R◦ = R→ = R→∗. Hence R← ⊆ R←∗ = R◦ so R← = R◦. So R◦ = R→ ∩ R←, which is compatible.
The proof of Prop. 4.1(ii)–(iii) is similar.
CIU Theorem
The goal of this section is to prove Prop. 4.1(iv).
Definition 4.9 A closed relation R is closed under sequencing when
V R V ' : A implies P [V /x] RP [V '/x] for any term x : A ▶ P : B
M R M ' : B implies M to x. P R M ' to x. P for any term x : A ▶ P : B. Clearly ±⇑U is closed under sequencing.

Proposition 4.10 Let R be a closed preorder. Then R◦SC decomposes over R◦.
Proof. [6]	 
Definition 4.11 Let S be a closed relation, let A be a type and let V, V' be sets of closed values of type A. We say V S V' when ∀V ' ∈ V'. EV ∈ V. V S V '.
Definition 4.12 Let A be a type, and let N be a closed term of type A.
For a closed value W : A, we say W ±o N when for every ground term

z : A ▶ P : Σ
i∈I
1, if P [W/z] ↓ n then N to z. P ↓ n.

For a set W of closed values of type A, we say W ±  N when, for every ground

term z : A ▶ P : Σ
i∈I
1, if P [W/z] ↓  for all W ∈ W, then

N to z. P ↓ Λ∀n.(N to z. P ↓ n ⇒ EW ∈ W. P [W/z] ↓ n)
Proposition  4.13	(i) W ±  N implies N ↓ .
If N ↓ , then {W | N ↓  W } ±  N
Proof.  Trivial.	 
Definition 4.14 A closed relation R is must-preadequate when M R M ' : C, where
B is a ground type, and M ↓ , implies M ' ↓ Λ∀n.(M ' ↓ n ⇒ M ↓ n).
Proposition 4.15 Let R be a closed preorder that is closed under sequencing. Let
S be a substitutive open relation that decomposes over R.
S0 ⊆ S`; R.
Suppose that R is may-preadequate. If M ↓ V : A and M S0 M ', there exists a closed value V ' : A such that V S0 V ' and V ' ±o M '
op
Suppose that R is must-preadequate. Suppose that S0 is may-preadequate and
n S n for each closed ground value n. If M ↓  and M S0 M ', then there exists a set V' of closed values of type A such that {V | M ↓ V }S V' and V' ±  M '.
Proof.
Suppose pm ⟨V, W ⟩ as ⟨x, y⟩. M S0 N . Then there exists V ',W ',M ' such that
⟨V, W ⟩S ⟨V ',W '⟩ and M S M ' and pm ⟨V ',W '⟩ as ⟨x, y⟩. M ' RN . Then there exists V '' and W '' such that V S V '' and W S W '' and ⟨V '',W ''⟩ R ⟨V ',W '⟩.
Then, since R is closed under sequencing, we have
pm ⟨V '',W ''⟩ as ⟨x, y⟩. M ' R pm ⟨V ',W '⟩ as ⟨x, y⟩. M ' RN 
The case (rec fλx.M )V S0 N is similar to the same case in Prop. 4.3.
All the other cases are similar to these or trivial.
We proceed by induction on M ↓ V . We know that there exists M '' such that M S`M '' and M '' RM '. We show that there exists a closed value V ' : A such that V S V ' and V ' ±o M '', as follows.

Suppose that M = M0 to x. M1 and M '' = M '
to x. M '
and M0 S M '
and

M1 S M ' . We have M0 ↓ W and M1[W/x] ↓ V . By inductive hypothesis, there

exists W ' such that W S W ' and W ' ±o M ' . Hence M1[W/x] S M ' [W '/x]. By
0	1
inductive hypothesis, there exists V ' such that V S V ' and V ' ±o M ' [W '/x].

We require V ' ±o M '
Σ0
to x. M ' .
'	'	'

Given z : A ▶ P :	i∈I 1, suppose P [V /z] ↓ n. Then M1[W /x] to z. P ↓ n.

So M0 to x. (M ' to z. xP ) ↓ n. So (M '
to x. M ' ) to z. P ↓ n.

Similarly for the other cases.
We then deduce that V ' ±o M ' by may-preadequacy of R.
We proceed by induction on M ↓ . We know that there exists M '' such that
M S`M '' and M '' RM '.
Suppose M = amb i∈IMi and M '' = amb i∈IM ' and Mi S M ' for all i ∈ I. Then
i	i
there exists ˆı ∈ I such that Mˆı ↓ . By inductive hypothesis and Prop. 4.13(i)
M ' ↓ , so amb i∈IM ' ↓ , so M ' ↓ . Set V' to be {n | M ' ↓ n}. By Prop. 4.13(ii)
ˆı	i
we have V' ± M '. To show {n | M ↓ n}S V', we reason as follows. If n ∈ V' then M ' ↓ n; since M S M ' and Sop is may-preadequate, M ↓ n, and n S n by assumption.
Otherwise we proceed as follows. We first show that there exists a set V' of closed values of type A such that {V | M ↓ V }S V' and V' ±  M '', in the
following way.
Suppose that M = return W , and M '' = return W ' and W S W '. Define
V' to be {W '}, so {V | M ↓ V } = {W }S V'. Prop. 4.13(ii) tells us that

{W '} ±  return W '.
Suppose that M = M0 to x. M1 and M '' = M '

to x. M '
and M0 S M '
and

M1 S M ' . We have M0 ↓ , so there exists W' such that

{W | M ↓ W } S  W'
(1)

W' ±  M '
(2)

Write L for the set of pairs (W, W ') such that M0 ↓ W and W ' ∈ W'
and W S W '.	For each (W, W ') ∈ L, we have M1[W/x] S M ' [W '/x] and

M1[W/x] ↓ , so by the inductive hypothesis there exists a set V'
' of closed

values such that
'
{V | M1[W/x] ↓ V } S0 VW,W '	(3)

'
W,W
' ±  M ' [W '/x]	(4)

Define V' to be 
(W,W ')∈L
W,W ' .
'	'	'

We show {V | M0 to x. M1 ↓ V } S0 V as follows. If V	∈ V then there
exists (W, W ') ∈ L such that V ' ∈ V'	' . By (3), there exists V such that
M1[W/x] ↓ V and V S V '. Since M0 ↓ W , we have M0 to x. M1 ↓ V .

To show V' ±  M '
to x. M ' , suppose that z : A ▶ P : Σ
i∈I
1 is a ground

term such that P [V '/z] ↓  for all V ' ∈ V'. Define Q to be M ' to z. xP . For
any W ' ∈ W', (1) tells us that there exists W such that (W, W ') ∈ L, and for
any V ' ∈ V'	' we have P [V '/z] ↓ , so by (4) we have M ' [W 'x] to z. P ↓ ,
i.e. Q[W '/x] ↓ .
· By (2) we have M ' to x. Q ↓ . Hence M ' ↓ , and for each V ' such that M ' ↓
0	0	0
V ' we have M ' [V '/ttx] to z. P ↓ , so M ' [V '/x] ↓  and for each W ' such that
1	1
M ' ↓ W ' we have P [W '/z] ↓ . Hence M ' to x. M ' ↓ . If M ' to x. M ' ↓ W '
1	0	1	0	1

then there exists V ' such that M ' ↓ V ' and M ' [V '/x] ↓ W ', so P [W '/z] ↓ .
Hence (M ' to x. M ' ) to z. P ↓ .

· Suppose (M ' to x. M ' ) to z. P ↓ n. Then M '
to x. Q ↓ n. By (2) there

0	1	0
exists W ' ∈ W' such that Q[W '/x] ↓ n, i.e. M ' [W '/x] to z. P ↓ n. (1) tells
us that there exists W such that (W, W ') ∈ L. Since P [V '/z] ↓  for every

'	'
W,W
' , (4) tells us that there exists V ' ∈ V'
' (hence ∈ V') such that

P [V '/z] ↓ n.
The other cases are similar (but much easier).
We then deduce that V' ±  M '' by must-preadequacy of R.

We now prove Prop. 4.1(iv). We know ±⇑U ◦SC is substitutive and decomposes

over ±⇑U , which is closed under sequencing. If M ±⇑U ◦SC
M ' : C, where C is

ground, and M ↓ n, then, since ±⇑U is may-preadequate, Prop. 4.15(ii) tells us that M ' ↓ n.

op
We also know ±⇑U
SC
op
is substitutive and decomposes over ±⇑U , which is closed

under sequencing. If M ±⇑U ◦SC
M ' : C, where C is ground, and M ' ↓ , then,

op
since ±⇑U
is must-preadequate and ±⇑U
SC
0
is reflexive and (we have just shown)

may-preadequate, we obtain from Prop. 4.15(iii) that M ↓ .
Acknowledgements
I thank Soren Lassen for his helpful comments.

References
Abramsky, S., The lazy λ-calculus, in: Research topics in Functional Programming, Addison Wesley, 1990 pp. 65–117.
Carayol, Hirschkoff and Sangiorgi, On the representation of mccarthy’s amb in the pi-calculus, TCS: Theoretical Computer Science 330 (2005).
Gordon, A. D., Bisimilarity as a theory of functional programming, Theor. Comput. Sci. 228 (1999),
pp. 5–47.
Hatcliff, J. and O. Danvy, Thunks and the λ-calculus, Journal of Functional Programming 7 (1997),
pp. 303–319.
Howe, D. J., Proving congruence of bisimulation in functional programming languages, Inf. and Comp.
124 (1996).
Lassen, S., “Relational Reasoning about Functions and Nondeterminism,” Ph.D. thesis, Univ. of Aarhus (1998).
Lassen, S. B., Normal form simulation for McCarthy’s amb, Electr. Notes Theor. Comput. Sci 155
(2006), pp. 445–465.
URL http://dx.doi.org/10.1016/j.entcs.2005.11.068

Lassen, S. B. and A. K. Moran, Unique fixed point induction for McCarthy’s amb, in: Proceedings of the 24th International Symposium on Mathematical Foundations of Computer Science, ”LNCS” 1672 (1999), pp. 198–208.
Levy, P., S. Lassen and P. Panangaden, Divergence-least semantics of amb is Hoare (2005), short presentation at the APPSEM II workshop, Frauenchimsee, Germany, full version in preparation.
Levy, P. B., “Call-By-Push-Value. A Functional/Imperative Synthesis,” Semantic Struct. in Computation, Springer, 2004.


Levy, P. B., Call-by-push-value: Decomposing call-by-value and call-by-name, Higher-Order and Symbolic Computation 19 (2006), pp. 377–414.
Levy, P. B., Infinitary Howe’s method, in: Proceedings, 8th International Workshop on Coalgebraic Methods in Computer Science, Vienna, Austria, ENTCS 164(1), 2006, pp. 85–104.
Levy, P. B., Infinite trace equivalence, in: Proceedings, 21st Annual Conference in Mathematical Foundations of Computer Science, Birmingham, UK, 2005, number 155 in ENTCS, 2006, pp. 467– 496.
McCarthy, J., A basis for a mathematical theory of computation, in: P. Brafford and D. Hirschberg, editors, Computer Programming and Formal Systems, North-Holland, 1963 .
Moggi, E., Notions of computation and monads, Information and Computation 93 (1991), pp. 55–92.
Moran, A. K., Natural semantics for non-determinism, Licentiate Thesis, Chalmers University of Technology and University of G¨oteborg, Sweden (1994).
Natarajan and Cleaveland, Divergence and fair testing, in: ICALP: Annual International Colloquium on Automata, Languages and Programming, 1995.
Talcott, C., Reasoning about functions with effects, in: A. D. Gordon and A. M. Pitts, editors, Higher Order Operational Techniques in Semantics, Publications of the Newton Institute, Cambridge University Press, 1998 pp. 347–390.
