Electronic Notes in Theoretical Computer Science 121 (2005) 47–63  
www.elsevier.com/locate/entcs


Analysing Password Protocol Security Against Off-line Dictionary Attacks
Ricardo Corin1
Faculty of Computer Science, University of Twente, The Netherlands
Jeroen Doumen2
Faculty of Computer Science, University of Twente, The Netherlands
Sandro Etalle3
Faculty of Computer Science, University of Twente, The Netherlands CWI, Center for Mathematics and Computer Science Amsterdam


Abstract
We study the security of password protocols against off-line dictionary attacks. In addition to the standard adversary abilities, we also consider further cryptographic advantages given to the adversary when considering the password protocol being instantiated with particular encryption schemes. We work with the applied pi calculus of Abadi and Fournet, in which we present novel equational theories to model the (new) adversary abilities.These new abilities are crucial in the analysis of our case studies, the Encrypted Password Transmission (EPT) protocol of Halevi and Krawczyk, and the well-known Encrypted Key Exchange (EKE) of Bellovin and Merritt. In the latter, we find an attack that arises when considering the ability of distinguishing ciphertexts from random noise. We propose a modification to EKE that prevents this attack.
Keywords: Password protocols, dictionary attacks, verification, pi calculus.



1 Email: corin@cs.utwente.nl
2 Email: doumen@cs.utwente.nl
3 Email: etalle@cs.utwente.nl



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.10.007

Introduction
Due to the low entropy available in user-chosen passwords, password protocols are usually subject to off-line dictionary attacks. The attack is mounted by a passive adversary who eavesdrops protocol messages and then goes off-line to perform the password search.
Recently, there have been some attempts to deal with the formal verifica- tion of password protocols that are subject to off-line dictionary attacks [13,7,8]. These approaches are based on the usual Dolev-Yao adversary, and assume ideal or perfect encryption: ciphertexts do not leak any information to an adversary that does not have the correct key.
Unfortunately, assuming ideal encryption to analyse password protocols is not realistic, since most practical encryption schemes are far from this ideal. In practice, password protocols are designed to be secure when instantiated with a particular encryption scheme, which makes the security against dictionary attacks dependent on the chosen cryptosystem. Typically, the security of an encryption scheme is characterized by certain properties that the ciphertexts satisfy. For instance, an encryption scheme is said to be repetition concealing
[2] if an adversary cannot detect two instances of the same message encrypted with the same key (to achieve this, probabilistic [10] or stateful encryption is needed). Similarly, an encryption scheme is which-key concealing if an adversary cannot deduce if two messages are encrypted under the same key [2]. Besides these general properties, usually each particular cryptosystem has its own subtleties that can also provide useful information to an adversary. For example, a public key in RSA consisting of a pair (n, e) can be distinguished from a random string because e is odd and n contains no small prime factors. As discussed by Mellovin and Merritt [3], this simple fact allows a dictionary attack over EKE when instantiated with RSA.
In this paper, we study password protocols using the applied pi calculus [1]. Our contribution is twofold: First, we show how to analyse, in a precise formal framework, the security of password protocols when they are instantiated with particular encryption schemes, which may or may not satisfy specific proper- ties. We model (most of) these properties by extending the equational theory of the applied pi calculus. In particular, we show how to model encryption schemes which are repetition and which-key revealing, and also encryption schemes that allow an adversary to distinguish ciphertexts and public keys from random noise. Second, we study, as illustrating examples, two well- known protocols: the EPT protocol of Halevi and Krawczyk [11], and the already mentioned EKE protocol [3]. For EPT, we show that security against dictionary attacks is achieved when encryption is repetition concealing. For the EKE protocol we show that security can be established if encryption is


which-key concealing, and ciphertexts and public keys are indistinguishable from random noise. Interestingly, our analysis helped us to identify a vulner- ability of EKE that arises when ciphertexts are identifiable. To solve this, we propose a simple modification that (to the best of our knowledge) is novel.

Applied Pi Calculus
We first very briefly summarize the Applied Pi Calculus from Abadi and Fournet, borrowing from [1] (with definitions copied verbatim). The process grammar is similar to the one in the pi calculus, differing in the fact that messages can contain terms and names need not be just channel names:
P, Q, R ::= 0 | P |Q | !P | νn.P | if U = V then P else Q | u(x).P | | u⟨V ⟩.P
We will describe our term grammar and its equational theory later, in Section 2.1.
In this calculus, plain processes as defined above are extended with active substitutions {x = V }, meaning the replacement of variable x with the term
V . {x = V } can represent the situation in which a term V has been sent to the environment, but the environment may not have the atomic names that appear in V . Still, the environment can refer to V by using x.
We use the standard notions of equivalences between processes, reduction (→), structural equivalences (≡) and observational equivalence (≈) as defined in [1] (we do not define them here, due to space constraints and the fact that we will mainly use static equivalence, described below).
Frames, ranging over φ, ϕ, ... are processes built up from active substitu- tions by parallel composition and restriction. The domain dom(φ) of a frame φ are all the variables that the frame exports, ie. the variables such that
{x = V } is in φ and x is not restricted. Given a term M, we denote f n(M) as the set of free names appearing in M. Now we can define when two terms are equal in a given frame (this definition and the next one follow from [1]).
Definition 2.1 We say that two terms M and N are equal in the frame ϕ, and write (M = N)ϕ, if and only if ϕ ≡ νn˜.σ, Mσ = Nσ and {n˜}∩ (f n(M) ∪ f n(N)) = ∅ for some names n˜ and substitution σ.
Example 2.2 We borrow an example from [1]. Let f and g be two functions with no equations (they can be thought as two independent one-way func- tions). Let φ0 = νK, s.{x = K, y = s}, φ1 = νK.{x = f(K),y = g(K)}, and φ2 = νK.{x = K, y = f(K)}. In φ0, x and y are unrelated, and hence they cannot be distinguished by any pair of terms M and N. The same happens in φ1. However, in φ2, x and y are related: y is obtained from x by apply- ing f. More formally, let M = f(x) and N = y. Then (M = N)φ2 but not (M = N)φi for i ∈ [0, 1].

The example motivates the definition of static equivalence ≈s:
Definition 2.3 We say that two closed (i.e. with no free variables) frames ϕ and ψ are statically equivalent, and write ϕ ≈s ψ, when dom(ϕ)= dom(ψ) and when, for all terms M and N, we have (M = N)ϕ if and only if (M = N)ψ.
Given two closed extended processes A and B, we can “extract” their frames φ(A) and φ(B), by replacing every plain subprocess of A and B with
0. We then say that two closed extended processes are statically equivalent, and write A ≈s B, when their frames are statically equivalent. We quote a useful lemma from [1].
Lemma 2.4 [1].
Observational equivalence and static equivalence coincide on frames. Ob- servational equivalence is strictly ﬁner than static equivalence on extended processes: ≈⊂≈s.
Static equivalence is closed under reduction and structural equivalence.
Now we are ready to instantiate the calculus with our term grammar and equational theory.

Equational Theories for the Applied Pi Calculus
In this section we first instantiate the applied pi calculus with our term gram- mar. Then, we present the equational theory EQ0 that represents the standard adversary abilities. Afterwards, we extend EQ0 with EQ1 and EQ2, two equa- tional theories that provide further adversary abilities. Our grammar for terms is shown in Table 1 (left).
Besides names and variables, we have the usual pairing constructor, along with its projections. Given a name K representing a private key (and thus usually appearing restricted) we can derive a public-key pk(K) that can then be used for (public key) encryption 4 . We also define the usual hash construc- tor. Our constructors for encryption (both symmetric and asymmetric) take a name r as randomness parameter. This allows us to model probabilistic encryption. By explicitly considering the randomness parameter as a name, say r, we can model easily repetition concealing vs. revealing cryptosystems by simply restricting or not r (This modelling was already suggested in [1]). On the other hand, decryption is deterministic.

4 However, note that in general it may be not possible to obtain the public key from a previously created private key: Typically, the key pair is created simultaneously. Thus, when a private key K is created using restriction ν, we assume that the corresponding public key is also created. Then, the constructor pk(K) is just a pointer to this public key.




Table 1
Grammar for terms (top). Equational theory EQ0 (bottom).

The standard equational theory EQ0 is shown 5 in Table 1 (right). In EQ0 we encode all the standard abilities of the adversary, given by decryption identities and pair projection. Here, pk(·) and hash(·) are modelled as non- reversible operations by implicitly not adding any ability in EQ0.
Under the standard equational theory EQ0, non-deterministic encryption behaves as a “secure envelope”, modelling a repetition concealing cryptosys- tem. Let us illustrate the practical implications of this with one example.
Consider P (M) =.  νr, K.{x = penc (M, pk(K)),y = pk(K)}. Process P (M)
r
exports (in x) the encryption of M with pk(K), and also exports (in y) the
used public key. Now, the property of “secure envelope” can be stated as
∀M : P (M) ≈s νs, k.{x = s, y = k}, which intuitively holds since r is an

5 Excluding all the equations obtained from reflexivity, symmetry, transitivity and substi- tution of terms for the variables x, y and r.


unguessable seed. This expresses that the resulting ciphertext of encrypting a message M with a public key derived from K is indistinguishable from ran- dom “noise” (analogously for the public key derived from K). Notice that this holds even if M is possibly known (or guessable) by the environment.
However, one could argue that this approach models a too strong, often unrealistic encryption mechanism, in at least three ways:
(A1) First, in particular cryptosystems, it can be the case that ciphertexts are distinguishable from pure random noise, even though the plaintext or encrypting key is not leaked. For example, a usual indication of the presence of a ciphertext can be found in the length of the messages (this can happen, for example, when padding is weak or non-existent). In block ciphers, for instance, ciphertexts typically consist of a certain number of blocks (e.g. a multiple of 128/256 bits). Similarly, numbers close to each other in RSA also give a good indication of a ciphertext. As another example, in the McEliece cryptosystem [15] every ciphertext is a codeword, with a small vector error added to it. This makes ciphertexts distinguishable from random noise.
(A2) Second, and similar to item 1 above, public keys can also be distinguish- able from random noise, even if the private key is kept secret. As an example (already mentioned in the introduction), a public key in RSA consists of two large naturals n and e, where e is always odd and n does not contain small prime factors.
(A3) Finally, encryption could be which-key revealing, allowing an adversary not only to detect ciphertexts (as in item 1 above) but also to deduce if two ciphertexts were encrypted under the same key.

Cryptography and the Equational theory
To study the security of protocols under these more realistic scenarios, we first need to model (A1), (A2) and (A3) as adversary abilities. We achieve this with the equational theories of Table 2.
In EQ1, we model the ability of an adversary to distinguish ciphertexts and public keys from regular messages: sym ciphertext detects ciphertexts created with symmetric encryption, while pk ciphertext recognizes public-key ciphertexts. Similarly, valid pk detects public keys. Now, EQ0∪ EQ1 models an adversary whose abilities include (A1) and (A2).
In EQ2, we add the ability to deduce whether two messages are encrypted under the same key (with equality same k.), modelling (A3).
When the equational theory is EQ0∪ EQ1∪ EQ2, the secure envelope prop- erty does not hold any more: x can be detected by pk ciphertext, y by valid pk


Table 2
Extended equational theories: EQ1 (top). EQ2 (bottom).
and finally x and y in conjunction can be recognized by same k. However, a weaker form of a “secure envelope” still holds, namely 6M, M ' : P (M) ≈s P (M '), which states that even though an adversary can recognize a ciphertext pencr (·, pk(K)) and its encrypting public key pk(K), the adversary can still not glean any information about the plaintext M. Thus, this weaker notion of secure envelope is reduced to express secrecy of M.
Modelling Dictionary Attacks
In an off-line dictionary attack, the adversary guesses the (weak) shared pass- word and then tries to verify the guess with the eavesdropped session [13]. Thus, we can regard a protocol as secure if it provides no such verification possibility to the adversary. As we already mentioned, in the applied pi calcu- lus the information gathered by the adversary can be characterized by using frames. Let the frame ϕ represent the information of an eavesdropped ses- sion and let K be the shared, weak password (K is free in ϕ, representing the fact that K can be “guessed” by the adversary). Then, we can represent the notion of security of a password protocol against dictionary attacks by checking whether the adversary can distinguish ϕ from νK.ϕ, in which K is bound, representing unguessability. More precisely, by “seeing” we use static equivalence (≈s), as defined in Definition 2.3.
Definition 2.5 Let φ be a frame in which K is free. Then we say that φ verifies a guess of K if φ /≈s νK.φ. Conversely, we say that φ is secure w.r.t. K if φ ≈s νK.φ.
Intuitively, a distinction of ϕ and νK.ϕ models the situation in which the adversary “hits” the correct guess, and he can verify that fact by using ϕ. On the other hand, if ϕ and νK.ϕ are indistinguishable, then an adversary has no way of verifying from ϕ that a given word (from e.g. a dictionary) is actually the correct password.
For example, if φ = νNa.{x = (Na, K)}, then νK.φ /≈s φ. Intuitively, this


follows from the fact that K is free (guessable!) in φ, and thus can be used in a term to distinguish x from random noise. To see this formally, we let M = snd(x) and N = K. Then (M = N)φ but not (M = N)νK.φ. On the other hand, if φ = νNa.{x = sencr(Na, K)} then νK.φ ≈s φ. To see the (⇒) of this claim is easy; we show the converse. Let M and N be such (M = N)φ. Intuitively, we need to see that using K does not help in the equality of M and N in φ. We can assume that Na does not occur in M or N (because anyway we can rewrite Na to Na' in φ, by alpha conversion). The only case in which M and N can use K in φ is by decrypting x; for example, M = sdec(x, K). But in this case N cannot be Na, and so for (M = N)φ to hold we must set N = M = sdec(x, K). But this implies that (M = N)νK.φ also, by alpha converting K (to some suitable K') in φ.
We then obtain the following result:
Proposition 2.6 Consider a process P, and suppose that K is free in φ(P ). Suppose also that P →∗≡ P '. If φ(P ) veriﬁes K, then φ(P ') veriﬁes K. Also, if φ(P ') is secure w.r.t. to K, then φ(P ) is secure w.r.t. to K.
The proposition follows from the fact that static equivalence is closed under reduction and structural equivalence, Lemma 2.4 (2).
Now we are ready to proceed to our case studies.

Encrypted Password Transmission (EPT) protocol
In this section we study the Encrypted Password Transmission (EPT) protocol [11]. We first present the protocol, then translate it into the calculus and finally analyse the security against dictionary attacks.
EPT is designed to be run between a server S and a user U . We assume that S and U share a weak password P , and that the server S has a strong public-private key pair. Also, U has stored a hash of S’s public key, which has been previously securely communicated. The goal of the protocol is to authenticate U to S:
S → U : (N, pk(KS))	(EPT.1)
U → S : pencr ((N, P ), pk(KS))	(EPT.2)
The protocol proceeds as follows: First, the server sends in the clear to the user a message consisting of a random challenge (“nonce”) N and his public key pk(KS) (EPT.1). Then, the user checks that the received public key, when hashed, matches with his own (stored) hashed copy of the key. If it does not, then the user aborts. Otherwise, the user answers by encrypting a pair of N and P with the server’s public key (EPT.2).

Translation in the calculus
First, we translate the user and server into appropriate processes. Let cSU be a channel name for communication from S to U and cUS a channel for communication from U to S. By keeping cij free in the processes U and S, we allow adversaries (i.e. the environment) can eavesdrop on these channels. We define S as:


S =.
νKS, N.	(cSU
⟨(N, pk(KS
))⟩ . cUS
(y).

if ((N, P )= pdec(y, KS)) then PS) | {pks = pk(KS)}
Process PS models what happens after the session was established success- fully. Note how the public key pk(KS) is exported in variable pks. We assume that none of the values used during the protocol appear in PS, and also that PS never discloses KS. If the decryption fails, then the process would abort (executing the implicit 0 of the else branch). The user process U is:


U =.
νr.	( cSU (x). if (hash(snd(x)) = hash(pks)) then
cUS⟨pencr ((fst(x),P ), snd(x)⟩.PU )

Similarly, PU is the process that the user executes after successful execution of the protocol (again, no value of the protocol appears in PU ). Now, a system of one user and one server can be setup by letting them share a password P : νP.(U | S). A normal execution of this process can now be modelled by applying reductions and equivalences, as in [1]:
νP.(U | S) →→≡ (PS | PU | νP, KS, N, r.ϕ)

ϕ =.
{x = (N, pk(KS)),y = pencr ((fst(x),P ), snd(x)), pks = pk(KS)}

The first two reductions come from the message communications (EPT.1) and (EPT.2), and the last equivalence corresponds to scope tightenings. More- over, by structural equivalence we can rewrite ϕ and obtain:
ϕ ≡ {x = (N, pk(KS)),y = pencr ((N, P ), pk(KS)), pks = pk(KS)}

Intuitively, ϕ (along with its restrictions) represents the information that the environment has learnt from eavesdropping a run of EPT between a user U and a server S.
Next, we study whether the information recorded in ϕ can be exploited to mount an off-line dictionary attack.
Thanks to the second part of Proposition 2.6, if we can regard ϕ secure

w.r.t. to P , then we can be sure that every other earlier frame is also secure
w.r.t. to KS.

Security against dictionary attacks
The following lemma states that EPT is secure, in the sense that it does not provide a verification of a guess of a password to an adversary. To model this, we let P be guessable by removing it from the restriction, and then compare the result to the case in which it is still restricted, as in our formalization of guessing attacks in Definition 2.5:
Lemma 3.1 Let PS and PU be processes where the names P, KS,N and r do not appear free. Then:
(PS | PU ) | νP, KS, N, r.ϕ ≈ (PS | PU ) | νKS, N, r.ϕ	(3)
Proof. We first establish:
νP, KS, N, r.ϕ ≈s νKS, N, r.ϕ	(4)
The case (⇒) is straightforward, so we show the converse. Let M and N be terms s.t. (M = N)νKS, N, r.ϕ. We first note that KS is not obtainable from φ, since constructor pk(·) has no inverse in the equational theory. If P does not occur in M or N, then it is easy to obtain the claim. Suppose now P does occur in M or N. Since the private key KS is not obtainable from φ, then y in φ can not be decrypted; then P can only be used in M or N to encrypt a term similar to y. But this is impossible since r is restricted in y, and we then obtain that (M = N)νP, KS, N, r.ϕ, which establishes (4). Note that this holds even when we consider as equational theory our most powerful adversary, with EQ0 ∪ EQ1 ∪ EQ2.
Finally, by Lemma 2.4 (1), we lift the result to observational equivalence (≈).	 
Intuitively, the lemma follows from the fact that r is an unguessable, freshly generated seed, and then environment can never distinguish y in ϕ from noise. While proving this lemma, the main cryptographic requirement of the pro- tocol w.r.t. its underlying encryption is uncovered: it must be repetition con- cealing. Discovering an attack in the case of repetition revealing (and thus deterministic) encryption is not difficult. To model deterministic encryption, we remove r from the restriction operator, thus letting the environment con- trol it. So, let φ0 be νP, KS, N.ϕ and φ1 be νKS, N.ϕ. Then, φ0 /≈s φ1. Let M1 = y and M2 = pencr ((fst(x),P ), snd(x)). Then, (M1 = M2)φ1 but not


(M1 = M2)φ0. Thus, when encryption is not repetition concealing the proto- col is not secure. This is in accordance with [11], where encryption is asked to be semantically secure [10] 6 .
The underlying encryption does not have to be which-key concealing to establish the security of EPT. In fact, all the abilities introduced by EQ1 and EQ2 do not affect (3). This makes EPT a robust protocol. Interestingly, in the next protocol we analyse (the EKE protocol), the requirements are the other way around: repetition concealing turns out to be irrelevant, while the feature of being which-key concealing is crucial to establish security against dictionary attacks.

Encrypted Key Exchange (EKE) protocol
In this section we analyse the Encrypted Key Exchange protocol, presented in [3]. The EKE protocol is designed to solve the problem of authenticated key exchange while being resistant against dictionary attacks.
Differently from the EPT protocol studied in the previous section, which required U to have a stored hashed copy of the server’s public key, EKE is a password-only protocol, which assumes only a weak shared password in common. The protocol can be described as follows:
A → B : sencr(pk(K),P )	(EKE.1)
B → A : sencs(penct(R, pk(K)),P )	(EKE.2)
A → B : sencu(NA, R)	(EKE.3)
B → A : sencv((NA, NB), R)	(EKE.4)
A → B : sencw(NB, R)	(EKE.5)
First, A generates a new private key K, and then derives the public key pk(K). Then, A encrypts pk(K) with the shared password P and sends it to B (EKE.1). Then, B extracts pk(K), generates a fresh session key R and encrypts it with pk(K). Then, B encrypts again the resulting message with P and sends it to A (EKE.2). The following three messages (EKE.i), i = 3, 4, 5, exchange nonces NA and NB to perform the “hand-shaking” necessary to defend against replay attacks.

Translation in the calculus
The user process A can be defined as:

6 In fact, in [11] a stronger notion of security is required, necessary to resist active adver- saries. We do not need that here, since we are dealing with passive adversaries only.



A =.
νK, r.(c
⟨senc (pk(K),P )⟩ . c	(x ).(νk.({k = sdec(pdec(x , K),P )}

AB	r	BA	1	1
| (νu, NA.cAB⟨sencu(NA, k)⟩ . cBA(x2) .
if (NA = fst(sdec(x2, k))) then νw.cAB⟨sencw(snd(sdec(x2, k)), k)⟩.PA)
Process PA is executed after the successful execution of the protocol. We assume that none of the values introduced by the protocol appear in PA, except for the exchanged session key (represented as free variable k in PA.) Similarly, the user process B is defined as follows:


B =.
(cAB(y1) . νs, t, R.cBA⟨sencs(penct(R, sdec(y1,P )),P )⟩
. cAB(y2) | νv, NB.cBA⟨sencv((sdec(y2, R), NB), R)⟩
. cAB(y3). if (NB = sdec(y3, R)) then PB)

Here, we ask the same restrictions for PB that we asked for PA. Similarly to the EPT protocol, we set up a session νP.(A | B). Now, this protocol reduces
to νP.(A | B) →5≡≡ νk.(PA | PB | ϕ), where ϕ = νP, K, NA, NB, R, r, s, t, u, v, w.ϕ0, with:

ϕ =. {	y = senc (pk(K),P ),x 
= senc (penc (R, sdec(y ,P )),P ),

1	r
s	t	1

y2 = sencu(NA, k), x2 = sencv((sdec(y2, R), NB), R) y3 = sencw(snd(sdec(x2, k))) }
The five above reductions correspond to the messages exchanges (EKE.i), i = 1, 2, 3, 4, 5. The last two equivalences correspond to scope tightenings plus scope extrusion of k. Finally, ϕ0 can be shown equivalent to:
ϕ0 ≡{	k = R, y1 = sencr(pk(K),P ),
x1 = sencs(penct(R, pk(K)),P ), y2 = sencu(NA, R),
x2 = sencv((NA, NB), R), y3 = sencw(NB, R)}

Analysis of EKE
Consider the frame ϕP = νP, K, NA, NB, R, r, s, t, u, v, w.ϕ0. Here, ϕP − is the same as ϕP but without P being restricted. Our analysis against dictionary attacks can be carried out by relating ϕP to ϕP − by static equivalence. By lifting the restriction on same names and by adding equational theories (EQ1 and EQ2) to the framework, we can analyze a range of different scenarios. We first start by weakening the underlying encryption and consider EKE be-


ing instantiated with a repetition revealing cryptosystem (although we still consider only standard abilities EQ0.)
Repetition Concealing. An interesting fact to note in EKE is that security does not really depend on whether encryption is repetition concealing or not. To see this, consider the frame φP = νP, K, NA, NB, R, k.ϕ0 and similarly φP − = νK, NA, NB, R, k.ϕ0. Frames φP and φP − are the same frames as ϕP and ϕP − respectively but with the randomness values (r, s, t, u, v and w) being “guessable”. This models an encryption scheme that is not repetition concealing, since now the adversary controls the seeds and thus can detect repetitions of same messages. However, the following lemma states that this extra information cannot be exploited by the adversary. If the adversary can distinguish φP and φP − where the seeds are known, then she could also distinguish ϕP and ϕP − where the seeds are unguessable.
Lemma 4.1 φP ≈s φP − iff ϕP ≈s ϕP − .
The lemma holds since letting the adversary have the seeds r, s, t, u, v and w never helps in the task of distinguishing xi nor yj, for i = 1, 2 and j = 1, 2, 3. Having r does not help to recognize y1, since pk(K) is indistinguishable from random noise when K is private (However this is not true anymore when considering EQ1, as explained below.) Having s and t does not help to recognize x1, since now R is random. The remaining cases are similar (for x2, y2 and y3.) Then, we obtain that ϕP ≈s φP and ϕP − ≈s φP − , which then allow us to conclude that φP ≈s φP − iff ϕP ≈s ϕP − .
While establishing the lemma, we see two cryptographic requirements of EKE:
Encryption may be repetition revealing since R is strong. In other words, it must be difficult to compromise R by brute-force attacking y2, x2 and y3 when encryption is repetition revealing, since otherwise x1 could be distinguished from noise (and thus ϕP /≈s ϕP −.)
K must not be used more than once. This can be an important deficiency of EKE, since generation of new keys can sometimes be expensive. In fact, this is where the later protocol OKE [14] improves on EKE. To model a key K used twice, we represent two sessions sharing the same K: Let ϕK,P

be νK, P.(νR, NA, NB.ϕ0 | νR',N' ,N' .ϕ' ) where ϕ'
is analogous to ϕ0.

A	B	0
0
'	'	'	'

Similarly, let ϕK,P − be νK.(νR, NA, NB.ϕ0 | νR , NA, NB .ϕ0) where P is
guessable. Now, ϕK,P /≈s ϕK,P − since the environment can distinguish them by comparing sdec(y1,P ) and sdec(y' ,P ).
Which-key Concealing. Now we consider the possibility of an adversary to recognize under which key is a message encrypted. To model this, we consider

as our equational theory EQ0 ∪ EQ2.
We want to see if, under a cryptosystem that is not which-key concealing, ϕP ≈s ϕP − . By Lemma 4.1, it suffices to show that φP ≈s φP − . However, this is not the case, and actually we can see that φP /≈s φP − . Let M = sdec(x1,P ) and N = pencw (x, sdec(y1,P )). Then, (same k(M, N) = true)φP − but not (same k(M, N)= true)φP .
Identifying public keys. While showing Lemma 4.1, we used the argument that pk(K) is indistinguishable from random noise when K is restricted and thus unguessable. If we consider EQ0∪EQ1 as our equational theory, this does not hold anymore. Intuitively, if an adversary is able to tell whether a public key is valid or not, an adversary could compare many eavesdropped sessions (with many messages (EKE.1)) and narrow the password space considerably, therefore mounting a successful attack over P . The attack is exposed in our setting since when we add EQ1, we see immediately that ϕP /≈s ϕP − , simply by noticing that decrypting message (EKE.1) returns a valid public key: Let M = valid pk(sdec(y1,P )) and N = true. Then (M = N)φP but not (M = N)φP − .
Identifying ciphertexts. When we consider EQ1, we can also distinguish ciphertexts. Then, a possible attack (similar to the one presented above on (EKE.1)) can be mounted on (EKE.2). Here, decrypting (EKE.2) with a good guess returns a valid ciphertext that pk ciphertext can recognize, thus allowing an attack. However, we propose to change (EKE.2) to:
B → A : pencs(senct(R, P ), pk(K))	(EKE’.2)
Now, message (EKE’.2) does not provide any verification of a guess of P , since the fact that pk ciphertext can recognize (EKE’.2) is now irrelevant if K is secret. Thus, the above attack is prevented. To the best of our knowledge, this modification to EKE has not been proposed before.
Security against dictionary attacks. If we consider only EQ0, that is, we as- sume that encryption is which-key concealing and public keys and ciphertexts are not recognizable, then we can state the security of EKE against dictionary attacks. The next theorem shows that the established key session is a secure key, i.e. an adversary cannot discover it by only overhearing the messages ex-
changed during the execution of the protocol. Let ϕ' − be νq, r, s, t, u, v, w.ϕ' ,
'	'  .	P	0
where ϕ0 is ϕ0 = {y1 = sencq(r, P ), x1 = sencs(t, P ), y2 = u, x2 = v, y3 = w}.
Then, we relate νk.(PA | PB | ϕP ), the message exchanges in EKE, with
νR.((PA | PB){k = R} | ϕ' − ), in which P is made guessable but encrypting
random values r and t.
Theorem 4.2 Let PA and PB be processes with free variable k where R does not appear. Then, νk.(PA | PB | ϕP ) ≈ νR.((PA | PB){k = R} | ϕ' − ).


Proof Sketch. Thanks to Lemma 4.1, it suffices to show that φ ≈s φP −, which can be established by case analysis over the messages of ϕP as in Lemma
'	'
4.1. Then, we can see that ϕP − ≈s ϕP − to conclude that ϕP ≈s ϕP − . To
obtain the desired observational equivalence we apply Lemma 2.3.
Intuitively, Theorem 4.2 says that EKE gives no verification of a guess of P , and furthermore the session key k between PA and PB is indistinguishable from random noise to an adversary represented by the environment.

Conclusions
In this paper we have studied the security of password protocols against off-line dictionary attacks, using the applied pi calculus. We argue that considering a standard adversary with the usual restricted abilities (represented in our approach by the equational theory EQ0), is not realistic enough to analyse thoroughly the security of password protocols. To this end, we have intro- duced two further equational theories EQ1 and EQ2, that model additional adversary abilities. The latter ability, namely which-key revealing, was al- ready considered in [9], where the presence of such an ability would spoil immediately the privacy guarantees of the protocol. In this paper, we allow EQ2 to enter the scene explicitly, and study whether its presence allows or not a dictionary attack. We also introduced the equational theory EQ1, that models the ability of an adversary to distinguish ciphertexts and public keys from random noise. To the best of our knowledge, we do not know of other formal approach for security protocol analysis that considered such an adver- sary ability. We also considered the ability in which an adversary can detect repetition of same messages.
These non-standard abilities turned out to be crucial to decide the security of our case studies, EPT and EKE protocols. Moreover, we believe that our analysis helps to identify which are the precise cryptographic assumptions that a protocol needs to rely on. For example, as we illustrated with the analysis of EKE, a protocol designer can decide whether to strengthen the underlying encryption or to require stronger key session and nonces, but asking for both may be unnecessary. Furthermore, our technique allows one to spot possible sources of confusions and possible attacks. In particular, for EKE instantiated with an encryption scheme in which ciphertexts can be distinguished from random noise (i.e. EQ1), we found a new vulnerability. To solve this, we have proposed a simple modification (i.e. to change the order of encryption in (EKE.2) to (EKE’.2)) that prevents this attack.
As future work we plan to analyse the challenging problem of analysing security of password protocols subject to dictionary attacks in the presence


of active adversaries. Another possible venue is to apply our technique to study the rich field of (later) proposed password protocols (e.g., the protocols proposed in [14,6,12].)
Recently, Blanchet proposed an extension to the tool Proverif [4] to prove (automatically) strong secrecy for security protocols [5]. Indeed, their (inde- pendently developed) notion of strong secrecy, presented in Definition 2 of [5], generalizes our Definition 2.5. Thus, it would be interesting to validate the (manual) proofs presented in this paper using Blanchet’s technique.
Acknowledgements. We would like to thank Pieter Hartel and the anony- mous reviewers for helpful comments. We would also like to thank Jonathan Herzog for mentioning a helpful comment that lead to this work. This work was carried out in the context of the LicenseScript project, supported by the Telematica Instituut.

References
M. Abadi and C. Fournet. Mobile values, new names, and secure communication. In Proceedings of the 28th ACM Symposium on Principles of Programming Languages (POPL’01), pages 104–115. ACM, January 2001.
M. Abadi and P. Rogaway. Reconciling two views of cryptography (the computational soundness of formal encryption). In Journal of Cryptology, number 15, pages 103–127. Springer, 2000.
S. Bellovin and M. Merritt. Encrypted key exchange: Password-based protocols secure against dictionary attacks. In IEEE Symposium on Security and Privacy, pages 72–84. IEEE Computer Society, May 1992.
B. Blanchet. An efficient cryptographic protocol verifier based on Prolog rules. In 14th IEEE Computer Security Foundations Workshop (CSFW-14), pages 82–96. IEEE Computer Society, 2001.
Bruno Blanchet. Automatic Proof of Strong Secrecy for Security Protocols. In IEEE Symposium on Security and Privacy, pages 86–100, Oakland, California, May 2004.
V. Boyko, P. MacKenzie, and S. Patel. Provably secure password-authenticated key exchange using Diffie-Hellman. LNCS, 1807:156–171, 2000.
R. Corin, S. Malladi, J. Alves-Foss, and S. Etalle. Guess what? here is a new tool that finds some new guessing attacks (extended abstract). In R. Gorrieri and R. Lucchi, editors, IFIP WG 1.7 and ACM SIGPLAN Workshop on Issues in the Theory of Security (WITS), pages 62–71, Warsaw, Poland, Apr 2003. Dipartamento di Scienze dell’Informazione Universita di Bologna, Italy.
S. Delaune. Intruder deduction problem in presence of guessing attacks. In Proc. Workshop on Security Protocols Veriﬁcation (SPV’2003), Marseille, France, Sep. 2003, pages 26–30, 2003.
C. Fournet and M. Abadi. Hiding names: Private authentication in the applied pi calculus. volume 2609 of LNCS, pages 317–338. Springer, January 2003.
S. Goldwasser and S. Micali. Probabilistic encryption. Journal of Computer and System Sciences, 28:270–299, 1984.
S. Halevi and H. Krawczyk. Public-key cryptography and password protocols. ACM Transactions on Information and System Security, 2(3):25–60, 1999.


J. Katz, R. Ostrovsky, and M. Yung. Forward secrecy in password-only key exchange protocols. volume 2576, pages 29 – 44. Springer, January 2003.
G. Lowe. Analyzing protocols subject to guessing attacks. Workshop on Issues in the Theory of Security (WITS’02), January 2002.
S. Lucks. Open key exchange: How to defeat dictionary attacks without encrypting public keys. In Security Protocols, 5th International Workshop, volume 1361 of LNCS, pages 79–90. Springer, April 1997.
R.J. McEliece. A public–key cryptosystem based on algebraic coding theory. In DSN Progress Report 42–44, pages 114–116. Jet Propulsion Laboratory, Pasadena, 1978.
