

Electronic Notes in Theoretical Computer Science 237 (2009) 107–125
www.elsevier.com/locate/entcs

Strategy-Based Rewrite Semantics for Membrane Systems Preserves Maximal Concurrency of Evolution Rule Actions
Dorel Lucanu1,2
Faculty of Computer Science, Alexandru Ioan Cuza University, Ia¸si, Romania

Abstract
We use a modal logic in order to show that the strategy-based rewrite semantics for membrane systems fully preserves the maximal concurrency of evolution rules actions, whereas the maximal concurrency of communication actions and structural actions is partially preserved. Consequently, the strategy-based rewrite semantics describes more faithfully the behavior of the membrane systems than the rewrite logic- based semantics. It is known that the rewrite logic-based semantics implements the maximal concurrency of the evolution rules in membrane systems only by interleaving concurrency. The concurrency degrees of the communication and structural actions are the same for the two rewrite-based semantics.
Keywords: Rewrite Strategies, Strategy Controller, Membrane System, Modal logic, True Concurrency, Rewrite Logic.


Introduction
Membrane computing [18] deals with distributed and parallel computing models inspired from the structure and the functioning of living cells, as well as from the way the cells are organized. Such a model processes multisets of symbol-objects in a localized manner. The locality of processing refers to the fact that the evolution rules and evolving objects are encapsulated into compartments delimited by mem- branes. An essential role is also played by the communication among compartments and, possibly, with the environment.
There are several approaches [3,1] which describe a rewrite semantics based on rewriting logic (RWL) [15,16]. Even if the use of RWL framework seems to be a natural choice for specifying and analyzing membrane systems, the locality of evo- lution rules and the higher degree of the concurrency given by the maximal parallel

1 This work is partially supported by the PN II grant ID 393/2007 and CNCSIS 1162/2008.
2 Email: dlucanu@info.uaic.ro

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.03.038

rewriting (used in defining the behavior of these systems) is quite challenging. An alternative approach based on rewrite strategies and strategy controllers is given in [4]. The main idea is to separate the implementation of the control mechanisms of regions from the effective application of the evolution rules.
In [13] we show that RWL-based semantics can describe the maximal parallel rewriting of the membrane systems only by interleaving semantics. In this paper we show that the strategy-based rewrite semantics defined in [4] preserves the maximal concurrency expressed by the maximal parallel application of the evolution rules. The concurrency degree of the communications and structural actions is the same in the RWL-based semantics and strategy-based rewrite semantics. Since the two for- malisms, membrane systems and strategy-based rewriting logic, are quite different, we use a simple modal logic as a common language for comparing the concurrency degrees of the two formalisms.
The paper is structured as follows. Section 2 briefly presents the membrane systems and rewriting logic. In Section 3 a Hennessy-Milner-like modal logic for membrane systems is introduced. Section 4 briefly recalls from [4] the strategy- based rewrite semantics for membrane systems. It further includes an algorithm computing strategies for communications and dissolvings with the highest concur- rency degree. Section 5 includes the main results of the paper. The concurrency degree of an evolution step of a membrane system is compared with that of its implementation as a strategic rewrite using the modal logic introduced in Section
3. The paper ends with some concluding remarks.
Acknowledgments: The author would like to thank the anonymous referees for their useful remarks and comments and to C. Croitoru for the helpful discussions regarding edge coloring problem for bipartite graphs.

Preliminaries
Membrane systems
In this paper we consider a particular case of membrane systems, namely that known as transition P systems [18]. Informally, a transition P system consists of: an alphabet of objects (usually a finite non-empty alphabet of symbols identifying the real objects), the membrane (region) structure (it can be represented in many ways, but the most used one is by a string of labeled matching parentheses), the multisets of objects present in each membrane of the system (represented in the most compact way by strings of symbol-objects), the sets of evolution rules as- sociated with each region, as well as the indication about the way the output is defined (see, e.g., Figure 1). A membrane structure is a hierarchically arranged set of membranes, contained in a distinguished external membrane called the skin membrane. Several membranes can be placed inside a membrane; a membrane is called elementary if it has no other membrane inside it. Each membrane determines a compartment, also called region, the space delimited from above by it and from below by the membranes placed directly inside, if any exists. Clearly, the correspon-

,		 


r11 : c → (a, here)(b, out) r12 : b → (c, here)
r21 : a → (b, here)(c, inM1 )
r22 : b → (a, here)



bbc
1
abb
J	M2	J

Fig. 1. A P system with two membranes
dence membrane-region is one-to-one, that is why we sometimes use interchangeably these terms. The hierarchical structure of membranes is a rooted tree symbolically represented as a string of labeled matching parentheses. The evolution rules have the form r : u → v or r : u → vδ, with u a non-empty multiset over O, v a mul- tiset over O × Tar , where Tar = {here, out}∪ {inj | 1 ≤ j ≤ m}, and δ a special object called dissolving action. The elements of Tar are called target indications and have the following meaning: an object having associated the indication here remains in the same region, one having associated the indication inj goes immedi- ately into the directly lower membrane j, and out indicates that the object has to exit the membrane, thus becoming an element of the region surrounding it. Note that the set Tar is depending on the number of the membranes in the system. A pair (a, tar ) ∈ O × Tar is often called message. A rule r : u → v can be cooperative (with u arbitrary), non-cooperative (with u ∈ O \ C), or catalytic (of the form ca → (c, here)v or ca → (c, here)vδ, with a ∈ O \ C, c ∈ C, and v a multiset over (O \ C) × Tar ); note that the catalysts never evolve and never change the region, they only help the other objects to evolve.
In this paper we associate a distinguished name Mj to each membrane j and the name Mj and the index j are used interchangeably.
Formally, a transition P system (of degree m) is a construct of the form Π = (O, C, μ, w1, w2,..., wm, R1, R2,..., Rm, i0), where:
O is the (finite and non-empty) alphabet of objects,
C ⊆ O is the set of catalysts,
μ is a membrane structure, consisting of m membranes, labeled with 1, 2,..., m; one says that the membrane structure, and hence the system, is of degree m,
w1, w2,..., wm are multisets over O representing the multisets of objects present in the regions 1, 2,...,m of the membrane structure (contents ),
R1, R2,..., Rm are finite sets of evolution rules associated with the regions 1, 2,...,m of the membrane structure,
i0 is either one of the labels 1, 2,..., m, and then the respective region is the output region of the system, or it is 0, and then the result of a computation is collected in the environment of the system.
A conﬁguration (μ, w1,..., wm) consists of the membrane structure μ of degree m and the multisets wi of objects/messages from its compartments. During the evolution of the system, both the multisets of objects/messages and the membrane

,		 


r11 : c → (a, here)(b, out) r12 : b → (c, here)
mpr
bbc
1
r21 : a → (b, here)(c, inM1 )
r22 : b → (a, here)
mpr
abb
J	M2	J

Fig. 2. A P system with control mechanisms
structure can change. For instance, the configuration of the system represented in Figure 1 is ([[]1]2, bbc, aab). We represent the multisets as (commutative) strings.
The contents of the membranes evolve by means of evolution rules. In each time unit a transformation of a configuration of the system, called evolution step, takes place by applying the rules in each region, in a non-deterministic and maximally parallel manner. An evolution step in a given region (membrane) consists in 1) ﬁnding a maximal applicable multiset of evolution rules, removing from the region all objects specified in the left hand sides of the chosen rules (with the multiplicities as indicated by the rules and by the number of times each rule is used), producing the messages from the right hand sides of rules, and then 2) distributing the objects from these messages as indicated by their target component. If at least one of the rules introduces the dissolving action δ, then 3) the membrane is dissolved, and its content becomes part of the immediately upper membrane, provided that this membrane was not dissolved at the same time, a case where we stop in the first upper membrane which was not dissolved (at least the skin remains intact). The rules of the dissolved membranes are lost.
There are many extensions of transitional P systems, among which we mention here the use of priority relation over the evolution rules, the use of promoters and inhibitors, the non-deterministic choice of the in target. The reader is invited to see
[18] for a detailed presentation. We associate to each membrane a control mechanism specifying its particular way to evolve (see, e.g., Figure 2). Different membranes of a system may have different control mechanisms. For the sake of presentation, in this paper we consider only the mechanism mpr given by the maximal parallel rewriting, where a maximal applicable multiset of evolution rules is used at each evolution step. The approach can be applied for other mechanisms, as well.
We briefly recall some notations regarding the formal operational semantics of membrane systems:
semantics of the control mechanisms: w →M w' whenever w' is obtained from w by applying the evolution rules of M according to the control mechanism of M . For instance, since the control of M1 is maximal parallel rewriting (mpr), we have bbc →M1 (c, here)(c, here)(a, here)(b, out ), applying in parallel twice r12 and once r11. Note that w is a multiset of objects and w' is a mixed multiset of objects and messages.
semantics of the evolution rules actions: (μ, w1,..., wm) →evrl (μ, w' ,..., w' )

whenever for each i, either wi is irreducible and w'
1
= wi or wi →Mi
m
w'.  We

assume that at least one wi is reducible. For instance,

([[]1]2, bc, ab) →evrl ([[]1]2, (c, here)(a, here)(b, out ), (b, here)(c, in1)(a, here)).
semantics of the communication actions: (μ, w1,..., wm) →comm (μ, w' ,..., w' )
1	m
whenever there is at least one i such that wi is a multiset over O×Tar (a message),
and for all j, w' is obtained by distributing the objects from all wi according to
their targets. For instance,
([[]1]2, (c, here)(a, here)(b, out ), (b, here)(c, in1)(a, here)) →comm ([[]1]2, cac, bba).
semantics of the dissolving actions: (μ, w1,..., wm) →diss (μ', w' ,..., w' ) when-
1	n
ever there is at least one i such that δ ∈ wi, and μ' and (w' )j are obtained by dissolving all membranes i with δ ∈ wi. For instance, ([[]M1 ]M2 , abδ, ccd) →diss ([]M2 , ccdab).
We often use w for w1,..., wm, w' for w' ,..., w'  and so on. An evolution step
1	m
of a system is either of the form (μ, w) →evrl (μ, w'), where w' has no messages or δ (no communications and no dissolvings, e.g., only evolution rules removing objects are applicable), or (μ, w) →evrl (μ, w') →comm (μ, w''), where w'' has no δ (no dissolvings), or (μ, w) →evrl (μ, w') →diss (μ, w''), where w'' has no messages (no communications, e.g, only rules of the form u → δ are applicable), or (μ, w) →evrl (μ, w') →comm (μ, w'') →diss (μ, w''').

Rewriting Logic (RWL)
We assume that the reader is familiar with the basic definitions and notations for many-sorted equational logic [9], term rewriting [5,6], membership equational logic (MEL) [17,7], and rewriting logic [8,15,16].
Here we consider only (unconditional) MEL-based rewrite theories R = (Σ, E, R), where
(Σ, E) is a MEL theory consisting of a MEL signature Σ and a set E of MEL axioms (membership axioms and equations), and
R is a set of (universally quantified) labeled (unconditional) rewrite rules having the form (∀X)r : u → v, with u, v ∈ TΣ(X)s (= the set of terms of sort s and with variables in X) for some sort s and V ar(v) ⊆ V ar(u) ⊆ X.
The rewriting logic of a MEL-based rewrite theory R consists of
sentences given by rewrite sequents, which are pairs of the form (∀X)t → t', with
t, t' ∈ TΣ(X)s for some sort s, and
an entailment relation R ▶ (∀X)t → t' defined by a set of inference rules (see, e.g., [8,15] for details).
A one-step concurrent rewrite is a sequent (∀X)t → t' which can be obtained by a derivation (deduction) which does not use the sequential composition deduction rule. In other words, t' can be obtained from t by applying in parallel a multiset of rewrite rules.
We give as examples the rewrite theories describing the control-free membranes (no restrictions regarding the application of the evolution rules are considered).
The Rewrite Theory Associated to an Elementary Membrane.  The static descrip-

tion of the membranes is represented by the MEL theory (Σm, Em), where Σm includes the sorts Object, Soup, Tar, and HotSoup with Object < Soup < HotSoup, (w, tar ) : HotSoup if w : Soup and tar : Tar , ε : → HotSoup, the concatena- tion   : HotSoup HotSoup −→ HotSoup. The sort Tar includes the constants here and out. The operation in will be defined later. Em includes axioms ex- pressing the associativity and commutativity of   with ε the identity element, and an axiom which allows to merge two messages with the same target into a sin- gle message: (w1, tar )(w2, tar ) = (w1w2, tar ). The sort Soup is for the multisets of objects and the sort HotSoup for the mixed multisets of objects an messages. The idea is as follows: a soup is heated (transformed into a hot soup) applying the evolution rules, then a hot soup is cooled (transformed back into a soup) dis- tributing the objects from messages according to their targets. The complete de- scription of a control-free membrane M is represented by the MEL rewrite theory M = (Σm ∪ O, Em, R), where O the set of object constants, and R includes the rewrite rules corresponding to the evolution rules. For the case of M1 in Figure 1, O includes the constants a, b, c and R1 includes the rules r11 and r12. Using the inference rules for RWL, we may deduce, e.g., that the one-step evolution of M1 bbc →M1 (c, here)(c, here)(a, here)(b, out ) can be described by an one-step concur-
rent rewrite:

(∀∅)b → (c, here)	(∀∅)b → (c, here)
bb → (c, here)(c, here)= (cc, here)	(∀∅)c → (a, here)(b, out )
bbc → (cc, here)(a, here)(b, out )= (cca, here)(b, out )
Note that the above rewrite theory describes M1 as an independent elementary membrane. We show below that the description of the behavior of M1 by the rewrite theory corresponding to the whole system is more complicated.
The Rewrite Theory Associated to a Membrane System.  The static description of membrane systems is represented by the MEL theory (Σp, Ep) consisting of (Σm, Em) together with:
a sort MembraneName together with a constant M : MembraneName, for each membrane name M , and an operation in : MembraneName → Tar ,
a sort Membrane for states of both simple and composite membranes,
a sort MembraneBag for multisets of membranes, together with its constructors: the subsort relation Membrane < MembraneBag, the constant NULL denoting the empty multiset, and the union of multisets
, : MembraneBag MembraneBag −→ MembraneBag [assoc comm id:  NULL]
the constructors for Membrane: ⟨ | ⟩ : MembraneName HotSoup −→ Membrane and ⟨ | { }⟩ : MembraneName HotSoup MembraneBag −→ Membrane, together with the axiom ⟨M|w {NULL}⟩ = ⟨M|w⟩.
A control-free membrane system Π (neither control mechanisms nor the membership of evolution rules to membranes is assumed) is described by the rewrite theory RΠ = (Σp ∪ O, Ep, R), where R includes the rewrite rules coming from all the

component membranes together with the cooperation (interaction) rules (if any):
in(M, M ): ⟨ M | w1(w2, inM' ) {⟨ M | w { X } ⟩,Y }⟩ →
⟨ M | w1 {⟨ M' | w'w2 { X } ⟩,Y }⟩ 
out (M',M ): ⟨ M | w {⟨ M' | w' (w' , out ) { X } ⟩,Y }⟩ →
1	2
⟨ M | ww' {⟨ M' | w' { X } ⟩,Y }⟩ 
2	1
diss(M'): ⟨ M | w {⟨ M' | w'δ { X } ⟩,Y } ⟩→⟨ M | ww' { X, Y }⟩ 
The first rule describes the transmission of a message from a parent membrane M to a child membrane M', the second one the transmission of a message from a child membrane M' to the parent membrane M , and the third one the dissolving of the membrane M' (this is triggered by the presence of the object δ in the current content of M').
The rewrite theory RΠ does not include information about the locality of the rewrite rules. For instance, if Π is the system described in Figure 1, then logic defined by RΠ allows to apply r12 for both the content of M1 and the content of M2. There are different ways for describing the locality of the evolution rules w.r.t. their membership to regions: considering an operation rules(M ) - returning the rules of the membrane M [3,4], encoding the set of rules in the description of each membrane [1,13] and so on. In either of these cases the rewriting logic fails to describe an one- step evolution of a membrane by an one-step concurrent rewrite. For instance, if we encode the rules of M1 by r11 : ⟨ M1 | cW ⟩ → ⟨ M1 | (a, here), (b, out ) W ⟩ and r12 : ⟨ M1 | bW ⟩→ ⟨ M1 | (c, here) W ⟩, then these two rules cannot be concurrently applied because they overlap.
A Modal Logic for Membrane Systems
In this section we define a Hennessy-Milner-like logic [11] able to express the con- currency degree (and the behavior) of a membrane system. We have seen that an evolution step consists of up to three transitions, where each transition accomplishes a specific task. Therefore we distinguish three kinds of actions in this logic:
rule actions corresponding to evolution rules of a membrane. Such an action is denoted by the label of the involved rule. We assume that the rules have distinguished labels such that there is no ambiguity regarding the rule or the membrane the rule belongs to.
communication actions which describe how two parent-child membranes com- municate. Here we consider two kinds of communications: in(M, M') - the membrane M sends a message to membrane M' (M' is a child of M ); and out (M',M ) - the membrane M' sends a message to the surrounding mem- brane M .
dissolving actions diss(M'), meaning that the membrane M' is dissolved and its contents is sent to surrounding membrane; the evolution rules of M' are lost. In general, we may consider a more general kind, namely structural actions meaning all actions aimed to modify the structure of the system.

We associate a modal language LΠ to a membrane system Π as follows:
true is a formula in LΠ;
if ϕ is a formula in LΠ and L a multiset of rule actions, then ⟨L⟩ϕ is a formula in LΠ;
if ϕ is a formula in LΠ and C a set of communication actions, then ⟨C⟩ϕ is a formula in LΠ;
if ϕ is a formula in LΠ and D a set of dissolving actions, then ⟨D⟩ϕ is a formula in LΠ;
if ϕ1 and ϕ2 are formulas in LΠ, then so are ¬ϕ1 and ϕ1 ∧ ϕ2.
Intuitively, if A is a multiset of actions of the same kind, then a configuration (μ, w) satisfies the formula ⟨A⟩ϕ iff there exists a transition (μ, w) →tr (μ', w') such that (μ', w') is obtained by applying in parallel the actions A and (μ', w') satisfies ϕ, where tr ∈ {evrl, comm, diss} corresponds to the kind of the actions A.
The other propositional connectors are added to LΠ in the usual way; e.g., false is the notation for ¬true. The modal operator [A]ϕ is defined as ¬⟨A⟩¬ϕ, where A denotes a set of actions of the same type.
In the following Π is a system with the membranes M1,..., Mm, μ and μ'
range over the structure of Π, wi, w' range over the contents of the membrane
Mi, w = (w1,..., wm), w' = (w' ,..., w' ' ), L ranges over the nonempty multisets
1	m
of rewrite actions, C over the nonempty sets of communication actions, and D over the nonempty sets of dissolving actions. The semantics of the modal formulas is as follows:
Π, (μ, w) |= true for each (μ, w).
Π, (μ, w) |= ϕ1 ∧ ϕ2 if and only if Π, (μ, w) |= ϕ1 and Π, (μ, w) |= ϕ2.
Π, (μ, w) |= ¬ϕ iff Π, (μ, w) |= ϕ.
Π, (μ, w) |= ⟨L⟩ϕ iff there is a transition (μ, w) →evrl (μ, w') such that

if wi →M
w' using the multiset of rules Li,1 ≤ i ≤ n, then L = ∪n
Li, and

i	i	i=1
Π, (μ, w' ,..., w' ) |= ϕ.
1	m
In other words, L is the multiset of all rules involved in the evolution of all membranes; the multiplicity of a rule in L is equal to the number of times the rule was used in the evolution of its membrane.
Π, (μ, w) |= ⟨C⟩ϕ iff there is a transition (μ, w) →comm (μ, w') such that
in(Mi, Mj) ∈ C iff Mj is a child of Mi and there is (ui, inMj ) ∈ wi (there are objects in the current content wi of Mi to be sent to the child Mj),
out (Mj, Mi) ∈ C iff Mj is a child of Mi and there is (uj, out ) ∈ wj (there are objects in the current content wj of Mj to be sent to the parent Mi).
Π, (μ, w) |= ⟨D⟩ϕ iff there is a transition (μ, w) →diss (μ, w') such that
diss(Mj) ∈ D iff wj = vjδ.
We often write M, w |= ϕ for Π, ([]M , w) |= ϕ, i.e., Π consists of only the elementary membrane M . It is easy to see that if Π, (μ, w) |= ⟨L⟩ϕ, then L can be written as a disjoint union L1  ...  Lm such that (∀i)Li /= ∅ implies Mi, wi |=
⟨Li⟩true.
For instance, if Π12 is the membrane system represented in Figure 1, then

M1, bbc |= ⟨r11r12r12⟩true	[iv]
M2, abb |= ⟨r21r22r22⟩true	[iv]
Π12, ([2[1]1]2, bbc, abb) |= ⟨r11r12r12r21r22r22⟩true	[iv] Π12, ([2[1]1]2, (c, here) ... (b, out ), (c, here)(c, in1) ... (a, here)) |=
⟨in(M2, M1) out(M1, M2)⟩true	[v]
Π12, ([2[1]1]2, bbc1, abb2) |= ⟨r11r12r12r21r22r22⟩⟨in(M2, M1) out(M1, M2)⟩true  [iv]
We have Π, (μ, w) |= [A]ϕ if for all transitions (μ, w) →tr (μ', w') such that (μ', w') is obtained by applying in parallel the actions A and tr ∈ {evrl, comm, diss} corresponds to the kind of the actions A, Π, (μ', w') |= ϕ. Since all evolution rules of M1 are non-cooperative, we have M1, bbc |= ⟨r11r12r12⟩true iff M1, bbc |= [r11r12r12]true, i.e., just one transition is possible from bbc. If, e.g., we add to M1 the cooperative evolution rule r13 : bc → (b, here)(c, out ), then we also have M1, bbc |= ⟨r12r13⟩true. The all transitions possible from bbc now are characterized by M1, bbc |= ⟨r11r12r12⟩true ∧ ⟨r12r13⟩true and M1, bbc |= [L]false if L /= r11r12r12 and L /= r12r13. By M1, bbc |= [L]false we express that there is no any transition

such that bbc →M1
w' applying the evolution rules L'.

The definition of LΠ allows legal formulas as ⟨L⟩⟨D⟩⟨C⟩true, which are non- satisfiable, i.e., there is no membrane systems satisfying such a formula. The def- inition of LΠ can be strengthened in order to remove such constructions, but we preferred to let it as simple as possible.
Using the modal language LΠ with the satisfaction relation previously defined, we are able to express the behavior of the system Π. An evolution step (μ, w) ⇒ (μ', w') of a membrane system Π is described as follows:
no dissolvings, no communications: ((μ, w) ⇒ (μ', w') iff (μ, w) →evrl (μ, w')); in that case there is a nonempty multiset L of rewrite actions such that Π, (μ, w) |= ⟨L⟩true and for each nonempty set C of communications and nonempty set D of dissolvings, Π, (μ, w') |= [C]false and Π, (μ, w') |= [D]false;
no dissolvings: ((μ, w) ⇒ (μ', w') iff (μ, w) →evrl (μ, w') →comm (μ, w'')); in that case there are a nonempty multiset L of rule actions and a nonempty set C of communications such that Π, (μ, w) |= ⟨L⟩⟨C⟩true and for each nonempty set D of dissolvings, Π, (μ, w') |= [D]false;
no communications: ((μ, w) ⇒ (μ', w') iff (μ, w) →evrl (μ, w') →comm (μ', w')); in that case there are a multiset L of rule actions and a nonempty set D of dissolvings such that Π, (μ, w) |= ⟨L⟩⟨D⟩true and for each nonempty set C of communications, Π, (μ, w') |= [C]false;
otherwise ((μ, w) ⇒ (μ', w') iff (μ, w) →evrl (μ, w') →comm (μ, w'') →diss (μ', w''')); in that case there are a nonempty multiset L of rule actions, a nonempty set C of communications and a non-empty set D of dissolvings such that Π, (μ, w) |= ⟨L⟩⟨C⟩⟨D⟩true.
The following result exhibits that the behavior of the membrane systems with the mpr control mechanism exposes a maximal concurrency degree.
Proposition 3.1 Let L be a nonempty multiset of rule actions, C a nonempty set

of communication actions, and D a nonempty set of dissolving actions.
If Π, (μ, w) |= ⟨L⟩true, then (∀L' /= ∅)Π, (μ, w) |= ⟨L⟩[L']false.
If Π, (μ, w) |= ⟨C⟩true, then (∀C' /= ∅)Π, (μ, w) |= ⟨C⟩[C']false.
If Π, (μ, w) |= ⟨D⟩true, then (∀D' /= ∅)Π, (μ, w) |= ⟨D⟩[D']false.
The proof of Proposition 3.1 follows direct from the definitions of →evrl , →comm , and →diss , respectively. For the case of the rule actions, does also mater the fact that the evolution rules consume objects and produce messages, so a new rule can be applied only after the objects are distributed according to their targets from messages, i.e., after the occurrences of the communication actions.
Since the implementation of this semantics is difficult in practice, we may derive from it other equivalent semantics but with different concurrency degrees:
true concurrency semantics |=tc:
if Π, (μ, w) |= ⟨A⟩ϕ, then Π, (μ, w) |=tc ⟨A⟩ϕ;
if Π, (μ, w) |=tc ⟨A⟩ϕ and A1    An is a partition of A, then Π, (μ, w) |=tc
⟨A1⟩	⟨An⟩ϕ;
interleaving semantics |=int :
if Π, (μ, w) |= ⟨A⟩ϕ and A = a1 ... an, then Π, (μ, w) |=int ⟨a1⟩	⟨an⟩ϕ
(recall that a1	an is a (multi)set, so the actions ai can be written in any
order),
where A ranges over multiset of rule actions, sets of communication actions, and sets of dissolving actions. Obviously, |=tc and |=int requires appropriate definitions for
→evrl , →comm , and →diss , respectively. The above modal formula-based definitions for concurrency degrees are inspired from [12].
However, the modal language was designated as minimal with respect to the concurrency of the membrane systems. Besides the concurrency degree, there is other information which can be of interest regarding the current state: the structure of the system (relationships between regions), explicit description of the membership of a content to its own region, relationships between the objects of a content and so on.
Strategy-based Rewrite Logic for Membrane Systems
In this section we recall from [4] the definition for the strategy-based rewrite logic for membrane systems. We further present here an algorithm for maximal parallel communication step. The correctness of this algorithm is based on Ko¨nig Theorem for the edge coloring of bipartite graphs. In [4] only an interleaving semantics is considered for communications and dissolvings.
Strategy-based rewrite logic for membrane systems was defined in [4] and spec- ifies a membrane system Π by a triple SRΠ = (RΠ, STRATΠ, SCTRLΠ), where RΠ = (Σ, E, R) is a rewrite theory that specifies the control-free system Π and defined as in Section 2.2, STRATΠ specifies a strategy language for Π, and SCTRLΠ defines the strategy controllers for Π. A strategy controller is intended to equation- ally define the control mechanisms of Π. The rewrite strategies are used to guide

the rewriting according to the operational semantics of Π. The semantics of SRΠ is given by a MEL theory Proof (Π), which includes the semantics of the strategies and the strategy controllers. We briefly describe here the last three theories.
The Equational Theory STRATΠ. We consider a minimal strategy language able to express the computations of a membrane system.
STRATΠ defines the syntax for strategies and consisting of:
a sort RuleLabel for representing rules, together with a membership axiom
r : RuleLabel , for each rule r : u → v in R,
a sort Strategy for strategies, and the subsort relation RuleLabel < Strategy,
the strategy constructors for identity, failure, non-deterministic choice, and se- quential composition respectively:
id fail : −→ Strategy
+  : Strategy Strategy −→ Strategy [assoc comm]
;  : Strategy Strategy −→ Strategy [assoc id : id]
a congruence strategy operator for each of the constructors of Soup, Membrane
and MembraneBag:
  : Strategy Strategy −→ Strategy [assoc comm]
⟨ | ⟩ : MembraneName Strategy → Strategy
⟨ | { }⟩ : MembraneName Strategy Strategy −→ Strategy
, : Strategy Strategy −→ Strategy [assoc comm]
The strategy language defined by the above theory was designed having in mind mainly the control of the evolution rules. This language can be enriched with new constructs needed for defining other control mechanisms over evolution rules [2] or to add certain control over the interaction rules. In Section 5 we sketch out an extension for the case of cooperation rules.
The Equational Theory SCTRLΠ. SCTRLΠ is the MEL theory consisting of:
a sort StrategyController - for strategy controllers, together with the constants mpr . . . – corresponding to the control mechanisms, evrl – corresponding to evolution rules actions, comm – corresponding to communication actions, and diss – corresponding to dissolving actions,
an operation getCtrl : MembraneName −→ StrategyController which returns the constant corresponding to the control mechanism of the membrane.
The equational theory Proof (Π). The proof-theoretical semantics of the specification (RΠ, STRATΠ, SCTRLΠ) is given by a MEL-theory Proof (Π) which includes the semantics for strategies and the semantics for strategy controllers.
The semantics of strategies can be defined in different ways. In this paper, in order to keep the presentation as simple as possible, we consider the set-theoretical semantics [14] defined by the following additional operations:

[[ @ ]] : Strategy State −→ Set{States}
[[ @ ]] : Strategy Set{States} −→ Set{States}
together with the following equations:
[[id @t]] = {t}
[[fail @t]] = ∅
[[r@t]] = {t' | t rewritten directly modulo Ep to t' using the rule r at top} [[s1 + s2@t]] = [s1@t]] ∪ [[s2@t]]
[[s1; s2@t]] = [s2@[[s1@t]]]]
[[s1s2@w1w2]] = {w' w' | w' ∈ [[si@wi]],i = 1, 2}
1 2	i
[[⟨M | s⟩@⟨M | w⟩]] = {⟨M | w'⟩| w' ∈ [[s@w]]}
[[s1, s2@t1, t2]] = {t' , t' | t' ∈ [[si@ti]],i = 1, 2}
1  2	i
[[⟨M | s1{s2}⟩@⟨M | w{t}⟩]] = {⟨M | w'{t'}⟩ | w' ∈ [[s1@w]], t' ∈ [[s2@t]]}
[[s@∅]] = ∅
[[s@(T ∪ {t})]] = [s@T ]] ∪ [[s@t]]
where State is a supersort of HotSoup, Membrane and MembraneBag, wi, w' are
variables of sort Soup, t, t', ti, t' are variables of sort State, T a variable of sort
Set{States}, and s, si are variables of sort Strategy.
However, we assume that the operational semantics for strategies is able to implement a strategy as a concurrent (parallel) rewriting whenever it is possible (e.g., see Corollary 4.5).
Definition 4.1 We say that two strategy terms s1 and s2 are equivalent in Proof (Π), written s1 ≡ s2, if and only if Proof (Π) ▶ [[s1@t]] = [s2@t ] for all state terms t.
Proposition 4.2 [4] The following equivalences are true in Proof (Π):
s + s ≡ s	id id ≡ id
s; fail ≡ fail; s ≡ fail	s + fail ≡ s
⟨M | s + s'⟩≡ ⟨M | s⟩ + ⟨M | s'⟩	sfail ≡ fail s ≡ fail
⟨M | s1 + s' {s2}⟩≡ ⟨M | s1{s2}⟩ + ⟨M | s' {s2}⟩  s1 (s2 + s' ) ≡ s1 s2 + s1 s'
1	1	2	2
⟨M | s1{s2 + s' }⟩≡ ⟨M | s1{s2}⟩ + ⟨M | s1{s' }⟩  s1, (s2 + s' ) ≡ s1, s2 + s1, s'
2	2	2	2
The semantics of the strategy controllers is given by means of two operations:
getStrat : StrategyController State −→ Strategy.
getStrat : MembraneName StrategyController State −→ Strategy
If for a given state t there are possible more than one evolution steps, then getStrat (ctrl, t ) returns a sum of strategies expressing this nondeterminism. Therefore the strategy returned by getStrat is unique up to ≡.
The semantics of the strategy controller evrl is given by

getStrat (evrl, ⟨ M | w ⟩)= ⟨ M | getStrat (M , getCtrl (M ), w ) ⟩
getStrat (evrl, ⟨ M | w { t1 ,..., tn } ⟩)= 
⟨ M | getStrat (M , getCtrl (M ), w ) { getStrat (evrl, t1 ),..., getStrat (evrl, tn ) }⟩ 
The first equation defines getStrat for the elementary membranes and the second one for the case when the membrane M includes other membranes.
The strategy controllers comm and diss used in the implementation presented in [4] have an interleaving semantics. In order to capture the maximal concurrency degree for the communication (resp. dissolving) rewrite rules, we have to add to the strategy language a new operator
⟨ ... ⟩ : Strategy ... Strategy −→ Strategy
with the intuitive semantics that [⟨s1,..., sn⟩@t ] is the set of terms which can be obtained from t by applying in parallel the strategies s1,..., sn at non-overlapping positions in t.
Let t be a term encoding a configuration (μ, w) and let k be the maximum degree of μ (viewed as a tree). The tree μ is a bipartite graph and therefore it can be edge colored with k colors (by Ko¨nig Theorem, see, e.g., [10]) and this is the minimum of colors which can be used for a edge coloring. For each color cl, we consider two strategies sl = ⟨...r .. .⟩ and sl = ⟨... r .. .⟩ such that:
if r is in(Mi, Mj) then r is out (Mj, Mi) and vice-versa;
r occurs in sl iff r occurs in sl;
in(Mi, Mj) occurs in sl or in sl iff there is an edge (i, j) colored with cl.
It is obvious that sl and sl have the same number of rule labels occurrences and the two strategies send the messages between the same set of membrane pairs but in opposite directions: if one sends messages from Mi to Mj, the other one sends from Mj to Mi. The rules specified by sl, respectively sl, can be applied concurrently, due to the edge coloring properties. Therefore a strategy implementing comm with a maximum concurrency degree is s1; s1; ... ; sk; sk.
Then an algorithm computing getStrat (comm, t )= s1; s1; ... ; sk; sk is an equa- tional description of the edge coloring algorithm applied on the particular case of trees and where the colors are expressed as strategies.
In order to understand better this algorithm, we consider a simple example. Let Π be a membrane system with the tree structure μ = [[[ ]1]2[[ ]3]4]5. An edge coloring for μ is given by two colors: {(2, 1), (5, 4)} and {(5, 2), (4, 3)}. A configuration for Π is of the form t = ⟨ M5 | w5 {⟨ M2 | w2 {⟨ M1 | w1 ⟩} ⟩, ⟨ M4 | w4 {⟨ M3 | w3 ⟩}⟩} ⟩. A possible strategy returned by getStrat (comm, t ) is s1; s1; s2; s2, where:
s1 = ⟨in(M2, M1) in(M5, M4)⟩	s1 = ⟨out(M1, M2) out(M4, M5) s2 = ⟨in(M5, M2) out(M3, M4)⟩  s2 = ⟨out(M2, M5) in(M4, M3)⟩
The following result summarizes the above discussion:
Proposition 4.3 Let Π be a membrane system, t a term encoding a conﬁguration (μ, w), k the maximum concurrency degree of μ. If Proof (Π) ▶ getStrat (comm, t)= s, then s = s1; ... ; s2k and for each i, if t' ∈ [[si@t]], then t' can be obtained from t

by a concurrent one-step rewriting.
The algorithm for getStrat (diss, t ) is similar.
Regarding the control mechanisms of an elementary membrane, in this paper we are interested in the strategy controller mpr. The semantics of mpr, getStrat (M , mpr, w ) with w : Soup, is given by the means of two auxiliary operations
mpr : RuleSet —→ StrategyController
mpr : RuleSet Soup RuleSet Strategy —→ StrategyController
together with the following equations:
getStrat (M , mpr, w )= getStrat (mpr (getRules(M )), w ) getStrat (mpr (RS ), w )= getStrat (mpr (RS, w, none, fail ), w ) getStrat (M , mpr ((RS, r ), w, RS′, S ), w )= 
(r getStrat (M , mpr ((RS, r ), w′, none, id ))) + getStrat (mpr ((RS, r ), w, (RS′, r ), fail ), w )
if lhs(r )w′ := w Λ notIn(r, RS′)
getStrat (M , mpr (RS, w, RS′, S ), w )= S [owise].
The attribute [owise] used in the last equation means that this equation is condi- tional, where the condition accumulates the cases when none of the similar equations can be applied.
The third argument of the quaternary operation mpr represents the set of rules already used for the construction of a strategy applicable to w; such iterative ap- plication allows to equally consider each of the rules given in the first argument for computing a strategy. As soon as a rule is tested as applicable and is used in a concatenation for building a strategy, then the fourth argument of mpr becomes id to mark the success. When the second and the third equations can no longer be applied, the fourth one is applied: if last argument of mpr is fail, this means no rule was applicable, and the strategy computed is fail by Proposition 4.2; otherwise, the strategy id is concatenated to the multiset of rules already found as applicable.
An evolution step in strategy-based rewrite semantics is defined as follows:
t ⇒evrl t1 iff Уroof (Π) ▶ t1 ∈ [[getStrat (evrl, t)@t]],
t1 ⇒comm t2 iff Уroof (Π) ▶ t2 ∈ [[getStrat (comm, t1)@t1 ], and
t2 ⇒diss t3 iff Уroof (Π) ▶ t3 ∈ [[getStrat (diss, t2)@t]].
The following result is a direct consequence of the definition of getStrat (M, ctrl, w) and of Proposition 4.2.
Proposition 4.4 [4] Let M be a membrane. If w is a term of sort Soup and Уroof (Π) ▶ getStrat (M, mpr, w) = s with s /= fail, then s is equivalent to a sum of strategy terms si of the form ri1 ... rin id, where ri1 ... rin is a multiset of rule labels. Moreover, [[si@w]] /= ∅.
Corollary 4.5 If Уroof (Π) ▶ getStrat (M, mpr, w) = s with s /= fail and w' ∈
[[s@w]], then w' can be obtained from w by a concurrent one-step rewriting.
The above corollary is essential for the main result proved in the next section.

Concurrency in Strategy-based Rewrite Semantics
This section includes the main results of the paper. We use the operational corre- spondence between a membrane system and its strategy-based rewrite semantics [4] to show how the modal formulas can be used for expressing the concurrency degree for computations in the strategy-based rewrite semantics. Then we compare this concurrency degree with that of the original membrane system.
Throughout of this section we consider a membrane system Π, its representation SRΠ = (RΠ, STRATΠ, SCTRLΠ) as strategy-based rewrite theory, and Уroof (Π) the theory giving semantics to SRΠ.
The static relationship between Π and SRΠ is given by a function ψ defined as follows:
if w is a multiset of objects, then ψ(w) is the corresponding ground term of sort Soup, denoted also by w (recall that each object of Π is defined as a constant of sort Soup in (Σp, Ep));
if M is an elementary membrane with content w, then ψ(M )= ⟨M | w⟩;
if M is a compound membrane with content w and the children M1,..., Mn, then ψ(M )= ⟨M | w {ψ(M1),..., ψ(Mn)}⟩;
ψ(μ, w) = ψ(M ), where M is the skin of Π (the relationship between w and
ψ(M ) is implicitly given here by means of μ).
The operational semantics correspondence is given by
(μ, w) →ctrl (μ', w') iff ψ(μ, w) ⇒ctrl ψ(μ', w')
iff Уroof (Π) ▶ ψ(μ', w') ∈ [[getStrat(ctrl , ψ(μ, w))@ψ(μ, w)]]
where ctrl ∈ {evrl, comm, diss}. See [4] for more details.
The parallelism of the strategy in the strategy-based semantics is supplied by the congruence operators corresponding to concatenation (union) of multisets of soups and membranes, respectively. In order to express this parallelism, we associate a modal formula ψ'(s) to a strategy term s as follows:
ψ'(id )= true, ψ'(fail )= false;
ψ'(r)= ⟨r⟩true if r is the label of a evolution/comunication/structural rewrite rule;
ψ'(s1 + s2)= ψ'(s1) Λ ψ'(s2);
ψ'(s1; s2)= ⟨A1⟩ϕ2 if ψ'(s1)= ⟨A1⟩true and ψ'(s2)= ϕ2;
ψ'(s1s2)= ⟨A1  A2⟩(ϕ1 Λ ϕ2) if ψ'(si)= ⟨Ai⟩ϕi for i = 1, 2;
ψ'(⟨M | s⟩)= ψ'(s);
ψ'(⟨M | s1 {s2}⟩)= ⟨A1  A2⟩(ϕ1 Λ ϕ2) if ψ'(si)= ⟨Ai⟩ϕi for i = 1, 2;
ψ'(s1, s2)= ⟨A1  A2⟩(ϕ1 Λ ϕ2) if ψ'(si)= ⟨Ai⟩ϕi for i = 1, 2.
We recall that the rule labels are unique and SRΠ stores the membership of rules to membranes, so we can recover the information lost by putting all the rule actions from different nesting levels in the same multiset. The function ψ' is partial; for instance, ψ'(s1; s2) is not defined for all s1. Moreover, in order to have defined formulas like ψ'(s id ) we assume that ϕ ≡ ⟨∅⟩ϕ.

Concurrency of Evolution Rules Actions
We have all the elements to compare the concurrency degrees of a membrane system Π and its strategy-based rewrite specification (RΠ, STRATΠ, SCTRLΠ).
Lemma 5.1 Let M be an elementary membrane and w its content. If Уroof (Π) ▶ getStrat (evrl, ⟨M |w⟩)= s, then ψ'(s) is well-deﬁned and has the form ⟨L1⟩true Λ... Λ ⟨Lk⟩true.
The proof of the above result follows directly from Proposition 4.4.
Lemma 5.2 Let M be an elementary membrane and w its content.	M, w  |=
⟨L⟩true if and only if Уroof (Π) ▶ getStrat (evrl, ⟨ M | w ⟩) = s and there is ϕ
such that ψ'(s)= ϕ Λ ⟨L⟩true.
Proof. We assume that L = {r1,..., rn}. If M, w |= ⟨L⟩true, then s = s' + r1 ... rnid from the definition of getStrat. The converse implication follows by ap- plying Proposition 4.4 and Lemma 5.1.	 
Now we are able to prove the first main result of this paper:
Theorem 5.3 Let L be a nonempty multiset of evolution rules actions.
If Π, (μ, w) |= ⟨L⟩true then there are the strategy terms s, s' such that ψ'(s') = 
⟨L⟩true and Уroof (Π) ▶ getStrat (evrl, ψ(μ, w)) = s + s'.
Conversely, if Уroof (Π) ▶ getStrat (evrl, ψ(μ, w)) = s then ψ'(s) is well-deﬁned and Π, (μ, w) |= ψ'(s).
Proof. If Уroof (Π) ▶ getStrat (evrl, ψ(μ, w)) = s, then s is a sum of strategies by Proposition 4.2 and each member of the sum defines a transition. The conclusions of the theorem follows by the operational semantics correspondence and Lemma
5.2.	 
It is worth noting that if Уroof (Π) ▶ getStrat (ψ(Π, w)) = s and si is a sum member of s, then si can be implemented by a concurrent one-step RΠ-rewriting (see Corollary 4.5). Therefore Theorem 5.3 says that the maximal concurrency of the rewrite actions is preserved by the strategy-based rewrite semantics.
Concurrency Of Communication Actions
Let us consider first a parent-child pair (M, M') of membranes such that there are messages in M to be sent to M' and, conversely, there are messages in M' to be sent to M . In other words, the communication between them is described by the modal formula ⟨in(M, M') out (M',M )⟩true. The communication between M and M' can be implemented by interleaving the in and out rules: s = in(M, M'); out (M',M ) or s' = out (M',M ); in(M, M'). We have ψ'(s)= ⟨in(M, M')⟩⟨out (M',M )⟩true.
This can be extended to the general case. We have seen that the algorithm presented on page 13 computes strategies which apply the communication rules in an concurrent way and as much as it is possible. In fact, by Proposition 4.3, we have that the maximum concurrency degree of the communication which can be

described in the rewrite semantics is that given by rewriting logic. This is because the communication rewrite rules are global and not local as it is the case of evolution rules.
We conclude now the second main result, namely that the true concurrency of the communication actions is partially preserved by the strategy-based rewrite semantics, i.e., it is described by a combination of true concurrency and interleaving concurrency. This is formalized by the following result:
Theorem 5.4 Let Π be a membrane system and (μ, w) a conﬁguration of Π such that Π, (μ, w) |= ⟨C⟩true, where C is a nonempty set of communication actions. Let s be the strategy such that Уroof (Π) ▶ getStrat (comm, ψ(μ, w)) = s. Then there is a partition C1  ...  Cn of C such that ψ'(s)= ⟨C1⟩ ... ⟨Cn⟩true.
Since Π, (μ, w) |= ⟨C⟩true, it follows that Π has at least two membranes. The proof of Theorem 5.4 is a direct consequence of the algorithm presented on page 13. It is worth noting that if C says that there are parent-child membranes which do not communicate or communicate in only one direction, in or out, then n given by Theorem 5.4 could be less than 2k, where k is the maximum degree of μ. If we add to RΠ the following rule, which simultaneously exchanges the messages between two membranes:

'	'	'	'
in-out(M, M ): ⟨ M | w1(w2, inM' ) {⟨ M | w1, (w2, out ) { X } ⟩,Y }⟩ →
⟨ M | w1w' {⟨ M' | w'w2 { X } ⟩,Y }⟩ 

and ψ'(in-out(M, M')) = ⟨in(M, M') out (M',M )⟩, then we get n ≤ k.

Concurrency of Structural Actions
If the structural actions include only dissolvings, then we get a similar conclusion as the one for the communication actions. However, since the structural actions change the structure of the system, the maximal concurrency of structural actions cannot always be described by interleaving concurrency in the strategy-based rewrite semantics. For the case of dissolvings, because we consider only actions with one parameter, the label of the dissolving membrane, the interleaving is preserved. For instance, the double-dissolving in the configuration ([1[2[3]3]2]1, w1, w2δ, w3δ) could be described by one of the following two strategies:
s = diss(M2); diss(M3) or s' = diss(M3); diss(M2).
Obviously ψ'(s + s') expresses the interleaving of the two dissolvings. This does not remain true if the dissolving actions are of the form diss(M, M').
Theorem 5.5 Let Π be a membrane system and (μ, w) a conﬁguration of Π such that Π, (μ, w) |= ⟨D⟩true, where D is a nonempty set of dissolving actions. Let s be the strategy such that Уroof (Π) ▶ getStrat (diss, ψ(μ, w)) = s. Then there is a partition D1  ...  Dn of D such that ψ'(s)= ⟨D1⟩ ... ⟨Dn⟩true.

6  Conclusion
In this paper we give a partial answer to the question if it is possible to define a rewrite semantics for the membrane systems. It was recently shown [13] that rewriting logic-based semantics cannot preserve the maximal concurrency of the rewrite actions. The main reason is the locality of the evolution rules w.r.t. their membership to the regions. The rewrite rules encoding the evolution rules belonging to a region must share this locality and hence they cannot be applied concurrently.
In this paper we show that the strategy-based rewrite semantics introduced in [4] preserves the maximal concurrency of the rewrite actions. In the strategy- based rewrite semantics the control mechanisms of the membranes are modeled by strategy controllers. A strategy controller analyzes the current state and computes a strategy term describing all possible transitions from the current state. The strategy term corresponding to a membrane can be computed in such a way it preserves the concurrency degree given by the control mechanism. The semantics of the strategy controllers is equationally defined and therefore it does not affect the behavior described by the strategy-based theory.
Regarding the concurrency of the cooperation (communication and structural) actions, the two rewrite semantics are equivalent. Since the rewrite rules governing these actions are global, the concurrency given by the rewriting logic is the maximum we can obtain.
In a recent paper, S¸erb˘anu¸ta˘ et al. [20] investigate the same problem of the faithful implementation of the membranes but using the framework K [19]. Their result is based on the following two facts:
a special encoding of the P systems by tagging the rewrite rules and the objects with the path in the structure-tree from the root to the membrane M , and
the rewriting rules in K can be applied concurrently even when they overlap, assuming that they do not change the overlapped portion of the term (may overlap on “read only” parts).
In this paper we consider the particular case of transition P systems [18]. There is a large variety of P systems. We think that the strategy-based rewrite semantics can faithfully describe almost all mechanisms used for controlling the evolution rules. It remains to investigate what happens with the concurrency degree of the cooperation actions for different more general structures, e.g., tissue-like structures or neural-like structures.

References
Agrigoroaiei, O. and G. Ciobanu, Rewriting Logic Specification of Membrane Systems with Promoters and Inhibitors, in: Proceedings of WRLA, 2008, pp. 1–16, to appear in ENTCS.

Andrei, O., G. Ciobanu and D. Lucanu, Expressing Control Mechanisms in P systems by Rewriting Strategies, in: H. J. Hoogeboom, G. Paun, G. Rozenberg and A. Salomaa, editors, Workshop on Membrane Computing, Lecture Notes in Computer Science 4361 (2006), pp. 154–169.

Andrei, O., G. Ciobanu and D. Lucanu, A rewriting logic framework for operational semantics of membrane systems, Theoretical Computer Science 373 (2007), pp. 163 – 181.


Andrei, O. and D. Lucanu, Strategy-Based Proof Calculus for Membrane Systems, in: Proceedings of WRLA, 2008, pp. 17–34, to appear in ENTCS.
Baader, F. and T. Nipkow, “Term Rewriting and All That.” Cambridge University Press, 1998.
Bezem, M., J. Klop and R. de Vrijer, editors, “Term Rewriting Systems.” Cambridge Tracts in Theoretical Computer Science I, Cambridge University Press, 2003.
Bouhoula, A., J.-P. Jouannaud and J. Meseguer, Specification and proof in membership equational logic, Theoretical Computer Science 236 (2000), pp. 35–132.
Bruni, R. and J. Meseguer, Semantic foundations for generalized rewrite theories, Theoretical Computer Science 360 (2006), pp. 386–414.
Goguen, J. A. and J. Meseguer, Order-Sorted Algebra I: Equational Deduction for Multiple Inheritance, Overloading, Exceptions and Partial Operations, Theoretical Computer Science 105 (1992), pp. 217– 273.
Gross, J. L. and J. Yellen, “Handbook of Graph Theory,” CRC Press, 2003.
Hennessy, M. and R. Milner, Algebraic laws for nondeterminism and concurrency, J. of ACM 32 (1985),
pp. 137–161.
Lodaya, K., M. Mukund, R. Ramanujam and P. Thiagarajan, Models and logics for true concurrency, in: P. Thiagarajan, editor, Some Models and Logics for Concurrency, Advanced School on the Algebraic, Logical and Categorical Foundations of Concurrency, Gargnano del Garda, 1991 .
Lucanu, D., Rewriting Logic-based Semantics of Membrane Systems and the Maximal Concurrency, in: Proceedings of Prague International Workshop on Membrane Computing (2008), pp. 23–34.
Mart´ı-Oliet, N., J. Meseguer and A. Verdejo, A Rewriting Semantics for Maude Strategies, in:
Proceedings of WRLA, 2008, pp. 207–226, to appear in ENTCS.
Meseguer, J., Conditional Rewriting Logic as a Unified Model of Concurrency, Theoretical Computer Science 96 (1992), pp. 73–155.
Meseguer, J., Rewriting Logic as a Semantic Framework for Concurrency: a Progress Report, in: Proceedings of the 7th International Conference on Concurrency Theory, Lecture Notes in Computer Science 1119, 1996, pp. 331–372.
Meseguer, J., Membership algebra as a logical framework for equational specification, in: Francesco Parisi-Presicce, editor, WADT, Lecture Notes in Computer Science 1376 (1997), pp. 18–61.
Paun, G., “Membrane Computing. An Introduction,” Springer, 2002.
Ro¸su, G., K: A Rewriting-Based Framework for Computations – Preliminary version, Technical Report Department of Computer Science UIUCDCS-R-2007-2926 and College of Engineering UILU-ENG-2007- 1827, University of Illinois at Urbana-Champaign (2007).
S¸erb˘anu¸ta˘, T. F., G. S¸tef˘anescu and G. Ro¸su, Defining and executing P-systems with structured data in K, in: WMC’08, 2008, to appear.
