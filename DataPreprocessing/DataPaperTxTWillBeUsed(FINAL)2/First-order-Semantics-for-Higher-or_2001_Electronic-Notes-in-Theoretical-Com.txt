Electronic Notes in Theoretical Computer Science 41 No. 3 (2000)
URL: http://www.elsevier.nl/locate/entcs/volume41.html pages 50–69


First–order Semantics for Higher–order Processes

Michael Baldamus
University of Karlsruhe
Institute for Computer Design and Fault Tolerance
baldamus@ira.uka.de


Abstract
Context bisimulation is a conceptually appealing behavioural equivalence for higher– order processes. Assuming that the scoping discipline for names or channels is static, that notion can be characterized in terms of so–called normal bisimulation and in terms of π–calculus bisimulation.
This paper provides a new characterization. Specifically, late context bisimulation in the static setting is characterized as ordinary delay bisimulation. The basis of that is a new operational semantics for higher–order processes, where higher–order communication is replaced by the coupling of trigger actions. These actions are freshly generated whenever, in the original semantics, an input or output would occur. To obtain the characterization, those actions must be normalized; to achieve this normalization, in turn, a novel scheme of shifting and unshifting actions is used.


Introduction
The mathematical study of systems of interconnected concurrent processes has a wide range of possible sub–topics. A particularly interesting one is that of mobility, where processes may be relocated and/or the communication topology may change dynamically. Within the field of process algebra, the π–calculus [13] was invented to describe and analyze mobility brought about by dynamically changing communication topologies; higher–order processes and mobile ambients [6] have been introduced to describe and analyze process relocation. Here, the focus is on higher–order processes. This approach can be traced back to [3]; it was firmly established by subsequent work starting with

1 The material presented herein was developed while the author was a member of the FLP/KIT research group at the Berlin University of Technology. The author’s current work is supported by the Deutsche Forschungsgemeinschaft (German Research Society) within the project Design and Design Methodology of Embedded Systems.
◯c 2000 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


[19]. The idea is to endow processes with the ability to send and receive their own kind. This stipulation renders processes first–class citizens; it is therefore justified to speak of “higher–order” processes.
Standard process algebra methodology calls for studying behavioural pre- orders and equivalences that are derived from operational semantics. As for higher–order processes, that obligation has been met in various ways. For example, there is the distinction between a dynamic and a static scoping dis- cipline for names or channels. Dynamic scoping means that process passing does not invoke α–conversion, so that free names or channels of a process passed may be bound by the receiving context; static scoping means that pro- cess passing does invoke α–conversion, so that no capture of free names or channels of a process being passed can occur.
As for behavioural preorders and equivalences over higher–order processes, context bisimulation [1, 15, 17] is a particularly appealing equivalence. This notion avoids over–discrimination as we see it in the case of higher–order bisimulation (cf. [17]), a notion studied in [19] and related works. A theoretical alternative is De Nicola/Hennessy–style testing [7] applied to higher–order processes. This notion, however, can be much more complicated to deal with than bisimulation.
Assuming that the scoping discipline is static, context bisimulation can be characterized in terms of normal bisimulation [17] and in terms of π–calculus bisimulation [18], where the latter characterization involves a syntactic trans- lation from higher–order to π–calculus processes. These results are interesting since they essentially reduce higher–order communication in the static setting to first–order communication. The idea is that higher–order communication in that setting can be understood as a mechanism of generating replicas of processes to be sent, where these replicas do not change location conceptually because of the very fact that the scoping discipline is static. All what hap- pens besides the generation of replicas is that they are triggered by receiving contexts.
The main purpose of the present paper, then, consists of characterizing context bisimulation in a new way, namely as delay bisimulation strictly in the sense of [9]. This result still adheres to that idea of reducing higher–order to first–order communication. It is distinguished from the above–mentioned ones chiefly in that delay bisimulation according to [9] is not located at the higher– order level, such as normal bisimulation, or at the π–calculus level. Besides that simplicity, the characterization should allow one to transfer many results and techniques from the world of CCS–like processes more or less directly to higher–order processes (cf. Section 5).
The technical basis of all of that is a new type of structural operational semantics (SOS) for higher–order processes with static scoping. Most notably, the idea of reducing higher–order to first–order communication is realized by dispensing with process passing from the beginning. To this end, the SOS puts processes to be sent into replicator contexts instead of sending them and

substitutes trigger processes for processes to be received; second, it does not contain a communication rule but a coupling rule for trigger actions; third, it employs a shifting and unshifting scheme for normalizing freshly generated trigger actions. Thus, part of what is technically new herein is the on–the–fly manner of generating replicas and triggers, which is built into the SOS. Those existing characterizations in terms of normal and π–calculus bisimulation bring replication and triggering into play via the notion of bisimulation [17] or via syntactic transformation [18].
It should also be noted that the normalization of fresh names is an ingre- dient of π–calculus models. Those models always consider processes relative to name contexts, since name normalization is affected by what free names of a π–calculus process can actually become active (see, for example, [8]). The shifting and unshifting scheme introduced herein, by contrast, is not affected by anything like that; for this reason, it allows us to go about in the usual way, that is, by considering processes on their own.
The paper is organized as follows:
Section 2 provides background by introducing a language, a standard SOS and notions of context and normal bisimulation for higher–order processes.
Section 3 introduces the new SOS mentioned above.
Section 4 introduces the notion of delay bisimulation over the new SOS from Section 3, compares it with the notion of normal bisimulation, states the characterization theorem and outlines that theorem’s proof.
Section 5 concludes the paper and gives an outlook on applications of the SOS and the characterization theorem. Specifically, it briefly mentions a fully abstract final coalgebra semantics for higher–order processes with static scoping. This semantics is based on the SOS from Section 3; its full abstraction property is proved with the help of the characterization theo- rem.
Because of space considerations, most proofs are omitted. All of them can be found in [4].


Acknowledgment
The author would like to thank the anonymous referees of this paper for all their remarks and suggestions.

Background
This section introduces a language, an SOS with static scoping and notions of context and normal bisimulation for higher–order processes.


TI(Var):	P	::=	i∈I prei.Pi | P1 | P2 | P\ao |!P | XI | F⟨P⟩
Pre(Var): pre ::=	aI | aI | n | n	; first–order prefix
| aII?XI | aII!P	; higher–order prefix
TII(Var):  F	::= YII | λXI.P
Table 1
BNF–like grammar for higher–order processes, where I ranges over finite index sets and o ∈ {I, II}
Language
Strictly speaking, the calculus to be introduced next is a second–order calcu- lus, since there is no exchange of abstractions. It is, nevertheless, consistent with most of the relevant literature to speak of higher–order processes. The language, then, is given in a BNF–like manner by Table 1combined with Ta- ble 2. Suffixes of I and II are used to designate first–order and higher–order
entities, respectively. Specifically, I accompanies (ordinary) first–order chan-
nels, which are used for mere synchronization, and variables of type process;
II accompanies second–order channels, which are used for process passing, and variables of type process −→ process. These subscripts are sometimes omitted given that they are clear form the context.
Channels and variables or order I or II must be given via two mutually dis- joint, countably infinite sets chI and chII, and via two countably infinite sets
VarI and VarII. — The language contains first–order channels since they are necessary for the new SOS introduced in Section 3. Another ingredient neces- sitated by that SOS is the possibility of using natural numbers in first–order channel position. In this role they serve as normalized channels. Accordingly, it is assumed that chI and N, the set of natural numbers including zero, are dis- joint. It is intentional that normalized channels can not be restricted because of that assumption.
The constructors are basically as in Sangiorgi’s higher–order π–calculus (cf. [16]), without any π–calculus ingredients and without the possibility of going beyond the second order. In particular, summation must be guarded, since weak behavioural equivalences over higher–order processes must be con- gruences right away; it is not feasible to admit unguarded summation while considering “observation congruences” of any kind, such as it can be done within first–order frameworks (cf. [12]). Moreover, the abstraction of XI in P is denoted by λXI.P, and ⟨ ⟩ is an application constructor of type ((process −→ process) × process) −→ process.
To finish this subsection, it should be noted that P\ao binds ao in P, o ∈
{I, II}, and that aII?XI.P and λXI.P bind XI in P. Substitution always invokes α–conversion so that any capture of free channels or variables is prevented. The set of free first–order channels of a (first–order) term P is denoted by
fchI(P).



Table 2
Syntactic classes and their typical variables, o ∈ {I, II}.

SOS
An SOS for the language from the preceding subsection is given by the ax- ioms and rules from Table 3. It is an SOS in the style of [2, 5] in that process transmission is achieved by turning the receiving context into an abstraction and substituting this abstraction into the sending context. To this end, the axiom for higher–order output prefixing, (out–HO), and the rule for com- munication, (com), differ from their counterparts within more conventional frameworks. Specifically, (out–HO) sets up the output context as a term of the form (YII⟨P1⟩) | P2, where YII is an arbitrary (higher–order) variable, P1 is the process send and P2 is the output residual; (com) does what was already mentioned. On a technical remark, the choice of YII is arbitrary; the reason is that we only consider transitions whose source term does not contain free variables. On another technical remark, static scoping is realized by the fact that (com) and (app) invoke ordinary substitution, which means that processes substituted into input contexts and input contexts substituted into output contexts never have their free names captured.
The SOS operates on various action sets. Their definitions and typical



pre
(pre)	pre.P −→ P if pre is not a higher–order output prefix
(out)	a !P .P a−II!→YII (Y ⟨P ⟩) | P

(choice) prek
µ
.Pk −→
k implies Σi∈I
prei.P
µ
i −→
' for each k ∈ I

(par)	P
µ
1 −→
' implies P1
µ
| P2 −→
' | P2

(sync)	P1
−a→I
' and P2
−a→I
' implies P1
| P2
−τ→ P'
| P'

(com)	P
a−II→?XI P'
and P
a−II!→YII P'
implies P | P
−τ→ P' [P' [X ]/Y ]

1	1	2	2	1	2	2	1	I	II

µ
(res)	P −→
P' implies P\a
µ
o −→
P'\ao
if ao
/∈ cho
(µ), o ∈ {I, II}

µ
(rep)	P|!P −→
P' implies !P µ	P'

µ
(app)	P [P /X ]
P' implies (λX .P )⟨P
µ	P'

1	2	I −→
I 1	2⟩ −→


Table 3
Higher–order structural axioms and rules. The symmetric counterparts of (par), (sync) and (com) are not shown.

ChII?VarI =def {aII?XI : aII ∈ ChII and XI ∈ VarI} ChII!VarII =def {aII!YII : aII ∈ ChII and YII ∈ VarII}
Table 4
Action classes and their typical variables and the cho–operator on actions,
o ∈ {I, II}.

variables and the definition of the ch( )o–operator, o ∈ {I, II}, can be found in Table 4. It is assumed that the silent action, τ , is not contained in ChI and ChII.
Context Bisimulation
To introduce the notion of context bisimulation, the following preliminaries are required:



The reflexive and transitive closure of −r→ is denoted by =⇒є
. Moreover,

the relational product of =⇒є
µ	µ	µ
and

is not defined as =є	µ  =⇒є
−→ is denoted by =⇒. As an aside, =⇒
since the SOS from the preceding subsection

⇒−→
is asymmetric. Specifically, source terms are always processes in the sense that they do not have free variables; residual terms of input and output transitions, on the other hand, in general do have free variables. This sit- uation is typical within the world of higher–order processes (cf. [17], for instance).
τ^ =def ϵ, α^ =def α
A ground substitution is a mapping from the set of variables into the set of terms without free variables, given that first–order variables are mapped to first–order terms, and given that second–order variables are mapped to second–order terms.
Suppose T is a term and suppose σ is a ground substitution. Then the result of simultaneously substituting every free variable of T by its image under σ is denoted by Tσ.
Suppose R is a binary relation on terms without free variables. Then its
open extension to terms (with or without free variables), R◦, is given by
P R◦ Q if and only if Pσ R Qσ for every ground substitution σ.
One could demand that R be order respecting in the sense that R be a subset of the union (TI(Var) ×TI(Var)) ∪ (TII(Var) ×TII(Var)). Technically, however, that side condition is not necessary.
The set of first–order terms without free variables is denoted by TI.
By virtue of that entire machinery, then, the following definition is remark- ably concise. It looks almost like weak bisimulation over CCS–like processes. What is rather different, however, is the matching condition, since it involves open extension. In particular, P' and Q' must be compared with respect to all input contexts if µ is an output action. This aspect can be regarded as the essence of context bisimulation.
Definition 2.1 A binary relation R on TI is a context simulation if P R Q
implies:


µ
Whenever P
'	µˆ
Q' and P' R◦ Q'.

If both R and R−1 are such simulations, then R is a context bisimulation. The union of all such bisimulations is denoted by ≈Ct; we call it context bisimilarity.
It should be noted that ≈Ct, being the union of all context bisimulations, is itself a context bisimulation. Also, ≈Ct can be proven to be an equivalence and a congruence [17, 4].
It should be noted too that Definition 2.1adheres to what is known as the
late style of introducing context bisimulation. There is also an early style but

both are equivalent [17].
Normal Bisimulation
To conclude this section, we recall the notion of normal bisimulation. To this end, we need to introduce triggers and replicators formally. A trigger is defined to be a process of the form sI.Nil, where sI is a subject, and where Nil is the constant for inaction, which is understood to be the empty sum; a replicator is defined to be an abstraction of the form λXI.(!sI.XI). Such constructs are denoted by Trs or Reps, respectively, calling sI the subject of the trigger or replicator.
The idea of normal bisimulation consists of simplifying the matching con- ditions for input and output actions drastically. Instead of respectively com- paring the residuals with respect to all inputs or input contexts, they are only compared with respect to one trigger as input or one replicator as input context.
Definition 2.2 A binary relation Y on TI is a normal bisimulation if P Y Q
implies:

Whenever P µI	'
'	µ^I
Q' and P' Y Q'.

Whenever P a—II→?XI P' then, for some Q' and some b with b /∈ fch (P', Q'),
aII?XI	'	'	'
Q =⇒ Q and P [TrbI /XI] Y Q [TrbI /XI].
Whenever P a—II!→YII P' then, for some Q' and some b with b /∈ fch (P', Q'),
aII!YII	'	'	'
Q =⇒ Q and P [RepbI /YII] Y Q [RepbI /YII].
If both Y and Y−1 are such simulations, then Y is a normal bisimulation. The union of all such bisimulations is denoted by ≈Nr; we call it normal bisimilarity.
The characterization is simply as follows (cf. [17]):
Theorem 2.3 (Sangiorgi) ≈Ct = ≈Nr
New SOS for Higher–Order Processes
In the previous section it has been recalled what a classic SOS for higher–order processes with static scoping may look like; this section introduces the new SOS mentioned in the introduction. This SOS is called the alternative SOS. On a preliminary note, a trigger or replicator is connected if its subject is a restricted channel.
As a first approximation to the alternative SOS, one might consider re- placing the axiom for higher–order output — a !P .P a—II!→YII (Y ⟨P ⟩) | P — by
aII!P1.P2 a—II!→YII (YII⟨Trb⟩| Repb⟨P1⟩)\b | P2,


where bI is fresh from ChI. This measure has already the effect of reducing higher–order to trigger communication: Instead of sending P1, the trigger Trb is sent, P1 is left behind attached to a replicator, and both the trigger and the replicator are properly connected by making their common subject private to them. Adopting this axiom in favor of (out–HO), however, is not enough if one wants to characterize context bisimulation as done below; the reason is that the ensuing SOS still involves process passing, albeit on an extremely reduced scale. To solve this problem, process passing is abolished altogether. The SOS does so by moving the creation of triggers to the input axiom and supplanting the communication rule by a connection rule which, predictably, does nothing than to connect triggers and replicators.
Moreover, all subjects of freshly created and not yet connected triggers and replicators are normalized. Whenever such a subject is needed, then each natural contained in the process term in question is increased by one and zero is taken. The reverse operation takes place whenever the connection rule is applied. We call these operations shift and unshift.
Definition 3.1 The shift, , and the unshift, , of a term T are given as follows:   replaces every n or n that occurs in T respectively by n +1 or n +1;  replaces every n or n that occurs in T respectively by n— 1or n — 1. As a side condition,   can be only applied to T if it contains neither 0 nor z.
We continue with going through the structural axioms and rules that make up the core of the alternative SOS. This group includes axioms for higher– order input (in–At) and output (out–At), and a connection rule (con–At). A rule for higher–order interleaving (par2–At) is its fourth member.

(in–At)
This axiom states that an input prefix is executed by shifting the receiving context and substituting the trigger Tr0 for the process variable. In other words, the input of a process via aII is explained in terms of a preemptive input of the trigger Tr0. For example, we have


a?X.b?Y.(X | Y) —a→?
b?Y.(Tr | Y) —b→?
At Tr1 | Tr0.



(out–At)
This axiom states that an output prefix is executed by shifting the process sent, applying the replicator Rep0 to the result, shifting the residual and putting both in parallel. For example, we have


a!(c.Nil).b!( d.Nil) —a→!
Rep ⟨c.Nil⟩|b!( d.Nil) —b→!
At Rep1⟨c.Nil⟩|Rep0( d.Nil),

using (out–At) and standard interleaving (rule par2–At from Table 5).

(par2–At)

This rule states that higher–order actions are propagated over parallel compo- sition by shifting the inactive sub–process. As an example, one might consider what may happen if the processes from the previous two examples are put in parallel:
(1) a?X.b?Y.(X | Y) | a!(c.Nil).b!( d.Nil)

—a→!
At a?X.b?Y.(X | Y) | (Rep0⟨c.Nil⟩| b!( d.Nil))

—a→?
At b?Y.(Tr0 | Y) | (Rep1⟨c.Nil⟩| b!( d.Nil))

The second transition is the interesting one, because its inference involves shifting the sub–process Rep0⟨c.Nil⟩| b!( d.Nil).

(con–At)

for bI /∈ fchI(P' , P' ).	This rule states in which way the triggers and the
1	2
replicator created by complementary input and output actions are connected:
Their subject 0 is replaced by a fresh first–order channel bI, this channel is made private to the triggers and the replicator, and the ensuing process is unshifted.
As an example, one might consider the following extension of (1):
a?X.b?Y.(X | Y) | a!(c.Nil).b!( d.Nil)

—a→!
At a?X.b?Y.(X | Y) | (Rep0⟨c.Nil⟩| b!( d.Nil))

—a→?
At b?Y.(Tr0 | Y) | (Rep1⟨c.Nil⟩| b!( d.Nil))

—r→	 (Tr | Tr ) | (Rep ⟨c.Nil⟩| Rep ⟨ d.Nil⟩) \e,
where e is fresh. The third transition is the interesting one, because it is inferred from


b?Y.(Tr | Y) —b→?
At Tr1 | Tr0 and
Rep ⟨c.Nil⟩| b!( d.Nil) —b→!

At Rep2⟨c.Nil⟩| Rep1⟨ d.Nil⟩.

This remark concludes the description of the specific aspects of the alter- native SOS. All other axioms and rules remain unchanged. The complete set can be found in Table 5.



(pre–At)	α .P —α→I
At P

(in–At)	a ?X .P a—II→?XI	(  (P))[Tr /X ], where Tr =	0.Nil
(out–At)	a !P .P a—II!→YII	Rep ⟨ (P )⟩|  (P ), where Rep0 =(def) (!z.XI)[XI]

(choice–At) πk
µ
.Pk —→At
k implies Σi∈I
πi.P
µ
i —→At
' for each k ∈ I

(par1–At)	P
µ
1 —→At
' implies P1
µ
| P2 —→At
' | P2

(par2–At)	P1
αII
At
' implies P1
| P2
αII
At
' |  (P2)

(sync–At)	P1
aI
At
' implies P2
aI
At
' and P1
| P2
r
At
' | P'

(con–At)	P
a—II→?XI
P' and P
a—II!→YII
P' implies

1	At	1	2
'	'

A t	2	'	'


if ao /∈ cho(µ), o ∈ {I, II}

µ
(rep–At)	P|!P —→At
P' and !P µ	P'

µ
(appl–At)	P [P /X ]
P' implies (λX .P )⟨P	µ	P'

1	2	I
—→At
I	1	2⟩ —→At


Table 5
Alternative structural axioms and rules. The symmetric counterparts of (par1–At), (par2–At), (sync–At) and (con–At) not shown. Note that input and output actions are endowed with variables, just like input and output actions within the context of the SOS from Section 2. The axioms and rules would work
just as well if this endowment was simply omitted. Keeping track of those variables is, however, necessary for proving that context bisimulation and delay bisimulation over the alternative semantics are equivalent. By using the same action format for both kinds of semantics this necessity is taken account of in the easiest way.
Charaterization of Late Context Bisimulation
The previous section has been concerned with introducing what we have called the alternative SOS for higher–order processes with static scoping; this section is initially concerned with stating the characterization of context bisimulation in terms of delay bisimulation over that new SOS. The main part of this section then gives an outline of how that characterization can be proven.

The Theorem
To begin with, the notion of delay bisimulation according to [9] is instanti- ated to the alternative transition semantics. This step is possible since that semantics can meaningfully be regarded as a labelled transition system, also in the sense of [9]. We call the ensuing equivalence alternative bisimilarity. As

for preliminaries, =⇒є	denotes the reflexive and transitive closure of =r⇒ ;
µ	є	µ
=⇒At denotes the relational product of =⇒At and —→At.
Definition 4.1 A binary relation Y on TI is an alternative simulation if P Y
Q implies:


µ
Whenever P
'	µˆ
Q' and P' Y Q'.

—→At P then, for some Q , Q =⇒At
If both Y and Y−1 are such simulations, then Y is an alternative bisimulation. We denote the union of all alternative bisimulations by ≈At and call it alter- native bisimulation bisimilarity.
Predictably, alternative bisimilarity is itself an alternative bisimulation. Also, the following lemma is a prerequisite for proving the characterization theorem:
Lemma 4.2 Alternative bisimilarity is a congruence.
This property can be proven directly, by adapting and extending what is known as Howe’s method (see [4] for the proof and [11] for that method’s original presentation). The congruence property of normal bisimulation does not have any known direct proof (cf. [17]), so the existence of a direct proof of Lemma 4.2 may be rather surprising. One has to bear in mind, however, that normal bisimulation is defined over the standard SOS for higher–order processes, which involves term substitution. The bisimulation game is, at the same time, very much restricted, and this situation seems to be the reason why a direct congruence proof for normal bisimulation is so difficult. The alternative SOS does not involve term substitution; this fact renders the direct proof of Lemma 4.2 possible.
Another important difference between normal and alternative bisimulation is that the normal bisimulation game involves choosing channels that are fresh with respect to residuals. This aspect may appear like a small technicality but in fact it becomes a significant issue as soon as questions such as fully abstract denotational semantics become interesting. Specifically, the naive idea would be to obtain “normal” process unfoldings on the basis of rendering
every transition of the from P a—II→?XI P' as P —a→II? P'[Tr /X ], and on the basis
b	I

of rendering every transition of the form P a—II!→YII
P' as P
—a→II!
P'[Rep
/YII],

where bI /∈ fchI(P') in both cases. The ensuing semantics would not be fully abstract, since bisimilar processes do not necessarily have identical sets of free channels. Analogous situations can be found within the framework of the π–calculus. They are one reason why fully abstract denotational models for the π–calculus took so much longer to develop and are rather different from models for CCS–like processes (see [8], for instance). The alternative behavioral semantics sidesteps the problem. On its basis, it is then possible to interpret higher–order processes so that they are reduced to first–order entities to what seems to be the greatest possible degree (cf. [4] and Section 5).

To conclude this subsection, what is left is to state the characterization of context in terms of alternative bisimilarity:
Theorem 4.3 ≈Ct = ≈At

Outline of the Proof of the Theorem
Prerequisites
Output Residuals
The first prerequisite of the proof of Theorem 4.3 consists of making explicit what terms can occur as output residuals of transitions generated by the SOS from Section 2. We denote individual output residuals by O and the entire set of output residuals over some variable Y by OR(Y). This set is given by
O ::= Y⟨P1⟩| P2 | O | P | P | O | O\ao for P1, P2, P ∈ TI and o ∈ {I, II}. The following lemma validates this definition: part 1states that each resid-
ual of an output action of the form a!Y is an element of OR(Y); part 2 states
that each element of OR(Y), where Y is an arbitrary second–order variable, is a possible output residual.
Lemma 4.4

P —a!→Y
P' implies P' ∈ OR(Y)

For each a ∈ Ch , O ∈ OR(Y) implies P —a!→Y
O, where P is the process

that results from replacing the subterm Y⟨P1⟩| P2 ofO by a!P1.P2.

Factorization
The idea of factorization, which is due to Sangiorgi [17], is the most decisive prerequisite. Here, it can be seen as basically stating that Q can be factored out of every context of the form P[Q/X], up to context bisimulation, using triggers and a replicator. The theorem can also be shown if context bisimulation is replaced by alternative bisimulation. In this capacity, we call it the alternative factorization theorem (AFT).
Theorem 4.5 (Factorization) Suppose Y ∈ {≈Ct, ≈At}.
Let λX.P ∈ TII and Q ∈ TI. Then
P[Q/X] Y  P[Tra/X] | Repa⟨Q⟩  \a whenever a ∈ ChI \ fchI(P, Q).
Let Y ∈ VarII, O ∈ OR(Y), X ∈ VarI, and P ∈ TI(X), the set of first– order terms with free variables in {X}. Then
O[λX.P/Y] Y  O[Repa/Y] | P[Tra/X]  \a whenever a ∈ ChI \ fchI(P, Q).

Bisimulation–Up–To
Another, rather more technical prerequisite is the up–to method of proving bisimilarity. Because this method is so well known, it suffices to state the relevant definitions and lemmas right away. There are only small adaptions to the framework of the present paper.
Definition 4.6 A binary relation Y on TI is a context simulation up to ≈Ct
if P Y Q implies:


µ
Whenever P
'	µˆ
Q' and P' (Y≈
)◦ Q'.

—→ P then, for some Q , Q =⇒	Ct
If both Y and Y−1 are such simulations, then Y is a context bisimulation up to ≈Ct.
Lemma 4.7 For every binary relation Y on TI that is a context bisimulation up to ≈Ct, we have Y ⊆ ≈Ct.
Definition 4.8 A binary relation Y on TI is an alternative simulation up to
≈At if P Y Q implies:


µ
Whenever P
'	µˆ
Q' and P' Y≈ 
Q'.

—→At P then, for some Q , Q =⇒At	At
If both Y and Y−1 are such simulations, then Y is an alternative bisimulation up to ≈At.
Lemma 4.9 For every binary relation Y on TI that is an alternative bisim- ulation up to ≈At, we have Y ⊆ ≈At.
Operational Correspondence
Lemma 4.9 concludes the prerequisites. Turning to the main part of the proof, we first show a correspondence result for the standard and alternative transition semantics, which is as follows:
Every visible standard transition can be transformed into an alternative transition with the same label, and conversely.
– For every invisible standard transition, there is an invisible alternative transition so that the residuals are alternatively bisimilar.
– Conversely, for every invisible alternative transition, there is an invisible standard transition so that the residuals are context bisimilar.
Using this result and the factorization theorems for context and alternative bisimulation, we show, afterward, that alternative bisimulation is a context bisimulation up to ≈Ct and, conversely, that context bisimulation is an al- ternative bisimulation up to ≈At. The equivalence theorem is an immediate consequence of that.
As a technical preliminary for the correspondence lemma, substitutions of the form [X/Tr0] and of the form [Y/Rep0] need to be introduced, where

X ∈ VarI and Y ∈ VarII. It is assumed that α–conversion is invoked so that X
and Y are not accidentally captured.
Lemma 4.10

i. P —α→I
P' implies P —α→I
At P'

P —a?→X P' implies P —a?→X	(  (P'))[Tr /X]
P —a!→Y P' implies P —a!→Y	(  (P'))[Rep /Y]
At	0
r	'	r	'

P —→ P implies, for some P ,P —→At P and P
≈At P

i. P —α→I	P' implies P —α→I  P'
P —a?→X	P' implies P —a?→X  (P'[X/Tr ])
0
P —a!→Y	P' implies P —a!→Y   (P'[Y/Rep ])
At	0
r	'	r	'

P —→At P implies, for some P ,P —→ P and P
≈Ct P

Proof. (Idea) By transition induction. For details see [4].	✷
Note that transforming a standard transition with a higher–order label into an alternative transition requires to shift the residual. Conversely, trans- forming an alternative transition with a higher–order label requires to unshift the residual. Also, the correspondence for silent transitions is weaker than in the other cases, as such transitions may hide communication or connec- tion steps. Specifically, the correspondence for silent steps requires to bring to bear the appropriate factorization theorem. This situation allows one to relate communication to connection only up to bisimilarity.
Concluding the Proof
Proof. (Theorem 4.3, ≈Ct = ≈At) “⊇”: To prove this inclusion, we show that ≈At is a simulation up to ≈Ct. Then, by symmetry, ≈At is a bi simulation up to ≈Ct. The conclusion, ≈Ct ⊇ ≈At, follows by Lemma 4.7.

So suppose P ≈At
µ
Q and P —→
P'. We consider only the case of µ = a!Y

because those of µ = αI, µ = a?X, and µ = τ are easier or very similar. In this case, by Lemma 4.10(1,iii), P —a!→Y	P with P = (  (P'))[Rep /Y] and
further, by P ≈	Q, Q =a⇒!Y	Q with P ≈	Q for some Q . The remaining steps are as follows:

We construct a transition Q
=a⇒!Y
Q' so that  (Q [Y/Rep ]) ≈◦
Q'.

(rightmost arrow in the diagram below)
0	Ct

We show P' (≈At≈Ct)◦ Q', thereby concluding the proof. (dotted line in the diagram below)


P ¸¸¸¸
¸¸a¸!Y
≈At
,,,,, Q
,a,!,Y,,,,,

a!Y
J 
¸¸¸¸Azt ˛
'
,,,,,,,
A¸,t,s
a!Y
cz

P'	(  (P ))[Rep /Y] ≈At Q	  (Q [Y/Rep ]) ≈◦	Q'

,¸	0

(≈At≈Ct)◦
0	Ct ,




As for this step, we distinguish whether Q =a⇒!Y	Q is actually a strong transition of the form Q —a!→Y	Q or a truly weak one of the form
Q —r→	Q —r→	... —r→	Q —a!→Y	Q , where k ≥ 1.
In the first case the desired conclusion is immediate by Lemma 4.10(2,iii),
in the second we show, first, that there exists a Q' so that Q =⇒є	' and
Q ≈Ct Q' for each l ∈ {1,..., k}. We do so by induction on l:
l = 1: Immediate by Lemma 4.10(2,vi). Note that Q =⇒є	Q' is, therefore,
r	'	1

actually a strong transition of the form Q —→ Q1.
l → l + 1: Suppose there exists a Q' so that Q =⇒є	Q' and Q
≈Ct
Q'. We

have QL
r
At
QL+1
, whence Lemma 4.10(2,vi) implies that there exists

 L+1
so that QL
r	 
L+1
and Q
L+1
≈Ct
 L+1
. Then, because ≈Ct
is a

bisimulation, there exists a Q'
so that Q' =⇒є
'
L+1
and Q 
≈Ct
L+1.

This fact implies Q =⇒є
'
L+1
in combination with QL+1
≈Ct
L+1.

In sum, there exists a Q'
so that Q =⇒є
k and Qk
≈Ct
Q' . Obtaining

a Q' so that Q
=a⇒!Y
Q' and   (Q [Y/Rep ]) ≈◦
Q' is now essentially

0	Ct
a matter of repeating the induction step above, this time appealing to
Lemma 4.10(2,iii).
The following diagram depicts this argument for k ≥ 3.


Q 	r	 Q	r
 Q	r
 Q 
Q ¸	a!Y
 Q 

,,,
At 1 ¸¸¸¸¸
At 2 ¸¸¸¸¸
At 3

k  ¸¸¸¸	At

,,,
¸¸¸¸
≈Ct
¸¸¸¸
≈Ct
≈Ct
¸¸¸¸¸

,,,,
¸¸¸¸z 
¸¸¸¸z 

...
a!Y
¸¸z 
 

Ct
,
,,,,
Q2
≈Ct
Q3
≈Ct
Qk
≈Ct
  (Q [Y/Rep0])
◦
Ct

zz
'	є	zQ '
є	zQ '
' 	 z '
k	a!Y

This step consists of closing up the bisimulation up to ≈Ct or, in other words, of meeting the proof obligation P'[λX.R/Y] ≈At≈Ct Q'[λX.R/Y] for each λX.R ∈ TII. Our main tools for doing so are AFT and the (ordinary) factorization theorem. To apply them, we need the following technical prerequisites:
Let b be fresh from ChI.
We have P'[Rep /Y] =   (  (P'))[Rep /Y][b/0]  and, as stated
at the beginning of the proof, (  (P'))[Rep /Y] ≈At Q .	Hence,
P'[Rep /Y] ≈At  (Q [b/0]) since ≈At is preserved by subject replace-
ment.
By the alternative SOS, 0 occurs in Q  exactly once, namely in	the	replicator	sub–term	Rep0.	Hence,	 (Q [b/0])	=

(  (Q [Y/Rep0]))[Repb/Y].
Then the final reasoning is as follows:
P[λX.R/Y]
≈At (P[Repb/Y] | R[Trb/X])\b	; AFT, using (a)
≈At (  (Q [b/0]) | R[Trb/X])\b	; (b), Lemma 4.2
=	(  (Q [Y/Rep0]))[Repb/Y] | R[Trb/X] \b ; (c)
≈Ct (  (Q [Y/Rep0]))[λX.R/Y ]	; factorization theorem
≈Ct Q'[λX.R/Y ]	; (1)
“⊆”: The proof of this inclusion is largely complementary to that of the other one or, in other words, we show ≈Ct to be an alternative bisimulation up to ≈At. The conclusion, ≈Ct ⊆ ≈At, then follows by symmetry and Lemma 4.9.

So suppose P ≈Ct
µ
Q and P —→At
P'. Again we consider only the case

of µ = a!Y since the other ones are easier or very similar.	In this case,

by Lemma 4.10(2,iii), P
—a!→Y
P  with P  =  (P'[Y/Rep ]) and further, by

P ≈Ct
Q, Q =a⇒!Y
Q with P ≈◦
Q for some Q . The remaining steps are

analogous to (1) and (2) in the proof of “⊇”:
We construct a transition Q —a!→Y	Q' so that ( (Q ))[Rep /Y] ≈	Q'. (rightmost arrow in the diagram below)
We show P' ≈At≈Ct Q', thereby concluding the proof. (dotted line in the diagram below)


P ¸¸¸¸¸
¸¸a¸!¸Y
≈Ct
,,,,,, Q
,a,!,Y,,,,,

a!Y
JAt 
¸¸¸z 
'
,,,,,,,,,,,,
a!Y
At cz

P'	  (P [Y/Rep ]) ≈◦	Q	(  (Q ))[Rep /Y]) ≈At Q'

,¸	0
Ct
≈Ct≈At
0	 ,



Step 1is in fact entirely complementary to step 1in the proof of “⊇” and may, therefore, be omitted. As for step 2, this step is significantly simpler than step 2 in the proof of “⊇” and, therefore, constitutes the only part where there is a real difference. Specifically, it does not require to bring to bear any factorization theorem. To see that, let us note the following prerequisites:
By the alternative SOS, 0 occurs in P' exactly once, namely in the repli- cator sub–term Rep . Hence,  (P'[Y/Rep ]) is well–defined and, in con-
0	0
sequence, P' can be represented as (  (  (P'[Y/Rep ])))[Rep /Y].
0	0
By   (P'[Y/Rep ])	≈◦	Q  and the fact that ≈◦	is preserved
0	Ct	Ct
by subject replacement, we have (  (  (P'[Y/Rep ])))[Rep /Y] ≈Ct
0	0
(  (Q ))[Rep0/Y].

Then the final reasoning is simply as follows:
P' = (  (  (P'[Y/Rep ])))[Rep /Y] ; (a)
≈Ct (  (Q ))[Rep0/Y]	; (b)
≈At Q'	; (1) 
This concludes the proof of Theorem 4.3.	✷

Conclusion and Outlook
The preceding sections have been concerned with characterizing context bisim- ulation over higher–order processes with static scoping. The idea of using replication and triggering to reduce higher–order communication in that set- ting to first–order communication has been the basis of all of that. This idea has been implemented in a new way, namely as part of a new operational semantics for higher–order processes, which has been called the alternative operational semantics. It has then been possible to provide the characteriza- tion in terms of delay bisimulation strictly in the sense of [9].
In the introduction it was claimed that this result should allow one to transfer many results and techniques from the world of CCS–like processes more or less directly to higher–order processes. The remainder of this section briefly mentions work that has followed through on that claim. A detailed account can be found in [4].
The topic is the question of how to model higher–order processes with static scoping. This problem can be regarded as interesting since the only published model for higher–order processes deals with the dynamic setting [10].
The model rests in part on the observation that the alternative operational semantics gives rise to a labelled transition system. It also rests on the fact that labelled transition systems are in one–to–one correspondence with specific instantiations of the categorical notion of F–coalgebra (see, for example, [14]), where F is a functor on a category. What is suitable for the purpose of modeling higher–order processes is a category of classes and maps together with a specific functor F. This functor has a unique largest fixed point, which can serve as semantic domain. What is more, that fixed point is a final F– coalgebra. The ensuing (final) coalgebra homomorphism from the coalgebraic representation of the alternative transition system into the fixed point can naturally serve as semantic mapping. It is not difficult to prove that this semantics is fully abstract with respect to alternative bisimulation; thus, by Theorem 4.3, the model is fully abstract with respect to context bisimulation. In this sense it is the first model of its kind. What might be regarded as most remarkable is the method of building it and of proving full abstraction: That method is almost entirely borrowed from the final coalgebra semantics

of CCS–like processes (cf. [14] as well). Only Theorem 4.3 needs to be added to complete the full abstraction proof.
One might object that the model is really a model of first–order processes, as process interpretations are essentially obtained via unfoldings under the (first–order) alternative transition system. In a technical sense, this observa- tion is certainly true; from a conceptual viewpoint, however, it must be pointed out that the whole point of the model consists of reflecting semantically what can be seen as the hidden first–order nature of higher–order processes with static scoping. Moreover, the model does not only contain semantic interpre- tations of higher–order process terms but also semantic interpretations of all term constructors contained in the language, namely as operations on the se- mantic domain. These interpretations are compositional in the sense that the interpretation of a process term is the same as the interpretation of its out- ermost constructor applied to the interpretations of its immediate sub–terms. The crucial point, then, consists of the fact that some of those construc- tor interpretations, by virtue of their compositionality within a higher–order framework, differ significantly from standard coalgebraic interpretations of the corresponding constructors of first–order process algebras. In sum, the model seen in isolation and as a whole, that is, the model including all construc- tor interpretations is not like a model for first–order processes, even if one disregards the conceptual intent behind it.

References
R. Amadio. On the Reduction of CHOCS Bisimulation to π–Calculus Bisimulation. In Concurrency Theory, LNCS 715, pages 112–126. Springer–Verlag, 1993. Proceedings CONCUR conference.
R. Amadio and M. Dam. Reasoning about Higher–order Processes. In Theory and Practice of Software Development, LNCS 915, pages 202–216. Springer–Verlag, 1995. Proceedings TAPSOFT ’95 conference.
E. Astesiano, A. Giovini, and G. Reggio. Generalized Bisimulation on Relational Specifications. In Theoretical Aspects of Computer Science, LNCS 295, pages 207–226. Springer–Verlag, 1988. Proceedings STACS symposium.
M. Baldamus. Semantics and Logic of Higher–Order Procsesses: Char- acterizing Late Context Bisimulation. PhD thesis, computer science de- partment, Berlin University of Technology, 1998.
M. Baldamus and J. Dingel. Modal Characterization of Weak Bisimu- lation for Higher–order Processes (Extended Abstract). In Theory and Practice of Software Development, LNCS 1214, pages 285–296. Springer– Verlag, 1997. Proceedings TAPSOFT ’97 conference.
L. Cardelli and A. Gordon. Mobile Ambients. In Foundations of Soft-

ware Science and Computational Structures, LNCS 1378, pages 140–155. Springer–Verlag, 1998. Proceedings FoSSaCS ’98.
R. De Nicola and M. Hennessy. Testing Equivalences for Processes. The- oretical Computer Science, 34:83–133, 1983.
M. Fiore, E. Moggi, and D. Sangiorgi. A Fully Abstract Model for the π–Calculus. In Logic in Computer Science, pages 43–54. IEEE Computer Society Press, 1996. Proceedings LICS symposium.
R. van Glabbeek. The Linear Time – Branching Time Spectrum II. In Concurrency Theory, LNCS 715, pages 66–81. Springer–Verlag, 1993. Proceedings CONCUR conference.
M. Hennessy. A Fully Abstract Denotational Model for Higher–Order Processes. Information and Computation, 112(1):55–95, 1994.
D. Howe. Equality in Lazy Computation Systems. In Logic in Computer Science, pages 198–203. IEEE Computer Society Press, 1989. Proceedings LICS ’89 symposium.
R. Milner. Communication and Concurency. Prentice Hall International, 1989.
R. Milner, J. Parrow, and D. Walker. A Calculus of Mobile Processes, Parts I/II. Information and Computation, 100:1–77, 1992. Journal version of two technical reports from 1989.
J. Rutten and D. Turi. Initial Algebra and Final Coalgebra Semantics for Concurrency. In A Decade of Concurrency — Reflections and Per- spectives, LNCS 803, pages 530–583. Springer–Verlag, 1994. Proceedings REX school/symposium.
D. Sangiorgi. Expressing Mobility in Process Algebras: First–Order and Higher–Order Paradigms. PhD Thesis CST–99–93, Department of Com- puter Science, The University of Edinburgh, 1993.
D. Sangiorgi. From π–Calculus to Higher–order π–Calculus — and Back. In Theory and Practice of Software Development, LNCS 668, pages 151–
161. Springer–Verlag, 1993. Proceedings TAPSOFT conference.
D. Sangiorgi. Bisimulation in Higher–order Calculi. Information and Computation, 131:141–178, 1996.
D. Sangiorgi. π–Calculus, Internal Mobility, and Agent–Passing Calculi.
Theoretical Computer Science, 167:235–274, 1996.
B. Thomsen. A Calculus of Higher–Order Communicating Systems. In Principles of Programming Languages, pages 143–154. ACM, 1989. Pro- ceedings POPL conference.
