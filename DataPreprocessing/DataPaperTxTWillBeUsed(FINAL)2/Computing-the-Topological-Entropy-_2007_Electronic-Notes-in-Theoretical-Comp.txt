	Electronic Notes in Theoretical Computer Science 167 (2007) 131–155	
www.elsevier.com/locate/entcs

Computing the Topological Entropy of Shifts
Christoph Spandl1
Institut fu¨r Theoretische Informatik und Mathematik Universit¨at der Bundeswehr Mu¨nchen
D-85577 Neubiberg, Germany

Abstract
Different characterizations of classes of shift dynamical systems via labeled digraphs, languages and sets of forbidden words are investigated. The corresponding naming systems are analyzed according to reducibility and particularly with regard to the computability of the topological entropy relative to the presented naming systems. It turns out that all examined natural representations separate into two equivalence classes and that the topological entropy is not computable in general with respect to the defined natural representations. However, if a specific labeled digraph representation
- namely primitive, right-resolving labeled digraphs - of some class of shifts is considered, namely the shifts having the specification property, then the topological entropy gets computable.
Keywords: Shift dynamical systems, topological entropy, Type-2 computability, labeled digraphs.


Introduction
Dynamical systems theory is an established part of mathematics with many applications in engineering and science [9]. Consider the class of topological dynamical systems, that is only topological aspects are examined as opposed to differential or measure theoretic concepts for example. A main question in topological dynamics is the following. Given two dynamical systems (M, f ) and (N, g) where M, N are compact topological spaces and f : M → M,
g : N → N continuous mappings, is there a topological conjugacy ϕ : M →
N between them, that is a homeomorphism commuting with the mappings:
ϕ ◦ f = g ◦ ϕ? In other words, are (M, f ) and (N, g) equivalent from a topological point of view?

1 Email:christoph.spandl@unibw.de




1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.08.011

Adler, Konheim and McAndrew [1] introduced topological entropy, being one of a couple of invariants of topological conjugacy. Since then, topologi- cal entropy grew to a useful tool for classifying concrete dynamical systems according to conjugacy. Later on, Dinaburg and Bowen gave a new defini- tion using metric spaces. It turned out that both definitions coincide if the topology is generated by the metric.
In the case of shift dynamical systems, called shifts for short, the topo- logical entropy can be expressed by a simple formula. Shifts are pairs (X, σ) of a compact metric space X and a uniformly continuous, bijective mapping σ : X → X where X is a closed subset of all bi-infinite sequences over some
(finite) alphabet and σ is the usual left shift map. Shifts emerge in a natural
way out of any topological dynamical system (M, f ) where f is bijective [2]. Consider any finite partition {Pi : i = 0,..., n} of M, then there is a map ψ : M → {0,..., n} defined by x ∈ Pψ(x) for all x ∈ M. Therefore, a map Ψ: M → {0,..., n}Z is obtained by setting Ψ(x)= y :⇔ ψ(fi(x)) = yi for all i ∈ Z, x ∈ M. This assignment is the link to shift dynamical systems since Ψ ◦ f = σ ◦ Ψ holds. On the other hand, symbolic dynamics, the part of topo-
logical dynamical systems theory concerned with shifts, is a self-contained
part of mathematics with connections to automata theory, language theory and the theory of codings with many applications [12,10,14].
The topological entropy h(X) of a shift (X, σ) is given by h(X) = lim log R(n)
n→∞	n
where R(n) is the number of distinct words of length n occurring in elements of
X. Due to the Perron-Frobenius theory of nonnegative matrices, the calcula- tion of the topological entropy is possible for a wide class of shifts. Therefore, the question arises if the calculation can be made effective. There have been several attempts in calculating the entropy of (general) dynamical systems, see
[13] for a short survey. In [16], the computability of the topological entropy of shifts is examined as well. A discussion of similarities and differences to the present work is given in Section 8.
The work presented in the following is based on Type-2 computability the- ory [17]. First, several definitions respectively characterizations of shift spaces are examined. Then, corresponding “natural” naming systems are defined on the basis of these definitions (characterizations). The naming systems are compared using the concept of reducibility. Finally, the question is treated if these naming systems are appropriate with regard to the computability of the topological entropy.
The paper is outlined as follows. In the next section, some basic notation is given. In Section 3, different characterizations of shift spaces are presented. The following Section 4 deals with the corresponding naming systems and their equivalence. After that, in Section 5 the Perron-Frobenius theory is pre-

sented, building the mathematical basis for computing the entropy. Finally, in Section 6 the focus is on the main subject: computing the topological entropy effectively. In the following Section 7, a specific class of shifts is examined, having an easy to manage entropy characterization. The last Section 8 is devoted to some discussion.

Notation
Let A be an alphabet, i.e. a nonempty finite set.In the following, only alpha- bets with |A| ≥ 2 are considered and the letters are set to 0, 1,...,n with n = |A| − 1. Then A∗ denotes the set of all finite words over A and Aω the set of all infinite sequences over A, i.e. Aω = {f : f : N → A}. The set of all bi-infinite sequences over A is denoted by AZ. The empty word is denoted by λ. For every w ∈ A∗, |w| denotes the length of w. The concatenation of words u and v of A∗ is denoted by uv. Let r, u, v, w ∈ A∗ and w = ruv. Then r is called a preﬁx of w, in symbols r ± w and u is called a subword of w, in symbols u a w. In addition, u и w denotes u ± w and u /= w. For any word w ∈ A∗ and i, j ∈ N, w[i,j] := wi ... wn is the subword of w with n := min(j, |w|− 1) if i ≤ j and i < |w|, as well as w[i,j] := λ otherwise. If p ∈ Aω and i, j ∈ N, then p[i,j] ∈ A∗ denotes the word p[i,j] = pipi+1 ... pj if i ≤ j and p[i,j] = λ if i > j.
A partial function is denoted by f :⊆ X → Y , a total function by f : X → Y . A (partial) function f :⊆ Z1 ×··· × Zk → Z0 with Z0, Z1 ... Zk ∈ {A∗, Aω} is called computable, if it is computable by a Type-2 Turing machine. All
concepts concerning Type-2 computability used here are in the sense of [17].
Following [17], an effective topological space is a triple S = (X, β, ν) where
X is a topological space, the topology being defined by the countable set β ⊆ 2X as subbase and ν :⊆ A∗ → β is a notation of β. Furthermore require that X is a T0-space, that is for any x, y ∈ X, when {B ∈ β : x ∈ B} = {B ∈ β : y ∈ B}, then x = y holds. The standard representation δ :⊆ Aω → X of an effective topological space S = (X, β, ν) is defined by δ(p)= x :⇔ {B ∈ β : x ∈ B} = {ν(u): ι(u) a p} and ι(w) ap ⇒ w ∈ dom(ν) for all x ∈ X and p ∈ Aω. Otherwise set δ(p) ↑. Here, the function ι : A∗ → A∗ is defined by ι(a1 ... an) := 110a10 ... 0an011 for all n ∈ N and all words a1 ... an ∈ A∗.

Characterization of Shifts
The approach presented here is adapted from [12,3]. Let A be an alpha- bet. Consider AZ as a metrizable topological space endowed with the product

topology of the discrete topology on A. Then the shift map σ : AZ → AZ, defined by σ(x)i = xi+1 is a homeomorphism. If X ⊆ AZ has the properties
X is closed and
X is shift invariant, that is, σ(X)= X holds,
then X is called a shift space and the pair (X, σ) is called a shift dynamical system or shift for short.
There are other equivalent characterizations of a shift space X. First the
definitions via sets of words. Consider a subset F ⊆ A∗. Then define a set
X	⊆ AZ the following way: start with AZ and remove all elements having a
subword which is in F. Then XF is closed and shift invariant, hence a shift
space. The set F is called a set of forbidden words of the shift space XF . On the other hand, for any shift space X there is a subset F ⊆ A∗ such that X = XF . So, the set of forbidden words determines a shift space uniquely. The converse does not hold.
A set S ⊆ A∗ is called factorial, if for any word u ∈ S, every subword of u also is in S. A set S ⊆ A∗ is called extendable if for any word u ∈ S, there are nonempty words v, w ∈ A+ such that vuw ∈ S holds. The set L ⊆ A∗ of all words in A∗ that are subwords of elements in X is called the language of X. Then L is factorial and extendable. On the other hand, let L ⊆ A∗ be factorial and extendable, then there is a uniquely determined shift space having L as its language. The language of a shift space X is denoted by A∗(X).
There is also a characterization via finite or countable directed graphs.
A directed graph or digraph Γ is a pair (V, E) where V and E are disjoint, finite or countable sets, together with two maps i : E → V and t : E → V .
V is called the set of vertices and E is called the set of edges. The maps i
and t assign to each edge e ∈ E some pair of vertices (α, β) where e starts at vertex i(e) = α and terminates at vertex t(e) = β. (In the literature, some authors call digraphs “directed multigraphs”.) A digraph Γ is called irreducible, if, given two vertices α, β ∈ V , there is a path in Γ connecting them (in the literature, also the expression “strongly connected” is used). A digraph Γ is called primitive, if, given two vertices α, β ∈ V , there exists an N ∈ N such that for any n ≥ N there is a path in Γ of length n connecting α and β. A primitive digraph also is irreducible. Finally a labeled digraph is a pair (Γ, ϕ) where Γ is a digraph with edge set E and ϕ : E → A, called the labeling, is a map assigning to each edge e of Γ an element in the alphabet
A. Let EZ(Γ) ⊆ EZ be the set of all bi-infinite paths in Γ. Then there exists a function Φ : EZ(Γ) → AZ assigning to each path γ ∈ EZ(Γ) the bi-infinite sequence of labels corresponding to the path γ. Namely if γ = (ei)i∈Z, then Φ(γ) = (ϕ(ei))i∈Z. Furthermore, the function Φ is uniformly continuous and

shift invariant, that is σ ◦ Φ= Φ ◦ σ holds. The set Φ(EZ(Γ)), which will be denoted by AZ(Γ), is shift invariant, but does not need to be closed. Then the closure AZ(Γ) is a s hift space X. So, any labeled digraph (Γ, ϕ) determines a shift space X = Φ(EZ(Γ)) in a unique way. For simplicity, only labeled digraphs with no stranded vertices and no multiple labeling are considered in the following. Here, a vertex α is called stranded for the digraph Γ, if there is no bi-infinite path in Γ having an edge e with i(e) = α. Multiple labeling of a labeled digraph (Γ, ϕ) means that there exist two distinct edges e, g ∈ E, e /= g, with i(e) = i(g), t(e) = t(g) and ϕ(e) = ϕ(g), that is e and g have the same initial vertex, terminal vertex and label. A labeled digraph (Γ, ϕ) with no stranded vertices and no multiple labeling is called a cover of the shift space X = Φ(EZ(Γ)). Any shift space has a cover.
A countable labeled digraph directly suggests the definition of a shift dy- namical system over some countable alphabet. Let B be a countable set, called a countable alphabet. BZ, endowed with the product topology of the discrete topology on B is a metrizable space. The shift map σ : BZ → BZ
is uniformly continuous on BZ. If Y ⊆ BZ is closed and shift invariant, then
Y is called a (countable) shift space and (Y, σ) a shift. Note that Y is not
necessarily compact.
The set EZ(Γ) for some finite or countable digraph Γ is closed and shift invariant, hence a shift space. The corresponding shift is called the edge shift of the digraph Γ.
Finally some definitions concerning shifts. Let X be a shift space having a finite cover. Then X is called a soﬁc shift. If X is a shift space owning a finite set of forbidden words, then X is called a shift of ﬁnite type. Any shift of finite type is sofic, but the converse does not hold. Let X be a shift space having a countable cover where the corresponding digraph is irreducible. Then X is called a coded system [5]. A shift X is called topologically transitive if for any
pair of words u, v ∈ A∗(X) there is a word w ∈ A∗(X) such that uwv ∈ A∗(X) holds. Consequently, if X has an irreducible cover, then X is topologically transitive. Conversely however, not every cover of a topologically transitive shift need to be irreducible. A shift space is called topologically mixing if for any pair of words u, v ∈ A∗(X) there exists an N ∈ N such that for all n ≥ N there is a word w ∈ A∗(X) of length n such that uwv ∈ A∗(X) holds. Any topologically mixing shift is topologically transitive, the converse does not hold. If X has a primitive cover, then X is topologically mixing. Finally, a synchronizing word of a shift space X is a word w ∈ A∗(X) such that for any u, v ∈ A∗(X), if uw ∈ A∗(X) and wv ∈ A∗(X) then also uwv ∈ A∗(X) holds. Here some examples to illustrate the definitions above. The alphabet A =
{0, 1} is the binary alphabet.

Example 3.1 First consider the following shifts of finite type X ⊆ {0, 1}Z.
X is defined by the set of forbidden words F := {01} having exactly one element. Then X reads X = {σi(x) : i ∈ Z}∪ {0Z, 1Z} where x ∈ {0, 1}Z is defined by x := ... 11.00 ... . By definition, there is no word w ∈ A∗(X) such that 0w1 ∈ A∗(X) holds. Hence X is not topologically transitive. Furthermore, 00 is a synchronizing word of X.
X is defined by the set of forbidden words F := {00, 11}. Then X reads
X = {(01)Z, (10)Z}. X is topologically transitive since for any pair of allowed words u, v ∈ A∗(X), either uv, u0v or u1v is an allowed word. But X is clearly not topologically mixing. Finally, 01 is a synchronizing word of X.
The golden mean shift X is defined by the set of forbidden words F := {00}. Let u, v ∈ A∗(X) then u1nv ∈ A∗(X) holds for all n ≥ 1. Hence X is topologically mixing. The word 1 is a synchronizing word of X.
Example 3.2 The even shift X ⊆ {0, 1}Z defined by the set of forbidden words F := {102n+11: n ∈ N} is sofic but not of finite type. A corresponding cover is given in Figure 1. If X were of finite type, there would exist a finite set F' of forbidden words characterizing X. Hence, there would be an M ∈ N such that all words in F' do have length ≤ M + 1. Since 102M+1 and 02M+11 are allowed words, 102M+11 ∈ A∗(X) would follow (see Theorem 2.1.8 in [12]). But this is a contradiction.
0
1 
0
Fig. 1. Cover of the even shift.

Finally an example with alphabet A = {0, 1, 2}.
Example 3.3 The context free shift X ⊆ {0, 1, 2}Z is defined the following way. Consider the set L' ⊆ {0, 1, 2}∗ defined by L' := {0n1n2: n ≥ 1}. Then the language L of X is defined by L := {u ∈ A∗ : u is a subword of some v ∈ L'∗}. Then X is a coded system but is not sofic. A corresponding infinite cover is given in Figure 2. If X were sofic, the subset S := {0n1n : n ≥ 1} of
{0, 1}∗ would be a regular language in terms of formal language theory. But
this is not true, which can be shown with the Pumping Lemma.
Note that 0Z ∈ X but 0Z is not the sequence of labels of any path in the digraph.


... 
... 




Fig. 2. Cover of the context free shift.
Naming systems for shift spaces
Let some finite alphabet A be given. Consider a shift space X over A, endowed with the product topology. Let A∗(X) denote the language of X and An(X) the words of A∗(X) with length n. Furthermore, without loss of generality, let the alphabet A be chosen so that A1(X)= A. X is a metrizable topological space where a basis of the topology is given by the cylinder sets [w]X := {x ∈ X : xn+i = wi, 0 ≤ i < |w|} for all w ∈ A∗(X), n ∈ Z. Next consider the set of all shift spaces over A, Xσ := {X ⊆ AZ : X is closed and σ(X)= X}.
Define effective topological spaces (in analogy to the Definition 5.1.1 in
[17]) Sσ := (Xσ, βσ , νσ ) and Sσ := (Xσ, βσ , νσ ), where the topology on Xσ
<	<	< σ	>	σ	>	>
is generated by βσ ⊆ 2X  (βσ ⊆ 2X  respectively) as a subbase, the following

way. The notations νσ :⊆ A∗ → βσ and νσ :⊆ A∗ → βσ
are defined by

<	<	>	>
νσ (⟨w, ν−1(n)⟩) := {X ∈ Xσ : [w]AZ ∩ X /= ∅}
<	Z	n
νσ (⟨w, ν−1(n)⟩) := {X ∈ Xσ : [w]AZ ∩ X = ∅}
>	Z	n
for all w ∈ A∗ and n ∈ Z. Here, νZ : A∗ → Z is some bijective standard notation of the integers.
Now consider the associated standard representations δσ :⊆ Aω → Xσ
of Sσ , δσ :⊆ Aω → Xσ of Sσ and δσ := δσ ∧ δσ .  It turns out that the
<	>	>	<	>
first two representations are equivalent to the enumeration representation of
the language and of the maximum set of forbidden words of the shift space, respectively. Let EnL :⊆ Aω → Xσ be given by EnL(p) = X :⇔ {w ∈ A∗ : ι(w) a p} = A∗(X). Analogously, let EnF :⊆ Aω → Xσ be given by EnF (p)= X :⇔ {w ∈ A∗ : ι(w) a p} = A∗ \ A∗(X). Then the following holds.

Theorem 4.1 The standard representation δσ is equivalent to EnL and δσ is
equivalent to EnF .
Proof. First show δσ ≡ EnL. Let p ∈ dom(δσ ) be given and X := δσ (p).
<	<	<
Then, by definition of δσ , {A ∈ βσ : X ∈ A} = {νσ (⟨w, ν−1(n)⟩): ι(⟨w, ν−1(n)⟩)a
<	<	<	Z	Z
p} holds. Hence, ι(⟨w, ν−1(n)⟩) ap ⇔ [w]AZ ∩ X /= ∅ can be concluded. On
Z	n

the other hand, by the definition of the language of X and shift invariance,
[w]AZ ∩X /= ∅ ⇒ w ∈ A∗(X) as well as w ∈ A∗(X) ⇒ ∀n ∈ Z [w]AZ ∩X /= ∅
n	n
holds.	Finally, for all n ∈ Z, ι(⟨w, ν−1(n)⟩) a p	⇔	w ∈ A∗(X) is de- rived. Now it is easily seen that there are computable translation functions
f1, f2 :⊆ Aω → Aω with EnL(p1)= δσ ◦ f1(p1) and δσ (p2)= EnL ◦ f2(p2) for
<	<
all p1 ∈ dom(EnL), p2 ∈ dom(δσ ).
The assertion δσ ≡ EnF is shown analogously.	 
As a direct consequence:
Corollary 4.2 The equivalence δσ ≡ EnL ∧ EnF holds.
Instead of using the standard representations, the admissible enumeration representations can be used. It turns out, that for computing the topological entropy of a shift space X, a naming system based on covers is superior to EnL.
Let (Γ, ϕ) be a finite labeled digraph with no stranded vertices and no multiple labeling. Then (Γ, ϕ) can be represented by a finite set G ⊆ A∗ of words, with ⟨ui, ut, a⟩ ∈ G iff (ui, ut) ∈ A∗ × A∗ represent the edges and a ∈ A represents the corresponding label. So, a name of (Γ, ϕ) is a word u ∈ A∗ with ι(w) au iff w ∈ G. Since (Γ, ϕ) has no stranded vertices and no multiple labeling, (Γ, ϕ) also is the cover of a uniquely determined shift space
X. Hence, u is also called a name of X. The shift spaces owning names are exactly the sofic shifts Xσ,s. Now define a notation νG :⊆ A∗ → Xσ,s of Xσ,s, called the graph notation by νG (u) = X iff {w : ι(w) a u} = G where G is a cover of X.
Let X be any shift space over A. Then there is a countable cover (Γ, ϕ) of
X. So, (Γ, ϕ) can be represented by a countable set G ⊆ A∗. A representation EnG :⊆ Aω → Xσ of all shift spaces can be defined similarly. It turns out that EnG is equivalent to EnL.
Proposition 4.3 Let EnG :⊆ Aω → Xσ be the graph representation and EnL :⊆ Aω → Xσ the language enumeration representation of Xσ, then EnG ≡ EnL holds.
Proof. First show EnG ≤ EnL. Let M be a Type-2 machine doing the follow- ing. Consider an EnG-name p as input for M. Then M works in steps n ≥ 1. Each step begins with the construction of a finite part of the corresponding labeled digraph by reading a prefix of p of length n. Then the whole subgraph is traversed at each vertex and all words of labels of length ≤ n are recorded and written to the output. After that the next step begins. Since a cover has no stranded vertices, all words in the language of the shift space are written
to the output tape.

Second show EnL ≤ EnG. There is also a Type-2 machine N doing the reverse on an EnL-name p as input. N also works in steps n ≥ 1. Each step begins with the determination of the n-th word u ∈ A∗(X) of the language of X listed in p. In the second part of each step the subgraph is constructed.
At each step, the digraph Γ consists of a finite number of linear chains not being connected to each other. Every chain is labeled by some word already read in the previous steps. If u is a subword of some word being the label of a chain, then go to step n + 1. Else, for all chains where the label is a word v such that u = w1vw2 holds with w1, w2 ∈ A+, extend the chain in
both directions such that the new chain is labeled by u. If there is no such
chain at all, construct a new chain labeled by u. Then write the constructed extension or the constructed new chain respectively to the output tape and proceed with the next step. By the construction, each word in the language is the label of some finite path in the digraph and any chain extends to infinity in both directions. Therefore the set of all bi-infinite labels of paths in Γ are dense in X. Hence N computes an EnG-name of X.	 
Finally turn to the set of shifts of finite type Xσ,f . Then there is a notation νF : A∗ → Xσ,f of Xσ,f , called the forbidden words notation. It is defined by νF (u)= X iff {w : ι(w) a u} = F where F is a finite set of forbidden words of
X. The following propositions are useful.
Proposition 4.4 There is a computable function χL : A∗ ×A∗ → {0, 1} such that for all u, w ∈ A∗, χL(u, w)= 1 iff w ∈ A∗(νF (u)).
For the proof, the notion of adjacency matrix is needed. Therefore, the proof is given in subsection 5.1, where this notion will be explained.
Proposition 4.5 Let νG :⊆ A∗ → Xσ,s be the graph notation and νF : A∗ →
Xσ,f the forbidden words notation, then νF ≤ νG holds.
Proof. It has to be shown that there is a computable function f : A∗ → A∗ such that for all u ∈ A∗, representing a finite set of forbidden words F for some shift space X ∈ Xσ,f , f (u) ∈ dom(νG) holds and f (u) represents a finite labeled digraph which is a cover of X.
The cover can be constructed in the following way. If F is empty, then
X = AZ and a corresponding cover consists of one vertex α and |A| edges starting at α and terminating at α being labeled with the complete alphabet. Otherwise, there exists some maximum length M ≥ 1 of the forbidden words in F. If M = 1, then X = (A\F)Z and the corresponding cover is a subcover of the above one. Specifically if F = A, then X = ∅ and f (u)= λ.
So let M ≥ 2. Then the vertex set is given by AM−1(X). According to Proposition 4.4, AM−1(X) and AM (X) can be uniformly effectively listed,

given a νF name of X. Now for u1, u2 ∈ AM−1(X), (u1, u2) is an edge of the labeled digraph iff u1 = au and u2 = ub for some a, b ∈ A and u ∈ AM−2, as well as aub ∈ AM (X). If so, the edge (u1, u2) is labeled with b.	 
Proposition 4.6 There is a computable function f :⊆ A∗ → A∗ with dom(f )= 
ν−1(range(νF )) and νG(u)= νF ◦ f (u) for all u ∈ dom(f ).
Proof. First note that if X is a shift of finite type, then there is an M ≥ 1 such that there is a set of forbidden words all of them having length M.
Consider the following algorithm, working in stages n ≥ 1. Since the cover G of X has no stranded vertices, An(X) can be uniformly effectively listed by traversing the labeled digraph at each vertex for n steps. Now consider the shift of finite type Y with the set of forbidden words being An \ An(X). Construct a corresponding labeled digraph G' according to Proposition 4.5.
Then according to Theorem 3.4.13 in [12], it can be effectively decided wether
X and Y are the same by comparing their covers. If they are not the same, proceed with stage n + 1, otherwise write a νF -name corresponding to An \ An(X) to the output and stop.
By the construction of the algorithm it is clear that the algorithm stops at
stage M iff X is of finite type and X /= AZ and stops at stage 1 if X = AZ. Therefore, the algorithm outlined above computes f .	 
Remark: According to Theorem 3.4.17 and 3.4.14 in [12], there is a com- putable function χf :⊆ A∗ → {0, 1} such that u ∈ dom(χf ) if u is a name of a cover of a topologically transitive sofic shift X, and χf (u)= 1 iff X is a shift of finite type.

Adjacency Matrices and Entropy
Let (Γ, ϕ) be a labeled digraph (countable or finite), V be the set of vertices of Γ. An adjacency matrix of (Γ, ϕ), A = (Aαβ)(α,β)∈V 2 with nonnegative elements is defined in the following way. Let α, β ∈ V then Aαβ ∈ N is the number of edges starting at vertex α and terminating at vertex β.
The topological entropy h(X) of a shift dynamical system (X, σ) over some finite alphabet A is defined by

h(X) := lim
n→∞
log |An(X)|
n
(1)

if X /= ∅ and h(∅) := 0. The topological entropy is a “growth rate” of the number of occurring words for a given length. Note that the entropy is bounded by 0 ≤ h(X) ≤ log |A|. Note that the limit always exists (Proposition 4.1.8 in [12]).

The Finite Case
In this subsection, finite adjacency matrices are considered. Hence, the re- garded shifts are sofic. The following proposition is easily seen.
Proposition 5.1 There are computable functions dimG :⊆ A∗ → N and AG :⊆ A∗ × N2 → N with dimG(u) = n and AG(u, i, j) = Aij for all u ∈ dom(νG), i, j ∈ {1,... , n} where A is the n by n adjacency matrix of the labeled digraph named by u.
Now some basic facts about finite adjacency matrices and Perron-Frobenius theory. References are [7,15].
A finite adjacency matrix A is called reducible if there exists a permutation matrix P such that P AP T has the form
T	⎛B 0 ⎞
P AP	=	.
∗ C
Here, B and C are square matrices. In other words, the above form is obtained by rearranging the indices of the original matrix. If A is not reducible, it is called irreducible. Irreducible matrices do have a fundamental property: If A is an n by n irreducible matrix, n ≥ 1, then A is the one by one matrix (0), or
for any pair of indices i, j ∈ {1,... , n} there is some l > 0 such that (Al)ij > 0 holds. Note that a labeled digraph is irreducible, iff its corresponding adja-
cency matrix is irreducible. An irreducible matrix is called primitive, if for any pair of indices i, j ∈ {1,..., n} there is some N ∈ N such that (Al)ij > 0 holds for all l ≥ N. Note that a directed labeled digraph is primitive, iff its corresponding adjacency matrix is primitive.
Any finite adjacency matrix A has a normal form: There exists a permu- tation matrix P such that P AP T has the form
⎛A1	0 ...	0	0	... 0 ⎞
⎜ 0  A2 ...	0	0	... 0 ⎟
⎜... ... ... ...	... ... .. .⎟
P AP T = ⎜ 0	0 ... A	0	... 0 ⎟
⎜ ∗	∗ ...	∗ Ag+1 ... 0 ⎟
⎝ ∗	∗ ...	∗	∗	... As⎠

where A1,... , As are irreducible square matrices and in each block row > g there is at least one matrix with block column strictly less than the block row which is not the zero matrix. The normal form is unique up to permutations of blocks and of indices within each diagonal block.
There are n! different permutation matrices P for an irreducible n by n square matrix. Therefore, following the steps of construction of the normal form presented in [7], it is clear that there exists an algorithm computing the normal form provided the matrix A as input. Due to Proposition 5.1, the following theorem holds.
Theorem 5.2 Let u ∈ dom(νG) be the (graph) name of some soﬁc shift space. Let N be the normal form of the adjacency matrix of the graph named by u (the index set is 1,..., n). Then the following functions are computable.
irG :⊆ A∗ → N,
dimG :⊆ A∗ × N → N and
NG :⊆ A∗ × N2 → N.
Here, irG(u) = s is the number of irreducible components of N, dimG(u, i) equals n if i =0 and equals the number of rows of the i-th irreducible compo- nent if i ∈ {1,..., s}. Finally NG(u, i, j)= Nij for all i, j ∈ {1,... , n}.
Before coming to the central Perron-Frobenius theorem a word on types of indices of an adjacency matrix A = (aij). An index i of A is called transient if its corresponding (permuted) index j in normal form is such that ajj forms a one by one irreducible block and ajj = 0. A finite sequence (si)1≤i≤m is called a chain of length m ≥ 1, if asisi+1 > 0 for all i = 0,...,m − 1. An index i of
A is called absorbing, if there is an upper bound for the length of all chains
starting at i. Then the following holds.
Lemma 5.3 An index i is absorbing iff it is transient and all chains starting with i have only transient indices.
Proof. Let i be an absorbing index and (sk)1≤k≤m a chain of length m starting at i. Then sk is transient for all k ∈ {1,..., m}. Assume otherwise. Then there is some l ∈ {1,..., m} such that sl is not transient. Hence, sl belongs to an irreducible block of the normal form with at least one strictly positive entry. Consequently, there are chains of any length starting at sl. But then, i would not be absorbing.
On the other hand, let i be transient and all chains starting at i have only transient indices. Let (sk)1≤k≤m be a chain of length m starting at i. Then i = s1 > s2 > ··· > sm holds. Hence there is only a finite number of different chains starting at i. As a consequence, i is absorbing.	 

Combining the results developed so far, the following proposition can be concluded.
Proposition 5.4 There exists an algorithm deciding if an index is absorbing or not uniformly in the adjacency matrix A.
Proof. Follows directly from Theorem 5.2 and the above lemma.	 
Now the proof of Proposition 4.4 can be given.
Proof of Proposition 4.4. Let u ∈ A∗ be given and let J be the set of

forbidden words of X := νF
(u) corresponding to u. If J is empty then X = AZ

and χL(u, w) = 1 for all w ∈ A∗. If J is not empty, there exists an M ≥ 1 such that M is the maximum length of all elements in J. If M = 1, then

X = (A \ J)Z and χ
(u, w) = 1 iff no symbol a ∈ J is a subword of w.

Finally consider the case M ≥ 2. Set N := |A|M . Let ν : {1,...,N} → AM be the lexicographical ordering of AM . Consider the N by N adjacency matrix A = (aij) defined by aij := 1 if ν(i)[1,M−1] = ν(j)[0,M−2] and there is no word w ∈ J a subword of either ν(i) nor ν(j). Otherwise set aij := 0. It is clear that there is an algorithm constructing A uniformly in u.
Now consider some word w ∈ AM . Then w ∈ AM (X) iff w is not an absorbing index of A and of AT . Only in this case exists an infinite extension of w to the right and to the left. Next let w ∈ A∗. If |w| < M then w ∈ A∗(X) iff there is some word v ∈ AM (X) having w as prefix. If |w| ≥ M consider the suffix v of w of length M. Then w ∈ A∗(X) iff w[0,M−1] ∈ A∗(X), v ∈ A∗(X) and there exists a chain from ν−1(w[0,M−1]) to ν−1(v). By the above proposition it is clear that the assertion in Proposition 4.4 holds.	 
The Perron-Frobenius theorem states the following: Let A be a finite irre- ducible adjacency matrix A /= (0). Then A has a positive eigenvector, called the Perron eigenvector, with corresponding positive eigenvalue, called Perron value, which is both geometrically and algebraically simple. Furthermore any
eigenvalue for A does not exceed the perron value in magnitude.
There is a link between topological entropy and the Perron value [12,10]. Let (Γ, ϕ) be a finite cover of some shift space X. The cover is said to be right-resolving if for any two edges e1, e2 ∈ E with i(e1) = i(e2), ϕ(e1) /= ϕ(e2) holds. Every sofic shift has a finite right-resolving cover. Let A be the adjacency matrix of a finite right-resolving cover of X. Assume that A /= (0) is irreducible. Then h(X)= log λA holds where λA is the Perron value of A. If A is not irreducible, then h(X)= log maxi λAi where Ai are the irreducible components of A.
The proof of the fact that every sofic shift has a finite right-resolving cover presented in [12] shows that there is a computable function f :⊆ A∗ → A∗

assigning to each name u ∈ dom(νG) of X a name f (u) ∈ dom(νG) representing a finite right-resolving cover of X.

The Countable Case
Let d be a metric on some shift space X over a finite or countable alphabet. Let K ⊆ X be a compact subset of X. A subset E of X is called a (K, n, ϵ) spanning set, if for any y ∈ K there is an x ∈ E with d(σi(x), σi(y)) < ϵ for all i ∈ {0,...,n − 1}. Let rd(K, n, ϵ) be the minimum cardinality of a (K, n, ϵ) spanning set. Define the topological entropy of (X, σ) with respect to d by
h (X) := sup lim lim sup log rd(K, n, ϵ)

K  є→0
n→∞	n

where supK is taken over all compact subsets of X.
If the alphabet is finite and d compatible with the standard topology (prod- uct topology of the discrete topology on the alphabet), then hd(X) = h(X) holds. Hence, hd is a generalization of h to the case where the alphabet is countable. In the following, the alphabet is considered to be N if it is countable. As already mentioned, a shift invariant, closed subset of NZ does not need to be compact. But there is a compactification. Define a mapping
π : N → B with B := {  1  : n ∈ N} ∪ {0} by π(n) :=  1 . Then the
restriction of the target of π to B := {  1  : n ∈ N} is a bijection. (B, π)
is a one point compactification of N. The topology on B is induced by the
Z
metric ρ(x, y) := |x − y|. Now B , endowed with the corresponding product
topology becomes a topological space. Since π is a homeomorphism on the
restriction to B, the corresponding product mapping Π : NZ → BZ also is a homeomorphism on the restriction to BZ. Furthermore, Π is shift invariant. BZ is a compact topological space and a compactification of NZ. The topology
Z

on B	is induced by the metric


τ (x, y) :=
+∞

i=−∞
|xi − yi|
2|i|

Z

for all x, y ∈ B .
Let Γ be a countable digraph, Y its edge shift and A the corresponding
(countable) adjacency matrix. Then Y = EZ(Γ) is closed, shift invariant but not necessarily compact in the standard topology. Now consider Π(Y ), which will be denoted by BZ(Γ). BZ(Γ) is a shift invariant, but not necessarily closed subset of the compact space BZ endowed with the metric τ . The closure BZ(Γ)

is a shift space.
Let A be a countable, nonnegative matrix. A is called irreducible if for any pair of indices i, j ∈ N there is some l > 0 such that (Al)ij > 0 holds. An irreducible matrix A is called primitive, if for any pair of indices i, j ∈ N there is some N ∈ N such that (Al)ij > 0 holds for all l ≥ N. Hence a countable labeled digraph is irreducible (primitive) iff the corresponding adjacency matrix is irreducible (primitive). It can be shown [15] that for an
1

irreducible, nonnegative matrix A, lim sup
n→∞
(An) n
exists, is positive and
1

does not depend on the index i. Set λ := lim sup
n→∞
(An) n . If A is finite, λ

is identical to the Perron value. Hence λ is called the Perron value even in
the case where A is countable. Let (Γ, ϕ) be a countable, irreducible labeled digraph, A its irreducible adjacency matrix and λ the corresponding Perron value. Then hτ (BZ(Γ)) = log λ holds ([10], Proposition 7.2.6 and [12], Section 13.9).

Computing the Topological Entropy
The computation of the topological entropy of shifts (X, σ) is done by se- quences of finite adjacency matrices with increasing number of rows. The following fundamental theorem is therefore a basis of the computation.
Theorem 6.1 The function hs : Xσ,s → R assigning to each soﬁc shift X its topological entropy is (νG, ρ)-computable.
Proof. First consider the case where A is an irreducible finite adjacency ma- trix with rows n ≥ 1. If n = 1, that is A = (a), then the Perron value is a. So let n ≥ 2. Following the proof of the Perron-Frobenius Theorem in [7], an algorithm for computing the Perron value can be derived. Let Sn ⊆ Rn be the compact n-sphere given by Sn = {x ∈ Rn : ||x|| = 1}. Define a function r : Sn → R by

r(x) := min
(A(E + A)n−1abs(x))i
n−1

1≤i≤n
((E + A)	abs(x))i

where the function abs : Rn → Rn takes the absolute value of each component, that is abs(x1,... , xn) = (|x1|,... , |xn|). r is continuous and Sn compact, so max r(Sn) exists. Furthermore λ = max r(Sn) is the Perron value of A.
The function r is ([ρ]n, ρ)-computable. Also the n-sphere Sn is a com- putable compact set in the sense of [17], Definition 5.2.1. Hence, r(Sn) also is a computable compact set. Finally, since the maximum of a computable compact subset of R is computable (Lemma 5.2.6 in [17]), also the Perron value λ is ρ-computable. It is clear that there exists an algorithm performing

the computation of the Perron value uniformly, given the adjacency matrix in form of a word u ∈ dom(νG).
Let A be an arbitrary finite adjacency matrix of a right-resolving cover of
a sofic shift space X. It was already mentioned that there is an algorithm computing the normal form of A. So, the Perron values λi for each irreducible component can be computed. Since the maximum function and the logarithm is computable, also h(X)= log max λi is computable (uniformly in A).
Theorem 5.2 finally guarantees that hs is (νG, ρ)-computable.	 
Proposition 4.5 directly implies the corollary:
Corollary 6.2 The function hf : Xσ,f → R assigning to each shift of ﬁnite type X its topological entropy is (νF , ρ)-computable.
Now turn to an arbitrary shift space X. X will be represented by a name p ∈ Aω of EnF . Then any prefix un ∈ A∗ of p of length n ∈ N represents a shift of finite type Yn being an extension of X: X ⊆ Yn for all n ∈ N. Furthermore, X = n Yn holds.
Theorem 6.3 The function h : Xσ → R assigning to each shift X its topo- logical entropy is (EnF , ρ>)-computable.
Proof. Let p ∈ dom(EnF ) be given and X := EnF (p). For all n ∈ N, define a word un of length n by the prefix of p, un и p. Set Yn := νF (un). Yn is a shift of finite type and X ⊆ Yn. By the definition of the topological entropy it is seen immediately that the sequence of topological entropies of Yn, (h(Yn))n, is a bounded, decreasing sequence of real numbers. Hence the limit limn→∞ h(Yn) exists. Furthermore, Yn+1 ⊆ Yn for all n ∈ N and X = n Yn holds. So, for any n ∈ N, |An(Ym+1)| ≤ |An(Ym)| holds for all m ∈ N and also
limm→∞ |An(Ym)| = |An(X)|. Hence, for all ϵ > 0 there are N, M ∈ N such

that for all n ≥ N, m ≥ M |h(X) − log |An(Ym)| | < ϵ holds. lim
n→∞
h(Yn) = 

h(X) follows immediately.
By the fact that (h(Yn))n is decreasing and with Corollary 6.2 follows the assertion.	 
Theorem 6.4 The function h : Xσ → R assigning to each shift X its topo- logical entropy is not (EnL ∧ EnF , ρ)-computable.
Proof. According to Theorem 6.3, it suffices to show that h is not (EnL ∧ EnF , ρ<)-computable. Assume otherwise. Then there is a Type-2 machine M doing the computation. Now let p ∈ Aω be an EnL ∧ EnF -name of some coded system X having strictly positive topological entropy h(X) > 0. Then there is some T ∈ N such that, after T steps of computation of M on input p, M has as output a word representing a rational number r with 0 < r < h(X).

After that time, M has read a prefix u и p of p. The prefix u corresponds to a finite subset JT of all forbidden words of X and a finite subset LT of the language of X.
Then construct a shift space Y the following way. Consider an irreducible cover (Γ, ϕ) of X. Then all words in LT have some finite path in Γ. Consider these paths. Next take some vertex α in Γ. Since Γ is irreducible, there is
some closed path in Γ starting at α, connecting all finite paths defined above and returning to α. Let w ∈ A∗ be its label path. Then y := wZ is an element of X. Now define Y := {σi(y) : i ∈ Z}. The Y is a shift space and Y ⊆ X. So, JT is also a subset of all forbidden words of Y and LT a subset of the language of Y . Therefore, there exists an EnL ∧ EnF -name q of Y also having the same prefix u и q as p. On input q, after T steps of computation, M also produces output r > 0. But this is not correct since h(Y )= 0.	 

Remark: The proof of the above theorem shows that the function h : Xσ → R is not even (EnL ∧ EnF , ρ)-continuous. Furthermore, since h is (EnF , ρ>)- computable, it is interesting to find an EnL-computable name of some shift
space X where the topological entropy is not a ρ<-computable number. This will be done in Section 7.
Now let Γ be a countable, irreducible digraph and A the corresponding adjacency matrix. Examine the calculation of the Perron value λ of A. For all n ∈ N, let nA be the n to n top-left corner truncation of A. Furthermore assume that there is a strictly increasing sequence (tn)n in N such that tn A is irreducible. Clearly, tn A is an adjacency matrix for some topologically
transitive edge shift. Denote the Perron value of tn A by (λtn )n. Then, Theorem
6.8 in [15] holds true even in the case of the weaker assumption made here instead of Assumption 4, demanded in [15]. The theorem shows that (λtn )n is a strictly increasing sequence of nonnegative reals converging to the Perron value of A.
Let (Γ, ϕ) be an irreducible labeled digraph of some shift space X and A the corresponding (irreducible) adjacency matrix. Let p be an EnG-name corresponding to (Γ, ϕ). By the definition of EnG it is clear that any prefix p[0,n] ∈ A∗ of p corresponds to a name of some finite (possibly empty) sub- graph of Γ after removing all stranded vertices. Let An be the corresponding adjacency matrix. Unfortunately, An need not be irreducible. But there is an algorithm, transforming p to an EnG-name q of X having the following property. Let Aˆ denote the corresponding adjacency matrix. Then there is a strictly increasing sequence (tn)n in N such that for any prefix of q of length tn, the adjacency matrix of the corresponding subgraph is irreducible and has the form l(n)Aˆ for some l : N → N.

Lemma 6.5 There is a computable function s :⊆ Aω → Aω transforming any EnG-name p, corresponding to an irreducible cover of some shift space X, to an EnG-name s(p) of X with the following properties. There are strictly increasing sequences (tn)n and (un)n in N such that s(p)[0,un] ∈ dom(νG) and the corresponding adjacency matrix is an irreducible tn by tn matrix.
Proof. There is a Type-2 machine M computing s :⊆ Aω → Aω defined the following way. M works in steps n ≥ 1. At step n, first the n-th element ((αn, βn), an) from the input p is read. Then p is read until M has found a path from βn to αn, from αn to βn−1 and from βn−1 to αn. The last two paths only if n > 1. Then ((αn, βn), an) is written to the output, also the edges and labels corresponding to the other paths.	 

Then it is clear that there is an algorithm computing the Perron value of A provided the name p as input. Using hτ (BZ(Γ)) = log λ, the following result is derived.
Proposition 6.6 Let Ze denote the set of all edge shifts, corresponding to an irreducible, labeled digraph (Γ, ϕ). Then t he function he : Ze → R, assigning to each Z ∈ Ze its topological entropy hτ (BZ(Γ)), is (EnG, ρ<)-computable.
The above proposition shows that there is an (EnG, ρ<)-computable func- tion, assigning any coded system X with irreducible cover (Γ, ϕ) the topo- logical entropy of the corresponding edge shift BZ(Γ). What about the com- putability of the entropy function for X itself? It can be shown (see Example 7.2.8 in [10], [14]) that there are countable, irreducible covers of the full shift
{0, 1}Z with Perron value λ < 2, hence log λ < h({0, 1}Z). If further restric- tions are made, the above situation does no longer appear.
Let (X, σ) be a shift having the speciﬁcation property [4], that is there is an M ∈ N, called the uniform synchronization length, such that for all pairs u, v ∈ A∗(X) there is some w ∈ AM (X) such that uwv ∈ A∗(X) holds. The specification property guarantees topological mixing [6]. The topologically mixing sofic shifts are a proper subclass of the class of shifts having the spec-
ification property [11], which themselves are a proper subclass of the coded systems.

Then for all n ∈ N, |A2n+M (X)| ≥ |An(X)|2 holds. Define hn
:= log |An(X)|

for n ≥ 1, then h2n+M ≥  2n hn follows directly. Finally, define the scaled

version of hn by

hn := (1 − 2−(n+1))h(2n+1 −1)M	(2)

for all n ∈ N, then by using the above estimation,

hn+1 = (1 − 2−(n+2))h2(2n+1 −1)M +M

≥ (1 − 2
−(n+2)
2(2n+1 − 1)M
) 2(2n+1 − 1)M + M h(2n+1 −1)M

1 − 2−(n+2)
= 1 − 2−(n+1)
2n+2 − 2 	
2n+2 − 1 hn = hn

follows. Hence hn+1 ≥ hn holds for all n ∈ N, also limn→∞ hn = limn→∞ hn =
h(X). Therefore, assuming that the uniform synchronization length M is given, the topological entropy h(X) is (EnL, ρ<)-computable. According to Theorem 6.3, the topological entropy h(X) is (EnL ∧EnF , ρ)-computable. But how to compute the uniform synchronization length? To solve this problem, the following definition is crucial, see [14].
Definition 6.7 A shift (X, σ) is called almost soﬁc if h(X) = sup{h(Y ) :
Y ⊆ X is a sofic subshift} holds.
Now it will be shown that a shift (X, σ) having the specification property is almost sofic. Furthermore, the topological entropy of the class of shifts having the specification property is computable, if a specific graph representation is chosen where the cover fulfills additional requirements. Consider a shift space X having a countable, primitive cover (Γ, ϕ). Then the corresponding adjacency matrix A also is primitive. Note that in this case, there is a nested sequence of primitive subgraphs whose union is (Γ, ϕ). To see this, consider the construction in the proof of Lemma 6.5 with one difference. Let α1 be the first vertex of the construction. Then there is an N ∈ N such that for all
n ≥ N, there is a loop starting and ending at α1. So, consider first N paths starting and ending at α1 having lengths N, N + 1,... , 2N − 1. Next follow the construction in Lemma 6.5. Using this property, the following statement
holds.
Lemma 6.8 Let X be a shift space having the speciﬁcation property and a primitive cover (Γ, ϕ). Then X is almost soﬁc.
Proof. Let L be the uniform synchronization length of X.	Furthermore,
let ϵ > 0 be given.	Then there are N, M ∈ N such that h(X) − ϵ <

(1 − 2−(n+1)) log |Am(X)|
holds for all n ≥ N and m ≥ M.	Consequently,

for any m ≥ M there is a sofic subshift Y ' ⊆ X corresponding to a fi-

nite, primitive subgraph (Γ'
, ϕ'
) of (Γ, ϕ), such that Al(Y ' )= Al(X) holds

for all l ≤ m. Since X has uniform synchronization length L, any pair of

vertices α, β of Γ'
sibly adding to Γ'
can be connected by a path of length at most L by pos-
some vertices and edges of Γ. For the resulting cover

(Γm, ϕm) of the resulting sofic subshift Ym, also Al(Ym) = Al(X) holds for all l ≤ m. Furthermore, (Γm, ϕm) is finite, primitive and Ym has the speci-

fication property with uniform synchronization length 2L, independent of m. Now for any Ym, consider the sequence of values hk(Ym) defined in Equa-
tion (2).	Then there are n ≥ N, m ≥ M such that (2n+1 − 1)2L = m

holds. Hence, hn
(Ym
) = (1 − 2−(n+1)) log |Am(Ym)|
> h(X) − ϵ follows.  So,

hl(Ym) > h(X) − ϵ follows for all l ≥ n since hl(Ym) is an increasing sequence. Therefore, h(X) − ϵ < h(Ym) ≤ h(X) is concluded, that is X is almost sofic. 
As a consequence, there is the following
Lemma 6.9 Let X be a shift space having the speciﬁcation property and a primitive, right-resolving cover (Γ, ϕ). Then h(X) = log λ, where λ is the Perron value of the corresponding (primitive) adjacency matrix of (Γ, ϕ).
Proof. Observe that the following relations hold:

log λ = sup{h(BZ(Δ)) : Δ is a finite subgraph of Γ}
= sup{h(AZ(Δ)) : Δ is a finite subgraph of Γ}
= sup{h(Y ): Y ⊆ X is a sofic subshift}
= h(X).
The equality in the first line is the Finite Approximation Theorem, see The- orem 7.1.4 in [10]. The equality in the second line holds since the cover is right-resolving and hence h(BZ(Δ)) = h(AZ(Δ)). The third line follows di- rectly from the proof of Lemma 6.8, since the supremum is attained even for
sofic subshifts corresponding to finite subgraphs. The last line holds true since
X is almost sofic due to Lemma 6.8.	 
Finally it is shown, that any shift having the specification property also has a primitive, right-resolving cover.
Lemma 6.10 Let (X, σ) be a topologically mixing (transitive) shift having a synchronizing word. Then there exists a primitive (irreducible), right-resolving cover of X.
Proof. Let w ∈ A∗(X) be a synchronizing word of X. Now given two symbols a, b ∈ A such that aw, wb ∈ A∗(X) holds, it is easily seen that aw and wb also are synchronizing words. Next, for all u ∈ A∗(X) define the follower set F (u) := {v ∈ A∗ : uv ∈ A∗(X)}. Observe that, for a synchronizing word w, F (uw)= F (w) holds for all uw ∈ A∗(X). To show this, let v ∈ F (uw). Then uwv ∈ A∗(X) holds. Hence, also wv ∈ A∗(X) holds, that is v ∈ F (w). On the other hand let v ∈ F (w), that is wv ∈ A∗(X). Since uw ∈ A∗(X) and w is a synchronizing word, uwv ∈ A∗(X) follows, that is v ∈ F (uw).
Now construct the cover. The vertex set V is the set of all follower sets
of synchronizing words: V := {F (w) : w is a synchronizing word of X}. Let

α ∈ V be a vertex. Then there is a synchronizing word w ∈ A∗(X) with α = F (w). Now let a ∈ A and wa ∈ A∗(X). Then also wa is a synchronizing word, hence there exists a vertex β ∈ V with β = F (wa). Draw an edge (α, β) from α to β labeled by a. If wa /∈ A∗(X), do nothing. Proceed for all vertices α ∈ V and all symbols a ∈ A. By construction, the resulting labeled digraph (Γ, ϕ) is right-resolving. Remains to show that (Γ, ϕ) is a cover of X, that is it contains no stranded vertices and A∗(Γ) = A∗(X) holds, and that the cover is primitive (irreducible).
Let α = F (u) and β = F (v) be two vertices where u and v are syn- chronizing words. Consider first that X is topologically mixing. Then there
is an N ∈ N such that for any n ≥ N there is a word w ∈ An(X) such that uwv ∈ A∗(X). Then F (uwv)= F (v) holds. Hence there is a path in Γ starting at α and ending at β of any length ≥ N +|v|. So, Γ is primitive. Con- sequently, the cover has no stranded vertices. An analogous argument shows that Γ is irreducible, if X is topologically transitive. Next let u ∈ A∗(Γ). Then there is a path γ in Γ having u as sequence of labels. Then there is a synchronizing word w with i(γ0) = F (w). So, wu ∈ A∗(X) follows, as well as u ∈ A∗(X). Hence, A∗(Γ) ⊆ A∗(X) follows. Finally let u ∈ A∗(X) and w be a synchronizing word. Since X is topologically transitive (topologically mixing), there is a word v ∈ A∗(X) such that wvu ∈ A∗(X) holds. Then there is a path γπ in Γ, starting at F (w), γ having label sequence v and π having label sequence u. Hence there is a path π in Γ having label sequence
u. Since no vertex is stranded, A∗(X) ⊆ A∗(Γ) follows.	 
Remember that a shift (X, σ) having the specification property is mixing [6]. Furthermore it has a synchronizing word, see [4]. Therefore, X has a primitive, right-resolving cover and, according to Lemma 6.8, is almost sofic. Now, for a shift space X having the specification property, the computabil-
ity of the topological entropy can be established. Therefore, let Xσ,sp ⊆ Xσ
be the class of all shift spaces having the specification property and Ensp :⊆

Aω → Xσ,sp
be a representation defined by Ensp(p)= X
:⇔ EnG(
G
p) = X ∧ p

represents a primitive, right resolving cover of X, where X has the specifica-
tion property. Then the following main result holds.
Theorem 6.11 The function hsp : Xσ,sp → R, assigning to each shift space X ∈ Xσ,sp its topological entropy is (Enσ,sp, ρ)-computable. Here, the repre- sentation Enσ,sp is deﬁned by Enσ,sp := Ensp ∧ EnF .
Proof. By Theorem 6.3, hsp is (EnF , ρ>)-computable. Next let X ∈ Xσ,sp be given and p ∈ Aω a corresponding Ensp-name of X. Then p corresponds to a primitive, right-resolving cover of X. By Lemma 6.9, hsp(X) = log λ holds, where λ is the Perron value of the adjacency matrix A corresponding to



p. Since log λ = hτ (BZ(Γ)), hsp is (Ensp, ρ<)-computable due to Proposition
6.6.	 
Since EnL ≡ EnG, Theorem 6.4 shows that only having the “information” of the cover of X is not enough to compute the topological entropy from below. Indeed, examining the proof of EnL ≤ EnG shows that the constructed labeled digraph is not even irreducible for any language enumeration. So, irreducibility is an essential property. On the other hand, as Example 7.2.8 in [10] shows, irreducibility is not enough. The labeled digraph can be thinned out in such a manner, even staying an irreducible cover, such that log λ is bounded away from h(X). But the stronger notion of a right-resolving primitive labeled
digraph is sufficient to guarantee the computability of the topological entropy of a shift, having the specification property.

The Topological Entropy of S-gap Shifts
In this section, the interesting class of so called S-gap shifts is introduced and an equation is derived, determining the topological entropy of an S-gap shift. Finally, this equation is used to construct a specific S-gap shift where the corresponding topological entropy is not a ρ<-computable real number.
Let S ⊆ N be an arbitrary subset of N. Then define a subshift XS ⊆
{0, 1}Z, called the S-gap shift, the following way. Consider all sequences of the form x = ... 10n−2 10n−1 1.0n0 10n1 10n2 1 ... , where ni ∈ S for all i ∈ Z. Then XS is the closure of all elements σi(x), i ∈ Z. Hence XS is closed and shift invariant.
Assume that S is infinite. The finite case is treated similarly. Denote by χS the characteristic function of S. Let Rn denote the number of words in XS of length n ending with the symbol 1. Consider a word of length n ending with the symbol 1. Then k + 1 symbols backwards, there possibly also is a 1 iff k ∈ S and k +1 < n. Otherwise, there is no other 1. Hence,
n−1
Rn+1 =	χS(k)Rn−k +1	(3)
k=0
holds.  Next consider all words in An(XS).  Since the last 1 can occur at
position i = 0,...,n − 1, the equation |An(XS)| = Σn	Rk + 1 follows.

Alternatively,
Rn+1 = |An+1(XS)|− |An(XS)|	(4)

holds. Inserting the Expression (4) in Equation (3) gives |An+1(XS)|−|An(XS)| =
Σn−1 χS(k)(|An−k(XS)|− |An−k−1(XS)|) + 1. So, there is some 0 ≤ cn < n 

such that |An+1(XS)|− Σn−1 χS(k)|An−k(XS)| = cn holds. In other words,

n−1
χ
|An−k(XS)|		cn	
(k)	+	=1	(5)


holds for all n.
S
k=0
|An+1(XS)|	|An+1(XS)|

Now, |An(XS)| is asymptotic proportional to λn for n → ∞, where λ =

2h(XS ). Therefore, for the limit lim
|An−k(XS )|
= λ−(k+1) holds. Letting

n → ∞ in Equation (5),
n→∞ |An+1(XS )|
Σ λ−(n+1) =1 
n∈S

follows. So, for the topological entropy of XS, h(XS) = log λ holds, where λ
is a nonnegative solution of the equation
Σ x−(n+1) = 1.	(6)
n∈S
Furthermore, the nonnegative solution of Equation (6) is unique and for any
t ∈ [0, 1] there exists an S ⊆ N such that h(XS)= t holds (see [12]).
For any S ⊆ N, consider the function fS : (1, 2) → R defined by fS(x) := n∈S x−(n+1) − 1 for all x ∈ (1, 2).	If S is decidable, then fS is (ρ, ρ)- computable and, since fS(x) = 0 has a unique solution, h(XS) isa ρ-computable number. Furthermore, S is decidable iff the language of XS is decidable. Con-
sidering a recursively enumerable, but not recursive S gives the following
Proposition 7.1 There is an EnL-computable name of some shift space X
such that h(X) is not a ρ<-computable number.
Proof. Consider the K-gap shift X where K ⊆ N is the halting problem. Since K is recursively enumerable, also the language of X is recursively enu- merable. Hence X has an EnL-computable name.
Let μ := 2−h(X). Then  n∈K μn+1 = 1 holds and μ is not ρ<-computable. Otherwise, K would be decidable. To see this, let M ∈ N be given. Compute
μ from the left to some value μn < μ and simultaneously enumerate a finite

subset Km of K such that Σ
μk+1
> 1 − μM+1 holds. Indeed, there

k∈Km  n
n
k+1

1 − μM+1 holds. Hence, M ∈ K iff M ∈ Km follows.	 

Related Work and Discussion
In [16], also the computability of the topological entropy of shifts is investi- gated. There are similarities and differences to the present work, which will

be discussed here briefly. First of all, in [16] only shift spaces with decidable language are considered. The name of a shift space is given by a finite string, representing a decision procedure for the language. On the other hand, the approach presented here handles different naming systems where no further re- strictions are required. Furthermore, these naming systems are in some sense “natural” since they represent shift spaces in a way already commonly used in the symbolic dynamics literature [12,3]. Clearly, the former approach gives finite names to some shift spaces where the latter approach does not. But if sofic shifts are considered, they are equivalent and the achieved results are the same: namely the computability of topological entropy. However, the charac- terization of shift spaces by labeled digraphs seems to be the more adequate since in Section 6 the computability of topological entropy of a class of shifts could be established which are not strictly sofic in general, namely the systems showing the specification property. Finally, the uncomputability result stays in both approaches whereas the one treated here admits an easy example of a shift space X, presented in Section 7, where the language enumeration name of X is computable - since the language is recursively enumerable - but h(X) is not a left computable real number. However, the interesting question al- ready stated in [16] remains open here: Is there a shift space with decidable language where the topological entropy is not a computable real number? But in [8] it is shown that for any right-computable real number r with 0 ≤ r ≤ 1
there exists a shift X with binary alphabet and (in polynomial time) decidable
language such that h(X)= r holds.
Acknowledgments
The author wishes to express his gratitude to Peter Hertling for helpful dis- cussions and comments.

References
Adler, R., A. Konheim and M. McAndrew, Topological entropy, Transactions of the American Mathematical Society 114 (1965), pp. 309–319.
Alekseev, V. and M. Yakobson, Symbolic dynamics and hyperbolic dynamic systems, Physics Reports 75 (1981), pp. 287–325.
B´eal, M.-P. and D. Perrin, Symbolic dynamics and ﬁnite automata, in: G. Rosenberg and
A. Salomaa, editors, Handbook of Formal Languages, Vol. 2, Springer-Verlag Berlin Heidelberg New York, 1997 .
Bertrand, A., Speciﬁcation, synchronisation, average length, in: G. Cohen, editor, Coding Theory and Applications, Lecture Notes in Computer Science 311, 1988, pp. 86–95.
Blanchard, F. and G. Hansel, Syst`emes cod´es, Theoretical Computer Science 44 (1986), pp. 17– 49.

Buzzi, J., Subshifts of quasi-ﬁnite type, Inventiones Mathematicae 159 (2005), pp. 369–406.
Gantmacher, F., “The Theory of Matrices,” Chelsea Publishing, New York, 1959.
Hertling, P. and C. Spandl, Shifts with decidable language and non-computable entropy (2006), preprint.
Hirsch, M., S. Smale and R. Devaney, “Differential Equations, Dynamical Systems and an Introduction to Chaos,” Elsevier Academic Press, Amsterdam, 2004.
Kitchens, B., “Symbolic Dynamics,” Springer-Verlag, Berlin Heidelberg New York, 1998.
Kwapisz, J., Cocyclic subshifts, Mathematische Zeitschrift 234 (2000), pp. 255–290.
Lind, D. and B. Marcus, “Symbolic Dynamics and Coding,” Cambridge University Press, Cambridge, 1995.
Milnor, J., Is entropy effectively computable? (2002), remark, available via the web site
http://www.math.sunysb.edu/~ jack/comp-ent.pdf.
Petersen, K., Chains, entropy, coding, Ergodic Theory & Dynamical Systems 6 (1986), pp. 415– 448.
Seneta, E., “Non-negative Matrices and Markov Chains,” Springer-Verlag, New York Berlin Heidelberg, 1981, 2nd edition.
Simonsen, J., On the computability of the topological entropy of subshifts, Discrete Mathematics and Theoretical Computer Science 8 (2006), pp. 83–96.
Weihrauch, K., “Computable Analysis,” Springer-Verlag, Berlin Heidelberg New York, 2000.
