Electronic Notes in Theoretical Computer Science 171 (2007) 3–19	
www.elsevier.com/locate/entcs

Term Collections in λ and ρ-calculi
Germain Faure1
Universit´e Henri Poincar´e & LORIA, BP 239 F-54506 Vandoeuvre-l`es-Nancy, France

Abstract
The ρ-calculus generalises term rewriting and the λ-calculus by defining abstractions on arbitrary patterns and by using a pattern-matching algorithm which is a parameter of the calculus. In particular, equational theories that do not have unique principal solutions may be used. In the latter case, all the principal solutions of a matching problem are stored in a “structure” that can also be seen as a collection of terms.
Motivated by the fact that there are various approaches to the definition of structures in the ρ-calculus, we study in this paper a version of the λ-calculus with term collections.
The contributions of this work include a new syntax and operational semantics for a λ-calculus with term collections, which is related to the λ-calculi with strict parallel functions studied by Boudol and Dezani et al. and a proof of the confluence of the β-reduction relation defined for the calculus (which is a suitable extension of the standard rule of β-reduction in the λ-calculus).
Keywords: lambda-calculus, rho-calculus, parallel operator, canonical sets, term collections.


Introduction
The ρ-calculus, also called the rewriting calculus, originally emerged from differ- ent motivations—and from a different community—than the λ-calculus. It was introduced to make explicit all the ingredients of rewriting such as rule application and result [7]. In ﬁne, the ρ-calculus provides an extension of the λ-calculus with additional concepts originating from rewriting and functional programing, namely built-in pattern-matching, represented using matching constraints, and term collec- tions.
There are several aspects of the ρ-calculus that have been studied so far. The dynamics of the computations has been studied [13] by defining interaction nets for the ρ-calculus. We can mention also the study of type systems [3,24] and their applications to a proof theory that handles rich proof-terms in the generalized de- duction modulo [25].

1 Email: germain.faure@loria.fr

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.12.037

On a more practical side, the ρ-calculus has been used both to encode object calculi [8] and to give a semantics to rewrite based languages [7] such as ELAN [4]. More recently, there were undergoing works to specify in the ρ-calculus the Focal Project [17,18], a programming environment in which certified programs can be developed. Also, the ρ-calculus has been used to specify efficient decision proced- ures [21].
Term collections are fundamental in the context of the ρ-calculus but also in logic programming and in web query languages. Typically, matching constraints that are involved in the calculus may have more than one solution —this is also the case for example in programming language like TOM [23], Maude [16], ASF+SDF [1] or ELAN [11]—and thus generates a collection of results.
Different works on the ρ-calculus propose different approaches to deal with term collections. They were originally [7,6] represented using sets. In more re- cent works [9], they are represented via a structure construction whose operational semantics is parametrised by a theory (typically a combination of the axioms of associativity, commutativity and/or idempotence) that the user chooses depending on the way (s)he wants to deal with non-determinism in the calculus. For example, the original semantics of ”sets of results” is recovered by considering the associative, commutative and idempotent (ACI) theory on structures.
The generality given by those recent works is broken when the matching con- straints involved in the calculus may have more than one solution, that is when the solving of the matching problem gives several solutions (substitutions). In fact, to the knowledge of the author there is no satisfactory (total) order to compare substitutions. Thus we must represent collections of terms by sets (or at least by an associative and commutative structure).
If we look carefully at the different presentations of the ρ-calculus, we can remark that the different operational semantics always share a common structure: the set of evaluation rules can be divided into a first subset consisting of the ρ-rule, an extension of the β-rule of the λ-calculus to deal with application of pattern- abstractions and into a second one dealing with term collections (including the δ-rule that distributes term collections over the application operator). These two kinds of rules are both treated at the same level whereas the former captures in a nutshell the computational mechanism of the calculus when the latter only performs ”administrative simplifications” concerning term collections.
The first attempt to a denotational semantics of the ρ-calculus proposed in [12] enlightened a relation between the ρ-calculus and the λ-calculi for (strict) paral- lel functions [5]. Syntactically, the latters are extensions of the λ-calculus with a parallel operator that distributes left w.r.t. applications and w.r.t. λ-abstractions (as the structure operator of the ρ-calculus). It has been extended to parallel and non-deterministic λ-calculi like in [10].
The Scott models of the ρ-calculus and of the λ-calculi for (strict) parallel func- tions are surprisingly close: the structure operator are adequately represented by the join operator.
This suggests a clear relation between these formalisms: the λ-calculi for (strict)

parallel functions are extensions of the λ-calculus with term collections and the ρ- calculus is an extension of the λ-calculus with term collections and built-in pattern- matching.
As a first step in the study of the ρ-calculus with non-unitary matching theories, we propose in this paper the study of the λ-calculus with term collections, called in the following the λ -calculus.
In the spirit of the normalized rewriting [15], the approach introduced in this paper manages term collections at the meta-level by considering only canonical sets that is, sets that are normalized for some rules (the ones previously refereed as ”administrative simplifications”). The result is a confluent calculus where the computational mechanism becomes easier to understand since only the β-rule is an explicit evaluation step. While the work of [5] mainly insists on models (looking at the full-abstraction problem for programming languages), in this work we pro- pose to look at the λ -calculus from an operational point of view by giving a clear operational semantics to the equivalence relation introduced in [5]. The same ap- proach can be used if one prefers to consider canonical multisets since neither the definitions nor the proofs are related to the idempotence.
Road-map The paper is organized as followed. The first section introduces the syntax of the λ -calculus by defining simple terms, parallel terms and substitutions. The second section is a general study of the relations on the terms on the λ -calculus. The third section introduces the operational semantics of the λ -calculus. We finally study in the fourth section the Church-Rosser property. We conclude by some remarks on the operationality of the reduction.

Syntax of the λ -calculus
Preliminaries
For better a readability, a relation τ is also denoted by →τ . Its reflexive and transitive closure is denoted either by (τ )∗ or by →→τ . The successors of A for the relation τ are the elements of the set {B | A →τ B}. The composition of two relations is simply denoted by juxtaposition.
We denote by P+ (X) the finite non-empty subsets of X.  A non-empty set

{S1,... , Sn} is often denoted by {Si}n
or even simpler by {Si}i.

Terms
In this section, we introduce the syntax of the λ -calculus which consists of simple terms and parallel terms. A parallel term is simply a set of simple terms. Simple terms differ from λ-terms since they cannot be applied to a simple term but only to a set of simple terms that is, to a parallel term.
Definition 2.1 (Simple terms and terms) Given a denumerable set of variables X , we deﬁne by induction on k an increasing family of sets (Sk). We set S0 = X and we deﬁne Sk+1 as follows:

Monotonicity: Sk ⊆ Sk+1 ;
Abstraction: if S ∈ Sk then λx.S ∈ Sk+1 ;
Application: if S ∈ Sk and M ∈ P+ (Sk) then S M ∈ Sk+1.
We denote by S the union of all the sets Sk and by M the set P+ (S). We call simple terms the elements of S and parallel terms or simply terms the elements of M.
In the application SM , the simple term S is said to be in functional position while the term M is in applicative position.
Simple terms are written S,T,U ... and terms are denoted by M, N, P,E .. .. We denote by η the canonical injection of simple terms into terms, that is the relation such that S →η {S} for all simple terms S. We consider terms modulo the α-conversion and the hygi`ene convention of Barendregt. The α-conversion on sets is defined by:


M =α N ⇔
⎧⎪⎨ ∀S ∈ M, ∃T ∈ N, S =α T
⎪⎩ ∀T ∈ N, ∃S ∈ M, T =α S

Note that the α-conversion does not preserve cardinality. For example,we have
{λx.x, λy.y} =α {λz.z, λz.z} = {λz.z}.
We can remark that proving a property by induction on terms means proving this property for each term M by induction on the least k such that M ∈ P+ (Sk).
This number denotes the height of M and is written h (M ).
Remark 2.2 We can equivalently deﬁned the simple terms and terms by
simple terms	S ∈ S ::= x	|	λx.S	|	S M 
terms	M ∈ M ::= {S,... , S}

Then the height of a term can be (re)deﬁned as follows:

h (x)	= 0	h (λx.S) = 1 + h (S)
h (S M ) = 1 + max {h (S) , h (M )}	h ({Si}i) = maxi {h (Si)}

Syntactic sugar For better readability, the λ-abstraction and the application op- erator are often applied to terms. These are simply syntactic sugar defined as follows:

λx.{Si}i	=	{λx.Si}i
{Si}i M	=	{Si M }i
For example, we write either
λx.{x, y} or {λx.x, λx.y}.

Similarly,

denote the same term.

Substitutions

{z, t} {y} and {z {y}, t {y}}

We define the application of substitutions in three steps:
First, we define the substitution of a variable by a simple term in a simple term. This operation has type S ×X × S → S.
Then, we define the substitution of a variable by a term in a simple term. This operation has type S ×X × M → M. Note that the substitution of variable by a term in a simple term gives a term.
Finally, we extend the previous operation to term, that is we define the substi- tution of a variable by a term in a term. This operation has type M×X ×M → M.
Definition 2.3 (Simple substitution) Let x be a variable and T be a simple term. We deﬁne by induction on the simple term S the substitution [ := ] : S ×X × S → S as follows:
y[x := T ]	=	⎧⎨ T	if x = y
⎩ y	otherwise
(λy.S0)[x := T ]	=	λy.(S0[x := T ])
(S0 {Si}i)[x := T ]	=	(S[x := T ]) {Si[x := T ]}i

In the abstraction case, we take the usual precautions assuming without loss of generality and thanks to the α-conversion that y /= x and y does not occur free in T .
Definition 2.4 (Substitution in simple terms) Let x be a variable and M be a term. We deﬁne by induction on the simple term S the substitution [ := ] : S ×X × M → M as follows:

Definition 2.5 (Substitution in terms) The deﬁnition of substitutions can be

extended to terms by setting:

{S }n


[x := M ]= S [x := M ],n

i i=1
i
i=1

Example 2.6 We consider the simple term y {x}. The substitution of x by the term {z, t} gives:

(y {x})[x := {z, t}] = (y[x := {z, t}]) ∪ x[x := {z, t}]
= {y}∪ x[x := {z, t}]
= {y}{z, t}
= {y{z, t}}

The substitution of y by {z, t} in y {x} gives:
(y{x})[y := {z, t}] = (y[y := {z, t}]) ∪ x[y := {z, t}]
= (y[y := {z, t}]){x}
= ({z, t}){x}
= {z{x}, t{x}}
The substitution lemma is valid.
Lemma 2.7 (Substitution lemma) Let M, N and P be terms and x be a vari- able. If x is not free in P then we have
M [x := N ][y := P ]= M [y := P ][x := N [y := P ]]

Relations on the terms of the λ -calculus
We shall consider two kinds of relations: relation from simple terms to terms which are subsets of S × M and relations from terms to terms which are subsets of M × M. To simplify the reading, we use the following definitions:
Definition 3.1 (Relations on (simple) terms) A relation of simple terms is a relation which is a subset of S × M. A relation on terms is a relation which is a subset of M × M.
To define a relation on the terms of the λ -calculus we will always proceed in the two following steps: first, we define a relation on simple terms and then we extend it to terms. The second point is studied in details in Sect. 3.1. We focus on the first one.
The specificity of this work is that the syntax consists in two different sets (the set of simple terms and the set of terms) and that a simple term is going to be reduced to a term (thus moving from a syntactical category to another one). The

usual approach (see for example [2]) to define the operational semantics of higher- order languages (usually called the reduction relation) first defines the reduction at the head position (usually called the notion of reduction) and then considers its compatible closure (that gives the reduction relation).
In the framework of the λ -calculus, the same approach must be used with care. Since a simple term reduces to a term, we have to make clear what a compatible relation is or in other words, we have to make clear how the compatible closure of a notion of reduction is computed.
For relations on simple terms, we adapt the usual notion of ”contextual relations” that are relations that verify

If S →τ M then C[S] →τ C[M ]

for any context C[ ]. In the λ -calculus, the context C[ ] may put the simple term S under an abstraction, or in functional position of an application or in a set that is located in the applicative position of an application. The notion of contextual relation (Def. 3.7) formalises this idea.
For relation of terms, we have moreover to specify how the relation behaves with respect to sets. This gives the notion of additive relations (Def. 3.4).
Nevertheless, in the context of relations that simultaneously reduce several re- dexes, the notion of contextual and additive relations should be adapted. This leads to the notion of multiplicative and parallel relations (Def. 3.5 and 3.8).
In the following sections, when defining a new relation we will always state its related properties (additive, multiplicative, contextual or parallel). This helps us not only in proofs but also to increase intuitions.


Extending a relation on simple terms to a relation on terms.
Let τ be a relation on simple terms. We want to determine the different ways to extend it to a relation on terms.
The first way is to use the canonical injection of simple terms into terms (pre- viously denoted η). Then, if S →τ M then {S} →τb M . This extension is called the singleton extension and it will be used only for technical reasons.
Let us examine other ways. Suppose given a term M that we consider as the union of (singletons of) simple terms. We want to determine the successors of M by an extended relation. They can be either the terms obtained by replacing one simple term of M by one of its successors by τ or the terms obtained by replacing all the simple terms of M by one of its successors by τ . By analogy with the terminology used in linear logics we call the former the additive extension of τ and the latter the multiplicative extension of τ .
Definition 3.2 (Extending a relation) Given a relation τ on simple terms, we



deﬁne three relations τ^, τ and τ˜ on terms as follows:

Singleton


S →τ M


{S} →τb M




Additive
S →τ M


{S}∪ E →τe M ∪ E


∀i, Si →τ Mi
multiplicative
∪i{Si} →τ ∪iMi

We will often refer to the following remark that express that the three extensions (the singleton, the additive and the multiplicative) are continuous.
Lemma 3.3 Let (τi)i be an increasing sequence of relation on simple terms and let τ be the relation deﬁned as τ = ∪iτi. Then we have τ = ∪i τi, τ = ∪i τi and τ = ∪i τi.
Proof We only prove the first equality. The two other ones are similar.
M →∪iτbi N ⇔ ∃i0,M →τci N
⇔ ∃i0,M = {S} and S →τi  N
⇔ M = {S} and S →∪τi N
⇔ M →∪diτi N
o

Relations
We first define two different behaviors of a relation with respect to sets.
Definition 3.4 (Additive relations) A relation τ on terms is additive if for all

terms M1,M ' such that M1 →τ M '
then for all terms M2 we have M1 ∪ M2 →τ

1	1
M ' ∪ M2.
We can remark that if τ is a relation on simple terms then the relation τ is an additive relation.
Definition 3.5 (Multiplicative relations) A relation τ on terms is multiplicat-
ive if for all terms M1,M ' , M2 and M ' such that M1 →τ M ' and M2 →τ M ' we
'	1'	2	1	2
have M1 ∪ M2 →τ M1 ∪ M2.
We can remark that if τ is a relation on simple terms then the relation τ is a multiplicative relation.
Additive and multiplicative relations are dual in the following sense:
Proposition 3.6 The reflexive and transitive closure of an additive relation is a multiplicative relation.

Proof Let τ be an additive relation. We want to show that (τ )∗ is multiplicative that is

∀M1,M ' , M2,M '	M1 →→τ M ' , M2 →→τ M ' ⇒ M1 ∪ M2 →→τ M ' ∪ M '
(1)

1	2	1	2	1	2
It is sufficient to prove that
∀M1,M '	M1 →→τ M ' ⇒ ∀M2 M1 ∪ M2 →→τ M ' ∪ M2.	(2)
1	1	1
Suppose that (2) is true and let us show (1). Let M1,M ' , M2,M ' be terms such that
'	'	1	2	'
M1 →→τ M1 and M2 →→τ M2. Applying (2) twice we get M1 ∪ M2 →→τ M1 ∪ M2 and
then M ' ∪ M2 →→τ M ' ∪ M ' . Then by transitivity of (τ )∗, we obtain M1 ∪ M2 →→τ
'	1	1	2
M ∪ M ' . To prove (2), it is sufficient to prove that
∀M1,M '	M1 →τ M ' ⇒ ∀M2 M1 ∪ M2 →τ M ' ∪ M2.	(3)
1	1	1
Suppose that (3) is true and let us show (2).  Let M1 and M ' be terms such
1
'	∗	1	n
that M1 →→τ M1. By definition of (τ ) there exist n terms M1 ,... M1 such that
M 1 →τ M 2 →τ ... →τ Mn with M1 = M 1 and Mn = M ' . Applying (3) n times
1	1	1	'	1	1	1	'
we get M1 ∪ M2 →τ ... →τ M1 ∪ M2 that is M1 ∪ M2 →→τ M1 ∪ M2. We finally
remark that (3) is true since τ is additive by hypothesis.	o
We introduce in the two following definitions two different behaviors of a relation on terms with respect to the application and the abstraction operator.
Definition 3.7 (Contextual relations) A relation τ on simple terms is contex- tual if it satisﬁes the two following conditions:
Contextuality w.r.t. to the abstraction operator: For each variable x of X , for each simple term S and for each term M such that S →τ M, we have λx.S →τ λx.M .
Contextuality w.r.t. to the application operator:
For all terms M, N and for each simple term S such that S →τ M, we have SN →τ MN.
For all terms M, N and for each simple term S such that M →τe N, we have SM →τ SN.
Definition 3.8 (Parallel relations) A relation τ on terms is parallel if it is re- flexive, multiplicative and satisﬁes the two following conditions:
Parallelism w.r.t. to the abstraction operator: For all variable x ∈ X , for all terms M and M ' such that M →τ M ', we have λx.M →τ λx.M '.

Parallelism w.r.t. to the application operator: For all terms M1, M2,M '
and

'	'	'
'	'	1

M2 such that M1 →τ M1 and M2 →τ M2, M1M2 →τ M1M2.
We often say that a relation has the parallelism property to means that it is a parallel relation.
The duality between additive and multiplicative relations can be extended to contextual and parallel relations:

Proposition 3.9 Let τ be a contextual relation on simple terms. Then the reflexive and transitive closure of the relation τ˜, that is the relation (τ˜)∗, is parallel.
Proof The proof is similar to Prop. 3.6.	o
Every parallel relation is compatible with the substitution application in the follow- ing sense:
Lemma 3.10 Let τ be a parallel relation on terms. If M, N, M ' are terms such that M →τ M ' then N [x := M ] →τ N [x := M '].
Proof The proof is by induction on N . If N ∈ P+ (S0), then the result is obvious. Suppose that the result is true for all terms in P+ (Sk). Let N be a term belonging to P+ (Sk+1). Then N = {Si}i with Si ∈ Sk+1. We prove that for all i, Si[x := M ] →τ Si[x := M '] and then we conclude by multiplicativity of τ . There are three cases:
If Si0 belongs to Sk+1 and it belongs also to Sk then the result holds by induc- tion.

If Si
belongs to Sk+1 with Si	= λx.S'  and S'	∈ Sk.	Then by induc-

0	'	0	i0	'	i0	'
tion hypothesis, we have Si0 [x := M ] →τ Si0 [x := M ]. By parallelism of
the relation →τ , we obtain λx.S' [x := M ] →τ λx.S' [x := M '] which means
i0	i0
Si [x := M ] →τ Si [x := M ']

If Si
belongs to Sk+1 with Si = S' N ' , S'
∈ Sk and N ' ∈ P+ (Sk). This

0	0	i0  i0	i0
i0	<∞	'

case is similar to the previous one: we apply the induction hypothesis on Si0
and N ' and we conclude by the parallelism of τ .
o
The following definition and the following lemma will be crucial in the proof of the Church-Rosser property of the Sect. 5. They formalize the idea that if a multiplicative relation on simple terms satisfies the multi-diamond property (form- ally if its singleton extension satisfies the diamond property) then its multiplicative extension also verifies this property.
Definition 3.11 (Multi-diamond) A pair of binary relations (τ, ϕ) on terms sat- isﬁes the multi-diamond property if for any term M, for any m > 0 and for any terms M1,... , Mm such that M →τ Mi for all i, then there exists a term M ' such that for all i we have Mi →ϕ M '.

M ¸¸¸
τ	¸¸¸¸¸¸

,  s 	τ  J 
τ ¸¸¸¸¸

M1¸
 
M 2
... 
¸z˛
, , Mn

¸ ¸ ϕ 
ϕ , ,

ϕ	¸z J  , , ,
M '	,

Lemma 3.12 Let τ ⊆ S × M be a relation on simple terms and let ϕ ⊆ M × M be a multiplicative relation on terms. If the pair (τ , ϕ) satisﬁes the multi-diamond property then the pair (τ, ϕ) also satisﬁes the multi-diamond property.
Proof Let M and M1,... , Mn be terms such that for all i we have M →τ Mi. Then M = {Sj}j and Mi = {Ni}j with Sj →τ Ni for all i and all j. Since (τ^, ϕ)
satisfies the multi-diamond property there exists a term Ni →ϕ N '. Since ϕ is
multiplicative we have {Ni}j →ϕ {N '}j for all i, that is to say, Mi →ϕ M ' with
j	j
M ' = {N '}j.
o

Operational semantics of the λ -calculus
To define the operational semantics of the λ -calculus, we first define the one-step reduction β1 on simple terms. Then we extend it on terms using the additive extension: this provides the one-step reduction on terms. Next, we consider the reflexive and transitive closure of the latter that defines the relation β. In the following section, we will show that this relation is confluent.

Deﬁnition of β1-reduction
Definition 4.1 We deﬁne an increasing sequence (β1)k of relations on simple terms

by induction. The relation β1 is the empty relation and the relation β1
is deﬁned

0
by induction as follows:
S → 1 M
k
k+1

S → 1
k+1
M	(λx.S) M → 1
k+1

M →f M '
S[x := M ]

S →	'

S → 1 M	1	1 M
k	k	k

λx.S →
1
k+1
λx.M
S M →
1
k+1
{S M '}
S M →
1
k+1
M ' M



We deﬁne

∞
1	1
k

k=0
We have defined the one-step reduction β1 that reduces a simple term into a term. The one-step reduction on terms is obtained by considering the additive ex- tension of β1 namely β1. Its reflexive and transitive closure is the relation denoted β that is:
β  (β˜1)
We can consider the λ-calculus as a sub-calculus of the λ -calculus where all terms are singletons. This is illustrated in the following example.

Example 4.2 The λ-term (λz.λt.zt)(λxy.x) can be encoded in the λ -calculus and we can simulate the reduction of the λ-calculus:
{(λt.λt.z{t}){λxy.x}} →f {λt.(λxy.x){t}}
β
→f {λt.λy.t}
β
The λ-term ω = (λx.xx)λx.xx of the λ-calculus can be encoded in the λ -calculus and we can simulate the reduction of the λ-calculus:
{(λx.x{x})λx.x{x}} →f {(λx.x{x})λx.x{x}}
β
→f ... 
β
Remark 4.3 In the λ-calculus for (strict) parallel functions of G. Boudol, the ap- plication of the λ-abstraction and the application operator to terms is not a syntactic sugar as in the λ -calculus introduced in this paper but is directly part of the syntax and the two following equations
λx.{Si}i	=	{λx.Si}i
{Si}i M	=	{Si M }i
are oriented from left to right and used as evaluation rules, at the same level as the
β-rule of the λ-calculus.
The result is a calculus that distinguishes all the following terms (g1 g2 g3)z	(g1 g2)z g3z	g1z g2z g3z
whereas they are all represented in the framework of the λ -calculus by the canonical
term
{g1z, g2z, g3z}
We conclude this section by the analysis of the relation β1 and β.
Lemma 4.4 The relation β1 is contextual.
Proof Statements (i) and (ii-a) of Definition 3.7 are obtained by definition of β1.

In fact, if S → 1 M ' them there exists a k such that S → 1
k
M '. We obtain

SN →
1
k+1
M 'N and thus SN →β1 M 'N . Statement (ii-a) follows in the same way.

Statement (ii-b) is an easy consequence of the definition of β1 and the property of continuity. In fact, we can remark that if M →f M ' then there exists, by applying
β

Rem. 3.3 an indice k such that M →f M ' and then SM →
k
1
k+1
SM ' (definition of

β1).
o
Proposition 4.5 The relation β is parallel.

Proof By Lemma 4.4, the relation β1 is contextual. Then we can apply Proposi- tion 3.9.	o

The Church-Rosser property
To avoid confusions with the terminology of parallel relations in the sense of Tait and Martin-Lo¨f and in the sense Sect. 3, the formers will be called simultaneous relations.
To prove the confluence the relation β of the λ -calculus, we proceed in the same way as in the proof of the confluence of the λ-calculus based on the parallel reduction `a la Tait and Martin-Lo¨f that was studied in [22].
We first define a variant of the β1-reduction (that was defined in Sect. 4) that reduce simultaneously several redexes in a single step. This relation is denoted by B. We then show that the reflexive and transitive closure of its parallel extension, that is the reflexive and transitive closure of the relation B, is equal to the relation β. We finally show the confluence of the B and then deduce the confluence of β.
The simultaneous reduction B
Definition 5.1 (B-reduction) The relation on simple terms B is deﬁned as the union of an increasing sequence (Bk)k of relations on simple terms. The relation B0 is equal to η. The relation Bk+1 is deﬁned by induction as follows:
S →Bk M	S →Bk N



S →Bk+1 M
λx.S →Bk+1
λx.N '



S →B  N '	M →	M '

SM →B	N 'M '
The relation B is thus deﬁned as
S →B  N '	M →	M '

(λx.S)M →B	N '[x := M ']



B    Bk .
k=0
Note that in the definition of B we use the multiplicative extension (while in the definition of β1 we used the additive one) in order to simultaneously reduce several redexes in a single step.
We show that the relation B is parallel. This gives an example of a parallel relation that is not a reflexive and transitive closure of a contextual relation.
Proposition 5.2 The relation B is parallel.

Proof We first show that the relation B is reflexive, that is that the identity relation on terms denoted id is included in B. This is true since

B0⊆B	and	B0=η= id

The multiplicativity of B is obvious. Let us show the parallelism w.r.t. the
abstraction operator. Let M1 and M ' be terms such that M1 → M ' . This means
'	1	B	1
that M1 = ∪i{Si} and M1 = ∪iNi with Si →B Ni. Then we have λx.Si →B λx.Ni
for all i, which proves λx.M1 → λx.M ' . Let us show now the parallelism w.r.t.
B	'	1	'	'
the application operator. Let M1, M1, M2 and M2 be terms such that M1 →B M1
and M2 → M ' . This means that we have M1 = ∪i{Si} and M ' = ∪iNi with
B	2	'	1
Si →B Ni for all i. Then we have SiM2 →B NiM2 for all i, which means that
M1M2 → M ' M ' .
B	1	2
o

Confluence of B
Lemma 5.3 We have the following inclusions:

β˜1 ⊆ B ⊆ β
The reflexive and transitive closure of B is thus β.
Proof To prove the first inclusion we prove by induction on k that β1 ⊆ B. The case k = 0 is obvious since β1 is the empty relation. For the induction case, we

suppose that β˜1 ⊆ B. We want to prove that β
⊆ B. Let M and N be two

k
terms such that M  = {S}∪ E  → ˜1
βk+1
k+1
P ∪ E = N with S → 1
k+1
P . We want to

prove that {S}∪ E →B P ∪ E but by the parallelism of B and since B is reflexive (and thus in particular E →B E) it is sufficient to prove that {S} →B P , which
can be done by case on the last rule used to prove S → 1	P :
k+1

If S → 1
k+1
P with S → 1
k
P then {S}→f1 P and by induction hypothesis we
βk

obtain {S} →B P .

If S → 1
k+1
P with S = (λx.S1)M1, P = S1[x := M1]. Then we have (λx.S1)M1 →B1

S1[x := M1] and {(λx.S1)M1} →B1 S1[x := M1]. By Rem. 3.3 applied to the
relation B the result holds.

If S → 1
k+1
P with S = λx.S1, P = λx.P1 and S1 →β1
P1.  By induction

hypothesis, we obtain {S1} →B P1 and then by the parallelism of B we conclude the case.

If S → 1
k+1
P with S = S1M1, P = {S1M ' } and M1 →f M ' . By induction
k

hypothesis, we obtain M1 →B
{S1M1} → {S1M ' }.
M ' . Again by the parallelism of B we conclude

If S →

1
k+1
P with S = S1M1, P = P 'M1 and S1 →
β1 M1. This case is similar

to the previous ones.

We now prove the second inclusion. We can prove that ηβ ⊆ β that is, the multiplicative extension of the composition of η and β is included in β. In fact, let M and N be terms such that M →ηβ N , that is there exist simple terms S1,... , Sn and terms P1,... , Pn such that M = ∪i{Si} and N = ∪iPi with Si →ηβ Pi for all i.

By definition of η this means that {Si} →→β Pi for all i. By the parallelism of β we have ∪i{Si} →→β ∪iPi. This proves M →→β N .
To prove that B⊆ β, it is sufficient to prove that
Bk⊆ ηβ.

In fact if Bk⊆ ηβ then B = ∪kBk ⊆ ηβ ⊆ β.
This is what we do in the following, by induction on k. The case k = 0 is trivial. Suppose that Bk⊆ ηβ and let us prove that Bk+1⊆ ηβ. Let S be a simple term and M be a term such that S →Bk+1 M . By case on the last rule used to prove S →Bk+1 M :
If S →Bk+1 M with S →Bk M then the result holds by induction.
If S →Bk+1 M with S = S1M1 and M = P1M2 with S1 →Bk P1 and M1 →B M2. Then by induction hypothesis S1 →ηβ P1 and M1 →→β M2 that is {S1} →→β P1 and M1 →→β M2. By the parallelism of β we have {S1M1} →→β P1M2 that is S1M1 →ηβ P1M2.
If S →Bk+1 M with S = (λx.T1)M1, M = P1[x := M2], T1 →Bk P1 and M1 →Bk M2. By induction hypothesis, we have T1 →ηβ P1 and M1 →→β M2. We want to show that (λx.T1)M1 →ηβ P1[x := M2] that is {(λx.T1)M1} →β P1[x := M2], which is obviously true.
If S →Bk+1 P with S = λx.S1, P = λx.P1 and S1 →Bk P1. By induction hypothesis, we obtain {S1} →→β P1 and by the parallelism of →→β we conclude
{λx.S1} →→β λx.P1 that is S →ηβ M .


Lemma 5.4 Let x be a variable and M1,M ' , M2,M ' be terms. If M1 →
o
M ' and

M2 → M ' , then
1	2	B	1



M1[x := M2] →
M ' [x := M ' ]

B	1	2
Proof We prove by induction on k that if M1 →	M ' and M2 → M ' , then

'	'	Bk	1 '	B	2
M1[x := M2] →B M1[x := M2]. For k =0 we have M1 = M1 and then we conclude
by parallelism of B (applying Lemma 3.10).
o
Proposition 5.5 The relation B is confluent.
Proof We prove by induction on k that the pair (Bk, B) (this clearly entail the proposition). The case k = 0 is trivial since B0 is just the identity function. So let us assume that (Bk, B) satisfies the multi-diamond property and let us prove that (Bk+1, B) satisfies also the multi-diamond property. By Lemma 3.12, it is sufficient to show that (B^ , B) satisfies the multi-diamond property. This is what we do in the following. Let S be a simple term and M1,... , Mn be terms such that S →Bk+1 Mi for all i. By case on the structure of S.
The case S = x for a variable x is not possible.

If S = λx.T then we have Mi = λx.Ni with T →Bk Ni for all i. Then by induction

hypothesis, there exists a N ' such that Ni →
Then we are done.
If S = TM then there are two cases
N ' and thus λx.Ni →
λx.N '.

· If for all i we have Mi = M 1M 2 with T →B  M 1 and M →	M 2. Then
i	i	k	i	Bk	i

by induction hypothesis, there exist N ' and N ' such that M 1 →
B
' and

M 2 →B
case.
N ' for all i. The parallelism of the relation B (Prop 5.2) concludes the

· Otherwise, T = λx.U and there exists a 1 ≤ q ≤ n such that
M1 = N1[x := P1] ... and Mq = Nq[x := Pq]
Mq+1 = (λx.Nq+1)Pq+1 ... and Mn = (λx.Nn)Pn
with λx.U →Bk λx.Ni and M →Bk Pi. By induction hypothesis, there exist a
term N ' and a term P ' such that λx.Ni → λx.N ' and Pi → P '. Then we
'	'	B	B
prove that Mi →B N [x := P ] by applying Lemma 5.4 for the terms M1,... , Mq
and by definition of ρ otherwise.
o

Confluence of β
Theorem 5.6 The relation β over terms of the λ -calculus enjoys the Church- Rosser property.

Proof Since the reflexive and transitive closure of B is β (Lemma 5.3) and since the relation B is confluent (Prop. 5.5) then the result clearly holds.	o

Conclusion
We have studied an extension of the λ-calculus with term collections represented by canonical sets. This provides a clear operational semantics for the λ-calculi for (strict) parallel functions and this is a first step in the study of the ρ-calculus with non-unitary matching theories.
The work of A.Reilles [20,19] on canonical abstract syntax trees is strongly related to the approach of this paper. Actually, the former provides the capability to maintain (in a very efficient way) the internal representation of data in canonical form with respect to a rewrite system. In the case of the λ -calculus, the set of rules used to ensure that the canonical invariant is the distributivity of sets over abstractions and applications.

Acknowledgments
A. Miquel suggests to the author the reading of [14]. This was the starting point of the work. H. Cirstea gave deep feedbacks on previous versions of the paper. This was very useful. We also thank L. Vaux and C. Kirchner for useful interactions and comments on this work.

References
ASF+SDF.	A	component-based	language	development	environment.
http://www.cwi.nl/projects/MetaEnv/ .
H. Barendregt. The Lambda-Calculus, its syntax and semantics. Studies in Logic and the Foundation of Mathematics. Elsevier Science Publishers B. V. (North-Holland), Amsterdam, 1984. Second edition.
G. Barthe, H. Cirstea, C. Kirchner, and L. Liquori. Pure patterns type systems. In Principles of Programming Languages - POPL2003, New Orleans, USA. ACM, January 2003.
P. Borovansky´, C. Kirchner, H. Kirchner, P.-E. Moreau, and C. Ringeissen. An overview of ELAN. In
Proc. of WRLA, volume 15. ENTCS, September 1998.
G. Boudol. Lambda-calculi for (strict) parallel functions. Inf. Comput, 108(1), January 1994.
H. Cirstea. Calcul de r´e´ecriture : fondements et applications. PhD thesis, Universit´e Henri Poincar´e - Nancy I, 2000. October 25.
H. Cirstea and C. Kirchner. The rewriting calculus — Part I and II. Logic Journal of the Interest Group in Pure and Applied Logics, 9(3):427–498, May 2001.
H. Cirstea, C. Kirchner, and L. Liquori. Matching Power. In Proceedings of RTA’2001, Lecture Notes in Computer Science. Springer-Verlag, May 2001.
H. Cirstea, L. Liquori, and B. Wack. Rewriting calculus with fixpoints: Untyped and first-order systems. volume 3085. Springer, 2003.
M. Dezani-Ciancaglini, U. de’Liguoro, and A. Piperno. Filter models for a parallel and non deterministic lambda-calculus. In Mathematical Foundations of Computer Science 1993, 18th International Symposium, volume 711 of lncs, 1993.
Elan. The ELAN system:. http://elan.loria.fr/ .
G. Faure and A. Miquel. Towards a denotational semantics for the rho-calculus. Technical report, LORIA, 2005.
M. Fern´andez, I. Mackie, and F.-R. Sinot. Interaction nets vs. the rho-calculus: Introducing bigraphical nets. In Proceedings of EXPRESS’05, satellite workshop of Concur, ENTCS. Elsevier, 2005.
T. Herhard and L. Reigner. The differential lambda-calculus. Theoretical Computer Science, 309, 2003.
C. March´e. Normalized rewriting: An alternative to rewriting modulo a set of equations. Journal Symb. Comput, 21(3), 1996.
Maude. The maude system:. http://maude.cs.uiuc.edu/ .
Mod. Modulogic home page. http://modulogic.inria.fr .
V. Prevosto. Conception et Implantation du langage FoC pour le d´eveloppement de logiciels certifi´es. Th`ese de doctorat, Universit´e Paris 6, September 2003.
A. Reilles. Canonical abstract syntax trees. In Proceedings of the 6th International Workshop on Rewriting Logic and its Applications. Electronic Notes in Theoretical Computer Science, 2006. to appear.
A. Reilles. R´e´ecriture et compilation de confiance. PhD thesis, November 2006.
A. Stump, A. Deivanayagam, S. Kathol, D. Lingelbach, and D. Schobel. Rogue Decision Procedures. In 1st International Workshop on Pragmatics of Decision Procedures in Automated Reasoning, 2003.
M. Takahashi. Parallel reductions in λ-calculus. Inf. Comput., 118(1), 1995.
Tom. The Tom language:. http://tom.loria.fr/.
B. Wack. The simply-typed pure pattern type system ensures strong normalization. IFIP-WCC TCS, 2004.
B. Wack. A Curry-Howard-De Bruijn Isomorphism Modulo. Under submission, 2006.
