Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 332 (2017) 95–111
www.elsevier.com/locate/entcs
Hybrid and Subexponential Linear Logics
Jo¨elle Despeyroux 1
INRIA and CNRS, I3S, Sophia-Antipolis, France
Carlos Olarte, Elaine Pimentel2
Universidade Federal do Rio Grande do Norte. Brazil

Abstract
HyLL (Hybrid Linear Logic) and SELL (Subexponential Linear Logic) are logical frameworks that have been extensively used for specifying systems that exhibit modalities such as temporal or spatial ones. Both frameworks have linear logic (LL) as a common ground and they admit (cut-free) complete focused proof systems. The difference between the two logics relies on the way modalities are handled. In HyLL, truth judgments are labelled by worlds and hybrid connectives relate worlds with formulas. In SELL, the linear logic exponentials (!, ?) are decorated with labels representing locations, and an ordering on such labels defines the provability relation among resources in those locations. It is well known that SELL, as a logical framework, is strictly more expressive than LL. However, so far, it was not clear whether HyLL is more expressive than LL and/or SELL. In this paper, we show an encoding of the HyLL’s logical rules into LL with the highest level of adequacy, hence showing that HyLL is as expressive as LL. We also propose an
encoding of HyLL into SELLe (SELL plus quantification over locations) that gives better insights about the meaning of worlds in HyLL. We conclude our expressiveness study by showing that previous attempts of encoding Computational Tree Logic (CTL) operators into HyLL cannot be extended to consider the whole set of temporal connectives. We show that a system of LL with fixed points is indeed needed to faithfully encode the behavior of such temporal operators.
Keywords: Linear Logic, Hybrid Linear Logic, subexponentials, logical frameworks, Temporal Logic.


Introduction
Logical frameworks are adequate tools for specifying proof systems, since they sup- port levels of abstraction that facilitate writing declarative specifications of object- logic proof systems. Many frameworks have been used for the specification of proof systems, and linear logic [13] (LL) is one of the most successful ones. This is mainly because LL is resource conscious and, at the same time, it can internalize classical and intuitionistic behaviors (see, for example, [6, 14]).

1 Email: joelle.despeyroux@inria.fr
2 Email: {carlos.olarte, elaine.pimentel}@gmail.com

http://dx.doi.org/10.1016/j.entcs.2017.04.007
1571-0661/© 2017 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

However, since specifications of object-level systems into the logical framework should be natural and direct, there are some features that cannot be adequately captured in LL, in particular modalities different from the ones present in LL.
Extensions of LL have been proposed in order to fill this gap. The aim is to propose stronger logical frameworks that preserve the elegant properties of linear logic as the underlying logic. Two of such extensions are HyLL (Hybrid Linear Logic) 3 [8] and SELL (Subexponential Linear Logic) [9,19]. These logics have been extensively used for specifying systems that exhibit modalities such as temporal or spatial ones. The difference between HyLL and SELL relies on the way modalities are handled.
In HyLL, truth judgments are labeled by worlds and two hybrid connectives relate worlds with formulas: the satisfaction at which states that a proposition is true at a given world, and the localization ↓ which binds a name for the (current) world the proposition is true at. These constructors allow for the specification of modal connectives such as 2A (A is true in all the accessible worlds) and 3A (there exists an accessible world where A holds). The underlying structure on worlds allows for the modeling of transitions systems and the specification of temporal formulas [8, 10].
In SELL, the LL exponentials (!, ?) are decorated with labels: the formula ?aA can be interpreted as A holds in a location, modality, or world a. Moreover, A can be deduced in a location b related to a (b ≤ a). On the other side, the formula
?a!aA means that A is conﬁned into the location a, that is, the information A is not propagated to other worlds/locations related to a. While linear logic has only seven logically distinct prefixes of bangs and question-marks (none, !, ?, !?, ?!, !?!, ?!?), SELL allows for an unbounded number of such prefixes (e.g., !a?c?d). Hence SELL enhances the expressive power of LL as a logical framework.
Up to now, it was not clear how HyLL is related to LL and/or SELL. In this paper we answer that question by showing a direct encoding of the HyLL’s logical rules into LL with the highest level of adequacy. Hence, we show that HyLL is actually as expressive as LL.
We also propose an encoding of HyLL into SELLA (SELL with quantification over locations) that gives better insights about the meaning of worlds in HyLL. More precisely, we represent HyLL formulas as formulas in SELL and encode the logical rules as formulas in SELLA. We show that a flat subexponential structure is sufficient for representing any world structure in HyLL. This explains better why the worlds in HyLL do not add any expressive power to LL: they cannot control the logical context as the subexponentials do with the promotion rule.
HyLL has been shown to be a flexible framework for the specification of biological systems [10] where both the system and its properties are specified using the same logic. More precisely, the properties of interest are first written in Computational Tree Logic (CTL) and later encoded as HyLL formulas. However, there was no a formal statement about the CTL fragments that can be adequately captured

3 Actually, HyLL is an extension of intuitionistic linear logic (ILL), while SELL can be viewed as an extension of both ILL or LL.

in HyLL. Hence, the last contribution of this paper is to continue our study of HyLL theory and to push forward previous attempts of using this logic for the specification of transition systems and formulas in CTL. We show that it is not possible to adequately encode, in HyLL, the universal path quantifier A (for all paths), nor the temporal formula EGQ (there exists a path where Q always holds). The definition of such formulas is recursive, hence one needs to use induction, at the meta-level, to accurately capture their behavior. Instead of using meta-reasoning, as done in [10], we use a logical framework featuring fixed point constructs. More precisely, we use additive multiplicative LL with fixed point operators (μMALL) [3] for the encoding of CTL. We show that the well known fixed point characterization of CTL [4] can be matched by the fixed point operators of μMALL.
The rest of the paper is organized as follows. We briefly recall LL in Section 2.1, HyLL in Section 2.2 and SELL in Section 2.3. The encoding of HyLL logical rules into LL is discussed in Section 3.1. Section 3.2 presents the encoding of HyLL into SELLA. We also prove that information confinement, a feature in SELL that is needed to specify spatial systems, cannot be captured in HyLL. Section 4 shows how to encode CTL into μMALL. Section 5 concludes the paper. The companion technical report [11] contains the detailed proofs of the results as well as the complete set of rules of the sequent calculi used in this paper.

Preliminaries
Although we assume that the reader is familiar with linear logic [13] (LL), we review some of its basic proof theory in the following sections.

Linear Logic and Focusing
Literals are either atomic formulas (p) or their negations (p⊥). The connectives ⊗
......
and ... and their units 1 and ⊥ are multiplicative; the connectives ⊕ and & and their
units 0 and T are additive; 6 and E are (first-order) quantifiers; and ! and ? are the exponentials (called bang and question-mark, respectively).
First proposed by Andreoli [2] for linear logic, focused proof systems provide normal form proofs for cut-free proofs. The connectives of linear logic can be divided into two classes. The negative connectives have invertible introduction rules: these
......
connectives are ..., ⊥, &, T, 6, and ?. The positive connectives ⊗, 1, ⊕, 0, E, and !
are the de Morgan duals of the negative connectives. A formula is positive if it is a negated atom or its top-level logical connective is positive. Similarly, a formula is negative if it is an atom or its top-level logical connective is negative.
Focused proofs are organized into two phases. In the negative phase, all the invertible inference rules are eagerly applied. The positive phase begins by choosing a positive formula F on which to focus. Positive rules are applied to F until either 1 or a negated atom is encountered (and the proof must end by applying the initial rules) or the promotion rule (!) is applied or a negative subformula is encountered, when the proof switches to the negative phase.

This change of phases on proof search is particularly interesting when the focused formula is a bipole [2].
Definition 2.1 We call a monopole a linear logic formula that is built up from atoms and occurrences of the negative connectives, with the restriction that ? has atomic scope. Bipoles, on the other hand, are positive formulas built from monopoles and negated atoms using only positive connectives, with the additional restriction that ! can only be applied to a monopole.
Focusing on a bipole will produce a single positive and a single negative phase. This two-phase decomposition enables us to adequately capture the application of object-level inference rules by the meta-level linear logic, as will be shown in Section 3.
The focused system LLF for classical linear logic can be found in [11].
Hybrid Linear Logic
Hybrid Linear Logic (HyLL) is a conservative extension of intuitionistic first-order linear logic (ILL) [13] where the truth judgments are labeled by worlds representing constraints on states and state transitions. Judgments of HyLL are of the form “A is true at world w”, abbreviated as A @ w. Particular choices of worlds produce particular instances of HyLL. Typical examples are “A is true at time t”, or “A is true with probability p”. HyLL was first proposed in [8] and it has been used as a logical framework for specifying biological systems [10].
Formally, worlds are defined as follows.
Definition 2.2 [HyLL worlds] A constraint domain W is a monoid structure
⟨W, ., ι⟩. The elements of W are called worlds and its reachability relation ≤ : W ×W
is defined as u ≤ w if there exists v ∈ W such that u.v = w.
The identity world ι is ≤-initial and it is intended to represent the lack of any con- straints. Thus, the ordinary first-order linear logic is embeddable into any instance of HyLL by setting all world labels to the identity. A typical, simple example of constraint domain is T = ⟨IN, +, 0⟩, representing instants of time.
Atomic propositions (p, q, . . .) are applied to a sequence of terms (s, t, .. .), which are drawn from an untyped term language containing constants (c, d, .. .), term variables (x, y, . . .) and function symbols (f, g, . . .) applied to a list of terms (t). Non- atomic propositions are constructed from the connectives of first-order intuitionistic linear logic and the two hybrid connectives. Namely, satisfaction (at), which states that a proposition is true at a given world (w, ι, u.v, . . .), and localization (↓), which binds a name for the (current) world the proposition is true at. The following grammar summarizes the syntax of HyLL.
t   ::= c | x | f (t)
A, B ::= p(t) | A ⊗ B | 1 | A → B | A & B | T | A ⊕ B | 0 | !A | 6x. A | Ex. A | (A at w) | ↓ u. A | 6u. A | Eu. A

Note that world u is bounded in the propositions ↓ u. A, 6u. A and Eu. A. World variables cannot be used in terms, and neither can term variables occur in worlds. This restriction is important for the modular design of HyLL because it keeps purely logical truth separate from constraint truth. We note that ↓ and at commute freely with all non-hybrid connectives [8].
The sequent calculus [12] presentation of HyLL uses sequents of the form Γ; Δ ▶ C @ w where Γ (unbounded context ) is a set and Δ (linear context ) is a multiset of judgments of the form A @ w. Note that in a judgment A @ w (as in a proposition A at w), w can be any expression in W, not only a variable.
The inference rules dealing with the new hybrid connectives are depicted below (the complete set of rules can be found in [11]).


Γ; Δ ▶ A@u


Γ; Δ ▶ (A at u)@w
atR
Γ; Δ, A@u ▶ C@w


Γ; Δ, (A at u)@v ▶ C@w
atL



Γ; Δ ▶ A[w/u]@w
↓ R
Γ; Δ ▶↓ u.A@w
Γ; Δ, A[v/u]@v ▶ C@w
↓ L
Γ; Δ, ↓ u.A@v ▶ C@w

Note that (A at u) is a mobile proposition: it carries with it the world at which it is true. Weakening and contraction are admissible rules for the unbounded context. The most important structural properties are the admissibility of the general identity (i.e. over any formulas, not only atomic propositions) and cut theorems.
While the first provides a syntactic completeness theorem for the logic, the latter guarantees consistency (i.e. that there is no proof of .; . ▶ 0 @ w).
Theorem 2.3 (Identity/Cut)
Γ; A @ w ▶ A @ w
If Γ; Δ ▶ A @ u and Γ; Δj,A @ u ▶ C @ w, then Γ; Δ, Δj ▶ C @ w
If Γ; . ▶ A @ u and Γ,A @ u;Δ ▶ C @ w, then Γ; Δ ▶ C @ w.
HyLL is conservative with respect to intuitionistic linear logic: as long as no hybrid connectives are used, the proofs in HyLL are identical to those in ILL. Moreover, HyLL is more expressive than S5, as it allows direct manipulation of the worlds using the hybrid connectives, while HyLL’s δ connective (see Section 4) is not definable in S5. We also note that HyLL admits a complete focused [2] proof system. The interested reader can find proofs and further meta-theoretical theorems about HyLL in [8].

Subexponentials in Linear Logic
Linear logic with subexponentials 4 (SELL) shares with LL all its connectives except the exponentials: instead of having a single pair of exponentials ! and ?, SELL may contain as many subexponentials [9, 15, 19], written !a and ?a, as one needs. The

4 We note that intuitionistic and classical SELL are equally expressive, as shown in [5]. Hence, although we will introduce here the classical version of SELL (needed in Section 3.2), we could also present SELL as an extension of ILL.

grammar of formulas in SELL is as follows:


F ::= 0 | 1 | T |⊥| p(t) | F1 ⊗ F2 | F1 ⊕ F2 | F1
Ex.F | 6x.F | !aF | ?aF
... F2 | F1 & F2 |


The proof system for SELL is specified by a subexponential signature Σ= ⟨I, ≤,U⟩, where I is a set of labels, U ⊆ I is a set specifying which subexponentials allow weakening and contraction, and ≤ is a pre-order among the elements of I. We shall use a, b, ... to range over elements in I and we will assume that ≤ is upwardly closed with respect to U , i.e., if a ∈ U and a ≤ b, then b ∈ U .
The system SELL is constructed by adding all the rules for the linear logic connectives except those for the exponentials.
The rules for subexponentials are dereliction and promotion of the subexponen- tial labeled with a ∈ I

▶ ?a1 F1,... ?an Fn,G 
▶ Γ,G 

a	a	a	!a
a	?a

▶ ? 1 F1,... ? n Fn, ! G	▶ Γ, ? G

Here, the rule !a has the side condition that a ≤ ai for all i. That is, one can only introduce a !a if all other formulas in the sequent are marked with indices that are greater than or equal to a. Moreover, for all indices a ∈ U , we add the usual rules of weakening and contraction to ?a.
We can enhance the expressiveness of SELL with the subexponential quantifiers
A and  ( [16, 19]) given by the rules (omitting the subexponential signature)


 ▶ Γ, G[le/lx]
▶ Γ, Alx : a.G
 ▶ Γ, G[l/lx] 
A	▶ Γ,  lx : a.G 


where le is fresh. Intuitively, subexponential variables play a similar role as eigen- variables. The generic variable lx : a represents any subexponential, constant or variable in the ideal of a. Hence lx can be substituted by any subexponential l of type b (i.e., l : b) if b ≤ a. We call the resulting system SELLA.
As shown in [16, 19], SELLA admits a cut-free, complete focused proof system (presented in [11]). That will be the system used throughout this text.
Theorem 2.4 SELLA admits cut-elimination for any subexponential signature Σ.

Relative Expressiveness Power of HyLL and SELL
We observe that, while linear logic has only seven logically distinct prefixes of bangs and question-marks, SELL allows for an unbounded number of such prefixes, e.g.,
!i, or !i?j. Hence, by using different prefixes, we allow for the specification of richer systems where subexponentials are used to mark different modalities/states. For instance, subexponentials can be used to represent contexts of proof systems [17];

to specify systems with temporal, epistemic and spatial modalities [16, 19] and soft- constraints or preferences [20]; to specify Bigraphs [7]; and to specify and verify biological [18] and multimedia interacting systems [1].
One may wonder whether the use of worlds in HyLL increases also the expres- siveness of LL. In this section we prove that this is not the case by showing that HyLL rules can be directly encoded into LL by using the methods proposed in [14].
HyLL and Linear Logic
In [14] classical linear logic (LL) was used as the logical framework for specifying a number of logical and computational systems. The idea is simple: use two meta- level predicates [·♩ and [·| for identifying objects that appear on the left or on the right side of the sequents in the object logic, respectively. Hence, object-level sequents of the form B1,..., Bn ▶ C1,..., Cm (where n, m ≥ 0) are specified as the multiset [B1♩,..., [Bn♩, [C1|,..., [Cm|. If an object-formula B is in a (object- level) classical context, it will be specified in LL as ?[B♩ or ?[B| (depending on the side of B in the original sequent). Hence HyLL sequents of the form Δ; Γ ▶ C

will be encoded in LL as ?[Δ♩
....
...
[Γ♩
.....
...
[C| where, if Ψ = {F1, ..., Fn}, then

[Ψ♩ = [F1♩
......
.
... [Fn♩ and ?[Ψ♩ = ?[F1♩
......
.
... ?[Fn♩ (similarly for [·|).

Inference rules are specified by a rewriting clause that replaces the active formula in the conclusion by the active formulas in the premises. The linear logic connectives indicate how these object level formulas are connected: contexts are copied (&) or split (⊗), in different inference rules (⊕) or in the same sequent ( ...). As a matter of example, the additive version of the inference rules for conjunction in classical logic


Δ,A −→ Γ Δ,A ∧ B −→ Γ
∧L1		Δ,B −→ Γ Δ,A ∧ B −→ Γ
∧L2	Δ −→ Γ,A	Δ −→ Γ,B ∧R
Δ −→ Γ,A ∧ B

can be specified as
∧L : EA, B.([A ∧ B♩⊥ ⊗ ([A♩⊕ [B♩))	∧R : EA, B.([A ∧ B|⊥ ⊗ ([A| & [B|)) The following definition shows how to encode HyLL inference rules into LL.
Definition 3.1 [HyLL rules into LL] Let w, d, h and o denote, respectively, the types for worlds, (first-order) objects, HyLL judgments and LL formulas. Let [·| and [·♩ be predicates of the type h → o and A, B, C have, respectively, types w → h, d → h and h. The encoding of HyLL inference rules into LL is depicted in Figure 1 (we omit the encoding of most of the linear logic connectives that can be found in [14]).
Observe that left and right inference rules for the hybrid connectives (at and ↓) are the same (see Section 2.2). This is reflected in the duality of the encoding where we only replace [·| with [·♩. Observe also that the inference rules for the quantifiers (first-order and worlds) look the same. The difference is on the type of the variables involved. Since A has type w → h, the encoding clause 6R(W ) guarantees that the


j	j	⊥	j

j	j	⊥

.	j

⊗ R	: EC, C , w.([(C ⊗ C )@w|
⊗ [C@w|⊗ [C @w|) ⊗ L	: EC, C , w.([(C ⊗ C )@w♩
⊗ ([C@w♩	[C @w♩))

at R	: EC, u, w.([(C at u)@w|⊥ ⊗ [C@u|)	at L	: EC, u, w.([(C at u)@w♩⊥ ⊗ [C@u♩)
↓ R	: EA, u, w.([↓ u.A@w|⊥ ⊗ [(A w)@w|)	↓ L	: EA, u, w.([↓ u.A@w♩⊥ ⊗ [(A w)@w♩)
6R(F ) : EB, u.([6x.B@u|⊥ ⊗ 6x.[(B x)@u|)	6L(F ) : EB, u.([6x.B@u♩⊥ ⊗ Ex.[(B x)@u♩)
6R(W ) : EA, u.([6v.A@u|⊥ ⊗ 6v.[(A v)@u|)	6L(W ) : EA, u.([6v.A@u♩⊥ ⊗ Ev.[(A v)@u♩)
!L	: EC, w.([!C@w♩⊥ ⊗ ?[C@w♩)	Init	: EC, w.([C@w♩⊥ ⊗ [C@w|⊥)
Fig. 1. HyLL rules into LL. (Definition 3.1)
variable v has type w. Analogously, since B has type d → h, then x has type d in the clause 6R(F ). This neat way of controlling the behavior of objects by using types is also inherited by the encoding of the other object level inference rules.
The following theorem shows that, in fact, the encoding of HyLL into LL is ade- quate in the sense that a focused step in FLL corresponds exactly to the application of one inference rule in HyLL.
Theorem 3.2 (Adequacy) Let Υ be the set of clauses in Figure 1. The sequent Γ; Δ ▶ F @w is provable in HyLL iff Υ, [Γ♩; [Δ♩, [F @w| ⇑ · is provable in FLL. Moreover, the adequacy of the encodings is on the level of derivations meaning that, when focusing on a speciﬁcation clause, the bipole derivation corresponds exactly to applying the introduction rule at the object level.
Proof. We will illustrate here the case for rule atL, the other cases are similar. Applying the object level rule


Γ; Δ, A@u ▶ C@v


Γ; Δ, (A at u)@w ▶ C@v
atL

corresponds to deciding on the LL formula given by the encoding of the rule atL
(stored in Υ). Due to focusing, the derivation in LL has necessarily the shape
I1	Υ, [Γ♩; [Δ♩, [C@v|, [A@u♩⇑· R ⇓,R ⇑


Υ, [Γ♩; [(A at u)@w♩⇓ [(A at u)@w♩⊥
Υ, [Γ♩; [Δ♩, [C@v|⇓ [A@u♩

Υ, [Γ♩; [Δ♩, [(A at u)@w♩, [C@v|⇓ [(A at u)@w♩⊥ ⊗ [A@u♩	⊗
Υ, [Γ♩; [Δ♩, [(A at u)@w♩, [C@v|⇓ EC, u, w.([(C at u)@w♩⊥ ⊗ [C@u♩) 3 ×E 
Υ, [Γ♩; [Δ♩, [(A at u)@w♩, [C@v|⇑·	D2
That is, the LL formula corresponding to (A at u)@w is consumed and, in the end of the focused phase, the encoding of A@u is stored into the linear context. This mimics exactly the application of the Rule atL in HyLL.	2
HyLL and SELL
Linear logic allows for the specification of two kinds of context maintenance: both weakening and contraction are available (classical context) or neither is available (linear context). That is, when we encode (linear) judgments in HyLL belonging to different worlds, the resulting meta-level atomic formulas will be stored in the same (linear) LL context. The same happens with classical HyLL judgments and

⊗ R	: EC, Cj.  w : ∞.(!w[(C ⊗ Cj)@w|⊥ ⊗ ?w[C@w| ⊗ ?w[Cj@w|)
at R	: EA.  u : ∞,w : ∞.(!w[(A at u)@w|⊥ ⊗ ?u[A@u|)
at L	: EA.  u : ∞,w : ∞.(!w[(A at u)@w♩⊥ ⊗ ?u[A@u♩)
↓ R	: EA.  u : ∞,w : ∞.(!w[↓ u.A@w|⊥ ⊗ ?w[(A w)@w|)
↓ L	: EA.  u : ∞,w : ∞.(!w[↓ u.A@w♩⊥ ⊗ ?w[(A w)@w♩)
6R(F ) : EA, w : ∞.(!w[6x.B@w|⊥ ⊗ 6x.?w[(B x)@w|)
6R(W ) : EA,  w : ∞.(!w[6v.A@w|⊥ ⊗ Av : ∞.?w[(A v)@w|)
!L	: EC,  w : ∞.(!w[!C@w♩⊥ ⊗ ?c?w[C@w♩)
Fig. 2. HyLL rules into SELLe. (Definition 3.3)

the classical LL context.
Although this is perfectly fine, encoding HyLL into SELLA allows for a better understanding of worlds in HyLL as we shall see. We use subexponentials to repre- sent worlds, where each world has its own linear context. More precisely, a HyLL judgment of the shape F @w in the (left) linear context is encoded as the SELLA formula ?w[F @w♩. Hence, HyLL judgments that hold at world w are stored at the w linear context of SELLA. A judgment of the form G@w in the classical HyLL context is encoded as the SELLA formula ?c?w[G@w♩. That is, the encoding of G@w is stored in the unbounded (classical) subexponential context c.
The next definition introduces the encoding of HyLL inference rules into SELLA. Observe that, surprisingly, the subexponential structure needed is flat and it does not reflect the order on worlds. This is explained by the fact that worlds in HyLL do not control the context on rules as the promotion rule in SELL does. This also explains why HyLL does not add any expressive power to LL.
Definition 3.3 Let w, d, h, [·|, [·♩, A, B,C be as in Definition 3.1 and o be the type for SELLA formulas. Given a HyLL constraint domain W, consider a subexponential signature Σ = ⟨I, ≤,U⟩ such that I = W ∪ {∞, c}, w ≤ ∞ for any w ∈ I and, for any u, w ∈ W ∪ {c}, u /≤ w. Moreover, U = {c, ∞}. The encoding of HyLL inference rules into SELLA is depicted in Figure 2 (we omit the encodings of the other connectives, that follow similarly).
Note that w : ∞ represents any subexponential in the ideal of ∞. This means that, in w : ∞.F , the subexponential variable w could be substituted, in principle, by any element of I. But note that, since world symbols are restricted to W, substituting w by c or ∞ would not match any encoded formula in the context. That is, the proposed subexponential signature correctly specifies the role of worlds in HyLL.
The following theorem shows that our encoding is indeed adequate.
Theorem 3.4 (Adequacy) Let Υ be the set of formulas resulting from the en- coding in Deﬁnition 3.3. The sequent Γ; Δ ▶ F @w is provable in HyLL iff c :

{Υ, [Γ♩}, wi : [Δ♩, ?w[F @w|; · ⇑ is provable in SELLA. 5 Moreover, the adequacy of the encodings is on the level of derivations.
Proof. Again, we will consider the rule atL, as the other cases are similar. If we decide to focus on the SELLA formula corresponding to the encoding of atL (stored in ?cΥ), we obtain


w : [(A at u)@w♩; · ⇑ [(A at u)@w♩⊥ D, I
c : {Υ, [Γ♩},w : [(A at u)@w♩; · ⇓ !w[(A at u)@w♩⊥ !
c : {Υ, [Γ♩}, wi : [Δ♩,v : [C@v|,u : [A@u♩; · ⇑ · 
c : {Υ, [Γ♩}, wi : [Δ♩,v : [C@v|; · ⇓ ?u[A@u♩

R ⇑, ?s

c : {Υ, [Γ♩},w : [Δ♩,w : [(A at u)@w♩,v : [C@v|; · ⇓ !w[(A at u)@w♩⊥ ⊗ ?u[A@u♩	⊗

i

c : {Υ, [Γ♩}, wi : [Δ♩,w : [(A at u)@w♩,v : [C@v|; · ⇓ EC,  u, w.(!w[(C at u)@w♩⊥?u ⊗ [C@u♩)
E, 

c : {Υ, [Γ♩}, wi : [Δ♩,w : [(A at u)@w♩,v : [C@v|; · ⇑	D

Observe that, in a (focused) derivation proving !wF , the only contexts that can be present are w and the ∞ contexts due to the promotion rule and the ordering in Σ. Since the encoding does not store any formula into the context ∞, the formula
!wF must necessarily be proved from the formulas stored in w. Thus, unlike the LL derivation after Theorem 3.2, the context c is weakened in the left-hand side derivation since c /≤ w. Hence [(A at u)@w♩ stored initially in the location w is substituted by [A@u♩ in the location u in one focused step.	2

3.3	Information Conﬁnement
One of the features needed to specify spatial modalities is information conﬁnement : a space/world can be inconsistent and this does not imply the inconsistency of the whole system. We finish this section by showing that information confinement, a feature that can be specified in SELL, cannot be modeled in HyLL.
In [16] the combination of subexponentials of the form !w?w was used in order to specify information confinement in SELL. More precisely, since the sequents (in a 2-sided sequent presentation) !w?w0 ▶ 0 and !w?w0 ▶ !v?v0 are not provable in SELL, it is possible to specify systems where inconsistency is local to a given space and does not propagate to the other locations.
In HyLL, however, it is not possible to confine inconsistency: the HyLL rule Γ; Δ, 0@u ▶ F @w 0L
shows that any formula F in any world w is derivable from 0 appearing in any world
u. Observe that, even if we exchange the rule 0L for a weaker version

j
Γ; Δ, 0@w ▶ F @w	L

5 Clarifying some notation: if Δ = {F1@w1,..., Fn@wn}, then ?wi [Δ♩ = ?w1 [F1@w1♩,..., ?wn [Fn@wn♩. Observe that, in the negative phase, such formulas will be stored at their respective contexts, that will be represented by wi : [Δ♩.

the rule 0L would still be admissible

	 0j Γ; Δ, 0@w ▶ (0 at v)@w		L



0j
	Γ; Δ, 0@v ▶ F @v	L
atL
Γ; Δ, (0 at v)@w ▶ F @v

Γ; Δ, 0@w ▶ F @v	cut

Computation Tree Logic (CTL) in Linear Logic.
Hybrid linear logic is expressive enough to encode some forms of modal operators, thus allowing for the specification of properties of transition systems. As mentioned in [10], it is possible to encode CTL temporal operators into HyLL considering existential (E) and bounded universal (A) path quantifiers. We show in this section the limitation of such encodings and how to fully capture E and A CTL quantifiers in linear logic with fixed points. For that, we shall use the system μMALL [3] that extends MALL (multiplicative, additive linear logic) with fixed point operators.

CTL connectives and path quantifiers
Let us recall the meaning of the temporal operators in CTL. X (Next) means “at the next state”. F (Future) means “in some future” while G (Globally) means “in all futures”. ϕUψ (ϕ until ψ) means “from now, ϕ will be true in every steps until some future point (possibly including now) where ψ holds (and from that point on, ϕ can be true or false)”.
The CTL quantifier E (Exists) means “for some path” while A (All) means “for all paths”. Formulas in CTL are built from propositional variables a, b, c, ..., the usual propositional logic connectives and the temporal connectives preceded by a path quantifier:

F ::= p | F ∧ F | F ∨ F | QXF | QFF | QGF | Q[F UF ]	Q ∈ {A, E}	(1)
where p is a state formula.

Transition Systems
Consider a set of propositional CTL variables V = {a1, ..., an}. A state s is a valuation from V into the set {true, false}. We shall use pres(ai) (resp. abs(ai)) to denote that s(ai) = true (resp. s(ai) = false). Hence, a state s on the set V can be seen as a conjunction of the form p1(a1) ∧... ∧ pn(an) where pi ∈ {pres, abs}.
We consider transition systems defined by states as above and transition rules
of the form r : s → sj. For instance, if V = {a, b}, the transition rule r : pres(a) ∧
abs(b) → abs(a) ∧ pres(b) enables a transition from a state s = {a '→ true,b '→
false} to the state sj = {a '→ false,b '→ true}. We shall use s ==r⇒ sj to denote such transitions.

Transition Systems and HyLL
In order to specify reachability properties in transition systems, some modal con- nectives are defined in HyLL [8]:
2A d=ef ↓u. 6w. (A at u.w)  3A d=ef ↓u. Ew. (A at u.w)
δv A d=ef ↓u. (A at u.v)   A U B d=ef ↓ u. Ev. (B at u.v  & 6w ≺ v. A at u.w)
2A (resp. 3A) represents all (resp. some) state(s) satisfying A and reachable in some path from now. The connective δ represents a form of delay: δv A stands for an intermediate state in a transition to A. Informally it can be thought to be “v before A”. AUB represents that A holds in all the steps until B holds.
We may use such modal operators in order to encode some features of transition systems as HyLL formulas as follows. Consider a set V = {a1, ..., an} of propositional variables, let s = p1(a1) ∧···∧ pn(an) represent a state where pi ∈ {pres, abs} and r : s → sj be a rule specifying a state transition. We define the encoding [·]] from CTL states and state transitions to HyLL as
[[pres(ai)]] = pres(ai)	[abs(ai)]] = abs(ai)

[[s]] =
i∈1..n
[[pi(ai)]]	[r : s → sj]] = 6w. (([[s]] at w) −◦ δ1([[sj]]) at w)

Moreover, let F, G be CTL formulas built from states and the connectives
∧, ∨, U, EX, EF. We can define C[[F ]] as
C[[s]]	= [s]]	C[[F ∧ G]]	= C[[F ]] & C[[G]]
C[[F ∨ G]] = C[[F ]] ⊕ C[[G]] C[[E[F UG]]] = C[[F ]]U C[[G]]
C[[EXF ]]	= δ1 C[[F ]]	C[[EFF ]]	= 3C[[F ]]
It is easy to see that such encodings are faithful, that is, a (CTL) formula F holds at state s in the system defined by the transition rules R if and only if the sequent [R]]@0; [s]]@w ▶ C[[F ]]@w is provable in HyLL (see [11]). In fact, since the left linear context is always constituted by atoms, the only action that can be performed is to apply transition rules up to reaching the state satisfying F , which is reachable in a finite number of steps for this CTL’s limited grammar.
However, the above encodings cannot be extended to consider formulas of the shape EGF . In fact, the natural choice would be C[[EGF ]] = 2C[[F ]], but this en- coding would not be adequate. Consider, for instance, a system with only one rule R = {r : s → s} that loops on the same state. Clearly, in CTL, s satisfies the formula EGs. Now, consider the HyLL sequent [R]]@0; [s]]@w ▶ 2C[[s]]@w. If we decide to introduce the connectives on the right, we obtain a derivation of the shape
[[R]]@0; [s]]@w ▶ [[s]]@w.v
[[R]]@0; [s]]@w ▶ 2C[[s]]@w ↓R, 6R, atR

where v is fresh. Furthermore, if we use the implication in [R]]@0, we obtain a derivation of the shape:
[[R]]@0; [s]]@(w + 1) ▶ G
copy, 6L, −◦L
[[R]]@0; [s]]@w ▶ G

Therefore, the left and right states in the sequent [R]]@0; [s]]@(k+n) ▶ [[s]]v@w.v will never match, and this sequent is not provable. Saying this in other way, the resources in the context are enough for proving the property for a (bounded) n but not for all natural numbers. For proving this, one necessarily needs (meta-level) induction which is the same as using fixed points. The next section shows how to do that with linear logic with fixed point operators.
Encoding E and A quantiﬁers in linear logic with ﬁxed points
In order to prove (in CTL) the formula AFF at state s, we have to check if s satisfies
F . If this is not the case, we have to check that AFF holds for all the successors of
s (i.e., for all sj s.t. s ==r⇒ sj for some transition rule r). Hence, the definition of
AF is recursive and it is usually characterized as a (least) fixed point.
One way to capture this behavior would by adding fixed point operators to HyLL. But it is simpler to rely on existing systems for linear logic with fixed points. In the following, we show that it is possible to characterize the CTL formulas built from the syntax (1) into the system μMALL [3] that adds to linear logic (without exponentials) least and greatest fixed points.
μMALL shares with linear logic all the proof rules for the additive and multi- plicative connectives plus the following two rules 6


▶ Δ, St	x ▶ B Sx, (Sx)⊥
▶ Δ, νBt	ν
▶ Δ, B(μB)t μ
▶ Δ, μBt


where S is the (co)inductive invariant. The μ rule corresponds to unfolding while
ν allows for (co)induction.
Path quantifiers as fixpoints
The usual interpretation of the CTL quantifiers as fixed points (see e.g., [4]) is
EFF = μY.F ∨ EXY	EGF = νY.F ∧ EXY	E[F U G] = μY.G ∨ (F ∧ EXY )
AFF = μY.F ∨ AXY	AGF = νY.F ∧ AXY	A[F U G] = μY.G ∨ (F ∧ AXY )
In CTL, the considered transition system is assumed to be serial, i.e. every state has at least one successor. This means that, in every state, there is at least one fireable rule.
The next definition shows how to encode CTL formulas into μMALL.

6 μMALL also consider rules for equality and inequality but we do not need them in our developments.



C[[AXF ]]Y	=	&
s→s′∈Y
(neg(s) ⊕ (pos(s) ⊗ ([[sj]]
......
.

C[[EXF ]]Y	=

s→ s′∈Y
(pos(s) ⊗ ([[sj]]
......
.




j .....

C[[AFF ]]Y	= μY. φ ⊕	&
s→s′∈Y
(neg(s) ⊕ (pos(s) ⊗ ([[s ]]
... Y ))

C[[EFF ]]Y	= μY. φ ⊕


s→ s′∈Y
(pos(s) ⊗ ([[sj]]
......
.




j .....

C[[AGF ]]Y	= νY. φ &	&
s→s′∈Y
(neg(s) ⊕ (pos(s) ⊗ ([[s ]]
... Y ))

C[[EGF ]]Y	= νY. φ &

 s→ s′∈Y
(pos(s) ⊗ ([[sj]]
&
......
.




j .....

C[[A[F U G]]]Y = μY.ψ ⊕
φ &
s→s′∈Y
(neg(s) ⊕ (pos(s) ⊗ ([[s ]]
... Y )))

C[[E[F U G]]]Y = μY.ψ ⊕
 φ &


s→ s′∈Y
(pos(s) ⊗ ([[sj]]

......
.

Fig. 3. Encoding of CTL temporal operators into μMALL. Here, φ = C[[F ]]R and ψ = C[[G]]R.
Definition 4.1 [CTL into μMALL] Let R be a set of transition rules. The encoding of QX, QF and QG, for Q ∈ {A, E} is in Figure 3. Given a state s = p1(a1) ∧· · ·∧ pn(an) (as in Section 4.1), we define
[[pres(ai)]] = ai	[[abs(ai)]] = a⊥
⊥ ......	......	⊥

[[s]]	= [p1(a1)]]
... ··· ... [[pn(an)]]
[[p]]	= pos(p)

pos(s)	= [p1(a1)]] ⊗ · · · ⊗ [[pn(an)]]= [[s]]⊥
neg(s)	= ( [p1(a1)]]⊥ ⊗ T) ⊕ ··· ⊕ ([[pn(an)]]⊥ ⊗ T)
where p is a state formula. 7 Finally, we map the CTL connectives ∧ and ∨ into & and ⊕, respectively.
Let us give some intuition. Consider the rule r : s → sj. The formula pos(s) (resp. neg(s)) tests if r can (resp. cannot) be fired at the current state. The encoding of the temporal quantifiers relies on the following principles. For each transition rule, we test if the rule can be fired or not. If it can be fired, then the current state is transformed into the new state. The encoding of A (resp. E) test
all (resp. one) of the fireable rules. This explains the use of & (resp.  ).
Example 4.2 Consider the temporal formula AFF . We first check if F holds in the current state. If this is not the case, for each of the fireable rules, we consume [[s]] (using pos(s)) and release [sj]], thus updating the current state. For instance, consider the sequent ▶ [[s]], C[[AFF ]]Y and assume that the formula F does not hold at state s. If we decide to focus on C[[AFF ]]Y we obtain a derivation of the shape

7 It is useful to allow the state property to mention only a subset of the propositional variables in V. In that case, we can define [pi(ai)]] as above if ai occurs in p and T otherwise.



j  ......	j  ......
▶ [[s]], neg(s1) ⊕ (pos(s1) ⊗ ([[s1]] ... μB)  ...	▶ [[s]], neg(sm) ⊕ (pos(sm) ⊗ ([[sm]] ... μB) μ, ⊕, &
▶ [[s]], μB
The premises correspond to proving if the rule ri is fireable or not. If ri : si → sj

is fireable, we observe a derivation of the shape:
	▶ [[sj]], μB
....





⊗, ...

▶ [[s]], pos(si) ⊗ ([[sj]]
... μB)
⊕

▶ [[s]], neg(si) ⊕ (pos(si) ⊗ ([[sj]]
......
.

where s becomes sj and, from that state, μB must be proved.
Remark 4.3 Observe that, in all the clauses in Figure 3, the formula pos(s) ⊗

([[sj]]
... B), is present. We could have written instead [r]] −◦ B, which reads closer to

what we expect: “assuming that r is fired, B holds”. The formulas (L −◦ R) −◦ B
and L ⊗ (R −◦ B) are not equivalent. In fact, the first formula is equivalent to

(L ⊗ R⊥
) ...B while the second is equivalent to L ⊗ (R
... B). The first is stronger

than the second in the sense that B can choose the branch to move up with (L or R), while the second forces B to stick with R. Since the desired behavior is the second, offering an extra possibility is not good for proof search.
Theorem 4.4 Let V = {a1, ..., an} be a set of propositional variables, R be a set

of transition rules on V, F be a CTL formula and s |=Y
F denote that F holds

at state s in the transition system deﬁned by R. Then, s |=Y
F iff the sequent

▶ [[s]], C[[F ]]Y is provable in μMALL.
Proof. [Proof sketch] In the case of the least fixed point, the result comes easily since unfolding will always substitute s by a reachable state sj (see derivation in Example 4.2). For the greatest fixed point, we show that we can always provide the needed invariant. For example, assume that the states in S = {s1, ..., sn} satisfy the formula AGF . We can show that I = [[s1]]⊥ ⊕ ··· ⊕ [[sn]]⊥ is the greatest invariant for proving the sequent ▶ [[s]], C[[AGF ]]Y. See [11] for the detailed proof.	2
Our encodings assume that each rule “uses” all the variables (either present or absent). This greatly simplifies the encodings and the adequacy proofs. In [10], this restriction is not imposed, giving rise to more compact rules. Note that our restrictions on the use of variables are without loss of generality: if a rule does not use all the variables, we can preprocess the input and generate accordingly a set of rules satisfying our requirements.
It it worth noticing that, in Definition 4.1, we do not encode the transition rules as a theory (as we did in Section 4.1). The reason in the following. On one hand, the presence of a formula [R ] in the context, encoding the rules, may allow us to move from the current state to a successor one. On the other hand, fixed points operators must be applied in order to go through paths, checking properties on them. These two actions should be coordinated, otherwise one would lose adequacy in the encod- ings. More precisely, by focusing on [R]], we may “jump” a state without checking

the needed property in that state. Therefore, the use of fixed points excludes the use of theories for encoding the transition system and we must internalize the tran- sition rules in the definition of the path quantifiers (see Definition 4.1). This seems to be the accurate way of controlling the use of rules in CTL.
Finally, note that the encoding of the CTL operators does not use the exponen- tials. That is, only the multiplicative/additive part of the logic is enough.


Concluding Remarks and Future Work
We compared the expressiveness, as logical frameworks, of two extensions of linear logic (LL). We show that it is possible to encode the logical rules of HyLL into
LL. In order to better analyze the meaning of worlds in HyLL, we show that a flat subexponential structure suffices to encode HyLL into SELLA. We also show that information confinement cannot be specified in HyLL. Finally, with better insights about the meaning of HyLL’s words, we pushed forward previous attempts of using HyLL to encode Computational Tree Logic (CTL). We showed that only by using meta-level induction (or fixed points inside the logic) it is possible to faithfully encode CTL path quantifiers. There are some other logical frameworks that are extensions of LL, for example, HLF [21]. Being a logic in the LF family, HLF is based on natural deduction, hence having a complex notion of (βη) normal forms as well as lacking a focused system. Thus adequacy (of encodings of systems in HLF) results are often much harder to prove in HLF than in HyLL or in SELL.
While logical frameworks should be general enough for specifying and verifying properties of a large number of systems, some logical frameworks may be more suitable for dealing with specific applications than others. Hence, it makes little sense to search for “the universal logical framework”. However, it is often salutary to establish connections between frameworks, specially when they are meant to reason about the same set of systems.
In this context, both HyLL and SELL have been used for formalizing and an- alyzing biological systems [10, 18]. This work indicates that SELL is a broader framework for handling such systems, since it can encode HyLL’s rules naturally and directly. However, the simplicity of HyLL may be of interest for specific pur- poses, such as building tools for diagnosis in biomedicine. And we can use the encoding of HyLL into LL in order to perform automatic proofs of properties of systems encoded in HyLL, for example.
Formal proofs in HyLL were implemented in [10], in the Coq proof assistant. It would be interesting to extend the implementations of HyLL given there to SELL. Such an interactive proof environment would enable both formal studies of encoded systems in SELL and formal meta-theoretical study of SELL itself.
We may pursue the goal of using HyLL/SELL for further applications. That might include neuroscience, a young and promising science where many hypotheses are provided and need to be verified.

References
Jaime Arias, Myriam Desainte-Catherine, Carlos Olarte, and Camilo Rueda. Foundations for reliable and flexible interactive multimedia scores. In Tom Collins, David Meredith, and Anja Volk, editors, MCM 2015, volume 9110 of LNCS, pages 29–41. Springer, 2015.
Jean-Marc Andreoli. Logic programming with focusing proofs in linear logic. J. Log. Comput., 2(3):297– 347, 1992.
David Baelde. Least and greatest fixed points in linear logic. ACM Trans. Comput. Log., 13(1):2, 2012.
Jerry R. Burch, Edmund M. Clarke, Kenneth L. McMillan, David L. Dill, and L. J. Hwang. Symbolic model checking: 10ˆ20 states and beyond. Inf. Comput., 98(2):142–170, 1992.
Kaustuv Chaudhuri. Classical and intuitionistic subexponential logics are equally expressive. In Anuj Dawar and Helmut Veith, editors, CSL 2010, volume 6247 of LNCS, pages 185–199. Springer, 2010.
Iliano Cervesato and Frank Pfenning. A Linear Logical Framework. Information & Computation, 179(1):19–75, November 2002.
Kaustuv Chaudhuri and Giselle Reis. An adequate compositional encoding of bigraph structure in linear logic with subexponentials. In Martin Davis, Ansgar Fehnker, Annabelle McIver, and Andrei Voronkov, editors, LPAR-20 2015, volume 9450 of LNCS, pages 146–161. Springer, 2015.
Jo¨elle Despeyroux and Kaustuv Chaudhuri. A hybrid linear logic for constrained transition systems. In Post-Proceedings of the 9th Intl. Conference on Types for Proofs and Programs (TYPES 2013), volume 26 of Leibniz Intl. Proceedings in Informatics, pages 150–168. Schloss Dagstuhl–Leibniz- Zentrum fuer Informatik, 2014.
Vincent Danos, Jean-Baptiste Joinet, and Harold Schellinx. The structure of exponentials: Uncovering the dynamics of linear logic proofs. In Georg Gottlob, Alexander Leitsch, and Daniele Mundici, editors, Kurt G¨odel Colloquium, volume 713 of LNCS, pages 159–171. Springer, 1993.
Elisabetta de Maria, Jo¨elle Despeyroux, and Amy Felty. A logical framework for systems biology. In Proceedings of the 1st Intl. Conference on Formal Methods in Macro-Biology (FMMB), volume 8738 of LNCS, pages 136–155. Springer, 2014.
Jo¨elle Despeyroux, Carlos Olarte, and Elaine Pimentel. Hybrid and Subexponential Linear Logics Technical Report (https://hal.inria.fr/hal-01358057). Research report, INRIA Sophia Antipolis - I3S ; Universidade Federal do Rio Grande do Norte (Natal), August 2016.
Gerhard Gentzen. Investigations into logical deductions, 1935. In M. E. Szabo, editor, The Collected Papers of Gerhard Gentzen, pages 68–131. North-Holland Publishing Co., Amsterdam, 1969.
Jean-Yves Girard. Linear logic. Theoretical Computer Science, 50:1–102, 1987.
Dale Miller and Elaine Pimentel. A formal framework for specifying sequent calculus proof systems.
Theor. Comput. Sci., 474:98–116, 2013.
Vivek Nigam and Dale Miller. Algorithmic specifications in linear logic with subexponentials. In Ant´onio Porto and Francisco Javier L´opez-Fraguas, editors, PPDP, pages 129–140. ACM, 2009.
Vivek Nigam, Carlos Olarte, and Elaine Pimentel. A general proof system for modalities in concurrent constraint programing. In CONCUR, volume 8052 of LNCS, pages 410–424. Springer Verlag, 2013.
Vivek Nigam, Elaine Pimentel, and Giselle Reis. Specifying proof systems in linear logic with subexponentials. Electr. Notes Theor. Comput. Sci., 269:109–123, 2011.
Carlos Olarte, Davide Chiarugi, Moreno Falaschi, and Diana Hermith. A proof theoretic view of spatial and temporal dependencies in biochemical systems. Theoretical Computer Science, 641:25–42, 2016.
Carlos Olarte, Elaine Pimentel, and Vivek Nigam. Subexponential concurrent constraint programming.
Theoretical Computer Science, 606:98–120, 2015.
Elaine Pimentel, Carlos Olarte, and Vivek Nigam. A proof theoretic study of soft concurrent constraint programming. Theory and Practice of Logic Programming, 14:475–308, 2014.
Jason Reed. Hybridizing a logical framework. In International Workshop on Hybrid Logic (HyLo), Electronic Notes in Theoretical Computer Science, pages 135–148, Seattle, USA, August 2006. Elsevier.
