Electronic Notes in Theoretical Computer Science 125 (2005) 109–124 
www.elsevier.com/locate/entcs


Satisfiability of Dolev-Yao Constraints
Laurent Mazar´e1
Laboratoire VERIMAG Grenoble, France

Abstract
The secrecy problem, under certain hypothesis, is equivalent to satisfiability of constraints involving Dolev-Yao’s operator ▶. Making some restrictions over these constraints, their satisfiability has been proven to be NP-complete. However, to check opacity [11] or some modified versions of secrecy, there is a need to find similar results for a larger class of predicates. This paper starts to extend this decidability result to more general constraints allowing in particular inequalities and gives a simple decision procedure based on a rewriting system.
Keywords: Security, Formal Verification, Dolev-Yao Constraints, Rewriting Systems, Opacity.


Introduction
During the last decade, verification of security protocols has been widely in- vestigated. The majority of the studies focussed on demonstrating secrecy properties using formal methods (see for example [4], [6], [5] or [9]). These methods have lead to effective algorithms and so to concrete tools for verifying secrecy like those proposed by the EVA project [3] or the Avispa project [2]. The main result is that considering an active intruder and a bounded num- ber of sessions in Dolev-Yao model (see [8]), secrecy is decidable and is an NP-complete problem. One possible way to demonstrate this result is to use constraints based on Dolev-Yao’s operator ▶. This has been done for example in [12] or in [14]. A Dolev-Yao constraint will be a conjunction of atomic constraints of the form E H m, where E is an environment (i.e. a finite set of messages), m is a message and both of them are potentially not closed.

1 Email: laurent.mazare@imag.fr


1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.05.022


Thus, in this case, the secrecy problem is equivalent to satisfiability of a given constraint.
In this paper, after giving a formal definition of Dolev-Yao constraints, we will investigate their satisfiability. In a first part, we will restrict ourselves to ”well-formed” constraints. These constraints will form an extension of the well-known set of constraints which satisfiability is exactly equivalent to se- crecy in Dolev-Yao’s model with a bounded number of sessions. This extension will add the possibility to use the /= operator. Thus, protocols which check that a received variable is not a given one (for example, a protocol verifying that a nonce has not already been used before) could be verified by checking satisfiability of this kind of constraint. Using a method based on term rewrit- ing, satisfiability of such constraints will be proved to be decidable and we will provide a concrete decision algorithm. Moreover, one of the hypothesis over well-formed constraints could be removed. This will define quasi well-formed constraints which satisfiability will be proved decidable too. In addition to protocols checking inequalities, there are two main motivations when extend- ing classical Dolev-Yao constraints. The first one, leading to the definition of well-formed, is to study opacity [11] instead of secrecy in the case of active intruders. Opacity in this case will be equivalent to satisfiability of a well- formed constraint. The criterion defining ”quasi well-formed” constraints is useful when studying opacity too, so that we could model the unfolding of two parallel sessions. An other use of these constraints could be to model attacks performed by two distinct intruders that are not allowed to communicate. Ap- plication of these constraints to opacity will not be entirely detailed here and will be the object of a future paper.
The remainder of this paper is organized as follows. In section 2, we will briefly recall the usual definitions leading to Dolev-Yao constraints and proper definitions for well-formed and quasi well-formed will be given. Then, in sec- tion 3, we will use a rewrite system to prove that satisfiability of well-formed constraints is decidable. Section 4 will extend this result to the case of quasi well-formed constraint. In section 5, we will quickly explain why satisfiability of our constraints is NP-complete. Section 6 will show how these results could be applied to check opacity with an active intruder. And eventually, section 7 will conclude this paper.

Dolev-Yao Constraints
Let A, X and F be three infinite countable disjoint sets. A is the set of atomic messages usually written a, b and so on. X is the set of message variables (written x, y,...) and F is the set of functions (written f , g,...).


Definition 2.1 Let Σ be the signature A∪{pair, encrypt}∪F where pair and encrypt are two binary functions. The atomic messages are supposed constant functions and each function f has a fixed arity ar(f ). Then a message is a first order term over Σ and the set of variables X, namely an element of T (Σ,X). A message is said to be closed iff it is a closed term of T (Σ,X), i.e. a term of T (Σ).

In the rest of this paper, we will use the well-known notations ⟨m1, m2⟩ = pair(m1, m2) and {m1}m2 = encrypt(m1, m2). The height of a message m could be easily defined recursively and will be noted |m|. The set of variables used in a message m is noted var(m), this is not the usual definition of var as we will consider that f (...) is ”atomic”:
var(a)	= ∅
var(x)	= {x}
var(f (...)) = ∅
var(⟨m, n⟩)= var(m) ∪ var(n) var({m}n) = var(m) ∪ var(n)
The substitutions σ from X to T (Σ,X) are defined as usual. Application of σ to message m will be noted mσ (instead of σ(m)). If σ is defined by xσ = n and yσ = y for any other variables y, then we could write m[x\n] instead of mσ. The domain of a substitution σ is the set dom(σ) of variables such that xσ /= x.
Using the pair operator, it is possible to introduce n-tuples. Then, we will use the tn notation to denote tuples composed using n times the same message
t. Formally, tn is recursively defined by t1 = t and tn+1 = ⟨t, tn⟩
We will use Dolev-Yao intruder’s model [8]. The intruder controls the net- work: he could intercept any message, forge messages using its initial knowl- edge and previously intercepted messages, and send these messages to other agents usurping an agent’s identity. To forge new messages, the intruder uses Dolev-Yao theory ▶. If E is a finite set of messages (usually called an envi- ronment) and m is a message, E ▶ m means that m could be deduced from E using the classical inferences. In this paper, we only consider symmetric cryptography. However, all of our results would still hold when considering public key cryptography but we will keep this hypothesis for simplicity’s sake. Dolev-Yao constraints are predicates built using classical logic operators and a new tertiary operator noted H. This operator is used in atomic predi- cates like T H m[U ] where T (environment), m (message) and U (environment) could be non closed. This predicates’ intuition is that there exists a proof of

T ▶ m[U ] which is defined as the classical ▶ except for the decode rule.
T ▶ {m}u[U ]	u ∈ U T ▶ m[U ]
The only keys allowed to decode a message are the keys in U and these keys are not to be proven deducible.
Definition 2.2 [Constraints] Dolev-Yao constraints are defined according to the following grammar:
C ::= ⊥|T|C V C|C Λ C|CA
CA ::= T H m[U ]|m /= n
Where T and U are finite sets of messages, m and n are messages.
For a constraint C, the sets T appearing as left part of an atomic constraint T H m[U ] in C are called environments of C. The classical notion of model is used for operators like V or /=. We will extend it by saying that σ is a model of T H m[U ] written σ |= T H m[U ] iff T σ, mσ and Uσ are closed and there exists a proof of Tσ ▶ mσ[Uσ].
Definition 2.3 [Model] A substitution σ is a model for constraint C iff Cσ is closed and σ |= C where σ |= . is the smallest predicate verifying the classical inferences for T, Λ and V, and the two following inferences:
mσ /= nσ σ |= m /= n
Tσ ▶T mσ[Uσ] σ |= T H m[U ]
Using standard boolean rules, any constraint could be transformed to C = i Coi where Coi =	CA. The Coi constraints are called the conjunctions composing C. We will usually suppose that our constraints follow this form
as it is needed to check that they are well-formed or quasi well-formed.
Definition 2.4 [Well-Formed Constraint] A constraint C is said to be well formed iff none of the environment is empty and for any conjunction Co composing C, the two following conditions hold:
If T H m[U ] and T ' H m'[U '] are in Co, then T ⊆ T ' or T ' ⊆ T (Environment Inclusion).
If T H m[U ] ∈ Co and x ∈ var(T ), then there exists T ' H m'[U '] ∈ Co such that x ∈ var(m'), U ' ⊆ U and T ' Ç T (Variable Introduction).


A constraint that only satisfies the Variable Introduction requirement and such that there exists a same closed message m in all its environment will be said quasi well-formed.
It is easy to remark that for conjunctions in a well-formed constraint, there exists a constraint Tx H mx[Ux] in Co such that Tx is minimal and x ∈ var(mx). This notation Tx will be used in the following. An immediate property about Tx is that x ∈/ var(Tx). Moreover, we could notice that any well-formed constraint is quasi well-formed.
As we have now proper definitions for Dolev-Yao constraints, we will give a very classical example of constraint. To achieve this, it is practical to be able to formalize the classical Dolev-Yao constraint: message m is deducible from the set of message T written T H m. This constraint could be described using constraint with [] by quantifying on the order upon which keys are compromised. m will be deducible iff there exist k1,...,kn distinct keys in T or m such that k1 is deducible without any decoding, k2 deducible using k1 only and so on. At the end, m needs to be deducible from T using only keys k1 to kn.
Proposition 2.5 Let m be a message and T a ﬁnite set of messages. Then, for any substitution σ, the following equivalence holds.

Tσ ▶ mσ ⇔ σ |=	 
k1 ,...,kn∈keys(T,m)
(T H k1[] Λ T H k2[k1] Λ ... Λ T H m[k1, ..., kn])

This property could be extended to predicates with several H operators. If environments of the predicate are ordered, it is possible to assume that keys compromised for an environment T are compromised for T ' verifying T ⊆ T '. Let us call the environments T1 ⊆ T2 ⊆ ...Tn. Thus, we quantify on the previous order that gives us k1,...,kα and for each environment Tj on the value of ij such that in Tj, keys k1 to kij are compromised (and so, we only have to consider i1 ≤ i2 ≤ ... ≤ in).
Proposition 2.6 For i between 1 and n, let mi be a message and Ti a ﬁnite set of messages. If 1≤i≤n Tiσ H mi is well-formed and T1 ⊆ T2 ⊆ ...Tn, then for any substitution σ, the following equivalence holds.

 

1≤i≤n
Tiσ ▶ miσ ⇔ σ |=	 
k1 ,...,kα∈keys(T,m) 1≤i1 ≤i2 ≤...≤in≤n
(T1 H k1[] Λ ... Λ T1 H m1[k1, ..., ki1 ])

Λ(T2 H ki1 +1[k1, ..., ki1 ] Λ ... Λ T2 H m2[k1, ..., ki2 ])
Λ...
Λ(Tn H kin−1 +1[k1, ..., kin−1 ] Λ ... Λ Tn H mn[k1, ..., kin ])


This property gives the following result: secrecy is equivalent to satisfia- bility of a well-formed Dolev-Yao constraint.

An Example: Needham-Schroeder Constraint
Secrecy with a bounded number of sessions in Dolev-Yao model could be linked to satisfiability of a well-formed constraint. This is explained in [7] for example. The usual example of attack that could be discovered using formal methods is an attack on Needham-Schroeder protocol [13] found by Lowe in 1995 [10]. The constraint NS which satisfiability is equivalent to the existence of this attack is given below. As it describes an attack in Dolev- Yao model, the environments describe the knowledge of the intruder and thus verifies Environment Inclusion and Variable Introduction. That is why, this constraint is well-formed and its satisfiability could be verified. The two ses- sions considered here occur between A and the intruder C and between C usurping A’s identity and B. To keep it as simple as possible, this example uses public key cryptography. Let E be the initial knowledge of the intruder C, E = {A, B, C, KA, KB, KC, K−1}.

NS =	E, {NC, A}KC
Λ E, {NC, A}K
H {x, A}K
, {x, NB}K  H {NC, y}K

C
Λ E, {NC, A}KC
A
, {x, NB}KA, {y}KC
A
H NB


Decidability for Well-Formed Constraints
In this section, we will provide an original decision procedure for satisfiability of well-formed constraints. For such constraints using only H, it is well known that the satisfiability problem is NP-complete: see for example [14], [12] or an extension to XOR in [7]. Our decision procedure will work using a rewriting system over constraints. We will have to prove that our system terminates, that satisfiability for our normal forms is decidable and eventually that our system is correct and complete, i.e. models of a constraint are exactly the models of this constraint once rewritten. Knowing that, we are able to provide a decision procedure for satisfiability which is to rewrite the constraint up to its normal form and then to check satisfiability on this normal form. Compared to other proofs of decidability of satisfiability for this kind of constraints (that are easy to find in the literature, see [12] as a starting point), our main objective is to provide a very simple, yet extensible, decision procedure.
Definition of the rewriting system needs some explanation. Our rewriting system is triggered by a condition. As we will check for termination without considering that condition, this will not cause any problem. The first step in


our decision procedure is to test all possible unifications among sub-terms of the different environments and messages. This is done using a large quantifi- cation (V operator). After that step, two different non-closed messages (that are sub-messages of the original constraint) are supposed to be instantiated with different closed messages (i.e. they cannot be unified). Using that, an atom a is deducible from T (using U ) iff a appears in T (protected only by keys occurring in U ). The same kind of idea is used for {} whereas the case of ⟨⟩ is trivial.
Definition 3.1 The rewriting system → is defined over well-formed con- straints by the three following rules that will only apply if for all x ∈ var(T ), Tx H x[Ux] occurs in the same conjunction with Ux ⊆ U .
T H a[U ] →T 
T H a[U ] →⊥ 
T H f (m1, ..., mn)[U ] →T 
T H f (m1, ..., mn)[U ] →⊥ 
T H ⟨m, n⟩[U ] → T H m[U ] Λ T H n[U ]
T H {m}n[U ] →T 
T H {m}n[U ] → T H m[U ] Λ T H n[U ]
Rule 1 is applied iff a occurs in T protected only by keys that appear in U , else rule 2 is applied.
Rule 3 is applied iff f (m1, ..., mn) occurs in T protected only by keys that appear in U , else rule 4 is applied. Thus, rule 1 and 2 are useless if we consider atoms as constant functions.
Rule 5 is the intuitive rule for pairs.
Rule 6 is applied iff {m}n occurs in T protected only by keys that appear in U (this is the case where {m}n could be obtained using decompositions), else rule 7 is applied (in the other case, {m}n is obtained with a composition operation).
The condition expressed over T aims to force the execution order to follow
⊆. Therefore if T1 ⊆ T2, then the pattern T1 H m1 will be entirely rewritten before processing T2 H m2.
Last remark, these rules are easy to extend to the case of public key cryp- tography. In this case, in the condition of application of the different rules, ”protected only by keys that appear in U ” is to be replaced by protected only by keys which inverses appear in U .
The first thing to check is that after applying → to a well-formed con- straint, the result remains well-formed. This is expressed by the following

property.
Proposition 3.2 If C and C' are constraints such that C → C' and C is well-formed, then C' is well-formed.
The second thing is to prove that our rewriting system terminates. Then, it will be possible to transform any constraint to a constraint in normal form that has exactly the same models. This is easy to show as when rewriting, right members of each constraint are discomposed or the constraint is rewritten to
⊥ or T. Thus, by taking a simple measure over constraint s(C) defined by:
s(T1 H m1[U1] Λ ... Λ Tn H mn[Un]) = Σ s(mi)
i=1
This gives us s(⊥)= s(T)= 0. And s is recursively defined over messages by:
s(a)= 1
s(f (...)) = 1
s(⟨m1, m2⟩)= s(m1)+ s(m2)+1 
s({m1}m2 )= s(m1)+ s(m2)+1 
Using an order based on this measure, the following property is immediate.
Proposition 3.3 The rewriting system → terminates.
After transforming a constraint to its normal form, we want to check that both have the same sets of models. Formally, if C → C' then for any substi- tution σ, σ is a model of C iff σ is a model of C'. This will prove that if the normal form is satisfiable then, the original constraint is satisfiable too and that the reciprocal is true.
Proposition 3.4 The rewriting system → is correct and complete for well- formed constraints.
Note that, to prove this result, the Variable Introduction hypothesis is used. Else, rules would not be correct and complete anymore. For example, if we consider the following constraint:
a, {b}a H x[a] Λ a, {b}a,x H b[]
This constraint would be rewritten to ⊥ as b does not appear in a, {b}a,x unprotected. But, by using x = b, we know that this constraint is satisfiable. That is why, most of the rules are only correct and complete if the Variable Introduction hypothesis is respected.
Eventually, the last step is to show that satisfiability for our normal forms is easily decidable. First, normal forms of well-formed constraints are well-

formed constraints. They have the form:
   (T H x[U ]) Λ (  m /= n) 

At this point, every normal form that is well-formed is satisfiable if the lowest environment T0 is non empty (this is always true by definition of well-formed) and if the conjunction of inequalities is satisfiable. To prove that, let t be a message in T0 (t always exists as T0 is not empty). As the environment T0 is closed (this could be seen by applying the Variable Introduction hypothesis to T0), t is closed. Then, for every variable in an atomic constraint, we will use a message of the form tn. It is clear that the conjunction of predicates using H is satisfied. And by changing values of the different n, if the /= part is satisfiable, we will satisfy it by giving to n a value lower than the number of inequalities plus the number of variables. The intuition is that, given a number n, if a conjunction m1 /= n2 is not satisfied, then it satisfied for any other number n' /= n.
We will use the σk notation which signification xσk is the tuple composed by k times xσ.
xσk = (xσ)k = ⟨xσ, ..., xσ⟩

Proposition 3.5 (Solving Inequalities) Let P be the constraint m1 /= n1 Λ
... Λ mj /= nj where mi and ni are messages. If P is satisﬁable, then for any substitution σ such that Pσ is closed and taking distinct values for any variables in var(P ), there exists an integer k such that k ≤ j +1 and σk is a model of P.
Proof. The proof use the following lemma: let m and n be two messages, σ be a substitution such that mσ and nσ are closed, and that xσ = yσ ⇒ x = y. If there exists two different integers i and j such that mσi = nσi and mσj = nσj, then we have m = n.	 
This kind of property is very general and could be applied to other operators instead of =. For example, the same thing holds for the ~ operator introduced in [11] and this will allow to prove decidability of satisfiability for a similar extension of the predicates defined in this paper. This decidability (and NP- completeness) will prove that the opacity problem when considering an active intruder (Dolev-Yao’s model) and a finite number of session is NP-complete. Eventually, satisfiability is equivalent to satisfiability of the /= part. This last satisfiability is easy to check using for example negation of this conjunction. This gives a constraint using only equalities. Then, by applying classical unification, it is possible to check that this final constraint is always satisfied


(hence is rewritten to T using unification) or not (and thus that its opposite is satisfiable or not).
Finally, the main result of this paper is a consequence of all the former properties.
Theorem 3.6 (Main Theorem) Satisﬁability of well-formed constraints is decidable.
This result is not really new, it could already be found in [1] for instance. However, the demonstration used here seems to be easier to adapt to other cases. In particular, having first order symbols like f , this theorem will apply quite directly to show decidability of opacity in a next section.

An Example: Needham-Schroeder Constraint
The former rewriting system has been implemented in a prototype using ocaml. However, it has been adapted so that it does not have to test all the possible unifications. This makes the method easier to understand but is very negative for performance. This is the reason why our algorithm does only make unification when it need them. For example, the rules 3 and 4 would be replaced by a rule trying all the possible unification of f (..) and the reachable patterns starting with f in the environment. The advantage of this method is that by looking at the unification requested by the rewriting system, we obtain values for the different parameters and this algorithm does not have to look to all possible unifications but only to ”plausible ones”. In the formal proof and other works, the general first idea is to guess all possible equalities between sub-messages and to get rid of them using the most great unifier (see [7] on how to adapt this to exclusive or). It has been tested on the Needham-Schroeder constraint. Its result is of course that this constraint is satisfiable and the only possible variables’ values are: x = NC and y = NB. During this check, five possible unifications have been tested. Three of them involved two messages that could not be unified and so only two cases were explored. One quickly lead to satisfiability whereas the other one was not satisfiable. Adding to the initial constraint the inequality y /= NB, we imme- diately have that the constraint is not satisfiable anymore. This gives us a possible fix for this protocol: if agent A was able to determine the origin of nonce NB (by replacing it by a pair nonce, identity of the nonce’s creator), then it would not be possible to perform this attack anymore. This is the idea behind Lowe fixed version of this protocol appearing in [10]. This fix adds the agent’s identity to the second message, hence allows to check if the identity of the nonce’s creator is valid.

Quasi Well-Formed Constraints

The previous theorem could be extended to quasi well-formed constraints. There are at least two possible ways to demonstrate this.
The first solution is to notice that the only place where we use the first hypothesis is to prove that satisfiability for normal forms is decidable. This is the reason why we added the last hypothesis for quasi well-formed con- straints, thus there exists a closed message common to all the environments. The modifications to perform are to demonstrate the modified property:
Proposition 4.1 If C and C' are constraints such that C → C' and C is quasi well-formed, then C' is quasi well-formed.
Termination is proved for any kind of constraints so this will not be a problem. Correctness and completeness could be adapted too.
Proposition 4.2 The rewriting system → is correct and complete for quasi well-formed constraints.
Eventually, when considering the normal form, the proof does not change: using tuples of message m, it is possible to verify satisfiability as message m is deducible from any of the involved environments.
The other way is to remark that a quasi well-formed conjunction is equiva- lent to a conjunction of well-formed conjunctions. In the initial conjunction, the atomic constraint T H m[U ] could be replaced by T H m[U ] Λ T ' H m'[U '] where the conjunctions introducing the different variables in T are added and those introducing variables in the different m' (to formalize that, we would need a fix point). As the number of conjunctions in the initial constraint is finite, the results are well-formed and finite conjunctions. The rest of this demonstration will be shorter as it will use the results of the former section. This is why, these conjunctions could be rewritten. And so, we obtain an equivalent normal form which is a quasi well-formed con- straint. As we have seen before, satisfiability of this constraint is rather easy to check. There remains the inequalities part to check but this could still be done using the method described above.
Both of these proof skeletons allow us to prove the following theorem.

Theorem 4.3 Satisﬁability of quasi well-formed constraints is decidable.

More than satisfiability, we provide a decision procedure that has been implemented and seems to perform quite well.

An Example: Needham-Schroeder Constraint
As said earlier, our main motivation for this extension is its application to opacity. However, there are other possible uses for it. The Environment Inclusion hypothesis held because the environments represented the intruder’s knowledge. As the intruder could only learn new messages, this set could only grow and the hypothesis is not restrictive. However, by suppressing this hypothesis, it is now possible to model distinct knowledge with the different environments. Concretely, this extension easily allows to model two intruders that are not able to communicate between each other. For example, let us consider a modified version of Dolev-Yao attack. There are two intruders C1 and C2 such that there is a session between A and C1 and another one between C2 (usurping A’s identity) and B. We want to know if it is possible for one of the intruder to deduce one of the secret NA or NB. Let T0 be the
initial knowledge of our intruders {A, B, C1, C2, KC , KC , K−1, K−1}. Then,

the constraint becomes:
T0 H {A, x}KB
1	2	C1	C2

Λ	T0, {A, NA}KB
H {x', y'}K

Λ ( T0, {x, NB}KA H NB
V T0, {A, NA}K , {y'}K	H NA)
This constraint appears to be quasi well-formed but is not well-formed. By using our decision procedure, we know that this constraint is not satisfiable. Thus, the two intruders need to communicate so that the classical attack over Dolev-Yao’s protocol could be performed.

NP-Completeness
We will now discuss the complexity of our approach. First, satisfiability of well-formed constraints is NP-hard (see for example [15] or [14]). This is the case for well-formed constraints that only involve H. And as all of these constraints are in the set of constraints that we are studying, our satisfiability’s problem is NP-hard. To show that this satisfiability problem is in NP and thus NP-complete, we will rely on the results presented in [14]. The authors of this paper proved that given a satisfiable well-formed constraint without inequalities, there exists a model which size is polynomial in the size of the constraint. The size used here is the number of different sub-terms. The same result holds for our method. Its result is a substitution σ such that the size of xσ is polynomial in the size of the constraint. When solving the inequalities part, the size remains polynomial: let |m|DAG be the number of distinct sub- terms in m. Then it is easy to prove that |mn|DAG = |m|DAG + n − 1. So in


the worst case, we only added the number of inequalities and variables to the size of our model. Thus the DAG size of our model remains polynomial in the size of the initial problem. That is why, we could conclude that satisfiability of well-formed constraints is NP-complete.
For quasi well-formed constraints, the exact same decision algorithm could be used. This proves that satisfiability for these constraints is also NP- complete.

Application to Opacity
In this section, we will give a quick look at how the former method could be used to prove that opacity is decidable when considering Dolev-Yao model. In other papers, we only studied the case of a passive intruder. Here, we will start to extend decidability results to the case of active intruders.
First, let us give an extended definition of ▶ to the case of two envi- ronments and two messages E, E ▶ n, n'. This means that n and n' are deducible from E and E' by making the same operations on both environ- ments. For example, {a, b}, {c, d} ▶ ⟨a, b⟩, ⟨c, d⟩ is true as both messages are obtained by pairing the first and second messages in the environments whereas
{a, b}, {c, d} ▶ ⟨a, a⟩, ⟨c, d⟩ is false as the messages could not be obtained by the same operations. E, E ▶ n, n' is defined on closed messages n, n' and closed environments E and E' by:
E, E' ▶ n1, n'	E, E' ▶ n2, n'
	1	2
{n1, ..., nk}, {n' , ..., n' }▶ ni, n'	E, E' ▶ ⟨n1, n2⟩, ⟨n' , n' ⟩
1	k	i	1	2

E, E' ▶ ⟨n1, n2⟩, ⟨n' , n' ⟩
E, E' ▶ n1, n'
E, E' ▶ ⟨n1, n2⟩, ⟨n' , n' ⟩
E, E' ▶ n2, n'

E, E' ▶ {n1}n , {n' }n'	E, E' ▶ n2, n'
E, E' ▶ n , n'	E, E' ▶ n , n'

	2	1	2	2 	1	1	2	2
E, E' ▶ n1, n'	E, E' ▶ {n1}n , {n' }n'
1	2	1	2
Note that E and E' must have the same length (in fact, as these sets will be supposed similar, this will not be a problem). Moreover, as we want to perform the same operations on both environments, we need the environments to be ordered. They could be represented using lists.
The definition of opacity (given for example in [11]) is that an intruder is not able to distinguish a run where the property is satisfied from a run where it is not. To distinguish two messages, the intruder could decompose them, according to his knowledge but if he does not know the key k for example, he will not be able to make the difference between two different messages encoded by this key k. However, in this section, we will only consider a very simplified version of opacity. Let us consider a finite protocol P with a unique parameter


v (called the vote) that could only take two values yes (protocol Py) or no (protocol Pn). We will say that the value of v is not opaque (in fact, the property v = yes is not opaque) iff the intruder is able to produce yes and no by doing the same operations on both protocols. The intruder has to perform the exact same sequence of actions: for example if in the first protocol, he sends a constant A then receives a message that is a pair and eventually sends the left part of the pair, he will have to do the same actions for the second protocol. This will be equivalent to satisfiability of the following constraint:
T0, T0 H m0, m' Λ T0; n0, T0; n' H m1, m' Λ ... Λ Tn,T ' H yes, no
0	0	1	n

Where Ti = T0; m0; ...; mi−1. The messages mi and m'
are produced by the

intruder and sent to protocols Py and Pn. Then, the protocols replies are
messages ni and n'. Both sessions are carried in the same manner and we ask that at the end, the intruder is able to tell on which session v was equal to yes and on which session v was equal to no.
To link our new constraint to Dolev-Yao constraints, let us introduce an explicit binary function f for our extended ▶ operator. The constraint could be written
f (T0, T0) H f (m0, m' )Λf (T0; n0, T0; n' ) H f (m1, m' )Λ...Λf (Tn,T ' ) H f (yes, no)
0	0	1	n
Next, we will distribute the f function inside our constraint by using the following distrib operator recursively defined by:
distribf (f (⟨m, n⟩, ⟨m', n'⟩)) = ⟨distribf (f (m, m')), distribf (f (n, n'))⟩
distribf (f ({m}n, {m'}n' )) = {distribf (f (m, m'))}distribf (f (n,n'))
Else we have distribf (m)= m.
Applying the distribf function creates a constraint equivalent to the origi- nal one but which is a Dolev-Yao constraint. This is formalized in the following property which could be proved using induction over the proofs’ structures. If E and E' are two environments, n and n' are two messages such that f does not appear in E, E', n or n', then the following equivalence is true:
E, E' H n, n' ⇔ distribf (f (E, E')) H distribf (f (n, n'))
So, opacity is equivalent to satisfiability of a Dolev-Yao constraint. Moreover, this constraint is, by construction, well-formed. Thus, opacity as defined be- fore is decidable and we have an NP-complete algorithm to check satisfiability. However, we only studied a very restrictive version of opacity but we believe that this result could be extended to the general opacity problem.

Conclusion
In this paper, we gave a simple decision procedure to prove satisfiability of extended versions of usual Dolev-Yao constraints. Using a rewriting system, this algorithm is easy to implement. Moreover, we believe that this method could easily be used for other constraints derived from Dolev-Yao’s one. This has been done through a prototype that performed well on simple examples. An immediate application of these new predicates is to check the secret in presence of two intruders that are not allowed to communicate. Then quasi well-formed constraint will be useful as they allow to describe two ”branches” of environments that do not have to be ordered by set inclusion. Each of these branches will be described by a well-formed constraint. Further works include of course linking more precisely these constraints to the opacity problem in the case of an active intruder. However, there remains an open question: is satisfiability of general Dolev-Yao constraints decidable ? We did not manage to prove that in the general (no hypothesis at all) case.
Acknowledgment
The author wishes to thank Romain Janvier for his reading of a preliminary version of this paper and Hubert Comon for his DEA course ”Cryptographic Protocols’ Proofs”: the decision method used here has been inspired by the content of this course during year 2003.

References
R. M. Amadio and D. Lugiez. On the reachability problem in cryptographic protocols. In
International Conference on Concurrency Theory, volume 1877 of LNCS, pages 380–394, 2000.
The Avispa Project. http://www.avispa-project.org/, 1999.
L. Bozga, Y. Lakhnech, and M. P´erin. Abstract interpretation for secrecy using patterns. Technical report, EVA : http://www-eva.imag.fr/, 2002.
E.M. Clarke, S. Jha, and W. Marrero. Using state space exploration and a natural deduction style message derivation engine to verify security protocols. In IFIP Working Conference on Programming Concepts and Methods, 1998.
H. Comon-Lundh. and V. Cortier. Security properties: Two agents are sufficient. Technical report, LSV, 2002.
H. Comon-Lundh and V. Cortier. New decidability results for fragments of first-order logic and application to cryptographic protocols. In 14th Int. Conf. Rewriting Techniques and Applications (RTA’2003), volume 2706 of LNCS, 2003.
Hubert Comon-Lundh and Vitaly Shmatikov. Intruder deductions, constraint solving and insecurity decision in presence of exclusive or. In Proceedings of the eighteenth annual IEEE symposium on Logic In Computer Science. IEEE Computer Society Press, June 2003.
D. Dolev and A. C. Yao. On the security of public key protocols. IEEE Transactions on Information Theory, 29(2):198–208, 1983.


Jean Goubault-Larrecq.  A method for automatic cryptographic protocol verification. In International Workshop on Formal Methods for Parallel Programming: Theory and Applications, volume 1800 of LNCS, 2000.
G. Lowe.	An attack on the Needham-Schroeder public-key authentification protocol.
Information Processing Letters, 56(3):131–133, 1995.
L. Mazar´e. Using unification for opacity properties. In Proc. of the Workshop on Issues in the Theory of Security (WITS’04). To appear, 2004.
Jonathan K. Millen and Vitaly Shmatikov. Constraint solving for bounded-process cryptographic protocol analysis. In ACM Conference on Computer and Communications Security, pages 166–175, 2001.
R.M. Needham and M.D. Schroeder. Using encryption for authentication in large networks of computers. Communications of the ACM, 21(12):993–999, 1978.
M. Rusinowitch and M. Turuani. Protocol insecurity with finite number of sessions is NP- complete. In IEEE Computer Security Foundations Workshop, 2001.
Micha¨el Rusinowitch and Mathieu Turuani. Protocol insecurity with a finite number of sessions and composed keys is np-complete. Theor. Comput. Sci., 299(1-3):451–475, 2003.
