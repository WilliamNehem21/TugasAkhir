Electronic Notes in Theoretical Computer Science 171 (2007) 73–93	
www.elsevier.com/locate/entcs

Language Primitives and Type Discipline for Structured Communication-Based Programming Revisited:
Two Systems for
Higher-Order Session Communication
Nobuko Yoshida1
Imperial College London
Vasco T. Vasconcelos2
University of Lisbon

Abstract
Session primitives and types provide a flexible programming style for structured interaction, and are used to statically check the safe and consistent composition of protocols in communication-centric distributed software. Unfortunately authors working on session types have recently realised that some of the previously published systems fail to satisfy the basic theorems of Subject Reduction and Type Safety.
This report discusses the issues involved in higher-order session communication, presents a formulation of the recursive types as well as proofs of the Subject Reduction and Type Safety Theorems of the original session typing system by Honda-Vasconcelos-Kubo in ESOP’98. It also proposes a variant which allows a more liberal higher-order session communication, based on an idea of Gay and Hole.
Keywords: Pi-Calculus, Session Types, Protocol Analysis, Subject Reduction Theorem, Type Safety, Rewrit- ing System


Introduction
Session primitives and types provide a flexible programming style for structural interaction, and are used to statically check the safe and consistent composition of protocols in communication-centric distributed software. They have been stud- ied for the π-calculus [2,11,12,13,17,20,23], Ambients [6], CORBA interfaces [21], multi-threaded functional languages [15,23,24], Web Description Languages [3,4,14],

1 Email: yoshida@doc.ic.ac.uk
2 Email: vv@di.fc.ul.pt

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.02.056

and distributed [8] and multi-threaded Java [7] and, at the industry level, WC3- CDL [5,25] and pi4Tech [16].
This paper reports on recent active discussions on the two fundamental theo- rems, Subject Reduction and Type Safety, among the authors working on session types. In the presence of higher-order session communication, session instantiation dynamically changes the structure of sessions, so that it becomes non-trivial to pre- serve typability. Unfortunately the aforementioned authors have recently realised that some of the previous systems fail to satisfy these basic theorems. Interest- ingly, the subtlety of type preservation is related to a treatment of communication channels in the rewriting rules of the π-calculus.
After discussing the issues involved in higher-order session communication, this report also proposes a session typing system which allows a more liberal higher- order session communication, based on the work of Gay and Hole [12] and already used in [23]. The full proofs of the two theorems are firstly given in this report, which also clarifies some definitions absent in [13]. The motivation to why the present authors should redo the proofs nine years after is the discovery of a subtle counterexample to the results in some works on session types published after the work under consideration, although not to results of the original system [13]. We explain the problem in detail in Section 3.
The technical contributions of this report include: the formulation of recursive types, proofs for the Subject Reduction and Type Safety Theorems in the original session typing system by Honda-Vasconcelos-Kubo [13], as well as the presentation of a more liberal system and the corresponding proofs.
The outline of the paper is simple. The next section revisits the ESOP’98 system, presenting proofs for the above mentioned results. Section 3 presents the more liberal system. Section 4 concludes the paper.

The Honda-Vasconcelos-Kubo Session Typing Sys- tem
Honda-Vasconcelos-Kubo’s session typing system in ESOP’98 [13] is an extension of the first session typing system [20] that allows higher-order session communication. We first informally review the syntax, operational semantics and typing system of the ESOP system. We then state and prove the main theorems, Subject Reduction and Type Safety. Detailed examples and explanations of the language and typing system can be found in reference [13].

Syntax and Operational Semantics
A session is a series of reciprocal interactions between two parties, possibly with branching and recursion, and serves as a unit of abstraction for describing interac- tion. Communications belonging to a session are performed via a port, specific to that session, called a channel. A fresh channel is generated when initiating each session, for the use in safe communications.


P ::= request a(k) in P	session request
| accept a(k) in P	session acceptance
| k![e˜]; P	data sending
| k?(x˜) in P	data reception
| k  l; P	label selection
| k D {l1 : P1[] ··· []ln : Pn}	label branching
| throw k[k']; P	channel sending
| catch k(k') in P	channel reception
| if e then P else Q	conditional branch
| P | Q	parallel composition
| inact	inaction
| (νu)P	name/channel hiding
| def D in P	recursion
| X[e˜k˜]	process variables
e ::= c	constant
| e + e' |  e − e' |  e × e |  not(e) | ...	operators
D ::= X1(x˜1k˜1)= P1 and ··· and Xn(x˜nk˜n)= Pn	declaration for recursion

Fig. 1. Syntax
We use the following base sets: names, ranged over by a, b, x, y,z ... ; channels, ranged over by k, k'; constants (including names, integers and booleans), ranged over by c, c',... ; labels, ranged over by l, l',... ; and process variables, ranged over by X, Y,... Letters u, u',... denote names and channels together. Then processes, ranged over by P, Q... , and expressions, ranged over by e, e',... are given by the grammar in Figure 1. The typing system in Figure 6 makes sure that, in process
X[e˜k˜], the channels in k˜ are pairwise distinct.

P ≡ Q if P ≡α Q
P | inact ≡ P	P | Q ≡ Q | P	(P | Q) | R ≡ P | (Q | R) (νu)P | Q ≡ (νu)(P | Q)	if u /∈ fu(Q)
(νu)inact ≡ inact def D in inact ≡ inact
(νu)def D in P ≡ def D in (νu)P	if u /∈ fu(D)
(def D in P ) | Q ≡ def D in (P | Q)	if dpv(D) ∩ fpv(Q)= ∅
def D in (def D' in P ) ≡ def D and D' in P	if dpv(D) ∩ dpv(D')= ∅.

Fig. 2. Structural Congruence
The bindings for names are k?(x˜) in P , X(x˜k˜) = P , and (νa)P ; those for


(accept a(k) in P1) | (request a(k) in P2) → (νk)(P1 | P2)	[Link] (k![e˜]; P1) | (k?(x˜) in P2) → P1 | P2[c˜/x˜]	(e˜ ↓ c˜)	 [Com]
(k  li; P ) | (k D {l1 : P1[] ··· []ln : Pn}) → P | Pi (1 ≤ i ≤ n)		[Label] (throw k[k']; P1) | (catch k(k') in P2) → P1 | P2			[Pass] if e then P1 else P2 → P1	(e ↓ true)	[If1]
if e then P1 else P2 → P2		(e ↓ false)		[If2] def D in (X[e˜k˜] | Q) → def D in (P [c˜/x˜] | Q) (e˜ ↓ c˜, X(x˜k˜)= P ∈ D)	[Def] P → P ' ⇒ (νu)P → (νu)P '	[Scop]
P → P ' ⇒ P | Q → P ' | Q		[Par] P → P ' ⇒ def D in P → def D in P '	[Defin] P ≡ P ' and P ' → Q' and Q' ≡ Q  ⇒ P → Q		 [Str]

Fig. 3. Reduction

channels are request a(k) in P, accept a(k) in P, catch k(k') in P, X(x˜k˜) = P , and (νk)P ; and that for process variables are def D in P . The derived notions of bound and free identifiers, alpha equivalence ≡α, and substitution are standard. For P a process, fpv(P ) denotes the set of free process variables, fn(P ) denotes the set of free names, and fc(P ) the set of free channels. We also define fu(P )= fn(P ) ∪fc(P ). We also need to talk about the set of process variables introduced in declarations
dpv(X1(x˜1k˜1)= P1 and ··· and Xn(x˜nk˜n)= Pn)= {X1,... , Xn}.
Structural congruence is the smallest congruence relation on processes that in- clude the equations in Figure 2. The operational semantics is given by the reduction relation, denoted P → Q, the smallest relation on processes generated by the rules in Figure 3, where e ↓ c says that expression e evaluates to constant c.
Rule [Link] establishes a new session between the server accept a(k) in P1 and the client request a(k) in P2 via shared name a. Rule [Com] transmits values between the client and the server at the private channel so that determinacy of value delivery is ensured among the two parties. Rule [Pass] is the key rule to allow higher-order session communication, i.e. session channel send and receive, with which various protocols are expressed, allowing complex nested structured communications. To show the difference between channels and names, for example,

accept a(k) in P1 | accept a(k) in P2 | request a(k) in Q

is accepted by the type system, while

throw k[k']; P1 | throw k[k']; P2 | catch k(k') in Q

is prohibited since two senders at k appear in context at the same time.


Sort	S ::= nat | bool | ⟨α, α⟩
Type	α ::= ?[S˜]; α | ?[α]; β | &{l1 : α1,... , ln : αn} | end |⊥ |
![S˜]; α | ![α]; β | ⊕{l1 : α1,... , ln : αn} | t | μt.α

Fig. 4. The syntax of types
Relationship with the Rewriting Rules of the π-Calculus
The essence of rule [Pass] is related to a “trick” in a rule of the operational semantics ofa variant of the π-calculus, called the πI-calculus in the literature [19]. This calculus restricts name passing to bound (private) name passing. Syntactically it restricts outputs to processes to the form:
(νy˜)(x⟨y˜⟩| P )	with y˜ pairwise distinct	(1)
where y˜ = y1 ... yn denotes a potentially empty vector, | denotes parallel composi- tion, and x⟨v˜⟩ is an asynchronous output (or a message). We write the process in
(1) as x(y˜).P . The dynamics has the following form by the restriction to the bound output.
x(y˜).P | x(y˜).Q → (νy˜)(P | Q)	(2)
Note that y˜, present both in the input and in the output, indicates that α-conversion is implicitly performed ahead of communication. One can easily observe a similarity between this rule, and rules [Link] and [Pass]: channel k is always freshly generated in rule [Link] and channel k' in rule [Pass] is already created and bound at a previous interaction. Hence no substitution is performed in (2), [Link] or [Pass].

Type Discipline
Structured communication-based programming allows a clear description of com- plex interaction structures beyond conventional communication primitives. The more complex the interaction becomes, the more difficult it is to capture the whole interactive behaviour and to write correct programs. The session type discipline offers a simple static checking framework to guarantee the correctness of commu- nication patterns in such situations. It guarantees that well-typed programs are exempt from incompatibility in interaction patterns.

Types
Given a set of type variables ranged over by t, t',... , the grammar in Figure 4 defines the set S of sorts ranged over by S, S',.. ., and the set T of types ranged over by α, β,... .
The type ?[S˜]; α represents the behaviour of first inputting values of sorts S˜,
then performing the actions prescribed by type α; type ?[α]; β represents a sim- ilar behaviour, which starts with channel input (catch) instead; types ![S˜]; α and
![α]; β are the dual of ?[S˜]; α and ![α]; β, sending values instead of receiving. Type



![S˜]; α =?[S˜]; α	⊕{li : αi}i∈I = &{li : αi}i∈I	![α]; β =?[α]; β
?[S˜]; α =![S˜]; α	&{li : αi}i∈I = ⊕{li : αi}i∈I	?[α]; β =![α]; β
end = end	μt.α = μt.α	t = t

Fig. 5. The co-type of a type




&{l1 : α1,... , ln : αn} describes a branching behaviour: it waits with n options, and behave as type αi if i-th action is selected (external choice); type ⊕{l1 : α1,... , ln : αn} then represents the behaviour which would select one of li and then behaves as αi, according to the selected li (internal choice). Type end represents inaction, acting as the unit of sequential composition; μt.α denotes a recursive behaviour, repre- senting the behaviour that starts by doing α and, when t is encountered, recurs to α again; and finally ⊥ is a specific type indicating that no further interaction is possible at a given name.
For a type α in which ⊥ does not occur, we define α, the co-type (or dual) of α, by exchanging ! and ?, and & and ⊕. The inductive definition is in Figure 5.






Recursive Types
One of the contributions of the present abstract is a precise definition and the fixed point theorem on recursive types which were omitted from the original paper. We follow the standard co-inductive treatment of recursive types [18]. The μ op- erator is a binder, giving rise, in the standard way, to notions of bound and free variables and alpha-equivalence. We do not distinguish between alpha-convertible types. Furthermore, we take an equi-recursive view of types, not distinguishing between a type μt.α and its unfolding α[μt.α/t]. We are interested on contractive types only.
Definition 2.1 (Contractive) A type is contractive if for each of its sub-expressions
μt.μt1 ... μtn.α, the body α is not t.
Henceforth we assume all types to be contractive.
Definition 2.2 (Type equivalence) Two types α and β are said to be equivalent if the pair (α, β) is in the largest ﬁx point of the monotone function F : P(T × T ) →

P(T × T ) deﬁned by:
F (R)= {(end, end), (⊥, ⊥)}
∪ {(?[S˜]; α, ?[S˜]; β) | (α, β) ∈ R}
∪ {(![S˜]; α, ![S˜]; β) | (α, β) ∈ R}
∪ {(?[α]; β, ?[α']; β') | (α, α'), (β, β') ∈ R}
∪ {(![α]; β, ![α']; β') | (α, α'), (β, β') ∈ R}
∪ {(⊕{li : αi}i∈I , ⊕{li : βi}i∈I ) | (αi, βi) ∈ R, ∀i ∈ I}
∪ {(&{li : αi}i∈I , &{li : βi}i∈I ) | (αi, βi) ∈ R, ∀i ∈ I}
∪ {(μt.α, β) | (α[μt.α/t], β) ∈ R}
∪ {(α, μt.β) | (α, β[μt.β/t]) ∈ R}
Theorem 2.3 The largest ﬁx point of function F is an equivalence relation.
Proof. For each of the three cases (reflexivity, symmetry, transitivity) we fol- low [18], Theorems 21.3.6–7. Take symmetry. A relation R is symmetric if it is closed under the monotone function Sym(R)= {(α, β}) | (β, α) ∈ R}. We start by noting that (cf. [18], Theorem 21.3.6):
Sym(F (R)) ⊆ F (Sym(R)) implies that the largest fixed point of F is symmetric.
We then show that Sym(F (R)) ⊆ F (Sym(R)). Let (α, β) ∈ Sym(F (R)). By definition of Sym, there exists (β, α) ∈ F (R). Our goal is to show that (β, α) ∈ F (Sym(R)). Consider all possible shapes of α. We focus on two cases; the remaining are similar.
Case α = end. Since (β, α) ∈ F (R), the definition of F implies that β = end or β = μt.γ with (α, γ[β/t]) ∈ R. In the first case, notice that (end, end) ∈ F (R) for any R, in particular for F (Sym(R)). In the second case, we know that (γ[β/t], α) ∈ Sym(R) (by the definition of Sym), hence that (β, α) ∈ F (Sym(R)) (by the definition of F ).
Case α = &{li : αi}i∈I .  Since (β, α) ∈ F (R), the definition of F implies that β = &{li : βi}i∈I or β = μt.γ with (α, γ[β/t]) ∈ R. In the first case, by the definition of Sym, we have (βi, αi) ∈ Sym(R) for all i ∈ I, hence (&{li : βi}i∈I, &{li : αi}i∈I ) ∈ F (Sym(R)). In the second case proceed as above.
Henceforth types are understood up to type equivalence, so that, for example, in a typing derivation, types μt.α and α[μt.α/t] can be used interchangeably. Due to the presence of record structures in the syntax of types (⊕{l1 : α1,... , ln : αn}, &{l1 : α1,... , ln : αn}), we do not pursue an interpretation of types as regular infinite trees (the interested reader may refer to [22] for such an interpretation).

Typing System
A sorting (resp. a typing, resp. a basis) is a finite partial map from names to sorts (resp. from channels to types, resp. from variables to sequences of sorts and types). We let Γ, Γ',... (resp. Δ, Δ',.. ., resp. Θ, Θ',.. .) range over sortings (resp. typings, resp. bases).



Γ · a : S ▶ ad S	Γ ▶ 1 d nat	Γ ▶ true, false d bool
Γ ▶ ei d nat
Γ ▶ e1 + e2 d nat

Θ; Γ ▶ P d Δ · k : end



Δ completed
[NameI],[Nat],[Bool],[Sum]
[Bot],[Inact]

Θ; Γ ▶ P d Δ · k : ⊥	Θ; Γ ▶ inact d Δ

Γ ▶ ad ⟨α, α⟩	Θ; Γ ▶ P d Δ · k : α


Θ; Γ ▶ accept a(k) in P d Δ
Γ ▶ ad ⟨α, α⟩	Θ; Γ ▶ P d Δ · k : α


Θ; Γ ▶ request a(k) in P d Δ
[Acc]

[Req]

Γ ▶ e˜ d S˜	Θ; Γ ▶ P d Δ · k : α
Θ; Γ ▶ k![e˜]; P d Δ · k : ![S˜]; α	[Send]
Θ; Γ · x˜: S˜ ▶ P d Δ · k : α
Θ; Γ ▶ k?(x˜) in P d Δ · k : ?[S˜]; α	[Rcv]

	Θ; Γ ▶ P1 d Δ · k : α1	·· ·	Θ; Γ ▶ Pn d Δ · k : αn	
Θ; Γ ▶ k D {l1 : P1[] ··· []ln : Pn} d Δ · k : &{l1 : α1,... , ln : αn}
[Br]

	Θ; Γ ▶ P d Δ · k : αj	
Θ; Γ ▶ k  lj; P d Δ · k : ⊕ {l1 : α1,... , ln : αn}
Θ; Γ ▶ P d Δ · k : β
(1 ≤ j ≤ n)	[Sel]

[Thr]

Θ; Γ ▶ throw k[k']; P d Δ · k : ![α]; β · k' : α
Θ; Γ ▶ P d Δ · k : β · k' : α
Θ; Γ ▶ catch k(k') in P d Δ · k : ?[α]; β	[Cat]
Θ; Γ ▶ P d Δ	Θ; Γ ▶ Qd Δ'	'
Θ; Γ ▶ P | Qd Δ ◦ Δ'	(Δ = Δ )	[Conc]
Γ ▶ ed bool	Θ; Γ ▶ P d Δ	Θ; Γ ▶ Qd Δ

Θ; Γ ▶ if e then P else Qd Δ
[If]

Θ; Γ · a : S ▶ P d Δ Θ; Γ ▶ (νa)P d Δ
Θ; Γ ▶ P d Δ · k : ⊥


Θ; Γ ▶ (νk)P d Δ
[NRes],[CRes]

Δ completed	Γ ▶ e˜ d S˜

Θ · X : S˜α˜;Γ ▶ X[e˜k˜] d Δ · k˜ : α˜ 
[Var]

Θ · X : S˜α˜;Γ · x˜: S˜ ▶ P d k˜ : α˜	Θ · X : S˜α˜;Γ ▶ Qd Δ
Θ; Γ ▶ def X(x˜k˜)= P in Qd Δ	[Def]

Fig. 6. Typing System

Definition 2.4 (Type algebra) Typings Δ0 and Δ1 are compatible, written Δ0 = Δ1, if Δ0(k)= Δ1(k) for all k ∈ dom(Δ0) ∩ dom(Δ1). When Δ0 = Δ1, the com- position of Δ0 and Δ1, written Δ0 ◦ Δ1, is given as a typing such that (Δ0 ◦ Δ1)(k) is (1) ⊥, if k ∈ dom(Δ0) ∩ dom(Δ1); (2) Δi(k), if k ∈ dom(Δi) \ dom(Δi+1 mod 2) for i ∈ {0, 1}; and (3) undeﬁned otherwise.

We write Δ · k : α when k /∈ dom(Δ). This notation is then extended to Δ · Δ'. Also, Θ \ x denotes the result of taking off x : Θ(x) from Θ. Similarly for Γ \ a and for Δ \ k.
Typing judgement are of the form Θ; Γ ▶ P d Δ which reads: “under the en- vironment Θ; Γ, process P has typing Δ”. The typing system is defined by the axioms and rules in Figure 6. We call a typing completed when it contains only end types [12]. Rules [Var] and [Inact] make sure that the leaves in every derivation tree contain complete typings only (then, ⊥ may be inserted via rule [Bot]). We also simplify the recursive definition to the single case; the extension to the multiple recursion is obvious.
Changes from the ESOP’98 system
For the syntax, we added x, y, z,... to the category of names, thus incorporating the set of variables into that of names. We have made clear the notions of bindings for the various identifiers in the calculus. For the structural congruence relation, we have replaced fpv(D) by dpv(D), the set of variables introduced in declaration D, and we added rule def D in inact ≡ inact for flexibility. For types, we changed the syntax from 1 to end, from † to !, and from ↓ to ?, following [12]. We have also added more accurate definitions for recursive types (Definitions 2.1 and 2.2) for clarification. For the typing system, we added [NameI], [Nat], [Bool], [Sum] and revised [Acc], [Req], [Var], [Def]. All of these changes are improvements and do not imply any technical difference with respect to [13].
However there is one important addition with respect to the typing system in [13]: the [Bot]-rule. Without the [Bot]-rule, subject congruence (Lemma 2.9) does not hold. Take for example process throw k[k']; inact | inact structural congruent to throw k[k']; inact. We have
▶ throw k[k']; inact | inact dk : ![end]; end · k' : ⊥
but process throw k[k']; inact is not typable under the same typing [1]. In [2], the authors fixed the problem by adding the condition β /= end in the [Thr]-rule. We believe the solution herein presented offers extra flexibility.
Subject Reduction and Type Safety
We start with a few auxiliary results; Subject-Reduction is on page 11, and Type Safety on page 13.
Lemma 2.5 (Weakening Lemma) Let Θ; Γ ▶ P d Δ.
If X /∈ dom(Θ), then Θ,X : S˜α˜;Γ ▶ P d Δ.
If a /∈ dom(Γ), then Θ; Γ,a : S ▶ P d Δ.
If k /∈ dom(Δ) and α = ⊥ or α = end, then Θ; Γ ▶ P d Δ · k : α.
Proof. A simple induction on the derivation tree of each sequent. For iii, we note that in [Inact] and [Var], Δ contains only end.

Lemma 2.6 (Strengthening Lemma) Let Θ; Γ ▶ P d Δ.
If X /∈ fpv(P ), then Θ \ X;Γ ▶ P d Δ.
If a /∈ fn(P ), then Θ; Γ \ a ▶ P d Δ.
If k /∈ fc(P ), then Θ; Γ ▶ P d Δ \ k.
Proof. Standard.
Lemma 2.7 (Channel Lemma)	(i) If Θ; Γ ▶ P d Δ · k : α and k /∈ fc(P ), then
α = ⊥, end.
(ii) If Θ; Γ ▶ P d Δ and k ∈ fc(P ), then k ∈ dom(Δ).
Proof. A simple induction on the derivation tree for each sequent.
We omit the standard renaming properties of variables and channels, but present the Substitution Lemma for names. Note that we do not require a substitution lemma for channels or process variables, for they are not communicated.
Lemma 2.8 (Substitution Lemma) If Θ; Γ,x : S ▶ P d Δ and Θ; Γ ▶ c : S, then
Θ; Γ ▶ P [c/x] d Δ
Proof. Standard.
We write Δ ≺ Δ' if we obtain Δ' from Δ by replacing k1 : end, ..., kn : end (n ≥ 0) in Δ by k1 : ⊥, ..., kn : ⊥. If Δ ≺ Δ', we can obtain Δ' from Δ by applying the [Bot]-rule zero or more times.
Lemma 2.9 (Subject Congruence) If Θ; Γ ▶ P d Δ and P ≡ Q, then Θ; Γ ▶
Qd Δ.
Proof. Case P | inact ≡ P .  We show that if Θ; Γ ▶ P | inact d Δ, then Θ; Γ ▶ P d Δ. Suppose
Θ; Γ ▶ P d Δ1	and	Θ; Γ ▶ inact d Δ2.
with Δ1 ◦ Δ2 = Δ. Note that Δ2 only contains end or ⊥, hence we can set: Δ1 =
Δ' ◦{k˜ : en˜d} and Δ2 = Δ' ·{k˜ : en˜d} with Δ' ◦Δ' = Δ' ·Δ' and Δ = Δ' ·Δ' ·{k˜ : ⊥˜ }.
1	2	1	2	1	2	1	2
Then by the [Bot]-rule, we have:
Θ; Γ ▶ P d Δ' · {k˜ : ⊥˜ }
Notice that, given the form of Δ above, we know that dom(Δ' )∩dom(Δ' ·{k˜ : ⊥})= 
2	1
∅. Hence by applying Weakening, we have:
Θ; Γ ▶ P d Δ' · Δ' · {k˜ : ⊥˜ }
1	2
as required.
For the other direction, we set Δ = ∅ in [Inact].
Case P | Q ≡ Q | P , (P | Q) | R ≡ P | (Q | R).  By commutativity and associativity of =.

Case (νu)P | Q ≡ (νu)(P | Q) if u /∈ fu(Q). The case when u is a name is standard. Suppose u is channel k and assume Θ; Γ ▶ (νk)(P | Q) d Δ. We have
Θ; Γ ▶ P d Δ'	Θ; Γ ▶ Qd Δ'
	1	2
Θ; Γ ▶ P | Qd Δ' · k : ⊥
with Δ' · k : ⊥ = Δ' ◦ Δ' , and Δ' ≺ Δ by [Bot]. First notice that k can be in either
1	2
Δ' or in both. The interesting case is when it occurs in both; from Lemma 2.7(i) and

the fact that k /∈ fc(Q) we know that Δ'
= Δ1 · k : end and Δ'
= Δ2 · k : end. Then,

by applying the [Bot]-rule to k in P , we have Θ; Γ ▶ P d Δ1 · k : ⊥, and by applying [CRes] we obtain Θ; Γ ▶ (νk)P d Δ1. On the other hand, by Strengthening, we have Θ; Γ ▶ Qd Δ2. Then, the application of [Conc] yields Θ; Γ ▶ (νk)P | Qd Δ'. Then by applying the [Bot]-rule, we obtain Θ; Γ ▶ (νk)P | Qd Δ, as required. The other direction is easy.
Case (νu)inact ≡ inact. Standard by Weakening and Strengthening.
Case def D in inact ≡ inact. Similar to the first case using Weakening and Strengthening.
Case (νu)def D in P ≡ def D in (νu)P if u /∈ fu(D). Similar to the scope opening case using Weakening and Strengthening.
Case (def D in P ) | Q ≡ def D in (P | Q) if dpv(D) ∩ fpv(Q)= ∅. Similar with the scope opening case using Weakening and Strengthening.
Theorem 2.10 (Subject Reduction) If Θ; Γ ▶ P d Δ and P →∗ Q, then Θ; Γ ▶
Qd Δ.
Proof. We assume that
Γ ▶ edS and e ↓ c implies Γ ▶ cdS	(3) and prove the result by induction on the last rule applied.
Case [Link] (accept a(k) in P1) | (request a(k) in P2) → (νk)(P1 | P2). Sup- pose Θ; Γ ▶ (accept a(k) in P1) | (request a(k) in P2) d Δ. Then the assumption is derived from:
Γ ▶ ad ⟨α, α⟩	Θ; Γ ▶ P1 d Δ' · k : α	Γ ▶ ad ⟨α, α⟩	Θ; Γ ▶ P2 d Δ' · k : α
1	'	and	2	'
Θ; Γ ▶ accept a(k) in P1 d Δ1	Θ; Γ ▶ request a(k) in P2 d Δ2
and [Bot] with Δ' ≺ Δi, [Conc] with Δ1 ◦ Δ2 = Δ', and [Bot] with Δ' ≺ Δ.

Then applying [Bot] to P1 and P2, we have:
Θ; Γ ▶ P1 d Δ' · k : α

Θ; Γ ▶ P2 d Δ' · k : α

1
Θ; Γ ▶ P1 d Δ1 · k : α
and
2
Θ; Γ ▶ P2 d Δ2 · k : α

Then we apply [Conc] to P1 and P2 to obtain:
Θ; Γ ▶ P1 d Δ1 · k : α	Θ; Γ ▶ P2 d Δ2 · k : α
Θ; Γ ▶ P1 | P2 d Δ' · k : ⊥

Now applying [CRes] and [Bot], we are done.
Case [Com] (k![e˜]; P1) | (k?(x˜) in P2) → P1 | P2[c˜/x˜] with e˜ ↓ c˜. The assumption is derived from:

Γ ▶ e˜ d S˜
Θ; Γ ▶ P1 d Δ' · k : α

and
Θ; Γ · x˜: S˜ ▶ P2 d Δ' · k : α



Θ; Γ ▶ k![e˜]; P1 d Δ' · k : ![S˜]; α	Θ; Γ ▶ k?(x˜) in P2 d Δ' · k : ?[S˜]; α
and [Bot] with Δ' ≺ Δi, [Conc] with Δ1 ◦Δ2 · k : ⊥ = Δ', and [Bot] with Δ' ≺ Δ. Then by (3), we know Γ ▶ c˜d S˜. By applying Substitution Lemma, we have:
Θ; Γ ▶ P2[c˜/x˜] d Δ' · k : α
Now the application of [Bot] and [Conc] to P1 and P2[c˜/x˜], then by [Bot], we complete this case.
Case [Label] (k  li; P1) | (k D {l1 : P1[] ··· []ln : Pn}) → P | Pi  (1 ≤ i ≤ n).
Similar to the above case.
Case [Pass] (throw k[k']; P1) | (catch k(k') in P2) → P1 | P2. The assumption is derived from:



and
Θ; Γ ▶ P1 d Δ' · k : β


Θ; Γ ▶ throw k[k']; P1 d Δ' · k : ![α]; β · k' : α

Θ; Γ ▶ P2 d Δ' · k : β · k' : α
Θ; Γ ▶ catch k(k') in P2 d Δ' · k : ?[α]; β

and [Bot] with Δ' ≺ Δi, [Conc] with Δ1 ◦ Δ2 · k : ⊥· k' : α = Δ' and [Bot] with
Δ' ≺ Δ. Note that k, k' /∈ dom(Δ1, Δ2, Δ' , Δ' ). By applying [Bot], [Conc] to P1
1	2
and P2, and then by [Bot], we obtain the required result.
Case [If1],[If2]. Trivial.
Case [Def] def D in (X[e˜k˜] | Q) → def D in (P [c˜/x˜] | Q) with e˜ ↓ c˜ and X(x˜k˜) = P ∈ D. Simplifying the recursive definition to the single case, we set D = (X(x˜k˜)= P ). Then the assumption is derived from:
Θ·X : S˜α˜;Γ ▶ X[e˜k˜] d Δ' ·k˜ : α˜	Θ·X : S˜α˜;Γ ▶ Qd Δ'

Θ·X : S˜α˜; Γ·x˜: S˜ ▶ P d k˜ : α˜ 
Θ·X : S˜α˜;Γ ▶ X[e˜k˜] | Qd Δ''·k˜ : α˜ 
Δ'' ≺ Δ'



Θ; Γ ▶ def X(x˜k˜)= P in (X[e˜k˜] | Q) d Δ'·k˜ : α˜ 

with Δ0 = Δ' · k˜ : α˜, Δ' = Δ' ◦ Δ' and Δ0 ≺ Δ. Note that Δ'
contains only ⊥ or

1	2	1
end. Then applying Substitution Lemma to P , we have:
Θ · X : S˜α˜;Γ ▶ P [c˜/x˜] d k˜ : α˜ 
Notice that k˜ ∩ dom(Δ' )= ∅, since (Δ' ◦ Δ' ) · k˜ : α˜ is defined. Then by Weakening,
1	1	2
we have:
Θ · X : S˜α˜;Γ ▶ P [c˜/x˜] d Δ' · k˜ : α˜ 

Now by [Conc], we have
Θ · X : S˜α˜;Γ ▶ P [c˜/x˜] | Qd Δ'' · k˜ : α˜ 
Finally by [Bot] (Δ'' ≺ Δ'), then by [Def], we obtain:
Θ; Γ ▶ def X(x˜k˜)= P in (P [c˜/x˜] | Q) d Δ' · k˜ : α˜ 
Then we can apply [Bot] to obtain Δ, as desired.
Case [Str]. By Subject-Congruence.
To formalise Type Safety, we need the following notions. A k-process is a process prefixed by subject k (such as k![e˜]; P and catch k(k') in P ). Next, a k-redex is the parallel composition of two k-processes, i.e. either of form (k![e˜]; P | k?(x˜) in Q), (k l; P | k D{l1 : Q1[] ··· []ln : Qn}), or (throw k[k']; P | catch k(k'') in Q). Then P is an error if P ≡ (νu˜)(def D in (Q | R)) where Q is, for some k, the parallel composition of either two k-processes that do not form a k-redex, or three or more k-processes. We then have:
Theorem 2.11 (Type Safety) A typable program never reduces to an error.
Proof. By Subject Reduction it suffices to show that typable programs are not errors. The proof is by reductio ad absurdum, assuming error processes typable. Suppose that Θ; Γ ▶ def D in (νu˜)(P | Q) d Δ. Analysing the derivation tree for the process, we conclude that Θ; Γ ▶ P d Δ', for some Δ'. We now analyse the two classes of error processes.
When P = P1 | P2 is the parallel composition of two k-processes that do not form a redex, there are several cases to consider. They are all alike; take for example

the pair label-select/throw. Applying [Conc] on P , we have Θ; Γ ▶ P1 d Δ'
and

Θ; Γ ▶ P2 d Δ' with Δ' ≺ Δ' ◦ Δ' . Applying [Sel] on P1 and [Thr] on P2 we
conclude that k : ⊕ {l1 : α1,... , ln : αn}∈ Δ' and k : ![α]; β ∈ Δ' . But then Δ' ◦ Δ'
1	2	1	2
is not defined, hence def D in (νu˜)(P | Q) is not typable.
When P is the parallel composition of three or more k-processes, we concentrate on the case of three processes, for the remaining cases reduce to this. So let P = (P1 | P2) | P3. Applying [Conc], we know that Θ; Γ ▶ P1 | P2 d Σ and Θ; Γ ▶ P3 d Σ' with Δ' ≺ Σ ◦ Σ'. If P1 | P2 is not a k-redex, we use the case above. Otherwise, it must be the case that k : ⊥ ∈ Σ. From Lemma 2.7(ii), we know that k ∈ dom(Σ'), thus Σ ◦ Σ' is not defined, hence def D in (νu˜)(P | Q) is not typable.

A More Liberal Session Passing Style
Rule [Pass] in the original ESOP’98 system
(throw k[k']; P1) | (catch k(k') in P2) → P1 | P2

does not allow the transmission of an arbitrary channel. In most situations a process catch k(k'') in P2 can be alpha-converted ahead of communication 3 so that the bound variable k'' syntactically matches the free variable k' in the throw process. The exception happens exactly when k' is free in P2: alpha-conversion becomes impossible (for it would capture free variable k'), and communication cannot occur. A more liberal rule would allow the transmission of an arbitrary channel, im-
plying a substitution on the client side.
(throw k[k']; P1) | (catch k(k'') in P2) → P1 | P2[k'/k''] Unfortunately this rule breaks Subject Reduction (Theorem 2.10). A counter-
example is a process which, possessing one end of a channel, receives the second
end. The process:
throw k[k'] | catch k(k'') in k''?(y) in k'![1]	(4) is typable under typing k : ⊥, k' : ⊥, but reduces to process
k'?(x) in k'![1]
which is not typable under the same typing [7].
One might think that the simplest solution of the above problem is to add the side condition k' /∈ fc(P2) to the above rule proposal. This reduction rule, however, implies that the condition of free channels is checked at runtime, which contradicts the aim of static type checking to preserve Subject Reduction. The same sort of situation occurs in the ESOP’98 system, where, in presence of a process throw k[k']; P1 | catch k(k'') in P2, the runtime system has to check whether k' ∈ fc(P2) in order to alpha-convert the catch-process before applying rule [Pass] above.
A different alternative would be to type the contractum with a different typing. In the above case and for the catch process in the redex, we have k' : ![nat]; end, and k'' : ?[nat]; end. In the contractum, channels k' and k'' are aliased and it is not obvious how to build, from the premises, the correct type ?[nat]; ![nat]; end for k'.
A solution, due to Gay and Hole [12], explicitly distinguishes between the two ends of a channel. For a channel κ, its two ends are denoted κ+ and κ−. Channels are now runtime entities (they are not supposed to occur in programs) created by rule [Link], which becomes:
(accept a(x) in P1) | (request a(x) in P2) → (νκ)(P1[κ+/x] | P2[κ−/x])
Rules that synchronise two processes on a given channel are updated so that each process explicitly mentions one of the ends. For example rule [Thr] becomes:

(throw κp[k']; P1) | (catch κp(x) in P2) → P1 | P2[k'/x]

3 Cf. Paragraph Relationship with the Rewriting Rules of the π-Calculus in Section 2.1.

where p denotes one end (one polarity ) of κ and p the other.
A further change allows a typing Δ to contain one type for κ+ and a different type (not necessarily dual) for κ−. Parallel composition juxtaposes the typings of the two operands (provided they have disjoint domains), rather than composing using ◦ (cf. Definition 2.4).
Θ; Γ ▶ P d Δ	Θ; Γ ▶ Qd Δ'
Θ; Γ ▶ P | Qd Δ · Δ'	[Conc]
An immediate consequence of the new rule is that we do not need the bottom ⊥ type anymore, or the notions of typing compatibility and composition. One the other hand, the new rule for channel restriction requires the two ends of the channel to be of dual types.

Θ; Γ ▶ P d Δ · κ+ : α · κ− : α
Θ; Γ ▶ (νκ)P d Δ

[CRes]

Notice that the original rule (in Figure 6) requires an entry k : ⊥ in typing Δ.
To understand how the new system works, consider process (4) refined into the new syntax:
throw κ+[κ'+] | catch κ−(x) in x?(y) in κ'−![1]
The process is typable under the typing κ+ : ![α]; end, κ− : ?[α]; end, κ'+ : α, κ'− : α
where α is the type ?[nat]; end. It now reduces to
κ'+?(x) in κ'−![1]
which is still typable (this time under typing κ'+ : α, κ'− : α).
Clearly, typability over arbitrary channel environments is not closed under re- duction any more. For example, the process
κ+![true] | κ−?(x) in κ'−![x + 1]	(5)
is typable under typing κ+ : ![bool]; end, κ− : ?[nat]; end, κ'− : ![nat]; end, but reduces to
κ'−![true + 1]
which is not typable. The last step is then to consider, for Subject Reduction and Type Safety purposes, only typings where the two ends of a channel are of dual types. We call such typings balanced [12]. This restriction rules out the above typing (since ![bool]; end is not dual to ?[nat]; end), hence process (5) is not guaranteed to preserve typability under reduction or to be type safe.
Syntax and Operational Semantics
With respect to the syntax in Figure 1, we let κ, rather than k, range over channels. Identifier k now stands for polarised channels (κ+, κ−) or names (a, x). As such k cannot occur in a binding position anymore; four process constructors need to be

updated: accept, request, catch, and def. The grammar of the language is given by the rules in Figure 1, replacing the productions for accept, request, catch, and def by the ones below.

P ::= request a(x) in P	session request
| accept a(x) in P	session acceptance
| catch k(x) in P	channel reception
| ... 
D ::= X1(x˜1y˜1)= P1 and ··· and Xn(x˜ny˜n)= Pn	declaration for recursion
k ::= x | κp	channel variables and values
p ::= + | −	channel polarities

Duality on polarities is defined as += − and − = +. Variable x is now bound in any of request a(x) in P, accept a(x) in P, catch k(x) in P , and the variables in x˜y˜ become bound in X(x˜y˜)= P , so that, in contrast with the system in Section 2.1, we have three more name binders, and only (νκ)P remains as a binder for channels. The new reduction relation adapts the rules that directly work with channels.
Reduction is given by replacing, in Figure 3, rules [Link], [Com], [Label], [Pass], and [Def] by the rules below. Structural congruence (Figure 2) remains unchanged.

(accept a(x) in P1) | (request a(x) in P2) → (νκ)(P1[κ+/x] | P2[κ−/x])
[Link]

(κp![e˜]; P1) | (κp?(x˜) in P2) → P1 | P2[c˜/x˜]	(e˜ ↓ c˜)	[Com]
(κp  li; P ) | (κp D {l1 : P1[] ··· []ln : Pn}) → P | Pi	(1 ≤ i ≤ n)	[Label] (throw κp[κ'q]; P1) | (catch κp(x) in P2) → P1 | P2[κ'q/x]		[Pass]
def D in (X[e˜κ˜p] | Q) → def D in (P [c˜/x˜][κ˜p/y˜] | Q) (e˜ ↓ c˜, X(x˜y˜)= P ∈ D)
[Def]


Type Discipline
Types in Figure 4 remain unchanged, except that bottom ⊥ is no longer needed. Typings still feature entries of the form k : α, only that k can now be a name x, or a polarised channel κ+ or κ−. The type system needs adjustments in rules [Acc], [Req], [Cat] and [Def] due to the change in syntax. Also, the absence of rule [Bot] is compensated by a new rule [CRes’] for (νκ)P . The main change however happens in rules [Conc] and [CRes]. The new type system is given by replacing, in Figure 6, rules [Acc], [Req], [Cat], [Def], [Conc], [CRes], and [Bot] by the rules below.



Γ ▶ a : ⟨α, α⟩	Θ; Γ ▶ P d Δ · x : α


Θ; Γ ▶ accept a(x) in P d Δ
Γ ▶ a : ⟨α, α⟩	Θ; Γ ▶ P d Δ · x : α
Θ; Γ ▶ request a(x) in P d Δ Θ; Γ ▶ P d Δ · k : β · x : α
Θ; Γ ▶ catch k(x) in P d Δ · k : ?[α]; β
[Acc]

[Req]

[Cat]

Θ · X : S˜α˜;Γ · x˜: S˜ ▶ P d y˜: α˜ 
Θ · X : S˜α˜;Γ ▶ Qd Δ
[Def]

Θ; Γ ▶ def X(x˜y˜)= P in Qd Δ
Θ; Γ ▶ P d Δ	Θ; Γ ▶ Qd Δ'
Θ; Γ ▶ P | Qd Δ · Δ'	[Conc]
Θ; Γ ▶ P d Δ · κ+ : α · κ− : α



Θ; Γ ▶ (νκ)P d Δ
Θ; Γ ▶ P d Δ	κ not in Δ Θ; Γ ▶ (νκ)P d Δ
[CRes]

[CRes’]

In rule [Var], Figure 6, typing k1 ... kn : α1 ... αn is understood as k1 : α1 ·
... · kn : αn, defined only when the ki are pairwise distinct. This restriction is crucial in controlling channel aliasing during reduction via the [Def] rule, now that a substitution is performed. Suppose that we judge as valid a sequent of the form X : SS ▶ X[kk] d k : S. Then, taking for D the process definition X(k'k'')= k'![1].k''![2], process def D in X[kk] would be typable under typing k : !nat.end, but reduces to process def D in k![1].k![2] which is not typable under the same typing.

Subject Reduction and Type Safety
The absence of typing compatibility (in rule [Conc]) is compensated by balanced typings. We say that a typing Δ is balanced if whenever κ+ : α, κ− : β ∈ Δ, then α = β [12]. Subject-Reduction (Theorem 3.3) and Type Safety (Theorem 3.4) hold only in presence of balanced typings.
We rely on the Weakening, Strengthening, Channel and Substitution Lemmas of Section 2.4, adapted to the syntax and typing system of this section. Since we now replace channels in processes, we need a Channel Replacement Lemma, a result not needed for the ESOP’98 system [13]. The proofs below are adapted from those in references [12,23], except that our scope extrusion rule (in Figure 2) is more general than that of [12].
Lemma 3.1 (Channel Replacement) If Θ; Γ ▶ P dΔ·x : α, then Θ; Γ ▶ P [κp/x]d Δ · κp : α.
Proof. A straightforward induction on the derivation tree for P .
Lemma 3.2 (Subject Congruence) If Θ; Γ ▶ P d Δ and P ≡ Q, then Θ; Γ ▶
Qd Δ.

Proof. The proof follows the pattern of that of Lemma 2.9, albeit slightly simplified by the absence of the non-structural [Bot] rule. We detail the two most interesting cases.
Case P | inact ≡ P . We show that if Θ; Γ ▶ P | inact d Δ, then Θ; Γ ▶ P d Δ. Suppose that
Θ; Γ ▶ P d Δ1	and	Θ; Γ ▶ inact d Δ2
with Δ1 · Δ2 = Δ. Note that Δ2 only contains end. Applying Weakening to P , we have Θ; Γ ▶ P d Δ1 · Δ2 as required.
For the other direction we start with derivation Θ; Γ ▶ inact d ∅, and then apply rule [Conc].
Case (νu)(P | Q) ≡ (νu)P | Q if u /∈ fu(Q). The case when u is a name is standard. Suppose u is channel k and assume Θ; Γ ▶ (νκ)(P | Q) d Δ. We consider the [CRes] case (the [CRes’] case is simpler):
Θ; Γ ▶ P d Δ1	Θ; Γ ▶ Qd Δ2
Θ; Γ ▶ P | Qd Δ · κp : α · κp : α

First notice that κp and κp can be both in either Δi or one in each. When they are both in Δ1 we conclude the case by applying [CRes] and [Conc]. When they are both in Δ2, by the Channel Lemma we know that the types for κp and κp in Δ2 are end. We conclude the case by applying Strengthening twice to Q before
applying [CRes’] and [Conc]. Finally, when κp is in Δ' and κp in Δ' , we apply
Strengthening to Q and Weakening to P , before applying [CRes] and [Conc].
The other direction is simpler.
Theorem 3.3 (Subject Reduction) If Θ; Γ ▶ P d Δ with Δ balanced and P →∗
Q, then Θ; Γ ▶ Qd Δ' and Δ' balanced.
Proof. The proof is similar to that of Theorem 2.10. We concentrate on the four new reduction rules, and reuse the remaining cases.
Case [Link] (accept a(x) in P1) | (request a(x) in P2)	→ (νκ)(P1[κ+/x] |
P2[κ−/x]). The assumption is derived from
Θ; Γ ▶ P1 d Δ · x : α
Θ; Γ,a : ⟨α, α⟩▶ accept a(x) in P1 d Δ


from
Θ; Γ ▶ P2 d Δ · x : α
Θ; Γ,a : ⟨α, α⟩▶ request a(x) in P2 d Δ

and from [Conc] with Δ1 · Δ2 = Δ. Applying the Channel Replacement Lemma to P1 and also to P2, we have Θ; Γ ▶ P1[κ+/x] d Δ · κ+ : α, and Θ; Γ ▶ P2[κ−/x] d Δ · κ− : α. The case concludes with the application of rule [Conc] followed by rule [CRes].

Case [Com] (κp![e˜]; P1) | (κp?(x˜) in P2) → P1 | P2[c˜/x˜]. The assumption is

derived from: Γ ▶ e˜ d S˜

Θ; Γ ▶ P d Δ1 · κp : α

Θ; Γ · x˜: S˜ ▶ P2 d Δ2 · κp : α

Θ; Γ ▶ k![e˜]; P1 d Δ1 · κp : ![S˜]; α	Θ; Γ ▶ k?(x˜) in P2 d Δ2 · κp : ?[S˜]; α
and [Conc] with Δ1 · κp : ![S˜]; α · Δ2 · κp : ?[S˜]; α = Δ. Notice that the types for κp and for κp are dual since Δ is balanced by hypothesis. Then by (3), page 11, we know Γ ▶ c˜ d S˜. We conclude the case by applying Substitution Lemma to P2, and the [Conc]-rule to P1 and to P2[c˜/x˜].
Case [Label]. Similar to the homonymous case in the proof of Theorem 2.10, relying, as above, on the fact that Δ is balanced.

Case [Pass] (throw κp[κ'q]; P1) | (catch κp(x) in P2) → P1 | P2[κ'q/x]. The assumption is derived from



from
Θ; Γ ▶ P1 d Δ1 · κp : β


Θ; Γ ▶ throw κp[κ'q ]; P1 d Δ1 · κp : ![α]; β · κ'q : α

Θ; Γ ▶ P2 d Δ2 · κp : β · x : α
Θ; Γ ▶ catch κp(x) in P2 d Δ2 · κp : ?[α]; β

and from [Conc] with Δ1 · κp : ![α]; β · κ'q : α · Δ2 · κp : ?[α]; β = Δ. Once again, the
types for κp and for κp are dual since Δ is balanced by hypothesis. Applying the Channel Replacement Lemma to P2, we obtain

Θ; Γ ▶ P2[κ'q/x] d Δ2 · κp : β · κ'q : α
By applying [Conc] to P1 and P2[κ'q/x], we obtain the required result.
Case [Def] (def D in (X[e˜κ˜p] | Q) → def D in (P [c˜/x˜][κ˜p/y˜] | Q) with e˜ ↓ c˜ and X(x˜y˜) = P ∈ D. Similar to the homonymous case in the proof of Theorem 2.10, with the difference that, when building the derivation tree for the contractum, after obtaining
Θ · X : S˜α˜;Γ ▶ P [c˜/x˜] d y˜: α˜ 
by the application of the Substitution Lemma, we apply Channel replacement to obtain
Θ · X : S˜α˜;Γ ▶ P [c˜/x˜][κ˜p/y˜] d κ˜p : α˜.
Theorem 3.4 (Type Safety) A program typable under a balanced channel envi- ronment never reduces to an error.
Proof. The proof follows the pattern of that of Theorem 2.11, only that the contra- diction happens not because typing composition (Δ◦Δ') is not defined, but because the resulting typing (Δ · Δ') is not balanced.
Conclusion
The study of session typing system is now widespread due to the need for structured communications in various scenarios in distributed applications. They have been

studied, at the research level, for the π-calculus [2,11,12,13,17,20,23], Ambients [6], CORBA interfaces [21], multi-threaded functional languages [23,24,15], Web De- scription Languages [3,4,14], and distributed [8] and multi-threaded Java [7] and, at the industry level, WC3-CDL [5,25] and pi4Tech [16].
In the presence of higher-order session communication, session instantiation dy- namically changes structures of sessions during execution, so that it becomes non- trivial to preserve typability. Unfortunately the authors of previous session typing systems did not realise (or even forgot about) the key point of rule [Pass], so that some of the systems published after [13] fail to satisfy the Subject Reduction Theo- rem. As discussed in this report, the subtlety of the type preservation is related to a treatment of communication channels in the operational semantics of the π-calculus: aliasing of channels, structured safe communication, types, new name creation and the α-conversion are tightly related with this issue.
As a future work, it would be nice to investigate the relationship uniformly using rewriting frameworks [9,10].

Acknowledgement
The authors thank Eduardo Bonelli for his pointing out the issue of the subject congruence in ESOP’98 paper; Kohei Honda for his suggestion of the [Bot]-rule; Simon Gay for his comments on the liberal typing system; and the SecReT review- ers for their comments and suggestions. This work is partially supported by EU IST–2005–015905 MOBIUS project, EU IST–2005–16004 SENSORIA project, EP- SRC GR/T03208, EPSRC GR/S55538, EPSRC GR/T04724, EPSRC GR/S68071,
FEDER, and Fundac¸˜ao para a Ciˆencia e a Tecnologia (via CLC, CITI, and POSC/ EIA/55582/2004 Space-Time-Types project).

References
Bonelli, E., A. Compagnoni and E. Gunter, Private communication (2003).
Bonelli, E., A. Compagnoni and E. Gunter, Correspondence Assertions for Process Synchronization in Concurrent Communications, Journal of Functional Programming 15 (2005), pp. 219–248.
Carbone, M., K. Honda and N. Yoshida, A calculus of global interaction based on session types, in: 2nd Workshop on Developments in Computational Models (DCM), ENTCS, 2006.
Carbone, M., K. Honda and N. Yoshida, Structured communication-centred programming for web services, in: ESOP’07, LNCS, 2007.
Carbone, M., K. Honda, N. Yoshida, R. Milner, G. Brown and S. Ross-Talbot, A Theoretical Basis of Communication-Centred Concurrent Programming, To be published by W3C. Available at http://www.dcs.qmul.ac.uk/∼carbonem/cdlpaper/workingnote.pdf (2006).
Compagnoni, A., M. Dezani-Ciancaglini and P. Garralda, BASS:Boxed Ambients with Safe Sessions, in: Proceedings of PPDP’06 (2006), pp. 119–148.
Dezani-Ciancaglini, M., D. Mostrous, N. Yoshida and S. Drossopoulou, Session types for object-oriented languages, in: The 20th European Conference on Object-Oriented Programming, LNCS (2006), pp. 328– 352.
Dezani-Ciancaglini, M., N. Yoshida, A. Ahern and S. Drossopoulou, A distributed object-oriented language with session types, in: Symposium on Trustworthy Global Computing, LNCS (2005), pp. 299– 318.


Fern´andez, M. and M. J. Gabbay, Nominal rewriting with name generation: abstraction vs. locality, in: Proc. 7th ACM-SIGPLAN Symposium on Principles and Practice of Declarative Programming (PPDP’05) (2005), pp. 47–58.
Fern´andez, M., M. J. Gabbay and I. Mackie, Nominal rewriting systems, in: Proc. 6th ACM-SIGPLAN Symposium on Principles and Practice of Declarative Programming (PPDP’04) (2004), pp. 108–119.
Gay, S. J. and M. J. Hole, Types and subtypes for client-server interactions, in: ESOP’99, LNCS (1999),
pp. 74–90.
Gay, S. J. and M. J. Hole, Subtyping for session types in the pi calculus, Acta Informatica 42 (2005),
pp. 191–225.
Honda, K., V. T. Vasconcelos and M. Kubo, Language primitives and type disciplines for structured communication-based programming, in: ESOP’98, LNCS 1381 (1998), pp. 22–138.
Honda, K., N. Yoshida and M. Carbone, Web services, mobile processes and types, EATCS 2 (2007), to appear.
Neubauer, M. and P. Thiemann, An implementation of session types., in: PADL, Lecture Notes in Computer Science 3057 (2004), pp. 56–70.
O’Hanlon, C., Conversation with Steve Ross-Talbot, ACM Queue 4 (2006), pp. 14–23.
Ostrovsky´, K., “On modelling and analysing concurrent systems,” Ph.D. thesis, Chalmers University of Technology (2006).
Pierce, B. C., “Types and Programming Languages,” MIT Press, 2002.
Sangiorgi, D., π-calculus, internal mobility and agent-passing calculi, Theoretical Computer Science
167 (1996), pp. 235–274.
Takeuchi, K., K. Honda and M. Kubo, An Interaction-based Language and its Typing System, in:
PARLE’94, LNCS 817 (1994), pp. 398–413.
Vallecillo, A., V. T. Vasconcelos and A. Ravara, Typing the behavior of objects and components using session types, Fundamenta Informaticæ73 (2006).
Vasconcelos, V. T., Recursive types in a calculus of objects, Transactions of Information Processing Society of Japan 35 (1994), pp. 1828–1836.
Vasconcelos, V. T., S. Gay and A. Ravara, Typechecking a multithreaded functional language with session types, Theoretical Computer Science (2006), to appear.
Vasconcelos, V. T., A. Ravara and S. Gay, Session Types for Functional Multithreading, in:
CONCUR’04, LNCS 3170 (2004), pp. 497–511.
Web Services Choreography Working Group, Web Services Choreography Description Language,
http://www.w3.org/2002/ws/chor/ .
