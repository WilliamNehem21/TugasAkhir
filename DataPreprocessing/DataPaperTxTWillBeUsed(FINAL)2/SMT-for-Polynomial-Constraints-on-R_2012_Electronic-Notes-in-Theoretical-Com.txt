Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 289 (2012) 27–40
www.elsevier.com/locate/entcs

SMT for Polynomial Constraints on Real Numbers
To Van Khanh1 and Mizuhito Ogawa2
School of Information Science
Japan Advanced Institute of Science and Technology Ishikawa, Japan

Abstract
This paper preliminarily reports an SMT for solving polynomial inequalities over real numbers. Our ap- proach is a combination of interval arithmetic (over-approximation, aiming to decide unsatisfiability) and testing (under-approximation, aiming to decide satisfiability) to sandwich precise results. In addition to existing interval arithmetic, such as classical intervals and affine intervals, we newly design Chebyshev Approximation Intervals, focusing on multiplications of the same variables, like Taylor expansions. When
testing cannot find a satisfiable instance, this framework is designed to start a refinement loop by split- ting input ranges into smaller ones (although this refinement loop implementation is left to future work). Preliminary experiments on small benchmarks from SMT-LIB are also shown.
Keywords: interval arithmetic, affine arithmetic, SAT modulo theories - SMT, polynomial constraints, testing.


Introduction
Solving polynomial constraints plays an important role in program verification, e.g., roundoff/overflow error detection [16], termination proving [10], hybrid systems, loop invariant generation, and parameter design of control.
Tarski proved that polynomial constraints over real numbers (algebraic numbers) is decidable [21], and later Collins proposed Quantifier Elimination by Cylindri- cal Algebraic Decomposition [4], which is nowadays implemented in Mathematica, Maple/SynRac, Reduce/Redlog, and QEPCAD. However, it is DEXPTIME with respect to the number of variables, and works fine in practice up to 5 variables and lower degrees. For instance, eight variables with degree 10 require 20-30 hours by supercomputer.

1 Email: khanhtv@jaist.ac.jp
2 Email: mizuhito@jaist.ac.jp


1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.11.004

SMT (SAT modulo theories) separates case analysis and the core computation in the theory. RAHD [18] is such an example, which applies variations of QE-CAD implementations (e.g., QEPCAD-B, Reduce/Redlog) as a background theory.
An alternative choice of theory is approximation, e.g., iSAT [8], MiniSmt [22], Barcelogic [3], CVC3 [2], and CORD [9], in which bounded binary encoding, CORDIC, and Interval arithmetic are examples of background theories. Among them, MiniSmt and CVC3 have participated in QF NRA category of SMT-LIB [1]. This paper preliminarily reports an SMT for solving polynomial inequalities over real numbers. Our approach is a combination of interval arithmetic (over- approximation, aiming to decide unsatisfiability) and testing (under-approximation, aiming to decide satisfiability) to sandwich precise results. In addition to existing interval arithmetic, such as classical intervals and affine intervals, we newly design Chebyshev Approximation Intervals (called CAI1 and CAI2), focusing on multipli- cations of the same variables, like Taylor expansions. Chebyshev approximation in interval arithmetic is not new, but we newly introduce noise symbols for absolute
values.
We apply very lazy theory learning [15] for interaction with MiniSat 2.2. Ini- tially, an SAT instance given from SAT solver describes possible combinations of input ranges. If interval arithmetic (IA) reports unsatisfiability (IA UNSAT), such combinations are removed for next SAT searching by memorizing them as learnt clauses to SAT solver. If IA reports validity (IA VALID), any instances in the ranges is satisfiable. If IA finds neither validity nor unsatisfiability (IA SAT), each polynomial is examined by testing.
If testing cannot find a satisfiable instance (Test UNSAT), such combinations of input ranges can be memorized as a learnt clause by heuristics, and removed from next searching.
When IA decides neither satisfiability nor unsatisfiability, this framework is de- signed to start a refinement loop by splitting input ranges into smaller ones (al- though this refinement loop implementation is left to future work).
The structure of paper is organized as follows. Section 2 describes the poly- nomial constraints and theory learning strategy in terms of abstract DPLL [15]. Section 3 explains variations of interval arithmetic and newly proposes Chebyshev Approximation Intervals, CAI1, CAI2. Section 4 describes testing strategies. The framework of our SMT solver is described with examples in section 5. Preliminary experiments on small examples from SMT-LIB benchmarks [1] are reported in sec- tion 6. Section 7 discusses some related works, and section 8 concludes the paper with future work.

Polynomial constraints and Abstract DPLL
Among polynomial constraints over real numbers, our current target problem is sat- isﬁable problem of polynomial inequality constraints, as in Definition 2.1. Handling polynomial equality’s is left to future work. We assume input ranges are given by intervals (as in the most of SMT-LIB benchmarks).

Definition 2.1 A polynomial inequality constraint is in the form of (∃x1 ∈ [l1, h1] ··· xn ∈ [ln, hn].	fj(x1, ··· , xn) > 0)
j
where li, hi ∈ R and fj(x1, ··· , xn) is a polynomial over variables x1, ··· , xn.
Satisfiability Modulo Theories (SMT) is a procedure to detect satisfiable instances under a background theory. A typical arithmetic theory is Presburger arithmetic (linear arithmetic) over integers and real numbers. It decomposes a problem into SAT solving as case analysis and theory as arithmetic conjunctive constraint solving. Interaction between SAT solving and theory has Lazy and Eager strategies, which are described below as Abstract DPLL modulo theories [15].
As notation, l and li denote literals,a clause is a set of literals, and a Conjunctive Normal Form (CNF) F is a set of clauses. M and M1 are (partial) assignments, which are sequences of literals. =⇒ is a binary relation over states which are pairs of an assignment M and a CNF F , denoted as M  F . A clause C is true in M if C ∩ M /= ∅. M is satisfied on F , denoted as M |= F , if all clauses of F are true in M . If F ∪ ¬G is unsatisﬁable in a background theory T which is denoted as F |=T G.
Very lazy theory learning interacts with theory T when an SAT instance is found, and learns a clause ¬l1 ∨ ... ∨ ¬ln ∨ ¬l when the theory refutes l1 ∧ ... ∧ ln ∧ l.
⎧⎪⎨MlM1 |= F

MlM1	F =⇒∅ F ∧ (¬l1 ∨ ... ∨ ¬ln ∨ ¬l)	if
{l1, ..., ln}⊆ M
⎪⎩l1 ∧ ... ∧ ln |=T ¬l

Eager theory propagation interacts with theory T during DPLL procedure of SAT, and DPLL procedure continues when the theory admits the current decisions.
⎧⎪⎨M |=T l

M	F =⇒ Ml	F	if
l is undefined in M
⎪⎩l or ¬l occurs in F

We adopt very lazy theory learning on MiniSat2.2, which naturally memo- rizes unsatisfiable combination of input ranges for a polynomial as a learnt clause. Certain combination with eager theory propagation would improve the efficiency. However, it is left for future work, since it requires tighter interaction between SAT solver and theory, which needs internal modification of MiniSat.

Interval Arithmetic
Interval arithmetic (IA) estimates bounds of polynomials under given input ranges, and we use it as an over-approximation theory. For a closed existential polynomial constraint

C = ∃x1 ∈ [l1, h1] ··· xk ∈ [lk, hk] .
m
fi(x1, ··· , xk) > 0,
1

ƒl(x1, ··· , xk) and ƒu(x1, ··· , xk) are lower and upper bounds estimated by IA,
i	i
we say
C is IA VALID if ∀i ∈ [1, m]. ƒl(x1, ··· , xk) > 0,
C is IA UNSAT if ∃i ∈ [1, m]. ƒu(x1, ··· , xk) ≤ 0 and
C is IA SAT if ∃j ∈ [1, m]. ƒl(x1, ··· , xk) ≤ 0 ∧ (V ƒu(x1, ··· , xk) > 0).
j	i
i
Note that IA VALID and IA UNSAT safely reason SAT and UNSAT, respec- tively. However, IA SAT cannot conclude SAT, and treated as unknown.
A popular example of IA is Classical Interval (CI) [14], which keeps a lower bound and an upper bound. The weakness of CI is loss of dependency among values. For instance, if x ∈ [2, 4] then, x − x is evaluated to [−2, 2].
Affine interval (AF) introduces noise symbols ϵ, which is interpreted as a value in [−1, 1] [5,6,7], for partial symbol manipulation. For instance, x ∈ [2, 4] is represented as x = 3+ϵ, and x−x = (3+ϵ)−(3+ϵ) is safely evaluated to 0. The drawback is that the multiplication without dependency may be less precise than CI. For instance, let x ∈ [2, 4] and y ∈ [3, 7]. Then x = 3 + ϵ and y = 5 + 2ϵj, and xy = 15 + 5ϵ + 6ϵj + 2ϵϵj. Choices are,
ϵϵj is replaced with a fresh noise symbol [5,6],
ϵϵj is replaced with [−1, 1]ϵ (or [−1, 1]ϵj), called Extended Affine Interval (EAI) [16], and
ϵϵj is pushed into the fixed error noise symbol ϵ±, denoted AF1 [11].
Either of treatments estimates that xy is in [2, 28], whereas CI results [6, 28]. We will use the last choice as default except for AF.



Fig. 1. Chebyshev approximation
Fig. 2. Chebyshev approximation of x2 and x |x|



We newly design Chebyshev Approximation Interval (CAI1, CAI2) and imple- ment Classical Interval (CI), Affine Intervals (AF, AF1, AF2) [11], and Chebyshe- vApproximation Intervals (CAI1, CAI2). Their forms are, e.g.,
n

AF1
xˆ = a0 + Σ aiϵi + an+1ϵ±
i=1

AF2
x¨ = a0 + Σ aiϵi + an+1ϵ+ + an+2ϵ− + an+3ϵ±
i=1

n	n
CAI1 ˚x = a¯0 + Σ a¯iϵi + Σ a¯i+nϵi+n + a¯2n+1ϵ±
i=1	i=1
where ϵ+ and ϵ− are interpreted as values in [0, 1] and [−1, 0] respectively, ϵ± is the error noise symbol interpreted as a value in [−1, 1] and ϵi+n represents the absolute value |ϵi| of ϵi. Ideas behind are,
introduction of noise symbols [5,6,11],
keeping products of noise symbols up to degree 2 (ϵiϵj) [11] (beyond degree 2, products are pushed into the error noise symbol ϵ±), and
Chebyshev approximation of x2 with noise symbols for absolute values.
(iii) comes from the observation that, for x ∈ [−1, 1],
|x|− 1 ≤ x2 = |x|2 ≤ |x| and x − 1 ≤ x|x|≤ x + 1
4	4	4
which are explained in Figure 2. This observation leads symbolic manipulation on products of the same noise symbol ϵ as
ϵϵ = |ϵ||ϵ| = |ϵ| + [− 1 , 0] and ϵ|ϵ| = ϵ + [− 1 , 1 ].
4	4 4
Remark 3.1 Introduction of Chebyshev approximation is not new. For instance, Stolfi [20] proposed it based on the mean-value theorem, as in the left of Figure 2. Miyajima et al. [13] applied not only for products of the same noise symbols but also those of different noise symbols. However, their estimation on x2 is only in the positive interval using the fact x − 1 ≤ x2 ≤ x for x ∈ [0, 1]. We newly introduce noise symbols for absolute values. The advantage is, coefficients are half compared to them, which reduce the effect of the offset [− 1 , 0]. Currently, we only focus on products of the same noise symbols, which is useful for computation like in Taylor expansion.
Roughly speaking, AF and AF1 apply (i) only, AF2 applies (i) and (ii) [12], CAI1 applies (i) and (iii), and CAI2 applies all. The definitions of CAI1 arithmetic are found in Appendix.
Example 3.2 Given ƒ = (x2 − 2y2 + 7)2 + (3x + y − 5)2 with x ∈ [−1, 1] and
y ∈ [−2, 0], the bounds of ƒ computed by AF1, AF2, CAI1 and CAI2 are as follows:
AF1 : [−98, 220]
AF2 : [−53, 191]
CAI1: [−4.6875, 163.25]
CAI2: [3.3125, 147.25]

Example 3.3 Given sin(x) = x − x3 + x5 − x7 + x9
			
with x ∈ [0, 0.523598], the

bounds of sin(x) are as follows:
3!	5!
7!	9!

AF1 : 10−6[−6290.49099241, 523927.832027]
AF2 : 10−6[−6188.00580507, 514955.797111]

CAI1: 10−6[−1591.61467700, 503782.471931]
CAI2: 10−6[−1591.61467700, 503782.471931]
In the example 3.2, CAI2 gives the best bound comparing with CAI1, AF2 and AF1 because it can keep information about ϵiϵj. The example 3.3 is Taylor expansion of sin(x). Bounds of sin(x) are estimated for x ranged from 0 to π . In this example, CAI1 and CAI2 give the same bound better than AF1 and AF2.
Testing
Testing is a popular methodology to find satisfiable instances. For real numbers, only finitely many instances can be tested, and we use it as an under-approximation theory. For a closed existential polynomial constraint
C = ∃x1 ∈ [l1, h1] ··· xk ∈ [lk, hk] .	ƒj(x1, ··· , xk) > 0
j
and finite set Θ of substitutions, we denote ▶test(Θ) C if	ƒj(θ(x1), ··· , θ(xk)) > 0
j
holds for some θ ∈ Θ with θ(x1) ∈ [l1, h1] ··· θ(xk) ∈ [lk, hk]. Then, ▶testΘ C implies
▶ C holds, but not vice versa. We say
C is Test SAT if ▶testΘ C and
C is Test UNSAT if btestΘ C.
Test UNSAT does not imply UNSAT, but we will use its information for com- puting leanrn clauses as heuristics.
There are two immediate strategies to generate random test cases.
Definition 4.1 For an interval [l, h] and k ≥ 1,
the k-random ticks are {c1, ··· , ck}, and
the k-periodic ticks are {c, c + Δ, ··· ,c + (k − 1)Δ},
where Δ = h−l , and c ∈ [l, l + Δ], ci ∈ [l + (i − 1)Δ,l + iΔ] are randomly generated (with i ∈ {1, ..., k}).
Reducing the number of unnecessary test cases is an important task to improve efficiency. For instance, if we consider 10 variables and each has 2 test cases, then we have 210 instances as a total. In solving that problem, we divides constraints into small groups (constraints in a group share some variables) and we compute satisfiable test cases for each group first.
SMT on polynomial inequality constraints
The main idea of our SMT solver is applications of two theories, IA (CI, AF1, AF2, CAI1, CAI2) for over-approximation and testing for under-approximation to sandwich the precise results. Although currently not implemented yet, we plan an automatic decomposition of input ranges to refine the detected results as in [17].
Fig 3 describes its design framework.



Fig. 3. Framework of SMT solver

Initial interval decomposition: An interval of a variable is split into small intervals, which are represented as disjunction. For instance, x ∈ [a, b] is repre- sented by x ∈ [a, a1] ∨x ∈ [a1, a2] ∨· · ·∨x ∈ [an, b] for a < a1 < a2 < ··· < an < b. After encoding x ∈ [ai, ai+1] and a polynomial ƒi(x1, ··· , xk) > 0 (initially, not appearing in CNF) by atomic propositions, we obtain a CNF, which is sent to SAT solver.
SAT solver: We use MiniSat2.2 as a backend SAT solver. The SAT solver finds a satisfiable combination of input ranges of all variables. A satisfiable (SAT) instance is sent to IA for checking. If the SAT solver returns unsatisfiability, we conclude unknown if testing is applied, otherwise we conclude UNSAT for the final result.
Interval Arithmetic (IA): We implement CI, AF1, AF2, CAI1 and CAI2 as IA. IA decides each polynomial ƒi(x1, ··· , xk) > 0 either IA VALID, IA UNSAT, or IA SAT, under given input ranges. If some of them are IA UNSAT, we return IA UNSAT and a negation of a combination computed by Learning analysis is added to the SAT solver as a learnt clause. If each of them is IA VALID, we have done. If some of them remain IA SAT, all IA SAT polynomials are sent to testing (still memorizing polynomials detected to be IA VALID).
Testing: In current implementation, 2-random ticks are generated for each vari- able to test a polynomial ƒi(x1, ··· , xk) > 0. If all polynomials are Test SAT for a test case, we have done. If it cannot find a successful test case, it returns Test UNSAT.



Fig. 4. Solver working on Example 5.1

Testing propagation: When testing of polynomials returns Test UNSAT, a negation of a combination of input ranges is computed and then it is added to CNF as a learnt clause. This is heuristics to narrow the search and intends to find other SAT instances for next evaluation.
The SMT solver will perform Dynamic interval decomposition to split in- put ranges into smaller ones, and refine the search. In current implementation, Dynamic interval decomposition is left to future work.
Example 5.1 Fig 4 describes how the SMT solver works on a polynomial constraint
∃x ∈ [−1, 4] y ∈ [−1, 4] . 4x + 3y − xy > 12. Its input format is
x = [-1,4] and y = [-1,4]
(assert (f = 4x + 3y -xy > 12))
First, by Initial interval decomposition, the input ranges [−1, 4] of variables x and y are split into 5 small input ranges. By IA, the red areas (x ∈ [−1, 2] and y ∈ [−1, 3]) are detected to be IA UNSAT. The remaining areas remain white, which means IA SAT. Then, testing is applied, for instance on x ∈ [3, 4] and y ∈ [1, 2], and fortunately finds a satisfiable instance with x = 3.33821 and y = 1.31143.
With Dynamic interval decomposition, for instance the area x ∈ [2, 3] and y ∈ [−1, 0] is split into quarters. By IA, two left quarters are detected to be IA UNSAT. Similarly, in the area x ∈ [3, 4] and y ∈ [3, 4], the right below quarter is detected to be IA VALID (light blue) by IA.

Preliminary experiment
In this section, we show preliminary results with the problem P1
∃x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10 ∈ [0, 3] x11 ∈ [−3, 4] x12 ∈ [−1, 3].
x1x3 − x1x3x7 > 0 ∧ x1x2 − x1x6 − x1x2x7 > 0 ∧ x1x3 − x3x5 > 0 ∧
x0 + x1x2 − x4 − x2x5 > 0 ∧ x8 − x2 + x10x9 − x10x3 > 0 ∧ x3x7 > 1 ∧

x6 + x2x7 > 0 ∧ x3 − 2x2 (1 + x2 ) − 2x12(x11 + x12)+ x12 − 6.5 > 0,
11	11	12
P2 (P2 is just changed the input of x11 from P1 into x11 ∈ [-3,2]) and 18 problems in the division QF NRA of SMT-LIB [1] benchmarks. We choose problems with up to 20 variables.
P1 was checked by AF1, AF2, CAI1 and CAI2, all of them give SAT results. For the problem P2, while AF1 and AF2 detect unknown, CAI1 and CAI2 detect UNSAT because CAI1 and CAI2 give better results for over - approximation than AF1 and AF2 in this problem. The Initial interval decomposition divides given ranges of variables into ranges with the width 1.
Division QF NRA of SMT-LIB benchmarks consists of a family zankl, which comes from termination analysis of term rewriting. All variables in problems are originally set a lower bound with ≥ 0. In this experiment, we set an upper bound for these variables and evaluate these problems with a range [0, 2.5]. The range [0, 2.5] is split into 5 ranges with the width 0.5.
We apply IA depending on the number of variables in a problem, e.g., CAI2 for
< 10, CAI1 for ≤ 15 (except the problem matrix-1-all-21) and AF1, AF2 for > 15, due to efficiency reason of preliminary implementation. Efficiency of CAI1 can be compared to AF1 and AF2, but CAI2 is much slower.
Table 1 includes 6 columns of the problem name, number of variables, number of constraints, type of interval arithmetic, result, and time in second.

Related work
There are several choices of theories among SMTs for polynomial constraints, e.g.,
QE-CAD (Quantifier Elimination by Cylindrical Algebraic Decomposition) [4],
interval arithmetic (as over approximation),
bounded binary encoding (as under approximation), and
reduction to linear constraints, e.g., bounded integer coefficients and CORDIC (COordinate Rotation DIgital Computer).
RAHD [18] separates case analysis and the core computation of QE-CAD origi- nated by Tarski. It applies different versions of QE-CAD implementations such as QEPCAD-B, Reduce/Redlog.
Interval arithmetic is an over-approximation, but sufficiently fine decomposition of input ranges will correctly find satisfiability of polynomial inequalities. Input range decomposition has proposed in RSOLVER [19] and implemented in RSOLVER
[19] and iSAT [8]. While RSOLVER develops a pruning algorithm to remove un- satisfied elements, iSAT applies a tight interaction of SAT solver and eager theory propagation. Thus, conflict detection and theory propagation are directly applied for SAT solver to provide new assignments. Our approach is combining testing (as under-approximation) with interval arithmetic. It will supply more opportunity to conclude satisfiability, furthermore it will guide more likely range decomposition. We also apply Chebyshev Affine Intervals, instead of using CI in RSOLVER and


Table 1
Experimental results with P1, P2 and QF NRA

iSAT.
MiniSmt [22] applies bundled bit encoding, which encodes non-linear arithmetic over rational numbers (i.e., pairs of integers) under given bounds, and reduced to SAT solving. To handle limited use of polynomial equality, it introduces the fixed number of algebraic numbers symbolically. MiniSmt can show satisfiability quickly, but due to the bound of the search, it cannot conclude unsatisfiability. CVC3 [2] is also a popular SMT, participating NRA category of SMT-LIB as well as MiniSmt. However, we could not find references that provide its technical details.
Barcelogic [3] assumes finite input ranges on integers, and reduces polynomial constraints to linear ones by instantiating one of arguments in multiplications with finitely many possible integers in bounded ranges. These linear constraints are solved by Yices (Presburger arithmetic over integers).
CORD [9] uses another reduction to linear constraints, called CORDIC (COordi- nate Rotation DIgital Computer), which translates a non-linear operation to linear forms by n iterative steps. One of two arguments of a multiplication is normalized to (−2, 2), then the multiplication is approximated by the sum of n positive/negative

shifters, in which the kth shifter corresponding to the half of the (k − 1)th shifter. Initially, the first shifter is set to the value of unnormalized argument. Each itera- tive step of a CORDIC translation is encoded as linear constraints, and some linear constraints are added to account for all inaccuracies in approximation of CORDIC. Finally, these linear constraints are solved by Yices (Presburger arithmetic over real numbers).

Conclusion and future work
This paper preliminarily reported an SMT for solving polynomial inequalities over real numbers. Our approach is a combination of interval arithmetic (over- approximation, aiming to decide unsatisfiability) and testing (under-approximation, aiming to decide satisfiability) to sandwich precise results. In addition to existing interval arithmetic, such as classical intervals and affine intervals, we newly designed Chebyshev Approximation Intervals.
Interval arithmetic can indicate unsatisﬁable areas (IA UNSAT) and remove these areas from search space. Testing only focus on areas that IA decides neither validity nor unsatisfiability. When testing cannot find a satisfiable instance in an area, heuristics is applied to make the solver not to search that area again. The re- sult of preliminary experiments on small examples including SMT-LIB benchmarks is encouraging. Our status is preliminary, and there is much future work to be undertaken.
Test data generation strategy: When the number of variables becomes large, the number of test cases to generate is a serious matter. Fortunately, interval arithmetic with noise symbols keeps sensitivity on variables. For instance, if an input range of xi is described by a noise symbol ϵi, the coefficient of ϵi in the result reflects strength of its influence. We can generate more test cases for such sensitive variables. This was proposed in [17] under the program analysis context and we hope to apply to our SMT.
Dynamic interval decomposition and refinement loop: In Figure 3, dynamic interval composition is connected with dotted lines, which means it is not yet im- plemented. Depending on interval arithmetic and testing results, we can focus on areas more likely to be unsatisfiable or contain satisfiable instances. For instance, even if ƒi(θ(x1), ··· , θ(xn)) fails to be positive, we can expect that θ would be nearer to satisfiable instances if ƒi(θ(x1), ··· , θ(xn)) is nearer to 0. If the result of interval arithmetic has smaller overlap with positive values, it is more likely to be unsatisfiable. This kind of refinement loop was proposed in [17] under the program analysis context and we hope to apply to our SMT.
Polynomial equality: Currently, we can handle polynomial inequalities only. How- ever, for instance
∃x1 ∈ [l1, h1] ··· xn ∈ [ln, hn].	ƒj(x1, ··· , xn) > 0 ∧ g(x1, ··· , xn)=0 
j
can be decomposed into two phases.	First, find some areas [l1k, h1k]  ⊆

[l1, h1] ··· [lnk, hnk] ⊆ [ln, hn] (by interval arithmetic) such that
∀x1 ∈ [l1k, h1k] ··· xn ∈ [lnk, hnk].	ƒj(x1, ··· , xn) > 0.
j
and find two instances (by testing) in that areas such that g(a1, ··· , an) > 0 and g(b1, ··· , bn) < 0. By Intermediate value theorem, we can conclude ∃x1 ∈ [l1, h1] ··· xn ∈ [ln, hn]. g(x1, ··· , xn)= 0.
Scalability and practical experiments: Scalability is very important in practice, and we expect the partial use of eager theory propagation will improve efficiency.
Acknowledgement
The authors would like to thank Nao Hirokawa and Harald Zankl for fruitful dis- cussions, and anonymous reviewers for their valuable comments. This research is partially supported by Grant-in-Aid for Scientific Research (B) No. 23300005 Mext, Japan.

References
Barrett, C., Aaron Stump, and Cesare Tinelli, The Satisfiability Modulo Theories Library (SMT-LIB), URL: http://www.smt-lib.org, 2010.
Barrett, C., and Cesare Tinelli, CVC3, “Proceedings of the 19th International Conference on Computer Aided Verification (CAV ’07),” Lecture Notes in Computer Science, Vol. 4590 (2007), Springer-Verlag, 298–302.
Borralleras, C., Salvador Lucas, Rafael Navarro-marset, Enric Rodriguez-carbonell and Albert Rubio, Solving Non-linear Polynomial Arithmetic via SAT Modulo Linear Arithmetic, “Proceedings of the 22nd International Conference on Automated Deduction CADE-22,” Lecture Notes in Computer
Science, Vol. 5663 (2009), Springer-Verlag, 294–305.
Caviness, B. F., Jeremy R. Johnson, “Quantifier Elimination and Cylindrical Algebraic Decomposition,” Springer-Verlag, 1998.
Comba, J. L. D., and Jorge Stolfi, Affine arithmetic and its applications to computer graphics, Proceedings of VI SIBGRAPI (1993), 9–18.
De Figueiredo, L., and Jorge Stolfi, “Self-Validated Numerical Methods and Applications,” Brazilian Mathematics Colloquium monographs, IMPA/CNPq, Brazil, 1997.
De Figueiredo, L., and Jorge Stolfi, Affine Arithmetic: Concepts and Applications, Numerical Algorithms, Vol. 37 (2004), 147–158.
Franzle, M., Christian Herde, Tino Teige, Stefan Ratschan and Tobias Schubert, Efficient solving of large non-linear arithmetic constraint systems with complex boolean structure, Journal on Satisfiability, Boolean Modeling and Computation, Vol. 1 (2007), 209–236.
Ganai, M., and Franjo Ivancic, Effcient decision procedure for non-linear arithmetic constraints using CORDIC, “Formal Methods in ComputerAided Design,” FMCAD 2009, 61-68.
Lucas, S. and Rafael Navarro Marset, Comparing CSP and SAT Solvers for Polynomial Constraints in Termination Provers, Electron. Notes Theor. Comput. Sci., Vol. 206 (2008), 75–90.
Messine, F., Extensions of affine arithmetic: Application to unconstrained global optimization, Journal of Universal Computer Science, Vol. 8 (2002), 992-1015.
Messine, F. and Ahmed Touhami, A General Reliable Quadratic Form: An Extension of Affine Arithmetic, Reliable Computing, Vol. 12 No. 3 (2006), 171-192.

Miyajima, S., Takatomi Miyata and Masahide Kashiwagi, A new dividing method in affine arithmetic, IEICE Transactions, Vol. E86-A No. 9 (2003), 2192–2196.
Moore, R. E., “Interval Analysis”, Prentice Hall, 1966.
Nieuwenhuis, R., Albert Oliveras and Cesare Tinelli, Abstract DPLL and abstract DPLL modulo theories, “Logic for Programming, Artificial Intelligence, and Reasoning, 11th International Conference LPAR04,” Lecture Notes in Computer Science, Vol. 3452 (2005), Springer, 36–50.

Ngoc, D., Mizuhito Ogawa, Overflow and Roundoff Error Analysis via Model Checking, “Proceedings of the 2009 Seventh IEEE International Conference on Software Engineering,” SEFM 2009, IEEE Computer Society, 105–114.
Ngoc, D., Mizuhito Ogawa, Checking Roundoff Errors using Counterexample-Guided Narrowing, “Proceedings of the IEEE/ACM international conference on Automated software engineering,” ASE 2010, ACM, 301–304.
Passmore, G. O., Paul B. Jackson, Combined Decision Techniques for the Existential Theory of the Reals, “Proceedings of the 16th Symposium, 8th International Conference. Held as Part of CICM ’09 on Intelligent Computer Mathematics,” Calculemus ’09/MKM ’09, Springer-Verlag, 122–137.
Ratschan, S., Effcient solving of quantified inequality constraints over the real numbers, ACM Trans. Comput. Logic, Vol. 7 No. 4 (2006), 723-748.

Stolfi, J., “Self-Validated Numerical Methods and Applications,” Ph. D. Dissertation, Computer Science Department, Stanford University, 1997.
Tarski, A., A decision method for elementary algebra and geometry, University of California Press, 1951.
Zankl, H., and Aart Middeldorp, Satisfiability of non-linear (Ir)rational arithmetic, “Proceedings of the 16th international conference on Logic for programming, artificial intelligence, and reasoning,” LPAR’10 (2010), Springer-Verlag, 481–500.

Appendix
Definition of CAF1	Given ˚x, ˚y are represented by CAI1 form:
n	n
˚x = a¯0 + Σ a¯iϵi + Σ a¯i+nϵi+n + a¯2n+1ϵ±

i=1
n
i=1
n

˚y = ¯b0 + Σ ¯biϵi + Σ ¯bi+nϵi+n + ¯b2n+1ϵ±
i=1	i=1
and c¯ = [−1, 1]. Standard operations {+˚, −˚, ×˚} of CAI1 arithmetic are defined as
follows (for simplicity we denote a¯¯b for a¯×¯ ¯b):
2n
˚x+˚˚y = (a¯0+¯ ¯b0)+	(a¯i+¯ ¯bi)ϵi + (c¯a¯2n+1+¯ c¯¯b2n+1)ϵ±
i=1 2n
˚x−˚˚y = (a¯0−¯ ¯b0)+	(a¯i−¯ ¯bi)ϵi + (c¯a¯2n+1+¯ c¯¯b2n+1)ϵ±
i=1
˚x×˚˚y = K0 + Σ(a¯0¯bi+¯ a¯i¯b0+¯ a¯i¯bi+n+¯ a¯i+n¯bi)ϵi
i=1
+¯ Σ(a¯0¯bi+n+¯ a¯i+n¯b0+¯ a¯i¯bi+¯ a¯i+n¯bi+n)ϵi+n + Kϵ±,
i=1
where {+¯ , −¯ , ×¯ } are CI arithmetic, and
n

· K = a¯ ¯b +¯ Σ(a¯ ¯b [− 1 , 0]+¯ a¯ ¯b	[− 1 1 ¯¯	[− 1 1 ¯
¯b	[− , 0])

0	0 0
i i	4
i=1
i i+n
4 , 4 ]+bia¯i+n
4 , 4 ]+a¯i+n
i+n	4

· K = (c¯a¯0¯b2n+1+¯ c¯¯b0a¯2n+1)+¯ Σ Σ
c¯a¯i¯bj+¯ Σ Σ c¯¯ai¯bj+n+¯ Σ c¯¯ai¯b2n+1

i=1 j=1,j/=i
i=1 j=1,j/=i
i=1

+¯ Σ Σ c¯¯ai+n¯bj+¯ Σ Σ
c¯a¯i+n¯bj+n+¯ Σ c¯a¯i+n¯b2n+1 +c¯a¯2n+1¯b2n+1

i=1 j=1,j/=i
i=1 j=1,j/=i
i=1

Note that ϵ± is propagated from unknown sources, then its coefficient is propa- gated by applying multiplication other coefficients with c¯ = [−1, 1].
