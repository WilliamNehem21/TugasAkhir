	Electronic Notes in Theoretical Computer Science 96 (2004) 51–72	
www.elsevier.com/locate/entcs




Adjuncts elimination in the static ambient logic

E´ tienne LOZES1
LIP, ENS Lyon – France


Abstract
The Ambient Logic (AL) has been proposed for expressing spatial properties of processes of the Mobile Am- bient calculus (MA). Restricting both the calculus and the logic to their static part yields static ambients (SA) and the static ambient logic (SAL), that form a model for queries about semistructured data. SAL also includes the non-standard fresh quantifier (I).
This work adresses the questions of expressiveness and minimality of SAL from the point of view of adjuncts. We define the intensional fragment of the logic (SALint), the logic without adjuncts, and prove that it captures all the expressiveness of the logic.
We moreover study the question of adjuncts elimination in SAL∀, where I quantifier is replaced by the classical
∀ quantifier. We conclude with a proof of the minimality of SALint.
Keywords: Spatial logics, Mobile Ambients, Minimality, Fresh quantifier.



Introduction
The Mobile Ambients calculus (MA) [5] is a proposal for a new paradigm in the field of concurrency models. Its originality is to set as data the notion of loca- tion, and as notion of computation the reconfiguration of the hierarchy of locations. The calculus has a spatial part expressing the topology of locations as a labelled unordered tree with binders, and a dynamic part describing the evolution of this topology. The basic connectives for the spatial part are 0, defining the empty tree, a[P], defining the tree rooted at a with subtree P, P | Q for the tree consisting of

1 Email: elozes@ens-lyon.fr


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.04.021

the two subtrees P and Q in parallel, and (νn)P for the tree P in which the label (or name) n has been hidden.
Type systems are commonly used to express basic requirements on programs. In the case of MA processes, the Ambient Logic (AL) [6] provides a very flexible descriptive framework. Seeing AL as a type system, one may ask a process P to match some specification R, written
P |= R .

The AL approach is however much more intensional than is the case for standard type systems. Indeed, the whole spatial structure of the calculus is reflected in the logic. For instance, the formula n[R] is satisfied by processes of the form n[P] with P |= R. AL also handles the dynamics of computation through the usual O modality. Finally, AL includes adjunct connectives for every spatial construct. For instance, the guarantee operator
R  B
specifies that a process is able to satisfy B whenenever it is put in parallel with any process satisfying R. This connective gives a functional flavour to the logic, in the sense that the formulas may then describe a service offered by the process they refer to. It has been shown that adjuncts, together with the O connective, allow one to express some very intensional properties, and in fact to capture all constructs of the calculus [14,13].
Leaving out from MA all capabilities, we get rid of the dynamics of the cal- culus, working with what we call static ambients, SA. The logic may then be restricted to its spatial part by forgetting the O connective; we call it the static ambient logic, SAL.
SA, associated to SAL, has appeared to be an interesting model for semistruc- tured data [4]. Datas are modeled by unordered labelled trees, where the binders may represent pointers [3], and the logic is used as the basis for a language for queries involving such data. For instance, the process

(νptr)(Cardelli[Ambients[ptr[text[0]]]] | Gordon[Ambients[ptr[0]]])

represents a database containing the two authors Cardelli and Gordon with one copy of their paper about Ambients stored at Cardelli’s and linked to Gordon’s. Query
Iptr. ptr® (Cardelli[т] | т)
asks whether the database contains some author named Cardelli.
Here In. R is the fresh quantification [11]. Intuitively, its meaning is “for almost all names n, R is true”. This quantification is related to α conversion of

bound names. It is complementary to the spatial connective n®R that forces the process to reveal a hidden name by calling it n.
There may be several ways to answer the question “what is SAL able to tell about data”? A first answer can be to study the separability of the logic, that is how far the logic can go into distinguishing between two datas. This is usually achieved by characterising the logical equivalence, that is the relation =L, relating datas that satisfy the same formulas. A more refined answer is to characterise completely the set of queries that can be formulated, what we call the expressiveness of the logic. For this, one may like to compare the formalism at hand with another, standard, logic, or to state equivalences in terms of other models for data analysis, such as automata.
The next question is then “what is really needed both to separate datas and express properties?” For instance, in the case of classical propositionnal logic, the nand connective is known to generate all the expressive power. In SAL, the intensional connectives surely bring some expressiveness. For the adjunct connec- tives, the situation is less clear. Some formulas clearly make an unefficient use of ajduncts; for instance, the formula n[0] n[0] is equivalent to the adjunct-free for- mula 0. However, the model-cheking problem for SAL is known to be undecidable [12], whereas it is decidable for SALint, the fragment without adjuncts. This sug- gests that adjuncts may express non trivial properties, beyond the expressive power of SALint.
This paper studies the question of adjunct elimination in SAL in relation with the nature of the quantification on formulas. The main contribution is to establish the adjunct elimination in SAL equipped with fresh quantification (Theorem 5.4), namely we prove SAL and SALint to be equally expressive. This shows that the adjuncts do not improve the expressiveness of the logic. In particular, the guarantee operator R B does not bring extra expressive power.
This result is derived in two steps. We first establish it for the quantifier-free formulas (Theorem 4.4), and then extend it to fresh-quantified formulas based on the use of prenex forms (Proposition 5.3). To establish adjunct elimination on quantifier-free formulas, we first define a notion of intensional bisimilarity, along the lines of [14], in which we bound the number of test steps. Then, two properties justify the encoding: a property we call precompactness, which expresses finite- ness of behaviours, and the existence of characteristic formulas for the classes of bounded intensional bisimilarities.
We conclude with two strongly related contributions. First, we prove the ab- sence of adjunct elimination for SAL∀, that is SAL equipped with classical quan- tification (Theorem 6.1). Then we establish that SALint is minimal (Theorem 7.1), in the sense that any subfragment of SALint is stricly less expressive.

Related work.
Apart from [10], this is, to our knowledge, the first result delimiting precisely the expressiveness of a spatial logic. Other works about expressiveness only give some hints. A first result about the separation power of AL is presented in [14]. Other examples of expressive formulas for AL are shown in [13], such as formulas for persistence and finiteness.
A compilation result has been derived for a spatial logic for trees without quan- tification and private names [10]. In that work, the target logic includes some new features such as Presburger arithmetic, and the source logic includes a form of Kleene star.
In the present work, the target logic is a sublogic of the original logic. In this sense, we also address for the first time minimality of a spatial logic, that is the indenpence of its connectives.
The setting in which we obtain our encoding is rather different in the dynamic case (see [13]). There, the presence of adjuncts considerably increases the ex- pressive power of the logic. For instance, allows one to construct formulas to characterise processes of the form open n. P, and, using the @ connective, we may define a formula to capture processes of the form out n. P.
The use of a bounded intensional bisimilarity and the notion of precompactness is original. Intensional bisimilarity plays an important role in the characterisation of the separation power of the logic [14]. Our proof suggests that it is also a powerful and meaningful concept for the study of expressiveness.
The presence of the connective in the logic is crucial with respect to decid- ability issues. The undecidability of the model-checking of SAL with classical quantification has been established in [9]. Quite unexpected decidability results for spatial logics with and without quantification were then established in [2] and [8]. [8] is closely related to the present study; roughly, the decidability result of [8] relies on finiteness of processes, whereas our encoding exploits finiteness of obser- vations. Most recently, the undecidability of the model-checking problem for SAL has been established [12]. This last work studies many variations around SAL, de- rives decidability results with and I, and presents a prenex form result similar to ours.
We introduce SA and the logics we use to reason about data in Sec. 2. We prove adjunct elimination for quantifier-free formulas in Sec. 4, based on the notion of intensional bisimilarity, discussed in Sec. 3. The general result for SAL is then established in Sec. 5, based on prenex forms. We discuss the adjunct elimination for SAL∀ in Sec. 6, and show minimality of SALint in Sec. 7; Sec. 8 gives concluding remarks.

Background
In all what follows we assume an infinite set W of names, ranged over by n, m. Tree terms are defined by the following grammar:

P ::=  P | P | n[P] | (νn)P | 0. 
The set fn(P) c W of free names of P is defined by saying that ν is the only binder on trees. We call static ambients tree terms quotiented by the smallest congruence
≡ (called structural congruence) such that:

P | 0 ≡ P	(νn) 0 ≡ 0
(P | Q) | R ≡ P | (Q | R)	(νn) m[P] ≡ m[(νn)P]	(n ≠ m)
P | Q ≡ Q | P	(νn)P | Q ≡ (νn)(P | Q) (n g fn(Q)) Formulas, ranged over with R, B,.. ., are described by the following grammar:
R ::= R∧ R | ¬ R | In. R | 0 | R | R | n[R] | n®R
| R  R |R@n | R o n

These formulas form the static ambient logic, and we call intensional fragment the subset of the formulas not using the connectives , @, and o (ajduncts). We note them respectively SAL and SALint.
We will say that R is quantifier-free if R does not contain any I quantification. The set of free names of a formula R, written fn(R) is the set of names appearing in R that are not bound by a I quantification. R(n — nj) is the formula R in which names n and nj are swapped.
Definition 2.1 (Satisfaction) We define the relation |= c (SA × SAL) by induction on the formula as follows:
P |= R1 ∧ R2 if P |= R1 and P |= R2
P |= ¬R if P |= R
P |= In. R if ∀nj e W – (fn(P) ∪ fn(R)), P |= R(n — nj)
P |= R1 | R2 if there is P1, P2 s.t. P ≡ P1 | P2 and Pi |= Ri for i = 1, 2
P |= 0 if P ≡ 0
P |= n[R] if there is Pj such that P ≡ n[Pj] and Pj |= R
P |= n®R if there is Pj such that P ≡ (νn)Pj and Pj |= R
P |= R1  R2 if for all Q such that Q |= R1, P | Q |= R2

P |= R@n if n[P] |= R
P |= R o n if (νn)P |= R
We note R cs B if for all P e S A, P |= R iff P |= B. A context is a formula con- taining a hole; if C is a context, C[R] stands for the formula obtained by replacing the hole with R in C. The following property stresses a first difference between SAL and the ∀/E version of the logic:
Lemma 2.2 For all R, B, and all context C, if R cs B, then C[R] cs C[B].
Remark 2.3
The formula ±, that no process satisfies, can be defined as 0∧¬ 0. As e.g. in [6], other derived connectors include v, and ►: P satisfies R ► B iff there exists Q satisfying R such that P | Q satisfies B.
If P |= R and P ≡ Q, then Q |= R. Moreover, |= is equivariant, that is P |= R iff
P(n — nj) |= R(n — nj) for any n, nj.
For any P, there is a characteristic formula (for ≡) RP, using the same tree rep- resentation, such that for all Q, Q |= RP iff Q ≡ P. In particular, two static ambients are logically equivalent if and only if they are structurally congruent.

Intensional bisimilarity
In this section, we define a notion of partial observation over trees corresponding to logical testing with a bound on the formulas’ size and on free names. This notion is an incremental version of the intensional bisimilarity presented in [14]. We then derive two key results:
the congruence of the intensional bisimilarity, which roughly says that SALint is as separative as SAL; as an important consequence, the bisimilarity is proved to be correct with respect to logical equivalence.
a construction of symbolic sets that represent the classes of bisimilarity by col- lecting all the necessary information, which will be used in the proofs of the next section.
We assume in the remainder some fixed set N c W.

Definition
We now introduce the intensional bisimilarity. Intuitively, ≈i,N equates processes that may not be distinguished by logical tests involving at most i steps where the names used for the tests are picked in N.

Definition 3.1 (Intensional bisimilarity) We define the family (≈i,N)ieN of symmet- ric relations over SA by induction on i: ≈0 d=ef SA × SA, and for any i ≥ 1, ≈  is the greatest relation such that if P ≈i,N Q, then the following conditions hold:
if P ≡ 0 then Q ≡ 0
for all P1, P2, if P ≡ P1 | P2 then there is Q1, Q2 such that Q ≡ Q1 | Q2 with Ps ≈i–1,N Qs , s = 1, 2.
for all n e N and for all Pj, if P ≡ n[Pj], then there is Qj such that Q ≡ n[Qj] and Pj ≈i–1,N Qj.
for all n e N and for all Pj, ifP ≡ (νn)Pj, then there is Qj such that Q ≡ (νn)Qj
and Pj ≈i–1,N Qj.

Lemma 3.2 For all i, ≈i,N is an equivalence relation.
We shall write SA/≈i,N for the quotient of SA induced by ≈i,N, and range over equivalence classes with C, C1, C2.
We may observe that the bisimilarities define a stratification of observations on terms, namely ≈ij,Nj ⊆ ≈i,N for i ≤ i and N ⊆ N . This may be understood in a topological setting. Given a fixed N, we consider the ultrametric distance over
models defined by d(P, Q) = 2–i if i is the smallest natural for which P /≈i,N Q, and d(P, Q) = 0 if P ≈ω,N Q where ≈ω,N= ieN ≈i,N. We call it the N-topology. It somehow captures the granularity of the logical observations with respect to their
cost.

Correction
The key step in proving correction of the intensional bisimilarities with respect to the logic is their congruence properties for the connectives admittting an adjunct.
Lemma 3.3 If P ≈i,N Q, then:
for all R, P | R ≈i,N Q | R;
for all n e W , n[P] ≈i,N n[Q];
for all n e N, (νn)P ≈i,N (νn)Q.
Proof. By induction on i.	□
Note that the last point cannot be improved: consider N = {n}, P ≡ m1[0], Q ≡ m2[0]. Then P ≈2,N Q, but (νm1)P /≈2,N (νm1)Q. For this reason, ≈i,N is not a pure congruence.
We note s(R) the size of R, defined as the number of its connectives.

Proposition 3.4 (Correction) For all P, Q, i such that P ≈i,N Q, for all quantifier free formula R such that s(R) ≤ i and fn(R) ⊆ N,

P |= R	iff	Q |= R.

Proof. By induction on R. For the adjuncts, apply the congruence properties of Lemma 3.3, and for the other connectives use the definition of ≈i,N.	□

Signature functions
Definition 3.5 (Signature) For i ≥ 1, we set:
zN(P) = 0 if P ≡ 0, otherwise ¬ 0
pN(P) = {(C1, C2) e (SA/≈	)2 : P ≡ P1 | P2 and Pi e Ci}
i	i–1,N
aN(P) = [n, C] if there is Pj s.t. P ≡ n[Pj], n e N and P e C, C e SA/≈	,

i
otherwise aN(P) = noobs, where noobs is a special constant.
i–1,N

rN(P) = {(n, C) e N × SA/≈
: EPj. P ≡ (νn)Pj and Pj e C}

i	i–1,N
We call signature of P at (i, N) the quadruplet χN(P) = [zN(P), pN(P), aN(P), rN(P)].
i	i	i	i	i
The following lemma says that the signature actually collects all the information that may be obtained from the bisimilarity tests.
Lemma 3.6 Assume i ≥ 1. Then P ≈i,N Q iff χN(P) = χN(Q).
i	i

Adjuncts elimination on quantifier-free formulas
In this section, we show that the quantifier free formulas of SAL have equivalent formulas in SALint. This result is then extended to all formulas of SAL in the next section.
In all what follows, we will assume N is a finite subset of W; it is intended to bound the free names of the considered formulas. The encoding result is based on two key properties:
Precompactness of the N-topology. In other words, when i, N are fixed, only a finite number of scenari may be observed.
Existence of intensional characteristic formulas for the classes of ≈i,N.
Lemma 4.1 The codomain of χN is finite.
Proof. We reason by induction on i. First notice that the codomain of χN is:


codom χN
=  {0, ¬ 0} × (SA/≈i–1,N
)2 × ({noobs}+ N ×SA/≈
) × k(N ×SA/≈i–1,N )

hence codom χN is finite iff SA/≈
is finite too (here we use that N is finite). For

i	i–1,N
i = 1, SA/≈	= {SA}, hence χN is finite, and so is codom χN. For i ≥ 2, we have by
0,N	0	1

induction codom χN  finite. By Lemma 3.6, there is an injection of SA/≈
i–1,N
into

codom χN
, so SA/≈i–1,N
is finite, and so is codom χN.	□

Here is an immediate consequence of Lemma 4.1:
Proposition 4.2 (Precompactness) For all i, the number of classes of ≈i,N is finite.
These results roughly say that there is only a finite amount of information is needed to capture a given bisimilarity class. The next result makes it more precise: this information may be collected in a single formula of SALint.
Proposition 4.3 (Characteristic formulas) For any i e N and for any process P, there is a formula Ri,N e SALint such that
∀Q	Q |= Ri,N	e	Q ≈i,N P .

Proof. By induction on i. For i = 0, we may take Ri,N = т. Then assume i ≥ 1,
P
and we have formulas Ri–1,N
P	for all P. This obviously gives a characteristic formula
Ri–1,N for any class C of SA/≈	. Let us consider some fixed P. We set
C	i–1,N


Rz = 0 if zN(P) = 0, otherwise ¬ 0

Rp =  (C
i–1,N	i–1,N
C )epN (P)
∧ ¬  (C
i–1,N	i–1,N
C )gpN (P)

Ra = 	i
 n[Ri–1,N]	if aN(P) = [n, C]
Rr =  [n C]erN (P) n®Ri–1,N ∧ ¬  [n C]grN (P) n®Ri–1,N
Ri,N = Rz ∧ Rp ∧ Ra ∧ Rr
where the finiteness of the conjunctions and disjunctions is ensured by Lemma 4.1. Then Q |= Ri,N iff χN(Q) = χN(P), hence the result.	□
P	i	i
The precompactness property says that if we bound the granularity of the ob- servations, only finitely many distinct situations may occur. The characteristic for- mula property says that each of these situations is expressible in the intensional fragment. The idea of the encoding is then just to logically enumerate all these possible situations.
Theorem 4.4 For all quantifier-free formula R e SAL, there is a formula [R] e
SALint such that
R  cs  [ R ].

Proof. We define [R] as follows:

[ R ] d=ef

  Ri,N

for C e SA



/≈i,N

, C |= R

for i = s(R) and N = fn(R). The disjunction is finite by Proposition 4.2. P |= [ R ] iff there is Q such that Q |= R and P ≈i,N Q, that is, by Proposition 3.4, P |= R. □

Effectiveness of the encoding:
Due to its finiteness, the construction of our proof could seem to be effective. How- ever, this cannot be the case due to an undecidability result for the model-checking problem on SAL [12]. This is quite surprising, since only an effective enumeration of the bisimilarity classes is missing to make the proof constructive. Moreover, such an enumeration exists for SA without name restriction, via testing sets as de- fined in [8]. This reveals an unexpected richness of SA compared to pure trees.

Adjuncts elimination and fresh quantifier
In this section we establish the adjunct elimination for the full SAL. The essential result that entails this extension is the existence of prenex forms for the fresh quan- tifier. Intuitively, the fresh quantifier may “float” on the formula without changing its meaning.
Proposition 5.1 (Correction of ~) The term rewriting system ~ defined by the rules of Fig. 1 preserves the semantics: for any R, B e SAL, if R ~ B, then R cs B.

Proof. (sketched) We only detail the proof for rule ( L).

P |= (In. R1)  R2
e ∀Q, ∀nj g fn(R1) ∪ fn(Q). Q |= R1(n — nj) → P | Q |= R2
e ∀Q, ∀nj g fn(R1  R2) ∪ fn(P | Q). Q |= R1(n — nj) → P | Q |= R2
e ∀Q, ∀nj g fn(R1  R2) ∪ fn(P | Q). Q |= R1(n — nj) → P | Q |= R2(n — nj)
e ∀nj g fn(R1  R2) ∪ fn(P),
∀Q. nj g fn(Q) → Q |= R1(n — nj) → P | Q |= R2(n — nj)
e P |= In. (R1 ∧ n®т)  R2
□



Remark 5.2 Some of the rules above (such as (Amb), (¬ ), and a variant of (| L)) have already been presented in [7], under the form of equalities. The same result is independently developped in [12].
We say that a formula R is wellformed if every variable bound by I is dis- tinct from all other (bound and free) variables in R. For such formulas, the side conditions in ~ are always satisfied.
It is easy to see that ~ defines a terminating rewriting system, and that the normal forms of wellformed formulas are formulas in prenex form. Confluence holds modulo permutation of consecutive I quantifiers.
Proposition 5.3 (Prenex forms) For any formula R, there are n˜, Rj such that R cs
In˜. Rj and Rj is quantifier free.
This result directly implies the following extension of Theorem 4.4:
Theorem 5.4 (Adjunct elimination) For any formula R e SAL, there is a for- mula [R] e SALint such that
R  cs  [ R ].
Proof. There is Rj quantifier free and n˜ such that R cs In˜. Rj by Proposition 5.3. Then by Lemma 2.2 and Theorem 4.4, we may write
R cs In˜. Rj cs In˜. [Rj]. 
□

Example 5.5 : We show an example to illustrate how SALint formulas can capture non trivial properties expressed using the adjuncts. Let
R  ::=	 Hmj. mj[т] ► (Hn1. n1[0] | Hn2. n2[Hn3. n3[0]]) o m@m
where Hn. R (H being the hidden name quantifier [1]) stands for In. n®R. The prenex form of R is
Imj, n1, n2, n3.   (mj®т∧. mj®mj[т]) ► (n1®n1[0] | n2®n2[n3®. n3[0]])  o m@m
Then P |= R iff there is Q such that
(νm) m[P] | (νmj) mj[Q]  ≡  (νn1)(νn2)(νn3)(n1[0] | n2[n3[0]])
The only solutions of this equation are P ≡ 0 or P ≡ (νn3)n3[0]. In other words, R
is equivalent to B = 0 v Hn3. n3[0].

Adjuncts elimination and classical quantifiers
In this section we consider a variant of SAL. Instead of fresh quantified formu- las, we consider name quantification of the form ∀x. R and Ex. R with the natural semantics:
P |= ∀x. R	if	∀n e W. P |= R{n/x}
Let us note SALint the intensional fragment with classical quantification. We ask the question of adjuncts elimination for extensions of this logic. The unde- cidability result of [9] implies that there is no effective adjunct elimination for SALint + { }. We establish now a more precise result:
∀	∀	∀
Theorem 6.1 (Expressiveness of adjuncts in SALint) SALint + { }, SALint + {@}
∀	∀
and SALint + {o} are strictly more expressive than SALint.
The proof of this theorem is based on the following observation. In any of the extensions we consider, it is possible to define a formula R such that
(1)	P |= R	iff	 fn(P) ≤ 1
For the  and @ connectives, we may first encode the formula n = m as (n[т] ∧
¬ m[т]) ± and (n[т])@m. Then (1) is satisfied by the formula
Ex. ∀y. (¬ y®т) → x = y
For the o connective, there is a direct formula satisfying (1):
Ex. ( ∀y. y®т) o x



However, SALint cannot bound the number of free names of its model. More precisely:
Proposition 6.2 There is no formula in SALint that satisfies (1).
The proof of this proposition is quite technical and is given in appendix.

Minimality
In this section, we show minimality w.r.t. expressive power of SALint. Our result follows from several technical lemmas that are given in appendix.
Theorem 7.1 (Minimality) SALint is a minimal logic, that is all fragments of SALint
are less expressive.
Proof (Sketch) We show that for each connective κ, the logic resulting from the removal of κ is stricly less expressive than SALint. We give an idea of the argument in each case.
κ = ∧: then we may not express n1[n2[0]] v n2[n1[0]].
κ = ¬ : then we may not express ¬ n®т, saying that n occurs free. To prove this, we remark that for a formula R without negation, there is a height h such that for all P, if P |= R then so does the truncation of P at height h, so we may find a contradiction by considering a process having a occurrence of n deep enough.
κ = I: then we may not express In. n®¬ n®т: P is a model of this formula iff there are n, Pj s.t. P ≡ (νn)Pj with n e fn(Pj). For N = {n1,... nr} we consider PN = n[n1[0] | ... | nr[0]] for some n g N. Then for any quantifier free formula R with fn(R) ⊆ N, P |= R iff (νn)P |= R.
κ = 0: here we assume we take т instead of 0 as a primitive formula. Then 0 is not expressible. For this, we remark that for any R without 0 and for n g fn(A), 0 |= R iff n[0] |= R.
κ =. |.: the separation power is different. For instance, we may not distinguish
n[0] | n[0] from n[0] | n[0] | n[0].
κ = n[. ]: we may not distinguish n1[n2[0]] from n2[n1[0]].
κ = n®.: we may not distinguish (νn)n[0] and (νn)n[n[0]].
□
Remark 7.2
In the proof above, the cases involving the intensional connectives . |. , n[. ] and n®. are treated by showing that the separation power of the logic is reduced. This entails a loss in terms of expressiveness, since equally expressive logics have the same separation power.

SALint is minimal in terms of expressiveness, but as far as separation power is concerned, the minimal fragment is SALint – {I, ¬ , ∧, 0}, since for this fragment logical equivalence coincides with intensional bisimilarity.
Notice that we do not show that SALint is the unique minimal fragment of SAL. This is far from being obvious. For instance, the fragment SAL – {∧} is surpris- ingly quite expressive, as the formula

¬ In. n®¬ n® (Im1. m1®Im2. m2®m1[m2[0]]) o n1 o n2

shows. This formula is equivalent to n1[n2[0]] v n2[n1[0]], and hence the case κ = ∧ in the proof of Theorem 7.1 does not apply here. We do not know the exact expressiveness of this fragment, one could think that it captures any finite set of processes. The interested reader may want to look for a formula for n1[0] v n2[n2[0]] in this fragment.


Conclusion
We have established the adjuncts elimination property for SAL, a logic for trees with binders including the fresh quantifier I. This involves putting a formula in prenex form and then doing the transformation on the quantifier-free formula. The adjunct-free fragment SALint turns then to be a minimal logic.
We established the absence of adjunct elimination for the same logic where I is replaced by the usual ∀ quantifier, whichever adjunct is considered. This result, together with the difference w.r.t. decidability of model-checking on pure trees, illustrates the significant gap existing between the two forms of quantification.
We believe that adjuncts elimination is not really specific to SAL but can be derived following the same ideas for other intensional logics with adjuncts.


Acknowledgement
This work has been supported by the european FET - Global Computing project
Poudis, and by the Action Incitative Me´thodes Formelles pour la Mobilite´ - CNRS.
I would like to thank M.J. Gabbay for enlightening discussions about Nominal Sets theory. The anonymous referees and G. Ghelli helped me significantly to improve the first version of this presentation. I also want to thank D. Sangiorgi, L. Monteiro, L. Caires, and D. Hirschkoff for their advice all along this work.

References
L. Caires and L. Cardelli. A Spatial Logic for Concurrency (Part I). In Proc. of TACS’01, LNCS. Springer Verlag, 2001.
C. Calcagno, H. Yang, and P. O’Hearn. Computability and Complexity Results for a Spatial Assertion Language for Data Structures. In Proceedings of FSTTCS ’01, volume 2245 of LNCS. Springer Verlag, 2001.
L. Cardelli, P. Gardner, and G. Ghelli. Manipulating trees with hidden labels. In Foundations of Software Science and Computational Structures, 6th International Conference, FOSSACS 2003, LNCS 2620, pages 216–232. Springer, 2003.
L. Cardelli and G. Ghelli. A Query Language Based on the Ambient Logic. In Proc. of ESOP’01, volume 2028 of LNCS, pages 1–22. Springer Verlag, 2001. invited paper.
L. Cardelli and A. Gordon. Mobile Ambients. In Proc. of FOSSACS’98, volume 1378 of LNCS, pages 140–155. Springer Verlag, 1998.
L. Cardelli and A. Gordon. Anytime, Anywhere, Modal Logics for Mobile Ambients. In Proc. of POPL’00, pages 365–377. ACM Press, 2000.
L. Cardelli and A. Gordon. Logical Properties of Name Restriction. In Proc. of TLCA’01, volume 2044 of LNCS. Springer Verlag, 2001.
C.Calcagno, L. Cardelli, and A. Gordon. Deciding Validity in a Spatial Logic for Trees. In Proc. of TLDI’03, pages 62–73. ACM, 2003.
W. Charatonik and J-M. Talbot. The Decidability of Model Checking Mobile Ambients. In Proc. of CSL’01, LNCS. Springer LNCS, 2001.
S. Dal-Zilio and C. Meyssonnier. A Logic You Can Count On. In preparation, 2003.
M. J. Gabbay and A. M. Pitts. A new approach to abstract syntax involving binders. In 14th Annual Symposium on Logic in Computer Science, pages 214–224. IEEE Computer Society Press, Washington, 1999.
G. Ghelli and G. Conforti. Decidability of freshness, undecidability of revelation. Technical Report TR 03 -11, Universita` di Pisa, 2003.
D. Hirschkoff, E. Lozes, and D. Sangiorgi. Separability, Expressiveness and Decidability in the Ambients Logic. In 17th IEEE Symposium on Logic in Computer Science, pages 423–432. IEEE Computer Society, 2002.
D. Sangiorgi. Extensionality and Intensionality of the Ambient Logic. In Proc. of 28th POPL, pages 4–17. ACM Press, 2001.

Proof of Proposition 6.2 (∀ quantifier)
In this section, we establish Proposition 6.2 that is used for the proof of Theo- rem 6.1. It follows from Lemma A.2, that itself depends on Lemma A.1. Roughly speaking, the aim of this section is to find some sufficient conditions so that substi- tutions can be applied both on the side of the formula and on the side of the process while keeping satisfaction.
We call thread context a context C of the form
C[ P ] ≡ (νn˜) n1[... nk[ P ] .. .]
with n˜ ⊆ {n ,... , n }. We note n(C) d=ef {n ,... , n } and d(C) d=ef k. For a formula R, we note d(R) the number of n[. ] connectives in R.

Lemma A.1 Let R be a formula of SALint , and C a thread context such that d(C) >
d(R). Let n, m be two names such that {n, m}∩ n(C) = ∅, and



Then P |= R iff P |= R{n/m}.

P d=ef
C[ n[0] | m[0]] 

Proof. By induction on the size of R:
the cases R = R1 ∧ R2, R = ¬ R1, and R = 0 are trivial.
R = R1 | R2. Assume first P |= R. Since d(C) ≥ 1, we may assume by symmetry that 0 |= R2 and P |= R1. Then P |= R1{n/m} by induction, and P |= R{n/m}. The other direction is proved similarly.
R = a[R1]. Assume first P |= R. Then C ≡ a[Cj] and Pj d=ef Cj[n[0] | m[0]] |= R1. By induction Pj |= R1{n/m}. Since {n, m} ∩ n(C), a ≠ m, so R{n/m} = a[R1{n/m}], and P |= R{n/m}.
Assume now P |= R{n/m}. Let b = a{n/m}. Then C ≡ b[Cj] and Pj d=ef Cj[n[0] |
m[0]] |= R1{n/m}. Then b e n(C), so b g {m, n}, and b = a. By induction
Pj |= R1, so P |= b[R1] = R.
R = a®R1. Assume first P |= R. Then C ≡ (νa)Cj and Pj d=ef Cj[n[0] | m[0]] |= R1. Since n, m are free in P, a ≠ m and a ≠ n. So {n, m} ∩ n(Cj) = ∅, and by induction, Pj |= R1{n/m}. R{n/m} = a®R1{n/m}, and P |= R{n/m}. The other direction is proved similarly.
R = ∀x. R1. Assume first P |= R. Let take a e W. Then P |= R1{a/x}, and by induction P |= R1{a/x}{n/m}. For a ≠ m, this is also P |= R1{n/m}ax. For a = m, this requires a bit more. Consider that P |= R1{n/x}. Then P |= R1{n/x}{n/m} by induction. But R1{n/x}{n/m} = (R1{n/m}{m/x}){n/m}, so by induction P |= R1{n/m}{m/x}. Hence P |= R1{n/m}{a/x} for all a, that is P |= ∀x. R1{n/m} =

R{n/m}.
Assume now that P |= R{n/m}. Let take a e W. Then P |= R1{n/m}{a/x}. If a ≠ m, this is P |= R1{a/x}{n/m}, so by induction P |= R1{a/x}. For a = m, consider that P |= R1{n/m}{n/x}, that is P |= R1{m/x}{n/m}, so by induction P |= R1{m/x}. Hence P |= R1{a/x} for all a, that is P |= R.
□

Lemma A.2 Let R be a formula of SALint , and C a thread context such that d(C) >
d(R). Let n, m be two names such that {n, m}∩ n(C) = θ, and moreover m g fn(R). Let

P  d=ef
C[ n[0] | m[0]]	and	P2
d=ef
C[ n[0] | n[0]] 

If P1 |= R, then P2 |= R.
Proof. By induction on the size of R:
the cases R = R1 ∧ R2, R = R1 v R2, R = 0 and R = ¬ 0 are trivial.
R = R1 | R2. Since d(C) ≥ 1, we may assume by symmetry that 0 |= R2 and
P1 |= R1. Then P2 |= R1 by induction, and P2 |= R
R = R1 || R2. Since d(C) ≥ 1, P1 |= R1 ∧ R2, 0 |= R1 ∧ R2. By induction,
P2 |= R1 ∧ R2, that is P2 |= R
R = a[R1]. Then C ≡ a[Cj] and Cj[n[0] | m[0]] |= R1. By induction Cj[n[0] |
n[0]] |= R1, that is P2 |= R.
R = ¬ a[R1]. Then either C is not of the form n[Cj], and P2 |= ¬ a[R1], or C ≡ n[Cj] but Cj[n[0] | m[0]] |= ¬ R1. Then by induction Cj[n[0] | n[0]] |= ¬ R1, that is P2|=a[R1].
R = a®R1. Then C ≡ (νa)Cj and Cj[n[0] | m[0]] |= R1. Since n, m are free in P, a g {m, n}, so n(Cj) ∩ {m, n} = θ. Then by induction, Cj[n[0] | n[0]] |= R1, and P2 |= R.
	R = ¬ a®R1. Assume first that a is free in P1. Then a ≠ m since m g fn(R) by hypothesis. So a is also free in P2 and P2 |= R. Assume now a is fresh for P1 (and P2). Let Cj be such that C ≡ (νa)Cj. Then Cj[n[0] | n[0]]|=R1, otherwise Cj[n[0] | m[0]] |= R1 and P |= R. So P2|=a®R1.
R = ∀x. R1. Let take a e W. Then P1 |= R1{a/x}, and by induction P2 |= R1{a/x} for a ≠ m. Let take some fresh mj. By equivariance, P1(m — mj) |= ∀x. R1, so P1(m — mj) |= R1{m/x}. Applying induction on P1 and R1{m/x} for mj instead of m, we have P2 |= R1{m/x}. Hence P |= R1{a/x} for all a, that is P2 |= ∀x. R1.
R = Ex. R1. Let a e W be such that P1 |= R1{a/x}. If a ≠ m, then we may apply induction on R1{a/x}, and P2 |= R2{a/x}, that is P2 |= R. Otherwise P1 |= R1{m/x}. By Lemma A.1, P1 |= R1{m/x}{n/m} = R1{n/x}{n/m}, and again P1 |= R1{n/x}. Then by induction, P2 |= R1{n/x}, that is P2 |= R.

□
Proof of Proposition 6.2
Proof. Let assume by absurd we have some R such that
P |= R	iff	 fn(P) = 1
Then let C be the thread context of the form (νa)a[... a[. ] .. .], and d(C) = d(R)+1. Let m, n be two fresh names. Then C[n[0] | m[0]] |= ¬R by definition of R, so by Lemma A.2, C[n[0] | n[0]] |= ¬ R. Moreover, by definition of R, C[n[0] | n[0]] |= R, so the contradiction.	□

Proof of Theorem 7.1 (minimality)
We detail the removal of each connective in the minimality proof for SALint. Some connectives are coined ‘expressive’, in the sense that removing them hinders the expressive power of the logic, others are ‘separative’, because their removal affects the separation power (and hence expressiveness) of the logic.

∧ is expressive
We note k2(W) = {{n1, n2} : n1 ≠ n2}. We note Kn = {{n, m} : m ≠ n}. We say that K ⊆ k2(W) is cofinite if there is N ⊆ W, N finite, such that for all n1, n2 g N, if n1 ≠ n2 then {n1, n2} e K. We may remark that K1, K2 are cofinite iff K1 ∩ K2 is cofinite, and K is cofinite iff K – Kn is cofinite.
Lemma B.1 Assume R is a formula of SALint – {∧} such that 0|=R. We set


K	d=ef
{ {n1, n2} : n1 ≠ n2, n1[n2[0]] |= R and n2[n1[0]] |= R }.

Then either KR = θ or KR is cofinite.
Proof. By induction on R:
R = In. R1. Then 0|=R1, and for any n1, n2 s.t. n1 ≠ n,n2 ≠ n and n1 ≠ n2,
{n1, n2} e KR1 iff {n1, n2} e KR1 . That is KR – Kn = KR1 – Kn.
R = 0: 0 |= R.
R = ¬ 0: then KA = k2
R = R1 | R2: since 0|=R, we may assume by symmetry that 0|=R1. If also
0|=R2, then KR = θ. Otherwise, KR = KR1 .
R = R1 || R2: since 0|=R, 0|=R1 and 0|=R2. then KR = KR1 ∩ KR2 .
R = n[R1]: then KR = θ.

R = ¬ n[R1]: then k2(W) – Kn ⊆ KR, so KR is cofinite.
R = n®R1: then 0|=R1, and KR – Kn = KR1 – Kn.
R = ¬ n®R1: then 0|=R1, and KR – Kn = K¬ R1 – Kn.
□
Lemma B.2 Let n1, n2 be two distinct names.  Then there is no formula R e
SALint – {∧} equivalent to n1[n2[0]] v n2[n1[0]].
Proof. By absurd: if there is such a formula R, then 0|=R. Then by Lemma B.1
KR ≠ 1, and the contradiction.	□

¬ is expressive
Definition B.3 We define the truncation at height h e N as t0(P) = 0, and
th((νn˜)(n1[P1] | ... | nr[Pr]))  =  (νn˜)(n1[th–1(P1)] | ... | nr[th–1(Pr)]).
Note that fn(th(P)) ⊆ fn(P).
Lemma B.4 If R is a formula without ¬ , s(R) ≤ h and P |= R, then th(P) |= R.
Proof. By induction on R:
R = R1 ∧ R2: then by induction th(P) |= R1, th(P) |= R2, so th(P) |= R1 ∧ R2.
R = In. R1: then there is nj g fn(P) s.t. P |= R1(n — nj). By induction
th(P) |= R1(n — nj), nj g fn(th(P)), so th(P) |= In. R1.
R = 0: then th(P) ≡ P ≡ 0
R = R1 | R2: then P ≡ P1 | P2 with Ps |= Rs, and by induction th(Ps) |= Rs, so
th(P) |= R.
R = n[R1]: then P ≡ n[P1] and P1 |= R1. By induction, th–1(P1) |= R1, and so
th(P) |= R.
R = n®R1: then P ≡ (νn)P1 with P1 |= R1. Then by induction th(P1) |= R1, so
th(P) |= R.
□
Lemma B.5 There is no formula R e SALint – {¬ } equivalent to ¬ n®±.
Proof. Suppose R exists, and take h = s(A). We note P ≡ m[m[... m[0] .. .]] and Q ≡ m[m[... m[n[0]] .. .]] a nesting of h ambients m, for some m ≠ n. Then Q |= R, P|=R, and P ≡ th(Q), which contradicts Lemma B.4	□


I is expressive
For N = {n1,... nr}, we set Pn


= n[n1[0] | ... | nr[0]].

Lemma B.6 Assume some finite set of names N and a quantifier free formula R such that fn(R) c N, and n g N. Then



Proof. By induction on R:
n |= R iff (νn)Pn
|= R

the cases R = R1 ∧ R2, and R = ¬ R1, are straightforward.
if R = 0: then none of the two processes satisfies R.
if R = R1 | R2. Assume first that Pn |= R. By symmetry, we may assume

n |= R1 and 0 |= R2. So (νn)Pn |= R1 by induction, and (νn)Pn
|= R. If we

assume (νn)Pn |= R, we may do the same reasoning.

R = m[R1]: none of Pn , (νn)Pn
does satisfy R.

N	N
R = m®R1: then m e fn(R) ⊆ N, hence none of Pn , (νn)Pn does satisfy R.
N	N
□
Lemma B.7 There is no formula R e SALint – {I} equivalent to In. n®n®±.
Proof. By absurd, let R be such a quantifier free formula, and {n1,... , nr} = fn(R). Then Pn |=R, so (νn)P|=R, by Lemma B.6, and the contradiction.	□

0 is expressive
In this case, the logic is enriched with т in order to have a 0-ary connector.
Lemma B.8 Let R be a formula without 0, and n g fn(A). Then
0 |= R iff n[0] |= R
Proof. We reason by induction on R
R = т, R = R1 ∧ R2, R = ¬ R1 : straightforward.
R = Im. R1 : We assume without loss of generality m ≠ n. If 0 |= Im. R1, then 0 |= R1. n[0] |= R1 by induction, so n[0] |= In. R1. Conversely, if n[0] |= Im. R1, then n[0] |= R1, so 0 |= R1 by induction, and then 0 |= In. R1.
if R = R1 | R2. Assume first that 0 |= R1 | R2. Then 0 |= R1 ∧ R2, hence by induction n[0] |= R1, and n[0] |= R1 | R2. If 0|=R1 | R2, then we may assume by symmetry that 0|=R1. Assume by absurd that n[0] |= R1 | R2. Then n[0] |= R1 and 0 |= R2. By induction 0 |= R1 and the contradiction.
if R = m[R1]. Then m ≠ n by hypothesis, and both 0|=R and n[0]|=R.
if R = m®R1, m ≠ n by hypothesis. If 0 |= R, then 0 |= R1, and by induction n[0] |= R1 and n[0] |= R. Conversely, if n[0] |= R, then n[0] |= R1, and 0 |= R1 so 0 |= R by induction.

□
Lemma B.9 There is no formula R e SALint – {0} equivalent to 0.
Proof. By absurd, if R is such a formula an n g fn(R), then by Lemma B.8,
n[0] |= R and the contradiction.	□

|, n[. ], n®. are separative
Lemma B.10 If R e SALint – {|}, then P1 = n[0] | n[0] |= R iff P2 = n[0] | n[0] |
n[0] |= R.
Proof. By absurd, suppose there exists a formula R telling apart P1 from P2, take a minimal such R, and reason by case analysis on R.
the cases R = R1 ∧ R2, R = ¬ R1 and R = ImR1 are straightforward.
if R = 0, then none of P1, P2 does satisfy R.
R = m®R1: if m = n, then none of those processes do satisfy R, otherwise the process satisfying R does satisfy R1, and R1 is a smaller separating formula.
R = m[R1]: none of the two processes do satisfy R.
□
Lemma B.11 If R e SALint – {n[. ]}, then for any names n1, n2, we set P1 =
n1[n2[0]] and P2 = n2[n1[0]]. Then P1 |= R iff P2 |= R.
Proof. As above, by absurd and case analysis on a minimal R:
the cases R = R1 ∧ R2, R = ¬ R1 and R = ImR1 are straightforward.
if R = 0, then none of P1, P2 do satisfy R.
R = R1 | R2. We may assume by symmetry that P1 |= R. Also by symmetry, we may assume P1 |= R1 and 0 |= R2. If P2|=R, then R1 separates P1 from P2 and is a smaller formula: contradiction.
R = m®R1: if m e {n1, n2}, then none of the two processes do satisfy R, oth- erwise the process satisfying R also satisfies R1, and R1 is a smaller separating formula.
□
Lemma B.12 Assume R e SALint – {n[. ]}, We set P1 = (νn)n[n[0]] and P2 =
(νn)n[0]. Then P1 |= R iff P2 |= R.
Proof. Again, by absurd and case analysis on a minimal R:
the cases R = R1 ∧ R2, R = ¬ R1 and R = ImR1 are straightforward.
if R = 0, then none of P1, P2 do satisfy R.

R = R1 | R2. We may assume by symmetry that P1 |= R. Also by symmetry, we may assume P1 |= R1 and 0 |= R2. If P2|=R, then R1 separates P1 from P2 and is a smaller formula: contradiction.
R = m[R1]: none of P1, P2 do satisfy R.
□
