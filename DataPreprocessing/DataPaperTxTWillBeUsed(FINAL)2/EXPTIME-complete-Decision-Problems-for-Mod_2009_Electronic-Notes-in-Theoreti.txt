

Electronic Notes in Theoretical Computer Science 242 (2009) 19–33
www.elsevier.com/locate/entcs

EXPTIME-complete Decision Problems for Modal and Mixed Specifications 1
Adam Antonik and Michael Huth2 ,3
Department of Computing, Imperial College London, United Kingdom
Kim G. Larsen and Ulrik Nyman4 ,5
Department of Computer Science, Aalborg University, Denmark
Andrzej Wąsowski6
IT University of Copenhagen, Denmark

Abstract
Modal and mixed transition systems are formalisms that allow mixing of over- and under-approximation in a single specification. We show EXPTIME-completeness of three fundamental decision problems for such specifications: whether a set of modal or mixed specifications has a common implementation, whether a sole mixed specification has an implementation, and whether all implementations of one mixed specification are implementations of another mixed or modal one. These results are obtained by a chain of reductions starting with the acceptance problem for linearly bounded alternating Turing machines.
Keywords: EXPTIME-completeness, decision problem, mixed transition system, modal transition system


Introduction
Behavioral models capture actual, desired or required system behavior and can so serve as documentation, specification or as the basis of analysis and validation

1 Huth and Antonik were partially supported by the UK EPSRC projects Efficient Specification Pattern Library for Model Validation EP/D50595X/1 and Complete and Efficient Checks for Branching-Time Abstractions EP/E028985/1. Wąsowski was partially funded by CISS—Center for Embedded Software Systems, Aalborg University
2 aa1001@doc.imperial.ac.uk
3 mrh@doc.imperial.ac.uk
4 kgl@cs.aau.dk
5 ulrik@cs.aau.dk
6 wasowski@itu.dk

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.06.011

activities. Formal behavioral models — of which we mention process algebras, Petri nets and labelled transition systems — bring a high degree of rigor and dependability to validation and verification activities.
Often one has to deal with more than one behavioral model at a time. For example, in requirement elaboration one may have several versions of a model, in component-based design one may have models that each focus on a different aspect of the system, and in formal verification one may have a system model accompanied by models that represent either desired features or genuinely faulty behavior. In each of these cases the modeller may want to have assurance that this collection of models is consistent. If versions of models are inconsistent with each other, this may reveal important implementation trade-offs. If all aspect models are inconsistent, their combination is not implementable. If a system model is inconsistent with all members of a given set of fault models, the system will not exhibit any of these flaws. Finally if a system model is consistent with a set of feature models, then the system will be able to actually implement all these features.
A related concept is the consistency of a single behavioral model. If models serve as specifications, their inconsistency suggests that the specification cannot be imple- mented. Conversely, a consistent model boosts our confidence in implementability and may even allow code-generation of such an implementation.
The stepwise-refinement paradigm proposes to write specifications as models and to then repeatedly refine such models until an implementation has been realized. In a thorough interpretation, refinement is decreasing the set of possible implementa- tions: only implementations that were possible before the refinement step are still possible thereafter, but not necessarily all of them anymore.
This paper is devoted to studying the exact computational complexity of these three decision problems; whether finitely many models are consistent, whether a single model is consistent, and whether one model thoroughly refines another. The actual models we study are mixed speciﬁcations — stateful models with allowed and required transitions, well recognized as a formal foundation for system specification and abstraction alike [23,18,24,5,21,22,8,9,20,19]. We show that
deciding whether finitely many modal or mixed specifications are consistent is EXPTIME-complete in the sum of the sizes of these specifications
deciding whether one mixed specification is consistent is EXPTIME-complete in the size of that specification
deciding whether one mixed specification thoroughly refines another mixed spec- ification is EXPTIME-complete in the sum of their sizes.
Interestingly, checking the consistency of 100 mixed specifications with a few states each can be dramatically more complex than checking the consistency of a few mixed specifications with 100 states each. This is in striking contrast to the situation when all mixed specifications are fully refined (have identical required and allowed behaviors). In that case, consistency checks reduce to pairwise bisimilarity checks, which can be performed in polynomial time.
Our complexity results motivate future research that aims to either approximate

these three decision problems soundly and efficiently, or that identifies sub-classes of specifications for which these decision problems are less complex.
We proceed by introducing the necessary background on alternating Turing ma- chines, specifications, and their decision problems in Section 2. In Section 3 state-of- the-art bounds for these problems are reported. The new EXPTIME-completeness results are given in Section 4. Section 5 reflects on a remaining open complexity gap for a special kind of mixed specifications, modal ones. We conclude in Section 6.

Related work
We refer to our recent overview [2] for a full account of related work. The present paper primarily improves on the results of [3], which are discussed in detail in Section 3. The relation of this work to generalized model checking [4] is detailed in Section 5.
In [13] a superpolynomial algorithm is given, which establishes common imple- mentation for k > 1 modal specifications. The algorithm is exponential in k, but polynomial if k is fixed. It computes a common implementation if one exists. These upper bounds follow also from the polynomial algorithm for consistency checking of a conjunction of disjunctive modal transition systems, as studied in [24].
In [14] Hussain and Huth present an example of two modal specifications that have a common implementation but no greatest common implementation.
Fischbein et al. [10] use modal specifications for behavioral conformance checking of products against specifications of product families. They propose a new thorough refinement whose implementations are defined through a generalization of branching bisimulation. The thorough refinement obtained in this manner is finer than weak refinement, and argued to be more suitable for conformance checking.
Background
Let us begin with a definition of the decision problem used in the main proof of this paper. An Alternating Turing Machine [6], or an ATM, is a tuple T = (Q, Γ, δ, q0, mode), where Q is a non-empty finite set of control states, Γ is an al- phabet of tape symbols, null /Γ∈ is a special symbol denoting empty cell contents, δ : Q × (Γ ∪ {null}) → P(Q × Γ × {l, r}) is a transition relation, q0 ∈ Q is the initial control state, and mode : Q → {Univ, Exst} is a labeling of control states as respec- tively universal or existential. Universal and existential states with no successors are called accepting and rejecting states (respectively). Each ATM T has an infinite tape of cells with a leftmost cell. Each cell can store one symbol from Γ. A head points to a single cell at a time, which can then be read or written to. The head can then move to the left or right: (q', a', r) ∈ δ(q, a), e.g., says “if the head cell (say c) reads a at control state q, then a successor state can be q', in which case cell c now contains a' and the head is moved to the cell on the right of c.” The state of the tape is an infinite word over Γ ∪ {null}.
Figure 1 presents an example of an ATM T over a binary alphabet Γ = {0, 1}
where arrows q (a,a',d)  q' denote (q', a', d) ∈ δ(q, a). The initial control state e is an


(1, 1, r)


(0, 0, r)

(0, 1, l)
u2


(0, 0, r)
δ(e, 0) = {(e, 0, r)}
δ(e, 1) = {(e, 1, r), (u1, 1, r)}
δ(u1, 0) = {(u1, 1, l), (u1, 0, r)}
δ(u1, 1) = {(u2, 1, r)}
δ(u2, 0) = δ(u2, 1) = {}

Fig. 1. The transition relation of an ATM as a labelled graph and a function.

existential one, and both ui control states are universal.
Configurations of an ATM T are triples ⟨q, i, τ ⟩ where q ∈ Q is the current control state, the head is on the ith cell from the left, and τ ∈ (Γ ∪ null)ω is the current tape state. For input w ∈ Γ∗, the initial configuration is ⟨q0, 1, wnullω⟩. The recursive and parallel execution of all applicable 7 transitions δ from initial configuration ⟨q0, 1, wnullω⟩ yields a computation tree T⟨T,w⟩. We say that ATM T accepts input w iff the tree T⟨T,w⟩ accepts, where the latter is a recursive definition:
T⟨T,w⟩ with root ⟨q, i, τ ⟩ and mode(q) = Exst accepts iff there is a successor
⟨q', i',τ '⟩ of ⟨q, i, τ ⟩ in T⟨T,w⟩ such that the sub-tree with root ⟨q', i',τ '⟩ accepts
T⟨T,w⟩ with root ⟨q, i, τ ⟩ and mode(q)= Univ accepts iff for all successors ⟨q', i',τ '⟩ of ⟨q, i, τ ⟩ in T⟨T,w⟩ the sub-tree with root ⟨q', i',τ '⟩ accepts (in particular, this is the case if there are no such successors)
The ATM of Figure 1 accepts the regular language (0 + 1)∗10∗1(0 + 1)∗. Observe that u2 is the only accepting state. Intuitively the part of T rooted in e accepts the prefix (0 + 1)∗1 — the semantics of existential states is locally that of states in non-deterministic Turing machines. The part of T rooted in u1 consumes a series of 0 symbols until 1 is reached, which leads to acceptance. The suffix of the input word after the last 1 is ignored. Note that the computation forks in u1 whenever a 0 is seen. However, the top branch would reach the earlier 1 eventually and accept. An ATM T is linearly bounded iff for all words w ∈ Γ∗ accepted by T , the accept- ing part of the computation tree T⟨T,w⟩ only contains configurations ⟨q, i, vnullω⟩, where the length of v ∈ Γ∗ is no greater than the length of w. That is to say, by choosing exactly one accepting successor for each existential configuration in T⟨T,w⟩, and by removing all the remaining successors and configurations unreach- able from the root, one can create a smaller tree that only contains configurations with ⟨q, i, vnullω⟩ where |v|≤ |w|. We refer to such pruned computation trees simply
as “computations”.
Our notion of “linear boundedness” follows [17] in limiting the tape size to the size of the input. This limitation does not change the hardness of the acceptance problem (see below). In addition we assume that linearly bounded ATMs have no infinite computations since any linearly bounded ATM can be transformed into another linearly bounded ATM, which accepts the same language, but also counts the number of computation steps used, rejecting any computation whose number of

7 Transitions ( , , , , l) are not applicable in configurations ⟨ , 1, ⟩ as the head cannot move over the left boundary of the tape.

steps exceeds the number of possible configurations. 8
Let ATMLB = {⟨T, w⟩ | w ∈ Γ∗ accepted by linearly bounded ATM T }. The problem of deciding if for an arbitrary linearly bounded ATM T and an input w the pair ⟨T, w⟩ is in ATMLB is EXPTIME-complete [6].
Let us now define the basic models of interest in our study [18,8,7]:
Definition 2.1 For a finite alphabet of actions Σ,a mixed speciﬁcation M is a triple (S, R , Ro), where S is a finite set of states and R , Ro ⊆ S × Σ × S are must- and may- transitions relations (respectively). A modal specification is a mixed specifica- tion satisfying R ⊆ Ro; all its must-transitions are also may-transitions. A pointed mixed (respectively modal) specification (M, s) is a mixed (modal) specification M with a designated initial state s ∈ S. The size | M | of a mixed (modal) specification M is defined as | S | + | R ∪ Ro |.
Refinement [18,8,7], called “modal refinement” in [20], is a co-inductive rela- tionship between two mixed specifications that verifies that one such specification is more abstract than the other. This generalizes the co-inductive notion of bisim- ulation [25] to mixed specifications:
Definition 2.2 A mixed specification (N, t0)= ((SN , R  , Ro ), t0) reﬁnes another
N	N
mixed specification (M, s0)=((SM , R  , Ro ), s0) over the same alphabet Σ, written
M	M
(M, s0)≺(N, t0), iff there is a relation Q ⊆ SM ×SN containing (s0, t0) and whenever
(s, t) ∈ Q then

for all (s, a, s') ∈ R 
for all (t, a, t') ∈ Ro
there exists some (t, a, t') ∈ R 
there exists some (s, a, s') ∈ Ro
with (s', t') ∈ Q
with (s', t') ∈ Q

Deciding whether one finite-state mixed specification refines another one is in P. For mixed specification (N, t0) and modal specification (M, s0) in Figure 2 we have (M, s0)≺(N, t0), given by Q = {(s0, t0), (s1, t1), (s2, t2), (s3, t2), (s4, t3)}. Note that throughout figures, solid arrows denote R -transitions, and dashed arrows denote Ro-transitions. But we do not have (N, t0)≺(M, s0). To see this, assume that there is a relation Q with (t0, s0) ∈ Q satisfying the properties in Definition 2.2. Then
from (s0, π, s2) ∈ Ro  we infer that there must be some x with (t0, π, x) ∈ Ro
and (x, s2) ∈ Q.  In particular, x can only be t1 or t2.  If x is t1, then since

(s2, π, s4) ∈ Ro
and (t1, s2) ∈ Q there has to be some Ro
transition out of t1,

which is not the case. If x is t2, then (t2, π, t3) ∈ R 
and (t2, s2) ∈ Q imply that

there is some R   transition out of s2, which is not the case. In conclusion, there
cannot be such a Q and so (N, t0) /(≺M, s0).
Labeled transition systems over an alphabet Σ are pairs (S, R) where S is a non- empty set of states and R ⊆ S × Σ × S is a transition relation. We identify labelled transition systems (S, R) with modal specifications (S, R, R). The set of implemen- tations I(M, s) of a mixed specification (M, s) are all pointed labelled transition systems (T, t) refining (M, s). Note that I(M, s) may be empty in general, but is guaranteed to be non-empty if M is a modal specification.

8 This is possible because ASPACE = EXPTIME [27, Thm. 10.18].



s0	t0

π
s	s3	t1
π
N :	t3 
Fig. 2. Mixed ((M, s0)) and modal ((N, t0)) specifications with I(M, s0)= I(N, t0) but not (N, t0)≺(M, s0).


Definition 2.3 Let (N, t) and (M, s) be pointed mixed specifications. As in [20] we define thorough reﬁnement (M, s)≺th(N, t) to be the predicate I(N, t) ⊆ I(M, s).
Refinement approximates this notion: (M, s)≺(N, t) implies (M, s)≺th(N, t) since refinement is transitive. The converse is known to be false [16,28,26]; Fig- ure 2 provides a counterexample.
We shall now formally define the decision problems informally stated above:
Common implementation (CI): given k > 1 modal or mixed specifications (Mi, si),
is the set  k	I(Mi, si) non-empty?
Consistency (C): Is I(M, s) non-empty for a modal or mixed specification (M, s)?
Thorough reﬁnement (TR): Does a mixed specification (N, t) thoroughly refine a mixed specification (M, s), i.e., do we have I(N, t) ⊆ I(M, s)?
As far as these decision problems are concerned, the restriction to finite imple- mentations, which follows from restricting our definitions to finite specifications, causes no loss of generality, as already explained in [3]. A mixed specification (M, s) is consistent in the infinite sense iff its characteristic modal mu-calculus formula Ψ(M,s) [15] is satisfiable. Appealing to the small model theorem for mu- calculus, Ψ(M,s) is satisfiable iff it is satisfiable over finite-state implementations. We can reason in a similar manner about common implementation, which justifies the restriction to finite-state specifications and implementations.
Throughout this paper we work with Karp reductions, many-one reductions computable by deterministic Turing machines in polynomial time. This choice is justified since we reduce problems that are EXPTIME-complete.

Current Bounds
In [3], the three decision problems CI, C, and TR were studied for mixed and modal specifications. The results of [3] are summarized in Table 1. Two reductions were given in [3] that we appeal to here:
a reduction of CI for modal specifications to C for mixed specifications
a reduction of C for mixed specifications to TR for mixed specifications.

EXPTIME-hardness of CI for modal specifications would thus render EXPTIME- completeness of the decision problems CI, C, and TR for mixed specifications. We
Table 1
A summary given in [3] of the results provided in [3].


turn to this EXPTIME-hardness proof in the next section.
EXPTIME-Completeness Results
Theorem 4.1 Let {(Ml, sl)}l∈{1...k} be a ﬁnite family of modal speciﬁcations over the same action alphabet Σ. Deciding whether there exists an implementation (I, i) such that (Ml, sl)≺(I, i) for all l = 1 ... k is EXPTIME-hard.
We prove Theorem 4.1 by demonstrating a PTIME reduction from ATMLB. Given an ATM T and an input word w of length n we synthesize a collection of
(pointed) modal specifications MT = {Mi | 1 ≤ i ≤ n}∪ {Mhead, Mctrl, Mexist}
whose sum of sizes is polynomial in n and in the size of T , such that T accepts w
iff there exists an (pointed) implementation I refining all members of MT .
Specifications Mi, Mhead, Mctrl, and Mexist model tape cell i, the current head position, the finite control of T , and acceptance (respectively). Common implemen- tations of these specifications model action synchronization to agree on what symbol is read from the tape, what is the head position, what is the symbol written to the tape, in what direction the head moves, and what are the transitions taken by the finite control, and whether a computation is accepting. The achieved effect is that a common refinement of these specifications corresponds to an accepting computation of T on input w. More precisely, any common implementations will correspond to different unfoldings of the structure of the finite control into a computation tree based on the content of the tape cells and the tape head position.

We now describe the specifications in MT
both formally and through our run-

ning example in Figure 1. All specifications in MT have the same alphabet 9
Σ= {π, ∃} ∪ (Γ × {1..n}× Γ × {l, r})
where ∃ and π are fresh symbols whose transitions encode logical constraints like disjunction and conjunction. All other actions are of the form (a1, i, a2, d) and denote that the machine’s head is over the ith cell of the tape, which contains the

9 A stricter and more complex reduction to CI of modal specifications over a binary alphabet is possible by encoding actions in binary form.

(0, 1, 1,  )




Σ − {( , 1, , )}
)

Σ − {( , 1, ,  )}

Fig. 3. Specification M1 of the first tape cell in our running example, assuming w1 = 0.

{π, ∃}	{π, ∃}	{π, ∃}	{π, ∃}
Fig. 4. Example of the head specification Mhead assuming |w| = 4.

a1 symbol, and that it shall be moved one cell in the direction d after writing a2 in the current cell. The alphabet for our running example is
{π, ∃} ∪ ({0, 1}× {1..n}× {0, 1}× {l, r})


Encoding Tape Cells.
For each tape cell i, specification Mi represents the possible contents of cell i. It has |Γ| states {p⟨i,a⟩}a∈Γ and initial state p⟨i,wi⟩, representing the initial contents of the ith cell. There are no must-transitions:
R  = ∅
The may-transition relation connects any two states:
for all symbols a1, a2 in Γ we have (p⟨i,a1 ⟩, (a1, i, a2,  ), p⟨i,a2 ⟩) ∈ Ro
Changes in cells other than i are also consistent with Mi:
for all a ∈ Γ if i /j=, 1 ≤ j ≤ n, then (p⟨i,a⟩, (, j, , ), p⟨i,a⟩) ∈ Ro
Finally the π and ∃ actions may be used freely as they do not affect the contents of the cell:
(p⟨i,a⟩, π, p⟨i,a⟩) ∈ Ro and (p⟨i,a⟩, ∃, p⟨i,a⟩) ∈ Ro for any a ∈Γ
There are no more may-transitions in Mi.
Figure 3 presents a specification M1 for the leftmost cell of an ATM over a binary alphabet. In figures we visualize multiple transitions with the same source and target as single arrows labeled with sets of actions. Several labels placed by the same arrow denote a union of sets. Wildcards (the ’’ symbol) are used to generate sets of actions that match the pattern in the usual sense.

Encoding The Head.
Specification Mhead, which tracks the current head position, has n states labeled p1 to pn — one for each possible position. Initially, the head occupies the leftmost cell, so p1 is the initial state of Mhead. There are no must-transitions:
R  = ∅
May-transitions are consistent with any position changes based on the direction encoded in observed actions. More precisely,
for every position 1 ≤ i<n we have (pi, (, i, , r), pi+1) ∈ Ro
for every 1 <i ≤ n we have (pi, (, i, , l), pi—1) ∈ Ro
The π and ∃ transitions may again be taken freely, but in this case without moving the machine’s head:
(pi, π, pi) ∈ Ro and (pi, ∃, pi) ∈ Ro for each 1 ≤ i ≤ n
There are no more may-transitions in Mhead. Note that the head of T is only allowed to move between the first and nth cell in any computation. Figure 4 shows specification Mhead for our running example.

Encoding The Finite Control.
Specifications Mctrl and Mexist model the finite control of the ATM T . Specifica- tion Mexist is indepenendent of the ATM T . It is defined in Figure 5. It ensures that a π-transition is taken after every ∃-transition. Specification Mctrl mimics the finite control of T almost directly. Each control state qs ∈ Q is identified with a state in Mctrl of the same name. Additional internal states of Mctrl encode existential and universal branching:
for each qs a state qsE with two ∃-transitions (qs, ∃, qsE) ∈ Ro ∩ R is added Dependent on mode(qs), additional states and transitions are created:
If mode(qs)=Exst: for each 1 ≤ i ≤ n, aold ∈Γ, and for each transition (qt, anew, d) ∈ δ(qs, aold) add a may π-transition from qsE to a new intermediate state uniquely named ⟨qsaoldianewdqt⟩, and add a must-transition labeled (aold, i, anew, d) from that intermediate state to qt. Formally:
(qsE, π, ⟨qsaoldianewdqt⟩) ∈ Ro

(⟨qsaoldia
dq ⟩, (a
, i,a	, d),q ) ∈ Ro ∩ R 

new	t
old
new	t

Figure 6 shows this encoding for the state e of our running example.
If mode(qs)=Univ: for each 1 ≤ i ≤ n, aold ∈Γ, and for each transition (qt, anew, d) ∈
δ(qs, aold) add a may π-transition from qsE to an intermediate state named ⟨qsaoldi⟩,

and add a must-transition labeled (aold, i, anew, d) from the intermediate state
⟨qsaoldi⟩ to qt. Formally:


(qsE, π, ⟨qsaoldi⟩) ∈ Ro ,	(⟨qsaoldi⟩, (aold
, i, anew
, d), qt) ∈ Ro ∩ R 




x3



x1	x2
Fig. 5. Specification Mexist enforces a π-transition after each E-transition.
The initial state of Mctrl is its state named q0, where q0 is the initial state of T . Figure 7 demonstrates the encoding of the state u1 of the ATM in Figure 1. The complete specification Mctrl for our running example is shown in Figure 8.
⟨e111re⟩








e
1







⟨e040re⟩
Fig. 6. Encoding for the existential state of the running example, assuming |w| = 4.

Notice how the two specifications Mctrl and Mexist cooperate to enforce the nature of alternation. For example, for an existential state, Mctrl forces every im- plementation to have an ∃-transition, which may be followed by a π-transition. Simultaneously Mexist allows an ∃-transition but requires a π-transition. Effectively at least one of the π branches from Mctrl must be implemented (which is an encoding of a disjunction).

The complete family of specifications MT
contains all the specifications de-

scribed above:
MT = {Mi | 1 ≤ i ≤ n}∪ {Mhead, Mctrl, Mexist}

⟨u101⟩	⟨u111⟩









u1
2





⟨u104⟩	⟨u114⟩
Fig. 7. Encoding for the universal state u1 of the running example, assuming |w| = 4.

All these specifications are modal by construction. Since the sum of their sizes is bounded by a polynomial in n and in the size of T , it remains to prove the following lemma:
Lemma 4.2 For each linearly bounded ATM T and an input w, T accepts w iff the

set of modal speciﬁcations MT
has a common implementation.

The proof of Lemma 4.2 will appear in the final version of the paper. We mention here some points of interest. From an accepting computation tree T⟨T,w⟩ one can construct a specification N by structural induction on T⟨T,w⟩. This N effectively adds to T⟨T,w⟩ some new states and labeled transitions so that the computation encoded in T⟨T,w⟩ then interlocks with the action synchronization of specifications in MT . Since N is of the form (S, R, R) it suffices to show that N is a common refinement of all members in MT . This is a lengthy but routine argument.
For the converse, a common implementation of MT is cycle-free by our assump- tion that T never repeats a configuration. So that pointed common implementation is a DAG and we use structural induction on that DAG to synthesize an accepting computation tree of T for input w. This makes use of the fact that the head of T never reaches a cell that was not initialized by input w.

Further results.
Theorem 4.1 states EXPTIME-hardness of CI for modal specifications. To- gether with the upperbound given in [3] we conclude that this bound is tight: CI is EXPTIME-complete. Moreover, by applying the reduction of CI for modal specifi- cations to C for mixed specifications [3] we conclude that C for mixed specifications is EXPTIME-complete. Furthermore by appealing to the reduction of C for mixed specifications to TR for mixed specifications [3], we obtain that TR for mixed spec- ifications is EXPTIME-complete as well.
Corollary 4.3 The complexities shown in Table 2 are correct.








⟨e111re⟩
⟨u201⟩















⟨e040re⟩
⟨u214⟩

Discussion
One complexity gap remains in Table 2, that for thorough refinement of modal spec- ifications. Despite having made an extensive effort we can presently show neither EXPTIME-hardness nor membership in PSPACE for this problem.
In this context, it is useful to state that thorough refinement can be reduced to certain validity checks. First, as observed in [3], mixed and modal specifications (M, s) have characteristic formulæ Ψ(M,s) [15] in the modal μ-calculus such that pointed labeled transition systems (L, l) are implementations of (M, s) iff (L, l) satisfies Ψ(M,s). This was already observed in [18] for such formulæ written in vectorized form. So the thorough refinement problem of whether (M, s)≺th(N, t) reduces to a validity check of ¬Ψ(N,t) ∨ Ψ(M,s). This raises the question of whether the validity problem for formulae given in the vectorized form of [18] is in PSPACE or whether it is EXPTIME-hard; that problem is known to be in EXPTIME (see for example [3]).
Second, we can reduce thorough refinement to a universal version of gener- alized model checking [4]. In loc. cit. Bruns and Godefroid consider judgments GMC(M, s, ϕ) which are true iff there exists an implementation of (M, s) satisfy- ing ϕ. They remark that this generalizes both model checking (when (M, s) is an implementation) and satisfiability checking (when (M, s) is such that all labeled transition systems refine it). This existential judgment has a universal dual (see e.g. [1]), VAL(M, s, ϕ) which is true iff all implementations of (M, s) satisfy ϕ, thus generalizing model checking and validity checking. The former judgment is useful for finding counter-examples, the latter one for verification; e.g. both uses can be seen in the CEGAR technique for program verification of [11]. Since (M, s)≺th(N, t) directly reduces to VAL(N, t, Ψ(M,s)), it would be of interest to understand the ex- act complexity of VAL(N, t, ϕ) for modal specifications (N, t) when ϕ ranges over characteristic formulæ Ψ(M,s) in vectorized form.
We remark that by translations and completeness results presented in [12] it follows that all complexity bounds presented here carry over to partial Kripke struc- tures and Kripke modal transition systems.

Conclusion
We have discussed three fundamental decision problems for modal and mixed spec- ifications: common implementation, consistency, and thorough refinement. For
Table 2
Tabular summary of the results provided in this paper (in bold).


modal specifications, consistency is trivially true, while thorough refinement was previously shown to be PSPACE-hard and in EXPTIME [3]. For the remaining decision problems we have shown here that they are all EXPTIME-complete in the sum of the sizes of mixed or modal specifications.
We have appealed to known reductions between some of these problems [3] and, crucially, to a new reduction of input acceptance for linearly bounded alternating Turing machines to the existence of a common implementation for modal specifi- cations – sketched in this extended abstract. The exact complexity of thorough refinement for modal specifications is subject to further investigation.

References
Antonik, A. and M. Huth, On the complexity of semantic self-minimization, in: Proc. AVOCS 2007, to appear in ENTCS.
Antonik, A., M. Huth, K. G. Larsen, U. Nyman and A. Wąsowski, 20 years of modal and mixed specifications,	Bulletin	of	EATCS	(2008),	available	at http://processalgebra.blogspot.com/2008/05/concurrency-column-for-beatcs-june-2008.html .
Antonik, A., M. Huth, K. G. Larsen, U. Nyman and A. Wąsowski, Complexity of decision problems for mixed and modal specifications, in: FoSSaCS’08, Lecture Notes in Computer Science 4962 (2008),
pp. 112–126.
Bruns, G. and P. Godefroid, Generalized model checking: Reasoning about partial state spaces, in:
C. Palamidessi, editor, CONCUR, Lecture Notes in Computer Science 1877 (2000), pp. 168–182.
Cerans, K., J. C. Godskesen and K. G. Larsen, Timed modal specification - theory and tools, in: CAV ’93: Proceedings of the 5th International Conference on Computer Aided Verification (1993), pp. 253– 267.
Chandra, A. K., D. Kozen and L. J. Stockmeyer, Alternation, J. ACM 28 (1981), pp. 114–133.
Clarke, E. M., O. Grumberg and D. E. Long, Model checking and abstraction, ACM Trans. Program. Lang. Syst. 16 (1994), pp. 1512–1542.
Dams, D., “Abstract Interpretation and Partition Refinement for Model Checking,” Ph.D. thesis, Eindhoven University of Technology (1996).
Dams, D., R. Gerth and O. Grumberg, Abstract interpretation of reactive systems, ACM Trans. Program. Lang. Syst. 19 (1997), pp. 253–291.
Fischbein, D., S. Uchitel and V. Braberman, A foundation for behavioural conformance in software product line architectures, in: ROSATEA ’06 Proceedings (2006), pp. 39–48.
Godefroid, P. and M. Huth, Model checking vs. generalized model checking: Semantic minimizations for temporal logics, in: LICS (2005), pp. 158–167.
Godefroid, P. and R. Jagadeesan, On the expressiveness of 3-valued models, in: L. D. Zuck, P. C. Attie,
A. Cortesi and S. Mukhopadhyay, editors, VMCAI, Lecture Notes in Computer Science 2575 (2003),
pp. 206–222.
Hussain, A. and M. Huth, On model checking multiple hybrid views, Technical report, Department of Computer Science, University of Cyprus (2004), TR-2004-6.
URL  http://pubs.doc.ic.ac.uk/hybrid-logic-multiple-views/

Hussain, A. and M. Huth, Automata games for multiple-model checking, Electr. Notes Theor. Comput. Sci. 155 (2006), pp. 401–421.
Huth, M., Labelled transition systems as a Stone space, Logical Methods in Computer Science 1 (2005),
pp. 1–28.
URL  http://pubs.doc.ic.ac.uk/labelled-systems-metrics-Stone/

Hu¨ttel, H., “Operational and Denotational Properties of Modal Process Logic,” Master’s thesis, Computer Science Department. Aalborg University (1988).

Laroussinie, F. and J. Sproston, State explosion in almost-sure probabilistic reachability, Inf. Process. Lett. 102 (2007), pp. 236–241.
Larsen, K. G., Modal specifications., in: J. Sifakis, editor, Automatic Verification Methods for Finite State Systems, Lecture Notes in Computer Science 407 (1989), pp. 232–246.
Larsen, K. G., U. Nyman and A. Wąsowski, Modal I/O automata for interface and product line theories., in: R. D. Nicola, editor, ESOP, Lecture Notes in Computer Science 4421 (2007), pp. 64–79.
Larsen, K. G., U. Nyman and A. Wąsowski, On modal refinement and consistency, in: L. Caires and
V. T. Vasconcelos, editors, CONCUR, Lecture Notes in Computer Science 4703 (2007), pp. 105–119.
Larsen, K. G., B. Steffen and C. Weise, A constraint oriented proof methodology based on modal transition systems, in: Tools and Algorithms for Construction and Analysis of Systems, 1995, pp. 17–40.
URL citeseer.ist.psu.edu/article/larsen95constraint.html

Larsen, K. G., B. Steffen and C. Weise, Fischer’s protocol revisited: a simple proof using modal constraints, Lecture Notes in Computer Science 1066 (1996), pp. 604–615.
URL citeseer.ist.psu.edu/larsen96fischers.html

Larsen, K. G. and B. Thomsen, A modal process logic, in: Third Annual IEEE Symposium on Logic in Computer Science (LICS) (1988).
Larsen, K. G. and L. Xinxin, Equation solving using modal transition systems, in: Fifth Annual IEEE Symposium on Logics in Computer Science (LICS), 4–7 June 1990, Philadelphia, PA, USA, 1990, pp. 108–117.
Park, D., Concurrency and automata on infinite sequences, in: Proceedings of the 5th GI-Conference on Theoretical Computer Science (1981), pp. 167–183.
Schmidt, H. and H. Fecher, Comparing disjunctive modal transition systems with a one-selecting variant, Submitted for publication (2007).
URL  http://www.informatik.uni-kiel.de/~hf/papers/Fecher07CDMTSO-Sub.pdf
Sipser, M., “Introduction to the Theory of Computation,” International Thomson Publishing, 1996.
Xinxin, L., “Specification and Decomposition in Concurrency,” Ph.D. thesis, Department of Mathematics and Comnputer Science, Aalborg University (1992).
