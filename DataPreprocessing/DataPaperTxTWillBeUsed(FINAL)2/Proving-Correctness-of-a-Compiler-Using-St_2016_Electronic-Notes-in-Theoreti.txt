Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 323 (2016) 197–214
www.elsevier.com/locate/entcs

Proving Correctness of a Compiler Using Step-indexed Logical Relations
Leonardo Rodr´ıguez1 Miguel Pagano2 Daniel Fridlender3
FaMAF
Universidad Nacional de C´ordoba Argentina

Abstract
In this paper we prove the correctness of a compiler for a call-by-name language using step-indexed logical relations and biorthogonality. The source language is an extension of the simply typed lambda-calculus with recursion, and the target language is an extension of the Krivine abstract machine. We formalized the proof in the Coq proof assistant.
Keywords: Compiler verification, proof assistants, biorthogonality, step-indexed logical relations.


Introduction
There are many tools and frameworks available to analyze programs and to prove desirable properties about them, for instance, that they meet their specification. Several methods of static analysis such as program verification, and abstract inter- pretation can be used to lower the chance of letting errors go into deployed programs. However, a machine seldom executes source programs directly. Instead, they are translated into low-level programs with the help of a compiler. Therefore, we must consider the potential errors that the compilation process might introduce: a naive translation of a source program may easily invalidate its properties, making the ef- fort initially invested useless. Dynamic program analysis, such as testing, may help finding errors in the executable code, but it is not enough when it comes to critical systems, which demand greater guarantees of security and reliability. It becomes necessary to prove that the compiler preserves semantics, that is, that the program

1 Email:lrodrig2@famaf.unc.edu.ar
2 Email:mpagano@famaf.unc.edu.ar
3 Email:dfridlender@famaf.unc.edu.ar

http://dx.doi.org/10.1016/j.entcs.2016.06.013
1571-0661/© 2016 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

generated by the compiler behaves exactly as the semantics of the source program indicates.
Since the first proofs of compiler correctness appeared many years ago [20,21], there has been a considerable amount of progress in the topic. Of particular im- portance is the work of the CompCert project [17], a certified compiler for a large subset of the C programming language. In the case of functional languages we can mention [8] which is a certified compiler for the the simply-typed lambda calculus, and [4] where the source language is a call-by-value functional language, and the target is a variant of the SECD machine [16].
In order to prove a compiler correct it is necessary to find a connection between the semantics of the source language and the semantics of the target language. In general, the latter is described operationally: we define which are the instructions available in the machine (a real microprocessor or an abstract machine) and how those instructions modify the configuration as they are executed. On the other hand, there are many ways to describe the semantics of the source language, and the structure of the proof of correctness is highly dependent on which method is used. There are proofs of compiler correctness based on the big-step semantics [9,19], small-step semantics [2], or denotational semantics [4,8] of the source language, among others.
In this work we prove the correctness of a compiler for a typed call-by-name functional language, and the proof is based on the domain-theoretic denotational semantics of the language. The compiler translates a well-typed term of the source language into a list of instructions for the Krivine machine (KAM) [15]. We use step-indexed logical relations [1,3] and biorthogonality [23] to capture the notion of correctness in a compositional and modular way. These two techniques have been used before in combination to obtain proofs of compiler correctness [4,5,12] and also applied in other topics such as program equivalence [11]. As far as we know, no previous work has applied these techniques to prove the correctness of a compiler targeting the KAM and for a call-by-name language.
The approach we follow in this paper has been used before by [4] but applied to a call-by-value language and the SECD machine. In this work we revise the method in such a way that it becomes applicable in a call-by-name language and the KAM machine, and we obtained a simpler definition of the logical relations and a cleaner proof of correctness.
We formalized all the results in the Coq proof assistant, and the code is available online [25]. We used and extended a domain theory library [6] as a basis for the formalization of the semantics and the logical relations.
The rest of the paper is organized as follows. In Section 2 we present the source language and its denotational semantics. We continue in Section 3 with the target language and its operational semantics. We present a general explanation of biorthogonality in Section 4 and then we apply this technique in Section 5 in which we present our first logical relation that we called “denotational approximation”. In Section 6 we introduce step-indexing and some results about its combination with biorthogonality. We apply both biorthogonality and step-indexing in Section

7 to construct the second logical relation called “operational approximation”. We comment on the formalization in Coq in Section 8 and in Section 9 we conclude.
The Source Language
The terms of the source language are the following:
Definition 2.1 (Language terms).
f e t ::= λt | t1 t2 | n | rec t | m | gn (t1,..., tn)
|  (t0, t1) | fst t | snd t | ifz t . tj

Hereafter we use the notation f e t to specify both the set defined by the grammar and our naming convention for meta-variables ranging over it. The first three constructors correspond to the lambda calculus with de Bruijn indices. The language also includes a fixed-point operator, integer constants, strict arithmetic operators, pairs and projections. The last constructor is a conditional projection. We choose this form of conditional for convenience, but a more familiar constructor of the form ifz t then t1 else t2 can be expressed as ifz t . (t1, t2). We write gn to represent any strict arithmetic operator with arity n > 0; operators are written in prefix position and cannot be partially applied.
The type system is rather simple. We have a single basic type int, and also arrow and product types. A context is defined to be a list of types, accordingly with the use of de Bruijn indices.
Definition 2.2 (Types and contexts).
Θ e θ ::= int | θ →θj | θ × θj
Θ∗ e π ::= [] | θ :: π

We present the typing rules for the language in Figure 1, which are quite familiar. The conclusion of a typing rule is a judgment of the form π ▶ t : θ which states that the term t has type θ under the context π.
Denotational Semantics
The denotational semantics of the source language is given in a domain-theoretic setting because of the presence of the fixed-point operator. In this section, and in the rest of the paper, we will follow a traditional treatment of domain theory – for example, we will not comment on how one calculates the supremum of a chain. In contrast, our formalization in Coq is based on a constructive domain theory library [6] where the supremum is given by a function (in Coq’s language).
Before coming to the semantics of the language, we recall some concepts and notations of domain theory. The domain of continuous functions from a domain P



Fig. 1: Typing rules.

to a domain Q is written as [P → Q]. Any set P can be turned into the flat domain P⊥ by adjoining a least element ⊥; this construction can be turned into a Kleisli triple whose unit is ι† : P → P⊥ and its extension operation for a f : P → Q⊥ is given by f∗ ⊥ = ⊥ and f∗ (ι†x)= f x, for x ∈ P . The semantics of strict arithmetic operators are based on abstract considerations: for a total function ⊕ : Z × Z → Z we can get a function ⊕∗ : (Z × Z)⊥ → Z⊥ by ⊕∗ = (ι† · ⊕)∗. Since the denotation of operands will be an unlifted tuple of lifted values, we compose ⊕∗ with the strength, τA,B : A⊥ × B⊥ → (A× B)⊥, to get the function ⊕⊥ = ⊕∗ · τZ,Z; notice that one can apply the same construction for an n-ary operation. Given a function f : P → D from the predomain P to a domain D, we write f⊥⊥ : P⊥ → D for the function such that f⊥⊥ ⊥ = ⊥ and f⊥⊥ (ι† x)= f x, for x ∈ P . If f : D → D is a continuous function over the domain D, then Y D f denotes the least fixed-point of f .
As usual, once we choose a domain for the denotation of atomic types, in our case int, the semantics of arrow types and contexts are determined by the exponentials and finite products of the underlying category.
Definition 2.3 (Semantics of types and contexts).


J int ) = Z⊥
J θ →θj ) = J θ ) → J θj ) 
J θ × θj ) = J θ ) × J θj )
J [] ) = {∗}
J θ :: π ) = J θ ) × J π )


In Figure 2 we present the denotational semantics for typing derivations of the source language. We use the symbol λˆ as a meta-binder to avoid confusion with the symbol λ used in abstractions. Also, if γ is a finite product, we write γ ( n for its
n-th projection. The coherence of this semantics –meaning that different judgments of the same expression have the same denotation– has already been proved for a language even larger than the one we use in this paper [24].



Fig. 2: Denotational semantics.
Semantic Chain
The semantics of a typing judgment can be thought of as the limit of increasingly better defined denotational values. In Figure 3 we define a family of functions J )i, indexed by natural numbers. It is easy to see that J π ▶ t : θ )i ± J π ▶ t : θ )i+1, thus the sequence J π ▶ t : θ )i forms a chain in the domain J π ) → J θ ) and its supremum is J π ▶ t : θ ).
Later we prove that each element of the semantic chain J π ▶ t : θ )i approxi- mates the compiled code for t, a key point in the correctness proof.

The Target Language
The Abstract Machine
We use an abstract machine as our target language. Abstract machines are often used as an idealized model of execution; they are in general simpler than a real machine since they lack certain hardware details that would otherwise complicate the reasoning and the analysis of its behaviour. They are therefore suitable as an intermediate language for compilation [10]. We proceed with the definition of the



Fig. 3: Semantic chain.



components of our machine. The instructions are the following:

Definition 3.1 (Machine instructions).

I e c, cj ::= Grab D c | Push c D cj | Access n
| Fix D c | Pair (c, cj) | Fst | Snd
|  Frame gn | Op | Const m


The first three instructions correspond to the classic KAM that are sufficient to evaluate the pure lambda calculus. We have added new instructions to handle recursion, strict arithmetic operators, pairs, and conditionals. We now define the components of the machine and some meta-variables as follows:

Definition 3.2 (Machine components).

Closures:	Γ e α ::= (c, η)
Environments:	H e η ::= [] | α :: η
Operators:	Ops e gn
Stack values:	M e μ ::= α | [gn m • α] | ⟨α, αj⟩
Stacks:	S e s ::= [] | μ :: s
Configurations: W =Γ × S e w ::= (α, s)

A machine configuration is a pair (α, s) where α is a closure and s is a stack. A closure is alsoa pair (c, η) where c is an instruction and η is a machine environment; which is itself a list of closures. A stack value can be either a closure, a frame, or a pair of closures. We use frames [27] to store the arguments of operators throughout execution: a frame [gn m • α] has three components: the list m of arguments already computed, a hole to indicate the argument that is being computed at the time, and a list α of closures for computing the remaining arguments. The transi- tion rules of the KAM are shown in Figure 4; they define a deterministic relation '—→ ⊆ W ×W . We use the symbol “|” in the rules to help the reader to distinguish the components of the configuration.



Compilation
Now that we have defined both the source and the target language, we present in Figure 5 the compilation function: each well-typed term is mapped into KAM’s code. For a closed term t of type int, we expect that the execution of ((Q t ¢, int, []), []) leads to a configuration ((Const m, η), []) if J ▶ t : int )() = ι† m. In the next sections we will prove that statement.
As a simple example, consider the compilation of the term (λx. x ∗ 2) 3  that with our syntax is written (λ (∗) (0, 2)) 3,

Q (λ (∗) (0, 2)) 3 ¢π, int =
Push (Const 3) D Grab D Push (Const 2) D Push (Access 0) D Frame (∗) .


A step-by-step execution of this code might be useful to understand the transi- tion rules. In particular, this example illustrates how frames are used to compute



Fig. 4: Machine transitions.
the arguments of a strict operator:
Push (Const 3) D Grab D Push (Const 2) D Push (Access 0) D Frame (∗), η, s '—→ Grab D Push (Const 2) D Push (Access 0) D Frame (∗), η, (Const 3, η) :: s  '—→ Push (Const 2) D Push (Access 0) D Frame (∗), (Const 3, η) :: η, s	'—→ Push (Access 0) D Frame (∗), ηj, (Const 2, ηj) :: s where ηj = (Const 3, η) :: η '—→ Frame (∗), ηj, (Access 0, ηj) :: (Const 2, ηj) :: s	'—→
Access 0, ηj, [(∗) • (Const 2, ηj)] :: s	'—→
Const 3, η, [(∗) • (Const 2, ηj)] :: s	'—→
Const 2, ηj, [(∗)3 • ] :: s	'—→
Const 6, ηj, s .



Fig. 5: Compilation function.
Note that, unlike the SECD machine, the Krivine abstract machine does not store the final value in the top of stack. Instead, one has to look at the entire final closure to infer the value computed by the machine. In this example, assuming s = [], the final closure is (Const 6, ηj).

Biorthogonality
Biorthogonality is a well-known technique that has been used in program equiva- lence [23], realizability [14], and compiler correctness [4,12]. The general idea can be explained as follows.
Let S and f be two sets, and |= ⊆ S × f a relation between those two sets. If we think f as a set of tests, and |= as a satisfability relation, then e |= t states whether an element e ∈S satisfies the test t ∈f . Suppose f0 is a subset of f , we write f T for the set of elements that satisfy all the tests in f0:
f T = {e ∈S | for all t ∈ f0, e |= t } .

As a concrete example, if f are formulas and S are models of a particular logic, then f T is the set of models that satisfy all the formulas in f0. We can also define a dual operation to obtain the set of tests that are satisfied by all the elements in a subset S0 ⊆ S :
S⊥ = {t ∈f | for all e ∈ S0, e |= t } .
The operators ⊥ and T are often called orthogonal, and it is a well-known fact that they form an antitone Galois connection [7,22]. As a consequence, the function ( )⊥T : P(S ) → P(S ) is a closure operator for the poset ⟨P(S ), ⊆⟩.

The key point of biorthogonality is that for a given set S0 we can obtain the set
S⊥T which is an extension of S0 that satisfies all the tests in S⊥. That is, we are able
0	0
to extend the set S0 without “losing” any test and hence maintaining the satisfability
relation. In the next section we present the concrete use of biorthogonality that is useful for our purposes.
Denotational Approximation
In this section we prove the correctness of the compiler for terms whose denotation is different from bottom. The strategy is to define a logical relation which states when a denotational value d approximates a closure α at type θ; then we prove the fundamental lemma of logical relations, finally concluding that the compilation of a term is approximated by every element of its semantic chain.
Our logical relation is parameterized over a set of observations of the KAM. Given a set of observations R ⊆ W =Γ × S, we use biorthogonality to define this logical relation – following the terminology of the previous section, we will say that stacks are tests for closures. All the reasoning of this section assumes that R is closed by anti-execution, i.e. (α, s) ∈ R and (αj, sj) '—→∗(α, s) implies (αj, sj) ∈ R; moreover, to keep our reasoning constructive we will also ask for the existence of an “excluded” closure: that is an αˆ such that (αˆ, s) /∈ R for any s ∈ S (a closure that does not satisfy any test). Termination is an example of an observation which is closed by anti-execution and has an excluded closure (think of the compilation of rec λx.x).
The relations Dθ, ►θ⊆ Γ × J θ ) are defined by mutual recursion over types as follows:
Definition 5.1 (Denotational approximation).
α Dθ ⊥ for any closure α ,
(Const m, η) Dint ι† m ,
(Grab D c, η) Dθ → θ′ f   iff   for all α and d, if α ►θ d then (c, α :: η) ►θ′ f d ,
(Pair (c ,c ), η) Dθ × θ′ (d , d )	iff	(c , η) ►θ d and (c , η) ►θ′ d  ,
0  1	0	1	0	0	1	1
α ►θ d	iff	α ∈ Γθ(d)⊥RTR ,	where	Γθ(d)= { α | α Dθ d } .

Let α ∈ Γ and d ∈ J θ ), then α ►θ d is read “d is an approximation of type θ to the closure α” but we often omit the type and just write “d approximates the closure α”. In a sense, the set Γθ(d) contains the closures that are “strongly approximated” by d, and Γθ(d)⊥RTR is the extension of this set obtained through the orthogonal operators. Note that, in this definition, the transitions of the machine are not relevant except in the restrictions we imposed to the set of observations.
We let ⊥ to be an approximation of any closure; this is consistent with the idea of approximation since ⊥ is a value with a minimum amount of information. Since Γθ(⊥) = Γ, by the “excluded closure” assumption, we know Γθ(⊥)⊥R = ∅; consequently s ∈ Γθ(d)⊥R always implies d /= ⊥. The fact that R is closed by

anti-execution leads to the following (trivial) lemma:
Lemma 5.2 Let α, αj ∈ Γ and s, sj ∈ S. If (αj, sj) '—→∗ (α, s), α ►θ d and
s ∈ Γθ(d)⊥R then (αj, sj) ∈ R.
We define a relation ►π between machine-level environments and denotational environments, as a point-wise extension of the ►θ relation.
Definition 5.3 (Denotational approximation for environments).
[] ►[] ()
α :: η ►θ :: π (d, γ)	iff	α ►θ d	and	η ►π γ.

If we follow the general schema of biorthogonality presented before, the elements of Γθ(d)⊥R are the tests that a closure must satisfy to be approximated by the value
d. Since this set depends on the type θ, we can also talk about “tests of type θ” (which is a frequent terminology in the literature about realizability ). In Krivine’s realizability tests of arrow types θ →θj are stacks α :: s where α is a realizer of θ and s is a test of type θj; as the following lemma shows, that is a good characterization in our setting.
Lemma 5.4 Let α ∈ Γ, s ∈ S, f ∈ J θ →θj ), d ∈ J θ ).  If α  ►θ  d and

s ∈ Γθ′
(f d)
⊥R then α :: s ∈ Γθ → θ′ (f )⊥R .

Proof. In order to prove α :: s ∈ Γθ → θ′ (f )⊥R we take αj ∈ Γθ → θ′ (f ) and prove

(αj, α :: s) ∈
R. Since Γθ′
(f d)
⊥R is not empty we know f d /= ⊥ and hence f /= ⊥.

Therefore, we have by inversion that αj is a closure of the form (Grab D c, η) where
η ∈ H and c ∈ I. Moreover, since α ►θ d we have (c, α :: η) ►θ′ f d. Consequently,

since (αj, α :: s) '—→ ((c, α :: η), s) and s ∈
Γθ′
(f d)
⊥R we conclude (αj, α :: s) ∈ R. 

Analogously, it is easy to see that tests for a product type θ × θj can be defined as those stacks having a “projection” at the top followed by a test for the projected type. For the sake of brevity we do not show characterization of tests for int, which can be found in the formalization.
Lemma 5.5 Let s ∈ S, η ∈ H, d0 ∈ J θ ), d1 ∈ J θj ).	If s ∈	Γθ(d0)⊥R

then (Fst, η) :: s ∈ Γθ × θ′ ((d , d ))⊥R . In a similar manner, if s ∈ Γθ′
(d1)
⊥R then

(Snd, η) :: s ∈ Γθ × θ′ ((d , d ))⊥R .
0	1
The next lemma provides various ways to combine closures using machine in- structions, in order to obtain new approximations of different types. This is an important property since it essentially says that we can merge “correct” code frag- ments (potentially generated by different compilers, or hand-written) to obtain a larger code fragment that is also correct.
Lemma 5.6	(i) If (c, η) ►θ → θ′ f and (cj, η) ►θ d, then (Push cj D c, η) ►θ′ f d.
If η ►π γ and n < |π|, then (Access n, η) ►π.n γ ( n.
If (c, η) ►θ → θ f and (Fix D c, η) ►θ d, then (Fix D c, η) ►θ f d.

If (ci, η) ►int di for all i ∈ { 1, ... ,n }, then
(Push cn D . . . D Push c1 D Frame gn, η) ►int gn (d1, ... , dn).

If (c, η) ►θ × θ′ (d , d ), then (Push Fst D c, η) ►θ d
and

(Push Snd D c, η) ►θ′ d .
If (c, η) ►θ × θ (d0, d1) and (cJ, η) ►int d, then
(Push cJ D c, η) ►θ (λˆ z . if z =0 then d0 else d1)⊥⊥ d.
By using Lemma 5.6, we can easily prove that the compilation of a typing derivation is related with every element of its semantic chain.
Lemma 5.7 (Denotational approximation of compiled code) If η	►π	γ
then for all i, (Q t ¢π, θ, η) ►θ J π ▶ t : θ )i γ.
Proof. The proof is by induction in the typing derivation. However, in the case of the fixed-point operator, we need a nested induction over the index i. We now show the proof for that case.
Let c = Q t ¢π, θ → θ, let fi = J π ▶ t : θ →θ )i γ, and di = J π ▶ rec t : θ )i γ. We want to prove (Fix D c, η) ►θ di by induction over i. The case i = 0 is trivial since d0 = ⊥ (and ⊥ is always an approximation). In the inductive case, we assume (Fix D c, η) ►θ di and prove (Fix D c, η) ►θ di+1. We have (c, η) ►θ → θ fi by inductive hypothesis, and hence by Lem. 5.6 we get (Fix D c, η) ►θ → θ fi di = di+1. 
It is possible to relate the compilation of a term directly to its semantics by defining an admissible extension of ►θ; the interested reader is invited to consult this extension in the formalization.
Note that Lemma 5.7 holds for any choice of R that satisfies the two condi- tions we stated before: it must be closed by anti-execution and there must be an excluded closure. In particular, to prove a “standard” version of the compiler cor- rectness theorem for closed terms of type int one fixes the set of observation to be Rm = { w ∈ W | w '—→∗ ((Const m, η), []), for any environment η}.
Lemma 5.8 If t is a closed term, and J [] ▶ t : int ) () = ι† m, then there is some environment η such that ((Q t ¢[], int, []), []) '—→∗ ((Const m, η), []).
Proof. In order to prove this result, we use Lemma 5.7 choosing Rm as the set of observations. We have then (Q t ¢[], int, []) ►int J [] ▶ t : int )i () for all i ∈ N. But since J int ) is a flat domain, there is a j ∈ N such that J [] ▶ t : int )j () = ι† m and hence we have (Q t ¢[], int, []) ►int ι† m. Since [] ∈ Γint(ι† m)⊥Rm , by Lemma 5.2 we have ((Q t ¢[], int, []), []) ∈ Rm, which is what we wanted by the definition of Rm. 
In order to prove a similar lemma for divergent terms we use another logical relation with similar properties.
Step-indexed Logical Relations
To prove the correctness of the compiler for terminating terms it was necessary to relate code fragments with each element of the semantic chain; as the proof of

Lemma 5.7 shows, this allowed us to make a nested induction when considering the case for rec t. If the source language were strong normalizing (i.e., by setting aside the fixed point operator), there would be no need to introduce the semantic chain and correctness would directly relate the compiled code with the semantics of the term.
A more general approach to deal with the subtleties introduced by the recursion operator is using step-indexed logical relations. This method has been used alone and in combination with biorthogonality to obtain proofs of compiler correctness [5,12] and program equivalence [1,11], among other topics. The basic idea is that the logical relation is defined incrementally through a family of relations indexed by natural numbers. Thus, one can prove different properties about this relation using induction in the index. Step-indexing is helpful to capture a notion of approximation at the operational side, analogous to that provided by the semantic chain at the denotational side. In this section we introduce step-indexed families and show some results regarding the combination of these families with the orthogonal operators.
Definition 6.1 (Step-indexed family). A family Ri ⊆ A is step-indexed if R0 = A
and for all i ∈ N, Ri+1 ⊆ Ri.
An example of a step-indexed family over the set of KAM configurations is given by letting Ri be the set of configurations that can make at least i transition steps. While in the previous section we parameterized all the development over a set of observations, in the next section we will work with any step-indexed family of observations closed by anti-execution.
Given a family of observations Ri ⊆ S × f , we can define a binary relation
R ⊆ Sˆ × fˆ over indexed elements Sˆ = N ×S and indexed tests fˆ = N ×f .
Definition 6.2 Let Ri ⊆S × f be an indexed family, then R ⊆ Sˆ × fˆ is given by (i, e) R (j, t) iff (e, t) ∈ Rmin(i,j).
Let us make explicit the definition of the orthogonal operator ( )⊥R for the relation
R:

X⊥R = { (j, t) ∈ fˆ
| for all (i, e) ∈ X, (i, e) R (j, t) } ,

which means that to prove (j, t) ∈ X⊥R one has to check that every element (i, e) in X is related with (j, t) via R. Now we prove that one can simplify the reasoning when Ri is step-indexed.
Definition 6.3 (Down-closed set). For any set S , we say that X ⊆ Sˆ is down-closed if whenever (i, e) ∈ X and j ≤ i, then (j, e) ∈ X.
Lemma 6.4 Let Ri ⊆S × f be step-indexed and X ⊆ Sˆ, then X⊥R is down-closed.
Proof. Let (j, t) ∈ X⊥R and i ≤ j. Suppose (k, e) ∈ X, then (e, t) ∈ Rmin(k,j). Since min(k, i) ≤ min(k, j), we have Rmin(k,j) ⊆ Rmin(k,i) and hence (e, t) ∈ Rmin(k,i). Therefore, (i, e) ∈ X⊥R .	 
As the following lemma shows, when restricted to down-closed sets, one can give a simpler definition of ( )⊥R in which it is only necessary to check those elements

that satisfy i ≤ j.
Lemma 6.5 Let Ri ⊆S × f . If X is down-closed, then


X⊥R = { (j, t) ∈ fˆ
| for all (i, e) ∈ X, i ≤ j implies (e, t) ∈ Ri } .

Since Lemmas 6.4 and 6.5 can also be proved for the operator ( )TR , we can construct an alternative definition of the closure operator.
Lemma 6.6 Let Ri ⊆S × f be step-indexed and X ⊆ Sˆ, then
X⊥RTR = { (j, e) ∈ Sˆ | for all (i, t) ∈ X⊥R , i ≤ j implies (e, t) ∈ Ri } .

Operational Approximation
In this section we define a relation of approximation from machine closures to deno- tational values. In the same vein as in section 5, these relations are defined by means of the closure operator associated to a set of observations. The logical relation is parameterized by a step-indexed family of relations Ri ⊆ Γ ×S satisfying the follow- ing condition: (α, s) ∈ Ri and (αj, sj) '—→ (α, s) imply (αj, sj) ∈ Ri+1. Note that this condition implies that each relation of the family is closed by anti-execution.
This time, instead of working with a single relation of approximation, we define simultaneously two families of relations,  θ, (θ ⊆ Γ×J θ ), indexed by natural num-
i	i
bers. Roughly speaking, the index measures the “accuracy” of the approximation:
the relation becomes finer as the index increases, starting with the total relation at index 0, where every closure approximates every denotation.
Definition 7.1 (Operational approximation).
α  θ d ,
(Const m, η)  int ι† m ,

(Grab D c, η)  θ → θ′
f	iff	for all k ≤ i, if α (θ
d then (c, α :: η) (θ′
f d ,

(Pair (c ,c ), η)  θ × θ′ (d , d )	iff	(c , η) (θ d
and (c , η) (θ′ d  ,

0  1	i	0	1
0	i	0
1	i	1

α (θ
d	iff	(k, α) ∈ Γθ(d)⊥R TR , where Γθ(d)= { (k, α) | α θ
d } .

While in the denotational approximation (Def. 5.1), ⊥ was strongly related with any closure, now ⊥ is strongly approximated by any closure only at level 0. As a consequence, we have (k + 1, α) /∈ Γint(⊥); from this and from the fact that Ri is step-indexed, is easy to show Γint(⊥)⊥R = N × S. This implies that a closure α which approximates ⊥ at every level must be a divergent closure.
Lemma 7.2 Deﬁne Ri = { w | w can make at least i transition steps }. Let α ∈ Γ

such that α (int
⊥ for all k ∈ N, then (α, s) diverges for any stack s.

Proof. Given that Γint(⊥)⊥R = N × S, we have that for any pair (N, s) ∈ N × S it holds (α, s) ∈ RN . That is, (α, s) can make an arbitrarily large number of transition steps.	 

The intuitive interpretation of the indices given above suggests that when α is an approximation at index k, it should also be an approximation at a smaller index j ≤ k. In addition, the approximation relation is monotone with respect to the domain order.
Lemma 7.3 Let α ∈ Γ, d ± dj ∈ J θ ), and j ≤ k. If α  θ d then α  θ dj. Similarly,
k	j
if α (θ d then α (θ dj.
From this lemma we deduce that Γθ(d) is down-closed and monotone: d ± dj

implies Γθ(d) ⊆ Γθ(dj). Moreover the family θk(α)= {d | α (θ
d} is step-indexed

over J θ ), and each θk(α) is closed by suprema of chains.
It is not surprising that we can construct tests for compound types by combining tests for simpler types. Recall that this time “tests” are pairs (k, s) where k ∈ N and s ∈ S. We only show here one way to obtain tests for product types, and there are other possible combinations that can be examined in the formalization.
Lemma 7.4 Let α ∈ Γ, s ∈ S. If α (int ι† 0 and (k, s) ∈ Γθ(d0)⊥R then it

k
θ × θ′	⊥
int

holds (k, α :: s) ∈ Γ	((d0, d1)) R . Similarly, if α (k	ι† m with m /= 0 and
(k, s) ∈ Γθ(d )⊥R then (k, α :: s) ∈ Γθ × θ′ ((d , d ))⊥R .
1	0	1
The following lemma presents the operational counterpart of Lemma 5.6, show- ing that approximations compose well with the constructors of the language. We show the proof only for the fixed point operator.

Lemma 7.5	(i) If (c, η) (θ → θ′
f and (cj, η) (θ
d, then (Push cj D c, η) (θ′
f d.

If η (π
γ and n < |π|, then (Access n, η) (π.n
γ ( n.

If (c, η) (θ → θ
f then (Fix D c, η) (θ
Y J θ ) f.

If (ci, η) (int
di for all i ∈ { 1, ... ,n }, then

(Push cn D . . . D Push c1 D Frame gn, η) (int gn d1, ... , dn.

If (c, η) (θ × θ′ (d , d ), then (Push Fst D c, η) (θ d
and

k	0	1	k	0

(Push Snd D c, η) (θ′
d1.

If (c, η) (θ × θ
(d0, d1) and (cj, η) (int
d, then

(Push cj D c, η) (θ
(λˆ z . if z =0 then d0 else d1)⊥⊥ d.

Proof. Let α = (c, η), let αj = (Fix D c, η), and d = Y J θ )f . Our goal is to

prove that α (θ → θ
f implies αj (θ
d, we proceed by induction over k. The

case k = 0 is trivial since (θ = Γ × J θ ). Now we assume α (θ → θ
f and prove

0	k+1

j	θ
k+1
d. We take (l, s) ∈ Γθ(d)⊥R with l ≤ k + 1, and prove (αj, s) ∈ Rl.

We have two cases depending on whether l ≤ k or l = k + 1. In the first case
we use our inductive hypothesis αj (θ  d to obtain (αj, s) ∈ Rl.  Now assume
l = k + 1. We have (k + 1, s) ∈ Γθ(d)⊥R and hence (k, s) ∈ Γθ(d)⊥R . Since
d = f d we obtain (k, s) ∈ Γθ(f d)⊥R . By inductive hypothesis we have αj (θ d,

and hence (k, αj :: s) ∈ Γθ → θ(f )⊥R . We had α (θ → θ
f by assumption, and hence

(α, αj :: s) ∈ Rk. Since (αj, s) '—→ (α, αj :: s) we obtain (αj, s) ∈ Rk+1 = Rl.	 

The fundamental lemma of the logical relation, which states that the compilation of a typing derivation is an approximation of its semantics, is a direct consequence of Lemma 7.5.
Lemma 7.6 (Operational approximation of compiled code) For all i ∈ N,

if η (π
γ, then (Q t ¢π, θ, η) (θ
J π ▶ t : θ ) γ.

Here the relation (π is defined as a pointwise extension similarly to 5.3. Lemmas
7.6 and 7.2 lead to the following result.
Lemma 7.7 If t is a closed term, and J [] ▶ t : int ) () = ⊥, then the conﬁguration
((Q t ¢[], int, []), s) diverges for any stack s.
Finally, as a consequence of lemmas 5.8 and 7.7, we can state a compiler cor- rectness theorem.
Theorem 7.8 (Compiler correctness) Suppose t is a closed term of type int. If
J [] ▶ t : int ) () = ι† m, then ((Q t ¢[], int, []), []) '—→∗ ((Const m, η), []), for some
η ∈ H. Otherwise, if J [] ▶ t : int ) () = ⊥, then ((Q t ¢[], int, []), []) diverges.

Formalization
All the results presented in this paper has been completely formalized in the proof assistant Coq (version 8.4pl6 with Ssreflect 1.5). The formalization is construc- tive, as we do not assume any classical axiom. We invite the curious reader to download [25] and explore the formalization as it complements the content of this article.
Our formal development is based on a domain-theory library by Benton et al. [6] that provided us with the basis to formalize the denotational semantics of the lan- guage; our formalization would have taken much more time without that library. As useful as it was, we found some shortcomings that we turned into extensions:
The original “extension” function, named kleisli, of the lifting monad has type kleisli : (P → Q⊥) → (P⊥ → Q⊥). This operator is adequate for a call-by- value language; in our setting, however this is not enough, the semantics of the conditional asks for the following operator gkleisli : (P → D) → (P⊥ → D) where D is any pointed cpo (not necessarily obtained through lifting).
A formalization of n-ary morphisms and finite products used to implement the semantics of n-ary operators and to prove some results about them.
A variety of results regarding Cartesian closed categories, cpos and the compu- tation of least upper bounds.
We also extended a formalization of sequences (finite and infinite) originally written in [18]. Our own development (excluding the domain-library) has 6134 lines of code in total, 2096 of which are specifications and 4038 are proofs.

Conclusion and Further Work
We have proved the correctness of a compiler for a call-by-name functional language by means of logical relations defined using biorthogonality and step-indexing. This abstract setting provides a certain degree of flexibility with respect to modifications of the execution environment and it is also modular with respect to the constructors of the language; in particular, the use of step-indexing enabled us to deal with inductive proofs in the presence of recursion.
This approach is similar to [4] but with some important differences due to the order of evaluation (call-by-name instead of call-by-value) and the nature of the abstract machine (KAM rather than the SECD machine). The lack of difference between values and terms in the call-by-name setting turns our logical relations simpler and more intuitive than those in [4]: there is only one kind of approximations on the operational side (closures) and there is no need for a “monadic lifting”. In addition, our definition of the orthogonal operators is simpler since there is no need to parameterize them using environments or any other kind of value.
As future work we plan to extend the source language by enriching the type sys- tem and adding new constructors. For example, in [26] we proved the correctness of a compiler for a higher-order imperative language with respect to the big-step operational semantics of the source language; it would be interesting to obtain a re- lational proof of compiler correctness. We also intend to investigate the application of this technique to lazy functional languages targeting the Sestoft abstract ma- chine [28] or the STG machine [13]. We are also interested in applying the method to other models of execution closer to real assembly code.

References
Ahmed, A., Step-Indexed Syntactic Logical Relations for Recursive and Quantified Types, in: Proceedings of the 15th European Conference on Programming Languages and Systems, ESOP’06 (2006), pp. 69–83.
Appel, A. W. and S. Blazy, Separation Logic for Small-step Cminor, CoRR abs/0707.4389 (2007).
Appel, A. W. and D. McAllester, An Indexed Model of Recursive Types for Foundational Proof-carrying Code, ACM Transactions on Programing Languages and Systems. 23 (2001), pp. 657–683.
Benton, N. and C.-K. Hur, Biorthogonality, Step-indexing and Compiler Correctness, SIGPLAN Not.
44 (2009), pp. 97–108.
Benton, N. and C.-K. Hur, Realizability and Compositional Compiler Correctness for a Polymorphic Language, Technical report, MSR-TR 2010-62, Microsoft Research (2010).
Benton, N., A. Kennedy and C. Varming, Formalizing Domains, Ultrametric Spaces and Semantics of Programming Languages (2010), unpublished.
Birkhoff, G., “Lattice Theory,” American Mathematical Society Colloquium Publications, vol. 25, 1940.
Chlipala, A., A Certified Type-preserving Compiler from Lambda Calculus to Assembly Language, SIGPLAN Not. 42 (2007), pp. 54–65.
Chlipala, A., A Verified Compiler for an Impure Functional Language, in: POPL, 2010, pp. 93–106.
Diehl, S. and P. Sestoft, Abstract Machines for Programming Language Implementation, Future Generation Computer Systems. 16 (2000), pp. 739–751.

Dreyer, D., G. Neis and L. Birkedal, The Impact of Higher-order State and Control Effects on Local Relational Reasoning, SIGPLAN Not. 45 (2010), pp. 143–156.
Jaber, G. and N. Tabareau, The Journey of Biorthogonal Logical Relations to the Realm of Assembly Code, in: Workshop LOLA 2011, Syntax and Semantics of Low Level Languages, Toronto, Canada, 2011, pp. 1–15.
Jones, P. and S. L, Implementing Lazy Functional Languages on Stock Hardware: The Spineless Tagless G-machine, Journal of Functional Programming 2 (1992), p. 127 202.
Krivine, J.-L., Classical Logic, Storage Operators and Second-order Lambda-calculus, Annals of Pure and Applied Logic 68 (1994), pp. 53 – 78.
Krivine, J.-L., A Call-by-name Lambda-calculus Machine, Higher Order Symbolic Computation. 20
(2007), pp. 199–207.
Landin, P. J., The Mechanical Evaluation of Expressions, The Computer Journal 6 (1964), pp. 308–320.
Leroy, X., Formal Verification of a Realistic Compiler, Communications of the ACM 52 (2009), pp. 107– 115.
Leroy, X., Mechanized Semantics - with Applications to Program Proof and Compiler Verification, in:
Logics and Languages for Reliability and Security, IOS Press, 2010 pp. 195–224.
Leroy, X. and H. Grall, Coinductive Big-step Operational Semantics, Information and Computation
207 (2009), pp. 284–304.
McCarthy, J. and J. Painter, Correctness of a Compiler for Arithmetic Expressions, in: Mathematical Aspects of Computer Science 1, 1 19 (1967), pp. 33–41.
Morris, F. L., Advice on Structuring Compilers and Proving them Correct, in: POPL, 1973, pp. 144–152.
Ore, O., Galois Connexions, Transactions of the American Mathematical Society 55 (1944), pp. 493– 513.
Pitts, A. M. and I. D. B. Stark, Operational Reasoning for Functions with Local State, in: A. D. Gordon and A. M. Pitts, editors, Higher Order Operational Techniques in Semantics, Cambridge University Press, New York, NY, USA, 1998 pp. 227–274.
Reynolds, J. C., The Coherence of Languages with Intersection Types, in: Proceedings of the International Conference on Theoretical Aspects of Computer Software, TACS ’91 (1991), pp. 675– 700.
Rodr´ıguez, L., D. Fridlender and M. Pagano, http://cs.famaf.unc.edu.ar/~leorodriguez/ compilercorrectness/, Coq formalization accompanying this paper.
Rodr´ıguez, L., D. Fridlender and M. Pagano, A Certified Extension of the Krivine Machine for a Call-by-Name Higher-Order Imperative Language, in: R. Matthes and A. Schubert, editors, 19th International Conference on Types for Proofs and Programs, Leibniz International Proceedings in Informatics (LIPIcs) 26 (2014), pp. 230–250.
Selinger, P., From Continuation Passing Style to Krivine’s Abstract Machine, Manuscript (2003), available in Peter Selinger’s web site.
Sestoft, P., Deriving a Lazy Abstract Machine, Journal of Functional Programing. 7 (1997), pp. 231–264.
