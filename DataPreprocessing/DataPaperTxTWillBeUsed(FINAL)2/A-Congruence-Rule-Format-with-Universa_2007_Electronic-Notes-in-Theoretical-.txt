	Electronic Notes in Theoretical Computer Science 192 (2007) 109–124	
www.elsevier.com/locate/entcs

A Congruence Rule Format with Universal Quantification
MohammadReza Mousavi a,b,1 ,	Michel Reniers a
a Department of Computer Science, Eindhoven University of Technology, P.O. Box 513, NL-5600 MB Eindhoven, The Netherlands
b Department of Computer Science, Reykjav´ık University, Kringlan 1, IS-103 Reykjav´ık, Iceland


Abstract
We investigate the addition of universal quantification to the meta-theory of Structural Operational Seman- tics (SOS). We study the syntax and semantics of SOS rules extended with universal quantification and propose a congruence rule format for strong bisimilarity that supports this new feature.
Keywords: Structural Operational Semantics (SOS), Universal Quantification, SOS Rule Formats, Bisimulation, Congruence.


Introduction
Structural Operational Semantics (SOS) [14] has been widely used in a variety of forms. Transition System Specification (TSS) [7] is a formalization of SOS which defines a rigorous syntactic and semantic framework for SOS. The notion of TSS paved the way for building up meta-theories around SOS [1,10]; theories about congruence rule formats [7,4] are examples of such meta-theories.
The semantics of a TSS [4,5] comes with an implicit existential quantiﬁcation of valuations of variables used in the rule: if there exists a substitution on variables (appearing in the rule) such that the premises of the rule are satisfied, then the conclusion (with the same substitution applied to it) follows. The following example illustrates this.

1 Corresponding author: m.r.mousavi@tue.nl. The work of this author has been partially supported by the projects “Unifying Framework for Operational Semantics” (nr. 070030041) and “The Equational Logic of Parallel Processes” (nr. 060013021) of The Icelandic Research Fund.

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.08.019

Example 1.1 Consider the following TSS.

(aaa) a →a  a	(aab) a →a  b	(bbb) b →b



(f)
b


x →a y ∧ y ~b f (x) → y

In the aforementioned TSS, it is possible to derive f (a) →c a from (f) using rule (aaa)
since there exists a substitution for x and y, namely, σ(x)= a and σ(y)= a such
that σ(x) →a σ(y) and σ(y) ~b . The semantics of TSS neglects the fact that there is
another substitution σ', with σ'(x)= a and σ'(y)= b such that the premises of (f)
do not hold (which is justiﬁed due to the aforementioned existential quantiﬁcation).
From a purely theoretical viewpoint, there is no reason to only use existential quantification (implicitly) in the premises and it makes sense to study the meta- theory of an SOS framework in which universal quantification over (valuations of) variables is also allowed. Universal quantification in SOS rules appears in practice, too [2,3,11,15]. The following examples illustrate the use of universal quantification in practical instances of operational semantics.
Example 1.2 In [2], the weak termination predicate is characterized as follows:
p √ iff

p ~τ
p →τ
and p√, or
and for each q, p →τ

q implies q √.

A straightforward formalization of this deﬁnition by means of deduction rules gives

x ~τ
∧ x√ x √
x →τ
∧ ∀y(x →
x√√
y ⇒ y √)

By rewriting implication (and negation), this predicate can be conveniently formu- lated in terms of deduction rules as follows:

x ~τ
∧ x√ x √

x →τ
∧ ∀y(x ~
x√√
y ∨ y √)

Example 1.3 Also in [2], semantical divergence p ⇓ is deﬁned formally by


x ↓ ∧∀y(x →τ
x ⇓
y ⇒ y ⇓)
x	y(x ~τ
or by
x ⇓
y ∨ y ⇓)

One may argue that universal quantification in the above examples (and other similar ones such as [15, Definition 33]) can be resolved by a semantics-preserving transformation which replaces universally quantified variables / terms with all their possible instantiations. This is not always desired. In a general framework, universal quantification can indeed be seen as an acronym for a (usually infinite) number of existentially quantified premises and/or rules. However, once due to the restrictions

in the meta-theory, one restricts the framework to a certain form of rules (i.e., a certain congruence rule format such as the NTyft format), this transformation may change the shape of the rules and take the specification beyond the restricted framework.
Hence, it is worth investigating a framework in which universal quantification is genuinely present and study how much of the meta-theory carries over to this setting. This has already been noted in [17, Section 2] where the author writes.
... Moreover, we think it would be a better idea to study a format that allows universal quantification.
This paper takes a step towards the addition of universal quantification to the SOS meta-theory. We slightly extend the syntax of SOS rules with one level of universal quantification. Inspired by examples such as those mentioned before, we also introduce the use of disjunction in the premises of a rule. We define the semantics of such SOS rules as expected. As the main contribution, we propose a congruence rule format for strong bisimilarity that supports these new features. To our knowledge no such format (supporting universal quantification) exists. Our meta-language for SOS rules is still restricted; one may consider a language in which an arbitrary first order predicate formula (thus, an arbitrary mix of existential and universal quantification) is allowed in the premises of deduction rules but this is an extremely complicated problem which we could not tackle in one go.
Universal Quantification in TSS
In this section, we first fix a syntax for TSS’s with universal quantification and then proceed with defining their semantics. There is little novelty concerning the notions presented here; most of the notions can be traced back to those presented in [15,5]. Fix a signature Σ, i.e., a collection of function symbols f , g, ... with fixed arities (natural numbers), ar(f ), ar(g), .. ., and a countable set X = {x, y, z, x0,.. .} of variables. Function symbols a, b, c,... with arity 0 are also called constants. Open terms t, t', ti ∈ T are defined inductively using function symbols and variables (while respecting the arities of function symbols). We denote variables of a term t by	(t).
Closed terms p,q ... C are terms containing no variable. A substitution maps variables to terms and it is closed if its range is a subset of C.
A (transition) clause Φ is defined by the following grammar.

Φ ::= t p t' | t ~p t' | 

i∈I Φi

|  i∈I Φi

We restricted the syntax of clauses as given above to facilitate better presentation; adding implication and negation to the above syntax is straightforward but causes a more complicated presentation, especially for our congruence results.
Clauses of the form t p t' and t ~p t' are called positive and negative (transition) formulae, respectively. The aforementioned formulae are said to deny each other,

denoted by ¬t p t' = t ~p
t' and ¬t ~p t' = t p t'. The formulae 
i∈I Φi
and 
i∈I Φi

denote conjunction and disjunction, respectively, over formulae parameterised by

an index variable i quantified over a possibly infinite index set I. To unclutter presentation we do not treat predicate formulae in our framework (e.g., formulae of the form P (t) or ¬P (t)) but allow for their presence and consider them as transition formulae with dummy labels and targets. The rest of this paper can be re-phrased in the genuine presence of predicate formulae without any substantial change in the formal development of the paper.
We intend to add one level of universal quantification and this suffices for the applications we have encountered thus far in the literature. It seems reasonable to make the already existing and implicit existential quantification in rules explicit. This raises the question as to whether these existentially bound variables are bound outside or inside the universal quantification, i.e., whether the clause should be
augmented as ∃ze0 ∀ze1 Φ or ∀ze1 ∃ze0 Φ where z˜0 represents the set of (formerly implicitly bound) existentially quantified variables. We decided to go for maximum generality in our setting and avoid the design decision altogether. In other words, we allow for disjoint sets of existentially quantified variables appearing before as well as after the
universal quantification. Of course, the ultimate goal would be to have a general first order language and allow for all sorts of nested quantifiers.
Another decision we made is to write the quantifiers in front of the deduction rules since they may also apply to the occurrences of the quantified variables in the target of the conclusion.
A TSS is a set of deduction rules of the form
Φ
(r) ∃ze0 ∀ze1 ∃ze2  ,

where z˜0, z˜1, and z˜2 stand for sets of variables, Φ is a transition clause and φ is a positive formula. Clause Φ is called the premises (each formula appearing in Φ is called a premise) and φ is a positive formula which is called the conclusion of deduc- tion rule (r). Assume that φ = t p t'; we call t the source of the above deduction rule. A deduction rule (TSS) without universal quantification and disjunction is called a traditional deduction rule (TSS). For such traditional deduction rules one can represent the conjunction of transition formulae as a set (as we do in Definition 2.3 below). To avoid any ambiguity we assume that V(r) ⊆ V(t) ∪ z˜0 ∪ z˜1 ∪ z˜2 (where V(r) denotes all variables appearing in the premises and the conclusion of the deduction rule (r)) and assume that V(t), z˜0, z˜1 and z˜2 are all pairwise disjoint. We decided to quantify on valuations of variables only since intuitively, quan- tification over valuations of (open) terms reduces to quantification over variables.
In the remainder of this paper, for better presentation, we assume that premises

are in the disjunctive normal form, i.e., of the form 

i∈I

j∈J
φij where I and J

are index sets, and φij is a positive or negative formula. Note that in the absence
of universal quantification, a rule with a number of disjuncts as premises can be represented by a number of rules; one for each disjunct. However, in the presence of universal quantification, this cannot be done because ∀z(φ ∨ ψ) is not equivalent to (∀zφ) ∨ (∀zψ).

Example 2.1 The weak termination operator of Example 1.2 is rephrased in our syntax as follows.

x ~τ
∀y
y ∧ x√
√	∃y' ∀y

(x →τ
y' ∧ x ~τ

y) ∨ (x →τ
x√√
y' ∧ y √)

Example 2.2 The semantical divergence of Example 1.3 can be rewritten into the following extended TSS.


(x ↓ ∧x ~τ
∀y
y) ∨ (x ↓ ∧y ⇓)
x ⇓


Extended TSS: Semantics
Semantics of extended TSS’s do not defer much from traditional TSS’s. In [4,5], the following notion of three-valued stable model is defined for closed traditional TSS’s, i.e., TSS’s containing only traditional deduction rules which do not contain any variable.

Φ
Definition 2.3 (Proof ) A traditional deduction rule
φ
Φ
is provable from a closed

traditional TSS R, denoted by R ▶
, when there exists a well-founded upwardly
φ

branching tree with formulae as nodes and of which
the root is labeled by φ;
if a node is labeled by ψ and the nodes above it form the set K then one of the following two cases hold:

ψ ∈ Φ and K = ∅;
ψ is a positive transition formula and
K
ψ ∈ R.

When the TSS is known from the context, we omit it from the notation and just write ▶ Φ .

Definition 2.4 (Truth) A negative transition formula φ = p ~l
p' is true for a

set PF of positive formulae, denoted by PF ▶ φ when p →l p' ∈/ PF. A set NF 
of negative formulae is true for the set PF, denoted by PF ▶ NF when for all
φ ∈ NF, PF ▶ φ.
Definition 2.5 (Three-Valued Stable Models) A pair (C, U ) of sets of posi- tive closed formulae (where C stands for Certain and U for Unknown; the third value is determined by the formulae not in U) is called a three-valued stable model for a TSS when C ⊆ U and
N

for all φ ∈ C, ▶
U ▶ N;
 for a set N of negative closed transition formulae such that
φ

for all φ ∈ U, ▶
C ▶ N.
N
 for a set N of negative closed transition formulae such that
φ

In [16,5], it has been shown that every TSS admits a least three-valued stable model with respect to the information theoretic ordering (i.e., (C, U ) ≤ (C',U ') when C ⊆ C' and U ' ⊆ U ). A TSS is called complete [5] (or positive after reduction [4]) if for its least three-valued stable model (C, U ), C = U .
To define the semantics of traditional TSS’s in general, one has to instantiate the deduction rules with all closing substitutions and then use the above definition on the resulting closed TSS. A similar approach, as suggested in [15], can be used to define a meaning for TSS’s with universal quantifiers. First, each rule is replaced with a number of traditional rules, of which the premises contain all possible instan- tiations for the universally quantified variables and some instance of the existentially quantified ones (for each instance of the universally quantified variables, similar to the idea of Skolemization). Second, the remaining variables, i.e., the variables in the source of the conclusion, are instantiated with all possible substitutions resulting in a closed traditional TSS. The following definitions formalize this idea.
Definition 2.6 For a traditional deduction rule r = Φ , its closure, cl (r) is the set of deduction rules	σ(Φ)	σ : X	C . Closure of a traditional TSS R, denoted by
 σ(φ)
cl (R) is deﬁned by	r∈R cl (r). The semantics of R is deﬁned by the semantics of
cl (R).
For each deduction rule r of the following form,



(r)∃ze0 ∀ze1 ∃ze2
i∈I
j∈J l '
φij

t → t
sk(r) is the set of all deduction rules sk(r, σ0, σ10,... , σ20,... , i0,... | ij) for each substitution σ0 : z˜0 → C, series of substitutions σ10, σ11,... : z˜1 → C such that for each variable z ∈ z˜1, {σ10(z), σ11(z),.. .} = C, series of substitutions σ20, σ21,... : z˜2 → C, series of indices i0, i1,... ∈ I and each ij ∈ {i0, i1,.. .} which is deﬁned as
follows.
( j∈J σ0 · σ10 · σ20(φi0 j )) ∧ ( j∈J σ0 · σ11 · σ21(φi1 j )) ∧ ... 



σ · σ	· σ	(t →l
t')

In the above deduction rule · denotes function composition and it binds stronger than function application. If any of the sets z˜i (for each i ∈ {0, 1, 2}) is empty then one should drop all σij (σi, for i = 0) from the deﬁnition of sk(r). Also in the case of I = ∅, all ij components should be dropped from the deﬁnition of sk(r).
Note that the above deduction rule is traditional and hence, sets of such deduction rules can be given a semantics using traditional ways of assigning meaning to TSS’s. The meaning of a TSS R with universal quantiﬁcation is deﬁned as the meaning of

r∈R
sk(r).

The following simple example illustrates the semantics of extended TSS’s.

Example 2.7 Consider the following TSS.
(aaa) a →a  a	(aab) a →a  b	(bab) b →a  b	(bbb) b →b  b

x ~a y ∨ y →b z

(f)∀y∃z
f (x) →c c

Assume A = {(aaa), (aab), (bab), (bbb)}; it holds that A = r∈A sk(r), i.e., since deduction rules in A do not contain quantiﬁed variables, their Skolemization yields the same deduction rules. However, (f) contains a universally quantiﬁed variable y and an existentially quantiﬁed variable z. (In terms of the notation used in Deﬁni-

a
tion 2.6, z˜ = ∅, z˜ = {y} and z˜ = {z}.) Let φ = x ~ y and φ
= y →b
z; sk(f ) is

0	1	2	0	1
deﬁned as follows.

{(sk(f, σ

= [y '→ p

],σ 

= [z '→ p
],... ,i ,i ,... , i))  j∈IN σ1j · σ2j (φij ) |

10	10	20
20	0  1
f (x) →c c

∀k∈{0,1},l∈IN pkl ∈ C ∧ {p10, p11,.. .} = C ∧ il ∈ {0, 1}∧ i ∈ {0, 1}}


For example, sk(f, σ10, σ20,... , i0,... , i) where ij = 0, for each j ∈ IN (for arbitrary i, σ1j and σ2j) is the following deduction rule.
  p∈C x ~a p
f (x) →c c
The least three-valued stable model of the TSS is the pair (C, U ) where C = U =
a	a	a	b	c
{a → a, a → b, b → b, b → b, f (p) → c | p ∈ C \ {a}}. Hence, the TSS is complete.

Universal NTyft
Bisimilarity and Congruence
Strong bisimulation [12], as defined below, is a key notion of behavioral equivalence in concurrency theory.
Definition 3.1 (Bisimulation and Bisimilarity)  A symmetric relation R ⊆ C× C is a bisimulation relation when for all p, q ∈ C such that p R q, l ∈ C, and p' ∈ C,
if p →l p' then there exists a q', q →l q' and p' R q'.
Two closed terms p and q are bisimilar, denoted by p ↔ q, when there exists a bisimulation relation R such that p R q.
To treat bisimilarity compositionally and algebraically, it is essential to make sure that it is a congruence relation, i.e., one can replace equals by equals.

Definition 3.2 (Congruence) An equivalence relation R is a congruence w.r.t. a function symbol f (with an arbitrary arity n), when for all −→p , −→q , if −→p R −→q then f (−→p ) R f (−→q ). R is a congruence w.r.t. a signature Σ when it is a congruence for all function symbols f ∈ Σ.

Rule Format and Its Proof
In this section, the rule format is defined that should guarantee congruence of bisimilarity and this is proven.
Definition 3.3 (Variable Dependency Ordering) For a deduction rule r of the
'

W	V	li	V
' lj  '

 k∈K ( i∈Ik ti → yi∧ j∈Jk tj ~ yj )
form (r)∃ ∀ ∃	, the variable dependency ordering
t → t
<r is the smallest relation containing all pairs (u, yi) and (u', y' ) where u ∈ V(ti)
and u' ∈ V(t' ) for each i ∈ Ik, j ∈ Jk and k ∈ K.
A deduction rule (TSS) is well-founded if the variable dependency ordering of the rule is (all its deduction rules are) well-founded.
Definition 3.4 (UNTyft/UNTyxt) A deduction rule of the following form

'
(	t l  y ∧	t' lj y' )
~

(r)∃ze0 ∀ze1 ∃ze2
,
t →l t'

is in the UNTyft format when it satisﬁes the following conditions:
t is of the form f (−→x );

∀i,i'∈S
I yi /= yi' ∧ yi ∈/ V(t) and ∀j,j'∈S
J y' /= y' ' ∧ y' ∈/ V(t) (targets of



positive and negative transition formulae are all distinct variables and are all
different from variables in the source of the conclusion);
z˜1 ∩ {yi | i ∈ Ik,k ∈ K} = ∅ (universally quantiﬁed variables cannot appear as targets of positive premises)

{y' | j ∈ Jk,k ∈ K}⊆ z˜1 (all targets of negative premises should be universally quantiﬁed);
∀z∈ze0 ∀k∈K∀i∈Ik z = yi ⇒ ∀u∈ze1∪ze2 ¬(u <r z) (if an existentially quantiﬁed variable in z˜0 appears in the target of a premise, then it does not depend on variables among those in z˜1 or z˜2).
A deduction rule of the above form is in the UNTyxt rule format when t is of the form x and it satisﬁes items (ii)-(v).
A TSS is in the UNTyft(/UNTyxt) format when all its deduction rules are.
An immediate question that comes to mind is how the UNTyft format compares to the NTyft format. It is not hard to see that the UNTyft format extends the NTyft formats (by taking sets K to be a singleton, z˜0 to be ∅ and z˜1 to be {yj | j ∈ Jk,k ∈ K}, one obtains the NTyft format). In terms of expressive power, i.e., the set of definable transition relations, the following example shows that the UNTyft format

is strictly more expressive than the NTyft format. (The example is essentially taken from [9, Example 4.9].)
Example 3.5 (UNTyft vs. NTyft)




	
a	a


∃y' ,y'' ∀y,z
(x →a y' ∧ x ~a y) ∨ (x →a y'' ∧ y ~b z)

c

a → d	b → d	b → c	c → d	f (x) → d

The above TSS is in the UNTyft format, it is complete and its three-valued stable
model is C = P = {a →a d, b →a d, b →a c, c →b d, f (a) →c d}. We claim that there is no
TSS in the NTyft format that deﬁnes the above three-valued stable model. Assuming that such a TSS does exist (without loss of generality, we can assume that the TSS
is pure), consider a minimal proof for f (a) →c d ∈ C (a minimal proof is a proof
in which no formula appears more than once in a branch of the proof tree); using the same deduction rule leading to this proof and a new substitution, we prove that

f (b) →c
d (contradiction).
c


pi	pj

Assume that the proof for f (a)	d is due the rule (r){ti → yi|i∈I}	{tj ~|j∈J} and
f (x) → t
there exists a substitution σ such that σ(x)= a and σ(t)= d. The premises of such a rule may be of one of the following shapes:
x →a yi or a →a yi, for some i ∈ I,
b →a yi, for some i ∈ I,
ti →b yi or c →b yi, where σ(ti)= c and i ∈ I,

tj ~a
tj ~b
tj ~c
where tj can be an arbitrary term but a, b or x, and j ∈ J, where tj can be any term such that σ(tj) /= c, and j ∈ J,
where tj can be any term but f (a) or f (x) and j ∈ J, (these two cases

are excluded since otherwise, f (a) →c
d cannot be included in C),

Note that f (x) or f (a) cannot be in the source of a positive premise because the
label of such a premise should be a c and then the proof of f (a) →c d due to (r) is
not minimal and there is a smaller proof which is the proof of such a premise. Also, given the above forms, the target of the conclusion, i.e. t, should either be d or some yl such that σ(yl)= d.
'	'	.	'
Deﬁne σ as follows: σ (x) = b, σ (y)= σ(y), for all variables y /= x. Then, all
positive premises (items 1 to 3 above) must have a proof (for they are all included in the C component of the least well-supported model). For the negative premises, there is no case where substituting a b for an a may enable a- or b-transitions. Similarly, substituting a b for an a may disable c-transitions but may not enable them. Hence,
we obtain a proof for σ'(f (x) →c t), i.e. f (b) →c d.
Theorem 3.6 For a complete and well-founded TSS in the UNTyft/UNTyxt format bisimilarity is a congruence.

Proof. We prove the theorem for a TSS in the UNTyft format. For deduction rules in the UNTyxt format essentially the same proof technique can be adopted. We use the following auxiliary definition for our inductive proof.
Definition 3.7 (Reduction Technique for SOS with Negative Premises) For an ordinal α, deﬁne:

.	N
Cα = {φ |▶ φ
.	N
Uα = {φ |▶ φ
∧ ∃β<αUβ ▶ N }
∧ ∀β<αCβ ▶ N }
N

It follows from the above two items that C0 = ∅, U0 = {φ |▶ φ }.
It follows from Tarski’s fixpoint theorem (observing that Cα ⊆ Cβ and Uβ ⊆ Uα for α ≤ β) that the above reduction procedure will reach a fixpoint at an ordinal, say λ and it follows from the above definition that (Cλ, Uλ) is indeed the least three-valued stable model.
Define R to be the smallest congruence containing the bisimilarity ↔ associated with the TSS in the UNTyft format. If we show that R is a bisimulation relation, then the theorem follows. Instead, by an induction on α, we simultaneously prove that the following two statements hold for each (p, q) ∈ R, for each l, p' ∈ C, and for each α.

p →l
p →l
p' ∈ Cα ⇒ ∃q' q →l
p' ∈ Uλ ⇒ ∃q' q →l
q' ∈ Cλ ∧ (p', q') ∈ R;
q' ∈ Uα ∧ (p', q') ∈ R;

Once we prove the above two statements, the transfer conditions for bisimulation (w.r.t. Cλ = Uλ) follow by taking α to be λ and from the fact that Cλ = Uλ (due to completeness of the TSS under consideration).
Note that bisimilarity is an equivalence and so is R; thus, we assume the sym- metric statements for q without having to prove them. The above statements hold trivially for all p and q such that p   q. Hence, we focus on terms of the form p = f (−→p ) and q = f (−→q ) where −→p R −→q .

N
It follows from Definition 3.7 that ▶ p →l
for some N and some β < α such
p'

that Uβ ▶ N , and from Definition 3.4 that there exists a deduction rule r of
the following form


'
(	t l  y ∧	t' lj y' )
~

(r)∃ze0 ∀ze1 ∃ze2
,
t →l t'


and (according to Definition 2.6) there exist substitutions σp : V(−→x ) → C and σ0 : z˜0 → C such that σp(−→x )= −→p and for all substitutions σ1 : z˜1 → C, there exists a substitution σσ1 : z˜2 → C and an index k ∈ K, such that all positive formulae with indices i and j with i ∈ Ik and j ∈ Jk under σ = σp · σ0 · σ1 · σσ1

	Ni	
hold, i.e., ▶
with a smaller proof structure and N
⊆ N for each

σ(t
li y )

i → i
lj
i ∈ I , and σ(t'	y' ) ∈ N for each negative premise j ∈ J . We proceed with
k	j	j	k
N
an induction on the proof structure for ▶ p →l p' .
In a traditional proof method for congruence rule formats (e.g., that of [7]), one aims at defining a new substitution σ' such that σ'(−→x ) = −→q and σ(u) R σ'(u) for each variable u X; furthermore, while completing the def- inition of σ', one shows, using the induction hypothesis, that all the premises
also hold under σ', thus, obtaining a proof for q →l q', for some q' such that
σ(t') R q' and q' = σ'(t'). Our proof method is slightly more involved. Since we have a universal quantification over variables in z˜1, we are allowed to use the fact that under all substitutions σ1 : z˜1 → C at least one disjunct among the premises holds by choosing an appropriate σσ1 . Thus, during the construction of σ', as explained below, we also change substitution σ into some σ'' = σp · σ0 · σ'' · σσ'' (by choosing a σ'' which is appropriate for our proof obligation),
while preserving σ''(u) R σ'(u). Note that σ and σ'' agree on the variables in
z˜0. Furthermore, σ and σ' agree on the variables in z˜1.
Let σq : V(−→x ) → C be such that σq(−→x ) = −→q . Given σ0 and for each σ1
as given above, we aim at constructing new substitutions σ' , σ'' and σ'	such
0	1	σ1
that σ''(z1) R σ1(z1) and σ''(u) R σ'(u) for each z1 ∈ z˜1 and for each u ∈ X
where σ'' = σp · σ0 · σ'' · σσ'' and σ' = σq · σ' · σ1 · σ' . Note that σσ'' need not
be re-defined; given σ'', it is determined by the deduction rule chosen to derive
p →l p' according to Definition 2.6, i.e., if σ'' = σ , for some j ∈ IN, σ '' is σ .
1j	2j

To define σ' and σ'', we start with σ'
1
where σ'
σ1
= σ(u) for each variable

in u ∈ (z˜0 ∪ z˜2) \ {yi, yj | i ∈ Ik' ,j ∈ Jk' , k' ∈ K} and undefined otherwise, and
a substitution σ'' such that σ'' = σ(u) for each variable in u ∈ z˜1 \ {yj | j ∈

Jk' , k' ∈ K}.
1i
and σ''
and a variable u such that for each variable

x preceding u in the variable dependency graph either σ' (x) or σ'' (x) is de-
1i	1i
fined. Furthermore, we assume that for all such variables x, σ''(x) R σ'(x)

where σ'
= σq · σ1 · σ' , σ''
= σp · σ0 · ρi · σρ
i
and ρi = σ1 ↑ σ''
i
where

(σ1 ↑ σ'' )(x)= σ'' (x) if σ'' (x) is defined and σ1(x) otherwise.
We define a procedure which takes any such variable u and substitutions

' and σ'' and defines the substitution σ'
which agrees with σ'  on the

domain of σ'  and extends the domain of σ'
with u, if u ∈ z˜0 ∪ z˜2 in such

a way that σ''(u) R σ'
Furthermore, if u ∈ z˜1, we define a value for

''
1i+1
)(u), in such a way that σ'' (u) R ρ(σ1)(u), thus in both cases maintaining

σ''	R σ'	(u). If u ∈ z˜1, then σ'	is the same as σ' ; if u ∈/ z˜1, then σ''
is the same as σ'' . Then, substitutions σ' and σ'' are defined as the greatest
fixed point of the chain σ'’s and σ''’s (taking the above-mentioned procedure
i	i
as a monotone function, with the subset relation on the union of the domains

of the substitutions σ' and σ''
as the ordering).

i	1i
We make a case distinction based on the status of variable u with respect

to set z˜0, z˜1 and z˜2. (We shall still use an induction on α and inside that an induction on the structure of the proof in the following items.)
Assume that u ∈ z˜0 ∪ z˜2; then, u can only be a variable yi' for some i' ∈ Ik
and k ∈ K (i.e., the target of a positive premise). We distinguish the
''	li'
following two cases based on the status of σi (ti' → yi' ) with respect to Cα.
''	li'	l  '
Assume that σi (ti' → yi' ) is among the premises of the rule proving σ(t → t ),
''	li'
i.e., σi (ti' → yi' ) ∈ Cα with a proof structure which is smaller than the
proof of σ(t →l t'). Considering that σ''(t ' ) R σ'(t' ), the induction hypoth-

i	i	i  i

'	li'

esis on the structure of the proof applies and we have that σi(ti' ) → qi' ∈
Cλ for some qi such that σ(u) R qi'  (and thus, σ''(u) R qi).	Define

'
1i+1
(u) = qi.

''	li'	l  '

Otherwise, assume that σi (ti' → yi' ) is not in the proof tree for σ(t → t ).
Take σ'	(u)= σ(u).
Note that since u ∈/ z˜1, in both cases σ''	= σ''.
Assume that u ∈ z˜1; then, u = yj, for some j ∈ Jk and k ∈ K. We
distinguish the following two cases.
lj
Either ∃	∀	σ(y ) R p  ⇒ σ''(t )	p  ∈/ U ; it follows from the
induction hypothesis (on α; contraposition of item (ii)) that σ'(t ) lj p ∈/

Uλ. Define σ''
(u) = σ(u).
i  j  → j

lj
Or ∀	∃	σ(y ) R p  ∧ σ''(t )	p
∈ U . It follows from the fact that

for all γ ≤ γ', U ' ⊆ U
lj
that ∃	∀	σ(y ) R p  ∧ σ''(t )	p ∈ U .

γ	γ
Define σ''	(u)= pj.
pj	β<α	j
j	i	j → j	β

This way, we have completed the definition of σ' and σ''. There is a k ∈ K

such that for all i' ∈ Ik, σ''
li'
(ti' → yi' ) ∈ Cα and it follows from the construc-

tion of σ' that σ'(t
li y ) ∈ C . Furthermore, it holds for all j ∈ J  that

σ''(t
lj
y ) ∈/ U
, for some β ≤ α. It again follows from the above construc-

tion of σ'' that σ''(t
lj
p ) ∈/ U
for all p
such that σ(u )= σ'(u ) R p  and

hence, σ'(t
lj
p ) ∈/ U
. This completes the proof for q →l
σ'(t') ∈ C
and we

have that σ''(t) R σ'(t).
The case is dual to the above case. One just has to replace the sets Cα with
Uλ and Cλ with Uα, simultaneously.


(Counter-)Examples
In this section, we give a few (counter-)examples witnessing the generality of our rule format. First, we show that our format is general enough to cover our motivating examples.
Example 3.8 The deduction rules for weak termination and divergence as speciﬁed,

respectively, in Examples 2.1 and 2.2 are in the UNTyft/UNTyxt format.
Next, we show that the syntactic constraints concerning the UNTyft format can- not be simply dropped or the congruence meta-result will be ruined. The first condi- tion in the UNTyft format concerns the source of the conclusion and it is among the conditions of the ordinary Tyft and NTyft formats. Thus, counter-examples given in [7,6] work in this case, as well. Constraint (ii) is about distinctness of variables appearing as targets of premises. Our addition to the traditional constraints of the NTyft format is that we prohibited the repetition of target variables among differ- ent disjuncts. The following counter-example shows that this additional constraint cannot be dropped.
Example 3.9 The following speciﬁcation conforms to all constraints of the UNTyft format but constraint (ii) in that variable y is repeated in the target of the premises of the left-most deduction rule. Moreover, it is complete and is well-founded.


x ~a y ∨ x ~b y
∀y	c	a


b	a	b

f (x) → c	a → a	a → a	b → a	b → b

For the above speciﬁcation, it holds that a ↔ b but it does not hold that f (a) ↔ f (b)
since ∀y b ~a y ∨ b ~b y but it does not hold that ∀y a ~a y ∨ a ~b y, namely a →a a and
a →b a.
Constraint (iii) states that universally quantified variables cannot appear as
targets of positive premises. The following counter-example shows the role of this constraint in establishing congruence.
Example 3.10 The following TSS is complete and well-founded and satisﬁes all constraints of the UNTyft format but constraint (iii).



∃x	a


a	a	a
x →a y
∀y	c

a → x	b → a	b → c	b → f (a)	f (x) → a


It holds for the above TSS that a	b but f (a) c
ple, b ~a b).
a while f (b) ~c
a (since, for exam-

The fourth syntactic constraint states that targets of negative premises should be universally quantified. The following counter-example witnesses that this constraint cannot be dropped.
Example 3.11 The following deduction rules satisfy the constraints of the UNTyft format apart from constraint (iv) in that the negative premise x ~a y has an existen- tially quantiﬁed variable y as its target.

a →a c	a →a c'	b →a c	c →b c	c' →b c



∃y,y',y''
x ~a y	y →b

y'	x →a y''
a

f (x) → c

The above TSS is complete and its associated transition relation is


a	a  '	a	b	' b	a
{a → c, a → c ,b → c, c → c, c → c, f (b) → c}.


Hence, we observe that a ↔ b but it does not hold that f (a) ↔ f (b). Thus, bisimi- larity is not a congruence.
The last constraint on the UNTyft format concerns the variables in z˜0 when they appear as a target of a premise. Namely, such variables should not depend on variables in z˜1 or z˜2 (in the sense of Definition 3.3). The first counter-example given below shows that a direct dependency on variables in z˜1 can be damaging. The second counter-example shows the same for a direct dependency on variables in z˜2. Both counter-examples can be easily adapted for indirect dependencies.
Example 3.12 The following deduction rules satisfy the constraints of the UNTyft format apart from constraint (v) in that variable z0 depends on a universally bound variable z1 in deduction rule (g).


(a) a →a b	(b) b →a a	(g)∃z0 ∀z1
f (z1, x) →b z0 g(x) →c c




(f0)∀y ∃y
x ~a y
x1 → y1
(f1)∃y ,y
x0 → y0
x1 → y1

0	1
f (x ,x ) → y

0  1
f (x ,x ) → a



First of all note that a ↔ b because they only afford a-transitions to each other.
Furthermore, from (f0), it follows that for all p ∈/ {a, b}, we have f (p, a) →b b and
f (p, b) →b a. Thirdly, from (f1), we can deduce that f (a, b) →b a and f (b, b) →b a.
Thus, we conclude that for all p ∈ C, f (p, b) →b a. Hence, we have that g(b) →c c.
It does not hold that for all p ∈ C, f (p, a) →b p' for any p' ∈ C; the only possible
candidates for such p' are a and b both of which fail (above-mentioned transitions to a cannot be derived from (f0) and transitions to b cannot be derived from (f1)).
Hence, we have that g(a) ~c  which shows that the congruence result is ruined.
Example 3.13 The following TSS is a modiﬁed version of the one speciﬁed in Example 3.12. The deduction rules satisfy the constraints of the UNTyft/UNTyxt format apart from constraint (v) in that variable z0 depends on an existentially

bound variable z2.


(a) a →a b	(b) b →a a	(x) x →d x




(f0)∀y ∃y
x ~a y
x1 → y1
(f1)∃y ,y
x0 → y0
x1 → y1

0	1
f (x ,x ) → y

0  1
f (x ,x ) → a

0	1	1	0	1

z1 →d z2	f (z2, x) →b z0

(g)∃z0 ∀z1 ∃z2


g(x) →c c

The transition relation induced by the above TSS is the same as the one in Example
3.12 except for that it also includes a d-self-loop on all closed terms. Thus, a ↔ b
and it does not hold that g(a) ↔ g(b).

Conclusions
Results. We extended the syntax and the semantics of SOS specifications with one level of universal quantification, explicit notions of existential quantification (before and after the universal quantifier), conjunction and disjunction. We proposed a rule format with the above-mentioned features that guarantees the induced bisimilarity to be a congruence.
Future Work. From a theoretical viewpoint, a much more challenging goal is to introduce a framework supporting the full first-order logic. We plan to investigate the possibility of relaxing the well-foundedness assumption in our congruence meta- results. Expressiveness of the UNTyft rule format with respect to the NTyft and the Tyft format is another topic for our future research. Our main point of inspiration for the introduction of universal quantification originated from our study of ordered SOS [13,8]. There, we observed that in order to translate general Tyft rules with ordering into the NTyft format, we need some extra expressive power, possibly modeled by universal quantification over variables. Otherwise, the ordered version of the Tyft format is strictly more expressive that the NTyft format and a direct translation (involving no auxiliary operators) is shown to be impossible in [9]. It remains thus to show that the UNTyft format indeed gives us sufficient expressive power to remove ordering from ordered Tyft rules.
Acknowledgments. Constructive discussions with Iain Phillips and Irek Ulidowski led to research questions which form the subject matter of this paper. Comments of the anonymous reviewers of the SOS workshop helped us improve the paper and are thus acknowledged.

References
Aceto, L., W. J. Fokkink and C. Verhoef, Structural operational semantics, in: J. A. Bergstra, A. Ponse and S. A. Smolka, editors, Handbook of Process Algebra, Chapter 3, pp. 197–292.

Aceto, L. and M. Hennessy, Termination, deadlock, and divergence, Journal of the ACM (JACM) 39
(1992), pp. 147–187.
Baeten, J. C. M. and J. A. Bergstra, Processen en procesexpressies, Informatie 30 (1988), pp. 177–248, (In Dutch).
Bol, R. and J. F. Groote, The meaning of negative premises in transition system specifications, Journal of the ACM (JACM) 43 (1996), pp. 863–914.
van Glabbeek, R. J., The meaning of negative premises in transition system specifications II, Journal of Logic and Algebraic Programming (JLAP) 60-61 (2004), pp. 229–258.
Groote, J. F., Transition system specifications with negative premises, Theoretical Computer Science (TCS) 118 (1993), pp. 263–299.
Groote, J. F. and F. W. Vaandrager, Structured operational semantics and bisimulation as a congruence, Information and Computation (I&C) 100 (1992), pp. 202–260.
Mousavi, M., I. C. C. Phillips, M. A. Reniers and I. Ulidowski, The meaning of ordered SOS, in: Proceedings of the 26th Conference on Foundations of Software Technology and Theoretical Computer Science (FSTTCS’06), Lecture Notes in Computer Science 4337 (2006), pp. 334–345.
Mousavi, M., I. C. C. Phillips, M. A. Reniers and I. Ulidowski, Semantics and expressiveness of ordered SOS, Technical Report CSR-07-07, Department of Computer Science, Eindhoven University of Technology, Eindhoven, The Netherlands (2007).
Mousavi, M., M. A. Reniers and J. F. Groote, SOS formats and meta-theory: 20 years after, Theoretical Computer Science (TCS) 373 (2007), pp. 238–272.
Mousavi, M., M. Sirjani and F. Arbab, Formal semantics and analysis of component connectors in Reo, in: Proceedings of the 4th International Workshop on the Foundations of Coordination Languages and Software Architectures (FOCLASA’05), Electronic Notes in Theoretical Computer Science 154, 2006, pp. 83–99.
Park, D. M., Concurrency and automata on infinite sequences, in: Proceedings of the 5th GI Conference, Lecture Notes in Computer Science 104, pp. 167–183.
Phillips, I. C. C. and I. Ulidowski, Ordered SOS rules and process languages for branching and eager bisimulations, Information and Computation (I&C) 178 (2002), pp. 180–213.
Plotkin, G. D., The origins of structural operational semantics, Journal of Logic and Algebraic Programming (JLAP) 60 (2004), pp. 3–15.
van de Pol, J., Operational semantics of rewriting with priorities, Theoretical Computer Science (TCS)
200 (1998), pp. 289–312.
Przymusinski, T. C., The well-founded semantics coincides with the three-valued stable semantics, Fundamenta Informaticae 13 (1990), pp. 445–463.
Verhoef, C., A congruence theorem for structured operational semantics with predicates and negative premises, Nordic Journal of Computing 2 (1995), pp. 274–302.
