

Electronic Notes in Theoretical Computer Science 256 (2009) 49–65
www.elsevier.com/locate/entcs

Representing Model Theory in a Type-Theoretical Logical Framework
Fulya Horozal and Florian Rabe
Jacobs University Bremen, Germany

Abstract
We give a comprehensive formal representation of first-order logic using the recently developed module system for the Twelf implementation of the Edinburgh Logical Framework LF. The module system places strong emphasis on signature morphisms as the main primitive concept, which makes it particularly useful to reason about structural translations, which occur frequently in proof and model theory.
Syntax and proof theory are encoded in the usual way using LF’s higher order abstract syntax and judgments-as-types paradigm, but using the module system to treat all connectives and quantifiers in- dependently. The diﬃculty is to reason about the model theory, for which the mathematical foundation in which the models are expressed must be encoded itself. We choose a variant of Martin-Löf’s type theory as this foundation and use it to axiomatize first-order model theoretic semantics. Then we can encode the soundness proof as a signature morphism from the proof theory to the model theory. We extend our results to models given in terms of set theory using an encoding of Zermelo-Fraenkel set theory in LF and giving a signature morphism from Martin-Löf type theory into it. These encodings can be checked mechanically by Twelf.
Our results demonstrate the feasibility of comprehensively formalizing large scale representation theorems and thus promise significant future applications.
Keywords: Logical Frameworks, First-Order Logic,Model Theory and Module Systems.

Introduction
Since the foundational crisis of mathematics logic has been an important research topic in mathematics and computer science. A central issue has always been what a logic actually is. Important research results to answer this question are logical frameworks – abstract formalisms that permit the formal definition of specific logics.
Today we observe that there are two groups of logical frameworks: those based on set theoretical foundations of mathematics that characterize logics model theoret- ically, and those based on type theoretical foundations that characterize logics proof theoretically. The former go back to Tarski’s view of consequence ([26,28]) with in- stitutions ([8,9]) and general logics ([15]) being the most important examples. The latter are usually based on the Curry-Howard correspondence ([5,11]), examples being Automath ([6]), Isabelle ([20]), and the Edinburgh Logical Framework (LF, [10]).

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.11.005

While some model-theoretical frameworks attempt to integrate proof theory (e.g., [15,16,7]), the opposite integration is less developed. This is unfortunate because many of the results and techniques developed for proof theoretical logics could also benefit model-theoretical reasoning. We are particularly interested in logic encodings in LF, which is related to Martin-Löf type theory (MLTT). These represent syntax and proof theoretical semantics of a logic using higher order abstract syntax and the judgments-as-types paradigm ([18]). This has proved very successful for proof- theoretical logic representations ([21,13,1,19]).
In [23], we introduced a framework that attempts to preserve and exploit the respective advantages of model and proof theoretical representation. The central idea is to also represent the model theory of a logic in a type-theoretical logical framework by axiomatizing models and the interpretation of formulas using MLTT as a meta-language.
In this paper we show how to implement such logic representations in LF. We pick LF because we have recently equipped the Twelf implementation of LF with a strong module system [24]. This module system is rigorously based on theory morphisms, which have proved very successful to reason about model-theoretical logic representations (e.g., [8,2,25]). Therefore, it is particularly appropriate for the modular development of syntax, proof theory, and models, and the translations between them.
In Sect. 2, we describe the Twelf system and its module system, and in Sect. 3, we describe how logics are represented in it. Our main result is the full representation of first-order logic (FOL) in Sect. 4: It comprises syntax, proof theory, model theory, and soundness proof of first-order logic, all of which use the module system to treat all connectives and quantifiers independently. In particular, the soundness is verified mechanically by Twelf. In Sect. 5, we go one step further: We discuss how to encode both Zermelo-Fraenkel set theory (ZFC) and a translation from MLTT to ZFC in LF. Thus, we can represent set-theoretical models as LF theory morphisms and reason about them within the logical framework.
The Twelf System
The Twelf system is an implementation of the logical framework LF designed as a meta-language for the representation of deductive systems. It is a dependent type theory with typed terms and kinded type families.
Kinds:	K	::= type | A → K
Type families: A, B ::= a | A M | Πx:AB | A → B
Objects:	M, N ::= c | x | λx:AM | M N 
Twelf features the dependent product type constructor Πx:AB and its introduc- tory axiom, the λ-binder λx:AM . As usual, application is written as juxtaposition M N . A → B abbreviates Πx:AB if x does not occur freely in B. Type families are kinded by kinds, where types are the type families kinded by type, and objects are typed by types.

Twelf signatures contain declarations of type- or object-level constants. Con- stants are declared in the form of declarations a : K or c : A, or definitions a : K = A or c : A = M . Variables x : A are typed, never kinded.
The Twelf module system permits one to use multiple named signatures that can be related via inheritance, i.e., structures, and translations, i.e., views. Readers fa- miliar with modular theory development languages such as development graphs ([2]) will recognize structures as definitional theory morphisms and views as postulated theory morphisms.
Since we will focus on concrete encodings, we will use Twelf’s concrete syntax as given below. Keywords are introduced with % and precede all declarations except for constant declarations. A modular Twelf specification is a sequence of signature declarations DT and view declarations Dv. Signatures are sequences of constant declarations Dc, structure declarations Ds and signature inclusions DI . Similarly, views are sequences of assignments to constants and structures.
Start :	S	::= DT  | Dv
Signatures :	DT  ::= % sig T  = { (Dc  | Ds  | DI )∗ }.
Views :	Dv	 ::= % view v : S -> T = { (c := C | % struct s := μ)∗ }. Inclusions :	DI	::= % include T .
Constants :	Dc	::= c : C . | c : C = C .
Structures :	 Ds	::= % struct s : S = { (c := C . | % struct s := μ.)∗ }. Terms :	 C	 ::= type | c | x | C -> C | C C | {x:C } C | [x:C ] C Morphisms :	μ		::= v | s | μ μ
Finally, there are two classes of expressions. Firstly, terms are normal LF ex- pressions where the Π-binder is written with braces {} and the λ-binder with square brackets []. Secondly, morphisms are expressions that translate between signatures: Each structure s or view v induces a signature morphism, and the juxtaposition μ μ' of morphisms represents their diagram-order composition. Morphisms preserve all judgments regarding well-formedness, typing, and equality (see [13,24] for the preservation results).
A view declaration encodes a translation between two signatures. A view occurs on toplevel and gives domain and codomain explicitly. It must instantiate all con- stants (except those that have definitions) of the domain signature with expressions of the codomain signature. This induces a signature morphism in the obvious way. A structure declaration %struct s : S = {} occurring in the signature T rep- resents an inheritance relation from S to T : It adds a copy of S to T . The copied constants are accessible by qualified names formed by prefixing the structure name. Then the declaration of a structure s induces a signature morphism from the instan- tiated signature S to its containing signature, which maps every constant c of S to
s.c. A structure declaration may also carry assignments, which are used to translate
S when copying it into T .
For example, consider the following signature declarations, which we will reuse later on. Base contains a type o for formulas and an o-indexed type family ded. This type family exemplifies how logic encodings in LF represent judgments as types and derivations as objects: Objects of type ded A represent derivations of the judgment “A is true”.

The signature NEG encodes the negation con- nective by inheriting from Base with a structure called base and adding the constant ¬ encoding the unary negation connective. Then the signature NEGPF encodes natural deduction style proof rules for it. Firstly, it inherits from Base and NEG where the instantiation %struct base := base. in the structure neg works as follows: The left side of the

% sig Base = { o	: type .
ded : o - > type .
}.
% sig NEG = {
% struct base : Base .
¬ : base . o -> base . o.
}.

instantiation is a symbol declared in the domain signature – here: NEG – and the right side is an expression over the codomain signature – here: NEGPF. This instanti- ation has the effect of a sharing declaration: The two structures base and neg.base inheriting from Base are identified. Secondly, it declares the constants notI and notE encoding the introduction and the elimination rule of negation.
Here we have used qualified structure names: The structure neg.base is a mor- phism from Base to NEGPF; it is an abbreviation of the composition of the morphism induced by the structure base of NEG and the morphism induced by the structure neg of NEGPF.
% sig NEGPF = {
% struct base : Base .
% struct neg	: NEG = {% struct base := base .}.
notI : ( base . ded A -> { B} base . ded B) -> base . ded ( neg .¬ A). notE : base . ded A -> base . ded ( neg .¬ A) -> { B} base . ded B.
}.
Note that we use implicit arguments: Upper case free variables in declarations are
assumed be implicitly Π-bound on the outside. This has the effect of free parameters. For example, in notE, the variable A is free. The verbal reading of the rule is “For any A, if A is true and ¬A is true, then for all B we have B is true ”.
Twelf computes the semantics of the modular signatures by elaborating them to the non-modular syntax. For example, NEGPF is by definition equivalent to the signature NEGPF2, where all the constants inherited via the structures base and neg are elaborated with their qualified names.
% sig NEGPF2 = {
base . o	: type .
base . ded	: base . o -> type .
neg . base . o	: type	= base . o. neg . base . ded : neg . base . o -> type = base . ded . neg .¬	: neg . base . o -> neg . base . o.
notI : ( base . ded A -> { B} base . ded B) -> base . ded ( neg .¬ A). notE : base . ded ( neg .¬ A) -> base . ded A - > { B} base . ded B.
}.
A special case of the inheritance relation is the include declaration. The decla-
ration %include S occurring in T creates an inclusion from S to T . This is similar to a structure declaration but simpler and less expressive. If a signature is included in multiple ways, all inclusions are identified. Therefore, a symbol c included from S into T is identified uniquely by the name S..c.

A Logical Framework Combining Proof and Model Theory

Since the structuring concepts of the Twelf module system are based on signature morphisms, we can obtain very elegant encodings of mathematical concepts that are defined in terms of signature morphisms. One example is the logical framework we gave in [23].
A representation of a logic L in this framework consists

of three signatures: Lsyn for the syntax, Lpf for the proof theory, and Lmod for the model theory. These are related by signature morphisms that translate from Lsyn to the others as in the diagram on the right. The morphism lpf is typically just an inclusion; this is in keeping with the practice of logic encodings in LF where syntax and proof theory are closely


Lsyn





lmod
Lpf




Lmod

related. The morphism lmod interprets the syntax in the semantic realm. In partic-
ular, lmod maps o to a type encoding the set of truth values of L. Therefore, Lmod must contain an encoding of the mathematical foundation in which the models are expressed, which makes lmod typically more complicated than lpf .
For example, for propositional logic with only negation, Lsyn and Lpf could be respectively the signatures NEG and NEGPF from Sect. 2. lpf would be the morphism induced by the structure neg of NEGPF. Lmod could be a signature formalizing the two-element boolean lattice. Note that this formalization might be carried out in some other logic, e.g., first-order logic, which would have to be included in Lmod. Alternatively, Lmod could include a full axiomatization of set theory; then lmod could map base.o to the set {0, 1}.
A specific theory Σ of L is represented as

an extension of L. This corresponds to the uniform logic encodings in LF given in [13]. For example, signatures of propositional logic are sets of propositional variables, and the set
Σ = {p ,...,p } is encoded as the LF-signature


Lsyn





lmod
Lpf

Σsyn

mod
Σpf




mod

1	n	L	 Σ
Lsyn, p1 : o, ..., pn : o.  The corresponding
extensions Σpf and Σmod of Lpf and Lmod lead to the diagram on the right.
With two further assumptions, it becomes possible to represent all aspects of L in LF: Lsyn should contain a type o and a type family ded : o → type, which have the same intuition as explained for the signature Base in Sect. 2.
Then Σ-sentences are represented as β-η-normal LF-terms of type o over the signature Σsyn. Σ-proofs of A using assumptions A1,..., An are represented as β- η-normal LF-terms over Σpf of type lpf (ded A1 → ... → ded An → ded A) where lpf (−) denotes morphism application.
Σ-models are represented as LF-models of the signature Σmod. Such a model I interprets all types A as sets [A]I and all terms s of type A as elements [s]I ∈ [A]I . The details can be found in [23] and [3]. Finally, the satisfaction I |=Σ A of the Σ-sentence A in the Σ-model I is represented by the condition [ded A]I /= ∅.

Note how the type ded A is used to represent truth both proof- and model- theoretically. Proof-theoretically, elements of type ded A represent proofs of A. And model-theoretically, and [ded] : [o] → Set acts as a predicate on the set of truth values singling out the designated truth values: A truth value v is designated iff [ded](v) /= ∅.
A particular strength of this framework is that soundness can be represented very naturally: A soundness proof of L is represented as a view from Lpf to Lmod that makes the diagram above commute. In the language of category theory ([14]), Σpf and Σmod arise as pushouts along the inclusion Lsyn → Σsyn. (The category of LF- signatures has pushouts along inclusions.) This implies that a signature morphism from Lpf to Lmod induces one from Σpf to Σmod thus proving soundness for all theories of L.

Representing First-Order Logic
As described in Sect. 3, the encoding of FOL consists of three main LF signatures:
FOL for the syntax, FOLPF for the proof theory, and FOLMOD for the semantics.
A specific theory Σ of FOL is a list of function and predicate symbols and axioms. Therefore, theories can be encoded naturally in LF by extending FOL with declarations of the form f : i → ... → i → i for function symbols, f : i → ... → i → o for predicate symbols, and a : ded F for axioms where the types i and o of FOL represent the universe and the sentences of FOL.
We will describe the signature FOL in Sect. 4.1, FOLPF in Sect. 4.2, and FOLMOD in Sect.4.4. To describe the semantics of first-order logic, we need a meta-language in which the models are expressed. In less formal descriptions, this meta-language is usually natural language implicitly based on some set-theoretical foundation of mathematics. Here we use a variant of Martin-Löf type theory [17], which we refer to as MLTT, as a simple formal language that is expressive enough to define the semantics of first-order logic. Therefore, we give the encoding of MLTT in Sect. 4.3 before we are able to define FOLMOD. Finally, we encode the soundness of FOL, i.e., the fact that any formula derived from the FOL proof theory is valid w.r.t. the FOL semantics, by giving a view from FOLPF to FOLMOD in Sect. 4.5.


Syntax
We encode the signature FOL mod- ularly, where each logical connective and quantifier is declared in a sep-


Base	BaseFOL
			

arate Twelf signature. The modular
representation of FOL is illustrated as a diagram in Fig. 1. Each node in
NEG
DISJ	Forall
	
PL	FOL
Exists

this diagram corresponds to a signa-
ture declaration in Twelf, and each
Fig. 1: Modular Encoding of FOL Syntax

edge corresponds to a structure. For example, the edge between Base and NEG
represents a structure declared in NEG that imports Base into NEG. For the sake of

simplicity, we use only negation (¬) and disjunction (∨) as primitive connectives in this paper. In our Twelf encoding, we declare all connectives as primitive connectives except for equivalence.
The signature Base introduces a

type o for propositions and a type fam- ily ded : o → type for the proofs of propositions. ¬ and ∨ are declared in the signatures NEG and DISJ, respec- tively. NEG and DISJ copy the content of Base via a structure – named as base locally in both signatures – so that o can be used in the declaration of ¬ and ∨.
The keyword %open provides syn- tactic sugar to avoid qualified names. Without %open o one would have to re-
% sig Base = { o	: type .
ded : o - > type .
}.
% sig NEG = {
% struct base : Base	% open o.
¬ : o -> o.
}.
% sig DISJ = {
% struct base : Base	% open o.
∨ : o -> o - > o.	% infix ∨.
}.

fer to the type o as base.o. The keyword %infix permits to declare a constant as infix. %infix requires arguments for the associativity and precedence, which we omit here simply because they are not relevant.
Then we import Base, NEG and DISJ into the signature PL via the structures base, neg and disj, respectively, as shown below. This gives us an encoding of the PL syntax. In neg and disj, the assignment %struct base := base. maps the structure base of NEG and base of DISJ, respectively, to the structure base of PL. This assignment allows us to identify the copies of Base that are imported from NEG and DISJ with the copy of Base that is imported by the structure base of PL.
% sig PL = {
% struct base : Base .
% struct neg	: NEG	= {% struct base := base .}.
% struct disj : DISJ = {% struct base := base .}.
}.


In the signature BaseFOL, we import Base and introduce a type i for the individuals of FOL. The universal quantifier ∀ and the existential quantifier ∃ are declared in the signatures Forall and Exists, respectively. BaseFOL is imported to both Forall and Exists so that i and o can be used to de- clare the quantifiers.
Finally, we define FOL based on the signa- tures BaseFOL, PL, Forall and Exists. Once again, we identify the multiple imports of signatures into FOL using structure assign- ments. These signatures are Base imported

% sig BaseFOL = {
% struct base : Base . i : type .
}.
% sig Forall = {
% struct basefol : BaseFOL 
% open base . o i.
∀ : ( i -> o) -> o.
}.
% sig Exists = {
% struct basefol : BaseFOL 
% open base . o i.
∃ : ( i -> o) -> o.
}.

from BaseFOL and PL, and BaseFOL imported from Forall and Exists.

% sig FOL = {
% struct basefol : BaseFOL .
% struct pl	: PL	= {% struct base	:= basefol . base .}.
% struct univq	: Forall	= {% struct basefol := basefol .}.
% struct existq	: Exists	= {% struct basefol := basefol .}.
}.


Proof Theory
The encoding of the signa- ture FOLPF follows the modu- larity in the encoding of FOL:


BasePF	BaseFOLPF
			

We define a separate signature
for the natural deduction style
NEGPF

DISJPF	ForallPF
	
ExistsPF


proof rules of each logical con-
nective and quantifier. This is illustrated in Fig. 2.
% sig BasePF = {
% struct base : Base .
PLPF	FOLPF
Fig. 2: Modular Encoding of FOL Proof Rules

}.
% sig BaseFOLPF = {
% struct basepf	: BasePF .
% struct basefol : BaseFOL = {% struct base := basepf . base .}.
}.
The signature BasePF is a copy of the signature Base to carry over the constants
o and ded to the encoding proof theory. Similarly, the signature BaseFOLPF imports the signature BaseFOL to carry over i to the encoding of proof theory, and extends BasePF to first-order. We distinguish these signatures anyway because of the con- ceptual clarity. (The analogues of BasePF in the encodings of other logics do contain additional declarations, e.g., the structural rules of sequent style calculi.)
The signatures NEGPF, DISJPF, ForallPF and ExistsPF encode the introduction and elimination rules for ¬, ∨, ∀ and ∃, respectively. They extend the respective node in Fig. 1 that declares the corresponding logical symbol by adding the proof rules.
We use the well-known encoding of FOL natural deduction rules in LF, see e.g. [10]. Therefore, we only present the rules for negation as an example.
% sig NEGPF = {
% struct basepf : BasePF % open base . ded .
% struct neg	: NEG = {% struct base := basepf . base .}	% open ¬. notI	: ( ded A -> { B} ded B) -> ded (¬ A).
notE	: ded A -> ded (¬ A) -> {B} ded B. 
}.
The signature PLPF imports all the signatures in which the proof rules for the
logical connectives are declared, and adds the law of excluded middle.
% sig PLPF = {
% struct basepf : BasePF .
% struct negpf	: NEGPF	= {% struct basepf := basepf .}.

% struct disjpf : DISJPF = {% struct basepf := basepf .}. tnd : ded ( A ∨ (¬ A )).
}.
The signature FOLPF extends PLPF by importing the signatures for the proof rules
of the quantifiers. The multiple copies of signatures are identified to one specific copy using structure assignments.
% sig FOLPF = {
% struct basefolpf : BaseFOLPF .
% struct plpf	: PLPF	= {
% struct basepf	:= basefolpf . basepf .}
% struct forallpf	: ForallPF	= {% struct basefolpf := basefolpf .}.
% struct existspf	: ExistsPF	= {% struct basefolpf := basefolpf .}.
}.
Note that our encodings in [12] factor out tertium non datur into a separate
signature so that we can distinguish intuitionistic and classical reasoning. We skip this here because we focus on classical model theory.
Martin-Löf Type Theory
The abstract syntax for MLTT is given below.

Types A, B, C . . .	::= a s1 ... sn | id(s, t) | unit | void | A + B | Σx:AB | Πx:AB
Terms s, t, s1, s2,... ::= x | c | refl(s) | ∗ | !!A | inj1(s) | inj2(s) | case(s, s1, s2)
|  (s, t) | π1(s) | π2(s) | λx:St | s t 

We use the following type constructors: the application of type-valued constants a s1 ... sn, extensional identity type id(s, t) for terms s and t of the same type, unit type unit, disjoint union A + B, dependent product types Σx:AB, and dependent function types Πx:AB. As usual Σx:AB and Πx:AB are written as A×B and A → B, respectively, if the variable x does not occur freely in B. In addition, MLTT adds an empty type void, and a negation type −A defined as an abbreviation for A → void. The term constructors are constants c, variables x, the element ∗ of the unit type, functions !!A from void to any type A, the element refl(s) of the type id(s, s), injections inj1(s) and inj2(s) of s into a union type, case distinctions case(s, s1, s2) (where s : A1 + A2 and si : Ai → B), pairs (s, t), projections π1(s) and π2(s) for a
pair s, λ-abstractions λx:At, and function applications s t.
Thus, our type theory corresponds to intuitionistic first-order logic via the Curry- Howard correspondence. The addition of the empty type to express negation is crucial to reason about model theory. For example, without negation, it would be impossible to express the condition that models must be consistent, i.e., may not interpret all formulas as truths.

Our encoding of MLTT uses the module system to treat all type constructors independently as illustrated in Fig. 3. In this paper, we will omit the straight- forward but technical encoding of equality of types and the substi- tution of equal terms.
TT
IDENT UNIT VOID	UNION PI SIGMA MLTT
Fig. 3: Modular Encoding of MLTT

In the signature TT, we introduce a type tp for types and a type family tm for terms. The encoding uses intrin- sic typing, i.e., the intuition of the LF-type tm A is that its LF-terms encode the MLTT-terms of MLTT-type A.
As an example, we give the encoding of dependent sum types, which is encoded in the signature SIGMA. The Σ-

% sig TT = { tp : type .
tm : tp -> type .
}.

binder is encoded using higher-order abstract syntax: S’ ([x: tm A] B) encodes the type Σx:AB where [x : tm A] B is an LF function representing an MLTT-type B with a free variable of MLTT-type A. The constants pair, pi1 and pi2 encode the usual introduction and elimination rules for dependent sum types (see, e.g., [17]).
% sig SIGMA = {
% struct TT : TT % open tp tm. S’	: ( tm A -> tp) -> tp.
pair : { a : tm A} tm ( B a) -> tm (S’ [ x] ( B x )).
pi1	: tm ( S’ [ x : tm A] ( B x)) -> tm A.
pi2	: { u : tm ( S’ [ x : tm A] ( B x ))} tm ( B ( pi1 u )).
}.
Similarly, the other type constructors are encoded in the signatures IDENT, UNIT,
VOID, UNION, and PI. The types id(s, t), unit, void, A + B, and Πx:AB are encoded as the LF-terms s ==’ t, unit, void, A +’ B, and P’ [x: tm A] B, respectively. Note that all type constructors are primed in Twelf. This is because we will use the unprimed variants as abbreviations later. Finally, we merge all these signatures into the signature MLTT in the same way as for FOL and FOLPF.



Model Theory
In this section, we define the model theory of FOL in Twelf. We follow the same modular-


BaseMOD	BaseFOLMOD
			

ity (see Fig. 4) as in the en-
coding of the FOL syntax and
NEGMOD

DISJMOD ForallMOD
	
ExistsMOD


proof theory. We use MLTT
as the meta-language for the model theory.	Therefore, all
PLMOD	FOLMOD
Fig. 4: Modular Encoding of the Model Theory

signatures that encode the model theory start with the declaration %include MLTT.
in order to include the signature MLTT.

In BaseMOD, we declare the con- stant o’ as an MLTT-type of propo- sitions. We encode the truth val- ues 1 and 0 as terms of MLTT-type o’, i.e., LF-type tm o’. The MLTT- type family ded’ acts as a judgment on truth values: desig1 makes 1 a designated truth value, and desig0 makes 0 non-designated. 0 being non-designated means that a model

% sig BaseMOD = {
% include MLTT % open tm tp. o’	: tp. 
1	: tm o ’.
0	: tm o ’.
ded ’	: tm o’ -> tp. desig1 : tm ( ded ’ 1). desig0 : tm -’ ( ded ’ 0).
boole	: {A} (A == ’ 1 + A == ’ 0).
}.

must interpret ded’ 0 as the empty set because otherwise it could not interpret void as the empty set. Given a proposition A, boole returns the proof of the fact that A is equal to either 1 or 0. This encodes that truth values are the elements of the set
{1, 0}. Note that we use unprimed type constructors as abbreviations for prefixing
tm. For example, A + B abbreviates tm (A +’ B), void abbreviates tm void’, and
-A abbreviates tm (-’ A).
In BaseFOLMOD, we extend BaseMOD

with the MLTT-type i’ for individuals. The interpretation of this type is the uni- verse of a FOL model. Then we declare non_empty_universe, which is an axiom stating the non-emptiness of the universe. This is provable in usual first-order axiom-
% sig BaseFOLMOD = {
% include MLTT % open tm tp.
% struct basemod : BaseMOD . i’ : tp. non_empty_universe : tm i ’.
}.

atizations because they permit arbitrary variables and thus representatives of ele-
ments of the universe. However, it must be added explicitly in encodings within a framework like LF, which only permits those variables that are in the current – possibly empty – context.
For all signatures of Fig. 1, there are morphisms into their counterparts in Fig. 4. For NEGMOD, DISJMOD, ForallMOD and ExistsMOD, these morphisms are induced by structure declarations. For the signatures BaseMOD and BaseFOLMOD, these are given by the following two views, which interpret the constants o, ded and i in terms of o’, ded’, and i’. Note that the view BaseFOLMODView reuses the translation of o and ded by using the view BaseMODView in the assignment to base. This has the effect that the rectangle made up of the morphism compositions base BaseFOLMODView and BaseMODView basemod commutes.
% view BaseMODView : Base -> BaseMOD = { o := tm o ’.
ded := [ A] tm ( ded ’ A).
}.
% view BaseFOLMODView : BaseFOL - > BaseFOLMOD = {
% struct base := BaseMODView basemod . i := tm i ’.
}.
For each logical connective and quantifier, the semantics is encoded by declaring
two terms: One to encode when a formula containing the connective or quantifier is

interpreted as true, i.e., when it is equal to the LF-term 1, and one to encode when the formula is interpreted as false, i.e., when it is equal to the LF-term 0.
As examples, we give the signatures NEGMOD and ForallMOD below. They are based on BaseMOD and BaseFOLMOD, respectively, and reuse the above views when importing from their counterparts NEG and Forall. not1 axiomatizes that ¬A is true if A is false, and not0 axiomatizes that ¬A is false if A is true. Similarly, forall1 and forall0 axiomatize the semantics of ∀. In the latter, the dependent product and sum types are used as meta-level universal and existential quantifiers: For example, the type P ([x] (F x) ==’ 1) is inhabited iff for all x the type (F x) ==’ 1 is inhabited, and thus encodes the judgment that the truth value of F (x) is 1 for all values of x.
% sig NEGMOD = {
% include MLTT % open == ’.
% struct basemod : BaseMOD % open 1 0.
% struct neg	: NEG = {% struct base := BaseMODView basemod } % open ¬. not1 : A == 0 -> (¬ A) == 1.
not0 : A == 1 -> (¬ A) == 0.
}.
% sig ForallMOD = {
% include MLTT % open == ’ P’ S ’.
% struct basefolmod : BaseFOLMOD % open 1 0.
% struct univq	: Forall = {
% struct basefol	:= BaseFOLMODView basefolmod .} % open ∀. forall1 : P ([ x] ( F x) == ’ 1) -> (∀ [ x] F x) == 1.
forall0 : S ([ x] ( F x) == ’ 0) -> (∀ [ x] F x) == 0.
}.
Finally, these signatures can be merged into PLMOD and FOLMOD in the same way
as for syntax and proof theory above, e.g.:
% sig FOLMOD = {
% include MLTT .
% struct basefolmod : BaseFOLMOD .
% struct plmod	: PLMOD = {% struct basemod := basefolmod . basemod .}.
% struct univq	: ForallMOD = {% struct basefolmod := basefolmod .}.
% struct existq	: ExistsMOD = {% struct basefolmod := basefolmod .}.
}.




Soundness
A view v : S → T from a signature S to a signature T maps every symbol s in S to an expression t in T , where the typing relation is preserved. The homomorphic extension of v maps all S-expressions (i.e., terms, types and kinds) to T -expressions. This means that a term s : A of S is translated to a term v(s) : v(A) in T .
We encode the soundness of FOL by means of a view from FOLPF to FOLMOD. This encoding follows the same modularity we used in order to encode the proof and model theory, i.e., we give separate views from each signature for proof theory in Fig. 2 to the respective signature for model theory in Fig. 4.

This is illustrated in Fig. 5 for the soundness of PL. The left and right diamonds in the diagram il-
BasePF SoundBase BaseMOD SoundNEG

lustrate the encoding of proof and
NEGPF
DISJPF
NEGMOD
DISJMOD

model theory, respectively, using
single arrows to denote structures and double arrows to denote the
PLPF
SoundDISJ SoundPL
PLMOD

views.
For the sake of simplicity, we
Fig. 5: Modular Encoding of Views for PL

present the view SoundPL; the view from FOLPF to FOLMOD is encoded in a similar way. SoundPL encodes the soundness of PL by interpreting all expressions in PLPF in terms of the expressions in PLMOD. PLPF consists of expressions that come from BasePF, NEGPF and DISJPF, which are interpreted in BaseMOD, NEGMOD and DISJMOD via the views SoundBase, SoundNEG and SoundDISJ, respectively. Then SoundPL can be pieced together as follows, where we omit the proof of the law of excluded middle for brevity.
% view SoundPL : PLPF -> PLMOD = {
% struct basepf	:= SoundBase basemod .
% struct negpf	:= SoundNEG negmod .
% struct disjpf	 := SoundDISJ disjmod . tnd	:= ...
}.
To see how this works, we explain the view

SoundNEG in detail.	The view SoundPL uses this view in the assignment %struct negpf :=
BasePF  BaseMOD SoundBase

SoundNEG negmod.. Its semantics is that negpf
basepf
basemod

as mapped by SoundPL is intended to be equal
NEGPF SoundNEG NEGMOD

to the composition of the view SoundNEG and the structure negmod. This corresponds to the
negpf
negmod

commutativity of the lower rectangle in the dia-
gram above. In general, the Twelf implementa- tion checks all the preconditions that are neces- sary to guarantee the commutativity.
PLPF
SoundPL
PLMOD

SoundNEG interprets all the expressions of NEGPF, i.e., the structures basepf, neg and the terms notI and notE, in terms of the expressions of NEGMOD. The view SoundBase interprets BasePF in BaseMOD. This interpretation is carried over to NEGMOD via the composed morphism SoundBase basemod. Then the structure basepf is mapped to SoundBase basemod, which ensures the commutativity of the upper rectangle in the diagram on the right. The structure neg is mapped to the signature neg in NEGMOD.
% view SoundNEG : NEGPF -> NEGMOD	= {
% struct basepf := SoundBase basemod .
% struct neg	:= neg .
notI := [ A][ p : basemod . base . ded A -> { B} basemod . base . ded B] ( MLTT .. case ( basemod . boole A)
([ q : A == 1] p ( basemod .1 - ded q) ( not A))

([ q : A == 0] basemod .1 - ded ( not1 q ))).
notE := ...
}.
Finally, the proof rules are mapped to their soundness proofs. These proofs are straightforward in principle but quite complex to formalize. Therefore, we give only one example here and refer to [12] for the rest. notI is mapped to a proof term. It formalizes the following proof, where 1-ded : A ==’ 1 -> ded A is a lemma proved in the signature BaseMOD that establishes one half of an equivalence between a formula having truth value 1 and that formula’s truth judgment:
A: Let A be a proposition.
p: Assume that given A is true, any proposition B is also true.
MLTT..case (basemod.boole A): We do a case analysis on the truth value of A. (Case 1) q: Assume A = 1.
p (basemod.1-ded q) (not A): Then ¬A = 1 by instantiating B with ¬A in p. (Case 2) q: Assume A = 0.
basemod.1-ded (not1 q): Then ¬A = 1 by not1.
Representing Set-Theoretical Models
The representation of models given in Sect. 3 and employed in Sect. 4 uses LF to axiomatize the semantics of models of a logic L. The signature morphism lmod interprets L-syntax in terms of the LF-signature Lmod, and the individual L-models are represented as LF-models of that signature.
This can be unsatisfactory as the L-models are still represented as set-theoretical entities. It would be more appealing if L-models could be represented as LF- signatures themselves. This is indeed possible without changing the principal fea- tures of our approach: All we have to do is to refine the signature Lmod so much that it becomes (a syntactical representation of) specific L-models.
More precisely, we can axiomatize the particular set theory in which we want to express L-models as a part of Lmod. We can do this in such a way that every choice of some free parameters in the signature morphism lmod corresponds to a specific L-model. Thus, we can represent L-models as certain LF-signature morphisms out of Lsyn.
For our representation of FOL, we arrive at

the diagram on the right. The signatures FOL, FOLPF, and FOLMOD are as before. Here we also make the signature MLTT that is included into FOLMOD explicit. Then we axiomatize Zermelo- Fraenkel set theory in the signature ZFC and give a view I that interprets FOLMOD in set theory. By

FOL
FOLPF
MLTT FOLMOD I




ZFC

composing lmod and I, we obtain a signature morphism out of FOL that represents FOL-models. Note that the morphism of Sect. 4.5 proving soundness can be reused immediately to prove the soundness of models in ZFC.
Naturally, this approach requires a significant investment in order to represent set theory within a logical framework. The representation of ZFC is highly non-

trivial and leads to lots of significant design questions. For example, very advanced encodings have been established in Mizar ([27]) and Isabelle ([20]) employing so- phisticated machine support. Even the proof of concept that we hand-coded in LF for this paper took over a week (which we consider in fact quite an achievement) to implement and still has some gaps. We will only sketch our encoding of ZFC and refer the reader to our full encoding (see [12]) for the details.
We encode ZFC as theory of a variant of first-order logic with universe Set, namely intuitionistic first-order logic with a description operator. The latter permits to define the basic operations such as union and replacement set, whose existence is only axiomatized indirectly in the ZFC axioms. This is different from Isabelle and Mizar where these operations are primitive.
After building up the basic operations on sets and the natural numbers, we introduce an operator Elem : Set → type, which serves the purpose of lifting sets – which are LF terms of type Set – to the type level in order to employ typed reasoning. Elem A can be regarded as an abbreviation of Σx:Set(ded x ∈ A). Then, using proof-irrelevance, the LF terms of type Elem A are in correspondence with the ZFC elements of the set A. This trick was inspired by the similar treatment in Scunak ([4]).
Then it becomes possible to give a view from MLTT to ZFC, which is a prereq- uisite to obtain a view from FOLMOD to ZFC. For example, o is mapped to the set
{0, 1} and all connectives are mapped to the corresponding functions. An important technical detail of the views is the treatment of the universe of FOL, which is already part of FOL and FOLMOD: the view I has a free parameter mapping the universe to an arbitrary set.

Conclusion
We took two developments on logical framework research to a practical test. Firstly, the module system for the logical framework LF and its implementation Twelf were designed to enhance the scalability of logic encodings ([24]). Secondly, the proof- and model-theoretical framework was given by the second author in [23].
Both were developed very recently, and our case study is the first scalability test for either one. We picked classical first-order logic and represented its syntax, proof theory, model theory, and soundness in LF. The most difficult part is the encoding of model theory and soundness, and we undertook two approaches to it that differ in the meta-language used to represent models.
Firstly, we defined models in Martin-Löf type theory. This is relatively simple to represent in LF, and it makes the reasoning about models manageably easy. On the down side, it does not correspond exactly to the usual paper definition of first-order models. This means that – depending on one’s familiarity with LF – one might require adequacy proofs to trust that the representation indeed formalizes the right notion of models.
Secondly, we defined them in Zermelo-Fraenkel set theory. This permits a very direct representation of models. While it has the disadvantage of the higher in-

vestment in representing set theory in LF, it offers the additional advantage that even individual models can be represented, namely as signature morphisms from the signature representing the syntax to the signature representing set theory.
We evaluate both developments very favorably. The representation of first-order logic was straightforward and made easy by the module system. All logical symbols are treated separately so that the encodings can be used to piece together different logics. The representation of model theory feels elegant and appealing. We are already working on further encodings of intuitionistic logic, higher-order logic, and description logics. The only doubt we have is about the representation of set theory: Clearly, the lack of automated proving support in Twelf will prevent scalable appli- cations. Therefore, we will investigate the possibilities of borrowing formalizations from other systems in the future. This will be supported by the logic-independent module system we designed in [22], which permits to express cross-framework trans- lations (e.g., LF to Isabelle) in terms of signature morphisms as well.

References
B. Avron, F. Honsell, M. Miculan, and C. Paravano. Encoding modal logics in logical frameworks.
Studia Logica, 60(1):161–208, 1998.
S. Autexier, D. Hutter, H. Mantel, and A. Schairer. Towards an Evolutionary Formal Software- Development Using CASL. In D. Bert, C. Choppy, and P. Mosses, editors, WADT, volume 1827 of Lecture Notes in Computer Science, pages 73–88. Springer, 1999.
S. Awodey and F. Rabe. Kripke Semantics for Martin-Löf Type Theory. 2009. Accepted at Conference on Typed Lambda Calculi and Applications (TLCA), see http://kwarc.info/frabe/ Research/LamKrip.pdf.
C. Brown. Combining Type Theory and Untyped Set Theory. In U. Furbach and N. Shankar, editors,
International Joint Conference on Automated Reasoning, pages 205–219. Springer, 2006.
H. Curry and R. Feys. Combinatory Logic. North-Holland, Amsterdam, 1958.
N. de Bruijn. The Mathematical Language AUTOMATH. In M. Laudet, editor, Proceedings of the Symposium on Automated Demonstration, volume 25 of Lecture Notes in Mathematics, pages 29–61. Springer, 1970.
R. Diaconescu. Proof systems for institutional logic. Journal of Logic and Computation, 16(3):339–357, 2006.
J. Goguen and R. Burstall. Institutions: Abstract model theory for specification and programming.
Journal of the Association for Computing Machinery, 39(1):95–146, 1992.
J. A. Goguen and G. Rosu. Institution morphisms. Formal Aspects of Computing, 13:274–307, 2002.
R. Harper, F. Honsell, and G. Plotkin. A framework for defining logics. Journal of the Association for Computing Machinery, 40(1):143–184, 1993.
W. Howard. The formulas-as-types notion of construction. In To H.B. Curry: Essays on Combinatory Logic, Lambda-Calculus and Formalism, pages 479–490. Academic Press, 1980.
Feryal Fulya Horozal and Florian Rabe. Twelf Encoding of the Soundness of FOL, 2009. https:
//svn.kwarc.info/repos/twelf/soundness.
R. Harper, D. Sannella, and A. Tarlecki. Structured presentations and logic representations. Annals of Pure and Applied Logic, 67:113–160, 1994.
S. Mac Lane. Categories for the working mathematician. Springer, 1998.
J. Meseguer. General logics. In H.-D. Ebbinghaus et al., editors, Proceedings, Logic Colloquium, 1987, pages 275–329. North-Holland, 1989.

T. Mossakowski, J. Goguen, R. Diaconescu, and A. Tarlecki. What is a logic? In J. Béziau, editor,
Logica Universalis, pages 113–133. Birkhäuser Verlag, 2005.
P. Martin-Löf. An Intuitionistic Theory of Types: Predicative Part. In Proceedings of the ’73 Logic Colloquium. North-Holland, 1974.
P. Martin-Löf. On the meanings of the logical constants and the justifications of the logical laws.
Nordic Journal of Philosophical Logic, 1(1):3–10, 1996.
P. Naumov, M. Stehr, and J. Meseguer. The HOL/NuPRL proof translator - a practical approach to formal interoperability. In 14th International Conference on Theorem Proving in Higher Order Logics. Springer, 2001.
L. Paulson. Isabelle: A Generic Theorem Prover, volume 828 of Lecture Notes in Computer Science. Springer, 1994.
F. Pfenning. Structural cut elimination: I. intuitionistic and classical logic. Information and Computation, 157(1-2):84–141, 2000.
F. Rabe. Representing Logics and Logic Translations. PhD thesis, Jacobs University Bremen, 2008.
F. Rabe. A Logical Framework Combining Model and Proof Theory. see http://kwarc.info/frabe/ Research/rabe_combining_09.pdf, 2009.
F. Rabe and C. Schürmann. A Practical Module System for LF. see http://kwarc.info/frabe/ Research/lf.pdf, 2009.
D. Sannella and M. Wirsing. A Kernel Language for Algebraic Specification and Implementation. In
M. Karpinski, editor, Fundamentals of Computation Theoryational, pages 413–427. Springer, 1983.
A. Tarski. Pojęcie prawdy w językach nauk dedukcyjnych. Prace Towarzystwa Naukowego Warszawskiego Wydzial III Nauk Matematyczno-Fizycznych, 34, 1933. English title: The concept of truth in the languages of the deductive sciences.
A. Trybulec and H. Blair. Computer Assisted Reasoning with MIZAR. In A. Joshi, editor, Proceedings of the 9th International Joint Conference on Artiﬁcial Intelligence, pages 26–28, 1985.
A. Tarski and R. Vaught. Arithmetical extensions of relational systems. Compositio Mathematica, 13:81–102, 1956.
