Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 341 (2018) 239–260
www.elsevier.com/locate/entcs

Factorisation Systems for Logical Relations and Monadic Lifting in Type-and-effect System Semantics
Ohad Kammar1
Department of Computer Science University of Oxford
Oxford, England
Dylan McDermott2
Computer Laboratory University of Cambridge Cambridge, England

Abstract
Type-and-effect systems incorporate information about the computational effects, e.g., state mutation, probabilistic choice, or I/O, a program phrase may invoke alongside its return value. A semantics for type-and-effect systems involves a parameterised family of monads whose size is exponential in the number of effects. We derive such refined semantics from a single monad over a category, a choice of algebraic operations for this monad, and a suitable factorisation system over this category. We relate the derived semantics to the original semantics using fibrations for logical relations. Our proof uses a folklore technique for lifting monads with operations.
Keywords: computational effects, type-and-effect systems, monads, factorisation systems, fibrations, logical relations, denotational semantics


Introduction
Consider the following program phrase in an imperative-functional ml-like language:
1	let ( t r i p l e : unit → int ) = λ  : unit . 3 ∗ ( get l )
2	in l  := 1 ;
3	l := triple ( ) + t riple ( )

1 Email: ohad.kammar@cs.ox.ac.uk
2 Email: dylan.mcdermott@cl.cam.ac.uk

https://doi.org/10.1016/j.entcs.2018.11.012
1571-0661/© 2018 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

The locally-defined function triple : unit→int triples the value read from memory location l. The phrase then triples this value twice, and mutates the state to the sum of these two results. When optimising the program, we would like to cache the call to triple , and replace line 3 with a single memory access:
3	l  := let y = t r i p l e ( ) in y + y
This transformation only preserves the semantics because the computational effects triple invokes are limited to reading. If we replace instead its definition on line 1 with a function that increments location lj with each invocation of triple then the caching optimisation is no longer semantics preserving:
1	let ( t r i p l e : unit → int ) = λ : unit . l
:= ( 1 + get lj ); 3 ∗ ( get l )
Type-and-effect systems [21] refine types, such as triple : unit→int, to propagate the information about which computational effects code pieces may invoke, e.g., decorating function types with additional effect annotations:

triple : unit −→ε
int 

In Gifford-style systems, these annotations are finite sets of effect operations, such as ε := {get, set}. For example, for every proper subset ε ⊂ {get, set}, the caching
transformation for every function ƒ : A −→ε  B is semantics preserving, while for ε =
{get, set} it is not.
Adequate denotational semantics is a natural technique for validating such equa- tional transformations, and there is a long line of work validating type-and-effect- dependent transformations, starting with independent results by Tolmach [31], Wadler [32], and Benton et al. [3], and continuing to this day [2]. In their most general form, the semantics of an effect system consists of a graded monad [15], a compatible family of monad-like structures Tε indexed by the effect annotations ε.
Here we make two contributions:
Contribution 1: avoiding structural combinatorial blow-up. To give the model structure for an arbitrary Gifford-style type-and-effect system with n opera- tion symbols, one would need to give the structure of 2n different monad-like struc- tures, n2n—1 monad-like-morphisms, and commute more than the same amount of diagrams to discharge the relevant proof obligations. To circumvent this blow-up, for example, Benton et al. give uniform bespoke definitions for each Tε, e.g., as in [2]. To avoid an ad-hoc definition for each collection of effects, Katsumata [15] constructs graded monads for Gifford-style systems when the effects in the lan- guage are free. Here we give a general construction for Gifford-style systems whose effects are given by a set of Kleisli arrows for an arbitrary monad over a category with a factorisation system with appropriate closure properties, providing a uniform construction even when the effects of interest are not free.
Contribution 2: relationship to a base semantics. We also show that this con- struction gives sound and complete reasoning principles with respect to the original

semantics under additional assumptions. As usual, such proofs involve construct- ing a logical relation. Here, we work fibrationally using Katsumata’s notion of a ﬁbration for logical relations [14]. We extend Hughes and Jacobs’s characterisation of fibrations arising from factorisation systems [7] and characterise the factorisation systems that correspond to fibrations for logical relations. Finally, we also define generally a monadic lifting for an arbitrary monad along a fibration for logical rela- tions that also lifts a given collection of Kleisli arrows. This construction utilises the bijection between algebraic operations and generic effects [26]. While Kammar [10] describes it in the special set-theoretic case, we believe this folklore monadic lifting methodology 3 should be known in its greater generality. We demonstrate that our results are applicable in several cases of interest.
These two contributions substantially generalise Kammar and Plotkin’s previ- ous domain-theoretic [11] and set-theoretic constructions [10]. Our factorisation system construction also strictly generalises the one in Kammar’s thesis [10], which is limited to factorisation of enriched Lawvere theories [29] over a locally presentable category. The development here is also substantially simpler than Kammar’s thesis. This simplification occurs in two levels. Kammar’s previous development requires a combinatorial solution set condition argument using Bousfield’s factorisation the- orem [4], while our factorisation construction is structural and elementary. Second, our proofs are straightforward in comparison.
The rest of the paper is structured as follows. Section 2 presents our main factorisation construction. Section 3 uses this construction to give semantics for a type-and-effect system for Moggi’s computational λ-calculus. Section 4 instru- ments a logical relations soundness and completeness proof from the factorisation construction. Section 5 surveys example applications of our construction. Section 6 concludes.
Factorising monads
To present our main construction, we first review the relevant category theoretic concepts and results.
Preliminaries and terminology
We assume familiarity with category theory, including categories C, D, functors F, G : C → D, and natural transformations α, β : F → G, and related concepts as found in textbooks such as Mac Lane’s [22].
Factorisation systems
A factorisation system axiomatises the set-theoretic situation in which every func- tion ƒ : A → B can be factorised as ƒ = m ◦ e, i.e., a surjection e : A → ƒ [A] onto the image of ƒ , followed by the injection m : ƒ [A] > B of this image into ƒ ’s codomain. In the general situation, we have two classes of morphisms (E, M) overa 

3 Alex K. Simpson, private communication, 2015.

category C, where E -morphisms are thought of as epimorphisms and M-morphisms are thought of as monomorphisms. We adopt the common convention to reserve the notation e : A → B for an E -morphism and m : B > C for an M-morphism when E and M are clear from the context, but emphasise that neither class needs to consist of epis or monos.
Definition 2.1 An (orthogonal) factorisation system on a category C is a pair (E, M) consisting of two classes of morphisms of C such that:
Both E and M are closed under composition, and contain all isomorphisms.
Every morphism ƒ : X → Y in C factors into ƒ = m ◦ e for some m ∈ M and
e ∈ E .
The diagonal ﬁll-in property is satisfied: for each commutative square as on the left, with m ∈ M and e ∈ E there is a unique morphism h : X → Y such that h ◦ e = ƒ and m ◦ h = g, as on the right:

W	e	X
f	=	g	=⇒
Y	m	Z
W
f
Y
e	X
g
m	Z

Under the first two axioms, the diagonal fill-in axiom is equivalent to a form of functoriality in factorisation, as in the following diagram:

f
X  Y	X
e	A	m	Y

g1	=	g2
=⇒	g1	=	h	=	g2

X	f′	Y
X	e′
A	m′	Y

In addition, it implies that factorisations of morphisms are unique up to a unique canonical iso, and so we talk about the factorisation of a morphism.
Example 2.2 The category Set has (surjection, injection) as a factorisation sys- tem, i.e., E is the class of surjective functions and M is the class of injective func- tions.
Example 2.3 [Meseguer [24]] Consider the category ωCpo of partial orders pos- sessing all least upper bounds (lubs) of ω-indexed monotone sequences (ω-chains), i.e., ω-cpos, and monotone functions between them preserving these lubs, i.e., Scott- continuous functions. A dense function is a continuous function e : X → Y such that the smallest ω-chain-closed subset U ⊆ Y with e[X] ⊆ U is Y itself, i.e., a Scott-continuous function with a dense image. A full function is a continuous function m : X > Y such that mx ≤ m xj implies x ≤ xj for each x ∈ X. The category ωCpo has (dense, full) as a factorisation system. The full functions form a proper subclass of the monos, and the dense functions form a proper subclass of the epis [20].
Example 2.4 Consider the functor category [W, C], for a small category W and any category C, and let (E, M) be a factorisation system on C. Take Ej (respectively Mj)

as the class of natural transformations that are component-wise in E (respectively
M). Then (Ej, Mj) is a factorisation system for [W, C].
The left and right classes in a factorisation system have useful closure properties. For example, if g ◦ ƒ and ƒ are in E , then so is g. For another example, view both classes as full subcategories of the arrow category C→ whose objects are triples
ƒ = (Af , Af , ƒ ) consisting of a morphism ƒ : Af → Af , and whose morphisms
1	2	1	2

h : ƒ → g are pairs (h1, h2) consisting of morphisms hi : Af
→ Ag
making the

evident square commute. Then the left class is closed under colimits in the arrow category, and similarly the right class is closed under limits.

Monad structures and monads
The main feature of our factorisation construction is its modularity. First, factori- sation takes place on a purely structural level, and we do not need any semantic properties such as the monad laws. Second, factorisation takes place on a pay-as- you-go basis, factorising any additional data the morphism of interest preserves. To describe it explicitly, we first describe precisely the structures we will factorise.
A monad structure T on a category C consists of a triple T , returnT , μT  where:
the functor part T assigns to every C-object A another C-object TA, and to every
C-morphism ƒ : A → B another C-morphism Tƒ : TA → TB;

the unit returnT assigns to every C-object A a C-morphism returnT
: A → TA;

and
the multiplication μT assigns to every C-object A a C-morphism μT : T 2A → TA.
A monad is thus a monad structure T satisfying the well-known monad laws [22, Section 7.1]. When C has finite products, a strong monad structure is a monad structure T with an additional structure component:
the strength strT assigns to every pair of C-objects A and B a C-morphism strT	:
A × TB → T (A × B).
A strong monad [19] is thus a strong monad structure satisfying the well-known laws. We similarly define Kleisli triple structures T = T , returnT , >>=T , demanding
extension >>=T	ƒ : TA → TB for every ƒ : A → TB. Finally, when C is cartesian

closed, we define a strong Kleisli triple structure T = T , returnT , >>=T analogously,

pair of C-objects A and B. This more general Kleisli extension induces morphisms

T A,B
: A × TB → T (A × B). (Strong) Kleisli triples are (strong) Kleisli triple

structures satisfying additional laws.
Morphisms m : S → T of the above structures are natural transformations m : S → T that preserve the structure, i.e. satisfy the same conditions a (strong) monad morphism should. Such morphisms provide categories of (strong) monad structures and of (strong) Kleisli triple structures. They also provide the subcategories of (strong) monads and of (strong) Kleisli triples. There are isomorphisms between

the categories of (strong) monads and (strong) Kleisli triples. The monad laws are necessary to establish this: the isomorphisms fail to extend to isomorphisms between the structure categories.
An algebra structure A = (A, algA) for a monad structure T over C consists of:
the carrier A, a C-object; and
the algebra map algA, a C-morphism algA : TA → A.
When T is a monad, an algebra is an algebra structure satisfying the well-known algebra properties [22, Section 7.2]. Similarly, when T is a Kleisli triple structure, an algebra structure A = (A, >>=A) replaces the algebra map with:
the extension operator >>=A which assigns to every morphism ƒ : X → A a mor- phism >>= ƒ : TX → A.
When T is a Kleisli triple, an algebra is an algebra structure satisfying [23], for every ƒ : X → A, and every g : X → TY , h : Y → A:

X return
TX
>>=f
>>=g
TX 
=
TY
>>=h

>>=A((>>=Ah)○g)
A	A
Similarly, we define an algebra structure for a strong Kleisli triple structure by replacing the extension operator with an internal extension operator >>=: TX×AX → A, and algebras for a strong Kleisli triple internalise the two equations above.
Let T be a monad over a category C. Recall that a Kleisli arrow is a morphism ƒ : A → TB. When C is cartesian closed and T is strong, an algebraic operation [26] α : A → B for T assigns to every C-object X a C-morphism αX : (TX)B → (TX)A, natural in X, and respecting the multiplication/extension and the strength. Plotkin and Power [26] establish a bijection between Kleisli arrows ƒ : A → TB and algebraic operations α : A → B given by:


uncurry αX
: A × (TX)B f×id
TB × (TX)B >>= TX


Let F : C → C be a functor with a tensorial strength strF over a category with finite products. The category F -MndC of F -monads on C has as objects (T, β) where T is a strong monad and β : F ◦ T → T is a natural transformation making the square on the left commute:

X × F (TY )
id×β
X × TY
strF
F (X × TY )
=
strT
F strT
F (T (X × Y ))
β
T (X × Y )
F (TX)
β
TX
Fm	F (T jX)
=	β′
m	T jX

A morphism m : (T, β) → (T j, βj) consists of a strong monad morphism m : T → T j
making the square on above right commute.
An effect signature ε in a category C consists of a set ε of operations and an
ε-indexed family of pairs of C-objects. We write (op : X → Y ) ∈ ε when op ∈ ε

and (X, Y ) is the op-th component in ε. Here X is thought of as the input to the operation, and Y as the output. We write ε ⊆ εj when ε is a subset of εj and both agree component-wise.
For every effect signature ε we define the functor Fε : C → C by Fε :=

Σ(op:X→Y )∈ε
X × (−)Y . Every Fε -MndC -object (T, β) induces an algebraic op-

eration αop for each operation (op : X → Y ) ∈ ε, which in turn induces a Kleisli
arrow (T, β) ⟦op⟧ : X → TY . This process extends to an isomorphism between Fε -MndC and the category whose objects are ε-monads on C, i.e., pairs (T, ⟦−⟧) consisting of a strong monad T together with a morphism ⟦op⟧ : X → T Y for each (op : X → Y ) ∈ ε. Its morphisms m : (T, ⟦−⟧) → T j, ⟦−⟧j are strong monad morphisms m : T → T j such that, for all (op : X → Y ) ∈ ε, we have m ◦ ⟦op⟧ = ⟦op⟧j.

The factorisation theorems
Let (E, M) be a factorisation system for a category C, and let S be a monad structure on C. We say that (E, M) is closed under S when, for every e : A → B in E , we have Se : SA → SB in E . We also say that S is compatible with (E, M). In that case, we can factorise every monad structure morphism m : S → T through a monad structure m[S] as a composition of monad structure morphisms m : S → m[S] > T by choosing a factorisation for each mX , setting for each ƒ : X → Y , and Z:

SX	mX	TX
e
SX	X

S
m[S]X

m
X
returnm[S]
Z 
m[S]Z







m[S]X


m

m[S]Y

e
f

m	TY	SZ
Y
me

S2Z
S Z
SZ

me
SmZ


=
Sm[S]Z




m[S] Z
m[S]Zm[S]2Z

m
Z
m[S]TZ
 m[S]mm
2

Z	=	T Z
T Z

m[S]Z

m	TZ
Z

This definition makes me : S → m[S] a monad structure morphism with components in E , and mm : m[S] > T a monad structure morphism with components in
M. Using the factorisation system closure properties, (E, M) is also closed under
m[S]. Moreover, we have a (component-wise E , component-wise M) factorisation

system of the category of (E, M)-compatible monad structures and monad structure morphisms. Every algebra structure A for m[S] induces an algebra structure S by setting:
me	alg
algT : SA −−→A→ m[S]A −−−→A  A
When C has finite products, we say that the factorisation system (E, M) is closed under products when, for every e1, e2 ∈ E, we also have that e1 × e2 ∈ E . We can then factorise a strong monad structure morphism m : S → T by setting the strength for m[S] as on the left:

X × SY
S X,Y
id×me
X × m[S]Y

id×mm

S(X × Y )
e
X×Y
m[S](X × Y )


m[S] X,Y
=

m
X×Y
X × TY
T X,Y
T (X × Y )

SX ×
 m[S]Y X

me ×id
m[S]X ×

 m[S]Y X


=	mm×(mm)X


>>=S


m[S]Y


>>=m[S]



m
Y
X	Y
TX × (TY )X
=	>>=T
TY


We also include the factorisation construction for strong Kleisli triples in a cartesian closed category, above on the right. This construction uses the fact that algebra structures for m[S] induce algebra structures for S.
Theorem 2.5 (Factorisation) Let C be a category, (E, M) a factorisation system,
S and T be monads over C, and m : S → T a monad morphism.
If (E, M) is closed under S then m[S] is a monad, and me and mm are monad morphisms. As a consequence, every algebra for m[S] induces an algebra for S.
If, moreover, (E, M) is closed under products, S and T are strong monads, and m is a strong monad morphism, then m[S] is a strong monad and me and mm are strong monad morphisms.
When, moreover, C is cartesian closed, the constructions for strong Kleisli triples and strong monads coincide.
The proof, commuting several diagrams, uses the diagonal fill-in property by substituting definitions.
We can transfer additional structure from S to m[S]. Post-composing with me transfers to m[S] any Kleisli arrow for S. Let F : C → C be a strong functor and assume (E, M) is closed under F . If (S, β) and (T, βj) are objects of F -MndC and m is a F -MndC -morphism we equip m[S] with a F -MndC -object structure

(m[S], m[β]) by setting as below on the left. We then have that me and mm are
F -MndC -morphisms.
Fmm

FSX
βX
X	Fm[S]X

Fmm

S	m	T

S  m[S]  T

SX	FTX
f1	=
f2  =⇒ f1	=
m[f ]  =	f2

e
X
m[S]X


′
X
m	TX
X

Sj	T j
m′
Sj	m[Sj]	T j

Using the diagonal fill-in property, we can functorially factorise commuting squares of monad structure morphisms, i.e., morphisms ƒ = (ƒ1, ƒ2) between monad struc- ture morphisms, as above on the right.
Theorem 2.6 (Functoriality) Let (E, M) be a factorisation system for a category C, and let ƒ : (S, T, m) → (Sj,Tj, mj) be a commuting square of monad structure morphisms. If (E, M) is closed under S and Sj, then m[ƒ ] : m[S] → m[Sj] is a monad structure morphism that preserves all of the above structure that ƒ preserves:
if (E, M) is closed under products and ƒ is strong, then so is m[ƒ ]; and
if moreover ƒ is an F-monad structure morphism, then m[ƒ ] is an F-monad structure morphism.
So far, we have worked with an arbitrary factorisation system (E, M). When it is an epi-mono factorisation system, i.e., a pair (E, M) in which M consists of monos, then Theorem 2.5 holds under the weaker assumption that T is a monad, while S need only be a monad structure. To prove it, instead of appealing to the diagonal fill-in property, use the cancellation property of monos.
Free monads
To apply the Factorisation Theorem 2.5, we need to choose a suitable monad S and monad morphism m. When giving semantics to type-and-effect systems, we take S to be the free monad for the functor Fε.
We recall Kelly’s [17,18] transfinite construction of the free F -monad when C has κ-directed colimits and F is an arbitrary functor that is κ-ranked, i.e., preserves these colimits, for some regular cardinal κ. Define an ordinal-indexed sequence of functors Sα : C → C by transfinite induction on α as follows:
S0 ➟ Id	Sα+1 ➟ Id + F ◦ Sα	Sλ ➟ colim Sα	(λ a limit ordinal)
α<λ

Each colimit is directed: the diagram includes morphisms Sα → Sα′ for α ≤ αj; these morphisms are defined by transfinite recursion. The free monad SF for F then has underlying endofunctor SF ➟ colimα<κ Sα. If F is also strong then SF is the initial object of F -MndC .
To apply the factorisation theorem, we need the free monad to be compatible

with the factorisation system. We give a sufficient condition on F for compatibility.

Lemma 2.7 Let C be a category with κ-directed colimits, κ a regular cardinal, F : C → C be a κ-ranked functor, and (E, M) a factorisation system over C. If F is compatible with (E, M), then the free F-monad SF is compatible with (E, M).
To apply the last lemma to the signature functor Fε, we want to show that Fε preserves κ-directed colimits for some κ, and that E is closed under Fε. For colimit preservation, the following lemma covers our examples.
Lemma 2.8 Let ε be an effect signature in a locally presentable cartesian closed category C. Then the functor Fε preserves κ-directed colimits for some regular car- dinal κ.
However, some Fε may be incompatible with some factorisation systems, since exponentials might not preserve E -morphisms:
Example 2.9 Consider the (dense, full) factorisation system on ωCpo. Exponen- tials (−)Y preserve dense maps iff Y is a countable discrete ω-cpo. For a simple illustration, take the discrete natural numbers N and the ordinal ω + 1. Take Y := ω + 1, and consider the inclusion e : N → ω + 1, which is a dense map. Every monotone function ƒ : ω +1 → N is constant, and so the ω-chain-closure of eY [NY ] contains only constant functions. Therefore, the identity function x := id ∈ (ω +1)Y is not in this closure, hence eY isn’t dense.
Type-and-effect systems
We consider a variant of Moggi’s [25] computational λ-calculus, λc, and its refine- ment with a Gifford-style type-and-effect system. The denotational semantics for such a system is standard, and we focus on the specific model structure given by the Factorisation Theorem 2.5.
Syntax
The syntax of λc is parametrised by three sets: a set B of base types ranged over by b; a set Σ of operations ranged over by op; and a set K of constants ranged over by c. The metavariable x ranges over some set of variables and ε ranges over finite subsets of Σ. The syntax of types A, B (base types, products and sums, and function types), ground types G, and terms M of the λc-calculus is given as follows:
A, B ::= b | 1 | A × B  | 0 | A + B  | A −→ε  B G ::= b | 1 | G1 × G2 | 0 | G1 + G2
M, N ::= c | op M | x | () | (M, N ) | fst M | snd M | elim0 M | inl M | inr M
| match M with {inl x. N1, inr y. N2} | λx. M | M N 
The main difference to Moggi’s calculus is that we include a specified set of constructs op M for causing effects. The other constructs are standard: built-in

(c : A) ∈K 


Γ ▶$ c : A
Γ ▶ε M : A	(op : A → B) ∈ Σ Γ ▶ε∪{op} op M : B
Γ ▶ε M : A	ε ⊆ εj


Γ ▶ε′ M : A

(x : A) ∈ Γ


Γ ▶$ x : A	Γ ▶$ () : A
Γ ▶ε M : A	Γ ▶ε′ N : B
Γ ▶ε∪ε′ (M, N ): A × B
Γ ▶ε M : A × B


Γ ▶ε fst M : A

Γ ▶ε M : A × B


Γ ▶ε snd M : B
Γ ▶ε M :0 Γ ▶ε elim0 M : A
Γ ▶ε M : A


Γ ▶ε inl M : A + B
Γ ▶ε M : B


Γ ▶ε inr M : A + B

Γ ▶ε M : A1 + A2	Γ,x : A1 ▶ε′ N1 : B	Γ,y : A2 ▶ε′ N2 : B
Γ ▶ε∪ε′ match M with {inl x. N1, inr y. N2} : B
ε′′
Γ,x : A ▶ε M : B	Γ ▶ε M : A −→ B	Γ ▶ε′ N : A
Γ ▶ λx. M : A −→ε  B	Γ ▶ε∪ε′∪ε′′ M N : B
Fig. 1. λc type-and-effect system
constants, unit value, products with projections, empty type elimination construct, sum injections and pattern matching, and function abstraction and application.
To define λc’s type system, we need some typing information for effect operations and the constants. Formally, a λc signature is a triple (B, Σ, K) consisting of: a set B of base types; a family of pairs of ground type Σ indexed by a set of operations Σ; and a family of types K indexed by a set of constants K. We write c : A when the type A is the c-component of K, and op : G → Gj when (G, Gj) is the op-component of Σ.
Given a λc signature we define two type systems. The type-and-effect system consists of a typing judgment Γ ▶ε M : A given inductively by the rules in Figure 1. Such judgments assert that in typing context Γ, a finitely supported partial function from variable names to types, the term M has type A and uses only the operations in ε ⊆ Σ. The rules are standard for such systems.
We recover the usual type system for λc by erasing the effect annotations ε from the type syntax and from Figure 1. In detail, for each type A there is an erased type A, and similarly for contexts Γ. The unrefined typing judgments Γ ▶ M : A are generated by the rules of Figure 1 without annotations. This judgment places no constraints on the operations that M can use. We have that if Γ ▶ε M : A then Γ ▶ M : A.
Semantics
Fix a λc signature (B, Σ, K). Recall that a bicartesian closed category is a cartesian closed category with finite coproducts. Given a bicartesian closed category C and an object ⟦b⟧ ∈C for each b ∈ B, we can define the interpretation ⟦G⟧ of each ground type G in the usual way, and interpret each ε ⊆ Σ with operations op : G → Gj as an effect signature ⟦ε⟧ with operations op : ⟦G⟧ → ⟦Gj⟧.
An unreﬁned λc model consists of: a bicartesian closed category C; an object
⟦b⟧ ∈ C for each b ∈ B; a ⟦Σ⟧-monad T on C (recall the definition of ε-monad from Section 2.1.2); and a morphism ⟦c⟧ :1 → ⟦A⟧ for each constant (c : A) ∈ K.

Unrefined models interpret the unrefined judgments Γ ▶ M : A, with types and contexts denoting C-objects ⟦B⟧ and ⟦Γ⟧, and judgments denoting Kleisli arrows
⟦Γ ▶ M : A⟧ : ⟦Γ⟧ → T ⟦A⟧.
To interpret type-and-effect judgments in their greatest generality, one replaces the monad with a graded monad [15]. Here, as we restrict to Gifford-style systems (so graded by the preordered monoid (P Σ, ⊆, ∪, ∅)), we consider a simpler structure. A reﬁned λc model consists of: a bicartesian closed category C; an object ⟦b⟧ ∈ C for each b ∈ B; a functorial assignment T—, to each ε ⊆ Σ, of an ⟦ε⟧-monad Tε on C, and to each inclusion ε ⊆ εj an ⟦ε⟧-monad morphism Tε → Tε′ ; and a morphism
⟦c⟧ : 1 → ⟦A⟧ for each constant (c : A) ∈ K. Function types are interpreted as
⟦A −→ε  B⟧ ➟ ⟦A⟧ ⇒ Tε ⟦B⟧. We interpret the refined judgment Γ ▶ε M : A by a
morphism ⟦Γ⟧ → Tε ⟦A⟧ along the same lines of the unrefined semantics.
The only difference between the two model structures is the functorial assign- ment T—, which requires additional structure over the unrefined model structure that is exponential in the number of operations. We can derive it in the follow- ing way and under the following assumptions, in addition to the unrefined model structure. First, we assume that, for each ε ⊆ Σ, we have the free ⟦ε⟧-monad Sε. Second, we assume a factorisation system (E, M) that is closed under products and each Sε. By Lemmata 2.7 and 2.8 these two assumptions hold in any locally pre- sentable cartesian closed category in which E is closed under exponentiation by the interpretation of base types. Third, we assume a ⟦Σ⟧-monad T . By initiality of Sε, we have a unique monad morphism mε : Sε → T for every ε ⊆ Σ. Applying the Fac- torisation Theorem 2.5 to this monad morphism, we set Tε := mε[Sε]. Applying the functorial action of mε[−] to the (unique) ⟦ε⟧-monad morphism Sε⊆ε′ : Sε → Sε′ , we set Tε⊆ε′ := mε[Sε⊆ε′ ]: Tε > Tε′ . Finally, we assume a refined interpretation of the built-in constants compatible with this structure.
Example reasoning
We demonstrate the model construction on a small set-theoretic example. Let L be a finite set of global memory location names. For our λc signature, we take: B := {loc, int}, Σ := {get : loc → int, set : loc × int → 1}, and

K := {+: int × int −→$
int}∪ {l : loc|l ∈ L}∪ {a : int|a ∈ Z}

For the unrefined model structure, we interpret: ⟦loc⟧ := L and ⟦int⟧ := Z. For our monad, we set S := ZL and take T to be the S-state monad, TX := (S × X)S, with the usual interpretation for get and set. We interpret locations and integers as themselves, and + as addition without side effects.
For the refined model, we take the (surjection, injection) factorisation system on Set. We can calculate that T{set}X = (1 + Z)L × X is the writer monad for the following overwriting monoid (1 + Z)L, 1, ∗ :


1 := (ι1 )

l∈L

 (al)l∈L

∗ (bl)l∈L
=	bl′	bl′ /= ι1 
l	al′	otherwise

I.e., an injected unit value at location l represents no state change, while an injected integer a represents an update of that location to a. To see why, first note that the free {set}-monad is the smallest set satisfying S{set}X ∼= X + L × Z × S{set}X. The unique {set}-monad morphism m{set} : S{set} → T satisfies:
m{set}(ι1x) := λs. (s, x)	m{set}(ι2 (l, a, r)) := λs. s[l '→ a], m{set}(r) 
Factorising it, and using the finiteness of L, we get the surjection:

e
{set}
(ι1x) '→ (ι1 , x)	me
(ι2 (l, a, r)) '→ (((ι1 )l′∈L
[l '→ ι2a] ∗ (−)) × id) m{set}(r) 

We then interpret + as addition, as T$ is the identity monad. We can then vali- date the example from the introduction, i.e. in the refined semantics ⟦M + M ⟧ =
⟦(λx.x + x)M ⟧ for every Γ ▶{set} M : int.
Monadic lifting
To prove that the refined factorisation semantics matches the unrefined semantics we use a suitable notion of logical relation. In this section we define a notion of factorisation system for logical relations, and show that these systems induce a suit- able logical relation. This notion combines Hughes and Jacobs’s [7] characterisation of fibrations arising from factorisation systems with Katsumata’s [14] fibrations for logical relations. We then describe the free lifting of monads to logical relations, and use this to prove the completeness of the refined semantics (Theorem 4.12).

Preliminaries
First we review some standard properties of fibrations, see Jacobs [8] for a sys- tematic development of fibred category theory in type theory and logic. Instead of considering general fibrations, we will only consider the simpler case of faithful fibrations.
Let p : D→ C be a faithful functor. For all D-objects X, Y , we write ƒ : X −→. Y
when ƒ : pX → pY in C and there is some (necessarily unique) ƒ˙ : X → Y such
that p ƒ˙ = ƒ . In this case we say that ƒ lifts to ƒ˙. If ƒ : X −→. Y then ƒ˙ is
Cartesian when, for all objects Z ∈ D and g : pZ → pX with ƒ ◦ g : Z −→. X we
have g : Z −→. X. The functor p is a ﬁbration when, for every object Y in D and
morphism ƒ : I → pY in C there is an object X such that pX = I and ƒ : X −→. Y
is Cartesian.
If p : D → C is a faithful fibration, we view objects X ∈ D as predicates over
pX, and morphisms ƒ˙ : X → Y as truth-preserving maps. If ƒ : pX → pY then
ƒ : X −→. Y means ƒ is truth-preserving, and ƒ˙ is a witness to this preservation.
Faithfulness implies that ƒ˙ is unique, so constructing such witnesses amounts to
checking a property, instead of providing structure. The property of being Cartesian intuitively means that X is true on as many elements of pX as possible, with the constraint that ƒ is truth-preserving.

For every I ∈ C, the ﬁbre DI is the category consisting of objects X ∈ D such that pX = I and morphisms ƒ : X → Y in D such that pƒ = idI . We write X ≤ Y when there is a (necessarily unique) morphism from X to Y in DI , and X ≡ Y when X ≤ Y and Y ≤ X.
For each ƒ : I → J in C there is an inverse image functor ƒ∗ : DJ → DI that
sends an object X to an object Y such that ƒ : X −→. Y is Cartesian. The object
Y is unique up to isomorphism in DI : for any Y j with the same property we have Y ≡ Y j. We will also postulate that ƒ∗ has a left adjoint ƒ∗ : DI → DJ , the direct image functor. When ƒ∗ exists, we call p a biﬁbration.
For fibrations to give us logical relations, we also require both categories to be bicartesian closed, and require p to preserve the bicartesian closed structure. For example, products in D allow us to form logical relations over a product, and preservation of products implies that this relation has the usual property of logical relations. We will also want to form conjunctions/intersections of logical relations; these are given by products in fibres.
Katsumata combines all of these requirements into a single notion.
Definition 4.1 A ﬁbration for logical relations [14] over a bicartesian closed cate- gory C is a faithful fibration p : D→ C such that:
p is a bifibration: each inverse image functor ƒ∗ has a left adjoint ƒ∗;
D is bicartesian closed, and p strictly preserves the bicartesian closed structure; and
each fibre DI has all small products, denoted  .
Our only deviation from Katsumata’s definition is to not require fibres to be partial orders, due to our use of non-strict factorisation systems. Since the fibration is faithful, fibres are preorders.
Recall also the change-of-base construction which allows us to construct new fibrations for logical relations from existing ones:
Lemma 4.2 (Katsumata [14, Proposition 6]) Let p : D→ C be a ﬁbration for logical relations, and let F : Cj →C be a product-preserving functor. The projection from the pullback F∗ p of p along F is a ﬁbration for logical relations on Cj.
F∗ D  D
τ
F∗ p	p
Cj  C
F
When we choose the product functor F := (×) : C× C → C, we call F∗ D the category of binary logical p-relations over C.
Fibrations from factorisation systems
Let (E, M) be a factorisation system on C. Recall that we view M as a full subcate- gory of the arrow category C→, so that objects are M-morphisms and morphisms are

commutative squares. The codomain functor cod : M→C sends an M-morphism m : X > Y to its codomain Y . Cartesian morphisms for cod are exactly pullback squares. Given an M-morphism m : Xj > Y j and a morphism ƒ : Y → Y j, we construct the Cartesian morphism required in the definition by taking the pullback of m along ƒ :
X  Xj
τ
f∗ m	m
Y  Y j
f
ƒ∗ m is necessarily in M due to the diagonal fill-in property. Hence if C has all pullbacks of M-morphisms then cod is a fibration. If this is the case then cod is also a bifibration: the left adjoint ƒ∗ maps an M-morphism m to the M-morphism in the factorisation of ƒ ◦ m.
Example 4.3 Consider the (surjection, injection) factorisation for Set. Every in- jection m : X > Y is equal to the composition of an inclusion i and an isomorphism. In this case, we have m ≡ i. This fact rephrases that an injection is, up to isomor- phism in the fibre, a subset X ⊆ Y . The direct image functor ƒ∗ of a function ƒ : Y → Y j maps this subset to {ƒ x | x ∈ X}⊆ Y j. The inverse image functor ƒ∗ maps a subset Xj ⊆ Y j to {x | ƒ x ∈ Xj}⊆ Y .
Example 4.4 Similarly for the (dense, full) factorisation for ωCpo, the full func- tions are the chain-closed subsets. Inverse images are the usual inverse images, but direct images are now the ω-chain-closure of the direct image.
We extend the work of Hughes and Jacobs [7], who give a correspondence be- tween factorisation systems on categories with pullbacks and certain fibrations. We restrict this correspondence to fibrations for logical relations.
Definition 4.5 [cf. [7]] Let C be bicartesian closed. A factorisation system (E, M) over C is a factorisation system for logical relations when:


C has all pullbacks of M-morphisms;
every morphism in M is a monomor- phism
(i.e. m ◦ ƒ = m ◦ g ⇒ ƒ = g);
for every Y ∈ C the ﬁbre MY has
small products;
M is closed under binary coproducts; and
E is closed under binary products.


The monomorphism requirement implies that cod is faithful. The closure of M under coproducts implies that M is bicartesian (it automatically has initial and terminal objects and products). The closure of E under binary products implies that for mj : Xj > Y j the canonical morphism X ⇒ mj : X ⇒ Xj > X ⇒ Y j is an

M-morphism, and hence that M has exponentials m ⇒˙
mj, which are given by the

following pullback:

Z τ
m⇒˙ m′

X ⇒ Xj
X⇒m′

Y ⇒ Y j


m⇒Y ′
X ⇒ Y j

Lemma 4.6 Let (E, M) be a factorisation system over a bicartesian closed category
C. The codomain functor cod : M→C is a ﬁbration for logical relations iff (E, M)
is a factorisation system for logical relations.
This lemma also has a converse: if a fibration for logical relations is a factori- sation ﬁbration [7, Definition 3.1] then the factorisation system induced by Hughes and Jacobs’s correspondence is a factorisation system for logical relations.
Example 4.7 The factorisation systems (surjection, injection) for Set and (dense, full) for ωCpo are factorisation systems for logical relations. If (E, M) isa factori- sation system for logical relations on C, then (component-wise E , component-wise M) is a factorisation system for logical relations on [W, C].
Folklore lifting for algebraic operations
Since our semantics uses monads, we also need to lift monads to the category of logical relations. Let p : D → C be a faithful fibration, ε be an effect signature in D, and T be a p ε-monad on C, where pε is the effect signature with operations

op : pX → pY for (op : X → Y ) ∈ ε. A lifting of T to D is an ε-monad T˙
such that:
on D



for each X ∈ D we have p (T˙ X) = 

T (pX);
for each ƒ	: X  →  Y  we have
p (T˙ ƒ )= T (pƒ );
the unit lifts: p (returnT˙) = returnT ;
the multiplication lifts: p (μT˙)= μT ;
the strength lifts: p (strT˙) = strT ; and
each op ∈ ε lifts: p (α˙ op)= αop.



Only the object action of T˙ properties we need to check.
is a required structure, the other requirements are

As each logical relations proof involving monads involves a lifting, these occur in abundance, and usually in an ad-hoc fashion. Two general lifting techniques are TT-lifting [13] and the codensity lifting [16]. We instead use the free lifting, which is the ε-monad that is initial amongst all ε-liftings. The proof of completeness relies on initiality. The construction of the free lifting is folklore, and is described for binary relations over Set in Kammar’s thesis [10]. We describe it for the general case of a fibration for logical relations here.
Let p : D → C be a fibration for logical relations with essentially small ﬁbres,
i.e. each fibre has a representing set of objects up to ≡. For each object X ∈ D 
define RX as the set of all Xj in the representing set of DT (pX) such that:
The unit respects Xj: returnT : X −→. Xj.

For each.(op : A → B) ∈ ε the algebraic operation αop respects Xj: αop :
B ⇒˙ Xj −→ A ⇒˙ Xj, where ⇒˙  denotes exponentials in D.
This definition makes essential use of the bijection between algebraic operations and Kleisli arrows, as the former localises the closure condition to Xj alone. The elements of RX can be thought of as candidates for T˙ X. We define the free lifting of T to D on objects by T˙ X ➟ RX, so that T˙ X is the least element of RX with respect to the order ≤ on the fibre. This definition extends uniquely to a lifting of T to D.


Theorem 4.8
T˙ is a lifting of T to D, and is initial: for all liftings T˙j, the identity

lifts to a (necessarily unique) ε-monad morphism T˙ → T˙j.

Completeness
We now return to the language λc and relate the refined semantics we construct at the end of Section 3.2 with the unrefined semantics. Suppose that the factorisation system we used to construct the refined semantics is a factorisation system for logical relations that is well-powered, meaning that each object has a representing set of M-morphisms into it, and let p : LogRel →C × C be the fibration for logical relations constructed from the codomain fibration cod : M→ C, as in Lemma 4.2. Explicitly, an object of LogRel is a triple (X, Y, m) where m : Z > X × Y (for some Z) is an M-morphism. The diagonal relations are the objects (X, X, δX ), where δX = ⟨id, id⟩ : X > X × X. We further assume that all diagonal relations exist, i.e., the diagonals δX are in M. Well-poweredness of the factorisation system implies p has essentially small fibres.
Example 4.9 The factorisation systems (surjection, injection) over Set and (dense, full) over ωCpo are well-powered and have all diagonals. For every factorisa- tion system (E, M) for C and every small category W, the factorisation (component- wise E , component-wise M) is well-powered if (E, M) is well-powered, and has diagonals if (E, M) has diagonals.
Example 4.10 Over Set, the factorisation system (iso, any) is not well-powered, and the factorisation system (any, iso) does not have all diagonals.
Consider any unrefined model together with a refined factorisation model for it. For each ε ⊆ Σ both T and Tε are ε-monads, so (Tε,T ) is an ε-monad on C × C (and this forms a refined λc model on C× C). By Theorem 4.8 we can lift (Tε,T )
to get an ε-monad T˙ε on LogRel. Moreover, each monad morphism Tε⊆ε′ induces

˙	˙	˙
∗ ˙	.	˙

an ε-monad morphism Tε → Tε′ , since Tε is initial and (Tε⊆ε′ ) (T ε′ X) −→ Tε′ X.
If we take the interpretations LogRel⟦b⟧ of base types b to be diagonal relations
⟦b⟧, ⟦b⟧, δ⟦b⟧ , we need to interpret the constants to form a refined λc model on LogRel. By the fibration’s faithfulness, this interpretation is merely a property, and not structure we need to provide. Using an inductive argument, ground types G denote diagonal relations, and if p (LogRel ⟦c⟧) is the interpretation of the constant

c in C× C then for all well-typed terms Γ ▶ε M : A we have:
p (LogRel ⟦Γ ▶ε M : A⟧)= (⟦Γ ▶ε M : A⟧, ⟦Γ ▶ M : A⟧)
We use LogRel to compare the refined model we constructed with the original unrefined model. First:
Lemma 4.11 Suppose that the free ε-monad Sε is given by the transﬁnite con- struction from §2.3. For each morphism (ƒ1, ƒ2): (X, X) → (Tε Y, T Y ) in C× C, if
(ƒ1, ƒ2): (X, X, δX ) −→. T˙ε (Y, Y, δY ) then ƒ2 = mm ◦ ƒ1.
We can now show that the refined semantics is complete for equational reasoning.

Theorem 4.12 (Completeness) Under the combined assumptions of this subsec- tion, for all contexts Γ containing only ground types and terms Γ ▶ε M : G and Γ ▶ε N : G of ground type,
⟦Γ ▶ M : G⟧ = ⟦Γ ▶ N : G⟧	⇐⇒	⟦Γ ▶ε M : G⟧ = ⟦Γ ▶ε N : G⟧
Proof. Noting that ground types are interpreted as diagonal relations, we apply Lemma 4.11 to both LogRel ⟦M ⟧ and LogRel ⟦N ⟧ to show that
⟦Γ ▶ M : G⟧ = mm ◦ ⟦Γ ▶ε M : G⟧	⟦Γ ▶ N : G⟧ = mm ◦ ⟦Γ ▶ε N : G⟧
Now the result follows from the fact that every M-morphism is a monomorphism.2

Examples
Before we conclude, we apply the factorisation construction to several examples.
Example 5.1 Continuing the global state example from §3.3, we have the full factorisation:
T$ = Id	T{get} = S ⇒ (−)	T{set} = (1 + Z)L × (−)	T{get,set} = T
By the completeness of the refined semantics from §4.4, we can apply the equation from §3.3 to programs of ground type in ground contexts without changing their denotations in the unrefined semantics.
Example 5.2 If instead of T we use the monad T j = (S ⇒ (−) ⇒ R) ⇒ S ⇒ R, which combines global state with continuations (so that the language can include constants such as call/cc), then we get the same factorisation, assuming |R| > 1. Hence we can also verify the caching transformation in this situation. The construc- tion in Kammar’s thesis [10] does not allow this factorisation, as it is restricted to Lawvere theories, i.e., ranked monads, and T j is not ranked. Note that, as call/cc is not algebraic, we cannot interpret call/cc in the refined semantics, so cannot validate transformations on subprograms that use continuations.

Example 5.3 Using the (dense, full) factorisation of ωCpo, we can re-cast Kam- mar and Plotkin’s [11] validation of effect-dependent optimisations.
Example 5.4 Let value be a base type for values (with associated constants). Con- sider λc with a base type ref of references, and the set Σ = {lookup : ref → value, update : ref × value → 1, alloc : value → ref } of operations, so that we can read from and write to references, and allocate new references. Let I be the cate- gory of finite ordinals and injections between them. Plotkin and Power [27] interpret these operations the functor category [I, Set] as follows. Let V be a nonempty finite set of values with interpretation for the value constants. Then we interpret value as the constantly-V functor, and ref as the Yoneda embedding ⟦ ref⟧ = I(1, −), so that ⟦ ref⟧ n has n elements. The local state monad is defined using a coend:
m∈I
T X n ➟ V ⇒	I(n, m) × V	× Xm

A computation is given an initial state in Vn, and returns an injection that describes how the original n references are distributed over the m references (so that n ≤ m), a new state in Vm, and a result in Xm.
The category [I, Set] has a (pointwise surjection, pointwise injection) factorisa- tion system. For each subset ε ∈ Σ, since V is finite, we can show that the transfinite sequence Sα converges at ℵ0. We can therefore show by induction on α that, for example, there are component-wise surjections from the corresponding free monads into the following functors:
m∈I
T{alloc} X n ➟	I(n, m) × V	× Xm  T{lookup,update} X n ➟ V  ⇒ V  × Xn

Calculation shows that there are pointwise injections from these into T . Theorem 2.5 (and the uniqueness of factorisations) implies they are the monads that result from factorisation. For an example of reasoning using this factorisation, note that there are two sequencing morphisms T{alloc} X × T{alloc} Y → T{alloc} (X × Y ), one that does the left computation first and one that does right first. It is easy to check that these are equal, i.e., T{alloc} is commutative, and hence we can validate a transformation that reorders computations that only allocate.

Conclusion
We have presented a factorisation theorem for cutting down a monad into sub- monads based on a factorisation system. We showed how this construction gives uniform semantics for Gifford-style type-and-effect systems. Synthesising Hughes and Jacobs’s characterisation of fibrations arising from factorisation systems and Katsumata’s axiomatisation of fibrations for logical relations, we provide a general proof that the factorisation construction is sound and complete for effect-dependent equational reasoning.

We would like to generalise the completeness theorem to programs of higher- order types, and not just ground types. Reynolds [30] relates direct and continua- tion semantics by defining domain-theoretic partial maps between the two seman- tics, and proves such a theorem. Felleisen and Cartwright [5] provide an analogous construction and proof for free effects and their handlers [28,1], but their semantics does not involve monads. Well-powered factorisation systems for logical relations induce categories of partial maps via Fiore’s axiomatic domain theory [6]. The axiomatic development is particularly appealing because factorisation systems of interest, such as the (dense, full) factorisation of ωCpo do not admit a representa- tion using a lifting monad.
We want to relate the free lifting to other lifting techniques, most notably TT-, and codensity-, lifting. We would also like to relate Benton et al.’s [2] relational models to our construction. We want to apply this construction to more sophis- ticated computational effects, such as dynamic memory allocation [9]. Another application area to the free lifting is relational parametricity with effects — we have used it as a semantic precursor to the more syntactic work on analysing the value restriction [12], and we hope it applies more widely. Finally, there is still a wide gap between Gifford-style type-and-effect systems and the full generality of graded monads. We hope our account will carry over to such settings.
Acknowledgement
This work has been supported by an Engineering and Physical Sciences Research Council (EPSRC) studentship, EPSRC grants EP/N007387/1 ‘Quantum compu- tation as a programming language’, EPSRC Leadership Fellowship EP/H005633/1 ‘Semantic Foundations for Real-World Systems’, Institute for Information & Com- munications Technology Promotion (IITP) grant funded by the Korea government (MSIP) No. R0190-16-2011 ‘Development of Vulnerability Discovery Technologies for IoT Software Security’, a Balliol College Oxford Career Development Fellowship, European Research Council Grant ‘Events, Causality and Symmetry — the next generation semantics’, and Isaac Newton Trust grant ‘algebraic theories, computa- tional effects, and concurrency’. We would like to thank Marcelo Fiore, Mathieu Huot, Justus Matthiesen, Ian Orton, and Philip Saville for fruitful discussions and suggestions.

References
Andrej Bauer and Matija Pretnar. Programming with algebraic effects and handlers. Journal of Logical and Algebraic Methods in Programming, 84(1):108 – 123, 2015. Special Issue: The 23rd Nordic Workshop on Programming Theory (NWPT 2011) Special Issue: Domains X, International workshop on Domain Theory and applications, Swansea, 5-7 September, 2011.
Nick Benton, Martin Hofmann, and Vivek Nigam. Effect-dependent transformations for concurrent programs. Science of Computer Programming, 155:27 – 51, 2018. Selected and Extended papers from the International Symposium on Principles and Practice of Declarative Programming 2016.
Nick Benton, Andrew Kennedy, and George Russell. Compiling Standard ML to Java Bytecodes. In Proceedings of the Third ACM SIGPLAN International Conference on Functional Programming, ICFP ’98, pages 129–140, New York, NY, USA, 1998. ACM.

Aldridge K. Bousfield. Constructions of factorization systems in categories. Journal of Pure and Applied Algebra, 9(2):207–220, 1977.
Robert Cartwright and Matthias Felleisen. Extensible denotational language specifications, pages 244–
272. Springer Berlin Heidelberg, Berlin, Heidelberg, 1994.
Marcelo Pablo Fiore. Axiomatic Domain Theory in Categories of Partial Maps. Distinguished Dissertations in Computer Science. Cambridge University Press, 1996.
Jesse Hughes and Bart Jacobs. Factorization systems and fibrations. Electronic Notes in Theoretical Computer Science, 69:156 – 182, 2003.
Bart Jacobs. Categorical Logic and Type Theory. Number 141 in Studies in Logic and the Foundations of Mathematics. North Holland, Amsterdam, 1999.
O. Kammar, P. B. Levy, S. K. Moss, and S. Staton. A monad for full ground reference cells. In 2017 32nd Annual ACM/IEEE Symposium on Logic in Computer Science (LICS), pages 1–12, June 2017.
Ohad Kammar. Algebraic theory of type-and-effect systems. PhD thesis, University of Edinburgh, UK, 2014.
Ohad Kammar and Gordon D. Plotkin. Algebraic foundations for effect-dependent optimisations. In Proceedings of the 39th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL ’12, pages 349–360, New York, NY, USA, 2012. ACM.
Ohad Kammar and Matija Pretnar. No value restriction is needed for algebraic effects and handlers.
Journal of Functional Programming, 27:e7, 2017.
Shin-ya Katsumata. A semantic formulation of TT-lifting and logical predicates for computational metalanguage. In Luke Ong, editor, Computer Science Logic, pages 87–102, Berlin, Heidelberg, 2005. Springer Berlin Heidelberg.
Shin-ya Katsumata. Relating computational effects by TT-lifting. Inf. Comput., 222:228–246, 2013.
Shin-ya Katsumata. Parametric effect monads and semantics of effect systems. SIGPLAN Not., 49(1):633–645, 2014.
Shin-ya Katsumata and Tetsuya Sato. Codensity liftings of monads. In CALCO, 2015.
G.M. Kelly. A unified treatment of transfinite constructions for free algebras, free monoids, colimits, associated sheaves, and so on. Bulletin of the Australian Mathematical Society, 22(1):1–83, 1980.
G.M. Kelly. Two addenda to the author’s transfinite constructions. Bulletin of the Australian Mathematical Society, 26(2):221237, 1982.
Anders Kock. Strong functors and monoidal monads. Archiv der Mathematik, 23(1):113–120, 1972.
Daniel Lehmann and Ana Pasztor. Epis need not be dense. Theoretical Computer Science, 17(2):151 – 161, 1982.
John M. Lucassen and David K. Gifford. Polymorphic effect systems. In Proceedings of the 15th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL ’88, pages 47–57, New York, NY, USA, 1988. ACM.
Saunders Mac Lane. Categories for the Working Mathematician (Graduate Texts in Mathematics). Springer, 2nd edition, 1998.
Francisco Marmolejo and Richard J. Wood. Monads as extension systems — no iteration is necessary.
Theory and Applications of Categories, 24(4):84–113, 2010.
Jos´e Meseguer. Completions, factorizations and colimits for ω-posets. In Mathematical Logic in Computer Science, Salgotarjan, 1978, Colloquia Mathematica Societatis Janos Bolyai, volume 26, pages 509–545. North Holland, 1981.
Eugenio Moggi. Computational lambda-calculus and monads. In Proceedings of the Fourth Annual Symposium on Logic in Computer Science, pages 14–23, Piscataway, NJ, USA, 1989. IEEE Press.
Gordon Plotkin and John Power. Algebraic operations and generic effects. Applied Categorical Structures, 11(1):69–94, 2003.
Gordon D. Plotkin and John Power. Notions of computation determine monads. In Proceedings of the 5th International Conference on Foundations of Software Science and Computation Structures, pages 342–356, London, UK, 2002. Springer-Verlag.


Gordon D. Plotkin and Matija Pretnar. Handlers of algebraic effects. In Proceedings of the 18th European Symposium on Programming Languages and Systems: Held As Part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2009, ESOP ’09, pages 80–94. Springer- Verlag, Berlin, Heidelberg, 2009.
A John Power. Enriched Lawvere theories. Theory and Applications of Categories, 6(7):83–93, 1999.
John C. Reynolds. On the relation between direct and continuation semantics. In Jacques Loeckx, editor, Automata, Languages and Programming, pages 141–156, Berlin, Heidelberg, 1974. Springer.
Andrew P. Tolmach. Optimizing ML using a hierarchy of monadic types. In Types in Compilation, pages 97–115, 1998.
Philip Wadler. The marriage of effects and monads. SIGPLAN Not., 34(1):63–74, 1998.
