

Electronic Notes in Theoretical Computer Science 262 (2010) 249–261
www.elsevier.com/locate/entcs
OOPS: An S5n Prover for Educational Settings
Gert van Valkenhoef1,2
Department of Business and ICT, University of Groningen,
P.O. Box 800, 9700 AV, Groningen, The Netherlands
Elske van der Vaart3
Department of Artificial Intelligence, University of Groningen,
P.O. Box 407, 9700 AK, Groningen, The Netherlands
Theoretical Biology Group, University of Groningen,
P.O. Box 14, 9750 AA, Haren, The Netherlands
Rineke Verbrugge4
Department of Artificial Intelligence, University of Groningen,
P.O. Box 407, 9700 AK, Groningen, The Netherlands

Abstract
We present OOPS, an open source, cross-platform, easy-to-run tableau prover for S5n. OOPS is aimed at education in modal logics. Thus, it has several features that enable insight into its internal workings. Specifically, OOPS allows tableaux to be visualized and can generate counter-models for formulas that are not provable. Moreover, the OOPS Graphical User Interface (GUI) increases ease of use and an integrated
general purpose scripting language (Lua) is used to provide convenient and powerful interactions with the
OOPS tableau generator.
Keywords: System Description, Modal Logic, Epistemic Logic, S5n, Tableau Methods, Education, Visualization


Introduction
In this paper, we describe OOPS 5 , an Object Oriented Prover for S5n. It is a tableau-based theorem prover, aimed at satisfiability checking, that is specifically designed for use in a classroom setting. Although not as efficient as highly optimized

1 Corresponding author.
2 Email: g.h.m.van.valkenhoef@rug.nl
3 Email: elskevdv@ai.rug.nl
4 Email: rineke@ai.rug.nl
5 http://wiki.github.com/gertvv/oops

1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.04.018

provers like MSPASS [12] and FaCT [11], or as flexible as highly extensible provers like LoTReC [7] and the Tableau Workbench [1], we believe OOPS offers a unique combination of features that make it particularly suitable for educational purposes. First, OOPS offers support for S5n, the logic typically used to model human reasoning processes. As far as we are aware, there are currently no other theorem provers which do this. Furthermore, OOPS is capable of visualizing its tableau proofs, and of generating counter-models to formulas that are false. These two properties are very useful for educational proof tools, and they are shared by at least two other systems: LoTReC can display its tableau trees, and the Logics Workbench [10] can
print its derivations in sequent calculi.
Another feature OOPS has in common with LoTReC, as well as MSPASS, but with few other theorem provers, is its free and convenient distribution. OOPS is packaged as a ZIP file that includes all dependencies, and once extracted, can be run simply by double-clicking the resulting oops.jar file. This is true for any operating system, provided the Java VM is available. In contrast, the Tableau Workbench must be built from source, FaCT offers binaries only for Linux and Windows, and requires Lisp otherwise, and the Logics Workbench is not open source, and can be difficult to install, due to outdated dependencies.
A fifth property that makes OOPS particularly attractive for educational use is its Graphical User Interface (GUI). Although simple, its GUI allows students to input formulas in an easy and intuitive format, or to save and load files. LoTReC, MSPASS and the the Logics Workbench also offer GUI-based access.
OOPS’ final educational attribute is its integrated scripting facility. In our expe- rience, most student projects involving theorem provers are efforts to model riddles, or game situations. This requires that students be able to build and extend theo- ries, using loops and conditionals where necessary. Many proof tools, like the Logics Workbench, offer custom scripting languages for this purpose. OOPS, by contrast,
integrates the existing Lua 6 scripting language. Lua can be used to call most of
OOPS’ functions, and offers a rich input language.
To summarize, our contribution is a proof system, OOPS, designed to support education in logics, specifically in multi-agent reasoning. For this purpose, OOPS features a tableau prover for S5n that is capable of visualizing its tableau proofs and counter-models for formulas that are false. Furthermore, OOPS is platform independent and easy to install. Finally, OOPS offers a Graphical User Interface (GUI) and an integrated scripting language (Lua) that enables easy but powerful interactions with the prover.
In the rest of this paper, we first offer a technical description of OOPS, including its proof system, its formal properties, its implementation in Java, and the details of its input language (Section 2). This is followed by a more detailed descrip- tion of OOPS’ educational properties (Section 3), as well as a worked-out example (Section 4). We conclude with a discussion of current limitations and future work (Section 5).

6 http://www.lua.org/

Technical description
In this section, we will first give a brief description of the tableau method used in OOPS and summarize the formal properties (soundness, completeness, complexity) of the system. Then, we explain how the tableau system is implemented in Java. Finally, we describe the input language for modal formulas that is provided by OOPS.

OOPS tableaux
The OOPS tableau system for S5n is a Java [8] implementation of the proof system ELtap [4,3]. ELtap, in turn, draws on [5] and [2]. [9] provides a good review of tableau methods for modal logics. Here, we summarize how tableaux are formalized in OOPS. For a complete description, see [14].
When we construct a tableau, we do so with the aim of creating a Kripke model in which a formula ϕ is satisfied. This is done by assuming ϕ is true and then systematically working out the implications of this assumption. Specifically, OOPS generates a collection of branches that each represent alternative ways of working
out these implications. A branch B consists of a number of nodes. A node γ is a
combination of a formula ψ and a label σ. A label is a systematically chosen name for a world in the Kripke model that is being constructed. Branches are created and expanded by the application of rules to existing nodes on a branch. A rule R consists of:
A precondition pre(R), written above a horizontal bar, which is a node containing variables;
A postcondition post(R), written below the horizontal bar, which is a list of nodes containing variables. There are two types of postconditions:
Linear: add nodes to the current branch, written top-to-bottom;
Branching: create a number of new branches, written left-to-right, separated by a vertical bar.
Zero or more constraints, which restrict the values variables may take.
The rules employed by OOPS are given in Table 1. A rule R is applicable to a branch B, if there is a node γ ∈ B that matches pre(R), such that no constraints are violated and R has not previously been applied to γ.
In the case of modal rules, after the precondition pre(R) has matched, we may either need to create a new world (add a label part) or to match existing worlds (labels). In the first case, we create a label part that is uniquely identified, through a function ·’ that encodes formulas as valid label parts. In the latter case, the postcondition will contain a variable as a placeholder for one of the label parts. Such a postcondition must be applied to all labels that its label matches to.
A branch B is closed if there is a label σ and a formula ψ, such that both (σ, ψ) ∈ B and (σ, ¬ψ) ∈ B. A branch B is open if it is not closed and no more rules can be applied to it. Thus, an open branch corresponds to a successful attempt to satisfy ϕ, whereas a closed branch corresponds to a failed attempt to satisfy ϕ. Specifically, for an open branch B, the labels determine the set of worlds and the

Double Negation Rule
¬¬
σ	ччϕ

σ	ϕ




Disjunctive
∨∧	∨∨

Rules
σ	ч(ϕ Λ ψ)
σ	ϕ V ψ

	

Table 1
Tableau Extension Rules (see Section 2.2 for an explanation of how OOPS applies these rules.)


accessibility relations in the corresponding Kripke model. For each label, the set of formulas given for that label determines the valuation in the corresponding world in the Kripke model. A tableau for ϕ is closed if all branches are closed, otherwise it is open.
Now, for any proof system, it is important that its proofs correspond exactly to the semantics of the logic. The proof system used by OOPS has been shown to

be both sound and complete for S5n [14]. Furthermore, in the same work, the implementation (Section 2.2) was shown to correspond to the formal description of the proof method. Unfortunately, this work also shows that the algorithm used by OOPS needs exponential time in the worst case, whereas satisfiability for S5n is known to be pspace-complete [9]. However, we believe that for educational purposes the functionality offered by OOPS (see Section 3) easily makes up for this shortcoming. Moreover, the implementation of these features does not depend on the specific proof algorithm used. Thus, as future work, the current algorithm may be replaced by one that is in pspace.

Implementation
In order to ensure the exhaustive, but non-redundant application of Table 1’s rules, OOPS employs two data structures: the match queue and the necessities list. When- ever a node is added to the current branch, we attempt to match every possible rule to that node. The resulting matches are placed on the match queue. Now, the Basic Necessity rules (Table 1) pose a specific problem: the postcondition may apply to labels that have not been generated yet. To address this, partially matched postconditions of these rules are stored in the necessities list. Whenever a new label is generated, any matches from this list to the new label are added to the match queue. These data structures are specific to a branch, i.e., when a new branch is created, it receives a copy of the current match queue and necessities list.
For reasons of efficiency, the match queue is a priority queue and rules can be given a numeric priority value, which specifies the order in which matches are applied to the tableau. In this way, we may define a strategy to close branches as soon as possible. For example, it is preferable to execute all possible non-branching propositional rules before attempting to execute any other rules.
The rules are implemented in such a way that they are easily replaceable by a different ruleset. Moreover, the tableau generator allows the generation process to be monitored. This enables the decoupled implementation of such features as tableau visualization and counter-model construction (see Section 3).

Input language
OOPS employs an input language for formulas implemented using the SableCC [6] compiler generator for Java. Propositions are input as strings of characters and digits, starting with a lowercase character. Agent identities are represented by nat- ural numbers. OOPS uses the widely understood infix notation for logical formulas. Table 2 shows OOPS ascii equivalents for different logical operators, as well as their precedences; lower numbers indicate stronger bindings.
In addition to this, the language allows the input of variables as placeholders for either (sub-)formulas or agent identities. This is useful in the definition of rules and allows one to create template formulas that can be instantiated in different ways, by substitution. Variables are strings of characters and digits that start with an uppercase character.


Table 2
OOPS Connectives.
Functionality
In this section, we highlight a number of features of OOPS that we believe are important in an educational setting. Even though other systems may share some of OOPS’ features, there is no other system that possesses all of them.

Integrated Scripting
In order for a theorem prover to be truly useful, it is not sufficient to be able to answer ‘true’ or ‘false’ given an input formula. Rather, our experience has shown that students will need to formulate and extend theories. Doing this by hand by editing a single large formula quickly becomes unmanageable. Moreover, we want to have a powerful toolbox to assist us in the formulation of larger theories. This toolbox should include general programming constructs such as loops and condi- tionals. Some other tools, such as the Logics Workbench, provide custom scripting languages for this purpose. The advantage of this approach is that the language can be tailored specifically to common usage of the prover. The disadvantage, however, is that developing a custom language is costly. Therefore, that the resulting lan- guage is likely to be lacking in expressive power. Furthermore, the user has to learn a language that has no application outside of the prover and for which support (i.e., documentation, user community and bug fixes) may be limited.
To address these concerns, OOPS integrates the general-purpose scripting lan- guage Lua. Lua has been designed specifically to be an embeddable language and is widely used both as an extension language and as a front-end for libraries written in other languages. Thus, Lua enables us to define an environment that is tailored to the needs of theorem proving, while avoiding the concerns associated with im- plementing a custom language. See [13] for a good introduction to programming in Lua. Currently, most of OOPS’ functionality is available from Lua and more extensive support is being worked on.
The above outlines our reasons for integrating OOPS with Lua. Now we briefly describe how OOPS can be used through its Lua interface. All OOPS methods are encapsulated in the oops namespace. The basis for interaction with OOPS through Lua is the theory concept. A theory is, simply put, a collection of formulas. The following example code creates a theory and adds a formula to it:
th = oops . Theory ( ) th : add ( "# _1 p" )
We define a number of operations on theories: checking of consistency, provability of a formula within a theory and satisfiability of a formula within a theory:


print ( th : consistent ( ) )	−− true print ( th : provable ( "# _2 # _1 p" )) −− false print (th : satisfiable ( "~# _2 p" )) −− true 
where −− starts a comment, here used to indicate the output produced by the print statement. Now, to aid in the construction of theories, we allow the explicit creation of formulas, on which we have defined the operation of substitution. For example:
th = oops . Theory ( )
f = oops . Formula ( "# _A V" )
for i = 1, 4, 1 do
th : add ( f : substitute ( {V = " p | q" } , {A = i } )) 
end
print (th) 
which expresses that each of the agents 1, 2, 3 and 4 ‘knows’ (p V q). The resulting output is:
[# 4 ( p | q) , # 3 ( p | q) , # 1 ( p | q) , # 2 ( p | q) ]
This completes our description of how OOPS is called from Lua. It must be noted that Lua is a very powerful and complete language and that much more can be achieved than is suggested by the above examples. For example, command-line interaction with the user is readily available through Lua.

Graphical User Interface
As is discussed above, Lua provides a convenient scripting interface to OOPS. How- ever, modern computer users do not expect to run applications from the command- line. Even if they are used to this concept, it is not always the most convenient method of interaction. Therefore, OOPS includes a very simple Graphical User In- terface (GUI), in which scripts can be displayed, edited and executed (Figure 1). In addition, scripts can be loaded from and saved to a file. For those who prefer to use an external editor (e.g., there are many editors that offer syntax highlighting for Lua), a single key combination reloads a modified file from the file system. The application consists of two panels: the top panel shows the current script and the bottom panel shows the output.
Though minimal, the GUI greatly enhances the convenience with which OOPS can be used. Firstly, script and output are shown in one place, allowing for easy cross-referencing. Second, scripts are run through a single key combination (or invocation from the menu). Finally, the load, save and refresh functionalities give the user the freedom to use the integrated editor or an external editor of choice with equal convenience.

Free and Convenient Distribution
As we noted in Section 1, most current proof tools have problems related to either platform dependence, aging dependencies, lack of maintenance or difficult instal- lation procedures. OOPS addresses these problems in several ways. First, OOPS is implemented in pure Java, which means that OOPS will run on any operating sys- tem for which a Java virtual machine is available. This is true for most operating



Figure 1. The OOPS Graphical User Interface.
systems available today. Second, OOPS is distributed as a ZIP file that includes all dependencies. No installation is needed, one simply extracts the ZIP file and double-clicks the resulting oops.jar file. Hence, OOPS is platform independent and easy to run, having no dependencies apart from the Java VM and what is provided in the OOPS distribution.
The concern of continued maintenance is harder to address. To ensure that OOPS
can be used and extended in the future by anyone who wishes to do so, we provide the full source code 7 under the GNU General Public License (GPL). It is our hope
that others will contribute extensions to OOPS.

Visualization of Tableaux
When a student is learning to work with modal logics, a prover can often give surprising results. He or she may encounter undesirable outcomes when constructing a theory and would like to be able to ‘debug’ the theory by inspecting the proof process. Moreover, inspecting generated tableaux may enhance understanding of tableau methods and the semantics of modal logics in general. To support this, OOPS includes a visualization module for labeled tableaux. Figure 2 shows an example of such a visualization. The tableau is drawn as a tree. In the tree, nodes are numbered in the order in which they are added (left-most on each line). After the node number, the label is shown, followed by the formula. Finally, the rule that resulted in the creation of the specific node and the node number to which the rule matched are given.
The visualization is implemented as an observer on the tableau generator (see Section 2.2). The Lua code to generate Figure 2 is as follows (note that the command-line output will be true):
oops . a ttachTableauVisualizer ( )
print ( oops . Theory ( ) : p rovable (
"(# _1 p | #_1 ~p) > #_1( p | ~p)" )) 

7 http://github.com/gertvv/oops




Figure 2. Visualization of the tableau that checks provability of ϕ, by attempting to satisfy ¬ϕ, where ϕ = (( 1p ∨ 1¬p) → 1(p ∨ ¬p)). In this case, the tableau is closed (i.e. ϕ is provable), as indicated by the = (m, n) under each branch, where m and n indicate the line numbers at which two contradicting formulas are found.


Visualization of Counter-Models
In addition to being able to view the tableau, it may be helpful to be able to inspect a model that the tableau corresponds to. In case the tableau is open, the generated model will generally be more insightful, as it does not contain any redundant information. As is the case for tableau visualization, visualization of (counter-)models may enhance understanding of the semantics of modal logics.
Figure 3 is generated by the following Lua code (note that the command-line output will be false):
oops . attachModelConstructor ( )
print ( oops . Theory ( ) : p rovable ( "# _1 p | # _1 ~p" )) 
oops . showModel ( )
As the reader will notice, the invocation of the model visualization is done differently from the tableau visualization. This is because we treat models as entities in their own right. In fact, the call oops.getModel() can be used to retrieve the most recently constructed model, if the last invocation of the tableau generator resulted in an open tableau. The Lua print function will output a textual representation of the model. However, further programmatic manipulation and inspection of models is future work.




Figure 3. Visualization of a counter-model for ϕ = ( 1p ∨  1¬p). The ‘main’ world is indicated in blue.

Example
To illustrate the educational potential of OOPS, we present a worked-out example that models an exercise we have assigned to students of multi-agent systems in the past, at the Department of Artificial Intelligence at the University of Groningen. We show how OOPS’ scripting can facilitate model construction and how its ability to visualize Kripke models can facilitate understanding of S5n. Our example concerns a simplified version of the ‘Wise Persons’ puzzle:
There are two wise persons, Abelard (1) and Heloise (2). It is known to everyone that there are three hats: two red ones and one white one. The king puts a hat on the head of each of the two wise persons, who cannot see their own hat but can see the other person’s hat (and they both know this). The king asks them sequentially if they know the color of the hat on their own head. The first person, Abelard, says that he does not know; the second person, Heloise, says that she knows. Exercise: find out what must be the color of Heloise’s hat.
To model this problem, let us define the propositions r1 for ‘Abelard wears a red hat’, w1 for ‘Abelard wears the white hat’, r2 for ‘Heloise wears a red hat’ and w2 for ‘Heloise wears the white hat’. In the full implementation of this example, available online, 8 a number of utility functions are given. conj(f1, f2) safely gives the con- junction of two formulas, knows(a1, f) gives the formula a1f ’ and knows2(a1, a2, f) for a1 a2f . Finally, printAbelard(th) and printHeloise(th) give in- formative output on the knowledge states of Abelard and Heloise, given the theory th.
The initial situation can be modelled by simply defining the basic facts given in the puzzle and stating that both Abelard and Heloise are aware of these facts to sufficient depth. Of course, the background information should be common knowledge, but this is not possible in pure S5n. So we give knowledge to depth 2, the minimum level required to solve this puzzle. The Lua code is as follows:
−− each person has only one hat
oneHat = "(r1 = ~w1) & (r2 = ~w2)"
−− there i s only one white hat
oneWhite = "( w1 > r2 ) & ( w2 > r1 )"
−− Abelard can see Heloise ’ s hat
abelardSees = "# _1 w2 | # _1 r2 "
−− Heloise can see Abelard ’ s hat
heloiseSees = "# _2 w1 | # _2 r1 "
−− background knowledge :
background = c o n j ( c o n j ( oneHat , oneWhite ) , conj ( abelardSees , h e loiseSees ) )
−− add the background and the wise persons ’
−− knowledge about i t ( to depth 2 )
th = oops . Theory ( ) th : add ( background )
th : add ( knows ( "1" , background ) ) th : add ( knows ( "2" ,  background ) )

8 http://cloud.github.com/downloads/gertvv/oops/hats.lua




Figure 4. Counter-model to Heloise knowing the color of her own hat in the initial situation of the ‘wise persons’ puzzle. The counter-model to Abelard knowing the color of his hat is almost identical, except that the relations between the worlds are for agent 1 (Abelard), not agent 2 (Heloise).

th : add ( knows2 ( "2" , "1" , background ) )
th : add ( knows2 ( "1" , "2" , background ) )
We can evaluate the agents’ knowledge in the initial situation using the following statements:
−− make sure we can show the counter−model
oops . attachModelConstructor ( )
print ( " Initial Situation : " ) printAbelard ( th )
printHeloise ( th )
oops . showModel ( )
The counter-model to Heloise knowing the color of her hat is shown in Figure 4. The console output is as follows:
I n i t i a l S ituation :
Abelard doesn ’ t know Heloise doesn ’ t know
In the puzzle, Abelard is asked if he knows the color of his hat and responds that he doesn’t. Heloise can now derive the color of her hat. We model this announcement by giving Heloise the knowledge that Abelard doesn’t know the color of his hat.
−− After Abelard announces he doesn ’ t know :
abelardKnows = "# _1 w1 | # _1 r1 "
th : add ( oops . Formula ( "# _2 ~ F" ) : substitute (
{F = abelardKnows } , {} )) 
print ( " After Abelard ’ s announcement : " ) printAbelard ( th )
oops . showModel ( ) printHeloise ( th )
print ( " Consistent : " .. tostring ( th : consistent ( ) ) )
The output is as follows:
After Abelard ’ s announcement :
Abelard doesn ’ t know
Heloise knows h i s / her hat i s red Consistent : true 
Clearly, Abelard still doesn’t know the color of his own hat (his own announcement doesn’t help him), but Heloise is now aware that her hat is red, which is the correct solution to the puzzle. The counter-model generated by the above code is nearly

the same as the one shown in Figure 4, so it is not shown separately.
This example demonstrates the kind of assignment that can be designed with OOPS. It gives students the experience of using a theorem prover, and lets them experiment with different assumptions, providing insight into the formal logic that underlies a familiar riddle. This can all be done quickly and easily due to OOPS’s integrated scripting facility and GUI.

Conclusions and Further Work
In this paper, we have presented OOPS, a cross-platform, easy to install and open source tableau prover for S5n. OOPS provides users with a graphical user interface, an integrated scripting language, tableau visualization and counter-model generation. We believe these features make OOPS more suited for educational use than other similar systems.
Given this, we now identify several directions for further work on OOPS. First of all, although the implementation currently allows new rule sets to be implemented relatively easily, this requires extending the Java source code and recompiling OOPS. To remedy this, we would like to implement rule sets as Lua modules and provide such modules for several logics. Lua is specifically designed to make it easy to implement domain specific languages. This facility can be used to provide a more direct integration of the formula input syntax with Lua, making formula input seem like native language support. The Lua bindings in general should be improved, but this will require further input from actual use as an educational tool. We would also like to implement an algorithm that allows the S5n tableau to be generated
in pspace, as our current implementation may require an exponential amount of
space.
Furthermore, we would like to have a more complete set of tools to interact with theories, formulas and Kripke models. For example, it should be possible to simplify formulas and theories. In the case of Kripke models, we would like to be able to construct and alter models ourselves and to perform operations such as model checking and bisimulation. Finally, the GUI should allow users to provide keyboard input to Lua scripts (through ‘standard in’) so that one can develop interactive OOPS scripts.

References
Abate, P. and R. Gor´e, The Tableau Workbench, Electronic Notes in Theoretical Computer Science
231 (2009), pp. 55–67.
Beckert, B. and R. Gore, Free variable tableaux for propositional modal logics, Automated Reasoning With Analytic Tableaux Related Methods 1227 (1997), pp. 91–106.
de Boer, M., “Praktische Bewijzen in Public Announcement Logica,” Master’s thesis, University of Groningen, Groningen, the Netherlands (2006).

de Boer, M., KE tableaux for Public Announcement Logic, in: B. Dunin-Kepli¸cz and R. Verbrugge, editors, FAMAS’007, 2007, pp. 56–69.


Fitting, M. and R. Mendelsohn, “First-Order Modal Logic,” Synthese Library 277, Kluwer Academic Publishers, 1999.
Gagnon, E´., “SableCC, an Object-Oriented Compiler Framework,” Master’s thesis, McGill University, Montreal, Quebec, Canada (1998).
Gasguet, O., A. Herzig, D. Longin and M. Sahade, LoTReC: Logical Tableaux Research Engineering Companion, in: B. Beckert, editor, TABLEAUX 2005 (2005), pp. 318–322.
Gosling, J., B. Joy, G. L. Steele and G. Bracha, “The Java Language Specification,” The Java Series, Prentice Hall PTR, 2005, third edition.
Halpern, J. Y. and Y. Moses, A guide to completeness and complexity for modal logics of knowledge and belief, Artificial Intelligence 54 (1992), pp. 319–379.
Heuerding, A., G. J¨ager, S. Schwendimann and M. Seyfried, The Logics Workbench LWB: A snapshot, Euromath Bulletin 2 (1996), pp. 177–186.
Horrocks, I., The FaCT system, in: H. de Swart, editor, TABLEAUX 1998 (1998), pp. 307–313.
Hustadt, U. and R. Schmidt, MSPASS: Modal reasoning by translation and first-order resolution, in:
R. Dyckhoff, editor, TABLEAUX 2000 (2000), pp. 67–71.
Ierusalimschy, R., “Programming in Lua,” Lua.org, 2006, 2nd edition.
van Valkenhoef, G., Elaborations on OOPS – project report (2008), http://www.ai.rug.nl/
~valkenhoef/oops/elaborations.pdf.
