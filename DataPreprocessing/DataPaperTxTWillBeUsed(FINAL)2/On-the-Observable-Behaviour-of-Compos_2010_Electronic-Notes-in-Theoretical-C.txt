

Electronic Notes in Theoretical Computer Science 260 (2010) 125–153
www.elsevier.com/locate/entcs


On the Observable Behaviour of Composite Components 1
Rolf Hennicker, Stephan Janisch
Institut für Informatik
Ludwig-Maximilians-Universität München
{hennicker, janisch}@pst.ifi.lmu.de
Alexander Knapp
Institut für Informatik Universität Augsburg
knapp@informatik.uni-augsburg.de

Abstract
The crucial strength of the component paradigm lies in the possibility to encapsulate behaviours. In this work, we focus on the observable behaviour of composite components which encapsulate the behaviour of (possibly large) assemblies of connected subcomponents. We first present our general component model which is equipped with a precise formal semantics allowing us to distinguish systematically different kinds of behaviours for ports, for components, and for component assemblies; technically we use UML2 notation for describing component structures and I/O-transition systems for behaviours. Then we investigate an efficient method for the computation of the observable behaviour of composite components which can circumvent the possibly infeasible intermediate computation of the usually complex behaviour of underlying assemblies if there are behaviourally neutral subcomponents. Finally, we utilise the fact that components are connected via ports such that checks for behavioural neutrality of components can be reduced to checks for behavioural neutrality of connected ports in the case of weakly deterministic port behaviours.
Keywords: hierarchical components, observable behaviour, I/O-transition system


Introduction
Components, being based on the notion of strong encapsulation, foster a composi- tional approach to system construction and analysis. Port-based component models, as e.g. the ROOM model [30], stress this encapsulation aspect by taking ports with provided and required interfaces to form the explicit and exclusive communication windows of components. The behavioural properties of a component should thus

1 This research has been partially supported by the GLOWA-Danube project (01LW0602A2) sponsored by the German Federal Ministry of Education and Research.

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.12.035

be governed only by the observable behaviour of a component on its boundary. In particular, when composing components hierarchically all subcomponent imple- mentation details and internal interactions become hidden behind the facade of the super-component.
Being aware of the various software component models [28,21] that have been proposed already, the first goal of this study is to combine many of the ideas found in the literature to obtain a comprehensive model for component-based system design which satisfies the following requirements. The component model should (i) support as a concrete syntax UML2 notation, which in our view provides, as a de-facto standard for industrial applications, a powerful notation for modelling the structural aspects of components; (ii) support ports and, of course, hierarchical composition;
(iii) be equipped with a precise formal semantics for both, the structural and the behavioural aspects of components thus resolving ambiguities left in the UML and also in other notations; and (iv) be able to discriminate systematically between different kinds of behaviours, like port, component and assembly behaviour, and also between specified and derived behaviours.
Building upon [4,19] our component model will first be described by an appro- priate metamodel and then precisely defined in terms of an algebraic approach. We distinguish between simple (i.e., basic) components, component assemblies, i.e., net- work structures of components connected via their ports, and composite components which make up large scale components by encapsulating assemblies. For the formal representation of behaviours we use I/O-transition systems which are based on in- terface automata [12]. Explicit I/O-labellings allow to distinguish between input, output and internal actions which can be hidden to compute (derive) the observable behaviour of components. The behaviour of an assembly is also an I/O-transition system which is derived from the composition of the observable behaviours of the connected components of the assembly.
The second goal of this study is to provide support for an efficient construc- tion and behavioural analysis of large scale component systems. In the context of component-based systems this usually means construction and analysis of assembly behaviour or, in other words, facing the state explosion problem, which has been the source of investigation at many places. There are, for instance, approaches to compositional reachability analysis (CRA) such as [10] and, even more prominent under the umbrella of component-based systems, approaches which focus on efficient analysis of safety and liveness properties such as [5,9,16,18,17]. However, the men- tioned studies focus essentially on the analysis of assembly behaviour, whereas our focus is on the construction of the observable behaviour of a composite component which encapsulates an assembly. Given a composite component CC that encap- sulates an assembly a with behaviour beh(a), the observable behaviour obs(CC) of CC is formally defined by observational abstraction from beh(a). The idea is then to identify components within the assembly a which do not play any role for the observable behaviour of CC. Formally, this idea will be reflected by our no- tion of behavioural neutrality. Then, instead of computing the behaviour beh(a) of the complete assembly it is sufficient to compute the behaviour of a simpler as-

sembly, say s, where all behaviourally neutral components have been removed from a, such that the observational abstractions from beh(s) and beh(a) are observation- ally equivalent. As a consequence, obs(CC) is then observationally equivalent to the observational abstraction of beh(s) which may be computable much easier. A major result of this paper is an algorithm which shows how to reduce an assembly for the efficient computation of the observable behaviour of a composite compon- ent. Our reduction strategy is particularly useful for acyclic topologies containing a distinguished “rooted” component, but is also sound for arbitrary topologies.
The cost of the reduction algorithm depends primary on the cost of the neut- rality checks which are performed between connected components of the assembly and hence depends on the complexity of the observable behaviours of the subcom- ponents. But we can reduce the cost of neutrality checks between components if we utilise the fact that components are connected via ports, that ports have themselves, usually much simpler, behavioural protocols and that component behaviours should conform to the behaviour of their ports. We show, as a further important result, that it is sufficient to perform neutrality checks for the behaviours of connected ports provided that ports to be checked for neutrality have a weakly deterministic behavioural protocol.
The remainder of this paper is structured as follows: Section 2 summarises definitions, operators and facts for I/O-transition systems. In Sect. 3 we review our component model by means of a metamodel and an example and complement the description by a precise algebraic definition. We consider behaviours of ports and of simple components and we describe how assembly behaviours and observable behaviours of components can be formally derived from their parts. In Sect. 4 we focus on our main results concerning simplified computation of the observable behaviour of composite components and we discuss the important role of ports for efficient neutrality checks. Section 5 provides a detailed discussion on related work and, finally, Sect. 6 summarises our approach and outlines future work.

I/O-Transition Systems
We use I/O-transition systems to describe behaviours of ports, components, and assemblies with their provided (input) and required (output) operations as well as their internal actions. Our definition of an I/O-transition system follows the notion of interface automata of de Alfaro and Henzinger [12]. However, we include an invisible (or silent) action τ for abstracting from internal actions and studying the observable behaviour of components which was not an issue in [12]. Moreover, we do not require input-determinism.
An I/O-labelling, iol for short, L = (I, O, T ) consists of three mutually disjoint sets of input labels I, output labels O, and internal labels T ; we write L for the set of labels I ∪ O ∪ T . An I/O-transition system, iots for short, A = (L, Q, q0, Δ) is given by an iol L, a set of states Q, an initial state q0 ∈ Q and a transition relation Δ ⊆ Q × ( L ∪ {τ }) × Q (with τ ∈/  L). We write L(A) for the iol of A, and L (A) for L(A).

Observational Equivalence
Behaviours of components are compared using observational equivalence of iotss. Observational equivalence is based on weak bisimulations abstracting from invisible τ -actions.
For an iots A = (L, Q, q0, Δ) we define the τ-closure of Δ as Δˆ ⊆ Q × (  L ∪
{τ }) × Q as follows: For an l ∈  L, (q, l, q') ∈ Δˆ , if q' is reachable from q w.r.t. Δ by a sequence of transitions containing exactly one transition labelled with l and
arbitrarily many τ -transitions; i.e., there are q = q1,..., qm ∈ Q and q' ,..., q' =

1
q' ∈ Q such that (qi, τ, qi+1) ∈ Δ for 1 ≤ i < m, (qm, l, q1' ) ∈ Δ, and (q' , τ, q'
n
) ∈ Δ

j	j+1
for 1 ≤ j < n. Furthermore, (q, τ, q') ∈ Δˆ , if q = q' or q' is reachable from q
w.r.t. Δ by τ -transitions only; i.e., there are q = q1,..., qn = q' ∈ Q such that (qi, τ, qi+1) ∈ Δ for 1 ≤ i < n.
A weak bisimulation between two iotss A = (L, QA, q0,A, ΔA) and B = (L, QB, q0,B, ΔB) with the same iol L is a relation R ⊆ QA × QB such that for all (qA, qB) ∈ R and all a ∈  L ∪ {τ } the following holds:
∀q' ∈ QA . (qA, a, q' ) ∈ ΔA ⊃ 𝖤q' ∈ QB . (qB, a, q' ) ∈ Δˆ B ∧ (q' , q' ) ∈ R , 
A	A	B	B	A  B
∀q' ∈ QB . (qB, a, q' ) ∈ ΔB ⊃ 𝖤q' ∈ QA . (qA, a, q' ) ∈ Δˆ A ∧ (q' , q' ) ∈ R . 
B	B	A	A	A  B
The iotss A and B are observationally equivalent, denoted by A ≈ B, if there exists a weak bisimulation R between A and B with (q0,A, q0,B) ∈ R.

Operators
For deriving behaviours in our component framework we will use the following operators on iotss: hiding, relabelling and the formation of products. Hiding and relabelling on iotss are generalisations of the usual operators used in various process algebras (see, e.g., [26,23]), the product of iotss is defined in accordance with the product of interface automata [12].
Hiding. Hiding is used to turn a subset of the labels of an iots into the invisible action τ . Formally, the hiding of an iol L = (I, O, T ) w.r.t. a subset H ⊆  L is the iol L/H = (I \ H, O \ H, T \ H). The hiding of an iots A = (L, Q, q0, Δ) w.r.t. a label set H ⊆ L (A) is the iots A/H = (L/H, Q, q0, Δ/H) where Δ/H = {(q, τ, q') | (q, a, q') ∈ Δ ∧ a ∈ H}∪ {(q, a, q') | (q, a, q') ∈ Δ ∧ a ∈/ H}.
In many cases we will choose H = T , i.e., we will hide all internal labels. Then, for an iol L = (I, O, T ), we write Lξ for L/T and, for an iots A over L, we write Aξ for A/T .
Relabelling. A relabelling is used for renaming labels and for changing the kind of labels. Formally, a relabelling ρ : L → L' from an iol L = (I, O, T ) to an iol L' = (I', O',T ') is defined by a function from L to L' for which we also write ρ. The relabelling of an iots A = (L, Q, q0, Δ) w.r.t. a relabelling ρ : L → L' is the iots Aρ = (L', Q, q0, Δρ) where Δρ = {(q, ρ(l), q') | (q, l, q') ∈ Δ ∧ l ∈  L}∪ {(q, τ, q') | (q, τ, q') ∈ Δ}.
A particular application of relabelling is the internalisation of (some) input and

output labels. For an iol L = (I, O, T ) and a subset X ⊆ I ∪ O, we define the internalisation relabelling θX : (I, O, T ) → (I \ X, O \ X, T ∪ X) with θX (l)= l for l ∈ L.
Given two relabellings ρ1 and ρ2 which coincide on all elements in the intersection of their domains, we denote their union (as function graphs) by ρ1 ∪ ρ2.
Product. The formation of the product of two iotss expresses their parallel compos- ition with synchronisation on identical input and output labels. To construct the product the iolss of the given iotss must be composable. Two iolss L1 = (I1, O1, T1) and L2 = (I2, O2, T2) are composable if I1∩I2 = ∅, O1∩O2 = ∅, T1∩(I2∪O2∪T2)= ∅, and T2 ∩ (I1 ∪ O1 ∪ T1)= ∅. The shared labels of composable iolss L1 and L2, writ- ten L1 0 L2, are given by (I1 ∩ O2) ∪ (O1 ∩ I2). The product of two composable iolss L1 and L2 is the iol L1 ⊗ L2 = ((I1 ∪ I2) \ (L1 0 L2), (O1 ∪ O2) \ (L1 0 L2), T1 ∪ T2 ∪ (L1 0 L2)) which moves the shared labels to the internal labels. Two iotss A1 and A2 are composable if L(A1) and L(A2) are composable. The product of two composable iotss A1 = (L1, Q1, q0,1, Δ1) and A2 = (L2, Q2, q0,2, Δ2) is the iots A1 ⊗ A2 = (L1 ⊗ L2, Q1 × Q2, (q0,1, q0,2), Δ) where
Δ= {((q1, q2), a, (q' , q2)) | (q1, a, q' ) ∈ Δ1 ∧ q2 ∈ Q2 ∧ a ∈/ L1 0 L2}∪ 
1	1
{((q1, q2), a, (q1, q' )) | (q2, a, q' ) ∈ Δ2 ∧ q1 ∈ Q1 ∧ a ∈/ L1 0 L2}∪ 
2	2
{((q1, q2), a, (q' , q' )) | (q1, a, q' ) ∈ Δ1 ∧ (q2, a, q' ) ∈ Δ2 ∧ a ∈ L1 0 L2} .
1  2	1	2
Observational equivalence is a congruence w.r.t. hidings, relabellings and products. For hiding and relabelling this follows directly from the definitions and corresponds to the respective facts for standard process algebras, like [23], since observational equivalence is independent of the kind of the labels. The preservation of observational equivalence by the product follows from the facts that observa- tional equivalence is a congruence w.r.t. parallel composition with synchronisation of shared labels [23] and that the equality of labellings is preserved by the product.
Lemma 2.1 Let A, B, and C be iotss.
If A ≈ B and H ⊆ L (A), then A/H ≈ B/H.
If A ≈ B and ρ : L(A) → L' is a relabelling, then Aρ ≈ Bρ.
If A ≈ B and A and C are composable, then A ⊗ C ≈ B ⊗ C.
The product is commutative and associative up to observational equivalence. Commutativity is straightforward from the definitions; associativity carries over from the corresponding fact for interface automata [12] taking into account also τ - transitions. Furthermore, hiding of non-shared labels commutes with the formation of products.
Lemma 2.2 Let A, B, and C be iotss.
If A and B are composable, then A ⊗ B ≈ B ⊗ A.
If A, B, and C are pairwise composable, then (A ⊗ B) ⊗ C ≈ A ⊗ (B ⊗ C).
If A and B are composable with shared labels S = L(A) 0 L(B), and H ⊆

L (A) with H ∩ S = ∅, then (A/H) ⊗ B ≈ (A ⊗ B)/H.
For a finite index set I, we write  i∈I Ai for the product of the iotss Ai with
i ∈ I, which is justified by Lem. 2.2(ii).
Component Model
Building upon ideas from ROOM [30], we consider components to be strongly en- capsulated behaviours. Encapsulation is achieved by ports which regulate any in- teraction of components with their environment. Components can be hierarchically structured containing again an assembly of components and connectors. We first give an overview of our component model by means of a (semi-formal) metamodel and illustrate its application by an example. We then complement the discussion with a formal algebraic component model which forms the basis of the subsequent analyses.

Metamodel
Figure 1 shows the metamodel of our component model which is an extension of the model in [19] taking more specifically into account different kinds of behaviours and connectors. The model is similar to UML2’s view on components [27]. Its embedding into the UML2 is sketched in [19] and carries over to the extended model straightforwardly.









Figure 1. Component metamodel

A port describes a view on a component (like particular functionality or com- munication), the operations offered and needed in the context of this view and the mandatory sequencing of operation calls from the outside and from the inside. The operations offered by a port are summarised in its provided interface; the operations needed in its required interface. The sequencing of operations being called from and on a port is described in a port protocol speciﬁcation. To be precise, a port is in fact considered as a port type that can be used in local port declarations of a component.

There are two kinds of components, simple components and composite compon- ents which are abstracted in the metaclass component. Any kind of component has a set of port declarations, which introduce local port names with corresponding port types, and an associated observable behaviour. In our metamodel a component rep- resents in fact a component type that can be used in component declarations when building component assemblies. Each component should be correct with respect to its ports, i.e., the protocol of its ports should indeed be supported by the observ- able behaviour of the component. For each simple component an internal behaviour speciﬁcation is given. A composite component encapsulates an assembly of compon- ents and declares delegate connectors. An assembly defines the internal structure of the composite component in terms of a set of local component declarations and local (binary) assembly connector declarations that connect local components via their ports. Non-connected (open) ports of local components may be connected to so-called relay ports of the surrounding composite component, using delegate con- nector declarations. Relay ports are not explicitly distinguished in the metamodel. Also an assembly has an associated behaviour. As indicated by the slash symbol in Fig. 1 the observable behaviour of a component as well as the assembly beha- viour are derived behaviours. The observable behaviour of simple components is derived from the components’ given internal behaviour specification; for composite components the observable behaviour is derived from the behaviour of its assembly which in turn is derived from the observable behaviours of the local components within the assembly and their connections.
Example: A Compressing Proxy System
We illustrate our component model by the compressing proxy system also used by Bernardo et al. [5]. In contrast to [5] we use here an additional component for the compression of graphical data which will be useful for our discussions later on: An HTTP proxy server mediates connections between a web server and their clients. In order to increase network bandwidth, the proxy server may apply different compres- sion techniques depending on the kind of information transferred. The proxy server distinguishes between textual (txt) and graphical (gif) data and applies different compression tools before sending the data further downstream.
We use UML2 notation for concretely specifying the static structure of compon- ent systems. The behaviours will semantically be based on I/O-transition systems (iotss, see Sect. 2). We do not intend to propose a particular, e.g., process algebraic or state machine, syntax for describing behaviours. In fact, any concrete syntax could be used as long as an interpretation by iotss is provided. Here, we use the LTSA tool [23] for the graphical representation of iotss. For the transitions in the LTSA graphs we indicate that a label i is an input (provided) label by the visual representation i_ and, symmetrically, that a label o is an output (required) label by _o. An initial state is indicated by 0. Several transitions between two states will be shown as a single transition with a set of labels. 2

2 The LTSA tool supports the process algebra FSP [23]. Hence, to obtain the graphs, we had to define the behaviours used in the example by appropriate FSP terms. These terms are not shown here because they

Static Structure
We describe the static structure of the compressing proxy system by a composite component type CompressingProxy which consists of an assembly of three simple components with types Adaptor, GZip, and GifToJpg introduced by the respective component declarations adapt : Adaptor, gzip : GZip, and gifToJpg : GifToJpg in Fig. 2 3 . The adaptor is responsible for distinguishing between textual and graphical data and forwarding the textual data for compression to gzip, which employs the gzip utility, and the graphical data to gifToJpg converting GIF- into JPG-images.


Figure 2. Static structure of a compression proxy server
The simple components as well as the composite component show port declar- ations (like t : TxtCompr or l : UpStream). The port declarations of the composite component are called relay ports. Port declarations are interconnected by as- sembly connectors inside the assembly (like the connector tz between t : TxtCompr and z : Zip) 4 and delegate connectors to the outside (like the anonymous connector between u : UpStream and l : UpStream).
The provided and required interfaces of the port types of the compressing proxy system are depicted with the UML ball-and-socket notation on the right-hand side of Fig. 2. The operations of these interfaces are as follows: openTxt, openGif (USP); compressed (DSR); txt, endTxt (TCR); bufFul, zip, endZip (TCP); gif (GCR); and jpg (GCP). We do not consider operations with parameters here. If two ports are connected by an assembly connector, the provided interface of the one port has to be equal to the required interface of the other, and vice versa. 5

are irrelevant for our study.
3 The UML2 declarations in Fig. 2 also show multiplicities, indicating how many instances of a component or port may exist. However, we only specified singletons (multiplicity 1) leaving the discussion of arbitrary multiplicities to future work.
4 UML2 would allow for arbitrary n-ary connectors with n > 2 which we do not consider here.
5 In general, one could use a more flexible condition such that the required interface of one port is included

Behaviour
Based on the static structure of the compressing proxy system the informal descrip- tion of its intended behaviour reads as follows: A proxy of type CompressingProxy receives stream-based data on its port l which is delegated to the port u of the contained component adapt. The adaptor distinguishes textual and graphical data received at u and forwards textual data for compression via port t and graphical via port g. After receiving the compression result, adapt sends the data further downstream using d which is relayed to r.
Speciﬁed Behaviours for Ports and Simple Components. A port protocol regulates the communication sequences according to the particular view of the port. The port protocols are specified by the component designer as iotss; the port protocols for the compressing proxy system are depicted in Fig. 3. They use the operations of the provided interface of the port as inputs and the operations of its required interface as outputs. The transitions of the protocol may show the invisible action τ (like in GifCompr or ToJpg) to reflect a possible internal choice of the port’s owner component; but they do not show internal actions.

(a) UpStream and DownStream	(b) TxtCompr	(c) GifCompr

(d) Zip	(e) ToJpg

Figure 3. Protocols for the ports in Fig. 2

In particular, the protocol of the port (type) TxtCompr used in the component (type) Adaptor, see Fig. 3(b), has as inputs bufFul, zip, and endZip; and as outputs txt and endTxt. After having sent an initial part of textual data by txt, there is a choice between sending further text pieces by txt until the end of the text is reached (notified by endTxt), or receiving the message bufFul which indicates buffer overflow of the compression tool. In the first case, the port waits to receive zip data (zip) until transmission end is signalled by endZip. In the second case, the port must retrieve the already compressed data via zip and communication proceeds until eventually the end of the text will be reached. In both cases a new communication can be started by sending again an initial part of the next textual data to be compressed via txt. As an example for a protocol with τ -transitions, consider Fig. 3(c) for GifCompr: After sending gif the port can receive the compressed image by jpg but it can also perform an internal choice not to wait for the result of the previous request.

in the provided interface of the other one. However, it is technically more convenient to use the more restrictive condition from above.

The internal behaviour of simple components, which are basic building blocks, has also to be specified by the component designer as an iots. Since a component can only communicate with its environment via its ports, any message received or sent has now the form p.m where p is a port name and m is a message according to the provided or required interface of the port. In contrast to port behaviours, we also consider internal actions of components represented by internal transition labels.

Figure 4. Behaviour of Adaptor 6

For instance, the internal behaviour of the simple component (type) Adaptor is specified in Fig. 4. The messages received are u.openTxt, u.openGif, t.zip, t.bufFul, t.endZip, and g.jpg; the messages sent are d.compressed, t.txt, t.endTxt, and g.gif; and the only internal action is noJpg. The behaviour specification introduces an internal transition (9, noJpg, 7), reifying the τ -transition of the port protocol in Fig. 3(c). The transition’s trigger is not further specified; one may think that the component waits only a fixed amount of time for the compression of gif data, and if the compression takes too long, it sends the gif data further downstream. We do not show specific- ations of the internal behaviour of the simple components GZip and GifToJpg. Since these components are equipped with one port only, their behaviour specifications would not differ too much from their port protocol specifications (Fig. 3(d), 3(e)), but, for of GifToJpg, the internal behaviour specification would reveal the internal decisions indicated by the τ -transitions in the protocol of ToJpg.
Derived Behaviours for Components, Assemblies and Composite Components. When using a component, be it simple or composite, in a component system, the designer of the system is not interested in the internal behaviour of the component, but only in the behaviour which is observable from the outside of the component. Thus, each component is equipped with an observable behaviour. For a simple component this observable behaviour can be computed from the internal behaviour by hiding all internal messages. In the case of Adaptor the single internal action noJpg is turned into τ .
Components are used in assemblies via component declarations showing a name and a component type. In order to distinguish the different components inside an

6 The behaviour corresponds exactly to the adaptor behaviour in [5] if we remove the communication concerning the port g for compression of graphical data, that is, if we remove the states 8 and 9 and the respective transitions.

assembly, the labels of their observable behaviours are prefixed by the name of the component declaration, thus turning, e.g., u.openGif of Adaptor into adapt.u.openGif. The overall behaviour of an assembly shows both, the interaction behaviour of the used components that are connected within the assembly via their ports, and the communication potential of the open ports of components that are not con- nected within the assembly. Hence, an assembly behaviour is a derived behaviour, given by the composition of the observable behaviours of all declared components of the assembly, synchronised according to the given (binary) assembly connectors. Note that we use the observable behaviour of components when constructing an assembly behaviour since in this way internal component behaviours are abstracted away before the composition. This is particularly useful when constructing hier- archical components which encapsulate an assembly and which can again be used as parts of other assemblies on the next hierarchy level. The synchronisation within an assembly maps the labels of the ports connected by an assembly connector into one common name, thus making them shared. Open ports do not appear in as- sembly connectors, therefore those parts of component behaviours related to open ports remain unsynchronised. In general, we also consider the case where a port is neither open nor connected to another port. Technically, these ports are closed by applying unary connectors. The internal actions of an assembly behaviour are the synchronised transitions of the composition, representing communication of the components via their connected ports and the not further used actions on closed ports. The behaviour on the remaining open ports is described by their input and
output actions which are the only external actions of an assembly.
For instance the behaviour of the assembly underlying the CompressingProxy component is computed by the synchronisation of the observable behaviours of the three components adapt : Adaptor, gzip : Gzip, and gifToJpg : GifToJpg according to the connectors of their ports. The assembly behaviour has 30 states and 65 transitions (including τ -transitions). After minimisation we obtain the iots shown in Fig. 5(a). The synchronisation labels are internal actions; e.g., the output label adapt.g.gif of adapt : Adaptor and the input label gifToJpg.j.gif of gifToJpg : GifToJpg are synchronised in accordance with the connector gj by the internal label gj.gif.

(a) Assembly behaviour of CompressingProxy	(b)	Observable behaviour		of CompressingProxy

Figure 5. Assembly behaviour and observable behaviour of the compressing proxy system
Finally, the observable behaviour of composite components is derived using

an external view of its underlying assembly where the synchronised communica- tions between the components connected within the assembly are abstracted into τ -transitions. Moreover, the input and output actions of a composite component are delegated between its relay ports and the open ports of the assembly. Figure 5(b) shows the resulting observable behaviour of CompressingProxy after minimisation
w.r.t. observational equivalence.

Correctness of Components
Each component should be correct with respect to its ports, i.e., the views of its ports should indeed be backed by the observable behaviour of the component. Component correctness can be checked for a component C and one of its port declarations p : P as follows: First, all labels of the component’s observable behaviour which are not of the form p.m, that is, do not pertain to the port p, are abstracted into τ , i.e., we construct the projection of the observable behaviour of C on the port p. Second, all input and output labels of the protocol of P are prefixed by p. Then C is correct
w.r.t. its port p : P if the projected component behaviour and the prefixed iots of the protocol are observationally equivalent. C is correct, if it is correct w.r.t. all of its ports.
For instance, component Adaptor is correct w.r.t. its port t : TxtCompr: We replace all labels in Fig. 4 not prefixed by t by τ and prefix all labels of Fig. 3(b) by t. Then it can be checked (using, e.g., the minimisation functionality of the LTSA tool) that these iotss are observationally equivalent. In fact, all components in the example, including CompressingProxy itself, are correct. The correctness of the latter can be easily checked by comparing the respective projections of Fig. 5(b) with the iotss in Fig. 3(a).

Algebraic Component Model
We complement the metamodel presentation of our component model with an al- gebraic description, which defines formally all previously mentioned concepts and behaviours in terms of algebraic structures and iotss resp.; see Sect. 2. In particular, we distinguish between those behaviours which have to be provided by the compon- ent developer and those that are computed (derived), by rendering the latter as definitions. We use italics for denoting all kinds of derived operators.
For the computation of the different behaviours we employ several relabelling functions on iolss and iotss, which specialise the relabelling as introduced in Sect. 2.2. We assume a primitive domain Nm of names.
A prefix relabelling prefixes all labels in an iots by a given name. For an iol
L = (I, O, T ) and some name n, we define the iol n.L = (n.I, n.O, n.T ) where n.I =
{n.i | i ∈ I} and similarly for n.O and n.T . The preﬁx relabelling ρn : L → n.L is defined by ρn(l)= n.l for l ∈ L. Given an iots A and a name n, we write n.A for the iots Aρn.
A match relabelling maps differently prefixed input or output labels into a single common name. For an iol L = (I, O, T ), X ⊆ Nm and y ∈ Nm, we define the iol

Lμ(X,y) = (Iμ(X,y), Oμ(X,y),T ) where Iμ(X,y) = {y.l | 𝖤x ∈ X . x.l ∈ I}∪ {l | l ∈ I ∧ ∀x ∈ X. l /= x.l'} and similarly for Oμ(X,y). The match relabelling μ(X,y) : L → Lμ(X,y) is defined by μ(X,y)(x.l)= y.l if x ∈ X and x.l ∈ I ∪ O, and μ(X,y)(l')= l' otherwise.
A binary synchronisation relabelling σ(X,y) is the match relabelling μ(X,y) with
|X| = 2. A unary synchronisation relabelling σ(x,y) is the composition θW ◦ μ({x},y) of a match relabelling and an internalisation with W = {y.l | y.l ∈ Iμ({x},y) ∪ Oμ({x},y)}. A relay relabelling ρ(x,y) is the match relabelling μ({x},y).
Ports. We assume a domain of messages Msg, interfaces If and ports (more pre- cisely, port types) Port, together with functions msg : If → ℘Msg to return the messages constructed from the operations of an interface, and prv : Port → If and req : Port → If for the provided and required interfaces of a port. For a port P we write msg(P ) for msg(prv(P )) ∪ msg(req(P )). We also assume a domain of port declarations PortDcl with a function nm : PortDcl → Nm for the name and a func- tion ty : PortDcl → Port for the port (type); we write p : P for a port declaration d with nm(d)= p and ty(d)= P .
For each port P ∈ Port we assume given its protocol (speciﬁcation), writ- ten prot(P ), which is an I/O-transition system ((I, O, T ), Q, q0, Δ) with I = msg(prv(P )),O = msg(req(P )) and T = ∅.
Definition 3.1 The protocol of a port declaration p : P is given by prot(p : P )= 
p.prot(P ).
Components. We assume a domain Cmp of components (more precisely, component types) and a function ports : Cmp → ℘PortDcl returning the ports declared for a component. For a component C and port declaration p : P we write C[p : P ] if p : P ∈ ports(C). Like for ports, we assume a domain of component declara- tions CmpDcl with a function nm : CmpDcl → Nm for the name and a function ty : CmpDcl → Cmp for the component (type); we write c : C for a component declaration d with nm(d)= c and ty(d)= C. The ports of a component declaration are given by ports(c : C)= {c.p : P | p : P ∈ ports(C)}.
For each component C ∈ Cmp there is a derived observable behaviour, written obs(C), which is an iots ((I, O, T ), Q, q0, Δ) with I = {p.msg(prv(P )) | p : P ∈ ports(C)}, O = {p.msg(req(P )) | p : P ∈ ports(C)} and T = ∅. How the observable behaviour of a component is defined depends on whether the component is simple or composite; cf. Def. 3.6 and Def. 3.7 below.
Definition 3.2 The observable behaviour of a component declaration c : C is given by obs(c : C)= c.obs(C).
Definition 3.3 The behaviour of a component C observable at port p : P ∈ ports(C) is given by obsp:P (C) = obs(C)/H with H = L (obs(C)) \ {p.m | m ∈ msg(P )}.
Definition 3.4 A component C is correct w.r.t. a port declaration p : P  ∈
ports(C), if obsp:P (C) ≈ prot(p : P ). A component C is correct, if it is correct
w.r.t. all p : P ∈ ports(C).

Connectors. We assume a domain Conn of connectors (more precisely, connector types) with a function ports : Conn → ℘PortDcl yielding the connected port de- clarations such that 1 ≤ |ports(K)|≤ 2 for each K ∈ Conn. We assume a domain of connector declarations ConnDcl with a function nm : ConnDcl → Nm for the name and ty : ConnDcl → Conn for the connector (type); we write k : K for a connector declaration d with nm(d)= k and ty(d)= K. Moreover, if ports(K)= {p : P, q : Q} we write k : (p : P, q : Q) and if ports(K) = {p : P } we write k : (p : P ). In the latter case, k is a unary connector which will be technically needed in our reduction algorithm later on.
The domain Conn has two disjoint sub-domains AsmConn ⊆ Conn, DlgConn ⊆ Conn of assembly and delegate connectors, respectively. Delegate connectors are always binary, i.e., for each K ∈ DlgConn we have |ports(K)| = 2. For an assembly connector with port declarations {p1 : P1, p2 : P2} the required interface req(P1) has to be equal to the provided interface prv(P2) and vice versa. For a delegate connector the provided and required interfaces of its port declarations must coincide.
Assemblies. We assume a domain Asm with functions cmps : Asm → ℘CmpDcl re- turning an assembly’s declared components and conns : Asm → ℘ConnDcl yielding its declared connectors. An assembly a ∈ Asm has to be well-formed: (i) it shows only assembly connectors, i.e., if k : K ∈ conns(a), then K ∈ AsmConn; (ii) only ports of components inside a are connected, i.e., for all k : K ∈ conns(a) we have that ports(K) ⊆  {ports(c : C) | c : C ∈ cmps(a)}; and (iii) there is at most one connector for each port, i.e., if c.p : P ∈  {ports(c : C) | c : C ∈ cmps(a)} and k : K, k' : K' ∈ conns(a) with c.p : P ∈ ports(K) ∩ ports(K'), then k : K = k' : K'. For an assembly a we define cmp :  {ports(c : C) | c : C ∈ cmps(a)}→ cmps(a)
by cmp(c.p : P ) = c : C if c.p : P ∈ ports(c : C). The components of an assembly a may show open ports which are not connected and we let open(a)=  {ports(c : C) | c : C ∈ cmps(a)}\  {ports(K) | k : K ∈ conns(a)}.
Definition 3.5 The behaviour of an assembly a is given by
beh(a)=   c:C∈cmps(a)(obs(c : C))σ , 
where σ =  {σ({c.p,d.q},k) | 𝖤k : K ∈ conns(a) . ports(K) = {c.p : P, d.q : Q}} ∪
  {σ(c.p,k) | 𝖤k : K ∈ conns(a) . ports(K)= {c.p : P }}.
We write ⟨C; K⟩ for an assembly a with the set of component declarations cmps(a) = C and the set of connector declarations conns(a) = K. We abbreviate the synchronisations used in the computation of the assembly behaviour in Def. 3.5 by σK.
Simple Components. We assume a sub-domain SCmp ⊆ Cmp of simple components.
For each SC ∈ SCmp we assume given its behaviour (speciﬁcation), written beh(SC), which is an iots ((I, O, T ), Q, q0, Δ) where I = {p.msg(prv(P )) | p : P ∈
ports(SC)} and O = {p.msg(req(P )) | p : P ∈ ports(SC)}.
Definition 3.6 The observable behaviour of a simple component SC is given by obs(SC)= beh(SC)ξ.

Recall that the operator ξ hides the internal labels of an iots, thus obs(SC) shows the external view of the behaviour of C.
Composite Components. We assume a sub-domain CCmp ⊆ Cmp of composite components, disjoint to SCmp. We assume functions asm : CCmp → Asm returning the assembly of a composite component, and conns : CCmp → ℘ConnDcl returning the connectors declared in a composite component. Similar to assemblies we require a composite component CC to be well-formed: (i) it shows only delegate connectors, i.e., if k : K ∈ conns(CC), then K ∈ DlgConn; (ii) all open ports of the asm(CC) are connected, i.e., for all c.p : P ∈ open(asm(CC)) there is k : K ∈ conns(CC) such that c.p : P ∈ ports(K); and (iii) all relay ports are connected, i.e., for all r : R ∈ ports(CC) there is a unique k : K ∈ conns(CC) with ports(K) = {c.p : P, r : R} and c.p : P ∈ open(asm(CC)).
Definition 3.7 The observable behaviour of a composite component CC is given by
obs(CC)= (beh(asm(CC))ξ)ρ , 
where ρ =  {ρ(c.p,r) | 𝖤k : K ∈ conns(CC) . ports(K)= {c.p : P, r : R}}.
We write ⟨a; P; K⟩ for a composite component CC with assembly asm(CC)= a, set of (relay) port declarations ports(CC) = P and set of (delegate) connector declarations conns(CC)= K.
On the Computation of Observable Behaviours
Let us now discuss how we can efficiently construct the observable behaviour of a component. Since for simple components a specification of its internal behaviour must be explicitly provided, their observable behaviour can be directly constructed and analysed. The problem with analysing the observable behaviour of a composite component is that in this case the observable behaviour of the component relies on the behaviour of the underlying assembly whose construction may be very complex or even not feasible due to state explosion (even if the observable behaviours of the subcomponents are first minimised w.r.t. observational equivalence). To overcome this problem, we realise that several components within an assembly may not play any role for the observable behaviour of the surrounding composite component CC. These subcomponents of CC are called behaviourally neutral and may be removed from the assembly without affecting the observable behaviour of CC.
Behaviourally Neutral Components and Reduction Strategy
For the formal definition of behavioural neutrality we have to take into account that if we remove components and their connectors from an assembly, components with artificially opened ports remain. These ports should not be available for new connections which is modelled by using unary connectors. Behavioural neutrality is now defined in terms of observational equivalence between the behaviour of an

assembly with two connected components and the behaviour of an assembly with a single component and the binary connector replaced by a unary one.
Definition 4.1 The component declaration d : D[q : Q] is behaviourally neutral at
q for the component declaration c : C[p : P ] at p, if
beh(⟨c : C, d : D; k : (c.p : P, d.q : Q)⟩) ≈ beh(⟨c : C; k : (c.p : P )⟩) .
Note that a component declaration d : D[q : Q] can only be neutral at q for another component declaration if q : Q is the only non-trivial port declaration of D, because otherwise the labellings of the compared assemblies would not be the same. Notions similar to behavioural neutrality are used by Bernardo et al. [5, Def. 4.3] under the name of compatibility and Cheung and Kramer [10, Sect. 6.3] under the name of transparency. In fact, Def. 4.1 lifts a notion of neutrality between iotss to component systems, which is formally defined as follows: An iots B is called neutral for an iots A, if A and B are composable and AθS ≈ A ⊗ B where S = L(A) 0 L(B) are the shared labels of A and B and θS internalises S in A. Intuitively, neutrality expresses that B does not restrict the behaviour given by A if B is composed with A.
Based on the notion of behavioural neutrality, we can describe our reduction strategy for assemblies: If a component at the border of an assembly topology is behaviourally neutral for the next component attached to it, this leaf can not have a behavioural effect on the remaining assembly. We can thus reduce the assembly by removing a neutral leaf component. In order to obtain again a syntactically well-formed assembly, the particular binary connector is removed and replaced by a unary connector (Lem. 4.2). In a second step, we can eliminate also the unary connector, by hiding the port to which the neutral leaf was connected (Lem. 4.3).
Formally, the leaves of an assembly are component declarations which are con- nected by exactly one binary assembly connector and do not show open ports: For a ∈ Asm we let leaves(a) ⊆ cmps(a) such that d : D ∈ leaves(a), if, and only if, open(a) ∩ ports(d : D) = ∅ and |{k : K | k : K ∈ conns(a) ∧ |ports(K)| = 2 ∧ ports(K) ∩ ports(d : D) /= ∅}| = 1.
Lemma 4.2 Let a = ⟨c : C[p : P ],d : D[q : Q], C; k : (c.p : P, d.q : Q), K⟩ be an assembly with C ⊆ CmpDcl, K ⊆ ConnDcl, and d : D ∈ leaves(a). If d : D is behaviourally neutral at q for c : C at p then
beh(⟨c : C, d : D, C; k : (c.p : P, d.q : Q), K⟩) ≈ beh(⟨c : C, C; k : (c.p : P ), K⟩) .
Proof By definition of assembly behaviours, we have that
beh(⟨c : C, d : D, C; k : (c.p : P, d.q : Q), K⟩)= 
obs(c : C)σ ⊗ obs(d : D)σ ⊗  c':C'∈C obs(c' : C')σ , 
beh(⟨c : C, C; k : (c.p : P ), K⟩)= obs(c : C)σ' ⊗  c':C'∈C obs(c' : C')σ'
with synchronisations σ = σ({c.p,d.q},k) ∪ σK and σ' = σ(c.p,k) ∪ σK. The neutrality of
d : D at q for c : C at p amounts to obs(c : C)σ(c.p,k) ≈ obs(c : C)σ({c.p,d.q},k) ⊗obs(d :

D)σ({c.p,d.q},k). Thus, by Lem. 2.1(ii), we have obs(c : C)σ' ≈ obs(c : C)σ ⊗ obs(d :
D)σ. As neither σ(c.p,k) nor σ({c.p,d.q},k) change  c':C'∈C obs(c' : C'), we also have
  c':C'∈C obs(c' : C')σ =  c':C'∈C obs(c' : C')σ', and the claim follows by applying Lem. 2.1(iii).	 
For a component C with p : P ∈ ports(C) the hiding of the port p : P in C, written C \ (p : P ), results in a component C' ∈ Cmp such that ports(C') = ports(C) \ {p : P } and obs(C')= obs(C)/L (obsp:P (C)).
Lemma 4.3 Let c : C ∈ CmpDcl and p : P ∈ ports(C). Then
beh(⟨c : C, C; k : (c.p : P ), K⟩)/{k.m | m ∈ msg(P )}≈ beh(⟨c : C \(p : P ), C; K⟩) .
Proof By definition of assembly behaviours and hiding of ports we have that
beh(⟨c : C, C; k : (c.p : P ), K⟩)/H = (c.obs(C)σ ⊗  c':C'∈C obs(c' : C')σ)/H ,
beh(⟨c : C \ (p : P ), C; K⟩)= 
c.(obs(C)/L (obsp:P (C)))σK ⊗  c':C'∈C obs(c' : C')σK
with synchronisations σ = σ(c.p,k) ∪ σK and hiding H = {k.m | m ∈ msg(P )}. As H does not affect C and K, the right-hand side of the first equation is ob- servationally equivalent to c.obs(C)σ/H ⊗ c':C'∈C obs(c' : C')σ by Lem. 2.2(iii). Now c.obs(C)σ/H = (c.obs(C)σ(c.p,k)/H)σK. By definition of unary synchron- isation relabellings we have for L(obs(C)) = (I, O, T ) and L(obs(C)σ(c.p,k)) = (I', O',T ') that k.m ∈ T ' iff p.m ∈ I ∪ O. Thus we obtain c.obs(C)σ(c.p,k)/H ≈ c.(obs(C)/L (obsp:P (C))).  Since removing σ(c.p,k)  from σ does not change
  c':C'∈C obs(c' : C'), we have  c':C'∈C obs(c' : C')σ =  c':C'∈C obs(c' : C')σK and the claim follows by applying Lem. 2.1(iii).	 
The two lemmas allow us to remove neutral components one after the other. The neutral leaves of an assembly a are defined by neutralleaves(a) ⊆ cmps(a) such that d : D ∈ neutralleaves(a), if, and only if, there are component declarations c : C[p : P ],d : D[q : Q] ∈ cmps(a), d : D ∈ leaves(a), k : (c.p : P, d.q : Q) ∈ conns(a) and d : D is behaviourally neutral at q for c : C at p. An assembly a is called ﬁnite if cmps(a) is finite. Now define the syntactical reduction of a finite assembly a ∈ Asm by red : Asm → Asm such that red(a) is the assembly computed by the following algorithm:
while neutralleaves(a) /= ∅
do d : D ← choose from neutralleaves(a)
let a = ⟨c : C, d : D, C; k : (c.p : P, d.q : Q), K⟩ with d : D neutral at q for c : C at p
a ← ⟨c : C \ (p : P ), C; K⟩ od
Of course, in general, the assembly a and the reduced assembly red(a) will not be observationally equivalent, because by hiding of ports red(a) shows less communica- tion than a. However, after hiding all internal actions with the ξ-operator we obtain observationally equivalent behaviours.

Lemma 4.4 Let a be a ﬁnite assembly. Then beh(a)ξ ≈ beh(red(a))ξ.
Proof The algorithm terminates for each finite assembly a. For each iteration of the while-loop let a0 be the assembly on entry and a1 the one on exit. We show beh(a0)ξ ≈ beh(a1)ξ. Let a0 = ⟨c : C, d : D, C; k : (c.p : P, d.q : Q), K⟩ with d : D neutral at q for c : C at p; then a1 = ⟨c : C \ (p : P ), C; K⟩. By Lem. 4.2, Lem. 4.3 with H = {k.m | m ∈ msg(P )}, and Lem. 2.1(i) we have
beh(a0)/H = beh(⟨c : C, d : D, C; k : (c.p : P, d.q : Q), K⟩)/H ≈
beh(⟨c : C, C; k : (c.p : P ), K⟩)/H ≈ beh(⟨c : C \ (p : P ), C; K⟩)= beh(a1) .
As all labels in H are internal, we obtain the invariant beh(a0)ξ ≈ beh(a1)ξ. The claim of the lemma follows from the invariant.	 
The reduction strategy for assemblies is directly applicable to the computation of the observable behaviour of composite components
Theorem 4.5 Let ⟨a; P; K⟩ ∈ CCmp with a ﬁnite. Then obs(⟨a; P; K⟩) ≈ obs(⟨red(a); P; K⟩) .
Proof By definition, leaves(a) do not have open ports. Thus no components with a delegate connector to a relay port can be removed from a by the reduction algorithm. Therefore, ⟨red(a); P; K⟩ is a well-formed composite component. Then the result follows from Lem. 4.4 by renaming actions on open ports of a, and hence of red(a), to actions on the relay ports P.	 
Our reduction strategy is sound for arbitrarily structured finite assemblies. But it is particularly useful for assemblies with an acyclic topology and for compos- ite components which are rooted, i.e., exactly one of the assembly components is connected to the relay ports of the composite component, like in Fig. 6. Then, in

Figure 6. Composite component with acyclic assembly
the best case, all subcomponents but the root rc : RC can be removed such that obs(CC) ≈ obs(rc : RC)ρ where ρ is a relay relabelling. Note that acyclic topologies do not present a too severe restriction in terms of practical applicability. There is,

e.g., a direct match with the architectural pattern “Blackboard” [8] for the design of distributed communications using a common data structure. Also, the architectural design of a large part of the Common Component Modelling Example [28,19] ad- heres to an even more restricted acyclic structure, called “star topology” [5], where each leaf is attached to one centre component. Our reduction strategy can also be effectively applied to assembly topologies containing cycles as long as there are neutral leaves around that can be removed. When a cycle is reached we would propose to encapsulate the cycle into a new, nested composite component and to proceed as before by looking again for neutral leaves.
A closer look reveals that in order to decide on neutrality along Def. 4.1, one needs to compute the composition of a leaf component behaviour with the behaviour of the attached component, which can still be quite expensive. To further optimise our method we are interested in criteria to avoid composition of full behaviours of components and to compose smaller transition systems instead. In Sect. 4.3 we show that port behaviours, in particular weakly deterministic port behaviours, can be used to provide such criteria. For this purpose we first need some further technical definitions and results on I/O-transition systems which are presented in the following Sect. 4.2.
Weakly Deterministic I/O-Transition Systems and Neutrality Weak Traces
Given an iots A = (L, Q, q0, Δ), if we remove in each finite trace of A all occurrences of τ then we obtain the weak traces of A. Formally, for an iots A = (L, Q, q0, Δ) the transitive τ-closure of Δ is the relation Δˆ ∗ ⊆ Q ×  L∗ × Q defined as follows:
For a non-empty sequence of labels λ = l1 ... ln−1 ∈  L∗, (q, λ, q') ∈ Δˆ ∗, if there
are q = q1,..., qn = q' ∈ Q such that (qi, li, qi+1) ∈ Δˆ for 1 ≤ i < n; for the empty
sequence of labels ε, (q, ε, q') ∈ Δˆ ∗, if (q, τ, q') ∈ Δˆ ; see Sect. 2.1 for the definition of Δˆ . A weak trace of an iots A = (L, Q, q0, Δ) is a finite (possibly empty) sequence λ of labels in  L with (q0, λ, q) ∈ Δˆ ∗ for some q ∈ Q; the set of weak traces of A is denoted by T (A).
Lemma 4.6 If A and B are iotss with A ≈ B, then T (A)= T (B).
Proof Weakly bisimilar iotss have, up to occurrences of τ , the same finite traces. Hence they have the same weak traces.	 

Weakly Deterministic I/O-Transition Systems
An iots A is weakly deterministic if all finite traces of A which coincide up to τ lead to observationally equivalent elements of A. Formally, an iots A = (L, Q, q0, Δ) is weakly deterministic if for all weak traces λ ∈ T (A) the following holds: If
(q0, λ, q1) ∈ Δˆ ∗ and (q0, λ, q2) ∈ Δˆ ∗ then q1 ≈ q2, i.e., there is a weak bisimulation
R between A and A with (q0, q0) ∈ R and (q1, q2) ∈ R.
The notion of weak determinism corresponds to Milner’s (weak) determinacy [26, Def. 11.3, Ex. 11.1]; in particular, weak determinism is preserved by observational equivalence [26, Prop. 11.4]. Based on strong bisimulation which treats τ ’s like

ordinary internal labels also the notion of strong determinism may be defined (see Milner [26, Def. 11.2], Cheung and Kramer [10, Def. A.2]), replacing in the defini- tion of weak determinism the requirement of weak bisimulation by the strong notion. Then it may be observed that for iots without τ -transitions strong and weak de- terminism coincide. In App. A we prove that an iots A is weakly deterministic, if there is an observationally equivalent, minimal iots B without τ -transitions; such a B is a weakly deterministic iots without τ -transitions and hence strongly determ- inistic. By the transition minimisation procedure of Eloranta [13], a finite τ -free minimal iots is unique up to graph-isomorphism. Thus, for ensuring that a finite iots is weakly deterministic, it suffices to minimise the iots w.r.t. the number of states and transitions and to check that the resulting iots has no τ -transitions and that from each state there is at most one transition for each label.

Weak Determinism and Neutrality
Let us recall that an iots B is called neutral for an iots A, if A and B are composable and AθS ≈ A ⊗ B where S = L(A) 0 L(B) are the shared labels of A and B and θS internalises S in A. We extend a sufficient criterion, called “interface theorem”, from Cheung and Kramer [10] for determining neutrality to our setting. This criterion has been formulated for communicating finite-state processes where parallel composition involves an error state for failing communications and relies on traces, strong process equivalence and strongly deterministic finite-state processes. We generalise the assumptions to include not necessarily finite iots and use observational equivalence and weakly deterministic iotss. 7
Proposition 4.7 Let A and B be two composable iotss with L (B) ⊆ L (A), and let S = L(A) 0 L(B) and H = L (A) \ L (B). Let B be weakly-deterministic. Then B is neutral for A if, and only if, T (A/H) ⊆ T (B).
Proof First, let T (A/H) ⊆ T (B) hold.  Let A = (LA, QA, q0,A, ΔA), B =
(LB, QB, q0,B, ΔB), AθS  = (LAθS, QA, q0,A, ΔAθ ), A ⊗ B = (LA ⊗ LB, QA ×
QB, (q0,A, q0,B), ΔA⊗B).	Let R = {(qA, (qA, qB)) ∈ QA × (QA × QB) | 𝖤λ ∈
L (A)∗ . (q0,A, λ, qA) ∈ Δˆ ∗ ∧(q0,B, λ/H, qB) ∈ Δˆ ∗ } where λ/H is the sequence of la-
A	B
bels which results from λ when removing all labels in H. Then (q0,A, (q0,A, q0,B)) ∈
R. In order to show that R is a weak bisimulation between AθS and A ⊗ B, let (qA, (qA, qB)) ∈ R.
Let (qA, a, q' ) ∈ ΔAθ . If a ∈ H or a = τ , then ((qA, qB), a, (q' , qB)) ∈ ΔA⊗B
A	S	A
and (q' , (q' , qB)) ∈ R. If a ∈ S, let λ ∈ L (A) be a weak trace with (q0,A, λ, qA) ∈
A	A
Δˆ ∗  and (q0,B, λ/H, qB) ∈ Δˆ ∗ . Then λa ∈ T (A) and thus (λ/H)a = (λa)/H ∈

A	B	(1)
(1)

T (A/H) ⊆ T (B). Hence there is a q
∈ QB such that (q0,B, λ/H, q
) ∈ Δˆ ∗

and (
(1)
(2)
B	(1)	B	B

qB , a, qB ) ∈ ΔB. As B is weakly deterministic, qB  ≈ qB, and thus there
is a q'  ∈ QB with (qB, a, q' ) ∈ Δˆ B . Thus ((qA, qB), a, (q' , q' )) ∈ Δˆ A⊗B and
B	B	A  B
(q' , (q' , q' )) ∈ R.
A	A  B

7 This generalisation is mentioned by Cheung and Kramer [10, p. 354]; their definition of weak bisimulation, however, does not take into account that τ -transitions may be simulated by idling.

Let ((qA, qB), a, (q' , q' )) ∈ ΔA⊗B. Then either a = τ or a ∈ S or a ∈ H,
A  B

since L (B) ⊆ L (A). If (qA, τ, q' ) ∈ ΔA then q'  = qB, (qA, τ, q' ) ∈ ΔAθ
and

A	B	A	S

(q' , (q' , qB)) ∈ R; if (qB, τ, q' ) ∈ ΔB then q'
= qA, (qA, τ, qA) ∈
Δˆ Aθ
, and

A	B	A	S
(qA, (qA, q' )) ∈ R. If a ∈ S, then (qA, a, q' ) ∈ ΔAθ	and (q' , (q' , q' )) ∈ R. If
A	S	A	A  B
a ∈ H, then (qA, a, q' ) ∈ ΔAθ , q' = qB, and (q' , (q' , qB)) ∈ R.
A	S	B	A	A
Now let AθS ≈ A ⊗ B. Then A/H ⊗ B ≈ (A ⊗ B)/H by Lem. 2.2(iii), as S ∩ H = ∅. Furthermore (AθS)/H ≈ (A/H)θS, again since S ∩ H = ∅. Thus (A/H)θS ≈ A/H ⊗ B by Lem. 2.1(i). Since L (A/H)= L (B), all labels between A/H and B are shared, and thus T (A/H ⊗ B) ⊆ T (B). By Lem. 4.6, we have T (A/H)= T ((A/H)θS)= T (A/H ⊗ B) ⊆ T (B).	 
The following corollary is the crucial result needed for the efficient computation of component behaviours hereafter. Essentially it says that neutrality of a weakly deterministic iots B for some iots A can be propagated to the neutrality of B for some more complex iots C, if A is observationally equivalent to some view C/H on the larger behaviour C.
Corollary 4.8 Let A, B, and C be iotss such that L (B) = L (A) ⊆ L (C). Let B be composable with A and C where S = L(A) 0 L(B) are the shared labels. Let H = L (C) \ L (A) and C/H ≈ A. Let B be weakly deterministic. Then B is neutral for A if, and only if, B is neutral for C.
Proof First, since C/H ≈ A we have, by Lem. 4.6, T (C/H)= T (A). B is neutral for A iff (by Prop. 4.7, since L (B)= L (A)) T (A) ⊆ T (B) iff T (C/H) ⊆ T (B) iff (by Prop. 4.7, taking C for A) B is neutral for C.	 

Neutrality and Port Protocols
In this section, we focus on the behavioural neutrality checks which are performed component-wise in our reduction algorithm of Sect. 4.1. We show that these neut- rality checks may be optimised by considering instead of component behaviours the protocols of connected ports.
Components communicate exclusively via ports; therefore it should be sufficient to compare instead of the observable behaviour of two components only the protocols of their connected ports which are usually given by much smaller iotss. Of course, this can only be sound if the observable behaviour of a component, which includes also the sequencing of input and output actions for all of its declared ports, fits to the individual protocols specified for each port, i.e., if the component is correct; see Def. 3.4.
Port neutrality is defined similarly to component neutrality, cf. Def. 4.1, by turning a port declaration p : P into a component declaration p˜ : P˜.
Definition 4.9 For a port declaration p : P let p˜ : P˜ be a component declaration with ports(P˜) = {p : P } and obs(P˜) = prot(p : P ). A port declaration q : Q is behaviourally neutral for a port declaration p : P, if
beh(⟨p˜ : P˜, q˜ : Q˜; k : (p˜.p : P, q˜.q : Q)⟩) ≈ beh(⟨p˜ : P˜; k : (p˜.p : P )⟩) .

Unfolding the definition of port neutrality results in a characterisation in terms of iotss: p : P is neutral for q : Q iff prot(P ) ⊗ prot(Q) ≈ prot(P )θS with S = L(prot(P )) 0 L(prot(Q)). Hence, ports can only be behaviourally neutral if their labellings are inverse, i.e., if input and output labels mutually coincide.
Port neutrality has the important consequence that the observable behaviour of a correct component is not affected if a port of the component is connected to a neutral port of another component, provided that this port has a weakly deterministic behaviour. The following theorem is an application of the results discussed on the level of I/O-transition systems in Sect. 4.2. It is at the core of a more efficient check for neutrality in assemblies. Note that component C may have more than one port.
Theorem 4.10 Let c : C, d : D ∈ CmpDcl with C and D correct components,
p : P ∈ ports(C) and ports(D) = {q : Q}. If prot(Q) is weakly deterministic and
q : Q is behaviourally neutral for p : P, then d : D is behaviourally neutral at q for
c : C at p.
Proof We need to show that
beh(⟨p˜ : P˜, q˜ : Q˜; k : (p˜.p : P, q˜.q : Q)⟩) ≈ beh(⟨p˜ : P˜; k : (p˜.p : P )⟩)	implies
beh(⟨c : C, d : D; k : (c.p : P, d.q : Q)⟩) ≈ beh(⟨c : C; k : (c.p : P )⟩) .
By unfolding definitions this amounts to show that
p˜.prot(p : P )σ2 ⊗ q˜.prot(q : Q)σ2 ≈ p˜.prot(p : P )σ1	implies
obs(c : C)σ' ⊗ obs(d : D)σ' ≈ obs(c : C)σ'
2	2	1

with σ2 = σ({p˜.p,q˜.q},k), σ1 = σ(p˜.p,k), σ2'
it suffices to prove that
= σ({c.p,c.q},k) and σ1'
= σ(c.p,k). Obviously

prot(p : P )σ({p,q},k) ⊗ prot(q : Q)σ({p,q},k) ≈ prot(p : P )σ(p,k)	implies
obs(c : C)σ({p,q},k) ⊗ obs(d : D)σ({p,q},k) ≈ obs(c : C)σ(p,k) .
Since D is correct and shows only a single port we can replace the antecedent by
prot(p : P )σ({p,q},k) ⊗ obs(d : D)σ({p,q},k) ≈ prot(p : P )σ(p,k) .
For the succedent observe that also C is correct w.r.t. p : P , i.e. obs(C)/H ≈
prot(p : P ) with H as in Def. 3.3, i.e., we have to prove that
(obs(C)/H)σ({p,q},k) ⊗ obs(d : D)σ({p,q},k) ≈ (obs(C)/H)σ(p,k)	implies
obs(c : C)σ({p,q},k) ⊗ obs(d : D)σ({p,q},k) ≈ obs(c : C)σ(p,k) .
Now, H does not interfere with by σ({p,q},k) and σ(p,k) = θS ◦ σ({p,k},k); thus writing A for obs(C)σ({p,q},k)/H, B for obs(d : D)σ({p,q},k) and C for obs(C)σ({p,q},k), we simply have an instance of Cor. 4.8.	 
The theorem allows for a port-based computation of the neutral leaves of an assembly which links our analysis back to the results of Sect. 4.1.

Corollary 4.11 Let a be an assembly, d : D ∈ leaves(a), ports(D) = {q : Q} and {k : (c.p : P, d.q : Q)} ∈ conns(a). If prot(Q) is weakly deterministic, D and cmp(c.p : P ) are correct, and q : Q is behaviourally neutral for p : P then d : D ∈ neutralleaves(a).
Proof By Thm. 4.10 we derive neutrality of the leaf component D from the given port neutrality, and with the definition of neutral leaves the claim follows. 

Application to the Compressing Proxy Example
Let us now apply our reduction algorithm of Sect. 4.1 and the results of this section to the efficient computation of the observable behaviour of CompressingProxy. We start with the underlying assembly of CompressingProxy, call it a, which contains the three components adapt : Adaptor, gzip : GZip, and gifToJpg : GifToJpg. First, we choose the leaf gzip : GZip and consider its port z : Zip. Obviously, the port protocol of Zip is weakly deterministic, since there are no τ -transitions and the protocol is already (strongly) deterministic; cf. Fig. 3(d). Moreover, the component (types) GZip and Adaptor are correct w.r.t. their ports. Then we check that the port z : Zip is behaviourally neutral for the (connected) port t : TxtCompr of Adaptor by constructing the port product prot(TxtCompr) ⊗ prot(Zip) shown in Fig. 7.

Figure 7. Port product of TxtCompr and Zip
Obviously, the port product is observationally equivalent to prot(TxtCompr)θS (cf. Fig. 3(b)) where the shared labels S = {txt, endTxt, zip, endZip, bufFul} are in- ternalised. Hence, by Cor. 4.11, gzip : GZip is a neutral leaf of the assembly. Our algorithm now removes this leaf and hides the port t : TxtCompr, i.e., the component type Adaptor is replaced by the component type Adaptor’ whose observable behaviour is obtained, by definition of port hiding, from Adaptor by hiding all labels related to t : TxtCompr. The resulting behaviour of Adaptor’ has a lot of τ -transitions and can be minimised to an iots with 4 states and 5 transitions. Let a' be the new assembly obtained from a after the first reduction step.
In the second step, we choose the leaf gifToJpg : GifToJpg of a' and consider its port j : ToJpg. Unfortunately, the port protocol of ToJpg is not weakly deterministic, since there is a weak trace gif which leads to state 1 and also to state 2 (cf. Fig. 3(e)) but both states cannot be observationally equivalent since the protocol is already minimised. Thus we cannot apply Cor. 4.11 and we have to show directly on the level of component behaviours that gifToJpg : GifToJpg is behaviourally neutral (at port j) for adapt : Adaptor’ (at port g). The neutrality check is indeed successful and amounts to the construction of an iots with 12 states and 23 transitions before it is minimised. Our algorithm now removes also the leaf gifToJpg : GifToJpg from a' and hides the port g : GifCompr of Adaptor’. Thus, we obtain as the final result of the reduction an assembly a'' consisting of a single component adaptor : Adaptor” where Adaptor”

has only two ports u : UpStream and d : DownStream. The observable behaviour of Adaptor” has only two states and three transitions after minimisation and hence the same holds for the behaviour of a''. Finally, we apply Thm. 4.5 which shows that obs(CompressingProxy) is observationally equivalent to the observable behaviour of a composite component which encapsulates the very simple assembly a'' and which results in the observable behaviour shown in Fig. 5(b). The most expensive task in our reduction was the neutrality check between gifToJpg : GifToJpg and adapt : Adaptor’ which led to the construction of a product iots with 12 states and 23 transitions (before minimisation). On the other hand, if we would have directly computed the observable behaviour of CompressingProxy based on the behaviour of the original assembly a than the most expensive task would have been the construction of the behaviour of a which has 30 states and 65 transitions (also before minimisation).
Let us remark again that the behaviour of a'' is not at all observationally equival- ent to the behaviour of our original assembly a and that the results of our approach rely fundamentally on the additional abstraction steps that are applied when the observable behaviour of a composite component is defined.

Related Work
Our approach integrates aspects from different but closely related domains. As a concrete syntax we use the UML2 [27] for the specification of port-based compon- ents. Our component model, however, is a formally defined software component model [21] which can be used for architectural programming in the sense of, e.g., Java/A [4], ArchJava [2], ComponentJ [29], and also SOFA [7] or Fractal [6]. Our component model is backed by I/O-transition systems and observational equivalence which resembles ADL approaches such as Wright [3], Darwin [22], and more recently PADL [5]. The analysis carried out for computing composite component behaviours more efficiently relies on a reduction strategy similar to contextual CRA [10]. Neut- rality between transition systems, as a criterion for state space reduction, is closely related to the transparency property of interface processes [10] and also to the notion of compatibility used in PADL [5] to detect deadlock-related architectural mismatches. We detail on each of the mentioned aspects in the following.
The port-based component model was originally inspired by ROOM [30], which later evolved to UML for Real-Time Systems [31] which in turn in the meantime has been incorporated into UML2 [27]. UML2 introduces notions of components, ports and structured classifiers which are, not surprisingly, a perfect match with the syntactic requirements of our port-based approach to components. Hence we use UML2 as a concrete syntax for the specification of port-based components. Given that the UML2 shows a number of semantical variation points, and also ambiguities, see e.g. [11,14], we provided a metamodel for our component model which is, on the one hand, easily mappable to the corresponding notions of the UML2 and provides, on the other hand, a convenient starting point for our formalisation of static struc- ture and behaviour of port-based components. In this sense our semantics may also be used to remedy the ambiguities of UML2 port semantics as discussed in [11].

We have introduced a formal, algebraic layer for our component model which is distinguished from its semantic backend, I/O-transition systems. Based on a precise understanding of the structural properties of hierarchical systems with port-based components, we identified conceptually and formally which kinds of behaviour are involved and, in particular, discussed the difference between specified and derived behaviours. PADL [5] and its extension as described in [1], deals also with formal modelling and verification of software architectures using component-oriented tech- niques. This approach extends a process algebra by architectural concepts like “architectural type” [1, Def. 2.4] which is similar to our notion of an assembly. In [1] PADL comes with various kinds of extension mechanisms based on architec- tural type invocation. Architectural type invocations do not hide local interactions which makes a principal difference to our notion of composite component which encapsulates an assembly by hiding all its internal communications. In our view, this encapsulation is methodologically and technically quite important for building components in a hierarchical way.
Closer to our approach is Darwin [24,20] as a language for design specifications of distributed systems. In particular, in combination with the Tracta method [15] it becomes evident that we do not only share key abstractions such as components encapsulated by ports but also the semantic domain of labelled transition systems (LTS) together with a compositional reachability analysis (CRA) for composed sys- tems which utilises specifications of the static structure. Even though I/O-transition systems provide a more convenient way to be precise about whether an action is a message reception, a message sending or an internal action, we could have used LTSs for the purpose of this article as well. However, since we are currently also working on a refinement relation where the difference between input and output becomes important, we just sticked to our semantic domain of I/O-transition systems.
In Darwin the importance of a separate configuration language for the specific- ation of structural aspects is stressed [20]. Given such a “common structural view”, behaviour of primitive components described by LTSs is added in a “behavioural view” and used for an architectural analysis of the composed system behaviour [24]. An operational semantics is developed translating notions of Darwin such as “bind- ing” or “external interface” to an LTS operator such as relabelling or hiding [15]. Obviously, our work is related in several concerns. First, and as argued above, with the UML2 we are also in favour of a clearly separated language for the specification of structural aspects. In fact, the UML2 notation for structured classifier resembles the graphical notation of Darwin. However, we use an algebraic layer between the UML2 specifications of components and the I/O-transition systems describing their behaviour.
Second, touching an, as we think, new aspect which is instrumental in CRA, we consider ports not as a mere structural, syntactical aid in system construction, but require explicitly specified port behaviours instead. Ports become first-class citizens which is neither the case in the contextual CRA applied to Darwin [10] nor in the analysis developed for PADL [5]. In [10] automatically derived context constraints are used to construct the LTS behaviour of composed systems more efficiently.

Context constraints take the form of interface processes which capture the interplay between a set of composed processes playing the role of an environment for a single fixed process as part of the composition. If the composition of interface and fixed process results in a smaller transition system, it is substituted. The correctness of the approach relies on a transparency property which requires a strong semantic equivalence between a (possibly) composed process P and its composition P ǁ I with the interface process I. Criteria which guarantee the transparency are identified in an interface theorem. Our notion of neutrality between component behaviours uses observational equivalence and formulates criteria based on weakly deterministic port behaviours. Even though the possibility of using weaker equivalences is mentioned in [10, p. 354], it is not elaborated. Moreover, the criteria do not make use of port behaviours.
PADL [5] applies observational equivalence for a notion of compatibility between components which expresses the same idea as our notion of behavioural neutrality. In PADL compatibility is used to detect architectural mismatches and it is shown that pairwise compatibility is a sufficient criterion to derive deadlock-freedom of an acyclic assembly from the deadlock-freedom of its local components. This technique is, however, not appropriate for an explicit construction of assembly behaviours. Nevertheless, since we are interested in the encapsulated behaviour of an assembly given by the observable behaviour of a composite component, we can abstract from component communications within an assembly which allows us to utilise again behavioural neutrality (compatibility) for an efficient construction of the observ- able behaviour of a composite component. Moreover, as observed in our study, to decide on neutrality of component behaviours can still be quite expensive. There- fore, as discussed in the comparison with [10] above, a further important difference between our approach and [5] concerns the integration of explicit port behaviours which makes the check for neutrality more efficient, under the assumption of weakly deterministic port protocols.

Conclusion
We have studied composite components and their observable behaviour based on a metamodel which clearly distinguishes different kinds of behaviours that are relevant for the construction and analysis of hierarchical systems using port-based compon- ents. We have provided conditions for a more efficient computation of the observable behaviour of a composite component using syntactically reduced assemblies. At the core of our reduction strategy is a notion of neutrality between component beha- viours. The approach is particularly useful for rooted composite components with acyclic assemblies, since then it might be the case that it is only the root component which remains in the reduced assembly.
We identified criteria to derive neutrality between components from the neut- rality between their ports. Thus, on the one hand, we improve the efficiency of the neutrality check involved in our reduction strategy, and, on the other hand, we shed light on the general usefulness of ports as first-class citizens of a software

component model. Until it comes to verification, ports are without doubt useful from a methodological point of view, though playing a mere syntactical role. We have shown that ports are also semantically important for the behavioural analysis of component-based systems. Hence, we consider the port-based component model with explicit port protocols as a useful extension of related results discussed above. The focus of this study is the explicit semantic characterisation of hierarchical port-based components rather than a property-based analysis of port, component or assembly behaviours. But, of course, our computation of observable component behaviours provides the basis on which properties of components that are compat- ible with observational equivalence can be studied. For instance, if we know that the observable behaviour of a composite component is deadlock-free (in the sense of PADL [5]), then also the behaviour of the underlying assembly must be deadlock- free, since deadlock-freeness is preserved by “unhiding”. In particular, in the context of component systems that are built on various hierarchical layers our techniques allow us to climb up the hieararchy and to analyse systems on the appropriate ab- straction level. It would be interesting to study to which extent our approach could be combined with techniques such as deadlock-analysis for interaction systems [25], analysis of safety and liveness properties for communicating LTSs with Tracta [15],
or the compositional verification of Real-Time UML designs [16].
In future work, our study should be extended to take into account not only derived observable behaviours but also requirement specifications for the observ- able behaviour of components as done, e.g., by the frame protocols used in [7]. We believe that then the proposed techniques to compute the observable behaviour of a composite component can be efficiently applied to verify refinement correctness between specification and observable behaviour. Moreover, we plan to extend our results to asynchronous message passing within the assemblies of connected com- ponents and to support architectural programming by adjusting Java/A [4] and its analysis tools to the results of this paper.
Acknowledgement
We thank the anonymous reviewers of the first version of this paper for many valuable remarks and suggestions and we are grateful to Mila Majster-Cederbaum for intensive and stimulating discussions on components and component behaviours.

References
Alessandro Aldini and Marco Bernardo. On the Usability of Process Algebra: An Architectural View.
Theo. Comp. Sci., 335(2–3):281–329, 2005.
Jonathan Aldrich. Using Types to Enforce Architectural Structure. PhD thesis, University of Washington, 2003.
Robert Allen and David Garlan. A Formal Basis for Architectural Connection. ACM Trans. Softw. Eng. Meth., 6(3):213–249, 1997.
Hubert Baumeister, Florian Hacklinger, Rolf Hennicker, Alexander Knapp, and Martin Wirsing. A Component Model for Architectural Programming. In Proc. FACS’05, volume 160 of Elect. Notes Theo. Comp. Sci., pages 75–96. Elsevier, 2006.

Marco Bernardo, Paolo Ciancarini, and Lorenzo Donatiello. Architecting Families of Software Systems with Process Algebras. ACM Trans. Softw. Eng. Meth., 11(4):386–426, 2002.
Eric Bruneton, Thierry Coupaye, Matthieu Leclercq, Vivien Quéma, and Jean-Bernard Stefani. The FRACTAL Component Model and its Support in Java. Softw., Pract. Exper., 36(11–12):1257–1284, 2006.
Tomáš Bureš, Petr Hnětynka, and František Plášil. SOFA 2.0: Balancing Advanced Features in a Hierarchical Component Model. In Proc. SERA’06, pages 40–48. IEEE, 2006.
Frank Buschmann, Kevlin Henney, and Douglas C. Schmidt. Pattern Oriented Software Architecture Vol. 5: On Patterns and Pattern Languages. Wiley, 2007.
Cyril Carrez, Alessandro Fantechi, and Elie Najm. Behavioural Contracts for a Sound Composition of Components. In Proc. FORTE’03, volume 2767 of Lect. Notes Comp. Sci., pages 111–126. Springer, 2003.
Shing Chi Cheung and Jeff Kramer. Context Constraints for Compositional Reachability Analysis.
ACM Trans. Softw. Eng. Meth., 5(4):334–377, 1996.
Arnaud Cuccuru, Sébastien Gérard, and Ansgar Radermacher. Meaningful Composite Structures. In
Proc. MoDELS’08, volume 5301 of Lect. Notes Comp. Sci., pages 828–842. Springer, 2008.
Luca de Alfaro and Thomas A. Henzinger. Interface-based Design. In Manfred Broy, Johannes Grünbauer, David Harel, and C. A. R. Hoare, editors, Engineering Theories of Software-intensive Systems, volume 195 of NATO Science Series: Mathematics, Physics, and Chemistry, pages 83–104. Springer, 2005.
Jaana Eloranta. Minimizing the Number of Transitions with Respect to Observation Equivalence. BIT Num. Math., 31(4):576–590, 1991.
Harald Fecher, Jens Schönborn, Marcel Kyas, and Willem P. de Roever. 29 New Unclarities in the Semantics of UML 2.0 State Machines. In Proc. ICFEM’05, volume 3785 of Lect. Notes Comp. Sci., pages 52–65. Springer, 2005.
Dimitra Giannakopoulou, Jeff Kramer, and Shing Chi Cheung. Behaviour Analysis of Distributed Systems Using the Tracta Approach. Autom. Softw. Eng., 6(1):7–35, 1999.
Holger Giese, Matthias Tichy, Sven Burmester, and Stephan Flake. Towards the Compositional Verification of Real-Time UML designs. In Proc. FSE’03, pages 38–47. ACM, 2003.
Gregor Gössler, Susanne Graf, Mila Majster-Cederbaum, Moritz Martens, and Joseph Sifakis. Ensuring Properties of Interaction Systems by Construction. In Thomas Reps, Mooly Sagiv, and Jörg Bauer, editors, Program Analysis and Compilation, Theory and Practice — Essays Dedicated to Reinhard Wilhelm on the Occasion of His 60th Birthday, volume 4444 of Lect. Notes Comp. Sci., pages 201–224. Springer, 2007.
Gregor Gössler and Joseph Sifakis. Composition for Component-based Modeling. Sci. Comp. Prog., 55(1–3):161–183, 2005.
Alexander Knapp, Stephan Janisch, Rolf Hennicker, Allan Clark, Stephen Gilmore, Florian Hacklinger, Hubert Baumeister, and Martin Wirsing. Modelling the CoCoME with the Java/A Component Model. In Rausch et al. [28], pages 207–237.
Jeff Kramer and Jeff Magee. Exposing the Skeleton in the Coordination Closet. In Proc. COORDINATION’97, volume 1282 of Lect. Notes Comp. Sci., pages 18–31. Springer, 1997.
Kung-Kiu Lau and Zheng Wang. Software Component Models. IEEE Trans. Softw. Eng., 33(10):709– 724, 2007.
Jeff Magee, Naranker Dulay, Susan Eisenbach, and Jeff Kramer. Specifying Distributed Software Architectures. In Proc. ESEC’95, volume 989 of Lect. Notes Comp. Sci., pages 137–153. Springer, 1995.
Jeff Magee and Jeff Kramer. Concurrency — State Models and Java Programs. Wiley, 1999.
Jeff Magee, Jeff Kramer, and Dimitra Giannakopoulou. Analysing the Behaviour of Distributed Software Architectures: A Case Study. In Proc. FTDCS’97, pages 240–247. IEEE, 1997.
Moritz Martens and Mila Majster-Cederbaum. Compositional Analysis of Deadlock-Freedom of Tree- Like Component Architectures. In Proc. EMSOFT’08, pages 199–206. ACM, 2008.
Robin Milner. Communication and Concurrency. Prentice Hall, 1989.
Object Management Group. Unified Modeling Language: Superstructure, Vers. 2.1.2. Specification, OMG, 2007.


Andreas Rausch, Ralf Reussner, Raffaela Mirandola, and František Plášil, editors. The Common Component Modeling Example: Comparing Software Component Models, volume 5153 of Lect. Notes Comp. Sci. Springer, 2008.
João Costa Seco and Luis Caires. A Basic Model of Typed Components. In Proc. ECOOP’00, volume 1850 of Lect. Notes Comp. Sci., pages 108–128. Springer, 2000.
Bran Selic, Garth Gullekson, and Paul T. Ward. Real-Time Object-Oriented Modeling. Wiley, 1994.
Bran Selic and Jim Rumbaugh. Using UML for Modeling Complex Real-Time Systems. Technical report, ObjectTime Ltd., Rational Software Corp., 1998.

A	Minimal Weakly Deterministic I/O-Transition Sys- tems
An iots A = (L, Q, q0, Δ) is called minimal, if (i) for all q ∈ Q there is a λ ∈ T (A) with (q0, λ, q) ∈ Δˆ ∗ , i.e., all states of A are reachable from q0; and (ii) for all q1, q2 ∈ Q, if q1 ≈ q2, then q1 = q2. Note that if A ≈ B and A is minimal, then the cardinality of the states of A is bounded by the cardinality of the states of B.
Proposition A.1 If A is a weakly deterministic iots, then there is a minimal iots B without τ-transitions such that A ≈ B.
Proof Let A = (L, QA, q0,A, ΔA) be a weakly deterministic iots. Define (by abuse of notation) ≈ ⊆ 
T (A) × T (A) by
λ1 ≈ λ2 ⇐⇒ (∀q1, q2 ∈ QA . (q0,A, λ1, q1) ∈ Δˆ ∗ ∧ (q0,A, λ2, q2) ∈ Δˆ ∗ ⊃ q1 ≈ q2) .
A	A
Then ≈ is an equivalence relation on T (A): ≈ is reflexive as A is weakly deterministic, it is symmetric by definition, and it is transitive as only weak traces are considered. Furthermore, if λ1 ≈ λ2 and l ∈ L (A),
then λ1l ≈ λ2l: If (q0,A, λ1, q1) ∈ Δˆ ∗ and (q1, l, q' ) ∈ Δˆ A, and (q0,A, λ2, q2) ∈ Δˆ ∗ and (q2, l, q' ) ∈ Δˆ A,
A	1	A	2
then q1 ≈ q2; thus there is a q'' ∈ QA with (q2, l, q'') ∈ Δˆ A and q' ≈ q''; but then (q0,A, λ2l, q'') ∈ Δˆ ∗ and
2	2	1	2	2	A
(q0,A, λ2l, q' ) ∈ Δˆ ∗ and thus q'' ≈ q' , as A is weakly deterministic. We write [λ]≈ for the equivalence class
2	A	2	2
of λ ∈ T (A) in the quotient T (A)/≈ of T (A) w.r.t. ≈.
Define an iots B = (L, QB, q0,B, ΔB) by QB = {[λ]≈ | λ ∈ T (A)}, q0,B = [ε]≈, and ([λ]≈, l, [λ']≈) ∈ ΔB if λl ∈ [λ']≈. Then B has no τ -transitions; and A ≈ B by using R = {(q, [λ]≈) ⊆ QA × T (A)/≈ | 𝖤λ' ∈ [λ]≈ . (q0,A, λ', q) ∈ Δˆ ∗ } as weak bisimulation between A and B with (q0,A, [ε]≈) ∈ R. B is also minimal:
All [λ]≈ ∈ QB are reachable by definition. If [λ1]≈, [λ2]≈ ∈ QB with [λ1]≈ ≈ [λ2]≈ in B, let q1, q2 ∈ QA
with (q0 , λ1, q1), (q	, λ2, q2) ∈ Δˆ ∗ ; then q1 ≈ q2 in A, as R = {(q' , q' ) | 𝖤λ' ∈	L . (q	, λ1λ', q' ) ∈
,A	0,A	A	1 2	0,A	1
Δˆ ∗ ∧ (q0,A, λ2λ', q' ) ∈ Δˆ ∗ } is a weak bisimulation on A with (q1, q2) ∈ R. Thus λ1 ≈ λ2 and hence
A	2	A
[λ1]≈ = [λ2]≈.	 
