

Electronic Notes in Theoretical Computer Science 258 (2009) 17–34
www.elsevier.com/locate/entcs

Deontic Logic, Contrary to Duty Reasoning and Fault Tolerance 3
Pablo F. Castro1 T.S.E. Maibaum2
Department of Computing and Software McMaster University Hamilton, Canada

Abstract
Deontic Logic was introduced in the first half of the last century to formalize aspects of legal reasoning. Since then a lot of effort has gone into improving the formalism(s) and widening their applicability, including in Computer Science and Software Engineering. One strand of work has focused on the use of an action based approach to deontic operators, rather than the traditional property focused operators. We propose a new version of this kind of deontic logic that has very nice meta-logical properties, avoids many of the traditional problems of deontic logics and has an appealing treatment of contrary to duty reasoning. This kind of reasoning provides a kind of conditional reasoning about having violated normative constraints and describing the resulting consequences. We show how to apply this formalism to characterize fault tolerance mechanisms and to then reason about the properties of the mechanisms.
Keywords: Fault-Tolerance, Deontic Logic, Software Specification, Software Verification

Introduction
Deontic logic is a branch of modal logic which focuses on the study of the reasoning arising in ethical and moral contexts, which usually involve norms and prescriptions (see [3,12]). These logics, usually, consider two new modalities: permission and obligation. Of course, related to them are the concepts of prohibition and violation. These concepts arise naturally in fault-tolerance, where some actions are “ideal” or “obligatory”, and the execution of any other action yields an error state. We have proposed a deontic logic in [11], and in [9] we have studied the application of this logic to fault-tolerance.
In fault-tolerant systems, it is usual to have situations where, after a violation, we must perform some actions to recover from this violation. This is an instance of

1 Email:castropf@mcmaster.ca
2 Email: tom@maibaum.org
3 This work was supported by the Natural Sciences and Engineering Research Council of Canada and the Department of Computing and Software and the Faculty of Engineering, McMaster University.

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.12.011

what is called by deontic logicians contrary-to-duty (or CTD for short) reasoning. CTD reasoning has been an important object of study in deontic logic; this kind of reasoning arises naturally in legal scenarios. However, in several deontic logics CTD scenarios are inconsistent when formalized; this is sometimes thought of as being paradoxical, since this is contrary to our intuition (in the sense that, intuitively, these statements are not inconsistent).
In this paper we extend the logics introduced in [11] with the goal in mind of obtaining a more expressive framework for allowing us to avoid the classical problems that arise in contrary-to-duty scenarios. Furthermore, we present some examples to illustrate that CTD statements are common in specification of fault- tolerant systems, and we show how we can deal with them using the proposed logic.
The paper is organized as follows. In section 2 we give a brief introduction to deontic logic and contrary-to-duty statements. In section 3 we describe our version of deontic logic and we propose a more expressive extension. In sections 4 and 5 we show two examples: a simple train system and a formalization of the Byzantine Generals problem [18]. These case studies allow us to demonstrate that CTD reasoning arises naturally in fault-tolerance. We prove some properties of the examples to illustrate the benefits of using deontic logic to specify and verify faul-tolerant systems.
Deontic Logics
Ernst Mally was the first to try to capture the reasoning underlying norms and prescriptions using a formal system, in particular Mally introduced obligation as a predicate (together with other related operators) and provided an axiomatic system for his logic. However, in Mally’s logic the concept of obligation is superfluous, in the sense that, if we take O(ϕ) as saying it ought to be the case that ϕ is true, then we obtain ϕ → O(ϕ), which trivializes the deontic operators. Since then, several deontic logics have been proposed in the literature. Perhaps the most studied is the so-called Standard Deontic Logic (or SDL) [12]. SDL is a particular case of normal modal logics; this logic has the modality O(ϕ) (ϕ is obligatory); and the following axioms are proposed to capture the notion of obligation [20]:

SDL0.	all the tautologies of the language.
SDL1.	O(ϕ → ψ) → (O(ϕ) → O(ψ)).
SDL2.	O(ϕ) → ¬O(¬ϕ).

For the rules we have:
If ▶ ϕ → ψ and ▶ ϕ, then ▶ ψ,
If ▶ ϕ, then ▶ O(ϕ).
Equivalent axiomatizations of SDL can be found in [12] (this system is called OK+
in [3]). The second deduction rule means that we have a normal modal system.

The semantics of SDL is given with Kripke structures [5], and the interpretation of the obligation operator is the same as the ussual modal necessity (although this axiomatization imposes a different structure on the Kripke models; note that the axioms imply that the Kripke structures are serial, i.e., every state has a successor).
The intuition of the semantics is as follows. If a state w is related with another state v, this mean that the obligations occurring in w are true in v (in some way we can think of v as an “ideal” world for w). Several consequences of this axiomatic system have been criticized for being contrary to the intuitive properties of obliga- tion. For example, a consequence of these axioms is the property O(T) (which can be read as saying that there are always obligations; at least we have that all the tau- tologies are obliged). Some people have argued that there could be scenarios where nothing is obliged, and these kinds of scenarios are not possible in SDL. Another problematic issue is the definition of permission which is introduced in the logic as a dual of obligation, that is: P(ϕ) — чO(чϕ). Note that this definition together with axiom SDL2, imply that we have the following theorem: O(ϕ) → P(ϕ), i.e., obligation implies permission. If we see permission as modal possibility (which is the case in SDL), then we have what is sometimes called Kant’s law: obligation implies possibility (i.e., O(ϕ) → ϕ). It is not hard to find examples where this property is not desirable. It is not our intention to defend or argue against this logical system; readers can take their own position. Further discussion about these topics can be found in [12].
As explained in the introduction, we are interested in contrary-to-duty state- ments. Let us introduce a standard example of CTD statements, the so-called Gentle Killer paradox [14]. It can be stated as follows:
It is forbidden to kill.
If you kill, you have to kill gently.
You kill.
In SDL the formalization of this paradox gives us an inconsistent set of sentences [24]. The main problem is that, in SDL, incompatible obligations are inconsistent, i.e., ▶ O(ϕ) Λ O(чϕ) → ⊥. Contrary-to-duty scenarios are also usual in fault- tolerance. We illustrate this fact with two examples in sections 4 and 5.
The Standard Deontic Logic is an ought-to-be deontic logic, i.e., the deontic predicates are applied to predicates (e.g., it is obligatory that it is raining). Many authors (e.g., [21,17]) have pointed out that several problems of deontic logics (para- doxical statements and non-intuitive properties) can be solved by applying deontic operators to actions instead of predicates. In [21], Meyer proposes to reduce de- ontic predicates to modal operators (in a dynamic logic setting [15]). The main idea behind this work is to use a constant predicate to indicate when a violation has occurred. In dynamic deontic logic, we have propositional formulae together with formulae of the type: [α]ϕ, where α is an action and ϕ is a formula. Actions are built from a set of atomic actions and operators. Dynamic logics have the fol- lowing operators: ; (sequential composition), H (choice), ∗ (iteration). Intuitively, the formula [α]ϕ means after executing the action α, the formula ϕ becomes true.

In other words, using these formulae we can express specifications of actions in a pre/post-condition style. Meyer reduces the notion of permission to modalities, as follows: P(α) ≡ ⟨α⟩чv, i.e., an action is allowed if and only if there is some way of executing it such that we get a state without violations (where v represents the idea that a violation has occured). A similar approach is presented by the FOREST project [17,19], where a modal logic with actions (called MAL) is introduced, but MAL considered several other action operators, for example: H (parallel execution) and — (action complement). Many other variations of deontic logic with actions have been presented in the literature. One difference between the logic presented in section 3 and Meyer’s logic (and related approaches) is that in our logic there is no relationship between deontic predicates and standard modalities, i.e., we do not reduce deontic predicates to the concepts of possibility or necessity. We reject the reduction of deontic predicates to modalities since we think that prescription (what the system should do) and description (what the system does) must not be mixed up. For example, following Meyer’s definition of permission, allowed actions are also recovery actions (they recover the system from an error state). This is undesirable in fault-tolerance: permitted actions may carry forward violations; this is also noted by Sergot in [23].


A Deontic Action Logic with Stratified Norms
We have presented a deontic action logic in [11,8,7,10]; in this section we review briefly the basic definitions of this logic and we introduce an extension for this logic to deal with contrary-to-duty reasoning.
We use vocabulary (or language) to refer to a tuple L = ⟨Δ0, Φ0, V0, I0⟩, where Δ0 is a finite set of primitive actions: a1, ..., an, which represent the possible actions of a part of the system and, perhaps, of its environment. Φ0 is an enumerable set of propositional symbols denoted by p1, p2,.  V0 is a finite subset of V, where V =
{v1, v2, v3,.. .} is an infinite, enumerable set of “violation” propositions. The indices in I0 correspond to a stratification of the concept of norm, where the stratification
corresponds to degrees of fault in the system being modeled. All these sets are mutually disjoint. The atomic actions in a vocabulary can be combined as follows to form more complex action terms (denoted by Δ): Δ0 ⊆ Δ and ∅, U ∈ Δ. If
α, β ∈ Δ, then α H β ∈ Δ, α H β ∈ Δ and α ∈ Δ. No other expression belongs to Δ. On the other hand, the formulae of this logic (denoted by Φ) are defined as follows. If ϕ ∈ Φ0 ∪ V0, then ϕ ∈ Φ. If ϕ and ψ are formulae, then ψ → ψ, чψ ∈ Φ. If ϕ is a
formula and α an action, then [α]ϕ is a formula. If α is an action and i ∈ I0, then Pi (α) and Pi(α) are formulae. If ϕ and ψ are formulae, then ENϕ, A(ϕ C ψ) and E(ϕ C ψ) ∈ Φ. If α and β are actions and S ⊆ Δ0, then DoneS(α) and α =act β are formulae. B is a formula.
The intuitive reading of the modal and deontic formulae is as follows:
[α]ϕ, after executing α in any possible way, ϕ will hold.
[α1 H α2]ϕ, every way of executing α1 or α2 leads to ϕ.

[α]ϕ, after executing an action different from α, ϕ holds.
[α1 H α2]ϕ, every way of executing both α1 and α2 leads to ϕ.
Pi(α), all the different ways of executing α are allowed, for the stratiﬁed level i.
Pi (α), there is at least one way of executing α which is allowed, for the stratiﬁed level i.
[U]ϕ, any execution of the component yields ϕ.
ENϕ, in some path, in the next instant ϕ is true.
A(ϕ C ψ), in every path the formulae ϕ is true until ψ becomes true.
E(ϕ C ψ), in every path the formulae ϕ is true until ψ becomes true.
Done(α), α was the last action executed.
B is true at the beginning of time and so denotes the initial state of execution of any system. The temporal operators have the standard meaning in a branching temporal logic. Note that, if we consider some complete axiomatization of boolean algebras ΦBA, then we obtain Δ/ΦBA the boolean (atomic) algebra of action terms. It is important to note that the atoms in this boolean algebra are each interpreted as singletons or the empty set.
Definition 3.1 [models] Given a language L = ⟨Φ0, Δ0, V0, I0⟩, a L-Structure is a tuple: M = ⟨У, Y, S, f, {Уi | i ∈ I0}⟩ where:
У, is a set of worlds.
S , is a non-empty set of (names of) events.
Y, is an S -labelled relation between worlds. We require that, if (w, w', e) ∈ Y 
and (w, w'', e) ∈ Y, then w' = w'', i.e., Y is functional.
f, is a function:
For every p ∈ Φ0 : f(p) ⊆У 
For every α ∈ Δ0 : f(α) ⊆ S , and f(α) is finite.
In addition, the interpretation f has to satisfy the following properties:
For every αi ∈ Δ0: |f(αi) —  {f(αj) | αj ∈ (Δ0 — {αi})}| ≤ 1.
For every e ∈ f(a1 H ... H an): if e ∈ f(αi) ∩ f(αj), where αi /= αj ∈ Δ0, then: ∩{f(αk) | αk ∈ Δ0 Λ e ∈ f(αk)} = {e}.
S =  αi∈Δ0 f(αi).
each Уi ⊆У × S is a relation which indicates which event is permitted in which world with respect to permissions with index i.
Roughly speaking, the structure gives us a labelled transition system, whose labels are events, which are produced by some local action or they could also cor- respond to external events. Note that we have a set of events, but actions are only interpreted over finite subsets, whose intersections satisfy the Hausdorff condition (implied by conditions I.1 and I.2), i.e., we require that every one-point set can be generated from the actions of the component; this ensures that the labels in the transitions are uniquely determined by some parallel execution of actions in the component and perhaps some environmental actions.

We use maximal traces to give the semantics of the temporal operators. Below,
we use the following notation. Given an infinite trace (or path) π = s0 →e0 s1 →e1

s2 →e2
..., we denote by πi = s  e
si+1
→ ... the subpath of π starting at position

i. The notation πi = si is used to denote the i-th element in the path, and we write

π[i, j] (where i ≤ j) for the subpath s e
ej
... →
e'
sj+1
e'
. Meanwhile π(i) denotes the

event ei. Finally, given a finite path π' = s' →0 .... →n sn+1, we say π' ≤ π if π' is an
initial subpath of π, that is: si = s' and ei = e' for 0 ≤ i ≤ n, and we denote by <
i	i
the strict version of ≤.
The formal definition of the relationship π, i, M ▶ ϕ (ϕ is true at instant i in the structure M ) can be found in [6]. In [6] we present a sound and complete axiomatic system for this logic.
Having several versions of permissions is useful in practice, in particular when we have contrary-to-duty statements. Consider, for example, the Gentle Killer paradox (introduced in section 2):
It is forbidden to kill.
If you kill, you ought to kill gently.
You kill.
As explained before, in SDL the formalization of this paradox gives us an inconsis- tent set of sentences [24]. We can formalize this scenario as follows:
F1(k)
kg ± k
nk H k =act ∅
O2(nk H kg)
ANDone(k)
We consider the actions k (kill), kg (kill gently) and nk (not kill). The first axiom says that it is forbidden to kill. The second formula says that the action of killing gently (kg) is a way of killing. The third axiom expresses that killing and not killing are disjoint actions. The fourth formula says that, if we will kill, then we have to kill gently. In the last formula, we use the Done() operator to state that we will kill (which is expressed saying that the next action is to kill). In this case, we consider in the vocabulary two indexes: 1 and 2 pointing to the fact that there are two different levels of norms in the specification. In contrast to standard deontic logic, these sentences are not contradictory in our setting. For example, the structure illustrated in figure 1 is a model of this set of sentences. The structure in this figure has three states w, w1, w2, and we have f(k) = {e1, e2}, f(kg) = {e1} and f(nk) = {e3}. The labels on the transitions indicate which actions are executed and which are not in each transition. The upper dashed arrow denotes a transition that is forbidden with respect to index 1 but not for index 2. The lower dashed arrow indicates an arrow which is forbidden for both indexes. In [22], Meyer sketched an extension of dynamic deontic logic where he considers several versions of permission and obligation; he uses this extension to model some paradoxes; however,

 w1¸


w ¸ ¸

¸ e¸2
¸z
w2

Fig. 1. Model for the Gentle Killer

in this version deontic predicates are reduced to modalities, and therefore, several violation predicates are introduced in the logic to model permission. As we explain above, defining permission by means of modalities is not always a good choice when modelling fault-tolerant systems: the notions of prescription and description are mixed up and, as we remarked above, this is not desirable in fault-tolerance, where the notion of allowed or permitted action must be different to that of recovery action.

First Example: A Simple Train System
We consider a simple example of a train system. Train systems are those systems that control the movement of trains through a network of rail segments. Fault- tolerance is a key aspect of these systems: a fault in the system may cause a train collision and the loss of human life. These kinds of systems are the object of active research in the fault-tolerance community, see [2,16,1].
Our system is made up of a collection of trains: t1,..., tn and a set of rail segments r1,..., rm (we assume n < m). Rail segments are connected to other rail segments; in each of these connections, the rails have one signal controlling access to them. The goal of the signal is to prevent trains from entering into a segment when another train is already in it. The signals can be green (when the segment is free) or red (when another train is in the segment). We have the following predicates. For each 0 ≤ i ≤ n and 0 ≤ j ≤ m, we have a predicate ti.rj which is true when the train ti is in segment rj; we also have a predicate ti.s (true when the train is
stopped). For each 0 ≤ j ≤ m, we have a proposition rj.green which is true when the signal of the rail rj is green. We have a violation predicate vj for every 0 ≤ j ≤ m which is true when we have two trains in the segment rj. (This is implemented by
a sensor in the segment which detects the two trains.) Finally, we have propositions
riRrj which indicate that ri and rj are connected.
We have the following actions: ti.move(j) (the train ti moves to the segment rj), ti.stop (this action stops the train), ri.ggreen (the signal of rail ri is set to green) and ri.gred (the signal of segment ri is set to red).
Recall that in section 3 we introduced a logic with vocabularies that can have several versions of deontic predicates. In this example, we consider three versions of deontic predicates for each train, and one version for each segment. We denote by ti.Pk(), ti.Pk () and ti.Ok() the permissions and obligations corresponding to train ti. We use the same notation for the segments. Furthermore, we use some syntactic sugar and instead of writing ti.Ok(ti.move(j)) we write ti.Ok(move(j)),

i.e., we do not repeat twice the trains and the segments when the second occurrence can be deduced from the context.
The axioms are as follows:



T1.	 
1≤j≤m

ti.rj




(for every 1 ≤ i ≤ n.) (  1≤j≤m ti.rj denotes the exclusive “or” of the predicates
ti.rj.) This axiom states that each train is in one and only one segment.


T2.	чDone(U) →	 

ч(ti.rk Λ tj.rk)

(1≤i≤n) (1≤j≤n)∧(i/=j)


This axiom says that, at the beginning of time, there are not two trains in the same segment.



T3.	 
1≤i≤m

(riRrj Λ tk.ri) → ⟨tk.moveto(j)⟩T



(for every 1 ≤ j ≤ m and 1 ≤ k ≤ n.) Axioms T3 say that train tk can move to segment rj if and only if the train k is in a segment that is connected to rj.

T4.	чriRri



(for every i.) Segments are not connected with themselves.



T5.	(	 
1≤i,j≤n∧i/=j

ti.rk Λ tj.rk) — vk




(where 1 ≤ k ≤ m.) There is a violation in segment rk if and only if there are two trains in segment rk.

T6.	ti.rj → rj.O1(gred)

(for every 1 ≤ j ≤ m and 1 ≤ i ≤ n.) When there is a train in a segment, the signal for this segment must be red.



T7.	( 
1≤i≤n

чti.rj) → rj.O1(ggreen)



(for every 1 ≤ j ≤ m.) If there is no train in the segment, then the signal for the segment must be green.

T8.	чti.rk л чrk.green → ti.F1(move(k))



(for every 1 ≤ i ≤ i, 1 ≤ k ≤ m and 1 ≤ j ≤ 2.) If the signal of a segment is red, then any train is forbidden to move into the segment.

T9.	ti.move(k) H tj.move(k) =act ∅



(for every 1 ≤ i, j ≤ n and i /= j.) We suppose that two trains cannot enter to the same segment simultaneously.

T10.	tj.F1(move(k)) → tj.O2(move(k) H stop)


(for every 1 ≤ j ≤ n, 1 ≤ k ≤ m and 1 ≤ i ≤ 3.) This axiom formalizes a contrary- to-duty statement: if you are forbidden to move to segment rk, then you are obliged to not move the train to segment rk, or to stop the train. This statement also can be read as saying: if you are forbidden to move to segment rk, and you do it, you have to stop the train. This is similar to the Gentle Killer paradox.
Note that we are only taking into account the trains that for some reason ignore a red signal and enter into the segment. We must also specify what happens when another train is already in the segment, to avoid train collisions.

T11.	ti.rj л rj.v → ti.O2(stop)

Another bad scenario is when a train is “locked” in a segment, i.e., when a train is in a segment where all the connected segments have their signal set to red. In this case the train is obliged to stop.



T12.	ti.rk л ( 
1≤j≤m

(⟨ti.move(j)⟩T → F1(ti.move(j)))) → ti.O3(stop)



The following axiom says that trains cannot move to a segment and at the same time this segment’s signal changes to red; we assume some kind of mechanism which prevents a signal from changing at the same moment that a train is entering the segment.

T13.	ti.move(j) H rj.gred =act ∅



(for every 1 ≤ i ≤ n and 1 ≤ j ≤ m.) We define the behaviour of each action with the following axioms.

T14.	([ti.take(j)]ti.rj) л (чti.rj → [i.take(j)]чti.stop)
T15.	([rj.ggreen]rj.g) л (чrj.g → [rj.ggreen]чrj.g)

T16.	([rj.gred]чrj.g) л (чrj.g → [rj.gred]чrj.g)


We can prove some properties of this specification. For example, we can prove that, if obligations of type 2 are fulfilled by trains, then there is no danger of having two trains in the same segment. Let Φ be the following set of formulae:
Φ1 = {AG(ti.O2(stop) → ANDone(ti.stop)) | 1 ≤ i ≤ n}.
These (finite) sets of formulae express that trains fulfil the obligations of type 2. We can consider a similar set of formulae for the segments:
Φ2 = {AG(ri.O1(gred) → ANDone(ri.gred)) | 1 ≤ j ≤ m}.
Using these sets of formulae, we can prove the following property:
Φ1, Φ2 ▶Train ч(ti.rk л tj.rk)
Informally, when trains fulfil their obligations of stopping at a red signal and seg- ments fulfil the obligation of setting their signal to red when there are trains in the segment, then we cannot have two trains in the same segment.
The proof uses the axiom of induction. Using axiom T2 and propositional logic we obtain ▶Train чDone(U) → ч(ti.rk л tj.rk). Now, we prove:
Φ1, Φ2 ▶Train ч(ti.rk л tj.rk) → [U]ч(ti.rk л tj.rk).

The proof is a follows:

чti.rk Λ tj.rk → rk.O2(gred)	T6
rk.O1(gred) → [U]Done(rk.gred)	PDL, TempAx1, Assumption




During the proof we use the acronym PDL to point out that basic property of the logic is used (see [6] for a listing of the basic properties). Therefore, using the induction rule, we get ▶train ч(ti.rk л tj.rk). Another property is that, when the obligations of type 3 are fulfilled, then when we have two trains in a segment, both will stop. The property can be stated as follows:
ti.O3(stop) → ANDone(ti.stop) ▶Train ti.rk л tj.rk → ANti.stop л tj.stop.
The proof is straightforward from the axioms.
We can think of this property as a recovery property, since from a state where there is a (dangerous) violation we go into a state where we still have a violation but it is safe, since it is free of train collisions. As stated in [4], fault-tolerance is not only about reaching a state free of error after a violation. But also, in some cases, it is acceptable to reach a safe state, where no further violations might arise. Of course, this example can be made more realistic, and we can state that after two trains are stopped in the same segment, then one of them can be removed, or an alternative exit can be made available. We keep the example as simple as




s0	,

, , ,

 t1 .mo_ve(¸2) ¸

¸ ¸ ¸


t1 ._sto,p
s1

t1.r1, t2.r2, r1Rr2	t1.r2, t2.r2, r2.v, r1Rr2, r2.green

Fig. 2. Example of of violation

possible to show how deontic predicates can be used to express requirements over specifications, which, when not fulfilled, yield a violation or bad behaviour.
On the other hand, if obligations of type 2 are not fulfilled, we can reach danger- ous states. In figure 2, we have a model with two states s0 and s1; below each state, we have the predicates that are true at this state. We have two segments which
are connected, and we have two trains, t1 is in segment r1 and t2 is in segment r2. Since segment r2 is occupied, t1 is forbidden to move to that segment, but if it moves, then it must stop. The train moves to that segment and it does not stop. We reach a state where the two trains are in the same segment, and t1 executes any action but t1.stop, which will produce a collision in the real world. This model also shows that the contrary to duty predicate expressed by axiom T10 does not introduce any inconsistency in the specification.

Second Example: Byzantine Generals
The Byzantine generals problem was stated originally in [18]; the problem is the following. We have a general with n— 1 lieutenants. The general and his lieutenants can communicate with each other using messengers. The general may decide to attack an enemy city or to retreat; then, he sends the order to his lieutenants. Some of the lieutenants might be traitors. Traitors might deliver false messages or perhaps they avoid sending a message that they received. The loyal lieutenants must agree on attacking or retreating. This problem is a classic problem of fault- tolerance and distributed computing. Different solutions have been proposed, for example in [18,13,25]. These solutions are simpler when an authenticated way of communication is used, i.e, traitors cannot lie. A solution proposed in the original paper is using signed messages in such a way that signatures cannot be forged (using some encryption protocol). The analogy with fault-tolerance is straightforward: the general is a sender process, the lieutenants are processes that have to agree with some decision taken by the sender. The traitors are faulty processes.
The specification that we provide below uses the ideas introduced in [13,25], where authenticated messages are used. The specification does not assume any form of authentication to prevent forged messages. Instead, deontic predicates are used to express that traitors are forbidden to lie. Of course, they might forge messages anyway. We consider this as a malicious behaviour which is a worse betrayal than to not obey orders. The important point here is that deontic operators allow us to abstract from the mechanisms that are used to prevent traitors from lying.
We have the following actions: li.sendA(j) (lieutenant li sends the message of attack to lieutenant lj), li.fwd(k, A, j) (lieutenant li forwards to lj the message of attack that he received from lk), li.betray (lieutenant li becomes a traitor). We

consider a clock that allows lieutenants to synchronize; the action tt increments the clock by one unit of time. The specification uses m + 1 rounds of messages, which are coordinated by means of the clock. We have the following predicates: li.Aj (this predicate indicates that li has received a message from lj saying that he must attack). We have a violation predicate li.v for each lieutenant (this predicate is true when li is a traitor, i.e., a li is in a violation state) and li.d (this predicate is true when li has decided to attack), ri (this predicate is true when we are in round i od the decision protocol).
We assume that l0 is the general, the messages are delivered correctly and all the lieutenants can communicate directly with each other, in such a way that they can recognize who is sending a message. We have n lieutenants and the specification that is shown below uses a constant m < n that indicates that the specification tolerates at most m traitors.
(For the deontic predicates we use the same notation conventions as in the train example.) The axioms are the following. Note that the following are axiom schemas, each formula denotes a finite collection of axioms.


чDone(U) → (	 

чli.Aj) л r1 л ( 

чli.d)

(1≤i≤n) (1≤j≤n)Λ(i/=j)	1≤i≤n



At the beginning, the lieutenants have not received any message, we are in the first round and the lieutenants (with the exception of the general) have not taken any decision (by default the decision is to retreat).

чDone(U) л чl0.v → (l0.d → AGl0.d) л (чl0.d → AGчl0.d)


If the general is loyal, then he keeps holding the same decision that he has taken at the beginning.



 
1≤i≤n

li.O1(betray)




Lieutenants should not betray.
чDone(U) л l0.d → l0.O2( .
1≤i≤n



sendA(i))

At the beginning, if the general decided to attack, then he ought to send a message with his decision to the other lieutenants.

(rj → [tt]rj+1) л чrm → ⟨tt⟩T



These axioms specify the behaviour of the clock.

ANtt



We always increment the clock.

rk л li.Aj1 л ... л li.Ajk → li.d



(where 1 ≤ k ≤ m + 1, 1 ≤ i ≤ n and 1 ≤ j1,..., jk ≤ 1 are k different numbers.) These axioms indicate that, if in round k the lieutenant li has received k messages with the order to attack, then he decides to attack.

rk л li.Aj1 л ... л li.Ajk →
li.O2((	.	sendA(j) H fwd(j1, A, j) H ... H fwd(jk, A, j)))
1≤j≤nΛj/=j1...Λj/=jk



These axioms indicate that, if in round rk the lieutenant li has received k messages with the order to attack from k different persons, then he ought to notify all the rest of the lieutenants about the decision to attack; he also forwards all the messages received.

li.v л чli.Aj → F3( .
1≤k≤n


fwd(j, A, k))



If a lieutenant is a traitor, then he is forbidden to lie. This involves contrary-to-duty reasoning. Lieutenants might betray at any moment (which is forbidden), but, if they betray, then they must not lie.

rk л чli.v л чli.Aj1 л ... л чli.Ajt →
[ . sendA(k)]⊥л [	.	fwd(k, A, k')]⊥
1≤k≤n	1≤k,k'≤n



(where 1 ≤ k ≤ m + 1, 1 ≤ i ≤ n and t > n — k.) These axioms say that, when in round rk a loyal lieutenant has not received at least k messages saying that he must attack, then he does not send nor forward any message.

rm+1 → (li.d → AGli.d) л (чli.d → AGчli.d)



(for any 1 ≤ i ≤ n.) These axioms expresses that the decision taken in round m + 1 is final.


[li.sendA(j)]lj.Ai
[li.fwd(k, A, j)]lk.Aj
чli.Aj → [lj.sendA(i) H .
1≤t≤n




lt.fwd(i, A, j)]чli.Aj

чli.v л li.d → [U]li.d
li.Aj → [U]li.Aj




(for every 1 ≤ k, i, j ≤ n.) These axioms specify the behaviour of the actions li.sendA(j) and lt.fwd(i, A, j). Axiom 15 says that, if a loyal lieutenant has decided to attack he sticks with his decision; axiom 16 says that lieutenants do not forget the messages received. Finally, we describe the behaviour of the action betray.

[li.betray]li.v

чli.v → [li.betray]чli.v






The axioms of the specification depend on a number m which, intuitively, is the number of traitors for which the specification ensures that the loyal lieutenants will agree on a decision. We sketch the proof of that fact that, if we have less than m traitors, then the loyal lieutenants reach an agreement. Consider, first, the following

set of formulae:

Φ1 = {li.F3(fwd(k, A, j)) → ANDone(li.fwd(k, A, j)) | for any 1 ≤ i, j, k ≤ n}
This set of formulae say that traitors do not lie. The following formulae say that there are at most m traitors:
Φ2 = AG(чlj1 .v л ... л чljn−m .v)
(for some different 0 ≤ j1,..., jn−m ≤ n.) Another useful supposition is that loyal lieutenants fulfil their obligations, which is expressed by the following formulae:
Φ3 = {li.O2(α) → ANDone(α) | for every 1 ≤ i ≤ n}.
Then, if we suppose that there are at least n — m lieutenants who are not traitors, traitors do not lie and that loyal lieutenants fulfil their obligations, we can prove that in round m + 1 the loyal lieutenants reach an agreement. This is expressed with the following formulae:
Φ1, Φ2, Φ3 ▶Bizm rm+1 → (lj1 .d — ... — ljn−m .d).
(We denote by Bizm the specification given above.) This property follows trivially if we prove that any two loyal lieutenants reach an agreement. This is expressed by the following property:
Property 1
Φ1, Φ2, Φ3 ▶Bizm rm+1 → (lu1 .d — lju2 .d).
(for any u1, u2 ∈ {j1,..., jn−m}.)
Sketch of Proof. At the beginning we have чlu1 .d and чlu2 .d. If, in any round rk with k ≤ m, we have lu1 .d by axiom 9, and since we assume that loyal lieutenants fulfil their obligations, we know that the action lu1 .sendA(lu2 ) will be executed and also lu1 will forward all of the k messages that he received with an attack order. This implies that, in round rk+1, lieutenant lu2 will have received k + 1 messages saying attack, and, therefore, by axiom 8, in round rk+1 we have lu2 .d. The same reasoning can be applied to lu2 .d in round rk with k ≤ m. If lk1 .d is true in round rm+1 and false in all the earlier rounds, then this lieutenant has received m + 1 messages saying “attack”, but since traitors do not lie by assumption and also we assumed that we have at most m traitors, lieutenant lu1 have received an order to attack from some loyal lieutenant, which by axiom 9 sent the same orders to lieutenant lu2 ; this implies that in the next round after receiving the order from the loyal lieutenant, both have decided to attack by axiom 7.	 
It is interesting to note that when traitors lie, the property shown above is not true. Suppose that we have three lieutenants: l0, l1, l2 and l1 is a traitor. Consider the specification instanced with m = 1 (only one traitor).  The model in figure 3 shows a counterexample; we have three states: s0, s1, s2, the initial state is s0. Below each state the predicates that are true at that state are shown, the predicates which are false are not shown. At the beginning, we have that no lieutenant is a traitor, and that the general l0 has decided to retreat. Each transition is labelled with the actions that are executed in that transition.  In the first transition, l1


l1 .,bet_ray¸Htt	l1 .fw,d(0_,A,2¸)Htt

s	¸ ¸z	.
s0	s1
r0	r1, l1.t
¸ ¸z
s2
r2, l2.d

Fig. 3. Counterexample when traitors lie

becomes a traitor; the dashed arrow indicates that a forbidden action was executed. After that, l1 lies to l2 and he forwards a message that he did not receive; this is also a forbidden action. As a consequence, in round r2, lieutenants l2 and l0 do not agree since one has decided to attack and the other to retreat.
Conclusions and Further Work
In this paper we have introduced an extension of the deontic action logic presented in [11,10,8,7]. The obtained logic allow us to capture contrary-to-duty statements, which have shown to be hard to deal with by other deontic formalisms. CTD structures are common in fault-tolerance. We have grounded this claim with two examples: first, we described the formalization of a simple train system, and we shown how contrary-to-duty statements arise in this scenario; we prove some prop- erties of the example and we show a scenario where the deontic constraints in the specification are violated, and, as a consequence, a non-desirable system state is reached. As a second example, we have described a specification of the Byzantine Generals problem [18], a classic case study in fault-tolerance. Using this example, we show that deontic predicates allow us to have several layers of reasoning about a specification; this is mainly obtained using stratified norms, where violations of the norms at some level are tolerated, while the violation of norms at other levels are not.
The logic presented in this paper can be extended in several ways to obtain more expressive frameworks. A first extension is to enrich the logic with first-order operators; this will allow us to express interesting properties related to data, and to deal with more complex examples. A second extension is to introduce the notion of module or component. This allows one to simplify designs and to enable com- positional reasoning over deontic specifications. We have done this partially in [6], where we have shown, using Dijkstra’s example of dining philosophers, how specifi- cations can be modularized and how the reasoning about specifications is simplified by using components. Interestingly, the structuring of specifications enables a mod- ular reasoning about the violations arising during a system execution; undoubtedly this deserves further investigation.

References
Zair Abdelouahab and Isaias Braga. An adaptive train traffic controller. In An Adaptive Train Traffic Controller, pages 550–555. Springer Netherlands, 2008.
Jean-Raymond Abrial. Train systems. In RODIN Book. Springer, 2006.
Lennart Aqvist. Deontic logic. In D.M.Gabbay and F.Guenther, editors, Handbook of Philosophical Logic, volume 2, pages 605–714. Kluwer Academic Publishers, 1984.


Anish Arora. A Foundation of Fault-Tolerant Computing. PhD thesis, The University of Texas at Austin, 1992.
P. Blackburn, M.de Rijke, and Y.de Venema. Modal Logic. Cambridge Tracts in Theoretical Computer Science 53, 2001.
Pablo F. Castro. Deontic Action Logics for the Specification and Analysis of Fault-Tolerance. PhD thesis, McMaster University, Department of Computing and Software, 2009.
Pablo F. Castro and T.S.E. Maibaum. A complete and compact deontic action logic. In The 4th International Colloquium on Theoretical Aspects of Computing. Springer Berlin, 2007.
Pablo F. Castro and T.S.E. Maibaum. An ought-to-do deontic logic for reasoning about fault-tolerance: The diarrheic philosophers. In 5th IEEE International Conference on Software Engineering and Formal Methods. IEEE, 2007.
Pablo F. Castro and T.S.E. Maibaum. Reasoning about system-degradation and fault-recovery with deontic logic. In Workshop on Methods, Models and Tools for Fault-Tolerance, 2007.
Pablo F. Castro and T.S.E. Maibaum. A tableaux system for deontic action logic. In Deontic Logic in Computer Science, 9th International Conference, DEON 2008, Luxembourg, Luxembourg, July 15-18, 2008. Proceedings. Springer, 2008.
Pablo F. Castro and T.S.E. Maibaum. Deontic action logic, atomic boolean algebra and fault-tolerance.
Accepted for publication in Journal of Applied Logic (Feb 27), 2009.
Brian F. Chellas. Modal Logic: An Introduction. Cambridge University Press, 1999.
Danny Dolev and H. Raymond Strong. Authenticated algorithms for byzantine agreement. SIAM J. Comput., 12:656–666, 1983.
James William Forrester. Gentle murder, or the adverbial samaritan. The Journal of Philosophy, 81:193–197, 1984.
D. Harel, D. Kozen, and J. Tiuryn. Dynamic Logic. MIT Press, 2000.
Claude Hennebert and G´erard D. Guiho. SACEM: A fault tolerant system for train speed control. In The Twenty-Third Annual International Symposium on Fault-Tolerant Computing, pages 624–628, 1993.
S. Kent, B. Quirk, and T.S.E. Maibaum. Specifying deontic behaviour in modal action logic. Technical report, Forest Research Project, 1991.
Leslie Lamport, Robert E. Shostak, and Marshall C. Pease. The byzantine generals problem. ACM Trans. Program. Lang. Syst., 4:382–401, 1982.
T. S. E. Maibaum. A logic for the formal requirements specification. Technical report, Imperial College, London.Deliverable R3 for FOREST, 1987.
Paul McNamara. Deontic logic. Technical report, The Stanford Encyclopedia of Philosophy, 2006.
J.J. Meyer. A different approach to deontic logic: Deontic logic viewed as variant of dynamic logic. In
Notre Dame Journal of Formal Logic, volume 29, 1988.
J.J. Meyer, R.J. Wieringa, and F.P.M. Dignum. The paradoxes of deontic logic revisited: A computer science perspective. Technical Report UU-CS-1994-38, Utrecht University, 1994.
Marek J. Sergot and Robert Craven. The deontic component of action language nC+. DEON, pages 222–237, 2006.
Marek J. Sergot and Henry Prakken. Contrary-to-duty obligations. In DEON 94 (Proc.Second International Workshop on Deontic Logic in Computer Science), 1994.
T. K. Srikanth and Sam Toueg. Simulating authenticated broadcasts to derive simple fault-tolerant algorithms. Distributed Computing, 2:80–94, 1987.
