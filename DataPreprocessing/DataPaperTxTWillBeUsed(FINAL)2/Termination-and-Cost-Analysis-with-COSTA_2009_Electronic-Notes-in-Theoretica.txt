

Electronic Notes in Theoretical Computer Science 258 (2009) 109–121
www.elsevier.com/locate/entcs

Termination and Cost Analysis with COSTA and its User Interfaces
E. Albert1 P. Arenas1 S. Genaim1 M. G´omez-Zamalloa1
G. Puebla2 D. Ram´ırez2 G. Rom´an2 D. Zanardini2
1 DSIC, Complutense University of Madrid,
{elvira,puri,samir.genaim,mzamalloa}@fdi.ucm.es
2 Technical University of Madrid, {german,diana,groman,damiano}@clip.dia.fi.upm.es


Abstract
costa is a static analyzer for Java bytecode which is able to infer cost and termination information for large classes of programs. The analyzer takes as input a program and a resource of interest, in the form of a cost model, and aims at obtaining an upper bound on the execution cost with respect to the resource and at proving program termination. The costa system has reached a considerable degree of maturity in that (1) it includes state-of-the-art techniques for statically estimating the resource consumption and the termination behavior of programs, plus a number of specialized techniques which are required for achieving accurate results in the context of object- oriented programs, such as handling numeric fields in value analysis; (2) it provides several non- trivial notions of cost (resource consumption) including, in addition to the number of execution steps, the amount of memory allocated in the heap or the number of calls to some user-specified method; (3) it provides several user interfaces: a classical command line, a Web interface which allows experimenting remotely with the system without the need of installing it locally, and a recently developed Eclipse plugin which facilitates the usage of the analyzer, even during the development phase; (4) it can deal with both the Standard and Micro editions of Java. In the tool demonstration, we will show that costa is able to produce meaningful results for non-trivial programs, possibly using Java libraries. Such results can then be used in many applications, including program development, resource usage certification, program optimization, etc.
Keywords: Cost Analysis, Termination Analysis, Resource Usage.


 This work was funded in part by the Information Society Technologies program of the European Commission, Future and Emerging Technologies under the IST-15905 MOBIUS and IST-231620 HATS projects, by the Spanish Ministry of Education (MEC) under the TIN-2005-09207 MERIT, TIN-2008-05624 DOVES and HI2008-0153 (Acci´on Integrada)
projects, and the Madrid Regional Government under the S-0505/TIC/0407 PROMESAS



1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.12.008

Introduction and System Description
We start by describing the architecture of costa, an abstract-interpretation- based static analyzer for studying the cost [4] and termination [1] behavior of Java bytecode [7] programs. Cost analysis deals with statically estimating the amount of resources which can be consumed at runtime (i.e., the cost), given the notion of a specific resource of interest, while the goal of termination analysis is to prove, when it is the case, that a program terminates for every input.
The input provided to the analyzer consists of a program and a description of the resource of interest, which we refer to as cost model. costa tries to infer an upper bound of the resource consumption, and sound information on the termination behavior (i.e., if the system infers that the program terminates then it should definitely terminate). The system comes equipped with sev- eral notions of cost, such as the heap consumption, the number of bytecode instructions executed, and the number of calls to a specific method.
costa is based on the classical approach to static cost analysis [14] which consists of two phases. First, given a program and a description of the re- source, the analysis produces cost relations, which are sets of recursive equa- tions. Second, closed-form solutions are found, if possible. For this, costa uses PUBS [2].
Having both cost and termination analysis in the same tool is interesting since such analyses share most of the computing machinery, and thus a large part of the analyzer is common to both. As an example, proving termination needs reasoning about the number of iterations of every loop in the program, which is also an essential piece of information for computing its cost.
In spite of being still a prototype, costa includes state-of-the-art techniques for cost and termination analysis, plus a number of specialized components and auxiliary static analyses which are required in order to achieve accurate results in the context of object-oriented programs, such as handling numeric ﬁelds in value analysis. As for the usability, the system provides several user interfaces: (i) a classical command-line interface (Section 2.1); (ii) a Web in- terface which allows using costa from a remote location, without the need of installing it locally (Section 2.2), and permits to upload user-defined exam- ples as well as testing programs from a representative set; and (iii) a recently developed plugin for the widely used programming environment Eclipse [6], which allows easily using the analyzer while developing software (Section 2.3). costa can deal with full sequential Java, either in the Standard Edition [13] or the Micro Edition [8]. Needless to say, the analyzer works on Java byte-

project.

code programs, and does not require them to come from the compilation of Java source code: instead, bytecode may have been implemented by hand, or obtained by compiling languages different from Java.
The tool demonstration will show that costa is able to read .class files and produce meaningful and reasonably precise results for non-trivial programs, possibly using Java libraries. Possible uses of such cost and termination results include:
helping the programmer in the development process, as obtained by using
costa from the Eclipse plugin;
the costa results can be used as guarantees that the program will not take too much time or resources in its execution nor fail to terminate; further- more, this can potentially be combined with the Proof-carrying code [10] paradigm by adding certificates to programs which make checking resource usage more efficient.
program optimization, costa can be used for guiding program optimization or choosing the most efficient implementation among several alternatives.
The preliminary experimental results performed to date are very promising and they suggest that resource usage and termination analysis can be applied to a realistic object-oriented, bytecode programming language.
User Interfaces of COSTA
Command-Line Interface
costa has a command-line interface for executing costa as a standalone ap- plication. Different switches allow controlling the different options of the ana- lyzer. It facilitates the implementation of other interfaces, as discussed below. They collect user information and interact with costa by making calls to its command-line interface.
Web Interface
The costa web interface allows users to try out the system on a set of repre- sentative examples, and also to upload their own programs, which can be in the form of either Java source, or as Java bytecode, in which case it can be given as a .class or a .jar file. As the behavior of costa can be customized using a relatively large set of options, the web interface allows two alternatives modes of use.
The first alternative, which we call automatic (see Figure 1, left) allows the user to choose from a range of possibilities which differ in the analysis


 
Fig. 1. Two ways of setting values for analysis options
accuracy and overhead. Starting from level 0, the default, we can increase the analysis accuracy (and overhead) by using levels 1 through 3. We can also reduce analysis overhead (and accuracy) by going down to levels -1 through
-3. The main advantage of the automatic mode is that it does not require the user to understand the different options implemented in the system and their implications in analysis accuracy and overhead. The second alternative is called manual (see Figure 1, right) and it is meant for expert users. There, the user has access to all the analysis options, allowing a fine-grained control over the behavior of the analyzer. For instance, these options allow deciding whether to analyze the Java standard libraries or not, whether to take excep- tions into account, to perform or not a number of pre-analyses, to write/read analysis results to file in order to reuse them in later analyses, etc.
Figure 2 shows the output of costa on an example program with exponen- tial complexity. In addition to showing the result of termination analysis and an upper bound on the execution cost, costa (optionally) displays information about the time required by the intermediate steps performed by the analyzer in previous phases.
Eclipse Plugin
costa also has available an Eclipse plugin interface, which is fully integrated within the Eclipse development environment. This plugin allows programmers to analyze methods during the development process. It loads the classpath established for the project and uses for analysis the same classes and libraries



Fig. 2. Results

Fig. 3. costa Plugin Preferences

specified by the user to compile and execute the program. As in the web inter- face, users can configure a large set of options by using the Eclipse preferences configuration window, as shown in Fig. 3. These options are saved and loaded at every Eclipse execution. Also, the user can choose either the automatic analysis or the expert mode which allows a more fine-grained customization, like in the web interface. By using this plugin, one can analyze one or several methods from a class (see Fig. 5) or the whole class (by running the analysis on all its methods). The results of the analysis are shown using markers in the source code (see Fig. 4). Such markers are different depending on the cost model used for analysis. In addition, the plugin also shows all previous



Fig. 4. costa Plugin Markers and View
analysis results in an additional view, which we call “the costa view”. The costa view also includes a warning icon for methods whose termination is not proved, in order to alert the programmer about potential problems. It can also read comments in the source code, written in Javadoc style, in order to set up analysis information.

Fig. 5. costa Plugin Methods Selection


Functionalities of COSTA
In this section, we explain the main functionalities of costa by means of several small examples. Some of these examples aim at illustrating the different cost



Fig. 6. Example for number of instructions
models available in the system. The last two examples are related to termi- nation issues. In particular, we start in Sect. 3.1 by showing a program whose execution requires an exponential number of bytecode instructions. Then, in Sect. 3.2, we present the cost model that bounds the total heap consumption of executing a program and the recent extension to account for the effect of garbage collection. Sect. 3.3 performs resource analysis on a MIDlet using the cost model “number of calls” to a given method. Finally, in Sect. 3.4, we prove termination on an example whose resource consumption cannot be bound by costa and, also, show the latest progress to handle numeric fields(Sect. 3.5) in termination analysis.

Number of Instructions
The cost model which counts the number of instructions which are executed is probably the most widely used within cost analyzers, as it is a first step towards estimating the runtime required to run a program. Let us consider the Java method in Fig. 6. The execution of this method has an exponen- tial complexity as each call spawns two recursive calls until the base case is found. costa yields the upper bound(slightly pretty printed) -13 + 18*2nat(n) using its automatic mode which indicates, as expected, that the number of in- structions which are executed grows exponentially with the value of the input argument n. This shows that costa is not restricted to polynomial complexi- ties, in contrast to many other approaches to cost analysis.

Memory Consumption
Let us consider the Java program depicted in Figure 7. It consists of a set of Java classes which define a linked-list data structure in an object-oriented style. The class Cons is used for data nodes (in this case integer numbers) and the class Nil plays the role of null to indicate the end of a list. Both Cons and Nil extend the abstract class List. Thus, a List object can be either a Cons or a Nil instance. Both subclasses implement a copy method which is used to clone the corresponding object. In the case of Nil, copy just returns a new instance of itself since it is the last element of the list. In the















Fig. 7. Example for memory consumption
case of Cons, it returns a cloned instance where the data is cloned by calling the static method m, and the continuation is cloned by calling recursively the copy method on next.
The heap cost model of costa basically assigns, to each memory allocation instruction, the number of heap units it consumes. It can therefore be used to infer the total amount of memory allocated by the program. Running costa in automatic mode, level 0, yields the following upper bound for the copy method of class Cons:
nat(this-1)*(12 + k1 + k2 + k3) + 12 + 2*k1 + k2 + k3
It can be observed that the heap consumption is linear w.r.t. the input param- eter this, which corresponds to the size of the this object of the method, i.e., the length of the list which is being cloned. This is because the abstraction being used by costa for object references is the length of the longest reference chain, which in this case corresponds to the length of the list. The expression also includes some constants. The symbolic constants k1, k2 and k3 represent the memory consumption of the library methods which are transitively in- voked. In particular, k1 corresponds to the constructor of class Object and k2 resp. k3 to the constructor and intValue method of the class Integer. The numeric constant 12 is obtained by adding 8 and 4, being 8 the bytes taken by an instance of class Cons, and 4 the bytes taken by an Integer instance. Note that we are approximating the size of an object by the sum of the sizes of all of its fields. In particular, both an integer and a reference are assumed to consume 4 bytes.
Interestingly, we can activate the flag go into java api and thus ask costa to analyze all library methods which are transitively invoked. In this case we obtain the upper bound 12*nat(this-1) + 12, for the same method. This

is because the library methods used do not allocate new objects on the heap.

Peak Heap Consumption
In the case of languages with automatic memory management (garbage collec- tion) such as Java Bytecode, measuring the total amount of memory allocated, as done above, is not very accurate, since the actual memory usage is often much lower. Peak heap consumption analysis aims at approximating the size of the live data on the heap during a program’s execution, which provides a much tighter estimation. We have recently developed and integrated in costa a peak memory consumption analysis [5]. Among other things, this has re- quired the integration of an escape analysis which approximates the objects which do not escape, i.e., which are not reachable after a method’s execution. The upper bound ub(A) = 8*nat(A-1) + 24 is now obtained for the same example.
An interesting observation is that the Integer object which is created inside the m method is not reachable from outside and thus can be garbage collected. The peak heap analyzer accounts for this and therefore deletes the size of the Integer object from the recursive equation, thus obtaining 8 instead of 12 multiplying nat(A − 1). By looking at the upper bound above, it can be observed that costa is not being fully precise, as the actual peak consumption of this method is 8 ∗ nat(A − 1)+ 8 (i.e. the size of the cloned list). The reason for this is that the upper bound solver has to consider an additional case introduced by the peak heap analysis to ensure soundness, hence making the second constant increase to 24.

Number of Calls – Java Micro Edition
The Java Micro Edition (Java ME ) [8] technology provides a limited envi- ronment to create Java applications which can be run on small devices with limited memory, display and power capacity. It is based on three elements: a conﬁguration that provides the most basic set of libraries and virtual machine capabilities, a proﬁle which is a set of APIs supported by mobile devices and an optional package (set of technology-specific APIs). MIDP (Mobile Infor- mation Device Profile) [12] is the profile that limits the set of APIs to only those functional areas considered as absolute requirements to achieve broad portability and successful deployments. A MIDlet is an application meeting the specifications for the Java ME technology, such as a game or a business application. Each MIDlet is an object of class MIDlet which follows a lifecy- cle [9], which is a state automaton managed by the Application Management System (AMS ).



Fig. 8. Example for number of calls





costa is able to perfom resource analysis on MIDlets by considering all classes used on each method called during the lifecycle of the MIDlet. Such methods are the constructor of the class, the startApp() and the commandAction(Command c, Displayable d) methods. In particular, the classes used during the analysis of the class constructor are added to the analysis of the startApp() method. After analyzing startApp() method, the current classes are used for analyzing the commandAction(Command c, Displayable d) method. As a result, the analyzer obtains a more precise cost and resource analysis for MIDP applications. Fig. 8 shows a simple but real example MIDlet that sends a text message: the text message is created (newMessage method), the recipient phone number set (setAddress method) and the text message is sent using the method send(Message tmsg) of the Wireless Messaging API.
We analyze this example using the cost model that counts the number of calls (ncalls) to a particular method. We apply it to obtain an upper bound on how many times the send(Message tmsg) method is called during the execution of commandAction method in a mobile device. costa outputs 1 as result, as it is to be expected.



Fig. 9. Example for termination
Termination
Fig. 9 shows two methods which belong to the same class. The method doSum computes the sum of all factorial numbers contained in the elements of a linked list x, where List is defined as in Fig. 7. costa is able to ensure the termination of method doSum but no upper bound can be found by the system for the cost model ninst. The information that costa yields when computing an upper bound is:
The Upper Bound for ’doSum’(x) is nat(x)*(19+c(maximize_failed)*9)+4 Terminates?: yes
Intuitively, the cost of the calls to factorial cannot be bound because the value of x.elem is unknown at analysis time. However, we can still prove that the execution of the two methods always terminates by finding a so- called ranking function [11]. The technical details about how costa deals with termination can be found in [1].

Numeric Fields
Fig. 10 shows a Java program involving a numeric field in the condi- tion of the loop of method m. This loop terminates in sequential execu- tion because the field size is decreased at each iteration, at instruction x.f.setSize(x.f.getSize() − 1), and, for any initial value of size, there are only a finite number of values which size can take before reaching zero. Un- fortunately, applying standard value analyses on numeric fields can produce wrong results because numeric variables are stored in a shared mutable data structure, i.e., the heap. This implies that they can be modified using different references which are aliases and point to such memory location. Hence, further conditions are required to safely infer termination. costa incorporates a novel approach for approximating the value of heap allocated numeric variables [3] which greatly improves the precision over existing field-insensitive value analy- ses while introducing a reasonable overhead. For the example in Fig. 10, costa not only guarantees termination of method m but is also able to compute the (pretty printed) upper bound for m(this,x,y,size) is 33+nat(size)*35 by using the cost model ninst.


Fig. 10. Example for termination in presence of numeric fields
Discussion and Future Work
costa is, to the best of our knowledge, the first tool for fully automatic cost analysis of object-oriented programs. Currently, the system can be tried online through the COSTA web site: http://costa.ls.fi.upm.es. We plan to distribute it soon under a GPL license. The fact that costa analyzes bytecode, i.e., compiled code, makes it more widely applicable, since it is customary in Java applications to distribute compiled programs, often bundled in jars, for which the Java source is not available.
As future work we plan to: (1) define new cost models to measure the consumption of new resources; (2) support other complexity schemes such as the inference of lower-bounds; (3) improve both the precision and performance of the underlying static analyses; and (4) handle the analysis of concurrent programs.

References
E. Albert, P. Arenas, M. Codish, S. Genaim, G. Puebla, and D. Zanardini. Termination Analysis of Java Bytecode. In FMOODS, LNCS 5051, pages 2–18, 2008.
E. Albert, P. Arenas, S. Genaim, and G. Puebla. Automatic Inference of Upper Bounds for Recurrence Relations in Cost Analysis. In SAS, LNCS 5079, 2008.
E. Albert, P. Arenas, S. Genaim, and G. Puebla. Dealing with numeric fields in termination analysis of java-like languages. In FTfJP, 2008.
E. Albert, P. Arenas, S. Genaim, G. Puebla, and D. Zanardini. Cost Analysis of Java Bytecode. In ESOP, LNCS 4421, pages 157–172. Springer, 2007.
E. Albert, S. Genaim, and M. G´omez-Zamalloa. Live Heap Space Analysis for Languages with Garbage Collection. In ISMM’09: Proceedings of the 8th international symposium on Memory management, New York, NY, USA, June 2009. ACM Press.
ECRC. Eclipse User’s Guide. European Computer Research Center, 1993.

T. Lindholm and F. Yellin. The Java Virtual Machine Speciﬁcation. A-W, 1996.
Java ME. http://java.sun.com/javame/technology/index.jsp.
MIDP.	http://java.sun.com/javame/reference/apis/jsr118/javax/-microedition/ midlet/package-summary.html.
G. Necula. Proof-Carrying Code. In Proc. of ACM Symposium on Principles of programming languages (POPL), pages 106–119. ACM Press, 1997.
A. Podelski and A. Rybalchenko. A complete method for the synthesis of linear ranking functions. In VMCAI, 2004.
Java Community Process MIDP Release. http://jcp.org/aboutJava/communityprocess/ final/jsr118-/index.html.
Java SE. http://java.sun.com/javase/technologies/index.jsp.
B. Wegbreit. Mechanical Program Analysis. Comm. of the ACM, 18(9), 1975.
