 Electronic Notes in Theoretical Computer Science 96 (2004) 113–127 
www.elsevier.com/locate/entcs




Event Structures for Interrupt Process Algebras

Harald Fecher
Universita¨t Mannheim, Fakulta¨t fu¨r Mathematik und Informatik D7, 27, 68131 Mannheim, Germany


Abstract
Interruption is a useful feature in programming and specification languages. Therefore, process algebras has been extended with an additional interrupt operator. We invent a class of event structures, called interrupt event structures, to give a true concurrent semantic to process algebras containing interruption. Interrupt event structures are more expressive than other event structures with respect to event trace execution. Furthermore, interrupt event structures can also distinguish simultaneous event executions from event interleaving. We show consistency, based on bisimulation, between the operational and the denotational semantics of a process algebra that contains an interrupt operator.
Keywords: process algebra, event structures, interruption, consistency, true concurrency


Introduction
A useful feature in programming and specification languages is the ability to de- scribe the interruption of a normal execution of the system. Interrupt mechanisms are, for example, increasingly used to perform memory management. It is already the case that some modern, general-purpose CPUs have sophisticated ways of han- dling interrupts. See for example [26], where an interrupt calculus is invented to analyze such CPU-based interrupts. See also [24,29], where precise interrupts are discussed. Since it is also essential to have interrupt mechanisms in reactive, con- current systems (for example the downloading from the internet can be interrupted and continued by the user), various interrupt mechanisms are added to process al- gebras, see e.g. [3,4,11,12]. A common approach is to use an interrupt operator (>>) where process B1 >> B2 behaves like process B1, except that it may be inter-
rupted by B2 at any time before the termination of B1. Furthermore, B1 continues
its execution after the termination of B2.


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.04.024

True concurrency models are important to describe the independence of events (actions). Event structures (e.g. [9,21,30]) are typical true concurrency models. They are especially used to give truly concurrent denotational semantics to process algebras. Standard event structures still lack the possibility to describe interrupts: an event that gets interrupted has to become disabled, and later it has to become enabled again (when the interrupting process has terminated). But standard event structures cannot undo the disabling 1 . Exceptions are the inhibitor event structures [5]. Nevertheless, in general they are not sufficient to give denotational semantics to process algebras that contains an interrupt operator (more precisely, to the pro- cess algebra presented here), since the disabling of these event structures is too restrictive.
The cancellation of the disabling is modelled in our event structures, which we call interrupt event structures, as follows: We collect a set X of events that disables event e, i.e. e is disabled if all events of X are executed. Then we connect
another set Y of events to the tuple (X, e). This Y denotes the cancellation of the
disabling, i.e. the disabling is removed (or will not happen anymore) if an event from Y is executed. In other words, when an event becomes disabled and when it becomes enabled is encoded in a single relation.
It turns out that some event structures are special cases of interrupt event struc- tures. Furthermore, the other standard event structures have less expressive power than interrupt event structures with respect to event traces. Interrupt event struc- tures can also distinguish event interleaving from simultaneous event executions. More precisely, it is possible that two events may interleave but they cannot be exe- cuted simultaneously. We classify the sets of step event traces that can be described by interrupt event structures. A process algebra that contains an interrupt operator is also introduced. We give an operational semantics in terms of (labelled) transi- tion systems and a denotational semantics in terms of interrupt event structures. A consistency result between the two semantics is given.
The paper is organized as follows: In Section 2 we introduce the interrupt event structures. Their expressive power is examined in Section 3. Section 4 introduces our process algebra together with the two semantics and the consistency result. Related works are discussed in Section 5.

Interrupt Event Structures
In the following, P(M ) denotes the powerset of M , and Pf (M ) denotes the set of all finite subsets of M . Furthermore, we assume a fixed countable set of events U
such that • ∈ U and * ∈/ U and for all e, e' ∈ U we have (e, e'), (*, e), (e, *) ∈

1 Disabling is modelled in standard event structure by a binary relation between (sets of) events and events, hence once an event is disabled it remains disabled.

. The constraints on	result from technical reasons (they guarantee the well- definedness of the operators which are defined in Subsection 4.2).
Definition 2.1 An interrupt event structure (IES), denoted by I = (E, ~), is an element of P(U) × P(P(U) × P(U) ×U) such that ~⊆ Pf (E) × P(E) × E. Let MI denote the set of all interrupt event structures.
E is called set of events and ~ is called interrupt relation. In the following, we
will write X ~Y  e rather than (X, Y, e) ∈~.

The intuitive meaning of an IES is the following: Set X in X ~Y
e states

when event e gets disabled and set Y indicates when this disabling condition gets removed. More precisely, if all events from X have been executed, then e is dis- abled unless an event from Y has already been executed. In other words, the first component of ~ is universally quantified (Winskel’s approach [30]) and the sec- ond component is existentially quantified (bundle approach [21]). It is possible to use the same kind of quantification (universal or existential) in both components, but this would complicate the definition of event execution. Furthermore, with our definition (pre-)inhibitor event structures 2 [5] become a special case of interrupt event structures. Additionally, we have the feeling that the mixed quantification approach gives simpler opportunities to extend interrupt event structures by perfor- mance issues, like time.
Some IES are shown in Figure 1. Events, here named a, b, c, d, are depicted as dots. The first component of an interrupt relation is illustrated by wavy lines

and the second component by straight lines. More precisely, X ~Y
e is depicted

by a wavy arrow from the elements of X to e together with a straight arrow from the elements of Y to this wavy line. Furthermore, we use only one wavy line for
{b}
each (X, e) tuple. For example, the upper wavy line in I2 encodes {b} ~ a and
b ~ a. The straight line points directly to e if X is the empty set, as it is the case for the arrow from b in 1. The straight lines are omitted if Y is the empty set unless X is also the empty set, as it is the case in 3. Process algebra terms to which the depicted interrupt event structures correspond are also given in Figure 1. The process algebra terms will be introduced in Section 4.
Remark 2.2 Interrupt event structures have to be extended with an additional con- straint (called approximation closedness) in order to obtain a complete partial or- der 3 (if the standard approach is used to define the order) [14,13]. This technical constraint is omitted here in order to increase the readability.

2 (Pre-)inhibitor event structures have a similar interrupt relation (the second component is exis- tentially quantified) except that only single events are allowed in the first component. Hence, their disabling is more restrictive than in interrupt event structures.
3 Complete partial orders [1] are used to give meanings to recursive processes.



I1
。b



。c
I3
。b	∅   。b



。c	。c

(a; 0) >> (b; c)

a



b
(a; 0) >> (b  ∅c)
(((a; b) >> c)\\{a}); 0 I5
a	。b

((a  ∅b) >> (c; d)); 0
Fig. 1. Some Interrupt Event Structures



Hereafter, we consider I to be (E, ~). Furthermore, init(I) denotes the set of the initial events of I, i.e. those events in I which are ready to be executed.
init(I)= {e ∈ E | ¬(∃Y : ∅ ~ e)}
The remainder of an IES with respect to an initial event e describes the sys- tem after the execution of e. Therefore, we remove e in E and also from the first components of the interrupt relation. Furthermore, we only consider those tuples
X ~ e' where e ∈/ Y . Formally:

Definition 2.3 Let I ∈ MI and e ∈ init(I). The remainder of I with respect to e
is the interrupt event structure I[e] = (E \ {e}, ~') where ~'= {(X \ {e}, Y, e') |
e' /= e ∧ e ∈/ Y ∧ X ~Y  e}.

The event execution of I1 shown in Figure 1 is presented in Figure 2. The execution of event b in I2 shown in Figure 1 yields the IES presented in Figure 3.
{c}
There it can be easily seen that c is the only initial event of I2[b], since ∅ ~ a. Event
c of 4 shown in Figure 1 is disabled if both events a and b are executed, but not if only one event a or b is executed. This can be seen in Figure 3, where the execution of event a in I4 is shown.





。b  b 



。c zz
  c)	a 。
。c


。b


zza
za


c 



(∅, ∅)

aza


。c
  b)	c 。

Fig. 2. Event Execution of I1


I2[b]
a 。(	 
。c
I4[a]



b


c。	) 。d


Fig. 3. Partly Event Execution of I2 and I4
Expressive Power
Event Traces
In this subsection, we compare the expressive power of interrupt event structures with other event structures with respect to the event traces they can execute.
Definition 3.1 An event trace, denoted by →v, is a finite sequence of distinct ele- ments of U. Let V denote the set of all event traces.
If →v = (e1, ..., en) ∈ V, then →v = {e1, ..., en}.
An event trace (e1, ..., en) is an execution of I ∈ MI if and only if ei+1 ∈ init(I[e1]...[ei]) for every i < n. Let EvTr(I) denote the set of all event traces that are executions of I.
The set of event traces corresponding to  1 is EvTr( 1)=	, a, ab, abc, b, bc, bca .
Dual event structures [19] and consequently (extended) bundle [20,21], prime
[25] and (pre-)asymmetric event structures 4 [6], are special cases of interrupt event structures if the termination and the action labelling of the events are neglected 5 :

The binary conflict relation, for example between e and e', is modelled by {e} ~∅
e',



4 (Pre-)asymmetric event structures are prime event structures where the conflict relation is not necessarily symmetric.
5 Interrupt event structures are extended with termination and action labelling in Subsection 4.2.

and the bundle causality relation (Y '→ e) is modelled by ∅ ~Y  e. Fortunately, in
these cases the depiction of the dual event structures coincides with the depiction of the corresponding interrupt event structures (see for example the first two IESs shown in Figure 5 on page 11).
(Pre-)inhibitor event structures [5] are interrupt event structures where the first component of ~ has to be either the empty set or a single event set. Termination bundle or termination precursor event structures 6 [13] can, similarly to dual event structures, be encoded in interrupt event structures such that they have the same set of event traces. Hence, interrupt event structures can also describe the sets of event traces of flow [9] and Winskel’s (stable) event structures [30], since they can be described by termination event structures [13].
On the other hand, the set of event traces corresponding to the interrupt event structure 4 shown in Figure 1 cannot be described by any of the other class of event structures mentioned. These facts are summarized in the following theorem:
Theorem 3.2 Every set of event traces that is described by a prime [25], flow [9], Winskel’s [30], bundle [21], (pre-)asymmetric [6], extended bundle [20], dual [19], termination bundle [13], termination precursor [13] or (pre)-inhibitor event structure [5] can also be described by an interrupt event structure, but not vice versa.
Proof. Can be easily checked by the results given in [13] and by the above de- scribed embedding of dual event structures in interrupt event structures.	 

Simultaneous Event Execution
In this subsection, we introduce step executions of interrupt event structures.
Definition 3.3 A step event trace, denoted by →s, is a finite sequence of pairwise disjoint elements of Pf (U) \ {∅}. Let S denote the set of all step event traces.
A set Y of initial events are independent if Y does not trigger a disabling of an event of Y . This is formalized in the following definition, where step execution on interrupt event structures is also introduced.
Definition 3.4 [Step Execution] Let	I. Define the set of all sets of initial, independent events by
i˜nit(I)= {Y ∈ Pf (E) \ {∅} | ∀(X, Y ', e) ∈~: e ∈ Y ⇒ ¬(X ⊆ Y \ {e})}. A step event trace (Y1, ..., Yn) is an execution of I ∈ MI if ∀i < n : Yi+1 ∈ i˜nit(I[Y1]...[Yi]), where I[{e1,...em}] = I[e1 ]...[em]. Let StEvTr(I) denote the set of all

6 Termination bundle or termination precursor event structures have a more general disabling rela- tion (set of events disables an event).

step event traces that are executions of I.
The step event execution in Definition 3.4 is well defined, since I[e1]...[em] is de- fined and it is independent from the order of these events whenever {e1, ...em} ∈ init( ). The set	a , a	b , b , b	a	consists of all step event trace exe- cutions obtained from 5 shown in Figure 1. From this example, it follows that two events do not have to be independent ( a, b is not in init( 5)) if they can be executed in any order. In other words, the interleaving of events does not imply independence of these events in	I. But this is the case for nearly all other event structures. Hence, the interrupt event structures are of special interest with respect
to true concurrency. Please note that we have considered interleaving with respect to event execution and not with respect to action execution (where the action de- noted to the event, see Subsection 4.2, is only observable and not the event itself). Of course it is possible to distinguish independence and interleaving with respect to action execution in the standard event structures (to some amount).

Classification of the Set of Step Event Traces from MI
Step event trace execution (and also event trace execution) in  I, is independent of the execution order. Furthermore, simultaneous event executions imply event
interleaving. This is formalized as follows:
Definition 3.5 Suppose S is a set of step event traces, i.e. S ⊆ S. Then
S is prefix closed if ∀(Y1, .., Yn) ∈ S : ∀m : m ≤ n ⇒ (Y1, .., Ym) ∈ S,
S is interleaving closed if
∀(Y1, .., Yn+1) ∈ S : ∀Y ∈ Pf (Yn+1) \ {∅, Yn+1} : (Y1, .., Yn, Y, Yn+1 \ Y ) ∈ S,
S is history-order independent if
∀(Y1, .., Yn+1), (Y ', .., Y ' ) ∈ S :  n	Yi =  m  Y ' ⇒ (Y ', .., Y ' , Yn+1) ∈ S.
It can be easily checked that the prefix closed, history-order independent sets of event traces (event traces correspond to step event traces where only single sets of events are allowed) and event automata 7 [27] where every state can be reached are equivalent approaches. Furthermore, prefix closed, interleaving closed, history- order independent sets of step event traces and local event structures 8 [17] are equivalent approaches.
Theorem 3.6 Let S ⊆ S. Then S is prefix closed, interleaving closed and history- order independent if and only if ∃I ∈ MI : S = StEvTr(I).

7 An event automaton is a set of configurations together with a relation on configurations, which indicates the events that can be executed in the corresponding configurations.
8 Local event structures can be considered as event automata where step executions are also de-
scribed.

Proof. [Sketch]
⇒: It can be checked that the interrupt event structure given by (U , {(X ∪ X˜, U\ 
 X, e) | |X ∪ X˜| < ∞∧ X ∩ X˜ = ∅∧ e ∈/ X ∪ X˜ ∧ ∀(Y1, ..., Yn) ∈ S : X =

⇐: Easily checked.

An immediately consequence of Theorem 3.6 is that for every set S of event
traces, i.e. S ⊆ V, we have S is prefix closed and history-order independent if and only if ∃I ∈ MI : S = EvTr(I).

Interrupt Process Algebra
Our process algebra is based on the interrupt process algebra of [3] 9 . Conse- quently, we follow the philosophy that the ‘final’ executed action of a process ter- minates the process [8].
Let τ denote the internal action. Furthermore, let Obs be a set such that τ ∈/
Obs. We call Obs the set of observable actions. The set of all actions ct is defined by ct = τ  Obs. Furthermore, we assume a fixed countable set of process variables Var which is disjoint from ct. The process algebra expressions EXP are defined by the following BNF-grammar.
B ::= 0 | a | B + B | B; B | B [>B | B >>B | B  AB | B\\A | x
where x  Var, a   ct and A   Obs. A process with respect to EXP is a pair decl, B consisting of a declaration decl : Var  EXP and an expression B  EXP. Let PA denote the set of all processes. We sometimes call an expression B  EXP a process if decl is clear from the context.
The expressions have the following intuitive meaning: 0 is the inactive process,
i.e. it cannot execute any action. a is the process that executes a and terminates. B1 + B2 is a choice between the behaviors described by B1 and B2. The choice is determined by the first action that occurs. B1; B2 is the sequential composition,
i.e. B1 proceeds until it terminates, after which B2 takes over. B1 [> B2 is the
disruption of B1 by B2, i.e. any action from B2 disables B1 as long as B1 has not terminated. On the other hand, the termination of B1 disables B2. The interrupt process B1 >> B2 behaves like B1, except that it may be interrupted by B2 at any time before the termination of B1. Furthermore, B1 continues its execution after the termination of B2. B1  AB2 describes the parallel execution of B1 and B2 where both processes have to synchronize on actions from A. The process terminates if both sides terminate in the case of synchronization or if one of them terminates and

9 We use different operator symbols.

the other one has already terminated. The restriction process B A executes action a if B executes action a, provided a is not contained in A. The behavior of x is given by the declaration, i.e. it allows the description of recursion.

Operational Semantics
The operational semantics of processes is given in terms of (labelled) transition systems. As stated before, we adopt the philosophy that the ‘final’ action termi- nates the process. Therefore, we have to distinguish between ‘final’ and ‘non-final’ actions. This is modelled by using a predicate for every action a, indicating that
the process can terminate by performing action a [8,3]. This predicate is typically
denoted by −a→ √, more precisely B −a→ √ indicates that B can terminate by
executing action a. The transition rules of −→decl⊆ EXP × Act × (EXP ∪ {√})
with respect to decl : Var → EXP are presented in Figure 4.

Denotational Semantics
We extend the interrupt event structures by termination and action labelling infor- mation in order to give a denotational semantics to PA. We use an additional set of event sets (T) to model termination. A system run is terminated if every element of T contains an event of the system run. Furthermore, an event structure can only terminate by executing an event, i.e. we demand that T = . However, T might
consist of the empty set only.
Before we present the definition, we introduce the following notation: M1 ~ M2 denotes the set of all partial functions from M1 to M2 (we sometimes consider a partial function from M1 to M2 as a subset of M1 × M2). Furthermore, the domain of a partial function f is the set {m | f (m) is defined} and is denoted by
dom(f ). Function f T M ' , where M ' ⊆ M1, denotes the restriction of function
f to domain M ' . We write f (m1)  f '(m' ) to denote that (f (m1) is defined ⇔
f '(m' ) is defined) ∧ (f (m1) is defined ⇒ f (m1)= f '(m' )).
Definition 4.1 A labelled interrupt event structure E = (E, ~, T, l) is an element of P(U) × P(P(U) × P(U) × U) × P(P(U)) × (U ~ Act) such that
(E, ~) ∈ MI
T ⊆ P(E) and T /= ∅
dom(l) = E and
∀→v ∈ EvTr((E, ~)) :

(∀Z ∈ T: →v ∩ Z /= ∅) ⇒ (∀e ∈ E \ →v : ∃X ⊆ →v, Y ⊆ E \ →v : X ~ e)
Let ME denote the set of all labelled interrupt event structures.



Fig. 4. Transition Rules for −→decl

a 。 
 
a 。
	,,
,,	a 。

 
/
b 。/
) 。c
 J
b 。
。c	.	。c

 J	b 。

(a + b); c
(a  ∅b); c
Fig. 5. Some Labelled Interrupt Event Structures
(a ∅b) [>c 

T is called the termination set and l the action-labelling function. The last constraint on labelled interrupt event structures guarantees that after termination ( Z  T : →v Z = ) no further event can be executed. Some labelled interrupt event structures are shown in Figure 5. The events and the interrupt relation are depicted as in Figure 1. The action names are shown close to the dots (we do not
name the events explicitly and identify them with the action names if no confusion arises). We mark a termination set Z  T by surrounding its events with a closed line.
Hereafter, we consider to be (E, ~, T, l) and i to be (Ei, ~i, Ti, li). The definition of the initial events is extended to labelled interrupt event structures by init(E) = init((E, ~)). Furthermore, the predicate Υ(T, e) holds if and only if e is a termination event with respect to T, i.e. E terminates by executing e. Formally:
Υ(T, e) ⇐⇒ ∀Z ∈ T: e ∈ Z
We present the operators on  E that are used to define the denotational seman- tics. In the following, πi denotes the projection to the ith component.
Definition 4.2 [Operators on ME ] Let A ⊆ Obs and i ∈ {1, 2}. Then define
+˜ : ME × ME ~ ME with E1+˜E2  (E1 ∪ E2, ~˜ , T˜, l1 ∪ l2) where
~˜ = ~1 ∪{({e2}, ∅, e1) | e1 ∈ init(E1) ∧ e2 ∈ init(E2)}∪ 
~2 ∪{({e1}, ∅, e2) | e1 ∈ init(E1) ∧ e2 ∈ init(E2)}
T˜ = {Z1 ∪ Z2 | Z1 ∈ T1 ∧ Z2 ∈ T2}
E	~, T2, l1 ∪ l2) where
˜; : M ×M ~ M with E1 ˜; E2  (E1 ∪ E2, ˜
~˜ = ~1 ∪ ~2 ∪{(∅, Z1, e2) | e2 ∈ init(E2) ∧ Z1 ∈ T1}
[˜> : ME × ME ~ ME with E1[˜>E2  (E1 ∪ E2, ~˜ , T˜, l1 ∪ l2) where
~˜ = ~1 ∪ ~2 ∪{({e2}, ∅, e1) | e1 ∈ E1 ∧ e2 ∈ init(E2)}∪ 
{(X1, ∅, e2) | e2 ∈ init(E2) ∧ X1 ∈ Pf ( T1) ∧ ∀Z1 ∈ T1 : X1 ∩ Z1 /= ∅}
T˜ = {Z1 ∪ Z2 | Z1 ∈ T1 ∧ Z2 ∈ T2}

>˜> : ME × ME ~ ME with E1>˜>E2  (E1 ∪ E2, ~˜ , T1, l1 ∪ l2) where
~˜ = ~1 ∪ ~2 ∪{({e2}, Z2, e1) | e1 ∈ E1 ∧ e2 ∈ init(E2) ∧ Z2 ∈ T2}∪ 
{(X1, ∅, e2) | e2 ∈ init(E2) ∧ X1 ∈ Pf ( T1) ∧ ∀Z1 ∈ T1 : X1 ∩ Z1 /= ∅}
˜A : ME × ME → ME with E1˜AE2 = (E˜, ~˜ , T˜,˜l) where
E˜ = (Ef × {*}) ∪ ({*}× Ef ) ∪ Es
1	2
Ef = {e ∈ Ei | li(e) ∈/ A}
Es = {(e1, e2) ∈ E1 × E2 | l1(e1)= l2(e2) ∈ A}
~˜ = {({(e' , e' )}, ∅, (e1, e2)) | (e' , e' ) /= (e1, e2) ∧ ∃i : e' = ei}∪ 
Yi
{(X˜, Y˜ , (e ,e )) | ∃i : ∃Y : π (X˜) ~ e ∧ Y˜ = {(e' , e' ) ∈ E˜ | e' ∈ Y }}
T˜ = {Z˜ | ∃i : ∃Zi ∈ Ti : Z˜ = {(e1, e2) ∈ E˜ | ei ∈ Zi}}
˜l(e ,e )=  l1(e1) if e2 = *
1	2
l2(e2) otherwise
˜\\A : ME → ME with E ˜\\A = E T {e ∈ E | l(e) ∈/ A} .
It is clear that all operators applied to 1 and 2 are defined if 1 and 2 have disjoint sets of events. We are only interested in such cases (out of readability, we define the operators without modelling the disjoint union explicitly).
The denotational meaning of processes 0 and a are [[ decl, 0 ]] = ( , ,  , ) and [[ decl, a ]] = (  , ,	, ( , a) ). The meaning of the other processes of PA can be derived from the operators in the standard way [13] (including recursion), where the disjointness of the sets of events can be ensured by using event renaming
operators. Examples of the denotational semantics of processes can be found in Figure 1 and Figure 5, where some processes are shown with their corresponding labelled interrupt event structures.

Consistency
Our causality result is based on bisimulation [22]. Please note that bisimulation is a congruence for our process algebra, which follows from the format of the transition rules [2]. Before we present our consistency result, we introduce action execution (including termination information) for labelled interrupt event structures.
Definition 4.3 The transition relation ‹→⊆ ME × Act × (ME ∪ {√}) is defined
by E ‹ a	' if and only if there is e ∈ init(E) such that a = l(e) and
→E 
(¬Υ(T, e)) ⇒ ((E', ~')= I[e] ∧ l' =l T E' ∧ T= {Z ∈ T | e ∈/ Z})

Υ(T, e) ⇒ E' = √.
Theorem 4.4 (Consistency) Suppose ⟨decl, B⟩∈ PA. Then the transition systems
(EXP, Act, −→decl, B) and (ME , Act, ‹→, [[⟨decl, B⟩]]) are bisimilar.
Proof. [Sketch] The proof uses the techniques presented in [13]: An event based transition relation is defined such that the events correspond to the events of the denotational semantics. This technique is used especially to handle unguarded recursion. Then we show that its corresponding transition system is bisimilar to
(EXP,  ct,   decl, B) and in addition bisimilar to (  E,  ct, ‹  , [[ decl, B ]]).
Hence, the statement follows by the transitivity of the bisimilarity [22].	 

Related Work
How interrupt event structures are related to other event structures is intensively examined in Section 3. There it is also shown that local event structures [17] (and event automata [27]) have the same expressive power as interrupt event structures with respect to step event traces (respectively event traces). Event automata and local event structures represent configurations explicitly, i.e. conflicts are not de- scribed intensionally as it is done in interrupt event structures. The intentional representation has, for example, the advantage of making the extension with time aspects less expensive.
(1-safe) Petri nets [28] can model some kinds of interruption. For example, the process (a; 0) >> (b; c) is modelled by the Petri net pictured on the left hand side in Figure 6. But 1-safe Petri nets (also if they are extended with read and inhibitor arcs [23]) cannot model the behavior of 4 shown in Figure 1, where sets of events ( a, b ) disable an event (c). On the other hand, 1-safe Petri nets that also contain read and inhibitor arcs can be expressed in inhibitor event structures [5]
and consequently in interrupt event structures.
General Petri nets (with possibly multiple tokens on places) can model the be- havior of 4 shown in Figure 1, but till now it is not clear how an interrupt operator can be defined. On the other hand, interrupt event structure may help to give a simpler semantics to general Petri nets.
Petri nets can also model event interleaving without implying simultaneous ex- ecutions. See for example the Petri net pictured on the right hand side in Figure 6. This Petri net has the same behavior with respect to step execution as the interrupt event structure I5 shown in Figure 1.
Configuration structures [15] lack the possibility of modelling interruptions, nor do they distinguish between event interleaving and simultaneous executions. Comtraces [18], which are a generalization of step based Mazurkiewicz traces, and chu-spaces [16] distinguish between event interleaving and simultaneous execu-


.o

.o
I1	I5

Fig. 6. Corresponding Petri Nets
tions. Contrary to our approach, event interleaving implies simultaneous executions in these models but not vice versa.

References
Samson Abramsky and Achim Jung. Domain theory. In Samson Abramsky, Dov M. Gabbay, and T. S. E. Maibaum, editors, Handbook of Logic in Computer Science, volume 3, pages 1–168. Clarendon Press, 1994.
Luca Aceto, Wan Fokkink, and Chris Verhoef. Structural operational semantics. In Bergstra et al. [7], pages 197–292.
J. C. M. Baeten and J. A. Bergstra. Mode transfer in process algebra. Report CSR 00-01, Vakgroep Informatica, Technische Universiteit Eindhoven, 2000.
J. C. M. Baeten, J. A. Bergstra, and J. W. Klop. Syntax and defining equations for an interrupt mechanism in process algebra. Fundamenta Informaticae, 9:127–168, 1986.
Paolo Baldan, Nadia Busi, Andrea Corradini, and G. Michele Pinna. Functional concurrent semantics for petri nets with read and inhibitor arcs. In C. Palamidessi, editor, CONCUR 2000 – Concurrency Theory, volume 1877 of LNCS, pages 442–457. Springer-Verlag, 2000.
Paolo Baldan, Andrea Corradini, and Ugo Montanari. Contextual petri nets, asymmetric event structures, and processes. Information and Computation, 171:1–49, 2001.
J. A. Bergstra, A. Ponse, and S. A. Smolka, editors. Handbook of Process Algebra. North-Holland, 2001.
Jan A. Bergstra, Wan Fokkink, and Alban Ponse. Process algebra with recursive operations. In Bergstra et al. [7], pages 333–389.
Ge´rard Boudol and Ilaria Castellani. Permutation of transitions: an event structure semantics for CCS and SCCS. In de Bakker et al. [10], pages 411–427.
J.W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors. Linear Time, Branching Time and Partial Order in Logics and Models for Concurrency, volume 354 of LNCS. Springer-Verlag, 1989.
B. Diertens. New features in PSF I – interrupts, disrupts, and priorities. Report P9417, Programming Research Group - University of Amsterdam, 1994.
A. Engels and Th. Cobben. Interrupt and disrupt in MSC: Possibilities and problems. In Y. Lahav,
A. Wolisz, J. Fischer, and E. Holz, editors, Proceedings fo the 1st Workshop of the SDL Forum Society on SDL and MSC, number 104 in Informatikberichte. Humboldt-Universitt zu Berlin, 1998.
Harald Fecher. Action Refinement in End-Based Choice Settings. PhD thesis, Universita¨t Mannheim, 2003.
Harald Fecher, Mila Majster-Cederbaum, and Jinzhao Wu. Bundle event structures: A revised cpo approach. Information Processing Letters, 83:7–12, 2002.
R. J. van Glabbeek and G. D. Plotkin. Configuration structures. In Proceedings of the 10th Annual IEEE Symposium on Logic in Computer Science, pages 199–209. IEEE Computer Society Press, 1995.


Vineet Gupta. Chu Spaces: A Model of Concurrency. PhD thesis, Stanford University, 1994.
P. W. Hoogers, H. C. M. Kleijn, and P. S. Thiagarajan. An event structure semantics for general Petri nets.
Theoretical Computer Science, 153:129–170, 1996.
Ryszard Janicki and Maciej Koutny. Semantics of inhibitor nets. Information and Computation, 123:1– 16, 1995.
Joost-Pieter Katoen. Quantitative and Qualitative Extension of Event Structures. PhD thesis, Enschede: Centre for Telematics and Information Technology, P.O. Box 217 - 7500 AE Enschede - The Netherlands, 1996.
Rom Langerak. Transformations and Semantics for LOTOS. PhD thesis, Department of Computer Science, University of Twente, 1992.
Rom Langerak. Bundle event structures: A non-interleaving semantics for LOTOS. In M. Diaz and
R. Groz, editors, Formal Description Techniques, V, pages 331–346. Elsevier, 1993.
Robin Milner. Communication and Concurrency. International Series in Computer Science. Prentice Hall, 1989.
Ugo Montanari and Francesca Rossi. Contextual nets. Acta Informatica, 32:545–596, 1995.
Mayan Moudgill and Stamatis Vassiliadis. Precise interrupts. IEEE Micro, 16(1):58–67, 1996.
Mogens Nielsen, Gordon Plotkin, and Glynn Winskel. Petri nets, event structures and domains, part I.
Theoretical Computer Science, 13:85–108, 1981.
Jens Palsberg and Di Ma. A typed interrupt calculus. In W. Damm and E.-R. Olderog, editors, FTRTFT 2002, volume 2469 of LNCS, pages 291–310. Springer-Verlag, 2002.
G. Michele Pinna and Axel Poigne´.  On the nature of events: another perspective in concurrency.
Theoretical Computer Science, 138(2):425–454, 1995.
Wolfgang Reisig. Petri Nets: An Introduction. EATCS Monographs on Theoretical Computer Science. Springer-Verlag, 1985.
Wade Walker and Harvey G. Cragon. Interrupt processing in concurrent processors. Computer, 28(6):36– 46, 1995.
Glynn Winskel. An introduction to event structures. In de Bakker et al. [10], pages 364–397.
