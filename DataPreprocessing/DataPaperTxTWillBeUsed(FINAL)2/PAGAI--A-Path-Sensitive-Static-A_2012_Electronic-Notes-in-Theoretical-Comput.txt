Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 289 (2012) 15–25
www.elsevier.com/locate/entcs

PAGAI: A Path Sensitive Static Analyser
Julien Henry 1
Universit´e Joseph Fourier, VERIMAG Grenoble, France

David Monniaux1
CNRS, VERIMAG
Grenoble, France
Matthieu Moy1
Grenoble-INP, VERIMAG Grenoble, France



Abstract
We describe the design and the implementation of PAGAI, a new static analyzer working over the LLVM compiler infrastructure, which computes inductive invariants on the numerical variables of the analyzed program.
PAGAI implements various state-of-the-art algorithms combining abstract interpretation and decision proce- dures (SMT-solving), focusing on distinction of paths inside the control flow graph while avoiding systematic exponential enumerations. It is parametric in the abstract domain in use, the iteration algorithm, and the decision procedure.
We compared the time and precision of various combinations of analysis algorithms and abstract domains, with extensive experiments both on personal benchmarks and widely available GNU programs.
Keywords: Static Analysis, Program Verification, Abstract Interpretation, Decision Procedure, Satisfiability Modulo Theories.


Introduction
Sound static analysis automatically computes properties on programs, such as the possible values of their variables during execution. Applications include: show- ing that a program cannot encounter a runtime error (such as arithmetic overflow, division by zero, array access out of bounds), as in e.g. the Astr´ee analyzer [6]; computing invariants for use with assisted proof systems (such as the B method), thereby lessening the burden on the user; computing invariants for advanced opti- mization techniques in compilation (e.g. showing that two array cells are distinct, in order to allow instruction reordering between assignments to these cells). All these applications need invariants on numerical quantities.

1 Email: First Name.Last Name@imag.fr

1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.11.003

This article introduces PAGAI, a new tool for fully automatic static analy- sis. PAGAI takes as input a program in the “bitcode” intermediate representation of LLVM [12, 13], a modern compilation framework. LLVM bitcode is a target for several industrial-strengh compilers, most notably Clang (supporting C, C++, Objective-C and Objective-C++) and llvm-gcc (supporting, in addition to these, Fortran and Ada); furthermore, a growing number of analysis tools, testing tools, etc. are currently built around this platform (Calysto, KLEE, LAV, LLBMC).
The output of PAGAI is a list of inductive invariants for a selected subset of the control nodes of the original program: for structured source programs, PAGAI will provide an inductive invariant for the head of every loop.
PAGAI is based on abstract interpretation, a general framework for fully au- tomatic static analysis. PAGAI infers invariants of a selected form; by default it performs linear relation analysis, which obtains invariants as conjunctions of linear inequalities (or, equivalently, convex polyhedra), but it also supports other abstract domains through a runtime option. Depending on the iteration algorithm selected, PAGAI may also infer invariants as disjunctions of elements of the abstract domain (e.g. unions of convex polyhedra).
Textbook descriptions of abstract interpretation-based static analysis state that an inductive invariant is computed at every control point of the program. In con- trast, PAGAI abstracts straight-line sequences of statements en bloc, computing invariants only at points where control flow branches or merges. Furthermore, sev- eral algorithms implemented in PAGAI compute invariants only at the heads of loops (or, in general control-flow graph, at nodes forming a feedback vertex set, whose removal breaks all cycles in the graph), expanding the rest of the control flow to a possibly exponential number of straight-line sequences of statements between the selected nodes. In order to avoid explicit enumerations of exponential sets, PAGAI uses decision procedures for arithmetic theories, based on the satisfiability modulo theory (SMT) approach.
The PAGAI tool is dedicated to experimenting new analysis algorithms. It al- lows independent selection of abstract domain and iteration strategy, and partially independent selection of decision procedure, and thus is well-suited for comparisons. We thus conducted extensive experiments both on examples we produced ourselves (sometimes inspired by industrial code) and on GNU programs, for which the ability to run on any C or C++ code, through the LLVM system, was especially useful. Front-ends for many analysis tools put restrictions (e.g. no backward goto instruc- tions, no pointer arithmetic...), often satisfied by safety-critical embedded programs, but not by generic programs; our tool suffers no such restrictions, though it may in some cases apply coarse abstractions which may possibly yield weak invariants.
After illustrating the limitation of traditional abstract interpretation on an ex- ample in section 2, we will describe PAGAI’s implementation in section 3, and comment on the results of extensive experiments in section 4, allowing the compar- ison of state of the art techniques on real-life programs.

Motivating Example

In most forward abstract interpretation-based analyzes, when control flows from several nodes into a single node, the abstract value at that node is obtained by computing the least upper bound of the incoming abstract values in the abstract domain (in backward analysis, this occurs when control flows from a single node to several nodes). If the abstract domain is convex polyhedra, then this means computing the convex hull of the incoming polyhedra. Such an operation may induce unrecoverable loss of precision by introducing spurious states that cannot occur in concrete program runs.
An example of program where such a loss of precision occurs is depicted in Fig. 1. In this program, the loop body has two feasible paths that are executed alternatively, depending on a variable “phase”. Such programs, with active code paths depending on global “mode” or “phase” variables, often occur in reactive systems.
Removing program point n0 breaks all cycles; we are thus primarily concerned with obtaining an inductive invariant at that point. We consider the domain of convex polyhedra and thus wish to obtain this invariant as a polyhedron. Because convex polyhedra form a lattice of infinite height, we use Kleene iterations (pushing abstract values through control-flow edges) with a widening scheme, which ensures convergence in finite time to an inductive invariant, followed by decreasing (nar- rowing) iterations.
At program point n5, classical forward abstract interpretation with convex polyhedra computes the convex hull of three incoming polyhedra over variables (phase, x, t). This convex hull introduces extra states, unreachable in the concrete programs, for the analysis of the fragment from n5 to n9. When analyzing the whole loop, these extra states prevent proving x < 100.
To cope with this problem, a solution is compute disjunctive invariants at all intermediate nodes: at n5, keep an explicit list of three polyhedra, and thus obtain a list of nine polyhedra at n9. We pass the convex hull of these polyhedra to the widening operator at point n0 (which operates on polyhedra, not on lists of polyhedra). The drawback is that the number of elements in the lists may grow exponentially with the number of successive tests.
A second solution, equivalent to the preceding with respect to final results but different in its operation, is to distinguish all nine paths inside the loop (from n0 to n0), compute the final outcome of each path, and compute the convex hull of these outcomes. Again, the number of such paths is exponential in the number of tests. but we consider paths only if they will make the final convex hull grow. The next path to consider is obtained from a model of an arithmetic formula expressing this growth condition [15]; if this formula is unsatisfiable, this means there is no such path and thus the convex hull encompasses the outcome of all paths. The advantages of this method over the preceding one are twofold: there is no exponentially large list of abstract elements, and the satisfiability query for the formula is handed over to a satisfiability modulo theory (SMT) solver. Modern SMT-solvers are very efficient;

their caching mechanisms may, for instance, remember that taking a certain branch in the code is incompatible with taking another one (if a Boolean is associated with passing through each branch, then this is just a blocking clause inside the underlying SAT-solver). The algorithms implemented in PAGAI are variants of this second approach.



i n t  x = 0 ;
i n t  t = 0 ;
i n t  phase = 0 ;


while  ( t < 100 )  {
i f ( phase == 0 ) x = x + 2 ;
i f  ( phase == 1 )
x = x−1;
phase = 1−phase ; t ++;




phase → 1 − phase t →
t + 1

}
a s s e r t ( x <= 1 0 0 ) ;





Fig. 1. Example of program, where the loop behaviour vary depending on a variable phase.


Implementation
PAGAI is a prototype interprocedural static analyser, that implements our recent combined techniques [10] as well as the classical abstract interpretation algorithm, and the state-of-the-art techniques Path Focusing [15] and Guided Static Analysis [9].
Abstract domains are provided by the APRON library [11], and include convex polyhedra (from the builtin Polka “PK” library), octagons, and products of inter- vals. It also has an interface with the Parma Polyhedra Library [2], giving access to more abstract domains (e.g. a reduced product of polyhedra and linear congruences, producing invariants such as 0 ≤ x ≤ 1001 ∧ x ≡ 0 (mod 7)).
For SMT-solving, our analyzer uses Yices [8] or Microsoft Z3 [7] through their C API. An implementation of communications with the SMT-solver by textual messages sent through a pipe following the SMT-Lib 2 standard [3] is underway, and now partially supports Z3, MathSAT 5 and SMTinterpol. 2

2 It is unfortunately impossible to ignore differences between solvers behind the supposedly standard in-


Table 1
List of analyzed open-source projects, with their respective number of lines of code, and their number of control points in PR

Analysis algorithm
For each program, we distinguish a set PR = PW of suitable widening points by a simple algorithm: for each procedure, compute the strongly connected components of its control-flow graph using Tarjan’s algorithm; the targets of the back-edges of the depth-first search are added to PR. The resulting feedback vertex set is not necessarily minimal, but is sufficient to disconnect all cycles — more sophisticated techniques are discussed in e.g. Bourdoncle [5]. 3 It is however unclear whether more advanced selection techniques would finally yield stronger invariants; the current simple scheme has the advantage that, when run over a control-flow graph obtained from a structured program, it marks heads of loops, which is a “natural” choice.
LLVM bitcode is in static single assignment (SSA) form: a given scalar variable is given a value at a single syntactic point in the program. In concrete terms, an
assignment x=2*x+1; gets translated into a definition x2 = 2x1 + 1, with distinct variables x1 and x2 corresponding to the same original variable x at different points in the program. Because LLVM generally assigns rather straightforward names (e.g.
x.0 for the first renaming of variable x), the user can map the invariants back to the original source code; an automatic and more robust back-to-source mapping, based on debugging information, is being developed.
LLVM makes it easy to follow definition-use and use-definition chains: for a given variable (say, x2) one can immediately obtain its definition (say, 2x1 + 1). One may see conversion to SSA form as a static precomputation of some of the symbolic propagations proposed by Min´e [14] to enhance the precision of analyses. SSA introduces φ-functions at the head of a control code to define variables whose value depends on which incoming edge was last taken to reach this control node. For instance, for if	(...)  { x = 2*x+1; } else { x= 0; }, then x2 is defined
as φ(2x1 + 1, 0).
In this framework, each variable is uniquely defined as an arithmetic (+, −, ×, /) function of other variables that themselves may not be representable as arithmetic functions, because they are defined using φ-functions, loads from memory, return values from function calls, or other numerical operations (e.g. bitwise operators)

terface, since different solvers may support slightly different sets of operators and settings and may return models in different formats.
3 It would be possible to obtain a feedback vertex set minimal with respect to inclusion by successive removal of nodes; however obtaining one of minimal cardinality is a NP-complete problem.

that are not representable with our class of basic arithmetic operations. We may vary the class of arithmetic operations, for instance, by restricting ourselves to linear ones.
This motivates a key implement decision of our tool: only those variables v1, . . . , vn that are not defined by arithmetic operations are retained as coordinates in the abstract domain (e.g. as dimensions in polyhedra), assuming they are live at the associated control point.
For instance, assume that x, y, z are numerical variables of a program, x is defined as x = y + z, and x, y, z are live at point p. Instead of having x as a dimension for the abstract value at point p, we only have y and z. All the properties for x can be directly extracted from the abstract value attached to p and the relation x = y + z. This is an optimisation in the sense that there is redundant information in the abstract value if both x, y and z are dimensions of Xp. The classical definition of liveness can be adapted to our case:
Definition 3.1 [Liveness by linearity] A variable v is live by linearity at a control point p if and only if one of these conditions holds: (i) v is live in p. (ii) There is a variable v′, defined as a linear combination of other variables v1, v2, . . . , vn, so that
∃i ∈ {1, . . . , n}, v = vi, and v′ is live by linearity in p.
Finally, a variable is a dimension in the abstract domain if and only if it is live by linearity and it is not defined as a linear combination of program variables.
A basic block of code therefore amounts to a parallel assignment operation be- tween live-by-linearity variables (v1, . . . , vn) '→ (f1(v1, . . . , vn), , . . . , fn(v1, . . . , vn)); such operations are directly supported by APRON. This has three benefits: (i) it limits the number of dimensions in the abstract values, since polyhedra libraries typically perform worse with higher dimensions; 4 (ii) the abstract operation for a single path in path-focusing methods also is a (large) parallel assignment; (iii) as suggested by Min´e [14], this approach is more precise than running abstract operations for each program line separately: for instance, for y=x; z=x−y; with pre- condition x ∈ [0, 1], a line-by-line interval analysis obtains y ∈ [0, 1] and z ∈ [−1, 1] while our “en bloc” analysis symbolically simplifies z = x−x = 0 and thus z ∈ [0, 0]. In the event that a node is reachable only by a single control-flow edge (which may occur because of dead code, or during the first phases of guided static analysis), the φ operation reduces to a copy of the values flowing from that edge. In this case, our tool just propagates symbolic values through the predecessor node, without
introducing φ-variables.

Use
PAGAI takes as input an LLVM bitcode file, and outputs an inductive invariant for each control point in PR (typically, the widening points). When a program

4 The additional dimensions express linear equalities between variables, which are directly handled by polyhedra library. They should therefore cost little assuming some sparse representation of the constraints. Alas, several libraries, including APRON, compute with dense vectors and matrices, which means that any increase in dimensions slows computations.

contains an assert (...) function call, PAGAI also outputs whether the statement has been proved. It is also possible to add some preconditions about the vari- ables, etc, using a function assume(...). Both assert and assume are implemented as C macros. assert (x) is roughly defined as if (! x) assert fail (); , and the tool just tests for the reachability of assert fail (); : if it is unreachable, then the assertion is true. assume works with the same principle, and is defined as if (! x) assumption declared(). Both assert fail and assumption declared are noreturn functions, terminating the program immediately.
Current limitations of the tool, possible future works
Our tool currently only operates over scalar variables from the SSA representation and thus cannot directly cope with arrays or memory accessed through pointers. We therefore run it after the “memory to registers” (mem2reg) optimization phase in LLVM, which lifts most memory accesses to scalar variables. The remaining memory reads are treated as nondeterministic choices, and writes are ignored. This is a sound abstraction.
The analysis is currently intraprocedural: function calls are ignored in a sound way (the return value is a nondeterministic choice, the value of all variables escaping from the local scope is discarded...). In order to increase precision, we apply function inlining as an LLVM optimization phase. Plans for interprocedural analysis include computing input/output summaries for functions as elements of the abstract domain (e.g. if the function operates over variables x and y, then one could compute a polyhedron over (x, y, x′, y′) encompassing all input-output pairs) or as more general formulas.
Since it is often advantageous to distinguish whether a loop has been executed at least once, 5 we unroll every loop once, again with a LLVM optimization phase. Our tool currently assumes that integer variables are unbounded mathematical integers (Z) and floating-point variables are real (or rational) numbers. Techniques for sound analysis of bounded integers, including with wraparound, and of floating- point operations have been developed in e.g. the Astr´ee system [4, 6], but porting these techniques to our iteration schemes using SMT-solving requires supplemental work. It is unclear whether one should use bitvector arithmetic inside the SMT
formula, or use mathematical integers with explicit splits for wraparound. 6
Our implementation of path-focusing currently does not use true acceleration techniques, as proposed by Monniaux et Gonnord [15]. Instead, it simply runs widening and narrowing iterations on a single path.
We currently analyze each strongly connected component of the control-flow graph in topological order; thus each loop nest gets analyzed as a single fixed point. An alternative method would be to recursively decompose the strongly connected

5 Consider the very simple loop for( int i=0; i <n; i++) . The obvious loop invariant is 0 ≤ i ≤ n, but it is valid only if n > 0. One would thus need to use disjunctive loop invariants to obtain 0 ≤ i ≤ n ∨ (i = 0 ∧ n ≤ 0). It is much simpler to unroll the loop once.
6 E.g. an operation z = x + y over n-bit signed integers would appear as the disjunction of three statements z = x + y ∧ −2n−1 ≤ x + y < 2n−1, z = x + y + 2n ∧ −x + y < −2n−1, z = x + y − 2n ∧ x + y ≥ 2n−1: one “normal” control path and two “overflow” paths.


Table 2
Results of the comparison of the various techniques described in this paper: classic Abstract Interpretation (S), Guided Static Analysis (G), Path-focusing (PF), our combined technique (G+PF), and its version using disjunctive invariants (DIS). For instance, G/S compares the benefits of Guided Static Analysis over the classic Abstract interpretation algorithm. Ç (resp. ≥) gives the percentage of invariants stronger (more precise; smaller with respect to inclusion) with the left-side (resp. right-side) technique, and “uncomparable” gives the percentage of invariants that are uncomparable, i.e neither greater nor smaller; the code points where both invariants are equal make up the remaining percentage

components (for structured programs, this amounts to reconstructing the nested loop structure) and summarize the inner loops before analyzing the outer loop.
The analysis is currently only forward, even though nothing in the techniques implemented is specific to forward analysis. A possible extension would therefore be backward analysis from the assert fail () statements.

Experiments
We conducted extensive experiments on real-life programs in order to compare the different techniques, mostly on open-source projects (Tab. 1) written in C, C++ and Fortran.
Precision of the various techniques
For each program and each pair (T1, T2) of analysis techniques, we list the proportion of control points in PR where T1 (resp. T2) gives a strictly stronger invariant, denoted by Ç (resp. ≥), and the proportion of control points where the invariants given by T1 and T2 are uncomparable for the inclusion ordering (the remainder of the control points are thus those for which both techniques give the same invariant). We use convex polyhedra as the abstract domain.
Let us briefly comment the results given in more details in Table 2. Guided Static Analysis from Gopan et Reps [9] improves the result of the classical Abstract Interpretation in 2.21% of the control points in PR. Path-focusing from Monniaux et Gonnord [15] finds better invariants in 4.13% of the control points.
However, these two techniques also lose precision in an important number (4.64% for G, 5.14% for PF) of control points, and obtain worse results than the classical many times. This result is unexpected, and could be partially explained by bad behaviour of the widening operator.
Finally, our combined technique gives the most promising results, since it is statistically more precise than the other techniques. It improves the precision of the inductive invariant in 8.29% to 9.86% of the control points compared to the three previous techniques. Still, we obtain worse result in a non-negligible number


Table 3
Execution time for each technique, expressed in seconds

of cases (2.02%).
The analysis using disjunctive invariants greatly improves the precision of the analysis (for 14.46% of the control points in PR compared to G+PF), at the expense of a higher time cost (see Table 3). It also gives worse results in 6.85% of the points, most probably because of a non optimal choice of the σ function, detailed in [10].
While experimenting with techniques that use SMT-solving, we encountered some limitations due to non-linear arithmetic in the analyzed programs. Indeed, the SMT-solver is not able to decide the satisfiability of some SMT-formulae expressing the semantics of non-linear programs. In this case, we skipped the functions for which the SMT-solver returned the “unknown” result. This limitation occurred very rarely in our experiments, except for the analysis of Lapack/Blas, where 798 over the 1602 functions have been skipped. Lapack/Blas implements matrix computations, which use floating-point multiplications. In cases where the formula is expressed in too rich a logic for the SMT-solver to deal with, a number of workarounds are possible, including: (i) Linearization, as per Min´e [14], which overapproximates nonlinear semantics by linear semantics. (ii) Replacing the results of nonlinear operations by “unknown”. Neither is currently implemented in our tool.
Table 3 gives the execution time of the different analysis techniques. It is in- teresting to see that Path-focusing is sometimes faster than the classical algorithm. This seems due to the fact that this algorithm computes inductive invariant on a small number of control points compared to classical approaches, thus leading to fewer operations over abstract values.

Precision of Abstract Domains
For each program and each pair (D1, D2) of abstract domains, we compare by inclusion the invariants of the different control points in PR = PW (Tab. 4).
Statistically, the domain of convex polyhedra gives the better results, but com- monly yields weaker invariants than the domains of octagons/intervals; this is a known weakness of its widening operator [16]. The Octagon domain appears to be much better than intervals; this is unsurprising since in most programs and libraries, bounds on loop indices are non constant: they depend on some parameters (array sizes etc.).
The Lapack/Blas benchmarks are unusual compared to the other programs. These libraries perform matrix computations, using nested loops over indices; such


Table 4
Results of the comparison of the various abstract domains, when using the same technique (G+PF). We used as abstract domains Convex Polyhedra (PK and POLY), Octagons (OCT), intervals (BOX), linear equalities (PKEQ) and the reduced product of NewPolka convex polyhedra with linear congruences from the Parma Polyhedra Library [2]. (PKGRID). The last column compares the domain of Convex Polyhedra with the improved widening operator from Bagnara et al. [1] (POLY*), and Convex Polyhedra using the
classical widening operator (POLY). POLY and POLY* use the PPL[2]. Ç, ≥ and “unc.” are defined as in Tab. 2.

programs are the prime target for polyhedral loop optimization techniques and it is therefore unsurprising that polyhedra and octagons perform very well over them.
The analysis of linear equalities (PKEQ) performs very fast compared to other abstract domains, but yields very imprecise invariants: it only detects relations of
the form Σ aixi = C where ai and C are constants.
Using the reduced product of convex prolyhedra with linear congruences
(PKGRID) improves the analysis by 2.52%.
Finally, we evaluated the benefits of the improved version of the widening opera- tor for convex polyhedra from Bagnara et al. [1], compared to the classical widening. We found that the improved version from Bagnara et al. [1] yields more precise in- variants for 3.70% of the control points in PR.

Future Work
It is not totally relevant to compare by inclusion the abstract values obtained by the various analysis techniques. Indeed, a slightly smaller invariant may not always be useful to prove the desired properties. Future work should thus include experiments with better comparison metrics, such as (i) the number of assert that have been proved in the code. Unfortunately, it is difficult to find good benchmarks or real life programs with many assert statements; (ii) the number of false alarms in a client analysis that detects array bound violations, arithmetic overflows, etc.

References
R. Bagnara, P. M. Hill, E. Ricci, and E. Zaffanella. Precise widening operators for convex polyhedra. Science of Computer Programming, 58(1–2):28–56, Oct. 2005.
R. Bagnara, P. M. Hill, and E. Zaffanella. The Parma Polyhedra Library: To- ward a complete set of numerical abstractions for the analysis and verification of hardware and software systems. Science of Computer Programming, 72(1–2): 3–21, 2008.

C. Barrett, A. Stump, and C. Tinelli. The SMT-LIB Standard: Version 2.0. In SMT, 2010.
B. Blanchet, P. Cousot, R. Cousot, J. Feret, L. Mauborgne, A. Min´e, D. Mon- niaux, and X. Rival. A static analyzer for large safety-critical software. In Programming Language Design and Implementation (PLDI), pages 196–207. ACM, 2003.
F. Bourdoncle.	S´emantiques des Langages Imp´eratifs d’Ordre Sup´erieur

et Interpr´etation Abstraite.	PhD thesis,
http://tinyurl.com/BourdonclePhD-pdf.
E´cole Polytechnique,	1992.

P. Cousot, R. Cousot, J. Feret, L. Mauborgne, A. Min´e, D. Monniaux, and
X. Rival. The ASTRE´E analyzer. In Programming Languages and Systems
(ESOP), number 3444 in LNCS, pages 21–30. Springer, 2005.
L. M. de Moura and N. Bjørner. Z3: An efficient SMT solver. In TACAS, volume 4963 of LNCS, pages 337–340. Springer, 2008.
B. Dutertre and L. M. de Moura. A fast linear-arithmetic solver for DPLL(T). In CAV, volume 4144 of LNCS, pages 81–94. Springer, 2006.
D. Gopan and T. W. Reps. Guided static analysis. In SAS, volume 4634 of
LNCS, pages 349–365. Springer, 2007.
J. Henry, D. Monniaux, and M. Moy. Succinct representations for abstract interpretation. In Static analysis (SAS), LNCS, 2012.
B. Jeannet and A. Min´e. Apron: A library of numerical abstract domains for static analysis. In CAV, volume 5643 of LNCS, pages 661–667. Springer, 2009.
C. Lattner and V. Adve. LLVM: A compilation framework for lifelong program analysis & transformation. In CGO, pages 75–86, Washington, DC, USA, Aug. 2004. IEEE Computer Society.
LLVM  Language  Reference  Manual.	LLVM  team,   2012.
http://llvm.org/docs/LangRef.html.
A. Min´e. Symbolic methods to enhance the precision of numerical abstract domains. In VMCAI, volume 3855 of LNCS, pages 348–363. Springer, 2006.
D. Monniaux and L. Gonnord. Using bounded model checking to focus fixpoint iterations. In Static analysis (SAS), volume 6887 of LNCS, pages 369–385. Springer, 2011.
D. Monniaux and J. Le Guen. Stratified static analysis based on variable dependencies, 2011. http://arxiv.org/abs/1109.2405.
