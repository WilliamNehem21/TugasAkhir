Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 305 (2014) 123–139
www.elsevier.com/locate/entcs
On a Graph Approach to Modal Logics
Paulo A. S. Veloso a,2 Sheila R. M. Veloso b,3
Mario R. F. Benevides a,4
a Computing and System Enginneering Progr., COPPE, Federal University of Rio de Janeiro
Rio de Janeiro, Brazil
b Computing and System Enginneering Dept, Engin. Fac.
State University of Rio de Janeiro Rio de Janeiro, Brazil

Abstract
We introduce a sound and complete graph calculus for multi-modal logics. This formalism internalizes the (Kripke) semantics of modal logics and provides uniform tools for expressing and manipulating modal formulas. We present the graph calculus for logic K and show how to extend it to handle some modalities, like the global and difference modalities, in a natural manner. We also indicate how it can be easily extended to other normal modal logics, such as T, S4, S5, etc.
Keywords: Modal logics, graph calculus, Kripke semantics, special modalities, refutation.


Introduction
We present a graph approach to multi-modal logics yielding sound and complete calculi. Such formalisms internalize the (Kripke) semantics of modal logics and pro- vides uniform tools for expressing and manipulating modal formulas. Our derivation rules mimic the semantical properties of the modal operators, so their application is quite intuitive.
Using drawings for relations is a natural idea: represent the fact that a is related
to b via relation r by an arrow a  r  b. Then, one can reason about relations by
manipulating their representations. This is a key idea underlying graph methods for reasoning about relations [3,4,5,6]. Graph representations and manipulations,

1 Research partly sponsored by the Brazilian agencies CNPq and FAPERJ
2 Email: pasveloso@gmail.com
3 Email: sheila.murgel.bridge@gmail.com
4 Email: mario@cos.ufrj.br

http://dx.doi.org/10.1016/j.entcs.2014.06.009
1571-0661/© 2014 Elsevier B.V. All rights reserved.

having precise syntax and semantics, are proof methods. In our graph calculi the derivations are very similar to the reasoning on modalities on the semantical level.
Modal logics and graphs are closely related. Kripke semantics is often presented by means of labeled graphs for the accessibility relation associated to each modality. Now, our approach here is as follows. 5 We associate a graphical representation to a modal formula and convert it to a graph, which will have empty extension if the formula is unsatisfiable, otherwise one can read a model from it (as much as in tableaux) [8].
The structure of this paper is as follows. Section 2 introduces and illustrates the main ideas underlying our graph approach to modal logics. Section 3 presents our graph language for modal logics: syntax, semantics and some constructions. Section 4 introduces our graph calculus for modal logics, with its conversion and expansion rules, discussing its correctness. In Section 5 we indicate some extensions of our graph calculus to handle some special modalities (like the global one and difference) as well as some modalities with properties like reflexivity, symmetry, transitivity and determinism. Section 6 presents some concluding remarks.

Graph Approach to Modalities: main ideas
We now introduce the main ideas of our graph approach to modal logics.
An interesting feature of the graph approach is its 2-dimensional notation pro- viding pictorial representations that support manipulations. We now examine and illustrate these ideas (see Sections 3 and 4 for more details).
A graph is a finite set of (alternative) slices. A slice consists of a draft together with a distinguished node. A draft consists of finite sets of nodes and arcs.
Arcs may be binary or unary. A binary arc stands for accessibility among states; we represent that node v is accessible from node u by the relation of α by a solid
arrow labelled α from u to v: u α v. A unary arc is meant to capture the fact that
a formula holds at state; we represent that formula ϕ holds at nodew bya dashed line from w to ϕ: w    ϕ . Thus, one may regard a set of arcs as a description of a model (see Examples 2.2 and 2.3).
We also mark the current state; we distinguish the current node: xˆ. We will also have rules for manipulating these representations.
(∧) We can eliminate conjunction by splitting a dashed line into two, as follows:
ψ ∧_ θ


(∧)
w	D	w
(⟨α⟩) We can eliminate modality ⟨α⟩, by adding a new node, via the conversion:

5 Graphs will be defined in the paper: the extension of a graph will be a set.

⟨α⟩ϕ	ϕ_


(⟨α⟩)
u	D	u
  α /v ¸

The above drawings are graphical representations of drafts.
We now illustrate how we can establish consequence by means of drawings.
Example 2.1 We wish to show that ⟨α⟩p follows from ⟨α⟩(p∧q). We can represent the formulas ⟨α⟩p and ⟨α⟩(p ∧ q) by slices T and S, respectively as follows:
⟨α⟩p	⟨α⟩(p ∧ q)
_	_

xˆ	ˆz
We can convert slice T (of formula ⟨α⟩p) to slice Tj as follows:
⟨α⟩p	p_


(⟨α⟩)
xˆ	D
xˆ  α /w¸

We can convert slice S (of ⟨α⟩(p ∧ q)) to slice Sj as follows:
⟨α⟩(p_ ∧ q)	p ∧_ q


(⟨α⟩)
ˆz	D	ˆz
	α	/v ¸
(Λ)
D

Now, let us compare the resulting slices Sj and Tj, namely:
,q	p_

xˆ  α /w¸
We see that we can find within slice Sj a copy of slice Tj. The node mapping x '→ z, w '→ v preserves unary and binary arcs as well as distinguished nodes: it gives a homomorphism from Tj to Sj (see 3.2). So, any state satisfying formula
⟨α⟩(p ∧ q) will also satisfy formula ⟨α⟩p.
This example illustrates a graph approach to consequence. Given formulas ψ and θ, we represent them by single-node slices S and T and transform these slices to Sj and Tj. If we have a homomorphism from Tj to Sj, then ψ |= θ.
We now illustrate some other features of this approach.
Example 2.2 Consider the formulas p and ⟨α⟩p.
We do not expect ⟨α⟩p to follow from p in general. The single-node slices S
and T (for p and ⟨α⟩p) convert to slices Sj and Tj, respectively as follows:
p_	p_

yˆ	xˆ  α /w¸

We cannot find a homomorphism from Tj to Sj. Now, from slice Sj we can read the following natural model: M = {y}, αM = ∅ and V(p) = {y}. In this model M, state y satisfies p (as y ∈ V(p)), but not ⟨α⟩p (as αM = ∅).
Now, we expect ⟨α⟩p to follow from p if the relation corresponding to α is re- flexive. In this case, every node is α-reachable from itself. So, we can transform the above slices Sj and Tj to Srf and Trf respectively as follows:
p_	p_

z	α	zxˆ  α /w¸,7α
Now, the node mapping x, w '→ y gives a homomorphism from Trf to Srf.
Example 2.3 The situation with ⟨α⟩p and ⟨α⟩⟨α⟩p is similar to Example 2.2.
We do not expect ⟨α⟩p to follow from ⟨α⟩⟨α⟩p in general. Converting the slices for ⟨α⟩⟨α⟩p and ⟨α⟩p, we obtain the following slices S and T:
,p	p_


ˆz
xˆ  α /w¸

Again, we cannot find a homomorphism from T to S and, from slice S, we can read a natural model: M = {z, u, v}, αM = {(z, u), (u, v)} and V(p) = {v}. In this model M, state z satisfies ⟨α⟩⟨α⟩p, but not ⟨α⟩p (as u /∈ V(p)).
Now, we expect ⟨α⟩p to follow from ⟨α⟩⟨α⟩p if the relation corresponding to α is transitive. In this case, the above slices S and T will transform to slices Str and Ttr, respectively as follows:

 u ,
α	α
ˆz 	α	/v¸z
,p	p_

  α /¸

Now, the mapping x '→ z, w '→ v gives a homomorphism from Ttr to Str.
Examples 2.2 and 2.3 indicate how one can handle some properties of a relation. One can similarly handle some special relations, like the square relation ∞. As this relation connects any two states, it imposes no restriction.
(∞) We can eliminate the square relation ∞ by the following conversion:

u  ∞ /v ¸
(∞)
D	u	v

Example 2.4 Given the formulas p and ⟨∞⟩p, we wish to show p |= ⟨∞⟩p.
The single-node slice S for p converts to slice Sj in Example 2.2.
The single-node T for ⟨∞⟩p converts to slice T∞ as follows:
⟨∞⟩p	p_	p_


(⟨∞⟩)
xˆ	D
xˆ  ∞ /w¸
(∞)
D	xˆ	w

Now, the node mapping x, w '→ y gives a homomorphism from T∞ to Sj.
We can see that ⟨∞⟩ behaves as the global modality E [2] (see also 5.1). We now examine the representation for negation.
The extension of a formula is the set of states satisfying it. So, the extension of the negated formula ¬ϕ is the complement of the extension of the formula ϕ. Thus, negation can be represented by an overbar (for complement).
We thus have a larger syntactical category representing sets of states: the ex- pressions, encompassing formulas, slices, graphs and their complements. So, if a formula ϕ converts to a slice S, then ¬ϕ converts to S, where we can enclose the slice within a box for better readability.
We can represent formulas ⟨α⟩¬ϕ and ¬⟨α⟩ϕ respectively by the slices:
,ϕ
xˆ 	α	/v ¸

Thus, we can represent [α]ϕ by its equivalent ¬⟨α⟩¬ϕ, i. e. by the slice:

Also, we can use expressions as labels for unary arcs. Expressions provide more flexible representations for formulas. For instance, we can represent formula p by the slice ˆz    p . So, we can represent formula ¬p by the expression E = ˆz    p or by a slice like
uˆ





In the above slice representation of the formula ¬p, we have a negative arc: the arc having under complement the following slice T:

We can now establish that some formulas are not satisfiable in our approach.
Example 2.5 Consider the formula ⟨α⟩(p ∧ ¬p). Its slice converts to slice S:

,p

xˆ 	α	/u¸







This slice S has a conflicting situation. For, on node u, we have two contradictory unary arcs: a positive arc (labelled p) and a negative arc (corresponding to p). Indeed, within slice S we find under complement the above slice T. Now, consider the underlying drafts: T of T and S of S. By mapping z to u, we can map draft T into draft S, as follows:
,p

T	z
, p

S	x	α	/u¸

The preceding example also indicates how our graph approach handles the ne- cessitation rule. It shows that formula ⟨α⟩(p ∧ ¬p) is unsatisfiable because so is formula p ∧ ¬p. In other words, since formula ¬(p ∧ ¬p) is valid, so is formula
¬⟨α⟩(p ∧ ¬p), which is equivalent to [α]¬(p ∧ ¬p).
In general, our graph approach to refutation is as follows. Given a formula ϕ, we represent it by a single-node slice S and transform it to Sj. If we can find a conflicting situation within Sj (see 3.2), then ϕ |= ⊥.
We will be able to convert every modal formula to a graph (see Proposition 4.2: Conversion to basic graph). Consider, however, the following two slices Sj and Sjj:



xˆ
 u , p
 u , p
xˆ	γ

z 	ze t  
v	q	v	q

⎛ ⟨α⟩p ⎞
Slice Sj corresponds to the modal formula ⎜ ∧ ⎟, but one does not have a modal
⎝ ⟨β⟩q ⎠
formula corresponding to slice Sjj. So, slices (and graphs) will turn out to be more expressive than modal formulas.
Graph Language for Modalities
We now present our graph language for modal logics: first its syntax and semantics (in 3.1), and then some concepts and constructions (in 3.2).
Modal Graph Syntax and Semantics
We now present syntax and semantics of our graph language for modal logics.
We will consider a modal language L with set Ψ of formulas involving proposi- tional letters from a set PS and modalities ⟨α⟩ for α ∈ Ξ. The corresponding graph language will also have a denumerably infinite set INd of (state) nodes (we will use x and y for the first 2 nodes).
We introduce the syntax of our graph concepts by mutual recursion.
(E) The expressions are the formulas in Ψ, the slices and the graphs (see below), as well as E, for an expression E.
(a) An arc over a set N ⊆ INd can be either unary or binary.
A unary arc is a pair w|E, where w ∈ N and E is an expression.
A binary arc is a triple u α v, where u, v ∈ N and α ∈ Ξ.
(Σ) A sketch Σ= ⟨N; A⟩ consists of 2 sets: a set N ⊆ INd (of nodes) and a set A of arcs over N. A proper sketch is one with non-empty set of nodes.
(D) A draft is a sketch with finite sets N of nodes and A of arcs.
(S) A slice S = ⟨N; A : zS⟩ consists of a draft S = ⟨N; A⟩, its underlying draft, together with a distinguished node zS ∈ N.
(G) A graph is a finite set of slices.
The empty graph {} has no slice. Slices and graphs are finite objects, whereas sketches are useful in some contexts (see 3.2 and 4.3) The slice of expression E is the single-node single-arc slice Sl(E) := ⟨{x}; {x|E} : x⟩ (where x is the first node in INd). For instance, Example 2.1 shows Sl(⟨α⟩p) = ⟨{x}; {x|⟨α⟩p} : x⟩.
We now examine the semantics of our graph language. We will use models for semantics: a model consists of an underlying frame and a valuation [2]. A frame F = (M, (αF)α∈Ξ) assigns to each α ∈ Ξ a binary relation αF on M /= ∅. A valuation V assigns to each propositional letter p ∈ PS a subset V(p) of M .
We now introduce the semantics of our graph concepts (again by mutual recur- sion). Consider a model M = (M, (αF)α∈Ξ, V) as above.
(E) The extension of expression E is the subset [E]M ⊆ M defined as follows. For a

formula ϕ ∈ Ψ, [ϕ]M := {s ∈ M / M,s H ϕ}. For a slice or a graph, we use their extensions: [S]M := [[S]]M and [G]M := [[G]]M (as defined below). For E, we set [E]M as the complement of [E]M, i. e. [E]M := M \ [E]M.
(a) For an arc a, we define satisfaction under g : N → M (g HM a) as follows.
For a unary arc: g HM w|E iff w ∈ N and wg ∈ [E]M.
For a binary arc: g HM u α v iff u, v ∈ N and (ug, vg) ∈ αF.
(Σ) Assignment g : N → M satisﬁes sketch Σ = ⟨N; A⟩ in M (noted g :Σ → M) iff
g satisfies all its arcs, i.e. g HM a, for every arc a ∈ A.
(S) The extension of a slice S = ⟨S : zS⟩ is the subset of M consisting of the values of its distinguished node zS for the assignments satisfying its underlying draft S: [[S]]M := {zSg ∈ M / g : S → M}.
(G) The extension of a graph G is the union of the extensions of its slices, i. e. [[G]]M :=  S∈G [[S]]M.
Expressions E and F are equivalent (noted E ≡ F) iff [E]M = [F]M, for every model M. An expression E and its slice Sl(E) are equivalent. Also, a slice S and a singleton graph {S} are equivalent, so one may identify them. An expression E is null iff E ≡ ⊥. Clearly, the empty graph { }, having no slice, is null.
We will give a calculus for establishing that an expression is null in Section 4.
Modal Graph Concepts and Constructions
We will now examine some graph concepts and constructions.
We begin with the idea of natural model illustrated in Examples 2.2 and 2.3. Consider a proper sketch Σ = ⟨N; A⟩. Its natural frame is F[Σ] := (N, (αF[Σ])α∈Ξ)
with αF[Σ] := {(u, v) ∈ N × N / u α v ∈ A}. Now, the natural valuation for Σ has
VΣ(p) := {w ∈ N / w|p ∈ A}. The natural model for Σ is N[Σ] := (F[Σ], VΣ).
We use the notation ‘+’ for adding nodes or arcs. Consider a sketch Σ = ⟨N; A⟩ and a slice S = ⟨S : zS⟩. For a node w ∈ INd, we set Σ + w := ⟨N ∪ {w}; A}⟩ and S + w := ⟨S + w :: zS⟩. For arcs, we set Σ + E|w := ⟨N ∪ {w}; A ∪ {E|w}⟩ and Σ + u α v := ⟨N ∪ {u, v}; A ∪ {u α v}⟩; then S + a := ⟨S + a : zS⟩.
We extend a node translation ν : N → INd naturally to arcs over N as follows: for a unary arc a = w|E, we set aν := wν|E, and for a binary arc a = u α v, we set aν := uν α vν. We also extend it naturally to sets of nodes and of arcs, sketches and slices as follows: N ν := {wν / w ∈ N} and Aν := {aν / a ∈ A}, for a sketch Σ= ⟨N; A⟩, Σν := ⟨Nν; Aν⟩ and, for a slice S = ⟨S : zS⟩, Sν := ⟨Sν : zSν⟩.
A useful node translation is renaming. Given node pair (u, v) ∈ INd2, we define
rename u to v as follows:
w[u/v] := ⎧⎨ v	if w = u
⎩ w	if w /=u 
We now introduce morphisms for comparing sketches.
Consider sketches Δ = ⟨NΔ; AΔ⟩ and Σ := ⟨NΣ; AΣ⟩. A node translation function
μ : NΔ → NΣ is a morphism from Δ to Σ (noted μ :Δ −−· Σ) iff it preserves arcs:

for every arc a ∈ AΔ, aμ is an arc in AΣ.
For the slices S and T of Example 2.5 (in Section 2), z '→ u gives a morphism
θ : T −−· S. Another example is as follows:
p_	q_	_r	_t
β

Δ:	uj 	α	/wj¸
z_jj  γ	/j¸





 w,
α	γ
μ
r

z  J	/¸

Σ:	x
αj	u
˛v	j	y
βj

q_	p_	er
_	_s

A morphism transfers satisfying assignments by composition.
Lemma 1 (Assignment transfer) Given a morphism μ : Δ −−· Σ and a model M, for each assignment g satisfying Σ in M, the composite g · μ is an assignment satisfying Δ in M.
Proof. For any arc a of Δ, aμ is an arc of Σ, so that, for every g satisfying aμ in a model M, g · μ is an assignment satisfying a in M.	 
A sketch Σ is zero iff, for some slice T = ⟨T : zT⟩, there exists a morphism μ : T −−· Σ, such that zTμ|T is an arc of Σ. A slice S is zero iff its underlying draft S is zero. A graph is zero iff all its slices are zero.
For instance, slice S of Example 2.5 is zero.
Lemma 2 (Zero sketches) No assignment can satisfy a zero sketch.
Proof. By Lemma 1. If g : Σ → M, then we have a contradiction: zTg·μ /∈ [T]M (as zTμ|T ∈ AΣ) and zTg·μ ∈ [[T]]M (as g · μ : T → M).	 
Corollary 1 (Zero slices and graphs) Zero slices and graphs are null.
Proof. By Lemma 2: if [H]]M /= ∅, then [T]]M /= ∅, for some slice T ∈ H, thus some
M -assignment satisfies the underlying draft T.	 
We can also introduce homomorphisms for comparing slices as follows. Given slices T = ⟨NT; AT : zT⟩ and S = ⟨NS; AS : zS⟩,a homomorphism η : T → S is a node translation η : NT → NS such that η : T −−· S and η preserves distinguished nodes: η(zT) = zS. For a homomorphism η : T → S and a model M: [S]]M ⊆ [[T]]M (by Lemma 1). Also, node renaming is a homomorphism from S to S[u/v].
We now wish to glue a slice T onto a sketch Σ (or slice S) via a designated node w ∈ INd. We do this by identifying the distinguished node of T with the designated

node w, to obtain a sketch ΣwT and a slice SwT with the following aspects:
w= zT	w= zT
The next example illustrates these ideas.
Example 3.1 (Gluing) Consider slices S and T respectively as follows:

,p
xˆ 	α	/u ¸
,q	,r
β	/v ¸
¸p
ˆz 	α	/w¸
,q
γ	/y ¸

The glued draft SvT and slice SuT are respectively as follows:

,p
x 	α	/u ¸
,q	,r
β	/v ¸
,p
xˆ 	α	/u ¸
¸q	¸r
β	/v ¸

q 	 w  sα	cp
z
y
q 	 w  sα	 p
z
y

More precisely, consider a slice T = ⟨N; A : z⟩ and a node w ∈ INd.
(Σ) Given a sketch Σ = ⟨NΣ; AΣ⟩, to glue T onto sketch Σ, we proceed as follows.
Add node w to Σ, obtaining sketch Σ0 := Σ + w (with N0 = NΣ ∪ {w}).
Take a copy T1 = ⟨N1; A1 : z1⟩ of slice T with N1 ∩ N0 = ∅.
Now, rename z1 to w in slice T1 to obtain slice T2 := T1[z1/w] (with sets
N2 = N1[z1/w] and A2 = A1[z1/w]).
Then, form the glued sketch ΣwT := ⟨N0 ∪ N2; AΣ ∪ A2⟩.
(S) Given a slice S = ⟨S : zS⟩, we glue slice T onto S, by gluing T onto the underlying draft S and using the distinguished node: the glued slice is SwT := ⟨SwT : zS⟩.
Lemma 3 (Arc addition and gluing) For slices S and T: S + w|T ≡ SwT.
Proof. By construction (we can combine satisfying assignments).	 
Graph Calculus for Modalities
We now introduce our graph calculus for modal logics. We will first introduce basic objects and then the rules, conversion (in 4.1) and expansion (in 4.2), and examine correctness (soundness and completeness) of the calculus in 4.3.
To establish that an expression is null, we convert it to a graph (by conversion rules) and then try to obtain a zero graph by repeatedly applying the expansion rule (see Example 4.3 in 4.2). Each rule will transform an expression to an equivalent one, so we can use it in any context. As usual, we employ ‘−∗’ for the reflexive- transitive closure of a relation.
We define basic expressions, arcs, sketches, slices and graphs by mutual recur- sion. An expression E is basic iff it is a propositional letter or T, where T is a basic slice (see below). An unary arc E|w is basic iff E is a basic expression and a binary

arc u α v is basic. A sketch is basic iff all its arcs are basic. A slice S is basic iff its underlying draft S is a basic sketch. A graph is basic iff all its slices are basic.
In Example 2.1, slices Sj and Tj are basic, whereas slices S and T are not basic.

Modal Graph Conversion
We now examine conversion in our calculus. The aim of the conversion rules is to transform each expression to an equivalent basic graph.
The conversion rules come from equivalences between expressions. They will be of three kinds: formula rules, complementation rules and structural rules. 6
The formula rules eliminate logical symbols by converting an expression to an
(ч)
equivalent expression. For ¬: ¬ϕ  D ϕ, and the rules for ∧ and ⟨α⟩ give the
conversions (cf. Section 2 (Graph Approach to Modalities: main ideas)):
¸ϕ


ψ ∧ θ
(Λ)
D	xˆ
(⟨α⟩)
⟨α⟩ϕ	D
xˆ  α /y ¸

The rule for ⊥ replaces it by the empty graph. The rule for ∨ replaces ψ ∨ θ by the graph with the following 2 slices:
,ψ	,θ
	
xˆ	xˆ
By applying these formula rules in any context, one can eliminate connectives
and modalities. We may still have complement as well as slices or graphs and their complements may appear in arcs. The remaining 5 rules will address these cases.
 ()
We have 2 complementation rules: one erases double complement (E D E) and
rule (H) converts a complemented graph to a single-node slice, e. g. {T1, T2} to the single-node slice:

,T2
xˆ
The 3 structural rules eliminate graphs and slices occurring as arc labels and introduce slice of expression.
(→) Addition of a graph-arc converts to alternative additions of its slice-arcs, in view of the equivalence S + w|H ≡ {S + w|T / T ∈ H}. For instance, for {T1, T2}:



S + w
{T1, T2}
,

∪
(→)
D
⎧⎪
S + w
⎪⎩
,T1

,


S + w
,T2 ⎫
⎪⎪⎬

⎪⎭




6 Recall that x and y are the first 2 nodes (cf. 3.1).


(→) Addition of a slice-arc converts to the glued slice: S + w|T
(†E)

T
(→)
D SwT. 7

(† E) An expression converts to its slice: E  D  Sl(E) (cf. 3.1). So, we can replace a
complemented propositional letter p by the basic expression
We can convert expressions modularly as the next example illustrates.
Example 4.1 Let ϕ be the formula ⟨α⟩T Λ ч⟨α⟩⟨β⟩T Λ ч⟨α⟩ч⟨β⟩T, with T := ч⊥.

Formula ⟨α⟩T converts to the slice
xˆ  α /y .¸

Formula ⟨α⟩⟨β⟩T converts to the slice Tj :=
xˆ  α /y ¸β /z .¸

Formula ⟨α⟩ч⟨β⟩T converts to the following slice Tjj:
xˆ 	α	/u¸







So, formula ⟨α⟩T Λ ч⟨α⟩⟨β⟩T Λ ч⟨α⟩ч⟨β⟩T converts to the following slice S:

,Tj


Proposition 4.2 (Conversion to basic graph) Every expression E can be ef- fectively converted to an equivalent basic graph Ebs.

Modal Graph Expansion
We now examine graph expansion and its rule in our calculus for modal logics.
The next example introduces expansion and its usefulness.
Example 4.3 (Expansion) Recall the slice S in Example 4.1. This slice S is not yet zero. Consider, however, the following slice T:
yˆ  β	/z ¸

7 Cf. Lemma 3 (Arc addition and gluing) in 3.2: Modal Graph Concepts and Constructions.

We can use this slice T to expand slice S to a graph G consisting of 2 alternative slices S+ = SyT and S— = S + y|T, respectively as follows:



,Tj
xˆ 	α /y ¸ β	/z ¸


,Tj



Both slices S+ and S— can be seen to be zero, so slice S is null (cf. 3.1).
We thus have (cf. Example 4.1) ⟨α⟩T Λ ч⟨α⟩⟨β⟩T Λ ч⟨α⟩ч⟨β⟩T |= ⊥, whence
⟨α⟩T Λ [α]⟨β⟩T |= ⟨α⟩⟨β⟩T.
We can expand a slice S on a node w under a slice T, giving 2 alternative slices SwT and S + w|T, which will be basic if both S and T are basic. Note that S ≡ { SwT , S + w|T }. The expansion rule is as follows:

(Exp) G ∪ { S }   G ∪ { SwT , S + w|T }	w ∈ NS	expand slice S
Modal Graph Calculus Correctness
We now examine the correctness of our graph calculus for modal logics.
A derivation is a sequence of applications of conversion and expansion rules:
▶:= (D ∪  )∗. In Example 4.3 we have the derivation ϕ D٨ {S}  {S+, S—}. Call a derivation smooth iff applications of conversion rules precede applications of expansion. 8 An expression is derivably zero iff it derives some zero graph and expansively zero iff it eventually expands to some zero graph.
We have soundness and completeness of (smooth) derivations.
Proposition 4.4 Soundness: every derivably zero expression is null. Complete- ness: if a basic graph H is null, then H is expansively zero.
Soundness is not difficult to see. We now indicate how one can establish com- pleteness. The idea is saturating a slice by applications of the expansion rule. 9 Consider a basic slice S that is not expansively zero. Then, for every w ∈ NS and basic slice T, SwT or S + w|T is not expansively zero. Thus, we can then obtain a chain of non-zero basic slices whose union is a basic sketch Σ. Now, this sketch Σ discriminates basic drafts: satisfying assignments into the natural model N[Σ] are morphisms into Σ. 10 Hence, in N[Σ], slice S has non-empty extension.
We thus have a correct calculus for null expressions.
Theorem 4.5 (Correctness) An expression E is null iff E is derivably zero, i. e. its basic form Ebs is expansively zero.
Proof. By Propositions 4.2 (Conversion to basic graph) and 4.4.	 

8 The preceding examples use smooth derivations: of the form E Qs G Q∗ H.
9 One may regard this as an analogue of Lindenbaum’s Lemma: extending a consistent theory to a maxi- mally consistent one.
10 For every basic draft D, g : D → N[Σ] iff g : D −−· Σ (see 5.3).

Graph Calculus for Modalities: some extensions
We now indicate some extensions of our graph calculus. We will examine some special modalities (in 5.1) and some modalities with special properties (in 5.2).
In Section 4, we have presented a sound and complete graph calculus for valid- ity on arbitrary models. We will now examine some cases of frames with special accessibility relations, as well as some details in 5.3.

Special Modalities
We now indicate how we handle modalities like the global one and difference.
The global modality and difference are interesting cases [2]: M,s H Eϕ iff, for some t ∈ M , M,t H ϕ and M,s H Dϕ iff, for some t ∈ M \ {s}, M,t H ϕ.
We handle them by considering special relations ∞ and /= as logical, in the sense that in any frame frame F = (M, (αF)α∈Ξ), ∞F is the square M 2 := M × M (if
∞ ∈ Ξ) and /=F = {(s, t) ∈ M × M / s /= t} (if /=∈ Ξ).
We can see that this achieves the desired effect: modality ⟨∞⟩ behaves as the global E (M,s H ⟨∞⟩ϕ iff M,s H Eϕ) and modality ⟨/=⟩ behaves as difference D (M,s H ⟨/=⟩ϕ iff M,s H Dϕ).
It remains to provide rules for manipulating ∞ and /=.
The case of ∞ has already been indicated in Example 2: we can use the conversion
(∞)
D to eliminate occurrences of ∞.
We can similarly handle logical identity =, where =F is taken as the diagonal
{(s, t) ∈ M × M / s = t}. Now, we can eliminate an arc u →=  v from a slice S by

renaming v to u throughout S (cf. 3.2), i. e. by the conversion S +u →=
v (=)	[v/u]

We cannot eliminate diversity /=, so we allow basic sketches to have occurrences of /=. We do however have rules for manipulating /=.
(/=†) First (as s = t or s /= t) we have the following expansion rule
(/=†)  G ∪ { S }   G ∪ { S[v/u] , S + u →/=  v }	(u, v) ∈ N 2
S
(/=↓) Also (as s = s) we have the following contraction rule

/=
(/=↓)    G ∪ { S + w →
w }  G	erase slice S + w →/= w

With these two rules, we can establish some properties of these special modali- ties, such as ϕ → [/=]⟨/=⟩ϕ and ⟨∞⟩ϕ x (ϕ V ⟨/=⟩ϕ).
Also, proceeding as in 4.3, we obtain a union sketch Σ that is /=-complete in the

/=
sense:  for (u, v) ∈ NΣ  , u /= v iff u  →
v ∈ AΣ. So, Σ will be discriminating for

basic drafts (which may now have /=-arcs).

Modalities with Special Properties
We now indicate how one can handle modalities with some simple properties, like reflexivity, symmetry, transitivity and determinism. In some cases, a categorical approach is convenient: we will outline such ideas in 5.3.

We will introduce the terminology for the case of reflexivity, the terminology for the other cases being analogous.
The case of reflexivity has already been indicated in Example 2.2. Given ρ ∈ Ξ, consider frames where relation ρF is reflexive: (s, s) ∈ ρF, for every s ∈ M . We are interested in the formulas holding in every model with a reflexive frame.
Consider a sketch Σ. Call Σ ρ-reflexive iff the relation ρF[Σ] of its natural frame F[Σ] (cf. 3.2) is reflexive. Also, call Σ ρ-reflexive basic iff Σ is basic and ρ-reflexive. We use similar terminology for a slice S via its underlying draft S.
Example 2.2 suggests the conversion rule (Rfρ): S D S + w ρ w, for w ∈ NS. Note that S and S + w ρ w have the same extensions on a reflexive model.
With this rule, we can convert every slice S to a ρ-reflexive slice Srf. Thus, as in Proposition 4.2 (in 4.1), we can convert every expression to a graph whose slices are ρ-reflexive basic. We thus have a correct calculus as in 4.3.
The case for a symmetric σ is similar. It suffices to consider the conversion rule
(Smσ): S D S + v σ u, for an arc u σ v ∈ AS.
In the case of a transitive τ , Example 2.3 already suggests the conversion rule
(T rτ ): S D S + u τ w, for arcs u τ v, v τ w ∈ AS.
Repeated applications of this rule will convert every slice S to a τ -transitive slice Str. But, we now have to adapt gluing and the construction in 4.3 to τ -transitive sketches (see 5.3). With these adaptations, we have a correct calculus as in 4.3.
The case ofa deterministic δ is similar to the transitive one. We use a conversion

rule with renaming (as in 5.1), rule (Dt ): S D S[v′′/v′], for arcs u δ vj, u δ vjj ∈ A
. As

above, repeated applications of this rule will convert every slice S to a δ-deterministic slice Sdt, but we need appropriate adaptations. With such adaptations, we will have a correct calculus as in 4.3.
The cases examined above are relatively simple: the rules do not involve addition of new nodes. Consider, however, the case of seriality: the natural rule will add a new node. Such cases are best left for the expansion stage (cf. 4.3). One can handle several cases by pairs of sketches, i. e. a rule replacing Δ by Σ.



Some Details: categorical aspects and discrimination
We will now examine some details concerning 5.2 and 4.3.
We first consider some categorical constructions: co-limits and pushouts [7].
The category of sketches and morphisms has co-limits. The co-limit of a diagram of sketches can be obtained as expected: obtain the co-limit of the sets of nodes and then transfer arcs (by using the functions to the co-limit node set). Thus, the pushout of drafts is a draft. Also, gluing can be described as a pushout. Consider a slice T. Givena sketchΣ anda nodew ∈ INd, the glued sketch ΣwT is the pushout of sketches Σ + w (cf. 3.2) and T over the arcless sketch ⟨{x}; ∅⟩ under the natural morphisms (μ :x '→ w and ν :x '→ zT) as follows:

μ
⟨{x}; ∅⟩
Σ +¸ w μj


zw_
Σ_ T


Given a slice S = ⟨S : zS⟩, we obtain the glued slice SwT by transferring the distin- guished node zS of S to the glued sketch SwT: SwT := ⟨SwT : μj(zS)⟩.
One can adapt these constructions to particular categories of sketches, like the transitive ones (cf. 5.2). The co-limit sketch Σ may fail to be τ -transitive, but one can transform Σ to a τ -transitive sketch Σtr, which will be a co-limit in the category of τ -transitive sketches. Transitive gluing is the pushout in the category of transitive sketches. 11 This is the gluing used in the rule (→T ) for adding a slice-arc (cf. 4.1) and in the expansion rule (Exp) (cf. 4.2). Also, the construction in 4.3 now gives a family of slices connected by homomorphisms and we use its co-limit sketch Σ to obtain the natural model N[Σ]. The deterministic case is similar.
We now examine discrimination (cf. 4.3)
The crucial result is discrimination of the co-limit sketch Σ: for every basic draft D, g : D → N[Σ] iff g : D −−· Σ. This can be established by induction on the complement-complexity of a basic draft. 12  Then, since we have a morphism μ : S −−· Σ, we can conclude μ(zS) ∈ [[S]]N[Σ], whence [S]]N[Σ] /= ∅.

Concluding Remarks
We now present some remarks on our graph approach to modal logics.
We have examined a graph approach to multi-modal logics giving correct calculi. Such formalisms, which internalize the (Kripke) semantics of modal logics, provide uniform tools for expressing and manipulating modal formulas. Soundness and completeness indicate that our rules capture the intended meanings of the concepts. The uniformity of the approach yields a flexibility that is very useful in extensions: they can be presented naturally by expressing the corresponding intuitive ideas.
We have presented the graph calculus for logic K in Section 4. In Section 5, we have shown how to extend it, in a natural manner, to handle some modalities, like the global and difference modalities (in 5.1), as well as some modalities with properties like reflexivity, symmetry, transitivity and determinism (in 5.2). This illustrates some benefits of our uniform approach: the graph rules we formulate express the intuitive ideas, which contrasts with the unorthodox rules often used [2]. Similar ideas can be used in a graph approach to PDL for structured data. This illustrates the naturalness of our approach in expressing ‘;’. We can also express
intersection of programs (cf. [1]) simply as follows:

11 Note that Lemma 3 (Arc addition and gluing), in 3.2 (Modal Graph Concepts and Constructions), still holds because of the pushout propery.
12 We introduce ranks by mutual recursion. For expressions: for r ∈ Rn, rk[r] := 0 and, for a basic slice T, Σrk[T] := rk[T] + 1. For arcs: rk(w|E) := rk[E] and rk(u α v) := 0. For a draft D = ⟨N; A⟩:
rk(D) :=	a∈A rk(a). For a slice S: rk[S] := rk(S).



u  Π1∩Π2 /v ¸

Π1
z
D	u	 v ,
Π2

As the examples in Section 2 suggest, we have finite counter-models. The model provided by the construction outlined in 4.3 is not guaranteed to be finite, but we think that we can extend the filtration method [2] to our approach, thereby obtaining finite models. In a similar vein, it seems that familiar modal logic ideas, such as bi-simulation [2], have appropriate analogues for graphs.

References
Balbiani, P., Vakarelov, D.: PDL with Intersection of Programs: a Complete Axiomatization. J. Appl. Non-Classical Logics, 13, 231–276 (2003)
Blackburn, P., de Rijke, M., Venema, Y. : Modal Logic. Cambridge University Press, Cambridge (2001)

Curtis, S., Lowe, G.: Proofs with Graphs. Sci. Computer Progr. 26, 197–216 (1996)

Freitas, R., Veloso, P. A. S., Veloso, S. R. M., Viana, P. J.: Reasoning with Graphs. In: Mints, G., de Queiroz, R.J.G.B. (eds.) ENTCS, vol. 165, pp. 201–212. Elsevier (2006)
Freitas, R., Veloso, P. A. S., Veloso, S. R. M., Viana, P. J.: On Graph Reasoning. Information and Computation, 207, 1000–1014 (2009)
Freitas, R., Veloso, P. A. S., Veloso, S. R. M., Viana, P. J.: A Calculus for Graphs with Complement. In: Goel, A. K., Jamnik, M., Narayanan, N. H. (eds.) Diagrams 2010, LNCS, vol. 6170, pp. 84–98. Springer (2010)
MacLane, S.: Categories for the Working Mathematician (2nd edition). Springer-Verlag, Berlin (1998)

Veloso, P. A. S., Veloso, S. R. M.: On Graph Refutation for Relational Inclusions. In: Rocca, S. R. D., Pimentel, E. (eds.) LSFA 2011, EPTCS, vol. 81, pp. 47–62. (2011)
