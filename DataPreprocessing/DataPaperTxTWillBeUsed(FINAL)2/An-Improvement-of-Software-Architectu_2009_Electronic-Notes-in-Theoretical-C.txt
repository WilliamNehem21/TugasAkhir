

Electronic Notes in Theoretical Computer Science 243 (2009) 49–67
www.elsevier.com/locate/entcs

An Improvement of Software Architecture Verification
Zuohua Ding 1
Center of Math Computing and Software Engineering Zhejiang Sci-Tech University
Hangzhou, 310018, P.R.China
Jing Liu 2 3
Shanghai Key Lab of Trustworthy Computing East China Normal University Shanghai, 200062, P.R.China

Abstract
Static analysis may cause state space explosion problem. In this paper we explore differential equation model that makes the task of verifying software architecture properties much more efficient. We demonstrate how ordinary differential equations can be used to verify application-specific properties of an architecture de- scription without hitting this problem. An architecture behavior can be modeled by a group of ordinary differential equations containing some control parameters, where the control parameters are used to rep- resent deterministic/nondeterministic choices. Each equation describes the state change. By checking the conditions associated with the control parameters, we can check whether an equation model is feasible. After solving a feasible equation model, based on the solution behavior and the state variable representa- tion, we can analyze properties of the architecture. A WRIGHT architecture description of the Gas Station problem has been used as the example to illustrate our method. All of the equations have been computed with Matlab tool.
Keywords: Static analysis; architecture; ordinary differential equation; Wright.


Introduction
Static analysis is an approach to program behavior verification without execution. The approach is particularly useful in identifying program design errors prior to implementation. It has been demonstrated that detecting errors early in the lifecycle greatly reduces the cost of fixing those errors. A number of static analysis techniques

1 Email:zuohuading@hotmail.com
2 Email:jliu@sei.ecnu.edu.cn
3 Corresponding author

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.005

have been proposed. They span such approaches as reachability-based analysis techniques, symbolic model checking, flow equations, and dataflow analysis.
These techniques and approaches have been used in several analysis tools such as Flow equation is used in INCA [5], data flow analysis is used in FLAVERS [11], Reachability Analysis is used in SPIN [14], Symbolic model checking is used in SMV [4] and SMC [21].
In general all existing approaches appear to be very sensitive to the size of the program being analyzed in terms of the use of concurrency constructs and the num- ber of asynchronous processes. Particularly, reachability analysis may cause state space explosion problem since it has to exhaustively explore all the reachable state space to detect concurrency errors. Although many techniques have been proposed to combat this explosion, such as state space reductions, compositional techniques, abstraction, the state explosion problem still is the main technical obstacle to tran- sition from research to practice.
Current concurrent systems are described as discrete event system models which are suited to model system concurrency. However, the discrete will lead to state explosion problem since model checkers build a finite state transition system and ex- haustively explore the reachable state space searching for violations of the properties under investigation [3]. Hence, to thoroughly solve the state explosion problem, one solution is that the discrete event system model should be continunized to continu- ous system model, such that the systems can be described with analytic expressions. Therefore, instead of counting states, we can analyze the solutions of the analytic expressions.
Petri net seems a good candidate that bridges discrete event systems and con- tinuous systems. On one hand, Petri nets have been used extensively as tools for the modeling, analysis and synthesis of discrete event systems. Petri nets offer ad- vantages over finite automata, particularly when the issues of model complexity and concurrency of processes are of concern. On the other hand, a continuous system can be approximated by a Petri net [20] and a Petri net model is used as discrete event representation of the continuous variable system by Lunze et al. [17].
However, Petri nets also suffer from the state explosion problem while doing reachability analysis[18] even through there are some net reduction methods. One way to tackle that problem is to use some kind of relaxation by removing the integrality constraints. This relaxation leads to a continuous-time formalism: Con- tinuous Petri Net (CPN) by David and Alla[6][7]. A continuous Petri net, in fact, is an approximation of the timed (discrete) Petri net. The semantics of a continuous Petri net is defined by a set of ordinary differential equations (ODEs), where one equation describes the continuous changes over time on the marking value of a given place. Different firing styles in the CPN can lead to different semantics of CPN. In this paper, we consider a modified VCPNs in which the instantaneous firing speeds depend on the markings such that the markings are continuous without points of discontinuity.
Based on CPN, a concurrent system can be modeled by a group of ordinary differential equations containing some control parameters, where the control param-

eters are used to represent deterministic/nondeterministic choices. Each equation describes the state change, which indicates that the state can be reached to some extent when the program is in execution. By checking the conditions associated with the control parameters, we can check whether an equation model is feasible. After solving a feasible equation model, based on the solution behavior and the state variable representation, we can analyze properties of the architecture. All equation groups will be solved by Matlab.
The primary goal of our work is to investigate the applicability of our skill for verifying application-specific properties of architectures. We investigate one exam- ple architecture, a WRIGHT description of the gas station problem, and illustrate the kinds of properties that can be verified and the kinds of errors that can be found early in the lifecycle. Since our architecture is described with CSP, we first translate CSP to Petri net and then build a differential equation model in order to analyze the state space.
This paper is organized as the following. Section 2 specifies a Gas-station with Wright. Section 3 builds Petri net model from Wright specification. Section 4 builds differential equation model based on Petri net. In Section 5, we show how to compute state measures. Section 6 is property analysis based on the solutions. In Section 7, we demonstrate how our method can be used to check the properties of Gas-station. The last section, Section 8, is the conclusion and discussion of the paper.

Specification of The Gas-Station Using Wright
According to [1], the Architectural Specification Language, Wright, was developed to provide a formal basis for specifying both the structure and behavior of archi- tectural descriptions. Wright is built around the basic architectural abstractions of components, connectors, and configurations. Each component is defined by a component type description which consists of an interface and a computation. An interface further contains a number of ports. Each port represents an interaction with the environment that the component may participate in, while the compu- tation describes the internal behavior of the component. Connectors in Wright define patterns of interaction between components. Each connector consists of the glue and a set of roles. Roles indicate the constraints on the components that will participate in the interaction. Glue is actually the counterpart of the computation in components. Wright uses CSP [13] to formalize the system behaviors.
The Gas-Station problem has been widely studied for property analysis, specially deadlock analysis. Generally, the automated gas station consists of a set of operators, a set of pumps and a set of customers. The scenario is as follows: customers continuously arrive at the gas station requesting a certain amount of gas from one of the pumps chosen at random. Each customer must go to an available cashier and pay for the gas before being allowed to pump it. If all the cashiers are serving customers, a customer who needs to pay must wait for the next available

cashier. After the gas is paid for, the cashier will activate the customer’s pump. If all the pumps are being used, the customer has to wait until a pump is free. In our study case, we consider a simplified instance of the Gas-Station problem, which consists of two customers, one cashier and one gas pump. A Wight specification is illustrated in the following.
Component Casher
Port Customer1 = accept?x→ Customer1 Port Customer2 = accept?x→ Customer2
Port ToPump = activate!x → ToPump
Computation = customer1.accept?x→ T oP ump.activate!x →
Computation  Customer2.accept?x→
T oP ump.activate!x → Computation
Component Pump
Port Hose1 = take?x→ Hose1 Port Gas1 = pump!x → Gas1 Port Hose2 = take?x→ Hose2 Port Gas2 = pump!x → Gas2
Port FromCasher = get order?x → FromCasher Computation = FromCasher.get order?x →
((Hose1.take?x→ Gas1.pump!x → computation )
 (Hose2.take?x→ Gas2.pump!x →
computation))
Component Customer
Port Pay = pay!x → Pay
Port Take = take!x → Take Port Gas = pump!x → Gas
Computation = P ay.pay!x → T ake.take!x →
Gas.pump?x→Computation Component Customer Casher
Role Givemoney = pay!x → Givemoney Role Getmoney = accept?x → Getmoney

Glue = Givemoney.pay?x→ Getmoney.accept!x Glue Component Customer Pump Hose
Role Gethose = take!x → Gethose Role Givehose = take?x → Givehose
Glue = Gethose.take?x→ Givehose.take!x Glue Component Customer Pump Gas
Role Getgas = pump?x → Getgas Role Givegas = pump!x → Givegas
Glue = Givegas.pump?x→ Getgas.pump!x Glue Component Casher Pump
Role Tell = activate!x → Tell Role Ack = get order?x → Ack
Glue = Tell.activate?x→ Ack.get order!x Glue
Instances
customer1: Customer customer2: Customer casher: Casher pump: Pump (omitted)

Attachments
(omitted)

We created four component instances and seven connector instances under the Instances section. The cashier module has a total of three communication ports (Customer1, Customer2 and ToPump). Two are inputs (Customer1 and Customer2, depicted by the CSP ”?” operator) and the remaining one is output communication (ToPump, depicted by the CSP ”!” operator). The internal ac- tion of this cashier module is specified as the Computation of the cashier com-

ponent, which nondeterministically (with the CSP  operator) selects one out of two possible execution paths: rendezvous with the input communication from port Customer1 then the output communication to port ToPump (which is the ”1? →	! ” branch), or rendezvous with the in- put communication from port Customer2 then the output communication to port ToPump (which is the ”2? →	:	! ” branch). All other component and connector specifications can be interpreted similarly.
As in [19], we will check two specifications of the architecture. The first one is a critical race, in which one customer pays for gas and the second customer then pays and takes the pump before the first customer gets gas. The second specification is that no customer receives gas without paying for it.

Building a Petri Net Model of the Gas Station
In this section, we will explain how to map the Wright specification of a system into a Petri-net model. We need some general concepts which can be found in [16].
Hierarchy and modules: The basic Petri-net model does not support hierarchy and composition explicitly. As in most ADL specifications, a whole system is nor- mally composed of components and connectors, which are most suitably described as submodules of a whole system. To support this, we introduce the module concept into the Petri-net model. We can map each component or connector into a small Petri-net module (sub-graph). With all the modules, together with the IO-nets concept below, we can model the whole system.
IO-nets, IO-places and IO-transitions: The concept of IO-nets comes from the idea of modularity in software design. An IO-net is a combination of a Petri-net and an interface. The interface specifies the way that an IO-net (module) inter- acts with its environments. It can represent a set of asynchronous communication channels. The interfaces of IO-nets are represented using IO-places together with the related arcs as illustrated in Figure 1. IO-transitions are those transitions that have outgoing arcs to, or incoming arcs from, IO-places.

IO-Net1	IO-Net2







21
11

Fig. 1. Example of IO net.
Internal transitions: All the Petri-net transitions that have no outgoing arcs to, or incoming arcs from, IO-places are defined as internal transitions.
The basic idea of the mapping algorithm is to map each component instance to a submodule of a Petri-net model and each atomic connector instance to an IO-place.

The atomic connector here refers to the connectors whose Glue part only contains the actions defined in the Role part. If there are internal computation steps other than simply carrying data between Role parts, which make the connectors non- atomic, we can map the computation steps of these connectors into sub-modules in the same way as components. The basic unit of a CSP behavior specification is an event which represents an action in Wright. Thus, each event in Wright can be mapped into a transition in a Petri-net. Actions carrying data can be mapped to IO-transitions. Output actions (e!x) contain outgoing arcs to IO-places while input actions (e?x) contain incoming arcs from IO-places. Actions not carrying data can be mapped into an internal transition. Once transitions have been fixed, places can be added between transitions to connect the whole Petri-net together based on the specifications in the Computation part. Normally, each Port of the component instance can be mapped into an aggregation of transitions which contains at least one IO-transition. In most cases, the Port contains no internal transition, so the Port can be mapped into an IO-transition because such Ports normally contain only one input/output action. For detailed rules, we refer to [16].
This mapping is actually a conversion of CSP operators into Petri-net transition structures. A set of conversion rules have been defined to cover the most common CSP operations [22]. Under these rules, the properties of the architecture, such as deadlock, will be reserved.
In this way, we get Petri nets such that each transition has at most two input arcs and at most two output arcs. We have the following definitions.
Definition 3.1 A Place/Transition Chain is a net such that transitions are con- nected by a head place that has one output arc and no input arc, an end place that has one input arc and no output arc, and places that have one input arc and one output arc. If the head place and the end place are overlapping, then the chain is called Place/Transition Cycle.
Definition 3.2 A place/transition cycle is called Process Cycle, if every transition in the cycle is 1) a transition that has one input arc and one output arc; this transition is called an Internal Transition of the process, 2) a transition that has one input arc and two output arcs; this transition is called an Output Transition of the process, here one output arc is to construct the cycle and the other is for the output of the cycle, 3) a transition that has two input arcs and one output arc; this transition is called an Input Transition of the process, here one input arc is to construct the cycle and the other is for the input of the cycle, 4) a transition that has two input arcs and two output arcs; this transition is called an Input-Output Transition of the process, here one input arc and one output arc are used to construct the cycle and the other two are used for the input and output of the cycle, respectively.
Thus, each component contains one or many process cycles depending on whether the component contains no or some select controls.
The complete Petri-net model of the Gas-Station problem is shown in Figure 2. While building a Petri net, we may obtain some ”valued-oriented” constructs such as parameters, variables that define the dynamic state of a program. We use























Fig. 2. Gas station net.

special variables, called state variables, to record them at each place such that when the system is executed from one place to another place, state variable’s values will be changed. In this paper, these variables are extracted from control structures such as if/else, switch, etc. In the Gas-Station example, we may have two variable, 1 and 2, that represent who pays the money and who picks the hose, respectively. Thus each variable has the domain {customer1 customer2}. We have the following definition.
Definition 3.3 (System State) A system state is deﬁned as a group of variables whose values have changed.
Thus, each place corresponds to a state.

Building A Model Using Ordinary Differential Equa- tion
Continuous Petri Net
The Petri net obtained in the last section is discrete Petri net, in which the number of marks in the places are integers. A transition is enabled if each input place of the transition is marked with a token. An enabled transition fires by removing a token from each input place and adding a token to each output place.
Now check the following example to find out how the data is processed. As shown in Figure 3(a), a process cycle has places 1  2 	and has an input place i at transition 1. We assume that place 1 has a token, meaning that the process is visiting this place, and i has 3 tokens, meaning that there are three data in the buffer.


		
(a)	(b)	(c)

Fig. 3. Marking changes in discrete Petri net.
The process has to visit place 1 for 3 times to move away all 3 tokens in the place i. In other words, 3 × 1 tokens will be moved from place 1 as shown in Figure 3(b)(c). Thus the tokens in the input place i can be regarded as an impact factor while tokens are moved from the process place 1. If the number of data in the buffer is big, and a program has many such buffers, then we will get large number of reacheable markings which could limit the use of discrete Petri nets.
Now we assume that the marking is moving as a continuous flow, then the marking moving rate can be regarded as the product of 1( ) × i( ), where 1( ) and i() are the markings of 1 and i at time , respectively. This can be pictured in Fig. 4.










Fig. 4. Continuous flow in Petri net.
Based on this idea, we propose a new continuous Petri net model. In this model, the instantaneous firing speed of a transition is proportional to the product of the markings of the input places.
Definition 4.1 A Continuous Petri Net is a tuple  = pre post  , where
 = {1  2 n} is a ﬁnite nonempty set of places,
 = {1  2  m} is a ﬁnite nonempty set of transitions,
pre = { → } is a set of directed arcs which connect places with transitions,
post = { → } is a set of directed arcs which connect transitions to places,
 :  → (0 ∞) is a mapping to assign a ﬁring rate to each transition.
Definition 4.2 Let  = [0 ∞) be the time interval and let i :  → [0 ∞) =
1 2	 be a set of mappings that associated with place i. A marking of a Con- tinuous Petri Net  = pre post   is a mapping
 :  → [0 ∞)n () = (1()2()  n())

Definition 4.3 A marked CPN is a 2-tuple (0) where
 is a CPN,
0 =( 1(0)2(0)  n(0)) is its initial marking, where i(0) takes value 1 or 0.
A place holding initial marking 1 is called start place. The marking of a place can be used to measure how often this place has been visited. We have the definition:
Definition 4.4 (State Measure) Given any time moment  ∈ [0 ∞), the state can be reached to some degree. This degree is called State Measure, denoted as ( ). State measures take nonnegative real numbers as their values.
Later, we will prove that the states of each process cycle take values from [0,1]. For a state , if () = 1, then we say that the program is completely in the state , or simply in the state . If () = 0, then we say that the program is not in the state .
All the i defined above are the state measures. So, if new marking is moved into a place, we say that the state is increasing; if some marking is moved out from a place, we say that the state is decreasing. The change rate of state measure can be calculated as the following.
Let 1 and 2 be the input places of a transition  and their markings are 1() and 2(), respectively. Let  be the firing rate associated with , then the mark moving rate from each place is defined as the product  ∗ 1() ∗ 2(), where ∗ represents the regular multiplication. This expression contains the enabling information: if one of 1 and 2 is zero, then the firing rate is 0, meaning the transition is not enabled. Our definition magnify the states, which is useful when we study the state trend. Our definition is to make the state marking differential, thus the state change is continuous without points of discontinuity.
Gilbert and Heiner [12] have successfully used the similar continuous Petri net model to study biochemical systems to explore possible observable behaviors, where the firing rates of all the atomic actions is the product of the concentrations of the involved substances. Here concentrations are continuous functions, which are the state measure functions in our paper.
Definition 4.5 A stationary state of a marked CPN is a state where all transitions are ﬁring.

Building A Differential Equation Model
The net marking (state measure) change depends on the program structures and the firing rates. Based on the semantics defined in the above section, the marking at each place can be represented by a differential equation. We consider choice structure here. For other cases, please see [9][8] for details.
Deterministic choice as shown in Figure 5.
Let  be a place that can move the marking to 2 or 3 deterministically based on some conditions. We assign a variable , called control parameter, to  to assist building equations.  is associated with some condition. If condition is true, then







3

4
Fig. 5. Deterministic choice.
 takes on the value 1, otherwise k is 0. Assume that the condition is true from  to 2, then the input of transition 1 is , while the input of 3 is (1 − ). The equation model for this net is

⎧⎪⎨
' = 11 − 2 − (1 − )3

' =  − 2  2
' = (1 − ) − 33
Nondeterministic choice as shown in Figure 6. Let  be a place that can move a marking to 1 or 2 nondeterministically. We also assign a control parameter  to  to assist building equations. But this time no condition is associated with the control parameter.  takes value 0 or 1. In this picture, the input of transition 1 of the first process is 1 , while the input of 3 of the second process is 3(1 − ).







3



Fig. 6. Nondeterministic choice.
The corresponding differential equations are:

⎧⎪⎪⎨

⎪

' = ()1 − 11 
' = 1 1  − 2 2
3 = ()2 − 3  3(1 −  )
 

Here we use () to represent some other state measures. If more than two processes are involved in sharing , say 3 processes 1  2 and 3, then we will have two parameters: 1 and 2. Let 1, 3 and 5 be the input transitions that need resource.
The inputs to the transitions are: ()1 ∗ 1 ∗ , ()2 ∗ (1 − 1) ∗ 2 ∗ , and ()3 ∗ (1 −
1) ∗ (1 − 2) ∗ , respectively.
All the parameters in the system form a vector, (1 2 	n), called control

vector. By selecting the values of 1 2 	n, we can show the different aspect while the system is executing.

Computing Program States
The differential equation model contains some nonlinear ordinary differential equa- tions, and thus it is hard to give analytic expressions to the solutions. Nevertheless, we may compute the solution trend and estimate the solution range.
Proposition 5.1 For any place/transition cycle, if it has at most one start place, then the state measures of the cycle are all converging to numbers in [0,1] no matter how the ﬁring rates are chosen. Particularly, 1) If the cycle does not contain start place, then all state measures are 0. 2) If the cycle contains one start place, and all the inputs to the cycle have positive state measures, then the state measures of the cycle converge to the numbers in (0, 1).
We assume that each process has one start place.
Proposition 5.2 When a system reaches stationary state, the measures of each process are all approaching to numbers in [0,1] no matter how the ﬁring rates are chosen.
Proof. Since each process is one or several place/transition cycles containing a start place. From Proposition 5.1, the state measures of the process will approach to the numbers in [0,1].
Note: We did not count the input places and the output places. Their state measures may exceed 1, unless they are also in some place/transition cycle.
Proposition 5.3 Given a process cycle, if it does not have inputs, then all the state measures converge to numbers in (0, 1).

Property Analysis
The ordinary equation model we obtained based on the Petri net may be infeasible,
i.e. the system is not able to take on certain states whose state measures can be solved in the equation model. In other words, some states can not be visited in the execution. Thus, in order to study the program properties, we first need to determine that the obtained equation model is feasible.
When a state is visited, some state variable’s value has been changed, or state variable’s domain has been changed. If some state variable’s domain at the state is empty, then this state may not be visited and the equation model is infeasible. If no state has empty state variable domain, then the equation model is feasible. Basically the variable domain is updated by the conditions from control parameters. For example, let  be a state variable and we also use Dx to denote the domain of . We call ( Dx) the representation of variable . Let  [ ] be a condition for variable , then   [ ] ∧ Dx ⊂ Dx. We also define
[ ] ∧ ( Dx)=(	] ∧ Dx)

If Dx = ∅, then (  Dx)= ⊥.
Let  be a control parameter. A condition  is associated with  if  = 1, denoted as ( = 1)  . Assume that 1 and 2 are two parameters such that (1 = 1)  1[] and (2 = 1)  2[], and 1[] ∧ 2[] = ∅. Then
1[] ∧ 2[] ∧ ( Dx)
= 1[] ∧ (2[] ∧ Dx)
=(1[] ∧ 2[] ∧ Dx)
=( ∅)= ⊥
Hence, the state with 1 or the state with 2 will not be visited. The equation model is infeasible.
Generally, for the system, we have a vector of variable representation: (	( Dx)	). For this vector, we have rule
[ ] ∧ (	( Dx)	) = (	] ∧ ( Dx)	)
Properties of the system will be implied from this vector. Note that in the case that condition has input or output, we will use marco to separate input/output from the condition. So the above definitions are still true.
For feasible equation models, we have the following definition:
Definition 6.1 (Stable and Unstable System) For any group of control parameter values, if all states of a system are converging to numbers in [0,1] no matter how the ﬁring rates are chosen, then the system is stable. For some group of control parameter values, if there exists one group of ﬁring rates such that there is at least one state measure converging to a number greater than 1, then the system is unstable.
In the case that the system is stable, we have proved the following result for concurrent systems which consists of a set of processes that communicate with one another via message passing[10].
Theorem 6.2 A program has a deadlock iff there exists a group of control pa- rameter values such that every state measure of the program either converges to 1 (including identically to 1) or converges to 0 (including identically to 0) no matter how the ﬁring rates are chosen.
In the case that the system is unstable, we have the following result.
Theorem 6.3 Given an unstable system, there is at least one input / output place that does not belong to any place / transition cycle.
Proof. Assume that the system is unstable. Then there is a state whose state measure is greater than 1. Let the state be , ()  1. If every place is in some cycle, then from Proposition 5.1, we know that  is in [0,1]. Hence  is not in any cycle. We say that  is not in any process cycles since all state measures in the process cycle are in [0, 1]. So  must be an input/output place. This completes the proof.
This result implies that with some control parameter values, there must exist one place/transition chain that is attached to a process cycle. Hence, we can infer

that in this situation the system has chance to hit some synchronization problems or nondeterministic behavior, such as Race Condition.
Informally, an execution of a program contains a race if the result of some com- putational step depends upon the scheduling of the individual threads of execution. For example, in Figure 7, processes 1 and 2 send messages to 3.

Fig. 7. Race example.
We assume that the firing rates all equal 1. The equation model is
'
1
2 ' 3
'
4 ' 5
6 ' 7
'
8
If  = 1, then process 3 takes the message from 1 and if  = 0, then process 3 takes the message from 2. Let  = ”3 gets message from 1” and ¬ = ”3 gets message from 2”. Then ( = 1)   and ( = 0)  ¬. In both cases, three processes are all running. But with the same inputs from 1 and 2, we may get different outputs. This will be reflected in the following equation models.
If  = 1, we get the equation model
'
1
2 ' 3
'
4 ' 5
6 ' 7
'
8
By the simple calculation, 5 will be accumulated to a number greater than 1. Let  be the state variable that describes the situation in which process 3 will get message. So the variable representation is ( {1 2}). This representation will be updated to ( {1 2}) ∧  =( {1}). If = 0, then we get the equation model	'
1
2
' 3 '
4 ' 5
6 ' 7
'
8

By calculation, 6 will be accumulated to a number greater than 1, and the repre- sentation will be updated to ( {1 2}) ∧¬ =(	{2}).
Hence, in the above two models we get two different outputs for the same mes- sages from 1 and 2.

Analyzing the Gas-Station With Differential Equa- tions
Based on the net of Figure 2, we label each place with a state measure as shown in Figure 8.






















Fig. 8. Gas station net with marking and control parameters.
There are 19 places, and therefore, we will have 19 equations. In the component Casher, since the token in 13 can be assigned to c1.accept or c2.accept nondeter- ministically, we need a control parameter for this place, which is 1 in the figure. If 1 = 1, then casher gets money from customer1 first, otherwise customer2 first. Also in component Pump, both hose1.take and hose2.take have the same chance to get the token from 17, we need another control parameter 2 here for 17. If 2 = 1, then customer1 will take the hose first, otherwise customer2 takes the hose. Without loss of generality, we may assume that these two customers use the same speed to pay the money, to pick the hose and pump the gas. Thus we may assume the firing rates all equal 1. We may use two state variables 1 and 2 to represent from whom the casher accepts the money and who picks the hose, respectively. Their domains are:
Dx1 = {customer1 customer2} Dx2 = {customer1 customer2}
Vector (1  2) will be associated with each state. Let

1[1] = casher accepts money from customer1,
¬1[1] = casher accepts money from customer2,
2[2] = customer1 pick the hose,
¬2[2] = customer2 pick the hose.
Two parameters 1 and 2 are associated with these conditions by

The differential equation model of Gas-station is in the following:
'
1
m' = m1 − m2
m' = m2 − m3m6
> m = m1	1  4  13
4
>
m' = m2 − k2m5m17
'
6
m' = m9m12 − m7 m' = m7 − m8
< m' = m8 − m9m12
'  = m7 − (1 − k1)m10 m13 m'  = m8 − (1 − k2)m11 m17
m'  = m18 − m12 m9
m'  = m14 − k1m13m4 − (1 − k1)m13 m10 m'  = k1m13 m4 + (1 − k1)m13 m10 − m14
'  = m14 − m15 m19
16 = k2m5 m17 − m16
m'  = m15m19 − k2m5m17 − (1 − k2)m11 m17 m'  = (1 − k2)m11 m17 − m18
'  = m16 + m18 − m19 m15
The initial values for the equation model are 1(0) = 7(0) = 13(0) = 19(0) = 1, 2(0) = 3(0) = 4(0) = 5(0) = 6(0) = 8(0) = 9(0) = 10(0) =
11(0) = 12(0) = 14(0) = 15(0) = 16(0) = 17(0) = 18(0) = 0
Based on the values assigned to 1 and 2, we totally have 4 cases:
Case 1. (1 2) = (1 1). The solutions of the model are plotted in Fig. 9(a). Since all the state measures are in [0,1], in this case, the system is stable. State variable domains can be calculated as following. For the process Casher, we have
((1 Dx1 ) ( 2 Dx2 )) ∧ 1[1]
= ((1 1[1] ∧ Dx1 ) ( 2 Dx2 ))
= ((1 {customer1}) ( 2 Dx2 ))
For the process Pump, we have
((1 {customer1}) ( 2 Dx2 )) ∧ 2[2]
= ((1 {customer1}) ( 2 2[2] ∧ Dx2 ))
= ((1 {customer1}) ( 2 {customer1}))
Thus for the whole system, we have the variable representation:
((1 {customer1}) ( 2 {customer1}))
We can interpret this expression as that customer1 pays the money and will get the gas. From the solution curves, we can also find that the state measures
7 → 0 8 → 0 12 → 0 18 → 0




1.2

1.2




1	1



0.8	0.8



0.6	0.6



0.4	0.4



0.2	0.2



0	0



−0.2
0	2	4	6	8	10	12	14	16	18	20
t

−0.2


0	2	4	6	8	10	12	14	16	18	20
t


Fig. 9. (a). Case1: (k1, k2)= (1, 1). (b). Case 2: (k1, k2)= (0, 0).
8 → 0 means that the state 8 is eventually not being visited, in other words, Customer 2 does not pay the money. Similarly, 18 → 0 means that the state 8 is eventually not being visited, in other words, Customer 2 does not have chance to pick the hose and thus does not get the gas.
Case 2. (1 2) = (0 0). The solutions of the model are plotted in Figure 9(b). The system is stable. This case is for customer2 as that for Customer1 in case 1. Customer2 pays the money and will get the gas. Customer1 does not pay the money and will not get the gas.
Hence, from Case 1 we imply that if a customer pays, then he/she will get the gas; from Case 2 we imply that if a customer does not pay, then he/she will not get the gas. Thus, we may conclude that the second specification ”no free gas” is satisfied.
Case 3: (1 2) = (1 0). The solutions of the model are plotted in Fig- ure 10(a). Form the curves, we find that state measure 10 approaches to 2. Thus the system is unstable. Variable domains can be calculated as following. For the process Casher, we have
((1 Dx1 ) ( 2 Dx2 )) ∧ 1[1]
= ((1 1[1] ∧ Dx1 ) ( 2 Dx2 ))
= ((1 {customer1}) ( 2 Dx2 ))
For the process Pump, we have
((1 {customer1}) ( 2 Dx2 )) ∧¬2[2]
= ((1 {customer1}) ( 2 ¬2[2] ∧ Dx2 ))
= ((1 {customer1}) ( 2 {customer2}))
Thus for the whole system, we have the variable representation:
((1 {customer1}) ( 2 {customer2}))
We can interpret this expression as that customer1 pays the money and customer2 gets the gas.




2	2



1.5

1.5






1	1





0.5	0.5





0	0



−0.5
0	2	4	6	8	10	12	14	16	18	20
t

−0.5


0	2	4	6	8	10	12	14	16	18	20
t


Fig. 10. (a). Case1: (k1, k2)= (1, 0). (b). Case 2: (k1, k2)= (0, 1).
Case 4: (1 2) = (0 1). The solutions of the model are plotted in Fig. 10(b). The system is unstable as well. This is the same as case case 3) except the positions of Customer1 and Customer 2 are changed.
Hence, from Case 3 and Case 4, we may conclude that the first specification is satisfied.

Discussion and Conclusion
The most closed work is by Naumovich et al. in [19], where they used two con- currency analysis tools, INCA and FLAVERS, to verify the same specifications of Gas station architecture as in our paper. Flow equation technique has been used in INCA to check the consistency of the system. Inequalities are solved using standard integer linear programming packages. However, integer linear programming prob- lems are generally NP-hard, and the standard techniques involved are potentially exponential. FLAVERS is data flow analysis based tool. By approximating the execution model of a program, properties can be efficiently checked using a polyno- mial algorithm. However the conclusion thus obtained is usually either complete or sound but not both.
Generally speaking, the existing static analysis techniques can not complete avoid hitting state explosion problem even some state reduction techniques have been used such as in SPIN. The reason is that we have to search all reachable states to determine if the properties can be satisfied. With our method, we only need to solve 2k different differential equation groups, where  is the number of control parameters. Given a group of values for these s, we will obtain an equation group. Hence, these equation groups are independent and can be solved in parallel. So the complexity is determined only by one equation group. By analyzing the solutions, we may determine if the architecture can satisfy the requirement. The more larger the system, the more powerful this method will express. This is why we can avoid the state explosion problem when we do statically analysis.
The existing static analysis tools can automate the checking of properties, but it is still up to the system architect to formulate those properties. With our method, it

is very easy to write equation group and compute them with Matlab. If the numbers of the equations is huge, we do require a tool to analyze the discrete-valued solutions, not just to check the curves from Matlab.
We make no claim that our technique can replace the existing analysis tools. In the existing tools, properties are expressed by Temporal Logic. To check the property of interest, we can design some check statements and insert them to the input language. In this way, we can immediately know if the specified property is satisfied. The disadvantage is that the tools may not suitable for large systems. In our case, we can easily find the abnormal behavior, and then based on the state variable representation to analyze if the properties of the architecture are satisfied. The disadvantage is that we need to interpret the variable representation. Also, we have not proved yet that the state variable representation can describe all the properties of the architecture.
By combining our technique with the existing skills, we may also improve the checking speed. For example, use our equation method as the first step to find abnormal behavior which corresponds to a group of control parameter values, and then based on the interpretation from these values to design some statements to be inserted to the input languages for the model checking. Since in the first step we have narrowed the analysis scope, we may quickly check the property without hitting explosion problem.
As one might concern, if the system is very large, the equation model will be very big. And sometime, even a single equation group may contain huge number of equations, for example to model a system with 1020 states that has been used for Symbolic Model Checking by Burch et al.[2]. Matlab may not have enough power to do such computing. A solution is to solve the equation group in parallel. Currently, we are developing a computing algorithm based on the work by Intievergelt[15]. A large differential equation group can be separated into several small equation groups that can be computed in parallel. Eventually, we will develop a tool to support the analysis from building equation model to parallel computing, and to the solution analysis.
As the next step study, we will check the efficiency of our method applied to the systems that consist of large number of behaviorally similar processes, e.g. in the gas station example there exist lots of customer processes, pump processes and casher processes, and find out how our model complement to those discrete event based models, e.g. [23], that are used to handle the large number of processes.

Acknowledgement
We are grateful to the anonymous reviewers for their detailed comments and suggestions that improved the paper. This work is partially supported by the National Key Research program of Dependable Software Theory under Grant No. 90718014, National High Tech Research 863 Program of China under Grant No.2006AA01Z165; the National Natural Science Foundation of China under Grant No.60673114; 60603037; International Cooperation Program of Shanghai under

Grant No.08510700300.

References

Allen R. and Garlan D. 1997. A formal basis for architectural connection. ACM Transactions on Software Engineering and Methodology 6(3), pp.213-249.
Burch J. R., Clarke E. M., and Long D. E. 1991. Representing circuts more efficiently in symbolic model checking, In Proceedings of the 28th Design Automation Conference, IEEE Computer Society Press, Los Alamltos, Calif., pp.403-407.
Clarke E.M., Grumberg O., Peled D. 1999. Model Checking, MIT Press.
Clarke E., McMillan K., Campos S. and Hartonas-Garmhausen V. 1996. Symbolic Model Checking,
Proceedings of 8th Computer Aided Verification Conference, Springer, Berlin.
Corbett J.C. and Avrunin G.S. 1995. Using integer programming to verify general safety and liveness properties, Formal Methods in System Desin, 6, pp.97-123.
David R. and Alla H. 1987. Continuous Petri nets. 8th European Workshop on Application and Theory of Petri nets, Zaragoza, Spain, pp.275-294.
David R. and Alla H. 1990. Autonomous and timed continuous Petri nets, 11th Int. Conf. On Application and Theory of Petri nets, Paris, France, pp.367-381.
Ding Z. and Xiao L., Hu J. 2008. Performance analysis of service composition using ordinary differential equations, Proceedings of FTDCS08, IEEE Computer Society Press, Kunming, China, October 21-23.
Ding Z. and Zhang K. 2008. Performance analysis of concurrent programs using ordinary differential equations, COMPSAC08, IEEE Computer Society Press, Turku, Finland, July 28-August 1.
Ding, Z., Zhang K., and Kandel A. Detecting program deadlocks with ordinary differential equations.
Journal of IEEE Transactions on Software Engineering, submitted.
Dwyer M.B. and Clarke L.A. 1994. Data flow analysis for verifying properties of concurrent programs,
Proc. Second Symp. Foundations of Software Enginemng, pp. 62-75.
Gilbert D. and Heiner M. 2006. From Petri nets to differential equations-an integrative approach for biochemical network analysis, Lecture Notes in Theoretical Computer Science, vol.4024, pp.181-200.
Hoare C. A. R. 1978. Communicating sequential processes. Communication of ACM 21(8), pp.666-677.
Holzmann G.J. 1980. Basic Spin Manual, http://cm.bell-labs.com/netlib/spin/ whatispin.html, 1980.
Intievergelt J. 1964. Parallel methods for integrating ordinary differential equations, Communications of the ACM, 7(12), pp.731-733.
Juan E., Tsai J.J.P. and Murata T. 1998. Compositional verification of concurrent systems using Petri-nets-based condensation rules. ACM Transactions on Programming Languages and Systems 20(3), pp.917979.
Lunze J., Nixdorf B., and Richter H. 1997. Hybrid modelling of continuous-variable systems with application to supervisory control. In Proceedings of the European Control Conference 97, Brussels, Belgium.
Molloy M. K. 1985. Fast bounds for stochastic Petri nets. International Workshop on Timed Petri Nets, Torino, July, pp.244-249.
Naumovich G., Avrunin G. and Clarke L. 1997. Applying static analysis to software architectures, ACM SIGSOFT Notes 22(6), pp.77-93.
Peleties P. and DeCarlo R. 1994. Analysis of hybrid systems using symbolic dynamics and Petri nets.
Automatica 30(9), pp. 1421-1427.
Sistla A.P., Miliades L. and Gyuris V. 1997. SMC: A symmetry based model checker for verification of liveness properties, Proceedings of 9th Computer Aided Verification Conference, Haifa, Israel.
Tsai J.P. and Xu K. 1999. An empirical evaluation of deadlock detection in software architecture specifications, Annals of Software Engineering 7, pp.95-126.
Wang X., Kwiatkowska M. 2007. Compositional state space reduction using untangled actions,
Electronic Notes in Theoretical Computer Science, 175(3), pp. 27-46.
