

Electronic Notes in Theoretical Computer Science 223 (2008) 3–14
www.elsevier.com/locate/entcs

Monotonic Abstraction in Parameterized Verification
Parosh Aziz Abdulla1
Department of Information Technology Uppsala University
Sweden
Giorgio Delzanno2
Dipartimento Informatica e Scienze dell´Informazione Universita` di Genova
Italy
Ahmed Rezine3
LIAFA
University of Paris 7 France

Abstract
We present a tutorial on verification of safety properties for parameterized systems. Such a system consists of an arbitrary number of processes which are organized in a linear array. The aim is to prove correctness of the system regardless of the number of processes inside the system. We give an overview of the method of monotonic abstraction, which provides an over-approximation of the transition system induced by a parameterized system. The over-approximation gives a transition system which is monotonic with respect to a well quasi-ordering on the set of configurations. This makes it possible to use existing methods for verification of well quasi-ordered programs.
Keywords: Model Checking, Automatic Verification, Parameterized Systems, Safety Properties


Introduction
In this tutorial, we explain the basic ideas of the monotonic abstraction, a technique which we have introduced recently [4,3,5] for automatic verification of parameter- ized systems. A parameterized system consists of an arbitrary number number of

1 Email: parosh@it.uu.se
2 Email: giorgio@disi.unige.it
3 Email: rezine.ahmed@liafa.jussieu.fr

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.027

processes usually organized as a linear array. In fact, a parameterized system rep- resents an infinite family of systems, namely one for each size of the system. We are interested in parameterized veriﬁcation, i.e., verifying correctness regardless of the number of processes inside the system. The term parameterized refers to the fact that the size of the system is (implicitly) a parameter of the verification prob- lem. Examples of parameterized systems include mutual exclusion algorithms, bus protocols, telecommunication protocols, and cache coherence protocols.
The main techniques used for verification of parameterized systems have been defined within the paradigm of regular model checking [14,7,9]. In regular model checking, states are represented by words where each element of the word corre- sponds to the local state of one process. The ordering of the elements inside the word reflects the ordering of the corresponding processes inside the array. Using words to represent configurations allows us to use finite automata (or regular ex- pressions) to represent (infinite) sets of configurations. A configuration belongs to the set if its word encoding is accepted by the automaton. We can also encode the transition relation by ﬁnite-state transducers. A transducer is an extension of an au- tomaton, where each run of the transducer both inputs and outputs a word (rather than only inputting a word). A transition from a configuration c1 to a configuration c2 can be encoded by a run of the transducer where we input the word encoding of c1, and output the word encoding of c2. Safety properties can be checked through performing reachability analysis, which amounts to applying the transducer relation iteratively to the set of initial states. The main problem with transducer-based tech- niques is the difficulty of computing the transitive closure. Existing methods are heavy and usually rely on several layers of computationally expensive automata- theoretic constructions; in many cases making them very inefficient and severely limiting their applicability.
In parallel, there has been an extensive research on the verification of infinite- state systems which are monotonic w.r.t. a well quasi-ordering on the set of config- urations [2]. The main idea is to perform symbolic backward reachability analysis to check safety properties for such systems. The method was first reported in [6] and applied to analyze safety properties for lossy channel systems. Concretely, we define a pre-order ≤ on the set of configurations such that (1) ≤ is a simulation with respect to the transition relation (i.e., the transition relation is monotonic w.r.t. ≤), and (2) ≤ is a well-quasi ordering (WQO for short). Given such a pre-order, we can derive a backward algorithm for checking reachability of sets of configurations which are upward closed w.r.t. ≤. Upward closed sets are attractive to use in this setting for several reasons. First, we are interested in safety properties, in which we check the reachability of a set of bad conﬁgurations. These are configurations which we do not want to occur during the execution of the system. For instance, in mutual exclusion protocols, the bad configurations are those in which at least two processes are in their critical sections. This means that checking safety properties amounts to checking reachability of upward closed sets of configurations. The second attractive feature of upward closed sets is that they can be characterized by their minimal elements, which often makes it possible to have efficient symbolic representations of

infinite sets of configurations.
We start from the set of bad configurations, and then compute the sets of pre- decessors, i.e., sets of configurations which correspond to going one step backwards along the transition relation. Monotonicity implies that, for any upward-closed set, the set of its predecessors is an upward-closed set. Since the set of bad configurations is upward closed, it follows that all the sets which are generated are also upward closed. This procedure is guaranteed to terminate by the well quasi-ordering of the relation on the set of configurations.
Since its first application to lossy channel systems [6], the method has been used for the design of verification algorithms for a wide range of models such as Petri nets, timed Petri nets, broadcast protocols, cache coherence protocols, etc. (see, e.g., [8,10,11,12]).
Unfortunately, parametrized systems do not quite fit into this framework, in the sense that there is no nontrivial (useful) WQO for which these systems are monotonic. The ordering ≤ amounts to the subword relation on words. The main obstacle is that parameterized systems usually use universal global conditions in which a process may need to check states of all other processes inside the system. Universal conditions are inherently non-monotonic, since having larger configura- tions may lead to the violation of the universal condition. In this tutorial, we give an overview of the method of monotonic abstraction [4,3,5,1], which attempts to over- come this problem by defining an abstract semantics which forces monotonicity. Basically, the idea is to consider that a transition is possible from a configuration c1
to c2 if it is possible from any smaller configuration c' ≤ c1 to c2. More precisely, the
abstraction kills (deletes) all the processes inside the configuration which violate the universal condition. Since the abstract transition relation is an over-approximation of the original one, proving a safety property in the abstract system implies that the property also holds in the original system.
Monotonic abstraction has been used for performing shape analysis [1], and for parametrized verification of mutual exclusion and cache coherence protocols [4,3,5]. Surprisingly, it leads to quite efficient analysis which can handle fully automatically several non-trivial examples of such systems [4,3].




Outline
In the next section, we give an overview of parameterized systems, using a simple protocol that we use as a running example throughout this tutorial. In Section 3, we introduce the (infinite) transition systems which arise from parameterized systems. In Section 4 we introduce our ordering on the set of configurations, and then we define our abstraction in Section 5. We describe our approximated algorithm in Section 6. In Section 7, we simulate the reachability algorithm on a simple example. Finally, in Section 8, we describe several features which can be used to enrich the basic model of Section 2.








∃L


Fig. 1. One process in the protocol.
Parameterized Systems
In this section, we introduce the concept of parameterized systems, through a sim- ple example of a protocol which implements mutual exclusion among an arbitrary number of processes.
A parameterized system consists of an arbitrary number of processes each of which is a finite-state process. The processes are (usually) organized as a linear array. In each step in the execution of a parameterized system, one process, called the active process, changes state. The rest of the processes, called the passive processes, do not change states. We call the passive processes to the left of the active process the left context of the active process. The right context is defined analogously. The active process may perform a local transition in which it changes its state independently of the states of the passive processes. The active process may also perform a global transition in which it checks the states of the passive processes. A global transition is either universally or existentially quantified. An example of a universal condition is that all processes in the left context of the active process should be in certain states. In an existential transition we require that some (rather than all) processes should be in certain states.
In our example, each process (depicted in Figure 1) has four local states, namely the green, black, blue, and red states. We represent these states by coloured balls
, , , and . Sometimes, we refer to a process in a configuration by its state, so we say e.g. “the red process” rather than “the process in its red state”.
Initially, all the processes are green (they are idle). When a process becomes interested in accessing the critical section (which corresponds to the red state), it declares its interest by moving to the black state. This is described by the global universal transition rule t1 in which the move is allowed only if all other processes are in their green or black states. The universal quantifier labeling t1 encodes the condition that all other processes (whether in the left or the right context – hence the index LR of the quantifier) of the active process should be green or black.
In the black state, the process may move to the blue state through the local transition t2 (in which the process does not need to check the states of the other processes). Notice that any number of processes my cross from the initial (green) state to the black state. However, once the first process has crossed to the blue

state, it “closes the door” on the processes which are still in their green states. These processes will no longer be able to leave their green states until the door is opened again (when no process is blue or red). From the set of processes which have declared interest in accessing the critical section (those which have left their green states and are now black or blue) the leftmost process has the highest priority. This is encoded by the global universal transition t4 where a process may move from its blue state to its red state only subject to the universal condition that all processes in its left context are green (the index L of the quantifier stands for “Left”). If the process finds out, through the existential global condition, that there are other processes that are black, blue, or red, then it loops back to the blue state through the existential transition t3. Once the process leaves the critical section, it will return back to the black state through the local transition t5. In the black state, the process chooses either to try to reach the critical section again, or to become idle (through the local transition t6).
Formally, we represent a parameterized systems P by a pair (Q, T ), where Q is the set of the local states of the processes, and T is the set of transition rules which define the behaviour of each process. In the above example, the set Q consists of four states (green, black, blue, and red), while the set T consists of six rules, namely three local rules (t2, t5, and t6), two universal rules (t1 and t4), and one existential rule (t3).

Transition Systems
A parameterized systems P = (Q, T ) induces a transition systems T = (C, −→), where C is the set of conﬁgurations and −→ is a transition relation on C. A configuration is a word in Q∗, where each element of the word represents the local state of one process.
Let us consider the example of Section 2. The word  represents a configuration in an instance of the system with five processes that are in their green, blue, red, blue, and black states, in that order. Since there is no bound on
the size of configurations, the set of configuration is infinite.
We define the transition relation −→:=  t∈T −→, where −→ is a relation on
t	t



−→t
depends on the type of t (whether it is local, existential, or universal). We will

consider three transition rules from Figure 1 to illustrate the idea.
The local rule t2 induces transitions of the form
t2
−→
Here the active process changes its local state from black to blue.
The existential rule t3 induces transitions of the form
t3
−→
The blue process can perform the transition since there is a black process in its left context. However, the transition is not enabled from the configuration 

, since there are no red, blue, or black processes in the left context of the process trying to perform the transition.
The universal rule t4 induces transitions of the form
t4
−→
The active process  can perform the transition since all processes in its left con- text are green. On the other hand, neither of the blue processes can perform the transition form the configuration  since, for each one of them, there is at least one process in its left context which is not green.

We use ∗ to denote the reflexive transitive closure of −→. For sets C
1
and C2

∗
of configurations, we use C1 −→ C
to denote that there are configurations c1 ∈ C1

∗
and c2 ∈ C2 such that c1 −→ c .
An initial conﬁguration is one in which all processes are in their initial (green) states. We use Init to denote the set of initial configurations. Examples of initial configurations are  and  corresponding to instances of the system with two and four processes respectively. Notice that there is an infinite set of initial configurations, namely one for each size of the system.
As mentioned in Section 2, the protocol is intended to observe mutual exclusion. In other words, we are interested in verifying a safety property. To do this we characterize the set Bad of configurations: all configurations which contain at least two red processes. Examples of configurations in Bad are  and 
. Showing the safety property amounts to proving that the protocol, starting from an initial configuration, will never reach a bad configuration. In other words, we want to answer the question whether Init −∗→ Bad .

Ordering
In this section, we define an ordering on configurations, which we use to define bad sets of configurations, and hence also to formulate the class of safety properties which we consider in this tutorial.
For configurations c1 and c2, we use c1 ≤ c2 to denote that c1 is (not necessarily contiguous) subword of c2. For instance, we have  ≤ . A set U of configurations is said to be upward closed, if whenever c ∈ U and c ≤ c' then c' ∈ U . For a configuration c, we use c to denote the upward closed set U := {c'| c ≤ c'}, i.e., c contains all configurations which are larger than c w.r.t. the ordering ≤. In such a case, we call c the generator of U .
We are interested in upward closed sets for two reasons. First, all sets of bad configurations which we work with are upward closed. For instance, in the example of Section 2-3, the set Bad of configurations violating mutual exclusion are those which contain at least two red processes. The set is upward closed since whenever a configuration contains two red processes then any larger configuration will also contain (at least) two red processes.
The second reason why we are interested in upward closed sets is that they have an efficient symbolic representation. In fact, it can be shown that each upward

closed set can be characterized by a ﬁnite set of generators. More precisely, for an

upward closed set U , there are configurations c ,... ,c  with U = c ∪ ··· ∪ c
. For

1	n	 ^1	^n
instance, the set Bad above has a single generator, namely   . Thus, operations
which manipulate upward closed sets can be translated into operations which ma- nipulate words. In this manner we avoid using heavy machinery, such as regular languages, when performing reachability analysis. This makes our approach much more efficient in practice compared to automata-based methods such as regular model checking [14,7,9].
We will check safety properties using backward reachability analysis. For a set C of configurations, we use Pre(C ) := {c| ∃c' ∈ C · c −→ c'}. In other words, the set Pre(C ) contains exactly all configurations from which a configuration in C can be reached through a single application of the transition relation.
To solve the safety problem, we present a scheme for backward reachability analysis. We start with the set Bad of bad configurations which is upward closed. Then, we apply the function Pre repeatedly generating a sequence U0, U1, U2,... of sets of configurations, where U0 := Bad , and Ui+1 := Ui ∪ Pre(Ui ) for i ≥ 0. We observe that the set Ui characterizes the set of configurations from which the set Bad is reachable within i steps. We would like the sets Ui to be upward (so that we can represent them by their finite sets of generators). In order to achieve that, we introduce a sufficient condition, namely that of monotonicity. Monotonicity implies that Pre(U ) is upward closed whenever U is upward closed. Since U0 is upward closed by definition, monotonicity would imply that all the sets Ui are upward closed.
A transition system is said to be monotonic if ≤ forms a simulation on the set of configurations. In other words, for all configurations c1, c2, c3, whenever c1 ≤ c2 and c1 −→ c3 then c2 −→ c4 for some c4 ≥ c3.
Monotonicity implies that upward closedness is preserved through the applica- tion of Pre as follows. Consider an upward closed set U . Let c1 be a member of Pre(U ) and let c2 ≥ c1. We will show that c2 is also a member of Pre(U ). Since c1 ∈ Pre(U ), we know by definition that there is a c3 ∈ U such that c1 −→ c3. By monotonicity it follows that there is a c4 such that c3 ≤ c4 and c2 −→ c4. From c3 ∈ U and c3 ≤ c4 it follows that c4 ∈ U . This means that we have found a configuration c4 ∈ U such that c2 −→ c4, which implies that c2 ∈ Pre(U ).

Monotonic Abstraction
In this section, we define an abstraction that generates an over-approximation of the transition system. The abstract transition system is monotonic, thus allowing to work with upward closed sets. In fact, we first show that local and existential transitions are monotonic, and hence need not be approximated. Therefore, we only provide an over-approximation for universal transitions.
Consider the local transition

t2
c1 =	−→
 = c3

in which a process changes state from black to blue. Consider the configuration c2 =  that is larger than c1. Clearly, c2 can perform the local transition
t
c2	−→	c4
leading to c4 ≥ c2. Local transitions are monotonic, since the active process in the small configuration (the black process in c1) also exists in the larger configuration (i.e., c2). A local transition does not check or change the states of the passive processes; and hence the larger configuration c2 is also able to perform the transition, while maintaining the ordering c3 ≤ c4.
Consider the existential transition

t
c1	−→
 = c3

Let us observe that the configuration c1 can be divided into three parts: the active process , the left context  , and the right context . Furthermore, the left context contains a witness which enables the transition. Consider the configu- ration c2 =	that is larger than c1. Also, the configuration c2 can be divided into three parts: the active process , the left context , and the right context . Notice that the left context of c2 is larger than the left context of c1, and hence the former will also contain the witness . This means that c2 can perform the same transition

t
c2	−→
 = c4

leading to c4 ≥ c3.
Next, we motivate why universal transitions are not monotonic. Consider the universal transition

t
c1	−→
 = c3.

The transition is enabled since all processes in the left context of the active process satisfy the condition of the transition (they are green). Consider the configuration c2 = . Although c1 ≤ c2, the universal transition t4 is not enabled from c2 since the left context of the active process contains processes that violate the condition of the transition. This implies that universal transitions are not monotonic.
In order to deal with non-monotonicity of universal transitions, we will work with an abstract transition relation −→A that is an over-approximation of the con- crete transition relation −→. We call −→A the monotonic abstraction of −→. The
relations −→t A coincides with −→t  in case of local and existential transitions (in these
two cases, the relation is monotonic and hence no over-approximation is needed).

In case t is universal, we have c1 −→t
A c2 iff c'
−→t
c2 for some c'
≤ c1. In other

words, c1 −→t
A c2 if c1 can first “transform” to a smaller configuration from which

it can perform the transition. This means for instance that
t4
−→A
since

t
−→
The abstract transition relation is monotonic also w.r.t. universal transitions, since c1 ≤ c2 and c1 −→A c3 implies that c2 −→A c3. Notice that in the over- approximation, we delete those processes in the configuration that violate the con- dition of the universal transition.
Since the abstract transition relation −→A is an over-approximation of the orig- inal transition relation −→, it follows that if a safety property holds in the abstract model, then it will also hold in the concrete model.

Backward Reachability Algorithm
We present a backward algorithm for approximated reachability analysis. The idea is that we compute the function Pre w.r.t. the abstract relation −→A rather than the concrete relation −→. This means that we can work with upward closed sets in the scheme for backward reachability analysis presented in Section 4. Recall that we generate a sequence U0, U1, U2,... of sets of configurations, where U0 := Bad , and Ui+1 := Ui ∪ Pre(Ui ) for i ≥ 0. Since U0 is upward closed by definition, and
−→A is monotonic, all the sets Ui are upward closed.
Several properties of upward closed sets enable us to transform the backward reachability scheme into an algorithm. First, each set can be represented by its finite set of generators. Given a configuration c, we show below how to compute the set of generators for the set Pre(c). This means that we only need to work with generators (configurations) as a symbolic representation of the sets which arise in the algorithm.
Now, we show that the algorithm is guaranteed to terminate. Suppose that the algorithm, during its execution, produces two generators c1, c2 such that c1 ≤

c . Since c  ⊆ c , we can safely discard c
from the analysis without the loss of

2	^2	^1	2
any information. In such a case, we say that c2 is subsumed by c1. Discarding
configurations in this manner makes it possible to apply the methodology of [2]. According to [2], termination of the algorithm is guaranteed since ≤ is a so called well quasi-ordering [13]. That ≤ is a well quasi-ordering means that for any infinite sequence c0, c1, c2,... of configurations, there are i < j such that ci ≤ cj.
It remains to show that we can compute the generators of Pre(c) for any con- figuration c. We define Pre(c) := t ∈T Pret (c) where Pret gives the generators of the set of configurations from which we can reach c through one application of the transition rule t. The definition of Pret depends on the type of t (whether it is local,
existential, or universal). We will consider different transition rules in Figure 1 to illustrate how to compute Pre (c).
t ^



Pret5 
  =   ,


In other words, the predecessor set is characterized by one generator, namely 

. Strictly speaking, the set contains also a number of other configurations such as
. However such configurations are subsumed by the original configuration
, and therefore we will not include them in the set.
For existential transitions, there are two cases depending on whether a witness exists or not in the configuration. Consider the existential rule t3 in Figure 1. We
have

Pre


t3
  =   ,

In the above case, there is a witness  in the left context of the active process . On the other hand, we have



Pre




t3
= ⎧⎪⎨
⎪⎪⎩
 ,  ⎫⎪⎬
  
 ,  ⎪⎪⎭

In this case there is no witness available in the left context of the active process. Therefore, we add a witness explicitly in each possible state (, , or ), and each possible place in the left context of the active process. Notice that the sizes of the new generators (four processes) is larger than the size of the original configuration (three processes). This means that the sizes of the configurations generated by the backward algorithm may increase, and hence there is no bound a priori on the sizes of the configurations. However, termination is still guaranteed to the well quasi-ordering of ≤.
For universal conditions, we check whether there are any processes in the con- figuration violating the condition. Consider the universal rule t4 in Figure 1. Then

Pret4	 = ∅

since there is a black process in the left context of the potential active process (which is in state  ). On the other hand


Pret4 
  =   ,


since all processes in the left context of the active process are in their green states.

Example
We show how the backward reachability algorithm runs on our running example. We start by the generator
g0 = 
of the set of bad configuration. The only transition which might be enabled back- wards from a red state, is the one induced by the rule t4. From the two red processes

in g0 only the left one can perform t4 backwards (the right process cannot perform
t4 backwards since its left context contains a process not satisfying the condition of the quantifier):
Pret4 (g0 )= g1 =  ,
From g1, two rules are enabled backwards (both from the blue process): the local rule t2


and the existential rule t3
Pret2 (g1 )= g2 =  ,

Pret3 (g1 )=   ,  ,  ,
Since a witness is missing in the left context, we add it explicitly. All the three generators in Pret3 (g1 ) are subsumed by g1.
One rule is enabled backwards from g2, namely the local rule t5 from the black process:
Pret5 (g2 )= {g0 }
Notice that the universal transition t1 is not enabled from the black process, since there is another process (the red process) in the configuration that violates the condition of the quantifier. At this point, the algorithm terminates, since it is not possible to provide any new generators which are not subsumed by the existing ones.

Since there is no initial configuration (with only green processes) in g0
∪ g1
∪ g ,

the set of bad configurations is not reachable from the set of initial configurations in the abstract semantics. Therefore, the set of bad configurations is not reachable from the set of initial configurations in the concrete semantics, either.

Extensions
In our earlier works [4,3], we have considered the following extensions of the basic model of parameterized systems we present in this paper.

Local and Global Variables
We allow each process to have a set of variables which range over finite domains, and which the process can read and write locally. We also allow a finite number of global variables which all the processes may read and write.

Broadcast and Binary Communication
In a broadcast transition, an arbitrary number of processes change states simul- taneously. The broadcast is initiated by a process, called the initiator. Together with the initiator, an arbitrary number of processes change state simultaneously. In binary communication two processes perform a rendez-vous changing states simul- taneously.

Dynamic Behaviour
We allow dynamic creation and deletion of processes.

Numerical Variables
We consider parameterized systems where the individual processes operate on numerical variables which range over the natural numbers. The conditions on the numerical variables are stated as gap-order constraints. Gap-order constraints [15] are a logical formalism in which we can express simple relations such as lower and upper bounds on the values of individual variables; and equality, and gaps (minimal differences) between values of pairs of variables.

References
Parosh Aziz Abdulla, Ahmed Bouajjani, Jonathan Cederberg, Fr´ed’eric Haziz, and Ahmed Rezine.
Monotonic abstraction for programs with dynamic memory heaps. In Proc. 20th Int. Conf. on Computer Aided Verification, 2008.
Parosh Aziz Abdulla, Karlis Cˇer¯ans, Bengt Jonsson, and Yih-Kuen Tsay. General decidability theorems
for infinite-state systems. In Proc. LICS ’96, 11th IEEE Int. Symp. on Logic in Computer Science, pages 313–321, 1996.
Parosh Aziz Abdulla, Giorgio Delzanno, and Ahmed Rezine. Parameterized verification of infinite-state processes with global conditions. In Proc. 19th Int. Conf. on Computer Aided Verification, volume 4590 of Lecture Notes in Computer Science, pages 145–157, 2007.
Parosh Aziz Abdulla, Noomene Ben Henda, Giorgio Delzanno, and Ahmed Rezine. Regular model checking without transducers (on efficient verification of parameterized systems). In Proc. TACAS ’07,
13th Int. Conf. on Tools and Algorithms for the Construction and Analysis of Systems, volume 4424 of Lecture Notes in Computer Science, pages 721–736. Springer Verlag, 2007.
Parosh Aziz Abdulla, Noomene Ben Henda, Giorgio Delzanno, and Ahmed Rezine.	Handling
parameterized systems with non-atomic global conditions. In Proc. VMCAI ’08, 9th Int. Conf. on Verification, Model Checking, and Abstract Interpretation, 2008.
Parosh Aziz Abdulla and Bengt Jonsson. Verifying programs with unreliable channels. In Proc. LICS ’93, 8th IEEE Int. Symp. on Logic in Computer Science, pages 160–170, 1993.
Parosh Aziz Abdulla, Bengt Jonsson, Marcus Nilsson, and Julien d’Orso. Regular model checking made
simple and efficient. In Proc. CONCUR 2002, 13th Int. Conf. on Concurrency Theory, volume 2421 of Lecture Notes in Computer Science, pages 116–130, 2002.
Parosh Aziz Abdulla and Aletta Nyl´en. Timed Petri nets and BQOs. In Proc. ICATPN’2001: 22nd Int. Conf. on application and theory of Petri nets, volume 2075 of Lecture Notes in Computer Science, pages 53 –70, 2001.
Bernard Boigelot, Axel Legay, and Pierre Wolper. Iterating transducers in the large. In Proc. 15th Int. Conf. on Computer Aided Verification, volume 2725 of Lecture Notes in Computer Science, pages 223–235, 2003.
G. Delzanno. Automatic verification of cache coherence protocols. In Emerson and Sistla, editors, Proc.
12th Int. Conf. on Computer Aided Verification, volume 1855 of Lecture Notes in Computer Science, pages 53–68. Springer Verlag, 2000.
E.A. Emerson and K.S. Namjoshi. On model checking for non-deterministic infinite-state systems. In
Proc. LICS ’98, 13th IEEE Int. Symp. on Logic in Computer Science, pages 70–80, 1998.
J. Esparza, A. Finkel, and R. Mayr. On the verification of broadcast protocols. In Proc. LICS ’99,
14th IEEE Int. Symp. on Logic in Computer Science, 1999.
G. Higman. Ordering by divisibility in abstract algebras. Proc. London Math. Soc. (3), 2(7):326–336, 1952.
Y. Kesten, O. Maler, M. Marcus, A. Pnueli, and E. Shahar. Symbolic model checking with rich assertional languages. Theoretical Computer Science, 256:93–112, 2001.
P. Revesz. A closed form evaluation for datalog queries with integer (gap)-order constraints. Theoretical Computer Science, 116(1):117–149, 1993.
