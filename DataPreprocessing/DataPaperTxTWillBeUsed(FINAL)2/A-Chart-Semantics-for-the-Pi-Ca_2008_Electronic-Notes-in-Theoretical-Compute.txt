Electronic Notes in Theoretical Computer Science 194 (2008) 3–29	
www.elsevier.com/locate/entcs
A Chart Semantics for the Pi-Calculus
Johannes Borgstro¨m1
TU Berlin
Andrew D. Gordon2 Andrew Phillips3
Microsoft Research

Abstract
We present a graphical semantics for the pi-calculus, that is easier to visualize and better suited to expressing causality and temporal properties than conventional relational semantics. A pi-chart is a finite directed acyclic graph recording a computation in the pi-calculus. Each node represents a process, and each edge either represents a computation step, or a message-passing interaction. Pi-charts enjoy a natural pictorial representation, akin to message sequence charts, in which vertical edges represent control flow and horizontal edges represent data flow based on message passing. A pi-chart represents a single computation starting from its top (the nodes with no ancestors) to its bottom (the nodes with no descendants). Unlike conventional reductions or transitions, the edges in a pi-chart induce ancestry and other causal relations on processes. We give both compositional and operational definitions of pi-charts, and illustrate the additional expressivity afforded by the chart semantics via a series of examples.
Keywords: pi-calculus, causality, message sequence charts.


Message Sequence Charts as Process Histories
Message sequence charts (MSCs) are a successful graphical notation for describing the history of interactions between system components running in parallel. They are standardized by the ITU in connection with the Specification and Description Language (SDL) [22,21], and are included, as sequence diagrams, in the Unified Modeling Language (UML) [33]. MSCs are widely used to specify the behaviour of systems made up of multiple components; a substantial literature addresses the problems of defining formal semantics for MSCs and deriving implementation code from MSCs used as specifications [27,2].

1 Email: jobo@cs.tu-berlin.de
2 Email: adg@microsoft.com
3 Email: aphillip@microsoft.com

1571-0661 © 2008 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.11.002

This paper explores a different direction, the use of MSCs as a formal semantics, in terms of potential execution histories, for known code. We work within a process calculus, the pi-calculus, although the ideas should apply to other languages. The semantics of the pi-calculus is typically specified as a reaction or reduction rela- tion, or as a labelled transition system [30,39]. We propose a form of MSC as an alternative.
In fact, MSCs are already used informally to illustrate computations in process calculi. For example, Bonelli and Compagnoni [5] visualize intended histories of pi-calculus processes with MSCs. Phillips, Yoshida, and Eisenbach [36] illustrate the semantics of a distributed abstract machine for the boxed ambient calculus [11] with MSCs. Jeffrey and Rathke [23] consider traces induced by a labelled transition system, and make informal connections between these and sequence diagrams. A paper [4] on the TulaFale process language uses an MSC to show an attack on a secu- rity protocol. In these papers, the formal semantics is given by relations and MSCs appear only informally. The attraction of MSCs is that they pictorially represent the identity of individual process components as they evolve and interact with other components; the conventional reduction semantics hides this information. Since the history and identity of components is valuable for expressing formal properties of systems, we go further and ask whether MSCs are suitable in themselves as a formal semantics.
To explain some of the basic ideas and to see some of the benefits of a chart semantics for the pi-calculus, we describe a simple example. We suppose there is a single stateful server S(n, s) which when called with a value n' and a session channel c, responds by sending on c its current state n, provisions a private service R(c) to handle the session, and changes state to S(n', s). Here is pi-calculus code for such a server, together with a client C(n', s) that initiates such a session, and then runs A(n, c) where n is the previous state of the server and c is the session channel.






S(n, s) := s(n', c).(c⟨n⟩.R(c) | S(n', s))
C(n', s) := (νc)s⟨n', c⟩.c(n).A(n, c)






The pi-chart below shows interactions between one server and two clients. Pi-charts are in the spirit of MSCs but do not conform to the letter of the standard [21]. In particular, we allow processes to fork, and to generate fresh names.


C(n2, s)






new c2











A(n1, c2)
A pi-chart is a directed acyclic graph. Both nodes and edges are labelled. As in this example we usually omit some node and edge labels to avoid clutter. Nodes are labelled with processes. Downward (or oblique) edges represent process evolution and are labelled with next labels, including new c, which represents the generation of a channel c, and ε, which represents the unfolding of a process constant or parallel composition. The next label ε is generally omitted. Horizontal edges represent interaction, and are labelled with communication labels, ⟨c⟩ on a.
A pi-chart represents a single computation starting from its top (the nodes with no ancestors) to its bottom (the nodes with no descendants), with restrictions corresponding to any new names. The computation in the example corresponds to the following series of reductions in a conventional reduction semantics.
C(n1, s) | S(n, s) | C(n2, s) →∗ (νc1)(νc2)(A(n, c1) | R(c1) | S(n2, s) | R(c2) | A(n1, c2)) As a means of visualizing computation, pi-charts have advantages over the con-
ventional relational semantics. A series of computation steps in the relational se-
mantics is hard to visualize; listing the series of intermediate states can lead to an overwhelming amount of syntactic detail. Conventionally, reduction and transition relations are closed up to associativity and commutativity of parallel composition. Hence, it is hard to track the evolution of individual threads within a system. One solution is to introduce syntax for abstract locations [13], although this increases the amount of syntactic detail when visualizing reductions. On the other hand, pi-charts have a two dimensional representation that is easily rendered pictorially. The graphical structure allows detail, such as process labels, to be omitted with
little risk of ambiguity. Vertical paths in a chart track the evolution of individual processes; in our example, we see that S(n, s) is an ancestor of R(c1), S(n2, s), and R(c2), but not of the other processes at the bottom of the chart. (There is, though, a causal relation between S(n, s) and all the processes at the bottom.)
In general, MSCs have been highly successful as a means of visualising and vali- dating dynamic behaviour of concurrent systems, and their graphical representation

has also facilitated communication between groups with different backgrounds [28]. We believe that a sequence chart representation of pi-calculus computations could have similar benefits.
We proceed as follows. In Section 2 we formally define a chart semantics for a synchronous pi-calculus with mixed choice. We give three separate inductive char- acterizations of the set of pi-charts; Theorem 2.5 establishes the equivalence of these characterizations. As evidence for the expressivity of pi-charts, we give a series of examples of correctness properties expressible using charts. Section 3 investigates the relationship of pi-charts to a conventional reduction semantics. Theorem 3.7 shows the relation between the parallel compositions of processes at the top and bot- tom of a pi-chart coincides with the reflexive and transitive closure of a conventional reduction semantics, up to top-level restrictions. Theorem 3.11 relates structural congruence of processes with a structural congruence on graphs. Sections 4 and 5 conclude and discuss related work.
Appendix A shows how charts can usefully illustrate the behaviour of biological reactions expressed in the pi-calculus. Appendix B is a case study of proving prop- erties expressible with pi-charts. We introduce a type system built from standard notions of name groups, group creation, and usage bounds on channels. Formal data flow and usage properties are conveniently expressed using charts. Theorem B.1 es- tablishes bounds on data flow and channel usage guaranteed by the type system.

A Chart Semantics
We consider a polyadic pi-calculus, with synchronous communication, mixed choice, and process constants. Standard variations such as replication operators or asyn- chronous output can be accommodated in our framework, but we omit the details. The only unusual feature is that we annotate the autonomous τ prefixes with terms t from a free algebra A over names; these terms serve various purposes, such as representing events (for correspondence assertions [20]) and type annotations (for the system in Appendix B).
Syntax for Pi-Calculus Processes: P
a, c, x	names and variables

M ::= M + M | a⟨˜c⟩.P | a(x˜).P | τt.P   mixed choice
P, Q, R ::= M | (P | Q) | (νa)P | A(˜c) | 0 process
Let P be the set of all processes. Names identify communication channels. We write fn(P ) for the set of names occurring free in P . Let P {y/x} be the outcome of substituting y for each free occurrence of x in P . We write a, c, x for finite tuples of names.
The intended meaning of the process syntax is as follows. An output a⟨c⟩.P
sends the tuple  on channel  , to become  . An input ( )  receives a tuple , of the same length as x, off channel a, to become P  ec/xe}. In a(x).P , the names
x are bound with scope P , and assumed to be pair-wise distinct.  A process τt.P
autonomously marks the event t, and becomes P . A choice M + N behaves either

as M or N . A parallel composition P | Q behaves as P running in parallel with Q. A restriction (νa)P creates a fresh name a and becomes P ; the name a is bound and has scope P . We assume a given constant library, a finite collection of process constants, each of which has a deﬁnition, written  ( ) :=  , where fn(  )   .
Given such a definition, a process A(c) behaves as P ec/xe}. Finally, 0 does nothing.
We identify phrases of syntax up to consistent renaming of bound names; for instance, (νa)P = (νb)P  b/a} if b ∈/ fn(P ). We also identify processes up to asso-
ciativity and commutativity of the choice operator.

Labelled graphs
Charts are particular labelled graphs. Nodes are drawn from an infinite set of node identiﬁers, I, ranged over by ι. Nodes are labelled with pi-calculus processes. Each edge has either a next label (nl) or a communication label (⟨c⟩ on a). A next label represents an event, and labels an edge from a process to its successor; the next label new x, where the free name x is globally fresh, represents name generation. Annotation t represents a tau step, while next step ε represents all other kinds of process evolution, including unfolding of process constants and parallel compositions. A communication label represents a message passing from an output to an input.
Edge Labels for the Pi-Calculus: nL and L
nl ∈ nL ::=	next label
new x	name generation
t	annotation
ε	next step
l ∈ L ::=	edge label
nl	next label
⟨˜c⟩ on a	communication
A labelled graph is a pair (N, E) where N : I → P and E : I × I → L are finite maps. Given G = (N, E), we write Nt for N and Et for E. A graph G is well-formed iff dom(Et) ⊆ (dom(Nt) × dom(Nt)). The following notations express graphs as compositions of labelled nodes and edges.

l
ι −d ι'
:= (∅, {((ι, ι'), l)})

ι • P := ({(ι, P )}, ∅)
G ∪ H := (Nt ∪ NH, Et ∪ EH ) when a well-formed graph
G \ H := (Nt \ NH, Et \ EH )

Primitive pi-charts
We begin our chart semantics by defining a set of primitive pi-charts. Let a primitive chart be any instance of one of the following five schemas. Here and elsewhere we omit the ϵ label from edges. We refer to nodes with the variables ι1, ι2, ι3, ι4, assumed pair-wise distinct. Let Cp be the set of primitive charts.

Primitive Charts: Cp

ι1 τt.P + M t
ι2	P




a⟨c˜⟩.P + M
⟨c˜⟩ on a	a(x˜).Q + N
ι1	ι2

ι1	A(c˜)




P	ι3
ι4  Q c˜/x˜}
ι2	P c˜/x˜}

when A(x˜) := P



Since we identify processes up to renaming of bound names, from (νa)P we get infinitely many primitive charts of the first form above, one for each possible choice of a.
The top and bottom of pi-charts
Each pi-chart has a top, the nodes with no predecessors, and a bottom, the nodes with no successors. A core idea, formalized later as Theorem 3.7, is that a pi-chart represents a computation starting with the processes at the top, and ending with those at the bottom. We formalize top and bottom below, together with other notations needed for a compositional definition of pi-charts: new(G) is the set of names generated within a chart; Gnil is the edgeless graph consisting of the terminal nodes of G, that is, those labelled with 0.
GT := ({(ι, P ) | Nt(ι) = P ∧ ¬(∃ι', nl. Et(ι', ι) = nl)}, ∅)
G⊥ := ({(ι, P ) | Nt(ι) = P ∧ ¬(∃ι', nl. Et(ι, ι') = nl)}, ∅)
new(G) := {a | new a ∈ range(Et)} Gnil := ({(ι, 0) | Nt(ι) = 0}, ∅) It := dom(Nt)
We write nnt(S) for ∪ι∈Sfn(Nt(ι)) when S ⊆ It. When speaking about a particular graph G, we often write nn(S) for nnt(S). We let nn(G) := nnt(It). One invariant we want to preserve is that all names that occur in a chart are either free in the processes at the top of the chart or freshly created. A well-named chart is one satisfying nn(G) ⊆ nn(GT) new(G); note that all primitive charts are well- named.

Three equivalent characterizations of pi-charts
We can now define how to build larger charts from primitive ones. We give three definitions, two compositional and one operational in flavour, and show them equiv- alent.

Intuitively, two pi-charts may be composed in sequence if the bottom of the first equals the top of the second. Dually, two pi-charts may be composed in parallel if they are completely disjoint. Given these notions, a pi-chart is either a singleton chart ι • P , a primitive chart G ∈ Cp, or a composition G ∪ H where G and H are composable, either in sequence or in parallel.
The following definitions make these intuitions precise; various freshness condi- tions are needed to guarantee global uniqueness of generated names.
Sequential Composition: S(G, H)
If G and H are well-formed then S(G, H) iff

It ∩ IH = It⊥ \ I(t⊥)

nil
= IHT ;

new(H) ∩ new(G) = nn(GT) ∩ new(H) = ∅; and
whenever ι ∈ It ∩ IH then Nt(ι) = NH (ι).
Parallel Composition: P (G, H)

If G and H are well-formed then P (G, H) iff
It ∩ IH = ∅; and
new(G) ∩ new(H) = nn(GT) ∩ new(H) = nn(HT) ∩ new(G) = ∅.
A First Characterization of Pi-Charts: CSP




ι • P ∈ CSP
G ∈ Cp
G ∈ CSP
G, H ∈ CSP	S(G, H) G ∪ H ∈ CSP
G, H ∈ CSP	P (G, H) G ∪ H ∈ CSP

Although sequential and parallel compositions are intuitive and easy to define, they lack some algebraic properties useful in proofs. As an example, if P (G1, G2) and S(G1 ∪ G2,H), we neither have S(G1,H) nor P (G1,H), in general. Moreover, inductive proofs using the definition of CSP require two inductive cases, where one ought to suffice. To overcome these problems, we unify parallel and sequential composition into liberal composition, and obtain a second definition of pi-charts.
Liberal Composition: L(G, H)
If G and H are well-formed then L(G, H) (“G before H”) iff
It ∩ IH ⊆ It⊥ and It ∩ IH ⊆ IHT ;
new(H) ∩ new(G) = nn(GT) ∩ new(H) = nn(HT \ G) ∩ new(G) = ∅; and
whenever ι ∈ It ∩ IH then Nt(ι) = NH (ι).
A Second Characterization of Pi-Charts: CL




ι • P ∈ CL
G ∈ Cp
G ∈ CL
G ∈ CL	H ∈ CL	L(G, H)


G ∪ H ∈ CL



By comparing definitions, it is clear that liberal composition is more permissive than either parallel or sequential composition.  Crucially, liberal composition is

associative, and preserves well-namedness.
Lemma 2.1 Assume that graphs G1, G2, G3 are well-named.
If L(G1, G2) and L(G1 ∪ G2, G3), then L(G2, G3) and L(G1, G2 ∪ G3).
If L(G2, G3) and L(G1, G2 ∪ G3), then L(G1, G2) and L(G1 ∪ G2, G3).
Lemma 2.2 If G1, G2 are well-named and L(G1, G2) then G1 ∪ G2 is well-named.
Proof.
n(G1 ∪ G2)
= n(G1) ∪ n(G2)
⊆ nn(G1T) ∪ new(G1) ∪ nn(G2T) ∪ new(G2)
= new(G1 ∪ G2) ∪ nn(G1T) ∪ n(It2T )
⊆ new(G1 ∪ G2) ∪ nn(G1T) ∪ n(It2T − join(G1, G2)) ∪ n(join(G1, G2))
= new(G1 ∪ G2) ∪ nn(G1 ∪ G2T) ∪ n(join(G1, G2))
Then n(join(G1, G2)) ⊆ n(It1⊥ ) ⊆ n(G1) ⊆ nn(G1T) ∪ new(G1) ⊆ n(It1T ∪ (It2T \
It1 )) ∪ new(G1) ⊆ nn(G1 ∪ G2T) ∪ new(G1 ∪ G2).
Moreover,
nn(G1 ∪ G2T) ∩ new(G1 ∪ G2)
= (nn(G1T) ∪ nn(It2T − It1⊥ )) ∩ (new(G1) ∪ new(G2))
= (new(G1) ∩ nn(It2T − It1⊥ ))
= ∅


Corollary 2.3 If G ∈ CL then G is well-named.
Proof. By Lemma 2.2 and nn(G) ⊆ nn(GT) ∪ new(G) for all primitive pi-charts
G.	 
By associativity (Lemma 2.1) we obtain the following iterative account of CL. Lemma 2.4 G ∈ CL iff there exist pi-charts H1,..., Hn ∈ Cp ∪ {ι • P | ι ∈ I,P ∈
P} such that G = H1 ∪ ... ∪ Hn and L(H1 ∪· · ·∪ Hi—1, Hi) for each i ∈ 2..n.
Proof. The implication from right to left holds by a simple induction on n.
We prove the other direction for all derivations D of G ∈ CL by induction on the depth of derivations of G ∈ CL. We define the right complexity r of a derivation D as r(D) := 0 for a single primitive rule D and r(b-before(D1, D2)) := r(D1)+ (r(D2)+ 1)2.
The base case (G ∈ CP ∪ {ι • P | ι ∈ I,P ∈ P}) is trivial. For the induction case, we assume that the lemma holds for all pi-charts G ∈ CL with derivations of depth strictly less than k.

Assume that D := b-before(D1, D2) is a derivation for G ∈ CL with depth k and the smallest r(D) among all derivations for G with depth k, and that D1 and D2 are derivations of G1 ∈ CL and G2 ∈ CL, respectively. If D2 is a leaf then G2 = H ∈ Cp ∪ {ι • P | ι ∈ I,P ∈ P}, and we have by the induction hypothesis that G1 = H1 ∪ ... ∪ Hn where H1, . . . , Hn are in Cp ∪ {ι • P | ι ∈ I,P ∈ P} such that L(H1 ∪ · · · ∪ Hi—1, Hi) for each i ∈ 2..n. Thus, G = H1 ∪ ... ∪ Hn ∪ H, and moreover L(G1,H) by assumption.
If D2 is not a leaf, we derive a contradiction.  In this case, D2 = b-before(D21, D22) for some D21, D22 deriving G21 and G22, respectively. Lemma  2.1  then  gives  that  L(G1, G21)  and  L(G1 ∪ G21, G22).   Then b-before(b-before(D1, D21), D22) is a derivation of G ∈ CL and
r(b-before(b-before(D1, D21), D22))
= r(D1)+ (r(D21)+ 1)2 + (r(D22)+ 1)2
< r(D1)+ (r(D21)+1+ (r(D22)+ 1)2)2
= r(D)

which is a contradiction.	 
For our final definition, we start with an initial set of unconnected nodes and add primitive charts one by one to the bottom. This amounts to an operational semantics. (We use it as the basis of two separate pi-calculus implementations that output pi-charts in the dot language, suitable for rendering with Graphviz [19].) We define chart extension G → G' (“G extends to G'”) as follows, and hence obtain a third characterization of pi-charts.
Chart Extension G → G' and a Third Characterization of Pi-Charts CI

G → G' iff there is H ∈ Cp such that G' = G ∪ H and L(G, H) and IH
CI := {G | GT →∗ G}
⊆ It⊥



Theorem 2.5 CSP = CL = CI
Proof. We begin by proving that CL ⊆ CI , that is, that G ∈ CL implies that
GT →∗ G. Trivially, L(GT, G). By Lemma 2.4, there exist primitive pi-charts H1,
..., Hn such that G = H1 ∪ ... ∪ Hn and L(H1 ∪· · · ∪ Hi—1, Hi) for each i ∈ 1..n. Since L(GT, H1 ∪ ... ∪ Hn) Lemma 2.1(i) gives that L(GT, H1 ∪ ... ∪ Hn—1) and L(GT ∪ H1 ∪ ... ∪ Hn—1, Hn).

We also have IHnT ⊆ I(tT∪H1∪...∪Hn—1)
tively, GT →n G.
, so GT ∪ H1 ∪ ... ∪ Hn—1 → G. Induc-

Secondly, we prove that CI ⊆ CSP , that is, that if GT →∗ G then G ∈ CSP , by induction on the number of extensions. For the base case, G = GT = (Nt, ∅) ∈ CSP , by parallel composition of charts of the form ι • P . For the induction case

we have G = G' ∪ H with G' ∈ CI , H ∈ Cp, L(G',H) and IH
⊆ It'⊥
. As above

(It'⊥
\ It'

nil
) ∪ H ∈ CSP . By induction G' ∈ CSP . Since 0 /∈ dom(NI
) we get

S(G', (It
\ It'

nil
) ∪ H), so G' ∪ H ∈ CSP .

Finally, since S(G, H) ∨ P (G, H) =⇒ L(G, H), CSP ⊆ CL by induction. 

Expressible properties
To end this section, we discuss some properties expressible with pi-charts. We may see the edges of a chart G as a relation −dt ⊆ I × L × I. We split this relation,

writing	on
⟨ec⟩ on a

ι1 dt ι2 for ∃c, a. ι1 −−−−dt ι2 and ι1 ι2 for Et(ι1, ι2) ∈ nL. Hence, we
define some causal relations, roughly following the terminology of Priami [38].
Causal Relations:

[Ancestor]
:=  ∗
[Causes]
:= (
on  )∗	[Enables]
:= (
on	( on
)—1)∗

t	t	t
t∪ dt
t	t∪ dt ∪ dt


The node receiving a message enables the sending node and all of its descendants. This is due to the synchronous nature of communication: the sender proceeds with the knowledge that the message was received, just as if they had received an explicit acknowledgement of reception. The “causes” relation only flows in the direction of communicated messages; it is the equivalent in our setting to Lamport’s “happened before” relation [26].
Another causal semantics for the pi-calculus is proved semantics [9,17,16], which makes a distinction between subject and object dependencies [7]. Since the latter are only defined in terms of “bound output” labels of a labelled transition system,
they have no direct counterpart in our setting where all communication is internal to a pi-chart.
Let the nodes with ι as an ancestor be the descendants of ι. If ι2, ι3 are the nodes in the primitive chart for parallel composition, the sets of descendants of ι2 and ι3
are disjoint. (The “causes” and “enables” relations do not possess this property.)
є	є
Lemma 2.6 If a pi-chart G has distinct edges ι1 −d ι2 and ι1 −d ι3 then there is no ι4 such that both ι2 [Ancestor]t ι4 and ι3 [Ancestor]t ι4.
We can concisely express some intensional properties of the interactions recorded in a chart G as follows (omitting the subscripts t).
⟨a⟩ on ec
“I got an answer to this message (ι1 −−−−d ι2).”


∃ι'. (ι1
[Ancestor] ι') ∧ (ι2
[Ancestor] on ')


“Every end(t) event was caused by a corresponding begin(t) event.” [20]


∀t, ι ,ι ∃ι'. (
end(t)
' begin(t)

1 2	ι1 −−−−d ι2) =⇒ (ι −−−−−d[Causes] ι1)
“I (ι1) only communicated with descendants of somebody else (ι2).”


∀ι' (ι1
[Ancestor] on
') =⇒ (ι2
[Ancestor] ι')

“No name created by me (ι1) was ever transmitted to somebody else (ι2).”


¬∃ι' , ι' , a, ˜c. (b ∈ ˜c) ∧ (ι
[Ancestor]
' ) ∧ (ι'
⟨ec⟩ on a
[Ancestor]	' )

∧ (ι2 [Ancestor] ι' )

Relating the Reduction Semantics and Chart Seman- tics
We define a standard reduction semantics for our pi-calculus [30,39], based on structural equivalence P ≡ Q, and reduction P → Q. The only noteworthy detail is that constant instantiation is a rule of reduction, not structural equivalence. This avoids the syntactic constraints on definitions usually needed to avoid any unbounded unfolding.
Structural Equivalence: P ≡ Q
P ≡ P	struct-refl
Q ≡ P ⇒ P ≡ Q	struct-symm
P ≡ Q, Q ≡ R ⇒ P ≡ R	struct-trans
P ≡ P' ⇒ (νx)P ≡ (νx)P'	struct-res
P ≡ P' ⇒ P | Q ≡ P' | Q	struct-par
P | Q ≡ Q | P	struct-par-comm
(P | Q) | R ≡ P | (Q | R)	struct-par-assoc
a ∈/ fn(P ) ⇒ (νa)(P | Q) ≡ P | (νa)Q	struct-res-par
(νa)(νb)P ≡ (νb)(νa)P	struct-res-res
Reduction: P → Q

P → P' ⇒ P | Q → P' | Q P → P' ⇒ (νa)P → (νa)P'
P ≡ Q, Q → Q', Q' ≡ P' ⇒ P → P'
(a(x).P + M ) | (a⟨c⟩.Q + N ) → P ec/xe} | Q
τt.P + M → P
A(˜c) → P ec/xe} if A(x˜) := P
red-par red-res red-struct red-comm red-note red-inst


Operational correspondence
We now develop the correspondence between the reduction semantics of the pi- calculus and pi-charts. We begin by defining the process corresponding to a pi- chart: the parallel composition of the processes at the bottom of the chart inside a restriction of the names generated in the chart.
Unloading a pi-chart G to a process: [[G]]
[[G]] := (νnew(G))( ι∈IG⊥ Nt(ι))   (hence: [G]] = (νnew(G))[[G⊥]])

Definition 3.1 Given P , we let N (P ) be the set of processes of the form
(νe)(P1 | · · · | Pn1 | A1(c1) | ··· | An2 (cn2 ) | 0t1 | · · · | 0tn2 ), where each Pi is a sum
Mi or a constant Ai(ci), that are structurally equivalent to P . We write PN for any
element of N (P ).
We split the primitive charts into housekeeping charts, that do not correspond to reduction steps, and computation charts, that do. Let the set of housekeeping charts, Ch, be the subset of Cp generated just from the schemas for parallel composition and restriction. Let the set of computation charts, Cc, be Cp \ Ch. Similarly, we split the chart extension relation → into two relations →h and →c as follows. If G → G ∪ H with H ∈ Ch, we write G →h G ∪ H. Similarly G →c G ∪ H if G → G ∪ H with H ∈ Cc.
Housekeeping charts


We can then say that a pi-chart G is in normal form if G /→h. We let N (G) be the set of pi-charts GN in normal form such that G →∗ GN .
Lemma 3.2 N (G) is non-empty for every pi-chart G.
Proof. By induction on Σι∈IG  |Nt(ι)|, where |P | denotes the syntactic size of P .
There are three cases.
If G⊥ = ι • (νa)P ∪ H with a /∈ nn(GT) ∪ new(G) then there is ι' with G →h
G ∪ New⟨ι⟩(a, P )⟨ι'⟩ =: G' and G'⊥ = ι' • P ∪ H. Then Σι∈I	|Nt(ι)| =
'	∗	G⊥

1+ Σι∈I '
⊥
|Nt' (ι)|, and by induction G →h GN with GN in normal form.

Otherwise, if G⊥ = ι • P | Q ∪ H with a /∈ nn(GT) ∪ new(G) then there is ι1, ι2
with G →h G ∪ Par⟨ι⟩(P, Q)⟨ι1, ι2⟩ =: G' and G'⊥ = {•iota1P ∪ ι2 • Q ∪ H.

Then Σι∈IG
|Nt(ι)| = 1 + Σι∈I

G'⊥
|Nt' (ι)| and by induction G' →∗
GN with

GN in normal form.
Otherwise, G is in normal form and we are done.

We can then show that housekeeping extension does not change the process corresponding to the chart, up to structural equivalence.
Lemma 3.3 Suppose G is a pi-chart and P ≡ [[G]]. If G →h G ∪ H then P ≡
[[G ∪ H]].
Proof. If H is a par chart, this is immediate by AC of parallel composition. If
H is a new chart, there is ι ∈ It⊥ such that Nt(ι) = (νx)P , and y /∈ new(G) ∪
nn(GT) ∪ fn((νx)P ). By Corollary 2.3, y /∈ fn(  ι ∈I	Nt(ιi)), so we may use scope
extrusion to conclude that [G]] ≡ [[G' ]. By transitivity, P ≡ [[G']].	 

Corollary 3.4 If P ≡ [[G]] and GN ∈ N (G) then [[GN ]] ∈ N (P ).
Proof. For each GN ∈ N (G), [GN ]] ∈ N ([[GN ]]) = N ([[G]]) = N (P ).	 
Corollary 3.5 N (P ) is non-empty for every process P.
Proof. By Corollary 3.4 and Lemma 3.2 with G = [[ι • P ]] .	 
Reductions, on the other hand, are matched one for one by computation ex- tension of charts, possibly with some housekeeping beforehand to reveal the redex.

Lemma 3.6 Suppose G is a pi-chart and P ≡ [[G]].
If P → P' then G →∗ →c G' with [[G']] ≡ P'.
If G →c G' then P → P' with [[G']] ≡ P'.
Proof.
Assume that PN = (νe)  v=1...n Pv. There are three base cases for P → P'.
Red Comm Then P	→  P' if and only if there are i, j	≤  n and
a, ˜c, x˜, P',P', M,N with Pi = a⟨b⟩.P ' + M and Pj = a(x).P' + N such that

P' ≡ (νe˜)(P ' | P' ec/xe} | 
Pv) =: Q. By struct, PN → P'.

By Corollary 3.4,  G  →∗	GN  with  PN	=α  [[GN ].	Thus,  there

are ι1, ι2	∈	ItN ⊥  with NtN (ι1)	=	a⟨˜c⟩.P
'
+ M and NtN (ι2)	=

a(x˜).P ' + N .	Choosing distinct ι' , ι'	/∈ It , we get GN  →c GN ∪
Comm⟨ι1, ι2⟩(a, ˜c, x˜, P',P', M,N )⟨ι' , ι' ⟩ =: H. Clearly, [H]] ≡ Q ≡ P'.
Red Note Then P → P' if and only if there is i ≤ n and T, P' with Pi =

τt.P ' such that P'
PN → P'.
≡ (νe˜)(0t | P' |
i
v∈({1...n}\{i,j}) Pv ) =: Q. By struct,

By Corollary 3.4, G →∗ GN with PN  =α  [[GN ]].	Thus, there is
ι ∈ ItN ⊥ with NtN (ι) = τt.P .	Choosing ι  /∈ It , we get GN →c
'	'
GN ∪ Note⟨ι⟩(t, P )⟨ι'⟩. Clearly, [GN ∪ Note⟨ι⟩(t, P )⟨ι'⟩]] ≡ Q ≡ P'.
Red Inst Then	' if and only if there is	and	with	=	( ) and A(x˜) := PA such that P' ≡ (νe˜)(PA ec/xe} |  v∈({1...n}\{i,j}) Pv) =: Q.
N
By Corollary 3.4, G →∗ GN with PN =α [[GN ]. Thus, there is ι ∈ It

with NtN
h
(ι) = A(˜c). Choosing ι' /∈ It
N ⊥
, we get GN →c GN ∪Inst⟨ι⟩(A, ˜c)⟨ι'⟩.

Clearly, [GN ∪ Inst⟨ι⟩(A, ˜c)⟨ι'⟩]] ≡ Q ≡ P'.
Assume that G →c G∪H, It⊥ = {ιi}	and Nt(ιi) = Pi. Modulo renumbering
n


of the node identifiers, there are three cases for H.
H = Note⟨ι1⟩(T, P')⟨ι' ⟩: We then have [G]] ≡ (νe˜)(τT .P ' +M | 

Pv) →

(	)(0
'   1	1
)	[[
']].
1	v=2...n

νe˜
T | P1 |
v=2...n Pv  ≡ G

H = Inst⟨ι1⟩(A, ˜c)⟨ι' ⟩: Assuming that A(x˜) := PA, we then have

[[ ]]	(	)(
( ) 1 
)	(	)(
 ec }
)	[[
']].

G ≡ νe˜
A ˜c |
v=2...n Pv
→ νe˜ PA
/xe |
v=2...n Pv  ≡ G

H = Comm⟨ι1, ι2⟩(a, ˜c, x˜, P',P', M,N )⟨ι' , ι' ⟩: We	then	have	[G]]	≡

(	)(	' +
( 1	2 +	 1  2
)	(	)(  '
' ec }

νe˜ a⟨˜c⟩.P1	M | a x˜).P '
N |	v=3...n Pv
→	νe˜
P1 | P2
/xe	|

2
v=3...n Pv ) ≡ [[G']].

 

The full correspondence between many-step reduction of processes and pi-charts is then given by the following theorem.
Theorem 3.7   P →∗ Q iff there is a pi-chart G with P ≡ [[GT]] and Q ≡
(νnew(G))[[G⊥]].
Proof. By Lemma 3.3, Lemma 3.6 and induction, with G and G' in the lemmas given by G := GT and G' := G.		 
Conversely, if [GT]] →∗ (νnew(G))[[G⊥]] for some graph G, the graph is not necessarily a pi-chart. It may have spurious edges, for example. We cannot expect to recover the notion of a pi-chart simply from the reduction semantics.
Many standard equivalences, such as barbed equivalence and congruence, are defined in terms of the relation P →∗ Q, plus direct observations of process struc- ture [39]. Theorem 3.7 provides a basis for re-defining such equivalences in terms of charts.
Structural equivalence on graphs
The set of pi-charts {G | ι • P →∗ G} generated by a process P is not preserved by structural congruence of processes, that is, it is not true that if P ≡ Q then P and Q will generate the same charts, or even of the same shape. For example, consider two equivalent processes (νa)(P | Q) and P | (νa)Q, where a ∈/ fn(P ). The first process will generate a fresh name a and then branch to P and Q, whereas the second process will branch to P and (νa)Q, which then can generate the fresh name
a. We reconcile these differences by defining a notion of structural congruence on graphs. Let G ≡ G' be the least relation on graphs that is reflexive, symmetric and transitive and that satisfies the following axioms.
Structural Equivalence on Graphs: G ≡ H


| R


R	≡
sc-comp-assoc







≡	sc-res-comp



P ≡ Q

ι • P ≡ ι • Q
G ≡ G'	H ≡ H'	L(G, H)	L(G',H')

G ∪ H ≡ G' ∪ H'
sc-calc sc-cong

We note various properties of equivalent charts in Lemma 3.8. The lemma states that the nodes at the top of equivalent charts are equal up to structural congruence of processes (1), and similarly for the nodes at the bottom (2). Equivalent charts also generate the same fresh names (3), and their corresponding processes are equivalent (4).


Lemma 3.8 ∀G. if G is a pi-chart and G ≡ H then H is a pi-chart and

GT ≡ HT
G⊥ ≡ H⊥
new(G) = new(H)
[G]] ≡ [[H]]


Proof. By induction on the derivation of structural congruence for pi-charts.
sc-comp-assoc
| R


If G =
R	and H =
then:




GT = ι1 • (P | Q) | R ≡ ι1 • P | (Q | R) = HT by struct-par-assoc
G⊥ = ι1 • P ∪ ι2 • Q ∪ ι3 • R = H⊥
new(G) = new(H) = ∅
[G]] = P | Q | R = P | Q | R = [[H]]
sc-res



GT = ι1 • (νa)(νb)P ≡ ι1 • (νb)(νa)P = HT by struct-res-res
G⊥ = ι3 • P = H⊥
new(G) = new(H) = {a, b}
[G]] = (νa)(νb)P = (νa)(νb)P = [[H]]
sc-res-comp Assume x ∈/ fn(P )



If G =
and H =
then:




GT = ι1 • (νa)(P | Q) ≡ ι1 • P | (νa)Q = HT by struct-res-par
G⊥ = ι3 • P ∪ ι4 • Q = H⊥
new(G) = new(H) = {a}
[G]] = (νa)(P | Q) = [[H]]
sc-calc
If P ≡ Q and G = ι • P and H = ι • Q then:
GT = ι • P ≡ ι • Q = HT by (sc-calc)
G⊥ = ι • P ≡ ι • Q = H⊥ by (sc-calc)
new(G) = new(H) = ∅
[G]] = P ≡ Q = [[H]]
sc-cong
If L(G, H) and L(G',H') and G ≡ G' and H ≡ H' and G ∪ H is a pi-chart then G and H are pi-charts by Lemma 3.9. Therefore GT ≡ G'T , G⊥ ≡ G'⊥ , new(G) = new(G') and [[G]] ≡ [[G' ] by induction, and also HT ≡ H'T , H⊥ ≡ H'⊥ , new(H) = new(H') and [[H]] ≡ [[H' ] by induction. Let I = (G⊥ ∩ HT) and I' = (G'⊥ ∩ H'T). Therefore I ≡ I' by (sc-calc). Therefore:
(G ∪ H)T = GT ∪ (HT \ I) ≡ G'T ∪ (H'T \ I') = (G' ∪ H')T by (sc-calc)
(G ∪ H)⊥ = H⊥ ∪ (G⊥ \ I) ≡ H'⊥ ∪ (G'⊥ \ I') = (G' ∪ H')⊥ by (sc-calc)
new(G ∪ H) = new(G) ∪ new(H) = new(G') ∪ new(H') = new(G' ∪ H') = Z
[[(G ∪ H)⊥]] = [H⊥ ∪ (G⊥ \ I)]] = [H⊥]] | [[G⊥ \ I]]

and [[(G' ∪ H')⊥]] = [H'⊥ ∪ (G'⊥ \ I')]] = [H'⊥]] | [[G'⊥ \ I']].
Therefore [[(G ∪ H)⊥]] ≡ [[(G' ∪ H')⊥]] by struct-par.
Therefore [G ∪ H]] = (νZ)[[(G ∪ H)⊥]] ≡ (νZ)[[(G' ∪ H')⊥]] = [[G' ∪ H']] by
struct-res.
 
Lemma 3.9 ∀G, H. if G ∪ H is a pi-chart and L(G, H) then G and H are pi-charts

Proof. By induction on the derivation of the syntax for pi-charts. For each prim- itive pi-chart CP , if CP = G ∪ H and L(G, H) then either G = CP and H is a pi-chart or vice-versa.	 
We can characterize structural equivalence of processes in terms of the extension relation G → G' on graphs and structural equivalence of graphs, as stated in Theo- rem 3.11. The theorem states that equivalent processes generate equivalent charts, up to housekeeping extensions. Ideally we would like the statement of Theorem
3.11 to hold for G ≡ H rather than the weaker G →∗ ≡ H (recall that →h denotes a “housekeeping” transition involving a parallel composition or a restriction). Un- fortunately, the stronger statement does not hold in general. For a counterexample, consider the two equivalent processes (νa)(P | Q) and P | (νa)Q, where a ∈/ fn(P ), and the charts G, H, G' defined as follows.


ι1  (νa)(P | Q)
G	=	new a	H	=
ι2	P | Q





G' =



We have that ι1 • (νa)(P | Q) can extend to G but ι1 • P | (νa)Q cannot extend to any chart structurally congruent to G. However, ι1 • P | (νa)Q →→ H and G can perform an additional housekeeping extension to G' with G' ≡ H.
Proposition 3.10 if P ≡ Q and ι•P →∗ G then there is an H such that ι•Q →∗ H
and G →∗ ≡ H
Proof. By induction on the derivation of structural congruence for pi-calculus. We assume the following induction hypothesis. If G0 is a pi-chart and P is a process and P ≡ Q and P (ι • P, G0) then:
if G0 ∪ ι • P →∗ G then ∃H such that G0 ∪ ι • Q →∗ H and G →∗ ≡ H

if G0 ∪ ι • Q →∗ H then ∃G such that G0 ∪ ι • P →∗ G and H →∗ ≡ G
The proof exploits the fact that structurally congruent processes generate struc- turally congruent charts by a series of housekeeping chart extensions. In principle, a housekeeping extension can always happen eventually, regardless of other chart extensions that may occur. We prove this by examining each of the structural con- gruence rules in turn, in order to ensure consistent use of node identifiers. The base case for part (1) of all the rules is as follows. If P ≡ Q and ι1 • P ∪ G0 →∗ ι1 • P ∪ G' and P (ι1 • P, G') then ι1 • Q ∪ G0 →∗ ι1 • Q ∪ G' and P (ι1 • Q, G'). Therefore ι1 • P ∪ G' ≡ ι1 • Q ∪ G' by sc-cong and sc-calc. The base case for part (2) is similar. Due to lack of space, we show only some representative inductive cases.
struct-res-par
If G1 =	and G2 =	and G3 =

ι1  (νa)(P | Q)	ι1  (νa)(P | Q)
new a
ι2	P | Q




and H1 =	and H2 =	and H3 =

ι1	P | (νa)Q	ι1	P | (νa)Q



| (νa)Q


If G1 ∪ G0 →∗ G2 ∪ G' and L(G2, G') and {ι2, ι3, ι4}∩ It' = ∅ then H1 ∪ G0 →∗ H3∪G' and L(H3, G') and G2∪G' →h G3∪G' and L(G3, G'). Therefore G3∪G' ≡ H3 ∪ G' by sc-cong and sc-res-comp.
Finally, if G1 ∪ G0 →∗ G3 ∪ G' and L(G3, G') then H1 ∪ G0 → H3 ∪ G' and
L(H3, G'). Therefore G3 ∪ G' ≡ H3 ∪ G' by sc-cong and sc-res-comp.
Part (2) is similar.
struct-refl and struct-trans are straightforward struct-symm follows from the induction hypothesis. struct-par
If P ≡ P ' and G1 = ι1 • P | Q and H1 = ι1 • P' | Q

and G2 =	and H2 =

then part (1) has one remaining case. If P (G1 ∪ G0) and {ι2, ι3}∩ G0 = ∅ then P (ι2 • P, ι3 • Q ∪ G0). Therefore if ι2 • P ∪ ι3 • Q ∪ G0 →∗ G we have ∃H such that ι2 • P' ∪ ι3 • Q ∪ G0 →∗ H and G →∗ ≡ H by induction. Also L(G1, G) and L(H1,H). Therefore G1 ∪ G ≡ H1 ∪ H by sc-cong and sc-calc.
Part (2) is similar.
 
Theorem 3.11 P ≡ Q iff whenever ι • P →∗ G there is H with ι • Q →∗ H and
G →∗ ≡ H.
Proof. The forward direction follows by induction on the derivation of structural congruence for the pi-calculus, from Proposition 3.10, while the reverse direction is straightforward. Consider the trivial case where ι • P →0 G = ι • P . If ι • Q →∗ H and H ≡ G we have that GT ≡ HT by Lemma 3.8. Furthermore, we know that ι • Q →∗ H implies HT = ι • Q. Therefore ι • P ≡ ι • Q, so P ≡ Q by Lemma 3.8. 

Related Work
Starting with Petri [34], there is a substantial literature on graphs as a notation for states of concurrent computations. Examples include process algebras inspired by Petri Nets [3], together with a range of graph-based notations such as [18] and its numerous citations. In the area of process calculi Milner’s pi-nets [29] represent pi-calculus processes as graphs, where each node represents a channel and edges to a node represent inputs or outputs on the channel. Rewrite rules on graphs coalesce nodes after an interaction. Other graph-rewriting based models for the pi calculus include a hypergraph semantics [25] and a term graph semantics [18]. History dependent automata [32] map the entire state space of a pi-calculus process, where each node represents a separate state. The history of names is recorded in the graph, but not the history of computations. Bigraphs [31] are a graphical representation of both the computational and spatial aspects of a process. The graphical stochastic pi-calculus [35] represents a pi-calculus process as a collection of synchronising automata. All these process representations use graphs to represent states of computations, but not the computation history. (However, in certain of the cases one can recover causal relationships [10].) In contrast, a pi-chart represents one of the possible interaction histories of a set of processes, themselves given by syntax trees.
A trace is a sequence of actions performed by a process. In the setting of the pi-calculus, there are several formal definitions of trace, with the aim of defining properties of type systems [39], investigating asynchronous equivalences [6], and defining correspondence assertions [20]. Proved traces [8,38] are decorated with the locations in the term that participated in a transition. Pi-charts enable two- dimensional rendering and record more information, especially regarding restricted names as the subjects and objects of communication.
Various graphical structures are used to define noninterleaving semantics and equivalences of processes; this work has mainly concerned other process calculi and

algebras, but recently Varacca and Yoshida [41] develop such a semantics for the pi-calculus using event structures [42]. In contrast, pi-charts are not directly useful (and are not intended) for generating equivalences on processes. The equivalence induced by the set of pi-charts {G | ι • P →∗ G} extending from a process P is syntactic identity, since the process P is embedded in each member of the set. Of course, Theorem 3.7 allows us to reformulate any equivalence relation defined using the interleaving semantics P →∗ Q in terms of the chart semantics. Our development of structural congruence of graphs, leading to Theorem 3.11, begins the study of equivalences induced by charts.
Cryptographic security protocols are often specified by protocol narrations [1], exemplary sequences of communications of the form “Message n X → Y : M ”, meaning that the nth message M of the protocol goes from role X to role Y . A narration itself is essentially an MSC. Some formalisms for security protocols represent protocol runs as MSCs, essentially.
For example, strand spaces [40] are a graphical formalism for protocol narra- tions, based on strands and bundles. Each strand is a string of inputs and outputs, with implicit name generation, representing a role in the protocol. A bundle is a directed acyclic graph obtained by composing strands, similar to an MSC. Prop- erties of protocols are expressed in terms of occurrences of strands within bundles and “ancestor of” and “earlier than” relations, similar to the causal relations in Section 2.
Crazzolara and Milicia [14] establish explicit formal links between MSCs, for- malized as pomsets [37], and the semantics of the Security Protocol Language (SPL) [15]. SPL can be seen as a simple process calculus, with broadcast communi- cation, but without process forking as in the pi-calculus. They define an algorithm for constructing an MSC from any finite trace in the transition semantics of an SPL program. Their main formal result is that the events of such an MSC can be linearized to match the trace and moreover that every linearization of the MSC corresponds to a trace of the original SPL program. Their MSCs are extracted from an existing semantics for SPL, rather than being defined directly.

Conclusion
To summarize, our chart semantics is the first semantics for the pi-calculus based on the idea of message sequence charts. The main benefits of pi-charts compared to a conventional relational semantics are: (1) pi-charts are easier to visualize; and (2) pi-charts can express ancestry and causal dependencies that state-based relational semantics omit.
Although a chart corresponds to a single execution trace, in future we envisage verification tools for proving properties about the set of all charts generated by a given process. For example, this could be useful for validating high-level protocols expressed as pi-calculus processes. In cases where the desired properties do not hold, a visual execution trace representing a counter-example could be presented to the user.

The pi-calculus is used to model programming language features, communication and security protocols and their properties, and more recently, aspects of systems biology (see Appendix A for an example). Hence, the broader significance of our work beyond the pi-calculus is that it forms a formal basis to help visualize and express properties of systems in all of these areas.

Acknowledgement
U. Nestmann and G. Winskel advised us on related work. J. Guttman helped us understand the connection between pi-charts and strand spaces.

References
M. Abadi. Security protocols and their properties. In Foundations of Secure Computation, NATO Science Series, pages 39–60. IOS Press, 2000.
R. Alur, G. J. Holzmann, and D. Peled. An analyzer for message sequence charts. Software Concepts and Tools, 17(2):70–77, 1996.
E. Best, R. R. Devillers, and M. Koutny. The box algebra = petri nets + process expressions. Inf. Comput., 178(1):44–100, 2002.
K. Bhargavan, C. Fournet, A. D. Gordon, and R. Pucella. TulaFale: A security tool for web services. In FMCO’03, volume 3188 of LNCS, pages 197–222. Springer, 2004.
E. Bonelli, A. Compagnoni, and E. Gunter. Correspondence assertions for process synchronization in concurrent communications. JFP, 15(2):219–147, 2004.
M. Boreale, R. De Nicola, and R. Pugliese. Trace and testing equivalence on asynchronous processes.
Information and Computation, 172(2):139–164, 2002.
M. Boreale and D. Sangiorgi. A fully abstract semantics of causality in the π-calculus. Acta Informatica, 35:353–400, 1998.
G. Boudol and I. Castellani. Concurrency and atomicity. TCS, 59:25–84, 1988.
G. Boudol and I Castellani. A non-interleaving semantics for CCS based on proved transitions.
Fundamenta Informaticae, 4(XI):433–452, 1988.
R. Bruni, H. C. Melgratti, and U. Montanari. Event structure semantics for nominal calculi. In
CONCUR, pages 295–309, 2006.
M. Bugliesi, G. Castagna, and S. Crafa. Boxed ambients. In Theoretical Aspects of Computer Software (TACS 2001), volume 2215 of LNCS, pages 38–63. Springer, 2001.
L. Cardelli, G. Ghelli, and A. D. Gordon. Secrecy and group creation. Information and Computation, 196(2):127–155, 2005.
I. Castellani. Process algebras with localities. In Handbook of Process Algebra, chapter 15, pages 945–1045. Elsevier, 2001.
F. Crazzolara and G. Milicia. Graphical descriptions of security protocols. In COnstraint & LOgic Programming in Security (COLOPS 2003), 2003.
F. Crazzolara and G. Winskel. Events in security protocols. In Eight ACM Conference on Computer and Communications Security (CCS’2001), 2001.
P. Degano and C. Priami. Non interleaving semantics for mobile processes. Theoretical Computer Science, 216:237–270, 1999.
P. Degano and C. Priami. Enhanced operational semantics. ACM Computing Surveys, 2(33):135–176, 2001.


F. Gadducci. Term graph rewriting for the pi-calculus. In Atsushi Ohori, editor, APLAS, volume 2895 of Lecture Notes in Computer Science, pages 37–54. Springer, 2003.
E. R. Gansner and S. C. North. An open graph visualization system and its applications to software engineering. Software—Practice and Experience, 30(11):1203–1233, 2000.
A. D. Gordon and A. Jeffrey.	Typing correspondence assertions for communication protocols.
Theoretical Computer Science, 300:379–409, 2003.
ITU. Message Sequence Chart (MSC), 1999. Recommendation Z.120.
ITU. Specification and Design Language (SDL), 1999. Recommendation Z.100.
A. S. A. Jeffrey and J. Rathke. A fully abstract may testing semantics for concurrent objects.
Theoretical Computer Science, 338:17–63, 2005.
N. Kobayashi, B. Pierce, and D. Turner. Linearity and the pi-calculus. TOPLAS, 21(5):914–947, 1999.
B. K¨onig. A graph rewriting semantics for the polyadic pi-calculus. In Proc. of GT-VMT ’00 (Workshop on Graph Transformation and Visual Modeling Techniques), pages 451–458. Carleton Scientific, 2000.

L. Lamport. Time, clocks, and the ordering of events in a distributed system. Commun. ACM, 21(7):558–565, 1978.

S. Mauw and M. A. Reniers. An algebraic semantics of basic message sequence charts. The Computer Journal, 37(4), 1994.

S. Mauw, M.A. Reniers, and T.A.C. Willemse. Message Sequence Charts in the software engineering process. In S.K. Chang, editor, Handbook of Software Engineering and Knowledge Engineering. World Scientific, 2000.
R. Milner. Pi-nets: A graphical form of π-calculus. In ESOP’94, pages 26–42, 1994.
R. Milner. Communicating and Mobile Systems: the π-Calculus. CUP, 1999.

R. Milner. Bigraphical reactive systems: Basic theory. Technical Report 523, University of Cambridge Computer Laboratory, 2001.

U. Montanari and M. Pistore. History-dependent automata: An introduction. Lecture Notes in Computer Science, 3465:1–28, 2005.
Object Management Group. Unified Modeling Language. At http://www.uml.org.

C. Petri. Fundamentals of a theory of asynchronous information flow. In IFIP Congress ’62, pages 386–390. North Holland, 1962.

A. Phillips, L. Cardelli, and G. Castagna. A graphical representation for biological processes in the stochastic pi-calculus. Transactions in Computational Systems Biology, 4230:123–152, 2006.

A. Phillips, N. Yoshida, and S. Eisenbach. A distributed abstract machine for boxed ambient calculi. In European Symposium on Programming, LNCS. Springer, April 2004.
V. Pratt. Modelling concurrency with partial orders. International Journal of Parallel Programming, 15(1):33–71, 1986.
C. Priami. Enhanced Operational Semantics for Concurrency. PhD thesis, Pisa, 1996.
D. Sangiorgi and D. Walker. The π-calculus: A theory of mobile processes. CUP, 2001.

F. J. Thayer F´abrega, J. C. Herzog, and J. D. Guttman. Strand spaces: Proving security protocols correct. Journal of Computer Security, 7:191–230, 1999.

D. Varacca and N. Yoshida. Typed event structures and the pi-calculus. In Mathematical Foundations of Programming Semantics, ENTCS. Elsevier, 2006.
G. Winskel. Events in Computation. PhD thesis, University of Edinburgh, 1980.

A Biological Example

This example shows how pi-charts can be a useful tool for visualising interactions between stochastic pi-calculus models of biological systems. We use the same pi- calculus syntax and reduction rules from Sections 2 and 3, enriched with a stochastic extension along the lines of [35]. Stochastic behaviour is incorporated into the calculus by associating each channel a with a corresponding interaction rate given by ρ(a), and associating each action τr with a delay rate r. The rates are used as the basis for a stochastic simulation algorithm, which calculates the probability of all possible reductions at each step and stochastically chooses the next reduction based on these probabilities.
Consider the following network of three genes that mutually repress each other, with definitions for Gene(a, b), Blocked(a, b) and Protein(b) based on [35]:

Gene(a, b) := τtranscribe.(Gene(a, b) | Protein(b))
+ a().Blocked(a, b) Blocked(a, b) := τunblock.Gene(a, b) Protein(b) := b⟨⟩.Protein(b)
+ τdegrade

Gene(a, b) | Gene(b, c) | Gene(c, a)

The Gene(a, b) is parameterised by its promoter region a, together with the pro- moter region b that is recognised by its transcribed proteins. The gene can perform one of two actions. Either it can transcribe a Protein(b) by doing a stochastic de- lay at rate transcribe, after which the new protein is executed in parallel with the gene, or it can block by doing an input on its promoter region a. The blocked gene can then unblock by doing a stochastic delay at rate unblock. The Protein(b) can repeatedly do an output on the promoter region b, or it can decay at rate degrade. According to the reduction rules of the calculus, the output b⟨⟩ of the transcribed protein can interact with the input b() of a Gene(b, c), which becomes blocked as a result. The three genes Gene(a, b), Gene(b, c) and Gene(c, a) can mutually repress each other, since Gene(a, b) produces a protein that can block Gene(b, c), which pro- duces a protein that can block Gene(c, a), which produces a protein that can block Gene(a, b), completing the cycle. This mutual repression gives rise to alternate oscil- lation of protein levels, as shown in the above simulation plot, in which the vertical axis represents the number of processes and the horizontal axis represents the sim- ulation time. The results were obtained with equal rates for channels a, b, c such that ρ(a)   transcribe   degrade > unblock. However, the plots themselves give no indication as to what actually causes the oscillations to occur. Such a question is fundamental to understanding the behaviour the system, and pi-charts can help to provide a partial answer. An execution trace for the system is represented by the following pi-chart, which shows how the system can evolve starting from one of each gene. The visual representation of causality in the pi-chart helps to clarify the sequence of execution steps leading to the first oscillation cycle.


Gene(b, c)
















Blocked(b, c)

The chart shows how one of the genes, in this case Gene(a, b), transcribes a Protein(b), which immediately blocks Gene(b, c). Gene(c, a) transcribes Protein(a) soon after, which blocks Gene(a, b).The Gene(a, b) and Gene(b, c) both remain blocked, waiting for a slow unblock delay to fire, while Gene(c, a) is able to freely produce Protein(a) and start the first oscillation cycle.
We have implemented a prototype stochastic simulator that automatically gen- erates a pi-chart during a given simulation run. The prototype was implemented as a simple extension to the SPiM simulator, 4 by exporting the execution history of a simulation to a file using the DOT syntax [19]. The DOT layout engine is then used to automatically render the file as a pi-chart. The generated charts can be quite large, but it is relatively easily to scroll and zoom through the charts to a time point of particular interest in the simulation. For the above biological example one can focus on the sequence of transitions leading up to a switch in oscillation cycles, which can be quite informative.
In general, pi-charts seem to be a convenient way of visualising and debugging the behaviour of concurrent biological systems, and initial reactions from biologists have so far been positive. We plan to include a pi-chart debugging option in the next release of the SPiM simulator, so that biologists can experiment with generating their own charts from a range of models.

Expressing the Bounds Guaranteed by a Type Sys- tem
We present a synthesis of some existing type systems, including groups (or sorts) [30], group creation [12], and usage bounds [24]. A channel type T takes the general form g ?i !o [T1,..., Tn]. We say g is the group of the type, and of names belonging to the type. Groups indicate different usages, for example, Req or Res. A name x of type T is a channel conveying tuples of names with types T1,

4 SPiM is available at http://research.microsoft.com/∼aphillip/spim/.

..., Tn. The multiplicities i and o are upper bounds on the number of uses of x for input and output.
Group creation (νgrp g)P makes a fresh group g for use within P .  Groups
are represented as names, but well-typed processes cannot send them on channels. Hence, group creation helps structure processes by confining the flow of names belonging to a group. In particular, if a process O | (νgrp g)P is well-typed and there is a name x in group g, then the name x is communicated only between
descendants of P —the lexical scope of g—and cannot flow to descendants of O.
Our point here is not the type system itself, an assembly of variations of existing components, but rather to show that pi-charts can conveniently express both the usage bounds induced by multiplicities and the secrecy properties induced by group creation. The original statement of the latter [12, Proposition 3] relies on an informal notion of process derivation; our statement in terms of the “ancestor of” relation is completely formal.
We proceed with a terse presentation of the type system. Further explanations and examples are in the original publications [12,24,30].
Groups and Types:
g, h	group: subset of the set of the names
μ, i, o ::= 0 | 1 | ω	multiplicity
T ::= g ?i !o [T1,..., Tn]	polyadic channel type (n ≥ 0)
m ::= g | (x : T )	item: either a group, or a name with a type
E ::= ∅, m1,..., mn	typing environment: finite list of items
dom(∅) := ∅	dom(E, g) := dom(E) ∪ {g}	dom(E, x : T ) = dom(E) ∪ {x}
Our pi-calculus syntax is untyped, but we place type and group annotations on τ prefixes, both to guide typechecking, and to record typing information in the pi-chart semantics. We take the algebra of annotations A to be the set of items, so that we can write τg.P and τx:T .P . Let typed name restriction be (νx : T )P := (νx)τx:T .P and group creation be (νgrp g)P := (νg)τg.P .  Every chart extending

from (νx : T )P and reaching P includes edges
new x
' and
' x:T
'' and node

ι'' • P . Similarly, every chart extending from (νgrp g)P and reaching P includes

new g
'	' grp g	''	''

ι −−−d ι , ι
−−−d ι , and ι
P .

Let the addition μ + μ' of two multiplicities be the commutative function satis- fying the equations μ + 0 = μ and μ + ω = ω and 0 + 1 = 1 and 1 + 1 = ω. The addition functions on types, items, and environments are the least partial functions to satisfy the following equations. They are all associative and commutative.
Type, Item, and Environment Addition: T + T '  m + m'  E + E'
(g ?i !o [T1,..., Tn]) + (g ?i' !o' [T1,..., Tn]) := g ?(i + i') !(o + o') [T1,..., Tn]
g + g := g
(x : T )+ (x : T ') := x : (T + T ')
(∅, m1,..., mn)+ (∅, m' ,..., m' ) := (∅, m1 + m' ,..., mn + m' )
1	n	1	n


We assume a relation between process constants and lists of groups and types describing their parameters. Specifically, for each definition A(x1,..., xn) := P , we assume that the constant A is related to a list of group parameters h1,..., hm and a list of types T1,..., Tn. We write this as A[h1,..., hm, x1 : T1,..., xn : Tn].
The following rules define four judgments: E ▶ ⬦ means that the environment E is well-formed; E ▶ m means that the item m occurs in E; E ▶ T means that the type T is well-formed in E; and E ▶ P means that the process P is well-formed in E.
Typing Rules:   E ▶ ⬦   E ▶ m   E ▶ T   E ▶ P


env-∅

∅ ▶ ⬦ 
env-group
E ▶ ⬦		g ∈/ dom(E) E, g ▶ ⬦ 
env-name
E ▶ T	x ∈/ dom(E)


E, x : T ▶ ⬦ 

lookup
∅, m1,..., mn ▶ ⬦	i ∈ 1..n


∅, m1,..., mn ▶ mi
type
E ▶ g	E ▶ T1	...	E ▶ Tn E ▶ g ?i !o [T1,..., Tn]
proc-zero
E ▶ ⬦ 


E ▶ 0

proc-in
E0 ▶ x : g ?1 !0 [T1,..., Tn]	E1, y1 : T1,..., yn : Tn ▶ P	E = E0 + E1 defined
E ▶ x(y1,..., yn).P
proc-out
E0 ▶ x : g ?0 !1 [T1,..., Tn]	Ei ▶ yi : Ti	∀i ∈ 1..n En+1 ▶ P	E = E0 + ··· + En+1 defined
E ▶ x⟨y1,..., yn⟩.P


proc-note
E ▶ m	E ▶ P E ▶ τm.P
proc-choice
E ▶ M	E ▶ N E ▶ M + N
proc-res-group
E, g ▶ P


E ▶ (νgrp g)P

proc-res
E, x : T ▶ P


E ▶ (νx : T )P
proc-par
E1 ▶ P1	E2 ▶ P2	E = E1 + E2 defined


E ▶ P1 | P2

proc-const
A[h1,..., hm, x1 : T1,..., xn : Tn]	σ = {gj/h | j ∈ 1..m}
E ▶ ⬦	E ▶ gj	∀j ∈ 1..m	Ei ▶ ci : Tiσ	∀i ∈ 1..n	E = E1 + ··· + En defined
E ▶ A(c1,..., cn)

We assume that h1,..., hm, x1 : T1,..., xn  : Tn  ▶ P  for each definition
A(x1,..., xn) := P where A[h1,..., hm, x1 : T1,..., xn : Tn].
Theorem B.1 Suppose E ▶ [[GT]], G is a pi-chart, and T = g ?i !o [T1,..., Tn].

If ι1 −−d ι2 then the number of communications on x in G is no more than min(i, o).
g	x:T
If ι1 −d ι2 and ι3 −−d ι4 then ι2 [Ancestor] ι3.
⟨ye⟩ on z

Moreover, if ι5 ι2 [Ancestor] ι6.
−−−−d ι6 and x ∈ fn(y˜, z) then ι2 [Ancestor] ι5 and

We can explain the secrecy property of group creation by appeal to this theorem. Suppose that E ▶ O | (νgrp g)P , and consider any pi-chart G such that GT = ι •(O | (νgrp g)P ) for some ι. Such a G represents an arbitrary interaction between the process O and the process (νgrp g)P . Unless G is a singleton, in which case it includes no interactions, it must include an instance of the primitive chart for parallel composition, with edges ι −d ι' and ι −d ι'', and nodes ι' • O and ι'' •

(νgrp g)P . As discussed above, if P is reached, there must be edges ι
new g
−−−d ι1,

grp g	'
ι1 −−−d ι2, and a node ι2 •P . By Lemma 2.6, no descendant of ι •O is a descendant of ι2 • P , and the converse. If a name x of group g is created, there must be an
edge ι3 −−d ι4, where g is the group of T . By Theorem B.1(ii), ι2 [Ancestor] ι3, that is, a descendant of P creates the name x. Now, consider any communication
⟨ye⟩ on z
of x, that is, consider any edge ι5 −−−−d ι6 with x ∈ fn(y). By Theorem B.1(ii),
ι2 [Ancestor] ι5 and ι2 [Ancestor] ι6, that is, both the sender ι5 and the receiver ι6
of the tuple y containing x are descendants of P . Additionally, the theorem implies that all communications on the channel x itself are between descendants of P .
Hence, pi-charts directly formalize the intention that “channels of group g are forever secret outside the initial scope of (νgrp g)” [12].
