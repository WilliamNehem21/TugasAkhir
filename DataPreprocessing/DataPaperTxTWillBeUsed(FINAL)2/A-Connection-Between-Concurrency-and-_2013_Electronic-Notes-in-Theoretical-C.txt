Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 298 (2013) 143–164
www.elsevier.com/locate/entcs

A Connection Between Concurrency and Language Theory
Zoltan E´sik1
Dept. of Computer Science University of Szeged Szeged, Hungary

Abstract
We show that three fixed point structures equipped with (sequential) composition, a sum operation, and a fixed point operation share the same valid equations. These are the theories of (context-free) languages, (regular) tree languages, and simulation equivalence classes of (regular) synchronization trees (or processes). The results reveal a close relationship between classical language theory and process algebra.
Keywords: Fixed point operations, iteration theories, context-free languages, regular tree languages, synchronization trees, simulation equivalence

Introduction
Iteration theories [8] capture the equational properties of fixed point operations including the least fixed point operation over continuous or monotone functions over cpo’s or complete lattices, in rational algebraic theories [33,40], in theories of monotone functions over partially ordered sets with enough least (pre-)fixed points [19], or the initial fixed point operation over continuous functors over categories with directed colimits [7] or more generally, in theories of functors with enough initial algebras [31], or the unique fixed point operation in Elgot’s (pointed) iterative theories [17], or the fixed point operation in theories of trees and synchronization trees, and many other structures.
It was argued in [8,10] that all natural cartesian fixed point models lead to iteration theories. Moreover, it was proved in [37] that essentially every nontriv- ial subclass of iteration theories obeying a natural condition satisfies exactly the equations of iteration theories.
But several models have an additional structure, such as a nondeterministic choice operation, or more generally, an additive structure, which interacts with the cartesian operations and the fixed point operation in a nontrivial way. The relationship between the iteration theory structure and the additional operations has been the subject of several papers, including [1,9,13,22,12,20,23,24,29,30] and

1 This publication is supported by the European Union and co-funded by the European Social Fund. Project title: ‘Telemedicine-focused research activities in the fields of mathematics, informatics and medical sciences’. Project number: TA´MOP-4.2.2.A-11/1/KONV-2012-0073
1571-0661 © 2013 Elsevier B.V. Open access under CC BY-NC-ND license.
http://dx.doi.org/10.1016/j.entcs.2013.09.011

the recent [26]. In many cases, it was possible to capture this relationship by a finite number of equational (or sometimes quasi-equational) axioms. As a byproduct of these results, it was possible to give complete (though infinite) sets of equational axioms and finite sets of quasi-equational or more general first-order axioms for various bisimulation and trace based process behaviors, rational power series and regular languages, regular tree languages, and many other models.
The equational theory of simulation equivalence classes of (regular) synchro- nization trees over a set of action symbols, equipped with the cartesian operations, the least fixed point operation and sum, has a finite equational axiomatization rel- atively to iteration theories [22]. Incidentally, the very same equations hold for continuous or monotone functions over complete lattices equipped with the least fixed point operation and the pointwise binary supremum operation as sum, or in all ‘(ω-)continuous idempotent grove theories’. In this paper, our main new con- tribution is that two more well-known classes of structures relevant to computer science are of this sort, the theories of (regular) tree languages and the theories of (context-free) languages (Theorem 3.2). In our argument, we will make use of a concrete characterization of the free ω-continuous idempotent grove theories, which is a result of independent interest (cf. Theorem 4.3). The facts proved in the paper reveal a close relationship between models of concurrency, automata and language theory, and models of denotational semantics.
The results of this paper can be formulated in several different formalism in- cluding ‘μ-terms’, ‘letrec expressions’, or cartesian categories. We have chosen the simple language of Lawvere theories, i.e., cartesian categories generated by a single object. The extension of the results to many-sorted theories is straightforward.
Theories
In any category, we write the composition f · g of morphisms f : a → b and g : b → c in diagrammatic order, and we let 1a denote the identity morphism a → a. For an integer n ≥ 0, we let [n] denote the set {1,..., n}. When n = 0, this set is empty.
A (Lawvere) theory [34,8] is a small category T whose objects are the nonnegative integers such that each object n is the n-fold coproduct of object 1 with itself. The hom-set of morphisms n → p of a theory T is denoted T (n, p). We assume that every theory comes with distinguished coproduct injections in : 1 → n, i ∈ [n], n ≥ 0. Thus, for any sequence of morphisms f1,..., fn :1 → p, there is a unique morphism f : n → p with in · f = fi, for all i ∈ [n]. We denote this unique morphism f by
⟨f1,..., fn⟩ and call it the tupling of the fi. When n = 0, we also write 0p. Since 0 is initial object, 0p is the unique morphism 0 → p. It is clear that 1n = ⟨1n,..., nn⟩ for all n ≥ 0. We require that 11 = 11, so that ⟨f⟩ = f for all f :1 → p. Since the object n + m is the coproduct of objects n and m with respect to the coproduct injections
κn,n+m = ⟨1n+m,..., nn+m⟩ : n → n + m
λm,n+m = ⟨(n + 1)n+m,..., (n + m)n+m⟩ : m → n + m,
each theory is equipped with a pairing operation mapping a pair of morphisms (f, g)

with f : n → p and g : m → p to ⟨f, g⟩ : n + m → p:
n,  κ	/n ¸+ m ¸,λ	 m


,,,,
,,,,


⟨f,g⟩
cccc
cccc

f  ,,,	ccc g
,,zJ zc csc
p
The pairing operation is associative and satisfies ⟨f, 0p⟩ = f = ⟨0p,f⟩ for all f :
n → p.
Also, we can define for f : n → p and g : m → q the morphism f ⊕ g : n + m → p + q as ⟨f · κp,p+q, g · λq,p+q⟩. Then f ⊕ g is the unique morphism n + m → p + q with
κn,n+m · (f ⊕ g)= f · κp,p+q λm,n+m · (f ⊕ g)= g · λq,p+q.
n 	κ	/n ¸+ m ¸,λ	 m

f	f⊕g	g
J	J	J 
p	/p +¸q ¸,	 q
λ
The ⊕ operation is associative, and 00 ⊕ f = f = f ⊕ 00 for all f : n → p. Also, (f ⊕ g) · ⟨h, k⟩ = ⟨f · h, g · k⟩
for all f : n → p, g : m → q, h : p → r and k : q → r.
Each theory T may be seen as a many-sorted algebra, whose set of sorts is the set N × N of all ordered pairs of nonnegative integers, satisfying certain equational axioms, see e.g. [8]. Morphisms of theories are functors preserving objects and dis- tinguished morphisms. It follows that any theory morphism preserves the tupling, (and pairing) operations. The kernels of theory morphisms are called theory con- gruences. The quotient T/ ≡ of a theory T with respect to a theory congruence is defined as usual. A subtheory of a theory T is a theory T j whose set of morphisms is included in the morphisms of T such that the natural embedding of T j into T is a theory morphism T j → T . See [8] for more details.
We end this section by providing some examples.
Let X = {x1, x2,.. .} denote a fixed countably infinite set of variables, and let A be a set disjoint from X. For each p ≥ 0, let Xp = {x1,..., xp}. The theory WA has as morphisms 1 → p all words in (A ∪ Xp)∗. A morphism n → p is an n-tuple of morphisms 1 → p. For morphisms u = (u1,..., un) : n → p and v = (v1,..., vp): p → q, we define u · v = (u1 · v,..., un · v), where for each i ∈ [n], ui · v is the word obtained from ui by substituting a copy of vj for each occurrence of the variable xj in ui, for all j ∈ [p]. Equipped with this composition operation and the morphisms 1n = (x1,..., xn): n → n as identity morphisms, WA is a category. In fact, WA is a theory with distinguished morphisms in = xi : 1 → n, i ∈ [n], n ≥ 0.

Suppose now that Σ = Uk≥0 Σk is a ranked set which is disjoint from X. We may view Σ as a pure set and form the theory WΣ. Consider the subtheory TreeΣ of WΣ consisting of the Σ-trees (or Σ-terms). A morphism 1 → p in TreeΣ is a well-formed word in (Σ ∪ Xp)∗ which is either a variable in Xp or a word of the form σt1 ... tk for a letter σ ∈ Σk and trees t1,..., tk :1 → p. A morphism n → p is an n-tuple of morphisms n → p. It is well-known that the theory TreeΣ is the free theory, freely generated by Σ. Indeed, each letter σ ∈ Σn may be identified
with a tree in TreeΣ(1, n) so that given any theory T and rank preserving function
ϕ :Σ → T , there is a unique theory morphism ϕ : TreeΣ → T extending ϕ.
Remark 2.1 If in the previous example Σ is empty, then we obtain the initial theory Θ. A morphism n → p of this initial theory is a tupling of distinguished morphisms (i.e., variables) and may be identiﬁed with a function [n] → [p], so that composition corresponds to composition of functions. A base morphism of a theory T is a morphism that arises as the image of a morphism in the initial theory with respect to the unique theory morphism Θ → T. For example, the base morphisms n → p in a theory WA are the morphisms of the form (x1ρ,..., xnρ), where ρ is a function [n] → [p]. In any nontrivial theory, we may faithfully represent base morphisms n → p as functions [n] → [p].

Statement of the main result
By taking sets of morphisms of a theory T , we may sometimes define a new theory P (T ). (For a more general construction, the reader is referred to [11].) The mor- phisms 1 → p in P (T ) are all sets L ⊆ T (1, p). A morphism n → p is an n-tuple (L1,..., Ln) of morphisms 1 → p, including the tuple 0n,p = (∅,..., ∅). To define composition, suppose that L : 1 → p and K = (K1,..., Kp) : p → q. Then we define L · K :1 → q to be the set of all morphisms 1 → q in T of the form
f · ⟨g1,..., gm⟩

such that f :1 → m in T and there is a base morphism ρ : m → p with f · ρ ∈ L and gi ∈ Kiρ for all i ∈ [m]. When L = (L1,..., Ln) : n → p, we define L · K as the morphism (L1 · K,..., Ln · K): n → q. For each n ≥ 0, the identity morphism 1n is the morphism ({1n},..., {nn}): n → n, and the ith distinguished morphism 1 → n is {in}. When P (T ) is a theory, we call it a power-set theory.
Suppose that P (T ) is a power-set theory. We may also equip P (T ) with a sum operation, denoted + and defined by component-wise set union. We define
L + Lj = (L1 ∪ Lj ,..., Ln ∪ Lj ): n → p,
1	n

for all L = (L1,..., Ln): n → p and Lj = (Lj ,..., Lj ): n → p in P (T ). It is clear
1	n
that, equipped with the operation + and the constant 0n,p, each hom-set P (T )(n, p)
is a commutative, idempotent monoid. Moreover,

in · (L + Lj)= in · L + in · Lj	(1)
in · 0n,p = 01,p	(2)
(L + Lj) · K = L · K + Lj · K	(3)
0n,p · K = 0n,q,	(4)

for all L, Lj : n → p and K : p → q. (Here, we adapt the convention that composition has higher precedence than sum.) Thus, P (T ) is an idempotent grove theory, cf. [8] or Section 4.
The above power-set construction is applicable to the theories WA and TreeΣ, yielding the idempotent grove theories LangA of languages over A and TreeLangΣ of tree languages over Σ. In LangA, composition is the usual operation of ‘language substitution’. In TreeLangΣ, it corresponds to the ‘OI-substitution’ of [16].
Any power-set theory P (T ) is naturally equipped with a partial order ⊆ defined
by component-wise set inclusion. It is clear that each hom-set P (T )(n, p) isa com- plete lattice with least element 0n,p, moreover, the theory operations are monotone, in fact continuous. (Composition preserves all suprema in its first argument, and tupling preserves all suprema in each of its arguments.) Thus, we can define a dag- ger operation † : T (P )(n, n + p) → T (P )(n, p) (n, p ≥ 0), L '→ L†, by taking the least solution of the fixed point equation X = L · ⟨X, 1p⟩. In particular, the theo- ries LangA and TreeLangΣ are also equipped with a dagger operation. The least subtheory of LangA containing the finite languages which is closed under dagger is the theory CFLA of context-free languages, and the least subtheory of TreeLangA containing the finite tree languages which is closed under dagger is the theory RegΣ of regular tree languages [20,24,32]. Both CFLA and RegΣ are idempotent grove theories.
We define yet another class of theories equipped with both an additive structure and a dagger operation, the theories of simulation equivalence classes of synchro- nization trees. A hyper-tree consists of a countable set V of vertices and a countable set E of edges, each edge e having a source v in V and an ordered sequence of target vertices (v1,..., vn) ∈ V n, for some n ≥ 0. There is a distinguished vertex, the root v0, such that each vertex v is the target vertex of a unique path from v0 to v. An isomorphism between hyper-trees is determined by a bijection between the vertices and a bijection between the edges that jointly preserve the root and the source and target of the edges.
Synchronization trees over a set A of action symbols were defined in [39]. A (slight) generalization of synchronization trees for ranked sets is given in [22]. Sup- pose that Σ is a ranked set. A synchronization tree t = (Vt, Et, λt):1 → p over Σ is a hyper-tree with vertex set Vt, hyper-edges Et, equipped with a labeling function λt : Et → Σ ∪ {ex1,..., exp}, where the exi are referred to as the exit symbols. Each hyper-edge e : v → (v1,..., vn) with source v and target (v1,..., vn) is labeled in Σn, when n ≥ 1, or by an exit symbol or a symbol in Σ0, when n = 0. When t is a synchronization tree and v is a vertex of t, then the vertices ‘accessible’ from v (including v) span the subtree t|v. The edges of t|v are those edges of t having a source accessible from v. An isomorphism between synchronization trees is an iso-

morphism of the underlying hyper-trees which preserves the labeling. We usually identify isomorphic synchronization trees. A synchronization tree n → p over Σ is an n-tuple (t1,..., tn) of synchronization trees 1 → p over Σ. A synchronization tree t : 1 → p is ﬁnite if its set of edges is finite (and thus its vertex set is also fi- nite), ﬁnitely branching if each vertex is the source of a finite number of edges, and regular, if it has a finite number of subtrees (up to isomorphism) and only a finite number of letters from Σ appear as edge labels. A synchronization tree t : n → p is finite (finitely branching, regular, resp.) if its components are all finite (finitely branching, regular, resp.).
We may identify each letter σ ∈ Σn with the finite synchronization tree 1 → n having and edge v0 → (v1,..., vn) labeled σ, where v0 is the root, and an edge originating in vi labeled exi for each i ∈ [n]. In the same way, we may view each exit symbol exi as a tree 1 → n for each i ∈ [n], n ≥ 0.
Synchronization trees over Σ form a theory STΣ. When t : 1 → p and tj =
(tj ,..., tj ): p → q, then t · tj :1 → q is constructed from t by replacing each edge
1	p
of t labeled exi for some i ∈ [p] by a copy of tj . When t = (t1,..., tn): n → p, then
t · tj = (t1 · tj,..., tn · tj): n → q. For each i ∈ [n], the distinguished morphism in is the tree having a single edge labeled exi. For synchronization trees t, tj :1 → p, we also define t + tj : 1 → p as the tree obtained from (disjoint copies of) t and tj by
merging the roots. When t = (t1,..., tn): n → p and tj = (tj ,..., tj ): n → p, then
1	n
t+tj = (t1 +tj ,..., tn +tj ): n → p. We define 01,p as the tree 1 → p having no edge,
1	n
and 0n,p = (01,p,..., 01,p) : n → p, for all n, p ≥ 0. Clearly, each hom-set of STΣ
is a commutative monoid and (1)–(4) hold, so that STΣ is a grove theory [8]. We also define the grove theories FSTΣ of finite and RSTΣ of regular synchronization trees over Σ.
Suppose that t and tj are synchronization trees 1 → p over Σ. A simulation [35,36] t → tj is a relation R ⊆ Vt × Vt′ , relating the roots such that whenever e : v → (v1,..., vn) is an edge of t and vRvj, then there is an equally labeled edge

ej : vj → (vj ,..., vj ) of tj such that viRvj
for all i. Note that the domain of a

1	n	i
simulation R : t → tj is Vt. For later use we also define a morphism t → tj to
be a simulation τ which is a function Vt → Vt′ . Thus, a morphism is a functional simulation. Note that when R is a simulation t → tj, then R contains a function τ which is a morphism. Indeed, for a vertex v ∈ Vf at distance n from the root, we define vτ as follows. When n =0 so that v is the root of f , then let vτ be the root of g. Suppose now that n > 0 and let v be one of the target vertices of the edge e : u → (u1,..., um) of f , say v = ui. Then uτ is already defined so that uR(uτ )

holds, and there is an (equally labeled) edge ej : uτ → (uj ,..., uj
) with ujRuj
for

all j. We define vτ = uj .
1	m	j

It is well-known that simulations compose, so that if t, tj, tjj :1 → p and R is a simulation t → tj and Rj is a simulation tj → tjj, then the relational composition of R and Rj is a simulation t → tjj. When t = (t1,..., tn) and tj = (tj ,..., tj ) are
1	n
synchronization trees n → p, a simulation t → tj is an n-tuple (R1,..., Rn), where
each Ri is a simulation ti → tj . We say that t and tj are simulation equivalent, denoted t ≡s tj, if there are simulations t → tj and tj → t. The relation ≡s is a

grove theory congruence of STΣ, i.e., a theory congruence which preserves the sum operation, giving rise to the grove theory SSTΣ = STΣ/ ≡s. We will denote the simulation equivalence class of a tree t by [t]s, or sometimes just [t]. Moreover, when t = (t1,..., tn): n → p, we identify [t]s with ([t1]s,..., [tn]s).
We define the relation t ±s tj for synchronization trees t, tj : n → p iff there is a simulation t → tj. Also, we define [t]s ±s [tj]s iff t ±s tj, since the definition is independent of the choice of the representatives of the equivalence classes. Since simulations compose, the relation ±s is a pre-order on synchronization trees and a partial order on simulation equivalence classes. Each hom-set of SSTΣ has all
countable suprema. Indeed, when t , i ∈ I, is a countable family of trees 1 → p, then supi∈I [ti]s = [t]s for the tree t = Σi∈I ti :1 → p obtained by taking the disjoint union of the ti and identifying the roots. When I is empty, the sum is the tree 01,p.
More generally, when ti : n → p, for all i ∈ I, then supi∈I ti is the tree t : n → p
such that for each j ∈ [n], jn · t =  i∈I jn · ti.
The theory operations are ω-continuous, so that we can define a dagger opera- tion. For each f = [t]s : n → n + p in SSTΣ, f† : n → p is the least solution of the fixed-point equation x = f · ⟨x, 1p⟩. The least subtheory of SSTΣ containing the finite synchronization trees which is closed under dagger is the theory SRSTΣ of simulation equivalence classes containing at least one regular tree. Further, we denote by SFSTΣ the subtheory determined by those simulation equivalence classes containing at least one finite synchronization tree. Both SRSTΣ and SFSTΣ are closed under the sum operation, and both of them are grove theories. Note that we may identify SRSTΣ with RSTΣ/≡s and SFSTΣ with FSTΣ/≡s.
Remark 3.1 It is known, cf. [8,13], that the dagger operation may also be deﬁned on STΣ, by taking ‘initial solutions’ of ﬁxed point equations x = f · ⟨x, 1p⟩ for f : n → n+p. The subtheory RSTΣ is closed under this dagger operation. Moreover, it turns out that simulation equivalence becomes a congruence as does the bisimilarity relation (see below).
A term is a well-formed expression composed of morphism variables and con- stants for the distinguished morphisms using the theory operations, sum, and dag- ger. Each term has a source n and a target p, for some nonnegative integers n, p.
We are now ready to state our main result. We may view each set A as a ranked set where each letter has rank 1.
Theorem 3.2 The following conditions are equivalent for terms t, tj : n → p.
The identity t = tj holds in all power-set theories P (T ), where T is a theory.
The identity t = tj holds in all theories LangA (or CFLA), where A is a set.
The identity t = tj holds in all theories TreeLangΣ (or RegΣ), where Σ is a ranked set.
The identity t = tj holds in all theories SSTΣ (or SRSTΣ), where Σ is a ranked set.
The identity t = tj holds in all theories SSTA (or SRSTA), where A is a set.

(In (ii) and (v), by a straightforward coding argument, we could as well require that A is a two-element set, or even a singleton set in (v).) The proof of Theorem 3.2 will be completed in Section 5.
Since simulation equivalence is known to be decidable (in polynomial time for finite process graphs, cf. [2,38]), it follows that it is decidable for terms t, tj : n → p whether t = tj holds in all theories CFLA. This fact is in contrast with the well- known undecidability of the equivalence problem for context-free grammars. Intu- itively, our positive result is due to the fact that we are interested in the equivalence of terms under all possible interpretations of the morphism variables as context-free languages. By restricting the interpretations to those mapping a fixed morphism variable 1 → 2 to the language {x1x2} (or by adding to our operations a constant for this language), we would run into undecidability, in fact the equational theory would not be recursively enumerable.
Remark 3.3 Languages and tree languages satisfy

L · ⟨L1 + Lj ,..., Ln + Lj ⟩ =	Σ
Ki∈{Li,L′ }
L · ⟨K1,..., Kn⟩

L · ⟨L1,..., 01,p,..., Ln⟩ = 01,p

for all L : 1 → n, and Li, Lj
: 1 → p whenever each of the variables x1,..., xn

occurs exactly once in each word/tree of L. However, these equations do not hold universally.

Free ω-continuous idempotent grove theories
Recall from [8] that a grove theory is a theory T with a commutative additive monoid structure (T (n, p), +, 0n,p) on each hom-set such that (1)–(4) hold. An idempotent grove theory is a grove theory with an idempotent sum operation. A morphism of (idempotent) grove theories is a theory morphism preserving + and the constants 0n,p. When T is an idempotent grove theory, we may define a partial order ≤ on each hom-set T (n, p) by f ≤ g iff f + g = g. It is clear that 0n,p is the least element of T (n, p) with respect to this partial order, and the tupling and sum operations preserve the order. Composition necessarily preserves the order in the first argument, but not necessarily in the second. When it does, we call T an ordered idempotent grove theory. Moreover, when f, g : n → p, then f ≤ g iff in · f ≤ in · g for all i ∈ [n]. Thus, the partial order on morphisms n → p is determined by the order on the morphisms 1 → p. Morphisms of idempotent grove theories necessarily preserve the order.
We say that an idempotent grove theory is ω-continuous if the supremum supk fk of each ω-chain (fk : n → p)k exists and composition preserves the supremum of ω- chains in both arguments. It follows that every ω-continuous idempotent grove the- ory is ordered, and the supremum of every countable family of morphisms fi : n → p, i ∈ I exists. Moreover, composition preserves the supremum of all countable fam- ilies in its first argument. A morphism of ω-continuous idempotent grove theories preserves the supremum of ω-chains.

Examples of ω-continuous idempotent grove theories include all power-set theo- ries P (T ) and thus the theories LangA, TreeLangΣ, and the theories SSTΣ defined above. In LangA and TreeLangΣ, the relation ≤ is the component-wise set inclu- sion relation ⊆, whereas it is the relation ±s in SSTA. Each of these theories is equipped with a dagger operation. More generally, we may define a dagger opera- tion in any ω-continuous idempotent grove theory: for a morphism f : n → n + p, f† : n → p is the least solution of the equation x = f · ⟨x, 1p⟩ in the variable x : n → p. We have f† = supk f (k), where f (0) = 0n,p and f (k+1) = f · ⟨f (k), 1p⟩, for all k ≥ 0. It is clear that every morphism of ω-continuous idempotent grove theories preserves dagger.
An ideal in FSTΣ(n, p) is a nonempty set Q ⊆ FSTΣ which is downward closed with respect to the relation ±s. An ω-ideal is an ideal Q which is generated by some ω-chain (tk)k of trees tk : n → p in FSTΣ with tk ±s tk+1 for all k ≥ 0. Note that we may identify any (ω)-ideal Q ⊆ FSTΣ(n, p) with an n-tuple of (ω)- ideals (Q1,..., Qn), where Qi ⊆ FSTΣ(1, p) is the set of all ith components of the members of Q, for each i ∈ [n]. We may recover Q from (Q1,..., Qn) as the set
{t : n → p : in · t ∈ Qi for all i ∈ [n]}.
We may turn ω-ideals into an idempotent grove theory ωSFSTΣ. The set of morphisms n → p in ωSFSTΣ is the collection of all ω-ideals Q ⊆ FSTΣ(n, p). When Q : n → p and Qj : p → q, then we define Q · Qj : n → q to be the ideal generated by the set of all trees f · g with f : n → p in Q and g : p → q in Qj. When Q and Qj are generated by the ω-chains (fk)k and (gk)k, respectively, then Q · Qj is the ω-ideal generated by the ω-chain (fk · gk)k. For each i ∈ [n], n ≥ 0, the distinguished morphism 1 → n is the ideal generated by the tree exi. The sum Q + Qj : n → p of Q : n → p and Qj : n → p is defined as the ideal generated by {f + g : f ∈ Q, g ∈ Qj}. It is easy to see that this is again an ω-ideal. The morphism 0n,p : n → p in ωSFSTΣ is the ideal containing only the tree 0n,p.
There is a canonical embedding of SFSTΣ into ωSFSTΣ which maps the simulation equivalence class of a finite tree t : n → p to the principal ω-ideal
{tj : n → p : tj ±s t}. It is easy to see that this defines an (ordered) idempotent grove theory morphism SFSTΣ → ωSFSTΣ.
An ω-ideal in SFSTΣ(n, p) is defined in the same way as in FSTΣ(n, p) using the partial order ±s. We may identify any ω-ideal Q ⊆ SFSTΣ(n, p) with an ω- ideal Qj ⊆ FSTΣ(n, p) which is the union of all simulation equivalence classes of the trees in Q. Using this identification, ωSFSTΣ is just the completion of SFSTΣ by ω-ideals as defined in [5] 2 It follows from the main result of [5] that ωSFSTΣ is an ω-continuous idempotent grove theory, and that we have:
Proposition 4.1 The theory ωSFSTΣ is the free ω-continuous idempotent grove theory, freely generated by SFSTΣ. Given any ω-continuous idempotent grove the- ory T and an (ordered) idempotent grove theory morphism ϕ : SFSTΣ → T, there is a unique ω-continuous idempotent grove theory morphism ϕ : ωSFSTΣ → T extending ϕ.

2 Actually [5] uses a different representation of ω-ideals.

Proposition 4.2 The theory SFSTΣ is the free ordered idempotent grove theory, freely generated by Σ.
Proof. It is known that FSTΣ is the free grove theory, freely generated by Σ, cf. [8]. Let ≈ denote the least grove theory congruence such that FSTΣ/ ≈ is an ordered idempotent grove theory, and define f ≤ g iff f + g ≈ g, for all f, g : n → p. Thus, f ≈ g iff both f ≤ g and g ≤ f hold. We show that the relations ≡s and ≈ are equal. The inclusion of ≈ in ≡s is clear, since SFSTΣ is an ordered idempotent grove theory. To complete the proof, we show that for all f, g :1 → p in FSTΣ, if f ±s g, then f ≤ g. We argue by induction on the height 3 of f . When the height of f is 0, f = 01,p and our claim is clear. Suppose now that the height of f is positive. If the root of f is the source of a single edge, then f = σ · ⟨fj ,...,fj ⟩ or f = jp
1	k
for some σ ∈ Σk, fj ,...,fj :1 → p and j ∈ [p]. In the first case, since f ±s g, we
1	k
may write g as g0 + σ · ⟨gj ,..., gj ⟩ for some g0, gj ,..., gj :1 → p with fj ±s gj for
1	k	1	k	i	i
all i ∈ [k]. By the induction hypothesis, we have fj ≤ gj for all i ∈ [k] and thus
i	i
f ≤ g, since FSTΣ/ ≈ is an ordered idempotent grove theory. In the second case,
when f = jp, g can be written as g0 + jp, for some g0 :1 → p. Thus, f ≤ g again. Suppose finally that the root of f has 2 or more outgoing edges e. Then we can write f as a finite sum of summands f|e, where the height of each f|e is less than or equal to the height of f and has a single edge whose source is the root. By the previous case and the induction hypothesis we have f|e ≤ g for each e. Since sum is idempotent, we conclude that f ≤ g.	2
By Proposition 4.2 and Proposition 4.1, we immediately have:
Theorem 4.3 For each ranked alphabet Σ, the theory ωSFSTΣ is the free ω- continuous idempotent grove theory, freely generated by Σ.
Our next task is to relate ω-ideals of finite synchronization trees to possibly infinite synchronization trees.
For each tree t : n → p in STΣ, let K(t) denote the set of all ﬁnite trees tj : n → p
with tj ±s t.
Proposition 4.4 A set of ﬁnite trees Q ⊆ FSTΣ(n, p) is an ω-ideal iff Q = K(t)
for some (possibly inﬁnite) tree t : n → p in STΣ.
Proof. It suffices to prove the claim for n = 1. Suppose first that Q = K(t) for some t :1 → p in STΣ. Then Q is the ω-ideal generated by the ω-chain (tk)k, where tk :1 → p is the prefix of t of height at most k which is determined by those edges whose source is at distance at most k − 1 from the root.
Suppose now that Q is the ω-ideal generated by the ω-chain (tk)k of finite trees

1 → p. Let t = Σ

k≥0
tk. Then for any finite tree s :1 → p, s ±s t iff s ±s Σk	ti

for some k ≥ 0 iff s ±s tk for some k ≥ 0.	2
Proposition 4.5 Suppose that t, tj : n → p in STΣ. If t ±s tj then K(t) ⊆ K(tj). Moreover, if t and tj are ﬁnitely branching, or simulation equivalent to some ﬁnitely branching trees, and if K(t) ⊆ K(tj), then t ±s t.
3 The height is the length of the longest path.

Proof. The first statement is obvious. In order to prove the second, we may restrict ourselves to finitely branching trees 1 → p. So suppose that t, tj :1 → p are finitely

branching with K(t) ⊆ K(tj). For each k ≥ 0, let tk and tj
denote the (finite)

prefixes of t and tj of height at most k, so that t is the union of the tk and, similarly,

tj is the union of the tj , for k ≥ 0. Since K(t) ⊆ K(tj), we have tk ±s tj
for each

k
k ≥ 0, so that there is a finite nonempty set of morphisms tk → tj
k
for each k ≥ 0.

Also, the restriction of a morphism tk+1 → tj	onto tk is a morphism tk → tj . By
K¨onig’s lemma, we may select a sequence of morphisms (τk : tk → tj )k such that τk is the restriction of τk+1 for each k ≥ 0. Since t is the union of the tk and tj is the union of the tj , the sequence (τk)k determines a morphism τ : t → tj.	2
Corollary 4.6 If t, tj : n → p in STΣ are simulation equivalent to ﬁnitely branching trees, then t ±s tj iff K(t) ⊆ K(tj), and t ≡s tj iff K(t)= K(tj).
Example 4.7 Let t be the inﬁnitely branching tree t = Σn≥0 σn · 01,0 :1 → 0, and let tj = σω : 1 → 0, a tree consisting of a single inﬁnite branch with edges labeled σ ∈ Σ1. Then K(t)= K(tj) but t ≡s tj does not hold.
Since every regular synchronization tree is simulation equivalent to a finitely branching regular tree, we have:
Corollary 4.8 Suppose that t, tj : n → p in RSTΣ. Then t ±s tj iff K(t) ⊆ K(tj)
and t ≡s tj iff K(t)= K(tj).
From Theorem 4.3 and Corollary 4.8, we obtain:
Corollary 4.9 Suppose that Σ is a ranked set, T is an ω-continuous idempotent grove theory and ϕ :Σ → T is a rank preserving function. Then there is a unique way to extend ϕ to an idempotent grove theory morphism ϕ : SRSTΣ → T pre- serving dagger.
Proof. Suppose that T is an ω-continuous idempotent grove theory and ϕ is a rank preserving function Σ → T . We may extend ϕ toa morphism ψ : ωSFSTΣ → T of ω-continuous idempotent grove theories. We know that SRSTΣ embeds in ωSFSTΣ by the function which maps a regular tree t : n → p to K(t). It is a routine matter to verify that the embedding preserves the theory operations, the additive structure, and dagger. Thus, we may identify SRSTΣ with a subtheory of ωSFSTΣ. The restriction of ψ to SRSTΣ is the required extension ϕ : SRSTΣ → T .   2
Remark 4.10 Corollary 4.9 is also derivable from a stronger result in [22], where it is shown (using the language of μ-terms) that simulation equivalence classes of regular synchronization trees form the free theories in a class of iteration theories with an additive structure satisfying certain axioms. Our aim here was to derive this result from Theorem 4.3.
Proof of the main result
In this section our aim is to prove Theorem 3.2.
Recall that we may view each set A as a ranked set of letters of rank 1. We start

by showing that for each ranked set Σ there is some set A such that SSTΣ embeds in SSTA and SRSTΣ embeds in SRSTA.
Proposition 5.1 For every ranked set Σ there exists a set A and an injective (idem- potent) grove theory morphism SRSTΣ → SRSTA preserving dagger.

Proof. When Σ is a ranked set, define A = Σ ∪ {#}, where Σ= {σ : σ ∈ Σ}. Our aim is to show that there is an injective dagger preserving grove theory morphism SRSTΣ → SRSTA.
Consider the function ϕ which maps the simulation equivalence class of the tree corresponding to a letter σ ∈ Σn, n ≥ 0, to the simulation equivalence class of the synchronization tree
sσ = σ · (# · 1n + #2 · 2n + ... + #n · nn):1 → n
in STA. (Recall that σ has rank 1. The tree sσ has a single edge originating in the root, which is labeled σ. The target of this edge is the source of n branches, a branch of the form #i · in for each i ∈ [n].) When n = 0, the simulation equivalence class of the tree σ is mapped to the equivalence class [σ·01,0]s. By Corollary 4.9, this function can be extended in a unique way to an idempotent grove theory morphism ϕ : SRSTΣ → SRSTA preserving dagger.
It is not hard to see that ϕ takes the following concrete form. Suppose that t : 1 → p in RSTΣ. Then [t]sϕ is the equivalence class of the (regular) tree tj :1 → p in RSTA obtained from t by replacing each edge labeled σ ∈ Σ bya copy of the tree sσ. Formally, the set of vertices of tj consists of the vertices of t together with a vertex [v, (v1, v2,..., vn)] and vertices (vi, j) with 1 < j < i ≤ n, for each hyper-edge v → (v1,..., vn) of t. The edges of tj are the exit edges of t labeled as in t together with the following ones, where we suppose that e : v → (v1,..., vn) is a hyper-edge of t labeled σ.
An edge v → [v, (v1,..., vn)] labeled σ.
An edge [v, (v1,..., vn)] → (vi, 1) for each 1 < i ≤ n labeled #.
An edge (vi, j) → (vi,j + 1) and an edge (vi,i − 1) → vi labeled #, for all 1 < i ≤ n and 1 < j < i − 1.
An edge [v, (v1,..., vn)] → v1 labeled #.
When t = (t1,..., tn) : n → p and each [ti]s is mapped to [tj ]s, then [t]sϕ = ([tj ]s,..., [tj ]s). Since each t : 1 → p can be recovered from tj : 1 → p, [t]s is
1	n
uniquely determined by [tj]s, i.e., ϕ is injective.	2
Remark 5.2 The above proof can be extended to all synchronization trees to obtain an injective ω-continuous idempotent grove theory morphism SSTΣ → SSTA.
Proposition 5.3 For each set A there exist a set B and an injective dagger pre- serving (idempotent) grove theory morphism SRSTA → CFLB.
Proof. Let B = A ∪ {#, $} and consider an idempotent grove theory morphism
ϕ : SRSTA → CFLB preserving dagger defined by the assignment a '→ a(#x1$)∗ =
{a, a#x1$, a(#x1$)2,.	} :1 → 1, so that the image of each letter a ∈ A is a regular

language. We claim that for any regular trees t, s :1 → p in RSTA,
[t] ±s [s] e [t]ϕ ⊆ [s]ϕ.

The implication from left-to-right is immediate from Corollary 4.9. Suppose now that t /±s s. We want to prove that [t]ϕ /⊆ [s]ϕ. We consider only the case p = 0 since the argument is similar for p > 0. Without loss of generality we may suppose that t and s are finitely branching since every regular tree is similar to a finitely branching regular tree. The n-round simulation game on the pair (t, s) is played by two players, player I and II. In each round, player I selects an edge originating in the vertex of t entered in the previous round, or in the root in the first round, and player II must respond by selecting an equally labeled edge originating in the vertex of s entered in the previous round, or in the root of s in first round. Player I wins the play if player II cannot respond. Otherwise player II wins. Since t /±s s and our trees are finitely branching, it follows that there is some n ≥ 1 such that player I wins the n-round simulation game on (t, s). We show by induction on n that [t]ϕ /⊆ [s]ϕ. When n = 1, player I can choose an edge originating in the root of t whose label is not matched by the label of any edge originating in the root of
s. Since the label of this edge is a word in [t]ϕ but not the first letter of any word
in [s]ϕ, we have [t]ϕ /⊆ [s]ϕ.
Suppose now that n > 1 and that we have established the claim for n — 1. Now player I can select an edge originating in the root of t, labeled a ∈ A, with target the root of a subtree tj such that for each a-labeled edge from the root of s to the root of some subtree sj, player I wins the (n — 1)-round game on (tj, sj). By the induction hypothesis, this means that [tj]ϕ /⊆ [sj]ϕ for all such subtrees sj.
Let s1,..., sk (k > 0) be up to isomorphism all those subtrees of s whose roots are the targets of a-labeled edges originating in the root of s. We have [tj]ϕ /⊆ [si]ϕ for all i. Now [t]ϕ contains a(#[tj]ϕ$)k as a subset, and all the words in [s]ϕ starting with a are in the set {a}∪ i∈[k] m≥1 a(#[si]ϕ$)m. For each i ∈ [k], let ui be a word in [tj]ϕ which is not in [si]ϕ. Then the word a#u1$ ... #uk$ is in [t]ϕ but does not belong to [s]ϕ, since it does not belong to any a(#[si]ϕ)k. Thus, [t]ϕ /⊆ [s]ϕ. 2
Proposition 5.4 For each set A there exist a ranked set Σ and an injective dagger preserving (idempotent) grove theory morphism SRSTA → RegΣ.
Proof. Let Σ0 = A ∪ {#, $}, Σ2 = {σ}, and let Σn be empty if n = 1 or n > 2. For each a ∈ A, consider a regular tree language La : 1 → 1 in RegΣ whose ‘frontier’ is the context-free (in fact, regular) language described in the previous proof. (Such a regular tree language exists, since the context-free languages are exactly the frontier languages of regular tree languages, see e.g. [32].) For example, let La = {t0 = a, t1 = σaσ#σx1$, t2 = σaσ#σx1σ$σ#σx1$,.. .}. Then let ψ : SRSTA → RegΣ be the unique dagger preserving morphism of idempotent grove theories determined by the assignment a '→ La for all a ∈ A, which exists by Corollary 4.9. The morphism ϕ constructed in the proof of Proposition 5.3 factors through ψ by the ‘frontier map’. Since ϕ is injective, so is ψ.	2

We are now ready to prove Theorem 3.2. First note that since for each set A, CFLA embeds in LangA, every identity that holds in all theories LangA holds in the theories CFLA. Similar facts are true in (iii), (iv) and (v) for the theories TreeLangΣ and RegΣ, SSTΣ and SRSTΣ, and SSTA and SRSTA. Clearly, every identity that holds in the theories SSTΣ (SRSTΣ, resp.) also holds in the theories SSTA (SRSTA, resp.). Since each theory TreeLangΣ embeds in a theory LangA, and similarly, each theory RegΣ embeds in some theory CFLA, each condition of
(ii) implies the corresponding condition of (iii). By Corollary 4.9, if an identity holds
in all theories SRSTΣ then it holds in all ω-continuous idempotent grove theories and thus in all theories appearing in Theorem 3.2. Also, if an identity holds in all power-set theories, then it holds in the theories LangA. Thus, to complete the proof it suffices to show that if an identity holds in all theories RegΣ, then it holds in the theories SRSTA, and that this turn implies that the identity holds in all theories SRSTΣ. But these facts follow from Proposition 5.4 and Proposition 5.3.
Remark 5.5 The above proof also establishes the fact that an identity holds in all ω-continuous idempotent grove theories iff it holds in all theories SRSTΣ (or the theories mentioned in Theorem 3.2).
Remark 5.6 (Based on [22].) When A is a poset with all countable suprema, the ω-continuous functions over A form an ω-continuous idempotent grove theory ωContA. A morphism n → p in this theory is an ω-continuous function Ap → An (note the reversal of the arrow), and composition is function composition (in the reverse order). For each i ∈ [n], n ≥ 0, the distinguished morphism in :1 → n is the ith projection function An → A. The constant 0n,p is the constant function mapping all elements of Ap to the least element of An, and f + g is the pointwise supremum of f and g, for each f, g : n → p (i.e., ω-continuous functions f, g : Ap → An). Note that the order ≤ becomes the pointwise partial order. Since ωContA is a continuous idempotent grove theory, it comes with the least ﬁxed point operation as dagger operation.
Every ω-continuous idempotent grove theory T may be embedded in a theory ωContA. Given T, let A =  p≥0 T (1, p), equipped with the pointwise partial order. The embedding maps a morphism f :1 → n to the ω-continuous function Ap → A deﬁned by
f ((g1,p)p,..., (gn,p)p)= (f · ⟨g1,p,..., gn,p⟩)p.
By this embedding, we conclude that an identity holds in all continuous idempotent grove theories iff it holds in all theories of the sort ωContA, where A is an ω- continuous poset (or in fact a complete lattice).

Axiomatization
By Theorem 3.2 and Remark 5.6, the very same equational calculus may be used in formal calculations involving simulation equivalence classes of (regular) synchro- nization trees, (context-free) languages, (regular) tree languages, (regular) synchro- nization trees, power-set theories, ω-continuous idempotent grove theories, or ω-

continuous functions over ω-complete posets, equipped with the theory operations, sum, and dagger. Axiomatic treatments were given in [22] using the formalism of μ-terms. We now transform these results into into the categorical language of this paper.
Iteration theories were introduced in 1980 by Bloom, Elgot and Wright [6], and

independently by
E´sik [18], as a generalization of Elgot’s iterative theories [17]

and the rational and continuous theories [33,40] of the ADJ group. See [8] for original references. Iteration theories are algebraic theories equipped with a dagger operation satisfying certain equational axioms such as the ﬁxed point identity
f · ⟨f†, 1p⟩ = f†	(5)
or the parameter identity
(f · (1n⊕g))† = f† · g,	(6)
where f : n → n + p and g : p → q. The equational axioms of iteration theo- ries may conveniently be divided into two groups, the ‘Conway identities’ and the ‘commutative identities’ [18], which are simplified to the ‘group identities’ in [21]. For detailed accounts, we refer to [8,10,21]. A morphism of iteration theories is a theory morphism preserving dagger. Iteration theory congruences are defined in the expected way.
A grove iteration theory [8,13] is an iteration theory which is a grove theory.
Here, we also require that
11† = 01,0.	(7)
It is known that in a grove iteration theory, (1n⊕0p)† = 0n,p
holds for all n, p ≥ 0. Morphisms of grove iteration theories are both iteration theory morphisms and grove theory morphisms. A grove iteration theory congruence is just an iteration theory congruence.
It is possible to define a star operation ∗ : T (n, n + p) → T (n, n + p) (n, p ≥ 0) in any grove iteration theory. When f : n → n + p, we define
f∗ = (f · (1n⊕0n⊕1p)+ (0n⊕1n⊕0p))† : n → n + p.
Thus, in particular, 11∗ = (12 + 22)† :1 → 1. It can be seen, cf. [8], that in grove iteration theories T , f∗ is a solution of the equation
x = f · ⟨x, 0n⊕1p⟩ + (1n⊕0p),
for all f : n → n + p in T . When p = 0, this equation becomes x = f · x + 1n. In fact, properties of the dagger operation may be translated into corresponding properties of the star operation and vice versa, see [8,25,28].
A grove iteration theory is ω-idempotent if
11∗ = 11
holds. Any ω-idempotent grove iteration theory is an idempotent grove theory and thus an idempotent grove iteration theory. Indeed, if T is ω-idempotent, then
11 + 11 = 11 · 11∗ + 11 = 11∗ = 11,

so that f + f = (11 + 11) · f = 11 · f = f , for all f :1 → p. Thus, we can define a partial order as above by f ≤ g iff f + g = g, for all f, g : n → p. Call an idempotent grove iteration theory ordered if the dagger operation is monotone:
f† ≤ (f + g)†,	(8)
or equivalently, if
f ≤ g : n → n + p ⇒ f† ≤ g† : n → p,
for all f, g : n → n + p. It follows that composition is also monotone, since in iteration theories,
f · g = (1n⊕0p) · ⟨0n⊕f⊕0q, 0n+p⊕g⟩†,
for all f : n → p and g : p → q. (It can be seen that an idempotent grove theory is ordered iff composition and the scalar dagger operation f '→ f†, f :1 → 1+ p are monotone.) Morphisms of (ordered) ω-idempotent grove iteration theories are just grove iteration theory morphisms.
The following results were proved in [22] using the formalism of μ-terms.
Theorem 6.1 For each ranked set Σ, SRSTΣ is the free ordered ω-idempotent grove iteration theory, freely generated by Σ.
Corollary 6.2 An identity holds in all ordered ω-idempotent grove iteration theo- ries iff it holds in all ω-continuous idempotent grove theories, or in the theories of Theorem 3.2.
Note that Theorem 6.1 shows that the theories of simulation equivalence classes of regular synchronization theories have a finite axiomatization relatively to iteration theories. (Without the additive structure, they satisfy exactly the iteration theory identities.)
Remark 6.3 By removing (8) from the axioms, we obtain a complete axiomatiza- tion of ‘bisimilarity’ of (regular) synchronization trees, cf. [8,13], and by adding to the the axioms the identities
f · (g + h)= f · g + f · h f · 0p,q = 0n,p,
for all f : n → p and g, h : p → q, the resulting system is known to be complete for (matrix) theories over ω-continuous idempotent semirings, or regular languages, or theories of binary relations, and many other structures. See [8], where original references may be found. (We note that (8) now becomes redundant.)
In the presence of some Conway theory identities, the commutative identities (and the group identities) are implied by simpler quasi-equational or other first- order axioms of more general type. Since many of these simpler axioms hold in ω-continuous idempotent grove theories, we may derive several corollaries to Theo- rem 6.1 and Corollary 6.2.
A idempotent Park grove theory is an ordered idempotent grove theory equipped with a dagger operation satisfying the fixed point identity (5), the parameter identity
(6) and the ﬁxed point induction rule:

f · ⟨g, 1p⟩≤ g ⇒ f† ≤ g,
for all f : n → n + p and g : n → p. (The equation (7) now becomes redundant, and the fixed point identity may be simplified to the inequality
f · ⟨f†, 1p⟩≤ f†,	f : n → n + p.)
For example, all ω-continuous idempotent grove theories are idempotent Park grove theories. It is known, cf. [19], that every idempotent Park grove theory is an ordered ω-idempotent iteration theory. A morphism of idempotent Park grove theories is an idempotent grove theory morphism which preserves dagger.
Using Theorem 6.1 we have:
Corollary 6.4 For each ranked set Σ, SRSTΣ is the free idempotent Park grove theory, freely generated by Σ.
Corollary 6.5 The following are equivalent for an identity t = tj between terms
t, tj : n → p involving the theory operations, dagger, and sum.
t = tj holds in all ω-continuous idempotent grove theories.
t = tj holds in all ordered ω-idempotent grove iteration theories.
t = tj holds in all idempotent Park grove theories.
It is well-known that it suffices to require the fixed point induction rule just in the case when n = 1, see [4,14] or [8].
By the above results, simulation equivalence classes of regular synchronization trees have a finite implicational axiomatization. Other known implicational or first- order axiomatizations involve the weak functorial implication of [8], or a version [27] of the Scott induction rule. In [25], it is shown that by adding one-sided residuation to the collection of operations, a finite purely equational system may be derived.
Proof of Theorem 6.1.
In order to make the paper self contained, in this section we provide a proof of Theorem 6.1, originally obtained in [22] using the formalism of μ-expressions. We make use of a corresponding result from [8,13] that concerns bisimilarity.
Recall [35,36] thata simulation R : f → g for trees f, g ∈ STΣ is a bisimulation if the relational inverse of R is a simulation g → f . We say that trees f, g :1 → p are bisimilar if there is a bisimulation f → g. When f = (f1,..., fn): n → p and g = (g1,..., gn): n → p, then we say that f is bisimilar to g is each fi is bisimilar to gi. As mentioned above, bisimilarity, denoted ≡b, is a grove iteration theory congruence [8], moreover, BSTΣ = STΣ/ ≡b is an ω-idempotent grove iteration theory as is BRSTΣ = RSTΣ/ ≡b. The bisimilarity class of a tree f : n → p in STΣ (or in RSTΣ) will be denoted [f ]b. Note that we may embedΣ into BRSTΣ or BSTΣ by the function mapping a letter σ ∈ Σn into the bisimilarity class of σ seen as a tree 1 → n.
The following result was proved in [13,8] (at least in the case when each letter in Σ has rank 1).

Theorem 7.1 For each ranked alphabet Σ, BRSTΣ is the free ω-idempotent grove iteration theory, freely generated by Σ. In more detail, given any ω-idempotent iteration theory T and rank preserving function Σ → T, there is a unique morphism of ω-idempotent grove iteration theories ϕ : BRSTΣ → T extending ϕ.
We will use Theorem 7.1 in our characterization of SRSTΣ as the free ordered ω-idempotent grove iteration theory, freely generated by Σ. But first we need some preparations. Recall that a morphism τ : f → g for f, g : 1 → p in STΣ is a function Vf → Vg preserving the root such that whenever e : u → (u1,..., un) is an edge of f then there is an equally labeled edge ej : uτ → (u1τ, ..., unτ ) of g. Call the morphism τ locally surjective if for each u ∈ Vf and v ∈ Vg with uτ = v, if ej : v → (v1,..., vn) is an edge of g, then there exists an equally labeled edge e : u → (u1,..., un) of f with uiτ = vi for all i ∈ [n]. Clearly, every locally surjective morphism is a surjective function. Moreover, we have:
Lemma 7.2 Suppose that Σ is a ranked alphabet and f, g :1 → p in STΣ. Then a morphism τ : f → g is a bisimulation iff τ is locally surjective.
Lemma 7.3 Suppose that Σ is a ranked alphabet and f, g : 1 → p in RSTΣ with f ±s g. Then there is a regular tree fj :1 → p in RSTΣ such that fj ≡b g and f embeds in fj by an injective morphism.
Proof. When τ is a morphism f → g and u is a vertex of f , let f|uτ be the tree determined by those vertices of g|uτ which are in Vf|u τ , together with all edges vτ → (v1τ, ..., vnτ ) of g|uτ such that v is in Vf|u . When n = 0, we also require that there is an equally labeled edge of f originating in v. Also, let gu be the tree determined by those edges of guτ which are not edges of f|uτ . Thus, g|uτ = f|uτ +gu. First note that since f ±s g, there is a morphism τ : f → g such that if f|u is isomorphic to f|v and g|uτ is isomorphic to g|vτ , for some vertices u, v of f , then there exist isomorphisms π : f|u → f|v and πj : g|uτ → g|vτ with xπτ = xτπj for all vertices x of f|u, so that also f|uτ is isomorphic to f|vτ and gu is isomorphic to gv.
Let fj be obtained from f by adding gu as a summand to f|u, for each vertex u of f . Then f clearly embeds in fj and fj ≡b g, since there is a locally surjective morphism fj → g. Moreover, fj is regular, since if f|u is isomorphic to f|v and g|uτ is isomorphic to g|vτ , then fj|u is isomorphic to fj|v.	2
Example 7.4 As an illustration, let σ be a letter of rank 1 and let σj and σjj be letters or rank 0. Let f :1 → 0 be the full binary tree whose edges are all labeled σ. Let g :1 → 0 have a single maximal inﬁnite path whose edges are all labeled σ and such that each vertex along this path is the source of one more edge. This edge is labeled σj or σjj according to whether the vertex is at even or odd distance from the root. Then there is a single morphism f → g. The tree fj can be obtained from f by adding an outedge labeled σj to each vertex at even distance from the root, and an edge labeled σjj to each vertex at odd distance from the root.
Lemma 7.5 Suppose that ≈ is a grove iteration theory congruence of BRSTΣ such that the quotient BRSTΣ/ ≈ is an ordered grove iteration theory. For all f, g : n → p in RSTΣ, deﬁne f ≤ g when [f ]b + [g]b ≈ [g]b. Moreover, deﬁne f ≈ g

iff [f ]b ≈ [g]b, so that f ≈ g iff f ≤ g and g ≤ f.
Let f, g : 1 → p in RSTΣ. If f : 1 → p embeds in g : 1 → p by an injective morphism, then f ≤ g.
Proof. Without loss of generality, we may choose an embedding τ : f → g such that whenever f|u is isomorphic to f|v and g|uτ is isomorphic to g|vτ , for some vertices u, v of f , then there exist isomorphisms π : f|u → f|v and πj : g|uτ → g|vτ such that xπτ = xτπj for all vertices x of f|u. In particular, f|uτ is isomorphic to f|vτ and gu is isomorphic to gv. (For definitions, see the preceding proof.) Let f1 = f,..., fn and g1 = g, ..., gm be, up to isomorphism, all the subtrees of f and g, respectively. Let us label a vertex u of f by the pair (i, j) if f|u = fi and g|uτ = gj. Let K denote the set of all pairs that label some vertex u, and consider a bijection ψ between the sets K and [k], where k denotes the number of elements of K. We may assume that (1, 1)ψ = 1. Let ψj denote the inverse of ψ. Now using the labeling of f , let us construct a tree a : k → k + p, a = ⟨a1,..., ak⟩. Consider a vertex u of f labeled (i, j), say, together with all edges originating in u. For each σ ∈ Σr that occurs as the label of an edge, and for each sequence (i1, j1),..., (ir, jr) of elements of K, let l = l(σ, (i1, j1),..., (ir, jr)) denote the number of outgoing edges of u labeled σ with target vertices labeled (i1, j1),..., (ir, jr) if there is at least one such edge. Consider the tree (l · σ · ρ)⊕0p, where ρ is the base morphism r → k corresponding to the function [r] → [k] with s '→ (is, js)ψ, for all s ∈ [r]. Here, l · σ · ρ is the l-fold sum of the tree σ · ρ with itself, which is a countably infinite sum when l = ∞. Moreover, for each j ∈ [p], let lj denote the number of edges originating in u labeled exj. Then the component a(i,j)ψ of a corresponding to (i, j)ψ is the (finite) sum of all such trees (l · σ · ρ)⊕0p and 0k⊕(lj · jp).
Having constructed a : k → k + p, we construct b : k → k + p. To this end, we label a vertex v of g by (i, j) ∈ K if g|v = gj and there is a vertex u of f with uτ = v and f|u = fi. (Note that there is at most one vertex u with uτ = v.) Now the component of b corresponding to (i, j)ψ is the finite sum of trees (l · σ · ρ)⊕0p and 0k⊕(lj · jp) as above, where l and the lj are determined using the labeling

of g, together with the regular tree 0k⊕gj
j
(i,j)ψ
is obtained from gu by

removing those outgoing edges of the root labeled in Σ0 or by an exit symbol (since
these have already been taken care of).
Clearly a ≤ b, since b ≈ a + c for some regular c. For each s ∈ [k], let is be the first component of sψj, and js the second. Then the fixed point equation x = a·⟨x, 1p⟩ has (fi1 ,..., fik ) as its unique solution in STΣ. Similarly, the equation y = b · ⟨y, 1p⟩ has (gj1 ,..., gjk ) as its unique solution in STΣ. Now it is known, cf. [13,8], that STΣ and RSTΣ are also grove iteration theories such that bisimilarity is a congruence of STΣ (and of RSTΣ). Thus, f = 1k · a† and g = 1k · b†. Since a ≤ b and dagger preserves ≤, we conclude that f ≤ g.	2
Example 7.6 In order to illustrate the above argument, let σ, σj be letters of rank
1. Let f : 1 → 0 be the inﬁnite tree with a single maximal path and edges labeled σ, and let g : 1 → 0 be the full binary tree with each vertex having an outgoing edge labeled σ and an edge labeled σj. Then there is an (essentially unique) injective

morphism f → g. Now k = 1, a : 1 → 1 is the tree σ, and b : 1 → 1 is the tree
σ + (01⊕ (σj · g)). Clearly, a ≤ b, and thus f = a† ≤ b† = g.
Example 7.7 Suppose that σ is a letter of rank 1 and σj, σjj have rank 0. Let f be the tree g of Example 7.4, and deﬁne now g as the tree obtained from the full binary tree with edges labeled σ by adding to each vertex an edge labeled σj and an edge labeled σjj. Then there is an essentially unique embedding of f into g. We have k = 2, a = ⟨a1, a2⟩ :2 → 2 and b = ⟨b1, b2⟩ :2 → 2 where
a1 = σ · 22 + (02⊕σj)
a2 = σ · 12 + (02⊕σjj)
b1 = σ · 22 + (02⊕σj)+ (02⊕σjj)+ (02⊕ (σ · g)) b2 = σ · 12 + (02⊕σj)+ (02⊕σjj)+ (02⊕ (σ · g)),
so that f = 12 · a†, g = 12 · b†. Also, a ≤ b and thus f ≤ g.
We now complete the proof of Theorem 6.1.
Let ≈ denote the least grove iteration theory congruence of BRSTΣ such that the quotient BRSTΣ/≈ is an ordered grove iteration theory. For all f, g :1 → p in RSTΣ, define f ≤ g when [f ]b + [g]b ≈ [g]s. Moreover, define f ≈ g iff [f ]b ≈ [g]b, so that f ≈ g iff f ≤ g and g ≤ f .
Our goal is to show that the relations ±s and ≤ on RSTΣ are equal. It is clear that ≤ is included in ±s. To complete the proof, it suffices to show that f ≤ g whenever f, g : 1 → p in RSTΣ with f ±s g. But if f ±s g, then by Lemma 7.3 there exists fj : 1 → p in RSTΣ with fj ≡b g and such that there is an injective morphism f → fj. But then fj ≈ g by Theorem 7.1, and f ≤ fj by Lemma 7.5. It follows that f ≤ g. The proof is complete.

Summary
We have shown that several apparently different fixed point models, relevant to automata and formal language theory, concurrency and semantics, share the same equational theory, and presented sound and complete equational and quasi- equational axiomatizations. The fixed point models included the theories of (context-free) languages, (regular) tree languages and the simulation equivalence classes of (finite) transition systems. We expect that our results generalize to weighted languages, weighted tree automata [15] and simulation equivalence classes of weighted transition systems.

References
L. Aceto, Z. E´sik and A. Ing´olfsd´ottir, Equational axioms for probabilistic bisimilarity, Algebraic Methodology and Software Technology, AMAST 2002, Reunion, LNCS 2422, Springer, 2002, 239–253.
J. Balc´azar, J. Gabarr´o, and M. S´antha, Deciding bisimilarity is P-complete, Formal Aspects of Computing, 4(1992), 638–648, 1992.
M. Barr and C. Wells, Category Theory for Computing Science, Prentice Hall, 1990.


H. Beki´c, Definable operation in general algebras, and the theory of automata and flowcharts, Technical report, IBM Vienna, 1969. Reprinted in Programming Languages and Their Definition – Hans Bekic (1936-1982), LNCS 177, Springer 1984, 30–55.
S.L. Bloom, Varieties of ordered algebras, J. Computer and System Sciences, 13(1976), 200–212.
S.L. Bloom, C.C. Elgot, and J.B. Wright, Solutions of the iteration equation and extensions of the scalar iteration operation, SIAM J. of Computing, 9(1980), 26–45.
S.L. Bloom and Z.E´sik, Equational logic of circular data type specification, Theoretical Computer Science, 63(1989), 303–331.
S.L. Bloom and Z. E´sik, Iteration Theories, Springer, 1993.
S.L. Bloom and Z. E´sik, Equational axioms for regular sets, Mathematical Structures in Computer Science, 3(1993), 1–24.
S.L. Bloom and Z. E´sik, The equational logic of fixed points, Theoretical Computer Science, 179(1997), 1–60.
S.L. Bloom and Z. E´sik, An extension theorem with an application to formal tree series, J. Automata, Languages, and Combinatorics, 8(2003), 145–185.
S.L. Bloom and Z. E´sik, Axiomatizing rational power series over natural numbers, Information and Computation, 207(2009), 793–811.
S.L. Bloom, Z. E´sik and D. Taubner, Iteration theories of synchronization trees, Information and Computation, 102(1993), 1–55.
J.W. DeBakker and D. Scott, A theory of programs, Technical Report, IBM Vienna, 1969.
M. Droste, W. Kuich and H. Vogler, Eds., Handbook of Weighted Automata, Springer, 2009.
J. Engelfriet and E.M. Schmidt, IO and OI, Parts I and II, J. Computer System Sciences, 15(1977), 328–353 and 16(1978), 67–99.
C.C. Elgot, Monadic computation and iterative algebraic theories, Logic Colloquium ’73 (Bristol, 1973), Studies in Logic and the Foundations of Mathematics, Vol. 80, North-Holland, Amsterdam, 1975, 175– 230.

Z.
E´sik, Identities in iterative and rational theories, Computational Linguistics and Computer

Languages, 14(1980), 183–207.
Z. E´sik, Completeness of Park induction, Theoretical Computer Science, 177(1997), 217–283.
Z. E´sik, Axiomatizing the equational theory of regular tree languages, STACS ’98, Paris, LNCS 1373, Springer-Verlag, 1998, 455–465.
Z. E´sik, Group axioms for iteration, Information and Computation, 148(1999), 131–180.
Z. E´sik, Axiomatizing the least fixed point operation and binary supremum, Computer Science Logic (Fischbachau, 2000), LNCS 1862, 2000, 302–316.
Z. E´sik, Continuous additive algebras and injective simulations of synchronization trees, J. Logic and Computation, 12(2002), 271–300.

Z.
E´sik, Axiomatizing the equational theory of regular tree languages, J. Logic and Algebraic

Programming, 79(2010), 189–213.
Z. E´sik, Residuated Park theories, J. Logic Computation, published on line on Feb. 5, 2013.
Z. E´sik, Axiomatizing weighted bisimulation, to appear.
Z. E´sik and L. Bern´atsky, Scott induction and equational proofs, Mathematical Foundations of Programming Semantics, New Orleans, ENTCS 1(1995), 32 pages, available at: http://www.elsevier.nl.
Z. E´sik and T. Hajgat´o, Iteration grove theories with applications, CAI 2009, Thessaloniki, LNCS 5725, Springer, 2009, 227–249.

Z. E´sik and W. Kuich, Free iterative and iteration K-semialgebras, Algebra Universalis, 67(2012), 141–162.
Z. E´sik and W. Kuich, Free inductive K-semialgebras, J. Logic and Algebraic Programming, 82(2013), 111–122.
Z. E´sik and A. Labella, Equational properties of iteration in algebraically complete categories,
Theoretical Computer Science, 195(1998), 61–89.
F. G´ecseg and M. Steinby, Tree Automata, Akad´emiai Kiad´o, Budapest, 1986.
J.A. Goguen, J.W. Thatcher, E.G. Wagner and J.B. Wright, Initial algebra semantics and continuous algebras, J. ACM, 24(1977), 68–95.
W.F. Lawvere, Functorial semantics of algebraic theories, Proc. Nat. Acad. Sci. U.S.A., 50(1963) 869– 872.
R. Milner, Communication and Concurrency, Prentice Hall, 1989.
D. Park, Concurrency and automata on infinite sequences, Proc. 5th GI-Conference, Karlsruhe, LNCS 104, Springer, 1981, 167–183.
A.K. Simpson and G.D. Plotkin, Complete axioms for categorical fixed-point operators, LICS 2000, IEEE Press, 2000, 30–41.
Z. Sawa and P. Jancar, P-hardness of equivalence testing on finite-state processes, SOFSEM 2001, LNCS 2234, Springer, 2001, 326–335.
G. Winskel, Synchronization trees, Theoretical Computer Science, 34(1984), 33–82.
J.B. Wright, J.W. Thatcher, E.G. Wagner and J.A. Goguen, Rational algebraic theories and fixed-point solutions, 17th Ann. Symp. Foundations of Computer Science, FOCS 17, IEEE Press, 1976, 147–158.
