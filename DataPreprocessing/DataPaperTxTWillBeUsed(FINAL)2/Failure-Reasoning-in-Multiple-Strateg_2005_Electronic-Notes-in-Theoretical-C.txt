Electronic Notes in Theoretical Computer Science 125 (2005) 67–90  
www.elsevier.com/locate/entcs


Failure Reasoning in Multiple-Strategy Proof Planning
Andreas Meier1	Erica Melis2
German Research Center for Artiﬁcial Intelligence (DFKI) Saarbru¨cken, Germany

Abstract
Monitoring a solution process and applying the right action at the right moment are at the heart of intelligent problem solving by humans. This includes the analysis of failure events and the development of “recommendations” to overcome typical failures.
In this article, we present how meta-reasoning on failures is used in multiple-strategy proof planning with the Multi system. Multi allows for a flexible traversal of the search space and a flexible construction of the proof plan guided by mathematically motivated heuristics. Because of the flexible control in Multi failures can be exploited to guide subsequent proof plan manipulations and refinements. The failure reasoning cannot only ease the derivation of a solution proof plan but is required for some problems to find a solution at all.
Keywords: Proof Planning, Meta-Reasoning


Introduction
In a problem solving process, a step may not result in the expected progress or may not be applicable as expected. Hence, it is part of intelligent problem solving to analyze a failure event and to develop “recommendations” to handle typical failures, i.e., to guide the subsequent solution process. This also holds for mathematical theorem proving for which “monitoring the state of a solution as it evolves and taking appropriate action in the light of new information” is a key skill as Schoenfeld points out in his book on mathematical problem solving [16].

1 Email: ameier@dfki.de
2 Email: melis@dfki.de



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.01.004


Monitoring the solution process and using “recommendations” requires a flexible control approach and reasoning about the problem solving situa- tion. Intelligent humans do not rely upon pre-determined control to guide their problem solving. Instead, they draw upon a repertoire of heuristics for dynamic solution construction. As opposed to human problem solving, search- based theorem proving systems often employ restricted control components. Typically, e.g., in provers based on the resolution principle, the control is based on “local” general-purpose heuristics that reason on the current proof facts and the possible inferences. As result, the control decisions are restricted to the selection of the inference rule and the premises for the next step in the proof derivation. Other decisions are often hard-coded into the system and not subject to reasoning about control such that monitoring and overseeing the entire problem-solving process is hardly possible.
Proof planning is an approach to mathematical theorem proving in which the proof of a theorem is planned at the abstract level of so-called methods. The knowledge-based proof planning developed in the Ωmega group employs declarative meta-reasoning to guide the search [14]. Mathematically motivated heuristics cannot only reason about the current goals and assumptions but also about the proof planning history and the planning context. Moreover, in Ωmega’s automated multiple-strategy proof planner Multi the choice points that are subject to heuristic guidance are not restricted to the next goal and the next method. Rather, also the decisions on which strategy to choose can be guided, where strategies are independent proof plan operations, and different strategies can realize, for instance, different kinds of backtracking and different kinds of variable instantiation.
In extensive experiments we applied Multi to several mathematical do- mains. The analysis of Multi’s proof attempts revealed typical failure situ- ations as well as meta-reasoning patterns on how to deal with these failure situations. It turned out that during the automated proof construction with Multi such failure reasoning patterns do not only guide “clever” steps that ease the derivation of a solution proof plan but are often necessary to find a solution at all.
In this paper, we shall describe the realization of meta-reasoning on failures in the multiple-strategy proof planner Multi. First, we introduce the basics of proof planning with multiple strategies and point out how Multi’s flexible con- trol approach allows for a flexible handling of impasses in the proof planning process. Afterwards, section 3, we describe several failure reasoning patterns that analyze and exploit failures to guide proof plan manipulations and refine- ments. The subsequent sections, section 4 – 5, exemplify the realization and application of the failure reasoning patterns to proof plan ϵ-δ-problems. Al-


though we illustrate the failure reasoning patterns with ϵ-δ-proofs, this meta- reasoning is applicable to other domains as well as our empirical results in section 6 evidence. Section 7 concludes the paper with a discussion of related work.

Proof Planning with Multiple Strategies
Proof planning was originally conceived as an extension of tactical theorem proving to implement automated theorem proving at the abstract level of tactics. Bundy’s key idea in [3] is to augment individual tactics with pre- and postconditions. This results in planning operators, so-called methods. In the Ωmega [17] system proof planning is enriched by incorporating knowledge into the planning process [14] and the introduction of the additional hierarchical level of strategies [13].
Domain-specific knowledge can be encoded in methods and control rules. Methods can encode not only general proving steps but also steps particular to a mathematical domain. Heuristics guiding the search can be encoded in control rules. The control rules are evaluated at choice points in the planning process and can express meta-level reasoning about the current proof planning state as well as about the entire history of the proof planning process and the proof context. Further domain-specific knowledge can be contained in external systems that are incorporated into the proof planning process. For proof planning ϵ-δ-problems, which we shall discuss, in particular, the constraint solver CoSIE for equations and inequalities over the reals is important.
Proof construction may require to construct mathematical objects, i.e., to instantiate existentially quantified variables by witness terms. In proof planning, meta-variables are used as place holders for witness terms. When proof planning ϵ-δ-problems, equations and inequalities with meta-variables are passed to CoSIE. CoSIE checks the (in)consistency of the constraints and collects consistent constraints in a constraint store. Later, it tries to compute instantiations for the meta-variables that satisfy the collected constraints [18]. The simplest version of proof planning, realized in the previous proof plan- ner of Ωmega, searches at the level of methods only, i.e., as long as there are goals it searches for applicable methods and applies the instantiated methods, which are called actions. The final sequence of actions forms a solution plan. The application of the operations backtracking and meta-variable instantia- tion is hard-wired with the action introduction: The proof planner backtracks, if and only if there is a goal to which no method is applicable. If this is the case, the planner backtracks the action that introduced this goal. Moreover,
it instantiates meta-variables at the end only, when all goals are closed.


Case-studies revealed that this proof planning approach is somewhat in- flexible and fails for a number of problems (e.g., see [13]). In particular, the previous proof planner of Ωmega fails for problems whose solution requires reasoning on failures. Because of its hard-coded control and its restricted functionalities, it neither provides choice points to reason on failures nor suit- able alternatives (e.g., different kinds of backtracking) to choose from. For instance, consider the following two impasses: (1) If no method is applicable, then the application of a particular backtracking operation is hard-coded in the planner; reasoning on the failure and choosing between different kinds of reactions is not possible. (2) The meta-variables are always instantiated at the end by incorporated constraint solvers. When the constraint solvers fail, then reasoning on this failure and choosing alternative actions to overcome it are also not possible.
These observations as well as the observation of further drawbacks of the previous proof planning approach (see [13]) motivated the development of proof planning with multiple strategies. Proof planning with multiple strate- gies decomposes the previously monolithic proof planning process and replaces it by separate strategies, which are instances of parameterized algorithms for different proof plan refinements and modifications.
We implemented proof planning with multiple strategies in the proof plan- ner Multi [13]. Among others, Multi employs general algorithms for action introduction, meta-variable instantiation, and backtracking. The algorithm for action introduction has parameters for a set of methods and a set of control rules. When Multi executes a strategy of this algorithm, then the algorithm introduces only actions that use the methods specified in the strategy. The choices during the action computation and selection are guided by the control rules specified by the strategy. The single parameter of the instantiation algo- rithm is a function that determines how the instantiation for a meta-variable is computed. If Multi applies an instantiation strategy wrt. a meta-variable mv and if the computation function of the strategy yields a term t for mv, then the instantiation algorithm substitutes mv by t in the proof plan. The single parameter of the backtrack algorithm is a function that computes a set of refinement steps of other algorithms that have to be deleted. When Multi applies a backtrack strategy, the algorithm removes all refinement steps that are computed by the function parameter of the strategy as well as all steps that depend from these steps. Sample strategies of all three algorithms are discussed in section 4 and section 5.
In Multi, no sequence of strategies is pre-defined or hard-coded in a control cycle. Rather, Multi’s blackboard architecture enables the flexible cooperation of independent strategies guided by meta-reasoning in strategic control rules.

In a nutshell, Multi operates according to the following cycle:
Job Offers Applicable strategies post their applicability in form of so-called job offers onto the blackboard.
Guidance Strategic control rules are evaluated to order the job offers.
Invocation The strategy with the highest ranked job offer is invoked.
Execution The algorithm of the invoked strategy is executed with respect to the parameter instantiation specified by the strategy.
Note that the execution of an action introduction strategy can be inter- rupted (i.e., interruption is a choice point in the action introduction algo-
rithm). In this case, Multi can first apply some other strategies and then
re-invoke the interrupted strategy execution. A detailed, technical description of the Multi system can be found in [10].
Failures in the action introduction algorithm, i.e., a goal for which no method is applicable, result in an interruption of the action introduction al- gorithm. Multi continues to work at the strategy level by collecting job offers and evaluating strategic control rules to rank the job offers. Similar to the previous proof planner, Multi’s default approach to deal with such a failure is to backtrack the action that introduced this goal. However, this backtrack approach is not hard-coded into Multi’s algorithm. Rather, it is realized by an according strategy of the backtrack algorithm and a strategic control rule that guides the application of this backtrack strategy after such a failure. Fur- ther backtrack strategies can be encoded that delete different sets of actions. Moreover, further strategic control rules overwriting this default behavior can be specified that reason on the failure and guide suitable subsequent proof plan refinements and modifications. Also reasoning on failing meta-variable instantiations is possible, since in Multi the instantiation of meta-variables is not pre-defined to be the final proof plan refinement.

Failure Reasoning
For many situations, the default handling of failures in Multi (see previous section) is not sufficient. Rather, different handling of failures is necessary. The reasons for this are twofold:
Theorem proving often requires steps whose necessity is difficult to predict. Reasoning about a situation in which a failure occurred can suggest certain recovery or solution steps. Hence, the failures and their productive use can hold the key to discover a solution proof plan.
Goals and applications of methods and strategies can be intertwined in complex ways. In particular, the incorporation of constraint solving into proof


planning causes dependencies that make a “standard” handling of failures difficult. Rather, dependencies have to be analyzed in order to guide suitable reactions.
In the following, we shall discuss several domain-independent and general meta-reasoning patterns on typical failures. The meta-reasoning patterns are declaratively encoded into corresponding control rules. This encoding and the concrete application to ϵ-δ-problems are discussed in section 5.
Guiding Case Splits
Case-split is a well-known technique in mathematics. But when is it useful to apply it and which cases should be considered? The following general pattern describes the need for a case-split: there is a main goal, which can be solved by methods introducing some side goals. These side goals are called conditions. If one of the conditions cannot be solved, then a partial success, i.e., the solution of the main goal, gives rise to consider patching the proof attempt by a case-split on the failing condition. Then, the main goal has to be proved for each case. This approach corresponds to the meta-reasoning pattern:

In the concrete application of this meta-reasoning pattern to ϵ-δ-problems, see section 5, we shall explain how the main goal and the side goals are deter- mined in this domain.
Unblock Meta-Variable Instantiation
During the proof planning process the application of certain key steps can become particularly “desirable”. If such a desirable step should be ap- plied but is blocked, then the application of other steps should be considered, which will unblock the desirable step. As example consider strategies of the instantiation algorithm that employ constraint solvers. When all goals are closed, the application of these strategies becomes highly desirable to instan- tiate the meta-variables. However, when the constraint solvers fail because the constraints collected so far are not sufficient, then the application of these strategies fails. A possibility to overcome this problem is to refine the existing constraints in order to obtain an extended set of refined constraints for which a solution exists. This approach corresponds to the meta-reasoning pattern:



In the concrete application of this meta-reasoning pattern to ϵ-δ-problems, see section 5, we shall explain how certain steps are selected for backtracking in order to enable the creation of further constraints in this domain.
Analysis of Meta-Variable Dependencies
The instantiations of meta-variables and constraints on the meta-variables cause dependencies among goals that share these meta-variables. Take, e.g., two goals J and J' that both contain a meta-variable mv. Now assume that Multi first creates a partial proof plan for J and binds mv in such a way that J' cannot be proved anymore. The default backtracking in Multi would remove J'. However, the actual problem is not J' but the selection of an appropriate instantiation for mv. That is, part of the subplan for J has to be removed to introduce another subplan that instantiates mv differently. This approach corresponds to the general meta-reasoning pattern:

In the concrete application of this meta-reasoning pattern to ϵ-δ-problems, see section 5, we shall explain how the causal connection of a failure with the instantiation of a meta-variable or constraints on meta-variables is determined in this domain.

Proof Planning ϵ-δ-problems
We shall elaborate the usage of these meta-reasoning patterns for ϵ-δ-problems, which prove statements about the limit, the continuity, or the derivative of a function f at a point a. The standard definitions of limit, continuity, and derivative comprise a dependency of a δ from an ϵ. For instance, the defini- tions of limit and continuity are:
lim f = l ≡
x→a
∀ϵ (0 < ϵ ⇒ ∃δ (0 < δ ∧ ∀x (|x − a| > 0 ∧ |x − a| < δ ⇒ |f (x) − l| < ϵ)))

cont(f, a) ≡ ∀ϵ (0 < ϵ ⇒ ∃δ (0 < δ ∧ ∀x (|x − a| < δ ⇒ |f (x) − f (a)| < ϵ)))
An example theorem is the Cont-If-Deriv problem that states that, if a func- tion f has a derivative f ' at point a 3 , then f is continuous at a. When the definitions of limit and continuity are expanded, then the problem’s assump- tion is
∀ϵ1 (0 < ϵ1 ⇒
∃δ1 (0 < δ1 ∧ ∀x1 (|x1 − a| < δ1 ∧ |x1 − a| > 0 ⇒ | f(x1)−f (a) − f '| < ϵ1)))
and the problem’s theorem is
∀ϵ (0 < ϵ ⇒ ∃δ (0 < δ ∧ ∀x (|x − a| < δ ⇒ |f (x) − f (a)| < ϵ))).
An ϵ-δ-proof of this problem as well as of similar theorems constructs a real number δ depending on ϵ that satisfies certain inequalities. 4 The usual pro- cedure for discovering a suitable δ is the incremental restriction of the range of values. Proof planning adopts this approach by replacing unknown witness terms such as δ by meta-variables and by cooperating with the constraint solver CoSIE, which collects constraints on the meta-variables.
In the remainder of this section, we describe the strategies employed by Multi to accomplish ϵ-δ-proofs. A more detailed description of this application of Multi is given in [10].
Strategies
Central for accomplishing ϵ-δ-proofs with Multi is the action introduction strategy SolveInequality, see Table 1. It is applicable to goals whose formu- las are inequalities. SolveInequality mainly comprises methods that deal with inequalities such as FactorialEstimate, ComplexEstimate, Solve*-B, TellCS, and AskCS. The control rule prove-inequality is in the list of control rules of SolveInequality.
When faced with an inequality goal, SolveInequality first tries to apply

the methods TellCS and AskCS, which both interface CoSIE.
TellCS

passes the goal as constraint to CoSIE (provided it is consistent with the constraints collected by CoSIE so far), whereas AskCS asks CoSIE whether the goal is entailed by its current constraints. If an inequality is too complex to be handled by CoSIE, then SolveInequality tries to apply methods such as



3 That is, if lim
x1 →a
f (x1)−f (a)	′
x1 −a

4 The construction of a δ is is a non-trivial task for students as well as for traditional, resolution-based automated theorem provers. Bledsoe proposed several versions of the prob- lem Lim+ as a challenge problem for automated theorem proving [2]. The simplest versions of this problem (problem 1 and 2 in [2]) are at the edge of the capabilities of traditional automated theorem provers but the harder versions are beyond their capabilities. More difficult problems such as Cont-If-Deriv cannot be proved by traditional provers.


Table 1
The SolveInequality strategy.

Simplify, Solve*-B, ComplexEstimate, and FactorialEstimate that reduce an inequality to simpler inequalities. For instance, applications of the ComplexEstimate method exploit the Triangle Inequality and reduce a goal with formula |b| < e to simpler inequalities in case there is an assumption |a| < e' and b = k∗a+l holds for suitable terms k and l. 5 The resulting simpler goals
are |l| < e , e' <  e  , |k| ≤ mv, and 0 < mv, where mv is a new meta-variable.
2	2∗mv
The method FactorialEstimate deals with fractions in inequalities.  It
reduces a goal of the form |  t | < t'' to the three subgoals 0 < mv , mv	<
t'	F	F
|t'|, and |t| < t'' ∗ mvF , where mvF is a new meta-variable. Applications of
Solve*-B exploit transitivity of <, >, ≤, ≥ and reduce a goal with formula a1 < b1 to a new goal with formula b2σ ≤ b1σ in case an assumption a2 < b2 exists and a1, a2 can be unified by the substitution σ. The method Simplify employs computer algebra systems to perform arithmetic simplifications of terms. When applied to a goal with arithmetic subterms that can be simplified by the computer algebra systems, it reduces the goal to a new goal with simplified subterms.
So, SolveInequality successively produces simpler inequalities until inequal- ities are reached that are accepted by CoSIE. This approach – handle with CoSIE or simplify – is guided by the control rule prove-inequality. This rule first checks whether the current goal is an inequality. If this is the case, it prefers the methods of SolveInequality in the desired order: TellCS, AskCS, Simplify, Solve*-B, ComplexEstimate, FactorialEstimate etc.
To derive ϵ-δ-proofs Multi also employs the domain-independent action introduction strategies NormalizeGoal and UnwrapAss. Both strategies contain general methods for the decomposition of logic connectives and quantifiers. Whereas applications of NormalizeGoal decompose goals, applications of Un-

5 Part of the application of the method is the computation of k, l for given b and a. This is done by the incorporated computer algebra system Maple.

wrapAss decompose assumptions.
In order to instantiate meta-variables that occur in constraints collected
by CoSIE, Multi employs the two instantiation strategies InstIfDetermined
and ComputeInstFromCS. The first is applicable only, if CoSIE states that a
meta-variable is already determined by the constraints collected so far. Then, the computation function connects to CoSIE and receives this instantiation for the meta-variable. ComputeInstFromCS is applicable to all meta-variables for which constraints are stored in CoSIE. The computation function of this strategy requests from CoSIE to compute an instantiation for a meta-variable that is consistent with all constraints collected so far.
Application and Cooperation of the Strategies
For proof planning an ϵ-δ-problem Multi typically proceeds as follows:
First, it applies NormalizeGoal to decompose the initial goal. Afterwards, it applies SolveInequality to the resulting inequality goals. Some methods of the strategy SolveInequality can only be applied when suitable assumptions are

available (e.g.,
ComplexEstimate and Solve*-B). In case SolveInequal-

ity detects promising subformulas of assumptions, it interrupts (guided by one of its control rules) such that Multi can apply UnwrapAss to unwrap the promising subformula. Afterwards, SolveInequality can proceed and use the new assumption.
The invocation of ComputeInstFromCS is delayed by a strategic control rule until all goals are closed. This delay of the computation of instantiations for meta-variables is sensible since the instantiations should not be computed before all constraints are collected, i.e., only after all goals are closed. However, if the current constraints already determine a meta-variable, then a further delay of the corresponding instantiation is not necessary. Rather, immediate instantiations of determined meta-variables can simplify a problem [13]. To allow for the flexible instantiation of determined meta-variables SolveInequality can interrupt and cooperate with the strategy InstIfDetermined.



How Failure Reasoning Works (Examples)

There are default application and cooperation of strategies to accomplish ϵ-δ- proofs (see previous section). In addition, since Multi does not pre-define an order or combination of strategies, control rules can be added, which override the default behavior and implement failure reasoning patterns.

Guiding the Introduction of Case-Splits
The Cont-If-Deriv problem is an example for an ϵ-δ-problem that needs the introduction of a case-split. When tackling this problem, Multi starts as usual for ϵ-δ-proofs. It decomposes the theorem with the strategy NormalizeGoal and derives the inequality goals 0 < mvδ and |f (cx) − f (a)| < cє (where mvδ is a new meta-variable and cx and cє are new constants) to which it applies SolveInequality. SolveInequality passes the first goal with an application of the method TellCS as constraint to CoSIE but fails to reduce the second goal. Since in the initial assumption it detects | ƒ(x1)−ƒ (a) − f '| < ϵ1 as a subformula,
which could be used, it interrupts. Multi applies the strategy UnwrapAss
whose application yields the new assumption
| ƒ (mvx1 )−ƒ (a) − f '| < mv
mvx1 −a	є1
and the three new goals 0 < mvє1 , |mvx1 − a| < cδ1 , and |mvx1 − a| > 0 (where
mvx1 and mvє1 are new meta-variables and cδ1 is a new constant).
With the new assumption, the strategy SolveInequality closes the main goal |f (cx) − f (a)| < cє in several steps. In between, SolveInequality interrupts once and switches to InstIfDetermined, which introduces the binding mvx1 →cx. Then, it tackles the new goals from the application of UnwrapAss. It succeeds to solve 0 < mvє1 and |mvx1 − a| < cδ1 but fails to solve |mvx1 − a| > 0, which meanwhile became |cx − a| > 0 wrt. the introduced binding mvx1 →cx. Thus, in this situation, Multi can solve the main goal |f (cx) − f (a)| < cє with an assumption that has some conditions. When Multi uses the assumption, then it introduces the conditions as new goals. Later, it fails to prove one of these conditions, |cx − a| > 0.
The meta-reasoning pattern Case-Split Introduction analyzes the failure and
suggests its “repair”. Technically, the pattern is realized in Multi by one
additional backtrack strategy and two control rules, one strategic control rule and one control rule in SolveInequality, which guide suitable backtracking and the introduction of the case-split. This works as follows: If SolveInequality fails to prove a condition of an assumption that was used to prove the main goal, then the strategic control rule triggers the additional backtrack strategy, which deletes all actions following the introduction of the failing condition.
In our example, the application of UnwrapAss and all actions that depend on it are backtracked such that |f (cx)−f (a)| < cє becomes a goal again. When Multi re-invokes SolveInequality after this backtracking, then the control rule in SolveInequality fires and suggests the application of the method CaseSplit for the failing condition and its negation. Afterwards, SolveInequality has to prove |f (cx) − f (a)| < cє twice: once under hypothesis |cx − a| > 0 and once under hypothesis ¬(|cx − a| > 0).




(Case 1) [|cx − a| > 0]
(Case 2) [¬(|cx − a| > 0)]



|f (cx) − f (a)| < cє
|f (cx) − f (a)| < cє

CaseSplit

|f (cx) − f (a)| < cє
For the first case it proceeds as described above. The failing condition
|cx − a| > 0 now follows from the hypothesis of the case. The second case is solved differently by SolveInequality. First, it simplifies the hypothesis ¬(|cx − a| > 0) to cx = a. Afterwards, it uses this equation to simplify the goal
|f (cx) − f (a)| < cє to 0 < cє, which follows from an introduced hypothesis.
Other ϵ-δ-problems also require this kind of failure reasoning (see sec- tion 6). In other mathematical domains the same pattern occurs and leads to a case-split introduction (see discussion of related work in section 7). Whereas the failure reasoning pattern is domain independent, the actual case-split may depend on the mathematical domain. Examples for possible domain depen- dent case-splits are:
a > 0,a < 0,a =0 
n = 1,n > 1
x ∈ S, x /∈ S
So far, however, we employ a general case-split into the cases cond and ¬cond
only.

Meta-Reasoning for Repair of Constraint Handling
The problem Lim-Div is an example problem for which backtracking is guided by meta-reasoning on a highly desirable but blocked strategy. To the knowl-
edge of the authors this is a problem that has not been proved by any other system. It states that the limit of the function 1 at point c is 1 :
x	c
∀ϵ (0 < ϵ ⇒ ∃δ (0 < δ ∧ ∀x (|x − c| < δ ∧ |x − c| > 0 ⇒ | 1 − 1| < ϵ)))

x	c
The decomposition of the initial complex goal by NormalizeGoal results in the two goals 0 < mvδ and |  1  − 1| < cє (where mvδ is a new meta-variable
cx	c
and cx and cє are new constants). SolveInequality closes the first goal by an
application of TellCS whereas it simplifies the second goal to | c−cx | < cє. An application of FactorialEstimate to this goal results in the three new goals 0 < mvƒ , |cx ∗ c| > mvƒ , and |c − cx| < mvƒ ∗ cє (with the new meta-variable

mvƒ ). SolveInequality closes these three goals with TellCS. This results in the proof plan tree for |  1  − 1| < cє in figure 1, where [|cx − c| < mvδ] is an
cx	c
assumption that is created during the application of NormalizeGoal but is not
used so far.







Fig. 1. Initial proof plan tree for |  1  − 1 | < cc.
cx	c

Now all goals are closed and in the default behavior CoSIE is supposed to provide instantiations for the meta-variables mvδ and mvƒ . That is, the strategy ComputeInstFromCS, which asks CoSIE to compute the instantia- tions, becomes a highly desirable strategy. However, CoSIE fails to compute instantiations here and ComputeInstFromCS does not succeed. What is the problem? So far, CoSIE collected the constraints
|cx−c| < mvƒ , 0 < mvƒ , mvƒ < |cx ∗ c|, 0 < mvδ, 0 < c, and 0 < cє.
These constraints are consistent but a solution for mvƒ exists only, if

|cx−c|
cc
< |cx ∗ c| holds.  This, however, does not follow from the collected

constraints. In particular, the constraints collected so far are not sufficient
for an ϵ-δ-proof since they do not establish a connection between cє and mvδ. A possibility to overcome this problem is to refine the existing constraints in order to obtain an extended set of refined constraints for which a solution exists. That is, selected applications of TellCS (and only these selected ap- plications) have to be backtracked in order to enable further refinement of some constraints.
The meta-reasoning pattern Unblock Meta-Variable Instantiation analyzes the fail- ure and suggests its “repair”. Technically, the pattern is realized in Multi by the strategic control rule backtrack-to-unblock-cosie. When all goals are closed, but the strategy ComputeInstFromCS is not applicable since the con- straint solver fails to compute instantiations, then this control rule analyzes the constraints passed by applications of TellCS. It triggers the backtracking of actions of TellCS that pass inequalities to CoSIE that can be refined to simpler inequalities by applications of methods such as ComplexEstimate. 6

6 Currently, the critical constraints are chosen by heuristics encoded in backtrack- to-unblock-cosie. It would be more convenient, if CoSIE would directly point out what the critical constraints are. However, this kind of information is not provided by the CoSIE


Then, these simpler inequality goals are may passed to the constraint solver. In our example, backtrack-to-unblock-cosie triggers Multi to back-

track the application of
TellCS
that closes |c − cx| < mvƒ ∗ cє.	Then,

SolveInequality applies the method ComplexEstimate to the re-opened goal. This action uses the assumption |cx − c| < mvδ and reduces |c − cx| < mvƒ ∗ cє
to the new goals |0| < cc∗mvf , mv ≤ cc∗mvf , |− 1| ≤ mv, and 0 < mv (where
mv is a new meta-variable). Afterwards, TellCS passes the new inequality goals to CoSIE. The resulting refined proof plan tree for |c − cx| < mvƒ ∗ cє is given in figure 2.

Fig. 2. Refined proof plan tree for |c − cx| < mvf ∗ cc.

Since CoSIE also fails on this extended constraint set the strategic control rule backtrack-to-unblock-cosie guides the backtracking of the application of TellCS that closes |cx ∗ c| > mvƒ . Again, SolveInequality reduces the re- opened goal with ComplexEstimate. This action makes again use of the assumption |cx − c| < mvδ and reduces |cx ∗ c| > mvƒ to the new goals
mvf
|c ∗ c| ≥ mvƒ ∗ 2, mvδ ≤	, |c| < mv', and 0 < mv' (where mv' is a new
meta-variable). Afterwards, SolveInequality passes again the new inequality goals to CoSIE by applications of TellCS. Figure 3 depicts the resulting refined proof plan tree for |c − cx| < mvƒ ∗ cє.

Fig. 3. Refined proof plan tree for |cx ∗ c| > mvf .

This results (after some CoSIE-internal simplifications) in the following con- straint store:

Now the following bindings consistent with these constraints can be computed:

mv→2, mv'→c + 1, mv
→ c2 , and mv →min( cc ∗c2 ,	c2	).



ƒ	2	δ
8	2∗(c+1)



system yet.


All ϵ-δ-problems in which subgoals with fractions occur need to repair the constraint reasoning (see section 6). In other domains the same meta- reasoning to overcome blocked instantiations of constraint solvers is applicable.

Analyzing Meta-Variable Dependencies
As example for an ϵ-δ-problem that needs the analysis of meta-variable de- pendencies consider the following problem:
lim f (a ∗ x)= l follows from lim f (x1)= l and a > 0.
x→0	x1 →0
Unfolding of the occurrences of limit and normalization result in the goal
|f (a ∗ cx) − l| < cє. Unwrapping the initial assumption yields the new as- sumption |f (mvx1 ) − l| < mvє1 , which can be used to close the goal. Thereby, mvx1 is instantiated by a ∗ cx. The unwrapping of the initial assumption also yields two goals, which become |a ∗ cx| > 0 and |a ∗ cx| < cδ1 wrt. the instantiation mvx1 '→ a ∗ cx. These two goals can be closed with two assump- tions from the normalization of the initial theorem: |cx| > 0 and |cx| < mvδ. This works as follows: apply ComplexEstimate with the first assumption to the first goal and pass the resulting inequality goals to CoSIE and ap- ply ComplexEstimate with the second assumption to the second goal and pass the resulting inequality goals to CoSIE. Figure 4 sketches the resulting solution proof plan tree for the two goals |a ∗ cx| > 0 and |a ∗ cx| < cδ1 .

Fig. 4. Sketch of solution proof with ComplexEstimate.

Since the control rule prove-inequality suggests the method Solve*-B

before the method
ComplexEstimate,
Multi does not find this solution

directly. Rather, Multi applies Solve*-B to the first goal |a ∗ cx| > 0 wrt. the second assumption |cx| < mvδ. This is possible since |cx| < mvδ equals mvδ > |cx| and mvδ can be trivially unified with |a ∗ cx|. This results in the instantiation mvδ '→ |a ∗ cx| and the new goal |cx| > 0, which equals the first assumption. Next, Multi tackles the second goal |a ∗ cx| < cδ1 but fails. With the introduced instantiation of mvδ the assumption |cx| < mvδ becomes
|cx| < |a ∗ cx| and a solution of the goal |a ∗ cx| < cδ1 with this assumption is not possible anymore. However, not the second goal is problematic in the end, but the instantiation of mvδ introduced during the solution of the first goal. Figure 5 depicts the failing proof plan tree for the two goals |a ∗ cx| > 0 and |a ∗ cx| < cδ1 .



Fig. 5. Failing proof attempt with Solve*-B.


The meta-reasoning pattern Analyze MV-Dependencies analyzes the failure and
suggests its “repair”. Technically, the pattern is realized in Multi by the
strategic control rule prefer-constraints-deletion, which guides the back- tracking of steps that introduce instantiations or constraints for meta-variables instead of the default backtracking. In this case, the strategic control rule an- alyzes that the instantiation mvδ '→ |a ∗ cx| is very unlikely to be part of a solution of an ϵ-δ-problem since the meta-variable for δ is supposed to be constrained during the proof planning process but not to be instantiated by different means than CoSIE. Hence, the control rule guides the backtracking of the Solve*-B step that closed the first goal. As result, Multi has to tackle the first goal differently, which finally results in the solution of both goals sketched above.
Note that the control rule prefer-constraints-deletion can also guide the successive trial and error of meta-variable instantiations. When Multi fails to solve a goal under a particular instantiation, then the instantiation of the meta-variable has to be backtracked (in order to try the next in- stantiation), rather than the goal for which Multi actually fails. The suit- able backtracking is guided by prefer-constraints-deletion, which over-
writes the default backtracking in Multi in this case.	A domain, where
prefer-constraints-deletion is used for such a trial and error of meta- variable instantiations are residue class problems (see [12,9]).


Empirical Results

Although our contribution is fundamentally conceptual and architectural, we had to show whether it is empirically relevant as well. Therefore, we tested the benefit in two domains, the ϵ-δ-proofs from the analysis textbook [1] and the residue class domain. Table 2 gives sample problems from the two domains and the failure-reasoning they require. Moreover, we included in Table 2 inductive proofs produced by the proof planner CLaM that also require failure reasoning.


ϵ-δ-proofs
The relevance of failure reasoning in this domain is not only demonstrated by Table 2. Its figures alone are underestimating because many similar prob- lems can be formulated. Moreover, the relative frequency of failure reasoning is also important. Therefore, the fact that 22 out of 65 ϵ-δ-proofs constructed by Multi from the systematically explored testbed [1] involve failure reasoning evidences the crucial role of failure reasoning. In the appendix we give a com- plete list of all ϵ-δ-proofs constructed by Multi that require failure reasoning.

Table 2
Sample proofs whose solution requires meta-reasoning about failures. The numbered colons denote (i) case split introduction, (ii) unblock meta-variable instantiation, (iii) analyze
meta-variable dependencies. Note that x → a− and x → a+ denote the left-hand limit and the right-hand limit.


Residue Class Problems
The residue class conjectures classify given residue class structures wrt. their algebraic category. An example theorem is “the residue class structure

(ZZ5, +¯ ) is associative”. Other problems from this domain concern the isomor- phy of two algebraic structures. An example is “the residue class structures (ZZ5, +¯ ) and (ZZ5, (x+¯ y)+¯ ¯15) are isomorphic”.
To tackle residue class problems we developed several techniques encoded
in four different method-introduction strategies in Multi. In one of these
strategies, the TryAndError strategy (see [12]), the Analyze MV-Dependencies pat- tern is crucial since Multi has to deal with nested existential quantifiers, which result in ‘nested’ meta-variables shared by several goals. Hence, dependencies among the meta-variables and the goals have to be analyzed.
We proved about 19.000 residue class conjectures with Multi. About half of these theorems, in particular, theorems refutating a property, could be proved with the TryAndError strategy only (see [12] for detailed description of the experiments). Some representative examples occur in Table 2.

Inductive Proofs
So far, we did not apply Multi to inductive proofs. The inductive theorems in Table 2 are taken from [8], which describes failure reasoning by so-called critics in the proof planner CLaM. Since the critics employed in CLaM are a special case bound to a particular method (see related work in section 7), our general failure reasoning pattern for case-split introduction is applicable for inductive proofs as well. For a more complete list of inductive proofs that require failure reasoning see [8].

Discussion
Failure reasoning – as any control reasoning in Multi – can change the search space traversed by Multi. The actual effect of the change can vary: it can delete alternatives and prune the search space or it can introduce new alternatives that extend the search space. The three failure reasoning patterns described in this article all introduce some alternatives.
For instance, case-split introduction guided by failure reasoning introduces the new alternative case-split where otherwise Multi would perform backtrack- ing. Thus, it extends the potential search space and can produce “overhead” as opposed to a run of Multi without the failure reasoning. Actually, this does not happen for the ϵ-δ-proofs currently solvable by Multi 7 but it happens for the (failing) application of Multi to non-theorems. As example non-theorem

consider lim
x→a−
f (x)= l ⇒ lim f (x)= l, which is similar to the second problem
x→a



7 That is, for none of the ϵ-δ-proofs currently solvable by Multi without failure reasoning, the search space traversed by Multi is extended by the failure reasoning.


in Table 2. When guided by failure reasoning, Multi introduces for this non- theorem a case-split similar to the case-split for the second problem in Table 2 (see [11] for details). This considerably extends the search space traversed by Multi for the non-theorem.
Since the knowledge engineering for proof planning is pretty difficult, the number of mathematical domains and problems successfully tackled by proof planning so far is growing only slowly. However, if not quantitatively then at least qualitatively, there is striking evidence for the need to meta-reason about failures in mathematics since the identified meta-reasoning patterns rely upon common techniques in mathematics. As evidence for this statement consider that failure reasoning in the proof planner CLaM (see related work in section 7) also exploits failures to guide the introduction of case-splits in a similar way but in a completely different mathematical domain, i.e., proving theorems by mathematical induction.

Conclusion and Related Work
We described three meta-reasoning patterns by which the multiple-strategy
proof planner Multi productively exploits failures to guide the subsequent
proof planning process. They represent heuristics suggesting how to handle a failure that occurs in conjunction with a pattern of partially successful steps. The meta-reasoning patterns do not only circumvent failures, they hold the key to the construction of a solution proof plan.
The described failure reasoning and the repair modifications are possible since Multi does not enforce a pre-defined systematic backtracking. Rather, when a failure occurs, then strategic control rules in which our heuristics are declaratively encoded can analyze the failure and can dynamically guide promising refinements and modifications of the proof plan. All the meta- reasoning patterns are generally applicable rather than over-specific as shown in the experiments (see section 6). Further meta-reasoning that exploits the flexible control in Multi is discussed in [9].

Related Work
Failure Reasoning in CLaM
Failure reasoning in the proof planner CLaM [15] is closely related to the introduction of case-splits and lemmas in Multi. In [7] and [8], Ireland and Bundy describe critics as a means to patch failed proof attempts in CLaM by exploiting information on failures. The motivation for the introduction of critics is similar to our motivation for failure reasoning: failures in the proof

planning process often hold the key to discover a solution proof plan.
Critics in CLaM extend the hierarchy of inference rules, tactics, and meth- ods. A critic is associated with one method – mostly with the wave method – and captures patchable exceptions to the application of this method. Critics are expressed in terms of preconditions and patches. The preconditions an- alyze the reasons why the method has failed to apply. The patch suggests a change to the proof plan.
The situations that trigger case-split introduction and lemma speculation in CLaM and Multi are very similar: unprovable premises of conditional facts from the context trigger case-split introduction, whereas missing premises in the current context trigger lemma speculation. However, the critics mech-

anism in CLaM and failure reasoning in
Multi considerably differ not only

in minor technical issues but also in their conceptual design. Critics are a method-like entity directly bound to failing preconditions of a particular method. Moreover, part of a critic is a patch of the failure, which is a special procedure that changes the proof plan. In contrast, failure reasoning in Multi is conducted by declarative and separate control rules. These control rules are not associated with a particular method but rather test for particular sit- uations that can occur during the proof planning process (independent of the strategy or method that caused the situation). The control rules can reason about the current proof plan and about other information such as the history. The patch of a failure is not implemented into special procedures but is carried out by methods and strategies whose application is suggested by the control rules.




Dynamic Backtracking
Typically, backtracking methods return to prior points in the spanned search tree and thereby often erase meaningful progress towards a solution. As opposed thereto, Multi enables the backtracking of selected steps (and all steps that explicitly depend on them). This can result in a new proof plan not in the search tree traversed so far. In [6] Ginsberg describes a backtracking approach for the solution of constraint satisfaction problems that is similar to Multi’s. His approach also enables the deletion of selected steps without removing all steps introduced after these steps (provided that these other steps do not explicitly depend on the steps selected for deletion). He uses the term “dynamic” backtracking because of the dynamic way in which the search is structured.


Meta-Reasoning in Blackboard Systems
Related to the unblocking of desirable steps in Multi is the control rea- soning in elaborate blackboard systems, e.g., see [4] and [5]. When a highly desirable knowledge source is not applicable, then reasoning on the failure can suggest the invocation of knowledge sources that unblock the desired knowl- edge source.

References
Bartle, R. and D. Sherbert, “Introduction to Real Analysis,” John Wiley& Sons, New York, 1982.
Bledsoe, W., Challenge Problems in Elementary Analysis, Journal of Automated Reasoning 6
(1990), pp. 341–359.
Bundy, A., The Use of Explicit Plans to Guide Inductive Proofs, in: Proceedings of CADE–9, LNCS 310 (1988), pp. 111–120.
Corkill, D., V. Lesser and E. Hudlicka, Unifying Data-Directed and Goal-Directed Control, in:
Proceedings of AAAI-82 (1982), pp. 143 – 147.
Durfee, E. and V. Lesser, Incremental Planning to Control a Blackboard-Based Problem Solver, in: Proceedings of AAAI-86 (1986), pp. 58 – 64.
Ginsberg, M., Dynamic Backtracking, Journal of Artificial Intelligence Research 1 (1993),
pp. 25—46.
Ireland, A., The Use of Planning Critics in Mechanizing Inductive Proofs, in: Proceedings of LPAR’92, LNAI 624 (1992), pp. 178–189.
Ireland, A. and A. Bundy, Productive Use of Failure in Inductive Proof, Journal of Automated Reasoning 16 (1996), pp. 79–111.
Meier, A., “Multi – Proof Planning with Multiple Strategies,” Ph.D. thesis, Fachbereich Informatik, Universit¨at des Saarlandes, Saarbru¨cken (2004).
Meier, A., The Proof Planners of Ωmega: A Technical Description, Seki Report SR-04-03, FR Informatik, Saarland University, Saarbru¨cken, Germany (2004).
Meier, A. and E. Melis, Proof Planning Limit Problems with Multiple Strategies, Seki Report SR-04-04, FR Informatik, Saarland University, Saarbru¨cken, Germany (2004).
Meier, A., M. Pollet and V. Sorge, Comparing Approaches to Explore the Domain of Residue Classes, Journal of Symbolic Computation 34 (2002), pp. 287–306.
Melis, E. and A. Meier, Proof Planning with Multiple Strategies, in: Proceedings CL-2000, LNAI
1861 (2000), pp. 644–659.
Melis, E. and J. Siekmann, Knowledge-Based Proof Planning, Artificial Intelligence 115 (1999),
pp. 65–105.
Richardson, J., A. Smaill and I. Green, System description: Proof planning in higher-order logic with λClam, in: Proceedings of the 15th International Conference on Automated Deduction (CADE–15), LNAI 1421 (1998), pp. 129–133.
Schoenfeld, A., “Mathematical Problem Solving,” Academic Press, New York, 1985.
Siekmann, J., C. Benzmu¨ller, V. Brezhnev, L. Cheikhrouhou, A. Fiedler, A. Franke, H. Horacek,
M. Kohlhase, A. Meier, E. Melis, M. Moschner, I. Normann, M. Pollet, V. Sorge, C. Ullrich,
C. Wirth and J. Zimmer, Proof Development with OMEGA, in: Proceedings of CADE–18, number 2392 in LNAI (2002), pp. 144–149.
Zimmer, J. and E. Melis, Constraint solving for proof planning, Journal of Automated Reasoning (2004), accepted.

Appendix: ϵ-δ-Proofs Requiring Failure Reasoning

Case-Split Introduction:
If function f has the limit f (a) at a, then f is continuous at a: lim f (x)= f (a) ⇒ cont(f, a).
x→a
(Cont-If-Deriv: Theorem 6.1.2 in [1])
If function f has a derivative at a, then f is continuous at a: deriv(f, a)= f ' ⇒ cont(f, a).
(Theorem 4.3.3, second part, in [1])
If function f has the left-hand limit l and the right-hand limit l at a, then f has the limit l at a:

lim
x→a−
f (x)= l ∧ lim
x→a+
f (x)= l ⇒ lim f (x)= l
x→a

If function f has the left-hand limit f (a) and the right-hand limit f (a) at a, then f is continuous at a:

lim
x→a−
f (x)= f (a) ∧ lim
x→a+
f (x)= f (a) ⇒ cont(f, a)

If function f has the left-hand limit ll and the right-hand limit lr at a, then f is bounded in a neighborhood of a:

lim
x→a−
f (x)= ll ∧ lim
x→a+
f (x)= lr ⇒

(∃δ ∃M 0 < δ ∧0 < M ∧(∀x (|x1 −a| > 0∧|x1 −a| < δ1) ⇒ |f (x)| ≤ M ))
If function f (a + x) − f (a) has limit 0 at 0, then f is continuous at a: lim(f (a + x) − f (a)) = 0 ⇒ cont(f, a)
x→0
Unblock Meta-Variable Instantiation:
(Theorem 3.2.3.b in [1])
If sequence X = (xn) has the limit lx and sequence Y = (yn) has the

limit ly /= 0 and yn /= 0 for all n, then sequence X
= ( xn ) has the limit
n

lx ly
limseq X = lx ∧ limseq Y = ly ∧ ∀n yn /=0 ⇒ limseq X = lx
Y	ly
(Example 4.1.7.d in [1])
The function f (x)= 1 has the limit 1 at a, if a > 0:
x	a
a > 0 ⇒ lim 1 = 1
x→a x	a
(Example 4.1.7.e in [1])
lim x3−4 = 4
x→2 x2+1	5
(Exercise 4.1.10.a in [1]) lim  1  = −1
x→2 1−x


(Exercise 4.1.10.b in [1]) lim  x  = 1
x→1 1+x	2
(Exercise 4.1.10.c in [1]) lim x2 =0 
x→0 |x|
(Exercise 4.1.10.d in [1])
lim x2−x+1 = 1
	

x→1
x+1	2

(Theorem 4.2.4.b in [1])
If f has limit lƒ at a and g has limit lg /= 0 at a and g(x) /= 0 for all x,

then ƒ
has limit lf
g
at a:

lim f (x)= l
∧ lim g(x)= l
∧ ∀x g(x) /=0 ⇒ lim ƒ(x) = lf

x→a
ƒ	g
x→a
x→a g(x)	lg

(Theorem 5.2.1.b in [1])
If f is continuous at a and g is continuous at a and g(x) /= 0 for all x,

then ƒ
is continuous at a:

cont(f, a) ∧ cont(g, a) ∧ ∀x g(x) /=0 ⇒ cont( ƒ , a)
(Theorem 6.1.3.a in [1])
If f has the derivative f ' at a, then a ∗ f has the derivative a ∗ f ' at a: deriv(f, a)= f ' ⇒ deriv(a ∗ f, a)= a ∗ f '
(Theorem 6.1.3.b in [1])
If f has the derivative f ' at a and g has the derivative g' at a, then f + g
has the derivative f ' + g' at a:
deriv(f, a)= f ' ∧ deriv(g, a)= g' ⇒ deriv(f + g, a)= f ' + g'
(Theorem 6.1.3.c in [1])
If f has the derivative f ' at a and g has the derivative g' at a, then f ∗ g
has the derivative f ' ∗ g(a)+ f (a) ∗ g' at a:
deriv(f, a)= f ' ∧ deriv(g, a)= g' ⇒ deriv(f ∗ g, a)= f ' ∗ g(a)+ f (a) ∗ g'
(Cont-If-Deriv: Theorem 6.1.2 in [1])
If f has a derivative at a, then f is continuous at a: deriv(f, a)= f ' ⇒ cont(f, a)
If function f (x) has limit l as x → ∞, then ƒ(x) has limit 0 as x → ∞:

lim f (x)= l ⇒ lim
ƒ (x) =0 

x→∞
x→∞ x

Analyse Meta-Variable Dependencies:
(Exercise 4.1.12 in [1])
If f (x) has limit l at 0 and a > 0, then f (a ∗ x) has the limit l at 0: lim f (x)= l ∧ a > 0 ⇒ lim f (a ∗ x)= l
x→0	x→0
(Exercise 4.1.3 first part in [1])


If the function f (x) has the limit l at a, then the function f (x + a) has the limit l at 0:
lim f (x)= l ⇒ lim f (x + a)= l
x→a	x→0
If function f (a + x) − f (a) has limit 0 at 0, then f is continuous at a: lim(f (a + x) − f (a)) = 0 ⇒ cont(f, a)
x→0
