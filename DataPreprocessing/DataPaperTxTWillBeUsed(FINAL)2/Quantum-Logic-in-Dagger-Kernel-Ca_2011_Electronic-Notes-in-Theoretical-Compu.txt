

Electronic Notes in Theoretical Computer Science 270 (2) (2011) 79–103
www.elsevier.com/locate/entcs
Quantum Logic in Dagger Kernel Categories
Chris Heunen and Bart Jacobs
Institute for Computing and Information Sciences (iCIS) Radboud University Nijmegen, The Netherlands

Abstract
This paper investigates quantum logic from the perspective of categorical logic, and starts from minimal assumptions, namely the existence of involutions/daggers and kernels. The resulting structures turn out to
(1) encompass many examples of interest, such as categories of relations, partial injections, Hilbert spaces (also modulo phase), and Boolean algebras, and (2) have interesting categorical/logical properties, in terms of kernel fibrations, such as existence of pullbacks, factorisation, and orthomodularity. For instance, the Sasaki hook and and-then connectives are obtained, as adjoints, via the existential-pullback adjunction between fibres.
Keywords: Dagger kernel category, quantum logic, categorical logic

Introduction
Dagger categories D come equipped with a special functor † : Dop → D with X† = X on objects and f†† = f on morphisms. A simple example is the category Rel of sets and relations, where † is reversal of relations. A less trivial example is the category Hilb of Hilbert spaces and continuous linear transformations, where
† is induced by the inner product. The use of daggers, mostly with additional assumptions, dates back to [16,19]. Daggers are currently of interest in the context of quantum computation [1,23,6]. The dagger abstractly captures the reversal of a computation.
Mostly, dagger categories are used with fairly strong additional assumptions, like compact closure in [1]. Here we wish to follow a different approach and start from minimal assumptions. This paper is a first step to understand quantum logic, from the perspective of categorical logic (see e.g. [17,14,24,12]). It grew from the work of one of the authors [11]. Although that paper enjoys a satisfactory relation to traditional quantum logic [10], this one generalises it, by taking the notion of dagger category as starting point, and adding kernels, to be used as predicates. The interesting thing is that in the presence of a dagger functor † much else can be derived. As usual, it is quite subtle what precisely to take as primitive.

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.01.024

Upon this structure of “dagger kernel categories” the paper constructs pullbacks of kernels and factorisation (both similar to [8]). It thus turns out that the kernels form a “bifibration” (both a fibration and an opfibration, see [12]). This structure can be used as a basis for categorical logic, which captures substitution in predicates by reindexing (pullback) f−1 and existential quantification by op-reindexing ∃f , in such a way that ∃f E f−1. From time to time we use fibred terminology in this paper, but familiarity with this fibred setting is not essential. We find that the posets of kernels (fibres) are automatically orthomodular lattices [13], and that the Sasaki hook and and-then connectives appear naturally from the existential- pullback adjunction. Additionally, a notion of Booleanness is identified for these dagger kernel categories. It gives rise to a generic construction that generalises how the category of partial injections can be obtained from the category of relations.
Apart from this general theory, the paper brings several important examples within the same setting—of dagger kernel categories. Examples are the categories Rel and PInj of relations and partial injections. Additionally, the category Hilb is an example—and, interestingly—also the category PHilb of Hilbert spaces modulo phase. The latter category provides the framework in which physicists typically work [5]. It has much weaker categorical structure than Hilb. Finally, we present a construction to turn an arbitrary Boolean algebra into a dagger kernel category. We suspect that there is a similar construction for orthomodular lattices, but to our regret, we have not been able to produce it.
The authors are acutely aware of the fact that several of the example categories have much richer structure, involving for instance a tensor sum ⊕ and a tensor product ⊗ with associated scalars and traced monoidal structure. But investigation of this additional structure is postponed to follow-up work. There are interesting differences between our main examples: for instance, Rel and PInj are Boolean, but Hilb is not; in PInj and Hilb “zero-epis” are epis, but not in Rel; Rel and Hilb have biproducts, but PInj does not.
The paper is organised as follows. After introducing the notion of dagger kernel category in Section 2, the main examples are described in Section 3. Factorisation and (co)images occur in Sections 4 and 5. Finally, Section 6 introduces the Sasaki hook and and-then connectives via adjunctions, and investigates Booleanness.

Daggers and kernels
To start we shall work with the following notion.
Definition 2.1 A dagger kernel category consists of:
a dagger category D, with dagger † : Dop → D;
a zero object 0 in D;
kernels ker(f ) of arbitrary maps f in D, which are †-monos.
Definition 2.2 A dagger kernel category is called Boolean if m ∧ n = 0 implies
m† ◦ n = 0, for all kernels m, n.

The name Boolean will be explained in Theorem 6.2. We shall later rephrase the Booleanness condition as: kernels are disjoint if and only if they are orthogonal, see Lemma 2.3.
A category DCK is formed with these dagger categories with kernels as ob- jects and functors F between them that preserve the relevant structure: dagger (i.e. F (f†)= F (f )†), zero object (F (0) is again zero object), and kernels (F (k) is kernel of F (f ) if k is kernel of f ).
The dagger operation † satisfies X† = X on objects and f†† = f on morphisms. It comes with a number of definitions. A map f in D is called a †-mono(morphism) if f† ◦ f = id and a †-epi(morphism) if f ◦ f† = id. Hence f is a †-mono if and only if f† is a †-epi. A map f is a †-iso(morphism) when it is both a †-mono and a †-epi; in that case f−1 = f† and f is sometimes called unitary (in analogy with Hilbert spaces). An endomap p : X → X is called self-adjoint if p† = p.
The zero object 0 ∈ D is by definition both initial and final. Actually, in the presence of †, initiality implies finality, and vice-versa. For an arbitrary object X ∈ D, the unique map X → 0 is then a †-epi and the unique map 0 → X is a
†-mono. The “zero” map 0 = 0X,Y = (X → 0 → Y ) satisfies (0X,Y )† = 0Y,X . Notice that f ◦ 0=0=0 ◦ g. Usually there is no confusion between 0 as zero object and 0 as zero map. Two maps f : X → Z and g : Y → Z with common codomain are called orthogonal, written as f ⊥ g, if g† ◦ f = 0—or, equivalently, f† ◦ g = 0.
We recall that a kernel of a map f : X → Y is a universal map k : ker(f ) → X with f ◦ k = 0. Universality means that for an arbitrary g : Z → X with f ◦ g =0 there is a unique map gj : Z → ker(f ) with k ◦ gj = g. Kernels are automatically (ordinary) monos. Definition 2.1 requires that kernels are †-monos. 1 We shall write KSub(X) for the poset of (equivalence classes) of kernels with codomain X. Sometimes we are a bit sloppy and confuse the kernel object ker(f ) with the kernel map, for instance in defining the cokernel coker(f ) as ker(f †)†. This cokernel is a
†-epi. Finally, we define m⊥ = ker(m†), which we often write as m⊥ : M⊥ > X if
m : M > X. This notation is especially used when m is a mono. In diagrams we
typically write a kernel as z¸/a/nd a cokernel as 	 z. ¸
We start with some basic observations.
Lemma 2.3 In a dagger kernel category,

ker(X →0
Y )= (X →id
X) and ker(X →id
X) = (0 →0
X); they yield the top and

bottom elements 1, 0 ∈ KSub(X);
ker(ker(f )) = 0;
ker(coker(ker(f ))) = ker(f ), as subobjects;
m⊥⊥ = m if m is a kernel;
f factors through g⊥ iff f ⊥ g iff g ⊥ f iff g factors through f⊥; in particular
m ≤ n⊥ iff n ≤ m⊥, for monos m, n; hence (−)⊥ : KSub(X)−=→KSub(X)op;

1 This requirement involves a subtlety: kernels are closed under arbitrary isomorphisms but †-monos are only closed under †-isomorphisms. Hence we should be more careful in this requirement. What we really mean is that for every kernel there is a †-mono that is isomorphic to it. Hence we can always choose a kernel in such a way that it is a †-mono.

if m ≤ n, for monos m, n, say via m = n ◦ ϕ, then:
if m, n are †-monic, then so is ϕ;
if m is a kernel, then so is ϕ.
Booleanness amounts to m ∧ n =0 ⇔ m ⊥ n, i.e. disjointness is orthogonality, for kernels.
Proof. We skip the first two points because they are obvious and start with the third one. Consider for an arbitrary f : X → Y the diagram:


ker(f ) z¸	k
,/ X/¸¸¸
ƒ	/Y,/,

,,	,,,,,,,,
¸¸¸¸¸¸¸

k′	l′
,,,,, l
c ¸¸¸¸¸	ƒ′

J  , ,˛,,
ker(coker(ker(f )))
¸s z 
coker(ker(f ))

By construction f ◦ k = 0 and c ◦ k = 0. Hence there are f j and kj as indicated. Since f ◦ l = fj ◦ c ◦ l = fj ◦ 0 = 0 one gets lj. Hence the kernels l and k are equal, as subobjects.
For the fourth point we now notice that if m = ker(f ),
m⊥⊥ = ker(ker(m†)†) = ker(coker(ker(f ))) = ker(f )= m.
Next,
f factors through g⊥ ⇐⇒ g† ◦ f =0 
⇐⇒ f† ◦ g =0 ⇐⇒ g factors through f⊥.
If, in the sixth point, m = n ◦ ϕ and m, n are †-monos, then ϕ† ◦ ϕ = (n† ◦ m)† ◦
ϕ = m† ◦ n ◦ ϕ = m† ◦ m = id. And if m = ker(f ), then ϕ = ker(f ◦ n), since:
(1) f ◦ n ◦ ϕ = f ◦ m = 0, and (2) if f ◦ n ◦ g = 0, then there is a unique ψ with
m ◦ ψ = n ◦ g; but then ϕ ◦ ψ = g since n is monic.
Finally, Booleanness means that m ∧ n = 0 implies m† ◦ n = 0, which is equivalent to n† ◦ m = 0, which is m ⊥ n by definition. The reverse implication is easy: if m ◦ f = n ◦ g, then f = m† ◦ m ◦ f = m† ◦ n ◦ g =0 ◦ g = 0. Similarly, g = 0. Hence the zero object 0 is the pullback of m, n.	 
Certain constructions from the theory of Abelian Categories [8] also work in the current setting. This applies to the pullback construction in the next result, but also, to a certain extend, to the factorisation of Section 4.
Lemma 2.4 Pullbacks of kernels exist, and are kernels again. Explicitly, given a kernel n and map f one obtains a pullback:
ƒ′	//
M_	N_


ƒ−1(n)
r_z
J 
rz
n
ƒ	/J/ 
as	f
—1(n) = ker(coker(n) ◦ f ).

X	Y

In case this f is a †-epi, then so is fj.
By duality there are of course similar results about pushouts of cokernels.
Proof. For convenience write m = f—1(n) = ker(coker(n) ◦ f ). By construction, coker(n) ◦ f ◦ m = 0, so that f ◦ m factors through ker(coker(n)) = n, say via fj : M → N with n ◦ fj = f ◦ m, as in the diagram. This yields a pullback: if a : Z → X and b : Z → N satisfy f ◦ a = n ◦ b, then coker(n) ◦ f ◦ a = coker(n) ◦ n ◦ fj =0 ◦ fj = 0, so that there is a unique map c : Z → M with m ◦ c = a. Then fj ◦ c = b because n is monic.
In case f is a †-epi we have f ◦ f† = id. Hence there are two adjacent pullbacks:


ƒ′′	//
ƒ′	//

N_	M_	N_

r_z
n
J 
r_z
m=ƒ−1(n)
ƒ†	/J/ 
rz
n
ƒ	/J/ 

Y	X	Y
Then f j ◦ f jj = id because n is monic. Further, f jj = m† ◦ m ◦ f jj = m† ◦ f† ◦ n =
f j† ◦ n† ◦ n = fj†. Hence f j is †-epi.	 
Corollary 2.5 Given these pullbacks of kernels,
the mapping X '→ KSub(X) yields an indexed category Dop → PoSets and forms a setting in which one can develop categorical logic for dagger categories;
the following diagram is a pullback,
ker_(f )	/0_ /

r_z
J 
X
rz
ƒ	/J/ 

showing that, logically speaking, falsum—i.e. the bottom element 0 ∈ KSub(Y )— is in general not preserved under substitution. Also, negation (−)⊥ does not commute with substitution, because 1= 0⊥ and f—1(1) = 1.	 
One may also describe the indexed category KSub from (i) as a split fibration [12]
  KSub(D)  where the “total” category KSub(D) has (equivalence classes of) kernels
D	m	n
M > X as objects, and morphisms (M > X) −→ (N > Y ) are maps f : X → Y
in D with:
M_ _ _ _ _ _ _/N_/

m rz
J 
X
rn z
ƒ	/J/ 
i.e. with	m ≤ f—1(n).

We shall sometimes refer to this fibration as the “kernel fibration”. Every functor
F : D → E in DCK induces a map of fibrations:
KSub(D)	/K/Sub(E)


J	F	/J/ 
(1)

because F preserves kernels and pullbacks of kernels—the latter since pullbacks can be formulated in terms of constructions that are preserved by F , see Lemma 2.4. As we shall see, in some situations, this diagram (1) is a pullback—also called a change-of-base situation in this context, see [12]. It means that the map KSub(X) → KSub(FX) is an isomorphism.
Being able to take pullbacks of kernels has some important consequences.
Lemma 2.6 Kernels are closed under composition—and hence cokernels are, too.
Proof. We shall prove the result for cokernels, because it uses pullback results as we have just seen. So assume we have (composable) cokernels e, d; we wish to show e ◦ d = coker(ker(e ◦ d)). We first notice, using Lemma 2.4,
ker(e ◦ d) = ker(coker(ker(e)) ◦ d)= d—1(ker(e)),


yielding a pullback:


 A_ ¸ 
ϕ 


d′	/B/ rz

m=ker(e○d)	ker(e)

K z¸ker(d)	/J/ 
 zJ¸ 
 Ez¸

We intend to prove e ◦ d = coker(m). Clearly, e ◦ d ◦ m = e ◦ ker(e) ◦ dj = 0 ◦ dj = 0. And if f : X → Y satisfies f ◦ m = 0, then f ◦ ker(d) = f ◦ m ◦ ϕ = 0, so because d = coker(ker(d)) there is fj : D → Y with fj ◦ d = f . But then: f j ◦ ker(e) ◦ dj = fj ◦ d ◦ m = f ◦ m = 0. Then fj ◦ ker(e) = 0, because dj is
†-epi because d is, see Lemma 2.4. This finally yields f jj : E → Y with f jj ◦ e = fj. Hence f jj ◦ e ◦ d = f .	 
As a result, the logic of kernels has intersections, preserved by substitution. More precisely, the indexed category KSub(−) from Corollary 2.5 is actually a functor KSub: Dop → MSL to the category MSL of meet semi-lattices. Each poset KSub(X) also has disjunctions, by m ∨ n = (m⊥ ∧ n⊥)⊥, but they are not preserved under substitution/pullback f—1. But we do have m ∨ m⊥ = (m⊥ ∧ m⊥⊥)⊥ = (m⊥ ∧ m)⊥ = 0⊥ = 1.
Proposition 2.7 Orthomodularity holds: for kernels m ≤ n, say via ϕ with n ◦
ϕ = m, one has pullbacks:

 z¸ϕ	//¸, ϕ⊥	¸ c
P
_	rz	_
n

M z¸m	/J/¸ ,m⊥
J 
¸Mc⊥

This means that m ∨ (m⊥ ∧ n)= n.
Proof. The square on the left is obviously a pullback. For the one on the right we

use a simple calculation, following Lemma 2.4:

n—1(m⊥) = ker(coker(m⊥) ◦ n)
= ker(coker(ker(m†)) ◦ n)
= ker(m† ◦ n)	since m† is a cokernel
(∗)	†
= ker(ϕ )
= ϕ⊥,

where the marked equation holds because n ◦ ϕ = m, so that ϕ = n† ◦ n ◦ ϕ =
n† ◦ m and thus ϕ† = m† ◦ n. Then:


m ∨ (m⊥ ∧ n) = (n ◦ ϕ) ∨ (n ◦
(∗)
ϕ ) = n
◦ (ϕ ∨ ϕ⊥) = n ◦ id = n.


The marked equation holds because n ◦ (−) preserves joins, since it is a left adjoint:
n ◦ k ≤ m iff k ≤ n—1(m), for kernels k, m.	 
The following notion does not seem to have an established terminology. Hence we introduce our own.
Definition 2.8 In a category with a zero object, a map m is called a zero-mono if
m ◦ f = 0 implies f = 0, for each map f . Dually, e is zero-epi if f ◦ e = 0 implies

f = 0. In diagrams we write	/○ //f/or zero-monos and  ○
/f//or zero-epis.

Clearly, a mono is zero-mono, since m ◦ f = 0 = m ◦ 0 implies f = 0 if m is monic. The following points are worth making explicit.
Lemma 2.9 In a dagger kernel category,
m is a zero-mono iff ker(m)=0 and e is a zero-epi iff coker(e)= 0;
ker(m ◦ f ) = ker(f ) if m is a zero-mono, and similarly, coker(f ◦ e) = coker(f ) if e is a zero-epi.
a kernel which is zero-epic is an isomorphism.	 
We shall mostly be interested in zero-epis (instead of zero-monos), because they arise in the factorisation of Section 4. In the presence of dagger equalisers, zero-epis are ordinary epis. This applies to Hilb and PInj. This fact is not really used, but is included because it gives a better understanding of the situation. A dagger equaliser category is a dagger category that has equalisers which are dagger monic.
Lemma 2.10 In a dagger equaliser category D where every dagger mono is a ker- nel, zero-epis in D are ordinary epis.
Proof. Assume a zero-epi e : E → X with two maps f, g : X → Y satisfying f ◦
e = g ◦ e. We need to prove f = g. Let m : M > X be the equaliser of f, g, with

h = coker(m), as in:


	e	//

ƒ	//

E	○	 X¸
/Y /

ϕ	 
     m


g
_h=coker(m)

J, _,
M
Zrz

This e factors through the equaliser m, as indicated, since f ◦ e = g ◦ e. Then: h ◦ e = h ◦ m ◦ ϕ =0 ◦ ϕ = 0. Hence h = 0 because e is zero-epi. But m, being a dagger mono, is a dagger kernel. Hence m = ker(coker(m)) = ker(h)= ker(0) = id, so that f = g.	 

Main examples
This section will describe our four main examples, namely Rel, PInj, Hilb and PHilb, and additionally a general construction to turn a Boolean algebra into a dagger kernel category.
The category Rel of sets and relations
Sets and binary relations R ⊆ X ×Y between them can be organised in the familiar category Rel, using relational composition. Alternatively, such a relation may be described as a Kleisli map X → P(Y ) for the powerset monad P; in line with this representation we sometimes write R(x) = {y ∈ Y | R(x, y)}. A third way is to represent such a morphism in Rel as (an equivalence class of) a pair of maps (X →r1 R →r2 Y ) whose tuple ⟨r1, r2⟩ : R → X × Y of legs is injective.
There is a simple dagger operation on Rel by reversal of relations: R†(y, x) = R(x, y). A map R : X → Y is a †-mono in Rel if R† ◦ R = id, which amounts to the equivalence:
∃y∈Y . R(x, y) ∧ R(xj, y)	⇐⇒	x = xj,
for all x, xj ∈ X. It can be split into two statements:
∀x∈X. ∃y∈Y . R(x, y)	and	∀x,x′∈X. ∀y∈Y . R(x, y) ∧ R(x , y) ⇒ x = x .
Hence such a †-mono R is given by a span of the form:
r1 R ¸z¸r2	(2)

with surjection as first leg and injection as second leg. A †-epi has the same shape, but with legs exchanged.
The empty set 0 is a zero object in Rel, and the resulting zero map 0 : X → Y
is the empty relation ∅⊆ X × Y .
The category Rel also has kernels. For an arbitrary map R : X → Y one takes ker(R) = {x ∈ X | ¬∃y∈Y . R(x, y)} with map k : ker(R) → X in Rel given by k(x, xj) ⇔ x = xj. Clearly, R ◦ k = 0. And if S : Z → X satisfies R ◦ S = 0, then

¬∃x∈X. R(x, y) ∧ S(z, x), for all z ∈ Z and y ∈ Y . This means that S(z, x) implies there is no y with R(x, y). Hence S factors through the kernel k. Kernels are thus of the following form:
  K ¸zz	with	K = {x ∈ X | R(x)= ∅}.

Kernels are thus essentially given by subsets: KSub(X) = P(X). Indeed, Rel is Boolean, in the sense of Definition 2.1. A cokernel has the reversed shape.
Finally, a relation R is zero-mono if its kernel is 0, see Lemma 2.9. This means that R(x) /= ∅, for each x ∈ X, so that R’s left leg is a surjection.
Proposition 3.1 In Rel there are proper inclusions:
kernel Ç †-mono Ç mono Ç zero-mono.

Subsets of a set X correspond to kernels in Rel with codomain X.
There is of course a dual version of this result, for cokernels and epis.
Proof. We still need to produce (1) a zero-mono which is not a mono, and (2) a mono which is not a †-mono. As to (1), consider R ⊆ {0, 1} × {a, b} given by R = {(0, a), (1, a)}. Its first leg is surjective, so R is a zero-mono. But it is not a mono: there are two different relations {(∗, 0)}, {(∗, 1)} ⊆ {∗} × {0, 1} with R ◦
{(∗, 0)} = {(∗, a)} = R ◦ {(∗, 1)}.
As to (2), consider the relation R ⊆ {0, 1}× {a, b, c} given by R = {(0, a), (0, b), (1, b), (1, c)}. Clearly, the first leg of R is a surjection, and the second one is neither an injection nor a surjection. We check that R is monic. Suppose S, T : X → {0, 1} satisfy R ◦ S = R ◦ T . If S(x, 0), then (R ◦ S)(x, a) = (R ◦ T )(x, a), so that T (x, 0). Similarly, S(x, 1) ⇒ T (x, 1).	 
We add that the pullback R—1(n) of a kernel n = (N = N > Y ) along a relation R ⊆ X × Y , as described in Lemma 2.4 is the subset of X given by the modal formula 2R(n)(x) = R—1(n)(x) ⇔ (∀y. R(x, y) ⇒ N (y)). As is well-known in modal logic 2R preserves conjunctions, but no disjunctions. Interestingly, the familiar “graph” functor G : Sets → Rel yields a map of fibrations:


Sub(Sets)

J 
Sets
/K/Sub(Rel)

G	J 
Rel

(3)

which forms actually a pullback (or a “change-of-base” situation, see [12]). This means that the familiar logic of sets can be obtained from this kernel logic on relations. In this diagram we use that inverse image is preserved: for a function

f : X → Y and predicate N ⊆ Y one has:
G(f )—1(N ) = 2G(ƒ )(N ) = {x ∈ X | ∀y. G(f )(x, y) ⇒ N (y)}
= {x ∈ X | ∀y.f (x)= y ⇒ N (y)}
= {x ∈ X | N (f (x))}
= f—1(N ).

The category PInj of sets and partial injections
There is a subcategory PInj of Rel also with sets as objects but with “partial injections” as morphisms. These are special relations F ⊆ X×Y satisfying F (x, y) ∧ F (x, yj) ⇒ y = yj and F (x, y) ∧ F (xj, y) ⇒ x = xj. We shall therefore often write morphisms f : X → Y in PInj as spans with the notational convention
ƒ	ƒ1 ,Fs¸z¸ƒ2 



ƒ1
where spans (X < F
ƒ2
> Y ) and (X
g1	g2
< G > Y ) are equivalent if there is an

isomorphism ϕ : F → G with gi ◦ ϕ = fi, for i = 1, 2—like for relations.

ƒ
Composition of X → Y
g
→ Z can be described as relational composition, but

also via pullbacks of spans. The identity map X → X is given by the span of
identities X < X > X. The involution is inherited from Rel and can be described
ƒ1	ƒ2	 †	ƒ2	ƒ1
It is not hard to see that f =  X  ƒ1  F  ƒ2  Y  is a †-mono—i.e. satisfies
f† ◦ f = id—if and only if its first leg f1 : F > X is an isomorphism.	For convenience we therefore identify a mono/injection m : M > X in Sets with the

corresponding †
id	m

By duality: f is †-epi iff f† is †-mono iff the second leg f2 of f is an isomorphism. Further, f is a †-iso iff f is both †-mono and †-epi iff both legs f1 and f2 of f are isomorphisms.
Like in Rel, the empty set is a zero object, with corresponding zero map given by the empty relation, and 0† = 0.
ƒ1	ƒ2
PInj we shall use the ad hoc notation ¬1F > X for the negation of the first leg
f1 : F > X, as subobject/subset. It yields a map:


ker(f )= 
¬ F
sss	z¸¸ 

¬1F	z 
It satisfies f ◦ ker(f ) = 0. It is a †-mono by construction. Notice that kernels are the same as †-monos, and are also the same as zero-monos. They all correspond to subsets, so that KSub(X)= P(X) and PInj is Boolean, like Rel.

The next result summarises what we have seen so far and shows that PInj is very different from Rel (see Proposition 3.1).
Proposition 3.2 In PInj there are proper identities:
kernel = †-mono = mono = zero-mono.
These all correspond to subsets.
The category Hilb of Hilbert spaces
Our third example is the category Hilb of (complex) Hilbert spaces and continuous linear maps. Recall that a Hilbert space is a vector space X equipped with an inner product, i.e. a function ⟨− | −⟩ : X×X → C that is linear in the first and anti-linear in the second variable, satisfies ⟨x | x⟩ ≥ 0 with equality if and only if x = 0, and
⟨x | y⟩ = ⟨y | x⟩. Moreover, a Hilbert space must be complete in the metric induced by the inner product by d(x, y)=  ⟨x − y | x − y⟩.
The Riesz representation theorem provides this category with a dagger functor. Explicitly, for f : X → Y a given morphism, f† : Y → X is the unique morphism satisfying
⟨f (x) | y⟩Y = ⟨x | f†(y)⟩X
for all x ∈ X and y ∈ Y . The zero object is inherited from the category of (com- plex) vector spaces: it is the zero-dimensional Hilbert space {0}, with unique inner product ⟨0 | 0⟩ = 0.
In the category Hilb, †-mono’s are usually called isometries, because they pre- serve the metric: f† ◦ f = id if and only if


d(fx, fy)= ⟨f (x − y) | f (x − y)⟩ 2 = ⟨x − y | (f†
1
f )(x − y)⟩ 2 = d(x, y).

Kernels are inherited from the category of vector spaces. For f : X → Y , we can choose ker(f ) to be (the inclusion of) {x ∈ X | f (x)= 0}, as this is complete with respect to the restricted inner product of X. Hence kernels correspond to (inclusions of) closed subspaces. Being inclusions, kernels are obviously †-monos. Hence Hilb is indeed an example of a dagger kernel category. However, Hilb is not Boolean. The following proposition shows that it is indeed different, categorically, from Rel and PInj.
Proposition 3.3 In Hilb one has:
kernel = †-mono Ç mono = zero-mono.

Proof. For the left equality, notice that both kernels and isometries correspond to closed subspaces. It is not hard to show that the monos in Hilb are precisely the injective continuous linear functions, establishing the middle proper inclusion. Finally, Hilb has equalisers by eq(f, g)= ker(g − f ), which takes care of the right equality.	 

As is well-known, the l2 construction forms a functor l2 : PInj → Hilb (but not a functor Sets → Hilb), see e.g. [2,9]. Since it preserves daggers, zero object and kernels it isa map in the category DCK, and thus yields a map of kernel fibrations like in (1). It does not form a pullback (change-of-base) between these fibrations, since the map KSubPInj(X)= P(X) → KSubHilb(l2(X)) is not an isomorphism.
The category PHilb: Hilbert spaces modulo phase
The category PHilb of projective Hilbert spaces has the same objects as Hilb, but its homsets are quotiented by the action of the circle group U (1) = {z ∈ C | |z| = 1}. That is, continuous linear transformations f, g : X → Y are identified when x = z· y for some phase z ∈ U (1).
Equivalently, we could write PX = X1/U (1) for an object of PHilb, where
X ∈ Hilb and X1 = {x ∈ X |  x  = 1}. Two vectors x, y ∈ X1 are therefore identified when x = z · y for some z ∈ U (1). Continuous linear transformations f, g : X → Y then descend to the same function PX → PY precisely when they are equivalent under the action of U (1). This gives a full functor P : Hilb → PHilb.
The dagger of Hilb descends to PHilb, because if f = z · g for some z ∈ U (1), then
⟨f (x) | y⟩ = z¯ · ⟨g(x) | y⟩ = z¯ · ⟨x | g†(y)⟩ = ⟨x | z¯ · g†(y)⟩,
whence also f† = z¯ · g†, making the dagger well-defined.
Also dagger kernels in Hilb descend to PHilb. More precisely, the kernel ker(f ) = {x ∈ X | f (x) = 0} of a morphism f : X → Y is well-defined, for if f = z · f j for some z ∈ U (1), then
ker(f )= {x ∈ X | z · f j(x)= 0} = {x ∈ X | fj(x)= 0} = ker(f j).
Proposition 3.4 In PHilb one has:
kernel = †-mono Ç mono = zero-mono.
Proof. It remains to be shown that every zero-mono is a mono. So let m : Y → Z be a zero-mono, and f, g : X → Y arbitrary morphisms in PHilb. More precisely, let m, f and g be morphisms in Hilb representing the equivalence classes [m], [f ] and [g] that are morphisms in PHilb. Suppose that [m ◦ f ] = [m ◦ g]. Then m ◦ f ∼ m ◦ g, say m ◦ f = z · (m ◦ g) for z ∈ U (1). So m ◦ (f − z · g) = 0, and f − z · g =0 since m is zero-mono. Then f = z · g and hence f ∼ g, i.e. [f ]= [g]. Thus m is mono.	 
The full functor P : Hilb → PHilb preserves daggers, the zero object and kernels. Hence it is a map in the category DCK. In fact it yields a pullback (change-of-base) between the corresponding kernel fibrations.


KSub(Hilb)
_
J 
Hilb
/K/Sub(PHilb)

J 
PHilb

(4)

From Boolean algebras to dagger kernel categories
The previous four examples were concrete categories. At the end we add a generic construction, which turns an arbitrary Boolean algebra into a (Boolean) dagger kernel category.
To start, let B with (1, ∧) be a meet semi-lattice. We can turn it into a category, for which we use the notation B. The objects of B are elements x ∈ B, and its morphisms x → y are elements f ∈ B with f ≤ x, y, i.e. f ≤ x ∧ y. There is an identity x : x → x, and composition of f : x → y and g : y → z is simply f ∧ g : x → z. This B is a dagger category with f† = f . A map f : x → y is a
†-mono if f† ◦ f = f ∧ f = x. Hence a †-mono is of the form x : x → y where
x ≤ y.
It is not hard to see that the construction B '→ B is functorial: a morphism h : B → C of meet semi-lattices yields a functor h : B → C by x '→ h(x). It clearly preserves †.


Proposition 3.5 If B is a Boolean algebra, then B category. This yields a functor BA → DCK.
is a Boolean dagger kernel

Proof. The bottom element 0 ∈ B yields a zero object 0 ∈ B, and also a zero map 0: x → y. For an arbitrary map f : x → y there isa kernel ker(f )= ¬f ∧ x, which is a †-mono ker(f ): ker(f ) → x in B. Clearly, f ◦ ker(f )= f ∧ ¬f ∧ x =0 ∧ x = 0. If also g : z → x satisfies f ◦ g = 0, then g ≤ x, z and f ∧ g = 0. The latter yields g ≤ ¬f and thus g ≤ ¬f ∧ x = ker(f ). Hence g forms the required mediating map g : z → ker(f ) with ker(f ) ◦ g = g.
Notice that each †-mono m : m → x, where m ≤ x, is a kernel, namely of its cokernel ¬m ∧ x : x → (¬m ∧ x). For two kernels m : m → x and n : n → x, where m, n ≤ x, one has m ≤ n as kernels iff m ≤ n in B. Thus KSub(x)= ↓ x, which is again a Boolean algebra (with negation ¬xm = ¬m ∧ x). The intersection m ∧ n as subobjects is the meet m ∧ n in B. This allows us to show that B is Boolean: if m ∧ n = 0, them m† ◦ n = m ◦ n = m ∧ n = 0.	 
It remains an open question whether a similar construction can be performed for orthomodular lattices (see [13]), instead of Boolean algebras. The straightforward extension of the above construction does not work: in order to get kernels one needs to use the and-then connective (&, see Proposition 6.1) for composition; but & is neither associative nor commutative, unless the lattice is Boolean [15].

Factorisation
In this section we assume that D is an arbitrary dagger kernel category. We will show that each map in D can be factored as a zero-epi followed by a kernel, in an essentially unique way. This factorisation leads to existential quantifiers ∃, as usual. The “image” Im(f ) of f : X → Y is defined as Im(f ) = ker(coker(f )) with kernel map (and hence †-mono) iƒ : Im(f ) z¸/Y /obtained as follows. First take

the kernel:

† zk¸//ƒ† //

ker(f )	Y	X
and define iƒ as the kernel of k† as in:
Im(f )= ker(k†) zif¸/Y /k† kzer¸(f †)
,, 

ef 
(5)

    ƒ
X
The map eƒ : X → Im(f ) is obtained from the universal property of kernels, since k† ◦ f = (f† ◦ k)† = 0† = 0. Since iƒ is a †-mono, this eƒ is determined as eƒ = id ◦ eƒ = (iƒ )† ◦ iƒ ◦ eƒ = (iƒ )† ◦ f .
The image of a map f is therefore defined as kernel ker(coker(f )). Conversely, every kernel m = ker(f ) arises as an image, since ker(coker(m)) = m by Lemma 2.3.
The maps that arise as eƒ in (5) can be characterised.
Proposition 4.1 The maps in D that arise of the form eƒ , as in diagram (5), are precisely the zero-epis.
Proof. We first show that eƒ is a zero-epi. Assume therefor a map h : ker(k†) → Z
satisfying h ◦ eƒ = 0. Recall eƒ = (iƒ )† ◦ f , so that:
f† ◦ (iƒ ◦ h†)= (h ◦ (iƒ )† ◦ f )† = (h ◦ eƒ )† = 0† = 0.
This means that iƒ ◦ h† factors through the kernel of f†, say via a : Z → ker(f †) with k ◦ a = iƒ ◦ h†. Since k is a †-mono we now get:
a = k† ◦ k ◦ a = k† ◦ iƒ ◦ h† =0 ◦ h† = 0.
But then iƒ ◦ h† = k ◦ a = k ◦ 0=0= iƒ ◦ 0, so that h† = 0, because iƒ is mono, and h = 0, as required.
Conversely, assume g : X → Y is a zero-epi, so that coker(g) = 0 by Lemma 2.9. Trivially, ig = ker(coker(g)) = ker(X → 0) = idX , so that eg = g.	 
The factorisation f = iƒ ◦ eƒ from (5) describes each map as a zero-epi followed by a kernel. In fact, these zero-epis and kernels also satisfy what is usually called the “diagonal fill-in” property.
Lemma 4.2 In any commuting square of shape


· ○/· /

there is a (unique) diagonal
·	○ /· /
c c

J	J	c

· z¸/· /
·J z j¸c/·J/  

making both triangles commute.
As a result, the factorisation (5) is unique up to isomorphism. Indeed, kernels and zero-epis form a factorisation system (see [3]).

Proof. Assume the zero-epi e : E → Y and kernel m = ker(h): M > X satisfy
m ◦ f = g ◦ e, as below,
E ○e/Y /
ƒ	g
J z¸/J/  //
M  m X h  Z
Then: h ◦ g ◦ e = h ◦ m ◦ f =0 ◦ f = 0 and h ◦ g =0 because e is zero-epi. This yields the required diagonal d : Y → M with m ◦ d = g because m is the kernel of
h. Using that m is monic we get d ◦ e = f .	 
Factorisation standardly gives a left adjoint to inverse image (pullback), corre- sponding to existential quantification in logic. In this self-dual situation there are alternative descriptions.
Proposition 4.3 For f : X → Y , the pullback functor f—1 : KSub(Y ) → KSub(X)
from Lemma 2.4 has a left adjoint ∃ƒ given as image:
 M  zm¸/X/    '−→   Im(f  ◦ m)  ∃zf (¸m)=if ◦m /Y / 

Alternatively, ∃ƒ (m)=  (f†)—1(m⊥)   .
⊥

Proof. It is standard/straightforward that m ≤ f—1(n) iff there is a ϕ : M → N
with n ◦ ϕ = f ◦ m iff ∃ƒ (m) ≤ n. For the alternative description:
(f†)—1(m⊥) ⊥ ≤ n ⇐⇒ n⊥ ≤ (f†)—1(m⊥)
⇐⇒ there is a ψ : N⊥ → M⊥ with m⊥ ◦ ψ = f† ◦ n⊥
(∗)
⇐⇒ there is a ϕ : M → N with n ◦ ψ = f ◦ m
⇐⇒ m ≤ f—1(n).

For the direction (⇒) of the marked equivalence, recall that n = ker(coker(n)), so we show: coker(n) ◦ f ◦ m = (f† ◦ n⊥)† ◦ m = (m⊥ ◦ ψ)† ◦ m = ψ† ◦ coker(m) ◦ m = ψ† ◦ 0 = 0. The reverse direction works similarly: given ϕ one gets: m† ◦ f† ◦ n⊥ = (f ◦ m)† ◦ n⊥ = (n ◦ ϕ)† ◦ n⊥ = ϕ† ◦ n† ◦ n⊥ = ϕ† ◦ 0= 0.
 
This adjunction ∃ƒ E f—1 makes the kernel fibration	 an opfibration,
KSub(D)


and thus a bifibration, see [12].
Recall the Beck-Chevalley condition: if the left square below is a pullback, then the right one must commute.


  q	//
KSub(P )
q−1
KSub(Y )

P _	Y
g	⇒
¸, 

∃p	∃g

(BC)

J	/J/ 
J  ¸, 	J 

X	ƒ	Z
KSub(X)

ƒ−1
KSub(Z)

This condition ensures that ∃ commutes with substitution. Beck-Chevalley holds for the pullbacks from Lemma 2.4 that are known to exist. In the notation from Lemma 2.4, for kernels k : K > Y and g : Y > Z,
f—1(∃g(k)) = f—1(g ◦ k) because both g, k are kernels
= p—1(k) ◦ q  by composition of pullbacks
= ∃p(q—1(k)).

In Hilb all pullbacks exist and Beck-Chevalley holds for all of them by [4, II, Proposition 1.7.6] using Hilb’s biproducts and equalisers.
The final result in this section brings more clarity; it underlies the relations between the various maps in the propositions in the previous section.
Lemma 4.4 If zero-epis are (ordinary) epis, then †-monos are kernels.
Recall that Lemma 2.10 tells that zero-epis are epis in the presence of equalisers.
Proof. Suppose m : M > X is a †-mono, with factorisation m = i ◦ e as in (5), where i is a kernel and a †-mono, and e is a zero-epi and hence an epi by assumption. We are done if we can show that e is an isomorphism. Since m = i ◦ e and i is
†-monic we get i† ◦ m = i† ◦ i ◦ e = e. Hence e† ◦ e = (i† ◦ m)† ◦ e = m† ◦ i ◦ e = m† ◦ m = id because m is †-mono. But then also e ◦ e† = id because e is epi and e ◦ e† ◦ e = e.	 
Example 4.5 In the category Rel the image of a morphism (X →r1 R →r2 Y ) is
the relation iR = (Y j →= Y j > Y ) where Y j = {y ∈ Y | ∃x. R(x, y)} is the image

of the second leg r2
in Sets. The associated zero-epi is eR
= (X
→r1
r2
R → Y
j).

Existential quantification ∃R(M ) from Proposition 4.3 corresponds to the modal diamond operator (for the reversed relation R†):
∃R(M )= {y ∈ Y | ∃x∈M . R(x, y)} = ♦R† (M )= ¬2R† (¬M ).

It is worth mentioning that the “graph” map of fibrations (3) between sets and relations is also a map of opfibrations: for a function f : X → Y and a predicate M ⊆ X one has:
∃G(ƒ)(M ) = {y | ∃x. G(f )(x, y) ∧ M (x)}
= {y | ∃x.f (x)= y ∧ M (x)}
= {f (x) | M (x)}
= ∃ƒ (M ),
where ∃ƒ in the last line is the left adjoint to pullback f—1 in the category Sets.

ƒ1	ƒ2
id	ƒ2

In PInj the image of a map f = (X < F > Y ) is given as iƒ = (F < F > Y ).
ƒ1	id
The associated map eƒ is (X < F > F ), so that indeed f = iƒ ◦ eƒ . Notice that
this eƒ is a †-epi in PInj.

In Hilb, the image of a map ƒ : X → Y is (the inclusion of) the closure of the set-theoretic image {y ∈ Y | ∃x∈X.y = ƒ (x)}. This descends to PHilb: the image of a morphism is the equivalence class represented by the inclusion of the closure of the set-theoretic image of a representative.
The functor l2 : PInj → Hilb is a map of opfibrations: for a partial injection
ƒ1	ƒ2

ƒ = (X < F > Y ) and a kernel m : M > X in PInj one has:
∃l2(ƒ )(l2(m)) = ImHilb(l2(ƒ ◦ m))
= ImHilb(λϕ : l2(M ).λy : Y.
x∈(ƒ○m)−1(y)

∼= {ϕ ∈ l2(X) | supp(ϕ) ⊆ F ∩ M}
= {ϕ ∈ l2(X) | supp(ϕ) ⊆ F ∩ M}
∼= l2(ƒ2 ◦ ƒ—1(m))
= l2(∃ƒ (m)).



ϕ(x)))

Also the full functor P : Hilb → PHilb is a map of opfibrations: for ƒ : X → Y
and a kernel m : M > X in Hilb one has:
∃Pƒ (P m)= ImPHilb(P (ƒ ◦ m))

= {ƒ (x) | x ∈ M}
= P ({ƒ (x) | x ∈ M})
= P (ImHilb(ƒ ◦ m))
= P (∃ƒ (m)).


is the composite x−→ƒ −→y. In particular, for m ≤ x, considered as kernel m : m →
x one has ∃ƒ (m)= (m ∧ ƒ : (m ∧ ƒ ) → x).
Example 4.6 In [18] the domain Dom(ƒ ) of a map ƒ : X → Y is the negation of its kernel, so Dom(ƒ ) = ker(ƒ )⊥, and hence a kernel itself. It can be described as an image, namely of ƒ†, since:
Dom(ƒ )= ker(ƒ )⊥ = ker(ker(ƒ )†) = ker(coker(ƒ †)) = iƒ† .
It is shown in [18] that the composition ƒ ◦ Dom(ƒ ) is zero-monic—or “total”, as it is called there. This also holds in the present setting, since:
ƒ ◦ Dom(ƒ )= ƒ†† ◦ iƒ† = (iƒ† ◦ eƒ† )† ◦ iƒ† = (eƒ† )† ◦ (iƒ† )† ◦ iƒ† = (eƒ† )†.
This eƒ† is zero-epic, by Proposition 4.1, so that (eƒ† )† is indeed zero-monic.
There is one further property that is worth making explicit, if only in examples.
In the kernel fibration over Rel one finds the following correspondences.
KSub(X) ∼= P(X) ∼= Sets(X, 2) ∼= Sets(X, P(1)) ∼= Rel(X, 1).

This suggests that one has “kernel classifiers”, comparable to “subobject classifiers” in a topos—or more abstractly, “generic objects”, see [12]. But the naturality that one has in toposes via pullback functors ƒ—1 exists here via their left adjoints ∃ƒ . Indeed, there are natural “characteristic” isomorphisms:
KSub(X)= P(X) 	char	/R/el(1,X)
=
(M ⊆ X) 	/{(/∗, x) | x ∈ M}.
Then, for S : X → Y in Rel,
S ◦ char(M ) = {(∗, y) | ∃x. char(M )(∗, x) ∧ S(x, y)}
= {(∗, y) | ∃x.M (x) ∧ S(x, y)}
= {(∗, y) | ∃S(M )(y)}
= char(∃S(M )).
Hence one could say that Rel has a kernel “op-classifier”.
The same thing happens in the dagger categories B from Subsection 3.5. There one has, for x ∈ B,
	char	//
KSub(x)= ↓ x	∼=	B^(1, x)
(m ≤ x) 	/(m/: 1 → x) As before, ƒ ◦ char(m)= ƒ ∧ m = ∃ƒ (m) = char(∃ƒ (m)).
Images and coimages
We continue to work in an arbitrary dagger kernel category D. In the previous section we have seen how each map ƒ : X → Y in D can be factored as ƒ = iƒ ◦ eƒ where the image iƒ = ker(coker(ƒ )) : Im(ƒ ) > Y is a kernel and eƒ is a zero- epi. We can apply this same factorisation to the dual ƒ†. The dual of its image, (iƒ† )† = coker(ker(ƒ )) : X → Im(ƒ†), is commonly called the coimage of ƒ . It is a cokernel and †-epi by construction. Thus we have:


	ƒ	//
ƒ†	//

X ¸¸  e
¸¸z˛
Im(ƒ )
i	,, Y ¸
, ,˛,
Y ¸¸¸¸ef†
z˛
Im(ƒ†)
i †  ,, X¸
, ˛, ,

By combining these factorisations we get two mediating maps m by diagonal fill-in, as in:

	ƒ	//
ƒ†	//

X,¸,¸¸¸¸e
Y
if	eee
Y ,¸¸
,, ¸ f†
X
if†... eee

,, ○¸¸¸¸z  , ._..,eee
,, ○¸¸¸z 
, ._..,eee

,,,
Im(ƒ )
ee
,,,,
Im(ƒ†)
ee

(i † )†
,,,	,,eee (ef† )
†
(if )† ,,	,,eee (ef )†

, mf ee
 t e
Im(ƒ†)
,, mf† ee
 t e
Im(ƒ )

We claim that (mƒ )† = mƒ† . This follows easily from the fact that (iƒ† )† is epi: (mƒ† )† ◦ (iƒ† )† = (iƒ† ◦ mƒ† )† = (eƒ )†† = eƒ = mƒ ◦ (iƒ† )†.
Moreover, mƒ is both a zero-epi and a zero-mono.
As a result we can factorise each map ƒ : X → Y in D as:

(i † )†	m	i

f
X	coimage
 Izm¸(ƒ †) /○f//Im/(ƒ ) z¸f
zero-epi zero-mono
/Y /.	(6)


This coimage may also be reversed, so that a map in D can also be understood as a pair of kernels with a zero-mono/epi between them, as in:


X ¸,if†
¸ Imc(ƒ †) /○ //Im/(ƒ ) z¸if	/Y /


The two outer kernel maps perform some “bookkeeping” to adjust the types; the real action takes place in the middle, see the examples below. The category PInj consists, in a sense, of only these bookkeeping maps, without any action. This will be described more systematically in Definition 6.4.
Example 5.1 We briefly describe the factorisation (6) in Rel, PInj and Hilb, using diagrammatic order for convenience (with notation ƒ ; g = g ◦ ƒ ).
For a map (X →r1 R →r2 Y ) in Rel we take the images Xj > X of r1 and Y j > Y
of r2 in:

	R,

	Xj,

	R,


	Y j
	 	

In PInj the situation is simpler, because the middle part m in (6) is the identity,
in:

  ƒ1e F ,z,ƒ2z 

  ƒ1e F,,
eeF ,z,ƒ2z 


In Hilb, a morphism ƒ : X → Y factors as ƒ = i ◦ m ◦ e. The third part i : I → Y is given by i(y)= y, where I is the closure {ƒ (x) : x ∈ X}. The first part e : X → E is given by orthogonal projection on the closure E = {ƒ†(y) : y ∈ Y }; explicitly, e(x) is the unique xj such that x = xj + xjj with xj ∈ E and ⟨xjj | z⟩ =0 for all z ∈ E. Using the fact that the adjoint e† : E → X is given by e†(x)= x, we deduce that the middle part m : E → I is determined by m(x)= (i ◦ m)(x)= (ƒ ◦ e†)(x)= ƒ (x). Explicitly,
ƒ  Y  =  X −e→ E  ;  E −m→ I  ;  I −→i	Y  .

Categorical logic
In this final section we further investigate the logic of dagger kernel categories. We shall first see how the so-called Sasaki hook [13] arises naturally in this setting, and then investigate Booleanness.
For a kernel m : M > X we shall write P (m) = m ◦ m† : X → X. This P (m) is easily seen to be a self-adjoint idempotent 2 : one has P (m)† = P (m) and P (m) ◦ P (m) = P (m). The endomap P (m): X → X associated with a kernel/predicate m on X maps everything in X that is in m to itself, and what is perpendicular to m to 0, as expressed by the equations P (m) ◦ m = m and P (m) ◦ m⊥ = 0. Of interest is the following result. It makes the dynamical aspects of quantum logic described in [7] explicit.
Proposition 6.1 For kernels m : M > X, n : N > X the pullback P (m)—1(n) is the Sasaki hook, written here as ⊃:


def
m ⊃ n = P (m)
—1(n) = m⊥ ∨ (m ∧ n).


The associated left adjoint ∃P (m) E P (m)—1 yields the “and then” operator:

def	⊥

k & m = ∃P (m)(k) = m ∧ (m
∨ k),


so that the “Sasaki adjunction” holds by construction:

k & m ≤ n ⇐⇒ k ≤ m ⊃ n.

Quantum logic based on this “and-then” & connective is developed in [15], see also [20,21]. This & connective is in general non-commutative and non-associative 3 . Some basic properties are: m & m = m,1 & m = m &1= m,0 & m = m &0= 0, and both k & m ≤ n, k⊥ & m ≤ n imply m ≤ n (which easily follows from the Sasaki adjunction).
Proof. Consider the following pullbacks.


P   q	/N_/
Q   s	/P/⊥

_	rz
p	n
_	_rz
r	(m∧n)⊥= ker(p†○m†)

J zm¸/J/	J zm¸/J/ 
M	X	M	X


2 Sometimes these self-adjoint idempotents are called projections, but we shall use “projection” slightly differently, see a forthcoming paper, namely with additional requirement that it is less than or equal to the identity, for a suitably defined order on homsets.
3 The “and-then” connective & should not be confused with the multiplication of a quantale [22], since the latter is always associative.

Then:
m⊥ ∨ (m ∧ n) = m ∧ (m ∧ n)⊥ ⊥
= ker (m ∧ (m ∧ n)⊥)† 

= ker ker(coker((m ∧ n)⊥) ◦ m)† ◦ m†
by definition of r as pullback, see Lemma 2.4
= ker ker(coker(ker(p† ◦ m†)) ◦ m)† ◦ m† 

because p† ◦ m† is a cokernel, see Lemma 2.6
= ker(coker(p) ◦ m†)
=  m† —1(p)

= P (m)—1(n).	 

We now turn to Booleanness. As we have seen, the categories Rel, PInj and B (for a Boolean algebra B) are Boolean, but Hilb and PHilb are not. We start with a result that justifies the name “Boolean”.
Theorem 6.2 A dagger kernel category is Boolean if and only if each poset KSub(X)
is a Boolean algebra.
Proof. We already know that each poset KSub(X) is an orthomodular lattice, with bottom 0, top 1, negation (−)⊥ (by Lemma 2.3), intersections ∧ (by Lemma 2.6), and joins m ∨ n = (m⊥ ∧ n⊥)⊥. What is missing is distributivity m ∧ (n ∨ k) = (m ∨ n) ∧ (m ∨ k). We show that it is equivalent to the Booleanness requirement m ∧ n =0 ⇒ m ⊥ n. Recall: m ⊥ n iff n† ◦ m =0 iff m ≤ n⊥ = ker(n†).
First, assume Booleanness. To start,
(m ∧ (m ∧ n)⊥) ∧ n = (m ∧ n) ∧ (m ∧ n)⊥ =0 Hence m ∧ (m ∧ n)⊥ ≤ n⊥. Similarly, m ∧ (m ∧ k)⊥ ≤ k⊥. Therefore:
m ∧ (m ∧ n)⊥ ∧ (m ∧ k)⊥ ≤ n⊥ ∧ k⊥ = (n ∨ k)⊥,


and thus:

m ∧ (m ∧ n)⊥ ∧ (m ∧ k)⊥ ∧ (n ∨ k)= 0.

But then we are done by using Booleanness again:
m ∧ (n ∨ k) ≤ ((m ∧ n)⊥ ∧ (m ∧ k)⊥)⊥ = (m ∧ n) ∨ (m ∧ k).

The other direction is easier: if m ∧ n = 0, then:
m = m ∧ 1 = m ∧ (n ∨ n⊥)
= (m ∧ n) ∨ (m ∧ n⊥)	by distributivity
= 0 ∨ (m ∧ n⊥) = m ∧ n⊥.

Hence m ≤ n⊥.	 
The Booleanness property can be strengthened in the following way.
Proposition 6.3 The Booleanness requirement m ∧ n = 0 ⇒ m ≤ n⊥, for all kernels m, n, is equivalent to the following: for each pullback of kernels:
P   p	/N_/

_	rz
n
one has	n†
◦ m = p ◦ q†.

J zm¸/J/ 
M	X
Proof. It is easy to see that the definition of Booleanness is the special case P = 0. For the converse, we put another pullback on top of the one in the proposition:


0 _ 
/P /⊥
rz
p⊥

J zp¸ /J/ 
P_	N_
r_z	rz
q	n
J zm¸ /J/ 
M	X

We use that p, q are kernels by Lemma 2.4. We see m ∧ (n ◦ p⊥) = 0, so by Booleanness we obtain:
m ≤ (n ◦ p⊥)⊥ = ker (n ◦ ker(p†))†
= ker(coker(p) ◦ n†)
= (n†)—1(p),

where the pullback is as described in Lemma 2.4. Hence there is a map ϕ : M → P with p ◦ ϕ = n† ◦ m. This means that ϕ = p† ◦ p ◦ ϕ = p† ◦ n† ◦ m = (n ◦ p)† ◦ m = (m ◦ q)† ◦ m = q† ◦ m† ◦ m = q†. Hence we have obtained p ◦ q† = n† ◦ m, as required.	 
Definition 6.4 Let D be a Boolean dagger kernel category. We write DKcK for the category with the same objects as D; morphisms X → Y in DKcK are cokernel-kernel pairs (c, k) of the form X  c  z• ¸zk¸/Y /. The identity X → X is X  id  Xz ¸zid¸/X/, and composition of X   c  Mz¸ zk¸/Y /and Y   d  Nz ¸zl¸/Z /is

the pair (q† ◦ c, l ◦ p) obtained via the pullback:
P_ zp¸ /N_/ zl¸/Z/



r_z	rz
q	d†
(7)

X   c  zJ¸ zk¸/J/ 
Y
To be precise, we identity (c, k) with (ϕ ◦ c, k ◦ ϕ—1), for isomorphisms ϕ.
The reader may have noticed that this construction generalises the definition of
PInj. Indeed, now we can say PInj = RelKcK.
Theorem 6.5 The category DKcK as described in Deﬁnition 6.4 is again a Boolean dagger kernel category, with a functor D : DKcK → D in DCK and a change-of- base situation (pullback):


KSub(DKcK)

J 
DKcK
/K/Sub(D)

D	/J/ 

Moreover, in DKcK one has:
kernel = †-mono = mono = zero-mono, and DKcK is universal among such categories.
Proof. The obvious definition (c, k)† = (k†, c†) yields an involution on DKcK. The
zero object 0 ∈ D is also a zero object 0 ∈ DKcK with zero map X 	 z0 ¸ z¸/Y / consisting of a cokernel-kernel pair. A map (c, k) isa †-mono if and only if (c, k)† ◦ (c, k)= (k†, k) is the identity; this means that k = id.

 d z ¸zl ¸//
⊥  id  ⊥( d†)⊥

The kernel of a map (d, l) = ( Y
Z ) is ker(d, l) = ( N
Nz¸z¸/Y /),

so that ker(d, l) is a †-mono and (d, l) ◦ ker(d, l) = 0. If also (d, l) ◦ (c, k) = 0, then k ∧ d† = 0 so that by Booleanness, k ≤ (d†)⊥, say via ϕ : M → N⊥ with
(d†)⊥ ◦ ϕ = k. Then we obtain a mediating map (c, ϕ) = ( X  c  Mz¸  zϕ¸/N/⊥ ) which satisfies ker(d, l) ◦ (c, ϕ)= (id, (d†)⊥) ◦ (c, ϕ)= (c, (d†)⊥ ◦ ϕ)= (c, k). It is not hard to see that maps of the form (id, m) in DKcK are kernels, namely of the cokernel (m⊥, id).
The intersection of two kernels (id, m) = ( M M zm¸/X/) and (id, n) = ( N N zn¸/X/) in DKcK is the intersection m ∧ n : P > X in D, with pro-
jections ( P P z¸/M/) and ( P P z¸/N/). Hence if the intersection of (id, m) and (id, n) in DKcK is 0, then so is the intersection of m and n in D, which yields n† ◦ m = 0. But then in DKcK, (id, n)† ◦ (id, m) = (n†, id) ◦ (id, m) = 0. Hence DKcK is also Boolean.
Finally, there is a functor DKcK → D by X '→ X and (c, k) '→ k ◦ c. Composi-

tion is preserved by Proposition 6.3, since for maps as in Definition 6.4, (d, l) ◦ (c, k) = (q† ◦ c, l ◦ p) '−→ l ◦ p ◦ q† ◦ c = (l ◦ d) ◦ (k ◦ c).
We have already seen that KSub(X) in DKcK is isomorphic to KSub(X) in D. This yields the change-of-base situation.
We have already seen that kernels and †-monos coincide. We now show that they also coincide with zero-monos. So let (d, l): Y → Z be a zero-mono. This means that (d, l) ◦ (c, k)=0 ⇒ (c, k) = 0, for each map (c, k). Using diagram (7), this means: d† ∧ k = 0 ⇒ k = 0. By Booleanness, the antecedent d† ∧ k = 0 is equivalent to k ≤ (d†)⊥ = ker(d), which means d ◦ k = 0. Hence we see that d is zero-monic in D, and thus an isomorphism (because it is already a cokernel).
Finally, let E be a Boolean dagger kernel category in which zero-monos are kernels, with a functor F : E → D in DCK. Every morphism ƒ in E factors as ƒ = iƒ ◦ eƒ for a kernel iƒ and a cokernel eƒ . Hence G : E → DKcK defined by G(X)= F (X) and G(ƒ )= (eƒ , iƒ ) is the unique functor satisfying F = D ◦ G. 

Conclusions and future work
The paper shows that a “dagger kernel category” forms a powerful notion that not only captures many examples of interest in quantum logic but also provides basic structure for categorical logic. Several research avenues are still open: construction of dagger kernel categories from orthomodular lattices (like in Subsection 3.5 for Boolean algebras), or further investigation of the relevance of “opfibred” structure in this setting (like for “op-classifiers” at the end of Section 4).

References
Abramsky, S. and B. Coecke, A categorical semantics of quantum protocols, in: Logic in Computer Science, IEEE (2004), pp. 415–425.
Barr, M., Algebraically compact functors, Journ. of Pure & Appl. Algebra 82 (1992), pp. 211–231.
Barr, M. and C. Wells, “Toposes, Triples and Theories,” Springer, Berlin, 1985, revised and corrected version available from URL: www.cwru.edu/artsci/math/wells/pub/ttt.html.
Borceux, F., “Handbook of Categorical Algebra,” Encyclopedia of Mathematics 50, 51 and 52, Cambridge Univ. Press, 1994.
Cassinelli, G., E. De Vito, P. J. Lahti and A. Levrero, “The theory of symmetry actions in quantum mechanics,” Number 654 in Lecture Notes in Physics, Springer, 2004.
Coecke, B. and D. Pavlovi´c, Quantum measurements without sums, in: G. Chen, L. Kauffman and
S. Lamonaco, editors, Mathematics of Quantum Computing and Technology, Taylor and Francis, 2006 See also: arXiv:/quant-ph/0608035.
Coecke, B. and S. Smets, The Sasaki hook is not a [static] implicative connective but induces a backward [in time] dynamic one that assigns causes, Int. Journ. of Theor. Physics 43(7/8) (2004), pp. 1705–1736.
Freyd, P., “Abelian Categories: An Introduction to the Theory of Functors,” Harper and Row, New York, 1964, available via www.tac.mta.ca/tac/reprints/articles/3/tr3.pdf.
Haghverdi, E. and P. Scott, A categorical model for the geometry of interaction, Theor. Comp. Sci.
350 (2006), pp. 252–274.

Heunen, C., Compactly accessible categories and quantum key distribution, Logical Methods in Comp. Sci. 4(4) (2008).
Heunen, C., Quantifiers for quantum logic, preprint, arXiv:0811.1457 (2008).
Jacobs, B., “Categorical Logic and Type Theory,” North Holland, Amsterdam, 1999.
Kalmbach, G., “Orthomodular Lattices,” Academic Press, London, 1983.
Kock, A. and G. Reyes, Doctrines in categorical logic, in: J. Barwise, editor, Handbook of Mathematical Logic, North-Holland, Amsterdam, 1977 pp. 283–313.
Lehmann, D., A presentation of quantum logic based on an and then connective, Journ. of Logic and Computation 18(1) (2008), pp. 59–76.
Mac Lane, S., An algebra of additive relations, Proceedings of the National Academy of Sciences 47
(1961), pp. 1043–1051.
Makkai, M. and G. Reyes, “First Order Categorical Logic,” Number 611 in Lect. Notes Math., Springer, Berlin, 1977.
Manes, E., Monads, matrices and generalized dynamic algebra, in: H. Ehrig, H. Herrlich, H.-J. Kreowski and G. Preuß, editors, Categorical Methods in Computer Science With Aspects from Topology, number 393 in Lect. Notes Comp. Sci. (1989), pp. 66–81.
Puppe, D., Korrespondenzen in abelschen Kategorien, Mathematische Annalen 148 (1962), pp. 1–30.
Rom´an, L. and B. Rumbos, A characterization of nuclei in orthomodular and quantic lattices, Journ. of Pure & Appl. Algebra 73 (1991), pp. 155–163.
Rom´an, L. and R. Zuazua, On quantic conuclei in orthomodular lattices, Theory and Applications of Categories 2(6) (1996), pp. 62–68.
Rosenthal, K., “Quantales and their applications,” Number 234 in Pitman Research Notes in Math., Longman Scientific & Technical, 1990.
Selinger, P., Dagger compact closed categories and completely positive maps (extended abstract), in: P. Selinger, editor, Proceedings of the 3rd International Workshop on Quantum Programming Languages (QPL 2005), number 170 in Elect. Notes in Theor. Comp. Sci. (2007), pp. 139–163, dOI http://dx.doi.org/10.1016/j.entcs.2006.12.018.
Taylor, P., “Practical Foundations of Mathematics,” Number 59 in Cambridge Studies in Advanced Mathematics, Cambridge Univ. Press, 1999.
