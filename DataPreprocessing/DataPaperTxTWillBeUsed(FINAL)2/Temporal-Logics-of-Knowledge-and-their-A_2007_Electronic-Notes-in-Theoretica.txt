Electronic Notes in Theoretical Computer Science 186 (2007) 27–42	
www.elsevier.com/locate/entcs

Temporal Logics of Knowledge and their Applications in Security
Clare Dixona, Mari-Carmen Fern´andez Gagob, Michael Fishera and Wiebe van der Hoeka
a Department of Computer Science The University of Liverpool, Liverpool L69 7ZF, UK
{clare,michael,wiebe}@csc.liv.ac.uk
b Departamento de Lenguajes y Ciencias de la Computacio´n, University Of Malaga, 29071 M´alaga, Spain mcgago@lcc.uma.es

Abstract
Temporal logics of knowledge are useful for reasoning about situations where the knowledge of an agent or component is important, and where change in this knowledge may occur over time. Here we investigate the application of temporal logics of knowledge to the specification and verification of security protocols. We show how typical assumptions relating to authentication protocols can be specified. We consider verification methods for these logics, in particular, focusing on proofs using clausal resolution. Finally we present experiences from using a resolution based theorem prover applied to security protocols specified in temporal logics of knowledge.
Keywords: Temporal logics of knowledge, security, verification, theorem proving, resolution

Introduction
As more and more information is transferred electronically, and as the sensitivity of this data increases, there is an increasing need to provide mechanisms for ensur- ing the security of information transfer between computers. In addition, with the advent of grid and ubiquitous computing, security and trust are key issues that are integral to the success of these technologies. This need for security has led to the de- velopment of cryptographic protocols, in which authentication of the individuals and messages concerned (typically through encryption) occurs. Given the importance of the area, it is vital that techniques be used which provide automatic analysis of such protocols prior to deployment.
Ever since the security of information transfer between computers became an issue, it has been clear that formal methods should have a key part to play in analysing protocol security. A wide range of tools for formal verification applicable to security have been developed [36]. Typically, these involve either full (or at

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.11.043

least abstracted) state-space exploration, for example via model checking [33,38], or complex theorem-proving using higher-order tools [41,13]. While both these types of approach have made significant advances, neither is completely satisfactory: the first has limitations with infinite state spaces (even with abstraction techniques); the second suffers from the complexity of the human intervention required, and the lack of heuristics having a high probability of success. A more appealing solution lies in between these two, namely to use proof methods, but to restrict the logic to decidable or semi-decidable fragments. While such a restriction is not always possible, there are a wide range of cryptographic protocols where analysis of this style can be effective. In particular, many authentication techniques that can be captured in terms of the change in the participants’ knowledge and belief fall into this category.
The application of logical tools to the analysis of security protocols was pio- neered by Burrows, Abadi and Needham (BAN logics) [3]. These are purpose built belief logics especially designed for dealing with authentication issues. Whilst these logics were influential, they suffered from a number of drawbacks such as a lack of semantics, the inability to express time explicitly, the need to capture additional features, etc. This led to the development of extensions, or logics of a similar style aimed at a larger class of systems such as [21,50]. In this paper we describe how to use a combination of standard, well-known modal and temporal logics, rather than developing special purpose logics, to specify security protocols.
Temporal logic is an extension of classical logic that is widely used in the speci- fication and verification of complex systems. In this logic, time is an added dimen- sion and so logical properties can evolve over time; consequently this form of logic is very suitable for systems that change over time, such as dynamic or adaptive systems. Temporal logic has been used in many areas within Computer Science and Artificial Intelligence, including the specification and verification of reactive (e.g. distributed or concurrent) systems [34], the synthesis of programs from temporal specifications [42,31], algorithmic verification via model-checking [26,7], knowledge representation and reasoning [15,2,52], and temporal databases [6,5].
Modal logics involve reasoning over possible worlds. The worlds are connected by relations for each agent or process denoting possible alternative worlds. A formula ϕ is possible, denoted ♦i ϕ in a world s if and only if there is a world t such that
(s, t) is in the i-relation and ϕ holds in t. A formula ϕ is necessary, denoted	ϕ in
a world s if and only if for all worlds t if (s, t) is in the i-relation then ϕ holds at
t. Modal logics have been used to capture notions such as knowledge, belief, desire, intention (see for example [15,44]) etc. In particular, the modal logic S5 has been used to reason about knowledge [15]. As we are interested in knowledge, we use the

operator Ki instead of knows ϕ.
and ¬Ki¬ instead of ♦i , where Kiϕ denotes that agent i

Together combinations of logics have been used to specify complex systems such as distributed or multi-agent systems. When specifying such systems we may need to represent dynamic, informational and motivational aspects of systems. Dynamic as- pects are typically modelled using temporal or dynamic logics, informational aspects

such as knowledge or belief using the modal logics S5 and KD45 and motivational aspects such as desires, intentions and wishes using the modal logics KD.
In this paper we will concentrate on a specific temporal logic of knowledge [15,37]. This is a temporal logic enriched by the addition of modal connectives for represent- ing the knowledge of a group of processes, using the modal logic S5. These logics can be used to formalise statements such as: “if process p1 knows that process p2 has received message m1, then p1 should eventually send message m2 to p2”.
The structure of this paper is as follows. In Section 2 we describe a particular authentication protocol, namely the Needham-Schroeder protocol. In Section 3 we provide a syntax and semantics for the temporal logic of knowledge used in this paper, KL(n), while in Section 4, we discuss how protocols such as the Needham- Schroeder protocol can be specified using this logic. In Section 5 we give an overview to a resolution based proof method for temporal logics of knowledge. In Section 6 we provide results having carried out proofs by hand and with an automatic theorem prover for a related logic. In Section 7 we mention related work and in Section 8 we provide concluding remarks.

The Needham-Schroeder protocol with public keys
The Needham-Schroeder protocol with public keys [40] intends to establish authen- tication between an agent A who initiates a protocol and an agent B who responds to A.
The complete protocol consists of seven messages, but we focus on a simplified version consisting of only three messages. The messages that we omit are those whereby the agents request other agents’ public keys from a server. Note that omitting these steps is equivalent to assuming that each agent always knows all the others’ public keys.
The protocol can then be described as the three following steps:

Message	Direction	Contents
Message 1	A → B	{NA, A}pub key(B) Message 2	B → A	{NB, NA}pub key(A) Message 3	A → B	{NB}pub key(B)
Note that message contents of the form {X, Y }pub key(Z) represent messages con- taining both X and Y but then encrypted with Z’s public key. Elements of the form NX are special items of data, called nonces. Typically, agents in the protocol
will generate their own unique nonce (often encrypted) which is, at least initially, unknown to all other agents.
Message 1: A sends B an encrypted nonce together with A’s identity, all encrypted with B’s public key.

Message 2: When B receives Message 1, it decrypts it using its corresponding private key to obtain NA. Then B returns to A the nonce NA and generates another nonce of his own, NB, and sends it back, this time encrypted with A’s public key.
Message 3: When A receives Message 2, it returns B’s nonce, this time encrypted with B’s public key in order to prove A’s authenticity.
A man in the middle attack on this protocol has been described by Lowe [33]. Agent A tries to run the protocol with a dishonest agent C. C pretends to be A and runs the protocol with B. Steps of the two protocol runs are interleaved and the outcome is that B thinks he has been running the protocol with A whereas he has actually been running it with C. Consequently C learns B’s nonce.

Syntax and Semantics
The logic, KL(n), a temporal logic of knowledge we consider is the fusion of linear- time temporal logic with multi-modal S5. We first give the syntax and semantics of KL(n), where each modal relation is restricted to be an equivalence relation [24]. The temporal component is interpreted over a discrete linear model of time with finite past and infinite future; an obvious choice for such a flow of time is (N, <), i.e., natural numbers ordered by the usual ‘less than’ relation. This logic has been studied in detail [24] and is the most commonly used temporal logic of knowledge.

Syntax
Formulae are constructed from a set P = {p, q, r,.. .} of primitive propositions. The language KL(n) contains the standard propositional connectives ¬ (not), ∨ (or), ∧ (and) and ⇒ (implies). For knowledge we assume a set of agents Ag = {1,... n} and introduce a set of unary modal connectives Ki, for i ∈ Ag, where a formula Kiφ is read as “agent i knows φ”. For the temporal dimension we take the usual [19] set of future-time temporal connectives o(next), ♦ (sometime, or eventually),  (always), U (until) and W (unless, or weak until).

The set of well-formed formulae of KL(n), wffK is defined as follows:
false, true and any element of P is in wffK;
if A and B are in wffK then so are (where i ∈ Ag)
KiA
oA
We define some particular classes of formulae that will be useful later.
Definition 3.1 A literal is either p, or ¬p, where p ∈ P.
Definition 3.2 A modal literal is either Kil or ¬Kil where l is a literal and i ∈ Ag.

Semantics
First, we assume that the world may be in any of a set, S, of states.
Definition 3.3 A timeline, t, is an infinitely long, linear, discrete sequence of states, indexed by the natural numbers. Let TLines be the set of all timelines.
Definition 3.4 A point q, is a pair q = (t, u), where t ∈ TLines is a timeline and
u ∈ N is a temporal index into t. Let Points be the set of all points.
Definition 3.5 A valuation π, is a function π : Points ×P → {T, F }.
Definition 3.6 A model M , is a structure M = ⟨TL, R1,... , Rn, π⟩, where:
TL ⊆ TLines is a set of timelines, with a distinguished timeline t0;
Ri, for all i ∈ Ag is the agent accessibility relation over Points, i.e., Ri ⊆ Points× Points, where each Ri is an equivalence relation; and
π is a valuation.
As usual, we define the semantics of the language via the satisfaction relation ‘|=’. For KL(n), this relation holds between pairs of the form ⟨M, q⟩ (where M is a model and q is a point in TL × N), and formulae in wffK. The rules defining the satisfaction relation are given below. We omit the semantics of some of the classical operators as they are standard and the temporal operators U and W as they will not be used further in this paper.
⟨M, (t, u)⟩ |= true
⟨M, (t, u)⟩ |= false
⟨M, (t, u)⟩ |= p	iff	π((t, u), p)= T	(where p ∈ P)
⟨M, (t, u)⟩ |= ¬A	iff	⟨M, (t, u)⟩ |= A
⟨M, (t, u)⟩ |= A ∨ B	iff	⟨M, (t, u)⟩ |= A or ⟨M, (t, u)⟩ |= B
⟨M, (t, u)⟩ |= oA	iff	⟨M, (t, u + 1)⟩ |= A
⟨M, (t, u)⟩ |=  A	iff	∀u' ∈ N,  if (u ≤ u') then ⟨M, (t, u')⟩ |= A
⟨M, (t, u)⟩ |= ♦A	iff	∃u' ∈ N such that (u ≤ u') and ⟨M, (t, u')⟩ |= A
⟨M, (t, u)⟩ |= KiA	iff	∀t' ∈ TL. ∀u' ∈ N. if ((t, u), (t', u')) ∈ Ri
then ⟨M, (t', u')⟩ |= A
For any formula A, if there is some model M and timeline t such that ⟨M, (t, 0)⟩ |= A, then A is said to be satisfiable. If for any formula A, for all models M there exists a timeline t such that ⟨M, (t, 0)⟩ |= A then A is said to be valid. Note, this is the anchored version of the (temporal) logic, i.e. validity and satisfiability are evaluated

at the beginning of time (see for example [14]).
As agent accessibility relations in KL(n) models are equivalence relations, the axioms of the normal modal system S5 are valid in KL(n) models. The system S5 is widely recognised as the logic of idealised knowledge, and for this reason KL(n) is often termed a temporal logic of knowledge.

Specification using Temporal Logics of Knowledge
In this section, we will give an overview on how to use KL(n) to specify the Needham- Schroeder protocol. In order to do this we use the following syntactic conventions. Let M , M1 and M2 be variables over messages, W be a variable over keys, N be a variable over nonces, V be a variable over values for keys and nonces, and X, Y,... be variables over agents. Moreover, for every agent, X, we assume there are keys pub key(X) and priv key(X), while in this protocol A and B are constants representing two specific agents. We identify the following predicates:
send(X, M ,W ) is satisfied if agent X sends message M encrypted by key W ;
rcv(X, M, W ) is satisfied if agent X receives message M encrypted by key W ;
Msg(M ) is satisfied if M is a message;
nonce(N ) is satisfied if N is a nonce;
val pub key(X, V ) is satisfied if the value of the public key of X is V ;
val priv key(X, V ) is satisfied if the value of the private key of X is V ;
val nonce(N, V ) is satisfied if the value of nonce N is V ;
contains(M1, M2) is satisfied if the message M2 is contained within M1.
To simplify the description, we allow quantification and equality over the sets of agents, messages and keys. As we assume a finite set of agents, messages, keys and nonces this logic remains essentially propositional. The following are examples of typical assumptions:
initially, only agent A knows the content of its own nonce NA and only B knows the content of its own nonce NB;
messages sent are not guaranteed to arrive at the required destination;
if a message is received by an agent, then that message must have been previously sent by some agent;
knowledge of messages persists, i.e. agents do not forget message contents;
if a message is received, and the receiver knows the private key required, then the receiver will know the content of the message; and
an intruder can intercept messages sent to others.
We allow a simple representation of public and private keys in terms of the unary functions ‘pub key(X)’ and ‘priv key(X)’. All agents know the public keys of all other agents, but each agent’s private key is only known by that agent.

Rather than give the complete set of axioms we provide some examples showing how to specify the above assumptions.
Initially, only agent A knows the value of its own nonce and only B knows the value of its own nonce.
KAval nonce(NA, an)  ¬KAval nonce(NB, an)  ¬KAval nonce(NB, bn) etc ... 
In the above an and bn are particular values for nonces and there will be similar formulae relating to B’s knowledge. Note that these statements are the initial conditions and must hold at the beginning of time.
Messages sent are not guaranteed to arrive.
There is no axiom of the form
send(.. .) ⇒ ♦rcv(.. .)
If any message does arrive, then that message must have been previously sent by some agent.
∀X, M, W. rcv(X, M, W ) ⇒ ∃Y. ♦• send(Y, M, W )
Note that ‘♦• ’ is the operator sometime in the past and has the following seman- tics.
⟨M, (t, u)⟩ |= ♦• A  iff  ∃u' ∈ N such that (0 ≤ u' < u) and ⟨M, (t, u')⟩ |= A
Whilst the use of this past-time operator makes specifying this axiom easier (see also, for example, [32]), it is well known that for finite past such operators add no extra expressive power [19,32] and can be translated using just future-time operators.
Agents’ knowledge of nonces and keys persists.
∀X, N, V. KXval nonce(N, V ) ⇒  oKXval nonce(N, V ) This is the axiom for nonces and there is a similar axiom for keys.
If a message is received containing a nonce, and the receiver knows the private key required, then the receiver will know the value of the nonce.

∀X, M, Y, V, N.
(rcv(X, M, pub key(Y )) ∧ KX val priv key(Y, V )∧
Msg(M ) ∧ contains(M, N ) ∧ nonce(N ))
⇒ ∃V1KX val nonce(N, V1)
The actual axiom in [4,12] is more complex than this as it also incorporates the idea that the knowledge of some information must come about from either having known something in a previous moment, if there was one, or from the initial

conditions or from having been sent a message which the agent could decrypt containing that information.
An intruder can intercept messages sent to others.
The predicate send does not contain who the message is sent to and the predicate rcv doesn’t contain information relating to who sent the message. Similarly, there is no axiom stating that receiving a message implies that the message must have been sent to that agent by a third party.
For full details of the specification see the axioms in [4,12].

Resolution for Temporal Logics of Knowledge
We give a brief overview of the resolution method for KL(n); for full details see [11,10]. To show that a KL(n)formula, ϕ, is valid we negate it and translate into a normal form, SNKK. Formulae in normal form are of the form
 ∗  Ti i

where

⟨M, (t, u)⟩ |=  ∗  Ti	iff	⟨M, (t', u')⟩ |=  Ti

i	i
for every point (t', u') reachable from (t, u) using either temporal or epistemic tran- sitions of arbitrary length.
Each Ti is known as a clause and must be one of the following:


start ⇒

g


  lb	(an initial clause)
b=1
r

  ka ⇒  o  lb (a step clause)

a=1 g
b=1

   ka ⇒ ♦l	(a sometime clause)
a=1

true ⇒


  m1b  (a K1–clause)
b=1

...	⇒ ... 
r

true ⇒


true ⇒
  mnb  (a Kn–clause)
b=1


  lb	(a literal–clause)
b=1

where ka, lb, and l are literals (propositions or their negations) and mjb are either literals or are of the form Kjl or ¬Kjl (modal literals).

The translation to SNFK removes all temporal operators apart from o (in the next moment in time) and ♦ (sometime in the future) by: rewriting them using their fixpoint definitions; renaming complex subformulae by new propositional variables where the truth value of these new propositions is linked to the formulae they replaced at all moments in time; and by using standard equivalences. Then resolution rules are applied to clauses until either start ⇒ false is derived, meaning ‘ϕ is valid’, or until no new clauses can be generated, meaning ‘ϕ is not valid’. The method has been shown to be sound, complete and terminating [11,10]. Rather than giving full details, we next provide a brief overview of the key aspects of the approach. Resolution rules can be of one of four types: initial, step, modal or temporal.
The following step resolution rules, applied between two step clauses or between a step and a literal clause, are similar to classical style resolution rules.



[SRES1]
P ⇒  o(F ∨ l)
Q ⇒ o(G ∨ ¬l) (P ∧ Q) ⇒  o(F ∨ G)

[SRES2]
P ⇒  o(F ∨ l)
true ⇒ (G ∨ ¬l)

P ⇒ (F ∨ G)

There are similar initial resolution rules for resolving two initial clauses or an initial and literal clause.
The following (also termed a step resolution rule) states ‘if Q leads to a contra- diction then ¬Q must hold everywhere’.


[SRES2]
Q ⇒ ofalse true ⇒ ¬Q

There is also a complex temporal resolution rule that resolves sets of step clauses that together imply P ⇒ o  l with a sometime clause of the form Q ⇒ ♦¬l. Explanation of this is beyond the scope of this paper and the interested reader is referred to [17].
Modal resolution rules are applied between two Ki clauses (for some i) or be- tween a Ki clause and a literal clause. These relate to the axioms of the modal logic S5. For example, the following rule:



[MRES3]
true ⇒ D ∨ Kil true ⇒ D' ∨ ¬l true ⇒ D ∨ D'

relates to the axiom Kiϕ ⇒ ϕ as Kil and ¬l cannot both hold together.
Theorem 5.1 Translation to SNFK preserves satisfiability [11,10]. A KLn formula A is satisﬁable if, and only if, τK[A] is satisﬁable (where τK is the translation into SNFK).

Theorem 5.2 Termination[11,10]. The resolution procedure terminates.
Theorem 5.3 Soundness[11,10]. Let S be a satisﬁable set of SNFK clauses and T be the set of clauses obtained from S by an application of one of the resolution rules. Then T is also satisﬁable.
Theorem 5.4 Completeness[11,10]. If a set of SNFK clauses is unsatisﬁable then it has a refutation by the given temporal resolution procedure.

Verifying Properties of NSP
We next describe how we used resolution based proof methods for KL(n) to verify simple properties of NSP.

Resolution Proof in Temporal Logics of Knowledge
We have proved several (simple) properties of NSP by hand using clausal resolution for KL(n). Full details are given in [4,12]. The properties we have considered are given below.
Once B receives the nonce of A encoded by B’s public key then B knows the value of that nonce.
This may be formalised as
 (rcv(B, m1, pub key(B)) ⇒  oKBval nonce(NA, an)).

Here m1 represents the first message of NSP, i.e. A’s identity and nonce encoded in B’s public key and an is the actual value of A’s nonce.
Once A receives its nonce back encoded via A’s public key then A knows that B knows the value of that nonce, i.e.
 (rcv(A, m2, pub key(A)) ⇒  oKAKBval nonce(NA, an))
Here m2 represents the second message of NSP, i.e. a message containing both A’s and B’s nonces encoded in A’s public key and, as previously, an is the actual value of A’s nonce.
C will never know the value of A’s nonce.
 ¬KCvalue nonce(NA, an)
Here C represents some other intruder agent and, as previously, an is the actual value of A’s nonce. This can be proved as we have used axioms stating that A and B can only send messages containing their nonces in the public keys of A and B. Whilst this is a strong axiom, if we allowed A or B to send messages containing their nonces in C’s public key it is obvious that C will be able to learn their contents.

Proof Using the Theorem Prover TeMP
Next we describe using a resolution theorem prover for monodic First-Order Tem- poral Logic (TeMP) to carry out these proofs automatically. First-Order (discrete linear time) Temporal Logic (FOTL) is an extension of classical first-order logic with operators that deal with a linear and discrete model of time. A formula, ϕ of FOTL is monodic if any subformula T φ (where T is , ♦, or	o) or any subformula φ1T φ2 (where T is U or W ) contains at most one free variable. Whilst full FOTL is incomplete, the monodic fragment has a finite axiomatisation [53] and may also be decidable if the pure first-order part is restricted to be a decidable fragment [25]. TeMP [27], is an implementation of a resolution-based calculus for monodic First-Order Temporal Logic over expanding domains [28]. TeMP implements the calculus described in [29], which is an implementable version of the monodic tem-
poral resolution calculus of [8].
It is possible to translate formulae from temporal logics of knowledge into the monodic fragment of First-Order Temporal Logic (see for example [18,46] for trans- lations from modal to first-order logics). Essentially, the truth of propositions in worlds are encoded by a unary predicate, accessibility relations between worlds are encoded by binary predicates, and restrictions on accessibility relations such as reflexivity, symmetry, transitivity (recall the modal accessibility relations are equiv- alence relations) are encoded as conditions on the binary relations. We provide such a translation in [16] and prove it is satisfiability preserving.
Using this approach, we have translated the specification of the NSP and the properties we wish to prove into FOTL and have run TeMP on the output. We have been able to prove the above properties provided we utilise the axiomatic translation [46] which is amenable to automatic theorem proving. In the axiomatic translation, the transitivity axiom is dealt with in a non-standard way to avoid termination problems which may occur with the standard translation. Full details of this approach, timings, the number of clauses generated, etc, can be found in [16].

Related Work
The application of logical tools to the analysis of security protocols was pioneered by Burrows, Abadi and Needham [3]. Known as BAN logic, this was an early approach to formalising the description and analysis of authentication protocols. BAN logic is a logic of belief, and it is the ‘beliefs’ of the computational components that are modified as the protocol progresses. Primitives in BAN allow statements such as A believes X, A sees M etc. The rules in these logics are such as “if an agent A sees M encrypted with a key K and he believes K is a good key for talking with another agent then A has seen M ”.
Whilst BAN was very influential it suffered from a number of drawbacks. Firstly BAN had no formal semantics. Although a modal logic semantics was given to a BAN-like logic in [1], this is complex. Also, when using BAN logics the protocol idealisation step, i.e. transforming the informal description of the protocol to one using BAN primitives, is far from easy. Further, BAN originally had no explicit

temporal component so could not express statements such as if a message is received then it was sent at some moment in the past, and suffered from difficulties in dealing with negated beliefs, i.e. the absence of information.
Since the introduction of BAN logic, many other logics in this style have been derived, some attempting to address the above drawbacks. These have either been extensions of BAN logic (e.g. GNY [21]) or logics developed in a similar style, but aimed at a larger class of systems (e.g. SvO [50]). What the majority of these techniques have in common is that their underlying basis can be seen as a multi- modal logic (typically knowledge, or belief ). Indeed, the SvO logic is an S5 logic for cryptographic protocol analysis that unifies several earlier logics and provides a semantic basis for them. In this work, it is clear than some of the problems that have occurred require more dynamic notations for their solution. This has led to the addition of temporal aspects to these logics [49].
In [20] a temporal logic of knowledge is described also incorporating obligation and permission for reasoning about security policies. However the temporal part uses a simplified branching time logic.
Other approaches to the formal verification of security protocols involve, for example, the use of process algebras [47,45], tools for higher order logics [41,13] and model checking [33,38,45].
Whilst some of the verification tools mentioned above are general purpose tools that have been used for the formal verification of security protocols, there are other tools developed specifically for the analysis of security protocols. It is worth men- tioning the NRL Protocol Analyzer [35] (where NRL stands for Naval Research Laboratory where this tool was developed). This analyzer has been successful in finding unpublished vulnerabilities.
Regarding verification for other types of protocol, standard epistemic logics [15,37] have been applied successfully to reason about communication protocols, for example the derivation of the alternating bit protocol in [22] or, more recently, the analysis of TCP [48]). In such an analysis, an epistemic language is useful in order to express that some receiver indeed knows some message at a specific state of the protocol, or that a sender knows that the receiver knows the message. In this setting, contrary to the security framework of BAN, the implicit assumption is always that the network is not hostile.
Temporal logics of knowledge (and belief) have been widely studied see for exam- ple [15,24,30,37,51]. As well as the resolution based proof methods for these logics, tableau style algorithms also exist, see for example [54] for temporal logics of knowl- edge and belief, or [43,44] for the fusion of either linear or branching-time temporal logic with the modal logics KD45 for belief, and KD for desire and intention.

Concluding Remarks
We have given an overview of how to specify security protocols, in particular the Needham-Schroeder protocol, using temporal logics of knowledge. We have proved properties of this protocol both by hand and automatically using the theorem prover

TeMP via a translation to the monodic fragment of First-Order Temporal Logic. Using proof in temporal logics of knowledge for the verification of security protocols has a number of advantages. Firstly, these logics are well known and well studied, having formal semantics and a bank of work relating to axiomatisations, complexity results etc. Secondly, time is incorporated explicitly to deal with the ordering of events ensuring that these logics are able to describe dynamic aspects of protocols. Verification can then be achieved via proof within an appropriate logic. Thus we avoid having to develop special purpose logics and proof methods specifically for the security domain. Dealing with negated information presents us with no problems and negated properties can be easily specified. Further, Lowe’s attack [33] suggests that it may be worthwhile to use both knowledge and belief in the specification, as agents can be misled. Technically this presents us with no problems, since we just use a temporal logic combined with suitable modal logics for knowledge (S5) and belief (KD45).
Whilst this approach has a number of advantages it does have some drawbacks. We carried out the specification by hand, encoding the assumptions, the protocol, and initial situation. This task is non-trivial and prone to error. Ideally we would like to produce a framework suggesting suitable axioms, given particular assump- tions. This problem is similar to that of idealisation in BAN, i.e. moving from an informal protocol description to one using BAN primitives. On the other hand, our experience is that spelling out such a specification makes crystal clear what assumptions are needed to show a protocol guarantees certain desirable properties.
Another issue is the size of the specification. Apparently simple protocols such as the NSP require many axioms and initial conditions. The first-order aspects of some of these axioms makes a huge specification when written propositionally. Future work involves re-considering these axioms to see whether we can abstract away from some of the detail (such as the values of keys and nonces) while still being able to prove useful properties of the protocol.
Regarding our explicit representation of time, several axioms deal with no for- getting or perfect recall assumptions, i.e. if we know something now (eg the value of a nonce) then we will also know this in the next moment. Thus when, incorporating time explicitly we have to state axioms relating to not forgetting the value of nonces, keys etc. An alternative to this would be to use a temporal logic of knowledge with more complex interactions between knowledge and time. For example if we allow the following as an axiom
Ki op ⇒ oKip,

meaning “if agent i knows that, in the next moment, p will be true then, in the next moment, agent i will know that p is true” then we can describe how knowledge evolves over time. Systems with the above axiom have been termed systems of synchrony and perfect recall [23]. Such logics, allowing non-trivial interactions be- tween the modal and temporal components become, in general, theoretically more complex, sometimes undecidable [23]. Proof methods for these complex logics have been developed in [9,39].

References
Abadi, M. and M. R. Tuttle, A Semantics for a Logic of Authentication, in: L. Logrippo, editor, 10th Annual ACM Symposium on Principles of Distributed Computing (1991), pp. 201–216.
Artale, A. and E. Franconi, Temporal Description Logics, in: Handbook of Temporal Reasoning in Artificial Intelligence, Foundations of Artificial Intelligence, Elsevier, 2005 pp. 375–388.
Burrows, M., M. Abadi and R. Needham, A Logic for Authentication, Proceedings of the Royal Society of London 426(1871) (1989), pp. 233–271.
C. Dixon and M.-C. Fern´andez Gago and M. Fisher and W. van der Hoek, Using Temporal Logics of Knowledge in the Formal Verification of Security Protocols, in: Proceedings of TIME 2004 the Eleventh International Symposium on Temporal Representation and Reasoning (2004), pp. 148–151.
Chomicki, J., Efficient Checking of Temporal Integrity Constraints Using Bounded History Encoding, ACM Transactions on Database Systems 20(2) (1995), pp. 149–186.
Chomicki, J. and D. Toman, Temporal Logic in Information Systems, in: Logics for Databases and Information Systems, 1998, pp. 31–70.
Clarke, E., O. Grumberg and D. A. Peled, “Model Checking,” MIT Press, 2000.
Degtyarev, A., M. Fisher and B. Konev, Monodic Temporal Resolution, ACM Transactions on Computational Logic 7(1) (2006).
Dixon, C. and M. Fisher, Clausal Resolution for Logics of Time and Knowledge with Synchrony and Perfect Recall, in: H. Wansing and F. Wolter, editors, Proceedings of the Third International Conference on Temporal Logic (ICTL), Leipzig, Germany, 2000, pp. 43–52.
Dixon, C. and M. Fisher, Resolution-Based Proof for Multi-Modal Temporal Logics of Knowledge, in:
S. Goodwin and A. Trudel, editors, Proceedings of TIME-00 the Seventh International Workshop on Temporal Representation and Reasoning (2000), pp. 69–78.
Dixon, C., M. Fisher and M. Wooldridge, Resolution for Temporal Logics of Knowledge, Journal of Logic and Computation 8(3) (1998), pp. 345–372.
Dixon, C., M.-C. F. Gago, M. Fisher and W. van der Hoek, Using Temporal Logics of Knowledge in the Formal Verification of Security Protocols, Technical Report ULCS-03-022, University of Liverpool, Department of Computer Science (2003), http://www.csc.liv.ac.uk/research/techreports.
Dutertre, B. and S. Schneider, Using a PVS Embedding of CSP to Verify Authentication Protocols, in: Theorem Proving in Higher Order Logics: TPHOL’s 97, Lecture Notes in Computer Science 1275 (1997), pp. 121–136.
Emerson, E. A., Temporal and Modal Logic, in: J. van Leeuwen, editor, Handbook of Theoretical Computer Science, Elsevier Science Publishers B.V.: Amsterdam, The Netherlands, 1990 pp. 996–1072.
Fagin, R., J. Y. Halpern, Y. Moses and M. Y. Vardi, “Reasoning About Knowledge,” MIT Press, 1995.
Fern´andez Gago, M., U. Hustadt, C. Dixon, M. Fisher and B. Konev, First-Order Verification in Practice, Journal of Automated Reasoning 34(3) (2005), pp. 295–321.
Fisher, M., C. Dixon and M. Peim, Clausal Temporal Resolution, ACM Transactions on Computational Logic 2(1) (2001), pp. 12–56.
Gabbay, D., A. Kurucz, F. Wolter and M. Zakharyaschev., “Many-Dimensional Modal Logics: Theory and Applications,” Studies in Logic and the Foundations of Mathematics 148, Elsevier, 2003.
Gabbay, D., A. Pnueli, S. Shelah and J. Stavi, The Temporal Analysis of Fairness, in: Proceedings of the Seventh ACM Symposium on the Principles of Programming Languages, Las Vegas, Nevada, 1980,
pp. 163–173.
Glasgow, J., G. MacEwen and P.Panangaden, A Logic to Reason About Security, ACM Transactions on Computer Systems 10(3) (1992), pp. 226–264.
Gong, L., R. Needham and R. Yahalom, Reasoning about Belief in Cryptographic Protocols, in:
Proceedings of the IEE Computer Society Symposium on Research in Security and Privacy (1990),
pp. 234–248.
Halpern, J. and L. Zuck, A Little Knowledge Goes a Long Way: Simple Knowledge-Based Derivations and Correctness Proofs for a Family of Protocols, in: Proceedings of the 6th ACM Symposium on Principles of Distributed Computing, 1987, pp. 268–280.

Halpern, J. Y., R. van der Meyden and M. Vardi, Complete Axiomatizations for Reasoning About Knowledge and Time, SIAM Journal on Computing 33(3) (2004), pp. 674–703.
Halpern, J. Y. and M. Y. Vardi, The Complexity of Reasoning about Knowledge and Time. I Lower Bounds, Journal of Computer and System Sciences 38 (1989), pp. 195–237.
Hodkinson, I., F. Wolter and M. Zakharyaschev, Decidable Fragments of First-Order Temporal Logics, Annals of Pure Applied Logic 106(1-3) (2000), pp. 85–134.
Holzmann, G., “Design and Validation of Computer Protocols,” Prentice-Hall, Englewood Cliffs, New Jersey, 1991.
Hustadt, U., B. Konev, A. Riazanov and A. Voronkov, TeMP: A Temporal Monodic Prover, in:
D. A. Basin and M. Rusinowitch, editors, Proceedings of the Second International Joint Conference on Automated Reasoning (IJCAR), LNAI 3097 (2004), pp. 326–330.
Konev, B., A. Degtyarev, C. Dixon, M. Fisher and U. Hustadt, Towards the Implementation of First- Order Temporal Resolution: the Expanding Domain Case, in: Proceedings of TIME-ICTL (2003), pp. 72–82.
Konev, B., A. Degtyarev, C. Dixon, M. Fisher and U. Hustadt, Mechanising First-Order Temporal Resolution, Information and Computation 199(1-2) (2005), pp. 55–86.
Kraus, S. and D. Lehmann, Knowledge, Belief and Time, Theoretical Computer Science 58 (1988),
pp. 155–174.
Kupferman, O. and M. Vardi, Synthesis with Incomplete Information, in: Advances in Temporal Logic, Applied Logic Series 16 (2000), pp. 109–127, proceedings the Second International Conference on Temporal Logic (ICTL). ISBN 0-7923-6149-0.
Lichtenstein, O., A. Pnueli and L. Zuck, The Glory of the Past, in: R. Parikh, editor, Logics of Programs (Proc. Conf. Brooklyn USA 1985), Lecture Notes in Computer Science 193, Springer, Berlin, 1985 pp. 196–218.
Lowe, G., Breaking and Fixing the Needham-Schroeder Public-key Protocol Using CSP and FDR, in:
T. Margaria and B. Steffen, editors, Tools and Algorithms for the Construction and Analysis of Systems: Second International Workshop, TACAS ‘96, Lecture Notes in Computer Science 1055 (1996), pp. 147–166.
Manna, Z. and A. Pnueli, “The Temporal Logic of Reactive and Concurrent Systems: Specification,” Springer, New York, 1992.
Meadows, C., The NRL Protocol Analyzer: An Overview., Logic Programming 26(2) (1996), pp. 113– 131.
Meadows, C., Formal Methods for Cryptographic Protocol Analysis: Emerging Issues and Trends, IEEE Journal on Selected Areas in Communication 21(1) (2003), pp. 44–54.
Meyer, J.-J. C. and W. van der Hoek, “Epistemic Logic for Computer Science and Artificial Intelligence,” Cambridge Tracts in Theoretical Computer Science 41, Cambridge University Press, 1995.
Mitchell, J., M. Mitchell and U. Stern, Automated Analysis of Cryptographic Protocols using Murφ, in:
Proceedings of the 1997 IEEE Symposium on Security and Privacy (1997), pp. 141–151.
Nalon, C., C. Dixon and M. Fisher, Resolution for Synchrony and No Learning, in: R. Schmidt, I. Pratt- Hartmann, M. Reynolds and H. Wansing, editors, AiML-2004: Advances in Modal Logic, Advances in Modal Logic Series 5 (2005), pp. 231–248.
Needham, R. and M. Schroeder, Using Encryption for Authentication in Large Networks of Computers, Communications of the ACM 21 (1978), pp. 993–999.
Paulson, L. C., The Inductive Approach to Verifying Cryptographic Protocols, Journal of Computer Security 6(1-2) (1998), pp. 85–128.
Pnueli, A. and R. Rosner, On the Synthesis of a Reactive Module, in: Proceedings of the 16th ACM Symposium on the Principles of Programming Languages, 1989, pp. 179–190.
Rao, A. S., Decision Procedures for Propositional Linear-Time Belief-Desire-Intention Logics, in:
M. Wooldridge, K. Fischer, P. Gmytrasiewicz, N. R. Jennings, J. P. Mu¨ller and M. Tambe, editors, IJCAI-95 Workshop on Agent Theories, Architectures, and Languages, Montr´eal, Canada, 1995, pp. 102–118.
Rao, A. S. and M. P. Georgeff, Decision procedures for BDI logics, Journal of Logic and Computation
8(3) (1998), pp. 293–342.


Ryan, P., S. Schneider, M. Goldsmith, G. Lowe and B. Roscoe, “Modelling and Analysis of Security Protocols,” Addison Wesley, 2001.
Schmidt, R. A. and U. Hustadt, A Principle for Incorporating Axioms into the First-Order Translation of Modal Formulae, in: Automated Deduction—CADE-19, Lecture Notes in Artificial Intelligence 2741 (2003), pp. 412–426.
Schneider, S., Verifying Authentication Potocols with CSP, in: PCSFW: Proceedings of The 10th Computer Security Foundations Workshop (1997), pp. 3–17.
Stulp, F. and R. Verbrugge, A Knowledge-Based Algorithm for the Internet Transmission Control Protocol (TCP), Bulletin of Economic Research 54(1) (2002), pp. 69–94.
Syverson, P., Adding Time to a Logic of Authentication, in: Proceedings of the First ACM Conference on Computer and Communications Security (1993), pp. 97–101.
Syverson, P. and P. van Oorschot, On Unifying some Cryptographic Protocols, in: Proceedings of the IEEE Computer Society Symposium on Research in Security and Privacy (1994), pp. 14–28.
van der Meyden, R., Axioms for Knowledge and Time in Distributed Systems with Perfect Recall, in:
Proceedings of the Ninth IEEE Symposium on Logic in Computer Science, 1994, pp. 448–457.
Wolter, F. and M. Zakharyaschev, Temporalizing Description Logics, in: Frontiers of Combining Systems (1999), pp. 379–402.
Wolter, F. and M. Zakharyaschev, Axiomatizing the Monodic Fragment of First-Order Temporal Logic, Annals of Pure Applied Logic 118(1-2) (2002), pp. 133–145.
Wooldridge, M., C. Dixon and M. Fisher, A Tableau-Based Proof Method for Temporal Logics of Knowledge and Belief, Journal of Applied Non-Classical Logics 8(3) (1998), pp. 225–258.
