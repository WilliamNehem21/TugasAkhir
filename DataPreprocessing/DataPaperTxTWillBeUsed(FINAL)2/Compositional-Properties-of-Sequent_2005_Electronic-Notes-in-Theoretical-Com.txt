Electronic Notes in Theoretical Computer Science 118 (2005) 111–128 
www.elsevier.com/locate/entcs


Compositional Properties of Sequential Processes
Naijun Zhan
Lehrstuhl fu¨r Praktische Informatik II Facult¨at fu¨r Mathematik und Informatik Mannheim Universit¨at
D7,27, 68163 Mannheim, Deutschland Email: {zhan}@pi2.informatik.uni-mannheim.de

Abstract
It is widely agreed that the modular method is one of the most effective methods to specify and verify complex systems in order to avoid combinatorial explosion. FLC ( Fixpoint Logic with Chop) is an important modal logic because of its expressivity and logic properties, e.g., it is strictly more expressive than the µ-calculus. In this paper, we study the compositionality of FLC, namely, to investigate the connection between the connectives of the logic and the constructors of programs. To this end, we first extend FLC with a nondeterministic operator “+” (FLC+ for the extension) and then establish a correspondence between the logic and the basic process algebra with deadlock and
termination (abbreviated by BPAc ). Finally, we show that as a by-product of the correspondence
δ	c
characteristic formulae for processes of BPAδ up to strong (observational) bisimulation can be constructed compositionally directly from the syntax of processes.
Keywords: chop operator, modal logic, compositionality, verification, bisimulation, characteristic formula, process algebra

Introduction
There is a growing need for reliable methods in designing correct reactive systems [9] such as computer operating systems and air traffic control sys- tems. These systems are characterized by ongoing, typically nonterminating and highly nondeterministic behavior. Such systems are often used to model “safety critical systems” like, e.g., air traffic control systems, nuclear reaction control systems and so on. As any faulty behavior of such systems might im- ply catastrophical consequences, proving the correctness of such systems with


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.12.018


respect to the expected behavior is inevitable. There is a common agreement that formal methods, such as modal and temporal logics [17,24] and process algebra [3,10,19], are effective and reliable methods to design these systems.
Because the complexity of large systems is normally uncontrollable, it is necessary that a method for developing such systems is compositional (verti- cally or horizontally) in order to avoid combinatorial explosion in specifying and verifying them, e.g. [10,19,3,2,16,4,5,15]. The compositional method al- lows one to build up a large system by composing existing systems with the defined constructors and reduce the problem of correctness for a complex sys- tem to similar and simpler correctness problems for the subsystems.
FLC [18] is an extension of the µ-calculus [12] with the sequential com- position operator — “chop” (denoted by “;”). [18] pointed out that FLC is strictly more expressive than the µ-calculus because [6,11] proved that only “regular” properties can be defined in the µ-calculus, but characteristic for- mulae of context-free processes can be defined in FLC. [13,14] investigated the issue of FLC model checking.
The compositionality was stated in [8] as one important requirement that should also be satisfied by specification logic used in a process algebraic setting, that is, any program constructor cons corresponds to an operator cons of the logic such that
Pi |= φi for i = 1,... ,n implies cons(P1,... , Pn) |= cons(φ1,... , φn);
cons(P1,..., Pn) |= cons(φ1,..., φn) is the strongest assertion which can be deduced from Pi |= φi for i = 1,..., n.
It is clear that FLC does not meet the above conditions since P meets φ and Q satisfies ψ, but we can not get any property that holds in the combined system P + Q according to φ and ψ in FLC. In order to guarantee that a specification logic satisfies the above conditions, we have two alternatives: one is to show that for each constructor in process algebra, a corresponding connective can be defined in the logic. To our knowledge, until so far it is still an open problem if a suitable “+” is definable in classical modal logics; the other is directly to introduce a connective, which exactly corresponds to the constructor in process algebra, into the logic like, e.g., in [8,15] a non- deterministic choice “+” is introduced explicitly.
Besides, it is worth investigating the connection between the sequential composition of process algebra and the ‘chop’ operator of FLC, but it seems no people to do such a job up to now.
In this paper, we first extend FLC with a non-deterministic operator “+” (denoted by FLC+ ). Intuitively, P |= φ + ψ means that P consists of two parts P1 and P2, which are executed nondeterministically such that P1 |= φ


and P2 = ψ. Then we show that the operators +, ; and νX. in the logic relate to +,; and rec x in process algebraic settings such as the basic process algebra

with termination and deadlock (BPAє
for short) respectively. Thus, we can

claim that the logic is compositional.
What’s more, compositionality also makes many senses in practice for the following reasons:
It means one more step to the goal to exploit the structure of process terms for model checking.
It allows to give a precise and compact specification of certain nondeter- ministic systems.
It is very easy to modify the specification of a system when additional alternatives for the behavior of the system should be admitted.
It enhances the possibility of modularity in model checking which is useful in redesigning of systems.
i) depends on if it is possibly to work out a syntax-directed model checker for FLC+ . In fact, we believe that it may be done exploiting the connection between FLC+ and BPAє that is presented in this paper. To explain the issues ii), iii) and iv), we present the following example: Consider a car factory that wants to establish an assembly line shown in the Figure 1,

put_car
Fig. 1. The Process P


which we denote by the process P , for one production step. If there is a car available for P then P will either get the car, adjust the motor, mount the windscreen, control the car, and put the car on the conveyer band or P will get the car, mount the windscreen, adjust the motor, control the car, and put it back. Then P may start again. The first option can be specified by
Spec1 = [get car]; ⟨adjust⟩; ⟨mount windscreen⟩; ⟨control⟩; ⟨put car⟩
∧⟨get car⟩; true, whereas the second is described by

Spec2 = [get car]; ⟨mount windscreen⟩; ⟨adjust⟩; ⟨control⟩; ⟨put car⟩
∧⟨get car⟩; true.
We are now looking for a specification that admits only such systems that offer both alternatives and that can be easily constructed from Spec1 and Spec2. Obviously, Spec1 ∧Spec2 is not suitable whereas Spec1 ∨Spec2 allows for imple- mentations that exhibit only one of the behavior. Spec1 + Spec2 describes the behavior we have in mind and a system P that offers this behavior repeatedly is described by
Spec = νX.(Spec1 + Spec2); X.
It will be shown that rec x.(P1 + P2); x |= Spec in Example 4.9 in Section 4, where
P1 = get car; adjust; mount windscreen; control; put car P2 = get car; mount windscreen; adjust; control; put car.
Let us now assume that the system specification should be modified to allow for a third alternative behavior Spec3, then this specification may be simply “added” to form
Spec' = νX.(Spec1 + Spec2 + Spec3); X.
If we establish P3 |= Spec3 then we obtain immediately that
rec x.(P1 + P2 + P3); x |= Spec'.
In addition, if we have to modify Spec1 to Spec' such that P ' |= Spec' , and

obtain
1	1	1

rec x.(P ' + P2 + P3); x |= νX.(Spec' + Spec2 + Spec3); X.
The remainder of this paper is organized as follows: Some basic notions are briefly reviewed in Section 2; The syntax and semantics of FLC+ are defined in Section 3; Section 4 establishes a connection between the constructors of BPAє and the connectives of FLC+ ; In Section 5, an algorithm to construct a formula ΨP for eac√h process P ∈ BPAє according to its syntax is presented and
we show that ΨP ;	is the characteristic formula of P by the compositionality
of FLC+ ; Finally, a brief conclusion is provided in Section 6.

Preliminaries
Let Act be a finite set of (atomic) actions, ranged over by a, b, c,.. ., and be a countable set of process variables, ranged over by x, y, z, ....
Sequential process terms are those which do not involve parallelism and communication, which are generated by the following grammar:
E ::= δ | ϵ | x | a | E1; E2 | E1 + E2 | rec x.E


We denote the above language by Ps. Intuitively, we consider that the ele- ments of Ps represent programs; δ denotes a deadlocked process that cannot execute any action and stays there for ever; ϵ denotes a terminated process that can not proceed, but terminates at once; the other constructors can be conceived as usual ones.
In the presence of the sequential composition operator “;” it is common to use a special predicate  to evaluate the semantics of the sequential composi- tion operator “;”. Let   s be the least set which contains ϵ and is closed under the rules:
if T (E1) and T (E2) then T (E1; E2) and T (E1 + E2); and
if T (E) then T (rec x.E).
Convention: For the sake of simplicity, as a well-formedness condition, ex- pressions like E = E1 + E2 in which T (E1) and ¬T (E2) or ¬T (E1) and T (E2) are prohibited.
An occurrence of a variable x ∈ X is called free in an expression E iff it does not occur within any sub-term of the form rec x.E , otherwise called bound. We will use f n(E) to stand for all variables which have some free occurrence in E, and bn(E) for all bound variables which have some bound occurrence in E. A variable x	is called guarded within a term E iff every occurrence of x is within a sub-term F where F lies in a subexpression F ∗; F such that ¬T (F ∗). A term E is called guarded iff all variables occurring in it are guarded. The set of all closed and guarded terms of  essentially corresponds to basic process algebra (BPA) with the terminated process ϵ and the deadlocked process δ, denoted by BPAє , ranged over by P, Q,.  BPA is
a sub-fragment of ACP [3].
Example 2.1 The expressions a; x, a; (b + x), rec x.(a + b); x; (y + z), ϵ,δ are guarded whereas x, a + x are unguarded.
An operational semantics of Ps is given by the following inference rules:

E [rec.xE /x] →a E'
	

a → ϵ
rec x.E1 →√E'

Seq-1	E1 → E1
Seq-2	E2 → E2 and	(E1)

'
E ; E → E ; E
E ; E → E

Nd	E1 → E1

'
E1 + E2 →	and E2
+ E1 →	1

Definition 2.2 A binary relation S ⊆ BPAє × BPAє is called a strong bisim-
δ	δ
ulation if (P, Q) ∈ S implies

√(P ) iff √(Q); and

whenever P → a ∈ Act; and
whenever Q →
a ∈ Act.
P ' then, for some Q',Q →a

Q' then, for some P ',P →a
Q' and (P ', Q') ∈ S, for any
P ' and (P ', Q') ∈ S for any

Given two processes P, Q ∈ BPAє , we say P and Q are strongly bisimilar, written P ∼ Q, if (P, Q) ∈ S for some strong bisimulation S.
We can extend the definition of ∼ over Ps as: Let E1, E2 ∈ Ps, and
f n(E1)∪f n(E2) ⊆ {x1,... , xn}. If E1{P1/x1,... , Pn/xn}∼ E2{P1/x1,... , Pn/xn}
for any P1,... , Pn	BPA , then E1	E2.
[1] proved that the following proof system for BPAє is complete 1 :
A0	E1 + E2 = E2 + E1	 A1	 (E1 + E2)+ E3 = E1 + (E2 + E3) A2	E + E = E	A3	(E1 + E2); E3 = (E1; E3)+ (E2; E3)
A4	(E1; E2); E3 = E1; (E2; E3)	A5 rec x.E = E{rec x.E/x}
A6	E + δ = E	A7 δ; E = δ
A8	E; ϵ = E	A9 ϵ; E = E
Also in [1], the following lemma was shown.
Lemma 2.3 For any P ∈ BPAє , P ∼ Σ	Σia  a; Qa,j or P ∼ δ, where

Qa,j ∈ BPAє . Note that if for all a ∈ Act, ia < 1 then Σ
Σia
a; Qa,j

δ
will be abbreviated as ϵ.
a∈Act
j=1

Notations: From now on, we use A op B to stand for {E1 op E2 | E1 ∈
s	s	s
A and E2 ∈ B}, A op E for A op {E}, where E ∈ P , A ⊆ P , B ⊆ P , and
op ∈ {+, ; }.
FLC with Nondeterministic Operator “+” (FLC+ )
FLC is due to Markus Mu¨ller-Olm [18], which is an extension of the modal µ-calculus, can express non-regular properties. It is therefore strictly more expressive than the µ-calculus, since [6,11] proved that only regular properties can be defined in the µ-calculus. Here, we extend FLC with a nondeterministic operator “+”, which is similar to the one presented in [7,15], in order to define

1 The proof system for BPAє presented in this paper is a little different from the one in [1]. But [1] pointed out that the variant is still complete.


the composed property according to the ones for the two components which can be executed nondeterministically. Intuitively, P |= φ1 + φ2 means that P consists of P1 and P2 which are executed nondeterministically such that P1 satisfies φ1 and P2 meets φ2.

Syntax and Semantics
Let X, Y, Z,... range over an infinite set Var of variables, true and f alse be propositional constants as usual, and for another special propositional constant that is used to indicate if a process is terminated.
Formulae of FLC+ are generated by the following rules:
φ ::= true | f alse | √ | term | X | [a] | ⟨a⟩ | φ1 ∧ φ2 | φ1 ∨ φ2 |
φ1; φ2 | φ1 + φ2 | µX.φ | νX.φ
where X ∈ V ar and a ∈ Act.	√

In the sequel, we use a
σ for ν or µ.
to stand for ⟨a⟩ or [a], p for true, false or
, and

As in the modal µ-calculus, the two ﬁxpoint operators µX and νX bind the respective variable X and we will apply the usual terminology of free and bound occurrences of variables in a formula, closed and open formulae etc. We will use f n(φ) to stand for all variables which have some free occurrence in φ and bf (φ) for all variables that have some bound occurrence in φ. We

say that X is guarded in φ if each occurrence of X is preceded with a
via “;”. If all variables in φ are guarded, then φ is called guarded.
or p

Example 3.1 Formulae ⟨a⟩; X, νX.(⟨a⟩∨⟨b⟩); X; (Y +Z), false; X are guarded, but X, ⟨a⟩∧ X, µX.(X + Y ) ∨ [a] are not guarded.
As in [18], formulae are interpreted as a monotonic predicate transformer

which is simply a mapping f : 2BPAc
BPAc
which is monotonic w.r.t. the

inclusion ordering on 2BPAc . We use MPT
to represent all these monotonic

predicate transformers over BPAє . MPTT together with the inclusion ordering

defined by
f ⊆ f ' iff f (A) ⊆ f '(A) for all A⊆ BPAє

forms a complete lattice. We denote the join and meet operators by and . By Tarski-Knaster Theorem, the least and greatest fixed points of monotonic functions:
(2BPAc → 2BPAc ) → (2BPAc → 2BPAc )
exist. They are used to interpret the fixed point formulae of FLC+ .
The meaning of true and f alse are interpreted in the standard way, i.e. by BPAє and ∅ respectively. The meaning of	is to map any set of processes

to the subset of BPAє in which all terminated processes are contained. So, a
δ
process P meets	iff T (P ). term is interpreted as an identity. Because ϵ and
δ have different behavior in the presence of ;, they should be distinguished by FLC+ . To this end, [a] of FLC+ is interpreted as a function that maps any set of processes  to the set in which each process is not terminated and every a-successor of the process must be contained in . This is different from the meaning of [a] given in FLC. Therefore, according to our interpretation,
P |= [a] only if ¬T (P ). Whereas, P always meets [a] for any P ∈ BPAє
δ
in FLC. So, it is easy to show that ϵ does not satisfy	a∈Act[a]; f alse, while
 a∈Act[a]; f alse is the characteristic formula of δ. The meaning of variables is given by an environment ρ : var → (2BPAc → 2BPAc ) that assigns variables
to monotonic functions of sets to sets. ρ[X ~ f ] agrees with ρ except for associating f with X.
Definition 3.2 Given an environment ρ, the meaning of a formula φ, denoted by Cρ(φ), is inductively defined as follows:
Cρ(true)(A)= BPAδ
Cρ(f alse)(A)= ∅
δ

Cρ(term)(A)= A
Cρ(X)= ρ(X)
є



'	є	a	'	'

Cρ([a])(A)= {P ∈ BPAδ | ¬T (P ) ∧ ∀P ∈ BPAδ .P → P ⇒ P ∈ A}
є	'	є	a	'	'

Cρ(⟨a⟩)(A)= {P ∈ BPAδ | ∃P  ∈ BPAδ .P → P ∧ P
∈ A}


Cρ(φ1 ∧ φ2)(A)= Cρ(φ1)(A) ∩ Cρ(φ2)(A)
Cρ(φ1 ∨ φ2)(A)= Cρ(φ1)(A) ∪ Cρ(φ2)(A)
Cρ(φ1; φ2)= Cρ(φ1) · Cρ(φ2)
Cρ(φ1 + φ2)(A)= {P ∈ BPAδ | ∃P1, P2 ∈ BPAδ .P ∼ P1 + P2 ∧
P1 ∈ Cρ(φ1)(A) ∧ P2 ∈ Cρ(φ2)(A)}
Cρ(µX.φ)= H{f ∈ MPTT | Cρ[X~ƒ](φ) ⊆ f } Cρ(νX.φ)= H{f ∈ MPTT | Cρ[X~ƒ](φ) ⊇ f }
where A⊆ BPAє , and · stands for the compositional operator over functions. As the meaning of a closed formula φ is independent of any environment,
we sometimes write C(φ) for Cρ(φ), where ρ is an arbitrary environment. We
also abuse φ(A) to stand for Cρ(φ)( ) if ρ is clear from the context.
The set of processes satisfying a given closed formula φ is φ(BPAє ). A process P is said to satisfy φ iff P ∈ Cρ(φ)(BPAє ) for some environment ρ, denoted by P |=ρ φ. If ρ is clear from the context, we directly write P |= φ.


φ ⇒ ψ means that Cρ(φ)(A) ⊆ Cρ(ψ)(A) for any A ⊂ BPAє and any ρ. φ ⇔ ψ means (φ ⇒ ψ) ∧ (ψ ⇒ φ). The other notations can be defined in a standard way.
Given a formula φ, the set of sub-formulae at the end of φ, denoted by ESub(φ), is: {φ} if φ = p, term, X or ◯a ; ESub(φ1) ∪ ESub(φ2) if φ = φ1 op φ2 where op ∈ {∧, ∨, +}; if φ = φ1; φ2 then if τ /∈ ESub(φ2) then ESub(φ2)
√else (ESub(φ2) − {τ }) ∪ ESub(φ1); ESub(φ') if√φ = σX.φ'. When we say that
only occurs at the end of φ it means that	only can be in ESub(φ) as a
sub-formula of φ.
Convention: In the sequel, we assume the binding precedence among the operators of the logic as follows: “νX” = “µX” > “; ” > “+” > “ ∨ ” = “ ∧ ” > “ ⇒ ”= “ ⇔ ”.


Some Theorems for FLC+
In this subsection, we prove some theorems for FLC+ which will be used in the later.
In fact, we can prove that all properties on FLC shown in [18] are still true for FLC+ , e.g., FLC+ is strictly more expressive than the µ-calculus, FLC+ is decidable for finite-state processes and undecidable for context-free processes and so on.
Besides, we can show that FLC+ has the tree model property, viz
Theorem 3.3 Given P, Q ∈ BPAє , and P ∼ Q, then for any closed formula
φ of FLC+ , P |= φ iff Q |= φ.
Definition 3.4 We define a subclass of FLC+ , denoted by N , as follows:
φ ::= p |◯a | φ ∧ φ | φ + φ |◯a ; ψ
where a ∈ Act, ψ ∈ FLC+ .

By the definition of the semantics of FLC+ , φ; true ⇒ ψ; true means that for any process P and environment ρ, P |=ρ φ implies P |=ρ ψ. For convenience, we abbreviate φ; true ⇒ ψ; true by φ → ψ, and φ; true ⇔ ψ; true by φ ↔ ψ.
The following theorem indicates the relationships among the propositional letters, connectives of FLC+ .


Theorem 3.5
N1 term; φ ⇔ φ; term ⇔ φ	P1 p; φ ⇔ p
P2 φ + f alse ⇔ f alse	P3 p + p ⇔ p
P4 ⟨a⟩; f alse ⇔ f alse	T1 √ ∨ [a]; true ⇔ true
T2 √ ∧ [a]; true ⇔ f alse	S1 φ + ψ ⇔ ψ + φ
S2 (φ + ψ)+ ϕ ⇔ φ + (ψ + ϕ)	S3 φ + φ ↔ φ if φ ∈ N 
SI φ + (ψ ∧ ϕ) ⇒ (φ + ψ) ∧ (φ + ϕ) SD φ + (ψ ∨ ϕ) ⇔ (φ + ψ) ∨ (φ + ϕ) SC (φ + ψ); ϕ ⇔ (φ; ϕ)+ (ψ; ϕ)	C1 φ; ψ → φ
C2 (φ; ψ); ϕ ⇔ φ; (ψ; ϕ)	IC (φ ∧ ψ); ϕ ⇔ (φ; ϕ) ∧ (ψ; ϕ)
DC (φ ∨ ψ); ϕ ⇔ (φ; ϕ) ∨ (ψ; ϕ)	SD [a]; φ1 + [a]; φ2 ↔ [a]; (φ1 ∨ φ2) The following theorem says that “;” and “+” both are monotonic.
Theorem 3.6 (i) If φ ⇒ ψ then φ; ϕ ⇒ ψ; ϕ and ϕ; φ ⇒ ϕ; ψ; and
(ii) If φ1 ⇒ φ2 and ψ1 ⇒ ψ2 then φ1 + ψ1 ⇒ φ2 + ψ2.
By extending the tableau based model checker for FLC given in [13] with a rule for “+”, namely

(+)		(E , F) ▶ φ1 + φ2	
E = E + E

(E1, F) ▶ φ1 (E2, F) ▶ φ2
where	, 1, 2,	BPAє , we can get a model checker for FLC+ , whose complexity is same as the one of the model-checker of FLC presented in [13].
Correspondence between FLC+ and BPAϵ
In this section, we discuss how to derive composite properties for a sequential process from those of its components.
Nondeterminism
It is clear that the connection between “+” of BPAє and “+” of FLC+ can be
expressed as follows:
Theorem 4.1 (i) For any P, Q ∈ BPAє , if P |= φ and Q |= ψ then P + Q |=
φ + ψ;
(ii) For any R ∈ BPAє , if R |= φ + ψ then there exist P, Q ∈ BPAє such that
δ	δ
R ∼ P + Q, P |= φ and Q |= ψ.

Sequential Composition
In this subsection, we show that the sequential composition of process algebra can be characterized by the chop operator.
Normally, P = φ and Q = ψ, but P ; Q = φ; ψ because possibly φ only describes some partial executions of P . For example, let P = a; b, Q = c; d. It’s obvious that P = a and Q = c , but P ; Q = a ; c . So, we require that the property of the first operand of ; must specify full executions of the corresponding process, that is, P = φ; . This is similar to the premise of the rule Seq-2 that only after the first segment P of ; finishes the executing, then the second one can be performed.
Another issue is that by the definition of the semantics of  s, ϵ; P
P . Therefore, the properties concerning intermediate terminations should be omitted in the resulting formula. Otherwise, the composed property does not hold in the combined system. E.g., l√et P = a; ϵ and Q = b; δ, φ = ⟨a⟩;  , and
ψ = ⟨b⟩. It’√s obvious that P |= φ;	and Q |= ψ but P ; Q |= φ; ψ. So, we
will replace	occurring in φ with term since term is a neutral element of the
chop. This is in accordance with that ϵ is a neutral element of the sequential composition “;” (See the axioms A8 and A9).
Be√sides, since φ{term/√}; ψ will be as a specification of P ; Q, it is possible
that	as a sub-formula of φ makes the sub-formulae of φ followed it by ;
no sense during calculating the meaning of φ by P1, but the sub-formulae play√a nontrivial role during calculating the meaning of φ{term/  }; ψ. E.g.
ϵ |=	; [a]; ⟨b⟩ an√d a; c |= ⟨a⟩; ⟨c⟩, but ϵ; (a; c) |= (term; [a]; ⟨b⟩); (⟨a⟩; ⟨c⟩). So,
such a requirement is reasonable because all formulae can be transform to such kind of the form equivalently by Theorem 3.5.
In a word, we have the following theorem on the sequential composition “;”:
Theorem 4.2 If √ only occurs a√t the end of φ as a sub-formula, P |= φ; √
and Q |= ψ then P ; Q |= φ{term/  }; ψ.
Remark 4.3 Generally speaking, the converse of Theorem 4.2 is not valid,
e.g. (a; b; c + a)√; (c; d) |= ⟨a⟩; (⟨b⟩; ⟨c⟩; ⟨c⟩), but we can not conclude that
a; b; c + a |= ⟨a⟩;	and c; d |= ⟨b⟩; ⟨c⟩; ⟨c⟩.

Recursion
In this subsection, we will study how to relate rec x to νX. So, in this subsection, all fixed point operators occurring in formulae will refer to ν if no otherwise stated. To this end, we firstly define a relation called syntactical

confirmation between processes and formulae, with the type Ps × F LC+ '→
{true, false}, denoted by |=sc.
Definition 4.4 Given a formula φ, we associate a map from 2Ps to 2Ps with it, denoted by φ^, constructed by the following rules:
√^ (E) =^ {E | E ∈ Ps ∧T (E)}
tˆrue(E ) =^ Ps f^alse(E ) =^ ∅ t^erm(E ) =^ E
X^ (E) =^ {x; E | E ∈ E}
⟨^a⟩(E ) =^ {E | ∃E' ∈ E .E →a E'}

[^a](E ) =^ {E | ¬T (E) ∧ E is guarded ∧ ∀E'.E →a
φ^∧ φ (E) =^ φ^ (E) ∩ φ^ (E)
E' ⇒ E' ∈ E}

φ^∨ φ (E) =^ φ^ (E) ∪ φ^ (E)

φ^+ φ (E) =^ {E | ∃E ,E .E = E
+ E ∧ E
∈ φ^ (E) ∧ E
∈ φ^ (E)}

φ^; φ (E) =^ φ^ · φ^ (E)
σ^X.φ(E ) = {(rec x.E1); E2 | E1 ∈ φ^({ϵ}) ∧ E2 ∈ E}
where E ⊆ Ps.
|=sc (E, φ) = true iff E ∈ φ({ϵ}); otherwise, |=sc (E, φ) = false. Here- inafter, we denote |=sc (E, φ) = true by E |=sc φ and |=sc (E, φ) = false by E |=sc φ.
Informally, P |=sc φ means that P and φ have a similar syntax, e.g.
rec x.[(a; x; x; b)+ c] |=sc νX.[(⟨a⟩; X; X; ⟨b⟩) ∧ ⟨c⟩].
The following theorem states that |=sc itself is compositional too.
Theorem 4.5 Let √ only appear at the end of φ1, φ2 and φ as a sub-formula. Then,
if E1 |=sc φ1 and E2 |=sc φ2 then E1 + E2 |=sc φ1 + φ2; √

if E1 |=sc φ1 and E2 |=sc φ2 then E1; E2 |=sc φ1{term/
if E |=sc φ then rec x.E |=sc σX.φ{term/  }.
}; φ2;

Example 4.6 Let E1=(a; x; x)+ d, E2=x; (b + c); y, E3=a; b; c, φ=⟨a⟩; X; X, ψ=X; ⟨b⟩; Y and ϕ=[a]; ⟨b⟩; ⟨c⟩. It’s obvious that E1 |=sc φ, E2 |=sc ψ, E3 |=sc ϕ, E1 + E3 |=sc φ + ψ, E3; (E1 + E3) |=sc ϕ; (φ + ψ) and rec x. rec y.E3; (E1 + E3) |=sc νX.νY.(ϕ; (φ + ψ)) by Definition 4.4.


The following lemma indicates that replacing =sc with =, the relation between processes and formulae is preserved by substitution, i.e.,
Lemma 4.7 √Let f n(E√) ⊆ {x1,..., xn}, f n(ψ) ⊆ {X1,..., Xn} . If E |=sc ψ

and Pi = φi;
ψ, then
where
does not occur neither in φi for i ∈ {1,... , n} nor in

E{P1/x1,... , Pn/Xn} |= ψ{φ1/X1,..., φn/Xn}; √.
Theorem 4.8 establishes a connection between =sc and =, so that we can relate rec x to νX. For instance, in the above example, we get
rec x. rec y.E3; (E1 + E3) |= νX.νY.(ϕ; (φ + ψ)).
Theore√m 4.8 If P ∈ BPAє , √ only occurs at the end of φ and P |=sc φ, then
P |= φ;	.
In order to demonstrate how to apply the compositionality of FLC+ to simplify the verification of reactive systems, we continue the example of a car factory given in Section 1.
Example 4.9 In the example, by Definition 4.4, it is easy to show that P1 |=sc
Spec1 and P2 |=sc Spec2. Therefore, we have
rec x.(P1 + P2); x |=sc νX.(Spec1 + Spec2); X
by Theorem 4.5. Furthermore, it follows that
rec x.(P1 + P2); x |= νX.(Spec1 + Spec2); X
by Theorem 4.8. That is,
P |= Spec.

Constructing Characteristic Formulae of Sequential Processes
Given an equivalence or preorder ≤ over processes, the characteristic formula for a process P up to ≤ is a formula φP such that given a process Q, Q |= φP if and only if Q ≤ P . Characteristic formulae can be used to relate equational reasoning about processes to reasoning in a modal logic, and therefore to allow proofs about processes to be carried out in a logical framework. [7] proposed an approach to deriving the characteristic formula of a finite CCS-term up to strong bisimulation and observational congruence by defining a translation function from finite CCS-terms to formulae of a modal logic. [23] proposed a method to define characteristic formulae for preorders from the transition graphs of finite-state processes, and applied their approach to finite-state CCS- terms up to strong (weak) bisimulation. [18] gave a method to derive the


characteristic formula of a process in BPA up to some preorder by solving equation systems induced by the semantics of the process ( the rewrite system of the process). In this section, we present an algorithm to construct the characteristic formula of a process in BPAє up to strong bisimulation directly from its syntax in a compositional manner based on the above results.
It is easy to sho√w that  a∈Act[a]; f alse (Φδ for short) is the characteristic
formula for δ, and	for ϵ.


on.
For convenience,  a∈Act−A[a]; f alse will be abbreviated by Φ−A from now

Definition 5.1 Given a process term E ∈ Ps, we associate with it a formula denoted by ΨE derived by the following rules:
Ψ = Φ
Ψє =^ √
Ψx =^ X
Ψa =^ Φ−{a} ∧ (⟨a⟩√∧ [a])

ΨE1;E2 =^ ΨE1 {term/
ΨE1+E2 =^ ΨE1 + ΨE2
}; ΨE2
√

Ψrec x.E =^ νX.ΨE{term/  }
Regarding ΨE, we have
Lemma 5.2 For any E	s, √ only occurs at the end of ΨE as a sub- formula.
Lemma 5.3 For any E ∈ Ps, E |=sc ΨE and E |=sc ΨE; √.
The rest of this section is devoted to prove that ΨP ; √ is the characteristic formula of P up to ∼ for each P ∈ BPAє .
The following lemma says that the proof system for BPA (See Section 2)
will be valid in FLC+ if P is substituted by ΨP ; √
δ
and = by ⇔. That is,
Lemma 5.4
A0 ΨE1+E2 ; √ ⇔ ΨE2 +E1 ; √	A1 Ψ(E1+E2 )+E3 ; √ ⇔ ΨE1+(E2 +E3); √ A2 ΨE+E ; √ ⇔ ΨE ; √	A3 Ψ(E1+E2 );E3 ; √ ⇔ Ψ(E1;E3)+(E2 ;E3); √ A4 Ψ(E1 ;E2);E3 ; √ ⇔ ΨE1;(E2;E3); √ A5 Ψrec x.E ; √ ⇔ ΨE{rec x.E/x}; √
A6 ΨE+δ; √ ⇔ ΨE; √	A7 Ψδ;E; √ ⇔ Ψδ; √ ⇔ Ψδ
A8 ΨE;є; √ ⇔ ΨE; √	A9 Ψє;E; √ ⇔ ΨE; √


By the above lemma and the fact that the proof system for BPAє is com-
plete [1], it is easy to show the following theorem:
Theorem 5.5 (Completeness) If E1 ∼ E2, then ΨE1 ⇔ ΨE2 .
The following lemma plays a key role in the proof for Theorem 5.7.
Lemma 5.6 For any P ∈ BPAє , if ¬T (P ) and there exists no P ' such that

P →a P '
δ
then ΨP ⇒ [a]; f alse.

Theorem 5.7 For any P ∈ BPAє , ΨP ; √ is the characteristic formula of P.
Remark 5.8 In Theorem 5.7, the condition P is guarded is essential. Other- wise, the theorem is not true any more because Lemma 5.6 will not be valid without the condition. For instance, νX.(X + (⟨a⟩∧ [a] ∧ Φ−√{a} )) is equivalent
to Ψrec x.(x+a), nevertheless, (νX.(X + (⟨a⟩∧ [a] ∧ Φ−{a})));	is not the char-
acteristic formula of rec x.(x + a), since rec x.(x + b + a) meets the formula
as well, but rec x.(x + b + a) /∼ rec x.(x + a).
Example 5.9 Let P =^ a; ϵ and Q=^ b; δ. Then,

ΨQ = (⟨b⟩∧ [b] ∧ Φ−{b}); Φδ by Definition 5.1.
It’s obvious that ΨP ; √ is the characteristic formula of P and ΨQ; √ is the
one of Q. Furthermore, by Definition 5.1,
Ψrec x.(P ;x;x;Q+P ); √


=^ νX. 
(⟨a⟩∧ [a] ∧ Φ−{a}); X; X; ((⟨b⟩∧ [b] ∧ Φ−{b}); Φδ)   √
+ (⟨a⟩∧ [a] ∧ Φ−{a})

which is exactly the characteristic formula of rec x.(a; x; x; b; δ + a; ϵ).

Related Work and Concluding Remarks
Since modular method plays a key role in developing large systems, many efforts have been done on this topic. For example, [20] investigated such topic from a logic point of view, i.e. specification and implementation of a system both are represented as a formula. While [10,19,3] studied the topic from an algebraic point of view, that is, specification and implementation of a system are represented as a process, and the relation between the specification and the implementation is described by several kinds of equivalences on processes. The advantage of logics lies in abstractness, but it is not easy to implement. In contrast to logics, it is easy to implement a process algebra, even, a process


algebra itself can be looked as a programming language like, e.g. [10], but it lacks of abstractness. Although the established equivalences make process algebra itself to be used as a specification language, it is not ideal candidate as argued in [15]. Therefore, an appropriate method to develop a large system is to use a logic as a specification language and a process algebra as a modeling language.
[4,5] studied the compositionality of a choppy logic [22], which is an ex- tension of classic propositional temporal logic [21] (PTL for short) by intro- ducing a chop operator. [15] defined a modal process logic which has com- positionality. But the logic can only express regular properties of processes.
[18] extended the µ-calculus with the chop operator (FLC), which can define non-regular properties, and therefore is strictly more expressive than the µ- calculus. [13,14] discussed the model-checking problem of FLC. Nevertheless, FLC has no compositionality, e.g., Q |= νX.[a]; ⟨b⟩; X; X; ⟨c⟩∧⟨d⟩ (φ for short) and P = νX.[a]; c ; X; X; c  d (ψ for short), but it is difficult to find a formula constructed based on φ and ψ which is satisfied by P + Q. In order

to establish a connection between BPAє
and FLC, we introduce a nondeter-

ministic operator “+” into FLC. So, FLC+ has compositionality. E.g. in the above example, we will see that P + Q |= φ + ψ.
In order to derive invariant properties of recursive processes based on the properties of the subsystems, we define a notion named “syntactical confirma- tion”, denoted by |=sc, between BPAє and FLC+ and show that |=sc itself is compositional too and if P =sc φ, then P = φ, where all fixed point operators occurring in φ only refer to the greatest one.
A by-product of the compositionality of FLC+ is that we present an algo- rithm to construct the characteristic formula of each process of BPAє directly according to its syntax in contrast to that [18] derives the characteristic for- mula for a process by solving the equation system induced by the semantics of the process (the rewrite system of the process).
In this paper, we do not consider the compositionality for parallel operator “|”.
Besides, if we re-interpret the modalities ⟨a⟩ and [a], characteristic formulae of observable equivalence can also be constructed compositionally in the logic.


Acknowledgement
Special thanks are due to Prof. Mila Majster-Cederbaum for her supervision and many fruitful discussions on the topic related to this paper. The author also thanks the anonymous referees for their useful comments on this paper.

References
L. Aceto and M. Hennessy. Termination, deadlock, and divergence. Journal of ACM, Vol. 39, No.1: 147-187. January, 1992.
L. Aceto and M. Hennessy. Towards action-refinement in process algebra. Information and Computation, 103:204-269. 1993.
J.A. Bergstra and J.W. Klop.  Algebra of communication processes with abstraction.
Theoretical Computer Science, 37:77-121. 1985.
H. Barringer, R. Kuiper, A. Pnueli. Now you may compose temporal logic specifications. In Proc. 16th STOC, pp. 51-63. 1984.
H. Barringer, R. Kuiper, A. Pnueli. A compositional temporal approach to a CSP-like language. In Proc. IFIP conference, The Role of Abstract Models in Information Processing, pp. 207-227. 1985.
E.A. Emerson and C.S. Jutla. Tree automata, µ-calculus, and determinacy. In proc. 33rd IEEE Symp. on Found. of Comp. Sci., 1991.
S. Graf and J. Sifakis. A modal characterization of observational congruence on finite terms of CCS. Information and Control, 68:125-145. 1986.
S. Graf and J. Sifakis. A logic for the description of non-deterministic programs and their properties. Information and Control, 68:254-270. 1986.
D. Harel and A. Pnueli. On the development of reactive systems. In K.R. Apt, editor, Logics and Models of Concurrent Systems, volume 13 of NATO, ASI Series, pp. 447-498. Springer- Verlag, 1985.
C.A.R. Hoare.  Communicating Sequential Processes.  Prentice-Hall, 1985.
D. Janin and I. Walukiewicz. On the expressive completeness of the propositional µ-calculus with respect to monadic second order logic. CONCUR’96, LNCS 1119, pp.263-277. Springer- Verlag, 1996.
D. Kozen.  Results on the propositional mu-calculus.  Theoretical Computer Science, 27:333-
354. 1983.
M. Lange and C. Stirling. Model checking fixed point logic with chop. FOSSACS’02, LNCS 2303, pp. 250-263. 2002.
M. Lange. Local model checking games for fixed point logic with chop. CONCUR’02, LNCS 2421, pp. 240-254. 2002.
K.G. Larsen and B. Thomsen. A modal process logic. In the proc. of LICS’88, pp.203-210. IEEE Computer Science Society, 1988.
M. Majster-Cederbaum and F. Salger. Towards the hierarchical verification of reactive systems. To appear in Theoretical Computer Science.
Z. Manna and A. Pnueli.	The Temporal Logic of Reactive and Concurrent Systems:Specification. Springer-Verlag, 1992.
M. Mu¨ller-Olm. A modal fixpoint logic with chop, STACS’99, LNCS 1563, pp.510-520. 1999.
R. Milner. Communication and Concurrency. Prentice Hall, 1989.
B. Moszkowski. Executing Temporal Logic Programs. Cambridge University Press, Cambridge, 1986.
A. Pnueli. The temporal logic of programs. In the proc. of 18th STOC, pp:232-239. 1977.
R. Rosner and A. Pnueli. A choppy logic. In the proc. of LICS’86, pp.306-313. IEEE Computer Science Society, 1986.


B. Steffen, A. Ing´olfsdo´ttir.	Characteristic formulae for processes with divergence,
Information and Computation, 110:149-163. 1994.
C. Stirling. Modal and Temporal Logics for Processes. Springer-Verlag, 2001.
