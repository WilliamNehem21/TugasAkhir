Electronic Notes in Theoretical Computer Science 111 (2005) 27–52  
www.elsevier.com/locate/entcs


Architectural Unit Testing

Giuseppe Scollo and Silvia Zecchini1 ,2
Department of Computer Science University of Verona
Verona, Italy


Abstract
A formal testing methodology is outlined in this paper, that proves applicable to validation of architectural units in object-oriented models, and its use is illustrated in the context of the design of a robot teleoperation architecture. Automated generation of test cases to validate the functionality of the robot trajectory generation unit showcases the key features of this methodology. A disciplined use of UML state diagrams, to model the unit’s dynamics consistently with its static properties as modeled by class diagrams, enables one to provide such models with Input/Output Labelled Transition Systems (IOLTS) semantics, whence a rich machinery of testing theories and tools based on those theories become readily available. Our case study tells that, besides black-box testing of final implementation units, white-box analysis of architectural units may greatly benefit from the flexibility of parameterized I/O-conformance relations. Test purposes turn out to be a useful methodological link between functional requirements, which they are drawn from, and conformance relations, which they help one to instantiate, thereby delimiting test selection to purposeful tests. Contingent aspects of our methodology include: a mechanical translation of state diagrams in Basic LOTOS, a non-mechanical, use-case driven synthesis of test purposes, expressed in the same language, and the use of the TGV tool for automated test case generation. Other choices in these respects are well possible, without affecting the characteristic traits of the proposed methodology, that are rather to be found in: 1) the combination of object-oriented architectural modeling with IOLTS semantics; 2) the aim at maximizing the potential for test generation from UML models, in a broad view of testing which applies throughout the development process; 3) the specific proposal to consider internal actions as testable actions, in view of a better coordination between testing (discovery of faults) and debugging (discovery of internal sources of faults).
Keywords: formal testing methods, white-box testing, test purpose, test selection, automated test case generation.



1 Email: giuseppe.scollo@univr.it
2 Email: silvia.zecchini@univr.it



1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.12.006

Introduction

The analysis, design and construction of a complex system can be made con- ceptually more tractable if one describes the software architecture by a formal specification [21]. A specification of such type enables engineers and designers to check which components’ functionalities, described in the system require- ments, are satisfied and to verify the intended interactions of those compo- nents. The formal specification of a software architecture provides a solid foundation for developing architecture-based testing techniques [22].
The testing of architectural abstractions allows one to detect defects in the initial phases of the software lifecycle, rather than after implementation or during system integration, as is common practice, and thus to prevent their propagation through the subsequent phases.
In very complex software systems, the amount of information in the sys- tem implementation is, typically, more than a single person could understand. A common way to deal with these systems is by using a model of the sys- tem. The availability of a model derives, obviously, from the application to realize. Clearly, in a model we must include all the relevant information for our purpose, but we must pay attention to exclude the information that is not necessary. Indeed, a model with too much information may be difficult to comprehend. The name “model-based testing ” is a general term used to refer to an approach that bases testing activities, such as test case generation and evaluation, on models of the application under test [6,1,4].
Object-oriented models have found in the Unified Modeling Language (UML) [20] a standard notation, supported by a wide variety of model de- velopment tools. This enables one to model design concerns, requirements as well as decisions, at different abstraction levels, or perspectives [3], ranging from the conceptual modeling perspective through a more prescriptive spec- iﬁcation perspective, down to concrete implementation perspective. Clearly, all of these prove useful, albeit in different phases of the software develop- ment process, but we argue that there’s even room in between. Of particular interest to this paper is an architectural perspective, which is more prescrip- tive than conceptual modeling in that it fixes design decisions of architectural relevance such as naming of components (packages, classes) and connectors (associations, operations, inheritance relations), as well as ordering of inter- actions between objects, yet not so complete in its prescriptive character as a specification perspective would be.
In the next section we characterize with some more precision the level of formal detail which is adopted in the architectural perspective taken in the subject case study. For the time being we just point out that several types of


UML diagrams prove useful to express architectural requirements of various kind, e.g. package diagrams to partition an architecture into separate layers, class diagrams to represent static structure requirements, interaction and/or state diagrams to highlight dynamic properties of the architecture envisaged and of components or connectors thereof, etc.
One may wonder what sort of relevance or meaning should be ascribed to testing in an architectural modeling perspective. Since this applies at an early design stage, there’s no such a thing as an “implementation under test” to talk about, unless the architectural model would be usable for some kind of prototype generation—a more frequent situation with constructive speciﬁca- tion models though. Now, traditional views of testing, such as the so-called V-model [23], assign different testing scopes (system, integration, unit) to dif- ferent phases of software development, and in particular defer unit testing to the coding phase. On the contrary, we believe that all testing scopes are of relevance to each phase, but under different testing perspectives. Architectural testing thus is testing of architectural requirements; this may be understood either as analysis and verification of architectural models, e.g. to test whether they comply with given user requirements, or as an early stage in the design of testers which are to be employed at later development phases, viz. their modeling in an architectural perspective.
Architectural unit testing is thus, in the first sense, testing of architectural units against functional requirements, while in the second sense it means ar- chitectural modeling of unit testing code. This activity need not wait for the coding phase to start, insofar as theory and tools are available to assist it on the basis of early available architectural models. Furthermore, a clever combination of architectural unit testing in both senses provides one with a kind of validation of functional requirements, in that in the first sense it maps them to architectural unit models, which are just early abstractions of unit specifications, and then in the second sense it enables designers to see whether those models give rise to sensible unit testing schemes for those requirements, whose testability is thereby assessed. In both cases, architectural unit testing is viewed as relative to given functional requirements here; this will be aided by translating each requirement into a suitable test purpose for a given ar- chitectural unit, that will drive test selection and test case generation for the given requirement and architectural unit.
UML models most relevant to architectural unit testing are: class dia- grams, for static requirements, such as the input alphabet of each unit (we take operation names as atomic constituents of an object’s input alphabet, as it will be explained in the next section), and state diagrams for dynamic re- quirements, i.e. those which apply to the object’s behaviour and constrain its


interaction capabilities with its environment. A disciplined use of UML state diagrams, to model the unit’s dynamics consistently with its required static properties, will be the starting point of our methodology for architectural unit testing.

Test methodology
The architectural perspective adopted in the subject case study takes the form of a few style prescriptions with respect to the form and level of detail put in UML models.

Architectural class diagrams
Static structure is conveyed by class diagrams, where each class element ac- tually is a partial description of a class interface; more precisely, it consists of a class name and a list of operation names with no parameters. Relations be- tween elements are the standard ones as in UML class diagrams. A refinement of an architectural class diagram to turn it into the specification perspective would have to complete the interface signatures, that is to say, to add any other required operation not included in the architectural perspective, and to define parameters and return types for all operations. Moreover, further relations as well as attributes may be added by specification refinements.

Architectural state diagrams
Dynamic requirements on architectural units are modelled by UML state di- agrams, under a few assumptions and style prescriptions. We assume each state diagram refers to the behaviour of a generic instance of the architectural unit, which is a class belonging to (only) one architectural class diagram. The I/O alphabet of such an object is defined by:
inputs: the operation names defined on the instance by its class, including inherited operation names;
outputs: the operation names (defined in any class element of any class di- agram of the architectural model) which occur as actions in transition labels of the state diagram.
Simple states have parsimonious, minimal descriptions in the diagrams of present concern, that is, just an optional name, obviously absent for pseu- dostates; only initial and final pseudostates are admitted here. Richer de- scriptions are only available for composite, nonconcurrent states, in the form of a state diagram over the substates of the (named) composite state; named substates may be simple as well as composite themselves, recursively.


We recall that the syntax of transition labels of UML state diagrams con- sists of a triple event guard / action, where each of the three components may be absent 3 . Our style prescriptions so far amount to only use input operation names as events, whereas actions are output operation names. Furthermore, a limited form of guard is admitted, written [bCond], where bCond is just a literal for a boolean condition (thus a possibly negated name).
Other prescriptions for architectural state diagrams are defined as follows, only motivated by the wish to translate them into Basic LOTOS, which fea- tures a fairly limited expressiveness, and to do so in a straightforward manner:
the state diagram has an initial (pseudo)state;
every transition label consists of at most one of the three components al- lowed by UML syntax, viz. event, guard, action, which respectively corre- spond to input, internal action and output;
anonymous states are made use of as intermediate states when conventional UML transitions with multiple-component labels are splitted into sequences of single-component labelled transitions, in order to satisfy the previous prescription;
there are no cycles in the state diagram that only cross anonymous states;
a limited form of guard conditions is adopted, in that such a condition is just a literal for a boolean condition, as just explained;
the initial transition edge (viz. that from initial state to default state) has empty label (no action thus), both at top-level and within any composite state, at any nesting depth;
incoming edges to the final state have empty label, both at top-level and within any composite state, at any nesting depth.
The main motivation for the following style constraints comes from good design practices. For example, transitions should be preserved by abstraction of a composite state to a simple state as well as by refinement of the latter to the former. This motivates the following restriction:
all edges that enter or leave a composite state must have their ending at the composite state contour, rather than at some inner state.
The following simple example, although deprived of explanations, should look familiar to most readers. The example aims at illustrating the method- ological significance of the aforementioned restriction, as well as the use of the previously stated prescriptions—those which were rather motivated by ease of translation into Basic LOTOS.

3 The slash is only present if the action component is present.


[not satisfiableRequest]


Fig. 1. A cash dispenser service
A basic state diagram of a cash dispenser service is depicted in Figure 1.
The state diagram in Figure 2 refines it in two respects:
a more detailed description of state Check: state reﬁnement takes place in the cleanest manner, in that by simply ignoring the composite state structure one gets back the abstract state, with no need to redirect edges.
a more detailed account of the internal processing that follows a suc- cessful completion of the Check: the action reﬁnement illustrated in this case enables one to identify and reason about potential sources of mis- behaviour of the service, e.g. if balance update and cash withdrawal are not implemented as an atomic action.

Fig. 2. A refined cash dispenser state diagram
For the transitions specified by edges that enter or leave a composite state, the aforementioned restriction implies that 4

4 Consistently with the UML 1.5 standard conventions w.r.t. transitions from/to the initial and final pseudostates of composite states, whereby 1) the transition from the initial state of a composite state must be unlabelled and represents any transition to the enclosing state (this initial transition may have an action, though), and 2) a transition to a final state represents the completion of activity in the enclosing state, which is exited thus—the unlabelled outgoing transition from the composite state contour represents the transition from its inner final state. Also recall that final states have no outgoing edges and initial


incoming transitions always lead to the initial state of the composite state,
unlabelled outgoing transitions always come from the final state of the composite state,
every labelled outgoing transition is to be allowed from all of the inner states of the composite state, excluding the initial and final (pseudo)states.
Finally, we assume there are no incoming edges to a state if, and only if, this is an initial state, be it the top-level initial state or the initial state of a composite state.

Semantics of architectural state diagrams
UML state diagrams under the aforementioned style restrictions have a straight- forward interpretation as I/O Labelled Transition Systems (IOLTS), where the key fact consists in seriously taking the classic OO view of message exchanges between objects as operation invocations. A distinct benefit of this view is that it helps one to retain traceability of requirements throughout the design process, insofar as high-level interactions, which are basic building blocks of requirement specification, can be traced through the operation invocations which make up them in design and test specification. On the basis of this cor- respondence, the tracing of functional requirements onto corresponding test cases in the test suite should prove easier to maintain.
The following, standard definition will then take a distinct pragmatic flavour, once the use of (a set of) internal actions in this context will be made clear.
Definition 2.1 [IOLTS]
An IOLTS (Input-Output Labelled Transition System) is an LTS

M = (QM , AM , →M , qM
) where QM is the set of states, qM
is the initial state,

→M ⊆ QM × AM × QM is the transition relation and AM = AM ∪ AM ∪ IM ,
I	O
where AM and AM are respectively the input and output alphabet, while IM
I	O
are the internal or unobservable actions, all three alphabets being pairwise
disjoint.
Unobservable actions evidently occur in UML state diagrams whenever all three components of a transition label are absent. Should this be the only case for internal actions, then a singleton for the internal action alphabet IM would do the job, as it happens in traditional Labelled Transition Systems (LTS) such as those employed in process algebras like CCS [19] or CSP [12]. However,

states no incoming edges, according to UML 1.5.


when message input to an object is viewed as an invocation of an operation on that object, and output conversely, then I/O interaction is no longer tied to value passing, but to a server/client relationship—the invoked operation being a provided service. Now, what if an object invokes an operation of its own? This phenomenon, often termed self-delegation in OO terminology, whereby server and client coincide, obviously corresponds to internal action, too.
Furthermore, suppose one would consider a variant of the IOLTS definition deprived of internal actions, but where the input and output alphabets would not be required to be disjoint (thus allowing for self-delegation, which can be statically enforced by declaring private visibility of operations). This variant is immediately recasted into the standard IOLTS definition by removing the intersection of the input and output alphabets from these and putting it into the set of internal actions. This corroborates the OO view of treating both I/O and internal actions as operation invocations, a view that has a straight- forward interpretation in the IOLTS model of concurrency. Our architectural style prescriptions thus require that names of boolean conditions occurring in guards of transition labels of an object’s state diagram be declared as (private) operations of that object’s class, in some class diagram.
Now, the question arises whether the set of those internal actions which correspond to self-delegation coincides with the whole set of internal actions. A negative answer is immediate from the fact that unlabelled edges are allowed in architectural state diagrams. We then let IM include a single “absolutely unobservable” internal action, which corresponds to the empty label in state diagrams. The other internal actions thus get a “limited observability” status in our methodology, in that they are 1) unobservable by any other object in the architectural model (they are only used for self-delegation), yet 2) observ- able by testers—which seems meaningful in the context of white-box testing,
e.g. for debugging purposes. These actions will be referred to as the testable internal actions.
Finally, the semantics of output actions deserves attention; they model operation invoications on other server objects, but we deliberately disregard consideration of including the server object reference into the action itself. This is motivated by the inherently local character of architectural unit test- ing, whereas collaboration between objects is of concern to integration testing proper. As a preliminary hint to questions for further research, concurrent state diagrams, interaction diagrams and activity diagrams seem to be the appropriate models where collaboration between objects is to be specified, thus providing the appropriate basis for integration testing suites.

Test methodology implementation
Once the syntax and semantics of architectural unit modeling are fixed as outlined above, it becomes possible to look for tool support to architectural unit testing in the rich machinery that has flourished as offspring of IOLTS theories during recent years [26,8,15,7,27,11,13]. Now, our methodology aims at test case generation for speciﬁc test purposes, associated to user require- ments, where the generated test case is viewed as an architectural model of the testing code for that purpose. This aim follows from a view of test selec- tion as not only being the practically viable alternative to exhaustive testing, but also proving beneficial to structuring tests according to user requirements, thus obeying to the basic principle of separation of concerns.
The view of the generated test case as an architectural abstraction of test- ing code also entails that it need not be restricted to black-box testing. Archi- tectural abstraction does already intrude into the system internals, insofar as it is aimed at driving the organization and construction of internal structure. White-box testing code checks those internals too, insofar as it aims not only at detection of failures to meet externally observable requirements but also at discovering the internal sources of those failures. Generation of test cases where internal actions could be included in the tester’s observation capability proves thus desirable in the context of our testing methodology.
Contingent aspects of our methodology include: a mechanical translation of architectural state diagrams in Basic LOTOS [2], a non-mechanical, use- case driven synthesis of test purposes, expressed in the same language, and the use of the TGV (Test Generation using Veriﬁcation techniques) tool [8] for automated test case generation. Other choices in these respects are well pos- sible, without affecting the characteristic trait of the proposed methodology, that is rather to be found in the combination of object-oriented architectural modeling with IOLTS semantics.
The rest of this section recalls the relevant Basic LOTOS concepts and then gives an outline of the three steps of the aforementioned implementation of our test methodology, that has been experimented in the subject case study.

State diagrams in Basic LOTOS
LOTOS (Language of Temporal Ordering Speciﬁcations) is an ISO standard language [14] for the specification of concurrent, distributed and non-determin- istic systems. A tutorial introduction to LOTOS is available in [2]. Roughly, LOTOS consists of two parts: Basic LOTOS, for specifying interactions and flow of control, and ACT ONE, for the algebraic specification of abstract data types. The structural operational semantics of a LOTOS specification is given


by a LTS, and is defined by a set of inference rules. In general, a LOTOS spec- ification describes a system using a process hierarchy. A process is an entity that may execute internal, unobservable actions, and may interact with other processes through its gates, or interaction points. Complex interactions be- tween processes are built up of elementary units of synchronization which are called events, or (atomic) interactions, or simply actions. A system consists of a set of interacting processes. The environment of a system may also be seen as an observer process, which could be a human, that is assumed to be always ready to observe any observable action at the system interface. Plenty of examples of analysis and verification of properties of LOTOS specifications can be found in the literature, such as [18,24,25], to mention but a few.
To verify the conformance of an architectural unit to required functional- ities, its state diagram is translated to Basic LOTOS, which fact proves me- chanically feasible when the aforementioned style restrictions on UML state diagrams are obeyed. A detailed outline of this translation is presented in the next subsection. The Basic LOTOS “disabling” operator [> proves very useful in that it allows an almost direct translation of labelled outgoing transitions from composite states in UML state diagrams.
Practically, verification and test case generation are based on a possibly partial exploration of the LTS that describes the behaviour of the system un- der test. IOLTS semantics is somewhat different from LTS semantics because of the partitioning of the action alphabet into I/O and internal actions. This is circumvented, in our methodology as well as in IOLTS-based test gener- ation tools, by declaring the action partitioning outside the (Basic) LOTOS specification.








Translation UML → Basic LOTOS

In this section a mechanical translation of UML state diagrams in Basic LO- TOS is worked out in detail, under the style prescriptions defined in section
Before presenting the recursive definition of the translation rules, it’s

useful to introduce some notation which proves convenient to this purpose.
Notation:
ε : the empty label (in state diagrams);
SD : the set of states in diagram D, partitioned into:
ND : the set of named states in D (we let them coincide with their names),
UD : the set of anonymous states in D;
CD : the set of composite states in diagram D,with CD ⊆ ND ;
initD : the initial state in diagram D;
dsD : the default state in diagram D (target state of unique outgoing edge from initD);
Ds : the state diagram inside the region of composite state s ∈ CD; LD : the set of edge labels in diagram D;
s →a : if a is the (possibly empty) label of some outgoing edge from state s in D;
suc  : S  × L  →.  S  : the partial map such that suc (s, a) ↓ iff s →a  ,
in which case it’s the target state of the a-labeled edge outgoing from state s ;
Out (s)= {a | s →a  }, partitioned into:
NOut (s)= {a | s →a	suc (s, a) ∈ N },
UOut (s)= {a | s →a  , suc (s, a) ∈ U } ;
⎧⎪ L = ∅ :	stop



Σ a; Ba
= ⎪⎪⎨ L = {a}∪ L' : a; Ba [] Σ a'; Ba'	(a ∈/ L')

a∈L
⎪
⎪⎪⎩
a'∈L'
(well defined up to associativity and commutativity of [])

where the last definition is standard notation for Basic LOTOS behaviour expressions in normal form, viz. only using stop, action prefix and choice; L is a finite set of nonempty labels here, possibly extended with i, the LOTOS symbol for the absolutely unobservable internal action. Owing to LOTOS


concrete syntax, a bijective relabeling l : LD → (LD\{ε}) ∪ {i} is defined, with subscript argument, whereby lε = i, la = a if a /= ε.
For each named state in the diagram a corresponding LOTOS process is defined, with the name of that state. The diagram D itself is translated to a specification having LD\{ε} as gate set and functionality FD defined to be exit if D has a top-level final state, noexit otherwise; the same gate set and functionality are ascribed to every process definition that is defined for a top-level named state, viz. a named state that is not a substate of a composite state. Named substates of composite states take the gate set and functionality defined as above, but for the diagram Ds that lies inside the region of their closest containing composite state s, thus LDs \{ε} as gate set, and functionality FDs = exit iff a final state is a direct substate of s. The map GD : ND → 2LD\{ε} sends every named state s to the gate set ascribed to the process definition for s.
For a given state diagram D, we now define a map BD sending each state s ∈ SD to a Basic LOTOS behaviour expression over the appropriate set of gates. The map BD will provide:
the Basic LOTOS specification with its top-level behaviour expression
BD(initD), and
the process definition of each named state s ∈ ND with its defining be- haviour expression BD(s),
thereby completing the definition of the translation of architectural state di- agrams in Basic LOTOS. Map BD is recursively defined as follows.
The BD-image of any (anonymous) final state (be it the top-level final state or the final state of any composite state) is the LOTOS exit process.
The BD-image of any (anonymous) initial state (be it the top-level initial state or the initial state of any composite state) depends on whether the subsequent default state is named:

BD(initD)= BD(dsD) if dsD ∈ UD
BD(initD)= dsD[GD(dsD)] if dsD ∈ ND

For any other state s ∈ SD, if s is simple (i.e. not composite, see below for this case), then
BD(s)=	Σ	la; sucD(s, a)[GD(sucD(s, a))] [ ]	Σ	la; BD(sucD(s, a))
a∈NOutD(s)	a∈UOutD(s)


The УD-image of a composite state is built by means of the sequential composition and disabling operators, in addition to the previous constructs. The disabling operator is employed to take care of the labelled outgoing tran- sitions from the composite state, thus rendering the fact that such transitions may occur from any of the inner (non pseudo)states of the composite state. The sequential composition operator is employed to specify behaviour after termination of the composite state process, whenever this has exit functional- ity. The УD-image of s ∈ CD is an instance of one of the following behaviour expression schemes, depending on which case applies, with Bi ranging over behaviour expressions (i = 1, 2, 3):
(B1 [> B2) >> B3 if JDs = exit and OutD(s)\{ε} /= ∅
B1 [> B2 if JDs = noexit and OutD(s)\{ε} /= ∅
B1 >> B3 if JDs = exit and OutD(s)= {ε}
B1 if JDs = noexit and OutD(s)= ∅
where the constituent behaviour expressions are recursively defined as follows:


B1= BD(initDs )
B2=	X
a∈NOutD(s)\{ε}


a; sucD(s, a)[GD(sucD(s, a))] [ ]	X
a∈UOutD(s)\{ε}


a; BD(sucD(s, a))


B3= BD(sucD(s, ε))


Test purposes
A test purpose is an abstract description of a subset of a specification, that allows one to choose behaviours to test, and consequently, helps one to reduce the extent of specification exploration. This is interpreted as an IOLTS where two disjoint subsets of final states are distinguished. Final states of the test purpose graph are: either accepting states (this means that the purpose is reached) or refusing states (this means that parts of the specification are rejected). A test purpose can thus be formalized by an IOLTS with selected marked states [8,16], as follows.
Definition 2.2 [Test Purpose]
A test purpose is an IOLTS, TP = (QTP , ATP , →TP , qTP ), with a set of states ACCEPT ⊆ QTP , that define the verdict Pass, and a set of states REFUSE ⊆ QTP , that define the verdict Fail.


Test purposes enable tools to limit the specification graph exploration by taking a synchronous product of the specification with the test purpose, where specified actions that are not in the I/O alphabets of the test purpose IOLTS are considered as internal actions of the specification. By giving priority to test purpose actions, an effective pruning of the specification graph is obtained. This is explained in some more detail as follows.
Automatic test generation
The third step of our methodology implementation is concerned with auto- matic test case generation using TGV. This is a tool for the generation of test suites based on verification technology [8,7], that is integrated into the CADP toolbox [15,11,13].
TGV takes two inputs as arguments: a specification of the system’s be- haviour, defined in a language with IOLTS semantics, and the test purpose, which is made use of to select a purposeful subset of the system’s behaviour to be tested.
To produce automatically the appropriate test case, TGV uses algorithms that are peculiar to systems verification technology, such as Tarjan’s Algo- rithm. The generation is done “on-the-fly” on the synchronous product of the specification with the test purpose. This product avoids states explosion by only exploring the particular fragment of the specification selected according to the test purpose. Thereupon TGV produces a test case, represented by an IOLTS, in which transitions may be labelled with the test verdicts, that are pass, fail or inconclusive. Therefore, a test case is a set of sequences of actions describing all possible interactions between the implementation under test (IUT) and a tester aimed at checking whether the implementation con- forms to the specification according to a given test purpose, insofar as this is concerned.
In the present architectural setting, significance of test case generation is twofold: 1) the testability of user requirements is validated by generating test cases for test purposes which are deemed to reflect those requirements in the given model; and 2) the generated test cases are architectural specifications of testers for those test purposes, and may thus be taken as early models for their design, well in advance of implementation and coding phases. In this perspective, reference to the (envisaged) IUT is meaningful although no IUT may be actually available when architectural test case generation takes place. The system specification and the test case (or tester) TC are both IOLTS, and the output alphabet of TC is a subset of the output alphabet of specifica-
tion, ATC ⊆ AS . In practice, in the test case, every trace, that is a transition
O	O
sequence, describes a corresponding interaction sequence between tester and


IUT. Basically, the conformance relation is the ioco| relation described in [26]. Informally, the conformance relation states that a IUT I conforms to a speci- fication S, according to a set of traces  if, after every observable trace in , the outputs of I is included in the outputs of S. In our methodology,  is the subset of the traces of S that in the test purpose lead to an accepting state.
To use the TGV tool, the specification must be defined as a Binary Coded Graph (BCG), spec.bcg, or as a LOTOS specification, while the test purpose must be described as a BCG, say file tp.bcg, or in Aldebaran format, say file tp.aut [13,17].
In the present application of our methodology we describe the test purpose in Basic LOTOS and we translate the obtained file in Aldebaran format using the CAESAR/ALDEBARAN Development Package (CADP) tools. Descrip- tions of this package can be found in [11,13,15].

A robot teleoperation case study
An application example is worked out in this section, that should help the reader to grasp the basic features of the testing methodology proposed here. The case study is drawn from the software architecture design documented in [29].
The class TrajectoryGen we use for this purpose is defined in the context of a package for robot motion control and manipulation, where this class is responsible for trajectory generation, uses forward and inverse kinematics of the robots for this computation, and checks whether the final position is reachable, as well as for possible collisions. The class operations are shown in figure 3.

Fig. 3. The TrajectoryGen class


State diagram of TrajectoryGen
Figure 4 shows the state diagram of a TrajectoryGen object.



Fig. 4. State diagram of TrajectoryGen class

According to the style prescriptions defined in section 2.2 for architectural state diagrams, we let every nonempty transition label consist of only one out of the three label components allowed by UML syntax, viz. event, guard, action, resp. corresponding to input, internal action, output.
Upon creation, a TrajectoryGen object is in the Idle state, waiting for new data and, in particular, new positions for the controlled robot(s). When it receives these data, the object moves to the Check state, to see whether the final position is within reach (TestPosition) and, if so, for the absence of obstacles and possible collisions (TestObstacle). If the verification succeeds, the object moves to the WaitGetT state, otherwise it goes back to Idle.
In the WaitGetT state the object waits for a getTrajectory input. When this occurs, the condition whether the position received is either a modification of a previous trajectory, or a new position used to generate a new trajectory, fires a transition, resp. to CompModT or to CompNewT. When the computation in either state terminates, the object moves to state TrajReady, where it outputs


the /newTrajectory to the robot(s), unless a newObject input occurs, signaling a new obstacle in the environment.
If the presence of a new obstacle is signalled, the object moves to the Control state, where it checks whether a collision with the obstacle may occur ([collisionDetected]). If so, then the object goes to the Approach state, where the previous trajectory is modified, so that the robot approaches the obsta- cle without collisions. The new trajectory is output to the robot, and the trajectory generator goes to the Check state again, where the new trajectory is computed, to reach the final position from the newly reached point. When the new obstacle does not lie on the trajectory, the trajectory generator outputs the computed trajectory to the robot and moves back to Idle.
When the object is in the Idle state and a new obstacle is detected in the robot work environment, a transition to the CheckTraj state fires, where it is checked whether or not there is a trajectory followed by the robot already. If there is such a trajectory, then the object moves to the Control state, where the possibility of collisions with the new obstacle is checked, otherwise it moves back to Idle.

Sample application of the test methodology
In this section we apply our test methodology to the TrajectoryGen state dia- gram, see figure 4.
State diagram translation in Basic LOTOS
A direct translation of the TrajectoryGen state diagram in Basic LOTOS is possible, since this diagram satisfies the constraints prescribed in section 2.2, hence the translation defined in section 2.6 is applicable.
Now, the presence of a composite state, such as Check, with outgoing transi- tions is no problem as far as translation to Basic LOTOS is concerned, thanks to the availability of the disable operator [>. However, the Caesar compiler complains about our translation using this feature, as we explain later. The following translation thus departs from the TrajectoryGen state structure in this respect: we collapse state TestPosition to its parent superstate Check, whose out- going transitions are replicated for its substate TestObstacle. We thus obtain an equivalent state diagram with no composite state.
For the sake of conciseness, we map operation names to shorter gate names, and observe the convention that all names of internal actions have an i prefix. This mapping is as follows.


Input actions:
nP : newPoint
dP : desiredPosition gT : getTrajectory nO : newObject
Output actions:
nT : newTrajectory
Internal actions:
i te :  trajectoryExists
i tn : not trajectoryExists i wb : withinBounds
i rp :  reachablePoint
i up :  not reachablePoint
i tg :  trajectoryGeneration
i tm : trajectoryModification i cn : computedNewTrajectory
i cm : computedModifiedTrajectory i cd : collisionDetected
i nd :  not collisionDetected
Finally, we let A stand for the set of actions defined above, and we let it abbreviate the corresponding list of process gates. Under these premises, here is a Basic LOTOS translation of the TrajectoryGen state diagram.
specification TrajGen[A]:noexit behaviour Idle[A]
where
process Idle[A]:noexit
:=
nP ; Check[A] [] dP ; Check[A] [] nO ; CheckTraj[A] endproc
process Check[A]:noexit
:=
i_wb ; TestObstacle[A] [] i_up ; Idle[A] endproc
process CheckTraj[A]:noexit
:=
i_te ; Control[A] [] i_tn ; Idle[A] endproc
process TestObstacle[A]:noexit
:=


i_rp ; WaitGetT[A] [] i_up ; Idle[A] endproc
process WaitGetT[A]:noexit
:=
gT ; ( i_tg ; CompNewT[A] [] i_tm ; CompModT[A] ) endproc
process CompNewT[A]:noexit
:=
i_cn ; TrajReady[A] endproc
process CompModT[A]:noexit
:=
i_cm ; TrajReady[A] endproc
process TrajReady[A]:noexit
:=
nT ; Idle[A] [] nO ; Control[A] endproc
process Control[A]:noexit
:=
i_cd ; Approach[A] [] i_nd ; nT ; Idle[A] endproc
process Approach[A]:noexit
:=
nT ; Check[A] endproc endspec
As mentioned above, this translation is not exactly a direct translation of the given state diagram because of a complaint by the Caesar compiler w.r.t. the translation of the composite state Check, with its outgoing transitions, using the Basic LOTOS disabling operator [>. It seems instructive, though, to report such a translation as well, that goes as follows.
process Check[A]:noexit := (TestPosition[i_wb]
[> i_up ; Idle[A]
) >> i_rp ; WaitGetT[A] endproc
process TestPosition[i_wb] : exit := i_wb ; TestObstacle
endproc


process TestObstacle : exit := exit
endproc
Basically, the Caesar compiler complains because of the recursive occur- rence of the Idle process in the left argument of the Basic LOTOS enabling operator >>. This as well as other cases of recursion, even though well-guarded ones, are forbidden by the so-called restriction rules, which admit regular be- haviours only[9]. It is to be noted, however, that those rules provide one with an only suﬃcient condition for regularity, that is termed static control prop- erty in [9] as well as in the Cæsar manual[10]. This property is meant to ensure that LOTOS specifications can be translated into finite state graphs. Now, our translation goes in the opposite direction, and we actually have a finite state graph to start with, yet we may expect that whenever some cycle goes through a composite state, then one has got to unfold the corresponding LOTOS enabling and disabling constructs, in order to recover that property.

A sample test purpose
The next step is a use-case driven synthesis of a test purpose, expressed in Basic LOTOS. This derivation is not mechanical, in that process-algebraic languages are not quite logical languages, but rather have a constructive character, thus prove better suited to describe models rather than require- ments. However, their use under appropriate specification styles, such as the constraint-oriented style [28], enables one to get specifications which come quite close to taking a logical flavour. While this is no general method for test purpose selection (a luxury we can’t afford at the present stage of our research), it does often work in practice, as we aim at demonstrating below.
We illustrate this aspect of our methodology by assuming a previous anal- ysis of the functional requirements which apply to our architectural unit, that splits them into separate, independent prescriptions. For example, the trajec- tory generator should in all cases output trajectories which prevent collisions with objects in the robot work environment; this may be split by case analysis, and modelled in UML by distinct use cases, by considering: collisions with still objects, or with moving objects; and, in either case, under the assumption that no new object comes into play during the new trajectory computation, or under the opposite assumption. Here we choose the first case under the first assumption, that is, output of new trajectory free from collisions with still objects, assuming that no new object is detected during the trajectory computation. This enables us to formulate the test purpose in terms of action traces, where the only relevant actions are: the newPoint input, the newTrajectory


output, and the internal actions reachablePoint and its opposite.
An informal statement of the selected test purpose exhibiting a kind of logical flavour could be as follows: when Idle, the unit inputs a newPoint, then it Checks whether this is a reachablePoint; if so, it outputs a newTrajectory, if not, it goes back to Idle; the test is passed upon output of a newTrajectory.
The formulation of the subject test purpose in Basic LOTOS, however, is also meant to be used for test case generation by the TGV tool. This means that we must follow this tool’s conventions to mark final states of testing traces as either accepting or refusing. In the TGV representation of the IOLTS associated with the LOTOS TP specifications, the accepting states (and respectively the refusing states) are characterized by cyclic transitions with predefined label ACCEPT or accept (and respectively REFUSE or refuse). The latter are implicitly determined by the tool itself, whereas the former require explicitly specified accept action cycles. A slightly nasty problem in this respect is that accept also is a LOTOS reserved keyword, used in the value-passing forms of the enable operator, hence it cannot be made use of as a gate name directly. We get around this problem by using a different gate name, acc, and then replacing it with the accept label as required by TGV test case generation afterwards.
Our test purpose formulation in Basic LOTOS thus looks like as follows.
specification TP [nP,i_rp,i_up,nT,acc] : noexit behaviour Idle[nP,i_rp,i_up,nT,acc]
where
process Idle[nP,i_rp,i_up,nT,acc] : noexit := nP ; Check[nP,i_rp,i_up,nT,acc]
endproc
process Check[nP,i_rp,i_up,nT,acc] : noexit := i_rp ; nT ; Accepted[acc]
[]
i_up ; Idle[nP,i_rp,i_up,nT,acc] endproc
process Accepted[acc] : noexit := acc ; Accepted[acc]
endproc endspec
The corresponding IOLTS (see figure 5) is generated by the Caesar compiler in Aldebaran format, that is one of the two formats required by TGV for test case generation.

The TGV test case

The last step aims at test case generation for the previously specified test purpose. With TGV, we choose to explicitly specify the inputs to the specifi- cation, the other actions being its outputs. This partitioning is to be defined by regular expressions with the Unix regexp syntax, put in an ad-hoc .io file as required by the TGV option -io. The content of this file (STG.io) is the following:
input [nNdD]P [gG]T
[nN]O
We get a fairly interesting, yet economical test case from TGV by invoking it with the following CADP command:
caesar.open TrajGen.lotos tgv -io STG.io -tpprior TP.aut
whereby we ask TGV to take the system specification TrajGen.lotos and the system I/O description file STG.io to generate a test case for the test purpose TP.aut (previously generated by the Caesar compiler from the test purpose specification given in section 4.2). Note that system inputs are outputs by the tester, and conversely. I/O labeling of transitions in the IOLTS of the generated test case refers to the tester. We do not hide any internal actions, although this would be well possible by the -hide option, consistently with our view of the generated test case as an architectural model of a white-box testing unit. Figure 6 displays the test case thus obtained.
The option -tpprior prescribes priority to actions of the test purpose in generating the test case. Note that, without this option, priority is by default assigned to specification actions; this would produce a substantially larger test case, where also actions such as nO outputs by the tester would appear in testing traces, against our intuition of the test purpose as being limited to still objects under the assumption of no new object entering the scene during new trajectory computation. Selection of test purpose priority seems to be a necessary ingredient of the implementation of our testing methodology when using TGV, and appears to be effective—judging from this example at least.

,r¸~ ~,z NP ,rz¸~ ~,,z I RP ,r¸~ ~,z NT ,r¸~ ~,z˛r

0 ,r 1
I UP 


z2,
z3,
ACCEPT

Fig. 5. IOLTS derived from test purpose

,r¸~8 ~,z
 ¸
NT ;INPUT (PASS)
,r.¸~7 ~,z,,,  

I CN ;INPUT cccc
,r¸~ ~,zcccc
,,,,
,,,,I CM ;INPUT
,,,,r¸~ ~,z c
ccc

I T G;INPUT


,,,r¸~ ~,zccc I  TM ;INPUT
 ¸

GT ;OUT PUT
,r¸~3 ~,z
 ¸
I RP ;INPUT
,r¸~2 ~,z¸,¸¸,¸
¸I¸¸W¸¸B;IN PUT
¸¸¸¸¸¸

I UP ;INPUT
   ,r¸~1 ~,,z

NP ;OUT P U T
          
, 
0 ¸r 



Conclusions
Fig. 6. The test case obtained

A combination of object-oriented architectural modeling with IOLTS seman- tics has been explored in this paper, as a framework for a formal testing methodology to assess testability of functional requirements, as well as to generate architectural models of unit testers, at early design stages. The pro- posed methodology has been tried in a non-trivial case study drawn from design of a telerobotics software architecture, and an implementation of the methodology using a well-established toolbox for IOLTS test case analysis and generation has been successfully experimented.
A single experiment is no definite assessment, of course, yet no reason of principle seems to hamper feasibility of further experiments, e.g. other tools such as TorX [27] or Promela/SPIN [5] seem to deserve attention, perhaps to overcome certain drawbacks which have surfaced in our first experiment.
Test selection and test case generation based on an orthogonal set of test purposes is a promising device to master the complexity of large test suites. However, it is apparent from the experiment presented in this work that the formalization of test purposes, as well as their being linked to formally specified


requirements, both are aspects of our methodology where further investigation is much needed. This seems crucial not only to achieve coherent applicability of the proposed methodology throughout the development process but also to retain traceability of requirements into the test set, thereby mitigating the risk of requirements change not being reflected in the corresponding tests.
Further directions of this research relate to: 1) extension of the methodol- ogy to other architectural testing scopes, viz. integration and system testing, involving other kinds of UML models, particularly those provided by concur- rent state diagrams, interaction diagrams and activity diagrams; 2) investi- gation of relationships with testing at more advanced development phases, whereby models are built in a more prescriptive, possibly complete specifi- cation perspective; 3) on the formal side of the previous research direction, extension of the expressive means of testing models to cater for data, e.g. in the form of parameter passing in I/O operations, evaluation in internal actions, etc.

Acknowledgements
The authors wish to thank the anonymous referees, of this as well as of a previous version of this paper, for their helpful suggestions to improve both the clarity and the coverage of the presentation.

References
Apfelbaum, L. and J. Doyle, Model based testing (1997), paper presented at the 10th International Software Quality Week Conference.
URL http://www.model-based-testing.org/sqw97.pdf

Bolognesi, T. and E. Brinksma, Introduction to the ISO Speciﬁcation Language LOTOS, Computer Networks and ISDN Systems 14 (1987), pp. 25–59.
Booch, G., J. Rumbaugh and I. Jacobson, “Unified Modeling Language User Guide,” Addison- Wesley, 1997.
Dalal, S. R., A. Jain, N. Karunanithi, J. M. Leaton, C. M. Lott, G. C. Patton and
B. M. Horowitz, Model-Based Testing in Practice, in: Proceedings of the 1999 International Conference on Software Engineering (ICSE’99), New York, 1999, pp. 285–295.
de Vries, R. G. and J. Tretmans, On-the-fly conformance testing using SPIN, Software Tools for Technology Transfer 2 (2000), pp. 382–393.
El-Far, I. K. and J. A. Whitteker, Model-Based Software Testing, The Encyclopedia on Software Engineering (edited by J.J. Marciniak), Wiley (2001).
URL http://testingresearch.com/Ibrahim/papers_html/encyclopedia.htm

Fernandez, J.-C., C. Jard, T. Jeron and C. Viho, An experiment in automatic generation of test suites for protocols with veriﬁcation technology, Science of Computer Programming 29 (1997),
pp. 123–146.


Fernandez, J.-C., C. Jard, T. Jeron and G. Viho, Using on-the-fly veriﬁcation techniques for the generation of test suites, in: Rajeev Alur and Thomas A. Henzinger, editors, Proceedings of the Eighth International Conference on Computer Aided Veriﬁcation CAV, Lecture Notes in Computer Science 1102 (1996), pp. 348–359.
Garavel, H., “Compilation et v´erification de programmes LOTOS,” Th´ese de Doctorat, Universit´e Joseph Fourier, Grenoble, F, 1989.

Garavel, H., “Cæsar
Reference Manual,” Rapport SPECTRE, C18, Laboratoire de G´enie

Informatique, I.M.A.G., Grenoble, F, 1990.
Garavel, H., F. Lang and R. Mateescu, An overview of CADP 2001, Technical Report 0254, INRIA, Institut National de Recherche en Informatique et en Automatique (2001).
Hoare, C. A. R., “Communicating Sequential Processes,” International Series in Computer Science, Prentice Hall, 1986.
INRIA, CADP (Caesar/Aldebaran Development Package), A Software Engineering Toolbox for Protocols and Distributed Systems.
URL http://www.inrialpes.fr/vasy/cadp.html
ISO, “Information processing systems – Open Systems Interconnection – LOTOS – A formal description technique based on the temporal ordering of observational behaviour,” International Organisation for Standardisation, 1988.
J. -C. Fernandez, H. Garavel, A. Kerbrat, L. Mounier, R. Mateescu and M. Sighireanu, CADP: a protocol validation and veriﬁcation toolbox, in: Rajeev Alur and Thomas A. Henzinger, editors, Proceedings of the Eighth International Conference on Computer Aided Veriﬁcation CAV, Lecture Notes in Computer Science 1102 (1996), pp. 437–440.
Jeron, T. and P. Morel, Test Generation Derived from Model-Checking, in: Proceedings of the 11th International Computer Aided Veriﬁcation Conference, 1999, pp. 108–121.
Jeron, T., P. Morel and S. Simon, TGV online manual.
URL http://www.inrialpes.fr/vasy/cadp/man/tgv.html
Kirkwood, C. and M. Thomas, Experiences with LOTOS: A Report on Two Case Studies, in:
Proceedings of WIFT ’95 (1995), pp. 159–172.
Milner, R., “Communication and Concurrency,” International Series in Computer Science, Prentice Hall, 1989.
Object Management Group, UML, Uniﬁed Modeling Language.
URL http://www.omg.org/uml
Richardson, D. J., J. A. Stafford and A. L. Wolf, A formal approach to architecture-based software testing (1997).
URL http://www.cs.colorado.edu/serl/arch/wpaper.html

Richardson, D. J. and A. L. Wolf, Software testing at the architectural level, in: Proceedings of the Second International Software Architecture Workshop (ISAW-2) (1996), pp. 68–71.
Sommerville, I., “Software Engineering, 7th Ed.” Addison-Wesley, 1999.
Thomas, M., The Story of the Therac-25 in LOTOS, High Integrity Systems Journal 1 (1994),
pp. 3–17.
Thomas, M. and B. Ormsby, On the Design of Side-Stick Controllers in Fly-By-Wire Aircraft, ACM Applied Computing Review 2 (1994), pp. 15–20.
Tretmans, J., Test Generation with Inputs, Outputs and Repetitive Quiescence, Software— Concepts and Tools 17 (1996), pp. 103–120.
Tretmans, J., Speciﬁcation Based Testing with Formal Methods: From Theory via Tools to Applications, in: A. Fantechi, editor, FORTE / PSTV 2000 Tutorial Notes, Pisa, Italy, 2000, transparencies.


Vissers, C. A., G. Scollo, M. van Sinderen and E. Brinksma, Speciﬁcation styles in distributed systems design and veriﬁcation, Theoretical Computer Science 89 (1991), pp. 179–206.
Zecchini, S., “Architettura software per un sistema di telerobotica,” Tesi di Laurea, Universit`a di Verona, 2003.
