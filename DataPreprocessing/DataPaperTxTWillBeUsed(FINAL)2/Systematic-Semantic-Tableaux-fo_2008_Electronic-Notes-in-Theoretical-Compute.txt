Electronic Notes in Theoretical Computer Science 206 (2008) 59–73	
www.elsevier.com/locate/entcs
Systematic Semantic Tableaux for PLTL
J. Gaintzarain, M. Hermo, P. Lucio and M. Navarro1
Dpto. de Lenguajes y Sistemas Informa´ticos.
Facultad de Informa´tica. Universidad del Pa´ıs Vasco.
20080-San Sebasti´an, Spain.

Abstract
The better known methods of semantic tableaux for deciding satisfiability in propositional linear temporal logic generate graphs in addition to classical trees. The test of satisfaction is made from the graph and it does not correspond with the application of rules in any calculus for PLTL. We present here a new method of semantic tableaux without using additional graphs. The method is based on a new complete finitary sequent calculus for PLTL which allows us to incorporate all the information in a tree. This approach makes our tableaux better suited for completely automatic theorem proving.
Keywords: Propositional Linear Temporal Logic, Tableaux, Satisfiability


Introduction
Temporal logics constitute a well-known topic of study in theoretical computer science. One of the most basic and important types of temporal logic is the Propo- sitional (Linear) Temporal Logic (PLTL), which contains logical operators for rea- soning about discrete, linear sequences of states. Tableaux are common mechanisms used in most decision procedures for the validity problem and also in tableaux-based completeness proofs for temporal logics.
The semantic tableaux for PL (Propositional Logic) are very simple: the formula is decomposed into its sub-formulas according to certain rules, resulting in a tree- like tableau where each branch is terminated by a leaf with a complementary pair of formulas (a closed branch) or by a leaf containing a set of non-contradictory literals (an open branch). Each open branch represents a model for the given formula.
However, in PLTL, the same approach is not enough, since each formula must be analyzed in an infinite sequence of states. For instance the formula φ U ψ is analyzed as follows: either ψ holds now or else φ holds now and φ U ψ holds in the next state.

1 This work has been partially supported by Spanish Project TIN2004-079250-C03.

1571-0661© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.075

Therefore, some mechanism must control the repeated appearances of the formulas and identify periodic situations in finite time [5]. The usual way to proceed is to build a tableau-graph, divide it into its strongly connected components, and check fulﬁlling paths among them to ensure that eventually in the future ψ holds for every φ U ψ.
While the application of rules in decomposing the formula can correspond to a deduction in usual sequent calculus for PLTL, the second phase of the procedure that checks for the fulfillment property does not correspond with rules for such calculus.
We can only mention one paper [9] that avoids the second phase in the con- struction by adding extra information into the nodes of the tableaux. Some of this information must be synthesized bottom-up and it is needed because a single branch cannot be open or closed; it may be open in connection with some other branches.
In this paper we present a systematic tableaux method that, similarly to the PL case, allows us to build a tableau as a finite tree with open and closed branches. If all branches are closed then the formula has no models. If the formula is satisfiable then some of its models can be obtained from the open branches. These models (in general) are ultimately periodic, that is, they terminate in a cycle. Our approach is simpler than [9] since each branch does not depend on other branches.
This approach is based on the use of a particular rule for until formulas (φ U ψ) to “remember” the context when the unfolding of such formulas occurs. By using this rule, the fulfilling check is incorporated into the construction of the tree. Moreover, this particular rule belongs to the set of rules in a new sound and complete sequent calculus for PLTL [3]. Therefore, each application of a rule in the tableaux is indeed an application of the corresponding rule in the mentioned calculus. In contrast with this calculus, called FC, other sequent calculus [6,7,8] prevent this correspondence.
This paper is organized as follows. Section 2 is a basic introduction to PLTL. In section 3, we introduce the method of semantic tableaux. More precisely, we present the rules for constructing tableaux, the algorithm of construction, and sev- eral properties of this algorithm. Section 4 shows some examples, while section 5 presents the soundness and the completeness proof of the method.
PLTL: Language and Model Theory
In what follows, we refer to the PLTL language, with syntax and semantics similar to [3].
A PLTL-formula is built using the constant proposition f alse, propositional vari- ables (denoted by lowercase letters p, q,.. .) from a set Prop, the classical connec- tives ¬ and ∧, and the temporal connectives ◦ and U . A lowercase Greek letter (ϕ, ψ, χ, γ,.. .) denotes a formula and an uppercase one (Φ, Γ, Ψ, Ω,.. .) denotes a finite set of PLTL-formulas. Those of the form p and ¬p, where p ∈ Prop, are called literals. As usual, other connectives can be defined in terms of the previous ones: true ≡ ¬f alse, ϕ ∨ ψ ≡ ¬(¬ϕ ∧ ¬ψ), ⬦ ϕ ≡ true U ϕ,  ϕ ≡ ¬ ⬦¬ϕ. In the rest of this paper, we employ formula instead of PLTL-formula. Formulas of the form

ϕ U ψ (also ⬦ ϕ and ¬  ϕ) are called eventualities. Those of the form ◦ϕ and ¬◦ϕ
are called next formulas.
The operator next translates any set of formulas into another (possibly empty) set of formulas next(Φ) = {γ | ◦γ ∈ Φ}∪ {¬γ | ¬◦γ ∈ Φ}.
Definition 2.1 A PLTL-structure M is a pair (N, VM) where N is the set of natural numbers and VM : N → 2Prop maps each state n ∈ N into a subset of Prop.
Intuitively, VM specifies which propositional variables are necessarily true in each state.
Definition 2.2 The truth of a formula ϕ in the state j of a PLTL-structure M, which is denoted by ⟨M, j⟩ |= ϕ, is inductively defined as follows:
⟨M, j⟩ |= f alse
⟨M, j⟩ |= p iff p ∈ VM(j) for p ∈ Prop
⟨M, j⟩ |= ¬ϕ iff ⟨M, j⟩ |= ϕ
⟨M, j⟩ |= ϕ ∧ ψ iff (⟨M, j⟩ |= ϕ
and ⟨M, j⟩ |= ψ)
⟨M, j⟩ |= ◦ϕ iff ⟨M,j + 1⟩ |= ϕ
⟨M, j⟩ |= ϕ U ψ iff ⟨M, k⟩ |= ψ for some k ≥ j and ⟨M, i⟩ |= ϕ for every j ≤ i < k.
This is extended to sets in the usual way: ⟨M, j⟩ |= Φ iff ⟨M, j⟩ |= ϕ for all ϕ ∈ Φ. We say that M is a model of Φ, in symbols M |= Φ, iff ⟨M, 0⟩ |= Φ. A satisfiable set of formulas has at least one model, otherwise it is unsatisfiable.

Semantic Tableaux for PLTL
In this section we present a method for semantic tableaux which, given a temporal formula, searches systematically for a model. If a model is found, the formula is satisfiable; otherwise, it is unsatisfiable.

Rules for Constructing a Semantic Tableau
We use the following α-, β-, X-rules in the construction of semantic tableaux for, respectively, α-formulas (conjunctions), β-formulas (disjunctions) and next formu- las. α1 denotes the (set of) conjuncts of a α-formula, β1, β2 denote the (sets of) disjuncts of a β-formula and X1 denotes the application of the operator next to a set of formulas.



All rules but (r6) are the usual ones in temporal tableaux construction (see for instance [1]). Rule (r6) is introduced in [3], where a new sound and complete calculus for PLTL is presented. This rule allows us to “remember” the context Γ when unfolding of ϕ U ψ is done. More concretely, it forces some formula in the context to change in future worlds (while ψ is not obtained).
Although it is enough to use the minimal set of operators given above, we will use all operators in the examples in section 4. Below the usual β-rules for ϕ ∨ ψ,
⬦ ϕ and ¬ ϕ, and α-rules for ¬(ϕ ∨ ψ),  ϕ and ¬ ⬦ ϕ are shown. Note that they can be derived from the above rules. In particular, the rules with context Γ are
derived from rule (r6).


Preclosure and Closure of a Temporal Formula
Let ϕ be the formula whose satisfiability we wish to check.
Definition 3.1 The set of components in ϕ, Comp(ϕ), is the smallest set of for-

mulas defined as follows:
ϕ ∈ Comp(ϕ)
If γ ∈ Comp(ϕ), then all the formulas appearing in the parts α1, X1, β1, β2 of rules (r1),... , (r7), except (r6), that can be applied to γ, are in Comp(ϕ).
Next we define the pre-closure of ϕ.
Definition 3.2 PCL(ϕ)= Comp(ϕ) ∪ {¬γ | γ ∈ Comp(ϕ)}∪{γ | ¬γ ∈ Comp(ϕ)}
Note that the pre-closure of a formula does not consider those produced by the application of rule (r6). We will define the closure adding these formulas to the pre-closure.
Definition 3.3 Let D(ϕ) be the following set of formulas
D(ϕ)= {¬(   ψ ): Q ⊆ PCL(ϕ)}∪ {f alse}
ψ∈Q
Let C(ϕ) be the set of all possible conjunctions of elements in D(ϕ). That is,
C(ϕ)= {   D : S ⊆ D(ϕ)}
D∈S
The closure of ϕ , CL(ϕ), is defined as follows
CL(ϕ)= PCL(ϕ) ∪ C(ϕ) ∪A 


where

A =	 

{◦((C ∧ γ) U ψ), (C ∧ γ) U ψ}

(γ U ψ)∈PCL(ϕ)
C∈C(ϕ)
From the above definition, the following holds:
Proposition 3.4 CL(ϕ) has ﬁnite cardinality. Actually, if |PCL(ϕ)| = n then
|D(ϕ)| ∈ O(2n) and both |C(ϕ)|, |CL(ϕ)| ∈ O(22n ).

Systematic Construction of a Semantic Tableau
A tableau T is a tree where each node n is labeled with a set of formulas F (n). The root is labeled with the singleton set {ϕ}, for the formula ϕ whose satisfiabil- ity we wish to check. The children of a node are obtained by applying the rules (r1),... , (r7).
Definition 3.5 Let T be a tableau and p be a path in T from nodes n1, n2,... , nj. Any eventuality γ1 U γ2 ∈ F (ni), with 1 ≤ i ≤ j, is fulfilled in p if there exists k, with i ≤ k ≤ j, such that γ2 ∈ F (nk).

To determine which rule (r5) or (r6) to apply to an eventuality in a node, it is necessary to “distinguish” eventualities. The rule (r6) is applied only to “distin- guish” eventualities, in other case the rule (r5) is used. If a node does not contain any distinguished eventuality, then the algorithm distinguishes one of them and rule (r6) is chosen to be applied to it. Each node of the tableau has at most one distinguished eventuality.
Each branch of T can be seen as divided into stages, where each stage is a set of consecutive nodes which are obtained by applying α- or β-rules. When the X-rule is applied, we move from one stage to the following one in the branch.
Given two nodes in the same branch of T , n1 and n2, that are labeled with the same set of formulas Φ (i.e. F (n1)=F (n2)=Φ), the path between such nodes is called a loop.
The construction of the tableau is as follows.
Input: A PLTL formula ϕ
Output: A semantic tableau T for ϕ
Algorithm:
The tableau is built inductively by repeatedly choosing an unmarked leaf l labeled with a set of formulas F (l) and applying one of the following points in the order given.
Check if there is either the formula f alse or a complementary pair of formulas
{ϕ, ¬ϕ} in F (l). If so, mark the leaf closed (×).
If F (l) is a set of literals, then mark the leaf open (⊙).
If F (l) = F (l') for l' an ancestor of l, take the oldest ancestor of l that is labeled with F (l) (denote it by l''). Now check if each eventuality in the path between l'' and l is fulfilled in such path. If this is the case, mark the leaf open (⊙).
Otherwise, choose ϕ ∈ F (l) which is not a next formula.
If the formula is an α-formula (ϕ = α), create a new node l' as a child of l
and label l' with
F (l')= (F (l) − {α}) ∪ {α1}
If the formula is a β-formula (ϕ = β), create two new nodes l' and l'' as children of l. Label l' with
F (l')= (F (l) − {β}) ∪ {β1}


and label l'' with

F (l'')= (F (l) − {β}) ∪ {β2}

In this case, if ϕ is an eventuality, then
If ϕ is the distinguished eventuality, then apply the special rule (r6) to
ϕ. Distinguish the formula that is inside the next formula in β2.
If ϕ is not distinguished, but there is another distinguished formula, then

apply rule (r5) to ϕ. Maintain the existing distinguished formula in β1 and
β2.
– Otherwise, distinguish the formula ϕ. Apply the special rule (r6) to ϕ
and distinguish the formula that is inside the next formula in β2.
If F (l) consists only of literals and next formulas, the operator next is applied. That is, let
{◦ϕ1,... , ◦ϕm, ¬◦ϕm+1,... , ¬◦ϕn}
be the set of next formulas in F (l). Create a new node l' as a child of l and label l' with
F (l')= {ϕ1,... , ϕm, ¬ϕm+1,... , ¬ϕn}
The construction terminates when every leaf is marked × or ⊙.	 
A tableau whose construction has terminated is called a completed tableau. A completed tableau is closed if all leaves are marked ×. Otherwise, it is open.
Properties of this Construction
Here, we give some conditions that our algorithm must hold to ensure its termina- tion, as well as other properties which are necessary for section 5.
Definition 3.6 A node in the tableau is inconsistent if it contains a formula and its negation, or the constant f alse.
Proposition 3.7 If a formula γ and its negation ¬γ belong to the same stage in a branch of the tableau, and γ does not contain an eventuality that is distinguished in the stage, then this stage ﬁnishes in an inconsistent node.
Proof. It can be easily proven by structural induction on the formula γ. Note that there are two base cases: for γ being a literal p and a next formula ◦α, since these formulas must remain (after its first appearance) in all following nodes of the stage.	 

Proposition 3.8 All contexts accumulated in a distinguished eventuality in an open branch are pairwise different.
Proof. Let n be a node with F (n)= Γ∪ {(Γ∗i ∧ ...∧Γ∗1 ∧ α) U β}, and n+1 the node obtained as the β2-part of applying rule (r6) to the distinguished eventuality in
n. That is, F (n + 1) = Γ∪ {¬β, Γ∗i ∧ ... ∧ Γ∗1 ∧ α, ◦((Γ∗ ∧ Γ∗i ∧ ... ∧ Γ∗1 ∧ α) U β)} where the last formula contains the eventuality that remains distinguished in all nodes of this stage. By applying i times rule (r2), the branch is extended until node F (n + i + 1) = Γ∪ {¬β, Γ∗i,... Γ∗1, α, ◦((Γ∗ ∧ Γ∗i ∧ ... ∧ Γ∗1 ∧ α) U β)}.
Let us suppose that Γ∗ ∈ {Γ∗i,... Γ∗1} for Γ = {γ1,... , γp}. Then {γ1,... , γp,
¬(γ1 ∧ ... ∧ γp)} ⊆ F (n + i + 1) and therefore, by applying p − 1 times rule (r3), the branch split (in some moment) into p branches containing each one a complementary pair of formulas (γj and ¬γj) in the same stage. Moreover, each formula γj, for j in 1,... , p, cannot contain any distinguished eventuality. By Proposition 3.7, all these branches are closed.	 

Note that although there can be some formulas in the tableau T for ϕ that do not belong to CL(ϕ) because contexts are repeated, the previous proposition proves that all formulas in any open branch of T belong to CL(ϕ).
The following proposition concerns the open branches containing a loop.
Proposition 3.9 For every eventuality α U δ which is distinguished inside a loop, it holds that δ also belongs to (some node in) the loop.
Proof. Let α U δ be distinguished in a node of a loop. Then the rule (r6) is applied to α U δ within some context Γ1. If δ does not belong to the loop, this means that each application of such rule in the loop yields to obtain the β2-formulas; in particular, in the following stages (i ≥ 1), distinguished formulas are obtained: γ1
= (Γ∗1 ∧ α) U δ, γ2 = (Γ∗2 ∧ Γ∗1 ∧ α) U δ, .. ., γi = (Γ∗i ∧ ... ∧ Γ∗1 ∧ α) U δ, for some contexts Γi.
By Proposition 3.8, these formulas are all new (they are syntactically growing), and in each node n of stage i either γi or ◦γi+1 is in the set F (n). This contradicts the existence of a repeated node. Therefore δ must belong to the loop.	 
Next, the construction of the tableau is open to be implemented in different ways. However, any implementation must ensure that it is not possible to find a never distinguished unfulfilled eventuality in an open branch.
Remark 3.10 The use of a fair strategy for distinguishing the eventualities in each branch of the tableau, is essential for proving that the construction finishes.
Theorem 3.11 Any semantic tableau for a temporal formula ϕ, that distinguishes eventualities with a fair strategy, is ﬁnite.
Proof. Suppose that a tableau for ϕ contains an infinite branch p. Then the sets of formulas labeling the nodes in p are included in CL(ϕ) which, by Proposition 3.4, has finite cardinality. Then there are only finitely many possible different nodes in p. Thus, there must exist a node occurring infinite many times in p. This means that there is an unfulfilled eventuality, and by proposition 3.9, this eventuality is never distinguished. But this contradicts the fact that the strategy for distinguishing eventualities is fair. Therefore, the tableau cannot contain an infinite branch. 

To conclude, it is worth saying that the implementation of the algorithm must build the tableau incrementally using a deep-first strategy. Thus, when a node is marked open, the algorithm stops providing a model for the formula.

Examples of Semantic Tableaux
In this section, we give some examples of tableaux. The distinguished formulas are overlined. The formula which a rule is applied to is underlined. The application of operator next is drawn with ⇓ (instead of ↓) to better mark the stages in each branch. For purposes of visual clarity, we sometimes omit the application of trivial rules like (r1), which eliminates double negations. In these examples, all connectives

are used and consequently all α and β-rules. In addition, Γ∗ is written  γ∈Γ ¬γ
instead of ¬( γ∈Γ γ).
The first example shows an open tableau without loops for the formula (p U q) ∧
( ⬦ ¬q).
{(p U q) ∧ ( ⬦¬q)}
↓
{p U q, ⬦¬q} (	 
{q,  ⬦ ¬q}	{p, ¬q,  ⬦¬q, ◦(((¬ ⬦¬q) ∧ p) U q)}
↓		|

{¬q}	{¬q, q, ◦((f alse ∧ ¬q) U ¬q)}	|
↓	↓	|
⊙	×	|
{p, ¬q,  ⬦¬q, ◦(((¬ ⬦¬q) ∧ p) U q)} (	 
|	{p, ¬q, q, ◦( ⬦¬q), ◦(((¬ ⬦ ¬q) ∧ p) U q)}
↓	↓
{p, ¬q, ◦(((¬ ⬦ ¬q) ∧ p) U q)}	×
⇓
{((¬ ⬦ ¬q) ∧ p) U q} (	 
{q}	{(¬ ⬦ ¬q) ∧ p, ¬q, ◦(ψ)} 2
↓	↓
⊙	{¬ ⬦¬q, p, ¬q, ◦(ψ)}
↓
{q, ¬◦⬦¬q, p, ¬q, ◦(ψ)}
↓
×
Note that each branch finishing with the mark ⊙, produces a finite structure from which a model can be constructed (see Figure 1).
The different stages in a branch correspond to the different worlds in the struc- ture associated to such a branch.
The second example shows a closed tableau for the formula p U q ∧ ¬◦⬦ q ∧ ¬q. Note that each branch finishes with the mark ×. The formula p U q ∧ ¬◦⬦ q ∧ ¬q has no models.

2 where ψ = (false ∧ (¬ ⬦ ¬q) ∧ p) U q



Fig. 1. Two structures for {(p U q) ∧ ( ⬦¬q)}
{p U q ∧ ¬◦⬦ q ∧ ¬q}
↓
{p U q, ¬◦⬦ q ∧ ¬q}
↓
{p U q, ¬◦⬦ q, ¬q} (	|
{q, ¬◦⬦ q, ¬q}	|
(	|
×	↓
{p, ¬q, ¬◦⬦ q, ◦(((q ∨ ◦⬦ q) ∧ p) U q)}
⇓
{¬ ⬦ q, ((q ∨ ◦⬦ q) ∧ p) U q}
↓
{¬q, ¬◦⬦ q, ((q ∨ ◦⬦ q) ∧ p) U q} (	↓
{¬q, ¬◦⬦ q, q} {¬q, ¬◦⬦ q, (q ∨ ◦⬦ q) ∧ p, ◦(δ)} 3
(	↓
×	{¬q, ¬◦⬦ q, (q ∨ ◦⬦ q), p, ◦(δ)}
(	 
{¬q, ¬◦⬦ q, q, p, ◦(δ)} {¬q, ¬◦⬦ q, ◦⬦ q, p, ◦(δ)}
↓	↓
×	×
The last example shows (part of) an open tableau with loops (indicated (a) and (b)) for the formula  ⬦ p ∧ ⬦¬p. Each branch finishing with the mark ⊙ produces a model (see Figure 2).

{  ⬦ p ∧ ⬦¬p}
↓
{  ⬦ p, ⬦¬p}
↓
{ ⬦ p, ◦ ⬦ p, ⬦¬p} (	 
{p, ◦  ⬦ p,  ⬦¬p}	... 

3 where δ = [(q ∨ ◦⬦ q) ∧ (q ∨ ◦⬦ q) ∧ p] U q

(	|
{p, ◦  ⬦ p, ¬p}		| (	↓
×	{p, ◦  ⬦ p, ◦((¬p ∨ ¬◦  ⬦ p) U ¬p)}
⇓
{  ⬦ p, (¬p ∨ ¬◦  ⬦ p) U ¬p}
↓
{ ⬦ p, ◦ ⬦ p, (¬p ∨ ¬◦  ⬦ p) U ¬p} (	 
{ ⬦ p, ◦  ⬦ p, ¬p}	... 
(	|
{p, ◦  ⬦ p, ¬p}	|
↓	↓
×	{¬p, ◦  ⬦ p, ◦((¬◦  ⬦ p ∨ p) U p)}
⇓
{  ⬦ p, (¬◦  ⬦ p ∨ p) U p}
↓
{ ⬦ p, ◦  ⬦ p, (¬◦  ⬦ p ∨ p) U p} (	 
{ ⬦ p, ◦ ⬦ p, p}	... 
(	|
{p, ◦  ⬦ p}	|
⇓	↓
{  ⬦ p} {¬p, ◦  ⬦ p, p, ◦(¬p ∨ ¬◦  ⬦ p) U p}
↓	↓
{ ⬦ p, ◦  ⬦ p}	× (	 
{p, ◦  ⬦ p}	{¬p, ◦  ⬦ p, ◦(¬◦  ⬦ p U p)}
↓	⇓
⊙	{  ⬦ p, ¬◦  ⬦ p U p}
↓
{ ⬦ p, ◦  ⬦ p, ¬◦  ⬦ p U p} (	 
{ ⬦ p, ◦ ⬦ p, p} { ⬦ p, ◦  ⬦ p, ¬◦  ⬦ p, ¬p, ◦(α) 4 }
↓	↓
⊙	×

Soundness and Completeness of Semantic Tableaux
In this section we prove that our algorithm is sound and complete for proving the satisfiability of PLTL formulas. Soundness is given in Theorem 5.2 and completeness in Theorem 5.3.

4 where α = [(¬ ⬦ p ∨ ¬◦  ⬦ p) ∧ (¬◦  ⬦ p)] U p



Fig. 2. Two models for {  ⬦ p ∧ ⬦¬p}

Lemma 5.1 The following facts hold for α- and β- formulas:
Φ  {α} satisﬁable ⇐⇒ Φ  {α1} satisﬁable
Φ  {β} satisﬁable ⇐⇒ Φ  {β1} satisﬁable or Φ  {β2} satisﬁable
Given a consistent (without any complementary pair of formulas) set of formulas
Φ consisting of literals and next formulas: Φ satisﬁable ⇐⇒ next(Φ) satisﬁable
Theorem 5.2 If there exists a closed tableau for ϕ then ϕ is unsatisﬁable.
Proof. Let T be a closed tableau for ϕ. The set of formulas labeling each leaf is inconsistent and therefore unsatisfiable. By the previous lemma, each node in T is then labeled with a unsatisfiable set of formulas, in particular the root. Therefore ϕ is unsatisfiable.	 
Theorem 5.3 If there exists an open tableau for ϕ then ϕ is satisﬁable.
Proof. Let T be an open tableau for ϕ. There exists a leaf n in T , marked open, labeled with a set of formulas F (n). Let R be the branch in T from the root until leaf n and let j be the stage in R the node n belongs to. We shall build from R a model for ϕ.
Consider the structure M with a sequence of states 0, 1, 2,.. ., where ⟨M, i⟩ is the set of all literals appearing in all nodes (or equivalently in the last node) of the stage i in R, for i = 0, 1,.  Distinguish two main cases:
The leaf n is marked open because F (n) is a (consistent) set of literals. Then
M is a finite structure that can be seen as follows:


. . .

0	1	j

The leaf n is marked open because the set of formulas F (n) coincides with the set of formulas in some ancestor nodes of n in R. Let m be the oldest ancestor node of n in R such that F (m) = F (n). Then all eventualities in the path between m and n are fulfilled in the path. Let j' be the stage in R the node m belongs to, for some 0 ≤ j' < j. Then M is an infinite structure with a final loop that can be seen as follows:



. . .

0	1	j’	j-1

In the next auxiliar lemma we shall prove that every formula φ in a node of stage i in R is satisfied in the structure M, that is, ⟨M, i⟩ |= φ. Then, in particular,
⟨M, 0⟩ |= ϕ.
Finally, it is well known that M can be extended to an interpretation by adding to
⟨M, i⟩ all propositional variables p (from ϕ) such that neither p nor ¬p are in the stage i in R, for every i ≥ 0.	 
Now we prove the auxiliary lemma used in the proof of Theorem 5.3.
Lemma 5.4 For every formula φ appearing at (a node of ) stage i in R, it holds that ⟨M, i⟩ |= φ.
Proof. Let φ ∈i R denote that φ appears at (a node of) stage i in R, with
i = 0, 1,... , j. We proceed by structural induction on φ.
The base case, φ literal, holds by construction of M.
Cases ¬¬φ1 , φ1 ∧ φ2 , ◦φ1 , ¬◦φ1 and the case ¬(φ1 ∧ φ2) can be easily proven by induction hypothesis on φ1 and φ2.
Case ¬(φ1 U φ2). 
When M is a finite structure, it is obvious that for some k in i... j it holds
¬φ1 ∈k R. Otherwise, the leaf n contains the formula ¬(φ1 U φ2) which is not a literal. Also ¬φ2 ∈s R for every s in i... k. Then, by induction, ⟨M, k⟩ |= ¬φ1 and ⟨M, s⟩ |= ¬φ2, for every s in i... k. Therefore ⟨M, i⟩ |= ¬(φ1 U φ2). 
When M is an infinite structure with a final loop, let us first suppose that stage i is not inside the loop, that is, suppose i < j'. Hence, either the same occurs as in the previous case, or else ¬φ2 ∈s R for every s ≥ i. Both facts yield to
⟨M, i⟩ |= ¬(φ1 U φ2). 
When M is an infinite structure with a final loop, but stage i is inside the loop, we must also take into account the stages from j until the second occurrence of i (these are also future worlds for i).
This situation can be converted to the previous one just considering that the structure M can be seen as the structure M' defined ⟨M', k⟩ = ⟨M, k⟩ for k in 0 ... j − 1, and ⟨M',j + s⟩ = ⟨M, j' + s⟩ for s in 0 ... (j − j' − 1)
That is, M' is the following structure, where p = 2j − j' − 1. Then it holds:
¬(φ1 U φ2) ∈i R =⇒ ⟨M', i⟩ |= ¬(φ1 U φ2) ⇐⇒ ⟨M, i⟩ |= ¬(φ1 U φ2). 



. . .	. . .

0	j’	i	j	p

Case φ1 U φ2 .

When M is a finite structure, it is obvious that for some k in i... j it holds φ2 ∈k R. Otherwise, the leaf n contains a formula which is not a literal. Also φ1 ∈s R for every s in i... k − 1. Then, by induction, ⟨M, k⟩ |= φ2 and
⟨M, s⟩ |= φ1, for every s in i... k − 1. Therefore ⟨M, i⟩ |= (φ1 U φ2). 
When M is an infinite structure with a final loop, we can consider again two situations depending on stage i to be before or inside the loop.
If stage i is inside the loop then, by construction of the algorithm, the formula φ2 belongs to the loop where, until this moment, always is φ1. It yields, again by induction, to ⟨M, i⟩ |= (φ1 U φ2).
If stage i is before the loop and the formula φ2 does not belong to some stage before the loop, then there must exist an eventuality (Δ ∧ φ1) U φ2 in the first node of stage j', for some (possibly empty) conjunction Δ of contexts. Besides, φ1 ∈s R for every s in i... (j' − 1). Now the previous situation can be applied to (Δ ∧ φ1) U φ2 since the stage j' is inside the loop. Then ⟨M, j'⟩ |= ((Δ ∧ φ1) U φ2) which implies that ⟨M, i⟩ |= (φ1 U φ2).	 


Conclusions and Further Work
The development of automated deduction systems for propositional temporal logic has followed two main proof-theoretical approaches: tableaux [10] and resolution [2]. We have focused here on the first field, introducing a new method for semantic tableaux. While most of the previous decision algorithms for PLTL have been presented as two-phase procedures:
A tableau procedure that creates a graph.
A procedure that checks whether the graph fulfills all eventualities.
Here, we have presented a tableau method where derivations result in tree struc- tures rather than general graphs. Consequently, our method has the following two main advantages:
First, it avoids the second phase which requires the creation of the graph. Since it involves only the first phase, the procedure stops as soon as a model is detected, thus avoiding the construction of the complete tableau.
Secondly, each application of a rule in the tableaux is indeed an application of the corresponding rule in a new sequent calculus called FC [3]. Given any valid propositional temporal formula, a refutational proof in FC can be directly built from the closed tableau obtained by our method.
With respect to implementation, we have built a first prototype (in Java) that allows us to see, step by step, the construction of the tableau. When the initial formula is unsatisfiable, the running time of our algorithm can be high. In fact, the Proposition 3.4 gives an upper bound on the time complexity (worst case) of our method. But in practice, although it is still in test phase, its behaviour appears to be good enough. We are also working on the mechanization of the calculus FC in the generic proof-assistant Isabelle (cf. http://isabelle.in.tum.de) in order to

allow the interactive formalization of FC-proofs for temporal properties.
Additionally, we also plan to work on applying this new approach to make resolution. Up to now, the best resolution methods need to incorporate rules that only can be implemented using an invariant formula [2]. As in the tableaux case, we believe that the use of FC could improve the known resolution algorithms.

References
M. Ben-Ari, Mathematical Logic for Computer Science, Springer, second edition, (2001).
M. Fisher, A Resolution Method for Temporal Logic, IJCAI, (1991), 99–104.
J. Gaintzarain, M. Hermo, P. Lucio, M. Navarro and F. Orejas, A Cut-Free and Invariant-Free Sequent Calculus for PLTL, 21 International Workshop CSL 2007. LNCS 4646. Springer-Verlag, (2007), 481–
495.
Y. Kesten, Z. Manna, H. McGuire and A. Pnueli, A Decision Algorithm for Full Propositional Temporal Logic, CAV’93: Proceedings of the 5th International Conference on Computer Aided Verification, Springer-Verlag, (1993), 97–109.
O. Lichtenstein and A. Pnueli, Propositional Temporal Logics: Decidability and Completeness, Logic Journal of the IGPL, volume 8, number 1, (2000).
B. Paech, Gentzen-Systems for Propositional Temporal Logics, in CSL, (1988), 240–253.
http://dblp.uni-trier.de .
R. Pliuskevicius, Investigation of Finitary Calculus for a Discrete Linear Time Logic by means of Infinitary Calculus, Baltic Computer Science, (1991), 504–528, http://dblp.uni-trier.de .
A. Szalas, Temporal Logic of Programs: A Standard Approach, Time and Logic. A Computational Approach. Bolc, L. and Sza-las, A. UCL Press Ltd. (1995), 1–50.
S. Schwendimann, A New One-Pass Tableau Calculus for PLTL, In Proceedings Tableaux 98. LNAI
1397, (1998), 277–291.
P. Wolper, Temporal Logic Can Be More Expressive, Information and Control, 56, 1–2, (1983),72–99.
