Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 331 (2017) 57–70
www.elsevier.com/locate/entcs


Sparsity Preserving Algorithms for Octagons
Jacques-Henri Jourdan
MPI-SWS, Inria Paris

Abstract
Known algorithms for manipulating octagons do not preserve their sparsity, leading typically to quadratic or cubic time and space complexities even if no relation among variables is known when they are all bounded. In this paper, we present new algorithms, which use and return octagons represented as weakly closed difference bound matrices, preserve the sparsity of their input and have better performance in the case their inputs are sparse. We prove that these algorithms are as precise as the known ones.
Keywords: Numerical abstract domain, Octagon abstract domain, static analysis, static analyzer


Introduction
In order to capture numerical properties of programs, static analyzers use numerical abstract domains. The choice of a numerical abstract domain in a static analyzer is a compromise between precision, the ability of capturing complex numerical prop- erties, and performance. Non-relational abstract domains, such as intervals [6], are very efficient but relatively imprecise: they cannot represent relations between program variables. On the other hand, in order to capture numerical relations be- tween program variables, one can express them as linear inequalities. This class of relational numerical abstract domain is composed of linear abstract domains. A lin- ear abstract domain corresponds to a different precision vs. performance trade-off: they range from the less precise, efficient ones such as zones [13], pentagons [12] or octagons [13,14] to the more precise, costly ones, such as subpolyhedra [11], octahe- dra [5], two variables per inequalities [16], zonotopes [15] or general polyhedra [8].
In particular, the Octagon abstract domain [13,14] accurately represents many of the variable relationships appearing in a program, while being still reasonably fast (all the operations have quadratic or cubic complexity on the number of variables). It is very popular in the static analysis community, which explains why algorithmic improvements [3,1,17] and precision improving variants [4] are regularly published.

1 This work was supported by Agence Nationale de la Recherche, grant ANR-11-INSE-003.

http://dx.doi.org/10.1016/j.entcs.2017.02.004
1571-0661/© 2017 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

As reported by the designers of Astrée [7], its quadratic or cubic performances still make it unusable as-is with a reasonable number of variables. Indeed, the data structures typically used to represent octagonal abstract values, i.e., strongly closed difference bound matrices, have a quadratic size in the number of variables for which an upper or lower bound is known. A common solution is the use of variable packing [13, §8.4.2], where the Octagon abstract domain is only used on small packs of variables. The downside of packing is that no relation is stored between variables that are not in the same pack. A variant of packing has been introduced to mitigate the imprecision [2], but loss in precision can still occur.
The problem of the performance of octagons has already been studied: in partic- ular, Singh et al. [17] proposed an implementation of the Octagon abstract domain optimized in the case its representation is sparse. But they do not address the fact that it is dense as soon as interval bounds are known for many variables, and we anticipate that, for this reason, the sparsity is very low in their implementation.
Instead, in this paper, we propose to use new algorithms for the Octagon abstract domain: these algorithms work on a sparse representation for octagons, so that the cost of the analysis of two independent sets of variables is the sum of the costs of the analyses of the two sets of variables, taken independently. Our algorithms have the same precision as the traditional ones. Our main idea is the following: in order to ensure an optimal precision of all the operations, the data structures representing octagons, difference bound matrices, are usually kept strongly closed : that is, algorithms make sure that any returned difference bound matrix is a best abstraction. However, most often, strongly closed difference bound matrices are dense because of the necessary strengthening step. In this paper, we propose to weaken the maintained invariant on difference bound matrices and to keep them weakly closed hence skipping the strengthening step. Weakly closed difference bound matrices are not necessarily dense, so that we can use sparse data structures to represent them. We prove that some algorithms can be kept unchanged to work on weakly closed difference bound matrices without losing any precision and give new algorithms for the other operations.
We begin by preliminary definitions in §2. In §3, we describe and prove the soundness and relative precision of our new algorithms. We conclude in §4.

Definitions
Let V+ be a finite set of variables. We call a regular environment a function from V+ to R. A regular environment represents the numerical state of a program. The role of the Octagon abstract domain is to approximate sets of regular environments ρ. To that end, the abstract domain of octagons stores a set of inequalities of the following form:
±ρ(u) ± ρ(v) ≤ Cstuv	u, v ∈ V+	(1)
This corresponds to giving bounds to sums and differences of values of ρ. More- over, if we use twice the same variable with the same sign, we see that, using such constraints, we can express interval constraints over values of an environment [13].

In order to handle in a unified way all the different combinations of signs in these constraints, we introduce the set V± of signed variables. Signed variables are of two kinds: they are either usual variables from V+, called positive variables in the context of signed variables, or their opposites form, negative variables. We equip V± with an involutive operator, associating to each signed variable v its opposite v, such that v is positive if and only if v is negative.
Regular environments are canonically extended to signed variables by taking ρ(u)= −ρ(u). More generally, we define irregular environments as functions σ from V± to R, and consider the set of regular environments as a subset of the set of irregular environments. Regular environments are exactly irregular environments ρ that satisfy the property ∀v, ρ(v)= −ρ(v).
Using this new formalism, octagonal constrains of the form (1) can be seen as upper bounds on differences of values of ρ, a regular environment:
ρ(u) − ρ(v) ≤ Cstuv	u, v ∈ V±	(2)
This has two benefits: first, all the different kinds of constraints allowed by (1) get factored out as one simpler form. Second, we can see these constraints as constraints on irregular environments, and further constrain them as being regular: we see that the study of the Octagon abstract domain starts by the study of a simpler abstract domain, where only differences of variables are bounded. The set of constraints, called potential constraints, of such an abstract domain is well studied in the lin- ear optimization literature, because it corresponds to the well-known shortest path problem in a weighted directed graph.
Such a set of constraints is represented as difference bound matrices: a diﬀerence
bound matrix, or DBM, is a matrix (Buv)(u,v)∈V2  of elements of R ∪ {+∞}. The
meaning of these constraints is given by two concretization functions γpot and γoct,
that associate to a DBM the set of irregular or regular environments, respectively, satisfying all the constraints:
γpot(B)= {σ : V± → R | ∀uv ∈ V±, σ(u) − σ(v) ≤ Buv}	(3)
γoct(B)= {ρ ∈ γpot(B) | ∀u ∈ V±, ρ(u)= −ρ(u)}	(4)
Example 2.1 Consider V+ = {x; y; z} a set of three (positive) variables. The set of signed variables is V± = {x; x; y; y; z; z}. Let A be the DBM such that Axx = 1, Ayy = 3, Ayz =1 and Auv = +∞ for all the other entries. The set γoct(A) contains all the environments ρ : V± → R such that:
∀u ∈ V±, ρ(u)= −ρ(u)
ρ(x) ≤ 1/2, −ρ(y) ≤ 3/2 and ρ(y)+ ρ(z) ≤ 1
This concretization is assimilated to the set of environments ρ : V+ → R over positive variables such that ρ(x) ≤ 1/2, −ρ(y) ≤ 3/2 and ρ(y)+ ρ(z) ≤ 1.
We denote as  ≤ the natural order relation over DBMs, defined as follows:
A ≤ B ⇔ ∀uv ∈ V±, Auv ≤ Buv	(5)

The following easy lemma states that this order relation makes γpot and γoct increas- ing, which makes ≤ a good candidate for a comparison operator of the Octagon abstract domain 2 :
Lemma 2.2 Let A and B be two DBMs such that A  ≤ B. Then, we have:
γpot(A) ⊆ γpot(B)	γoct(A) ⊆ γoct(B)
For any non-empty set S of irregular environments, there exists a minimal (in the sense of ≤) DBM that approximates it. That is, there exists a minimal DBM α(S) such that S ⊆ γpot(α(S)). This property follows immediately from the definition of α:
α(S)uv = sup{σ(u) − σ(v)}	(6)
σ∈S
This function α is called the abstraction function. We can easily see that α is an increasing function. Moreover, α does not only return best abstractions for γpot, but also for γoct: if the set S contains only regular environments, we can see that α(S) is also the minimal DBM such that S ⊆ γoct(α(S)). In fact, it is easy to see that
 ≤ defines a complete lattice over DBMs extended with a bottom element, and that the pairs (α, γpot) and (α, γoct) form Galois connections.
Closure and Strong Closure
Many DBMs have the same concretization. This is a problem, because the abstract environments that we manipulate are therefore not necessarily the most precise ones, and this can lead to imprecision. Thus, usually, an implementation of the Octagon abstract domain maintains the invariant that it only manipulates “canonical” forms of DBMs, such that B = α(γoct(B)). Such “canonical” DBMs are always the best possible representative over all the DBMs with the same concretization.
An important fact is that we can characterize best abstractions using the values they contain, and that we have algorithms to compute them. We expose these char- acterizations, together with these algorithms. Moreover, we give a weaker closedness condition over DBMs, that does not ensure canonicity, but that allows better algo- rithms without loss of precision.
Best abstractions for γpot
A first step is to remark that canonical DBMs always have null diagonal values. Moreover, canonical DBMs should always verify the triangular inequality. We call such DBMs closed DBMs:
Definition 2.3 [Closed DBM] A closed DBM is a DBM B verifying the two follow- ing properties:
∀v ∈ V±, Bvv =0 
∀uvw ∈ V±, Buw ≤ Buv + Bvw

2 As we see in §3.1, this is not the order relation we use as a comparison operator in our implementation of the Octagon abstract domain.

Closed DBMs are exactly best abstractions for γpot [13, Theorem 3.3.6]. Hence, closed DBMs always have non-empty concretizations. We do not detail here the algorithm used to detect the emptiness of the concretization of a DBM and to compute closures: instead, we refer the interested reader to previous work [13,1].
Example 2.4 The closure α(γpot(A)) of the DBM A as defined in Example 2.1 contains the following additional finite entries:
6u ∈ V±, α(γpot(A))uu =0 
α(γpot(A))y z =4 (corresponding to the constraint ρ(z) — ρ(y) ≤ 4).
Best abstractions for γoct
We now refine the notion of closure to canonical forms for γoct. It is easy to see that, for any non-empty set S of regular environments, α(S)uv = α(S)v u. Thus, canonical DBMs for γoct will verify the coherence property:
Definition 2.5 [Coherent DBM] A DBM B is coherent when:
6uv ∈ V±, Buv = Bv u
Moreover, matrix elements of the form Buu (for u ∈ V±) impose interval con- straints on values of ρ. These interval constraints can be combined to entail con- straints on any difference of values of ρ. For this reason, canonical forms for γoct will verify the following strong closedness property:
Definition 2.6 [Strongly closed DBM] A DBM B is strongly closed when it is closed and coherent and:

6uv ∈ V±, Buv
≤ Buu + Bvv
2

This condition is necessary and sufficient: strong closedness characterizes canon- ical DBMs for γoct.
Theorem 2.7 Let B be a DBM. The two following properties are equivalent:
B is strongly closed
γoct(B) /= ∅ and B = α(γoct(B))
Proof. See, e.g., [13, Theorems 4.3.2 and 4.3.3].	2
Usually [1], to compute strong closure, one first ensures that the given matrix is coherent, then computes a closure (i.e., a canonical representative in the sense of γpot), and, finally, performing a so-called strengthening step 3 :
Definition 2.8 [Strengthening] Let B be a DBM. The strengthening of B, noted
 £(B) is defined by:

 £(B)uv
= min	Buu + Bvv ; B
2	uv

3 This is actually an improvement of the method described initially by Miné [13].

The following theorem states the correctness of the strong closure algorithm sketched above, consisting in computing a closure followed by a strengthening:
Theorem 2.9 Let B be a coherent DBM with γoct(B) /= ∅. Then:
α(γoct(B)) = £(α(γpot(B)))
In particular, if B is coherent and closed, then £(B) is strongly closed.
Proof. See, e.g., [10, Theorem 8.2.7].	2
Example 2.10 In order to consider the strong closure of the DBM A as defined in Example 2.1, we first need to make it coherent: let A˜ be the DBM containing the same entries as A, except that A˜zy = 1.
The closure of A˜ contains the following addional finite entries:
6u ∈ V±, α(γpot(A˜))uu =0 
α(γpot(A˜))zy = α(γpot(A))y z =4 (corresponding to the constraint ρ(z)—ρ(y) ≤ 4)
α(γpot(A˜))zz =5 (corresponding to the constraint ρ(z) ≤ 5/2).
The strong closure α(γoct(A˜)) is then obtained by strengthening α(γpot(A˜)). The strengthening operation creates the following new entries:
α(γoct(A˜))xy = α(γoct(A˜))y x =2 
α(γoct(A˜))xz = α(γoct(A˜))zx = 3.
Weak Closedness
Usually, the implementations of the Octagon abstract domain maintain all DBMs strongly closed, so that maximal information is known when performing an abstract operation. However, this breaks sparsity: indeed, matrix elements of the form Buu are non-relational interval bounds on the variables: as we expect many variables to be bounded, the strengthening step gives finite bounds for many DBM cells, and a strengthened DBM loses most of the sparsity. In general, a DBM has a quadratic size in the number of variables, and therefore this loss of sparsity is costly. Previous attempts at improving performances using sparsity [17] did not make this observation. We believe that, when using these implementations, DBMs quickly become dense, hence reducing the efficiency of sparse algorithms.
In our algorithms, we propose to skip the strengthening step: instead of main- taining the invariant that all the manipulated DBMs are strongly closed, we maintain the invariant that they are weakly closed:
Definition 2.11 [Weakly closed DBM] Let B be a DBM. We say that B is weakly closed when any of the two following equivalent statements hold:
B has a null diagonal and £(B) is strongly closed;
B has a null diagonal, £(B) is coherent, and:
6uvw,  £(B)uw ≤ Buv + Bvw	(7)

Proof. The proof of equivalence of the definitions is in [10, Definition 8.2.5].  2
In order to make sure we do not lose precision, we will prove for each of those operators that it computes abstract values with the same concretization as with the usual algorithms. Equivalently, we prove that the strengthening of the abstract values computed by our operators are equal to the abstract values computed by the usual operators on the strengthened parameters.
A weakly closed DBM is neither necessarily strongly closed nor closed. However, a closed and coherent DBM is always weakly closed: this helps us easily building weakly closed DBMs from arbitrary sets of octagonal constraints.
Example 2.12 Continuing on the definitions of Example 2.10, α(γpot(A˜)) is closed and coherent hence weakly closed. This DBM contains no entry relating the variable x and the other variables. This is an improvement in sparsity compared to the strong closure α(γoct(A˜)). To the best of our knowledge, this opportunity is not leveraged
by previously known algorithms, such as [17].
This notion of weak closedness has been introduced by Bagnara et al. [1, Ap- pendix A] as an intermediate notion for proving the correctness of the tight closure algorithm (see §3.5). To the best of our knowledge, the use of weak closedness as an invariant for manipulating sparse DBMs is an original result of our work.

Operations on Difference Bound Matrices
The abstract domain of octagons defines several operations manipulating difference bound matrices. They include lattice operations, like comparison and join, and abstract transfer functions, which model state change in the program.
In this section, we recall the standard definition of these operations, and give the new sparsity-preserving definition on weakly closed DBMs. All these algorithms preserve the sparsity and weak closedness of DBMs and can be proved to be as precise as the standard ones. More precisely, we claim that they always return DBMs whose strengthening equals the DBMs that would have been returned by the traditional algorithms. The implementation of the widening operation, detailed in [10, Section 8.2.7], is more complex and omitted by lack of space.

Comparison
In order to use octagons in a static analyzer, we need to define a comparison operator, taking two DBMs and returning a Boolean. If this Boolean is true, then we have the guarantee that the concretization of the first operand is included in that of the second operand.
A good candidate is ≤, the natural order relation between DBMs. Its soundness is guaranteed by the monotonicity of γoct. In usual implementations of the Octagon abstract domain, DBMs are kept strongly closed, hence this operator is actually as precise as possible: it returns true if and only if the concretizations are included.

However, in the setting of weakly closed DBMs, this property does not hold. In order not to lose precision while still using sparse DBM, we need another comparison operator that strengthens the bounds of the left operand when they do not entail the right operand:
Definition 3.1 [Weakly closed comparison] Let A and B be DBMs. The weakly closed comparison of A and B, noted A ≤weak B is defined by:


A  ≤

B ≡	 

A	≤ B
∨ Auu + Avv ≤ B

weak
uv	uv	2	uv
u,v∈V± Buv<+∞

That is, for every finite bound on B, we first check whether it is directly entailed by the corresponding bound in A, and then try to entail it using non-relational bounds. The following theorem states that it implements the comparison on con- cretizations, hence we can use it in a sparse context without losing precision:
Theorem 3.2 Let A a weakly closed DBM and B any DBM. The two following statements are equivalent:
γoct(A) ⊆ γoct(B)
A ≤weak B
Proof. See, e.g., [10, Theorem 8.2.9].	2
Forgetting Variables
An important operation provided by the Octagon abstract domain is forget. When given a DBM and a variable v, it returns another DBM where all the information on v has been forgotten. Its concrete and abstract definitions are given by:
Definition 3.3 [Concrete forgetting] Let x ∈ V+ and S be a set of regular environ- ments. We define:

x oct
= {σ + [x ⇒ r; x ⇒ —r] | σ ∈ S, r ∈ R}

Definition 3.4 [Abstract forgetting]
Let x ∈ V± and B be a DBM. We define Fx
(B) the DBM such that:

  x
pot
(B)uv =
0	if u = v = x
+∞	otherwise if u = x or v = x
⎪⎩Buv	otherwise

Let x ∈ V+ and B a DBM. We define:

  x
oct
(B) = Fx


  x
pot
(B))

It is a known result from the Octagon literature [13, Theorems 3.6.1 and 4.4.2]
that  Fx	is sound when applied to any DBM. Moreover, when applied to any

strongly closed DBM, it is exact and returns a strongly closed DBM. To these
properties, we add similar properties for weak closedness, that let us use Fx  as-is
for weakly closed DBMs without loss of precision:
Theorem 3.5 Let B be a weakly closed DBM and x ∈ V+. We have:

£( Fx
(B)) = Fx
( £(B))

Fx (γoct(B)) = γoct( Fx (B))
Fx (B) is weakly closed
oct
Proof. See [10, Theorem 8.2.11].	2

Join
The usual join operator on DBMs is the least upper bound operator for  ≤:
Definition 3.6 [DBM least upper bound] Let A and B be two DBMs. The least upper bound ∪ on DBMs is defined by:
6uv, (A ∪ B)uv = max{Auv ; Buv}

The order relation ≤ and the operator ∪ clearly form an upper semi-lattice, thus usual properties on Galois connections hold, providing the usual results on the soundness and precision of this operator: ∪ is sound, and, if given strongly closed DBMs, it returns the best strongly closed DBM approximating the concrete union. For weakly closed DBMs, even though ∪ is sound, it would possibly lose precision when applied to non-strongly closed DBMs. For example, the weakly closed DBM
A represents the two following inequalities on positive variables x and y:
x + x ≤ 1	y + y ≤ 0
The weakly closed DBM B, in turn, represents the two following inequalities:
x + x ≤ 0	y + y ≤ 1
The inequality x + y ≤ 1/2 is not present in A nor in B, even though it is in £(A) and in £(B). As a result, A ∪ B contains the inequalities x + x ≤ 1 and y + y ≤ 1, but does not entail x + y ≤ 1/2, which is entailed however by £(A) ∪ £(B).
The rationale behind this example is that a join can create some amount of relationality that was not present in one or both operands. Our operator has to reflect this fact. Care should be taken, however, not to break the sparsity of the operands by introducing spurious finite values in the matrix. Our join for weakly closed DBMs is defined as follows:
Definition 3.7 [Weakly closed join for octagons] Let A and B be two weakly closed

DBMs. We take, for u, v ∈ V
, B1/2 = Buu+Bvv
and A1/2 = Auu+Avv . The weakly

±	uv	2	uv	2
closed join  ∪weak is defined in two steps:

We first define A ∪0
B. Let u, v ∈ V±. We define:

⎧⎪Auv	if Auv = Buv
max{Auv ; Buv }	if Auv < Buv ∧ Buv  < Buv
⎪
Let u, v ∈ V±. We define:

0
⎪	weak

B)uv

	if Auu

< Buu

∧ Avv

> Bvv

(A ∪
B)	= ⎨min
max A1/2 ; B1/2,
or A

			
> B	∧ A	< B 

weak
uv
⎪⎩(A ∪0
uv	uv
B)uv
uu	uu	vv	vv
otherwise

The first step can be computed by iterating over all the matrix elements that are different in A and B. This first step thus preserves the sparsity, and consumes computing time only for variables that are different in both branches. The second step can be computed efficiently by first collecting in a list all the variables u for which Auu < Buu and, in another list, all those for which Buu < Auu. By iterating over the two lists, we can efficiently modify only the cells meeting the given condition. It should be noted that we break in the second step only the sparsity that needs to be broken, as the modified cells correspond to the cases where the join create new relational information (as in the example above).
The following theorem states that this modified join operator can be used on weakly closed DBMs without losing precision or soundness:
Theorem 3.8 Let A and B be two weakly closed DBMs. We have:
£(A  ∪weak B)= £(A)  ∪ £(B)
γoct(A  ∪weak B)= γoct(α(γoct(A) ∪ γoct(B)))
A ∪weak B is weakly closed
Proof. See [10, Theorem 8.2.13].	2

Assuming Constraints
An important operation for abstract domains is the assume primitive, which refines the internal state of an abstract domain using a new assumption over the set of approximated environments. In this section, we only consider the cases where this operation is exact, i.e., it does not lead to any approximation. These cases amount to assuming that ρ(x) — ρ(y) ≤ C, for C ∈ R and x and y two variables. In order to deal with arbitrary linear inequalities or even arbitrary arithmetical constraints, it is necessary to write some supporting module for the Octagon domain that will translate arbitrary constraints into exact ones. Such a support module is out of the scope of this paper: we refer the reader to [13] for more detail. Moreover, note

that the combination of assume together with the forget let us emulate variable assignment 4 , hence we do not detail variable assignment in this paper.
We give the assume primitive in two versions: one adapted to γpot, and one adapted to γoct. We first give the concrete semantics of this operation, which is the same for irregular and regular environments:
Definition 3.9 [Assuming constraints in the concrete] Let C ∈ R, x, y ∈ V± and S
be a set of irregular environments. We define:
Ax−y≤C(S)= {σ ∈ S | σ(x) — σ(y) ≤ C}
It is easy to see that we can reflect exactly this operation in DBMs. Indeed, it suffices to change the cell corresponding to the new constraint, if the old value is larger than the new one. However, this does not maintain any kind of closedness, whether it be the normal closure, the strong closure or the weak closedness. As a result, it is necessary to run a closure algorithm when inserting the new constraint. These algorithms are costly (i.e., cubic complexity), and do not leverage the fact that the input matrix is already almost closed. For this reason, incremental closure algorithms have been developed, with quadratic complexity. We give here a slightly different presentation of these algorithms as the one originally given by Miné [13]:
Definition 3.10 [Assuming constraints in the abstract] Let C ∈ R, B be a DBM and x, y ∈ V±.
We define Ax−y≤C(B) the DBM such that, for u, v ∈ V±:
 Ax−y≤C(B)uv = min{Buv ; Bux + C + Byv}
If x, y ∈ V+, we define Ax−y≤C(B) and Ax−y≤C(B) as:
weak	oct
 Ax−y≤C (B)= Ay−x≤C ( Ax−y≤C (B))

weak
pot
pot

 Ax−y≤C (B)= £( Ax−y≤C (B))
oct	weak
It is well-known [10, Theorem 8.2.14] that Ax−y≤C is sound and exact when
applied to a DBM with a null diagonal. When applied to a strongly closed DBM B with 0 ≤ C + Byx, the result is strongly closed. Therefore, an implementation of the assume primitive in the strongly closed setting first checks whether 0 ≤ C + Byx. If so, it returns Ax−y≤C; otherwise it returns ⊥.
In particular, when applied to weakly closed DBMs, Ax−y≤C is sound and exact, since weakly closed DBMs have null diagonals. However, because this operator uses £, it breaks sparsity. The advantage of using weakly closed DBMs is that, in
the setting of weakly closed DBMs,  £ is no longer needed:  Ax−y≤C can be used
as-is, provided the implementation additionally checks that 0 ≤ 2C + Byy + Bxx. The following theorem summarizes this result, and justifies the use of this transfer function in the context of sparse DBMs without loss of precision:

4 An eﬃcient implementation would however use a specific, optimized implementation for assignments.

Theorem 3.11 Let C ∈ R, B a weakly closed DBM and x, y ∈ V+. We have:
If 0 ≤ 2C + Byy + Bxx, then £( Ax−y≤C(B)) = Ax−y≤C( £(B))

weak
γoct( Ax−y≤C(B)) = Ax−y≤C(γoct(B))
oct

If B is weakly closed, the following statements are equivalent:
Ax−y≤C(γoct(B)) /= ∅
0 ≤ Ax−y≤C(B)xx
0 ≤ C + Byx and 0 ≤ 2C + Byy + Bxx
Ax−y≤C(B) is weakly closed.
Proof. See, e.g., [10, Theorem 8.2.15].	2
Tightening
Miné [13] and Bagnara et al. [1] study the case of the Octagon abstract domain when the considered environments take only values in Z: in contrast with the previous sections, in this case, the strongly closed DBMs are not all canonical, so that modified algorithms need to be used. We explain here that the use of the weakly closed setting is compatible with the integer case. To this end, we define a different concretization
function, γZ , that concretizes to integer environments:
Definition 3.12 [Integer concretization of octagons] Let B be a DBM. We define:

Z
oct
(B) = {ρ ∈ γoct(B) | 6u ∈ V+, ρ(u) ∈ Z}

If we consider only integer environments, best abstractions have a slightly stronger characterization. Such DBM are said tightly closed. We also define the notion of weakly tightly closed DBMs, which is the analog of weakly closed DBMs for the integer case:
Definition 3.13 [Tight closure] Let B be a DBM. B is tightly closed (respectively weakly tightly closed) when:
B is strongly closed (respectively weakly closed)
6uv ∈ V±, Buv ∈ Z

6u ∈ V±, Buu ∈ Z
Tightly closed DBMs are exactly best abstractions for integer environments [10, Theorem 8.2.17]. Bagnara et al. [1, §6] give efficient algorithms for computing the tight closure of a DBM. It consists in using a tightening operation before strength- ening. The tightening operation is defined by:
Definition 3.14 [Tightening] Let B a DBM with elements in Z. We define T (B)
be the DBM with elements in Z such that, for u, v ∈ V±:


 T (B)uv


=	Buv — 1	if u = v and Buv is odd
Buv	otherwise

The following theorem gives the essential property of the tightening operation:
Theorem 3.15 Let B a weakly closed DBM with elements in Z. We suppose that
6u ∈ V±, 0 ≤ T (B)uu + T (B)uu. Then T (B) is weakly tightly closed.
Proof. See, e.g., [10, Theorem 8.2.18].	2
This theorem has two consequences. First, as already explained by Bagnara et al. [1, §6], it gives an efficient algorithm to compute tight closure: one would compute the closure of the input matrix, then tighten it and finally strengthen it. Second, our sparse algorithms need only small adjustments when used with integer environments: instead of maintaining the DBMs weakly closed, we just have to make them weakly tightly closed by tightening them after each operation.
Note, however, that tightening does not address the case of mixed environments, where some variables are known to have integer values, and some others can have an arbitrary real values. To the best of our knowledge, there is no known efficient closure algorithm supporting this use case, even in the dense setting.

Conclusion
In this paper, we presented new algorithms for the Octagon abstract domain, which preserve the sparsity of the representation of octagons. These algorithms are as precise as the usual ones, and rely on a weaker invariant over difference bound matrices, called weak closedness. We have shown that these algorithms can be used in the context of rational or real environments as well as in the context of integer environments.
We implemented and formally verified in Coq these algorithms in the context of the Verasco static analyzer [9,10,18]. The use of these new algorithms improved the performances of the Octagon abstract domain by at least one order of magnitude.
There are still possible improvements to these algorithms: in particular, we think that it could be profitable to sparsify difference bound matrices as much as possible after each abstract operation, while still maintaining them weakly closed. Indeed, abstract operations may infer bounds in difference bound matrices that can actually be deduced from non-relational bounds, therefore missing opportunity of sparsity.
We think the reduction algorithm presented by Bagnara et al. [1] can be adapted to compute reduced difference bound matrices using only weakly closed difference bound matrices. This would lead to a simpler widening algorithm based on a seman- tic definition as described by Bagnara et al. [1, §4.2]. We believe the implementation of these new algorithms in state-of-the-art static analyzers, by using, for example, the framework developed by Singh et al. [17] would lead to a significant performance improvement.

References
Bagnara, R., P. M. Hill and E. Zaffanella, Weakly-relational shapes for numeric abstractions: Improved algorithms and proofs of correctness, Formal Methods in System Design 35 (2009), pp. 279–323.

Bouaziz, M., TreeKs: A functor to make numerical abstract domains scalable, in: NSAD, ENTCS 287
(2012), pp. 41–52.
Chawdhary, A., E. Robbins and A. King, Simple and eﬃcient algorithms for octagons, in: APLAS, LNCS 8858 (2014), pp. 296–313.
Chen, L., J. Liu, A. Miné, D. Kapur and J. Wang, An abstract domain to infer octagonal constraints with absolute value, in: SAS, LNCS 8723 (2014), pp. 101–117.
Clarisó, R. and J. Cortadella, The octahedron abstract domain, in: SAS, LNCS 3148 (2004), pp. 312– 327.
Cousot, P. and R. Cousot, Static determination of dynamic properties of programs, in: Proceedings of the Second International Symposium on Programming (1976), pp. 106–130.
Cousot, P., R. Cousot, J. Feret, L. Mauborgne, A. Miné and X. Rival, Why does astrée scale up?, Formal Methods in System Design 35 (2009), pp. 229–264.
Cousot, P. and N. Halbwachs, Automatic discovery of linear restraints among variables of a program, in: POPL (1978), pp. 84–96.
Jourdan, J., V. Laporte, S. Blazy, X. Leroy and D. Pichardie, A formally-veriﬁed C static analyzer, in:
POPL, ACM, 2015, pp. 247–259.
Jourdan, J.-H., “Verasco: a Formally Verified C Static Analyzer,” Ph.D. thesis, Université Paris Diderot (2016).
Laviron, V. and F. Logozzo, Subpolyhedra: A (more) scalable approach to infer linear inequalities, in:
VMCAI, LNCS 5403 (2009), pp. 229–244.
Logozzo, F. and M. Fähndrich, Pentagons: a weakly relational abstract domain for the eﬃcient validation of array accesses, in: SAC, ACM, 2008, pp. 184–188.
Miné, A., “Weakly relational numerical abstract domains,” Ph.D. thesis, École Polytechnique (2004).
Miné, A., The octagon abstract domain, HOSC 19 (2006), pp. 31–100.
Putot, S. and E. Goubault, Static analysis of numerical algorithms, in: SAS, LNCS 4134 (2006), pp. 18–34.
Simon, A. and A. King, The two variable per inequality abstract domain, HOSC 23 (2010), pp. 87–143.
Singh, G., M. Püschel and M. Vechev, Making numerical program analysis fast, in: PLDI, ACM, 2015,
pp. 303–313.
The Verasco formally veriﬁed C static analyzer, http://compcert.inria.fr/verasco/.
