Electronic Notes in Theoretical Computer Science 184 (2007) 21–37	
www.elsevier.com/locate/entcs

Distributing the Workload in a Lazy Theorem-Prover
David Deharbe1 ,2
Departamento de Informa´tica e Matema´tica Aplicada Universidade Federal do Rio Grande do Norte
Natal, RN, Brazil

Silvio Ranise3
Laboratoire Lorrain de Recherche en Informatique et ses Applications Institut National de Recherche en Informatique et en Automatique Nancy, France

Jorgiano Vidal4
Nu´cleo de Desenvolvimento de Software
Centro Federal de Educac¸˜ao Tecnol´ogica do Rio Grande do Norte Natal, RN, Brazil


Abstract
Automated theorem proving consists in automatically (i.e. without any user interaction) discharging proof obligations which arise when applying rigorous methodologies for designing critical software systems. Re- cent developements in the so-called lazy approach in the integration of Boolean satisfiability with decision procedures for decidable theories of first-order logic have provided new means to efficiently prove or refute such proof obligations. In this paper, we present the first (known) attempt to design a distributed version of lazy theorem proving on a network of computers so that the available processing power can be used more effectively and avoid that automated reasoning be the bottleneck of the application of formal methods. Experiments clearly show the viability and the benefits of the proposed approach.
Keywords: Automated theorem proving, SMT prover, distributed computing.



1 This work has been possible partially supported by the Brazilian Research Agency, CNPq, grants number 500473/2003-0, 477960/2004-9 and 490084/2005-2.
2 Email: david@dimap.ufrn.br
3 Email: Silvio.Ranise@loria.fr
4 Email: jorgiano@cefetrn.br

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.03.013

Introduction
Formal verification tools and techniques are challenged by increasingly complex software systems. In particular, checking that a property is met by a system is the bottleneck in the application of virtually any formal design approach. One recur- ring approach to this problem consists of building a conservative abstraction of the system and check if it is satisfied. If this is the case, the original model also satisfies the property; otherwise, we are not allowed to conclude and a refinement step is un- dertaken. The abstract model is changed to take into account more details and it is checked if such a model satisfies the property of interest. This abstract-check-refine cycle is repeated until we are allowed to conclude or the available computational resources are exhausted. State-of-the-art model checkers for software verification (see e.g. [8,2]) are typical examples of this approach to verification.
These different verification activities can be carried out, at least in part, using so-called lightweight theorem provers, i.e. provers providing a high-degree of au- tomation for selected classes of formulae in decidable theories of first-order logic (FOL). Lightweight theorem provers have also been used successfully to check con- sistency of formal specification artifacts [9] and extended static checking of software code [14]. The construction of such provers has been made possible by recent ad- vances in the integration of highly efficient Boolean solvers (e.g. SAT solvers) and decision procedures for theories in FOL. This integration can be either eager or lazy. In the eager integration, the formulas are translated to propositional logic and decided using a SAT-solver (see, e.g. [6]). Their main limitation is w.r.t. flexibil- ity since the decidable theory must obey severe restrictions for the translation to propositional logic to be possible. Lazy integrations abstract atoms of formulas in FOL to propositional letters so that boolean satisfiability solvers (SAT solvers), or Binary Decision Diagrams (BDDs), can be used to extract a satisfiable propositional assignment of the abstract formula (BDDs actually compactly represent all the sat- isfiable assignments). Such an assignment is then translated back to a conjunction of literals in FOL which can then be checked valid (or not) by the available decision procedure for the first-order to which they belong. If checked valid, the process is started again by considering a new propositional assignment. Otherwise, the pro- cess halts by reporting that the first-order input formula is not valid. The lazy approach is at the basis of several recently developed tools such as Zapato [1], Ver- ifun [15], CVC Lite [3] and our tool haRVey [12]. The main advantage of lazy over eager integrations is a much higher degree of flexibility while maintaining efficiency. For example, heterogenous theories obtained by unions of “simple” theories can be considered by using well-known combination methods (see [21] for an overview). More recently, it has been shown that a carefully engineered implementation of a lazy integration can outperform the eager approach [17]. In the case of haRVey, an even greater flexibility is achieved by integrating an automated deduction engine that can be configured with finitely axiomatizable theories.
The paper presents the first distributed approach to lightweight theorem prov- ing based on the following simple observation. If we consider n (> 1) propositional assignments at the same time and we invoke n instances of the decision procedures

on their first-order counterparts (as sketched above), we can hope to significantly reduce the overall running time of the reasoning system. As it is well-known in distributed computing, to make this observation practical, special care must be put into choosing a suitable number n of instances of the decision procedures. Another open question is the choice of the n propositional assignments that provide best results. As experimentation is a mean to validate answers to these questions, we have implemented a distributed version of haRVey which exploits the above obser- vation. Our implementation uses the ToolBus architecture [4] which allowed us rapid prototyping. This paper presents an experimental analysis with this prototype on a set of representative proof obligations showing the viability of the proposed ap- proach. In particular, we study the impact on performances of different approaches in choosing n propositional assignments to be considered at the same time.

Plan of the paper.
Section 2 gives some background material on the ToolBus architecture. Section 3 explains the basic algorithm underlying haRVey. It also explains how a distributed algorithm has been derived from the original sequential version. Section 4 describes our prototype implementation of a distributed variant of haRVey. Section 5 re- ports on the experiments. Finally, Section 6 concludes and sketches our research directions.

The ToolBus
The construction of a heterogenous, distributed system is a challenging task, both from a design and implementation point of views. The ToolBus provides an ele- gant solution to implement robust distributed systems, using a process algebra as language to describe the protocol between the different components, and a uniform, term-like, communication data type called Aterms, which is also used in haRVey to represent logic formulas. In this section, we provide the reader with just the information necessary to understand how haRVey components may be distributed and interconnected with the help of the ToolBus. Further details can be found in
e.g. [4].
Programmers write a ToolBus script describing the intended interaction pro- tocol between the components, called tools. Scripts are then directly executable by the ToolBus interpreter. Moreover, the ToolBus suite provides utilities to automatically generate the interfaces that each tool has to implement to participate in the protocol. Currently, there is support for the programming languages JAVA and C (adapters are also available for Perl, Python, Tcl/Tk and UNIX scripts).

A ToolBus
script defines an interaction protocol between different (user-

supplied) tools by means of a composition of processes. We will adopt the term
tool bus to denote an instance of such protocol.
The ToolBus scripting language provides the classic process algebra constructs:
+ for choice, . for sequential composition,  for parallel composition, * for repetition,
if then [else] fi for guarded command, and delta to represent deadlock. Moreover,

the create operator dynamically creates process instances; finally, execute and snd- terminate respectively spawns and aborts the execution of a tool instance.
The execution of a tool can be dispatched from within the tool bus, with the command execute, or can be started externally and issue a connection request to the tool bus, that may accept such connection requests with the rec-connect command. Once connected to the tool bus, tools do not communicate directly. Instead, com- munication channels are established between tools and processes, or between pro- cesses. The communication between processes can be synchronous, using matching send-msg and rec-msg commands, or asynchronous, with the send-note broadcasting command, which can be received using the rec-note command from all processes
that had previously issued a subscribe command on the corresponding label.
Processes use handshaking to communicate with the tools. The tool-to-process communication can be either a send-event message (notifies an event) or a send- value message (sends a value), while the communcation from a process to a tool can be one of the following three commands: snd-eval (evaluation request), snd- do (action request, i.e. without return value), or snd-ack-event (acknowledges a previous event).
All the communication commands may have typed parameters and return re- sults. To distinguish between input and output parameters, the latter are decorated with the symbol ? as suffix.
To illustrate these concepts, Figure 1 presents the definition of a tool bus pro- viding the glue between a graphical user interface and the command-line UNIX calculator calc. The tool bus is composed of these two tools and two processes. The first process, named CALC (defined lines 1–11) mediates requests for numeric com- putations to a command-line calculator: it spawns the calculator tool and assigns the corresponding identifier to Tid (line 04), then repeatedly receives a message on channel compute and assigns its value to E (line 05), sends it for evaluation to the tool (line 06), gets the answer in variable V (line 07), forwards it along channel compute (line 08), and also broadcasts it to any interested party (line 09). The second process, called UI, is responsible to get expressions to be calculated from the user: it spawns a graphical user-interface gui tool (line 15), and then repeatedly receives expressions from the interface, transmits them to the calculator, gets the corresponding value, and forwards it back to the user interface (lines 16 to 20), until it gets a command to quit the application (line 21). Finally, both tools are configured with actual applications (lines 25 and 26).


The lightweight theorem-prover haRVey
haRVey [12] checks if a first order formula ψ (possibly containing quantifiers) is a logical consequence of a theory T which can be finitely axiomatized. For simplicity, in this paper, we will assume that ψ is of the following form ∀x1, ..., xn.φ, where x1, ..., xn are the only variables occurring in φ which is required to be quantifier-

process CALC is
let Tid: calc, E: str, V: term
in
execute(calc, Tid?) .
(	rec-msg(compute, E?) .
snd-eval(Tid, expr(E)) .
rec-value(Tid, val(V?)) .
send-msg(result, E, V) .
send-note(result(E, V))
) * delta
endlet
process UI is
let UI : ui, E, V : str,
in
execute(gui, UI?) .
(	rec-event(UI, expr(E?)) .
snd-msg(compute, expr(E)) .
rec-msg(result, expr(E, V?)) .
snd-ack-event(UI, expr(E, V))
20	)* 
rec-event(UI, quit) .
snd-ack-event(UI, quit) .
shutdown(”Goodbye!”)
endlet
tool calc is { command = ”calc” }
tool gui is { command = ”wish-adapter -script ui.tcl” }
Fig. 1. Excerpt of a ToolBus script
free 5 . haRVey works by refutation, i.e. it negates the formula ψ and tries to show that this negation is T -unsatisfiable, i.e. that models of T do not satisfy ¬ψ. Under the assumptions above on ψ, ¬ψ is ∃x1, ..., xn.¬φ and hence we consider the problem of determining the T -unsatisfiability of ¬φ where each xi is considered as a (Skolem) constant.
haRVey is based on a combination of Boolean solving and superposition theorem proving. The core algorithm of haRVey is presented in Figure 2. Let fol2prop be a bijective mapping from ground atoms of φ to boolean propositions, abs its homomorphical extension to ground formulas, and prop2fol the inverse mapping from boolean propositions to ground atoms. φ is first univocally abstracted to a propositional formula φa and a Boolean solver finds satisfiable assignments to this abstraction. Each such assignment βa is then translated back to a conjunction l1∧·· ·∧ln of ground first-order literals, which can be checked for T -(un)satisfiability, using a superposition-based reasoning wrapped into the function fol check unsat . This is actually implemented by simply feeding a third-party superposition-based

5 Readers interested in the technical details on the elimination of quantifiers are referred to [9].

prover with the axioms of 7 and the set {{li}}i=1,...n of unit clauses. A refinement of this schema which dramatically improves performances (based on the capability of generating suitable lemmas to prune the search space of the Boolean solver) is actually implemented in haRVey. The function fol check unsat is extended so that also a small unsatisfiable sub-formula of the input conjunction of ground literals is returned. More precisely, we assume that fol check unsat (7 , β)= (T, π) iff π is a sub-formula of β and π is 7 -unsatisfiable. π is called the proof of the assignment β. Using π to constrain the formula φ, several assignments can be discharged at once, resulting in often dramatically better results.

function check unsat (T: theory ; φ: formula)
φa ←— abs(φ)
while φa /= ⊥ do begin
βa ←— pick assignment (φa)
(ρ, π)←— fol check unsat (T, prop2fol (βa))
if ρ /= T then return no
φa ←— φa Λ чfol2prop(π)
end return yes
Fig. 2. The core algorithm of haRVey.


A key feature of haRVey with respect to other lazy theorem provers is the fact that the decision procedure is based on superposition-based automated deduction, which makes it possible to apply it to verify the validity of a formula in any finitely presentable background theory. This feature also provides the possibility to handle nicely the verification of formulas with quantifiers [9]. In the current develope- ment version of haRVey, boolean satisfiability can be realized with BDDs [5] or the SAT-solver zchaff [18], and first-order reasoning is a combination a la Nelson and Oppen [19] of the superposition-based E prover [22] and a decision procedure for a fragment of linear arithmetics. So far haRVey has been successfully applied to the verification of pointer-based programs [20], B specifications [9], static checking of automatically generated code for aerospatial applications [13] as well as array programs [11].

Distributed Algorithm
By considering Figure 2, it is not difficult to see how to obtain a distributed version of the algorithm. The key idea is to consider n (> 1) propositional assignments concurrently and invoke n instances of the decision procedures on their first-order counterparts (as sketched above); in this way, we can hope to significantly reduce the overall running time of the reasoning system. Indeed, to make this observation practical, particular care must be put in choosing a suitable value for n.




(7 , φ)
ˆ
yes/no





(7 , βa)v
⊥ˆ/(T, π1)
(7 , βa)v
⊥ˆ/(T, π2)


··· 

(7 , βa)v
⊥ˆ/(T, πn)


Fig. 3. Schematic architecture of distributed haRVey.
Overview of the architecture
The first step in designing the distributed version of haRVey is to identify the different components (or tools, in ToolBus terminology) that can be distributed over a network, with the following restrictions in mind:
The distributed version shall be scalable so that it can take advantage of having a large or a small number of nodes.
The communication overhead in the distributed version shall be minimal, so the data shared between the different components shall be as little as possible.
The distributed and the sequential versions of the tool shall have as much code in common as possible, in order to limit maintenance problems.
We have therefore split haRVey into the following components, as illustrated in the interaction diagram depicted in Figure 3:
interface: It is responsible for receiving proof obligations from interested clients and returns the result of the verification. Even though we could imagine having several instances of the interface, it only complicates the protocol and does not offer much insight on how a distributed lazy theorem prover performs.
propositional reasoning: The component will maintain the propositional ab- straction of the given proof obligations, generate assignments, and send them to the instances of the first-order reasoning component. As the data structures nec- essary to handle propositional reasoning are quite complex and intertwined (be they BDDs or a SAT-solver), we chose to have a single instance of this component.
first-order reasoning:  This is the component responsible to verify if assignments are indeed satisfiable or invalid. As it is necessary to carry out several independent verifications of this type, we identified that this component is candidate to be replicated in a distributed algorithm.
The interaction between these components is modeled after two well-known pat- terns of distributed programming. First, the interaction taking place between the interface and the propositional reasoning tool follows the client/server pattern, while the interaction occuring between the propositional reasoning component, and the

tool master-server is { command = ”prop-reasoning” }
tool slave is { command = ”fol-reasoning” }
tool client is { command = ”reasoning” }
Fig. 4. Declaration of the components in the distributed haRVey tool bus.
first-order reasoning instances follows the master/slave pattern. Figure 4 presents the declaration of the three corresponding tools in the ToolBus script.
Description of the tool bus protocol
The main process.
The top-level process is presented in Figure 5. It spawns an instance M of the propositional reasoning tool master-server (line 04), and then repeatedly presents one of the two following behaviours:
A connection request from an instance S of the first-order reasoning tool slave is handled in process ConnectSlave (line 05).
The reception of a new proof obligation is dealt with in process Check (line 07).
This loop is exited when M emits a quit event (i.e. when it has completed the verification), at which point the process is stopped (lines 09 and 10).

Establishing new master-slave connections.
The process ConnectSlave (see Figure 6) is the sub-process of the main process responsible for the connection between a new instance S of the first-order reasoning tool slave and the instance M of the tool master-server. It sequentially receives a connection request from S (line 04), creates an instance of the process Slave (described below) which is attached to S, gets the corresponding process identifier Pid (line 05), and notifies asynchronously the master M that a new slave is available, sending a message parameterized with the value of Pid (line 06).

Interface with instances of the first-order reasoning tool.
The process Slave (see Figure 7) describes the part of the protocol related to interfacing one instance S of the slave tool responsible to carry out first-order rea- soning. It is responsible for handling two types of events:
Verification requests are emitted from the Check process via a folCheckUnsat mes- sage (line 08), are dispatched to be evaluated to the slave tool S (lines 09 and 10). The result is then sent back through a folCheckUnsatResults message (line 11).
Initialization requests, parameterized with the set of theory axioms, are forwarded to S, via a folInit message (lines 13 and 14).

Handling proof obligations.
Process Check (see Figure 8) mediates the communications between the three types of tools to coordinate the verification of a proof obligation. In a first phase,

process Main is
let M : master-server,
in
execute(master-server, M?) .
(ConnectSlave(M)
06	+
Check(M)
)* 
rec-event(M, quit) .
shutdown(”Checker is closed”)
endlet
toolbus(Main)
Fig. 5. The main process
process ConnectSlave(M: master-server) is
let Pid : int, Name : str, S : slave
in
rec-connect(S?) .
create(Slave(S), Pid?) .
snd-do(M, slaveCreate(Pid))
endlet
Fig. 6. Establishing a connection with a new slave
process Slave(S: slave) is
let Assignment, Theory: term,
ProofStatus: int,
ProofLiterals: term
in
(	(rec-msg(folCheckUnsat(S, Assignment?)) .
snd-eval(S, folCheckUnsat(Assignment)) .
rec-value(S, folCheckUnsat(ProofStatus?, ProofLiterals?)) .
snd-msg(folCheckUnsatResult(S, ProofStatus, ProofLiterals)) )
12	+
(rec-msg(folInit(S, Theory?)) .
snd-do(S, folInit(Theory)) )
) * delta
endlet
Fig. 7. Process mediating communications with a slave tool

it accepts a connection request from a client tool C (line 08), sends it the message propCheckUnsat and gets the parameters of the verification: theory axioms and goal formula (lines 09 and 10). These parameters are forwarded to the master-server tool M (line 11). The process enters then in the second phase, which is the main loop of the distributed algorithm (lines 12 to 19), until it gets signaled by M that

the verification has completed (line 20), then forwards the result to the client and terminates it (lines 21 and 22). The main loop is a choice between two behaviours:
First (lines 12 to 15), M can emit a new assignment to be checked for unsatisfiabil- ity by some slave first-order reasoning tool S. S is then initialized and signaled this new verification task. M is sent an acknowledgement as soon as the verification has been started.
Second, and conversely, (lines 17 and 18), a slave first-order reasoning tool S may return the result of the verification of a previously sent assignment. This result is then forwarded to M.
The verification in the slave tools is done asynchronously with respect to the master tool. It is up to the master to create new assignments and dispatch them to slaves that have previously been connected to the tool bus. A detailed description of the inner workings of the master-slave tool is presented in the next section.
process Check (M:master-server) is
let C: client, S: slave,
CTheory, CGoal: term,
MAssignment, MTheory: term,
SProofStatus: int, SProofLiterals: term,
FinalResult: int,
in
rec-connect (C?) .
snd-eval(C, propCheckUnsat) .
rec-value(C, propCheckUnsat(CTheory?,CGoal?)) .
snd-do(M, propCheckUnsat(CTheory,CGoal)) .
(	(rec-event(M, folCheckUnsat(S?,MAssignment?, MTheory?)) .
snd-msg(folInit(S,MTheory)) .
snd-msg(folCheckUnsat(S,MAssignment)) .
snd-ack-event(M,folCheckUnsat(S,MAssignment)) )
16	+
(rec-msg(folCheckUnsatResult(S?,SProofStatus?,SProofLiterals?)) .
snd-do(M,folCheckUnsatResult(S,SProofStatus,SProofLiterals)) )
19	) * 
rec-event(M, checkEnd(FinalResult?)) .
snd-do(C, checkEnd(FinalResult)) .
snd-terminate(C,FinalResult)
endlet
Fig. 8. Process handling verification requests


Description of the components of distributed haRVey
This section provides details on the inner workings of each of the three tools that compose the distributed version of haRVey. The client interface and the first-order

reasoning slave basically consist in wrapping the corresponding functionalities im- plemented in the sequential version of haRVey. For instance, the slave has just to invoke the routine fol check unsat (as in Figure 2) when it receives a message labelled folCheckUnsat.
However, for the propositional reasoning master-server, the situation is not so simple. A new assignment has to be dispatched whenever a slave instance is idle. So the master-server must maintain the set S of the available first-order reasoning slaves, the set B ⊆ S of the busy slaves, the theory 7 of the current proof obligation, a propositional formula φ to represent the assignments that have not yet been checked for unsatisfiability, and another propositional formula ψ to maintain the assignments that have not yet been dispatched to some slave.
The master-server must therefore be able to generate several different models from a propositional formula. Now, recall that haRVey can either use a SAT-solver or a BDD-based representation for the propositional reasoning. Contemporary SAT- solvers, based on evolutions of the Davis and Putnam algorithm [10], are not de- signed to provide several satisfying assignments and it would be necessary to make significant alterations to adapt an existing tool to our needs. In the case of BDDs, the situation is much simpler: each branch from the root node to the true leaf is a satisfying assignment (indeed a BDD is no more than a compact representation of all possible assignments). Moreover, although SAT-solvers are able to handle much larger formulas than BDDs, the complexity of the propositional structure in the proof obligations generated for software verification is usually simple enough to be handled easily with BDDs. Finally, using SAT-solvers require converting formulas to clausal normal form, introducing extra propositional variables, and eventually makes harder the reasoning in the background theories. Thus, in this first attempt at exploring the potential of distributed lazy theorem proving, we opted to use a BDD based representation.
The main routine of the master-server tool is shown in Figure 9. The set of slaves is initialized and the event handling loop is started. The following messages are handled in this loop (the implementation of the event-handling part of the code is automatically generated by the ToolBus):
slaveCreate The message happens when a new instance of the slave first-order reasoning tool connects to the tool bus (line 06 of Figure 6). The routine handling this message is given in Figure 10.
propCheckUnsat The message occurs when the client user-interface tool has sent a new proof obligation to the tool bus (line 11 of Figure 8). Figure 11 contains the routine handling this message: the state variables are updated with the proof obligation, and the auxilixary routine dispatch is invoked. This routine is respon- sible for dispatching new assignments to idle slaves and is detailed in Figure 12. It first checks that there are assignments that have not yet been checked. If this is the case, then for each idle slave, a new assignment is constructed (using the same routine as in the sequential algorithm) and dispatched. Otherwise, no as- signments have been shown unsatisfiable (see next paragraph) and the result is that the given formula g is 7 -unsatisfiable.

folCheckUnsatResult This message happens when a slave tool returns a result (line 11 of Figure 7). The corresponding routine is given in Figure 13. First, the outcome of the verification is tested: if the assignment is unsatisfiable, then the (smaller) unsatisfiable subset π of the assignment is used to prune both φ and ψ, as in the sequential case, and a new assignment is dispatched as explained above. Otherwise, the whole verification is ended with an checkEnd message. In this case, the result is that the formula g is 7 -satisfiable.

Experimental results
The distributed version of haRVey, as described in the previous section, has been implemented and tested in a small network of workstations. We report on two experiments that we have carried out. First, we present in Section 5.1 different approaches to choose the assignment. As a matter of fact, as this choice has a direct impact on how much the propositional formula gets pruned, it may affect the efficiency of the verification. Second, in Section 5.2, we present the speed-up obtained with the distributed version of haRVey considering a varying number of available slaves.
These experiments have all been carried out in an 10Mbps Ethernet network, in a normal working environment, where all the tools had to compete for resources with other user processes. The examples composing the benchmarks have been collected from different protocol and software verification examples. Indeed, we used proof obligations generated from the B methodology [9], the formalization of the Burns mutual exclusion protocol, and the verification of pointer-manipulating programs [20]. This benchmark has been composed of proof obligations requiring several interactions between the propositional and first-order reasoning engines.

Assignment choice
We have developed several approaches to choose a (satisfying) assignment from the propositional abstraction of a formula. As distributed haRVey only uses BDDs, we have developed these approaches for BDDs. We recall that an assignment is represented in a BDD as a branch from the root node to the leaf node for the constant true. Traversing the BDD to find an assignment is straightforward and basically consists in recursing down the graph up to a node that has a true child node. The complexity is thus O(n), where n is the number of atoms in the verified formula.
The goal of the assignment choice approaches is to find assignments such that, if they are shown unsatisfiable, their proof can be used to prune as large a number of assignments as possible. Indeed, if two similar assignments are verified, it is reasonable to expect that their proof would prune the same portion of the search space in the propositional representation. With these ideas in mind we developed four different approaches. The rightmost approach is the most simple, and was originally implemented in sequential haRVey: the BDD is recursively traversed down

function master server main () B, S ←— ∅, ∅ HandleEvents()
Fig. 9. The main routine of the master-server.
function slaveCreate (s: slave)
S ←— S ∪ {s}
Fig. 10. The routine handling slaveCreate messages.
function propCheckUnsat (O: options, T : theory, g: formula)
φ, ψ ←— g, g
7 ←— T
dispatch()
Fig. 11. The routine handling propCheckUnsat messages.
function dispatch ()
if φ then
while B — S /= ∅Λ ψ do
let s ∈ (B — S), α ← pick assignment (ψ) in
ψ ←— ψ Λ чα B ←— B ∪ {s}
send(folCheckUnsat(s, α, 7 ))
end end
else
send(checkEnd(T))
end
Fig. 12. The auxiliary routine dispatch.
function folCheckUnsatResult (s: slave, r: boolean, π: formula)
B ←— B — {s}
if r then
φ ←— φ Λ чπ ψ ←— ψ Λ чπ dispatch()
else
send(checkEnd(⊥))
end
Fig. 13. The routine handling folCheckUnsatResult messages.

by picking the right child. The random approach choses randomly one of the two child nodes. The zigzag approach choses alternatively the right or the left child. Finally, in the alternate approach, the traversal produces alternatively the rightmost or the leftmost branch.


Table 1
Comparison of the assignment choice approaches (sequential case), where Ri stands for rightmost, Ra for random, Zz for zigzag, and Al for alternate.

Table 1 reports the number of assignments that need to be computed for each of these approaches on the sequential version of haRVey. No approach dominate the others, and we conclude that, in the sequential case, the assignment choice approach has no measurable impact on the average result. Indeed, when an assignment is found unsatisfiable, its proof is returned and is used to prune the search tree. This prevents other assignments with the same proof from being generated in the remainder of the search.

Performance in the distributed version
We repeated the previous experiment with the distributed version of haRVey, set up with two and four slaves. One important remark is that, due to the essentially random nature of low-level network protocols, the number of assignment checks to verify the original formula is non-deterministic in the distributed case. Indeed,

when two slaves deliver a result concomitantly, the master might receive them in a different order. This may result in different prunings, and cause the master to dispatch a different assignment at the next iteration, which ultimately explains the difference in the number of generated assignments. In our experiments, we repeated each verification several times and report here an average value of the measures.
Thus, for each of the 50 examples in our benchmark, we measured the number of dispatched branches with one (B1), two (B2) and four (B4) slaves, using the four assignment choice approaches presented in the preceding Section. To illustrate the impact of distribution, we computed the estimated speedup Sn = (n.B1)/(Bn), where n is the number of slaves.
The measured speedups are reported in Figure 14. For reference purposes, each diagram also contains two lines, corresponding to no speedup (horizontal plain line, with speedup = 1), and linear speedup (diagonal dotted line, with speedup = slaves). The closer the results are to the linear speedup, the more efficient is the distributed algorithm. We can clearly visualize that, on our bench- mark, the Random approach performs better than the three others, which present similar behavior. A plausible explanation is that Rightmost, Zigzag and Alternate tend to generate similar successive assignments (in the case of Alternate, every other assignment is generated on the same area of the BDD), which have a higher proba- bility to realize the same or similar prunings, while this is not the case for Random. Indeed, while in the sequential version, the n + 1-th assignment is generated after the pruning of the search tree with the proof generated from the n-th assignment, this is not necessarily the case in the distributed version; therefore approaches that tend to generate dissimilar consecutive assignments will always tend to perform better in the distributed version.
Finally, note that, in some experiments (mainly happening in those conducted with the Random approach), distributed theorem proving achieves super-linear speedups. This happens when the proof of unsatisfiability of an assignment is so general that it prunes a relatively large part of the search tree. This may happen for the class of formulas such that the value of a relatively small subset of the atoms causes unsatisfiability. Our experiment shows that the probability of achieving super-linear speedups is larger in the random choice assignment approach.

Conclusion
This paper presents how the lightweight theorem prover haRVey, which uses a lazy approach, can be distributed over a network of computers. The feature, unique to haRVey, that BDDs can be used to represent the propositional structure of the for- mulas to be verified has greatly simplified the realization of the distributed version. The distributed algorithm has been prototyped by distributing the code of the sequential version of haRVey into three distinct tools: user interface, propositional reasoning, and first-order reasoning. The last tool can be instantiated an arbitrary number of times in the distributed algorithm. The implementation has been real- ized using the software architecture ToolBus: a process algebra script describes




4
2
1
1	2	4
4
2
1
1	2	4

(a) Rightmost	(b) Random




4
2
1
1	2	4
4
2
1
1	2	4

(c) Zigzag	(d) Alternate
Fig. 14. Speedups for the different approaches.
the tool interaction protocol and is used to generate the code responsible for the communication and synchronization, as well as the interfaces that the tools shall im- plement to participate in the interaction. Also, we developed different approaches that impact on how the workload is distributed. We validated our approach via a series of experiments that show, first, that the distributed version does indeed achieve an interesting speedup in average and, second, that the so-called Random assignment choice approach is the most efficient policy.
In the future, we plan to use the interaction protocol as a basis to a grid-based approach to lazy theorem proving. We also envision to extend or adapt the proposed protocol so that propositional reasoning can be handled with a SAT-solver, based on some existing framework for propositional logic [7,16].

References
Ball, T., B. Cook, S. K. Lahriri, and L. Zhang, Zapato: Automatic theorem proving for predicate abstraction refinement, in: Proceedings of the 16th International Conference on Computer-Aided Verification, Lecture Notes in Computer Science 3114 (2004), pp. 457–461.
Ball, T., A. Podelski and S. K. Rajamani, Relative completeness of abstraction refinement for software model checking, in: Proceedings of the 8th International Conference on Tools and Algorithms for Construction and Analysis of Systems, Lecture Notes in Computer Science 2280 (2002), pp. 158–172.
Barrett, C. and S. Berezin, CVC Lite: A new implementation of the cooperating validity checker, in: Proc 16th Intl. Conf. Computer Aided Verification (CAV’2004), Lecture Notes in Computer Science 3114, 2004, pp. 515–518.
Bergstra, J. A. and P. Klint, The discrete time ToolBus — a software coordination architecture, Science

of Computer Programming 31 (1998), pp. 205–229.
URL citeseer.ist.psu.edu/bergstra98discrete.html

Bryant, R., Graph-based algorithms for boolean function manipulation, IEEE Transactions on Computers C-38 (1986), pp. 677–691.
Bryant, R., S. German and M. Velev, Processor verification using efficient reductions of the logic of uninterpreted functions to propositional logic, ACM Transactions on Computational Logic 2 (2001).
Chrabakh, W. and R. Wolski, GridSAT: A Chaff-based distributed sat solver for the Grid, in: Proc. of the 2003 ACM/IEEE Conference on Supercomputing, 2003, p. 37.
Clarke, E., O. Grumberg, S. Jha, Y. Lu and H. Veith, Counterexample-guided abstraction refinement for symbolic model checking, Journal of the ACM 50 (2003), pp. 752–794.
Couchot, J.-F., D. D´eharbe, A. Giorgetti and S. Ranise, Scalable automated proving and debugging of set-based specifications, Journal of the Brazilian Computer Society 9 (2004), pp. 137–151.
Davis, M., G. Lovemand and D. Loveland, A machine program for theorem-proving, Communications of the ACM 5 (1962), pp. 394–397.
D´eharbe, D., A. Imine and S. Ranise, Abstraction–driven verification of array programs, in: Proc. of the 7th Int. Conf. on Artificial Intelligence and Symbolic Computation, Lecture Notes in Artificial Intelligence (2004), pp. 271–275.
D´eharbe, D. and S. Ranise, Light-weight theorem proving for debugging and verifying units of code, in:
Proc. of the Int. Conf. on Software Engineering and Formal Methods (SEFM03) (2003), pp. 220–228.
D´eharbe, D. and S. Ranise, Satisfiability solving for software verification, in: NASA, editor, IEEE ISoLA Workshop on Leveraging Applications of Formal Methods, Verification, and Validation, number CP-2005-212788 in Tech. Rep., 2005.
Detlefs, D. L., K. R. M. Leino, G. Nelson and J. B. Saxe, Extended static checking, Research Report 159, Compaq Systems Research Center (1998).
Flanagan, C., R. Joshi, X. Ou, and J. B. Saxe, Theorem proving using lazy proof explanation, in: Proceedings of the 15th International Conference on Computer-Aided Verification, Lecture Notes in Computer Science 2725 (2003), pp. 355–367.
Ganai, M. K., A. Gupta, Z. Yang and P. Ashar, Efficient distributed sat and sat-based distributed bounded model checking, in: Correct Hardware Design and Verification Methods (CHARME 2003), Lecture Notes in Computer Science 2860, 2003, pp. 334–347.
Ganzinger, H., G. Hagen, R. Nieuwenhuis, A. Oliveras and C. Tinelli, DPLL(T): Fast decision procedures, in: R. Alur and D. Peled, editors, Proceedings of the 16th International Conference on Computer Aided Verification, CAV’04 (Boston, Massachusetts), Lecture Notes in Computer Science 3114 (2004), pp. 175–188.
URL  ftp://ftp.cs.uiowa.edu/pub/tinelli/papers/GanHNOT-CAV-04.pdf

Moskewicz, M., C. Madigan, Y. Zhao, L. Zhang and S. Malik, Chaff: Engineering an efficient sat solver, in: Proc. of the 39th Design Automation Conference (DAC 2001), 2001.
Nelson, G. and D. C. Oppen, Simplification by cooperating decision procedures, ACM Transactions on Programming Languages and Systems 1 (1979), pp. 245–257.
Ranise, S. and D. D´eharbe, Applying light-weight theorem proving to debugging and verifying pointer programs, Electronic Notes in Theoretical Computer Science 86 (2003), proceedings of 4th Intl. Workshop on First-Order Theorem Proving (FTP’03).
Ranise, S., C. Ringeissen and D.-K. Tran, Nelson-Oppen, Shostak, and the Extended Canonizer: a Family Picture with a Newborn, in: First Int’l. Symp. on Theoretical Computer Science (ICTAC’04), Lecture Notes in Computer Science 3405 (2004), pp. 372–386.
Schulz, S., E—a brainiac theorem prover, Journal of AI Communications 15 (2002), pp. 111–126.
