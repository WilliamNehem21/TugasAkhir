Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 346 (2019) 241–251
www.elsevier.com/locate/entcs

Identifying Codes in the Complementary Prism of Cycles
M´arcia R. Cappelle, Erika M. M. Coelho, Hebert Coelho1,2
Instituto de Inform´atica Universidade Federal de Goi´as Goiˆania–GO, Brazil
Lucia D. Penso, Dieter Rautenbach3
Institut fu¨r Optimierung und Operations Research Universit¨at Ulm,
Ulm, Germany

Abstract
We show that an identifying code of minimum order in the complementary prism of a cycle of order n has order 7n/9 + Θ(1). Furthermore, we observe that the clique-width of the complementary prism of a graph of clique-width k is at most 4k, and discuss some algorithmic consequences.
Keywords: identifying code, complementary prism, dominating set, cycle


Introduction
We consider finite, simple, and undirected graphs, and use standard notation and terminology.
For a positive integer d, a graph G, and a vertex u of G, let N≤d[u] be the set of vertices of G at distance at most d from u. Note that the closed neighborhood NG[u] of u in G coincides with N≤1[u]. A set C of vertices of a graph G is a d-identifying code in G for a positive integer d [18] if the sets N≤d[u] ∩ C are non- empty and distinct for all vertices u of G. A 1-identifying code is known simply as an identifying code. Let ic(G) denote the minimum order of an identifying code in

1 Thanks to the Fundac¸a˜o de Amparo a` Pesquisa do Estado de Goi´as - FAPEG (Call 03/2015).
2 Email: {marcia,erikamorais,hebert}@inf.ufg.br
3 Email: {lucia.penso,dieter.rautenbach}@uni-ulm.de

https://doi.org/10.1016/j.entcs.2019.08.022
1571-0661/© 2019 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

G. Note that a graph has an identifying code if and only if no two vertices have the same closed neighborhood.
It is algorithmically hard [1,5] to determine identifying codes of minimum order even for planar graphs of arbitrarily large girth. Exact values, density results, as well as good upper and lower bounds have been studied in detail for many special graphs; in particular for graphs that arise by product operations using simple factors such as grids [2,3,4,7,8,11,10,12,13,17,20]. In the present paper we study identifying codes in the complementary prism of cycles. The related notion of locating-domination was studied for such graphs in [16].
Complementary prisms were introduced by Haynes et al. [15] asa variation of the well-known prism of a graph [14]. For a graph G with vertex set V (G)= {v1,..., vn} and edge set E(G), the complementary prism of G is the graph denoted by GG¯ with vertex set V (GG¯)= {v1,..., vn}∪ {v¯1,..., v¯n} and edge set
E(GG¯)= E(G) ∪ {v¯iv¯j :1 ≤ i < j ≤ n and vivj /∈ E(G)}∪ {v1v¯1,..., vnv¯n}.
In other words, the complementary prism GG¯ of G arises from the disjoint union of the graph G and its complement G¯ by adding the edges of a perfect matching joining corresponding vertices of G and G¯. For every vertex u of G, we will consistently denote the corresponding vertex of G¯ by u¯, that is, V (GG¯)= V (G) ∪ V (G¯) where V (G¯) = {v¯1,..., v¯n}. For a positive integer k, let [k] denote the set of positive integers at most k. For an integer n at least 3, let Cn denote the cycle of order n.
In Section 2 we determine the minimum order of an identifying code in CnC¯n
up to a small constant. Note that for n ≥ 6 and d ≥ 2, the graph CnC¯n contains

distinct vertices u and v with N≤d
CnCn
= N≤d
CnCn
, which implies that there is no

d-identifying code in CnC¯n for such values.
Before we proceed to Section 2, we make some more general algorithmic ob- servations. In [1] Auger describes an involved linear time dynamic programming algorithm that determines an identifying code of minimum order for a given tree. In [6] Charon et al. present a similar algorithm for oriented trees, and explicitly mention that it is an open issue whether, for any fixed d at least 2, it is possible to determine a d-identifying code of minimum order for a given tree in polynomial time. In fact, the existence of such efficient algorithms follows immediately from general results [9] concerning graph of bounded clique-width, such as trees, which have clique-width at most 3. For a positive integer d, and two vertices u and v of a graph G, we have v ∈ N≤d[u] if and only if
∃v0, v1,..., vd ∈ V (G): (u = v0) ∧ (v = vd)
∧ (v0v1 ∈ E(G)) ∨ (v0 = v1) ∧· · · ∧ (vd−1vd ∈ E(G)) ∨ (vd−1 = vd) .
Furthermore, a set C of vertices of G is a d-identifying code in G if and only if
 ∀u ∈ V (G): ∃v ∈ C : v ∈ N≤d[u] ∧
 ∀x, y ∈ V (G): (x /= y) ⇒
∃z ∈ C :  (z ∈ N≤d[x]) ∧ (z /∈ N≤d[y])  ∨ (z /∈ N≤d[x]) ∧ (z ∈ N≤d[y])  .

These observations imply that the optimization problem to determine a d-identifying code of minimum order is expressible in the LinEMSOL(τ1) logic [9]. Therefore, if cw is some constant, and G is a class of graphs such that every graph G in G has clique-width at most cw, and a clique-width expression for G using at most cw distinct labels can be determined in polynomial time, then d-identifying codes of minimum order can be determined in polynomial time for the graphs in G (cf. Theorem 4 in [9]). For the class of trees, this immediately implies the existence of linear time algorithms that determine a d-identifying code of minimum order for any fixed d. These algorithmic consequences extend to complementary prisms by the following result.

Proposition 1.1 If G is a graph of clique-width cw, then GG¯ has clique-width at most 4cw.

Proof: Let G be a graph of clique-width cw. In [19] it is shown that there is a rooted binary tree T whose leaves are the vertices of G such that, for every vertex s of T , the set Vs of vertices of G that are descendants of s in T partitions into at most cw equivalence classes with respect to the equivalence relation ∼, where u ∼ v for u, v ∈ Vs if and only if NG[u] \ Vs = NG[v] \ Vs. Replacing in T every leaf u with parent x by three vertices u, u¯, and y, and adding the arcs (x, y), (y, u), and
(y, u¯), we obtain a rooted binary tree T j whose leaves are the vertices of GG¯. By the
definition of GG¯, we obtain that for every vertex sj of T j, the set V j of vertices of GG¯ that are descendants of sj in T j partitions into at most 2cw equivalence classes with respect to the equivalence relation ∼j, where u ∼j v for u, v ∈ V j if and only if
N ¯[u] \ V j = N ¯[v] \ V j. Again by [19], this implies that the clique-width of GG¯
GG	s	GG	s
is at most 4cw. 2




Minimum identifying code in CnC¯n

Throughout this section, let Cn : v1v2 ... vnv1 be a cycle of order n at least 3, and let G = CnC¯n. We identify indices of vertices of G modulo n. For a subset C of V (Cn), let x(C) denote the characteristic vector of C, that is, x(C)= (x1,..., xn) ∈ {0, 1}n where xi = 1 if and only if vi ∈ C for i ∈ [n]. Similarly, for a subset C¯ of V (C¯n), let x(C¯)= (x¯1,..., x¯n) ∈ {0, 1}n where x¯i =1 if and only if v¯i ∈ C¯ for i ∈ [n].

Lemma 2.1 For an integer n at least 9, let G = CnC¯n. Let C ⊆ V (Cn) and
C¯ ⊆ V (C¯n). Let x(C)= (x1,..., xn) and x(C¯)= (x¯1,..., x¯n).
If C ∪ C¯ is an identifying code in G, then the following conditions hold for every

i, j ∈ [n] with (j − i) mod n /∈ {0, 2} (cf. Figure 1):

C(i)	: xi−1 + xi + x¯i + xi+1	≥ 1,
C(i, i + 1) : xi−1 + x¯i + x¯i+1 + xi+2	≥ 1, C(i, i + 2) : xi−1 + xi + x¯i + xi+2 + x¯i+2 + xi+3 ≥ 1,
C¯(i, j)	: x¯i−1 + xi + x¯i+1 + x¯j−1 + xj + x¯j+1 ≥ 1, and
C¯(i, i + 2) : x¯i−1 + xi + xi+2 + x¯i+3	≥ 1.

Furthermore, if |C¯|≥ 4, then C ∪ C¯ is an identifying code in G if and only if these conditions hold.

Proof. Note that for distinct vertices u and v of G, we have NG[u] ∩ (C ∪ C¯) /= NG[v] ∩ (C ∪ C¯) if and only if C ∪ C¯ intersects (NG[u] \ NG[v]) ∪ (NG[v] \ NG[u]). Therefore, for i ∈ [n], we have that C(i) is equivalent to NG(vi) ∩ (C ∪ C¯) /= ∅, C(i, i + 1) is equivalent to NG(vi) ∩ (C ∪ C¯) /= NG(vi+1) ∩ (C ∪ C¯), C(i, i + 2) is equivalent to NG(vi) ∩ (C ∪ C¯) /= NG(vi+2) ∩ (C ∪ C¯), and C¯(i, i + 2) is equivalent to NG(v¯i)∩(C∪C¯) /= NG(v¯i+2)∩(C∪C¯). For i, j ∈ [n] with (j −i) mod n ≥ 3, we have that C(i) and C(j) together are equivalent to NG(vi) ∩ (C ∪ C¯) /= NG(vj) ∩ (C ∪ C¯). For i, j ∈ [n] with (j − i) mod n /∈ {0, 2}, we have that C¯(i, j) is equivalent to NG(v¯i) ∩ (C ∪ C¯) /= NG(v¯j) ∩ (C ∪ C¯). Hence, all these conditions are necessary. Note that |C¯| ≥ 4 implies NG(vi) ∩ (C ∪ C¯) /= NG(v¯j) ∩ (C ∪ C¯) /= ∅ for every
i, j ∈ [n], in which case, the given conditions are also sufficient.	2

v¯i
v¯i		
v¯i+4

. 
. // .	.	.  . // .


vi
v¯i
vi	vi+4


vi

Fig. 1. Condition C(i) implies that at least one of the four vertices indicated in the left figure belongs to C ∪ C¯. Condition C¯(i, i + 4) implies that at least one of the six vertices indicated in the middle figure belongs to C ∪ C¯. Condition C¯(i, i + 2) implies that at least one of the four vertices indicated in the right figure belongs to C ∪ C¯. Note that for C¯n, instead of indicating the edges, we indicate the non-edges by dashed lines.

Lemma 2.2 For an integer n at least 9, let G = CnC¯n. Let C ⊆ V (Cn) and
C¯ ⊆ V (C¯n). Let x(C)= (x1,..., xn) and x(C¯)= (x¯1,..., x¯n).

If k = n , and for i ∈ [n] (cf. Figure 2),






and

xi =
1, i mod 9 ∈ {1, 2, 3} and i ≤ 9k,
1, i ≥ 9k + 1, and
⎪⎪⎩ 0, otherwise


x¯i
= ⎧ 1, i mod 9 ∈ {5, 6, 7, 8} and i ≤ 9k, and
⎩ 0, otherwise,

	

Proof. Lemma 2.1 easily implies that C ∪ C¯ is an identifying code in G. Further- more, |C ∪ C¯| = 7k + (n − 9k)= n − 2k = n − 2 n ≤ n − 2 (n—8) = 7 n + 16 .	2



··· 
. . .

··· 


Fig. 2. Some identifying code for CnC¯n.
Lemma 2.3 For an integer n at least 9, let G = CnC¯n. Let C ⊆ V (Cn) and C¯ ⊆ V (C¯n) be such that C ∪ C¯ is an identifying code in G. Let x(C)= (x1,..., xn) and x(C¯)= (x¯1,..., x¯n). Let I¯ = {i ∈ [n]: x¯i—1 + xi + x¯i+1 = 0}.
If |C¯| ≥ 6 and i ∈ [n] is such that i − 5, i,i + 1,i +6 /∈ I¯ and x¯i x¯i+1 = 0 0 ,
either there are subsets Cj ⊆ V (Cn) and C¯j ⊆ V (C¯n) such that Cj ∪ C¯j is an identifying code in G with |Cj ∪ C¯j|≤ |C ∪ C¯|, and

 x¯j 

 0 
 x¯j 

 0 

j ∈ [n]:	j
j
j ∈ [n]:	=
	xj	0


1	n	1	n
or  x¯i−1 x¯i ... x¯i+7 , x¯i−6 x¯i−5 ... x¯i+2 , contains 1 0 0 1 0 1 0 0 1 .
Proof. We use the conditions from Lemma 2.1. Let i ∈ [n] be such that i− 5, i,i + 1,i +6 /∈ I¯ and x¯i x¯i+1  = 0 0 . C(i) and C(i + 1) imply xi—1 = xi+2 = 1. Since
i, i +1 /∈ I¯, we have x¯i—1 = x¯i+2 = 1.
Let Cj = C ∪ {vi, vi+1} and C¯j = C¯ \ {v¯i—1, v¯i+2}. Let x(Cj) = (xj ,..., xj )
1	n
and x(C¯j) = (x¯j ,..., x¯j ). If Cj ∪ C¯j is an identifying code in G, then (i) holds.
1	n
Hence, we may assume that Cj ∪ C¯j is not an identifying code in G. Since |C¯j|≥ 4,
some condition from Lemma 2.1 is violated by Cj ∪ C¯j. Since (C ∪ C¯) \ (Cj ∪ C¯j)= 

{v¯i—1, v¯i+2}, a violated condition must involve x¯j
or x¯j
. By symmetry, we may

assume that x¯j
is involved in a violated condition. The conditions that involve

j
i+2
are C(i + 2), C(i + 1,i + 2), C(i + 2,i + 3), C(i, i + 2), C(i + 2,i + 4), C¯(i + 1, j),

C¯(i + 3, j), C¯(i − 1,i + 1), and C¯(i + 3,i + 5) for j ∈ [n] with (j − i) mod n /∈ {0, 2},

where we replace xj with xj
and x¯j with x¯j
for all j ∈ [n]. Since xj
= 1, the

conditions C(i + 1,i + 2) and C(i, i + 2) are not violated. Since xj
= 1, the

conditions C(i + 2,i + 3), C¯(i + 1, j), and C¯(i − 1,i + 1) are not violated. Since

j
i+2
= 1, the conditions C(i + 2) and C(i + 2,i + 4) are not violated. If C¯(i + 3, j)

is violated, then xi+3 = xj
=0 and x¯i+4 = x¯j
= 0. If C¯(i + 3,i + 5) is violated,

then xi+3 = xi+5 =0 and x¯i+6 = 0. Therefore, by symmetry, we may assume that either xi+3 = x¯i+4 = 0, or xi+3 = xi+5 = x¯i+6 = 0, and x¯i+4 = 1. In the first case, C¯(i + 1,i + 3) is violated. Hence, we may assume xi+3 = xi+5 = x¯i+6 = 0, and x¯i+4 = 1. C(i + 1,i + 3) implies that x¯i+3 = 1 or xi+4 = 1. Let Cjj = C \ {vi+2} and C¯jj = C¯ ∪ {v¯i+1}. If Cjj ∪ C¯jj is an identifying code in G, then (i) holds. Let
x(Cjj)= (xjj,..., xjj). Hence, we may assume that Cjj∪C¯jj is not an identifying code
1	n
in G. Since |C¯jj|≥ 4, some condition from Lemma 2.1 is violated by Cjj ∪ C¯jj. Since

(C ∪ C¯) \ (Cjj ∪ C¯jj)= {vi+2}, a violated condition must involve xjj
. Arguing as

above, Lemma 2.1 implies that x¯i+3 = x¯i+5 = xi+6 = 0. As noted above, x¯i+3 =0 implies xi+4 = 1. Now C(i + 6) and i +6 /∈ I¯ imply xi+7 = x¯i+7 = 1, that is, (ii) holds, which completes the proof.	2
Lemma 2.4 If n is an integer at least 9, then ic(CnC¯n) ≥ 7 n − 12.
Proof. We prove the statement by induction on n, and use the conditions from Lemma 2.1. Clearly, we may assume that n >  9·12 = 15. Let G = CnC¯n, and let
C ⊆ V (Cn) and C¯ ⊆ V (C¯n) be such that
C ∪ C¯ is an identifying code in G with ic(G)= |C ∪ C¯|, and

Let I¯ = {i ∈ [n]: x¯i—1 + xi + x¯i+1 = 0}. By C¯(i, j) and C¯(i, i + 2), we may assume that I¯ ⊆ [1].
If |C¯| ≤ 5, then there are at least n − 1 − 2|C¯| indices i with i /∈ I¯ and x¯i—1 = x¯i+1 = 0, which implies xi = 1. Therefore, |C| + |C¯| ≥ (n − 1 − 2|C¯|)+ |C¯| = n − 1 − |C¯|≥ n − 6 > 7 n − 12. Hence, we may assume that |C¯|≥ 6.
Claim 2.5 There is no integer i with 7 ≤ i ≤ n − 6 such that x¯i x¯i+1 = 0 0 .


C ∪ C¯ imply x¯i−1 x¯i ... x¯i+7 = 1 0 0 1 0 1 0 0 1 or x¯i−6 x¯i−5 ... x¯i+2 = 1 0 0 1 0 1 0 0 1 .
By symmetry, we may assume that the former case occurs. Let Cj ⊆ V (Cn—5) and
C¯j ⊆ V (C¯n—5) be such that


j ... x¯j
j ... xj
=	x¯1 ... x¯i+2 x¯i+8 ... x¯n x1 ... xi+2 xi+8 ... xn



for x(Cj) = (xj ,..., xj	) and x(C¯j) = (x¯j ,..., x¯j
).	Since |C¯| ≥ 6, we

1	n—5	1	n—5
have |C¯j| ≥ 4.	Considering the conditions from Lemma 2.1 easily implies
that Cj ∪ C¯j is an identifying code in Cn—5C¯n—5.	By induction, we obtain

|C ∪ C¯| = |Cj ∪ C¯j| +4 ≥ 7 (n − 5) − 12 + 4 > 7 n − 12. 2
9	9
Let i1 < i2 < . . . < ik be the increasing sequence of integers i with 8 ≤ i ≤ n−6 such that x¯i  = 0 . Note that, by Claim 2.5, for j ∈ [k], we have x¯ij−1 , x¯ij +1 /= 0 .
For j ∈ [k − 1], let Ij = {i ∈ [n] : ij ≤ i ≤ ij+1 − 1}. Note that |Ij| ≥ 2 for
j ∈ [k − 1].
For I ⊆ [n], let V (I)=	i∈I{vi, v¯i}.
Claim 2.6 If k ≥ 2, then there are integers l, j1, j2,..., jl with l ≥ 2 and 1= j1 < j2 < . . . < jl = k such that

 C ∪ C¯ ∩ V (Ij1
∪ ··· ∪ I

j2 −1
) ≥ 9 |Ij1
∪ ··· ∪ I
5
j2 −1|— 9 ,
(1)

 C ∪ C¯ ∩ V (Ijr
∪ ··· ∪ I

jr+1 −1
) ≥ 9 Ijr
∪ ··· ∪ I

jr+1 −1
 , for r ∈ [l — 2] \ [1],	(2)

and  C ∪ C¯ ∩ V (I
∪ ··· ∪ I
) ≥ 7 I
∪ ··· ∪ I
 — 5 .	(3)

jl−1
jl−1 
9 jl−1
jl−1	9

Proof of Claim 2.6: If for some j ∈ [k − 1], there is some i ∈ Ij with x¯i = 1 ,
C ∪ C¯ ∩ V (Ij) ≥ |Ij|,	(4)
and, if Ij is clean, then, since |Ij|≥ 2,
 C ∪ C¯ ∩ V (I ) = |I |− 1	7 I |− 5 .	(5)

Recall that x¯i1−1 /= 0 . If x¯i1−1 /= 1 , then the definition of j2 follows the
pattern of the definition of jr+1 for r ≥ 2 described above, that is, in this case, (2) will be satisfied also for r = 1, which is a stronger inequality. If x¯i1−1  = 1 , then
let j2 be maximum such that j1 < j2 ≤ k and Ij is dirty for j ∈ {j1, j1+1,..., j2−2}. Note that, if Ij1 is clean, then j2 = j1 + 1. By (4) and (5), we obtain that (1) holds. If j2 = k, then set l = 2, and terminate the definition of the sequence j1,..., jl. Note that (3) coincides with (1) in this case. If j2 < k, then, by the choice of j2, we have that Ij —1 is clean, which implies that x¯ij2 −1 /= 1 .
Therefore, we may now assume that for some non-negative integer r, the indices 1 = j1 < ··· < jr < k have already been defined in such a way that the corre- sponding conditions are satisfied, and that x¯ijr −1  /∈  0 , 1  . We will define jr+1

different cases. In each case, we consider potential choices jj	and possibly jjj

for jr+1. As before, if one of jr+1, jj
, or jjj
equals k, then set l = r + 1, and

terminate the definition of the sequence j1,..., jl. In such a case, (4) and (5) will imply (3).
Let t = ijr .
Case 1 Ij is clean and x¯t x¯t+1 = 0 1 .
Since Ijr is clean, xt+2 = 0. C¯(t, t + 2) implies x¯t+3 = 1. Since Ijr is clean,
xt+3 = 0. C¯(t + 1,t + 3) implies x¯t+4 = 1. Since Ijr is clean, xt+4 = 0. This

implies ij +1 −ij ≥ 5. Since  C ∪ C¯ ∩ V (Ij ) = |Ij |− 1 ≥ 4 |Ij | > 7 |Ij |, setting
Case 2 Ij is clean and x¯t x¯t+1 = 0 0 .
Since t /∈ I¯, we have x¯t—1 = 1, and hence, xt—1 = 0. C(t, t + 1) implies xt+2 = 1. Since Ijr is clean, x¯t+2 = 0. C(t + 1,t + 2) implies xt+3 = 1. Since Ijr is clean, x¯t+3 = 0. This implies ijr +1 −ijr ≥ 4. If ijr +1 −ijr ≥ 5, then setting jr+1 = jr +1, we obtain condition (2) for r as in Case 1. Hence, we may assume that ijr +1 − ijr = 4. If Ijr +1 is clean, then t +4 /∈ I¯ implies x¯t+5 = 1, and hence, xt+5 = 0. Now, analogous arguments as in Case 1 imply xt+6 = xt+7 = xt+8 =0 and x¯t+6 = x¯t+7 =
x¯t+8 = 1. Hence, ijr +2 − ijr ≥ 9, and

 C ∪ C¯ ∩ V (Ijr

∪ Ijr +1
) = |Ijr

∪ Ijr +1
|− 2
7
≥ 9 |Ijr

∪ Ijr +1|,

that is, setting jr+1 = jr + 2, we obtain condition (2) for r. Hence, we may assume that Ijr +1 is dirty.

Let jj
be maximum such that jr < jj
≤ k and Ij is dirty for j ∈ {jr +

1, jr + 2,..., jj
— 2}. Clearly, jj
= k or I ′
r+1
—1 is clean.

j
r+1
= k, then set l = r + 1 and jr+1 = k. Note that, if Il—1 is dirty, then

|Ijr ∪· · · ∪ Il—1|≥ 6 and

 C ∪ C¯ ∩ V (Ijr

∪· · · ∪ I


jÆ—1
) = |Ijr

∪· · · ∪ I


jÆ—1
|− 1 ≥ 7 |I
9	jr

∪· · · ∪ I

jÆ—1| ,

and, if IjÆ—1 is clean, then |Ijr ∪ ··· ∪ IjÆ—1|≥ 8 and

 C ∪ C¯ ∩ V (Ijr

∪· · · ∪ I

jÆ—1
) = |Ijr

∪· · · ∪ I

jÆ—1
|− 2 ≥ 7 |I
9	jr

∪· · · ∪ I

jÆ—1
|− 5 ,
9

that is, in both cases (3) holds. Hence, we may assume that jj
< k and I ′
r+1

is clean.
If ij′
—1 − ij +1 ≥ 3, then set jr+1 = jj
. Since Ij

∪· · · ∪ Ij
—1 ≥ 9 and

r+1	r

 C ∪ C¯ ∩ V (Ijr

∪· · · ∪ I




jr+1—1

) = Ijr
r+1

∪· · · ∪ I




jr+1—1
r


 −2 ≥ 9 I
r+1


jr ∪· · · ∪ I



jr+1—1 ,

(2) holds for r. Hence, we may assume that i ′
r+1
—1 − ijr +1 = 2, which implies that

Ij +1 has exactly two elements, and jj	= jr + 3, that is, Ij +2 is clean.
r	r+1	r
Let s = ij′	—1. Note that s = t + 6. If x¯s x¯s+1 = 0 1 , then, s +1 /∈ I¯
r	r+1
 


xs xs+1	0 1 
 x¯t ... x¯t+7  =  0 0 0 0 0 1 0 0 .

Now, C¯(t + 4,t + 6) does not hold, which is a contradiction, and completes the second case.

For the remaining cases, we may assume that Ijr
is dirty. Let jj
be maximum

such that jr < jj
≤ k and Ij is dirty for j ∈ {jr, jr + 1,..., jj
— 2}. Clearly,

j
r+1
= k or I ′
r+1
—1 is clean.

j
r+1
= k, then set l = r + 1 and jr+1 = k. Note that, if Il—1 is dirty, then



 C ∪ C¯ ∩ V (I	∪· · · ∪ I	) = |I	∪· · · ∪ I
7 I	∪· · · ∪ I	| ,


and, if IjÆ—1 is clean, then |Ijr ∪ ··· ∪ IjÆ—1|≥ 4 and


 C ∪ C¯ ∩ V (Ijr
∪· · · ∪ I

jÆ—1
) = |Ijr
∪· · · ∪ I

jÆ—1
|− 1 ≥ 7 |I
9	jr
∪· · · ∪ I

jÆ—1
|− 5 ,
9



that is, in both cases (3) holds. Hence, we may assume that jj
< k and I ′
r+1

is clean.
The remaining two cases have some similarities with Cases 1 and 2.

Let t = i ′
r+1
—1.

Case 3 Ij



is dirty and x¯t x¯t+1 = 0 1 .
	


i ′
r+1
— ijr
≥ 5. Setting jr+1 = jj
, condition (2) for r follows as in Case 1.

Case 4 Ij is dirty and x¯t x¯t+1 = 0 0 .
	 	

may assume that ij′	− ij
= 4, which implies jj	= jr + 2 and |Ij | = |Ij +1| = 2.

r+1	r
r+1	r	r

If Ijr +2 is clean, then t+2 /∈ I¯ implies x¯t+3 = 1, and hence xt+3 = 0. Now similar
arguments as in Case 1 imply xt+4 = xt+5 = xt+6 =0 and x¯t+4 = x¯t+5 = x¯t+6 = 1. Therefore, ijr +3 − ijr ≥ 9, and setting jr+1 = ijr +3 satisfies (2) for r as above. Note
that if ijr +3 − ijr = 9, then	 corresponds to the pattern used in the proof
x¯t ... x¯t+8
of Lemma 2.2. Hence, we may assume that Ijr +2 is dirty.
Let jjj	be maximum such that jr +2 < jjj	≤ k and Ij is dirty for j ∈

{jr + 2, jr + 3,..., jjj
— 2}. Clearly, jjj
= k or I ′′
r+1
—1 is clean. If jjj
= k, then

setting l = r + 1 and jr+1 = k, and arguing similarly as in Case 2 yields (3). Hence,

we may assume jjj
< k and I ′′
r+1
—1 is clean.

If i ′′
r+1
−ijr
≥ 9, then setting jr+1 = jjj
yields (2) for r as above. Hence, we may

assume that ij′′  −ij
= 8, which implies that jjj	= jr +4 and |Ij +2| = |Ij +3| = 2.

r+1	r
This implies
r+1	r	r

 x¯t—2 ... x¯t+6  ∈  0 1 0 0 0 1 0 1 0 , 0 1 0 0 0 1 0 0 0  .

Now the first options leads to the contradiction t +5 ∈ I¯, and the second option leads to the contradiction that C¯(t + 2,t + 4) does not hold.
This completes the proof of Claim 2.6. 2

If k ≤ 1, then n > 15 implies
 C ∪ C¯  ≥  C ∪ C¯ ∩ V ([n − 6] \ [7]) ≥ n − 6 − 7 − 1= n − 14 > 7 n − 12.

Hence, we may assume that k ≥ 2.
xi	0
¯

xi	0
obtain
 C ∪ C¯ ∩ V ([ik − 1] \ [i1 − 1]) 

= C ∪ C¯ ∩ V (Ij1 ∪· · · ∪ Ij2—1) + Σ C ∪ C¯ ∩ V (Ijr ∪· · · ∪ Ijr+1—1) 



 7	5 

	

Σl—2  7 




+  7 I



jÆ−1

∪· · · ∪ I


jÆ—1


 − 5 

7	10
= 9 |I1 ∪· · · ∪ Ik—1|− 9
7	10
= 9 (ik − i1) − 9
= 7  (i − i ) − 10  .
Altogether, this implies

|C ∪ C¯|≥ (i − 1 − 7) +  7 (i
— i ) − 10  + (n − 6 − i )

≥ 7  (i
— 1 − 7) + (i − i ) − 10  + (n − 6 − i ) 

9
= 7 n −
9
7
1
108
9
k	1	7	k

=  n − 12, 9
which completes the proof.	2
We proceed to our main result.
Theorem 2.7 ic(CnC¯n)= 7 n + Θ(1) for n ≥ 3.
Proof. This follows immediately from Lemma 2.2 and Lemma 2.4.	2

References
D. Auger, Minimal identifying codes in trees and planar graphs with large girth, Eur. J. Comb. 31 (2010) 1372-1384.
Y. Ben-Haim and S. Litsyn, Exact minimum density of codes identifying vertices in the square grid, SIAM J. Discrete Math. 19 (2005) 69-82.
N. Bertrand, I. Charon, O. Hudry, and A. Lobstein, 1-identifying codes on trees, Australas. J. Comb. 31 (2005) 21-35.
M. Blidia, M. Chellali, F. Maffray, J. Moncel, and A. Semri, Locating-domination and identifying codes in trees, Australas. J. Comb. 39 (2007) 219-232.
I. Charon, O. Hudry, and A. Lobstein, Minimizing the size of an identifying or locating-dominating code in a graph is NP-hard, Theor. Comput. Sci. 3 (2003) 2109-2120.
I. Charon, S. Gravier, O. Hudry, A. Lobstein, M. Mollard, and J. Moncel, A linear algorithm for minimum 1-identifying codes in oriented trees, Discrete Appl. Math. 154 (2006) 1246-1253.
G. Cohen, S. Gravier, I. Honkala, A. Lobstein, M. Mollard, C. Payan, and G. Z´emor, Improved identifying codes for the grids, Electr. J. Comb. 6 (1) (1999) #R19 (comment).
G. Cohen, I. Honkala, A. Lobstein, and G. Z´emor, New Bounds for Codes Identifying Vertices in Graphs, Electr. J. Comb. 6 (1) (1999) #R19.
B. Courcelle, J.A. Makowsky, and U. Rotics, Linear Time Solvable Optimization Problems on Graphs of Bounded Clique-Width, Theory Comput. Systems 33 (2000) 125-150.
M. Daniel, S. Gravier, and J. Moncel, Identifying Codes in Some Subgraphs of the Square Lattice, Theor. Comput. Sci. 319 (2004) 411-421.
W. Goddard and K. Wash, ID Codes in Cartesian Products of Cliques, J. Combin. Math. Combin. Comput. 85 (2013) 97-106.
S. Gravier, J. Moncel, and A. Semri, Identifying codes of cycles, Eur. J. Comb. 27 (2006) 767-776.
S. Gravier, J. Moncel, and A. Semri, Identifying codes of Cartesian product of two cliques of the same size, Electr. J. Comb. 15 (2008) #N4.
R. Hammack, W. Imrich, and S. Klavˇzar, Handbook of product graphs, 2nd ed. Discrete Mathematics and Its Applications, Boca Raton (2011).
T.W. Haynes, M.A. Henning, P.J. Slater, and L.C. van der Merwe, The complementary product of two graphs, Bull. Inst. Comb. Appl. 51 (2007) 21-30.
T.W. Haynes, K.R.S. Holmes, D.R. Koessler, and L. Sewell, Locating-domination in complementary prisms of paths and cycles, Congr. Numerantium 199 (2009) 45-55.
V. Junnila and T. Laihonen, Optimal lower bound for 2-identifying codes in the hexagonal grid, Electr.
J. Comb. 19 (2012) #P38.
M.G. Karpovsky, K. Chakrabarty, and L.B. Levitin, On a New Class of Codes for Identifying Vertices in Graphs, IEEE Transactions on Information Theory 44 (1998) 599-611.
V. Lozin and D. Rautenbach, The relative clique-width of a graph, J. Combin. Theory Ser. B 97 (2007) 846-858.
R. Martin and B. Stanton, Lower bounds for identifying codes in some infinite grids, Electr. J. Comb. 17 (2010) #R122.
