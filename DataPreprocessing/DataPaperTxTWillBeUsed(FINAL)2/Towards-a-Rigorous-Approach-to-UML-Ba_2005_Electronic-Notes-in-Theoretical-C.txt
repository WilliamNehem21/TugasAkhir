Electronic Notes in Theoretical Computer Science 130 (2005) 57–77  
www.elsevier.com/locate/entcs


Towards a Rigorous Approach to UML-Based Development 1
Zhiming Liu and He Jifeng
International Institute for Software Technology The United Nations University, Macao SAR, China
Xiaoshan Li
Faculty of Science and Technology, University of Macau, Macao SAR, China

Abstract
We discuss the promises and problems of UML-based development. We then suggest a framework in which UML can be used precisely and more disciplined so as to solve the problems and meet the promises better.
Keywords: Object-Orientation, Component-Based Development, Refinement, Specification, Transformation


Introduction
When programming in the small, the speciﬁcation of the problem is mainly concerned with the control and data structures of the program. The program development is the design and implementation of data structures and algo- rithms through a number of steps of reﬁnement. Veriﬁcation is needed to prove that each step preserves the specification of the control and data structures in the previous step. Various formal methods, especially those state-based

1 Email: lzm@iist.unu.edu,hjf@iist.unu.edu,xsl@umac.mo.
J. He is on leave from East China Normal University, Shanghai, China.
J. He’s work is partly supported by the research grant 02104 MoE and the 973 project 2002CB312000 of MoST of P.R. China.


1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.03.005


models [9,18] such as VDM [20] and Z [8], are widely found helpful in correct and reliable construction of such a program.
For programming in the large, problems become more complicated. The specification has to be described in terms of (or decomposed into) components, their interfaces and interactions. Such a specification in general contains dif- ferent views and aspects, e.g. the static view, the interaction view and the behavioural view. An overall structure, i.e. the system architecture, is re- quired to consistently unify these views. The system construction needs a process of model transformations. These transforms have to ensure consis- tency of the deferent views and preserve the functional and behavioural cor- rectness. Therefore, for programming in the large, it is ideal in general to have a multi-view modelling language that supports specifications at different levels of abstraction. In this article, we will discuss how UML can be used for this purpose and how it can be used formally for correct and reliable construction of large scale software.


The promises of UML
UML2.0 is designed as a modelling language for component-based and object- oriented development, promising to support programming in the large. It is obviously a multi-view and multi-notional language and we can count up to at least 10 kinds of diagrams including component diagrams, packages, class diagrams, object diagrams and use-case diagrams for static views; activity di- agrams, interaction diagrams (sequence diagrams and collaboration diagrams) and statecharts for concurrency, interaction and behavioural aspects; and de- ployment diagram for deployment. A textual specification language, Object Constraint Language (OCL), is also part of UML for writing constraints on the diagrams and pre- and post-conditions of operations and methods.
The multi-view and multi-notational aspect of UML has an obvious good purpose to allow the split of an overall system model into several views and decompose it into chunks of manageable size. Each single view focuses on a different aspect and this will ease for analysis and understanding. This decomposability of the model enable the development team to split the work of producing models among different people. It is also important for tool support as it would be more difficult for a tool to deal with one large and complex model. UML also intends to support modelling a system at different levels of abstraction. However, without clear means for information hiding, this promise is not as obvious as the one discussed earlier and we need more effort to make UML support model transformation and refinement better.

Problems in using UML

When applying UML to real software projects, several challenging issues in- evitably arise from such a multi-view and multi-notational approach [34]:
Consistency:	the models of various views need to be syntactically and semantically compatible with each other (i.e. horizontal consistency) [12,3],
Transformation and evolution:	a model must be semantically consistent with its refinements (i.e. vertical consistency) [12,3].
Traceability:	a change in the model of a particular view leads to corre- sponding consistent changes in the models of other views.
Integration:	models of different views need to be seamlessly integrated before software production.
Consistency checking and formal analysis of UML models have been widely studied in recent years [14,4,2,13,11,37]. The majority of them focus on the formalization of individual diagrams and only treat the consistency of the models of one or two views. Another phenomenon in research on formal use of UML is that different communities intend to emphasize different notations and use the full or even extended power of, say sequence diagrams or state machines. This would lose the advantages of the multiple-view modelling and the increase in the complexity of a certain kind of models and the reduction of the role that the other kinds of UML models can play. To our knowledge, there is little work on consistent refinement of complete UML models of systems. A complete model of a system here means a family of models for the different views of the system. A majority of methods in the literature use a transforma- tional approach that translate some UML models into an existing formalism, such as B, Z, and CSP, and then employs the existing theories and tools of the corresponding formalisms for the analysis and manipulation of the translated models. A problem with such an approach is that most of the translations are not reversible and the manipulated model will not be able to be converted back to a UML model for comparison. This would cause difficulties for most UML users.
Some researchers, e.g. the authors of [12,3], have realized the conditions and solutions for consistency depend on the diagrams involved, the develop- ment process employed, and the current stage of the development. The dif- ficulties in consistency checking lie in the fact that the syntax and semantics of UML are informal and imprecise compared to formal modelling notations. For example, many features including role names in class diagrams and object names in sequence diagrams are optional and may not appear in the diagrams. This causes no harm if UML is only used in its sketchy mode, but it is not


satisfactory in the modes of blueprint and programming language [15]. Also different models describe overlapping aspects of a system. A particular nota- tion, such as statecharts that in theory can specify all semantic information of sequence diagrams (and activity diagrams) and vice versa, has the power or potential to describe nearly all aspects of a system. This complicates the problems in consistency checking. A good project should restrict the roles of the diagrams to the viewpoints that they intend to represent so as to reduce the amount of overlapping among the different models.


Towards a rigorous approach to UML-based development
In fact the problems of UML are the problems of programming in the large in general, when a multi-view and multi-notaional modelling approach is to be used. To deal with the problems of consistency and refinement in the application of UML, we provide a common semantic model that can define the
UML models and integrates them consistently. We do this by developing a relational model for Refinement of Component and Object Systems (rCOS ) [17,28]. To ease the difficulties mentioned in the previous section in dealing with the problems of consistency and refinement, we target at a particular
use-case driven, incremental and iterative development process (RUP) [19,21], and restrict the syntax and semantics of a kind of UML models to the roles that they play in the development to the viewpoints that they represent. We only allow the use models that are definable in rCOS for formal analysis
and transformation – at the moment they are component diagrams, class diagrams, sequence diagrams for system operations, state machines for classes and activity diagrams.
After this introduction, we give an introduction in Section 2 to the refine- ment calculus for object systems. We then outline the ideas in Section 3 about how the model for object systems is to be extended to deal with component systems. In Section 4, we briefly discuss the relation between object systems and component systems.


A Relational Model for Object Systems
In this section we give an introduction to the syntax and semantics of rCOS . We will omit most of the formal details about the semantics and refer the reader to [17].

Syntax

In rCOS , a system (or program) S is of the form cdecls• P , consisting of class declaration section cdecls and a main method P . The main method P is a pair (glb, c) of a finite set glb of global variables declarations and a command c. P can also be understood as the main method class in Java. The class declaration section cdecls is a finite sequence of class declarations cdecl1; ... ; cdeclk, where each class declaration cdecli is of the following form
[private] class N extends M {
private	U1 u1 = a1,.. ., Um um = am; protected V1 v1 = b1 ,... , Vn vn = bn; public	 W1 w1 = d1; ... Wk wk = dk; method	 m1 (T 11 x1, T 12 y1 , T 13 z1){c1 };
··· ;
mÆ(TÆ1 xÆ, TÆ2 yÆ, T Æ3 zÆ){cÆ}
}
Note that
A class can be declared as private or public, but by default it is assumed as public. Only a public class or a primitive type can be used in the global variable declarations glb. In [17], structural reﬁnement laws allow us to add, delete, change (e.g. adding, deleting or changing attributes or methods), decomposing or composing private classes and associations among them without changing the behavioural of a system. Refinement laws are also available for consistent change in public classes and the main method.
N and M are distinct names of classes, and M is called the direct superclass of N.
Attributes annotated with private are private attributes of the class, and similarly, the protected and public declarations for the protected and pub- lic attributes. Types and initial values of attributes are also given in the declaration.
The method declaration declares the methods, their value parameters (Ti1 xi),
result parameters(T i2 yi), value-result parameters (Ti3 zi) and bodies (ci). We sometimes denote a method by m(paras){c}, where paras is the list of parameters of m and c is the body command of m.
The body of a method ci is a command that will be defined later.
We will use Java convention to write a class specification, and assume an at- tribute protected when it is not tagged with private or public. We have these different kinds of attributes to show how visibility issues can be dealt with. We can have different kind of methods too for a class. However, we omit the


declaration of private or public methods for the simplicity of the theory. In- stead, we assume all methods in public classes are public and can be inherited by a subclass and accessed by the main method, and all methods in private classes are protected.
Commands
rCOS supports typical object-oriented programming constructs, but it also allows some commands for the purse of specification and refinement:
c ::= skip | chaos | var T x=e | end x | c; c | c ¢ b ¢ c | c H c
| b ∗ c | le.m(e, v, u) | le := e| C.new(x)[e]
where b is a Boolean expression e is an expression, and le is an expression which may appear on the left hand side of an assignment and is of the form le ::= x | le.a where x is a simple variable and a an attribute of an object. Unlike
[35] that introduces “statement expressions”, we use le.m(e, v, u) to denote a call of method m of the object denoted by the left-expression le with actual value parameters e for input to the method, actual result parameters v for the return values, and value-result parameters u that can be changed during the execution of the method call and with their final values as return values too; and use the command C.new(x)[e] to create a new object of class C with the initial values of its attributes assigned to the values of the expressions in e and assign it to variable x. Thus, C.new(x)[e] uses x with type C to store the newly created object.
Expressions
Expressions, which can appear on the right hand sides of assignments, are constructed according to the rules below.
e ::= x | null | self | e.a | e is C | (C)e | f (e)
where null represents the special object of the special class NULL that is a subclass of all classes and has null as its unique object, self will be used to denote the active object in the current scope (some object-oriented languages uses this), e.a is the a-attribute of e, (C)e is the type casting, e is C is the type test.
Semantics
rCOS adopts an observation-oriented and relational semantics. It supports refinement of object-oriented designs at different levels of abstraction during a system development. Here we will give a brief overview of the semantics, as for more details, please refer [17].


To formalize the behavior of an object-oriented program, we have to take into account the following features:
A program operates not only on variables of primitive types, such as inte- gers, Boolean values, but also objects of reference types.
To protect attributes from illegal accesses, the model has to address the problem of visibility of attributes to the environment.
An object can be associated with any subclass of its originally declared one. To validate expressions and commands in a dynamic binding environment, the model must keep track of the current type of each object.
Our model describes the behavior of an object-oriented program by a design containing the following logical variables as its free variables that form the alphabet in [18] of the program.
cname: its value is the set of classes which are declared so far, and it is modified by a class declaration.
Each class C ∈ cname is associated with
attr(C): the set of (declared or inherited) attributes of class C
{⟨a1 : T1, d1⟩, ··· , ⟨am : Tm, dm⟩}
where Ti and di are the type and initial value of attribute ai, and will be referred by decltype(C.ai) and init(C.ai) respectively. We also abuse the notation a ∈ attr(C) and use it to denote
∃T, d · (⟨a : T, d⟩ ∈ attr(C))
Again, we do not allow attribute hiding (or redefinition) in a sub- class. We also use an attribute name to represent its value and a type name to denote the set of its legal values.
op(C): the set of (declared and inherited) methods of class C. We allow method overriding, but not signature redefinition in a subclass.
{m1 '→ (x1 : T 11, y1 : T 12, z1 : T 13, Ψ(C.m1)),
··· ,
mk '→ (xk : T k1,y  : Tk2, zk : Tk3, Ψ(C.mk))}
which states that each method mi has xi, yi and zi as its value,
result and value-result parameters respectively, that are denoted by val(C.mi), res(C.mi), and valres(C.mi), and the behavior of mi is defined by the design Ψ(C.mi) that will be defined later in this sec- tion. When we are not interested in distinguishing the value, result and value-result parameters, we simply denote each element in op(C) as mi '→ (parasi, Ψ(C.mi)). We also sometimes abuse the notation m ∈ op(C) and use it to denote
∃paras,D · (m '→ (paras, D) ∈ op(C))
The variables in (a) and (b) are modified by class declarations.
superclass: the partial function mapping a class to its direct superclass. This variable is also modified by a class declaration.


Σ(C): the set of objects of class C that currently exist in the execu- tion of the program, and it will be updated through object creation or destruction. We let

def
Σ =
C∈[cname
Σ(C)

These variables, {Σ(C) | C ∈ cname} are changed by the creation of a new object (and the destruction of an existing object or garbage collection that we do not consider in this article).
We call Σ the system state of the program. It in fact corresponds to the current conﬁguration of the program in [35]. It is also the UML object diagram of the system representing current system’s state [29].
glb: the set of global variables with their types known to the program
{x1 : T1,... , xk : Tk}. The type Ti of xi, denoted by decltype(xi), can be either a primitive type or a class name. We assume they are declared at the beginning of the main program and will not be changed afterwards.
locvar: the set of the current declared local variables with their types. This set is to be modified by local variable declaration and undeclaration statements.
Commands and class declarations, as well as an object system as a whole, are semantically defined as a framed design {V } : pre(x) ▶ Post(x, x') in [18] over the above alphabet.
For P = (glb, c), the semantics of cdecls • P is defined to be the sequential (relational) composition

[[cdecls • P ]]
where
def
= [[cdecls]]; init; [[c]]

the semantics of the declaration section cdecls calculates the set canme of the declared classes, their attributes, methods, and the superclass relation.
design init checks the well-definedness of the declaration section and global variable declarations, initialises the visible attributes, the set of attributes of each declared class, the semantics of methods of each declared class. When combine them together and get
def
([[cdecls]]; init) = {cname, supperclass, visattr, attr, op} :
D(cdecls) ∧ D(glb) ▶
initCname ∧ initSupperclass ∧ initVis ∧ initAttr ∧ initOP
where
initCname collects all the declared public class names in cdecls into cname
initSupperclass sets the direct superclass relation superclass to contain
N '→ M if N extends M appears in cdecls. Let ≤ be the general subclass

relation induced from superclass. Also N ≺ M means that N ≤ M but
N and M are different.
cdecls is well-defined if the attributes names, method names of each class and parameter names of each method are distinct; all types used in cdecls are either classes names declared in cdecls or primitive types; all super- classes are also declared in cdecls; and protected and public attributes of a class are not redeclared in its. subclasses
The global declaration is well-defined if all types used in it are either primitive types or class names declared in cdecls.
initVis sets the execution environment visattr as the set of all public attributes of the public classes {N.a | a ∈ pub(N), N ∈ cname}.
initAttr sets attr(N) for each N ∈ canme as the union of the private at- tributes of N , the protected and inherited protected and public attributes of N’s superclasses:
def	[
attr(N) = pri(N) ∪	{prot(M) | N ≤ M}
initOp sets op(N) for each N ∈ cname the set of its own declared methods and inherited from its superclasses:
def
op(N) = {m '→ (paras, Ψ(N.m)) | (m '→ (paras, c)) ∈ op(M) ∧ N ≤ M}
	
where Ψ(N.m) gives the behaviour of N.m that we define below.
A method of an object of class N is dynamically bound to its current type, and thus we set(N) to set the execution to the environment of class N and Reset to recover the global execution environment. The behaviour of a method m of a class is defined to be the design Ψ(N.m)
def	Set(N); φ (body(N.m)); Reset m ∈ N
Ψ(N.m) =

and



def
Set(N ); φN (body(M.m)); Reset m ∈ M > N

Set(N) = {visattr} : true ▶
visattr'  {N.a | a ∈ attr(N)}∪  M
def


∈cname
{N.a | a ∈ pub(M)} ”

' 

Reset = {visattr} : true ▶ visattr
M∈cname{M.a | a ∈ pub(M)}

where φN(body(N.m)) is recursively defined to prefix each attribute and a



Fig. 1. A bank system

method of class N appearing in the body of m with self:
def	def
φN(skip) = skip,  φN(chaos) = chaos
def
φN(P1; P2) = φN(P1); Set(N); φ(P2)
φ (P1 ¢ b ¢ P2 ) d=ef φ (P1 ) aφ (b) dφ (P2)
N	N	N	N
def
φN(P1 H P2) = φN(P1) H φN(P2 )
def
φN(b ∗ P ) = φN(b) ∗ (φN(P ); Set(N))

φ (var T x = e) d=ef var T x = φ
def
(e), φN
(end x) d=ef end x
def

φN(C.new(x)) = C.new(φN(x)),  φN(le := e) = φN(le) := φN(e)
def
φN(le.m(v, r, vr)) = φN(le).m(φN(v, r, vr))
def
φN(v, r, vr) = (φN(v), φN(r), φN(vr))
def
φN(m(v, r, vr)) = self.m(φN(v), φN(r), φN(vr))

φN(x) =
def
x	otherwise


def

φN(self) = self,	φN(le.a) = φN(le).a
Then the semantics of φN (body(M.m)) can be defined as a design of the form pre ▶ Post following the Unifying Theories of Programming in [18].
In rCOS , an object program is specified as a sequence class declarations
class1; ··· ; classn, where each class is declared with its fields and methods. With rCOS , a class diagram can be easily formalised as a sequence of class declarations in which associations can be either specified as a class or an at-
tribute of a class [29]. Sequence diagrams and statecharts are formalized and integrated into the body of the methods of the relevant classes [30,25,38,24,26]. Therefore, within the proposed framework, we can provide a consistent inte- gration of UML models in an object-oriented development.


Example
Consider the UML class diagram for a simple bank system in Figure 1. This class diagram can be specified in rCOS as a class declaration section,

denoted by BankDecls. The semantics of the class diagram is formalized as
BankDecls; init = true ▶
cnname' = {Acc, CA,Bank}∧ sup' = {CA '→ Acc, SA '→ Acc}∧
'	∅∧
attr'(Acc)= {aNo : Int, balance : Int}∧ attr'(CA)= {aNo : Int, balance : Int}∧ attr'(SA)= {aNo : Int, balance : Int}∧
attr'(Bank)= {name : String, address : String, A : Set[Acc]}∧
op'(Acc)= {gB '→ (pas,, Ψ(Acc.gB)), wD '→ (pas, Ψ(Acc.wD))}∧
B op'(CA)= {gB '→ (paras, Ψ(CA.gB)), wD '→ (pas, Ψ(CA.wD))}∧  C
op'(SA)= {gB '→ (paras, Ψ(SA.gB)), wD '→ (paras, Ψ(SA.wD))}∧

	
Notice here that we have used some shorthands, such as gB for getBalance
and wD for withDraw.
Not assume that the body of withDraw(x) is balance := balance − x. Then the design of the withDraw method of CA that is inherited from the definition of Account is
Ψ(CA.wD) = Set(CA); φN(balance := blance − x); Reset
= visattr := {CA.blance, CA.aNo};
self.balance := self.balance − x;
visattr := ∅
However, assume for a saving account of calls SA, withDraw is allowed only if the current balance is no less than the amount to withdraw. The method withDraw(x) is SA is rewritten from that of Account to
(balance:=blance-x) ¢ (x ≥ balance) ¢ (output “no enough money”)
Then the design of the withDraw method of SA that overwrites that of Account is
Ψ(SA.wD) = Set(SA); φN(balance := blance − x); Reset
= visattr := {SA.blance, SA.aNo};
self.balance := self.blance − x)¢
(x ≥ self.balance) ¢ (out put “no enough money”);
visattr := ∅
The above examples show how dynamic binding in our model works.

Reﬁnement of Object Systems
rCOS includes refinement of class declarations (structural reﬁnement, refine- ment of commands and refinement of a whole system.
Definition 2.1 (Design refinement) Design D2 = (α, P2) is a reﬁnement

of design D1(α, P1), denoted by D1 ± D2, if P2 entails P1, i.e.
∀x, x' , ok, ok' · (P2 ⇒ P1 )
where x are variables contained in α. D1 ≡ D2 if and only if D1 ± D2 and
D2 ± D1.
Definition 2.2 (Data refinement) Let ρ be a mapping (that can also be specified as a design) from α2 to α1. Design D2 = (α2, P2) is a reﬁnement of design D1 = (α1, P1) under ρ, denoted by D1 ±ρ D2, if (ρ; P1) ± (P2; ρ). In this case, ρ is called a refinement mapping.
Definition 2.3 (System refinement) Let S1 and S2 are object programs which have the same set global variables glb. S1 is a reﬁnement S2, denoted by S1 ±sys S2, if its behavior is more controllable and predictable than that of S2:
∀x, x' , ok, ok' · (S1 ⇒ S2 )
where x are those variables in glb.
This indicates the external behavior of S1, that is, the pairs of pre- and post global states, is a subset of that of S2. To prove one program S1 refines another S2, we require that they have the same set of global variables and the existence of a reﬁnement mapping between the variables of S1 to those of S2 that is identical on global variables.
Let stateV be the set of variables listed above, except for those in glb. The semantics of a program is defined by
cdecls • P def ∃stateV, ∃stateV ' · (cdecls; init; c)
where ∃setV for a set setVof variables is a short hand for applying ∃ to each of the variables in the set, and the design init performs the tasks of computing the initial state. It is explained in details in [17].
Definition 2.4 (Class refinement) Let cdecls1 and cdecls2 be two decla- ration sections. cdecls1 is a reﬁnement of cdecls2, denoted by cdecls1 ±class cdecls2, if the former can replace the later in any object system:
def
cdecls1 ±class cdecls2 = ∀P · (cdecls1 • P ±sys cdecls2 • P )
where P stands for a main method (glb, c).
Intuitively, it states that cdecls1 supports at least the same set of services as cdecls2.
The following refinement laws capture the basic principles in object-oriented design and decomposition, and can be used to prove general object-oriented design patterns within the UML framework:
Adding a class declaration: this allows us to add a class into the class


diagram, sequence diagrams and state machines of the methods of the new class.
Introducing a fresh private attribute to a class: this corresponds to adding a fresh attribute of a primitive type to the class or adding a directed association from the class to another in the class diagram.
Promoting a private attribute of a class to a protected attribute, and a protected attribute to a public attribute: the same refinements can be applied to a class diagram.
Adding a fresh method into a class: this allows us to add a method signature into the class in the class diagram, and add a sequence diagram, modify the state machine to incorporate this method. The newly added methods must not violate any state constraint required by the model.
Refining the body command of a method m(){c} in a class: this leads to the replacement of the subsequence diagrams corresponding to the occurrences of m(), and refine the actions of transitions with m() as the triggering event in the state machine of the class.
Introducing inheritance: If none of the attribute of class N is defined in class M or any superclass of M , we can make M a direct superclass of N .
Moving some attributes from a class to its direct superclass.
Introducing a fresh superclass to a class: If M is not in the class decla- ration, we can introduce M and make it a superclass of an existing class N.
Moving common attributes of classes which are direct subclasses of a class to the superclass.
Moving a method from a class to its direct superclass.
Copying (not removing) a method of a class to its direct subclass.
Removing unused attributes: for a private attribute, it can be removed if it does not appear in any method of the class; for a protected attribute, it can be removed if it does not appear in any method of the class or any of its subclasses; for a public attribute, it can be removed if it does not appear in any method. This is because the main method does not access attributes directly.
We can also refine a class diagram by flattening it into a diagram with- out inheritance relations between classes. Refinement rules are also available for the object-oriented design patterns. General Responsibility Assignment Software Patterns (GRASP) [22] is a frequently used object-oriented design technique. We have used the facade controller in a requirement specification.


One of the most important design patterns is called the expert pattern, which shows how part of a functionality of a class can be delegated to another class:

Law 1 (Expert) If a method of a class contains a subcommand that can be realized by a method of another class, we can replace that subcommand with a method invocation to the of the latter class (see Figure 2).

Fig. 2. Expert Pattern
Note that the sequence diagrams and state machines involving N :: m() are refined accordingly. They are not shown here due to the length limit of this paper.
The Low-Coupling Pattern of GRASP, on the other hand, can help us remove unnecessary associations to reduce the coupling between classes and simplify reuse and maintenance:
Law 2 (Low Coupling) A call from one class to a method of another can be realized via a third class that is associated with these two classes. This is shown in Figure 3.

Fig. 3. Low Coupling Pattern
The High-Cohesion Pattern corresponds to the principle to decompose a com- plex class into several related classes. A highly cohesive design makes reuse and maintenance more flexible.
Law 3 (High Cohesion) Assume that there are two methods m1() and m2()n a class M and m1 does not depend on m2 (though m2() may call m1()), we can decompose the class into three associated classes so that the original class M only delegates the functionalities to the newly introduced classes. There are two ways of doing this, as shown in Figure 4.
The case (a) in Pattern 3 requires M to be coupled with both M1 and M2;
and in case (b) M is only coupled with M2, but more interactions are needed between M2 and M1.
The other design patterns in [16], such as Adaptor Pattern, Observer Pat- tern, Strategy Pattern and Abstract Factory Pattern can also be formalized.


 	 
(a)	(b)
Fig. 4. High Cohesion pattern

In fact the laws above are also reversible and thus can be used for re- engineering. This also implies the result in [5] that every object-oriented program can be converted back to a normal form specification corresponding to an imperative program. Moreover, such a normal form in our framework corresponds to the requirement specification in terms of use cases [23,29]. In [22,27], the five GRASP patterns are systematically used for the development of a case stsudy.


Modelling Component Systems
Within rCOS , a component system S is modelled as family C of components. Each component C is specified as a tuple ⟨St,PI,Comp,Prot, RI, RProt⟩ where
St is a set typed state variables and a type can be a class. St contains a control variable wait for synchronization.
PI is a set of methods called the provided interface of the component, each method is of the form m(in : U, out : V ) with an input parameter in and an output parameter out.
Comp is a mapping that associate each method m in PI with a specification of the required functionality of m, and when m is called by its environment it is executed according to Comp(m) to change the state St and to provide output via out. Each specification Comp(m) is written in a well defined s language that allows specifications at different level of abstraction. At the highest level of abstraction, each Comp(m) is a design in UTP [18] of the

form (α, P ) where,
def

α
inα
= inα ∪ outα
def
= {in : U }∪ St

outα  def {out' : V }∪ St'
def
p ▶
Also a design may be guarded in the form g&(p ▶ R), where is a Boolean expression, that is defined as
g ∧ (p ▶ R) ∨ ¬g ∧ (true ▶ wait')
Prot is a set of sequences of method invocations of the form
?m1(in1); ··· ; ?mk(ink)
where mi ∈ PI, to specify the protocol between the component with its environment.
RI is a set of methods that are required by the component. When execut- ing methods in PI. When Comp(m) is a design for each m ∈ PI. The component is independent of RI. Therefore, only when Comp assigns some methods in PI to specifications that contain calls to methods that are not in PI, RI is the set of these called methods. Then for each given specifica- tion mapping SpecRI gives each method in RI a design, we can recursively calculate Comp(m) as a design.
RProt is a set of method calls of the form
!m1(out1); ··· ; !mk(outk)
where mi ∈ RI, to specify the possible order in which the required methods may be called by the component.
Note that
ok are wait are local to the component being concerned. So when the guard of a method does not hold when it is called, the calling component is sus- pended, but the owning component of the operation can still accept calls to other operations.
ok and wait are not programming variables and will not be used in any code of an operation.
At the level of functional requirement specification, Comp(m) is a design and thus does not depend on any other services.
At lower levels of abstraction, Comp(m) contains programming statements that may even include calls to methods, called required services, that are not declared in PI.
All these required methods of a component form the required interface. For


a given specification of the required operations, we can calculate Comp(m) as a design. Therefore, a component is a higher order logical formula at low level specification.
We can see that the interfaces of the components describe the UML component diagram of the system, Comp provides a specification of the statechart of the component, and specification of Comp at low level design or implementation can formalize the interaction diagrams among the components, and protocols corresponds to high level interaction diagrams (at the system level).
When Comp(m) are designs for all m ∈ PI, they allow us to calculate the sequences of interactions of the component with its environment that lead the component to a divergent state (or livelock state). From them, we can also calculate the set of refusals, i.e. the set of pairs (s, X) where s is a sequence of interactions between the component with its environment and X is a set of methods which the component my refuse to respond after it has engaged in the sequence s of events. With the set of refusals of a component, we can define the condition of deadlock for the component.
The different parts of a component specification are consistent if it will never enter a deadlock state if its environment follows Prot when it calls the provided services and will react to any call to the required methods in RI. The components of a component system are consistent if the composed system does not deadlock, i.e. the protocols agree with each other, and the specification of the provided methods meets those required.
A component C1 = ⟨St, PI1, Comp1, Prot1, RI, RProt1⟩ is a refinement of component C = ⟨St,PI,Comp,Prot, RI, RProt⟩ if
C1 provides at least as many as services as C, PI ⊆ PI1,
any sequence of call acceptable C is acceptable by C1, Prot ⊆ Prot1,
any environment that can provide services to C well should also provide services to C1 well, RProt1 ⊆ RProc.
We have refinement rules of five categories:
Refine private or provided operations of a component
Add public or private methods. This is useful for incremental and itera- tive development
Delegation of tasks methods to other methods. This formalises the expert pattern in [22], but in a component-based style.
Refine the provided protocol by providing more choices of sequences
Decompose complex components into composition of simpler and more cohesive components.


This are essential for scaling up the method, software to be high cohesive, easy to maintain and reuse

Object-Orientation and Component-Based Develop- ment
In most books on component-based design in the UML framework, e.g. [10,36], components are taken as a family of collaborating objects (or class at the level of templates or styles) without being formally defined. Some papers, e.g. [6,33,1], are critical to object-orientation and think that objects or classes are not composable and thus cannot be treated as objects. To some extend, this true as objects or classes do not specify their required interfaces. On the other hand, all the existing component technologies, such as JavaBeans, EJB, and
.COM, are based on object-oriented methods.
In our framework, we can take a class and translate it to primitive objects easily by calculating the required methods from the code of the class methods. However, in general, a component in our proposed model can be realized by a family of collaborating classes. Therefore, for a component C, we treat the interface methods of C and the protocol as the specification of a the use cases of the component and the components in environment of C as the actors of these use cases. The type of state variables of C may be a class and all the classes and their relationships form a class diagram. The design and implementation of this component can then be carried in a UML-based object-oriented framework.

Conclusion
We have proposed a classical relational model (rCOS ) for component-based and objectoriented development. This model provides a smooth link between component-based design and object-oriented development. This model sup- ports rigorous application of UML in an iterative and incremental development process (RUP). The formalism is based on the design calculus in Hoare and He’s Unifying Theories of Programming [18] In a top-down process, model provides the fundamental basis for Model Driven Development. If we take a bottom-up approach, it supports re-engineering. Our message is: to support programming in the large,
we need a multi-view modelling approach,
a multi-notational modelling language is of a great advantage (though not everyone has to use UML),

consistent refinement of different views is important
different verification techniques may be applied to refinement of different views.
In the framework of ROOL [7], Borba, et al, also investigate refinement of object systems in [5]. Although, ROOL and rCOS share a number of com- mon refinement laws, rCOS supports more features, such as references, and enjoys more refinement laws than ROOL. In our related works, general tran-
sition systems are introduced to provide an integrated model for conceptual class diagrams and use cases (without the treatment of sequence diagrams, state machines and use-case diagrams) [31]. rCOS is used in [29] for the spec- ification UML models of requirements, but a requirement model there only consists of a conceptual class diagram and a use-case model directly specified by rCOS . Article [25] uses rCOS for the specification of design class dia- grams and sequence diagrams, but without rules for model transformation. A tool for requirement analysis has been developed using this framework [26]. Algorithms are also designed for consistency checking and executable code
generation from a system model [32].
Future work includes the completion of the calculus rCOS for component systems, and test it with some case studies. We are also interested in a theory of tool integration within this framework.

References
N. Aguirre and T. Maibaum. A temporal logic approach to component-based system specification and verification. In Proc. ICSE’02, 2002.
P. Andre, A. Romanczuk, J.-C. Royer, and A. Vasconcelos. Checking the consistency of UML class diagrams using Larch Prover. In Proc. ROOM’2000, York, UK, 2000.
E. Astesiano and G. Reggio. An attempt at analysing the consistency problems in the UML from a classical algebraic viewpoint. In Proc. WADT 2002, LNCS 2755. Springer Verlag, 2003.
R.J.R. Back, L. Petre, and I.P. Paltor. Formalizing UML use cases in the refinement calculus. In Proc. UML’99. Springer-Verlag, 1999.
P. Borba, A. Sampaio, and M. Corn´elio. A refinment algebra for object-oriented programming. In L. Cardelli, editor, Proc. ECOOP03, LNCS2743, pages 457–482. Springer, 2003.
M. Broy. Object-oriented programming and software development - a critical assessment. In
A. McIver and C. Morgan, editors, Programming Methodology. Springer, 2003.
A. Cavalcanti and D.A. Naumann. A weakest precondition semantics for an object-oriented language of refinement. Technical Report CS Report 9903, Stevens Institute of Technology, Hoboken, NJ 07030, February 2000.
J. Davis and J.P. Woodcock. Using Z: Speciﬁcation, Reﬁnement and Proof. Prentice Hall, 1996.
E.W. Dijkstra and C.S. Scholten. Predicate Calculus and Program semantics. Springer, 1989.


D. D’Souza and A.C. Wills. Objects, Components and Framework with UML: The Catalysis Approach. Addison-Wesley, 1998.
A. Egyed. Scalable consistency checking between diagrams: The Viewintegra approach. In
Proc. 16th IEEE ASE, San Diego, USA, 2001.
G. Engels, J.M. Kuester, and L. Groenewegen. Consistent interaction of software components. In Pro. of IDPT2002, 2002.
G. Engels, et al. A methodology for specifying and analyzing consistency of object-oriented behavioral models. In The Proc. FSE-10, Austria, 2001.
A. Evans, et al. Developing the UML as a formal modelling notation. In Proc. UML’98, LNCS 1618. Springer-Verlag, 1998.
M. Fowler. What is the point of UML. In P. Srevens, J. Whittle, and G. Booch, editors,
<<UML>> 2003 -The Uniﬁed Modeling Language, 6th International Conference, LNCS 2863, San Fancisco, CA, USA, 2003. Springer.
E. Gamma, et al. Design Patterns. Addison-Wesley, 1995.
J. He, Z. Liu, X. Li, and S. Qin. A relational model of object oriented programs. In Proceedings of the Second ASIAN Symposium on Programming Languages and Systems (APLAS04), Lecture Notes in Computer Science 3302, pages 415–436, Taiwan, March 2004. Springer.
C.A.R. Hoare and J. He. Unifying Theories of Programming. Prentice-Hall, 1998.
I. Jacobson, G. Booch, and J. Rumbaugh. The Uniﬁed Software Development Process. Addison-Wesley, 1999.
C.B. Jones. Software Development: A Rigorous Approach. Prentice Hall International, 1980.
P. Kruchten. The Rational Uniﬁed Process – An Introduction (2nd Edition). Addison-Wesly, 2000.
C. Larman. Applying UML and Patterns. Prentice-Hall International, 2001.
X. Li, Z. Liu, and J. He. Formal and use-case driven requirement analysis in UML. In
COMPSAC01, pages 215–224, Illinois, USA, October 2001. IEEE Computer Society.
X. Li, Z. Liu, and J. He. A formal semantics of UML sequence diagrams. In Proceedings of ASWEC2004, pages 168–177, Melbourne, Australia, 2004. IEEE Computer Society.
X. Li, Z. Liu, J. He, and Q. Long. Generating prototypes from a UML model of requirements. In International Conference on Distributed Computing and Internet Technology (ICDIT2004), Lecture Notes in Computer Science 3347, pages 215–225, Bhubaneswar, India, 2004. Springer.
J. Liu, Z. Liu, J. He, and X. Li. Linking UML models of design and requirement. In Proceedings of ASWEC2004, pages 329–338, Melbourne, Australia, 2004. IEEE Computer Society.
Z. Liu. Object-oriented software development in UML. Technical Report UNU/IIST Report No. 228, UNU/IIST, P.O. Box 3058, Macau, SAR, P.R. China, March 2001.
Z. Liu, J. He, and X. Li. Contract-oriented development of component systems. In Proceedings of IFIP WCC-TCS2004, pages 349–366, Toulouse, France, 2004. Kulwer Academic Publishers.
Z. Liu, J. He, X. Li, and Y. Chen. A relational model for formal requirements analysis in UML. In J.S. Dong and J. Woodcock, editors, Formal Methods and Software Engineering, ICFEM03, LNCS 2885, pages 641–664. Springer, 2003.
Z. Liu, J. He, X. Li, and J. Liu. Unifying views of UML. Electronic Notes of Theoretical Computer Science (ENTCS), 101C:95–127, 2004.
Z. Liu, X. Li, and J. He. Using transition systems to unify UML models. In C. george and
H. Miao, editors, Proc. of International Conference on Formal Engineering Methods (ICFEM 2002), Lecture Notes in Computer Science 2495, pages 535–547, 2002.


Q. Long, Z. Liu, X. Li, and J. He. Consistent code generation from UML models. In Pro. of Australian Software Engineering Conference (ASWEC’2005), Brisbane, Australia, 2005. IEEE Computer Sciety.
F. Luders and K.K. Lau. Specification of software components. In I. Crnkovik and M. Larsson, editors, Building Reliable Component-Based Software Systems, pages 23–38. Artech House, 2002.
S.J. Mellor and M.J. Balcer. Executable UML: a foundation for model-driven architecture. Addison-Wesley, 2002.
C. Pierik and F.S. de Boer. A syntax-directed hoare logic for object-oriented programming concepts. Technical Report UU-CS-2003-010, Institute of Information and Computing Science, Utrecht University, 2003.
R. Pooley and P. Steven. Using UML: Software Engineering with Objects and Component. Addison-Wesley, 1999.
G. Reggio, et al. Towards a rigorous semantics of UML supporting its multiview approach. In
H. Hussmann, editor, Proc. FASE 2001, LNCS 2029. Springer, 2001.
J. Yang, Q. Long, Z. Liu, and X. Li. A predicative semantic model for integrating UML models. In Proceedings of 1st International Colloquium on Theoretical Aspects of Computing (ICTAC), Lecture Notes in Computer Science 3407, Guiyang, China, 2004. Springer.
