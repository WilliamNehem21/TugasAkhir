Electronic Notes in Theoretical Computer Science 177 (2007) 35–57	
www.elsevier.com/locate/entcs

Expander2: Program Verification Between Interaction and Automation
Peter Padawitz1
Informatik 1 University of Dortmund
Germany

Abstract
Expander2 is a flexible multi-purpose workbench for interactive rewriting, verification, constraint solving, flow graph analysis and other procedures that build up proofs or computation sequences. Moreover, tailor- made interpreters display terms as two-dimensional structures ranging from trees and rooted graphs to a variety of pictorial representations that include tables, matrices, alignments, partitions, fractals and turtle systems. Proofs and computations performed with Expander2 follow the rules and the semantics of swinging types. Swinging types are based on many-sorted predicate logic and combine constructor-based types with destructor-based (e.g. state-based) ones. The former come as initial term models, the latter as final models consisting of context interpretations. Relation symbols are interpreted as least or greatest solutions of their respective axioms. This paper presents an overview of Expander2 with particular emphasis on the system’s prover capabilities. It is an adaptation of [21] to the latest version of Expander2. In particular, proof rules tailor-made for transition rule specifications have been added to the system and are discussed and exemplified here for the first time.
Keywords: algebraic and coalgebraic specification, program verification, theorem proving, constraint solving, rewriting, transition systems, modal logics


Introduction
The following design goals distinguish Expander2 from many other proof editors or tools using formal methods:
Expander2 provides several representations of formal expressions and allows the user to switch between linear, tree-like and pictorial ones when executing a proof or computation on formulas or terms.
Proof and computation steps take place at three levels of interaction: the sim- plifier automates routine steps, axiom-triggered computations are performed by narrowing and rewriting, analytical rules like induction and coinduction are applied locally and stepwise.

1 Email: peter.padawitz@udo.edu

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.01.003

The underlying logic is general enough to cover a wide range of applications and to admit the easy integration of special structures or methods by adding or exchanging signatures, axioms, theorems or inference rules including built-in simplifications.
Expander2 has an intelligent GUI that interprets user entries in dependence of the current values of certain global variables. This frees the user from entering input that can be deduced from the context in which the system actually works.
Proofs and computations performed with the system are correct with respect to the semantics of swinging types [17,18,19]. A swinging type is a functional- logic specification consisting of a many-sorted signature and a set of (generalized) Horn or co-Horn axioms (see section 3) that define relation symbols as least or greatest fixpoints and function symbols in accordance with the initial resp. final model induced by the specification.
Sortedness is only implicit because otherwise the proof and computation pro- cesses would become unnecessarily complicated. If used as a specification envi- ronment, the main purpose of Expander2 is proof editing and not type checking.
Therefore, the syntax of signatures is kept as minimal as possible. The only ex- plicit distinction between different types is the one between constants on the one hand and functions and relations on the other hand, expressed by the distinction between first-order variables (fovars) and higher-order variables (hovars). Proofs or computations that depend on a finer sort distinction can always be performed
by introducing and using suitable membership predicates.
The prover features of Expander2 do not aim at the complete automation of proof processes. Instead, they support natural derivations, which humans can com- prehend and thus control easily. Natural deduction avoids skolemization and other extensive normalizations that make formulas unreadable and thus inappropriate for interactive proving. For instance, the simplifier (see Section 5), which turns formulas into equivalent “simplified” ones, prefers implication to negation.
Of course, many conjectures can be proved both comprehensibly and efficiently without any human intervention into the proof process. Such proofs often follow particular schemas and thus may be candidates for derived inference rules. However, proofs of program correctness usually do not fall into this category, especially if induction or coinduction is involved and the original conjecture must be generalized in a particular way.
In fact, the simplifier of Expander2 performs certain normalizations. But they are in compliance with natural deduction and deviate from classical normalizations insofar as, for instance, implications and quantifiers are not eliminated by intro- ducing negations and new signature symbols, respectively. On the contrary, the simplifier eliminates negation symbols by moving them to literal positions and then are removed completely by transforming negated (co)predicates into their comple- ments. Axioms for relations and their complements can be constructed from each
other: If P is a predicate specified by Horn axioms, then these axioms can be trans-
formed systematically into co-Horn axioms for the copredicate not P, and vice versa. This follows from the fact that relation symbols are interpreted by the least resp.

greatest solutions of their axioms provided that these are negation-free and thus induce monotonic consequence operators [17,18].
Expander2 has been written in O’Haskell [12], an extension of Haskell [8] with object-oriented features for reactive programming and a typed interface to Tcl/Tk for developing GUIs. Besides providing a comfortable GUI the overall design goals of Expander2 were to integrate testing, proving and visualizing deductive methods, to admit several degrees of interaction and to keep the system open for extensions or adaptations of individual components to changing demands.
System components

Figure 1. Components of Expander2
The main components of Expander2 are two copies of a solver, a painter, a simplifier an enumerator and a recorder that saves proofs and other computa- tion sequences as well as executable proof terms. As Fig. 1 indicates, the components work together via several interfaces. For instance, the painter is used for drawing normal forms or solutions produced by the solver.
The solver is accessed via a window for editing and displaying a list of trees that represents a disjunction or conjunction of logical formulas or a sum of algebraic terms (see Fig. 2). By moving the slider below the canvas of the solver window one
selects the summand/factor to be shown on the canvas. If the parse text resp. parse
tree button is pushed, the linear representation of a term or formula in the solver’s text field is translated into an equivalent tree representation on the canvas and vice



Figure 2. The solver window
versa. Both representations are editable. As a linear representation is edited by selecting substrings, the tree representation is edited by selecting subtrees or nodes or redirecting edges.
The painter consists of several widget interpreters from which one is selected and applied to the current trees or parts of them. The resulting pictorial represen- tations are displayed in a painter window. Pictures can be edited in the painter
window and completed to widget graphs. Widgets are built up of path, polygon and
turtle action constructors that admit the definition of a variety of pictorial represen- tations ranging from tables and matrices via string alignments, piles and partitions to complex fractals generated by turtle systems [24]. The latter define pictures in terms of sequence of basic actions that a turtle would perform when it draws the picture while moving over the canvas of a window. The turtle works recursively in two ways: it maintains a stack of positions and orientations where it may return to, and it may create trees whose pictorial representations are displayed at its current position.
The solver and its associated painter are fully synchronized: the selection of a tree in the solver window is automatically followed by a selection of the tree’s pictorial representation in the painter window and vice versa. Hence rewriting, narrowing and simplification steps can be carried out from either window.
The enumerator provides algorithms that enumerate trees or graphs and pass

their results both to the solver and the painter. Currently, two algorithms are available: a generator of all sequence alignments [5,20] satisfying constraints that are partly given by axioms, and a generator of all nested partitions of a list with a given length and satisfying constraints given by particular predicates. The painter displays an alignment in the way DNA sequences are usually visualized. A nested partition is displayed as a rectangular dissection of a square where different levels are colored differently.
The user of Expander2 operates on specifications (consisting of signatures and axioms), theorems, substitutions, trees (representing algebraic terms, logical formu- las or transition systems to be evaluated, solved, proved, or executed, respectively) via commands selected from the solver’s menus (see Fig. 2). Sliders control the layout of a tree. With the slider in the middle of a solver window, one browses among several trees. All these actions yield input for the solver and may modify its state variables. Hence the solver can be regarded as a finite automaton whose actions are triggered not only by user input, but also by the actual system state. Here are the main state variables:
The current signature consists of symbols denoting basic speciﬁcations consist- ing of signatures, axioms, theorems and/or conjectures, predicates interpreted as the least solutions of their (Horn) axioms, copredicates interpreted as the great- est solutions of their (co-Horn) axioms, constructors for building up data, deﬁned functions specified by (Horn) axioms or implemented as Haskell functions called
by the simplifier, first-order variables that may be instantiated by terms or formu- las, and higher-order variables that may be instantiated by functions or relations. Most built-in signature symbols have the same syntax and semantics as synonymous Haskell functions (see [20]).
The current axioms and theorems are applied to conjectures and build up the high- or medium-level steps of a computation or proof. Axioms and theorems are applied by narrowing or rewriting. A narrowing/rewriting step starts with uni- fying/matching a subtree (the redex) with/against an axiom. Narrowing applies (guarded) Horn or co-Horn clauses, rewriting applies only unconditional, but possi- bly guarded equations. The guard of an axiom is a subformula to be solved before the axiom is applied.
The widget interpreter pictEval recognizes paintable terms or formulas and transforms them into their pictorial representations (see above).
The current proof records the sequence of derivation steps performed since the last initialization of the list of current trees. Each element of the current proof consists of a description of a rule application, the resulting list of current trees and the resulting values of state variables.
The current proof term represents the current proof as an executable expression for the purpose of later proof checking. It is built up automatically when a derivation
is carried out and can be saved to a user-defined file. A saved proof term is loaded by writing its name into the entry field and pushing check proof term from ﬁle. This action overwrites the current proof term. The proof represented by the loaded proof
is carried out stepwise (and thus checked) on the displayed tree by pushing only the

---> button. Each click triggers a proof step.
treeMode indicates whether the list trees of current trees (or other rooted graphs) is a singleton or represents a disjunction or conjunction of formulas or a sum (= disjoint union) of terms. True, False and () are the respective zero elements. The slider between the canvas and the text field of a solver window allows one to browse among the current trees and to select the one to be displayed on the canvas.
The list treePoss consists of the positions of selected subtrees of the actually displayed tree. Subtrees are selected (and moved) by pushing the left mouse button while placing the cursor over their roots.
varCounter maps a variable x to the maximal index i such that xi occurs in the current proof. varCounter is updated when new variables are needed.
Expander2 allows the user to control proofs and computations at three levels of interaction. At the top level, analytic and synthetic inference rules and other syn- tactic transformations are applied individually and locally to selected subtrees. The rules cover single axiom applications, substitution or unification steps, Noetherian, Hoare, subgoal or fixpoint induction and coinduction. Derivations are correct if, in the case of trees representing terms, their sum is equivalent to the sum of their suc- cessors or, in the case of trees representing formulas, their disjunction/conjunction is implied by the disjunction/conjunction of their successors. The underlying mod- els are determined by built-in data types and the least/greatest interpretation of Horn/co-Horn axioms. Incorrect deduction steps are recognized and cause a warn- ing. All proper tree transformations are recorded, be they correct proofs or other transformations.
At the medium level, rewriting and narrowing realize the iterated and exhaus- tive application of all axioms for the defined functions, predicates and copredicates of the current signature. Rewriting terminates with normal forms, i.e. terms con- sisting of constructors and variables. Terminating narrowing sequences end up with the formula True, False or solved formulas that represent solutions of the initial formula (see section 3). Since the axioms are functional-logic programs in abstract logical syntax, rewriting and narrowing agree with program execution. Hence the medium level allows one to test such programs, while the inference rules of the top level provide a ”tool box” for program verification. In the case of finite data sets, rewriting and narrowing is often sufficient even for program verification. Besides classical relations or deterministic functions, non-deterministic functions (e.g. state transition systems) and ”distributed” transition systems like Maude programs [10] or algebraic nets [26] may also be axiomatized and verified by Expander2. The latter are executed by applying associative-commutative rewriting or narrowing on bag terms, i.e. multisets of terms (see section 3).
At the bottom level, built-in Haskell functions simplify or (partially) evaluate terms and formulas and thereby hide most routine steps of proofs and computations. The functions comprise arithmetic, list, bag and set operations, term equivalence and inequivalence and logical simplifications (see section 5). Evaluating a function f at the medium level means narrowing upon the axioms for f , Evaluating f at the bottom level means running a built-in Haskell implementation of f . This al-

lows one to test and debug algorithms and visualize their results. For instance, translators between different representations of Boolean functions were integrated into Expander2 in this way. In addition, an execution of an iterative algorithm can be split into its loop traversals such that intermediate results become visible. Cur- rently, the computation steps of Gaussian equation solving, automata minimization, OBDD optimization, LR parsing, data flow analysis and global model checking can be carried out and displayed.
Section 3 presents the syntax of the axioms and theorems that can be handled by Expander2 and describes how they are applied to terms or formulas and how the applications build up proofs. Section 4 shows how axiom applications are combined to narrowing or rewriting steps. Section 5 goes into the logical details of the sim- plifier and lists the simplification rules for formulas. Section 6 provides induction, coinduction and other rules that Expander2 offers at the top level of interaction. The correctness of the rules presented in Sections 4, 5 and 6 follows almost imme- diately from corresponding soundness results given in [16,17,18]. The concluding section 7 focuses on future work.
Axioms, theorems, and derivations
Axioms and theorems to be applied in derivations are Horn clauses ((1)-(7)),
co-Horn clauses ((8)-(12)) or tautologies ((13) and (14)):

Curly brackets enclose optional parts. f , p and q denote a defined function, a predicate and a copredicate, respectively, of the current signature. In the case of a higher-order symbol f , p or q, (→t) may denote a “curried” tuple (t→1) ... (t→n). Usually, at1,..., atn are atoms, but may also be more complex formulas (see section 6).
The underlined terms or atoms are called anchors. Each application of a clause to a redex, i.e. a subterm or subformula of the current tree, starts with the search for a most general unifier of the redex and the anchor of the clause. If the unification is successful and the unifier satisfies the guard, then the redex is replaced by the reduct, i.e. the instance of prem, u or conc, respectively, by the unifier. Moreover,

the reduct is augmented with equations that represent the restriction of the unifier to the redex variables (see section 4). If the current trees are terms, then the reducts must be terms and thus only premise-free, but possibly guarded clauses of the form
(1) or (2) can be applied.
A guarded clause is applied only if the instance of the guard by the unifier is solvable. The derived (most general) solution extends the unifier. Guarded axioms are needed for efficiently evaluating ground, i.e. variable-free, formulas. Axioms or theorems used as lemmas in proofs, however, should be unguarded. Otherwise the search for a solution of the guard may block the proof process.
Axioms represent functional-logic programs and thus are of the form (1), (2),
(3) or (8). Axioms determine the least/greatest fixpoint model of a specification (see section 1). Theorems are supposed to be valid in this model. Narrowing and rewriting consist of automatic axiom applications (see section 4). Applications of individual axioms are restricted to the top level of interaction (see section 6).
Axiom (2) can be applied to a bag term t = u1 ∧ ... ∧um if the list [t1,..., tn] unifies with a list [ui1 ,..., uin ] of elements of t such that 1 ≤ i1 ≤ ... ≤ in ≤ m, the unifier satisfies the guard and t is the left-hand side of a transitional atom t → t'. This atom is then replaced by the formula
uσ∧uk σ ∧ ... ∧uk	σ = t'σ {∧ premσ}
where {k1,..., km−n} = {1,..., m}\ {i1,..., in}. If the application of (2) to t fails, the elements of t are permuted. If after 100 permutations (2) is still inapplicable, the last permutation of a will be returned as result - and yield a new starting point for further attempts to apply (2).
For applying a clause of type (1)-(5) or (8)-10), a term/atom at' with posi- tive/negative polarity must be selected in the displayed tree such that the leading term/atom at is unifiable with at'. at' is replaced by the corresponding instance of prem/conc.
For applying a clause of type (6), (7), (11) or (12), n subformulas at' ,..., at'
1	n
must be selected in a disjunction/conjunction ϕ with positive/negative polarity of the displayed tree such that for all 1 ≤ i ≤ n, ati is unifiable with at'. The
summands/factors of ϕ where at' ,..., at' are selected from must not contain
1	n
universal/existential quantifiers or negation or implication symbols. at' ,..., at'
1	n
are replaced by the corresponding instance of prem/conc. The resulting sum- mands/factors are combined conjunctively in the case of a Horn clause and dis- junctively in the case of a co-Horn clause (see section 6).
For applying a tautology, select a subformula ϕ in the displayed tree. In case (13), ϕ is replaced by the conjunction ∀→zconc ⇒ ϕ. In case (14), ϕ is replaced by ¬ϕ ⇒ ∃→zprem where →z consists of the free variables of conc resp. prem. The
replacement is usually followed by a substitution of →z by terms →t of ϕ, i.e. ∀→zconc ⇒ ϕ
and ¬ϕ ⇒ ∃→zprem are turned into the goals conc[→t/→z] ⇒ ϕ and ¬ϕ ⇒ prem[→t/→z], respectively.
Example 1 We specify finite lists with a defined function flatten for flattening lists of lists and a predicate part for generating list partitions:


constructs: [] :
defuncts:	flatten preds:	part
fovars:	x y s s’ p
axioms:	part([x],[[x]])	&
(part(x:y:s,[x]:p) <=== part(y:s,p))	&
(part(x:y:s,(x:s’):p) <=== part(y:s,s’:p)) & flatten[] = []	&
flatten(s:p) = s++flatten(p)
Example 2 We specify streams (infinite lists) with defined functions head, tail and eq, a constant stream blink and, given a Boolean function f , a predicate exists(f ) and a copredicate fair(f) that check whether f holds true for some element resp. infinitely many elements of the stream argument: 2

Example 3 We specify modal-logic formulas in terms of first- or second-order state predicates (for least fixpoints) and copredicates (for greatest fixpoints). The binary predicate → denotes the underlying LTS:
constructs: a b
preds:	P true OD Y -> copreds:	false OB X fovars:	x st st’
hovars:	P
axioms:	true(st)	&
(false(st) ===> False)	&
(OD(x)(P)(st) <=== (st,x) -> st’ & P(st’))	&
(OB(x)(P)(st) ===> ((st,x) -> st’ ==> P(st’)))	&
(X(st) ===> Y(st))	&
(X(st) ===> OB(b)(X)(st))	&
(Y(st) <=== OD(a)(true)(st))	&
(Y(st) <=== OD(b)(Y)(st))	&
(2,b) -> 1 & (2,b) -> 3 & (3,b) -> 3 & (3,a) -> 4 & (4,b) -> 3
A derivation with Expander2 is a sequence of successive values of the state variable trees (see Section 2). It is stored in the state variables proof and proof term. All three variables are initialized when the contents of the text field is parsed and the resulting tree t is displayed on the canvas. Then the state variable trees is set to the singleton [t].
A derivation is correct if the derived disjunction/conjunction (resp. sum) of the current trees implies (resp. is a possible result of) the original one. The under- lying semantics is described in section 1. Built-in symbols are interpreted by the simplifier. Expander2 checks the correctness of each derivation step and delivers a warning if the step may be incorrect.
A correct derivation that ends up with the formula True or F alse is a proof resp.
refutation of the original formula ϕ. Further possible results are solved formulas,

2 & and | denote conjunction and disjunction, respectively.

which are conjunctions of existentially quantified equations or universally quantified inequations that represent a substitution of the free variables of ϕ by normal forms (see section 2). The substitution is a solution of ϕ if the derivation of the solved formula is correct.
The correctness of a derivation step depends on the polarity of the redex with respect to its position within the current trees. The polarity is positive if the number of preceding negation symbols or premise positions is even. Otherwise it is negative. A rule is analytical or expanding if the reduct implies the redex. Here the redex must have positive polarity if the derivation step shall be correct. A rule is synthetical or contracting if the redex implies the reduct. Here the redex must have negative polarity if the derivation step shall be correct. Expander2 checks these applicability conditions automatically. Of course, both analytical and synthetical rules transform a redex into an equivalent formula and thus may be applied regardless of the polarity.

Narrowing and rewriting
The narrowing procedure of Expander2 applies axioms and simplification rules re- peatedly from top to bottom and from left to right, first to the currently displayed tree and then to other current trees. Usually, all applicable axioms for the anchor of a redex are applied simultaneously. Hence narrowing steps within a proof provide case distinctions.
Applying all applicable (Horn) axioms for a predicate or defined function simul- taneously results in the replacement of the redex by the disjunction of their premises together with equations representing the computed unifiers (see Section 3). Apply-
ing all applicable (co-Horn) axioms for a copredicate simultaneously results in the replacement of the redex by the conjunction of their conclusions. The narrowing rules read as follows:
narrowing upon a predicate p /=→
p(t)

k i=1
∃Zi : (ϕiσi ∧ →x = →xσi)

where γ1 ⇒ (p(t1) ⇐= ϕ1),..., γn ⇒ (p(tn) ⇐= ϕn) are the axioms for p, (∗)	→x is a list of the variables of t,
for all 1 ≤ i ≤ k, tσi = tiσi, γiσi ▶ True 3 and Zi = var(ti, ϕi),
for all k < i ≤ n, t is not unifiable with ti.
narrowing upon a copredicate p

p(t)

k i=1
∀Zi : (→x = →xσi ⇒ ϕiσi)



3 Hence σi solves the guard γi. Expander2 tries to solve γi by applying at most 100 narrowing steps.

where γ1 ⇒ (p(t1) =⇒ ϕ1),..., γn ⇒ (p(tn) =⇒ ϕn) are the axioms for p and (∗) holds true.
narrowing upon a defined function f
r(...,f (t),.. .)

  k	∃Zi : (r(..., ui,.. .)σi ∧ ϕiσi ∧ →x = →xσi) ∨

i=1  l	( (
( )	)	=	)

i=k+1 r ...,f t ,... σi ∧ →x
where r is a predicate or copredicate,
→xσi

γ1 ⇒ (f (t1) = u1 ⇐= ϕ1),..., γn ⇒ (f (tn) = un ⇐= ϕn) are the axioms for f ,
(∗∗)	→x is a list of the variables of t,
for all 1 ≤ i ≤ k, tσi = tiσi, γiσi ▶ True and Zi = var(ti, ϕi), for all k < i ≤ l, σi is a partial unifier of t and ti,
for all l < i ≤ n, t is not partially unifiable with ti.
narrowing upon the predicate →
t ∧v → t'

  k	∃Zi : ((ui ∧v)σi = t'σi ∧ ϕiσi ∧ →x = →xσi) ∨

i=1   l
(( ∧ )	'	=	)

i=k+1 t
v σi → t σi ∧ →x
→xσi

where γ1 ⇒ (t1 → u1 ⇐= ϕ1),..., γn ⇒ (tn → un ⇐= ϕn) are the axioms for →, (∗∗) holds true and σi is a unifier modulo associativity and commutativity of ∧
elimination of non-narrowable atoms and terms

p(t)


False
q(t)


True
r(...,f (t),.. .)


r(..., (),.. .)
t → t'

() → t'

where p /=→ is a predicate, q is a copredicate, r is a predicate or copredicate, f is a defined function, t is a normal form and for all axioms γ ⇒ (p(u) ⇐= ϕ), γ ⇒ (q(u) =⇒ ϕ), γ ⇒ (f (u) = v ⇐= ϕ) and γ ⇒ (u → v ⇐= ϕ), t and u are not unifiable.
u1,..., un may be tuples of terms. In the case of narrowing upon a defined function, the unification of t with ui may fail because at some position, the root symbols of t and ui are different and one of them is a defined function f . Since the unification may succeed later, when subsequent narrowing steps have replaced f by a constructor or a variable, we save the already obtained partial unifier σi and construct a reduct that consists of the σi-instance of the redex and equations that represent σi. This version of the narrowing rule has been derived from the needed narrowing strategy [1,16]. If the underlying specification is functional, the strategy of applying these narrowing rules iteratively from top to bottom to a formula ϕ leads to a set S of solutions of ϕ such that each solution of ϕ is an instance of some s ∈ S [17,18]. Hence, in the context of this strategy, the narrowing rules are equivalence transformations.
If the current trees are terms, only rewriting steps can be applied. Rewriting is the special case of narrowing upon defined functions where the unifiers σi do not instantiate redex variables:

rewriting upon a defined function f

c(f (t))
c(u1σ1)<+>... <+>c(ukσk)
where γ1 ⇒ f (t1) = u1,..., γ1 ⇒ f (tn) = un are the axioms for f and (∗)	for all 1 ≤ i ≤ k, t = tiσi and γiσi ▶ True,
for all k < i ≤ n, t does not match ti.
rewriting upon the predicate →

c(t) c(u1σ1)<+>... <+>c(ukσk)

where γ1 ⇒ t1 → u1,..., γ1 ⇒ tn → un are the axioms for → and (∗) holds true.
elimination of non-rewritable terms
f (t)
()

where f is a defined function, t is a normal form and for all axioms γ ⇒ f (u) = v and γ ⇒ u → v, t and u are not unifiable.

Simplification
Narrowing removes predicates, copredicates and defined functions from the current trees. The simplifier does the same with logical operators, constructors and symbols of the built-in signature. Simplifications realize the highest degree of automation and the lowest level of interaction (see section 2). The reducts of rewriting or narrowing steps are simplified automatically.
The evaluation rules used by the simplifier are equivalence transformations. Be-
sides the partial evaluation of built-in predicates and functions, the following rules are applied: 4
Elimination of zeros and ones


ϕ ∧ True

ϕ
ϕ ∨ False

ϕ
ϕ ∧ False False
ϕ ∨ True True
() → t
False
t <+> ()


t



Flattening

ϕ ∧ (ψ1 ∧ ... ∧ ψn)
ϕ ∧ ψ1 ∧ ... ∧ ψn

ϕ ∨ (ψ1 ∨ ... ∨ ψn)
ϕ ∨ ψ1 ∨ ... ∨ ψn




4 The binding-priority ordering of logical operators is given by {¬, ∀, ∃} > ∧ > ∨ > ⇒.

Disjunctive normal form Let f be a function and p be a (co)predicate.

	f (..., t1 <+> .. . <+> tn,.. .)	
f (..., t1,.. .) <+> ... <+> f (..., tn,.. .)
 p(..., t1 <+> .. . <+> tn,.. .) 
p(..., t1,.. .) ∨ ... ∨ p(..., tn,.. .)

	ϕ ∧ ∀→x(ψ1 ∨ ... ∨ ψn)	
∀→x((ϕ ∧ ψ1) ∨ ... ∨ (ϕ ∧ ψn))
if no x ∈ →x occurs freely ϕ

Term decomposition Let c and d be different constructors.

c(t1,..., tn) = c(u1,..., un) t1 = u1 ∧ ... ∧ tn = un
c(t1,..., tn) /= c(u1,..., un) t1 /= u1 ∨ ... ∨ tn /= un
Quantifier distribution
c(t1,..., tn) = d(u1,..., un)
False
c(t1,..., tn) /= d(u1,..., un)
True

 ∀→x(ϕ1 ∧ ... ∧ ϕn)
∀→xϕ1 ∧ ... ∧ ∀→xϕn
 ∃→x(ϕ1 ∨ ... ∨ ϕn)
∃→xϕ1 ∨ ... ∨ ∃→xϕn
∃→x(ϕ ⇒ ψ)

∀→xϕ ⇒ ∃→xψ

 ∃→x(ϕ1 ∧ ... ∧ ϕn) 
∃x→1ϕ1 ∧ ... ∧ ∃x→nϕn
 ∀→x(ϕ1 ∨ ... ∨ ϕn) 
∀x→1ϕ1 ∨ ... ∨ ∀x→nϕn

if →x = x→1 ∪ ... ∪ x→n and for all 1 ≤ i ≤ n, no variable of x→i occurs freely in some ϕj, 1 ≤ j ≤ n, j /= i.
Removal of negation.	Negation symbols are moved to literal positions where they are replaced by complement predicates: ¬P (t) is reduced to not P (t),
¬not P (t) is reduced to P (t). Co-Horn/Horn axioms for not P can be generated
automatically from Horn/Co-Horn axioms for P .
Removal of quantifiers. Unused bounded variables are removed. Successive quantifiers are merged.
Subsumption

ϕ ⇒ ψ
True
ϕ ∧ ψ ϕ
ϕ ∨ ψ ψ
ϕ ∧ (ψ ⇒ θ) ϕ ∧ θ

if ϕ subsumes ψ

Subsumption is the least binary relation on terms and formulas that satisfies the following implications: Let ∼ be the syntactic equality of formulas modulo the re- arrangement of arguments of permutative operators and the renaming of variables.
ϕ or ψ subsumes ϑ	=⇒ ϕ subsumes ψ ⇒ ϑ ϕ' subsumes ϕ, ϕ subsumes ψ and ψ subsumes ψ'
=⇒ ϕ ⇒ ψ subsumes ϕ' ⇒ ψ'
ψ subsumes ϕ	=⇒ ¬ϕ subsumes ¬ψ
∃ 1 ≤ i ≤ n : ϕ subsumes ψi =⇒ ϕ subsumes ψ1 ∨ ... ∨ ψn
∀ 1 ≤ i ≤ n : ϕ subsumes ψi =⇒ ϕ subsumes ψ1 ∧ ... ∧ ψn
∀ 1 ≤ i ≤ n : ϕi subsumes ψ =⇒ ϕ1 ∨ ... ∨ ϕn subsumes ψ
∃ 1 ≤ i ≤ n : ϕi subsumes ψ =⇒ ϕ1 ∧ ... ∧ ϕn subsumes ψ ϕ(→x) subsumes ψ(→x)	=⇒ ∃→xϕ(→x) subsumes ∃→yψ(→y) ϕ(→x) subsumes ψ(→x)	=⇒ ∀→xϕ(→x) subsumes ∀→yψ(→y)
∃ →t : ϕ ∼ ψ(→t)	=⇒ ϕ subsumes ∃→xψ(→x)
∃ →t : ψ ∼ ϕ(→t)	=⇒ ∀→xϕ(→x) subsumes ψ

Elimination of equations and inequations. Let x ∈ →x \ var(t).

∃→x(x = t ∧ ϕ)

∃→xϕ[t/x]
∀→x(x /= t ∨ ϕ)

∀→xϕ[t/x]

∀→x(x = t ∧ ϕ ⇒ ψ)

∀→x(ϕ ⇒ ψ)[t/x]
∀→x(ϕ ⇒ x /= t ∨ ψ)

∀→x(ϕ ⇒ ψ)[t/x]

Substitution by normal forms. Let x ∈ →x \ var(t) and t be a normal form.

∃→x(x = t ∧ ϕ)

∃→x(x = t ∧ ϕ[t/x])
∀→x(x /= t ∨ ϕ)

∀→x(x /= t ∨ ϕ[t/x])

∀→x(x = t ∧ ϕ ⇒ ψ)

∀→x(x = t ∧ ϕ[t/x] ⇒ ψ[t/x])
∀→x(ϕ ⇒ x /= t ∨ ψ)

∀→x(ϕ[t/x] ⇒ x /= t ∨ ψ[t/x])

Universal quantification of implications


∃→xϕ ⇒ ψ

∀→x(ϕ ⇒ ψ)
ψ ⇒ ∀→xϕ

∀→x(ψ ⇒ ϕ)
if no variable of →x occurs freely in ψ

Implication splitting
	∀→x(ϕ1 ∨ ... ∨ ϕn ⇒ ψ)	
∀→x(ϕ1 ⇒ ψ) ∧ ... ∧ ∀→x(ϕn ⇒ ψ)
Uncurrying


	∀→x(ϕ ⇒ ψ1 ∧ ... ∧ ψn)	
∀→x(ϕ ⇒ ψ1) ∧ ... ∧ ∀→x(ϕ ⇒ ψn)

ϕ ⇒ (θ ⇒ ψ1) ∨ ψ2
ϕ ∧ θ ⇒ ψ1 ∨ ψ2
Besides being an essential part of proof processes, simplification in Expander2 may be used for testing algorithms, especially iterative ones, which change values of state terms during loop traversals [20]. Several such algorithms have been integrated into the simplifier by translating a loop traversal into a simplification step. Consequently, intermediate results can be visualized in a painter window (see Section 2). The respective state terms are created by applying particular equational axioms.
Similarly to narrowing and rewriting, the simplifier pursues a top-down strategy that ensures termination and the eventual application of all applicable rules. This is necessary because it usually works in the background. For instance, narrowing reducts are simplified automatically before they are submitted to further narrowing steps.
The notion of simplification differs from prover to prover. For instance, Isabelle
[13] subsumes rewriting upon equational axioms under simplification.
Rules at the top level of interaction
Narrowing steps and simplifications are both analytical and synthetical and thus turn formulas into semantically equivalent ones.  Instances of the rules that are

accessible via the solver’s selection menu (see Fig. 2), however, may be strictly analytical or strictly synthetical. Hence they can be applied only individually and only to subtrees with positive resp. negative polarity (see Section 3). We describe the main rules in terms of the actions to be taken by the user in order to apply them.
Instantiation. Select an existentially/universally quantified variable x. If the scope of x has positive/negative polarity, then all occurrences of x in the scope are replaced by the term in the solver’s entry field. Alternatively, the replacing term t may be taken from the dispalyed tree and moved to a position of x in the scope. Again, all occurrences of x in the scope are replaced by t.
Generalization. Select a subformula ϕ and enter a formula ψ into the solver’s entry field. If ϕ has positive/negative polarity, then ϕ is combined conjunc- tively/disjunctively with ψ.
Unification. Select two factors of a conjunction ϕ = E→x(ϕ1 Λ ... Λ ϕn) or two summands of a disjunction ψ = 6→x(ϕ1 V ... V ϕn). If they are unifiable and the unifier instantiates only variables of →x, then one of them is removed and the unifier is applied to the remaining conjunction/disjunction. The transformation is correct if ϕ/ψ has positive/negative polarity.
Copy. Select a subtree ϕ. A copy of ϕ is added to the children of the subtree’s parent node. The transformation is correct if the parent node holds a conjunction or disjunction symbol.
Removal. Select subtrees φ1,..., φn. φ1,..., φn are removed from the displayed
tree. The transformation is correct if φ1,..., φn are summands/factors of the same disjunction/conjunction with positive/negative polarity.
Reversal. The list of selected subtrees is reversed. The transformation is correct if all subtrees are arguments of the same occurrence of a permutative operator. Currently, the permutative operators are:

&, |, =, = / =, ~, ~ / ~, +, ∗, ∧, {}.


Atom decomposition.
f (t1,..., tn) = f (u1,..., un) t1 = u1 Λ ... Λ tn = un
Replacement by other sides.


f (t1,..., tn) /= f (u1,..., un) t1 /= u1 V ... V tn /= un



t = u Λ ϕ(t)
t = u Λ ϕ(u) 🅘
t /= u V ϕ(t)
t /= u V ϕ(u) 🅘

t = u Λ ϕ(t) ⇒ ψ(t)
t = u Λ ϕ(u) ⇒ ψ(u) 🅘
ϕ(t) ⇒ t /= u V ψ(t) ϕ(u) ⇒ t /= u V ψ(u) 🅘

Transitivity. Select an atom tRt' with positive polarity or n — 1 factors
t1Rt2, t2Rt3, . . . , tn−1Rtn

of a conjunction with negative polarity such that R is among <, ≤, >, ≥, =, ~ . The selected atoms are decomposed resp. composed in accordance with the assumption that R is transitive.
Constrained narrowing. Select subtrees φ1,..., φn and write axioms into the text field or a signature symbol f into the solver’s entry field. Then narrow- ing/rewriting steps upon the axioms in the text field or the axioms for f , respec- tively, are applied to φ1,..., φn.
Axiom/theorem application. Select subtrees φ1,..., φn and write the num- ber of an axiom or theorem into the solver’s entry field. The selected axiom or theorem ψ is applied from left to right or from right to left to φ1,..., φn. Left/right refers to t resp. u if ψ has the form tRu ⇐= prem where R is symmetric and to the formula left/right of ⇐= resp. =⇒ in all other cases. The transformation is correct if the conclusion/premise of ψ has positive/negative polarity.
A clause of type (6), (7), (11) or (12) is applied to atoms at' ,..., at' each of
1	n
which is part of a conjunction or disjunction: Let →z consist of the free variables of
prem resp. conc that do not occur in at1,..., atn.
ϕ1(at' ) Λ ... Λ ϕn(at' )

application of (6)
(  n	(	(	1
))) ⇑

i=1 ϕi E→z premσ Λ
x∈dom(σ) x ≡ xσ


where for all 1 ≤ i ≤ n, at'σ = atiσ and ϕi does not contain existential quantifiers or negation or implication symbols.
ϕ1(at' ) V ... V ϕn(at' )

application of (7)
(  n	(	(	1
))) ⇑

i=1 ϕi E→z premσ Λ
x∈dom(σ) x ≡ xσ


where for all 1 ≤ i ≤ n, at'σ = atiσ and ϕi does not contain universal quantifiers or negation or implication symbols.
ϕ1(at' ) Λ ... Λ ϕn(at' )

application of (11)
( n
(	(  1
))) ↓

i=1 ϕi 6→z	x∈dom(σ) x ≡ xσ ⇒ concσ

where for all 1 ≤ i ≤ n, at'σ = atiσ and ϕi does not contain existential quantifiers or negation or implication symbols.
ϕ1(at' ) V ... V ϕn(at' )

application of (12)
( n
(	(  1
))) ↓

i=1 ϕi 6→z	x∈dom(σ) x ≡ xσ ⇒ concσ

where for all 1 ≤ i ≤ n, at'σ = atiσ and ϕi does not contain universal quantifiers or negation or implication symbols.
Noetherian induction. Select a list of free or universal induction variables x1,..., xn in the displayed tree. If ϕ = (prem ⇒ conc), then the induction hypothe- ses
conc' ⇐= (x1,..., xn)   (x' ,..., x' ) Λ prem'
prem' =⇒ ((x ,...,x )   ( 1'	n ) ⇒ conc')
1	n	x ,..., x'
1	n

are added to the current theorems. If ϕ is not an implication, then

conc' ⇐= (x1,..., xn)   (x' ,..., x' )
1	n

is added. Primed formulas are obtained from unprimed ones by priming the oc- currences of x1,..., xn. denotes the induction ordering. Each left-to right ap- plication of an added theorem corresponds to an induction step and introduces an occurrence of . After axioms for have been added to the current axioms, narrowing steps upon should remove the occurrences of because the transfor- mation is correct only if ϕ can be derived to True [15,16].
Shift of subformulas. Select an implication

ϕ = (prem1 Λ ... Λ premm ⇒ conc1 V ... V concn),

premise indices i1,..., ik and conclusion indices j1,..., jl. ϕ is turned into the equivalent implication
premi' Λ ... Λ premi' Λ ¬concj1 Λ ... Λ ¬concjl
1	r
⇒	concj' V ... V concj' V ¬premi1 V ... V ¬premik
1	s
where i' ,..., i' = {1,..., m}\ {i1,..., ik} and j' ,..., j' = {1,..., n}\ {j1,..., jl}.
1	r	1	s
For instance, such a transformation may be necessary for turning ϕ into a formula to which fixpoint induction or coinduction, respectively, can be applied.
The following rules are correct if the selected subformulas have positive polarity. For each predicate, copredicate or function p, let AXp be the set of axioms for p.
Coinduction on a copredicate p. Select subformulas

{prem1 ⇒} p(t→1)
Λ ...	(A)
Λ {premk ⇒} p(t→k)
such that p does not depend on any predicate or function occurring in premi.
is turned into

p(→x)	⇐=	{prem1 Λ} →x = t→1
Λ ...	(A’)
Λ {premk Λ} →x = t→k

where →x is a list of variables. Moreover, a new predicate p' is added to the current signature and
p'(→x)	⇐=	{prem1 Λ} →x = t→1
Λ ...	(*)
Λ {premk Λ} →x = t→k
becomes the axiom for p'.  (*) is applied to AXp[p'/p].  The conjunction of the resulting clauses replaces the original conjecture (A).

Fixpoint induction on a predicate p. Select subformulas
p(t→1) ⇒ conc1
Λ ...	(B)
Λ p(t→k) ⇒ conck
such that p does not depend on any predicate or function occurring in conci.
is turned into
p(→x)	=⇒	(→x = t→1 ⇒ conc1)
Λ ...	(B’)
Λ (→x = t→k ⇒ conck)
where →x is a list of variables. Morever, a new predicate p' is added to the current signature and
p'(→x)	=⇒	(→x = t→1 ⇒ conc1)
Λ ...	(*)
Λ (→x = t→k ⇒ conck)
becomes the axiom for p'.  (*) is applied to AXp[p'/p].  The conjunction of the resulting clauses replaces the original conjecture (B).
Fixpoint induction on a function f . Select subformulas
f (t→1) = u1 ⇒ conc1
Λ ...	(C)
Λ f (t→k) = uk ⇒ conck
or
f (t→1) = u1 {Λ conc1}
Λ ...	(D)
Λ f (t→k) = uk {Λ conck}
such that f does not depend on any predicate or function occurring in ui or conci.
is turned into
f (→x) = z	=⇒	(→x = t→1 Λ z = u1 ⇒ conc1)
Λ ...	(C’)
Λ (→x = t→k Λ z = uk ⇒ conck),
is turned into
f (→x) = z	=⇒	(→x = t→1 ⇒ z = u1{Λ conc1})
Λ ...	(D’)
Λ (→x = t→k ⇒ z = uk{Λ conck})
where →x is a list of variables and z is a variable. Moreover, a new predicate f' is added to the current signature and
f'(→x, z)	=⇒	((→x = t→1 Λ z = t1) ⇒ conc1)
Λ ...	(*)
Λ ((→x = t→k Λ z = tk) ⇒ conck)

resp.

f'(→x, z)	=⇒	(→x = t→1 ⇒ (z = t1{Λ conc1}))
Λ ...	(*)
Λ (→x = t→k ⇒ (z = tk{Λ conck}))

becomes the axiom for f'. (*) is applied to flat(AXf )[f'/(f ( ) ≡ )]. The conjunc- tion of the resulting clauses replaces the original conjecture (C)/(D).
Hoare induction. Select a subformula of the form (C) or (D) such that k = 1 and f has a single axiom of the form f (→x) = loop(→v). (C)/(D) is turned into (C’)/(D’) and then transformed into the following conjectures, which characterize INV as a Hoare invariant:
INV (→x, →v)	(INV 1)
loop(→y) = z Λ INV (→x, →y) ⇒ conc1	(INV 2)
Subgoal induction. Same as Hoare induction except that the following con- jectures are created, which characterize INV as a subgoal invariant:
INV (→v, z)	⇒ conc1	(INV 1)
loop(→y) = z ⇒ INV (→y, z)	(INV 2)
Example 1 (continued) An Expander2 proof by fixpoint induction is pre- sented. The conjecture says that part returns only partitions of the given list. 5 .
part(s,p) ==> s = flatten(p) Applying fixpoint induction w.r.t.
part([x],[[x]])
& (part(x:(y:s),[x]:p) <=== part(y:s,p))
& (part(x:(y:s),(x:s’):p) <=== part(y:s,s’:p))
at position [] of the preceding formula leads to a single formula, which is given by All x y s p s’:
( [x] = flatten[[x]]
& (x:(y:s) = flatten([x]:p) <=== y:s = flatten(p))
& (x:(y:s) = flatten((x:s’):p) <=== y:s = flatten(s’:p))) Simplifying the preceding formula (5 steps) leads to
All x:([x] = flatten[[x]])
& All x y s p:(y:s = flatten(p) ==> x:(y:s) = flatten([x]:p))
& All x y s p s’:(y:s = flatten(s’:p) ==> x:(y:s) = flatten((x:s’):p)) Narrowing at position [0] of the preceding formula (2 steps) leads to
True
& All x y s p:(y:s = flatten(p) ==> x:(y:s) = flatten([x]:p))
& All x y s p s’:(y:s = flatten(s’:p) ==> x:(y:s) = flatten((x:s’):p)) Simplifying the preceding formula leads to
All x y s p:(y:s = flatten(p) ==> x:(y:s) = flatten([x]:p))
& All x y s p s’:(y:s = flatten(s’:p) ==> x:(y:s) = flatten((x:s’):p))
Applying the axioms
flatten(s13:p10) = s13++flatten(p10) & flatten(s11:p8) = s11++flatten(p8)
at positions [1,0,1],[0,0,1] of the preceding formula leads to All x y s p:(y:s = flatten(p) ==> x:(y:s) = [x]++flatten(p))
& All x y s p s’:(y:s = flatten(s’:p) ==> x:(y:s) = (x:s’)++flatten(p))

5 All and Any denote universal and existential quantification, respectively


Simplifying the preceding formula (21 steps) leads to
All y s p s’:(y:s = flatten(s’:p) ==> y:s = s’++flatten(p))
Applying the axiom
flatten(s15:p12) = s15++flatten(p12)
at position [0,0] of the preceding formula leads to
All y s p s’:(y:s = s’++flatten(p) ==> y:s = s’++flatten(p)) Simplifying the preceding formula (2 steps) leads to
True

A proof by Noetherian induction of the same conjecture is less straightforward and more than twice as long as the one above (see [20], Examples, PARTproof2).
Example 2 (continued) An Expander2 proof by coinduction is presented. The conjecture says that blink and 1:blink contain infinitely many zeros.
fair(eq(0))(blink) & fair(eq(0))(1:blink) Applying coinduction w.r.t.
fair(f)(s) ===> exists(f)(s) & fair(f)(tail(s))
at position [] of the preceding formula leads to the formula All f s:
(	f = eq(0) & s = blink | f = eq(0) & s = 1:blink
===>	exists(f)(s)
& (f = eq(0) & tail(s) = blink | f = eq(0) & tail(s) = 1:blink))
Simplifying the preceding formula (44 steps) leads to exists(eq(0))(1:blink) & tail(blink) = 1:blink & exists(eq(0))(blink)
| exists(eq(0))(1:blink) & tail(blink) = blink & exists(eq(0))(blink)
Narrowing the preceding formula leads to
exists(eq(0))(tail(1:blink)) & tail(blink) = 1:blink & exists(eq(0))(blink)
| exists(eq(0))(1:blink) & tail(blink) = blink & exists(eq(0))(blink) Narrowing the preceding formula leads to
True & tail(blink) = 1:blink & exists(eq(0))(blink)
| exists(eq(0))(1:blink) & tail(blink) = blink & exists(eq(0))(blink)
Simplifying the preceding formula leads to tail(blink) = 1:blink & exists(eq(0))(blink)
| exists(eq(0))(1:blink) & tail(blink) = blink & exists(eq(0))(blink)
Narrowing the preceding formula leads to 1:blink = 1:blink & exists(eq(0))(blink)
| exists(eq(0))(1:blink) & tail(blink) = blink & exists(eq(0))(blink)
Simplifying the preceding formula (3 steps) leads to exists(eq(0))(blink)
Narrowing the preceding formula leads to True
Example 3 (continued) An Expander2 proof by coinduction is presented. The conjecture says that states 3 and 4 satisfy the predicate X.
X(3) & X(4)
Applying coinduction w.r.t. (X(st) ===> Y(st))


& (X(st) ===> OB(b)(X)(st))
at position [] of the preceding formula leads to All st:
( (st = 3 | st = 4 ===> Y(st))
& (st = 3 | st = 4 ===> OB(b)(X0)(st))) Simplifying the preceding formula (14 steps) leads to Y(3) & Y(4) & OB(b)(X0)(3) & OB(b)(X0)(4)
The rest of the proof is a sequence of formulas each of wich is derived from its predecessor by a narrowing step:
OD(a)(true)(3) & Y(4) & OB(b)(X0)(3) & OB(b)(X0)(4)
| OD(b)(Y)(3) & Y(4) & OB(b)(X0)(3) & OB(b)(X0)(4)
Any st’0:((3,a) -> st’0 & true(st’0)) & Y(4) & OB(b)(X0)(3) & OB(b)(X0)(4)
| OD(b)(Y)(3) & Y(4) & OB(b)(X0)(3) & OB(b)(X0)(4)
true(4) & Y(4) & OB(b)(X0)(3) & OB(b)(X0)(4)
| OD(b)(Y)(3) & Y(4) & OB(b)(X0)(3) & OB(b)(X0)(4) Y(4) & OB(b)(X0)(3) & OB(b)(X0)(4)
OD(a)(true)(4) & OB(b)(X0)(3) & OB(b)(X0)(4)
| OD(b)(Y)(4) & OB(b)(X0)(3) & OB(b)(X0)(4)
Any st’1:((4,a) -> st’1 & true(st’1)) & OB(b)(X0)(3) & OB(b)(X0)(4)
| OD(b)(Y)(4) & OB(b)(X0)(3) & OB(b)(X0)(4)
OD(b)(Y)(4) & OB(b)(X0)(3) & OB(b)(X0)(4)
Any st’2:((4,b) -> st’2 & Y(st’2)) & OB(b)(X0)(3) & OB(b)(X0)(4) Y(3) & OB(b)(X0)(3) & OB(b)(X0)(4)
OD(a)(true)(3) & OB(b)(X0)(3) & OB(b)(X0)(4)
| OD(b)(Y)(3) & OB(b)(X0)(3) & OB(b)(X0)(4)
Any st’3:((3,a) -> st’3 & true(st’3)) & OB(b)(X0)(3) & OB(b)(X0)(4)
| OD(b)(Y)(3) & OB(b)(X0)(3) & OB(b)(X0)(4)
true(4) & OB(b)(X0)(3) & OB(b)(X0)(4)
| OD(b)(Y)(3) & OB(b)(X0)(3) & OB(b)(X0)(4) OB(b)(X0)(3) & OB(b)(X0)(4)
All st’4:((3,b) -> st’4 ==> X0(st’4)) & OB(b)(X0)(4) X0(3) & OB(b)(X0)(4)
OB(b)(X0)(4)
All st’5:((4,b) -> st’5 ==> X0(st’5)) X0(3)
True


7	Conclusion
We have given an overview of Expander2 with special focus on the system’s prover capabilities. Other features, such as the generation, editing and combination of pictorial term representations or the use of state terms by the simplifier are described in detail in [20]. Future work on Expander2 and on the underlying Swinging Types approach will concentrate on the following:
Representation of coalgebraic data types in terms of coinductively defined
functions and of corresponding subtypes defined in terms of co-Horn clauses for

membership predicates or coequalities. First steps towards this extension can be found in [19]. Coalgebraic specifications are also dealt with in, e.g., [6,23,9,11]. O’Haskell records [12] may be suitable for embedding standard coalgebraic data types into the simplifier.
Compilers that translate functional or relational programs written in, e.g., Haskell, Maude [10], Prolog or Curry [7] into simplification rules. This might involve the combination of particular programming language constructs and their semantics with the pure algebraic-logic semantics of Expander2 specifications. Related work has been done by combining the algebraic specification language CASL [3] with Haskell [25].
A compiler of UML class diagrams and OCL constraints into Expander2 specifications has been developed in a students’ project. This yields a basis for proving invariants, reachabilities and other safety or liveness properties of object- oriented specifications within Expander2.
Commands for the automatic generation of particular axioms, theorems or simplification rules. Such commands are already available for specifying complement predicates, deriving “generic” lemmas from the least/greatest fixpoint semantics of relations and for turning co-Horn axioms into equivalent Horn axioms (see [20],
Axioms menu).
Simplification rules that cooperate with other theorem provers [2,22,27,28,29] or constraint solvers [4] via tailor-made interfaces.
Narrowing and fixpoint (co)induction complement each other with respect to the direction axioms are combined with conjectures: In the first case, axioms are applied to conjectures, and the proof proceeds by transforming the modified conjec- tures. In the second case, conjectures are applied to axioms and the proof proceeds by transforming the modified axioms. Moreover, narrowing on a predicate p is, at first, a computation rule, i.e. a rule for evaluating p, while fixpoint induction on p is a proof rule, i.e. a rule for proving something about p. Strinkingly, the situation turns upside down for copredicates: narrowing on a copredicate q is rather a proof rule, whereas coinduction on q is used as a computation rule. This observation makes it worthwhile to look for a uniform proof/computation strategy that uses fixpoint (co)induction already at the medium level of interaction.

References
S. Antoy, R. Echahed, M. Hanus, A Needed Narrowing Strategy, Journal of the ACM 47 (2000) 776-822
Automated Reasoning Systems, www-formal.stanford.edu/clt/ARS/systems.html
M. Bidoit, P.D. Mosses, CASL User Manual, Springer LNCS 2900 (2004)
Th. Fru¨hwirth, S. Abdennadher, Essentials of Constraint Programming, Springer 2003
R. Giegerich, A Systematic Approach to Dynamic Programming in Bioinformatics. Parts 1 and 2: Sequence Comparison and RNA Folding, Report 99-05, Technical Department, University of Bielefeld 1999
J. Goguen, G. Malcolm, A Hidden Agenda, Theoretical Computer Science 245 (2000) 55-101

M. Hanus, ed., Curry: A Truly Integrated Functional Logic Language, www.informatik.uni-kiel.de/∼curry
Haskell: A Purely Functional Language, haskell.org
B. Jacobs, J. Rutten, A Tutorial on (Co)Algebras and (Co)Induction, EATCS Bulletin 62 (1997) 222- 259
The Maude System, maude.cs.uiuc.edu
Till Mossakowski, Horst Reichel, Markus Roggenbach, Lutz Schr¨oder, Algebraic-coalgebraic specification in CoCASL, Proc. WADT 2002, Springer LNCS 2755 (2003) 376-392
J. Nordlander, ed., The O’Haskell homepage, www.cs.chalmers.se/∼nordland/ohaskell
T. Nipkow, L.C.Paulson, M. Wenzel, Isabelle/HOL, Springer LNCS 2283 (2002)
P. Padawitz, Computing in Horn Clause Theories, Springer 1988
P. Padawitz, Deduction and Declarative Programming, Cambridge University Press 1992
P. Padawitz, Inductive Theorem Proving for Design Specifications, J. Symbolic Computation 21 (1996) 41-99
P. Padawitz, Proof in Flat Specifications, in: E. Astesiano, H.-J. Kreowski, B. Krieg-Bru¨ckner, eds.,
Algebraic Foundations of Systems Specification, IFIP State-of-the-Art Report, Springer (1999) 321-384
P. Padawitz, Swinging Types = Functions + Relations + Transition Systems, Theoretical Computer Science 243 (2000) 93-165
P. Padawitz, Dialgebraic Specification and Modeling, draft, fldit-www.cs.uni-dortmund.de/∼peter/Dialg.pdf
P. Padawitz, Expander2: A Formal Methods Presenter and Animator, fldit-www.cs.uni-dortmund.de/∼peter/Expander2.html
P. Padawitz, Expander2: Towards a Workbench for Interactive Formal Reasoning, in: H.-J. Kreowski,
U. Montanari, F. Orejas, G. Rozenberg, G. Taentzer, eds., Formal Methods in Software and Systems Modeling, Springer LNCS 3393 (2005) 236-258
The QPQ Database of Deductive Software Components, www.qpq.org
H. Reichel, An Approach to Object Semantics based on Terminal Coalgebras, Math. Structures in Comp.
Sci. 5 (1995) 129-152
G. Rozenberg, A. Salomaa, eds., Handbook of Formal Languages, Vol. 3: Beyond Words, Springer 1997
L. Schr¨oder, T. Mossakowski, Monad-Independent Dynamic Logic in HasCASL, Proc. WADT 2002,
Springer LNCS 2755 (2003) 425-441
M.-O. Stehr, J. Meseguer, P.C. O¨ lveczky, Rewriting Logic as a Unifying Framework for Petri Nets, in:
H. Ehrig et al., eds., Unifying Petri Nets, Springer LNCS 2128 (2001)
G. Sutcliffe, Problem Library for Automated Theorem Proving, www.cs.miami.edu/∼tptp
F. Wiedijk, ed., The Digital Math Database, www.cs.kun.nl/∼freek/digimath
The Yahoda Verification Tools Database, anna.fi.muni.cz/yahoda
