Electronic Notes in Theoretical Computer Science 117 (2005) 5–50	
www.elsevier.com/locate/entcs


Constraint Functional Logic Programming Revisited *
F. Javier Lo´pez-Fraguasa, Mario Rodr´ıguez-Artalejoa, and Rafael del Vado V´ırsedaa
a Departamento de Sistemas Informa´ticos y Programaci´on, UCM, Madrid, Spain

Abstract
In this paper we propose a new generic scheme CFLP (D), intended as a logical and semantic frame- work for lazy Constraint Functional Logic Programming over a parametrically given constraint domain D. As in the case of the well known CLP (D) scheme for Constraint Logic Programming, D is assumed to provide domain specific data values and constraints. CFLP (D) programs are presented as sets of constrained rewrite rules that define the behaviour of possibly higher order and/or non-deterministic lazy functions over D. As the main novelty w.r.t. previous related work, we present a Constraint Rewriting Logic CRW L(D) which provides a declarative semantics for CFLP (D) programs. This logic relies on a new formalization of constraint domains and program interpretations, which allows a flexible combination of domain specific data values and user defined data constructors, as well as a functional view of constraints.
Keywords: Functional Programming, Logic Programming, Constraints


Introduction
The idea of Constraint Functional Logic Programming arose around 1990 as an attempt to combine two lines of research in declarative programming, namely Constraint Logic Programming and Functional Logic Programming.
Constraint logic programming was started by a seminal paper published by J. Jaffar and J.L. Lassez in 1987 [47], where the CLP scheme was first introduced. The aim of the scheme was to define a family of constraint logic

 This research has been partially supported by the Spanish National Project MELODIAS (TIC2002-01167).


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.06.030


programming languages CLP (D) parameterized by a constraint domain D, in such a way that the well established results on the declarative and operational semantics of logic programs [55,3] could be lifted to all the CLP (D) languages in an elegant and uniform way. The best updated presentation of the classical
CLP semantics can be found in [49]. In the course of time, CLP has become a very successful programming paradigm, supporting a clean combination of logic programming and domain-specific methods for constraint satisfaction, simplification and optimization, and leading to practical applications in vari- ous fields [90,48,70].
On the other hand, functional logic programming refers to a line of research started in the 1980s and aiming at the integration of the best features of functional programming and logic programming. As far as we know, the first attempt to combine functional and logic languages was done by J.A. Robinson and E.E. Sibert when proposing the language LOGLISP [78]. Some other early proposals for the design of functional + logic languages are described in [26]. A more recent survey of the operational principles and implementation techniques used for the integration of functions into logic programming can be
found in [40]. Narrowing, a natural combination of rewriting and unification,
originally proposed as a theorem proving tool [84,54,31,43], has been used as a goal solving mechanism in functional logic languages such as Curry [41]
and T OY [59,1]. Under various more or less restrictive conditions, several narrowing strategies are known to be complete for goal solving [28,40,72].
To our best knowledge, the first attempt of combining constraint logic pro- gramming and functional logic programming was the CFLP (D) scheme pro- posed by J. Darlington, Y.K. Guo and H. Pull [24,25]. The idea behind this ap- proach can be roughly described by the equation CFLP (D) = CLP (FP (D)),
intended to mean that a CFLP language over the constraint domain D is
viewed as a CLP language over an extended constraint domain FP (D) whose constraints include equations between expressions involving user defined func-
tions, to be solved by narrowing. Other proposals concerning the combina- tion of constraints with functional programming, equational deduction and lambda-calculus appeared around the same time [22,23,51,75,66].
The CFLP scheme proposed by F.J. Lo´pez-Fraguas in [56,57] tried to pro- vide results on the declarative semantics of CFLP (D) programs closer to those known for CLP . In the classical approach to CLP semantics a constraint do-
main is viewed as a first order structure D, and constraints are viewed as first order formulas that can be interpreted in D. In [56,57] programs were built as sets of constrained rewrite rules. In order to support a lazy semantics for the user defined functions, constraint domains D were formalized as continuous structures, with a Scott domain [83,39] as carrier, and a continuous interpre-


tation of function and predicate symbols. The resulting semantics had many pleasant properties, but also some limitations. In particular, defined functions had to be first order and deterministic, and the use of patterns in function definitions had to be simulated by means of special constraints.
More recently, yet another CFLP scheme has been proposed in the Phd Thesis of M. Marin [67]. This approach introduces CFLP (D, S, L), a family of languages parameterized by a constraint domain D, a strategy S which
defines the cooperation of several constraint solvers over D, and a constraint lazy narrowing calculus L for solving constraints involving functions defined
by user given constrained rewrite rules.  This approach relies on solid work
on higher order lazy narrowing calculi and has been implemented on top of Mathematica [68,69]. Its main limitation from our viewpoint is the lack of declarative semantics.
Our aim in this paper is to propose a new CFLP scheme which pro- vides a clean declarative semantics for CFLP (D) languages, as in the CLP scheme, and also overcomes the limitations of our older CFLP scheme in
[56,57]. The main novelties of the current proposal are a new formalization of constraint domains for CFLP , a new notion of interpretation for CFLP programs, and a new Constraint Rewriting Logic CRWL(D) parameterized
by a constraint domain, which provides a logical characterization of program
semantics. CRWL(D) is a natural extension of the rewriting logic CRWL
[35,36], originally proposed as a logical framework for first order functional
logic programming languages based on lazy and possibly non-deterministic functions, whose semantics cannot be directly described in terms of equa- tional logic. Early work on CRWL was inspired by Hussmann’s work on nondeterminism in algebraic specifications and programs [44,45,46]. In com- parison to Meseguer’s Rewriting Logic [71], originally aimed as a unified logic and semantic framework for concurrent languages and systems, CRWL shows clear differences in objectives and motivation. A careful comparison of both approaches has been worked out by M. Palomino in [76,77], showing that the semantics of both logics, when viewed as institutions, are formally incompa- rable.
In the last years, various extensions of CRWL have been devised, to ac- count for various features of functional logic languages, such as higher order functions [37], polymorphic types [38], algebraic data constructors [8,9,10], an ad-hoc treatment of certain kinds of constraints [6,7], and finite failure [60,61,62,63,64]. A survey of previous work on CRWL can be found in [79]. A generic extension of CRWL with constraint reasoning was missing up to now.
Constraint functional logic programming obviously falls within the wider


field of Multiparadigm Constraint Programming. Giving a survey of the many interesting research activities in this area lies outside the scope of the present paper. Here we just mention Concurrent Constraint Programming [80,81,82] as a particularly relevant subject which arose from the interplay between con- current extensions of logic programming languages and the CLP scheme, and
has inspired the design of various declarative languages [42,92]. Our CFLP
scheme, however, does not deal with concurrency issues.
The reader of this paper is assumed to have some knowledge on the foun- dations of logic programming [55,3] and term rewriting [27,52,11]. The rest of the paper is organized as follows: section 2 presents a new formalization
of constraint domains D, tailored to the needs of constraint functional logic programming. Section 3 presents CFLP (D) programs and their interpreta- tions, along with results concerning the existence of least program models. Section 4 introduces the constraint rewriting logic CRWL(D), presenting an inference system as well as correctness results w.r.t. the model-theoretic se-
mantics given in the previous section. Section 5 summarizes conclusions and gives an overview of planned future work. Section 6 presents a small sample of CFLP (D) programs written in the concrete syntax of the T OY language.
Finally, section 7 includes some technical proofs that have been moved away
from the main text in order to ease reading.


Constraint Domains
As already explained, one main aim in this paper is to overcome the limitations of our older CFLP (D) scheme [56,57]. As a first step in this direction, we propose a new view of constraint domains D as structures with carrier set
GP at⊥(U), consisting of ground patterns built from the symbols in a universal
signature Σ and a set of urelements U. Urelements are intended to represent
some domain specific set of values, as e.g. the set R of the real numbers used in the in well-known CLP language CLP (R) [50], while symbols in Σ are intended to represent data constructors (e.g. the list constructor), domain
specific primitive functions (e.g. addition and multiplication over R), and user defined functions. Assuming a unique universal signature rather than various domain-dependent signatures turns out to be convenient for technical reasons. Another important limitation of our older CFLP (D) scheme [56,57], name-
ly the lack of a type system, can be easily overcome by adopting the approach
of [38], which shows how to refine a CRWL-based semantics for untyped programs with a polymorphic type system in Damas-Milner’s style [73,21]. In this paper, however, we refrain from an explicit treatment of types, except for showing type declarations in some concrete programming examples.


The rest of this section gives a formal presentation of constraint domains. We begin by introducing the syntax of applicative expressions and patterns, which is needed for understanding our construction of constraint domains.

Applicative Expressions, Patterns and Substitutions
We ass ume a universal signature Σ = ⟨DC, FS⟩, where DC =  n∈N DCn and
FS =	n∈N FSn are families of countably infinite and mutually disjoint sets
of data constructors resp. evaluable function symbols, indexed by arities. As
we will see later on, evaluable functions can be further classified into domain dependent primitive functions and user given deﬁned functions. We write Σ⊥ for the result of extending DC0 with the special symbol ⊥, intended to denote an undefined data value. As notational conventions, we use c, d ∈ DC,
f, g ∈ FS and h ∈ DC ∪ FS, and we define the arity of h ∈ DCn ∪ FSn as
ar(h) = n. We also assume that DC0 includes the three constants true, f alse
and success, which are useful for representing the results returned by various primitive functions.
Next we assume a countably infinite set V of variables X, Y,... and a set U of urelements u, v,.. ., mutually disjoint and disjoint from Σ⊥. Partial expressions e ∈ Exp⊥(U) have the following syntax:
e ::= X (X ∈ V) | ⊥ | u (u ∈ U) | h (h ∈ DC ∪ FS) | (e e1)
These expressions are usually called applicative, because (e e1) stands for the application operation (represented as juxtaposition) which applies the function denoted by e to the argument denoted by e1.  Applicative syntax
is common in higher order functional languages. The usual first order syntax for expressions can be translated to applicative syntax by means of so-called curried notation. For instance, f (X, g(Y )) becomes (f X (gY )). Following a usual convention, we assume that application associates to the left, and we
use the notation (e en) to abbreviate (e e1 ... en).
The set of variables occurring in e is written var(e). An expression e is called linear iff there is no X ∈ var(e) having more than one occurrence in e. The following classification of expressions is also useful: (X em), with

X ∈ V and m ≥ 0, is called a flexible expression, while u ∈ U and (h em) with h ∈ DC ∪ FS are called rigid expressions. Moreover, a rigid expression (h em) is called active iff h ∈ FS and m ≥ ar(h), and passive otherwise. Any pattern is either a variable or a passive rigid expression. Intuitively, reducing
an expression at the root makes sense only if the expression is active. This idea will play a role in the semantics presented in sections 3 and 4.
Some interesting subsets of Exp⊥(U) are:
GExp⊥(U), the set of the ground expressions e such that var(e) = ∅.


Exp(U), the set of the total expressions e with no occurrences of ⊥.
GExp(U ), the set of the ground and total expressions GExp⊥(U) ∩ Exp(U).
Another important subclass of expressions is the set of partial patterns
s, t ∈ P at⊥(U), whose syntax is defined as follows:
t ::= X (X ∈ V) | ⊥ | u (u ∈ U) |
(c tm) (c ∈ DCn, m ≤ n) | (f tm) (f ∈ FSn, m < n)

Note that expressions (f tm) with f ∈ FSn, m ≥ n, are not allowed as patterns, because they are potentially evaluable using a primitive or user given definition for function f . Patterns of the form (f tm) with f ∈ FSn, m < n, are used in CRWL [37,38] as a convenient representation of higher order values.  The subsets P at(U ), GPat⊥(U), GPat(U) ⊆ P at⊥(U) consisting of
the total, ground and ground and total patterns, respectively, are defined in
the natural way.
Following the spirit of denotational semantics [83,39], we view P at⊥(U) as the set of finite elements of a semantic domain, and we define the information ordering ± as the least partial ordering over P at⊥ satisfying the following properties: ⊥ ± t for all t ∈ P at⊥(U), and (h tm) ± (h t'm) whenever these

two expressions are patterns and ti ± t'
for all 1 ≤ i ≤ m. In the sequel,

	
tm ± t'm will be understood as meaning that ti ± t' for all 1 ≤ i ≤ m. Note that a pattern t ∈ P at⊥(U) is maximal w.r.t. the information ordering iff t is a total pattern, i.e. t ∈ P at(U ).
Any partially ordered set (shortly, poset), can be converted into a semantic domain by means of a technique called ideal completion; see e.g. [74]. There- fore, in the rest of this paper we will use the poset GP at⊥(U) as an implicit representation of the semantic domain resulting from its ideal completion.
This is consistent with the use of Scott domains in the semantics of the older
CFLP (D) scheme [56,57].
For some purposes it is useful to extend the information ordering to the
set of all partial expressions. This extension is simply defined as the least partial ordering over Exp⊥(U) which verifies ⊥ ± e for all e ∈ Exp⊥(U), and
(e e1) ± (e' e' ) whenever e ± e' and e1 ± e' .
1	1
As usual, we define substitutions σ ∈ Sub⊥(U) as mappings σ : V → P at⊥(U) extended to σ : Exp⊥(U) → Exp⊥(U) in the natural way. Similarly, we consider total substitutions σ ∈ Sub(U) given by mappings σ : V → P at(U ), ground substitutions σ ∈ GSub⊥(U) given by mappings σ : V → GP at⊥(U), and ground total substitutions σ ∈ GSub(U) given by mappings σ : V → GP at(U). By convention, we write ε for the identity substitution, eσ instead of σ(e), and σθ for the composition of σ and θ, such that e(σθ) = (eσ)θ for any e ∈ Exp⊥(U ). We define the domain and the variable range of a substitution



in the usual way, namely:
dom(σ) = {X ∈ V | σ(X) /= X}	ran(σ) = 



X∈dom(σ)

var(σ(X))

As usual, a substitution σ such that dom(σ) ∩ ran(σ) = ∅ is called idem- potent. For any set of variables X ⊆ V we define the restriction σ T X as the substitution σ' such that dom(σ') = X and σ'(X) = σ(X) for all X ∈ X . We use the notation σ =X θ to indicate that σ T X = θ T X , and we abbreviate σ =V\X θ as σ =\X θ. Finally, we consider two different ways of comparing given substitutions σ, σ' ∈ Sub⊥(U):
σ is said to be less particular than σ' over X ⊆ V (in symbols, σ ≤X σ') iff
σθ =X σ' for some θ ∈ Sub⊥(U). The notation σ ≤ σ' abbreviates σ ≤V σ'.
σ is said to bear less information than σ' over X ⊆ V (in symbols, σ ±X σ') iff σ(X) ± σ'(X) for all X ∈ X . The notation σ ± σ' abbreviates σ ±V σ'.

A New Formalization of Constraint Domains
Intuitively, a constraint domain is expected to provide a set of specific data ele- ments, along with certain primitive functions and predicates operating upon them. Primitive predicates can be viewed as primitive functions returning boolean values. Therefore, we just consider primitive functions, and we for- malize the notion of constraint domain as follows:


Definition 2.1 Constraint Domains.
A constraint signature is any family Γ = 



n∈N

PFn of primitive function

symbols p indexed by arities, such that PFn ⊆ FSn for each n ∈ N. We will usually write PFn in place of PFn, leaving Γ implicit.
A constraint domain of signature Γ is any structure
D = ⟨DU , {pD | p ∈ PF }⟩
such that the carrier set DU = GP at⊥(U) coincides with the set of ground patterns for some set of urelements U, and the interpretation pD of each p ∈ PFn satisfies the following requirements:
pD ⊆ Dn × DU , which boils down to pD ⊆ DU in the case n = 0. In the sequel we always write pD tn → t to indicate that (tn, t) ∈ pD. In the case n = 0, this notation boils down to pD → t.
pD behaves monotonically in its arguments and antimonotonically in
its result; i.e., whenever pD tn → t, tn ± t'n and t ± t' one also has
pD t'n → t'.
pD behaves radically in the following sense: whenever pD tn → t and
t /= ⊥, there is some total t' ∈ DU such that pD tn → t' and t' ± t.


Items (ii).(a),(b) in the previous definition are intended to ensure that pD
n
encodes the behaviour of a monotonic and continuous mapping from DU , the
nth power of the semantic domain obtained from DU by ideal completion [74] into Hoare’s Powerdomain HP(DU ) [83,93,39]. Intuitively, one can think of pD just as describing the behaviour of a possibly non-deterministic function over
finite data elements. The kind of non-determinism involved here is borrowed from our previous work on the CRWL framework [36,38,10], which in turn was inspired by ideas from Hussmann [44,45,46].
Item (ii).(c), requiring primitive functions to be radical, is more novel
and important for our present purposes. Requiring primitives to be radical just means that for given arguments, they are expected to return a total result, unless the arguments bear too few information for returning any result
different of ⊥. As far as we know, all the primitive functions used in practical constraint domains are radical in this sense.
Let us illustrate the previous definition by means of two examples. First we present two primitives for equality comparisons. They make sense for any constraint domain D built over any set of urelements U, and are obviously
radical:
Example 2.2 Two equality primitives:
eqU , equality primitive for urelements, interpreted to behave as follows:
eqD u u → true for all u ∈ U; eqD u v → f alse for all u, v ∈ U , u /= v;
U	U
eqD t s → ⊥ otherwise.
seq, strict equality primitive for ground patterns, interpreted to behave as follows:
seqD t t → true for all total t ∈ GP at(U ); seqD t s → f alse for all t, s ∈ GP at⊥(U) such that t, s have no common upper bound w.r.t. the information ordering; seqD t s → ⊥ otherwise.
In the sequel we write Hseq to denote the constraint domain built over the empty set of urelements, and having seqD as its only primitive. The language CFLP (Hseq) can be seen as a new foundation for our previous work
on functional logic programming with disequality constraints [53,5,58]. On
the other hand, Hseq is analogous to the extension of the Herbrand domain with disequality constraints, introduced by A. Colmerauer [19,20] as one of
the first constraint extensions of logic programming, and later investigated by M. J. Maher [65]. Some important differences must be noted, however. Firstly, the carrier set of Hseq is a poset of ground partial patterns, including
representations of higher order values; while the carrier set in Colmerauer’s
approach consists of possibly infinite rational trees which cannot be interpreted as higher order values. Secondly, equality and disequality constraints were


based on two different predicates in Colmerauer’s approach, while in Hseq one single boolean valued primitive function allows to express strict equality and
disequality constraints, as we will see in the next subsection. More gene- rally, constraints in the CFLP (D) scheme are always expressed by means of primitive functions with radical semantics.
The next example presents a constraint domain R similar to the one used in the well known constraint logic language CLP (R) [50,48,70]. In the CLP case, the carrier set of R is defined as the set of all possible ground terms built from real numbers and data constructors, while we use a strictly bigger poset
of partial ground patterns.
Example 2.3 The constraint domain R has the carrier set DR = GP at⊥(R) and the radical primitives defined below. We apply some of them in infix
notation for convenience.
eqR, equality primitive for real numbers, interpreted as in Example 2.2.
seq, strict equality primitive for ground patterns over the real numbers, interpreted as in Example 2.2.
(iii) +, ∗, for addition and multiplication, interpreted to behave as follows: x +R y → x +R y for all x, y ∈ R; t +R s → ⊥ whenever t ∈/ R or s ∈/ R; and analogously for ∗R.
(iv) <, ≤, >, ≥, for numeric comparisons, interpreted to behave as follows:
x <R y → true for all x, y ∈ R with x <R y; x <R y → f alse for
all x, y ∈ R with x ≥R y; t <R s → ⊥ whenever t ∈/ R or s ∈/ R;
and analogously for ≤R, >R, ≥R.  In the sequel, e1 < e2 abbreviates
e1 < e2 →! true, e1 ≥ e2 abbreviates e1 < e2 →! f alse and analogously for the rest of primitives.
Other constraint domains known for their practical value in constraint pro- gramming include feature tree constraints [2,85,12,13], which can be viewed as an extension of Colmerauer’s rational trees [19,20], and finite domain cons- traints [89,90,91,92]. These two kinds of constraints play an important role in the multiparadigm programming language Oz [42]. Finite domain constraints have been recently used for solving combinatorial problems in constraint func-
tional logic programming [32], using an extension of the T OY system [59,1] which we hope to formalize as an instance of the CFLP (D) scheme in some future work.

Constraints over a given Constraint Domain
Assuming an arbitrarily fixed constraint domain D built over a certain set of urelements U, we will now define the syntax and semantics of constraints. As


in the CLP case, we view constraints as logical formulas. In contrast to CLP , our constraints can include occurrences of user defined functions. In the sequel, we will write DF = FS \ PF for the set of user defined function symbols,
and DFn = FSn \ PFn for the set of user defined function symbols of arity
The following definition distinguishes primitive constraints without any
active occurrence of defined function symbols, from user defined constraints that can have such occurrences. For the sake of brevity, we sometimes write simply ‘constraints’ instead of ‘user defined constraints’.
Definition 2.4 Syntax of Constraints.

Atomic Primitive Constraints have the syntactic form p tn →! t , with p ∈ PFn, ti ∈ P at⊥(U) for all 1 ≤ i ≤ n, and t ∈ P at(U ). The special constants  and □ are also atomic primitive constraints.
Primitive Constraints are built from atomic primitive constraints by means of logical conjunction ∧ and existential quantification ∃.

Atomic Constraints have the syntactic form p en →! t , with p ∈ PFn, ei ∈ Exp⊥(U) for all 1 ≤ i ≤ n, and t ∈ P at(U ). The special constants
  and □ are also atomic constraints.
Constraints are built from atomic constraints by means of logical con- junction ∧ and existential quantification ∃.
In the sequel we use the following notations:
PCon⊥(D), the set of all the primitive constraints π over D.
PGCon⊥(D), the set of all the primitive ground constraints over D, defined as {π ∈ PCon⊥(D) | fvar(π) = ∅}, where fvar(π) is defined as the set of all variables which have some free occurrence in π.
PCon(D), the set of all the total primitive constraints over D, defined as
{π ∈ PCon⊥(D) | π has no occurrences of ⊥}.
PGCon(D), the set of all the primitive ground and total constraints, defined as PGCon⊥(D) ∩ PCon(D).
We also write DCon⊥(D) for the set of all the user defined constraints δ over D, as well as DGCon⊥(D), DCon(D) and DGCon(D) for the subsets of DCon⊥(D) consisting of ground, total, and ground and total constraints, respectively. We reserve the capital greek letters Π resp. ∆ for sets of primi-
tive resp. user defined constraints, usually interpreted as conjunctions. The notations fvar(Π) resp. fvar(∆) will refer to the set of free variables occur- ring in such sets. The semantics of user defined constraints depends on the
interpretation of user defined functions, and will be investigated in the next section as part of the semantics of CFLP (D)-programs. The semantics of


primitive constraints depends on the notion of solution, presented in the next definition.
Definition 2.5 Solutions of Primitive Constraints.
The set of valuations resp. total valuations over D is defined as V al⊥(D) = 
GSub⊥(U) resp. V al(D) = GSub(U).
The set of solutions of π ∈ PCon⊥(D) is a subset SolD(π) ⊆ V al⊥(D) recursively defined as follows:
SolD(  ) = V al⊥(D).
SolD(□) = ∅.
SolD(p tn →! t) = {η ∈ V al⊥(D) | tη is total and pD tnη → tη}.
SolD(π1 ∧ π2) = SolD(π1) ∩ SolD(π2).
SolD(∃Xπ) = {η ∈ V al⊥(D) | η' ∈ SolD(π) for some η' =\{X} η}
The set of s olutions of a set of constraints Π ⊆ PCon⊥(D) is defined as
SolD(Π) =	π∈Π SolD(π), corresponding to a logical reading of Π as the
conjunction of its members. In particular, SolD(∅) = V al⊥(D), corres-
ponding to the logical reading of an empty conjunction as the identically
true constraint  .
According to item (ii).(c) in this definition, the solutions of a primitive atomic constraint p tn →! t are those valuations for which p tn can return a
total value which matches the total pattern t. For instance, η ∈ SolR(X +Y →
! 5) holds iff η(X) = x ∈ R, η(Y ) = y ∈ R, and x +R y = 5. The other items in the definition are quite standard.
As argued also in [63] for the particular case of strict equality and dise- quality constraints over constructor terms, a functional view of atomic cons- traints as proposed here has some advantages w.r.t. the traditional view of atomic constraints as predicates. In order to clarify this point, let us consider the example of equality and disequality constraints over the real numbers. According to the traditional (relational) view one would use two different primitive predicates, say =R and /=R, for writing atomic constraints such as
X =R Y or X/=R Y . In CFLP (R) these atomic constraints can be written as eqR X Y →! true and eqR X Y →! f alse, respectively. Moreover, one can also write the atomic constraint eqR X Y →! R, whose use in programs can lead to greater expressivity. An improvement of efficiency can also be expected in
computations depending on the value obtained for R by constraint solving, because it will be possible to solve the constraint eqR X Y →! R one single time instead of checking which of the two constraints X =R Y and X/=R Y
succeeds. Similar considerations apply to the various inequality primitives in R and to the strict equality primitive seq in any constraint domain where it is available. In the sequel we allow some useful shorthands for writing atomic


constraints, primitive or not:
p en abbreviates p en →! success.
e1 =U e2 abbreviates eqU e1 e2 →! true.
e1/=U e2 abbreviates eqU e1 e2 →! f alse.
e1 == e2 abbreviates seq e1 e2 →! true.
e1/= e2 abbreviates seq e1 e2 →! f alse.
Using the notion of solution, some useful semantic notions related to primi- tive constraints are easily introduced:

Definition 2.6 Primitive Semantic Notions.
Assuming a finite set Π ⊆ PCon⊥(D) of primitive constraints, a primitive constraint π ∈ PCon⊥(D), expressions e, e' ∈ Exp⊥(U), patterns tn, t ∈ P at⊥(U), and a primitive function symbol p ∈ PFn, we define:
π is called satisfiable in D (in symbols SatD(π)) iff SolD(π) /= ∅. Other- wise π is called unsatisfiable (in symbols U nsatD(π)). Analogously for
constraint sets Π.
π is a consequence of Π in D (in symbols, Π  |=D  π) iff SolD(Π) ⊆
SolD(π).
π is valid in D (in symbols, |=D π) iff ∅ |=D π, which is obviously equivalent to SolD(π) = V al⊥(D).
e ± e' is a consequence of Π in D (in symbols, Π |=D e ± e') iff eη ± e'η
holds for all η ∈ SolD(Π).
e ± e' is valid in D (in symbols, |=D e ± e') iff ∅ |=D e ± e', which is obviously equivalent to requiring eη ± e'η to hold for all η ∈ V al⊥(D).
Π |=D e ± e' and |=D e ± e' are defined analogously.
p tn → t is a consequence of Π in D (in symbols, Π |=D p tn → t) iff
pD tnη → tη holds for all η ∈ SolD(Π).
p tn → t is valid in D (in symbols, |=D p tn → t) iff ∅ |=D p tn → t iff
pD tnη → tη holds for all η ∈ V al⊥(D).

Items (iv)–(viii) in the previous definition will be needed for defining some logical inference rules in sections 3.2 and 4.1. Note that the statement p tn → t used in items (vii) and (viii) is intended to mean that evaluation of the
primitive function call p tn is able to return a result t. In sections 3.2 and
4.1 this idea will be generalized to production statements of the form e → t (with e ∈ Exp⊥(U) and t ∈ P at⊥(U)), intended to mean that evaluation of the expression e can return the value t.

A New CFLP (D) Scheme
The CLP scheme, originally introduced by Jaffar and Lassez [47], served the purpose of defining a family of constraint logic programming languages CLP (D) parameterized by a constraint domain D, in such a way that the
well established results on the semantics of logic programs could be lifted to
all the CLP (D) languages in an elegant and uniform way; see [49] for an updated presentation. Previous work on CFLP schemes, including our old scheme CFLP (D) [56,57] had similar aims w.r.t. functional logic program- ming, differing mainly in the kind of semantic framework provided.
We will now complete the presentation of the new CFLP (D) scheme, assuming that constraint domains are as discussed in the previous section.
As in other previous approaches, we introduce programs as sets of constrai- ned rewrite rules for defined function symbols. We provide a semantics for CFLP (D)-programs by defining a class of interpretations and a model re-
lationship between interpretations and programs.  The main results in the
section concern the existence of least models and their characterization as least fixpoints of continuous operators.

CFLP (D)-Programs and Goals
In the sequel we assume an arbitrarily fixed constraint domain D built over a set of urelements U. As CFLP (D)-program we allow any set P of constrained rewrite rules for defined function symbols, also called program rules. More precisely, a program rule R for f ∈ DFn has the form

R : f tn → r ⇐ P  ∆ and is required to satisfy the conditions listed below:

The left-hand side f tn is a linear expression, and for all 1 ≤ i ≤ n, ti ∈ P at(U ) are total patterns.
The right-hand side r ∈ Exp(U) is a total expression.
∆ ⊆ DCon(D) is a finite set of total constraints, intended to be in- terpreted as conjunction, and possibly including occurrences of defined
function symbols.
P is a finite set of so-called productions ei → si (1 ≤ i ≤ k) also intended to be interpreted as conjunction, and fulfilling the following admissibility conditions:
For all 1 ≤ i ≤ k, ei ∈ Exp(U) is a total expression, si ∈ P at(U ) is a total linear pattern, and var(si) ∩ var(f tn) = ∅.
For all 1 ≤ i ≤ j ≤ k, var(ei) ∩ var(sj) = ∅.


For all 1 ≤ i < j ≤ k, var(si) ∩ var(sj) = ∅.
The left-linearity condition required in item (i) is quite common in func- tional and functional logic programming. As in constraint logic programming, the conditional part of a program rule needs no explicit occurrences of exis- tential quantifiers, because a program rule like R above is logically equivalent to

R' : f tn → r ⇐ ∃Y (P  ∆)
where Y = var(P  ∆) \ var(f tn → r). The admissibility conditions (iv).(a),
(b) and (c) are best understood by thinking of each production ei → si as a local definition, expected to work by obtaining values for the variables in the
pattern si by matching the result of evaluating ei to si. Admissibility just means that the locally defined variables must be fresh w.r.t. the left-hand side of the program rule, and also that the local definitions are not recursive.
Placing P ∆ as conditional part in the program rule means that the local definitions in P and also the constraints in ∆ must succeed for the rewrite rule to be applicable.
The following example illustrates the previous points by showing some constrained rewrite rules which could be part of a CFLP (R)-program P. The main function split is intended to receive a list Xs of real numbers as
parameter and to return a pair (Ys, Zs) of lists, where the members of Ys are the positive members of Xs and the members of Zs are the other members of Xs. We assume that (Ys, Zs) corresponds to the application of a binary constructor in mixfix notation, and we also use a Prolog-like syntax for list
constructors.

Example 3.1 Splitting a list of numbers in CFLP (R):
split	[]	→	([ ], [ ])
split	[X|Xs]	→	case R X Ys Zs ⇐ split Xs → (Ys, Zs)
  X > 0 →! R
case	true	X	Ys	Zs	→	([X|Ys], Zs)
case	false	X	Ys	Zs	→	(Ys, [X|Zs])

Function case in this example shows that an empty conditional part can be omitted when writing program rules. Section 6 includes a small sample
of CFLP programs over the constraint domains Hseq and R, which can be executed in the T OY system and are written in T OY’s concrete syntax.


Goals for CFLP (R)-programs have the same form as the conditional part of program rules. Computed solutions for a goal G : P  ∆ are expected to be
pairs of the form S  σ, where σ is and idempotent substitution, S is a set of primitive constraints verifying dom(σ)∩var(S) = ∅, and SolD(S) ⊆ SolP(Gσ). Coming back to Example 3.1, the expected computed answers for the goal
G : split [1.2, X, −0.25] == (Ys, Zs) are
S1  σ1 = {X > 0}  {Ys '→ [1.2, X], Zs '→ [−0.25]}
S2  σ2 = {X ≤ 0}  {Ys '→ [1.2], Zs '→ [X, −0.25]}
Note that in this case SolR(S1) ⊆ SolP(Gσ1) amounts to SolR(X > 0) ⊆ SolP(split [1.2, X, −0.25] == ([1.2, X], [−0.25])), which is intuitively true; and analogously for the second computed answer. In the general case, the
meaning of the requirement SolD(S) ⊆ SolP(Gσ) depends on the semantics for CFLP (D)-programs to be developed in the rest of this paper. The formali- zation of a constrained lazy narrowing calculus for solving CFLP (D)-goals is left for future work.

Interpretations and Models for CFLP (D)-Programs
In order to interpret CFLP (D)-programs, the constraint domain D has to be extended with interpretations for the defined function symbols. The D- algebras defined below achieve this aim in a simple and straightforward way:
Definition 3.2 D-algebras.
Assume a constraint domain D with sets of urelements U. A D-algebra is any structure of the form
A = ⟨D, {f A | f ∈ DF }⟩
conservatively extending D with an interpretation f A of each f ∈ DFn, which must satisfy the following requirements:
f A ⊆ Dn × DU , which boils down to f A ⊆ DU in the case n = 0. The notation f A tn → t indicates that (tn, t) ∈ f A. In the case n = 0, this notation boils down to f A → t.
f A behaves monotonically in its arguments and antimonotonically in its result; i.e., whenever f A tn → t, tn ± t'n and t ± t' one also has f A t'n → t'.
Similarly as in Definition 2.1, the monotonicity conditions in item (ii) are intended to capture the behaviour of a possibly non-deterministic function over finite data elements. The radicality condition in Definition 2.1 is omitted here, because user defined functions which return potentially infinite data structures as results are useful for programming and obviously not radical.


A full-fledged semantics for CFLP (D)-programs could be developed on the basis of D-algebras. This approach would be analogous to the D-interpretations used in the traditional semantics of CLP (D)-programs [49], and also formally similar to the structures used as interpretations for functional logic programs
in our previous CFLP (D) scheme [56,57] and previous work based on the logic CRWL [36,38,10].
We have nevertheless decided to abandon D-algebras in favour of a more ex- pressive approach, motivated by the π-interpretations for CLP (D)-programs proposed in [33,34]. Roughly speaking, π-interpretations in the CLP setting are sets of facts of the form p tn ⇐ Π, intended to mean that the user de-
fined atom p tn is valid for any valuation which is a solution of the primitive
constraint Π. As shown in [33,34], π-interpretations can be used as a basis for three different program semantics Si (i = 1, 2, 3), characterizing valid ground goals, valid answers for goals and computed answers for goals, respectively. In
fact, the Si semantics are the CLP counterpart of previously known seman- tics for logic programming, namely the least ground Herbrand model semantics [3,55], the open Herbrand model semantics, also known as C-semantics [18,30] and the S-semantics [29,14]. A very concise and readable overview of these semantics can be found in [4].
In order to generalize π-interpretations to CFLP (D) languages, we con- sider sets of facts of the form f tn → t ⇐ Π, intended to describe the behaviour of user defined functions f ∈ DFn. We will use this class of inter- pretations for defining two different semantics, corresponding to S1 and S2, which we will call the weak and strong semantics, respectively. In future work
on constrained lazy narrowing for goal solving in CFLP (D) languages, we ex- pect that the strong semantics will provide a characterization of valid answers
for goals, including computed answers as a particular case.
Note that a CFLP (D) analogous of the S3 semantics would characterize
exactly the computed answers, being therefore dependent on the choice of
a particular narrowing strategy for goal solving; a complication which does not exist in the CLP setting. The scope of the present paper is limited to results which make sense independently of any particular goal solving method.
Therefore, we present no results on S3-like semantics.
In order to define an analogous of π-interpretations for CFLP (D)-programs, we must first introduce some preliminary notions.

Definition 3.3 Constrained Statements and D-entailment.
Let D be any fixed constraint domain over a set of urelemets U. In what follows we assume partial patterns t, ti ∈ P at⊥(U), partial expressions e, ei ∈ Exp⊥(U), and a finite set Π ⊆ PCon⊥(D) of primitive constraints.


We consider three possible kinds of constrained statements (c-statements):
c-productions e → t ⇐ Π, with e ∈ Exp⊥(U). In the case that Π is empty they boil down to unconstrained productions written as e → t. A c-production is called trivial iff t = ⊥ or U nsatD(Π).

c-facts f tn → t ⇐ Π, with f ∈ DFn. They are just a particular
kind of c-productions. In the case that Π is empty they boil down to unconstrained facts written as f tn → t. A c-fact is called trivial iff
t = ⊥ or U nsatD(Π).
c-atoms p en →! t ⇐ Π, with p ∈ PFn and t total. In the case that Π is empty they boil down to unconstrained atoms written as p en →! t . A c-atom is called trivial iff U nsatD(Π).
In the sequel we use ϕ and similar symbols to denote any c-statement of
the form e →? t ⇐ Π, where the symbol →? must be understood as
→! in case that ϕ is a c-atom; otherwise →? must be understood as →.
Given two c-statements ϕ and ϕ', we say that ϕ D-entails ϕ' (in symbols,
ϕ  D ϕ') iff one of the two following cases holds:
ϕ = e → t ⇐ Π, ϕ' = e' → t' ⇐ Π', and there is some σ ∈
Sub⊥(U) such that Π' |=D Πσ, Π' |=D e' ± eσ, Π' |=D t' ± tσ.
ϕ = p en →! t ⇐ Π, ϕ' = p e'n →! t' ⇐ Π', and there is some σ ∈ Sub⊥(U) such that Π' |=D Πσ, Π' |=D p e'n ± (p en)σ, Π' |=D t' ± tσ.
The intuitive idea behind D-entailment is that, whenever ϕ  D ϕ', the c-statement ϕ' can be accepted as a consequence of ϕ for any possible inter-
pretation of the defined function symbols. This is indeed reasonable because the definition of the D-entailment relation does rely only on assumptions con- cerning the monotonic behaviour of both primitive and defined functions, as
well as on the radical behaviour of primitive functions.
The next definition generalizes the idea of π-interpretation [33,34] to our
CFLP (D) setting:
Definition 3.4 For any given constraint domain D:
A c-interpretation over D is any set I of c-facts including all the trivial c-facts and closed under D-entailment. Equivalently, a c-interpretation is any set I of c-facts such that clD(I) ⊆ I, where clD(I) is defined as follows:
clD(I) = {ϕ' | ϕ' is a trivial c-fact, or else ∃ϕ ∈ I (ϕ  D ϕ')}
The D-grounding of a c-interpretation I is defined as
gdD(I) = {ϕ ∈ I | ϕ is a ground c-fact}
The grounding of a c-interpretation I is technically not a c-interpretation,


since it neither includes all the trivial c-facts, nor is closed under D-entailment. Nevertheless, it is clear that gdD(I) can be viewed as a description of a D- algebra in the sense of Definition 3.2. Obviously, different c-interpretations
can have the same grounding.
The next definition assumes a constraint domain D with urelements U, and a given c-interpretation I over D. The purpose of the calculus is to infer the semantic validity of arbitrary c-statements in I.

Definition 3.5 Semantic Calculus.
We write I ▶▶D ϕ to indicate that the c-statement ϕ can be derived from I
using the following inference rules:

TI Trivial Inference:

ϕ
If ϕ is a trivial c-statement.

RR Restricted Reflexivity:


t → t ⇐ Π If t ∈ U ∪ V.
SP Simple Production:


s → t ⇐ Π
If s ∈ P at⊥(U), s ∈ V or t ∈ V, and Π |=D s ± t.

DC Decomposition:

e1 → t1 ⇐ Π, ··· , em → tm ⇐ Π
h em → h tm ⇐ Π If h em is passive.


IR Inner Reduction:

e1 → t1 ⇐ Π, ··· , em → tm ⇐ Π
h em → X ⇐ Π
If h em is passive but not a pattern, X ∈ V and Π |=D h tm ± X.
DFI I-Defined Function:
e1 → t1 ⇐ Π, ··· , en → tn ⇐ Π

f en → t ⇐ Π
If f ∈ DFn, (f tn → t ⇐ Π) ∈ I.

e1 → t1 ⇐ Π, ··· , en → tn ⇐ Π s ak → t ⇐ Π

f enak → t ⇐ Π
If f ∈ DFn, k > 0, (f tn → s ⇐ Π) ∈ I, s ∈ P at⊥(U).

PF Primitive Function:

e1 → t1 ⇐ Π, ··· , en → tn ⇐ Π
p en → t ⇐ Π
If p ∈ PFn, ti ∈ P at⊥(U) for each 1 ≤ i ≤ n, and Π |=D p tn → t.


AC Atomic Constraint:

e1 → t1 ⇐ Π, ··· , en → tn ⇐ Π
p en →! t ⇐ Π
If p ∈ PFn, ti ∈ P at⊥(U) for each 1 ≤ i ≤ n, and Π |=D p tn →! t.

By convention, we agree that no inference rule of the semantic calculus is applied in case that some textually previous rule can be used. In particular, no rule except TI can be used to infer a trivial c-statement, and SP is not applied whenever RR is applicable.


Any derivation in the semantic calculus can be represented as a proof tree whose nodes are labelled by c-statements, where each node has been inferred from its children by means of the inference rules. In the sequel, we will use the following notations:
T = RL(ϕ, [T1 ··· , Tp]) represents a proof tree whose root ϕ is inferred with the inference rule RL from p previously derived c-statements with proof trees Ti (1 ≤ i ≤ p).
T : I ▶▶D ϕ indicates that I ▶▶D ϕ is witnessed by the proof tree T .
T is called an easy proof tree iff T makes no use of the inference rules
DFI, PF and AC.
	 T  denotes the full size of the proof tree T , defined as the total number of nodes in T .
| T | denotes the restricted size of the proof tree T , defined as the number of nodes in T which are inferred with some of the rules DFI, PF or AC. Obviously, | T |≤ T  and | T | = 0 iff T is an easy proof tree.
The next lemma states several useful properties of the semantic calculus.
The proof is rather technical and can be found in Section 7.1.
Lemma 3.6 Properties of the Semantic Calculus.
Compactness Property: I ▶▶D ϕ implies clD(I0) ▶▶D ϕ for some ﬁnite subset I0 ⊆ I.
Extension Property: I ▶▶D ϕ and I ⊆ I' implies I' ▶▶D ϕ.
Approximation Property: For any e ∈ Exp⊥(U), t ∈ P at⊥(U): Π |=D e ± t iff there is some easy proof tree T such that T : ▶▶D e → t ⇐ Π (derivation from the trivial c-interpretation ⊥⊥ = clD(∅)).
Conservation Property: For any c-fact ϕ, I ▶▶D ϕ iff ϕ ∈ I.
Primitive c-atoms: For any primitive atom p tn →! t , I ▶▶D p tn →! t ⇐
Π iff Π |=D p tn →! t .
Entailment Property: T : I ▶▶D ϕ and ϕ  D ϕ' implies T ' : I ▶▶D ϕ'
with proof tree T ' such that | T ' |≤ | T |.
Using the semantic calculus, solutions of user defined constraints can be easily defined. The next definition generalizes Definition 2.5, assuming a given c-interpretation I over a constraint domain D with urelements U:
Definition 3.7 Solutions of User Defined Constraints.
The set of solutions of δ ∈ DCon⊥(D) is a subset SolI(δ) ⊆ V al⊥(D) recursively defined as follows:
SolI(  ) = V al⊥(D).


SolI(□) = ∅.
SolI(δ) = {η ∈ V al⊥(D) | I ▶▶D δη}, for any atomic constraint
δ ∈ DCon⊥(D) \ {  , □}.
SolI(δ1 ∧ δ2) = SolI(δ1) ∩ SolI(δ2).
SolI(∃Xδ) = {η ∈ V al⊥(D) | η' ∈ SolI(δ) for some η' =\{X} η}
The set of s olutions of a set of constraints ∆ ⊆ DCon⊥(D) is defined as
SolI(∆) =	δ∈∆ SolI(δ), corresponding to a logical reading of ∆ as the
conjunction of its members. In particular, SolI(∅) = V al⊥(D), corres-
ponding to the logical reading of an empty conjunction as the identically
true constraint  .
For primitive constraints one can easily check that SolI(π) = SolD(π) and SolI(Π) = SolD(Π), using the obvious correspondence between Definitions 3.7 and 2.5.
The semantic calculus also allows to define the denotation of arbitrary expressions in a given interpretation, as follows:
Definition 3.8 Denotation of Expressions.
Assume a given c-interpretation I over a constraint domain D. The denotation of any expression e ∈ Exp⊥(U) in I under a valuation η ∈ V al⊥(D) is defined as the set [e]]I = {t ∈ DU | I ▶▶D eη → t}. For the case of a ground expression e ∈ GExp⊥(U) we will abbreviate [e]]I as [e]]I.
Using Lemma 3.6, it is easy to prove that [e]]I ⊆ DU includes the undefined element ⊥ and is downwards closed w.r.t. the information ordering ±; i.e.,
t' ∈ [[e]]I holds whenever t ∈ [[e]]I for some t ± t'. Due to these properties, [e]]I
η	η	η
turns out to be an element of Hoare’s Powerdomain HP(DU ) [83,93,39], co- rresponding to so-called call-time choice semantics for non-determinism. This
kind of semantics is inspired by Hussmann’s work on nondeterministic alge- braic specifications and programs [44,45,46] and shown to be convenient for programming on previous work on the CRWL logic; see [36,79].
Definitions 3.7 and 3.8 just rely on the ground facts provided by the ground- ing of c-interpretations. On the contrary, the first item in the next definition really exploits the non-ground information provided by c-interpretations.
Definition 3.9 Strong and Weak Models.
For any given CFLP (D)-program P and c-interpretation I we say
I is a strong model of P (in symbols I |=s  P) iff
for any (f tn → r ⇐ P  ∆) ∈ P, θ ∈ Sub⊥(U), Π ⊆ PCon⊥(D) and t ∈ P at⊥(U) such that I ▶▶D (P  ∆)θ ⇐ Π and I ▶▶D rθ → t ⇐ Π one has ((f tn)θ → t ⇐ Π) ∈ I.
I is a weak model of P (in symbols I |=w P) iff



for any (f tn → r ⇐ P  ∆) ∈ P, η ∈ GSub⊥(U) and t ∈ GP at⊥(U) such that I ▶▶D (P  ∆)η and I ▶▶D rη → t one has ((f tn)η → t) ∈ I.
Roughly speaking, the weak model semantics I |=w P means that all
the individual instances of program rules from P must be valid in I. There-
fore, a technical variant of weak semantics could be also defined using the
D-algebras from Definition 3.2. On the other hand, the strong model seman- tics would not make sense for D-algebras. The rough meaning of the strong
model relationship I |=s P is that all those c-facts that are “immediate con-
sequences” from c-facts belonging to I via program rules from P must belong to I. In comparison with previous works, the weak model semantics is similar
to the model notion used for CRWL in [36,38,10], to the semantics in our older CFLP (D) scheme [56,57], and to the more traditional CLP (D) semantics in [47,48,49]; while the strong model semantics is analogous to the S2-semantics
for CLP (D)-programs proposed in [33,34].
The next proposition establishes a natural relationship between strong and
weak models:
Proposition 3.10 Strong versus Weak Models.
For any CFLP (D)-program P and any c-interpretation I one has: I |=s
P ⇒ I |=w P. The reciprocal is false in general.
Proof. Any strong model of a given CFLP (D)-program P is also a weak model of P, because item (ii) in Definition 3.9 is the particular case of item (i) obtained when θ is a ground substitution, Π is empty and t is a ground pattern. As a counterexample for the reciprocal, consider the CFLP (R)-program P
consisting of one single program rule notZero X → true ⇐ X /=R 0 and the following c-interpretation over R:
I =def clR({notZero X → true ⇐ X > 0
notZero X → true ⇐ X < 0})
For this particular program and c-interpretation we can claim:
I  |=w  P, because item (ii) in Definition 3.9 holds.  Indeed, for any
η ∈ GSub⊥(R), I ▶▶R (X /=R 0)η iff η(X) ∈ R \ {0}. Therefore, for such η one also has ((notZero X)η → true) ∈ I, since I is closed under R-entailment.
I |=s  P, because item (i) in Definition 3.9 fails when choosing ε as θ
and X /=R 0 as Π. Indeed, I ▶▶R X /=R 0 ⇐ X /=R 0, I ▶▶R true →
true ⇐ X /=R 0, and (notZero X → true ⇐ X /=R 0) /∈ I, since this c-fact does not follow by R-entailment from the c-facts used to define I.
 


The two kinds of models naturally give rise to different notions of logical consequence:
Definition 3.11 Strong and Weak Consequence.
For any given CFLP (Ð)-program У and c-statement ϕ we say
ϕ is a strong consequence of У (in symbols У |=s ϕ) iff f ▶▶D ϕ holds
for every strong model f |=s У.
ϕ is a weak consequence of У (in symbols У |=w ϕ) iff f ▶▶D ϕη holds
for every weak model f |=w У and every valuation η ∈ V al⊥(Ð).
As we will prove in Section 4.2, strong consequence always implies weak consequence; but the reciprocal is false in general.

A Fixpoint Characterization of Least Models
In this subsection we prove the existence of least models for CFLP (Ð)- programs and we characterize them as least fixpoints, exploiting the lattice
structure of the family of all c-interpretations. Similar results are well-known in logic programming [3,55] and constraint logic programming [49,33,34], as well as in our older CFLP (Ð) scheme [56,57].  In our current CFLP (Ð)
scheme, the lattice structure is revealed by the following result:
Proposition 3.12 Interpretation Lattice.
ID, deﬁned as the set of all possible c-interpretations f over the constraint do- main Ð, is a complete lattice w.r.t. the set inclusion ordering. Moreover, the bottom element ⊥⊥ and the top element TT of this lattice can be characterized as follows:
⊥⊥  =  clD({ϕ | ϕ is a trivial c-fact})
TT  =  {ϕ | ϕ is any c-fact}
Proof. TT is trivially the top element of ID w.r.t. to the set inclusion ordering. Moreover, ⊥⊥ is the bottom element because any c-interpretation is required to include all the trivial c-facts and to be closed under clD. It only remains to show that any subset I ⊆ ID has a least upper bound H I and a greatest lower bound H I w.r.t. the set inclusion ordering. Let us see why this is true:
H I = clD( I), which is obviously the smallest set of c-facts closed under clD and including all f ∈ I as subsets. Note that H∅ = ⊥⊥ and H I =  I (which is already closed under clD) for non-empty I.
H I =  I (understood as TT if I is empty), which is closed under clD and the greatest set of c-facts included as a subset in all f ∈ I.




The strong and weak interpretation transformers defined below are in- tended to formalize the computation of strong resp. weak “immediate conse- quences” from the c-facts belonging to a given c-interpretation.
Definition 3.13 Interpretation Transformers.
For any given CFLP (Ð)-program У and c-interpretation f we define:

STP(f) =def clD({(f tn)θ → t ⇐ Π | (f tn → r ⇐ P ∆) ∈ У, θ ∈ Sub⊥(U), Π ⊆ PCon⊥(Ð), t ∈ P at⊥(U), f ▶▶D (P ∆)θ ⇐ Π, f ▶▶D rθ → t ⇐ Π})
W TP(f) =def clD({(f tn)η → t | (f tn → r ⇐ P  ∆) ∈ У, η ∈
GSub⊥(U), t ∈ GP at⊥(U), f ▶▶D (P  ∆)η, f ▶▶D rη → t})
The crucial properties of the interpretation transformers are given in the next proposition, whose proof can be found in Section 7.1:
Proposition 3.14 Properties of the Interpretation Transformers.
For any ﬁxed CFLP (Ð)-program У, the transformers STP , WTP : ID → ID are well deﬁned continuous mappings, whose pre-ﬁxpoints are the strong resp. weak models of У. More precisely, for any f ∈ ID one has STP(f) ⊆ f iff
f |=s У, and W TP(f) ⊆ f iff f |=w У.
Using the previous proposition, the desired characterization of least models is easy to obtain:
Theorem 3.15 Least Program Models.
For every CFLP (Ð)-program У there exist:
A least strong model SP = lfp(STP) =	STP ↑k (⊥⊥).
A least weak model WP = lfp(W TP) =	W TP ↑k (⊥⊥).
Proof. Due to a well known theorem by Knaster and Tarski [86], a monotonic mapping from a complete lattice into itself always has a least fixpoint which is also its least pre-fixpoint. In the case that the mapping is continuous, its least fixpoint can be characterized as the lub of the sequence of lattice elements obtained by reiterated application of the mapping to the bottom element. Combining these results with Proposition 3.14 trivially proves the theorem. 
In Section 4.2 we will see that WP ⊆ SP , the inclusion being strict in general. A deeper investigation of the relationship between both least models
is left for future work.

A Logical Framework for CFLP (Ð)
In this section we generalize the CRWL approach [36,38,10,79] to a new rewriting logic CRWL(Ð), parameterized by a constraint domain Ð, and aimed as a logical framework for CFLP (Ð) programming. We start by pre-
senting a logical calculus for CRWL(Ð) and investigating its main proof
theoretical properties. Next, we investigate the relationship between formal
derivability in this calculus and the model theoretic semantics studied in the subsections 3.2 and 3.3. The relevance of CRWL(Ð) w.r.t. past work and planned future work will be briefly discussed in the concluding section 5.

The Constraint Rewriting Logic CRWL(Ð): Proof Theory
The next definition assumes a constraint domain Ð with urelements U, and a given Ð-program У. The purpose of the calculus is to infer the semantic validity of arbitrary c-statements from the program rules in У.
Definition 4.1 Constrained Rewriting Calculus.
We write У ▶D ϕ to indicate that the c-statement ϕ can be derived from У in the constrained rewriting calculus CRWL(Ð), which consists of the inference rules TI, RR, SP, DC, IR, PF and AC already presented in the semantic
calculus from Definition 3.5, plus the following inference rule:
DFP У-Defined Function:
e1 → t1 ⇐ Π, ··· , en → tn ⇐ Π, P  ∆ ⇐ Π, r → t ⇐ Π

f en → t ⇐ Π
If f ∈ DFn, (f tn → r ⇐ P  ∆) ∈ [У]⊥.
e1 → t1 ⇐ Π, ··· , en → tn ⇐ Π, P  ∆ ⇐ Π, r → s ⇐ Π, s ak → t ⇐ Π
f enak → t ⇐ Π
If f ∈ DFn, k > 0, (f tn → r ⇐ P  ∆) ∈ [У]⊥, s ∈ P at⊥(U).

The crucial difference between CRWL(Ð) and the semantic calculus is that CRWL(Ð) infers the behaviour of defined functions from a given program У, rather than from a given interpretation f. This is clear from the formulation of rule DFP , where [У]⊥ denotes the set {Rθ | R ∈ У, θ ∈ Sub⊥(U)}
consisting of all the possible instances of the function defining rules belonging to У.


As in the semantic calculus, we agree that no inference rule is applied in case that some textually previous rule can be used. Moreover, we also agree that the premise P  ∆ ⇐ Π in rule DFP must be understood as a shorthand
for several premises α ⇐ Π, one for each atomic statement α occurring in
P  ∆. This harmless convention allows to dispense with an explicit inference
rule for conjunctions.
CRWL(Ð)-derivations can be represented as proof trees whose nodes are labelled by c-statements, where each node has been inferred from its children by means of some CRWL(Ð)-inference rule. Concerning proof trees and their sizes, we will use the same notation and terminology already introduced for the semantic calculus in subsection 3.2, modulo the replacement of rule DFI by rule DFP . In particular, T : У ▶D ϕ will indicate that У ▶D ϕ is witnessed by the proof tree T .
Most of the properties proved in Lemma 3.6 for the semantic calculus translate into analogous valid properties of the rewriting calculus CRWL(Ð), with the only exception of item (iv) in Lemma 3.6, which seems to have no natural analogous in CRWL(Ð). The properties are stated in the next lemma. Again, the rather technical proof can be found in Section 7.1.
Lemma 4.2 Properties of the Constrained Rewriting Calculus.
Compactness Property: У ▶D ϕ implies У0 ▶D ϕ for some ﬁnite subset
У0 ⊆ У.
Extension Property: У ▶D ϕ and У ⊆ У' implies У' ▶D ϕ.
Approximation Property: For any e ∈ Exp⊥(U), t ∈ P at⊥(U): Π |=D e ± t iff there is some easy proof tree T such that T : ▶D e → t ⇐ Π (derivation from empty program).
Primitive c-atoms: For any primitive atom p tn →! t , У ▶D p tn →! t ⇐
Π iff Π |=D p tn →! t .
Entailment Property: T : У ▶D ϕ and ϕ  D ϕ' implies T ' : У ▶D ϕ'
for some proof tree T ' such that | T ' |≤ | T |.
The Constraint Rewriting Logic CRWL(Ð): Model Theory
In this section we investigate the relationship between CRWL(Ð)-derivability and the two model-theoretic semantics presented in sections 3.2 and 3.3.
Our main result is the next theorem, showing a nice correspondence between CRWL(Ð)-derivability, strong consequence, and validity in least strong mo- dels:
Theorem 4.3 Correctness Results for Strong Semantics.
For any CFLP (Ð)-program У and any c-statement ϕ, the following three con-

ditions are equivalent:
(a) У ▶D ϕ	(b) У |=s ϕ	(c) SP ▶▶D ϕ
Moreover, we also have:
Soundness: for any c-statement ϕ, У ▶D ϕ ⇒ У |=s ϕ.
Completeness: for any c-statement ϕ, У |=s ϕ ⇒ У ▶D ϕ.
Canonicity: SP = {ϕ | ϕ is a c-fact and У ▶D ϕ}.
Proof. A proof of the equivalence among (a), (b), (c) is given in Section 7.2. Soundness and completeness are just a trivial consequence of this equivalence. In order to prove canonicity, consider any c-fact ϕ. We know that ϕ ∈ SP
iff SP ▶▶D ϕ, because of the Conservation Property from Lemma 3.6. On the
other hand, SP ▶▶D ϕ iff У ▶D ϕ is ensured by the equivalence between (c)
and (a).	 
Concerning the relationship between CRWL(Ð)-derivability and the weak semantics, most of the results (with the exception of soundness) must be
restricted to ground c-statements:
Theorem 4.4 Correctness Results for Weak Semantics.
For any CFLP (Ð)-program У and any ground c-statement ϕ, the following three conditions are equivalent:
(a) У ▶D ϕ	(b) У |=w ϕ	(c) WP ▶▶D ϕ
Moreover, we also have:
Soundness: for any c-statement ϕ, У ▶D ϕ ⇒ У |=w ϕ.

Ground Completeness: for any ground c-statement ϕ, У |=w
ϕ. This does not hold in general for arbitrary c-statements.
ϕ ⇒ У ▶D

Ground Canonicity: gdD(WP ) = {ϕ | ϕ is a ground c-fact and У ▶D ϕ}.
Proof. The equivalence among (a), (b), (c) can be proved by similar reason- ings as those used in the proof of Theorem 4.3.
In order to prove soundness, assume any c-statement ϕ such that У ▶D ϕ. By the Entailment Property of Lemma 4.2, we the have У ▶D ϕη for all ground substitutions η ∈ GSub⊥(U ). Due to the equivalence between (a)
and (b), we get У |=w ϕη for all η ∈ GSub⊥(U), which amounts to f ▶▶D ϕη

for every η ∈ GSub⊥(U) and all weak models f |=w
У. Therefore, we can

conclude that У |=w ϕ.


Ground completeness is a direct consequence of the equivalence between
(a) and (b). When considering arbitrary statements, completeness w.r.t. weak semantics fails in general. As a counterexample, consider the follow- ing CFLP (R)-program:
У =def {notZero X → true ⇐ X > 0
notZero X → true ⇐ X < 0}
and the c-fact ϕ =def notZero X → true ⇐ X /=R 0. For this particular choice of У and ϕ we can claim:

For every weak model f |=w
У, it is easy to see that (notZero x → true) ∈

f for all x ∈ R \ {0}, which implies f |=w ϕ. Therefore, У |=w ϕ.
On the other hand, У /▶R ϕ, because the proof (if existing) should use the CRWL(R)-rule DFP together with some program rule, and neither of the two rules in У supports such an inference.
Finally, ground canonicity just follows form the equivalence between (c) and (a) and the Conservation Property from Lemma 3.6, as in the proof of Theorem 4.4. Note that WP includes also some non-ground c-facts, because
all c-interpretations over Ð are required to be closed under clD. Nevertheless,
for the purposes of weak semantics, only the ground c-facts are the relevant. 
Using Theorems 4.3 and 4.4 we can now easily obtain two results that were announced at the end of sections 3.2 and 3.3, respectively.
Proposition 4.5 Strong versus Weak Consequence.
For any CFLP (Ð)-program У and any c-fact ϕ one has: У |=s  ϕ ⇒ У |=w
ϕ. The reciprocal is false in general.

Proof. Assume that У |=s
ϕ. By the Completeness Property in Theorem

, we can conclude that У ▶D ϕ, which implies У |=w
ϕ by the Soundness

Property in Theorem 4.4.
On the other hand, in the proof of Theorem 4.4 we have seen a CFLP (R)-
program У and a non-ground c-statement ϕ such that У |=w ϕ and У /▶R ϕ,
which is the same as У |=s ϕ because of Theorem 4.3.	 
Proposition 4.6 Strong versus Weak Least Models.
For any CFLP (Ð)-program У one has WP ⊆ SP . The inclusion is strict in general.
Proof. According to Proposition 3.10 and the first item in Theorem 3.15, SP is a weak model of У. By the second item of Theorem 3.15, WP is the least weak model of У. Therefore, WP ⊆ SP .
As a counterexample for the opposite inclusion, consider an arbitrary cons-


traint domain Ð with urelements C, the CFLP (Ð)-program У consisting of one single program rule id X → X defining the identity function, and the c-interpretation f = clD({id t → t | t ∈ DU }). Note that the c-fact ϕ = (id X → X) does not belong to f, since it is neither a trivial c-fact nor follows by Ð-entailment from the ground c-facts used for defining f. On the other hand, ϕ belongs to £P by the Canonicity Property in Theorem 4.3, because У ▶D ϕ is obviously true. Therefore, £P /⊆ f. But УP ⊆ f holds by Theorem 3.15, because f is clearly a weak model of У. From £P /⊆ f and УP ⊆ f we conclude £P /⊆ УP.	 

Conclusions
We have proposed a new generic scheme CFLP (Ð) which provides a uniform foundation for the semantics of constraint functional logic programs. As main
novelties w.r.t. previous related approaches, we have presented a new formali- zation of constraint domains, a new notion of interpretation giving rise to weak and strong semantics for programs, and a new constraint rewriting logic CRWL(Ð) whose proof theory is sound and complete w.r.t. strong semantics,
and sound and ground complete w.r.t. weak semantics.
Our results can be viewed as a natural and not trivial extension of known results on the semantics of success in the CLP (Ð) scheme for constraint logic programming [49,34]. In comparison to previous work on constraint functional logic programming, we have improved our older CFLP (Ð) scheme [56,57] in several respects, and we have provided a rigorous declarative semantics which
was missing in other approaches.
The improvements in the new scheme provide a satisfactory foundation for our previous work on functional logic programming with disequality cons- traints [53,5,58] and a solid starting point for a better foundation of our pre- vious work on functional logic programming with multiset constraints [6,7].
Multiset constraints are outside the scope of the present paper because they use algebraic data constructors, while the CFLP (Ð) scheme presented here assumes free data constructors.
The new scheme CFLP (Ð) is also planned as a basis for several lines of ongoing and future work, involving other people at our University Depart-
ment in addition to the authors. The design of a lazy constrained narrowing calculus for goal solving has already started, using ideas and techniques from the narrowing calculi in [36,38,88] as well as a notion of solver inspired in [56,5,63]. After completing this work, we plan to investigate an extension of
the CFLP (Ð) scheme with algebraic data constructors.
Concerning concrete instances of the CFLP (Ð) scheme, we plan to formali-


ze the work on functional logic programming with finite domain constraints started in [32] and to investigate practical constraint solving methods and applications of the resulting language.
Last but not least, we also plan to extend the work on declarative debug- ging of functional logic programs started in [15,16,17] to CFLP (Ð)-programs, taking into account existing work on the declarative debugging of constraint
logic programs [87] and the finite failure semantics of functional logic programs with disequality constraints [60,61,62,63,64].

References
M. Abeng´ozar-Carneros, P. Arenas-Sa´nchez, R. Caballer-Rold´an, A. Gil-Luezas, J.C. Gonz´alez- Moreno, J. Leach-Albert, F.J. L´opez-Fraguas, N. Mart´ı-Oliet, J.M. Molina-Bravo, E. Pimentel- S´anchez, M. Rodr´ıguez-Artalejo, M.M. Rolda´n-Garc´ıa, J.J. Ruz-Ortiz and J. Sa´nchez- Hern´andez. T OY: A Multiparadigm Declarative Language. Version 2.0. Technical Report, Dpto. Sistemas Inform´aticos y Programaci´on, Universidad Complutense de Madrid, February 2002.
H. A¨ıt-Kaci and A. Podelski. A feature constraint system for logic programming with entailment. Theoretical Computer Science 122, pp. 263–283, 1994.
K.R. Apt. Logic Programming. In J. van Leeuwen (ed.), Handbook of Theoretical Computer Science, Vol. B, Chapter 10, Elsevier and The MIT Press, pp. 493–574, 1990.
K.R. Apt and M. Gabbrielli. Declarative Interpretations Reconsidered. Proc. Int. Conf. on Logic Programming (ICLP’94), Santa Margherita Ligure, the MIT Press, pp. 74–89, 1994.
P. Arenas-S´anchez, A. Gil-Luezas and F.J. L´opez-Fraguas. Combining Lazy Narrowing with Disequality Constraints. Proc. Int. Symp. on Programming Language Implementation and Logic Programming (PLILP’94), Springer LNCS 844, pp. 385–399, 1994.
P. Arenas-S´anchez, F.J. L´opez-Fraguas and M. Rodr´ıguez-Artalejo. Embedding Multiset Constraints into a Lazy Functional Logic Language. Proc. Int. Symp. on Programming Language Implementation and Logic Programming (PLILP’98), held jointly with the 6th Int. Conf. on Algebraic and Logic Programming (ALP’98), Pisa, Springer LNCS 1490, pp. 429–444, 1998.
P. Arenas-S´anchez, F.J. L´opez-Fraguas and M. Rodr´ıguez-Artalejo. Functional plus Logic Programming with Built-in and Symbolic Constraints. Proc. Int. Conf. on Principles and Practice of Declarative Programming (PPDP’99), Paris, Springer LNCS 1702, pp. 152–169, 1999.
P. Arenas-S´anchez and M. Rodr´ıguez-Artalejo. A Semantic Framework for Functional Logic Programming with Algebraic Polymorphic Types. Proc. Int. Joint Conference on Theory and Practice of Software Development (TAPSOFT’97), Springer LNCS 1214, pp. 453–464, 1997.
P. Arenas-S´anchez and M. Rodr´ıguez-Artalejo. A Lazy Narrowing Calculus for Functional Logic Programming with Algebraic Polymorphic Types. Proc. Int. Symp. on Logic Programming (ILPS’97), The MIT Press, pp. 53–68, 1997.
P. Arenas-S´anchez and M. Rodr´ıguez-Artalejo. A general framework for lazy functional logic programming with algebraic polymorphic types. Theory and Practice of Logic Programming 1(2), pp. 185–245, 2001.
F. Baader and T. Nipkow. Term Rewriting and All That. Cambridge University Press, 1998.
R. Backofen. A Complete Axiomatization of a Theory with Feature and Arity Constraints. Journal of Logic Programming 24(1&2), pp. 37–71, 1995.


R. Backofen and G. Smolka. A complete and recursive feature theory. Theoretical Computer Science 146, pp. 243–268, 1995.
A. Bossi, M. Gabbrielli, G. Levi and M. Martelli. The s-Semantics Approach: Theory and Applications. Journal of Logic Programming 19&20, pp. 149–197, 1994.
R. Caballero, F.J. L´opez-Fraguas and M. Rodr´ıguez-Artalejo. Theoretical Foundations for the Declarative Debugging of Lazy Functional Logic Programs. Proc. of the 5th International Symposium on Functional and Logic Programming (FLOPS’2001), Springer LNCS 2024, pp. 170–184, 2001.
R. Caballero and M. Rodr´ıguez-Artalejo. A Declarative Debugging System for Lazy Functional Logic Programs. Electronic Notes in Theoretical Computer Science 64, 63 pages, 2002.
R. Caballero and M. Rodr´ıguez-Artalejo. DDT : A Declarative Debugging Tool for Functional Logic Languages. To appear in Proc. of the 7th International Symposium on Functional and Logic Programming (FLOPS’2004), Springer LNCS.
K.L. Clark. Predicate logic as a computational formalism. Research Report DOC 79/59, Imperial College, Department of Computing, London 1979.
A. Colmerauer. Prolog and Infinite Trees. In K.L. Clark and S.A. T¨arnlud (eds.), Logic Programming, Academic Press, pp. 153–172, 1982.
A. Colmerauer. Equations and Inequations on Finite and Infinite Trees. Proc. of the 2nd International Conference on Fifth Generation Computer Systems, pp. 85–89, 1984.
L. Damas and R. Milner. Principal Type Schemes for Functional Programs. Proc. ACM Symp. on Principles of Programming Languages (POPL’82), ACM Press, pp. 207–212, 1982.
J. Darlington and Y.K. Guo. Constraint Functional Programming. Technical Report, Imperial College, November 1989.
J. Darlington and Y.K. Guo. Constraint Equational Deduction. Proc. of 2nd Int. Workshop on Conditional and Typed Rewriting Systems (CTRS’90), Springer LNCS 516, pp. 11–14, 1991.
J. Darlington, Y.K. Guo and H. Pull. Introducing Constraint Functional Logic Programming. PHOENIX Seminar and Workshop on Declarative Programming (DP’91), Springer Workshops in Computing, pp. 20–34, 1992.
J. Darlington, Y.K. Guo and H. Pull. A New Perspective on the Integration of Functional and Logic Languages. Proc. of the Int. Conf. on Fifth Generation Computer Systems (FGCS’92), IOS Press, pp. 682–693, 1992.
D. DeGroot and G. Lindstrom (eds.). Logic Programming: Functions, Relations and Equations. Prentice-Hall, Englewood Cliffs, 1986.
N. Dershowitz and J.P. Jouannaud. Rewrite Systems, in J.van Leeuwen (ed.), Handbook of Theoretical Computer Science, Vol. B, Chapter 6, Elsevier and The MIT Press, pp. 243–320, 1990.
N. Dershowitz and M. Okada. A Rationale for Conditional Equational Programming. Theoretical Computer Science 75, pp. 111–138, 1990.
M. Falaschi, G. Levi, M. Martelli and C. Palamidessi. Declarative Modeling of the Operational Behavior of Logic Languages. Theoretical Computer Science 69(3). pp. 289–318, 1989.
M. Falaschi, G. Levi, M. Martelli and C. Palamidessi. A Model-theoretic Reconstruction of the Operational Semantics of Logic Programs. Information and Computation 102(1). pp. 86-113, 1993.
M.J. Fay. First-Order Unification in an Equational Theory. Proc. Workshop on Automated Deduction (CADE’79), Academic Press, pp. 161–177, 1979.
A.J. Fern´andez, M.T. Hortala´-Gonza´lez and F. Sa´enz P´erez. Solving Combinatorial Problems with a Constraint Functional Logic Language. Proc. 5th International Symposium on Principles and Practice of Declarative Languages (PADL’2003), Springer LNCS 2562, pp. 320–338, 2003.


M. Gabbrielli and G. Levi. Modeling Answer Constraints in Constraint Logic Programs. Proc. of the Eigth Int. Conf. on Logic Programming (ICLP’91), The MIT Press, pp. 238–252, 1991.
M. Gabbrielli, G.M. Dore and G. Levi. Observable Semantics for Constraint Logic Programs. Journal of Logic and Computation 5 (2), pp. 133–171, 1995.
J.C. Gonz´alez-Moreno, M.T. Hortala´-Gonza´lez, F.J. L´opez-Fraguas and M. Rodr´ıguez- Artalejo. A Rewriting Logic for Declarative Programming. Proc. European Symp. on Programming (ESOP’96), Springer LNCS 1058, pp. 156–172, 1996.
J.C. Gonz´alez-Moreno, M.T. Hortala´-Gonza´lez, F.J. L´opez-Fraguas and M. Rodr´ıguez- Artalejo. An Approach to Declarative Programming Based on a Rewriting Logic. Journal of Logic Programming 40(1), pp. 47–87, 1999.
J.C. Gonz´alez-Moreno, M.T. Hortala´-Gonza´lez and M. Rodr´ıguez-Artalejo. A Higher Order Rewriting Logic for Functional Logic Programming. Proc. Int. Conf. on Logic Programming, The MIT Press, pp. 153–167, 1997.
J.C. Gonz´alez-Moreno, M.T. Hortala´-Gonza´lez and M. Rodr´ıguez-Artalejo. Polymorphic Types in Functional Logic Programming. FLOPS’99 special issue of the Journal of Functional and Logic Programming, 2001. http://danae.uni-muenster.de/lehre/kuchen/JFLP.
C.A. Gunter and D. Scott. Semantic Domains. in J.van Leeuwen (ed.), Handbook of Theoretical Computer Science, Elsevier and The MIT Press, Vol. B, Chapter 6, pp. 633–674, 1990.
M. Hanus. The Integration of Functions into Logic Programming: From Theory to Practice. Journal of Logic Programming 19&20, pp. 583–628, 1994.
M. Hanus (ed.), Curry: an Integrated Functional Logic Language, Version 0.8, April 15, 2003.
http://www-i2.informatik.uni-kiel.de/∼curry/.
M. Henz, G. Smolka and J. Wu¨rtz. Object-oriented concurrent constraint programming in Oz. In V. Saraswat and P.V. Hentenryck (eds.), Principles and Practice of Constraint Programming, The MIT Press, Chapter 2, pp. 27–48, 1995.
J.M. Hullot. Canonical Forms and Unification. Proc. Conf. on Automated Deduction (CADE’80), Springer LNCS 87, pp. 318–334, 1980.
H. Hussmann. Nichtdeterministische Algebraische Spezifikationen. Ph. D. Thesis, University of Passau, 1988. (In German)
H. Hussmann. Nondeterministic Algebraic Specifications and Nonconfluent Term Rewriting. Journal of Logic Programming 12, pp. 237–255, 1992.
H. Hussmann. Non-determinism in Algebraic Specifications and Algebraic Programs. Birkha¨user Verlag, 1993.
J. Jaffar and J.L. Lassez. Constraint Logic Programming. In Proc. ACM Symp. on Principles of Programming Languages (POPL’87), ACM Press, pp. 111–119, 1987.
J. Jaffar and M.J. Maher. Constraint Logic Programming: A Survey. The Journal of Logic Programming 19&20, pp. 503–581, 1994.
J. Jaffar, M.J. Maher, K. Marriott and P.J. Stuckey. The Semantics of Constraint Logic Programs. Journal of Logic Programming, 37 (1-3) pp. 1–46, 1998.
J. Jaffar, S. Michaylov, P.J. Stuckey and R.H.C. Yap. The CLP(R) Language and System. ACM Transactions on Programming Languages and Systems, 14 (3) pp. 339–395, 1992.
C. Kirchner, H. Kirchner and M. Rusinowitch. Deduction with Symbolic Constraints. Revue Fran¸caise d’Intelligence Artificielle, 4 (3) pp. 9–52, 1990.
J.W. Klop. Term Rewriting Systems. In S. Abramsky, D.M. Gabbay and T.S.E. Maibaum (eds.), Handbook of Logic in Computer Science, Vol. 2, pp. 2–116, Oxford University Press, 1992.


H. Kuchen, F.J. L´opez-Fraguas, J.J. Moreno-Navarro and M. Rodr´ıguez-Artalejo. Implementing a Lazy Functional Logic Language with Disequality Constraints. Proc. Joint Int. Conf. and Symposium on Logic Programming (JICSLP’92), The MIT Press, pp. 207–221, 1992.
D.S. Lankford. Canonical inference. Technical Report ATP-32, Department of Mathematics and Computer Science, University of Texas at Austin, 1975.
J.W. Lloyd. Foundations of Logic Programming. 2nd. ed., Springer Verlag, 1987.
F.J. L´opez-Fraguas. A General Scheme for Constraint Functional Logic Programming. Proc. Int. Conf. on Algebraic and Logic Programming (ALP’92), Springer LNCS 632, pp. 213–227, 1992.
F.J. L´opez-Fraguas. Programacio´n Funcional y Logica con Restricciones. Ph.D. Thesis, Univ. Complutense Madrid, 1994. (In Spanish)
F.J.L´opez Fraguas, J. S´anchez Herna´ndez. Disequalities May Help to Narrow. Proc. APPIA- GULP-PRODE’99, pp. 89–104, 1999.
F.J.L´opez Fraguas, J. S´anchez Herna´ndez. T OY: A Multiparadigm Declarative System. Proc. RTA’99, Springer LNCS 1631, pp 244–247, 1999.
F.J. L´opez-Fraguas and J. S´anchez-Herna´ndez. Proving Failure in Functional Logic Programs. Proc. Int. Conf. on Computational Logic (CL’2000), Springer LNCS 1861, pp. 179–193, 2000.
F.J. L´opez-Fraguas and J. S´anchez-Herna´ndez. Functional Logic Programming with Failure: A Set-Oriented View. Proc. Int. Conf. on Logic Programming and Automated Reasoning (LPAR’2001), Springer LNCS 2250, pp. 455–469, 2001.
F.J. L´opez-Fraguas and J. S´anchez-Herna´ndez. Narrowing Failure in Functional Logic Programming. Proc. 6th Int. Symp. on Functional and Logic Programming (FLOPS’2002), Springer LNCS 2441, pp. 212–227, 2002.
F.J. L´opez-Fraguas and J. S´anchez-Herna´ndez. Failure and equality in functional logic programming. Electronic Notes in Theoretical Computer Science 86(3), 21 pages, 2003.
F.J. L´opez-Fraguas and J. S´anchez-Herna´ndez. A Proof Theoretic Approach to Failure in Functional Logic Programming. Theory and Practice of Logic Programming 4(1), pp. 41–74, 2004.
M.J. Maher. Complete Axiomatization of the Algebras of Finite, Rational and Infinite Trees. Proc. of the Third Annual Symposium of Logic in Computer Science (LICS’88), IEEE Computer Society Press, pp. 348–357, 1988.
L. Mandel. Constrained lambda calculus. Aachen Verlag Shaker, 1995.
M. Marin. Functional Logic Programming with Distributed Constraint Solving. Ph. D. Thesis, Johannes Kepler Universit¨at Linz, 2000.
M. Marin, T. Ida and W. Schreiner. CFLP: a Mathematica Implementation of a Distributed Constraint Solving System. In Third International Mathematical Symposium (IMS’99), Hagenberg, Austria, August 23–25, 10 pages, 1999.
M. Marin, T. Ida and T. Suzuki. Cooperative Constraint Functional Logic Programming. In International Symposium on Principles of Software Evolution (IPSE’2000), pp. 223–230, November 1–2, 2000.
K. Marriott and P.J. Stuckey. Programming with Constraints, An Introduction. The MIT Press, 1998.
J. Meseguer. Conditional Rewriting Logic as a Unified Model of Concurrency. Theoretical Computer Science 96, pp. 73–155, 1992.
A. Middeldorp and E. Hamoen. Completeness Results for Basic Narrowing. Applicable Algebra in Engineering, Communications and Computing 5, pp. 213–253, 1994.


R. Milner. A Theory of Type Polymorphism in Programming. Journal of Computer and Systems Sciences, 17, pp. 348–375, 1978.
B. M¨oller. On the Algebraic Specification of Infinite Objects - Ordered and Continuous Models of Algebraic Types. Acta Informatica 22, pp. 537–578, 1985.
A. Mu¨ck, T. Streicher. A Tiny Constrain Functional Logic Language and Its Continuation Semantics. Proc. European Symp. on Programming (ESOP’94), Springer LNCS 788, pp. 439- 453, 1994.
M. Palomino Tarjuelo. Comparing Meseguer’s Rewriting Logic with the Logic CRWL. Electronic Notes in Theoretical Computer Science 64, 22 pages, 2002.
M. Palomino Tarjuelo. A Comparison between Meseguer’s Rewriting Logic and the Logic CRWL. Under consideration for publication in Theory and Practice of Logic Programming.
J.A. Robinson ans E.E. Sibert. LOGLISP: Motivation, Design and Implementation. In
K.L. Clark and S.A. T¨arnlund (eds.), Logic Programming, Academic Press, pp. 299–313, 1982.
M. Rodr´ıguez-Artalejo. Functional and Constraint Logic Programming. in H. Comon,
C. March´e and R. Treinen (eds.), Constraints in Computational Logics, Theory and Applications, Revised Lectures of the International Summer School CCL’99, Springer LNCS 2002, Chapter 5, pp. 202–270, 2001.
V. Saraswat. Concurrent Constraint Programming Languages. PhD Thesis, Carnegie Mellon University, 1989. In ACM distinguished dissertattion series. The MIT press, 1993.
V. Saraswat and M. Rinard. Concurrent Constraint Programming. Proc. of the 17th Annual Symposium on Principles of Programming Languages (POPL’90), ACM Computer Society Press, pp. 232–245, 1990.
V. Saraswat, M. Rinard and P. Panangaden. Semantic Foundations of Concurrent Constraint Programming. Proc. of the 18th Annual Symposium on Principles of Programming Languages (POPL’91), ACM Computer Society Press, pp. 333–352, 1991.
D.S. Scott. Domains for Denotational Semantics. Proc. ICALP’82, Springer LNCS 140, pp. 577–613, 1982.
J.R. Slagle. Automated Theorem-Proving for Theories with Simplifiers, Commutativity and Associativity. Journal of the ACM 21(4), pp. 622–642, 1974.
G. Smolka and R. Treinen. Records for Logic Programming. Journal of Logic Programming 18, pp. 229–258, 1994.
A. Tarski. A lattice-theoretical fixpoint theorem and its applications. Pacific Journal of Mathematics 5, pp. 285–309, 1955.
A. Tessier and G. Ferrand. Declarative Diagnosis in the CLP Scheme. In P. Deransart, M. Hermenegildo and J. Ma-luszynski (eds.), Analysis and Visualization Tools for Constraint Programming, Chapter 5, pp. 151–174. Springer LNCS 1870, 2000.
R. del Vado-V´ırseda. A Demand-driven Narrowing Calculus with Overlapping Definitional Trees. Proc. ACM SIGPLAN Conf. on Principles and Practice of Declarative Programming (PPDP’03), ACM Press, pp. 213–227, 2003.
P. Van Hentenryck. Constraint Satisfaction in Logic Programming. Logic Programming Series, The MIT Press, 1989.
P. Van Hentenryck. Constraint logic programming. The Knowledge Engineering Review, Vol. 6:3, pp. 151–194, 1991.
P. Van Hentenryck, H. Simonis and M. Dincbas. Constraint satisfaction using constraint logic programming. Artificial Intelligence 58, pp. 113–159, 1994.
P. Van Hentenryck, V. Saraswat and Y. Deville. Design, implementation and evaluation of the constraint language cc(FD). Journal of Logic Programming 37, pp. 139–164, 1998.
G. Winskel. On Powerdomains and Modality. Theoretical Computer Science 36, pp. 127–137, 1985.

Small sample of CFLP (Ð)-programming in T OY
Permutation sort in CFLP (Hseq) using strict equality
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	%
%	Programming in CFLP(H_seq)	%
%	%
%	using strict equality constraints	%
%	%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Lazy generate & test as a higher order scheme.
%
% Problem: Given a generator, a tester and an input, find a solution.
%	The generator will be a non-deterministic lazy function.
% Method:  Lazy generate and test.

findSol :: (Input -> Solution) -> (Solution -> bool) -> Input -> Solution findSol Generate Test Input -> check Test (Generate Input)

check :: (Solution -> bool) -> Solution -> Solution check Test Candidate = Candidate <== Test Candidate

% Intended Goals: findSol input == Sol
% Application: permutation sort.

permSort :: [int] -> [int]
pemSort = findSol permute isSorted
% The generator computes permutations: permute :: [A] -> [A]
permute []	-> []
permute [X|Xs] -> insert X (permute Xs)

insert :: A -> [A] -> [A] insert X []	-> [X]
insert X [Y|Ys] -> [X,Y|Ys] // [Y|insert X Ys]

% Binary choice function. infixr 20 //
(//) :: A -> A -> A
X // Y = X 
X // Y = Y 
% The tester accepts sorted lists: isSorted :: [int] -> bool
isSorted []	= true
isSorted [X]	= true
isSorted [X,Y|Zs] = (X <= Y) /\ (isSorted [Y|Zs])

% /\ behaves as sequential conjunction: infixr 40 /\
(/\) :: bool -> bool -> bool false /\ Y = false
true  /\ Y = Y

% Auxiliary funtion for tests:




downFrom :: int -> [int]
downFrom N = if N > 0 then [N|downFrom (N-1)] else [N]

% Goal:	permSort (downFrom 99) == Xs
% Solution:  Xs = [0,1,2, ..., 99]

List difference in CFLP (Hseq) using disequality constraints
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	%
%	Programming in CFLP(H_seq)	%
%	%
%	using disequality constraints	%
%	%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Problem: given two lists Xs, Ys, compute the list difference Xs -- Ys,
%	obtained by deleting from Xs the first occurrence of each member
%	of Ys, failing in case that some member of Ys does not occur
%	in Xs with the same multiplicity; i.e., compute the difference
%	Xs -- Ys viewing the lists Xs, Ys as representations of multisets. infixl 50 --
(--) :: [A] -> [A] -> [A] Xs -- []	= Xs
Xs -- [Y|Ys] = (delete Y Xs) -- Ys

delete :: A -> [A] -> [A]
delete Y [X|Xs] = if Y == X then Xs else [X|delete Y Xs]

% Note: (delete Y Xs) fails if Y does not occur in Xs.
%
% Moreover, the rule of "delete" is TOY code for:
%
% delete Y [X|Xs] -> if R then Xs else [X|delete Y Xs] <== seq X Y ->! R
%
% The use of the seq primitive here involves disequality constraints.
% An equivalent but less efficient definition of delete would be:
%
% delete Y [X|Xs] -> Xs	<== Y == X
% delete Y [X|Xs] -> [X|delete Y Xs] <== Y /= X
%
% Disequality constraints are apparent in this version

% Goal:	[1,2,3,2,4] -- [2,4] == Xs
% Solution:  Xs = [1,3,2]

% Goal:	("angle" -- Xs) ++ Xs == "angel"
% Solutions: Xs = "l"; Xs = "el"; Xs = "gel"; etc.

% Application: computing permutations.
% (alternative to the function "permute" above)
% Not good for using in cooperation with "permSort",
% because "permutation" is not a lazy generator!

permutation :: [A] -> [A]
permutation Xs -> Ys <== Ys -- Xs == []

% Goal:	permutation [1,2,3] == Xs
% Solutions:  Xs == [1,2,3] ;
%	Xs == [1,3,2] ;
%	Xs == [2,1,3] ;



%	Xs == [2,3,1] ;
%	Xs == [3,1,2] ;
%	Xs == [3,2,1] ;
%	no










Computing a mortgage in CFLP (R)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	%
%	Programming in CFLP(R)	%
%	%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Computing a mortgage (adapted from K. Marriott and P.J. Stuckey)

% Some useful type alias.


% Computation of the new principal NP after one repayment R:
%
% NP = P + P*I - R

mortgage :: (principal,time,interest,repayment) -> balance mortgage (P, T, I, R) = P <== T == 0
mortgage (P, T, I, R) = mortgage (P + P*I - R, T-1, I, R) <== T >= 1

% Several modes of use are possible:

% What is the balance corresponding to borrowing 1000 Euros for 10 years at
% an interest rate of 10% and repaying 150 Euros per year?
%
% Goal:	mortgage (1000, 10, 10/100, 150) == B
% Solution: B == 203.12876995000016

% How much can be borrowed in a 10 year loan at 10% with
% annual repayments of 150 Euros?
%
% Goal:	mortgage (P, 10, 10/100, 150) == 0
% Solution: P == 921.6850658557024

% What must be the relationship between the initial principal, the
% repayment an the balance in a 10 year loan at 10%?
%
% Goal:	mortgage(P, 10, 10/100, R) == B
% Solution: B == 2.5937424601*P-15.937424601000002*R
%	(a linear constraint relating P, R and B)


Proofs of the main results
Proofs of the main results from section 3
Proof of Lemma 3.6
Proof. (1) Assume a given proof tree T for f ▶▶D ϕ. Reasoning by induc- tion on  T  we prove the existence of some finite subset f0 ⊆ f and a proof tree T ' such that T ' : clD(f0) ▶▶D ϕ. We distinguish cases according to the inference rule applied at the root of T . First, if T is an easy proof tree the property holds trivially because T : f ▶▶D ϕ is a derivation from the trivial c-interpretation clD(∅). Therefore, T and T ' are the same easy proof tree for clD(∅) ▶▶D ϕ, and of course, for clD(f0) ▶▶D ϕ with f0 ⊆ f every finite sub- set. In other case, using the induction hypothesis and the fact that we only
use almost one c-fact of f in each step of the derivation, the property is obvi- ous for all the rest of inference rules applied at the root of T . For example, if ϕ = f enak → t ⇐ Π and T = DFI(f enak → t ⇐ Π, [T1,... , Tn, Ts]) for some
c-fact (f tn → s ⇐ Π) ∈ f such that Ti : f ▶▶D ei → ti ⇐ Π with  Ti  <  T 

(1 ≤ i ≤ n) and Ts : f ▶▶D s ak → t ⇐ Π with  Ts  <  T  , by induction hy- pothesis we obtain T ' : clD(fi) ▶▶D ei → ti ⇐ Π for some finite subset fi ⊆ f 
(1 ≤ i ≤ n) and T ' : clD(fs) ▶▶D s ak → t ⇐ Π for some finite subset fs ⊆ f.

Then, we can define the finite subset f0 =def 
s
m fi ∪ fs ∪ {f tn → s ⇐ Π}.

We note that f0 ⊆ f and clD(f0) = 
m
i=1
clD(fi) ∪ clD(fs) ∪ clD({f tn →

s ⇐ Π}). Moreover, we have T ' : clD(f0) ▶▶D ei → ti ⇐ Π (1 ≤ i ≤ n),
' : clD(f0) ▶▶D s ak → t ⇐ Π and (f tn → s ⇐ Π) ∈ clD(f0). Hence,
T ' =def DFclD(I0 )(f enak → t ⇐ Π, [T ',... ,T ' ,T ']).
1	n	s
Assume a given proof tree T for f ▶▶D ϕ. Reasoning by induction on  T  , we prove the existence of a proof tree T ' for f' ▶▶D ϕ. First, if T is an easy proof tree then the property holds trivially because T : f ▶▶D ϕ is a derivation from the trivial c-interpretation clD(∅). Therefore, T and T ' are the same easy proof tree for clD(∅) ▶▶D ϕ, and of course, for f' ▶▶D ϕ. In other case, using the induction hypothesis and the fact that f ⊆ f' if f is necessary in the derivation, the property is obvious for all the rest of inference
rules applied at the root of T . For example, if ϕ = f enak → t ⇐ Π and T = DFI(f enak → t ⇐ Π, [T1,... , Tn, Ts]) for some c-fact (f tn → s ⇐ Π) ∈ f such that Ti : f ▶▶D ei → ti ⇐ Π with Ti  < T  (1 ≤ i ≤ n) and Ts : f ▶▶D s ak → t ⇐ Π with  Ts  <  T  , by induction hypothesis we obtain
' : f' ▶▶D ei → ti ⇐ Π (1 ≤ i ≤ n) and T ' : f' ▶▶D s ak → t ⇐ Π.
Moreover, since f ⊆ f', we also have (f tn → s ⇐ Π) ∈ f'.	Hence,
T ' =def DFI' (f enak → t ⇐ Π, [T ',... ,T ' ,T ']), which verifies T ' : f' ▶▶D ϕ.
1	n	s
In case that SolD(Π) = ∅, Π |=D e ± t is trivially true and T : ▶▶D


e → t ⇐ Π with just one TI inference. In the rest of this proof we can assume SolD(Π) /= ∅ and reason by induction on the syntactic size of e. We distinguish cases for t:

t = ⊥. In this case, Π |=D e ± ⊥ is trivially true and T : ▶▶D e → ⊥ ⇐ Π with just one TI inference.

t = u ∈ C. We consider several subcases for e. If e = u then Π |=D u ± u is true and T : ▶▶D u → u ⇐ Π with just one RR inference. If e = X ∈ V and Π |=D X ± u then T : ▶▶D X → u ⇐ Π with just one SP inference, and if Π $D X ± u then KD X → u ⇐ Π (since no inference rule is applicable). Finally, if e is neither u nor a variable then Π $D e ± u. Assume a proof tree T : ▶▶D e → u ⇐ Π (if there is no proof tree, then
we are done). Since the c-interpretation is clD(∅) and e /= u, e ∈/ V, the
inference rule applied at the root of T must be either PF or AC. In either
case, T is not easy.

t = X ∈ V. We consider several subcases for e. If e = X then Π |=D
X ± X and T : ▶▶D X → X ⇐ Π with just one RR inference. If e is a pattern s /= X and Π |=D s ± X then T : ▶▶D s → X ⇐ Π with just one SP inference, and if Π $D s ± X then KD s → X ⇐ Π (since no inference rule is applicable). Finally, if e is not a pattern, we consider any µ ∈ SolD(Π) such that Xµ is a total pattern. Then eµ ± Xµ is not true and therefore Π $D e ± X. Assume a proof tree T : ▶▶D e → X ⇐ Π (if there is no proof tree, then we are done). Since the c-interpretation is clD(∅) and e is not a pattern, the inference rule applied at the root of T must be IR, PF or AC. In the last two cases, T is not easy. In the first
case, we can assume that e = h em is a rigid and passive expression but

not a pattern. Hence T = IR(h em → X ⇐ Π, [T1,... , Tm]), and for each 1 ≤ i ≤ m, Ti : ▶▶D ei → ti ⇐ Π such that Π |=D h tm ± X. Then, for some 1 ≤ i ≤ m, Π $D ei ± ti. Otherwise we would have Π |=D ei ± ti for all 1 ≤ i ≤ m, and then Π |=D h em ± h tm and Π |=D h em ± X, which is not the case. Fix any 1 ≤ i ≤ m such that Π $D ei ± ti. By induction hypothesis (note that the size of ei is smaller than the size of
h em), Ti is not an easy proof tree. Therefore, T is not easy either.

t = h tm with t1,... , tm patterns. We consider again several subcases for e. If e = X ∈ V and Π |=D X ± h tm then T : ▶▶D X → h tm ⇐ Π with just one SP inference, and if Π $D X ± h tm then KD X → h tm ⇐ Π



(since no inference rule is applicable). If e = h em and Π |=D h em ± h tm then Π |=D ei ± ti for all 1 ≤ i ≤ m. Hence, by induction hypothesis (the size of ei is smaller than the size of h em), ▶▶D ei → ti ⇐ Π with an easy proof tree Ti for all 1 ≤ i ≤ m and T : ▶▶D h em → h tm ⇐ Π with T = DC(h em → h tm ⇐ Π, [T1,... , Tm]) is an easy proof true. Moreover, if Π $D h em ± h tm then Π $D ei ± ti for some 1 ≤ i ≤ m. Hence, by induction hypothesis, there is some 1 ≤ i ≤ m such that no easy proof tree Ti for ▶▶D ei → ti ⇐ Π exists. Therefore, no easy proof tree T exists for ▶▶D h em → h tm ⇐ Π (DC doesn’t work and no other inference rule applies). Finally, if e is neither a variable nor of the form h em then we
consider any total µ ∈ SolD(Π). Clearly eµ ± (h tm)µ is not true. Hence, Π $D e ± h tm. If KD e → h tm ⇐ Π we are done. If there is some proof tree T : ▶▶D e → h tm ⇐ Π, the inference rule applied at the root must be either PF or AC (DFI cannot be used with the trivial c-interpretation clD(∅)). In any case, T is not easy.

Let ϕ be a c-fact of the form f tn → t ⇐ Π. We prove first the ”if” part. Taking into account that Ti : f ▶▶D ti → ti ⇐ Π are easy proof trees for all 1 ≤ i ≤ n by the Approximation Property (from the definition of the approximation ordering, ti ± ti always holds for all ti ∈ P at⊥(C) and there- fore Π |=D ti ± ti also holds for all 1 ≤ i ≤ n), we can also suppose that t /= ⊥ (the case f ▶▶D f tn → ⊥ ⇐ Π is trivial by TI) and build directly the deduction DFI(f tn → t ⇐ Π, [T1,... , Tn]) using the initial hypothesis (f tn → t ⇐ Π) ∈ f. The ”only if” part. First, if we suppose that t = ⊥ or SolD(Π) = ∅, directly (f tn → t ⇐ Π) ∈ f by definition of c-interpretation. Otherwise, by initial hypothesis T : f ▶▶D f tn → t ⇐ Π must have the
form T = DFI(f tn → t ⇐ Π, [T1,... , Tn]), where Ti : f ▶▶D ti → t' ⇐ Π
(1 ≤ i ≤ n) are easy proof trees such that (f t'n  → t ⇐ Π) ∈ f with

t' ,... , t'	∈ P at⊥(C).  In this setting, we obtain Π |=D t'
± ti for all

1	n	i

1 ≤ i ≤ n using the Approximation Property. It follows that (f t'n → t ⇐
Π)  D (f tn → t ⇐ Π) and consequently (f tn → t ⇐ Π) ∈ f because f
is closed under entailment by definition of c-interpretation.
The ”only if” part. By initial hypothesis, a proof tree T for f ▶▶D p tn →
! t ⇐ Π must have the form T = AC(p tn →! t ⇐ Π, [T1,... , Tn]), where
Π |=D p t'n →! t for some t' ,... , t' ∈ P at⊥(C) and Ti : f ▶▶D ti → t' ⇐ Π
1	n	i
(1 ≤ i ≤ n) are easy proof trees. Moreover, Π |=D ti ± t' (1 ≤ i ≤ n) follows using the Approximation Property, and then Π |=D p tn →! t. Now, the ”if” part. Since Π |=D p tn →! t by initial hypothesis and Ti : ▶▶D ti → ti ⇐ Π are easy proof trees for all 1 ≤ i ≤ n using the Approximation Property, we can build a proof tree T  =def  AC(p tn  →! t  ⇐  Π, [T1,... , Tn]) for


f ▶▶D p tn →! t ⇐ Π.
Assume ϕ D ϕ' and a substitution σ which relates ϕ and ϕ' as ex- pected by the entailment relation (see definition 3.3). We can also assume SolD(Π') /= ∅, otherwise T ' : f ▶▶D ϕ' with an easy proof tree T ' =def
TI(ϕ', [ ]) and | T |≥ 0 = | T ' |. Let T be a given proof tree for f ▶▶D ϕ.
Reasoning by induction on  T  we prove the existence of a proof tree T ' for
f ▶▶D ϕ' such that | T |≥ | T ' |. We distinguish various possible cases:

T is an easy proof tree and ϕ = e → t ⇐ Π. This covers the cases where T has some of the forms TI(ϕ, [ ]), RR(ϕ, [ ]), SP(ϕ, [ ]) or DC(ϕ, [ ]). Since T is easy, DFI is not used. Therefore, T : ▶▶D e → t ⇐ Π. By the Approximation Property, Π |=D e ± t. This implies Πσ |=D eσ ± tσ. Since ϕ  D ϕ', we know that ϕ' = e' → t' ⇐ Π' with Π' |=D Πσ, Π' |=D e' ± eσ and Π' |=D tσ ± t'. We can conclude Π' |=D e' ± t'. By the
Approximation Property again, there is some easy T ' : ▶▶D e' → t' ⇐ Π',
and of course, T ' : f ▶▶D e' → t' ⇐ Π'. Since T and T ' are both easy,
| T |= 0 ≥ 0 =| T ' |.

T = DC(h em → h tm ⇐ Π, [T1,... , Tm]). In this case, we know ϕ = h em → h tm ⇐ Π with Ti : f ▶▶D ei → ti ⇐ Π,  Ti  <  T  (1 ≤ i ≤ m) and ϕ' = e' → t' ⇐ Π' with Π' |=D Πσ, Π' |=D e' ± (h em)σ, Π' |=D (h tm)σ ± t'. We can assume that T is not easy; otherwise we could reason as in the previous case. Since T is not easy, h em is not a pat-

tern.  Then it must be the case that e' = h e'
with Π' |=D e'
± eiσ

for all 1 ≤ i ≤ m (otherwise, any total µ ∈ SolD(Π') would be such that e'µ ± (h em)σµ is not true).  Moreover, Π' |=D (h tm)σ ± t' and

SolD(Π') /= ∅ leave only two possible cases for t'. First, t' = h t'
with

Π' |=D tiσ ± t'
for all 1 ≤ i ≤ m. In this case, for each 1 ≤ i ≤ m

we have (ei → ti ⇐ Π)  D (e'
→ t'
⇐ Π') because Π' |=D Πσ,

Π' |=D e' ± eiσ, Π' |=D tiσ ± t'. By induction hypothesis, we can as-
sume proof trees T ' : f ▶▶D e' → t' ⇐ Π' with | Ti |≥ | T ' | (1 ≤ i ≤ m).
i	i	i	i
Therefore, T ' =def DC(h e'm  → h t'm  ⇐ Π', [T ',...,T ' ]) verifies that

'			'	Σm 1
m Σm	'

T : f ▶▶D h e'm → h t'm ⇐ Π and | T | =	i=1 | Ti | ≥	i=1 | Ti | =
| T ' |.  Second, if t' = X ∈ V with Π' |=D (h tm)σ ± X.  In this case,
for each 1 ≤ i ≤ m we have (ei → ti ⇐ Π)  D (e' → tiσ ⇐ Π')
because Π' |=D Πσ, Π' |=D e' ± eiσ, Π' |=D tiσ ± tiσ. By induction

hypothesis, we can assume proof trees T '
: f ▶▶D e'
→ tiσ ⇐ Π' with

| Ti |≥ | T ' | (1 ≤ i ≤ m).  Since Π' |=D (h tm)σ ± X, we can build
the proof tree T ' =def IR(h e'm → X ⇐ Π', [T ',... ,T ' ]), which verifies
1	m

T ' : f ▶▶D h e'm → X ⇐ Π' and | T | = Σm
| Ti | ≥ Σm

| T ' | = | T ' |.

T = IR(h em → X ⇐ Π, [T1,... , Tm]). In this case, we know ϕ = h em →
X ⇐ Π with h em a rigid and passive expression but not a pattern, Π |=D h tm ± X (and hence Πσ |=D (h tm)σ ± Xσ), Ti : f ▶▶D ei → ti ⇐ Π,  Ti  <  T  (1 ≤ i ≤ m), and ϕ' = e' → t' ⇐ Π' with Π' |=D Πσ (and hence Π' |=D (h tm)σ ± Xσ), Π' |=D e' ± (h em)σ, Π' |=D Xσ ± t' (and hence also Π' |=D (h tm)σ ± t'). Now we can reason similarly to the previous case.

T = DFI(f enak → t ⇐ Π, [T1,... , Tn, Ts]).  Assume k > 0 (the case k = 0 is analogous and easier). In this case, we know ϕ = f enak → t ⇐ Π with t /= ⊥, and there are some c-fact (f tn → s ⇐ Π) ∈ f and some partial pattern s /= ⊥ such that Ti : f ▶▶D ei → ti ⇐ Π, Ti  < T  (1 ≤ i ≤ n) and Ts : f ▶▶D s ak → t ⇐ Π,  Ts  <  T  . Since ϕ  D ϕ', we know ϕ' = e' → t' ⇐ Π' with Π' |=D Πσ, Π' |=D e' ± (f enak)σ, Π' |=D tσ ± t' and t' /= ⊥ (if t' = ⊥ then T ' consists of just one TI step and | T | > 0 = | T ' |). From Π' |=D e' ± (f enak)σ, it follows that

e' = f e'na'k with Π' |=D e'
± eiσ for all 1 ≤ i ≤ n and Π' |=D a'
± ajσ

for all 1 ≤ j ≤ k (otherwise, for any total µ ∈ SolD(Π') we would have
e'µ ± (f enak)σµ not true). Using the former conditions, it is easy to
check that (ei → ti ⇐ Π)   D  (e' → tiσ ⇐ Π') for all 1 ≤ i ≤ n
and (s ak → t ⇐ Π)  D (sσ a'k  → t' ⇐ Π'). By induction hypothe-
sis (applied to Ti, Ts), we get T ' : f ▶▶D e' → tiσ ⇐ Π', | Ti |≥ | T ' |
i  	i	i

(1 ≤ i ≤ n) and T '
: f ▶▶D sσ a'k → t' ⇐ Π', | Ts |≥ | T '
|.  Since

(f tn → s ⇐ Π) ∈ f and (f tn → s ⇐ Π)  D (f tnσ → sσ ⇐ Π'), it implies that (f tnσ → sσ ⇐ Π') ∈ f by definition of c-interpretation, with sσ /= ⊥ a partial pattern (if sσ = ⊥ then the pattern s must be
a variable and the deduction is not possible in the semantic calculus be- cause f ▶▶D s ak → t ⇐ Π with k > 0 and t /= ⊥). We can build the
proof tree T ' =def DFI(f e'na'k → t' ⇐ Π', [T ',... ,T ' ,T ']), which verifies
1	n	s
T ' : Σf ▶▶D f e'na'k → t' ⇐ Π' and | T | = 1 +	i=1 | Ti | + | Ts |≥ 
1 +	m | T ' | + | T ' | = | T ' |.
i=1	i	s

T = PF(p en → t ⇐ Π, [T1,... , Tn]). In this case, we know ϕ = p en → t ⇐ Π and Ti : f ▶▶D ei → ti ⇐ Π, Ti  < T  (1 ≤ i ≤ n) with Π |=D p tn → t. Since ϕ  D ϕ' and SolD(Π') /= ∅, it must be the case
that ϕ' = p e'n  → t' ⇐ Π' with Π' |=D Πσ, Π' |=D e' ± eiσ for all
1 ≤ i ≤ n, Π' |=D tσ ± t'. From the previous conditions, we can de- duce Πσ |=D (p tn)σ → tσ and hence also Π' |=D (p tn)σ → t'. We also


observe that (ei → ti ⇐ Π)  D (e' → tiσ ⇐ Π') (1 ≤ i ≤ n).  By
induction hypothesis, we obtain proof trees T ' : f ▶▶D e' → tiσ ⇐ Π',
i	i
| Ti |≥ | T ' | (1 ≤ i ≤ n). Since Π' |=D (p tn)σ → t', we can build the proof
tree T ' =def PF(p e'n → t' ⇐ Π', [T ',... ,T ' ]), which verifies T ' : f ▶▶D

p e'n → t'
⇐ Π'
with | T | = 1 +
1	n
m  | Ti | ≥ 1 +	m
| T '
| = | T ' |.

i=1	i=1	i

T = AC(p en →! t ⇐ Π, [T1,... , Tn]). Similar to the case of the rule PF.
 
Proof of Proposition 3.14
Proof. We prove only the properties of the strong interpretation transformer STP; the corresponding properties of W TP can be proved similarly. In the rest of the proof we use the notation preSTP(f) for the set of c-facts.
{(f tn)θ → t ⇐ Π | (f tn → r ⇐ P  ∆) ∈ У, θ ∈ Sub⊥(C), Π ⊆
PCon⊥(Ð), t ∈ P at⊥(C), f ▶▶D (P  ∆)θ ⇐ Π, f ▶▶D rθ → t ⇐ Π}
First we note that STP : ID → ID is a well defined mapping, because for each f ∈ ID the image STP(f) is defined as clD(preSTP(f)), and hence a c-interpretation.
A careful inspection of Definition 3.9 reveals that f |=s  У iff preSTP(f) ⊆
On the other hand, preSTP(f) ⊆ f iff STP(f) = clD(preSTP(f)) ⊆ f,

because f is closed under clD. Therefore, f |=s
strong models of У are the pre-fixpoints of STP.
У iff STP(f) ⊆ f, i.e., the

Finally, the fact that STP is continuous follows from the two items below:
STP is monotonic:

Assume f, J ∈ ID such that f ⊆ J . Then, preSTP(f) ⊆ preSTP(J ) is an easy consequence of the Extension Property from Lemma 3.6, and we can conclude STP(f) ⊆ STP(J ).

STP preserves the lubs of non-empty directed sets:
Assuming a non-empty directed set I ⊆ ID, we must prove STP(H I) = H STP(I). The inclusion STP(H I) ⊇ H STP(I) holds because STP is monotonic. Since I is not empty, the opposite inclusion can be rewrit- ten as STP(  I) ⊆  STP(I), which is obviously a consequence of -
 	 
preSTP(	I) ⊆	STP(I). In order to prove this last in clusion, assume
an arbitrarily fixed c-fact ϕ belonging to the set preSTP(	I). Because of
the way this set is defined, ϕ becomes its member due to the existence of finitely many other c-statements ϕi such that	I ▶▶D ϕi. Therefore, by


the Compactness Property in Lemma 3.6, there must be some finite set of c-facts f0 ⊆ I such that ϕ ∈ preSTP(clD(f0)). Since I is directed, there must be also some f ∈ I such that f0 ⊆ f. Since f is closed under clD, we obtain clD(f0) ⊆ f, and ther efore (using the Extension Property
from Lemma 3.6) ϕ ∈ preSTP(f) ⊆	STP(I).


Proofs of the main results from section 4
Proof of Lemma 4.2
Proof. This lemma is proved in a similar way to the proof of 3.6. In (1) the property holds trivially because we only use almost one program rule instance of У in each step of the derivation. (2) is obvious using the fact that
У ⊆ У' if some program rule instance of У is necessary in the derivation.
and (4) are proved in the same way as the analogous properties of the
semantic calculus. Finally, in (5) we can use again induction on  T  to prove the existence of the proof tree T ' for У ▶D ϕ' such that | T |≥ | T ' |. Now, the only different case is in the application of the rule DFP. If T = DFP(f enak → t ⇐ Π, [T1,... , Tn, T, Tr, Ts]) and k > 0 (the case k = 0 is analogous and easier), we know ϕ = f enak → t ⇐ Π with t /= ⊥, and there are some program rule instance (f tn → r ⇐ P  ∆) ∈ [У]⊥ and some partial pattern s /= ⊥ such that Ti : У ▶D ei → ti ⇐ Π,  Ti  <  T  (1 ≤ i ≤ n), T : У ▶D P  ∆ ⇐ Π,  T  <  T  , Tr : У ▶D r → s ⇐ Π,

 Tr  <  we know Π' |=D t
nce ϕ  D ϕ',
± (f enak)σ, just one TI

step and | T | > 0 = | T ' |). From Π' |=D e' ± (f enak)σ, it follows that

e' = f e'na'k with Π' |=D e'
± eiσ for all 1 ≤ i ≤ n and Π' |=D a'
± ajσ

for all 1 ≤ j ≤ k (otherwise, for any total µ ∈ SolD(Π') we would have
e'µ ± (f enak)σµ not true). Using the former conditions, it is easy to check
that (ei → ti ⇐ Π)  D (e' → tiσ ⇐ Π') for all 1 ≤ i ≤ n, (P  ∆ ⇐
Π)  D ((P  ∆)σ ⇐ Π'), (r → s ⇐ Π)  D (rσ → sσ ⇐ Π') and (s ak → t ⇐ Π)  D (sσ a'k → t' ⇐ Π'). By induction hypothesis (applied
to Ti, T, Tr, Ts), we get T ' : У ▶D e' → tiσ ⇐ Π', | Ti |≥ | T ' | (1 ≤ i ≤ n),
i	 i	 	i
T ' : У ▶D (P  ∆)σ ⇐ Π', | T |≥ | T ' |, T ' : У ▶D rσ → sσ ⇐ Π',
| Tr |≥ | T ' |, and T ' : У ▶D sσ a'k  → t' ⇐ Π', | Ts |≥ | T ' |.  Since
(f tn → r ⇐ P  ∆)σ ∈ [У]⊥ and sσ /= ⊥ is a partial pattern (if sσ = ⊥
then the pattern s must be a variable and the deduction is not possible in the constrained rewriting calculus because У ▶D s ak → t ⇐ Π with k > 0 and t /= ⊥), we can build the proof tree T ' =def DFP(f e'na'k  → t'  ⇐

Π', [T ',... ,T ' , T ',T ',T ']), which verifies T ' : У ▶D f e'na'k → t' ⇐ Π' and

1	Σn  m	r	s
Σm	'

| T | = 1 +	i=1 | Ti | + | T | + | Tr | + | Ts |≥ 1 +	i=1 | Ti | + | T ' |
+ | T ' | + | T ' | = | T ' |.	 
r	s

Proof of Theorem 4.3
Proof. The stated result follows from the following three implications:
У ▶D ϕ ⇒ У |=s ϕ:
Assume T : У ▶D ϕ. Consider any strong model f |=s У. We prove f ▶▶D ϕ reasoning by induction on  T  . The base cases correspond to T = RL(ϕ, [ ]), where RL ∈ {TI, RR, SP}. These are trivial since the same tree T verifies T : f ▶▶D ϕ.
The inductive cases corresponding to T = RL(ϕ, [T1,... , Tn]), where
RL ∈ {DC, IR, PF, AC}, are also straightforward, simply noticing that the same rule RL applies in CRWL(Ð), and using the induction hypothe- sis for T1,... , Tn.
The interesting case is that of the rule DFP applied at the root step. We consider the first variant of the rule DFP (the reasoning for the second one is similar).
The tree T would have the form
T = DFP(f en → t ⇐ Π, [T1,... , Tn, T, Tr])
with Ti : У ▶D ei → ti ⇐ Π, T : У ▶D P  ∆ ⇐ Π, Tr : У ▶D r →
t ⇐ Π, where f ∈ DFn, (f tn → r ⇐ P  ∆) ∈ [У]⊥.
By the induction hypothesis applied to T, Tr, there must exist T ',T ' such that T ' : f ▶▶D P ∆ ⇐ Π and T ' : f ▶▶D r → t ⇐ Π. This, together with the fact that f is a strong model of У, ensures that (f tn → t ⇐ Π) ∈ f. Combining this with the rest of the induction hypothesis which ensures the existence of trees Ti : f ▶▶D ei → ti ⇐ Π, for i = 1 ... n, we
can build the tree T ' = DFI(f en → t ⇐ Π, [T ',...,T ' , T ',T ']), which

proves f ▶▶D f en → t.
1	n	r

У |=s ϕ ⇒ £P ▶▶D ϕ:
This holds simply because £P |=s У, as proved in Theorem 3.15.
£P ▶▶D ϕ ⇒ У ▶D ϕ:
k
A ssume £P ▶▶D ϕ, where £P =	k∈N STP ↑ (⊥⊥). Due to the fact that
k∈N STP ↑k (⊥⊥) ▶▶D ϕ must be proved by a finite proof tree, and taking into account that STP ↑k (⊥⊥) grows with k, it is easy to see that there must exist k ∈ N such that STP ↑k (⊥⊥) ▶▶D ϕ. Therefore, it suffices to


prove the following:
For all k ∈ N, STP ↑k (⊥⊥) ▶▶D ϕ ⇒ У ▶D ϕ
We prove that by induction on k.

k = 0 :
Assume STP ↑0 (⊥⊥) ▶▶D ϕ. We prove that У ▶D ϕ by induction on the structure of a tree T with T : STP ↑0 (⊥⊥) ▶▶D ϕ. We distinguish cases according to the rule at the root of T :
TI, RR or SP: trivial, since the same rule in CRWL(Ð) proves У ▶D ϕ. DC, IR, PF or AC: straightforward using the induction hypothesis, since the same rule applies also in CRWL(Ð).
DFI: This rule is in fact not applicable.  Otherwise, the proof tree
T would have the form T = DFI(f en → t ⇐ Π, [T1,... , Tn]), with Ti : У ▶D ei → ti ⇐ Π, and where f ∈ DFn, (f tn → t ⇐ Π) ∈ STP ↑0 (⊥⊥). But STP ↑0 (⊥⊥) = ⊥⊥, and therefore (f tn → t ⇐ Π) is a trivial fact, which implies that (f en → t ⇐ Π) is also trivial, but then the rule TI could have been applied.
A similar reasoning holds for the second case of the DFI rule.
k '→ k + 1:
Assume STP ↑(k+1) (⊥⊥) ▶▶D ϕ. The induction hypothesis says that STP ↑k (⊥⊥) ▶▶D ψ ⇒ У ▶D ψ, ∀ψ. As before, we prove У ▶D ϕ by induction on the structure of the proof tree for STP ↑(k+1) (⊥⊥) ▶▶D ϕ. Also as before, the interesting case is when the root step consists of an ap- plication of DFI, that is, when T = DFI(f en → t ⇐ Π, [T1,... , Tn]), with Ti : У ▶D ei → ti ⇐ Π, and f ∈ DFn, (f tn → t ⇐ Π) ∈
STP ↑k+1 (⊥⊥).

Now, since (f tn → t ⇐ Π) ∈ STP ↑(k+1) (⊥⊥), it follows, from the definition of STP ↑(k+1) (⊥⊥), that there must exist a rule instance (f tn → r ⇐ P  ∆) ∈ [У]⊥ such that r → t ⇐ Π ∈ STP ↑k (⊥⊥) and P ∆ ⇐ Π ∈ STP ↑k (⊥⊥). Then, by the induction (on k) hypothesis, we have У ▶D r → t ⇐ Π and У ▶D P ∆ ⇐ Π. This, together with the (proof tree) induction hypothesis У ▶D ei → ti ⇐ Π, for i = 1,..., n, allows to build, using DFP, a derivation in CRWL(Ð) for У ▶D fen → t ⇐ Π.
A similar reasoning holds for the second case of the DFI rule.
 
