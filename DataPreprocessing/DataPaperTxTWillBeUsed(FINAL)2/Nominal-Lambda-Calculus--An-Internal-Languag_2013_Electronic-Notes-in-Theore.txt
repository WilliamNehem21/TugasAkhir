Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 298 (2013) 93–117
www.elsevier.com/locate/entcs

Nominal Lambda Calculus: An Internal Language for FM-Cartesian Closed Categories
Roy L. Crole and Frank Nebel
Dept of Computer Science, University of Leicester, University Road, Leicester, LE1 7RH, U.K.

Abstract
Reasoning about atoms (names) is difficult. The last decade has seen the development of numerous novel techniques. For equational reasoning, Clouston and Pitts introduced Nominal Equational Logic (NEL), which provides judgements of equality and freshness of atoms. Just as Equational Logic (EL) can be enriched with function types to yield the lambda-calculus (LC), we introduce NLC by enriching NEL with
(atom-dependent) function types and abstraction types. We establish meta-theoretic properties of NLC; define FM-cartesian closed categories, hence a categorical semantics for NLC; and prove soundness & completeness by way of NLC-classifying categories. A corollary of these results is that NLC is an internal language for FM-cccs. A key feature of NLC is that it provides a novel way of encoding freshness via dependent types, and a new vehicle for studying the interaction of freshness and higher order types.
Keywords: category theory, dependent types, FM-sets, internal language, nominal logic, semantics, type theory


Introduction
(NEL) was introduced by Clouston and Pitts in [8] (closely related to Nominal Algebra introduced by Gabbay and Mathijssen [16]). Space forces us to assume familiarity with NEL, but here is a quick overview: NEL extends equational logic EL [10,24] (where types denote ZF-sets). NEL variables are thought of as ele- ments of FM-sets (roughly speaking, sets whose elements have a finite support of atoms/(names) in the sense of Gabbay and Pitts [14] and for which one can make assertions about the freshness of atoms). The motivation for NEL is to provide a system for formal equational reasoning combined with reasoning about the fresh- ness of atoms—the latter an important topic of study in Programming Semantics. To this end one seeks a theory with a sound and complete semantics. The theory must necessarily capture permutation actions, finite support, and freshness. As such, one might expect to be able to make judgements a # M , asserting atom a is

1 Email: r.crole@mcs.le.ac.uk

1571-0661 © 2013 Elsevier B.V. Open access under CC BY-NC-ND license.
http://dx.doi.org/10.1016/j.entcs.2013.09.009

fresh for M , as well as M = Mj. Further, we need to be able to assert hypotheses a # x about variables x that may occur (freely) in M . Indeed in NEL one sees a1 # x1 : s1, ..., an # xn : sn ▶# a # M : s capturing the intuition that if sets of atoms ai are fresh for (the interpretation of) the xi, then a is fresh for M . One might also work instead with judgements a1 # x1 : s1, ..., an # xn : sn ▶E M : s and then codify a # M by way of an equation, since freshness can be defined equationally [6] (under suitable conditions). This is the approach we take.
Clouston has shown in [5,7] that the category FMSet provides a sound and complete semantics for NEL. Further he defines the notion of an FM-category, axiomatising the underlying structure of FMSet , and shows that such categories yield a sound semantics. He shows that a NEL theory has a classifying FM-category in which there is a generic model [10,31]—hence his semantics is also complete. Indeed, Clouston shows that there is a correspondence between NEL theories and FM-categories establishing that NEL is an internal language for FM-categories. Lambek [21] showed that theories in the λ-calculus correspond to cartesian closed categories (a proof using functional completeness, with Scott, appears in [22]; see also [10]).
A natural question to ask is whether there is a notion of nominal λ-calculus (NLC) that corresponds to some form of “cartesian closed FM-category”. More- over, if there is, we can test the robustness of both NEL, and the methodology of categorical logical relations, by attempting to show that NLC is conservative over NEL using gluing. To do this we need to develop NLC and a suitable categorical correspondence, which we do in this paper.
Before we begin the task at hand, we justify our overall approach. At the conceptual level, this paper concerns itself with the fascinating notion of corre- spondences between category theory and type theory. This arises from Lawvere’s seminal work [23]. There are two approaches that one could take in formulating such correspondences. (i) is to demonstrate that models of a theory Th in a cate- gory C (and maps between models), Mod (Th, C), correspond to structure preserving functors (and natural transformations between functors), SPF (Cl (Th), C). (ii) is to show the existence of a monad TTh for which Mod (Th, C) corresponds to the (Eilenberg-Moore) algebras of TTh . Both approaches have their merits. For some deep insights into the heart of the matter in the case of theories in equational logic consult Hyland and Power’s overview [19]. An elegant approach via monads, pro- viding a very general framework, is established in the work of Berger, M`elli´es and Weber [2] and M`elli´es [26]. However, for computer science and (foundations of) program semantics, where one may well be seeking a rigorously specified syntactic type theory capable of being formalised, approach (i) seems to be the path to follow (please see Section 7 for additional commentary). In particular, we want to estab- lish that any such theory is indeed the internal language of a suitable category with structure, with the usual adjunction Cl E Th.
Remark 1.1 The category central to this work is FMSet [5,15]. The category of nominal sets FMNom is relevant too: for a very clear introduction see [30]. While the properties of FMSet are less well known than FMNom, both are toposes f .

As such each is equipped with a Higher Order Logic internal language ThT . Thus one might ask whether one could automatically capture the notion of FM-ccc by internalisation of cartesian closure (and freshness) in f ; and indeed “extract” NLC from the HOL ThT , perhaps by extending ThT with additional axioms. It is not clear to us that this can be done, or, if it can, whether it it can circumvent the detail in this paper bearing in mind that our aim from the “computer science” perspective is to produce a fully formalised type theory. See Section 7 for more discussion.
We build directly on [7], taking approach (i). We have tried to keep this paper as self-contained as possible, but cannot include all of the definitions and lemmas for lack of space. In Section 2 we specify the types and terms of NLC without abstraction. We define permutation actions, capture avoiding substitution, and α- equivalence. We prove results about the terms which we will use when proving soundness and completeness. In Section 3 we specify the NLC type system and define NLC equational theories, without abstraction. We again prove key results for soundness and completeness. In Section 4 we introduce FM-cartesian closed categories, showing they soundly model NLC without abstraction. In Section 5 we add abstraction and concretion to NLC and show that our semantics is sound and complete for FM-cccs, which are FM-cccs with additional structure that models abstraction and concretion. In Section 6 we show that FM-cccs are syntax free presentations of NLC theories. In Section 7 we discuss applications and further work. Here are the main contributions:
Higher order functions that naturally extend NEL are partial in the sense that their arguments must satisfy freshness conditions. We believe that this is the first paper to posit a move to a “types dependent on atoms” type theory in order to capture, in a novel type system, this partiality of higher order functions (see page 4 for details). NLC allows us to examine the combination of the freshness relation and higher types in a new light.
Dependent types enable us to to specify name abstraction and concretion. The operation of concretion is inherently partial, and indeed cannot be captured as a NEL theory—see Clouston [4]. However NLC dependent types do provide a mechanizm to capture this partiality.
In [7] the type system for terms is separate from the system for freshness as- sertions, (a two part type system). Moreover typing judgements predicated on freshness assertions are not first class citizens (but simply reflexive equations). We introduce rules for a single first class type system. This is not only necessitated by the dependent types, but significantly simplifies and unifies the judgements forms in [7].
A clean formulation of a categorical semantics of NLC. The semantics is consid- erably complicated by both type dependency on atoms, and the encapsulation of freshness judgements by equational axioms. Our single first class type system simplifies our soundness proof from what it would otherwise have been.
A simplification of Clouston’s meta-theory [7]. We show that all the key properties of (syntactic) permutation actions we require can be defined cleanly on raw terms,

prior to type-checking. This material is mainly in Section 2.
A detailed proof of an “approach (i)” category theory type theory correspon- dence, yielding NLC theories as the internal language of FM-cccs, and hence completeness. We pay very careful attention to details that are significant for implementations (see for example the proof on page 11 of Lemma 3.3).
We will use the following notation: Let A be the set of atoms (names). We write a or similar for typical finite subsets {a1,..., ak} of A. We write π or similar for any permutation on A with finite domain. Perm denotes the set of such permutations (equivalently those generated by transpositions (a b)). The composition of π and πj, with πj acting first, is denoted by π ◦ πj or ππj. If X = (X, ·) is an FM-set, and x ∈ X, we write supp(x) for the support of x, and a # x to denote that each atom in a is not in supp(x).
The Meta-Theory of NLC Terms without Abstraction
Remark 2.1 Until Section 5 we work with a subset of NLC. This will allow us to fully motivate the use of a form of dependent typing in order to formulate our extension of NEL with higher order functions. Abstraction and concretion is omitted until later in the paper.
In NEL one works with a nominal set of types 2 . In NLC we work with a nominal set of ground types, and generate the function types. NLC extends NEL terms with function abstractions and applications. An abstraction takes the form λax : s.M and we explain the intended semantic interpretation. In NEL we may have a # x : s ▶E M : sj. If we want to capture the “mapping” x '→ M as an abstraction, we could consider λ x : s.M . However, if we apply λ x : s.M to a term N : s we also need to ensure that a # N . We might codify the set a in the abstraction λax : s.M . So far so good. But what about types? In NEL, the FM-set semantics of a # x : s

is specified by requiring that [x]] ∈ [[s]]#a d=ef
{e ∈ [[s]] | a # e}. So one might

wonder if sa could be be a suitable type for the source of our abstraction, with a
compositional semantics [sa]] d=ef [[s]]#a. We can then consider the type sa ⇒ sj for our abstraction, hoping that if our semantics is defined in a compositional way, it will have all of the relevant equivariance and categorical properties to yield a sound and complete semantics. This abstraction typing is deceptively simple: the type and equation system that results is intuitive, but quite complex to manipulate since function types now depend on atoms.
NLC-Signatures, Types, and Raw Terms. We start with an analogue of the notion of a signature for λ-calculus. A NLC-signature Sg is specified by
Gnd Sg , a nominal set of ground types. The set of types TypeSg is then generated by the BNF grammar s ::= γ | sa ⇒ s where γ is any ground type. Since each type s is a finite tree and Gnd Sg is a nominal set, each s is finitely

2 In [7] “types” are called sorts. We use the word type since it better matches general usage in computer science, and categorical type theory

supported with the permutation action
π · γ d=ef π ·Gnd	γ	π · (sa ⇒ sj) d=ef (π · s)π·a ⇒ (π · sj) and hence TypeSg is a nominal set of types.
A nominal set of (higher order function) constant symbols FunSg .
An equivariant typing function FunSg → TypeSg , which assigns to each con- stant symbol c a type; we refer to a typing c : s.
Fixing a set Var d=ef {V1, V2, V3,.. .} of (ordered) variables, the raw NLC-terms are specified by M := πx | c | λax : s.M | M M where πx is a suspension [8,7] of any variable x ∈ Var . We refer to the set of raw terms for signature Sg by TermSg . Variables may be free or bound (where all occurrences of x in any “subterm” λax : s.M are bound).
Permutation Actions for Raw Terms. Recall [8,16] the two standard permu- tation actions on Perm, namely conjugation (which is finitely supported) and left multiplication (which is not). Clouston & Pitts and Gabbay & Mathijssen define two permutation actions, called meta-level π · M and object-level π ∗ M [8,7], which are syntactic analogues of the actions on Perm. In categorical type theory one always works with terms in context. As such, a term M with a free variable x is always regarded as a “function” x '→ M . The permutation action on functions found in nominal and FM-sets is a (form of) conjugation action and the syntac- tic analogue is π · M . However it is useful to work also with a simple action in which π acts on M simply by acting recursively over the structure of a term: eg π ∗ (τx)(τjy)= (π ∗ τx)(π ∗ τ jy)= (πτx)(πτjy).
We define such actions for NLC. To do so, consider the recursive definition of mappings (π, M ) '→ π ∗ M and (π, M ) '→ π · M in Table 1. Note that in order to define the object-level permutation we first define a basic form of substitution M [π—1x/x], on raw terms M . We call this a suspension-substitution. Informally, free occurrences of x in M are replaced by π—1x. Formally, the recursive definition is the expected one, where on suspensions we define (πjy)[π—1x/x] d=ef πjy if x /= y and (πjx)[π—1x/x] d=ef (πjπ—1)x.
To show, in Proposition 2.3, that the mappings in Table 1 are permutation actions, we need Lemma 2.2 which is proved by induction over M .
Lemma 2.2 (π ∗ M )[π—1x/x]= π ∗ (M [π—1x/x]) for any raw M, where [π—1x/x]
indicates that x is replaced by π—1x.
Proposition 2.3 (Permutation Action Definitions)
The mapping (π, M ) '→ π · M is a permutation action; we call it the meta-level permutation action. It is ﬁnitely supported, so the set TermSg of raw NLC- terms is a nominal set. The ﬁnite support of a raw term is speciﬁed recursively

where supp(πx) d=ef
supp(π), supp(λax : s.M ) d=ef
a ∪ supp(s) ∪ supp(M ) and

supp(M N ) d=ef supp(M ) ∪ supp(M ); and constants are ﬁnitely supported by deﬁ-





π · πjx d=ef (ππjπ—1)x
π · c d=ef π ·Fun	c
π · (λax : s.M ) d=ef

λπ·ax : π · s.(π · M )
π · (M N ) d=ef (π · M ) (π · N )
Meta-Level
π ∗ πjx d=ef (ππj)x
π ∗ c d=ef π ·Fun	c
π ∗ (λax : s.M ) d=ef

λπ·ax : π · s.(π ∗ (M [π—1x/x]))
π ∗ (MN ) d=ef (π ∗ M )(π ∗ N )
Object-Level

Table 1 Permutation Actions for NLC

nition.
The mapping (π, M ) '→ π ∗ M is a permutation action; we call it the object-level
permutation action.
Capture Avoiding Substitution and α-Equivalence. We require simultaneous capture-avoiding substitution of raw terms. This will be crucial for defining compo- sition of morphisms in a classifying category–see Proposition 5.1. Since the high level ideas of this paper can be read without recourse to complete detail, we just outline our notation and the key ideas (our approach simplifies Clouston’s [7]). Substitut- ing N1, . . . , Nn for free occurrences of the distinct variables x1, . . . , xn in the raw term M yields another raw term, which we denote by M {N1,..., Nn/x1,..., xn} or by M {Ni/xi}. The “usual” recursive definition for “ordinary” λ-terms (see, for example, [18]) carries over to NLC apart from the base cases on suspensions where we define
(πy){N1,..., Nn/x1,..., xn} =def πy	(∀i)(xi /= y)
(πy){N1,..., Nn/x1,..., xn} =def π ∗ Ni0	(∃i)(xi = y) with xi0 = y
Note the critical use of the object-level permutation action. Note also the crucial connection—used in many proofs—between suspension-substitutions and simulta- neous substitution, which is easily proved by induction:
Lemma 2.4 For any term M we have M [π—1x/x]= M {π—1x/x}.
So far we have used structural equality on terms M = N . Since we wish to work with capture avoiding substitution (to construct our classifying category) which makes use of variable renaming, we have to replace = with α-equivalence ∼α. We use two definitions of α-equivalence. One is founded on capture avoiding substitution; the other on variable swapping. Each definition generates the same relation ∼α⊂ TermSg × TermSg (see [11]).
The first definition [18] takes ∼α to be the smallest equivalence relation closed under the congruence rules (for application and abstraction terms) and the axiom λax : s.M ∼α λaxj : s.M {xj/x} where xj /∈ var (M ). The second definition is given



M1 ∼α Mj	M2 ∼α Mj

πx ∼α πx
(x ∈ Var	π ∈ Perm)
	1	2 
M1M2 ∼α Mj Mj

1	2
 (z x) • M1 ∼α (z y) • M2	
(z /∈ var (M ) ∪ var (M ))



λax : s. M1 ∼α
1	2
λ y : s. M1

Table 2
Alpha Equivalence by Variable Swapping

in terms of variable swapping [11,14]. If x, y ∈ Var then we define (x y) • M to be M in which any occurrence of x is swapped with y (and vice-versa). Then we can define ∼α by the rules in Table 2. It can easily be shown that ∼α is equivariant for the permutation actions, that is M ∼α N implies π · M ∼α π · N and respectively for the object level permutation action. From this well-defined permutation actions on α-equivalence classes of terms are induced by way of the following definitions π · [M ]α d=ef [π · M ]α and π ∗ [M ]α d=ef [π ∗ M ]α and moreover we can prove
Lemma 2.5 Capture avoiding substitution lifts to the set of α-equivalence classes
of terms, TermSg ,∼ , a nominal set under the meta-level permutation action on
α-equivalence classes, with supp([M ]α)= supp(M ).
Remark 2.6 We call [M ]α an expression. Having taken great care in defining expressions [M ]α, we adopt the usual convention of writing just M . However, all our proofs deal correctly with the intricacies that arise from variable re-naming to avoid capture (see for example [28] (page 169) and [25]).
The next propositions are crucial for our main theorems, the first (∗ associates with {/}) by induction on M , the second (∗ distributes over {/}) by direct calcula- tion being a corollary of Proposition 2.8 and Lemma 2.7. The lemma expresses the meta-level action in terms of the object-level action. In fact it is not only used to prove properties of NLC but also, later on, our categorical semantics.
Lemma 2.7 (· in terms of ∗) For any term M and {x1, ..., xn} ⊆ Var with
fv(M ) ⊆ {x1, ..., xn} we have π · M = (π ∗ M ){π—1x1/x1, ..., π—1xn/xn}.
Proof. Although the proof of this lemma is straightforward, since it is quite typical we give full details of the proof by induction on the structure of term M of
(∀π)(∀{x1,..., xn})(fv(M ) ⊆ {x1 ... xn}
=⇒ π · M = (π ∗ M ){π—1x1/x1, ..., π—1xn/xn}
We assume Lemma 2.4 throughout.
SUSP: When M is τxi the result follows immediately by the definition of sub- stitution and the permutation actions. CONST: Follows immediately. APP: Straightforward.

LAM-ABS: Case M is λax : s. Mj where fv (λax : s. Mj) d=ef
fv (Mj) \ {x} ⊆ 

{x1 ... xn}. We examine the case when x is not an xi; if x is an xi the details are

not too dissimilar. So for the induction step fv (Mj) ⊆ {x, x1 ..., xn}.

π · (λax : s.Mj)
d=ef λπ·ax : π · s.π · Mj
= λπ·ax : π · s.(π ∗ Mj){π—1x/x, π—1xi/xi}	(induction)
= λπ·ax : π · s.((π ∗ Mj){π—1x/x}){π—1xi/xi}	(x /= xi)

= λπ·ax : π · s.(π ∗ (Mj{π—1x/x})){π—1xi/xi}	(Lemma 2.2)
= (λπ·ax : π · s.π ∗ (Mj{π—1x/x})){π—1xi/xi}	(x /= xi so no capture)
d=ef (π ∗ (λax : s.Mj)){π—1xi/xi}
2
For expressions [M ]α, distinct variables x1, . . . , xn, and expressions [N1]α, . . . , [Nn]α we have
Proposition 2.8 (π ∗ [M ]α){[NS]α/xi} = π ∗ ([M ]α{[NS]α/xi})
i	i
Proposition 2.9 π · (M {Ni/xi})= (π · M ){(π · Ni)/xi} (Written using the con- vention for α-equivalence classes, generally adopted from now on.)
NLC Typed Expressions and Equational Theories
We define NLC by specifying a type and equation system. The intuitions of NLC and NEL are the same, but technicalities are quite different. In NEL, terms are

typed using environments Γ d=ef
x1 : s1,..., xn : sn, just like ordinary equational

logic. The judgements either take the form Γ ▶ M : s (⬦), or ∇ ▶E M ≈ Mj : s where ∇ = a1 # x1 : s1, ..., an # xn : sn records assumptions about freshness and types. NEL judgements ∇ ▶E M : s are simply sugar for reflexive equations. The type system (⬦) is entirely separate from the freshness system (in two parts)! We found this slightly confusing. Indeed, with NLC we cannot separate the type system in this way, since the types of abstractions depend directly on freshness assertions. Thus the environments used in the type system must encode freshness assertions (and cannot be of the form Γ)! Our typing judgements ∇ ▶E M : s are first class citizens (in a single system). They are not abbreviations for reflexive equations. This is not merely dabbling with unnecessary cosmetic idolatry: it simplifies the presentation of our categorical semantics and is a key contribution.
Recall the formal notion of a freshness environment [7] (included below). We can then define expressions, and equations, in context and finally present the NLC type and equation systems.
A freshness environment, or just environment, is a finite partial function
∇ : Var → Pfin(A) ⊗ TypeSg with finite domain.  By definition it maps each x ∈ dom(∇) to a pair (a, s) where a is a finite set of atoms s ∈ TypeSg and a # s. The set of environments Env Sg is a nominal set under the permutation action (π · ∇)(x) = (π · a, π · s). We often write an environment ∇ as a1 # x1 : s1, ..., an # xn : sn. For ∇, ∇j, we write ∇ ≤ ∇j if dom(∇) ⊆ dom(∇j) and for all x ∈ dom(∇) we have pr1(∇(x)) ⊆ pr1(∇j(x)) and pr2(∇(x)) = pr2(∇j(x)).




(SP)	∇, a # x : s ▶E πx : π · s

(C)	∇ ▶E c : s (c ∈ FunSg and c has Sg typing c : s)


(ABS)


(AP)
∇, a # x : s ▶E M : sj
∇ ▶E λax : s. M : sa ⇒ sj
∇ ▶E F : sa ⇒ sj	∇ ▶E a # A : s

∇ ▶E F A : sj



(	∇#a ▶E M : s
∇ ▶E M : s	j

AE)


(SUB)
∇ ▶E M : s	(a # (∇,M ))	(WEAK)
∇j ▶E ai # Ni : si	∇ ▶E M : sj

∇j ▶E M {N1,..., Nn/x1,..., xn} : sj
∇j ▶E M : s (∇ ≤ ∇ )

In rule (SUB)	∇ d=ef a1 # x1 : s1, ..., an # xn : sn and 1 ≤ i ≤ n
Table 3
NLC Typing Rules for a Given Th

We define an expression-in-context as a judgement of the form ∇ ▶E M : s where ∇ is a freshness environment, M is an α-equivalence class of NLC-terms (an expression) and s is a type.
An equation-in-context is a judgement of the form ∇ ▶E M ≈ Mj : s where
∇ ▶E M : s and ∇ ▶E Mj : s.
A NLC-theory Th is a pair (Sg, Ax ), where Sg is a NLC-signature and Ax is a collection of equations-in-context. We shall use Th to inductively define a subset of expressions-in-context and equations-in-context. Any expression-in-context that has a derivation is a typed expression; and any such equation-in-context is a theorem. The set of typed expressions and theorems of a NLC-theory Th is the least set of judgements containing the axioms of Th and closed under the rules in Table 3 and Table 4. We indicate that any judgement J has a derivation in theory Th by writing Th D J .
Remark 3.1 Justified by [6] we use the following abbreviation: for ∇ ▶ M : s and
a ⊆ A (a # s), we write ∇#b d=ef a1 ∪ b # x1 : s1, ..., an ∪ b # xn : sn and

∇ ▶E a # M : s d=ef ∇#b ▶E M ≈ (a b) ∗ M : s.
In the transposition, a ∈ An is sugar for a tuple of the atoms in the set a and





(REF)
∇ ▶E M : s


∇ ▶E M ≈ M : s	SYM
∇ ▶E M ≈ Mj : s

∇ ▶E Mj ≈ M : s



(TRANS)
∇ ▶E M ≈ Mj : s	∇ ▶E Mj ≈ Mjj : s

∇ ▶E M ≈ Mjj : s

(	∇ ▶E M ≈ Mj : s	j

WEAK)
∇j ▶E M ≈ Mj : s (∇ ≤ ∇ )

(	∇#a ▶E M ≈ Mj : s		j

AE)


(
∇ ▶E M ≈ Mj : s	(a # (∇, M,M ))
∇ ▶E M : s	j

PERM)
∇#ds(π,π′) ▶E π ∗ M ≈ πj ∗ M : π · s  (ds(π, π )# (∇,M ))



(BF)


(EF)
∇, a # x : s ▶E M : sj	∇ ▶E a # N : s
∇ ▶E (λax : s. M ) N ≈ M {N/x} : sj

∇ ▶E M : sa ⇒ sj	(x ∈/ fv(M ))
∇ ▶E λax : s. (M x) ≈ M : sa ⇒ sj




(CF)
∇, a # x : s ▶E M ≈ Mj : sj
∇ ▶E λax : s. M ≈ λax : s. Mj : sa ⇒ sj




(CA)
∇ ▶E a # Ai : s	∇ ▶E F1 ≈ F2 : sa ⇒ sj	∇ ▶E A1 ≈ A2 : s
∇ ▶E F1 A1 ≈ F2 A2 : sj
∇j ▶E ai # Nj : si

(i=1,2)

(SUB)
∇j ▶E ai # Ni : si	∇j ▶E Ni ≈ Nj : si	∇ ▶E M ≈ Mj : sj
∇j ▶E M {N1,..., Nn/x1,..., xn} ≈ Mj{Nj ,...,Nj /x1,..., xn} : sj

1	n

ds(π, πj) is the disagreement set: {a ∈ A | π(a) /= π(a)}
In rule (SUB)	∇ d=ef a1 # x1 : s1, ..., an # xn : sn and 1 ≤ i ≤ n

Table 4
NLC Equation Rules for a Given Th


b ∈ An is any/some fresh tuple of the same size such that b # (∇, a, M ). If Th D ∇ ▶E a # M : s then we may legitimately call the judgement a theorem, but we will usually call it a freshness assertion.
The role that the judgements ∇ ▶E a # M : s play leads to a crucial difference



between NEL and NLC. Consider the rule AP. Since F has type sa ⇒ sj then a must be fresh for the argument A, formally encoded as ∇ ▶E a # A : s. Thus the type system rules have equations-in-context as hypotheses, and the equation rules have expressions-in-context as hypotheses. Thus theorems and typed expressions are mutually inductively defined. Obviously this complicates our proofs, at least in comparison to NEL, and leads to some subtleties which we explain in due course.
We have two more lemmas that are crucial for proving some important facts about NLC. Lemma 3.2 is used in induction steps in which a binding variable in an abstraction also occurs in the environment (of the abstraction): For an example induction see the proof on page 11 of Lemma 3.3, and [28] (page 169) for a detailed explanation of the problem. Lemma 3.3 is used in proving Proposition 3.4; the proposition underpins our semantics and classifying category construction.
Lemma 3.2 (Variable Equivariance of Judgements) All typed expressions, and all theorems (hence freshness assertions too), are equivariant under variable swapping. More precisely, for any two distinct variables x, y, and where (x y) •− denotes variable swapping (see page 7), we have
Th D ∇ ▶E M : s =⇒ Th D (x y) •∇ ▶E (x y) • M : s
Th D ∇ ▶E M ≈ Mj : s =⇒ Th D (x y) •∇ ▶E (x y) • M ≈ (x y) • Mj : s
Lemma 3.3 Th D ∇, a # x : s ▶E M : sj if and only if Th D ∇,π · a # x : π · s ▶E
M {π—1x/x} : sj and similarly for equations.
Proof. Since permutations are isomorphisms we only need to prove one direction of the implication. We have to prove, by (mutual) induction over the rules in Table 3 and 4,

(∀Th D ∇j ▶E [M ]α : sj)	[
(∀ ∇, a, π, x, s)	(∇j ≡ ∇, a # x : s
=⇒ Th D ∇,π · a # x : π · s ▶E [M {π—1x/x}]α : sj))	]

(∀Th D ∇j ▶E [M ]α ≈ [Mj]α : sj)	[
(∀ ∇, a, π, x, s)	(∇j ≡ ∇, a # x : s
=⇒ Th D ∇,π · a # x : π · s ▶E [M {π—1x/x}]α ≈ [Mj{π—1x/x}]α : sj))	]
In the remainder of this example proof we concentrate only on illustrating the care we take over dealing with proofs involving capture avoiding re-naming.
Rule (ABS) : Consider the following instance




∇j, b # y : t ▶E [N ]α : tj

ABS

As an illustration of the proof, consider an (arbitrary) instantiation of (∀ ∇, a, π, x, s) such that ∇j ≡ ∇, a # y : s and y ≡ x. For Induction Property Closure, since [(λby : t. N ){π—1y/y}]α = [λby : t. N ]α, we have to prove that

∇,π · a # y : π · s ▶E [λby : t. N ]α : tj	(⬦)


We cannot immediately invert ABS since the binding
occurs in ∇j. Choosing


	
distinct yj we have [λby : t. N ]α = [λbyj : t. (yj y) • N ]α	(†) so we may now invert
ABS to get
∇, a # y : s, b # yj : t ▶E [(yj y) • N ]α : tj
and hence by the variable equivariance of judgements, Lemma 3.2,

∇, a # yj : s, b # y : t ▶E [N ]α : tj
Therefore by induction with (∀ ∇, a, π, x, s) locally instantiated to ∇, b # y :
t, a, π, yj, s we have

∇,π · a # yj : π · s, b # y : t ▶E [N {π—1yj/yj}]α = [N ]α : tj
since yj /∈ var (N ). Hence by Lemma 3.2 we have

∇,π · a # y : π · s, b # yj : t ▶E [(yj y) • N ]α : tj
and (⬦) follows from this using an instance of ABS, and (†).	2
In order to define our categorical semantics, we will require Proposition 3.4 and Proposition 3.5.
Proposition 3.4 (∗ preserves Typed Expressions and “Equalities”)
Given a theory Th,
Th D ∇ ▶E M : s implies Th D ∇ ▶E π ∗ M : π · s
Th D ∇ ▶E M ≈ Mj : s implies Th D ∇ ▶E π ∗ M ≈ π ∗ Mj : π · s
Proposition 3.5 (Atom Equivariance of Judgements) Given a theory Th,
Th D ∇ ▶E M : s implies Th D π ·∇ ▶E π · M : π · s
Th D ∇ ▶E M ≈ Mj : s implies Th D π ·∇ ▶E π · M ≈ π · Mj : π · s
A Sound Categorical Semantics
FM-Cartesian Closed Categories. Underlying intuition for FM-cccs starts by con- sidering internal categories I in FMNom. Such structures, while necessary for modelling NLC, are not sufficiently rich: to give meaning to NLC terms we must encode permutation actions as morphisms—an additional requirement on I. We

follow the “type (i) approach”: axiomatising I externally and equipping with per- mutation morphisms, yields a category with ﬁnitely supported internal permutation actions. We then obtain good notions of products and exponentials by stipulating coherence conditions between these structures and the internal permutation action; these are cartesian closed perm-categories. The (additional, external) axiomatisa- tion of freshness properties yields FM-cccs. Further details of FM-categories are in [7].
A category C has an internal permutation action if for each π ∈ Perm and
C ∈ ob C there is a C-arrow πC : C → π · C such that ιC is the identity idC and

(πj ◦ π)C = πj
πC, where π · C is defined to be the codomain of πC. An internal

permutation action is finitely supported if every arrow f : C → D in C is finitely supported with respect to the permutation action π · f d=ef πD ◦ f ◦ (π—1)π·C. We call a category with a finitely supported permutation action a perm-category. A 
perm-category has equivariant products if it has finite products, and the inter- nal permutation action preserves the projections (hence also preserves the product objects). A perm-category with equivariant finite products has equivariant ex- ponentials if it is cartesian closed and the internal permutation action preserves the evaluation morphism π · ev A,B = evπ·A,π·B (and hence exponential objects are preserved). A perm-category with equivariant finite products has fresh inclusions if for every finite set of atoms a ⊆ A and C-object C such that a # C we have a
C-arrow ia : C#a → C for which the following properties hold:

(Equivariance): π · ia


π·a π·C

(Sets of Atoms): i∅
= id
and ia ◦ ia′
= ia∪a′ ;

(Products): ia
C
= ia
C	C
× ia ;

C#a	C

C1×C2	C1	C2
(Internal permutation action): if supp(π)# C then πC#supp(π) is equal to the identity idC#supp(π) ;
(Epi When Fresh): If we have parallel C-arrows f, g : C → D such that



f ◦ ia
= g ◦ ia
and a # (f, g), then f = g;

(Freshness): Let f : C → D be such that a # D. Define †(f, a) d=ef (∃ b)(b #
(a, f ) ∧ (a b)D ◦ f ◦ ib  = f ◦ ib ). If †(f, a) holds then there is a unique
f∗ : C → D#a, the image restriction of f , such that ia ◦ f∗ = f .
A perm-category with equivariant finite products and fresh inclusions is an FM- category and if it also has equivariant exponentials we call it an FM-ccc. The category FMSet of FM-sets is an FM-ccc, with the (equivariant) exponential of FM-sets X and Y being the FM-set X ⇒fs Y of finitely supported functions from

X to Y , and with ia
are another example.
: X#a d=ef {x ∈ X | a # x} ‹→ X as fresh inclusions. FM-cpos

We will use the functor (−) ⇒ (+) : Cop ×C → C, which is defined by (A, B) '→ A ⇒ B and (f, g) '→ f ⇒ g d=ef λ(g ◦ ev ◦ (idA⇒B × f )). An auxiliary lemma is used in establishing that our semantics is sound; the proof is routine category theory. Its use is illustrated briefly on page 16.

Lemma 4.1
For any f : A × B → C we have π · λ(f )= λ(π · f )
πB ◦ evA,B = evπ·A,π·B ◦ (πA⇒B × πA).
π · (f ⇒ g)= π · f ⇒ π · g

πA⇒B = π—1
⇒ πB

For any f : A × B → C we have πB⇒C ◦ λ(f )= λ(πC ◦ f ◦ (id × π—1 ))
For any f : A × B → C and g : Aj → A, λ(f ) ◦ g = λ(f ◦ (g × idB))
Remark 4.2 Each freshness property has a simple intuition. We give one example for (Freshness). Let f : X → Y be finitely supported in FMSet , x ∈ X and a # Y . By choosing b # a, f and b # x we have (f ◦ ib )(x)= f (x) and the condition †(f, a) amounts to (b # a, f ) ∧ (a b) · f (x) = f (x). But since b # x we can also deduce b # f (x), so we have (b # a, f (x)) ∧ (a b) · f (x)= f (x). Hence f (x) ∈ Y #a and so f image restricts (with f∗ : x '→ f (x)).
A Sound Categorical Semantics. We wish to define a categorical semantics which will interpret typed expressions Th D ∇ ▶E M : s as morphisms [∇ ▶E M : s]] : [[∇]] −→ [[s ] in an FM-ccc C. However we have seen that NLC is dependently typed: in particular the type system and equation system are mutually inductively defined. This means that we cannot give a simple recursive definition of a function [[− ] over (well-typed) expressions [31,33]. However, we can give such a definition of a partial semantic function, which is defined only when certain equations are themselves satisfied by [−]].
We also deal with a further complication. See rule AP which has hypothesis
∇ ▶E a # A : s.  We wish to define, following Remark 4.2, the semantics of

∇ ▶E a # A : s as [∇ ▶E a # A : s]] d=ef
∗
A : s]] —but this morphism is

defined only if the condition †([[∇ ▶E A : s]], a) holds! Thus we also need to factor this requirement into our semantics and soundness theorem.
We can now define the semantics. Let C be a FM-ccc and Sg a NLC-signature.
Then a Sg -structure M in C is specified by giving:
An equivariant map [−]] : Gnd Sg −→ ob C. We extend to the map [−]] : Type −→ ob C via structural recursion ( [sa ⇒ sj]] d=ef [[s]]#a ⇒ [[sj]]) and this is easily seen to be equivariant too, since C has equivariant structure.
An equivariant map [−]] : FunSg −→ ob C where for each higher order function constant c : s we have [c]]:1 −→ [[s ] (recall that C has finite products—hence an equivariant terminal object).
Let ∇ = a1 # x1 : s1, ..., an # xn : sn ∈ Env Sg be a freshness environment. Then
we define the C-object [∇]] by [[∇]] d=ef [s1]]#a1 × ... × [[sn]]#an . We define a notion
of satisfaction for both expressions-in-context and equations-in-context. Let M be a structure for a NLC-signature in an FM-ccc C and consider the binary relation
in Table 5.	Table 5 specifies a partial function J '→ [[J ] from judgements to morphisms [J ]] in C. Given ∇ ▶E M : s or ∇ ▶E a # M : s we say that M satisfies





[[∇, ai # xi : si ▶ πxi : π · si]] ► π[[s ]] ◦ iai ◦ pr
: [[∇, ai # xi : si]] —→ [[si]]#ai —→ [[si]] —→ π · [[si]]

i	[[si ]]	i
[[∇▶ c : s]] ► [[c]]◦!: [[∇]] → 1 → [[s]]

[[∇, a # x : s ▶ M : s′]] ► m : [[∇]] × [[s]]a → [[s′]]
[[∇▶ λax : s.M : sa ⇒ s′]] ► λ(m): [[∇]] → ([[s]]#a ⇒ [[s′]])
[[∇▶ F : sa ⇒ s′]] ► f : [[∇]] → ([[s]]#a ⇒ [[s′]]) [[∇▶ a # A : s]] ► θ : [[∇]] → [[s]]#a
[[∇▶ F A : s′]] ► ev ◦ ⟨f, θ⟩ : [[∇]] → ([[s]]#a ⇒ [[s′]]) × [[s]]#a → [[s′]] [[∇ ▶E M : s]] ► m

[[∇ ▶E a # M : s]] ► m∗
Table 5
†(m,a)

Semantics of Higher Order Functions

the judgement if the morphism [∇ ▶E M : s]] : [[∇]] −→ [[s]] or [[∇ ▶E a # M : s]] : [[∇]] −→ [[s]]#a in C is defined (that is, the partial function J '→ [[J ] is defined). If so we write [∇ ▶E M : s]]⇓ or [∇ ▶E a # M : s]]⇓. Generally, [J ]]⇓ d=ef (∃j)([[J ]] ► j). We may write [J ]] or even [[J ]]⇓ for morphism j. Given ∇ ▶E M ≈ Mj : s we say that M satisfies it if both [∇ ▶E M : s]]⇓ and [∇ ▶E Mj : s]]⇓ and they are equal morphisms in C. We say that M is a model of a NLC theory Th = (Sg, Ax ) if M satisfies all of the equations-in-context in Ax . With this, we have our soundness theorem:
Theorem 4.3 (Soundness) Let Th be a NLC theory and M a model of Th in an FM-ccc. Then every typed expression Th D ∇ ▶E M : s, freshness assertion Th D ∇ ▶E a # M : s and theorem Th D ∇ ▶E M ≈ Mj : s is satisﬁed by M.
We need the following intermediate results to prove the soundness theorem. We adopt a direct approach to proving that our semantics is compositional with respect to substitution, which reduces some overhead from the approach in [7]. Note that we appeal to Propositions 3.4 and Proposition 3.5 to ensure that the NLC judgements mentioned below are properly defined. We shall write L = R to mean that L⇓ ⇐⇒ R⇓ and that L = R.
Lemma 4.4 (Semantic Id, Inclusion, Int. Perm. Action, Projection)
Given a freshness environment ∇ = a1 # x1 : s1, ..., an # xn : sn then we have
(i) id[[∇]] = ⟨[[∇ ▶ a1 # x1 : s1]], ..., [[∇ ▶ an # xn : sn]]⟩



a
[[∇]]
= ⟨[[∇#a ▶ a1 # x1 : s1]], ..., [[∇#a ▶ an # xn : sn]]⟩

π[[∇]] = ⟨[[∇ ▶ π · a1 # πx1 : π · s1]], ..., [[∇ ▶ π · an # πxn : π · sn]]⟩
pr [[∇j ]] : [[∇1]] × [[∇2]] → [[∇j]] = ⟨[[∇1 ∪ ∇2 ▶ ai # xi : si]]⟩, where ∇1, ∇2 ∈
Env Sg have disjoint domains but are such that ∇j = ∇ for j =1 and 2.
Lemma 4.5 (Useful Semantic Factorisations “[[ξ]]= [[ξ]] ◦ m”)
The function [[−]] : Env Sg → Env Sg is equivariant.
[[π ·∇ ▶E π · M : π · s]] = π · [[∇ ▶E M : s]]
[[∇ ▶ π ∗ M : π · s]] = π[[s]] ◦ [[∇ ▶ M : s]]



[[∇,π · a # x : π · s ▶E M {π—1/x} : sj]] =
[[∇, a # x : s ▶E M : sj]] ◦ (id


[[∇]]

—1
[[π·s]]#π·a

Given ∇ ≤ ∇j there exists an arrow weak : [[∇j]] → [[∇]] such that for any typed expression ∇ ▶E M : s, [[∇j ▶E M : s]] = [[∇ ▶E M : s]] ◦ weak.
[[∇#a ▶E M : s]] = [[∇ ▶E M : s]] ◦ ia where a # ∇.
Proof. We illustrate proofs of Lemma 4.5 part i and ii:
Following the definitions in our paper together with the properties of a perm- category, we have

π · [[∇]] = π · ([[s1]]#a1 × ... × [[sn]]#an )
= (π · [[s1]]#a1 × ... × π · [[sn]]#an )

= ((π · [[s1]])#π·a1 × (π · [[sn]])#π·an )
= ( [π · s1]]#π·a1 × [[π · sn]]#π·an )
= [[[π · a1 # x1 : π · s1, ..., π · an # xn : π · sn]]]
= [[π · ∇]]
Proof by induction on the structure of M


(∀M )	[	(∀ ∇, π, s)	(π · [[∇ ▶E M : s]] = [[π ·∇ ▶E π · M : π · s]]))	]
SUSP: It directly follows from the categorical semantics that [[π · ∇,π · a # x : π · s ▶E π · πjx : π · πj · s]]⇓
and [∇, a # x : s ▶E πjx : πj · s]]⇓
The equality follows by basic properties of FM-cccs.
CONST: It is immediate that [∇ ▶E c : s]]⇓ and [π ·∇ ▶E π · c : π · s]]⇓.
The equality follows from the fact that [−]] : FunΣ → ob C is equivariant.
LAM-ABS: Suppose [π · ∇ ▶E π · (λax : s. M ) : π · (sa ⇒ sj)]]⇓ and it is equal to fπ. By the definition of the meta-level permutation action and the inductively defined semantics we get

[[π ·∇ ▶E λπ·ax : π · s. π · M : (π · s)π·a ⇒ π · sj]] ► λ(mπ)
for some mπ where [π · ∇,π · a # x : π · s ▶E π · M : π · sj]] ► mπ. By induction we deduce that [∇, a # x : s ▶E M : sj]] ► m such that π · m = mπ. We then apply the rule for semantics of abstraction to obtain [∇ ▶E λax : s. M : sa ⇒ sj]] ► λ(m), that is, [∇ ▶E λax : s. M : sa ⇒ sj]]⇓. The definitional existence proof in the converse direction follows by similar reasoning. We now need to show that fπ = π · λ(m).


fπ d=ef λ(mπ)
= λ(π · m)	(induction)
= π · λ(m)	(Lemma 4.1 (i))
APP: Suppose [π · ∇ ▶E π · (F A) : π · sj]]⇓ and it is equal to tπ. By the definition of the meta-level permutation action and the rule for semantics of applications
[[π ·∇ ▶E (π · F ) (π · A): π · sj]] ► ev ◦ ⟨fπ, θπ⟩

for [π·∇ ▶E π·F : (π · s)π·a ⇒ π·sj]] ► fπ and [π·∇ ▶E π·a # π·A : π·s]] ► θπ. We have [π ·∇ ▶E π · a # π · A : π · s]] ► απ∗ by the rule for freshness assertion semantics where [π · ∇ ▶E π · A : π · s]] ► απ such that †(π · a, απ). Given that ► is a partial function, we have that θπ = απ∗. By induction we get [[∇ ▶E F : sa ⇒ sj]] ► f and [∇ ▶E A : s]] ► α such that fπ = π · f and απ = π · α. We now deduce from †(π · a, απ) that †(a, α) holds: Let aj # (a, α). It follows immediately that π · aj # (π · a, π · α) and hence from †(π · a, π · α) we obtain equation (1). In the equations below, we write internal permutation actions τC as τ— since the source-target data does not play a significant role in our reasoning, and indeed is probably obfuscating:

(π · aj π · a)− ◦ (π · α) ◦ i = (π · α) ◦ i	(1)

(π · aj π · a)
◦ π  ◦ α ◦ π—1 ◦ i = π  ◦ α ◦ π—1 ◦ i	(2)

−	−	−	−	−
π ◦ (aj a) ◦ α ◦ π—1 ◦ i = π  ◦ α ◦ π—1 ◦ i	(3)
−	−	−	−	−

(aj a)
◦ α ◦ i ◦ π—1 = α ◦ i ◦ π—1
(4)

−	−	−
(aj a)− ◦ α ◦ i = α ◦ i	(5)
By definition of the FM-ccc permutation action on morphisms we obtain equation (2). The transposition notation (aj a) is short for (aj a1)◦...◦(aj ak).
1	k
Since in Perm, π◦(c d)= (π(c) π(d))◦π holds generally for single transpositions

(c d), and since permutation actions satisfy (τ j ◦ τ )C = τ j
πC we have


	
π− ◦ (aj a)− = (π ◦ (aj a))− = ((π · aj π · a) ◦ π)− = (π · aj π · a)− ◦ π−
This gives us equation (3). Any internal permutation action (τC : C → τ · C | C ∈ ob C) is a natural transformation Id → τ ·− and in particular so is π—1. Since also π— is iso, equation (4) holds. Finally since π—1 is iso we obtain (5).
Hence, †(a, α) holds.
We can now apply the rule for freshness assertion semantics to obtain [∇ ▶E a # A : s]] ► α∗, followed by the rule for application semantics to get [∇ ▶E F A : sj]] ► ev ◦ ⟨f, α∗⟩. Hence, we have [∇ ▶E F A : sj]]⇓. The definitional existence proof in the converse direction follows by similar reasoning.

We now show that tπ = π · (ev ◦ ⟨f, α∗⟩). Note that (π · α)∗ = π · α∗ (Φ) holds: This follows immediately from the universal property of inclusion image restriction and the definition of π · −. Hence


tπ d=ef ev

([[π·s]]

#π·a

,[[π·s′]])
⟨fπ
, θπ⟩

= ev	#π·a	′  ◦ ⟨fπ, απ∗⟩	(θπ = απ∗)
= ev	#a	′  ◦ ⟨π · f, (π · α)∗⟩	(induction)
∗
(π·([[s]]	),π·[[s ]])
= ev	#a	′  ◦ (π · ⟨f, α∗⟩)	(equivariant products)
= (π · ev	#a  ′  ) ◦ (π · ⟨f, α∗⟩)	(equivariant exponentials)
= π · (ev	#a  ′  ◦ ⟨f, α∗⟩)	(equivariance of ◦)
([[s]]	,[[s ]])	2

Proposition 4.6 (Compositional Semantics) Let ∇ d=ef a1 # x1 : s1, ..., an # xn : sn. Suppose, for theory Th, we have the typed expression ∇ ▶E M : s and freshness assertions ∇j ▶E ai # Ni : si for each i. Then we have ∇j ▶E M {Ni/xi} :
s. Moreover, if [[∇ ▶E M : s]]⇓ and [[∇j ▶E ai # Ni : si]]⇓ for each i then we have [[∇j ▶E M {Ni/xi} : s]]⇓ and further [[∇j ▶E M {Ni/xi} : s]] = [[∇ ▶E M : s]] ◦ ⟨[[∇S ▶E ai # Ni : si]]⟩.
The proofs of Lemmas 4.4 and 4.5 require a combination of direct calculations and inductions over the structure of terms. Note that the proof of Proposition 4.6 is by induction over the structure of M and does not require a complicated statement that is provable by mutual induction. The intuition is that, as one would expect, the semantics of expressions is derivation independent. We are now in a position to prove Theorem 4.3.
Proof. This proof does proceed by a mutual induction establishing the satisfaction of all judgement forms. Induction Property Closure for all the rules in Table 3 and Table 4 is similar to our example:
(AP): We need to show that [∇ ▶E F A : sj]]⇓  (⬦). By induction we have [[∇ ▶E F : sa ⇒ sj]] ► f  (1). Recalling that satisfaction of the freshness assertion is the satisfaction of an equation

∇ ▶E a # A : s	d=ef	(∀ / ∃ aj # (∇, a, A))	(∇#a′ ▶E A ≈ (a aj) ∗ A : s)

we have [∇#a′ ▶E A : s]] ► θ and [∇#a′ ▶E (a aj) ∗ A : s]] ► θj with θ = θj. Hence by Lemma 4.4 vi we have θ = α ◦ i where [∇ ▶E A : s]] ► α and by Lemma 4.4 iii and 4.4 vi we have θj = (a aj)[[s]] ◦ α ◦ i. From the (Epi When Fresh) property of FM- cccs we have α = (a aj)[[s]] ◦ α, that is †(α, a). Hence [∇ ▶E a # A : s]] ► α∗ (2). From (1) and (2) we have (⬦), with definition ev ◦ ⟨f, α∗⟩.
Property Closure for the rules in Table 4 is trivial for (REF) (SYM) (TRANS). (WEAK) uses Lemma 4.4 v. (AE) uses Lemma 4.4 vi and Lemma 4.4 ii. (PERM) uses Lemma 4.4 iii and Lemma 4.4 vi. (BF) is quite similar to the details given for (AP).2

A Complete Categorical Semantics
In order to obtain a completeness result we need a way to construct a cartesian closed category out of NLC syntax. To do this we augment the types, expressions and rules with a form of dependently typed atom-abstraction. In doing so we arrive at the final form of NLC (with abstraction) for which we have a categorical model that is both sound and complete. Please note that we only give a summary of the details in this preliminary paper; a substantial journal version will follow.
We augment the type system with types of the form [a]s. We augment the collection of terms with abstraction and concretion denoted by ⟨a⟩ M and M @ a respectively, and by a form of local scoping fr a.M .
Occurrences of a in ⟨a⟩ M are not bound. The permutation actions on the resulting terms (and expressions) are defined in the expected way. The type system and equation system appears in Table 6 on page 20.
The equations specify forms of beta and eta equality, ensure that term forming operations are congruences, and that the ⟨a⟩ M abstraction operator on expressions is equated with ⟨aj⟩ Mj provided that the two expressions given by swapping out the a and aj for a fresh atom b are provable equal in the logic (so “binding” is encoded at the level of formal equations). As for semantics, in FMSet one should think of the usual semantic notions of abstraction and concretion modelling ⟨a⟩ M and M @ a, and the expression fr a.M as the syntactic analogue of fresh a in F (a) (see [30], the Freshness Theorem).
We also need a richer categorical structure to achieve completeness. For any
FM-category C, there is a family of categories (C#a | a ∈ A) where ob C#a consists of those C ∈ ob C for which a # C. Given such C, Cj ∈ ob C#a, then f : C → Cj ∈ mor C is a morphism in C#a just in case a # f . The basic properties of fresh inclusions ensure that each C#a is indeed a category, and moreover that there is a functor (−)#a : C#a → C. For the remainder of this section we fix on an atom a that specifies the functor (−)#a. We shall require this functor to have a right adjoint [a](−) (moreover, an equivalence) and for there to be a family of morphisms concb : ([a]C)#b → (a b) · C. These structures are required to satisfy the commutativity properties which are needed in order to soundly model the equations (see Table 6). For example, for every D ∈ ob C#a, X ∈ ob C, and aj,b # X, where ηa,D is the counit of the adjunction, we have



D#a


i
v
)m (a a′) · X
(a′ b)(a a' )·)X

(a b) · X
ˆ
concb

D 	) ([a]X)#b
F∗

with F being the morphism


D	ηa),D

[a]D
#a [a])m

[a](a a′) · X
[a](a a′)(a a' )·)X

[a]X






(AABS)


(CONC)
∇#a ▶E M : (a aj) · s
∇ ▶E ⟨aj⟩ M : [a]s
∇ ▶E b # F : [a]s
(a # ∇, M, aj # s)

(a # ∇)[b = a ∨ b # s]



(LN)
∇#a ▶E F @ b : (a b) · s
∇#a ▶E a # M : s (a # ∇)[a # s]
∇ ▶E fr a.M : s
∇#a ▶E M : (a aj) · s	∇ ▶E b # ⟨aj⟩ M : [a]s

(BAA)


(EAA)
∇#a ▶E (⟨aj⟩ M )@ b ≈ (aj b) · M : (a b) · s
∇ ▶E b # F : [a]s
(a # ∇,b # F )
∇ ▶E ⟨b⟩ (F @ b) ≈ F : [a]s
(a # ∇,M, a′ # s)



∇#a,b ▶E (b aj) · M ≈ (b ajj) · Mj : (a aj) · s

′  ′  ′′

(BINDAA) 	
(a # ∇,M,M ,a ,a  # s,

∇ ▶E ⟨aj⟩ M ≈ ⟨ajj⟩ Mj : [a]s
b # a, a′, a′′,M,M′, s)



(CC)
∇ ▶E b # F : [a]s	∇ ▶E F ≈ Fj : [a]s
∇#a ▶E F @ b ≈ Fj @ b : (a b) · s
∇#a ▶E a # M : s
(a # ∇)[a = b ∨ b # s]

(LNFr)
∇#a ▶E fr a.M ≈ M : s
(a # ∇,a # M )[a # s]




(LNS)
∇#b ▶E b # M : s
∇#b\{a,a′} ▶E fr a.fr aj.M ≈ fr aj.fr a.M : s
∇#a′ , a # x : s ▶E M : sj


(b # ∇, a, aj
∈ b)[b # s]

(LNFS)
∇ ▶E fr aj.λax : s. M ≈ λax : s. fr aj.M : sa ⇒ sj
(aj /∈ a)

Table 6
NLC Augmented Typing and Equation Rules for a Given Th



Further
D	F	) [a]X
¨

ηa,D	¨
v	¨


where
[a]D#a 		) [a]X [a]((a b)(a b)·X ◦ conca ◦ F∗ ◦ ia )

ia	)	F∗
concb
(a b)(a b)·X

D#a	D
D 	) ([a]X)#b 	) (a b) · X 	) X





[[∇#a ▶E M : (a a′) · s]] ► m : [[∇]]#a → (a a′) · [[s]]
[[∇ ▶E ⟨a′⟩ M : [a]s]] ► [a]((a a′)(a a' )·[[s]] ○ m) ○ ηa,[[∇]] : [[∇]] → [a][[∇]]#a → [a][[s]] [[∇ ▶E F : [a]s]] ► f : [[∇]] → [a][[s]]




†(f ,b)

[[∇#a ▶E F @ b : (a b) · s]] ► concb ○ f∗ ○ ia	: [[∇]]#a → [[∇]] → ([a][[s]])#b → (a b) · [[s]]
[[∇#b ▶E b # M : s]] ► θ : [[∇]]#b → [[s]]#b

[[∇ ▶E fr b.M : s]] ► η−1
○ [b]θ ○ ηb,[[s]] : [[∇]] → [b][[∇]]#b → [b][[s]]#b → [[s]] Table 7

Semantics of Abstraction and Concretion

Suppose that we also require the adjoints to commute. We call such FM-cccs with this additional structure FM-cccs; it is these categories that yield a sound and complete semantics for NLC. The semantics of abstraction and concretion appears in Table 7.
An example of such a category is FMSet . The action of the functor (−)#a sends any FM-function f : X → Y ∈ FMSet #a to f #a : X#a → Y #a where f #a(x ∈ X#a) d=ef f (x) ∈ Y #a is easily seen to be well-defined. The action of the right adjoint [a](−) is defined on f : X → Y by setting
[a]X d=ef {⟨aj⟩ x | aj # X ∧ x ∈ (a aj) · X}
where ⟨aj⟩ x is the abstraction operator of Gabbay and Pitts [14], and further

[a]f (aj ∈ [a]X) d=ef
fresh b in ⟨b⟩ ((a b) · f )(aj @ b). The verification that we have

an adjunction satisfying the stated properties is a rather length calculation which
we omit from this paper.
The Classifying Category and Categorical Completeness. The notion of classi- fying category, topos, etc is a standard one in category theory [10,22]. To prove completeness we now show that we can build an FM-ccc from the syntax of a NLC theory (Proposition 5.1), together with a generic model [10] (Propositions 5.3 and 5.4).
Proposition 5.1 (Classifying Category) For every NLC-theory Th we can de- ﬁne a classifying FM-ccc Cl (Th) which is built from the syntax of Th. An object is
a freshness environment ∇ d=ef (a1 # x1 : s1, ..., an # xn : sn). If ∇j d=ef (aj1 # xj :

sj , ..., ajm # xj : sj
) then a morphism δ d=ef ([M1]≈,..., [Mm]≈): ∇ → ∇j is a list

1	m	m
of typed expressions such that for 1 ≤ i ≤ m we have Th D ∇ ▶E aj # Mi : sj, and
i	i
[Mi]≈ is the equivalence class of those T such that Th D ∇ ▶E Mi ≈ T : sj.
Remark 5.2 We explain, with a simple example, how we are able to construct
exponentials in the classifier. Consider (a1 # x1 : s1) ⇒ (aj1 # xj : sj ). One
would imagine that, whatever the exponential is, it should somehow involve the
type s a1 ⇒ sj a′ which is not legitimate in NLC. However, consider the following,
1	1
recalling that in an	FM-ccc the adjoints commute


#a1	j #a′
#a′	j	#a1	j
#a′	j
#a1	j

C(C1	, C1
1 ) ∼= C
1 ([a1]C1	, C1) =∼ C
1 (([a1]C1)
, C1)

We can mimic the above isomorphisms in the syntax of NLC in order to construct exponentials, and in fact we can show that


(a1 # x1 : s1) ⇒ (aj1 # xj : sj ) d=ef aj
# f : ([aj ]s1)#a1 ⇒ sj

1	1	1
`	NLC˛¸type	x

and that this easily extends to the general case of ∇1 ⇒ ∇2.
Proposition 5.3 The generic Sg-structure G of Th = (Sg, Ax) in Cl (Th) is given by deﬁning [[γ]]G =def (∅ # x : s) where γ is any ground type from Sg. If c is a

constant with typing c : s then [[c]]G
d=ef
([c]≈) : 1 d=ef
() −→ (∅ # x : s) is well

deﬁned since Th D [] ▶E c : s Further, suppose that Th D ∇ ▶E M : s. Then
[[∇ ▶E M : s]]G ► [M ]≈ : ∇ → (∅ # v : s)
Proposition 5.4 The generic structure G is a model of any Th = (Sg, Ax ).
Theorem 5.5 (Completeness) The categorical semantics of NLC-theories in FM-cccs is complete: Let Th bea NLC-theory. If any equation-in-context for Th is satisﬁed in all FM-ccc models of Th, then it is a theorem.

Category Theory/Type Theory Correspondence
Clouston [7] demonstrated a categorical type theory correspondence between NEL and FM-categories; we have established a similar correspondence between NLC and FM-cccs. Recall [10] that the correspondence result for standard λ-calculus and cartesian closed categories is slightly more restricted than the one for EL and cate- gories with finite products: Due to the covariant nature of exponentials, components of homomorphisms of models must be restricted to isomorphisms.
Theorem 6.1 The category Cl (Th) is a classifying category for NLC-theories in the sense that for every model M of Th in a FM-ccc D there is a unique FM- ccc functor Fn : Cl (Th) → D such that Fn composes with the generic model to yield M.
Now take a definition of homomorphism h : M → N of models of an NLC-theory
Th in an	FM-ccc C consisting of equivariant isomorphisms hγ : [[γ]]n ∼= [[γ]]n,
where h a	′ is given by (h#a)—1 ⇒ h ′ (and a # s ensures homomorphisms are well
s ⇒s	s	s
defined). For a NLC-theory Th and a small  FM-ccc C, the category of models
Mod~=(T h, C) consists of the Th models and homomorphisms. An FM-ccc functor F : C → D is an FM-functor that preserves exponentials and commutes with the adjunction. We can define FMccc~=(C, D) as a category with FM-ccc functors as objects and finitely supported natural isomorphisms as morphisms.
Theorem 6.2 We have FMccc~=(Cl(T h), D)  Mod~=(T h, D) for any NLC-theory Th and FM-ccc D. For any FM-ccc C, we have Cl(Th(C))  C. For any NLC- theory Th we have Th  T h(Cl(T h)).

Solutions, Open Questions, and Further Work

Exploiting Atom-Dependent Types. Clouston [4] observes that name-abstraction and concretion in FMSet cannot be captured by a NEL theory. This is related to the fact that concretion is a partial function, which can only be applied to arguments that meet certain freshness conditions. In the total concretion theory in Section 8 of [4] (page 15; MFPS 2010), Clouston describes concretion functions of the form cona : Name.s → s where Name.s is the name-abstraction type. Now cona x is well-formed only if a # x. NEL does not support such partiality. But in NLC we have exploited the new dependent type system to yield a solution.
Internal and 2-Categorical Approaches Could this paper be simplified by consid- ering internalisation in one of the FM-toposes? We cannot give a definitive answer: a deep investigation must wait for future work, but here are a few observations. Consider even the basic notion of perm-category. A perm-category is internal to FMNom; but an internal FMNom-category is not a perm-category since the mor- phism permutation πC is not directly captured by the internalisation. So it is not clear to us that the notion of FM-ccc could be extracted by internalisation. Going further, it is also not clear how the atom-set-partiality of our higher types can be (usefully) captured. However, even if it can, this misses a central point of our pa- per: a direct investigation into the interplay of higher order types and the freshness relation via a domain specific formal type theory. Possibly if one sought a direct route to “some kind of” completeness result an internal approach might work, but we are trying to do more than that. What is true is that the “nominal” world still needs to be better understood from a “2-categorical” viewpoint, and there are a number of open questions.
Future Work. Recall our motivation for this work: to develop a formal frame- work for nominal higher order functions, with a view to proving it a conservative extension over NEL by nominal gluing. Nominal gluing remains work in progress, but our preliminary results about the Yoneda Lemma and cartesian closure of nom- inal functor categories appear in [12]. From such a gluing proof, we might be able to extract a form of categorical normalisation result, taking the work in a more ap- plied direction through the construction of some form of abstract machine for NLC along with an implementation. Is there some form of nominal categorical abstract machine?
From the Computer Science perspective, we have taken great care in specifying NLC formally and care with proofs that involve quite subtle intricacies arising from α-equivalence in the nominal setting, and the (variable) equivariance of judgements and rules. We have attempted to avoid the traps (explained in [28]) that others have fallen into. As such, it would be an interesting project to study a mechanisation of NLC.
How much further can one take categorical correspondences for nominal log- ics/type theories? We are considering product and coproduct types, and of course one might study computational monad types, numbers, and more [20]. Going still further there is the general consideration of Martin L¨of dependent type theory

[27,32], nominal and FM analogues, and corresponding categorical structures. We are also investigating Henkin style models as have Gabbay and Mulligan [17]. Ch- eney [3] has studied the properties of a type theory that mixes functions, and atoms as first class citizens, along with a name abstraction operator. While discussing others’ work, it is interesting to note that type dependency is a common feature of studies involving computational type-and-effect systems. Examples are [34,1].
We have considered the possibility that the original NEL could be presented using dependent types in place of freshness assertions. However, the resulting type theory might be different. Such dependently typed theories, in which a # x : s is wholly replaced by x : sa, could be more expressive than NEL theories. This remains future work.
Acknowledgement
We thank Ranald Clouston for very detailed comments; John Power for being helpful and generous with his time over a public holiday; and for other useful comments and observations from Martin Hyland and Bill Lawvere. We must also thank others who have provided useful thoughts that we hope have improved this paper. Finally, and most importantly, we thank Andrew Pitts for extensive discussions about an earlier version of this paper which contained an error and assisting with its correction.

References
Nick Benton, Andrew Kennedy, Lennart Beringer, and Martin Hofmann. Relational Semantics for Effect-Based Program Transformations with Dynamic Allocation. In Proc. of the 9th ACM SIGPLAN international conference on Principles and Practice of Declarative Programming, PPDP ’07, pages 87–96, New York, NY, USA, 2007. ACM.
Clemens Berger, Paul-Andre Mellies, and Mark Weber. Monads with Arities and their Associated Theories. Journal of Pure and Applied Algebra, 216(89):2029–2048, 2012.
James Cheney. A Dependent Nominal Type Theory. Logical Methods in Computer Science, 8(1), 2012.
Ranald Clouston. Binding in Nominal Equational Logic. Electr. Notes Theor. Comput. Sci., 265:259– 276, 2010.
Ranald Clouston. Nominal Lawvere Theories. In WoLLIC’11, pages 67–83, 2011.
Ranald Clouston. Nominal Logic with Equations Only. In Logical Frameworks, Metalanguages and Theory of Programming, pages 44–57, 2011.
Ranald Clouston. Nominal Lawvere Theories: A Category Theoretic Account of Equational Theories with Names. Journal of Computer and System Sciences, 2013.
Ranald Clouston and Andrew M. Pitts. Nominal Equational Logic. Electron. Notes Theor. Comput. Sci., 172:223–257, 2007.
R. L. Crole. On Fixpoint Objects and Gluing Constructions. Applied Categorical Structures, 4(2 & 3):251–281, 1996. This volume is a Special Edition for the European Colloquium on Category Theory, Tours, France.
Roy L. Crole. Categories for Types. Cambridge University Press, 1993.
Roy L. Crole. α-Equivalence Equalities. Theoretical Computer Science, 433:1–19, May 2012.
Roy L. Crole and Frank Nebel. The Yoneda Lemma and Cartesian Closure in the FM-World. Submitted, 2013.


P.J. Freyd and A. Scedrov. Categories, Allegories. Elsevier Science Publishers, 1990. Appears as Volume 39 of the North-Holland Mathematical Library.
Murdoch Gabbay and Andrew M. Pitts. A New Approach to Abstract Syntax with Variable Binding.
Formal Asp. Comput., 13(3-5):341–363, 2002.
Murdoch J. Gabbay. Foundations of Nominal Techniques: Logic and Semantics of Variables in Abstract Syntax. Bulletin of Symbolic Logic, 17(2):161–229, 2011.
Murdoch J. Gabbay and Aad Mathijssen. Nominal Universal Algebra: Equational Logic with Names and Binding. Journal of Logic and Computation, 19(6):1455–1508, December 2009.
Murdoch James Gabbay and Dominic P. Mulligan. Nominal Henkin Semantics: Simply-Typed Lambda- Calculus Models in Nominal Sets. In LFMTP, pages 58–75, 2011.
J.R. Hindley and J.P. Seldin. Introduction to Combinators and the Lambda Calculus, volume 1 of
London Mathematical Society Student Texts. Cambridge University Press, 1988.
Martin Hyland and John Power. The Category Theoretic Understanding of Universal Algebra: Lawvere Theories and Monads. Electr. Notes Theor. Comput. Sci., 172:437–458, 2007.
Neelakantan R. Krishnaswami and Nick Benton. Adding Equations to System F Types. In ESOP, pages 417–435, 2012.
J. Lambek. From λ-calculus to cartesian closed categories. In J.P. Seldin and J.R. Hindley, editors, To
H.B. Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism. Academic Press, 1980.
J. Lambek and P.J. Scott. Introduction to Higher Order Categorical Logic. Cambridge University Press, 1986.
F.W. Lawvere. Functorial Semantics of Algebraic Theories. PhD thesis, Columbia University, 1963. Summary appears in Proc. of the National Academy of Science, 50:869–873, 1963.
E. Manes. Algebraic Theories, volume 26 of Graduate Texts in Mathematics. SV, 1976.
James McKinna and Robert Pollack. Some Lambda Calculus and Type Theory Formalized. JAR, 1998.
Paul-Andr´e Melli`es. Segal Condition Meets Computational Effects. In LICS, pages 150–159, 2010.
B. Nordstr¨om, K. Petersson, and J.M. Smith. Programming in Martin-L¨of ’s Type Theory, volume 7 of Monographs on Computer Science. Oxford University Press, 1990.
A. M. Pitts. Nominal Logic, A First Order Theory of Names and Binding. Information and Computation, 186:165–193, 2003.
A. M. Pitts. Structural Recursion with Locally Scoped Names. Journal of Functional Programming, 21(3):235–286, 2011.
A. M. Pitts. Nominal Sets: Names and Symmetry in Computer Science, volume 57 of Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, 2013.
Andrew M. Pitts. Categorical Logic. In Handbook of Logic in Computer Science: Volume 5: Logic and Algebraic Methods, pages 39–123, Oxford, UK, 2000. Oxford University Press.
Thomas Streicher. Independence Results for Calculi of Dependent Types. In Category Theory and Computer Science, pages 141–154, 1989.
Thomas Streicher. Semantics of Type Theory: Correctness, Completeness, and Independence Results, volume XII of Progress in Theoretical Computer Science. Basel: Birkh¨auser Verlag, 1991.
Jacob Thamsborg and Lars Birkedal. A Kripke Logical Relation for Effect-Based Program Transformations. In Proc of the 16th ACM SIGPLAN international conference on functional programming, ICFP ’11, pages 445–456, New York, NY, USA, 2011. ACM.
