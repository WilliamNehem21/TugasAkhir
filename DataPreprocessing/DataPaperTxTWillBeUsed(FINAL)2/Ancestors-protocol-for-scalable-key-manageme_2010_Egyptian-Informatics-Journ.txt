
ORGINAL ARTICLE

Ancestors protocol for scalable key management
Dieter Gollmann a,*, Fatma A. Omara b, Shrief Ibrahem Zaki c,
Mohamed W. Abo El Soud d

a Department of Security, Hamburg-Harburg University, Germany
b Department of Computer Science, Cairo University, Egypt
c Department of Mathematics, Suez Canal University, Egypt
d Department of Computer Science, Suez Canal University, Egypt

Received  November 2009; accepted 13 April 2010
Available online 13 August 2010

Abstract Group key management is an important functional building block for secure multicast architecture. Thereby, it has been extensively studied in the literature. The main proposed protocol is Adaptive Clustering for Scalable Group Key Management (ASGK). According to ASGK proto- col, the multicast group is divided into clusters, where each cluster consists of areas of members. Each cluster uses its own Traffic Encryption Key (TEK). These clusters are updated periodically depending on the dynamism of the members during the secure session. The modified protocol has been proposed based on ASGK with some modifications to balance the number of affected members and the encryption/decryption overhead with any number of the areas when a member joins or leaves the group. This modified protocol is called Ancestors protocol. According to Ances- tors protocol, every area receives the dynamism of the members from its parents. The main objective of the modified protocol is to reduce the number of affected members during the leaving and joining members, then 1 affects n overhead would be reduced. A comparative study has been done between


* Corresponding author.
E-mail addresses: diego@tu-harburg.de (D. Gollmann), F.Omara@ fci-cu.pdu.eg (F.A. Omara), sherif.ibrahem@gmail.com (S.I. Zaki), drmwagieh@hotmail.com (M.W. Abo El Soud)
1110-8665 © 2010 Faculty of Computers and Information, Cairo University. Production and hosting by Elsevier B.V. All rights reserved.

Peer review under responsibility of Faculty of Computers and Infor- mation, Cairo University.
doi:10.1016/j.eij.2010.06.002


12	D. Gollmann et al.

ASGK protocol and the modified protocol. According to the comparative results, it found that the modified protocol is always outperforming the ASGK protocol.
© 2010 Faculty of Computers and Information, Cairo University. Production and hosting by
Elsevier B.V. All rights reserved.




Introduction

Multicasting is considered an efficient solution for group com- munication on the Internet [1]. Instead of sending a separate copy of data per receiver, a sender can send a single copy and the multicast routers in the network make copy and for- ward packets appropriately to all receivers. Thus, multicasting utilizes network resources such as bandwidth and buffer space efficiently, and reduces load at the sender(s), as well as, the transit routers [1,2].
In order to secure group communications, security mecha- nisms such as authentication, access control, integrity, and confidentiality are required. Most of these mechanisms rely gen- erally on encryption using one or several keys. The management of these keys, which includes creating, distributing, and updat- ing the keys, constitutes a basic block to build secure group com- munication applications. Group communication confidentiality requires that only valid users could decrypt the multicast data even if the data is broadcasted to the entire network [3].
The confidentiality requirements can be translated further into four key distribution rules [4]:
Non-group confidentiality: Users that were never part of the group should not have access to any key that can decrypt
any multicast data sent to the group.
Forward confidentiality: Users who left the group should not have access to any future key. This ensures that a mem-
ber cannot decrypt data after leaving the group.
Backward confidentiality: A new user that joins a session should not have access to any old key. This ensures that a
member cannot decrypt data sent before he joined the group.
Collusion freedom: Any set of fraudulent users should not
be able to deduce the currently used key.

The work in this paper focuses on group key management by using a symmetric cryptosystem such as Advanced Encryp- tion Standard (AES) [5]. In this system, a symmetric key is used to encrypt data by the source and to decrypt it by the receivers. This key is generally called Traffic Encryption Key (TEK).
In order to meet the above requirements, a re-key process should be triggered after each join/leave to or from the secure group. It consists of generating a new TEK and distributing it to the members including the new one in case of a join or to the residual members in case of a leave. This process ensures that a new member can not decrypt eventually stored multicast data before its joining and prevents a leaving member from eaves- dropping future multicast data.
A critical problem with any re-key technique is scalability; as the re-key process is triggered at each membership change. The number of encryption key update messages may be impor- tant in case of frequent join and leave operations, and induces what is commonly called the 1 affects n phenomenon [6]. Some solutions have been proposed to organize the group into areas
with different local traffic encryption keys. This reduces the 1 affects n impact of the key updating process, but needs decryp- tion and re-encryption operations at the border of areas. These operations may decrease the communication quality. Such schemes have to define a mechanism that decides how a group should be divided. Ideally, the result of such division is optimal could be proved. Optimality of course, depends on the chosen cost functions.
Challal et al. [7] proposed Adaptive Clustering for Scalable Group Key Management (ASGK) that divides the multicast group into areas that are managed by Area Security Agents (ASAs). Areas are organized into clusters, where all agents in the cluster use the same TEK. These clusters are updated peri- odically by each ASGK agent depending on local dynamism information, i.e. the arrival and leave rate of members. Each agent in addition receives this information from its parent area and computes the re-keying overhead and key translation overhead to decide whether to create a new cluster or to use the TEK of its parent agent. The ASGK protocol scales well to large groups by balancing the 1 affects n overhead and the encryption/decryption operations through the adaptive structures of the clusters depending on the membership dynamism.
However, it is noted that ASGK only approximates the 1 affects n overhead. In particular, the used cost function does not consider the number of affected members. The Ancestors protocol will be proposed to provide a better balance between encryption/decryption overhead and mutual impact overhead where mutual impact overhead is expressed as a function of the affected number of members.
The 1 affects n and the re-encryption overheads are consid- ered relative important when defining an overall cost function for group key management. For a given cost function and a fixed group membership it is then possible to define optimal splits of the group into areas. With dynamic group member- ship, a split may become suboptimal due to membership changes and the areas have to be updated to maintain an opti- mal splitting of the group. This process has overheads of its own.
In the following, a fixed infrastructure of areas arranged as a tree is assumed. Each area is managed by an Area Security Agent (ASA). The ASA of area Ai is denoted by ai. An area can be active and use a TEK different than that of its parent or passive and use the same TEK as its parent. Areas that share the same TEK form a cluster. The set of areas in the same cluster
as area Ai are denoted by C(Ai). By abuse of notation we write ak ∈ C(Ai) to denote that ak is the ASA of an area Ak in C(Ai). An ASA switches between active and passive state depend-
ing on the number of members that have joined the area. The specification of the algorithm that decides which area a new member will join is outside the scope of this paper. When designing an algorithm for updating the state of an ASA, it is desirable to make decisions based as much as possible on local information.

Ancestors protocol for scalable key management	13

Figure 2	ASGK protocol.




Cluster 2


ASA: Area Security Agent


Cluster 1
kij, TEK, TEK', KEKi as defined before.
KEK': a new key encryption key for area Ai.
Kagt: a key encryption key shared between all the ASAs.

Figure 1  Adaptive Clustering for Scalable Group Key Manage-
ment Architecture [7].

The ASGK protocol

Challal et al. proposed the Adaptive Clustering for Scalable Group Key Management (ASGK) protocol [7], which follows the approach just described. Fig. 1 illustrates the components of the ASGK architecture. ASGK offers an adaptive protocol that maintains good performance during an entire multicast session. The ASGK protocol consists of three phases; join, leave, and update phases.
The multicast communication is denoted with ⇒, unicast communication with →, and out-of-band communication with #. There are multicast channels are assumed from each ASA
to the members in its area, and a multicast channel between the
ASAs.

Join phase

cluster C(Ai) have to distribute a new traffic encryption key TEK' to the members in their areas. The following four keys When a new member mij joins in area Ai, all the ASAs in the
will be used in the protocol:
kij: a secret key shared between ai and mij.
TEK: old traffic encryption key.
TEK': new traffic encryption key.
KEKi: key encryption key shared between ai and all mem- bers in area Ai.

The following protocol is executed when a new member mij
joins in area Ai:
mij → ai: ‘‘join request’’.
ai → mij : kij.
ai → mij : enc(kij; TEK'; KEKi).
ai ⇒ {ak|ak ∈ C(Ai)}: ‘‘join in area Ai’’, enc(TEK; TEK').
For all ak ∈ C(Ai); ak ⇒ Ak: enc(TEK; TEK').
Leave phase
When member mij leaves area Ai, all ASAs in cluster C(Ai)
have to distribute a new TEK to the members in their areas.
The following six keys are used:
The protocol executed when member mij leaves area Ai is as follows:
mij → ai: ‘‘leave request’’.
ai → {mit|mit – mij ∈ Ai}: enc(kit; TEK'; KEK').
ai ⇒ {ak|ak ∈ C(Ai)}: ‘‘leave in area Ai’’, enc(Kagt; TEK').
ak ∈ C(Ai); k–i: ak ⇒ mik: enc(KEKk; TEK').
Cluster update phase

A distributed cluster update phase is executed periodically tak- ing into account that dynamism distribution over a multicast session is space and time dependent [8,9]. Each agent records the arrival and leave rate of members during a given time per- iod. This is the local dynamism information ki.
In addition, ai securely receives dynamism information ki
overhead as ki + kj and the re-encryption overhead q(Ai) as 2 · r · Algt where r is the rate of the multicast traffic and Algt from its parent area Aj. ASA ai then computes the 1 affects n
the computation time per data unit for encryption taking into
consideration the agents’ computation power. Let the factor x indicate the relative importance of the 1 affects n overhead in comparison to the re-encryption overhead. Then, ai takes a local decision to become active or passive depending on the comparison between the weighted overheads (see Fig. 2).
If x(ki + kj) > q(Ai) then Ai becomes active and forms a new separate cluster.
If x(ki + kj) 6 q(Ai) then Ai becomes passive and merges with the cluster of its parent.

Cost functions

Two overheads are induced by clustering a set of areas to use the same TEK. The first relates to key translation at the clus- ter’s root agent. This overhead depends on the key translation scheme used. Different schemes have been proposed, such as





14	D. Gollmann et al.



cipher sequences [10], proxy encryption [11], and the decryp- tion/re-encryption protocols used in Iolus [6] and KHIP [12]. The Iolus re-encryption overhead in the simulation section will be used as same as ASGK protocol. The second overhead re- lates to re-keying due to clustering.
The 1 affects n overhead can be estimated either by the number of exchanged messages (unicast or multicast) or by the number of affected entities. Table 1 shows the 1 affects n overhead for steps 4 and 5 of the ASGK join protocol accord-
ing to these two approaches. Here, |C(Ai)|areas denotes the number of areas in cluster C(Ai) and |C(Ai)|members the number of members in cluster C(Ai). Table 2 shows the 1 affects n overhead for steps 2, 3, and 4 of the leave protocol.

Evaluation of the ASGK protocol

In [7], the disturbance power dp(Ai) of an area Ai is defined as the degree d(Ai) of area Ai in the cluster C(Ai), multiplied by its dynamism information:
dp(Ai)= ki · d(Ai)	(1)
The 1 affects n overhead u(C) of cluster C is captured by
u(C)≈   kj · d(Aj)	(2)
Aj ∈C
and the cluster’s cost function c(C) is defined as
c(C)= x · u(C)+ q(C)	(3)
where q(C) is as above the re-encryption overhead for C and x
a weight factor.
It is shown in [12] that the update protocol in Section 2.3 is optimal with respect to this cost function.
However, the update function can induce some non-intui- tive results. Assume that all areas have the same membership turnover k. Then, the update condition becomes
x · k > r · Algt	(4)
for all ASAs. Hence, either all areas are active or all areas are
passive. Assume further that we have








Figure 3	ASGK for different binary trees.

bers remain in a session for 30 min on average. ASAs execute the cluster update phase every 15 min. Fig. 3 gives the result of
a simulation using x = 1 and a rate of multicast traffic of 10
data units per second. Observe that the number of affected
members for the ASGK protocol with 15 areas is greater than for a configuration with seven areas.
In summary, the ASGK protocol scales well to large groups by balancing the 1 affects n and the re-encryption overheads through the adapting the structure of the clusters depending on membership dynamism. However, its cost function only approximates the 1 affects n overhead. In particular, it does not consider the number of affected members.
The protocol will be proposed that balance 1 affects n and re-encryption overheads when cost is expressed as a function of the number of members affected.

Ancestors protocol
The setup is the same as in the ASGK protocol. The multicast group is organized into multiple areas arranged into a tree structure. Each area is managed by an ASA which is responsi- ble for the local key management process. An ASA can be in two possible states, active or passive. An active ASA uses its own TEK for its area and thus has to decrypt and re-encrypt received messages before forwarding them to local members. A passive ASA uses the TEK of its parent area and hence for- wards received messages to local members without decryption/ re-encryption. So, the states of the ASAs induce a partition of the areas into a set of clusters. Each cluster is composed of a

x · k > r · Alg > x · k
(5)
set of areas that share the same TEK. The cluster’s root ASA

2	is active and all internal ASAs are passive.

If the number of areas is doubled so that membership changes are distributed equitably, it would be moved from a configura- tion where all areas are active to a configuration where all areas become passive forming a single cluster. Note that the ASGK cost function does not consider the overall number of members in an area but only those joining and leaving within the period monitored. As discussed in Section 2.4 the true cost for some of the steps in the join and leave protocols does de- pend on the full membership.
For illustration, the number of affected members is mea- sured for ASGK protocol runs when areas form a binary tree with seven and 15 areas, respectively. A session of three hours has been simulated where member arrivals follow a Poisson distribution with average inter-arrival time of 20 s, and mem-

Cost function

Let the re-keying overhead be measured by the number of mes- sages being sent when members join or leave. For measuring the re-keying overhead during a monitoring period ASA ai keeps two counters, a counter si holding the total number of
messages it has sent and a counter li holding the number of current area members. The following algorithm is executed during a monitoring period:
At the start of the period, set si ← 0; ci ← |C(Ai)|areas .
When  a  new  member  joins,  set  li ← li + 1  and
si ← si + ci + 1.

Ancestors protocol for scalable key management	15
When	a	member	leaves,	set	li ← li — 1	and
si ← si + li + ci + 1.
It is assumed that first ji members join and then ki members
leave. Then the final value of si is:

si ← si + ji · (ci + 1)+ 
ki
z=1
li + ji — z!
+ ki · (ci + 1)

It is assumed that first ki members leave and then ji mem-
bers join. Then the final value of si is:
 Xki	!
	 	



Then, si have two values. The first one is an upper bound and the other is a lower bound.

Proof. It is assumed that first ki members leave and then ji
Then, the cluster’s cost function is based on the true number of affected members in the cluster and the re-encryption overhead. h

2	2
members join and then ki members leave and then ji members

2	2
join. Then the final value of si is:
 Xki	k	j	!
Evaluation protocol

For illustration, the number of affected members is measured

i	i	i	i

	
i
z=1
i	i
(6)
and 15 areas, respectively. The protocol is implemented by using the some features as in Fig. 3. According to the simula- tion results, the number of affected members with 15 areas is

Because of the result of this equation is not larger than the first
number or not smaller than the second number. Then the two numbers are an upper and a lower bound.
The cluster’s cost function, Cost(C(Ai)), of a cluster C(Ai) is defined as the number of affected members, C(C(Ai)), and the re-encryption overhead q(Ai).
Cost(C(Ai)) = xC(C(Ai)) + q(Ai)	(7)
the number of affected members is
Aj parent of Ai
C(C(A )) =	C(A , A )	(8)
fewer comparing with seven areas (see Fig. 4). It is found that the number of affected members are balanced using seven and 15 areas (see Fig. 5).
Therefore, the protocol satisfies the balance between mu- tual impact and re-encryption overheads when cost is ex- pressed as a function of the number of members affected.

Cluster update protocol for Ancestors

When the cluster update protocol is executed, every Ai receives the affected members information of areas on the path via pas-

i


and
C(C(Ai)) =
Finally,
i	j
Ai ,Aj ∈C(Ai )
sm	(9)
Am ∈C(Ai )
sive ancestor areas toward the first active ancestor area, i.e. to the cluster head responsible for generating the cluster TEK. We
denote the set of Ancestors of area Ai by A(Ai). Then Ai com- putes the 1 affects n overhead FA(Ai) by:
FA(Ai)=	sk	(11)
Ak ∈A(Ai )

Cost(C(Ai)) =	sm
Am ∈C(Ai )
+ q(Ai)	(10)
The re-encryption overhead q(Ai) is defined as in Section 2.3.
Then, Ai becomes active or passive depending on the compar-
ison between these two overheads (see Fig. 5).

If FA(Ai) > q(Ai) then Ai becomes active and forms a new separate cluster.
If FA(Ai) 6 q(Ai) then Ai becomes passive and merges with the cluster of its parent.

According to the Ancestor protocol, each agent takes a lo- cal decision relying on the affected members information of the ancestor areas in the cluster.

Proof of optimality





Figure 4	Different binary trees for Ancestors protocol.
of y. If q(y) 6 C(x, y), then if y takes the decision to become Definition 1. Let x and y be area security agents, with x parent active this will decrease the total cost of the partition [12].

16	D. Gollmann et al.


Definition 2. Let x and y be area security agents, with x parent
of y. If C(x, y) 6 q(y), then if y takes the decision to become
is positive, and according to Definition 2, the quantity:
Ak parent of Aai

passive this will decrease the total cost of the partition [8].
It is supposed when all of the ASAs take their decisions, the

AaXi ∈zetaa
(q(Aai)— C(Aai, Ak))	(14)

resulting partition will be the optimal solution. To proof of optimality, the total cost induced by our Ancestors protocol partitioning is denoted by Cost(New). The total cost induced by any other partition is denoted by Cost(Other). The areas
that make the difference are denoted by fa ∪ fp  where fp = {Ap1; Ap2;.. .} are the passive agents in the other partition which  are  active  in  the  proposed  protocol,  and
fa = {Aa1; Aa2;.. .} are the active agents in the other partition which are passive in the proposed protocol. According to the
cost function in Eq. (7), we follow that:
Cost(Other)— Cost(New)
Ak parent of Api
=	(C(Api, Ak)— qApi))
Api ∈zetap
is positive also. This means that
Cost(New) 6 Cost(Other)	(15)
and hence the proposed protocol partition is an optimal solu-
tion. Then, the Ancestors protocol outperformed the ASGK protocol.

Simulation results

A comparative study has been implemented between the Ancestors protocol and ASGK protocol using ns2 simulator run sunstation with linux operating system. According to Fig. 6 by using the proposed Ancestors protocol, the 1 affects n overhead is smaller than that the ASGK protocol through the whole update times. According to Fig. 7, the proposed

Ak parent of Aai
+
Aai ∈zetaa
(q(Aai)— C(Aai, Ak))	(12)
Ancestors protocol has the same nearly cost as the ASGK pro-
tocol. Generally, the proposed Ancestors protocol is always outperformed the ASGK protocol.

According to Definition 1 the quantity:
Ak parent of Api
Conclusion and future work

ApXi ∈zetap
(C(Api, Ak)— q(Api))	(13)


Figure 6	Comparison of 1 affects n overhead.




















Figure 7	Comparison of cost.

Conclusion

Consider group key distribution to a large and dynamic group. In most applications, some members join and leave any time, these joins and leaves induce re-keying. Changes in group membership require new keys to be distributed. To manage the overhead thus created, a multicast group can be split into areas, where areas form clusters so that each cluster uses its own Traffic Encryption Key. It is noted that all proposed pro- tocols suffer from great concerns depending on group dyna- mism where the common TEK approaches suffer from the 1 affects nphenomenon, where a single group membership (join or leave) changes results in a re-keying process such that all group members have to update the TEK.
Moreover, ASGK protocol relies on dynamic clustering of encryption areas depending on the actual membership dyna- mism which has been shown to be time and space dependent. But ASGK protocol has disadvantage that the number of af- fected members will grow with the number of areas. ASGK protocol is modified by introducing Ancestors protocol. In Ancestors protocol, each agent receives up to the number of affected members of areas of the path from passive parent’s area to active parent’s area. The objective of this protocol is to satisfy the balanced between the 1 affects n overhead and the encryption/decryption overhead. According to the simu- lated results, it is found that our Ancestors protocol is optimal solution.

Future work

Instead of sending data independently to clients by the server, the peer-to-peer multicast scheme could be used to redistribute the serving load among the clients. This modification will dra- matically reduce the server’s resource requirement; enable low bandwidth sources to serve high quality live media to up to 100 clients.

Ancestors protocol for scalable key management	17


References

Deering S. Multicast routing in internetworks and extended LANs. In: ACM SIGCOMM, vol. 10; August 1998. p. 75–112.
Deering S. Host extensions for IP multicasting. RFC 1112; 1989.
Rafaeli S, Hutchison D. A survey of key management for secure group communication. ACM Comput Surveys 2003;35(3):309–29.
Snoeyink J, Subhash S, Vorghese G. A lower bound for multicast key distribution. In: IEEE INFOCOM’01; 2001. p. 1–10.
Federal Information Processing Standards Publication, Advanced Encryption Standard (AES). FIPS PUB 197; November 2001.
Mittra S. Iolus: a framework for scalable secure multicasting. In: ACM SIGCOMM; 1997. p. 1–12.
Challal Y, Said G, Bouabdallah A, Bettahar H. Adaptive clustering for scalable key management in dynamic group communications. Int J Security Networks 2008;3(2):133–46.

Almeroth K, Ammar M. Collecting and modeling the join/leave behavior of multicast group members in the Mbone. In: Sympo- sium on high performance distributed computing, Syracuse NY; 1996. p. 209–216.
Almeroth K, Ammar M. Multicast group behaviour in the Internet’s multicast backbone (Mbone). IEEE Commun Mag 1997;35(6):124–9.
Molva R, Pannetrat A. Scalable multicast security in dynamic groups. In: 6th ACM conference on computer and communica- tion security, Singapore; November 1999. p. 101–112.
Mukherjee R, Atwood JW. Proxy encryptions for secure multicast key management. In: IEEE local computer networks – LCN’03,
Bonn Germany; October 2003. p. 377–384
Shields C, Garcia J. KHIP – a scalable protocol for secure multicast routing. ACM SIGCOMM Comput Commun Rev 1999;29(4):53–64.
