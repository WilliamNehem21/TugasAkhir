Available online at www.sciencedirect.com



Electronic Notes in Theoretical Computer Science 278 (2011) 201–214
www.elsevier.com/locate/entcs

Expressive Completeness for LTL With Modulo Counting and Group Quantifiers
A V Sreejith 1
Institute of Mathematical Sciences, CIT Campus, Taramani,
Chennai, India

Abstract
Kamp showed that linear temporal logic is expressively complete for first order logic over words. We give a Gabbay style proof to show that linear temporal logic extended with modulo counting and group quantifiers (introduced by Baziramwabo,McKenzie,Th´erien) is expressively complete for first order logic with modulo counting (introduced by Straubing, Th´erien, Thomas) and group quantifiers (introduced by Barrington, Immerman, Straubing).
Keywords: linear temporal logic, first order logic, modulo counting, group quantifiers

Introduction
Kamp showed that over linear orders, linear temporal logic LTL (Prior [14], Pnueli [13], Gabbay, Pnueli, Shelah and Stavi [5]) is expressively complete for first order logic FO with monadic predicates. Kamp’s proof ([11]) also establishes that FO has the three-variable property: every first order formula has an equivalent formula using just three variables. Gabbay [6] gave another proof of this result emphasizing the separation property: every LTL formula has an equivalent formula which can be separated into pure past, present and pure future formulas. A more precise definition will appear later in this article. For word models, McNaughton and Papert [15] showed that these logics also correspond to the class of starfree regular languages. The translation algorithms are not elementary, and from Meyer and Stockmeyer [16] we know we cannot do better.
Various extensions have been proposed to extend the expressiveness of temporal logic over word models to all the regular languages (Wolper [18], Banieqbal and Bar- ringer [1], Hodkinson [9], Baziramwabo and McKenzie and Th´erien [3], Henriksen

1 Email: sreejith@imsc.res.in

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.10.016

and Thiagarajan [8]). Hodkinson’s proof (see the book ([7])) represents finite au- tomata using LTL with fixpoint operators, nowadays called the linear mu-calculus. The later work of Janin and Walukiewicz ([10]), which is in a branching context, also passes through automata.
Barrington, Immerman and Straubing [2] showed using the Krohn-Rhodes de- composition of finite monoids that the regular languages can also be described by FOgrp, first order logic extended with generalized quantifiers which perform com- putation in finite groups. This generalizes FOmod, first order logic extended with modulo counting, defined by Straubing, Th´erien and Thomas ([17]). Baziramwabo, McKenzie, Th´erien [3] use the Krohn-Rhodes decomposition to produce an LTLgrp formula, LTL extended with group computation modalities. So they also establish the three-variable property for FOgrp. They also show that the logic LTLmod is expressively complete for FOmod.
In this article we give Gabbay-style [6] separation-based proofs of these latter expressive completeness results, showing that LTLgrp and LTLmod have the sep- aration property. As a technical note, the present definition of the logics LTLgrp and LTLmod uses simpler modalities than the ones in [3] and in our own earlier work ([12]).
We also look at unary temporal logic UTL ([4]), which is LTL without the Until operator. We extend the technique of Etessami, Vardi and Wilke ([4]) to show that UTL with group operators (UTLgrp) has the same expressive power as FOgrp which uses only two variables.
The motivation for our work is to push logic-based methods further. In our view an interesting open question remaining is whether one can “logicize” the result of Barrington, Immerman and Straubing [2], namely, translate from monadic second order logic MSO to FOgrp without passing through automata or monoids.
Section 2 provides the syntax and semantics of LTL and first order logic with its extensions. Section 3 gives a proof of our main theorem.
Preliminaries
Linear temporal logic
A linear temporal logic formula over a set of propositions P is built using the fol- lowing syntax
φ ::= p ∈P | ¬ φ | φ1 ∨ φ2 | Xφ | Yφ | F φ | P φ | φ1 U φ2 | φ1 S φ2
We denote by true the statement a ∨ ¬a. Then Fφ, Pφ can be defined as trueUφ
and trueSφ respectively.
Linear temporal logic (LTL) formulas are interpreted on strings over an alphabet Σ= 2P , the set of all subsets of P. We denote the ith letter of a string u ∈ Σ∗ by u(i) and the length of u by |u|. The positions in u are numbered from 0 to |u|− 1. We consider only finite words.
Given a string u ∈ Σ+, a position i < |u| and a linear temporal logic formula φ

over P, we denote by (u, i) |= φ to mean that φ is true at position i in the word u. The semantics of the logic is given below

As usual Gφ abbreviates ¬F¬φ and Hφ abbreviates ¬P¬φ. Restricting the above logic to not have since (S) and until (U) operator, gives us the logic UTL.
We say that a formula φ satisﬁes a word u if (u, 0) |= φ. Then u is called a model of φ. We denote by L(φ) the language of φ, that is the set of all the models of φ. We say that formulas α and β are equivalent if for all words u and ∀i < |u|, we have that w, i ▶ α ⇔ u, i ▶ β.
Modulo counting and Group operator extensions of LTL
The logic LTLmod extends LTL with the following modulo counting quantifiers for every r, q ∈ N where r ≤ q:
MODF φ | MODP φ
r,q	r,q
The following logic LTLgrp, extends LTL with the group operator.


F
g,(g1,...,gk)
P
g,(g1,...,gk)
⟨φ1, ..., φk⟩

Here G is a finite group whose elements are {g1, ..., gk, 1} and g is an element in G. Here 1 denotes the identity of G. We denote by multiplication the group operator. If the ordering of the group is known we will drop that from the subscript of the syntax. Also we denote by LTLgrp(G) the logic if the only group used is G.
We denote by UTLmod, UTLgrp the logic got by extending UTL with the above modulo counting and group operators.
Let φ be a formula over the propositions P and u be a finite word over (2P )∗ and let i < |u|. The semantics for the newly introduced operators are given as follows.
u, i |= MODF φ iff |{i < l < |u|| u, l |= φ}| ≡q r u, i |= MODP φ iff |{0 ≤ l < i | u, l |= φ}| ≡q r

We denote by m ≡q r that m leaves a remainder of r when divided by q.
The semantics for the group operators GF ⟨φ1, ..., φk⟩ is as follows.
First, we define Γ(u, l)= gj if u, l |= ¬φ1 ∧ ... ¬φj−1 ∧ φj for 1 ≤ j ≤ k. Also define Γ(u, l) = 1 (the identity element) if none of the formulae φ1,..., φk hold at position
l. Then:
u, i |= GF ⟨φ1, ..., φk⟩ iff (Π|u|−1 Γ(u, l)) = g
g	l=i+1
u, i |= GP ⟨φ1, ..., φk⟩ iff (Πi−1Γ(u, l)) = g
g	l=0
Observe that this is a generalization of the modulo counting we did earlier, since modulo counting is similar to working with cyclic groups.	For example.

F
1,q
φ can be expressed by the following formula which uses the cyclic group,

G = {g1, g2, g3,..., g|q|}.

1	1	1
GF ⟨φ,false,...,false⟩

Later we use the notation Γj⟨φ1, ..., φk⟩ to denote the formula ¬φ1 ∧· · ·∧¬φj−1 ∧φj We say that an LTLgrp (LTLmod) formula is a pure future formula if the only modalities used are X, U and future group operator (future mod operator). Similarly we say that an LTLgrp (LTLmod) formula is a pure past formula if the only modalities used are Y, S and past group operator (past mod operator). Pure present formulas are those which does not use any modality. The formula F MODP α is neither a pure past or a pure present or a pure future formula. In such a case we call the formula impure. Observe that the semantics of until, since, group and modulo operators are strict, that is it does not depend on the present
position.
We define the future depth (past depth) inductively. All pure past (future) formula has future (past) depth 0. Future depth of the formulas φ1Uφ2, Xφ1, GF ⟨φ1, ..., φk⟩ is one more than the maximum of the future depth of the formu- las φ1, ..., φk. Similarly the past depth of the formulas φ1Sφ2, Yφ1, GP ⟨φ1, ..., φk⟩ is
one more than the past depth of the formulas φ1, ..., φk.
The depth of a formula is the sum of its future depth and past depth. Similarly the alternation depth of a formula is the number of alternations of its future and past modalities.

First order logic with modulo and group quantiﬁers
Let Σ be a finite alphabet and V be a finite set of variables. A word model over (Σ, V) is a pair (u, s), where u ∈ Σ∗ and s : V → {1, ..., m}, where |u| = m. Let us introduce the syntax of first order logic for word models. We use a finite set of variables V = {x1, ...}, a binary predicate < and unary predicates a, a ∈ Σ, for the finite alphabet Σ.
α ::= a(xi), a ∈ Σ | x1 < x2 | x1 = x2 | ¬ α | α ∨ β | ∃xα
The semantics for first order logic is standard. In the logic FOmod, introduced by Straubing, Th´erien and Thomas [17], one can count the number of times a

formula is satisfied modulo a number:
∃r,qx φ, q, r ∈ N, r ≤ q

The semantics for ∃r,qxφ is given as follows.
(u, s) |= ∃r,qxφ iff |{l ∈ {1, ..., |u|}|(u, s[x '→ l]) |= φ}| ≡ (r	mod q) Here s[x '→ l] denotes extension of s with the variable x being mapped to l.
The logic FOgrp is got by extending FO with the following group quantifier [2]:
Gg,(g1,...,gk)x ⟨φ1, ..., φk⟩

Its semantics is given as follows.


u, s |= G

g,(g1,...,gk)
x ⟨φ1, ..., φk⟩ iff Π|u| Γ(u, s[x '→ i]) = g

The definition of Γ is the same as the one given in LTLgrp semantics.
The following theorem [11,6] identifies the set of languages accepted by LTL.
Theorem 2.1 LTL is expressively complete for First order logic over words.
The theorem states that for all first order logic formula φ(x) with one free variable, there exists a formula ψ in LTL such that for all words u and ∀i ≤ |u| we have that
u, i ▶ φ ⇔ u, i ▶ ψ
We show in the next section that the theorem continous to be true even if we add the power of modulo counting and group operations.

Properties of LTLgrp
We first look at certain properties of the logic LTLgrp. Our first observation is that the formulas in LTLgrp have a normal form.
Theorem 3.1 Let α ∈ LTLgrp. Then there exists a group, Gα and a formula αˆ ∈
LTLgrp(Gα) such that L(α)= L(αˆ).
Proof. Take Gα to be the cross product of all the groups in α. Now any group G can be replaced by Gα (also requires modifying accepting group element).	2
Hence we can always work with formulas over LTLgrp(G), for some group G. Our next theorem says that the future group operator can simulate the past group operator (and vice versa) in the presence of future and past operators.
Theorem 3.2 Let α ∈ LTLgrp. Then α is equivalent to a formula αˆ, where αˆ do not contain any past group operator.

gi	)

.	.
`ˆ	˛¸	x
	)
g.gi
Fig. 1. Future Group modality can simulate Past Group modality
Proof. We replace all past group operators by future group operators as follows. Let β := GP ⟨φ1, ..., φk⟩ be a formula. We assume that all the formulas φ1, ..., φk do not contain any past group operator. We claim that β is equivalent to the following formula
   GF ⟨φ1, ..., φk⟩∧ P H GF  ⟨φ1, ..., φk⟩

gi
i∈[k]
g.gi

The formula says that, if the “result of the group computation” in the future of the current position is gi, then the value of the group computation from the beginning of the word should be g.gi. Note that both the above formula and β are not satisfied at the beginning of the word since we use strict past. See Figure 1 for a position not at the beginning of the word.	2
Observe that the formula αˆ in the proof above is an impure formula, even if
α was one. This takes us to the next section, where we show that any formula in LTLgrp (LTLmod) can be written as a boolean combination of pure formulas.
Separation property of LTLgrp
We say that a formula can be separated if it can be written asa boolean combination of pure past, pure present and pure future formulas. We say that a logic satisfies the separation property [6] if all formulas in that logic can be separated.
Theorem 3.3 [6] The logic LTL satisﬁes the separation property
We next show that logics LTLgrp, LTLmod have the separation property. The proof is given by a series of technical lemmas. The translations given below in Lemma 3.4 is the base case for the full proof.
Lemma 3.4 The following formulas can be separated.
GF ⟨(aSb ∧ β) ∨ φ1, ..., φk⟩
GF ⟨(GP ⟨γ , ..., γ ⟩∧ β) ∨ φ , ..., φ ⟩
g	g′	1	k	1	k
α U(GP ⟨γ , ..., γ ⟩∧ α )
1	g′	1	k	2
(GP ⟨γ , ..., γ ⟩∨ α )Uα

g′	1
k	2	1

GP ⟨(aUb ∧ β) ∨ φ1, ..., φk⟩
GP ⟨(GF ⟨γ , ..., γ ⟩∧ β) ∨ φ , ..., φ ⟩
g	g′	1	k	1	k
α S(GF ⟨γ , ..., γ ⟩∧ α )
1	g′	1	k	2
(GF ⟨γ , ..., γ ⟩∨ α )Sα

g′	1
k	2	1

a
.	b ¸	x`	˛ β
.	.
x	y
ˆ


Fig. 2. Timeline for aSb Λ β
(	gj
.	.
x `ˆ	˛¸
gjg—1
(			)
gi	gj

Fig. 3. Timeline for GP ⟨...⟩
Proof.
: Let x be the current location and z > y > x be locations such that b is true at y and a is true at all positions in the interval (y, z) and z satisfies β. That is z is where aSb ∧ β is true. See Figure 2. Observe that (y, z) is a block of states which satisfy aSb formula. Our idea is to get the group value computed in this interval. We consider the case where x does not satisfy the formula aSb. The solution we give can be modified to take this also into consideration.
Let Θ = ⟨φ1, ..., φk⟩. We now give a formula ψg which is true at all positions which satisfy b ∧ aUβ and the group value computed for the block of as until β is g.

ψg :=	 
g′=g.g′′
b ∧ (aU(β ∧ GF Θ)) ∧ GF Θ

Thus ψg is true at y iff the group value in the interval (y, z) is g. Let γ = ¬(aUβ). Now the following formula is equivalent to α.
GF ⟨(γ ∧ φ1) ∨ ψg , ..., (γ ∧ φk) ∨ ψg ⟩
g	1	k
The formula evaluates φis only when the position does not satisfy aUβ. Otherwise one of the ψgi s would have calculated the group value for the entire block. (2,3,4): Let the current point satisfy the formulas GP ⟨γ1,... γk⟩, Γl⟨γ1,..., γk⟩

and GF
j
⟨γ1,..., γk⟩. Let us assume gj = gl.gj′ . Then any point in the future will

satisfy GP ⟨γ , ..., γ ⟩ iff it also satisfies GF
⟨γ , ...γ ⟩. This let us replace the

g′	1	k
gjgig′−1	1	k

past group operator with a future group operator and vice versa. See Figure 3.
(5,6,7,8): These formulas are got by replacing past operators with future operators and vice versa in the formulas in 1,2,3,4. By the same arguments above we can show that these formulas can also be separated.	2
Lemma 3.5 The following translations are equivalent.
α1S(α2 ∨ α3) ≡ α1Sα2 ∨ α1Sα3
(α1 ∧ α2)Sα3 ≡ α1Sα3 ∧ α2Sα3

¬(aSb) ≡ (¬bS¬a) ∨ H¬b
¬GP ⟨φ1, ..., φk⟩ ≡ 

GP ⟨φ1, ..., φk⟩

α1U(α2 ∨ α3) ≡ α1Uα2 ∨ α1Uα3
(α1 ∧ α2)Uα3 ≡ α1Uα3 ∧ α2Uα3
¬(aUb) ≡ (¬bU¬a) ∨ G¬b
¬GF ⟨φ1, ..., φk⟩ ≡	GF ⟨φ1, ..., φk⟩
Proof. It is easy to see that the fourth and eigth statements are correct. The rest of the statements can be proved as shown in [6].	2
Lemma 3.4 and Lemma 3.5 let us rewrite formulas with past operators nested inside future operators. Observe that there are dual Lemmas where the past oper- ator is replaced by the future operator and vice versa. Using these two lemmas we give a series of lemmas to show that formulas in LTLgrp can be separated. These lemmas are proved using induction on the structure of the formula.
Lemma 3.6	(i) Let a, b be propositional formulas. Let α, β and φ1, ..., φk be for- mulas having the only modality being aUb. Then αSβ, GP ⟨φ1, ..., φk⟩ can be
separated.
(ii) Let a, b be propositional formulas. Let α, β and φ1, ..., φk be formulas having the only modality being aSb. Then αUβ, GF ⟨φ1, ..., φk⟩ can be separated.
Proof. Observe that the (ii)nd statement is the (i)st statement with past modalities replaced by future modalities and vice versa. We prove (i) now.
Gabbay [6] shows how to separate the formula αSβ. So let us consider the formula GP ⟨φ1, ..., φk⟩. Let each φi be a boolean combination of aUb and propositions. To rewrite GP ⟨φ1, ..., φk⟩ as boolean combination of pure Future and pure Past formulas, we apply the transformations given in Lemma 3.4 repeatedly which gives us a separated formula.	2
Lemma 3.7  (i) Let a1, ..., ak be propositional formulas. Let α, β and φ1,  , φk
be formulas having only the modality GF ⟨a , ..., a ⟩. Then αSβ, GP ⟨φ , ..., φ ⟩

can be separated.
g	1	k
g′	1	k

(ii) Let a1, ..., ak be propositional formulas. Let α, β and φ1, ..., φk be formulas having only the modality GP ⟨a , ..., a ⟩. Then αUβ, GF ⟨φ , ..., φ ⟩ can be sep-

arated.
g	1	k
g′	1	k

Proof. Repeated application of Lemma 3.4 and Lemma 3.5 give us a separated formula.	2
We now look at formulas where an until modality (since modality) is nested inside a past modality (future modality).
Lemma 3.8 (i) Let a1, ..., an, b1, ..., bn be propositional formulas. Let α, β and φ1, ..., φk be formulas having only the modality being ∀i ≤ n : Ui = aiUbi. Then αSβ, GP ⟨φ1, , φk⟩ can be separated.

(ii) Let a1, ..., an, b1, ..., bn be propositional formulas. Let α, β and φ1, ..., φk be formulas having only the modality being ∀i ≤ n : Si = aiSbi. Then αUβ, GF ⟨φ1, ..., φk⟩ can be separated.
Proof. We prove (i) and claim that the proof for (ii) is similar. When ψ = αSβ, this can be separated by the arguments of Gabbay. So let ψ = GP ⟨φ1, ..., φk⟩. Let {U1, ..., Un} be the n Until formulas used in the φis. We first replace the Until formulas U1, ..., Un—1 by new propositions p1, ..., pn—1. Let the new formula be called
ψˆ. By Lemma 3.6 we know that we can find a separated formula equivalent to ψˆ.
Now replace pn—1 in the formula by Un—1 and again apply Lemma 3.6. Observe that we did not introduce any new Untils when we separated. After n rounds we get a formula which is separated.	2
Lemma 3.9	(i) Let a1, ..., an, b1, ..., bn be propositional formulas. Let α, β and
φ1, ..., φk be formulas having only the modality GF ⟨a1, ..., ak⟩.	Then αSβ,
GP ⟨φ , ..., φ ⟩ can be separated.
g′	1	k
(ii) Let a1, ..., an, b1, ..., bn be propositional formulas. Let α, β and φ1, ..., φk be for- mulas having only the modality GP ⟨a , ..., a ⟩. Then αUβ, GF ⟨φ , ..., φ ⟩ can

be separated.
g	1	k
g′	1	k

Proof. The proof is similar to the proof of Lemma 3.8. In (i) we replace ∀i < n, GF ⟨a1, ..., ak⟩ by new propositions pi. We then apply 3.6 and continue as in the proof of Lemma 3.8.	2
Lemma 3.10	(i) Let a1, ..., an, b1, ..., bn be propositional formulas. Let α, β be formulas having only the modality ∀i ≤ n : Ui = aiUbis or GF ⟨a1,	, ak⟩. Then
αSβ, GP ⟨φ , ..., φ ⟩ can be separated.
g′	1	k
(ii) Let a1, ..., an, b1, ..., bn be propositional formulas. Let α, β be formulas hav- ing only the modality ∀i ≤ n : Ui = aiSbis or GP ⟨a1, ..., ak⟩. Then αUβ,
GF ⟨φ , ..., φ ⟩ can be separated.
g′	1	k
Proof. The proof is by combining the two Lemma 3.8 and Lemma 3.9.	2
Now we look at formulas having Until (Since) modality but without any Since (Until) nested inside an Until or Since. That is no modality is nested inside a Future (Past) modality, but Past and Future modalities can be nested with Past (Future) modality.
Lemma 3.11 (i) Let a1, ..., ak, b1, ..., bk be propositional formulas. Let α be a for- mula such that the Future modalities are of the form ∀i ≤ n : Ui = aiUbis or GF ⟨a1,  , ak⟩. Then α can be separated.
(ii) Let a1, ..., ak, b1, ..., bk be propositional formulas. Let α be a formula such that the Future modalities are of the form ∀i ≤ n : Ui = aiSbis or GP ⟨a1,  , ak⟩.
Then α can be separated.
Proof. We prove (i) and claim that the proof for (ii) is similar. Let the Past depth be n. If n = 0 the claim is trivially true. When n = 1 the claim follows from Lemma
3.10. For depth n > 1 we repeatedly apply Lemma 3.10 to the most deeply nested

Past modality. After each application of the Lemma the depth of the Past modality is reduced and hence after n steps we get a separated formula.	2
Now we consider formulas which can have Future modalities nested inside the Past modality.
Lemma 3.12 Let α be a formula such that no Past (Future) modality is nested inside a Future (Past) modality. Then α can be separated.
Proof. The proof is by induction on the depth n of the Future (Past) modality. n = 1 was proved by Lemma 3.11. When n > 1, we replace all Future (Past) modalities at Future (Past) depth ≥ 2 by new propositions pi. Let the resultant formula be αˆ. Observe that the Future (Past) depth of αˆ is one and hence can be separated by Lemma 3.11. Now replace all the pis by the Future (Past) modalites we replaced them with. Observe that we have reduced the Future (Past) depth. We repeat the above process until we get a separated formula.	2
Finally we show that any formula α ∈ LTLgrp can be separated.
Theorem 3.13 Let α be an LTLgrp (LTLmod) formula. Then α can be separated.
Proof. This involves induction on the alternation depth n of the formula α. n =1 was proved in Lemma 3.12. When n > 1, we replace the modalities by propositions such that we get a formula αˆ which is of alternation depth one. Lemma 3.12 will give a separated αˆj formula equivalent to αˆ. Now replace the propositions in αˆj with the modalities we had earlier replaced with. The formula we get is of alternation depth lesser than α. Hence we can repeat the procedure until we get a formula which is separated.	2
Corollary 3.14 Every LTLgrp (LTLmod) formula is initially equivalent to a for- mula with only future modalities.
Proof. Let α be an LTLgrp (LTLmod) formula. By Theorem 3.13 α can be separated. We can now replace the past formulas with false since all statements regarding past are false at the 0th position. The resultant formula which is equivalent to α now contains only future modalities.	2
3.2	Expressive Completeness of LTLgrp
Lemma 3.15 LTLgrp (LTLmod) has separation property iff it is expressively complete for FO grp (FO mod).
Proof. (⇐): Let α be an LTLgrp (LTLmod) formula. We can now write a first order logic formula, αj(x) on free variable x, such that it is equivalent to α. First order logic formulas can be separated using relativization. This can be proved by induction on the structure of the formula. The atomic case is trivial. Formulas of form ∃yφ(x, y) can be replaced by
∃y((y < x) ∧ φ(x, y)) ∨ φ(x, x) ∨ (∃y(y > x ∧ φ(x, y)))

Now a formula of type Ey(y > x Λφ(x, y)) can be replaced by a pure future LTLgrp formula (since LTLgrp is expressively complete for FOgrp). Similarly we can re- place pure past and pure present FOgrp formulas by pure past and pure present LTLgrp formulas. A similar proof can be given for group quantifiers too.
Now since LTLgrp (LTLmod) is expressively complete for FOgrp (FOmod) each of the separated formulas can be replaced with LTLgrp (LTLmod) formulas. This gives us a separated formula.
(⇒): We show that for an FOgrp (FOmod) formula with one free variable we can give an equivalent LTLgrp (LTLmod) formula. Let P1, ..., Pn be the unary predicates. The proof is by induction on the quantifier depth. For the base case we assume formulas with no quantifiers. This consists of boolean combination of formulas of the form Pi(x). The translation of this formula will be boolean combi- nation of formulas of the form pi.
Now let us assume that all FOgrp formulas with one free variable and of quan- tifier depth < k over any constant number of unary predicates (alphabet) can be converted into an LTLgrp formula. Let Q be a quantifier. Consider the formula ψ(x)= Qy φ(x, y) such that φ is of quantifier depth < k. We first remove x from ψ as follows. All subformulae of the form x = x, x < x, x > x are replaced by T, ⊥, ⊥ respectively. Now we rewrite ψ as follows (here v ∈ {0, 1}n):


ψ(x)=	 
v={0,1}n


((  Pi(x) e vi) ⇒ ψv(x))
i=1

Here ψv(x) replaces all occurrences of subformulas of the form Pi(x) with T, ⊥ de- pending on vi. Now the subformulas in each of ψv containing x will be of the form x < z, x > z, x = z, where z is some other variable in ψ. We remove these formu- lae by introducing three new unary predicates R<, R>, R= and replacing x op z by Rop(z) (op := {<, >, =}). The resultant formula ψv will not contain any occurrence of x. Moreover if we assume the interpretations for Rop it will be equivalent to the old formula. Now let ψv = Qyαv(y).
Case 1, Q = E: Since αv(y) is a formula with one free variable and quantifier depth
< k, we can apply the inductive hypothesis to get an LTLgrp formula γ with new propositions r<, r>, r=. We now write β = Pγ Vγ V Fγ. Since LTLgrp formulas can be separated we can now separate β into boolean combinations of pure past, pure present and pure future formulas. Finally in all the pure past formulas we replace r<, r>, r= with T, ⊥, ⊥ respectively. Similarly one can replace all the rop formulae with T, ⊥ in the pure future, and pure present formulae.
Case 2, Q = Gg: So let ψv = Ggy⟨α1(y), ..., αk(y)⟩. Since αv(y)s are formulas with one free variable and quantifier depth < k, we can apply the inductive hypothesis
to get LTLgrp formulas φis with new propositions r<, r>, r=.
Let us denote by Φ = ⟨φ1, ..., φk⟩. Then we can write β =	GP Φ Λ Γl(Φ) ΛGF Φ,
i,j,l	gi	gj
such that gi.gl.gj = g and ψv = β. Here Γl(Φ) is true only if (Λl	чφj) Λ φl
j=1
We can now separate β into boolean combination of pure past, pure present and pure future formulas. Finally in all the pure past formulas we replace r<, r>, r=

with T, ⊥, ⊥ respectively. Similarly one can replace all the rop formulae with T, ⊥
in the pure future, and pure present formulae.
So we have shown that the formula ψ(x) has an equivalent LTLgrp formula. Re- placing the Pi(x) with pi in the rest of the ψ formula will give us an LTLgrp formula which is equivalent to ψ.	2
Lemma 3.15 along with Theorem 3.13 gives us that
Theorem 3.16 LTLgrp (LTLmod) is expressively complete for FO grp (FO mod)
As a corollary we get
Corollary 3.17 Every FO grp (FO mod) formula with one free variable has an equivalent formula using three variables.
Proof. Let φ(x) be a FOgrp (FOmod) formula. By Theorem 3.16 we know that there exists an equivalent LTLgrp (LTLmod) formula ψ. We now induc- tively built a FOgrp (FOmod) formula from ψ as follows. The translation, t : LTLgrp×{x, y, z} → FOgrp is inductively given. tx(α), ty(α), tz(α) denotes t(α, x), t(α, y), t(α, z) respectively. For a formula α we give the translation tx as follows.
Clearly this translation uses only three variables and hence we get an equivalent FOgrp (FOmod) formula in three variables.	2

UTLgrp and two variable fragment of FOgrp
Here we show that UTLgrp is expressively complete for the two variable logic fragment of FOgrp, (written as FO2grp).
Theorem 4.1 UTLgrp is expressively complete for FO2grp.
Proof. The translation is recursive. For the atomic formulas, boolean combinations and existential formulas we follow the proof by Etessami et al [4]. We give here the translation for the group quantifier (A similar translation can be given for the

modulo quantifiers). Let
φ(x) := Ggy ⟨φ1(x, y), ..., φk(x, y)⟩
Each of the φj(x, y), for j ≤ k can be rewritten as
φj(x, y) := τj(γj(x, y), ..., γj(x, y), αj (x), ..., αj(x), βj(y), ..., βj(y))
1	r	1	s	1	t
Here τjs are boolean propositional formula. γjs are order formulas of the form x < y, x = y, x > y. The successor relations inside the group quantifiers can be removed and hence we do not consider it here. αjs and βjs are formulas whose
i	i
quantifier depth is less than the quantifier depth of φ(x). Moreover αjs and βjs are
i	i
of type atomic or existential or group quantified. We first take out the αjs outside
the group quantifier. For a vector v = (v1,..., vsk) ∈ {0, 1}sk we define
ψj (x, y)= τj(γj(x, y), ..., γj(x, y), vj,1, ..., vj,s, βj(y), ..., βj(y))
v	1	r	1	t
Let ψg for a g ∈ G be Ggy ⟨ψ1(x, y), ..., ψk(x, y)⟩. Then we can rewrite φ as:
v	v

φ(x) :=		(	αj(x) e vj,i) Λ ψg(x)
v∈{0,1}ks j≤k,i<s

Observe that the γjs are order formulas. Let Γ = {x < y, x = y, x > y}, be the set of all order relations between x and y. For any order relation, o ∈ Γ, γjs will be evaluated to {T, F}. Let ψo be the formula got by replacing γj with T/F in ψg(x)
g	i
depending on the order o. Observe that x does not appear free in ψo. Thus we get

φ(x) :=		(	αj(x) e vj,i) Λ	 

ψy<x Λ ψx=y Λ ψy>x

i
v∈{0,1}ks j≤k,i<s
g1	g2	g3
g1g2g3=g



Since formulas ψo
do not contain free variables equivalent UTLgrp formulas

exists. Formulas αj(x) have equivalent UTLgrp formulas, since their quantifier depths are less than the quantifier depth of φ(x). Hence we get an UTLgrp formula equivalent to φ.
2

References
Banieqbal, B. and H. Barringer, Temporal logic with fixed points, in: Temporal Logic in Specification
(1987), pp. 62–74.
URL http://portal.acm.org/citation.cfm?id=647236.720405

Barrington, D. A., N. Immerman and H. Straubing, On uniformity within NC1, Journal of Computer and System Sciences 41 (1990), pp. 274–306.
Baziramwabo, A., P. McKenzie and D. Th´erien, Modular temporal logic, in: Proc. 14th LICS (1999),
p. 344.
Etessami, K., M. Y. Vardi and T. Wilke, First-order logic with two variables and unary temporal logic, Inf. Comput. 179 (2002), pp. 279–295.


Gabbay, D., A. Pnueli, S. Shelah and J. Stavi, On the temporal analysis of fairness, in: Proceedings of the Seventh ACM Symposium on Principles of Programming Languages, ACM, 1980, pp. 163–173.
Gabbay, D. M., The declarative past and imperative future: Executable temporal logic for interactive systems, in: Temporal Logic in Specification (1987), pp. 409–448.
URL http://portal.acm.org/citation.cfm?id=647236.760143

Gabbay, D. M., I. Hodkinson and M. Reynolds, “Temporal Logics: Mathematical Foundations and Computational Aspects, Volume 1,” Oxford University Press, Oxford, 1994.
Henriksen, J. G. and P. Thiagarajan, Dynamic linear time temporal logic, Ann. Pure Appl. Logic 96
(1999), pp. 187–207.
Hodkinson, I. M., On Gabbay’s temporal fixed point operator, Theor. Comput. Sci. 139 (1995), pp. 1–25.
Janin, D. and I. Walukiewicz, On the expressive completeness of the propositional mu-calculus with respect to monadic second order logic, in: Proceedings of the 7th International Conference on Concurrency Theory, CONCUR ’96 (1996), pp. 263–277.
URL http://portal.acm.org/citation.cfm?id=646731.703838

Kamp, J. A. W., “Tense Logic and the Theory of Linear Order,” Ph.D. thesis, University of California, Los Angeles, CA (1968).
Lodaya, K. and A. Sreejith, LTL can be more succinct, in: Proc. 8th ATVA, Singapore, LNCS 6252, 2010, pp. 245–258.
Pnueli, A., The temporal logic of programs, in: focs77, 1977, pp. 46–57.
Prior, A. N., “Time and Modality,” Oxford University Press, Oxford, 1956.
R. McNaughton and S. Papert, “Counter-free Automata,” MIT Press, Cambridge, USA, 1971.
Stockmeyer, L. J. and A. R. Meyer, Word problems requiring exponential time(preliminary report), in:
Proceedings of the fifth annual ACM symposium on Theory of computing, STOC ’73 (1973), pp. 1–9.
URL http://doi.acm.org/10.1145/800125.804029

Straubing, H., D. Th´erien and W. Thomas, Regular languages defined with generalized quantifiers, Inf. Comput. 118 (1995), pp. 389–301.
Wolper, P., Temporal logic can be more expressive, Inf. Contr. 56 (1983), pp. 72–99.
