

Electronic Notes in Theoretical Computer Science 237 (2009) 39–56
www.elsevier.com/locate/entcs

Completion after Program Inversion of Injective Functions
Naoki Nishida 1 Masahiko Sakai 2
Graduate School of Information Science, Nagoya University Nagoya, Japan

Abstract
Given a constructor term rewriting system that defines injective functions, the inversion compiler proposed by Nishida, Sakai and Sakabe generates a conditional term rewriting system that defines the inverse relations of the injective functions, and then the compiler unravels the conditional system into an unconditional term rewriting system. In general, the resulting unconditional system is not (innermost-)confluent even if the
conditional system is (innermost-)confluent. In this paper, we propose a modification of the Knuth-Bendix completion procedure, which is used as a post-processor of the inversion compiler. Given a confluent and operationally terminating conditional system, the procedure takes the resulting unconditional systems as input. When the procedure halts successfully, it returns convergent systems that are computationally equivalent to the conditional systems. To adapt the modified procedure to the conditional systems that are not confluent but innermost-confluent, we propose a simplified variant of the modified procedure. We report that the implementations of the procedures succeed in generating innermost-convergent inverse systems for all the examples we tried.
Keywords: unraveling, conditional term rewriting system, convergence, innermost reduction


Introduction
Inverse computation of an n-ary function f is, given an output v, the calculation of the possible input v1,..., vn of f such that f (v1,..., vn) = v. Two approaches for inverse computation are distinguished [1]: inverse interpreters [4,1] that performs inverse computation, and inversion compilers [18,28,9,25,24,7,19,20,2] that performs program inversion.
Given a constructor term rewriting system (constructor TRS), the inversion compiler proposed in [24,25] first generates a deterministic conditional TRS (DC- TRS) as an intermediate result, and then transforms the DCTRS into a TRS that is equivalent to the DCTRS with respect to inverse computation. The first phase of the compiler performs a local inversion: for every constructor TRS, the first

1 Email: nishida@is.nagoya-u.ac.jp
2 Email: sakai@is.nagoya-u.ac.jp

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.03.034

injective TRS

U( nv(R))
terminates?
convergent inverse TRS

R	)
)  zz )	)
z  y	R
n

inversion compiler [25]
		) U( nv(R)) non-terminating inverse TRS

Fig. 1. Overview of the partial inversion with completion.


phase generates a DCTRS, called an inverse system, which represents the complete inverse relation for the reduction relation of the constructor TRS. The second phase employs (a variant of) Ohlebusch’s unraveling [26]. Unravelings are transformations based on Marchiori’s approach [15] that transform DCTRSs into TRSs.
Unfortunately, the compiler cannot always generate TRSs that are computation- ally equivalent to the corresponding DCTRSs due to a characteristic of unravelings [15,27,30,22]. The characteristic is that the unraveled TRSs of DCTRSs may have unexpected normal forms that represent dead ends of wrong choices at branches of evaluating conditional parts of the DCTRSs (see the example nv(R1) shown later in this section). These wrong choices are captured by critical pairs of the unraveled TRSs, each of which originates from two (conditional) rewrite rules corresponding to the ‘correct’ and ‘wrong’ choices. Note that any rules looking like ‘wrong choice’ must be necessary elsewhere, and that it is decidable whether or not a normal form is expected: a normal form of the unraveled TRSs is an unexpected one if it contains an extra defined symbol introduced by the unraveling.
In program inversion by the inversion compiler [25,24], this problem arises even if all functions defined in the given constructor TRSs are injective. For this reason, the resulting TRSs do not define functions and thus the inversion compiler is less applicable to injective functions in practical functional programming languages — it is easy to translate functional programs into constructor TRSs, but difficult to translate the resulting TRSs of the compiler back into functional programs.
In this paper, we propose a modification of the Knuth-Bendix completion proce- dure in order to transform the unraveled TRSs of confluent and operationally ter-
minating DCTRSs into convergent (and possibly non-overlapping) TRSs that are computationally equivalent to the DCTRSs. Unfortunately, the procedure does not always halt just as in the case of the ordinary completion procedure. However, if the procedure halts successfully and the resulting convergent TRSs are non-overlapping, then the resulting systems can be translated back into functional programs due to the non-overlapping property. When all functions defined in the input TRSs are injective, we take the modified completion procedure as a post-processor into the inversion compiler (Fig. 1 and Section 5). Through this approach, we show that un- ravelings are useful not only in analyzing properties of DCTRSs [15,27] but also in generating programs that can be used for computation instead of the corresponding original programs, such as program inversion of functional programs.
Consider the following functional program written in Standard ML where
Snoc(xs, y) produces the list obtained from xs by adding y as the last element:

fun Snoc(	[]	, y ) = [y]
|	Snoc( x::xs, y ) = x :: Snoc( xs, y );
We can easily translate the above program into the following constructor TRS:
R1 = { Snoc(nil, y) → [y],	Snoc(x :: xs, y) → x :: Snoc(xs, y) }
where nil and :: are list constructors as usual, [t1, t2,..., tn] abbreviates the list t1 :: (t2 ::  :: (tn :: nil)  ). The compiler inverts R1 into the following DCTRS in the first phase: 3

Inv(R1) = ⎧⎨
InvSnoc([y]) → ⟨nil, y⟩

⎩ InvSnoc(x :: ys) → ⟨x :: xs, y⟩⇐ InvSnoc(ys) → ⟨xs, y⟩
where each tuple of n terms t1,..., tn is denoted by t1,..., tn that can be rep- resented as terms by introducing an n-ary constructor. The compiler unravels the DCTRS Inv(R1) into the following TRS in the second phase:
⎧⎪	InvSnoc([y]) → ⟨nil, y⟩,	⎫⎪

U(Inv(R1)) = ⎪⎨
InvSnoc(x :: ys) → U1(InvSnoc(ys), x, ys),⎪⎬

⎪⎪⎩U1(⟨xs, y⟩, x, ys) → ⟨x :: xs, y⟩	⎪⎪⎭
The introduced symbol U1 is used for evaluating the conditional part InvSnoc(ys) xs, y	of the second rule in	nv(R1).	The term Snoc([a, b], c) has a unique normal form [a, b, c] but InvSnoc([a, b, c]) has two normal forms:	a solution	[a, b], c	of inverse computation and an unexpected normal form U1(U1(U1(InvSnoc(nil), c, nil), b, [c]), a, [b, c]).  The restricted inversion compiler in
[2] for generating non-overlapping systems is not applicable to this case because R1
is out of its scope. In this example, it appears to be easy to translate from the TRS U( nv(R1)) or the CTRS nv(R1) into a functional program because we can easily determine an appropriate priority of rules, for instance, the common first rule
InvSnoc[y]   nil, y  may have the highest priority. However, such a translation
based on priorities of rules is difficult in general because we cannot decide which rules have priority of the application to terms. On the other hand, it is probably impossible that one transforms input systems into equivalent systems from which the compiler generates the inverse systems without overlapping.
To avoid this problem, it has been shown in [22] that the transformation in [30] is suitable as the second phase of the compiler, in the sense of producing conver- gent systems. However, the generated systems contain some special symbols and
overlapping rules. For this reason, it is difficult to translate the convergent but
overlapping TRS into a functional program (see Section 6).
Roughly speaking, non-confluence of U( nv(R1)) comes from the critical pair ( nil, x , U1(InvSnoc(nil), x, nil)) between the first and second rules in U( nv(R1)). In this case, the application of the first rule is ‘correct’ and that of the second

3 To simplify discussions, we omit describing special rules in the form of InvF (F (x1,..., xn))	x1,..., xn [25,24] because they are meaningless for inverse computation in dealing with functional programs on call- by-value interpretation. The special rules are necessary only for inverse computation of normalizing com- putation in term rewriting.

is ‘wrong’, that is, nil, x is the expected result and U1(InvSnoc(nil), x, nil) is the unexpected recursive call of U1 containing the dead end InvSnoc(nil). From this observation, by adding the rule U1(InvSnoc(nil), x, nil)  nil, x , the unexpected normal form of InvSnoc([a, b, c]) can be reduced to the solution. This added rule provides a path from the wrong branch of inverse computation back to the correct branch. Due to this rule, the new TRS is confluent. This process just corresponds to the behavior of completion. Therefore, completion is expected to solve the non- confluence of TRSs obtained by the inversion compiler.
In Section 3, we propose a notion of operationally innermost reduction of DC- TRSs that corresponds to call-by-value interpretation of functional programs, and we show that simulation-completeness with respect to innermost reduction is pre- served by Ohlebusch’s unraveling if the DCTRSs are restricted to functional pro- grams having let-like structures.
In Section 4, we propose a modification of the Knuth-Bendix completion pro- cedure, by adding a side condition to the orientation phase. Given a confluent and operationally terminating DCTRS, the modified completion procedure takes the unraveled TRSs as input. When the procedure halts successfully, it returns a convergent TRS that is computationally equivalent to the DCTRS. To obtain innermost-convergent TRSs from the unraveled TRSs of operationally terminating DCTRSs that are not confluent but innermost-confluent, we simplify the modified completion procedure by prohibiting the modified procedure to use two basic func- tions (composition and simpliﬁcation), and by giving an additional side condition to the orientation phase. The additional condition restricts orientable equations to equations that are oriented without overlaps with other rewrite rules.
In Section 5, we first show a sufficient condition of constructor TRSs from which the inversion compiler generates (innermost-)convergent DCTRSs. Next, we de- scribe an implementation of the modified completion procedure, and the experi- ments for the unraveled TRSs of DCTRSs obtained by the inversion compiler [24] from injective functions shown by Kawabe et al. [9]. Finally, we illustrate an infor- mal translation of the non-overlapping TRSs obtained by the procedure back into functional programs.
In this paper, we do not consider sorts. However, the framework in this paper can be extended to many-sorted systems as usual. All proofs can be found in the full version of this paper [21].

Preliminaries
Here, we will review the following basic notations of term rewriting [3,27].
Throughout this paper, we use V as a countably infinite set of variables. The set of all terms over a signature F and V is denoted by T (F, V). The set of all variables appearing in the terms t1,..., tn is represented by Var(t1,..., tn). The identity of terms s and t is denoted by s ≡ t. For a term t and a position p of t, the notation t|p represents the subterm of t at p. The function symbol at the root position ε of t is denoted by root(t). The notation C[t1,..., tn]p1,...,pn represents

the term obtained by replacing each  at position pi of an n-hole context C[ ] with term ti for 1		i	n. The domain and range of a substitution σ are denoted by om(σ) and	an(σ), respectively, and the application σ(t) of σ to t is abbreviated to tσ. The composition σθ of substitutions σ and θ is defined as σθ(x) = θ(σ(x)). Given terms s and t, we write s N t if there are some C[ ] and θ such that s ≡ C[tθ].
An (oriented) conditional rewrite rule over   is a triple (l, r, c), denoted by l   r   c, such that l is a non-variable term in  ( ,  ), r is a term in  ( ,  ), and c is of the form of s1  t1	sn   tn (n   0) with terms si and ti in  ( ,  ). In particular, the conditional rewrite rule l   r   c is said to be an (unconditional) rewrite rule if n = 0, and we may abbreviate it to l r. We sometimes attach a unique label ρ to a rule l  r  c by denoting ρ : l  r  c, and we use the label to refer to the rule. An (oriented) conditional rewriting system (CTRS, for short) R over a signature F is a finite set of conditional rewrite rules over F. Note that R is a TRS if all rules in R are unconditional. The rewrite relation of R is denoted by −→R. To specify the applied position p and rule ρ, we
write −→p or −→[p,ρ]. We write −→ε< if p is not the root position ε. A conditional
rewrite rule ρ : l → r ⇐ s1 → t1 ··· sk → tk is called deterministic if Var(r) ⊆ ar(l, t1,..., tk) and  ar(si)   ar(l, t1,..., ti−1) for 1  i  k. The CTRS R is called a deterministic CTRS (DCTRS, for short) if all rules in R are deterministic. A notion of operational termination of DCTRSs is defined via the absence of infinite well-formed proof trees in some inference system [14]: a CTRS R is operationally terminating (OP-SN, for short) if for any terms s and t, any proof tree attempting
to prove that s −→∗ R t cannot be infinite.
Let → be a reduction over terms in T (F, V). Then, the set of normal forms with respect to → is denoted by NF→(F, V). The binary relation −→∗ ! is defined as
{ (s, t) | s −→∗ t, t ∈ NF→(F, V) }.
Let R be a CTRS over F. The sets DR and CR of all deﬁned symbols and all constructors of R are defined as DR = {root(l) | l → r ⇐ c ∈ R} and CR = F \ DR, respectively. Terms in T (CR, V) are called constructor terms of R. The CTRS R is called a constructor system if every rule f (t1,..., tn) → r ⇐ c in R satisfies
{t1,..., tn} ⊆ T (CR, V).
We use the notion of context-sensitive reduction in [13]. A replacement mapping
μ is a mapping from a signature   to a set of natural numbers such that μ(f )
1,..., n for n-ary symbols f in . When μ(f ) is not defined explicitly, we assume that μ(f ) = 1,..., n . The set  (t) of reducible positions in t is defined as follows: μ(x) =  where x   , and  μ(f (t1,..., tn)) = ip  i  μ(f ),p   j μ(f )  μ(tj) . The context-sensitive reduction of the context-sensitive TRS (R, μ) of a TRS R and a

replacement map μ is denoted by −→
(R,μ)
: −→
(R,μ)
= {(s, t) | s −→p t, p ∈ Oμ(s)}. The

innermost reduction of −→
(R,μ)
is denoted by −→i (R,μ)
: −→i (R,μ)
= {(s, t) | s −→p t, p ∈

Oμ(s), (∀q > p. q ∈ Oμ(s) implies that s|q is irreducible)}.
Let li  ri (i = 1, 2) be two rules whose variables have been renamed such that ar(l1, r1)   ar(l2, r2) = . Let p be a position in l1 such that l1 p is not a variable and let θ be a most general unifier of l1 p and l2. This determines a critical pair (r1θ, (l1θ)[r2θ]p). If the two rules are renamed versions of the same rewrite rule, we

do not consider the case p = ε. If p = ε, then the critical pair is called an overlay . If two rules give rise to a critical pair, we say that they overlap. We denote the set of critical pairs constructed by rules in a TRS R by CP (R). We also denote the set of critical pairs between rules in R and another TRS R' by CP (R, R'). Moreover, CPε(R) denotes the set of overlays of R.
Let R and R' be CTRSs such that their normal forms are computable, and T be a set of terms. Roughly speaking, R' is computationally equivalent to R with respect to T if there exist mappings φ and ψ such that if R terminates on a term s  T admitting a unique normal form t, then R' also terminates on φ(s) and for any of its normal forms t', we have ψ(t') = t [30]. In this paper, we assume that φ and ψ are the identity mappings.
Let −→1 and −→2 be two binary relations on terms, and T ' and T '' be sets of terms. We say that −→1 = −→2 in T ' ×T'' (−→1 ⊇ −→2 in T ' ×T'', respectively) if −→1 ∩ (T ' ×T'')
= −→2 ∩ (T ' × T '') (−→1 ∩ (T ' × T '') ⊇ −→2 ∩ (T ' × T ''), respectively). Especially, we say that −→1 = −→2 in T ' (and −→1 ⊇ −→2 in T ') if T ' = T ''.
An equation over a signature F is a pair (s, t), denoted by s ≈ t, such that
s and t are terms in T (F, V). We write s  t for representing s ≈ t or t ≈ s. The equational relation with respect to a set E of equations is defined as ↔E =
{ (C[sσ], C[tσ]) | s  t ∈ E }.
Finally, we introduce the Knuth-Bendix completion procedure [11,3,31].
Definition 2.1 Let E be a finite set of equations over a signature F, and > be a reduction order. Let E(0) = E, R(0) = ∅ and i = 0, we apply the following steps:
(Orientation) select s  t ∈ E(i) such that s > t;

(Composition) R' := l	r'  l	r	R  ,r ∗ !
i R(i)∪{s→t}
r' };

(Deduction) E' := (E(i) \ {s  t}) ∪ CP ({s → t}, R' ∪ {s → t});
(Collapse) R(i+1) := {s → t} ∪ {l → r | l → r ∈ R',l / Ns};
(Simplification & Deletion)
E(i+1) := {s'' ≈ t'' | s' ≈ t' ∈ E', s' −→∗ !	s'' /≡ t'' ←−∗ !	t' };
if E(i+1) /= ∅ then i := i + 1 and go to step 1, otherwise output R(i+1).
Note that the procedure does not always halt. Suppose that the procedure halts successfully at i+1 = k (hence E(k) = ∅). Then, R(k) is convergent, and R(k) satisfies
↔∗ E = ↔∗ R(k) [3]. Note that when there is no rule to select at the Orientation
step, the procedure halts in failure. Note that Composition and Collapse are used for efficiency, and the resulting systems are convergent even if Composition and Collapse are skipped.
Unraveled TRSs with Call-by-Value Interpretation
In this section, we propose a notion of operationally innermost reduction of DCTRSs that corresponds to call-by-value interpretation of functional programs, and we show that simulation-completeness with respect to innermost reduction is preserved by

Ohlebusch’s unraveling if the DCTRSs are restricted to functional programs having
let-like structures.
We first give the definition of Ohlebusch’s unraveling [26]. Given a finite set X
of variables, we denote by −→X the sequence of variables in X without repetitions (in
some fixed order).
Definition 3.1 Let R be a DCTRS over a signature F. For every conditional rewrite rule ρ : l → r ⇐ s1 → t1 ∧ ··· ∧ sk → tk, let |ρ| denote the number k of conditions in ρ. For every conditional rule ρ ∈ R, we prepare k ‘fresh’ function symbols Uρ,...,Uρ not in F, called U symbols, in the transformation. We transform
ρ into a set U(ρ) of k + 1 unconditional rewrite rules as follows:
U(ρ) =  l → Uρ(s1, −X→1), Uρ(t1, −X→1) → Uρ(s2, −X→2), ··· , Uρ(tk, −X→k) → r ,
where Xi = Var(l, t1,..., ti−1). The system U(R) = ρ∈R U(ρ) is a TRS over the extended signature FU = F ∪ DU where DU = {Uρ | ρ ∈ R, 1 ≤ i ≤ |ρ|}.
Note that the definition of U is essentially equivalent to that in [26,29].
An unraveling U is simulation-sound (simulation-preserving and simulation- complete, respectively) for a DCTRS R over F if −→∗ R ⊆ −→∗ U(R) in T (F, V) (−→∗ R
∗ U(R) and ∗ R = ∗ U(R) in ( , ), respectively). Note that the simulation- preserving property is sometimes called simulation-completeness in some papers, and it is a necessary condition of being unravelings. Roughly speaking, the com- putational equivalence is equivalent to the combination of simulation-completeness and normal-form uniqueness. The unraveling U is not simulation-sound for every DCTRS [27]. To avoid this difficulty of non-‘simulation-soundness’ of U, a restric- tion to the rewrite relations of the unraveled TRSs is shown in [29], which is done by the context-sensitive condition given by the replacement map μ such that μ(Uρ) = 
ρ	i
1 for every Ui in Definition 3.1. We denote the context-sensitive TRS (U(R), μ) by Ucs(R). We consider Ucs as an unraveling from DCTRSs to context-sensitive
TRSs.
Theorem 3.2 ([29]) For every DCTRS R over F, Ucs is simulation-complete, that is, −→∗ R = −→∗ Ucs(R) in T (F, V).
To apply completion procedures to unraveled TRSs, we expect that the un- raveling U is simulation-complete without the context-sensitivity. To this end, we propose an ‘innermost-like’ reduction of DCTRSs, called operationally innermost reduction. Let R be an operationally terminating (OP-SN) DCTRS. The n-level operationally innermost reduction −−(n−)→,i R is defined as follows:
−(−0)→,i R = ∅, and
−(−n−+−1)→,i R = −−(n−)→,i R ∪ { (C[lσ], C[rσ]) | l → r ⇐ s1 → t1 ∧ ··· sk → tk ∈ R, ∀u D
lσ. u ∈ NF −→R (F, V), ∀i. siσ −−−∗→  tiσ }.
!
The operationally innermost reduction −→i R of R is defined as i≥0 −(−i)→,i R. Note that if R is a TRS then −→i R is equivalent to the ordinary innermost reduction. Note that

the ordinary definition of innermost reduction is not well-defined for every CTRS [8]. However, both the ordinary and operationally innermost reductions of OP-SN CTRSs are well-defined. R is called innermost-confluent (innermost-convergent ) if
−→i R is confluent.
Let R be a DCTRS. Terms in  u1,..., un, t1,..., tk  f (u1,..., un)	r	s1
t1    sk   tk  R   are called patterns (in R). We denote the set of patterns in R by Pat(R). It follows from the definition of U that Pat(R) = Pat(U(R)) up to variable renaming. Patterns represents structures of data by means of matching. Especially, in innermost reductions, patterns matches normal forms only.
Unfortunately, Ucs is not simulation-preserving for every DCTRS with respect to the normalizing innermost reduction −→∗ !. This is because not all normal form of R are normal form of Ucs(R), that is, NF R (F, V) /⊆ NF Ucs(R) (F, V). To preserve the simulation-preserving property, Ucs(R) must have the same pattern-
matching capability with R, that is, if an instance pθ of a pattern p is irreducible by R then pθ' is also irreducible by Ucs(R) for every substitution θ' such that xθ

∗ !
i Ucs(R)
xθ' for all x ∈ Dom(θ). When all patterns are constructor terms (that

is, U(R) is a constructor system), R and U(R) have the same pattern-matching capability. However, in examples of program inversion, a primitive operator du that requires equality check is used: du(⟨x⟩) = ⟨x, x⟩, du(⟨x, x⟩) = ⟨x⟩, and du(⟨x, y⟩) = 
⟨x, y⟩ if x /= y. This operator is encoded as the following terminating TRS:



Rdu
= ⎧⎨
Du(⟨x⟩) → ⟨x, x⟩,	Du(⟨x, y⟩) → EqChk(EQ(x, y)),	⎫⎬

⎩EqChk(⟨x⟩) → ⟨x⟩,	EqChk(EQ(x, y)) → ⟨x, y⟩,	EQ(x, x) → ⟨x⟩⎭
Note that any system containing Du is not a constructor system. Since Rdu has no overlay, Rdu is locally innermost-confluent , and hence, Rdu is innermost-confluent [12]. Under the innermost reduction, Rdu can simulate computation of du.
One of the sufficient conditions to have the same pattern-matching capability is to satisfy all of the following conditions:
all rules defining g  g  R g appears in Pat(R) are unconditional and every proper subterm of the left-hand sides is a variable, and
every rule l → r ⇐ s1 → t1 ∧· · ·∧ sk → tk represents a let-like structure, that is, Var(ti) ∩ Var(l, t1,..., ti−1) = ∅ for 1 ≤ i ≤ k.
We call R pattern-stable if R satisfies all of these conditions. The let-like struc- ture guarantees that ar(ti)  x1,..., xn = for every Uρ(ti, x1,..., xn) [23,25]. Pattern-stability is essential for DCTRSs that are used for modeling functional pro- grams with let-like structures and equality check.
Theorem 3.3 Let R be a pattern-stable OP-SN DCTRS over a signature F, and

s and t be terms in T (F, V). Then, s
∗ !  t implies s
i
∗ !
i Ucs(R)
u for some u in

T (FU, V) such that t −→∗ !	u.
Pattern-stability is also a sufficient condition for simulation-soundness. On the other hand, the non-erasing property of R is another sufficient condition. Here, we

call R strongly non-erasing if every rule l	r	s1	t1	sk	tk satisfies all of the following conditions [23,25]:
Var(l) ⊆ Var(r, s1, t1,..., sk, tk), and
Var(ti) ⊆ Var(r, si+1, ti+1,..., sk, tk) for 1 ≤ i ≤ k.
Any U symbol is not consumed by pattern-matching. The non-erasing property guarantees that no normal form containing U symbols appears along the reduction

∗ !
i Ucs(R)
t ∈ T (F, V); if a normal form containing a U symbol appears in the

sequence, the non-erasing property ensures that it remains in t.
Theorem 3.4 Let R be a pattern-stable or strongly non-erasing OP-SN DCTRS

over a signature F, and s and t be terms in T (F, V). Then, s −→∗ !
t implies s

∗ !  t.
i
Context-sensitivity is not necessary for innermost reduction of Ucs(R).

Theorem 3.5 For every DCTRS R over F, T (FU, V).
−→∗ U(R) =
−→∗ Ucs(R) in T (F, V) ×

Thanks to Theorem 3.5, when evaluating terms by the innermost reduction of
Ucs(R), we can treat U(R) without the context-sensitivity determined by U.
For pattern-stable OP-SN DCTRSs, we have the following simulation-soundness and weak simulation-preserving property.
Corollary 3.6 Let R be a pattern-stable OP-SN DCTRS over a signature F, and
s and t be terms in T (F, V). Then,
s −→∗ !  t implies s −→∗ !	u for some u in T (FU, V) such that t −→∗ !	u, and
s −→∗ !	t implies s −→∗ !  t.
Corollary 3.6 does not mean that s −→∗ !	u implies s −→∗ R t for some t such that
t −→∗ U(R) u and t is a normal form of R. This weakness of the simulation-preserving property does not happen when U(R) is innermost-confluent. Therefore, getting innermost-confluence is important for unraveled TRSs.
Completion of Unraveled TRSs
In this section, by adding a side condition to Orientation, we propose a modifica- tion of the ordinary Knuth-Bendix completion procedure for the unraveled TRSs of convergent DCTRSs. The modified procedure transforms the unraveled TRSs into convergent TRSs that are computationally equivalent to the DCTRSs. Moreover, to adapt the modified procedure to DCTRSs that are not confluent but innermost- confluent, we add another side condition to Orientation.
The usual purpose of completion procedures is to generate convergent TRSs that are equivalent to given equation sets. In contrast to the usual purpose, we expect completion procedures to transform unraveled TRSs U(R) into convergent TRSs that are computationally equivalent to the original DCTRSs R.  To this

end, we start the completion procedure from the initial pair (CP (U(R)), l	r U(R)	l'	r'	U(R),l N l' ) where U(R)	. Moreover, consistency of the normal forms of U(R) (that is, they are also normal forms of the resulting system) is necessary for preserving computational equivalence of R. For this requirement, we add the side condition ‘root(s) is a U symbol’ to Orientation:
1. (Orientation†) select s ≈ t ∈ E(i) such that s > t and root(s) is a U symbol;
Due to the side condition of Orientation†, and due to the basic characteristic of the ordinary completion procedure [3], the modiﬁed completion procedure produces convergent TRSs that are computationally equivalent to the input TRSs when it halts successfully.
Theorem 4.1 Let R be an OP-SN DCTRS over , and be a reduction order such that U(R)   . Let E0 = CP (U(R)), R0 =  l   r  U(R)   l'  r  U(R),lNl' ,
and R' be a TRS obtained by the modiﬁed completion procedure from (E0, R0) with

>. Then, (1) R' is convergent, (2) NF −→
= −→∗ ! ' in T (F, V).

U(R)
(F, V) = NF −→R'
(F, V), and (3) −→∗ !

Since NF −→S (F, V) = NF −→i S (F, V) (S is either U(R) or R), it holds in Theorem
4.1 that −→∗ !	= −→∗ ! ' in T (F, V).
Example 4.2 Consider the non-convergent TRS U( nv(R1)) in Section 1 again. Given the lexicographic path order (LPO)  lpo determined by the precedence > with InvSnoc > U1 > :: > nil > , we obtain the following convergent and non- overlapping TRS by the modified completion procedure (in 4 cycles):

R2 = ⎧⎨
InvSnoc(x :: ys) → U1(InvSnoc(ys), x, ys),	⎫⎬

⎩ U1(⟨xs, y⟩, x, ys) → ⟨x :: xs, y⟩,	U1(InvSnoc(nil), x, nil) → ⟨nil, x⟩ ⎭
Since the procedure removes the rule InvSnoc([y])  nil, y from U( nv(R1)), the resulting TRS R2 is non-overlapping.
Unfortunately, the modified completion procedure does not always halt even if the inputs are restricted to unraveled TRSs. For example, the modified procedure does not halt for the unraveled TRS obtained from Example 7.1.5 in [27] although there exists an appropriate convergent TRS that is computationally equivalent to the corresponding DCTRS.
Confluence of R is necessary for the modified completion procedure to halt ‘suc- cessfully’. Note that confluence of R is not sufficient for the procedure to ‘halt’. In other words, the procedure halts (or keeps running) ‘unsuccessfully’ if R is not con-
fluent. If R is not confluent, then we have t1 ←−∗ U(R) s −→∗ U(R) t2 and t1 /≡ t2 for some
s, t1 and t2 in  ( ,  ). The added side condition ‘root(s) is a U symbol’ prevents t1 and t2 from being joinable. From this observation, the modified procedure can be considered as a method to show confluence of R: if the procedure succeeds, then R is confluent.
As stated above, we would like to transform DCTRSs on call-by-value interpre- tation into convergent TRSs that are computationally equivalent to the DCTRSs.

Moreover, the modified completion procedure always fails for DCTRSs that are not confluent but innermost-confluent, such as DCTRSs containing Rdu.
To obtain innermost-convergent systems that are computationally equivalent to TRSs containing Rdu, applying completion procedures to the TRSs appears to be effective just as in the case of convergent TRSs. However, there is a difficulty associated with innermost reduction. The difficulty is that innermost reduction is not closed under substitutions. When applying the completion procedure to Rdu, the rules Du( x, y )  EqChk(EQ(x, y)) is transformed into Du( x, y )   x, y . Given a ground normal form t, the resulting system cannot simulate the reduction
Du(t, t) −→∗ Rdu ⟨t⟩ due to the lack of Du(⟨x, y⟩) → EqChk(EQ(x, y)).  To remove
this troublesome problem from the modified completion procedure for innermost reduction, we prohibit the procedure to use the two operations Composition and Simplification, and give an additional side condition to Orientation† as follows:
1. (Orientation‡) select s ≈ t ∈ E(i) such that s > t, root(s) is a U symbol, and CP ({s → t}, R(i) ∪ {s → t}) = ∅;
The additional condition means that the oriented rule s → t is not overlapping with other rules in R(i) ∪ {s → t}. Thus, Deduction does not add any equations to the equation set E(i) but removes an equation. Since no U symbol appears in the left- hand side l in T (F, V) from the definition of U, and since the added rules are not overlapping with other rules, Collapse removes no rules from the rule set R(i). If E has no equation of the form s s, Deletion step removes no equations from the equation set. From this observation, the modified procedure with Orientation‡ is simplified as Definition 4.3 shown later.
Before simplifying the modified procedure, we describe the relation between U(R) and S with respect to the innermost reduction. No rule l → r ∈ U(R) such that there exists a rule l'  r' with l D l'θ for some substitution θ is used in  U(R) because no instance of l is an innermost redex. For this reason, we restrict the initial set of rules to U(R) \ S. Roughly speaking U(R) \ S is the set of rules that
are usable for −→i U(R).
Definition 4.3 Let R be an OP-SN DCTRS over F, and > be a reduction order such that U(R) ⊆ >. Let S = { l → r ∈ U(R) | / ∃l' → r ∈ U(R),l N l' }, E(0) =
{s ≈ t | s  t ∈ CPε(U(R) \ S),s /≡ t}, R(0) = { l → r ∈ U(R) \ S | / ∃l' → r ∈
U(R) \ S, l N∼ l' }, and i = 0, then we apply the following steps:
(Orientation‡) select s ≈ t ∈ E(i) such that s > t, root(s) is a U symbol, and CP ({s → t}, R(i) ∪ {s → t}) = ∅;
R(i+1) := {s → t} ∪ R(i), and E(i+1) := E(i) \ {s  t};
if E(i+1) /= ∅ then i := i + 1 and go to step 1, otherwise output R(i+1). We call this procedure the simpliﬁed completion procedure.
It is clear that E(i) E(i+1) for every i 0. Therefore, the simplified completion procedure always halts. Note that the simplified procedure doest not succeed for all input.

Theorem 4.4 Let R be a pattern-stable OP-SN DCTRS over F, and > be a re- duction order such that U(R) ⊆ >. Let R' be a TRS obtained by the simpliﬁed completion procedure from R and >. Then all of the following hold: (1) R' is

innermost-convergent, (2) NF −→U(R)(F, V) = NF −→R'
(F, V), and (3)
i U(R) =

−→∗ ! ' in T (F, V).
Note that (1) and (3) implies (2).	The simplified procedure succeeds for
U(Inv(R1)) as well as for Example 4.2.
Similarly to the modified completion procedure, innermost-confluence of R is necessary for the simplified completion procedure to halt ‘successfully’. Therefore, the simplified procedure is a method to show innermost-confluence of R;

Completion after Program Inversion
In this section, we apply the modified and simplified completion procedures to DCTRSs generated by the partial inversion compiler [25], that is, we apply the procedures as a post-processor of U( nv( )) to the unraveled TRSs. First, we briefly introduce the feature of inverse systems for injective functions. Then, we show the results of experiments by an implementation of the framework.
We employ the partial inversion nv in [25] that generates a partial inverse CTRS from a pair of a given constructor TRS and a specification, which we do not describe in detail here. For a defined symbol F , the defined symbol InvF introduced by nv represents a full inverse of F . We assume that constructor TRSs define main injective functions, and that the specifications require full inverses of the main functions.

Inverse DCTRSs of Injective Functions
We first define injectivity of TRSs [22], and then give a sufficient condition for input constructor TRSs whose inverse DCTRSs generated by Inv are convergent.
Definition 5.1 Let R be a terminating and innermost-confluent constructor TRS. A defined symbol F of R is called injective (with respect to normal forms) if the binary relation ( s1,..., sn , t)	s1,..., sn,t	NF	(  ,  ),F (s1,..., sn) ∗ R t is an injective mapping. R is called injective (with respect to normal forms) if all of its defined symbols are injective.
For example, the TRS R1 in Section 1 is injective. Note that every injective TRS is non-erasing [22].
The following defined symbol Reverse computes the reverses of given lists:
R  = ⎧⎨ Reverse(xs) → Rev(xs, nil),	⎫⎬
⎩ Rev(nil, ys) → ys,	Rev(x :: xs, ys) → Rev(xs, x :: ys) ⎭
Reverse is injective but Rev is not. Thus, R4 is not injective. In this case, the inverse TRS U(Inv(R4)) is not terminating because U(Inv(R4)) contains the rule

InvRev(z) U4(InvRev(z), z). For this reason, we restrict ourselves to injective functions whose inverse TRSs are terminating. In [22], a sufficient condition has been shown for the full inversion compiler in [24] to generate convergent inverse DCTRSs from injective TRSs. The condition is also effective for the partial inversion compiler Inv [25].
Theorem 5.2 Let R be a non-erasing, terminating and innermost-confluent con- structor TRS.
If F ∈ DR is injective, then for all t, t1 and t2 ∈ NF −→Inv(R) (F, V), t1 ←−∗ Inv(R)
InvF (t) −→∗ Inv(R) t2 implies t1 ≡ t2.
Suppose that for every rule F (u1,..., un) → r in R, if r is not a variable then the root symbol of r does not depend 4 on F. If Inv(R) ∩ R = ∅ then the DCTRS Inv(R) is OP-SN.
Note that if the DCTRS nv(R) is OP-SN then the TRS U( nv(R)) is ter- minating [14]. Theorem 5.2 (i) shows that if nv(R) is OP-SN, then nv(R) has innermost-confluence that is necessary for successful runs of the simplified comple- tion procedure. Note that nv(R) is confluent if R is convergent [25]. When R does not satisfy the condition in Theorem 5.2 (ii), we directly check the termination of U( nv(R)). In other words, when R satisfies the condition in Theorem 5.2 (ii), we are free of the termination check of U( nv(R)) that is less efficient than the check of satisfying the condition.

Experiments
In this subsection, we report the results of applying implementations of the modified and simplified completion procedures to 10 of 15 examples shown in [9]. 5 These 15 examples are introduced for the experiments of the inversion compiler LRinv [9,10] where LRinv succeeds in inverting all of them. Those examples are written in the scheme script Gauche. The inverse TRSs of the scripts snoc, snocrev and reverse correspond to the TRSs U( nv(R1)), R3 and U( nv(R4)), respectively. The constructor TRSs corresponding to the 5 scripts (reverse and so on) are not injective and the inverse TRSs obtained from them are not terminating. For this reason, we excluded those non-terminating examples from our experiments. For some examples, there exists no appropriate LPO to guarantee termination of the
input TRSs. For this reason, we employ the termination check ‘( i	R(i))∪{s → t}
is terminating’ instead of the input reduction orders, following the approach in [34]. The implementations are written in Standard ML of New Jersey, and they were executed under OS Vine Linux 4.2, on an Intel Pentium 4 CPU at 3 GHz and 1
GByte of primary memory. By the system call in SML/NJ, the implementations consult with AProVE 1.2 [6] as a termination prover at the Orientation step. The

4 An n-ary symbol G of R depends on a symbol F if (G, F ) is in the transitive closure of the relation
'	'	'	'
{ (G ,F ) | G (·· ·) → C[F (·· ·)] ∈ R }.
5 Unfortunately, the site shown in [9] is not accessible now. The examples are also described briefly as functional programs in [10], and some of the detailed programs can be found in [10].

Table 1
the results of the experiments


implementations check termination of input TRSs in advance of the completion procedures. The timeout for checking termination is 300 seconds in every call of the prover. Note that 60 seconds timeout is enough, except for treelist.
The examples (double, mirror and print-xml) contain the special primitive operator du described in Section 4. Hence, they are not confluent but innermost- confluent. The operator du is an inverse of itself [9,10]. Thus, the TRS Rdu is also
an inverse system of itself. For this reason, exceptionally, the inversion compiler does not produce any rules of InvDup but introduces Du instead of InvDup.
Due to the syntactic properties provided by the inversion compiler, all inverse DCTRSs in the experiments are pattern-stable and strongly non-erasing. Thus, the procedures in this paper are applicable to all of them.
Table 1 summarizes the results of the experiments for our approach running on
10 of the 15 examples previously mentioned, which were translated by hand into TRSs. 6 The second column labeled with ‘CR by [2]’ shows whether the input TRS
of the example is in the class shown in [2], in which the corresponding inverse TRS is orthogonal and thus confluent. In that case, the implementations only check termination of the inverse TRS. The third column labeled with ‘SN by Th. 5.2’ shows whether the input TRS satisfies the conditions in Theorem 5.2 (ii), that is, the corresponding inverse TRSs are terminating. Columns 4–6 show the results of the modified completion procedure. The fourth column shows the results of the modified completion (‘success’ or fail’) with the numbers of running ‘cycles’ in the sense of Definition 2.1, and with the average time (seconds) of 5 trials. The
number of cycles is the same as the number of applications of Orientation. As
described above, the implementation checks the termination of input TRSs before the completion procedure starts. Thus, we have the results ‘success (0c,	) and
1 call of provers’. The sixth column labeled by ‘ OVL’ shows whether or not the resulting TRSs are non-overlapping (√ means the resulting is non-overlapping, and
‘—’ means no resulting TRS). None of the resulting TRSs has overlays while some of them are overlapping. Columns 7–9 show the results of the simplified completion

6 The detail will be available from “http://www.trs.cm.is.nagoya-u.ac.jp/repius/experiments/”.

procedure, and the meaning of those columns is the same as columns 4–6.

Translation Back into Functional Programs
In general, it is difficult to decide a priority of rewrite rules. However, we do not have to consider such a priority for R2 that is computationally equivalent to nv(R1) because R2 is not only confluent but also non-overlapping. On the other hand, every convergent constructor TRS can be easily translated back into a func- tional program. However, it is not easy to translate convergent TRSs that are not constructor systems, into functional programs even if the TRSs are non-overlapping. The reason is that some rules contains non-‘well-formed’ patterns in their left-hand sides, for instance, InvSnoc(nil) in U(Inv(R1)).
In this subsection, we show a translation from R2 into a SML program. Such a translation has not been automated yet but we believe that the automation is feasible.
The U symbols Uρ introduced by the unraveling are often considered to express let, if or case clauses in functional programming languages. In the rewrite rules of R2, the U symbol U1 plays the role of a case clause as follows:
case InvSnoc( ys ) of (xs,y) => ( x::xs, y )
| InvSnoc( [] ) => (	[]	, y )
where InvSnoc( [] ) is not well-formed in the syntax of Standard ML. It is natural to write this fragment by introducing the extra case clause for ys as follows:
case ys of [] => ( [], y )
| _	=> (case InvSnoc( ys ) of (xs,y) => ( x::xs, y ) )
Thus, we translate the TRS R2 into the following program:
fun InvSnoc( x::ys ) =
case ys of [] => ( [], x )
| _ => (case InvSnoc(ys) of (xs,y) => ( x::xs, y ) );
Other approaches to translations are possible. For example, we can consider U1 as the composition of if and let clauses or as a ‘local function’ defined in InvSnoc.
In all of the 10 examples, we succeeded in translating by hand the resulting con- vergent TRSs back into SML programs by means of the mechanism in this subsection although the resulting systems of double, mirror, treelist, and print-xml have overlapping.

Concluding Remarks
In this paper, we have shown that completion procedures are useful in generating (innermost-)convergent inverse TRSs of injective TRSs. The completion procedures can be also used for checking whether or not a (innermost-)convergent constructor TRS is injective. This is because if a given convergent constructor TRS is not injec- tive, then the procedures never succeeds for the TRS. It is known to be undecidable

in general whether or not a function is injective [5]. In [17], however, it is shown that injectivity of linear treeless functions is decidable. On the other hand, some of the examples we mentioned in the experiments are non-linear or non-treeless while the method in this paper is not decidable.
Completion procedures are effective for solving word problems, for transforming equations into equivalent convergent systems, or for proving inductive theorems. As far as we know, there is no application of completion to program modification, and there is no program transformation based on unravelings in order to produce computationally equivalent systems.
The modified completion procedure in this paper does not succeed for every con- fluent and OP-SN DCTRSs while the latest transformation [30] based on Viry’s ap- proach [33] always succeeds. Consider the example in Section 1 again. By the trans-
formation in [30], we obtain the following convergent TRS instead of U(Inv(R1)):
⎧⎪	InvSnoc([y], z) → {⟨nil, y⟩},	⎫⎪
⎪⎨	InvSnoc(x :: ys, ⊥) → InvSnoc(x :: ys, {InvSnoc(ys, ⊥)}), ⎪⎬
⎪ InvSnoc(x :: ys, {⟨xs, y⟩}) → {⟨x :: xs, y⟩},	⎪
⎪⎩	InvSnoc({xs}, z) → {InvSnoc(xs, ⊥)},	{{x}}→ {x} ⎪⎭
∪{ c(x1,..., {xi},..., xn) → {c(x1,..., xn)}| c ∈ {::, ⟨, ⟩} }
where   and  are special function symbols not in the original signature. In this system, the term InvSnoc([a, b, c],  ) has a unique normal form  [a, b], c . As described in Section 1, however, it is difficult to translate the convergent TRS into a functional program because the system contains special symbols  and  , and overlapping rules. On the other hand, the modified completion procedure in this paper unexpectedly succeeded for all the experiments where the DCTRSs are confluent, and the resulting systems of the procedure are often non-overlapping. Moreover, for the DCTRSs that are not confluent but innermost-confluent, we pro- posed the simplified completion procedure but it is not yet known whether or not the transformation in [30] is applicable.
The inversion compiler LRinv, the closest one to the method in this paper, has been proposed for injective functions written in a functional language [9,7,10]. This compiler translates source programs into programs in a grammar language, and then inverts the grammar programs into inverse grammar programs. To eliminate nondeterminism in the inverse programs, their compiler applies LR parsing to the inverse programs. The classes for which LR parsing and the completion procedure work successfully are not well known, which makes it difficult to compare LRinv and our method. However, LRinv succeeds in generating inverse functions from the 5 scripts (reverse and so on) that we excluded from the experiments, where the main functions call non-injective functions such as the accumulator Rev. From this fact, LRinv seems to be stronger than the method in this paper but there must be plenty of room on improving the principle of inversion used in the partial inversion complier in [25]. As future work, we plan to extend the partial inversion compiler

for functions with accumulators such as Rev, and we also improve the modified and simplified completion procedures.

Acknowledgement
We are grateful to Germa´n Vidal and the anonymous reviewers for valuable com- ments for improving this paper. We also thank Tsubasa Sakata and Kazutoshi Seki for discussing correctness of the completion procedure on innermost reduction, and for helping the experiments. This work is partly supported by MEXT. KAKENHI #18500011, #20300010 and #20500008 and Kayamori Foundation of Informational Science Advancement.

References
Abramov, S. and R. Glu¨ck, The universal resolving algorithm and its correctness: Inverse computation in a functional language, Science of Computer Programming 43 (2002), pp. 193–229.
Almendros-Jim´enez, J. M. and G. Vidal, Automatic partial inversion of inductively sequential functions, in: Proc. of the 18th International Symposium on Implementation and Application of Functional Languages, Lecture Notes in Computer Science 4449 (2006), pp. 253–270.
Baader, F. and T. Nipkow, “Term Rewriting and All That,” Cambridge University Press, United Kingdom, 1998.
Dershowitz, N. and S. Mitra, Jeopardy, in: Proceedings of the 10th International Conference on Rewriting Techniques and Applications, Lecture Notes in Computer Science 1631, 1999, pp. 16–29.
Fu¨l¨op, Z., Undecidable properties of deterministic top-down tree transducers, Theoretical Computer Science 134 (1994), pp. 311–328.
Giesl, J., P. Schneider-Kamp and R. Thiemann, Automatic termination proofs in the dependency pair framework, in: Proc. of the 3rd International Joint Conference on Automated Reasoning, Lecture Notes in Computer Science 4130 (2006), pp. 281–286.
Glu¨ck, R. and M. Kawabe, A method for automatic program inversion based on LR(0) parsing, Fundam. Inform. 66 (2005), no. 4, pp. 367–395.
Gramlich, B., On the (non-)existence of least fixed points in conditional equational logic and conditional rewriting, in: Proc. 2nd Int. Workshop on Fixed Points in Computer Science – Extended Abstracts (2000), pp. 38–40.
Kawabe, M. and Y. Futamura, Case studies with an automatic program inversion system, in: Proc. of the 21st Conference of Japan Society for Software Science and Technology, 6C-3, 2004, pp. 1–5.
Kawabe, M. and R. Glu¨ck, The program inverter LRinv and its structure, in: Proc. of the 7th International Symposium on Practical Aspects of Declarative Languages, Lecture Notes in Computer Science 3350 (2005), pp. 219–234.
Knuth, D. E. and P. B. Bendix, Simple word problems in universal algebra, in: Computational Problems in Abstract Algebra (1970), pp. 263–297.
Krishna Rao, M. R. K., Relating confluence, innermost-confluence and outermost-confluence properties of term rewriting systems, Acta Informatica 33 (1996), no. 6, pp. 595–606.
Lucas, S., Context-sensitive computations in functional and functional logic programs, Journal of Functional and Logic Programming 1998 (1998), no. 1.
Lucas, S., C. March´e and J. Meseguer, Operational termination of conditional term rewriting systems, Information Processing Letters 95 (2005), no. 4, pp. 446–453.
Marchiori, M., Unravelings and ultra-properties, in: Proc. of the 5th International Conference on Algebraic and Logic Programming, Lecture Notes in Computer Science 1139 (1996), pp. 107–121.

Marchiori, M., On deterministic conditional rewriting, Computation Structures Group, Memo 405, MIT Laboratory for Computer Science (1997).
Matsuda, K., Z. Hu, K. Nakano, M. Hamana and M. Takeichi, Bidirectionalization transformation based on automatic derivation of view complement functions, in: Proc. of the 12th ACM SIGPLAN International Conference on Functional Programming (2007), pp. 47–58.
McCarthy, J., The inversion of functions defined by Turing machines, in: Automata Studies, Princeton University Press, 1956 pp. 177–181.
Mogensen, T. Æ., Semi-inversion of guarded equations., in: Proc. of the 4th International Conference on Generative Programming and Component Engineering, Lecture Notes in Computer Science 3676 (2005), pp. 189–204.
Mogensen, T. Æ., Semi-inversion of functional parameters, in: Proc. of the 2008 ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation (2008), pp. 21–29.
Nishida, N. and M. Sakai, Completion as Post-Process in Program Inversion of Injective Functions,
http://www.trs.cm.is.nagoya-u.ac.jp/~nishida/papers/ (2008), the full version of this paper.
Nishida, N., M. Sakai and T. Kato, Convergent term rewriting systems for inverse computation of injective functions, in: Proc. of the 9th International Workshop on Termination (2007), pp. 77–81.
Nishida, N., M. Sakai and T. Sakabe, On simulation-completeness of unraveling for conditional term rewriting systems, IEICE Technical Report SS2004-18, (2004), vol. 104, No. 243, pp. 25–30.
Nishida, N., M. Sakai and T. Sakabe, Generation of inverse computation programs of constructor term rewriting systems, The IEICE Trans. Inf.& Syst. J88-D-I (2005), no. 8, pp. 1171–1183 (in Japanese).
Nishida, N., M. Sakai and T. Sakabe, Partial inversion of constructor term rewriting systems, in: Proc. of the 16th International Conference on Rewriting Techniques and Applications, Lecture Notes in Computer Science 3467 (2005), pp. 264–278.
Ohlebusch, E., Termination of logic programs: Transformational methods revisited, Applicable Algebra in Engineering, Communication and Computing 12 (2001), no. 1-2, pp. 73–116.
Ohlebusch, E., “Advanced Topics in Term Rewriting,” Springer-Verlag, 2002.
Romanenko, A., Inversion and metacomputation, in: Proc. of the Symposium on Partial Evaluation and Semantics-Based Program Manipulation, SIGPLAN Notices 26 (1991), pp. 12–22.
Schernhammer, F. and B. Gramlich, On proving and characterizing operational termination of deterministic conditional rewrite systems, in: Proc. of the 9th International Workshop on Termination (2007), pp. 82–85.
Serbanuta, T.-F. and G. Rosu, Computationally equivalent elimination of conditions, in: Proc. of the 17th International Conference on Rewriting Techniques and Applications, Lecture Notes in Computer Science 4098 (2006), pp. 19–34.
Terese, “Term Rewriting Systems,” Cambridge University Press, 2003.
Toyama, Y., How to prove equivalence of term rewriting systems without induction, Theoretical Computer Science 90 (1991), no. 2, pp. 369–390.
Viry, P., Elimination of conditions, Journal of Symbolic Computation 28 (1999), no. 3, pp. 381–401.
Wehrman, I., A. Stump and E. M. Westbrook, Slothrop: Knuth-Bendix completion with a modern termination checker, in: Proc. of the 17th International Conference on Term Rewriting and Applications, Lecture Notes in Computer Science 4098 (2006), pp. 287–296.
