Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 341 (2018) 345–370
www.elsevier.com/locate/entcs

The Sequent Calculus of Skew Monoidal Categories
Tarmo Uustalu1
Reykjavik University, Reykjavik, Iceland TalTech University, Tallinn, Estonia
Niccolo` Veltri2
IT University of Copenhagen, Copenhagen, Denmark
Noam Zeilberger3
University of Birmingham, Birmingham, United Kingdom

Abstract
Szlach´anyi’s skew monoidal categories are a well-motivated variation of monoidal categories in which the unitors and associator are not required to be natural isomorphisms, but merely natural transformations in a particular direction. We present a sequent calculus for skew monoidal categories, building on the recent formulation by one of the authors of a sequent calculus for the Tamari order (skew semigroup categories). In this calculus, antecedents consist of a stoup (an optional formula) followed by a context (a list of formulae), and the connectives unit and tensor behave like in intuitionistic non-commutative linear logic (the logic of monoidal categories) except that the left rules may only be applied in stoup position. We show the admissibility of two forms cut (stoup cut and context cut), and prove the calculus sound and complete with respect to existence of maps in the free skew monoidal category. We then introduce an equivalence relation on sequent calculus derivations and prove that there is a one-to-one correspondence between equivalence classes of derivations and maps in the free skew monoidal category. Finally, we identify a subcalculus of focused derivations, and establish that it contains exactly one canonical representative from each equivalence class. As an end result, we obtain simple algorithms both for deciding equality of maps in the free skew monoidal category and for enumerating any homset without duplicates, in particular, for deciding whether there is a map. We have formalized this development in the dependently typed programming language Agda.
Keywords: skew monoidal categories, substructural logics, sequent calculus, nonstandard sequent forms, cut admissibility, focusing, Agda


1 Email: tarmo@ru.is
2 Email: nive@itu.dk
3 Email: n.zeilberger@cs.bham.ac.uk

https://doi.org/10.1016/j.entcs.2018.11.017
1571-0661/© 2018 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

Skew monoidal categories of Szlacha´nyi [16] are a variation of monoidal categories [13,3]. In a skew monoidal category, the unitors and associator are not required to be natural isomorphisms, but only natural transformations in a particular direction: a very simple definition, but with remarkably subtle properties. Szlacha´nyi’s original motivation was from quantum structures. In a different context, the first author of this paper ran into skew monoidal categories studying a generalization of monads to functors between different categories—relative monads [1].
Szachl´anyi’s paper was immediately noticed by Street, Lack and colleagues who have by now published a whole series of papers about them [9,10,6,4,5, . .. ]. Mac Lane’s original coherence theorem for monoidal categories is often summarized as “all diagrams commute”, but this is no longer true in the skew monoidal case: it is not the case that there is at most one map between any two objects in the free skew monoidal category on a set of generators (not even for one generator); also, it is not so easy to give a simple necessary and sufficient condition for the existence of such a map. Curiously, there is at most one map between any two objects in the free skew semigroup category, so multiple maps originate from the presence of the unit. As a step towards the coherence problem, Uustalu [17] showed that there is at most one map between an object and an object in normal form, and exactly one map between an object and that object’s normal form. Lack and Street [10] addressed the coherence problem by proving that there is a faithful, structure-preserving func- tor Fsk → Δ⊥ from the free skew monoidal category on one generating object to the strictly associative skew-monoidal category of finite non-empty ordinals and first-element-and-order-preserving functions. This analysis was further elaborated by Bourke and Lack [4] with a more explicit description of the morphisms of Fsk, although they still took as given the classical Tamari order [15], that is, the partial order on fully-bracketed words induced by a non-invertible associative law (or what can be equivalently seen as the free skew semigroup category on one generator).
In this paper, we present a sequent calculus for skew monoidal categories, build- ing on a recent proof-theoretic analysis of the Tamari order by the third author [18]. He observed that the Tamari order is precisely captured by a sequent calculus very similar to Lambek’s original calculus [11] for (what is nowadays referred to as) intuitionistic non-commutative linear logic, but with tensor as the only logical connective, and with the tensor left rule restricted to only apply to the first formula in the antecedent. The sequent calculus of [18] admits a strong form of cut elim- ination known as focusing completeness (after Andreoli [2]), with the consequence that valid entailments in the Tamari order are in one-to-one correspondence with focused sequent calculus derivations.
The situation becomes significantly more subtle with the addition of a unit. As we will explain, sequents now need to have an explicit “stoup”, corresponding to a distinguished first position in the antecedent which can either be empty or contain a formula. In particular, the left rules for unit and tensor can only be applied to a formula inside the stoup. We will develop the metatheory of this sequent calculus, and see that the presence of the stoup is crucial for adequacy with respect to skew

monoidal categories.
After establishing the admissibility of two cut rules (stoup cut and context cut), we prove that the sequent calculus is sound and complete with respect to the free skew monoidal category in the sense that morphisms can be mapped to derivations and vice versa. We then impose a certain notion of equivalence on sequent calculus derivations in order to prove that these two mappings are inverses of each other (i.e., that derivations in the sequent calculus and maps in the free skew monoidal category are in bijection). Finally, we identify the subcalculus of focused derivations, and show that every equivalence class of derivations contains exactly one focused derivation. This means that the focused sequent calculus characterizes the free skew monoidal category in a particularly appealing fashion. Moreover, as the focused representation of a derivation can be easily computed, we get a simple algorithm for deciding equality of morphisms in the free skew monoidal category: two morphisms are equal if and only if they correspond to the same focused derivation. Also, since focused derivations can be systematically searched for, we get an algorithm for enumerating (without duplications) any homset, in particular, for deciding whether a homset is inhabited.
Bourke and Lack [5] have recently related skew monoidal categories to what they call skew multicategories, establishing a correspondence between skew monoidal cat- egories and left representable skew multicategories. Their work is closely related to ours: in sequent calculus terms, their “tight maps” (resp. “loose maps”) corre- spond to derivations of sequents where the stoup is non-empty (resp. empty), while their notion of “left” representability (which weakens the more standard notion of representability for multicategories [12, Ch. 3]) is precisely analogous to the stoup restriction on left rules. We intend to elaborate on this connection in a future paper. This paper is organized as follows. In Section 2, we introduce skew monoidal categories and the free skew monoidal category as a deductive calculus. In Section 3, we introduce our sequent calculus, show that it admits the appropriate cut rules and satisfies a number of equations reminiscent of the equations of a multicategory. In Section 4, we present our soundness and completeness proofs of the sequent calculus wrt. the categorical calculus, introduce our notion of equality of derivations for the sequent calculus and prove that the derivations in the two calculi are in a bijection.
We develop focusing in Section 5. In Section 6, we conclude and outline some avenues of future work.
We have fully formalized the development of Sections 2-5 in the dependently typed programming language Agda.
Our Agda formalization is available at http://cs.ioc.ee/~niccolo/ skewmonseqcalc/. The formalization uses Agda 2.5.3 and Agda standard library 0.14.

A skew monoidal category [16] is a category C together with a distinguished object
I, a functor ⊗ : C× C → C and three natural transformations
λA : I ⊗ A → A	ρA : A → A ⊗ I	αA,B,C : (A ⊗ B) ⊗ C → A ⊗ (B ⊗ C)


satisfying the laws
​

(A ⊗ I) ⊗ B αA,I,B A¸⊗ (I ⊗ B)
,,

I	ρA⊗B
I t\	A ⊗ B
A⊗λ
  
A ⊗ B



(I ⊗ A) ⊗ B  αI,A,B  I ⊗¸(A ⊗ B)
λA⊗B	z  ,7λA⊗B
A ⊗ B
(A ⊗ B) ⊗ I αA,B,I A¸⊗ (B ⊗ I)
 ,

A ⊗ B

(A ⊗ (B ⊗ C)) ⊗ D 	αA,B⊗C,D	 A¸⊗ ((B ⊗ C) ⊗ D)
,,

αA,B,C⊗D

α A⊗B,C,D ¸

α A,B,C⊗D ¸
A⊗αB,C,D
  

((A ⊗ B) ⊗ C) ⊗ D
(A ⊗ B) ⊗ (C ⊗ D)
A ⊗ (B ⊗ (C ⊗ D))

Notice that (a)–(e) are directed versions of the original Mac Lane axioms [13]. Later, Kelly [8] observed that, when λ, ρ and α are natural isomorphisms, laws (a), (c), and (d) can be derived from (b) and (e). For skew monoidal categories, this is not the case.
Skew monoidal categories arise more often that one would perhaps first think, see [16,9,6,17]. The following are some examples from [17].
Example 2.1 A simple example of a skew monoidal category results from skewing a numerical addition monoid.
View the partial order (N, ≤) of natural numbers as a thin category. Fix some
.	.
natural number n and define I = n and x ⊗ y = (x − n)+ y where − is “truncating
.	.
subtraction”. We have λx : (n − n)+ x = 0 + x = x, ρx : x ≤ x max n = (x − n)+ n,
.	.	.	.
αx,y,z : (((x − n)+ y) − n)+ z ≤ (x − n)+ (y − n)+ z (by a small case analysis).
Example 2.2 The category Ptd of pointed sets and point-preserving functions has the following skew monoidal structure.
Take I = (1, ∗) and (X, p) ⊗ (Y, q)= (X + Y, inl p) (notice the “skew” in choosing the point). We define λX : (1, ∗) ⊗ (X, p)= (1 + X, inl ∗) → (X, p) by λX (inl ∗)= p, λX (inr x) = x (this is not injective). We let ρX : (X, p) → (X + 1, inl p) = (X, p) ⊗ (1, ∗) by ρX x = inl x (this is not surjective). Finally we let αX,Y,Z : ((X, p) ⊗ (Y, q)) ⊗ (Z, r) = ((X + Y )+ Z, inl (inl p)) → (X + (Y + Z), inl p) = (X, p) ⊗ ((Y, q) ⊗ (Z, r)) be the obvious isomorphism.
(We note that Ptd has coproducts too: (X, p)+ (Y, q) = ((X + Y )/∼, [inl p]) where ∼ is the equivalence relation on X + Y induced by inl p ∼ inr q.)

Example 2.3 Suppose given a monoidal category (C, I, ⊗) together with a lax monoidal comonad (D, e, m) on C. The category C has a skew monoidal structure with ID = I, A ⊗D B = A ⊗ D B. The unitors and associator are the following:

λD = I	 I⊗εA  I ⊗¸A  λA  A¸

ρD = A  ρA  A¸⊗ I  A⊗e  A¸⊗ D I


αD	(A⊗D B)⊗δ C ¸
αA,DB,D(D C)¸
A⊗mB,DC ¸

A,B,C = (A ⊗ D B) ⊗ DC 
(A ⊗ D B) ⊗ D (D C)
A ⊗ (DB ⊗ D (D C))
A ⊗ D (B ⊗ D C)


A similar skew monoidal category is also obtained from any oplax monoidal monad.
Example 2.4 Consider two categories J and C with a functor J : J → C, and assume that the left Kan extension LanJ F : C → C exists for every F : J → C. Then the functor category [J , C] has a skew monoidal structure given by I = J, F ⊗ G = LanJ F ◦ G. The unitors and associator are the canonical natural transformations λF : LanJ J ◦ F → F , ρF : F → LanJ F ◦ J, αF,G,H : LanJ (LanJ F ◦ G) ◦ H → LanJ F ◦ LanJ G ◦ H. This category becomes properly monoidal under certain conditions on J: ρ is an isomorphism if J is fully-faithful, and λ is an isomorphism if J is dense. (This is the example from our relative monads work [1]. Relative monads on J are skew monoids in the skew monoidal category [J , C].)
As our aim is to analyze the relationship of skew monoidal categories to a sequent calculus with the methods of structural proof theory, we will find it convenient to have an explicit description of the free skew monoidal category Fsk(At) overa set At (whose elements we view as propositional letters, also called atoms) as a deductive calculus.
The objects are given by the set Fma (of formulae). A formula is either an element X of At (an atomic formula); I; or A ⊗ B where A, B are formulae.
The maps between two objects A and B are derivations of singleton-antecedent, singleton-succedent sequents A ⇒ B constructed with the following inference rules




A ⇒ A
id	A ⇒ B	B ⇒ C A ⇒ C
comp	A ⇒ C	B ⇒ D
A ⊗ B ⇒ C ⊗ D

I ⊗ A ⇒ A λ	A ⇒ A ⊗ I ρ	(A ⊗ B) ⊗ C ⇒ A ⊗ (B ⊗ C) α
.
identified up to the least congruence = given by the equations on Figure 1. In ad-
dition to the laws (a)–(e) above, these equations state that id and comp satisfy the laws of a category, that ⊗ is functorial, and that λ, ρ and α are natural transfor- mations. In the term notation for derivations, we write g ◦ f for comp f g to agree with the standard categorical notation.

.
.
. f	. f
.	.
.	.
. g	. h
.	.	.
.	.
.	.
. f	. g
.	.	.

.		 id
.	. f
. f	.
id	.
. f	B ⇒ C  C ⇒ D
.	A ⇒ B  B ⇒ C	. h

A ⇒ B  B ⇒ B comp	=	.
.	=  A ⇒ A	A ⇒ B comp	.
comp	=
comp	.

A ⇒ B
A ⇒ B
A ⇒ B
A ⇒ B
A ⇒ B	B ⇒ D comp
A ⇒ D
A ⇒ C	C ⇒ D comp
A ⇒ D


id	id
.	.
.	.
. f	. h
.	.
.	.
.	.
. g	. k
.	.
.	.
.	.
. f	. g
.	.
.	.
.	.
. h	. k
.	.

A ⇒ A	B ⇒ B ⊗	.		 id
A ⇒ C  C ⇒ E comp
B ⇒ D  D ⇒ F
comp
.	A ⇒ C  B ⇒ D ⊗
C ⇒ E  D ⇒ F ⊗

A ⊗ B ⇒ A ⊗ B

.
.
. f
=  A ⊗ B ⇒ A ⊗ B
A ⇒ E	B ⇒ F ⊗
A ⊗ B ⇒ E ⊗ F
.
.
=
A ⊗ B ⇒ C ⊗ D	C ⊗ D ⇒ E ⊗ F
A ⊗ B ⇒ E ⊗ F
.
.
. f
comp

id	.
. f	.		 id	. f

I ⇒ I	A ⇒ B ⊗
.	λ	.
	 ρ  A ⇒ B  I ⇒ I ⊗	.	.	ρ

I ⊗ A ⇒ I ⊗ B	I ⊗ B ⇒ B λ
comp
I ⊗ A ⇒ B
= I ⊗ A ⇒ A	A ⇒ B comp	A ⇒ A ⊗ I	A ⊗ I ⇒ B ⊗ I I ⊗ A ⇒ B		A ⇒ B ⊗ I
comp
=  A ⇒ B  B ⇒ B ⊗ I comp
A ⇒ B ⊗ I

.	.
.	.
. g	. h
.	.	.
.	.
.	.
. f	. g
.	.	.

. f	B ⇒ E  C ⇒ F  ⊗
A ⇒ D  B ⇒ E  	. h
.	⊗

α
(A ⊗ B) ⊗ C ⇒ A ⊗ (B ⊗ C)
 A ⇒ D	B ⊗ C ⇒ E ⊗ F 
⊗
A ⊗ (B ⊗ C) ⇒ D ⊗ (E ⊗ F )
=	B ⊗ C ⇒ E ⊗ F	C ⇒ F ⊗
(A ⊗ B) ⊗ C ⇒ (D ⊗ E) ⊗ F
α
(D ⊗ E) ⊗ F ⇒ D ⊗ (E ⊗ F )

	 comp		 comp

(A ⊗ B) ⊗ C ⇒ D ⊗ (E ⊗ F )
(A ⊗ B) ⊗ C ⇒ D ⊗ (E ⊗ F )
A ⇒ A id  I ⊗ B ⇒ B λ

I ⇒ I ⊗ I ρ  I ⊗ I ⇒ I λ
A ⇒ A ⊗ I ρ  B ⇒ B id
α
(A ⊗ I) ⊗ B ⇒ A ⊗ (I ⊗ B)
⊗
A ⊗ (I ⊗ B) ⇒ A ⊗ B

I ⇒ I
=  I ⇒ I id
⊗
A ⊗ B ⇒ (A ⊗ I) ⊗ B
	 comp
(A ⊗ I) ⊗ B ⇒ A ⊗ B
=  A ⊗ B ⇒ A ⊗ B id

	 comp
A ⊗ B ⇒ A ⊗ B

α	λ
(I ⊗ A) ⊗ B ⇒ I ⊗ (A ⊗ B)	I ⊗ (A ⊗ B) ⇒ A ⊗ B
	 comp
(I ⊗ A) ⊗ B ⇒ A ⊗ B
ρ	α
A ⊗ B ⇒ (A ⊗ B) ⊗ I	(A ⊗ B) ⊗ I ⇒ A ⊗ (B ⊗ I)
I ⊗ A ⇒ A λ  B ⇒ B id
=	⊗
(I ⊗ A) ⊗ B ⇒ A ⊗ B
A ⇒ A id  B ⇒ B ⊗ I ρ

	 comp	.		 ⊗

A ⊗ B ⇒ A ⊗ (B ⊗ I)
=	A ⊗ B ⇒ A ⊗ (B ⊗ I)

α
((A ⊗ B) ⊗ C) ⊗ D ⇒ (A ⊗ B) ⊗ (C ⊗ D)
α
(A ⊗ B) ⊗ (C ⊗ D) ⇒ A ⊗ (B ⊗ (C ⊗ D))

	 comp
((A ⊗ B) ⊗ C) ⊗ D ⇒ A ⊗ (B ⊗ (C ⊗ D))

A ⇒ A id (B ⊗ C) ⊗ D ⇒ B ⊗ (C ⊗ D) α

(A ⊗ B) ⊗ C ⇒ A ⊗ (B ⊗ C) α  D ⇒ D id  (A ⊗ (B ⊗ C)) ⊗ D ⇒ A ⊗ ((B ⊗ C) ⊗ D) α  A ⊗ ((B ⊗ C) ⊗ D) ⇒ A ⊗ (B ⊗ (C ⊗ D)) ⊗
.				 comp
((A ⊗ B) ⊗ C) ⊗ D ⇒ (A ⊗ (B ⊗ C)) ⊗ D	(A ⊗ (B ⊗ C)) ⊗ D ⇒ A ⊗ (B ⊗ (C ⊗ D))
	 comp
((A ⊗ B) ⊗ C) ⊗ D ⇒ A ⊗ (B ⊗ (C ⊗ D))
Fig. 1. Skew monoidal category equations

A necessary condition for the existence of a map A ⇒ B is that A and B have the same underlying frontier of atoms (where the frontier ∂A of a formula A is defined by ∂X = X; ∂I = ( ); ∂(A ⊗ B) = ∂A, ∂B). However, this is not sufficient. For example, there are no maps X ⇒ I ⊗ X, X ⊗ I ⇒ X or X ⊗ (Y ⊗ Z) ⇒ (X ⊗ Y ) ⊗ Z (typing the inverses of the unitors and the associator in the monoidal case). Moreover, it is possible to have more than one map with the same
.
domain and codomain. The prototypical examples are ρI ◦ λI /= idI⊗I : I ⊗ I ⇒ I ⊗ I,

id(X⊗I)⊗Y  .	X	Y
X,I,Y
.
X⊗(I⊗Y )
X,I,Y	X	Y

monoidal case as variations of equations (a), (b)).
Sequent Calculus
We now introduce a sequent calculus for skew monoidal categories inspired by the sequent calculus for the Tamari order [18].
Sequents are of the form S | Γ ▶ A, where the succedent A is a single formula and the antecedent is a pair of a stoup S and a context Γ. A stoup S is either nothing (written −) or a single formula, while a context Γ is a (possibly empty) list of formulae.
Derivations are constructed with the following inference rules:




A |  ▶ A
A | Γ ▶ C
ax
−| A, Γ ▶ C
pass


−| Γ ▶ C
I | Γ ▶ C  IL	−|  ▶ I IR


A | B, Γ ▶ C
A ⊗ B | Γ ▶ C ⊗L
S | Γ ▶ A	−| Δ ▶ B
S | Γ, Δ ▶ A ⊗ B	⊗R


(pass stands for ‘passivate’.) There are no primitive cut rules in this calculus, but we will shortly see that two cut rules are admissible. (In Section 5, we will describe a further restriction to focused derivations.)
Although these rules look very similar to the rules of the I, ⊗ fragment of intuitionistic non-commutative linear logic (the sequent calculus of monoidal categories)—in particular, there is no left exchange rule, weakening or contraction—
, there are two crucial differences. First, the left logical rules are restricted to apply only at the leftmost end of the antecedent, to the formula within the stoup. This restriction was present in the sequent calculus for the Tamari order [18]. Second, and this is a new aspect, the stoup is allowed to be empty, permitting a distinction between antecedents of the form A | Γ (with A inside the stoup) and antecedents of the form − | A, Γ (with A outside the stoup). These ingredients are crucial for obtaining the correspondence with skew monoidal categories.
Let us demonstrate these restrictions in action on a few examples. We will state

the exact relationship of skew monoidal categories and our sequent calculus later, but one of the results will be that there is a map A ⇒ B in the free skew monoidal category iff the sequent A | ▶ B is derivable (see Theorems 4.4 and 4.5).
In the sequent calculus of monoidal categories, one can build the derivation
X ▶ X ax	Y ▶ Y ax
X, Y ▶ X ⊗ Y	⊗R	Z ▶ Z ax
X, Y, Z ▶ (X ⊗ Y ) ⊗ Z	⊗R
X, Y ⊗ Z ▶ (X ⊗ Y ) ⊗ Z ⊗L
X ⊗ (Y ⊗ Z) ▶ (X ⊗ Y ) ⊗ Z ⊗L


corresponding to α−1
: X ⊗ (Y ⊗ Z) ⇒ (X ⊗ Y ) ⊗ Z. Notice that the second

application of the ⊗L rule (counting from the bottom) is to the formula second from the left in the antecedent. In the skew monoidal calculus, the corresponding sequent has no derivation; attempts to build one fail:


??	??
X | Y ⊗ Z ▶ X ⊗ Y	−| ▶ Z
??	??
X |  ▶ X ⊗ Y	−| Y ⊗ Z ▶ Z

X | Y ⊗ Z ▶ (X ⊗ Y ) ⊗ Z	⊗R
X ⊗ (Y ⊗ Z) |  ▶ (X ⊗ Y ) ⊗ Z ⊗L
X | Y ⊗ Z ▶ (X ⊗ Y ) ⊗ Z	⊗R
X ⊗ (Y ⊗ Z) |  ▶ (X ⊗ Y ) ⊗ Z ⊗L

(Thanks to cut-freeness, the sequent calculus admits a root-first proof search strat- egy deciding derivability. We will say more about this in Section 5.)
In the same vein, one can build a derivation of X ⊗ I ▶ X in the sequent calculus

of monoidal categories (corresponding to ρ−1
: X ⊗ I ⇒ X), but this relies on

applicability of IL to the second formula in an antecedent, and there is no derivation of X ⊗ I | ▶ X in the skew monoidal sequent calculus.
Finally, corresponding to λ−1 : X ⇒ I ⊗ X, one has the following derivation in the sequent calculus of monoidal categories:
▶ I IR	X ▶ X ax
X ▶ I ⊗ X	⊗R
But there is no such derivation in the skew monoidal sequent calculus:
??	??
X |  ▶ I	−| ▶ X
X |  ▶ I ⊗ X	⊗R
This time the reason is that, while the context can be split freely in an ⊗R inference, the stoup formula must go to the first premise.
At the same time, derivations corresponding to λX , ρX , αX,Y,X can be smoothly constructed in our calculus despite the restrictions. They are needed and appear in the proof of Theorem 4.5 below.
As a more involved example, here is a derivation corresponding to the (inciden- tally) unique map (X ⊗ (I ⊗Y )) ⊗Z ⇒ (X ⊗I) ⊗ (Y ⊗Z) in the free skew monoidal

category:



Y |  ▶ Y
−| Y ▶ Y

ax
pass	Z |  ▶ Z
−| Z ▶ Z

ax pass


X |  ▶ X ax	−| ▶ I IR
X |  ▶ X ⊗ I	⊗R
−| Y, Z ▶ Y ⊗ Z	⊗R
I | Y, Z ▶ Y ⊗ Z  IL
I ⊗ Y | Z ▶ Y ⊗ Z ⊗L
pass
−| I ⊗ Y, Z ▶ Y ⊗ Z

X | I ⊗ Y, Z ▶ (X ⊗ I) ⊗ (Y ⊗ Z)	⊗R
X ⊗ (I ⊗ Y ) | Z ▶ (X ⊗ I) ⊗ (Y ⊗ Z) ⊗L
(X ⊗ (I ⊗ Y )) ⊗ Z |  ▶ (X ⊗ I) ⊗ (Y ⊗ Z) ⊗L
The reader is invited to check that, in contrast, there is no derivation of the converse sequent, although the sequent (X ⊗ I) ⊗ (Y ⊗ Z) ▶ (X ⊗ (I ⊗ Y )) ⊗ Z is derivable in the sequent calculus of monoidal categories.
We now proceed to some proof-theoretic results. We begin with the simple observation that the left logical rules IL and ⊗L are invertible.
Lemma 3.1 (Invertibility of IL and ⊗L) The following rules are admissible.


I | Γ ▶ C
−| Γ ▶ C IL−1
A ⊗ B | Γ ▶ C
A | B, Γ ▶ C  ⊗L−1

Lemma 3.2 The following equations hold:


.
.
. f
.
−| Γ ▶ C
.
.
. f
.	.	.
. f	A | B, Γ ▶ C	. f

IL	=
.		 ⊗L	=	.

I | Γ ▶ C
−| Γ ▶ C
A ⊗ B | Γ ▶ C
A | B, Γ ▶ C



−| Γ ▶ C
IL−1	⊗L−1
A | B, Γ ▶ C


In contrast, the left structural rule pass is not invertible. For example, although there is no derivation of X |	▶ I ⊗ X (as we saw above), there is a derivation of
−| X ▶ I ⊗ X:
ax
X | ▶ X

−| ▶ I IR
	 pass
−| X ▶ X

⊗R
−| X ▶ I ⊗ X
Likewise, ⊗R is non-invertible, even when there is only one way to split the context because it is empty. For example, the sequent X ⊗ Y | ▶ X ⊗ Y is an instance of ax, but X ⊗ Y | ▶ X and −| ▶ Y are both non-derivable.
The sequent calculus admits two different cut rules, one for substitution into the stoup, one for substitution into the context.

Proposition 3.3 (Admissibility of cuts) The following rules are admissible.


S | Γ ▶ A	A | Δ ▶ C
S | Γ, Δ ▶ C	scut
−| Γ ▶ A	S | Δ0, A, Δ1 ▶ C
S | Δ0, Γ, Δ1 ▶ C	ccut


Proof. The two cut rules are defined by mutual induction on the cut formula A, with each rule requiring a separate induction on derivations.
We start with the definition of scut. Let f : S | Γ ▶ A and g : A | Δ ▶ C be two derivations. The proof proceeds by induction on f .
Case f =df ax. In particular, S = A and Γ is empty. We define:
.

ax
A | ▶ A
.
. g
.
A | Δ ▶ C


scut
=df
.
.
. g
.
A | Δ ▶ C

A | Δ ▶ C
Case f =df pass fj for some fj : Aj | Γj ▶ A. In particular, S = − and Γ = Aj, Γj. We define:
.	.
. f	. f′	. g
.

A′ | Γ′ ▶ A	. g
A′ | Γ′ ▶ A
A | Δ ▶ C

pass	.
′  ′
=df	′	′
scut

−| A , Γ ▶ A
A | Δ ▶ C
A | Γ , Δ ▶ C

−| A′, Γ′, Δ ▶ C	scut
pass
−| A′, Γ′, Δ ▶ C

Case f =df IL fj for some fj : −| Γ ▶ A. In particular, S = I. We define:
.	.
. f	. f′	. g
.

−| Γ ▶ A	. g
IL	.
=df
−| Γ ▶ A
A | Δ ▶ C
scut

I | Γ ▶ A
A | Δ ▶ C
−| Γ, Δ ▶ C

scut
I | Γ, Δ ▶ C
I | Γ, Δ ▶ C  IL

Case f =df ⊗L fj for some fj : B | D, Γ ▶ A. In particular, S = B ⊗D. We define:
.	.
. f	. f′	. g
.

B | D, Γ ▶ A	. g
⊗L	.
=df
B | D, Γ ▶ A
A | Δ ▶ C
scut

B ⊗ D | Γ ▶ A
A | Δ ▶ C
scut
B | D, Γ, Δ ▶ C
⊗L

B ⊗ D | Γ, Δ ▶ C	B ⊗ D | Γ, Δ ▶ C
Case f =df IR. In particular, S = −, Γ is empty and A = I.


−| ▶ I IR
.
.
. g
.
I | Δ ▶ C


=df
.
.
. g
.
I | Δ ▶ C

scut
−| Δ ▶ C
−| Δ ▶ C IL−1

Case f =df ⊗R f1 f2 for some f1 : S | Γ1 ▶ A1 and f2 : −| Γ2 ▶ A2. In particular, Γ = Γ1, Γ2 and A = A1 ⊗ A2. At this point, we proceed by induction on the derivation g : A1 ⊗ A2 | Δ ▶ C. Notice that g can neither be of the form pass nor IR since the stoup of its endsequent is non-empty. Moreover, g can neither be of the form IL since the stoup formula is not equal to I. Therefore, we only have to check the three remaining cases.

· Case g =df ax. In particular, Δ is empty and C = A1 ⊗ A2. We define:


.
.
. f
.
S | Γ1 ▶ A1
.
.
. f
.
−| Γ2 ▶ A2
⊗R


ax	=df
.
.
. f
.
S | Γ1 ▶ A1
.
.
. f
.
−| Γ2 ▶ A2

S | Γ1, Γ2 ▶ A1 ⊗ A2
A1 ⊗ A2 | ▶ A1 ⊗ A2
scut
⊗R
S | Γ1, Γ2 ▶ A1 ⊗ A2

S | Γ1, Γ2 ▶ A1 ⊗ A2
· Case g =df ⊗R g1 g2 for some g1 : A1 ⊗ A2 | Δ1 ▶ C1 and g2 : − | Δ2 ▶ C2. In particular, Δ = Δ1, Δ2 and C = C1 ⊗ C2. We define:


.
.
. f
.
S | Γ1 ▶ A1
.
.
. f
.
−| Γ2 ▶ A2
⊗R
.
.
. g
.
A1 ⊗ A2 | Δ1 ▶ C1
.
.
. g
.
−| Δ2 ▶ C2
⊗R

S | Γ1, Γ2 ▶ A1 ⊗ A2
A1 ⊗ A2 | Δ1, Δ2 ▶ C1 ⊗ C2
scut

S | Γ1, Γ2, Δ1, Δ2 ▶ C1 ⊗ C2


S | Γ
.
.
. f
.
1 ▶ A1

−| Γ
.
.
. f
.	.
2 ▶ A2	. g
⊗R	.	.

=df
S | Γ1, Γ2
▶ A1
⊗ A2
A1 ⊗ A2
| Δ1
▶ C1
.
. g
scut	.

S | Γ1, Γ2, Δ1 ▶ C1
S | Γ1, Γ2, Δ1, Δ2 ▶ C1 ⊗ C2
−| Δ2 ▶ C2
⊗R

· Case g =df ⊗L gj for some gj : A1 | A2, Δ ▶ C. We define:
.	.
.	.
. f	. f
.	.	.

S | Γ1 ▶ A1
−| Γ2 ▶ A2
⊗R
A1 | A2, Δ ▶ C
⊗L

S | Γ1, Γ2 ▶ A1 ⊗ A2
A1 ⊗ A2 | Δ ▶ C
scut

S | Γ1, Γ2, Δ ▶ C
.	.
.	.
. f	. g
.	.	.

.
. f2
S | Γ1
▶ A1
A1 | A2, Δ ▶ C

=df
.		 scut

−| Γ2 ▶ A2
S | Γ1, A2, Δ ▶ C
ccut

S | Γ1, Γ2, Δ ▶ C
(Alternatively, the cuts on A1 and A2 can be performed in the other order.)
We continue with the proof of ccut. Let f : −| Γ ▶ A and g : S | Δ0, A, Δ1 ▶ C be two derivations. The proof proceeds by induction on g. Notice that the g can neither be of the form ax nor IR, since the context of its endsequent is non-empty. Therefore, we only have to check the four remaining cases.
Case g =df pass gj, for some gj : Aj | Δj ▶ C. In particular, S = − and Δ0, A, Δ1 =
Aj, Δj. We proceed by checking if the context Δ0 is empty or not.
· If Δ0 is empty, then Aj = A and Δj = Δ1. We define:
.
. g	.
.	. f	. g
. f	A | Δ1 ▶ C	.	.

.		 pass
=df
−| Γ ▶ A
A | Δ1 ▶ C

−| Γ ▶ A
−| A, Δ1 ▶ C
ccut
−| Γ, Δ1 ▶ C
scut

−| Γ, Δ1 ▶ C
· If Δ0 =df Ajj, Δj , then Ajj = Aj and Δj = Δj , A, Δ1. We define:
0	0


.
.
. g	. f	. g
.

.	A′ | Δ′ , A, Δ ▶ C
−| Γ ▶ A
A′ | Δ′ , A, Δ ▶ C

. f		0	1		0	1

.	pass
′	′
=df	′	′
ccut

−| Γ ▶ A  −| A , Δ0, A, Δ1 ▶ C
−| A′, Δ′ , Γ, Δ1 ▶ C
ccut
 A | Δ0, Γ, Δ1 ▶ C  pass
−| A′, Δ′ , Γ, Δ1 ▶ C

Case g =df IL gj for some gj : −| Δ0, A, Δ1 ▶ C. In particular, S = I. We define:
.	.
.	.
. g	. f	. g
.

. f	−| Δ0, A, Δ1 ▶ C
−| Γ ▶ A
−| Δ0, A, Δ1 ▶ C

.		 IL
=df
ccut

−| Γ ▶ A	I | Δ0, A, Δ1 ▶ C
−| Δ0, Γ, Δ1 ▶ C

I | Δ0, Γ, Δ1
ccut
▶ C
I | Δ0, Γ, Δ1
▶ C  IL

Case g =df ⊗L gj for some gj : B ⊗ D | Δ0, A, Δ1 ▶ C. In particular, S = B ⊗ D. We define:

.	.
.	.
. g	. f	. g
.

. f	B | D, Δ0, A, Δ1 ▶ C
−| Γ ▶ A
B | D, Δ0, A, Δ1 ▶ C

.		 ⊗L
=df
ccut

−| Γ ▶ A
B ⊗ D | Δ0, A, Δ1 ▶ C
ccut
B | D, Δ0, Γ, Δ1 ▶ C
⊗L

B ⊗ D | Δ0, Γ, Δ1 ▶ C	B ⊗ D | Δ0, Γ, Δ1 ▶ C
Case g =df ⊗R g1 g2 for some g1 : S | Λ1 ▶ C1 and g2 : −| Λ2 ▶ C2. In particular, C = C1 ⊗ C2 and Δ0, A, Δ1 = Λ1, Λ2. We proceed by checking if the formula A occurs in Λ1 or in Λ2.
· If A occurs in Λ1, we have Λ1 = Δ0, A, Δj and Δ1 = Δj , Λ2. We define:


.
.
. g
.	.
.	S | Δ , A, Δ′ ▶ C
.
.
. g
.
−| Λ ▶ C
.
.
. f
.
−| Γ ▶ A
.
.
. g
.	.
S | Δ , A, Δ′ ▶ C	.

. f		0	1	1	2	2
′	⊗R
=df
	0	1	1
′
. g
ccut	.

−| Γ ▶ A	S | Δ0, A, Δ1, Λ2 ▶ C1 ⊗ C2	S | Δ0, Γ, Δ1 ▶ C1	−| Λ2 ▶ C2

S | Δ , Γ, Δ′ , Λ
▶ C ⊗ C
ccut
S | Δ , Γ, Δ′ , Λ
⊗R
▶ C ⊗ C

0	1  2	1	2	0	1  2	1	2
· If A occurs in Λ2, we have Λ2 = Δj , A, Δ1 and Δ0 = Λ1, Δj . We define:
0	0


.
.
. g
.
.	S | Λ ▶ C
.
.
. g
.
−| Δ′ , A, Δ ▶ C
.
.
. f
.	.
.	−| Γ ▶ A
.
.
. g
.
−| Δ′ , A, Δ ▶ C

. f		1	1	0	1	2
′	⊗R
=df
. g		0	1	2
′
ccut

−| Γ ▶ A	S | Λ1, Δ0, A, Δ1 ▶ C1 ⊗ C2	S | Λ1 ▶ C1	−| Δ0, Γ, Δ1 ▶ C2

S | Λ , Δ′ , Γ, Δ
▶ C ⊗ C
ccut
S | Λ , Δ′ , Γ, Δ
⊗R
▶ C ⊗ C

1	0	1	1	2
1	0	1	1	2
2

The cut rules obey a number of equations reminiscent of the unit and associa- tivity laws of multicategories. More precisely, our sequent calculus can be seen as a particular generalized multicategory in the sense of [12, Ch. 4]. We give the details of this connection in Section A.
Proposition 3.4 The equations in Figure 2 hold.
This proposition is used in the proofs of Theorems 4.14 and 4.19.

.
. ax
.
A | ▶ A
.
.
. f
.
A | Δ ▶ C

.
.
. f
scut	.



A | ▶ A
A | Δ ▶ C	=
ax	.
. f
A | Δ ▶ C

	 pass
−| A ▶ A
.
S | Δ0, A, Δ1 ▶ C
.
.
. f
ccut	.

S | Δ0, A, Δ1 ▶ C	=	S | Δ0, A, Δ1 ▶ C
	.	
.
. f

.		 ax
S | Γ ▶ A  A | ▶ A
scut
S | Γ ▶ A	=
.
.
. f
.
S | Γ ▶ A

.
.
. g
.	.
. f	A | Δ ▶ B
.
.
. h
.
B | λ ▶ C
.
.
. f
.
S | Γ ▶ A
.
.
. g
.	.
A | Δ ▶ B	. h

.		 scut
scut	.

S | Γ ▶ A
A | Δ,λ ▶ C
scut
S | Γ, Δ ▶ B
B | λ ▶ C
scut

S | Γ, Δ,λ ▶ C
.
.
. g	. h
.	.
=	S | Γ, Δ,λ ▶ C
.	.
.	.
. f	. g
.	.	.

. f	S | Δ0, A, Δ1 ▶ B  B | λ ▶ C
−| Γ ▶ A S | Δ0, A, Δ1 ▶ B	. h

.		 scut
ccut	.

−| Γ ▶ A
S | Δ0, A, Δ1,λ ▶ C
ccut
S | Δ0, Γ, Δ1 ▶ B
B | λ ▶ C
scut

S | Δ0, Γ, Δ1,λ ▶ C
.
.
. g	. h
.	.
=	S | Δ0, Γ, Δ1,λ ▶ C
.	.
.	.
. f	. g
.	.	.

.	−| Δ , A, Δ ▶ B  S | λ ,B,λ ▶ C
−| Γ ▶ A  −| Δ , A, Δ ▶ B	.

. f	0	1	0	1	0	1	. h

.		 ccut
ccut	.

−| Γ ▶ A
S | λ0, Δ0, A, Δ1, λ1 ▶ C
ccut
−| Δ0, Γ, Δ1 ▶ B
S | λ0,B, λ1 ▶ C
ccut

S | λ0, Δ0, Γ, Δ1, λ1 ▶ C	=	S | λ0, Δ0, Γ, Δ1, λ1 ▶ C

.
.
. f
.
.	−| Γ ▶ A
.
.
. g
.
A | Δ ,A , Δ ▶ C
.
.
. f
.
.	S | Γ ▶ A
.
.
. g
.
A | Δ ,A , Δ ▶ C

. f1
2	2	1
1  2	2
. f2
1	1	1
1  2	2

.		 ccut	.		 scut

S | Γ1 ▶ A1
A1 | Δ1, Γ2, Δ2 ▶ C
scut
−| Γ2 ▶ A2
S | Γ1, Δ1, A2, Δ2 ▶ C
ccut

S | Γ1, Δ1, Γ2, Δ2 ▶ C
.	.
.	.
. f	. g
.	.	.
=	S | Γ1, Δ1, Γ2, Δ2 ▶ C
.
.
. f	. g
.	.

.	−| Γ ▶ A	S | Δ ,A , Δ ,A , Δ ▶ C
.	−| Γ ▶ A	S | Δ ,A , Δ ,A , Δ ▶ C

. f1
2	2	0  1
1  2	2
. f2
1	1	0  1
1  2	2

.		 ccut	.		 ccut

−| Γ1 ▶ A1
S | Δ0, A1, Δ1, Γ2, Δ2 ▶ C
ccut
−| Γ2 ▶ A2
S | Δ0, Γ1, Δ1, A2, Δ2 ▶ C
ccut

S | Δ0, Γ1, Δ1, Γ2, Δ2 ▶ C	=	S | Δ0, Γ1, Δ1, Γ2, Δ2 ▶ C
Fig. 2. Generalized multicategory equations

Adequacy
In this section, we show the connection between the categorical calculus and the sequent calculus. We start by showing how to interpret antecedents as formulae. This is performed in several steps, by first specifying how to interpret stoups and contexts.
Stoups are interpreted as formulae in Fma:
J−⟨⟨ =df I	JA⟨⟨ =df A.
A context is interpreted as an endomap on Fma. Given a context Γ, we write C ⟨⟨Γ) for the application of the interpretation of Γ to a formula C. The interpre- tation of contexts is the right action of contexts on formulae induced by ⊗:
C ⟨⟨ ) =df C,	C ⟨⟨A, Γ) =df (C ⊗ A) ⟨⟨Γ)
Using the interpretation of stoups and contexts, we define the interpretation of antecedents as formulae in Fma:
JS | Γ) =df JS⟨⟨ ⟨⟨Γ)
Explicitly, the interpretation of antecedents works as follows.	Let Γ =
A1,..., An. Given a formula A, we have JA | Γ) = (... ((A ⊗ A1) ⊗ A2) ... ) ⊗ An.
We also have J−| Γ) = (... ((I ⊗ A1) ⊗ A2) ... ) ⊗ An, i.e., J−| Γ) = JI | Γ).
In other words, depending on whether a sequent has an empty or non-empty stoup, the antecedent has to be interpreted with an I as the leftmost factor in the big tensor product or not. This is an important observation and the reason why stoups are needed in the first place: to give a correct interpretation of sequents. Indeed, suppose we formulated the rules of the sequent calculus conflating the stoup and the context together into a flat antecedent. We would still interpret antecedents as big tensor products, but we could in principle choose to add an I in the leftmost position or not. Either way, the interpretation of sequents would be unsound. In fact, if the interpretation of an antecedent A1,..., An were (... (A1⊗A2)⊗... )⊗An, then the derivable sequent X ▶ I ⊗ X where X is an atom would be interpreted as X ⇒ I⊗X, which cannot be derived in the categorical calculus. On the other hand, if the interpretation of an antecedent A1,..., An were (... ((I ⊗ A1) ⊗ A2) ... ) ⊗ An, then the derivable sequent X ⊗ Y ▶ (I ⊗ X) ⊗ Y where X and Y are atoms would be interpreted as I ⊗ (X ⊗ Y ) ⇒ (I ⊗ X) ⊗ Y , which is again not derivable in the categorical calculus.
We now show that the sequent calculus is sound. This relies on three lemmata about the interpretation of antecedents.
Lemma 4.1 For any derivation f : A ⇒ B and context Γ, there is a derivation
Jf | Γ) : JA | Γ) ⇒ JB | Γ).
Proof. We proceed by induction on Γ. If Γ is empty, then we take Jf | ) =df f . If Γ= C, Γj, then we take Jf | C, Γj) =df Jf ⊗ idC | Γj).	2

Lemma 4.2 For any formulae A, B and context Γ, there is a derivation ψA,B,Γ :
JA ⊗ B | Γ) ⇒ A ⊗ JB | Γ).
Proof. We proceed by induction on Γ. If Γ is empty, then we take ψA,B,( )=df idA⊗B. If Γ = C, Γj, then we take ψA,B,(C,Γ′) =df ψA,B⊗C,Γ′ ◦ Jα | Γj).	2
Lemma 4.3 For any stoup S and contexts Γ, Δ, there is a derivation ϕS,Γ,Δ : JS |
Γ, Δ) ⇒ JS | Γ) ⊗ J−| Δ).

Proof. It is sufficient to construct ϕj
: A ⟨⟨Γ, Δ) ⇒ A ⟨⟨Γ)⊗J−| Δ) for A : Fma,

and define ϕS,Γ,Δ =df ϕj
. We proceed by induction on Γ. If Γ is empty, then we

have to construct ϕj
: JA | Δ) ⇒ A⊗ J−| Δ). We take ϕj
=df ψA,I,Δ ◦ Jρ |

Δ). If Γ = C, Γj, then we take ϕj
′	=df ϕj
′	.	2

A,(C,Γ ),Δ	A⊗C,Γ ,Δ
Theorem 4.4 (Soundness) For any derivation f : S | Γ ▶ C, there is a derivation sound f : JS | Γ) ⇒ C. As a special case, for f : A | ▶ C, we have a derivation sound f : A ⇒ C.
Proof. The proof proceeds by induction on f .
Case f =df ax. In particular, we have S = C and Γ is empty. We define:


sound
, C | ▶ C ax 


=df
C ⇒ C id

JC | ) ⇒ C

Case f =df pass fj, for some fj : A | Γj ▶ C. In particular, S = − and Γ = A, Γj. We define:


.  ′	⎞	Jλ | Γ′)
.
. sound f′
.

. f	′	′	′

sound ⎜⎝
.
A | Γ′ ▶ C
⎟⎠ =df
JI ⊗ A | Γ ) ⇒ JA | Γ )
′
JA | Γ ) ⇒ C
comp

	

Case f =df IL fj, for some fj : −| Γ ▶ C. In particular, S = I. We define:
.	.
. f	. sound f′
.

sound ⎜⎝
—| Γ ▶ C
I | Γ ▶ C IL
⎟⎠ =df
J—| Γ) ⇒ C
JI | Γ) ⇒ C

Case f =df ⊗L fj, for some fj : A | B, Γ ▶ C. In particular, S = A⊗B. We define:
.	.
. f	. sound f′
.

sound ⎜⎝
 A | B, Γ ▶ C
⊗L
A ⊗ B | Γ ▶ C
⎟⎠ =df
 JA | B, Γ) ⇒ C
JA ⊗ B | Γ) ⇒ C

Case f =df IR. In particular, S = −, A = I and Γ is empty.


sound
, —| ▶ I IR


=df
I ⇒ I id

J—| ) ⇒ I

Case f =df ⊗R f1 f2, for some f1 : S | Γ1 ▶ C1 and f2 : −| Γ2 ▶ C2. In particular Γ= Γ1, Γ2 and C = C1 ⊗ C2. We define:

.
.
. f	. f
.

sound ⎜⎝
S | Γ1 ▶ C1 —| Γ2 ▶ C2
⊗R
S | Γ1, Γ2 ▶ C1 ⊗ C2

.	.
.	.
.	f	.	f
.	.

=		 ϕS,Γ ,Γ
JS | Γ1) ⇒ C1	J—| Γ2) ⇒ C2
⊗

df	JS | Γ , Γ ) ⇒ JS | Γ ) ⊗ J—| Γ )
1 2
JS | Γ ) ⊗ J—| Γ ) ⇒ C ⊗ C

1  2	1
2	1
JS | Γ1, Γ2) ⇒ C1 ⊗ C2
2	1	2
comp
2


Next, we show that the sequent calculus is complete. Crucially, this relies on admissibility of scut, which we had to prove admissible together with ccut. (We chose to not have primitive cut rules in our sequent calculus, but completeness depends on their availability. Alternatively, one could take scut and ccut as primitive rules, and give a separate proof of cut elimination. This would slightly reduce the level of conceptual dependency, although it amounts to essentially the same amount of work in the end.)
Theorem 4.5 (Completeness) For any derivation f : A ⇒ C, there is a deriva- tion cmplt f : A | ▶ C.
Proof. Just like the proof of soundness, the proof is by induction on the given derivation f .
Case f = idA. In particular, A = C. We define:
cmplt , A ⇒ A id   =df	A | ▶ A ax
Case f = h ◦ g where g : A ⇒ B and h : B ⇒ C. This is the case where we need
scut. We define:

.	.
.	.
. g	. h
.	.
cmplt
.
. cmplt g
.
⎟ =	A | ▶ B
.
. cmplt h
.
B | ▶ C

A ⇒ B  B ⇒ C comp	df
A ⇒ C
scut
A | ▶ C

Case f = f1⊗f2 where f1 : A1 ⇒ C1 and f2 : A2 ⇒ C2. In particular, A = A1⊗A2
and C = C1 ⊗ C2. We define:


.
.
. f	. f
.
.
.
.	f
.	.
.	f	A2 | ▶ C2 pass

cmplt ⎜⎝
A1 ⇒ C1  A2 ⇒ C2 ⊗
A1 ⊗ A2 ⇒ C1 ⊗ C2
⎟⎠ =df
A1 | ▶ C1	—| A2 ▶ C2
⊗R
A1 | A2 ▶ C1 ⊗ C2

⊗L
A1 ⊗ A2 | ▶ C1 ⊗ C2
Case f = λC. In particular, A = I ⊗ C. We define:


ax
C | ▶ C


cmplt
, I ⊗ C ⇒ C λ

=df
pass
—| C ▶ C
I | C ▶ C  IL

⊗L
I ⊗ C | ▶ C

Case f = ρA. In particular, C = A ⊗ I. We define:



cmplt
, A ⇒ A ⊗ I ρ


=df
ax	IR
A | ▶ A	—| ▶ I
⊗R
A | ▶ A ⊗ I


Case f = αA′,B,C′ . In particular, A = (Aj ⊗ B) ⊗ Cj and C = Aj ⊗ (B ⊗ Cj). We define:



ax
B | ▶ B
′
C′ | ▶ C′ ax
pass
—| C′ ▶ C′
′	⊗R


cmplt
, (A′ ⊗ B) ⊗ C′ ⇒ A′ ⊗ (B ⊗ C′) α
 	
′	′ ax
df

 B | C ▶ B ⊗ C 
pass
—| B, C′ ▶ B ⊗ C′






The function sound is a left inverse of cmplt
A′ | B, C′ ▶ A′ ⊗ (B ⊗ C′)	⊗R
A′ ⊗ B | C′ ▶ A′ ⊗ (B ⊗ C′) ⊗L
(A′ ⊗ B) ⊗ C′ | ▶ A′ ⊗ (B ⊗ C′) ⊗L
2
.

up to =. In order to prove this, we
show admissibility of two categorical rules, ssubst and csubst. These rules correspond to the rules scut and ccut of the sequent calculus. This is made precise by showing that the function sound sends a derivation ending with an scut (or ccut) inference into a derivation ending with an ssubst (or csubst) inference.
The proof of admissibility of ssubst and csubst relies on the following additional lemma about the interpretation of antecedents.
Lemma 4.6 For any stoup S and contexts Γ, Δ, there is a derivation θS,Γ,Δ : JS |
Γ, Δ) ⇒ JJS | Γ) | Δ).


Proof. It is sufficient to construct θj
: A ⟨⟨Γ, Δ) ⇒ (A ⟨⟨Γ)) ⟨⟨Δ) for A : Fma,

and define θS,Γ,Δ =df θj
. We proceed by induction on Γ. If Γ is empty, we

take θj
=df id. If Γ = C, Γj, then we take θj	′	=df θj	.	2

A,( ),Δ
A,(C,Γ ),Δ
A⊗C,Γ,Δ

Lemma 4.7 The following rules are admissible:

JS | Γ) ⇒ A	JA | Δ) ⇒ C
JS | Γ, Δ) ⇒ C	ssubst
J−| Γ) ⇒ A	JS | Δ0, A, Δ1) ⇒ C
JS | Δ0, Γ, Δ1) ⇒ C	csubst

Lemma 4.8 The following equations hold:

.	.
.	.
. f	. g
.	.
.
. sound f
.
.
. sound g
.

sound ⎜⎝
S | Γ ▶ A  A | Δ ▶ C
S | Γ, Δ ▶ C
scut
⎟⎠	=
JS | Γ) ⇒ A	JA | Δ) ⇒ C
JS | Γ, Δ) ⇒ C
ssubst

.	.
.	.
. f	. g
.	.
.
. sound f
.
.
. sound g
.

sound ⎜⎝
—| Γ ▶ A  S | Δ0, A, Δ1 ▶ C
S | Δ0, Γ, Δ1 ▶ C
ccut
⎟⎠  =
J—| Γ) ⇒ A	JS | Δ0, A, Δ1) ⇒ C
JS | Δ0, Γ, Δ1) ⇒ C
csubst

Theorem 4.9 For all f : A ⇒ C, we have sound (cmplt
.
f ) = f.

Proof. By induction on f .	2
On the other hand, sound is not a right inverse of cmplt up to literal equality of sequent derivations. For example, consider the derivation IL IR : I | ▶ I, since cmplt (sound (IL IR)) = ax /= IL IR. This calls for a coarser notion of equality for sequent calculus derivations. We identify derivations in the sequent calculus up to the least congruence $ induced the following equations:

ax
I | ▶ I
—| I IR
$	I | ▶ I IL
ax
B | ▶ B

ax 	 pass

ax	$	A | ▶ A
—| B ▶ B
⊗R

A ⊗ B | ▶ A ⊗ B

A | B ▶ A ⊗ B
⊗L
A ⊗ B | ▶ A ⊗ B

A′ | Γ ▶ A
pass
—| A′, Γ ▶ A	—| Δ ▶ B


—| A′, Γ, Δ ▶ A ⊗ B
—| Γ ▶ A
A′ | Γ ▶ A —| Δ ▶ B
$	 A′ | Γ, Δ ▶ A ⊗ B	⊗R
⊗R	—| A′, Γ, Δ ▶ A ⊗ B pass
—| Γ ▶ A  —| Δ ▶ B

I | Γ ▶ A IL —| Δ ▶ B
⊗R
I | Γ, Δ ▶ A ⊗ B
A′ | B′, Γ ▶ A
A′ ⊗ B′ | Γ ▶ A ⊗L —| Δ ▶ B
A′ ⊗ B′ | Γ, Δ ▶ A ⊗ B	⊗R
⊗R
$	—| Γ, Δ ▶ A ⊗ B
I | Γ, Δ ▶ A ⊗ B  IL
A′ | B′, Γ ▶ A —| Δ ▶ B
$	A′ | B′, Γ, Δ ▶ A ⊗ B	⊗R

A′ ⊗ B′ | Γ, Δ ▶ A ⊗ B ⊗L

The inverted left rules IL—1 and ⊗L—1 are compatible with the relation $.
Lemma 4.10	(i) For all f, g : I | Γ ▶ C, if f $ g, then IL—1 f $ IL—1 g.
(ii) For all f, g : A ⊗ B | Γ ▶ C, if f $ g, then ⊗L—1 f $ ⊗L—1 g.
We already showed in Lemma 3.2 that the rules IL—1 and ⊗L—1 are left inverses of IL and ⊗L, respectively. They are also right inverses up to $.
Lemma 4.11 The following equations hold:


.
.
. f
.
I | Γ ▶ C
.
.
. f
.	.	.
. f	A ⊗ B | Γ ▶ C	. f

IL−1	$	.		 ⊗L−1	$	.

—| Γ ▶ C
I | Γ ▶ C  IL
I | Γ ▶ C
A | B, Γ ▶ C
⊗L
A ⊗ B | Γ ▶ C
A ⊗ B | Γ ▶ C

The function sound
.
sends $-related derivations into =-related derivations.

Theorem 4.12 For all f, g : S | Γ ▶ C, f $ g implies sound f .
sound g.

The function cmplt
.
sends =-related derivations into $-related derivations. The

proof of this fact relies on the rules scut and ccut being compatible with the relation
$. Moreover, it relies on the unit and associativity laws of Figure 2.
Lemma 4.13	(i) For all f1, f2 : S | Γ ▶ A and g1, g2 : A | Δ ▶ C, if f1 $ f2 and
g1 $ g2, then scut f1 g1 $ scut f2 g2.
(ii) For all f1, f2 : −| Γ ▶ A and g1, g2 : S | Δ0, A, Δ1 ▶ C, if f1 $ f2 and g1 $ g2, then ccut f1 g1 $ ccut f2 g2.
.
Theorem 4.14 For all f, g : A ⇒ C, f = g implies cmplt f $ cmplt g.
We showed in Theorem 4.9 that the function sound is a left inverse of cmplt
.
up to =. We are now in the position to see that sound is a right inverse of (a
suitable generalization of) cmplt up to $. To prove this, we first construct a rule that unpacks a stoup of the form JS | Γ) by iterating ⊗L—1 and then also applying IL—1 if appropriate.
Lemma 4.15 The following rule is admissible:
JS | Γ) | Δ ▶ C
S | Γ, Δ ▶ C	L—1
Proof. We proceed by induction on Γ.
Case Γ is empty. We define:
.

.
.
. f
.
JA | ) | Δ ▶ C

=df
.
.
. f
.
JA | ) | Δ ▶ C
.
.
. f
.
J—| ) | Δ ▶ C

=df
.
. f
.
J—| ) | Δ ▶ C



L−1	L−1
I | Δ ▶ C

A | Δ ▶ C
A | Δ ▶ C
—| Δ ▶ C


—| Δ ▶ C
IL−1

Case Γ = B, Γj. We define:

.
.
. f
.
JA | B, Γ′) | Δ ▶ C


A | B, Γ′, Δ ▶ C









L−1




=df


.
.
. f
.
JA | B, Γ′) | Δ ▶ C


JA ⊗ B | Γ′) | Δ ▶ C A ⊗ B | Γ′, Δ ▶ C A | B, Γ′, Δ ▶ C
.
.








L−1
⊗L−1

.
.
J−| B, Γj) | Δ ▶ C


j



L—1


=df
J−| B, Γj) | Δ ▶ C


JI ⊗ B | Γj) | Δ ▶ C
I ⊗ B | Γj, Δ ▶ C


L—1

−| B, Γ , Δ ▶ C
I | B, Γj, Δ ▶ C
⊗L—1

−| B, Γj, Δ ▶ C IL—1

2
The rule L—1 is compatible with the relation $. This is a consequence of Lemma 4.10.
Lemma 4.16 For all f, g : JS | Γ) | Δ ▶ C, if f $ g, then L—1 f $ L—1 g.
The postcomposition of cmplt with sound sends a derivation of the sequent S | Γ ▶ C into a derivation of the sequent JS | Γ) | ▶ C. Therefore, for general S, Γ, the derivation f : S | Γ ▶ C is not directly comparable with cmplt (sound f ). We can easily repair this discrepancy by realizing that Lemma 4.15 gives a generalization of our completeness result Theorem 4.5.
Corollary 4.17 (Strong completeness) For any derivation f : JS | Γ) ⇒ C, there is a derivation strcmplt f : S | Γ ▶ C.


Proof. We define:
.
.
. f
.

.
. cmplt f
.

strcmplt ⎝
JS | Γ) ⇒ C
⎠ =df
JS | Γ) | ▶ C
S | Γ ▶ C
L−1

2
Lemma 4.16 makes it an immediate consequence of Theorem 4.14 that the func-

tion strcmplt
.
sends =-related derivations into $-related derivations.
.

Corollary 4.18 For all f, g : JS | Γ) ⇒ C, f = g implies strcmplt f $ strcmplt g.
Now we have that, given f : S | Γ ▶ C, the derivation strcmplt (sound f ) has the same endsequent S | Γ ▶ C. We can prove that the two derivations are equal up to
$. I.e., sound is a right inverse of strcmplt up to $.
Theorem 4.19 For all f : S | Γ ▶ C, we have strcmplt (sound f ) $ f.
Proof. By induction on f .	2
As a special case, the restriction of sound to sequents A | ▶ C is a right inverse of cmplt up to $.
Corollary 4.20 For all f : A |  ▶ C, we have cmplt (sound f ) $ f.
Theorem 4.9 used only the restriction of sound to sequents A |	▶ C. We can now generalize it and prove that sound (for general sequents) is a left inverse of

strcmplt
.
up to =. This is immediate from the following lemma.

Lemma 4.21 The following equation holds:

sound ⎛
⎜⎝
.
.
. f
.
JS | Γ) |  ▶ C
S | Γ ▶ C	L−1


⎟⎠ =

sound ⎛⎝

.
.
. f
JS | Γ) | ▶ C  ⎠



Corollary 4.22 For all f : JS | Γ) ⇒ C, we have sound (strcmplt
.
f ) = f.

Theorem 4.19 and Corollary 4.22 show that sound and strcmplt make a bijection between the derivations of S | Γ ▶ C (considered up to $) and the derivations
.
of JS | Γ) ⇒ C (considered up to =). (And Corollary 4.20 and Theorem 4.9
demonstrate that restricted sound and cmplt form a bijection between the derivations of A | ▶ C and the derivations of A ⇒ C.)
Focusing
If we consider the congruence relation $ on sequent calculus derivations as a term rewrite system (just by directing every equation to go from the left to the right), we can notice that it is weakly confluent and strongly normalizing, hence strongly confluent with unique normal forms. It turns out that these normal forms admit a simple direct description, corresponding to a natural “focused” [2] subsystem of the sequent calculus.
We present the focused subsystem as a sequent calculus with an additional mode annotation on sequents, which alternates between L (the “left mode”) and R (the “right mode”). In an L-sequent there is no restriction on the stoup, but in an R- sequent the stoup has to be irreducible, i.e., be empty or contain an atom (we write T to range over such irreducible stoups).


 A | Γ ▶L C  pass	T | Γ ▶R C
msw	ax

−| A, Γ ▶L C
T | Γ ▶L C
X |  ▶R X


−| Γ ▶L C
I | Γ ▶L C  IL	−|  ▶R I IR


A | B, Γ ▶L C
A ⊗ B | Γ ▶L C ⊗L
T | Γ ▶R A	−| Δ ▶L B
T | Γ, Δ ▶R A ⊗ B	⊗R


(Note that, in the rules msw and ⊗R, the stoup T has to be irreducible.)
As in Andreoli’s original formulation for linear logic [2], we can think of focusing as defining a root-first proof search strategy which attempts to build a derivation of a sequent bottom-up. Beginning in L-mode, the invertible rules IL and ⊗L are applied to break down the formula in the stoup and transform it into a list of additional subformulae in the context. Once the stoup is empty, there is a choice to either apply the pass rule to shift the next formula into the stoup and repeat the inversion process, or else apply the msw rule (for “mode switch”) and move into R-mode. During R-mode, the non-invertible rule ⊗R is applied as necessary to attempt to continue the derivation (moving back into L-mode for the right premise), while the rules IR and ax are applied to attempt to finish off the derivation.
The focused calculus is clearly sound, in the sense that, if one ignores the mode annotations, all of the above rules are either rules of the original sequent calculus or else (in the case of msw) have the conclusion equal to premise. In fact, the fo-

cused calculus is complete, and indeed optimal in the sense that focused derivations give unique representatives of each $-equivalence class. This is established by the following results.
Proposition 5.1 For any derivation f : S | Γ ▶L C, there is a derivation emb f :
S | Γ ▶ C.
Theorem 5.2 For any derivation f : S | Γ ▶ C, there is a derivation focus f : S |
Γ ▶L C.
Proof. By induction on f .	2
Theorem 5.3 For any f : S | Γ ▶L C, focus (emb f )= f.
Proof. By induction on f .	2
Theorem 5.4 For any f, g : S | Γ ▶ C, if f $ g, then focus f = focus g.
Proof. By induction on the proof of f $ g.	2
Theorem 5.5 For any f : S | Γ ▶ C, we have emb (focus f ) $ f.
Proof. By induction on f .	2
Corollary 5.6 For any f, g : S | Γ ▶ C, if focus f = focus g, then f $ g.
Putting these results together with Theorems 4.4, 4.5 on soundness and complete- ness and Theorems 4.9, 4.12, 4.14, we obtain a simple decision procedure for equality of maps in the free skew monoidal category.
.
Corollary 5.7 For any f, g : A ⇒ C, we have f = g if and only if focus (cmplt f )= 
focus (cmplt g).
It was already observed that the cut-free sequent calculus of Section 3 can be used to decide existence of maps in the free skew monoidal category. The focused cal- culus yields a more efficient decision procedure, since there is less non-determinism. Furthermore, it provides a simple algorithm for listing the elements of any homset in the free skew monoidal category without producing duplicates.
Theorem 5.8 For any S, Γ, C, one can compute a duplicate-free list focderivs (S, Γ, C) of derivations of S | Γ ▶L C containing every such deriva- tion. In particular, we can decide whether S | Γ ▶L C is derivable.
Proof. As explained above, we can consider the focused calculus as a root-first search strategy. This search is guaranteed to terminate because, for any goal sequent S | Γ ▶m C (m ∈ {L, R}), there are only finitely many possible instances of rules to apply, and the subgoals that they generate are always smaller relative to a well- founded order on sequents. (We can rank sequents by lexicographically ordered triples consisting of the number of occurrences of I and ⊗, the information whether the stoup is empty or not, with singleton < empty, and the mode, with R < L.) 2

Corollary 5.9 For any A, C, one can compute a list of derivations A ⇒ C that
.
contains, for any derivation f : A ⇒ C, exactly one derivation g such that f = g,
as (sound ◦ emb)∗ (focderivs (A, (), C)).
It is worth mentioning that there are some surprisingly elegant formulae for counting different families of maps in the free skew semigroup category [7], and so it may be interesting to apply the focused sequent calculus to pursue a similar quantitative analysis of maps in the free skew monoidal category (cf. [18]).
Conclusion and Future Work
In this paper, we studied the free skew monoidal category from a proof-theorist’s point-of-view. We considered three calculi, a categorical calculus, which embodies the definition of the free skew monoidal category, a sequent calculus and a focused version thereof, and proved their sets of derivations to be in bijections. Nicely, in the focused calculus, there is no need to quotient derivations by a congruence relation, equality of derivations is just (literal) equality. The focused calculus thus provides a very concrete description of the free skew monoidal category. We learned that, although simply defined, skew monoidal categories are remarkably subtle. We also learned that methods of proof theory, such as proof techniques of cut admissibility, focusing or use of non-standard sequent forms, are surprisingly well suited for exploring them.
We envisage a number of directions for future work.
One obvious direction for continuing this line of work would be to prove analo- gous coherence theorems for (non-monoidal) skew closed categories and/or for skew monoidal closed categories, by analyzing sequent calculi that correspond to restric- tions of Lambek’s original calculus with only one implication (with or without the tensor product).
As mentioned in the Introduction, the analysis we have presented here is closely related to Bourke and Lack’s recent characterization of skew monoidal categories as left representable skew multicategories [5]. Indeed, it appears that the focused sequent calculus gives an explicit construction of the free left representable skew multicategory over a set of atoms. We plan to describe this connection in full detail in another paper.
In the free skew monoidal category, there can be multiple maps between the same two objects, i.e., multiple focused derivations of the same sequent. We believe that we can partially order the derivations in a canonical way both in the cate- gorical calculus and in the sequent calculus. In particular, we can have a greatest element, i.e., a preferred derivation for any derivable sequent, and have soundness and completeness preserve these partial orders. Moreover, one may ask whether this ordering coincides with the canonical ordering induced by Lack and Street’s faithful functor Fsk → Δ⊥, viewing Δ⊥ as a 2-category (with the pointwise ordering on monotone maps).
Finally, another more speculative direction is to develop sequent calculi for
higher-dimensional skew monoidal and/or skew semigroup categories – given the

connections between the Tamari order and the well-studied higher-dimensional poly- topes known as associahedra [15], it is natural to wonder whether the sequent cal- culus presentation can reveal something new.
Acknowledgement
T.U. was partially supported by the Estonian Ministry of Education and Research institutional research grant no. IUT33-13. N.V. was supported by the ERDF funded Estonian national CoE project EXCITE and a research grant (13156) from VILLUM FONDEN.

References
T. Altenkirch, J. Chapman, T. Uustalu (2015): Monads need not be endofunctors. Log. Methods in Comput. Sci. 11(1), article 3, 2015. doi: 10.2168/lmcs-11(1:3)
J.-M. Andreoli (1992): Logic programming with focusing proofs in linear logic. J. of Log. and Comput.
2(3), pp. 297–347. doi: 10.1093/logcom/2.3.297
J. B´enabou (1963), Cat´egories avec multiplication. C. R. Acad. Sci. Paris 256, pp. 1887–1890. Available at http://gallica.bnf.fr/ark:/12148/bpt6k3208j/f1965.image.
J. Bourke, S. Lack (2018): Free skew monoidal categories. J. of Pure and Appl. Alg. 222, pp. 3255-3281. doi: 10.1016/j.jpaa.2017.12.006
J. Bourke, S. Lack (2018): Skew monoidal categories and skew multicategories. J. of Alg. 506, pp. 237–266. doi: 10.1016/j.jalgebra.2018.02.039
M. Buckley, R. Garner, S. Lack, R. Street (2014): The Catalan simplicial set. Math. Proc. of Cambridge Philos. Soc. 158(12), pp. 211–222. doi: 10.1017/s0305004114000498
F. Chapoton (2006): Sur le nombre d’intervalles dans les treillis de Tamari. S´eminaire Lotharingien de Combinatoire 55, article B55f. https://www.mat.univie.ac.at/~slc/wpapers/s55chapoton.html

G. M. Kelly (1964): On MacLane’s conditions for coherence of natural associativities, commutativities, etc. J. of Alg. 1(4), pp. 397–402, doi: 10.1016/0021-8693(64)90018-3.
S. Lack, R. Street (2012): Skew monoidales, skew warpings and quantum categories. Theor. and Appl. of Categ. 26, pp. 385–402. Available at thttp://www.tac.mta.ca/tac/volumes/26/15/26-15abs.html

S. Lack, R. Street (2014): Triangulations, orientals, and skew monoidal categories. Adv. in Math. 258,
pp. 351–396, 2014. doi: 10.1016/j.aim.2014.03.003
J. Lambek (1958): The mathematics of sentence structure. Amer. Math. Monthly 65(3), pp. 154–170. doi: 10.2307/2310058
T. Leinster (2004): Higher Operads, Higher Categories, v. 298 of London Math. Soc. Lect. Note Ser. Cambridge Univ. Press. doi: 10.1017/cbo9780511525896 (Preprint version available at https://arxiv. org/abs/math/0305049.)
S. Mac Lane (1963): Natural associativity and commutativity. Rice Univ. Stud. 49(4), pp. 28–46. Available at http://hdl.handle.net/1911/62865.
S. Mac Lane (1971): Categories for the Working Mathematician. Springer-Verlag. doi: 10.1007/978-1- 4757-4721-8
F. Mu¨ller-Hoissen, J.-M. Pallo, J. Stasheff (eds.) (2012): Associahedra, Tamari Lattices and Related Structures: Tamari Memorial Festschrift, v. 299 of Progress in Mathematics. Birkh¨auser. doi: 10.1007/978-3-0348-0405-9
K. Szlachanyi (2012): Skew-monoidal categories and bialgebroids. Adv. in Math. 231(3–4), pp. 1694– 1730, doi: 10.1016/j.aim.2012.06.027.


T. Uustalu (2014): Coherence for skew-monoidal categories. In P. Levy, N. Krishnaswami (eds.), Proc. of 5th Wksh. on Mathematically Structured Programming, MSFP 2014, v. 153 of Electron. Proc. in Theor. Comput. Sci., pp. 68–77. Open Publishing Assoc. doi: 10.4204/eptcs.153.5


N. Zeilberger (2017): A sequent calculus for a semi-associative law. In D. Miller (ed.), Proc. of 2nd Int. Conf. on Formal Structures for Computation and Deduction, FSCD 2017, v. 84 of Leibniz Int. Proc. in Inform., article 33. Dagstuhl Publishing. doi: 10.4230/lipics.fscd.2017.33


A  Sequent Calculus as a Generalized Multicategory
The sequent calculus can be seen as a particular generalized multicategory for a Cartesian monad that we denote (·)?s. Its underlying functor is given by X?s =df X? × Xs where X? is the free pointed set on X (obtained by adding an element to X) and Xs is the free monoid on X (the set of lists over X). For elements of X?s, we use the notation we have been using for antecedents, i.e., we write S | Γ for an element of T X, where S can either be nothing or an element of X and Γ is a list of elements of X. The unit η?s : X → X?s
of (·)?s is given by η?s A =df A | . The multiplication μ?s : (X?s)?s → X?s is given by:


μ?s (—| Δ) =df —| μs ([·]s Δ)	μ?s ((S | Γ) | Δ) =df S | Γ, μs ([·]s Δ)


where μs is the multiplication of the list monad (·)s, i.e., concatenation of lists, and [·] is a monad morphism typed [·]X : X?s → Xs and given by [—| Γ] =df Γ and [A | Γ] =df A, Γ.
The sequent calculus is an instance of a generalized multicategory for (·)?s. We call this generalized multicategory SC. An object of SC is a formula, i.e., an element of Fma. A map between S | Γ : Fma?s and C : Fma is a derivation of the sequent S | Γ ▶ C.
The identity map on an object A is the derivation ax of the sequent A |  ▶ A.
The composition of the generalized multicategory is given by the following two “multicut” rules, defined from pass, scut and ccut.

S | Γ ▶ B  S1 | Γ1 ▶ B1 ...  Sn | Γn ▶ Bn  B | B1,... Bn ▶ C

S | Γ,S , Γ ,...,S , Γ
▶ C	mcutj

1  1	n  n

S1 | Γ1 ▶ B1 ...  Sn | Γn ▶ Bn  —| B1,... Bn ▶ C


—| S1, Γ1,..., Sn, Γn ▶ C
mcutn



In the conclusions of these rules, we are informal in our notation, instead of Si, Γi, we should officially write [Si | Γi].
The construction is as follows. First, we define a generalized version of pass:


S | Γ ▶ C


—| S, Γ ▶ C

pass?



The definition is immediate:


.
.
. f
.
A | Γ ▶ C



=df
.
.
. f
.
A | Γ ▶ C
.
.
. f
.
—| Γ ▶ C
.
.
. f
=df	.

pass?		 pass		 pass?
—| Γ ▶ C

—| A, Γ ▶ C
—| A, Γ ▶ C
—| Γ ▶ C

Using pass?, the rules mcutj and mcutn are defined as follows:

.
.
. f
.
S | Γ ▶ B
.
.
. f
.
S1 | Γ1 ▶ B1  ... 
.
.
. f
.
Sn | Γn ▶ Bn
.
.
. g
.
B | B1,... Bn ▶ C

S | Γ,S , Γ ,...,S , Γ
▶ C	mcutj

1  1	n n


Sn | Γ
.
.
. f
.
n ▶ Bn

.
.
. g
pass?	.

.	—| Sn, Γn, ▶ Bn
B | B1,..., Bn ▶ C
ccut

.	B | B ,...,B 
,S , Γ ▶ C

=df
S1 | Γ
. f
.
1 ▶ B1
?
1	n.−1  n  n
.
.

.		 pass	.

.	—| S , Γ , ▶ B
B | B ,S , Γ ,...,S , Γ ▶ C

. f	1  1	1
1  2  2	n  n

.		 ccut

S | Γ ▶ B

.
.
. f	. f
.
B | S1, Γ1,..., Sn, Γn ▶ C
S | Γ, S1, Γ1,..., Sn, Γn ▶ C
.
.
. g
.
scut

S1 | Γ1 ▶ B1 ...  Sn | Γn ▶ Bn  —| B1,... Bn ▶ C


mcutn

—| S1, Γ1,..., Sn, Γn ▶ C



Sn | Γ
.
.
. f
.
n ▶ Bn


.
.
. g
pass?	.

.	—| Sn, Γn, ▶ Bn
—| B1,..., Bn ▶ C
ccut

=	.	—| B ,...,B 
,S , Γ ▶ C

df
S1 | Γ
. f
.
1 ▶ B1

pass?
1	n.−1  n  n
.
.
.

—| S1, Γ1, ▶ B1
—| B1, S2, Γ2,..., Sn, Γn ▶ C
—| S1, Γ1,..., Sn, Γn ▶ C
ccut


On the other hand, we could start with mcutj and mcutn and define scut and ccut as follows:


.	.
.	.
. f	. g
.	.
.
.
. f
.		 ax
.
.
. g
ax	.

S | Γ ▶ B  B | B1 ,..., Bn ▶ C


scut
=df
S | Γ ▶ B  B1 | ▶ B1
...  Bn | ▶ Bn
B | B1 ,..., Bn ▶ C
mcutj

S | Γ, B1 ,..., Bn ▶ C
.	.
.	.
. f	. g
.	.
S | Γ, B1 ,..., Bn ▶ C

− | Γ ▶ B  A | B1 ,..., Bi,B, Bi+1 ,... Bn ▶ C


ccut

A | B1 ,..., Bi, Γ, Bi+1 ,... Bn ▶ C

ax	ax
.	.
.	.
. f	. g
.		 ax	.

=df
A | ▶ A
B1 | ▶ B1
... 
− | Γ ▶ B  ... 
Bn | ▶ Bn
A | B1 ,..., Bi,B, Bi+1 ,... Bn ▶ C
mcutj

.
.
. f
.
− | Γ ▶ B

.
.
. g
.
− | B1 ,..., Bi,B, Bi+1 ,... Bn ▶ C
A | B1 ,..., Bi, Γ, Bi+1 ,... Bn ▶ C



ccut

− | B1 ,..., Bi, Γ, Bi+1 ,... Bn ▶ C

ax
.	.
.	.
. f	. g
.		 ax	.

=df
B1 | ▶ B1
... 
− | Γ ▶ B  ... 
Bn | ▶ Bn
− | B1 ,..., Bi,B, Bi+1 ,... Bn ▶ C
mcutn

− | B1 ,..., Bi, Γ, Bi+1 ,... Bn ▶ C

There is also another multicategory in the picture, this one standard, i.e., based on the list Cartesian monad (·)s. We call it SCn. An object of SCn is again a formula, i.e., an element of Fma. A map between Γ : Fmas and C : Fma is a derivation of the sequent —| Γ ▶ C. The identity on A is the derivation pass ax : —| A ▶ A. Composition is given by the restriction of mcutn to the case where the stoups S1,..., Sn are all —.
pass? defines an identity-on-objects functor from SC to SCn wrt. the monad morphism [·] between the corresponding Cartesian monads.
