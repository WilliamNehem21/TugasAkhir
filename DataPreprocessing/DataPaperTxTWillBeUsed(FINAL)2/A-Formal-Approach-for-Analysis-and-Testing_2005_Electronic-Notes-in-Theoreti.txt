	Electronic Notes in Theoretical Computer Science 141 (2005) 91–106	
www.elsevier.com/locate/entcs

A Formal Approach for Analysis and Testing of Reliable Embedded Systems
Abdelaziz Guerrouat1
Department of Computer Science Clausthal University of Technology 38678 Clausthal, Germany

Harald Richter2
Department of Computer Science Clausthal University of Technology 38678 Clausthal, Germany


Abstract
In this paper, a framework for the specification of embedded systems described as ’predicated’ extended finite state machines (p-EFSMs) is proposed. Compared to simple FSMs, p-EFSMs allow the control flow and the data flow description of hardware modules or software processes. We introduce a new variant of the EFSM model, a so-called ’predicated’ EFSM that extends the usual EFSM. This extension offers a more convenient mean to specify constraints on the system’s transitions. Secondly, it provides an easy mapping onto formal description techniques. Thirdly, it allows the development of an embedded system independently from the implementation, i.e. without favoring a hardware or a software. Crucial tasks in the design of reliable embedded systems are analysis and testing. These allow the system developer to detect bugs that may be very costly to do in subsequent phases of the system development. We identify the different testing issues and demonstrate how the bugs can be detected by means of p-EFSMs. Failure detection and elimination improve the likelihood of the well-functioning and the reliability of the embedded system.
Keywords: Embedded systems, analysis and testing, extended finite state machines, formal description techniques.



1  Email: aguerrou@informatik.tu-clausthal.de
2  Email: richter@informatik.tu-clausthal.de




1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.02.050

Introduction
An embedded system represents a part of a product with which an end user does not directly interact. Nowadays, there exists a lot number of typical applications of industrial embedded systems that are supported by software, for instance adaptive cruise control systems, automotive systems and nuclear power plants. These are mostly characterized by safety-critical properties.
Because of the growing complexity of embedded systems the software de- velopment process becomes a costly and error-prone activity. The cost factor plays a central role in today’s industrial competition, for instance between car manufacturers. The development of competitive and efficient products is imposing more and more constraints to the design of embedded systems. One of the means to reach this goal are formal methods to support the dif- ferent phases of system development, i.e. specification, synthesis and testing. There are several requirements for those methods that should be among oth- ers qualities abstract, understandable, analyzable, scalable and unambiguous specification formalisms.
Much work should be done for introducing standardized formal description techniques (FDTs) [6] [10] and related formalisms at a high level of abstrac- tion in the life-cycle development of embedded systems. On the other side, formal descriptions techniques have demonstrated their effectiveness in the analysis of complex requirements like those for communicating systems [5]
[6] [10]. Furthermore, they provide a solid mean for unambiguous specifica- tion and rigorous analysis. They are based on formal methods such (E)FSMs (’extended’ finite state machines) and differ from conventional programming languages by providing not only a formal syntax but also a formal semantic. Moreover, the application of formal specification increases the confidence in the software and the system. Especially in the area of safety-critical systems, the use of formal techniques is highly recommended [2], e.g. steer-by-wire or brake-by-wire in cars [9].
Statecharts as a semi-formal model is actually the mostly used formal- ism to specify requirements for embedded systems [7]. Although Statecharts provide graphical facilities, they might lack formal and unambiguous seman- tics. Therefore, detecting bugs, incompleteness and inconsistencies becomes a difficult task. Furthermore, they are only used to describe behavioral require- ments. To alleviate these lacks many authors try to combine formal notations like Z with state-transition models [8]. Z is based on set theory and first or- der predicate logic and used for data structuring and abstracting. Petri Nets have been also used to verify the correctness of embedded systems, e.g. [3]. However, approaches developed around this model do not directly deal with the here addressed standardized FDTs and related test generation methods.

Formal methods have been widely and successfully used in other areas for both, software and hardware design and testing. We think that they may be adapted for embedded systems too.
The finite state machine model is very popular in the control flow speci- fication of state/transition-based systems and many related analysis methods have been developed [1] [4]. These support a formal test derivation which can be used for validation and testing purposes. However, finite state machines lack to deal with the data flow. This shortcoming can be alleviated by using the extended finite state machine model. Moreover, the test generation cannot be easily applied in this case.
In this paper, we discuss the testing problems for embedded systems mod- eled as extended finite state machines and propose a framework to deal with them. We first present the main components of an embedded system as well as their interactions. Furthermore, the testing issues based on so-called p-EFSM (predicated EFSM). The later, represents a variant of the usual EFSM are identified and the appropriate solutions will be discussed.
The paper is organized as follows. Section 2 reviews the conventional finite state machine and the extended finite state machine models and gives a short comparison. Modeling embedded systems based on p-EFSM are presented in Section 3. Section 4 identifies the main properties of an embedded system to be tested. After that, the testing principle is explained. Finally, Section 5 concludes the paper.

Preliminaries
In this section, we give the definitions of the used formalisms. We first review the finite state machine model and its extension. After that, we propose a definition of the p-EFSM (’predicated’ EFSM).
Definition 2.1 A ﬁnite state machine (FSM) is a 5-tuple ⟨S, I, O, T, s0⟩, where S is a non-empty finite set of states, I a non-empty set of inputs, O a non-empty finite set of outputs, T ⊆ S × I × O × S the set of transition relations, and s0 ∈ S the initial state of the FSM.
Note, in some literature the set of outputs may be considered as not a part of an FSM. However, the definition of an FSM given here appears to be more convenient in FDTs.
A transition t ∈ T of an FSM is a 4-tuple ⟨s, i, o, s'⟩, where s ∈ S is a current state (the edge), i ∈ I an input, o ∈ O an output related to s and I, and s' ∈ S the next state (a tail state) related to s and i.
The FSM model is often less appropriate for specifying most parts of a

system, for instance, regarding the data flow. Therefore, FSMs were extended to improve their description capability by using additional state variables and interaction parameters. Such variables are used in programming languages specifying conditions on transitions and calculations carried out during tran- sitions.
Definition 2.2 An extended ﬁnite state machine (EFSM) is a 7-tuple ⟨ S, C, I, O, T, s0, c0⟩ where S is a non-empty set of main states, C = dom(v1) ×...× dom(vn) a non empty countable set of contexts with vi ∈ V , V the non-empty finite set of variables and dom(vi) a non-empty countable set referred to as the domain of vi, I a non-empty finite set of inputs, O a non-empty set of outputs, T ⊆ S × C × I × O × S × C the set of transition relations, s0 ∈ S the initial main state, and c0 ∈ C the initial context of the EFSM.
A main state may consist of sub-states. A context is a specific assign- ment of values to the variables. A transition t ∈ T of an EFSM is a 6-tuple
⟨s, c, i, o, s', c'⟩ where s ∈ S is a current main state, c ∈ C a current context, i ∈ I an input, o ∈ O an output, s' ∈ S a next main state, and c' ∈ C a next context.
A transition may be characterized, in addition to its current and next state and input and output interactions and context, by a so-called enabling predicate. This represents a condition on a state transition and the related output to be carried out, once the predicate ’fires’. All usual logical and comparative operators and, or, =, > etc. are allowed in a predicate. Thus, a transition takes place only if its enabling predicate fires. It depends on the current FSM state with additional variables and the concrete variables values (context) of the input. Therefore, we introduce a so-called p-EFSM in which the enabling predicates on transitions are explicitly represented.
Definition 2.3 A predicated extended ﬁnite state machine (p-EFSM) is an 8-tuple ⟨S, C, I, P, O, T, s0, c0⟩ where S is a non-empty set of main states, C = dom(v1) × · · · × dom(vn) a non-empty countable set of contexts with vi ∈ V , V a non-empty finite set of variables, and dom(vi) a non-empty countable set referred to as the domain of vi, P a countable set of predicates (possibly empty), I a non-empty finite set of inputs, O a non-empty finite set of outputs, T ⊆ S ×C ×I ×P ×O ×S ×C a set of transition relations, s0 ∈ S the initial main state, and c0 ∈ C the initial context of the p-EFSM.
A transition t ∈ T of a p-EFSM is a 7-tuple ⟨s, c, I, p, o, s', c'⟩ where s ∈ S is a current main state, c ∈ C a current context, i ∈ I an input, p ∈ P an enabling predicate which depends on the context c, o ∈ O an output, s' ∈ S a next main state, and c' ∈ C a next context.



Fig. 1. Examples of objects including embedded systems

Note if P = ∅ then the p-EFSM is equal to the conventional EFSM. There- fore, the p-EFSM provides a more generalized specification mean. The system specification using a p-EFSM is more suitable for using formal description techniques like Estelle or SDL [6] [10].
Estelle is a standardized formal description technique (International Stan- dard ISO 9074) based on concepts of structured communicating extended state automata and Pascal. It is oriented towards the specification of complex dis- tributed systems, in particular communicating systems. A specified system is presented as a tree of tasks where each task has a fixed number of input/output access points (interaction points). Within a specified system it exists a fixed structure of subsystems (sub-trees of tasks) and communication links between subsystems.
SDL (Specification and Description Language) is an object-oriented, formal language defined by The International Telecommunications Union Telecommu- nications Standardization Sector (ITU) (formerly Comit´e Consultatif Inter- national T´el´egraphique et T´el´ephonique [CCITT]) as recommendation Z.100. The language is intended for the specification of complex event-driven real- time, and interactive applications involving many concurrent activities that communicate using discrete signals.
Indeed, p-EFSMs can functionally describe system components that may be blocks or modules depending on the used formal description technique 3 .

Characteristcs and Structure of Embedded Systems
An embedded system is any computer system or computing device that per- forms a dedicated function or is designed for use with a specific embedded software application, e.g. Car, PDA (Personal Data Assistant), Mobile Phone,

3 SDL uses the ’block’ concept whereas Estelle ’module’



external process
sensors embedded system
controller



user-machine interface



actuators


Fig. 2. Basic structure of an embedded system

E-Book (Electronic Book), Robot, etc. (Figure 1). That is, an embedded sys- tem is a special-purpose system built into a larger device. It is embedded as a subsystem in a larger system which may or may not be a computer system. An embedded system is typically required to meet specific requirements. In an embedded mechatronic system, a microcontroller or computer system per- forms a dedicated function for an appliance or a gadget such as a car’s brake or a steering wheel [9].
Embedded systems must usually be dependable, efficient and must meet real-time constraints. Be ’dependable’ means that an embedded system must be reliable, available and safe. The efficiency mostly concerns properties like energy, code-size, run-time, weight and cost. An embedded system is dedicated for a certain application and characterized also by a dedicated user interface. Thus, knowledge about future behavior at design time can be used to mini- mize resources and to maximize robustness. Many embedded systems must meet real-time constraints. A real-time system must react to stimuli from the controlled object (or the operator) within the time interval dedicated by the environment.
Embedded systems are frequently connected to a physical environment through sensors and actuators. They are typically reactive systems. A reactive system is in continuous interaction with its environment and executes at a pace determined by that environment. The behavior depends on input and current state for which the automata model is often most appropriate.
Figure 2 illustrates the basic structure of an embedded system comprising an external process, sensors, actuators, and a controller :
The external process is a process that can be of physical, mechanical, or electrical nature.
Sensors provide information about the current state of the external pro- cess by means of so-called monitoring events. They are communicated to the controller. For the controller, they represent input events. They are



Sensor’s behaviour modules
EFSMs
p-EFSM
monitoring signals
channel

controlling signals
channel






Fig. 3. Embedded system based on p-EFSM modeling

considered as stimuli for the controller.
The controller must react to each received event, i.e. input event. Events originate usually from sensors. Depending on the received events from sensors, corresponding states of the external process will be determined.
Actuators receive the results determined by the controller which are com- municated to the external process by means of so-called controlling events.
The external process is usually given in advance. In contrast, the controller is often implemented by real-time hardware and software. This should allow each modification of the controller algorithm in a straightforward way each time this is needed. The controller’s behavior is depending on that of the ex- ternal process. The controller commands the behavior of the external process taking into consideration requirements on the process and its characteristics, such as physical laws, real time and other constraints.

Formal Description
The embedded system specification consists of the specification of its en- vironment and its controller. We assume that the embedded system is state- transition based because the automata model is efficiently more appropriate. Thus, its behavior description will be based on the proposed p-EFSM model. This consists of a set of modules where each module describing a given func- tion is modeled as a one or many p-EFSM (Figure 3). These modules interact with each other via broadcasting events. However, a sequence has to be re- spected in this communication. For instance, the direct communication of a module of an actuator with a sensor is not allowed.
The most important component of an embedded system consists of the controller which communicates with its environment, i.e. sensors and actors, via signals (i.e. events). To be recognized by all components, these events have to be declared as global variables for adjacent p-EFSMs. The events output from sensors represents input events for the controller. The events

from the controller to the actuators are output events and represent input events for the actuators. They result from new computations performed by the controller that is triggered by the received input events.
Depending on the nature of sensor events (e.g. indicating the power on/of state for an electrical unit, the speed of a mobile object such as a car, etc.) the corresponding p-EFSM of this component is triggered and the concerning transition(s) are performed. This triggers the p-EFSMs of the controller whose states change. Depending on the received events, transitions in the p-EFSMs are executed. Note, that transitions in the controller can spontaneously be triggered by other events, e.g. time out. The modeled subsequent state of the external process is computed and communicated as output events via the actuators.
Now we use the p-EFSM to model a given embedded system. We consider a single p-EFSM for each component of the system and denote them with indices s, c and a for sensors, controller, and actuators.
Interdependencies between these components are described as follows:
Let be given a transition ts ∈ Ts : ts = ⟨ss, cs, is, ps, os, s' , c' ⟩ with

ss ∈ Ss, cs ∈ Cs, is ∈ Is, ps ∈ Ps, os ∈ Os, s'
∈ Ss, c'
s	s
∈ Cs

⇒ ∃tc ∈ Tc|os ≡ ic
That is, each output event generated by sensors must trigger a transition of the controller. This event represents an input event for the triggered transition. We assume here that the predicates related to the transitions are satisfied by the actual context.
Let be given a transition tc ∈ Tc with

sc ∈ Sc, cc ∈ Cc, ic ∈ Ic, pc ∈ Pc, oc ∈ Oc, s'
∈ Sc, c'
∈ Cc

if ic ∈ Os ⇒ ts ∈ Ts and ic ≡ os
This means that, if there exists a transition of the controller whose input event belongs to the set of output events of the sensors then it must exist a transition of the sensors whose output event is identified with the given event.
Let be given a transition ta ∈ Ta : ta = ⟨sa, ca, ia, pa, oa, s' , c' ⟩

with sa ∈ Sa, ca ∈ Ca, ia ∈ Ia, pa ∈ Pa, oa ∈ Oa, s'
a
∈ Sa, c'
a
∈ Ca

=⇒ tc ∈ Tc : tc = ⟨sc, cc, ic, pc, oc, s' , c' ⟩ and oc ≡ ia
c	c
Each transition of actuators must be only triggered by the controller and
must match the output event of the triggering transition of the controller.
It is easy to map a p-EFSM specification on the behavioral part (transition part) of an Estelle module. The later has the following structure which is composed of two parts - condition clauses and actions:
WHEN clause

when interaction_point_id.interaction_name FROM clause
from state PROVIDED clause
provided Boolean expression DELAY clause
delay (integer_expression)
TO clause
to state output
The when corresponds to input events in p-EFSM, from to edge state, provided to predicate, delay is a timing special input event, to to the tail state and output to output event.

Analysis and Testing Issues
Analysis and testing of embedded systems have to prove correctness, com- pleteness and consistency in early phases of system development. Correctness means the fulfillment of the required services and its providing within a given time period. Completeness is its act of reaction to all possible events and car- rying out all services. Consistency relates to the interior contradiction freeness of the specification.
There are two kinds of testing, general and special. The first one consists of testing of properties that must be held independently of special semantics of the developed system (consistency), such as livelock and deadlock-freeness, limitedness and resynchronization. The second aims at properties that are determined by the semantics of the designed system.
Properties that are addressed by analysis and testing are summarized as follows:
The non-existence of non-executable actions: The system comprises no ac- tions that cannot be executable under normal conditions.
Liveliness: Each state of the system is reachable from the initial state.
Deadlock-freeness: The system reaches no state that does not allow to in- teract with the environment and never leaves it.
Livelock-freeness: The system comprises no non-productive cycles.
Error tolerance and resynchronization: The system reaches a normal state within a limited time period after an error leading to an abnormal state has been occurred.

Safety: The system comprises no unspecified events.
Partial correctness: The system provides a special service when it termi- nates.
Termination: The system reaches each time the final state(s), or the initial state for cyclic systems.
Precise specifications are essential to allow the analysis of embedded sys- tems. The use of formal methods enables the automation of most aspects. We are particularly interested in the following testing problems:
The non-executability of parts of the system
Deadlock situations
Inconsistencies of the system, i.e. whether the system contains non- deter- ministic behaviors
Prohibited types of communication
Incompleteness
Checking of erroneous behaviors
The first five problems relate mainly to the system design phase, whereas the last question is more relevant for testing. These problems are usually very complex for models like extended finite state machines because of the inclusion of state variables and interaction parameters. Furthermore, the derivation of appropriate test cases is also an important issue for embedded systems testing and for software testing in general. In the context of embedded system testing, to decide whether a given part of the specification is executable is difficult. Therefore, the most work on verification and test development for embedded systems assumes that the system is specified in a simple state transition model without considering the data flow.

Detecting of Non-executable Parts
Lemma 4.1 The detection of non-executable parts is reducible to the problem of deciding whether a given p-EFSM modeling a function for a given compo- nent contains non-executable transitions.
The detection of non-executable transitions allows to deduce a specifica- tion whose all transitions are executable. This specification is obtained by eliminating all non-executable transitions as well as their descendants.
We can find all non-executable transitions in a p-EFSM as follows: A branch s → s' (i.e. a sequence of transitions starting at state s and ending at s') in the p-EFSM is non-executable if the two following conditions are

fulfilled:
∃x1, ··· , xk[δs(x1, ··· , xk)]
¬(∃x1, ··· , xk[δ' (x1, ··· , xk)])
where
s and s' are two given states of the p-EFSM.
δs(x1, ··· , xk) represents the intersection of the (for the given context x1, ··· , xk fulfilled) predicates of all transitions starting at the initial state s0 and ending at state s.
The problem for deciding, whether a given transition (or a branch) of the p-EFSM is non-executable, is resolvable under certain assumptions. Indeed, if the domains of state variables are finite and countable it is always possible to solve the problem analytically or by simulation. For each state of the p-EFSM it is possible to assess whether there is a context for which the predicates are not satisfied.
Note 1 An event e of the p-EFSM is represented as follows: g.e. The symbol
$ denotes either the input symbol ? or the output symbol !. The letter g represents the name of the component sending the event or receiving it. We use the letters s, c and a to designate sensors, the controller and actuators, respectively. The condition for a transition is written in brackets [], the output
event follows the bracket by :. The whole sequence of input, condition and output is denoted as ?gi.i, [c] :!go.o.
An example of an p-EFSM is given in Figure 4 that comprises three global variables x, y and z.
In Figure 4, we can show by means of the transition conditions for state
s3 and s4:
∃x, y, z[δs3 = true] and ¬(x, y, z[δs4 = true]) where
δs3(x, y, z) ≡ [((x >= −8) and (x <= 8)) and ((y >= −8) and (y <= 8)) and (y <= −1) and (z < x − 1)], and
δs4(x, y, z) ≡ [((x >= −8) and (x <= 8)) and ((y >= −8) and (y <= 8)) and (y <= −1) and (z < x − 1) and (x = z)]
In this example, we suppose that all the variable domains are of type integer, finite and countable. s3 is reachable from the initial state, but the branch s3 → s4 is non-executable.








?s.x,[(x>=-8) and (x<=8)]:
!s.x



s1





s0











?c.z,[z<x-1]:
!a.z
?s.x,[z=x]:
!c.x

?c.z,[z=x]:
!a.z


?c.z,[z<x-1]:
!a.z
s5




?c.z,[z>x+1]:
!a.z





?c.x,[x<0]:
!a.0


?c.x,[x<5]:
!c.2



s4








?s.z,[z<x-1]:
!c.x


?c.y,[(y>=-8) and (y<=8)]:
!a.y
?c.x,[(y>=0) and (x=y)]:	s3
!c.x

s2
?c.y,[y<=-1]:
!a.x



Fig. 4. A p-EFSM example for the controller

Detecting Deadlocks
Lemma 4.2 Deadlock detection is reducible to decide whether a given p- EFSM modeling a function of a component contains deadlocks, and generating a speciﬁc test sequence that leads to the deadlock states.

Let be given a p-EFSM, a state s, and s' , s' ,, s'
all the tail states of s.

2	m
We assume that for the following transitions: ⟨s, c1, i1, p1, o1, s' , c' ⟩, ⟨s, c2, i2,
1	1

p2, o2, s' , c' ⟩, ·· ·, ⟨s, cm, im, pm, om, s' , c'
⟩ the predicates p1, p2, ··· , pm are

2	m	m
satisfied.  The p-EFSM contains a deadlock state if there exists a state s
in the p-EFSM such that the following condition is satisfied:
∃x1, x2, ··· , xk[δs(x1, x2, ··· , xk) and ¬p1 and ¬p2 ··· and ¬pm]
pi denote the enabling predicates for leaving the state s. If the condition is satisfied, then there is no executable input event at the state s, which means that the state s is a deadlock state.
In the p-EFSM of Figure 4 the state s5, for instance, represents a deadlock state. The condition for checking the presence of deadlocks for this state is:
∃x, y, z[δs5(x, y, z) and ¬p5]
⇔ ∃x, y, z[((x >= −8) and (x <= 8)) and ((y >= −8) and (y <= 8)) and (y <= −1) and (z < x − 1) and (x < 5) and ¬(z > x + 1) and ¬(z = x)]

This condition is true, for instance, for the context x = 2, y = 1 and z = 0 noted (x/1, y/1, z/0). Therefore, the state s5 represents a deadlock state for the given context. The input sequence leading to the deadlock state and the corresponding generated output sequence are ρ[s0, s5](x/2, y/1, z/0) = ”?s.2; ?c.1; ?s.0; ?c.2” and β[s0, s5](x/2, y/1, z/0) = ”!s.2; !a.1; !a.2; !c.2; !c.2”,
respectively. ρ[s0, s](x1/λ1, ··· , xn/λn) and β[s0, s](x1/λ1, ··· , xn/λn) denote functions that provide an input sequence or an output sequence, respectively, for the context (x1/λ1, ··· , xn/λn) from the initial state s0 until the state s. The semi-colon ; is used as an event sequencing operator.
Lemma 4.3 For a given state s in the p-EFSM, it is decidable whether the state s is a deadlock state. If s is a deadlock state, then a test sequence leading to the deadlock state can be derived.

Detecting Non-Determinism
Lemma 4.4 Non-determinism can be reduced to decide whether a p-EFSM describes non-determinism and to determine test sequences that lead to non- deterministic behaviors.
Let s denote a state of a p-EFSM. Suppose that we have transitions t =
⟨s, c1, i1, p1, o1, s' , c' ⟩ and t' = ⟨s, c2, i2, p2, o2, s' , c' ⟩ with the same edge state
1	1	2	2
s and satisfying conditions (i) and (ii):
The predicate p1 holds. The input event i1 has the form ?g.e1.
The predicate p2 holds. The input event i2 has the form ?g.e2. We also assume that the following condition
x1, x2, ··· , xk[δs(x1, ··· , xk) and p1 and p2 and (e1 = e2)]  (*)
is satisfied and the values λ1, ··· , λk are the solutions for the variables x1, ··· , xk to meet predicates pi. Since δs(x1, ··· , xk) is true, the input event sequence ρ[s0, s](x1/λ1, ··· , xk/λk) traces the path from the initial state s0 of the p-EFSM to the state s.
If the condition above holds, then
”ρ[s0, s](x1/λ1, ··· , xk/λk); ?g.e1(x1/λ1, ··· , xk/λk)”
is an event sequence to trace the path from the initial state s0 to the state s' . Here, ?g.e1(x1/λ1, ··· , xk/λk) is obtained by assigning the values λ1, ··· , λk to variables x1, ··· , xk. Since the values λ1, ··· , λk also satisfy the condition p2, ”ρ[s0, s](x1/λ1, ··· , xk/λk); ?g.e2(x1/λ1, ··· , xk/λk)” is a test sequence to trace the path from the initial state s0 to the state s' . The value of the ex- pression e1(x1/λ1, ··· , xk/λk) is the same as that of e2(x1/λ1, ··· , xk/λk). This means that the p-EFSM contains non-determinisms and that the sequence

”ρ[s0, s](x1/n1, ··· , xk/nk); !g.e1(x1/n1, ··· , xk/nk)” is an event sequence rep- resenting non-deterministic behaviors. The state s is called the state starting non-determinism. Since it is decidable whether the condition (*) is satisfied, the following lemma holds.
Lemma 4.5 For a given state s in the p-EFSM, it is decidable whether s is a state starting non-determinism. If s is such a state, then an event sequence representing non-determinism can be derived.
For the p-EFSM in Figure 4, for instance, there are two paths from s2 to
s3, i.e. transitions t3 = ⟨s2, c3, i3, p3, o3, s2, c' ⟩ and t4 = ⟨s2, c4, i4, p4, o4, s3, c' ⟩.
3	4
We can show that the input event i3 of t3 is ”?c.x” and the input event of t4
is ”?c.y”, and that
∃x, y[δs2(x, y, z) and p3 and p4 and (x = y)]
⇔ ∃x, y[((x >= −8) and (x <= 8)) and ((y >= −8) and (y <= 8)) and ((y >= 0) and (y = x)) and (y <= −1) and (x = y)]
which can be satisfied for the context (x/1, y/1). Therefore, we conclude that the p-EFSM of the example is non-deterministic.

Detecting Prohibited Communications
Lemma 4.6 Prohibited communications is reducible to decide whether a p- EFSM describing a function of a given component contains prohibited events and to determine them if they exists.
Let be given a p−EFSMs, p−EFSMc and p−EFSMa that model func- tions of the components: sensors, controller and actuators, respectively. Spec- ification relations between these components can functionally be expressed as follows:
Let be given a transition ts ∈ Ts : ts = ⟨ss, cs, is, ps, os, s' , c' ⟩ with

ss ∈ Ss, cs ∈ Cs, is ∈ Is, ps ∈ Ps, os ∈ Os, s'
s	s
∈ Ss, c' ∈ Cs

⇒ ∃tc ∈ Tc : tc = ⟨sc, cc, ic, pc, oc, sc, c' ⟩|os ≡ ic
Let be given a transition tc ∈ Tc : tc = ⟨sc, cc, ic, pc, oc, s' , c' ⟩ with

sc ∈ Sc, cc ∈ Cc, ic ∈ Ic, pc ∈ Pc, oc ∈ Oc, s'
∈ Sc, c'
c	c
∈ Cc,

if ic ∈ Os ⇒ ∃ts ∈ Ts : ts = ⟨ss, cs, is, ps, os, s' , c' ⟩ and ic ≡ os.
s	s
Let be given a transition ta ∈ Ta : ta = ⟨sa, ca, ia, pa, oa, s' , c' ⟩ with

sa ∈ Sa, ca ∈ Ca, ia ∈ Ia, pa ∈ Pa, oa ∈ Oa, s'
∈ Sa, c'
a	a
∈ Ca

⇒ ∃tc ∈ Tc : tc = ⟨sc, cc, ic, pc, oc, s' , c' ⟩ and oc ≡ ia.
c	c
For actuators, we assume that:
∀ta ∈ Ta : ta = ⟨sa, ca, ia, pa, oa, s' , c' ⟩⇒ oa ≡ ε (ε empty event)
a	a

Considering the facts above, we can conclude that an embedded system contains a prohibited communication if particularly one of the following con- ditions holds:
∃ts ∈ Ts : ts = ⟨ss, cs, is, ps, os, s' , c' ⟩ | 
s	s
∀tc ∈ Tc : tc = ⟨sc, cc, ic, pc, oc, s' , c' ⟩|os ≡ ic
c	c
∃ta ∈ Ta : ta = ⟨sa, ca, ia, pa, oa, s' , c' ⟩ | 
a	a
∀tc ∈ Tc : tc = ⟨sc, cc, ic, pc, oc, s' , c' ⟩|os ≡ ic
c	c
∃ta ∈ Ta : ta = ⟨sa, ca, ia, pa, oa, s' , c' ⟩ | oa ≡ ε
a	a
These predicates assume that first, it exists at least one input event gen- erated by the sensors that is never used in the controller. Secondly, the actu- ator contains a transition whose input event is not specified in the controller. Thirdly, it exists at least a transition in actuators whose output event is not empty.
Lemma 4.7 Let be given all the p-EFSMs of all components, it is decidable whether the whole system contains prohibited behavior as shown above.
Detecting Incompleteness
Lemma: Incompleteness is reduced to decide whether a given p-EFSM of a component is incomplete and to determine the states presenting incomplete- ness if they exist.
Let be given a p − EFSMs, p − EFSMc and p − EFSMa that denote p-EFSMs of sensors, controller and actuators, respectively. If one of the following conditions holds, the corresponding p-EFSM is incomplete:
(∃ss ∈ Ss, sc ∈ Sc, sa ∈ Sa) and (∃is ∈ Is, ic ∈ Ic, ia ∈ Ia) such that
ts = ⟨ss, cs, is, ps, os, s' , c' ⟩ /∈ Ts, tc = ⟨sc, cc, ic, pc, oc, s' , c' ⟩ /∈ Tc,
s	s	c	c
ta = ⟨sa, ca, ia, pa, oa, s' , c' >/∈ Ta)
a	a
For a given p-EFSM, it is decidable whether this p-EFSM is incomplete. The states in which the p-EFSM presents incompleteness can be then detected. This can be carried out by checking all the states of the specified behavior of the given p-EFSM. Each time the specified input events have to be checked against the potential input events at the given state.
The p-EFSM given in Figure 4, for instance, is incomplete because the initial state s0, for example, presents incompleteness.
Conclusion
In this work we have presented an analysis approach dedicated to reliable em- bedded systems which can be described as (predicated) extended finite state

machines (p-EFSMs). The mapping of this formalism on formal description techniques like Estelle or SDL has been addressed. We identified the differ- ent analysis and testing issues based on p-EFSMs. The solutions of these problems depending on the ranges of the state variables and interaction pa- rameters have been demonstrated. The main advantage of the approach is the use of already standardized specifications languages (FDTs). These are characterized not only by a formal syntax but also a formal semantic and have been successfully used in the formal design of many communication protocols and communicating systems [9]. In addition, many test generation methods (e.g. transition tour method, distinguishing sequences’ method, characteris- ing sequences’ method, unique input/output sequences’ method, W-method, etc. [6] [7) have been developed for state/transition models which build the background of these FDTs.
We are now developing a knowledge-based diagnosis system to explain the reasons of errors in faulty implementations after execution test suites (sets of test cases). In addition, we plan to investigate real-life embedded systems especially from the automotive area to study the extent of the application of the analysis and testing approach.
References
Aho, A. V. et al, An optimisation technique for protocol conformance test generation based on UIO sequences and Rural Chinese Postman Tours, In S. Aggarwal and K. Sabnani, editors, Protocol Specification, Testing, and Verification, New Jersey, 1988.
Buessow, R., R. Geisler, and M. Klar, Specifying safety-critical embedded systems with statecharts and Z: A case study, In Proceedings of Fundamental Approaches to Software Engineering (FASE’98), Lisbon, 1998.
Corts, L. A., P. Eles, and Z. Peng, Veriﬁcation of embedded systems using a petri net based representation, In Proceedings of the 13th international symposium on System synthesis, Madrid, 2000.
Fujiwara et al, Test selection based on ﬁnite state models, IEEE transaction on Software Engineering 17(6): 591-603, 1991.
Henniger, O., A. Ulrich, and H. Koenig, Transformation of Estelle modules aiming at test case derivation, Chapmann & Hall, 1995.
Information processing systems - Open Systems Interconnection - Estelle: A formal description technique based on an extended state transition model, International Standard ISO 9074, 1989.
Mendler, M., and G. Luettgen, Statecharts: From Visual Syntax to Model-Theoretic Semantics, In K. Bauknecht, W. Brauer, and Th. Mck (editors), Workshop on Integrating Diagrammatic and Formal Specification Techniques (IDFST 2001), pages 615-621, Vienna, 2001.
Potter, B., J. Sinclair, and D. Till, Introduction to Formal Speciﬁcation and Z 2ndEdition, Prentice Hall PTR, 1996.
Richter, H. et al, A Concept For a Reliable, Cost-Effective, Real-Time Local-Area Network for Automobiles, In Proceedings of Joint conference Embedded in Munich and Embedded Systems, Munich, 2004.
Speciﬁcation and Description Language SDL ’92, ITU-T Recommendation Z.100, 1992.
