

Electronic Notes in Theoretical Computer Science 223 (2008) 47–60
www.elsevier.com/locate/entcs

Approximated Reachability on Hybrid Automata: Falsification meets Certification
K. Bauer a,1 R. Gentilini a,2 K. Schneider a,3
a Department of Computer Science, Embedded Systems Group, University of Kaiserslautern (Germany)


Abstract
Undecidability of the reachability problem is ubiquitous in the context of hybrid automata. Being mostly based on either bounded reachability or on the notion of simulation preorder, current techniques for the approximated reachability analysis force to choose between under- and over-approximations.
In this paper, we introduce a novel method for the reachability analysis of hybrid automata featuring
(1) the ability of combining the certification and the falsification of reachability properties, and (2) the applicability to highly expressive families of hybrid automata, whose dynamics are not amenable to an exact representation.
Keywords:  Hybrid Automata, Reachability Analysis, Abstraction-Refinement.


Introduction
Hybrid automata [10,2] provide an appropriate modeling paradigm for systems where continuous variables interact with discrete modes. Such models are frequently used in complex engineering fields like embedded systems, robotics, avionics, and aeronautics [1,3,20,9]. In hybrid automata, the interaction between discrete and continuous dynamics is naturally expressed by associating a set of differential equa- tions to every location of a finite automaton.
Finite automata and differential equations are well established formalisms in mathematics and computer science. Despite of their long-standing tradition, their combination in form of hybrid automata leads to surprisingly difficult problems
that are often undecidable. In particular, the reachability problem is undecidable
for most families of hybrid automata [16,15,17,11,2,5], and the few decidability results are built upon strong restrictions of the dynamics [4,12]. The reachability

1 Email: k bauer@informatik.uni-kl.de
2 Email: gentilin@informatik.uni-kl.de
3 Email: schneider@informatik.uni-kl.de

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.030

analysis of hybrid automata is a fundamental task, since checking safety properties of the underlying system can be reduced to a reachability problem for the set of bad configurations [10].
For this reason, a growing body of research is being developed on the issue of dealing with approximated reachability on undecidable – yet reasonably expressive – hybrid automata [6,21,8,19,20]. To this end, most of the techniques proposed so far either rely on bounded state-reachability or on the definition of finite ab-
stractions. While the first approach suffers inherently of incompleteness, the quest for soundness is a key issue in the context of methods based on abstractions. In fact, abstractions can introduce unrealistic behaviors that may yield to spurious
errors being reported in the safety analysis. Usually, a simulation preorder is re- quired to relate the abstraction to the concrete dynamics of the hybrid system under consideration, ensuring at least the correctness of each response of (abstract) non
reachability. In [7], a novel abstraction-refinement framework has been proposed, based on the encoding of both over- and under-approximations of the reachable con- figurations. Hence, both sound proofs and sound counter-examples can be reported
for reachability (i.e. safety).
Unfortunately, the abstraction-refinement framework in [7] is based on the exact analysis of the continuous dynamics in the underlying hybrid automata. Namely, it requires (1) the ability of solving the set of differential equations in each location l, obtaining the corresponding flow functions fl, and (2) the ability of recovering an exact symbolic representation of the image-set fl(r), for an arbitrary initial region
r. These requirements strongly limit the applicability of the method in [7]. In particular, though (possibly) undecidable, the classes of hybrid automata amenable to [7] have relatively simple continuous dynamics, and thus they still do not allow the faithful modeling of real dynamical systems.
In this paper, we propose a new sequence of abstractions that still is adequate both to certify and to falsify safety properties on the underlying hybrid automata. However, the computation of our abstractions does not require to recover exactly the target set of the flow’s evolution in each location, fl(r). Rather, we assume
that the latter can be only over-approximated and under-approximated. Hence, the method applies to a family of hybrid automata significatively more expressive than the one covered by [7]. As an example, we can now consider the evolution of continuous variables according to flows involving trigonometric terms, that can not be dealt with by means of symbolic computation, but are easily amenable to approximation methods (e.g by means of interval arithmetic).
The paper is organized as follows. Following the preliminaries (in Section 2), Section 3 introduces our new sequence of abstractions, so called ABB abstractions. Section 4 proves that ABB abstractions can be used to both certify and falsify safety
properties on hybrid automata: Related efficient algorithms (linear in the size of the ABB abstractions) are provided in Subsection 4.1. Section 5, finally sketches a sound three-valued semantics for more general branching properties (namely CTL
formulas) on ABB abstractions.

Preliminaries
In this section, we introduce the basic definitions and the notations used in the remainder of the paper.
Definition 2.1 [Hybrid Automata [4]] A Hybrid Automaton is a tuple H = (L, E, X, Init,Inv, F, G, R) with the following components:
a finite set of locations L
a finite set of discrete transitions (or jumps) E ⊆ L × L
a finite set of continuous variables X = {x1,... xn} that take values in R
an initial set of conditions: Init ⊆ L × Rn
Inv: L → 2Rn , the invariant location labeling
F : L × Rn → Rn, assigning to each location l ∈ L a vector field F (l, ·) that defines the evolution of continuous variables within l
G : E → 2Rn , the guard edge labeling
R : E × Rn → 2Rn , the reset edge labeling.
We write v to represent a valuation (v1,..., vn) ∈ Rn of the variables’ vector x =
(x1,..., xn), whereas x˙ denotes the first derivatives of the variables in x (they all
depend on the time, and are therefore rather functions than variables). A state in H is a pair s = (l, v), where l ∈ L is called the discrete component of s and v is called the continuous component of s. A run of H = (L, E, X, Init, Inv, F, G, R),
starts at any (l, v) ∈ Init and consists of continuous evolutions (within a location) and discrete transitions (between two locations). Formally, a run of H is a path with alternating continuous and discrete transitions in the time abstract transition system of H, defined below:
Definition 2.2 The time abstract transition system of the hybrid automaton H = (L, E, X, Init, Inv, F, G, R) is the transition system TH =(Q,Q0, →), where:
Q ⊆ L × Rn and (l, v) ∈ Q if and only if v ∈ Inv(l)
Q0 ⊆ Q and (l, v) ∈ Q0 if and only if v ∈ Init(l) ∩ Inv(l)
The transition relation → is defined as follows:
there is a continuous transition (l, v) → (l, v'), if and only if there is a differ- entiable function f : [0, t] → Rn, with f˙ : [0, t] → Rn such that:
f (0) = v and f (t) = v'
for all ε ∈ (0, t), f (ε) ∈ Inv(l), and f˙(ε) = F (l, f (ε)).
there is a discrete transition (l, v) → (l', v') if and only if there exists an edge
e = (l, l') ∈ E, v ∈ G(l) and v' ∈ R((l, l'), v).
A region is a subset of the states Q of TH =(Q,Q0, →). Given a region α, the predecessor region Pre(α) is defined as the region {q ∈ Q | ∃q' ∈ α.q → q'}.
The relations of simulation and bisimulation, recalled below, are two fundamen-
tal tools in the context of hybrid automata abstraction.

Definition 2.3 [Simulation] Let T 1 = (Q1, Q1, →1), T 2 = (Q2, Q2, →2) be two
0	0
transition systems, and consider a partition P over Q1 ∪ Q2. A simulation from T 1
to T 2 is a nonempty relation ≤S⊆ Q1 × Q2 such that, for all p ≤S q it holds:
p ∈ Q1 iff q ∈ Q2, and [p]P = [q]P , where [p]P denotes the class of p in P.
0	0
For each node p' such that p →1 p', there exists a node q' such that p' ≤S q'
and q →2 q'.
If there exists a simulation from T 1 to T 2, then we say that T 2 simulates T 1, denoted by T 1 ≤S T 2. If T 1 ≤S T 2 and T 2 ≤S T 1, then the transition systems T 1 and T 2 are said simulation-equivalent (or similar ), denoted by T 1 ≡S T 2.
Definition 2.4 [Bisimulation ] Let T 1 = (Q1, Q1, →1), T 2 = (Q2, Q2, →2) be two
0	0
transition systems and consider a partition P over Q1 ∪ Q2.  A bisimulation for
T 1,T 2 is a nonempty relation ≡B⊆ Q1 × Q2 such that, for all p ≡B q it holds:
p ∈ Q1 iff q ∈ Q2, and [p]P = [q]P .
0	0
For each node p' such that p →1 p', there exists a node q' such that p' ≡B q'
and q →2 q'.
For each node q' such that q →2 q', there exists a node p' such that p' ≡B q'
and p →1 p'.
If there exists a bisimulation relation for the transition systems T 1,T 2, then T 1 and
T 2 are said bisimilation-equivalent (or bisimilar ), denoted by T 1 ≡B T 2.
From an algorithmic point of view, the characterization of the (maximum) bisim- ulation equivalence in terms of a coarsest partition problem [18,13] leads to the bisimulation algorithm for hybrid automata [10] depicted in Figure 1. Such an al- gorithm refines an initial partition over the states of an hybrid automaton H, until each class is stable w.r.t. the transition relation of TH , i.e. until for each pair of classes (α, β), it holds β ∩ Pre(α) ∈ {∅, β}.

Approximated Bounded Bisimulation Abstractions (ABB) of Hybrid Automata
In this section, we build up the basement of our safety analysis method for hybrid automata, featuring the ability of both certifying and falsifying safety.
Such a feature distinguishes our approach from traditional techniques based on the simulation preorder, that allow only to over-approximate the set of configu- rations admitting an evolution toward the target (unsafe) states. As in [20], we assume to deal with highly expressive hybrid automata, whose dynamics could be in principle not amenable to an exact symbolic computation. This means that, given a region α of the hybrid automaton H, the set of states
Pre(α) = {x | x can evolve to α by means of a continuous/discrete transition} can not be exactly computed (and represented). Rather, we assume that the prede-




Fig. 1. Bisimulation on hybrid automata.

cessor region Pre(α) can be only over- and under-approximated. In the remainder of this work, we will use the notation Pre↑(α) (resp. Pre↓(α)) to refer to an arbitrary over- (resp. under-) approximation of Pre(α), i.e. Pre↓(α) ⊆ Pre(α) ⊆ Pre↑(α).


Fig. 2. Construction of ABB abstractions.

Note, that in our context, the construction of a bisimulation quotient is not amenable to the classic partition refinement approach, independently from its size. More precisely, the traditional partition-refinement bisimulation algorithm (cfr. Fig- ure 1, in the previous section) is subject not only to problems of non-termination (that naturally occur for undecidable hybrid automata) but also of non computabil- ity ! Such a procedure relies in fact on the availability of the operation Pre(α), for the predecessor region.
The development of our method departs exactly from attempting at recovering a sort of approximation of bisimulation for our families of hybrid automata. In more detail, we will build a succession of abstractions, that we call approximated bounded bisimulation (ABB) abstractions: Such abstractions retain enough information to provide both an over-approximation and an under-approximation of the set of states fulfilling a given reachability property.
The construction of the n-th element in our succession of abstractions (n-ABB abstraction) is given in Figure 2, and can be better understood if compared with the related classic bisimulation algorithm. There are three main differences between the procedure in Figure 1 (for bisimulation), and the construction of an n-ABB abstraction, given in Figure 2.
First, the fix-point is replaced by a bounded number of n iterations (as in clas- sic bounded bisimulation).
Second, and more important, the fun- damental step of two-way split for clas-

sic bisimulation, is replaced by a three-way split in an n-ABB abstraction.
As depicted in Figure 3, on the right, the classic two way-split induced by the class α on the class β, leads to the two new regions:
β \ Pre(α)
 β ∩ Pre(α) Fig. 3: Two way split

β1 = Pre(α) ∩ β	∧	β2 = β \ Pre(α)
Here, β1 must evolve to α, while β2 does not reach α. In a three way split, the approximations Pre↓(α),Pre↑(α) are employed in place of Pre(α). This leads to the three way split of β via α into:
β1 = Pre↓(α) ∩ β	∧	β2 = β ∩ (Pre↑(α) \ Pre↓(α))	∧	β3 = β \ Pre↑(α)
Now, β1 must evolve to α, β2 may evolve to α, while β3 does not lead to α, as illustrated in Figure 4, below.
The last difference between a bounded bisimulation and an n-ABB abstraction involves the definition of the edges over the two abstractions. In fact, in ABB abstractions the control graphs are designed so that the information relative to a must /may evolution over regions is encoded into an edge, as soon as such an information is made explicit via a three-way split. More precisely, the edges of an n-ABB-abstraction are labeled by weights w ∈ {1 ... n} ∪ {∞}.  Infinite weights

among classes denote simply that the corresponding edge over-approximates the trajectory linking the states in such classes (i.e. has a may nature). To introduce the meaning of integer weights, denote by γi the (unique) region in the i-ABB abstraction Ai which contains γ, where γ is a class in the finer n-ABB abstraction An≥i. Then, an integer weight-label m /= ∞ on the transition (δ, γ), encodes that the corresponding edge under-approximates the trajectories linking δ to γn−1. The different values of integer-weights allows to further recognize whether the under- approximation operator Pre↓(γ) has been recurrently used to refine δ. The meaning of integer weights is more precisely outlined by Lemma 3.1, below, that concludes this section.
Lemma 3.1 (Interpretation of the Weights) Let α →m β be a weighted transi- tion in the n-ABB abstraction An, with m ≤ n. For all n ≥ m' ≥ m it holds: αm' → βm'−1 is a must-transition, i.e. ∀x ∈ αm' ∃y ∈ βm'−1 such that H admits a trajectory departing from x and leading to y.
Proof. We proceed by induction on k = n−m. For the base case, assume n−m = 0.
Then, α n→=m β, and we need to prove that α → βn−1 is a must transition i.e.
∀x ∈ α, ∃y ∈ βn−1 such that H admits a trajectory from x to y. By Line 11 of Algorithm 2, Pre↓(βn−1) ⊇ α is a necessary condition for the definition of the
weighted edge α →n  β. Such a condition yields our claim. For the inductive step,
assume k = n − m > 0 and let α →m β. By Lines 11–12 in Algorithm 2 we have that
(1) Pre↓(βn−1) ⊇ α, and (2) αn−1 →m βn−1 is a weighted edge in An−1. Condition
(1) ensures that α → βn−1 is a must transition. Our inductive hypothesis applied to αn−1 →m βn−1 finally yields that, ∀m ≤ m' ≤ n − 1, αm' → βm'−1 is also a must transition, i.e. our thesis.	 

ABB Abstractions and Reachability: Safety Falsifi- cation meets Certification
In this section, we prove that the abstraction-refinement framework introduced in Section 5 can be used to both prove and falsify safety properties on the under-




β \ Pre↑(α)
β ∩ (Pre↑(α) \ Pre↓(α)) β ∩ Pre↑(α)
Fig. 4. The three-way split employed in the construction of ABB abstractions.

lying hybrid automata. To obtain such a result, we show that ABB abstractions provide enough information to both under-approximate, and over-approximate the possible global evolutions of the related dynamical system. In turn, safety can be established on the ground of overapproximations (of reachable ‘bad’ states), while underapproximations are sufficient to deal with safety falsification.
We start by establishing, in Theorem 4.1, a sufficient condition to determine whether a path in a n-ABB abstraction provides a faithful representation of a run-prefix. Thus, such a path can be used in the context of underapproximated reachability analysis.
Theorem 4.1 (Underapproximated Reachability) Consider a weighted path

p : α = γ
m→0 ... mk−1 γ
= β in the n-ABB-abstraction An for the hybrid automaton

0	→	k
H. Assume that, for all 0 ≤ i ≤ k, it holds mi ≤ n − i. Then, for each 0 ≤ i ≤ k, H admits an evolution from α = γ0 to γn−i.
Proof. According to Lemma 3.1 and by our condition mi ≤ n − i, each transition
γn−i → γn−i−1 is a must-transition, i.e. each x ∈ γn−i admits an evolution to a
i	i+1	i
point x' ∈ γn−i−1 in H. Thus, starting in α = γn and successively following these
i+1	0
must-transitions, it is possible to construct for each x ∈ α = γ0 a feasible trajectory of H, x = x0 ~ x1 ~ ... ~ xi, with xi ∈ γn−i.	 
Theorem 4.2 establishes that ABB abstractions are amenable also to overapproxi- mated reachability analysis. This result is proved upon the existence of a simulation preorder relating each ABB abstraction to the time abstract transition system of the corresponding hybrid automaton.
Theorem 4.2 (Overapproximated Reachability) Consider an ABB abstrac- tion An for the hybrid automaton H, let s, q be two states of H, and denote by α = [s],β = [q] the corresponding classes in An. If H admits a trajectory from s to q, then An admits a path from α to β.
Proof. Assume that H admits a trajectory from s to q, and consider the classes of An traversed along such a trajectory, α1,..., αk. Then, for all i = 1 ... k, αi ⊆
Pre↑(αn−1).  By definition of En we conclude that (α1, α2,..., αk) is a path in
i+1	A
An.	 
Corollary 4.3 combines the above results on over- and under-approximated reacha- bility into a three-valued approach to the safety analysis of hybrid automata.
Corollary 4.3 (Safety) Let An = ⟨Qn, En⟩ be an n-ABB abstraction of the hybrid automaton H computed w.r.t. the initial partition P. Assume that P is compatible 4
w.r.t. the initial states of H, IH, and w.r.t. a set of bad conﬁgurations for H, BH. Then, denoted by I (resp. B) the set of classes in An reﬁning IH (resp. BH):
H is safe w.r.t. BH, if ∀α ∈ I, ∀ β ∈ B : β is not reachable from α in An.

4 A partition P on Q is compatible w.r.t. r ⊆ Q iff for each class α in P, α ∩ r ∈ {r, ∅}.

H is not safe w.r.t. BH
, if An admits a path p : I e α = γ0
m→0 ... mk−1 γ  =

β ∈ B satisfying mi ≤ n − i, for all 0 ≤ i ≤ k.
We are now ready to provide an applicative character to Corollary 4.3, i.e. to define an efficient safety analysis algorithm on ABB abstractions. Such an algorithm is discussed in the following subsection.

Efficient Algorithmic Safety Analysis on ABB Abstractions
The algorithmic ‘positive’ safety analysis on simulation-based abstractions of hybrid automata, relies in general on the visit of the corresponding finite graph structure, by means of traditional linear graph exploration algorithms. Here, ‘positive’ refers to the fact that the only certiﬁcation of safety can be stated, since the solely non- reachability results (for a region of bad states) can be trusted, due to overapproxi- mation. The procedure depicted in Figure 5 shows that the algorithmic exploration of ABB abstractions leads instead to a three-valued safety analysis, using again only a linear number of steps. In our three-valued approach, boolean values refer to ei- ther a positive or a negative response to the safety inquiry, while the third value ⊥ models the fact that the given abstraction is too coarse to decide the problem.
The algorithm in Figure 5 is indeed a variant of the classic breadth first search exploration, where the weights on the edges of the abstraction are also taken into account, according to Corollary 4.3. More precisely, the procedure takes as input an n-ABB-abstraction An = ⟨Qn, En⟩, a set of initial regions I ⊆ Qn and a set of (bad) regions 5 , B ⊆ Qn.
The first loop at lines (4)–(10) uses a queue Q to collect the states of An relevant to falsify the safety of the underlying hybrid automaton, according to Theorem 4.1 and Corollary 4.3. Namely, this loop collects the states of An reachable via a path p in which each edge ei is labeled by a weight mi satisfying the relation mi ≤ n − i. This is done by:
First, maintaining for each node inserted into Q, say α, the length of the ‘feasible’ path leading to its discovery. The latter is stored in the field l(α).
Second, selecting the edges having a weight 0 ≤ m ≤ n − l(α), in order to discover new nodes from α, using again ‘feasible’ paths (cfr. line (9)).
Here, ‘feasible’ naturally refers to our constraint on the disposition of weights along the paths, given in Theorem 4.1. If any of the abstract states so collected belongs to the set B given as input, then the algorithm terminates returning the value ‘not safe’, meaning that the underlying hybrid automaton is unsafe.
The second loop completes the visit to recover the states of An relevant for certifying the safety of the abstracted dynamical system, according to Theorem 4.2 and Corollary 4.3. The latter are given by the rest of reachable nodes in An (via an arbitrary path). If also none of these regions belongs to B, the procedure returns

5 We naturally assume that An = ⟨Qn,En⟩ has been computed w.r.t. an initial partition for the hybrid automaton H compatible w.r.t. to the initial and the bad configurations of H, IH , BH . Hence, I ⊆ Qn and B ⊆ Qn refine IH and BH , respectively.




Fig. 5. Linear Three-valued safety analysis algorithm on ABB-abstractions.

‘safe’. Theorem 4.4 below states that each boolean answer ‘safe’ (resp. ‘not safe’) returned by Algorithm 5 is sound.
Theorem 4.4 (Soundness) If the algorithm SafetyAnalysis (An,I, B) returns ‘not safe’, then the hybrid automaton H abstracted by An admits a run to a bad conﬁguration x ∈ α ∈ B. Conversely, if SafetyAnalysis (An,I, B) returns ‘safe’, then H does not admit any run to a bad conﬁguration x ∈ α ∈ B.
Proof. By Lines (16)–(18) in Algorithm 5, the procedure returns ‘not safe’ iff upon the termination of the two loops there exists a state α ∈ B, whose corresponding field reach(α) is 1. By Lines (6)–(7) reach(α) = 1 iff α has been inserted into the queue Q within the first loop. Thus, by Corollary 4.3, to establish our claim for each negative boolean answer ‘not safe’ it is sufficient to show that a state β is
inserted into the queue Q iff it An contains a path p : α = γ m→0 ... mk−1 γ = β ∈ B
0	→	k
satisfying mi ≤ n − i, for all 0 ≤ i ≤ k. Such a statement can be easily proved by induction on the number of insertions into Q.
Similarly, the soundness of each positive boolean answer ‘ safe’, can be estab-

lished on the ground of Corollary 4.3, and by induction on the number of insertions into either the queue Q or the queue Q'.	 
If the algorithm terminates with output ‘perhaps not safe’, then the abstraction is too coarse to make a decision. Theorem 4.5, below, finally establishes the claimed linear complexity of our algorithm, and concludes this section.
Theorem 4.5 (Complexity) The algorithm SafetyAnalysis (An,I, B) termi- nates in time O(|Qn + En|), where An = ⟨Qn, En⟩.
Proof. Overall the execution of the algorithm, the adjacency list of each node α can be inspected at most once (either at lines (8)–(10), or at line (15)). In fact, such inspections are guarded by the condition reach(α) = 0, and the field reach(.) is updated either to 1 or to ⊥ as soon as it is discovered to be 0. It follows that the global cost of executing the innermost for-loops is O(  α∈Qn En(α)) = O(En). Such a cost determine the entire complexity of the external while-loops at lines
(4)–(15). The cost of the rest of the code is clearly O(Qn).	 

A 3-Valued Semantics for CTL on ABB Abstractions
After having introduced in Section 4.1 a framework for the three-valued safety anal- ysis of hybrid automata, in this section we consider stronger properties expressed by means of the temporal logic CTL. Definition 5.1 and Definition 5.2 recapitulate syntax and semantics of CTL formulas on hybrid automata. Note that due to the density of the underlying time framework the neXt operator is omitted [2,10].
Definition 5.1 [CTL for Hybrid Automta] Let AP be a finite set of propositional letters and p ∈ AP. CTL is the set of formulas defined by the following syntax:
φ ::= p |¬φ | φ1 ∧ φ2 | φ1 ∨ φ2 | E(φ1Uφ2) | A(φ1Uφ2)
Definition 5.2 [CTL Semantics] Let H = (L, E, X, Init, Inv, F, G, R) be a hybrid automaton, and let AP be a set of propositional letters. Consider lAP : L×X → 2AP. Given φ ∈ CTL and q ∈ Q, φ)(s) is inductively defined:
p)(q) = 1 if and only if p ∈ lAP(s)
¬φ) = ¬ φ)
φ ⬦ ψ) = φ) ⬦ ψ) for ⬦ ∈ {∧, ∨}
E(φUψ))(q) = 1 iff there exists a run ρ departing from q that admits a prefix
ρ∗ := q1 → ... → qn, where q = q1, qi = (l, vi), satisfying:
ψ)(qn) = 1 and for 1 ≤ i < n:  φ)(qi) = 1 
for each 1 ≤ i < n, if qi → qi+1 is a continuous transition, then there exists a differentiable function f : [0, t] → Rn for which:
f (0) = vi and f (t) = vi+1
for all ε ∈ (0, t), f (ε) ∈ Inv(l), and f˙(ε) = F (l, f (ε))
for all ε ∈ (0, t), q' = (li,f (ε)) satisfies  φ ∨ ψ)(q') = 1 

A(φUψ))(q1) = 1 iff for all runs ρ departing from q there exists a prefix ρ∗ :=
q1 → ... → qn, where q = q1, qi = (l, vi), satisfying:
ψ)(qn) = 1 and for 1 ≤ i < n:  φ)(qi) = 1 
for each 1 ≤ i < n, if qi → qi+1 is a continuous transition, then there exists a differentiable function f : [0, t] → Rn for which:
f (0) = vi and f (t) = vi+1
for all ε ∈ (0, t), f (ε) ∈ Inv(l), and f˙(ε) = F (l, f (ε))
for all ε ∈ (0, t), q' = (li,f (ε)) satisfies  φ ∨ ψ)(q') = 1 
H ▶ φ iff ∀q ∈ Q0 : φ)(q) = 1.

Since ABB abstractions encode both an over- and an under-approximation of the dynamics in the underlying hybrid automaton H, a preservative three valued seman- tics for the logic CTL can be derived thereof. Intuitively, the simulation preorder H ≤S An allows us to use unbounded runs for the falsification (resp. certification) of CTL-formulas of the form EφUψ (resp. AφUψ), whereas the must-transitions induced by integer weights allow to deal with the other formulas. However, in con- trast to the pure safety analysis, for CTL properties it is important to consider not only the target state of a given evolution, but also the intermediate configurations. In order to follow such intermediate configurations, we assume here to dispose of an additional edge-label: The label dir. Such a label simply distinguishes whether an integer weighted transition from α to β encodes a must-trajectory that passes directly from α to βn−1 (i.e. without never leaving these two regions).
Given the above premises, Definition 5.3 formalizes our three valued semantics for CTL on ABB abstractions.

Definition 5.3 [Three Valued CTL Semantics on ABBs] Let H be a hybrid au- tomaton, let AP be a finite set of atomic propositions, and let P be a partition of the state space of H consistent w.r.t. the labeling function lAP : Q → 2|AP|. Con- sider the succession of ABB abstractions, {Ai}i=1,...,n, computed w.r.t. the initial partition P. Then the semantics of CTL on An is recursively defined as follows:
1	φ ∈ l	(α)
If φ is an atomic proposition, then  φ)(α) = 
⎩ 0	otherwise
¬φ) := ¬3 φ)
For ⬦ ∈ {∨, ∧}:  φ ⬦ ψ) := φ) ⬦3 ψ)
Let {αi}i∈N denote an infinite path of An starting in α1 = α. Then:


 E(ϕUψ))(α) = ⎪⎨

∃α dir,m β :  ϕ)(α) = 1 ∧ E(ϕUψ))(βn−1) = 1 

0	∀{αi}i∈N∀k ∈ N :  ψ)(αk) /= 0 ⇒ ∃j < k :  ϕ)(αj) = 0 
⎪⎩ ⊥  otherwise

⎧ 1	∀{αi}i∈N∃k ∈ N :  ψ)(αk) = 1 ∧ ∀j < k :  ϕ)(αj) = 1 
 A(ϕUψ))(α) =	0	 ψ ∨ ϕ)(α) = 0 ∨ ∃α dir,m β : A(ϕUψ))(βn−1) = 0 
⎪⎪⎩ ⊥  otherwise
Theorem 5.4, below, states the desired result of preservation for our three valued semantics. Note that for a CTL formula φ, we distinguish between the semantics
 φ)H on a hybrid automaton H (as given in Definition 5.1) and the semantics φ)(r) on the region α of an ABB abstraction for H (as given in Definition 5.3).
Theorem 5.4 (Preservation Theorem) Let H be a hybrid automaton and let A
be an n-ABB abstraction of H. Then, for any CTL formula φ,
 φ)(α) = 1 ⇒ ∀ x ∈ α :  φ)H (x) = 1 
 φ)(α) = 0 ⇒ ∀ x ∈ α :  φ)H (x) = 0 
Proof. We proceed by induction on the bound n for the ABB-abstraction An. The base case is immediate. To prove our claim for n > 0 we use a structural inductive argument. Atomic propositions and boolean operations can be easily dealt with. For the temporal operators, let us start to consider the case  E(ϕUψ))(α) = 1. By Definition 5.3  E(ϕUψ))(α) = 1 iff either  ψ)(α) = 1 or ∃α m,dir β :  ϕ)(α) = 
1∧ E(ϕUψ))(βn−1) = 1. In the first case the claim holds by our structural inductive

hypothesis. In the second case, the edge α m,dir
β ensures that for any x ∈ α,

x admits an evolution to βn−1 in H, which traverses the only regions α, βn−1.
Moreover, α satisfies ϕ and βn−1 satisfies E(ϕUψ). Thus, using our induction on n as well as our structural induction, we can conclude that for each x ∈ α,
 E(ϕUψ))H (x) = 1. The case for which E(ϕUψ))(α) = 0 can be easily established on the ground of the simulation preorder relating An to H, stated in Theorem 4.2. The boolean evaluations of the operator AU can be simmetrically dealt with. 

Conclusions
We proposed a novel framework for the reachability analysis of hybrid automata. Our method is based on the definition of a succession of abstractions, whose con- struction does not relies on the exact representation of the predecessor (resp. suc- cessor) regions. Nevertheless, our ABB abstractions encode enough information to both prove and falsify safety properties, as well as more general CTL formulas. In particular, we provide efficient (linear) algorithms for the three valued safety analysis on ABB abstractions.

References
R. Alur, C. Courcoubetis, and Henzinger, T. A., “Computing Accumulated Delays in Real-Time Systems” Formal Methods in System Design 11, 1997, pp. 137–156.
R. Alur and D. L. Dill “A theory of timed automata” Theoretical Computer Science 126, 1994, pp. 183–235.


R. Alur and T. A. Henzinger and P. Ho, “Automatic Symbolic Verification of Embedded Systems” IEEE Real-Time Systems Symposium, 1993, pp. 2–11.
R. Alur, T. A. Henzinger, G. Lafferriere, and G. J. Pappas, “Discrete abstractions of hybrid systems” Proceedings of the IEEE 88, 2000, pp. 971–984.
T. Brihaye, C. Michaux, C. Rivier, and C. Troestler, “On O-Minimal Hybrid Systems” Hybrid Systems: Computation and Control HSCC, LNCS 2993, 2004.
M. Fr¨anzle, “What Will Be Eventually True of Polynomial Hybrid Automata?” Proceedings of 4th International Symposium on Theoretical Aspects of Computer Software, LNCS 2215, 2001, pp. 340– 359.
R. Gentilini, K. Schneider, and B. Mishra, “Successive Abstractions of Hybrid Automata for Monotonic CTL Model Checking” , Logical Foundations of Computer Science, International Symposium, LFCS 2007, LNCS 4514, pp. 224–240.
R. Ghosh, A. Tiwari, and C. Tomlin, “Automated Symbolic Reachability Analysis with Application to Delta-Notch Signaling Automata” Hybrid Systems: Computation and Control HSCC, LNCS 2623, 2003.
R. Ghosh and C. J. Tomlin, “Lateral Inhibition through Delta-Notch Signaling: A Piecewise Affine Hybrid Model” LNCS 2034, 2001, pp. 232–245.
T. A. Henzinger, “The Theory of Hybrid Automata.” Proceedings of the 11th IEEE Symposium on Logic in Computer Science, IEEE Computer Society, 1996, pp. 278–292.
M. R. Henzinger, T. A. Henzinger, and P. W. Kopke, “Computing simulations on finite and infinite graphs” Proceedings of the 36th Annual Symposium on Foundations of Computer Science, IEEE, 1995,
pp. 453–462.
T. A. Henzinger, P. W. Kopke, A. Puri, and P. Varaiya, “What’s decidable about hybrid automata?” Proceedings of the 27th Symposium on Theory of Computing, ACM Press, 1995, pp. 373–382.
P. C. Kannellakis, and S. A. Smolka, “CCS Expressions, Finite State Processes, and Three Problems of Equivalence” Information and Computation 86, 1990, pp. 43–68.
S. C. Kleene, “Introduction to Metamathematics” Wolters-Noordhoff 1971.
G. Lafferriere, J. G. Pappas, and S. Yovine “A New Class of Decidable Hybrid Systems” Proceedings of the 2nd International Workshop on Hybrid Systems, LNCS, 1999, pp. 137–151.
G. Lafferriere, G. Pappas, and S. Sastry, “O-minimal hybrid systems” Mathematics of Control, Signals, and Systems, Springer-Verlag 13, 2000, pp. 1–21.
J. S. Miller, “Decidability and Complexity Results for Timed Automata and Semi-linear Hybrid Automata.” Proceedings of the 3th International Workshop on Hybrid Systems, LNCS, 2000, pp. 296– 309.
R. Paige, and R. E. Tarjan, “Three partition refinement algorithms” SIAM Journal on Computing 16, 1987, pp. 973–989.
C. Piazza, M. Antoniotti, V. Mysore, A. Policriti, F. Winkler, and B. Mishra, “Algorithmic Algebraic Model Checking I: Challenges from Systems Biology.” Proceedings of the 17th International Conference on Computer Aided Verification, LNCS 3576, pp. 5–19.
S. Ratschan and Z. She. “Safety Verification of Hybrid Systems by Constraint Propagation Based Abstraction Refinement.” Proceedings of the 8th International Workshop on Hybrid Systems: Computation and Control, LNCS 3414, pp. 573-589.
A. Tiwari and G. Khanna, “Series of Abstractions for Hybrid Automata” Proceedings of the 5th International Workshop on Hybrid Systems, LNCS, 2002, pp.465–478.
