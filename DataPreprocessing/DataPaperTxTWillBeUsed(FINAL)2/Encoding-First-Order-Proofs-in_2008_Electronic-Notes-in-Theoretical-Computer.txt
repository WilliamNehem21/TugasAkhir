Electronic Notes in Theoretical Computer Science 198 (2008) 71–84	
www.elsevier.com/locate/entcs


Encoding First Order Proofs in SMT

Jeremy Bongio1	Cyrus Katrak2	Hai Lin3	Christopher Lynch4 Ralph Eric McGregor5
Mathematics and Computer Science Department, Clarkson University, Potsdam, NewYork, United States

Abstract
We present a method for encoding first order proofs in SMT. Our implementation, called ChewTPTP-SMT, transforms a set of first order clauses into a propositional encoding (modulo theories) of the existence of a rigid first order connection tableau and the satisfiability of unifica- tion constraints, which is then fed to Yices. For the unification constraints, terms are represented as recursive datatypes, and unification constraints are equations on terms. The finiteness of the tableau is encoded by linear real arithmetic inequalities.
We compare our implementation with our previous implementation ChewTPTP-SAT, encoding rigid connection tableau in SAT, and show that for Horn clauses many fewer propositional clauses are generated by ChewTPTP-SMT, and ChewTPTP-SMT is much faster than ChewTPTP-SAT. This is not the case for our non-Horn clause encoding. We explain this, and we conjecture a rule of thumb on when to use theories in encoding a problem.
Keywords: SMT, first-order, tableau, Yices


Introduction
Recent techniques in SAT solving have resulted in extremely fast proce- dures for solving propositional satisfiability problems[8], based on the DPLL method[4]. As an application of these techniques, we have developed an au- tomated theorem prover called ChewTPTP-SAT[6], which encodes rigid first

1 Email:bonjiojp@clarkson.edu
2 Email:katrakc@clarkson.edu
3 Email:linh@clarkson.edu
4 Email:clynch@clarkson.edu
5 Email:mcgregre@clarkson.edu



1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.081

order theorem proving problems as SAT problems, and solves those SAT prob- lems using Minisat[8].
Rigid unsatisfiability has been studied as early as [3,1]. A set of first order clauses is rigidly unsatisfiable if and only if there exists a closed rigid connection tableau for that set of clauses[10]. Our encoding uses this fact and solves the satisfiability of a set of rigid clauses by encoding the existence of a rigid connection tableau in SAT.
A set of Horn clauses is encoded by creating propositional clauses repre- senting the following requirements of a tableau T : (1) The root of the tableau must be a clause with only negative literals. (2) If a clause is in the tableau, then all its negative literals are in the tableau. (3) If a negative literal is in the tableau, then it must be extended by some clause. (4) If a negative literal
¬A is extended by a clause C, then A must unify with the positive literal in
C. (5) All unifications must be consistent with each other. (6) The tableau must be finite, i.e., there is no cycle.
For connection tableaux for non-Horn clauses, literals are either extended or complementary to an ancestor literal in its branch. For efficiency rea- sons, we choose to encode a clause tableau as a DAG. So there may be many branches from the root to a node. Therefore, we encode the fact that each literal L in the tableau must either be extended or all paths from the root to that node must contain a literal complementary to L. A tableau may have the same clause on different branches, and those branches may be closed with dif- ferent literals. Therefore, we may have to add more instances of clauses to find a closed tableau. This cannot be avoided, since rigid Horn clause satisfiabil- ity is NP -complete, but rigid non-Horn clause satisfiability is Σp-complete[9]. However, because of the DAG structure, we can often encode many instances of a clause with just one instance.
Since we encode rigid proofs, the proof of unsatisfiability of a set of clauses may require repeating the encoding with fresh variants of each clause. How- ever, there are also applications which really require rigid proofs[5].
Our original ChewTPTP-SAT implementation[6] performed well on some problems, but some of the encodings created huge sets of clauses. Some parts of our encoding represented choices made, such as which clause to extend each literal with. But other parts of our encoding represented deterministic proce- dures, such as deciding the consistency of unification constraints and deciding the acyclicity of the DAG, which verifies that a particular property holds of the DAG. Furthermore, in experimental results with Horn clauses, approximately 99% of the clauses generated were encoding the determinstic procedures, and only about 1% represented the choices. We had an eager encoding of unifica- tion and acyclicity. We decided the implementation would be more efficient if

unification and acyclicity were encoded lazily and implemented these changes in ChewTPTP-SMT. It makes sense to expresses choices involved in building the tableau using SAT, and verifcation of unification and acyclicity using un- derlying theories. Therefore, we chose to encode our problem as Satisfiability modulo Theories[12], and we replaced Minisat[8] with Yices[7].
Yices has a theory for recursive datatypes, which can be used to represent terms. A term can be defined by using function symbols as constructors. Each function symbol of arity n is a constructor with n arguments. Constants are constructors with no arguments. Predicate symbols are viewed the same as function symbols. Variables are instances of terms. Then unification is repre- sented as equality of terms. We represent acyclicity using linear arithmetic. Consider a graph G = (V, E). If an edge (u, v) exists in E, then we assert an inequality xu < xv for some real numbers xu and xv. Then G is acyclic if and only if the set of inequalities is consistent.
In this paper, we describe our implementation of ChewTPTP-SMT, and compare our results with ChewTPTP-SAT. We show that in the Horn encod- ing, ChewTPTP-SMT produces far fewer clauses than ChewTPTP-SAT. The time needed to decide the satisfiability is also drastically reduced. This is not the case for non-Horn clauses. We explain why this is the case and give a rule of thumb for when theories should be used for encoding.

Clausal Tableau
See [2] for a detailed description of first order logic and a background discussion on the validity of a first order logic formula.
We use the following definition of tableau [10].
Definition 2.1 Clausal tableaux are trees with nodes labeled with literals and branches labeled either open or closed. Clausal tableaux are inductively deﬁned as follows. Let S = {C1...Cn} be a set of clauses. If T is a tree consisting of a single unlabeled node N then T is a clausal tableau for S. The branch consisting of only the root node N is open. If N is a leaf node on an open branch B in the tableaux T for S and one of the following inference rules are applied to T then the resulting tree is a clausal tableaux for S.
(Expansion rule) Let Ck be a clause in S. Replace each variable in Ck with a new variable not appearing in T . Suppose Lk1 ∨ ... Lki is the resulting clause. Construct a new tableaux T ' by adding i nodes as children of N and labeling them Lk1 through Lki. Label each of the i branches open. T ' is a clausal tableaux for S.
(Closure rule) Suppose Lij is the literal at N and for some predecessor node with literal Lpq such that Lij and ¬Lpq are uniﬁable. Construct T ' from

T by applying the uniﬁer to T and labeling the branch containing Lij as closed.
T ' is a clausal tableaux for S.
A clause which is added to the root node is called the start clause and we say that a clause is in a tableaux if the clause was used in an application of the expansion rule.
Definition 2.2 A clausal tableaux is tightly connected if each clause (except the start clause) in the tableaux contains some literal which is uniﬁable with the negation of its predecessor.
Connected clausal tableaux use an additional rule called extension rule.
Definition 2.3 (Extension Rule) Let N be a node in the tableau T and let Ck be a clause in S such that there exists a literal Lik in Ck which is uniﬁable with the negation of N. Apply the expansion rule with Ck and immediately apply the closure rule with Lik.
Definition 2.4 The calculus for connection tableaux consists of the expansion rule (for the start clause only), the closure rule, and the extension rule.
We call a tableau closed if each leaf node has been closed by an application of the closure rule. By [11] we can require that the start clause is a negative clause since there exists a negative clause in any minimally unsatisfiable set.

Rigid Unsatisﬁability
The main problem in Automated Theorem Proving is to determine if a set of hypotheses implies a conclusion, or equivalently that a formula F is unsatisfi- able. We will assume that F is in CNF. The problem of rigid unsatisfiability of F is to determine whether there exists a ground instance of F which is unsatisfiable. A rigid tableau is a tableau in which multiple instances of a clause appearing in the tableau are identical copies of the clause appearing in F . One result of Tableaux Theory is the completeness and soundness of closed connection tableaux.
Theorem 2.5 There exists a closed connection (rigid) tableau for F iff F is (rigidly) unsatisﬁable[10].

Tableau Encoding
Our method to determine the rigid unsatisfiability of F generates a set S of propositional logic clauses modulo the theories of unification and arithmetic for F which encodes a rigid closed connection tableau for F and tests the satisfiability of S with a SMT solver.

We provide two encodings, the first for problems containing only Horn clauses and the second for those containing non-Horn clauses. Given F we enumerate each of the clauses in F and each of the literals in each clause. We denote clause i by Ci and denote the jth literal in clause i by Lij. We denote Aij to be the atom of Lij. Therefore Lij is either of the form Aij or ¬Aij.
Encoding for Horn Clauses
Let F be a set of first order logic formulas.
We define a set of propositional variables cm, lmn, emnq, disjoint from the symbols in F , as follows: Define cm = T iff Cm appears in the tableau. Define lmn = T iff Lmn is an internal node in the tableau. Define emnq = T iff Cq is an extension of Lmn. For each pair of clauses Ci and Cj we define xi < xj = T (where xi and xj do not exist in F ) iff there exists a path from Ci to Cj. For each pair of atoms Ai and Aj in F , we define (Ai = Aj)= T iff Ai and Aj are the two atoms involved in an application of the closure rule.
Below we list the set of clauses that we generate and provide their meaning.
At least one clause containing only negative literals appears in the tableau:

(1)
	cm

Cm is a negative clause

If Cm appears in the tableau and Lmn is a negative literal then Lmn is an internal node in the tableau:
(2)	cm ⇒ lmn
If Lmn is an internal node in the tableau then for some qj, Cqj is an exten-

sion of Lmn:
(3)
lmn ⇒ (emnq1 ∨ ... ∨ emnqk )

where {Cq1 ...Cqk } represent the set of all clauses whose positive literals are unifiable with Lmn
If Cq is an extension of Lmn then Cq exists in the tableau:
(4)	emnq ⇒ cq
If Cq is an extension of Lmn and Lqr is the positive literal in Cq then Amn

and Aqr are unifiable:
(5)

emnq ⇒ (Amn = Aqr )

If Cq is an extension of Lmn then there is a path from Cm to Cq:
(6)	emnq ⇒ (xm < xq)
The encoding is satisfiable if and only if the original set of first order
Horn clauses is rigidly unsatisfiable. We encode non-rigid unsatisfiability by continually adding new instances of each clause, renamed apart.

Encoding for Non-Horn Clauses
For non-Horn problems we use a different set of variables and generate a different set of clauses. Note: we say that two literals are complementary if they have opposite signs and their atoms are unifiable.
We define the variables, disjoint from the symbols in F, sm, cmn, lmn, emnqj, oijkl and qmnij as follows: Define sm = T iff Cm is the start clause. Define cmn = T iff Cm appears in the tableau and Lmn is complementary to its parent. Define lmn = T iff Lmn is a node in the tableau and is not a leaf node created by an application of the extension rule. Define emnqj = T iff Cq is an extension of Lmn and Lqj is the complement of Lmn. Define oijkl = T iff Lij and Lkl are a pair of literals used in a closure but not by the extension rule. If a path to a node N contains the complement of N , then we say that the path is closed. Define qmnij = T iff Lmn is a leaf and Lij is a node on a path from the root node to Lmn and every path from the root to Lij contains a complement of Lmn. For each pair of clauses Ci and Cj we define xi < xj = T (where xi and xj do not exist in F ) iff there exists a path from Ci to Cj. For each pair of atoms Ai and Aj in F , we define (Ai = Aj) = T iff Ai and Aj are the two atoms involved in an application of the closure rule.
The clauses are as follows.
There exists a start clause in the tableau which only contains negative literals:

(7)
	sm

sm is a negative clause

If Cm is the start clause in the tableau then each literal Lmn of Cm is in the tableau:
sm ⇒ lmn
If Ci appears in the tableau and Lij is the complement of a literal in its
parent then all other literals of Ci are in the tableau:
cij ⇒ lik where j /= k
If Lij exists in the tableau and is not a leaf node created by an application
of the closure rule then either every branch ending at Lij is closed or there is an extension of Lij:

​
lij ⇒ (qijij V (  eijkl))
k,l

If Lij is extended with Ck then Ck is in the tableau and some Lkl of Ck is the complement of Lij:

​
eijkl ⇒ ckl

If clause Cm is an extension of Lij and literals Lij and Lml are complements then Aij and Aml are unifiable.

​
eijml ⇒ (Aij = Aml)

If Lij and Lkl are a pair used in a closure then they must be unifiable:

​
oijkl ⇒ (Aij = Akl)

If Lij has the same sign as Lkl or their respective atoms are not unifiable then they are not complements:
¬oijkl where Lij and Lkl are not unifiable
If every path through Lkl to leaf Lij is closed and Ck is an extension of Lmn then either Lij is a complement of Lmn or every path through Lmn to Lij is closed:

​
qijkl ⇒ (emnkp ⇒ (oijmn V qijmn))

If Ck is an extension of Lij then there is a path from clause Ci to clause
Ck:
eijkl ⇒ (xi < xk)
If Ci is the start clause then there are no inferences into any of the literals in Ci:

​
si ⇒ ¬eklij

If Ci is the start clause, Lmn is a leaf, and all paths that traverse Lij to
Lmn are closed, then Lij and Lmn are complementary:

​
si ⇒ (qmnij ⇒ omnij )

We represent our tableau as a DAG, so there is some structure sharing. But even with the structure sharing, a non-Horn clause tableau may need more than one instance of the same clause. Rigid unsatisfiability could be determined by continually adding identical instances of a clause. Non-Horn encoding could also be extended to the non-rigid case in the same way as the Horn encoding.

Implementation and Experimental Results
We have implemented our tableau encoding in our theorem prover ChewTPTP-SMT, which is an extension of ChewTPTP-SAT[6]. In ChewTPTP-SAT, instead of using theories, we encoded the consistency of the unifiers and the acyclicity of the tableau with additional propositional clauses. To encode the consistency of the unifiers, we encoded the equations that would be created if a unification algorithm was run. We do not know

ahead of time which unifiers we will have to create, so we encode everything that can possibly occur when the unification algorithm is run. To encode the absence of a cycle, we encode the existence of a path from one clause to an- other and the fact that there is no path from a clause to itself. This requires encoding all possible transitivity and irreflexivity axioms that may occur.
Our implementation allows the user to decide whether ChewTPTP encodes the problem as a SAT problem or an SMT problem. If the user chooses SMT, our implementation uses Yices to test the satisfiability of the encoding. If the user chooses SAT, then the user can also choose whether to test the satisfiability using Yices or Minisat, with a DIMACS encoding of SAT.
We tested our prover in all three settings on a subset of TPTP[13] prob- lems. Tables 1-4 provide empirical data from these tests.
SMT-Y denotes our prover run in SMT mode, SAT-Y is SAT mode using Yices, and SAT-M is SAT mode using Minisat. For Horn clauses, we ran ChewTPTP on all the Horn problems in the TPTP database, but for non- Horn we only had time to run it through the GRP problems. We report all problems that both provers solved within five minutes but SAT-M took greater than one second. We believe the problems in these tables are representative of the overall results. Columns in the table show the running time of each method, the clause generation time rounded off to the nearest second, the number of clauses generated, and the number of variables generated for each method. We also show whether or not the problem is rigidly satisfiable. For these experiments, we only tested rigid satisfiability with one instance of each clause.
We wanted to see if working modulo theories would improve the perfor- mance of ChewTPTP. In the Horn case the running time was reduced signif- icantly, except for a small percentage of exceptions. In the non-Horn case, working modulo theories often increased the running time. Generally, Yices was faster than Minisat on SAT problems without theories.
We believe we have an explanation for our results. In the Horn problems the number of clauses is reduced by an order of magnitude, whereas in the non- Horn problems the number of clauses is not reduced by much. This implies that working modulo theories is only useful when the clauses size is reduced significantly.
In the Horn encoding, everything can be encoded in O(n2) except for the encoding of unification and acyclicity, which require O(n3) space. When we remove the clauses used to represent unification and acyclicity, the number of clauses is now O(n2). However, for the encoding of non-Horn clauses, we must encode the fact of a leaf node having a complementary literal as an ancestor. This encoding is O(n3). We do not know how to encode this using

Table 1
ChewTPTP Times For Horn Problems

the theories of Yices, so we have kept the propositional encoding. Therefore, when we remove the encoding of unification and acyclicity, the entire coding of the problem is still O(n3). We conjecture a good rule of thumb for deciding when it is useful to encode properties using theories. We conjecture that if the number of clause can be reduced by a factor of n, then the coding is useful, but if the asymptotic complexity remains the same, then it is not a good idea.

Table 2
ChewTPTP Clause and Variable Count For Horn Problems
Conclusion
We have given an application of SMT to theorem proving in first order logic by encoding the existence of a rigid connection tableau in SMT. We have im- plemented the SMT encoding in our theorem prover ChewTPTP-SMT. We compared it with our initial version of ChewTPTP-SAT, where a rigid con- nection tableau was encoded in SAT.

Table 3
ChewTPTP Times For Non-Horn Problems

Compared to our encoding in SAT, the encoding in SMT is more natural and more efficient. As part of our encoding, we need to encode the solving of unification problems and the acyclicity of the tableau. In SAT, it was necessary to add cubically many clauses to encode the solving of unification. In addition, it was necessary to add cubically many clauses to encode the acyclicity of the

Table 4
ChewTPTP Clause and Variable Count For Non-Horn Problems

tableau. However, when encoding this information in SMT, there was no need to encode the solving of unification, since this was accomplished directly with the Yices recursive datatype theory. The number of unification clauses was reduced from a cubic to a quadratic number. Similarly for acyclicity of tableau, we did not need to encode the transitivity and irreflexivity of the path

relation. We only needed to express edges in the tableau as inequalities. The number of clauses to represent acyclicity also dropped from a cubic number to a quadratic number.
In the Horn encoding, all the other information in the tableau can also be encoded with a quadratic number of clauses. Therefore the entire encoding of the existence of a tableau dropped from a cubic number of clauses in SAT to a quadratic number in SMT. This drastically reduced the number of clauses, and simultaneously decreased the time needed to decide the satisfiability of the clauses. There was only a small reduction in number of clauses for non- Horn clauses, because we still need to encode the fact that all paths in the tableau can be closed. Therefore the entire encoding is still cubic, and the running time was actually worse. We conjecture a rule of thumb saying that it is worthwhile to use theories if the number of clauses is reduced by a factor of n, but not worthwhile if the asymptotic number remains the same.
For future work, we hope to be able to use SMT to further reduce the representation for non-Horn clauses, ideally cutting it down to a quadratic number of clauses. It would be possible to define a theory to do this directly, but we have not yet figured out how to do it with the existing theories in Yices. In addition, in order to prove the general first order problem we also need to find a good way to decide exactly which clauses should be copied. We would like a method to decide satisfiability from rigid satisfiability. It would be useful to have an encoding of rigid clauses modulo a non-rigid theory, as discussed in [5]. This way, we could immediately identify some clauses as non-rigid, and work modulo those clauses.
This paper shows the usefulness of SMT to theorem proving in first order logic. We suspect there are other logics which could also be solved efficiently using SMT.

Acknowledgement
We would like to thank to Leonardo de Moura for his explanation of how to express unification problems in Yices using recursive datatypes.

References
Andrews P. B. [1981], Theorem Proving via General Matings, Journal of the Association for Computing Machinery, Vol. 28, No. 2, pp.193-214
Bell J.L. and Slomson A.B. [1969], Models and Ultraproducts, An Introduction, Dover
Chang, C. and Lee, C.R. [1973], Symbolic Logic and Mechanical Theorem Proving. Academic Press New York and London.

Davis M., Logemann D. and Loveland D. [1962], A Machine Program For Theorem Proving,
Communications of the ACM, Volume 5, Issue 7, pp. 394-397
Delaune S., Lin H. and Lynch C. [2007], Protocol Verification Via Rigid/Flexible Resolution, submitted
Deshane T., Hu W., Jablonski P., Lin H., Lynch C. and McGregor R.E. [2007], CADE, Lecture Notes in Computer Science, Springer, Vol. 4603, pp. 476-491
Dutertre B. and deMoura L., Yices, http://yices.csl.sri.com
Ee´n N. and So¨rensson N. [2003], An Extensible Sat-Solver, In SAT, pp. 502-518
Goubault J. [1994], The Complexity of Resource-Bounded First-Order Classical Logic, Lecture Notes In Computer Science, Proceedings of the 11th Annual Symposium on Theoretical Aspects of Computer Science, Vol. 775, Springer-Verlag, pp. 59-70
Ha¨hnle R. [2001], Tableaux and Related Methods, in A. Robinson and A. Voronkov, eds, ’Handbook of Automated Reasoning’, Vol. 1, Elsevier Science, chapter 3, pp. 101-177
Letz R. and Gernot S. [2001], Model Elimination and Connection Tableau Procedures, in A. Robinson and A. Voronkov, eds, ’Handbook of Automated Reasoning’, Vol. 2, Elsevier Science, chapter 28, pp. 2015-2113
Nieuwenhuis R., Oliveras A. and Tinelli C. [2006], Solving SAT and SAT Modulo Theories: From an Abstract Davis-Putnam-Logemann-Loveland Procedure to DPLL(T), Journal of the ACM, 53(6), 937-977, November 2006.
Sutcliffe G. and Suttner C.B. [1998], The TPTP Problem Library: CNF Release v1.2.1, Journal of Automated Reasoning, Vol. 21, No. 2, pp. 177-203
