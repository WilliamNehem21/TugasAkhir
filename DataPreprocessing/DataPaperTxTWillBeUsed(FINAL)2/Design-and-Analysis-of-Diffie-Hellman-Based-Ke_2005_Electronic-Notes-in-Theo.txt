Electronic Notes in Theoretical Computer Science 135 (2005) 79–94  
www.elsevier.com/locate/entcs


Design and Analysis of Diffie-Hellman-Based Key Exchange Using One-time ID by SVO Logic
Kenji Imamoto1 ,2
Graduate School of Information Science and Electrical Engineering Kyushu University
Fukuoka, Japan
Kouichi Sakurai1 ,3
Faculty of Information Science and Electrical Engineering Kyushu University
Fukuoka, Japan

Abstract
Authenticated key exchange protocols have been developed to establish secure channel on the In- ternet. In this paper, we consider following attacks against an authenticated key exchange using shared secret: eavesdropping, DoS attack, replay attack, and impersonation. Besides prevention from all these attacks, efficiency is also important. In this paper, we propose a three-party au- thenticated key exchange protocol based on Diffie-Hellman key exchange with one-time ID, which is a user’s extraordinary identity used only once [2,3]. Moreover, we analyze our proposal by SVO Logic, which is one of formal methods to analyze cryptographic protocols [7,8], and show what assumptions are needed.
Keywords: Diffie-Hellman based key exchange, SVO Logic, Pre-shared key model, One-time ID


1 The authors would like to thank Dr. Wang Guilin and the anonymous referees for their useful comments. This research was partly supported from the grant of Secom Science and Technology Foundation, and the 21st Century COE Program ’Reconstruction of Social Infrastructure Related to Information Science and Electrical Engineering’. Also, the first author was partly supported from JSPS Research Fellowships for Young Scientists, 2004, 06737.
2 Email:imamoto@itslab.csce.kyushu-u.ac.jp
3 Email: sakurai@csce.kyushu-u.ac.jp



1571-0661 © 2005 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.06.003

Today, information technology has developed as one of the most important techniques in the rationalization of industry. This has improved the infras- tructure of industrial foundation. Namely, many resources have been changed into electronic data, and transferred via computer networks. To achieve se- cure and relievable electronic data exchange such as electronic commerce, it is important to provide authentication, confidentiality, integrity, and user’s privacy. The subject of our study is a channel in which adversary can modify and eavesdrop on all transferred messages (e.g, the Internet, Bluetooth, radio frequency Identification (RFID), etc.). In such a communication channel, it is essential to prevent adversary from detecting user’s identity [1]. Especially, we focus on pre-shared key model in which it is difficult to solve this problem [10].
In this paper, we consider the problem of authenticated key exchange with one-time ID. One-time ID [2,3] is a user’s extraordinary identity, which has two properties: (1) An adversary cannot specify who is communicating even when he eavesdrops on the communication channel, but legitimate participants can specify the interlocutor; and (2) Any one-time ID can be used only once and the adversary, who does not know a long-term secret, cannot guess unused one-time ID. By substituting one-time ID for user’s fixed identity (e.g., name, address), both leakage of user’s identity and DoS attack can be prevented. However, because the system in this previous paper is designed to use one- time ID in two parties, it is not suitable for large system. This means if a user wants to communicate with n partners then he needs to prepare and store n shared secret keys beforehand. To overcome this shortcoming, we propose a new extensible system with one-time ID by using Trusted Third Party (TTP). In this system, if a user already shared a secret with only one TTP, he can establish secure communication with any other users. We analyse the proposed protocol by SVO Logic, which is suitable for analysis of Diffie-Hellman based key exchange, and show it can achieve desired authentication goals. Finally, we consider a practical problem such as synchronization of one-time ID, and propose new calculation method of one-time ID to solve this problem.

Related Works
Almost all of the key establishment protocols using pre-shared key are based on challenge-response mechanism. The goal of challenge-response protocols is that the claimant proves its identity to the verifier by demonstrating knowl- edge of a secret known to be associated with that entity, without revealing the secret itself to the verifier during the protocol. This is done by providing


Table 1
Comparison of key establishment protocols using pre-shared key (TS: Time-Stamp, RN: Random Number, SN: Sequence Number, PN: Pre-chosen Number)





a response to a challenge using time-variant parameters, where the response depends on both the entity’s secret and the challenge. Time-variant parame- ters can be divided into four types as follows: random number (RN), sequence number (SN), time-stamp (TS), and a number chosen before a protocol run (we call it pre-chosen number (PN)). In Table 1, we compare and classify the key establishment protocols based on pre-shared key ([2,3,4,5,6] and pro- posal of this paper), viewed from the type of time-variant parameters, the involvement of third party, the usage of one-time ID, and the total number of messages.
Besides, there are many requirements for authentication or key exchange protocol, e.g., key confirmation ([2] and [5] cannot provide this property), anonymity (Only [2,3] and this paper consider this requirement), prevention of DoS attack (especially, 3PAK [6] is fragile).
Because only a few attempts have been made on anonymous key exchange based on pre-shared key in three-party model, we propose a key exchange system using one-time ID with trusted server. This system is based on Diffie- Hellman key exchange [9] to realize Perfect Forward Secrecy. Perfect Forward Secrecy is a requirement to achieve following situation: Even if a long-term secret is revealed, security of other secret keys used previously can be guaran- teed. When using sequence number or pre-chosen number, the synchroniza- tion problem can occur because any systems using one-time ID need to update them in each protocol run (the system using time-stamp also has similar prob- lem). We consider this problem in section 4.

Preliminaries of SVO Logic
In this section, we give a brief review on the SVO logic [7,8]: the notations, rules, and axioms. However, we omit some definitions unused in our analysis such as signature or public key.


Notation
The entities who want to perform an authenticated key exchange are tradi- tionally named Alice and Bob. The other main principal is the trusted server. Alice and Bob are assumed to share long-term keys with the server. We use the obvious symbols for Alice (A), Bob (B), the trusted server (S), and the shared keys (kAS, kBS, kAB).
P believes X : The principal P may act as though X is true.
P received X : The principal P received a message containing X to P , who can read and repeat X.
P said X : The principal P at some time sent a message including X. P says X : P must have said X since the beginning of current epoch. P has X :
Initially available to P ,
Received by P ,
Freshly generated by P ,
Constructible by P from the above.
	controls X : P has jurisdiction over X. The principal P is an authority on X and should be trusted on this matter.
fresh(X) : X has not been sent in any message prior to the current protocol run.
k  Q : P and Q may use the shared key k to communicate. k will never
be discovered by any principal but P , Q, or a principal trusted by P or Q.
PKδ(P, k) : k is a public key-agreement key of P . A Diffie-Hellman key formed with k is shared with P .
{M}k : Encryption of message, M, using key k. Encrypted messages are uniquely readable and verifiable as such by holders of the right keys.
⟨X⟩∗P : This is used for messages that P doesn’t know or recognize (e.g.,
{X}k where P does not know k).

k− Q  ≡ (P k
∧ P has k)

SVO Rules
SVO logic has two inference rules:
Modus Ponens : From ϕ and ϕ → ψ infer ψ
Necessitation : From ▶ ϕ infer ▶ P believes ϕ
’▶’ is a metalingusitic symbol. ’Γ ▶ ϕ’ means that ϕ is deriable from the ’▶ ϕ’ is a thorem, i.e., derivable from axioms alone without any additional set of formulae Γ (and the axioms as started below) using the above rules. assumptions.
SVO Axioms
Here, we introduce some axioms of SVO.
Belief Axioms
(P believes ϕ ∧ P believes (ϕ → ψ) ) → P believes ψ
P believes ϕ → P believes (P believes ϕ)
Source Association Axiom
(P k  Q ∧ R received {X from Q}k) → (Q said X ∧ Q has X)
Key Agreement Axiom

(PKδ(P, kP
) ∧ PKδ(Q, kQ
)) → P F0(kP ,kQ)Q

F0(k, k') implicitly names the (Diffie-Hellman) function that combines k
with k−1 (or, k' with k−1) to form a shared key.
Receiving Axioms
P received (X1, ··· , Xn) −→ P received Xi, for i = 1, ··· ,n 
(P received {X}k+ ∧ P has k−) −→ P received X
Here k+ and k− are used to abstractly represent congnate keys, whether
for symmetric or asymmetric cryptography. In the symmetric case, k+ = k− = k. In the asymmetric case, k+ is a public key and k− is the associated private key.
Posession Axioms
P receivede X −→ P has X
P has (X1, ··· , Xn) −→ P has Xi, for i = 1, ··· ,n 
(P has X1 ∧ ··· ∧ P has Xn) −→ P has F (X1, ··· , Xn)
F is meta-notation for any function computable in practice by P , e.g.,
encryption with known keys.


Comprehension Axiom
P believes (P has F (X)) −→ P believes (P has X)
F is meta-notation for any function that is effectively one-one and such that
F + or F − is computable in practice by P .
Saying Axioms
P said (X1, ··· , Xn) −→ P said Xi ∧ P has Xi, for i = 1, ··· , n.
P says (X1, ··· , Xn) −→ (P said (X1, ··· , Xn) ∧ P says Xi), for i = 1, ··· , n.
Freshness Axioms
fresh(Xi) −→ fresh(X1, ··· , Xn),for i = 1, ··· , n.
fresh(X1, ··· , Xn) −→ fresh F (X1, ··· , Xn)
F must genuinely depend on all component arguments. This means that it
is infeasible to compute value of F without value of all the Xi.
Jurisdiction and Nonce-Verification Axioms
(P controls ϕ ∧ P says ϕ) −→ ϕ
(fresh(X) ∧ P said X) −→ P says X
Symmetric Goodness Axiom
P k  Q ≡ Q k  P
Authentication Goals
We list six generic goals that our protocols are desired to meet.
G1. Ping Authentication captures situations where a principal P wants to know whether an interlocutor Q is alive. It is expressed as “P believes Q says X”.
G2. Entity Authentication further requires that P ’s interlocutor Q said something relevant to their present conversation. Given some information YP known to be fresh to P , entity authentication mandates that Q recently sent a message F (X, YP ) from which it is manifest that Q has seen YP
and has processed it. It is expressed as “P believes (Q says F (X, YP ) ∧
fresh(YP ))”.
G3. Secure key establishment indicates that a principal P believes that he has a good key k to communicate with a counterpart Q. Given the above

notion of unconfirmed secret, this is expressed as “P believes P k−
Q”.

G4. Key freshness simply requires that a principal P believes a key k to be fresh, that is, “P believes fresh(k)”.


G5. Mutual understanding of shared keys applies to situations where a principal P can establish that an interlocutor Q has sent a key k as an unconfirmed secret between the two of them (from Q’s point of view). This

is formalized by “P believes Q says (Q k−
P )”.

G6. Key confirmation is intended to describe scenarios in which a prin- cipal P believes that an interlocutor Q has proved to have received and successfully proccessed a previously unconfirmed secret key k between the
two of them. It is expressed as “P believes (P k− Q ∧ Q says F (k))”.
Above authentication goals are listed in [7,8]. In addition to them, we
further consider the following requirements.
Anonymity: An adversary could not guess who is communicating even if he eavesdropped on transferred messages.
Scalability: Even if any principals want to perform key exchange and mu- tual authentication with a lot of different interlocutor, the cost, which is needed to establish the system, is not directly proportional to the number of partners.

Proposed System
In the previous one-time ID system [2], secret key is assumed to have been al- ready shared between Alice and Bob before a key exchange begining. Because of this assumption, if a principal wants to communicate with other user, he needs to prepare shared secrets with all partners beforehand. Therefore, this system cannot achieve good scalability. To provide high scalability for a sys- tem with one-time ID, we propose a new system that uses trusted server. In the proposed system, a secret key is assumed to have been already shared be- tween a user and a server beforehand, and the user can communicate securely with any other users.
We design a key agreement protocol, and reason, by using SVO Logic, that it can achieve authentication goals, which are defined in section 3.4, from both Alice and Bob’s views. Furthermore, we consider one-time ID synchronization problem and computation methods of one-time ID, and propose the solution for this problem.

Protocol
A → B: S, OAS, {B, gx, OAS}kAS
B → S: OAS, {B, gx, OAS}kAS , {gy, OAS}kBS
S → B: S, {A, gx, gy, {gx, gy}kAS }kBS

B → A: gx, {gx, gy}k	, {gx, Nb}k
A → B: {Nb − 1}kAB





Here, OAS denotes an one-time ID for current session between Alice and server, and Nb denotes a nonce generated by Bob. Moreover, x, (y) is Al- ice’s (Bob’s) private key for Diffie-Hellman key exchange, and gx (gy) denotes the corresponding Diffie-Hellman public key. OAS is calculated and shared as follows. It is assumed that Alice and trusted server have a synchronized sequence number i, which increases one by one in each protocol run. Each principal (that is, Alice and server) substitutes i and a shared secret for a function which cannot be calculated inversly by adversary (e.g., one-way hash function). Then, they can use this function’s output as Alice’s one-time ID in i session. By receiving one-time ID calculated beforehand, the server can know who the interlocutor is. Consequently, adversary cannot guess who is communicating even if he eavesdrops on one-time ID, but for server, it is the same information as Alice’s fixed identity. Furthermore, one-time ID changes in every session because of using sequence number i, and adversary cannot guess unused one-time ID.
In section 4.4, we consider a calculation method of one-time ID, OAS, for the proposed system.

Analysis using SVO approach
Our approach is based on the analysis of [7,8]. The protocol analysis steps are as follows: (1) Write assumptions about initial state, (2) Annotate protocol,
(3) Assert comprehensions of received messages, (4) Assert interpretations of comprehended messages, and (5) Use the logic to derive beliefs held by protocol principals.

Initial State Assumptions
Here, we present initial state assumptions of our proposal using SVO.
P1. A believes A kAS S


P2. B believes B kBS S P3. A believes PKδ(A, gx) P4. B believes PKδ(B, gy) P5. A believes fresh(gx) P6. B believes fresh(gy)
P7. A believes A has (gx, x)
P8. B believes B has (gy, y)
P9. S believes A controls PKδ(A, ka) P10. S believes B controls PKδ(B, kb) P11. A believes A OAS S
P12. A believes fresh(OAS) P13. S believes fresh(OAS) P14. B believes fresh(Nb)
P1 and P2 denote each principal shares a long-term secret with the server beforehand. P3 and P4 denote each principal knows own Diffie-Hellman public key. P5 and P6 denote each principal knows own Diffie-Hellman public key is fresh. P7 and P8 denote each principal knows own Diffie-Hellman private key. P9 and P10 denote the server believes that each principal controls their own Diffie-Hellman public key. P11 denotes Alice and the server share one-time ID used in the session beforehand. P12 and P13 denote Alice and the server believe that one-time ID is fresh. These assumptions are derived from the property of one-time ID, that is, one-time ID can be used only once. P14 denotes Bob believes his nonce is fresh.



Received Message Assumptions

In this step, for each message “P → Q : M” of the proposed protocol, we assert “Q received M”.
P15. B received (S, OAS, {B, gx, OAS}kAS )
P16. S received (OAS, {B, gx, OAS}kAS , {gy, OAS}kBS )
P17. B received (S, {A, gx, gy, {gx, gy}kAS }kBS ) P18. A received (gx, {gx, gy}kAS , {gx, Nb}kAB ) P19. B received {Nb − 1}kAB


Comprehension Assumptions
In this step, we express that which a principal comprehends of a received message.
P20. B believes B received (S, ⟨OAS⟩∗B, ⟨{B, gx, OAS}K	⟩∗B)
P21. S believes S received (OAS, {B, ⟨gx⟩∗S, OAS}k	, {⟨gy⟩∗S, OAS}k	)
P22. B believes B received (S, {A, ⟨gx⟩∗B, gy, ⟨{gx, gy}k	⟩∗B}k	)
P23. A believes A received (gx, {gx, ⟨gy⟩∗A}k	, {gx, ⟨Nb⟩∗A from B}⟨k	⟩  )
P24. B believes B received {Nb − 1}⟨kAB ⟩∗B
Interpretation Assumptions
In this step, we are asserting how a principal interprets a received message (as that principal understands it).
P25. S believes S received (OAS, {B, ⟨gx⟩∗S, OAS}k	, {⟨gy⟩∗S, OAS}k	)
−→ S believes S received ({B, PKδ(A, gx), OAS}k	, {P Kδ(B, gy), OAS}k	)
P26. B believes S says (A, ⟨gx⟩∗B, gy) −→ B believes PKδ(A, gx)
P27. A believes S says (gx, ⟨gy⟩∗A) −→ A believes PKδ(B, gy)

P28. (A believes A received ({gx, ⟨Nb⟩∗A
}⟨kAB ⟩∗A
)) ∧ (A believes A ⟨kAB ⟩∗AB)

−→ A believes A received ({gx, ⟨Nb⟩∗A
,A ⟨kAB ⟩∗A B}
⟨kAB ⟩∗A )

P29. (B believes B received{Nb
— 1}
⟨kAB ⟩∗B
) ∧ (B believes A ⟨kAB ⟩∗B B)

−→ B believes B received {Nb
1,A ⟨kAB ⟩∗B B}
⟨kAB ⟩∗B )

Derivations
Here, we derive the beliefs each principal can obtain in proposed protocol. Then, we analyse which authentication goal can be achieved.
For Alice
A believes A received ({gx, ⟨gy⟩∗A}kAS ) by Receiving Axioms, P23
A believes S says (gx, ⟨gy⟩∗A)
by 1, Source Association Axiom, P5, Freshness Axioms, Nonce-Verification
Axiom

A believes PKδ(B, gy)
by Modus Ponens using 2 and P27
A believes A ⟨kAB ⟩∗A B
by 3, P3, Key Agreement Axiom (where kAB = F0(gx, ⟨gy⟩∗A))
A believes A has kAB
by 1, Receiving Axioms, Posession Axioms (where kAB = F0(gx, ⟨gy⟩∗A))
A believes A ⟨kAB −⟩∗AB
by 4, 5, and def. of P k− Q
A believes fresh(kAB)
by P5, Freshness Axioms, Modus Ponens (where kAB = F0(gx, ⟨gy⟩∗A))

A believes B said ({gx, ⟨Nb⟩∗A
,A ⟨kAB ⟩∗A B}
⟨kAB ⟩∗A )

by P23, Receiving Axioms, P28, 4, Source Association Axioms, Belief
Axixoms, Modus Ponens
A believes B has kAB
by 8, Saying Axioms

A believes B says ({gx, ⟨Nb⟩∗A
,A ⟨kAB ⟩∗A B}
⟨kAB ⟩∗A )

by P5, 8, Freshness Axioms, Nonce-Verification Axiom, Modus Ponens
From above analysis, we can derive following conclusion. Both G1 and G2 for Bob are derived in line 10. Moreover, both G1 and G2 for the server are derived in line 2. For Bob, G3 is derived in line 6, G4 in line 7, G5 in line 9 and 10, and G6 in line 6 and 10.
For Bob
B believes B received ({A, ⟨gx⟩∗B, gy}k	) by Receiving Axioms, P22
B believes S says (A, ⟨gx⟩∗B, gy)
by 1, Source Association Axiom, P6, Freshness Axioms, Nonce-Verification
Axiom
B believes PKδ(A, gx)
by Modus Ponens using 2 and P26
B believes A ⟨kAB ⟩∗B B
by 3, P4, Key Agreement Axiom (where kAB = F0(⟨gx⟩∗B, gy))
B believes B has kAB
by 1, Receiving Axioms, Posession Axioms (where kAB = F0(⟨gx⟩∗B, gy))
B believes B ⟨kAB −⟩∗B A
by 4, 5, and def. of P k− Q


B believes fresh(kAB)
by P6, Freshness Axioms, Modus Ponens (where kAB = F0(⟨gx⟩∗B, gy))

B believes A said {Nb
1,A ⟨kAB ⟩∗B B}
⟨kAB ⟩∗B

by P24, Receiving Axioms, P29, 4, Source Association Axiom, Belief
Axixoms, Modus Ponens
B believes A has kAB
by 8, Saying Axioms

B believes A says {Nb
1,A ⟨kAB ⟩∗B B}
⟨kAB ⟩∗B

by P6, 8, Freshness Axioms, Nonce-Verification Axiom, Modus Ponens
From above analysis, we can derive following conclusion as well as Alice. Both G1 and G2 for Alice are derived in line 10. Moreover, both G1 and G2 for the server are derived in line 2. For Alice, G3 is derived in line 6, G4 in line 7, G5 in line 9 and 10, and G6 in line 6 and 10.
For Server
S believes S received ({B, PKδ(A, gx), OAS}kAS , {P Kδ(B, gy), OAS}kBS ) by Modus Ponens using P21 and P25
S believes A said ({B, PKδ(A, gx), OAS, }kAS )
by 1, Receiving Axioms, P1, Source Association Axiom
S believes A says({B, PKδ(A, gx), OAS, }kAS
by 2, P13, Freshness Axioms, Nonce-Verification Axiom
S believes PKδ(A, gx)
by 3, Receiving Axioms, P9, Jurisdiction Axiom
S believes B said {P Kδ(B, gy), OAS}kBS
by 1, Receiving Axioms, P2, Source Association Axiom
S believes B says {P Kδ(B, gy), OAS}kBS
by 5, P13, Freshness Axioms, Nonce-Verification Axiom
S believes PKδ(B, gy)
by 6, Receiving Axioms, P10, Jurisdiction Axiom
G1 and G2 for both Alice and Bob are derived in line 3 and 6. By this goal, the server can update Alice’s one-time ID. Remained authentication goals do not need to be realized because each principal does not share new session key with the server.

Analysis on Anonymity
The first message of the proposed protocol includes the server’s identity and one-time ID, OAS. An adversary who eavesdrops on this message can know only who the server is. In this step, Bob also cannot know who the interlocu- tor is. Moreover, because second message uses only one-time ID as identity, the server can understand that Alice is the initiator of the protocol, but the adversary cannot. However, both first and second messages include the same
information, such as OAS and {B, gx, OAS}, therefore, an eavesdropper can guess that first and second messages are performed in the same session’s run.
Third message includes the server’s identity and new encrypted information. Hence, Bob can decrypt the encrypted message by kBS, but the adversary cannot obtain any information except for the server’s identity. That is, the adversary cannot guess whether third message is relational with first or second message or not. By seeing a plaintext of Alice’s Diffie-Hellman public key of fourth message, Alice can realize this message was produced in the session she initiated. Namely, gx can be used as session ID for her. The adversary who eavesdrops on fourth message can obtain Alice’s Diffie-Hellman public key, but cannot relate with any other information.
According to the above analysis, we can recognize that our protocol can achieve anonymity of both Alice and Bob. Any eavesdropper can only know the server’s identity and the fact that first and second messages are in the same protocol execution. This paper assumes that the leakage of the server’s identity is not an issue. However, there might be the situations where it becomes significant problem. For example, if a server serves for limited users and the purpose of using the server was very restricted, then a message with its identity might have much meaning. This problem is our future work.

Analysis on Calculation of One-time ID
Here, we analyse the calculation of one-time ID, and propose a solution for synchronization problem of one-time ID.
One-time ID needs two properties. One is that one-time ID can be used only once, and the other is that an adversary, who does not know secret in- formation, cannot guess unused one-time ID. Hence, there are two calculation methods of one-time ID as follows.
OASi := h(SOAS, i)
OASi := {A, SOAS, i}kS
OASi denotes an one-time ID used in ith protocol run. Moreover, SOAS is
a secret for one-time ID between Alice and the server, and kS is the server’s

public key. This can be denoted as 'PKψ(S, kS)' by SVO Logic. And h(·) denotes one-way hash function. Both methods can calculate different value
in every session by using sequence number i, and the adversary cannot guess unused one-time ID unless SOAS is revealed. Thus, both methods can satisfy the requirements for one-time ID. Incidentally, the systems proposed in [2,3] use first method.
By preparing one-time ID beforehand, although it is the same information as Alice’s fixed identity for server, the adversary cannot understand who the sender is. However, this method causes the synchronization problem of one- time ID. For example, suppose Alice and the server share 5 as a sequent number. Then, Alice performs two protocols at the same time and sends OAS5 and OAS6 to the server. If the server can obtain them in order (i.e.,
OAS5 → OAS6), problem does not occur. But otherwise (i.e., OAS6 → OAS5),
the server might discard OAS6 because he does not still prepare. This problem
also happens when OAS5 is missing. We call this problem the synchronization problem of one-time ID.
The differences of above calculation methods are as follows. First method needs few computation because it uses only hash function. However, if the synchronization problem of one-time ID occurs, the server is difficult to solve this problem. On the other hand, second message needs more computation because it uses the server’s public key. Moreover, new assumption is needed, that is, A and B believes PKψ(S, kS). In return for that, if the synchroniza- tion problem occurs, the server can solve it by decrypting OASi and seeing Alice’s identity included in it.
Two-party model has the synchronization problem as well as three-party model, but it is more likely to occur this problem in three-party model because Bob intervenes. Therefore, second method is more suitable for our proposed system.

Differences of One-time ID’s goals between P-SIGMA[3] and Our Pro- posal
Our proposal needs an assumption that S believes OAS is fresh (i.e., P13) to derive each user’s ping authentication (G1) and entity authentication (G2) by S, while P-SIGMA can derive all requirements introduced in Section 3.4 without freshness of one-time ID.
From the viewpoint of anonymity of both A and B, one-time ID of P- SIGMA has to be fresh. On the other hand, the freshness of one-time ID is needed to provide A’s anonymity in our proposal.
As described above, each protocol has different security goals achieved by freshness of one-time ID (see Table 2). However, since a formal analysis of


Table 2
Security goals achieved by freshness of One-time ID

anonymity has never developed so far, we cannot derive the necessity of one- time ID’s freshness in P-SIGMA. It is our future work to analyze anonymity in formal way.

Conclusion and Future Work
In this paper, we presented a scalable authenticated Diffie-Hellman based key agreement protocol using trusted third party, which uses one-time ID to achieve anonymity in application layer. We analysed this protocol using SVO Logic [7,8], and showed that our protocol can achieve considered authentica- tion goals. Furthermore, we considered one-time ID synchronization problem and computation methods of one-time ID, and proposed the solution for this problem.

References
R. Perlman, C. Kaufman, Analysis of IPSec Key Exchange Standard, WETICE2001, 2001.
K. Imamoto, K. Sakurai, Notes on Dynamic Information Management for Authenticated Key Exchange, ISEC, March 2003.
H. Krawczyk, The IKE-SIGMA Protocol, Internet Draft, Nov 2001. http://www.ee.technion.ac.il/ hugo/draft-krawczyk-ipsec-ike-sigma-00.txt
C. Neuman and T. Ts’o, Kerberos: an authentication service for computer networks, IEEE communications, 1994.
D. Otway and O. Rees. Efficient and timely mutual authentication. Operating Systems Review, 21(1):8–10, 1987.
C. Lin, H. Wen, T. Hwang, and H. Sun, Provably Secure Three-Party Password-Authenticated Key Exchange, IEICE TRANS. Fundamentals, Vol.E85.A, No.1 2002.
P. Syverson and P. C. van Oorschot. A Unified Cryptographic Protocol Logic. NRL CHAOS Report, 5540-227, 1996.
P. Syverson and I. Cervesato. The Logic of Authentication Protocols. FOSAD’00, LNCS2171, pp.63-137, 2001.
W. Diffie and M. E. Hellman. New directions in cryptography. IEEE Trans. Inform. Theory, IT-22:644–654, Nov 1976.
D. Harkins and D. Carrel. The Internet Key Exchange (IKE), RFC2409, 1998. http://www.ietf.org/rfc/rfc2409.txt


V. Shoup, On formal models for secure key exchange, IBM Research Report RZ3120, April 1999.
V. Boyko, P. MacKenzie, and S. Patel, Provably Secure Password-Authenticated Key Exchange Using Diffie-Hellman, EUROCRYPT’2000, 2000.
H. Krawczyk, SIGMA: the ’SIGn-and-MAc’ Approach to Authenticated Diffie-Hellman and its Use in the IKE Protocols, 2003.
