local strategies on operators are used in this context, in particular to force the evaluation of expressions to terminate. this kind of strategy is allowed by languages such that obj3, cafeobj or maude, and studied in and. it is de ned in the following way: to any operator f is attached an ordered list of integers, giving the positions of the subterms to be evaluated in a given term, whose top operator is f. for example, the trs



on the previous example, our method consists in proving termination of the constants, and of the terms of the form f(t); zero(t); ite(t1; t2; t3); h(t); i(t); g(t); s(t), for the previously given strategy, whatever the values of the ground terms t; t1; t2; t3. obviously, 0; true; f alse are in normal form and then terminating. for i(t)(like for s(t) and h(t)), using an induction ordering such that i(t) t, by induction hypothesis, we can suppose that t is terminating. so is i(t), since i is a constructor(i.e. i is not a top symbol of left-hand side of rule).



by de nition of the strategy, normalizing zero(t) rst consists in normalizing t, into any of its normal forms t# if it exists, and then zero(t#) at the top position. for the same ordering as previously, we have zero(t) t. then, by induction hypothesis, t terminates. let t# be any of its normal forms(there can be several normal forms if the system is not con uent). the termination of zero(t) is then reduced to the termination of zero(t#), which can only reduce into true or f alse.



normalizing h(t) also rst consists in normalizing t. in a similar way as previously, the induction hypothesis can be applied to t. the termination of h(t) is then reduced to the termination of h(t#), which can only reduce into i(0), that is in normal form, or into s(i(t#)), that is also in normal form.



normalizing ite(t1; t2; t3) rst consists in normalizing t1. as previously, t1 can be supposed to be terminating, and the termination of ite(t1; t2; t3) reduced to the termination of ite(t1#; t2; t3). according to the strategy, ite(t1#; t2; t3) is then reduced into t2 or t3, that are terminating by induction hypothesis.



our goal here is to provide a procedure implementing such a reasoning. in section 2, the background is presented. section 3 introduces the basic notions formalizing our induction principle. in section 4, a rule-based algorithm mechanizing the proof principle is given, its correctness is established and examples are given.



substitutions 1 followed by 2 is denoted 2 1. given two substitutions 1 and 2, we write 1 2 i 9 such that 2= 1. given a subset x1 of x, we note x1 for the restriction of to the variables of x1, i.e. the substitution such that dom( x1) x1 and 8x 2 dom( x1): x1 x= x:



given a set r of rewrite rules or term rewriting system on t(f; x), a function symbol in f is called a constructor if it does not occur in r at the top position of the left-hand side of a rule, and is called a de ned function symbol otherwise. the set of constructors of f for r is denoted by consr, the set of de ned function symbols of f for r is denoted by defr(r is omitted when there is no ambiguity). the rewriting relation induced by r is called standard rewriting relation and is noted!r(! if there is no ambiguity on r). we note s!p;l!r; t(or s!p;l!r; t where either p or l! r or may be omitted) if s rewrites into t at position p with the rule l! r and the substitution. the term sjp is called a redex, the position p a redex position and the symbol in s at position p is called a redex symbol. the transitive(resp. re exive transitive) closure of the rewriting relation induced by r is



de nition 3.1 an ls rewriting strategy(or ls-strategy) on terms of t(f; x)(resp. of t(f)) is a function ls from f to the set of lists of integers l(n), de ning a rewriting strategy as follows.



at each rewriting step, the term t is said to ls-rewrite into a term t0. if t does not rewrite for the ls-strategy, it is said to be in ls-normal form(or in normal form if there is no ambiguity). if any ls-rewriting chain starting from t leads to an ls-normal form then t is said to be ls-terminating(or to ls-terminate). if the evaluation strategy of a term t0 is the empty list, then t0 is in ls-normal form.



we then consider the case of any term t of t(f). for that, we observe the rewriting derivation tree for the ls-strategy starting from a term tref= g(x1;:::; xm), for any g 2 f, where x1;:::; xm are induction variables that can be instantiated by any ground term. the ls rewriting relation on ground terms is simulated by the two mechanisms below to follow the derivation tree starting from tref, and whose current term is t. let ls(top(t))=[p1;:::; pn], and pk the rst element of[p1;:::; pn] such that pk= 0.



first, the subterms tjp1;:::; tjpk 1 of t have to be ls-normalized, by definition of the above ls-strategy. if tref tjp1;:::; tjpk 1 we can suppose, by induction hypothesis, that these subterms are ls-terminating. we then replace them in t by abstraction variables xi representing respectively any of their normal forms ti#: these variables will only be instantiated by terms in normal form. reasoning by induction allows us to only suppose the existence of the ti# without explicitly computing them; this step will be called abstraction step or abstraction of the subterms of t. we also say that t is abstracted into a term v.



de nition 3.3 let n be a set of new variables disjoint from x. symbols of n are called nf-variables. substitutions and instantiations are extended to t(f; x[ n) in the following way. let x 2 n; for any substitution(resp. instantiation) such that x 2 dom(), x(resp. x) is in normal form.



de nition 3.5 an ordering constraint(t> t0) on terms of t(f; x[n) is satis able if there exists an ordering and at least one instantiation such that t t0. we say that and satisfy(t> t0).



along our induction process, when abstracting subterms ti by xi, we state constraints on nf-variables to express that their instances can only be the normal forms of the corresponding instances of the ti. they are of the form t#= x where t 2 t(f; x), and x 2 n, or more generally of the form t#= t0 where t; t0 2 t(f; x[ n). let us call such a constraint an abstraction constraint.



de nition 3.6 an abstraction constraint(t#= t0) where t; t0 2 t(f; x[ n) is satis able if there exists at least one instantiation such that t#= t0. we say that satis es(t#= t0).



de nition 3.7 let a be a constraint formula and c a conjunction of ordering constraints. the constraint problem(a; c) is satis ed by an ordering if a is satis able, and for all instantiations satisfying a, and satisfy c.(a; c) is satis able if a is satis able and there exists an ordering as above.



de nition 3.8 let r be a trs on t(f; x). a term t is narrowed into t0, at the non variable position p, using the rewrite rule l! r of r and the substitution, when is a most general uni er of tjp and l, t0=(t[r]p). this is denoted t;p;l!r; t0 where either p, or l! r or may be omitted. it is always assumed that there is no variable in common between the rule and the term, i.e. that v ar(l)\ v ar(t)=;.



the rule narrow y processes the narrowing step at position 0 of the current term u. if u is narrowable with a substitution satisfying the current constraint formula a, then u is narrowed in all possible ways in one step, with all possible rewrite rules of the rewrite system r, and all possible substitutions i, into wi;i 2[1::l]. then(fug;[0; p1;:::; pn]; a; c) is replaced by f(fwig; ls(top(wi));a^ i; ic); i 2[1::l]g, where i is the most general substitution allowing narrowing of u into terms wi. moreover, since in a, we only memorize the abstractions and narrowing substitutions performed on the current term u, and since var(u) is disjoint from the set of variables occuring in the rewrite rules of the trs, we can restrict i to var(u) in adding i to a. thus, in the following, we will write i for ivar(u).



let us also precise that if wi is a variable x 2 x, we cannot conclude anything about termination of ground instances of x. so we force the proof process to stop in setting ls(x) to a particular symbol]. however, if wi= x 2 n, ls(x) is set to[], which is coherent with the fact that any ground instance of x is in normal form.



0 or is narrowable with a substitution that does not satisfy the current constraint formula a. then no narrowing is processed and the current term is evaluated at positions following the top position in the strategy. the list of positions then becomes[p1;:::; pn].



we also can test for the current term whether there exists an ordering having the subterm property such that(a; c^ tref> u) is satis able. then, by induction hypothesis, any ground instance of u terminates for the ls-strategy, which ends the proof on the current derivation chain. the stop ind rule then replaces the set containing the current term by the empty set.



when the induction hypothesis cannot be applied on a term u, the inductive reasoning can be completed as follows. it can sometimes be possible to prove termination of any ground instance of ui(resp. u) by another way. let term in(u) be a predicate that is true i any ground instance of u lsterminates. in abstract, abstract stop and stop ind, we can then replace the condition t> ui for some i(resp. t> u) by the alternative predicate term in(ui)(resp. term in(u)). obviously, in this case, the ordering constraint t> ui(resp. t> u) is not added to c.



as in, for establishing that term in(u) is true, in some cases, the notion of usable rules can be used. given a trs r on t(f; x) and a term t 2 t(f; x[ n), we determine the only rewrite rules that are likely to apply to any of its ground instances, for the standard rewriting relation, until its ground normal form is reached, if it exists. then we try to nd a simpli cation ordering n so that these rules are oriented. thus any ground instance t is bound to terminate for the standard rewriting relation: indeed, if t! t1! t2!:::, then, thanks to the previous hypotheses, t n t1 n t2 n::: and, since the ordering n is noetherian, the rewriting chain cannot be in nite.



more formally, given a trs r, we call usable rules of a term t 2 t[n, as in, a calculable superset u(t) of the set of rules of r used in all possible lsderivations starting from any t, and de ned as follows. when t is a variable of x, then the usable rules of t are r itself. likewise, the set of usable rules associated to a nf-variable is empty, since the only possible instances of sucha variable are ground terms in normal form. when t is of the form f(u1;:::; un), then the usable rules of t are the usable rules of the ui, for i 2 ls(f);i 6= 0 and, if 0 2 ls(f), all the rules l! r having the symbol f as top symbol of lhs l, altogether with sets u(r) of the usable rules of the terms r.



since in general r contains variables of x, the evaluation of u(r) and then of u(t) is likely to result in the whole set of rules r. to compute a smaller set of usable rules, like for the narrowing substitutions, we will replace variables by nf-variables as much as we can. the idea is that the usable rules of some variables in r can be omitted since they are included in the usable rules of the ui.



de nition 4.2 let r be a trs on a set f of symbols. let rls(f)= fl! r 2 r j top(l)= f g, and rls0(f)= fl! r0 2 nf(r) j top(l)= f g. for any t 2 t(f; x[ n), the set of usable rules of t, denoted u(t), is de ned by:



proposition 4.4 let r be a trs on a set f of symbols, r0= nf(r) and for each l! r0 2 r0, no variable of x occurs in r0 at an ls-position. let t 2 t(f; x[ n). if there exists a simpli cation ordering such that 8l! r 2 u(t): l r, then any ground instance of t is terminating.



abstract applies here, since zero(x2) can be abstracted, thanks to proposition 4.4. indeed, u(zero(x2))= fzero(0)! true; zero(s(x))! f alseg, and both rules can be oriented by a lpo with the precedence zero f true and zero f f alse. then we have term in(zero(x2)).



x4= 0 and x1= i(0). the second one is satis able by any instantiation such that x4= s(0) and x1= i(s(0)). the third one is satis able by any instantiation such that x3= zero(i(0)), x2= i(0) and x1= i(i(0)).



the second abstract applies onf(h(x4)), thanks to proposition 4.4. indeed, u(h(x4))= fh(0)! i(0); h(x)! s(i(x))g, and both rules can be oriented by the same lpo as previously with the additional precedence h f i and h f s. then we have term in(h(x4)).



one could have tried to narrow f(x5), by using the rst rule and the narrowing substitution nf=(x5= i(x6)^ x000= x6). but then a^ nf would be(x1#= x1^ x1= i(x2)^ zero(x2)#= x3^ x3= f alse^ x2= x4^ h(x4)#= x5^ x5= i(x6)). for any satisfying a^ nf, must be such that h(x4)#= h( x4#)#= i( x6). if x4# 6= 0, then, according to r, h( x4#)! s(i( x4#)), where s is a constructor. then we cannot have h( x4#)#= i( x6), so must be such that x4#= 0. but then zero(x4)#= true, which makes a^ nf unsatis ed. therefore there is no narrowing.



more precisely, the method is applied on terms of the form g(x1;:::; xm), where g is a de ned symbol, and consists in iterating the application of two steps: an abstraction step, replacing immediate subterms by nf-variables, representing any of their normalized instances, and a narrowing step, reducing the resulting term according to the di erent possible instances of its variables. these two steps are iterated until getting a term for which one can easily say that all ground instances are terminating. the important point to automate our proof principle is the satisfaction of the ordering constraints for abstract, abstract stop and stop ind.





m. clavel, s. eker, p. lincoln, and j. meseguer. principles of maude. in j. meseguer, editor, proceedings of the 1st international workshop on rewriting logic and its applications, volume 5 of electronic notes in theoretical computer science, asilomar, paci c grove, ca, usa, september 1996. north holland.



nakamura m. and ogata k. the evaluation strategy for head normal form with and without on-demand ags. in k. futatsugi, editor, proceedings of the third international workshop on rewriting logic and its applications, wrla'2000, pages 211{227, kanazawa city cultural halt, kanazawa, japan, september 2000. electronic notes in theoretical computer science.



that p= j:p0. by induction hypothesis on uj, strict subterm of t, we have the property: 8p 2 ls p os(uj): u(ujjp) u(uj). then, since p 2 ls p os(uj), we have u(ujjp0) u(uj), that is u(tjp) u(uj). moreover, by de nition of the usable rules, we have: u(t)=



proof. this lemma is a corollary of the lemma a.1. indeed, if x occurs at an ls-position p in t then, according to lemma a.1, u(tjp) u(t). since tjp= x 2 x, by de nition of the usable rules, we have u(tjp)= r, therefore r u(t). since we also have u(t) r, we get u(t)= r. 2



lemma a.3 let r be a trs on a set f of symbols and t 2 t(f; x[ n). then, every symbol f 2 f occuring in t at a redex position is such that rls(f) u(t).



proof. this lemma is also a corollary of lemma a.1. indeed, if f occurs in t at a redex position p, then p 2 ls p os(t). according to lemma a.1, u(tjp) u(t). since f is a redex symbol, we have 0 2 ls(f), and then



lemma a.4 let r be a trs on a set f of symbols, r0= nf(r) and t 2 t(f; x[n). for each l! r 2 r, we note l! r0 the rule nf(l! r). then l! r 2 u(t)) u(r0) u(t).



proof. according to lemma a.2, if a variable of x occurs in t at an lsposition, then u(t)= r, and then the property is trivially true. we will then suppose in the following that t does not contain any variable of x at an ls-position.



lemma a.5 let r be a trs on a set f of symbols and r0= nf(r), so that for each l! r0 2 r0, no variable of x occurs in r0 at an ls-position. let t 2 t(f; x[ n) such that no variable of x occurs in t at an ls-position. whatever ground substitution such that var(t) dom(), and t!p1;l1!r1 t1!p2;l2!r2 t2!:::!pn;ln!rn tn ls-rewrite chain starting from t, the symbol of tk; 1 k n at a redex position of tk is either a redex symbol of t or one of the ri;i 2[1::k].



for an empty derivation, the property has to be checked on t. in this case, let us show that whatever x 2 x[ n variable of t, x does not introduce redex symbol in t. let x be a variable of t occuring at position p.



if x occurs at an ls-position in l1, since l1= tjp1, then x is a subterm of t at an ls-position. then, for a redex symbol f of x, f is a redex symbol of t. then, as shown before, f is a redex symbol of t.



let us now suppose the property true for any term of the ls-rewrite chain t0= t!p1;l1!r1 t1!:::!pk;lk!rk tk, and let us consider tk!pk+1;lk+1!rk+1 tk+1. we then have to show that every de ned symbol of tk+1 at a redex position comes either from t or from one of the ri;i 2[1::k+1]. by hypothesis, there exists a substitution such that lk+1= tkjpk+1 and tk+1= tk[ rk+1]pk+1.



lemma 4.3 let r be a trs on a set f of symbols, r0= nf(r) and for each l! r0 2 r0, no variable of x occurs in r0 at an ls-position. let t 2 t(f; x[ n). whatever t ground instance of t and t!p1;l1!r1 t1!p2;l2!r2 t2!:::!pn;ln!rn tn ls-rewrite chain starting from t, then 8i 2[1::n]: li! ri 2 u(t).



proof. if a variable x 2 x occurs in t at an ls-position then, thanks to lemma a.2, we have u(t)= r and the property is trivially true. we then consider in the following that the variables of x in t do not occur at an lsposition. we proceed by induction on the length of the derivation.



the property is trivially true if t is in normal form. for any t!p1;l1!r1 t1, since no variable of t occurs at an ls-position, p1 is a non variable position of t. let f be the symbol at position p1 in t. then, thanks to lemma a.3, rls(f) u(t). moreover, since f is the symbol at the redex position, l1! r1 2 rls(f). therefore we get l1! r1 2 u(t).



or the symbol f at position pk+1 in tk is a symbol of a r0i;i 2[1::k], occuring at an ls-position; then, thanks to lemma a.3 on r0i, we get rls(f) u(r0i); moreover, since f is the symbol at the redex position, lk+1! rk+1 2 rls(f), henceforth lk+1! rk+1 2 u(r0i); by induction hypothesis we have li! ri 2 u(t) and, thanks to lemma a.4, we have u(r0i) u(t). henceforth lk+1! rk+1 2 u(t).



proposition 4.4 let r be a trs on a set f of symbols, r0= nf(r) and for each l! r0 2 r0, no variable of x occurs in r0 at an ls-position. let t 2 t(f; x[ n). if there exists a simpli cation ordering such that 8l! r 2 u(t): l r, then any ground instance of t is terminating.



lemma b.3 let r be a trs. let s 2 t(f; x), a ground substitution such that s is reducible at a position p 2 o(s), and y x fvar(l) j l! r 2 rg a set of variables such that v ar(s)[ dom() y. if s!p;l!r t0, then there exist a term s0 2 t(f; x) and substitutions; such that:



let=[. then we have:(sjp)=(sjp)= l= l, therefore sjp and l are uni able. let us note the most general uni er of sjp and l, and s0=(s[r]p). therefore, by de nition: s;[p;l!r;] s0, and then the point 1.



according to proposition b.1, we have var((s))=(var(s) dom())[ ran( var(s)); by de nition, var(s) y and ran( var(s)) ran(), therefore var((s))(y dom())[ ran(), that is var((s)) y1. therefore, with the previous point, we get v ar(s0) y1.



to each step of the procedure characterized by(ftg; l; a; c), we associate the set of ground terms g= f t j and satisfy(a; c)g. inference rules abstract, narrow y and narrow n transform(ftg; l; a; c) into(ft0g; l0; a0; c0) to which is associated g0= f t0 j and satisfy(a0; c0)g. we then prove the following result: if for all t0 2 g0, t0 ls-terminates wrt l0, then any t in g ls-terminates wrt l.



f(u1;:::; um) is abstracted. so by induction hypothesis, the ukj lsterminate. moreover, for i 2 fi1;:::; ipgnfk1;:::; klg, we have term in(ui) and then ui ls-terminates. finally, for i 2 fp1;:::; pk 1g n fi1;:::; ipg, ui is either a ground term in normal form or an nf-variable, and then ui ls-terminates.



:::; um)! t0, thanks to lemma b.3, there exists a narrowing step f(u1;:::; um); v and a substitution such that t0= v. moreover, this narrowing derivation is e ectively produced by narrow y, which is applied in all possible ways on ff(u1;:::; um)g. then ls-termination of the v implies ls-termination of f(u1;:::; um).



let us now prove that the ground instances satisfying(a; c) of each term t removed from t during the application of the rules ls-terminate. the rst rule removing terms from t is stop. when stop is applied and removes t from t, then the evaluation strategy of t is[]. then, for any ground substitution satisfying a and c, t ls-terminates.



induction hypothesis, the ukj ls-terminate. moreover, for i 2 fi1;:::; ipgn fk1;:::; klg, we have term in(ui) and then ui ls-terminates. finally, for i 2 fp1;:::; png n fi1;:::; ipg, ui is either a ground term in normal form or an nf-variable, and then ui ls-terminates. therefore, by de nition of the evaluation strategy of t, t ls-terminates.



