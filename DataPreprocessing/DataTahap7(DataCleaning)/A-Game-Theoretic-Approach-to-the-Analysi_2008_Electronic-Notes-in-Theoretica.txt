the classical methodology of model-checking(see) refers to a fixed system and a specification of its behavior. usually the states and transitions of the system under consideration are collected in a transition graph(kripke structure), and the only dynamic aspect is the change of state(via available transitions) which is then captured by the concept of an execution path or(if branching behavior is considered) of a computation tree. specifications are definitions of desired properties of execution paths or computation trees.



a theory of model-checking over dynamic structures is still very much in its beginnings. some references known to us are[15,3,13] where the data structures with a dynamic behavior(like programs or uml state machines) are efficiently encoded(e. g. as lists or trees) for the use of well-established model-checking methods. the objective of this paper is to introduce(and prove initial results on) a simple but quite



specifications for dynamic networks are typically concerned with guaranteeing desirable properties of networks. in the present paper we only consider the properties of connectivity and biconnectivity.(a graph is biconnected if deletion of any node still leads to a connected graph.) there are many similar properties, like kconnectivity, having a small diameter, having a certain minimal degree for all nodes, etc.



previous studies of dynamic networks addressing the aspect of adversarial agents have been concerned with routing problems. in such studies it was either assumed that the network under consideration stays connected or the connectivity of the network is at least given infinitely often over time(cf.[6,1,2]).



the two players destructor and constructor play turn by turn(destructor starts). in our model the players are allowed to skip as well. plays are infinite in general, but may be considered finite in the cases where neither of the players can move, or a given winning condition is satisfied.



solitaire games: in this case, only constructor moves and keeps control of the evolvement of networks. deletion and hence restoration moves are not admitted, and the moves that remain are either the creation or the re-labeling of nodes. a variant suggested by the solitaire model is the situation where constructor also carries out the deletion moves. this corresponds to a situation where the evolvement of a structure(here: a network) is controlled completely by one agent.



a possible criticism about our framework may be the radical difference between destructor and constructor, which puts the former into an advantage. this can be remedied by natural conventions, for example by the assumption that destructor keeps silent(i. e., skips) for certain periods of time until a deletion is carried out. it depends on the respective area of application how a balance between constructor and destructor should be tuned. in the context of fault tolerance(which is the motivation of our work), it is natural to assume that that the deletion actions of destructor are undesirable and the creation and restortation actions of constructor are desirable. in other domains, the converse is conceivable. the purpose of



for each such turing machine m we construct a solitaire game(i. e. an initial connected network g and a set r of rules) such that m halts when started on the empty tape iff constructor can reach a biconnected network from g by applying the rules of r.



for the proof it suffices to observe that from the initial network only finitely many distinct networks(over the unchanged original vertex set v) can be generated. if there are n such networks, each play will yield a repetition after at most n steps. hence, for deciding the winner(and providing a winning strategy) it suffices to build up the game tree up to depth n.



remark 4.3 in order to keep the model simple we do not consider scenarios where deletion and insertion of edges are allowed. since the number of possible edges in the non-expansive case is bounded by|v|, the absence of edge insertion and deletion is insignificant for the decidability of the model-checking problem.



one might have the impression that the high complexity for the case without node creation is only due to consideration of information flow resp. labeling rules. but even without these rules, simple questions like connectivity cause computational problems. we present a corresponding pspace-hardness result in thm. 4.6 below using a reduction to sabotage games again. for readers who prefer a reduction to a standard problem, we include also a np-hardness proof(invoking the vertex cover problem).



