we motivate, define and design a simple static analysis to check that comparisons of floating point values use compatible bit widths and thus compatible precision ranges. precision mismatches arise due to the difference in bit widths of processor internal floating point registers(typically 80 or 64 bits) and their corresponding widths when stored in memory(64 or 32 bits). the analysis guarantees that floating point values from memory(i.e. array elements, instance and static fields) are not compared against floating point numbers in registers(i.e. arguments or locals).



the successive field store forces the value to be truncated to 32 bits, thereby changing the value. in the example, 9.42477822 is coerced to a float, causing a loss of precision resulting in the value 9.424778 being stored in the field this.balance. when the postcondition is evaluated, the truncated value of balance is reloaded from memory, but the addition in the postcondition is re-computed with the internal precision. comparing these two values causes the postcondition to fail,



we have implemeted the analysis described in this paper in clousot, our static analyzer for codecontracts. the analyzer first reads the il from disk, then constructs for each method the control flow graph, inserting contracts at the necessary points. then it simplifies the program by getting rid of the evaluation stack and the heap, reconstructs expressions lost during compilation, and finally produces a scalar program.



several analyses are run on the top of the scalar program, i.e. non-null, numerical, array, or arithmetic. we added the detection of precision mismatches in floating point comparisons described in this paper to the arithmetic analysis. the analysis is fast and accurate: on the core library of the.net framework, mscorlib.dll, constisting of 25089 methods, it adds less than 10 seconds to the total time, and it reports 5 warnings. we manually inspected those, and they all represent real warnings similar to the following example:



we decided to detect problems with precision mismatches only when comparing floating point numbers. another view would be to write an analysis that warns users whenever some higher precision float is implicitly cast to the nominal type width(effectively whenever a result is stored into memory). the problem with such an alternative analysis is that it would a) warn about most memory writes, b) miss implicit narrowings arising due to register spilling into memory introduced by the compiler. we found that warning about comparisons addresses the problem in a more actionable way.



