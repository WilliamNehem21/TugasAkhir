modularization and component reuse are concepts that can speed up the design and implementation of domain specific languages. several modular development frameworks have been developed that rely on attributes to share information among components. unfortunately, modularization also fosters development in isolation and attributes could be undefined or used inconsistently due to a lack of coordination. this work presents 1) a type system that permits to trace attributes and statically validate the composition against



domain specific languages(dsls) are getting more and more relevant nowadays but their development is still difficult and this contains their proper spread. one way to ease dsl development, consists in maximizing reuse by modularizing the language and its implementation in the composition of loosely coupled language component s where a language component is any language-oriented concept that should be part of the language shipped together with its implementation. according to this trend several modular development frameworks have been developed such as lisa, jastadd, silver, spoofax and neverlang.



semantics for such a concept. composition is typically driven by the syntactic description of the language component that provides an interface to the other language components. even if loosely coupled the code realizing the semantic of the different language components relies on data computed by the other components and the sharing of these data is typically delegated to and relies on the presence of attributes. being the composition syntax-driven, semantic constraints as attributes presence are rarely considered at development/composition time.



the paper is organized as follows. section 2 introduces the problem of welldefinedness in attribute grammars, how this is contextualized to the framework neverlang and an overview of the proposed solution. section 3 introduces the formalization of neverlang slice that is used in section 4 to define a small-step operational semantics that specifies how the semantic actions define, access and modify the attributes of syntax-trees. section 5 introduces a type system for a type decorated version of slices which prevent runtime errors and states the soundness result. section 6 outlines the type inference algorithm and states that it is correct and complete for the type system. in sect. 7 some related work and the application of the presented system to them is discussed. in sect. 8 we draw some conclusions.



a slice defines its own syntax through some grammar rules. it also defines semantic roles, i.e., a set of semantic actions associated with the grammar rules. roles represent single tree traversals and the semantic actions are executed during the traversal. semantic actions are written in a java-like dsl that permits to define and work with attributes. roles can be defined in modules collected and/or reused by the slices.



in quotes. each production may be preceded by a label(e.g., if) that can be used in semantic actions to refer to the production nonterminals. each role is associated with a name, in our example evaluation. semantic actions are written enclosed between.{ and}. symbols. an action is associated with its production by a label that precedes its definition. the example in listing 1 has a single semantic action associated with the only production in the grammar.



the semantic action code can refer to all nonterminals of the associated production by using the following syntax$label[offset], where label is the label identifying the associated production. the head nonterminal has offset 0. so in the above example, the head nonterminal can be referred by$if or simply$if. the second nonterminal representing the condition part of the if-then-else expression can be referred to by$if and so on.



the semantic action, first, traverses the subtree representing the condition part of the if-then-else construct(eval$if). this traversal may define new attributes in the node represented by$if. these attributes may come from other modules implementing the exp nonterminal. depending on the value of the$if.val attribute, we continue by traversing one of the branches of the if-then-else construct(eval$if or eval$if). in both branches, we copy the val attribute of the branch to the current node.



problem statement. since the nature of attributes in neverlang is dynamic, an attribute might not be defined when needed. there are basically two reasons for this. first, an attribute might get defined only when a specific computational path is followed. for example, let us suppose that the else branch in listing 1 misses the



solution overview. to identify erroneous situations like these a formalization of neverlang has been provided that describes all the relevant entities involved in the framework and their formal semantics. to prevent errors, we introduce a version of neverlang, in which semantic actions and nonterminals are decorated with types specifying their definition and use of attributes. the decorations are used to assess the result that: if the code of the semantic actions is well-typed with respect to these decorations then computations on the syntax-tree of any string of the language correctly proceeds. the result assumes that we have a complete language implementation, however, since development is compositional we specify type-checking incrementally, by associating with a slice the information about the defined/used attributes of the nonterminals occurring in it. to type-check the composition of slices, we use this information, i.e., the code of the semantic actions of the slice is not needed.



the type decoration needed for type-checking can be inferred. in section 6, we outline an algorithm that, given a neverlang slice, analyzes the code of its semantic actions and produces the information about the definition/use of attributes for the nonterminals associated with the slice. the algorithm fails in case the slice cannot be decorated in such a way that type-checking succeeds. moreover, if the algorithm succeeds from the information produced we can derive all possible decorations for the slice. type inference of composition of slices relies on this information, making inference compositional.



of a semantic action, eval p[i] where p[i] specifies the nonterminal at position i in the production labeled p in p. expressions can be integer or boolean constants, the value of an attributes of instances of nonterminals(p[i].a), or the application of some operators to expressions. in the examples, we will use operators such as+ and



example 4.2 let us consider the productions if, int and dbl in listings 1, 2 plus the start production s: s d exp;(s is the start symbol) which is added to transform the productions into a grammar according to def. 3.3. define the slice containing the actions specified in listings 1, 2 plus the action:



in this section we give an informal definition of the type inference function for slices, ts, describing the constraints returned by this function, and showing how constraints are checked for consistency and combined. then, we state the results of correctness and completeness of type inference w.r.t. the type system of section 5.



to state completeness we have to relate typed slices with their underlying untyped version. therefore, we introduce the erasure of a typed slice, erase(tsp), which is the slice obtained by erasing the decoration of actions in tsp. note that, the typed slice tsp returned by ts(sp) is such that erase(tsp)= sp.



the proposed type system is also applicable to some non-modular development frameworks, although the lack of modularity makes the well-definedness analysis less challenging. even though antlr forces to declare attributes the compiler generator does not check that attribute values are actually set. when an attribute is defined but not set the compiler generator assigns a default value to it and this might drive to some unexpected behavior. with our approach such errors wold be detected. similar considerations can be done for yacc. on the other hand, spoofax does not rely on attributes and jastadd that uses full-fledged attribute grammars cannot benefit from the proposed type system.



to share semantic information. the proposed type system traces attribute definition and use. well typed components cannot cause runtime errors due to attribute misuse. the type decorations needed for the type system can be inferred from the definition/use of the attributes in the semantic actions associated with the components without knowledge of the whole language implementation.



