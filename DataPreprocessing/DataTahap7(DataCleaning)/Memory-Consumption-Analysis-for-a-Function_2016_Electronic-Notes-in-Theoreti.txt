the omnipresence of resource-constrained embedded systems makes them critical components. programmers have to provide strong guarantees about their runtime behavior to make them reliable. among these, giving an upper bound of live memory at runtime is mandatory to prevent heap overflows from happening. the paper proposes a semi-automatic technique to infer the space complexity of ml-like programs with explicit region management. it aims at combining existing formalisms to obtain the space complexity of imperative and purely functional programs in a consistent framework.



in this paper, we propose a language`a la ml mixing purely functional and imperative features with an explicit region mechanism. to retrieve information about a program memory interactions, we rely on a static type& effect system and manual memory management through region related primitives. the type system aims at ensuring the absence of memory-related errors at compile time. to



the main goal of this paper is to introduce a framework to combine various memory consumption analyses depending on the programming style used at function level to provide an upper bound of live memory at compile time considering reclaimed memory. in the remainder, related works are presented in section 2. we describe the language in section 3 with its type& effect system on which we base our analysis. then, we show how to deal with purely functional and imperative features in sections 4, 5 as described above and section 6 composes them in a consistent framework. then, we show how it works on an example in section 7. finally, we conclude with a discussion about current limitations and further improvements.



resource consumption analysis started in the late 70s with metric targetting the best, worst and average execution times of programs written in a pure subset of lisp. based on recurrence relations, it can be adapted to memory consumption analysis. contrary to time, memory can be reclaimed. hence, new methods have emerged from both purely functional and imperative communities to obtain upper bounds on live memory.



several projects. among them, raml, a pure ml language and raja, a subset of the java language. it is able to infer polynomial bounds on live memory considering some side-effects in the last version without any user annotation.



invariants over iteration spaces have been used in the jconsume project targetting the java language. it considers side-effects through an escape mechanism. it also relies on invariants provided by external tools or the programmer to extract program space complexity. thanks to the escape mechanism, it can provide an upper bound on live memory.



in modern high-level languages, memory management is often performed by a garbage collector. mainly ruled by dynamic criteria, predicting its behavior is a difficult problem. for instance, we need to know when it will be triggered and how much memory will be reclaimed.



that the access to a value in region r is sound. for region allocated values, we have different rules. we need to distinguish region handlers from other values because of the linearity constraints. the role of the primitive instantiate is to replace type parameters with fresh type variables. hence,



to introduce capabilities in the system, the primitive newrgn has to be used. it gives the permission to allocate, read, write values in the region. we can see that the capability is qualified with a linear property. at creation, we know that it has not been shared. this is an important criterion for reclaiming a region.



sometimes using a region handler several times is necessary. for instance, when you need to pass several region handlers as arguments to a function. this is the case when you use a function that copies a list in two distinct regions. to perform this, aliasrgn can help. leaving the scope of this primitive restores the linearity property we had before.



we have a set of rules giving information about the memory behavior of our programs and providing guarantees that a well typed should not crash because of memory management. moreover, regions give us an abstract view of the heap at compile-time. in section 6, we will see how this view can be useful to do a resource consumption analysis.



to perform a resource consumption analysis, we need to model the runtime environment with respect to memory usage. programs written in our language can allocate memory with the creation of five different kinds of values: closures, pairs, lists, references and region handlers. thus, we introduce five constants representing the amount of allocated memory for a pair, a list node, an empty list, a reference and a region handler. for closures, we introduce a specific operator because the amount of memory used is proportional to the number of free variables. we assume that compilation schemes do not introduce additional heap memory allocations.



the goal of this analysis is to provide an upper bound of live memory at compiletime to prevent heap overflows. the analysis consists in a mix of several existing resource consumption analyses. it returns the amount of allocated memory in each region involved by a function call. with region sizes and the region mechanism, we are able to consider reclaimed memory.



to analyze a program, we distinguish functions written with a purely functional style from those written with an imperative style. to do this, we rely on the language effect system. in this language, side effects happen through reference updates. hence, if a function type is labelled with a write effect on a region r then this function is considered impure and is analyzed with the analysis based on invariants on iteration spaces. whereas if the function only performs alloc or read effects then it is seen as pure and can be analyzed thanks to automatic amortized analysis.



the analysis being compositional, we cannot easily count the number of times a function is applied. this constrains us to add the following restriction: potential contains in a function closure has to be null. thus, memory consumption can only be parameterized by the function parameters.



the pattern matching rule is crucial. depending on the branch taken, different assumptions about data structure sizes can be made. for instance, if the nil branch is taken then we know that the list is empty. but if the cons branch is taken then we know that the list has at list one element with its potential. this rule combined with allocation sites drive the analysis.



with this rule, the amount of potential available cannot be duplicated but is shared among different variables. for instance, list a k0 means that each list element has k0 credits. if this list is shared between variables x: list a k1 and y: list a k2 then we generate a constraint similar to k0= k1+ k2.



this function can allocate memory in different regions(depending on how it is called). we are interested in the more general case. what size regions r, r1 and r2 will be? to do this we apply the analysis to each region. hence, we are going to get three different sets of relations to minimize.



programs written with an imperative style perform side-effects through the use of references. to consider them, we need to use a different method: invariants on iteration spaces. we rely on recent work done in the jconsume project targeting java programs at the bytecode level.



we adapt this analysis to programs written in our language. we still rely on the user to provide invariants. they can be expressed using all classic arithmetical and logical operators. these can be directly provided by her or obtained through the use of external tools. they are written with the with syntax as in



contrary to the original work, here we do not care about the notion of escape memory as it is already handled through the use of regions. as in the automatic amortized analysis, we are looking for the sizes of the different regions involved in the computations. to perform this, invariants characterize the number of iterations. here, invariants are linear relations but the user could provide other classes as well. the advantage of linear invariants comes when we try to infer them.



assignments are cumulative, meaning that data is added to previous data reachable through the reference. hence, to determine the amount of memory reachable from them, we rely on the same invariants. in the end, we dereference ys and zs, so we propagate the amounts of memory reachable through these references.



to track side-effects, it is necessary to manage references with some accuracy. for instance, if a reference is updated then we need to propagate new size information about the value being dereferenced to pursue the analysis. unfortunately, space complexities are not directly related to the sizes of the data structures involved. the



if the programmer employs the region mechanism with a fine granularity, it is possible to derive data structure sizes from space complexity. the function append is a good illustration of this principle. its type shows that the two lists can reside in two different regions and that the resulting list lives in the same region than the second argument. the combination of the base case and the effect alloc r2 entails that data is added to the second list. thanks to this, we can deduce that the size of the resulting list is the sum of lists passed as arguments.



when size relations cannot be extracted automatically, the programmer has to provide them manually with the with syntax just like for the imperative analysis to run the analysis. annotations can be provided through the use of classic arithmetical operators and the size operator. this size operator is a way to count the number of node of a data structure. variables bound to integers can be used directly to refer to the integer itself.



conditional expressions introduce the use of the operator max. to keep the analysis sound, we need to consider the worst case. here, it means the maximum of memory allocated in a region and the maximum amount of memory reachable from a reference.



the following example shows how the analysis is performed. the main function is revappend which concatenates two lists by reversing the first one to be tail recursive. this function can be written in at least two different styles: purely functional and imperative.



the imperative version of revappend is analyzed thanks to invariants on iteration spaces. here, the side-effect is local to the function. hence, the amount of allocated memory is the only information propagated. here, the invariant is length!rs= size xs+ size ys where size ys is a constant. it is linear and could be obtained in an automatic way. in other cases, we would rely on programmer annotations. from this, we can deduce the amount of allocated memory. in this case, it is also proportional to the length of the first list.



in this example, both analyses return similar results. then, we can instantiate symbolic expressions to get the amount of memory necessary to execute the program in a safe way. here, we can see that the region rr is freed at the end. if the program would be larger, this region would have been considered as non-existent to analyze the rest of the memory allocated.



we present a language`a la ml mixing pure and imperative features with an explicit region mechanism. memory management is performed by the programmer through a set of primitives and checked at compile time. this mechanism provides information about the heap topology and lifespans of allocated values.



the analysis relies mainly on an effect system and a region mechanism. the effect system allows us to combine several analyses depending on the programming style employed by the programmer. regions offer lifespans of allocated values. this prevents overpessimistic bounds because we can consider reclaimed regions at compile time. automatic amortized analysis is used on pure functions and invariants on iteration spaces are employed on imperative functions.



