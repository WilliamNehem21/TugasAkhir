the second criterion is space safety: a program transformation is space safe if it does not raise the complexity of programs. clearly, program transformations used in a compiler must satisfy this criterion. however, we think that this criterion is too loose. this criterion does not impose any restriction for programs without inputs. however, showing space safety is simpler than showing space efficiency, in the sense that it is possible to adopt a simpler profiling semantics that ignores details such as sizes of closures and stack frames.



the criterion we propose is a property of a whole-program transformation. on the other hand, some transformations used in compilers are based on local program transformations. we therefore also study the connection between the properties of local transformations and the properties of global transformations. we will show that some restricted class of local transformations induces whole-program transformations satisfying our new criterion.



we review the safety criteria of program transformations with respect to performance discussed in previous studies. to formalize safety criteria we must first develop semantics to formalize performance of programs. we call such semantics profiling semantics. for a simple programming language, profiling semantics can be given as a partial function eval(m):



although many program transformations used in compilers seem space efficient, some useful transformations are not space efficient, but only space safe. furthermore, to show that a program transformation is space efficient we must consider too many details of the operational semantics of the source language. in the study of the cps transformation it was necessary to revise the semantics proposed by blelloch and greiner to show that the cps transformation was space efficient.



the theorem above is still not enough to use a local transformation in a compiler. in a compiler we usually apply local transformations n times in one phase of a compiler where n is proportional to the size of a program. even for such composition, a strong improvement relation induces a space efficient transformation.



we have shown weak efficiency only for stack space for two semantics of a simple functional language. it will not be very difficult to deal with execution time or heap space. for example, the proof that the cps transformation is space efficient can easily be modified to show that the cps transformation is weakly space efficient with respect to a simpler space semantics of the source language that ignores the sizes of closures and stack frames.



we have shown no examples of local program transformations that are weak improvement relations or semi-strong improvement relations. we are planning to show that various optimizations formalized as local program transformations have these kinds of properties. in this area, gustavsson and sands have developed a theory of space improvement relations for call-by-need programming languages and have shown that several local transformations are weak improvements. their work will be also applicable to call-by-value languages.



