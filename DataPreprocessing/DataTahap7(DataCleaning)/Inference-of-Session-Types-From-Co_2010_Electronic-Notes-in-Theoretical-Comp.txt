a process may commit to one of these choices either passively or actively, and either implicitly or explicitly. if a process makes the choice actively, then the choice was made by the process based on its choice of communication steps. if the process makes the choice passively, then the choice was made based upon the active choice made by its peer.



after performing a communication action, or in the case of explicit choice another relevant action, the current type of the session mutates in order to reflect the current state of the channel. if a choice has been made, the session type is replaced with the type corresponding to the choice that has been made. if a communication action has occurred, the type representing that communication action is removed from the beginning of the current session type. the resultant session type is known as the continuation type of that session type under the given action.



our inference system is specified in two distinct ways. firstly we shall provide a set of inference rules and a methodology for applying them in order to derive a session type. secondly we shall describe a graph-based implementation technique for the algorithm. the graphs used by this technique are based on finite automata and thus we employ a number of techniques from this field, including the subset construction.



ninja can be considered an implementation of common component models such as architecture description languages as shall be described in section 2. it may extend most imperative languages, however our implementation is for the c++ language and is known as ninja-c++. we describe the implementation of ninja-c++ and of a type inference tool for it.



after we have used a session variable(i.e. by sending or receiving over it), it becomes invalid. this means that any further use of the variable is an error and would violate our typing system. a variable with such a constraint imposed upon it is known as a linear variable, and any program that satisfies this property is said to satisfy the linearity constraint. we have developed a prototype tool to check linear usage of session values.



in order to ensure the correct behaviour of the program, we impose the following constraints on the operation of closing a session. sessions of type end must close their session by performing the close operation on the session. furthermore, sessions of any other type may not close. the second constraint is trivial to enforce, but we may enforce the first constraint by asserting that for each statement a that assign to a session s of type end, there must exist a statement c of the form s.close() such that i.e. c postdominates a. intuitively this means that all sessions that are scheduled to close(by a communication operation resulting in a session of type end) are guaranteed to close by the control flow of the program, provided the program is not interrupted, e.g. by the operating system.



if the dfa nodes have overlapping subsets, which is entirely possible based on the structure of our program, we will not be able to type those session variables that appear in two or more nodes, as each session variable must have a single type. thus for each node in the original graph we must merge all nodes in the resultant graph containing that node; i.e. for each original node n we apply the substitution function



the first step in implementing the algorithm is to create an untyped version of ninja-c++. creating an untyped version of the language entails creating versions of the session and channel templates that do not take session type parameters. the two use cases for our type inference system are deriving intermediate session types, and deriving full session and participant information. thus we must have two variants of our untyped implementation; for the first, only session and channel are untyped(known as the untyped sessions variant); for the second, everything is untyped(known as the untyped participants variant).



the implementation of the algorithm is used to automatically assign types to sessions, channels and participants. it proceeds in three stages. firstly it uses an ast traversal to collect information about the session usages, channel invocations and participant definitions that the program uses. information about session usages is stored in a graph-like structure, a mapping between a node and a set of arcs. each arc stores direction and type information as well as the node the arc points to. each node stores a set of rose ast variable declarations which represent the session variables that correspond to the type at that node. information about channel invocations is stored as a mapping from channel variables(ast variable declaration for the channel) to session nodes. information about participant definitions is stored as a mapping from the template parameter representing the channel type to the session node.



