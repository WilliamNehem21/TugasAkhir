we describe the design and prototype implementation of a combination of theorem prover interface technologies. on one side, we take from proof general the idea of a prover-independent interaction language and its proposed implementation within the pg kit middleware architecture. on the other side, we take from isawin a sophisticated graphical metaphor using direct manipulation for developing proofs. we believe that the resulting system will provide a powerful, robust and generic environment for developing proofs within interactive proof assistants that also opens the way for studying and implementing new mechanisms for managing interactive proof development.



proof general is a generic interface for interactive proof assistants, built on the emacs text editor[4,7]. it has proved rather successful in recent years, and is popular with users of several theorem proving systems. its success is due to its genericity, allowing particularly easy adaption to a variety of provers(primarily, isabelle, coq, and lego), and its design strategy, which targets experts as well as novice users. its central feature is an advanced version of script management, closely integrated with the file handling of the proof assistant. this provides a good work model for dealing with large-scale proof developments, by treating them similarly to large-scale programming developments. proof general also provides support for high-level operations such as proof-by-pointing, although these are less emphasised.



proof general provides an advanced implementation of script management which synchronises file editing between the proof assistant and editor in a twoway communication. files are used to store proof scripts, representing parts of developments. if the user completes processing a proof script file, proof general informs the prover, if the prover reads another file during processing, it will inform proof general, and similarly for undo operations at the file level. technically, proof general is implemented mostly in emacs lisp, interfacing with other emacs packages, notably including x-symbol for displaying mathematical symbols. a considerable effort has been made into making it easy to adapt proof general to new proof assistants, and it is possible to



to address the limits of the existing proof general model, and particularly of the emacs lisp implementation, proof general(pg) kit has been designed[5,6]. the central idea is to use the experience of connecting to diverse provers to prescribe a uniform protocol for interaction. instead of tediously adapting proof general to each prover, proof general calls the shots, by mandating a uniform protocol for interactive proof, dubbed pgip, which each prover must support.



isawin is the instantiation of a generic graphical user interface called gengui for the isabelle proof assistant. it provides a more abstract, less syntaxoriented interface to isabelle(and related provers), based on the visual metaphor of a notepad. all objects of interest, such as proofs, theorems, tactics, sets of rewriting rules etc. are visualised by icons on a notepad, and manipulated there using mouse gestures. more complex objects such as proofs can be manipulated by opening them in a separate sub-window. isawin offers selfcontained history support, proof-by-pointing, dependency management and session management.



appearing in its pop-up menu and whether(and how) it can be opened into a separate sub-window. the interface also keeps track of dependencies, i.e. if one object is used as an argument to construct another object, and if objects are changed or outdated, all dependent objects are outdated as well.



for us, the experience with gengui and isawin has shown that the implementation of an interface as an add-on to the proof assistant, even in the same programming language, can leads to a less modular architecture, which makes the interface difficult to reuse. it also makes the interface less robust: if the prover diverges or returns a run-time error, the interface diverges or stops as well. for these reasons, not many different adaptations of gengui exist, and in comparison with proof general, gengui has not fully delivered on its promise of genericity.



the spirit of proof general kit is to use lightweight protocols to connect together a range of components used for conducting interactive proof. components are loosely coupled, and may be run on different machines. the specifics of the design are intended to work with existing theorem provers. thus, where some of our design decisions appear fairly conservative, this is because we want to allow a gradual migration of existing theorem provers to



we expect that the other components have no access to the proof assistant other than via the mediator. the other components may have direct access to the theory store, but(especially in case of write access) this must be carefully sanctioned by the mediator. this separation allows the mediator to organize the synchronization messages needed for interactive development, for example, maintaining a set of locked files.



proof development proceeds by traversing the fundamental states, building up proof scripts along the way. this incremental development model is an abstraction of what occurs in a typical prover, based on the current model used in proof general. some provers may not implement all of this(for example, some provers do not know anything about files; others identify theories and files), and some provers may provide richer notions(for example, nested proofs or generic proofs) which are not captured in pgip.



the ideas behind the pg kit system architecture have been outlined above. the architecture is described in more detail elsewhere[6,8], including xml schemas(written in relax ng) for the pgip and pgml languages. this section describes our prototype implementation of the design.



events contain pgip messages. to model pgip faithfully in haskell, we use haxml. from a given dtd, haxml generates a series of haskell datatypes, one for each element, along with functions to read and write xml. the advantage is that the type security given by the dtd extends into our program, making it nearly impossible to send messages containing invalid xml, and detecting the reception of invalid xml immediately. the broker does further validation on the messages, but it tries to be a robust as possible;



display message events(dispmsg) contain messages to be displayed, such as a new proof assistant state, error or warning messages. display events are generated by the event broker from proof response events, or as an answer to user input(e.g. trying to browse beyond the end of the history).



to allow for the possibility of divergence, we must be able to interrupt the prover. presently, the prover is run in a child process on the same machine, so we can use signals. for a distributed setup where the prover may run on another machine, we will need provision to transmit out-of-band interrupt signals, for example by running the prover as child process of the process listening on the actual socket.



all display engines, even such seemingly different ones like emacs and pgwin, serve to visualise display messages originating mainly from the event broker. crucially, display messages and user input may refer to earlier messages. for example, in later proofs users will usually want to use theorems they have proven earlier.



in order to subsume different display engines in a uniform framework, we use the notion of an object as introduced by the generic graphical user interface(see sect. 3 above). an object is anything the system needs to keep track of: most prominently, theories, theorems and ongoing proofs, but also auxiliary objects such as tactics, rewrite rules, and so on. objects are typed. types comprise basic types(such as theories, theorems, and proofs), and prover-definable types(such as the auxiliary objects, which vary from prover to prover). each display must visualise at least the basic types, but may not



notice that implementing a notion of object within the interface allows us to keep context information with objects which specifies dependencies: effectively, a position within the linear pgip protocol. this means that the user can switch between open proofs, for example, by selecting objects with the mouse. behind the scenes the theory might be switched by aborting the currently open proof and closing its theory and file, before opening the file and theory of the newly selected proof. this is why displays must support outdating and updating operations on objects: if an earlier definition is undone, or an ancestor theory is retracted, all dependent objects will be outdated by the broker, and marked as temporarily unavailable in the interface.



the other piece needed for our prototype implementation is some proof assistant itself. by design, we want to interface with existing theorem provers with minimal effort, but recognising that they will need some customization. an experimental effort to pgip-enable isabelle/isar has been undertaken, with the help of the isabelle development team. the implementation consists of a 500-line extension to the existing standard ml module for interfacing with proof general that is already supplied with isabelle. there have



this paper has described the concepts underlying the synthesis of the proof general and isawin interfaces into one combined interface. the new interface has an event-based architecture based on the pg kit, and consists of several components communicating in the pgip proof protocol. the implementation of a first prototype of the pg kit architecture has led to a many clarifications and extensions of the pgip protocol; more are planned. the system comes with a new user interface, which allows a mixed graphical and textual interaction, combining the advantages of both proof general and isawin. moreover, the open architecture opens the way to more easily implementing new interaction mechanisms, and developing a truly generic high-level interface.



the omega prover started as a framework to integrate different automatic provers. it has developed into mathweb, which uses the xml format omdoc as an exchange language, and the activemath project, which is a learning environment based on omdoc. omega has a user interface, loui, but it is not generic in our sense; mathweb uses style sheets for visualisation. nonetheless, the system architecture is not unlike ours: components



prosper uses another approach to interoperability, aiming at connecting different automated proof tools together: at the core of the system an lcf prover kernel is used to guarantee logical consistency. tools are wrapped up as components, using the prosper integration interface. although this is a more logic-centred view, with an emphasis on the exchange of proofs and theorems, there are interesting similarities to our architecture: again, a light-weight customised middleware architecture implemented in a functional language and a central broker component with provers(and other tools) connected by loose coupling.



