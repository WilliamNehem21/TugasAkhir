this paper presents a high-level, visual service creation environment(sce) for web services. the sce introduces two main concepts: services and composition templates. composition templates are abstract descriptions of reusable compositions containing several placeholders for services. services are verified to be compatible with the composition template when a service is mapped onto a composition template. the sce supports the modularization of crosscutting concerns using both the general-purpose aop language padus and several concern-specific languages. aspects can be visually deployed on a target composition template or service, which automatically triggers the weaving process.



over the last years, web services have been gaining a lot of popularity as a means of integrating existing software in new environments. basic web services can be created by exposing existing applications to the internet using xml front-ends. by composing a number of basic web services, new web services can be created that provide more advanced functionality. these compound web services can then be used by other web services, further improving software reusability.



originally, the only way to compose web services was by manually writing the necessary glue-code in programming languages such as c and java. it quickly became clear, however, that a composition of web services is more naturally captured by dedicated workflow languages than by general-purpose programming languages. today, the most popular workflow language with regard to the composition of web services is the business process execution language(ws-bpel). wsbpel processes are platformand transport-independent, and are expressed using xml. recently, a higher-level visual notation for ws-bpel, called the business process modeling notation(bpmn), has been proposed.



the outline of the paper is as follows: section 2 explains the motivation for the sce, and section 3 provides an overview of the sce architecture. next, the support for concern-specific languages in the sce is presented. section 5 describes related work, and section 6 states our conclusions and future work.



the current state-of-the-art is insufficient for supporting the envisioned sce. typical workflow languages(such as ws-bpel) provide visual guis in order to facilitate the creation of workflows. however, these guis are nothing more than a visual interface on top of the language. examples of such guis are bpws4j and oracle bpel designer. there is no support for guiding the service composition process to a correct service composition. furthermore, management concerns still have to be encoded in the workflow itself, which results in a workflow that is tangled with several secondary concerns, and as such makes the resulting workflow more complex. in the next section, we introduce our sce and show how the above stated objectives are met.



in this section, we first introduce the architecture of our visual sce. secondly, we explain how the sce supports aosd. next, the gui of the sce is presented, followed by an explanation on how services can be composed, on how service compositions can be verified, and finally, on how services can be deployed.



another repository contains a set of documented composition templates. these templates are specified in ws-bpel. the templates are abstract descriptions of web service compositions and may contain one or more placeholders for services. the composition templates can be instantiated by filling in the placeholders with different services. when services are added to service composition templates, the sce checks whether the protocols of the services are compatible with the protocol of the service composition template.



the sce supports the modularization of crosscutting concerns through the padus language. padus is our aspect-oriented process language based on wsbpel. a detailed explanation of padus is outside the scope of this paper. we only introduce and explain the features of padus relevant for the sce and for defining concern-specific languages.



padus is an xml-based language, and introduces two main concepts: aspects and aspect deployments. an aspect is a reusable description of a crosscutting concern, and contains one or more pointcuts and advice. a pointcut selects interesting points in the execution of the target ws-bpel process(called joinpoints), and exposes target objects to the advice. the pointcut language of padus is a logic language based on prolog, and is thus very expressive. the complete target wsbpel process is reified as a collection of facts that can be queried by the pointcut. the advice language is ws-bpel, extended with some aosd-specific constructs. the padus technology is based on a traditional static weaver that processes the target ws-bpel processes and generates new ws-bpel processes containing the advice code as specified in our visual environment. the main advantage of this approach is the compatibility with existing infrastructure, as the output can be deployed on any ws-bpel-compatible engine.



when the composition is complete and verified, the user may choose to generate the resulting composition and deploy it on a ws-bpel engine. this will start the code generation process, which will bind the unbound partner links in the composition templates. an aspect deployment is automatically generated for the aspects contained in the composition. the padus weaver is then employed to weave the aspects into the resulting ws-bpel processes based on the aspect deployment specification. a resulting composition can also be imported back into the library as a new service. the generated ws-bpel process then serves as documentation for the new service. apart from specifying a name and some other properties, this process



the sce also includes a built-in ws-bpel engine that can be used to immediately execute a resulting composition. this feature is meant to be able to quickly assess the result rather than to be the real deployment target. we are currently working on improving the integration of this engine, so that it can be used as a debugger for compositions by providing feedback directly to the sce.



for expressing the aspect of data serializability in distributed environments. a recent concern-specific language is kala. kala is a powerful aspect language for describing the use of advanced transaction models by an application, which also allows new models to be defined if needed. however, since a new language has to be devised for each concern, construction of concern-specific languages was quickly deemed too costly. instead, more approaches opt for general-purpose aspect languages, such as aspectj.



our objective is to enable the definition of concern-specific languages on top of the padus technology and integrated in the sce. the implementation of a crosscutting concern is thus defined in a specific csl, built on padus. to apply the concern to the service process or service composition process, a user can select the relevant aspects, add them to the service process and concretize them.



we recognize two important patterns in the billing concern. on the one hand there is the issue of when billing starts and ends. on the other hand there is the issue of what should be charged. in our approach we separate these two parts. our dedicated billing language selects the points in a process execution where billing starts and ends, and allows us to add extra behavior at each of these points. typically, we pass the information about the operation and associated timestamps to a dedicated charging service. this service keeps a complete log of all charged events. at a later time, a program may collect these logs and create bills for the customers, possibly affected by business rules. this is the issue of what should be charged, and can greatly vary on the context of the events. therefore, the billing csl exposes the context of the process events to a large extent.



the main element of a billing module is the concern element. its attributes specify the language and the type of the module. in our example, line 1 specifies that the module is specified using the billing language, and that its type is time. modules that are expressed using another concern-specific language would also contain a concern element, but its language attribute would indicate that another language is used, and that its contents are thus different than those of a billing



there are three types of billing modules: event-based modules are used to perform billing based on events that occur during the execution of a service(e.g., when a text message has been sent), time-based modules are used to perform billing based on the time that has passed between two events(e.g., between the start and the end of a telephone call), and data-based modules are used to perform billing based on the volume of data that has been exchanged between two services.



the children of the concern element specify when billing should occur, and what should be charged. because our example is a time-based module, it specifies both when billing should start(using the start element in line 4) and when billing should end(using the end element in line 5). the when attributes of the start and end elements are padus pointcuts that select certain points in the execution of a service.



bpmn is a graphical notation for specifying workflows, and aims to become the de facto graphical standard similar to ws-bpel for workflow languages. bpmn allows for a higher-level graphical notation for processes in comparison to wsbpel, and is in fact complementary to our approach. a bpmn-based editor that is able to import/export ws-bpel can for instance be used to edit the specification of a composition template. as soon as there is a standardized file format for bpmn, the sce can also directly support bpmn for the documentation of services and composition templates, instead of or next to ws-bpel.



several approaches exist that focus on the construction of concern-specific languages, also referred to as domain-specific languages. note that these languages do not have facilities for encapsulating crosscutting concerns and are hence not aspect languages. such approaches provide environments for the more efficient and scalable construction of languages fit to express concepts from a particular domain. examples are draco, genvoca, babel and intentional programming. agarwal et al. present a service creation environment based on end-to-end composition of web services, but this environment does not allow visual composition



in this paper, we present a high-level service creation environment for composing web services. our approach supports the modularization of crosscutting concerns through padus aspects. padus aspects can be visually deployed onto composition templates or services. furthermore, support for concern-specific languages on top of padus is available.



our approach supports visually deploying aspects onto concrete services. the pointcuts still have to be defined programmatically in padus. describing pointcuts at a higher level of abstraction would be an important contribution to our work. we are experimenting with existing pointcut visualizations such as theme/uml, join point designation diagrams[30,29] and aosf to solve this problem.



the support for integrating concern-specific languages is currently quite limited. apart from a set of common tool(such as xml parsing and transformation tools) and a simple visualization template, defining and implementing a new concernspecific language still largely happens in an ad hoc manner. a more in-depth solution based on existing work(such as babel) is subject to future work.



