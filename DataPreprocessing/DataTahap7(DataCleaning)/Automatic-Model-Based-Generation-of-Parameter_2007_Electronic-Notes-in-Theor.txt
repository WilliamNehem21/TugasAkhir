test cases can be generated either from a test model, i.e. a model of the test suite, or from a model of an iut. in the first case, test cases are designed separately from the model of the iut, for instance using frameworks like the uml 2 testing profile. this leads to well-tailored test cases, but might also double the modeling effort during development. in the second case, the existing models of the iut are examined by a test case generator. model-based test generation is well-developed for conformance testing, which aims at checking whether an iut conforms with its specification[22,33].



given the specification of an open system, we apply data abstraction which has already successfully been applied to model-checking open systems(e.g.) to obtain a(finite) abstract system. from the abstracted system, we generate a set of abstract test cases. the generation of these test cases is guided by a test purpose, which defines the scenario of interest. the produced abstract test cases contain abstract data that should be concretized prior to test execution.



to instantiate abstract test cases with concrete data, we employ constraintsolving. in parallel to test generation and abstraction we transform the original specification into a rule system, which is used further for data selection. the test suite is transformed into a test oracle in order to retrieve test data. we use the data to instantiate the test case and execute it. while being executed, the iut might diverge from the selected path. by online constraint-solving, we dynamically adapt the course of the test execution.



of conformance testing. in section 3, we describe the syntax and semantics of the specifications, we are working with. preliminaries for constraint-solving are given in section 4. in section 5, we describe our approach for data abstraction, followed by the explanation of test generation in section 6. we applied our approach to a case study, which is described in section 7. finally, we conclude with section 8. full proofs for the lemmata in this paper can be found in.



the closest to our approach is symbolic test generation[8,14,23,29,36]. this method works directly on higher-level specifications given as input-output symbolic transition systems without enumerating their state space. given a test purpose and a specification, their product is built. those works are founded on the ioco theory. the coreachability analysis is in these cases over-approximated by abstract interpretation. the concept of test generation with verification techniques(tgv,) is also based on ioco.



test data determination for whitebox testing has been discussed in several recent papers[16,31,34]. they are mainly based on the technique of symbolic execution[9,24]. the constraint rule systems that we generate to determine test data, are comparable to, where also constraint rules are generated encoding the visible inputs and outputs, guards and internal state changes. these rules are used to generate a set of test cases by transforming a whole system specification into prolog. however, test cases are already present in our case and the rule system is only needed to find concrete test data.



our approach is based on conformance testing that validates whether an implementation conforms to its specification. in a theory of conformance testing, the notion of conformance is formalized by a conformance relation between specification and implementation that are assumed to be input output labeled transition systems(iolts s). in this paper, we refer to a variant of the theory, described in. quiescence is not discussed here.



set of inputs labspec by building the synchronous product of mspec and mtp. the ctg may contain loops and choices between several outputs in the same state or between inputs and outputs. for this reason it is not controllable, i.e. the tester can for example not autoatically decide whether to expect an input from the iut or to send an output to it.



the sets of actions act and communicating actions comm are necessary to declare the actions and communication issues necessary for the process definition. however, we will not discuss them here in detail. the process itself is defined as proc in terms of linear process operators. to enable a graphical representation, however, we give a definition of processes based on the theory of symbolic trantion, it does not limit our approach. the realization of our approach works on linear process operators. for these, existing linearization techniques can be used to obtain a single process definition for a parallel composition of a finite number of process definitions by eliminating communication and parallel composition.



a constraint solver solv() for a constraint domain d is a decision procedure that takes as an input a constraint c and returns either true, false or unknown. whenever solv(c) returns true, c is satisfiable. whenever solv(c) returns false, there is no solution for c and c is unsatisfiable. the value unknown indicates that a solution might exist, but could not be determined.



we do not make any assumptions about the environment of an iut, i.e. we take the most general one. signals coming from the environment can thus have any value. this often boosts the state space of the system to infinity. we abstract denoted t. values that are not influenced by the environment remain the original ones, and so they should be treated in the same way as in the original system. this data abstraction was first proposed in for model checking open systems. a system obtained by this approach is a safe abstraction of the original one, meaning,



the transformation of the process specification consists in lifting all variables, expressions and guards to the new sorts. each occurrence of a variable x of sort s, is substituted by a variable xt of type s t where s t is a safe abstraction of sort s. each occurrence of an expression e of type s is lifted to the expression e t of sort s t. thereby, all the newly introduced symbols(constructors and rewrite rules) are used and replace the original ones.



m t can receive only t values from environment, so the infinity of environmental data is collapsed into one value. basically, the transformed system shows at least the traces of the original system where data influenced by environment are substituted by t values. this means, that m t simulates m. this simulation relation is now defined for concrete and abstracted iolts s. it is not a standard relation, since we allow the abstraction of actions. further, we give an overview of preservation results based on[21,20].



in this section, we describe the approach of test selection and execution with data abstraction. first, we give an algorithmic overview of the whole process. then, we describe how the necessary rule system is built and how test selection and execution work. finally, we review our approach and prove the soundness of verdicts assigned to a test execution.



a parameterizable test case may contain traces introduced by data abstraction. moreover, information about the relationship of symbolic variables or concrete values they can be substituted with is absent. to sort out spurious traces and to obtain valuations for symbolic variables, we employ constraint-solving.



no guards are specified for inputs. the action parameters param are given by the expression e for an output, or by a variable y for an input action, while internal actions have no action parameters. finally, input and internal assignment actions change values of variables. this change is noted in the second state parameter of the respective rule.



in an iut, nondeterminism may be induced, for instance, by interleavings of the behavior of single components. in these cases, it is possible that during test execution the iut leaves a trace to pass which had been calculated beforehand and which is in principle a valid trace. test execution then has to be adapted dynamically to the new situation.



proof sketch: given a finite trace, the algorithm always analyzes the next step in this trace. if there is no next step, i.e. the end of trace is reached, the algorithm terminates with pass or none, resp. if the verdicts fail or inconc are assigned, the algorithm already stops without having reached the end of the trace under consideration. the lemma is proven by pointing out the exit points of the algorithm and the according assignments of verdicts.



an interesting aspect, especially from a practical viewpoint, is the generation of test cases directly from uml specifications, as it has been proposed in[2,26]. as a future work, we aim to adapt our approach for uml-based test case generation. doing so, the target language of test case generation is ttcn-3(testing and test control notation, version 3), a standardized test specification language, widely accepted by the industrial community.



