modern integrated development environments(ides) provide programmers with a variety of sophisticated tools for program understanding and manipulation. in addition to such basics as syntax highlighting and project building, these tools commonly offer refactorings and program visualization components. many of the techniques developed for ides can be transferred directly to the world of uitps. others can be modified to exploit the special nature of theorem provers.



the idea of transferring ide techniques to theorem provers is not new[2,7,21,36]. however, there have been significant advances in ides in the last decade. many of these advances have been motivated by the needs of developers who must maintain and extend large bodies of existing code. the increasing complexity of real world programs means that even an experienced programmer will struggle to understand



as automated theorem proving matures, the proportion of old proofs to new as well as their size will continue to grow. tools to visualize, understand, and automatically change these proofs will become vital. integrated proof environments(ipes) 5 should incorporate these tools in the same manner as ides.



each component is associated with its corresponding component in the adjacent panel. examples of proof script components are definitions or theorems with tactics, examples of proof components are definitions or proofs, examples of components in an extracted program are definitions of types or functions. corresponding components are automatically aligned as the user focuses on different areas in the proof script or extracted program. light gray is used for portions of the proof script that are not incorporated into the proof such as directives to the proof engine or comments. narrow gray bars are also used to separate proof and program components. pale blue indicates that a component has been generated indirectly from a component in the proof script. in this example, some induction principles for the list type have been automatically generated. some components of the proof do not have corresponding components in the extracted program. in this case the adjacent separators are merged in the program pane.



a refactoring is a way of restructuring a program so that the overall organization of the program is improved but the behavior is unchanged. where large parts of a proof have been developed separately, refactoring may be necessary to make common the underlying assumptions of the different components. refactorings may also facilitate proof reuse. while modern ides offer extensive support for automatic refactorings[30, 37, 38] uitps offer very little. ides offer support for renaming of functions and variables; uitps should offer a similar facility for renaming lemmas. ides offer facilities for restructuring programs; for example, a local variable may be converted to a field in a java class definition. in the same way, uitps should offer facilities for restructuring existing proof scripts; in coq, for example, a user might wish to encapsulate a group of proof entities within a module. in the eclipse java ide, a developer can generalize the type of a field, lifting the field to its supertype and changing all uses of the field appropriately. similarly, uitps should offer refactoring support for abstracting over definitions and hypotheses. many other refactorings are likely to be dependent on the logic and organization of the individual proof assistant.



we have described a number of ways in which techniques developed to assist programmers in maintaining and extending large programs can be of use to proof developers who must maintain and extend large proofs. many software projects involve a considerable number of people working over several years. as the discipline of automated theorem proving matures proofs of similar size and complexity, which are now considered extraordinary, will grow more common. program extraction is gaining acceptance as a technique for developing programs which must be correct. as these trends continue, the tools we have described will become more and more valuable to proof developers.



proof script, its associated proof, and the derived program. it is clear that this data is available. the relationship between the entities in a proof script and its corresponding proof must be calculated by the proof engine that develops the proof. similarly, the relationship of the terms in a proof to the corresponding terms in the extracted program must be calculated by the program extraction mechanism. the difficulty does not lie in establishing these relationships but rather in recording them and displaying them in a useful manner.



on the other hand, work in this area may yield significant theoretical insights. the refactorings described in section 3.2 are all quite straightforward; just a bit more sophisticated than textual replacement. some program refactorings are much more ambitious. for instance, tip et al. describe a refactoring from java programs that do not exploit a polymorphic type system to ones that do. more ambitious refactorings for theorem provers could very well yield unexpected insights.



