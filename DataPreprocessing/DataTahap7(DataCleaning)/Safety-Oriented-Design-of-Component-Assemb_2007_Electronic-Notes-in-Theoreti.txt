this paper promotes compositional reasoning in the context of safety-critical systems, and demonstrates a safety-oriented component model using an application from the automotive industry: an adaptive cruise controller(acc). the application consists of four components for which a set of 18 fault modes have been identified. we show the impact of all single faults and double faults selected from this set, on a safety property associated with the acc assembly. analysis related to each fault mode is performed using compositional rules and derived safety interfaces for each component.



reasoning and the automatically generated interfaces. the component model uses reactive modules as the formal notation. the instantiation of the model in terms of modules specified in scade provides a link between formal analysis of components in safety-critical systems and the traditional engineering processes supported by model-based development.



component-based software development[32,8](cbsd) has emerged as a promising approach for developing complex software systems by composing smaller independently developed components into larger component assemblies. this approach offers means to increase software reuse, achieve higher flexibility and shorter timeto-market by the use of off-the-shelf components(cots). however, the use of cots in safety-critical system is highly unexplored.



first, system safety engineers need to present arguments that justify dependability of the system, based on any information available from the cots. typically cots are not developed with generation of such arguments to certification authorities in mind. specially, whether or not fault tolerance in components affects system properties, is not currently part of component interfaces. secondly, the process that leads to this assurance needs to be rigorous, efficient, and easily applicable for upgrades at a later stage of the system life cycle. thus, support for rigorous, compositional analysis from components to assemblies, and with specific focus on faults that can jeopardize system safety is a relevant area of work[16,26].



following the trend of software components in system development, the use of critical software in complex safety-critical systems has increased. since safety has to be addressed at the system level, an overall analysis of the component assembly is necessary. this implies that effect of possible component failures must be analysable as foreseen hazards at the system level. also, for efficiency, there is a desire not only to reuse components, but also to reuse analysis results upon future upgrades. the use of formal models and analyses is generally accepted as a means of rigorous safety assessment in software[33,31]. however, as of now, no industrial tools exist for assessing dependability in a system built from components.



during recent years, a wide range of models and methods for developing systems from components have emerged[6,11]. in particular, an analytical component model has been presented that provides the means for reasoning about system safety, by reasoning about known component behaviour in presence of specified faults(i.e. safety interfaces). this work is built on the component model presented therein. by generating safety interfaces of components, the component developer may specify the effects and the assumptions needed for the component to be resilient to specific faults. this characterises how a component might contribute towards jeopardizing a given safety property at system level. the framework has so far been applied to an aerospace application with only boolean variables in the esterel studio tool set.



in this paper, we apply the proposed technique to a non-trivial case study, namely an automotive adaptive cruise controller(acc) with non-boolean variables. in order to cope with the analysis on integer functions we utilise the tool set scade. a methodology for building fault mode libraries in order to use this method efficiently is illustrated. we have also implemented parts of the framework as a front-end to scade for generating safety interfaces. this application illustrates the possibility of reuse of previous partial analysis results in future upgrade scenarios.



the paper is structured as follows. in section 2 we present some basic definitions and recall our earlier work upon which the rest of the paper builds. in section 3, an overview of the acc case study is given. section 4 presents the methodology for use of fault mode libraries and the front-end to scade. in sections 5 and 6, the activities seen from the two perspectives(system developer and component developer) are described and the result of the analysis is presented. section 7 presents related work while section 8 concludes the paper.



faults in the environment of a component are modelled as faulty inputs to the component, and each such faulty input creates a fault mode for the component. the input fault of one component thereby captures the output fault of a component connecting to it. by using modules as means of modelling fault modes, the fault modelling is only limited by the expressiveness of modules. various fault mode classes can be derived by specifying the corresponding fault modules. in traditional safety analysis, faults can be classified into the following high-level categories: omission faults, value faults(coarse and subtle), commission faults and timing faults[4,13]. in this work, we do not focus on timing faults and our work does not include the process of determining fault modes, and hazard analysis, which is itself a different research topic. fault modes are assumed as given, and the result of the analysis is knowledge about the potential impact of a given fault on a component assembly.



contrained environment: the normal case when the eag-algorithm terminates with a constrained environment. the generated environment abstraction together with the specific fault is added to the safety interface. the special case when the generated environment abstraction has no traces indicates that the component is not tolerant of this fault no matter in which environment it is placed. this is a valuable knowledge for the component developer.



in this section we introduce an automotive application to illustrate our methodology; the adaptive cruise control(acc)(informally described in). beside its safety and real-time aspects, the case study is particularly interesting because structuring and reuse is of importance in competitive industries today, especially the automotive industry. however, we are well aware that such formal safety analysis is only a small part of the puzzle that corresponds to developing complex automotive electronics in a competitive market.



the acc is an extension of the conventional in-vehicle cruise control function that can be found in most cars today. as well as the traditional functionality of a cruise control, i.e. adapting the vehicle to a specific speed set by the driver, the acc may also adapt the distance to a vehicle in front or adapt to the current speed limit of the specific road section.



if the acc application discovers a target vehicle in front of the own vehicle, the acc will adapt the speed of the own vehicle to ensure a safe distance to the target vehicle. if the target vehicle disappeares, the acc will work as a conventional cruise control. for safety reasons, the driver should at any time be able to take control of the car by braking or using the throttle.



a part of the preliminary safety assessment procedure is to identify, as far as possible, faults in the system and evaluate their impact as described in section 2. for example, each triggering signal can be effected by an omission or commission fault. every variable can be effected by a value fault, i.e. an unintended change in the value of the signal. more specifically, signals can get stuck at a certain value giving rise to a stuckat-fault.



existing tools with an ambition to support component-based development are mainly based on uml 2.0 which is promoted for representing and describing(software) components. however, none of these tools supports automatic derivation of any kind of interfaces. this section introduces an overview of our safety analysis methodology and presents an approach to aid the component developer in this process.



in order to make the system-level safety analysis possible, the component developers must supply the system integrators with a model of a component including a safety interface. one method for generating the safety interface was introduced in section 2. however, the iterative generation of the environment abstraction is in practice too tedious to do manually since it may involve placing a very large number of constraints on the environment. to make the process of generating safety interfaces efficient, some tools are necessary to aid the component developers in this process. several tools are being extended to handle component(interaction or functional) interfaces, e.g. autofocus, matlab. our focus here is the interfaces specific to fault tolerance and safety.



the whole acc system and its four components were divided into 12 scade nodes which can be translated into over 2000 lines of automatically generated c code. the front-end to scade and the fault mode library were both used to generate safety interfaces for the four acc components. in this section, we will present the development and the safety interface generation of the modeswitch component.



for complex systems such as the acc, it is difficult to reason about its impact on safety, especially in presence of faults in the multiple(upgraded) components. assume-guarantee reasoning is one method for handling manageability and scalability of complex systems. this section presents a technique that enables the system integrator to perform system level safety analysis based on component models.



the system integrator checks whether the fault fj is in the safety interface for any component that has an input affected by fj. all single faults in f that do not appear in single in the safety interface of the relevant components will actually be a threat to the overall system safety in relation to the safety property under study. in the case of the acc, we present here the application of the rule to the 4component assembly in presence of fault f1. let mm,ma,ms,mo represent the m odeswitch, the accctrl, the speedlimit, and the objectrecognition modules



when two single faults appear simultaneously, they create a double fault. if both of these faults affect the same component, then the system level analysis of this double fault is handled analogously to single faults, except that the double element is used instead of single. however, when the individuals in a double fault affect two different components, the safety analysis process becomes a bit more complex.



using modular verification techniques within component assemblies is an active area of work. for example, in system properties are proved by independent model-checking of a group of small state spaces with the help of interface automata. however, their work focuses on communication protocols while abstracting away from the data values being communicated. similarly, chaki et al present methods for finite state abstractions of low-level c components. the approach of is related to ours in terms of environment assumptions. they present a model checking algorithm for linear transition systems that returns an assumption that characterizes exactly those environments in which the component satisfies the property. our work can be considered as extension of that work to analysis of fault tolerance by considering environment faults as input to the analysis.



this paper illustrates a component-based safety analysis framework with the help of formal models and tools to support the process. our work shows promising results on an automotive application with 4 non-trivial components and 20 fault modes. we show how the component-based methodology can be cast in terms of models underlying traditional engineering processes by illustrating the extension needed to apply the method with the scade tool set, namely analysis front-end and fault libraries.



however, more work needs to be done towards a more efficient method of generating safety interfaces and refinement checking. also, employing such techniques in development environments that are specifically built around the notion of components is worthwhile to pursue. more advanced methods for analysing environment constraints could also be useful to increase the possibility for component developers to find design flaws early in the development process.



this work was supported by the swedish strategic research foundation(ssf) project save, and the national aerospace research program nffp. the authors would like to thank marius minea and lars grunske for comments on earlier drafts of this paper. we would also like to thank the anonymous reviewers for their valuable input.



