for many software analysis tasks, however, the functional approach is too restrictive. first, specifications are often non-deterministic, thus allow one-tomany associations of elements. determinism of programs is usually established in a refinement process. non-determinism is even an essential feature of concurrent or reactive systems. second, functions are not entirely satisfactory for modeling the semantics of predicate transformers or of analysis formalisms like dynamic or temporal logics or the mu-calculus. it is therefore desirable to generalize from functions to relations. in fact, relations form the backbone of formal methods like b or z in software development. but how to visualize relational reasoning?



the strength of our approach, however, consists not solely in the visualization of algebraic axioms by a sound and complete diagrammatic calculus, but also in intuitive and powerful derived rules for transforming and(de)composing diagrams, while preserving some interesting properties. we introduce rules that capture the typical informal diagrammatic style of rewriting theory. our considerations in the general setting of semi-commutation, however, increases their domain of applicability to relational software development with methods like b or z. the idea of transferring diagrammatic techniques from rewriting to software engineering is probably novel. several examples from rewriting theory and concurrency control support the usefulnes of this approach.



the general merits of relational diagram chase in rewriting are beyond any doubt: it is the standard way of reasoning in this area. diagrams show the essence of proofs while hiding boring technical details. proofs by diagrams are informally rigorous in contrast to the formally rigorous proofs from logic or algebra. our examples show that the present approach unifies both kinds of rigor in one simple and convenient formalism. in a corresponding formal method, a proof engineer might first sketch a proof using diagrams and then incrementally refine it using our derived rules. the underlying algebraic semantics paves the way to a simple mechanized verification of the diagrammatic arguments. the approach is open in the sense that further diagram rules can easily be defined and verified by the user.



in this paper we try to informally motivate the main ideas behind our diagrammatic calculus and to illustrate them by examples. theoretical results about kleene algebras and related theories can be found in the literature[14,6,9]. an implementation of the calculus and an integration into a formal method is left for future work.



the remainder of this text is organized as follows: section 2 shows how rewriting diagrams can be used for modeling meaningful properties of concurrent systems and processes. section 3 proposes an algebraic semantics for semi-commuting relational diagrams. section 4 presents transformation and preservation laws for diagrams. sections 5 and 6 introduce diagrammatic induction techniques and examples. section 7 gives diagrams and techniques for coinduction. section 8 and 9 further discuss the results, draw a conclusion and suggests some future work.



this turns the labeling algebra into a monoid with unit 1 and element 0 that satisfies the annihilation laws 0a=0= a0. some applications suggest to drop a0= 0. when a is always non-terminating, one might want that ab= a for all b and in particular for b= 0; a conflict. see for a deeper discussion.



the second rule can be obtained by exchanging solid and dashed lines. using these rules and the splitting rule, we can derive another rule for commuting diagrams that has the same shape and in which all lines are solid. there are further derived diagram rules for combinations of commuting and semicommuting diagrams that can be derived from the fundamental rules using the splitting rule. for the sake of brevity we present them using path expressions.



the second rule can again be obtained by replacing solid and dashed lines. a corresponding rule for commuting diagrams follows immediately from those for semi-commutation and the splitting rule. further derived rules handle again the combination of commutation and semi-commutation. they are



our derived transformation and composition rules formalize the essence of diagram chase in rewriting theory, but generalized to the setting of semicommutation and with an underlying abstract algebraic semantics. diagram chase is usually far more convenient for a human than performing the detailed underlying algebraic manipulations(except for sectarians of idempotent semirings). the simple formal semantics of the present approach yields a coincidence of these opposites.



the last step in the chain of implications(and the first step in our backwards proof) uses the star induction law as a star elimination rule. the remaining step is by denesting and yields two new goals. the first goal follows immediately from the star unfold diagram and denesting. the second goal is one of our previous regular diagrams, which we do not analyze any further. the underlying proof in kleene algebra can easily be recovered. the entire goal could as well be handled effectively by the decision procedure for regular expressions.



therefore, at the present stage, the main task is the design and implementation of a graphical front-end that allows the explicit manipulation of diagrams, supports user-defined transformation rules and enhances a transition between algebraic and diagrammatic reasoning. a main question is proof presentation. at first sight, its seems most natural to modify diagrams successively on the screen by applying transformation rules in a drag an drop style. the concrete realization of such a tool is left open.



