in the former approach programmers can write fragments of code(classes in the case of java-like languages) which are not self-contained, but depend on other fragments. such dependencies can be later resolved by combining fragments via composition operators, to obtain different behaviours. these operators form a composition language. inheritance(single and multiple), mixins and traits are all approaches allowing one to combine classes, hence they define a composition language in the sense above.



the paper is organized as follows: in section 1 we informally introduce our approach by means of some examples, in section 2 we provide a formalization on a very simple class composition language, and in section 3 we summarize the contribution of the paper and draw related and further work. the appendix contains the proof of soundness. this paper is the full version of.



in order to show how to use meta-programming as a tool for better composing software, we introduce a language allowing one to compose classes by means of some operators. in such a language, a class declaration associates a class expression with the name of the declared class. the simplest form of class expression is the base class, that is, a set of field and method declarations. for instance, the literal



the first four rules define the subtyping relation. note that, since a class definition can contain many class names as subterms 11, in our generalization a class can be a direct subtype of many others. however, method look-up function mbody gives precedence to the left operand as in standard fj.



rule(meta-red) models a(safe) meta-reduction step. indeed, meta-reduction is only performed w.r.t. a conventional program cp which has been previously successfully typechecked. note that, here as in the following two rules, there can be another portion of the program cp' which has already been reduced, but for which it is still impossible to perform a conventional typechecking step. this happens when cp' refers to some class names whose definition is still unavailable, see the first example in the following.



the meta-level. that is, the first class declaration in the program which is not annotated yet is examined, to check that its right-hand side e is a well-typed metaexpression. the expression is typechecked w.r.t. the portion of the conventional program cp which has been already successfully typechecked. if the typechecking step succeeds, then the class declaration is annotated code. otherwise, an error is raised only if it is not possible to perform a further conventional typechecking



compile-time execution checks that class c is well-typed. note that it is not possible to check class d since it refers to class e that has no associated class expression yet. hence, expression new c().m() is checked to be of type code. at this point, reduction of this expression can take place, and finally the resulting class d is checked to be



compile-time execution checks that class c is well-typed, and then checks whether the expression new c().k() is of type code. this is not the case, since class c has no methods named k. moreover, because no standard typechecking steps are possible, since there are no other classes, an error is raised.



compile-time execution checks that class c is well-typed, then checks that the expression new c().m() is of type code, then reduces this expression. finally, the check that the resulting class d is well-typed fails since class c has no methods named k.



metaprogramming approaches can be classified by two properties: whether the meta-language coincides with the conventional language(the so-called metacircular approach), and whether the code generation happens during compilation. metaml, prolog and openjava are meta-circular languages, while c++, d, meta-trait-java and morphj use a specialized metalanguage. 14 regarding code generation, metaml and prolog performs the computation at run time, while c++, d, meta-trait-java, morphj and openjava use compile-time execution. the work presented in this paper lies in the area of metacircular compile-time execution.



among the above mentioned approaches, is the one showing more similarities with ours. in openjava, programmers can add new language constructs on top of java, and define the semantics of these new constructs by writing meta-classes, that is, particular java classes which instruct the openjava compiler on how to perform a type-driven translation into standard java. these meta-classes use the reflection-based meta object protocol(mop) to manipulate the source code. in the same way it is even possible to change the semantics of standard java language constructs. a similar capability of specifying within the code instructions for contextual compilation has been recently provided in java 6 by annotations.



however, this approach, besides being lower-level, has a very different goal w.r.t. ours, that is, to make easy for programmers to extend and possibly change the behaviour of an existing language, in rather arbitrary ways. in our case, instead, syntax and semantics of both the underlying language and the language for composing classes are fixed. the programmer is only allowed to define its own derived composition operators by using the whole expressive power of the underlying language. note also that both approaches produce standard java code; however, in our case this code is obtained by an algorithm which interleaves standard java compilation and execution steps, rather than by a unique preprocessing step.



we conclude this summary of related work by a comparison with dynamically typed languages, which very often allow some sort of meta-circular facility, typically by offering an eval function. such a function allows to run arbitrary code, represented by an input string. a more sophisticated approach is supported by groovy 15, a dynamic language, targeting the jvm, that explicitly supports compile-time meta-programming via ast(abstract syntax tree) transformations. that is, the groovy compiler allows to specify custom ast visitors, which can arbitrarily modify the ast before it is turned into bytecode.



