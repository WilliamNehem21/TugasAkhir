xpath is a well-known query language for finding and extracting information from xml documents. this paper shows how the characteristics of this domain-specific language fits very well into the functional-logic paradigm. the proposed framework allows the user to write xpath-like queries as first-class citizens of the functional-logic language t oy, using higher-order combinators for constructing the queries and non-determinism in order to obtain the different answers that xpath queries can return. the result is a very good example of cross-fertilization of two different areas. in the case of t oy, the users can now integrate xml queries in their programs without using any external library or ad hoc interface. in the case of xpath, the use of higher-order patterns allow us to define functions for easily processing the queries. in particular, the paper shows how to trace and debug erroneous queries, and how to detect that a query is a refinement of another query, which can be useful for improving the efficiency of query processing.



in the last years the extensible markup language xml has become the de facto standard for exchanging structured data in plain text files. this was the key for its success as data structures are revealed and therefore they are readily available for its processing(even with usual text editors if one wishes to manually edit them). structured data means that new, more involved access methods must be devised. xquery[21,23] has been defined as a query language for finding and extracting information from xml documents. it extends xpath, a domain-specific language that has become part of general-purpose languages. although less expressive than xquery, the simplicity of xpath makes it a perfect tool for many types of queries. due to its acknowledged importance, xml and its query languages have been embodied in many applications as in database management systems, which include native support for xml data and documents both in data representations and query languages(e.g., oracle and sql server). some of them extend sql to include support for xquery, so that results from xml queries can be used by the more declarative sql language in the context of a database, making possible to share relational and xml data sources.



proposes a rule-based language for processing semistructured data that is implemented and embedded in the functional logic language curry. recently, in, we have proposed an implementation of xpath in the functionallogic language t oy, where a xpath query becomes at the same time implementation(code) and representation(data term). xml documents are represented in this proposal by means of data terms, and the basic constructors of xpath: child, self, descendant, etc. are defined as non-deterministic higher-order functions that can be applied to xml terms.



this paper continues this work, showing that xpath fits very well into the functional-logic paradigm. the proposed framework allows the user to write xpath-like queries as first-class citizens of the functional-logic language t oy. to this end, higher-order combinators are used for constructing queries, and we take advantage of non-determinism in order to obtain the different answers that xpath queries may return. the result is a very good example of crossfertilization of two different areas: in the field of relational databases to our scheme. this refers to the ability of reusing previous cached query results for enhancing query solving performance(section 5). finally, in section 6 we draw some conclusions and point out some future work.



the input arguments of this operator are a string s representing the file name and a xpath query q. the function applies q to the xml document contained in file s. this operator plays in t oy the role of doc in xpath. the xpath combinators/ and:: which correspond to the connection between steps and between axis and tests, respectively, are defined in t oy as function composition: produces a single answer, with r instantiated to a list whose elements are the nodes in"food.xml". xpath abbreviated syntax allows the programmer to omit the axis child:: from a location step when it is followed by a name. thus, the query child::food/child::item/child::price becomes in xpath simply as food/item/price. in t oy we cannot do that directly because we are in a typed language and the combinator./. expects xpath expressions and not strings. however, we can introduce a similar abbreviation by defining new unitary operators name(and similarly text), which transform strings into xpath expressions:



notice that a new function append is used for concatenating xpath expressions. this function is analogous to the well-known append for lists, but defined over xpath terms. this is our first example of the usefulness of higherorder patterns since for instance pattern(a.::.b) has type xpath, i.e., xml the context node x, returning a new context node y. then the if condition checks whether y satisfies the filter f, simply by checking that f y does not fail, which means that it returns some value represented by the anonymous variable in f y==. although xpath filter predicates allow several possibilities, in this presentation we restrict to xpath expressions. multiple predicates can be chained together to filter items as with the and operator, which can be formulated as follows:



one of the most appealing features of our setting is that xpath queries can be manipulated. in this section we use this feature for tracing and debugging queries. we distinguish two types of possible errors in a xpath query depending on the erroneous result produced: wrong queries when the query returns an unexpected result, and missing when the query does not produce some expected result. we present a different proposal depending on the error.



the first rule handles the merged node, assigning the children of the first argument to the second argument whenever they have the same label test. second and third rules are recursive rules for handling steps and filters. third rule accumulates filters by means of the xpath operator/&. the auxiliary functions children, filter and root compute the children and filter of the root, and the root of a xpath expression, respectively. let us now see an example of use. for instance, defining:/*[variety] in the standard xpath syntax. in summary, we are able to use the logic features of t oy for building the compensation of a certain view. currently, t oy is able to solve one of the problems related to compensations: to find them. t oy offers as output a set of compensations when they exist, otherwise fails. to find a minimal compensation is considered as future work of this implementation. moreover, we would like to extend our implementation to cover with compensations to multiple views.





s. schaffert and f. bry. a gentle introduction to xcerpt, a rule-based query and transformation language for xml. in proc. of international workshop on rule markup languages for business rules on the semantic web, page 22 pages, aachen, germany, 2002. ceur workshop proceedings 60.



