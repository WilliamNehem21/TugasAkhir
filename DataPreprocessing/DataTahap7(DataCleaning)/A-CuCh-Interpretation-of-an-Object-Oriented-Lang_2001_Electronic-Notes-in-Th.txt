inheritance mechanisms. classes have been studied either as a primitive construct([20,19,16,30]), or as a combination among extensible objects and traditional data abstraction([27,15]), but they are not as well-understood from a mathematical point of view as objects are instead. in fact, lots of di erent translations of object-based calculi into di erent typed lambda{calculi have been proposed[29,2,14](a detailed comparison of various encodings can be found in), which highlight the mathematical meaning of objects.



we think that a promising step forward in understanding the class concept may lay in further exploring connections between object{oriented and functional paradigms, even though object-orientation was born from the imperative paradigm. in particular, the functional setting we consider, the cuch machine[8,13], o ers algebraic data types and the possibility of de ning functions over disjoint sums of algebras(and hence a natural form of overloading), so it seems a natural setting to be extended in order to model concepts as classes, inheritance, dynamic method lookup and information hiding. starting from bohm's intuition about relationships between the data{driven programming style of the cuch machine and the object{oriented programming style, we will study how to encode object{oriented constructs into the cuch machine, taking advantage of the cuch features as described in section 2. to formalize our intuitions, we introduce a toy class-based language cuch++ which embodies typical features of(untyped) class-based languages and we show how to encode it into the cuch machine. the basic ideas of our encoding is to interpret classes as algebras, object constructors as algebraic constructors, objects as terms of such algebras, and methods as recursively de ned functions, and to take advantage of the possibility of de ning overloaded functions in order to manage overriding and to mimic dynamic method lookup inside lambda{ calculus. as an interesting outcome of our preliminary investigations we have that some of the most common concepts of object{oriented languages, such as inheritance, dynamic method lookup and a primitive form of encapsulation(public methods and private elds) are naturally interpreted in the language cuch.



of our cuch++{to{cuch encoding, but we defer to future work its metatheoretical analysis. in section 5 we will brie y outline how to address the problem of proving a form of correctness for the cuch++{to{cuch encoding. the rest of the paper is organized as follows: in section 2 we hint at the seminal bohm's cuch machine, highlighting those aspects which inspired this work. in section 3, we introduce the syntax and the(informal and operational) semantics of cuch++. in section 4, we explain which basic ideas are behind the cuch++{to{cuch encoding, by illustrating a variation of the canonical



the well-known paper by backus proposed a purely functional language based essentially on combinators, as showed in, as an alternative to imperative programming languages which are related rather to the von neumann's architecture than to problem speci cations. this stimulated a new interest in making functional programming languages rich enough to be employed into the development of concrete applications. particular interest was devoted to embed algebraic data types and relative mappings of algebras within lambda{ terms and this research is still on. a methodology to represent any type of term algebras and functions\iteratively" de ned on that algebras, using second order typed normal forms, was introduced by bohm and berarducci in.



in this section we de ne the syntax of the calculus cuch++. as mentioned in the introduction, cuch++ can be seen as a distilled class-based language, designed with the main purpose to formalize our intuitions about relationships between the cuch programming style and the object{oriented programming style, while keeping in mind the prominent features of class-based languages. furthermore, it also provides a core language for an extension of the cuch machine. to this aim, a preliminary version of cuch++ was implemented.



contains the class de nitions. we choose not to include classes as rst-order entities because this makes easier to deal with class names, which, in turn, make easier de ning the encoding of section 4 where classes are seen as algebras(moreover, this is not a totally uncommon practice 3, see for example). so, an object is generated by applying a new operation to a class name. a class de nition speci es the superclass' class, together with the behavior of its objects by listing the elds and the method names(and respective bodies). a class silently inherits all methods and elds from its superclass. we assume, for the sake of uniformity, that each class has always a superclass, and for this purpose we introduce a top class, the empty class empty, in which neither



super allows the previously de ned code of an overridden method to be referred. super( m has a static meaning(as it has in the most common object{oriented languages, from smalltalk to java), i.e., super( m fetches the body of m starting the lookup from the superclass of the class whose the method containing the super invocation belongs to. we observe that super does not in uence the binding for self;



we assume that the keyword self is only syntactic sugar standing for a bound variable self, i.e., all method bodies b are abstractions of at least the self parameter and so the method bodies we consider in the operational semantics have the shape b0= self:b[self=self].



as remarked in the previous section, even though super is treated in the syntax as if it were an object, it is not really an object in the usual sense: giving the name super as the receiver of a message indicates only where to start the method lookup. so, super denotes a message environment that can be statically determined. with this idea in mind, we assume to pre-process a cuch++ program before executing it, in order to substitute each expression of the form super( m with the expression bmself, where bm is the appropriate method body found up in the class hierarchy. we apply it to self in order to preserve the right host object when the program will be executed.



we use a name convention which links class names in the source language with constructors and names of algebras in the target language(see below the encoding of class de nitions). to distinguish cuch++ programs from their cuch translations, we use a typewriter font for the latter. for the sake of simplicity, we assume that both in cuch++ and cuch usual arithmetic and logical operators(like+,<,=, and abs for absolute value function) are builtin and pre xed. moreover, we freely use in both cuch++ and cuch examples some syntactic sugar such as if b then e1 else e2 statements(if b e1 e2 in cuch).



the data constructor c point(resp. b c point) has arity 2, because each colored point(resp. bidimensional colored point) keeps information about the color(resp. the second coordinate) and the information about the point(resp. the colored point). each canonical element in the algebra c point has the shape c point c(point x) and each canonical element in the algebra b c point has the shape b c point y(c point c(point x)).



we presented an(untyped) object{oriented calculus cuch++ inspired by the bohm's cuch philosophy, and provided a cuch++{to{cuch encoding that takes care of some of the main concepts of object{oriented programming languages, such as classes, objects, inheritance, dynamic method lookup and a primitive form of encapsulation(public methods and private elds). the encoding exploits one of the most prominent feature of cuch, i.e., the data{ driven computation style(supported by overloaded functions), and provides a semantics for cuch++. the cuch++ calculus and the related encoding can then be seen from two orthogonal points of view: asa well-founded class-based calculus, simple yet representative, and as a novel functional interpretation of object{oriented features.



in an untyped scenario, our object encoding may provide an alternative formalization of classes and objects which avoids the use of explicit xed points, as instead in[24,16]. it can be objected that a calculus based on overloading seems more an implementation rather than a formalization. this could be true, but there is evidence that some phenomena like method override are related more to a syntactic universe of\names", rather than to a semantic universe of functions. for example, in our encoding method specialization in the inheritance process has a clear meaning in terms of algebra morphisms, but overriding does not seem to t in clear algebraic concepts. so it looks worthwhile further pursuing this line of research.



a theoretical analysis of overloading has been carried out by castagna, ghelli and longo in: aimed by the purpose of providing a general framework as a foundation of object{oriented languages, they introduced an extension of simply typed lambda{calculus,&, where overloaded terms and types are considered. in, an encoding of a toy object{oriented language into& has been proposed. in the&-calculus, an overloaded term is essentially a collection of functional terms, glued together. when an overloaded term m= m1&:::&mn is applied to an argument n, one branch mi of the overloaded term m is chosen depending on the type of n, and then applied to n. therefore, the reduction relation of this calculus(and hence its operational semantics) depends on types. in our approach, properties peculiar to the cuch machine allow us to encode overloading in pure lambda{calculus, keeping the natural treatment of application and abstraction. moreover, they allow us to avoid type-dependent operational semantics and to obtain a quite



another related piece of work is in, where the formal foundations of a design method integrating algebraic speci cation techniques and object{ oriented programming is presented. this work is really interesting since it exploits algebraic data types de nitions in a software-engineering setting. we still do not know whether if there is a possible use of the cuch++calculus in a similar setting, but it is certainly worthwhile exploring the possible connections between it and breu's treatment of abstract data types.



an earlier version of the translation presented in section 4 was implemented as a\precompiler" which takes as input a cuch++ program and produces the corresponding cuch code. we would rather not hiding the cuch programming style but instead extending the cuch machine with cuch++ object{oriented features in such a way that functional and object{oriented features are blended, in order to get a nice heterogeneous environment to experiment cuch++'s future extensions. we plan, in fact, to study further extensions of cuch++ and of the encoding, in order to deal with issues such as multiple inheritance and more re ned encapsulation rules, to provide the programmer with an explicit control over eld and method external accessibility(for example introducing usual keyword public, protected and private).



as pointed out by an anonymous referee, since we implement an object{ oriented language via primitive recursion without using xed point operators, it might be possible to similarly design a typed cuch++ without recursive types. for example, given a type p oint= fx: int; move: int! p ointg, can we have a\ nite" type for point? the answer is very likely to be\yes", by using higher{type functionals. it's bohm-berarducci all over again, just at the level of types instead of terms.



