freely available experimental transformation languages have begun to stimulate practical usage of textual transformation notations. the forthcoming qvt transformation languages may provide standardisation or at least interchange capabilities for these experimental languages. graphical transformation notations are proving rather less successful. we identify many disadvantages of the graphical approach, consider how they can be circumvented and describe changes in the umlx notation and tool support to improve usability and qvt compatibility.



model transformations are becoming steadily more practical and rigorous with the advent of better meta-model based tools such as atl or tefkat. the transformation language for each of these tools is proprietary and so inhibits the wider exploitation of these transformations. the increasingly imminent qvt standard for a suite of three languages may avoid incompatibility problems, possibly by rendering the existing languages obsolete, more likely by defining an interchange point so that transformations for language a may be transformed to a qvt language and from there to language b.



in this paper we try to understand why graphical transformation notations are proving less successful and consider when and how this lack of success should be remedied. we first consider the generic advantages and disadvantages of textual and graphical notations, before examining the reasons why some graphical notations have proved successful and others have not. in section 2 we examine a variety of graphical transformation notations in greater detail, noting their similarities with respect to the use of declarative patterns in principle, but significant differences in practice and even greater differences with respect to transformation rules. then in section 3 we outline the tool support for umlx and notational enhancements to improve alignment with qvt.



a textual notation does not suffer particularly from scalability issues. the use of multiple source files and hierarchical language constructs enables very large overall line counts to be managed. unduly long lines are readily avoided at the expense of a slightly increased line count.



of languages such as c or java. a critical weakness in textual languages arises when a more declarative perspective is taken. it is difficult to identify all uses of a particular concept such as a variable, so it is necessary to search the code for all occurrences of a name.



the lack of an inherent layout makes graphics well suited to a declarative exposition of many interrelated concepts. each concept is a graph node denoted by a symbol, and each interrelationship is a graph edge denoted by a line. the lines between symbols are easy to identify and so all relationships involving a particular node are easily determined.



in the revised merged qvt submission, the class name underlines and the line decorations are omitted. omission of the underline is a minor stylistic deviation from uml. omission of the line decorations deprives the reader of the distinction between composition and association and the disambiguation of multiple associations involving the same classes. agg uses a more conventional graph transformation notation and so underlines and line decorations are again omitted, and instance names are replaced by instance numbers.



gre showed multiplicity in the style of uml but did not exploit it. its successor, great, recognised that non-unit multiplicity could support patterns involving sets of objects rather than just objects. the corollaries of this interpretation are discussed in; a pattern could now specify that its rule was applicable only to each book containing two or more chapters, rather than just to each book(that might contain some chapters). however, in great, the multiplicity was shown as an instance stereotype thereby identifying the absolute size of the set of matched objects for each free variable, rather than the relative size of the set of matched objects between the ends of the decorated relationship.



umlx was inspired by gre but replaced the creation relationship by declarative preservation and evolution relationships. a preservation relationship keeps the input element for re-use on as an output element. an evolution relationship may add an output element or elements with respect to an input element or elements, and may also delete an input element or elements with respect to an output element or elements. preservation extends the keep operation of graph theory, to support keeping not just a node, but also all its composed descendants. evolution combines add and delete operations in a multi-directional relationship that always defines a traceability relationship.



the editor supports partitioning a design into sheets using three different diagram types. meta-model diagrams support maintenance of ecore meta-models, that are instantiated within transformation rule diagrams where the umlx transformations are drawn. a further transformation context diagram supports aggregating many umlx-defined or qvt-defined rules as part of a qvt compatible transformation.



