being syntactic, the restrictions on rules are often rather intricate, and it is not clear how they arise. this intricacy makes proving meta-theoretic results difficult, and makes it virtually impossible to see how these results are affected by changes to the language under consideration, or to the notion of observable behaviour of the semantics being defined. one gets the feeling that there is some deeper mathematical structure at play that is being obscured by the syntactic clutter.



being syntactic, operational semantics presented in this form is language-specific. as a result, it is difficult to implement a generic notion of operational semantics in a high-level programming language such as haskell. compare, for example, with the use of logical frameworks to implement logics and type theories; such language-independent frameworks are clearly missing for operational semantics. one would like to be able to write data types whose inhabitants are operational semantics, and programs which manipulate such data types.



being syntactic, it is not clear how to relate operational semantics to the more abstract and high-level denotational semantics. this is more than just a mathematical irritation: by utilising concepts from category theory, denotational semantics has given us many language-independent mathematical tools to structure programs. these include, for example, monads, initial algebra semantics and kan extensions. the fact that these tools are language independent suggests that they somehow get at the essence of computation. the same cannot currently be said of operational semantics, with its inherently language-dependent flavour.



overall, we are left with the feeling that we need to get at the mathematical essence of operational semantics, to allow mathematical tools to be used to structure and reason about operational semantics in a high-level manner, and to make it easier to relate it to denotational semantics. indeed, at this point, we can begin to wonder if we really need operational and denotational semantics. a categorical semantics encompassing both approaches may actually be what we are striving for.



as shown in these last two examples, when the transition relation is a function, we can remove the powerset(or list). in this manner, the determinism of the underlying transition system is made explicit, avoiding the need for a separate proof. being able to describe precisely what is observable by choosing the appropriate behaviour functor is an important advantage of the coalgebraic approach.



coalgebras provide an abstract model of transition systems. unfortunately, they do not support a proper theory of sos. in particular, the carrier of a coalgebra is unstructured, and hence a purely coalgebraic approach will not be able to take advantage of the fact that the carrier of the coalgebra is the set of terms, and hence, has an algebra structure. therefore, in order to develop a mathematical operational semantics, what we need is a structure which contains both coalgebraic and algebraic features. turi constructed such a structure in his categorical framework for sos by focusing on the operational rules rather than on the transition relation.



in general, a rule consists of some premisses and a conclusion. the source of the conclusion consists of an operator of the language(the; operator, in the example above) applied to some metavariables(p and q) which stand for arbitrary terms. premisses are transitions from these metavariables. finally, the target of the conclusion is a term with metavariables taken from the source of the conclusion and from the premisses(q and pj, respectively).



every operational rule or s b induces a lifting opmonad of the syntax monad term s to the category of b-coalgebras. the function opmonad(the operational monad) takes a b-coalgebra on x and returns a b-coalgebra on term s x. intuitively, opmonad shows that given an operational rule and the semantics of variables x in the terms, we can give semantics to terms with variables from x.



this is the fundamental tool for combining modular operational rules. the constraint that the monad m and behaviour b should be the same for the input rules of appears to be a severe restriction that undermines our original goal. however, as it will be shown next, we can sidestep this restriction by defining modular operational rules over an abstract monad and behaviour.



we have developed a modular approach to operational semantics which allows us to define the semantics of a language as a combination of the semantics of its individual components. our approach is based on writing the operational semantics on partially known syntax and behaviour, and on the representation of an operational semantics as a polymorphic function that distributes syntax over behaviour. this high-level modular approach leads to a simple and natural implementation in haskell, which serves to make our work more accessible and also to allow readers to experiment further with our constructions.



