the analysis of information flow is a popular technique for ensuring the confidentiality of data. it is in this context that confidentiality policies arise for giving guarantees that private data cannot be inferred by the inspection of public data. one of those policies is non-interference, a semantic condition that ensures the absence of illicit information flow during program execution by not allowing to distinguish the results of two computations when they only vary in their confidential inputs. a remarkable feature of non-interference is that it can be enforced statically by the definition of information flow type systems. in those type systems, if a program type-checks, then it means that it meets the security policy.



the analysis of information flow is a popular technique for ensuring the confidentiality of data. it is in this context that confidentiality policies arise for giving guarantees that private data cannot be inferred by the inspection of public data. non-interference is an example of a security policy. it is a semantic condition that ensures the absence of illicit information flow during program execution by not allowing to distinguish the results of two computations when they only vary in their confidential inputs. a remarkable feature of non-interference is that it can be enforced statically by the definition of an information flow type system[2,16,14,8]. thus, when a program type-checks in such a type system then it means that it satisfies the security policy. in this setting, program variables are classified in different categories(types) according with the kind of information they can store(e.g., public or confidential data). the advantage of modelling security properties in terms of types is that they can be checked at compile-time, thus partially reducing or even eliminating the overhead of checking properties at run-time.



most of the security type systems are flow-insensitive. these are type systems in which the security level of the program variables remain unchanged. this contrasts with security type systems that are flow-sensitive[4,13]. in those type systems each variable can have a different security level at different points of the program. flow-sensitive type systems are more permissive than flow-insensitive ones since they accept a larger set of secure programs.



the paper is organized as follows. in section 2 we present the high-level language that serves as source and target of the translation and a flow-insensitive type system for it. section 3 deals with the flow-sensitive type system for the language defined by hunt and sands. section 4 presents the program transformation and the proof



suppose we want to model a security scenario where each program variable has associated a security level stating the degree of confidentiality of the values it stores. in such a context it is natural to implement some security mechanism in order to protect confidential data. we will do so by implementing an information flow type system[16,14,8]. the type system to be defined in this section is flow-insensitive in the sense that it considers that the security level of the variables is maintained unchanged during program execution. variables with this property are called fixedtype variables. this contrasts with the so-called floating-type variables, whose security level may vary along program excecution. we will deal with floating-type variables in the flow-sensitive type system to be presented in section 3.



an explicit flow is observed when data are copied to less confidential variables. consider two variables xh and yl, with l< h. for example, the assignment yl:= xh+ 1 is not allowed because the value of the variable xh is copied to a less confidential variable, yl. on the other hand, an assignment in the opposite direction, e.g. xh:= yl, is authorized, since it does not represent a security violation.



the reason for being insecure is because by observing the value of the variable yl on different executions we can infer information about the value of the variable xh. this is because we are performing the assignment of a variable with security type l in a more confidential context(in this case, the branch of a conditional statement with a condition of type h). due to these situations it is necessary to keep track of the security level of the program counter in order to know the security level of the context in which a sentence occurs. on the other hand, a program like this:



now we present the flow-sensitive type system that was defined by hunt and sands[4,5] for the while language. this is the type system that is used to type-check the source programs of the translation. like before, the type system is parameterized by a lattice of security types l.



in the formulation of the theorem we capture the relevant characteristics that our semilattice of environments has. taking into account that environments are finite mappings that contain only the variables that occur in the analysed program, it turns out that the semilattice is finite. from that, what is relevant for us is that every strictly ascending chain in the semilattice has finite length; in particular, every chain that ends at the top environment. this will be reflected in the theorem by assuming the existence of a function, called bound, that associates a natural number to every element of the poset and is strictly decreasing with respect to the strict order:



function fixs turns out to be itself a monotone function wrt the elements of s. this fact should not surprise because we are simply working with an abstraction of the fixpoint construction we had in the type system for statements. later we will use the monotonicity of fixs for the implementation of the type system.



for the agda implementation of the language with a flow-sensitive type system we want to proceed in a similar way as we did for the flow-insensitive type system using an internalist approach. again, the goal is to define type families that represent(flow-sensitive) typed terms for expressions and statements. on those typed terms we will define later the translation to flow-insensitive typed terms.



for expressions the internalist implementation is immediate. expressions are represented by a type exps, which is parametrized by the type environment(given by a vector of security types), and the security type of the expression. like before, s denotes the carrier set of the lattice of security types.



variable n denotes the number of program variables that occur in the program code. each program variable is identified by a value in the finite set fin n. that way, each variable has associated a position in a type environment of type vec s n.



