since our focus is on development of distributed algorithms with formal model support, we first create a formal model of the initial design idea. by model we mean a system with a clear semantics, in this paper a finite state system. afterwards we verify the model against a correctness specification. in this paper verification is as the underlying case study. the aim of that paper was to evaluate different proof strategies on a concrete distributed agreement algorithm, i.e. different ways of proving already known theorems. in this paper we extend and improve the algorithm by iterative development. in the end we provide a correctness proof for the extension.



we use communicating finite state automata with asynchronous fair message passing as the basic model. fairness ensures that agents cannot wait forever to receive messages already sent. all n agents communicates over a medium where messages are not lost or altered under transmission.



initially the automaton is in its idle location. it initializes by a transition to location phase1. from there it may either crash or move to location wait1 waiting for a message or suspecting. it loops through all agents, moves up a round, and returns to location phase1. when all rounds are complete it moves to phase2. at location wait2 all agents are looped through again. when finished it moves to phase3 selecting the final value.



the synchronous communication primitives of uppaal is not usable since we need asynchronous communication. instead we use shared buffers. there are no testand-set race conditions since the semantics of uppaal is interleaved and agents write to different places of the shared memory. we introduce the boolean arrays sent1[][] and sent2[]. if sent1[q][r] is true, then agents q has made a broadcast of a message in round r in phase 1. if sent2[q] then agents q has made a broadcast of a message in phase 2. the message is retrieved by an array lookup v= msg1[q][r][i]. here v is the integer value at index i of the message tuple sent from agent q in round r. similarly v= msg2[q][i] is a broadcast of a message with value v at index i from agent q.



we use model checking on a bounded number of agents and fix the number of agents to three which turns out to be enough for revealing errors. the check of(1) and(2) succeeds as expected(in total 278316 states explored, 5.2 seconds of time used).



we model-check this model against the specification with n= 3 agents. that gives a total of 154592 states explored and a time usage of 4.7 seconds. for n= 4 agents we have not been able to complete the model check due to insufficient memory) and uppaal finds this counter example to the termination property: assume ti= 1 and that agent 1, 2, and 3 cooperate such that agent 1 and 2 discover a match and terminate(by jumping to phase 3) while agent 3 waits at location phase2. when agent 3 then moves to location wait2 a deadlock occurs. agent 3 waits for a message from agent 1. since it cannot suspect agent 1(it is the ti) it will block until a message is sent. the problem is that agent 1 has bypassed phase 2, so it will never send the knowledge-vector to agent 3 and agent 3 waits forever.



the termination, agreement and validity property are now satisfied for three agents(in total 514084 states explored in 12.3 seconds). even though we cannot check the model for n= 4(due to lack of memory) we still have an indication that the algorithm might be correct. we therefore proceed with a general correctness proof for any fixed number of agents.



