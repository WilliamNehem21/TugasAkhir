to fully support refactorings in a team development environment we have implemented a refactoring-aware repository provider as an extension plug-in to the java development tools in eclipse. the versioning system treats refactorings as first-class changes described as semantic actions rather than the set of resulting changes scattered over the source tree. we also introduce refactoring-aware merge, which merges refactorings as well as traditional changes utilizing the semantics of the refactorings to detect and resolve merge conflicts. it also ensures that the semantic meaning of a refactoring is preserved after the merge.



refactorings are a safe and efficient way to improve code quality in a controlled manner. refactorings differ from traditional changes in that they are guaranteed to be semantically valid and have a semantic meaning, e.g. after renaming a variable all uses of that particular variable should still reference the same variable.



these benefits apply to refactorings in a single user environment, but the introduction of traditional team development repository providers decreases the above mentioned benefits due to insufficient tool support. when merging code from several developers the preconditions have been checked for each individual branch, but not for the merged source tree. thus, all preconditions ensuring a safe refactoring may not be met for the merged tree. during merge, the changes originating from a refactoring are viewed as numerous small unrelated changes that the developer may have to merge manually, in case of a merge conflict. since a refactoring is only applied to one of the merged branches, and not both involved versions, the merged result may not include the semantic meaning of the refactoring. changes in the branch where the refactoring is not applied may violate pre-conditions, prohibiting the refactoring to execute, or newly introduced code that should have been affected by that refactoring is unaffected, e.g. adding a invocation of a method that is renamed in a parallel branch should be changed to use the new name instead of the old name.



to better support refactorings in a team development environment, we have developed a model for a refactoring-aware repository provider. this provider stores and retrieves both traditional changes and entire refactorings, which enables the presentation of differences between two versions in terms of refactorings. moreover, when two branches are merged this semantic knowledge is used to better detect potential conflicts and(when possible) to do an automatic merge. the result is that some cases of unintended merges and false merge conflicts now can be correctly automatically merged and that real conflicts more often are detected and better presented to the developer. we have implemented parts of this model in a prototype as an extension plug-in to the java development tools in eclipse. currently the prototype supports refactoring-aware automatic merge of two refactorings(rename and move) with manual changes.



the rest of this paper is structured as follows. section 2 gives an introduction to refactorings and various merge strategies. the two concepts of refactoring-aware merge and refactoring-aware versioning are introduced and motivated by examples in section 3 and section 4. section 5 outlines a versioning model and merge strategy to support refactoring-aware versioning. experiences from integrating that model and strategy in eclipse is given in section 6. related work is described in section 7 and section 8 concludes the paper and discusses some future work.



rename renames a class-, field-, or method-declaration as well as all uses of that same entity. when renaming a method, polymorphism and overriding must be taken into account. pre-conditions involve checking that the new name is not already in use or shadowed by another declaration. a refactoring like rename class, that changes both declarations and use sites, often involves numerous changes scattered over the entire code base.



merge is the task of combining changes made to one document in parallel into one unified version. incompatible parallel changes results in a merge conflict that must be manually resolved. the following techniques represent the current state of the art and are orthogonal to each other and may thus be used in any combination. for a thorough survey on software merging see.



an important difference between merge tools is the way documents are represented. a textual representation of documents treats each document as a flat structure. the most common approach is to divide the document in single lines of text and perform merge on these lines. because of this granularity parallel changes to the same line is not handled very well, since only one of these lines can be selected even when a combination of the two modifications to the same line is desirable.



a better approach is to take the syntactical structure of the documents in account. this is particular powerful in the context of programming languages where the syntax is clearly defined. the most common structural representation of software documents is a parse tree matching the context-free grammar for the used programming language. the merge tool can detect context-free conflicts and ensure that the merged result is syntactically correct.



an even more advances approach is to take the static semantics of the used language in account as well. the goal is to detect semantic merge conflicts that would generate static semantic compile-time errors or unintended run-time behavior when merged. this approach often rely on complex mathematical formalisms and current implementations do not work for full blown languages.



the final result of the two concurrently changed versions are considered. a change-based merging tool uses information about the exact changes made to the documents. these changes often correspond the the actions taken in the integrated development environment. the extra information can be used for improved conflict detection. operation-based merge is a special case of change-based merging that models the changes as explicit transformations.



the main goal of a merge tool is to find changes made in parallel that are independent and then automatically merge them. changes that are dependent result in a merge conflict that needs to be resolved manually. in a naive row-based merge-tool only changes made to the same row are considered dependent while a structural merge tool consider changes made to the same node dependent. while certainly useful, this type of dependency detection fails to detect certain dependences and detects some unintended dependences as well. since the semantics and intention of a refactoring is clearly defined, this information can be used to perform a more intelligent merge that better reflects the intention of the developer.



class to another, e.g. pulling a method to a super class, and in parallel changing that same method. traditional merge tools will view the single move operation as two unrelated delete and add operations done in parallel with the change operation. the delete and change operations affect the same code



and thus result in a conflict while the add operation is merged automatically. a refactoring-aware merge can detect that the changed method is to be moved and apply the changes to that method prior to moving it to its new location. the merge conflict in a traditional merge is replaced by an automatic refactoring-aware merge.



the pre-conditions for a refactoring can be used to detect cases where an automatic traditional merge will not be semantically correct. such errors are better resolved as merge conflicts than as compile-time errors. a merge conflict that originates from refactoring pre-conditions often turns out to result in numerous compile-time errors as will be discussed in section 3.4. consider pulling down a method from a super class to one of its sub classes in parallel with adding a use of that same method in the super class. the pre-conditions for the pull down method refactoring states that the method may only be moved to the sub class when all invocations of that method are done through references that are statically qualified to the sub class. the added invocation violates these pre-conditions and the refactoring-aware merge will detect a merge conflict in contrast to the semantically incorrect automatic merge performed by a traditional merge.



one important benefit from refactorings often neglected is the definition of a nomenclature for common high-level changes that improve source code. these refactoring names can also be used to provide more descriptive history tracking. indicating that an element is renamed is more descriptive than the more traditional unrelated changes to the definition and all uses of that element that are scattered all over the source code.



manual changes to the source code are stored as traditional delete-, add-, and change-operations but make use of node identity to specify the affected nodes. since node identity is preserved when refactorings are executed these changes can still be applied after structural changes, e.g. a changed method body can be located even after the affected method is moved.



the refactoring-aware merge tool has two main tasks: to detect semantic merge conflicts and, if possible, perform an automatic refactoring-aware merge. the merge is done in several steps. first, the traditional changes are merged and merge conflicts that originate from these changes are detected. then, refactoring pre-conditions are checked to detect possible semantic merge conflicts that would be caused by applying that refactoring to the merged version. if the pre-conditions hold the merge proceeds with an automatic refactoringaware merge. the traditional changes are first applied followed by the refactorings. this ensures that all traditional changes are affected by the whole source transformations caused by refactorings. because node identity always is preserved, both for traditional changes and when refactorings are executed,



we have a implemented a plugin that adds a refactoring-aware repository provider to java development tools(jdt) in eclipse for proof of concept. the current implementation supports refactoring-aware automatic merge for the rename and move refactorings. we believe that the approach is generic enough to be extended with other refactorings as well. the goal was to re-use as much infrastructure as possible in jdt while implementing the versioning model described in section 5.



manual changes are directly replicated in rajm. we register a java elementchangedlistener to receive events when changes to the javamodel occur. these are reported as traditional add, delete, change, and move deltas. while add and delete report changes all the way down to type members, change and move seem to only report changes down to the affected compilation unit. we therefore compare the entire compilation unit with rajm in order to find the actual changes, which then are store in rajm.



refactorings should be more carefully traced. the series of changes caused by a refactoring should not always be directly replicated, but a the semantic behavior should be better stored. when, for example, a move is executed the delete and add operations made in the java model should be transformed to a true move to the affected node in rajm.



why not add these transformations directly to the existing refactoring implementation? it may seem like we need a lot of semantic knowledge to replicate these transformations in the version model. however, many refactorings have little or no net effect on the actual structure and sometimes provide information of the affected nodes. e.g. a rename refactoring does not change the structure but only the node contents, and a move element refactoring provides access to the source and target location elements. i.e. the actual transformation is a match of delete and add operations, transforming them to one move.



since we used the javamodel structure for rajm the most fine-grained element is type members, and the node contents may thus be the entire method body. a more appropriate solution would be to use the underlying ast as the structure to replicate. however, the javamodel is still needed for refactoring parameters and has a more convenient access to its syntactical source range than the ast nodes. refactoring parameters are needed to represent refactoring deltas and the source range for the node contents. our current implementation replicates the javamodel and relies on a traditional merge for method bodies while still demonstrating the central concepts.



the use of static semantic information when merging versions is not a new idea but used in several approaches to semantic merge, e.g.. our approach differs in that we limit the semantic merge to refactorings where not only the semantic is well defined but where the intention from a developer point of view



two approaches that detect and merge renamed entities in software are described in and. in, a generic rename detection for languages with a nested block structure is described and implemented using contextual information. however, this approach does not work on object-oriented languages. in, a statistical rule based method is used to detect renamed entities. neither approach tries to generalize these ideas for other semantic sensitive changes.



