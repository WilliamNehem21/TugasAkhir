analysed through simulation and verification. moreover, starting from an obgg model we can generate code for execution in a real environment, following a straightforward mapping to java. we also worked on an approach to consider classical failure models for distributed systems, allowing the reasoning about a given model in the presence of a selected failure. by using the methods and tools mentioned above we have defined a framework to assist the development of distributed systems. the innovative aspect of this framework is the use of the same formal specification language(obgg) as the underlying unifying formalism.



in an approach for verifying obgg was defined, where obgg models are translated to promela, the input language of the spin model checker. one important aspect of this approach is that properties(to be verified) are specified over obgg models, instead of over translated promela models. the proposed approach considered only properties over events(that, in case of obgg, are rule applications). however, complementary aspects of a system could be specified by using properties over states. besides, counter-examples obtained from spin have no corresponding meaning for obgg models, because they are automatically generated over translated promela models. the main contributions of this paper are:(i) to extend the property specification approach to consider states of objects;(ii) to define an approach to generate graphical counter-examples for properties that are not true for an obgg model.



graphs are a very natural means to explain complex situations on an intuitive level. graph rules may complementary be used to capture the dynamical aspects of systems. the resulting notion of graph grammars generalises chomsky grammar from strings to graphs. the basic notions of graph grammars are that the state of a system can be represented by a graph(the system state graph), and from the initial state of the system(the initial graph), the application of rules successively changes the system state.



the behaviour of an entity when reacting to a message is defined by a(set of) rule(s). therefore the left-hand side of a rule always specifies the reception of a message by a specific entity. at the right-hand side, that message is consumed and the effect of applying the rule is defined. this effect may be: change of attribute values; creation of objects(instances of entities); and/or generation of new messages. the initial graph specifies the start state of the system.



the spin model checker is a tool for the verification of concurrent software systems. the input language of spin is promela. property specifications in spin are defined using linear temporal logic(ltl). besides being a model checker, spin can be used as a simulator. the simulation feature of spin, among other things, is used to simulate counter-examples(traces) of properties that are false for a given model. a counter-example generated by spin is composed by statements of the promela model having variables substituted by values of the current state of the model.



when specifying properties in spin, the user needs to define atomic propositions over the promela model. one possibility for defining atomic propositions is using global variables. this leads to the need to insert attributions to global variables that will be used in verification.



in the translation defined in, obgg objects are mapped to promela processes(which we call object processes). variables that compose object processes are attributes of corresponding objects. for verification purposes, attributes of obgg objects are restricted to the types supported by promela. obgg messages are translated to promela messages. the receipt of messages is done through an asynchronous channel, called object process channel, also used as reference to the object process. rules for obgg objects are



the generic behaviour of an object process is as follows:(i) wait for new messages in the object process channel;(ii) once new messages are received, send them to an internal buffer of the object process;(iii) non-deterministically choose a message from the internal buffer and try to apply a rule to process that message;(iv. a) if a message is processed and the object process channel is empty, return to(iii);(iv. b) if no message is processed or the object process channel is not empty, return to(i).



the obgg initial graph is composed of object instances and messages of the model. the initial graph becomes an init process in promela. this init process has three stages:(i) create object process channel(s) for objects appearing in the initial graph;(ii) execute object process(es) defined in the initial graph;(iii) send initial messages using the object process channel(s).



basically, in the literature we can identify two complementary approaches used to specify properties about executions of models, one based on events and another based on states. for using these approaches with obgg, we can view the application of rules as being events and graphs, obtained from the application of rules, as states. in we provided a way to verify properties based on events for obgg. this will be presented in more detail in section



when specifying properties over translated obgg models in spin, we have to consider that spin is an ltl state-based model checker. in order to specify properties based on events, we would have to make available names of the events used in the property specification through global variables. in our approach using events, every promela model generated from the translation has a global variable called event rulename. the type of this variable is an enumeration of symbolic names which contains the names of obgg rules that compose the model. thus, when a rule is applied, the name of the rule is atomically written to the event rulename global variable, i.e., the name of the applied rule is made visible in the current state of the model.



by using the application of rules as events, we can specify properties(in ltl) over obgg models without having to know the translation. however, we lack the support to express properties about states of objects. when considering the internal state of objects we can, among others, specify properties about specific objects in the model, for instance the impossibility of one specific writer proceed to get the resource(i.e., starvation of that specific writer). in order to address this issue, we extend the approach using events in the sense that users can define events using attributes of objects. nevertheless, the basis for these events continues to be the application of rules.



in the literature of distributed systems, one widely accepted graphical form to view the execution of distributed systems has its basis on the exchange of messages between processes. this approach consists on defining a time-line for each process that compose the system. time increases downwards, by showing the messages(via labelled arcs) being send/received by processes.



since obgg has its focus on the specification of distributed systems, the use of a graphical representation similar to the one described has the advantage of being intuitive for users that work with the abstraction of message passing. however, showing only the exchange of messages does not capture another important abstraction of obgg, the application of rules. in order to consider the application of rules in a graphical execution view of obgg models, we can add information about rule applications to the time-line of each object that compose the system. this information contains the name of applied rule(s), and is added whenever a rule is executed by an object.



due to inherent characteristics of the translation from obgg to promela, in the promela model messages do not have unique ids(identifications), an information available in obgg. therefore when more than one message with the same type and same attributes are sent to the same object, it is not possible to identify which of the identical messages triggered a specific rule in an object. although much of the analysis needed can be done with these counter examples, in some cases it may not be possible to analyse the causal relationships among events.



in this paper we explained how it is possible to specify properties for verification of obgg models using events(application of rules). based on that, we defined an extension of the approach to consider the specification of properties using the internal states of objects. the second contribution of this paper is the definition of a graphical layout that is meaningful for obgg users to view the promela counter-examples.



in the literature, when focusing on the verification of non-visual languages we found works like[4,3,13,9,16]. more specifically, the works presented in[4,3,9] aim the verification of restricted java programs, where java programs are translated to the input language of the spin model checker. despite these works dealing with the verification of java programs, extends promela(the input language of spin) by considering the actors concurrency model, in order to model check object-based distributed systems. in an integration of the formal specification language object-z with asm(abstract state machine) was introduced, creating the oz-asm notation. after a series of translations, it is possible to verify oz-asm specifications using the smv tool.



differently from most similar approaches considering the translation between languages for model checking, in our work it is possible to specify properties and to view graphical counter-examples in a level of abstraction which is compatible with the language used to specify the model(obgg), i.e., using the main obgg abstractions. moreover, we have a formal proof of the correctness of our translation, something not found on most of the works found in the literature.



