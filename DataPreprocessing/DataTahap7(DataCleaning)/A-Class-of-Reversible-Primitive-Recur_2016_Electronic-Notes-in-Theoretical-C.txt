here above we have recalled the physics related aspects that make reversible computation relevant. from a computer science foundational point of view reversible computing is interesting because it subsumes classical computing: every computation in a classical model can be simulated by a reversible one. moreover, aspects of reversible computation are ubiquitous in everyday classical computations. we can find them in activities spanning from software verification to programming languages, passing through computer architectures, as well as part of innovative computing models, like quantum, bio, chemical and molecular ones.



our starting point are rf and prf for various reasons. first, we want to manage entities that compose because they stand for and are written as functions. second, rf, as well as prf, balance intensional and extensional aspects. intensionally, they can be taken as programming languages whose semantics is given informally. extensionally, rf deals with partial functions 3 while prf with total ones, both shifting the focus on functions closer to what other computational models can express and providing support to functional, or compositional, programming.



a little bit more specifically, our goal is the synthesis of a formalism which, at least, describes a reasonable large class of first-order functions whose graphs can be effectively inverted inside the formalism itself. the simple and effective inversion operation that we propose in this work takes great advantage from the compositional nature of the computational model we introduce. as a side effect we shall eventually be able to compare the programming style our computational model supplies with those ones available inside the reversible turing machines as in and janus.



primitive recursive functions. we develop our goal gradually. in this paper, we do not aim at the synthesis of a full analogous of rf which, we recall, is turing-complete. we present what we think is a good candidate we can identify as being the analogous of prf i.e. a class of terms which could capture all the algorithms developed in mathematics until the first part of xx century, see. prf is not turing-complete and corresponds to a core of rf which only contains everywhere-defined, i.e. total, functions. in analogy to prf, we supply reversible primitive recursive functions(rprf) which always terminate and keeps semantic redundancies at bay(with a relatively light abstract syntax).



a work that introduces a language related to rf is. first it provides a representation of the full set of invertible partial recursive functions between natural numbers, unlike ours. moreover, a second difference with rprf is that the language in heavily depends on the explicit binary representation of numbers. this difference is essential for us, since we aim at characterizations independent from the data representation as for dedekind-robinson-kleene ones.



we introduce the class of reversible primitive recursive functions that we abbreviate as rprf. rprf includes only total functions. among them we show that all primitive recursive functions can be represented by using an embedding technique that recalls the ones we can find in[2,17,18]. one novelty of rprf, as compared to the class of primitive recursive functions(and classic recursion theory), is that its functions operate on integers instead than on natural numbers(as first proposed in). the reason is that natural numbers do not form a group(endowed by inverses) with standard operations. another peculiar aspect of rprf is that it is closed under inversion in an effective way.



unpairing is by bernays and robinson, see[13, p.72]. they used pairing and unpairing for a non standard definition of prf, like we do. the main motivation to let pairing and unpairing available is to pack the information. a single argument can be used as a kind of store, like the coming example shows. the composi-



the composition among elements of rprf has no major differences with the composition scheme of prf. the recursion scheme is, in fact, an iterator. it iteratively applies one of the three parameters in rprf as many times as the value of the argument in position i if xi/= 0, one time otherwise. the value of that argument is not passed to the iterated function. instead, it is preserved by the whole evaluation and reappears untouched as part of the result. of course the i-th argument can be negative. we take into account this case by using its absolute value for driving the iteration.



