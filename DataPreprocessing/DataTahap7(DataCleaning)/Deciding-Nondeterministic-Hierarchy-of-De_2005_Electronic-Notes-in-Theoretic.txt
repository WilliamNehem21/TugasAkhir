the problem appears somewhat easier if the input automaton is deterministic. deterministic tree languages form a proper, but effective, subclass of all recognizable tree languages(we can determinize an automaton in exptime, whenever possible). computing the level in the deterministic hierarchy can be accomplished by reduction to an analogous problem for word automata, see remark 2.4 below. note however that the level of a deterministic language in a nondeterministic hierarchy can be arbitrarily smaller than in the deterministic one 5.



given a tree t in t(a), there is a unique run of a^ on t. this defines parts of the tree accepted by different strongly connected components(sccs) of a^. we can have an automaton without acceptance conditions that calculates in each node the state of the unique run of a on t. the automaton we want to construct will be a product of this automaton and(1, 2) automata, one for each scc of a^. the role of the latter automata will be to check if all paths of the run of a^ that stay forever in a given scc are accepting. the composition of these automata will give us(1, 2) automaton recognizing t(a).



