for programs running on general-purpose operating systems on pc-class hardware, threads are the most important abstraction supporting concurrent programming. on the other hand, interrupts are the dominant method for expressing concurrency in low-end embedded systems, such as those based on microcontroller units(mcus). all major mcu architectures support interrupts, and a large number of these chips are deployed in embedded systems: according to a gartner report, 3.5 billion 8bit mcus and a billion 16-bit mcus were shipped in 2003. the correctness of interrupt-driven software is important: a substantial number of these 4.5 billion mcus were deployed in safety-critical applications such as vehicle control and medical automation. for example, some of the extremely serious therac-25 bugs[17, app. a] were directly caused by race conditions involving interrupt handlers.



verifying the absence of race conditions in interrupt-driven systems is important, but the technology for this is primitive. we must understand interrupts and their semantics in order to understand where thread verifiers can, and cannot, be applied to interrupt-driven systems. in particular, we want to identify a minimal set of extensions to verifiers for thread-based programs that permit them to also check interrupt-based programs. a secondary goal is to exploit the semantics of interrupts to make checking faster and more precise.



of course, threads come in many flavors. in this paper we assume the common case of posix-style thread semantics: preemptively scheduled blocking threads, scheduled either in the kernel or at user level. however, the source code examples in this paper use a simplified syntax rather than using the verbose posix calls.



that are scheduled using fixed priorities, since even a high-priority thread can become blocked voluntarily, due to making a blocking kernel or library call, or involuntarily, due to a page fault. in contrast, asymmetrical preemption relations are the norm for interrupts. first, all interrupts can preempt non-interrupt code, whereas non-interrupt code can never preempt any interrupt. second, interrupts are often scheduled using fixed priorities, resulting in asymmetrical preemption relations among interrupt handlers.



some hardware platforms, such as the programmable interrupt controller on a pc, enforce priority scheduling of interrupts. on other systems, prioritized interrupt scheduling must be implemented in software. for example, the atmel atmega128, a popular mcu that is the basis for mica2 sensor network nodes, performs priority scheduling only among interrupts that are concurrently pending. once an interrupt begins to execute on an atmega128, it can be preempted by an interrupt of any priority, if interrupts are enabled. to implement priority-based preemptive scheduling on this platform, software must manipulate the individual enable bits associated with various interrupts.



a thread lock uses blocking to prevent a thread from passing a given program point until the lock resource becomes available. since interrupts cannot be blocked once they begin to execute, concurrency control consists of preventing an interrupt from starting to execute in the first place. this is accomplished either by disabling all interrupts, or by selectively disabling only interrupts that might interfere with a particular computation. the former is cheaper while the latter avoids incidentally delaying unrelated code.



interrupt handler in the avrx system is reentrant in order to avoid missing ticks. reentrance has two unavoidable costs. first, later parts of the handler will have their average latency increased, rather than decreased, since total latency in a work-conserving system is a zero-sum game. second, in practice it is difficult to



in practice these functions are written in such a way that they operate properly when used recursively. recursive locks are those that can be safely acquired multiple times. we ignore the issue of recursive locks here; their semantics are the same in threaded and interrupt-based code.



we wrote a plugin for cil that converts a tinyos application intoa posix threads program that we then check for race conditions using locksmith. the nesc compiler for tinyos applications includes a race condition detector, but it is unsound due to not following pointers. the transformation closely follows the one outlined in section 3. the transformation tool was not difficult to implement, taking one of the authors about five hours.



many systems support not only interrupts and threads, but also deferred calls, such as dpcs in windows and tasklets in linux, with their own semantics. typically, various kinds of locks are available, each protecting against some subset of these concurrency abstractions. in large code bases such as the windows or linux kernels, the diversity of concurrency and synchronization abstractions becomes a barrier to creating correct code. a principled way to reason about heterogeneous concurrency models is needed. our previous work includes tsl, an initial step in this direction.



interrupts lend themselves to many kinds of bugs other than race conditions. these include stack overflows, livelock, blocking in interrupt context, erroneous use of non-reentrant functions, and erroneous reentrant interrupt handlers. unfortunately, there is no obvious way to check for most of these types of bugs via translation to threaded code and use of an existing thread checking tool.



