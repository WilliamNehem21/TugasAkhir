all proposed io operations in this paper are specified generically. the presented generic functions are written in clean(see). due to some language specific limitations, the presented functions cannot be converted directly to generic haskell. there are some syntactic differences between haskell and clean. the major differences will be explained on-the-fly; for a complete comparison between clean and haskell we refer to.



specifying generic functions resembles defining a type class and its instances. the main difference is that a generic compiler can derive most of the instances automatically, given a minimal fixed set of instances for three(generic) type constructors. the derivation of instances is based on the fact that any algebraic data type can be expressed in terms of eithers(for distinguishing the constructors), pairs(for representing the argument types of each constructor), and units(for representing 0-ary constructors).



to define a generic function, the programmer specifies its signature and provides instances for the generic types(either, pair, and unit). as an example we define a generic packing program, taken from. the basic idea of this program is simple: given a value, we construct a compact representation of that value in which data constructors are represented by as few bits as possible. e.g. for a simple binary tree this means that we distinguish leafs from internal nodes using a single bit. to abstract from the concrete container that is used to store the packed value, we first introduce



unlike instances for ordinary classes, we define type instances for gcompress using the special parentheses{||}. moreover, the actual number of arguments of each instance depends on the arity(actually the kind) of the used type constructor. for example, the instance for pair as well as for either are supplied with two extra parameters that can be used to compress the arguments of these types. finally, the(auxiliary) types object and cons, were added to the set of generic types in clean to give access to concrete information about the original type definition(via object) and data constructors(via cons). in this example this information is not used, but in section 5 it plays a crucial role.



in contrast to generic haskell, the implementation of generics in clean is based on type classes. each generic function gives rise to a collection of so-called kind indexed type classes, i.e. classes of which the signatures are obtained from the type of the generic function via kind indexing. these generic type classes can be used as any other type class. therefore, they are allowed in contexts of type signatures or can be applied in expressions like any other overloaded operation.



the tree constructed by createtree above is completely out of balance: all elements are stored in the right branches. the use of chunks enables us to re-balance the tree without touching the stored records. this can be achieved as follows(we left out the open and close operations which are the same as in the previous example).



type is used for representing types as values. we use integers and strings to identify type variables and type constructors, respectively. the auxiliary temp constructor is intended to be used as an initial or default value. note that, although we are only interested in the type, we are forced to use the generic type variable a in the type signature. the use of maybe allows us to deliver nothing as a concrete dummy value.



before explaining the working of the generic type construction we illustrate its use. the aim is to define a type safe version of our basic generic io operations. we first introduce a wrapper type to include type information in the type of the io container, together with a function for constructing such a container. this function also takes care of the type checking.



structors. this time, however, the alternative for object plays a crucial role. as said before, one of our main concerns is not getting into an infinite computation. to illustrate the danger, we start with the instance of type that will be generated for lists by writing derive type[]. the structure of this generated function, say type_list, is completely determined by the definition of the list type.



when entering type_list it is checked whether the corresponding calling edge already occurs in the history. if so, the function returns immediately. otherwise the underlying type is constructed by calling the continuation. however, in some cases a single traversal of a type is not sufficient to derive a type completely. consider for example the following definition of an alternating list.



serialization and de-serialization are standard examples in any introductory paper on generic or type driven programming techniques[8,7,10]. data which is serialized in such a way can be stored and retrieved from persistent memory, but it lacks the ability to destructively update substructures. this is an absolutely necessary feature for any real world database system. instead of using generic techniques one can of course also use the overloading mechanism. however, this has the disadvantage that the programmer has to provide the proper instances for reading and writing of data explicitly.



in a persistent storage for haskell is presented. the basic idea is to extend the application memory with a persistent memory. when data is(explicitly) shifted from one memory to another, the internal representation of data in the application is converted to the external representation in the storage, and backwards. for the conversions support of the run time system is needed. destructive updating is not provided, but when structures are modified, sharing is maintained in the storage in the same way as it is common in the application memory. the approach cannot be used to exchange data between different applications.



