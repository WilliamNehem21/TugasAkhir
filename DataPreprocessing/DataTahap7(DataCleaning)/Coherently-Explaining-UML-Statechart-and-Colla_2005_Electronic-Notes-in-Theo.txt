the unified modeling language(uml) has recently become a widely accepted standard for the visualization, specification, construction, and documentation of object-oriented software systems. it is well established and used in industry as well as in research. the uml is a graphical language that comprises a number of different diagram types for different purposes. the syntax of these diagram types is defined in the uml metamodel. but the semantics of the language constructs is only given in natural language. as the uml is supposed to support a software engineer in constructing precise models, a formal foundation for uml is needed. the graphical notation is enhanced by the object constraint language(ocl), which permits to formulate constraints that cannot be expressed by the diagrams in a textual way. ocl is formally defined in. currently, the 2.0 version of uml is about to be finalized but the language definition will still be informal.



the graph transformation system consists of graph transformation rules and a working graph, which represents a snapshot of the current state(hence called system state) of the modeled system. the system state changes during a run of the system, i.e. graph transformation rules are applied rewriting parts of the working graph. using our approach modelers can validate a system model by performing system runs and comparing their expectations with the results of these runs.



in this paper we present the fundamental concept of system states and the translation of a given uml model into a graph transformation system focusing on the rules evolving from statechart and collaboration diagrams. an important aspect for us is that our approach integrates the ocl. ocl expressions that appear in the model are used in rules as well. when applying



several other works can be found, that provide a precise semantics for parts of uml by means of graph transformation. an integrated semantics similar to the one presented here is introduced in for class, object and statechart diagrams. since this approach does not cover interaction diagrams, it is extended in adding interaction diagrams on instance level. however, the operations have to be specified by single rules, thus only atomic operations are considered. in addition, the modeller is forced to enrich the uml model with graph transformation by himself, thus that approach is not purely uml conform in contrast to the approach presented in this paper. this work discusses in more detail our approach that has already been presented in which illustrated the basic concept only by means of an example. in the present paper, we explain the approach in a more general way.



the structure of the paper is as follows. in the next section an example model consisting of a class, collaboration, and statechart diagram is introduced and explained. section 3 provides an overview of system states in general. the formal background of our graph transformation approach and the translation of a model into a graph transformation system is explained in section 4, focusing on the rule generation concerning the sending of messages. the paper closes with a conclusion.



the model comprises the three classes icqserver, icqclient, and icqsession. an icqserver can have any number of icqclients, while the latter can only be a client of exactly one icqserver. the icqclient has an attribute id, which uniquely identifies a user operating the client. this id has been created during the registration, which is necessary for users to be able to be part of icq chats. this registration is not modeled in our example. the actual chat of exactly two icqclients is managed by the class icqsession. naturally, an icqclient can take part in more than one chat, therefore it can be connected to any number of sessions.



in the example collaboration diagram the operations connect, establish, and receive are specified. the other called operations(e.g. print) are not specified because it is not shown which suboperations are invoked by them. note that the operation establish is called with actual parameters(caller and callee) in the context of the connect operation, but the messages activated by establish only refer to the formal parameters of establish(c1 and c2).



diagram exists for a class, then any operation belonging to it can be called at any time. but in the case of a present statechart diagram, an operation on an object is only allowed if the object is in a state with an outgoing transition labeled with this operation. in our example, it is not allowed to execute the receive operation if the state of the session is pending. it is also not allowed to execute the establish operation if the state is ready. however, an operation that is not depicted in the statechart diagram of its class may still be executed at any time. if a transition is labeled with a guard, it has to be evaluated to true for the transition to fire. our graphically simulated system run never violates the restrictions specified in the statechart diagrams.



before the evolution of the system starts, the system state resembles the initial object diagram provided by the modeler. it contains nodes of type object representing the objects that initially exist, connected to nodes of type class, representing their class. however, it is possible, that the model comprises statechart diagrams specifying initial object states. in this case these states are added to the system state by depicting them as nodes of type state and connecting them to the corresponding object nodes via a state link. the corresponding classes are also connected to their initial states for internal reasons concerning certain graph transformation rules. further information from the statechart diagrams are not reflected in the system state but rather in the derived graph transformation rules.



operations that belong to classes are depicted by operation nodes that are connected to their class nodes. to be more precise, an operation node representing an operation of a class is connected to the class and its subclasses. moreover, an overriding operation is connected to the class the overriden operation is defined for. operation nodes that are not connected to a class node represent use cases.



a message invokes a user-defined operation or a predefined operation like setting an attribute value, setting a local variable or creating an object. a user-defined operation is an operation that is declared in the class diagram for a specific class. for example, the message 1.2 calls a predefined operation while the message 1.3 calls a user-defined operation.



the evaluation takes place in the context of this system state rather than the system state graph. variables representing attribute values in the usual way can also be used in both sides of a rule. these variables can also be employed in ocl expressions in the right-hand side of a rule in order to calculate new attribute values. thus the right-hand side of a rule actually differs from the system state defined earlier in that attributes may hold general ocl expressions and not only constants.



in our system state, the sending of a message corresponds to the creation of a process node with status#waiting. when a waiting process is activated by a rule, its status changes to#active. an active process represents an operation in execution. in the following, we simply say that a rule sends a message(or invokes an operation) if it creates a process node.



the set of rules handling the invocation of the suboperations of a userdefined operation is said to execute the operation. we concentrate on these rules here. so, let us assume that there is(among many other nodes) a waiting process of a user-defined operation in the system state(technically, there is a complexprocess node with status=#waiting that is connected to a node).



in the simplest case(if there is no statechart diagram for the class of the sending classifier role) we only need one single rule for sending a message. the framework of the rule differs depending on the kind of message. in the following let us consider a message that calls a user-defined operation.



activator process. we assume that in the preceding rule application a proper process node has been marked with a loop. thus, it is not necessary to connect this node to an operation node now. this allows for recursive operation calls in spite of injective matching. a proper activator process is connected to the operation op a of class c a and has the status#waiting if the message we want to send by this rule has no predecessors in the collaboration diagram, and#active otherwise.



ute of op b and c b are set accordingly(e.g., to establish resp. icqsession). an nac not shown here ensures that dynamic dispatching works correctly. finally, there is an object node o connected to c b. that is the object the operation will be invoked on.



for each parameter par b i of op b we add a localvar node v b i with the same name and type. each v b i is connected to p b. so the newly created process has a local variable for each parameter. the value attributes of the v b i,...,v b n are set according to the arguments of the message as given in the collaboration diagram.



if a called operation has parameters, they are given as ocl argument expressions in the collaboration diagram. these expressions can be used unchanged in the rules as described above. however, such an ocl expression can contain variables that have to be bound when applying the rule and evaluating the expression. the message can contain only variables that are known in the context of the activator process.



let var 1,...,var m be the free variables contained in the argument expressions. then for each var i we add a localvar node v a i in both sides of the rule, where the name attribute of v a i is set to the constant var i and the value attribute is set to a variable that is also named var i. all these localvar nodes are connected to p a. when applying the rule with any match, the match binds each var i to a concrete value, so the expressions can be evaluated and the result is inserted into the system state graph.



if the message under consideration is sent via an association role with the stereotype local, it means that the receiver of the message is referred to in a local variable of the activator process. the name of this variable is given as the role name of the receiving classifier role. so we add a localvar node in both sides of the rule and connect it to p a. its name is set to the role name from the collaboration diagram and its value is set to the receiving object o. in this way we ensure that by applying the rule the process is attached to the object that is stored in the specified local variable.



when a message is sent via an ordinary association role, i.e., an association role without any stereotype, the modeller has not yet specified how to determine a concrete receiver object. the only demand is that it is linked with the sender object with a link compliant to the association role. this is ensured in the rule by additional nodes and connections.



so far, a rule created only one process, i.e., sent one message. when several messages are specified to be sent in parallel in the collaboration diagram, all those messages are sent by one single rule. for each classifier that receives one of these messages, there is an object node in both sides of the rule. two messages sent to the same classifier role result in two processes attached to the same object node. the procedure for the single messages is as described above.



a statechart diagram can be given for a uml class to specify in which order operations on an object of the class may be executed. in our chat example, the establish operation is allowed to execute only when the session is in the state pending. we assume that operations of a class that do not occur in the statechart for the class are allowed to be executed at any time. the statechart also specifies in which state the object is after an operation has been finished. in our example, the state of a session changes to ready as soon as the establish operation has been finished.



because the statechart specifies whether an operation is allowed to execute, we have to modify the rule that starts the operation by sending the first message(or several parallel first messages). let us assume we construct the rules that send messages according to a collaboration diagram for an operation of a class. furthermore, let us assume that there is a statechart for this class and there are n transitions labeled with the operation. then we split the rule that sends the first message(s) of the collaboration diagram into n versions that differ from each other by the state nodes attached the object node and by an optional application condition. this application condition holds the ocl expression given by the optional guard of the considered transition. for this reason the rule is only applicable if the guard evaluates to true.



we have shown a translation from a uml model into a graph transformation system in order to give a precise formal semantics for a large part of uml. in this paper, we concentrated on the construction of graph transformation rules that represent the sending of messages as specified in a collaboration diagram. at the beginning, an example model has been introduced focusing on a collaboration and a statechart diagram. then, we have described the concept of a system state being a graph representing the current state of the modeled system and being transformed by graph transformation rules as the system evolves. in the central section, we have described in a general way



future work comprises the completion of the tool, including a user-friendly gui. then our approach can be evaluated in case studies that provide feedback on its usefulness. furthermore, we will investigate how the approach can be extended with uml features not covered yet. this includes additional features of already covered diagram types but also entire diagram types like activity diagrams. another important issue that has to be studied more extensively is how our approach allows to assert properties of uml models by examining the resulting graph transformation system.



