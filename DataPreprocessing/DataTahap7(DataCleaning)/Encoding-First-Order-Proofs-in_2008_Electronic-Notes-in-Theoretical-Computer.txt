our original chewtptp-sat implementation performed well on some problems, but some of the encodings created huge sets of clauses. some parts of our encoding represented choices made, such as which clause to extend each literal with. but other parts of our encoding represented deterministic procedures, such as deciding the consistency of unification constraints and deciding the acyclicity of the dag, which verifies that a particular property holds of the dag. furthermore, in experimental results with horn clauses, approximately 99% of the clauses generated were encoding the determinstic procedures, and only about 1% represented the choices. we had an eager encoding of unification and acyclicity. we decided the implementation would be more efficient if



in this paper, we describe our implementation of chewtptp-smt, and compare our results with chewtptp-sat. we show that in the horn encoding, chewtptp-smt produces far fewer clauses than chewtptp-sat. the time needed to decide the satisfiability is also drastically reduced. this is not the case for non-horn clauses. we explain why this is the case and give a rule of thumb for when theories should be used for encoding.



our implementation allows the user to decide whether chewtptp encodes the problem as a sat problem or an smt problem. if the user chooses smt, our implementation uses yices to test the satisfiability of the encoding. if the user chooses sat, then the user can also choose whether to test the satisfiability using yices or minisat, with a dimacs encoding of sat.



we wanted to see if working modulo theories would improve the performance of chewtptp. in the horn case the running time was reduced significantly, except for a small percentage of exceptions. in the non-horn case, working modulo theories often increased the running time. generally, yices was faster than minisat on sat problems without theories.



we believe we have an explanation for our results. in the horn problems the number of clauses is reduced by an order of magnitude, whereas in the nonhorn problems the number of clauses is not reduced by much. this implies that working modulo theories is only useful when the clauses size is reduced significantly.



the theories of yices, so we have kept the propositional encoding. therefore, when we remove the encoding of unification and acyclicity, the entire coding of the problem is still o(n3). we conjecture a good rule of thumb for deciding when it is useful to encode properties using theories. we conjecture that if the number of clause can be reduced by a factor of n, then the coding is useful, but if the asymptotic complexity remains the same, then it is not a good idea.



