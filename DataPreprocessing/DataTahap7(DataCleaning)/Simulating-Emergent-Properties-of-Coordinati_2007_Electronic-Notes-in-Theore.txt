first made in the context of natural systems, it was shortly recognised as an inspiring metaphor for artificial systems as well. a main aspect of emergent properties, however, is that by their very definition they cannot be achieved through a systematic design: their dynamics and outcomes cannot be fully predicted. providing some design support in this context is still possible. the whole system of interest, that is the application and the environment, can be modelled as a stochastic system, namely, a system whose dynamics and duration aspects are probabilistic. in this scenario, simulations can be run and used as a fruitful tool to predict certain aspects of the system behaviour, and to support a correct design before actually implementing the application at hand.



this scenario is particularly interesting for coordination models and languages. some works like the tota middleware, swarmlinda, and stochastic klaim, though starting from different perspectives, all develop on the idea of extending standard coordination models with features related to adaptivity and self-organization. they share e.g. the idea that tuples in a tuple space eventually spread to other tuple spaces in a non-deterministic way, depending on timing and probability. accordingly, our goal is to analyse the potential role that simulation tools can have in this context, towards the identification of some methodological approach to system design.



another example architecture is the swarmlinda coordination model, which though similar to tota is more inspired by swarm intelligence and stigmergy[3,8,9]. in swarmlinda, ant-like algorithms are used to retrieve tuples in the distributed system. the use of selftechniques in swarmlinda derives from necessity of achieving adaptivity when dealing with openness and with the unpredictability of user interactions.



in particular, following the work on foundational calculi for interaction, we identify the stochastic dimension as a crucial one in system modelling. a stochastic system is a system where the evolution in time is aleatory. on the one hand, this can be used to abstract away from implementation specific issues, by just stating that a process will take some time to execute. on the other hand, advancement in time is tracked, and its variability is accounted for, by considering the execution time as an aleatory variable distributed according to a specific distribution of probability.



first of all, sorts for a system state(state), an action(action), and a multiset of states(states) must be provided. a constructor operator is introduced to let the juxtaposition of two states be of sort states. that operator is then declared to be commutative(comm) and associative(assoc): this is used to state that a states represents a(non-void) multiset of elements of sort state.



then types effect and effects are defined. the operator#->[] is used to construct an effect. a term of the kind a#f->[ss] means that in a certain system state, action a can be applied with rate f, which moves the system to any state in the multiset of states ss. an operator; is then specified to state that sort effects represents a list([assoc]) of elements of sort effect, separated by semi-colons, and with constant nil representing the empty list.



finally, the user must implement the predicates temp and quit. the temp predicate is defined over states so as to mark a given state as temporary, thus preventing the engine from adding it to the simulation trace. the quit predicate is instead used to check if/when a simulation has to be stopped, for the system seemingly reached a final state. these two predicates come with default implementations, both yielding false.



types and constructors for the concepts of(i) step,(ii) steps, and(iii) observations are first introduced. a step represents a simulation step, whose structure is[n:s@f], where n is a countdown counter of the simulation, s is the current system state, and the float f is the elapsed time since the beginning. a steps element is a list of steps separated by commas, while an observations element is a list of observations separated by commas.



then, sort trace is defined. a trace represents the outcome of a simulation stn<ob1,ob2,...,obn>, where: stn is a step that represents the current state of the simulated system, and ob1,ob2,...,obn is a list of observations providing a view on the system evolution.



function move in the module implements the single-step behaviour of the simulation engine. it takes a step and produces the next one, randomly, by properly using the functions defined both in stochastic-selection and in stochastic-traces-functions. in particular, as the event@(nn,ff) is computed from the currently available rates, the simulation counter decreases(from(s n) to n in peano notation), the elapsed time increases of ff, and finally the new state ss is obtained by applying the nnth action(by means of the newstate function). note that the move function works if the simulation counter did not reached zero.



we considered a multiagent system where the environment is structured and populated with items of different kinds: the goal of agents is to collect and move items across the environment so as to order them according to a shared criterion. this problem basically amounts to clustering: homogeneous items should be grouped together and should be separated from different ones. moving to a typical context of coordination models and languages, we consider the case of a fixed number of tuple spaces hosting tuples of a known set of tuple types. the goal of agents is to move tuples from one tuple space to the other until the tuples are clustered in different tuple spaces according to their tuple type.



nature is a rich source of simple but robust strategies: the behaviour we are looking for has already been explored in the domain of social insects. ants perform similar tasks when organizing broods and larvae: this class of coordination strategies are generally referred to as collective sort or collective clustering. although the actual behaviour of ants is still not fully understood, there are several models that are able to mimic the dynamics of the system. ants wander randomly and their behaviour is modelled by two probabilities, respectively, the probability to pick up pp and drop pd an item where k1 and k2 are constant parameters and f is the number of items perceived by an ant in its neighborhood: f may be evaluated with respect to the recently encountered items. to evaluate the system dynamics, apart from visualising it, it can be useful to provide a measure of the system order. such an estimation can be obtained by measuring the spatial entropy, as done e.g. in. basically, the environment is subdivided into nodes and pi is the fraction of items within a node,



