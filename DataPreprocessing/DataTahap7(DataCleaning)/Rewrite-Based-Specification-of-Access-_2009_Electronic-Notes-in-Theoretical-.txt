we apply our technique on two well-known models in the computer security literature. we consider the security model proposed by mclean in, whose intention is to generalize the bell and lapadula model for dealing with joint access. we show that confidentiality is compromised when some simplifying assumptions made in order to relate the general framework for joint access with blp are taken.



and section 4 presents the encoding of the two policies in tom. section 5 shows how these models can be checked and proposes some optimizations used to cut the search space to speed-up the execution of the verification process. in section 6 we discuss some related works and conclude the paper.



bell and lapadula have formalized the concept of mandatory access controls[2,3] originally targeted to the military domain. the essence of the blp model is to augment discretionary access controls, represented in an access control matrix, with mandatory access controls to enforce information flow policies. without loss of generality, we focus only on the mandatory part in this paper, which is really specific to the blp model. therefore we do not describe how the contents of the access control matrix can be modified by subjects, but we consider that the current state of the system is exactly the set of access tuples the matrix contains. also, the notation and precise formulation of the rules of blp used here are substantially different from those of the original bell-lapadula work, since we use a more up-todate interpretation of these concepts in line with our formalism.



and the-secure property. the first property states that if a subject performs a read access on an object then the level of the subject dominates that of the object. the second one allows a user reading from an object o1 to write only objects whose levels dominate that of o1. intuitively, this means that information read from one level cannot be disclosed towards lower level objects. we should point out that write access is interpreted here as write only.



from a practical point of view, the-property would not be applied to human users, but rather to programs. human users are trusted not to leak information. a secret user can write an unclassified document because we assume that he or she will put only unclassified information in it. programs, on the other hand, are not trusted because they can embed trojan horses. the-property prohibits a program running at the secret level from writing to unclassified objects, even if it is permitted to do so by discretionary access controls.



the algebra of security of mclean is seen as a generalization of the blp model. one of the new concepts introduced in this approach is joint access, which is the capability to express that a given task must be accomplished by a set of subjects concurrently. in the military field, this allows to capture the idea that two individuals need to command at the same time a missile launch, for instance. privileges are then represented as tuples of the form(s, o, x), where s is a non-empty set of subjects, o is an object and x is an access mode.



tom is a language extension which adds new matching primitives to existing imperative languages, and in particular java. this is particularly well-suited for describing transformations on structured entities like trees/terms. the language provides support for matching modulo associativity and neutral element, which is particularly useful to manage lists of objects and to model the search space exploration.



the main originality of this system is its integration into existing languages, which makes it possible to use efficient and well-designed runtime libraries. for example, in the presented work, we make an intensive use of the collection framework provided by the java api. from an implementation point of view, tom is a compiler which accepts several native languages as input, like c or java, and whose compilation process consists in translating the matching constructs into the underlying native language. for an interested reader, design and implementation issues related to tom are presented in[10,1].



this example should be read as follows: given a term a(that represents an access), the evaluation of%match prints"same level" if the involved subjects and resources have the same security level and"denied" when the access is not authorized. this is implemented by non-linear pattern matching: l1 occurs twice in the first pattern. the reader should note that variables do not need to be declared, their type is automatically inferred from the definitions of the operators using them. the action associated to a pattern is a java statement which can be guarded using the classical if construct. in the second pattern, we retrieve the two security levels l1 and l2, and we assume that< is an order that makes their comparison possible. when l1 is less than l2, the"denied" message is printed.



the levels from each list are comparable with the first element being the lowest and the last the biggest. when the security levels are totally ordered the lattice is specified by only one list containing all the security levels. for example, the order introduced in section 2.1 can be encoded by sllattice(slset(sl("unclassified"), sl("confidential"), sl("secret"), sl("top secret"))). we should mention that no check is done on the coherence between the orders specified by each list but this can be easily done by extending the construction functions of sllattice and slset with explicit rewriting rules.



a given state is not valid w.r.t. the blp policy if one of its current accesses is a read access involving a resource with a security level which is not lower than that of the concerned subject(1) or if the state is not-secure(2). the validity of a state depends on the current state and on the security levels lattice of the given instance of the policy. the attribute sll defines this lattice of security levels for the corresponding policy and it is initialized when an instance of the tom class encoding the given policy is created.



and implicit accesses, we rely on the hook mechanism provided by gom. a hook is a specialization of a construction function. instead of just allocating the memory to represent a constructor of the signature, a hook performs some additional treatments ensuring that the resulting term is in a particular canonical form. in our case we want to ensure that the implicit accesses are always represented in a state. this is implemented by specializing the insertion of an access e in a list l and by considering four cases:



