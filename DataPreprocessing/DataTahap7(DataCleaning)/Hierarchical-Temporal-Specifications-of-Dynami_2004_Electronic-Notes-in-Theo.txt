the notion of subsystem provides an extra coarse grained unit of modularisation, that complements that of components. since component interaction is achieved by means of coordination,a component or subsystem can be represented by a logical theory isolated from the rest of the system. this, in combination with the possibility of hierarchically organising a specification, has a special impact in reasoning, since it allows us to further localise the proof efforts to the relevant subparts of a specification.



in this section we describe a language over which the study of hierarchical subsystems is based. the language is prototypical, and should not be regarded as a real adl. it is intended to be just a means to study more abstract and declarative ways of describing software architectures, and to probe the capabilities of our proposed formalism.



this logic is a variant of the manna-pnueli logic, in which the flexible symbols, i.e., those whose interpretation is state dependent, have been generalised. unfortunately, due to space restrictions, we are unable to discuss more details regarding this logic. we refer the interested reader to for details on the original manna-pnueli logic, and to for a detailed description of our variant of the logic.



action get obtains an incoming message from the environment. it has as a precondition that in must be true(there is a message waiting to be obtained) and curr-in must be null(no incoming messages are overwritten before being consumed)(see axiom 4). after get(m) occurs, curr-in becomes m in the next state(see axiom 5). action cons consumes a previously obtained message, provided that the incoming message is addressed to the component(see axioms 6-7). if a previously obtained message is not addressed to the component, it can be removed using the rem() operation(see axioms 8-9). actions prod and send are meant to produce and send messages, respectively. they are characterised by axioms 11-14.



we choose to define class definitions as closed independent units. that is, we do not allow classes to refer to other classes within their definitions. this is an important point, since from a logical point of view it allows us to reason about component properties independently of the rest of the system. but, of course, we need ways of making components interact. we achieve communication between components by using the useful concept of coordination. in this respect, our means for communication are very close to those of community, although we allow for more flexibility. to make components interact we define associations. associations are composed of a set of participants and a number of formulae, which characterise the interaction.



in a previous work, we defined subsystems as complex components whose internal state is dynamic, and is built out of instances of classes(i.e., components) related by means of instances of associations(i.e., connectors). we want now to extend that, to allow subsystems not only to be composed of instances of classes, but also to subsume instances of simpler subsystems, thus allowing for hierarchical organisations of systems. as a result, we would have two types of component definitions: classes, which define simple unstructured components(i.e., the base case of the process of defining aggregations), and subsystems, which define complex components whose structure is built out of instances of simpler components. this is feasible thanks to the fact that the semantics of basic components and aggregations are defined in a similar way, by means of temporal theories, and therefore there are no technical restrictions for iterating the process of defining aggregations.



let us then propose an extended notation for subsystems. let adt name be a conservative extension of adt with an extra sort name and a sufficiently large set of constants of this sort. constants of sort name are used to represent identifiers of components of the lower layers. a subsystem signature is composed of:(i) a name,(ii) finite sets of basic attributes and basic read variables, typed by a sort of adt name,(iii) a finite set of operations, whose arguments are typed by sorts of adt name.



n.address in axiom 6). these prefixes are actually a convenient way of denoting the extra name-typed argument incorporated in the read variables, attributes and actions of the class and subsystem definitions of the lower layers. that is, expressions such as n.address and n.c-init(x) actually correspond to address(n) and c-init(x, n), respectively.



even for simple systems, specifications tend to be large and complex. although modularisation mechanisms help in alleviating the proof efforts, software tool support is a necessity. at the moment, we are experimenting with the use of the stanford temporal prover(step) in order to assist in the proofs in our logic.



