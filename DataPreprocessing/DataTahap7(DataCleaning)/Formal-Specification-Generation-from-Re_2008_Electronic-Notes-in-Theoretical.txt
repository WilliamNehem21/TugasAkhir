we propose a strategy that automatically translates use cases, written in a controlled natural language, into specification in csp process algebra. for obvious reasons, it is not possible to allow a full natural language as a source. we define a subset of english, which we call controlled natural language(cnl), with a fixed grammar, in order to allow the mechanized translation into csp.



the context of this work is a research cooperation between cin-ufpe and motorola called cinbtcrd. therefore, the proposed cnl reflects this domain. the formal model generated in csp is used as input by other tools developed in this project. this model is internally used by these tools to automatically generate test cases, both in java(for automated ones) and cnl itself(for manual ones).



unlike the cited approaches, which focus on translation at a single level, we consider use case views possibly reflecting different levels of abstraction of the application specification. this is illustrated in this paper through a user and a component view. we also explore a refinement relation between these views; the use of csp is particularly relevant in this context: its semantic models and refinement notions allow precisely capturing formal relation between user and component views. the approach is entirely supported by tools. a plug-in to microsoft word 2003 has been implemented to allow checking adherence of the use case specifications to cnl grammar. another tool has been developed to automate the translation of use cases written in cnl into csp. finally, fdr, a csp model checker, is used to check refinement between user and component views.



section 2 gives an overview of the proposed approach. in section 3 we present the templates defined to write use cases in cnl and tools that ensure its correct usage. section 4 focuses on the translation from use cases in cnl to models in csp. in section 5 we explore a refinement relation between csp models describing user and component views and how this can be mechanically checked using fdr. section 6 summaries our contributions and suggest topics for further research.



the language used to write these use cases is a controlled natural language(cnl), a subset of english relevant to the specific domain. using cnl it is possible to write imperative and declarative sentences. an imperative sentence describes actor actions and a declarative sentence depict system characteristics, such as a gui description, or the system state. cnl is necessary to restrict vocabulary used to write use cases; its grammatical rules are defined through knowledge bases that map verbs to csp channels and verb complements to values of csp datatypes. besides aiming at automatic generation of formal models, the use of cnl also prevents the introduction of ambiguous sentences in the use case specification, therefore contributing to the quality of documentation.



finally, the relation between user and component use cases is established by a mapping from the more abstract to the more concrete model. this event mapping relation is used to prove that the component view model is a refinement of the user view model. the following sections detail the steps of the strategy.



there are situations when user can accomplish more than one action given the current system state. when this happens it is necessary to define one execution flow for each of the possible actions. execution flows are categorized as main, alternative or exception flows, based on their nature. the existence of alternative and exception flows is also related to the system state column. at a given state, the system may respond differently given the same user action. in this case, it must be specified a different system state for each of the possibilities.



the system state column is mainly used to specify conditional situations. note that this example captures one exception flow. the normal execution of the main flow would pass through the step 2m, and go on until the end of the main flow. the exception execution goes from step 2m to step 1e, when the message storage is full(system state). in this case, given the same select move to important messages option user action, depending on the system state a different system response is presented.



in the component view it is necessary to define the component that is invoking an action and the one that is providing the service. it is a message exchange process composed by a sender,a receiver and a message. the user is actually viewed here as a component, and can either send or receive messages to or from other components. a component can also send a message to itself. the idea of execution flows is the same as in the user view and the system state column plays the same role as previously described in the user view.



the case frame defines the relation between verbs, terms and modifiers. each case frame determines how a verb can be used to instantiate a sentence. we use the case grammar formalism that contains information about the input domain verbs and its thematic roles, which can be an agent or a theme of the sentence. when and the other is implemented in java. the.net module is a gui program that accomplishes the cnl validation within word. the java module is the natural language processing(nlp) unit responsible to verify if sentences are written according to cnl rules. more details about the nlp module implementation can be found at.



the csp process algebra is the target formalism of our strategy. csp allows the description of systems in terms of processes that operate independently, and interact with each other through message-passing communication. the relationship between processes is described using process algebraic operators from which complex process compositions can be constructed from few primitive constructors.



the behavior of a csp process is described in terms of events, which are atomic and instantaneous operations, such as open or close, which may transmit information. as an example, the communication open!door outputs the value door through the channel open. there are two primitive processes: stop and skip. stop communicates nothing and stands for a canonical deadlock; skip represents successful termination.



based on the presented cnl knowledge bases, we define the csp alphabet channel names and the datatypes of the model. the verbs determine csp channel names. each class from the ontology defines a csp datatype. the terms and modifiers from the lexicon are related to classes from the ontology and therefore define datatype values. using these mappings and the case frame definitions, it is possible to translate each sentence from the use cases into csp events.



the component view model is quite different from the user view one. the component channels contain information about the components involved in the message exchange and its name is suffixed by comp, making the user and component view csp alphabets different. the datatypes used in both views are the same; since both use cases refer to elements from the same domain.



a tool has been implemented to mechanize the translation of the user and the component views into csp models. it reads user and component views use cases as word 2003 document files, checks its content(invoking the tool presented in section 3.5), and generates the user and the component models. the nlp module is once again used to translate cnl sentences into csp events. this application itself accomplishes the arrangement of these events based on the use case structure so the csp model can be generated.



modeling systems at different levels of abstraction has the advantage of capturing several architectural views, as illustrated here with the user and the component views. nevertheless, it is essential that the several architectural views produced are consistent. in general, these views are expressed using different alphabets(event names) so a relation is needed in order to compare them. one or more events from one model can be related to one or more events of another model. defining a relation allows replacing abstract events with more concrete ones, formally keeping track of the relationship between the models.



this paper defines only two abstraction levels, user and component views. however, the strategy presented in this section can be generalized for an arbitrary number of views. use case engineers can define new use case templates and propose new ways to map events from use cases written at different levels of abstraction.



the process that represents the mapping is composed, through an alphabetized parallel composition, with the abstract model. this composed process contains events from the alphabet of both views. once the events from the abstract model are hidden, it produces a process that is refined by the concrete model. the mapping process works as a trigger from one view to another; events executed in the abstract model force the execution of the related concrete events.



when analyzing the user view use cases, it is also possible to retrieve information about the use cases relation. the link between execution flows(from steps and to step) can be seen as a uml inclusion operator between use cases. once an execution flow starts from other flow, it includes this latter flow steps in its definition.



are several approaches related to model based-testing that use system specifications to generate test cases. in particular, the user view models generated by the presented strategy are used in the cinbtcrd research project to automatically generate test cases based on test purposes. there is also complementary work in the cinbtcrd research project that uses the proposed component view model to generate uml diagrams; in a set of laws is proposed to map csp specifications into uml-rt diagrams, which is now part of uml 2.0.



the proposed model refinement strategy, through events mapping, and the use case validation approach can also be used as an important step toward automating test case execution. the execution of user actions based on atomic events, associated with automatization of test case verification would enable the execution of test cases generated from the model. along with code generation, test scripts generation is a possible topic for future investigation associated to our strategy.



