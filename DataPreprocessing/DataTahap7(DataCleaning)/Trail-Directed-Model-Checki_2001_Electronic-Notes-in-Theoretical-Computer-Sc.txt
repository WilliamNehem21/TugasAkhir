the formal methods of model checking have various applications in software veri cation. through the exploration of large state-spaces model checking produces either a formal proof for the desired property or a detailed description of an error trail. we concentrate on explicit state model checking and its application to the validation of communication protocols.



in the broad spectrum of techniques for tackling the huge state space that are generated in concurrent systems, heuristic search is one of the new promising approaches for failure detection. early precursors execute explicit bestrst exploration in protocol validation and symbolic bestrst search in the model checker mur. symbolic guided search in ctl model checking is pursued in and bypasses intense symbolic computations by so-called hints. last but not least, the successful commercial uppaal veri er for realtime systems represented as timed automata has also been e ectively enriched by directed search techniques.



our own contributions to directed model checking integrate heuristic estimates and search algorithms to the cke model checker, to a domain independent ai-planner, and to a promela model checker[9,10]. the global state space is interpreted as an implicitly given graph spanned by a successor generator function, in which paths corresponding to error behaviors are searched. the length of the witness path is crucial to the designer/programmer to debug the erronous piece of software; shorter trails are easier to interpret in general.



in this paper we concentrate on error trail improvement, an apparent need in practical software development. we expect that a possibly long witness for an error is already given. this trail might be found by simulation, test, random walk, or depthrst model checking. the witness is read as an additional input, reproduced in the model and then signi cantly improved by directed search.



the paper is structured as follows. first we give some background on the ai technique we use. in a next section we introduce the hsf-spin model checker and its usage in terms of its command line options. in the following sections we address the facets of trail-directed search, based on the hamming distance and the fsm distance. we distinguish between single-state trail directed search for safety errors and cycle-detection trail-directed search for liveness errors. both approaches have been implemented in hsf-spin and in the experimental section we present rst results. we close with some concluding remarks.



depthrst search and breadthrst search are call blind search strategies, since they use no information of the concrete state space they explore. on the other hand, heuristic search algorithms take additional search information in form of an evaluation function into account. this function is used to rank the desirability of expanding a node u.



a* uses an evaluation function f(u) that is the sum of the generating path length g(u) and the estimated cost of the cheapest path h(u) to the goal. hence f(u) denotes the estimated cost of the cheapest solution through u. if h(u) isa lower bound then a* is optimal, i.e. it nds solution paths of optimal length.



like in spin, two steps must be performed prior to the veri cation process. the rst step generates the source code of the veri er for a given promela speci cation. in the second step, the source code is compiled and linked for constructing the veri er. the veri er then checks the model. among other parameters the user can specify the error type, the search algorithm, and the heuristic estimate as command line options. it is also possible to perform interactive simulations similar to spin. when veri cation is done, statistic results are displayed and a solution trail in spin's format is generated.



the veri er runs depthrst search, since it is the default search algorithm. it nds a deadlock at depth 1,362. following such a long trail is tedious. the a* algorithm(option-aa) and a simple heuristic estimate for deadlock detection(option-ha) nds a deadlock at optimal depth 34, expanding and storing less states(17 and 67, respectively), and performing less transitions(73).



set and x is the value for the option. for example, argument-ad sets the option search algorithm to the value depthrst search. by giving an option no value, the list of available values for that option is printed. for example, executing check-a prints all available search algorithms.



executing the hsf-spin veri er without arguments outputs all available run-time options, e.g.-ax, where x is the search algorithm(a*, ida*, dfs, ndfs, etc.);-ex, where x is the error to be checked(deadlock, assertion, ltl, etc.); and-hx, where x is the heuristic function(formula-based, hamming distance, fsm distance, etc.).



since various explicit on-they model checkers like spin search the superimposed global state space in depthrst manner, they report the rst error that has been encountered even if it appears at a high search depth. one natural option to improve the trail is to impose a shallower depth on the depthrst search engine. however, there are two severe drawbacks to this approach.



the rst one is that bounds might increase the search e orts by magnitudes, since a xed traversal ordering in bounded depthrst exploration in large search depths might miss the lasting error states for a fairly long time. therefore, even if the rst error is found fast, improvements are possibly dicult to obtain. moreover, to nd shorter trails by manual adjusting bounds is time consuming, e.g., trying to improve an optimal witness will fail and result



we have observed this behavior in some of our models. for example, in a model of a telephony system after establishing a witness of length 756, the search with a new bound 755 fails to nd one of the remaining error states. for the same promela model, error detection alternates with di erent search depths bound: up to bound 67 no error is found, from bound 68 to 139 an error is found, from bound 140 to 154 no error is found, from 155 onwards an error is again found, and so on.



therefore, we aim at a di erent aspect of trail improvement; namely heuristic search. the idea is to take the failure state or some of its de ning features to set up a heuristic estimate that guides the search process into the direction of that particular state. in contrast to heuristic search strategies described in previous work[9,10], we exhibit re ned information. the main argument is that it is easier to nd a speci c error situation instead of nding any member according to a general error description. we distinguish two heuristics and two search algorithms. the rst heuristic is designed to focus exactly the state that was found in the guidance trail, while the second heuristic relaxes this requirement to important aspects for the given failure type. the two algorithms divide in trail-directed search for safety property violation and trail-directed search for liveness property violation.



h(s; s0) is not a lower bound, since one transition might change more than one bit in the state description at a time. moreover, the hamming distance can be re ned by taking the binary encoded values of the state variables and their modi ers into account. nevertheless, the hamming distance reveals a valuable ordering of the states according to their goal distances.



let(pc1;:::; pcl) be the vector of all fsm locations in a state s, i.e. pci, i 2 f1;:::; lg, denotes the corresponding program counter. the fsm distance metric h(s; s0) according to the goal state s0 with fsm state vector



in our case we extract the error state s0 to focus the search by the above heuristics h(s; s0) and h(s; s0). these estimates are integrated in the heuristic search algorithm a*. recall that is complete, and that, if the estimate is a lower bound, the path is optimal.



while previous work on directed model checking concentrates on detecting unknown error states, the paradigm of trail-directed model checking contemplates the improvement of trails result from error detections, simulations, etc. on the other hand, although paths to errors could be improved with directed model checking, the new paradigm proposes richer heuristics based on the information of a singleton given error states. moreover directed model checking is restricted to safety properties, while trail-directed model checking is able to improve error trails corresponding to such type of properties.



one early approach for focusing trail information is diagnostic model checking for real-time systems. it also shifts attention to highlight failure detection, but does not clarify why the established traces are improved compared to ordinary failure trails. another line of research aims not only to report what went wrong, but explain why it went wrong. however, most approaches in this class such as assumption truth-maintenance systems implemented in the general diagnostic engine(gde) turn out to scale badly.



at the moment we concentrate on spin's promela speci cation language, but in future we are interested in verifying real software in java and c. the bandera tool developed at kansas university allows slicing of distributed java-programs with an export to either spin or smv. the same research line is pursued by the automated software engineering group at nasa ames research center that apply a java byte code veri er, called java path finder. on the other side, holzmann has pushed the envelope for actual c-code veri cation with the spin validator.



s. edelkamp. directed symbolic exploration and its application to ai-planning. in aaai-spring symposium on model-based validation of intelligence, pages 84{92, 2001. precursor s. edelkamp, directed symbolic exploration in planning published in european conference on arti cial intelligence(ecai), workshop on new results in planning, scheduling and design(puk-2000).



g. j. holzmann and m. h. smith. software model checking: extracting veri cation models from source code. in formal description techniques for distributed systems and communication protocols, protocol speci cation, testing and veri cation(forte/pstv), pages 481{497. kluwer, 1999.



