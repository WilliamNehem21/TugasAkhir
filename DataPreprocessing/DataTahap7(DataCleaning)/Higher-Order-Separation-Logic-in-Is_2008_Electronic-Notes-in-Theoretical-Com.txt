we formalize higher-order separation logic for a first-order imperative language with procedures and local variables in isabelle/holcf. the assertion language is modeled in such a way that one may use any theory defined in isabelle/holcf to construct assertions, e.g., primitive recursion, least or greatest fixed points etc. the higher-order logic ensures that we can show non-trivial algorithms correct without having to extend the semantics of the language as was done previously in verifications based on first-order separation logic[2,20]. we provide non-trivial examples to support this claim and to show how the higher-order logic enables natural assertions in specifications. to support abstract reasoning we have implemented rules for representation hiding and data abstraction as seen in.



we now give a brief overview of the technical development. in section 2.1 we define the syntax of our programming language using a deep embedding of commands(by defining a new inductive type of commands) and a shallow embedding of expressions.



semantics of the programming language. the definition makes use of the implementation of basic domain theory in isabelle/hol(isabelle/holcf). we also define the frame property expressing that commands behave locally, as needed for the verification of the frame rule, and prove that the meaning of any command satisfies the frame property.



our model of the language uses a shallow embedding of expressions and a deep embedding of commands. this enables us to focus on the separation logic for commands. of course, a real programming language will have a proper syntax for expression; the idea is that any such expression can easily be given meaning in our shallow embedding, and thus modeling its syntax only complicates the implementation and the uses thereof. in this presentation we use the syntax commonly seen in presentations of separation logic.(this makes the presentation easier to read, but as many of the symbols are already used in isabelle/holcf and cannot be overloaded, the syntax of this presentation and the syntax used in our implementation are slightly different.) satisfies the partial correctness properties set out in the definition of validity, i.e., if p holds of a given heap and store then the procedure, executed in that state, does not abort, and if the procedure terminates then q holds of the resulting heap and store.



given the representation assumptions above we need an appropriate heap invariant. disallowing skewed sharing enables us to express every record by a precise formula and then use the separating conjunction to glue it all together. as the separating conjunction is associative and commutative this approach will give a unique set of heaps.



the main correctness criteria of a garbage collector is that it preserves the structure of the heap, i.e., the old heap and the new heap should be isomorphic, and it should preserve the heap invariant. to make this precise we define what it means to have a heap isomorphism.



first on the left subtree and then on the right subtree. as sketched in, if you give the procedure a pointer to a dag then the result will be a tree where any shared structure in the dag is copied multiple times to eliminate the sharing. we did the exercise of formalizing this proof in our isabelle/hol implementation. the exercise illustrates the use of higher-order separation logic to quantify over heap sets across a hoare triple, it exercises our proof rules for procedures, and lemma 3.4 is needed to simplify the assumptions about the procedure to what is originally sought. the proof also relies crucially on the rule for lookup in section 3.2. the main observation about this proof is that it fits entirely within higher-order separation logic in the sense that all the needed predicates are definable in our implementation.



future work includes further case studies of formal verification of programs, extending the formalization to languages with more features, e.g., concurrency, first class functions, and/or heaps with procedures. future work also includes more automated reasoning in higher-order separation logic with, for instance, tactics for entailment of higher-order separation logic formulas.



