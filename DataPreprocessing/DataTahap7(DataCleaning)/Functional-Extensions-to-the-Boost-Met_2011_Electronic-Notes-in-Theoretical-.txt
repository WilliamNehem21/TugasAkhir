more and more c++ applications use template metaprograms directly or indirectly by using libraries based on that. given the complexity of template metaprogramming, developers need supporting libraries. the most widely used one is the boost template metaprogramming library. it implements commonly used compile time algorithms and meta-data structures in an extensible and reusable way. despite the wellknown commonality of template metaprogramming and the functional programming paradigm, boost::mpl lacks a few important features directly supporting the functional style. in this paper we evaluate how and in what degree boost::mpl supports functional programming and present new elements it can be improved with.



in the last fifteen years major efforts were put into creating the foundations of template metaprogramming including meta data structures and algorithms. boost is one of the most important c++ library collections. the libraries are used by a wide range of c++ users and application domains. boost makes extensive use of templates and has been a source of extensive work and research into metaprogramming in c++. boost has a template metaprogramming library providing tools to build template metaprograms in a structured way. the library implements commonly used utilities and algorithms in an extensible and reusable way. it helps reducing the amount of boilerplate code in c++ template metaprograms.



to follow the functional paradigm directly, the tools have to be developed with functional programming in mind. we have developed a complex template metaprogramming library, that depends heavily on the functional paradigm. we were using the boost metaprogramming library. we have missed a number of tools that are commonly used in functional languages but are not yet available for c++ template metaprogramming. in this paper we evaluate some functional aspects of the boost metaprogramming library and propose new elements providing more direct support of functional programming. we have implemented these new elements and have used in the complex template metaprogramming library we built.



in this paper we introduce some extensions to the boost metaprogram library following the functional paradigm. in section 2 we discuss lazy evaluation of compile time selection, in section 3 we implement(meta)function composition, and section 4 overviews currying. related works are found in section 5 and we summarize our results in section 6.



value of a nullary metafunction can only be accessed explicitly. when someone accesses the value of a nullary metafunction, he has to access a nested type of the nullary metafunction. this nested type is called type. the first time the nested type is accessed, the c++ compiler evaluates the metafunction. this value is reused every time the nested type is accessed again later, during the same compilation. for example, here is a simple value:



this class can be passed to template metafunctions expecting a nullary metafunction: this class is a data-value and a nullary metafunction at the same time. this class as a nullary metafunction evaluates to itself, thus it represents itself when it is evaluated as a nullary metafunction. wrappers of static constants, such as int, bool support this: they have a nested type called type that is a typedef of the wrapper class itself. these classes can be passed to metafunctions expecting eagerly evaluated arguments, because these classes represent data values. these classes can also be passed to metafunctions expecting lazily evaluated arguments, because these classes are nullary metafunctions evaluating to themselves.



some calculation helper is evaluated lazily. when the condition in some calculation evaluates to false, some calculation helper is not instantiated, thus the invalid division is not evaluated and does not break the compilation. the problem with this solution is that we have to pollute the namespace with new classes and the code of some calculation is defined in multiple metafunctions.



the nested lazy eval if evaluates its condition only when the lazy eval if itself is evaluated. when the condition of the outer eval if evaluates to true, lazy eval if it not evaluated, thus its condition is not evaluated either. it guarantees, that when b is 0, the invalid division in the condition of lazy eval if is not evaluated and does not break the compilation.



we have considered implementing this solution in a more generic way using a template that makes the arguments of a metafunction lazy. unfortunately this can not be done. such a solution could delay the evaluation of the arguments until the metafunction is evaluated. all arguments of it would have to be evaluated at the same time. it means evaluating the condition and the true and false branches of the selection. this would evaluate the unused branch as well and when the evaluation of that branch leads to an error, it would break the compilation.



vesa karvonen wrote a fully lazy version of the standard template library as a proof of concept. in his library every template metafunction evaluates its arguments lazily. when someone has to pass a class without a nested type class pointing to itself as argument to a template metafunction, he has to wrap it with a template adding this capability. only a proof-of-concept implementation of this library is available.



solves the problem and keeps the business logic at one place. this was a simple example. when we have to deal with template metafunction classes instead of template metafunctions, it has a large syntactical overhead. when square and tan are template metafunction classes, this solution gets more difficult to write, understand and maintain. this is how the square tangent would look like, if square and tan were template metafunction classes:



we had to use complex tools to solve a rather simple problem which is applying a chain of functions on an argument. it is so common that functional languages often have a special operator for it in the language or the standard library. due to the functional nature of c++ template metaprograms introducing it in template metaprogramming could reduce the complexity of the code of metaprograms.



here we used compose to build the composition of the two metafunctions we have to apply on deg. compose is a metafunction class we can apply deg on to apply the functions on deg. it is evaluated lazily, the functions are applied only when the condition of eval if evaluates to false, thus the functions are not applied when it would lead to a compilation error.



this function takes 4 numbers as arguments: two opposite points of the rectangle. it takes 4 arguments in one step and calculates the result immediately. if this function was using currying, it would be a function accepting one number. the value of this function would be an anonymous function taking 1 number as argument. the value of that function would be another anonymous function taking 1 argument. the value of that function would be the area of the rectangle. it would be something like the following template metaprogram:



as you can see adding currying to a function by hand has a large syntactical overhead. it leads to writing a large amount of boilerplate code. we propose a template metafunction taking a template metafunction as argument and building the curried version automatically. the generated metafunction maintains a compile time list internally and every time a new argument is passed to it, it stores the argument in the list. when all of the arguments are available, it applies the full argument list on the original template metafunction.



we need a function that collects its arguments in a compile time list. the function takes the function to curry and the argument list collected so far as arguments. it has to take the number of arguments left as an argument as well.



using these functions we can implement our curry functions. these functions take metafunctions as arguments and build a curried version of them. template metafunctions are template classes, thus the argument of the curry functions will be templates. unfortunately we have to create different curry functions to handle template metafunctions taking different number of arguments. we call the curry function handling a template metafunction with n arguments curryn. for example the curry function handling template metafunctions with 4 arguments is called curry4. as an example, here is the implementation of it:



we had to use helper functions from boost::mpl. we used quote4 because curryimpl expects template metafunction classes while we had a template metafunction, thus we had to generate a metafunction class from it. we used unpack args because curryimpl passes the arguments of the metafunction as a compile time list to the metafunction class we call it with.



fc++ is a c++ library providing runtime functional programming support for c++. template metaprograms are always evaluated at compile time. the development of template metaprograms is different from runtime programs, thus they need different supporting tools to develop software following the functional paradigm.



