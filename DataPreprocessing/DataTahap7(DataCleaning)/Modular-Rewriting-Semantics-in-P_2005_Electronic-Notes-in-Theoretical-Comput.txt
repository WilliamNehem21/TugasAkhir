the proof of the pudding is in the eating. the practical use of a methodology must be demonstrated by convincing case studies. here we discuss two examples of quite different flavor: ccs, and bc. the gnu bc language is essentially a subset of c well suited for numerical computation that is part of the linux distribution and therefore is a real, yet medium-sized, language. another nontrivial case study on the use of our methodology, namely a rewriting logic semantics of concurrent ml can be found in.



3.1 is imported. there are two fields in the record of semantic entities: a trace of actions, with index tr, and an environment, with index env, keeping the context of(possibly recursive) definitions of process names. the trace component uses a list of actions from the module action-list, whereas the environment component uses sets of process definitions, called contexts, and defined in the module ccs-context. our maude syntax for actions, processes and contexts follows that in. the key module is of course ccs-semantics, which we later extend to weak-ccs-semantics.



in our modular rewriting semantics specification of bc in bc-rules.maude, the record has two main components: an environment and a store. therefore, variables in bc are simply environment bindings of variables identifiers to store locations. 1 applying the information-hiding principles, so that only abstract functions are mentioned in semantic rules, ensures that the actual details of:



a key point about the use of abstract sorts and functions in our proposed methodology is that we always remain free to change such concrete representations in a language extension, which could either change the concrete representations of stores and environments, or add new fields to the record, such as a field for input-output: the point is that the semantic rules will not have to be changed. we can illustrate these ideas by means of the extension units.maude of our bc semantics in the spirit of, so that a bc program can be annotated with information about the physical units(meters, seconds, kilograms, etc.) that it manipulates. in this extension, the concrete representation of stores has to be changed: they now map a location to a pair, with first component the concrete numerical value, and second component an abstract unit value, indicating which kind of unit the value corresponds to.



when the bc program print(x+ y); is evaluated in the context of an empty environment(< mt-env>) and an empty store(< mt-st>) the output is 0 but the resulting unit is fail. this is so because the units of x and y were not declared; therefore the unit of the addition is fail. such a declaration is possible using the annotation assume(not shown in the example) which would not generate a fail unit. the actual result depends on the specified unit algebra, but could be simply the unit of x.



