many modern program verifiers translate the program to be verified and its specification into a simple intermediate representation and then compute verification conditions on this representation. using an intermediate language improves the interoperability of tools and facilitates the computation of small verification conditions. even though the translation into an intermediate representation is critical for the soundness of a verifier, this step has not been formally verified. in this paper, we formalize the translation of a small subset of java bytecode into an imperative intermediate language similar to boogiepl. we prove soundness of the translation by showing that each bytecode method whose boogiepl translation can be verified, can also be verified in a logic that operates directly on bytecode.



many modern program verifiers such as esc/java, boogie, krakatoa, and caduceus verify programs in two steps. first, they translate the program and the specification into an intermediate representation such as guarded commands, boogiepl, or the why language. in the second step, they compute verification conditions for the intermediate representation and pass them to a theorem prover. using an intermediate language improves the interoperability of tools. for instance, krakatoa and caduceus translate java and c code to the why language, which allows them to share the why back end. moreover, simple intermediate representations facilitate the generation of small verification conditions through passification.



in this paper, we formalize the translation of java bytecode into an untyped version of the intermediate language boogiepl and prove soundness of the translation by showing that the verification conditions for the intermediate program are at least as strong as the corresponding verification conditions for the original program. our formalization and proof[6,14] cover a large subset of java bytecode. due to space limitations, we focus on a small, but interesting subset in this paper.



in this section, we give a brief overview of boogiepl and present a wp-calculus. for details, we refer to a report by deline and leino. to focus on the essentials of the bytecode translation, we use an untyped version of boogiepl in this paper. however, our full formalization works with the typed language.



boogiepl programs consist of a prelude and a list of procedures. the prelude specifies a background theory in first-order logic using global variables, constants, axioms, and uninterpreted functions. the procedures contain a specification and an implementation. in our translation, we do not use the procedure specifications. the implementation of a procedure starts with the declaration of all local variables, followed by one or more blocks. a block has a unique id, a body consisting of boogiepl commands, and ends with a non-deterministic goto, which specifies all possible successor blocks in the control flow graph. a goto with an empty list of block ids terminates the execution. boogiepl provides the following commands: assignment, call, assume, assert, and havoc. the havoc command assigns an arbitrary value to a given variable. in the following, we will reuse sort method for procedure names.



sh(m, l) yields the index of the top element of the operand stack before execution of the instruction at label l of method m. isedge(m, l1, l2) yields true iff there is an edge from label l1 to label l2 in the control flow graph of method m. if this is the case, isedgetarget(m, l2) yields true. the functions isbackedge and isbackedgetarget are analogous to isedge and isedgetarget, but consider only backward edges in the control flow graph.



local state: we use the global variable heap to model to heap of the current execution state. the operand stack is modeled by the variables stacki, where i denotes the height of the stack(starting with 0). the registers(representing the local variables and parameters) are modeled by variables regi. since the maximum height of the operand stack and the number of used registers is given in the class file, we know statically how many of the stacki and regi variables we have to declare in the boogiepl procedure.



a transition along a back-edge always closes a loop in the control flow graph. therefore, we can assume that the target of the back-edge has a local annotation for the loop invariant. in the translation, we eliminate the back-edge and instead generate an assertion that the loop invariant holds. a forward-edge is simply translated into a goto. this is done by the translation function tredge. which is defined for a list of possible successor labels ls.



ifgt: a branch instruction is translated into a non-deterministic goto to two successor blocks that assume the branch condition to be true or false, respectively. the true-block then jumps to the target label l'. to eliminate back-edges, we apply tredge at this point. the false-block is continued with the translation of the next



the actual method call is translated as follows: we assert that the receiver is not null and that the precondition of the callee holds. possible side effects of the callee are accounted for by havocing the heap. since the callee may terminate normally or abruptly, we continue with a non-deterministic goto.



for abrupt termination, we erase all information about stack0, which now contains the exception object. for simplicity, we do not consider the throws clause of the callee here, but simply assume that the exception is an allocated object of type throwable(typeof yields the runtime type of a value and<: denotes the subtype relation). we then assume the exceptional postcondition of the callee and jump to all possible handlers of the exception. a more fine-grained handling of exceptions using throws clauses is straightforward.



not considering back-edges. the base case covers all instructions that terminate the method, in particular, ireturn. all other instructions are covered by the induction step. in the following, we show one case of the induction step, namely the case where the instruction at label l is iload n.



by definition, instrpos yields the first position of part(2). part(1) is needed to show the proof obligations stemming from loop invariants(see last paragraph of sec. 2.4), but not relevant for this lemma. therefore, we consider the output of trinstr(tr(m), l) in the following. we start by expanding the left-hand side of the implication:



case(d): this case does not generate any suffix after the translation of the instruction. thus, we have pos(tr(m), l+ 1)= instrpos(tr(m), l)+ 1. the rest of this case is analogous to case(c).



the boogie verifier translates annotated cil code to boogiepl. some aspects of this translation have been proven sound, for instance, the back-edge elimination and the translation of the statements that manipulate the heap. our formalization and proof cover a much larger language subset, in particular, exceptions, which are not yet handled by boogie.



we have formalized a translation of a small subset of java bytecode to boogiepl and proved soundness of this translation. this work closes a gap in the soundness argument of several program verifiers. we managed to keep the complexity of the translation and proof reasonable by using the identical heap model and a very similar state model for bytecode and the boogiepl translation. moreover, our translation relies on the guarantees and information given by the bytecode verifier.



