safe is a first-order eager language with heap regions and unusual facilities such as programmer-controlled destruction and copying of data structures. the regions are disjoint parts of the heap where the compiler may allocate data structures. thanks to regions, a runtime garbage collector is not needed. the language and its associated type system, guaranteeing that destruction facilities and region management are done in a safe way, have been presented previously.



in this paper, we start from a high-level big-step operational semantics for safe, and in a series of semiformal steps we derive its compilation to an imperative language and imperative abstract machine. once the memory needs of the machine are known, we enrich the semantics with memory consumption annotations and prove that the enriched semantics is correct with respect to the translation and the abstract machine. all the steps are derived in such a way that it is easy to understand the translation and to formally establish its correctness.



the allocation and deallocation of regions is bound to function calls: a working region is allocated when entering the call and deallocated when exiting it. inside the function, data structures may be built but they can also be destroyed by using a destructive pattern matching denoted by! or a case! expression, which deallocates the cell corresponding to the outermost constructor. using recursion, the recursive portions of the whole data structure may be deallocated. we say that it is con-



the function insertd is the destructive version of insertion in a binary search tree. then mktreed exactly consumes the space occupied in the heap by the list. the nondestructive version of this function would consume in the worst case quadratic heap space.



data structures may also be copied denoted appending@ to a variable. only the recursive part of the structure is copied, while the elements are shared with the old one. this is useful when we want non-destructive versions of functions based on the destructive ones. for example, we can define treesort xs= treesortd(xs@).



polymorphic algebraic data types are defined through data declarations. algebraic types declarations have, after region inference, additional type variables indicating the regions where the constructed values of that type are allocated. region inference also adds region arguments to constructors, forcing the restriction that recursive substructures must live in the same region as their parent. for example, after region inference, trees are represented as follows: starting at p and creates in region j a copy of all recursive cells. some restricted type informaton is available in our runtime system so that this function can be implemented. the pointers in non recursive positions are kept identical in the new cells. this implies that both data structures may share some subparts.



rule app shows when a new region is allocated. notice that the body of the function is executed in a heap with k+ 2 regions. the formal identifier self is bound to the newly created region k+ 1 so that the function body may create dss in this region or pass this region as a parameter to other function calls. before returning



those new regions created during the evaluation of the bound expression cannot contain the result of the evaluation because after function application the local region is deallocated. region k0 denotes the highest region available when the machine stops reducing the expression. initially k= k0= 0. rule app increments k while rules lit, var 1, var 2 and var 3 discard all the local regions back to k0.



the current environment is extended with new bindings in rules let 3, case1 and case 2 as soon as let-bound or case-bound variables become free variables in scope in the continuation expression. also, it is extended in rules copy and reuse with a fresh program variable y. this is merely an artifact due to the fact that a fresh data structure must be referenced in the control expression. finally, in rules lit 2 and cons 2, the environment e saved in the continuation must be extended with the new binding introduced by let.



