this paper describes tsat++, an open platform which realizes the lazy sat-based approach to satisfiability modulo theories(smt). smt is the problem of determining satisfiability of a propositional combination of t-literals, where t is a first-order theory for which a satisfiability procedure for a set of ground atoms is known. tsat++ enjoys a modular design in which an enumerator and a theory-specific satisfiability checker cooperate in order to solve smt. modularity allows both different enumerators, and satisfiability checkers for different theories(or combinations of theories), to be plugged in, as far as they comply to a simple and well-defined interface. a number of optimization techniques are also implemented in tsat++, which are independent of the modules used(and of the corresponding theory). some experimental results are presented, showing that tsat++, instantiated for separation logic, is competitive with, or faster than, state-of-the-art solvers for that very logic.



one of the most promising approaches to smt is the so-called lazy satbased approach[1,2,8]. the idea is that of managing the search for a model via an efficient machine for boolean satisfiability(sat), e.g., the davislogemann-loveland algorithm(see, e.g., the seminal paper), and delegating first-order reasoning to an ad-hoc satisfiability procedure for the theory t 2.



tsat++ is written in c++ and naturally exploits the mechanism of abstract classes to realize the interfaces to the enumerator and satisfiability checker modules. an interface is defined by a c++ abstract class, and every module must be a concrete instance of the related abstract class(see, for instance,). each interface consists of methods each module can use to interact with the system, and data structures, which must be made compatible(i.e., models, sets of t-atoms and so on must be translated from the common data structure defined in tsat++ to those pertaining to the modules).



the interfaces mechanism leaves totally unspecified not only the inner workings of the modules, but also the quality, with respect to the theory tackled, of the objects returned. for instance, tsat++ cannot possibly influence the way the enumerator searches for models. if on one side this limits the control tsat++ has over its components, on the other it gives the module developer maximum freedom in choosing heuristics and optimizations.



in order to comply with the augmentformula method, the enumerator must be able to on-the-fly augment its formula. as is well-known from the literature on lazy sat-based theorem proving, this can either be realized by using an off-the-shelf sat solver(see) or by engineering the dpll method in order for it to be more open and flexible. the second option is better from the point of view of efficiency, of course, but it is usually no trivial task to re-engineer an off-the-shelf sat solver this way.



feeding such an assignment to the satisfiability checker might produce valuable sets of constraints earlier than if we let the enumerator produce a model, therefore potentially saving time. this technique is similar(but more powerful than) what is usually called early pruning and/or forward checking in the ai literature(see, e.g.,[16,13,19]).



we have instantiated the architecture described in section 3 for separation logic(sl), a decidable theory combining boolean logic with a fragment of linear arithmetic able to compactly capture the behavior of a large class of infinite-state systems. recently a number of interesting problems of ai(planning, scheduling, temporal reasoning, e.g., in[19,4]) and formal methods(safety of hardware, bounded model checking of real-time systems, e.g., in) have been recast as decision problems of sl-formulas. hence, the need of efficient decision procedures for this logic.



given a parameter d, these problems are characterized by an exponentially large(2d) number of boolean models, some of which correspond to sl-models; hard instances with a unique sl-model can be generated. a second parameter, s, is used to make sl models larger, further increasing the difficulty. variables range over the reals.



enumerator module, and the first-order reasoning, delegated to a specialized satisfiability procedure. much research has recently been done along these lines, see, e.g., the results achieved by such systems as tsat, cvc, ics, mathsat and uclid(sep was actually born as a back-end to uclid).



we think openness and modularity are crucial here in order to gain in terms of flexibility, upgradability and extendability. this is why we have built the system tsat++, in which the two facets of the lazy sat-based approach to smt are embedded in two dedicated modules, managed thanks to simple, well-defined c++ abstract classes. an open question, of course, is how open the system can be kept without loosing performance.



