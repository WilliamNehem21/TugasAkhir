key to the efficient development of ide components are abstraction, to eliminate the accidental complexity of ide frameworks, modularity, to reuse definitions of editor components, and extensibility, to customize editor components. in the design of abstractions to increase expressiveness, care must be taken to avoid a prohibitive loss of coverage, i.e. the flexibility to customize aspects of a component. reuse is particularly important when considering language extension and embedding, as occurs for example in scenarios such as domain-specific language embedding[3,1], and meta-programming with concrete object syntax. ideally, language combinations are defined modularly, and likewise their ide support should be composed from ide support for the constituent languages.



to further assist in efficient ide development, spoofax/imp automatically derives syntactic editor service descriptors for a language by heuristically analyzing the grammar. using the compositional nature of the descriptors, generated service descriptors can be composed with handwritten specifications, customizing the default behavior. this technique allows for rapid prototyping of editors, and helps in maintaining an editor as a language evolves. when a language definition evolves, the generated components of an editor can simply be re-generated. we have applied these techniques to webdsl, a mature domain-specific language[22,9] for web application development, which serves as running example in this paper.



this paper is organized as follows. first, we describe the definition of editor services, discussing services that handle the presentation of a language in section 2 and those based on the language semantics in section 3. in section 4 we discuss composition of editor services. section 5 provides an overview of the eclipse and imp architecture, and how our implementation augments it. finally, in section 6 we discuss related work, and offer concluding remarks and directions for future work in section 7.



each type of service, e.g. outline, folding, coloring, is defined by its own declarative description language. all editor service descriptor languages share the notion of section headings for structuring the module, such as the language section in this example. these specify the kind of editor service described and can optionally contain human-readable text describing the part of the file.



a new editor. firstly, they can form the basis for a customized editor service. in particular, using editor service composition, generated editor services can be reused and customized as desired. secondly, they quickly explain the syntax of the editor service descriptors, by means of generated, inline documentation, and by showing relevant examples that apply to the target language.



the most basic and perhaps one of the most essential editor services provided by an ide is syntax highlighting. in spoofax/imp, syntax highlighting is based on the grammar of the language, rather than just a list of keywords. thus, we correctly highlight tokens that are only considered keywords in parts of a composed grammar(such as from, which is a keyword in hql but not in webdsl). using the grammar also enables us to report syntax errors inline.



scannerless: it parses individual characters and uses no tokenizer. tokens in the traditional sense are not present. reconciling these differences is done in several ways. first, we use jsglr, our own java implementation of sglr, and stratego/j, a stratego interpreter written in java. the parse trees built by jsglr are converted to new objects that implement the imp interfaces. this conversion creates an imp ast from the jsglr parse tree, and maps literals and terminals in the parse tree to imp tokens. the imp ast nodes maintain links to tokens, which in turn know their exact source location. this is essential for editor services such as reference resolving or error markers that use the source locations of nodes in the tree. for integrating imp asts with stratego, we employ a variant of the program object model(pom) adapter approach; our implementation of the imp ast interface also implements the term interface necessary for stratego rewriting.



imp extends eclipse with a high-level framework and specialized tooling for developing ide support for new languages. developed by ibm, it is currently being used for ibm-built dsls, such as the x10 concurrent programming language. imp provides wizards for quickly generating initial implementations of services in terms of the imp framework. the usual caveat applies: any user-customizations are overwritten if the wizard is run again.



abstracts over these with dsls. as language extensions and embeddings are composed with the subject language, the necessary visitors are automatically provided. the osgi model implies distributing plugins as static jars. during development, changes made to a plugin are, in general, not reflected in the active eclipse instance. to avoid launching a new eclipse instance to use a new or updated editor, we use interpretation of editor services to allow dynamic loading of services into the current instance of eclipse. for example, for the syntax highlighting specification,



some open problems remain. we intend to replace the stratego interpreter with a compiler(targeting the jvm) to address performance concerns, while maintaining the flexible interface of primitive operations as defined by the extended term factory. similarly, we want to optimize the jsglr parser for use in an interactive environment. the current prototype performs poorly, and, ideally, it would support incremental parsing. however, as it runs in a background thread, this has relatively cantly expanded its support for language composition since, and added support for semantic analysis and dynamic loading of editor services at runtime. in part, these changes were driven by experience from the webdsl case studies briefly reported on in this paper. in other previous work, we have applied strategic programming in the field of attribute grammars, allowing high-level, declarative specifications of semantic analyses. in the future, we want to use these as a basis for defining semantic editor services. in particular, we want to investigate the feasibility of using such specifications for achieving full compositionality of complete syntactic, semantic, and tooling descriptions of language extensions.



