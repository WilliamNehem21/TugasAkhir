safety cases become increasingly important for software certification. models play a crucial role in building and combining information for the safety case. this position paper sketches an ideal model-based safety case with defect hypotheses and failure characterisations. from this, open research issues are derived.



in all these approaches the use of models plays a central role in the construction of a safety case. while earlier approaches are based on structured reviews of models, recently formal verification techniques have been applied for model analysis[1,3,5,2]. however, a systematic approach to the definition of those models is still uncommon. it is also an open issue how to justify the appropriateness of the underlying models for the safety case: is it possible to derive all relevant hazards, system failures and component faults, and is it possible to reason about the causal chains that link them? in other words, we believe that the major open issue is how to reason about



in general, a safety case is a structured line of arguments that shows that the system under consideration is safe. one of the difficulties is that a large variety of information needs to be combined to form this argument. a single safety assurance method is never able to show the complex issue of safety completely. hence, formal verification, statistical testing, process conformance and other information must be integrated for a convincing argument.



depicted by the two constraints c2 and c3. from the strategies, four refined goals are derived. g2 expresses that all relevant defects need to be considered, which is shown by using defect pattern libraries in solution sn1. g3, g4 and g5 describe further goals for failures and hazards, which are met by the exemplary solutions sn2, sn3 and sn4. important for the following is also that there are several context informations like c1, the characterisations of failures, and models of the behaviour of the system(c4) and the environment(c5).



model-based development is becoming a common-place approach to embedded(control) software construction; models, which describe the nominal functionality, are found in form of plant models, e.g., for in-the-loop testing, as well as controller models, e.g., for production-code generation. in some areas, the generation of production code from models is already state-of-the-art.



