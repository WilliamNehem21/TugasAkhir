in this paper, we propose a thorough redesign of msr intended to establish it as a usable specification framework for complex security protocols. the major innovations include the adoption of a flexible yet powerful typing methodology that subsumes persistent information predicates, and the introduction of memory predicates that significantly widen the range of applicability of this formalism. the detailed definition of this language also allows for a precise description of its execution semantics. we call this formalism typed msr, or just msr when no ambiguity can arise. it fully subsumes our earlier presentations of this language[8,15].



e.g. the use of a shared key to perform public-key encryption. our typing infrastructure can point to more subtle errors, such as a principal trying to encrypt a message with a key that does not belong to him. a procedure for enforcing such access control policies is analyzed in.



memory predicates allow a principal to remember information across role executions. their presence opens the doors to the specification of protocols structured as a collection of coordinated subprotocols. this novel possibility is exemplified in, where we formalize the neuman-stubblebine repeated authentication protocol, which lies outside the reaches of our previous version of msr. a particularly interesting application of memory predicates is given by their role in the specification of the intruder model against which a protocol is to be analyzed. indeed, our enhanced version of msr allows expressing an attacker as a distributed protocol that communicates through dedicated memory predicates. we exemplify this technique by giving two specifications of the generic dolev-yao intruder. we should stress that these specifications lie completely within the the language of our present version of msr, while the attacker corresponded to a set of rules that did not fully follow the syntax of protocols in[8,15,9].



in section 2.1, we describe the messages, or more generally terms, that form the core of msr. then in section 2.2, we introduce the typing infrastructure that allowus to make sense of these terms. we will need them in the definition of protocol rules in section 4. we conclude in section 2.3 by pointing out the major differences with respect to the messages used in previous work on msr[8,9].



messages are obtained by applying a number of message forming constructs, discussed below, to a variety of atomic messages. the atomic messages we will consider in this paper are principal identifiers, keys, nonces, and raw data(i.e. pieces of data that have no other function in a protocol than to be transmitted). we formalize our notion of atomic message by means of the following grammatical productions:



here and in the rest of the paper, a, k, n, and m will range over principal names, keys, nonces, and raw data respectively. we will sometimes also use b to denote a principal. although we will limit the discussion in this paper to these kinds of atomic messages, it should be noted that others can be accommodated by extending the appropriate definitions.



we will use the letter t, possibly suband/or super-scripted, to range over terms. observe that we use a different syntax for shared-key and public-key encryption. we could have identified them, as it is done in many approaches. we choose instead to distinguish them to showthe flexibility and precision of our technique.



type tuples(discussed in section 3) and protocol rules(see section 4) rely on objects that may contain variables to be instantiated during type-checking(this aspect is formalized in) and execution, respectively. a parametric message allows variables where terms could appear in the messages of section 2.1.



the execution rules of section 5), we will use the corresponding seriffed letters: a(or b), k, n and m. instead, the letters x, y and z will stand for terms that must be variable. in some circumstances, we will need to refer to objects that can be either variables or atomic message constants, but not composite terms. we call these terms elementary and denote them with the letter e, variously decorated.



the typing machinery that best fits our goals is based on the type-theoretic notion of dependent product types with subsorting. rather than delving into the depth of the definitions and properties of this formalism, we will introduce only the facets that we will use, and only to the extent we will need them. in particular, we do not conduct an in-depth discussion of this type theory; we will even stay away from the most exotic aspects of its syntax. readers who wish to further their understanding of this formalism are invited to consult[11,18,1,22].



all composite terms have type msg, given that their constituent submessages are correctly typed. this implies that the subterms of a concatenation(t1 t2) are themselves messages. on the other hand, the plaintext part t of an encrypted message{t}k should have type msg but k should be a shared key between two principals. terms encrypted with public keys, of the form{{t}}k, are handled similarly. this intuition is formally captured in the following typing rules for messages:



as we will see shortly, a state is a collection of specialized atomic first-order formulas. states are a fundamental concept in msr. indeed, they are the central constituent of the snapshots of a protocol execution. they are the objects transformed by rewrite rules to simulate message exchange and information update. finally, together with execution traces, they are the hypothetical scenarios on which protocol analysis is based.



in this section, we will formalize the concept of state in msr, together with the constructions needed to implement it. in section 3.1 we introduce message tuples and a notion of type for them. then in section 3.2, we discuss the message predicates that appear in a state, and in section 3.3 we define states.



second, active roles rely on a number of role state predicates, generally one for each rule in them, of the form ll(,...,), where l is a unique identifying label. the arguments of this predicate record the value of known parameters of the execution of the role up to the current point.



every protocol relies on a public network. therefore, we will hardwire the network predicate n() in our language. local state and memory predicates are different: they are defined on a per-protocol basis. this is similar to principals and keys. we therefore maintain generality by declaring them as part of the signature. we can now complete the definition of a signature as follows:



for the most part, this reduces to admitting variables in the embedded terms. however, role state predicates need to be created on the spot in order to avoid interferences. we achieve this by introducing variables, denoted l, that are instantiated to actual role state predicates during application. this makes our language weakly second-order, although we could easily reduce it to the first order by interpreting a role state predicate ll as the symbol l indexed by a label l that is kept as a variable in rules. we however opt for the more direct solution since it does not have any drawback, and allows for slightly simpler definitions.



msr adopts and formalizes this perspective. it represents protocols as a set of syntactic entities that we also call roles. a role is itself given as a parameterized collection of multiset rewrite rules that encode the expected message receptions and the corresponding transmission. rule firing emulates receiving(and accepting) a message and/or sending a message, the smallest execution steps.



the notion of fresh and bound variable discussed earlier applies also here. notice that the scope of these quantifiers is limited to the right-hand side of the current rule. later rules can refer to the values created by these variables by introducing universal quantifiers of the proper type: synchronization is ensured by their occurrence in the role state predicates. we have shown in that, when encoding of msr in logic, our marker for fresh data is indeed rendered by an existential quantification.



here, the role owner a is an actual principal name, a constant. other roles can be executed by any principal. in these cases a must be kept as a parameter bound to the role. we use the following syntax to represent these generic roles:



it should be observed that we do not make any special provision for the intruder. the adversary is expressed as one or more roles in the same way as the more legitimate message exchange in a protocol. we will illustrate how this is achieved for the standard dolev-yao intruder and for a variant of it in section 6.



a protocol theory was defined in[8,9] as a collection of rules for which the graph generated by their role state predicates was acyclic(see item x below for further details). each connected component corresponded to a role. besides this constraint, the rules within a role were independent. this aspect is mostly maintained in our current formulation, but



with the exception of, our previous work did not refer to any argument of a role state predicate as a distinguished role owner. these early versions of msr did not need to actively rely on role owners to fulfill their objectives, i.e. studying the decidability of discovering attacks in a protocol. therefore, no particular emphasis was given to this notion. this information becomes crucial when trying to enforce access control, as described in.



observe that, for simplicity, we are overloading the bracket notation to denote the application of the substitution operation to objects belonging to different syntactic categories. we only need to define the substitution of t for x in objects that may mention x as a free variable. this is why we do not include protocol theories, states and active roles in the above list.



the two rules below implement this judgment. the toptmost inference captures the degenerate situation where no basic step is applied: the current snapshot is returned as output. rule exp par expresses parallel execution: intuitively, we want to partition the current state description into partial snapshots, independently apply one basic step to each, and then merge the results together to obtain the output snapshot.



we nowcome to the central lemma in the proof of the admissibility of the rules for parallel firing. it asserts that not only signatures, but also states and active role sets can be weakened in an execution judgment, without influencing its derivability. the first result in this lemma is needed in the proof of the remaining two.



in this section, we will demonstrate the expressive power of msr by formalizing what has come to be accepted as the standard abstraction of the attacker: the dolev-yao intruder[20,14]. more precisely, we define the dolev-yao abstraction and the natural intruder model it induces in section 6.1. we then provide a direct msr encoding in section 6.2. we conclude in section 6.3 by presenting an optimized variant of the dolev-yao intruder model and hinting at its correctness.



the dolev-yao abstraction of a crypto-protocol appears to be drawn from positions taken in and from a simplified model presented in. it assumes that such elementary data as principal names, keys and nonces are atomic rather than strings of bits, as implemented in practice. furthermore, it views the operations needed to assemble messages, i.e. concatenation, encryption and digital signature, as pure constructors in an initial algebra. therefore, if n is a nonce and k a key,{n}k is a composite object whose structure is clearly recognizable. this means for example that a term of the form{t}k cannot be mistaken for a concatenation(t1 t2), and that{t}k={t}k' if and only if t= t and k= k'. this also means that the dolev-yao model abstracts away the details of the cryptographic algorithms in use, reducing in this way encryption and decryption to atomic operations. indeed, it is often said to adopt a black box viewon cryptography.



the atomicity and initiality of the dolev-yao abstraction limits considerably the attacks that can be mounted against a protocol. in particular, its idealized encryption model makes it immune to any form of crypto-analysis: keys cannot be exhaustively searched, piecewise inferred from observed traffic, or guessed in any other manner. an encrypted message can be deciphered only when in possession of the appropriate key. the symbolic nature of this abstraction allows then to very precisely circumscribe the operations an intruder has at his disposal to enact an attack against a protocol. all together, they define what has become to be known as the dolev-yao intruder. this attacker can do any combination of the following eight operations that we find convenient to organize in the five lines below:



the first line of the description of the dolev-yao intruder is then expressed by the following two roles, anchored on i. with the rule on the left, the intruder can capture a network message n(t) and store its contents in a memory predicate. observe that the execution semantics of msr implies that n(t) is removed from the current state and therefore this message is not available any more to the principal it was supposed to reach. the rule on the right emits a memorized message out in the public network.



from now on, we will only be concerned with the memory predicate mi, which acts as a workshop where the intruder can dismantle intercepted communications and counterfeit messages. concatenated messages do not offer any barrier to the intruder: he can take them apart at will. similarly he can construct the concatenation of any two messages he knows. this is realized by the following two rules:



both for taking apart and constructing a shared-key encrypted message, the intruder must know the key. observe that most typing information can be inferred assuming that the specification at hand it well-typed. take for example the role on the left. in order for the message{t}k to be well-formed, k must be a shared key between two principals. thus its type must be shk ab and the type of the dependent arguments a and b has to be principal. an algorithmic description of howtype reconstruction is performed is the subject of future work.



we now tackle the often overlooked fourth line of the dolev-yao intruder specification above: the ability to access public information. he should clearly be entitled to look up the name and public keys of principals, but any attempted access to more sensitive information such as private keys should be forbidden. the clear exception to this rule consists of the keys he is independently entitled to look up, namely his own private key and keys he shares with other principals. this situation is therefore implemented by the following five rules:



we provide our formalization of the dolev-yao intruder with two administrative rules to allowhim to take full advantage of the above stated capabilities. the rule below on the left allows him to forget information. the more interesting rule on the right permits duplicating and reusing fabricated data.



last, we have two seldom needed rule schemata that allow the intruder to shuffle data between the knowledge predicate mi() used above and other memory predicates he may have. it is in general unnecessary for the standard dolev-yao intruder to rely on additional memory predicates. here, we write m' for a generic intruder memory predicate with n+ 1 arguments. we have the following role patterns, where i is an index between 2 and n+ 1:



all but the fresh data generation rules can be automatically generated from the term language, and their typing and access control rules. we conjecture that which fresh data generation rules are admissible is dependent on the protocol the intruder is running against. in turn, this may be realized by constraining the fresh data that a principal can generate by imposing a stricter access control policy.



whenever the adversary intercepts a message, we will have him decompose it in its most elementary bits, store them in a dedicated memory predicate, and construct any message intended for transmission from stored elementary terms, without the possibility of undoing his own work. we therefore partition the actions of the intruder in three distinct activities: message decomposition, storage of elementary information, and message construction. this idea was first proposed in and analyzed in an earlier version of msr in.



we replace the single memory predicate mi() used in section 6.2 with three predicates, di(), ai() and ci(). the first is intended to contain messages while they are decomposed into their elementary constituents. the second holds the atomic terms learnt in this way. the third is used in the message construction phase. our signature shall therefore contain the following four declarations:



observe that an intercepted message is placed in the decomposition memory predicate since it must be disassembled before its elementary constituents can be used. dually, only constructed messages can be transmitted over the public network. this is enforced by having a construction predicate in the antecedent of the rule on the right.



as observed earlier, not all terms can be decomposed into to their atomic constituents. in particular encrypted message cannot be exposed unless the intruder has access to the proper decryption key. the following rule is intended to deal with this situation. here, a message t being disassembled is promoted as a constructible term. notice that a copy of t is is kept in the decomposition queue in the eventuality that later captured information may allow breaking t into more elementary pieces.



coming from the network: we read them into the decomposition queue, and store them back from the construction stack. clearly, these rules can be specialized whenever we have additional information on the data stored in each argument of m'. in particular, atomic terms can be read to and from the ai() predicates. we have the following two schematic roles, where i is an index in 2,...,n+ 1:



it should be noted that we have structured the above rules in such a way that no explicit copying rule is ever needed: whenever atomic or decomposable information is accessed for constructing an outgoing message, we always leave a copy for future use. on a similar note, we omit the deletion rule of section 6.2: this version of the dolev-yao intruder only accumulate information, never eliminates it.



the proof of the corresponding completeness result, which shows that our optimized model is powerful enough to simulate the original dolev-yao intruder, is instead quite complex on the basis of the definitions given in this paper. the intuitively simple translation of runs into the optimized model is complicated by the need to perform context-dependent permutations between rule applications. keeping track of firing dependencies among rules, while abstracting from unrelated rules that happen to be interleaved with them, is not handled elegantly in our execution model. proofs of these forms call for a more abstract viewof execution, that chains together cooperating rules. strand spaces have those qualities and we are currently developing a similar model on top of our current execution rules. the core of this proof in the context of strand spaces can indeed be found in.



in this paper, we have presented the execution model of msr, a strongly-typed framework for the specification of security protocols. msr extends previous attempts at using multiset rewriting for formalizing crypto-protocols[8,15,9] with the introduction of dependent types as a simple and effective mechanism for expressing relations among objects(e.g. between a key and its owner), and by permitting rules to mention memory predicates that allow a principal to store data that survives role termination. the typing infrastructure of msr is discussed in detail in while the related notion of access control is the subject of. memory predicates are a powerful mechanism that enables the specification of protocols consisting of a set of coordinated subprotocols that exchange data and pass control. the intruder model that best fits the analysis of a given protocol is indeed expressed as a collection of such subprotocols that communicate through dedicated memory predicates. we exemplified this feature by presenting two detailed specifications of the dolevyao intruder[20,14]. the execution model of msr is based on parallel multiset rewriting. we proved the admissibility of this approach with respect to the interleaving model that we considered in our previous work[8,9].



in addition to the execution model presented here, msr also embeds an extensive type system, fully discussed in, as well as a set of judgments and rules that formalize the notion of access control. in the near future, we plan to develop msr in three directions. first we want to extend our collection of case studies to encompass not only the most popular authentication protocols, but also fair exchange protocols and schemes developed for achieving secure multicast(we are currently formalizing the oft key management policy). second, we are developing an operational execution model as a basis for simulation and model checking. this involves in particular delaying the instantiation of universal variables to limit non-determinism. still on the pragmatic terrain, we are devising support for type reconstruction aimed at speeding up the correct formalization of a protocol. third, we are designing a



this appendix collects the grammatical productions, judgments and rules used throughout the paper for the convenience of the reader. more specifically, the syntax of msr is summarized in section a.1. the minimal typing infrastructure needed in this paper is displayed in section a.2. the definition of substitution for msr is given in section a.3. finally, we collect the executions judgments of our language and associated inference rules in section a.4. for the convenience of the reader, we specify the page number where each notion is first introduced.



