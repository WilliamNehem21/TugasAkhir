existing java verifiers perform an iterative data-flow analysis to discover the unambiguous type of values stored on the stack or in registers. our novel verification algorithm uses abstract interpretation to obtain definition/use information for each register and stack location in the program, which in turn is used to transform the program into static single assignment form. in ssa, verification is reduced to simple type compatibility checking between the definition type of each ssa variable and the type of each of its uses. inter-adjacent transitions of a value through stack and registers are no longer verified explicitly. this integrated approach is more efficient than traditional bytecode verification but still as safe as strict verification, as overall program correctness can be induced once the data flow from each definition to all associated uses is known to be type-safe.



this research effort was partially funded by the national science foundation(nsf) under grants tc-0209163 and itr-0205712 and by the office of naval research(onr) under agreement n00014-01-1-0854. the u.s. government is authorized to reproduce and distribute reprints for governmental purposes notwithstanding any copyright annotation thereon. the views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of the national science foundation, the office of naval research, or any other agency of the u.s. government.



verifying programs in ssa significantly reduces the number of points in the program that have to be type-checked, because only producers and consumers of values are verified. inter-adjacent transitions of a value through stack and registers are no longer verified explicitly. this integrated approach is more efficient than traditional bytecode verification but still as safe as strict verification, as overall program correctness can be induced once the data flow from each definition to all associated uses is known to be type-safe.



values are produced by core instructions and can be consumed by other core instructions. during the lifetime of a value it can reside on the operand stack or in variables and in multiple locations at the same time. data-flow instructions neither produce nor consume values, they merely transport values between stack locations and variables. 2



jvml instructions can read and store intermediate values in two locations: the operand stack and local variables. these locations are ad-hoc polymorphic in that the same stack location or local variable can hold values of different types during program execution. verification ensures that these locations are used consistently and intermediate values are always read back with the same types that they were originally written as.



verification also ensures control-flow safety, but this is a comparatively trivial task. conversely, verifying that the data flow is well-typed is rather complex. the jvm bytecode verifier[12,25] uses iterative data-flow analysis and an abstract interpreter for jvml instructions. unlike jvm, the stack cells and local variables of the abstract interpreter store types, rather than



the central responsibility of the java bytecode verifier is to check that stack locations and local variables are used in a type-safe manner. this is the case if the definitions and uses of values have compatible types. to ensure this, the verifier algorithm has to determine the types of all stack locations and variables for each instruction.



in jvml, there is no obvious link between the definition of a value and its uses. however, even if definition-use chains were available for each value in a jvml program, it would still be impossible to verify a java program in a single pass by comparing the type of each definition with its uses. the reason for this becomes more obvious if we consider how we categorized the instructions of jvmls. only core instructions define and use values. dataflow instructions merely facilitate the flow of values between core instructions. for core instructions the expected types of any consumed operands and the types of any produced values are always known statically. in contrast, dataflow instructions are polymorphic. in general, it is not possible to determine the type of the value produced by a data-flow instruction without knowing the type of its operands. the result type of a dup instruction, for example, depends on the type of the value on top of the stack.



the rationale of our approach is to replace the stack and local variables by a register file, and to redefine the dynamic semantics of instructions to actually work on these registers. this replacement allows us to transform the stack based code into ssa and to perform type checking only between the definitions of values and their actual uses. we abstract each instruction in a program to a tuple consisting of the depth of the stack before that instruction is executed, a mapping from stack cells and local variables to the instructions that define them, the set of stack cells and local variables the instruction reads and writes, as well as a map from stack cells to the values that reside in them.



after the annotation phase, our verification algorithm first computes the iterative dominance frontier(idf) for all definitions of values, that is values written into stack cells or local variables. each reachable instruction in the program is visited in dominator-tree order and all references of core instructions to stack cells and local variables are resolved to ssa-names. data-flow instructions do neither produce nor consume any values and are eliminated through copy propagation.



in this example, in line 1 a long integer is pushed onto the stack as a pair of halves(long, long'). partially storing the long integer in an integer register(line 2) is rejected by the traditional verifier. in contrast, since our verifier does not consider the typing rules of data-flow instructions, it accepts this code fragment, because the(long, long') pair pushed in line 1 is restored on the stack before it is used in line 4. it is important to note that this program, while rejected by the jvm, is perfectly safe when executed.



in addition to the informal description of the jvm, a number of formal specifications of the jvml and its verifier have been proposed[6,11,21]. in this context, subroutines are of particular interest and several type systems have been proposed for them[15,16,22]. all these approaches have in common that they rely on some form of iterative data-flow analysis[11,17] to decide type-safety.



in our framework. while subroutines are rapidly disappearing from jvml, they are still interesting from an academic perspective. they reinforce the question whether and how an ssa-based representation can be obtained for polymorphic code in which not all control-flow edges are explicit.



