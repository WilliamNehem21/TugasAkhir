jrebel started as an academical project that became a successful commercial product used by thousands of developers worldwide. it extends the java virtual machine with a mechanism that allows seamless class reloading. it uses bytecode manipulation extensively, both for the just-in-time class translator and numerous integrations with the java se and ee apis. in this live demo we will show how it can be used in real-life projects to cut development time by 8 to 18 per cent.



java ee development day-to-day activities involves deploying the application to the java ee server. this step is necessary after the application has been compiled and packaged into an archive as per java ee specification. every time developers want to make changes to the running application they need to deploy it, which can take from a few seconds in the best case to several minutes in the worst.



an alternative way to update an application is using the hotswap protocol, available from the java ee debugger. this allows to update the application classes without redeploying it. unfortunately only a very restricted set of changes is allowed; namely hotswap allows changes to the method bodies, but does not allow changing the class signature or inheritance hierarchy. thus no new methods, fields or constructors are allowed.



the average is about 10.5 minutes per hour, accounting for 17.5% of total development time. the standard deviation is 8, which means that the actual per cent varies quite a lot. the estimated number of java developers worldwide is nine million. estimating conservatively that only half of them develop for java ee we have an estimate for the annual worldwide cost to the economy of$56,700,000,000 a year(assuming 48 working weeks a year, 5 hours of coding per day and a$30 per hour salary).



jrebel works by rewriting the bytecode of java classes to enable versioning. to do that we use just-in-time bytecode translation in a manner akin to dynamic languages compilation and runtime support. this enables us to support changes to java class schema, though not to the type hierarchy.



fortunately object relocation is something that java does all the time. java garbage collectors relocate objects every time they compact the heap. however the problem is that the abstraction of one heap is just that, an abstraction. the actual layout of memory depends on the garbage collector that is currently active and, to be compatible with all of them, the relocation would have to be implemented in the active garbage collector. this, however, presents quite a challenge, as the sun jvm features at least four garbage collectors(some of them multi-threaded), two jit compilers and a multitude of hardware platforms and operating systems it supports. implementing this functionality in each of the garbage collectors and ensuring compatibility with the other components of the environment is a challenging enough task that since the 2001 when the initial hotswap implementation the full schema update has yet to make it into the sun jvm.



fields and methods(albeit named differently). jruby implements those features on the jvm, by treating objects as not much more than a runtime map from method names to their implementations and from field names to their values. the implementations for those methods are contained in anonymously named classes that are generated when the method is encountered. when a method is added, jruby generates a new anonymous class that includes the body of that method. as each anonymous class has a unique name there are no issues loading them and as a result the application is updated on-the-fly.



perfomance such a setup would mean that each method invocation would be subject to indirection. we could optimize, but the application would be at least an order of magnitude slower. memory use would also skyrocket, as so many classes are created.



therefore, jrebel does not take such an approach. instead we transform the class into a frontend class with a signature compatible to the original and an anonymous backend class, a new version of which can be loaded when the original class is updated. we rewrite all invocations among transformed classes introducing a level of indirection where necessary. however we use advanced just-in-time compilation techniques to inline as many indirections as we can, so as to keep performance overhead to a minimum.



