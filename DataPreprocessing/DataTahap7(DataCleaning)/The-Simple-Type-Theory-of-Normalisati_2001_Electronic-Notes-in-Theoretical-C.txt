normalisation by evaluation(nbe) was rst studied in its own right by berger and schwichtenberg about a decade ago. it is a method by which the meaning function(aka evaluation functional) of a model of a language can be used to normalise terms of the language. simply put, nbe is a typeindexed function which takes as argument a semantic object corresponding to some term and returns that term's long()-normal form at the given type. all computation is performed in the model; still, the result is a syntactic term rather than a semantic object in the traditional sense. because of this functionality, the model theory of nbe typically involves augmenting standard models with the relevant syntax; something which is highly non-trivial.



the original motivation for the nbe algorithm was largely practical. the algorithm was invented to obtain syntactic representations of the internal proof objects of the minlog proof system at lmu, munich. the main focus in, apart from the domain-theoretic correctness proof, was thus the use of the quote and unquote constructs of the programming language scheme to provide a native(as opposed to interpretative) implementation of the algorithm for the simply-typed-calculus. 3 the non-trivial details of how such a native implementation works in a more traditional programming language setting are given in. related to this,[10,11] substantiates the usefulness of nbe for purposes of partial evaluation and, in particular, semantics-based compiling(i.e., automated compiler derivation).



we will show that nbe also has interesting theoretical implications in a rewriting-based setting. in particular, we will show that the algorithm computes long()-normal forms by using very limited computational powers, i.e., plotkin-style-evaluation semantics, which makes it interesting from a practical, compiler-technology perspective as well. we accomplish this by b 2 f n; v; wg for call-by-name(cbn), call-by-value(cbv), and their combination: call-by-whatever(cbw). we use nbe to refer to all three in conjunction. one level of nbe takes the role of the model, the other that of the target syntax. the syntactic level is evidently not subjected to evaluation. the core of the nbe algorithm is expressed as the canonical inter-level term coercers in nbe.



although the semantics-based approaches naturally use constructive models, we feel that our approach is superior in explaining the actual, e ective means by which the computation of nbe is performed, e.g., via the nbe machine. we hope this will help facilitate more practical programming language applications of nbe.



furthermore, 0 combined with! behaves well for other typing paradigms, e.g., unit types and system f![4,13]. further considerations in categorical rewriting and algebraic rewriting, have lead to restricted-expansion assuming a de facto status as the choice-relation for most typed purposes. that said, the study of the rewriting properties of the restricted-relations is non-trivial[4,13].



we now introduce our two-level nbe-calculi with the intent of making them capture the type theory of the nbe algorithm under di erent evaluation paradigms. some of the employed design techniques can be used to de ne a more general notion of two-level calculi. we have chosen to focus fairly narrowly on nbe.



plotkin-style-evaluation semantics) and augmenting it with the relevant syntax, viz.() long. the former is written with overlines while the latter is written with underlines. overlap between the two levels is only allowed at ground type. the reason is one of analyticity of the type-indexed nbe algorithm and is closely connected to the ground-type restriction on d's in long()-normal formedness) of the underlined level are respected. the second,(ii), essentially follows from(i). in turn,(i) is established from the subject reduction property of the simply-typed-calculus by observing that types of(residuals of) sub-terms and not merely of terms proper are preserved under reduction. 4 alternatively, the result is established by the ml well-typedness of the evaluation mechanism of the nbe machine as presented in appendix



on the issue of a correct way of picking fresh variable names for reify and re ect, we point out that there is a simple solution in our set-up with twosorted variable names. as we shall see,# and" are only applied in a very speci c manner, cf. theorem 3.3. in particular, their application always starts with# being applied to a completely overlined term which thus contains no y's. the y's can therefore simply be picked in order starting from\the rst"| that is, vny is taken to be countably in nite. as for the x's, we notice that while reify(i.e.,#) is applied to arbitrary overlined terms, re ect(i.e.,") is only applied to underlined terms that are themselves constructed by



we see that# and" do not respect 0 under j j as the functions can be applied to abstractions. on the other hand, mints' restrictions serve to make-expansion terminating while# and" are well-de ned in themselves by virtue of being de ned inductively on types. furthermore, the-part of nbe deciding= is exclusively accounted for by the(once-and-for-all typeindexed) use of the reify and re ect functions: at each type, the use of re ect and reify amounts to placing the considered term in a xed context. this should be contrasted with the term-indexed, so to speak, use of the 0relation in traditional rewriting settings: a term is repeatedly inspected in its entirety for the presence of redexes.



an underlined term). if present, the redex will be located in a pre-determined position. in fact, by lemma 3.2 there will always be a redex in that position or the term will be underlined. no inspection of overlined terms is thus needed to perform a!b step and, furthermore, reduction will always terminate. this comment will be further explored in sections 3.1 and 4.1.



proof. functionality follows as+u and+o are given recursively over terms. totality follows(i) from x-closedness making suitably de ned in the top-left rule and(ii) from a simple adaptation of the proof of lemma 3.2: the left premise on the n-contraction rule is always met. the last point follows from theorem 3.3. 2



our motivating examples for the de nition of reify and re ect, cf. section 2.1, were the rei cation of the identity function at di erent types. we now re-do these and other examples using our implementation of the nbe machine, cf. appendix a. all code is available from our homepage. the output has been edited for space, only. the pp* functions are pretty printers, double constructors(e.g.,@@ for application) belong to the overlined level, and single constructors belong to the underlined level.



andrzej filinski. a semantic account of type-directed partial evaluation. in gopalan nadathur, editor, international conference on principles and practice of declarative programming, number 1702 in lecture notes in computer science, pages 378{395, paris, france, september 1999. springerverlag. extended version available as the technical report brics rs-99-17.



