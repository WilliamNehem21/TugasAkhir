ciently. we rst show how maude can be used to get prototyping of abstract interpretations\for free." building on the meta-logic facilities of maude, we further develop a tool that automatically checks an abstract interpretation against a set of user-de ned properties. this can be used to select an appropriate abstract interpretation, to characterize the speci c loss of information during abstraction, and to compare di erent abstractions with each other.



we discuss only satisfaction of atomic sentences in this paragraph; the general case follows easily. for an-algebra a and an assignment a: x! a we use a?: t(x)! a to denote the unique extension of a to a morphism of(k;)-algebras. we then say that a satis es(8x) t= t0(or(8x) t: s) if and only if for each assignment a we also have that a?(t)= a?(t0)(or a?(t) 2 a). a mel speci cation or theory is a pair(;), where is a set of-sentences, and it de nes a class of-algebras(those that satisfy it) denoted alg(;).



the main di erence between the two-algebras a and b above is obviously that b is nite. hence, it is easy to handle in practice but it looses information about the concrete domain of real numbers, so that many useful properties of real numbers do not hold anymore. a just structures the at concrete domain but still carries all the burden of analyzing the real numbers directly. ideally, we would want to keep both algebras, as opposed to just discard a and keep b as it often happens in practice. we next show that mel is a framework under which we can write a( nite) speci cation which accepts both a and b as models. this speci cation can be seen as a\ nite abstraction" of the concrete domain that can contain as many properties of the domain as needed.



cmb| r|: neg-s if r>=-1 and r<= 0. cmb| r|: pos-s if r>= 0 and r<= 1. cmb| r|: pos-l if r>= 1.



op _+_: neg-s zero-> neg-s. op _+_: zero neg-s-> neg-s. op _+_: pos-s zero-> pos-s. op _+_: zero pos-s-> pos-s. op _+_: pos-l pos-> pos-l. op _+_: pos pos-l-> pos-l. op _+_: neg neg-> neg.



op _*_: pos-l neg-l-> neg-l. op _*_: neg-s pos-s-> neg-s. op _*_: pos-s neg-s-> neg-s. op _*_: pos-s pos-s-> pos-s. op _*_: neg-s neg-s-> pos-s. op _*_: neg-l neg-l-> pos-l. op _*_: pos-l pos-l-> pos-l. op _*_: neg pos-> neg.



all one needs to know in order to write up desired properties of an abstract interpretation are the sorts and the operations one wants to refer to. notice that the sorts pos and neg are only needed for the last three properties, so one could remove them if one was not interested in the membership properties. the fact that the main sort real has 10 subsorts in our previous abstract interpretation is part of the abstraction, not of its desired properties w.r.t. the concrete domain. since one may want to test the same properties against many di erent abstract interpretations of the same domain and to chose one that best ts one's purpose, one should refer to as few sorts speci c to only one abstraction as possible when writing properties.



acknowledgments: we thank jos e meseguer and steven eker for encouragements and productive discussions. we also thank steven eker for providing us an alpha version of maude 2.0 which uses the membership assertions in calculating the least sort of a term, so we could test our programs and claims.



patrick m. cousot and radhia cousot. abstract interpretation: a uni ed lattice model for static analysis of programs by construction or approximation of fixpoints. in proc. 4th acm symp. principles of programming languages, pages 238{252, los angeles, california, january 1977. acm press.



bernd fischer, johann schumann, and thomas pressburger. generating data analysis programs from statistical models(position paper). in walid taha, editor, proc. intl. workshop semantics applications, and implementation of program generation, volume 1924 of lect. notes comp. sci., pages 212{229, montreal, canada, september 2000. springer.





