the control systems team at awe is currently undertaking the formal analysis of a hardware implementation of a java virtual machine(jvm). the intention is to analyse the behaviour of the processor with respect to the instruction set presented in the official jvm documentation. since the instruction set of the jvm comprises over 200 bytecodes, this paper will illustrate one of the intended approaches using a considerably smaller example. however, the example is sufficient to demonstrate potential hazards in the development of pipelined hardware through refinement.



informally, the acl2 and event-b approaches described above are similar because the refinement map in acl2 corresponds to the gluing invariant in event-b. a gluing invariant relates states in a refined(concrete) event-b model with states in the corresponding abstract model. finite stuttering in the acl2 approach corresponds to the introduction of new events in an eventb refinement(see section 1.2).



the structure of the paper is as follows. event-b and its notion of refinement are introduced. then an informal description of the instruction set of a hypothetical processor(taken from) is presented in section 2; from this, an abstract event-b specification is constructed. in section 2.2, a pipelined hardware architecture(also taken from) is introduced as a candidate processor for the instruction set, and event-b refinement is used to formalise the architecture and its behaviour with respect to the instruction set. a proof of refinement, described in section 2.4, fails to highlight some potential hazards in the pipelined architecture, and a novel solution(event merging) is proposed in section 3 as a way to overcome these problems. in section 4, we see how over-zealous merging can introduce further problems in a refinement.



note that this paper is not questioning the soundness of superposition refinement. the purpose of this paper is, given an abstract specification of an instruction set, to propose a solution to the task of its formal refinement to hardware. also note, the refined model presented in this paper is still relatively abstract when compared to hardware description languages such as vhdl. hence, the paper does not propose a complete route to hardware. however, it could be incorporated into any future approach that generates hardware from event-b specifications.



an abstract event-b specification comprises a static part called the context, and a dynamic part called the machine. the machine has access to the context via a sees relationship. this means that all sets, constants, and associated properties defined in the context are visible to the machine. to model the dynamic aspects, the machine contains a declaration of all of the state variables. the values of the variables are set up using the initialisation clause, and values can be changed via the execution of events. ultimately, we aim to prove properties of the specification, and these properties are made explicit using the invariant clause in the machine. the tool support generates the proof obligations that must be discharged to verify that the specification is well-defined and the invariant is maintained. it also has interactive and automated theorem proving capabilities with which to discharge the generated proof obligations.



where g(v) is a boolean guard and s(v) is a generalised substitution(both of which may be dependent on one or more state variables denoted by v) 2. the guard must hold for the substitution to be performed(otherwise the event is blocked). a refines clause, which includes the name of an abstract event, is necessary when the definition is a refinement of an existing event. there are



in order to express the desired properties of a system as succinctly as possible, an abstract specification will dispense with many of the implementation details in favour of a more mathematical representation. refinement is the means by which the artefacts of an implementation can be incorporated into a formal specification whilst conforming to the behaviour of the abstract specification. a demonstration of event-b refinement will be given in section 2.4.



the context and machine of an abstract event-b specification can be refined separately. refinement of a context consists of adding sets, constants or properties(the sets, constants and properties of the abstract context are retained). the link between an abstract machine and its refinement is achieved via a gluing invariant defined in the concrete machine. the gluing invariant relates concrete variables to those of the abstract model. proof obligations are generated to ensure that this invariant is maintained.



substitution s' and variable v' causes a transition to a new state, then the new state is related(via j) to a new state in the abstract world(i.e. a state resulting from the abstract event with generalised substitution s with abstract variable v). note, the multiple arrows in the diagram indicate that generalised substitutions can be non-deterministic. also note that it is not necessary for transitions in the abstract world to correspond to transitions in the concrete world(i.e. refinement can reduce the non-determinism).



the guard of an event is enabled only when the instruction indexed by pc contains the appropriate opcode. for example, the event add inst is enabled only when ins opcode(program(pc))= add. note that there are two events corresponding to the bez instruction: one event for the zero case(i.e. when the first source register is 0) and one for the non-zero case; the guards determine which of these events is enabled by examining the value held in the first source register.



in this paper of merging events gives a more accurate model of pipelined behaviour, and reveals conflicts within the pipeline by generating unprovable proof obligations. by strengthening guards, it is possible to circumvent such conflicts, and introduces explicit constraints in the pipeline to guarantee correct execution. an alternative solution could be achieved by redefining the abstract-level specification, but this would obscure the relationship between the formal specification and the informal description of the instruction set.



