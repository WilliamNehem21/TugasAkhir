

ysis method which significantly automates termination arguments. this eliminates the need for students to justify the kind of user-defined recursive functions and induction schemes that would be covered in an undergraduate class. we can therefore avoid discussing termination analysis completely or until well after students have become proficient acl2 users. in addition, acl2s includes several levels appropriate for beginners through experts. this allows us to introduce the major concepts in acl2 in easy-to-understand modules that do not overwhelm beginners.



programming mode. this mode is intended to introduce new users to acl2 as a programming language of untyped, total functions. none of the ordinary restrictions relating to logical soundness apply. with the exception memory exhaustion(heap or stack), no runtime errors are possible with functions defined in programming mode. macro definition and usage is also available in this mode.



what does happen when(begin-book) is submitted, is the source editor begins highlighting that part of the completed region with light purple instead of gray. as more forms are completed, the light purple highlight extends as long as the forms are legal for a book. after the(begin-book) this must be an(in-package...). after that, only events(see section 4.2) are legal.



the session editor also supports typing input to acl2 that is not command input. for example, acl2 sometimes prompts the user for an answer to a yes/no type question. another example is interacting with the proof checker, which has its own set of commands. all of these cases expect a single lisp object as input, and our plugin is able to detect when acl2 is expecting non-command input.



acl2 in drscheme also provides a basic script management interface for interacting with the theorem prover. the implementation is still rough and easy to break, but of theoretical concern is the relative independence of the two interfaces. one can track two separate logical environments that pertain to the same input buffer. for example, defining a function in the read-eval-print interface does not cause it to be defined in the theorem prover.



