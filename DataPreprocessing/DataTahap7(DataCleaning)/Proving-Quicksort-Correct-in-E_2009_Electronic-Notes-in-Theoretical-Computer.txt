in this article we describe our experiences with using event-b by way of an example. we show how we verified iterative quicksort in event-b and intersperse our observations and criticisms. we use them to formulate some suggestions of how we believe event-b should evolve in future. some of the minimalism may have to be abandoned in favour of more clarity of the produced formal models.



although this article discusses methodical problems of using event-b, we think that the discussion and the discussed techniques are of general interest. similar problems appear in other methods such as vdm or circus and associated tools. for instance, the technique of decomposing proof obligations by means of witnesses is also well-applicable to circus. the approach usually followed in circus is to document corresponding heuristics, whereas in event-b we try to implement very useful heuristics in the rodin tool.



event-b models are described in terms of the two basic constructs: contexts and machines. contexts contain the static part of a model whereas machines contain the dynamic part. contexts may contain carrier sets, constants, axioms, where carrier sets are similar to types. in this article, we simply assume that there is some context and do not mention it explicitly. machines are presented in section 2.1, and proof obligations in section 2.2 and section 2.3.



a before-after predicate describes the relationship between the state just before an assignment has occurred(unprimed variable names x) and the state just after the assignment has occurred(primed variable names x'). all assignments of an action s(t, v) occur simultaneously which is expressed by conjoining their beforeafter predicates, yielding a predicate a(t, v, x'). variables y that do not appear on the left-hand side of an assignment of an action are not changed by the action. formally, this is achieved by conjoining a(t, v, x') with y'= y, yielding the predicate:



a machine n can refine at most one other machine m. we call m the abstract machine and n a concrete machine. the state of the abstract machine is related to the state of the concrete machine by a gluing invariant j(v, w) associated with the concrete machine n, where v are the variables of the abstract machine and w the variables of the concrete machine.



informally, concrete event f(w) refines abstract event e(v) if the guard of f(w) is stronger than the guard of e(v), and the gluing invariant j(v, w) establishes a simulation of the action of f(w) by the action of e(v). the predicate w(t, v', u, w, w') denotes witnesses. they link abstract parameters t and variables v' to concrete parameters u and variables w'. witnesses describe for each event separately more where we assume that the variant is an integer expression. 2 we call events that satisfy these two proof obligations convergent. anticipated events can be used to prove convergence on a lexicographic order or just to delay convergence proofs. anticipated events can be refined by anticipated or convergent events, but must ultimately be refined by a convergent event. for an anticipated event the second proof obligation is replaced by



we may prove that whenever the abstract machine may continue by means of event e(v) with guard g(t, v) then the concrete machine may continue by means of concrete event f(w) with guard h(w) or some new events f1(w),..., fk(w) with guards h1(u1, w),..., hk(uk, w), 3



introducing such a variable a in a refinement we would have to introduce an auxiliary variable akin to a program counter. we want to avoid this if possible.(program counters do not make a model more readable because they complicate the invariant.) instead, we introduce variable a already in the abstract model. eventually, we can refine both variables by only one variable h representing both a and b. the price for this decision is that the specification is more loose and the proper algorithm will only appear right at the end of the development.



proof of termination. delaying termination proofs has turned out to be very useful. we used machine qs1 to prove invariant preservation and enabledness, and machine qs2 to prove termination. this made our model less sensitive to modifications; proofs in model qs2 often remained valid after changes in model qs1.



we do not present the whole model qs2 but only the assignments that have to be added to the different events. in particular, the second assignment looks complicated. but it was really suggested by the proof obligation of invariant preservation for inv15.



in the recursive version of that follows the same structure as the algorithm presented here the variant simply is the size of the partitions passed in the recursive calls. because the size can be 0 this does not work here. dropping the top element from the stack would not decrease the variant. this is an example where the recursive version of an algorithm seems easier to verify than the iterative version; there would be no need to model the stack and the variant would be simpler.



event qs3_part contains only the non-deterministic choice of partitioning to be implemented. the pivot position is chosen in event qs3_call so we only need to specify a witness for f stating that z contains that choice. although nothing essential changes in event qs3_drop we have to refine it. we have to specify that it only can occur when part= false. if we had some structuring mechanism we would not



finally we remark that we do not have local variables. variable z is global and must be initialised. variable part is also global and is visible in all proof obligations. with some structuring this would not be necessary. we would also have less proof obligations because, for instance, event qs3_drop would not have to be refined.



in the fourth refinement we implement array partitioning by the dutch national flag algorithm. event qs4_call is used for its initialisation. all variables are global. we have to assign values to them in the initialisation event(act4). we could write anything that type-checks. a concept of local variables would provide more clarity.



