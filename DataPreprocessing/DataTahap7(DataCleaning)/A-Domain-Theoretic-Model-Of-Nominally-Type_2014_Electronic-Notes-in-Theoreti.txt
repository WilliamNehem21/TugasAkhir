to evolve and improve the type systems of mainstream object-oriented programming languages such as java, c#, c++, scala and others that utilize class name information in defining object types and oo subtyping, a precise mathematical model of these languages is needed. a precise model of nominally-typed oop allows accurate reasoning and analysis of these mainstream oo programming languages. imprecise models, on the other hand, lead to inaccurate conclusions.



noop is a denotational model of nominally-typed oop. dana scott invented and developed, with others including gordon plotkin, the fields of domain theory and denotational semantics(e.g., see[29,32,30,25,12,19,16]). the development of denotational semantics has been motivated by researching the semantics of functional programming languages such as lisp[21,22] and ml[17,23].



other research that is similar to one presented here, but that had different research interests and goals, is that of reus and streicher[27,28,26]. in, an untyped denotational model of class-based oop is developed. type information is largely ignored in this work(object methods and fields have no type signatures) and some nominal information is included with objects only to analyze oo dynamic dispatch. the model of was developed to analyze mutation and imperative



a record can be viewed as a finite mapping from a set of labels(as member names) to fields or methods. thus, we model records using explicitly finite record functions. a record function is a finite function paired with a tag representing the input domain of the function. the tag of a record function modeling a record represents the set of labels of the record. in agreement with the definition of shapes of objects, we similarly call the set of labels of a record the shape of the record. the tag of a record function thus tells the shape of the record.



in this section we present formal definitions for class signatures and related constructs. class signatures and other signature constructs are syntactic constructs that capture nominal information found in objects of mainstream oo software. embedding class signature closures(formally defined below) in objects of noop makes them nominal objects, thereby making noop objects more precise models of objects in mainstream oo languages such as java, c#, c++, and scala.



not all members of set s are class signatures. to agree with our intuitions about describing the interfaces of classes and their instances, a member s of s is a class signature if its supersignature names component, its field signatures component and its method signatures component(i.e., the second, third and fourth components of s) have no duplicate signature names, field names, and method names, respectively(for simplicity, method overloading is not modeled in our model of oop). it should be noted, however, that field names and method names are in separate name spaces and thus we allow a field and a method to have the same name.



information in class signatures is derived from the text of classes of oo programs. given that interfaces of objects are the basis for defining types in oo type systems, class signatures are the formal basis for nominally-typed oo type systems, so as to confirm that objects are used consistently and properly within a program(ch. 2 of, and, give more details on types and typing in oop).



a signature closure is a pair of a signature name and a signature environment. a pair sc=(nm, se) of a signature name nm and a signature environment se is a signature closure if and only if there exists a class signature s in se with signature name nm and if the direct-reference(adjacency) relation corresponding to se is referentially-closed relative to s, and if this relation is the smallest such relation. class signature s is then called the root class signature of sc. relative to the root class signature, a signature environment is minimal, i.e., contains no unnecessary class signatures. this minimality condition ensures that all class signatures in the signature environment of a signature closure are accessible via paths in the adjacency graph of the signature environment starting from(the node in the graph corresponding to) the root signature name, i.e., that the signature environment has no redundant class signatures unnecessary for the root class signature.



first, we define exact class types. the exact class type corresponding to a class c is the set of all objects tagged with the signature closure for c. 6 next, it should be noted that a cardinal principle of nominally-typed mainstream oop is that objects from subclasses of a class c conform to the contract of class c and can be used in place of objects constructed using class c(i.e., in place of objects in the exact class type of c). hence, the natural type associated with class c, called the class type corresponding to or designated by c, consists of the objects in class c plus the objects in all subclasses of class c. in nominally-typed oo languages, the class type designated by class c is not the exact class type for c but the union of all exact types corresponding to classes that subclass(i.e., inherit from) class c, including class c itself.



mainstream oo type systems to completely identify inheritance and subtyping. we express this statement formally as follows: two signature closures corresponding to two classes are in the subsigning relation if and only if the class types denoted by the two signature closures are in the subset relation(i.e., the two classes are in the inheritance relation if and only if the corresponding class types are in the nominal subtyping relation). we prove the correspondence between inheritance and subtyping in the following theorem.



we should notice in the proof above that it is the nominality of objects of noop(i.e., the embedding of signature closures into objects) that makes s[sc2] being a superset of s[sc1] imply that sc1 has sc2 as one of its supersignatures, and vice versa. the simplicity of the proof is a clear indication of the naturalness of the definitions for class signatures and class types.



in this paper we presented noop as a model of oop that includes nominal information found in nominally-typed mainstream oo software. this led us to readily prove that inheritance, at the syntactic level, and subtyping, at the semantic level, completely agree in nominally-typed oop. it is necessary, we thus believe, to include nominal information in any accurate model of nominally-typed mainstream oop. by its inclusion of nominal information, noop offers a chance to understand and advance oop and current oo languages based on a firmer semantic foundation.



the possibilities for research that can be built on top of research presented in this paper are many. one immediate possible future work is to define a minimal nominally-typed oo language, e.g., in the spirit of fj, then, in a standard straightforward manner, give the denotational semantics of program constructs of this language in noop. the type safety of this language can then be proven using the given denotational semantics.



