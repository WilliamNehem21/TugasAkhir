most(quantum) algorithms take a(classical or quantum) input, calculate, and finally give a(classical or quantum) output. however, this paradigm does not capture the case where a program outputs data before its termination. then even a non-terminating program may have outputs(possibly an infinitely long one). an example for such a program would be e.g. one that enumerates some set.



we follow the philosophy adapted by and present fully abstract semantics for quantum programs with classical output streams. the idea underlying the model is to consider the execution of a program to be a physical measurement process on the state of the program. such a measurement process takes a quantum state as input(the initial state of the system), returns a classical measurement result(the output during the programs execution) and leaves the system in a new state. such a measurement process can be described by the established pmvm formalism(cf. section 1.1). of course, for a non-terminating program the notion of the state after the execution is not defined, so these programs are to be modelled by measurements without a post-measurement state, so-called povms(cf. section 1.1).



the most interesting construct presented here is that of loops. if nonterminating programs may have outputs, the approach of defining a loop as a least fixpoint is not straightforward. therefore we present an alternative approach where the semantics of a loop are uniquely defined by some intuitive axioms(see section 7).



note that this summary of quantum mechanical formalism does not provide an introduction to quantum mechanics. it is mainly intended to state the nomenclature used in this paper. for a gentler introduction see e.g., or, and for the case of povms/pmvms with uncountably many outcomes.



let p and q be mixed measurements. what does the composition qp(q applied after p) mean intuitively? first we measure p, yielding outcome xp. then, if p terminates, we measure q, yielding outcome xq. the overall outcome of this experiment shall then be(xp, xq) or xp(depending on whether q has been applied or not). this intuition easily gives us the following properties of qp, which turn out to define qp(cf. definition 2.1): which are only identical if m and n commute. so if in doubt, explicitly write switch. also, a program like a:=f(b) could be read as switch(f(b) as x) a:=x(measure f(b) and assign the outcome to a) or switch(b as x) a:=x(measure b and assign f(b) to a). our convention is to assume the latter case.



would measure the parity of x1,..., xn without performing a complete measurement). with such a measurement, getting measurement result m means projecting the state onto the subspace hm of states where f(x1,..., xn)= m. we mold this into a formal definition:



here h2 denotes the hadamard-transform on one qubit, and not the bit-flip. if the test a=b fails, a and b are entangled to have opposite values. otherwise, they are entangled to have the same value, but a gets flipped, so after the if statement they have opposite values, too. so the above example generates an epr pair.



assume that a program p and a probability preserving pmvm b with outcomes in{true, false} are given(cf. definition 6.1). then the program while(b) p shall intuitively represent the following experiment: repeatedly measure b. while b yields true, apply p. when b yields false, stop. the overall output shall be the concatenation of the outcomes of all invocations of p.



