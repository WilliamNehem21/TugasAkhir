nevertheless, the absence of some indices in the local strategies can also jeopardize the ability of such strategies to compute normal forms. for instance, the evaluation of the expression s(0)+ s(0) w.r.t. example 1.1 using maude 3 yields the following:



in, we have introduced two new commands(norm and eval) to make techniques i and ii available for the execution of maude programs. in this paper we show how we have brought on-demand strategies into maude. before entering into details, we show how negative indices can improve maude strategy annotations.



as we show below, on-demand strategy annotations can solve this problem. in fact, the use of the strategy(-1 0) for symbol s, declaring its first argument as evaluable only on-demand, permits to recover the desired behavior while keeping termination of the program(see examples 4.1 and 4.2 below).



in this paper, we furnish maude with the ability of dealing with on-demand strategy annotations. the reflective capabilities of maude are the key for building such language extensions, which turn out to be very simple to use thanks to the infrastructure provided by full maude. full maude is an extension of maude written in maude itself, that endows maude with notation for objectoriented modules and with a powerful and extensible module algebra. its design, and the level of abstraction at which it is given, make of it an excellent metalevel tool to test and experiment with features and capabilities not present in(core) maude[9,10,5]. we make use of the extensibility and flexibility of full maude to permit the use of both red(the usual evaluation command of maude) and norm(introduced in) with maude programs using on-demand strategy annotations.



that is, we try to reduce one of the subterms in positions with(consumed or present) negative indices. all consumed indices(positive and negative) are kept associated to each symbol in the term using an extra strategy list, so that demanded positions can be searched. see for a formal description of the procedure and for details about why the memory list is necessary compared to other frameworks for negative annotations as obj3 and cafeobj[20,21]. in this paper, we do not consider ac symbols or rules with non-linear left-hand side. furthermore, strategy annotations are explicitly prohibited for ac symbols(see[13,14]) and the completeness of evaluation with strategy annotations is only guaranteed for linear left-hand sides and constructor-based



all these functionalities are very useful for metaprogramming, and in particular when building formal tools. moreover, full maude provides a powerful setting in which additional facilities are available, making the addition of new commands or the redefinition of previous ones, as in this paper, simpler. the specification of full maude and its execution environment can then be used as the infrastructure on which building new features.



as for other commands in full maude, we may define the actions to take when the new commands are used by defining its corresponding meta-function. for instance, a red command is executed by appropriately calling the metalevel metareduce function. in order to furnish maude with on-demand evaluation we provide a new metalevel operation metareduceondemand which extends the reflective and metalevel capabilities of maude, as explained in section 3. the operation metareduceondemand takes arguments of sorts module,



opdeclset and term, and returns a term of sort resultpair. its arguments represent, respectively, the module on which the reduction takes place, the operation declarations in such a module, and the term to be reduced. the result returned is as the one given by metareduce(see section 3). note that(core) maude cannot handle negative annotations, and therefore, the function takes a valid module, i.e. a module without negative annotations, and the set of operation declarations with any kind of annotation. the redefined command red must then select between metareduce and metareduceondemand depending on whether negative annotations are present or not.



when an index 0 is found, the function procstrat attempts to match the term against the left-hand sides of the rules using the metalevel function metaapply. 4 if there is a match, then the rule is applied. if no match is obtained, then we determine if any demanded position exists using the function procstratod, which performs a matching algorithm to detect which positions under negative annotations are actually demanded by some rule(see for details). if a demanded position exists, then the evaluation of such a position is started, and then we will retry the matching against the left-hand sides of the rules after the evaluation is completed. if no demanded position exists, the current index 0 is removed from the strategy list and the rest of the strategy list is considered.



when the function procstratod is executed, i.e. when a demanded position is being searched, the computational model of specifies that the search order defined by the position order in the strategy must be followed, i.e. if(-1-2 0) is the strategy for symbol., then any demanded subterm under the first argument would be selected first, despite any demanded subterm under the second argument(see for details).



once implemented the function metareduceondemand, we need to redefine parts of full maude so that the command red can be able to execute metareduce or metareduceondemand. there is no need to define a new command and extend full maude to accept that command, as it was done for norm and eval commands in. we just need to modify the way the red command is processed.



in the current version of maude, input/output is accomplished by the predefined loop-mode module, which provides a generic read-eval-print loop. in the case of full maude, the persistent state of the loop is given by a single object of class database which maintains the database of the system. this object has an attribute db, to keep the actual database in which all the modules being entered are stored(a set of records), an attribute default, to keep the identifier of the current module by default, and attributes input and output to simplify the communication of the read-eval-print loop given by the loop-mode module with the database. using the notation for classes in object-oriented modules we can declare such a class as follows:



the module database-handling defines the behavior of the database upon new entries. the behavior associated to commands is managed by rules describing transitions which call the function proccommand. for example, the rule defining what to do when the red command is received is as follows.



when a red command is entered, the parsing of the input returns a term of the form red_.[t], where t is a variable of sort t representing a bubble. the result of the parsing is placed in the input attribute of the database object. the function proccommand specifies what to do when the term red_.[t] is received, with mn and db variables with values the name of the current default module and the state of the database, respectively. in the original case of the command red, proccommand calls the function procred with the appropriate arguments, namely the name of the default module, the flatten module itself, the bubble representing the argument of the command, the variables in the default module, and the database. note that depending on whether the default module is a built-in or not, and whether it is compiled or not, proccommand will do different things, so that the arguments for procred are obtained. in the redefinition for command red, proccommand calls a new function procreduceondemand which redefines procred.



as explained along the paper, our goal is to provide appropriate normal forms to programs with strategy annotations. however, the redefinition of command red is not able to provide the normal form 0. 1 for the program in example 1.2, since the annotation 2 is missing in the strategy list for symbol.(see the output of the red command in example 4.1). however, as it was explained in section 1, this concrete problem is solved using either a layered normalization, or a transformation. in this section, we redefine the command norm of to perform a layered normalization of the output given by the on-demand evaluation previously presented.





these features have been integrated into full maude, making them available inside its programming environment. the high level at which the specification(implementation) of full maude is given makes this approach particularly attractive when compared to conventional implementations(see e.g.). the flexibility and extensibility that full maude affords has made the extension quite simple and in a very short time.



