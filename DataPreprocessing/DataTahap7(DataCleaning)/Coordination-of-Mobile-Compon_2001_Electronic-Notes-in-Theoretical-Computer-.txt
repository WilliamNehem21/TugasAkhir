in this paper, we present p!, a paradigm for composition of software components based on the notion of mobile channels. both components and channels are mobile in p!, in the sense that(1) components can move at any time from one location to another, retaining their existing channel links, and(2) the same channels can be disconnected and reconnected to other components, thus dynamically changing the topology of inter-component communication. the component composition paradigm of p! is in the style of the iwim coordination model, and is an extension of our earlier work on a formal-logic-based component interface description language to convey the observable semantics of components. the main focus of attention in p! is the channels and operations on them, not the processes that operate on them or the components they are connected to. the composition operations in p! combine various channel types to produce complex dynamic topologies of\connectors" to which processes or components can be attached.



many of the issues investigated in the coordination research community in the past decade or so are closely tied to some of the basic problems in component based software engineering and mobility. speci cally, we believe an iwimlike coordination model[1,4] can support a powerful channel-based paradigm for composition of software components. such a paradigm can also easily support the notion of mobility as a general concept that captures both the movement of individual components from one location to the next, leaving the topology of their channel connections intact, as well as the dynamic recon guration of the system that changes this topology.



our work on p! builds upon and extends our earlier work. in a language for dynamic networks of components is introduced, and in a compositional semantics for its asynchronous subset is given. a formal model for component-based systems is presented in, together with a formal-logicbased component interface description language that conveys the observable semantics of components, a formal system for deriving the semantics of a composite system out of the semantics of its constituent components, and the conditions under which this derivation system is sound and complete. a concrete incarnation of mobile channels to support our formal model for component-based systems is presented in. generalization of dataow networks for describing dynamically recon gurable or mobile networks has also been studied in and for a di erent notion of observables using the model of stream functions.



a component is a software implementation that can be executed on a physical or logical device, which we call a location. components are the basic entities of a system. they can be instantiated at various locations, yielding speci c component instances, which interact by means of exchanging values via channels. a component instance may move from one location to another during its life-time.



a channel is a point-to-point medium of peer-to-peer communication. it represents a reliable and directed ow of information from its source to its sink. a component instance may send a value to a channel only if it is connected to its source. similarly, it may receive a value from a channel only if it is connected to its sink. the identity of the source or the sink of a channel itself can also be communicated via a channel. as such, the connection topology in a system can dynamically change. initially, we assume that each component instance is connected to a given set of sources and/or sinks of some channels. component composition in p! is accomplished indirectly through chan-



patterns are used in p! to regulate channel input/output operations. a pattern is an expression that matches(in the sense of uni cation in logic programming) an item when it is written to, read from, or simply ows through a channel. the atomic patterns are type identi ers(e.g., int, real, string, number, etc.) that match with any one of their instances, plus the wild-card pattern(*). patterns can be composed into tuple structures using angular brackets(< and>). thus,<int, string> is a pattern that matches any pair that consists of an integer and a string. matched patterns can bind free variables, which in turn can be used to enforce additional constraints. for instance,<int*x, string, x> matches any triplet consisting of the same integer as its rst and third element, with a string as its second.



a channel is a peer-to-peer medium of communication. channels are created and destroyed dynamically in p!. a channel has a unique identity and two distinct ends. a channel may follow a synchronous or an asynchronous protocol. an asynchronous channel may have a bounded or an unbounded bu er and may or may not follow a fifo ordering in the delivery of its contents. either or both ends of a channel may be connected to component instances, or be dangling. a channel end can simultaneously be known to several component instances, but it cannot be connected to more than a single component instance at any given time.



there are three types of input/output operations on channels in p!: read, take, and write. the di erence between read and take is that a read operation always makes a copy of the available value and does not remove its original from the channel. the take operation, on the other hand, takes the original out of the channel.



a synchronous channel has a source and a sink and no bu er. every take or write performed on an end of a synchronous channel hangs until a matching write or take is performed on its opposite end. once a pair of take and write operations match, and the value item can actually pass through the channel, the value is exchanged and the entities performing these operations continue independently. a read and a write on a synchronous channel also behave the same(as a take and a write), except that because the read operation does not actually take the value item o ered by the write operation, the write operation remains pending, while the read succeeds and reads a copy of this same value. if the lter on the channel prevents the value item to ow through the channel, then the write succeeds and the entity performing the write continues independently, while the(read/take) operation on the opposite end of the channel remains pending.



bounded asynchronous fifo channels, respectively. the size of the bu er of a bounded channel is speci ed at its creation time. when the bu er of this channel contains the maximum number of items it is allowed to have, a write to its source end suspends until at least one item is taken out of its bu er.



the channel types bag and set specify asynchronous channels with unbounded bu ers that behave as bags(i.e., a multi-sets) and sets, respectively. at most one copy of any value item can exist in the bu er of a set at any time. multiple operations that write the same value item into a set all succeed, but the channel will never contain more than one copy of this value item. a delayset channel is the same as a set, except that an attempt to write a value item that already exists in the bu er of this channel suspends until the existing copy in is taken out.



a keyedset channel is an asynchronous channel with an unbounded bu er. every item written into this channel must be a non-empty tuple. the rst element of each tuple is considered as its key. the key value of every tuple in the bu er of a channel of this type must be unique. writing a tuple whose key value is the same as the key value of an existing tuple, replaces the old tuple in the bu er with the new one.



a drain is an asynchronous lossy channel with only two source ends. this channel alternates between its two source ends, every time attempting to consume one item from each. because this channel has no sink end, everything written to either end of this channel is lost and can never be read(or taken). this channel gives a fair chance to the write operations that may potentially be pending on its two ends, consuming their respective values. however, its alternating behavior guarantees that even when two write operations are pending on its both ends, only one succeeds at a time; this excludes the possibility of simultaneous release of the entities that perform the two write operations. a syncdrain(synchronizing drain) behaves the same as a drain, except that a write operation on one of its ends suspends until a matching write operation is performed on its opposite end. only then both write operations succeed simultaneously, and their written values are lost. both types of drain channels are very useful synchronization tools.



a spout is an asynchronous channel with only two sink ends. this channel alternates between its two sink ends, every time making one value item available for taking from each. because this channel has no source end, nothing can ever be written into it. however, the channel itself acts as an unbounded lter, as well as their corresponding read/take patterns. for instance, reading from a spout sink may produce random integers, perhaps within a range, or repeatedly produce the same constant. analogous to a drain, the alternating behavior of a spout guarantees fairness but excludes the possibility of simultaneous success at its two ends. a syncspout(synchronizing spout) behaves the same as a spout, except that a take operation on one of its ends suspends until a matching take operation is performed on its opposite end. only then both take operations succeed. both types of spout channels are very useful synchronization tools.



a component can be instantiated at a location, producing a unique component instance. a component instance in p! consists of two distinct parts: its interior and its interface. the interior of a component is a black box that conceals its semantics and its static and dynamic structures. the active entities inside the interior of a component instance(e.g., objects, threads, processes, or agents) have a well-de ned set of channel operations through which they create and manipulate entities within its own interface, as well as those in that of other component instances.



the only way for(the interiors of) other component instances to communicate with(the interior of) a component instance is through channel connections available within its interface. the interface of a component instance is initialized upon its creation by a parameter substitution mechanism through which its creator makes a number of existing actual channels in the system known to the created component instance. a component instance can dynamically create new channels and communicate their identities with other component instances in the system.



channel end represents the end of the channel to which data can be written, and a sink channel end is the end of the channel from which data can be read. a channel end may be known to many components, but it can be connected to at most one of them at any given time. every channel end knows the set of component interfaces that know that channel end.



the only way for the interior of a component to refer to a channel end is through a special data type, called channel end variable(cev), which has two subtypes: inp and outp. the value of a variable of type inp is an indirect reference to a sink channel end. analogously, the value of a variable of type outp is an indirect reference to a source channel end. the interior of a component instance can arbitrarily replicate and use cev values(i.e., variables of type inp and outp) within that component instance. regardless of what happens to the channel ends they ultimately refer to, the indirection mechanism ensures that the cev values remain meaningful.



there are three ways in which a component instance can become to know a channel end. the rst is when the component instance creates a new channel end, e.g., by creating a new channel, and receives its identity. the second is when a component instance reads a value that represents a channel end from another channel end. the third is when the component passes a channel end as an actual parameter to a new component instance.



the operation wait([t,] cev, conds) suspends the active entity that performs it, either inde nitely or until the speci ed timeout, t, waiting for the conditions speci ed in conds to become true for the channel end cev. the channel end cev need not be connected to the component instance for this operation to succeed. the argument conds is a boolean combination(using and, or, not, and parenthesis for grouping) of a prede ned set of primitive wait conditions that includes open, closed, connected, disconnected, empty, and full.



the operation read([t,] inp, v[, pat]) suspends the active entity that performs it, either inde nitely or until the speci ed timeout, t, waiting for any value, or one that can match with pat, to become available for reading from the channel end inp into the variable v. the channel end inp must be connected to the component instance, and its lter must match with pat, if speci ed, for the read to succeed. reading a value from a channel does not remove that value from the channel. the same value can be read multiple times(even from a synchronous channel). the take([t,] inp, v[, pat]) operation is the destructive variant of read.



the write([t,] outp, v) operation suspends the active entity that performs it, either inde nitely or until the speci ed timeout, t, until it succeeds to write the value of the variable v to the channel end outp. if v contains a cev value, the actual value written to outp is a reference to the channel end that v refers to. the channel end outp must be connected to the component instance for the write to succeed. writing a value to a synchronous channel unblocks only when it is taken(not just read) from the channel.



a connector is a set of channels con gured in a graph. the vertices in this graph are called nodes and its edges are called paths. zero or more channel ends coincide on every node, and there is a path between two nodes x and y if and only if there is a channel whose ends coincide on x and y. all channel ends that coincide on a node are aliases for that node.



a channel itself is a simple example of a connector with two nodes and a path. more complex connectors can be built in p! using a number of channel composition operators. these operators are best seen as operations that change the topologies of connectors and their accessibility to the components. in practice, we adorn the undirected edges of the graphs of connectors with direction arrow heads that indicate the ow direction of data items in the channels they represent. the resulting adorned graph is not exactly a directed graph, because of the potential existence of drains and spouts: an lter, or(2) an asynchronous channel with a non-empty bu er. a node with one or more readable coincident channels is called a readable node. a read from a node succeeds only if it is readable. when multiple readable channels coincide at a node, every read from that node non-deterministically selects one of them and reads its value.



channel composition in p! is accomplished through composition of nodes. the join(cev1, cev2) operation combines the two nodes identi ed by the channel ends cev1 and cev2 into a single node. all channel ends that were the aliases for cev1 and cev2 before this operation become aliases for the new composite node.



the inverse of join() is the split() operation, which splits a node into two distinct nodes: the same old(i.e., splitting) node plus a fresh new one. the split() operation partitions the set of channel ends that coincide on the splitting node before the operation into two subsets. it leaves one subset of channel ends to coincide with the splitting node and the other to coincide with the fresh new node after the split. the partitioning of the set of pre-split



the quoin of a split operation is the set of paths forming the exterior structure at the splitting node. all channel ends corresponding to the paths in the quoin of a split\move out" of the splitting node and coincide on the new node after the split. there are three special cases of the general split operation that are of interest in p!: split(cev1, cev2), split(cev), and split(cev, all).



\clones" it, gives the clone node a new name, and moves all paths from cev to this clone node). it then forgets the only reference that exists to refer to the resulting private(i.e., clone) node. the net e ect is that after this operation, no entity, including the one that performs this operation, can ever refer to the clone node. this ensures that the topology of paths that used to coincide on cev cannot be changed anymore.



the constructs in the coordination language manifold[1,4] can be described in p! in a straight-forward manner. a port in manifold is simply a synchronous channel. following the manifold's rules of access, the source ends of input ports and the sink ends of output ports are publicized for access from the outside of their owner processes, while their opposite ends are kept for private. a manifold stream is a process that administers a p! fifo channel. the main function of this administrator process is to force the manifold's prescribed disconnection at one end of a stream when the connection at its other end breaks. connection of a stream to a port in manifold is a join of the respective ends of their corresponding fifo and synchronous channels in p!. disconnection in manifold is a split in p!.



the event-based communication of manifold can be emulated through special channels in p!. we stipulate a special pair of\event-in" and\event-out" ports for every process through which it receives the event occurrences it is interested in. the(static or dynamic) subscription of a process to an event source is modeled in p! by connecting the event-out port of the event source to the event-in port of the observer process by a fifo channel. raining an event, then, multi-casts the message(i.e., the event occurrence) to all(subscriber) processes currently connected to the event-out port of an event source.



a linda-like tuple space can be constructed in p! using a bag channel type. a component instance that represents a tuple space behaves as follows. it creates a private bag channel that only its own internal entities(presumably di erent processes) have access to. the component instance then creates a sign-on fifo channel and publicizes its source end(ts) as the identi er for the tuple space it represents. this component instance then becomes the(possibly distributed) server for the tuple space it represents. any component instance that wishes to perform any linda-like operation on a speci c tuple space, must specify its respective sign-on fifo channel source end in those



channels provide peer-to-peer, anonymous communication. this makes channels a good basis for a communication paradigm for component based systems. the topology of channels used in such a system closely represents its architecture. composition of the variety of channels in p! produces a powerful set of\connectors" for coordination of the component instances that simply attempt to perform input and output operations on their respective channel ends. furthermore, channels can easily support dynamic recon gurability and mobility.



our current work on p! is proceeding on two fronts. on the one hand, we are building an implementation platform based on mobile channels to support and experiment with the constructs in p!. on the other hand, we are working on formal models for mobile channels, component based systems using them as their coordination glue, and their semantics, towards a calculus of channels.



farhad arbab, f. s. de boer, and m. m. bonsangue. a logical interface description language for components. in antonio porto and gruia-catalin roman, editors, coordination languages and models: proc. coordination 2000, volume 1906 of lecture notes in computer science, pages 249{266. springerverlag, september 2000.



