gatel proposes a testing environment for lustre/scade programs. its main component is a resolution procedure based on a clp interpretation of its input language. this paper presents a two-tier extension of gatel in order to take into account state-machines descriptions. this extension relies on a compilation of these constructs into multi-clocked expressions. our first contribution is a definition of explicit constraints to manage the clock type hierarchy in gatel. the second one is the definition of constraints reflecting properties of state-machines built by the scade compilation schema.



the contribution of this paper is twofold: first, it describes an extension of gatel for these new multi-clocked operators, then it proposes some improvements based on the compilation process to refine state-machine constraints. we first present the lustre language and its associated notion of clocks in section 2. a glimpse of the translation process between state-machines and a clocked program is then given. section 3 introduces the basic mechanisms used in gatel, then presents the major updates used for the clock extension. the next step is the definition of specific state-machine deduction rules in section 4. finally, in section 5,a case study based on a simplified cruise control model demonstrates the efficiency of our proposal compared to the first two solutions.



an enumerated type that represents the states(one enumerator per state). three flows based on this type are created to carry out the dynamic semantics of the statemachine: at each cycle sel identifies the state which can trigger strong transitions, act the one which evaluates state bodies and may trigger weak transitions, and nxt which defines the next selected state. in a state-machine without any strong transitions, we thus get act=sel; and reciprocally act=n xt if no weak transition occurs. these three flows are automatically defined from the structure of the statemachine.



gatel[3, 16] is a testing tool based on a dedicated resolution procedure. this procedure relies on an interpretation of lustre operators through constraints programming. a first possible way to manage the clocked extension is to simulate the behaviour of when, merge, pre and-> by a combination of single-clock existing ones. for instance, x when(id, v) can be simulated by if id=v then x else(def ault-> pre x), returning a def ault value when its clock has never been present and maintaining the previous value since the last occurrence of its clock. this simulation exactly matches the original expression on each instant of the clock(id, v). however, as it will be illustrated in section 5, the clp interpretation of this simulation is less efficient than a direct interpretation of these operators.



this program p is used by the main component of gatel: its resolution engine. the goal of this engine is to produce a matrix m whose rows are identifiers from vars and columns are cycles. for each known cycle c, m(id, c) stores the logical variable associated to id whose domain is initialised according to its type. new cycles are created on demand by the resolution engine, extending m accordingly. as a standard clp algorithm, the resolution engine alternates between deterministic



rule init-t states that if the current cycle is the highest known one of the clock type cl and its status is init, then the filtering procedure applies on its first argument. rule init-f is complementary: when the current cycle is smaller than cm(cl), this means that c is non initial. therefore the filtering procedure applies on the second argument.



state(act), and truth value is this state. an important point is that all these clocks appear at the same level of the clock hierarchy for a given state-machine. moreover, the clock hierarchy contains as many levels as nested state-machines. the properties stated in proposition 1 and 2 are thus widely used during derivations. we propose to strengthen these propositions in order to make a direct link between the transition function and the clock hierarchy. given a state-machine(i, s, t), where i is the initial cycle, s the set of states and t the transition function that defines allowed transitions from one state to another, the following property states that the highest known cycle and status of the initial state i are the same as those of its ancestor clock.



m. indeed, the selected state cannot be set to a different state vjj since a transition would have already been fired between vjj and vj, violating thus the second major rule. we therefore propose to add to the system a dedicated constraint called sm relating these three variables at a given cycle. this constraint is managed by the var rules: it is launched each time a new cycle c is created for a clock type based on the active or the selected state. in these rules xc is a shortcut for m(x, c).



