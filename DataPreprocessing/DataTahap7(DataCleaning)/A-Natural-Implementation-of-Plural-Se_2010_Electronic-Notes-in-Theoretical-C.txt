? c(1)) we must first compute a(partial) value for c(0)? c(1), and then we may continue the computation with f(c(0)) or f(c(1)) which yield d(0, 0) or d(1, 1). note that d(0, 1) and d(1, 0) are not correct values for f(c(0)? c(1)) in that setting. modern functional-logic languages like toy or curry adopt calltime choice.



exploiting the fact that rewriting logic is reflective, a key distinguishing feature of maude is its systematic and efficient use of reflection through its predefined meta-level module[5, chap. 14], a feature that makes maude remarkably extensible and that allows many advanced metaprogramming and metalanguage applications. this powerful feature allows access to metalevel entities such as specifications or computations as usual data. in addition, the maude system provides another module, loop-mode[5, chap. 17], which can be used to specify input/output interactions with the user. thus, our program transformation, its execution, and its user interactions are implemented in maude itself.



although maude provides commands to execute expressions in(metarepresented) modules, including a metasearch function that performs a breadth-first search of the state space, 2 the highly non-deterministic nature of the programs obtained with the transformation avoids its use in practice. to solve this problem we have implemented the natural rewriting strategy, that evolves only the terms needed in the execution of an expression, avoiding to rewrite unnecessary terms. this is the first implementation of an on-demand strategy for maude system modules, 3 and it can be considered a first stage towards on-demand execution of general rewrite theories.



the tool reads the module and applies it the pst transformation, that simulates plural semantics with ordinary rewriting(see section 3.1 for details). this transformed module can be seen with the command(showtr.). we can now change the default depth-first strategy to breadth-first by using the command is sound. note that the guard if match(c(0)? c(1)) is needed to ensure that at least one of the values of the argument matches the original pattern, otherwise the soundness of the step could not be granted. later on, after resolving the guard, different evaluation of the occurrences of project(c(0)? c(1)) will lead us to the final values d(0, 0), d(1, 1), d(0, 1), and d(1, 0), which are the expected values for the expression in the original program under the plural semantics.



