operation calls the call op(v; y. c) passes a parameter value v(e.g. the memory location to be read) to the operation op, and after op performs the effect, its result value(e.g. the contents of the memory location) is bound to y and the evaluation of c, called a continuation, resumes. however, note that encompassing handlers may override this behaviour.



when a computation returns a value x, there will be no further printouts, so we can return the given accumulator acc in addition to x. but if print is called, we resume the continuation by yielding it the expected unit result. since the continuation is further handled into a function, we need to pass k() the new accumulator, which is acc extended with s. to obtain the collected output of a computation c, we apply the resulting function to the empty accumulator as:



exception handlers are, of course, a special instance of handlers. we represent exceptions with an operation raise that takes an exception argument(e.g. error message) and yields nothing to the continuation(for more details on how this can be enforced, see example 4.1).



then, with backtrack handle pythagorean(m, n) finds(5, 12, 13) for(m, n)=(4, 15) but fails for(m, n)=(7, 10). the exact triple found depends on the implementation of the handler. if, instead, we first tried yielding false, the resulting triple for(m, n)=(4, 15) would be(9, 12, 15). to get a list of all possible triples, we can use the handler pickall from section 2.3.1, but extended with a clause that handles fail with an empty list.



we represent state with operations set for setting the state contents, and get for reading them. for simplicity, we assume a single memory location that holds an integer. so, set takes an integer, stores it, and returns a unit result, while get takes a unit parameter, reads the stored integer, and returns it.



we can use handlers to temporarily alter the stored value or to log all updates. but we can also use them to implement stateful behaviour even if we do not assume a built-in one. like in section 2.1.3, we use a parameter-passing handler to pass



to make the intuition about the behaviour of computations concrete, we now give an operational semantics. the idea behind it is that operation calls do not perform actual effects(e.g. printing to an output device), but behave as signals that propagate outwards until they reach a handler with a matching clause. for simplicity, any operation call that escapes all handlers will be treated as a terminating computation, i.e. one that does not further reduce. we can assume that actual effectful behaviour is simulated by an outermost handler, or consider one of the approaches listed in section 6.5.



call-by-push-value is an evolved version of the fine-grain call-by-value approach. though the latter was used in this tutorial as it is closer to the more familiar callby-value, a significant part of the recent work on algebraic effects uses the former. to compare given operational semantics and effect system to ones done in a call-bypush-value setting, see, while for denotational semantics and reasoning, see.



the list of examples in section 2 is by no means exhaustive. for more involved examples that include multi-threading, delimited continuations, selection functionals, text processing, resource management, efficient backtracking, or logic programming, see[5,10,6,25]. a number of implementations of handlers has also sprung up, either as independent languages[3,14], or as libraries in existing languages[10,6,25]. more recently, a multicore branch of ocaml has started adopting handlers as a way of implementing concurrency primitives.



