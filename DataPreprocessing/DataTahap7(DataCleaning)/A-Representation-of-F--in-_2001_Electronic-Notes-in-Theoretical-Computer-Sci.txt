modern compilers employ sophisticated compilation technology to guarantee safety conditions of the generated binary. an important class of safety conditions is captured by type systems with which compilers attempt to maintain type information across an entire cascade of intermediate languages throughout a compilation process. the cascade starts with a source language and typically ends in a machine language. a variety of techniques have been proposed to express safety conditions, such as pcc and tal.



meta-logical frameworks, such as coq, nuprl, and isabelle/hol for example o er elaborate and sophisticated interactive proof search tools. in order to use those tools, one must commit to a particular way of representing the inference systems involved. in particular, representations of typing relations and operational semantics, for example, which have in general extremely elegant and expressive higher-order encodings are not directly supported in coq, nuprl, or isabelle/hol, because the question what induction principles to use is problematic[3,9]. however, true higher-order encodings of those systems provide enormous advantages in that certain lemmas related to substitution and weakening are implicitly supported, and need not be implemented by the language designer. in this paper, we use twelf as representation language of speci cations, algorithms, and their meta-theory.



this paper is organized as follows. we discuss twelf in section 2, introduce f! in section 3, discuss issues concerning substitution in section 4, and give a reduction semantics in section 5 before we show type soundness in section 6. an example of how to use our encoding is given in section 7. section 8 outlines future work and assesses results.



f! is a type theory that has been introduced by girard in his thesis as a tool to prove properties about higher-order logics. in type-directed compilation, f!'s expressive power has made it an attractive choice for the core of the flint system and tilt. it extends the simply-typed-calculus by polymorphism and type constructors.



there are di erent ways to encode f! in lf. one way, for example, is to represent expressions, types, and kinds as individual syntactic categories, and then to encode the related typing relations explicitly. for the purpose of this work however, we have chosen an\implicit" representation and index types by kinds and terms by types(see below).



the type system of f! is strongly normalizing, which seems to make lf's simply typed-calculus a good candidate to represent f!'s type level directly. however such an encoding would be unsatisfactory because it is incompatible with polymorphic quanti cation. therefore we encode f!-types in lf as type family indexed by their respective kinds.



the type level of f! forms a strongly normalizing-calculus. without further discussion and formalization, we assume this fact as given and leave a formulation of meta-level properties about this congruence relation to future work. f! also satis es several inversion principles, two of which are important for this work.



note that in this case p q is compositional, but only in the sense that atomic derivations can be substituted for atomic assumptions. the more general case of substituting canonical derivations for atomic assumptions also holds and is shown in lemma 4.2. the introduction of canonical and atomic forms brings other bene ts such as additional inversion lemmas(of which we only show one here).



following our original proposal we make the well-typedness condition part of the twelf encoding and avoid therefore an explicit encoding of the typing relationship. this technique relieves us from having to run a separate typechecking and type-normalization phase once a term has been constructed in lf. the well-typedness condition is built into the representation.



and the implementation of the proof is given in. the type annotation(t1 a: tp k) signals twelf's type reconstruction algorithm that k cannot depend on types. the substitution lemma holds not only for the congruence relation, but also for types.



the representation of the progress proof in lf is mostly straightforward, however it relies on the property that substitution of types into terms from the previous section is total. informally true, this property must be formalized explicitly in lf. for a complete development of this(and related) theorems and their proofs consult.



we view this paper as a case study on how to use meta-logical frameworks in the design, implementation, and veri cation process of datastructures and algorithms. speci cally, the main motivation of this work stems from the area of safe intermediate languages. the encoding and the properties of f! are not just of signi cant theoretical interest, but have also many practical applications related to compilers and proof carrying code.



in future work we plan to extend f! to mini-flint by adding other features namely row polymorphism, type tuples, sum types, existentials, xedpoint and contextual recursive types. mini-flint can serve as target language for compiling featherweight java. we also plan to develop a compiler from mini-flint to typed assembly language and to develop veriable safe compilation techniques within the meta-logical framework, possibly all the way down to machine code. finally, we plan to extend f! to support intensional type analysis in the spirit of[8,19]. applications of intensional type analysis include tagless garbage collection and polymorphic marshalling.



