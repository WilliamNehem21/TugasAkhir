the object system we focus on is the lazy, call-by-name-calculus( cbn), both untyped and simply typed. we will see that the formal, fully detailed development of the theory of cbn in the theory of contexts introduces a small, sustainable overhead with respect to the proofs\on the paper". moreover, this will allow for comparison with similar case studies developed in other approaches to the metatheoretical reasoning in higher-order abstract syntax.



of course there are some tradeo s. one of the major theoretical problems concerning any axiomatic approach is the consistency of the axioms. in fact, it is possible to prove that the theory of context is sound. we refer the reader to, where a full proof of consistency of the theory of contexts is given, using a model of functor categories along the line of.



it turns out that theory of contexts is quite successful in handling the metatheory of cbn. the encoding of the syntax, the semantics and the type system is straightforward, and still we delegate the-conversion to the metalevel. only the encoding of substitution is not immediate, since we need to represent it as a relation. however, this will allow us to state and prove some fundamental results(i.e., functionality of substitution) which usually are



the calculus of inductive constructions is an extension of the calculus of constructions(cc), which can be de ned as the pts c of barendregt'scube, with two sorts, prop and set. under the proposition-as-types, proofs-asterms paradigm, there is an isomorphism between propositions of intuitionistic higher-order logic and types of sort prop. if a has type prop then it represents a logical proposition; the fact that a is inhabited by a term m represents the fact that a holds. each term m inhabiting a represents a proof of a. on the other hand, the sort set is supposed to be the type of datatypes, such as naturals, lists, trees, booleans, etc. these types di er from those inhabiting prop for their constructive contents.



therefore, cc, as many similar type theories, can be fruitfully used as a general logic speci cation language, i.e. as a logical framework(lf)[13, 22, 23]. in an lf, we can represent faithfully and uniformly all the relevant concepts of the inferential process in a logical system(syntactic categories, terms, variables, contexts, assertions, axiom schemata, rule schemata, instantiation, tactics, etc.).



another problem arising from the use of higher order abstract syntax together with inductive types is that of exotic terms. these are-terms which do not correspond to any object\on the paper", despite their types correspond to some syntactic category. exotic terms are generated when a type has a higher-order constructor over an inductive type. a simple example is the following fragment of rst-order logic:\" and\0= 0", respectively. exotic terms are problematic in establishing the faithfulness of the formalization; usually, they have to be ruled out by means of auxiliary\validity" judgements[7, 27]. another approach, which will be used in section 3.1 is to have the higher order constructors to range over types which are not de ned as inductive, so that there is no cases to use as above.



a common implementation of cic is coq, an interactive proof assistant developed by the inria and other institutes. for a complete description, we refer to. coq is an editor for interactively searching for an inhabitant of a type, in a top-down fashion by applying tactics step-by-step, backtracking if needed, and for verifying correctness of typing judgements. a proof search starts by entering where goal is the type representing the proposition to prove. at this point, coq waits for commands from the user, in order to build the proof term which inhabits goal(i.e., the proof). to this end, coq o ers a rich set of tactics, e.g., introduction and application of assumptions, application of rules and previously proved lemmata, elimination of inductive objects, inversion of(co)inductive hypotheses and so on. these tactics allow the user to proceed in his proof search much like he would do informally. at every step, the type checking algorithm ensures the soundness of the proof. when the proof term is completed, it can be saved(by the command qed) for future applications.



as a corollary, a(capture-avoiding) context m() 2 x is naturally encoded as[z:var] x;z(m(z)), where the fresh variable z acts as a\placeholder" for the hole. in fact, a bijection like in proposition 3.3 can be established between contexts and terms of type var->tm.



given the signature of the syntax, the theory of contexts is composed by two parts. the rst contains the de nitions of\occurrence" predicates. these de nitions are immediately derived from the signature of the language, following the pattern in[16, 15].



remark 3.4 in also another axiom schema, called-expansion, is presented. informally,-exp states that given a term m and a variable x, there is a context n() such that n(x)= m and x does not occur in n(). this has been used several times in the development of the metatheory of each of which should be dealt by inverting the hypothesis h(or corresponding). usually, such an inversion would eliminate automatically all absurd cases, but this does not work when the terms which have to be discriminate are higherorder. this is indeed the case, since the second argument of subst has type var->tm. the inversion h tactic gives us four cases for the rst goal, only one of which is trivially true and the other are absurd:



in this section we extend the theory and the metatheory of cbn by adding simple types. simple types are de ned by the grammar::= u j!, where u; v range over type variables. the typing judgement has the form` m:, where is the typing base, that is a nite set of pairs x1: 1;:::; xn: n. the usual typing rules are the following:



on the other hand, rockl et al. proved recently that the theory of contexts(for the-calculus) can be derived from well-formedness predicates in isabelle. in some sense, therefore, the theory of contexts can be seen as a core set of basic properties capturing the essence of what a context is, without assuming unnecessary assumptions. further case studies like the present one are needed, in order to verify the expressive power of this approach.



in, pitts introduced the nominal logic, a rst-order logic speci cally designed for reasoning on syntax involving variable bindings. the axioms of nominal logic express the key properties of the fm-model of syntax introduced in. the main idea is to express and deal only with properties whose validity is invariant under swapping of bindable names. it is interesting to see that many principles are common to nominal logic and the theory of contexts(e.g., unsaturability of names,\structural induction modulo",...). the exact connection between the two theories is still to be investigated.



as already pointed out, most nowadays proof editors, and in particular all those based on type theory, lack of induction on higher order types. the problem of combining hoas and induction, avoiding the arising of exotic terms, has been addressed radically in[9, 8], where modal-calculi are proposed as metalanguages in place of usual type theories. in fact, this approach is best seen as a step towards a brand new generation of proof assistants, rather than a way for dealing with hoas in nowadays proof editors, as the theory of contexts is intended to be.



although in this work we have focused on the coq system, all arguments should be applicable to any other proof assistant based on inductive type theories close to cic, such as lego or plastic. on the other hand, the theory of contexts is inconsistent with the axiom of unique choice(ac!). in particular, this means that the approach we have adopted in this paper cannot be adopted in isabelle/hol because the description axiom entailes ac!. for a comparison of formalizations of languages with variable bindings in isabelle, see. nevertheless, it is still possible to use the theory of contexts within classical hol; see[15, 4] for an example metalanguage with full classical higher-order logic, and the proof of its consistency.



on the theoretical side, at least two interesting issues has arisen. the rst is that we have not needed the whole theory of contexts, since the axiom of-expansion has not been introduced. this seems to point out that the properties of cbn we dealt with do not rely on such kind of property. the second issue is that, due to soundness constraints imposed by cic, in order to prove totality of substitution we introduced higher-order recursion with dependent types. known models of the theory of contexts validate plain higher-order recursion; it is an open question if these models can be extended to dependent type theory.



rockl, c., d. hirschko and s. berghofer, higher-order abstract syntax with induction in isabelle/hol: formalising the-calculus and mechanizing the theory of contexts, in: f. honsell and m. miculan, editors, proc. fossacs 2001, number 2030 in lncs(2001), pp. 359{373.



