the crucial roles of atom patterns in determining rule applicability and specifying the results of rule applications necessitate an appropriate syntactic structure for representing the patterns in such a way that their instantiations can be precisely and suitably controlled. for this purpose, the notion of metaatom is introduced. meta-atoms have the same structure as usual atoms except that two kinds of meta-variables|&-variables and#-variables|are used instead of ordinary variables. the two kinds of meta-variables have di erent instantiation characteristics. not only do the di erences allow precise speci cations of rewriting rules; they enable rigorous investigation of several important properties of several kinds of transformation steps, e.g., correctness of expanding transformation, and, moreover, as shown in, systematic generation of correct rewriting rules from a problem speci cation.



syntax for rewriting rules. the rst objective of this paper is to determine appropriate syntax for a large class of rewriting rules. the syntactic structure of rewriting-rule components as well as their instantiations should be suitably de ned in order that they can be used to precisely specify rule applicability and the results of rule applications.



reverse transformation. the third objective is to introduce the reverse transformation operation, and to show that in the rbet framework an et rule is reversible, i.e., one can obtain a rewriting rule the operation of which reverses that of another rewriting rule by syntactically reversing the latter rewriting rule, and the correctness of the former depends solely on the correctness of the latter.



will be used instead of r1. then, any instantiation of this rule is regulated in such a way that the#-variable#y can only be instantiated into an ordinary variable that does not appear in the other part of the clause resulting from an application of the rule. this instantiation constraint precludes the instantiation of#y into the ordinary variable x when the rule r2 is applied to the rst body atom of c1; as a result, the transformation of c1 into c3 is prevented.



and the correctness of the latter step follows from the correctness of the former step. in general, however, the application of the rule r3 may result in an incorrect transformation step. for example, by instantiating the&-variable&y into x, the application of r3 to the rst body atom of the clause c3 of the previous subsection yields an incorrect transformation step deriving c1 from c3.



while the application of r4 to the rst body atom of c3 can be ruled out by appropriately restricting the instantiation of the#-variable#y, i.e.,#y is only allowed to be instantiated into a variable that does not occur in the other part of c3.



rigorous description of rewriting rules and their applications demands precise conditions for instantiations of meta-variables in rule applications. for the sake of generality and regularity, the conditions should not be specialized for any particular case, but common to all rewriting rules. such common conditions will be de ned in section 5(conditions(mvi-1),(mvi-2),(mvi-3) and(rra-2)).



an&-variable is a variable that begins with the symbol&; for example,&n and&x are&-variables. a#-variable is a variable that begins with the symbol#; for example,#x and#y are#-variables. an&-variable as well as a#-variable is called a meta-variable. an ordinary variable is assumed to begin with neither& nor#.



usual rst-order terms on hk; f; v1i and on hk; f; v2i will be referred to as terms and meta-terms, respectively, on. given r0 r, usual rst-order atoms on hk; f; v1; r0i and on hk; f; v2; r0i will be referred to as atoms on r0 and meta-atoms on r0, respectively. for example, assume that fx; y g v1 and f&x;#y g v2. then, nil, x and cons(x; cons(y; nil)) are terms on; nil,&x and cons(&x; cons(#y; nil)) are meta-terms on; initial(x; cons(x; cons(y; nil))) is an atom on r1; and initial(&x; cons(&x; cons(#y; nil))) is a meta-atom on r1. the standard prolog notation for lists is adopted; e.g.,[x; y] and[7;#xj&y] are abbreviations for the term cons(x; cons(y; nil)) and the meta-term cons(7; cons(#x;&y)), respectively.



in general, the rbet framework can deal with several data structures other than usual rst-order terms, e.g., multisets, strings; and a declarative description can be represented by a set of de nite clauses extended with these data structures[2,4]. for simplicity, however, only usual terms are used in this paper; that is, a declarative description is a set of usual de nite clauses. de nite clauses and declarative descriptions considered herein as well as the meanings of declarative descriptions will now be de ned.



a de nite clause c on is an expression of the form a bs, where a is an atom on r and bs is a(possibly empty) set of atoms on r. the atom a is called the head of c, denoted by head(c); the set bs is called the body of c, denoted by body(c); each element of body(c) is called a body atom of c. when body(c)=;, c will be called a unit clause. the set notation is used in the right-hand side of c so as to stress that the order of the atoms in body(c) is immaterial. however, for the sake of simplicity, the braces enclosing the body atoms in the right-hand side of a de nite clause will often be omitted; e.g., the de nite clause ans(x) fappend(y; x; z); initial(y; z)g will often be written as ans(x) append(y; x; z); initial(y; z).



let i 2 f1; 2g. a de nite clause c is said to be from r1 to ri, if and only if body(c) a1 and head(c) 2 ai. a declarative description from r1 to ri is a set of de nite clauses from r1 to ri. the set of all declarative descriptions from r1 to ri will be denoted by dscr(r1; ri).



where n 0, and h^s and the b^si are subsets of a^1. for the sake of simplicity, the braces enclosing the meta-atoms in each side of a rewriting rule may be omitted; e.g., the rewriting rule finitial(&x;&z)g! fappend(&x;#y;&z)g will also be written as initial(&x;&z)! append(&x;#y;&z).



(&z)=[1; 2; 3] and satis es conditions(mvi-1),(mvi-2) and(mvi-3). then, since y occurs in neither the head nor the second body atom of c1, r2 can be applied to c1 at finitial(x;[1; 2; 3])g by using, and this application rewrites c1 into c2. likewise, the application of r4 to c2 at fappend(x; y;[1; 2; 3])g by using rewrites c2 into c1. now consider the clause c3. the rule r4 is not applicable to c3, since every: v2! t such that



(&z)=[1; 2],(#a)= a1,(#x)= x1 and(#z)= z1. the clause c6 can be further transformed by the application of r5. notice that r5 is also applicable to the clause c2 of section 2 at fappend(x; y;[1; 2; 3])g. 2



since the rule r2 of section 2 and the rule r5 of example 5.2 are applicable to an initial-atom of any pattern and an append-atom of any pattern, respectively, and their applications correspond to the unfolding operation, they will be referred to as unfolding-based general rewriting rules. the next example illustrates rewriting rules that are devised for atoms of speci c patterns.



