in the coming c++0x standard 3, it is proposed that axioms be part of the new concept construct. the idea of concepts is to let programmers place restrictions on template parameters. for instance, a generic sorting function may specify that its argument should be an indexable object with lessthancomparable elements. without concepts, one would have to just go ahead and use the indexing and less-than operators, and then the compiler



the rest of this paper is organised as follows. we start by introducing axioms, then discuss the use of axioms for rewriting(sect. 3) and testing(sect. 4). we will then sketch some implementation issues(sect. 5), and finish with a discussion and conclusion(sect. 6).



by allowing any statement to be used within the axiom body(used in testing, see sect. 4), and by marking the actual axiom with the keyword assert. also, we allow axioms to be declared outside of concepts, so that one may attach simple axioms directly to a class, instead of having to declare concepts and concept maps for it.



rules are applied to expressions. if we wish to apply a rule to a whole program(i.e., all expressions in the program), we must use a rewriting strategy(discussed below). a rule may either succeed, if it matches and its condition is true, or it may fail. if it succeeds, the rewrite is performed and we are done. if it fails, we may try other rules if we are applying a group of rules, until we find one which succeeds. a typical rewrite strategy would visit all expressions in a program, and repeatedly apply rules until no rules succeed.



we can expect a rewrite system based on c++ axiom to be both nonconfluent(i.e., applying rules in a different order gives a different result) and non-terminating. rewrite strategies together with axiom groups provide a pragmatic solution to this, and allow us to carefully control the application of rules.



we can do better, of course. user-defined strategies allow detailed control over when and how various rewrites are applied. boyle showed in the tampr system that such control was needed to obtain many of the goals of program optimisation from rewrite rules.



the axioms and strategy definitions are then picked out from the program tree. axioms may then be compiled to rules that apply at the concept level, and after applying concept maps, to rules at the class/user level. testing code is generated after applying concept maps.



embedding optimisation rules in programs is not a new idea. user-defined rules in codeboost were inspired by the rewrite rules in the glasgow haskell compiler. the codeboost implementation was more advanced, however, and supported both conditions and multiple strategies(through a simpler version of the axiom groups introduced in this paper). conditional rewrite rules is well known from transformation languages such as stratego and elan, both of which also support strategies, and from term rewriting in general.



