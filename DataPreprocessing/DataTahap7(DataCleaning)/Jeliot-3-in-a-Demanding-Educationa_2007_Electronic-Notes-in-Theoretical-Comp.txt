software visualization(sv) tools are intended to be used in the early stages of the learning path of a programmer, teaching them the basics of programming, algorithms, and the software development cycle. sv tools convey important information by means of graphics or animations. although it is believed that visual representations are useful, previous evaluations of software visualization tools suggest that such tools do not significantly improve the learning outcome. nonetheless, some experiments have shown that they motivate the students when learning algorithms or basic programming skills.



ben-bassat levy et al. studied the pedagogic advantages of jeliot 2000(the predecessor to jeliot 3) compared with the use of an integrated development environment(ide), turbopascal, to trace programs. their study divided high school students in an introduction to programming course into two groups. both of them attended the same lectures, but in their laboratory sessions one group used jeliot 2000, and the other used turbopascal.



represented a viable working model of the execution of a program that they could understand and follow. however, the strongest and weakest students appeared not to gain much from the tool, since it was either too simple or too complex for them. in another experiment, qualitative data were gathered from 35 students who were taking part in a second course on programming and were using jeliot 3. students were asked to reflect on their jeliot 3 usage while solving programming and debugging tasks. the findings noted the problems that jeliot 3 presented to those students with some experience in programming and to those without previous use of jeliot 3. again, novice students were more positive regarding the usage of



kehoe et al. argue that a different approach was needed to demonstrate the effectiveness of algorithm animations. they hypothesize that the pedagogic value of algorithm animation tools would be more apparent when used in an interactive setting, such a homework assignment. they claimed that the pedagogic value of such tools would increase if accompanying instruction is provided at the same time as the animation. further, a meta-analysis notes the importance of how the animation is administered to the students, rather than what is actually visualized.



most of them followed an iterative approach when completing the tasks:(i) read instruction,(ii) write method, and(iii) create and run short test. the first iterations of this cycle can be understood as part of the learning process. the following iterations had a clearer debugging aim. they used jeliot 3 to visualize and identify bugs:



from observations during the lab session, we noted that the complete novices all exhibited a common behavior. students appeared to have two different goals when attending the course. their main aim is to pragmatically complete the course by solving the assigned tasks, and their secondary goal is to understand how their solution is achieved. it was noted that neither the animation(if they were using jeliot 3) nor the console output(if they were using the system java implementation rather than jeliot 3) were used to understand the basics of programming, unless explicitly taught.



students found it difficult to understand compound assignments, e.g., a+=3;. some of the students using jeliot 3 could not decipher the steps taken in its animation. only after the animation was explained to them, could they make sense of it.



from these initial results, it appears that jeliot 3 animations are hard for novice students to understand. the transfer of knowledge from the tool to the student is not successful. even students who have been explained explicitly the meaning of the animations have problems understanding or applying this later. despite this issue, both groups of students found that the help they could get from the animation was useful to debug their programs. moreover, all the students found jeliot 3 easy to use, and most the students who started using jeliot 3 continued to use it.



