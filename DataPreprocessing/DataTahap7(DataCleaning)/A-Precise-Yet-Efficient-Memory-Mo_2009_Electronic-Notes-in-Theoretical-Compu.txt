for example, one might use a join an array of bytes returned from the memory allocator, into an object of some particular type. then one would use fields of the newly allocated object in a typed way. at some point one might want to split it back into array of bytes, use memcpy() to copy it somewhere, and then join it back again. finally, one needs to split it and pass the array of bytes back to the memory allocator.



for example, let us take accesses to p1= a1~b1~c1 and p2= a2~b2~c2, done in the same 7. we want to conclude p1/= p2. for p1 the smt solver computes embedding(7, p1)= a1~b1 and path(7, p1)= c1, while for p2 is is embedding(7, p2)= a2~b2 and path(7, p2)= c2. if c1/= c2 we are done. otherwise, we need to check if a1~b1/= a2~b2. using similar reasoning(the axiom above will be triggered again), if b1/= b2, we are done, otherwise we look for a1/= a2, which will hopefully follow from preconditions. thus the axiom above allows for distinguishing between pointers, if any element of the path leading to them is different.



proof. if[ss]1 does not get stuck or go wrong, we have the correspondence from lemma 5.1. otherwise the only difference between ss and[ss]1 are the additional conditions on memory accesses. they are however always ok since for any newly introduced join e1, 7= 71 and for all other operations there was a preceding join e1.



c allows the definition of bit-fields in structured types, which are interpreted as a signed or unsigned integer type with the corresponding number of bits. since most architectures do not allow for direct access to arbitrary bit ranges in memory, c compilers usually merge one or more consecutive bit-fields into a single underlying field of unsigned integer type. accesses to particular bitfields will then be transformed into bit manipulations on the underlying field. that is why c does not allow taking the address of a bit-field. we extend our



except for the l4 kernel verifier, none of these verifiers deals with unions and bit fields. the memory model presented here is similar to the embedding of c in coq developed as part of the ongoing certification of a moderatelyoptimising c compiler. the spark programming language, a subset of ada, has its own verifier. spark avoids the issues with anti-aliasing and dangling pointers by disallowing allocation at run time entirely.



