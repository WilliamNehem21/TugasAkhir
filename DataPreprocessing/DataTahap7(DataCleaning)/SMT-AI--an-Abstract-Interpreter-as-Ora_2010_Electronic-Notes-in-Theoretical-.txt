the last decade has seen a major development of verification techniques based on smt solvers used to prove inductive invariants on systems. this approach allows to prove functional properties and scale up to handle industrial problems. however, it often needs a man in the loop to provide hand-written lemmas on the system in order to help the analysis and complete the proof.



the next section will introduce and motivate a combination of analysis methods while the remaining of the article focus on the implementation of one of them. section 3 describes the input language of our tools. then the two following sections deal with the analysis it performs. finally, section 6 gives some details about the implementation, section 7 details an example and section 8 concludes and gives an overview of what remains to be done.



abstract semantic is computed through usual least fixpoint increasing iterations with a delayed widening with thresholds followed by decreasing steps with narrowing, memi and memu predicates acting as assignments for variables used as memory of the synchronous system. most of the work consists in analyzing the expression defining the values of those variables from the values at previous step. the remaining of this section will focus on this second separate analysis, conducted by decreasing iterations toward a greatest fixpoint.



when the result n is false, one of the subexpressions e1 or e2 can force the value of the conjunction. we can thus only compute a join of backward evaluations to false of subexpressions. disjunction is similar, replacing join with meet and vice versa.



such backward semantics is commonly applied on guards of if... then... else or while loop constructs of imperative languages like c. iterating can be needed in our case to gain precision, when some information learn in one part of an expression enables to get more precise results in another part.



we can not make use of a widening operator(or more precisely its dual) to accelerate convergence since this would lead to an under-approximation of the greatest fixpoint whereas we want to compute an over-approximation of it. only solution to enforce convergence in reasonable time is to make use of a narrowing operator which basically amounts to bound the number of iterations. this would lead to far too much coarse results if iterations were commonly stopped by narrowing. however convergence seems to be reached after only a few iterations on the formula fed to our tool(c.f. section 3.3).



the analysis presented here, even used with simple abstractions such as intervals, already gives interesting results. computing non relational properties like bounds on variables allows to optimize the analysis for the smt solver, for example relying on bit-blasting techniques. on some simple systems with integer counters, for instance, the k-induction analysis could necessitate to increase the induction depth up to unreasonable values, while our abstract interpretation tool using widening with thresholds will infer bounds in a few steps of computation.



