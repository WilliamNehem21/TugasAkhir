harmony search metaheuristic is successfully used in several applications of science and engineering. however, its effectiveness in solving multiobjective optimization problems using the concepts of pareto optimality, remains unproved. this paper presents two proposals of the harmony search metaheuristic for multiobjective optimization, using the zdt functions as a test bed. performance metrics for experimental results show that the proposals are competitive even when compared to nsga-ii evolutionary algorithm.



harmony search algorithm(hs) is a recent metaheuristic inspired by the music improvisation process. it was proposed as a mono-objective problem optimization metaheuristic and, since its creation, it has shown to be effective and convenient in several science and engineering applications, as seen in. the natural and efficient application of hs algorithm to multiobjective optimization problems is a proposed extension of the existing research. furthermore, the use of this algorithm to solve complex multiobjective problems, like np-hard ones, is considered as a future challenge.



the paper is organized as follows: section 2 presents the definition of multiobjective optimization problem and other related concepts. section 3 explains the harmony search metaheuristic in detail, making first a comparison to musical improvisation process, and then, describing each part of the algorithm structure. section 4 presents a brief review of works that treat hs algorithm and multiobjective optimization. section 5 presents the adaptations of the mono-objective hs algorithm for both proposals of this paper. next, section 6 presents the set of tests and the experimental results. finally, section 7 presents conclusions and future work.



before introducing the hs algorithm and each of its parts, a brief comparison to the processes of musical improvisation(and optimization) will be given in section 3.1. then, the structure of the algorithm together with each of its parts will be treated in section 3.2.



{500 mm, 600 mm, 700 mm}, these values make a new solution vector,{100 mm, 300 mm, 500 mm}. if the solution vector is better than the worst vector in hm, then the new vector replaces the worst one in hm. this process is repeated until a stopping criterion for termination of the algorithm is reached or the global optimum is found.



pitch adjustment is similar to the mutation operator in genetic algorithms. a low value for par together with a narrow value for fw can make the convergence of the hs algorithm slow, given the limitation in exploration to a single portion of the search space. on the other hand, a very high value for par together with a wide value for fw may cause solutions to disperse around a few potential optima as in random search. for these reasons, usually, par[0.1; 0.5] and fw, generally, is bounded between 1% and 10% of all the range of variable values.



gao et al. proposed a modified version of the hs algorithm for mono-objective optimization problems with constraints, using the pareto optimality concept. the function to be optimized results from the aggregation of the objective function and the weighted sum of constraint functions. the application of the pareto optimality concept allows to rank the non-feasible solutions, that is, those that violate one or



for this new generated solution, a ranking is calculated considering the solutions stored in hm. if this ranking turns out to be better than the worst ranked solution in hm, the new solution is stored in hm replacing the worst one, choosing randomly among the worst ones if there is more than one. this procedure incurs in an asymptotic cost of o(hms) to recalculate the ranking of the solutions in hm.



each iteration begins by improvising all solutions that will belong to hm2, using the same selection method as the mono-objective hs algorithm. this is, the values of each calculated solution are generated using the values of decision variables contained in hm1 as considered values. once the solutions for hm2 are generated, the fonseca-fleming ranking of hu is calculated.



