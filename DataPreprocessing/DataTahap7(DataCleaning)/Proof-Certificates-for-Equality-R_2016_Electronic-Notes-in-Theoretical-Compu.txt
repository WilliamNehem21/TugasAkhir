our framework for defining proof evidence is based on looking closely at the provability of horn clauses(which are used to encode the rules for congruence, symmetry, transitivity, and to list redexes) and to allow the explicit controlling of choice points in such proofs via simple programs called experts. we are able to modularly specify all the informally mentioned proof evidence above(as well as many more) simply by varying the definitions of experts and by using different indexing schemes. the design of our proof checker makes it simple to show that a proof checker is sound no matter how experts are defined.



kind cert, index type.% two new types type interp cert-> bool-> o. type bc cert-> bool-> bool-> o. type clause index-> bool-> o. type decidee cert-> cert-> index-> o. type impe cert-> cert-> cert-> o.



type ar1( i-> i)-> int-> index. type ar2( i-> i-> i)-> int-> index. type ar3( i-> i-> i-> i)-> int-> index.



perform simple computations and do not need to examine the structure of certificate terms. on the other hand, the expert predicates generally examine that term in order to pull out of them information meant to guide the proof: substitution terms, indexes for stored formulas, or cut-formulas. notice that if a predicate name ends with a capital c, then that predicate is a clerk; if a predicate name ends with a capital e, then that predicate is an expert. finally, store predicates are clerks while the predicates associated to the decide, release, and initial rules are experts.



