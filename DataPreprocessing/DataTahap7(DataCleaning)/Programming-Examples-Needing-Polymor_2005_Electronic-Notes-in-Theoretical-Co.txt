and determines their typability under various type systems, including the hindley-milner system, an intersection-type system, and extensions of these two. the goal of this report is to show that many of these examples are typable using a system of intersection types as an alternative form of polymorphism. by accomplishing this, we hope to lay the foundation for future research into a decidable intersection-type inference algorithm.



the definitions of double, foo, and goo are mutually recursive. therefore the calls to double within the definition of foo and goo are recursive calls. hence, the hindley-milner typing derivation breaks down with the realization that each of these recursive calls is on an argument of a different type.



as an aside we translate a couple of the examples in this report into haskell syntax and compare the sml/nj error messages with the ghc error messages(which uses algorithm m in contrast to algorithm w of sml/njfor more discussion see). we choose to translate only those examples which will yield an interesting and different error message. most of the following examples, when translated, offer error messages that are very similar to the sml/nj error messages, but differ occasionally in the program location which the compiler targets as problematic. this example, when translated, is no different.



the final type assigned to this example is: int. this example can be uncoupled in the same way as the previous two examples. a natural question at this point would be to ask why id needs to be defined mutually recursive to sumlist. to avoid such a question we could pass id as an argument to sumlist and then motivate this move by demonstrating a need to pass two different functions to sumlist. we show this for the matrix transpose example so we do not show it here.



an objection made in a preliminary presentation of this work is that this example(matrix transpose) and the next(vector addition) are not cases of truly polymorphic recursive functions, because the polymorphism is not at the outermost position of the type expression, as in the previous examples. however, such a definition of polymorphic recursion is arguably too restrictive, as it disallows function types whose argument type(i.e., expressions to the left of the arrow constructor) are polymorphic.



as an alternative alleviation, one could simply remove the first argument, f, of map2 and replace each f in the body of map2 with the standard map function. however, there may be cases where passing map1 as an argument is advantageous. for example, consider the following. suppose that given a matrix m, one wishes to compare the transpose of m with the transpose



we now return to our comparison of sml/nj and ghc error reporting. the bar example, this example, and the following example(delay) all demonstrate a difference between the error reporting of the two compilers that we have not yet seen. here we show the haskell translation and ghc error message of this example.



notice that the error message reported by ghc consists of only one message while sml/nj reports two messages. this suggests that ghc may get to the heart of the error while sml/nj reports numerous superfluous messages. on the other hand, perhaps sml/nj error reporting is more precise, exposing every relevant error location. since this is not the main objective of this report we leave this issue for future inquiry. however, the interested reader is advised to see for more discussion.



