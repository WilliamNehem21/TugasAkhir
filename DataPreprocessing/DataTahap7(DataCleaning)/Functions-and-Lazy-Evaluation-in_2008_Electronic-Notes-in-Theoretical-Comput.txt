both functional and logic programming styles provide appealing resources for programming and there have been different approaches for combining both paradigms in order to amalgamate the most interesting capabilities of them. this is the core idea of functional-logic languages such as curry[8,9] or toy[4,13]. they have a strong influence of haskell in their syntax, higher order capabilities, type inference systems, etc. moreover, following haskell, lazy evaluation has been incorporated as a primitive feature. in a certain sense(apart from type classes and some other sophisticated features) they can be seen as an extension of haskell. in fact, a big collection of haskell programs runs in toy or curry with minor changes. in addition, these functional-logic languages incorporate from logic programming nondeterministic functions, logic variables treated by a generalization of unification in our context, with non-deterministic computations involved, these delayed computations may destroy our intended semantics for programs. we do not provide a formal semantics in this work, but our informal argument is as follows: lazy declarations can achieve termination for functions that diverge under eager evaluation. but assuming termination we want to obtain the same result(s) for a function call, with eager or lazy evaluation, or even with a mixture of both. this corresponds to the call-time choice semantics adopted in functional-logic systems like toy or curry. the above mechanism for lazy evaluation does not satisfy our aim, and we need to introduce some sharing structure(as in toy and curry).



there is an important aspect about the meaning of rules that we must clarify. given a function rule, the order in which computation is performed is the following: firstly parameter passing is done by unification, then conditions are satisfied and finally the body of the rule is evaluated to obtain the result. this is not the only possible translation. an alternative way to proceed could be for example to do parameter passing, evaluate the body of the function and then satisfy the conditions.



for higher order functions we perform a translation into first order using a well known technique that was also implemented in the language toy. the idea is to consider every partial application as a prolog term instead of a proper function call and to use a new function@(read apply) for applying these partial applications to arguments. the function@ is defined as an infix operator and the translation generates its rules for(every partial application of) all the functions of the program. as an example, consider the program:



we adopt a middle way: our functions are strict by default, but we allow lazy evaluation by means of explicit annotations. this idea is not new as the functional extension of prolog proposed in allows lazy annotations for functions. furthermore, some strict functional languages such as ocaml provide resources to suspend the evaluation of expressions and to force its evaluation when needed. in the next sections we explore these approaches.



the proposal of allows to declare a function to be evaluated lazily. in the translation to prolog predicates, the evaluation of those functions is suspended until the result is demanded by unification at some predicate. this is done by means of the primitive control freeze(var,goal) that delays the execution of goal until var is bound. to illustrate this translation consider the following program:



now consider again the evaluation of the function firstnats(3), i.e., the goal firstnats(3,l). the goal from(1,l1) generates a suspended call to fromlazy(1,l1). the variable l1 will be demanded by unification when evaluating take(3,l1,l). then we obtain a list with head 1 followed by a suspended call to fromlazy(2,l2). in this way we obtain a list with the elements 1,2 and 3, followed by a suspended call to take(0,<susp>, k) that provides the answer k=[] using the first clause of take.



the functions from and take have the same meaning as in previous examples. notice that they must explicitly suspend and force evaluation according to the declared type. finally, we can force the evaluation of a lazy list using the function nf, which takes a lazy list and returns a standard list in normal form(without any deferred computation). for example, the expression nf(take 4(from 1)) will be evaluated to the list[1,2,3,4].



this last version contains essentially the idea that we will incorporate to our translation, but it presents a problem: while the first version implicitly provides sharing(because ocaml stores the computed result after the evaluation of a thunk, for avoiding reevaluation), the second one does not. in our context this is not only a problem of efficiency, but the intended semantics could be destroyed as we will see in section 5.2.



in our setting we provide laziness annotations for data type constructors. with only this information, the translator will introduce the appropriate suspensions and the corresponding manipulation for them. we start showing a basic translation scheme and then an extension to capture sharing.



the previous translation can have an undesirable(or at least unexpected) behaviour when non-determinism is involved. let us examine an example to illustrate the situation. consider the classical prolog generate and test algorithm for sorting a list: generate permutations of the list in a non-deterministic way and test if they are sorted. this algorithm, using(non-deterministic) functions can be easily implemented in functional prolog as:



the function permut returns a permutation of the list by inserting the head of such a list into a permutation of the rest of the list; insert puts an element into a list at any possible possition(by backtraking). the function sorted checks if the given list is sorted. and finally, permutsort generates a permutation of the list and if it is sorted then returns it(if it is not sorted, by backtraking will search for another permutation). the function sorted checks if the given list is sorted. and finally, permutsort generates permutations of the list searching for a sorted one by backtracking. the function ifthen is defined in the prelude with the standard meaning.



this rule first checks if the expression has been previously evaluated by looking up the flag ev. in such a case, the resulting value is the one stored in res. in other case we evaluate expr, set the flag and return the obtained value. the notation expres indicates that the expression exp must be flattened in such a way that the resulting value is res. for example, the function app is defined in the prelude as:



now, coming back to our example, the function permutsort works as desired and the goal permutsort([4,3,2,1],l) will produce a unique answer l=[1,2,3,4]. using lazy lists the algorithm is drastically improved in efficiency as expected. moreover, the translation incorporates some(quite technical) optimizations that improve the efficiency even more.



in this section we will give an idea of the capabilities of the functional prolog model proposed in this work and its performance. we are interested in the comparison with similar approaches, in particular, with functional-logic programming and with the approach of that we have summarized in section 4.1.



the approach of laziness of section 4.1 was introduced in as an extension to ciao prolog. that proposal is very close to our current approach, as both are functional extensions of prolog, with optional laziness. it is different from ours in its treatment of higher order and some other aspects, but the most interesting difference is with respect to laziness. unfortunately, the implementation is not included in the ciao prolog distribution and so we must use the translation scheme seen in section 4.1 for comparison.



as we have pointed out in section 4.1, implementing this model for laziness is quite straightforward just using the resources of standard prolog for delaying computations. this approach has the advantage that most of the work about laziness is automatically done by prolog, using its capabilities for delaying goals. nevertheless, this model of laziness can be hard to manipulate as, in general, choosing which program functions must be lazily evaluated is not a trivial issue. as an easy solution we could turn every function lazy, but in this case the efficiency of the program would be seriously affected.



the evaluation function eval is defined in a natural way using prolog cuts(the last rule stands for a single number). the rule for division must make some tests as it is understood as integer division. finally, the function sol(v,l) generates an expression with the operands of the list l and tests if it is a solution. by backtracking this function will find the solution for the problem if it exists. for example, sol(28,[3,6,4,5]) will return mult(plus(5, div(6, 3)), 4), that is,(5+6/3)*4. if we evaluate sol(26,[4,5,3]) we do not obtain any solution as the numbers 4, 5 and 3 do not allow to get the exact value 26. it would be interesting to obtain the best approximation to the solution from the program above. a typical solution in prolog for this kind of problems is to use some meta-predicates to explore the search space. using higher order functions we can encapsulate this search operation. it expression. for example, genexpval(17,[3,4,1]) may return(3*4+1,4) as 3*4+1=13 and the difference with the total 17-13=4; another result may be(3*4,5) as 1712=5. the function better(c1,c2) returns the best between the candidates c1 and c2, where a candidate is a pair expression-valorization as we have seen. now, for the expression bestapprox(26,[4,5,3]) we would obtain the expression mult(3, plus(5, 4)) and the valorization 1(3*(5+4)=27 and 27-26=1).



in this work we show how to extend prolog with functions performing a translation of function rules into prolog predicates. we introduce a simple syntax for function definition and a transformation of higher order to first order syntax including lambda abstractions. with these features we can talk about functional prolog. the extended language implements an eager evaluation mechanism, but we explore some alternatives for introducing lazy evaluation by means of user annotations.



it is possible to manipulate optional laziness by introducing annotations on functions or on constructors. in practice it is easier to use the second alternative because to decide which functions in a program must be lazily evaluated may be a hard task, while it is not difficult to think about the data structures that must be lazily constructed. moreover, experimental measurements show a better performance when using lazy constructors.



for the first problem we extend lambda abstractions with a sharing structure that ensures call-time choice. for the second one, the translation incorporates a complete mechanism for delaying computations and forcing later on their evaluation. similar transformations have been proposed for eager functional languages and are close to context-sensitive rewriting[7,14]. as a future work it would be interesting to study the relation of our lazy annotations with context-sensitive rewriting, at least for the declarative fragment of functional prolog(excluding metaprogramming).



we have presented a collection of examples showing the capabilities of the proposal. in particular, we obtain a fine control on laziness that can be used to improve the efficiency of programs. on the other hand, combining the meta-predicates provided by prolog with the functional extension we obtain sophisticated resources for exploring the search space.



