the first assumption is obvious. it is necessary for all kinds of systems and it may be established by unit testing. the second assumption comes from the fact that loosely coupled distributed systems cannot be tested in integration. instead, the specifications have to contain enough information



the paper is organized as follows: in section 2 we describe design by contract in more detail. in section 3, we apply this concept to web services and introduce a visualization of contracts by graph transformation rules. section 4 discusses the use of contracts for testing and section 5 concludes the paper.



a contract states what both parties must do, independent of how it is accomplished. a contract is typically defined by assertions and associated concepts. an assertion is a boolean expression involving some entities of the software, and stating a property that these entities may satisfy at certain stages of software execution. a typical assertion might express that a certain integer has a positive value or that a certain reference is not void. at runtime,



implementation-level: here, a contract consists of a boolean expression of the implementation language, using all the functional features(access to fields, method calls, basic types and operations) with some specific operators to refer to pre-conditions(e.g. pre) and to post-conditions(e.g. post).



current web services are in the majority of cases based on object-oriented programming languages. most of these programming languages only support syntactic contracts, but some languages, as for example eiffel, inherently incorporate behavioral contracts with pre-, post-conditions, and invariants. however, there are different approaches to extend existing languages with behavioral contracts, like icontract, jml, or jcontract for java. an example of jcontract looks as follows:



model-level: the main drawback of the first two levels is that they are hard to read and write for humans. a visualization for contracts that enables documentation and communication between developers would be preferable. in the following, we will concentrate on the model-level specification of contracts to explain our ideas.



design by contract is a formal way to specify the behavior of operations. using design by contract at implementation level is a way to incorporate specification information into the code itself. however, we still have to test the implementation against its specification. the question is how design by contract can be used to support testing, i.e., to create, select, and execute test cases.



in this paper, we are interested in functional tests, i.e., black-box tests derived from contracts. such tests ensure that the delivered product meets its specification. with this goal in mind, it makes sense to use provided contracts both for the creation of test cases(sample input data) and test oracles(conformance checks for the output).



rather than deriving test cases manually, we consider to use the jtest tool by parasoft for this purpose. jtest is a java-based unit testing tool. its aim is to support the testing of components before they are integrated into an environment. jtest works together with jcontract whose implementation-level contracts are analyzed to derive test cases and oracles. thus, jtest enables automated unit-level functional testing.



