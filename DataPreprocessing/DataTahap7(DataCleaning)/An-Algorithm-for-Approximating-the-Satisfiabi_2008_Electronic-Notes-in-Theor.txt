(high-level) conditions are a graphical formalism to specify valid objects as well as morphisms, i.e., they can be used to describe system or program states as well as specify matches for transformation rules. they provide an intuitive formalism for structural properties and are well suited for reasoning about the behavior of transformation systems.



in this paper, we present a sound and complete algorithm that works for conditions over a class of replacement capable categories. instead of enumerating all possible objects of a category to approach the problem, the presented algorithm uses the input condition in a constructive way. starting from the initial object, e.g. the empty graph, elements of positive statements are added if necessary, while the absence of forbidden patterns is checked. the result is a monotone(non-deleting) algorithm which non-deterministically progresses towards a satisfiable object. technically, we generate for each condition a program seeksat. as we need to handover information between computation steps, seeksat works on morphisms of the considered category. to this aim,



the paper is organized as follows. in section 2, the definition of conditions is reviewed and programs over rules with external interfaces for high-level structures such as graphs are introduced. in section 3, the satisfiability algorithm is presented, its correctness and completeness is shown, and for a fragment of conditions, its termination and hence its capability to decide is proved. in section 4, practical aspects concerning a possible implementation and optimization are discussed. we relate our results to other work in section 5. a conclusion including further work is given in section 6. a long version of this paper is available at including detailed proofs.



in this section, we review the definitions of conditions and introduce programs over rules with external interfaces for high-level structures such as graphs. we seek an algorithm for the satisfiability problem of conditions that is not concerned with a specific definition of a structure. therefore, we use the framework of weak adhesive hlr categories introduced as combination of hlr systems and adhesive categories. a detailed introduction can be found in[9,8].



external interfaces may be seen as a kind of input/output types. they can be used to control the location of rule applications. rules with external interface object i correspond to usual transformation rules. for now, to concatenate rule applications, an external interface object x has to coincide with the right-hand side of the predecessing rule. the external interface may be a partial morphism to selectively use the interface information it provides, see example 2.9. the input may be a partial morphism, if programs over rules with external interfaces are considered.



elements. in this example, the external interface expresses that a given chain of nodes in a graph, represented by the last two nodes, must be extended. we will make use of similar handover effects in our satisfiability algorithm. as x= r, this rule is iterable. note, the indices do not correspond with the



like the satisfiability problem of first-order logic on graphs and on finite structures in general[21,5], the satisfiability problem of graph conditions and high-level conditions in general is undecidable. we seek a correct and complete algorithm, not always guaranteed to terminate. the algorithm answers yes, as soon a result is found, answers no, if it terminates without results, and does not answer in case of non-termination.



in contrast, seeksat contains no such translation. nevertheless, seeksat seems, to some degree, related to the family of enumeration algorithms that are based on tree search and splitting, like the dpll algorithm. seeksat is based on a tree search where internal nodes correspond to partial solutions(morphisms), branches are choices(partitioning the search space), and leaf nodes are complete results or deadends. instead of splitting, i.e. the process of branching by selecting a propositional variable x from a formula and assigning true and false, respectively, seeksat will either skip, modify the morphism by adding elements to its codomain(positive statement) or backtrack(negative statement), depending on the satisfaction of the considered subcondition by the current morphism. while currently not the case, seeksat can be made aware of the propositional structure of a condition to exclude whole branches of the search tree without losing results, as discussed in section 4. this should strenghten the above relation.



