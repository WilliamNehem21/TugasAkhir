we present a simple calculus where imperative features are modeled by just rewriting source code terms, rather than by modifying an auxiliary structure which mimics physical memory. formally, this is achieved by the block construct, introducing local variable declarations, which also plays the role of store when such declarations have been evaluated. in this way, we obtain a language semantics which is more abstract, and directly represents at the syntactic level constraints on aliasing, allowing simpler reasoning about related properties. we illustrate this possibility by a simple extension of the standard type system which assigns a capsule tag to expressions that will reduce to(values representing) isolated portions of store.



the rest of the paper is organized as follows: in section 2 we provide the formal definition of the calculus, in section 3 the type system, in section 4 the results, and in section 5 some conclusion and pointer to further work. the appendix provides auxiliary definitions. proofs omitted for lack of space will be provided in a forthcoming extended version of this paper.



9 more precisely, can be temporarily aliased, e.g., when passed as parameter of a method, but cannot be stored within other objects. that is, aliasing here means static aliasing in the sense of. as discussed there, static alias can cause unpleasant surprises at an arbitrarily distant point in an execution, whereas dynamic alias has no effects beyond the scope in which it occurs.



behaviour of type modifiers. notably, in rule(t-field-access), the type modifier is propagated to fields. for instance, fields of a readable object are readable as well. in rule(t-field-assign), neither the receiver nor the right-hand-side expression can be readable. in rule(t-new), analogously, values assigned to fields cannot be readable, since saving a reference as field of an object introduces an alias.



it should be clear how to extend the formal definition to handle primitive types, used in previous and following examples. briefly, modifiers make no sense on such types, which are simply used in the standard way. for instance, in the premise of rule(t-new) the types of constructor arguments could be primitive types as well, whereas in rule(t-meth-call) the type of method receiver could not.



the inner block(right-hand side of the declaration of x) can be typed capsule, since free variable z is only used as readable(neither modified nor aliased). formally, we can apply rule(t-capsule). indeed, the block reduces to( d y= new d(1) c x= new c(y,y) x) which is a capsule.



informally, a capsule is a reachable object subgraph where nodes cannot be reached from the outside. in our model, where reachable object subgraphs are directly represented by language values, a capsule is simply a closed value. hence the fact that an expression of capsule type actually reduces to a capsule can be stated as in theorem 4.6 below.



the fact that aliasing properties can be expressed at the syntax level should more easily allow the implementation of an interpreter for the calculus into a theorem prover. indeed, e.g., the key theorem prover uses an approach, called abstract object creation, where parallel update(a kind of runtime expression) is added to the language and used to represent the store inside the code: all the object creations and field updates are preserved and consulted by field accesses.



in future work, we plan to use(variants of) the calculus presented in this paper as a basis to express and formally verify different properties of object graphs, among those proposed in the wide literature about ownership, see, e.g.,. a more ambitious goal will be to investigate(a form of) hoare logic on top of this model. we believe that the hierarchical structure of our memory representation should help local reasoning, allowing specifications and proofs to mention only the relevant portion, analogously to what is achieved by separation logic.



we warmly thank the anonymous referees for their very useful comments. in particular, one referee pointed out the analogy with scope extrusion in the pi-calculus, leading to a better formulation of congruence and reduction rules. we also thank lindsay groves, co-author of a preliminary version of this work, with focus on didactic applications.



