automatic static checkers based on model checking, particularly sat-based bounded model checkers, are used in industry, but they sometimes suffer from the scalability problem. scalability can be achieved with the notions of design by contract(dbc) and modular checking. however, modular checking with dbc still have some problems. the method is insufficient for handling pointers to functions(function-pointers) which are abundantly used in c programs, defensive programming which is widely adopted in industrial software development projects, and re-entrancy which sometimes occurs in programs using callback functions. this paper proposes a dbc notation for the above problems and a checking method that uses behavioral subtyping to clarify the exact location where an error occurs.



suffer from the state space explosion problem, which results in them having poor scalability. users sometimes have to pre-process the program codes to cut down its size before they begin checking with the tool. the resulting witnesses of errors also need to be manually checked afterwards. a systematic means of modular checking is desirable to overcome this problem.



varvel, a sat-based bounded model checker for c programs, combines model checking and modular checking. it performs modular checking on top of the model checker f-soft. the idea of introducing dbc to a program model checker is not new. for example, cbmc and bogor as well as f-soft provide two primitives, assume and assert. these primitives can be combined to emulate behavioral specifications needed for modular checking. however, varvel explicitly introduces such a dbc style, which means that the tool automatically embeds the appropriate primitives corresponding to a contract at specific positions in the source programs and conducts model checking.



furthermore, varvel provides advanced features to deal with dbc for higher-order functions. in c programming, higher-order functions are emulated by using function-pointers. the capability of handling functionpointers is mandatory for checking industrial c programs because they use many function pointers.



in this paper, we illustrate how the model checker we developed(varvel) can provide modular checking, i.e., modular checking with model checking. we also discuss dbc for function-pointers and the case of defensive programming. the code snippets in the paper are from source programs developed in industry that varvel has been applied to.



(1) and(2), it is possible to check the calling program and the called program separately; modular checking is performed and the method is scalable. a further advantage of dbc is that it clarifies where the responsibility lies for fixing a defect. for instance, if s does not satisfy prep, the calling program clientp rogram needs to be modified.



a disadvantage of modular checking is that it does not perform the interprocedural flow-sensitive analysis because it stops the analysis at the boundary of the contracts and uses no caller side information. therefore, modular checking produces many spurious witnesses of the errors. particularly, it does not handle re-entrancy where a function of a module will be processed while the other function of the module is processed. in addition, the expressiveness of the contract notation has some problems, such that it does not handle higher order functions(function-pointers in the case of the c language). also, dbc remains controversial to what should be denoted as contracts, especially for defensive programming.



next, varvel generates state transition and property formulas from the cfg. the state transition is represented as a set of formulas. each formula denotes the next value of a variable from the current values of some variables. a property is an ltl formula denoting the condition to reach the error nodes. the tool converts these formulas into boolean formulas and passes them along to the model checking engine, which then performs sat-based bounded model checking on the given boolean formulas.



functional languages that treat functions as first class data must be able to handle the contract of a higher-order function. there is an existing work that introduces contracts to scheme, but the contracts are checked at run-time, as in eiffel. our method differs from the existing work because it checks contracts statically.



a higher-order function is difficult to check against a contract statically, since the preconditions and postconditions of a callee function are not decided until the address of the callee function is assigned to a function-pointer. modular checking divides a program into modules by regarding contracts as boundaries. this makes it even more difficult to use the source codes of the callee functions in other modules.



defensive programming is a technique for achieving robustness, and it has been used in many industrial software development projects. programmers write as many checking codes for the invalid arguments as possible. from the viewpoint of the design or functionality, the contract of a function is an external specification of its intrinsic functionality to the other functions. in this sense, the contract of a function should not accept invalid arguments because they result in the function returning just an error code without performing its intrinsic functionality.



that represents an external specification for the intrinsic functionality. the precondition@pre denotes that callers must not pass null to bar in order for bar to perform its intrinsic functionality. case 2 is an example of a internal contract that represents an internal specification for defensive programming. no precondition indicates that bar accepts any actual argument, and the postcondition@post denotes the result for each case of an actual argument. if p is not null, bar returns a non-negative value. if p is null, bar returns a



external and internal contracts can be handled with the help of behavioral subtyping. the relationships below should be respected for the consistency of the external and internal contracts as mentioned in the section 4.2. namely, the internal contracts that represent all behaviors of a function correspond to supertype and the external contracts that are specialized for behaviors of its intrinsic functionality correspond to subtype.



resolution of actual function the re-entrancy in c programs is often caused by a function call through a function-pointer. f-soft performs a pointsto analysis to determine the set of function addresses that are potentially assignable to a function-pointer and constructs a proper cfg in consideration of the function-pointers. varvel can make use of such features provided by f-soft.



as mentioned in sections 4,5, and 6, a sat-based bounded model checker supporting modular checking can overcome the weakness in modular checking if we adopt the notion of behavioral subtyping and enhance dbc notations. however, it needs to consider other aspects for a practical use of the tool. the explanations are in order.



initialization for invariants. the invariants are met after the initialization is completed. object oriented languages like c++ and java have a constructor, which is a language construct for initialization. c dose not have a constructor and the initializer of the variable declaration in c is not expressive enough to initialize the variables with complex data structures. c programmers usually write their own initialization functions. dbc notations must be enhanced to instruct the static checkers about the initialization function.



it is not easy to solve the above issues by considering only the syntax and semantics of c language. we need to more thoroughly understand programming convention currently in practical use; how developers write industrial source codes(defensive programming, etc.) and how they create logical modules using language constructs and physical containers. we plan to establish a convention so that the advanced checking discussed above can also be performed by varvel.



