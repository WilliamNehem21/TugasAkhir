paradigm models specify coordination of collaborating components via constraint control. component mcpal allows for later addition of new constraints and new control in view of unforeseen adaptation. after addition mcpal starts coordinating migration accordingly, adapting the system towards to-be collaboration. once done, mcpal removes obsolete control and constraints. all coordination remains ongoing while migrating on-the-fly, being deflected without any quiescence. through translation into process algebra, supporting formal analysis is arranged carefully, showing that as-is and to-be processes are proper abstractions of the migrating process. a canonical critical section problem illustrates the approach.



such a collaboration has to change, dynamic consistency is even more problematic, particularly so during migration. for a similar reason, the notion of quiescence has been introduced for adaptive systems: a system part, having to change while the system is ongoing, is isolated first from its environment, then it is changed, e.g. by replacing it, and finally, the part in its renewed form is reconnected. thus, quiescence circumvents dynamic consistency problems in ongoing collaborations during the actual change, by separating a part from what remains ongoing.



algebra we consider, defining how components communicate. thus, a paradigm model of an adapting system, including the special component mcpal, is translated into pa. so, using a well established abstraction technique of pa, we can formally analyze the adaptation process. for instance, we can prove that as-is collaboration indeed migrates to to-be collaboration. in particular, the pa model makes the adaptation dynamics explicit. therefore, for every migration trajectory, progress properties can be verified.



a phase, when being current state of a role, is a dynamic constraint imposed on the detailed std underlying the role, containing all transitions allowed by the role in that phase. thus, a detailed transition can only be taken if admitted by each current phase of the various roles assigned. a connecting trap of a phase is a further dynamic constraint committed to by the detailed std, serving as guard for a phase transfer, often to be carried out in combination with simultaneous phase transfers in other roles.



the above two consistency rules let scheduler conduct the cs roles of the workers. the roles, by imposing the current phase, in turn dynamically constrain the five detailed steps of each worker. some of these steps actually lead to entering a connecting trap. via such a trap entered, detailed stds dynamically constrain coordination steps of scheduler. in general, a consistency rule synchronizes single steps from different stds: zero or one detailed steps, zero or more role steps and a so-called change clause to update the consistency rules within a protocol. if present in one rule, the role steps together constitute one protocol step. if synchronized with a detailed step of an std m, this m is referred to as the conductor of that protocol step.



four rules have mcpal coordinating migration by conducting evol phase transfers of all other participants. in the first rule, mcpal starts scheduler migrating and, simultaneously, it transfers the three workers to their new full dynamics. as long as scheduler has not transferred their as-is cs phases to to-be ones, such new dynamics will remain excluded, although allowed by mcpal already. the remaining three rules transfer scheduler from migrating to round robin scheduling only, depending



in this section, mcpal and the other example components from section 2 are expressed as pa processes, following the translation of. using the translation we formally prove that the system migrates indeed from the as-is to the to-be behaviour. moreover, the pa specification can directly be taken as an input for the mcrl2 modelchecker, to be used for further analysis of the migration model.



having formalized the separate components and the systems they compose, we are able to relate the models. see theorem 3.1 to 3.3 below. the first result states, as long mcpal(evol) is not allowed to perform the choreography step prepared, meaning it cannot start migration, the larger migration system has the same behaviour as the as-is system, up to branching bisimulation[7,1]. this is specified first by blocking the action prepared and second by abstracting all actions mcpal can perform in the hibernating phase; thus all actions act(mcpalhib)= suming that there are n different trajectories tk, k= 1,..., n. assume that state sk is the first state on trajectory tk that is a state in the(lts of the) to-be model pm2. and assume that the set i contains all actions occurring in pm1to2 but not in



the above mcpal is reminiscent of two other mcpal versions from earlier work[10,11]. compared with, the above mcpal is far more general, since the older one, lacking a mcpal(evol) role, has exactly two fixed migration steps between crs extension and crs reduction only. the older version does allow for quite some freedom in unforeseen migration, however, as both fixed migration steps can be adorned, lazily but just-in-time, with new conducting, even repeatedly so for later migrations. nevertheless, more than two migration steps, alternative migration steps or iterated migration steps cannot be covered at once, which for the above mcpal are no problem at all. the concrete migrations in are also less comprising, more cautious than the above example combining change of all detailed and role dynamics within one migration cycle.



(iii) mcpal kicks off and conducts the others from as-is collaboration to to-be collaboration, while keeping them ongoing.(iv) mcpal out-phases obsolete dynamics of all others, while keeping to-be collaboration of the others ongoing.(v) mcpal returns to hibernating by out-phasing its migration conducting dynamics and removing obsolete constraint control, while keeping to-be collaboration ongoing and continuing to do so thereafter. the above five steps constitute the backbone of mcpal, serving as architectural redesigner as well as redirector of ongoing collaboration for all kinds of paradigm models.



there is much research addressing dynamic system adaptation. generally, formal analysis of the migration trajectory is ignored. exceptions to this are mainly found in the wcat community. in the setting of component-based software engineering, process languages and mobile calculi are used to express run-time adaptor modification for coupled cots components[4,5,6,16]. however, tool support towards formal analysis of run-time adaptation has not been addressed so far. moreover, whereas adaptors do change, components cannot, unless by replacement: they are from on-the-shelf.



