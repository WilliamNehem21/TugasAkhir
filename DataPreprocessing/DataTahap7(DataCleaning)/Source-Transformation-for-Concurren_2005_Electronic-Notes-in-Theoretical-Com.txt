concurrent programming poses a unique set of problems for quality assurance. these difficulties include the complexities of deadlock, livelock and divergence, which can be extremely difficult to detect and debug. a variety of tools have been developed to assist designers and developers of concurrent applications. some of these tools, such as verisoft, are specific to particular implementation languages, such as c++.



the java remote method invocation(java rmi) package facilitates the implementation of concurrent applications designed for networked environments, for example client-server systems, and is widely used for production applications in e-commerce and other distributed environments. java rmi provides a higher level of abstraction by hiding low-level concurrency implementation details. however, it does not relieve the developer from the potential pitfalls of controlling concurrent access to remote objects, and in fact may make concurrency problems even more difficult to find.



a variety of tools have been developed to assist in the design and development of correct concurrent applications[4,15,21]. some of these are based on abstract models from which code can be generated(in whole or in part), others are based on analyzing the source code. one of the latest tools is the verisoft state space exploration system. verisoft provides a set of libraries and an execution engine that explores the state space of a concurrent program implemented in c++ using inter-process communication. in addition to deadlock, livelock and divergence, the developer can specify invariant assertions that must hold throughout the execution of the program.



verisoft is explicitly designed to analyze c++ programs using inter-process communication, and cannot be used with other languages and concurrency methods directly. the verisoft website describes one possible way of analyzing java, which is to call the virtual machine from a c++ program. however, such a method treats the java program as simply a black box, and severely limits the analysis that can be done on the java program itself. in particular, it does not address the problem of representing the concurrency of java rmi using verisoft inter-process communication, and thus does not allow for concurrency analysis of java rmi. moreover, java rmi systems are by nature distributed, typically including several independent communicating java programs, not just one.



the main reason we have chosen to work with verisoft in this experiment is that it works directly with source code. being able to perform the analysis directly on the source code has two advantages. first, the possibility of spurious analysis results due to modelling inaccuracies is reduced because no model needs to be constructed. second, it is simpler to relate analysis output such as error traces or counterexamples back to the c++ source code, and by method name back to the java source from which it was transformed. a third advantage of verisoft is the fact that it is stateless, that is, it performs its analysis without an explicit representation of the values of program variables. stateless analyses are particularly well suited to the analysis of software systems with large amounts of complicated data such as e-commerce applications.



order reduction. the basic premise behind partial order reduction is that not all interleavings of concurrent events have to be examined. that is, the interleavings that correspond to the same concurrent execution in the state space need not be explored individually. it is for this reason that partial order reduction has been shown to be an effective means to keep the state explosion problem in check.



the remainder of this paper is devoted to explaining how we transform java code that makes use of rmi into c++ code that is analyzable by verisoft. section 3 introduces the various tools and libraries used in our work. section 4 details the transformation process and the advantages of using our tool. java uses a garbage collection algorithm that automatically frees memory that is no longer being used. to mimic this behaviour a simple garbage collection algorithm is developed for c++ and detailed in section 5. an example of the final results of our transform is explained in section 6. section 7 gives a short overview of some of the other experiments we have performed. finally, related work is described in section 8, followed by our conclusions and future work in section 9.



verisoft is a tool that can be used to analyze concurrent c++ programs. it does this by traversing the state space of a program up to an arbitrary depth as set by the developer until it finds a deadlock, divergence, livelock or until some user defined assertion fails. the depth of any state space traversal is dictated by the presence of visible operations. visible operations are any functions from the verisoft library, which include, but are not limited to, message passing operations and non-deterministic choice points.



txl is a pure functional programming language specifically designed to support structural source transformation. the structure of the source to be transformed is described using an unrestricted ambiguous context free grammar from which a parser is automatically derived. the transformations are described by example, using a set of context-sensitive formal transformation rules from which an application strategy is automatically inferred.



this stub method begins by putting the string of characters represented in the macro global executetask var into the message character array. then it sends those characters to the verisoft messaging queue variable named m remoteobjectmsgqueueid. the messaging queue object is a verisoft-specific class used to send messages between processes. once those characters have been sent to the queue, the buffer containing them is deleted locally. the code then blocks until it receives a return message from the queue. if the received message is what it expects(i.e. the same message it sent) then it returns, otherwise the smart-pointer version of a remoteexception object is thrown.



verisoft can then be used in one of three modes(manual, guided, or automatic simulation mode) to analyze the resulting model. manual mode allows the user to manually step through the execution of the code. guided mode is used if the user wants to specify when a particular process will execute its next visible operation or which number is chosen at a toss point(a point in the code where a range of numbers can be selected to be returned from a function). automatic mode allows verisoft to run automatically and return at what point(if any) in the state space of the program execution that it found a deadlock, divergence or livelock.



our memory solution introduces two new java classes. the first is a smart pointer class that makes use of templates. this class is used in place of regular c++ pointers. it allows dynamically created c++ objects the advantage of staying on the stack(like automatic objects). as these pointers are copied and assigned, they adjust the reference count of the objects that they point to. smart pointers have deconstructors to make sure that reference counts are adjusted appropriately when a pointer variable goes out of scope.



another of our examples is a simplified version of a networked financial transaction system. clients in the system all share the same account, depositing money into the account and getting the balance. this example made use of 10 separate clients making remote method invocations on a shared remote object. in one execution a divergence was successfully found at a depth of



many transformations done by other tools actually miss the underlying semantics of the language[14,7]. an example of this is the transformation done by bandera in transforming java to promela. in this transformation important dynamic i/o functionality(sockets, files, etc.) are impossible to transform, though it is possible to model the behaviour of these services(reading or writing from files, sending messages over ports, etc.) by indicating whether methods are blocking or non-blocking, dependency relationships, etc.



although both can model java programs, neither bandera nor java pathfinder are capable of transforming/translating java rmi into a modelling language[22,19]. the main problem lies in the abundance of native methods in the java rmi framework. by automatically transforming to c++ at a higher level of abstraction our work avoids this problem.



these analysis tools are well suited to examining aspects of programs similar to those we address, but using modelling languages that are more limited in their i/o capabilities than java. the behaviour of i/o libraries must be modelled by determining the essential properties(blocking, non-blocking, dependency relationships, etc.) of the i/o functionality and encoding them in the modelling language.



transformation. another disadvantage is that verisoft does not support dynamic process creation, thus the tester must know the number of processes to be created at compile-time in order to do the analysis. this allows us to model and analyze java rmi applications with any given number of clients, but it limits some of the options for the analyst. for bounded numbers of dynamic processes, this problem can be partially addressed by modifying the transformation to handle dynamic process creation automatically by mapping to a pre-allocated fixed number of static processes.



the most obvious need in this work is for continued testing on larger examples and production systems. the scalability of our solution faces three challenges: the sheer number of java library classes on which a java rmi program may depend, the ability of the txl transformation to handle such large sources, and the ability of verisoft to analyze the large size of the resulting transformed c++ programs. since both txl and verisoft have already been proven to handle very large production programs in practice, it is actually the first of these that is the biggest threat to our technique.



