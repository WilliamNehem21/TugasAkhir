prevent conflicts. the two solutions, even if applied here to a fixed, though rather general, formalism, can be considered paradigmatic. we prove that both solutions are sound, in the sense that they prevent ill-formed combination of components, and formally compare the two approaches.



the paper is structured as follows. in sect.2 we provide a brief informal introduction to the r-calculus. in sect.3 we extend the calculus with the receive primitive, discuss informally the problem of guaranteeing safe composition in this case, and present the hiding-based solution. in sect.4 we present the constraintbased solution and compare the two approaches. finally, in sect.5 we summarize the contribution of the paper and briefly discuss related and further work. to ease the reader, we have added in the appendix the formal definition of the r-calculus, together with proofs.



work for software composition provided by mixin modules the operation consisting in solving clashes by renaming can be nicely internalized in terms of the primitive language operators, whereas in previous work[11,4] this operation can be only defined at a metatheory level and sometimes in a rather tricky way. however, by a preliminary analysis there seems to be no trivial way to generalize this approach to the higher-order case, since we would need an hiding operator propagating to subcomponents as well, which can be hardly be expressed as a derived module operator. this can be seen as another drawback of the hiding-based approach versus the constraint-based, which can be immediately generalized to higher-order modules.



as already mentioned, the schema we adopt here, based on a combination of static typechecking of local code and dynamic checks via subtyping is the same as in momi. however, there are many differences with this work. first, in momi exchanged code is object-oriented(more precisely, classes or mixin classes), whereas here we are interested in a more general framework for software composition where entities which are exchanged are mixin modules on an arbitrary core language. note, in particular, that this allows symmetric composition(by sum) of local and external code, differently from momi where composition is always in one direction(instantiation of a mixin class on a parent). moreover, in momi there is an explicit language for the process layer, different from the language used for the objectoriented code; here instead for simplicity we have just a receive primitive integrated in the language, since this addition was enough in order to study the problem of dynamic checks.



other work which has directly inspired this paper is that on dynamic software updating in, e.g.,[5,17,12]. however, our approach here is in the context of module/fragment calculi rather than lambda-calculi, and we take as basic primitive a receive primitive for retrieving external code on demand, whereas in[5,17,12] the basic primitive is an update primitive which when performed changes some part of the local code in a less controlled way.



the extension to a higher-order calculus. finally, even though the framework for software composition offered by the r-calculus is rather general and powerful, we are bound to a fixed arbitrary set of operators; hence, we would like to investigate an even more abstract framework for expressing and studying safe combination of local and retrieved code via dynamic checks. all these directions have already been partly investigated in.



