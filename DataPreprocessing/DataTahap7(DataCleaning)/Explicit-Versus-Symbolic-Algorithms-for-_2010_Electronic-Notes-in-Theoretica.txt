static analysis can be seen as a two-phase process where we first transform the analysis problem into a set of constraints that, in the second phase, is solved to produce the analysis result of interest. the constraints may be expressed in a language tailored to the problem at hand, or they may be expressed in a general purpose constraint language; in this paper we follow the latter approach and consider alfp, alternation-free least fixed point logic, which is an extension of datalog. alfp has successfully been used as the constraint language for sophisticated analyses of a wide variety of programming paradigms including imperative, functional, concurrent and mobile languages and more recently for model checking[4,12].



while a wide variety of analysis problems can be rephrased into the same constraint language it is not necessarily the case that they all will benefit from the same solver techniques. we can for example imagine that certain solver techniques are better at handling certain types of input formulae, due to the use of specialized data structures. it is therefore desirable to be able to experiment with different data structures and algorithms for solving the constraints. similar considerations



the rest of this paper is organized as follows. we first give the necessary background information on alternation-free least fixed point logic in section 2. in section 3 we describe the overall structure of the algorithm that is shared between the two solver algorithms. sections 4 and 5 describe the data structures and the algorithms of the differential and the bdd based algorithms respectively. we continue in section 6 with experiments, employing model checking to verify a number of properties. we conclude in section 7.



in the case of assertions the details depend on the actual algorithm and we shall return to those later. the case of conjunction is straightforward as we have to inspect both clauses. in the case of implication we make use of the function check that in addition to the precondition and the environment also takes the continuation execute(cl) as an argument. in the case of universal quantification we perform a recursive call using an updated environment; the details of which depend on the actual algorithm.



in this section we present the main data structures and the details of the differential worklist algorithm[14,13]. the algorithm computes the relations in increasing order on their rank and therefore the negations present no obstacles. it combines the top-down solving approach of le charlier and van hentenryck with the propagation of differences, an optimization technique for distributive frameworks which is also known in the area of deductive databases or as reduction of strength transformations for program optimization. as mentioned above the main data structures are env and result representing the(partial) interpretation of variables and predicates, respectively.



the formulation is based on abstractions of the actions that annotate the edges of a program model. assignment statements, x:= e, are abstracted to actions modx, whereas all other statements are abstracted to actions use. intuitively, the formula verifies whether there exists a path, ef, not modifying variable x, leading to a state labeled l which has outgoing transition, ex, that modifies x. the actl formula is translated into the alfp formula:



from the experiment results for modalities ex and eu we observed that both algorithms were slightly slower for the second case. this is caused by two factors, greater length of the formula for modality eu and secondly the nesting of quantifiers, which in both cases is the same. together, these factors determine the complexity of the algorithm. what is more, the results show that the differential algorithm outperformed bdd implementation by a factor of two in both cases. this is caused by the fact that when resuming computations the differential algorithm only propagates the differences, whereas in the current implementation of the bdd based algorithm entire clauses are recomputed.



