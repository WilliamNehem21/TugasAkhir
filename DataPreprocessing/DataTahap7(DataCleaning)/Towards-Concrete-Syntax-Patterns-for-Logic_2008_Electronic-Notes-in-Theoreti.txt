program transformation, the act of changing one program into another, is one of the most fundamental activities of software development. automated program transformation helps software engineers manage the complexity and continuous evolution of modern software projects. in particular, tools that treat transformations as first class entities let programmers quickly define transformations that suit their needs. depending on their formal foundations these tools can be roughly classified as based on term rewriting[31,4,28,33,1], graph transformation, or logic[35,7]. each category has its particular strengths and weaknesses.



logic meta-programming is the use of logic programming for analysing and transforming the logic representation of a program[7,35]. the logic programming language is typically a variant of prolog or some other system implementing topdown sld resolution[16,15]. logic meta-programming allows for easy implementation of program analyses as predicates and queries on the program representation.



modified method. since the type of this is the enclosing class, class, the replaceable predicate verifies whether selftype is implemented by class and provides the same interface as class. its implementation is not shown here, for brevity. line 8 unifies the param variable with a new, unique identifier. line 9 creates a clause representing the new parameter. lines 10 and 11 replace the clause specifying the method signature by a version that includes the new parameter as the first one in the parameter list.



summarizing, lmp offers a smooth integration of analysis and transformation at a high conceptual level and produces easy to reuse implementations. however, it lacks a well-defined semantics and the ability to work with concrete syntax. the remainder of this paper incrementally introduces a logic-based program transformation approach that offers the advantages of logic meta-programming but avoids its problems.



??args is bound to an empty argument list. each match of the csp yields a tuple of values(a substitution) for the mv tuple(?expression,?call,??args). in our example the substitutions are(a,a,[42,43]),(this,y,[]),(this,y,[]) and(this.y(),y,[]), where[] denotes the empty list.



in order to use csps in logic programms, we introduce a special pattern predicate, is. it is often necessary to be able to refer to the entire program element matched by a csp. for this purpose, the left-hand-side of is denotes the program element matched by the csp on the right-hand-side.



this design provides benefits in terms of reduced dependencies on transformed programs and increased reusability of transformation specifications. because the meta-variable values are determined by evaluation of predicates and preconditions can share meta-variables with transformations, it is possible to define analyses and transformations without referring to concrete instances, e.g., identifier or types of program elements. this leads to very generic and reusable transformation specifications. in addition, gentl provides reusability of the elements used in analyses and transformations. predicates encapsulate program analyses that can be reused in different preconditions. the generate declarataion encapsulates concrete syntax based templates for the code to be generated by transformations.



gentl supports self-defined logic predicates in the usual prolog notation. own predicates can be defined based on a standard set of predefined predicates common to logic programming languages. however, gentl explicitly excludes predicates that change the logic database. only the most important predefined predicates are described in the following.



if the arguments are different constants of variables bound to different constants, unification fails. otherwise the arguments are unified, that is, they are bound to the same value. note that, unlike an assignment, unification is symmetric. for instance, the unification of a constant on the left-hand-side and a variable on the right-hand-side, e.g. const=?var succeeds if the variable has the same value as the constant or did not have a value before.



compared to the basic ct concept, the syntax of transformations supports a higher level of abstraction. first, it enables use of concrete syntax patterns for specifying code to be generated. second, it frees programmers from having to manage the creation of new unique element identities. third, it allows for specifying relative locations of added elements with respect to existing ones.



the ct add self parameter introduces a new parameter named self of type?selftype to all public methods for which the replaceable test in line 4 is true(cf section 2.2) 3. the add transformation expresses that the new parameter is inserted as the first one in the list of parameters of the modified method.



the ct redir self calls in redirects all this-calls to the new self parameter. the precondition matches all this-calls, making their receiver,?recv, which is bound to this, available for replacement. the action replaces?expr with self, the identifier of the new parameter.



the right-hand-side shows a pattern predicate and its implementation as a jtransformer query. here, use of a color in the lower part indicates the implementation of the gentl expression with the same color from the upper part. use of a color on the right-hand-side indicates a gentl expression(or its implementation) that matches the java element(or logic facts) marked with the same color on the left-hand-side.



note that gentl meta-variables are directly mapped to unbound logic variables in the implementing jtransformer query. note also that the illustrated translation of java to logic facts also defines the translation of concrete syntax patterns used in transformations. at the time when a transformation is executed, all the metavariables in its patterns are guaranteed to be bound to concrete values by the prior evaluation of the condition. thus, the patterns have become plain base language code.



soul, the smalltalk open unification language, enables meta-programming with logic queries and program transformations for smalltalk, in smalltalk. it provides a sophisticated, dynamic integration of the object-oriented base language and the logic-based meta-language, which goes beyond the capabilities of gentl. however, its ability to express concrete syntax patterns is restricted to quoted strings, as in tyruba. recently, roover et al. presented an extension of soul for matching execution flows with concrete syntax patterns.



borba et al. introduce jats, the java transformation system, which allows the definition of pattern based rewriting rules. each rewriting rule is a pair of concrete syntax patterns describing the program state before and after a transformation. like gentl, both parts can be linked by the use of common meta-variables



like its predecessor, logicaj2, gentl provides a way to explicitly declare syntactic types for meta-variables. we have omitted discussing this feature because we regard it as a step back to a language model that forces programmers to know and think in terms of the entire set of syntactic categories of the base-language. rho and kniesel propose a type inference mechanism for logicaj that we intend to adapt and generalize for gentl. another source of inspiration could be hats[33,34].



defining complex analysis and transformation rules using logic meta-programming can be elaborate, error-prone and suffers from semantic problems. the conditional transformation formalism supports logic program transformation with a structural breakup of analysis and transformation. additionally, cts provide a composition mechanism for transformations. however, cts are still declared at the ast level. we claim this level provides not the appropriate abstraction for transformations.



in this paper, we have introduced gentl, a generic transformation language. gentl combines concrete syntax patterns with predicates. transformations are defined as conditional transformations. as a result, gentl allows the definition of program analysis and transformation rules in a easy and reusable way.



