the work presented in this paper addresses the challenge of fully verifying complex temporal properties on large rtl designs. windowed induction has been proposed by sheeran, singh, and stalmarck as a technique augmenting bounded model checking for unbounded verification of safety properties. while induction proved to be quite effective for combinational properties, the case of temporal properties was not handled by previously known methods. we introduce explicit induction, a new induction scheme targeted to temporal properties, and to interactive development of inductive proofs. the innovative idea in explicit induction is to make the induction scheme an explicit part of the specification, where it can be easily controlled, using a highly expressive language like forspec. we show how explicit induction was implemented with minor modifications in the forspec compiler and in thunder, a bounded model checker. finally, we describe how explicit theoretical completeness is demonstrated by having the property q describe the set of reachable states of m. note that induction hypotheses are typically much simpler than a full reachable state description. when it succeeds, induction is able to handle larger models than bounded model checking, since the induction step has to consider only paths of length 1, whereas bounded model checking needs to check sufficiently long paths to get a reasonable confidence.



ening p, if we restrict the induction step only to loopfree paths, completeness can be proved by choosing n to be the recurrence diameter of the transition system m, i.e., the maximum length of a loopfree path in m. the advantage of windowed induction over classical induction is that it provides the user with two ways of strengthening the induction hypothesis: strengthening the invariant q or lengthening the window n.(for simplicity, we do no mention the loopfreeness condition in the rest of our discussion, but it is implemented in our tool.)



windowed induction is used in, and is considered more abstractly in. the formal verification environment in intel offers this induction scheme as an automatic mode in the sat-model checker thunder. the bound n is iteratively increased until either the proof succeeds or a given limit is reached. windowed induction and standard induction have the same theoretical capabilities, but windowed induction often permits much simpler induction hypotheses. in many cases the size of windows is relatively small. as with simple induction, we get the best of both worlds: we get a correctness proof and we get the ability to handle very large models.



a loopfree path in the product mp= m ap. in the worst case, the minimal window n for which the induction succeeds is the recurrence diameter of the system m(the minimal length of loopfree paths in m), which usually exceeds the capacity of the tool.(it might seem that the problem is caused by the specific automaton used in the example, but this is not the case.)



this limitation is in fact what motivated our work. we want to perform the inductive reasoning directly on the original temporal formula, rather than on the results of its compilation. to this end, we encode the induction scheme explicitly as part of the specification. a failure to prove the induction produces a meaningful counterexample, which reflects the real reason of the failure and is not due to compilation artifacts anymore. understanding the induction failure is a crucial hint for strengthening the inductive property.



model checking, as we discuss later. for readers not familiar with the forspec language, the formula always[0,n] q means that q holds in the first n+1 states of a path. similarly, next[n+ 1] q means that q holds in the n+ 2-nd state of a path.



this section examines the tool support necessary to implement the induction checks(ii-a) and(ii-b) described in subsection 1.4. note first that(ii-a) comes down to checking the assertion always q until bound n(see discussion below for the impact of formula depth on the bound). this is a plain bounded model checking problem.



induction hypothesis, that he can use to mark the assumption always[0,n] q. this way, one can distinguish between assumptions that strengthen the induction proof and regular assumptions that specify the interface with neighbor rtl blocks. based on the new keyword, the forspec compiler marks every one of the automata it generates as an assertion, assumption, or induction hypothesis. this information is passed to the model checker that makes sure to use only the initial constraints from the assertion and the induction hypothesis.



finally, note that the bounds n and n+1 used in the two checks above are appropriate for the case where q is a combinational property. we mentioned earlier that p(and hence q) can be a bounded safety property. in this case, the bounds used depend on the length of the time windows employed in p. usually, we end up choosing an offset k, such that the induction base(ii-a) is



in implicit induction, the invariant is the result of automatic translation of the property. hence, the user may find it difficult to strengthen the invariant(as explained above) and his most probable strategy would be to increase the window size. in explicit induction, the strengthening can be achieved by changing both the invariant and the window size.



the forspec directives needed to express explicit induction proofs are assert, assume, and induction hypothesis. the keyword assume is used to give auxiliary assumptions(e.g., assumptions about inputs etc.). the explicit induction technique does not depend on the usage of forspec, the forspec constructs described below help expressing and maintaining the induction hypotheses.



we then check these two directives in a model checking run of n+ 1 cycles. not only does the block template give us a compact notation, it also keeps the low level formulas denoting assertions and inductive hypotheses synchronized. they refer to the same property q and the same bound n, which prevents false positives.



in some cases it is convenient to use a different window size for different induction hypotheses. this provides useful insight into the pipeline/logic depth that each property depends on, and also helps select minimal sufficient model checker bounds to control complexity. it is a strength of this methodology that it is flexible enough to use either independent or identical induction window sizes for different specs.



for any property that can be proved inductively, there will be some induction window size for which it and all larger window sizes yield a successful proof, and all smaller window sizes fail with a counterexample in the formal model. initially it is not known what window size is needed, so starting with larger window sizes can be beneficial. on the other hand, shorter window sizes find counterexamples more quickly, and shorter counterexamples are easier to debug.



as a general rule, we estimate an induction window size n that might work and try to prove the property q. if we get a failure, we examine the counterexample. if the counterexample looks like it could be due to out-ofsync initialized pipelines, the induction window size needs to be increased. if the counterexample looks like it is caused by some state in the formal model that should not be reached in the actual circuit, the inductive hypothesis probably needs strengthening. the strengthened hypothesis typically adds a new constraint that forbids some problematic state combination that contributes to the counterexample.



the lock protocol is used in the pentiumtm4 to allow different threads to execute atomic operations on several shared resources. the lock protocol is important to verify because it interacts subtly with several other microarchitectural features, making its functional correctness crucial. the lock protocol interacts with the cache coherence protocol, as well as with several other performance optimizations.



when trying to prove the mutual exclusion property, we quickly get induction failures. the model checker provides a witness trace for which the inductive step does not hold. usually this is due to starting in states that are unreachable in the real model. for instance, the control part of the protocol is modeled as a finite state machine. some induction failures are traces that include concurrent occurrence of certain events that cannot actually happen together in the real model. adding a simple induction hypothesis eliminates such trivial failures.



developing the inductive proof is therefore an iterative process, where we keep strengthening the induction hypothesis based on the failures of previous attempts to establish induction. overall, we had to add about twenty constraints before the hypothesis was sufficiently strong to establish induction. the window size of the inductive proofs differed from property to property. only three properties were provable with a window size of one cycle. all the other properties were proved with a window size of six to twelve cycles.



the model we verified is quite large, containing about 12,000 state elements. this is considerably beyond the capacity(a few hundred state elements) of bdd-based model checkers. the verification effort for the proved properties described here took three to six person-months. most inductionstep runs completed within 20 minutes, checking 36 steps, using under 600m of memory. all induction-step runs completed within 3 hours, checking 48 steps, using under 1g memory.



another comparison with our approach is induction using ste instead of sat as the bounded model checker. induction with ste has been used successfully at intel for several years, particularly for datapath logic and floating-point property proofs. sajid and kaviola pioneered the extension of ste induction to a moderately complex control logic property. direct comparisons between the ste and sat induction approaches are not easy because of tool differences. our 12000 state element model, even reduced to the critical latches, is likely more than twice the size of the 3000 state element model in. perhaps the largest distinction between sat induction and ste induction is the apparent difficulty or impracticality of doing windowed induction(vs. simple induction) with ste. windowed induction using ste is theoretically possible, but it has problems with rapid variable blowup and/or antecedent conflicts. the work of includes simple induction for exactly this reason.



the methodology and tool support presented in this paper address the challenge of fully verifying complex temporal properties on large rtl designs. the methodology advocated here is interactive development of inductive proofs. there is much ongoing research for automating induction proofs, but no satisfactory technique has been found, even for combinational properties. we believe that for proofs of the complexity encountered in our work, user guidance is needed for finding the correct induction invariants.



