we introduce a novel process calculus called dbspi(distributed broadcast spi-calculus) which models mobile ad hoc networks(manet). the calculus is a cryptographic broadcast calculus with locations and migration. communication and migration are limited to neighborhoods. neighborhood definitions are explicitly part of the syntax allowing dynamic extension using bound identifiers. in this semantic setting recent advances is that of mobile ad-hoc networks(manets). a manet is a selforganizing network that does not rely on the existence of central service providers. this means that route discovery and route maintenance are completely local and that mobile devices act as routers and servers. the mobility and limited send and receive range of such devices cause new challenges in protocol construction. firstly, route discovery and multi-hop protocols are necessary. secondly, topologies that change dynamically need to be captured. thirdly, reliability and security are important issues. finding the right attacker model is not trivial. the dolev-yao attacker seems unrealistic strong in a manet setting because of the limited radio transmission range.



in this paper we describe a process calculus that lets us reason about authenticity properties of manet protocols that use cryptographic operations. we define an attacker model that allows the user of our calculus to choose the strength of the attacker. one example would be the attacker that may only communicate locally. another would be the attacker capable of communicating everywhere.



example 1.1(mobile ip registration) the mobile ip protocol[14,19] allows a mobile device(or mobile node, in short mn) to have one single long term ip-address, when connecting to the internet from different access points. we will assume that a manet is used to establish connection to mn. each device has a home agent(in short ha) in some home network associated with it. the agent acting as the access point for mn(called the foreign agent, in short fa) is a router between mn and ha. every communication with mn from the internet goes through ha and fa.



in sangiorgi and mezzetti introduce a calculus for wireless systems called cws. the objectives of this work are different from ours. sangiorgi and mezzetti study semantic properties of collisions in radio broadcasts. our work is targeted at a higher level of abstraction where problems related to collisions have already been dealt with.



in merro describes the calculus cmn, a broadcast calculus with locations and mobility but without cryptography. here, the connectivity of nodes is described using a distance function and physical radii. it is an interesting and fundamental discussion whether topologies should be given using radii or neighborhood relations. where merro gives simulations we use an approximative verification technique.



where y is instantiated with the content of m. otherwise the process is stuck. local binding of a message m for a free name x in p is written let x= m in p. the constructs begin l and end l are assertions i.e. protocol points. the process release m; p is an annotation used with latent effects in the type system later



messages are built from names, tuples of names and cryptographic constructors for symmetric and asymmetric keys and encryption. messages m and m' are paired by(m, m'). components can be extracted by projections fst(m)(the first) and snd(m)(the second).



are neighbors. rule(r-bcom) defines broadcast communication between neighbors. since i may be a smaller set than the total set of listeners rule(r-bcom) permits loss of messages. rules(r-if) are standard. rule(r-let) permits the use of a local declaration and(r-decrypt) describes decryption of an encrypted message. replication is defined by(r-replication). the annotation release ok; p can be reduced using(r-release). beginand end-assertions do not add anything to the semantics.



in the examples below we will show typical manet features expressed in dbspi. we will start this section by noting that migration is our main semantic tool for what sometimes is called joining and splitting of manet. if we have the following topology ab| bc| bd we see that processes at location a and location c may only communicate via a forward node at b. a split of the groups connected to a and c(if a and c has b as their only intermediate node) occurs if b migrates to a. a join would be the opposite situation where a process acting as a forwarder



example 2.5 dynamic extension of neighborhoods are possible since input prefixes may bind names occurring in neighborhood relations. for example l[c(x).l d x]| m[c(n).p]| m d l can result in the network l d n| m d l| m[p]. by(r-move) used twice this can be rewritten to l d n| m d l| n[p] which shows that dynamic creation of locations is possible as well.



the safety property we are interested in is safety in presence of an attacker. this is what is called robust safety. in this respect it is important to settle an appropriate opponent model. we will use the dolev-yao model extended with concepts related to manet. choosing the right concepts is not a trivial task. however there are some basic limitations. the opponent is not allowed to use assertionssince this would let the attacker violate safety by creating unmatched end-assertion like l[new a: un; end a].



we will type a and b with types un, and let the symmetric key k be of type symkey(pair(z: un, ok({z}))) because k is a symmetric key. now(b, ok) was given type pair(z: un, ok({z}) which means that the message occurring at the first component is of type un. the second component expresses that there has been observed a begin-assertion of the form begin z for whatever z might be(could be b). ok-messages and dependent types are used to capture that effects has been observed at some points of the protocol. it is hence safe when receiving a message with an ok(at some other point of the protocol) to assume the same effects. this is what the expression release does. it allows effects generated at one place in the protocol to be unleashed into the type environment at another point. the protocol designer will have to insert release-expressions preceding end-expressions. in this way he can use the type system checking that each end-expression will be matched by one or more begin-expressions.



rules(m-pubkey),(m-seckey) describe how to derive symmetric and asymmetric keys types from the key seed type keypair(t). rule(m-symenc) describes encryption of a message m under a symmetric key y. the result of encryption is a cipher text which receives type un. this is safe because the message is only readable to those who have the symmetric key. rule(m-secenc) is the analogous rule using secret keys. rule(m-publish)(and the fact that the opponent only use public keys) makes it possible for the opponent to do public key encryption and decryption. in this way public key parts can be used by the opponent via a type environment with names of type keypair(t).



protocol, to be unleashed into the environment at this very point. the protocol designer inserts appropriate ok-expressions in messages and release-expressions in front of occurrences of end-expressions. in this way we can use the type system to check that each end-expression is matched, by one or more begin-expressions, occurring at an earlier stage at the protocol.



finally it would be interesting to compare the expressive power of dbspi with cman. the cman calculus can model all the cryptographic operations from dbspi and broadcast communication. it seems plausible that dbspi networks with a fixed neighbor topology and bidirectional neighbor relations could be simulated in cman.



