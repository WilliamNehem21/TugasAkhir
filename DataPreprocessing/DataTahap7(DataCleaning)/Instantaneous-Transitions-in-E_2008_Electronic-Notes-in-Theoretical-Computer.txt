esterel[3,4,5,6] is a concurrent programming language. its syntax is imperative and fit for the design of control-oriented reactive systems. its semantics are synchronous: active threads run in lockstep and communicate via instantly broadcast signals. like most modern imperative languages, esterel promotes structured programming. common programming practice strongly discourages the use of gotos when they are available, but esterel provides none at all.



internally, all esterel compilers use ad hoc intermediate languages(e.g., ic and grc) that expand esterel control-flow constructs into jump instructions. this suggests adding gotos to esterel should not only be feasible but also have a minor impact on code generation. while for code generation, it would be reasonable to translate formalisms such as synccharts directly to such internal formats, this would not help users reason about specifications.



previously, we extended esterel with a gotopause instruction. by design, it ensures that one instant elapses between the execution of the jump instruction and the execution of the code following the target of the jump. thanks to the definition of well-formed programs, we were able to specify non-instantaneous jumps that are consistent with the principles of deterministic synchronous concurrency. the delay implies their semantics do not involve unfolding, making compilation trivial.



of course, non-instantaneous jumps are no help for the programming of finite state machines with instantaneous transitions. in this paper, we introduce instantaneous jumps, which we obtain by combining features of loops, exceptions, and non-instantaneous jumps. first, like exceptions, instantaneous jumps have scopes and are prioritized accordingly. in a series of concurrent jumps, all but the highestpriority jump are ignored. second, as with loops, the semantics of instantaneous jumps rely on unfolding. finally, the machinery for transferring control to a distant location in the source code already exists in the formal semantics of esterel thanks to gotopause.



we introduce instantaneous jumps by extending the exception handling mechanism of esterel. raising an exception normally jumps to the end of the exception scope. our extension makes it possible to place the exception handler, i.e., the target of the jump, at any point within the scope of the exception. this employs an explicit catch instruction, which behaves like a label.



between concurrency and gotos to provide a formal framework that can be used to add a variety of jump constructs. what if a goto attempts to exit the scope of an exception? what if concurrent gotos target exclusive program states? our design minimizes the change to the language and its semantics. we only suggest a general, low-level syntax. additional syntactic sugar is probably necessary.



we describe the syntax and semantics of the esterel language and the gotopause instruction in section 2. we introduce and formalize the catch instruction in section 3. through an example, we illustrate the encoding of state machines with instantaneous transitions. we also discuss loop elimination as an instance of a source-to-source program transformation relying on the new construct. we discuss related work in section 4 and conclude in section 5.



p; q executes p instantly followed by q if/when p terminates; instantly terminates if/when q terminates. if the execution of p raises an exception then it is instantly propagated upward and q is not run. if the execution of q raises an exception then it is instantly propagated upward.



p|| q executes p in parallel with q synchronously: one reaction of p|| q consists of one reaction of p and one reaction of q until p or q terminates. if p terminates first then q continues running and p|| q instantly terminates when q does(and vice versa). if p and q raise exceptions in the same instant, the exception with higher priority is instantly propagated upward. if p only raises an exception then q is allowed to complete its current reaction before this exception is instantly propagated upward. even if incomplete, the execution of q is not resumed in the next instant(and vice versa).



loop p end repeats p forever unless p raises an exception, which is instantly propagated upward. two iterations of the loop may not complete in the same instant. e.g., loop nothing end is illegal. this constraint ensures that atomic execution steps(reactions) can be computed with statically bounded resources.



trap t in p end declares exception t in p and executes p. exceptions are lexically scoped. if p terminates or raises exception t then trap t in p end terminates instantly. if p raises a different exception it is propagated upward. in case of nested exception declarations, the outermost declaration has the highest priority.



with the constraint that there can be at most one catch t statement in the scope of each trap t in... end construct under the usual scoping rules. for instance, if there are two nested declarations for the same exception identifier t, then there can be at most one catch t statement inside the inner declaration plus at most one catch t statement between the declarations.



this design is implemented as follows. one exception is declared for each state. exception priorities are irrelevant here because we never raise two exceptions simultaneously. state entry points are specified with catch constructs. instantaneous transitions are encoded by exit constructs. non-instantaneous transitions are delayed by pause instructions. alternatively, gotopause instructions could be used for non-instantaneous transitions here.



only emits b. in general, the semantics of exit is that the body of its enclosing trap is terminated and restarted at the catch. in particular, the catch instruction may occur to the left of the corresponding exit(s). for instance,



since gotopause(s) and exit(s) implement dual approaches to concurrency, gotopause instructions do not reduce to trap-exit-catch constructs plus delays. on the one hand, trap-exit-catch constructs cannot replace gotopause instructions when several targets must be reached concurrently and the scopes of the concurrent jumps intersect. 6 on the other hand, gotopause instructions cannot encode the instantaneous transitions of synccharts specifications. as a result, we believe it makes sense to retain both constructs.



p. to express the semantics of the catch instruction, we now introduce exception states: for each statement in the scope of a trap t in... end construct and containing a catch t statement, we associate the exception state p/#t. in other words, we extend the locations of p to contain not only the locations of its pause instructions but also the locations of its catch instructions. moreover, we consider these new locations to be first pairwise incompatible and second incompatible with pause locations. now, the set l0 in p/l0 is either a potentially empty set of compatible pause labels of p or the single location#t of some catch t statement in p.



6 the scope of a non-instantaneous jump is the least program piece that contains both the source gotopause and target pause instructions of the jump. the scopes of concurrently executed jumps are typically pairwise disjoint when using gotopause to encode synccharts non-instantaneous transitions thanks to synccharts restrictions on inter-level transitions. in contrast, these scopes are typically not disjoint when using gotopause to cure schizophrenia.



the goto-like constructs we formalize here follow directly from synccharts[1,2], a statecharts-like graphical modeling language with well-defined synchronous semantics`a la esterel. but our constructs are more expressive than the collection of transitions available in synccharts. in particular, the trap-catch-exit construct makes it possible to exit and reenter several layers of nested macrostates at once. while synccharts drawings abide by rigid nesting rules and drastically restrict inter-level transitions, we allow them whenever possible.



tomata in argos and more recently in lucid synchrone. faithful to the languages they extend, these proposals restrict transitions to avoid complex causal dependencies and schizophrenia. we do not. in particular, we allow arbitrarily(finitely) many transitions to be taken in one instant.



we extend the trap-exit construct of esterel with a new catch instruction that allows exception handlers to appear anywhere in the body of the trap. one can think of the exit instruction as a goto to the location of the corresponding catch instruction. simultaneous exit s result in a single jump to the highest-priority handler. thus, our trap-exit-catch construct supplements but does not supplant the existing gotopause instruction for concurrent non-instantaneous jumps. we believe both must coexist in the language. only gotopause can decouple the structure of program states from that of the source code while the catch instruction makes it possible to specify finite state machines with instantaneous transitions. in particular, it greatly



although we did not address causality, especially constructive causality, we think there is no issue. the semantics of the new construct is obtained by combining existing pieces: loops for reincarnation, exceptions for priorities, and noninstantaneous jumps for locations. synchronous digital circuit synthesis for the extended language, thus constructive semantics, should be similarly derived. for the same reason, implementing the new construct should be straightforward.



