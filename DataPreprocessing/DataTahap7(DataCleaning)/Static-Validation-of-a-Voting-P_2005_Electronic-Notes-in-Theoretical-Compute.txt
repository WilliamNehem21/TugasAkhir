the desired security properties of electronic voting protocols include verifiability, accuracy, democracy and fairness. in this paper we use a static program analysis tool to validate these properties for one of the classical voting protocols under appropriate assumptions. the protocol is formalised in an extension of the lysa process calculus with blinding signatures. the analysis, which is fully automatic, pinpoints previously undiscovered flaws related to verifiability and accuracy and we suggest modifications of the protocol needed for validating these properties.



electronic voting promises a convenient and inexpensive alternative to the classical paper vote. due to the rapid growth in computer networks, most people nowadays have access to the internet. this makes electronic voting a viable alternative for governmental elections, as well as small scale elections and surveys. however, the use of electronic voting systems introduces new ways to systematically disrupt the voting or falsify the result. if these systems are to replace the classical way of voting, the communities that hold the elections should be convinced of their correctness.



in this paper we show that static program analysis can be used to validate several of these properties, in particular the properties of verifiability, accuracy, democracy and fairness. we illustrate this for the foo92 protocol developed for large scale elections by fujioka, okamoto and ohta. this protocol makes use of chaums blind signatures[10,11] which is a mechanism allowing a message to be signed by another party without revealing any information about the message to the other party. assuming perfect cryptography, blinding is a cryptographic primitive obeying the following two rules:



here msg is a message, b is a cryptographic key known as the blinding factor and s is a digital signature. the second rule is the most interesting one as it expresses that a signed blinded message can be unblinded without disclosing any information about the message itself; note that the signature of the message is not destroyed. the first rule simply states that blinding acts as symmetric encryption when no signature is present.



first observe that each message is extended with source and destination information along the lines of ipv4 and ipv6. upon receipt of a message the principal will always check whether the message is intended for him; occasionally he will also check that the sender is who he expected. note that these components of the message are sent in clear text and are therefore forgeable. as mentioned earlier we model bit commitment(message 1) as symmetric encryption with the commitment key v. digital signatures are modelled using asymmetric encryption with the principals private key(messages 1 and 2) and verification of a signature is then modelled using asymmetric decryption



the aim of the analysis is to give a safe over-approximation of all possible messages communicated on the network, along with the possible value bindings of the variables. furthermore the analysis will record all violations that there may be to the destination/origin annotations. in the analysis we assume perfect cryptography meaning that decryption can only be done using the correct key and similarly unblinding can only be done using the correct blinding factor.



to better understand the analysis, consider the following flawed protocol with two principals a and b. in the protocol a generates a fresh key k and sends it in clear to b along with a message m which is symmetric encrypted under the key k(at crypto-point la). upon receiving the messages xk and x, b decrypts x with the key xk(at crypto-point lb).



both of these scenarios and we have in particular analysed the protocol for an arbitrarily large number rather than than a fixed number of principals, as this is one of the strengths of the lysatool. for readability in the following lysa specifications we have only one principal for each of the roles in the protocol(voter, administrator, counter and attacker). however as mentioned above the protocol is analysed with an arbitrary number of principals acting as voters, administrators and attackers such that interference within multiple principals is also considered.



we will begin with property(2). a valid vote is a committed vote signed by the administrator, which is obtained by the voter after the unblinding at crypto-point v6. in order for a vote to count in the final tally it has to be accepted by the counter at crypto-point c1. hence we shall take lc1={v6}



this attack shows that the attacker can choose not to blind his committed vote and hence be un-anonymous. however this does not violate that only valid ballots can be accepted by the counter as the attacker still needs to get his ballot validated by the administrator. therefore we can extend the assertion lc1 to include a20.



being able to vote(1) has two issues in the foo92 protocol. firstly, if and only if you are an eligible voter you must be able to get your ballot validated. secondly, only validated ballots and all validated ballots must be accepted by the authority of the tallying, but this was already established by the validation of accuracy.



a type(1, a, i) replay attack on the validation from the administrator would mean that the same voter had two or more votes validated by the administrator, but this contradicts our assumptions. a type(1, a, i) replay attack on the counter would mean that the counter accepted the same vote twice, but again this contradicts our assumption that all committed ballots are unique and that the counter only accepts one of each. hence this type of replay attack is not possible according to our assumptions in section 2 and as lysatool does not report any violations to our assertions we can conclude that democracy is satisfied.



privacy. privacy is obtained when no one can link any ballot to the voter who cast it. validation of this property cannot be observed directly from the analysis result from lysatool as the analysis result is an over-approximation of the values that the attacker may learn, but it does hold any information about how these values are related. in foo92 the attacker learns both the vote and the identity of the voter, however only if the attacker can link them together, privacy is violated.



the very same approach for validating the somewhat different kind of security properties that apply for electronic voting protocols, namely verifiability, accuracy, democracy and fairness. we have studied one of the first voting protocols presented in the literature, the foo92 protocol. it is based on blinding signatures and part of the work presented here has been to accommodate this as a primitive in the lysa framework and the associated tool.



