this paper presents an algorithm of proof search for positive formulas in minimal predicate logic. it is based on the ljb deduction system introduced in. the algorithm returns a deduction tree, and hence a proof, when the formula is provable, and a counter-model will be constructed when the formula is unprovable. the soundness and the completeness are proved.



our algorithm firstly search the proof backward using the rules in the ljb system. if the formula is provable, the search will finally get a proof. if it is unprovable, the search will stop in a stage where we can not use any rule to search upwards, or we find a loop. in this case, we start to construct the counter-model from the leaves to the root. we assign every variable a different constant, give the atomic formulas of every leaf an original assignment, and construct model with the subnodes for every internal node.



section 2 will give some basic knowledge for the whole paper. in section 3, the algorithm of proof search and counter-model construction is introduced, and two small examples are given. in section 4, we prove the correctness of the counter model construction. finally we give a proof to the soundness and completeness in the last section.



every world w of a kripke frame< r, w,d> corresponds an extension lw of the language of predicate logic obtained by adding constants for all elements of the domain d(w). we identify such a constant with the corresponding element of d(w). hence sentences of lw are formulas containing no free occurrences of variables but possibly containing objects of d(w).



definition 2.16(singleton model) a singleton model m with a set of atomic formulas s={a1,..., an} and domain d0 is a kripke model< w, r, d,v> such that w={w} is a singleton set, r is the trivial order wrw, d(w)= d0, and support(w)=s.



to get one evidence for uprovable, so we give an assignment to every free variable. for the sake of our assignment, we define a c-substitute to substitute all the free variables in the nodes of the fail tree t with constants from root to leaves, and we assign the variables with fresh constants instead of using brackets so that we can move all the brackets away. the detail is followed.



