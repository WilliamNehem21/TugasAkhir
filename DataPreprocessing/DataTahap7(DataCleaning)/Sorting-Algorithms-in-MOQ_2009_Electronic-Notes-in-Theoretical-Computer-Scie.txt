for the scope of this paper. section 4 will be an overview of the current state of the moqa implementation and section 5 will discuss the overhead of two algorithms written in this implementation. the two algorithms are insertion-sort and quicksort.



between data in its structures instead of the algorithms specifying what the relation is. section 5 will show that the impact of this is a higher space cost and for the average-case time of quicksort, an increase in constant values. this paper will then conclude with a summary, section 6, and an outline of future work in this area, section 7.



after comparing the insertion-sort pseudo-code to the moqa-java implementation of insertion-sort, it is clear that moqa provides another level of abstraction. with moqa-java there is no explicit reference to the position of the next element to be inserted correctly amongst the elements already sorted, whereas in the pseudo-code the explicit reference to this position is the variable j, the index in the array of the next item to be inserted. in moqa-java an iterator over the orderedcollection to be sorted returns the next element for insertion. the first two elements returned by the iterator are the parameters for the first product. product removes these elements from the specified orderedcollection oc, the orderedcollection to be sorted, and connects the greater of the two above the lesser within a new orderedcollectionsubset that is added to oc before being returned. after this for each product, a nodeinfo in oc is removed from oc and connected above the specified orderedcollectionsubset to form a new orderedcollectionsubset that replaces the one previously added to oc. after being connected above the previously returned orderedcollectionsubset, the nodeinfo is pushed into its correct position in this newly created orderedcollectionsubset, which is then returned by product.



in its traversal and manipulation being more intricate than that of an array. the current implementation is one way of storing this additional complexity. so for this implementation, what is the price of this extra information in the average-case time of an algorithm? it may be more useful to examine this question with a sorting algorithm that is not so simplistic in its approach to sorting.



refactoring moqa-java. while the encapsulation of the partial order data structure within the orderedcollection class is important, the indirect manipulation of it through the current api is not flexible enough. this and other refactoring will take place, along with an extension to moqa-java that will include more specific partial orders types.



