we extend a distributed-memory explicit-state ltl model checking algorithm(owcty) with hash compaction. we provide a detailed description of the improved algorithm and a correctness argument in the theoretical part of the paper. additionally, we deliver an implementation of the algorithm as part of out parallel and distributed-memory model checker divine, and use this implementation for a practical evaluation of the approach, on which we report in the experimental part of the paper.



the effectiveness of the nested dfs algorithm is achieved due to the particular order in which the graph is explored and which guarantees that states are not visited more than twice. in fact, all the best-known algorithms rely on the same exploring principle, namely the postorder as computed by the dfs. it is a well-known fact that the postorder problem is p-complete and a scalable parallel algorithm which would be directly based on dfs postorder is unlikely to exist. several solutions to overcome the postorder problem in a parallel environment have been suggested. the parallel algorithms were developed employing additional data structures and/or different search and distribution strategies. there also are approaches based on running several instances of nested dfs with limited information sharing, as can be seen in. for a survey on parallel algorithms for accepting cycle detection they are linear in the size of the graph. number of iterations can be at most linear in the height of the graph, but is very low in practice. owcty does not depend on postorder and therefore can be parallelized reasonably well. we refer to for details and proofs of correctness.



at the end of the algorithm, we added a new phase to check validity of discovered accepting cycle. it works the same way as the counter-example generation phase of owcty described in previous section. the only difference is that it can fail, because there is no actual counter-example.



described algorithm can be extended by adding accepting self-loop detection to allow early termination, but since the reachability phase can visit states previously not discovered by the initialization phase, it is meaningful to add this heuristics to both phases. on the other hand, we decided not to use the heuristics based on the map algorithm. the reason was that it can, like owcty, produce false accepting cycles and we found no way to circumvent that.



as we prove in the next section, if our algorithm reaches a fixpoint, the resulting set s is either empty or contains an accepting cycle. in that case, the measures described in last the two bullets are not needed. however, since we can not reliably detect reaching a fixpoint, the iterative process can stop prematurely and we need the verification phase to prevent reporting a false counter-example.



all states in s lie on a cycle or are reachable from a cycle in s. correctness of owcty(see for proof) ensures that if a fixpoint is reached, this condition is always satisfied. in the case the algorithm terminates before reaching it, this may cause counter-example omission.



the verification phase can return true only if there is a path from some state a to itself and state a was in qacc. comparison is done with full representation of state a, so it is not affected by hash compaction. this, along with the fact that qacc can contain only reachable accepting states, guarantees that if true is returned, there is a reachable accepting cycle. therefore, the verification phase is correct.



in our experiments, the hash-compaction never resulted in some property being falsely identified as valid. however, this can be caused by the structure of beem models in a sense that any model with a counter-example usually contains multiple similar counter-examples. nevertheless, this property is prevalent in models of asynchronous systems in general and we do not expect this effect to be particularly amplified by the selection in beem.



