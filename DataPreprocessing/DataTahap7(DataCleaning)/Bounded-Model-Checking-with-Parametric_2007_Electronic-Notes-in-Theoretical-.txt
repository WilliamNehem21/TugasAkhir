also the kind of specification considered can have different logical domains. we deal with safety properties: the violation of a safety property is expressed by stating that the last state of the computation does not fulfill the specification. additional loop-determining techniques extend the method to verify properties for some problem classes(see e.g.[11,17]).



once the existence of a counterexample of a fixed length is expressed by some formula, we need to check that formula for satisfiability: the formula is satisfiable if and only if the specification can be violated by a computation of that length. in the discrete case the check is carried out by a sat-solver, i.e., a boolean satisfiability checker, whereas in the mixed discrete-continuous case of hybrid and timed automata the check is usually done by combining a satand an lp-solver(linear programming, see section 5.2). some popular solver are, e.g., zchaff, berkmin, minisat, hysat,mathsat, cvc lite, and ics. our



before the satisfiability check can start, the boolean formula is transformed into a conjunctive normal form(cnf). in order to keep the formula as small as possible, auxiliary boolean variables are used to build the cnf. a formula in cnf-form is a conjunction of clauses, while each clause is the disjunction of literals. we distinguish between positive and negative literals, being boolean variables or their negations.



in order to satisfy the formula, each of the clauses must be satisfied, i.e., at least one of their literals must be true. the sat-solver assigns values to the variables in an iterative manner. after each decision, i.e., free choice of an assignment, the solver propagates the assignment by searching for unit-clauses in that all literals but one are already false and thus the last unassigned literal is implied to be true. if two unit-clauses imply different values for the same variable, a conflict occurs. in this case a conflict analysis takes place which results in non-chronological backtracking and conflict learning[9,27]. intuitively, the solver applies resolution to some unit-clauses, using the implication tree, and inserts a new clause strengthening



an important point for this paper is the usage of watch-literals for the detection of unit-clauses. the basic idea is the following: if in a clause there are two unassigned(or already true) variables, then this clause cannot be a unit-clause. so it is enough to watch only two unassigned or true variables in each clause, which we call the watch-literals. if one of the watch-literals becomes false, we search for another literal in the clause, being unassigned or already true, and being different from the other watch-literal. only if we cannot find any new watch-literal, the clause is indeed a unit-clause. with this method, the number of clauses that we have to look at to determine the unit-clauses after a decision can be reduced remarkably.



mula. the representation of the auxiliary boolean variables used to build the cnf efficiently needs some more explanation: an auxiliary boolean variable gets as instance id the smallest instance id occurring in the formula it encodes. the abstraction of the same formula at different time points use the same abstract id.



the i-clauses remain untouched. note that we do not need to insert any new clauses or literals for increasing the computation length! this is done simply by adding a new instance to the already existing transition clauses in the form of a new watchpair. the number of clauses and the number of literals remain unchanged.



usually, the conflict clauses learned during the sat-check of a bmc instance get removed before checking the next bmc instance. however, they can also be partially re-used in the style of shtrichman, thereby excluding search paths from the sat-search already before the search starts: if a conflict clause is the result of a resolution applied to clauses that are present also in the next iteration, then the same resolution could be made in the new setting, too, and thus we can keep those conflict clauses. furthermore, if all clauses used for resolution to generate a conflict clause are present in the next sat iteration with an increased instance, then the same resolution could be made using the increased instances. thus each such conflict clause can be added with an increased instance in the next bmc iteration. accordingly, we distinguish between the following conflict clause types:



note that conflict clauses stemming from both iand s-clauses(is-conflict clauses) cannot be re-used. note furthermore that it is possible to learn even more than 2 instances of t-conflict clauses, if we record during the resolution not only which kind of clauses are involved(i, t, or s) but also which instances of t-clauses. however, our experiments show that learning all possible conflict clause instances leads to a large number of new clauses(or clause instances in the parametric case), each of which must be considered in the propagation of new decisions. that is the reason why learning too much rather slows down the sat-check instead of accelerating it. we follow the policy of re-using conflict clauses when possible, and inserting t-conflict clauses additionally with one increased instance. this policy turned out to be successful within our experimental bmc framework.



during the sat-checks, our solver also learns the explanations served by the lp-solver in order to refine the abstraction. those explanations are contradictions in the real-valued domain, thus we could exclude them using all possible renamings of the involved real-valued variables. in our solver those conflict clauses, stemming from the real-valued domain, are treated as t-conflict clauses.



most research on sat-solving is done in the important area of increasing the runtime efficiency. related work, like those dealing with the basic solver algorithms, bounded model checking, and learning in the context of bmc etc., is already mentioned in the introduction.



the approach of tackles memory problems during bmc by distributed computation. there, the unfolding of the clause set is partitioned and each partition is assigned to one component in the network. the focus lies on the distribution of the boolean constraint propagation to local components such that a memory reduction is achieved due to the decentralized organization. thus works in some sense orthogonal to our approach where we exploit the inherent symmetry of the bmc formula by means of parametric data structures. as to future work, we are also working on a parallelization scheme that incorporates both ideas.



