lock-free algorithms have been developed to avoid various problems associated with using locks to control access to shared data structures. instead of preventing interference between processes using mutual exclusion, lock-free algorithms must ensure correct behaviour in the presence of interference. while this avoids the problems with locks, the resulting algorithms are typically more intricate than lock-based algorithms, and allow more complex interactions between processes. the result is that even when the basic idea is easy to understand, the code implementing lock-free algorithms is typically very subtle, hard to understand, and hard to get right.



we consider a system consisting of a finite set of concurrent processes which access a shared queue with elements of some type t. each process occasionally performs an operation on the queue, and otherwise performs actions which do not involve the queue. to model such a system, we abstract away from its other behaviour and just consider its queue operations.



head, tail, value and next are assumed to be encapsulated within a module, so they can be seen by all processes performing queue operations, but from nowhere else. queue nodes(i.e. elements of value and next) can only be accessed via location values returned by newnode().



not commute with other actions that access these variables. we would not expect append to move, since it determines the new value of the abstract queue, and is thus the linearisation point for enqueue. and moving an advance left over another advance would affect whether tail is updated, and thus alter the behaviour of the execution as seen by other processes. so let us consider more carefully how append and advance actions interact.



we now consider how to implement tryappend. as indicated above, we need to test whether next(tail) is null, and if not(attempt to) update tail before we(attempt to) append the new node. but if we do advance tail, another process may perform an append before this process gets to append its node, so we need to do the test again. this can happen any number of times, so we serve that nextl= next0(tail) implies that next(tail) has not changed since it was read in the assignment to nextl. this follows from the fact that, under the assumption that heap locations are not reused, for any location l, next(l) is only assigned twice: once(to null) when it is allocated, and once(to a non-null value) when it is the last node in the list when a new node is appended. so next(tail) cannot change from one value to another and back to the previous value again.



