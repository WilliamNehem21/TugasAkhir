circus is a refinement language, in which specifications define both data and behavioural aspects of concurrent systems using a combination of z and csp. its refinement theory and calculus are distinctive, but refinements may be long and repetitive, and using this technique can be hard. some useful strategies have already been identified, described, and used. by documenting and using them as tactics, a lot can be gained since they can be repeatedly used as single transformation rules. here, we present arcangelc, a language for defining such refinement tactics; we present the language and its application in the formalisation of an existing informal strategy for verification of ada implementations of control systems.



many tactic languages can be found in the literature[5,20,1,21]. however, as far as we know, none of them present a formal semantics and support a refinement calculus for concurrent systems. furthermore, some of these languages do not present some operators like recursion and alternative. this limits the power of expression of these languages.



refinement strategy that can be used to prove that a given ada code correctly implements a particular control law diagram. in section 5, we formalise parts of the refinement strategy presented in as arcangelc tactics and use them in the verification of a simple controller. finally, in section 6, we draw our conclusions and discuss some future work.



scope. in the action a1|[ ns1| cs| ns2]| a2, the actions synchronise on the channels in the set cs and have access to the initial values of all variables in scope. however, only a1 and a2 may modify the values of the variables in ns1 and ns2, respectively. the interleaving a1||[ns1| ns2]|| a2 has a similar behaviour. however, the actions do not synchronise on any channel.



proof obligations of refinement laws are described in their provided condition. they are conditions that need to be met in order to validated the application of the corresponding refinement law. for instance, the application of law 2.1 is only valid if none of the channels used in actions a1 and a2 are in cs; the function usedc returns the set of all channels used in a given action.



the most basic tactic is a law application: law n(a) p. if the law n with arguments a is applicable to the circus program p, the application succeeds: a new program is returned, possibly generating proof obligations. however, if it is not applicable to p, the application of the tactic fails. a similar construct, tactic n(a), applies the tactic n as though it were a single law.



by way of illustration, the tactic law copy-rule-action(n) applies to an action the refinement law a.2(copy-rule-action), which takes the name n of the action as argument. as a result, it replaces all the references to n by the definition of n. in this case, no proof obligation is generated. a list of the refinement laws used in this paper can be found in appendix a.



tactics may also be combined as alternatives: t1| t2. first t1 is applied to the program. if the application of t1 succeeds, then the composite tactic succeeds; otherwise t2 is applied to the program. if the application of t2 succeeds then the composite tactic succeeds; otherwise the composite tactic fails. if one of the tactics aborts, the whole tactic aborts.



the definition of the tactic below uses alternatives. it promotes the local variables declared in the main action to state components. this is the result of an application of either law a.9(prom-var-state) or law a.10(prom-varstate-2) depending on whether the process has state or not.



two tactics are used to assert the outcome of applying a tactic. the tactic succs t fails whenever t fails, and behaves like skip whenever t succeeds. on the other hand, fails t behaves like skip if t fails, and fails if t succeeds. if the application of t runs indefinitely, then these tacticals behave like abort. a simple example is a test to check whether a program is a parallel composition. the commutativity law for parallel composition applies only(and always) to parallel compositions. so, our test may be coded as succs(law par-com()).



often, we want to apply individual tactics to parts of a circus program. in, we defined structural combinators that apply to subprograms of sequential programs. arcangelc extends the number of structural combinators; essentially, there is one combinator for each syntactic construct in circus.



control systems present a cyclic behaviour. we consider discrete-time models, in which inputs and outputs are sampled at fixed intervals. the inputs and outputs are represented by rounded boxes containing numbers. in our example, there are four inputs, e, kp, ki, and kd, and one output, y.



the inputs of diagrams and blocks are modelled as components in1?, in2?, and so on. similarly, outputs have conventional names out 1!, out 2!, and so on. components state, state0, and initialstate record the value of the state at the beginning and at the end of the cycle, and at the beginning of the first cycle. the other components, if any, represent blocks; for each block in the diagram or in the diagram of a subsystem block, there is a component.



the main action starts with the initialisation, and recursively proceeds in parallel to execute each of the flows and update the state, before synchronising on end cycle. the flows proceed independently, but a block can only start a new cycle when all the flows(and all the blocks of the diagram) have finished. in diff, there is only one flow, so the parallelism in the action is reduced to a single action execdiff out that synchronises with diff stupdt on e.



after the nb phase, three other phases, bj, pr, and sc conclude the refinement. they match the structure of the diagram to the architecture of the scheduler, and prove that the individual procedures implement the block functionality correctly. their definitions are omitted here for the sake of conciseness. further details can be found in.



the first step of this phase is a series of applications of the refinement law copy-rule-action to eliminate all references to action names in the main action. the tactic that accomplishes this step uses a couple of auxiliary tactics in its definition. the first one, try, makes a robust application of a given tactic t.



the tactic below formalises the series of applications of law copy-ruleaction. it receives a list fs of the names of the actions execf that execute the flows as arguments. it applies to explicit process definitions, and transforms the process using law copy-rule-action().



our strategy is to remove the declarations d and interleaving ain from the parallel composition of all the flows by recursively applying syncinput. only then, we remove d and ain from the outermost parallel composition. the auxiliary tactic fold recursively applies a given tactic t, from the innermost to the outermost parallel composition of an action a1(... an).



nevertheless, stateless processes do not have a parallel composition with a state update; the application of the tactic above fails. hence, we define another tactic that synchronises the input of the flows, and then, introduces a parallel composition of the flows output with skip. this unifies the structure of the actions that result from the application of this step to both stateful and stateless processes, allowing the remaining tactics to be used in both of them.



the tactic expdisjvarpar presented below applies to a parallel composition of two variables block whose sets of declared variables are disjoint. it applies law var-exp-par to expand the scope of the variable block in the left-hand action to outside the parallelism. next, it commutes the parallel composition and uses the law var-exp-par again to expand the scope of the other variable block to outside the parallel composition. finally, it commutes the parallel composition once again and joins the variable blocks.



the result is a single variable block that declares input and output variables. the tactic that corresponds to the third step of the nb phase, nbst3, first joins all the variables blocks in the left-hand action of the outermost parallel composition. finally, it invokes tactic expoutvarscope() in order to expand the scope of the block that introduces the output variables, and joins the resulting nested blocks.



the proof obligations are those originated from the application of the expansion laws. the simple application of extendvarscope represents the seventh step of the phase nb: tactic nbst7()= tactic extendvarscope() end. the result of its application to our example yields the following main action.



the tactic nb presented below can be applied to normalise the blocks: it receives the list of names of the flows as argument and applies the tactic nbst1 using this argument. then, it applies the tactic nb to the main action of the process. finally, it promotes the variables declared in the beginning of the resulting main action to state components using the tactic nbst8.



we formalise the first of four phases of a refinement strategy proposed in that is used to verify spark ada programs with respect to simulink diagrams using circus. the approach is based on calculating the circus model of the diagram using the semantics given in, calculating a circus model for the spark ada program, and proving that the former is refined by the latter. in this paper, we described this first phase as a tactic nb and used it in the development of a simple pid-controller. the tactics, however, are general enough to apply to the large examples that we find in industrial practice. the formalisation of the verification strategy as tactics of refinement gives clear route to automation.



chanically prove algebraic laws for reasoning about arcangelc tactics. some of them have already been presented in the context of arcangel, but laws about the novel structural combinators are still needed. furthermore, this mechanisation can be done in the context of the work presented in, where we present the mechanisation of circus in proofpower-z. this will allow us to use tactics in the development of circus programs within the theories for circus processes we have developed in proofpower-z.



we use fv(p) to denote the set of free variables of a predicate or expression p. moreover, we use l(n) to denote the fact that the local action definitions may include references to the action n; the same holds for the main action ma(n). later references to l(a) and ma(a) are the result of substituting the body a of n for some or all occurrences of n in l and ma.



