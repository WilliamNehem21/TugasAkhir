in most formal systems for cryptographic protocol analysis, it is typical to represent encryption operations in terms of a free algebra. encryption, for example, may be represented as e(k,x), where k is the key and x is the plaintext. decryption, however, is represented implicitly. for example, one may include a rule that says that if a principal knows the shared/symmetric key k and e(k,x), then it can also learn x.



another approach is to represent both encryption and decryption explicitly. encryption is represented, say, by e(k,x), while decryption is represented by d(k,x). the fact that decryption undoes encryption can be represented by a cancellation rule d(k,e(k,x))= x. since the decryption operator can also be used on unencrypted data, and the operations also cancel out when applied in reverse, we can also include the rule e(k,d(k,x))= x.



however, explicit representation of cancellation, although more expressive, can lead to a less efficient analysis. moreover, many practical protocols appear to be immune to cancellation based attacks. techniques such as recognizable formatting, probabilistic encryption, and so forth, appear to make unanticipated application of cancellation rules unlikely. thus, most formal systems for cryptographic protocol analysis make use of the free algebra model, although they provide little formal justification for that approach.



in millen addresses this problem by giving necessary and sufficient conditions on protocols using symmetric encryption, under which if the secrecy property holds for a protocol in the free algebra model, then it also holds in the decrypt-extended model. the condition is specified on protocols written in a model based on parametric strand spaces and pattern matching. it has two subconditions. the first, called purity says that the decryption operator should not appear in the protocol specification. the second, called ev-freeness, says that there must be no application of an encryption operator to a variable in a specification. the ev-free property essentially says that a principal should not apply an encryption operator to a term unless it has been able to verify that that term has some kind of structure, so that it is not unknowingly applying the encryption operator to the result of applying a decryption operator. since it is generally considered good practice to apply encryption only to data about which one knows something(e.g. it is data that satisfies certain formatting conventions, or data that one has created oneself), it is reasonable to expect that most cryptographic protocols will satisfy ev-freeness.





like millen, we use a model based on parametric strands as used by cervesato et al. in and song et al. in, and constraint solving as developed by millen and shmatikov in. we refer the reader to for a definition of strand spaces. in a parametric strand, message terms may contain variables. a variable will correspond to a subterm of a message term appearing in a negative node for which the receiver can verify no properties; thus any terms can be used to substitute for it. variables can also appear in positive nodes of a strand, but only if they appeared earlier in a negative node.



in millen describes two constraint systems. one is based on a free algebra, with intruder operators consisting of concatenation, deconcatenation, encryption, and reversal of encryption. the other is based on an algebra(called the decrypt-extended algebra) that includes cancellation rules describing the effects of encryption and decryption on each other, and penetrator operators consisting of concatenation, deconcatenation, encryption, reversal of encryption, and the application of the decryption operator. the main theorem of that paper is that, given certain conditions, any bundle that is solvable in the second system is solvable in the first system. this boils down to showing under what conditions a constraint m: t from the free algebra that is solvable in the cancellation algebra is also solvable in the free algebra. in these conditions are that the protocol from which the constraints are derived should not contain any explicit use of the decryption operator(purity), and that it should contain no case of an encryption operator applied to a variable(ev-freeness). note that solvability in the free algebra always gives us solvability in the decrypt-extended algebra, so that the result is an if-and-only-if. moreover, the solution for the decrypt-extended algebra induced by the one for the free algebra introduces no strands belonging to honest principals. this has a result on the type of theorems we can prove, as we will see below.



millen describes in how this result can be used for proving that the free algebra is sound with respect to the decrypt-extended algebra for secrecy properties. one can create a special strand that describes the intruder learning a specified secret, such as a key. one can use his theorem to show that purity and ev-freeness implies that the intruder strand is solvable in the cancellation algebra if and only if it is solvable in the free algebra. millen also mentions that the result could be used to prove soundness with respect to some authentication properties, although he does not go into detail about this.



briefly, the positive set of an attack specification gives the strands that should be in the bundle, and the negative set gives the strands that should not be in the bundle. thus, a specification of an attack on the secrecy of a key accepted by an initiator could be given in terms of a positive set containing two strands: an initiator strand in which the key is represented by the variable k, and a special intruder strand of the sort described by millen in which the datum learned by the intruder is also represented by k. the negative set would be empty. however, a specification of an authentication protocol would include the authenticated strand in the positive set and the authenticating strand in the negative set.



the notion of attack specification is not explicitly set out in, but our definition captures the essence of the kinds of attacks millen and shmatikov handle in their constraint system. we note, however, that millen and shmatikov restrict themselves to ground attack specifications, or at least attack specifications in which all terms in the positive set are ground. we believe that it should be straightforward to extend their notion of an attack to non-ground attack specifications. this would allow us to characterize attacks in a somewhat more general way. however, when rewrite rules are used to describe the properties of a cryptosystem, the problem becomes a little more complex, since we need to keep track of which terms in an attack specification are assumed to be irreducible, and which terms may be allowed to be reducible. though this would not necessarily be difficult to do(something like this is already done for the specification of insecure states in the nrl protocol analyzer) it could be tedious and somewhat beside the main goal of this paper. thus we treat it as outside the scope of the paper and leave it for further work.



we only consider protocols where the second and third arguments of a pk operator are not variables. this reflects the assumption that keys have a fixed purpose, it is not possible to change that purpose, and all principals will recognize what the purpose of a key is. this would hold, for example, in cases in which public and private keys are distributed beforehand by some trusted protocol. since this is an assumption under which much cryptographic protocol analysis is done, we consider it reasonable, at least as a first approximation.



any term that can be derived by d can also be derived by de. the only thing that is not obvious is for rules 4 and 5 of d that do not exist in de. but these rules are simulated by a derivation of de plus a reduction with r.



definition 2.8 we call a term t public key pure(or pk-pure) if it does not contain any term pk(k, priv, enc) or pk(k, pub, sig) where k may be any term. a set of terms is pk-pure if all its elements are pk-pure. a protocol is considered to be pk-pure if all terms appearing in the protocol are pk-pure.



there are a number of ways in which these results could be extended, besides to attack specifications with nonempty negative sets as we noted in the previous section. the most obvious would be to include other best practices(for example, the use of probabilistic encryption), or to extend our results to models in which both public and single key encryption are used, since most protocols in use today employ both. moreover, there are a number of other special properties of cryptographic algorithms for which it would be useful to be able to abstract away from in a safe way. for example, the commutative property of diffie-hellman can add greatly to the expense of the analysis of a cryptographic protocol. in a specification of diffie-hellman is used that abstracts away from the commutative property, but it has the disadvantage that the same key fragment computed by an initiator and a responder will have different representations. this should not be a problem if we can guarantee that a key fragment computed by an initiator will never be confused with one computed by a responder. we have some preliminary results in that direction, using techniques similar to those used in this paper. other algebraic properties of interest that might be amenable to techniques such as the ones used in and here include the homomorphic properties of rsa used to compute blind signatures, as well as the properties of diffie-hellman used in group diffiehellman. indeed, an early paper by even et al. shows that it is safe to leave out the homomorphism property for rsa for a very restricted class of protocols known as ping-pong protocols, so we know that for this property the result is true at least for a limited case. it would also be useful to extend these results to systems that already use cancellation rules, such as the nrl protocol analyzer. this would allow us to use cancellation rules when necessary, and the more efficient free algebras when not.



