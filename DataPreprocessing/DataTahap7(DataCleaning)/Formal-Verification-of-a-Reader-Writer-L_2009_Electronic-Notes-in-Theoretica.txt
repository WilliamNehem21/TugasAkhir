the remainder of this paper is structured as follows. in section 2 we give a short overview on related work in the area of concurrency and lock verification. in section 3 we give an introduction to the annotation language and methodology of the verifying c compiler(vcc) developed at microsoft, which we use to annotate and verify our lock implementation. in section 4 we present the reader-writer lock implementation, its invariants, and the specifications of its various functions. in section 5 we conclude.



bornat et al. proposed an ownership scheme to allow for shared readonly state as well. they present a(manual) proof of a reader writer lock implementation based on axiomatically defined semaphores in concurrent separation logic. besides the missing mechanization, their lock implementation is slightly simpler and less efficient than ours: it is based on semaphores and also may block when releasing a shared lock. similar to dynamic creation and initialization of locks is not properly modeled.



the verifying c compiler(vcc) is a verifier for concurrent c being developed at microsoft research, redmond, usa, and the european microsoft innovation center(emic), aachen, germany. vcc is used as a proof tool in the verisoft xt project to specify and verify industrial software, which includes the microsoft hypervisor hyper-v. vcc and the methodology are not purpose-built for our lock example but target a broad class of programs and algorithms.



in this section we give a short overview of the annotation constructs provided by vcc and of the underlying formal model. for the sake of our verification target we pay special attention to concurrency. we illustrate the methodology with small examples. for a more elaborate introduction into the tool and methodology we refer the reader to and, with regards to concurrency, in particular to.



objects and ownership. the current vcc version implements and enforces a spec#-style object and ownership model[2, 9], which has proven to be more elegant and efficient than the low-level memory model supported in earlier versions. in particular, the model guarantees that objects of the same type with different addresses do not overlap in the memory. in the vcc methodology objects may coincide with(pointers to) structures in the annotated c program, but vcc also allows identifying sub structures(so-called groups) and arrays as individual objects. each object o is associated with meta data. most importantly for this article, owner(o) denotes the owner of an object o, owns(o) denotes the objects it owns, closed(o) denotes its closedness, and ref cnt(o) denotes its(claim) reference count. these fields control if and how objects can be accessed, and when object invariants need to or can be assumed to hold. if the owns set of an object is declared as vcc(volatile owns) it may change even while the object is closed.



invariants. objects of aggregate type(e.g., structures) can be annotated with singleor two-state invariants. as a system invariant these invariants are meant to hold for all closed objects(and have to be checked when closing an object): single-state invariants in each state of the system and two-state invariants for each pair of successive states. two-state invariants are used to restrict possible interference of other threads(this is similar to guarantees in the sense of rely/ guarantee reasoning[10, 11]).



out parameters. there is no proper support for out(call-by-reference) parameters in c; instead, one has to pass in a pointer to the object which is to be updated. this extra indirection and the corresponding memory update when the object is updated burden the prover with additional verification conditions. to save some of this effort, vcc supports call-by-reference specification parameters. they are marked with the out keyword both in function declarations and calls.



establish a claim on it. usually, once an object(in our case the lock) is closed such write permissions cannot easily be obtained. a self claim serves as a proxy between the claimant and the object. it is a volatile claim owned by the target object and it claims the target object. thus, in an atomic operation on the target object additional claims on the self claim can be established because of the extra write permissions inside atomic operations. moreover, these new claims can also establish properties on the target object via the indirection of the self claim.



additionally, we need two-state invariants that ensure that the lock stays initialized and that the protected object and the self claim do not change, i.e., are not replaced. for these invariants we need old(initialized) instead of initialized on the left side of the implication because the two-state invariants on the right side cannot be fulfilled during the activation of initialized. 8



acquireshared() passes out a claim parameter read access claim. after returning, read access claim needs to be a fresh, valid, wrapped, and unreferenced claim, which derives from the self claim and the protected object. the latter fact allows using the returned claim in read accesses(and volatile write accesses) on the protected object. the function releaseshared() takes back such an unreferenced claim and destroys it.



