one of the great advantages of programming languages inheriting the hindleymilner type system[6,17] such as ocaml or haskell is the conciseness and expressiveness of their type language. for example, sum types in these languages are very natural to express and use when coupled with pattern-matching. these concepts can be translated to c or java, but at the price of a costly and unnatural encoding. parameterised types and mutually recursive types can also be used in ocaml or haskell to let the user define arbitrary complex data-types: part of the art of programming in such languages is to encode invariants of the problem being resolved into the types, and let the compiler statically ensure these invariants are met during the whole execution of the program.



generate efficient code with compact runtime support[9,15]. the lack of runtime type introspection does make some tasks more difficult to perform than with more dynamically-typed languages such as python or java. pretty-printing, conversions between different types, or value persistence is a largely manual process in ml-like languages, and can be tedious and error-prone. haskell solves these problems by using type-classes[4,22], which is a natural concept but difficult to implement. the type-inference algorithm becomes more complex and the runtime implementation suffers some performance penalties. in this paper, we concentrate on dynamic types, but our work is influenced by ideas coming from type-classes.



such constructions are very powerful but difficult to implement correctly when combined with a rich type environment. moreover, their implementation is quite intrusive in the compiler source code, as they modify the host type-system and language constructs. possibly as a result of this complexity, modern versions of ocaml no longer have dynamics as a language feature.



in this paper, we describe a simplified implementation of dynamics in ocaml, based on staged programming to generate and execute code fragments as part of the compilation process. we describe a 2-stage transformer that is sufficient for generating information about dynamic types, and we illustrate the use of that information to show how to build a storage layer which can easily persist ml values. a key benefit of our approach is that it does not need to modify the core ocaml compiler, and instead uses the camlp4 ast transformer to generate extra code at compilation time. our implementation:(i) parses a large subset of ocaml types to a more succinct and expressive form than the syntax tree which camlp4 provides;(ii) implements an object-relational mapping(orm) which defines an efficient conversion to and from sql; and(iii) provides a syntax extension to augment type



the type t is a standard ocaml type, with an annotation to mark it as a storage type. variables of type t can be saved and queried via the t open, t save and t get functions. the backend uses the sqlite database library, and sql is automatically generated from the applications datatypes and never used by the programmer directly.



in this case, type of x has to be defined previously for the program to compile. this definition may have either been automatically generated previously using the type-of library, or been defined previously by the user. the latter option makes the type-of library easily extensible, especially for abstract types.



the only constructs are unbounded product and sum constructors. values corresponding to named sum types are built by remembering the name of the tag and the corresponding value. functional values have no(explicit) runtime representation and are represented by the symbol t.



