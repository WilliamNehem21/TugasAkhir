checkers, and standard automata-manipulating algorithms for lexer and parser generation. in these applications, the code comes out much more concisely than implementations in more standard languages. concision is valuable not just for aesthetic reasons: minimizing the trusted computing base is important for security applications(see, e.g.,[2,3]).



the main concern of this work is to show how rogue can itself be concisely implemented in a simpler rewriting system, called microrogue. microrogue resembles a traditional implementation of term rewriting insofar as it rewrites terms using a global set of rules. the rules are only applied at the top level of terms, however. rules are ordered: if more than one applies, the greatest in the ordering is used. even less like traditional term rewriting, rules can be dynamically enabled and disabled. inspired by work of visser, we also allow new rules to be added dynamically. rules are added in scopes, which can be pushed and popped. finally, microrogue provides mechanisms for specifying evaluation order.



using the primitives of microrogue, a rogue interpreter can be implemented in less than 40(non-comment, non-blank) lines of microrogue code. this is attractive from a practical point of view, since it enables much easier development of rogue than seems possible in an industrial non-symbolic language like c++. from a more theoretical perspective, the move from rogue to microrogue is motivated by the observation that the definition of the operational semantics of the rewriting calculus contains several clauses which are essentially simple rewriting rules. this suggests that a meta-language for implementing rogue or the rewriting calculus should be based on some kind of rewriting. this seems somewhat strange, since these are already supposed to be foundational rewriting languages! microrogue resolves this tension by providing a small set of rewriting primitives which are sufficient to implement the operational semantics of rogue.



the rest of the paper is organized as follows. section 2 describes rogue. section 3 discusses the forces leading to the development of microrogue from rogue. section 4 defines microrogue, and section 5 walks through the implementation of rogue in microrogue.



the first two applications succeed because the left hand side of the rule that is being applied is identical to the term to which the rule is applied. the third application fails(with null) since f(a) is not identical to f(c). note that as stated above, f(a) is just alternative notation for f@ a. consider now the following one-step evaluations of applications of rules with variables:



in the first example,(null,3) is first reduced to 3, which does not match the pattern(x,y). so the whole application reduces to null. but in the second example, because a lazy arrow expression is applied, we do not reduce(null,3). this unevaluated expression then matches the pattern(x,y), and evaluation continues successfully.



the operational semantics of microrogue defines how a certain kind of state is updated during evaluation of a microrogue expression. this state has two parts. there is a global set of rules to use for top-level rewriting of expressions. there is also a single microrogue expression called the hold expression. the hold expression can have its subexpressions rewritten in place. this is how microrogue allows evaluation order to be controlled. both the



evaluating done causes the hold expression to be marked as normalized. this is useful, for example, to prevent congruence rules from being needlessly applied to a term which has already been fully evaluated. in order to accomodate dynamically added rules, however, expressions are marked as normalized just with respect to some core prefix of the global set of rules. dynamic rules may still be used to rewrite expressions that have been normalized with respect to the core rules. the core prefix of rules is indicated by evaluating the special expression endcore. if a term has been marked as normalized and the first rule in the ordering which applies to it is in the set of rules added before the evaluation of endcore, then the term will be rewritten just to itself. otherwise, the rewriting will proceed.



simply by giving the rule a name when it is added. then the congruence rule indicates that the hold expression, which is a possibly rewritten version of the application, should be further rewritten. this gives the reduction rule a chance to rewrite it. the reduction rule is then responsible for enabling the congruence rule again, using on. if it could happen that no reduction rule applies, we can include a catch-all rule after the reduction rules, to turn the congruence rule on again. alternatively, we can have the congruence rule turn itself back on after the recursive evaluation of the hold expression.



at this point, if no reduction rule applies, the catch-all rule of expression 1 will be used, and the expression will be marked as normalized. if, on the other hand, the application is now of the form(l-> r)@ t, the rule of expression 17 will be applied. this rule just returns(l=> r)@ t, since applications of lazy and eager arrows are evaluated the same way if the target expression has already been evaluated; and turns the congruence rule app2 back on. we do the latter to maintain the invariant that when a rule is applied which occurs later in the list of rules than one of those congruence rules(app1 and app2), all earlier congruence rules are enabled.



a partial compiler for microrogue has also been implemented(in rogue). microrogue rules are simply compiled into the c++ code that would otherwise be executed by the interpreter for them. this compilation is currently limited to the top-level of rules. rules that are dynamically added by other rules are not compiled. the resulting partially compiled version of the microrogue program is then statically linked into the microrogue interpreter. applied to the definition of rogue in microrogue, this partial compilation has cut around 20% of the running time from the interpretation of representative rogue programs.



