we propose a semi-automatic inductive process to prove termination of outermost rewriting on ground term algebras. the method is based on an abstraction mechanism, schematizing normalisation of subterms, and on narrowing, schematizing reductions on ground terms. the induction ordering is not needed a priori, but is a solution of constraints set along the proof. our method applies in particular to systems that are non-terminating for the standard strategy nor even for the lazy strategy.



a term rewriting system and the evaluation of a query consists of rewriting a ground expression. in such a context, one needs more specific termination proof tools than those previously cited, allowing one to prove termination under specific reduction strategies. there are still few results in this domain, although the need is important. to our knowledge, methods have only been given for the innermost strategy[1,14], the context-sensitive rewriting including particular kinds of local strategies, and general local strategies.



our termination proof method for outermost rewriting on ground terms is based on an explicit induction mechanism on the termination property. the main idea is to use induction on the termination property in order to prove that any element t of a given set of terms t terminates, i.e. there is no infinite derivation chain starting from t.so this approach needs a noetherian ordering on terms used in the induction principle. unlike classical induction proofs, where the ordering is given, we do not need to define it a priori.we only have to check its existence by ensuring satisfiability of ordering constraints incrementally set along the termination proof. thanks to the power of induction, the generated constraints are often simple to solve.



the method is based on an abstraction mechanism, schematizing normalization of subterms, and on narrowing, schematizing reductions on ground terms. it is semi-automatic: it can stop with success, then establishing outermost termination of a given trs; it can stop with failure or diverge, in which case nothing can be concluded about termination. constraints solving can be handled by the procedure itself, or can be left to the user or delegated to external automatic constraint solvers.



each derivation tree is simulated by a proof tree starting from g(x1,..., xm), and developed by alternatively using two main concepts, namely narrowing and abstraction. more precisely, narrowing schematizes, thanks to all possible narrowing unifiers, all outermost rewriting possibilities of the ground terms in the derivations. the abstraction process simulates the normalization of subterms in the derivations, according to the outermost strategy. this abstraction step is performed on subterms that can be assumed outermost terminating by induction hypothesis.



so the proof process amounts to develop abstract trees whose nodes are composed of a current term that may have variables, and a set of ground substitutions appropriately represented by a constraint. this constraint results from the conjunction of the successive unifiers used for narrowing, from g(x1,..., xm) to the current term. each node schematizes a possibly empty



as said before, there are three cases for the behavior of the termination proof procedure. the good case is when the strategy terminates because the rules do not apply anymore and all terminal states of all proof trees have an empty set of terms.the strategy can also stop with failure, when the rules do not apply anymore on states having non empty sets of terms. finally, it may not terminate if there is an infinite number of applications of rules on one of the reference terms.in the last two cases, we cannot conclude anything about termination.



below. this implies that every ground instance of the term s outermost terminates.this is the abstracting step, which is a final step on the branches of the proof tree it applies on.if v cannot be abstracted, we attempt again a narrowing step.



an important point to automate our proof principle is the satisfaction of the ordering constraints. on many examples, this is immediate: since the ordering constraints only express the subterm property, they are trivially satisfied by any simplification ordering, so we do not need any ordering constraint solver.elsewhere, we can use an ordering constraint solver as cime.



m. clavel, s. eker, p. lincoln, and j. meseguer. principles of maude. in j. meseguer, editor, proceedings of the 1st international workshop on rewriting logic and its applications, volume 5 of electronic notes in theoretical computer science, asilomar, pacific grove, ca, usa, september 1996. north holland.



