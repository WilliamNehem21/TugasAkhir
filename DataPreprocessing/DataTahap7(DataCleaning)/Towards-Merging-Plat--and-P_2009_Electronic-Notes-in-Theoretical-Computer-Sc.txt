proof general[2,3] is widely used by theorem proving experts for several interactive proof systems. in some cases, there is no alternative interface; in others, the alternatives are little different. yet the limitations of proof general are readily apparent and reveal its evolution from simple command line systems. for one thing, the input format is lines of ascii-text, with the minor refinement of supporting unicode or tex-like markup. the presentation format during interaction is the same. for another thing, the proof-checking process has an overly simple linear progression with a single point-of-focus; this means that the user must explicitly undo and redo to manage changes in different positions in the document, which is quite tedious.



meanwhile, theorem provers have increased in power, and the ability for workstations to handle multi-threaded applications with ease suggests that it is high time to liberate the single-threaded viewpoint of a user interface synchronised in lock-step to an underlying proof-checking process. some provers now provide multiple foci of attention, or several prover instances might be run in concert. text editors, too, have evolved beyond linear ascii-based layout. the scientific wysiwyg text editor texmacs, for example, allows editing mands(proof(induct x rule: n.induct)). the new text is sent to the broker and then on to isabelle for parsing. once parsed the broker breaks the text into separately processable spans(here, only one), which is sent back to the display. now eva asks for the proof step to be processed, which sends the actual proof text to isabelle, which answers with two open subgoals.



<opengoal> and<closegoal>, but the contents of the<block> element of type proofbody that belongs to an<assertion> element. the<endproof> element replaces<closegoal> and can be annotated with status information about the proof proven, assert, or unproven. another extension is the corresponding attributes xml:id for the<assertion>, and xref for the<block> elements, which allow assertions to refer to proofs which are elsewhere in the document, and not directly following the assertion. these attributes are optional, and may only appear in the display protocol(i.e., between displays and the broker); we assume that provers always expect proof scripts to be in linear order, and it is the responsibility of the broker to rearrange them if necessary before sending them to be checked.



in the pgipd protocol, changes in the document are communicated using specialised commands<createcmd> and<editcmd> from the display to the broker, and<newcmd>,<delcmd> and<replacecmd> from the broker to the display(so the protocol is asymmetric). we can rephrase this in terms of xupdate; the unique identifier given by the broker to each command contained in the cmdid attribute allows to easily identify an object by the xpath expression*[cmd=c]. the key advantages of xupdate are that it is standard, symmetric, and allows several changes to be bundled up in one<xupdate:modifications> packet that is processed atomically, adding a transaction capability to the display protocol.



in the pgipp protocol, changes in the document communicated via xupdate must be mapped to changes in the prover state. in the previous version of pgip, this was done by the broker, because the single-focus state model does not easily accommodate arbitrary changes to the document. however, the multiple-focus extensions as described in sect. 3.2 amount to supporting



clients affect changes to the document by the xupdate messages above, and trigger broker actions by changing the attributes. for example, to start a prover, the client will change the status of the prover resource from not running to running. here, bundling up changes into one xupdate modification becomes useful, as it allows displays to send several changes to the document resource in one transaction.



traditionally, menus are fully specified and include all submenus and the leafs are all actions with all possible actual arguments. executing an action triggers modifications of the document and the menu is closed. for theorem provers, computing all submenus and action instances can be expensive and unduly delay the appearance of the menu. for example, a menu entry for applying a lemma would contain as a submenu all available lemmas, and for each lemma, all possibilities to apply it in the current proof situation. once the user makes a choice, the other possibilities are discarded. so on-demand computation of submenus is desirable.



(using the any element from above). a menu entry is rendered by its name and an action is rendered by its name and its arguments. arguments are rendered with the given custom object, e.g., an openmath formula or some standard texmacs markup. the alt attribute provides a fallback ascii representation in case the custom object content cannot be displayed.



when the user chooses an action, it is executed on the specified arguments. the result of the action may be an xupdate patch to the document. this is sent to the broker and then on to the display, which incorporates the patch and closes the menu. alternatively it is a patch for the menu only: in this case the action is replaced in the menu by the new submenu. if a submenu is empty, i.e., there are no possibilities to refine the abstract action, then the submenu consists solely of an error that describes the cause, which should be displayed inside the menu.



menu action execution: the final top level action execution triggers applying the specific instance of the lemma in the prover, modifying the formal proof. the modification is propagated via the broker to the display, either as an xupdate patch for the document if the display is able to deal itself with these; otherwise the broker computes the new document version and forwards only the new document. additionally, a patch description is sent for closing the menu.



if a conflict that cannot be merged occurs, the broker sends the merged document including conflict descriptions back to the display(using an extension to xupdate to markup the conflicts, as in[11, sect. 7.1.3]). the display(or the user) then needs to resolve the conflicts, and send in new changes.



xupdate flattening going from omdoc to ascii, the structured xml representation must be transformed into a linearised text representation. a mapping must be setup between xml ranges and text ranges, i.e., the start xpath maps to the start text position(relative to the last range) and the end xpath maps to the end text position(relative to the last range). start and end xpaths have the same parent xpath by definition. to flatten patches, the affected xml ranges must be recomputed and the mapping adapted; additions in the patch are flattened similarly.



on the other side, we can now provide translators for further displays with advanced layout possibilities, such as word 2007. the translator component must abstract the display document format to simplify it for the broker: e.g. in word 2007, the document body is extracted and information about fonts, colours and spacing is stripped. on the way back, annotations are extracted from the patches coming from the broker, which guide heuristics for layout of new or modified text.



proof. 4 the infrastructure of pgip 2 and a(partial) mapping from coq into geoproof would allow for simultaneously working in geoproof and coqide. away from proof assistant systems, multiple views are familiar in ides for programming languages such as eclipse and netbeans: there the same file may be presented in different ways in different windows(e.g., code and model), and either updated dynamically in step, or at clearly defined points in the interaction(e.g., window activation).



