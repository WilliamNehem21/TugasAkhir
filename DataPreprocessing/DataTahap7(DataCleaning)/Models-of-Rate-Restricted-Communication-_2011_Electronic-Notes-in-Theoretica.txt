we demonstrate by examples how rate restrictions in creol models can be used to capture properties of radio-based message broadcast as well as of point-to-point communication channels. channel-based communication concerns itself with communication between two objects, modeling e.g. a low-bandwidth connection between two hardware systems. arrival-based restrictions describe a single component with its limits of accepting communication from anyone, capturing interference and resending in the context of radio communication. we further show how we can simulate the system behavior, ranging over rate restrictions, using maude as an interpreter for creol models.



the paper is structured as follows: section 2 introduces timed creol, a timed extension of the creol modeling language and illustrates the language by an example of client server communication. section 3 proposes a modeling pattern for resource-constrained behavior and introduces a rate restricted point-to-point communication channel for the client server example. section 4 develops a creol model of a bandwidth restricted wireless sensor network. section 5 discusses related work and section 6 concludes the paper.



creol is an abstract behavioral modeling language for distributed active objects, based on asynchronous method calls and processor release points. in creol, objects conceptually have dedicated processors and live in a distributed environment with asynchronous and unordered communication between objects. communication is between named objects by means of asynchronous method calls; these may be seen as triggers of concurrent activity, resulting in new activities(so-called processes) in the called object. this section briefly introduces creol(for further details see, e.g.,[14, 21]).



creol objects are dynamically created instances of classes, their declared attributes are initialized to some arbitrary type-correct values. an optional init method may be used to redefine the attributes. active behavior, triggered by an optional run method, is interleaved with passive behavior, triggered by method calls. thus, an object has a set of processes to be executed, which stem from method activations. among these, at most one process is active and the others are suspended on a process queue. process scheduling is by default non-deterministic, but controlled by processor release points in a cooperative way. creol is strongly typed: for well-typed programs, invoked methods are supported by the called object(when not null), such that formal and actual parameters match. this paper assumes that programs are well-typed.



while, and return constructs are standard. the statement suspend unconditionally releases the processor by suspending the active process. in contrast, the guard g controls processor release in the statement await g, and consists of boolean conditions b and return tests x?(see below). if g evaluates to false, the current process is suspended and the execution thread becomes idle. in that case, any enabled process from the pool of suspended processes may be scheduled. explicit signaling is therefore redundant.



expressions rhs include declared variables x, object identifiers o, boolean expressions b, and object creation new c(e) and null. the specially reserved read-only variable this refers to the identifier of the object and now refers to the current clock value(explained below). note that pure expressions are denoted by e and that remote access to attributes is not allowed.(the full language includes a functional expression language with standard operators for data types such as strings, integers, lists, sets, maps, and tuples. these are omitted in the core syntax, and explained when used in the examples.) pattern which extends a given model with a class that is parametric in the available resources per time interval. this class contains an active behavior which resets the consumed resources when time has advanced, captured by the run method. in the examples of this paper, we apply this technique in order to impose rate restrictions on communication between objects(see sec. 2.1 and sec. 4).



sometimes be desirable to fine-tune the bandwidth consumption for the different methods; e.g., a higher bandwidth may be needed in order to transmit data than for completing an authentication handshake. this can be done easily by using the desired values in the proxy methods.



when a sensor receives a message from another sensor, a call to the receive method is made by the network. if the sensor has not seen this message before, it is added to the received set, and queued for re-sending. this unconditional resending implements a simple flooding routing algorithm: when a sensor senses data, it broadcasts it to all other nodes within range; when a sensor receives a message that it has not seen before, it rebroadcasts this message to all its neighbors. more involved routing algorithms exist where sensors selectively rebroadcast messages depending on whether they are on the path to the sink, but this simple algorithm suffices to illustrate our approach.



the bandwidth is the number of time slots in a channel. in general, nodes are scalable in sending the messages, but they are limited by the bandwidth of the sinks or gateways. in addition, the number of sent messages may become limited by the transformation strategy regarding to the power efficiency. since transmission is the biggest source of energy drain in wsns, having control over bandwidth consumption is important for the efficient power consumption and longevity of the nodes.



we further simulated a series of randomly-generated network topologies with constant four sensor nodes and six connections. each network contained four sensor nodes, where each node was initialized to create and send three data packets. as expected, the time for all messages to reach the sink goes up as available bandwidth(as modeled by the network arrival rate restriction) goes down. also, the performance characteristics of the random networks can be observed to lie between those of the two chosen extreme topologies, potentially allowing reasoning about timing behaviors of arbitrary sensor networks of given connectedness based on the behavior of the boundary cases.



techniques and methodologies for predictions or analysis of non-functional properties are based on either measurement or modelling. measurement-based approaches apply to existing implementations, using dedicated profiling or tracing tools such as jmeter or loadrunner. model-based approaches allow abstraction from specific system intricacies, but need parameters provided by domain experts. a survey of model-based performance analysis techniques is given in. experimentation and simulations is the major source for obtaining an initial understanding of non-functional behavior in distributed networks. in the domain of wireless sensor networks, experiments are performed using simulators such as ns-2 and omnet+. however, different simulators may give vastly different results, even for simple protocols, because the simulators make different assumptions about medium access control and physical layers. in contrast, we have shown in this paper that abstract simulations give initial insights into the behavior of distributed algorithms without having to consider particular assumptions about the lower-level layers. furthermore, formal models allow a more systematic, in-depth exploration of the execution space not only in terms of model-checking and theorem proving techniques, but also in terms of flexibility with respect to the simulation scenarios.



