the application of formal methods to the design of computing systems often results in the generation of verification conditions that need to be proved in order to guarantee the correctness of the result. such verification conditions express properties of models or relations between models and may be expressed in a wide range of logics: from propositional to high order logic, but also process algebra and temporal logic. hence the level of automation for verification in a specific formalism is tightly dependent on the availability of tools to support reasoning in such logics.



the next section introduces notations and the basics of smt-solvers. in section 3 we present an abstract framework for describing smt-solvers. it only serves to discuss the soundness and completeness of the combination framework we describe in this paper. it is not as detailed as the dpll(t) framework since it is not meant to be a precise description of solvers. by contrast to the dpll(t) framework and for simplicity, our schema highlights the distinction between the boolean reasoning and the theory reasoning. it is not difficult to understand dpll(t) as being a refinement of our schema.



since the bottleneck of the cooperation between proof assistants and smtsolvers is not the efficiency of the smt-solvers, our focus has not been much directed towards the efficiency of our implementation. in particular, we do not implement theory propagation(see for instance). however, we observed that for the specific qf ufidl benchmarks reported to work particularly well for, our implementation works as fast as in z3.



future works include applying this technique to other decidable fragments(for instance full linear arithmetic on integer and reals). also, our implementation includes a full-featured first-order theorem prover that handles user theories. we will then investigate the benefits of our framework in presence of such user defined theories.



