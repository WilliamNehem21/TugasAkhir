context-aware computing studies the development of systems which exploit context information(e.g., user location, network resources, time, etc.), which is specially relevant in mobile systems and pervasive computing. when these systems are built assembling pre-existing software components(cots), the composition process must be able to solve potential interoperability problems, adapting component interfaces. in addition, the composition must be adapted to the execution conditions of such systems, which are likely to change at run-time, affecting component behaviour. this work presents an approach to the flexible composition of possibly mismatching behavioural interfaces in systems where context information can vary at run-time. our approach enables composition at run-time, enabling dynamic changes in composition according to context changes. furthermore, our approach simplifies the specification of composition/adaptation by keeping separation of concerns, and is able to handle context-triggered adaptation policies.



software adaptation is a field characterised by the modification of component interactions through the use of special components called adaptors, which are capable of enabling components with mismatching interfaces to interoperate. these are automatically built from an abstract specification of how mismatch can be solved(i.e. adaptation mapping or contract), based on the description of component interfaces. particularly, recent research efforts[1,8,21,19] concentrate on behavioural interoperability, extending interfaces with a description of the protocol they follow, and ensuring correctness and termination of component interactions.



traditionally, the context of reuse of a component used to be more or less static(e.g., spreadsheets, banking systems, etc.), but the advent of mobile and pervasive computing has given rise to a whole new breed of systems where execution conditions are likely to change at run-time(e.g., time, user location, resource availability, etc.). although context-aware computing has broadly studied the development of systems exploiting context information, it does not deal with the specificities of component-based systems. component-based, context-aware systems must be able to reflect environmental changes affecting system behaviour, altering the composition at run-time.



this work advocates for the flexible(i.e., modifiable at run-time) interaction between an arbitrary number of components depending on the current state of the execution of the system. this approach serves a double purpose: on one hand, it adapts the composition to the changing environmental conditions or context of the system. on the other hand, it works out the potential incompatibilities among components. this work develops and formalises the seminal ideas sketched in, extending previous work which focuses on run-time composition and adaptation techniques. run-time composition is an essential feature of our proposal since it avoids the costly generation of the full adaptor, and its recomputation when the system changes(e.g., addition of a new service).



moreover, we reduce the complexity of mapping specification by enabling separating concerns, breaking down the specification of adaptation into multiple context facets which express the different concerns which may affect system behaviour. furthermore, our proposal is able to deal with adaptation policies which may depend on context changes(i.e., context-triggered actions),



the rest of this paper is structured as follows: section 2 presents a wireless medical information system used to illustrate the different issues described in the remaining sections. section 3 describes our run-time composition/adaptation proposal. section 4 describes some related work. finally, section 5 draws up conclusions and further work.



we describe a mapping through an incremental specification, focusing on the different facets or concerns involved in the composition. each concern is represented as a context facet, where the changes between the different states of that particular context facet are triggered either by component messages or signals designated by vector expressions. specifically, when an expression matches on the vector which is currently being applied in the composition, the transition is triggered. the order of events and signals does not need to coincide both in the expression and the vector for them to match.



it is worth noticing that there may be cases in which we may need to assign a specific precedence order to just one vector. this could be expressed by adding the precedence order in the vector declaration(e.g., vconn=



when the state of this facet is local, treatment prescription and logging are performed on the local dbms(vectors vptr and vltr, respectively). likewise, queries for patient data are performed on the rfid reader(vectors vqry, vebl and vresp). notice that vebl will help to solve the 1-to-many interaction problem described in our case study, by making the rfid reader evolve independently whenever it is ready to receive enable?.



once we have described the inputs to our approach, we will detail the process followed for composition and adaptation. first, we illustrate the selection of active vectors for a particular state of the global context(i.e., the combination of the active states of all context facets). second, we sketch the approach used to ensure correct termination of the system. finally, we describe the composition algorithm, illustrating it with an execution trace coming from our case study.



considering the nature of our search problem, the use of an informed search algorithm looks like a good strategy in order to find potential solutions efficiently. specifically, we make use of the a* algorithm, a particular best-first search strategy which determines the mimimum cost path from a given node n to a goal state by expanding the most promising candidate paths first. however, we have to provide guidance information for this search. this is achieved by defining a heuristic estimation function h(n) of the cost of arriving from the current state of the components to a global termination state in the composition. in order to determine the heuristic estimation to be used:



the heuristic estimate h(n) is admissible in our case(i.e., it never overestimates the actual cost from node n to a goal). this is because the distance function d that we have defined always returns the minimum of the distances from a state in the lts to a final state, resulting in a lower bound of the estimation. this admissibility guarantees a* to return an optimal solution, if one exists.



run-time composition should avoid to engage into execution branches that may lead to deadlock situations. at this stage the state of the components is checked, and if all of them are in a final state, the composition finishes. otherwise, the composition engine attempts to select an applicable vector v which may lead to a global correct termination state for the system. if such vector does not exist, the composition process ends as well.



vector v is processed. first, the engine receives the emissions specified in v. notice that the engine operates reversing the direction of communication with respect to the events specified in vectors. next, the engine sends the receptions specified in v. after processing both emissions and receptions the state of the components is updated accordingly. finally, environmental signals are received by the engine as well, and the state of context facets is updated by matching vector expressions on context facet ltss with the vector being currently applied(v).



in context-aware computing applications can discover and take advantage of contextual information(such as user location, time, resource availability, etc.). although this topic has been broadly studied and the usefulness of this technology has been demonstrated, this paradigm does not explicitly deal with the composition and adaptation of software entities within the system.



our main perspective is to implement this proposal as a composition engine, using aspect-oriented programming(aop), where unlike in traditional platforms and languages, a particular system can be modified without altering its(base) code. this is achieved by separately specifying modifications as aspects, and a description of their relation with the current system. then the aop environment weaves or composes aspects and base code into a coherent program. this weaving process can be performed at different stages of the development, ranging from compilation-time to run-time(dynamic weaving). in this dynamic approach, the virtual machine or interpreter running the code is aware of aspects and controls the weaving process. hence, aspects can be applied and removed at run-time in a transparent way. dynamic aop will enable us to shape up the composition engine as aspects able to:(i) intercept communication(i.e., service invocations) between components;(ii) apply the composition process introduced in this proposal wrt. the adaptation mapping in order to make the right message substitutions;(iii) forward the substituted messages to their recipients transparently.



