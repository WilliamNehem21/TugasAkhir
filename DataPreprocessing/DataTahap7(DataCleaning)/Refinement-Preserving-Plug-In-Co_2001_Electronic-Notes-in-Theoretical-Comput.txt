a formal method is a mathematically-based theory which is used to describe and reason about the behaviour of a computer system. application of a formal method encompasses specification of the system in a chosen formal notation, analysis and verification of key properties and stepwise refinement to a correct implementation. it is generally recognised that even partial use of these techniques during development can significantly increase the quality of software and hardware systems, with respect to correctness and maintainability. for example, the application of a general-purpose specification notation such as z has been found to lead to the earlier discovery of design flaws. formal and deductive reasoning. we show by examples that certain desirable relational properties of a system with arbitrary components are not necessarily preserved by component-wise refinements, and we describe a solution for avoiding this refinement paradox. we conclude by placing our work in the context of other research linking the two notations, notably, that by morgan, butler and treharne and schneider[25,26].



in contrast to safety properties, liveness properties are not preserved by the operator, as illustrated by example 5.1 below. our focus is on plug-in relationships among components, whereby we mean that component q plugs in to component p iff q does not cause p to deadlock when they are run in parallel. we formalise this notion(a desirable behaviour for a plug-in component to offer its controller), and show by example that unfortunately, more deterministic refinements of processes satisfying such a relationship do not themselves have to satisfy the relationship.



csp models a system as a process which interacts with its environment by means of atomic events. communication is synchronous: an event takes place precisely when both process and environment agree on its occurrence. this rather than assignments to shared variables is the fundamental means of interaction between agents. csp is a process algebra.



q. we regard q as a plug-in to p, since their joint behaviour expressed by p q behaves desirably. clearly not every process which returns keys should be regarded as a plug-in to p. for example, consider r:



if q is a plug-in to p on channels t and r, it would be tempting to generalize theorem 6.6 that q is a plug-in to p on t r. however, this is not in general true, as illustrated by the following example.



another reason for refining the csp specification is that we might want to analyse behaviour of a chosen protocol with respect to security, e.g., robustness against deliberate or inadvertent attacks by intruders. demonstrating security or(lack of it) might involve modelling attackers as processes with certain constrained behaviour, such as not having the ability to decipher encrypted messages, whilst having the ability to intercept and replay communications containing cipher text[13,14]. for example, lowe and roscoe discover potential security flaws with the tmn key exchange protocol, revealed by counter examples provided by fdr showing that attackers could perform operations specifically disallowed by the csp specification. again, adding detail involves introducing internal actions, and checking that the new system is a valid refinement. a disadvantage of action systems for this sort of analysis is that automated deductive reasoning tools cannot generally provide counter examples for flawed conjectures.



ler. csp-like descriptions are translated into machine readable b specifications, which can then be verified by a deductive tool. event-based csp descriptions and state-based action system-like ones are combined into one b machine, with appropriate proof obligations to ensure liveness properties of the system.



in contrast, our desire is to modularise both specification and analysis from the beginning in order to reduce effort and space explosion for those systems where it is possible. treharne and schneider[25,26] provide techniques for using csp and the b-method. they define csp control executives for statechanging operations based on the b-method. they identify wp-formulated proof obligations on the csp specifications to ensure that appropriate preconditions and guards(which they distinguish) are not violated. they do not generate an encompassing b machine, and do not allow shared state. thus independent analysis of the separate specifications is possible.



our driving motivation is to contain inherent problems of scale in applying formal techniques to large applications. the goal of a great deal of current research is to combine different formal approaches in order to treat different aspects of a given system. there is a danger that combining techniques for a particular system creates prohibitive complexity. our aim is to divide and conquer potential complexity by structuring separation-of-concerns specifications early in the development process, so that independent analysis can be effectively performed. finally we note that our techniques are formulated using action systems and csp, but we feel that concepts which we have identified are generally applicable to other formal and semi-formal specification techniques.



a p is the most basic program constructor. it waits to perform the event a and after this has occurred it behaves as process p. the same notation is used for outputs( c!v p) and inputs(c?x p(x)) of values on named channels.



