bpel is the language used to express web services(ws) orchestrations which has been accepted as the standard since april 2007. it expresses the execution logic of a business process based on interactions between the process and its partners. a bpel process defines how multiple service interactions between partners can be coordinated internally in order to achieve a business goal(orchestration).



the rest of this paper is organized as follows. the next section briefly describes the bpel language; and section 3 presents the bp-language, our formalism for the modelling of bpel processes. in section 4, we present the mapping from the bpcalculus to bpel. in section 5, after giving an outline of the verification process, we illustrate the approach with a representative example. we conclude the paper in section 6.



to accomplish the description of the bp-calculus, we need a mechanism that abstracts the bpel scopes. scopes act as containers for bpel processes and handlers. a scope contains a primary structured activity which defines its normal behavior; it might contain variable definitions and handlers(fault, compensation, event and termination handlers). in case of normal execution, a scope is activated at the same time as its activities are and terminates when all its activities have been accomplished.



normally we define a reduction semantics by using a structural relation and a reduction relation. the structural relation is meant to express intrinsic meanings of the operators. the reduction relation defines the way in which processes evolve dynamically by means of operational semantics.



a fault handler is enabled using the enfh channel. the fault handler uses a guarded sum to execute an activity pi, associated with the triggered fault(i). after executing the associated activity, it then signals its termination to the activating process on the channel y1 and to the scope on channel yfh. if necessary, the fault handler is disabled using disfh channel. internal faults are signaled using the



a compensation handler associated with a scope z is first installed at the beginning of the scope through an input on channel instch( yinv signals this installation); it then executes its compensation activity p2. if the compensation handler is invoked but not installed, it signals the termination of the scope activity through channel throw and performs children compensation(cc). the compensation handler is invoked using the<compensate> activity.



the means of specifying a process in either of both languages and to process formal verification in bp-calculus. the result of the verification can be iteratively refined. the final result is then an automatically generated bpel code that is formally verified.



we assume that all bound variables occurring in the bp-calculus expression being translatied have been renamed with names distinct from each other and distinct from any free names in the expression. this obviates the need to actually invoke alpha-conversion in the translation. when translating communication primitives we assume that channels in the bp-calculus represent service operations and that partners(i.e portypes) are transmitted as variables.



the proposed verification approach is the following. first, processes are specified in the bp-calculus. this specification is translated into a syntax compatible with the hal tool. this translation is not isomorphic because annotations are lost, but their absence does not interfere in the verification process.



the fault handler is composed of three activities, af={fsnv, fqna, ftimeout}(each one corresponding to a catch). the invoked porttype and operation are the same for the three faults. the only difference is the parameter for the name of the fault. the fault handler can be mapped as follows:



a link represents a connection between two activities; one defined as the source and one defined as the target. both the source and the target must define explicitly their role in the syntax. a link allows for the specification of some order in the execution of the parallel activities expressing the interdependencies among activities, thus allowing synchronization between some activities. some restrictions hold for links(for example a link cannot cross a scope).



