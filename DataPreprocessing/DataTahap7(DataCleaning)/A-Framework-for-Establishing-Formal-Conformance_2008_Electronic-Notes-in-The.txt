for a particular aspect; for instance, whereas structural models depict main software elements and their inter-relationships, behavioral models specify how these elements interact to accomplish the system function. structural models depicting domain concepts, relations and invariants in an object-oriented fashion are called object models. languages for expressing object models include alloy or class diagrams from the unified modeling language(uml) annotated with invariants in the object constraint language(ocl).



in this paper, we describe a formal framework for defining conformance relationships between object models and object-oriented programs, allowing reasoning with more flexible rules of conformance between model and program constructs. it supports independence of model and program semantics, by relying upon intermediate representations of interpretations and heaps(respectively, model and program states). these representations are related by a coupling formula involving model and program elements, defining how a model element is implemented in the program.



this syntactic mapping, as provided by the user, offers a definition for semantic conformance between models and programs, independently from object modeling or programming language. our definitions were encoded in pvs(showed in section 3), whose interactive type checking helped us in finding specification errors. reasoning on conformance may be useful for several applications, ranging from syntactic(code generation from models and reverse engineering) to semantic correspondence(conformance checking).



software models provide visualization and specification for tackling software complexity. mainly, models offer decomposition, which provides distinct perspectives for a particular aspect; for instance, whereas structural models depict main software elements and their inter-relationships, behavioral models specify how these elements interact to accomplish the system function. in terms of object models, languages include alloy or class diagrams from the uml annotated with ocl. in a number of software development contexts, it is useful that abstractions in models and source code evolve consistently, for documentation or even development purposes. for the applicability of this practice, a conformance relationship between models and programs must be defined.



the traditional conformance relationship favors the manipulation of those constructs by case tools, especially for code generation and reverse engineering. for instance, a skeleton declaration for the customer can be easily generated from the object model, including the accs attribute; on the other hand, the object model sets and relations can also be generated from the source code with minimal user intervention. similarly, semantic conformance with direct correspondence is usually easier to check. an informal analysis of the main program shows that the invariants hold during its execution; in every heap, no two customers have the same account and every checking account carries exactly one card. the implicit constraint of



conformance relationship 3. due to abstraction, another conformance relationship allows implementations to be even more distinct from the object model. here the subset relationship from the object model is implemented as an attribute in account, defining the type of each account.



program structures must be applied in this verification, in order to correctly relate values from both worlds and check the conformance. as shown in this section, several conformance relationships can be useful in practice; offering a precise definition of those relations may be an aid for tool supporting several software engineering tasks. this is the aim of our solution.



the prototype verification system(pvs) provides mechanized support for formal specification and verification. the pvs system contains a specification language, based on simply typed higher-order logic, and a prover. each specification consists of a collection of theories. each theory may introduce types, variables, constants, and may introduce axioms, definitions and theorems associated with the theory. specifications are strongly typed, meaning that every expression has an associated type.



the balance(acc) expression denotes the balance of the acc account. we can use these fields as predicates. for instance, balance(acc)(100) is a predicate stating that the balance of the acc account is 100. the with keyword denotes the override operator, which replaces the mapping for acc by a new tuple, if acc is originally in the function domain. in the withdraw function, the expression containing the with operator denotes an account with the same owner of acc, but with a balance subtracted of amount. similarly, we can declare a function representing the credit



in this section we introduce the formal framework definitions for establishing conformance relationships in pvs. a notion of conformance is given in terms of syntactic correspondence between constructs from models and programs(which we call coupling). this correspondence is a hot spot of the framework, as instantiated for particular conformance relationships. with a given coupling, a notion of semantic conformance can be verified.



a formal definition of models and programs is given, using uninterpreted types, in the following pvs fragment 4. these types can be seen as interfaces of our framework, regarding, in any language, object models declaring sets and relations, and programs declaring classes and attributes, given by the indicated functions. we treat relations and attributes as a name, not qualified with the name of the declaring set or class(considering models and programs that declare relations and attributes, respectively, using unique names).



in our core language for coupling formulae, we consider twelve kinds of expressions, which are specified next. we have expressions for set, class, relations, attributes and variable names. moreover, there are five kinds of binary expressions representing the union, intersection, difference, join and product expressions. fi-



conformance relationship 1 for the banking application in section 2 uses class and attribute-based couplings; account, chacc, customer and creditcard sets are implemented as classes, besides accs and card as attributes. the next pvs fragment formalizes the predicates for both kinds of couplings, for each set and relation. they are valid whether a class implements each set and an attribute implements each relation(for simplicity, we consider the same names).



the following fragment defines this coupling for all relations from a model m, in which targettype denotes the function yielding its target type, which must be subtype of collection. in the coupling relation, the formula for the accs is given by accsm=accsp.elems, where elems denotes the attribute from the collection to its elements.



our conformance framework can be general enough to allow defining different kinds of couplings for elements in the same model. for instance, some relations may be defined as class-based, while others use a collection-based coupling. in this case, only part of the coupling relation is generated by following these kinds of couplings; other couplings can be used for particular names in the same model.



although some set comprehension constructs do not appear in our definition for the language presented in section 4.2, we could easily derive it as shorthands for the core constructs, for making this logic practical. for instance, the existential quantifier can be built from the universal quantifier.



objects may have overlapping accounts. this is guaranteed before and after calls to the indicated method; however, this is not true for resulting heaps when executing the loops from the for command. for each new account reference copied to another customer, this account is owned by two customers, breaking the invariant.



nevertheless, in practice, this program is suitably in semantic conformance, since it is natural that object methods perform encapsulated state changes which are not perceived by the users. for that, we need to restrict on which portions of the program code the clients may rely on model invariants, for example before entry and after execution of the transferaccounttocustomer method. heaps of interest are then the program heaps from those portions.



in particular, we consider object models in alloy and programs in a java-like formal language, rool(refinement object-oriented language). both languages present relatively complete sets of primitive semantics-preserving transformations and refinement calculus, used as a basis for model-driven refactoring. refactoring strategies can only be correctly applied to source code with a condition: original object model and program must be in conformance. therefore, a specific conformance relationship which is appropriate for the consistent refactoring must be defined; we then use our formal framework for defining this conformance.



developers intended to reflect model refactoring to source code might also expect some syntactic conformance, otherwise model-driven refactoring would not be applicable. in model-driven refactoring, we used a specific conformance relationship, as shown in the next pvs fragment. the syntactic mapping for sets defines one direct class for each set(for simplicity, with the same name). also, all supersignatures for the set(given by super(s)) are included in the set of superclasses of the corresponding class(super(c)), indicating that more superclasses can be declared in the program, but the hierarchy is maintained.



regarding syntactic conformance, harrison et al. show a method for maintaining consistency between object models(uml class diagrams) and java programs, by advanced code generation from models at a higher level of abstraction, which allows more independence when making program changes not affecting models. a more specific case of syntactic conformance is addressed by another work, aims at bridging the gap between object modeling and programming languages, in particular regarding binary associations, aggregations and compositions in uml class diagrams. they describe algorithms that automatically detect these relationships in code, introducing a more flexible conformance relationship for model relations. these conformance relationships can be represented by our coupling formula, allowing reasoning on semantic conformance, which is not present in those approaches.



the framework is appropriate to accommodate freedom of implementation for abstract concepts, a useful task in design and implementation practice. applications of this framework include conformance checking, code generation and roundtrip engineering, and model-driven development, more specifically refactoring. in the latter, a formal conformance relationship is critical to the soundness of transformations that affect model elements and its correspondent implementations.



