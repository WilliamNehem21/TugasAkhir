the paper is organized as follows. section 2 briefly explains an overview of the mac framework. section 3 introduces an extension medl-re. section 4 discusses the construction of the dependency graph. section 5 presents and proves our augmented dfa algorithm. section 6 presents related work. lastly, section 7 concludes the paper.



linear temporal logic(ltl), allows us to express a large subset of safety properties of systems, including real-time properties. the monitoring script, expressed in the primitive event definition language(pedl), is used to define what information is sent from a filter to the mac system and how it is transformed into events and conditions used in medl. the steering script written in the steering action definition language(sadl) is used to specify actions to be invoked when violations occur. see[9,10] for pedl and sadl details.



events occur instantaneously during the system execution, whereas conditions represent information that hold for a duration of time. for example, an event denoting the call to method init occurs at the instant the control is passed to the method, while a condition(angle< 30) holds as long as the value of the variable angle does not exceed 30. the syntax of events and conditions is shown below.



the boolean connectives used in events and conditions are defined in the usual way. events start(c) and end(c) are triggered when c becomes true and false, respectively. an event e when c is triggered when e is triggered and c is true. a condition defined(c) is true when c is defined. a condition[e1, e2) is true between the occurrence of events e1 and e2 where e1 is included but e2 is not. for formal semantics of events and conditions, see[9,11].



medl includes events and conditions imported from pedl, definitions of composite events and conditions, safety properties, auxiliary variables, and auxiliary functions. a safety property can be expressed as a condition or as an event called an alarm. a safety property condition must always be true during the execution whereas an alarm must never be raised. auxiliary variables can be used to define events and conditions. auxiliary variables allow us, for example, to count the number of occurrences of an event. auxiliary functions are time(e) and value(e), which return the time stamp and the value of an event e, respectively.



the acount variable keeps track of how many times an event a occurs. whenever a occurs, we increment it and whenever b occurs, we reset it. the alarm a3 alerts users when acount becomes 3. the event wxyz is triggered only when c holds true and when y or z occurs between w and x or when z occurs between x and y. the wxyzcount variable stores the number of times the event wxyz has occured. the property wxyz10 alerts users when wxyzcount is greater than 10.



an important property of monitoring is its ability to monitor target systems as efficiently and quickly as possible using minimal system resources. hence, using a deterministic finite automaton(dfa) to monitor a re is preferred over a non-deterministic finite automaton(nfa). several existing algorithms have been proposed to efficiently construct and minimize a dfa from a given re. we have chosen the algorithm by aho, sethi and ullman because it generates a dfa directly without generating an nfa. the empirical result by watson also suggests that this dfa construction is efficient.



simulation of a dfa involves the following steps. identify a re that has the current event in its relevant set. then compare the current event with all the possible transitions from the current state of the dfa and take the appropriate one. if the current event initiates the simulation of a dfa, then it would trigger a startre event. if the automaton moves to a final state, a success event is triggered under certain conditions as specified in section 5. similarly, the event causing the automaton to get stuck triggers a fail event. however, the problem in dfa simulation arises when there are simultaneous events generated by one primitive event or condition. since there is no inherent



the mac language consists of high-level or composite events and conditions, and low-level or primitive events and conditions described in section 2.1 and 2.2. when primitive events or conditions are detected, the filter sends them to the event recognizer in the order as they occur. these primitive events and conditions can trigger composite events or change the value of conditions. while the primitive events and conditions are ordered, we cannot order the composite events triggered by one primitive event or conditions because all of the composite events occur at the same time.



since res can be defined on composite events that can occur individually and simultaneously, we need a way to recognize the events that can occur simultaneously. if two events can occur simultaneously, then their order is insignificant and their concatenation can be permuted without changing the meaning. to handle simultaneous events inexpensively, we propose the following steps. during the static phase, we determine if events used in the res could occur simultaneously. if such events exist, we augment the original dfa with alternative transitions. at runtime, we try to take a step using the original transitions. if it is not possible, we try to take a step using the alternative transitions only if there exists a set of events from among the relevant set of this re that have occured simultaneously.



there are two special cases. the first case is when an event is composed using an and connective(e1&& e1). the event with the&& connective is triggered if and only if both of its two arguments e1 and e2 occur simultaneously. therefore, if there exists an&& connective along the path, the two arguments of the&& connective must depend on one common vertex. otherwise, the event with the&& connective will never be triggered and therefore, can be



based on the information of simultaneous events provided in section 4, we incorporate additional information into the dfa statically. we claim that this additional information can assist the simultaneous simulation of multiple paths in the dfa efficiently. the following algorithm is proposed to incorporate this additional information into the dfa.



let the dfa be a minimal dfa generated using the algorithm for dfa generation and minimization as described in section 4. we call this dfa as dfaorg and the augmented dfa generated by the algorithm as dfaaug. we construct dfaaug under the following premises.



the set of simultaneous events generated by the event recognizer does not constitute multiple occurrences of the same event. this assumption is valid because the mac system does not record the number of occurrences of an event at any given time instant. it only records the presence or absence of the event occurrence.



linearization linearization is a total order of a set of events. if this set consists of events that have occured simultaneously then the ordering of such simultaneous events in the set is one linearization of this set. a different ordering of these simultaneous events then constitutes a different linearization of this set.



let a be the event currently being considered. let q1 and q2 be the two states being considered. let es1 and es2 be the two event strings associated with q1 and q2, respectively. assume the current state is q1, and therefore, es1 is one linearization of input seen so far. the algorithm has the following alternatives.



an alternative transition from q1 to a state q3 on a such that a transition from q2 to q3 on a exists, i.e., t(q2, a)= q3. thus, this alternative transition takes a step from one linearization to the other.(hashed(concat(es1, a))= hashed(concat(es2, a))).



reach this state. this claim is valid because while determining event strings, we use only the original transitions present in dfaorg. the transition taken from the penultimate state to reach the accepting state is also an original transition. therefore, the event string concatenated by the last transition is accepted by dfaorg, contradicting the assumption above.



