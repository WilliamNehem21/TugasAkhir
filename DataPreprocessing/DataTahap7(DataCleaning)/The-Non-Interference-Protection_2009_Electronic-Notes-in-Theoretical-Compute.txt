many information-flow type systems have been developed that allow to control the non-interference of information between the levels of classification in the bell-lapadula model. we present here a translation of typing information collected for bytecode programs to a bytecode program logic. this translation uses the syntax of a bytecode specification language bml. a translation of this kind allows including the check of the non-interference property in a single, unified verification framework based on a program logic and thus can be exploited within a foundational proof-carrying code infrastructure. it also provides a flexible basis for various declassification strategies that may be useful in a particular code body.



the paper is structured as follows. in sect. 2, we fix the notation and present the basic notions which are used in the paper. sect. 3 provides an exposition of the translation of the type based system to the logic based one. this translation is supplemented by a theorem that the resulting specifications guarantee the non4 the translation from this paper does not reduce the trusted logical base to the one of the foundational pcc. to achieve that one has to link the resulting formulae with the non-interference property expressed in the foundational logic e.g. the property expressed in for while programs.



interference property in sect. 4. the formal development is concluded by a proof that the non-interference property holds even when the bytecode program is extended with other specifications. this is presented in sect. 4.1. at last we present the final remarks in sect. 5 where we sketch the way the declassification can be introduced.



in this section we fix the notation used throughout the paper. we, generally, follow the papers[4,12]. we also present informal description of some notions which are not directly used in the translation, but are essential for understanding the principles of the construction.



security policy we use here the security policy framework from. it is based on assumption that the attacker can observe the input/output of methods only. this, however, is extended to the values of fields and heaps as otherwise it is difficult to guarantee statically the non-interference property. we also assume that the attacker is unable to observe the termination of the programs.



the vector kr describes the security levels for the method results(both normal and exceptional ones); it is a list of the form{n: kn, e1: ke1,..., en: ken}, where kn is the security level of the return value and ei is the class of an exception that might be thrown in the method and kei is the upper bound on the security level of the exception. we use the notation kr[n] and kr[ei] for kn and kei.



the translation of the information flow system into the bytecode program logic is done with the use of the bml syntax. the bml formulae can be translated to the actual bytecode program logic with the use of the translation in. here is a brief summary of the relevant bml syntax.



we use the modifier ghost to indicate that a particular variable is not a program variable, but a specification variable. other java type modifiers such as public, private, final, static have the same meaning as in the case of java declarations. we use the bml syntax to denote the logical connectives i.e.&& means the logical conjunction,|| the logical alternative, and! the logical negation. the logical implication is denoted as==>. we also use the bml syntax to access and initialise elements of arrays and to denote types of variables. we also use here the general quantifier. the syntax of the quantifier expression is as follows: where the variable declaration has the same form as a variable declaration in java and introduces the quantified variables. the bound on the quantification is a formula the goal of which is to restrict potentially infinite domain of the quantification to be finite and it can be any boolean expression. at last, the actual formula is the formula we are interested in. a bound on the quantification b and an actual formula a are understood as the implication b==> a.



qm is a finite partial map which for a program label i in m gives an assertion qi(s0, s). if the point i in m is annotated with qm then qi(s0, s) is supposed to hold in every state s at i during any execution of m with the initial state s0 satisfying rm(s0)(i.e. the precondition of the method). intuitively, qi(s0, s) provides the content of the assert statement right before the instruction with the label i.



the following theorem relates typability and the fact that the program verifies correctly in the bytecode logic. it says that whenever a program with annotations proposed in sect. 3 successfully verifies it also successfully typechecks. this property and the main theorem of(see sect.6) imply the non-interference.



theorem 4.3 below states that we can safely extend the specifications so that the noninterference property is preserved. more precisely, it allows to mix the specifications that result from our translation with specifications that come from other sources(e.g. are written by hand).



design choices the primary goal of the design choices we took here was to find a way to express a system which ensures the non-interference property in terms of the bml formulae. the main challenge here was to connect the flow of the data with the first order formulae available in the language. we decided to simulate in ghost variables the operation of the type checking.



this obstacle could be overcome with the help of the observation that the satisfiability of the formulae does not depend on the values of the source code variables and the control flow of the programme. this lets us to store the conjunction of all the formulae in the method precondition rm. that, however, would make the implementation of the declassification more involved. in this framework, the declassification must be implemented by a modification of the formulae themselves instead of the modification of the data they operate on.



