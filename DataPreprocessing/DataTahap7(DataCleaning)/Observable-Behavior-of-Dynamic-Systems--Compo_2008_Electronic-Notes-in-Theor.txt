in order to better capture the setting of interacting distributed components we work with the concurrency and communication model of the creol language, based on concurrent objects, asynchronous method calls, and so-called processor release points. there is no access to the internal state variables of other objects. a concurrent object has its own execution thread. processor release points influence the implicit internal control flow in objects. this reduces the time spent waiting for replies to method calls in a distributed environment and allows objects to dynamically change between active and reactive behavior(client and server).



paper overview. section 2 introduces and informally explains the language. section 3 describes class invariants for observable behavior, section 4 the language semantics, and section 5 the derived proof rules. section 6 gives an example, section 7 discusses related work, and section 8 concludes the paper.



instances of classes. the state of an object is constructed from the parameters and attributes of its class. there is read-only access to the class parameters, including the implicit parameter this, used for self reference. the state of an object is encapsulated



access to attributes is not allowed. for simplicity, all methods are assumed to be available to the environment, except the special methods init and run. the init method is used for object initialization and is invoked immediately after the object is created. after initialization, the run method, if provided, is invoked. the remaining methods reflect passive, or reactive, object behavior, whereas run initiates active



in the asynchronous setting, objects may send messages at any time. type checking ensures that only available methods are invoked for objects of given types. the run-time system ensures that generated objects will have unique identifiers. assuming type correctness, well-formed histories satisfy a well-formedness predicate, as a completion message may only occur after the corresponding invocation message in the history:



this definition ensures the local uniqueness of created identifiers, while null may create objects. whenever an object identifier o' occurs in an output message in h/o, o' must either be a child of o, or occur in a previous input message to o. this leads to a notion of closure for histories.



in interactive and nonterminating systems, it is difficult to specify and reason compositionally about object behavior in terms of preand postconditions. instead, preand postconditions to method declarations are used to establish a so-called class invariant. the class invariant must hold after initialization in all the instances of the class, be maintained by all methods, and hold at all processor release points. the class invariant serves as a contract between the different processes of the object instance: a method implements its part of the contract by ensuring that the invariant holds upon termination and when the method is suspended, assuming that the invariant holds initially and after suspensions. to facilitate compositional and component-based reasoning about programs, the class invariant is used to establish a relationship between the internal state and the observable behavior of class instances. the internal state reflects the values of class attributes, whereas the observable behavior is expressed as a set of potential communication histories.



in the asynchronous setting objects may independently decide to send messages and these may arrive in a different order than sent, due to overtaking. the invariant should therefore restrict messages seen by an object, but allow the existence of additional unprocessed input. therefore, we find the asynchronous input property natural for asynchronous systems: note that invariants on h/outthis are guaranteed to have this property. since completion messages give explicit information about the corresponding invocation messages, such invariants are often sufficient.



list of fresh pseudo-variables v' captures the execution of the remote method. the completion message is appended to the history and the reply values assigned to v. the statement this.m(e; v) synchronously invokes the local method m. we may assume that the invariant is preserved by m. by adaptation, the execution of m is captured by a nondeterministic assignment to w and h: if the invariant holds before



the completion message of the call. for local calls, the encoding does not rely on properties about the invoked method such as the absence of processor release points or its call structure.(for local calls, use of pre/postconditions strengthens the proof system. for further details, see the extended version of this paper.)



b holds the statement is reduced to skip, otherwise the process is suspended. when the process continues after a suspension, b must hold for the current values of w. the encoding of await x.m(e; v) resembles that of synchronous invocations and consists of several parts. the initiation message is appended to the history before the processor is released. after the suspension, the actual parameter list is assigned the values found in the completion message. since there is no transfer of control between caller and callee, the history need not end with the completion message corresponding to the method activation, but this message must be somewhere on the history extension. we end this section with two lemmas.



the buffer.(a different example using asynchronous calls is given in.) notice that the next object can easily be identified from the history of a buffer object by a function next(x, h). focusing on this property, we express the external invariant of



future work. creol supports multiple inheritance. we intend to extend the approach of this paper to combine processor release points, multiple inheritance, and history-based compositionality. the combination of nondeterministic assignment and inherited class invariants challenges the transformational approach. for larger programs, tool supported proof systems are needed. for this purpose, we plan to adapt the key tool to proof systems for active objects communicating by means of asynchronous method calls.



