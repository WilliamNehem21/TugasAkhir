for several years now, nasa has been flying robotic deep space missions that rely on software to perform mission functions. deep space missions involve a tight integration of physical and software systems. these systems are complex and expensive to design, build, and deploy. the mission data system(mds) framework has been developed to address this problem. mds provides an architecture, tools, and libraries of reusable components to be used in the design and implementation of space mission systems, principally for robotic deep





state-based approach to system design and(2) a goal-oriented approach to operation. the system state is the basis on which decisions about mission operations are based. system state includes device operating and failure modes, device health, resource levels, and information about dynamics such as vehicle position and attitude, angles, and wheel rotation. mission goals describe the desired outcome of a mission operation so that the overall mission will be successfully completed. mathematically, a goal is a prioritized constraint on the value of a state variable during a time interval.



state values are computed by estimators, communicated in messages, tested for constraint satisfaction by controllers, and used by goal-elaborators. the module state-value declares a sort for state values, a subsort for unknown state values, and a constant uk to represent the fact that the value of a state variable may be unknown. here and elsewhere the sort and class hierarchy of the maude model mirrors the class hierarchy of the mds framework, to facilitate relating the model to the implementation.



be achieved or not. in case of failure, it will deliver a reason. the module constraint declares a sort constraint, for constraints, together with a constant nocstr of sort constraint that stands for the constraint that is always satisfied, analogous to the boolean value true. the module reason declares a sort reason, for reasons. the following module specifies the messages for the interface between state variables and the environment as follows.



note that the state variable rules use a class identifier variable svcid of sort svcid rather than a specific constant of this sort. this is so that the rule will apply to specific state variables with class identifier whose sort is a subsort of svcid. this is a standard technique for modeling subclassing in maude.



the current state value satisfies the constraint using an operation satisfy. if the current state value already satisfies the constraint, it replies to the state variable with a successful endcstr message. if the current state does not satisfy the constraint, the controller determines the course of action by calling its coa function, issues the first command and stores the rest of the command list.



if the controller is in the process of satisfying a constraint and it receives a message with a new value, newval(v), it first determines if the constraint is satisfied by the new value. if so, an endcstr message is sent to the state variable indicating success. if the constraint is not satisfied and the controller has no more commands to issue, an endcstr message is sent to the state-variable with the reason coanosuccess indicating that the course of action determined by the controller was not successful. in both of the above cases the controller sets its waitafter attribute to nomsg to allow new constraints to be processed. otherwise the controller issues the next command in its stored command list and remains in the processing constraint state.



the rover can receive a drive command from its actuator. if the rover is not heading in either north, east, south, or west direction, it will not be able to move along the grid. it will also be unable to move if there is an obstacle occupying the target grid position. in this case, the rover will simply report to the sensor its current position and heading. the rover can also receive a turn command from its actuator. in this case it executes the command and then reports its current position and heading to its sensor.



in the rover adaptation, the controller-actuator, device-actuator, devicesensor, and estimator-sensor interfaces must be further refined to specify the data to be communicated between components. two commands drive and turn are added to the controller-actuator interface. these are also added to the actuator-device interface as message bodies, using overloading. a constructor



as discussed above, an important part of designing an mds remote agent system is identifying the state variables and determining how they are to be measured and controlled. goals of the rover system include moving to a certain location on the grid and facing in a given direction. thus, we define a class for position and heading state variables in the module posandhead-state-variable.



first the x-position of the final location is achieved. this is done by determining in which direction(east or west) along the x-axis the rover has to drive and whether the rover needs to turn to reach its initial position. then the number of steps is computed that the rover needs to proceed along the x-axis. an appropriate list of turn and drive commands is generated.



the specifications for the position and heading actuator, sensor and estimator classes are very simple. thus, the actuator takes a command from the controller and transforms it into the correct format for execution in the device. because we have chosen the same names for commands and actuator-rover messages this is just a sort conversion. the operations converting sensor values into measurements(executecmd) and measurements into values(verifystate) are also defined to be sort conversions, simply returning their arguments viewed as elements of a different sort.



to partially automate checking outcomes we defined parameterized success and failure patterns and used the model-checker to look for the expected pattern. this could also be done using search. the advantage to modelchecking in the current setting is that when the question is formulated so that a positive result from the model-checker is a counter-example, a rule trace can be extracted as a simple trace of the execution.



we have presented a simplified version of the mds architecture to test our understanding of the structure and constraints. in order to make further elaboration and adaptation easier, some effort was made to take a systematic specification approach to the control structures for controller, actuator, sensor, estimator, and state variable interactions with each other and with the framework scheduler. we also studied how mission specific devices, their models, controllers and estimators can be modeled, and specified a simple version of the scrover. simple execution unearthed several small problems in the control flow. in multiple goal scenarios, search of the state space yielded unexpected outcomes. examination of the search graph provided the needed information to determine the problems. in the process of developing these first models, we have also discovered gaps in the informal documentation(filled by discussion with the experts).



