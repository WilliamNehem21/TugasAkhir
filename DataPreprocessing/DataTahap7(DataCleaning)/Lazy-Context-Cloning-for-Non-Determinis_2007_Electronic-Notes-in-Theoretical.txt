non-determinism is one of the most appealing features of functional logic programing. a program is non-deterministic when its execution may evaluate some expression that has multiple results. to better understand this concept, consider a program to find a donor for a blood transfusion to a patient. the following declarations, in curry, define the blood types and which type can be given to which other type:



this paper addresses both theoretical and practical aspects of the implementation of non-determinism. section 2 highlights some deficiencies of typical implementations of non-determinism and sketches our proposed solution. section 3 discusses the background of our work. section 4 defines our strategy and related concepts. section 5 proves the soundness and completeness of our strategy. section 6 very briefly discusses problems and some solutions of the extension of the strategy to narrowing. section 7 briefly addresses related work. section 8 offers our conclusion.



functional logic programs are traditionally seen as term rewriting systems(trss)[9,11,12,21] with the constructor discipline. the execution of a program is the repeated application of narrowing steps to a term until either a constructor term is reached, in which case the computation succeeds, or an unnarrowable term with some occurrence of a defined operation is reached, in which case the computation fails. examples of the latter are an attempt to divide by zero or to return the first element of an empty list.



of t(according to s). for the trss that we consider, the computation space of a term is a tree-like structure. a child is obtained through the application of a step to its parent. a tree branch occurs when the strategy computes two or more distinct steps on the same term. when a parent has several children, the order in which the strategy is applied to these children and their descendants is important, although most strategies for functional logic languages are unconcerned with this order. the order of application affects only how the computation space of a term is traversed or explored, not the content of the space itself.



with copying, the computation of t[u] consists in the simultaneous, e.g., by interleaving steps, independent evaluations of t[x] and t[y]. if either evaluation produces a constructor term, this term is a result of the computation, and the interpreter may give the user the option of continuing the evaluation of the other term. if the evaluation of one term fails to produce a constructor term, the evaluation of the other term continues unaffected.



both backtracking and copying have been used in the implementation of fl languages. for example, pakcs and t oy are based on backtracking, whereas the flvm and the interpreter of tolmach et al. are based on copying. unfortunately, both backtracking and copying as described above have non-negligible drawbacks. consider the following program, where div denotes the usual integer division operator and n is some positive integer.



we describe the evaluation of t= f(loop? 1) with backtracking. if the first choice for the non-deterministic expression is loop, no value of t is ever computed although t has a value, since the evaluation of f loop does not terminate. this is a wellknown problem of backtracking referred to as loss of completeness. since narrowing computations are complete with an appropriate strategy, in this example the culprit is backtracking.



the theory of graph rewriting is significantly more complicated than that of term rewriting. furthermore, there are multiple presentations with non-trivial variations in the literature. in this paper, we follow the systemization of echahed and janodet because the class that they consider is a good fit for our programs, as we will discuss later. the space allotted to this paper allows us only to recall the key concepts. the complete details can be found in.



since there are no non-deterministic steps, a redex has only one replacement. in particular, at the machine or implementation level, a redex can always be replaced in place, i.e., in the execution of a step, the context of the redex becomes the context



in this section we prove the correctness of our strategy. the main purpose of a strategy is to compute a subset of the steps that could be executed on a term so that all and only the values of the term are reached. a good strategy does not compute steps that do not help to reach any value of a term, although this should be achieved without look-ahead.



compute a subset of all the steps of a term are obviously sound. since we allow bubbling steps, the soundness of the strategy is not immediate. computing all the values of a term is referred to as completeness. a good strategy should attempt to eliminate as many steps as possible. proving that a strategy is complete is generally difficult, since if some steps are eliminated, some values might be lost.



proof. let t' be the term obtained from t by replacing the subgraph at c with its left(resp. right) successor, and let u' be term obtained from u by replacing the subgraph at d with its left(resp. right) successor. by the definition of bubbling, t'= u'. thus, if the same side is chosen at both c in t and at d in u, by lemma 5.5 the claim follows.



the strategy of section 4 computes rewriting steps. many of the results and ideas that we have presented can be used for extending the strategy to narrowing. the correctness of bubbling is independent of whether a bubbling step is performed in a rewriting or narrowing computation.



