in this paper, we show how our program transformation algorithm called distillation can not only be used for the optimisation of programs, but can also be used to facilitate program verification. using the distillation algorithm, programs are transformed into a specialised form in which functions are tail recursive, and very few intermediate structures are created. we then show how properties of this specialised form of program can be easily verified by the application of inductive proof rules. we therefore argue that the distillation algorithm is an ideal candidate for inclusion within compilers as it facilitates the two goals of program optimization and verification.



the programs resulting from distillation are in a specialised form in which functions are tail recursive and very few intermediate structures are created. we show that this specialised form is very amenable to the automatic verification of properties of programs through the application of inductive proof rules. we therefore argue that the distillation algorithm is an ideal candidate for inclusion within a compiler as it enables both powerful optimization and program verification.



each constructor has a fixed arity; for example nil has arity 0 and cons has arity 2. we allow the usual notation[] for nil, x: xs for cons x xs and[x1,..., xn] for cons x1...(cons xn nil). we also allow the notation 0 for zero,1 for succ zero and n+1 for succ n.



in this section, we give an overview of the distillation algorithm; full details of the algorithm can be found in. the distillation algorithm is a significant advance over the supercompilation algorithm. using the supercompilation algorithm, it is only possible to obtain a linear improvement in the run-time performance of programs; with distillation it is possible to produce a superlinear improvement.



if the transformation rules presented so far were left unsupervised, non-termination could arise, even in the presence of folding. this non-termination will always involve encountering expressions which are embeddings of previously encountered expressions. we therefore allow transformation to continue until an embedding of a previously encountered term is encountered within the current one, at which point generalization is performed to ensure termination of the transformation process.



the first of these rewrite rules is for the case where both expressions have the same functor at the outermost level. in this case, this is made the outermost functor of the resulting generalized expression, and this functor is removed from each of the two expressions. the second rule identifies common sub-expressions within an expression. the results of applying this most specific generalization to items 1-4 in example 3.11 are as follows:



when we encounter an expression e which is an embedding of a previously encountered expression e', we calculate the most specific generalization of e and e'. if the redex of this most specific generalization is a variable, then the partial process subtree rooted at e is replaced by the result of transforming the generalized form of e. otherwise, the partial process subtree rooted at e' is replaced by the result of transforming the generalized form of e'. the generalized forms of these expressions are constructed using the abstract operation.



these rules can be explained as follows. in rule(1), if we encounter a variable, the value false is returned, as this is one possible value of this variable(it must be a boolean). in rule(2), if we encounter a constructor, then we return the value of this constructor(again, this must be a boolean). in rule(3), if we encounter a let expression, then we need to apply the proof rules to all the sub-terms within this expression to show that they are all true. in rule(4), if we encounter a case expression, we need to apply the proof rules to all the branches of the case to show that they are all true. in rule(5), if we encounter a letrec expression, we add the



it is possible that overgeneralization can occur, thus turning a theorem into a non-theorem(but not the converse). this means that our theorem prover may determine that a correct program is not actually correct. however, if our theorem prover determines that a program is correct, then this is definitely the case.



in this paper, we have presented a novel transformation algorithm called distillation, which can produce a superlinear speedup in programs. this represents a major advance over existing unfold/fold transformation techniques, which can only produce a linear improvement. we have shown that, not only is distillation useful for performing program optimization, it also facilitates the relatively straightforward verification of the resulting programs. we therefore argue that the distillation algorithm is an ideal candidate for inclusion within a compiler as it enables both powerful optimization and program verification.



