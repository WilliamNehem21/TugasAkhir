in current practice, even using refactoring tools, programmers must rely on successive compilation and a good test suite to have some guarantee that it does not introduce type errors and preserves the observable behavior, respectively. a test suite is able only to uncover errors, not to prove their absence. moreover, usually, modifying the structure of a program, such as extracting a new class, implies updating the test suite in order to add new test cases for the new classes. therefore, relying on a test suite is not a good way to guarantee behavior preservation. in case of structural model refactorings, most proposed transformations rely on informal



in a previous work, we propose model transformations for alloy, showing a number of applications. in another work, we give a dynamics semantics for alloy and show how to prove that model transformations for alloy preserve dynamic semantics. in this work, we focus on the static semantics and show how it can be used in proposing and proving(in pvs) that model transformations for alloy do not introduce type errors.



plex type system[7,31], these examples may also introduce a type error. another work does not consider invariants. therefore, the examples presented in this section suggest the importance of formally proving not only that a structural model transformation preserves dynamic semantics, but also that they do not introduce any type error. this is also useful for model transformations in general, not only refactorings.



the prototype verification system(pvs) provides mechanized support for formal specification and verification. the pvs system contains a specification language, based on simply typed higher-order logic, and a prover. each specification consists of a collection of theories. each theory may introduce types, variables, constants, and may introduce axioms, definitions and theorems associated with the theory. specifications are strongly typed, meaning that every expression has an associated type.



the balance(acc) expression denotes the balance of the acc account. we can use these fields as predicates. for instance, balance(acc)(100) is a predicate stating that the balance of the acc account is 100. the with keyword denotes the override operator, which replaces the mapping for acc by a new tuple, if acc is originally in the function domain. in the withdraw function, the expression containing the with operator denotes an account with the same owner of acc, but with a balance



in this section, we give an overview of alloy in section 4.1 and propose a core language for it in section 4.2. a core language for alloy contains a small set of its constructs. it contains all constructs that cannot be expressed in term of others, thus presenting the same expressivity of alloy. since the core language is as expressive as any alloy model, the results for the core language can be leveraged for alloy.



an alloy model or specification consists of a set of modules. each module may contain some signature declarations and paragraphs(constraints and analysis). signatures are used for defining new types, and constraint paragraphs, such as facts and functions, used to record constraints and expressions. each signature comprises a set of objects(elements), which associate with other objects by relations declared in the signatures. a signature paragraph introduces a type and a collection of relations, called fields, along with the types of the fields and other constraints on the values they include.



instance, account and bank are disjoint. moreover, accounts may be checking or savings. in alloy, one signature can extend another, establishing that the extended signature is a subset of the parent signature. for instance, the values given to chacc form a subset of the values given to account.



a fact is a kind of constraint paragraph. they are used to record formulae that always hold, such as invariants about the elements. the following example introduces a fact named bankconstraints, establishing general properties about the previously introduced signatures. it contains one formula stating that each account is related to exactly one customer by the owner relation. the all keyword represents the universal quantifier. the one keyword, when applied to an expression, denotes that the expression has exactly one element.



regarding signatures, we do not consider syntactic sugar constructs, such as abstract. an abstract signature partitions its subsignatures, so all elements of the abstract signature belong to exactly one of its direct subsignatures. this constraint can be represented by a formula. moreover, cardinality signature qualifiers, such as one, lone and some, may also be represented in a formula. each signature has a name, may extend a signature, in addition to possibly declaring a set of relations. next, we declare part of the grammar considered in the core language.



alloy has some other constructs for performing analysis, such as assertions and commands(run and check). due to its exclusive use for performing analysis, they do not affect the meaning of a model. therefore, we do not include in the core language. so, in our core language, an alloy model may only contain signatures and facts.



the uninterpreted type type represents a type in alloy. in fact, we cannot use this name since it is a pvs keyword. hereafter, when we use type in capital letters, we refer to the pvs keyword. otherwise, we refer to a type in alloy. in alloy, we have three kinds of names: signature, relation and variable names. the uninterpreted types representing them are declared next.



in our core language, we consider ten kinds of expressions, which are specified next. we have expressions for signatures, relations and variable names. moreover, there are five kinds of binary expressions representing the union, intersection, difference, join and product expressions. finally, we have the transpose and closure unary expressions. in order to formalize them, we create a pvs abstract datatype.



a pvs datatype is specified by providing a set of constructors, recognizers and accessors. the previous datatype has some constructors, such as signame and union, which allow the expressions to be constructed. for instance, the expression signame(n) is an element of this datatype if n is a signature name. the union? and closure? recognizers are predicates over the expression datatype that are true when their argument is constructed using the corresponding constructor. for instance, closure?(e) is true when e is a closure expression. suppose that we have the union(e1,e2) union expression, where e1 and e2 are expressions. we can use the l and r accessors to access the left and right expressions. for example, the l(union(e1,e2)) expression yields the e1 expression. when a datatype is type checked, a new theory is created that provides the axioms and induction principles needed to ensure that the datatype is the initial algebra defined by the constructors.



for example, suppose in the banking system presented in section 4.1 we have the all b:bank| some b.accounts formula in alloy stating that all banks have at least one account. the some keyword, when applied to an expression, defines a predicate stating that there is at least one element in the expression. considering our formalization for representing universal quantification formulae, the variable name x of all b:bank| some b.acc is b, its type t is bank and the f formula is some b.accs. notice that all universal quantification formulae are quantified over



there are some constraints that define a well-formed signature or relation in alloy. next, we declare the well-defined constraints for our core language. for instance, a signature can only extend another declared in the same module(extsigsfrommodel) and an alloy model cannot have two signatures with the same name(uniquesigname). moreover, a signature cannot extend itself direct or indirectly(norecextension) and may extend at most one signature(singleinheritance). additionally, the left and right side types of a relation must be signature names declared in the same model(reltype). finally, as previously mentioned, we add a constraint stating that we cannot have two relations with the same name(uniquerelname) in a model. next we formalize the wfsigrel predicate.



one kind of type error in alloy is an arity error. it is reported when we attempt to apply an operator to an expression of the wrong arity, or to combine expressions of incompatible arities. for instance, the union of a signature name and a field, such as bank+owner, is ill-typed since they have different arities. a disjointness error happens when two relations in an expression are combined in a way that always results in an empty relation. for example, the expression bank& account yields a disjointness error, since this intersection is always empty.



we do not allow in our core language two variables with the same name, which is possible in alloy. this does not restrain expressiveness since we can always rename a variable. finally, the model m must declare a signature named t.



the same holds for product and transpose expressions. for join expressions e1.e2, at least the right type of e1 must be a super or subtype of the left type of e2. in case of closure expressions^e1, at least the left and right types of e1 must have a subtype in common.



all type errors(arity, disjointness and irrelevance) reported in alloy analyzer are sound. however, reports regarding ambiguous references may generate a false alarm. in alloy, two disjoint signatures can declare relations with the same name. for example, in the following fragment describing some expressions in alloy, notice that the subsignatures bynary and unary declare a relation(left) with a same name. moreover, we have a formula stating that all unary expressions have exactly one left expression. the one keyword, when applied to an expression, denotes that the expression yields exactly one element. however, the alloy analyzer tool reports a false alarm stating that this formula has an unambiguous reference type error. the tool reports that it is not possible to know whether left is from unary or binary in the formula.



in alloy it is possible to have none expressions, which denote the empty set relation. it has the same type(empty) of some ill-typed expressions. for example, considering the formula account= none expressing that there is no account. although account and none have disjoint types, this formula is well-typed in alloy analyzer. therefore, we need some additional cases in some parts of our formalization for dealing with none expressions. since none is a syntactic sugar construct,



in this section we show the importance of the static semantics in proposing and proving model transformations for alloy in pvs. we have proposed a set of primitive laws for alloy, stating properties about signatures, relations, facts and formulae. each primitive law defines two fine-grained structural semantics-preserving model transformations. although they define primitive and localized transformations, we can compose them in order to derive interesting coarse-grained transformations.



when introducing r, its name must not be previously declared in the family of s(all signatures that extend or are extended by it) in order to preserve uniquerelname valid. it is important to mention that uniquerelname is the only property of wfsigrel that is different in full alloy from our core language. this property states that a model cannot have two relations with the same name, which is very restrictive. in full alloy, two relations declared in disjoint signatures can have the same name. the conditions related to the relation names of laws for the core language may be relaxed when considering full alloy.



moreover, t must be a signature name declared in the model in order to preserve reltype. the other constraints of wfsigrel(extsigsfrommodel, uniquesigname, norecextension and singleinheritance) are related to signatures. since we do not change signatures, these properties are satisfied. when removing r, all properties regarding signatures are valid because we do not change them. moreover, removing elements that are not used do not cause name conflicts. therefore, all properties of wfsigrel are satisfied when removing a relation.



preserves semantics. next we declare a function describing some of the conditions for introducing a relation, as established in law 1, stating that there exists a signature named t in m1. the right function denotes the right type of a relation.



since we are dealing with fine-grained transformations that have syntactic conditions, the previous two functions are easily specified. now we are able to state the theorem in order to prove that the introduction of a relation preserves static semantics. so, we have to prove that a transformation takes a well-formed model to another well-formed model, as declared next.



so far, we have proposed a set of 21 primitive laws for alloy. all of them are proven sound in pvs. although they define small transformations, we can compose them and derive interesting coarse-grained transformations, such as refactoring 1. all refactorings derived using these laws are also type safe and do not need to be proven in pvs. therefore, we do not need to prove that the two transformations defined by refactoring 1 preserve the static semantics.



proving some laws in pvs shows us the importance of defining fine-grained transformations. in our opinion, coarse-grained transformations would be far more difficult to prove. the pvs prover helps us by performing several proofs or part of those lemmas automatically. in order to do that, experience with pvs is needed, for deciding when to apply the appropriate proof command.



related work proposes a formal dynamic semantics for a subset of our core language[7,18]. the authors take into consideration the same expressions and formulae as ours, but, in contrast, they consider signatures as a syntactic sugar construct for sets. moreover, there is no signature extension in their language. our core language contains all elements of their language. they do not formally state when an alloy set of transformations for structural and behavioral diagrams. they propose some structural refactorings, such as extract interface. moreover, they do not precisely state the enabling conditions. some class diagram transformations consider ocl constraints. evans proposes deductive transformations for a subset of uml class diagrams. a semantics is proposed for a subset of uml class diagrams. he proposes five transformations, such as the pull up attribute refactoring. however, some transformations do not preserve the static semantics in some situations, as shown in section 2. these transformations can easily introduce type errors when considering ocl constraints.



another work presents some refactoring rules for uml class diagrams annotated with ocl constraints. they describe how the ocl constraints have to be refactored to preserve their syntactical correctness. however, they do not formally prove that they preserve semantics. we can easily verify that some of their transformations do not preserve semantics. no transformation has been proved to be type safe, which may be dangerous in some situations, as shown in section 2.



one transformation is very similar to our transformation defined by refactoring 1. his work does not prove that the transformations preserve the static semantics. the conditions for each transformation are not precisely defined as presented in our work. moreover, since it is a simple language, bergstein considers pushing down or pulling up a relation as a primitive transformation, differently from our approach.



mccomb investigates refactorings for object-z models. he proposes three refactoring rules and show that they are complete in the sense that any object-z specification that does not have unbounded recursive constructs, any design may be derived, which represents a refinement of the original specification. he informally describes the enabling conditions of each refactoring rule and does not prove the static semantics preservation.



a closely related approach was developed by tip et al.. they realized that some enabling conditions and modifications to source code for refactorings involving generalization in java, for automation in eclipse, depend on relationships between types of variables. these type constraints enable the tool to selectively perform transformations on source code, avoiding type errors that would otherwise prohibit the overall application of the refactoring. they manually proved that these refactorings preserves the type system of the language. in our approach, we can prove that any model transformation preserves static semantics, not only dealing with generalization.



a more practical work proposes refactorings for java programs. the author guarantees that two programs have the same behavior if the resulting program compiles and does not present failures in a test suite. the compilation is necessary in order to guarantee that it preserves the static semantics and the test suite makes sure that the behavior is preserved.



one of the most difficult tasks for proposing refactorings is to define the enabling conditions. this is the most important part for refactoring tools developers. they rely on these conditions to automate refactorings. we can waste a great amount of time trying to prove something that cannot be accomplished. the experience of proving some laws in pvs shows us that it becomes easier(dealing with finegrained transformations) to identify which conditions are necessary for a specific transformation.



