the presence of concurrent terms in clf allows for a new representation methodology compared to the way e.g. operational semantics has been represented in twelf. in twelf the methodology is a goal-oriented approach focusing on proofsearch via backward chaining bearing much resemblance to logic programming, whereas in clf the canonical representation methodology is context-oriented, employing forward chaining inside the monad. as clf is a conservative extension to lf it allows both styles of representation to coexist.



so the important question is whether the methodology of meta-theory representation and proof representation known from twelf can be conservatively extended to deal with the new clf representations and how. the clf extensions over lf are linear and concurrent terms, so a conservative meta-logic for clf would need to extend twelf with induction on linear and concurrent terms. the importance of this question is emphasized by the fact that it is a main part of the uncharted clf-territory and contains valuable insight on the directions in which clf could be further developed.



in twelf, proofs are by structural induction since whatever is represented in twelf is represented as an inductively defined lf-term. furthermore the proof objects themselves are inductively defined lf-terms. we expect this meta-level representational methodology to extend to clf as well, since it is a conservative extension at both the object level and the semantic level. there are however several challenges, and the one we will focus on is how to extend the structural induction known from twelf to one working with terms with implicit concurrency. 3



since the above proof only relies on straigtforward induction on lf-terms it should be easy to represent in clf for any conservative extension of the twelf meta-theory to clf. this is however still very speculative. more on this below in section 4.2.2.



in order to complete the proof we will need to come up with a much stronger induction hypothesis. we will need to reason about the continuations that can occur in the linear context, and in order to make this precise, we will start with a definition of normal linear contexts to be the relevant linear implications from return... into a monadic type:



if let-floating has to be reasoned about explicitly in clf then we could probably just as well have represented the concurrent features explicitly as it would be done in twelf. to get actual benefit from clf it therefore seems likely that we would have to come up with a let-floating aware coverage-checker, such that the let-floating would be handled behind the scenes, much like substitution is handled behind the scenes in twelf. more specifically, in a trace where a and b can occur in either order, we want to be able to implicitly assume that for instance a occurred first.



a conservative approximation of this restriction which is easy to compute, is to simply start the proof search semantics looking for a term of type{1}. the first step after entering the monad is a nondeterministic choice depending on the signature. now if the only option for this nondeterministic choice is to terminate the forward-directed mode and construct 1 directly then we are certain that the signature is legal, otherwise we reject the signature.



