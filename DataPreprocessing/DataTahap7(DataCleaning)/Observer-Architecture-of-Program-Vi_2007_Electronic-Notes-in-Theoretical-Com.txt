we propose observer architecture for program visualization. the principles of observer architecture are modular, model-driven visualization with one-directional coupling, hierarchical delegation, message-passing and archival by visualizers. the architecture is scalable. the resulting visualization can be distributed and modified independent of the model. the observer architecture has been implemented in online tutors for programming called problets.





our programming tutors, called problets, automatically build a model of the program presented in each problem. the model consists of the structure and behavior of the program. the structure describes the programming objects and constructs, and how they are interconnected within a program. the behavior describes the execution semantics of the constructs used in the program. consider the following c++ pointer code with a nested block:



in the observer architecture of program visualization, each component in the program model is an observable object. each of these objects is coupled with an observer object whose responsibilities are to track and visualize the changes in the state of the observable object. the overall structure of the visualization objects is isomorphic to the structure of the model. this architecture is inspired by the model-view-controller pattern used for graphical user interface construction.



message-passing for coordination: since each visualization object is modular, it is often necessary to coordinate among two or more visualization objects, e.g., when animating the assignment of the value of one variable to another, or depicting the assignment of a pointer to point to a variable or heap object. message-passing is used for such coordination. in message-passing, a visualization object that needs to coordinate with another visualization object passes a message up and down the visualization hierarchy. a visualization object that receives the message acts on it if it is the intended target of the message, and passes it onwards if it is not.



some of these principles, viz., separation of model and view, and one-directional coupling between the model and view have been proposed in the matrix framework for building algorithm visualization. our work may be seen as an extension of the matrix architecture in that we have proposed hierarchical delegation, messagepassing for coordination and archival functions. whereas a static repository is used in the matrix architecture to keep track of the visualizations, we use hierarchical delegation.



observer-architecture is model-driven, i.e., visualization is driven by a model of the domain that can be simulated. model-driven visualizations are capable of capturing more of the semantics of the domain being modeled. they support custom input data sets, one of the ways to improve the effectiveness of visualizationin the case of program visualization, this includes visualizing learner-written programs. they reduce instructor overhead, one of the impediments to adoption and use of visualization, because, instead of specifying the visualization, the instructor can specify the program for which the visualization is desired, and let the model-driven observer architecture automatically create the visualization for the program.



we have proposed observer architecture for visualization. the architecture is general and domain-independentit can be used for algorithm visualization just as well as program visualization, as long as an appropriate model is available. this may be seen as a disadvantage of observer architecture for program visualization: the model needed for program visualization is a language interpreter, constructing which can be a daunting undertaking.





problets are driven by parameterized templates. the user can execute and visualize a new program by simply entering its template into a problet. by defining a clear separation between observable and observer objects, observer architecture makes it easy for the developer to provide multiple visualizations of a programming construct. when the developer provides alternative visualizations, the user can select among them as easily as selecting from a menu. the user will be able to customize the visualization to the extent that the individual visualization objects allow them, e.g., visualization of a variable may permit the user to change its appearance or animation scheme. since the visualization objects are composed to build the overall visualization, the user can customize the visualization of each type of program object independent of the visualization of the other objects.



