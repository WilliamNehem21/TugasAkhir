service oriented computing(soc) is based on service composition, that is, loosely coupled autonomous heterogeneous services, which are collectively composed to implement a particular task. we develop a new calculus for soc within the framework of csp process algebra, aiming to improve the verification techniques and to enhance the expressiveness of soc calculi. this paper presents the part of the calculus that extends csp with built-in buffers to facilitate direct asynchronous communications. we provide the operational semantics of the calculus and extend the fdr(a csp model checker) by implementing functions for asynchronous communications.



process calculi, such as scc and caspis, provide a formal specification of interaction patterns with synchronous communications, allowing designers to reason about the correctness of soc systems. other formal systems, such as cows and conversation calculus, consider only asynchronous communications, since synchronous communications in the internet standards are usually implemented by network protocols such as tcp/ip, which are by default asynchronous. to the best of our knowledge, none of the formal calculi developed for soc supports both synchronous and asynchronous communications.



the novelty in cspa is the introduction of implicit buffers, which are used in the channel semantics to facilitate asynchronous communications in a transparent way. in other words, cspa includes asynchronous communication primitives, which rely on buffers, but designers do not need to create, maintain or terminate buffers. we provide an operational semantics that explains how buffers work.



in previous work, we extended csp with primitives to model dynamic compensations. here we focus on communication primitives solely: we enhance csp by allowing asynchronous communications in addition to its standard mixed synchronous/interleaving communications. more precisely, we extend the parallel composition operator in order to permit mixed synchronous, interleaving and asynchronous communications. in future work, we plan to include also primitives to create and maintain sessions and to model mobility, to obtain an expressive calcu-



paper overview: section 2 recalls some basic csp notions. section 3 introduces cspa. section 4 discusses the relationship between csp and cspa. section 5 presents the implementation of cspa in fdr. section 6 illustrates the usability of this extension with an example. section 7 discusses related work. finally, section 8 concludes and discusses future directions.



where a can be the name of an atomic action, inputting through channel a(written as a?x), outputting through channel a(written as a!x), or a combination of them(e.g. a!x?y). the interleaving(|||) and the parallel composition( a) operators have



in two-way communications(between two processes) if buffers are introduced in the middle of a communication then the sent message from the first process will be stored in the buffer until the receiver process is ready to get the message. however, in multi-way communications(multiple processes communicate) as in csp, we should explain what asynchronicity means. in our model, we want to retain the csp model of multi-way communications with the addition of asynchronicity. in multi-way communications, buffered channels may introduce non-determinism, as example 3.2 shows.



according to our model the communications can happen in any order. if the output is done first then the value 3 will be stored in ba then retrieved by the input event. however, which input event will get the value from the buffer(a?>x or a?>y) is not specified. either a?>x gets the value and a?>y will be waiting for a new value, or the other way around.



synchronous communication, but with a delay between inputting and outputting values. this can be achieved by synchronising on input events and output events. thus, if buffers are empty, then all output events happen at the same time and upload data to buffers, then all input events get the same value from the buffers. note that, cspa adheres to csp synchronisation rules, where the whole a.n event is considered in synchronisation. for instance, in csp, an event a.3 can only be synchronised with a.3 or a.x if x is an input variable(in the latter case, x will be substituted by 3).



buffered channels within csp have been discussed also in, where all or a set of channels can be selected to be buffered between two processes. installing buffers in two-way communications was enough for the purpose of this model which is proving that the correctness of a network of processes is independent of the amount of buffering added. however, in our model, we aim to provide a practical model where asynchronous communications are available as primitive communications in addition to the standard synchronous and interleaving communications. therefore, we extend csp with built-in buffers which can be used anywhere in the system. additionally, our model retains the multi-way communication mode of csp.



