the relative ease of use comes at the cost of putting aside a number of important practical issues, such as the existence of imperfect quantum hardware, the need for quantum error correction and the fact that every quantum program will eventually have to be implemented as a quantum circuit using only a finite set of quantum gates and, therefore, some of the unitary transformations that nqml allows will have to be approximated. similar problems were a source of concern for the founders of the classical programming model many decades ago. fortunately they have been resolved and their solutions have been abstracted in such a way that people who use modern high-level programming languages do not need to know anything about them. we believe that the same can and must be done for the quantum programming languages of the future and adopt the approach that such issues should be tackled not by the designer and users of a quantum programming language, but by the architect of a quantum computer, the designer of its operating system and, to a lesser extent, the designer of the compiler.



the rest of the paper is structured as follows. section 2 discusses related work. in section 3 we describe the syntax and semantics of nqml and section 4 contains a number of examples. in section 5 we discuss how to extend nqml with a polyifm e then e1 else e2: it conducts a measurement on e, which must be of type qubit. depending on the result, it executes one of its branches. it is similar to a classical random branching, based on a toss of a biased coin with probabilities depending on the state of the qubit being measured.



if e then e1 else e2: it allows the programmer to perform quantum branching. if e, which must be of type qubit, is in a classical state, then the effect is what we would expect from ifm. but if e is in a quantum superposition, the program proceeds in a quantum superposition of both branches, most likely creating entanglement among the qubits of the quantum state.



e x, x'. c: a generic means of expressing any unitary transformation, which has to be relied upon when a transformation can not be easily broken down to a series of controlled operations, expressible with if. its advantage is that, rather than forcing programmers to precompute and provide the whole unitary matrix of the transformation, whose size is exponential in the number of qubits that it affects, it allows them to express that matrix as a complex function of the input and output state of the transformed qubits. this leads to a succinct and clear expression of many useful quantum algorithms, such as the quantum fourier transform that is described in section 4.



the semantics of the let construct, product introduction and elimination is straightforward and very similar. in each of them, evaluation begins with the evaluation of e1 and continues with the evaluation of e2 on the new state. the impure cases are very similar. 8



the case of if is slightly more complicated. evaluation begins with the condition. the matrices that correspond to the two branches are calculated and their(inexistent) effect on the control bit is removed by using the auxiliary function except. then, the two expressions are executed conditionally, with e as the control qubit. the impure case is again very similar.



surprisingly, the measuring conditional ifm is more straightforward. the condition is evaluated and then the corresponding qubit is measured. the auxiliary function measure returns the two density matrices that correspond to collapsing a qubit to a classical state. then the two branches are combined. each branch is evaluated on the corresponding result state of the measurement and their sum is the total result.



we now present a few example nqml programs of varying complexity. we start with two useful operators in quantum programming: not and had, standing respectively for quantum negation and the hadamard transformation. both can be applied to any expression q of type qbit[n].



in the examples of the previous section we have used parametric expressions in nqml, such as not(q) or cnot(q, p). such parametric expressions were used as macros: when used in another expression, not(e) is syntactically expanded by substituting the expression e for q in the body of not. macro expansion is an easy way to enjoy some of the advantages of having functions in nqml, without resorting to a more complex type system. macros can even simulate higher-order functions, such as deutsch(f) where f is a function from qubit to qubit, or polymorphic functions, such as add(r, c) where r is a quantum register of unknown type. they cannot, however, simulate recursive functions or currying.



in this section, we sketch a polymorphic type system for nqml to support higher-order functions. although we do not deal with the denotational semantics of the extended language here, we believe that it is possible to extend nqml with polymorphic higher-order recursive functions, as also suggested by selinger and valiron. the type system that is briefly presented here lays the ground for such an extension.



where the variable k ranges over qubit positions. we take this idea even further and we disallow types of the form qbit[n] in function arguments, for any constant n. all function arguments must be polymorphic w.r.t. the qubits in which they reside.



