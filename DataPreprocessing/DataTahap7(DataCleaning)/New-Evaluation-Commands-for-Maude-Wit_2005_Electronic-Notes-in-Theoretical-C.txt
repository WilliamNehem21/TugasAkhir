maude is able to deal with infinite data structures and avoid infinite computations by using strategy annotations. however, they can eventually make the computation of the normal form(s) of some input expressions impossible. we have used full maude to implement two new commands norm and eval which furnish maude with the ability to compute(constructor) normal forms of initial expressions even when the use of strategy annotations together with the built-in computation strategy of maude is not able to obtain them. these commands have been integrated into full maude, making them available inside the programming environment like any other of its commands.



full maude is a language extension of maude written in maude itself, that endows maude with notation for object-oriented programming and with a powerful and extensible module algebra in which maude modules can be combined together to build more complex modules[9,10,4]. every maude module can be loaded in full maude by just enclosing it into parentheses. then, the usual evaluation commands of maude(e.g., reduce, rewrite, etc.) are available in full maude by also enclosing them into parentheses.



in this paper, we introduce new commands to make techniques(i) and(ii) available for the execution of maude programs. or to be more precise, of full maude programs. on-demand strategy annotations are not directly available in maude, although they can be used, e.g., in cafeobj programs(see).



the rest of the paper is structured as follows. section 2 gives some preliminaries on context-sensitive rewriting and local strategies. section 3 discusses on reflection and the way it appears in maude through its built-in module meta-level. sections 4 and 5 explain, respectively, how the commands norm and eval have been added to full maude. section 6 draws some conclusions and future work.



all this functionality is very useful for metaprogramming, and in particular when building formal tools. moreover, full maude provides a powerful setting in which additional facilities are available, making the implementation of new commands, as the ones introduced in this paper, much simpler. the specification of full maude and its execution environment can then be used as the infrastructure on which building new features, with the additional advantage of making such commands applicable to full maude modules, that is, to modules which may be parameterized, object-oriented, etc.



as for other commands, we may define the actions to take when the command is used by defining its corresponding meta-function. for instance, a reduce command is executed by appropriately calling the metareduce function. in the case of norm, we define an operation metanorm, which takes arguments of sort module and term and returns a term of sort resultpair, a pair consisting of a term and its corresponding sort(see for details). basically, metanorm calls the auxiliary function metanormred, which reduces the term using metareduce, and then proceeds recursively on each of the arguments of the resulting term. it calls metanormred on the arguments with evaluation restrictions, and metanormnored on the others. metanormnored proceeds as metanormred, but without reducing the term before going on the arguments.



now, we need to extend full maude so that the command can be entered by the user. to parse some input using the built-in function metaparse, we need to give the metarepresentation of the signature in which the input is going to be parsed. in full maude, such a grammar is provided by the full-maude-sign module, in which we can find the appropriate declarations so that any valid input, namely modules, theories, views, and commands, can be parsed. since we wish to add new commands, we need to extend such a module with the new declarations. for example, for the command norm, we can define the following norm-sign module.



here, grammar is the metarepresentation of the module full-maude-sign, obtained in a similar way, which is defined in the module meta-full-maude-sign. in the current version of maude, input/output is accomplished by the predefined loop-mode module, which provides a generic read-eval-print loop. in the case of full maude, the persistent state of the loop is given by a single object of class database which maintains the database of the system. this object has an attribute db, to keep the actual database in which all the modules being entered are stored(a set of records), an attribute default, to keep the identifier of the current module by default, and attributes input and output to simplify the communication of the read-eval-print loop given by the loop-mode module with the database. using the notation for classes in object-oriented



the evaluation of quoted terms quote(t) is performed by introducing some additional rules to appropriately deal with the new symbols in the setting of the considered program r. the transformation vf(r) takes a defined symbol f as a parameter(usually the top symbol of t) and yields a new module which can be used to obtain the values of expressions t whose root symbol is f. by lack of space, we cannot give all details of the transformation and we refer the reader to for a detailed explanation of its definition and conditions of use.



we have implemented a new command eval which uses this transformation to obtain the value(if any) associated to a given input expression t. in contrast to the command norm, we first transform the module and, then, we simply reduce the expression unquote(quote(t)) within the new module(using the metareduce function). we define a function transformcorrcomp which takes arguments of sort module and qid and returns the transformed module. basically, transformcorrcomp builds the set of rules and new symbols necessary for the transformation and adds them to the previous module; see for details.



the function proccommand calls the function proctrcorrcomp with the appropriate arguments: the name of the default module, the flatten module itself, the bubble representing the argument of the command, the variables in the default module, and the database. the function proctrcorrcomp is in charge of evaluating the bubble given as argument of the eval command, calling another extra function pretransformcorrcomp, and then preparing the results(a list of quoted identifiers that will be passed to the output channel of the read-evalprint loop to be shown to the user). the function pretransformcorrcomp, which finally calls transformcorrcomp, performs two tests in order to determine whether the transformation is necessary or not. these two tests are associated to the following two facts:



furthermore, the reader should note that since the transformation is parametric with respect to a defined function symbol, the command eval is often more interesting than the command norm, since we can evaluate an expression within the transformed module for a concrete defined function symbol. this often improves the termination behavior of the evaluation process(see). for this reason, we have implemented a variant of the command eval_for_ allowing the explicit inclusion of the defined function symbol(which can be thought of as expressing the functionality we are interested in) to transform the module.



maude is able to deal with infinite data structures and avoid infinite computations by using strategy annotations(see). maude strategy annotations are lists of non-negative integers associated to function symbols that specify the ordering in which the arguments are(eventually) evaluated in function calls. some argument indices can eventually be missing from these lists thus improving the termination behavior of the program. however, they can eventually make the computation of the normal form(s) of some input expressions impossible.



we have used full maude to implement two new commands norm and eval which furnish maude with the ability to compute(constructor) normal forms of initial expressions even when the use of strategy annotations together with the built-in computation strategy of maude(i.e., command red) is not able to obtain them. the command norm performs a layered normalization of the initial expression until the normal form is reached(if any). on the other hand, eval uses a transformed program to obtain a different one which is able to obtain the constructor normal forms which correspond to a given input expression.



these commands have been integrated into full maude, making them available inside the programming environment like any other of its commands. the high level at which the specification/implementation of full maude is given makes this approach particularly attractive when compared to conventional implementations. the flexibility and extensibility that full maude affords has made the extension quite simple, and in a very short time.



the overloading which is introduced by the preprocessing step of eval(i.e., computing the transformed program) is not so high. this is more evident when we consider the factorization of the first, second and fourth numbers where the computational effort due to the factorization is much higher than the administrative overloading.



