elan was one of the first rule based language to introduce a clear separation between the notion of rule and the notion of control, also called strategy. starting from this experience, our goal was to make available these constructs in a widely used language such as java. in this paper we present the essential features we have considered when designing the tom language, which is an extension of java that integrates the notions of rules and strategies. relying on the implementation, we explain how these ingredients can be implemented and smoothly integrated in a java environment.



the notion of rewrite rule is an abstraction that can be used to model various processes. it has been used intensively to model, study, and analyze different parts of a complex system, from algorithms to running software. on one side it can be used to describe the behavior of a transition system for instance. on the other side, it provides a theoretical framework useful to certify and prove properties such as termination or confluence.



programming with rewrite rules is apparently easy: a complex transformation can be decomposed into elementary transformations, encoded using a rewrite rule, then, we rely on the rule engine to fire a rule whenever it is possible. most of the time, we are interested in getting a result whose computation is deterministic. in other words, the result should be reproducible, the set of rules should be terminating and confluent. however, things are rarely confluent by nature. one solution could be to use the knuth-bendix completion, but this is not realistic on large programs.



a first solution to this problem is to assign a priority to each rule and to consider an execution mechanism that encodes a fixed order of reduction, such as innermost or outermost, also called call by value or call by name in functional programming languages. another solution is to separate the control from the rules. instead of encoding the control into the rules themselves, it is described in a distinct expression or language. the expressions that specifies how the rules should be applied are called strategies. the design of such a strategy language is not easy and several attempts and proposals have been made.



maude followed this approach and added the notion of meta-level. in this setting, a rewrite rule has a name, considered as a constant, and can be explicitly applied via the meta-apply operator. the application of a set of rules can be controlled by another program, expressed by rewriting and using meta-apply. this new program can also be controlled by another program from the meta-meta-level. this tower of reflexivity is very elegant and expressive, but a bit difficult to use.



during the last decade we have accumulated an important experience in both implementing and using rule based languages. in this paper we try to isolate the essential constructs and features that have to be considered when designing a new rule and strategy based language. in a second part, we explain how those features can be smoothly integrated and efficiently implemented into an object oriented programming language such as java.



a same label can be given to several rules to define a rewrite system. the application of such system has to be explicitly specified by the user. given a term t, the application of a labeled rule performs a single step of reduction at the root position, if t is matched by a left-hand side. otherwise, the application fails.



another important feature inherited from elan is the ability to automatically maintain terms in normal form with respect to a rewrite system. this is done via the definition of unlabeled rules which are applied until getting an irreducible term. the considered rewrite system has of course to be confluent and terminating.



maintaining a data structure in canonical form is an essential feature that improves the quality of software. the programmer does no longer have to take care of this maintenance by calling normalisation functions. in addition, this makes the writing of elementary transformations simpler since only canonical forms have to be considered.



in our case, the situation is a bit particular since in addition to the notion of rule, there is an underlying turing complete language, namely java. to control the application of rules, an attracting possibility would be to use java directly. this language natively offers the composition(;), the repetition(while), and many other control statements. however, the more we use java, the more it becomes complex to reason about programs and to perform proofs. how to show that a rewrite system is terminating under a given strategy when this strategy is expressed in java? therefore, the problem is to find a good strategy language which is both expressive and simple to use.



as mentioned in the introduction, we have studied and experimented the expressiveness of several existing strategy languages. the one proposed by stratego has several interesting properties. it is atomic, being composed of less than 10 elementary combinators. it is expressive, allowing the definition of various traversal strategies. initially not tailored to support non-deterministic searches, we will see that this limitation can be removed in a simple and elegant way, using context information.



specific term data structure: the implementation of the term data structure becomes a parameter of the tom compiler, using a mapping mechanism. an advantage of this approach is to make the%match construct usable on any kind of data structure. the counterpart is that the user has to provide an implementation.



the notion of labeled rule cannot be implemented with the same approach. a labeled rule corresponds to an elementary strategy that has to be manipulated as an object. therefore, its implementation cannot be a function: this is not a first order object in java. in our setting, an elementary strategy is implemented by a class which has an apply function. the implementation of such a class is generated automatically when using the%strategy keyword:



this results in a language in which formally defining algorithms using terms, rules, and strategies is easy and elegant, without losing the flexibility and versatility of the underlying host language. it makes possible the mixture between the formal definition of a logic system, using tom, with user code that provides a fully fledged interface implemented using low level code. the integration of formal aspects into a classical programming language eases a gradual integration of formal methods into existing projects. in practice, this integration becomes natural since the use of algebraic constructs, as those provided by tom, makes the code smaller, more readable and robust.



