suppose that we want to model part of a banking system in pvs, on which each bank contains a set of accounts, and each account has an owner and a balance. next, we declare a theory named bankingsystem that declares two uninterpreted types(bank and person), representing sets of banks and persons, and a record type denoting an account. an uninterpreted type imposes no assumptions on implementations of the specification, contrasting with interpreted types such as int, which imposes all axioms of the integer numbers.



in pvs, we can also declare function types. next, we declare two functions types(mathematical relation and function, respectively). there are various forms to declare functions in pvs. one of them is to just declare its name and parameters and result types, such as the first function establishing that each bank relates to a set of accounts. another way is to also define the associated mapping, as in the second function, which denotes the withdraw operation.



the balance(acc) expression denotes the balance of the acc account. the with keyword denotes the overriding operator. in the withdraw function, the expression containing the with operator denotes an account with the same owner of acc, but with a balance subtracted of amount. similarly, we can declare a function representing the credit operation.



in this example, an arrow with a closed head form, such as the one from chacc to account, denotes a subset relationship. in this case, chacc is a subset of account. since the two subsets share an arrow, they are disjoint. if the arrowhead is filled, the subsets exhaust the superset, so there are no members of the superset that are not members of one of the subsets. in both object models representing a banking system, the subsets form a partition: every member of the superset belongs to exactly one subset.



the third property of a valid view ensures that there is exactly one valid item for each name in the alphabet that does not belong to the models. since v1 is a valid view for m1 and m2, it already has mappings for all names of m1 and m2 in the alphabet. therefore, we must guarantee that if the name mapped by it, which is the item to be removed, is not included into one of the models, for instance m1, then the expression mapped by this name cannot be evaluated in m1, containing at least one name that does not belong to m1. accordingly, this item must not be valid for m1. this constraint ensures that it is not used when comparing interpretations, hence preserving the property that the view has only one valid item for each name in a model.



similarly, we proved a theorem for increasing a view. we just have to check the same properties of decreasing a view, and two other constraints verifying that the new item cannot be recursive and maps an element of the alphabet. observe that these constraints imply that we can only introduce an item that is not used to compare the corresponding models, as stated by the following theorem.



first have apply the law to decrease the view, removing the item for it; then we can apply the law to decrease the alphabet. it is important to observe that the conditions for decreasing a view are also syntactic. for increasing an alphabet, we need some semantic conditions, since we have to make sure that both models have the same values for the names added in the alphabet.



