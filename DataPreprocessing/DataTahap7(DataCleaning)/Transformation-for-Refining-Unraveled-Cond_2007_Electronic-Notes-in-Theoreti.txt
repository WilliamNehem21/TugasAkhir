4 is an important property of ctrss and it can be guaranteed by termination of the unraveled ctrss[6,7,13]. the first transformation from ctrss into trss was investigated for normal ctrss by j.a. bergstra and j.w. klop. this concept was revisited as an unraveling by m. marchiori who discussed its properties such as syntactic ones, termination, modularity, and so on. he also proposed an



the unraveling for deterministic ctrss is used in the inversion compilers proposed in[10,11]. the compilers transform constructor trss into ctrss that compute(partial) inverses of functions defined in the trss. the compilers then unravel the ctrss into trss whose rules may have extra variables. since terms representing inverse computation of many-to-one functions may have several normal forms as solutions of the computation, the ctrss that are intermediate results of the compilers are not always confluent. for this reason, this paper does not assume confluence for ctrss. the transformation in this paper is sometimes useful for simplifying trss obtained by the compilers. we will show an example at the end of this paper.



as another approach to simulation-completeness, it was shown that the unraveling for normal ctrss is simulation-complete for all left-linear normal ctrss. it was also shown that the unraveling for deterministic ctrss is simulation-complete for ctrss if the unraveled ctrss are either left-linear or both right-linear and non-erasing. the approach in is not applicable to all deterministic ctrss while that in is so.



thus, in order to allow simultaneous evaluation of conditions that can be evaluated in parallel, we improve the ordinary unraveling uo so that some conditional rules are decomposed to less unconditional rules. this idea comes from the unraveling un for normal ctrss. as shown in the proof of theorem 3.7 later, this improvement is not so a novelty. however, it is sometimes effective for reducing the number of the unraveled rules by the transformation we will show in section 4(see an example at the end of subsection 4.3).



={1,..., n} for all n-ary symbols f that may be a u symbol. in this way, by using the above replacements, we succeeded in reducing the number of u symbols from u(r), removing u symbols and updating the context-sensitive conditions.



it is probably impossible to relax the condition rmc in subsection 4.2 in maintaining simulation-completeness of the unraveled ctrss. on the contrary, we should tighten rmc for maintaining a feature of conditional rules associated with efficiency of reductions. consider the following ml program.



the let structure provides a facility that bundles the parallel evaluations of terms that are identical into one. for example, twofib2(n-1) is evaluated once in the first ml program and three times in the second ml program. the advantage of coming from the let structure is lost in the process of t, by instantiating variable m in tp2(#2(m), add(#2(m),#1(m))), whose occurrence is non-linear, with twofib(n). in order to prevent such instantiation in these cases, we must tighten the condition rmc as follows:



it is clear that rmc' implies rmc. the above condition rmc' does not cause the target systems to lose the essential advantage of the original ctrss, such as efficiency that comes from let structure. in order to keep the advantage of ctrss relative to efficiency of reductions, t should be based not only on rmc but also on rmc' even when all u symbols can be removed by t based on rmc.



where div and sub compute division and subtraction of natural numbers, respectively, and tpi(t1,..., ti) denotes the tuple of i terms t1,..., ti. if we can identify tp1(t) 10 with t, the above rule can be transformed into the following rule in the sense of computing division:



typical definition of division for natural numbers. this justifies the correctness of the program generated by the compiler relative to the handmade program. this example shows that in some cases, the transformation t may make it possible to obtain a smart unconditional rule that is simulation-complete for the original conditional rule.



as another approach to remove conditional parts of conditional rules, p. viry proposed a transformation from join ctrss into trss, that is also applicable to normal ctrss. unlike unravelings, his transformation does not introduce u symbols but extends the arity of defined symbols. similarly to unravelings, his transformation is not simulation-complete for all ctrss in general. the example



this work is partly supported by mext. kakenhi#17700009 and#18500011. we thank professor yoshihito toyama for pointing out some interesting issues about confluence. we would like to thank the anonymous referees for several comments that are useful to make the paper more precise. we are deeply grateful to salvador lucas for his valuable comments helping us to improve the final version of the paper.



