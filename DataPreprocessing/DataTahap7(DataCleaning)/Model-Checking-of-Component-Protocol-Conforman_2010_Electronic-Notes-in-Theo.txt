in past years, a number of works considered behavioral protocols of components and discussed approaches for automatically checking of compatibality of protocols(protocol conformance) in component-based systems. the approaches are usually model-checking approaches, i. e., a positive answer guarantees protocol conformance for all executions while a negative answer provides example executions that may lead to protocol violations. it turned out that if behavioral abstractions take into account unbounded concurrency and unbounded recursion, the protocol conformance checking problem becomes undecidable. there are two possibilities to overcome this problem:(i) further behavioral abstraction to finite state systems or(ii) a conservative approximation of the protocol conformance checking problem. both approaches may lead to spurious counterexamples, i. e., due to abstractions or approximations the shown execution can never happen. this work considers the second approach and shows a heuristics that reduces the number of spurious counterexamples by cutting off search branches that definitely do not contain real counterexamples.



developing software contains nowadays a big share of reusing previously developed software called components. often these components were developed a long time ago by different developers, third party companies, in different programming languages, supplied as binary code, or as distributed components(e. g., web services). thus, there is a big interest in components which can be composed to reliable systems.



protocol violation is discovered, an example demonstrating the violation is provided(counterexample). since the abstract behavior of a component(and therefore the system behavior) is an abstraction, it may model execution paths that can never be executed. in this case the counterexample is called a false negative. positive answers guarantee that no protocol violations occur.



there are two basic approaches to ensure abstract component behavior. in the top-down approach, the component developers specify the abstract behavior and then refine it(e. g.,[33,31]). the bottom-up approach determines from the source code the abstract behavior(e. g.,[43,7]). the top-down approach has the advantage that protocol conformance can be checked before implementing the components while the bottom-up approach has the advantage that the approach can be mechanized using standard control-flow analysis. this work considers the bottom-up approach.



there are three possibilities to overcome the undecidability of the general protocol conformance checking:(i) further abstraction to, for example finite state systems,(ii) bounded checking(by bounding the recursion depth and the number of concurrent threads),(iii) approximation of the protocol conformance checking. the first and third possibility may lead to more false negatives. the second approach may lead to false positive answers(in case a protocol violation happens with a larger recursion depth or a larger degree of concurrency than the given recursion depth and degree of concurrency, respectively). as demonstrated in, a naive implementation of(i) may lead to false positive answers in the presence of recursive call-backs even if each component internally only contains non-recursive procedures. hence, this work considers the third possibility.



the paper is organized as follows. section 2 introduces how process rewrite systems can be used for abstractions. section 3 introduces the approach of approximate protocol conformance checking and analyzes reasons for spurious counterexamples, while section 4 shows how to avoid these spurious counterexamples by using a specialized search strategy. section 5 shows the results of a case study. the paper finishes with a consideration of the related work in section 6 and the conclusion and future work in section 7.



this section is a summary of the results in extended by an explanation why the techniques work well. in particular, we present an abstract execution model based on process rewrite systems for concurrent execution of potentially recursive programs and motivate their use. then, it is shown how abstract component behaviors can be modeled as process rewrite systems and how these are glued together to obtain an abstract system behavior. finally, we show that special cases lead to component models known from literature.



after the calls a and b but before their synchronization, respectively. if a procedure call in a process is executed, a stack frame is pushed on a stack. if a new parallel process is started, a new stack grows for this process(like in a saguaro stack). synchronizations only can be performed between two top-level elements on cactus stacks if one of these stacks contains only one stack frame. hence, an execution transforms a cactus stack into a cactus stack.



procedure call happened. note that not all process-algebraic expressions correspond to cactus stacks. for example an expression p1.(p2|| p3) cannot correspond to a cactus stack because p2|| p3 would represent two branches in a cactus stack and therefore it would not be clear where to put p1 in the cactus stack.



protocols can be verified dynamically by performing the transitions according to the(incoming remote) invocations. in this work we focus on static verification of protocols, i. e., it is verified that a component is used according to its protocol before executing the component-based system.



hence, the reachability problem can be solved by using the round-robin reachability and will create fewer false negatives. this leads to a better applicability because a component developer or quality management representative has to check a lower number of counterexamples. moreover, because we cut branches during the verification, it will probably be finished faster.



the round-robin reachability within the time constraints. this is caused by the behavior of the round-robin reachability enabling the evaluation of a derivation path only if precisely one action rule was applied. thereafter, all protocol states are synchronized. in contrast, the trivial evaluation approach evaluates each path.



our verification approach ensures properties based on interaction protocols of programs which include unbounded recursion and unbounded parallelism. this leads to a higher quality of software, because the protocol conformance can be checked before the deployment. every error will be found.



this work has shown how the special properties of the representation(defined in earlier works) can be used to reduce the number of false negatives. we call this approach round-robin reachability, because it balances the derivation steps applied on each parallel term. this improvement reduces the costs of the quality check, because fewer counterexamples have to be reviewed to find the real errors. we assume that, most spurious counterexamples might be removed in an industrial environment.



currently, we validate our approach in an industrial case study of componentbased systems written in python and c/c++. we can create abstractions of source codes written in python, already. presently, we are creating a generator of abstractions for c/c++ source code. early results show that our approach is capable of finding errors or unexpected behavior in real programs. in future work we will create abstractions of bpel and php source codes, considering java is also planned.



the user of the verification process can use a graphical user interface(gui) or a python interface providing the api. the implementation of the web services for user interfaces omits the verification process and provides multi-user support. the gui can represent the abstract behavior of components and composed components using a graphical representation. prs transition rules are represented only in this way. to our experience a graphical representation of the considered counterexample is useful for the evaluation.



