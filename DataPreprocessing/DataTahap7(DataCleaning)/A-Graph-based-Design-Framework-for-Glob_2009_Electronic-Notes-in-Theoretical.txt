we present a framework for designing and analyzing global computing systems using dynamic software architectures. the framework, called t gga, integrates typed graph grammars and the alloy modeling language to specify programmed dynamic software architectures that represent systems that evolve their topology at runtime. we demonstrate the benefits of the framework by applying it to the study of an automotive software system.



software architectural models are intended to describe the structure of a system in terms of components, their interactions, and their composition patterns. since a gcs topology may change at run-time, software architecture(sa) models should be able to describe the change of the system and to enact those modifications during the system execution. such models are referred as dynamic software architectures(dsas)[2,3,22], to emphasize that the system architecture evolves during runtime. a variety of definitions of dynamicity for sa have been proposed in literature. below we list some of the most prominent definitions to show the variability of connotations of the word dynamic.



and groove. all of these allow to design typed and attributed graphs. full support of cardinality constraints, including automatic constraint checking, is only provided by agg. except for checkvml, which is intended to translate graph transformation models into the input language of model checkers, all these tools allow the execution of graph transformation rules, even with negative application conditions. their limits are in the possibility of designing typed hypergraphs. the only tool one that supports typed hypergraphs is graph exchange language gxl, but it lacks in verification aspects. in conclusion, the above considerations made us to select alloy as our tool.



the rest of the paper is structured as follows. in section 2 we introduce our pdsa formalization using tggs. section 3 presents the alloy implementation of each tgg aspects introduced, while section 4 shows in which way we can design an automotive system using tgga. section 5 concludes our paper with some conclusions and future work.



according to the above definition, nodes and ports are atomic concept, while edges has a field conn that maps each port to nodes. the keyword lone in the declaration indicates multiplicity, in this case that each port is mapped to at most one node. the signature graph(lines 10-16 of listing 1) is used to define as a graph as structure composed of nodes and edges.



to generate graphs that are conform a given type graph, we have defined in alloy the signature typedgraph that is a graph with a typing morphism. listing 2 presents the implementation of typed graphs. it is important to note that the target graph of the morphism in each typed graph is the style of the system(line 2). a type graph consists of a set of basic elements(i.e., edge, node, and ports) that can constitute a typed graph plus a set of constraints indicating how these elements can be lagally connected. for each new system that we want to design we must define an alloy module that contains all these elements. the style of our case study is described in section 4.2.1.



