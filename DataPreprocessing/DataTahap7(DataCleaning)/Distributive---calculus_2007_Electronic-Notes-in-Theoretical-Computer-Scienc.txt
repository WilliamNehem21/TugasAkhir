in this paper, we go a step further and we propose an extended version of the calculus that allows one to encode unrestricted term rewriting systems. this version of the calculus features a new evaluation rule describing the behavior of the result structures and a call-by-value evaluation strategy. we prove the confluence of the obtained calculus and the correctness and completeness of the proposed encoding.



the ability to discriminate patterns is one of the main basic mechanisms the human reasoning is based on. indeed, the ability to recognize patterns, i.e. pattern matching, is present since the beginning of information processing modeling. instances of it can be traced back to pattern recognition and it has been extensively studied when dealing with strings, trees or feature objects.



we show in this paper that the previously proposed encoding can be extended to the general case, i.e. to arbitrary term rewrite systems. for this, a new evaluation rule that enriches the semantics of the structure operator is added and an evaluation strategy is enforced by imposing a certain discipline on the application of the evaluation rules. this strategy is defined syntactically using an appropriate notion of value and is used in order to recover the confluence of the calculus that is lost in the general case.



roadmap in section 2, we give the syntax and the evaluation semantics of the proposed calculus and we prove its confluence. then in section 3, we discuss the expressive power of the calculus. more precisely we propose an encoding of(non-convergent) term rewriting systems in the calculus. finally in section 4, we conclude and give some perspectives of this work.



notice that the term(a d b b d c) a does not reduce to b as one might expect. instead, the fact that the rule b d c fails to apply to a(in classical rewriting) is also recorded in the final result as a(failure) term in normal form. this approach is very interesting when we want to handle explicitly the failures by allowing rules that can handle such particular terms(e.g. for an exception handling mechanism). however, if the user is not interested in the explicit manipulation of matching failures and just wants to ignore such a behavior, we need to handle uniformly matching failures and eliminate them when not significant for the computation.



the main difficulty in defining such a calculus comes from the fact that matching modulo the given congruence is generally non-unitary(at least for classical theories like associativity and commutativity). indeed there might exist(infinitely) many solutions and there exists no natural ordering for these solutions(i.e. substitutions). for example let us consider the term(f(x, y) d x) f(a, b) when working modulo the commutativity of the symbol f. there exist two solutions of the matching problem:{a/x, b/y} and{b/x, a/y}. depending on the substitution we use, we



as the normal form of some terms w.r.t. a non-confluent trs is not unique, we will obviously have to deal with sets of results. we choose here to encode sets of results as structures. the empty set is represented by stk and the union of two sets is represented using the structure operator. in the rewriting calculus the representation of some set is not unique as the structure operator is not considered as commutative, associative or idempotent.



proof. the proof of this theorem is done first by induction on the term m, and then by induction on the largest length of a reduction w.r.t. r of m to a normal form. it uses the theorem 3.2 and it is presented in.



the extension to general term rewriting systems is considered as the next step of this work. a major difficulty when dealing with matching modulo some congruence consists in the multiplicity of solutions and since these solutions cannot be ordered in any natural way, the structure operator should be then considered as associative, commutative and idempotent. moreover the notion of definitive failures should be adapted to the considered matching theories and a call-by-value strategy should be enforced to prevent matching against uninstanciated terms and thus to avoid loosing matching solutions.



