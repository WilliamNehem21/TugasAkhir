this direct implementation is not an efficient one(as expected). it is well-known that first-order unification, which is a particular case of nominal unification, is exponential if subterms are not shared, but it is linear if terms are represented as graphs with maximal sharing. our second implementation of the nominal unification algorithm, written in ocaml, is based on the use of termgraphs instead of terms. there is an additional complication with respect to first-order unification, in that to obtain a polynomial algorithm we also have to share subterms up to permutations of atoms. because of the additional operations on permutations, our second implementation is not linear, but we can show that these additional computations are polynomial.



the syntax of nominal terms was extended in with an operator to model name generation, and with a new kind of constraint to express locality(written a@t). extended terms have the form a.t where a is a set of local names in t, and t is a nominal term which may contain but not at the top level. we omit the unification rules dealing with and locality constraints here, although we have



the naive implementation described above is simple but inefficient. to improve it, we have changed the data structure used to represent terms and unification problems: a whole nominal unification problem will be represented as a single directed acyclic graph. in this way we obtain a polynomial algorithm. this algorithm has been implemented in ocaml(a strongly typed, strict, functional programming language, with support for imperative features and object-oriented design; see for more details). in the rest of the section we highlight the main difficulties encountered and the techniques used.



the complexity of nominal unification is still an open problem. unification of higher-order patterns, a closely related problem(see), is linear and there is therefore hope that nominal unification could also be linear. this is a challenging area for future work.



