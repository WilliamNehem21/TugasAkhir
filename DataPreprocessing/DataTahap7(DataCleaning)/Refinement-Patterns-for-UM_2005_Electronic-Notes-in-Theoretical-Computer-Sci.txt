x.ocliskindof(t) is expressible in loca as x: t for class names t. x.oclinstate(s) is expressible by x.att= s where s is a state of the state machine attached to the class, and att is an attribute which identifies the current state. c.allinstances() is expressed by the name c by itself.



a comparator operator op2 is one of=,/=,<,>,<=,>=,:,<:,/:,/<:. a logical operator op3 is one of&, or. a temporal operator is one of ax(in all next states), ex(in some next state), af(in some future state on all paths), ef(in some future state in some path), ag(in all future states on all paths) and eg(in all future states on some path). identifiers are either class names, function names, class features(attribute, operation or role names), elements of enumerated types, or represent variables or constants(if in upper case). variables are implicitly universally quantified over the entire formula. operations can also be written with parameters as op(p1,..., pn), etc.



eration names. declarative constraints define the invariant properties of the system without any bias towards particular algorithms for maintaining them, so they form a computation-independent model(cim) in mda terminology. from such models a more explicit operational model can be systematically derived, as described in this section.



uml models can be systematically transformed to refine them to forms closer to implementation on specific platforms. for example, the elimination of association classes(which are not expressible in any mainsteam oo programming language), the elimination of many-many associations(for refinement to a relational data model), etc. such transformations can be viewed as patterns.



