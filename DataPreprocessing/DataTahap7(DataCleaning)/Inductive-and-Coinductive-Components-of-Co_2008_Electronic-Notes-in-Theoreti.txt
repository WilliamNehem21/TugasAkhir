the proof assistant coq is an implementation of the calculus of inductive constructions extended with inductive and coinductive types. implementations of coinductive types were first suggested by coquand in and implemented in coq by gimenez. coq has proved to be an effective tool for working with different kinds of final coalgebras, such as the final coalgebra of streams, the final coalgebra of infinite binary trees, and some others. for instance, the machinery of coq was used to define algebraic structures on real numbers[28,38,11].



the specification language of coq makes it possible to model the types and programs of typed programming languages. typed programming languages usually provide a few basic types and a mechanism that allows the definition of inductive data types. when defining an inductive data type, we need to introduce constructors to generate the elements of the new type. a very well-known inductive data type is the type of natural numbers, defined using two constructors: 0 and s.



in coq, one can define coinductive types in the same fashion as inductive types, using a few basic constructors that are also related to destructors through the pattern-matching construct. one can also use destructors when he wants to emphasise the duality relative to inductive constructors. we will illustrate this in section 2.



which an object being defined refers to itself. functions defined over inductive types are recursive by nature. e.g., most of the functions defined on natural numbers need to be defined recursively. in section 2, we will discuss in more detail the syntax of such functions in coq.



recursive definition is such that every recursive call is performed on a structurally smaller argument. this guarantees that the recursion terminates. constructive type theory in general, and coq in particular, impose the structurally recursive condition on every defined recursive function. and thus, all functions are guaranteed to terminate in coq, as we further explain in sections 3 and 4.



already in the case of inductive types, there exists a difference between the class of functions satisfying the semantic condition of termination, and the class of functions satisfying the syntactic condition of structural recursion. it is significant that, when working with coinductive types in coq, we find the notions of productivity[24,43] and guardedness[22,31] dual to those of termination and structural recursion. this is analysed in sections 3 and 4. similarly to the inductive case, the guardedness condition bans coq formalisations for many useful productive functions. this problem was tackled(e.g.) in[1,9,29,30] for type theory and in for hol.



in sections 5 and 6, we give a general method of separating the inductive and coinductive components of productive coinductive values in coq. in particular, section 5 is devoted to the inductive component and gives general characterisation of the method of building ad-hoc predicates for formalising productive values in coq. in section 6, we characterise the coinductive component.



in this section, we will give a short exposition of how inductive and coinductive types are defined and used in coq. we will introduce several running examples. the related work of developing the theory of corecursive definitions was done in hol and mechanised using isabelle. for a more detailed introduction to coq, see.



infinite streams are not the only kind of data that is handled by coinductive machinery of coq. we can work with different types of infinite data types, such as infinite binary trees or infinite expression trees, see also. expression trees are trees in which every node has one or two children. the nodes of these trees are labelled with elements of sets a and b, and we will call them a-nodes and b-nodes, respectively. we will denote expression trees by e(a, b). the expression trees were extensively used in formalising real number arithmetic, see[38,25].



the notion of productivity was first defined in[24,43], in terms of domain theory. for a very careful domain theoretic characterisation of productivity of streams and trees, see. however, we will omit the domain theoretic definitions here, and describe productivity from a computational point of view. namely, we use recursive functions in order to define classes of productive functions in coq. we hope that this section will give the reader the opportunity to capture the spirit of a functional approach to productivity. for more on productivity of infinite data structures, see,



we call a function productive at the input value i, if it outputs a productive value at i. this understanding of productivity of functions differs slightly from the approach of[43,37,38], where a function is said to be productive if it takes productive values as an input and outputs productive values. let us explain this on the following examples.



we have discussed the reasons why termination and productivity are important for our theory, and also we showed how they relate to each other. we introduced important examples of partially productive functions. in the next section, we will discuss the way how terminative and productive functions are syntactically defined in coq.



guardedness is a sufficient condition for productivity. it is described in two steps. the first step defines pre-guarded positions. a position is pre-guarded if it occurs as the root of the function body, or if it is a direct sub-term of a pattern-



in coq, the method was implemented in[33,4], see also. the method of using accessibility predicates was improved by bove in her thesis and series of papers[14,17,16,18]. the core of the improvement proposed by bove was to separate computational and logical parts of the definitions of general recursive algorithms. that is, the method amounts to defining an inductive special-purpose accessibility(ad-hoc) predicate that characterises the inputs on which the algorithm terminates. proving that a certain function is total amounts to proving that the corresponding accessibility predicate is satisfied on every input.



the recursive call here is made under the constructor sconc, but it also appears on the argument place of the function map. the latter fact violates the guardedness condition**, and hence the function will be rejected by coq. despite of this, the value nats is known to be productive.



the conventional definitions of eventually and infinite as formalised,(e.g.) in, express whether a given stream s satisfies some given property p at least once or infinitely many times. we modify these predicates in order to characterise the conditions for a corecursive function to perform a guarded corecursive step. in this section, we consider eventually and its role in defining a recursive function which characterises the inductive component of a given corecursive function.



using the inductive definition of eventually predicates, we can describe the first component of the function we want to compute. this component is a recursive function that performs all the computations and tests that lead to the first guarded corecursive call. for lack of a better name, we will call this function the inductive component of the corecursive function being defined. separating this inductive component from the rest of the function behaviour is interesting: it will hide all the non-guarded corecursive calls and make it possible to go directly from one guarded call to the next one.



the data produced by the inductive component is organised in two parts: the first part contains the observable data that is included in the head constructor of the output. such a head constructor is necessarily present, because the eventually predicate holds and this means that there is a guarded corecursive call. the second part contains the argument for the next recursive call of the initial corecursive function.



in this section we characterise the coinductive part of corecursive functions. corecursive computations are introduced by repeating computations performed by the inductive component defined in the previous section. now, because the inductive component finds guarded corecursive call, guarded co-recursion can take place. however, this can only happen if recursive calls satisfy the eventually predicate repeatedly. we need an extra predicate to express this.



the infinite predicate describes exactly those arguments to the function for which the function is guaranteed to be productive. thus, we will reproduce the scheme already followed in recursion with respect to an ad-hoc predicate: the recursive function will be modelled in coq by a function that receives an extra argument, a proof that the initial argument satisfies the infinite predicate. computation will be performed by repeatedly calling the inductive component of the function. since the inductive component function can only compute on arguments that satisfy the eventually predicate, we need a lemma stating that the infinite predicate implies the eventually predicate. this lemma is always obtained using a very simple proof by pattern matching.



in this section, we have given a systematic characterisation of the coinductive components of productive functions. we employed the predicate infinite to obtain the guarded formalisation of productive functions in coq. it remains to provide tools to reason on the functions we modelled.



the inductive component and coinductive component for each corecursive function are modelled by coq functions which take both a regular argument(named x in the function dyn and t in the function e filter) and a proof about this argument(named h in both dyn and e filter). of course, we expect the result to depend on the regular argument, but we do not expect the computation to depend on the value of the proof. we only expect the computation to depend on the existence of this proof. in other words, when receiving a given argument x and two different proofs e1 and e2 that x satisfies the infinite dyn predicate, we expect the resulting values dyn x e1 and dyn x e2 to be the same. this needs to be expressed in



the proofs of these lemmas are given in. also, in we formulate and prove the similar proof irrelevance lemmas for filters on streams and expression trees. a similar proof irrelevance lemma was used in; a very good study of applications of the principle of proof irrelevance in type theory can be found in.



we prove the similar step-lemmas for filters on expression trees and streams in. they are all formulated uniformly with the step-lemmas above. for expression trees, for example, we need four step lemmas, to give an account both for the cases when p x is true or false, and for the two constructors used to define expression trees. conceptually, all these lemmas can be formulated in a uniform way.



in this paper, we revisited the technique developed in to model filter functions on streams in a type-theory with coinductive types and guarded corecursion. we showed that the same technique could be applied to a wide class of functions: firstly, we showed that it could be applied even if the output data-type was not a stream type, and secondly, we showed that the input data does not have to be of coinductive type. in the process, we delineated the various steps of the description and we showed that the technique can lead to the main theorem stating that the model exhibits the expected behaviour.



many of the steps in the technique we describe here can easily be automated, others are very tricky to formulate. in future work, we wish to give a precise description of the class of functions for which the technique works, and a precise description of each step that is taken in producing the eventually predicate, the first recursive component using recursion on the ad-hoc predicate eventually, etc. in the end, all the steps could be implemented as a program that takes as input the syntax tree describing the function one wants to model and produces both the coq model and the main lemmas about this model.



