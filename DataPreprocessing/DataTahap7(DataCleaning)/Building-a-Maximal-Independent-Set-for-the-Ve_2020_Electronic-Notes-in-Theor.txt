we analyze the vertex-coloring problem restricted to planar graphs and propose to consider classic wheels and polyhedral wheels as basic patterns for the planar graphs. we analyze the colorability of the composition among wheels and introduce a novel algorithm based on three rules for the vertex-coloring problem. these rules are: 1) selecting vertices in the frontier. 2) processing subsumed wheels. 3) processing centers of the



in this article, we introduce what we believe are the basic graph patterns that form any planar graph and that we have called polyhedral wheels. we consider compositions among polyhedral wheels and analyze its chromatic number. we propose a novel method to recognize the colorability for classic and polyhedral wheels.



let g=(v, e) be an undirected simple graph(i.e. finite, loop-less and without multiple edges) with vertex set v(or v(g)) and set of edges e(ore(g)). we assume the reader is familiar with standard terminology and notation concerning graph theory and planar graphs in particular, see e.g. for standard concepts in graph theory. we present here only some notations that we will use.



we extend the class of wheels by considering any polygon as an axle face of the wheel. such type of wheel is called a polyhedral wheel. this means that there are some vertices in the cycle of rx surrounding the center vertex crx, and which are not adjacent to the center. the center vertex is a common incident vertex to all the axle face of the polyhedral wheel.a polyhedral wheel of a planar graph g is represented as a cycle in its internal-face graph gf.



we will consider an acyclic graph as a tree. in the case of trees, we call node to each vertex of the tree. it is known that an acyclic graph is 2-colorable. however, considering that any vertex of an acyclic graph has restricted any color from any of the 3 colors of three, the acyclic graph is 3-colorable.



when gf is a tree, we say that g(its corresponding planar graph) is a polygonal tree. this means that, although g has cycles, all those cycles can be arranged as a tree whose nodes are polygons instead of single vertices of g. the following theorem shows that to determine an order for visiting all faces from the planar graph is enough to obtain an efficient procedure for the 3-coloring of a polygonal tree.



because all acyclic graphs are 2-colorable. a 3-coloring procedure for g can be done by traversing the nodes of gf in pre-order. the face of the father node of gf is colored first and after, the faces of its children nodes. in each current level, the two adjacent faces(father and children in g) are considered. both regions have two common extremal vertices x, y in its common boundaries.



several works have focused on recognizing 3-coloring patterns based on the length of the cycles. for example, borodin et. al[1,2] have shown the 3-colorability of planar graphs without triangles at distance less than 4 and without 5-cycles. similarly, for graphs without cycles of length from 4 to 7. on the other hand, we perform a different analysis for recognizing between the 3 or 4-colorable topologies in planar graphs. mainly, we focus on the recognition of the topologies formed by the union of polyhedral wheels in order to design a coloring algorithm.



theorem 5.4 includes the forbidden existence of k4 and any other classic wheel in the resulting graph gj. if gj is a polygonal tree, then a 3-coloring is built. otherwise, different algorithms can be proposed to build a 3-coloring for gj.



as the first part of step two, the wheels that subsume other wheels are processed(step 2a). the list of wheels rh={a, b, i, c}, ri={h, b, c}, rj={b, d, f, e, c} is generated. we can see that the wheel rh subsumes the wheel ri, so that the vertex h is selected for being colored. color(h)=1 and n(h) is marked with 1. as there



let g=(v, e) be an input planar graph, with n=|v| and m=|e|. in the first part of the algorithm, we select some of the external vertices and remove them. this process iterates until there are not more external free vertices in the current graph. in the worst case, the graph would be outerplanar(all vertices are in the external face) and we could select any of them, giving a complexity of o(n).



in the step(2a) of our algorithm, subsumed wheels are searched and processed by using special data structures that storage the components of the wheels. we have to build every cycle of the wheels, using a breadth first search procedure that has an o(m) time-complexity. afterwards, we compare a cycle of each wheel versus each other cycle of the remaining wheels, performing at most n2 comparisons in the worst case.



