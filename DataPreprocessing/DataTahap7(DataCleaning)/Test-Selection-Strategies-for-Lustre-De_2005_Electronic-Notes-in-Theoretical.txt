lustre is a specification and programming language for the description of synchronous data-flow computations(cyclic computations). it is used for reactive control/command systems, mainly for electrical power production applications. the final code may be either generated automatically or hand coded(for efficiency reasons, or in order to reuse existing code). we assume that we work in the second context, where lustre is merely used as a specification language.



after a brief presentation of lustre and the resolution procedure used in gatel, we will present these basic selection mechanisms in the rest of the paper. the first one relies on the notion of test objective, and we will take a microwave oven controller as a simple example. we then explore on the same example the technique of interactive domain splitting by exploring sub-cases of the initial constraint system. this technique is based either on predefined operator sub-cases or user-defined integration scenarios.



lustre belongs to the synchronous data-flow language family. it was developed at the grenoble imag institute. lustre is not just another academic language but is effectively used in industry due to its numerous advantages(e.g. schneider electric, aerospatiale). it provides both a textual and a graphical notation, the latter being similar to those used in hardware design(block diagrams, operators net, etc.).



reaction is described with four inputs and three outputs. the boolean input data flows start and abort correspond respectively to the start and abort buttons of the oven, they are true when the user pushes the corresponding button. the input open is set by a sensor on the oven door, it is true while the door remains open. the input duration is the cooking duration in seconds programmed by the user. the output parameter remaining_time is the remaining time(in seconds) until the end of cooking which is displayed on the screen of the oven. the boolean output cooking is connected to a symbol highlighted on the screen when cooking is in progress. finally, the bell parameter triggers the ringing of a bell when cooking is finished or aborted.



invariant properties can be stated with the assert directive, which operates on a boolean expression that must be satisfied at each cycle. let us come back to the above example. it can be extended with the assertion given below. this assertion states that the oven is never started and aborted in the same cycle.



gatel efficiency relies on several specialized heuristics, for the choice of the variable to be instantiated during the labelling steps or consistency checking during propagation. classically, the chosen variable must awake the maximal number of constraints, while minimizing the average branching of the resolution tree(variable with the smallest domain). to facilitate this choice, the global constraint system is structured into smaller independent ones according to constraint dependencies. consistency checks rely on the usual arcconsistency refined with refutation mechanisms for boolean constraints, and abstraction of constraint relationships for integer ones. for a more complete description of our tool, please refer to.



the specification of the environment contains assertions about current/past inputs and possibly about past outputs(since the program under test reacts with its environment). the point here is to filter out from all the possible behavior of the model the behaviors corresponding to realistic reactions. each statement should thus be carefully checked. moreover, since several assertions may involve the same variables, the consistency of the model gets harder to ensure as it gets larger. in order to check an environment specification the model can be animated using simple random simulations for a limited number of cycles. at each cycle, assertions coming from the environment are introduced as constraints on input values, which are then randomly instantiated inside their restricted domain so that the computed outputs also remain within valid domains. indeed, for integer variables this computation could lead to values outside the authorized bounds so it is controlled by a formal integer interval arithmetic.



there are two different ways to describe test cases in gatel. the first one relies on an interactive unfolding of lustre operators of the current constraint system. in this case, test cases are defined by a structural decomposition of the initial constraint system. this method allows a fine grained coverage of lustre expressions, and thus is best used within unit testing. the second one uses predefined functional scenarios attached to variables. a scenario can be seen as a high level splitting method, since the user identifies which parts of the domain to explore, only exhibiting particular instances of behavior among all possible ones. this method can be used during the integration phase, since scenarios may involve the composition of several nodes.



the initial constraint system is built from assertions at each known cycle, from properties occurring in reach directives at the last cycle, and from necessary data flow variables definitions. this system characterizes a domain of validity of the uniformity hypotheses. we propose a splitting technique of this domain adapted from the unfolding technique of the tool loft. it makes it possible to recursively split sub-domains according to predefined sub-cases of lustre operators.



at each unfolding step, gatel shows the operators that can be unfolded(top-level operators of an expression whose evaluation is needed). thus, the user can interactively and dynamically tune the kind and number of subdomains. furthermore, domain splitting can be applied to the constraints system defining an output chosen by the user. in this case, unfolding builds the path predicates of the selected output at an arbitrary cycle. in this way in a selection of unfoldable operators from the lustre definition of"active" variables(whose definition has already been propagated). several operators can be selected at each step, each operator can be unfoldable at several cycles and in several cases. since all values were set at cycle 0, no further operator can be selected for this final cycle. however, the upper-most-> of the definition



unfolding is a simple answer to the need of splitting the domain of a test objective. however for methodological reasons this process may not be applicable on complex examples. when the decomposition sought implies several variables at several cycles, the choice of the right operator to unfold may become harder. this is also the case even on simpler decompositions, when many operators are unfoldable. moreover, as we saw on the above example, the splitting process may create auxiliary test cases which complicate the ex-



the handling of real and floating point numbers in gatel is still being studied. this point introduces difficulties of various sorts. the kernel has to be extended so as to manage constraints on these new types.(a french national research action, v3f is focused on the design of a constraint solver for floating point number arithmetic.) moreover, these data types introduce observability problems for the oracle step: computation accuracy may change outputs at any cycle, and may cause some temporal shifts(e.g.: comparisons of floating-point numbers as timing parameters).



