the#(hash) component model has been proposed to bring the advantages of a component-based perspective of software for the development of high performance computing applications, targeting computer architectures enabled for grid, cluster and capability computing. in simple terms, it is a component model for general purpose parallel programming targeting distributed architectures. this paper presents an institutional theory for#-components, which has originated the idea of introducing parameterized and recursive abstract component types in# programming systems, making possible a general notion of skeletal programming.



the current trend of parallelism support in components infrastructures has been to encapsulate parallel synchronization inside components, sometimes introducing a minimal set of orthogonal extensions at the coordination level to enable parallel execution. thus, parallelism is not fully treated as a coordination level concern, as expected. such approach is influenced by the common trend of taking processes as units of software decomposition in the same dimension of concerns, thus making software engineering disciplines too hard to be applied to parallel programming. processes and concerns must be placed at orthogonal dimensions of software decomposition. the# component model takes the hypothesis of orthogonality as a premise, proposing an alternative for component based parallel programming, inspired in the coordination model of haskell#, a parallel extension to the functional language haskell. most possibly, any component model and parallel programming artifact may be interpreted in terms of the# component model.



this paper introduces an institutional theory for#-components, which has provided valuable insights about abstraction mechanisms that could be supported by# compliant programming systems. in fact, it has suggested that#-components may be categorized by component classes represented by recursive component types, with support to polymorphism based on universal and existential bounded quantification. a generalized use of skeletal programming, a promising approach for promoting abstraction in parallel programming, has been made possible from such perspective. a basic background in category theory and petri nets is recommended for readers of this paper.



section 2 introduces the basic principles behind the# component model. section 3 includes the formalization of the# component model using theory of institutions. section 4 concludes this paper, describing ongoing and lines for further works regarding formalization, specification, and verification of#-components.



orthogonal concepts. without any loss of generality, aiming at clarifying the intuitions behind the enunciated orthogonality hypothesis, let p be an arbitrary parallel program formed by a set of processes that synchronize through message-passing. each process may be split into a set of slices, each one related to a concern. in



c. the reader must be convinced that the concrete interpretation of a unit is abstract at the perspective of the# component model, since it may correspond to slices of any nature, covering functional and some kinds of non-functional concerns. the units of overlapped#-components are combined to form the units of the#component being composed. let u be a unit. the units that are combined to



the# component model goes far beyond the idea of raising connectors to the status of first-class citizens[36,39], by promoting them to components, leading to uniformity of concepts. for example, a communication channel could be implemented as a#-component channel. fractal also supports connectors as components through composite bindings, but primitive bindings are not yet components. the# connectors are exogenous, like in p-com, while they are endogenous in cca and fractal.



since the# component model is mainly focused on separation of concerns that cross cut the processes of a parallel program, the reader may consider it helpful to understand the relation between modularity in# programming and modularity in some recently proposed artifacts for separation of cross-cutting concerns in software, such as aspects, hyperspaces, features, and so on. for instance, aspects may be encapsulated in#-components. in this perspective, joinpoints are the execution points before, after, and around activation of slices in protocols. advices correspond to the interleaving of activations of slices from#-aspects(aspect slices) with other slices in protocols. weaving is related to the process of composition of a parallel program from the overlapping composition of a set of#-components that represent components, in the usual sense, and aspects. however, modularity in# programming is closer to mechanisms of multi-dimensional separation of concerns, where hyperspaces and features are included. in fact, a hyperslice that cross cuts a set of classes is like a#-component that cross cuts a set of processes, in such a way that a unit of a hyperslice corresponds to a unit of a#-component. the combination of hyperslices to form hypermodules is captured by overlapping composition of#-components, where hyperslices and hypermodules are both viewed as#-components. the relation of features with aspects and hyperspaces have been detailed studied in. features are closer to hyperspaces, by making refinements correspondent to hyperslices. transitively, it is easy to see the relation between features and#-components. also, the idea of synthesizing efficient programs that meet some specification by looking for the best implementation of features has a clear relation to the idea of skeletal programming through existential polymorphism with component types in# programming.



this paper presented an institutional theory for#-components. besides to provide important insights on the nature of#-components and to allow proving important properties about them, such approach has also the advantage of introducing abstraction mechanisms from algebraic specification and type theory into# programming systems. for instance, this leads to the idea of supporting skeletal programming using recursive polymorphic component types.



work on progress address some pragmatic issues regarding the implementation of type systems for#-components, such as decidability and generality issues that always rise when talking about type systems supporting bounded quantification. besides that, it is intended to extend the institutional framework presented in this paper to deal with specific kinds of concerns. as discussed along the paper, the current approach abstracts from the nature of concerns addressed by#-components. for example, a simple approach to support functional concerns could be to enrich the specification of units of functional component types with pre-conditions, postconditions, and invariants, trying to apply specification matching techniques for verification of combination of units in the overlapped composition of#-components. such approach suggests the application of notions of behavioral subtyping onto component type systems.



