we propose a more compositional method of building verification condition generators, using ideas from monadic denotational semantics and from generic programming. our technique allows us to extend an existing verification condition generator to handle new language constructs, but also to add extensions at another level, such as the ability to generate validation traces. we explain the technique through an example, extending a simple while language with a construct for exception handling. this construct not only needs an extension to the logic, but also a change of its structure.



development and maintenance of implementations of realistic programming logics is known to be hard. there are few methods of dealing with the changes that are incurred by changing the language or the addition of features. implementing these changes is a dangerous and error prone process that can easily introduce inconsistencies in the logic.



code of the existing implementation of a logic. our approach has several advantages. first and foremost is the advantage that it is safer. second, it allows enabling and disabling alterations at will. thus we can always fall back on the existing implementation. third, it enables us to easily create a set of related partial logics, each of which can be used separately for light weight verification.



our technique uses ideas from generic programming and monadic denotational semantics to represent a syntax driven logic. generic programming abstracts from algebraic datatypes, and these techniques can thus be used to abstract from the actual implementation of the abstract syntax used to represent programs. the main use we make is that of a generic fold, encapsulating the recursion over the datatype, which we assume to be easily specified. this allows us to decouple the recursion scheme from the calculation of the semantics.



monadic denotational semantics has been introduced as a method of separating concerns in denotational semantics[11,1]. the key idea is to choose an abstraction for the domain of the semantics such that different computations in that domain can be combined in a standard fashion. by relying on that combination method, independence of the domain is achieved. thus, given a monadic domain, we can hide those aspects that do not affect a specific part of the logic. this allows us to keep the code of the base logic unchanged despite adding to the underlying structure, which normally affects the implementation of each rule in the logic.



although straightforward, such code is not easily changed. turning it into an explicit algebra over the provided algebraic data type makes changes easier. the way to implement the algebra as a fold over the abstract syntax can be easily seen: it involves making a separate function for each alternative in the datatype representing the abstract syntax, and passing those functions as arguments to the fold. the set of passed functions clearly specifies an algebra over the language, with the nonterminals in the language being the sorts, and the alternatives inducing the operations. applying the generic fold gives us the unique homomorphism between the initial algebra and the algebra specified.



although this works, it involves replacing the entire monad upon changes. much nicer would be the ability to just add aspects to the existing monad. traditional approaches of combining monads are the use of distributive laws over monads or the use of monad transformers[4,10]. we have chosen to use another approach, that of monadic coproducts, as described by luth and ghani.



the problem that remains is that of choosing a monad r that we map the operations on record and poste to. this monad r is the essential domain of the semantics. in this case we can use a general state carrying monad, with as state a tuple of expressions and an expression, that is state([ expr], expr). this monad has functions get and put, where get extracts the state from the monad, and put takes the state and puts it back under a monad over the unit type. their



given this implementation method for verification condition generators, several research paths remain. not only do we want a more compositional way of implementing a verification condition generator, we also want to formally verify said generator, as for example homeier and martin described. one hypothesis we have investigated is that our approach makes it possible to not only reuse existing code, but also to reuse proofs so that proving e.g. soundness for a changed verification condition generator need not be done from scratch. this does indeed seem possible for a simple language, given more care in constructing the underlying monad than exposed in section 4. the question remains if this scales to languages with function abstraction and application.



