two users u1 and u2. suppose that u1 modifies file a into b by committing a patch f, which is then imported by u2, and then u1 and u2 concurrently modify the file b into c(resp. d) by committing a patch g(resp. h). the evolution of the file is depicted on the left and the partial ordering of patches in the middle:



however, as expected, not every pair of coinitial morphisms have a pushout in the category l: this reflects the fact that two patches can be conflicting(for instance if two users modify the same line of a file). representing and handling such conflicts in a coherent way is one of the most difficult part of implementing a vcs(as witnessed for instance by the various proposals for darcs: mergers, conflictors, graphictors, etc.). in order to be able to have a representation for all conflicting files, we investigate the free completion of the category l under all pushouts, this category being denoted p, which corresponds to adding all conflicting files to the category, in the most general way as possible. this category can easily be shown to exist for general abstract reasons, and one of the main contributions of this work is to provide an explicit description by applying the theory of presheaves. this approach paves the way towards the implementation of a vcs whose correctness is deduced from universal categorical properties.



tion 2. then, in section 3, we abstractly define the category p of conflicting files obtained by free finite cocompletion. section 4 provides a concrete description of the construction in the simpler case where patches can only insert lines. we give some concrete examples in section 5 and adapt the framework to the general case in section 6. we conclude in section 7.



in order to increase readability, we shall consider the particular case where l is reduced to a single element. in this unlabeled case, the objects of l can be identified with integers(the labeling function is trivial), and proposition 2.2 can be adapted to achieve the following description of the category, see also.



in order to represent the state of files after applying two conflicting patches, we investigate the definition of a category p which is obtained by completing the category l under all pushouts. since, this completion should also contain an initial object(i.e. the empty file), we are actually defining the category p as the free completion of l under finite colimits: recall that a category is finitely cocomplete(has all finite colimits) if and only if it has an initial object and is closed under which would intuitively model the pushout of the diagram(3) if it existed, indicating that the user has to choose between c and d for the second line. notice the similarities with the corresponding textual notation in git on the right. the name of the category l reflects the facts that its objects are files whose lines are linearly ordered, whereas the objects of p can be thought as files whose lines are only partially ordered. more formally, the category is defined as follows.



is preserved by presheaves in p(which corresponds to adding an edge between vertices at the source and target of a non-empty path), it is enough to show that presheaves in p preserve diagrams generated by graphs gn. this follows again by proposition 4.3, see(6). 2



in this paper, we have detailed how we could derive from universal constructions a category which suitably models files resulting from conflicting modifications. it is finitely cocomplete, thus the merging of any modifications of the file is well-defined. we believe that the interest of our methodology lies in the fact that it adapts easily to other more complicated base categories l than the two investigated here: in future works, we should explain how to extend the model in order to cope with multiple files(which can be moved, deleted, etc.), different file types(containing text, or more structured data such as xml trees). also, the structure of repositories(partially ordered sets of patches) is naturally modeled by event structures labeled by morphisms in p, which will be detailed in future works, as well as how to that the right adjoint is full and faithful if and only if the counit is an isomorphism, which is a classical theorem[6, theorem iv.3.1]. the construction can be adapted to the general case where d is not necessarily cocomplete by considering



