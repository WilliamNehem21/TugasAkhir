this paper demonstrates an embedding of the semantic models of the ccsp process algebra in the general purpose theorem prover pvs. ccsp is a language designed to model long-running business transactions with constructs for orchestration of compensations. the ccsp process algebra terms are defined in pvs by using mutually recursive datatype. the trace and the operational semantics of the algebra are embedded in pvs. we show how these semantic embeddings are used to define and prove a relationship between the semantic models by using the powerful induction mechanism of pvs.



compensating csp(ccsp) is a language designed to model long-running business transactions within the framework of standard csp process algebra. business transactions typically involve multiple partners coordinating and interacting with each other. compensation is defined in as an action taken to recover from error in business transactions, particularly, in long-running transactions. ccsp provides constructs for orchestration of compensations to model business transactions. a formal semantics offers a complete, and rigorous definition of a language.



subtle mistakes, or omissions can easily occur at any stage of such proofs. a tool that allows mechanising the semantic models, and supports mechanically proving the relationship between the semantic models can overcome the problems in the hand proofs. an interactive and automatic theorem prover that successfully mechanise our proofs, demonstrates the correctness of our proofs, and a feasible mechanisation allows us to follow the same mechanical proof technique to apply to larger proofs. to address our problem, presently, there are several systems, such as, pvs, hol, isabelle, and coq, having a rich specification language and automated support for decision procedures, and proof strategies to their logic. pvs is an automated framework for specification and verification. pvs supports high-order logic, allows abstract datatypes to model process terms, and has a strong support for induction mechanism. pvs supports interactive proof checking, where the user applies proof commands to simplify the goal to be proved, until it can be proved automatically by its decision procedure. several research, such as[4,8,9], have been carried out in order to mechanise process algebras by using pvs, where an acp-style process algebra has been mechanised in, and the trace semantics of standard csp has been mechanised in[8,9]. the ccsp semantic models are closely related to that of standard csp, and given the positive experience described in[8,9], we have decided to use pvs in our experiments. most of the existing works in pvs are aimed at concrete applications, and very few of them are focused in the theoretical issues, especially, process algebra terms and semantic models. to the best of our knowledge, it is the first attempt to mechanise both the operational,



after giving a brief overview of the ccsp language, we outline the definitions of the traces, and the operational semantics. we briefly describe how a relationship is defined between the two semantic models, and how they are proved by hand. we then describe the embedding of ccsp in pvs. the process algebra terms are defined by using a mutually recursive datatype. the traces are defined by following the original semantic definitions. a recursive definition is given to define the operational semantics that plays a vital role in the proofs. we define several supporting lemmas and mechanise them to prove the relationship between the semantic models. the lemmas are proved by applying induction and the proof steps follow similar level of granularity as in the hand proofs.



we have adopted a systematic approach to derive a relationship between the semantic models. first, traces are extracted(derived trace) from the transition rules of the operational semantics. then, a correspondence is established between the extracted traces with the originally defined traces.



a way to combine the strength of general purpose theorem provers with formal notations is the semantic embedding of the formal notations within the logic of the verification systems. an embedding is a semantic encoding of one specification language into another, especially, to reuse the existing tools of the target language. there are two main variants of semantic embedding: deep and shallow embedding. in a deep embedding, the language and the semantics of the method



the traces of ccsp are defined in pvs by following the original trace definition, as a pair consisting of a list of normal event, and a terminal event. the definition ensures that traces are non-empty(at least there is a terminal event when the list is empty). compensable traces are defined as pair of standard traces. processes are defined as a set of traces.



proofs about properties of a process algebra often use induction on the structure of the algebra, which is no exception in our case. pvs has a datatype called abstract datatype, for which pvs generated an induction scheme, and it is convenient to model process algebra terms as an abstract datatype. pvs provides mechanism to define abstract datatype of certain class, which includes all of the tree-like recursive data structure that are freely generated by a number of constructor operators(detailed discussion in).



the trace semantics are defined in pvs in the same way as they are originally defined. operators are first defined at the trace level, and then lift to the sets of traces to define the processes. the same approach is taken for both standard, and compensable processes. within the limited scope in this paper, we outline the trace definitions of only a few operators. other operators are defined by following a similar approach.



we have outlined an approach to mechanise the ccsp semantic models, and proved their relationship by using the automated theorem prover pvs. we have embedded the semantic models in pvs by using its existing logics and theories. we have defined the operators in terms of their semantic models, and laws of these operators can be proved from these semantic definitions, which helped to avoid the approach of directly encoding the laws as axioms, because it would introduce inconsistencies in the logic. the inductive proofs have followed similar steps as the steps in the hand proofs, and it has given us confidence in our language definitions. the general philosophy behind the works in[1,7,12], and ours is similar, where the work is aimed at providing an environment, where proofs about the algebra can be done in a similar level of granularity as in the hand proofs. although defining process



it is easy to be imprecise about recursion, and typing of the rules in the informal proofs(by hand). the mechanisation has forced us to be strict about datatypes, and recursion. this helped us to define the theorems, and the lemmas in a systematic way as well as to prove all the lemmas by following a similar fashion. the mechanisation has helped us identifying some lemmas, which were not explored in the hand proofs. the mechanisation also deepen our understanding of the semantic models for both standard and compensable processes.



we have avoided describing the semantics, and the mechanisation of synchronous composition of processes(p x q). a separate description is needed for its definitions. we need to extend both the trace, and the operational semantics as well as the process algebra terms to define synchronisation. in synchronous composition,



we have taken a subset of the original ccsp language in our experiment. it is our future plan to extend the current experiments to include the other operators, and define the semantic relationship for them. we are also investigating to model business transactions in order to experiment the expressiveness of the language, and to improve the language features.



