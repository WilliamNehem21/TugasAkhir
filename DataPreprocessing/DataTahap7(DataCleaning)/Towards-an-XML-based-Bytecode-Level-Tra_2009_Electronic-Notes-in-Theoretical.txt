programs to manipulate virtual machine bytecode are becoming more prevalent. bat2xml uses xml to represent java bytecode in order to take advantage of supporting xml technologies for processing and manipulation. one of the features of bat2xml allows for the easy injection and extraction of java bytecode. this means that the bytecode can be analyzed and then optimized. bat2xml is only able to represent java bytecode, however, and has no provisions for clr bytecode.



the approach taken in this paper is to make extensive use of xml technologies in order to provide a framework for generic bytecode manipulation. we use xml in order to provide a representation of bytecode that is a superset of stack-based machine languages. this allows for the easy manipulation of bytecode, and we demonstrate this with a cross-compilation example that uses xsl stylesheets for translating clr bytecode instructions to the jvm. xsl stylesheets allow for a declarative methodology when performing this transformation.



ultimately, this paper is a showcase for the power of xml technologies and declarative programming for a non-trivial application. the outline of this paper is as follows: in section 2 we present xmlvm, our xml-based representation of bytecode instructions. section 3 gives an overview of the jvm and the clr while focusing on their differences. based on xmlvm, we show in section 4 how to crosscompile bytecode instructions using xsl stylesheets. section 5 presents conclusions and outlook for future work.



the most interesting part of the above xmlvm program is the actual implementation of method main, which lies in between the tags<code> and</code>. since the bytecode instructions belong to the clr, the respective xmlvm instructions are placed in the xml namespace denoted by the prefix clr. the<clr:var>(variable) tag declares a variable with respective type that can be addressed by a given index. instruction<clr:ldc>(load constant) pushes a constant referred to by attribute value onto the stack.



the stack and pushes their sum back onto the stack. the<clr:call> instruction invokes the method system.console.writeline(). the false value of attribute has-this indicates that writeline() is a static method, because it does not require a this reference. note that the actual parameters have been removed by the



the aforementioned<clr:add> instruction gives no indication as to the type of the operands. in this particular example, the<clr:add> instruction will compute the sum of two integers, since the two top elements of the stack are of type integer. the same<clr:add> instruction would have been used if two floating point values had been added. the clr states that the virtual machine has to determine the correct type through some mechanism. this could be accomplished by either a static data flow analysis of the program or by maintaining a type-stack at runtime. the<clr:add> instruction does not check for overflow. if an overflow occurs, only the least significant bytes of that type are considered for the sum of the arguments. if the c# program above had computed the sum using the expression checked((int)(a+ b)), it would have resulted in the byte code instruction



as with any high-level programming language, the languages based on the jvm and the clr both define a set of primitive types such as bytes, integers, or doubles. furthermore, both execution platforms define various bytecode instructions such as addition or subtraction that operate on these primitive types. we first discuss the different data models of the jvm and the clr and then introduce the bytecode instructions.



the jvm supports numerical types of various sizes and precisions. in the following we focus on integer types. based on the java programming language, the jvm supports four different integer types, ranging from 8 to 64 bit precision. one interesting fact is that the jvm(and therefore java) only supports signed integers. i.e., there is no built-in support for unsigned integer types. as with the jvm, the clr also supports integer types of various precisions. one important difference however is that the clr supports both signed and unsigned integer types.



it is interesting to note that the description for the add instruction only specifies the addition of two signed integers. there is no mention of unsigned integers. how can it be possible, then, that the clr supports the basic addition of unsigned integers? it turns out that the clr imposes a constraint somewhat similar to that of the jvm for items placed upon its evaluation stack. only signed 32 bit and 64 bit integers can be loaded onto the stack. unsigned types are simply sign-extended and treated as signed types when loaded onto the stack. the clr then takes advantage of the fact that, for some operations, signed and unsigned integers do not need to be



based on this examination, we can see that there are several significant differences between the jvm and clr with respect to their support of integer types. this complicates the efforts involved with cross-compilation. to translate bytecode from the clr to the jvm, for example, the cross-compilation process must at least provide support for unsigned integers, use the appropriate bytecode instructions for different data types, and check for overflow by throwing a runtime exception when an overflow occurs.



the clr introduces the notion of value types. value types are similar to classes, but their instances are allocated on the stack. instances of classes(i.e., objects) are usually allocated on the heap and are garbage collected when not used anymore. garbage collection introduces significant runtime overhead. however, since value types are allocated on the stack, they will be automatically reclaimed when the method where they were defined is exited. for this reason, the underlying behavior of value types in the clr differs from that of classes. this is demonstrated by the following c# program:



the preceding section outlined some differences between the clr and the jvm. the clr is a superset of the jvm in many ways, which is underlined by the fact that the clr supports more primitive types as well as features additional bytecode instructions not found in the jvm. therefore, it is relatively straightforward to map a jvm program to the clr. there already exists at least one project that implements this direction of the transformation.



traced, but instead of pushing and popping specific arguments onto the stack, only the types of those arguments are stored on the stack. for this reason it is also called a type stack(vs. an argument stack). with this analysis, it is possible to determine the type of the arguments that will be stored on the stack at any point during the execution of the program.



the dfa for this instruction can only be computed once the<stack-post> of the preceding instruction has been determined. this condition is given by the xpath expression of the match attribute(line 1). the first<copy-of> copies all attributes to the result tree via the@* expression(line 3). next, the template defines the type stack before the instruction executes via the<stack-pre> tag. the state of the type stack at this point is identical with the<stack-post> of the previous instruction. therefore, the xpath expression of the second<copy-of> selects the<clr:add ovf> and<clr:add ovf un>) during addition are two such cases. in order to map those clr instructions to the jvm, it is necessary to introduce a compatibility library that mimics the semantics of the original clr instruction. as an example, consider the clr instruction<clr:add ovf> discussed earlier. since the jvm does not offer a single bytecode instruction with the same semantics, the



since the jvm has no support for value types, they have to be simulated while retaining the semantics as defined by the clr. the easiest approach is to convert value types to heap-allocated objects. if value types are mapped to objects, they need to be allocated via<clr:newobj>. special care has to be taken when copying value types. the<clr:ldloc> and<clr:stloc> copy references for objects, while performing a deep copy for value types. in this case, the data flow analysis again helps to map these bytecode instructions to proper jvm instructions. since a deep copy cannot be performed with a single bytecode instruction, we generate a call to a compatibility library that implements this behavior. each value type inherits directly or indirectly from class system.valuetype. we add a static method copy to this class that performs the deep copy using the java reflection api. here is the declaration of this method:



the<clr:stloc> instruction expects the value type to be stored on the stack. since we treat all value types as objects, this value type will be represented as a reference. the destination(also represented as a reference) is pushed onto the stack via<jvm:aload> before making a call into the compatibility library. the signature of method copy is chosen such that it matches the stack layout at this point in time.



cross-compiling clr bytecode instructions to jvm bytecode instructions does not solve the problem of external libraries referenced by the application. e.g., if a c# application uses winforms to create a button on a user interface, it will reference class system.windows.forms.button. cross-compiling bytecode instructions would result in a java class file having an external reference to this class that does



changing class names and method names is the essence of api mapping. when used together with api wrapping, the cross-compiled java application behaves identically to its original clr version. the above xsl template demonstrates the full potential of declarative xpath expression to filter out the desired api.



