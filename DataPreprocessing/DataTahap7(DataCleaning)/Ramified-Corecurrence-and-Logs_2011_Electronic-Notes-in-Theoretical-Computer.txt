implicit computational complexity(icc) deals with intrinsic properties of complexity classes, properties that do not refer directly to machine-based resources, such as computation time or space. that is, one matches complexity measures defined in terms of machine models resources, such as time and space, with declarative paradigms that are restricted along functionality, linearity, repetitions, flow control, or similar parameters. the benefits and potential applications of this research are well known(see e.g.[3,14]). of particular practical interest is the characterization of computational complexity classes by restricted but natural declarative programming languages, since such languages guarantee complexity bounds automatically.



turing transducers over streams can simulate turing transducers for functionals(i.e. with functions as oracles), if their work-tapes are unrestricted. however, crucial differences surface when resources are considered, and when the real-time sequentiality of stream transducer contrasts with the random access underlying oracle turing-machines.



it is reasonable to consider a variant of turing transducers where the output tape is two-way, with the cursor possibly revisiting an earlier output symbol. but for logspace transducers such an extension makes no difference: using additional work-tapes we can track the intended positions of cursors, and then recalculate the output symbols at such positions. the space used for each such calculation is immediately released at its end, so the entire process is still in log-space.



proof. by proposition 2.3, it suffices to show that 2-way cursors on a finite counter can be simulated by cursors that can be reset, and that 2-way cursors on a global counter can be simulated by cursors that can be jumped to the position of other cursors.



(c) step c and cj in tandem, until cj reaches the end of the tape. thus c and cj both scan the entire finite work-tape once, with c lagging by one step, i.e. ending at a position preceding its initial one.



we show in proposition 4.5 below that every 2-tier ramified lazy-corecursive function between finite streams is logspace in the usual sense, i.e. in the size of the input. but e maps(1n, 1n) to a stream of length 2n, so e is not ramified lazycorecursive, let alone ramified strict-corecursive.



a natural question is to relate output-based complexity for finite streams with input-based complexity for functions over words. when the input itself is finite, it makes little sense to posit an extra input 1n. we therefore dispense in this context of the extra input 1n, and use the finite input instead.



while-programs over lists, without recursion nor use of the cons function. kristiansen gives a characterization based on a simple recursion scheme that does not use cons. bonfante uses tail recursion(which bears structural similarity to corecursion), using tiering to limit branching.



