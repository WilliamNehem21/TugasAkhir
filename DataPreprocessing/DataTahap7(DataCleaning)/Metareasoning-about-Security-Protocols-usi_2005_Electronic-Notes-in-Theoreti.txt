our starting point is the distributed temporal logic dtl of, which focuses on the expressibility of properties from the local point of view of each agent, and which we extend in order to also express global properties. aside from its clean interpretation structures, which provide a simple, intuitive model of distributed systems, our reasons for using this logic are primarily threefold. first, it is well-suited for specifying and reasoning about communicating agents in distributed systems. second, its temporal dimension can be effectively used to formalize and reason about interleaved protocol executions. finally, its distributed dimension, with explicit agent identifiers, supports an elegant formalization of the different security goals that protocols are supposed to achieve, such as different forms of authentication and secrecy.



the logic we introduce here provides an object level tool where we can specify and reason about specific protocols and the properties that the protocols are supposed to establish. in particular, as we describe in[3,4], using the logic it is possible to specify a protocol-independent distributed communication model, on top of which protocols can be formally defined and analyzed. the principal aim of our work, however, is not the mere ad hoc analysis of specific protocols. rather, our long-term objective is to use our logic as a metalevel tool for the comparative analysis of security protocol models and properties. our logic provides a basis to rigorously investigate general metalevel properties of different protocol models by establishing modeling and analysis simplification techniques that contribute to the sound design of effective protocol validation tools. in this regard, we believe that our logic can contribute to clarifying the concepts involved by providing a basis for naturally representing and reasoning about the underlying computational models.



we anticipate several applications. the most direct consists of a rigorous account of different widely used simplification techniques, as we discuss in this paper. we prove here a general lemma about secret data that is similar to the secrecy theorems of[7,12]. we also obtain soundness and completeness results, with respect to typical security goals, for two model-simplification techniques: one intruder is enough, along the lines of, and the predatory intruder, a restriction on the behavior of the intruder, variants of which underly the trace models used in practice, e.g.. while these results, mutatis mutandis, have



we have also begun applying our logic to other metatheoretical investigations, such as developing appropriate partial-order techniques that may reduce the(potentially infinite) state-space exploration involved in model-checking protocol properties(cf.). this is work in progress and the first results are promising.



the model could, of course, be extended in many ways. for example, we could include other kinds of message constructors(e.g. for hashing and exponentiation), or further actions and state propositions. we will consider such extensions in future work, where we will also include servers and further channels with distinct accessibility and reliability properties. for now, however, the above is enough to abstractly formalize and reason about the properties of communication between principals executing security protocols.



to b', then the message synchronously arrives at the channel, where it is stored for future delivery to b. if delivery ever happens, it must be synchronized with the corresponding receive action of b. however, the principal a can only send m to b' if a knows both the name b' and how to produce the message m. as usual, the knowledge of principals is not static. in addition to their initial knowledge, principals gain knowledge from the messages they receive and the fresh nonces they generate. principals may also spy on messages being leaked



in this notation, a and b are variables of sort name that denote the roles played in one execution of the protocol, and n1 and n2 are variables of sort nonce. the arrows represent communication from the sender to the receiver. the parenthesized nonces prefixing the first and second messages signify that these nonces must be freshly generated before the message is sent. moreover, it is assumed that public and private keys have been generated and appropriately distributed: ka represents the public key of a, whose inverse key should be private, i.e. known by no one but the principal using that name. although other possibilities, such as shared keys, could be easily added to the model, we refrain from doing so here, for simplicity, and assume that these are the only existing keys.



in this section, we give three substantial examples of formally reasoning about simplification techniques for protocol models. these examples are interesting in their own right. moreover, they also illustrate how our approach can help to clarify a number of underlying concepts that are often left implicit, or neglected, when considering such simplifications within other approaches.



note that the set msg\ msgs of s-insecure messages forms precisely what has been called an ideal in the context of strand spaces, whereas the set msgs of s-secure messages is the corresponding coideal, in the terminology of[7,12]. in fact, lemma 5.1 is a general result about the flow of data in the network, which is independent of protocols. the result can of course be used to reason about secrecy properties in protocol models, providing a result that is very similar to those found in[7,12]. indeed, under reasonable conditions, the secrecy of generated nonces can be easily seen to hold.



communication and distribution are the essential ingredients of protocols. these are the main concepts underlying our logic. through the choice of different signatures and axioms, we can define theories for formalizing and reasoning about different application domains, as shown here in the case of security protocol models and their properties. it is worth noting in this regard that many of the problems with security protocols arise out of problems with communication, as opposed to problems with the underlying cryptographic algorithms(which are abstracted away with the black-box, perfect cryptography approach). while some of the results presented here, mutatis mutandis, have already been shown using other formalisms, our logic provides a means



event structures, which are the underlying models of our logic, are comparable with strand spaces, as explained in. a comparison to other formalisms for reasoning about communicating processes can be found in. it is worth emphasizing some of the advantages of our approach. to begin with, our approach provides not just a language for describing models(as in process algebras, for example) but also a logic for reasoning about them. reasoning about local temporal properties of agents in a distributed system could also be performed in a linear temporal logic over linearizations of the distributed models. however, this would come at the price of readability and simplicity, as the locality dimension is lost. in contrast, our distributed logic is simple and robust in the sense that formulas are invariant with respect to different linearizations. we have taken advantage of this in the proofs of both the one-intruder and the predatory intruder reductions.



we have begun applying our logic to other metatheoretical investigations, such as developing appropriate partial-order techniques that may reduce the(potentially infinite) state-space exploration involved in model-checking protocol properties(cf.). this is work in progress and the first results are promising. further work is the application of our logic for reasoning about protocol composition, as well as the development of a calculus for the logic.



