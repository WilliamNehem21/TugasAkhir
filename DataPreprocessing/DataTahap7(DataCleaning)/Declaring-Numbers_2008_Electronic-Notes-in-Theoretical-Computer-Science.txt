implementations of functional and functional logic languages usually provide numbers as an external data type and reuse the default implementation of the underlying language(e.g. c) for the implementation of operation like(+),(-),(<=),(==). this provides a very efficient implementation of complex arithmetic computations within the high-level language.



however, in the context of functional logic languages, this approach results in a major drawback: numbers cannot be guessed by means of narrowing. semantic extensions, like residuation[4,5], allow the user to use some restricted logical features in combination with numbers. the idea is that all(externally defined) functions on numbers suspend on unbound free variables. these residuating functions have to be combined with a generator which specifies all possible values of a free variable. as an example, we consider pythagorean triples(a, b, c) with a2+ b2= c2. this



first, the search tests whether a combination of a, b and c is a pythagorean triple. since pakcs cannot guess natural numbers this test is suspended by means of residuation for external functions(+) and(*). now the programmer has to add good generator functions which efficiently enumerate the search space.



note, that we obtain a partial function, since we did not define a peano representation of negative numbers. by means of narrowing, a solution for the constraint add r m=:= n generates a binding for r. this binding is the result of sub.



termination: because of laziness, our functions are normally also defined on infinite numbers. therefore, we distinguish two categories of termination. in this section these categories only apply to deterministic expressions. considerations with respect to narrowing will follow in section 3.



hnf-termination: we call an expression hnf-terminating iff it evaluates to a head normal form of arbitrary depth in finitely many steps. repeat true 3 is an example for an hnf-terminating expression that is not terminating. analogous to nf-termination we will also say that a function hnf-terminates for certain categories of arguments. e.g., succ hnf-terminates if its argument hnf-terminates.



because the result type ordering is a simple enumeration type hnf-termination and nf-termination coincide and we simply speak of termination. since compnat simultaneously descends on both arguments, it terminates whenever at least one of its arguments is nf-terminating and the other is at least hnf-terminating. note that the comparison only takes as many steps as the size of the smaller argument. this is a nice property helping on efficiency.



we now turn to the last operator solely defined on natural numbers. this is the function pred which computes the predecessor of a given natural number. of course, this operator can only be defined partially. this partiality will then lead to the extension of our numbers to integers in the next section.



uses our narrowable arithmetic operations. because of the additional support for narrowing, it could even be an option for pakcs to use our library instead of a primitive implementation of integers. in addition, the time spent in arithmetic computations is usually only a fraction of the run time of functional(logic) programs. even in our benchmarks, which were designed to make mostly arithmetic operations, the overhead measured with(,) as op was much larger than the time used to compute the result of the arithmetic computations in most cases.



we propose a different implementation of arithmetic operations for functional logic programming languages. currently, declarative programming languages employ external functions to do arithmetics, which results in serious limitations in the context of functional logic programming. free variables cannot be guessed in arithmetic operations and need to be generated explicitly.



we show that a binary encoding of integers as algebraic datatype eliminates this need. we define all usual arithmetic operations on this datatype and show that our implementation can be used to narrow unknown arguments to these operations. practical experiments show that our implementation produced significant overhead compared with primitive operations. however, we feel that programmers willingly accept this overhead given the new opportunities of narrowing.



