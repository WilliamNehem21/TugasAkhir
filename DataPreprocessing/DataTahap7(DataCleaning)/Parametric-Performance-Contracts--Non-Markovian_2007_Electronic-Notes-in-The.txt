even with todays hardware improvements, performance problems are still common in many software systems. an approach to tackle this problem for component-based software architectures is to predict the performance during early development stages by combining performance specifications of prefabricated components. many existing methods in the area of component-based performance prediction neglect several influence factors on the performance of a component. in this paper, we present a method to calculate the performance of component services while including influences of external services and different usages. we use stochatic regular expressions with non-markovian loop iterations to model the abstract control flow of a software component and probability mass functions to specify the time consumption of internal and external services in a fine grain way. an experimental evaluation is reported comparing results of the approach with measurements on a component-based webserver. the evaluation yields that using measured data as inputs, our approach can predict the mean response time of a service with less than 2 percent deviation from measurements taken when executing the service in our scenarios.



to specify the performance of a component, multiple external influences have to be considered, because components shall be third-party deployable. components may execute external services to provide their services, they can be deployed on different hardware, operating systems and middleware platforms. furthermore, they interact with their environment by using limited resources of a system, and they are possibly executed by very different user groups. any approach aiming at predicting performance properties of component based systems has to take all of these factors into account to be precise. most of the existing approaches fall short in at least one of the mentioned factors.



our approach is precise, because we use discrete probability mass functions to model the time consumption of internal and external computations. it is compositional, since the result of our prediction is again a discrete probability mass function and can be used to model the performance of an external service for another component. furthermore, the approach is parametric, because different probability mass functions can be used(for example depending on the underlying hardware) and the prediction can be adjusted to a different usage profile by changing transition probabilities and probability functions for loop iteration. moreover, performance contracts for component services specified in the quality of service modelling language(qml) can be checked with our method.



the contribution of this paper is twofold: first, we present a new concept for modelling loops with probability mass functions and introduce stochastic regular expressions. second, we report on an experimental evaluation of our approach on a prototypical component-based software system and compare the predictions of our approach with measurements. as can be seen in our evaluation, the calculated probability mass functions differ only slightly from the actual measured values emphasizing the precision of our approach.



the paper is organised as follows: section 2 introduces our modelling approach based on service effect specifications, describes the stochastic annotations and explains the calculations. section 3 contains the description of our experimental evaluation and illustrates the results. section 4 discusses related work and section 5 concludes the paper and outlines future work.



loops with the control flow are modelled by cycles in the service effect automaton. cycles complicate the analysis, since they can be interconnected, include other cycles or have multiple entry points. we want to model loop iterations with probability functions, which will be described later, so we have to identify all cycles explicitly. because of this, we convert the service effect automaton into a regular expression. regular expressions are hierarchically structured and loops have a clear entry and exit point and can be identified by the kleene star operator. furthermore, regular expressions are well suited for the later computations, because it is possible to perform the calculation by traversing their abstract syntax tree. for the conversion, we use the gnfa-algorithm. the regular expression for the above service effect automaton is:



for example, service s0 from the stochastic regular expression above is assigned with a random variable x0, whose probability mass function models how long s0 is executed. the probability mass function is either the result of a computation, measured, or estimated(cf. section 2.4).



furthermore, the service effect specification is annotated with random variables expressing the time consumption of external services(on transitions) and the time consumption of internal computations(on states). the needed probability functions might be derived from measurements(e.g. by benchmarking the component and the external services) or by estimating the values based on former experience, possibly supported by an approach like spe.



it is still unclear, if our approach can be fully applied on existing black box components, for example by analysing byte code. code annotations may have to be made to fully retrieve the needed information for our approach from source code. the direction of reengineering existing components to make them useful for our approach is part of our future research.



in the following, we provide a first initial experimental evaluation of our performance prediction approach. we compare measured data with calculated data assuming that the input data for the calculations are available. this assumption also needs to be tested in the future, as it is not clear if developers of component-based systems can obtain all the necessary data with the needed precision. the assumption could be tested with a controlled experiment involving students or with an experiment in an industrial setting, but this is beyond the scope of the validation described here. the goal of our experimental evaluation was to analyse our performance prediction method from the viewpoint of the developer. we ask the following questions



in the following, we define the independent, dependent and possible interfering variables of our experiment. independent variables are not altered between measurements and calculations and define the context of our experiment. they are namely the hardware, the middleware platform, the deployment, the analysed component(staticfileprovider) and the usage profile. to reduce the influence of the usage profile on the outcome of the experiment, we analysed three different scenarios for the service effect specification described above, which will be described later.



possible interfering variables were active background processes, which could have distorted the measurements, caching of the webserver, time consumption for the output of log messages, the possible influence on the measurement approach to the measured results, garbage collection, just-in-time compiling etc.. we tried to keep the effect of the interfering variables as low as possible, by e.g. deactivating background processes, and implementing the measurement application as efficient as possible.



for measuring the scenarios, we implemented a monitoring framework for our webserver, using interceptors to decorate component interfaces with a measuring facility. the response time of each service call was measured. the data was stored in memory during the measuring process and written to disk in an xml file format after the webserver was shut down. this way, we tried to remove the interfering influence of monitoring on the measurement results because of harddisk accesses.



distribution shifted to the right. the reason for this is, that by specifying loops with transition probabilities, the number of loop iterations is always bound to a geometrical distribution(the discrete case of the exponential distribution). the practical advantage of modelling loops in a non-markovian way can be clearly observed in the graph, because the predictions do resemble the measurements closer.



first we will analyse the time complexity of the calculations. without loss of generality, consider a random variable x describing the timing behaviour of the loop body. let w be the number of values of x and let n be the maximal possible number of loop iterations determined by the function l. before the fourier transformation, the value range of x has to be enlarged to nw. the discrete fourier transformation of a random variable with nw values has the complexity of o n 2w2 nw. the nfold convolution of the discrete random variable corresponds to the n-fold pointwise product of the fourier transform. as the fourier transform also has nw values, the complexity of the n-fold product is o n 2w. afterwards, the inverse fourier transformation has to be performed, having the same complexity as the fourier transformation. altogether, the complexity of the computation of the probability



our approach aims at supporting design decisions during early life-cycle stages of a software system. the timing and resource efficiency of a component-based software architecture shall be assessed as early as possible during development to avoid the costs of redesign after starting the implementation. the spe(software performance engineering) methodology by smith et. al.[17,13] was one of the first approaches into this direction. balsamo et. al. provide a broad survey on model-based performance prediction methods.



further work is related in terms of the notations used. parametric contracts for software components have been developed by reussner et. al.. stochastically enhanced service effect specifications have been used for reliability predictions for component based architectures. the quality of service modelling language(qml) can be used to express performance contracts for components. stocharts



in this paper, we have extended our previous parametric performance contracts by introducing a new loop concept to better model practical situations. we have used stochastic regular expressions instead of markov models, because it is easier to identify loops and the effort for the calculations is reduced by the ability to traverse the abstract syntax tree of the expressions. furthermore, we presented an experimental evaluation, finding a close resemblance between measured data and data calculated. we also discussed the efficiency of the approach.



