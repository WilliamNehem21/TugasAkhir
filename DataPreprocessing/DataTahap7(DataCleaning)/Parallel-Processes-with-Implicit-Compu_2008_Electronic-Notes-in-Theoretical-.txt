we propose a process algebra which is concerned with processes that have an implicit computational capital. this process algebra is intended to be helpful when designing computer-based systems of which the behaviour is related to money handling. it goes along with the development that the behaviour of computer-based systems, organizations and persons is increasingly more related to money handling.



it is not an easy matter to determine what are the basics of money handling. money is what is considered and used as money by a group of people. this implies that economics, sociology and ethnography are involved in deciding what is money and what is not. for that reason, we do not aim at covering all aspects of money handling.



we also extend acpicc with abstraction from internal actions. it happens that restrictions must be imposed on the actions from which abstraction is allowed in order to preclude unexpected effects of this kind of abstraction on the implicit computational capital of processes. the approach to abstraction from internal actions followed in this paper is based on the notion of branching bisimulation.



the structure of this paper is as follows. first, we review acp(section 2) and guarded recursion in the setting of acp(section 3). next, we introduce a simple theory about computational money values called cmv(section 4) and extend acp, using cmv, to a theory about processes that have an implicit computational capital(section 5). after that, we introduce some notions concerning transition systems of preservation of computational money(section 8). thereupon, we extend acpicc with abstraction from internal actions(section 9). following this, we give examples of the use of acpicc(section 10). finally, we make some concluding remarks and mention some options for future work(section 11).



in this section, we shortly review acp(algebra of communicating processes), introduced in. for a comprehensive overview of acp, the reader is referred to. although acp is one-sorted, we make this sort explicit. the reason for this is that we will extend acp with a second sort in section 5.



we use infix notation for the binary operators. the following precedence conventions are used to reduce the need for parentheses. the operator+ binds weaker than all other binary operators to build terms of sort p and the operator binds stronger than all other binary operators to build terms of sort p.



for each guarded recursive specification e and each variable x v(e), we introduce a constant of sort p standing for the unique solution of e for x. this constant is denoted by x e. we often write x for x e if e is clear from the context. in such cases, it should also be clear from the context that we use x as a constant.



first of all, we give a picture of the ideas that underlie the design of this extension. there are three kinds of actions: actions with which an amount of computational money is spent, actions with which an amount of computational money is acquired and actions with which no computational money is spent or acquired. as for spending or acquiring computational money, the effect of performing two actions synchronously is the joint effect of the two actions concerned.



neither what a process is capable of using exceeds its implicit computational capital nor the other way round. the fact that the implicit computational capital of a process does not exceed what the process is capable of using corresponds to the liquidity assumption that the whole capital can potentially be used. the monetary effects of performing actions do not affect the behaviour of a process that has an implicit computational capital.



the following example goes into the implicit computational capital of an infinite process. in case q(a)> 0, the process x x= a x repeats forever a step on which the amount q(a) is spent. because no capital is large enough for that, the implicit computational capital of x x= a x is undefined if q(a)> 0. assuming q(a)> 0, we derive from axioms rdp, pr3, pr4 and icc6, using an inductive argument, that q( x x= a x)= 1. in case q(a)< 0, the process amount is spent. in other words, they say that the monetary effect of performing an action can always be neutralized by performing it synchronously with some other action. it can be useful to hypothesize this neutralization property in derivations concerning a system that is not supposed to interact with its environment, but not otherwise.



in this section, we introduce the notions of transition system induced by a model of acp, paths in a transition system and bisimilarity of transition systems. those notions will be used in section 7 to show how bisimulation models of acp can be expanded to models of acpicc. prior to all that, we make precise what we understand by a transition system.



in acpicc, the implicit computational capital of a process is the least amount of computational money that is needed to account for the behaviour of the process. this amount is implicit in the behaviour of the process. in this section, we show that each bisimulation model of acp can be expanded to a model of acpicc, provided that it can be expanded to a model of acp+pr.



in, the full bisimulation models of acpfo, a first-order extension of acp, are introduced. the full bisimulation models of acp are the restrictions of those models to the signature of acp. the full bisimulation models of acp are the main models of acp. we gather from:



proof. let a be a bisimulation model of acp that can be expanded to a model of acp+pr, and let a' be an expansion of a to a model of acp+pr. let b be a model of cmv, and let b' be the unique expansion of b to a model of cmv+cmt. this unique expansion exists because cmv+cmt is a definitional extension of cmv. moreover, the instances of axiom schema cmtc hold in b' because they are derivable from cmt and the axioms of cmv. from this and the fact that the signatures of a' and b' are disjoint, it follows, by the amalgamation result about expansions presented as theorem 6.1.1 in(adapted to the manysorted case), that there exists a model c of acpcm such that the restriction to the signature of acp+pr is a' and the restriction to the signature of cmv+cmt is b'. because a' is an expansion of a and b' is an expansion of b, the restriction of c to the signature of acp is a and the restriction of c to the signature of cmv is b.



proof. let a be a bisimulation model of acp that can be expanded to a model of acp+pr. let b be a model of cmv, and let be the ordering on the domain of b such that, for all i and j from the domain of b, i j iff max(i, j)= j. it is easy to see that the subset of the domain of b that consists of all elements that are the interpretation of some closed term of sort m is totally ordered by. by lemma 7.1, there exists a model c of acpcm of which the restriction to the signature of acp is a and the restriction to the signature of cmv is b. let a' be c expanded with the function q from the domain of a to the domain of b such that, for all p from the domain of a:



it is plausible that an electronic device, such as an electronic wallet, is modelled in acpicc as a process that deadlocks if the device crashes because of a technical failure. in such cases, it is likely that the process is not cm-preserving. this indicates that preservation of computational money is not a fact of life, but a constraint on how to model. modelling with cm-preserving processes may enforce the introduction of a hypothetical process to which computational money is transferred just before the crash takes place. the problem with that process is that, unless it is able to dispose of its computational money, it accumulates computational money and by doing so it is not cm-preserving.



chipcards with an electronic wallet appear to provide an electronic pendant of tokens. the fourth example concerns a vending machine like the one from section 10.3. the main difference is that it accepts this electronic pendant of tokens instead of tokens.



seeing that the behaviour of an electronic cash dispenser depends upon the balance of the bank accounts for which chipcards with an electronic wallet have been issued, the balance of all those accounts together make up a parameter of the electronic cash dispenser. we formalize this parameter using account numbers. we assume that a finite set n of account numbers has been given. n is considered to be the set of all account numbers of bank accounts for which chipcards with an electronic wallet have been issued. the parameter is formalized by a function



the work presented in this paper was carried out in the framework of a project investigating it sourcing. in that project, we look at it sourcing from the perspective of formal methods. it sourcing is mainly actuated by financial issues. we believe that the idea of processes with an implicit computational capital may be helpful to understand those financial issues.



