the specification of a concurrent program module is a difficult problem. the specifications must be strong enough to enable reasoning about the intended clients without reference to the underlying module implementation. we survey a range of verification techniques for specifying concurrent modules, in particular highlighting four key concepts: auxiliary state, interference abstraction, resource ownership and atomicity. we show how these concepts combine to provide powerful approaches to specifying concurrent modules.



however, these specifications are too weak to specify such clients as the ticket lock. they lose all information about the value of the counter, and give no information about how the operations change this value. in fact, the read operation could change the value of the counter and it would still satisfy the specification! unfortunately, assertions that describe the precise value of the counter are not invariant.



the concept of auxiliary state, introduced in the owicki-gries method, is important in specifying concurrent modules. auxiliary state abstracts the internal state of threads. it is more convenient to reason using auxiliary variables than to consider the program counter and local variables of each thread in describing invariants. this



although this specification captures some of the intended behaviour of wkincr, it is insufficient to reason about the ticket lock. with the ticket lock, it is possible for two invocations of the wkincr operation to be executing concurrently. only one thread can call unlock at any one time, because only one thread can have the lock. however, suppose one thread calling unlock has executed the body of wkincr. then, a second thread may correctly conclude that it now has the lock and release it, before the call of the first thread has returned. this results in a concurrent invocation of wkincr. by ruling out all concurrent updates to the counter with an empty rely relation, the above specification does not allow this concurrent behaviour.



following boyland, bornat et al. introduced permission accounting to separation logic. this allows shared resources to be divided by associating with them a fraction in the interval(0, 1]. shared resources may be subdivided by splitting this fraction. for instance, we may associate fractions with our counter resource and declare the logical axiom:



the concept of atomicity, put forward by linearisability, is important in specifying concurrent modules. atomicity can be seen as a form of interference abstraction: it effectively guarantees that the only observable interference from an operation will occur at a single instant in its execution. this is a powerful abstraction, since a client need not consider intermediate states of an atomic operation(which, for non-atomic operations, might violate invariants) but only the overall transformation it performs.



one way of overcoming the non-modularity of the owicki-gries method was introduced by jacobs and piessens. their key idea is to give higher-order specifications for operations, which are parametrised by auxiliary code that is performed when the abstract atomic operation appears to take effect(the linearisation point). where previously we instrumented the code of the incr operation differently for different call sites, here it is instrumented uniformly; the auxiliary code is a parameter that is determined at the call site.



. however, the environment must preserve the counter, e.g. it cannot deallocate it. the last specification means that wkincr(x) will atomically update the counter from n to n+ 1, as long as the environment guarantees that the shared counter will not



atomic triples specify operations with respect to an abstraction(e.g. c(x, n)), which means that each operation can be verified independently. this makes it possible to extend modules with new operations without having to verify the existing operations again. linearisability, by contrast, is a whole module property: adding new operations(e.g. wkincr) can break the linearisability.



in, we introduce a generalised version of the atomic triple that can combine atomicity with resource transfer. for example, we can specify an operation that reads the value of the counter into a buffer; the read happens atomically, but the write to the buffer does not, and so ownership of the buffer is transferred between the client and implementation. this is not possible with traditional linearisability, although gotsman and yang have proposed an extension of linearisability that supports ownership transfer.



the counter specifications shown in this section are strong: a client can derive the abstract disjoint specifications from them. moreover, they are strong enough to support synchronisation: the correctness of the ticket lock can be justified from the counter specifications. these approaches to specification are expressive enough to enforce obligations on both the client and the implementation. by contrast, cap specifications tend to unduly restrict the client(e.g. a counter specification cannot be used for synchronisation), while linearisability specifications tend to unduly restrict the implementation(e.g. a counter cannot provide a wkincr operation).



we have considered a number of proof methods for verifying concurrent programs: owicki-gries, rely/guarantee, concurrent separation logics and linearisability. in each method, we have identified a particularly valuable contribution towards specifying concurrent modules. finally, we have demonstrated how these ideas can be brought together to produce specifications that are both expressive and modular.



