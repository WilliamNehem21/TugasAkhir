formal verification within interactive or automated theorem provers has become more and more important during the last ten years due to several reasons: first of all, machine proofs guarantee that no special cases have been overlooked and, hence, that the verified properties will indeed hold under all specified circumstances. secondly, mechanized theorem provers allow for managing even large correctness proofs for large systems that cannot be managed by humans without machine help due to sheer complexity. and last but not least, the efficiency and user-friendliness of theorem provers has improved so much over the last years that they can be used in real-life verification problems. nevertheless, there are still many unsolved problems. especially the question how proofs are to be formalized in a theorem



in recent years, coalgebraic methods, in particular coinduction, have gained increased interest and importance in the specification of and reasoning about statebased systems. in subsection 3.1 we summarize the most important concepts in this area. in subsection 3.2 we show how the coinductive definition and proof principle can be used in the theorem prover isabelle/hol.



coalgebraic types are available in isabelle/hol in the extension described in. this extension makes use of coinductively defined sets, a definition principle available in isabelle/hol, and uses it to define lazy lists. as an example, consider the coinductive definition of possibly infinite lists as stated in. the following definition specifies the set of lazy lists llist(a) over a given set a.



lately, also coalgebraic methods have been used successfully in the specification of and reasoning about programming languages and systems. in[7,9], the semantics of object-oriented programming languages has been defined coalgebraically. the goal of the vfiasco project is the verification of an operating system with coalgebraic methods. describes the coalgebraic class specification language ccsl. coalgebraic proof methods are not the only formalism capturing the characteristics of semantics for non-terminating programs. one can also use labeled transition systems. bisimulation can be used within both formalisms. our notion of bisimulation with collapsings(operating on coalgebraic datatypes) und the notion of weak bisimulation(operating on labeled transition systems) may be used for



in our own work we have proved a dead code elimination algorithm as used in compilers correct using bisimulation on kripke structures. in, we describe how coalgebras and coinduction may be used in compiler verification. finally, our work on formalizing and transforming data flow dependent computations also shows, as the work presented in this paper, that the choice of formalization is vital for the proof success when using theorem provers.



