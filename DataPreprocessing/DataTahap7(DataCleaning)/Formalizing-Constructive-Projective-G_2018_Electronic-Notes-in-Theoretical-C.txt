projective geometry is a well-established branch of mathematics which studies the incidence properties of points, lines and planes. typical textbooks relative to this area(e.g.[4,23]) cover topics such as: axiomatisation of points and lines and of the incidence relation, the principle of duality, the theoremes of desargues and fano, harmonic conjugates, projectivities, polarities, conics, etc..



projective geometry constitutes a very elegant, self-contained mathematical system. it is constructed from two primitive concepts: points and lines together with a relation of incidence among them. in addition, a few axioms determine the behaviour of the entire system. for this reason, projective geometry becomes a very attractive discipline to be formalized in a computer system. and an interesting case study in order to investigate problems involved with computer formalization of mathematics.



despite its simplicity, projective geometry is considered as a unifying framework for all other geometries. every result in projective geometry can be applied to affine geometry which in turn reduces to euclidean geometry. this feature is implicit in the so called erlangen program of f. klein where projective geometry is defined as the study of the properties invariant under projectivities.



in order to obtain a definition as general as possible, we consider that a belongs to the universe seta for a generic level a. analogous assumptions are adopted for all objects in our formalization. we will not give details about levels in the rest of this paper. the reader unfamiliar with universe polymorphism in agda can just ignore them without loss of understanding. note that some arguments are declared as implicit(the ones enclosed between curly brackets). implicit arguments have a nice property: in most cases we can omit these arguments and agda will try to infer them from the context. we use implicit arguments very often in our implementation. we will not explain why some arguments are declared as implicit and others are not. in general, it is decided by some sort of heuristics given by practice.



overloading. we need to work with several setoids at the same time. in order to overload the apartness operators for different setoids, we use an agda feature called instance arguments 5. the idea is rather simple: we can open the module setoid] with a special directive: open setoid]{[...]}. this directive allows us to access all the operations of the module setoid] and we can omit the particular instance argument which will be inferred by agda from the context by a special instance resolution algorithm.



the proof of uniqueness of the harmonic conjugate turns out to be a quite complex proof when carried out just by using constructively valid methods. in fact, we could not find a complete and rigorous presentation of this proof in the literature. therefore, a formal and machine-checked construction of such a proof constitutes a major contribution of this paper.



we have based our development on the programming language features of agda rather than on the proof-assistant ones. in particular, we have not constructed proofs by tactics. we have taken advantage of a number of important features of the language. modules and dependent record types have played an important role allowing us to implement setoids as an abstract data type and to view lines and points as instances of this adt. in addition, the mechanism of implicit instances has provided the ability for overloading the operators of this adt. we almost did not need any additional data type: only natural numbers and finitary sets are used in order to provide the definition of complete n-point. with respect to the logic involved in the implementation: we have used the standard connectives of first order intuitionistic logic, namely implication, negation, disjunction, conjunction and quantifiers.



induction and recursion have been rarely used along our implementation. this is rather unusual for a formalization in type theory, but it is reasonable in a case where the main objects are adts instead of inductively defined data types. accordingly, pattern matching is scarcely used(only to process disjunctions and finitary sets).



there exists an early formalization written in alf(an ancestor of agda) by von plato. this is a very simple formalization of von plato axiom system. a more advanced implementation is which formalizes von plato constructive geometry in coq. these works only present a small fragment of projective geometry without covering advanced concepts such as desargues theorem and harmonic conjugates. however, they use the same representation for line/point existence and uniqueness: with functions join and meet defined as in our implementation. the definition of apartness relation is also very similar.



future work. this work is part of a more ambitious project consisting in a complete formalization of constructive projective geometry. future topics to cover will be: projectivities and conics. in addition, there are a number of interesting related problems to be investigated such as: the relationship of projective geometry with affine geometry, i.e. the extension problem(,); implementation of the coordinatization of the projective plane; relation with algebraic models of projective geometry like grassman-cayley algebra, geometric algebra, etc..



