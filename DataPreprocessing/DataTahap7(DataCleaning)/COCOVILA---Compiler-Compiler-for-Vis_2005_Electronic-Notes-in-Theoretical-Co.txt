a compiler-compiler for visual languages is presented. it has been designed as a framework for building visual programming environments that translate schemas into textual representation as well as into programs representing the deep meaning of schemas. the deep semantics is implemented by applying attribute grammars to schema languages; attribute dependencies are implemented as methods of java classes. unlike compiler-compilers of textual languages, a large part of the framework is needed for support of interactive usage of a visual language.



our idea has been to develop a compiler-compiler for visual languages analogous to the compiler compilers of programming languages, to be used as a tool for rapid development of domain-specific visual languages. to be able to describe both syntax and semantics of languages considered, we have restricted the class of languages to schema languages with well-defined abstract syntax. on the semantic side, we are able to specify precisely shallow semantics that produces a textual representation of schemas without loss of essential information included in a schema. furthermore, we give a general way to implement



in several ways, cocovila is similar to meta-modelling tools such as metaedit or atom3. however, our treatment of scheme semantics is quite different. unlike the latter we are using a technique of dynamic evaluation of attributes of the syntactic graph underlying the scheme.



for calculating loads and kinematics of a gearbox has been loaded. gears are connected to each other by arranging them on top or next to each other; lines connect other objects(motor and monitoring device). the toolbar at the top of the scheme is used for adding objects and relations to the scheme. one pop-up window is designed for instantiating object attributes, another popup window is designed for manipulating the schemedeleting and arranging objects etc.



the way to handle large schemes in the scheme editor is to use hierarchical composition in building the scheme. any part of a scheme can be encapsulated as a separate class, so a large scheme can consist of a hierarchy of schemes, where each scheme object can contain subschemes. this means that schemes can be viewed in several different levels of abstraction, in order to encapsulate and manipulate parts of the scheme which are relevant to a particular issue.



