the complexity of the theories and specifications attempted in provers has risen dramatically in recent years. for example, the formal semantics of programming languages like java has been specified in several provers. the proof scripts in one of these efforts(to which the author contributed) are tens of thousands of lines long, and hundreds of strategies have been written to help prove thousands of theorems.



within a military c4i context agents are, e.g., a general, a battleship, or a tank. their infospheres share some characteristics: position, disposition, communication, etc. other components are very different; the agents with which a general interacts are not the same as those with which a battleship or tank interacts.



kind theory is used to specify the semantics of reusable artifacts in collaborative environments. in the context of this work, the artifacts are the subcomponents of proof scripts and proofs, which in turn are instances of mathematical notions like variables and functions. the kind theoretical formalization of the semantic context, and likewise the ui features discussed here, follows partially from the grammar of the proof script language.



some theorem proving environments like jape and ctcoq have been used as ui/hci testbeds[6,7,21]. many of the innovations that were originally introduced in specialized environments have now found their way into general purpose front-ends. for example, proof-by-pointing in centaur and ctcoq is now available in proofgeneral, and the ppml-based layout and prettyprinting facilities of ctcoq are partially functionally reproduced in some of this work.



pcoq is a java-based user-interface for coq. it has some of the features of this work including a rich graphical interface and structured editing and presentation mechanisms. in particular, the rich presentation capabilities are based upon an internal formal representation of proof constructs. unfortunately, while pcoq followed a high-minded model put forth in, it has not evolved as is not used as a ui for coq.



isawin is another environment which has some advanced interactive features. isawin differs from this work in that it focuses on an iconic, graphical representation of mathematical constructs with a drag-and-drop interactive metaphor. as with most iconic languages, there are some problematic issues with scaling graphical representations of non-trivial artifacts.



some commercial general-purpose computation environments, particularly quality commercial environments like mathematica, maple, and matlab, have rich uis. these tools provide wysiwyg-ish interfaces that use mathematics fonts and provide direct editing of terms with a point-and-click, drag-and-drop ui. while the intention here is not to attempt to duplicate such uis, their visual features are compelling and inspirational, but their editing features and flexibility are actually inferior to most sophisticated environments like those mentioned above.



coupling an advanced ui like that of mathematica to a prover like pvs is an interesting experiment. but, as neither tool was designed as a reusable component, such coupling is awkward. instead, in this work these commercial mathematics environments are studied, and the features that are found to be most useful in day-to-day work are adopted, adapted, and formalized for theorem provers.



the second-level concepts of pvs are one level deeper within the grammar. they are exactly those concepts which are used to define the top-level concepts. they are: theory formals, import and export relations between theories, assumptions, declarations, judgments, and conversions.



the set consisting of all kinds identified using the process of section 2.2 is the underlying kind context of the ime. this set is fixed for a given proof script language and ime combination, thus is not contextual from the point-of-view of a user.



all documents loaded by a user in the ime must be parsed to identify all instances in the current semantic context. a parser will obviously exist in the back-end prover of the ime, but it is often the case that no published api exists for accessing this information. thus, many imes will use a front-end parser of some kind, like that discussed in section 4.



each construct identified by the parser has a starting point and an ending point. this extent information is used to determine the current user focus by identifying which construct encloses the current point of focus within the ime. if the current point does not fall within the extent of any instance, than the closest instance, moving backward through the current document, is consider the enclosing instance.



extended implicit hyperlinking is a feature new to commercial development environments. for example, automated spell-checking functionality, like that found in emacs or microsoft word, is an example of implicit hyperlinking. in such an environment, the source document, perhaps a research paper, is implicitly hyperlinked to one or more dictionaries. the purpose of this particular hyperlinking is word spelling correction and definition and synonym lookup.



the pvs latex printer is driven from typechecked specifications. it allows substitutions to be made, and, by using the resolution information, can distinguish operators based on arity and the theory where the operator is declared. types are not currently used, in order to keep the substitutions file simple 8.



other approaches are available for pretty-printing that are especially useful when embedding different logics in pvs. for example, skakkebaek generated a new parser for the duration calculus, mapping its abstract syntax to subclasses of the pvs abstract syntax. instances of these classes are prettyprinted using specialized methods, but typechecking, proving, etc. would use the methods of the superclass. this works well, but it is not easy to define a new grammar in pvs 9. defining a new grammar for the duration calculus was not too difficult because it copied most of the pvs grammar and simply added a few new operators. another difficulty is that as a proof is developed, terms get introduced that are part pvs and part duration calculus, and though they would be pretty-printed, the result could be confusing to the user.



in pombo, pvs was used to provide the semantics of ag specifications, defining the semantics of first order dynamic logic and fork algebras, along with rules and strategies that allow a user to reason in ag. here there were conversions defined, such as a meaning function, and arguments such as the current world of the kripke structure, that by default are included in the prover interaction, but add clutter to the proof. in this case the function for pretty-printing applications was modified in order to suppress the meaning function and the world argument.



this approach works well for many situations, but not all pretty-printing tools can be integrated into common lisp. for non-common lisp-based tool, resolution and type information need be provided. the most promising approach to this problem is to provide the abstract syntax of pvs terms in xml, given most programming languages have facilities for reading and manipulating xml documents. this is done, for example, in omdoc, which provides an extension for pvs that generates omdoc abstract syntax from typechecked pvs specs. there are future plans for generating xml that directly reflect the internal abstract syntax of pvs, and this could easily be used to build a new pretty-printer.



this integrated environment is an extension of the emacs code browser(ecb), a source code browser for emacs. it displays a user-customizable set of windows that can be used to browse directories, files, and file contents, all of which are substructures of the current semantic context. the summary pane in the top-left of the future can also be split off into a separate window. the speedbar package is used to support this functionality.



shortcut menus(not seen in the illustration) are available as discussed in section 3.1.1. they are realized using the imenu facility, which is built into recent versions of emacs. this features offers a way to find the major definitions in a file by name, via a nested set of menus.



second, currently the wisent parser does not work with the x-symbol package, as the grammar is written in ascii. thus, a user currently either can have symbolic representation of their pvs proof scripts, or can have the integrated environment, but not both. we hope to lift this limitation before the release of the new pvs.



finally, ui operations involving parameterized theories are weak. improving support for completion and summarization of such parameterized substructures is an important research topic. it is likely that pvs theory parameterizations can be characterized by the kind theoretical composition operators, thus the methods of section 2 can continue to be used.



ing its capabilities. examples of refactoring include safe renaming of program features(variables, functions, methods, etc.), function extraction and insertion, and safe modification of feature visibility(e.g., making a public variable private, automatically writing getter and setter methods, and automatically inserting these methods at all program locations that access the original public variable).



an example refactoring operation within an ime is the identification and use of a cut rule. when performing a large proof, it is sometimes the case that, at some mid-point during the interactive process, multiple branches of the proof are recognized as having a similar structure. to simplify the proof, a lemma could be defined and used within these branches. unfortunately, many provers, pvs included, provide no means by which such a lemma, acting here as a cut, can be extracted, defined, proved, then(re)used.



this work was supported by the netherlands organization for scientific research(nwo). thanks to sam owre, erik poll, martjin warnier, bart jacobs, and adriaan de groot for their input on earlier versions of this paper. thanks to chara williams for help with the screen captures.



