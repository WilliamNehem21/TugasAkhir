also, in connection with the topological theory of distributed computing, to represent executions of protocols in the iterated model(and in the extended ifsc model), we will have something to say about theorem 3.6. it is known that the protocol complexes in the iterated shared memory model are connected and because of this, it is impossible to solve consensus[7,19]. in this paper, we argue that the protocol complexes in the ifsc model are disconnected, yet, these protocols cannot solve consensus. the discussion about theorem 3.6 is in section 3.



the state machine of each process pi models a local protocol ai, that determines the steps taken by pi. we assume that all local protocols are identical; i.e. processes have the same state machine. a protocol is a collection a of local protocols a1,..., an. in this paper, we are interested in protocols in the iterated read/write shared memory model of distributed computing. from now on we just call it the basic iterated model. for the sake of simplicity, we give protocols specifications using pseudocode and we establish the following conventions: a lowercase variable



it would seem that the iterated model that we have defined is too restrictive: a process cannot go back and read again the same shared array. moreover, all processes must access all the shared arrays in the same order. because of this, one may think it does not have full generality when compared with the more standard, non-iterated wait-free shared memory model, that does not have the restrictions imposed to protocols in the iterated model. the crucial question is: does there exists a task that is solvable in the wait-free standard model and it is not solvable in the iterated model? the answer is no. every task that is solvable in the waitfree standard model is also solvable in the iterated model. this is proved using an algorithm that simulates the standard model in the iterated model, first in, and more recently in. therefore, there is no loss of generality(for computability purposes) in considering only protocols in the iterated model.



a) is closely related with the notion of a span in[19, definition 4.4, page 884]. herlihy and shavit define the protocol complex as a bigger geometric structure which depends on all the possible input values of processes and all possible executions of a protocol a. however, for most cases, it is sufficient to work with the definition of protocol complex we have given. we find our definition sufficient for the purposes of this introductory paper.



the safe-consensus task is the result of weakening the validity condition of consensus. it was first proposed by yehuda, gafni and lieber; they use it to show that the g-tight-group-renaming task is as powerful as consensus for g processes. we can now define new objects to extend the basic iterated model.



it can be seen that the safe-consensus shared objects are primitives more powerful than the read/write shared memory. this is because in the authors give two protocols that solve the consensus problem for n processes in a model of distributed computing that extends the standard shared memory model with safe-consensus objects(without any restriction in the way that the processes use the safe-consensus objects) and this says that the safe-consensus task is as powerful as consensus. remember that in this paper, in order to make a clear exposition of the field, we use the safe-consensus objects by imposing some rules in the way in which processes invoke the shared objects.



after we add to the basic iterated model the power to use safe-consensus objects, one of the first questions that we would like to answer is: what happens to the protocol complex in the extended model? are the topological properties unchanged? in order to answer this question, the first thing we must do is to formally define the protocol complex for protocols in the new ifsc model. if a is a protocol in the ifsc model for n processes, the protocol complex sa of a is defined in the same way as we defined protocol complexes in section 2.3, the only thing that changes is the view associated to a vertex. a vertex of sa is a tuple v=(i, smi, val), where i is the id of process pi, smi is the local state of pi and val is the return value of the safe-consensus object invoked by all processes.



if we take the case of n= 2 processes, then by theorem 3.2, consensus of 2 processes((2, 1)-set agreement problem) is solvable with safe-consensus objects. as we have seen in this section, the protocol complexes of protocols in the ifsc model are disconnected, so that one would expect to be able to solve consensus in this model, but our next results argue otherwise.



proof it is enough to prove the lemma for l= 1, as the general case follows easily from this case. suppose(without loss of generality) that s= s0 is v-valent and that sj= sl is vj-valent(v/= vj). since s is v-valent, in every execution starting from s, there is at least one process that outputs v and by the agreement condition of consensus, all processes must output v as the consensus value; the same is true for sj, replacing v with vj. let r be the round number of both s and sj(this makes sense, because s and sj are adjacent, thus they must have the same round number, which is part of the local state of each process), then combining lemma



we have described the iterated model of distributed computing, a useful tool to study and understand the behavior of distributed systems. also, we described how the runs of protocol in this model can be represented with simplicial complexes and we presented some standard tools(i.e. connectivity of states, valency, etc.) commonly used to investigate distributed systems. also, we described the set agreement task, one of the most important distributed problems.



to show to the reader what sort of results can be achieved with the iterated model and the topological approach, we defined the iterated shared memory with full safe-consensus objects(ifsc) model, an extension of the basic iterated model using the safe-consensus task of. we showed how to analyze protocol complexes in the ifsc model, and we discovered that the protocol complexes of protocols in the ifsc model are(globally) disconnected. we explained why local connectivity between some pairs of vertices of the protocol complex is sufficient to prove that consensus is unsolvable in the ifsc model. thus we see that connectivity of the protocol complex(which is related to the notion of non-distinguishable states) is indeed fundamental in the study of distributed computing.



