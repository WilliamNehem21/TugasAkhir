our study of the turing category computation model takes the form of building a type-theoretic formal language description(formalization) of the relevant concepts. the concepts we have selected to formalize lay the groundwork for(formally) proving abstract interpretations of standard theorems in recursion theory. the key motivation behind this approach is the level of organization, consistency, and guaranteed correctness it provides in working with proofs and definitions for which unformalized presentations may omit important and interesting details.



turing category theory can be viewed as an(up until recently) non-formalized mathematical framework that describes a precise model of computation. as computation on a physical computer is a precise procedure, it seems natural to verify that a formal description of this framework exactly fits the selected categorical model. this is the motivating idea and the main objective of this work. there is not a huge



we start from a library for general category theory developed by timany and jacobs, designed to take advantage of advanced features in coq 8.5 such as type classes and universe polymorphism. this library successfully develops many of the basic concepts, and thus we chose to adopt the style of definitions and formalization strategy used in this library. with this library as a starting point, we specify the mathematical definitions found in the framework of the turing category computation model, as well as abstract versions of other types of structures naturally occurring in the traditional computation model. we then formally prove(the abstract versions of) a number of results from traditional recursion theory.



in addition to formalizing the categorical concepts, we formalize several examples of categories. these examples provide validation of our formalization approach and formalized results. they also provide a mechanism to formally study these specific example categories. our main example is the formalization of traditional computation on the natural numbers and the categorical interpretation of all the structure found therein, illustrating that these indeed conform to the turing category model formalism. we base our formalization of traditional recursion theory on a formalization due to zammit.



examples of restriction categories include familiar categories of partial functions(formalized in sections 2.5 and 2.6 below) as well as the category of topological spaces and partial continuous functions with open domains. continuous functions which preserve open sets, called open maps, have also been axiomatized abstractly and play an influential role in computer science. this allows topological notions to be lifted to other categories and forms an important part of the theory of restriction categories(see also section 2.4 below).



a similar approach is used to define the notions of a total subcategory, trivial restriction structure, etc.. for cartesian restriction structure, we formalize restriction products and restriction-terminal objects, which are similar in structure to true products and true terminal objects. we have formalized restriction products and the restriction terminal object following closely the example of how the true products and the true terminal object are defined in the category theory library we are using. in order to define a cartesian restriction category, we build a class that takes as parameters a category, a restriction combinator in this category, partial products for all pairs of objects in the category, and the partial terminal object.



we have formalized comp(a) and split(comp(a))(the karoubi envelope of comp(a), i.e. the idempotent-splitting completion of the category comp(a)) as cartesian restriction categories. the resulting terms can be instantiated to give specific instances of comp(a) and split(comp(a)) when supplied with arguments including the base category c, the object a: c, as well as cartesian restriction structure in c(which, by our construction, will be inherited by both of the resulting categories). in the process of building these terms, we have discovered additional



the maps f^ are obviously idempotent. open maps as presented in allow an abstract characterization of ranges. for example, it is shown in that a restriction category c is a range category if and only if every map is open.



the categorical concepts on which the tools we developed in(i) are based provide us with the advantage of allowing us to model both partial and total computation constructively. the tool framework itself is integrated into an existing comprehensive category theory coq library, and it conforms to the structure existing therein. such a formal development enhances the traditional study of abstract computation by introducing structural and hierarchical integrity and making precise all definitions. furthermore, building our tools as an extension of an existing library facilitates future research on the topic by using and building on the categorical



while most of the formal results we have proved confirm what has already been shown in the literature, formalization also gives us the ability to find omissions in the definitions, proofs and propositions. for example, in the process of formalizing a result about ranges in turing categories, we saw that we were not able to directly express the result in terms of range structure, and had to instead formulate and prove a very closely related result in terms of open maps(see section 2.4).



the most noteworthy result we have formalized is the constructive version of the category of sets of the form nn and partial recursive maps between them, which is meant to categorically represent traditional computation. this has not previously been done. through our work, we have gained an understanding(as well as formal constructions) of the additional results, concepts and machinery that are needed to build such a category. in the process of building this category in the formal sense, we have also encountered several proofs whose completion necessitated the use of specific versions of the axiom of choice, as mentioned earlier.



tegrated way than the coq development. the lean system has two modes, the proof irrelevant mode(which is incompatible with homotopy type theory), and the homotopy type theory mode. this system is another option to consider for future work on formalizing categorical examples of abstract computation.



