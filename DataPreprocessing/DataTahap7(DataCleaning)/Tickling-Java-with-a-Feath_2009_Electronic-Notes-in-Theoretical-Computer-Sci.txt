in this work, we present our findings from testing java with featherweight java(fj). we take the syntax and binding structure of fj to define an instance space of non-isomorphic test programs and implementations of fj type checkers to provide oracles for our tests, to ensure the mainstream implementation conforms with the expectations of fj. using these, we evaluate(using code coverage techniques) how much of the sun openjdk javac can be tested by fj.



writing compilers and type checkers is hard. in addition to the sheer quantity of code, the implementation may be complicated by the desire to produce code that is efficient and fast. the languages compilers are processing are ever-increasingly complicated, with sophisticated type rules, and many possible obscure corner cases. there are also complications with possibly several intermediate representations being used inside the compiler, each with their own invariants and properties.



creating tests for a new language compiler is time consuming. the test cases need generating, and an oracle consulted to determine if it should be a passing or failing test. if it is a human oracle, it is possible that they could be wrong. test cases are then also limited by human imagination, obscure corner cases could be overlooked. if the test cases are being generated by the compiler writer; it is possible that they could be biased or influenced by their own assumptions about the implementation or their interpretation of what the language should do.



there is an issue of maintaining or upgrading the tests if the language evolves. the validity of some old tests may change if the language semantics are altered during development, and a human oracle has to find and check all possible tests that are affected. this is as-well as finding new tests for interactions with existing language features and any new ones added.



this work asks whether the formal presentation of the theory could also be used both as input to generate test programs and to be an oracle for them. they can then be executed by the implementation of the full language to see if it conforms with the theory. we want to evaluate how useful these test programs would be in practice.



in section 2 we briefly summarise featherweight java, and discuss features and omissions that become interesting later in the paper. we then describe how we take the grammar component of fj and use it to generate test programs in section 3. we also describe how we use knowledge of name binding to prune some isomorphic programs from the search space of those generated. in section 4 we describe how we use implementations of fj type checkers as our oracles to determine whether the test program is one that javac should accept or reject. we also discuss the presence of fj programs that fj rejects but that javac will accept. with the test programs generated and their expectation provided, we describe the set up used to test the openjdk java compiler in section 5. the results from the experiment are presented in section 6. finally we put this work in context in section 7 before concluding and looking to the future in section 8.



there are many features of java that are not in the fj abstraction, for example assignment, field shadowing, covariant return types in overridden methods, method overloading, interfaces, enumerated types, nested class declarations, and many others. as we discuss in section 4, some of these missing features mean that there are fj programs that fj fails to type check that full java would accept. however, all fj programs that fj can type are valid java programs.



fj provides a grammar that describes syntactically valid fj programs. the test programs we generate are all instances of that grammar. we instantiate the grammar by walking it using a bounded, depth-first exploration algorithm. we use structural constraints limiting the maximum number of classes, the number of fields and methods per class, and the complexity(sum of all production rules used) of expressions in each method and the number of variables used in a method, to ensure the depth first exploration does not explore an infinite space.



because class, method and field names bind globally, the names can be forward referenced inside earlier definitions. for example in p1 above, the constructor return type c2 is a forward reference to the next class declaration. to be able to know which globally bound names will be available, the generation algorithm proceeds in two phases.



the current generation scheme could be improved in some ways. if we assumed that the relative order of some declarations(e.g. class and method declarations) were of no significance to the compiler we will test, then a further class of isomorphic programs could be pruned.



to help ensure our oracle is correct, we have used our generated test programs to check that it gives the same outputs as another implementation of fj. given the java compiler we have chosen to test, we also expect that the implementation of javac is actually correctso the oracle should agree with it in most cases(which it does). however there are some cases where the fj oracle and javac do not agree.



the use of this server program also aids greatly with collecting code coverage results for a test suite(all the tests in a particular search space). we instrumented the open jdk compiler jar using the code coverage tool emma, and ensured the server invokes this. as the server is only invoked once and kept running during the testing of an entire suite, we do not need to do a post processing step of combining individual test code coverages together to find out the coverage of a suite.



some trends are apparent in the results. for example, the change in code coverage when moving from test suite 10000 to 20000 shows a relatively low increase in the code coverage of java, but a slightly larger jump in fj. this is due in part to the number of new concepts or conditions being tested in the second case(e.g. possibly a user defined cyclic class hierarchy) being low in terms of all the concepts in java, but less insignificant in the face of fj.



comparing the results of test suite 11103 with 11113 and 11104 is also telling. despite the latter two test suites being over 6 times bigger than the former, the coverage of javac is only negligibly larger. an expression complexity of 3 is large enough for all expression productions to be used in some way. increasing the limit from 3 to 4 with almost no change in the type checking code of both fj and javac show how the recursive nature of the implementations of the type checkers can be tested mainly by lots of small examples. however there is a small code increase outside of the type check packages which is due to the parser now handling more complicated expressions. they also demonstrate that adding method arguments to method definitions is also negligible in the context of javac, but a more meaningful to the much simpler fj, which gains about 3% coverage increase.



larger tests. the fj implementation featured a parser written in pure java, and since all the programs being provided to it are syntactically correct, a large proportion of that code was not exercised. we also collected coverage for the same tests that we provided to javac, which means the programs that were not usable and filtered out where also not used to collect fj code coverage. to further explore this, we re-ran test-suite 11103 against our fj implementation without filtering out programs and the code coverage was 0.5% higher.



attempt to evaluate the accuracy of the small scope hypothesis in the context of java libraries. they use a tool(korat) that generates non-isomorphic java programs of bounded size matching a predicate, and check implementations of several library data structures(linkedlist, hashset, treemap, etc), using standard metrics of statement coverage and mutant killing 3 to see how much of the space of the implementation they have tested in the bounded size of inputs. the results of the experiment show that even with low bounds set on the inputs, very high(generally near 100%) mutant killing ratios are achieved, and over 80% statement coverage is achieved. we achieve similar results in the type checking packages of our fj implementation. while we do not achieve these levels of coverage on the java compiler(nor would we expect to), we do show that lots of small, simple tests can cover a non-trivial amount of the code base.



