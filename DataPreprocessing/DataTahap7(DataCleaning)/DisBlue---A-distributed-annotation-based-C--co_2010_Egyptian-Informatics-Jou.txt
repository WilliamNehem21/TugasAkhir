abstract many programming languages utilize annotations to add useful information to the program but they still result in more tokens to be compiled and hence slower compilation time. any current distributed compiler breaks the program into scattered disjoint pieces to speed up the compilation. however, these pieces cooperate synchronously and depend highly on each other. this causes massive overhead since messages, symbols, or codes must be roamed throughout the network. this paper presents two promising compilers named annotation-based c#(blue+) and distributed annotation-based c#(disblue+). the proposed blue+ annotation is based on axiomatic semantics to replace the if/loop constructs. as the developer tends to use many(complex) conditions and repeat them in the program, such annotations reduce the compilation scanning time and increases the whole code readability. built on the top of blue+, disblue+ presents its proposed distributed concept which is to divide each program class to its prototype and definition, as disjoint distributed pieces, such that each class definition is compiled with only its related compiled prototypes(interfaces). such concept reduces the amount of code transferred over the network, minimizes the dependencies among the disjoint pieces, and removes any possible synchronization between them. to test their efficiencies, blue+ and disblue+ were verified with large-size codes against some existing compilers namely javac, djavac, and cdjava.



to undertake all above mentioned flaws, a c# compiler, named blue, was first selected as the research baseline. second, blue+ was implemented to handle the proposed annotation. third, disblue+ was built over blue+ to achieve all above contributions. finally, many applications were applied to validate the proposed ideas. to test blue+ and disblue+ efficiencies, java/blue and djavac/cdjavac compilers[21,23] were used, respectively.



the remainder of this paper is as follows. the main research contributions and goals are divulged in the following section. section 3 covers some related works. section 4 illustrates by examples blue+ aspects. section 5 demonstrates by examples disblue+ features. section 6 shows some implementation issues for the two proposed compilers. in section 7, experimental results are presented. to end the paper, conclusions are drawn in section 8.



axiomatic semantics, annotations, and compiled interfaces concepts are existing current programming issues(section 3). however, this research novelty is how to utilize these notions to acquire the research goal. besides code readability and reusability, the research goal is to overcome the overhead because of annotation tagging and/or the distributed compilation. the proposed utilization could be summarized as follows:



all program conditions could be replaced by axiomatic semantics as precompiled annotations. these annotations are created and compiled by the developer at development time before the compilation takes place. in addition, they are reusable and more readable than any current conditional(compound) statements. hence, the total produced tokens are reduced and the updates of them are easier than ever.



many distributed/parallel compilers have been constructed to reduce the compilation time. a parser may decompose the grammar into small disjoint parts and make each processor responsible for one part[8,16,17,25,26,28,29]. partitioning the parse tree into sub-trees and distributing them on a set of processors is proposed in which each processor performs the semantic analysis and code generation, then, the result is finally gathered.



comes a leaf node in the matrix. once a ready file is compiled, it will be removed from the matrix. this makes all files depending only on it be leaf nodes and then are nominated to be the next selection. the process continues until all files are compiled. the major djavac drawback is the extensive use of file transfer. additional overhead is added in transferring a class file(s). for example, if class a depends on class b and the scheduler decides to compile class a, so either a.java or class b is transferred since a cannot be compiled separately without the existence of b.java/.class file(s).



while designing blue+ compiler, the three main decisions are taken. first, axiomatic semantics is decided to be the annotations to replace the program conditions/loops. this is because of its simplicity, readability, and declarative natures. second, c#[33,35,36] is selected as a good oop language. in comparison to java and c++, ref. presented good reasons to nominate c# for this selection. finally, as c# compiler, blue is selected to be the research baseline. it is a managed compiler that follows all oop compiler principles



blue+ basic idea is to utilize the pre-parsing operations in its compilation phases. that is to parse some source code before parsing time. blue+ does pre-parsing to parse axiomatic semantics at development time. then the generated tree is merged(injected)1 into the parse tree of non-axiomatic statements during the parsing phase. the pre-parsing is surely designed to reduce compilation time. example 1 illustrates this idea by showing the abstract syntax tree(ast) before and after using if-statement to enclose the expression. the if-statement sub-ast is marked by surrounded thick closed line.



built on the top of blue+, disblue+ inherits all its features(section 4). moreover, disblue+ has own distributed features that totally depend on compiled interface concept. the disblue+ idea is based on oop features coupled with software engineering principles. with support of polymorphism and interface features, the application software engineer forms the application as a set of correlated interfaces in the application server. the compiled interface(ci) coupled with its compiled relevant interface(s) is sent to one of the application client. in that client, the compiled interfaces are extracted to get their specifications via reverse engineering module and then the body of ci is written. these steps are rendered as follows:



in spite of the fact that the compiled interface is not a novel idea, the manner of its utilization in the above steps is a distributed compiler novel idea and it reveals many potential points. first, the divided tasks could be asynchronously coded without any synchronous collaboration among the project developers. second, no conflict or possible programming miscommunications may be arisen because all interfaces and related bodies are well defined by the software engineer. third, all tasks are automatically assembled which gives better software management activities than any today distributed compilers. finally, since most disblue+ transferred files are compiled interfaces, the total transferred bytes of disblue+ application is small. that is in contrast to similar nowadays compilers which each of them makes its clients exchange the whole(compiled) class(s) among each other because of their dependencies.



however, the disblue+ software engineer should consider the removal of all application dependencies via interfaces. it is intended to build a new c#/c++ compiler having the above features such that they may affect all compilation phases especially parsing and semantic phases. more types of annotations should be investigated to enhance such compiler.



