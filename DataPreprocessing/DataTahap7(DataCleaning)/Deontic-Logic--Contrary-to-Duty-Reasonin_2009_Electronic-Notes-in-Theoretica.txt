what is called by deontic logicians contrary-to-duty(or ctd for short) reasoning. ctd reasoning has been an important object of study in deontic logic; this kind of reasoning arises naturally in legal scenarios. however, in several deontic logics ctd scenarios are inconsistent when formalized; this is sometimes thought of as being paradoxical, since this is contrary to our intuition(in the sense that, intuitively, these statements are not inconsistent).



the paper is organized as follows. in section 2 we give a brief introduction to deontic logic and contrary-to-duty statements. in section 3 we describe our version of deontic logic and we propose a more expressive extension. in sections 4 and 5 we show two examples: a simple train system and a formalization of the byzantine generals problem. these case studies allow us to demonstrate that ctd reasoning arises naturally in fault-tolerance. we prove some properties of the examples to illustrate the benefits of using deontic logic to specify and verify faul-tolerant systems.



the semantics of sdl is given with kripke structures, and the interpretation of the obligation operator is the same as the ussual modal necessity(although this axiomatization imposes a different structure on the kripke models; note that the axioms imply that the kripke structures are serial, i.e., every state has a successor).



we consider a simple example of a train system. train systems are those systems that control the movement of trains through a network of rail segments. faulttolerance is a key aspect of these systems: a fault in the system may cause a train collision and the loss of human life. these kinds of systems are the object of active research in the fault-tolerance community, see[2,16,1].



we have the following actions: ti.move(j)(the train ti moves to the segment rj), ti.stop(this action stops the train), ri.ggreen(the signal of rail ri is set to green) and ri.gred(the signal of segment ri is set to red).



recall that in section 3 we introduced a logic with vocabularies that can have several versions of deontic predicates. in this example, we consider three versions of deontic predicates for each train, and one version for each segment. we denote by ti.pk(), ti.pk() and ti.ok() the permissions and obligations corresponding to train ti. we use the same notation for the segments. furthermore, we use some syntactic sugar and instead of writing ti.ok(ti.move(j)) we write ti.ok(move(j)), are connected, and we have two trains, t1 is in segment r1 and t2 is in segment r2. since segment r2 is occupied, t1 is forbidden to move to that segment, but if it moves, then it must stop. the train moves to that segment and it does not stop. we reach a state where the two trains are in the same segment, and t1 executes any action but t1.stop, which will produce a collision in the real world. this model also shows that the contrary to duty predicate expressed by axiom t10 does not introduce any inconsistency in the specification.



the specification that we provide below uses the ideas introduced in[13,25], where authenticated messages are used. the specification does not assume any form of authentication to prevent forged messages. instead, deontic predicates are used to express that traitors are forbidden to lie. of course, they might forge messages anyway. we consider this as a malicious behaviour which is a worse betrayal than to not obey orders. the important point here is that deontic operators allow us to abstract from the mechanisms that are used to prevent traitors from lying.



consider a clock that allows lieutenants to synchronize; the action tt increments the clock by one unit of time. the specification uses m+ 1 rounds of messages, which are coordinated by means of the clock. we have the following predicates: li.aj(this predicate indicates that li has received a message from lj saying that he must attack). we have a violation predicate li.v for each lieutenant(this predicate is true when li is a traitor, i.e., a li is in a violation state) and li.d(this predicate is true when li has decided to attack), ri(this predicate is true when we are in round i od the decision protocol).



