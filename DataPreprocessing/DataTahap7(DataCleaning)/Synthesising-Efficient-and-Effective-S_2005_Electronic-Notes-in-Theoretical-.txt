framework views design synthesis as a numerical optimisation problem. we use the established global optimisation technique of simulated annealing(see subsection 4.1 for a description) to perform the search. the framework extends previous work of the authors[5,6,7] which addressed only issues of logical correctness. our previous work used ban logic. in this paper, we use svo logic, a more sophisticated logic than ban logic, and thus giving greater confidence in the practical security of discovered protocols.



the additional scope of these logics. rather, its aim is to produce a model of computation and a logic that is sound with respect to that model, whilst still keeping the expressiveness of the various ban extensions. we shall use a subset of svo logic as the basis for our protocol synthesis framework. the parts of svo we need for the examples in this paper are given in subsection 2.1.



p controls x: p has jurisdiction over x. the principal p is an authority on x and should be trusted on this matter. an example of jurisdiction is that principals may believe that a key distribution server has jurisdiction over statements about the quality of keys.



svo logic represents a protocol at the abstract level by asserting comprehension of received messages and interpretation of comprehended messages. these premises almost preclude automated reasoning in that a message of the same format may carry different, context dependant, meaning in different protocols. we avoid this limit by using the gny recognisability rule and message extension.



in this example, a principal a obtains a new secure session key kab to communicate with another principal b from a key distribution server s. we start from a set of initial assumptions and intend to achieve the above goals. firstly, a possesses their identifiers(that is, a, b and s). he also possesses a particular random number na(also known as a nonce), and a long term key kas for communicating with s. secondly, s possesses principals identifiers(a, b and s) and the long term key kas as well as a. as s plays the role of a key distribution server, he also possesses the new session key kab. thirdly, a believes that kas is secure and na is a well formed nonce which is both fresh and recognisable. a also trusts s to provide kab, that is to say a believes that s has jurisdiction over the new session key. and finally, s believes that kas is secure for communicating with a and kab is a good key that can be used between a and b.



boyd and mathuria define two sorts of efficiency: computational efficiency and communications efficiency. computational efficiency is concerned with the computations that the principals need to engage in to complete the protocol. this will largely depend on the algorithms used to provide the cryptographic services. communications efficiency is concerned with the number and length of messages that need to be sent and received during the running of a protocol. in some sense, computational efficiency is an issue that can be discussed at the concrete level whilst communications efficiency can be expressed at the abstract level. in our system, we define a collection of fitness functions for expressing efficiency issues(number of messages, encryption method, server interaction etc.) and ways of determining how these concerns have been achieved. details of the fitness function are given in subsection 4.4.



in the experiments, we used a geometric cooling rate of 0.97; the number of attempted moves at each temperature was 400, with a maximum of 300 iterations(temperature reductions) and maximum number of 50 consecutive unproductive iterations(that is, with no move being accepted). further details of the annealing algorithm we used in our system can be found in the earlier papers[5,6,7].



determine the sender, receiver, and the key under which the current message is encrypted. if this key is an appropriate one for communication between the sender and the receiver, then proceed with the rest of the current message, else ignore this message and proceed to the next message. the method of decoding the sender, receiver, and key is given in subsection 4.2.



a holds a long term secure key kas that he believes to be secure for communicating with the key distribution server s. a maintains his own nonce na that he believes to be fresh. a is able to recognise his own identifier a and nonce na.



similar to principal a, principal b holds a long term secure key kbs that he believes to be secure for communicating with s. b maintains his own nonce nb that he believes to be fresh. b is able to recognise his own identifier b and nonce nb.



one pleasing feature of the work is the speed at which protocols are generated. a typical run takes two minutes or less(on a pentium mobile 1.5g processor with 512mb memory, javatm 2 sdk 1.4.2 and borland jbuilder 9). this compares very favourably with other design synthesis approaches, for example model checking.



there is very little published work in the field of protocol efficiency. with our protocol synthesis approach, we have provided a framework for incorporating efficiency concerns into the synthesis approach(in terms of the number of messages, server interactions etc.).



in this paper, we demonstrate that our system has the ability to synthesise three-party authentication and key transport protocols using symmetric key cryptography. key agreement protocols have become much more popular than key transport protocols in recent years. svo logic has the ability to analysis key agreement protocols. we believe that our synthesis system can easily be extended to encompass public key scheme and synthesise key agreement protocols.



