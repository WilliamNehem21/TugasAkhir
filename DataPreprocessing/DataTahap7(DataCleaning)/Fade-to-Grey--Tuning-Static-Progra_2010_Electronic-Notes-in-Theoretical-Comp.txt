static program analysis[1,2] can alleviate some of the aforementioned disadvantages. in contrast to traditional testing, static program analysis does not execute the implementation, but analyzes the source code for known dangerous programming constructs, for combinations of those and their causal relationships, and the impact of potentially tainted input. typical examples in c/c++ are null pointer dereferences, accessing freed memory, memory leaks, or creating exploits through buffer overruns. these types of bugs are only found to the extend in that they affect the functional behavior, and since traditional testing is focussed on checking the functional behavior of the system, finding these types of bugs is more often a welcomed side-effect, rather than intentional. because static program analysis can pinpoint those software deficiencies directly, and because it is scalable to large code bases and can be run fully automatically, it is a way to complement traditional testing.



by modern static analysis tools. we briefly describe the underlying technology of our own analyzer goanna in section 3. the focus of this work is section 4 where we discuss the dimensions for classifying bugs, give example deficiencies, as well as measures for improvement. section 5 presents empirical data based on analyzing firefox, before section 6 concludes the paper.



naturally, the more information that is available, the better the analysis results become. however, from a practical point of view collecting and computing semantic information can result in excessive computation, and slow down the analysis to a point where it is not scalable to larger programs. in most circumstances a static analysis tool is only regarded as useful if the analysis time is roughly in the same order of magnitude as the compilation process and not several orders of magnitude higher.



while may-analysis can turn up significantly more bugs, the detected bugs may not exist in the actual program behavior due to infeasible paths or infeasible data dependencies. in this context these warnings are called false positives(or false alarms). must-analysis, however, might miss bugs due to the nature of underapproximation. we call these false negatives.



to complicate matters further, modern static program analyzers often mix overand under-approximations within the same analysis. for instance, the semantics of pointer arithmetic might be under-approximated and the semantics of a loops overapproximated. while not sound, those frameworks have proven to be most effective in turning up many bugs without generating many false alarms at the same time. another complication is that the term false alarm is often used in a different way, motivated from the point of view point of a developer, or from the point of view of a tester. section 4 discusses these alternative uses.



is only violated if the resource p is used on all paths after being freed. while this relaxed property does not pick up as many bugs as the previous one, it also does not create as many false alarms. this is one way to tune a static program analyzers.



tuning the strictness of different checks can be one way to improve the bug/falsealarm ratio, another option is to add more semantic information and reflect the fact that it is semantically impossible to access p after a free operation. we implemented a false path elimination strategy based on interval constraint solving that does exactly this. hence, our implementation can use the first check to find all possible bugs and still rule out many false positives automatically.



we implemented the whole framework in our tool goanna. goanna is able to handle full c/c++ including compiler dependent switches for the gnu gcc compiler and uses the open source model checker nusmv as its generic analysis engine. the run-times are typically in the order of the compilation, i.e., we experience an



with local path-sensitive analysis a warning is a true positive if there exist input to the function, such that the error path becomes possible. with a context-sensitive analysis a warning is only a true positive, if the rest of the system is actually able to provide such an input. if the rest of the system can guarantee that such an input is impossible, the subsystem can use this as an assumption, and guarantee correct behavior under this assumption.



in the remainder we will discuss each of these categories in detail and provide details to illustrate that the categories are not necessarily correlated, e.g that severity can be independent from incidence. all examples are taken from the firefox code base.



the severity of a warning can be either high, medium or low, and this is typically how developers categorize bugs. security flaws, even if they have benign causes or only occur under very specific circumstances, can be more severe than errors that have an immediate impact on functionality. a warning might have medium or high severity, even if close manual inspection cannot establish conclusively, whether there is an actual execution producing the bug. just the chance for the deficiency to create a run-time bug is sufficient reason to change the code.



the case in this example. variable numtoks is an unsigned integer, which suggests the index should be bounded to positive integers, and it is unclear if the predecessor array for tokens is defined in any meaningful way. for this reason this warning was classified to have medium severity.



catching bugs depending on their incidence can best be tuned by the analysis algorithms used. must-analysis is good at picking up bugs that will always occur, while may-analysis picks up potential bugs on single executions. moreover, a pathsensitive analysis can filter out those combinations of conditions that are infeasible in the execution. to get a better understanding of inputs from other parts of the program and to increase the precision of the analysis a full context-sensitive approach should be used.



goanna supports the fine tuning of properties by reasoning about some program path or all paths as described in section 3. moreover, goanna can automatically eliminate infeasible paths that are caused by a set of excluding conditions. goanna does not perform full context-sensitive analysis, yet. however, one can argue that every function should be implemented defensively, i.e., inputs should be checked before being used to avoid unexpected crashes.



reducing false alarms resulting from intraor inter-procedural over-approximations can best be addressed by finer abstractions and specialized analysis algorithms. in the example above creating a fine grained cfg for the analysis of short circuit operators can help. moreover, a specialized inter-procedural pointer analysis taking aliasing into account can also aid in reducing context-sensitive over-approximations. often, incorrect warnings are caused by one of the many exceptions, and corner cases that exist in c and c++. in this case it is usually sufficient to refine the syntactic description of the properties on an intra-procedural level. this technique is also effective to cover coding practices that are not according to standard, but nevertheless common.



our implementation is written in ocaml and we use as the back-end model checker nusmv 2.3.1. the current implementation is an early version consisting mostly of intra-procedural analyses for full c/c++. at the moment we have implemented 18 different classes of checks. these checks cover, among others, the correct usage of malloc/free operations, use and initialization of variables, potential null-pointer dereferences, memory leaks and dead code. the ctl property is typically one to two lines in the program and the description query for each atomic proposition is around five lines because of the need to cover many exceptional cases.



we evaluate our tool with respect to run-time performance, memory usage, and scalability, by running it on a regular basis over nightly builds of the mozilla code base for firefox. the code base has 1.43 million lines of of pure c/c++ code, which becomes 2.45 million non-empty lines after preprocessing. the analysis time including the build process for firefox is 234 minutes on a dell poweredge sc1425 server, with an intel xeon processor running at 3.4 ghz, 2 mib l2 cache and 1.5 gib ddr-2 400 mhz ecc memory.



firefox. this was obviously an accepted coding practice, to achieve consistency throughout the code base, rather than being accidental omissions or errors. it is interesting to note that all of these warnings were semantically correct, pointing to behavior that occurs always, and thus are true positives from a language semantics point of view. however, from a user perspective these warnings are of a very low severity.



while a virtual function call in a destructor does not necessarily cause a problem, it might result in memory leaks, and is considered bad coding practice, regardless of the effects. our analysis of the firefox code base found 114 instances of such usages. from those warnings, 105 refereed to the same macro that was used over and over again, and thus caused as many warnings after preprocessing. this points to another way to improve the usability of static analysis tools, namely to present to the user with a concise set of warnings. except for this duplication of warnings, the check itself was kept unchanged, as all of the warnings are considered valuable.



overall, we achieved an 83% reduction in false alarms and very low severity warnings by mostly changing the precision of our rules. this was achieved by taking care of particular programming styles and strengthening our ctl properties. encoding checks as ctl properties and switching from a mayto a must-analysis easily by changing the path quantifier proved crucial to quickly adjust the granularity where needed.



currently, our reported defect density is around 3.2 warnings per 1000 loc for the firefox code base. the best state-of-the art checkers provide a defect density of around 0.35 for firefox. while there appears to be a significant gap between those two numbers, when neglecting low impact properties such as unused values and taking into account must-properties only, we achieve a defect density of 0.36. however, those numbers can only serve as a rough comparison, because we do not know about the exact checks commercial tools are implementing, their reporting strategy or the exact techniques used. nonetheless, understanding programming styles, severity of bugs and the importance of scalability are in a first analysis step more important than deep semantic analysis techniques.



in this work we presented our experiences in tuning static program analysis for large software systems. in particular we gave a classification of properties and bugs based on our practical experiences in keeping the warning rate down to report relevant issues. we advocate that a crucial first step is to get familiar with programming styles and the oddities in real code and to fine tune syntactic checks accordingly instead of applying an expensive semantic analysis right from the beginning. typically static program analysis returns a manageable set of warnings. in a future step, only this set should be subjected to full context-sensitive analysis to keep the overall analysis scalable.



related to our work is an evaluation and tuning of static analysis for null pointer exceptions in java as described in. the authors show that many null pointer bugs can be found on a syntactic level without sophisticated semantic analysis. they show that fine tuning syntactic checks is the key for good analysis results. a similar conclusion has been drawn in where the authors studied coding patterns and



more information about prominent commercial static analyzers can be found in. the authors compare a number of tools and point out their strength and weaknesses as well as their experiences of using them within ericsson. a more general comparison of some static program analyzers including a discussion on bugs can be found in[21,20,22].



