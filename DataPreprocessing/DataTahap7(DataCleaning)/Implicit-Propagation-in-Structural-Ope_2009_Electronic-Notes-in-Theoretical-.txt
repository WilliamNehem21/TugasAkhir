in contrast to a transition system specification in process algebra, a structural operational semantics(sos) of a programming language usually involves auxiliary entities: stores, environments, etc. when specifying sos rules, particular auxiliary entities often need to be propagated unchanged between premises and conclusions. the standard technique is to make such propagation explicit, using variables. however, referring to all entities that need to be propagated unchanged in each rule can be tedious, and it hinders direct reuse of rules in different language descriptions.



this paper proposes a new interpretation of sos rules, such that each auxiliary entity is implicitly propagated in all rules in which it is not mentioned. the main benefits include significant notational simplification of sos rules and much-improved reusability. this new interpretation of sos rules is based on the same foundations as modular sos, but avoids the notational overhead of grouping auxiliary entities together in labels.



structural operational semantics(sos) is a well-known framework for describing both static and dynamic semantics of programming and specification languages. this paper is about how its pragmatic aspects can be significantly improved, and assumes familiarity with the standard framework(see e.g.[1,8,22,24]).



the conclusion. notice that the order in which the premises are written in the abbreviated rule determines the(intended) order of evaluation of the sub-expressions e1,..., en, in contrast to the usual treatment of premises as an unordered set. a further convention, called the exception convention, is introduced to provide implicit propagation of exceptions; but propagation of the environment is left explicit. the introduction of the two conventions seems somewhat ad hoc, and it appears that they have not been adopted in sos descriptions of other languages.



implicit propagation of unmentioned variables is a familiar concept from imperative programming languages. it has previously been exploited in various semantic frameworks, including abstract state machines, action semantics, monadic semantics, attribute grammars and, most recently, k. our contribution here is the formal incorporation of implicit propagation in the popular structural style of operational semantics.



section 2 recalls the foundations of sos and msos, then defines how sos specifications are interpreted as msos specifications, allowing implicit propagation. section 3 considers familiar examples of sos specifications from the literature, and shows how much simpler they are when reformulated using implicit propagation. section 4 concludes with a summary of the contribution of the paper, and indicates plans for future development.



as more appropriate for the static semantics of programming languages(also for the semantics of non-computational specification languages, e.g. casl), and unsuitable for the dynamic semantics of languages that involve concurrency or interleaved effects. note however that the two styles can be used together in the semantics of the same language(e.g. small-step for command execution, big-step for expression evaluation).



the sorts in sl classify the phrases of the language(commands, expressions, etc.), the function symbols in tfl correspond to phrase constructors, and subsort inclusions correspond to direct inclusions(e.g. of identifiers in expressions). for example, consider the following constructs:



an sos specification extends the specification of abstract syntax and auxiliary entities by introducing some relation symbols, and defining the relations inductively by rules. in process algebra, transition system specifications usually involve ternary relation symbols(corresponding to labelled transitions between states) and unary predicate symbols(corresponding to subsets of states), and the introduction of the symbols is often left implicit. in descriptions of programming languages, in contrast, the argument sorts of relation symbols tend to be less homogeneous, and the explicit introduction of the relation symbol being defined by a set of rules is common practice(cf.).



we consider only positive rules in this paper(partly for simplicity, but note also that rules with negated judgements are generally eschewed in sos descriptions of programming languages). then, by the classic theory of inductive definitions, the interpretation of relation symbols defined by rules always exists. it corresponds to the semantics of a structured free-extension specification in casl, where the inference rules are expressed as universally-quantified implications(under the assumption that the sets of premises are finite).



a semantic relation symbol can be introduced more than once in an i-msos specification. we assume that each time the same relation symbol is introduced, the same variables are used to indicate its argument sorts; this ensures that the sorts of the argument terms in an application r(t1,..., tn) uniquely determine the variables x1,..., xn used to introduce r.



