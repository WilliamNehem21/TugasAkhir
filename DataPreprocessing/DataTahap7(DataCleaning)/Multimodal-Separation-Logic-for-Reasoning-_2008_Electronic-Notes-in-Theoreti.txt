in the next section, we will describe the general form of programming language semantics we treat. the following several sections will present examples of different programming languages of increasing complexity. the needs of each particular language will be used to motivate various features of our model. we will adopt a fairly informal tone and will focus on practical applications of the techniques.



we have chosen to reason about deterministic small-step operational semantics. operational semantics are fairly easy to construct both for low-level programming languages such as assembly language as well as higher level languages. operational semantics, as a specification language, may be more likely to correspond to the intended meaning of low-level languages than(for example) axiomatic semantics. we chose to reason about small-step semantics because we are specifically interested in languages which feature shared-memory concurrency; using a big-step operational semantics makes reasoning about possible interleavings difficult. finally, we stipulate that the semantics be deterministic for convenience in reasoning: we can then do simple induction over the number of steps taken rather than doing induction over all possible paths. we fit nondeterminism into this framework by using oracles to determinize; see section 7 for an example.



the final component of a traditional kripke model is a binary relation on worlds, r, called the accessibility relation. the accessibility relation is used to give semantics to the modal operators of the logic. accessibility relations in multimodal logics are quite interesting, as we will discuss in section 4.



as we mentioned in section 2, a traditional kripke semantics of modal logic consists of three parts: a set of worlds, a forcing relation, and an accessibility relation. there is a long history in the literature of presenting kripke semantics this way[19,17]. however, such a presentation is biased toward logics with a single modality(and perhaps its negation dual). experience has shown us that this is too restrictive. we instead wish to have a variety of modalities for different purposes.



note there is a subtle difference between this definition and our earlier attempted definition; we have inserted a later operator into the definition of listf. this extra later is responsible for making the definition of listf contractive, and thus allows us to use the fold_unfold lemma to prove list_unfold. in practice, the later would normally be incorporated into the semantic definition of pair, which is naturally contractive.



definition empty: resource_map:=... definition join( w1 w2 w: world): prop:=... definition emp:= fun w=> world_phi w= empty. definition sep_conj( p q: pred):= fun w=>



a safety or partial-correctness proof in csl will naturally prove that the program does not get stuck in this operational semantics. the resource invariants are assertions of the object logic, csl; that is, we model them as predicates on worlds. therefore, these predicates can not only say what addresses are controlled by the lock, but what invariants hold on the contents of memory at those addresses at any time that the lock is unlocked; while a thread holds the lock, it need not satisfy the invariant.



now that we have a workable definition of resource maps, we can define joinability. first of all, two resource maps must be of the same age to join. next, it must be the case that the resources at each location join pairwise. two resources join if they are compatible and their shares join. two regular value resources are always compatible, and two lock resources are compatible iff their resource invariants are the same. value and lock resources are incompatible. as before, we lift the join



the languages studied by pratt were also rather simple; for example, in one of his early papers on the topic, pratt studied the language generated by a basic assignment operation and the regular language operators(union, concatenation and kleene closure). in a later paper, other basic operations were added, but kleene closure remained the only way to generate iterative behavior. although the set of programs that can be generated by regular grammars are interesting, they do not correspond well to languages programmers are accustomed to using.



sadrzadeh has encoded a modal linear logic in coq using the deep embedding approach. this logic lacks quantification, and although it is also a multimodal logic, all the modalities are assumed to be s4(reflexive and transitive). using her embedding, sadrzadeh demonstrates proofs of classic puzzles in epistemic logic.



a powerful testament to the strength of our techniques is their success in a real-world proof: the soundness proof for the operational semantics of concurrent cminor. at approximately 50,000 lines of coq code, the proof is a sizable software-engineering artifact. more importantly, however, the proof is an interesting result about a realistic programming language. as we increasingly used modal techniques in this proof, it went from infeasible to feasible, then became smaller and more manageable. as we continue to rewrite this proof, we expect that an increased and more consistent use of modal techniques will continue to simplify and modularize the proof, decreasing its size and increasing its elegance.



