besides of the frameworks, which are beyond the scope of this article, one can also perform refinement proofs by means of model checks if the space of the reachable system states does not exceed a certain finite number(cf.[1,24]). the advantage of model checker application to the frameworks is that the proofs can be performed in a highly automated fashion. since uml-based system descriptions tend to describe systems in a relatively abstract manner, we expect that the modeled state space of many real-life systems can be handled by a model checker. therefore we decided to apply the powerful checker tlc(temporal logic checker)[24,33], to perform the refinement proofs. tools for the transformation of uml specifications into ctla[9,11] and of ctla specifications into tla exist. the transformation utilizes the compositional features of ctla extensively since a uml diagram can be transformed into a separate ctla process. our approach complements a lot of other approaches formalizing uml diagrams by formal models(cf.[25,28,30,31]) which, however, do not use compositionality in the way explained in this paper.



a read write action is used to perform read and write access to structural features like object attributes and properties, to create and destroy objects, and to handle links between objects. derivations are structural feature actions to handle access to structural features, object actions to manage the life cycle of an object, and association actions in order to operate on links and associations. an example of the first subclass is readstructuralfeature retrieving the values of a uniquely identified and not statical structural feature of a certain target object. so called object actions are responsible for the creation and destruction of objects. a createobjectaction is an action which creates an object conforming to a class. the destruction of objects is performed using a destroyobjectaction.



systems and subsystems are described as compositions of concurrent processes. as in the iso/osi specification language lotos, a set of processes interact in a rendezvous-like way by performing actions jointly, and the data parameters of the actions can model the communication of values between processes. each process encapsulates its variables and changes its state by atomic execution of its actions. the system state is the vector of the process each object instantiated from the corresponding uml class according to its statechart diagram. our transformation of a statechart to a ctla process is based on the concept of run-to-completion semantics(cf.) which assumes that only one thread of control is active in an object at a certain point of time. this concept forces the interleaving of concurrent processes.



the transformation is performed in two steps. at first, we flatten a state chart to another state chart containing only simple states and pseudostates. this is done by application of graph grammars(cf.). in this step, we also consider the actions defined in a state. actions of entry activities are shifted to every activity of an ingoing transition. in contrast, an action of an exit activity belonging to a state is shifted to every activity of an outgoing transition. do activities are not supported since they invoke concurrent computations which can be interrupted at any point of time. this, however, violates our assumption of run-to-completion semantics for a state machine.



contained in qu. a state variable sync used to block an object initiating a synchronized calls. moreover we introduced the state variable lifecycle describing the lifecycle state of an object 3. possible values of lifecycle are unborn, alive, and dead. unborn and dead objects are neither able to compute a result nor to take part in an interaction. moreover, for every pin of an action we added a set of state variables. one variable is used to store the data transferred via the pin. for the sake of simplicity, we restrict the range of pin types to simple data types. another variable states if the pin is currently filled by a data or control value.



ctla actions that change the value of the state variable lifecycle if the creation and destruction of objects is handled in the corresponding uml model. the ctla action which creates an object sets the value of the state variable lifecycle to alive if it has the value unborn. an additional action is used to change the value of lifecycle to dead if an object has to be destroyed and the value of lifecycle is alive.



similar to an operation call, the corresponding operation reply is also modelled by two coupled ctla actions. in the uml, however, an incoming reply transmission is accepted by the same calloperationaction which also triggered the initial call. since this non-atomic behavior cannot be specified by a single ctla action, we describe calloperationactions by two ctla actions modelling the execution of an operation call resp. the acceptance of the reply transmission. in the process adapter the actions callcontrol and callcontrolreply are both used to model a single calloperationaction.



