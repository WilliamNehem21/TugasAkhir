program transformation is used in a wide range of applications including compiler construction, optimization, program synthesis, refactoring, software renovation, and reverse engineering. complex program transformations are achieved through a number of consecutive modi cations of a program. transformation rules de ne basic modi cations. a transformation strategy is an algorithm for choosing a path in the rewrite relation induced by a set of rules. this paper surveys the support for the de nition of strategies in program transformation systems. after a discussion of kinds of program transformation and choices in program representation, the basic elements of a strategy system are discussed and the choices in the design of a strategy language are considered. several styles of strategy systems as provided in existing languages are then analyzed.



this survey aims at understanding the similarities and di erences between systems for program transformation by analyzing existing systems on the basis of publications. many aspects of program transformation such as parsing, pretty-printing and formulating basic transformations are fairly well understood. therefore, this survey concentrates on transformation strategies, i.e., the control part of transformation systems that determine the order of application of basic transformation steps.



a program is a structured object with semantics. the structure allows us to transform a program. semantics includes the extensional and intensional behavior of a program and gives us the means to compare programs and to reason about the validity of transformations. a programming language is a collection of programs that comply with the same set of structural and semantic rules. this is a rather broad de nition that is intended to cover proper programming languages(with an operational interpretation), but also data formats, domain-speci c languages, and aspects of programs such as their controlor dataow.



programming languages can be clustered into classes with structural and/or semantic similarities. one of the aims of a general framework for program transformation is to de ne transformations that are reusable across as wide a range of languages as possible. for example, the notions of variable and variable binding are shared by all programming languages. transformations dealing with variables such as bound variable renaming, substitution, and uni-



program transformation is the act of changing one program into another. the term program transformation is also used for a formal description of an algorithm that implements program transformation. the language in which the program being transformed and the resulting program are written are called the source and target languages, respectively.



program transformation is used in many areas of software engineering, including compiler construction, software visualization, documentation generation, and automatic software renovation. in all these applications we can distinguish two main scenarios, i.e., the one in which the source and target languages are di erent(translations) and the one in which they are the same



the purpose of reverse engineering is to extract from a low-level program a high-level program or speci cation, or at least some higher-level aspects. reverse engineering raises the level of abstraction and is the dual of synthesis. examples of reverse engineering are decompilation in which an object program is translated into a high-level program, architecture extraction in which the design of a program is derived, documentation generation, and software visualization in which some aspect of a program is depicted in an abstract way.



rephrasings are transformations that transform a program into a di erent program in the same language, i.e., source and target language are the same. in general, rephrasings try to say the same thing in di erent words thereby aiming at improving some aspect of the program, which entails that they change the semantics of the program. the main subscenarios of rephrasing are normalization, optimization, refactoring, and renovation.



a normalization reduces a program to a program in a sublanguage, with the purpose of decreasing its syntactic complexity. desugaring is a kind of normalization in which some of the constructs(syntactic sugar) of a language are eliminated by translating them into more fundamental constructs. for example, the haskell language de nition describes for many constructs how they can be desugared to a kernel language. other examples are module example in the sdf2 normalizer. simpli cation is a more general kind of normalization in which a program is reduced to a normal(standard) form, without necessarily removing simpli ed constructs. for example, consider transformation to canonical form of intermediate representations and algebraic simpli cation of expressions. note that normal form does not necessarily correspond to being a normal form with respect to a set of rewrite rules.



a refactoring is a transformation that improves the design of a program by restructuring it such that it becomes easier to understand while preserving its functionality. obfuscation is a transformation that makes a program harder to understand by renaming variables, inserting dead code, etc. obfuscation is done to hide the business rules embedded in software by making it harder to reverse engineer the program.



a program transformation system is determined by the choices it makes in program representation and the programming paradigm used for implementing transformations. the next section discusses considerations in choosing a representation for programs. the remaining sections consider implementation of transformations.



finally, a program representation should be supported by an exchange format that makes it possible to exchange programs between transformation components. example formats are xml, which supports exchange of tree shaped data, and the annotated term format, which supports exchange of dags, maintaining maximal sharing. see for a bibliography of exchange formats.



nates an unused variable de nition. the extract rule abstracts an expression into a function. the hoist rule de nes lifting a function de nition out of a variable de nition if the variable is not used in the function. using this set of rules di erent transformations can be achieved. for example, a constant propagation strategy in an optimizer could use the inlinev and dead rules to eliminate constant variable de nitions:



rules are based on the semantics of the language. a rule generally preserves the semantics of the program. that is, before and after the application of a rule the program has the same meaning. usually the observable behavior of the program is preserved, but some other aspect is changed. optimizations, for example, try to decrease the time or space resource usage of a program. applying constant propagation can decrease the need for registers, for instance. extracting a function during refactoring can improve the readability of the program.



a rule consists of recognizing a program fragment to transform and constructing a new program fragment to replace the old one. recognition involves matching the syntactic structure of the program and possibly verifying some semantic conditions. the replacement in a rule can consist of a simple term pattern, a function that constructs a new tree or graph, or a semantic action with arbitrary side-e ects.



for these reasons, enhancements of the basic pattern matching features have been implemented or considered for several languages. for example, list matching in asf+sdf is used to divide a list into multiple sublists possibly separated by element patterns. associative-commutative(ac) matching in obj, maude and elan supports the treatment of lists as multisets. higher-order uni cation in prolog[37,45] allows higher-order matching of subterms in an arbitrary context[22,29], which in turn allows matching of subterms at arbitrarily deep levels using higher-order variables without explicit traversal of the structure involved. views for haskell, as proposed in, provide a way to view a data structure using di erent patterns than are used to represent them. overlays in stratego are pseudo-constructors that abstract from an underlying representation using actual constructors.



depending on the goal of a transformation task, a path should be chosen in the rewrite relation. for a speci c program it is always possible to nd the shortest path to the optimal solution for a speci c transformation task. however, for most transformation tasks the process of nding a path needs to be automated, and optimal solutions might only be approximated. a strategy is an algorithm for choosing a path in the rewrite relation. given one set of rules, there can be many strategies, each achieving a di erent goal. on the other hand, a general strategy can be applicable to many di erent sets of rules.



in the case of speculative exploration some kind of non-deterministic choice between two alternative paths is needed. on failure in one of the paths, the other path is taken. if backtracking is local, the choice is made after one of the chosen branches succeeds. if back-tracking is global, failure at any point



although we have distinguished rules at the conceptual level, at the implementation level rules and strategies can be intertwined, i.e., the rules can be hardwired in the de nition of the strategy. alternatively, rules and strategies can be de ned separately, which entails that strategies are parameterized with a set of rules.



in intentional programming a program is represented by a source tree instead of by a source text. each node of a source tree has a reference to its declaration(thus making the tree into a source graph). for example, an occurrence of a variable has a link to its declaration. likewise each language construct, or intention, corresponds to a tree node that de nes it. intentions can be used by making links to the de nitions of the intentions. for example, a while statement is a node with two children corresponding to the condition and the iteration statement together with a link to the while intention. domain-speci c programming abstractions can be captured by de ning new intentions.



source trees are implemented by reducing them to source trees using only r-code intentions. r-code intentions are basic constructs that can translated to some form of machine code by a code generator. part of the de nition of each intention is a method reducing it to its r-code. the dependencies between these reduction methods are computed and interpreted by the intentional programming engine to reduce an entire program to its r-code.



tree parsing is analogous to string parsing; instead of nding structure in a string, the goal is to nd structure in a tree by covering the tree with patterns. sorcerer[42,43] is the tree parser generator for the antlr language processing system. sorcerer generates tree walkers from tree grammars. a tree grammar is a bnf-like notation for the de nition of tree structures. for example, the grammar



if a tree grammar is ambiguous, multiple parses of a tree are possible. the parser needs to decide which parse to take. by associating costs to each production, the disambiguation can be based on the accumulated cost of a tree. dynamic programming techniques can be used to compute all possible parses in one traversal.



as illustrated by this example, more than one covering of a tree is possible, corresponding to di erent ways to generate code. each node can have several di erent parses because of overlapping patterns and chain rules. the costs associated with the productions express the cost of executing the associated machine instruction. the goal of a code generator is to nd the lowest cost covering(i.e., lowest execution time) of an intermediate representation expression tree.



a redex is a subterm that matches with a rewrite rule. a term is in normal form if it has no redices. rewrite engines for term rewrite systems compute the normal form of terms with respect to sets of rules in speci cations. this involves exhaustively applying rules to subterms until no more rules apply. a rewrite engine can employ di erent strategies to order the application of rules. in innermost rewriting all subterms of a term are normalized before rules are applied to the term itself. in outermost rewriting redices closest to the root of the term are rewritten rst. this implies that rules are automatically applied



the dnf function mimics the innermost normalization strategy by recursively traversing terms. the auxiliary functions not and and are used to apply the distribution rules and the negation rules. in functional programming such auxiliary functions are known as smart constructors. in the de nition of the rules for and and not it is assumed that the arguments of these functions are already in disjunctive normal form. for example, if none of the arguments of and is an or term, the term itself is considered to be in dnf.



needed. rules and3 and not4 are default rules that only apply if the other rules do not apply. without this mechanism even more rules would have had to be used to handle the cases were the real transformation rules do not apply. default rules were introduced in asf+sdf.



asf+sdf provides a limited set of traversals. for traversal strategy there is a choice between top-down and bottom-up. the latter has been explained above. a top-down traverses down the tree and stops as soon as a rule applies. in addition a traversal can be a transformation(trafo) and/or a traversal which accumulates information along the way(accu). finally, traversal



first of all, there is no separation of rules from strategies. a rule is bound to one speci c traversal via the traversal function. it is not possible to reuse rules in di erent traversals, for example, to normalize under di erent rule sets. furthermore, rules are intertwined with strategies, making it hard to distinguish the basic transformation rules from the traversal code, and to argue about correctness of the whole.



finally, the traversals provided by the language capture an abstraction, i.e., certain traversal schemata. there is no possibility in the language to give further abstractions for alternative traversal schemata, or for more elaborate functionality involving traversals. this is desirable for building libraries with language independent strategies. for example, de ning substitution without variable capture is similar for many languages, given the shape of variables and variable bindings. extrapolating the traversal function approach, more and more such abstractions will be captured as additional primitives in the rewrite engine. at some point it will make sense to extend the language with a mechanism for specifying such abstractions generically.



the e-strategy of the cafeobj system uses an extended form of strategy annotations in which not all arguments need to be evaluated. in this style a strategy annotation is a list of argument positions and the root position(0). the annotation declares the order of evaluation of the arguments. the root position 0 indicates the evaluation of the term at the root. not all argument positions need to be declared. an undeclared argument is not evaluated.



elan is a language for rewriting with user-de nable strategies in a special strategy language. an elan speci cation consists of a set of unlabeled rewrite rules, which are applied using a xed innermost strategy, and labeled rules, which are applied by user-de ned strategies. rewrite rules support matching modulo associativity and commutativity.



a strategy expression combines several rule labels by means of strategy operators. the application of a strategy to a term leads to a set of results. an empty set of results denotes failure. evaluation of a term involves normalizing the term according to the unlabeled rules, and then applying a strategy to it. strategies exist at two levels: the elementary strategies built into the language that can be used to apply labeled rules and de ned strategies, which



a build!t replaces the subject term with the instantiation of the pattern t using the current bindings of terms to variables in t. a scope{x1,...,xn: s} makes the variables xi local to the strategy s. this means that bindings to these variables outside the scope are undone when entering the scope and are restored after leaving it. the operation where(s) applies the strategy s to the subject term. if successful, it restores the original subject term, keeping only the newly obtained bindings to variables.



a strategy de nition f(x1,...,xn)= s introduces a new strategy operator f parameterized with strategies x1 through xn and with body s. labeled transformation rules are abbreviations of a particular form of strategy de nitions. a conditional rule l: l-> r where s with label l, lefthand side l, right-hand side r, and condition s denotes a strategy de nition l={x1,...,xn:?l; where(s);!r}. here, the body of the rule rst matches the left-hand side l against the subject term, and then attempts to satisfy the condition s. if that succeeds, it builds the right-hand side r. the rule is enclosed in a scope that makes all term variables xi occurring freely in l, s and r local to the rule.



the languages discussed in this paper are closely related to the term rewriting paradigm. since any implementation of program transformation is ultimately a form of rewriting, languages dedicated to transformation will likely be based on rewriting. however, program transformation systems are also programmed in other paradigms. an extended survey should also investigate how strategies are modeled in these paradigms. the strategies discussed in this paper control transformation by explicitly ordering the application of rules. another approach is to let constraints or goals guide the application of rules.



strategies are used to control the application of rewrite rules in order to prevent undesired interference between transformations. the design of strategies is based on an analysis of this interference. often this analysis is informal. for pure, unconditional rewrite rules, analysis techniques exist for discovering such interference. for more complex transformation rules such analysis is needed as well.



generic strategies parameterized with rules or other strategies often have to renormalize/retraverse terms. in an optimization for the case of the generic de nition of innermost is given. there is a general need for fusion of generic traversals.



origin tracking for term rewriting relates a normalized term to the original term. applications include error messages and layout reconstruction. how can we compute origins in a system with strategies? in systems with a clean separation between rules and strategies it should be possible to make the inheritance of origin information transparent to strategies.



p. borovansky, c. kirchner, and h. kirchner. controlling rewriting by rewriting. in j. meseguer, editor, proceedings of the first international workshop on rewriting logic and its applications, volume 4 of electronic notes in theoretical computer science, asilomar, paci c grove, ca, september 1996.



m. clavel, s. eker, p. lincoln, and j. meseguer. principles of maude. in j. meseguer, editor, proceedings of the first international workshop on rewriting logic and its applications, volume 4 of electronic notes in theoretical computer science, pages 65{89, asilomar, paci c grove, ca, september 1996.



m. clavel and j. meseguer. re ection and strategies in rewriting logic. in j. meseguer, editor, electronic notes in theoretical computer science, volume 4. elsevier science publishers, 1996. proceedings of the first international workshop on rewriting logic and its applications. 5.10



a. felty. a logic programming approach to implementing higher-order term rewriting. in l.-h. eriksson, l. hallnas, and p. schroeder-heister, editors, extensions of logic programming(elp'91), volume 596 of lecture notes in arti al intelligence, pages 135{158. springer-verlag, 1992. 4.1



e. visser. stratego: a language for program transformation based on rewriting strategies. system description of stratego 0.5. in a. middeldorp, editor, rewriting techniques and applications(rta'01), volume 2051 of lecture notes in computer science, pages 357{361. springer-verlag, may 2001. 5.11



