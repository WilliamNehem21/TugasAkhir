In this paper, we present a game-theoretic framework for understanding concurrent separation logic (CSL). We assign a specification game to each execution trace involving the interaction between the program code and the surrounding environment. In this game, a player named Eve represents the code, and another player named Adam represents the environment. Their objective is to partition each state in the execution trace into three distinct parts—one for the code, one for the environment, and one representing shared resources. The key contribution of this paper is demonstrating the correctness of concurrent separation logic by showing that every proof in CSL corresponds to a winning strategy in the specification game.

This game-theoretic perspective builds on and extends previous work on the soundness of CSL, which ensures that a program starting in a state satisfying certain preconditions will reach a state satisfying specific postconditions, provided all memory resources obey the defined CSL invariants. Previous proofs of CSL soundness have been subject to intense scrutiny within the community and have been approached from various angles—semantics, syntax, and axiomatic frameworks—and have also been formalized in proof assistants. A central challenge of these proofs is validating the concurrent rule of CSL.

Our work intentionally focuses on a game-theoretic approach to simplify and concretize the understanding of concurrent separation logic. We deliberately avoid delving into more complex and axiomatic versions of CSL, such as Iris.

We specifically discuss the parallel composition operator "c1 ‖ c2", which allows two programs, c1 and c2, to execute simultaneously and interact via mutexes that we refer to as resources. These resources are declared with the syntax "resource r" and acquired by using the construct "with r when b do c". This requires the Boolean expression b to be true before proceeding, ensuring that at any given moment, a mutex is controlled by only a single thread.