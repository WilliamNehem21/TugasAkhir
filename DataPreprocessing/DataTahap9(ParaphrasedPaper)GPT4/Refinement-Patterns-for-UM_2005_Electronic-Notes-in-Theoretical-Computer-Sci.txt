The academic paper describes how certain expressions in the OCL (Object Constraint Language) can be translated into a different constraint language, LOCA. The expressions mentioned involve working with class instances and states:

- In LOCA, you can denote `x.oclIsKindOf(t)` from OCL as `x: t` for any given class name `t`.
- `x.oclInState(s)` from OCL can be represented in LOCA as `x.att = s`, where `s` is a state from the state machine associated with the class and `att` is an attribute signifying the current state.
- The OCL expression `c.allInstances()` is simply denoted by the class name `c` itself in LOCA.

The paper goes on to define a set of comparison operators `op2` (such as equal to, not equal to, less than, greater than, etc.) and logical operators `op3` (including "and" and "or"). Additionally, it details temporal operators used to describe constraints over time, including operators to refer to all next states (`AX`), some next state (`EX`), some future state (`AF` and `EF`), and all future states (`AG` and `EG`).

Identifiers within the language can be names of classes, functions, class features (attributes, operations, or role names), enumerated types elements, or represent variables/constants (with constants being in uppercase). Variables are understood to be universally quantified throughout the entire formula.

The paper also discusses declarative constraints, which are invariant properties of a system that do not favor specific algorithms for maintaining them. These constraints create a computation-independent model (CIM) within the context of Model-Driven Architecture (MDA). The paper explains that more explicit operational models can be derived from such CIMs.

In terms of UML (Unified Modeling Language) models, the paper suggests that systematic transformations can be applied to refine the models, making them closer to actual implementations on specific platforms. Examples of such transformations could be the removal of association classes, which are generally not expressible in mainstream object-oriented programming languages, or the alteration of many-to-many associations for compatibility with a relational data model. These types of transformations may follow certain patterns.