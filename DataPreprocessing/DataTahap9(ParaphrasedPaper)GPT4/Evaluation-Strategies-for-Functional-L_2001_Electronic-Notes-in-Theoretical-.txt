The recent progress in functional logic programming languages has been driven by substantial breakthroughs in narrowing evaluation strategies. Narrowing is a computation process similar to rewriting, but it also produces substitutions alongside normal forms. Functional logic programming typically applies narrowing to subclasses of constructor-based, and sometimes conditional, rewrite systems. Many effective narrowing strategies, particularly for the smallest subclasses of constructor-based rewrite systems, are extensions of well-known rewriting strategies. Yet, some strategies tailored for larger, non-confluent subclasses have been developed specifically for functional logic computations.

This paper examines the fundamental elements that shape evaluation strategies within functional logic programming. It outlines key classes of rewrite systems that are used to model functional logic programs, illustrates their varying levels of expressiveness, and evaluates the properties of different narrowing strategies suitable for each rewrite system category.

Functional logic programming merges the features of functional and logic programming into one paradigm, and a functional logic program resembles a constructor-based conditional rewrite system. Despite some liberties with notation for the sake of examples, the paper notes that the functional logic version of a program is typically more concise and simpler than its pure logic or pure functional counterparts. The streamlined nature of functional logic programs can be attributed to features such as non-determinism and semantic unification—which are absent in purely functional or logic programs.

A rewrite system is defined as a pair \( ( \Sigma, R ) \), where \( \Sigma \) is a signature divided into constructors and defined operations or functions, and \( R \) is a set of rewrite rules. A narrowing strategy is then described as a method to determine which steps must be applied to a term within a constructor-based rewrite system. This strategy maps a term to a set of triples, each representing a potential narrowing step.

The paper goes on to discuss needed narrowing, an optimal strategy by which every computed substitution is unique across distinct derivations. Additionally, the paper explores how de finitional trees, imperative for driving evaluation strategies, connect patterns in parent-child relationships for effective computation.

In functional logic programming, the language must support the programmer in specifying the desired semantics for non-deterministic computations, whether it be a call-time or need-time choice semantics. Moreover, while most classes of rewrite systems discussed are unconditional, the paper mentions the possibility of extending evaluation strategies to conditional rewrite systems by transforming them into unconditional ones—thus retaining the applicable strategies' beneficial properties.

Finally, the paper touches on transformational approaches to higher-order computations, suggesting transformations from extended to ordinary rewrite systems to retain desirable properties while managing more complex functionalities.

In conclusion, the paper provides insight into the evaluation strategies for functional logic programs, emphasizing that constructor-based rewrite systems serve as effective models because they allow computations using functions defined over algebraic data types, and noting that strategies for conditional and higher-order rules remain areas for further development.