The Object Constraint Language (OCL) has not been widely adopted in the industry mainly due to the lack of integrated tool support. To address this, we introduce a prototype tool that can analyze OCL constraints together with UML (Unified Modeling Language) models and translate them into the language used by the PVS (Prototype Verification System) theorem prover. This translation creates a formal semantics for both UML and OCL and allows for the formal verification of UML-modeled systems, overcoming the challenge of OCL's three-valued logic by mapping it to PVS's two-valued logic framework.

Our approach concentrates on deductive verification within higher-order logic, which is suitable for verifying systems with potentially infinite state spaces. We describe how UML artifacts—such as class diagrams, state machines, and OCL constraints—can be converted into PVS's input language, enabling the formal verification of specifications originally articulated in OCL.

We highlight this process through an example that, while concise, is complex enough to pose a verification challenge since it includes object creation and asynchronous communication without a finite state space. Additionally, the model's behavior is influenced by data transmitted between objects, and the property intended for validation is that the generated numbers are prime—a number-theoretic characteristic that cannot be demonstrated by automatic methods like model checking.

The complexity encountered in the transition relation created by our translation tool is significant but seems to stem from the intrinsic complexity of UML semantics. Our most considerable challenges arose with message queuing—the technical intricacies of reasoning about the precedence of messages are particularly taxing. The proof of the example (a sieve algorithm) relies on the assurances that no signals are discarded and that signal handling follows a first-in, first-out protocol. These conditions must be articulated as separate invariants within PVS and proven to ensure the sieve algorithm fulfills its specification. If either of these conditions is not met, the sieve would fail to operate as intended.