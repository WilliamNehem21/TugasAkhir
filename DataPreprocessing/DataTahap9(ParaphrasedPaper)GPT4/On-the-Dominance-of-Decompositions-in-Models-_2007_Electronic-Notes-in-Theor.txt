Aspect-oriented programming (AOP) strategies typically recommend separating distinct concerns within a program. Some methods, like Hyper/J, apply this separation symmetrically, treating all concerns equally, while others, such as AspectJ, use an asymmetric approach, adding concerns as supplementary aspects to a base implementation. This paper explores how conventional implementations in asymmetric approaches are distinguished and whether symmetric separation could result in a fundamentally different program structure.

The paper presents an examination of dominant decompositions in both specifications and AOP implementations. Using the specification method Disco as a case study, we explore how it isolates concerns into branches and how AOP implementations such as Hyper/J and AspectJ can be mapped onto these Disco specifications. We argue that, at the code level, certain concerns will inevitably become dominant due to the inherent control flow in programs.

Dominant decompositions are problematic as they prevent addressing all software system concerns uniformly. Hyper/J was developed as a practical programming solution to address all concerns symmetrically, thereby facilitating the simultaneous management of classic modularity and cross-cutting concerns through "hypermoules."

In contrast, approaches like AspectJ embrace an asymmetric method where a base implementation is augmented with aspectual additions, allowing developers to expect aspects' integration and ignore those sections in the base code.

The paper is divided as follows: Section 2 introduces the Disco specification method and the common structure used for separating concerns. Sections 3 and 4 detail how to implement Disco specifications with Hyper/J and AspectJ, discussing symmetric and asymmetric separation and decomposition dominance. Section 5 concludes the paper.

Disco uses a layered approach where each layer addresses a separate concern and is considered an atomic refinement of its predecessor. The layering preserves safety properties and supports multiple abstractions. For example, when modeling a telephony system, layers address abstract functions like call control and charging and underlying implementation processes.

The paper transitions to discussing aspect-oriented techniques, emphasizing the preservation of the layered specification structure. When composing a Hyper/J system, subsystems are defined independently, but the dominance of control flow presents a challenge. Until the control flow definition is included, only declarative goals can be met, making the control flow branch semantically dominant.

AspectJ, on the other hand, extends a baseline Java implementation with aspects. It differentiates between conventional Java classes and aspects, with the latter being weaved into the baseline code, thus introducing a fundamental asymmetry.

The paper concludes that regardless of whether an AOP uses Hyper/J or AspectJ, dominant decompositions arise due to execution requirements, revealing similarities in structure-preserving implementations of specifications despite prescribed differences.