The academic paper discusses the development of a fully automated system to infer upper bounds on resource usage by Java bytecode programs. Traditional analyses of program costs have focused on a limited set of resources such as time, memory, or execution steps. However, with the growing importance of applications like static debugging and certification of user-level properties, there is a need for analyses tailored to application-specific resources, such as data transmitted, number of open files, sent or received SMS messages, database accesses, financial expenses, energy consumption, etc.

To address this, the authors propose a method in which the developer can define resources and their associated basic consumptions through Java annotations. This system then uses these definitions to automatically generate upper bounds for overall and individual block resource usage dependent on input data sizes.

A resource is identified via these annotations in the Java code, which also specify the basic cost function related to the resource's consumption for certain program components like classes, methods, or individual statements. The analysis not only tracks predefined resources but also allows developers to create custom metrics and relationships between data sizes.

The analysis process involves annotating a control flow graph (CFG) with resource information. Each block method in the CFG represents an uninterrupted sequence of operations, with characteristics distinct from standard Java methods, such as the absence of branching and the inclusion of input and output formal parameters.

The paper continues by outlining the resource analysis approach. First, the CFG is decomposed into strongly connected components. Next, two separate analyzes are performed on each component: size analysis and actual resource analysis, where the size analysis determines the relationships between input and output parameter sizes, and resource analysis calculates the resource usage for each block method.

For the estimation of parameter size relationships, the authors base their work on previous research and focus on defining input and output sizes in terms of formal parameter sizes. They introduce a set of measures to capture the size relationships, even for complex data structures like arrays or cyclic structures.

When dealing with non-recursive function calls, the analysis decides between previously computed resource usage functions, user annotations, or issues a warning if there are discrepancies. The chosen function represents the most accurate safe upper bound for the resource usage.

The paper includes experimental results demonstrating the effectiveness of their prototype system across various resources, highlighting the flexibility and independence of the resource analysis with respect to the particular resource being considered.