The article discusses the λ-calculus[11,10,4], a foundational system for reasoning about functional programming languages that incorporate control features like continuations and exceptions. This calculus extends the classical λ-calculus with an additional binding mechanism. Key properties, such as strong normalization and confluence, are essential for its application in functional programming and proof systems, which makes formal verification of these properties highly valued, as human proofs may contain errors that can persist even after peer review; for example, an initial proof of confluence for the λ-calculus was flawed and only recently rectified.

To date, mechanical verification of the λ-calculus properties has not been conducted. This paper proposes two encodings of the λ-calculus using higher-order abstract syntax, revealing that a third-order constructor can best represent some aspects of the calculus. This allows for a more natural implementation of the debated structural or mixed substitution.

The paper explains that the "contra" rule implies a contradiction from the assertion and negation of the same statement. Interestingly, within this framework, a term resulting from the application of a variable to another term is untyped, but considered named by that variable.

In the type system of the λ-calculus, every term in its normal form obeys the subformula property. Each term can reach a normal form through a finite series of β-reductions. Unlike the original confluence proof, an adaptation of the parallel reduction method by Tait and Martin-Löf proved inadequate; a correct confluence proof was later given by Baba, Hirokawa, and Fujita, who noted that parallel reduction as initially defined does not possess the diamond property, a key aspect of confluence.

Ong and Stewart extended the λ-calculus to include data types, case distinctions, and recursion to create a simple programming language called PCF. The paper focuses on a subset of PCF, referred to as V, which uses a call-by-value reduction strategy.

The paper then debates the interpretation of λ-variables, suggesting they function as placeholders for evaluation contexts, an idea supported through the structural substitution of contexts. Furthermore, small-step semantics are refined to avoid accumulating unnecessary contexts, replacing them with substitutions and decomposing terms into evaluation contexts and redexes.

A complication arises when applying local rules due to an infinite chain of necessary additions, making implementation unfeasible. The paper suggests type refinement within logical frameworks to improve second-order representation and proposes third-order representation as a valuable tool for proving various properties of the λ-calculus. The author has formally demonstrated the soundness of the big-step semantics for this calculus, and foresees further applications of the encoding in the future.

Acknowledgements are given to Ralph Matthes, Frank Pfenning, Brigitte Pientka, and the anonymous referees for their contributions and feedback, and thanks are expressed to the creator for facilitating human life and thought. The work of Baba, Hirokawa, and Fujita on parallel reduction in the λ-calculus is also cited.