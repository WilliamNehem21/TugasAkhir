In this study, we're examining the ongoing formal verification of a process supervisor through the use of the McErlang model checker. The supervisor in question is an alternate version of Erlang/OTP's standard supervisor behavior and is being used at LambdaStream, where it's assessed for various safety and liveness conditions.

Developing reliable concurrent software is challenging due to the innate unpredictability of such systems. Concurrent declarative languages, like Erlang, which has reduced side-effects, are promising for building such applications. Companies worldwide apply Erlang for constructing intricate concurrent control systems.

The paper structures as follows: Section 2 provides an overview of Erlang and McErlang. Section 3 describes the process supervisor and the considered properties. Section 4 elaborates on how these properties were implemented and checked by McErlang, while Section 5 offers conclusions and future research directions.

Erlang achieves fault-tolerance by linking processes, allowing for error detection and recovery, such as process restarts after abnormal terminations. To manage many processes, Erlang programmers typically leverage higher-level constructs from libraries, with OTP being the most common, featuring various design patterns.

McErlang, an Erlang model checker, takes an Erlang program and a property to verify. Programs serve as models straightaway, simplifying usage in real applications. A source-to-source transformation prepares the program for the model checker; then it's compiled into bytecode and executed under the McErlang run-time system, handled by the standard Erlang environment but with side effects managed by the McErlang runtime.

Verification involves creating a model, defining properties as safety monitors or in Linear Temporal Logic (LTL), and generating scenarios. Safety monitors track program states successively, reporting errors through counterexamples if a property fails. Moreover, monitors observe system structure and crucial system events.

When a process crashes, the supervisor may restart the offending child or all children, depending on the specified restart strategy. The paper details verifying multiple properties of the Nos supervisor, such as proper handling of different restart intensities and shutdown strategies, using McErlang.

The Nos supervisor's source code serves directly as a model in McErlang, with minor changes for verifiability, like abstracting time intervals for restart intensity. Safety monitors express most correctness properties and are written in simplified models of the system to compare against actual behavior.

Examples of the verification process demonstrate scenario generation and debugging, providing insights into supervisor behavior and identifying deviations from specifications. The extracted properties are coded as safety monitors, observing supervisor actions and signaling errors if it deviates from expected behavior. 

The paper acknowledges the difficulty of using McErlang and formulating correctness properties. Future updates of McErlang will aim to enhance usability, provide better debugging information, recommend verification approaches, and simplify the API for defining correctness properties.