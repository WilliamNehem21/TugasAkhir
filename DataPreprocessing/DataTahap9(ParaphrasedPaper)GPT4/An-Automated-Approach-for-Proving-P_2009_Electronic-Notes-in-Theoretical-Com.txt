The paper begins with an introduction to Protocol Composition Logic (PCL) to make the content more approachable for those not familiar with it. It then covers the Transport Layer Security (TLS) protocol as an ongoing illustrative example. Those who already have knowledge of PCL and the analysis of TLS through PCL are advised to skip to section 3.

A significant part of the paper details a proof system that augments first-order logic with axioms and rules designed for protocol actions, time-based reasoning, cryptographic primitive properties, and a specific rule for program invariance dubbed the "honesty rule." These axioms—and their soundness proofs—are referenced in other works.

Discussion on TLS describes the protocol's function, which is to enable mutual authentication and establish a shared secret between a client and a server. The paper zeroes in on proving the authentication property of TLS and relating it to a program invariant. Moreover, the paper indicates that other security properties pertinent to TLS have been examined in the broader context of IEEE 802.11i.

The paper also examines how PCL programs are encoded. It states that one must demonstrate that an invariant persists at the close of every potential segment of a protocol performed by an honest participant. The examination method for one such segment of a protocol is described in detail, and this process is applicable to other segments as a composite of similar checks.

Next, it describes the practical modeling of PCL programs, specifically highlighting encoding actions as facts and the organization of actions within individual threads. Significant differentiation from other encoding methods includes explicit representation of actions like concatenation, and an explanation of why alternative methods, such as lists, can be computationally inefficient.

Later, the paper presents an argument for the main theorem about invariant checking, using a standard decision procedure applied to logic programs to verify soundness. It elaborates on the verification process for an individual initial segment within a protocol and demonstrates how the decision procedure can identify failures effectively.

The final presented proofs focus on demonstrating that using SLD-resolution in a specific manner (left to right, depth-first) is a sound approach for invariant checking. Since this method is implemented by most Prolog interpreters, the authors were able to employ existing tools for their decision procedure, specifically mentioning the use of the SWI-Prolog interpreter in their prototype.