This academic paper describes a method for verifying Erlang programs by combining abstract interpretation and model checking techniques. Previous work outlined a framework for abstract interpretations for Erlang, ensuring that the abstract operational semantics (AOS) encompass all paths within the standard operational semantics (SOS). This study focuses on properties that must be satisfied on all system paths, similar to those expressed in linear temporal logic (LTL). If such properties hold true for the AOS, they will also hold true for the Erlang program itself. Automating the proof is feasible through model checking when the AOS is a finite transition system. However, infinite domain abstract interpretations lead to infinite state systems where model checking becomes undecidable.

The paper introduces an abstraction of control flow that simplifies recursive calls in non-tail positions into jumps to the last call of the same function and modifies the corresponding returns into jumps to potential return points. The approach is further developed to accommodate standard Erlang operations, including spawning processes, message passing, and using mailboxes for message storage.

The authors describe the syntax for a core fragment of Erlang and provide an overview of its operational semantics. A framework for abstract interpretation is briefly introduced, along with the limitations of current techniques. A graph semantics is presented as a basis for the new abstraction, and the authors explain and formalize the idea. The method's application to model checking is then described.

The paper discusses how processes and their communication are modeled, emphasizing the context-free nature of functional programs and the challenges it poses for state transition system abstraction. An abstraction technique that transforms the context-free structure to a regular one is defined to obtain a finite state transition system, allowing LTL model checking for system property verification.

The specifics of the Erlang language semantics, the framework for abstract interpretation, and various technical aspects of the approach are discussed in detail throughout the paper. The abstraction developed enables verification of systems with non-tail recursive calls, which was previously not possible with infinite transition systems.

Finally, the paper suggests that, for practical verification of larger systems, the graph semantics yields a more compact representation of the AOS, facilitating verification with limited memory. While the authors have implemented their approach as a prototype capable of model checking, they also indicate that for real systems, abstraction is necessary and the presented techniques should be integrated into tools for model checking Erlang programs. Future work could also explore translating this approach to other specification languages like Promela, as has been done for Java and Ada, but challenges remain due to language differences and the need to translate counterexamples back to Erlang.