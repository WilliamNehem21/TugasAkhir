The paper presents a highly efficient, parallelizable multithreaded algorithm for tackling the propositional satisfiability problem (SAT), a significant issue in computational theory. This problem has seen substantial scholarly interest for over 40 years, highlighted by its classification as the first NP-complete problem by Cook in 1971. The practical relevance of SAT solutions spans numerous fields, including hardware verification, AI, and computer vision, with a survey noting over 200 applications.

Over time, various advanced optimization strategies have been integrated into the primary DPLL algorithm for SAT, enhancing its efficacy. These strategies include watched literals, conflict analysis, non-chronological backtracking, variable state independent decaying sum (VSIDS) decision heuristics, and restarts. These optimizations are central to the parallel solver discussed in this paper.

The proposed parallel solver ensures balanced workload distribution across threads by dynamically partitioning the search space. An active list of tasks helps minimize thread idle time, with tasks added to the list corresponding to new open variables introduced by threads. The design ensures that thread waiting time is minimal, typically only occurring at the initial or final stages of execution.

The algorithm's design circumvents complex synchronization mechanisms for terminations by implementing distributed conflict clauses. When a conflict is detected and a clause added to the conflict list, other threads recognize it and independently backtrack to avoid the specified conflict.

Data collection and analysis did not directly elucidate the declining performance observed with increasing thread count. Processor load, load distribution among threads, and function call patterns maintained consistency regardless of threads. The majority of the processing time was spent on Boolean constraint propagation algorithms, and this proportion remained stable even with more threads. Increased thread count primarily affected the time spent waiting on synchronization locks, but not enough to account for significant performance loss.

Distinct from earlier research, this paper focuses on the parallel execution of a SAT solver in a shared memory workstation rather than a cluster of networked computers. This scenario is more realistic in industrial settings, where dedicating a cluster to SAT solving may be resource-prohibitive, whereas utilizing idle processors on a workstation is viable. Nevertheless, the impact of shared memory architecture on cache performance suggests that the speed-ups seen in clustered environments may not be fully replicated on a multiprocessor workstation.