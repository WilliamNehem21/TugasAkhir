In our paper, we have expanded an LTL (Linear Temporal Logic) model checking algorithm, known as the One-Way Catch Them Young (OWCTY), to include hash compaction for distributed memory systems. We delve into the specifics of the enhanced algorithm and provide a theoretical framework to ensure its correctness. Further, we've integrated this algorithm into our parallel and distributed-memory model checker called DIVINE and have carried out empirical tests to evaluate its practical performance.

Nested Depth-First Search (DFS) is known for its efficiency as it controls how a graph is traversed, ensuring each state is visited a maximum of twice. Most advanced algorithms use a similar principle based on the postorder sequence generated by DFS. While postorder is recognized as a P-complete problem, developing a scalable parallel algorithm based on DFS postorder is challenging. Several strategies have been attempted, including the use of supplementary data structures, different search tactics, and limited information sharing across multiple instances of nested DFS. While OWCTY does not rely on postorder, it lends itself more suitably to parallelization.

Towards the conclusion of the algorithm, we've introduced a phase to verify the legitimacy of any detected accepting cycles, similar to the counter-example generation phase of OWCTY. This phase can fail because it may not find an actual counter-example.

We have considered extending the algorithm to detect self-looping acceptance early on for quicker termination, making this heuristic applicable to multiple algorithm phases. Contrarily, we opted against incorporating map algorithm-based heuristics due to their propensity to yield incorrect accepting cycles which we could not reliably circumvent.

As we demonstrate further in the paper, reaching a fixpoint with our algorithm means either no cycle is present or there exists an accepting cycle. Under these circumstances, specific measures can be omitted. However, since a fixpoint might not be accurately detected, the algorithm might terminate too soon, necessitating a verification phase to prevent false positives.

When the algorithm reaches a supposed fixpoint, the set 'S' will consist of states that are either within a cycle or can reach a cycle in 'S'. Should the algorithm not reach an actual fixpoint, this might lead to missed counter-examples.

The verification phase confirms an accepting cycle only if there exists a path from a state 'A' back to itself, and this state must be within the set 'Qacc'. This comparison uses the complete representation of state 'A', thereby not being influenced by hash compaction. As a result, if the verification phase yields a true result, there is certainly an accessible accepting cycle, attesting to the phase's accuracy.

In our hands-on tests, hash compaction did not cause any false validations. This absence of false positives could partly be due to the structure of BEEM models, where counter-examples are generally plentiful and similar. This characteristic is common in asynchronous system models, implying that our results are not unique to BEEM models and should generally hold true.