In this paper, the authors present and discuss a method for conducting static analysis aimed at ensuring that comparisons between floating-point values are conducted with compatible levels of precision. This is important due to the precision discrepancies that occur when floating-point values are transferred between processor registers and memory storage, as the bit widths of these two storage types differ (processor registers typically having 80 or 64 bits and memory having 64 or 32 bits).

An illustrative example demonstrates how a 64-bit floating-point value can be truncated to 32 bits when stored in memory, which can lead to precision loss and, eventually, to errors when values are compared at different bit widths. They describe a situation where a previously accurate value loses precision due to this process, causing an incorrect result in a subsequent comparison.

The authors have implemented the precision-compatibility analysis within Clousot, a static analyzer for CodeContracts. Clousot processes Intermediate Language (IL) code to build control flow graphs for each method, inserting contracts as needed. It then simplifies the program, abstracts away the stack and heap, reconstructs expressions that may have been lost during compilation, and reduces the program to a scalar form. After this process, various analyses including non-null checks, numerical range checks, and array boundary checks are performed.

In addition to these existing analyses, the authors have integrated their novel analysis for detecting mismatches in floating-point precision within the arithmetic analysis module. This enhancement reportedly runs quickly and accurately, adding minimal time to the analysis of a vast number of methods in the core .NET framework library and identifying several genuine precision-related warnings.

The authors have made a conscious decision to target their analysis on floating-point comparisons rather than on all instances where a higher-precision floating-point value is narrowed to a normal type width upon memory storage. They reason that the latter approach would result in an overwhelming number of warnings due to frequent memory writes and might miss certain precision losses caused by compiler-induced register spilling into memory. By focusing on comparisons, the analysis provides more actionable insights for rectifying precision mismatch issues.