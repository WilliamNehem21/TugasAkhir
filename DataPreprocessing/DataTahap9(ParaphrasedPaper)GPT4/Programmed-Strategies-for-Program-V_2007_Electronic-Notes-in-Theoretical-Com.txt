The paper discusses Plover, an automated property-verifier for Haskell programs, developed as part of the Programatica project over three years. Programatica allows embedding predicate definitions and property assertions, using a logic system called P-Logic, directly in Haskell code. However, the Haskell type system alone isn't sufficient for verification, thus necessitating a more powerful logic-based verifier like Plover.

The paper consists of several sections. Section 2 introduces P-Logic while Section 3 provides an overview of Plover's architecture. The implementation of Plover, including the usage of the Stratego strategy programming language, is covered in Section 4. Sections 5 and 6 discuss normalization and type-specific strategies, respectively. In Section 7, the paper examines generic strategies, some unique to Plover. It concludes with a summary of progress and related work in Sections 8 and 9.

Other language-specific logics like ACL2 for Common Lisp and Sparkle for the Clean 2.0 programming language are also mentioned, highlighting the benefits of formulating assertions without translating them into a different logical system.

The paper explains fixed-point predicates and the structure of Haskell modules with added property and assertion names encapsulated within comment brackets. It also differentiates program verification from theorem-proving, emphasizing the focus on verification results over the proof process itself.

Program verification is likened more to proof-checking, where one must verify that a property conjectured about a program is true, based on the logic and theory of the language. This distinction allows verifiers to employ performance-improving shortcuts that are coherent with the language's logic.

The paper further delves into the technical aspects of P-Logic, including the handling of specific Haskell terms and type-specific strategies for certain Haskell program constructions. It discusses the considerations involved in constructing let expressions, instantiating lemmas, and simplifying verification steps, as well as the challenges of managing the complexity that can arise in verification's derivation tree.

Finally, there's a comparison of Plover with other verification tools and theorem provers, noting the general lack of construction of proof terms in verifiers, and highlighting PVS for its pioneering inclusion of cooperating decision procedures. The paper elaborates on how theorem provers are different due to their strict adherence to logical rules and lack of dependency on decision procedures or user-specified axioms.