The paper introduces imperative commands specific to the Creol language, which are particularly useful in concurrent or distributed settings. It begins by discussing foundational commands and then explores composite operators.

A key point is the behavior of Creol's "await" statement, which prevents the blocking of the program at a "reply" statement while waiting for a method to finish executing. This is comparable to the behavior seen with transparent futures.

Creol distinguishes between local and remote method calls. Calls within the same object (local) occur immediately to avoid deadlock. Remote method calls entail an asynchronous method invocation and subsequent blocking for a reply, which may lead to temporary suspension of the calling object.

The paper also defines the concept of a statement being "enabled" or "ready." For instance, an "await" statement is enabled only if its condition is true and does not relinquish the processor. The statement "l?(y)" is enabled but ready only when the corresponding reply has been received.

Two examples highlight how asynchronous method calls can be handled differently: the first method processes only the first arriving reply while the second method processes both replies, albeit in a potentially nondeterministic order depending on which reply arrives first.

Overall, the paper centers on Creol's basic concurrency and communication models. It references detailed discussions on these topics, the formal semantics of Creol, the integration of first-class futures, and explores several case studies and type systems. Creol also facilitates the dynamic evolution of distributed systems through runtime reprogramming, allowing gradual and type-safe updates of classes and subclasses without disrupting ongoing system processes.