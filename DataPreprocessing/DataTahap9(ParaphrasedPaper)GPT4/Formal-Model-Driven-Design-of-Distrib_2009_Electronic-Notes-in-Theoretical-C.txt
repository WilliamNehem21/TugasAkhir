The paper focuses on the advancement of distributed algorithms backed by formal models. Initially, it creates a formal model – characterized in this context as a finite state system – to capture the original design concept. This model's behavior follows clear semantics, and it is later scrutinized for adherence to a defined correctness specification in conjunction with a case study's examination. The paper's objective was to assess various proof methods on a concrete distributed agreement algorithm by exploring different ways to validate known theorems. The article reports on how the algorithm is refined and enhanced through iterative development and concludes with a proof of correctness for the new version.

In their approach, the researchers employ a basic model consisting of communicating finite state automata utilizing asynchronous, fair message passing. 'Fair' implies messages sent between agents are guaranteed eventual delivery and are not corrupted during transmission. With n agents operating, the system begins in an idle state, evolves through initial transitions into phase one, may experience crashes, and then either anticipates messages or enters a suspecting state. The process iterates across agents, advances through rounds, and returns to phase one. Upon completion of all rounds, the system progresses to phase two, then iterates across agents once more, and ultimately selects a final value in phase three.

Due to the asynchronous nature of the required communication, the researchers opt out of using UPPAAL's synchronous communication primitives in favor of shared buffers for message exchange, circumventing potential race conditions as UPPAAL operates with interleaved semantics and agents communicate via distinct memory sections. The paper introduces boolean arrays, 'sent1[][]' and 'sent2[]', to record whether an agent has broadcasted a message in a particular round or phase.

To validate the model, model checking is applied to a constrained size of three agents, which is sufficient to unearth possible faults (exploring a total of 278,316 states in 5.2 seconds). However, exploring the behavior with four agents was not feasible due to memory limitations. An identified issue with three agents reveals that if agent 3 is waiting for a message that agents 1 and 2 (who have already prematurely terminated) will never send, it leads to a deadlock scenario where agent 3 is indefinitely blocked.

Subsequent tests confirm that termination, agreement, and validity properties are satisfied for three agents, with 514,084 states explored in 12.3 seconds. Although verification for four agents could not be completed, the results for three agents imply the possible correctness of the algorithm, prompting the researchers to conduct a generalized correctness proof applicable to any fixed number of agents.