The increasing need for processing power, coupled with the physical limitations on CPU clock speeds, has made multi-threaded programming essential in modern applications. However, multi-threaded programs are susceptible to programming errors such as race conditions and deadlocks, leading to persistent and hard-to-trace defects. Current tools for detecting such errors are either user-unfriendly due to the need for manual annotations, ineffective for analyzing large codebases beyond a few tens of thousands of lines of code, or prone to generating excessive false warnings. This paper discusses the usage of the freely available debugging tool Helgrind to analyze a substantial server application of 500,000 lines of code. The paper describes improvements made to the runtime analysis of C++ programs, which significantly lower the rate of false alerts.

Existing runtime methods can effectively scale but are limited to faults along the code's execution path; therefore, they can't guarantee the detection of all potential data races, but only the apparent ones that occur. A well-known efficient lock-set based runtime algorithm, Eraser, has been integrated into the open-source tool Valgrind and is available for Linux-based systems. Unfortunately, the high number of false positives, especially for C++ applications, hampers its practical use as each reported instance requires manual verification.

The proposed solution combines static and runtime analysis by automatically and transparently annotating the code. This extra knowledge from code structure equips the runtime method to reduce false positives, yet annotations are not strictly necessary, allowing for analysis of partially unavailable source code.

The paper presents outcomes from experiments applying the improved Eraser implementation in Helgrind to a pre-existing network server application. The modifications led to more accurate simulations of hardware behavior and tailored handling of C++ specific traits, which drastically reduced false positives, thus making the tool more practical for debugging large C++ applications. The reduction in false positives during the experiments was significant.

The paper is structured into five main parts: Section 2 surveys runtime fault detection methods for multi-threaded programs and explains Helgrind's runtime detection; Section 3 details the source-code annotation method that improves runtime analysis accuracy; Section 4 details experimental results; and Section 5 concludes with a discussion of these results.

Distinctive concurrency faults are defined, while giving an overview of runtime methods to detect such faults. Helgrind's mechanisms are examined more closely, including algorithms for fault detection and the experiences with adapting these algorithms to deal with specific C++ challenges, such as polymorphism and object destruction, improving the accuracy of race detection while reducing false positives.

Helgrind can be applied to unmodified programs, even without debug symbols, but such symbols allow it to provide detailed information about where faults may exist. The examined application, with hundreds of thousands of lines of C++ code, was challenging for experimental tools, as many can't handle all C++ language constructs. The tool Helgrind not only identified real bugs but also improved data race and deadlock detection within the application.

Ultimately, the paper presents an integrated approach that leverages Helgrind and its improved algorithms to effectively analyze and debug complex, large-scale C++ applications for concurrency issues.