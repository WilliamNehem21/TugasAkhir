Program transformation is a critical technique used broadly across several areas in software engineering such as compiler construction, program synthesis, refactoring, legacy software upgrading, and reverse engineering. It involves making a series of edits to a program to achieve complex changes. These edits are governed by transformation rules that specify the elementary changes and strategies that help choose a sequence of rule applications effectively. The paper presents an overview of how strategies are defined and supported within various program transformation systems, with a focus on the control mechanisms within these systems, which determine the sequence and manner in which transformation steps are applied.

While basic program manipulation tasks like parsing and printing are well-documented, this review emphasizes the higher-order control part termed "transformation strategies." These strategies manage the order in which individual transformation steps are used. The paper further discusses the structure and semantics of programs, noting that the semantics allow comparisons and validity checks for transformations. It generalizes the concept of programming languages, aiming to identify universal transformation techniques that work across diverse languages.

The paper differentiates between two main scenarios in program transformation: translation (where source and target languages differ) and rephrasing (where both languages are the same). It dives into reverse engineering, which involves abstracting a high-level program or features from a lower-level one, and mentions subscenarios of rephrasing such as normalization, optimization, refactoring, and renovation, highlighting their purposes and challenges.

The importance of choosing a suitable program representation and programming paradigm for implementing transformations is underscored. The paper then delves into the technical aspects of transformation, such as rules based on language semantics, pattern matching in rule recognition, and complex matching enhancements made within certain languages.

Strategies for choosing paths in transformation are discussed with an emphasis on automation and approximation of optimal solutions due to the complexity of manually finding paths. Furthermore, the interplay between rules and strategies during implementation is analyzed, explaining intentional programming and domain-specific abstractions in transformation.

The paper reviews concrete strategy systems and their implementation in existing languages and provides an overview of strategic annotations and user-definable strategies in languages such as ELAN, highlighting the use of strategy expressions and operators.

The document concludes with a call for deeper analysis into how strategies can prevent interference between transformations, a need for generic strategies, origin tracking in term rewriting, and considerations on system separation between rules and strategies. It also references relevant literature and existing works that delve into the concepts discussed, such as controlling rewriting by rewriting, principles of maude, reflection strategies in rewriting logic, and strategic pattern matching.

The overall purpose of this study is to understand and compare various systems for program transformation by examining the features, strengths, and limitations of existing systems. It calls for further research into sophistication in rule application control and the parametrization of strategies, which could enhance both the efficiency and reach of program transformation practices.