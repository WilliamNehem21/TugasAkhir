The Maude system is an implementation of rewriting logic which, along with an array of methodologies and tools, supports the design and analysis of systems. There are two main approaches to modeling assembly languages according to the research. One proposes a simplified RISC assembly language model for microprocessor component verification, while the other models a limited subset of x86 for malware behavior detection. Both focus on verification rather than language definition. Defining the semantics of a language depends crucially on the memory system, both structurally and functionally. Our work enhances previous efforts in formalizing memory representations in rewriting logic for imperative and object-oriented languages.

The K Framework is another rewrite-based system for defining operational semantics of programming languages, demonstrated through its application to languages like C, Scheme, and Verilog. Our previous work outlined an integer subset of a pertinent language, and now we have built the K-Maude implementation on top of Maude, leveraging its tool suite.

This paper is structured as follows: Section 2 introduces key concepts of the K Framework and defines the assembly language; Section 3 discusses a modular memory system and its two instances; Section 4 details implementation and benchmarking; and Section 5 concludes.

An in-depth look is provided for defining the SimpleScalar PISA assembly language, termed SSRISC, including a subset featuring integer and floating-point operations, branching, jumping, and error instructions. This subset reflects several semantic aspects of the language using the specialized notation of K.

We exemplify SSRISC instructions, which encompass arithmetic, logic on integer and floating-point registers, branches, jumps, loads, stores, flag manipulation, and a unique program error instruction. The rules for addition (‘add’ on integers and ‘add.s’ on floating points) specify overflow checks and register updates, with error handling when overflow occurs. Branch and jump instructions correctly update the program counter, with special handling for updating the return address using ‘jal’ and target address based on the flag for ‘bc1t’.

The SSRISC language addresses the 'break' instruction, which signals a program error ending the computation, and introduces the 'la' instruction for loading registers using symbolic addresses.

The paper presents potential future extensions, such as label handling and symbolic data manipulation with getaddr messages that interface with memory models.

Our SSRISC implementation in the K Framework includes a syntax module, a semantic module, and a module for supporting operations, with specifics tailored to the language and its applications. A distinct communication module facilitates expansion like memory model swaps without altering semantics.

SSRISC allows for the underspecification of memory content using symbolic data, useful for abstract program execution in predicting timing bounds. The SimpleScalar toolset, simulating a MIPS-based assembly language, is partially implemented with 112 instructions and 20 auxiliary operations in K, plus memory modeling rules.

Testing involves simple C programs without unsupported library functions, verifying arithmetic, logical, loads, stores, and jumps operations, and comparing return values between C and assembly representations to validate program behavior. Ultimately, the SSRISC language aims to serve as a foundation for defining abstractions in timing analysis of embedded programs, with non-labeled memory representation being instrumental for understanding instruction and data locations.