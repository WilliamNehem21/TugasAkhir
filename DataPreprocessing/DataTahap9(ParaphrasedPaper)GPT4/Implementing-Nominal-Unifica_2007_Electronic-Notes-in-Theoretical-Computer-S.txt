Our initial approach to implementing nominal unification was straightforward but not optimized. While first-order unification—a simpler version of nominal unification—is known to be exponential without term sharing but linear with maximum term sharing, our initial implementation did not share subterms. To improve efficiency, we adopted a second approach using termgraphs to represent terms in the OCaml programming language. This modification also entailed managing permutations of atoms to share subterms up to permutations, introducing additional complexity. Although the resulting implementation is not linear due to permutation operations, we achieved polynomial complexity.

Furthermore, we enhanced the syntax for nominal terms by including an operator for name generation and a new constraint type to capture the concept of locality, denoted as a@t. This syntax allows for specifying disjoint local name sets within terms; however, we don't address the specific unification rules for these new syntax additions in this discussion.

Moving on from our naive approach, we selected a more sophisticated data structure to represent terms and unification problems as a single directed acyclic graph (DAG). This choice led to the development of a polynomial algorithm for the problem, which we implemented in OCaml. OCaml caters to a variety of programming paradigms and is known for its strong typing and functional orientation.

The computational complexity of nominal unification remains an unresolved issue in our field of research. Given that the unification of higher-order patterns—a related problem—is known to have linear complexity, there is optimism that nominal unification might also achieve linear complexity. This possibility represents an exciting direction for future research.