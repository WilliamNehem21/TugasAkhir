Multi-adjoint logic programming is a flexible framework that marries fuzzy logic with logic programming. Essentially, it consists of a collection of rules, each tagged with a degree of truth (like a number between 0 and 1), along with a query composed of a goal and a (typically initial) identity substitution. Evaluating goals within this framework is a two-stage process.

In the first stage, the operational phase, a backward reasoning process similar to traditional logic programming methods systematically applies admissible steps (an extension of the classic modus ponens rule). The goal during execution is to save on computations by only performing them once at "partial evaluation" (PE) time, utilizing symbolic computation and program transformation techniques, particularly "unfolding," which replaces a function call with its definition.

To enhance computation of "reductants" (optimized versions of goals) through PE, a new kind of partial evaluation has been introduced for multi-adjoint logic programs. The target is to unfold these goals exhaustively, streamlining the original program.

To fine-tune the creation of PE-reductants, an adapted concept of "unfolding tree" is employed. This tree includes an upper limit on truth degrees and uses dynamic threshold values to prevent the expansion of nodes below a certain utility threshold, significantly streamlining the tree.

Important considerations for the unfolding process include the selection function (which determines the next computation step), the order in which program rules are applied, and the choice between breadth-first or depth-first search strategies. The algorithm presented accommodates these factors and incorporates a termination criterion to ensure the process concludes.

The data structure used to traverse the unfolding tree can be treated either as a LIFO (stack) for a depth-first approach or as a FIFO (queue) for breadth-first. Experience shows no definitive advantage in node elimination between these strategies, although the rule order does significantly influence node reduction.

A comparative example highlights the advantages of the threshold-based PE-reductants, showing how the original program may fail to produce correct answers and how differing reductants compare in computational effort and structure.

Ultimately, reductants are vital for ensuring completeness in multi-adjoint logic programming. This paper presents a method for computing PE-reductants using unfolding and dynamic thresholds, offering improved efficiency both in construction and execution. Current efforts focus on defining the properties that these enhanced reductants satisfy.