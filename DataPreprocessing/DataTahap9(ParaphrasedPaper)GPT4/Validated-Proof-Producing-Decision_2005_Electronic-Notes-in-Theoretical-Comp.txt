This paper presents a method by which decision procedures (DPs), which are tools used for automatically making logical decisions, can be programmed to produce proofs that validate the correctness of the formulas they assert. Debugging proof-generating code in standard programming languages is prone to errors, as it's easy to create an incorrect proof. To address this, the paper introduces Rogue-Sigma-Pi (RSP), a programming language designed with a strong type system that ensures proofs are correctly manipulated. RSP merges features from the Rogue rewriting language with the Edinburgh Logical Framework (LF).

In RSP, type-correct programs are inherently partially correct; any LF proof object they produce will pass the LF's type check, implying its correctness. The paper illustrates this by demonstrating RSP's ability to combine propositional satisfiability checking with congruence closure, following an "eager" strategy in which atomic formula assignments are immediately communicated to the decision procedures.

The authors discuss certain assumptions regarding the ability to write general programs, referred to as tactics, to manipulate proofs. These tactics may lack properties like termination or complete coverage and therefore may not always be successful. Despite these limitations, the paper contrasts RSP's proof-production method with that of another system, CVC, emphasizing differences in handling proofs under assumptions.

In RSP, the restrictive instrumenting approach to proof production necessitates 52 lemmas derived from basic rules to justify all inferences. Proofs are expected to be thoroughly elaborated, using only primitive rules and the mentioned lemmas. While the RSP language has been statically verified for soundness with respect to H= provability, completeness may still be an issue due to bugs or runtime errors, which could result in the presence of a special "null" symbol in proofs, thereby invalidating them. Consequently, the guarantee is that any proof without the null symbol will be successfully checked.

The paper describes RSP as similar to the ML programming language with additional features like pattern abstractions, deterministic choice operators, and explicit application operators. These features, combined with general recursion and pattern-matching case analysis, enable RSP to transform and manipulate terms efficiently, ensuring that the produced proofs are both valid and dependable within the confines of the language's type system and logical framework.