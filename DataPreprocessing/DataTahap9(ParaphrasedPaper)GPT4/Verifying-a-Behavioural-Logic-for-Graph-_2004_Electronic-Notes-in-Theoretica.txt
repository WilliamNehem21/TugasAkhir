Graph Transformation Systems (GTSs) are recognized as a more general and powerful system than Petri nets for specifying the behavior of concurrent and distributed systems. The concurrent aspects of GTSs have been extensively studied, and a well-established theoretical framework for concurrency now exists. This includes the adaptation of various Petri net semantics—such as process semantics and unfolding semantics—to GTSs.

On the other hand, when it comes to the automated verification of these systems, the existing body of research on GTSs does not offer as many contributions as it does for Petri nets. Petri nets benefit from several verification methods, like invariant calculus and model checking based on finite complete prefixes. However, there is a scarcity of literature on analogous techniques for the static analysis of GTSs.

It is worth noting that other formalisms dealing with concurrency and mobility can be represented using GTSs, suggesting that verification methods developed for GTSs might also apply to these formalisms.

In this paper, we introduce a type system intended for the specification of graph properties, which is aimed at assisting with the verification of GTSs. This type system is designed to detect formulas in the logic that are preserved or reflected by edge-bijective morphisms, making it possible to carry out verification on a finite approximation of the GTS, known as a Petri graph covering.

Although we can prove the correctness of the proposed type system, it is not complete. Specifically, we can demonstrate that determining whether closed first-order formulas are preserved or reflected by edge-bijective morphisms is undecidable; hence our type system cannot capture all such formulas.

Moreover, given an approximation of an original system, we can eliminate quantifiers and translate these formulas into a boolean combination of atomic predicates on multisets. When combined with an algorithm that approximates unfolding, this provides a method for verifying and analyzing GTSs. The abstraction used here is distinctive in that it abstracts the system's structure instead of its data, akin to shape analysis, which abstracts the data structures in a program.