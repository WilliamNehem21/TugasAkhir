The Pagai tool is designed for exploring new algorithmic analyses, with flexible choices in abstract domains, iteration strategies, and to a lesser extent, decision procedures. This flexibility makes it ideal for comparative studies. Research using both self-created examples (inspired by real industry code) and GNU software demonstrated the utility of Pagai's ability to process any C/C++ code via LLVM, a capability without the common analyzer constraints often incompatible with general-purpose programs.

Abstract interpretation commonly merges multiple control paths into a single abstract value using the least upper bound, which can introduce imprecision by allowing states not possible in actual program execution. To maintain precision, Pagai uses a widening scheme to ensure convergence of Kleene iterations, then narrows to refine the invariants.

At a specific program point, Pagai avoids combining polyhedra to prevent generating extra program states, which could hinder proving certain properties. Instead, Pagai can maintain lists of polyhedra at intermediate points, although this approach risks exponential list growth during successive tests.

Pagai's implementation focuses on non-arithmetic variables as dimensions in abstract polyhedra, as including both these and their arithmetic outcomes leads to redundancy. This strategy decreases precision in a small percentage of control points, leading to results inferior to traditional methods at times. However, a combined technique demonstrated more precision at many control points.

Among different abstract domains, convex polyhedra generally yielded the best results, albeit sometimes less precise than other domains due to its widening operator known weaknesses. Octagons were shown to be more effective than intervals, credited to the variable nature of program parameters such as array sizes.

An improved version of the widening operator for convex polyhedra presented by Bagnara et al. showed more precision in certain control points, implying it is beneficial to use.

When comparing analysis techniques, it may not be sufficient to only consider the size of derived invariants. A slightly tighter invariant might not necessarily contribute to property proofs. Consequently, future work needs better benchmarks and metrics, such as the number of verified asserts or the ability to reduce false positives in analyses like array bound violation and overflow detection.