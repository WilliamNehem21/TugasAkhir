We've investigated the issue of collateral evolution within Linux device drivers. Currently, these changes are mostly performed by hand with basic tools like text editors and grep, despite the vast number of drivers, making this method cumbersome and prone to errors.

Previously, we looked into the widespread effect of collateral evolution, where changes to a generic library's interface necessitate alterations across all client implementations, and analyzed this impact on Linux device drivers.

In this paper, we introduce a new declarative language, SMPL (Semantic Patch Language), designed to facilitate the precise and concise expression of collateral evolutions. Since Linux programmers are familiar with exchanging and modifying patch files that register changes, we based SMPL's syntax on this notation. However, SMPL differs from standard patches by enabling generic transformations that target multiple evolution sites, defined via control-flow graphs rather than conventional syntax treesâ€”hence the term 'semantic patches.'

The remainder of the paper is laid out as follows: Section 2 demonstrates a series of collateral evolutions using a running example, while Section 3 shows how to represent these evolutions using standard patch notation.

As an illustration, proc info functions evolved because direct usage of certain functions could lead to integrity issues, so such functions were removed, and device representations became additional arguments, affecting numerous SCSI driver files.

Patches usually apply to identical files, but without semantic awareness, code variations may prevent a patch's successful application, leading to fragile and error-prone outcomes.

Our proposed SMPL language allows the specification of semantic patches that can be applied flexibly across multiple files, driven by code semantics rather than syntax. An example in the appendix displays how SMPL captures the earlier detailed collateral evolutions and how it handles variability in function parameters by using metavariables.

Further, the paper demonstrates how SMPL can sufficiently handle complex coding scenarios such as variable aliasing through standard dataflow analysis and discusses the introduction of bugs in certain versions of Linux due to improper hand-performed evolutions.

The design of SMPL was influenced primarily by Linux device drivers and includes ideas from JetBrains' IDE and jQuery's use of logic variables and compiler optimization specification through control-flow graphs. Despite Aspect-Oriented Programming's (AOP) utility, we note that Linux developers favor direct source code updates for maintaining uniformity in driver implementations.

The Linux community has recently started utilizing tools like Sparse and Smatch for C code analysis, showing openness to automated tools that align with traditional Linux developer skill sets.

SMPL uses a language based on the familiar patch syntax and incorporates isomorphisms for conciseness and flexibility, addressing identified collateral evolution types. Finally, the paper discusses the SMPL grammar, explaining its macro and pattern systems, and clarifies that the examined grammar is of the actual transformation rather than the overall SMPL code a programmer writes.