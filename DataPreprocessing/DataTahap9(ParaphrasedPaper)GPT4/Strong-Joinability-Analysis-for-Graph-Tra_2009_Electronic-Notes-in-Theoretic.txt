This paper discusses the connection between Graph Transformation Systems (GTS) and Constraint Handling Rules (CHR), focusing on the concept of confluence which is significant to both frameworks. The study reveals a novel method for embedding GTS into CHR, enabling the consideration of strong derivations in confluence analyses. While confluence can be determined for a terminating CHR program, it's undecidable for a terminating GTS. The authors illustrate that observable confluence for CHR is equivalent to a particular aspect of confluence for GTS.

The paper is structured as follows: Section 2 introduces the fundamental principles of GTS and CHR. Section 3 describes the proposed embedding method of GTS into CHR, establishing the groundwork for later sections. Section 4 demonstrates the soundness and completeness of this embedding. Following in Section 5, the authors discuss observable confluence and propose it as a sufficient condition to determine confluence for an embedded GTS. The paper concludes with Section 6.

A critical component of embedding GTS in CHR involves translating graph production rules into CHR rules and creating goal constraints that correspond to the host graph. The nodes and edges of the GTS type graph are given unique labels for this purpose. In Section 4, the discussion spotlights the relevance of degree variables in the context of the encoded GTS which are essential for the analysis of strong joinability.

Section 5 reviews both confluence properties in GTS and CHR and presents ways to apply automatic confluence checks within CHR to serve as a decidable sufficient criterion for confluence in an embedded GTS. This exploration covers the divergence between critical GTS pairs and CHR pairs and presents criteria for deciding a type of confluence called glocal-confluence.

The theorem introduced implies that the automated confluence checks used in CHR can be repurposed to validate confluence in a GTS encoded as a CHR program. This efficiency arises from the fact that the CHR confluence checker needs no modification but only restricted inputs to decide g-confluence, providing a sufficient condition for GTS confluence.

In conclusion, the paper shows that CHR offers a sophisticated method for representing GTS. The authors have not only presented a new encoding that closely follows the original GTS rules but have also created a model that accounts for strong derivations essential for analyzing confluence within GTS.