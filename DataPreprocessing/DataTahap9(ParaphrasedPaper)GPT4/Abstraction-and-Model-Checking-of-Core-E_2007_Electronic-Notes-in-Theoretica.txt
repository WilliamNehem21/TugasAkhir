The paper is structured as follows:

- Section 2 introduces the basic syntax and underlying concepts associated with the Core Erlang programming language.
- Section 3 provides a brief overview of the rewriting logic framework.
- The bulk of the discussion, found in Sections 4 and 5, dives into the details of how Core Erlang's operational semantics are represented within rewriting logic and the specifics about its implementation in the Maude system. 

The excerpt provided describes an example within the paper. The 'locker' system is a module that initializes two client processes using the 'spawn' function. The 'self' function is used to obtain the process identifier of the 'locker' process so that the client processes can communicate with it.

The paper also discusses how function names in Core Erlang are handled as variables with a special domain for functional abstractions. The semantics of 'letrec' expressions, a type of recursive binding, are explained in terms of scope and the propagation of these bindings through function abstraction bodies, as illustrated with the 'e' expression and its premises.

Lastly, it refers to the way processes are represented and managed, including their scheduling and blocking states. The text uses predicates to express conditions such as the existence of a process, whether it's been scheduled, or if it's currently blocked awaiting a message. This forms part of the semantic modeling within the framework being described.