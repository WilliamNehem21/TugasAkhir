The paper discusses the completion of a formal proof for the DPLL (Davis-Putnam-Logemann-Loveland) proof system, and the subsequent extraction of a SAT solver based on this proof. When given a propositional formula in conjunctive normal form (CNF), this program can either generate a satisfying assignment or produce a DPLL derivation that proves the formula's unsatisfiability. Non-computational quantifiers are used in the process to eliminate superfluous computational details from the extracted program, enhancing its efficiency. The formalization was executed using the Minlog system.

Program extraction, which derives formally verified software from constructive proofs, is exemplified in the paper by the creation of the SAT solver. This is in line with early program extraction practices observed in systems like Nuprl. Minlog, like other advanced interactive theorem provers such as Coq (which is based on the Calculus of Inductive Constructions) and Isabelle (a generic prover with multiple logic extensions), is proficient in program extraction.

For example, in Isabelle, various decision procedures, including the DPLL algorithm, have been verified and incorporated into the system. Moreover, the automatic theorem prover Metis was formally verified in Isabelle and is now employed to rebuild proofs from quicker external processes.

In contrast to methodologies that require an explicit statement of the algorithm to be verified, as done in Coq and Isabelle, the authors of this paper commence with a theorem claiming each CNF formula is either unsatisfiable or has a model, and from there, synthesize the SAT-solving program. Their ultimate aim is to integrate automatic verification techniques into Minlog, with the creation of the SAT solver being a preliminary step.

The extraction of the program honors different types of quantifiers by discarding any information tied to the quantified variable in non-computational (nc) cases. Proof rules for nc-quantifiers have strict conditions to ensure the information excluded is genuinely unnecessary in the program. Minlog is designed to automatically identify the maximal subset of quantifier occurrences in a proof that can be marked as non-computational without affecting proof correctness.

Finally, for practical application of the solver, the Minlog-extracted term needs translation into a functional programming language, such as Scheme or Haskell. A translation mechanism exists for Scheme, though it lacks the capability to handle inductive definitions and general recursion. The authors wish to expand this translation capacity and speculate on performance gains possible with Haskell's lazy evaluation.