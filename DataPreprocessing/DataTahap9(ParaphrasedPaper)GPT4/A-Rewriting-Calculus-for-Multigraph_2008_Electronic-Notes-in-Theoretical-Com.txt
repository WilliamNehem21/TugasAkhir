Graphs are widely recognized for their utility in depicting complex systems, such as communication networks, neural networks, UML diagrams, microprocessor designs, XML documents, and biological structures. The dynamic changes within these structures can be modeled using graph transformation, which is a rule-based approach. There have been various proposals on how to formalize graph transformation and define graph rewriting, as highlighted in various summaries.

A node in a graph is defined by its adjacency list, which contains pairs of neighboring nodes and the corresponding labels of the edges connecting them. Should a node not have any neighbors, its adjacency list would be empty. A subgraph is a subset of a larger graph, containing a selection of its nodes and edges.

Graph transformation rules are epitomized by a left-hand side graph, L, and a right-hand side graph, R, with a defined correspondence between elements of L to those of R aided by unique identifiers assigned to nodes.

When transforming a graph, there are critical issues to address, such as whether non-injective matching (where multiple nodes in L correspond to a single node in the host graph) is permitted, which affect whether nodes will be preserved or deleted upon transformation. Another issue concerns how to deal with dangling edges that result from transformation rules, referred to as the identification and dangling problems.

We represent unmatched nodes as 'UN', unmatched edges (where both endpoints are matched but the edge itself isn't) as 'UE', and bridges (edges not matched by L with one matched endpoint and one unmatched endpoint) as 'B'.

For rewriting in the context of multigraphs, it is necessary to consider the context within which replacements occur. This is achieved by enriching rewrite rules with extension variables that capture the context, allowing the application of rewrite steps to subterms, a common practice in associative and commutative rewriting.

The process involves an extended rewrite rule 't1 d t2', where an ACU-matching algorithm solves the matching problem, and a strategy, 's', which is used to reduce a term to its normal form with respect to specified cleaning and restructuring rules.