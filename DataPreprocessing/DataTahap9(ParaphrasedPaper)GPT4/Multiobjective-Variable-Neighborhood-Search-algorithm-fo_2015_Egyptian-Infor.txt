Grid computing is a model of distributed computing where computational resources such as computing power, applications, data, storage, and network capabilities are shared and operated across an organization that is spread over various locations. Users access these shared grid resources by submitting tasks to the grid system, which comprises various elements including computers, storage, instruments, software applications, and data that are interconnected via the internet and managed through middleware responsible for security, monitoring, and resource allocation.

Variable Neighborhood Search (VNS) is an efficient, straightforward meta-heuristic approach to solving complex optimization problems. This method structure is focused on systematic modifications to a set of solutions ('neighborhoods') during two key phases—a descent phase to locate a local minimum, and a perturbation phase to escape the minimum and explore other potential solutions. VNS has been effective in various practical applications such as offshore pipeline network design and the pooling problem, and it has been applied to real-world optimization challenges like optimizing cable layouts in power plants and optical routing.

Although scheduling problems often aim at optimizing objectives such as makespan (completion time) and flow time (time in the system), relatively few studies have explored these objectives in depth. Some researchers have investigated optimization with multiple objectives, including makespan, resource use, time, and cost. Others have used algorithms like Chemical Reaction Optimization (CRO) to approach grid job scheduling issues with objectives like makespan, flow time, and tardiness.

VNS performance is highly dependent on its neighborhood structure. Researchers have enhanced VNS by creating specific neighborhoods tuned to address extensive and complex scheduling problems in heterogeneous computing environments. In this research, the focus is on a multiobjective scheduling problem that aims to optimize a combined function of makespan and flow time.

A computational grid provides reliable, widespread access to advanced computational resources at a low cost. A grid scheduler (GS) processes user applications, selects suitable computing nodes based on grid information service (GIS) data, and maps applications to nodes according to certain objectives and predicted node performance. Scheduling algorithms facilitate task-resource mapping, aiming to optimize system-related metrics like makespan and user-centric metrics such as flowtime.

The GIS serves a critical role in providing status updates on available computing nodes to grid schedulers. It collects and predicts node performance data, including CPU speed, memory size, network bandwidth, software availability, and expected loads at various times. GIS responds to information requests and can also actively distribute information to users.

Describing a specific neighborhood function, one method involves assigning a light node—defined by its minimal local makespan—to a random job from a heavy node's job list, where heavy nodes have the maximum local makespan, indicating the finish time of its most recent job.

For initial solutions, VNS seeks a descent direction within a neighborhood, moves to the local minimum along that direction, and then modifies the neighborhood structure after performing a local search. The heuristic either continues iterating if a descent direction exists or stops when no such direction is found.

In tackling heterogeneous computing scheduling problems, researchers frequently use benchmark instances provided by Braun et al. and apply the Expected Time to Compute (ETC) model proposed by Ali et al. This model considers machine heterogeneity (variation in a task's execution time across different nodes), task heterogeneity (variation in execution times of different tasks on the same machine), and consistency. In a consistent scenario, if one node is faster than another for any task, it is faster for all tasks. Conversely, in inconsistent scenarios, a machine's performance may vary depending on the task. A semi-consistent scenario is an intermediate situation where an inconsistent system includes consistent elements.