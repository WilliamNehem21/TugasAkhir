The paper discusses how two compatible interface automata can be composed in at least one design configuration due to their non-input-enabled nature, which contrasts with I/O automata and CSP where all input actions are enabled at any given state. Interface automata synchronize shared input and output actions for interaction, while internal actions are handled asynchronously. The authors have previously enhanced interface automata to include action semantics for better verification of components' interoperability. This enhancement involves adding preconditions and postconditions to the transitions, which are atomic propositions over variables. However, their earlier work did not address refinement of interface automata fully, which is the primary focus of the current paper.

Refinement in interface automata formalizes the relationship between abstract and concrete component versions. Unlike I/O automata, where refinement is seen as trace containment or simulation, interface automata refinement must adjust to non-input-enabled settings to prevent the refined interface from being usable in fewer environments than its abstract counterpart. The paper introduces an alternating refinement simulation approach, which views interface automata as alternating transition systems, modeling the refinement as a game between components where the refined automata can offer more services and demand fewer services.

The refined interface uses additional variables to formulate more detailed preconditions and postconditions for its refined and new input actions, but the conditions for output actions remain unchanged. This approach acknowledges that offered services are component-specific, and their semantic constraints might be strengthened, unlike demanded services, which are not refined by the component itself.

The composition condition for interface automata remains unchanged from previous approaches, with actions being disjoint except for shared input and output. The verification algorithm for compatibility incorporates these semantic action constraints without increasing the computational complexity and preserves linear complexity.

Refinement aims to transition from a high-level to a more concrete interface specification. Interface automata refinement allows for more inputs and fewer outputs in the concrete version than in the abstract. The paper stipulates variants for defining preconditions and postconditions during refinement, ensuring that new services added to a component are defined clearly and existing operations are enriched with stronger semantic constraints.

Finally, the paper applies this refinement approach to a case study with the Cycab car, an electronic transportation system which operates under computer control and features multiple automatic driving modes. The Cycab car system serves as an illustration of how the proposed refinement method can be applied in practice to component-based systems.