This paper discusses the utilization of XML as a meta-model enabling the creation of schemas for specific roles, like SrcML and JavaML that define XML-compliant schemas for source code representation but differ in their approach to integrating code with the schema. SrcML embeds markup in the source code, whereas JavaML embeds code in the model as attributes. Similarly, GXL, another XML schema, represents graph-based software structures, showcasing the diversity in XML usage given different conceptual pressures.

The authors suggest a solution involving multiple schemas and representation models through a multilayered approach, which provides for separation of concerns across different layers, where higher layers are not overly restricted by the lower layers' constraints. The paper details a three-layered implementation involving a storage layer (that might use different database models like relational, object, or text), a schema layer (which can include additional schemas for information that doesn't fit higher conceptual models), and a conceptual layer where traditional markups like XML are used.

The storage layer, which can differ based on database choice, might face little scalability issues due to modern databases handling large datasets. Direct storage using the storage model is not favored due to the lack of manipulation features, leading to the development of query languages such as the one by Paul and Prakash for source code. Storing multiple XML schemas in a single database requires further research, especially around normalization and efficiency when retrieving decomposed code.

The paper describes Jupiter, a project exploring multi-level markup with a simplified second level of markup tailored for efficient retrieval and mapping to a structured text database system like Multitext. This highly simplified storage level markup supports algebraic querying and reflects no semantic constraints on relationships, presenting items as atomic and attributeless tokens.

The potential development of multi-layered approaches may lead to layers focused on specific concepts, such as an AST-based layer below a higher-level DMM-based layer. While multi-layered approaches promise flexibility, their complexity and lack of extensive research make their impact on reverse engineering minimal so far.

Further research is required to understand how traditional storage models can integrate multiple conceptual models and how to map abstract graphical languages to database query languages effectively. There's a discussion on developing common conceptual models for information interchange, though not yet in relation to software storage models. Recognizing that efforts in extracting and representing information, and the development of repository systems should not be disjoint but rather combined under a layered implementation approach, is vital for advancing reverse engineering tools.