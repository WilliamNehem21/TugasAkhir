Declarative debugging is a method that builds a computation tree, reflecting the steps a flawed program takes during execution. The structure of this tree varies depending on the error types being identified. Nodes in the computation tree denote the outcomes of individual computation steps, linked to their respective subordinate computations that led to those outcomes.

When a program produces incorrect or unexpected outcomes, its computation tree will contain erroneous nodes, reflecting miscalculations unintended by the developer. Some of these nodes are erroneous due to other faulty computations, while others represent actual bugs, indicated by their correct child nodes but incorrect results.

The paper proposes an improved transformation technique for programs that addresses certain limitations by specifically transforming functions within the IO monad. Since IO is an abstract type, user-defined functions cannot directly inspect elements of this type. Adaptors for primitive IO functions are defined, most of which can be mechanistically derived from the semantic model of the IO type. Only a handful of these primitives require predefined implementations; no additional non-standard primitives are necessary.

The paper is organized into several sections: an overview of standard program transformation methods for identifying errors in functional and functional logic languages; an examination of monadic IO and its challenges for program transformation; the introduction of a modified transformation that works with monadic IO; and finally, discussions of related work and conclusions.

The debugger's computation trees will contain basic facts at their nodes, each associated with a program rule applied at that computation step. If the debugger identifies a node as buggy, it indicates an incorrect program rule. The node's children represent subcomputations for the condition and right-hand side evaluation of the rule. Results ensure that the debugger will spot an incorrect rule if a wrong answer is detected.

Several strategies exist for creating and navigating computation trees, such as meta-interpreters in logic programming that replay goals during debugging. Thus, a computation tree isn't explicitly formed, facilitating the handling of both incorrect and missing answers. This concept has extended to functional logic languages in systems like NU-Prolog, but isn't available in languages without built-in meta-instructions like Haskell or Curry. Notable, declarative logic languages can handle missing answers, which are often complex and tend to occur alongside wrong answers. Addressing a wrong answer often resolves both errors, as demonstrated by the debugging tool in question.

If a computation tree is lost in this context, it's not a concern since the approach focuses on wrong answers only. The exception condition, where no answer is computed, is represented by the error case (Left e, w). Maintaining trees for such cases is unnecessary, as no answer computation occurred.