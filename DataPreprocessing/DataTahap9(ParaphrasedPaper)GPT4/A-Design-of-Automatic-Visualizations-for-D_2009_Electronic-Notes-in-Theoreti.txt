We've established a framework to create multiple visualization platforms, each tailored to specific design techniques. As a testament to our framework's viability, we first constructed a system, SRec, to demonstrate recursion visualization. Our current project involves crafting a visualization system for establishing divide-and-conquer algorithm design techniques.

The concept of divide-and-conquer algorithms is commonly understood; nevertheless, we reiterate the terminology for clarity within our paper. These algorithms break down a problem into smaller parts, solve each recursively, then merge the partial solutions to resolve the original issue.

Such algorithms typically navigate and manipulate data structures, confining each subproblem to a segment of the structure, such as subarrays, subvectors, or submatrices when dealing with one- or two-dimensional arrays. Delimiting these segments is most efficiently done with a range marked by lower and upper indices.

Our system equips users to choose what parameters or results they want to see. For methods that manipulate data without returning values, we visualize both the original and altered parameter states. The system includes tools, like zoom and panning or overview and detail, which manage extensive activation trees. Users can also apply custom color codes to differentiate between input/output values and the call status within the overall procedure—whether executed, active, or pending. Despite these features, the visual outcomes have not yet been fully satisfactory.

The partition tree, a variant of an activation tree, effectively merges recursion and vector visuals. It's a tree that mirrors an activation tree, showing elements of the vector as either tree nodes, indicating their final position, or as components of a subvector when they have not been processed.

Contrasting views on recursive algorithm visualization are discussed, citing Stern's division of algorithms into categories based on how they interact with data structures—altering, traversing, or building them—rather than their recursion patterns. However, it's unclear whether these visual concepts are universally applicable. Their visual models include vectors for the modifying algorithms and trees for the other types, with a divide-and-conquer example (quicksort) demonstrated through the vector and corresponding recursive call bars.

We've created a prototype illustrating our design concepts, but further development is needed for a fully functional system. To confirm the system's effectiveness, we advocate for usability tests conducted by professionals (e.g., instructors) and during student sessions, similar to the evaluations done for the SRec system.