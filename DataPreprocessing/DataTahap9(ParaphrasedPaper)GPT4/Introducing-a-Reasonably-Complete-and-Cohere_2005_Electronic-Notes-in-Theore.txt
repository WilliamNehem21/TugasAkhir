The paper discusses the concept of model-based testing, which involves creating test cases from a model that represents the behavior of software. Such models might originate from formal specifications or be designed by software engineers using various tools. The paper reviews model-based testing methodologies and highlights shortcomings of existing methods.

The document is structured as follows: Section 2 provides an overview of model-based testing approaches and identifies their limitations. Section 3 describes the technologies to be used throughout the study. Section 4 introduces the authors' novel contribution to the field, which, while still in its infancy, differs from established practices. Section 5 offers concluding remarks and suggests directions for future research.

Scenarios are a common method for modeling and analyzing software systems, however, they only represent possible execution paths, not the complete system behavior. Hence, they are often combined with state machines for a more comprehensive approach, commonly used in component-based development.

State machines are constructed by synthesizing them from scenarios, creating a machine for each process outlined in the scenario. These machines include all the events from the process as specified in the scenarios, in the order indicated by their sequence within the scenarios. Many algorithms and tools exist for state machine synthesis from scenarios.

A key expectation from the synthesis process is that the resulting state machine accurately mirrors the scenarios. Occasionally, however, the synthesized state-based model may exhibit behaviors not found in the original scenarios, known as implied scenarios, which arise from inconsistencies between local and global behavioral perspectives.

To ensure a deadlock-free model, the presence of unrealizable scenarios indicates implied scenarios. One proposed method uses both message sequence charts (MSCs) and high-level MSCs (HMSCs) to build a behavioral model and spot implied scenarios therein.

It should be noted that implied scenarios aren't necessarily unwanted. By deploying positive and negative scenarios, the specified implied scenarios can be filtered, leading to an updated initial specification. Through iterative assessment and refinement of scenarios and state machines, all implied scenarios are identified and categorized as either acceptable or not.