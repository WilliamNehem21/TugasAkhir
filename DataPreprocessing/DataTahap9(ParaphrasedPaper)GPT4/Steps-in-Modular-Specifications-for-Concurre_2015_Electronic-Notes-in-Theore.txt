The challenge of creating specifications for concurrent program modules is notable because these specifications require sufficient strength to enable reasoning about how potential clients will use the modules without needing to delve into the module's implementation. This paper reviews several verification techniques for specifying concurrent modules and emphasizes four principal concepts: auxiliary state, interference abstraction, resource ownership, and atomicity, which together form effective strategies for specification.

However, these strategies fall short when specifying clients like the ticket lock because they do not maintain information about counter values or how operations affect these values, resulting in specifications that cannot ensure invariants around precise counter values.

The auxiliary state concept, originating from the Owicki-Gries method, simplifies concurrent module specifications by abstracting thread internal states, making it easier to represent invariants than dealing with each thread's program counter and variables.

The paper discusses how specifications can inadequately capture the behavior of concurrent operations such as in the ticket lock scenario, where concurrent executions and updates to a counter can occur, challenging the specification.

Permission accounting, introduced to separation logic by Bornat and others, enables dividing shared resources by associating fractions with them, which can be further subdivided for resource delegation. This concept allows for resources to be carefully managed and reasoned about in a concurrent environment.

Atomicity, essential for specifying concurrent modules, provides an interference abstraction by ensuring that any observable effects of an operation occur at a single point, allowing clients to disregard intermediate states that might occur in non-atomic operations.

The paper also examines how the non-modularity of the Owicki-Gries method was addressed by Jacobs and Piessens through the use of higher-order specifications, which are parameterized by auxiliary code determined at the operation's call site.

Atomic triples are introduced as specifications that enable independent operation verification within an abstraction framework, thereby allowing for modular extension of concurrent modules without re-verifying existing operations. This contrasts with linearisability, which is considered when adding new operations to a module and can complicate the verification process.

The authors present a generalized version of the atomic triple that can integrate atomicity with resource transfer, providing more nuanced specifications than traditional linearisability. This flexibility allows for specifying operations that involve both atomic reads and non-atomic resource transfers.

Concluding the paper, the authors assert that their presented counter specifications are robust, enrich synchronisation mechanisms, and enforce obligations on both client and implementation, thus providing a more expressive resource in concurrent programming verification than both CAP and linearisability specifications. The paper showcases the utility of multiple proof methods, combining their best features to create specifications with high expressiveness and modularity.