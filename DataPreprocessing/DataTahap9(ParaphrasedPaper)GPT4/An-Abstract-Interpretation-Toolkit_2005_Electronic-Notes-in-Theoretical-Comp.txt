This paper discusses an abstract model checker, which creates a transition system that is a double approximation of the original system. It employs a three-valued logic to determine whether properties are satisfied or refuted. This three-valued model checking problem can be reduced to two standard two-valued problems, allowing for the use of existing model-checking tools.

The model checker supports the use of homomorphisms and Galois connections to bridge concrete and abstract domains. In the homomorphic approach, each concrete data value is related to a single abstract value through a mapping function, whereas the Galois connection approach allows a concrete data value to be related to multiple abstract values.

The tool, called the abstractor, can use either approach or a combination of both. It automatically converts a homomorphism into a Galois connection given the mapping between concrete and abstract data domains and the definition of abstract functions. The abstractor outputs an incomplete modal-LPE, and the user must complete it with abstract domains and abstract function definitions. An abstraction loader helps manage these domains through import/export functions and an automatic abstraction generator.

The loader's export mode specifies the needed functions (which for manipulating sets are automatically generated), while the load mode imports definitions, and the auto mode carries out pointwise abstraction for sorts and functions.

In the next step, an abstract formula is interpreted over a modal-LTS, yielding two sets of states: one that necessarily satisfies the formula and one that possibly satisfies it. The three-valued model checking problem can be simplified into two two-valued problems, making it compatible with existing model checking tools like the evaluator in the CADP toolset. This linear time transformation uses one model and two formula versions, a more efficient approach than duplicating models.

The paper also discusses how this tool has been applied in various case studies, including verifying JavaSpaces applications, which use a shared repository for parallel processing. By abstracting specific parameters, the tool enabled model checking for a system with over 100 processes. It could also cope with the infinite state space in protocol verification by abstracting certain parameters.

Finally, the paper mentions related tools such as FeaVer, ABC, and Java Pathfinder, along with the techniques they use for abstract model checking. FeaVer translates code to Promela and allows user-defined abstractions, ABC abstracts C code directly, and Java Pathfinder, Bebop, and SLAM use predicate abstraction. The paper provides a reference for a comprehensive overview of tools and techniques in this field.