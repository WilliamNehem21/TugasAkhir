Our proposed type system for MIL aligns with the tradition of Typed Assembly Languages (TALs), augmented with capabilities for multithreading and synchronization, taking inspiration from Flanagan and Abadi's work. However, our approach operates at a lower level of abstraction and addresses unique challenges associated with languages that lack lexical scoping. Although lock primitives have been discussed in the context of concurrent object calculi, Java Virtual Machine (JVM), and lower-level languages like C and C--, they have not been examined within the framework of TALs or intermediate languages. In our type-safe environment, programs are designed to avoid race conditions.

We enable the creation of read-only tuples directly in registers, eliminating the need for locking or permissions when the tuple is used by a single thread on one processor. However, when a tuple is to be shared between threads, we employ a "share" instruction to allocate space on the heap, transferring the tuple from the register to the heap securely, either by employing a lock or by marking it as read-only.

Our system incorporates both universal and existential polymorphism, specifically applying existential polymorphism to locks. This allows lock variables to transcend their static scope of declaration, providing greater flexibility in lock management.

Regarding our queue implementation within a monitor construct, the removal operation from an empty queue is undefined, ensuring that a consumer will wait for the producer to populate the queue before attempting to dequeue. We assume the queue has infinite capacity, enabling producers to continually add items without blocking. This contrasts with the dequeue operation, which does necessitate waiting when the queue is empty.