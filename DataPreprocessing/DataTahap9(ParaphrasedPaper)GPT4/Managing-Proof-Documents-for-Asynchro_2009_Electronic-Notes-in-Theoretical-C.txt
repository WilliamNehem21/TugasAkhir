This academic paper discusses the limitations of traditional linear interaction with interactive proof systems and proposes a new asynchronous model that enhances usability and the efficiency of proof command processing.

Traditionally, proof scripts are executed step-by-step and become locked upon verification, preventing further editing. Users revert steps using an undo mechanism in the prover to unlock and edit parts of the script. User interfaces serve as script buffers, tracking processed commands for later replay.

However, this linear model does not cater well to the usability improvements necessary for future interfaces. One usability approach is direct manipulation, as presented in work by Aspinall et al., who suggest a document-centered interface allowing users to edit proof documents as mathematicians edit paper proofs, using provers only for verification. Yet, their proof command processing remains linear.

In contrast, the language of proofs allows postponing execution until resources are available, since references to proven facts are not influenced. Proofs can run in parallel, reducing the response time to user edits.

The paper underscores the benefit of a batch-mode behavior, similar to Mizar, enabling the prover to annotate errors and continue processing unaffected commands, enhancing the proof document metaphor.

The authors propose a departure from the linear model, advocating for asynchronous processing and a communication protocol that allows the prover to determine the sequence of command processing. This protocol supports existing linear-processing provers.

A new state model for commands and an architectural design for asynchronous processing support are introduced. Different software architectures for user interfaces are proposed, compatible with other proof systems due to abstract modeling.

The authors suggest an ownership semantics for asynchronous processing, with a protocol for transferring command ownership between processes. States like "sent", "error", and substates indicate command processing status, with the user interface reflecting this visually.

The paper outlines the communication protocol and document structure maintenance strategies. The user interface could use various event triggers, and the authors find advantages in experimenting with different approaches and strategies.

Incremental parsing is considered but ultimately, a specialized solution is chosen for document structure maintenance. The executor follows the state model for command handling.

The user interface displays the proof document with visual indicators on processing status, reflecting user edits in real-time. Output widgets function differently from traditional ones, displaying results based on the command where the caret resides.

Message communication between the user interface and prover is observable by users, with strategies for sending commands contingent on user interaction and multi-core processor capabilities minimizing interface lag.

In summary, the paper advocates for a shift towards asynchronous proof processing, improving proof system usability by allowing more flexible interactions and providing a more responsive, user-friendly interface.