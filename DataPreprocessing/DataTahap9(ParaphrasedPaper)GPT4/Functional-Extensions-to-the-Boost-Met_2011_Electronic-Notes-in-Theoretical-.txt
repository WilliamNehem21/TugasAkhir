Template metaprogramming is becoming increasingly prevalent in C++ applications, either directly or through libraries that utilize it. Due to its complexity, developers benefit from supplementary libraries like the Boost Template Metaprogramming Library (Boost.MPL), the most commonly used one. Boost.MPL offers an extensive collection of compile-time algorithms and meta-data structures designed for extensibility and reusability. However, even though template metaprogramming shares a lot with functional programming, Boost.MPL is missing some capabilities that would provide more seamless functional programming integration.

Over the past decade and a half, significant strides have been made in laying the groundwork for template metaprogramming, including meta-data structures and algorithms. The Boost libraries are pivotal in C++ development, facilitating template metaprogramming and reducing boilerplate code by offering structured tools, utilities, and algorithms.

Our research involved creating a complex template metaprogramming library that leans heavily on functional paradigms and utilizes Boost.MPL. We noted Boost.MPL's lack of certain tools commonplace in functional languages and absent in C++ template metaprogramming. Consequently, we evaluate Boost.MPL's capacity for functional programming and suggest enhancements that better embrace the functional style, which we've implemented and incorporated into our library.

Specifically, we extended Boost.MPL to align more with functional programming, addressing lazy evaluation, function composition, and currying. The evaluation of metafunctions is deferred until necessary, and a mechanism for composing metafunctions and currying—the transformation of a function that takes multiple arguments into a sequence of functions each with a single argument—is introduced.

For instance, we discuss "lazy evaluation" where nullary metafunction values are accessed only when needed, and how Boost.MPL's metafunctions can represent both data-value and nullary metafunctions. We also encounter challenges in fully lazy evaluation in metafunctions, as fully-generic lazy argument implementation isn't possible in C++ without evaluating unused or error-inducing branches.

Furthermore, we introduce a proof-of-concept for fully lazy metafunctions by Vesa Karvonen and the complexities of function application when dealing with template metafunction classes. By advocating for function composition and currying support in template metaprogramming, we aim to reduce the intricacy of metaprograms in C++.

Consequently, we propose a currying technique for template metafunctions, necessitating the need for different implementations depending on the number of arguments. This involves building a curried version of metafunctions that gradually collects arguments in a compile-time list until ready for application.

Lastly, we contrast runtime functional programming support in C++ provided by libraries like FC++ with the needs of template metaprograms, which always operate at compile-time, emphasizing the distinct tooling required for effectively developing software in a functional paradigm.