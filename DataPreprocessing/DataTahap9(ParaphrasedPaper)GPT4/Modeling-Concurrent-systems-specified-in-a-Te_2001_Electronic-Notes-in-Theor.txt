The primary instrument in our study is the Timed Concurrent Constraint Programming (tcc) framework, as established by Saraswat and colleagues, which serves as the model for describing reactive systems. This framework benefits from the inherent attributes of declarative programming, particularly with the integration of time into the language's semantics. By confining model checking to a user-defined finite time interval, we can restrict the behavior space of the program to a finite set, allowing conventional model-checking algorithms to apply. Generating the behavior graph from the tcc specification is an automated process.

The tcc model is integral to constraint programming as it detects not only the presence (positive information) but also the absence (negative information) of information. Such detection is essential for modeling reactive and real-time systems. The model emphasizes that once negative information is identified, it's impossible to alter the pastâ€”if certain information isn't recorded at a specific moment, it will never be captured.

Model checking, a method for formal verification, involves an exhaustive review of all system states to validate specific behavioral properties algorithmically. Our approach utilizes constraint-based languages to abstractly construct models from specifications. Utilizing the explicit concept of time in tcc, we can bind variables within finite models suitable for classical model checking.

The paper consists of several sections. Section 2 introduces the tcc language, its semantics, and its features. Section 3 presents the definition and basic principles of the tcc structure, with Section 3.3 detailing how to model the system using a finite graph for an infinite state model. Section 4 discusses how user-provided time parameters and values introduce constraints. The paper ends with conclusions and further considerations.

We highlight timing constructs like timed negative ask, unit delay, and abortion which extend processes over time, with timed negative ask initiating a process based on the absence of data. To ensure a finite model representation, some operations, such as "always a," will not be translated.

Formal modeling of a system is the first step in verification. For reactive systems, it's crucial to capture their ongoing state. Our state transition graph construction begins with the tcc formalism and incorporates explicit time. We express states and transitions with first-order formulas that include time as an additional parameter.

In the graph, a state is a bundle of constraints (variable values) and labels (execution points), where active labels depend on the system's store at each moment. The graph reflects the construction process from the tcc structure, distinguishing two types of transitions and identifying quiescence points.

Upon reaching quiescence, we transition to the next time instant, creating a new graph node and deciding how to proceed based on the current state's labels. To ensure graph finiteness, we employ the concept of a finite time interval for verification. This completes once we reach an upper bound or the construction concludes earlier, yielding a valid model for system verification.

Graph construction involves various tcc syntactic constructs such as tell, ask, parallel, hiding, procedure call, and always. Each of these transforms the graph nodes differently, either by adding information, testing conditions, conducting concurrent execution, renaming variables, or modeling cyclic behavior.

While our tcc-based graph is not directly compatible with classical model checking due to its unrestricted variable domains and the presence of variables without specific values, we overcome this by imposing restrictions that enforce finite domains.

To summarize, our method automatically transforms a tcc program into a graph depicting system behavior, with synchronization ensured within each time instant and across time intervals. This finite construction is related to the work of Clarke and others, who synchronize parallel processes to conclude at the same time.