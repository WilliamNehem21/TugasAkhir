This academic paper discusses the challenges and proposed solutions for generating tests for modern software, which is often concurrent, timed, distributed, and, as a result, non-deterministic. Traditional test generation methods, such as those using linear temporal logic (LTL) or computation tree logic (CTL) model checking, can encounter difficulties when dealing with non-determinism. To tackle this, the paper suggests methods that use fault modeling through mutation and leverage both conventional (closed) and modular (open) model checkers.

The paper advances the idea that deterministic strategies for test generation are insufficient due to the inherent non-determinism in current software systems caused by factors like asynchrony and multithreading. Non-determinism can also be introduced by incomplete knowledge, limitations in modeling languages, and the use of conservative abstractions to manage complexity.

To address these challenges, the authors propose an approach where finding mutant-killing tests is analogous to reaching states that satisfy certain properties within a model combined with faulty sub-modules. This method can help create tests that account for both specification coverage and fault propagation.

The paper is organized into several sections, beginning with necessary definitions, followed by a discussion of generating tests from model or module checking in non-deterministic settings, and then considering the application of results to multiple mutants. The final sections cover related work and conclusions.

The authors introduce the concept of a 'module,' compared to a Kripke structure with partitioned atomic propositions, and explain that in the presence of hidden variables, extended finite state machine (EFSM) models can offer a more compact representation.

They acknowledge the potential benefits of using traditional LTL or CTL model checking for simpler cases but cast doubt on the efficacy of these methods for deriving strong tests in non-deterministic scenarios without incurring significant computation costs due to state space increase.

Lastly, the paper explores the possibility of an incremental approach to generating strong tests by verifying all test candidates of a given length, albeit with a caution about the limitations related to memory consumption.

In summary, the paper addresses the complexities of test generation in non-deterministic software systems, proposes new methods to surmount these challenges, and critically analyses the limitations of current model checking techniques and test generation approaches.