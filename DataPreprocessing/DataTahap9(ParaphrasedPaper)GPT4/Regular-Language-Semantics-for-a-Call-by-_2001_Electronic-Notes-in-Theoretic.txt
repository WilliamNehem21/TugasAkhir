The original paper contends that while a comprehensive games calculus capturing the full scope of games may be out of reach, specialized calculi for certain game-based models offer practical benefits. These calculi make game semantics more approachable and provide a foundation for innovative program analysis methods backed by robust theory. Hankin and Malacaria have similarly approached static analysis research.

The paper anticipates that readers may not be acquainted with game semantics and acknowledges the impossibility of thoroughly covering the topic within a short space. Introductory materials are available elsewhere. The game model the paper uses for the language FOIL is sourced from Abramsky and McCusker's work. The paper focuses on essential elements of game semantics, especially relevant to call-by-value gameplay.

The conceptual approach to interpreting a term in game semantics involves a two-stage strategy reflective of the call-by-value paradigm: first, selecting a game from a family of games (the protocol phase), followed by playing the selected game. This reflects the call-by-value approach where all arguments are evaluated once before evaluating the function body, maintaining a single value for free identifiers during evaluation. Unlike call-by-value, call-by-name evaluation allows free identifiers to represent various values at different evaluation stages.

In providing a regular language representation for the game semantics of FOIL, types correlate with games defined as regular languages over a moves alphabet. Meanwhile, strategies relate to terms and are represented as regular languages over the combined alphabets of free identifier types and the term itself.

The paper elaborates on game semantics, exemplifying with the 'if' construct and describes looping through a recursion combinator. Although a general recursion combinator isn't laid out, a fixed point can be manually derived, with the 'while' semantics demonstrated as a result of this process.

Ultimately, the paper showcases a game semantics-based regular language model for an imperative language featuring first-order procedures, call-by-value, and by-reference passing for arrays and variables. This model adapts the game semantic model from Abramsky and McCusker's work, omitting certain game mechanics like justification pointers as unnecessary for the language subset in question.