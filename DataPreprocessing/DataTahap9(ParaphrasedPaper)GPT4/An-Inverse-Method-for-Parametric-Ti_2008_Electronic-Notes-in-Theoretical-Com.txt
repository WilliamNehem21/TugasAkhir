This paper discusses event-based systems represented by vertices (events) and directed edges (causal dependencies) through the lens of timed automata, which are more flexible than timing constraint graphs due to their ability to handle system composition and action choices. Unlike regular timed automata that use constants, the paper focuses on parametric timed automata, which include parameters instead of constants, making them suitable for modeling various timed systems like communication protocols and asynchronous circuits.

The concept of constraint synthesis in these systems has been explored before using tools like an extension of UPPAAL for parametric model checking and noting the capability to infer nonlinear constraints. The idea of refining constraints using counter-examples is applied here, similar to how it is often used in CEGAR-based methods, where a "bad state" is one that is not compatible with the reference valuation.

The paper outlines its structure as follows: introduction of parametric timed automata (section 2), a motivating example (section 3), the proposed constraint synthesis method (section 4), application of the method to examples including cyclic traces (section 5), and concluding remarks with future work (section 6).

It assumes readers understand standard timed automata, which use boolean combinations of atomic conditions with integer constants, and extends this idea by allowing the use of parameters instead of constants. This parameterization does not hinder practical application despite some technical constraints like guards and invariants having to be in conjunctive form.

The paper restates a proposition from previous literature about symbolic traces being simulated by concrete traces and adapts it to its formalism using first-order constraints. It also comments on the algorithm's termination condition and the theoretical impossibility of finding an instantiated trace that exceeds any parametric trace given correct synthesis.

An elementary complexity analysis indicates that the synthesis procedure's complexity is exponential relative to parameters, locations, and doubly exponential relative to the number of clocks. Nonetheless, in practical applications with optimizations, the method has been effective in managing examples with sizable parameter counts, clocks, and thousands of locations, owing to its state space reduction capabilities.

The implementation of the synthesis procedure is scripted in Python and employs the tool HyTech. Its experimental phase involved applying the method to asynchronous circuits represented through bi-bounded inertial delay models, with promising results both short-term and for future larger-scale applications, particularly in the context of the French ANR project VALMEM and STMicroelectronics' memory circuit timing constraints.

In conclusion, the paper introduces an algorithm to synthesize constraints that ensure the derived set of traces agrees with those of a given parameter valuation. This algorithm has shown particular promise in the context of asynchronous circuit design and the goal to tackle even larger systems moving forward.