The paper introduces "ConSpec," an automaton-based language for specifying security policies. It balances the complexity of its language with the precision of its definitions, utilizing security automata to formally define its semantics. ConSpec can help in defining and enforcing security measures throughout the entire application lifecycle and supports the formalization of various enforcement techniques.

As mobile devices carry sensitive personal and financial data, the paper underscores the necessity of securing mobile applications. These devices also grant access to expensive services, necessitating a system that allows controlled access to these resources without stifling application development by imposing too many limitations.

The authors discuss how ConSpec can be applied during development, installation, and runtime to verify security specifications. They suggest incorporating a "contract" with the application which outlines its intended security behavior, akin to the Model-Carrying Code (MCC) approach, where program behavior is verified against a simplified model. However, the paper identifies ConSpec contracts as not necessarily derived from program analysis.

A pivotal contribution is the establishment of ConSpec as a language for specifying both user policies and application contracts. Its formal semantics are explained, alongside its application at various stages of the application lifecycle.

During the development phase, developers use ConSpec to express contracts that align with common security policies. Compliance can be ensured by static verification through a trusted third party or by using Proof-Carrying Code (PCC) methods that deliver compliance assurances via an accompagnying proof. If static verification is impractical, applications can be equipped with an execution monitor for runtime enforcement.

The paper provides an example scenario where two different developers might specify contracts based upon their awareness of the policy limits. One developer explicitly restricts the application to send one SMS message per day, while the other specifies a more complex rule based on user contacts and their birthdays because of uncertainty in behavior.

At runtime, policies may be enforced by monitoring the application's behavior, but this is often seen as a less desirable option due to its performance overhead. The authors suggest minimizing runtime work by utilizing static methods when possible, yet acknowledge that sometimes monitoring is the only viable security solution.

ConSpec's design is influenced by the PSLang language, created for runtime monitoring, and although PSLang's syntax is straightforward for integration, its lack of a formal underlying model complicates the formalization of security automaton from policy specifications.

Monitoring with ConSpec is described as a formalized co-execution of the ConSpec automaton and the application under observation. The authors also explain how to inline ConSpec monitoring directives within the application code, ensuring it complies with policy specifications.

Finally, the paper situates ConSpec alongside other automata-based languages, noting its similarity to PSLang. However, unlike PSLang or the Polymer language, which use programming constructs without formal semantics, ConSpec provides a rigorous foundation for proving the correctness of its enforcement mechanisms, primarily due to its formal semantics.