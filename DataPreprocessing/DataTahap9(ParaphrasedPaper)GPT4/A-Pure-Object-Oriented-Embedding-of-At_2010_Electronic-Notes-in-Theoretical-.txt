Recently, academic research on attribute grammar systems has shifted towards methods that determine both the attributes for evaluation and their evaluation sequence dynamically at runtime instead of during code generation. Prominent among these developments are systems like LRC, JastAdd, UU AG, and Silver. Such dynamic scheduling ensures that attributes are evaluated at most once, minimizing redundant computation. However, this technique introduces additional runtime overhead. Despite this, the tradeoff proves advantageous, particularly within integrated development environments (IDEs), where not all attributes are continuously necessary.

Current attribute grammar systems rely on code generators, which steepens the learning curve and complicates both development and build processes. Our paper proposes the integration of dynamically scheduled attribute grammar approaches into a pre-existing, modern object-oriented programming language as a library. We accomplish this through a pure embedding strategy that utilizes the native syntax, concepts, expressiveness, and libraries of the host language. By doing so, we maintain the high-level declarative essence of attribute grammar formalisms while also leveraging the flexibility and familiarity of the underlying language for both the specification and implementation phases.

Our paper describes the Kiama implementation in Section 3, explores language extension and separation of concerns utilizing the Scala platform in Section 4, and assesses Kiama's performance in Section 5. The final sections discuss our approach in relation to other attribute grammar systems (Section 6) and offer concluding thoughts (Section 7).

We illustrate our system through the repmin problem, a benchmark for tree analysis and transformation used to demonstrate the elimination of redundant tree traversals in functional programming. The goal is to transform a binary tree with integer leaves into a new tree with identical structure but with each leaf bearing the minimum value from the original tree's leaves.

Kiama allows for the flexible static combination of attribution modules using Scala's traits to define components that can be mixed together. For instance, we can divide the variable liveness problem into three separate concerns — control flow, variables, and the liveness computation itself — each abstracted by trait-defined interfaces.

We benchmark Kiama's attribute evaluation performance against a manually cached Scala implementation and a Java attribute evaluator generated by JastAdd. JastAdd is recognized for its application in creating high-performance Java compilers, offering results competitive with manual implementations.

Using the PicoJava specification as a test case, designed with 18 syntax rules and 10 attributes for name and type analysis, we measure performance on large, synthetically-generated programs; these inputs consist of classes with up to 150 nested definitions.

Kiama, our attribute grammar library, is developed differently from dynamic evaluation generators, focusing on a pure embedding within Scala. While inspired by JastAdd and similar in many features, including object-oriented support for attribute grammars, Kiama differs in that it omits the generation step, composing the full attribute grammar in Scala. This direct method creates a user-friendly, lightweight system with potential competitive power in both expressivity and performance compared to established systems like JastAdd.

Unlike generator-based systems that can perform correctness checks on attribute grammars during generation, Kiama does not always allow for such precise verifications, especially when syntax extensibility is a goal. However, Scala does offer partial checking through sealed case classes, enabling some degree of confidence in the completeness of the implementation through compile-time pattern match warnings.

In summary, dynamically-scheduled attribute grammars are an advanced tool for language processing, and our Kiama attribution library modernizes this approach by using Scala to eliminate the intermediate generation step, creating a system that is intuitive yet remains expressive and performative.