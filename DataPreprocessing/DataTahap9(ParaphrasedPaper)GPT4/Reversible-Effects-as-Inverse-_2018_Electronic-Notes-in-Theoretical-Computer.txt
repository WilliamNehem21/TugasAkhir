Our interest lies in developing reversibility concepts suitable for functional programming languages. Such languages are significant in reversibility research for two main reasons. Firstly, their inherent simplicity makes it easier to deduce and validate their behaviors, which is advantageous for comprehending the principles of reversible computing. Secondly, as they are inherently devoid of state, the reversal of programs becomes more straightforward. Despite this, current reversible functional programming models remain deficient in some conventional constructs that are well-established in their irreversible counterparts.

Irreversible functional languages like Haskell typically align with categorical semantics, where the objects represent types and morphisms represent functions, and they exclusively model stateless, pure functions. Nevertheless, there are times when side-effects - such as exceptions, I/O operations, or even state - are beneficial. Irreversible functional languages have elegantly managed these using constructs like monads or the more encompassing arrows.

The focus of this paper is to lay down foundational design tenets for robust reversible programming languages. The central contribution is to align desirable programming features with exact categorical theory constructs, featuring an academic orientation. To bridge the gap between theory and practical application, we use the syntax of a type-first order reversible functional language with type classes as a baseline for examples. The discussion begins with an overview of reversible base categories.

The paper also discusses variable assignment in reversible contexts, drawing parallels with how the reversible language Janus handles state alteration: since traditional destructive updates are forbidden, state changes are conducted through built-in reversible operations, like incrementing a variable by a constant or another variable's value.

We examine an alternative approach to invertibility through the concept of bidirectional arrows, which differ fundamentally from inverse arrows. While inverse arrows aim to incorporate effects into inherently invertible languages, bidirectional arrows aim to introduce invertibility into languages that are by default not invertible. Consequently, bidirectional arrows address different issues and do not inherently ensure invertibility across all cases.