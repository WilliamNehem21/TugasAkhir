The paper discusses the use of formal methods in industry for verifying the correctness of system models, specifically hardware, protocols, and distributed algorithms. Model checking is noted as an automatic method for verifying finite-state systems, though it has limitations due to the state explosion problem. The paper then describes imperative languages with explicit parallelism and communication statements, such as Occam and Promela, which provide clear frameworks for expressing system models and verification tasks.

The semantics of communication in a system are extended by introducing channel variables to record the history of values for each external channel. The paper distinguishes between internal and external channels, with the latter being part of the system's interface.

A communication elimination algorithm is proposed that iteratively removes pairs of matching communication statements (inputs and outputs on the same channel) which, if unsuccessful, indicates a deadlock possibility in the system. A proof construction method simulates execution where communication events match statement elimination pairs.

The concept of "communication-closed layers" is defined, and the paper also discusses the elimination of redundant variables as part of the statevector reduction process, noting that eliminating internal communications can affect external communications and lead to potential deadlocks. An example involving a three-register queue illustrates these concepts.

The paper introduces definitions and justifications for various refinement techniques, including concatenation chains and congruence symbols in proofs.

The central components of the system verification process are detailed, including the recursive elimination algorithm, the correctness theorem for the complete communication elimination procedure, and a while loop process for the elimination of communication pairs.

The overall focus of the paper is on the formal verification of concurrent systems through the meticulous refinement and reduction of components to ensure deadlock-free execution and correct system behavior.