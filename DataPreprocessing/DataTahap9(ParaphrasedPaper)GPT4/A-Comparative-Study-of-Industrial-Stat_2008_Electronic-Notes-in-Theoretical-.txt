Nearly all software has flaws, some glaring, others undetected - often due to rare occurrence or because they go unrecognized as errors or are not seen as critical. Software flaws can trigger various errors, from those affecting logic or function (like occasional incorrect computations) to others affecting performance or security.

This study aims to (1) pinpoint key static analysis features in tools that compilers miss, and (2) examine the technologies supporting these tools without ranking them due to differing functionalities and underlying technologies. Static analysis tools each have unique capabilities and detection methods, making comparisons difficult.

Acquiring detailed technical information about commercial proprietary tools is challenging, but available documents like manuals, white papers, and early-stage academic research provide some insight. Despite efforts to validate tool descriptions with providers, some uncertainty persists.

Languages like C and C++ focus on efficiency and portability, providing minimal runtime error prevention, leaving checks of bounds, null pointers, or type casts to the developer.

Static analysis involves automatically deducing runtime code properties without execution, excluding syntactic or functional correctness checks. It can detect potential runtime disruptions, not guarantee correct program outcomes. Static analysis includes checking for deadlocks, but there are specialized methods for other issues like timeliness or non-termination. It differs from dynamic analysis, which involves actual program execution.

A defect flagged by static analysis that isn't actually a defect is a false positive. The more imprecise the analysis, the higher the likelihood of false positives occurring.

Path and context sensitivity depend on tracking variable values; imprecise value and aliasing analysis could lead to numerous false positives. Analyzing incomplete code risks high false positives or negatives based on the assumptions made about missing parts.

Soundness, in terms of static analysis, can refer to the absence of false positives or reflect assumptions about possible executions. A sound analysis might still produce false positives but no false negatives.

Static analysis tools, like Polyspace, Klocwork, and Coverity, cater to specific markets and issues, e.g., embedded systems or networked applications, with varying degrees of handling security risks, resource leaks, and other defects.

Incremental analyses can be quicker than comprehensive ones, but each tool offers singular file analyses, though with limited depth.

Though all three tools evaluate C and C++ codes, only Klocwork initially supported Java, and only Polyspace supported Ada. Complexity and the risk of error limit the development of new checkers for these tools.

Concurrency handling is generally weak across tools, with only Polyspace providing substantial support.

User expectations of defect detection in thoroughly tested software varied, with some surprised at the discovery of long-standing bugs by static analysis tools. These findings highlight that static analysis might detect neglected issues that could become critical with changes in system configuration or usage patterns.

Comparative evaluations displayed diverse outcomes between tools, with Coverity generally outperforming others in terms of fault detection and fewer false positives. Coverity's analysis of third-party library code contributed to this edge.

CodePro Analytix, another tool aimed at development phases, integrates into the Eclipse IDE for quicker, interactive analysis, but it's not as comprehensive and generates many false positives, tempered only by selective analysis rules.

Tools relying on string and pattern matching approaches, like various derivatives of the lint program, yield high rates of both false positives and negatives due to shallow analyses.

On the contrary, sound dataflow analysis tools—while potentially generating false positives—offer path and context sensitivity. Polyspace Verifier/Desktop exemplifies such tools, offering a degree of certainty that if it gives code a clean bill of health (designated 'green'), the code is free from checked defects.

Each static analysis tool has limitations, often finding unique defects while missing others, underscoring the existence of dormant bugs not detectable without a sound analysis.