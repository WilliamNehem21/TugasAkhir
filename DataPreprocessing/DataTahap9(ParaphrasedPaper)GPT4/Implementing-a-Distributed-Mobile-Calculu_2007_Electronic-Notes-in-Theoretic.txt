Many research groups seeking to evaluate the quality of new computational models for mobile distributed systems have frequently created prototype implementations that can serve as core programming languages. To streamline the development phase of such implementations and accommodate the increasing number of experiments, we developed a versatile Java framework named IMC (Implementing Mobile Calculi). IMC functions as an intermediary platform for crafting multiple distributed calculi. It is designed to allow developers to focus on the unique aspects of their systems while leveraging the pre-built IMC framework for common distribution and mobility mechanisms, thus bypassing the minutiae of low-level programming. Using Java is intentional as it offers numerous benefits for crafting network applications equipped with mobile code—a favored choice among existing mobile and distributed systems.

IMC facilitates seamless code mobility, dynamic communication protocol composition, and node topology management, maintaining a high level of abstraction to simplify tasks like switching communication protocols without altering other components. IMC is user-friendly and does not require customization for basic use, but it does offer the option to personalize parts of the framework through interface implementations. Various design patterns (e.g., factory method, abstract factory, template method, and strategy) are incorporated throughout the package to enable both transparency and adaptability.

Among IMC's features is automatized code mobility handling, which covers the intricacies of code marshalling and dissemination. The framework aids in managing object marshalling, code migrations, and dynamic code loading, and is adaptable to various network structures and message routing.

To the best of our knowledge, no similar broad frameworks are reported in the literature.

We provide an overview of IMC's capabilities and interfaces, although we omit detailed descriptions. IMC consists of three main subpackages—protocols, mobility, and topology—which address respective issues. Our recommended approach for users implementing a runtime system for mobile calculi starts with developing the communication protocol, followed by node functionality using the protocol, and finally process functionalities dependent on node implementation.

IMC's protocol abstraction layer allows protocol reuse over different communication channels, including TCP, UDP, or file-streams—facilitated by specialized streams for writing (marshaler) and reading (unmarshaler) that extend Java's standard data streams and support mobile code.

Nodes in a network, managed by the topology package, are containers for running computational processes (or units). Processes, derived from the NodeProcess class, use resources from their nodes and migrate between them with ease. NodeProxy restricts node interface visibility for security. IMC already includes session handling, useful in various network topologies.

We detail a protocol used in JDPI networking, where components exchange messages through predefined means. The protocol greatly benefits from IMC’s mobility and protocol packages. Channels, references, sending, receiving, executing, and managing protocols are described, noting the abstraction provided for effective communication and the facilitation of intermediate communication roles.

Finally, we present two example mobile agents developed in JDPI, though space constraints limit our details. The code for an agent that searches multiple markets for the best price on an item is provided as one such example. For further information, IMC and JDPI, along with applications and examples, are available for download.