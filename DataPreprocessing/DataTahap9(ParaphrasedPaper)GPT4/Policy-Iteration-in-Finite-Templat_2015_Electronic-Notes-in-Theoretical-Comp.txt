The paper demonstrates that a policy iteration algorithm can be effectively applied to a finite set of templates without assumptions on their shape, using the principles of Lagrange duality. This algorithm is shown to converge to a stable solution under a simple technical condition and yields an over-approximating solution for reachable states in programming variables. The study also delves into selecting optimal templates that enhance algorithm performance, tying these choices to invariant algebraic relationships, which, when correctly selected, enable straightforward algorithm initialization for programs with single loops.

The authors initially introduced a complete lattice of function sub-level sets as an abstract domain for deriving numerical invariants within program analysis, based on earlier work that deviated from the linear-only template bias. Previously, a policy iteration method using shor relaxation and semi-definite programming was introduced for affine and quadratic constraints. In that work, convergence was only established for a relaxed form of the algorithm and quadratic templates had to be provided, often including a Lyapunov function for affine systems in programming.

This paper's main contribution is the universal policy iteration algorithm that employs Lagrange duality across any program arithmetic or template algebraic structure. It establishes that this algorithm reaches a fixed point for relaxed programming semantics. Furthermore, strategies for generating effective templates for simplistic one-loop programs are discussed and have shown that judicious template selection leads to a natural initial policy.

The structure of the paper is laid out as follows: Section 2 revisits the non-linear template-based abstract domain and abstract semantics. Section 3 outlines the relaxed semantics foundation via Lagrange duality. Section 4 reviews both Kleene and policy iteration within template domains and offers proofs of convergence. Section 5 discusses the criteria and initialization of effective templates particularly for single-loop programs. Section 6 explores practical applications, and Section 7 draws conclusions.

The work addresses the limitation of Kleene iteration, which can be slow and produce unsafe invariants mid-process, suggesting an alternative policy iteration that avoids these issues and provides safe invariants even if halted prematurely. Results indicate the policy iteration on quadratic templates converges to a postfixpoint beyond relaxed functional constraints (Theorem 4.2), confirmed by earlier findings (Theorem 3.1).

The choice of initial policies is critical, as improper choices can lead to quickly halted iterations and a less accurate fixed point. This highlights the importance of informed template selection. Lastly, the paper outlines future works to develop automated methods for both calculating invariant algebraic relations and initializing policy iteration based on these relations.