This paper presents an argument for a multicore-optimized version of the C++ Standard Template Library (STL) tailored for the Cilk++ platform. The authors focus on adapting STL containers, algorithms, and functors using C++'s generative programming techniques to leverage multicore processors effectively. They highlight the challenge of performance degradation due to memory fences in parallel applications and emphasize the need for fence-free solutions, particularly for asynchronous asymmetric communications that support complex streaming networks.

The STL's design emphasizes generic programming, where class templates define containers, and function templates implement algorithms. These algorithms are container-independent, allowing for broad interoperability within STL. However, while the extensibility of STL allows for the integration of new containers and algorithms, it is not inherently optimized for multicore environments, which can lead to efficiency issues in Cilk++ applications.

To address this inefficiency, the authors demonstrate a reimplementation of the vector container that exploits parallelism in operations like construction, copying, and resizing. They confront the limitation that Cilk++'s high-level constructs, such as 'cilk_for', do not yet function within constructors. The authors employ lower-level constructs like 'cilk_spawn' and 'cilk_sync', which start new threads and wait for their completion, to manual schedule parallel tasks.

Their technique uses template metaprogramming at compile time to split tasks across CPU cores, reducing the runtime overhead. This is based on recursive template instantiation, dividing tasks into sub-intervals handled by individual processing elements matched to the number of available cores.

An analyzer program determines core count and other constants prior to compiling the library, enabling empirical comparisons with traditional STL vectors on a quad-core CPU and vectors of various sizes. Iterators, critical for algorithm traversal of data structures, are transformed into 'cilk_for' constructs. To manage race conditions and shared resource access within algorithms, the authors introduce reducers for atomic operations.

The paper claims a significant speedup when using their multicore STL implementation on the Cilk++ platform. The proposed solution is a framework extending STL to better serve the needs of multicore programming, thus addressing the limitations of the current STL when used in Cilk++ applications, and potentially alleviating a significant efficiency bottleneck.