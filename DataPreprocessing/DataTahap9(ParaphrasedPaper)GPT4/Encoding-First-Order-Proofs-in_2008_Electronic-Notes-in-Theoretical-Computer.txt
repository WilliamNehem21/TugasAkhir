Our initial version of CHEWTP2-SAT showed promising results on certain problems, yet for other problems the sheer number of clauses generated was excessive. Specifically, a portion of the encoding handled choices, like selecting which clause a literal should extend. Another portion, however, dealt with deterministic steps such as verifying the consistency of unification constraints and the acyclicity within a directed acyclic graph (DAG), ensuring the DAG maintained certain characteristics. From our experiments with horn clauses, we found that nearly 99% of the generated clauses pertained to deterministic procedures, and merely around 1% reflected actual choices. Our approach to encoding unification and acyclicity was comprehensive but perhaps too eager.

In our paper, we describe our new CHEWTP2-SMT implementation and compare it with CHEWTP2-SAT. Notably, when encoding horn clauses, CHEWTP2-SMT generates far fewer clauses than its predecessor and determines satisfiability much faster. However, this efficiency was not observed with non-horn clauses. We provide insights into these disparities and offer a general guideline on when to apply theoretical encoding.

Our system gives users the choice of encoding problems either for SAT or SMT. For SMT, we use the Yices SMT solver to check satisfiability. If SAT is chosen, users then have the option of verifying satisfiability with either Yices or MiniSat, both of which use a DIMACS formatted SAT encoding.

We investigated whether leveraging theories would enhance CHEWTP2's performance. In problems involving horn clauses, using theories usually resulted in a significant decrease in runtime, with few exceptions. However, with non-horn clauses, the use of theories tended to increase runtime. Generally, on SAT problems not involving theories, Yices outperformed MiniSat.

We believe the contrast in our findings stems from the dramatic reduction of clauses in horn problems versus non-horn problems, where the reduction is not as pronounced. The implication is that working with theories is advantageous predominantly when they can substantially reduce the number of clauses.

The encoding provided by Yices remains propositional. Therefore, even after omitting the encoding of unification and acyclicity from our system, the complexity of encoding the overall problem remains cubic. We propose a general principle for deciding when it is worthwhile to employ theories for encoding. If the number of clauses can be lowered by a factor of 'n', then using theoretical encoding is beneficial. However, if the complexity does not fundamentally improve, then it may not be worth the effort.