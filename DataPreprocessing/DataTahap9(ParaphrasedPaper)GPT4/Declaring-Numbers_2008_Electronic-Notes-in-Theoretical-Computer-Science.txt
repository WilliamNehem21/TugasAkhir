The paper discusses how typical implementations of functional and functional logic languages handle numbers by using the built-in numerical types of the underlying implementation language, such as C, for efficiency reasons. However, this approach leads to a limitation in functional logic languages because it doesn't allow for the use of narrowing to infer the values of numbers.

The authors introduce the idea of using semantic extensions, such as residuation, which allows numbers to interact with logical features by suspending computations on unbound variables. Functions must then be paired with generators that enumerate the potential values for these variables. To illustrate, the authors discuss the implementation of finding Pythagorean triples where typical arithmetic functions suspend until definite values are provided.

They differentiate between two types of termination when working with functions that handle numbers in their approach: head normal form (hnf) termination, which stops when an expression evaluates to a head normal form, and normal form (nf) termination. For simplicity, they discuss only the case where the two coincide (termination) when functions like natural number comparison are involved because they end the computation based on the size of the smaller argument.

The authors recognize that their implementation can only partially define the predecessor function for natural numbers and suggest extending the domain to integers. Furthermore, they propose that their approach to arithmetic could potentially replace the existing primitive integer implementations even though their method incurs some computational overhead. This overhead is considered acceptable due to the added flexibility of narrowing in functional logic programs.

In summary, they offer an alternative approach to implementing arithmetic operations in a way that integrates better with the logical aspects of functional logic programming languages, by using a binary encoding of integers as an algebraic datatype. This approach permits narrowing on unknown argument values, even though it introduces overhead in comparison to using primitive operations. The authors argue that the benefits of allowing narrowing outweigh this overhead for programmers working within functional logic programming.