In the following section, we provide foundational information about interaction nets. The programming language we're investigating is introduced in Section 3. Sections 4 and 5 detail how we translate this language into C code. Section 6 outlines how this process is actually implemented, and we wrap up the study in Section 7.

We have improved the way data types are represented in interaction nets by incorporating agents associated with specific values, which allows for more efficient hardware-supported representations, especially for numbers, which no longer rely on 's' and 'z' agents. Additionally, we've created a series of deterministic operations for intrinsic data types such as booleans, integers, and characters. An example of how we can implement the addition operation in a way that aligns with hardware support is provided below.

Interaction nets can have multiple active pairs, meaning that there are various paths for reduction to occur. To ensure that the resulting normal forms are unique (so that the same net always yields the same outcome), we employ a straightforward reduction strategy that processes the net into a full normal form following a Last-In-First-Out (LIFO) pattern. We maintain a stack of all active pairs and reduce them adhering to the LIFO order. This strategy mimics a big-step structured operational semantics.

In this section, we outline the methods of converting code from our specialized language into C source code. We leverage existing C compiler tools to convert the C source files we generate into executable native code. When run, this code constructs the corresponding net in memory and reduces it to its full normal form.

Our fundamental approach involves compiling each rule and each net into a separate C function. For rules, the corresponding functions accept a pair of active agents as inputs and are coded to construct the right-hand side (RHS) of the rule's net, connecting it to the agents at the auxiliary ports of the active pair.