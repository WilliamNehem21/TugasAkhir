In this study, we explore the process of converting the semantics of a register-based intermediate representation (IR) into code suitable for a stack-machine execution model. We propose a new program representation known as treegraphs, where nodes of the treegraphs represent calculations that can be visualized as depth-first search (DFS) trees. Meanwhile, edges in the treegraphs signify operations that are reused multiple times, which typically contradicts the one-time-use nature of stack-based computation. To overcome the inefficiency of temporary variable storage and the associated load/store instructions, our approach maintains all values directly on the stack. Consequently, the task of code generation simplifies into arranging treegraph nodes in a manner that is most economical.

The structure of our paper is as follows: Section 2 provides an overview of the topic and relevant literature. Section 3 introduces our treegraph IR and outlines the algorithm used to schedule these treegraphs. We address strategies for reducing the cost of stack manipulations in Section 4. Section 5 presents the results of our experiments. Finally, we sum up our findings in Section 6.

Previously, generating register-code for arithmetic computations was examined by Andrei Ershov, while Sethi and Ullman created an optimal code generation algorithm for arithmetic expressions based on Ershov numbers. Aho and Johnson later applied dynamic programming to produce optimal code for expression trees tailored for CISC architectures.

In terms of the instruction set, the 'fetch k' operation duplicates the k-th element from the top of the stack and pushes this duplicate onto the stack. If the stack contains fewer than k elements, the machine will encounter an error and stop execution.

We support our arguments with a proof stating that the unique qualities of a directed acyclic graph (DAG) G are preserved when it is transformed into a tree-graph H(F, A), as this conversion does not add extra edges. Instead, each tree in the original DAG becomes a single node in H, and the tree-graph edges represent a cut-set C.

For experimental validation, we used an Intel Xeon 5120 server running CentOS Linux 5.4 with kernel version 2.6.18 and tested 24 C benchmark programs from the LLVM compiler infrastructure's test suite. Our tinyVM backend, which is an embedded systems virtual machine for the C language designed for stack-based operation, currently does not support floating-point numbers and structures as function arguments, and this limitation impacted our choice of benchmark programs.

In summary, we explored the mapping of register-based IR to stack-code and introduced treegraphs as a new program representation that retains all values on the stack to avoid the use of temporary variables and minimize related memory operations. We implemented our scheduling algorithm within the LLVM compiler infrastructure for our stack-based virtual machine, tinyVM.