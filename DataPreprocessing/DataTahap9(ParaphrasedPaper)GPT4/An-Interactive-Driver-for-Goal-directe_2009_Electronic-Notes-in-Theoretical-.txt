The paper discusses the limitations of traditional interactive theorem proving tools, stressing that they lack an interactive element that helps users understand the process, reasons for failures, and ways to improve outcomes. To remedy this, the authors developed an SLD (Selective Linear Definite clause) resolution engine that performs backtracking without using the call stack, which helps users visualize computations.

This engine is implemented in a tool called Matita through an 'apply tactic,' where users control the selection and computation rules, providing their own goals and clauses (lemmas). The 'apply tactic' produces a proof status or raises an exception if unification fails.

To ensure users see only viable alternatives, a computational rule attempts to apply the best candidate lemmas and filters out ineffective ones. The 'cands' function searches for these candidates and presents a list of alternative proof statuses.

To convey information effectively, the user interface (UI) shows applicable lemmas in a dedicated column using a 'choice stack' with tooltips providing extra details. The UI also manages the application of lemmas to conjectures and handles failed attempts by trying next alternatives or backtracking if necessary.

The UI distinguishes between solved subgoals with or without metavariables, allowing users to interact with the remaining candidate list in the latter case. For real-time interaction, the search procedure is stackless, keeping all information needed for backtracking in a first-order object that can be accessed by the UI.

Proof statuses include a 'd constructor' for unsolved goals, an 's constructor' for solved ones (with caching), and a failure list for tracking failed goals. The 'step function' uses rule (vi) to handle new goals and manage the cache for solved goals, ensuring that the proof cache isn't updated with failures unless all alternatives are exhausted.

To manage the search tree's depth and size, the element structure is augmented with two integers to keep track of these limits. The UI and the automatic procedure operate in separate threads with the possibility to pause the computation, thanks to a condition variable associated with the UI's pause button.

Overall, this paper presents an advancement in interactive theorem proving by providing a more informative and user-friendly experience that empowers both educational users and those needing to understand the reasoning behind proof successes and failures.