The creation of software to interpret and analyze Java bytecode dates back many years, and designers continue to develop new tools [citations]. These tools often require significant effort to build parsers for the bytecode and to create or reimplement standard control and data-flow analyses, which are used to generate important structures like control-flow graphs and data-dependency graphs.

OPAL SPL is designed differently in that it doesn't have an inherent type hierarchy embedded within it. Instead, specifications written in SPL include their own description of the type system relevant to the described bytecode language, with the only condition being that the types form a singular, strict hierarchy.

OPAL SPL approaches the representation of the stack in a distinct way from the JVM specification; it treats the stack as a list of operands instead of slots. This operand-based model simplifies the representation of most instructions but diverts from the slot-based model when dealing with category-2-values, such as dealing with the two halves of a 64-bit long value.

Developers have created two generators based on the SPL specification, both implemented with XSLT. The first generator, 350 lines of code, creates classes for each bytecode instruction, with these classes being capable of generating XML and Prolog representations. The second generator, 300 lines in length, parses code arrays and instantiates the instruction classes dynamically. Compared to the Bytecode Engineering Library (BCEL), which has a similar method for managing instructions, these generators are significantly more concise, being 15 to 20 times smaller.

An additional benefit of this setup is that the localization of changes that impact all instructions. For instance, varying the Prolog representation required adjustments, but typically this meant altering less than 40 lines of code in the generator, which stresses the efficiency and maintainability of the approach.