We put forward a new model for concurrent programming in Java-like languages that includes a set of code annotations to denote how objects are to be used in multi-threaded contexts. Developers can annotate their code to specify if an object is meant to be shared among threads. These annotations furnish sufficient data for static analysis tools to check whether proper locking mechanisms are in place, ensuring that shared objects are locked before use and unshared objects are only accessed by the thread that created them. This allows for modular verification, enabling it to scale to larger codebases.

Concurrent access to the same variable by multiple threads, especially when one is writing, creates a data race. Usually, developers ensure thread safety by assigning mutual exclusion locks to data structures and requiring threads to acquire these locks before any access. Yet conventional programming languages like Java do not enforce compulsory lock acquisition or consistent association of locks with data structures.

Another complexity arises when methods assume an object is already locked by the caller, leading to direct field access without re-locking the object. Thus, simply indicating object sharing status is insufficient. Method implementers also need to clearly state their assumptions about pre-held locks in a method contract.

Our concurrent programming model introduces a conceptual shared set 'S' at runtime that distinguishes shared objects from unshared ones. This is the basis for explaining the model and performing verification.

We formally define our programming model through the transformation of a program 'P' with annotations into 'P'', where correctness of 'P' within our model depends on the correctness of 'P'' according to its assertions and standard method contracts. To determine the correctness of 'P'', we leverage automatic program verifiers designed for single-threaded applications, which our experiments demonstrate can verify realistic multi-threaded applications.

Our model states that code must acquire lockable resources in a predefined order. Alternatively, one could define the order based on some attribute, like locking account objects in the order of account numbers to avoid deadlocks.

Module developers might want to impose partial constraints on locking order or generalize over a set of objects. For example, in a subject-observer pattern, the developer might specify that observers should be locked before the subject to prevent deadlocks.

Within the model, once an object is shared, it is assigned a lock level which dictates the order in which locks should be acquired and prevents deadlock by ensuring a consistent locking sequence.

We then delve into the semantics of class initialization in Java and describe how our model extends this concept while ensuring the locking order remains free of cycles.

By analyzing two existing tools, extended static checkers for Modula-3 and Java that support race and deadlock prevention, we reveal that while they are user-friendly, they do not guarantee soundness as they do not account for thread interactions outside exclusive regions, and their methodologies lack the formalization for a soundness proof.
