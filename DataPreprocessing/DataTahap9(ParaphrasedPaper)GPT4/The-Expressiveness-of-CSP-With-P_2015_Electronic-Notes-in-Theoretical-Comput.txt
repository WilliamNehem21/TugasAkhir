The paper discusses an approach to calculating the transitions of a process in a system, suggesting that another process can be capable of specific actions, which are determined based on the syntax of the initial process under consideration. These auxiliary processes are typically the operands of the parent operator, except when recursion is involved.

For cases other than recursion, it's essential to keep track of the new state that the process transitions to. This new state is represented by a syntactic structure that includes placeholders for active and inactive operands, with constraints that preclude copying or pausing active operands. However, the structure can manipulate or eliminate inactive operands as needed.

The paper contains a theorem (4.1) stating that if an operator and all related operators (reachable through the combinators' third components) resemble the pri-CSP framework, then their behavior, with respect to any operands p and q, can be replicated in pri-CSP such that it's strongly bisimilar to the operator's behavior.

The authors provide a proof, similar to previous works, by constructing a pri-CSP implementation. This is more complex due to the inclusion of elements beyond negative premises but does introduce some simplifications over earlier models.

If no combinator has conflicting positive and negative premises for the same operand, it's possible to ensure that an operand contributes to the combinator's activation by providing the necessary positive or negative premise. Positive premises are already known, while negative premises require priority adjustments to enable an event when certain actions aren't possible.

The paper also explores two strategies for handling the activation of previously inactive operands. One strategy dynamically creates new operand processes with each activation, and the other, usable when there's a limit to the number of active operands, involves recycling them by allowing "zombie" operands to be regenerated in a new role.