This paper represents an initial effort toward establishing a formal framework for graph transformations within interactive theorem provers, laying the groundwork for validating the correctness of graph transformation systems. Unlike typical graph rewriting that applies a graph morphism to embed a pattern graph into a target graph and then modifies the resulting subgraphs, this paper extends the idea of pattern graphs to path expressions, which are defined using certain subsets of first-order logic. These path expressions enhance formal reasoning about model transformations using proof assistants.

The traditional focus of graph transformation systems extends term rewriting systems, emphasizing properties like confluence and termination, which do not necessarily describe the resulting graph structure post transformation. Automated approaches like model checking are limited by these systems, as they only handle graphs with a predetermined maximum size. This paper addresses structural properties of graphs, such as multiplicities, through specific techniques.

Path expressions are seen as a decidable fragment of first-order logic, which simplifies the application of transformation rules to graphs. However, proving the validity of path expressions may require interactive proofs due to their potential undecidability.

The structure of the paper is: Section 2 introduces generalized graph transformations informally; Section 3 describes the formal model; Section 4 compares the new model to traditional graph rewriting; Section 5 explores reasoning with proof assistants; and the paper concludes by looking ahead.

The duplication process is detailed: marking nodes with 'orig' labels, duplicating nodes while preserving a 'cp' edge to show clone relationships, recreating edges, and removing auxiliary markings. The initial marking phase is discussed with semi-formal notation, with precise definitions given in later sections.

The paper refrains from formalizing any specific graph rewriting approach, instead proposing a set-theoretic model where graphs consist of finite nodes and edges with node typing. Path formulae are introduced, with the logicâ€™s decidability and complexity of model checking affected by the choice of language constructors.

Quantification in the model uses de Bruijn indices instead of named variables. Model checking relies on well-known algorithms, and universal quantification only considers the finite node set due to well-formed graphs.

The applicability condition for transformations is expressed by a path formula potentially containing free variables referencing source graph nodes. Structural well-formedness for graph transformations ensures generated nodes and edges do not exist in the source graph. Fresh nodes are deterministically assigned numbers following the highest present in the graph.

Executed transformations must respect that node references slated for deletion exist in the applicability condition, whereas generated ones do not. Assertions are used to infer postconditions from preconditions, subject to invariants being maintained.

The example demonstrates verifying that nodes marked 'node' type have a correct number of 'or' edges, assuming they had zero or one to begin with. The set of all nodes of a type is defined for this purpose.

The paper acknowledges the expressiveness of path formulae leading to verification challenges and aims to mitigate the human effort in proofs. Future work will explore specialized analytical methods for subsets of the logic, which already align with path expressions used in shape analysis for pointer programs. Comparing various approaches remains a task for future investigation.