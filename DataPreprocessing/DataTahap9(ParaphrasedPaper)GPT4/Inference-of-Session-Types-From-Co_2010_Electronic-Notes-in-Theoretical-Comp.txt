A process in this context may choose a course of action either by taking the initiative (actively) or by following another's lead (passively), and can do so either overtly (explicitly) or subtly (implicitly). An active choice stems from the process's own decisions during communication, while a passive choice is a consequence of an active decision from another process.

Once a communication or another significant action occurs, the session's type changes to reflect the new channel state. If a choice is made, the session type becomes what that choice dictates. If a communication event happens, the session type erases that event from its description, leaving what is called the continuation type.

The system for deducing session types is outlined in two forms: an established set of rules and application methodologies for inferring a session type; secondly, an algorithmic approach rooted in graph theory which borrows from finite automaton techniques, and involves subset construction.

"Ninja" is a model compatible with numerous component and architecture description languages. While it could augment various programming languages, there's a specific C++ implementation known as Ninja-C++. Both the Ninja-C++ and the associated type checking tool are elaborated upon.

Using a session variable, such as for sending or receiving data, renders it unusable for future operations. Variables under such restriction are termed "linear variables", and programs complying with this rule meet the "linearity constraint". A prototype tool has been developed to verify the linear usage compliance in session variables.

To ensure correct program functioning, two rules pertaining to the end of sessions are proposed. First, a session marked as 'end' must conclude with a 'close' operation. Second, sessions of any other type must not perform a 'close'. While the latter is straightforward, the former requires a control flow that ensures sessions are ended as intended, barring program interruptions like those from an operating system.

Issues arise when overlapping subsets in DFA nodes exist in our program, which can happen. Such overlap means a session variable cannot have distinct types in different contexts. Hence, merging must occur for nodes in the resulting graph that contain the original node in question. A substitution function is applied to accomplish this.

To facilitate type inference, an untyped version of Ninja-C++ is created, which involves generating untyped session and channel constructs. Two versions are necessary: one where only the session and channel are untyped, for intermediate type derivation, and another where all components are untyped, for complete session and participant data derivation.

Finally, algorithm implementation for type assignment to sessions, channels, and participants is threefold. It starts with an AST traversal to gather program data on sessions, channels, and participants. Session data is formatted into a graph-mimicking structure, while channel and participant data is mapped from their respective definitions to session nodes.