This paper discusses the integration of the orchestration language Orc as a domain-specific language (DSL) within Haskell. By implementing Orc as a combinator library that leverages Haskell's lightweight concurrency features, the authors make it possible to incorporate existing Haskell code into Orc orchestrations and vice versa. This approach is particularly useful for managing the complexities of distributed computing and allows for the re-use of efficient concurrent programming patterns.

The paper explores extending functional program derivation strategies, such as the calculus of recursive schemes, to distributed computation contexts. It demonstrates how binary tree hylomorphisms—a class of recursive functions—can be parallelized effectively across a distributed system.

The development of Orc within Haskell (referred to as HOrc) aimed to provide a way to compose software from autonomous and possibly heterogeneous components that may be distributed. Such capabilities are increasingly necessary due to the prevalence of concurrency in software systems. A key motivation for this work was to enable the extraction and validation of coordination scripts from existing (legacy) software, enhancing the ability to reason about and adapt software interactions.

The paper includes details about Orc's semantics, such as its '0' operator, implemented in HOrc as a primitive site for symmetry in presentation. In Orc, sites are components that compute results asynchronously, publishing zero or one value upon completion. Calls to sites exemplify Orc's loose semantics: responses can be arbitrary in timing or may not occur at all.

The authors discuss how common sub-expressions in Orc can be abstracted into functions, which are expressions with abstracted parameters represented as variables. A function example provided processes incoming messages, forwarding them as required and recursively calling itself until an accumulator indicates that there are no more active threads.

The 'prune' operator in Orc is also explained, which handles the conditional execution of a secondary process depending on whether the first process publishes a value or terminates. 

The paper illustrates the practical application of HOrc with examples, such as rewriting the eight queens problem in HOrc to demonstrate the language's differences from standard Haskell and introducing general programming patterns. This includes an extended definition of hylomorphism that allows concurrent execution of certain parts, making it easy to implement parallel algorithms such as parallel quicksort. The authors also mention other patterns implemented in HOrc, like MapReduce and workflow patterns.

Furthermore, the paper highlights a generalization for binary trees, which introduces an additional type variable to replace the recursive structure. This allows for communication primitives (like channels and MVars) among threads in the definition of de-forested binary tree hylomorphisms in HOrc. The approach adopted by HOrc is presented as a middle ground between explicit parallelism and semi-explicit approaches like those in GpH, where the programmer provides annotations for potential parallelism rather than specifying a fixed division of tasks, and the runtime makes the final decision on task distribution.