Software tools designed to manipulate bytecode for virtual machines are growing in popularity. One such tool, bat2xml, uses XML to represent Java bytecode, harnessing existing XML technologies to process and transform the code. Bat2xml simplifies the tasks of injecting and extracting Java bytecode for analysis and optimization purposes but it's limited to Java and can't handle Common Language Runtime (CLR) bytecode.

This paper describes an innovative method leveraging XML to create a universal framework for bytecode manipulation that encompasses various stack-based languages. The approach involves using XML as a container to represent bytecode as a superset, enhancing versatility in handling different bytecode types. The practical effectiveness of this approach is illustrated through a cross-compilation example, which employs XSL stylesheets to convert CLR bytecode into Java Virtual Machine (JVM) compatible bytecode, highlighting the convenience of declarative programming for such complex conversions.

The paper emphasizes the strength of XML technologies and declarative programming, especially in the context of bytecode manipulation, a non-trivial problem for software developers. The structure of the paper introduces XMLVM, the XML-based bytecode representation, followed by comparative analyses of the JVM and CLR while pinpointing their distinctions. The feasibility of cross-compiling between these machine languages using XSL is demonstrated. Finally, conclusions are drawn, and the potential for future enhancements in this area is outlined.

A key element of XMLVM's functionality is the transformation of CLR bytecode instructions into their XML representations, enabling operations and adding extended capabilities, such as assigning variables or invoking methods with specialized XML tags. The CLR's bytecode semantics are carefully observed without direct type indication during instructions like addition, leaving it to the virtual machine to deduce operand types, either through static analysis or runtime type stacks.

Despite JVM and CLR sharing common ground in supporting primitive types for high-level languages, they hold notable differences, such as the JVM only acknowledging signed integers, while CLR accommodates both signed and unsigned integers. These differences pose challenges for cross-compilation, demanding mechanisms to handle unsigned integers, correctly map instructions for varying types, and manage overflow exceptions between the two bytecode domains.

CLR's unique "value types" concept, which allocates instances on the stack rather than the heap, contrasts starkly with JVM's heap-focused object instances. Attempts to cross-compile CLR bytecode to JVM must account for these disparities by employing compatibility libraries to preserve original CLR instruction semantics, for value types, and for deep copy operations that can't be directly translated into single JVM instructions.

Moreover, the paper addresses the complexity of external library references that arise during cross-compilation. For instance, CLR-specific class references may not exist in the target JVM environment, necessitating class and method name changes, a process termed API mapping. By using API wrapping in conjunction, a cross-compiled Java application can achieve behavior identical to its CLR counterpart.

In summary, the paper explores the application of XML and declarative techniques in abstracting bytecode to allow for broader manipulation, optimization, and cross-compiling capabilities between distinct virtual machine environments.