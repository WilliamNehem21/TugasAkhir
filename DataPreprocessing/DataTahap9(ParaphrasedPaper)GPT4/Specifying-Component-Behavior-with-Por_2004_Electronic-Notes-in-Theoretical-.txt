Behavior protocols use traces—a sequence of events—to describe the behavior of a software component. The textual notation used is akin to regular expressions and is designed to represent the behavior with a regular language. Past research has defined the compliance relation and the consent operator to evaluate the consistency of component composition and to support tools that can verify this compliance.

In contrast, UML state machines use different methods to specify events. For components, events received are captured as triggers for state transitions, while responses to events are specified through activities, which are detailed using actions, some of which may send events. However, linking triggers and corresponding actions is difficult due to the wide range of possible actions, making it complex to derive behaviors from compositions of components through state machines.

To address these challenges, this paper proposes the Port State Machine (PoSM), which aims to (1) notate the interleaving of events sent and received by a component's port, supporting nested calls with a trace model based on atomic events, and (2) establish a verifiable compliance relation for PoSMs.

The paper is organized as follows: Section 2 presents PoSMs; Section 3 demonstrates how to verify composition using PoSMs, followed by a case study in Section 4. Sections 5 and 6 evaluate the method and discuss related work and future research, concluding in Section 7.

A PoSM is a type of ProtocolStateMachine and contains regions, vertices, and transitions. Transitions in PoSM must be classified as either port transitions or protocol transitions. The language of execution and communication for a PoSM is formalized.

The paper also discusses an efficient method for representing the call state and transition notation to improve readability, noting that while other approaches are feasible, this was chosen for clarity.

It is shown that a PoSM can be converted into a finite automaton. By modifying the structure of a PoSM, including orthogonal regions and composite states, a non-deterministic finite automaton that generates a regular language is obtained.

Behavioral protocols ensure compliance through relationships that verify component behavior upon composition. Operators such as composition, adjustment, and consent are used, and the paper introduces new shortcuts for these operations. Compliance applies to PoSMs, and the consent operator is particularly useful for identifying erroneous compositions.

The paper outlines how to use behavioral compliance to address specific consistency issues and notes that behavior protocols and PoSMs both yield regular languages of communication traces, enabling transformations between the two.

The case study highlights that PoSMs are compliant with behavioral protocols even when certain calls happen more or fewer times than expected, under specific conditions. Future work includes improving operations to combine behaviors from multiple PoSMs into one and expanding the definition of behavior compliance.

Ultimately, PoSMs use atomic events to define behavior comprehensively in terms of traces, making their compliance relation decidable and suitable for use with existing verification tools.