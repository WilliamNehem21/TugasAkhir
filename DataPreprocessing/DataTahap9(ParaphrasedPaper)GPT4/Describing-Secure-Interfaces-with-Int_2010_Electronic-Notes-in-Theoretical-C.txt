Interface automata (IA) are formal models for representing the stateful interactions of system components, which consist of input and output actions along with temporal ordering. This paper introduces a variant of IA known as Interface Structures for Security (ISS), designed to model security concerns. The primary focus is on the non-interference property, specifically bisimulation-based non-interference for reactive systems.

The authors define the concept of compatible interfaces, meaning that they can be composed without compromising security, and provide algorithms to determine if an ISS can guarantee security by controlling actions.

Monitoring actions are considered to be confidential, while transaction-related actions are public. The authors demonstrate that each component of the system maintains non-interference, such that a low-level user cannot differentiate whether a high-level (confidential) action has occurred.

Previous works addressed synthesis problems for non-interference, but commonly overlooked the distinction between input (controllable) and output (uncontrollable) actions or did not allow for control over both public and private actions.

The paper's structure recaps IA and defines ISS, composition operations, and non-interference properties. It introduces algorithms that establish conditions for secure interface composition.

ISS extends IA by categorizing actions as either public (low) or private (high) based on the visibility to users. To achieve a secure information handling, the authors adapt non-interference definitions to their model.

The composition of secure interfaces can result in an insecure interface; the paper addresses whether a secure interface can be derived from such a composition, akin to how IA compositions are adjusted to ensure safe interaction. The focus is on the bisimulation-based non-interference (BSNNI) method for deriving an ISS that meets security standards.

Unlike traditional IA compositions, the synchronous product in ISS requires matching transition names and types, and does not allow for interleaving actions. A failure state is introduced for non-matching transitions. The presence of silent step self-loops in all states of a saturated IA eliminates silent steps that lead to failure.