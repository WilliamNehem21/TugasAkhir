Integrated Development Environments (IDEs) that support the evolution of both software and models must address the challenge of keeping code and models synchronized amidst ongoing changes. Avoiding extensive model reengineering or code regeneration, establishing and incrementally maintaining a correspondence between initial models after each evolutionary step is preferred. Previous research demonstrated how distributed graph rewriting can aid in synchronizing these updates. This paper extends that work by discussing how to create a distributed graph from separate models using synchronized rules, particularly focusing on Java code and UML models, and by proposing an Eclipse plugin implementation for the technique.


The technique relies on mapping connections between software elements (represented in the Abstract Syntax Tree, or AST) and UML model elements, viewing both as instances of their respective metamodels interpreted as graph types. Constructing these correspondences involves establishing an interface graph where each node represents a shared abstract concept across the models, maintaining appropriate morphisms at the instance level.


The paper outlines the construction of said interface graph and its morphisms, assuming that the existing AST and UML models are coherent and consistently use qualified names to reference the same concepts. This approach can be adapted to reconcile incoherent models, allowing for the identification of inconsistencies or repairing one model based on the other deemed as correct.


The paper is structured as follows: Section 2 revisits relevant theory; Section 3 details general transformation patterns and specific examples; Section 4 describes the Eclipse plugin implementation; and Section 5 provides conclusions.


This approach constructs the correspondence using a generic transformation template and identifies context-related issues, suggesting a resolution strategy. Typically, the Java AST serves as the construction basis, and necessary rule adaptations for real metamodels are discussed.


The Eclipse plugin architecture is extensible, with tools structured as plugins. For the correspondence construction process, the plugin initiates by invoking a method passing the Java source's AST as input, also loading the UML model for mapping. The plugin then navigates the AST, applying transformation rules without disturbance to existing graph nodes or edges, ensuring that building correspondence for some elements does not impede the construction of others.


Finally, the node-specific visit methods are utilized to map elements according to transformation unit definitions. Context identification follows, where the paper emphasizes the importance of checking applicability conditions and acknowledges that nodes with the same context may have been visited and mapped earlier in the process.


In summary, this academic paper proposes a method for maintaining coherence between Java code and UML models by using distributed graph rewriting techniques and synchronized rules within an Eclipse-based implementation, all of which can handle incremental changes within the software development process.