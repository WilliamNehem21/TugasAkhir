The paper introduces a method for ensuring the termination of program evaluations within reduction semantics—a type of operational semantics that explicitly includes the notion of reduction contexts—by constructing a specific type of proof based on Tait-style reducibility predicates. These predicates are defined for both terms and contexts. The primary focus is on the simply typed lambda calculus as well as extensions to include abortive control operators for first-class continuations within call-by-value and call-by-name reduction strategies.

The authors highlight the importance of using contexts specially in the presence of control operators that manipulate continuations. They reference Wright and Felleisen to point out that context-based reduction semantics provide a powerful way of proving type soundness properties. The specific syntax of reduction contexts is directly linked to the chosen reduction strategy, with their grammatical definitions deferred to later sections.

A standard approach is used to define free and bound variables, with the convention that closed terms have no free variables. Terms that are the same except for the names of bound variables are considered identical. Within this framework, a reducibility predicate for well-typed terms is used to demonstrate that when a reducible term is applied to another appropriate reducible term, the result is also reducible, and thus normalizes. The overall termination proof requires showing that all well-typed terms are reducible, which implicitly means they too will normalize.

The paper then moves on to explore the concept of type soundness in general, highlighting that while broad soundness properties are challenging to prove, it is feasible for 'plain programs'. Plain programs are programs without complex control features and can be shown to evaluate to a single, well-typed value. This is not the case for programs that during evaluation capture and substitute contexts for continuation variables, leading to non-plain programs.

A more restrictive annotated type system is proposed that relates to the main system by limiting context application to a fixed answer type. It is mentioned that this kind of annotated system can ensure strong type soundness by detailing the type of the entire program at each point in its reduction.

For call-by-value evaluation of well-typed plain programs, the logical predicates for languages with 'call/cc' (call with current continuation) are the same as for simply typed lambda calculus and a termination theorem is provided.

Similarly, the paper asserts that languages using a call-by-name reduction strategy with 'call/cc' satisfy both weak and strong type soundness properties. Again, by using logical predicates analogous to the simply typed call-by-name lambda calculus, termination of call-by-name evaluation for these languages is demonstrated.

It is recognized that certain typing rules are too unrestricted to guarantee type preservation during reduction; type preservation could be ensured by a more narrowly defined type system.

Lastly, the paper references OCaml implementations for the evaluators, which are based on normalization by evaluation in continuation-passing style. These evaluators exemplify the logical relationship between continuations and contexts previously noted by Danvy. Although these implementations serve as examples, they have not been created through automatic program extraction tools, which typically yield less readable results.