In imperative programming languages, "for" and "while" loops are commonly used structures that repeat code execution until a specific condition is satisfied, or they continue indefinitely if the condition never holds (leading to a diverging loop). These loops can be enhanced using "break" and "continue" statements, which may also have labeled versions. Although not mandatory for programming, these statements improve readability, even though code can be restructured to avoid them, often with a loss of clarity. 

Labeling statements like "break" and "continue" is a common practice which helps in managing control flow within nested loops. When a "continue" statement is executed inside an inner loop, control returns to the beginning of that loop, indicated by a solid purple box in our example. The control flow preceding the start of the inner loop, such as an assignment to a variable `prod`, is also marked purple.

Likewise, when a "continue" statement targeting an outer loop is executed, shown as "continue outer," control returns to the start of that outer loop, outlined with a thick dashed red box in the diagram. Assignments occurring before the outer loop starts, like one to a variable `sum`, are similarly marked in red.

Control flow can resume either at the inner or outer loop iterations when a "return inl" statement is used, depending on the context in the program. Unlike the unlabeled iteration, where control flow resumption might be ambiguous, labeled control statements such as "continue outer" in Java leave no doubt as to where execution continues.

The paper further discusses that labeled iteration not only facilitates understanding of control flow but also involves a semantically rich type system associated with set-based semantics. This mechanism is similar to exception handling, hence the chosen term "raise" to describe it, with a more in-depth discussion available in sections 3 and 4 of the paper.