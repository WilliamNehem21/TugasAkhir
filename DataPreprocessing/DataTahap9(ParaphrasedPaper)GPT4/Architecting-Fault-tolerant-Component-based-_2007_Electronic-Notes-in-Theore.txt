The academic paper discusses a case study focused on a mining control system composed of three key subsystems that manage water extraction, air extraction, and mineral extraction within a mining environment while monitoring for methane gas release. Our discussion centers on the air extractor control subsystem as an illustrative example for presenting the proposed methodology.

Software architecture is recognized as an effective strategy for enhancing software quality and reducing production time and costs. It is the initial complete system description in the development lifecycle, offering both a high-level outline of components and their interactions and detailing the static structure of the system.

Our methodology introduces a fault-tolerant software architecture language that incorporates both structural and behavioral elements. Structurally, it delineates the composition of components and connectors, dividing them into normal and exceptional parts and their interrelations. The behavioral aspect defines the prescribed interactions between components and connectors in accordance to an ideal fault tolerance model.

In this model, an SA (software architecture) component is symbolized as a UML (Unified Modeling Language) component with a 'hasException' boolean tag indicating the presence of fault-tolerant behavior. These components are further detailed into 'normal' and 'exceptional,' depicting standard and exceptional behaviors respectively. Communication is handled via ports, which are also used for signaling exceptions, and UML interfaces facilitate exception propagation.

Behavioral descriptions are provided through UML state diagrams, which are intuitive and straightforward for showing single-component behaviors. These diagrams also describe exception signaling, management, and system recovery measures, and delineate how unhandled exceptions are passed on.

For specification-based testing, test cases are paths covering the behavioral graph generated from the state machine specification. These utilize information from both the structural model (for identifying critical services and components) and the behavioral model (for detailing expected runtime system behavior), aiming to develop test cases that can assess functionality at the architectural level.
