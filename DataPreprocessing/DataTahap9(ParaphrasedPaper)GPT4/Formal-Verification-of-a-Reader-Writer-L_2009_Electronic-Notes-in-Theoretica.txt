The rest of this paper is organized in the following way. Section 2 provides a brief survey of prior work that is relevant to checking concurrency and lock correctness. Section 3 introduces the annotation language and method utilized by the Verifying C Compiler (VCC), which is developed by Microsoft, and is employed to annotate and check our lock code. In Section 4, we describe our reader-writer lock code, including its invariants and the details of its functions. We wrap up with conclusions in Section 5.

Bornat et al. introduced an ownership model that accommodates shared, read-only state and showed a manual proof for the correctness of a reader-writer lock using semaphores defined in concurrent separation logic. However, this approach lacks automation, and their lock design is somewhat simpler and not as efficient as ours, depending on semaphores and potentially causing blocks during release operations. Additionally, their model does not handle dynamic lock creation and initialization well.

The Verifying C Compiler (VCC) is a concurrent C verification tool being developed at Microsoft Research in Redmond, USA, and at the European Microsoft Innovation Center in Aachen, Germany. Designed to specify and verify industrial software within the Verisoft XT project, which includes Microsoft's Hyper-V hypervisor, VCC is also suited for a wide range of software applications, not just our specific lock example.

We provide a brief summary of VCC's annotation syntax and the core formal model it is based on, focusing on concurrency features. We accompany the explanation with small code samples, and refer readers to other resources for comprehensive VCC tool and methodology discussions.

Objects in VCC have an ownership model similar to Spec#, with each object including metadata about its owner, the objects it owns, its closed state, and reference count, which regulate access permissions and object invariant conditions. VCC can identify not only program structures but also groups and arrays as individual objects within the C code being annotated.

VCC's objects can be marked with invariants that either apply at all times (single-state invariants) or apply across state changes (two-state invariants). These invariants ensure system integrity and set limits on other threads' interaction with the objects.

For manageability, VCC supports "out" parameters as specification elements, marked with the keyword "out" in both function declarations and calls to simplify the proof process that usually suffers from additional complexity due to Câ€™s pointer-based parameter passing.

When an object (like a lock) is closed, obtaining write permissions is typically challenging. The use of a 'self claim' serves as an intermediary claim that has write permissions during atomic operations, enabling new claims that establish object properties indirectly through the self claim.

We also employ two-state invariants to assure that the lock stays initialized and to ensure neither the protected object nor the self claim is replaced during the operation. This requires using "old(initialized)" for the left-hand side of the implication because our two-state invariants cannot be accomplished during the initialization state.

The "acquireShared()" function outputs a claim parameter for read access, which, upon return, must be a new, valid, unwrapped, and unreferenced claim originating from the self claim and the protected object. This enables read (and volatile write) operations on the protected object using the returned claim. The "releaseShared()" function reverses the process, taking back and discarding any such claim.