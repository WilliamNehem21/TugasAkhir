This paper discusses the limitations of existing software evolution research due to incomplete data capture by version control systems, which only store snapshots of code when developers commit changes, instead of recording every intermediate change. The authors propose a new approach where development information is modeled as change operations, directly retrieved from the Integrated Development Environment (IDE) as developers make changes, allowing for a richer and more incremental information flow that can be used to advance software understanding and evolution.

The authors emphasize that by integrating their tools into the IDEs, they can capture detailed and real-time evolution information, handle it incrementally, and enhance tool usability. They treat changes as fundamental elements, blurring the line between software engineering and evolution. They highlight the difficulty of tracking program-level entities across versions due to factors like renaming or refactoring, which current analyses struggle with due to sampling or coarse-grained information reliance.

Their proposed model involves first-class change entities that encapsulate system history incrementally, capable of reproducing programs at different points in time and providing additional information beneficial for evolution research. The authors acknowledge previous attempts at change-based versioning systems but argue their model has broader applications and complements traditional version control without replacing it.

They also see potential benefits for forward engineering, suggesting that first-class change operations could facilitate features like a semantic-level undo mechanism and assist in program transformations similar to refactorings.

While their approach is currently language-specific, their prototype is structured to separate language-independent and language-dependent components, which implies the language-dependent part requires adaptation for various languages or IDEs.

The paper outlines how their change model enhances program comprehension by allowing for more precise change detection and characterization. By recording all code changes, such as refactorings, they aim to track code entities throughout their lifetimes and believe changes can be categorized (e.g., bug fixes, refactorings, feature additions) to focus analysis more effectively on specific changes.

Their approach also allows for tagging and modifying change properties during review for easier grouping and handling of related changes. The complete history of system changes enables a fine-grained context for understanding code changes over time.

The authors share a case study based on a project by students who worked in pairs during their second semester, programming in Smalltalk. The students' IDEs were equipped with the authors' monitoring tools, which periodically uploaded change data to an FTP server.

Finally, the paper describes different types of work sessions based on the change data, differentiating between sessions that exhibit steady growth and cautious, error-fixing sessions with repeated method modifications.

In conclusion, the authors suggest that capturing fine-grained change operations as they occur in the IDE can revolutionize the way developers and researchers understand and evolve software systems, providing better tools for both forward and reverse engineering.