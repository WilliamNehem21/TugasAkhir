Functional and logic programming styles both offer benefits for programmers, and combining them yields hybrid languages that leverage the strengths of each paradigm. Examples of such languages are Curry and Toy, which share syntactic similarities with Haskell and include features like higher-order functions, type inference, and lazy evaluation (though they do not fully incorporate advanced elements like type classes).

These functional-logic languages combine Haskell's characteristics with distinct features from logic programming, such as non-deterministic functions, and employ a generalized form of unification to handle logical variables in non-deterministic calculations. However, the introduction of delayed computations in these languages can sometimes interfere with the semantics intended by the programmer.

For functions where termination could be affected by the evaluation strategy (eager versus lazy), these languages opt for a 'call-time choice' semanticsâ€”seeking consistency in the outcomes of function calls, regardless of the evaluation strategy used. This requires a specific implementation of lazy evaluation, often involving structures in the language to ensure sharing of computations.

The translation of higher-order functions to first-order ones uses a technique that represents partial function applications as Prolog terms and employs a special '@' function to handle application to arguments.

Explicit annotations in the form of lazy declarations can enable functions to adopt lazy evaluation behaviors. This strategy is not new; it has precedents in both the world of strict functional languages, like OCaml, which allows for controlled evaluation suspension and forcing, as well as in the functional extension to Prolog.

The inclusion of laziness annotations in data type constructors leads to a translation approach that incorporates necessary suspensions, although this must be done carefully to ensure desirable behavior when non-determinism is involved.

A motivating example is tailored to the sorting algorithm where laziness, combined with the goal of selecting a sorted permutation of a list, can significantly boost efficiency. This combination of laziness with non-deterministic functions is a powerful and flexible addition to functional programming in Prolog, allowing for both eager evaluation by default and optional lazy evaluation where prescribed by the programmer.

The paper continues by comparing their approach with related work, demonstrating the implementation of their functional Prolog model, which enhances Prolog with function definitions, and exploring how to effectively bring in laziness through annotations on functions or constructors. The presented translation incorporates a mechanism for delaying computations and forcing their evaluation later, akin to context-sensitive rewriting strategies. Future work could involve examining these lazy annotations in relation to context-sensitive rewriting, particularly considering the declarative aspects of functional Prolog, excluding metaprogramming.

The experiments conducted showcase that fine control over laziness can be harnessed to improve program efficiency while integrating higher-order functions and Prolog's meta-predicates enables advanced search space exploration capabilities.