The academic paper discusses the challenges of analyzing deletions in binary search trees (BSTs) because they do not preserve randomness. The paper introduces a new tree structure, called the ordered binary search tree (OBST), which retains a history element in its nodes to keep track of the insertion order. This innovation enables the development of a deletion algorithm that preserves both randomness and order, contributing to feasible average-case time analysis.

The importance of randomness preservation for average-case time analysis is underscored by referencing previous work, including the introduction of the MOQA programming language, which guarantees this property for all its programs.

The structure of the paper is outlined as follows: Section 2 explains the OBST and the new deletion algorithm, including pseudo code; Section 3 compares probabilities of tree structures post-deletion with the new algorithm, and provides a general proof of randomness preservation through a bijection between the OBST set and the set of permutations; Section 4 presents average-case analysis showing expected logarithmic performance for both insertion and deletion; and Section 5 concludes and suggests future research.

While initial observations are based on small trees, the paper aims to prove the generality of the claims. Deletion is analyzed in two steps: searching for the node to delete (cost denoted as SE) and restructuring the tree (cost denoted as RE). SE is found using expected node depth similar to insertion analysis. The restructuring process involves converting a tree into a smaller tree and reinserting elements, with costs related to finding correct node positions within the tree.

The paper asserts a contradiction in the possibility of multiple permutations leading to the same OBST, solidifying the argument that the OBST and its corresponding deletion algorithm succeed in preserving the necessary properties for accurate average-case analysis.