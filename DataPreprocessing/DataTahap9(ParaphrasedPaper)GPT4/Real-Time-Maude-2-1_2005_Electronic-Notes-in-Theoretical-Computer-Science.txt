Real-Time Maude 2.1 builds upon Full Maude 2.1 to enable formal specification and analysis of real-time and hybrid systems through symbolic simulation, search, and model-checking. This paper introduces the tool and elaborates on its underlying principles.

Prior research has validated the effectiveness of rewriting logic as a foundational framework for modeling real-time and hybrid systems. The results have prompted the development of a preliminary version of Real-Time Maude, demonstrating its ability to handle a broad spectrum of real-time system specifications beyond the scope of existing decision procedures, allowing for their execution and analysis through search and model checking techniques.

The implementation leverages the efficient search and LTL model checking capabilities found in Full Maude 2.1. The incorporation of these features facilitates the specification process for real-time and hybrid systems and supports the creation of a robust and well-documented tool, Real-Time Maude 2.1, which is the focus of this document.

Previous iterations, like Real-Time Maude 1, included eager and lazy rewrite rules to represent urgency by prioritizing eager rules over lazy tick rules. However, with the advent of the ability to define "frozen" operators in rewriting logic, the explicit distinction between eager and lazy rules became redundant. Hence, Real-Time Maude 2.1 does not offer explicit support for these rules at the system definition level.

Tick rules, which are core to real-time system specifications, are used to model time progression. These rules increment the time by a fixed amount or non-deterministically, depending on whether the increment is specified. Time-deterministic tick rules allow for discrete time modeling, while time-nondeterministic tick rules make model checking unable to prove a formula correct due to analyzing only a subset of potential behaviors; however, discovered counterexamples remain valid.

The paper also provides examples of how time elapse is modeled using tick rules in the context of system state changes and how to define time sampling strategies. The use of commands is illustrated through examples, showing how to simulate system behavior, perform untimed searches, and identify deadlocks or unreachable states given a particular time sampling strategy.