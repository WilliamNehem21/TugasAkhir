This academic paper discusses the extension of Tom, a language that provides rewriting strategies, with the capability for strategic graph rewriting. Term-graphs are implemented using a formalism that leverages existing rewriting tools without the need to extend the rewriting concept itself, allowing for the handling of terms with references efficiently.

The authors introduce the concept of relative positions and how Tom can be extended to support strategic graph rewriting. They then outline how this can be used for lambda-calculus normalization. The paper also addresses the uniqueness of their approach, which utilizes pattern matching on terms with references without altering the fundamental rewriting process.

The paper further explains the mapping mechanism that translates Java objects into algebraic terms, divided into destructive and constructive parts for matching and building terms, respectively. Even though the paper relies on automatically generated classes and mappings, occasional manual adaptations to mappings are necessary.

Pattern matching and term construction in Tom can be expressed at both low-level positions or via a labeled syntax. The authors also introduce a deref operator to compare reference values directly.

While term-graphs can often be represented by a labeled graph, rewrite rules in Tom are more restrictive, as the left-hand side of a rule is typically limited to trees. Unlike classical graph representations, there is no automatic garbage collection, which can lead to invalid terms. The paper suggests possible solutions, like integrating garbage collection into Tom's matching or adopting a formalism where the right-hand side of rewriting rules is constituted of pointer actions.

Tom also provides a strategy language for describing the application of transformation rules, which needs to be extended for terms with references to allow for graph traversal effectively.

The authors note the success in implementing many of their proposed ideas and are working on defining a rewriting step akin to previous work. They also suggest investigating strategies that can prevent infinite loops during graph traversal with cycles.

Overall, the paper presents an innovative model with valuable applications in program transformation and code analysis, providing a robust foundation for experimenting with transformations on term-graphs in a clear and expressive way.