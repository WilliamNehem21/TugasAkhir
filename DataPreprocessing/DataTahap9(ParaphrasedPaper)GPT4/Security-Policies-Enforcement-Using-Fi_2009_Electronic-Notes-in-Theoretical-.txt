Security enforcement mechanisms are essential for upholding policies designed to protect both extensible systems and their users. These mechanisms are crucial, for example, in web browsers that run user-uploaded applets or databases that process user-submitted queries. They help prevent these systems from engaging in harmful activities. A solution to achieving security compliance is through a program monitor that enforces the applicable security policy.

Schneider first formulated a formal model of such a program monitor and explored the types of properties that can be enforced within his model. Ligatti and others later introduced a more sophisticated model known as edit automata, which not only has the ability to halt program execution when a security policy is breached but can also alter the offending programâ€™s behavior through deletion and addition of actions.

Our research focuses on identifying the types of policies enforceable by edit automata with a specific limitation: finite memory. Although previous work has introduced a subset of edit automata called bounded history automata, which have been categorized based on the policies they can enforce, our study departs from these models as it relies on both the input alphabet and the set of states being finite.

Consider an automaton 'A' that meets properties S0, S2, and S4, but not S3. Suppose there's a cycle 'Ci' in the modified automaton 'J'' with an outbound edge. Since this automaton has undergone a pruning process, this edge must connect either to a path leading to a final state 'F' or to a different cycle 'Cj'. Proposition 2 and Lemma 5 assert that 'Ci' cannot connect to 'F', and so it must lead to another cycle 'Cj'.