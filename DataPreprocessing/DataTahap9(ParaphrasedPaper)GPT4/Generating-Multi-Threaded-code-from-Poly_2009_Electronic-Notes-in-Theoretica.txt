In recent years, parallel processing has become a cornerstone for enhancing performance and efficiency in general computing. Multi-core architectures are now expected to extend their presence into the embedded processor market. Many processor manufacturers have already introduced multi-core chips, necessitating programmers to adopt concurrent programming techniques to leverage these multi-core systems effectively. An established approach to concurrency is multi-threaded programming, which is widely familiar to developers.

An updated version of the signal compiler has been introduced, capable of generating multi-threaded code that ensures tight coordination between threads that execute atomic operations. While this advancement helps manage concurrency, the indiscriminate use of multi-threading can lead to performance issues, primarily because creating too many threads can cause high context switching overhead. We believe that the current signal compiler engages in micro-threading, resulting in the generation of C programs with more threads than are needed for the intended parallel computations, as demonstrated by the provided pseudo signal code example.

This paper also reviews recent academic work on concurrent code generation from concurrent computation specifications. We discuss various computation models designed to express process concurrency. Moreover, we underline our concerns with the multi-threading techniques implemented by current synchronous programming languages.

Kahn Process Networks (KPN) are a critical formalism for specifying process data flow in concurrent systems. In KPNs, processes or nodes communicate via infinite, unidirectional FIFO channels, characterized by non-blocking write and blocking read operations. Real-world implementations of the KPN model face challenges, especially with buffer sizing. Several scheduling approaches have been proposed to estimate buffer sizes and validate the behavior of KPN models. Dataflow networks are similar to KPNs but differ because they can determine buffer sizes according to the computational load of the network.

Various tools are grounded in these dataflow models. For example, Simulink is a popular environment for simulating multidomain systems and for model-based design of dynamic and embedded systems. It includes a stateflow coder that generates readable code traceable to the stateflow chart. Recently, a method has been presented to generate multi-threaded code from Simulink models that reduces thread communication overhead by focusing on larger thread granularity.

Two languages based on synchronous dataflow are Lustre and Esterel. Lustre is declarative and used for specifying reactive systems, while Esterel is imperative, tailored for control descriptions, featuring entities such as supervisors (handling major flight control functions) and monitors (maintaining elevation).

Traditionally, decisions concerning the number and organization of threads are abstracted away from the programmer. However, tapping into the full potential of multi-core architectures requires programmers to have a deeper understanding of implementation details to custom-fit their programs to the available hardware. We therefore propose an alternative method for multi-threading in line with the signal specification and demonstrate it using just two threads in a starmac example.