This paper introduces a novel checkpointing method called stabilizers for programs written in Concurrent ML (CML), aiming to efficiently handle transient faults in multi-threaded software systems. Transient faults within a thread can be addressed through re-execution of code, but when multi-threaded programs are involved, re-execution becomes complex due to the need to revert other threads that have seen the effects of the faulty thread to a consistent state before the error occurred.

Stabilizers are designed to autonomously monitor threads for communication and thread creation events and create thread-local checkpoints that can act as restoration points in case of transient faults. When a fault is detected, these stabilizers facilitate reverting both the control and state back to a globally consistent checkpoint, maintaining atomicity and isolation. The re-execution process unrolls all global effects of the monitored code region atomically.

Stabilizers are flexible and can be nested, creating composite monitored regions that work with varying numbers of threads and non-deterministic communication patterns. A key benefit of stabilizers is that they offer a more controlled approach to checkpointing compared to both operating system-based (less precise) and user-directed (more labor-intensive) checkpointing methods.

The paper includes a detailed case study using a web server application to demonstrate stabilizers' effectiveness in improving robustness against transient faults. It also proposes an extension of stabilizers into transactions, providing further guarantees like atomicity and isolation during monitored code execution. The paper discusses the implementation details within the MLton compiler and the potential efficiency issues around tracking shared memory, outlining a combination of depth-first search and bucket sorting for optimal checkpoint graph calculations.

Benchmarks on real-world server applications showed that stabilizers introduced minimal overheads, proving their value in practical scenarios. Open nesting is suggested as a possible solution to manage transactions and speculative data dependencies more effectively, with the graph used to track these dependencies providing a rollback mechanism to consistent states.

In conclusion, stabilizers offer concise and semantically meaningful checkpointing for concurrent functional programming, simplifying error handling and state management without severe performance penalties. Their design aligns well with implementations of higher-level abstractions like transactions, which require similar atomicity properties on rollback.