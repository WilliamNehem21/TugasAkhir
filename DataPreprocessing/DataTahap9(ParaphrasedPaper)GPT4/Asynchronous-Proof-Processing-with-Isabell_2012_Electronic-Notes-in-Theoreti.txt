Despite the advances in technology, most proof assistants continue to revolve around an outdated model of interaction, reminiscent of old terminal (tty) interfaces, where each command results in an immediate response in a synchronous loop. This approach, even when wrapped in sophisticated editors like Emacs, still relies on a single-threaded, command-response pattern that appears outdated to modern users. Efforts to import these traditional interfaces into larger integrated development environments (IDEs) have been made without deviating from this old model.

The paper questions whether there is a better method to facilitate interaction and proposes integrating proof assistants, such as Isabelle, with modern IDEs through the use of alternate programming languages like Scala, which is functionally similar to ML (the language commonly used with proof assistants) but is also compatible with the Java Virtual Machine (JVM). This allows for the use of existing Java libraries.

The approach involves developing system wrappers for Isabelle in Scala, aiming for a smooth integration with IDEs like NetBeans. To simplify the development process and avoid the intricacies of full IDEs, the authors focus on JEdit, a Java-based editor which can be expanded easily through plugins, constructed in Scala. The plugins leverage the Scala actor library, enabling parallel and interactive programming. As a result, the Isabelle/JEdit interface becomes notably straightforward thanks to the Isabelle/Scala layer.

Emacs, although powerful, displays signs of aging, with some branches like XEmacs becoming unmaintained and Emacs itself seeming antiquated. Moreover, Emacs has inherent limitations like its single-threaded Lisp engine, which restricts concurrent operations.

This implementation offers a functional and asynchronous editing experience where the document acts as a persistent entity. Document versions evolve over time, resulting in a tree structure managed by an asynchronous toplevel process. As the user edits, the prover updates its state and provides feedback without causing any disruption to the userâ€™s editing.

The paper argues that developing proof assistants should be the focus, not reinventing editors or IDEs. Thus, linking to existing frameworks, such as via JVM for user interface components, is preferred, even if it introduces complexities in interprocess communication.

Integrating into an environment like JEdit requires main object-code in a JAR file supplemented with properties files and XML. The components are interconnected through Beanshell scripts, with an interactive console analogous to Emacs' scratch buffer. Learning to develop plugins for JEdit is accessible through documentation and examples.

The Isabelle/Scala library manages input, grouping text edits into commands based on the proof language's structure. The prover and editor communicate through a detailed protocol which, while complex, enables the separation of their processes.

A debugging dock displays raw XML protocol messages, but for performance, this is limited to debugging scenarios. A Scala sub-plugin recreates the traditional read-eval-print loop, executing within the same JVM as the application.

Ultimately, the paper suggests using ML for prover implementation, with Scala providing the GUI connectivity. This allows for advanced programming in Scala, utilization of Java frameworks, and access to efficient Scala standard libraries like Actors, promoting parallelism and interactive programming.