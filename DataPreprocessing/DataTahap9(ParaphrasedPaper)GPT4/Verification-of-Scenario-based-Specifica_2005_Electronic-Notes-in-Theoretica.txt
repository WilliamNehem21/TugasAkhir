When defining how to interpret the joining of basic message sequence charts (MSCs), two perspectives are considered: synchronous and asynchronous concatenation. In synchronous concatenation, every event of the first MSC (M1) happens before any event of the second (M2). On the other hand, asynchronous concatenation links two MSCs on an instance-by-instance basis.

This paper focuses on algorithms that presume synchronous concatenation for MSC graph semantics. This choice allows for modular verification, breaking down the verification process into smaller, manageable tasks at each vertex of an MSC graph. Asynchronous concatenation would necessitate more intricate algorithms, such as creating a comprehensive reachability graph from the MSC graph.

For the purpose of clarity, this work assumes that sets X and Y don't contain any negatively-defined user events. To represent the union of multiple sets in X, the paper utilizes the shorthand notation X. For example, the union of {{a, b}, {a, c}} would be denoted simply as {a, b, c}. The paper defines this template to explain the property in question.

Algorithm 2 presented in the paper applies Proposition 3.7 to determine if a vertex U in a graph G is invariably succeeded by another vertex V, given certain start and end points in G. The algorithm uses a recursive depth-first approach to traverse G from U and backtracks upon reaching any vertex in a set L. A global 'visited' array with boolean flags is employed to track which vertices have been visited.

The development team of the BMF tool project is acknowledged for their implementation work and feedback. The authors express gratitude for the ongoing support and motivation provided by Prof. Mathai Joseph. Lastly, the lead author extends personal thanks to Dr. Manasee Palshikar.

The paper also clarifies that within an MSC, an instance doesn't have to represent a computer program but could be any active agent, and a message doesn't have to be a literal data message but could symbolize any form of information exchange. Messages in this context are assumed to be named, lack detailed structure in their simplest form, and are always delivered in a sequence without any loss or corruption. It is also assumed that sending a message is non-blocking; the sender does not wait for the message to be received.