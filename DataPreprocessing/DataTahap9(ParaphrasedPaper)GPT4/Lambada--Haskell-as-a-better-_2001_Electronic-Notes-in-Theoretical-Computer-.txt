Despite its many benefits, utilizing the Java Native Interface (JNI) in its basic form can be a cumbersome and mistake-ridden process. Working with raw JNI is similar to coding in assembly language within the Java Virtual Machine (JVM). Our objective is to make the interoperability between Java and Haskell through JNI as straightforward as programming in Java itself.

When implementing native methods, they typically receive an extra argument, JNIEnv, and a reference either to a JObject for instance methods or a JClass for static methods. JNIEnv serves as an interface for the native method to interact with Java, allowing it to access object fields or call back into the JVM. The JObject or JClass reference is analogous to the 'this' pointer in Java, or to the class object for static methods.

Haskell interpreters like Hugs don't inherently support functions with static exports, but we can dynamically export Haskell functions as though they were C function pointers. This dynamic exportation is extremely potent and facilitates programming with callbacks, as illustrated in our example.

Our DiethEP component builds upon the foreign function interface we have previously defined for Haskell. This component enables us to treat any Haskell module like a standard Dynamic Link Library (DLL). Users of DiethEP won't notice any difference, except for the added versatility that comes with specifying calling conventions at runtime, compared to using a regular DLL via kernel32.dll.

Currently, we have outlined the basic framework for integrating Haskell and Java. We plan to enhance the bindings to be more user-friendly in several ways. Firstly, we'll encapsulate common patterns. Secondly, we'll conceal the repetitive passing of the JNIEnv argument throughout JNI-related code. Finally, we'll use method overloading to simplify the handling of result types in JNI methods.

Since the JNIEnv pointer is valid only within the context of its thread, we cannot store it in a global variable. However, the JavaVM pointer remains valid across threads, and thus it can be safely stored globally. To achieve this, we need to acquire the JavaVM pointer from the current thread, and we assume that current and future JNI implementations include some means to do this, following suggestions by Liang that are based on the current limitation of JVMs to a single instance per process.

Before simplifying JNI usage with overloading, we must talk about marshalling briefly. Previously, we assumed the existence of a function called marshalString that converts a Haskell string to a pointer to a null-terminated character array.

Note several key points in the code: it leverages lazy evaluation, with functions relying only on argument types, not values. The use of unsafePerformIO is purely to remove the IO layer from the result type of the callMethod function, which is entirely safe.

Casting in Haskell is limited; the need for downcasting is occasionally necessary. Java allows unsafe casting between classes, potentially causing a run-time ClassCastException. In Haskell, using the cast function for illegal casts could lead to a thrown ClassCastException or other exceptions, or cause JNI functions to signal an error. The Haskell wrapper identifies these exceptions or errors and relays them as a user error at the Haskell level.

Lambada provides tool support alongside HDirect, which is based on Interface Description Language (IDL). With a Java class or interface, we can generate an IDL specification using Java reflection API, to which HDirect can then generate the Haskell callable stubs described in this paper. HDirect is also capable of creating Java callable stubs for Haskell classes and methods.