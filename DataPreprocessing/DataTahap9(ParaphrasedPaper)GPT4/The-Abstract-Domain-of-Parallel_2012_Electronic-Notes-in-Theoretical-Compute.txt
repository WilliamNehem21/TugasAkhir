Paraphrasing the provided academic paper text:

When developing abstract operators, a primary challenge is that many specific operations cannot be constrained within parallelepipeda, and often there isn't a single optimal parallelepiped that can approximate the result of a concrete operation. Thus, selecting an approximating parallelepiped must be done with care, sometimes employing suitable heuristics to enhance precision within the analysis.

In cases where ci ≠ 0, the function assign(i, c, b) is reversible and, importantly, it transforms one parallelepiped into another. In such instances, it's feasible to construct the abstract operator based on these parameters. Essentially, the operation assign(i, c, b) is equivalent to performing the assignment xj = c * xi + b, with xj representing the updated value of xi.

To forget a variable, xi, it is necessary to make explicit the implicit constraints in a parallelepiped, p, that do not include xi. Typically, the resulting constraints exceed what can be depicted by a parallelepiped, requiring a means of prioritizing them.

To tackle these issues, we introduce an operator that disregards rows in parallelepiped p that either have unlimited bounds or contain a zero in the i-th entry, since these are either already unbounded or unaffected by the assignment. We concentrate on the remaining rows indexed by j, where aji ≠ 0 and lj ≠ ∞.

We suggest a variant of the abstract union operation influenced by the inversion join operator, which works by generating various possible linear forms and calculating the highest and lowest bounds for these forms from matrices pa and pb, respectively. Each obtained constraint is then allocated a priority level for consideration.

The union operation notably incorporates both rows from matrices a and b, adding new linear forms derived via the partial application of the inversion join algorithm. The algorithm generates a new linear form by linearly combining two existing constraints, provided they form an inversion. The full method is outlined in Algorithm 5.