The rising availability of numerous documents online has made plagiarism all too common and convenient, affecting various types of documents including text and structured data like computer programs. To address this, numerous tools and methods have been developed to detect similarities. This paper introduces a novel algorithm to identify similarities in source code. Unlike existing methods, this algorithm uses the concept of functions, paying close attention to obfuscation techniques like inlining and outlining of functions, and can also handle insertions, deletions, and rearrangements of instructions blocks. The approach employs code factorization and utilizes advanced pattern matching algorithms along with data structures like suffix arrays.

The proposed strategy involves dividing each function into smaller sub-functions and maximizing the sharing of these sub-functions across original functions. The source code is then represented as a call graph where nodes represent functions and edges represent function calls. Consequently, similar functions are expected to have an identical or similar set of sub-functions, which are the leaves on the call graph. This similarity assessment technique is designed to be robust against code obfuscations such as insertion, deletion, reversal, inlining, or outlining.

The paper is structured as follows: Section 2 provides an overview of the detection process; Sections 3 and 4 detail the factorization algorithm and the analysis of the call graph; Sections 5 and 6 discuss related work and benchmarks. Finally, the conclusion is drawn and potential future work is suggested.

The focus of this work is on detecting similarities in source code, particularly in procedural languages at the function level. The goal is to test a similarity detection method based on function transformations, creating call graph abstractions that are enriched with synthetic sub-functions indicating levels of similarity. These graphs are iterated on, creating function nodes with leaves representing primitive functions. Metrics or scores can then be defined to measure similarities between functions.

Existing research on similarity detection is divided, with some examining free text and others focusing on source code. The latter can be split into two main categories: one related to software engineering looking for exact matches for redundancy elimination or version tracking, which typically doesn't tackle obfuscation; the second addresses pattern matching and more complex algorithms based on syntax trees or dependency graphs, supported by tools like CCFinder or CloneDR.

The proposed factorization method for finding source code similarities yields modest but promising results in preliminary tests, particularly in resisting common obfuscation techniques. However, excessive outlining could lead to issues such as short leaf functions or false positives, suggesting a need for a threshold on leaf function lengths and consideration of function call order in comparisons. Data-flow analysis could be useful in minimizing false positives.

The method does not yet address situations where function calls include other function calls as arguments, a common occurrence in source code that poses a challenge for obfuscation. A tentative solution is to add temporary local variables to unfold nested function calls into separate assignments.

Current results show the outlining process as partial outlining graphs, with similarities used to locate matches between functions or clusters. Future work includes creating a user-friendly tool to better visualize the findings.