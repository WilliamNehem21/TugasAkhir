This paper introduces a lower-level specification language designed for describing actual internet security protocols. The specifications are produced by a compiler that converts TLA-based high-level descriptions of the protocols into rule-based programs, which contain all the necessary details for either implementation or verification of security characteristics. The methodology has been applied to a number of prominent internet security protocols, leading to the discovery of several vulnerabilities.

In the realm of security protocol specification, much of the research, including the authors' previous work, has been limited to simplistic toy protocols using Alice & Bob notation. The authors' primary objective is to address the complexity of real-world protocols like those being developed by the IETF. For this purpose, a new high-level protocol specification language (HLPSL) was created as part of the AVISPA project. The paper does not focus on the compiler itself but rather on how high-level properties are translated into rewrite rules, which the authors believe are well-suited to encoding properties of cryptographic protocols.

Security protocol analysis is typically a three-step process: specifying the protocol, analyzing it to catch trivial errors, and then moving on to a rigorous verification process. The paper emphasizes the need for protocol specifications to be clear, as they often serve as documentation that can be challenging to interpret, potentially leading to variability in understanding whether the intention is to implement, verify, or simply understand the protocol.

The authors illustrate their new specification language using a complex variant of the Needham-Schroeder Public Key (NSPK) protocol, focusing on the NSPK Key Server (NSPK-KS), presented in an Alice & Bob scenario. Variables in the transitions are used to denote changes in state, with "primed" variables representing future states.

The protocol specifications are then compiled into a rule-based program, which is semantically validated during the compilation phase. The high-level specification consists of roles, both basic representing a participant and composed describing the environment and how to instantiate the basic roles.

The current compiler considers only one type of channel that applies the Dolev-Yao threat model. The program generated defines each role's internal data structure and includes signatures for role state primitives. The compiler is flexible in translating variables shared between roles into constants in the generated rules.

A diverse range of protocols from different sources was assessed to validate the ability of the compiler to manage both low and high-level protocols, including those recommended and still in development by the IETF. In collaboration with Siemens, the compiler was used to analyze protocols under development, exemplified by the analysis of the AAA MobileIP protocol.

The compiler is implemented in OCaml and is part of the AVISPA project, aiming to support real-world security protocols. The initial results are promising, showing significant advancement over older compilers that could only handle simple protocols. The paper highlights the difference between the authors' language and MuCAPSL, pointing out that while MuCAPSL has more features, it is not clear how to specify shared information or role instances, making it less deterministic.

In conclusion, both MuCAPSL-MuCIL and the authors' compiler have their merits, but the new specification language targets industrial application by simplifying protocol specification while retaining enough power to describe most internet security protocols. The aim is to provide industrial partners with specifications that assist in implementing and verifying their own protocols, integrating with different verification tools as demonstrated by prior work with AVISPA.