This paper discusses the complexities faced by software development tools when integrating formal design by refinement transformations, alerting the research community to this issue. It explores a component-based, model transformational approach that leverages refinement within the object-oriented and component-based software development process. This method employs RCOS, a refinement calculus, to define, maintain consistency, and affirm correctness of models. In RCOS, transformations that preserve correctness are rigorously formulated and validated as refinement rules.

A variety of graph-transformation approaches, such as VIATRA, AToM3, GREAT, UMLX, and BOTL, have been developed based on theoretical graph transformations, with a focus on visual notations and formal foundations suitable for resembling UML models. While these tools have been applied in software development, more research is necessary to ensure the transformations' correctness and completeness.

The paper highlights the practical example of how a customer's checkout process translates into a series of actions, including recording purchases, handling payment, and updating inventory. For such scenarios, detailed design and verification of each component are necessary, utilizing tools like model checkers or JML for runtime checking.

A transformation could either check for consistency between two models without altering them or enforce consistency by modifying a model. Enforcement is subject to the properties of the target domain and follows a check-before-enforce scheme, with detailed semantics outlined in the paper.

During the transformation from object-oriented models to component-based architectures, use case functionality is redistributed among multiple components, with decisions on how to decompose this functionality left to the designers. Rules for these transformations are provided, including mapping rules for classes to components and assignment of methods.

For tool support, the authors suggest selecting a transformation that is proven correct in RCOS and implementing it using the QVT language. Transformation execution involves importing a source model and customizing it with design decisions. While these transformation processes tend to be unidirectional, bidirectional transformations are also presented with the potential complexity of requiring simultaneous changes to both models.

Some transformations need explicit design decisions, precluding a fully automatic process; this calls for interaction with the QVT tool to incorporate designer input. By implementing the OVT transformation for all RCOS refinement rules, particularly the 'expert pattern' commonly used in object-oriented design, a repository of automatic transformations with verified correctness can be created, enhancing reusability and efficiency.

The paper also discusses state diagrams that outline class behavior and method functionalities, with transitions indicated by internal methods or external invocations.

Acknowledgments are given to Zhiming Liu and Volker Stolz from UNU-IIST for their valuable insights on the paper. This work is partially supported by the HighQSoftD project, funded by the Macao Science and Technology Development Fund, and China's national grand fundamental research program (No. 2002CB312001).