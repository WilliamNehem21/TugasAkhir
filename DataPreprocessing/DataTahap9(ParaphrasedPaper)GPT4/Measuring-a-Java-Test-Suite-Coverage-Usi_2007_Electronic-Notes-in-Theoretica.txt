In this paper, we present a novel method for assessing the thoroughness of a Java test suite in conjunction with the Java Modeling Language (JML) specifications of the Java program being tested. Our approach involves generating a predicate-based graph from JML method specifications and measuring coverage based on the test suite's execution paths through this graph. We seek to determine whether a test suite satisfies traditional condition coverage criteria. To facilitate these evaluations, we have developed a tool that operates as a Java precompiler, tasked with measuring and reporting coverage according to these criteria.

Testing is essential for uncovering software defects, but it cannot be exhaustive due to the impracticality of testing all possible scenarios. Therefore, evaluating the test suite quality is critical to gain confidence in a program's reliability. Various evaluation methods have been explored, and coverage measurement is among the most pertinent. Standard coverage methods focus on the programâ€™s control or data flow, but our proposed technique extends this by including specification coverage.

Model-based testing generates test suites from a system model; when paired with conformance testing, it helps ensure a program behaves as specified. JML acts as a behavioral interface for Java, serving as an oracle where test success is contingent upon the absence of assertion violations during execution.

The paper is structured as follows: Section 2 details JML modeling capabilities. Section 3 introduces the novel coverage criterion based on method specifications, while Section 4 proposes the definition of condition coverage. The measurement principles and implementation are discussed in Section 5, along with experiments. Section 6 examines related work, with conclusions and future directions in Section 7.

We employed the JML Runtime Assertion Checker (RAC) in our approach, which verifies JML specifications during program execution. This serves as a modified precompiler that adds checks for various specification clauses. However, for practicality, we opted to rewrite only positive preconditions, avoiding combinatorial cases from precondition negations while still considering the potential for unauthorized actions.

Leveraging the principles behind RAC, we propose preprocessing that enriches Java code with JML predicate verifications and integrates a Coverage Report Manager for data collection. This methodology was tested with a simplified version of the "Demoney" applet, an electronic purse application. Various tools, including Jartege for random testing, demonstrated our approach's practicality, particularly when using our tool to control test generation based on a desired specification coverage rate.

Experimental results showed that execution overhead introduced by our JMLCoverage tool was minimal, especially in comparison to the comprehensive checks performed by RAC. While RAC offers partial coverage information, it lacks the granularity of our method. Our approach, merging traditional graph coverage criteria with condition coverage, allows specification-level evaluations that provide a more implementation-independent and black-box view of program behavior. This offers advantages over traditional code coverage approaches, aligning with tools that measure UML specification coverage, but our work specifically incorporates a comprehensive assessment of JML specifications for Java programs.