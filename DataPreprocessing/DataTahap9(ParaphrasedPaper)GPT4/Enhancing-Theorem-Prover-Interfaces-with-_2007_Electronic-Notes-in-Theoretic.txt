This paper presents a method to enhance theorem proving interfaces by incorporating a mechanism to aid in proof-directed debugging and other disproof-based applications. This method involves monitoring a predefined set of rules chosen by users and constructing a detailed program slice based on these rules' participation in both successful and failing proof attempts. This process yields a heuristic score to evaluate rule correctness.

The method assumes that debugging typically requires identifying an incorrect program statement or, for functional programs, an erroneous function case. Such faulty components manifest within a program slice, which can be detected during the verification process. The theorem proving system can also recognize slices that lead to valid inferences. The data gathered from this tracking is then utilized to enhance the user interface, notably by applying syntax highlighting to signal the reliability of different function cases. The authors propose a potential color-coding scheme and demonstrate its application using a case study with the proof assistant Isabelle/HOL and the Proof General interface.

Program slicing, initially introduced by Weiser, selects a particular variable at a certain point within a program as the slicing criterion and extracts relevant program fragments based on how the value of the variable depends on those fragments or how those fragments are affected by the variableâ€™s value. Techniques for this in imperative programming languages often use various graph-based representations, while in functional languages, function applications are analogous to program statements, and the concept of a slicing criterion can be generalized further.

One practical example provided is a student-submitted function called "onceonly," which generates a list with unique occurrences of elements from an original list, "l." This function contains three errors: a flawed base case in the "insert" function, a missing case for single-element lists in the "once" function, and a mistake in the recursive case's "else" branch.

During an attempted proof, it becomes evident that some independent lemmas about the "sort" function must be confirmed, showcasing how the system performs when a proof goal is false. The paper then moves on to a more advanced stage of the main verification, assuming that the "insert" and "sort" functions are no longer under suspicion. New functions, lemmas, and more advanced constructs in the language of the theorem prover are introduced.

The authors plan to implement their system using the Isabelle/Isar language and Proof General interface, which provides a clear distinction between interface-related information and data managed by the underlying theorem prover. Despite the separation, there are challenges, such as inferring necessary properties of goals and proof states and managing the relationships between goals for correct tracking of proof progress. Special attention is needed when the proof system discards goals that have been successfully addressed, as this might complicate tracking.

The paper notes that the proposed rule tracking also needs to accommodate situations where a rule is directly invoked by a tactic, like the "rule method" in Isar. Effort must be made to maintain up-to-date tracking information through a simple analysis of tactic invocations.