Programmable strategies of various types are prevalent throughout computer science. For example, rewriting systems benefit from evaluation strategies that do not require control over traversal. In the realm of theorem proving, specific strategies are utilized as proof tactics and "tacticals," while in parallel functional programming, similar strategies are employed to create parallel programs.

In the context of type systems, there are different types of generics that encapsulate transformations and queries across data types, such as 'GenericM', 'GenericT', and 'GenericQ'. The combinator 'gmapT', a generic transformation function, applies a type-generic transformation across a data structure, and it's a nonmonadic equivalent to 'allTP'. To improve clarity, type aliases are used, although the underlying polymorphic types could be specified directly.

A more specialized variation of 'stop_tdTP', a type-generic scheme, was derived to showcase flexibility. This new scheme uses the 'Maybe' monad, as opposed to the original which used the abstract type 'TP M', capable of being instantiated with any 'MonadPlus'. This change ensures successful strategy composition due to the non-monadic result type 'GenericT'.

Strategies are also compared to attribute grammars, with the former being more operational, focusing on traversal, and the latter being more declarative, focusing on attribute dependencies. There is ongoing research into integrating these two approaches, which may yield compelling insights. Just as strategies can be smoothly integrated into Haskell, attribute grammars can too.

For XML document processing, strategies can be an effective tool, similar to language processing based on syntaxes. There are existing functional combinator libraries for XML processing, but they often lack the typing strength found in functional strategies. It's proposed that strategies could provide a way to manage fully typed XML transformations, somewhat akin to using an XPath-like language for control.