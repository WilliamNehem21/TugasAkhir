The paper discusses a method of handling assertions at runtime through translation rather than embedding an interpreter for an assertion language within the runtime environment. This translational method can be seen as less capable than the interpreter method, as it is limited to assertions that can be easily translated into a target implementation language. However, its simplicity offers flexibility, making it easier to adjust translation rules, create variations, and connect to different implementation or assertion languages. This strategy is particularly suited for systems built with multiple programming languages, such as component-based systems.

The paper is structured with the second section illustrating the main concepts applied to an example system, and the third detailing a prototype that includes a customizable OCL translator. The fourth section compares the current work to existing research, focusing on alternatives for supporting OCL. The conclusion is drawn in section five.

The authors exemplify their approach using the iContract assertion language within the Java programming context, but note that other Java assertion languages could serve similarly. While Java's native assert statements provide flexibility and user choice in expressing assertions, a dedicated assertion system more strictly controls the possibilities for the user.

The paper identifies that while the inherent constraint between 'off at' and 'on at' times are implicitly understood, this is different from the requirement for increasing times across rows of data. It points out that each journey segment must adhere to previously discussed constraints.

The distinction between translation and interpretation blurs in practice, since interpreters often translate to an intermediate form, and translators generally rely on runtime libraries. It's conceivable to create a hybrid approach where design constraints are translated and supported by a library to bridge the gap between a design constraint language and current assertion languages.

Previous work on OCL support primarily involved bespoke interpreters, such as one proposal which uses a meta-model for OCL as a basis for creating an interpreter. Other works include experiences with interpreting OCL, and proposals for efficiently running complex OCL assertions.