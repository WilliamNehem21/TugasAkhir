This paper explores a different direction, the use of MSCs as a formal semantics, in terms of potential execution histories, for known code. We work within a process calculus, the pi-calculus, although the ideas should apply to other languages. The semantics of the pi-calculus is typically specified as a reaction or reduction rela- tion, or as a labelled transition system [30,39]. We propose a form of MSC as an alternative.

To explain some of the basic ideas and to see some of the benefits of a chart semantics for the pi-calculus, we describe a simple example. We suppose there is a single stateful server S(n, s) which when called with a value n' and a session channel c, responds by sending on c its current state n, provisions a private service R(c) to handle the session, and changes state to S(n', s). Here is pi-calculus code for such a server, together with a client C(n', s) that initiates such a session, and then runs A(n, c) where n is the previous state of the server and c is the session channel.

The pi-chart below shows interactions between one server and two clients. Pi-charts are in the spirit of MSCs but do not conform to the letter of the standard [21]. In particular, we allow processes to fork, and to generate fresh names.

mantics is hard to visualize; listing the series of intermediate states can lead to an overwhelming amount of syntactic detail. Conventionally, reduction and transition relations are closed up to associativity and commutativity of parallel composition. Hence, it is hard to track the evolution of individual threads within a system. One solution is to introduce syntax for abstract locations [13], although this increases the amount of syntactic detail when visualizing reductions. On the other hand, pi-charts have a two dimensional representation that is easily rendered pictorially. The graphical structure allows detail, such as process labels, to be omitted with

little risk of ambiguity. Vertical paths in a chart track the evolution of individual processes; in our example, we see that S(n, s) is an ancestor of R(c1), S(n2, s), and R(c2), but not of the other processes at the bottom of the chart. (There is, though, a causal relation between S(n, s) and all the processes at the bottom.)

Appendix A shows how charts can usefully illustrate the behaviour of biological reactions expressed in the pi-calculus. Appendix B is a case study of proving prop- erties expressible with pi-charts. We introduce a type system built from standard notions of name groups, group creation, and usage bounds on channels. Formal data flow and usage properties are conveniently expressed using charts. Theorem B.1 es- tablishes bounds on data flow and channel usage guaranteed by the type system.

Let P be the set of all processes. Names identify communication channels. We write fn(P ) for the set of names occurring free in P . Let P {y/x} be the outcome of substituting y for each free occurrence of x in P . We write a, c, x for finite tuples of names.

Each pi-chart has a top, the nodes with no predecessors, and a bottom, the nodes with no successors. A core idea, formalized later as Theorem 3.7, is that a pi-chart represents a computation starting with the processes at the top, and ending with those at the bottom. We formalize top and bottom below, together with other notations needed for a compositional definition of pi-charts: new(G) is the set of names generated within a chart; Gnil is the edgeless graph consisting of the terminal nodes of G, that is, those labelled with 0.

Crazzolara and Milicia [14] establish explicit formal links between MSCs, for- malized as pomsets [37], and the semantics of the Security Protocol Language (SPL) [15]. SPL can be seen as a simple process calculus, with broadcast communi- cation, but without process forking as in the pi-calculus. They define an algorithm for constructing an MSC from any finite trace in the transition semantics of an SPL program. Their main formal result is that the events of such an MSC can be linearized to match the trace and moreover that every linearization of the MSC corresponds to a trace of the original SPL program. Their MSCs are extracted from an existing semantics for SPL, rather than being defined directly.

Although a chart corresponds to a single execution trace, in future we envisage verification tools for proving properties about the set of all charts generated by a given process. For example, this could be useful for validating high-level protocols expressed as pi-calculus processes. In cases where the desired properties do not hold, a visual execution trace representing a counter-example could be presented to the user.

The chart shows how one of the genes, in this case Gene(a, b), transcribes a Protein(b), which immediately blocks Gene(b, c). Gene(c, a) transcribes Protein(a) soon after, which blocks Gene(a, b).The Gene(a, b) and Gene(b, c) both remain blocked, waiting for a slow unblock delay to fire, while Gene(c, a) is able to freely produce Protein(a) and start the first oscillation cycle.

