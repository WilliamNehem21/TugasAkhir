We define EVL, a minimal higher-order functional language for dealing with generic events. The notion of generic event extends the well-known notion of event traditionally used in a variety of areas, such as database management, concurrency, reactive systems and cybersecurity. Generic events were introduced in the context of a metamodel to deal with obligations in access control systems. Event specifications are represented as records and we use polymorphic record types to type events in our language. We show how the higher-order capabilities of EVL can be used in the context of Complex Event Processing (CEP), to define higher-order parameterised functions that deal with the usual CEP techniques.

Note that, much like what happens with tuples, the type of a particular list in this notation will be closely related to the size of the list in question. A more realistic approach is to add lists and list-types as primitive notions in the language, but, as we mentioned before, we are focusing on a minimal language. Furthermore, we will often use constants (numbers, booleans, strings, etc) and operators (arithmetic, boolean, etc) in our examples. However, following the minimalistic approach, we do not add constants/operators to the grammar and instead use free variables to represent them. Again, in a more general approach we could extend the grammar with other data structures and operators, for numbers, booleans, lists, etc.

Example 2.3 Consider the following example illustrating the definition of a generic event FireDanger and of a function check that determines if there is the danger of a fire erupting in a particular location, using the weather information associated with that location. Function check creates an appropriate instance of FireDanger to report the appropriate fire danger level.

In this section we are going to study the application of EVL in the context of Complex Event Processing (CEP). See [15] for a detailed reference on the area. The area of CEP comprises a series of techniques to deal with streams of events such as event processing, detection of patterns and relationships, filtering, transformation and ab- straction, amongst others. Because EVL is a higher-order functional language, we are going to explore the higher-order capabilities, to define higher-order parameterized functions that deal with the usual CEP techniques.

The canonical model [10,15] for event processing is based on a producer-consumer model: an event processing agent (EPA) takes events from event producers and distributes them among event consumers. This process often involves filtering or translating. Filtering may happen because not every event will be of interest or available to every consumer: in some cases access control policies might be in place that restrict what events consumers might receive. Translating events allows us to change, add or remove information from the agents based on particular consumers. The processing of events can be done in a one-event in/one-event out form, but it is also possible to have event processing agents that process a collection of events as a whole or that produce a set of events as result: for example, an incoming event may be split into multiple events, each containing a subset of the information from the original event.

EVL can be used to program event processing agents. It is able to process raw events produced by some event processing system and generate derived events as a result. These derived events can then be passed on to an event consumer.

Transformation event processing agents can be either stateless (if events are processed without taking into account preceding or following events) or stateful (if the way events are processed is influenced by preceding or following events). In the former case, events are processed individually. In the latter, the way events are processed can depend on preceding or succeeding events. Transformation events can be further classified as translate, split, aggregate or compose agents. In the following we describe some transformation events that we are going to focus on.

Example 5.9 This example represents an event processing agent that composes the partial weather information that is provided by two different sensors. One of the sensors outputs event x, which contains information about the temperature and wind velocity, and the other sensor outputs event y, which contains information about the humidity and precipitation levels. This event processing agent outputs an instance of WeatherInfo with the complete weather information.

Definition 5.10 [Pattern Detect event processing agent] A Pattern Detect event processing agent is an event processing agent that performs a pattern matching function on one or more input streams. It emits one or more derived events if it detects an occurrence of the specified pattern in the input events.

An area where pattern-detect agents are quite relevant is in publish-subscribe systems, where consumers are allowed to subscribe to selective events by specify- ing filters using a subscription language. The filters define constraints, usually in the form of name-value pairs of properties and basic comparison operators, which identify valid events. Constraints can be logically combined to form what are called complex subscription patterns [16]. CEP systems extend the functionality of tra- ditional publish-subscribe systems by increasing the expressive power of the sub- scription language to consider complex event patterns that involve the occurrence of multiple, related events [12].

else i f ( p list . head ) then ( cons list . head ( f ilt er p list . t a i l ) ) else f i l t e r p l i s t . t a i l

When dealing with event processing applications, many events will have a similar structure and a similar meaning. Consider a temperature sensor: all of the events produced by it have the same kind of information, such as temperature reading, timestamp and maybe location, but with possibly different values. This means that instead of defining the structure of each event individually, we can specify the structure of an entire class of events [15]. This relationship was formally defined in [1] as that between Generic and Specific events. EVL is based on the typed language that was defined in [1], but it extends it by allowing explicit subtyping between record types according to [24].

A retraction event relationship is a property of an event referencing a second event. It indicates that the second event is a logical reversal of the event type that references it. For example, an event that starts a fire alert and the event that stops it. This is a notion that is also present in access control systems with obligations. In [1], this is defined by a closing function that describes how events are linked to ( x . snd . p recipitation + y . precipitation )/ x . f s t ) ) i n l e t check x = i f ( x . temperature > 29 and x . wind > 32

When it comes to processing flows of information, there are two main mod- els leading the research done in this area: the data stream processing model [4] (that looks at streams of data coming from different sources to produce new data streams as output); and the complex event processing model [23] (that looks at events happening, which are then filtered and combined to produce new events). In [12], several information processing systems were surveyed, which showed a gap between data processing languages and event detection languages, and the need to define a minimal set of language constructors to combine both features in the same language. We believe that EVL is a good candidate to explore the gap between these two models.

With respect to future work, events in our language are represented by records of the form {l1 = v1,..., ln = vn}, with appropriate constructors for creating, accessing and modifying records. Additionally one could consider more powerful operations on records, such as extending a record with a new field or removing an existing field from a record, which are not part of EVL but could prove useful in both CEP and in the treatment of obligations in the context of access control models.

