software components, where each component can in turn be composed of other sim- pler components. The encapsulation here means that the programmer only needs to know what each component does (the semantics), without worrying about how this is done (the implementation). Object oriented languages such as Java [16] are based on this concept, allowing the definition of flexible, extensible, and reusable software components, thus saving time and avoiding errors in the final program.

A declarative debugger starts when the user finds out some unexpected behavior while testing a program, i.e. an initial symptom. Then the debugger builds a tree corresponding to the computation that produced the initial symptom. Each node of this tree corresponds to the result of some subcomputation, and has a fragment of program code associated, namely the fragment of code needed for producing the result. The children of a node correspond to the results of those subcomputations that were necessary to obtain the parent result. In particular the root of the tree corresponds to the result of the main computation. The user navigates the tree looking for a node containing a non-valid result but whose children produced valid results. Such a node is considered a buggy node and its associated fragment of code is pointed out as erroneous because it has produced a wrong output result from the correct input results of its children.

In this paper we apply the idea of declarative debugging to the object oriented language Java. Starting from some erroneous computation, our debugger locates a wrong method in the debugged program. The task of the user during a debugging session is reduced to checking the validity of the results produced by some method calls occurring during the computation. Thus, our tool abstracts away the details of the implementation of each method, deducing the wrong method from the intended semantics of the methods and the structure of the program.

The idea of using declarative debugging out of declarative programming is not new. In 1989 N. Shahmehri and P. Fritzson presented in [13] a first proposal, further developed by the same authors in [5]. In this works a declarative debugger for the imperative language Pascal was presented. The main drawback of the proposal was that the computation tree was obtained by using a program transformation, which limited the efficiency of the debugger. The differences of our approach w.r.t. these earlier proposals are:

Modern languages such as Java offer new possibilities for implementing the declar- ative debugger. In our case we have based the implementation of our prototype on the Java Platform Debugging Architecture (JPDA) [7]. JPDA has an event- based architecture and uses the method-entry and method-exit events in order to produce the computation tree. The result is a much more efficient tool.

A more recent related work [6] presents a declarative debugger for Java that keeps information about most of the relevant events occurred during a Java computation, storing them in a deductive database. The database can be queried afterwards by the user in order to know the state of the program (variables, threads, etc.) in different moments of the execution in order to infer where the bug is located. The main difference between both proposals is that our debugger concentrates only on the logic of method calls, storing them in a structured way (the computation tree) which allows the debugger to deduce the wrong method from the user answers.

In the next section we present the application of the ideas of declarative debug- ging to the case of Java programs. Section 3 introduces the idea of using a test-case generator in order to reduce the number of questions that the user must answer before finding the bug. In Section 4, we discuss the limitations of our prototype. Finally the work ends presenting some conclusions and future work.

Let D1,. . . , Dn be the sets of def-use chains corresponding to the previous n calls of the considered method, and let D be the set of def-use chains covered by the considered call to that method. Analogously, let E1,. .., En be the sets of edges of the control-flow graph covered by the previous n calls of the considered method, and let E be the set of edges covered by the considered call to that method. These pieces of information give us a couple of options, how to combine them. Depending on how conservative we want to be, we can infer that a considered call works properly, if

Another limitation of our prototype is that it only indicates a wrong method rather than the buggy statement in that method. We could switch to a trace debugging mode for finding the error more precisely. However, a well-designed program should not contain long methods. Thus, it should not be a problem to find the erroneous line in the indicated method.

