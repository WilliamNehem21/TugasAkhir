Given 1) source code annotated with preconditions and postconditions and 2) a security property of interest, the overall problem is how to establish that the code satisfies the property. We developed a five-step process for establishing the property. These five steps are described next.

To show formally that the system is secure, we prove that the system code is a refine- ment of the state machine that underlies the TLS. For ED, our proof of refinement is based on a demonstration that all kernel code falls into three major categories: Event Code, Trusted Code, and Other Code (see [10] for details). Partitioning the code dramatically reduces the cost of code verification since only Event Code, a small part of the code, must be checked for conformance to the TLS. In ED, Event Code and Trusted Code comprised less than 10% of the code. The remaining 90% was Other Code.

and from the code states to the states in the TLS, and 2) a mapping from precondi- tions and postconditions in the TLS events to the preconditions and postconditions that annotate the corresponding Event Code. We demonstrated separately that Trusted Code and Other Code were benign. Based on these results, we concluded that the kernel code refines the TLS. Because in step 3, we proved that the TLS satisfies the properties that guarantee data separation and because each property is preserved under refinement, we may conclude that the kernel code is secure. For details, see [10].

During certification, the natural language representation of the TLS enabled the evaluators to communicate easily with the formal methods team and others, thus ensuring that misunderstandings were avoided and issues resolved early in the cer- tification process. The natural language representation of the TLS for ED contrasts with the representations used in other formal specifications of secure systems. These specifications are often expressed in specialized languages such as ACL-2 (see, e.g, [8]). Any ambiguity in the natural language representation of the kernel behavior was removed by translating the TLS into TAME, since the state machine semantics underlying TAME is expressed as a PVS theory.

For the approach in Section 3 to succeed, a security property must be preserved under refinement. It is well-known that safety (but not liveness) properties are preserved under refinement [1]. Hence, our techniques may be used to guaran- tee security properties that are safety properties. It is easy to show that all se- curity properties verified for ED, except one, are safety properties and therefore

For many years, researchers have recommended annotating code with precondition, postconditions, and invariants (see, e.g., [13]). Such code annotations are already used in practice: Developers at Praxis annotate SPARK programs with assertions and use tools to automatically check the assertions [4]. Moreover, in the largest Microsoft product groups, annotations are a mandated part of the software devel- opment process [6]. Unfortunately, manual annotation of source code remains rare in the wider software industry because it is highly labor-intensive [9]. To address this problem, Amtoft et al. have developed new techniques for checking and for de- riving annotations from SPARK programs [2]. Tools for checking and deriving code annotation for programs written in other languages, such as C, would be extremely useful.

Many new techniques for constructing tests from formal specifications have been proposed. Such techniques (see, e.g., [7]) derive a set of test cases from a formal specification and use them to test the given program. One promising new approach constructs test cases from preconditions and postconditions and uses the test cases to check that the given program satisfies the asserted preconditions and postcondi- tions. Validating source code in this manner should provide high assurance of both the security and functional correctness of source code. Reference [20] describes an approach that uses automatic test generation from preconditions and postcondi- tions to find bugs in Java code. Similar research is needed that uses tests generated from an annotated program written in another language, such as C, to check the program for errors.

