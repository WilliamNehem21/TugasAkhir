type op = Reg of register | Mem of {size : int, reg : op} | Imm8 of [8]. Here, the argument to the Mem constructor is a record while Imm8 takes a bit vector of 8 bits, written [8]. Bit vectors and int are the only basic data types with singleton bit-vectors acting as Booleans. Abbreviations for complex types can be introduced syntactic construct in line 4.

val /66 [0 x0f 0 x59 / r] = binop MULPD xmm xmm / m128 val / f2 [0 x0f 0 x59 / r] = binop MULSD xmm xmm / m64 val / f3 [0 x0f 0 x59 / r] = binop MULSS xmm xmm / m32 val main [...] = ...

not written in C. A possible reason for the results of the metasm package being slower is that it does not only do a linear sweep but also resolves symbols and does some control-flow analyses using the decoded instructions. Similarly, we were unable to run a linear-sweep disassembly using IDA Pro.

Here, four 66 prefixes precede a segment override prefix 2e before a nop opcode f1 f8 follows which takes an elaborate argument. Furthermore, malware may add spurious prefixes as additional code obfuscation technique. Thus, a decoder has to recognize more than what the manual recommends.

Further afield is the specification of semantics for which many intermediate rep- resentations have been suggested [14,15,16]. The expressed goal of GDSL is to also specify how a processor instruction can be translated to an intermediate represen- tation that describes its semantics. Using a common framework can help to make the various intermediate representations comparable and usable in various analysis frameworks. Recently, Reps et al. have proposed to compile an abstract transformer for each processor instruction in order to obtain more a more efficient analysis [17]. Future work will address how a different backend to our compiler can follow this setup.

