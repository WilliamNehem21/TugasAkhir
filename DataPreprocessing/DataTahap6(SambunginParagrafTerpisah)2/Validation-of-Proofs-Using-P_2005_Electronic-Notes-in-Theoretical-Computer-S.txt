In this paper we present the DemoNat project, its purposes and the ideas developed so far. De- moNat is a French project whose aim is to make a program able to analyze and validate proofs made in a natural language. It will be used by students in order to improve the way they understand and make mathematical proofs.

Let us explain it: the student first writes a proof of a theorem in a natural language. The program then translates it into a proof made in an intermediate language called PhoX.nc. It includes the standard commands of PhoX and some others that we will call new commands.

Standard commands are the usually defined commands in proof assistants: intro, left, elim, apply, prove, trivial, .. .. All except trivial correspond to combinations of proof rules and so are validated for syntactic reasons. New commands are different because the automatic tactic must prove a for- mula before validating them.

In section 2 we introduce the new commands and explain the purpose of this language. In section 3 we give a simple example of a proof that could be made by a student and we explain how the program will have to analyze it. The section 4 is devoted to the validation, the mathematical part of the project, which needs a theorem prover dedicated to this project.

As the definition of new commands is not yet fixed, we give here a very general and partial (but an important part of the) grammar for the commands in PhoX.nc. An important thing to mention is that these commands are de- signed to be close to a natural language but with a formal grammar. Thus by this principle some of the standard commands are kept:

As you can see the proof is really easy. Now let us study in detail how the translation from the natural language to PhoX.nc could be made. We must warn about the fact that this translation is only one possible and that there may be many other translations. The aim is just to point out some of the difficulties that may occur while translating proofs into PhoX.nc. The translation here will be done step by step, that is one sentence after the other. At each step we give the current hypotheses and goal together with the sentence written by the student and from them will follow the translation.

Here there are two difficulties. The first one is that the student knows implicitly that there are two kinds of neighbourhood but he does not make this difference explicitly in his sentence. So the translator has to be able to deal with that: find the good notions of neighbourhood for each word. Here it is one more time helped by reading the definition of the goal. The sentence of the student is no more than a reading of a definition.

In this part we explain how the meta-rules coming from the new command could be validated by an automatic prover. As the current automatic tactic of PhoX is not powerful enough for the new commands, we need another one, dedicated to the problem. The idea is in fact to implement an inverse resolution method in a lazy way. The purpose of this paper is not to define it, we will just give some examples and hope that they are clear enough. We assume anyway that the reader knows what is the resolution method. Otherwise, see some of the references given, for instance [2] and [5].

What we have seen here is an overview of the DemoNat project which is not yet implemented (except PhoX and PhoX.nc). Some of the difficulties that can appear in the linguistic part of the project have been pointed out. In the basic example given they seem not to be strong: we have only done a translation sentence by sentence.

In fact there are two ways of thinking the system. The first one is to validate a whole proof and so to read the complete text of the proof. In this case the system has a great freedom on the parts translated into PhoX.nc. The second one is to build a proof, i.e. the user interacts with the system. He writes a proof and when he needs to know what is the current state of the proof he tells it to the analyzer. Then the system analyses the part asked by the user.

As we have seen, a good way to handle with the formulae implied by the commands of PhoX.nc is to implement an inverse resolution in a lazy way. Indeed the formulae given to the automatic prover seem to be particular: most of them are propositional or need the use of few quantifiers. We could think about a prover becoming stronger when the user is a more advanced student. This means that the system may reject steps of the proof if it sees that they are too difficult for a beginner for example.

