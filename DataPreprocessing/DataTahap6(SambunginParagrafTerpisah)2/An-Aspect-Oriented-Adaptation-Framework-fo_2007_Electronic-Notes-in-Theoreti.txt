This paper briefly describes the design of a dynamic adaptation management framework which exploits the concepts provided by Aspect-Oriented Software Development (AOSD), in particular Aspect-Oriented Programming (AOP). The framework uses reflection and adaptation techniques in order to support COTS composition and evolution by tackling issues related to signature and protocol interoperability. This pro- vides a basic infrastructure for a non-intrusive, semi-automatic approach for syntactical and behavioural adaptation.

adaptation which has to be repeatedly performed when teams face component in- tegration along the evolution of the system. These activities are highly demanding, consuming time and resources which could otherwise be devoted to the enhance- ment or development of new functionality. Moreover, some kinds of systems can not be shut down (i.e., banking or airport traffic control systems). Evolving such systems without halting them (e.g., replacing a component with a new version) is a challenging operation which comprises many different problems.

The need to automate the aforementioned adaptation tasks has driven the devel- opment of Software Adaptation [4], a field characterised by highly dynamic run-time procedures that occur as devices and applications move from network to network, modifying or extending their behaviour. Software Adaptation promotes the use of software adaptors [19], which are specific computational entities for solving in- teroperability problems between software entities (i.e., components, services, etc.). These issues can be classified in four different levels:

Protocol Level: Interfaces at this level specify the protocol describing the interac- tive behaviour that a component follows, and also the behaviour that it expects from its environment. Mismatch may also occur at this protocol level, because of the ordering of exchanged messages and of blocking conditions. The kind of prob- lem that can be addressed at this level is, for instance, compatibility of behaviour (i.e., whether the components deadlock when combined).

In this paper, Section 2 provides an overview of Aspect Oriented Programming. Section 3 briefly describes a small example which will be used to illustrate our proposal throughout the upcoming sections. Section 4 describes the design of a dy- namic adaptation management framework based on AOP, automatic protocol adap- tor derivation, and illustrates key implementation issues using AspectJ [9]. Section 5 compares our proposal with related work in the fields of Software Adaptation and AOP. Finally, Section 6 presents conclusions and open issues.

Aspect-Oriented Programming (AOP) is based on the idea that systems are better programmed by separately specifying the different concerns (properties or areas of interest) of a system and a description of their relations, and then relying on mechanisms in the underlying environment to weave or compose them together into a coherent program. Taking a look at the modular structure of a system, it can be observed that while some concerns are neatly localised within a specific structural module, others cross multiple elements. AOP is focused on mechanisms for simplifying the realization of such crosscutting concerns (e.g., security). AOP provides aspects as the mechanism to provide an explicit structure for the expression of crosscutting concerns, compacting into a single structure behaviour that otherwise would be scattered throughout (and tangled with) the rest of the code in the system. AOP also provides mechanisms for weaving aspects and base code together into a coherent working system. This weaving process can be performed at different stages of the development, ranging from compile-time to run-time (dynamic weaving)[13]. The dynamic approach implies that the virtual machine or interpreter must be aware of aspects and control the weaving process, although it represents a remarkable advantage, considering that aspects can be applied and removed at run-time. This allows the modification of application behaviour during the execution of the system in a transparent way.

the quantification of join points) to match on them. Once a join point has been matched, the AOP program can run the code corresponding to the new or injected behaviour (advices) typically before, after, instead of, or around (before and after) the matched join point. Since join points are dynamic, it is possible to expose run- time information such as the caller or callee of a method from a join point to a matching pointcut.

Concerning the signature level, name mismatch occurs if a particular compo- nent is expecting a particular input message, and receives one with a different name (e.g., RulesEngine sends loadRules whereas RuleSetProvider is expect- ing getProvider). Moreover, it can be acknowledged that the expected function-

Adaptors are automatically built from an abstract description of how mismatch between components or services can be solved (i.e., adaptation mapping ), which is based on the description of component interfaces. The first step towards the realisation of adaptation is the obtention of this mapping. Anyway, its construction falls out of the scope of this paper. Given a mapping description, this section is focused on the design of an aspect-based adaptation management framework able to work out the mismatch between components at the protocol and signature levels.

It inspects the interfaces of the components as they join the context of the system, and keeps their description in an interface repository in order to use them later for mapping generation. For this purpose we use reflection techniques. Upon initial- ization of the component c of class C, the manager checks for the existence of an entry for C in the repository, and if it does not exist, it creates one for it.

In order to illustrate some of the issues related to the implementation of our pro- posal, AspectJ is used. This is a language level Java AOP extension which is highly representative of the AOP systems currently used. In this section some of the key structures and mechanisms provided to implement the functionality of the adapta- tion management framework are highlighted.

Component class identification and interface inspection is performed using the Java Reflection API. Through this API the class of each component can be ob- tained, along with information from it such as name, public attributes, and method signature description. It is worth noticing that parameter name information is not stored in standard Java .class files, so it is not retrievable using standard Java reflection. However, the AspectJ compiler does enrich compiled classes with that information. We will consider that we have that information readily available for our purposes.

Redmond and Cahill present in [16] the Iguana/J architecture and programming model to support unanticipated dynamic adaptation. Here, each functional class is associated with a set of adaptation classes which contain the adaptation code. The association is also specified in separated entities in order to achieve improved flexibility. In contrast, in our proposal different adaptors are built and managed specifically for each interaction between components as they join the context of the system. Hence, adaptation code is encapsulated into aspects, although not in a static way. On the contrary, aspects act as interpreters of the design information gathered from the components and as coordinators of the interaction between them.

In this paper, we have discussed our approach to Aspect-Oriented Dynamic Com- ponent Adaptation in order to support Dynamic Component Evolution. We have proposed a design for an adaptation management framework, highlighting its ad- vantages as a potential tool to support the process of component evolution. We have then illustrated the foundational differences of our proposal comparing it with related work.

