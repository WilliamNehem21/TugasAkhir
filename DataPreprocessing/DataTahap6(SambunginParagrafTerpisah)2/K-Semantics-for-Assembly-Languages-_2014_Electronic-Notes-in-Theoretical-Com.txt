The Maude system [6,7] is the implementation of rewriting logic and together with a number of integrated methodologies and tools, it facilitates the design and analysis of systems. To the best of our knowledge, there are two approaches to model assembly languages. The work in [12] proposes a first model of a simplified RISC assembly language, used in verification of various microprocessor elements. The method presented in [27] presents a limited subset of the x86 assembly language for malware behavior detection. Both of these approaches focus more on verification issues and less on the language definition ones. Language semantics definitions rely on the memory system specification, both at the structural and functional levels. With respect to the memory representation in formal language definitions using rewriting logic, our current work complements the work in [13], which proposes memory models for imperative and object-oriented languages.

The K framework, described in [26], is a rewrite based framework that enables the definitions of operational semantics of programming languages. K shows its versatily when handling definitions of real languages, such as C in [8], Scheme in [19] and Verilog in [20]. In our previous work [1], we succinctly introduced the integer subset of the language of interest. The current implementation of K is implemented on top of the Maude system and is called K-Maude. In this way, it has access to all integrated technologies and tools that Maude offers.

Outline of the paper. The paper is organized in the following way. Section 2 briefly overviews some concepts of the K framework as we formally define the assembly language. Section 3 describes a modular system with an emphasis on the main memory modeling and two of its possible instances. Section 4 presents implementation and benchmarking specific details, while Section 5 contains the conclusions.

We give more practical insights into K when we define the Simplescalar [4] PISA assembly language, which we call SSRISC. Next, we present a subset of it that includes integer and floating point ALU-instructions, branch and jump instructions, load and store instructions, an instruction for program errors. In other words, the subset exposes many of the language semantic entities, using the K specialized notation.

We present a number of SSRISC instructions, which cover arithmetic-logic in- structions on both integer and floating point registers, branch and jump instructions, load and store instructions, an instruction to manipulate special flags (i.e. bc1t) as well as a special instruction for program errors - break. We implement the semantics in [4].

Out of the arithmetic-logic instructions, we present the two addition instructions: add on integer operands and add.s on floating point operands. The K rule for add states that the instruction with the source integer registers having values V1 and V2 reduces to an overflow check, ovf, for the signed addition between these two values and, if necessary, followed by the destination register Rd update with the result. When the overflow condition is on top of the computation and it is evaluated to true, the execution continues with an instruction for program errors, break. The K rule for addition instruction add.s is reduced to a term for the register update, updateFReg,

The branch and jump instructions transform the task in the k cell into a correct pc register update. Before each instruction is reduced, via a structural K rule, into the corresponding operation, the value of the pc register has the address of the next instruction. The two rules for instructions j and jal use the setPC operation with the first argument 1 which means a program counter update. The jump and link jal instruction saves, in the ra cell, the return address after the execution of the callee function terminates. The instruction bc1t sets the target address depending on the value of a special flag called fcc.

The last semantic rule of the SSRISC language treats the special break instruction. The k cell gets the last term that ends the computation, while the special break cell updates to reflect a program error. We mention that last is also used for normal termination of computation.

First, the new instruction la that loads a destination integer register with the data that resides at a symbolic address. The sort of this address is denoted by SVar and is subsorted to the built-in sort for identifiers #Id. Then, the load instruction lw could handle symbolic addresses, based on a specified offset.

The execution of an instruction that manipulates symbolic data addresses (i.e. la or lw) is transformed into an integer register Rd update, via a structural K rule. The symbolic memory address VA is wrapped by a new term, getAddr, which acts as communication message between the semantic and the memory model.

There are several other possible extensions. For example, the labels for instruction addresses can be handled in a similar way, using a specialized cell. The message getAddr is transformed into a lookup in the list of labels, to identify the value Val associated with a particular label VA. When this particular message is the result of the execution of a lw instruction, the actual data address is translated, using the information stored in the cell dlabels.

The current implementation of the SSRISC assembly language follows a standard approach for programming language definitions in the K framework. In general, such a definition in K comprises of a syntax module, a semantic module and the use of a built-in module for the implementation of the support operations. Our definition of the SSRISC assembly language poses two kinds of particularities, imposed on one hand by the language specifics and on another hand by the target applications. We start with the former and elaborate on the later afterwards.

An important element in our design is what we name a communication module, to allow easy extensions to the definition. For example, the K rules for the load and store instructions use geti and getd operations to fetch instructions, respectively data, from the memory. We call these communication channels between the semantics and the memory module, and we place them into the communication module. In this way, the memory model could be replaced with a different one, without modifying the semantics. Another example is with respect to the labeled representation of the data memory addresses. The instruction la uses a communication channel called getAddr to access the information in the cell dlabels.

A particularity of the SSRISC definition is that it allows to underspecify the memory content using symbolic values for stored data. For example, if a load instruction (i.e. lw, l.s and la accesses a memory address with an unknown value, this value is retrieved and further propagated during the program execution. The set of specific built-in operations on bitwise representation is extended to handle the symbolic value. We have used this feature in the context of abstract execution of programs for estimation of timing bounds [1].

The Simplescalar toolset [4] is an architecture simulator and presents two sets of instructions: a MIPS-based assembly language, used to compile C programs into it and a set of simulator-specific instructions. We implement the former, together with a number of pseudo-instructions and some of the instructions specific to the program with labels. There are 112 instructions, each implemented using exactly one K rewrite rule, and 20 rewrite rules for auxiliary operations (i.e. set the program counter, overflow check etc). The memory modelings comprises of 15-20 rewrite rules, which are split into memory read and write cases (for word and double word).

code without library function calls (i.e. memcpy), which currently, we do not support. We consider simple C programs, with small arrays of integer and floating point values, to test various arithmetic and logic instructions, as well as load/store instructions and conditional and unconditional jumps. Also, the return value of a C program and its corresponding representation in the assembly program - the value in a particular register - should be compared and decide if the test program passes or fails. We reiterate that our intention is to present the SSRISC language definition as a basis to define abstractions for timing analysis of embedded programs. For this purpose, the input program uses the non-labeled representation of the main memory because it contains useful information about actual instruction and data placement.

