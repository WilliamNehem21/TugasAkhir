This paper presents the integration of the optimization known as dynamic cut within the functional-logic system T OY . The implementation automatically detects deterministic functions at compile time, and includes in the generated code the test for detecting at run-time the computations that can actually be pruned. The outcome is a much better performance when executing deterministic functions including either or-branches in their definitional trees or extra variables in their conditions, with no serious overhead in the rest of the computations. The paper also proves the correctness of the criterion used for detecting deterministic functions w.r.t. the semantic calculus CRWL.

Nondeterminism is one of the characteristic features of Logic Programming shared by Functional-Logic Programming. It allows elegant algorithm definitions, increas- ing the expressiveness of programs. However, this benefit has an associated draw- back, namely the lack of efficiency of the computations. There are two main reasons for this:

However, in spite of being well-known and accepted as an interesting opti- mization, the dynamic cut had not been implemented in any real system up to now. In this paper we present this implementation in the functional-logic system T OY (available at http://toy.sourceforge.net).

The paper is organized as follows. The next section introduces the non-ambiguity criterion for detecting deterministic functions and the correctness theorem. Section 3 shows by means of examples the cases where the optimization will be applied. Section 4 presents the steps followed during the implementation of the dynamic cut in T OY, and Section 5 finalizes presenting some conclusions.

The non-ambiguity condition characterizes a set of functions F as deterministic. This is because the value of a function may depend on other functions, and in general this dependence can be mutual. In practice the implementation starts with an empty set F of non-ambiguous functions, adding at each step to F those functions that satisfy the definition and that only depend on functions already in F . This is done until a fix-point for F is reached.

Examining the code we find out easily the source of the redundant computation: the condition of function part includes two existential variables U and V. When the user asks for more solutions the backtracking mechanism looks for new values of the variables satisfying the conditions. But this is unnecessary because the rule already has returned true and cannot return any new value. The dynamic cut will avoid this redundant computation. Here is the same goal running after activating the dynamic cut optimization in T OY :

Now the system detects automatically that there are no more possible solutions after the first one, reducing the 40 seconds to 0. The interested reader can find in [4] more experimental results. The experiments in that paper were tested introducing manually the code for the dynamic cut before the optimization was part of the system. However the results have been confirmed by the current implementation.

Function calls f (e1,... , en) occurring in the first order T OY program rules are replaced by Prolog terms of the form susp(f (e1,... , en), R, S) called suspensions. The logical variable S is a flag which is bound to a concrete value, say hnf, once the suspension is evaluated. R contains the result of evaluating the function call. Its value is meaningful only if S==hnf holds.

After g' succeeds, i.e. after an or-branch has produced a result, the test for the dynamic cut is performed. This test, represented by predicate checkvarlist, checks if any of the variables in the list produced by varlist has been bound. This will mean that either an input logical variable has been bound or a non- deterministic function has been evaluated. In any of these cases the cut is avoided. Otherwise the dynamic cut, which is implemented as an ordinary Prolog cut, is safely performed. The definition of checkvarlist is simple:

The code of this example corresponds to the implementation of an orCut node. The two branches are represented here by the two clauses for multi' (correspond- ing to function g' in the case 3 of the previous subsection). The cut is introduced if the first alternative, which corresponds to a case node with two possibilities, succeeds.

In this paper we have presented the implementation of the dynamic cut optimization in the Functional-Logic system T OY . The optimization improves dramatically the efficiency of the computations in the situations explained in the paper. Moreover, we claim that in practice it allows the use of some elegant and expressive function definitions that were disregarded due to their inefficiency up to now.

The definitional tree associated to each program function is examined. The or nodes occurring in deterministic functions are labeled during this process as or-cut nodes. Also the try nodes corresponding to program rules including existential variables in the conditions are labeled as try-cut nodes.

