We present a new abstraction of reactive systems interacting with databases. This abstraction is intended to be used for model-based testing. We abstract the database into two sets: present set and absent set, and present a proof of this abstraction. We present two extensions of FSM, the DBFSM and PAFSM. DBFSM are a form of FSM incorporating databases. PAFSM are an abstraction of DBFSM using present-absent sets. Depending on what type of testing is to be done, the translation is tailored to fit this purpose. We show how this translation is related to the present-absent abstraction. Finally, we illustrate the approach through a small example and show how this can be used for testing with the model-based testing tool Uppaal TRON.

This paper presents one such abstraction. We model the database as two sets, the present set and the absent set. The present set is an under-approximation of the data present in the database, and the absent set is an under-approximation of the data not present in the database. This way we can abstract over an infinite amount of databases with two small sets.

To enable model-based testing using this abstraction we present two new forms of FSM: DBFSM and PAFSM. We show that the present-absent abstraction is used to translate from DBFSM to PAFSM, and how specifications for testing can be developed using PAFSM. Additionally we show an example and how test cases can be generated from this example.

In this paper we consider reactive systems which interact with databases in a shallow manner, meaning no complex operations on the data are performed. Rather the system can insert or remove values to and from the database and the control flow of the systems can depend on the presence or absence of values. We refer to this simplistic view as databases althought databases are far more complex. The simplistic view in this paper is a starting point and is intended to be extended with a more complex view of databases.

The paper is structured as follows: Section 2 describes some related work. Sec- tion 3 describes model-based testing in its two forms, online and offline. Section 4 through 7 describe the theoretical parts of this paper. First the present-absent abstraction is explained and proved. Then extended finite-state machines are ex- plained, and these are further extended to include databases and present absent sets. The abstraction and translation between DBFSM and PAFSM is described in Section 8. A short example is presented in Section 10, and Section 11 concludes the paper.

Model-based testing originates in the formal approaches developed by Tretmans [6,7], and implemented in the tool TorX [8]. These approaches have been extended to include real-time by Hessel et al. [1], and implemented in Uppaal TRON [2]. Also, a number of commercial UML-based tools are emerging, such as Qtronic and ATG.

Online testing merges test-case generation and execution into one activity. The test cases are dynamically derived from a simulation of the model and sent to the implementation under test (IUT) directly. Output from the IUT is observed and the state of the model is updated accordingly. The advantages of online testing include easier handling of non-determinism and the reduction in state-space. Non- determinism is easier to handle since the IUT is dynamically observed, thereby revealing which non-deterministic choices have been taken, eliminating the need for the test tool to track unnecessary states. The state-space is reduced for the same reason. Disadvantages include the difficulty to reason about coverage and the arbitrarily long traces complicating the process of linking an erroneous test case to an error in the IUT.

We now introduce the present and absent set abstraction originally proposed in [3]. The abstraction abstracts a database into two sets; the present set and the absent set. The present set is an under-approximation of the values which are present in the database and the absent set is an under-approximation of the values which are not in the database. This can be seen as a three-valued-logic, where if the value is in the present set it corresponds to true, if the value is in the absent set it corresponds to false, and if the value is in neither it corresponds to unknown. If the value is in both sets it corresponds to an erroneous state, this should be avoided. This abstraction allows us to abstract over an infinite number of databases and abstract away from the actual content of the database, using a relative small set of values.

We now present the translation from DBFSM to PAFSM. Two translations are presented, they differ in the way unknown values are handled. The first translation assumes full knowledge of the database, and enters an error state if at any time an unknown value is observed. The second assumes no knowledge and is allowed to nondeterministically choose whether an unknown value should be treated as present or absent.

If the value is in the present set this transition has no effect. If the value is in the absent set, it is added to the present set and removed from the absent set. If the value is in neither present nor absent the value is added to the present set.

If the value is in the present set, it is removed from the present set and added to the absent set. If the value is in absent set this transition has no effect. If the value is in neither present nor absent the value is added to the absent set.

online testing, the non-deterministic choices allow the model-checker to be in both states at the same time, and reduce the state space when observations from the IUT reveal which choice was correct. When trees are generated for offline testing the tester can traverse the tree and follow branches according to the output ob- served. How the non-determinism is handled in practice is shown in more detail in the concrete example in Section 10.

Traditionally testing is not performed on the system in actual use, since the test cases can interact arbitrarily with the actual database. By proving correctness on the present-absent sets, and proving that the test cases will only interact with the specific test data, the tests can be executed on the actual running system. By observing the state of the database the state of the system can be entered into the sets, and the tests can be executed, only affecting the test data in the database.

To illustrate the abstraction and test-case generation, an example is presented. This example is manufactured by hand since no tool support has been developed yet. The specification of the IUT is a network of timed automata in Uppaal syntax. Three network of timed automata are presented: one modeling the system using databases, one translation assuming no knowledge and one assuming full knowledge.

the system, the output channels are used to return to the user. The shared variable currentId is used to pass the id of the calling user to the system, and used by the user to ensure the result is returned to the correct user. The Add and Remove methods are used to add and remove cid to and from the database respectively.

the values. If the value is unknown a non-deterministic choice is available, either return OK and add the user to the present set, or return Error and remove the user from the set. The methods Login and Logout handle this. This has the effect of updating the database when the correct choice is observed from the IUT. Notice that when the result of a login action is unknown both the OK and the Error choice add the user. This is because, returning Error means the user is in the database, therefore we add him. If we return OK the user is not in the database, and we should remove him, however, since the login was successful the user is now added to the database, therefore we add him.

This system has been tested against an implementation using Uppaal TRON. The systems was instantiated with ten users. A mutant is made, in which the login action has a 1/500 chance to fail to update the database. The system has been implemented such that the database is filled with random values at initialization. This way the tester has no way of knowing the state of the database when starting the test. The test was run ten times on the correct implementation and ten times on the mutant. Each successful test executed about 22.000 action (input and output combined). One of the mutant runs failed to detect the mutant, this is due to the randomness of the mutant. The tests have shown us that the present-absent set approach has the capabilities to automatically test a system which interacts with a database without knowledge about the state of this database prior to testing.

static testing tool. To generate the traces the Uppaal model checker can be asked whether a template can reach a specific location and get a trace of how to reach this location. This trace can be used as a test case.

We have introduced the abstraction from a database into present and absent sets and a proof of this abstraction. We have introduced two new forms of FSMs, the DBFSM and PAFSM and explained how to translate from DBFSM to PAFSM. Furthermore, we have explained two different translations and how these relate to the present-absent abstraction.

We are able to perform online testing of systems without taking any assumptions about the state of the database into account. As the test progresses, we gradually gain more knowledge about the state of the database. This increase of knowledge will reduce the state space of the simulation model, as well as enable us to potentially guide the testing in a desired direction.

We enable two forms of offline testing. One without assuming any knowledge about the state of the database. We are able to generate abstract traces which automatically learn the state of the database and make choices accordingly to reach the desired state. By examining the state of the database prior to generating the test cases, we are able to generate static traces which can be executed without any branching. This removes the problem of state dependency when performing offline testing on database systems. There are some potential performance issues with this approach, but we are hopeful as to finding a solution to these problems.

As future work we plan to extend the simplistic view of database presented in this paper. We plan to measure the effectiveness of this approach on larger examples, preferably industrial. We are currently working on extending the Uppaal model checker to improve the effectiveness of model checking systems using present and absent sets.

