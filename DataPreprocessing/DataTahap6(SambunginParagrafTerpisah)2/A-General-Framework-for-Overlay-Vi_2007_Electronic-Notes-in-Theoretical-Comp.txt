1) to separate the application from the visualization; and 2) to separate the specification from the rendering. We will describe a few applications of overlay visualization for programming and provide examples from our implementation of overlay visualization for software tutors called problets. The advantages of overlay visualization include: less cognitive load on the learner, and automatic support for both path and state visualization.

Overlay Visualization is the superimposition of graphics on the material to be visualized. In the context of programming, it is superimposing graphics on code. We will first describe a general framework for overlay visualization in section 2. Next, in section 3, we will discuss some applications of overlay visualization for program visualization. We will illustrate with examples from our implementation of overlay visualization for programming tutors called problets (www.problets.org) [6]. In section 4, we will present the current implementation. Finally in section 5, we will discuss the advantages of overlay visualization and compare it with prior work.

While separating the application from the visualization, we wanted to ensure two objectives: 1) maximize the flexibility of visualization; and 2) minimize the overhead of specifying such visualization. Separating the specification from the rendering and using a declarative representation for the specification increases the flexibility of the framework. The specification can be coded by hand, generated automatically by a program, or specified by the learner using mouse gestures. In all these cases, the visualizer that translates the specification into visualization would be the same.

Less Cognitive load: There is less cognitive load if both the code and the visualization are displayed on the same panel. The student doesnt have to al- ternate between two separate panels, and mentally put together the information from the two panels. His/her attention will be focused on both the code and the visualization at the same time.

Execution History: As compared to code visualization, where only the cur- rently executing line of code is highlighted (e.g., [8]), overlay visualization auto- matically supports the display of execution history. Including execution history is one of the ways to improve the effectiveness of visualization [12]. In other words, overlay visualization supports path visualization (execution history), just as easily as state visualization (a current snapshot of the program being executed).

Active learning: One of the recommendations for improving the effectiveness of visualization is to let the learner construct his/her own visualization [12], [4]. This will promote visual as well as active learning. With overlay visualization, students can construct their own visualization using mouse gestures. For example students can specify Connect and Point by dragging the mouse, highlight by double-clicking the mouse, etc. The user interface can translate mouse gestures into visualization specifications, which can then be compared with the correct specifications to provide feedback to the learner.

control space visualization (flowchart of the program, call graph, UML diagram, etc.), and control flow visualization (highlighting the path of execution of a pro- gram) provided in visual debuggers (e.g., Retrovue http://www.retroview.com/, whyline [5]), program visualizers (e.g., Jeliot 3 [11]) and concept visualizers (e.g., [3] [9]).

