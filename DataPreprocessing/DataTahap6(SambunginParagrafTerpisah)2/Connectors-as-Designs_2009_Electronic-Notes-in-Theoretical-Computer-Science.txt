The point of UTP is to formalize the similar features of different languages in a similar style, and on that basis to analyze and connect different languages. One potential benefit of the UTP semantics for Reo is the possibility to integrate rea- soning about Reo with reasoning about component specifications/implementations in other languages for which UTP semantics is available, such as CSP, Circus and rCOS. Another possible benefit of the result in this paper is that it provides a semantic model in which the causality of connector behavior is made explicit by separation of the assumption and the commitment in the design model. The ac- counting of assumptions and commitments can enable a large team of engineers to collaborate successfully in the design of huge connectors. The UTP approach also makes it possible to check connector properties by assume-guarantee reason- ing. Properties of a complex connector can be decomposed into properties of its subconnectors and each subconnector can be checked separately.

This paper is structured as follows. In Section 2 we briefly summarize the coordination language Reo. Then, in Section 3, we present the UTP observation model with meta variables and introduce the UTP design model used throughout the rest of the paper. In Section 4, we present the UTP design semantics for basic connectors in Reo. In Section 5, the composition of connectors is discussed. In Section 6 we discuss refinement and testing of connectors. Finally, Section 7 concludes with some further research directions.

In this section we provide a brief introduction to Reo [6]. Reo is a channel-based exogenous coordination model wherein complex coordinators, called connectors, are compositionally built out of simpler ones. Exogenous coordination imposes a purely local interpretation on each inter-components communication, engaged in as a pure I/O operation on each side, that allows components to communicate anonymously, through the exchange of untargeted passive data. We summarize only the main concepts in Reo here. Further details about Reo and its semantics can be found elsewhere [6,8,11].

Complex connectors are constructed by composing simpler ones via the join and hiding operations. Channels are joined together in nodes. A node consists of a set of channel ends. The set of channel ends coincident on a node A is disjointly partitioned into the sets Src(A) and Snk(A), denoting the sets of source and sink channel ends that coincide on A, respectively. Nodes are categorized into source, sink and mixed nodes, depending on whether all channel ends that coincide on a node are source ends, sink ends or a combination of the two. The hiding operation is used to hide the internal topology of a component connector. The hidden nodes can no longer be accessed or observed from outside. A complex connector has a graphical representation, called a Reo circuit, which is a finite graph where the nodes are labeled with pair-wise disjoint, non-empty sets of channel ends, and the edges represent the connecting channels. The behavior of a Reo circuit is formalized by means of the data-flow at its sink and source nodes. Intuitively, the source nodes of a circuit are analogous to the input ports, and the sink nodes to the output ports of a component, while mixed nodes are its hidden internal details.

set of all observation-capturing variables, used in this paper is different from that for a design in [14]. The signature gives the rules for the syntax for denoting the elements of the theory. Healthiness conditions, which embody aspects of the model being studied, are taken as true here.

An important subtheory of relations allows the separation of preconditions from postconditions, in the manner of the well-known formal methods like VDM [16], B[2], RAISE [21], refinement calculus [9] and more recently OCL [17]. This allows us to model the total correctness of programming constructs using relations. This section is an introduction to the relational calculus on designs in UTP.

As can be seen, a design predicate represents a pre/post-condition specification. The separation of precondition from postcondition allows us to write a specification that has a more generous precondition than simply the domain of the relation used as a specification. Implementing a design, we are allowed to assume that the precondition holds, but we have to satisfy the postcondition. Moreover, we can rely on the system having been started, but we must ensure that it terminates. If the precondition does not hold, or the system does not start, we are not committed to establish the postcondition nor even to make the system terminate.

The synchronous channel transfers the data without delay in time. So it behaves just as the identity function. The pair of I/O operations on its two ends can succeed only simultaneously, and the input is not taken until the output can be delivered, which is captured by the variable ok.

This channel is similar to a synchronous channel, except that it always accepts all data items through its source end. If it is possible for it to simultaneously dispense the data item through its sink end, the channel transfers the data item. Otherwise the data item is lost.

Therefore, test cases, as well as connector specifications and implementations, can be specified by designs. It is obvious that an implementation that is correct with respect to its specification should refine the test cases of the latter. An implementa- tion refines a test case if and only if the implementation passes the test case. Taking specifications into consideration, the specification should also be a refinement of a test case if the test case is properly derived from the specification. An algorithm

This paper demonstrates that UTP can be applied not only for giving semantics of specific programming languages and specification languages, but also for providing a formal semantic foundation for coordination languages. In particular, the unified semantic model for different kinds of channels and composite connectors in Reo covers different communication mechanisms encoded in Reo, and allows the combi- nation of synchronous and asynchronous channels as in Reo. Our semantic model offers potential benefits in developing tool support for Reo, like test case generators. Furthermore, the predicates used in UTP provide a possible symbolic representation of coloring for connectors [12], and thus make it possible to synthesize connectors from specifications more efficiently.

The authors are indebted to our colleagues, especially Bernhard Aichernig, Jan Rutten, Frank de Boer, Milad Niqui and Christel Baier for helpful discussions, and Jifeng He for the constructive comments on an earlier version of the paper which helped to simplify the model and improve this paper. We are grateful to Lacramioara Astefanoaei for her help in developing the test case generator. The work reported in this paper is supported by a grant from the GLANCE funding pro- gram of the Dutch National Organization for Scientific Research (NWO), through project CooPer (600.643.000.05N12), and the DFG-NWO-project SYANCO.

