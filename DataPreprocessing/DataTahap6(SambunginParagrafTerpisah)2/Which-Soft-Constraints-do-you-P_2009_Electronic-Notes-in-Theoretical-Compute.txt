Soft constraints are gaining popularity in diverse areas such as orchestration of Web services or optimization of scheduling decisions. However, current approaches to soft constraints preclude them from modelling certain decision problems with multiple preference criteria. We propose a new approach to soft constraints which allows a natural expression of these problems, describe an implementation in the rewriting logic system Maude, and prove its correctness.

Soft constraints are gaining popularity in diverse areas such as orchestration of Web services (see e.g. [13]) or optimization of scheduling decisions (see e.g. [18]). How- ever, current approaches to soft constraints preclude them from modelling certain decision problems with multiple preference criteria.

The structure of the paper is as follows: In Section 2 we introduce the theory of Monoidal Soft Constraints. We describe the transformations that we perform on constraint systems before submitting them to the solver in Section 3. In Section 4 we describe the branch-and-bound algorithm and prove its correctness. The final two sections present related work and our conclusions.

A monoidal soft-constraint problem combines the grades of several soft constraints into a single rank which measures the overall quality of a solution. We use a family of c-operations, called the preference relation to specify this combination process. While the grades represent the quality of individual constraints the preference re- lation expresses the importance we assign to the individual constraints.

improve the efficiency of constraint solving, all recursive specifications are written in tail-recursive form. In the following we present shortly the implementation of the constraints for the meeting scheduling service and the branch-and-bound algorithm for solving soft constraints. The implementation is based on our earlier work for solv- ing soft constraints over constraint semirings [21]. The main changes are: solving soft constraints over partially ordered monoids instead of totally ordered constraint semirings, and a flexible approach for specifying preferences between constraints by dynamically constructing cartesian and lexicographic products of monoids instead of using a (possibly composite) fixed constraint semiring.

In some cases, it is also possible to use divide-and-conquer optimizations. If two lists of constraints cl1 and cl2 are combined lexicographically, it is possible to solve the first constraint independently and then process the second constraint for each solution of the first one. Cartesian products can also be computed independently if they do not share variables.

A general observation is that the introduction of totally ordered preferences tends to speed up the search significantly whereas the introduction of indifferences (which lead to partial orders) slows down the search, often several orders of mag- nitude. The divide and conquer optimization separates the problem into several smaller ones which can be solved independently and thereby tends to reduce the time necessary to compute the solutions. However, there are certain problems where each of the preceding statements does not hold and the reverse effect can be ob- served.

The most direct influence on our work was the elegant theory of semiring-based constraint satisfaction problems (SCSPs)(see e.g. [5,6,4]); the constraint solver pre- sented in this paper is an enhanced version of the solver for semiring-based con- straints presented in [21]. Semirings are not closed under lexicographic products, therefore SCSPs cannot be used to directly express the preference relations described in this paper. Other approaches to generalize SCSPs for preference relations are given in [8,7]. Our approach was also inspired by [1] where preferences are treated in an elegant algebraic way.

The separation into grades and ranks resembles the stratification of constraint problems in constraint hierarchies [10,9]. Constraint hierarchies describe a hierarchi- cal structure of crisp constraints where a comparator function computes values for the quality of solutions which are consistent with the hierarchy. There exist many algorithms for solving particular constraint hierarchies, and a number of constraint solvers for solving particular constraint hierarchies have been implemented [19,2,16]. It is an interesting problem to try to generalize some of these algorithms to work with our framework.

Using Maude as the implementation language simplifies the correctness proof for the implementation and allows us to easily integrate the solver into the Pagoda system for software-defined radios. On the other hand, using the Maude system entails some inefficiencies which are not incurred when implementing the solver in a lower-level language. We are currently working on a C# implementation which we expect to be competitive with other soft-constraint solvers.

In the Maude implementation we flatten the constraint system and thereby re- move the separation between grades and ranks before trying to solve the constraints. While this simplifies the constraint solver this preprocessing removes information that might be used to improve the performance of the constraint solver. Further re- search is needed to find appropriate analysis methods that can exploit the two-level structure of the constraint problem to generate improved solvers.

Currently we restrict constraints to finite support. It is straightforward to gen- eralize the theory to constraints with infinite support and therefore to address prob- lems that go beyond constraint satisfaction problems. However, further research is needed to develop efficient methods to solve these generalized problems.

