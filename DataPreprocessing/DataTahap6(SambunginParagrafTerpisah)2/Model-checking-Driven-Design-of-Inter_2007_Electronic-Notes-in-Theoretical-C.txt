A number of researchers have explored the use of formal models to understand how cognitive errors can affect user performance. Rushby [12] models the behaviour of a forgetful operator who follows a warning display light or a non-forgetful operator without warning lights and checks for an emergent mode confusion. Curzon and Blandford [5] focus on goal-based interactions and model the behaviour of a user who assumes all tasks completed when the goal is achieved, but forgets to complete some important subsidiary tasks (post-completion error).

Section 2 introduces a scenario that may occur during a workshop or conference, in which conference attendees share thoughts and opinions through a web interface motivated by various goals (Section 2.1). We also assume a basic structure of the web interface accessible through a login mechanism (Section 2.2).

describes the model of the user behaviour in terms of three possible goals that may motivate and lead the user in interacting with the system: expressing own ideas in the forum (Section 3.1), establishing contact with a matching user (Section 3.2) and gathering information about other users (Section 3.3).

Section 5 identifies possible security threats (Section 5.1), defines a security prop- erty which aims to prevent security violations (Section 5.2), introduces assumptions on the expertise and forgetfulness of a typical user (Section 5.3), shows how to analyse the system design under the given assumptions with respect to the security property (Section 5.4), and describes possible improvements of the design to reduce (Section 5.5), or even completely overcome (Section 5.6), the vulnerabilities of the initial design.

This tool consists of a web-based interface which could be a part of a bigger system, that features a simple discussion forum and a member list. Through web pages users gather information on a conference (or some other events) and find/contact other users who are likely to match their interests. The tool, however, does not feature a dating service [9]. Matching decisions are instead explicitly made by the user.

We start considering a common scenario that may occur at a workshop or conference. We use the word user to identify the main subject of our scenario. After a lecture or speech a user would like to meet other attendees to discuss impressions or reactions to the attended presentation. Such attendees might either be working on similar projects as our user or have similar thoughts about the topic of the presentation. A lecture usually involves a large number of attendees and every single attendee could have a different opinion about the topic. In series of lectures attendees do not have many chances to communicate with one another and ask opinions. Therefore it is important to allow the user to search and initiate communications before attending the conference and in order to make in advance plans and appointments for meetings to be held while being at the conference.

After achieving the goal, the authorised user can either logout or choose a new goal and continue the interaction session with the system. In principle, a cognitively plausible behaviour [1] must include the situation in which the user may leave the interaction session unattended at any time, independently of whether the goal is achieved or not. However, such a situation is unlikely to occur when the user focusses on achieving the goal, but it is much more plausible after the goal is achieved. It is actually common that the user assumes all tasks completed when the goal is achieved, but forgets to complete some important subsidiary tasks (post-completion error) [5], such as logging out of the system. Therefore we assume that

After achieving the goal, the authorised user may pursue a new goal (state AuthorisedUser) or leave the session (state Leave). In the latter case, the user may either logout (action logout) or leave the session unattended (action unattended) without logging-out. An unattended open session, after a certain time, which may be short (action short_delay) or long (action long_delay), may be taken over by an unauthorised user (in state UnauthorisedUser), who can try to perform any action.

of the information gathering loop, if the information gathering process has been performed outside the system. Obviously, the goal_achieved action must be pre- ceeded by the try_contact action. Due to assumption (2) in Section 2.2 action try_setup may also need to be performed.

Process Priviliges defines the initial state, in which the user has not logged in yet. After the user logs in (action login), the system checks whether the user has already set a profile (action profile) or not (action noprofile). If the user has not set a profile yet, the state changes to NonMember, otherwise it changes to Member. These two states define the two user privileges that correspond to assumptions (1) and (2) in Section 2.2. The purpose of action enter is to move to the state corresponding to the appropriate user privilege and to activate the web interface described in Section 4.2. User privileges can be changed by the successful execution of action try_setup (from NonMember to Member). Action logout leads back to the initial state (Priviliges).

The other states model the five web pages described in Section 2.2. Actions users, forum, home, back_to_users and back_to_forum allow the user to freely navigate through the five web pages. Note that action logout is only possible from state Home1. This means that the user has always to go back to the home page in order to be able to logout.

Interface1 is then composed with the User process. In this second parallel com- position, the synchronisation must include all user actions that define interactions with the interface. Note that we have also included the failure action, which does not occur in the Priviliges and Interface1 processes (and therefore neither in their parallel composition) in the sychronisation set. This prevents the overall system from performing the failure action, so modelling the following assumption

Such an assumption was implicitly made for logout and navigation actions in Sec- tion 4.2; it is here explicitly extended to all user actions. The purpose of this assumption is to show that the design weaknesses captured by the model-checking analysis presented in Section 5.4 are independent of the ability of the user in suc- cessfully performing a single interaction with the interface.

Ideally, we would like an unattended session to automatically logout on time to prevent security violations. However, in practice, we can just introduce safeguards that minimise the likelihood of security violations, in a way that does not introduce much degradation in the quality and performance of the services provided to the user. In order to find the right balance between security and the quality and per- formance of services, it is important to analyse the user attitudes and behaviours while interacting with the system. Specific attitudes and behaviours may actually reduce the likelihood of some threats and increase the likelihood of others. For example, panicking when the planned action does not appear immediately available on the current web page is an attitude that may lead to the behaviour of leaving the session unattended, so causing a security threat. On the other hand, the attitude of always checking that all tasks have been completed after achieving a goal reduces

In CWB-NC syntax atomic formulae have form {action list} or {-action list}; the former is satisfied by any action that appears in action list, whereas the latter is satified by any action that does not appear in action list. Note that a deadlock process satisfies ~{action list}, where ~ is the negation connective, but does not satisfy {-action list}. The W temporal operator (weak until ) ensures that formula pWq is true if and only if p is continuously true forever or until q is true.

Note that using {-success} rather than ~{success} in formula secure ensures that a deadlock occurring after the goal is achieved falsifies the secure formula. We will exploit this in Section 5.3 by checking whether some constrained user behaviours are supported by the interface.

The users of our system are not supposed to be expert in using interactive systems. In fact, some of them might have very low familiarity with computers. The user behavior model defined in section 3 is a very general one and needs to be restricted to capture specific attitudes and behaviours of non-expert users.

The user defined by the SYSTEM1N process may, however, forget to logout and leave the session unattended even if there is a logout mechanism (e.g. a logout button) promptly available on the current web page. This occurs when actions unattended and logout are both available but unattended is chosen. We model an extreme case of a non-forgetful user, who will always choose a logout action when available after goal_achieved, even when intending afterwards to pursue another goal, and will never leave the session unattended. Such a non-forgetful user may be defined by appropriately synchronising the system with the NonForgetful process defined as follows.

The problem is that the logout is not available on each web page, but just on the Home page. The users have to properly navigate back to the Home page from the page where the goal has been achieved. This might be quite challenging for a non-expert user. In addition, the presence of a logout button on each web page would be a reminder for the user to logout, so addressing also expert but forgetful users.

A problem with the interface defined by SYSTEM2 is the lack of any protection for forgetful users. Although adding a direct logout mechanism to each web page may work as a reminder to the user to logout, users might still forget to logout. Property security does not actually hold for SYSTEM2N.

This process models the presence of an authorised user until action unattended occurs, and then the presence of an unauthorised user, with no authenticated action allowed, until action logout occurs. Note that this constraint restricts as- sumption (5) in Section 4.3 to authorised users only.

