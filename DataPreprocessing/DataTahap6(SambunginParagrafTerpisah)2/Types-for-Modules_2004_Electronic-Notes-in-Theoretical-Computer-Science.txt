The programming language Standard ML is an amalgam of two, largely or- thogonal, languages. The Core language expresses details of algorithms and data structures. The Modules language expresses the modular architecture of a software system. Both languages are statically typed, with their static and dynamic semantics specified by a formal definition.

Over the past decade, Standard ML Modules has been the source of inspiration for much research into the type-theoretic foundations of modules languages. Despite these efforts, a proper type-theoretic understanding of its static semantics has remained elusive. In this thesis, we use Type Theory as a guideline to reformulate the unconventional static semantics of Modules, providing a basis for useful extensions to the Modules language.

Our first extension generalises Modules to higher-order, allowing modules to take parameterised modules as arguments, and return them as results. We go beyond previous proposals for higher-order Modules by supporting a notion of type generativity. We give a sound and complete algorithm for type-checking higher-order Modules. Our second extension permits modules to be treated as first-class citizens of an ML-like Core language, greatly extending the range of computations on modules. Each extension arises from a natural generalisation of our type-theoretic semantics.

Modules allows definitions of identifiers denoting Core language types and terms to be packaged together into possibly nested structures. Access to structure components is by the dot notation and provides good control of the name space in a large program development. Structures are transparent : by default, the identity of a type component within a structure is evident from outside the structure. This provides good support for the incremental construction of large programs.

Standard ML is distinguished from most other programming languages by the existence of a formal definition of both its syntax and semantics. It is a strongly typed language with static type checking of programs performed prior to program execution. These two phases are defined, respectively, by separate static and dynamic semantics. Type checking ensures the absence of certain run-time type errors, such as accessing an undefined component of a structure, or using a Core value component at a type incompatible with its definition. In this sense, Standard ML is similar to the formal languages studied in Type Theory. This field of logic has close connections to Com- puter Science and provides a rational basis for the design of programming languages. Indeed, the type-theoretic underpinnings of the Core language are well-understood.

In recent years, largely inspired by the success of Standard ML Modules, the study of the type-theoretic foundations of module languages has be- come an active topic of research. Nevertheless, despite numerous attempts, a proper type-theoretic understanding of Standard ML Modules, and its static semantics in particular, has remained elusive. The benefits of a type- theoretic understanding are twofold. Type Theory provides us with a frame- work for analysing existing features of the language and for synthesising new features by generalisation.

This thesis has two main objectives. The first is to provide a better, more type-theoretic formulation of the static semantics of Modules. The second is to use this formulation as the rational basis for designing proper extensions of the static semantics.

This approach is rather different from those of other researchers in the area. Reductionist approaches aimed at providing type-theoretic semantics of Modules by a translation into existing type theories have either failed to capture significant features and properties of the language, or imposed severe limitations inherited from the chosen model. Others approaches have relied on introducing new, and often badly behaved, type-theoretic constructs.

In Chapter 5, we extend the Modules language of Chapter 3 to higher- order. Functors are given the same status currently enjoyed by structures: they may be bound as components of structures, specified as functor ar- guments and returned as functor results. We give a sound and complete algorithm for signature matching that forms the basis of a type checking algorithm for Higher-Order Modules. This chapter builds on the alterna- tive semantics of generativity given in Chapter 4 and on previous work by Biswas [Bis95] that extends a skeletal fragment of Modules to higher-order. We reformulate, generalise and clarify his definitions, and use them to prove analogous results. Our work furthers his by capturing a notion of type gen- erativity, and by catering for more realistic Core languages, e.g. languages supporting polymorphic values and parameterised types.

In Chapter 6 we briefly discuss the foundations of a separate compilation system for Modules. One of the main criticisms of Standard ML Modules is its perceived lack of support for separate compilation. We review the simple approach to separate compilation in traditional programming languages and explain why previous attempts to adopt this approach in Standard ML have failed. Unlike other researchers, we place the blame for this failure on an inappropriate choice of compilation unit, not on the semantics of Modules.

In Chapter 7 we turn our attention to the particular Core language presented in Chapter 3, Core-ML, and consider relaxing the stratification between Core and Modules. We obtain a language with first-class modules: modules may be passed as arguments to Core-ML functions, returned as results of arbitrary computations, selected using conditional expressions, stored in data structures and so on. Our approach is novel in maintaining the distinction between Core and Modules. Instead of amalgamating the features of both in a single language, we provide constructs for packing and unpacking module terms as Core values, allowing programs to alternate between Core and Modules level computation.

The components of a structure identifier can be accessed by using the dot notation. For instance, the type IntNat.nat refers to the type component nat of IntNat and denotes the type int. The term IntNat.zero refers to the value component zero of IntNat. It evaluates to 0, and has type int. Structure bodies may themselves contain definitions of (sub)structures.

functors ensures that conceptually distinct applications of the same functor return distinct abstract types. In Standard ML, a functor may only be defined at the outermost or top-level of a program. In particular, a functor may not be defined as a component of a structure, applied to a functor, or return another functor as a result. These restrictions mean that functors are first-order mappings on structures.

tional, stronger notion of sharing, called structure sharing. Encapsulating a body of declarations within struct and end generated a new internal struc- ture name, or stamp, for the expression, similar to the generation of a fresh abstract type. However, the name identified the entire structure, not just in- dividual types. In signatures, structure sharing constraints could be used to specify structure components with shared names. This made it possible to specify sharing not only of types, but also of values, since any two structures which shared the same name must have originated from a common ancestor. This interesting but little used feature has been abandoned in the revised definition of Standard ML [MTH96]. The move simplifies the semantics, benefitting both the working programmer and language implementor.

Although the published definition of Standard ML [MTH90, MT91, MTH96] formally defines the Modules language, it makes few concessions to help the reader understand its features. It particular, no attempt is made to relate these features to well-known concepts developed in the theory of program- ming languages. This has presented an obstacle not only to the understand- ing of the language, but also to its further development.

Remark 2.2.2 (The Phase Distinction). A typed programming language is said to obey a phase distinction [Car88b] if the type of any term in the language can be checked without evaluating arbitrary terms. This allows the semantics of the language to be split into a static semantics of type checking, that is performed at compile-time, and a dynamic semantics of evaluation, that is performed at run-time. The phase distinction is impor- tant because it ensures that the tractability of type checking is independent of term evaluation, which, in typical programming languages, may fail to

From a programming language perspective, adding universal quantifica- tion allows us to express polymorphic programs. A polymorphic program is a program whose operation is generic in a type. The operation of appending two lists is a good example of a polymorphic operation, since it is indepen- dent of the type of elements stored in the list. With simple types, we have to define a new, but essentially identical, append operation for each type of list element. Polymorphism allows us to get away with a single definition, leading to substantial savings in code and maintenance.

Remark 2.2.4 (The Logical Interpretation). From a logical perspective, this extension alone is not particularly meaningful. However, if we combine it with the extension to quantified types, we obtain a system that corresponds to higher-order propositional logic. That is, we can now quantify not only over propositions, but also over functions from propositions to propositions and so on.

Research related to this thesis can be divided naturally into three categories: type-theoretic approaches to modular programming, type-theoretic accounts of Standard ML Modules, and type-theoretic alternatives to Standard ML Modules. We shall discuss each of these in turn and finish with a section on miscellaneous related work. In Chapter 9 we will revisit some of this work to compare it with the results of this thesis.

Despite these similarities, DL fails to model most of the other important features of Modules. It is impossible to specify type definitions in signa- tures, preventing the expression of shared type components. Components are accessed not by identifier but by positional notation. DL has no notion of subtyping (corresponding to signature matching), making it impossible to treat a structure as if it had a type declaring fewer components, a type higher-order functors in [MT94]. The behaviour of this static semantics is reflected in an early implementation of higher-order functors in the Stan- dard ML of New Jersey compiler [AT 93]. The static semantics is very complicated and departs radically from the existing first-order semantics of Standard ML. In particular, it relies on the compile-time execution of a non- trivial language of identity stamps to account for full transparency. (On the other hand, the dynamic semantics for this proposal admits a straightfor- ward formalisation that is studied by Maharaj and Gunter [MG93].)

Taking a different tack, Biswas [Bis95] proposes an alternative static semantics for higher-order functors that is also fully transparent. This se- mantics is based on a direct generalisation of a fragment of the existing Standard ML semantics. His ideas, which we believe have not received the attention they deserve, will be discussed in detail, reworked and extended to the full language in Chapter 5.

duction, which runs foul of the phase-distinction. The fact that XML type checking becomes undecidable in the presence of impredicative strong exis- tential types leads Harper and Mitchell to conclude that the extension of Standard ML with first-class modules is incompatible with decidable type checking. HML [HMM90], a further refinement of XML, is a predicative theory that preserves the phase distinction by adopting a non-standard for- mulation of dependent types.

One of the characteristics of Standard ML is that the static semantics of the language is defined, not in terms of the type syntax of the language, but with respect to an intermediate language of static semantic objects. During classification, type phrases are elaborated to semantic objects, and the classification of term phrases is done in terms of these semantic objects. This style of semantics can be criticised for two reasons. From a software engineering perspective, the classification of terms using semantic objects means that the type of a term cannot be reported to the programmer in the syntax of the language. In particular, this makes it more difficult to relate type errors to the source text of the program. It also raises the possibility that some terms have semantic objects that are not expressible in the syntax of the language, impeding simple approaches to separate compilation. From a proof engineering perspective, the classification of terms using semantic objects makes it difficult, and perhaps impossible, to prove the type sound- ness property of the language in terms of its type syntax. These properties are at odds with the syntactic nature of types and soundness proofs in type theory.

In this section, we define the Modules language. Given a Core language supporting a notion of definable types and terms, Modules provides a typed calculus for manipulating collections of Core type and term definitions. Al- though the choice of Core language is largely arbitrary, we do need to make some assumptions on its structure. These are stated as hypotheses. They are sufficiently weak to accommodate a wide variety of Core languages.

We can present the syntax of Modules as a collection of phrase classes de- fined by a grammar. Modules is an explicitly typed language. For this reason, it is convenient to group the phrase classes of both Modules and the Core according to whether they belong to the syntax of types or the syntax of terms. The concrete grammar of Core definable types and terms depends on the Core language in question:

Example 3.1.1 (Core-ML). In Core-ML, a definable type is a parameterised simple type describing a family of simple types. The kind of a definable type is the number of type parameters it expects. A value type, on the other hand, is a universally quantified simple type, reflecting the polymorphism of Core-ML value expressions. Finally, a value expression is either a function, a function parameter, a function application, or an occurrence of a Core-ML value defined within a Module.

Following Standard ML [MTH90, MTH96], the static semantics of Modules distinguishes between the type phrases of the language and the semantic objects they denote. As we shall see in Section 3.1.3, a type phrase is well- formed provided it denotes some semantic object, according to a denotation judgement. Similarly, a term phrase is well-typed provided it can be clas- sified by some semantic object, according to a classification judgement. In this section, we define the semantic objects of Modules.

In fact, in Standard ML [MTH90, MTH96], semantic structures are de- fined as finite maps on identifiers: we prefer to use an inductive definition to make it easier to prove properties about them. The difference is not sig- nificant. In particular, our retrieval functions and the soon to be defined enrichment relation (Definition 3.17), are immune to the order in which components appear, as in Standard ML.

(E-13) The structure body defines t as the denotation of d: the remainder of the body b is classified in the context extended with the assumption [t = d ]. The types generated by the entire phrase are just the types generated by classifying b. The component is added to the resulting structure.

(E-14) The structure body defines x as the value expression e. Provided e has value type v , the remainder of the body b is classified in the context extended with the assumption [x : v ]. The types generated by the entire phrase are just the type generated by classifying b. The type of x is recorded in the resulting structure.

(E-16) The rule is similar to Rule (E-15). The difference is that the defini- tion of X is local b, and does not become a component of the resulting structure. Note that the type variables generated locally by s are still recorded in the output set.

Remark 3.2.1 (Relating Type Phrases to their Denotations). Observe that the structure of corresponding syntactic and semantic objects is almost isomorphic. The essential difference between them is this: while simple type phrases may contain applications of type occurrence phrases, semantic simple types may not; instead, they allow for (well-kinded) applications of type names. It should come as no surprise that the denotation judgements merely replace type occurrences by expanding their denotations, preserving the structure of the original phrase in all other respects.

[Mac86, HM93, HMM90]. Indeed, the use of dependent types lingers on in the more recent type-theoretic alternatives to Standard ML proposed in [HL94, Ler94, Ler96b, Ler95, Lil97, SH96, HS97]. By contrast, in the following sections and the next chapter, we shall present evidence to suggest that dependent types play no discernible role in the semantics of Mini-SML. Since Mini-SML is merely a cut down version of Standard ML, we will conclude with the counter-claim that dependent types have no role in the semantics of Standard ML.

C. The judgement states that the term p has type o. We stress that o is a semantic object, not a syntactic type phrase. The classification judgements are clearly of a different nature from the denotation judgements discussed in the previous section: while a denotation judgement merely translates a syn- tactic type phrase to its semantic representation, a classification judgement relates a term to its type. Indeed, the denotation of a term phrase would be defined by the dynamic semantics of terms, which we have not presented. Classification judgements are thus instances of the familiar typing relations we encountered in our introduction to Type Theory (Section 2.2).

researchers in the area to propose that dependent types underly the type structure of Standard ML. However, by inspecting the static semantics of Mini-SML, we have found ample evidence to suggest that Mini-SML can be understood by relying only on the simpler type-theoretic notions of type parameterisation, type quantification and subtyping. Since Mini-SML is merely a cut down version of Standard ML, we can make the counter-claim that dependent types have no role in the static semantics of Standard ML. The generative classification judgements, however, do not sit nicely with our type-theoretic understanding of other aspects of the static semantics. In Chapter 4, we focus our attention on the generative judgements, and expose them as a particularly operational incarnation of existential quantification over types. By the end of that chapter, we hope to have discredited the claim that dependent types are necessary to explain the type structure of

Of course, if we rule out the redefinition of type identifiers already bound in the context, the need to distinguish them using type variables disappears. But this is a harsh restriction and goes against one of the main motivations for Modules: to provide a mechanism of name space control allowing com- ponent names to be reused within different modules. After all, outside of the structure body, the definitions are referred to by distinct phrases t and X.t.

The unsuccessful but sound classification of the same phrase. The example demonstrates how the generation of fresh types at each and every functor application preserves sound- ness. The denotations of Y.u and Z.u are correctly distin- guished. The offending subphrase is underlined.

Remark 4.3.2 (Motivating Groundedness). Although we will not need this property, we should also point out that insisting on ground functors ensures that the type of a functor application is uniquely determined by the type of the actual argument. As a counter-example, consider the Mini-SML functor J defined as:

Proof (Sketch). The proof follows easily by simultaneous induction on the rules defining the judgements. The first three clauses are Core language dependent, but must be proven together with the remaining statements in order deal with subphrases containing type and value occurrences.

In this chapter, we extend the Modules language of Chapter 4 to higher- order. Functors are given the same status that structures enjoy in Modules: they may be bound as components of structures, specified as functor ar- guments and returned as functor results. We will continue to refer to the first-order language collectively as Modules. Its generalisation will be called Higher-Order Modules. The Core language remains the same.

With the first implementation of N, which used the abstract Module Nat, we implicitly assumed that every value of type Nat.nat corresponded to a natural number. Since we are now using a proper subset of the integers, we should enforce the invariant that only positive integers are ever used as natu- ral numbers. Grouping the definitions of N, A and M into a single module and

The ability to define functors as structure components is crucial in this example. If we could only define functors at top-level, as in (first-order) Modules, we would be faced with only two design options, both of which are bad: we could either make the implementation of N.nat public, com- promising integrity but supporting efficient implementations of A and M, or private, preserving integrity, but rendering efficient implementations of A and M impossible.

While it is possible to do this, the practical ramifications for program- ming in the language are rather severe. To ensure data abstraction (one of the key motivations for using a modules language), programs have to be written in a fully functorised form. By this we mean the following. Sup- pose P [m] is a program with an occurrence of a module m, implementing the signature S, and we wish to ensure that the module expression m can be replaced by any other implementation m' matching S. Using an ab- straction, we can isolate m from its context P by writing P [m \ S]. If this program type-checks, then so does P [m' \ S]. If we remove generativity from the language then we can no longer accommodate the abstraction phrase. Without abstractions, we can only ensure the above property if P is writ- ten as the outermost application of a functor to m, i.e. if P has the form (functor(X : S)m'') [m]. Notice that if the application is not outermost, i.e. P is merely in the form P '[(functor(X : S)m'') [m]] for a non-empty program context P ', then the inner functor application may propagate the actual implementations of types in m that are meant to be abstract ac- cording to the signature S. With access to the concrete implementations, the outer context P ' can inadvertently make use of this information and violate the intended abstraction, preventing the replacement of m by m'. Unfortunately, insisting on fully functorised code leads to an unnatural and unintelligible coding style in which all abstract modules must be anticipated early on and imported as initial functor arguments, possibly at considerable distance from their point of use. As MacQueen [Mac86] rightly points out, this seriously impedes the incremental construction of programs, which is, after all, the main motivation for using a modules language. Notice, also,

Remark 5.2.1 (For Type Theorists). There is also a more theoretical moti- vation for generalising projections. If we want to prove a syntactic subject reduction result for Modules, then a key lemma we will need is that the type of a functor application is preserved when substituting the actual ar- gument for the formal argument of the functor. It is easy to see that the phrase class StrPath is not even syntactically closed under substitution of module phrases for identifiers, making it impossible to state this lemma, let alone prove it. By generalising projections from paths to projections from arbitrary module expressions, the syntax of Modules becomes closed under substitution, bringing us one step closer3 to proving syntactic subject reduc-

In short, we have generalised the first-order concepts of Definition 3.4 by allowing higher kinds, well-kinded applications of type names to types, and well-kinded type functions. As in the first-order setting, type names enter Core semantic objects when they arise as the denotations of type occurrences.

Unfortunately, Specification 5.12 cannot be taken as a proper (induc- tive) definition of the enrichment relations, since one of the relations we are specifying occurs in the antecedent (i.e. in a negative position) of the clause relating functors. However, it is relatively easy for a programmer to under- stand, and can be treated as a specification of the enrichment relations we will define. In the next section, we will give a proper inductive definition of enrichment and show that it satisfies Specification 5.12. For the moment, we can observe that the property expressed by the specification is obviously reflexive and transitive, forming a good basis for a subtyping relation.

As we discussed, Specification 5.12, although intuitive, cannot serve as a def- inition of the enrichment relations between structures, functors and modules. In this section, we define enrichment as a collection of inductive relations and show that they form a pre-order that is closed under realisation. Using these properties, we can then prove that our definition satisfies Specification which succumbs to rule induction and an appeal to Hypothesis 5.19. The stronger induction hypothesis corresponds to splitting the proof of transitivity into a simultaneous proof of transitivity for objects enriched by realisations of O', together with a proof of transitivity for objects enriching realisations of O.

The classification rules for structure bodies are the same as their first-order counterparts (cf. Section 4.2.1): Rules (H-12) and (H-13) merely generalise the first-order Rules (T-15) and (T-16) by catering for module definitions instead of structure definitions, but are otherwise unchanged.

The classification rules for module expressions deserve the most com- ment. Rules (H-15) and (H-16) subsume the role of the first-order Rules (T-19), (E-9) and (E-10), but also cater for generalised module projections. Rules (H-18) and (H-19) are new and formalise the applicative semantics of Section 5.2.2 for anonymous functors and module applications. The re- maining rules for encapsulating a structure body, curtailing a module by a signature and abstracting a module by a signature are unchanged from the first-order rules of Section 4.2.1, except that the last two now apply to both structures and functors.

In the preceding sections we focussed on producing an algorithm for match- ing. Although the algorithm is only sound and complete provided its inputs are ground and solvable, we can now turn to the static semantics of Higher- Order Modules to show that, whenever we need to invoke the algorithm, the matching problem will indeed be well-posed. To this end, we first de- fine a notion of ground contexts, ground existential modules, and solvable signatures.

In the previous section, we identified a programming style that supports separate compilation. As long as the programmer adheres to this style, she can separately type-check (and compile) the components of her program. The style is flexible enough for practical programming, because the syntax of signatures provides fine control over the abstraction of individual type components.

In Mini-SML, as in Standard ML, it is possible to redeclare an identifier which is already declared in the current context. This is useful, as it allows the same component name to be re-used within substructures and subsig- natures. The meaning of an identifier is resolved by static scoping: each occurrence of an identifier refers to its textually most recent declaration.

X.t in a context where the outermost definition of X is in scope. The range of v can only be specified as X.u in a context where the inner specification of X is in scope. Since the definition and specification of X both declare the same identifier, one must eclipse the other and they cannot be in scope at the same time. Because the actual definition of its v-component cannot be specified, the type of Y cannot be fully captured by a signature.

We will sketch another solution, that relies on distinguishing declarations by their binding depth. Observe that the example above is problematic only because the syntax of Mini-SML does not allow us to distinguish between different declarations of the same identifier, in this case the structure iden- tifier X. Every reference to an identifier is resolved by static scoping. In the semantics, this behaviour is ensured by defining contexts as finite maps. Extending a context by a new declaration overrides any previous declaration of that identifier.

Our alternative solution relies on defining contexts, not as finite-maps, but as lists of declarations. New declarations are added to the head of the list, without forgetting the effect of previous declarations. In this way, all declarations are preserved in the inverse order in which they were added.

Our technique is essentially a combination of named identifiers and de Bruijn [deB72] indices. Although terms written in pure de Bruijn notation are notoriously difficult for humans to read, our scheme seems more accept- able in realistic programming situations. First, we need only use an index when we need to refer to an eclipsed identifier (this rarely occurs in practice and can easily be avoided by disciplined programming). Second, the count- ing scheme is relative to identifiers of the same name: hence indices, when they need to be used, are small and manageable.

The aim of this section is to sketch a modules language that, by adopting the changes discussed in Sections 6.4.1 and 6.4.2, namely the introduction of indexed identifiers to prevent eclipsing, and the removal of abstractions to rule out anonymous abstract types, enjoys the following, informal property: base kind ? classifying definable types. Semantic structures and contexts no longer declare value components. The removal of the abstraction phrase means that existentially quantified types are no longer needed. Finally, instead of being finite maps, contexts are defined inductively as lists of dec- larations to support the use of indexed identifiers. For readability, contexts are defined to extend to the right2, so that the head of a context is its rightmost declaration, and its tail the context preceding that declaration.

Unfortunately, we cannot simply recover a representation by defining an inductive translation of the semantic object. Semantic objects arise by erasing the dependency of type phrases on module terms. Thus, given a arbitrary semantic object, it is typically impossible to infer the module terms that produced it.

The first operation we will need is a notion of substituting a module expression for a module identifier, and a definable type for a type identifier. This is the technical motivation for introducing de Bruijn indexed identifiers. The indices allow us to define substitution in a way that avoids the capture of free identifiers.

that remains unchanged. Note that if p is a declaration binding an iden- tifier, then we need to prevent the capture of any free occurrences of that identifier in m. This is achieved by lifting references to that identifier in m, before substituting in the scope of the declaration. If the bound identifier happens to be X itself, then we also need to ensure that the substitution does not affect occurrences bound by this declaration of X. This is achieved by incrementing the index n of the substitution before descending into the scope of the declaration.

However, from a theoretical perspective, the problems posed by eclipsed identifiers and anonymous abstract types mean that some module expres- sions may fail to possess syntactic representations of their types. We sketched a simplified (higher-order) Modules language that, by introducing indexed identifiers and removing the abstraction phrase, always admits syntactic representations. This property is captured by Theorem 6.13.

We should point out that the proof of Theorem 6.13 is constructive. In principle, the proof can be implemented in a compiler to report module types to the user as syntactic signatures, instead of semantic objects. Such an implementation can relieve the programmer of the burden of understanding semantic objects.

In Chapter 5 we promoted the status of functors by making them first-class citizens of the Modules language. Although much more expressive than first- order Modules, Higher-Order Modules still maintains a rigid stratification between Modules and the Core. The notion of computation at the level of Modules is very weak, consisting solely of functor application, to model the linking of modules, and projection, to provide access to the components of structures. This weakness reflects the historical intention that Modules should merely be used to express the architecture of Core programs: actual algorithms and data structures are expressed by Core values and types.

7.2 we present an example illustrating the elegance of first-class modules. In Section 7.3 we give another example illustrating the additional expressive power of first-class modules. In Section 7.4 we propose an alternative, intu- itively more natural elimination phrase for first-class modules but show that it is unsound. This violation of soundness highlights an important distinc-

tion between type abstraction at the level of Modules and its counterpart in the extended Core. In Section 7.4.1 we sketch a dynamic semantics for first- class modules and give a sketched proof that our static semantics is sound for this dynamic semantics. Section 7.5 closes with a brief assessment.

We adopt a different approach. We maintain the distinction between Core and Modules, but relax the stratification by enriching the Core lan- guage with a family of Core types, called package types, corresponding to first-class modules. A package type is introduced by encapsulating, or pack- ing, a module as a Core expression. A package type is eliminated by breaking an encapsulation, unpacking an expression as a module in the scope of an- other expression. Because package types are ordinary Core types, packages are first-class citizens of the Core. The introduction and elimination phrases allow computation to alternate between computation at the level of Mod- ules and computation at the level of the Core, without having to identify the notions of computation.

The advantage of preserving the distinction between Modules and the Core language is that we do not have to make an a priori commitment to a particular Core language in order to give the definition of Modules; the approach of amalgamating the Core and Modules into a single language, on the other hand, forces such a commitment from the outset. The advantage of distinguishing between Modules computation and Core computation is that each form of computation can be designed to satisfy different invariants. For instance, the invariant needed to support applicative functors, namely that the abstract types returned by a functor depend only on its type arguments and not the value of its term argument, is violated if we extend Modules computation directly with computational mechanisms such as conditional computation and recursion. On the other hand, these are precisely the sort of mechanisms that Core computation should provide. Applicative func- tors provide good support for programming with Higher-Order Modules; recursion and conditional computation are necessary in order to support realistic Core programs. By keeping Modules computation and Core com- putation separate, we can accommodate both. By contrast, although the amalgamated languages proposed by Harper and Lillibridge [HL94], Lillib- ridge [Lil97], and Harper and Stone [SH96, HS97] support higher-order func- tors, because there is only a single notion of computation, there is a trade-off between supporting either applicative functors or recursion and conditional computation. Since ruling out the latter is too severe a restriction, functors are not applicative.

From now on we will refer to a first-class module as a package, and its type as a package type. For concreteness, we will describe our extension of the Core with package types as an extension of a particular Core language, Core-ML. The technique should apply to other Core languages as well.

In Chapter 3, we were able give a presentation of Core-ML parameterised by an arbitrary Modules language, exploiting the fact that the points of contact between Core and Modules are few. This level of abstraction enabled us to generalise first-order Modules to Higher-Order Modules while keeping the definition of Core ML essentially fixed. Since the aim of this chapter is to extend Core-ML with first-class modules, we will need to make a stronger commitment to a particular modules language. For maximum generality, we will fix the modules language to be Higher-Order Modules.

age type <S>. For instance, in a call-by-value dynamic semantics, the phrase is evaluated by evaluating the module expression m and encapsulat- ing the resulting module value as a Core-ML value. The classification rule will ensure that the module expression matches the signature S, via some realisation. The signature determines the package type of the expression, and is also used to make the actual realisation of types in m abstract.

With package types, it is perfectly possible to make the actual realisation of an abstract type depend on the result of some Core-ML computation. In this way, package types strictly extend the class of types that can be defined in Core-ML with Higher-Order Modules alone. Since this feature is not illustrated by our implementation of the Sieve of Eratosthenes, we will give a different example exploiting it here.

entry. The function init x returns the initial value x of its entry, viewed as an array. Since (i mod 20) = 0, for any i, the function sub a i merely returns the value of the entire array a, viewed as an entry. Similarly, the function sub a i x updates the array a by simply returning the updated entry x, viewed as an array.

The functor ArraySucc represents an array of size 2n+1 as a pair of arrays of size 2n. Entries with even indices are stored in the first component of the pair. Entries with odd indices are stored in the second component of the pair. The function init a returns a pair of arrays of size 2n, initialised using the function A.init on arrays of size 2n. The function sub a i uses the parity of i to determine which component of the array to inspect, returning its (div i 2)-th entry using the function A.sub on arrays of size 2n. The function update a i x uses the parity of i to determine which component of the array to update, returning the pair of the unaltered component and the result of updating the other component using the function A.update on arrays of size 2n. It is easy to see that sub and update are of time-complexity O(n + 1), provided A.sub and A.update are of complexity O(n).

a realisation of P that can depend both on the static interpretation of the type variables in C and on the dynamic interpretation of the module and value identifiers in C. It is sound to treat a purely static realisation as if it had a vacuous dynamic dependency. This forward direction justifies the soundness of the package introduction rule. It is not sound to treat a possibly dynamic realisation as if it were purely static. This explains why the stronger elimination rule for unpack e as S is unsound.

Unfortunately, the addition of the phrase means that we can no longer prove the stronger property on module expressions used in the proof of Prop- erty 7.3. In particular, we can no longer establish the induction hypothesis needed to argue that the classification rule for applicative functors (Rule (H-18)) is sound.

The aim of this chapter is to design an algorithm that integrates Core- ML type inference with Modules type checking. The primary motivation for this work is that it paves the way for the correct integration of our proposals with existing implementations of Standard ML. Although we take care to present our algorithms with their intended correctness properties, the verification of these properties is left to future work.

The soundness and completeness of this algorithm is predicated on the existence of analogous type checkers for type and term phrases of the Core. As an hypothesis concerning an arbitrary Core language, this simplifying assumption is reasonable: a wide variety of strongly typed Core languages admit type checking algorithms of this kind. Unfortunately, as we shall see, Core-ML does not.

i.e. that we can get away with the simple-minded approach of interleav- ing Core type inference and Modules type checking, alternating between (a variant) of algorithm W and the type checker for Higher-Order Modules pre- sented in Chapter 5. Such an algorithm would invoke type inference when entering a Core expression, reverting back to type checking when entering a Modules subphrase, and so on. The following examples demonstrate that this approach cannot be made to work.

Here, the type of i is determined by a Core-ML phrase occurring within the type phrase (struct type u = int val x = + i 1 end).u. Clearly, the algorithm used to determine the denotation of a type phrase must also be modified to support type inference.

In the original algorithm, the first argument P merely records the set of type variables, other than R, allowed to occur free in the objects O and O'. In the generalised algorithm, Q subsumes the role of P . Like P , Q records the set of type variables, other than R, allowed to occur free in both objects O and O', by declaring these variables as parameters. However, it also sets the scene for any unification problems encountered during matching by declaring the role and scope of any simple type variable occurring free in O and O'.

The rules for inferring the denotations of Core-ML type phrases are straight- forward adaptations of their counterparts in the static semantic of Core-ML (cf. Section 3.2.3). Each rule has been altered to propagate the additional substitution from the output of one recursive call to the inputs of the next, and to return the appropriate denotation and composite substitution, tak- ing care to apply any intervening substitution to a previously computed component of the denotation.

Remark 8.4.1. Clearly, adding this rule means that the proofs of termina- tion, soundness and completeness of our unification and matching algorithms must now be carried out simultaneously. Even though it is easy to motivate and describe the extension, it is by no means obvious that the properties of the original, stratified, algorithms are preserved: we have tied the knot and made them mutually recursive.

For instance, one of the challenges is to devise a decreasing measure on unification problems that establishes termination. The measure tradition- ally used for first-order unification relies on the fact that the unification algorithm cannot introduce new meta-variables during its execution. This property no longer holds in the extended algorithm since it may indirectly invoke Rule (V-1) and, in Example 8.3.4, we demonstrated how this rule can increase the set of new meta-variables.

However, empirical evidence does support our claim of correctness. The algorithms, including the extension to First-Class Modules, are implemented in the prototype interpreter accompanying this thesis [Rus98a]. The algo- rithms behave correctly on a small but representative range of tests that includes all of the examples in this thesis.

The Standard ML Modules language has been both the subject and the source of much of the recent research into the type-theoretic foundations of module languages. Despite these efforts, a proper type-theoretic under- standing of the static semantics of Modules has not emerged. Such an un- derstanding offers two potential benefits: Type Theory provides us with a rational basis for analysing existing features of the language, and for syn- thesising new features by generalisation.

Thus we undertook the work in this thesis with two main objectives. The first was to provide a better, more type-theoretic formulation of the existing static semantics of Modules. The second was to use this formulation as the rational basis for designing proper extensions of Modules.

In Chapter 5, we extended the Modules language of Chapter 3 to higher- order, using the revised semantics in Chapter 4 as our starting point. Func- tors were given the status previously enjoyed only by structures: they could now be defined as components of structures, specified as functor arguments and returned as functor results. We were able to present the semantics of Higher-Order Modules as a natural generalisation of the definitions un- derlying the first-order language of the preceding chapters. The crucial ideas of introducing higher-order realisations and of generalising the en- richment relation to functors, by combining polymorphic subsumption with contravariant enrichment, were adapted and reworked from the original pro- posals of Biswas [Bis95]. The applicative semantics for functor generativity was inspired by our own results in Chapter 4. We also addressed the prac- tical concern of type-checking Modules by providing, and proving correct, a sound and complete algorithm for signature matching. The algorithm is similar to, but simpler than, the one proposed by Biswas.

In Chapter 7 we turned our attention to a particular Core language, Core-ML, and relaxed the stratification between Core and Modules. We obtained a language with first-class modules and gave examples of programs exploiting them. Our approach is novel in maintaining the distinction be- tween Core and Modules. Instead of amalgamating the features of both in a single language, we provide constructs for packing Module values as Core values and opening Core values as Module values, allowing programs to al- ternate between Modules and Core level computation. Our ability to define a simple notion of first-class module directly contradicts the claims made by Harper and Mitchell [HM93]: their analysis implies that Standard ML is incompatible with first-class modules.

In our semantics, the value component is still available. Of course, in this example, the value component is useless because there are no operations that can manipulate this value. However, it is easy to construct larger examples where the result is a full-blown abstract data type together with useful operations.

In Chapter 5 we gave a semantics for applicative functors. The terminology is borrowed from Leroy, who has proposed an applicative version of his own module calculus [Ler95]. Although similar in spirit, the two notions of applicative functor are subtly different.

notation of a signature that is qualified by structure sharing constraints. However, this problem is very similar to the one encountered in determin- ing the principal denotation of a signature that is qualified by type sharing constraints. In the latter case, it is known that the problem of ensuring principality becomes trivial if type sharing constraints are abandoned in favour of definitional type specifications in signatures. It is very plausible that structure sharing constraints may also be replaced by a simpler form of specification that eliminates the principality problem.

the presentation in earlier chapters to avoid introducing new keywords and grammatical ambiguities. More significantly, it has forced me to generalise the semantics of higher-order functors described in Chapter 5 to accommo- date standard generative functors as well as non-standard applicative ones. I have also taken the opportunity to revise the semantics of first-class mod- ules slightly, making their use more convenient for programmers, especially those working in interactive sessions [Rus00a, Rus00b]. Recursive modules are an entirely new extension, built on the foundations of this thesis, but introduced only briefly here; see [Rus01] for a complete formalisation in the spirit of Mini-SML.

In Moscow ML, the types of functors are specified using functor signatures. Similar to the distinction between generative and applicative functor expres- sions, functor signatures may be opaque or transparent. Whether a functor signature is opaque or transparent affects the interpretation of any datatype or opaque type specifications in its range signature.

All that remains is to extend the definition of the enrichment relation for higher-order Mini-SML to cater for our generalised notion of semantic functor with existentially quantified range. This, too, is straightforward. Informally, we modify the relevant clauses of Specification 5.12 as follows:

The local binding has no run-time effect and is only elaborated at compile- time for its type information. This new phrase is nothing more than a syn- tactic variant of the generalised dot notation for types, m.t, introduced in Section 5.2.3, but fits better with the concrete grammar of SML. Moscow ML does not add any new syntax for generalised projections of value or module components because these can already be expressed using existing constructs.

Note that the restriction only applies to functor bodies, not top-level structures or their substructures, which may still contain package-eliminating module bindings. Recalling the discussion in Sections 7.4 and 7.4.1, intu- itively, the reason it is sound to admit top-level package-elimination is that any existential types introduced at top-level will never be skolemised on the type parameters of an outer functor argument (since there can be no such outer functor). For this reason, it is perfectly legal to allow the realisations of these variables to depend on the dynamic as well as the static interpretation of the context.

Here, X is a forward declaration of a structure implementing the body of the signature that allows the specification of Even.t to refer to the type X.Odd.t before it has been fully specified. In this new form of signature expression, rec(X : S)S', X is a forward declared structure, S is its signature, and S' is the body of the signature, which may refer to its own components via X. In a recursive signature, the body of the signature must match the forward declaration and specify an implementation for any opaque types or datatypes declared within the forward specification.

In SML, functors and signatures may only be declared at top-level, and structures may only be declared at top-level and within structures. None of these may be declared within Core let-expressions. Moscow ML removes these restrictions so that functors, signatures and structures may be declared anywhere, which is particularly useful when programming with first-class modules.

In SML, every parameterised type definition, and every type scheme occurring within a signature, must be closed: it must not mention any (simple) type variables that are not explicitly listed as type parameters. Moscow ML does not impose this restriction, and allows free simple type variables, provided they are (explicitly or implicitly) bound in an enclosing scope. Again, this is useful when programming with first-class modules.

