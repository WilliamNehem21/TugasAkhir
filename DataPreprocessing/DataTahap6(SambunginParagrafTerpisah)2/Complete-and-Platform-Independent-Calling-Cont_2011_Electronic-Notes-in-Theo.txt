Calling context profiling collects statistics separately for each calling context. Complete calling context profiles that faithfully represent overall program execution are important for a sound analysis of program behavior, which in turn is important for program understanding, reverse engineering, and workload charac- terization. Many existing calling context profilers for Java rely on sampling or on incomplete instrumentation techniques, yielding incomplete profiles; others rely on Java Virtual Machine (JVM) modifications or work only with one specific JVM, thus compromising portability. In this paper we present a new calling con- text profiler for Java that reconciles completeness of the collected profiles and full compatibility with any standard JVM. In order to reduce measurement perturbation, our profiler collects platform-independent dynamic metrics, such as the number of method invocations and the number of executed bytecodes. In contrast to prevailing calling context profilers, our tool is able to distinguish between multiple call sites in a method and supports selective profiling of (the dynamic extent of) certain methods. We have evaluate the overhead introduced by our profiler with standard Java and Scala benchmarks on a range of different JVMs.

Unlike a context-insensitive DCG, a CCT in principle is capable of capturing the complete context of a call. Still, CCTs generated by state-of-the-art profilers [17] are missing one key bit of information present in the well-known labelled variant of DCGs: information about the individual site at which a call is made. In other words, while keeping track of numerous methods in entire call chains, many calling context profilers are unable to distinguish between multiple call sites within a single method.

There are several variations of the CCT supported by our tool. For instance, calls to the same method from different call sites in a caller may be represented by the same node or by different nodes in the CCT. Moreover, in the case of recursion, the depth of the CCT may be unbounded, representing each recursive call to a method by a separate CCT node, or alternatively recursive calls might be stored in the same node, limiting the depth of the CCT and introducing back-edges into the CCT [1].

In this section we describe the design and the architecture of our tool. First, Sec- tion 3.1 discusses both the design and the weaknesses of a previous version of the tool. Next, Section 3.2 presents our new design implemented in the JP2 profiler. Finally, Section 3.3 explains how JP2 deals with native methods.

JP2 provides a mechanism to temporarily disable the execution of instrumenta- tion code for each thread. Assume that instrumentation code itself uses methods from the Java class library, which has already been instrumented. This will cause infinite recursions. To sidestep this issue, JP2 uses code duplication within method bodies in order to keep the non-instrumented bytecode version together with the instrumented code, and inserts a conditional upon the method entry in order to select the version to be executed. [16]

The Probabilistic Calling Context (PCC) approach due to Bond et al. [9] con- tinuously maintains a probabilistically unique value representing the current calling context. As this value can be efficiently computed, the approach causes rather low overhead, if supported by a customized virtual machine. But due to its probabilistic nature PPC does not always produce completely accurate profiles. Recent research, however, has shown that is often possible to reconstruct a significant amount of context offline [8].

In this paper we presented JP2, a new tool for complete platform-independent calling context profiling. JP2 relies on bytecode transformation technique in order to create CCTs with platform-independent dynamic metrics, such as the number of method invocations and the number of executed bytecodes. In contrast to prevailing profilers, JP2 is able to distinguish between multiple call sites in a method and supports selective profiling of certain methods. We have evaluated the overhead caused by JP2 with standard Java and Scala benchmarks on a range of different JVMs.

