Analysis of convex polyhedra using abstract interpretation is a common and powerful program analysis technique to discover linear relationships among variables in a program. However, the classical way of performing polyhedral analysis does not model the fact that values typically are stored as fixed-size binary strings and usually have a wrap-around semantics in the case of overflows. In embedded systems where 16-bit or even 8-bit processors are used, wrapping behaviour may even be used intentionally. Thus, to accurately and correctly analyse such systems, the wrapping has to be modelled.

Section 2 contains preliminaries to our approach, explaining classical polyhedral analysis and wrapping of polyhedra. We show in Section 3 a motivational example of our method and how it differs from other methods. In Section 4 we detail our approach to a bounded polyhedral analysis. Section 5 discusses our approach to widening, which is the core of the method. Finally, we conclude in Section 6.

In this example, our approach takes a few more iterations before stabilisation, but this result, while still sound w.r.t. wrap-arounds, is more precise than the previous approach. In particular, notice that in P BD(3) we have that x remains zero, but N can be any number between 0 and 255 (soundness), and we have kept the valuable relation between x and N in P BD(2),P BD(4) and P BD(5), as the polyhedra

In classical analysis, a polyhedron may become unbounded in three cases: First, in the initial program point, where nothing is known about the program variables. Second, any non-linear assignment drops any information about a variable, leaving the polyhedron unbounded in the direction of that variable. Third, widening often produces an unbounded polyhedron.

For a program containing cycles, widening is necessary to ensure termination. In classical abstract interpretation, the widening is usually inserted immediately after the loop merge points. Let ploop be a program point immediately succeeding a loop merge node (for example edge 2 for program L). Then, the classical polyhedral analysis defines:

The standard widening operation, as mentioned, often makes polyhedra unbounded. However, with the help of limited widening it might be possible to intersect the result with some finite constraints. Our idea is to use widening in such a way that it is always possible to intersect the result with a fully bounded polyhedron.

That is, the result of the widening is intersected with all constraints in C which hold in both P and Q. It can be shown that this is a widening operation for any set of constraints C. The set C is typically selected strategically for each program. Our idea is to use the range constraints Y of a program as the set C in limited widening. Our goal is to be able to intersect with all range constraints, to make the polyhedron fully bounded. To avoid wrapping variables more than necessary, with the range constraints and to reduce unnecessary wrappings. To this end, we place the widening point at the conditionals where wrapping must be done anyway. We do this in a way so that we still have exactly one widening per cycle in the flow chart. This means that we replace

Proposition 5.1 proves that all variables are bounded after widening. This to- gether with the previous steps to make sure a polyhedron is bounded results in an analysis where each polyhedron is bounded. On a final note, it is possible to improve the set X in Proposition 5.1, by observing that only the variables involved in constraints that are removed by the widening operator need to be wrapped, since they are the only ones being affected by the widening. However, we used X as the set of all variables to simplify the proof.

