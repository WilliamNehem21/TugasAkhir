In this paper, we put forward the idea of outsourcing also the access control enforcement at the third party. Our approach combines cryptography together with authorizations, thus enforcing access control via selective encryption. The paper describes authorizations management investigating their specification and representation as well as their enforcement in a dynamic scenario.

Although the database outsourced scenario has been intensively studied in the last few years, the access control issue in such a scenario has never been considered. The existing access control mechanisms, designed for distributed applications, oper- ate on client-server architectures according to the basic assumption that the server is in charge of defining and enforcing access control. In our scenario this assump- tion is no more applicable, since the server does not know the access control policy defined by the data owner. Current proposals for querying encrypted outsourced databases assume that clients have complete access to the query result and therefore use a single key for encrypting the whole outsourced database. Access control can therefore be enforced only by involving the data owner, who has to filter out from the query result the tuples that a client cannot access. Obviously, this solution is too expensive and not applicable in a real-world scenario, which demands for selective access by different users or applications.

In this paper, we address the problem of enforcing access control by exploiting data encryption. The idea is then to use different encryption keys for different data as proposed, for example, for XML documents [10]. To access such encrypted data, users have to decrypt them by using the appropriate key. If different users know different keys, they have different access rights.

The remainder of this paper is organized as follows. Section 2 introduces the main concepts of access control and presents our selective encryption solution. Section 3 describes the algorithm we propose to efficiently enforce access control through selective encryption in the specific scenario. Section 4 illustrates how changes in the access control policies can be efficiently managed. Finally, Section 5 contains our conclusions.

Given the access matrix representing the policies to enforce, it is first of all nec- essary to select which vertices should be part of TUH. In particular, since each tuple t is encrypted with the key of the vertex representing aclt , all vertices correspond- ing to resource acls have to be part of the tree. The set of these vertices, called material, is denoted by M. This set contains also the empty set vertex that will be the root vertex of the tree.

Let us now consider the case of a deletion of a vertex in TUH. Whenever a leaf vertex becomes non material, it is convenient to remove it from TUH because it is no more useful and causes just a waste of space for its key storage. In this case, it is sufficient to remove the vertex from the hierarchy and to notify all users knowing the corresponding key that the vertex has been deleted. For consistency with the algorithm that builds TUH, also when a vertex with only a child becomes non material, it should be removed from the tree. However, this deletion is quite

When the data owner inserts a new tuple t in the database, she has to specify its aclt because, on the basis of aclt , it is then possible to individuate the key that will be used to encrypt t (i.e., the key associated with the vertex corresponding to aclt ). Two cases can occur, depending on whether TUH contains such a vertex or not. In the first case, it is sufficient to encrypt t using kaclt , while in the second case it is first necessary to insert a new vertex representing aclt . Note that in both cases aclt becomes a material vertex.

As previously noted, TUH updates result in a lower quality hierarchy than re- building the tree. This is also due to the fact that non material vertices are inserted in the tree during the initial construction phase only. To mitigate such disadvan- tages, we propose to adopt a preallocation strategy. According to this strategy, a

To demonstrate that our problem is at least as complex as the 3-SAT, we need to show that, if there exists an algorithm solving the minimum TUH problem, this algorithm solves also 3-SAT. To this purpose, we first show that each instance of 3-SAT can be mapped in an instance of minimum TUH. Given a formula f with variables x1, x2 ... xn and clauses c1, c2,... cl, we build M and NM sets as follows.

