All source code modifications are performed automatically before executing the code. A step by step presentation of the evaluation of selected data structures or functions in a separate window can help beginners to understand the lazy execution semantics of Curry. This presentation provides another advantage: all views are implemented by independent system processes which may even be distributed on multiple computers to avoid a slow-down or shortage of memory of observed exe- cutions. Finally, observation sessions can be saved and reloaded when debugging is necessary again. The tool is implemented in Curry using libraries for GUI pro- gramming [10,11] and meta programming which are available for the Curry system PAKCS [6].

The function observe behaves as an identity on its third argument. Additionally, it generates, as a hidden side effect, a trail file representing the evaluated part of the observed data. To distinguish different observations from each other, observe takes a label as its second argument. After program termination (including run- time errors and aborts), all observations are presented to the user, with respect to their different labels. Finally, observe demands an observer as its first argument

The explicit annotation of the observer for each type is necessary, since Curry, in contrast to Haskell, does not provide type classes which hide these observers from the user in HOOD. However, there is also a benefit of these explicit annotations. It is possible to use different observers for the same type which allows selective masking of substructures in large observed data structures, e.g. by the predefined observer oOpaque [2] which presents every data structure by the symbol #.

In this observation, it is also possible to detect the bug and in practice it is often easier to find bugs by observing functions. However, in larger programs it is still an iteration of adding and removing observers to find the location of a bug, similar to the debugging session sketch for the sublists example. A tool which supports the programmer in adding and removing observers is desired.

The most problematic part of using COOSY (especially for beginners) is the defini- tion of observers for newly introduced data types, although COOSY provides useful abstractions for this task. For every user defined data type, corresponding observers have to be defined to observe values of this type. Our tool provides an automatic derivation of these observers, not only for defined data types in the program, but also for data types which are imported from other modules. We sketch the idea by means of an example. Consider the data type for natural numbers:

In this way, generic observers for all data structures defined in the program are generated and added automatically to the program. These observers are used for observations of functions and expressions over values of this type. This method is applied to the imported data types, so that for all imported modules the data types observers can be generated and automatically imported to the program.

Sometimes it is not sufficient to observe functions defined in a program. Observa- tions of subexpressions in the right-hand sides of rules can become necessary to find a bug. A user can also select (sub-)expressions from right-hand sides of function definitions. For this purpose iCODE provides a tree representation of the whole program, in which the user can select arbitrary (sub-)expressions of the program to be observed. Corresponding calls of observe are automatically added as presented in Section 2. The type of each selected expression is inferred and a corresponding observer is generated.

iCODE also automatically generates labels for the observers which helps the pro- grammer to later identify the observations. Top-level functions are simply labeled with their name. Local functions are labeled with a colon-separated list of function names leading to the declaration of the observed function. Finally, expressions are labeled with the corresponding function name and a String representation of the selected expression.

iCODE supports adding observations to different modules of a project. When the user selects functions or expressions of a module to be observed a new module is generated which contains the observer calls. Since observer calls in (even indirectly) imported modules must also be executed, iCODE can check for each imported module whether an observer version is available and uses this for execution.

With the advance of modern computer technology, distributed programming is be- coming more and more popular. Instead of storing huge amounts of data redun- dantly in many places, we use a client/server architecture, and typically, we have many clients connected to many servers. For the communication between a client and a server in Curry, TCP communication can be used. In this section we briefly review the client/server architecture of iCODE for showing the observation steps in separate viewing tools.

Originally in COOSY, each time the computation made progress the information about observed values was recorded in a separate trace file as events. There are two kinds of events to distinguish unevaluated expressions from failed or non-terminated computations: Demand and Value. A demand event shows that a value is needed for the computation. A value event shows that the computation of a value has succeeded [2]. These events were shown with a textual visualization in the viewer of COOSY.

In Section 2 we have seen that for each observed function/expression a label is needed to match the observed values with the observed expressions. These labels group the progress of the execution for each observed expression in separate trace windows. Each of these windows which is named with the corresponding label receives messages from the main window through a socket.

In COOSY the generation of the observations for each observation label con- tained in the trace file works in a bottom-up manner. For a continuous update of observed data terms this algorithm is of no use, since in each step the whole observed data structure has to be re-constructed. We need a top-down algorithm which allows extensions in all possible leaf positions of the presented data structure. For instance, during the computation non-evaluated arguments (represented by un- derscores) may flip into values, but values within a data structure will not change anymore. However, we must consider the non-determinism within Curry by which values may later be related to different non-deterministic computations. Our new representation of events is stored in the following dynamic predicate:

In Section 5 we have seen that events are sent via a socket connection from the main window of iCODE to each trace window. Each event contains a logical parent showing in which order values are constructed. Hence, within one non-deterministic branching the index list [Index] is extended in its head position whenever the evaluation tree is extended, usually in an Open leaf.

The next incoming event is a value event with the logical parent 5. This index does not occur in the head position of the index list. Hence, we detect a non- deterministic computation. The observed value of this computation shares the nodes with indices 0 to 5 with the first tree. Hence we copy this part and extend it with the new event 10, which means the same function is called with another argument

In some cases programmers prefer to follow the order of program execution instead of observing functions to see the program behavior during the execution. Furthermore, knowing which parts of the program have been executed is an interesting information for the programmer, because this restricts the possible locations of a bug to the executed parts. Observers should only be added to executed code. iCODE provides such a feature which can also be useful for testing small separate functions of a program and focus on a small environment of the program for being observed.

markLineNumber behaves as an identity function on. Executing this function, the first and second argument are sent as a message from the executed application to the main window of iCODE (Section 5). In the main window process, the message initiates a marking of the corresponding position of the actual expression in the viewer with the ability of backward and forward stepping on the marked expressions. This technique is a light-weight implementation of program slicing as defined in [3]. Furthermore, it will be interesting to investigate how this kind of slicing can be used for improving debugging like done in [4].

the extension). On the other hand, having the whole program as a data structure in iCODE, some more global information like in Hat can be computed (like the line information discussed in Section 6). However, iCODE is supposed to stay a light-weight and easy to use debugger.

Distributed programming helps us to send the information about the observed expressions through a socket and to show each computed expression in a trace win- dow in parallel. The trace windows separate the display of observation steps for selected expressions and offer an understandable result for programmers. The infor- mation about observed expressions/functions is collected in each trace window and the ability of going forward and backward on the collected information is provided for the programmer.

The programmer does not need to add annotations to her/his program to observe the desired expressions. These annotations are added automatically by iCODE. A tree containing all program expressions (i.e. global and local functions, patterns, variables and all subexpressions) is provided for the programmer. Each selection in this tree activates iCODE to write the annotations in an extra file automatically, without changing the original program. Also larger projects consisting of different modules are supported.

For future work, we want to improve observations of polymorphic functions by generating specialized versions for each usage of observed polymorphic functions. Furthermore, we plan to investigate, how our tool can also be used as a platform for other development tools for Curry, like refactoring, test environment and program analysis. Another possible future work could result from the fact that our tool holds a lot of meta information about debugged programs. Hence, it could be possible to add observations to every/many program functions automatically and derive information about the connection between different observations which may improve debugging.

M. Wallace, O. Chitil, T. Brehm and C. Runciman. Multiple-View Tracing for Haskell: a New Hat. In Ralf Hinze, editor, Preliminary Proceedings of the 2001 ACM SIGPLAN Haskell Workshop, pages 151170, Firenze, Italy, September 2001. Universiteit Utrecht UU-CS-2001-23. Final proceedings to appear in ENTCS 59(2).

