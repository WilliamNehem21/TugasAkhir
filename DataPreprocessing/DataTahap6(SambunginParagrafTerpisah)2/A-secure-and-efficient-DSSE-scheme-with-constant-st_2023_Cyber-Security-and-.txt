Based on RC-II, we propose a scheme with poor forward update privacy and backward security.Both strong and poor forward up- date privacy ensures the separation of updated data from the index in the CSP, even during the next search. To obtain a good tradeoff between security and performanc, our scheme meets poor forward update privacy. Our scheme can also resist replay attack.

data as the update token. Send the file and the corresponding update token to the server. The CSP uses the update token to update the index on the cloud, completing an update operation. A formal description of the algorithm is given below.

DSSE generally includes 7 algorithms (Setup, KeyGen, Enc, SrchTo- kenGen, Search, UpTokenGen, Update). DSSE typically have two actors, the data owner and the CSP. The data owner sends encrypted data and index to the CSP. When the owner wants to retrieve the documents con- taining a keyword, the owner sends a search token containing the key- word information to the CSP. The CSP uses the search token to traverse the index and return the search results that meet the keyword. when the owner needs to update the data, he generates the index of the updated

In our index structure, we design the search control node to achieve user control of retrieval operations. In search phase, the user can choose to retrieve only the most recently updated chain, and the CSP cannot re- late it to other index data, which guarantees weak forward update pri- vacy. For backward security, we use a symmetric encryption algorithm that has proven to be secure. By symmetrically encrypting the identifier information during the update phase, we ensure that the index will not reveal any information even if it is deleted.

In order to monitor the malicious behavior of the three entities in this system, we use the set hash in our protocol. Specifically, malicious behavior detection from device and service peers relies on the meta- data they upload on the chain, while the monitoring of malicious be- havior in CSP depends on the validation data stored in the service peer. We hold the opinion that if the set hash we use is secure enough, the probability that an adversary returns an error and passes validation is negligible. Our scheme can be performed correctly, and even if there is malicious behavior, we can detect it and take appropriate measures to punish them.

In order to demonstrate the applicability of this scheme to smart devices, we evaluate our scheme and show the advantages of this scheme compared with other schemes. The experiments are performed in Python 3. We use HMAC to realize the pseudo-random function. The set hash function was implemented in SHA-256. The symmetric encryp- tion scheme we used for encrypting identifier is AES. The computer is Intel(R) Core (TM) i5-10210U and 8GB of RAM that running on win- dows 11. We will prove the reliability of this scheme applied to smart devices from storage cost, computation cost and communication cost respectively.

well as the number of sub-keywords. In our experiment, we set the num- ber of sub-keywords to 1 which means that their local storage overhead will be even heavier in practical. He et al. [13] proposed a fish-bone structure which decreases the local storage costs to a constant. But their schemes suffer from the maximum number of updates. Besides, client need to provide more computing resources under their protocol(which will be explained in Section 8.3).

Sai Ji received his BS degree from the Nanjing University of Information Science & Technology (NUIST), Nanjing, China, in 1999, and his MS degree from the Nanjing Aeronautics and Astronautics University (NUAA), Nanjing, China, in 2006. He works as an Associate Professor at the NUIST. His research in- terests are in the areas of computer measurement and control, structural health monitoring, and WSNs. He has published more than 20 journal/conference papers. He is a Principle In- vestigator of three NSF projects.

