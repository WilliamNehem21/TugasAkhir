that enjoys subject reduction, type uniqueness, and decidability of typing. Then we apply a clas- sical type-erasing function to RhoF, to obtain an untyped Rho-calculus `a la Curry (uRhoF). The related type inference system is isomorphic to RhoF and enjoys subject reduction. Both RhoF and uRhoF systems can be considered as minimal calculi for polymorphic rewriting-based program- ming languages. We discuss the possibility of a logic existing underneath the type systems via a

is associated with an action; once an instance of a pattern is recognized, the corresponding term is rewritten to a new one. Another advantage of rewriting- based languages (in contrast with ML or Haskell) is the ability to handle non- determinism by means of a collection of results: pattern-matching needs not to be exclusive, i.e. multiple branches can be taken simultaneously. An empty collection of results represents a matching failure, a singleton represents a

One of the most commonly used models of computation, the Lambda- calculus, uses only trivial pattern-matching. This calculus has recently been extended, initially for programming concerns, either by introducing patterns in Lambda-calculi [31,42], or by introducing matching and rewrite rules in functional languages. More concerned with extending logics, Stehr has studied a Calculus of Constructions enhanced with rewriting logic [32].

in a uniform way. Its abstraction mechanism is based on the rewrite rule formation: in a term of the form P d A, one abstracts over the pattern P . Note that the Rewriting-calculus is a generalization of the Lambda-calculus, since we get the Lambda-calculus back if every pattern P is a variable.

