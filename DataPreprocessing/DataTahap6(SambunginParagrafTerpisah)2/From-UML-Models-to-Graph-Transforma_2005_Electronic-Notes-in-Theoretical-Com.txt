Today the Unified Modeling Language (UML) is widely accepted as a standard for modeling object-oriented software systems. UML is a graphical language providing different diagram types for describing particular aspects of software artifacts. The syntax of these diagrams is defined by means of a metamodel in [12], notated as class diagrams. However this approach is semi-formal, since the class diagram itself is defined in a cyclic way by the metamodel.

Furthermore the semantics of UML diagrams is only expressed in natural lan- guage. The graphical notation is enhanced by the Object Constraint Language (OCL), which permits to formulate constraints in a textual way that cannot be expressed by the diagrams. OCL is again semi-formally defined in [12]. A formal syntax and semantics for UML class diagrams as well as OCL has been introduced in [13], which is also included in the accepted OCL 2.0 OMG submission [1].

In this paper we present an integrated formal semantics not only for class diagrams but for further basic diagram types: use case, object, statechart and interaction diagrams. We stick to UML 1.5 but UML 2.0 likewise includes the UML concepts covered by us, albeit some details and the naming have changed in some cases. In particular, collaboration diagrams are called com- munication diagrams in UML 2.0. The new integrated semantics is formalized employing the concepts of graph transformation, which is a well-developed field (cf. [15], [4], [5]). We are not aware of a formal approach handling this collection of UML diagrams, in particular the formal incorporation of use cases is new (in [17] use cases are described precisely by so-called operation schemas including OCL pre- and postconditions but the connection to other UML diagrams is left open).

Our approach provides a framework for an automatic translation of a UML model into a graph transformation system. The UML model may consist of the mentioned diagram types and can include OCL expressions. The graph transformation system comprises a set of graph transformation rules and a so-called working graph, hence called system state graph. As the name may suggest, the system state graph represents the current state of the modeled system. The graph transformation rules modify this state step by step, thus simulating a run through the modeled system.

In contrast to most work on graph transformation, we employ an enhanced approach, which allows OCL expressions in rules. We combine the advantages of two worlds: the operational graph transformation world and the logic- based OCL world. On the one hand graph transformations allow to handle complex issues by depicting and modifying them using more intuitive graphical representations. On the other hand, although it is theoretically possible to represent every aspect in the graphical structure, the additional power to use OCL as a textual notation leads to the benefit of even more compact graphs in most cases. In our approach OCL expressions navigating in the current system state are used as application conditions, which decide whether a certain rule may or may not be applied. Furthermore OCL is used in attribute expressions in the right-hand side of graph transformation rules. The modeler can also utilize OCL for querying the current state of the modeled system.

Our approach provides an integrated formal semantics for a large part of UML. As no formal semantics is given for the UML, our approach relies on a number of assumptions on how the diagrams could be used in practise and integrated in a useful way. The precise semantics is a solid basis for further work. For example, the representation of a UML model as a graph transform- ation system is used here to validate the system before actually implementing it. This is done by comparing system behavior with the expectations of the modeler. The benefit of using graph transformations in this context obviously is the close proximity of the simulated system run to the actual model. This proximity allows for fewer assumptions regarding the semantics of the model as for instance code generators have to make. It also allows for an easier hand- ling of future extensions and changes regarding these assumptions, since only the structure of the generated rules has to be changed in these cases. Cur- rently, a prototypic validation system is being implemented for our approach which generates the graph transformation rules for a given model and allows to interactively execute and visualize the modeled system. Our approach can be used by a modeler in an early stage of a software development process in order to get a flair for the newly designed system.

The structure of the rest of this paper is as follows. In the next section the covered UML features of the model are presented and explained using a simple example. Section 3 deals with the detailed description of the system state concept. The translation of the model into a graph transformation sys- tem is presented in Sect. 4 by example. The fundamental architecture of the prototypic implementation is presented in Sect. 5. The paper closes with a

Use cases are likewise realized by interaction diagrams. A use case resp. its realization states which operations are called by an actor and in which order this is done. Statechart diagrams specify the order in which operations on an object may be executed. The kind of statechart diagram we support are so-called protocol machines, i.e., statechart diagrams which do not need actions on transitions. Object diagrams are used to specify the system state to start the evolution with and to represent part of the current state of the system.

or which call an operation of a class. For each class there can be one state machine specified in a statechart diagram. The object diagram instantiates the class diagram. We illustrate the usage and interplay of the diagrams by an example UML model for a digital clock. This a rather simple example; a more complex model fitting our approach can be found at [20].

To briefly illustrate the concept of a process in this context let us consider an OpCallProcess by example. An OpCallProcess is associated with an opera- tion of a class. Let us now assume that an interaction diagram defines that the effect of this operation is exactly to call another operation. Then there would be a rule creating another process node, that is associated with the operation to be called. The system state also includes the information that the first process is the activator of the second one.

A graph transformation system consists of a working graph and a set of rules which rewrite parts of this graph when applied. We use the algebraic graph model for attributed, directed and labeled graphs and their transformations (cf. e.g. [11]). Roughly speaking a graph transformation rule consists of a left- hand side and a right-hand side. The left-hand side specifies the part of the working graph that has to be changed and the right-hand side specifies these changes. Nodes that should be preserved during the rewriting have to occur in both sides of the rule. Nodes that only occur in the left-hand side are deleted while nodes that only occur in the right-hand side are added to the working

The initial system state does not contain any processes, i.e., there is no oper- ation that is called and waiting to be executed. This is what the use cases are needed for: For every use case we construct a rule that adds an OpCallProcess node with local variables for holding the arguments where necessary.

Currently a prototype for the concepts discussed in this paper is being imple- mented. The goal of this prototype is to visualize the evolution of the system state. When provided with a model and an initial object diagram, the pro- totype automatically generates the graph transformation rules and the initial system state graph. A graphical user interface then permits the user to view the evolution of the system state step by step and to examine the current state by querying it using OCL.

For this reason the prototype must be able to perform graph transform- ations as well as evaluate OCL expressions. Instead of implementing a new tool for these purposes, we chose to combine two well established tools. The graph transformation part is done by AGG [16] and the evaluation of OCL expressions is performed by the USE tool [14].

The model and the initial object diagram are specified in USE-like syntax. The USE tool had to be extended in order to be able to read collaboration, use case, and statechart diagram definitions and to represent their features in its internal model representation. Furthermore the possibility to evaluate the oclInState operation had to be added to the OCL expression interpreter.

the Grammar. This core class stores the generated graph transformation rules and the system state and deals with the actual rule application. As discussed earlier, a rule may contain OCL expressions as application conditions or as a means to calculate new attribute values. Since AGG is not able to handle OCL expressions, these rules cannot exactly be AGG rules. For this reason a system state rule has been developed, which extends the functionality of an AGG rule. The expressions calculating new attribute values are stored as constant string values in the corresponding attributes of the AGG nodes of the AGG rule, while the application conditions are stored directly in the system state rule.

The system state grammar contains the system state. This system state combines the concepts of AGG and USE. A system state consists of an AGG working graph and a USE state. The AGG graph is necessary to be able to let AGG handle the pure graph rewriting, while the USE state is needed for the evaluation of OCL expressions. When applying a rule, the system state grammar has to ensure that the AGG graph and the USE state of the system state are synchronized. The application of a system state rule then works as follows.

If the rule has an application condition, the system state grammar uses the USE state and the USE expression evaluator to determine the value of given expressions depending on the match of the left-hand side of the rule to the system state. If it evaluates to true, the rule may be applied, otherwise another match is tested. If there is no further match, the application of the rule to the current system state is not possible. The actual application is then performed by AGG on the AGG graph of the system state. This comprises the correct handling of possible variables in the left-hand side of the rule. In order to keep the USE state of the system state synchronous to the AGG graph, the observer facility of AGG is used. An instance of class Synchronizer is registered as an observer of the observable AGG graph. Whenever this graph is changed, the synchronizer is informed via its update method. These changes are accumulated to change the USE state once AGG has completed the rule application. When the rule application is finished, the synchronizer is removed from the observer list of the AGG graph. At this stage, there may be unevaluated OCL expressions as string constants in attribute values of the working graph. They are now interpreted by USE and the values replace the corresponding constants. Then the system state grammar changes the USE state according to the previously collected changes of the AGG graph. Afterwards the USE state and the AGG graph represent the same system state and the next rule application may be calculated.

In order to provide the possibility to calculate the next step of a system state evolution, the system state grammar permits to apply any rule in the set of system state rules. This is done by randomly choosing one of the rules until an applicable one is found. Instead the user may also select a process to be executed. Furthermore the user may choose a new use case. In this case optional parameters have to be provided by the user. Note that a use case rule is always applicable and that such a use case rule needs to be selected to actually start a system state evolution.

We have presented an integrated semantics for UML based on the translation of a given UML model into a graph transformation system. To demonstrate our approach an example model comprising several UML diagrams has been introduced. Next we have described our idea of a system state by means of a metamodel followed by a discussion of the translation of a given model into model-depending and predefined graph transformation rules by example. Finally the basic concepts of the prototypic software implementing this ap- proach have been addressed. The prototype translates a given UML model into a graph transformation system and allows to monitor the evolution of the system state step by step.

An interesting topic would be the integration of further diagram types like activity diagrams into our approach. We will also investigate whether and how the diagrams already covered can be extended with yet missing UML fea- tures. Case studies will provide feedback on the practicability of the approach and tool. In particular, more insight is needed into the process of asserting properties of UML models on the basis of our approach, for instance, based on transformation invariants. In this way our approach will automatically benefit from future cognitions in the field of graph transformation.

