This direct implementation is not an efficient one (as expected). It is well-known that first-order unification, which is a particular case of nominal unification, is ex- ponential if subterms are not shared, but it is linear if terms are represented as graphs with maximal sharing. Our second implementation of the nominal unifica- tion algorithm, written in OCaml [8], is based on the use of termgraphs instead of terms. There is an additional complication with respect to first-order unification, in that to obtain a polynomial algorithm we also have to share subterms up to permu- tations of atoms. Because of the additional operations on permutations, our second implementation is not linear, but we can show that these additional computations are polynomial.

The syntax of nominal terms was extended in [4] with an operator to model name generation, and with a new kind of constraint to express locality (written a@t). Extended terms have the form  A.t where A is a set of local names in t, and t is a nominal term which may contain  but not at the top level. We omit the unification rules dealing with  and locality constraints here, although we have

The naive implementation described above is simple but inefficient. To improve it, we have changed the data structure used to represent terms and unification prob- lems: a whole nominal unification problem will be represented as a single directed acyclic graph. In this way we obtain a polynomial algorithm. This algorithm has been implemented in OCaml (a strongly typed, strict, functional programming lan- guage, with support for imperative features and object-oriented design; see [8] for more details). In the rest of the section we highlight the main difficulties encoun- tered and the techniques used.

The complexity of nominal unification is still an open problem. Unification of higher-order patterns, a closely related problem (see [1]), is linear [9] and there is therefore hope that nominal unification could also be linear. This is a challenging area for future work.

