Formal methods are increasingly being used in industry to establish the correct- ness of, and to find the flaws in, system models; of hardware, protocols, distributed algorithms, etc... In particular, model checking [11,19,7,21,20] does that automat- ically for finite-state systems. However, model checking is limited in scope due to the state explosion problem; since it works on the transition system defining the semantics of the distributed program. This transition system has often infinitely

Imperative languages with explicit parallelism and communication statements provide an intuitive, explicit, and complete framework to express system models and distributed programs with perspective and clarity. This is important in verifi- cation. OCCAM [12,13,14], the simple programming language SPL of Manna and Pnueli [16,17], PROMELA of the SPIN model checker [11], and the shared-variable language++, SVL++, in [8] are representatives of these imperative notations.

This semantics has been extended in [5] by adding to the set O an auxiliary variable, channel variable, for each external channel, to record the history of values traversing it. External channels are used in S, but they are not in I, the set of internal channels. These are channels communicating parallel substatements within S, and considered to be hidden from the outside. Any channel is either external or internal. The extended set O is referred to as the interface set. When S is the body of a procedure, the internal channels are not declared in its interface whereas the external channels are. Internal communication and external communication will mean communication substatements of S over internal and external channels, respectively.

The communication front of S, written ComFront(I,S), is the subset of minimal elements of the set of communication statements in its concatenation ordering. Two internal communications of S, l and m, are said to form a matching communication pair, p, if they are parallel, one is an output and the other an input over the same channel. The set of competing pairs of S, written CompPairs(I,S) is, by definition, the set of matching pairs p : (l, m) which can be formed with the communications in ComFront(I, S). Two matching pairs are disjoint if they share no communication statement.

Assuming disjointness of all possible pairs, a communication elimination algo- rithm has been proposed and studied in [2]. It applies iteratively a procedure, PElim which carries out the elimination of a pair applying the above recursive law. When applicability conditions do not hold a boolean result is returned with a false value, and the algorithm terminates unsuccessfully. When the loop of PElim in- vocations terminates without failure, and there is still some communication left in ComFront(I, S), this means that the original program has deadlock possibility. This proof construction algorithm simulates an execution where the elimination of a pair of matching communication statements in the proof corresponds to a communica- tion event in an execution. Generalizations of this algorithm are within procedures DisjPairsElim and CompleteComsElim given at the end of sections 5 and 6, respec- tively.

Lemma 4.1 (Communication-closed-layers) Let the statement pairs (A1, B2) and (A2, B1) be non-communicating, and [B1; A1] be disjoint with [B2; A2]. Then [[B1; A1]||[B2; A2]] =O [[B1||B2]; [A1||A2]] , and either both sides are deadlock-free or none of them is.

The third and last step of DPS proofs is redundant variable elimination. State- vector reduction comes with this last step. Both, redundant variables and state- ments are eliminated. The former usually come from communication buffers, of the original distributed system, which are no longer necessary after their inner commu- nications have been eliminated. The next subsection provides some detail about variable elimination.

In general, the elimination of internal communication statements reduces parallelism among external communication offerings. This follows from remark 3.1 of section 3; but, in addition, from parallelism to concatenation reductions as well. This introduces the possibility of deadlock within the embedding program environment. This will be illustrated with the following three register queue, with interface set O : {cout, cin}.

Here, the three ci channels are internal and a maximum of three inputs via channel cin are allowed without the occurrence of any output via channel cout. From this state, a maximum of three cout outputs are allowed without the need of any further input. Other degrees of external input/output interleavings are allowed.

Definition 5.2 (Concatenation chain of a statement) A concatenation chain of a statement is a list of some of its basic substatements, in consecutive ascending concatenation order, with parallelism and selection symbols, whose first element is an initial substatement or a selection or a parallelism symbol; and whose last element is a terminal or an exit substatement. Each of the two symbols represents the LCA selection or parallelism statement of its immediate successor.

Justification An approach, as in [4], would be to show that the transitions as- sociated or denoted by the statements at the two sides of the congruence symbols are the same. A different approach is the following. The sets of interface computa- tions of the statements at the left sides of the congruence symbols are partitioned into three classes: the one involving the left alternative, the class with the rest of alternatives R, and that involving none of the alternatives.

construction of the statements at the right side. The class of computations involving none of the alternatives is included in the sets of the two alternatives at the right hand sides. But this apparent duplicity is supressed by the union operation, since the set of behaviors of a selection is the union of those of its alternatives.

Justification  The congruences follow from lemma 5.6, definition 5.8, the fact that elimination from a selection is the selection composition of the elimination from each of its alternatives, and that p is not in S[R]. Furthermore, the conservation principle of lemma 5.5, which applies to the first relation, is met since the disabled pairs some of whose communications have to be in R remain in the R alternatives in the right sides.

Let Ac be a variable taking values from the set {c; A|A[c]|ext; A[c]} , where the vertical bar | is used as a value separator. Then the three laws of lemma 5.6, and the three laws of lemma 5.9, can be expressed, respectively, with the two laws 5.6. The conservation principle of definition 5.5 is also met, since the disabled pairs are kept in another alternative of the selection of the right side. The assumption of disjoint pairs is crucial here, since it excludes two alternatives, out of the four which would be combinatorically possible.

The justification would go along the same lines as the one of lemma 5.6. How- ever, lemma 5.5 does not apply since there is no disabled communication guard. The selection of alternatives depends on the boolean conditions only, and all the combinatorically possible alternatives have to be kept.

The justification can be done as in lemma 5.9. The conservation principle of lemma 5.5 applies to the disabled pairs which have a communication guard in R1. The second alternative of the statement to the right retains these alternate pairs. In addition the statement has the usual S[R1|R2] alternative.

Procedure GPElim has been given above. ObtainCompPair obtains a commu- nication pair (c1, c2) from the current communication front, as well as information, within sel1 and sel2, on the selections embedding the two communications. The search for a pair within this procedure is done over a new communication front in each invocation of ObtainCompPair, since the previous pair has been eliminated in the loop, and this may uncover new communications. When no pair is found, existsPair is returned with the value false. For any selection embedding inner com-

Lemma 6.1 suggests the above recursive elimination algorithm. n is the number of pairs in S sharing c, as determined by ObtainNDPairs, which also stores the other communication of the i-th pair in altCom(i). Variables selJoint and selAlt corre- spond to sel1 and sel2 of GPElim. The former concerns the shared communication c, and is computed only once.

Theorem 6.3 (Correctness of CompleteComsElim) The statement S result- ing at the exit from CompleteComsElim when failure=deadlock=false is such that S =O S', where S' is the statement S at the entry point, and no eliminable pairs remain in S. When, at the exit, deadlock=true, S' is not deadlock-free.

Justification At the entry point of the while loop, a new iteration is started whenever there are still competing pairs. By theorem 6.2, at the if statement of the loop body, all pairs of the current front are guaranteed to be disjoint and, whenever a pair still exists it is eliminated by GPElim, whose precondition of disjoint pairs is fulfilled. The loop is continued while there still remain pairs to be eliminated. If, after some iteration, failure=true, exit with failure occurs.

