In this note, we define an abstract file system as a partial function from (absolute) paths to data. Such a file system determines the set of valid paths. It allows the file system to be read and written at a valid path, and it allows the system to be modified by the Unix operations for removal (rm), making of directories (mkdir), and moving (mv ). We present abstract definitions (axioms) for these operations.

This specification is refined towards a pointer implementation. To mitigate the problems attached to partial functions, we do this in two steps. First a refinement towards a pointer implementation with total functions, followed by one that allows partial functions. These two refinements are proved correct by means of a number of invariants. Indeed, the insight gained mainly consists of the invariants of the pointer implementation that are needed for the refinement functions.

Formal verification uses the mathematical techniques for ensuring the design to conform to the functional correctness. It can be applied to designs described for many different levels of abstraction [5]. It helps in eliminating errors in the design which can cause disaster at later stages.

In this paper, we formalize the most rudimentary aspects of a hierarchical file system: only reading and writing files, deleting them, creating them, and moving them. We do this in a top-down fashion, starting with the point of view of a user who does not want to know anything of the implementation. This is refined into a version with directories that hold subdirectories.

When formalizing this, one encounters the problem of partial functions. In the first refinement step this is ignored by forcing the functions to be total. In the second refinement step, we recognize the inherent partiality of our functions. From the conceptual point of view, this may seem superfluous. For implementations, however, it is crucial because this partiality corresponds to the potential occurrence of unallocated pointers in the implementation.

We use the proof assistant PVS [6] for our formalization and the verification of the refinement relations. The PVS proof script of our definitions, theorems, and proofs is available at [7]. Our notation is partially based on PVS syntax, but we also use concepts from Haskell, and standard mathematical notations.

Here [# and #] are constructors for record types as used in PVS. The corresponding element constructors are (# and #) used below. For a node v, we write v.data and v.dir for its data and its directory. At this point, the nodes are more general than usual. Later on, we may want to impose conditions on the data for a node that

Unreachable nodes in the tree are useless. Garbage collection amounts to the re- moval of useless nodes. In the present context this is impossible because every store x is a total function. The best we can do is minimize the unreachable nodes. This is done as follows.

By a straightforward induction on the length of p, one proves that L(p, gc(x)) = L(p, x) for all paths p. Having done this, one can easily prove that abstract(gc(x)) = abstract(x). In words, garbage collection does not influence the meaning of the store.

It is straightforward to prove that the operations write, delete, create, move, and gc preserve the invariant J 0, i.e., J 0(x) implies J 0(write(p, m, x)) for all x : StoreT, and similarly for the other functions. The same is done for the invariant J 1. Preser-

Here, f and g range over Fid and m and n range over Name. By induction on the lengths of the paths, one proves that these two invariants, together with J 0, imply J 2. It is fairly easy to prove that write, delete, move, and gc preserve the invariants J 2a and J 2b. For create, we use J 3 and formula (1).

Working with partial functions in a theorem prover like PVS gives technical difficulties that, from a conceptual point of view, seem inessential and distracting. In the implementation, however, these difficulties correspond to the usual prob- lems with unallocated pointers. It is therefore important to get it correct at the theoretical level.

where px stands for the permission to execute, pr to read, and pw to write. We do not go into details of how these permissions are represented in the data. Instead, we concentrate on the specification and verification that users can only access and modify according to the permissions granted. As the functions px, pr, pw depend

For the sake of brevity, we omit the definitions of write, create, and move at this level. Using the invariants J 0, .. ., J 3, we then prove the refinement theorems for the user-adapted functions of this level, analogous to those of section 3. All details are given in the PVS proof script of [7].

We finally prove with PVS, that the refinement function from the implemented store to the total store also respects (i.e., commutes with) the user-adapted versions of read, write, ls, create, delete, and move. The details of the proof can be found at

A total of 204 lemmas were proved with proof assistant PVS [6] during this work. It included 10 lemmas for the abstract model, 87 lemmas for the model with total functions, 79 lemmas for the model with partial functions, and 28 lemmas shared for all models. This may be an indication of the efficiency of PVS as compared to the work done in [17] using Athena where they constructed 283 lemmas and theorems for only reading and writing into files in only one directory. Details of the PVS proof can be found in the proof script for this work at [7].

