There are numerous ways of implementing program visualizations. At its simplest the visualization can be a line of moving pictures, e.g. implemented with a technique like Flash. The problem of this kind of approach is that the interaction between the user and the tool is very limited. Visual interpreters that work on any program code are easier to adjust to communicate with the user. This kind of program visualiza- tion tools, e.g. Jeliot 3 [3] and VIP [5], are available for free use on introductory programming level.

A program visualization tool typically shows the visualized program code in a win- dow. This window can include short comments as a part of the code. The purpose of the visualization is to explain the run of the program to the student. To aid this the visualization tool can include extra instructions to describe the program and to draw the students attention to the essential.

To make sure that the additional instructions do not make the source code unneccessarily long, they can be placed in a separate instruction window. The instruction window can show only the instructions related to the line of code that is currently executed. This way the students who need more explanation can follow long intructions and the students who do not need it can skip reading since the instruction is separate from the actual visualization.

To improve the expression of the instructions, the visualization tool developer can add annotations to define the visibility of the instructions. For example, a certain instruction could be shown only when the execution reaches the statement for the first time. When the execution returns again to that statement there will be a new instruction. This way the teacher can build the instructions more useful and interesting for the student. E.g. when executing a function call statement on

The existing annotations are connected to the execution order of the program. Thus they enable writing wide explanations of the program for the students but do not really support interactivity. If the visualization tool provides a possibility to edit the visualized program source code the tool can also be used for visualization exercises described by Lahtinen and Ahoniemi [2].

Our idea is to use the visual interpreter for interpreting these too. An annotation can mark some parts of the code hidden. In the hidden code, the teacher can test the program. E.g., if the task for the student is to implement a function, the hidden test code can run the function a couple of times and display the instruction text for the student according to the results of the tests.

When the student is visualizing the code the input stream cin naturally works in a normal way: asks the user to write the input. When the code written by the student is tested it usually is not a good idea to ask the input from the user. First of all it could be confusing for the student because he does not know what is happening during the testing and secondly in some tests it would allow the student to cheat. To make sure that the testing is done carefully it is better that the teacher defines the input beforehand.

The functionality introduced here is easy to add to an existing interpreter since it uses the same interpreter to implement the tests in the hidden code. After this addition the visualization tool can be used e.g. for utilizing visualizations and problem-solving visualizations [2].

When implementing tests like this to a visual interpreter also the effectiveness of the interpreter should be considered. A visual interpreter can be implemented with the idea that it does not need to be very effective, since the visualization needs to be observed and thus is not supposed to be too fast. In this case it should be checked that the interpreter is effective enough to run the tests in the hidden code in a reasonable time. At least the student should be shown some kind of a progress bar to follow while waiting.

It is easy to add annotated instructions to an interpreter based visualization tool. With some imagination these instructions can be used for creating visualization exercises that engage the student to work with the visualization. Adding this little feature to the tool widens the pedagogical uses of the tool greatly.

