We present an abstract interpretation framework for a subset of Java (without concurrency). The framework uses a structural abstract domain whose concretization function is parameterized on a relation between abstract and concrete locations. When structurally incomptatible objects may be referred to by the same variable at a given program point, structural information is discarded and replaced by an approximated information about the objects (our presentation concentrates on type information). Plain structural information allows precise intra-procedural analysis but is quickly lost when returning from a method call. To overcome this limitation, relational structural information is introduced, which enables a precise inter-procedural analysis without resorting to inlining.

Our abstract domains contain structural information and closely resemble to the standard domain (consisting of an environment and a store). Abstract locations may be annotated with various kind of information, making the framework generic. Structure sharing at the abstract level can be interpreted in several different ways, at the standard level, giving rise to three variants of the abstract domains 3 .

This paper presents an overview 4 of the work and is composed of five main sections. Section 1 provides a brief overview of the standard semantics. Section 2 describes the abstract domains. Section 3 sketches the abstract semantics definition. Section 4 details the results of the analysis for small programs. Section 5 discusses the related work.

We use several abstract domains, i.e several abstractions for the set . All those domains are structural ones: they keep a partial view of the heap struc- ture. When a variable or field may concretely denote values with different types, an abstract type is introduced in the abstract graph. Those abstract types belong toa parameter abstract domain, which may express various kinds of information (although we currently mainly focus on type information).

Let us now consider the analysis of the method Main.main3(). Snapshot 3 depicts the abstract store just before the cast check within the statement v = (Int) var.pop(). This time, the value mapped to the internal variable #0 does not permit to validate the cast, since it can represent an instance of Int or an instance of CoupleInt. A warning can then be raised.

before the call l.getCell() within the method readList for this entry. In this situation, the type of l is exact. Thus, the dynamic call can be replaced by a static one and, further, inlined. Snapshot 3 details the analysis for the entry in the method environment for this call. Again, the type of this.info is exactly known and the call can be made static and inlined. So, we have derived enough type information to obtain a completely specialized method (with two nested loops).

There is a single case where the results are not totally optimal: For the call p.writeCell() within the method writeList, we are only able to derive that p is either of type IntList or IntL2List. This result could be improved on with minor modifications of the abstract domain. For instance, we could use an improved version of the Distinctness Domain that would allow OR-Nodes to deal with the null value.

We have presented an abstract interpretation framework for a subset of Java. This framework uses structural abstract domains, which makes it possible to extend the framework with additional analyses, and it provides a precise treat- ment of inter-procedural analysis, through the use of relational information. We see this framework as a first step towards a completely satisfactory ab- stract interpretation framework for Java. The needed improvements include addressing the complete Java language, further parameterizing the abstract domains, and dealing with incomplete source code. The contribution of this work is thus to provide the semantic basis for a complete system since many improvements will amount to add new but similar definitions and to tune the abstract domains and the algorithms.

In the near future, we plan to work along two main lines. On the one hand, we will investigate variants of the structural abstract domains to find the most interesting tradeoffs between precision and efficiency of the analyses, in different situations (e.g., optimization versus verification). On the other hand, we will extend the framework to the complete Java language (still without concurrency but with provision to analyze incomplete code).

