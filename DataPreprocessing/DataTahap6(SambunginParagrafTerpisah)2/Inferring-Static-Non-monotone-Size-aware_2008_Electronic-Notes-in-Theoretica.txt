To infer a size dependency, the procedure generates hypotheses for increasing degrees of polynomials. For each degree, a polynomial is defined by a finite number of points. Based on interpolation theory, in this paper we establish an upper bound on the number of test runs and a correct choice of test data that guarantees that all polynomials representing sizes of output lists can be found. The resulting hypothesis is then checked using an existing type checking procedure.

The procedure is not tied to the current size-aware type checker. The size-aware type of a function will be inferred if it exists and if it is accepted by a size-aware type checker. For terminating functions, our size-aware type inference procedure is complete with respect to type checking: if a function is well-typed, then the inference procedure terminates and produces corresponding size dependencies.

list. In this paper we focus on the task of automatically deriving the exact output- on-input size dependencies of function definitions in a program. The ratio behind exactness is explained later in this section. A possible relaxation of it is considered in Section 5.

Consider examples. The function progression appends all tails of an argument list. Given the list [1, 2, 3] it returns the list [3, 2, 3, 1, 2, 3]. Thus the size of the output list is the sum of all integers from 0 to s (arithmetic progression

The function cprod computes the Cartesian product of two lists. It generates all pairs of elements, one taken from the first list, the other from the second. To define cprod one needs an auxiliary function pairs. The function sqdiff returns the Cartesian product of an argument with itself, if another argument is empty. If both arguments are not empty, then it recursively calls itself on their tails.

Recently, we have developed a size-aware type checking algorithm to formally verify polynomially size-aware types (section 2) [12]. Given a size-aware type, the algorithm automatically checks if the function definition satisfies that type. Unfor- tunately, inferring such types is a lot more challenging than type checking and the type system approach does not straightforwardly extend (section 2.3). Therefore, we have suggested an alternative method of inferring size-aware types [12]. This paper develops this method into a practical type inference procedure.

Combining hypothesis generation and type checking yields a procedure that can infer the size-aware type of a function (section 4). The procedure generates hypotheses for an increasing degree. For each degree, hypotheses for all polynomial size expressions in the output type are determined. The resulting size-aware type is checked using the size-aware type checking procedure. Thus:

Essentially, our approach to size-aware type inference for shapely functions is based on reducing inference to size-aware type checking. This section briefly describes the existing strict size-aware type system for a functional language and accompanying type checking procedure [12] that we use in the inference procedure. This also motivates our approach to type inference.

The zero-order types we consider are integers, strictly sized lists of integers, strictly sized lists of strictly sized lists, etc. A strict list of length n is a list exactly of length n (not of some length up to n, as, e.g. in sized types of Pareto [11]). For lists of lists the element lists have to be of the same size and in fact it would be more precise to speak about matrix-like structures, e.g. the type [[Int]3]2 is given to a list which two elements are both lists of exactly three integers, such as [[2,5,3], [7,1,6]].

As usual Q denotes the set of all rational numbers. As size expressions we consider polynomials with rational coefficients that are not necessary integer. Only those of them who map non-negative integers into non-negative integers have a semantic in the type system 3 . An example of a size expression with non-integer coefficients is the polynomial for progression function above.

As in [12] the formal rules are designed conventionally for ML-like syntax. Recall that an empty list [] is denoted by nil, a list x:xs is presented as cons(x, xs), and pattern matching and case-expressions both correspond to a match-construct. But, still, everywhere in examples we use Haskell-like syntax.

We formulated a syntactical condition sufficient to make type checking decid- able for this system [12]. We allow pattern matching and case expressions only for function parameters and variables bound to them by other pattern matchings and case expressions. For instance, cprod and sqdiff satisfy this condition, since here only program arguments are matched. Case expressions on tails (of tails of ...) of function arguments are allowed as well:

The type checking procedure from section 2 and the size hypothesis generation from section 3 are combined into an inference procedure for an increasing degree of polynomials. The procedure is semi-decidable: it only terminates when the function is well-typable in the type system of the type checker used. In this sense the procedure is complete w.r.t. a type-checker: if a function definition is well-typed, the type will be found.

Based on the results of Section 3 we define a theoretical maximum on the number of tests in the following way. Let m = max{m1, ..., mk}. The theoretical maximum is the upper bound (1 + km)n. In practice, as a rule, the number of tests needed to define all the output polynomials for a given function is significantly closer to the theoretical lower bound defined by m+n which is the number of coefficients of the polynomial with n variables and degree m.

The second source of nontermination is the iteration over increasing degrees of polynomials. If none of the generated types is accepted by the checker, either be- cause the function definition is not shapely or due to incompleteness, the procedure in principle does not stop. In practice, often an upper bound can be put on the degree because only size expressions of low degree are desired.

The current hypothesis generation procedure relies on the limitation to shapely programs; output sizes need to be exactly polynomial in the input size. In practice many programs are not shapely, but still have a polynomial upper bound. Consider inserting an element in a set. This increases the set size by one only if the element was not in it. Its actual upper bound is:

To extend our approach to such upper bounds, we are studying program trans- formations that transform an unshapely function into a shapely function with the strict size dependency corresponding to an upper bound of the size dependency of the original function. For instance, the insert function would be transformed into a shapely function that always inserts the element. We believe that in many practical cases the testing approach combined with program transformations will succeed in providing good upper bounds.

We have developed a procedure (and a demonstrator for it) to infer static non- monotone size-aware types through interpolating data from run-time tests. The dynamically generated types are only accepted after checking them by a formal type checking algorithm. So, the types are static: the size expressions hold for every possible future run of the program.

