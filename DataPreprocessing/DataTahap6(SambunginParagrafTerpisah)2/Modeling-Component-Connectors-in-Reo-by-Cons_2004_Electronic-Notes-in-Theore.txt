model for the behavior of connectors in Reo. Constraint automata can be thought of as conceptual generalizations of probabilistic automata where simple constraints, instead of probabilities, influence applicable state transitions. The single most im- portant composition operator in Reo, join, amounts to a product of automata in this model.

Reo defines a number of operations for components to (dynamically) compose, connect to, and perform I/O through connectors. Atomic connectors are channels. The notion of channel in Reo is far more general than its common interpretation. A channel is a primitive communication medium with exactly two ends, each with its own unique identity. There are two types of channel ends: source end through which data enters and sink end through which data leaves a channel. A channel must support a certain set of primitive operations, such as I/O, on its ends; beyond that, Reo places no restriction on the behavior of a channel. This allows an open- ended set of different channel types to be used simultaneously together in Reo, each with its own policy for synchronization, buffering, ordering, computation, data retention/loss, etc.

It follows that every channel represents a (simple) connector with two nodes. More complex connectors are constructed in Reo out of simpler ones using its join op- eration. Joining two nodes destroys both nodes and produces a new node on which all of their coincident channel ends coincide. This single operation allows con- struction of arbitrarily complex connectors involving any combination of channels picked from an open-ended assortment of user-defined channel types. The seman- tics of a connector is defined as a composition of the semantics of its (1) constituent channels, and (2) nodes. The semantics of channels are defined by the users who provide them. Reo defines the semantics of its three types of nodes, mentioned above.

The simplest channels used in these connectors are synchronous (Sync) channels, represented as simple solid arrows. A Sync channel has a source and a sink end, and no buffer. It accepts a data item through its source end iff it can simultaneously dispense it through its sink. A lossy synchronous (LossySync) channel is similar to

The semantics of Reo connectors can be defined in terms of relations on timed data streams (TDSs) as presented in [2]. In this section we introduce the notion of constraint automata and show how they can serve as operational models for the behavior of Reo connectors by relating the languages of these automata with timed data streams. Here, like in [2], we do not consider the dynamic behavior of com- ponents in creating and composing connectors. Our focus is on the Reo circuits, built from basic connectors (channels and merger) via join and hide operations, without considering the further possibility of join or split. We use constraint au- tomata to specify the operational semantics of Reo because this allows us to adapt the known methods for the analysis of finite state automata to work with constraint automata. Ordinary finite automata are not rich enough to represent the seman- tics of Reo. Constraint automata allow us to model subtle timing and input/output constraints of Reo connectors, specifically their combined mix of synchronous and asynchronous transitions. This is reflected in our definition of constraint automata and we will show it further in our examples.

Constraint automata can be viewed as acceptors for tuples of timed data streams that are observed at certain input/output ports A1,..., An of components. The rough idea is that such an automaton observes the data occurring at A1,..., An and either changes its state according to the observed data or rejects it if there is no corre- sponding transition in the automaton. We use constraint automata as a semantic model to describe the TDS-language induced by Reo connector networks.

B. The time streams a and b contain for each of them the times at which these input and output actions take place. The relevance of this timing information is restricted to the particular connector, in this case the channel, at hand: what matters is only the relative order of the initial values a0 and b0, which determines which channel ends will be active next. A pair of timed data streams is a timed run for a state

If A is understood from the context, we simply write dc(q, N, P). Intuitively, dc(q, N, P) is the weakest DC that ensures there is an N-transition from state q to P. Note that dc(q, N, P)= false if there is no N-transition from q to a P-state. We use dc(q, N) as an abbreviation for dc(q, N, Q).

