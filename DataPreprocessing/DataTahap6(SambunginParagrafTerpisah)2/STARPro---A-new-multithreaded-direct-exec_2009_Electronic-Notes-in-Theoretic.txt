Esterel programs have traditionally been compiled to software code for general pur- pose processors or to hardware netlists. This paper, instead, proposes a reactive processor for the direct execution of Esterel. This intermediate approach offers the same flexibility as software compilation, while at the same time, providing much better code size and execution time. The proposed architecture, called STARPro, is a pipelined, multithreaded, reactive processor that provides native support for the direct execution of Esterel. STARPro manages Esterel threads and their scheduling, and also features a hardware preemption unit to assist the handling of the abort constructs in Esterel. In addition to the proposed architecture, we have also devel- oped a new intermediate format called UCCFGsd (unrolled concurrent control-flow graph with surface and depth) to represent the structure of an Esterel program in our compiler. UCCFGsd closely resembles the Esterel source, and it has also been designed with Esterel hardware support in mind, allowing a straight forward trans- lation into STARPro assembly instructions. We have compared the performance of STARPro against a recent reactive architecture and found an average of 37% speed-up in worst-case reaction times, and 38% in average-case reaction times.

Reactive systems typically consists of tasks running in parallel. This con- currency is traditionally supported by running an operating system (OS) that manages these tasks. The dynamic nature of an OS makes the programs run- ning in it difficult to debug and verify. The synchronous paradigm that Esterel follows, in contrast, abstracts away the physical time, and synchronizes the program with a global logical clock. All concurrent components of an Esterel program execute in lock-step, evolving in discrete instants of time, known as a tick. Execution is assumed to be infinitely fast between ticks. Hence, the communication between the concurrent components are conceptually instan- taneous. Such synchronous execution guarantees that each reaction in Esterel is atomic in every possible sense. This makes race conditions, common in concurrent programming, impossible in Esterel.

The architecture-specific approach relies on custom microprocessors that have been augmented with an instruction set, which enables the efficient map- ping of Esterel statements to assembly code. This approach yields very com- pact software code, as well as efficient execution, and will be the focus of this paper. We present a novel multithreaded processor, named STARPro (Simultaneous multiThreaded Auckland Reactive Processor), and an Esterel compiler for it, that achieves significant speed-up and code size compaction over traditional methods for software implementations of Esterel.

In contrast to the approach taken in EMPEROR, new contributions were also made to the idea of reactive processing through the KEP series of pro- cessors [12,11,13,10]. The KEP series of processors are custom designed ar- chitectures that have evolved with incremental support for executing Esterel. The most recent processor, KEP3a [10], is capable of preserving the seman- tics of the full language. It also provides a multithreaded execution platform to support the concurrency in Esterel. This approach has yielded impressive code size compaction and execution times, thus affirming again the benefits of reactive processors for executing Esterel.

In contrast, this paper presents a novel multithreaded processor, named STARPro, that provides an alterative approach to direct execution compared to KEP3a. STARPro uses variable tick lengths and a pipelined architecture to obtain much better average performance compared to KEP3a. This has been achieved using far fewer logic gates for processor implementation, while maintaining code sizes that are comparable to KEP3a for a given Esterel program.

Plummer et al [14] have explored another approach of executing Esterel using a virtual machine (VM). A VM provides Esterel supporting intructions for direct execution, similar to the way STARPro works. The key difference is a virtual machine is implemented as software, where STARPro is a hard- ware platform. Both approaches are superior in code size when compared with traditional Esterel compilers, however the VM approach is significantly slower than traditional Esterel compilers [14] and the VM cannot handle host procedure calls written in for example C.

The other remaining important component of the TCB is the scheduler. The scheduler stores the priority and a notion of a local tick for each thread. We say that the local tick for a thread has elapsed whenever a pause statement in it is reached. This differs from the global tick for an entire Esterel program, which only elapses when all running threads have completed their local ticks. In STARPro, the pause statement is mapped to the PAUSE instruction, which is used within the processor to indicate the completion of the local tick for a given thread.

The scheduler will always select the thread with the highest priority for execution. In doing so, it ignores all the threads that have either completed their local ticks, or are otherwise inactive. A thread is considered to be inactive if its priority number is set to the lowest possible priority. When the local tick of all the currently active threads elapse, the global tick completes, and a compiler-generated management thread is selected to sample new inputs and to clear all output signals for the next global tick.

Rx: This is the bus that connects to a 16-bit register selected from the register file in datapath. The register has to be loaded with the status of I/O signals in a bunch of 16s at a time from memory. It is updated at every tick, and is used by the AHB to evaluate the status of the aborting signals.

The most significant difference between the AHB and the preemption watchers in KEP is how the preemption is monitored. STARPro relies on explicit checks at appropriate times using an instruction, where the watch- ers in KEP relies on a physical tick signal in hardware. The correctness of abort semantics of the AHB relies on the compiler at compile time, where the watchers rely on the runtime hardware behaviour. The difference in the two approaches results in simpler preemption hardware design for STARPro.

We describe the reason for this difference. An abort construct in Esterel may contain an abort handler. If an abort handler exists, the handler will be executed when an abortion takes place. A weak abort offers the current executing abort body one last chance to complete the current tick before preempting it.

Let us now consider the scenario where a weak abort is nested within another weak abort, and both of them have an associated abort handler. In the instant where the aborting signals for both constructs are present, the program will first execute the inner abort handler up to, but not including, the pause statement (if any). Execution will then branch to the outer abort handler.

The number of I/O signal ports is parameterizable. I/O signals are memory-mapped, which enables signal manipulation to be also done using instructions that read from and write to memory. This design allows any ar- bitary arithmetic or logic operation to be performed on signals. STARPro also does not have any dedicated instruction for strong immediate aborts. In- stead, this is derived using the ABORT instruction, together with the PRESENT instruction to test for the aborting condition in the starting instant.

Following the preliminary construction of the UCCFGsd, the nodes are clustered into distinct sets to facilitate their static scheduling. This is similar to that done in the CEC compiler [8]. However, unlike CEC, our scheduling is done in hardware using a priority instruction, similar to [10].

Statements in an Esterel program may potentially be executed multiple times within a single tick. Such programs are referred to as schizophrenic [2,17]. This phenomenon may result in a single local signal declaration in Esterel being executed multiple times within a tick. Esterel compilers typically handle this by creating multiple copies of the same signal (known as incarnations [2]) for each new signal declaration that may potentially occur within the tick. This not only complicates the compilation process, but also significantly leads to an increase in memory footprint due to code duplication.

The nodes in the UCCFGsd map very closely to STARPro instructions. Code generation from the UCCFGsd is greatly simplified as there is almost a di- rect mapping between nodes and assembly instructions. For example, the context switch and pause nodes directly translate to the CSWITCH and PAUSE instructions respectively.

The benchmark programs presented here have been selected from EstBench [7]. All the selected programs are also present in [10] for comparison. The benchmarks were evaluated in three aspects. First, we compare the worst-case and average reaction times for KEP3a and STARPro. The optimized results for KEP3a were taken from [10]. Then, we compare the generated code size. Finally, we show the effects of a pipelined architecture in terms of the speedup obtained.

