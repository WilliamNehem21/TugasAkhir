Component orientation is a new paradigm for the development of software-based systems. The basic idea is to assemble the software by combining pre-fabricated parts called software COTS (Commercial Off-The-Shelf) components, instead of de- veloping it from scratch [22]. This procedure is similar to the construction methods applied in other engineering disciplines, such as electrical or mechanical engineering. Software components are put together by connecting their interfaces. A provided

We briefly describe the formal method B and explain how we use it in the context of component-based software. The architecture is modeled by UML diagrams (the components) annotated with B models associated to their interfaces. The B models are then used to verify the interface compliancy.

The B method has been successfully applied in the development of several com- plex real-life applications, such as the METEOR project [2]. It is one of the few formal methods which has robust and commercially available support tools for the entire development life-cycle, from specification down to code generation [3]. It provides structuring primitives that allow one to compose models in various ways. Proofs of invariant consistency and refinement are part of each development and POs (Proof Obligations) are generated automatically by support tools such as Ate- lierB [21] or B4free [6]. Checking POs with B support tools is an efficient and practical way to detect errors introduced during development and to validate the B models.

intuitive and progressive transformations. For instance, instead of transforming enumerated values of a set directly to the set of natural numbers, it is wiser to first transform it to a set of numbers modulo the number of enumerated values and then transform it to the full set of natural numbers. This way the proof of the refinements become easier.

a new variable nat ids and we add a relation- ship between both variables in the invariant. The other variables are unchanged, and the result is shown in Listing 5. The invariant expresses the fact that nat ids is the image of the alarms ids by id cast. The proof of this

We thus replace them by the variables nat status and nat type. The result is pre- sented in Listing 6. The invariant helps relat- ing nat status with nat ids, i.e. it states that nat status is the composition of the functions alarm status and id cast. The proof of this re- finement consists of 14 POs, among which 5 and nat type are not in the data types of Database O. We need to typecast these codomains, namely AlarmStatus and AlarmTypes, to the corresponding data types of the fields of the database, i.e. Attribute and Value respectively. These fields contain natural numbers, hence we introduce two constant functions named status cast and type cast which map AlarmStatus and AlarmTypes to natural numbers.

The variables status nn and type nn that we have introduced correspond to nat status and nat type respectively. As the codomains of status nn and type nn are the nat- ural numbers, the codomains of nat status and nat type are trans- formed by the typecasting func- tions mentioned above. For nota- tion consistency, we rename nat ids into ids nn.	Moreover, we intro- duce a new variable uid gen for pro- ducing a new unique index each

The proof of this last step is at the crossroad of the POs of the refinements and the POs of the included (provided) interface, hence the POs here tend to be unreadable because of the size of the terms. Fortunately, the shape of the formulas also tend to resemble the POs of the refinements and the POs of Database O. Hence most of the time similar strategies with the proof strategies of the refinements and the included interface can be used for proving the last step.

Zaremski and Wing [23] propose an interesting approach to compare two soft- ware components. It is determined whether one component can be substituted for another. They use formal specifications to model the behavior of components and the Larch prover to prove the specification matching of components.

The refinement steps of our approach for building an adapter can also be viewed as steps for building morphisms between interfaces. Such methods, for instance the methods presented by Smith [20], are based on signature algebras and theory category. Our approach is rather practical because we choose the B method for expressing the interfaces. The B method is indeed easier for software engineers to understand because it is based on set theory. Our results resemble much with

We are currently working on a method for adding dependability features to component-based software systems. The method is applicable if the dependability features add new behavior to the system, but do not change its basic functionality [11]. The idea is to start with a software architecture whose central component is an application component that implements the behavior of the system in the nor- mal case. The application component is connected to other components, possibly through adapters. It is then possible to enhance the system by adding dependability features in such a way that the central application component remains untouched. Adding dependability features necessitates to evolve the overall system architec- ture by replacing or newly introducing hardware or software components. The adapters contained in the initial software architecture have to be modified, whereas the other software components need not to be changed. Thus, the dependability of a component-based system can be enhanced in an incremental way.

Reussner, R. H. and H. W. Schmidt, Using parameterised contracts to predict properties of component based software architectures, in: I. Crnkovic, S. Larsson and J. Stafford, editors, Workshop On Component-Based Software Engineering (in association with 9th IEEE Conference and Workshops on Engineering of Computer-Based Systems), Lund, Sweden, 2002, 2002.

