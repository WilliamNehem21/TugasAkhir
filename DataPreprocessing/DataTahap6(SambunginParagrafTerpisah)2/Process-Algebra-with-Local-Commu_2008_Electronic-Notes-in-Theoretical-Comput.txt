In modelling systems, component-based architectures are a natural way of sep- arating different parts (and subparts) of a system and specifying how these parts relate to each other by means of, for example, communication. Espe- cially in the case of larger systems (i.e. real-life systems and complex proto- cols), component-based modelling is essential to avoid losing overview of the model. We introduce a new process algebra called LoCo which aim it is to be a practical language supporting such hierarchical modelling. Besides the asynchronous behaviour seen in most languages, this algebra also supports the modelling of synchronous behaviour. This allows for the modelling of, for example, electronic circuits (from which one wants to abstract away from the relatively small delays) or easy multiway communications.

The main difference between LoCo and most other process algebras is the fact that it has a local communication mechanism and multiactions. Local communication means that one can specify communication between compo- nents precisely where it is relevant, whereas global communication means that one has to specify the communication for the whole system in one place. Multi- actions are basically multisets of actions that occur at the same time (without communicating). With these concepts we also get a straightforward way to model synchronous behaviour.

introduce multiactions, which in turn resulted in the addition of local instead of global communication. After adding this local communication it became clear that it made the language a truly compositional process algebra. This led us to reversing the thought process; local communication is introduced to make the language compositional and it is this local communication that leads to the introduction of multiactions (as is explained below).

The Petri Box Calculus [8,7,9] gives a more Petri-net-based approach to combining both formalisms. Although the communication is done in the CCS style, multiactions are used here. Because of these multiactions multiway communication becomes feasible, but it remains cumbersome due to the type of communication. A component needs to know that it is going to participate in a multiway communication or one has to introduce a special component that takes care of it. The same holds for SCCS [21] and MEIJE [1], which add synchrony to CCS.

In Section 2 we introduce the syntax of LoCo for which we give a semantics in Section 3. An axiomatisation for LoCo is given in Section 4 to facilitate algebraic reasoning. As abstraction and data often play an important role in systems, we discuss these in Sections 5 and 6, respectively. Some examples are given in Section 7 to illustrate LoCo by modelling a Petri net and a simple compositional system.

Of course, also with these extensions we want to have a sound and complete axiomatisation, as stated in the following theorems. Note that the complete- ness of the axiomatisation now depends on the completeness of derivability in the data algebra A. As we do not explicitly consider this algebra, we say that our axiomatisation is relatively complete. This means that it is complete if we have completeness of derivability in A.

Places are modelled by recursive processes parameterised with the contents of such a place. For places P1, P2, P3 and P4 this is a bag of natural numbers and for place Q a bag of  (with  = {1}). Transitions are modelled by recur- sive processes without parameters (as transitions are memoryless) consisting of a single multiaction. Actions rx and sx are used to model the receiving respectively sending of a token by a place or transition X. These actions correspond to the incoming and outgoing arrows, respectively. If there are

The whole system is a parallel composition of the places and transitions enclosed by communication (modelling the links between places and transi- tions), hiding and restriction. Note that places P1 and P4 are enclosed by a blocking operator because they do not have an incoming or outgoing link, respectively. Also note that the behaviour of places is somewhat restricted here for simplicity; normally it would be possible to atomically take several tokens from one place, as well as putting new ones in it.

of local communication. If one would do so, it is impossible for, say, component One to know that he is communicating with the right Plus component. At least one instance of both the Plus and Mul components need to be changed to avoid conflicts in action names.

We have introduced the process algebra LoCo that is truly compositional due to its local communication operator and the use of multiactions. It has a formal syntax, semantics and a sound and complete axiomatisation. We have included two small examples to illustrate the compositionality of LoCo and the ease with which Petri nets can be modelled in it.

