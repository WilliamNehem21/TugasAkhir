A bracket abstraction is a syntactic operator to abstract variables in combinatory logic. There are different algorithms for different combinator systems. In this paper we present a recursive algorithm scheme, which generates a family of brackets abstractions, in which all the bracket abstractions referenced here are found. In addition, theorems with certain hypotheses are enunciated about the scheme, which state that the resulting abstraction operators, has one property or another. Thus forming a criteria for designing bracket abstractions that comply with a given property.

The algorithms H, fab, abf, SH are not particularly efficient in terms of the size of the term [x]At with respect to the size of t. For example, fab and H are exponential and abf is O(n3), so they are not useful for implementing functional languages. In [10, 11], the size of [x]At for different algorithms is analyzed.

In the bracket abstraction algorithms presented in the introduction, it can be seen that [x]p depends on some sub-terms of p. and the position of the sub-terms to use depends on how it is p. For this reason it is convenient to formalize the concepts of positions and replacement in a subterm position.

Each of the functions ti are homomorphisms with respect to [z|x]. For ex- ample in SH, is fulfilled t5(p, q, r, w)[z|y] = (Bpw)[z|y] = Bp[z|y]w[z|y] = t5(p[z|y], q[z|y], r[z|y], w[z|y]). For the rest of the ti, similar proves can be made.

