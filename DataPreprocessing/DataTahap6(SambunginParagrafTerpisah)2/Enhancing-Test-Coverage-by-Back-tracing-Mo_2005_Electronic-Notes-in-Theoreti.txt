We apply the process described in sect. 2.1 to the module S0, obtaining a path which shows which inputs the module needs to exercise the uncovered branch. We assume that such inputs to S0 come, as outputs, by the previous module S1.

In order to cut this kind of false counterexamples we should consider only the paths of AC1 that correspond to paths of AC0. This operation is essentially a synchronization operation between AC0 and AC1 on the common actions. We will use for this operation the notation AC1/GAC0, where G is the set of common actions, in our case (a,b,c,d,e).

We have detailed the proposed approach using a single running example, and particular formalisms and verification tools. Nevertheless, we believe that the approach has a general validity. Work is in progress on implementations of the approach both using explicit model checking (as shown in the paper) and BDD-based symbolic model-checking, but still focusing on LTSs and on action-based temporal logics.

A result which is related to our work is the definition of more expressive tree-like counterexamples for Kripke Structures and CTL; such counterexam- ples are used as a support to guide a refinement technique [5]. The main difference with respect to our approach is that a tree-like counterexample is in its entirety a proof that the formula is not valid. Our counterexample automa- ton gives instead the set of all linear counterexamples, each of which can be taken separately as a traditional counterexample. A recent evolution of tree- like counterexamples is represented by proof-like counterexamples [11], used to extract proofs for the non satisfiability of a formula over a model. Closer to our approach is the multiple counterexamples generation of [6,10], which generates all the counterexamples to a given length, expressed as a single counterexample trace annotated with possible values of binary variables.

