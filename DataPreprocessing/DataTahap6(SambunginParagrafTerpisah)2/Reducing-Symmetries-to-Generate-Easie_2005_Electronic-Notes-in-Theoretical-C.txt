Finding countermodels is an effective way of disproving false conjectures. In first-order predicate logic, model finding is an undecidable problem. But if a finite model exists, it can be found by exhaustive search. The finite model generation problem in the first-order logic can also be translated to the satisfiability problem in the propositional logic. But a direct translation may not be very efficient. This paper discusses how to take the symmetries into account so as to make the resulting problem easier. A static method for adding constraints is presented, which can be thought of as an approximation of the least number heuristic (LNH). Also described is a dynamic method, which asks a model searcher like SEM to generate a set of partial models, and then gives each partial model to a propositional prover. The two methods are analyzed, and compared with each other.

Compared with theorem proving, the subject of disproving false conjectures has been less studied. But it is actually very important, since for open ques- tions, you do not know whether the conjecture holds or not. If you give a false conjecture to a typical resolution-based theorem prover, the prover either runs forever or terminates without producing any useful information. When this

Currently, there are roughly two main approaches to finite model genera- tion in the first-order logic. The first approach translates the problem into a satisfiability (SAT) problem in the propositional logic, and uses a SAT algo- rithm (e.g., the DPLL algorithm) to solve it. See for example, [6,8,1,5]. The second approach treats the problem as a constraint satisfaction problem, and uses backtracking search to find the interpretations of the functions/predicates directly. Tools like FINDER [11], FALCON [14], SEM [16] and Mace4 [9] are based on this approach. Gandalf [13] implements both approaches.

Each of the above two approaches has some benefits and weaknesses. For example, the translation approach may generate too many propositional for- mulas, and the constraint solving (or direct search) approach may not be so efficient on some problems. But using the first-order clauses directly leads to larger reasoning steps and also gives us opportunity to eliminate symmetrical subspaces.

We have been studying how to combine the two approaches. One way is to improve the direct search procedure by incorporating successful techniques developed in the SAT community [4]. Alternatively, we can also improve the translation approach by combining it with first-order model searchers [15]. This paper compares different ways of exploiting symmetries in the problem specification, so that the resulting SAT problem instances are easier. Some examples and experimental results will be given.

The paper is organized as follows. In the next section, we recall some basic concepts and notations, as well as two approaches to model finding. In Section 3, we give an example showing the importance of reducing symmetries. Then we present two approaches for adding constraints to the original problem so as to obtain easier propositional problem instance(s). The first one is static, which produces only one instance; and the second one is dynamic, which usually generates more than one instances. Examples are given to show their strengths and weaknesses.

The finite model generation problem can be stated as follows. Given a set of first order formulas and a non-empty finite domain, find an interpretation of all the function symbols and predicate symbols appearing in the formulas such that every formula is true under this interpretation. Such an interpretation is called a model. Usually we also assume that the formulas are all clauses, and every variable in a clause is (implicitly) universally quantified.

Alternatively, we can also search for the values of the cells directly. A finite model generation problem may also be regarded as a constraint satisfaction problem (CSP), which has been studied by many researchers in Artificial In- telligence. The variables of the CSP are the cell terms, i.e., ground terms like f (0, 0) and f (0, 1). The domain of each variable is Dn (except for predicates, whose domain is the Boolean domain). The constraints are the set of ground instances of the input clauses. The goal is to find a set of assignments to the cells (e.g., f (0, 1) = 2) such that all the ground clauses hold.

Typically backtracking search is used to solve the above problem. The basic idea of the search procedure is roughly like the following: Repeatedly extend a partial model (denoted by P mod) until it becomes a complete model (in which every cell gets a value). Initially P mod is empty. P mod is extended by selecting an unassigned cell and trying to find a value for it. Of course, when no value is appropriate for the cell, backtracking is needed and P mod becomes smaller. Such a procedure may be depicted as a search tree. Each edge of the tree corresponds to choosing a value for some cell.

The propositional satisfiability (SAT) problem has been studied for more than 40 years. Many theoretical results have been obtained, and many efficient algorithms have been designed. In recent years, more and more highly efficient SAT solvers are being developed, such as zChaff [10] and BerkMin [3].

When asked to find a 13-element model of the above formulas, MACE 2.2 [8] takes 9.34 seconds to conclude that such a model does not exist. Most of the time is spent on SAT solving rather than obtaining the propositional clauses (DPLL time: 9.09 seconds). If we add the following two clauses to the input:

The above two clauses represent the initial two steps taken by SEM [16]. Note that in the first step, there is only one branch, i.e., SEM decides that only the value 1 can be assigned to c(0). Similarly, in the second step, there is also one choice. So adding the two clauses does not change the satisfiability of the original problem.

When solving the quasigroup problems, Fujita et al. [2,12] add a few clauses which eliminate quite many symmetrical subspaces. This greatly reduces the search time. But the additional constraints are domain-specific, namely, they can only be applied to quasigroup problems and other similar problems.

The LNH is a more general method. We can simulate it by adding cer- tain constraints. This kind of static symmetry reduction is implemented in Paradox. See Section 6 of [1]. A similar method is adopted in SAGE [5]. For simplicity, we assume that no domain elements appear in the input and that there is only one binary function symbol f. SAGE adds the following constraints (denoted by Cf ):

It can prune the search tree greatly, since we now need to examine only 2 (instead of n) values for f(0,0), only 3 (instead of n) values for f(0,1), ... To get an understanding of its effectiveness, let us look at the QG5 problem.

Suppose we try to find all of its models. If we do not use any method for eliminating isomorphism, there are 120 models of size 7, and 720 models of size 8. If we add the above three Cf formulas to the input, there are 24 models of size 7, and 24 models of size 8. But when we use the LNH, there is only one model of size 7, and one model of size 8.

If we use no additional constraints to eliminate symmetries, we will find 80 models. If we add the C1 constraints when generating the propositional clauses, 16 models will be found. If we add both C1 and C2 constraints, then only 9 models are found.

Thus adding the above constraints is quite helpful for eliminating isomor- phic subspaces. Of course, we can ask SEM to go beyond the 3 steps and more subspaces can be eliminated. In general, more than one SAT instances are generated using this approach.

If we are just looking for one model, it is not necessary to generate all the partial models. In this case, it will be beneficial to combine SEM with a SAT solver more closely, as done in [15]. Then as soon as one partial model leads to a full model, SEM can be terminated and no more partial models need to be generated.

In this paper, we discussed two different approaches. The first one is static, which adds some formulas to the input and then gets a set of propositional clauses in the conventional way. Only one SAT instance is generated. We presented a procedure for adding the formulas, which is an approximation to the least number heuristic. It can usually eliminate many isomorphic models, and makes the resulting SAT instance easier.

The second approach is dynamic, which uses a first-order model searcher to derive some partial models, and then gets a number of SAT instances (each corresponding to a partial model). Comparatively speaking, this approach can usually eliminate more isomorphic models. But for some problems, there may be too many partial models.

