We propose a behavioural extension of the concept of interface of components. We aim to uniformly reason about correctness properties of both closed and open component-based systems. The characterizing feature of our approach is that we perform a local analysis over nite fragments of interactions naturally modeling mobility and coordination aspects. We present a semi-automatic technique that reduces the veri cation of security properties of protocols to the veri cation of correctness in component-based systems.

Interaction patterns describe both the behaviour of components in terms of the communications they can perform, and the communication channels the components initially o er to the environment. We already remarked that interaction patterns can express only nite behaviours. The abstraction of the composition environment is called context, i.e.  a multiset of connected where in( c,query) (resp., out( c, z)) is a synchronous input (resp., out- put) action on the channel c, where query and z are the transmitted data, and ( c) denotes the channel that can be used to connect the server to other components.

A component may send and receive data (D) over channels (C) by per- forming synchronous communication actions (in and out). As in -calculus, channel names can be exchanged in communications. The signature D of data can be arbitrarily complex by allowing, for example, structures for method in- vocations as well as encryption mechanisms (see Section 3). Input actions on a complex term d synchronize with outputs that provide a term compatible via pattern matching with d. The set of names C contains the distinguished name net, which is known by every component in the system. The name net has been introduced to model all the untrusted communications that may occur over the net and to which every component can participate. The silent action names of those interaction patterns that belong to the same context. Once an open name has been connected, it is not anymore available to the environment, and it is removed from the set of open names. Besides the static incremental construction of a system, the same connecting mechanisms models also the dynamic interplay of components that intend to join a running environment, like, e.g., in the case of code mobility. The following example shows the composition of components inside a context.

The above framework permits us to describe nite fragments of the be- haviour of a generic component, to compose components in a system (con- text) by appropriately connecting them, and to observe the behaviour of the resulting system. It is possible to uniformly model both static and dynamic systems, by means of closed and open contexts, respectively. The two di erent scenarios need di erent formulations of correctness properties.

component that will eventually join the context. An open context is feasible if and only if there exists an interaction pattern that can join the context, and make it both closed and correct. Feasibility appears like a desirable, easy to verify, invariant in the life of an open system. For example, a mobile compo- nent should be accepted inside a site only if it does not spoil its feasibility. The following example illustrates a feasible context.

f ( s) [ out( s,query).  ( in( s, y).0 +  .out( s,break).0 ) ] g it can not be joined by a server not capable of handling break events: ( c) [ in( c,query).  out( c, z).0 ]

A secure protocol does not permit unintended accesses to, or modi cations of its \sensible" data. In this sense, the security of a protocol is reduced to the identity of some communicated data. Determining the data and the values whose integrity implies the desired security property is the crucial task. To give a avor of this step of the methodology, let us consider a simple protocol. The protocol states that a principal A rst sends (or better, intends to send) a key k to principal B, then it sends B a nonce n encrypted with k: where fngk, like in the spi-calculus, is the encryption of n with the key k. Communication actions encapsulate the encryption and decryption mecha- nisms: The attempt to receive an encrypted data by means of a key k, e.g. in(net,fxgk ), will succeed only if the sent data are encrypted with k, oth- erwise a deadlock will occur. On the other hand, it is possible to receive an encrypted data as is, i.e. in(net, x), without attempting to decrypt it.

No more messages are available at the moment. The intruder (who now knows k and also n) sends k' to B, where k' 6= k is a key generated by the intruder. The intruder then sends fmgk0 to B, which reduces to ()[0] (as A did at the previous step).

Several formal techniques have been recently proposed for the analysis of security protocols (see e.g. [1,9] and the references therein). On the other hand, a large body of foundational models address the problem of component composition (see e.g. [2,3,4,7,11]). The distinguishing and novel feature of our approach is to provide formal mechanisms to locally and uniformly reason on both composition and security in open system. To the best of our knowledge, only [12,13] address the issue of reasoning about secure composition of compo- nents, by considering the coordination of components that may be (partially) untrusted. Components are enclosed into wrapper programs to encapsulate and enforce security policies.

Our recent work [5] has been devoted to extend the framework presented in this paper in order to handle multiple sessions and authentication protocols, and to generalise the notion of magic instance so as to allow the speci cation of arbitrary relations among data and principal instances. Security properties are hence expressed in general as logic formulae rather than as magic instan- tiations. In spite of its simplicity, the proposed logic permits to express other classes of security properties. Current work is devoted to validate further the proposed methodology by experimenting its application to the work-bench examples of [8].

