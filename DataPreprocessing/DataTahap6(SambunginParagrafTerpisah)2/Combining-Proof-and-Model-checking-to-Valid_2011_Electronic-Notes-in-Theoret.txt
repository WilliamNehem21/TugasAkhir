The remainder of the paper is organised as follows. After giving a motivating example in Sect. 2, the B method and its tools supports are introduced in Sect. 3. We formally define a generic B model of component architectures in Sect. 4. This model is then instantiated to validate a particular architecture in Sect. 5. To automatically verify temporal properties, Section 6 introduces FTPL and gives its translation into LTL. Finally, Section 7 concludes before discussing related work.

B is a formal software development method used to model systems and to reason about their development [1]. When building a B model, the principle is to express system properties which are always true after each evolution step of the model, the evolution being specified by the B operations. The verification of a model correctness is thus akin to verifying the preservation of these properties, no matter which step of evolution the system takes.

Tool supports, such as B4free or AtelierB 3 , automatically generate proof obli- gations (POs) to ensure the consistency in sense of B [1]. Some of them are obvious POs whereas the other POs have to be proved interactively if it was not done fully automatically by the different provers embedded into AtelierB. Another tool, called ProB 4 , allows the user to animate B specifications for their debugging and test- ing. On the verification side, ProB contains a constraint-based checker and a LTL bounded model-checker with particular features; Both can be used to detect various errors in B specifications [18,19].

The add(subComponent,composite) operation must establish that the both components are instantiated components, composite is a composite component (i.e. a component without parameters). Moreover, subComponent is not a sub-component of another composite nor is already used: none of its interfaces is bound or delegated. Finally, the modification does not introduce a cycle into Parent.

The unbinding primitive opera- tion is specified as follows: this operation expresses as precon- dition that the considered inter- face is provided by an instanti- ated component. This provider must be stopped. Moreover, a re- quired interface bound with the considered interface, must exist. Then, the considered interface is removed from Binding.

The FTPL property presented in Example 1 has been translated into the LTL formula below. This formula has been partially checked with ProB in 126 millisec- onds. The model checker generates 2002 atoms and 16064 transitions when the maximum number of new states is 1000.

In the Fractal-based framework, the work in [17] has defined integrity constraints on a graph-based representation of Fractal, to specify the reliability of component- based systems. Unlike [17], our model lays down only general architectural con- straints, thus providing an operational semantics to other component-based systems. On the integrity constraints side, the FTPL logic allows specifying architectural constraints more complex than architectural invariants in [11].

To enforce software robustness while adding adaptive behaviour, the work in [20] proposes a formal framework for the Fractal component model, named FracL. Like our B-based proposal, the FracL static approach allows verifying the consistency of the application architecture. However, our proposal allows checking the model consistency and monitoring temporal properties, both fully automatically.

