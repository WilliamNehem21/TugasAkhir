Describing and reasoning about asynchronous distributed systems is often a difficult and error prone task. In this paper we experiment the Input/Output Automata framework as a tool to describe and reason about cryptographic protocols running in an asynchronous distributed system. We examine a simple certified email protocol [5], give its formalization using the IOA model, and prove that some security properties are satisfied during the execution of the protocol.

In order to provide some form of protection, cryptographic techniques have been employed to obtain additional guarantees on the email service. A number of certified email protocols has been presented in literature, ensuring that the message exchange procedure provides the participants with different security properties. Usually such protocols involve a trusted third party (ttp for brief) which controls the behavior of the participants, helping them in the message exchange, and resolving any dispute if necessary. According to the role played by the ttp, protocols have been classified as inline or optimistic. In inline protocols [3,5,14,15], the ttp is actively involved in each message exchange. In optimistic protocols [1,2,9], the sender and the receiver perform the message exchange without the intervention of the ttp but they can invoke the ttp to resolve any dispute, caused for example by a cheating attempt from one of the party.

P KB (m): denotes the encryption of message m using the public key of user B in some public-key encryption algorithm. The algorithm should provide non-malleability, i.e., given a ciphertext it is impossible to generate another ciphertext such that the respective plaintexts are related.

for communication from node i to node j. The state is a list of all the vari- ables that describe the state of the automaton. For this channel the state is completely described by a variable that contains the messages still in transit on the channel.

The channel has an input action Send(m)i,j which is controlled by another (unspecified in the example) automaton A, modeling node i, which has the same action Send(m)i,j as an output action. Whenever automaton A executes this action also the channel executes the action (at the same time), we will say that the action Send of A controls the action Send of channeli,j . In this case the effect of the action, in the channel automaton, is to add a message in the set of in transit messages.

The channel has an output action Receive(m)i,j which has a precondition (a boolean condition) specifying when the action is enabled, that is when the action can be executed. An output action can be executed whenever it is enabled. Moreover, all other automata that have such an action as input will execute it. There will be an automaton B, modeling node j, that has Receive(m)i,j as an input action.

There are also internal actions that are similar to output actions (i.e., have a precondition and an effect) with the difference that they do not interact with other automata (i.e., several automaton may have internal actions with the same name and they are all independent). We use the notation name.var to indicate variable var of automaton name, for example channel.Msgs refers to variable Msgs of automaton channeli,j .

Non-repudiation of delivery. The protocol provides the mail originator with an irrevocable proof that the mail content received by the recipient was the same as the one sent by the originator. This proof-of-delivery can protect against any attempt by the recipient to falsely deny receiving the message.

Fairness. Proper execution of the protocol ensures that the proof-of-delivery from the mail recipient and the proof-of-origin from the mail originator are available to the mail originator and recipient, respectively. Moreover, the protocol must be fail-safe. That is, incomplete execution of the protocol will not result in a situation where the proof-of-delivery is available to the originator but the proof-of-origin is not available to the recipient, or vice versa.

We can now start with the description of the automaton actions, and will proceed by looking at each of them in the order they appear in the code from top to bottom, left column first. This order corresponds to the logical order in which the actions are executed. Notice the use of the unique identifier id: it is attached to all the messages concerning a particular email: this is just to avoid interference with possible delayed messages from other sessions.

Constr M1. Variable StatusSnd is set to send so that the only (non-input) action that is enabled is the Send action. This action interacts with the channel to the recipient j and sends the message stored in M1 . The program counter goes into a wait state wait. All the non input actions are not enabled now. The execution proceeds when a message is received from the ttp. When this message is received, it is stored into variable M4 . The program counter is updated to done. At this point the protocol has terminated successfully and nothing else has to be done. The output action Send is in a task, so in a fair execution it has infinitely many opportunities to be performed.

We next describe the actions, top to bottom, left to right. The Lose action models the delivery of a corrupt message. The program counter StatusRcv is set to discarded and the protocol is aborted. The first Receive action takes a message from the channel and starts processing the incoming message.

