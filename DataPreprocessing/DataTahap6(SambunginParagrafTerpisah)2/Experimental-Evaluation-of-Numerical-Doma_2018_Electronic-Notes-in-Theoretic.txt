Many numerical abstract domains have been defined in the literature with the aim of discovering relations among numerical variables in imperative programs. These abstract domains differ on the shape and number of constraints on program variables which may be represented. The most common numerical domains are the interval [14], octagon [20] and polyhedra [15] abstract domains.

According to the expressive power, we have Poly > Oct > Int and Poly > Par > Int, while octagons and parallelotopes are incomparable. Obviously, the more ex- pressive a domain is, the more accurately it may track, at least in principle, the values of program variables during the program execution. If we compare two anal- yses performed using the domains A and B with A > B, we would expect the analysis using A to find more constraints or more precise bounds than the analysis using B. However, expressiveness of a domain does not tell the whole story. At least other two factors may influence the result of the analysis: abstract operators and widening.

The widening H79 maintains all the constraints of the polyhedra in the previous iteration, under the condition that the constraint is satisfied by all the points in the polyhedra of the current iteration. The widening BHRZ03 improves on the standard widening by combining four different heuristic techniques, derived from upper bound operators. Both widenings present cases where they lose precision in such a way that the resulting analysis is less precise than what may be attained even with the much simpler interval domain. A detailed example appears in [21].

From the theoretical point of view, it is easy to study the computational com- plexity, in space and time, of the abstract operators. Most operations on intervals are linear in the number of variables. For octagons and parallelotopes operations are at most cubic on the number of variables, while polyhedra have a worst-case exponential complexity on the number of variables.

However, just knowing how each abstract operator behaves does not give a com- plete account of the performance of a domain in a real analysis. In particular, predicting the behavior of polyhedra is difficult because the cost of operations heav- ily depends on the complexity of the polyhedra found during the analysis. Therefore, there are cases when polyhedra are faster than octagons, and cases in which they are much slower.

In this paper, we will focus on comparing the precision of analyses run with the same algorithm but different domains. However, we do not compare directly the results as returned by the analysis, for two reasons. First of all, we would get many cases of incomparable results. Second, domains such as parallelotopes and polyhedra find many complex constraints involving a lot of variables which, although may be useful to track the execution of the program, are not particularly useful in the final result.

Generally, simpler constraints are more easily applicable. For example, interval constraints may be used to prove that some run-time errors, such as division by zero or out-of-bound access to array, do not occur in practice. In case it is needed, simple program transformations may replace complex expressions with new synthetic variables, so that every interesting constraint in the original program becomes an interval constraint in the transformed one. Moreover, interval constrains are the largest set of constraints which can be explicitly represented in all the domains. For these reasons, we think that evaluating the precision of the analysis only on the interval constraints is a valuable approach.

We also include for completeness a different comparison on octagonal constraints. These constraints are useful, for example, to check for out-of-bound array accesses when arrays are created with a dimension known at run-time only. However, since new synthetic variables may be created to transform all problems to interval check- ing problems, we think this comparison is not as relevant as the one on interval constraints.

Benchmarks were performed using the Jandom static analyzer [3] on the ALICe benchmarks [19]. Jandom is an analyzer for simple imperative programs, linear tran- sitions systems and Java bytecode. Intervals, parallelotopes and their product are natively implemented in Jandom. For octagons and polyhedra we use the implemen- tation in the PPL.

The test-suite comprises a total of 108 models (linear transition systems) with a total of 326 locations, 161 of which are loop heads. Each model has at most 11 different locations, 4 loop heads and 10 variables. Most of the models (102 out of 108) are part of the ALICe benchmarks, the remaining 6 are taken from our previous work.

For each model a classical two-phase analysis is performed, consisting of an ascending chain with widening and a descending chain with narrowing. Widening and narrowing are applied on all loop heads. For polyhedra, the trivial narrowing which always returns the previous value of the descending chain is used. A delay is applied for both widening and narrowing. We have experimented with different values of the delay: for widening, we have used values between 0 and 6, while for narrowing values between 0 and 3. Further experiments carried out with bigger narrowing delays are not shown here, since there are practically no improvements.

The case with narrowing delay 0 is very unfavorable for polyhedra, since it means that no descending chain is performed at all. It is shown only for completeness, but it is not particularly interesting in practice. Actually, if we exclude the polyhedra domain, delayed narrowing seems to have a very marginal benefit. Results for in- tervals and octagons, in particular, do not show any improvements with delayed narrowing. The fact that descending chains are generally quite short was already observed in [1,2].

which also loses precision when narrowing delay is 0 and widening delay increases from 4 to 5. Finally, polyhedra with H79 widening hardly combines with delayed widening: precision is lost moving from delay 0 to delay 2. From delay 3 onward the analysis recovers some lost precision, but it never comes back to the precision it had with delay 0.

From the point of view of performance, the execution time of intervals, octagons and polyhedra are as expected. Intervals are much faster than anything else. For low values of widening delays, speed of octagons and polyhedra is comparable, but for high value of delays, octagons are faster. Parallelotopes and their reduced product with intervals are the slowest domains. Although this contrasts with the theoretical results, actually it is due to the fact that while octagons and polyhedra are part of the PPL, which is written in C++ and highly optimized, parallelotopes are written in Scala with a functional style which is not particularly well suited for this kind of application.

We have compared the relative precision of polyhedra, intervals, octagons, paral- lelotopes and a reduced product of parallelotopes and intervals w.r.t. the interval constraints on the ALICe benchmarks using the Jandom static analyzer. We have shown that, although the polyhedra domain is theoretically the most precise for inferring linear relationships, in practice the less expressive domains can find more precise results, in particular the reduced product of parallelotopes and intervals. We have also shown that delayed widening generally improves precision of the results up to a certain value (around 3, 4) with the exception of the polyhedra domain with standard widening, where it has a detrimental effect. Finally, we have shown that delayed narrowing has no significant effect on the precision of the analysis, with the exception of polyhedra domain which, lacking a narrowing operator, needs at least a delay of one during the descending phase to take a step.

