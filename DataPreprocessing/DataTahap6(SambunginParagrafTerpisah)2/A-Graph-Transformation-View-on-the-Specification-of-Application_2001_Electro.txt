Highly distributed networks (e.g. Internet) have now become a common plat- form for large scale distributed programming. These environments are often called open environments, being characterized by: massive geographical dis- tribution; high dynamicity (appearance of new nodes and services); no global

Research e orts have been directed to manage this complexity through the development of new paradigms, theories and technologies for distributed applications. Within this context, code mobility [11] has received special at- tention due to its exibility and potential use in various application elds, like network management [11], electronic commerce [19], distributed information retrieval [16], advanced telecommunication services and active networks [27], active documents, work ow management systems, and disconnected opera- tions (namely, the ability to launch remote computations, switch o the local node (e.g., a laptop), switch on the node later, and receive the results of the remote computations).

Currently there are standards, platforms and languages available for mobile code [22]. Java is being widely used due to high portability and dynamic bind- ing, among other features. However, there are still problems to be addressed in order to build a sound support for mobile code. One of them is the lack of formal basis: the ideas around mobile code and active networks and their implementations emerged from a practical approach. An abstract semantic framework (including methods for speci cation, veri cation and analysis) to formalize the model of computation of Internet applications is clearly needed, and missing. Such semantic framework may provide the formal basis to dis- cuss and motivate controversial design/implementation issues and to state and certify properties in a rigorous way.

Places represent the needed infrastructure to support mobile applications. This infrastructure comprises hardware and software (middleware) support to o er locations where mobile components can run, move into and leave. Beyond these basic functions, places can be con gured to support additional functionalities as needed. While building mobile applications, the developer assumes that places o er a given level of functionality. The lowest level is the support to mobility and to communication among components in the same place.

Mobile components  are software components that, during their execution, may migrate from place to place to use other components as well as basic facilities like processing power, storage and communications. A mobile com- ponent has internal data or state, code, and a set of meta-data or attributes (e.g. identi er, credentials, originator, operational status, etc.). Mobile appli- cations can be build from various mobile components, which may run concur- rently and cooperate.

Open/Dynamic environment: Places must o er a basic functionality level and be easily con gurable in order to better t the goals of the distributed in- frastructure. In many situations, places must be highly customizable in order to support di erent applications in a distributed environment. It is important to easily install components in various places and use them afterwards (e.g. for active networks).

The distributed environment considered is characterized by being open. Software components and places are independent in the sense that they have distinct ownership and therefore distinct authorities to decide upon their man- agement. In such an environment, these entitites have distinct life-cycles, and no global state can be provided/obtained. Nonetheless, entities often cooper- ate in order to achieve their goals.

Failures: While designing a distributed application the designer has to as- sume some behavior of the environment where the application is to run. This has already been stated for places. Another very important aspect is to con- sider the failure behavior of the environment. Therefore it is desired that the designer may state the expected failure behavior of the environment and build its application to work on it.

Using Graph Transformation Systems, it comes natural to model places and components as nodes, and the relations modelling spatial distribution (like adjacency of places, presence of a component on a place, ...) as edges. Actually, the possibility of having an explicit representation of the system's topology is a strong point in favour of this speci cation formalism.

tems exists, see [8] for an informal comparison of some of them. In all such approaches a module includes at least a description of the class of graphs handled by the modules (for example, via a type graph) and a collection of graph transformation rules. Concerning the export interfaces, some of the approaches (like GRACE [14] and PROGRES [25]) only allow to export pro- cedure names, while others (like DIEGO [26] and TGTS [12]) also allow to export rules. This feature could be used to describe abstractly the behavior of the component in terms of kinds of observable events (for example, mes- sages received/sent by a component). This would allow for a rely{guarantee approach [6].

Dynamic environment: In many situations, it is interesting to allow the creation of multiple instances of the same component. For example, if there is a list of places to visit asking for some information, one could create one mobile component to visit each of the places and bring the information back. The only di erence among them is the place they have to visit. Some approaches to modularity in graph transformation allow one to specify formal parameters for modules. For example, in both PROGRES and CGSPEC [7] the procedures exported by a module may have parameters that can bound by the client at instantiation time.

Components may die at any moment, even if other components have point- ers to them (for example, know their names). The middleware is responsible for handling these situations: it warns a component in case it tries to com- municate with a non-existing component. Also, the middleware may support distributed garbage collection. In this case, a component does not die but may

In a graph transformation approach, a possible way to handle deletion of components is to mark them as dead and provide (exception) rules for handling the cases when a component tries to communicate with them. These rules, as well as those for distributed garbage collection, if any, should be part of the speci cation of the middleware, as this is a service provided by this level. It would be desirable to have exceptions handled by the semantics in a clean way.

Failures:	Mobile code applications have to cope with the unreliability of the open environment. Typically, one should provide levels of con dence in the implementation of this systems. For example, one may want to ensure that provided nothing fails, the system behaves as expected; or that if some servers (these must be speci ed) fail, the system still behaves correctly, etc. Sophisticated analysis techniques would be needed for addressing such issues. An approach to the static analysis of graph trasformation systems is pro-

A rst attempt in this direction is reported in [4,5], where a restricted form of graph grammar is used to model code mobility. Components, places and messages are modeled as nodes. The behavior of places is speci ed by rules which realize typical middleware functionalities, like forwarding messages to agents located on a remote place, or handling the migration of agents. The behavior of each component is speci ed in a reactive way: each rule must delete a message vertex, meaning that this message triggers the application of this rule. No true module concept is used in the speci cation, but there are some further restrictions to rules to assure encapsulation properties of components.

[7] Ehrig, H. and Engels, G., Pragmatic and semantic aspects of a module concept for graph transformation systems, in Proceedings Fifth Int. Workshop on Graph Grammars and Their Application to Computer Science, Lecture Notes in Computer Science, vol. 1073, Springer, 1996, pp. 137{154.

