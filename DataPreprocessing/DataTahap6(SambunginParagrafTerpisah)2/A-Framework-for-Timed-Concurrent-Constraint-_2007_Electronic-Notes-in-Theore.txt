The timed concurrent constraint programming language (tccp in short) was introduced for modeling reactive systems. This language allows one to model in a very intuitive way typical ingredients of these systems such as timeouts, preemptions, etc. However, there is no natural way for modeling other desirable features such as functional computations, for example for calculating arithmetic results. In fact, although it is certainly possible to implement such kind of operations, each single step of the computation takes time in tccp, and avoiding interferences with the intended overall behavior of the (reactive) system is quite involved.

The programming language Timed Concurrent Constraint Programming (tccp in short) was introduced by F. de Boer et al. in [3] for modeling reactive systems, i.e., concurrent systems which continuously interact with the user (and generally do not terminate). tccp was defined as an extension of the ccp model introduced by

Saraswat in [12], which was ideally thought of as a simple but powerful model for concurrency. The tccp language introduced two main modifications to the original ccp model. On the one hand, an implicit notion of (discrete) time was included in the semantics of tccp. On the other hand, a new conditional agent was introduced, which is able to handle negative information that can be used to model timeouts and preemptions.

In this paper, we propose an extension of tccp for modeling instantaneous func- tions which allows us to simplify and speed up arithmetic calculations. Although it is possible to implement arithmetic functions in tccp, the resulting implementation of such functions is quite far from being intuitive. Moreover, these computations consume unspecified amount of time, thus making the synchronization of processes more difficult. For example, a given process might need some data that another process is committed to compute, and this computation might take some time de- pending on the data size. Thus, the calculation might slow down and eventually disorder the overall execution of the system. We illustrate this problem by means of an example in Section 3.

The new capability presented here can be used as a new tool for developers from the verification point of view. It is well-known that verifying concurrent systems is highly complex. In the context of tccp, where the synchronization among processes is manually programmed, badly implemented calculations may cause synchroniza- tion errors and even mask other communication anomalies which then become more elusive to capture. In such cases, the possibility to perform an independent verifi- cation for the reactive and the functional components of the system can be a very helpful facility. External functions written in a functional language can be seen as a specification of tccp function implementations and the programmer can check the implementation of the whole tccp system by using the version with the external functions. Assertions which use the external functions can also be introduced in the tccp program, thus automatically verifying that they are satisfied during the program execution.

In Section 2 we first introduce the tccp language, then in Section 3 we motivate the proposed extension of the language by means of an example. We also provide the semantics for the new construct. In Section 4 we illustrate the proposed extensions by means of a representative example (the model of a coffee machine). We discuss how we can use the new features to check tccp programs in Section 5. Finally, some lines of further work and our conclusions are in Section 6.

The tell agent tell(c) adds the (atomic) constraint c to the global store. c must be a constraint from the underlying constraint system.. The semantics of the agent establishes that the constraint c is only available in the following time instant. In other words, the execution of the tell agent takes one instant of time. The choice one of the branches Ai among theses whose guard ci is satisfied by the store at that time. When a branch is taken, the execution of the corresponding Ai agent starts in the following time instant. This means that also the execution of the choice agent takes one instant of time. If no guard is entailed by the store, then the choice agent suspends. In such cases, it is executed again in the following time instant.

For example, the execution of the agent (goal) mult(3,3,Result,Sync) instan- tiates, after a certain amount of time, variable Result to 9, and Sync to 1, which signals the termination of the process. This particular execution takes 8 instants of time, and what is more important, the time needed to finish a computation directly depends on the input values of the call. A detailed trace of this execution can be found in [2].

Next we explain the most important points in the specification of the coffee machine. The complete code of this program can be found in [2]. First of all, let us recall that streams are used in tccp to record the change of state. Each single variable is associated to a stream (implemented as a logical list); that is, each element of the list represents the value of the variable at a given time instant. This allows us to handle imperative variables in the same way as logical lists are used in concurrent logic languages. We write X = [Y |Z] for denoting a stream X recording the current value Y of the considered variable and the stream Z of future values of the same variable. Streams are also used in tccp as explicit communication channels between tccp agents as illustrated in this section.

The structure of the declaration is as follows: Depending on the product chosen by the user (which is recorded in the Order stream), the machine checks the stream Cash to determine if enough money has been introduced. Here we use a function paid to calculate the total amount of money introduced. This function is externally implemented (in Curry) by simply adding the values of the different kinds of coins recorded in stream Cash.

Whenever the total amount is greater than the price of the product, we start the process of supplying the product and (if necessary) returning the change, which depends on the number of coins of each kind the machine has. Note that change is again an external function, which represents the number of coins that the machine must return to the user. The following code excerpt shows the implementation of the change function, where Price represents the cost of the chosen product, C the number of coins in the case of the machine, and Input the coins that have been introduced by the user. The auxiliary function coinsFor calculates the total amount of each kind of coin that the machine will give back to the user.

If an order is initiated and sufficient money has been introduced, then eventu- ally the order is correctly completed (i.e., the product is supplied, the change is correctly returned, the Case is consistently updated and the status of the machine is reset); otherwise the machine returns the money.

These function calls in the program can be seen as a means to introduce in- variants or assertions along the code. Such invariants are checked during system execution, and the execution is interrupted in case one of the assertions is not sat- isfied. Obviously, the invariants should not corrupt the behavior of the original system, and it is the programmer who must take care of the synchronization.

