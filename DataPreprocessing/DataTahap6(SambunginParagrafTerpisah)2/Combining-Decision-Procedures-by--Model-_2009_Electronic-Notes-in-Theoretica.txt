The application of formal methods to the design of computing systems often results in the generation of verification conditions that need to be proved in order to guar- antee the correctness of the result. Such verification conditions express properties of models or relations between models and may be expressed in a wide range of log- ics: from propositional to high order logic, but also process algebra and temporal logic. Hence the level of automation for verification in a specific formalism is tightly dependent on the availability of tools to support reasoning in such logics.

The next section introduces notations and the basics of SMT-solvers. In Sec- tion 3 we present an abstract framework for describing SMT-solvers. It only serves to discuss the soundness and completeness of the combination framework we de- scribe in this paper. It is not as detailed as the DPLL(T ) framework [18] since it is not meant to be a precise description of solvers. By contrast to the DPLL(T ) frame- work and for simplicity, our schema highlights the distinction between the Boolean reasoning and the theory reasoning. It is not difficult to understand DPLL(T ) as being a refinement of our schema.

Since the bottleneck of the cooperation between proof assistants and SMT- solvers is not the efficiency of the SMT-solvers, our focus has not been much directed towards the efficiency of our implementation. In particular, we do not implement theory propagation (see for instance [18]). However, we observed that for the specific QF UFIDL benchmarks reported to work particularly well for [7], our implementa- tion works as fast as in Z3 [8].

Future works include applying this technique to other decidable fragments (for instance full linear arithmetic on integer and reals). Also, our implementation includes a full-featured first-order theorem prover that handles user theories. We will then investigate the benefits of our framework in presence of such user defined theories.

