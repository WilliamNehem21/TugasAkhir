The imperative statements in Creol are now briefly introduced. In addition to standard statements, Creol offers a few statements that are only relevant in a con- current or distributed context. Basic statements are discussed in this section and composition operators in Section 4.4.

Without the await statement, the program would block on the reply statement l?(result) until the associated method invocation had terminated. This is the standard behavior of transparent futures (e.g., [11]), in which case the reply state- ment could be made implicit by identifying l with reply.

Method calls may be local or remote. Local synchronous calls correspond to the case where o is omitted or evaluates to self and are executed immediately in order to avoid deadlocking the object. In contrast, a remote synchronous call o.m(e; y) is implemented as an asynchronous method invocation t!o.m(e) followed by the reply statement t?(y), for some fresh label t. Because there is no await statement between the method invocation and the reply statement, the calling object is blocked while the remote method executes. The values assigned to the output parameters become available in y.

In order to understand the choice operator, the following definitions are used. A statement S is enabled if it can execute in the current state without releasing the processor immediately. For example, await b is enabled if b evaluates to true; otherwise it is disabled. If s is enabled and does not block immediately, then we say that s is ready. The statement l?(y) is always enabled, but it is only ready if the reply associated with l has arrived.

In both method bodies, two asynchronous method calls are made: one to server1 and one to server2. In the first method body the nondeterministic choice selects the first reply which arrives for further processing, and the other reply is ignored. In the second method body, both replies are processed, but the order of processing depends on which reply arrives first. (The second method body suggests a nondeterministic merge operator, discussed in [30].)

In this paper, focus has been on the basic model of concurrency and communication in Creol. A more in-depth discussion of this model and its formal semantics may be found in [30]. The integration of first-class futures in Creol is discussed in [17]. An industrial case study of the ASK communication system in Creol is presented in [4]. Type systems for asynchronous method calls are developed in [36] and for the full language in [35]. An extension of Creol for service-oriented computing is presented in [13] and for wireless communication in [32]. Creol further supports runtime reprogramming of distributed systems by means of a dynamic class construct which allows objects of a class and its subclasses to gradually evolve in a type-safe way without interrupting the overall system execution [33,42].

