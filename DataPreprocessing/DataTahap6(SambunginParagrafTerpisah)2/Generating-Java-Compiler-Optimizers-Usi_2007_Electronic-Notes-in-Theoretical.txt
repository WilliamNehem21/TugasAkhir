a new specification language based on the bidirectional CTL that can express typical optimization rules very naturally. By adding rewriting conditions to allow for temporary variables and considering real-world language features such as exceptions, the system can perform optimization of Java programs. So far, a com- piler optimizer using temporal logic was assumed to be impractical, because it consumes too much time. However, with our method, the generated Java compiler optimizer can compile seven of the SPECjvm98 benchmarks with a compile time from 4 seconds to 4 minutes.

Current optimizers are almost always implemented by some kind of programming language. However, the approach of implementing optimizers by CTL (computa- tional tree logic) [6], a branching temporal logic, has attracted interest in recent years. This approach has two main advantages.

Before model checking, free variables 4 must be bound. Therefore when there are a lot of free variables in the conditional expression, processing time becomes unrealistic. We clarify through experiment the fact that using the node numbers of the Kripke structure as free variables, as done in all previous work [9] [2] [19], will greatly increase the optimization time. Thus, formalization of optimization should be done using the least number of free variables.

The specification language we have developed does not refer to the node number of the Kripke structure. What the model checker calculates is not the instruction of a specific number but sets of instructions that satisfy the same condition. There- fore, it becomes very easy to describe a complex rewrite rule that rewrites many instructions. Moreover, efficiency is improved as the free variables corresponding to the node number of the Kripke structure are omitted.

So far, optimizers with temporal logic have been assumed to be impractical because of the amount of processing time needed. By adding some processing for real-world language features, we obtained several typical optimization phases for a Java language compiler, the performance of which is now close to optimizers that use traditional algorithms. In our research, seven of the SPECjvm98 benchmarks were able to be optimized in a time ranging from 4 seconds to 4 minutes using the aforementioned improvement.

We constructed a new model checker instead of modifying an existing model checker because we think our model checker can easily handle the program features. Also, creating our own model checker will make it easy to extend its functionality in the future such as improving the algorithm and data structures to make it more efficient, e.g., by using bit vectors (or partial evaluation).

Complex optimization like partial redundancy elimination is needed for real optimizing compilers. Many conditional formulas are necessary to specify it. The system must rewrite a set of instructions that satisfy the same conditional formula at the same time. Writing specifications in CTLbd from scratch considering the meaning and condition of optimization is difficult.

Free variables has been adopted by most previous work [9] [2] [19], as well as ours, and it seems very convenient and expressible. However, as mentioned above, binding of free variables will cause an exponential computational complexity. An example of time explosion caused by free variables will be shown in section 8. There, we use different formulas for copy propagation, one containing 2 free variables that can be bound at the MATCH stage, and another containing 4 free variables with only 2 of them able to be bound at the MATCH stage. The resulting time explosion exhibited by the latter case will be shown later. It shows that the introduction of free variables needs to be avoided as much as possible in practical compiler optimizers. We focused on eliminating unnecessary free variables when we made our optimizers.

Binding can be omitted if the target is not on the path related to the temporal formula. For example, checking instructions on the past paths can be omitted if the CTLbd formula includes only future temporal operators. Similarly, checking instructions far away from the next instruction can also be omitted if the temporal operator is AX or EX. In our experiment, when this technique is applied to the dead code elimination (which only includes future temporal operators), processing time is reduced to about 1/3.

