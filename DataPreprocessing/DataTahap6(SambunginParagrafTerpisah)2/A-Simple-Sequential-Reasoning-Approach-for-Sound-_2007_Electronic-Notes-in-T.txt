We propose a programming model for concurrent programming in Java-like lan- guages, and the design of a set of program annotations that make the use of the programming model explicit. For instance, a developer can annotate his code to make explicit whether an object is intended to be shared with other threads or not. These annotations provide sufficient information to static analysis tools to verify if locking is performed correctly: shared objects must be locked before use, unshared objects can only be accessed by the creating thread. Moreover, the verification can be done modularly, hence verification scales to large programs.

A data race occurs when multiple threads simultaneously access the same variable, and at least one of these accesses is a write access. Developers can protect data structures accessed concurrently by multiple threads by associating a mutual ex- clusion lock with each data structure and ensuring that a thread accesses the data structure only when it holds the associated lock. However, mainstream program- ming languages such as Java and C# do not force threads to acquire any locks before accessing data structures, and they do not enforce that locks are associated with data structures consistently.

An additional complication is the fact that the implementation of a method may assume that an object is already locked by its caller. Hence, the implementation will access fields of a shared object without locking the object first. In such a case, merely indicating which objects are shared does not suffice. The implementor of a method should also make his assumptions about locks that are already held by the calling thread explicit in a method contract.

Object sharing. In addition to an access set, our model associates with each run-time state a global shared set S. We call the objects in S shared and objects in the complement of S unshared. The shared set, like the access sets, is conceptual: it is not present at run time, but used to explain the model and implement the verification.

formal definition of our programming model: the original annotated program P is correct according to our model, if and only if the translated program P' is cor- rect with respect to its assertions and classical method contracts. To check if the translated program P' is correct, we use an existing automatic program verifier for single-threaded programs. Our experiments show (Section 7) that state-of-the-art verifiers are capable of verifying realistic programs in this way.

objects protect global resources: code will have to acquire these resources in the statically defined order. A second strategy is to define the order based on some field of the objects involved. For instance to define a transfer operation between accounts, the two accounts involved can be locked in order of the account number, thus avoiding deadlocks while locking account objects.

In some cases the developer of a particular module may only wish to impose partial constraints on the locking order or may wish to abstract over a set of objects. For instance the developer of the Subject class in the Subject-Observer pattern may wish to specify that Observers should be locked before locking the Subject and not vice-versa. In other words, all Observers are above the Subject in the deadlock prevention ordering.

In the model, a lock level is associated with an object the moment the object is shared. This defines the lock order: for shared objects o1 and o2, we have o1 < o2 iff o1.lockLevel < o2.lockLevel . A thread is only allowed to lock an object if the object

We first briefly recall the syntax and semantics of class initialization in Java. We then present the programming model extension. The remaining subsections discuss acyclicity of the lock before relation and describe our support for classes whose static state does not change after initialization.

. This call first checks if a path already exists from M1 to M2. If so, the call returns normally. Otherwise, it checks if an edge from M1 to M2 would create a cycle. If so, the call throws an exception. Otherwise, the call adds the edge to the graph and returns normally.

The Extended Static Checkers for Modula-3 [6] and for Java [8] attempt to stati- cally find errors in object-oriented programs. These tools include support for the prevention of data races and deadlocks. For each field, a programmer can designate which lock protects it. However, these two tools trade soundness for ease of use; for example, they do not take into consideration the effects of other threads between regions of exclusion. Moreover, various engineering trade-offs in the tools notwith- standing, the methodology used by the tools was never formalized enough to allow a soundness proof.

