This paper presents scalable parallel BDD operations for modern multi-core hardware. We aim at increasing the performance of reachability analysis in the context of model checking. Existing approaches focus on performing multiple independent BDD operations rather than parallelizing the BDD operations themselves. In the past, attempts at parallelizing BDD operations have been unsuccessful due to communication costs in shared memory.

exponentially. One way to deal with this is to represent all states using Boolean functions, instead of storing them individually. This is called symbolic model check- ing [7]. Boolean functions can be stored in memory efficiently using Binary Decision Diagrams (BDDs) [1,6].

processor cores. The speedup is a measure for the performance gain of parallelizing an algorithm. If an algorithm with 20 workers is executed 5 times faster than with 1 worker, we say the speedup for 20 workers relative to 1 worker is 5. The ideal speedup in that case would be 20. In this example, the efficiency is 5/20 = 25%.

Several frameworks implement task-based parallelism, e.g. the compiler-based frameworks Cilk and OpenMP and the library-based framework Wool [17]. These frameworks support creating tasks (spawn) and waiting for their completion (sync) to use the results. We selected Wool for the parallelization of symbolic reachability for several reasons. According to [32], Wool offers superior scalability in fine-grained task-based parallelism, compared to Cilk and OpenMP. There is also a blog reporting on parallelizing the BDD package BuDDy using Cilk [20] and using Wool we expect similar results. Finally, it is quite straightforward to implement parallelism using the Wool framework.

Of course, it can be the case that multiple workers start the same suboperation, as is always the case for the initial task. However, due to the random order of handling suboperations, the workers will quickly branch off to different subtasks. So load balancing depends purely on randomization. For example, if a task has two subtasks, workers start on different subtasks with 50% probability. This increases rapidly with a larger number of subtasks.

Traditionally, concurrency conflicts like data races are solved by locks, providing mutual exclusion. Since blocked processes must wait, locks have a negative impact on the speedup of parallel programs. Recent research has been dedicated to developing non-blocking data structures and algorithms. Herlihy and Shavit [21] distinguish lock-free algorithms, wait-free algorithms and lockless algorithms. Our algorithms fall in the last category. Here explicit locks are avoided by using atomic processor instructions like compare and swap.

We encode these values in 32 bits: 15 bits for the hash, 1 bit for the lock, and 16 bits for the reference count. The reference count is prevented from integer overflow by reserving a special value SATURATED. When the reference count is saturated, it will no longer be increased or decreased.

We experimented with a representative selection of models from the BEEM data- base [31] using a symbolic BFS reachability algorithm of dve2-reach from the LTSmin toolset [4]. Experiments ran on a 48-core machine, consisting of 4 AMD OpteronTM 6168 processors with 12 cores each. This machine has a NUMA archi- tecture with 8 memory domains and 6 cores per domain. We first parallelized the BDD operations using work stealing with Wool (see Section 4.1) by implementing an experimental parallel BDD package Sylvan. 2

We also experimented using randomized load balancing (see Section 4.2) and report decent performance and scalability elsewhere [15]. The conclusion there is that this alternative approach is viable, but the approach using Wool currently gives slightly higher performance and a larger speedup.

Performance measurements with this parallel implementation demonstrated relative speedups of up to 32 using 48 cores. Compared to the popular BDD package BuDDy we get a speedup of up to 12 using 48 cores. We demonstrated that parallelizing BDD operations on a low level is a viable method to get good speedups for symbolic reachability on multi-core multi-processors with a non-uniform shared-memory architecture.

