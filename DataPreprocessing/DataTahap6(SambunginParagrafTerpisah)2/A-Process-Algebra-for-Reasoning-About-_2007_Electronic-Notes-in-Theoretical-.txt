Security protocols are, in general, composed by several agents running in par- allel, where each agent computes information (bounded by polynomial-time on the security parameter) and exchange it with other agents. In the context of quantum processes, the computation is bounded by quantum polynomial- time and the information exchanged is supported by qubits. In this paper, the problem of defining quantum security properties is addressed using a quantum polynomial-time process algebra. This approach is highly inspired in [13,9].

Thanks to the non-cloning theorem, quantum information cannot be copied without prior knowledge of its state. This observation imposes some design options in the process algebra, since it is necessary to know which agent pos- sesses a qubit in order to know who can retrieve each piece of information. In order to deal with this fact, a set of agents is fixed and the qubits are partitioned among them.

Most of the commands above are self-explanatory, but it is worthwhile to notice that all commands are deterministic with exception of measure. In- deed, according to the measurement postulates of quantum mechanics (see for instance [3]), when a quantum system is measured the outcome is stochastic, and moreover the state evolves accordingly to this outcome. Note that we only consider measurements over the computational basis, nevertheless this is not a limitation since any other qubit measurement can be performed by applying a unitary transformation before measuring the qubit over the computational basis.

Definition 2.1 A quantum polynomial machine is a triple M = (c, q, o) where c is a QRAM command, q is a positive step bounding polynomial and o is a positive output polynomial. We denote the set of all these triples by QPM.

One of the most successful ways for defining secure concurrent cryptographic tasks is via process emulation [1,2]. This definitional job boils down to the following: a process realizes a cryptographic task if and only if it emulates an ideal process that is known to realize such task. In this section, guided by the goal of defining secure functionalities, we detail the notion of emulation for the quantum process calculus defined in the previous section.

where an ideal adversary is an adversary which cannot corrupt I and a real adversary is any local process for agent a. This property asserts that given a real adversary (a : A), agent a cannot distinguish the information leaked by P ||(a : A) from the information leaked by the well behaved process I||(a : B) for some ideal adversary (a : B), and therefore, we infer that P ||(a : A) is also well behaved. This discussion leads to the concept of emulation with respect to a set of real adversaries A and ideal adversaries B.

Any interactive proof system fulfills two properties: completeness and soundness. Completeness states that if the assertion the prover wants to convince the verifier is true, then the verifier should be convinced with prob- ability one. On the other hand, soundness is fulfilled if the verifier cannot be convinced, up to a negligible probability, of a false assertion. Therefore, completeness and soundness allow the verifier to check whether the assertion of the prover is true or false.

So, a process (p : S) models a quantum zero-knowledge strategy if, from the point of view of the verifier, it is impossible to distinguish the final result of the interaction with (p : S) from the interaction with the 0 process. A clear corollary of Theorem 3.2 is that, quantum zero-knowledge is compositional.

The contributions of this paper are multiple. First, we introduced a process algebra for specifying and reasoning about (quantum) security protocols. To restrict the computation power of the agents to quantum polynomial-time, we introduced the logarithm cost quantum random access machine, and incor- porated it in the process language. Due to the special aspects of quantum information, qubits were assumed to be partitioned among agents, and the (quantum) computation of an agent was restricted to its own qubits.

