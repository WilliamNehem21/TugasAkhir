i.e. a class A is a subclass of B if the type of A is a subtype of B. In this paper this notion is extended to consider arbitrary class properties obtained by a modular static analysis of the class. In such a setting, the subclass relation boils down to the order relation on the abstract domain used for the analysis of the classes. Furthermore we show how this approach yields a more semantic characterization of class hierarchies and how it can be used for an effective modular analysis of polymorphic code.

checked. Thus there is no need of using a theorem prover or to rely on unsound methods as runtime assertion monitoring [10]. Furthermore the definition of the behavioral subtyping in the abstract interpretation framework allows to use standard techniques as for instance domain refinement [4] in order to systematically improve the precision of the observables.

place of s will not cause a run-time type error, if s did not cause one. Thus in the example, the classes Stack, PosStack and Queue have the same type so that for instance Stack may be a subtype of Queue and conversely. Only SqStack has to be a subtype of Stack, PosStack or Queue, due to method addSq. This is the only constraint on the possible class hierarchies.

B. Intuitively, the precondition condition says that if the context satisfies Qi then it satisfies the inherited method precondition Pi too. Thus the inherited method can be used in any context where its ancestor can. On the other hand, the postcondition of the inherited method may be stronger than that of the ancestor.

Moreover we have made no-hypothesis on the abstraction of the concrete semantics. In particular we do not differentiate between history properties and state properties, unlike [7], the two being just different abstractions of the concrete semantics. In fact, history properties correspond to trace abstractions and state properties to state abstractions.

A further advantage of formalizing the behavioral subtyping in the abstraction interpretation framework is that it is possible to apply well-known abstract domain refinement techniques [4,5] in order to improve the precision of the observables. Hence having more fine-grain class hierarchies. In particular, the use of the reduced product is practical for refining the precision of the captured properties.

On the other hand we are trustful that our approach can be effective for the design and the development of problem-specific object oriented languages. As an example, let us consider a language for smartcards programming. In this setting security is important, so that a wished property is that if a sub- class does not reveal a secret, so do the subclasses. In that case, we can use a domain of observables able to capture security and information-flow proper- ties. Embedded systems are another field that may take advantage of a more constrained subclass relation. In fact, in such a field it is immediate to see the benefits of having a language that ensures that subclasses does not violate the space and time constraints of the superclass.

In the future we plan to extend the present work to cope with multiple inheritance and Java interfaces, too. The first extension is quite straightfor- ward. The case of interfaces is more difficult: an interface is essentially a type specification, though most of the time such a specification is not expressive enough. Consider for example the case of a Java thread, which can be defined using either the Runnable interface or the Thread class. In both cases the class implementing a thread needs to define a method run. So what is the difference between a class implementing Runnable or extending Thread? The intuition is that in both cases the behavioral type of the class is the same, the difference being just syntactic We plan to define a specification language in order to cope with not-typing properties able to express properties imposed by interfaces. Then we will use it to prove that a class correctly implements an interface.

