Existing robustness testing tools such as Ballista [14] and JCrasher [5] test APIs with random and preset inputs to check whether the programs crash or not. The authors did empirical studies on Unix shell programs and Java classes respectively. They detected interesting robustness defects.

On the other hand, many verification/testing techniques based on Finite State Machine (FSM) have been proposed [1][7][9][22] for traditional software as well as component software. They define coverage criteria and algorithms to generate test cases for both unit testing and integration testing. But they focus on verifying whether functional specifications are correctly implemented. To our knowledge, it is new to use state model to test robustness.

The rest of the paper is organized as follows. The next section introduces com- ponents and their robustness problem. Section 3 describes the methodology of the state machine based testing framework. Experimental results and evaluation of the prototype tool are presented in Section 4. Section 5 surveys literature works. Finally we conclude the paper and describe the future work.

Semantics of reactive programs is defined by the notion of reactive designs with an additional Boolean observable wait that denotes suspension of a program. Design D is reactive if it is a fixed point of H, i.e. H(P )= P , where

Crash should be refined to concrete phenomenons on different platforms. For instance, in Java, an unhandled exception is thrown to upper levels of the stack frames until it was caught in one level. Both the component and its call site are suspended. Detailed mapping from the crash designs to Java is given in Section 3.3.

We implement the test framework for components implemented in Java and the fol- lowing test case generation mechanism assumes such testing targets. Nevertheless, the approach can be ported to other platforms. Test inputs are generated based on the method calls on the paths. For a method call, an concrete parameter is generated to replace each formal parameter. Instead of creating serializable objects and restore them at runtime, we generate Java statements which creates them. Our approach avoid managing any external object base. A Java metamodel is adopted from Octopus [23]. An OJOperation instance is constructed for each method call, and an OJParameter for each parameter. The objects are then translated JUnit test cases.

The recursion stops when it reaches a primitive type. We also limit the recursion depth to be less than 5, to avoid possible infinite loop and make the experiment more practical. When a construction reaches 5 levels deep an null reference is returned. This limit is adapted by our experiment experience.

When a parameter is bounded by pre-conditions, the random generator narrows the sample space accordingly. In rCOS, OCL constraints can be applied to notate a transition in state machine. Our prototype tool abstract OCL notations and use them for effective random generation. For instance, in the divide example in introduction, the pre-condition is y = 0, so the random generator pick a random value in [MIN INT, 0) and (0, MAX INT]. 6

To test robustness, an invalid method call should be provided at the final step. For invalid inputs(iv1 ), parameter lists are generated the same way as we do for valid calls, but with at least one parameter replaced with an invalid value from a pool for corresponding type described below. Suspicious values which often cause problems are also included. Note that static type checking and refinement typing[6] could make it impossible to feed some invalid inputs.

unchecked exceptions, subclasses of RunTimeException. Programmers can throw an unchecked exception without declaring it in the throws list. An unchecked exception might indicate a broken contract. For example, an ArrayIndexOutOf- BoundsException is thrown when beginIndex is negative for String.substring(int beginIndex, int endIndex). It could also be due to a bug in the component.

Unchecked exceptions thrown to test script without being declared. This will cause the client code to hang, and propagate the exception to call stacks. In- stead, a robust component would catch the unchecked exceptions and return an information message to its client code. An unchecked exception might be due to either erroneous parameter from client code or the component implementa- tion. During development, the programmer should try to expose all of them to test script. But components shipped as products are supposed to catch them and provide mechanisms for client code to understand the situation, rather than rudely terminate the process.

User-defined checked exceptions, which indicates the component is in wrong state and not performing its functionality. We provide a customization point for testers to add component-defined exceptions to indicates an erroneous state of the com- ponent. This is similar as returning a positive integer in C functions to indicate certain error in the method call.

Any reported failure indicates that the component crashes. The stack trace of this exception pinpoints the call hierarchy how robustness defects are triggered. Corre- sponding test case and the path of state transitions are available for reproducing and debugging the problem.

We analyze the unchecked exceptions and find several code segments which op- timistically assume the parameters to be valid. For example, the NullPointerExcep- tions traces back to line 100 of CircularBuffer.java, where the following statement tries to copy a null buffer, without any safety checking.

For the former, random string and int value are generated and fed to stateless buffer which are newly initialized. The fuzzy testing detects the NullPointerEx- ception. However, the other exceptions are never thrown because the testing always starts on an empty buffer.

State machine is also used for integration testing of component based software. Gallagher et al. [9] use interacting state machines with class variables to generate combined class states and component flow graph, so as to get test cases upon them. Ali et al. [1] combines collaboration diagram and state machines, and produces State Collaboration Test Model for testing. Those approaches extend basic UML diagrams for integration testing, but assume the components themselves are correct. The latter is the focus of our work.

On the other hand, research on robustness testing for API has produced several tools, mainly based on the idea of random testing. Fuzz [17] and Ballista [14] con- duct study on Unix and POSIX implementation. JCrasher [5] tests Java programs with pre-set values for each data type. Their advantage lies in that they do not need additional model other than API specification. Their targets are API, rather than general components with rigorous specification of interface and contract. Compared to our approach, a disadvantage of these tools is that the units under test are state- less. It stops them from identifying problems which only occurs in certain states of a component.

We would like to thank the anonymous reviewers for their valuable comments. This work is supported by the National Natural Science Foundation of China (No. 60603036 and No. 60673114) and 863 of China (No. 2006AA01Z165 and No.2007AA010302). It is also supported by HighQSofD and HTTS funded by Macao Science and Technology Fund.

