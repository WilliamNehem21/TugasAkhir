As the markets of mobile devices are expanding, needs for developing reliable memory cards are increasing, too. Samsung, one of the major players in memory card business, is also trying to improve the validation process for their memory card products. To this aim, we conducted a pilot project where a formal method and a specification-based testing technique are adopted to validate our MMC (MultiMediaCard) system. System under testing (SUT) is an MMC card which is implemented in two languages, Verilog for RTL and C for firmware. To test MMC cards, we formalize the fully general behavior model of MMC host with Esterel. It is also used as a test oracle in order to automate testing of SUT. Then, the two models of host and card are co-simulated on the verification environment Seamless. We conducted scenario-based testing and random testing.

Our modern life heavily depends on many systems that are carrying computers in them. Cellphone is one of the most obvious, and also the most complex, examples. The source code for a cellphone has the size of more than 1 million lines. There are many other examples, such as electric ovens, traffic light controllers, power plant management systems, and car-navigation systems, with various size and complexity. These systems are called embedded systems.

There are a number of industrial standards for memory cards, like SD card, memory stick, and CF card. MultiMedia Card(MMC)[9] is also one of the specification for memory cards. It has been adopted by many vendors, including Samsung, in the fields of PDA, digital camera, camcorder, and MP3 player.

Generally, they operate on a special-purpose hardware. Since hardware and software are co-designed, design decisions of hardware affect heavily on the design of software and vice versa. Moreover, both hardware and software have complex application logics. It is not general for embedded systems, where off-the-shelf real-time OS is used to reduce the direct functional de- pendencies between software and hardware.

Since, embedded systems often tend to a large harm to safety or finances, they are usually developed with great care and many resources. However, memory cards are not considered so critical to safety or finances. Moreover, there are severe market needs to ship relatively reliable products, quickly.

According to these features, we think it is better to design our own spec- ification based testing method rather than to adopt existing one. We build a cycle-accurate model of MMC host which shows fully general behaviors. It is built on the basis of the official MMC specification only. It also enables us to encompass a test oracle in the host model. MMC specification restricts the permitted behavior of MMC cards. The host model is also used as a test oracle because it keeps up the state of MMC card.

Third, we describe the test results of our MMC card. Testing is done on a commercial platform, Seamless, a hardware/software co-simulation tool[11]. Due to the speed problem and reproducibility of errors, actual testing is done on an emulation environment. Test harness code produced from the formal model is combined with the code of MMC card for hardware (written in Ver- ilog) and software (written in C). We will show the effectiveness of the exper- iment compared to that of brute-force random testing.

This paper is organized as follows. In Section 2, we present the background of our work. We introduce MMC specification and Esterel. We present our framework with the rationales in Section 3. In Section 4, we briefly explain our modeling method of MMC host. The testing result will be given in Section

An MMC system consists of an MMChost and MMC cards. Host is a device that uses the external memory cards, such as digital camera, PDA, or cell- phone. They are connected with three-wire serial data bus (clock, command and data lines). Communication between them is performed using messages, which is represented by one of the following tokens.

The main functionality of an MMC card is to read and write data. Data is transferred in two ways: stream-oriented mode, where the host should ex- plicitly stop a stream of data transfer, and block-oriented mode, where data transfer is done in terms of a block whose size is defined before the transfer. We consider block-oriented mode here, because many MMC cards, includ- ing the one made by Samsung, support only block-oriented transfer. Besides reading and writing commands, there are other additional commands, such as stop-transfer command and set-block-count command.

Our method has been designed to provide many benefits we expect from specification-based testing. It is considered lightweight to be applicable to real-world problems with limited resource. We think it is not too radical to be accepted by the field engineers.

We assume that the MMC system consists of the environment and the SUT, of which have almost the same complexity. Suppose neither of the environment and the SUT are formally modeled currently and we are to apply formal methods to them. We will need to model both of them, after all, if we are to benefit from formal verification techniques like model checking[4]. However, given this situation, we have two choices on which of them to model first.

Traditional formal methods usually emphasize the models of SUT. Thus, specification-based testing methods also assume the existence of the models of the SUT, and propose testing techniques for them. Therefore, there is a tacit agreement in the literature that users need to formalize the SUT first to apply specification-based testing.

It also enables lightweight application of formal methods[6]. Since many behavioral modeling language comes with compilers that generate imperative codes (usually written in C), the learning cost of engineers is relatively small. Moreover, the adoption becomes easy because the generated code can be used in the existing testing process.

It can generate efficient C codes. Many specification languages support code generation facility. However, the primary purpose of code generation is, in many cases, rapid prototyping or simulation. On the contrary, Es- terel is supposed to be used as an implementation language directly, so the generated code is quite efficient.

There are several kinds of nondeterminism in our MMC host model. In a state, the host should determine: 1) which command to issue next, 2) after having received the response, how long time to wait before sending the next command, 3) the number of data tokens to send, and so on. They correspond to the outgoing transitions from a state.

We use two methods to resolve nondeterminism. The first is to use pre- defined scenarios. A number of errors which have been reported for Samsung MMC card are used as scenarios. The second is random simulation. We provide Esterel code with C code that chooses a transition randomly.

Most complexities lie in the specification of interaction between commands. For example, the host can issue a number of commands during reading or writing data, including Stop Transmission, Deselect Card, Go Inactive State, Go Idle State, etc [9]. Thus, the modules for those commands should interplay to properly handle those situations.

The loop body is divided into two parts. When the control is in the first part, the card is operating normally, i.e. without any violation against the specification. Some modules are instantiated normally by run commands (lines 9-11), but others are instantiated within another nested loop with abort-when construct (lines 14-16). This distinction is needed to deal with the soft reset by CMD0. The module CMD00 can emit the signal Soft Reset, and it enforces restart of modules for other commands. Thus, the module CMD00 itself should be outside of the abort-when construct.

As soon as a violation against the specification is detected, the signal Violation Found is emitted. The first trap block (lines 3-18) is terminated, and the control is transferred into the second part of the loop body. Now we found a violation, we should reset the card to continue the testing, by issuing a CMD0.

MMC has two serial communication lines, CMD line for commands and re- sponses and DATA line for data transfer. Modules for interface manage these lines. They take the roles of packing (resp. unpacking) tokens from (resp. to) bits, notifying other modules of arrival / sending of tokens, etc.

In the module for CMD18 in Appendix A, 6 lines 10-52 are the main body. The loop construct means that this body should start whenever CMD18 is issued. Lines 11-16 take the role of waiting for CMD18. Whenever a command is issued (line 12), it checks whether it is CMD18 or not. If it is, it exits the every loop by exiting the trap (line 14). Lines 19-50 are executed when a command is issued in TRAN state (line 18). It consists of two threads, which deals with CMD line (lines 20-33), and deals with DATA line (lines 36-48).

We use two threads because reading process can be terminated in a few ways. The second thread (lines 36-48) is for processing normal transfer. It receives pre-spceified number of data blocks (lines 38-42) and emits a signal state changed(TRAN) to indicate the end of transfer.

However, there are other ways to end the transfer before all the blocks are transmitted. Lines 28-31 represent such a way that the signal state changed (TRAN) can terminate the transfer. Note that the signal state changed(TRAN) can be emitted by other modules, too. The module for CMD12 (Stop Trans- mission) also emits that signal to indicate aborting of progressing transfer. Thus, lines 28-31 actually deal with two situations: normal transfer termina- tion and termination by Stop command.

We also found other cases that were identified as violation of official spec- ifications. For example, when we send an illegal command during the write operation, the CRC bits on the data line become abnormal under certain conditions. We have identified four abnormal cases during random testing.

In this paper, we introduced a lightweight specfication-based testing method for memory card systems. Instead of testing with many real MMC host de- vices, we proposed to build the cycle-accurate behavior model of general MMC host from the official MMC specification and to use it on a co-simulation en- vironment. We were able to reproduce the error scenarios on the simulator, which was found to be helpful in debugging the errors. Testing method using

Our method is not so theoretically elegant nor radically novel. However, we believe it can directly benefit many engineers facing similiar problems with us. It can be integrated into existing testing process right with little burden. Using formal modeling language is an easy, but effective way to implement the test harness precisely.

Emulating hardware and softwre together took much more time than we expected. For example, it took about 10 minutes for the MMC card model (written in Verilog) to start normal operation after power-on. The problem can be partially solved by storing and restoring the simulation status. We have heard that the forthcoming version of Seamless will provide one solu- tion for this problem by translating Verilog code into C. We believe that it will ease the speed problem much.

There exist dedicated commercial tools for verification of embedded sys- tems. Two of them have reached noticeable level of industrial acceptance: Specman from Verisity[15] and Vera from Synopsys[12]. We had a chance to compare our approach with that of Specman. It uses their proprietary modeling language e, and a set of facilities that are useful for modeling and performing the verification. Constraint solver enables modelers to write pa- rameterized test scenarios with constraints for actual data values. Coverage analyzer reports the degree of completeness after a set of test are performed. A bit primitive forms of both tools were made in our framework, but in a rather ad-hoc manner.

argue that open, not proprietary language such as Esterel has its own benefits. First of all, we need not be dependent to a specific tool vendor. Moreover, we could benefit from other analysis tools freely available for Esterel, such as model checker Xeve[2].

Now we have a formal model of the MMC host, we could conduct a formal verification such as model checking. The biggest challenge is probably to build the model of MMC card. It would be much harder than building the host model because the model should reflect enough details of a concrete product. However, if the next version of Seamless provides the facility of abstracting Verilog code to C code, it would ease the modeling task very much.

It will be interesting to compare the testing result from our method and those from other existing specification-based testing methods. To do this experiment, we need to build the model of MMC card, too. But, in this case, the model would be built using the information from the specification, not from the actual codes of the card. We do not think it is difficult because there is a duality between behaviors of the host and the card.

During the experiments described in Section 5, we found that there is no standard language for specifying test cases of embedded systems like mem- ory cards. Thus, engineers should program their testbenches from scratch, using general purpose languages like Verilog or C. The situation is different for communication systems, where TTCN[14] is considered as a standard language for describing test cases. Verification engineers using TTCN can concentrate on the logical correctness of test cases, rather than having to pay attentions to irrelavant details. We strongly believe that a test lan- guage for embedded systems would easy much of the burden of verification engineers of this field.

