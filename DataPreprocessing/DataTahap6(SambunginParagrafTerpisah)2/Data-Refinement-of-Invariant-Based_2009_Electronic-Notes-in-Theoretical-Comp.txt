Invariant based programming is an approach where we start to construct a program by first identifying the basic situations (pre- and postconditions as well as invariants) that could arise during the execution of the algorithm. These situations are identified before any code is written. After that, we identify the transitions between the situations, which will give us the flow of control in the program. Data refinement is a technique of building correct programs working on concrete data structures as refinements of more abstract programs working on abstract data types. We study in this paper data refinement for invariant based programs and we apply it the the construction of the classical Deutsch-Schorr-Waite graph marking algorithm. Our results are formalized and mechanically proved in the Isabelle/HOL theorem prover.

Invariant based programming [3,4,5,8] is an approach to constructing correct pro- grams where we start by identifying all basic situations (pre- and post-conditions, loop invariants, etc.) that could arise during the execution of the algorithm. These situations are determined and described before any code is written. After that, we identify the transitions between the situations, which together determine the flow of control in the program. The transitions are verified at the same time as they are constructed. The correctness of the program is thus established as part of the construction process.

within situation A, then B inherits the constraints of A. The control structure is secondary to the situation structure, and will usually not be well-structured in the classical sense, i.e., control is not necessarily expressible in terms of single- entry single-exit constructs. The invariant diagram shows explicitly all the information needed in order to verify that the program is correct: pre- and post-conditions, invariants, transitions, and termination functions.

We have been experimenting with teaching formal methods using invariant based programming for a number of years now, mainly in the form of introductory CS courses at university levels. The experiences have been good, the students learn quite easily how to construct programs that are correct by construction with this approach, and appreciate the added understanding that the approach brings to how a program works. The problems encountered have less to do with the invariants first approach than with the general problem of how to describe formally (in predicate calculus) situations that are intuitively well understood [5].

Execution of an invariant based program may start in any situation (not neces- sarily an initial situation), in a state that satisfies the constraints of the situation. One of the transitions that are enabled in this situation will be chosen. The tran- sition is then executed, leading to new state in (possibly) another situation. There again one of the enabled transitions is chosen, and executed, and so on. In this way, execution proceeds from situation to situation. Execution terminates when a situation (not necessarily a final situation) is reached in a state for which there are no enabled transitions. Because the execution could start and terminate in any situation, invariant-based programs can be thought of as multiple entry, multiple exit programs. We may choose to identify some situations in an invariant based program as initial situations and some other situations as final situation, with the idea that execution should start in some initial situation and it should end in some final situation.

An invariant based program is consistent, if each transition preserves the situ- ation constraints. This means that if we start execution in a situation A and in a state where the constraints of A are satisfied, and choose a transition that is enabled in A, then executing the transition will lead to some situation B (which could be A again) such that the resulting state satisfies the constraints associated with B. An invariant based program is terminating, if each execution of the program eventually terminates. For a given collection of final situations, an invariant based program is said to be live if termination only occurs in some final situation. The semantics and proof theory for invariant based programs are studied in detail in [8].

The purpose of this paper is to study the use of data refinement when building invariant based programs. Data refinement [12,2,10,11] is a technique of building correct programs working on concrete data structures as refinements of more abstract programs working on abstract data structures. The correctness of the final program follows from the correctness of the abstract program and from the correctness of the data refinement. The overall complexity of the correctness proof is usually lower when using data refinement than when the final program is developed directly on the concrete data structure. We will show how to adapt the basic idea of data refinement to the construction of invariant based programs. At the same time, we will extend the notion of nested invariant diagrams in a way that makes it easy to describe data refinement. On the theoretical side, this paper extend the work described in [8] by including methods for carrying out data refinement. The data refinement theorems that we present here have all been proved mechanically in Isabelle/HOL [15].

proof obligations that arouse during our development were all formalized an proved mechanically in Isabelle/HOL. The main difference in our case study, as compared to the previous studies [14,1], is that the whole refinement process is carried out using invariant diagrams. We also believe that the way we develop the algorithm by first proving a generalization of the algorithm significantly reduces the overall proof effort.

The paper is structured as follows. Section 2 presents the proof theory for invari- ant based programs. Section 3 shows how to carry out data refinement of invariant diagrams. The DSW algorithm is constructed in Section 4. Section 5 presents some concluding remarks.

Data refinement has proved to be a powerful tool in developing software systems. When writing a complex program, it is often useful to start with an abstract program on an abstract data structure, and gradually refine it to a more concrete program working on a concrete data structure. Using this approach the overall proof work is split in smaller tasks [2,10,11].

Data refinement is often used to implement a data module with information hiding. The specification of the module defines the effect of access procedures in terms of abstract variables. The implementation of the module is in fact done in term of concrete variables, in order to achieve efficiency. If we can prove data refinement for all access methods, then any user of the module will never see a difference, and may use the module and reason about its behavior as if it was really implemented in terms of the abstract variables.

In other words, if we can prove that the abstract program terminates, then any data refinement of the abstract program will also terminate. We have shown earlier how termination is proved for programs with the structure (5). This can be easily generalized to arbitrary diagrams because the termination argument is proved for every transition, and refinement preserves this property.

We will now apply the data refinement technique presented above to construct the classical Deutsch-Schorr-Waite marking algorithm as an invariant based program. This algorithm marks all reachable nodes in an arbitrary directed graph, using only one bit of extra memory for every graph node. The algorithm is given for a graph structure represented using two pointers, left and right, associated with each node. A marking bit is associated with every node, and initially the marking bit is false for all nodes.

An auxiliary bit called atom is also associated with every node (initially this bit can contain any value). The algorithm will mark exactly those nodes that are reachable from a given root node by a path on which all nodes have the atom bit false. Thus, y will not be marked if every paths from the root to y contains a node with the atom bit true. If the algorithm should mark all reachable nodes, then the atom bit must initially be false for all nodes.

The second algorithm uses a stack of nodes instead of a set. In the first version of the algorithm, any element of the set could be used to proceed with marking, the stack version always chooses the element at the top of the stack. If all successors of the top are marked, then the top is removed, otherwise an unmarked successor of the top of the stack is marked and pushed onto the stack. The stack stores the path from the current node to the root node. We derive the second algorithm with a data refinement from the first algorithm.

In the first algorithm we start with a set X containing the root element. As long as the set X is non-empty we repeat the following steps: if there exists a unmarked successor node x of a node in X, then we mark x and we add it to X; or if there is a node x in X such that all successors of x are marked, then we remove x from X. The algorithm terminates when the set X is empty.

The type node is the type of all graph nodes. In practice this type is the type of all memory addresses (pointers). The constant nil is the null pointer, root is the initial graph node from which we compute the reachable nodes, and next is the relation which gives the graph structure. The set mrk is the variable in which we compute the set of reachable nodes. Initially mrk is set to empty-set, and on completion it will hold the set of all nodes reachable from root. The set X is an auxiliary variable which is initialized to singleton root. We define the following auxiliary functions: and tl.S the head and the tail of S, respectively. If S is empty, then hd.S is nil and tl.S is the empty list. We denote by [] the empty list, [x] the list with one element, and we use + for list concatenation. The predicate dist.S is true if all elements of S are distinct of each other and the function set applied to S gives the set containing the elements of S.

The final marking algorithm is constructed using two additional data refinement steps. The following diagram collects all these refinement steps into a single diagram. The diagram shows explicitly all situations, and how they are built up as successive layers of abstraction. The transitions describe all successive versions of the marking algorithm. The diagram contains all the information that we need in order to verify that each version of the algorithm is correct (provided we also have access to the definitions used in expressing situations and transitions).

The main variables used in this final concrete program are lft , rgt , at , and mrk . The variables lft and rgt store the left and right successors of a graph node. The variable at defines what nodes are marked and is used during marking, and mrk contains the set of all reachable nodes at the end. The variables lft , rgt , and at are altered during marking, but they are restored to their initial values when the program terminates. The program uses also two auxiliary variables p, t : node. Variable p stores the head of the stack S, and t stores the head of the tail of S. The rest of S is stored by temporarily modifying the variables lft , rgt and at .

We have shown how the overall proof effort of the marking algorithm, is simplified by first proving a generalized version of it, and then data refining it to the classical version. All results presented in this paper have been proved mechanically using the Isabelle/HOL interactive theorem prover. This gives a very solid foundation of our results. Currently we are working on including data refinement into the Socos environment [6,7], which is specifically designed to support the construction of invariant based programs and proving their correctness.

