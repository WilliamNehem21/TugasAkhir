jMonitor events correspond to fundamental Java programming abstrac- tions such as reading or writing of a field in a class, method invocation, method return or throw of an exception, and creation of a new object or array. Each event is also qualified with a Java application context such as the name of the field or the method and the names of the class and method context. The names are specified as strings representing POSIX compliant regular expressions.

Several distinct event monitors can be associated with any event. jMonitor instruments applications to capture the call context and call the monitor func- tion with this information. Each monitoring function is called before, after or instead of the associated event depending on the event specification.

The organization of the paper is as follows. In section 2 we introduce the jMonitor events, event patterns and event monitors. In section 3 we de- scribe the different types of event monitors and the types of runtime context information collected and made available to the event monitor through jMon- itor instrumentation. In section 4 we present the design and implementation overview. Section 5 covers how jMonitor relates to existing work in the field.

For event patterns built using the of and from constructs, no additional runtime checks are needed to determine whether a specific Java instruction matches the event pattern. Event patterns that include the in context defi- nitions incur a very slight extra runtime overhead (single boolean test) dur- ing application execution around each instruction that potentially match the event pattern. This also imposes a similar overhead to the call of the function mentioned by the in construct.

Each event pattern is associated with zero or more event monitors. A jMonitor event monitor is a pure Java class inheriting from one of the abstract classes in the jMonitor package: Monitor or InsteadMonitor. Each class corresponds to a particular type of the monitor that is attached to an event pattern. The doAfter and doBefore monitors implement the jMonitor.Monitor interface and the abstract doEvent method. The doBefore and doAfter monitors are intended to be observer monitors, although the monitors are implemented as unconstrained Java methods and can have side-effects.

Each doInstead monitor implements the jMonitor.InsteadMonitor in- terface and can use the passThrough method of the jMonitor.EventContext passed to the monitor to perform the original event that is being replaced. The passThrough method takes an Object[] representing the arguments for each event type:

One limitation imposed on the user is that event monitoring classes must be distinct from event specification classes (or declared within the specifica- tion classes as inner classes). This is necessary to prevent dynamic class from attempting to load monitor or legacy application classes before the event spec- ification classes are loaded. jMonitor needs to load specification classes first and learn about all user defined event patterns before any other class is loaded, otherwise the instrumentation will be partial.

The matching of event patterns to actual intructions in class bytecodes of the monitored application that needs to be instrumented is performed statically during initialization, prior to loading any application class. There is no ad- ditional runtime overhead associated with event pattern matching involving those built using the of and from constructs. The instrumented application methods simply call the event monitor methods when execution reaches the specified event trigger locations.

Event patterns that include the in context definitions, however, incur a very slight extra runtime overhead (single boolean test) during application execution around each instruction that potentially match the event pattern. It is important to note, however, that there is no runtime regular expression match overhead for matching the in patterns. All regular expressions are matched at instrumentation time.

To illustrate the mechanism, suppose there is an in("^int .*\\(") pat- tern, to match any function that returns an int. For this pattern object, jMon- itor introduces a thread specific static boolean (so there will be one boolean per in() pattern per thread). When instrumenting a method, jMonitor checks to see if it matches the pattern for all in patterns anywhere for any event. If it does match, then instrumentation adds some code around the method to

The tool bearing closest resemblance to jMonitor is Java-MaC, an implemen- tation for Java of the Monitoring and Checking architecture [4]. Java-MaC supports a language for specifying events and alarms on a Java program in the form of a Java expression that begins at a static object. These events can detect changes made to fields of objects in the system as well as the beginning and end of method calls. Various other contexts are supported to limit the scope of such events.

One feature that Java-MaC has that makes it useful for particular kinds of events is that it tracks the references to a particular object. This allows it to determine that the fields of a specific object (as determined by a code path from some static class object) have been changed rather than simply that a field of an object of a specific type was changed. This functionality causes Java-MaC to incur a performance penalty, however.

Another project that is similar in nature and design is Valgrind [5]. Valgrind is a framework for doing instrumentation of compiled x86 code. Some of the tools that have been implemented using Valgrind are memory leak and overrun detectors, as well as profilers. Valgrind has a rather large runtime performance cost, however, in that even if no instrumentation is to be performed there is about a four to five times speed hit. Some other limitations of the tool is due to the limitations of its target domain: the environment of compiled x86 code. There is not nearly enough meta information in compiled x86 binaries to design general runtime instrumentation skins in Valgrind as most of the useful code details are lost during the compilation process. jMonitor, implemented in and for Java, has access to metadata information regarding what functions or fields are actually being accessed by any particular instruction.

Lencevicius et al. [7] have developed a query-based debugging tool which, working somewhat similar to an SQL database query tool, finds all object tuples satisfying a given boolean constraint expression. The dynamic query based debugger continually updates the results of queries as the program runs, and can stop the program as soon as the query result changes. To provide this functionality, the debugger finds all places where the debugged program changes a field that could affect the result of the query and uses sophisticated algorithms to incrementally reevaluate the query. The on-the-fly debugger adds a capability to stop the java program just at prescribed execution phases and enables querying as well as allowing to change the query later. They have implemented such a dynamic query-based debugger for Java written in pure Java with no JVM modifications.

It seems possible to use a tool based on jMonitor to assist in similar type of debugging scenarios. jMonitor monitors can be written by the programmer to provide instant error alerts by continuously checking inter-object relation- ships while the debugged program is running. The monitor can continually update the results of queries (expressed as user level Java expressions) as the program runs, and can stop the program as soon as the query result changes. The programmer can specify event patterns matching all contexts where the debugged program changes a field that could affect the results of the query for an efficiency.

jMonitor can be used during the development, debugging, testing and de- ployment stages of the software lifecycle. When a developer needs to get more of an understanding of when and why a particular behavior is happening, he or she may decide to design event patterns and attach monitors to analyze the relevant events. We envision powerful tooling and debugging environments to be developed around jMonitor technology. Additionally, we envision adding tooling support to automate some of the mechanical (i.e. programmed speci- fication) aspects of event pattern specification and event monitor selection.

jMonitor supports program guidance. It can be used to alter the behavior of a legacy program for example to adapt to a new paradigm or when its specification is violated. This ranges from standard exceptions to advanced planning. Guidance can also be used during testing to expose errors.

