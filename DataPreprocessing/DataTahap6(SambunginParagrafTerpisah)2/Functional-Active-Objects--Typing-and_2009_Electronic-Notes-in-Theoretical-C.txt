on a copy of the object: there is no side-effect. The calculus is called distributed because it ensures absence of sharing between activities (processes) allowing them to be placed on different machines, and features asynchronous RMI-like commu- nications. From the original actor paradigm [16,2], several languages have been designed. Some languages directly feature actors, distributed active objects (like the ProActive [6] library), or other derived paradigms. The calculus ASPfun pro- vides a simple model for such languages. We can prove strong properties about it and, since the calculus is abstract, our semantics and mechanisation can be a basis for the analysis of related languages. For example, ASPfun enables the correlation with the imperative ASP [7] with respect to communication strategies and static analysability. Typing is a well studied technique [22]; we prove here a classical typing property, progress, in unusual settings, distributed active objects.

In [1], additional rules ensure that the typing environment is well-formed. We simplified it here by defining environment as a mapping. Also, a rule for correct formation of object types is introduced in [1], mainly ensuring that there is no infinitely nested object type. This last assumption has been omitted here as it did not seem necessary and, indeed, the properties shown below have been mechanically proved without any additional assumptions on type formation.

More recently, in [11], the authors suggest a communication model, called Am- bientTalk, based on an actor-like language, and adapted to loosely coupled small devices communicating over an ad-hoc network. The communication model is quite similar to the ASP calculus, but with queues for message sending, handlers in- voked asynchronously, and automatic asynchronous calls on futures. The resulting programming model is slightly different from ASP and ASPfun because there is no blocking synchronisation in AmbientTalk. In AmbientTalk, the flow of control might be difficult to understand for complex applications, because one can never ensure that a future has been returned at a precise point of the program. AmbientTalk should be dead-lock free, but unfortunately as no formalisation of the language has been proposed to our knowledge, this has not been formally proved. Our framework could be relatively easily adapted to prove the absence of dead-locks in AmbientTalk by transferring our progress property.

