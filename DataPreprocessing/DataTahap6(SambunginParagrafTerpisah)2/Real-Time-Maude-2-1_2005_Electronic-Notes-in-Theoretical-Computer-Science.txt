Real-Time Maude 2.1 is an extension of Full Maude 2.1 supporting the formal specification and analysis of real-time and hybrid systems. Symbolic simulation, search and model checking analysis are supported for a wide range of systems. This paper gives an overview of the tool and documents its semantic foundations.

In earlier work we have investigated the suitability of rewriting logic as a semantic framework for real-time and hybrid systems [10,14]. The positive results obtained were then used to build a prototype Real-Time Maude tool [13,10] based on an earlier version of Maude. This prototype showed that real- time system specifications of considerable generality and practical interest, falling outside the scope of the known real-time decision procedures, could be fruitfully executed, and analyzed by search and model checking [10,12].

2.1 implementation [5], especially its efficient built-in support for search and LTL model checking, and Full Maude 2.1, have provided a good basis for both simplifying the specification of real-time and hybrid systems, and for develop- ing a well-documented [11] and efficient tool, Real-Time Maude 2.1, that we present in this paper.

The motivation behind having eager and lazy rewrite rules was to model urgency by letting the application of eager rules take precedence over the application of lazy tick rules [14]. This feature was supported in Real-Time Maude 1. The ability to define frozen operators in rewriting logic [3] means that it is no longer necessary to explicitly define eager and lazy rules. Instead, one may define a frozen operator

This technique should make unnecessary any explicit support for eager and lazy rules at the system definition level to model urgency. In addition, the lazy/eager feature has not been needed in any Real-Time Maude application we have developed so far. Real-Time Maude 2.1 therefore does not provide explicit support for defining eager and lazy rules.

where x is a variable of sort Time (or of a subsort of Time) which does not occur in {t } and which is not initialized in the condition. The term u denotes the maximum amount by which time can advance in one tick step. Each variable in u should either occur in t or be instantiated in cond . The (possibly empty) conditions cond and cond ' should not further constrain x (except possibly by adding the condition x =/= zero). Tick rules in which the time increment is not given by the match are called time-nondeterministic. All other tick rules are called time-deterministic and can be used e.g. in discrete time domains.

or with time bounds of the form < r or with no time limit. The model checker in general cannot prove a formula correct in the presence of time- nondeterministic tick rules, since it then only analyzes a subset of all possible behaviors. If the tool finds a counterexample, it is a valid counterexample which proves that the formula does not hold. Time-bounded model checking is guaranteed to terminate for discrete time domains when the instantaneous rules terminate.

The two tick rules model the effect of time elapse on a system by increas- ing the clock value of a running clock according to the time elapsed, and by leaving a stopped clock unchanged. Time may elapse by any amount of time less than 24 - r from a state {clock(r )}, and by any amount of time from a state {stopped-clock(r )}. To execute the specification we should first specify a time sampling strategy, for example by giving the command (set tick def 1 .). The command (trew {clock(0)} in time <= 99 .) then simulates one behavior of the system up to total duration 99. The com- 99. Since the reachable state space is finite when we take the time sam- pling into account, we can check whether a state {clock(r )}, with r > 24, can be reached from state {clock(0)} by giving the untimed search command (utsearch {clock(0)} =>* {clock(X:Time)} such that X:Time > 24 .). The command (utsearch [1] {clock(0)} =>! G:GlobalSystem .) can show that there is no deadlock reachable from {clock(0)}. Finally, the command (utsearch [1] {clock(0)} =>* {clock(1/2)} .) will not find the sought- after state, since it is not reachable with the current time sampling strategy.

