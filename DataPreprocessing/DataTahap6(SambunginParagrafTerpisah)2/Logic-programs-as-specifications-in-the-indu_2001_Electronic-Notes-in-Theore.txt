In this paper we define a new verification method based on an assertion language able to express properties defined by the user through a logic program. We first apply the verification framework defined in [3] to derive sufficient inductive condi- tions to prove partial correctness. Then we show how the resulting conditions can be proved using program transformation techniques.

In this paper we propose a new verification method based on an assertion language able to express properties which are not given once and for all, but can be defined by the user through a logic program. This yields a very pow- erful assertion language, which allows us to verify different properties for a wide class of programs. Given any property expressed as a formula built on user defined predicates, by applying the verification framework defined in [3], we derive sufficient inductive conditions for partial correctness. Since the as- sertion language is very powerful we can not hope to have an effective way to decide whenever the resulting conditions are verified. However, we will show that such conditions can be proved by using well-known program transforma- tion techniques. Program transformation is a methodology which allows one to syntactically transform formulas while preserving its (chosen) semantics. Some examples of transformation rules are fold/unfold transformation rules. In our case we prove assertions on the user defined predicates by means of transformations on the user program.

It is worth noting that assertion languages which allow one to express properties defined by means of user programs have already been defined in the literature [14,15,2,16,7]. However our approach is substantially different. In [14,15,2], in fact, assertions are associated to program points. At run time such assertions will be executed using the logic programs defining the assertion language and the run time values. In this approach the logic implementation of the specification language is used to check by execution that each result of the actual program verifies the specification, while in our approach the same program is used to syntactically prove sufficient conditions for partial correctness.

In order to prove that a program behaves as expected we can use a semantics- based approach based on abstract interpretation techniques. This approach allows us to derive in a uniform way sufficient conditions for proving par- tial correctness w.r.t. different properties of interest. The ideas behind this approach are the following:

Following the above approach, verification techniques inherit the nice fea- tures of abstract interpretation. Namely, we can define a verification frame- work, parametric with respect to the (abstract) property we want to model. Given a specific property, the corresponding verification conditions are sys- tematically derived from the framework and guaranteed to be indeed sufficient partial correctness conditions.

(1) (in the case of logic programs) was initially used in abstract diagnosis [4], a technique which extends declarative debugging [16,8] to a debugging framework, parametric w.r.t. abstractions. A similar approach is taken in [2], where different approximations (modeled by abstract interpretation) can be used in the semantics and in the specification.

More general specifications (including pre and post conditions) are consid- ered in [9], which defines a verification framework, where well known verifica- tion methods can be reconstructed, by simply choosing different abstractions. The approach can be explained in terms of two steps of abstraction. The first step is concerned with the derivation of a semantics which models a spe- cific aspect of the computation which allows us to derive the sufficient verifica- tion conditions through (1). The second step performs the abstraction needed

As already mentioned, the second abstraction step is concerned with the choice of an abstract domain to approximate the properties. Of course we can make available to program verification all the abstract domains designed for the static analysis of properties such as modes, types, groundness dependen- cies, etc. As is the case for static analysis, in general we lose the precision, however we succeed in getting finite specifications.

Although decidable, the class of properties which can be expressed in these languages are given once for all. Furthermore the expressiveness of such as- sertion languages is limited. A more interesting case would be to let the user to be able to define its own properties through the definition of logic pro- grams. As already mentioned, assertion languages which allow one to express properties defined by means of logic programs have already been defined in the literature [14,15,2,16,7]. In particular in [14] such a language is used to

In all these approaches the role of the user defined logic programs is to allow to extensionally derive information on the intended behavior, i.e. the specification. They are in fact used to execute the assertion on run time values and therefore to check that each single program answer also satisfies the assertion. In this paper we propose an approach where the user defined logic programs are used to intensionally derive information on the intended behavior. This is obtained by using the user defined programs to syntactically transform the verification conditions and to prove them.

The approach proposed in this paper considers a language where assertions are formulas built on user defined predicates. The meaning of such predicates is specified by some user defined logic program. Once the verification condi- tions are derived they can be proved using the program and transformation techniques as the ones described in [12].

Depending on the property we want to verify, different versions of these techniques can be used. For example if we want to prove partial correctness of a program w.r.t. computed answers we should be careful to use transformations preserving the computed answers semantics.

This paper essentially presents some examples which show how our ver- ification method works. As the following programs will show, most of the verification conditions are very easily proven by using a few unfolding steps. This suggests that the process of proving the verification conditions can be automatized or at least semi-automatized.

The concrete semantics of such a system has to model partial answers in order to be able to express the infinite behavior. However (1) on the assertion domain boils down to the same sufficient conditions presented on Page 5. Thus the interpretation I models the partial answers of the program.

We conclude that the program is partially correct w.r.t. the specification. Note that if we had used a stronger verification condition with call correctness, we would not succeed in proving it, because we have no guarantee that every procedure call verifies the preconditions.

It is worth noting that here we need a semantics which models arithmetics over naturals. This is just to shorten notation because we should have chosen to use a first order representation of numbers (0, s(0), ... ), implement sum as a user defined predicate and then use the computed answer semantics.

As the examples presented in this paper have shown, most of the verifica- tion conditions can very easily be proven by using some unfolding steps while other transformation techniques, such as goal replacement, are necessary to prove more complex properties. As we have already discussed, also the gen- eration of the intermediate lemmata needed for goal replacement, can often be obtained by using an unfold/fold proof method, as shown in [13]. These considerations suggest that the process of proving our verification conditions can easily be semi-automatized by using, for example, some of the recently implemented systems for the transformation of logic programs [11].

