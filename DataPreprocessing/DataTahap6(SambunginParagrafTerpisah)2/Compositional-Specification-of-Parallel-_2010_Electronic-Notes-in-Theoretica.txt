The # (hash) component model aims to take advantage of a component-based perspective of software for the development of high-performance computing applications targeted at parallel distributed architectures. This paper presents an approach for specifying #-components using Circus, to provide the ability of reasoning about behavioral and functional properties of #-components and their composition, as well as to partially generate code of their units through the application of successive semi-automatic refinement steps. On the Circus side, the # component model provides a new compositional approach to combine a Circus specification to form new ones, widening its applicability.

The dissemination of parallel architectures, such as clusters, grids and multi-core processors rapidly increased the widespread interest in high performance computing (HPC) applications. Thus, such platforms attracted the investments of the software industry. Today, peak performance demands of programmers a good knowledge of HPC techniques for parallel and distributed programming tuned with computer architectures. This narrows the possibility of the development of general purpose parallel programming in widespread platforms.

The # component model was developed to improve the practice of developing HPC parallel software. The ability to be deployed in a pool of computing nodes of a parallel platform and addressing non-functional concerns are inherent to the so called #-components. Based on a framework architecture recently proposed [13], a # programming system called HPE (The Hash Programming Environment ) was designed and prototyped on top of the notion of #-components.

The implementation of parallel programs is considered an error prone task. In particular, to deal with synchronization bugs is an important aspect of programming with low level message passing libraries like MPI, mainly when programming for scientific and engineering application domains, due to the complexity of interactions in optimized implementations of high-level mathematics involved in simulations. Moreover, it is also very important to ensure the correctness of computations, which are not trivial for non-specialist programmers. The authors believe that formal methods may constitute an important tool for addressing these issues.

This paper presents an approach for the specification of #-components using Cir- cus, a language for behavioral and functional specification of concurrent programs that supports code generation by semi-automatic refinement steps. The reasons to adopt Circus are presented throughout this paper. This is an initial step to integrate existing tools for working with Circus specifications (model checking, re- finement, code generation, and type checking) [3] with HPE, providing support for translating behavioral parts of specifications of #-components using Circus onto Petri nets. This integration will provide an environment for the analysis of formal properties, performance evaluation, and the safe implementation of parallel pro- grams. On the side of Circus, this paper contributes with a new modularization technique, orthogonal to processes, intended for incremental building of large scale specifications written using this formalism.

The # component model introduces a number of new concepts attempting to reach expressiveness for describing parallel programming abstractions and to pro- vide the necessary level of abstraction to be independent of parallel platforms and parallelism-enabling infrastructures on top of them. By assuming that probably readers are not familiar with some of these concepts, and despite the fact that this is not the first paper to introduce the # component model [15,12,16,13], the Sec- tion 2, devoted to describe and formalize it, occupies a substantial space in this paper. It firstly introduces the notion of #-component by assuming some knowl- edge of the reader about basic structure of parallel programs as a set of interacting processes. For that, it is used a simple example from which #-components are ex- expressive parallelism with components an important research theme for those who work with CCA and Fractal [1,8,6]. The # component model proposes a notion of components that is intrinsically parallel and shows how they can be combined to form new components and applications, recursively. A #-component may be seen as a generalization of the usual notions of component, where a component is formed by a set of component parts, called units, each one deployed in a node of a parallel computer. Usual component models assume that a component is a software entity that resides in a single address space.

and u across all the N processes. This is performed in the second stage, where the arrows denote exchange of messages between processes. Finally, the dot product is calculated in the third stage, returning the resulting scalar by summing the partial results calculated by each process.

The example presented in the introduction of Section 2 only attempts to provide some intuition about the slicing of processes of a parallel program for decomposing it in concerns. This is the main principle behind the notion of #-component. In fact, the example helps us to show how to move from a process-based decompo- sition of a parallel program, that is the current practice in parallel programming, onto a concern-oriented based decomposition, that is closer to software engineering artifacts. In this section, the opposite direction is taken by informally introducing a model of #-components that supports the basic principles described in the example and from which other properties about the model can be extracted.

As a comparison, usual component models might be interpreted as # program- ming systems with only one component kind defined as a particular notion of soft- ware module (a .NET assembly, a Java Bean, a CCA component, for example). A # programming system must provide a library of primitive #-components and/or facilities to build them from scratch according to the semantics of the different kinds of components.

In the design of # programming systems, it is usual to classify units of some kinds of #-components as actions, such as units of synchronizers and computations in HPE. Action units denote operations that must be performed in some partial order. A #-component may have action and non-action units in its constitution. More- over, action units may also appear in #-components that address non-functional concerns. Thus, a unit of a composite #-component may be formed by folding a set of action and non-action units that come from its inner components. In our work with # programming systems, since Haskell# [14], we have adopted the approach to give to programmers linguistic abstractions to describe the order in which action units are activated, defining the behavior of the #-components exogenously and promoting separation between coordination and computation. For this reason, the #-component model has been presented in previous works as a coordination model for parallel components [11]. Behavior expressions has been adopted as the formal- ism to describe the order of activation of actions, with semantics in CSP [22] and a possibility of translation onto Petri nets [17]. In order to achieve the expressive power of Petri nets for describing traces of actions, a class of synchronized regular expressions has been adopted [23].

Circus has important contributions to # programming systems, regarding spec- ification of parallel programs. Besides to make possible to think about an inte- grating environment for formal reasoning about behavioral and functional aspects of #-components belonging to a subset of kinds supported by the # programming system, as pointed out in Sections 2.4 and 2.5, it makes possible the generation of source code after the application of successive refinement steps, with help of some automatic support. It is planned to use this feature for generation of source code targeting specific architectures. The # component model also has contributions to Circus. The authors argue that the # component model may be a useful approach for modular description of Circus specifications.

The remaining portion of this section presents how Circus can be used to specify #-components, and how the overlapping composition combinators (join and fold) may be applied to combine Circus specifications of #-components, forming new ones. Moreover, syntactical extensions to Circus are proposed to support overlap- ping composition operations. The case study of Section 4 will attempt to present the ideas and syntactical extensions in a more intuitive way. The convention adopted a set of actions, denoted by U .Action, which forms the main action of the process when applied to an action combinator  . In fact, in a unit of a composite #- component C, the set of state and action paragraphs are inherited from the slices of the unit, which, by overlapping composition, are units of inner components of C.

In practical # programming systems, it is convenient to define a notation for speci- fying an enumeration of N units, for an arbitrary N . Such notation is not included in the syntax of the overlapping composition calculus, since it only intends to for- malize the semantics of composition, but it is supported in HPE using indexed notation 4 . For the purposes of this paper, it is relevant to make a explicit discus- sion about specification of enumerated units because they represent an important class of parallel program in SPMD style (Single Program Multiple Data). CCA, for example, define the notion of SCMD components (Single Component Multiple Data), only to represent such class of parallel programs.

from the overlapping composition combinators join and fold applied over Circus specifications of other #-components. In fact, it is worth to note that the following two sections presents intuitively which is already implicit in the semantics of terms of HOCC and the definition of the category U presented in Section 3.1.

A #-component MatVecProduct, with an enumerated unit calculate, repre- sents the product of a PMatrix-matrix a and a RVector-vector x, resulting in a PVector-vector v. These data structures are represented by inner components. One may notice that the distributed vectors x and v have distinct partition strate- gies, which are the appropriate ones for promoting better data locality, avoiding communication among calculate units. The data structures a, x, v are public, as defined in the header of MatVecProduct (enclosed by parenthesis) for the pur- pose of sharing. VecVecProduct is analogous to MatVecProduct. The input vectors u and v are both PVectors. The scalar calculated by each process, from their partitions of u and v are processed by ReduceSum. Thus, the result r is copied into each process.

express more complex algebraic mathematical structures in a general setting that allows to study the commonalities of concepts in and between these structures. Due to its ability to deal with abstraction, category theory has been adopted as a stan- dard mathematical framework in several computer science domains, replacing the role of set theory. In fact, it has been extensively used in developments in theories of programming languages (types, semantics, and implementation), concurrency, automata, formal methods, constructive logic, algorithms, and so on.

holds for Cop from a dual perspective. Duality also implies that category theory concepts are always presented in pairs: the concept and its dual concept. For example, in Set, cartesian product is the dual concept of disjoint union, which means that disjoint union in Set correspond to cartesian product in Setop and vice-versa.

In Section 2.3, the concept of cocone have been used to define the semantics of folding operators in overlapping composition. The intuition behind the use of this concept in such context was discussed. In fact, research in software architecture have been revealed the important role of cocones and colimits for defining semantics and understand the fundamentals of composition of systems [21,20,36].

