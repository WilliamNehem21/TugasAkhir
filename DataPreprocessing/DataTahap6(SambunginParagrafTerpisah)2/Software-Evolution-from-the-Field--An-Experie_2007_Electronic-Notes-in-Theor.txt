Over the last few years, we actively participated in the maintenance and evolution of Squeak, an open- source Smalltalk. The community is constantly faced with the problem of enabling changes while at the same time preserving compatibility. In this paper we describe the current situation, the problems that faced the community and we outline the improvements that have been introduced. We also identify some areas where problems continue to exist and propose these as potential problems to addressed by the research community.

Over the few last years, we actively participated in the development and mainte- nance of the Squeak open-source project [13]. We were responsible for the the 3.7 and 3.9 official releases and participated in the releases 3.6 and 3.8. During this activity we faced the typical situations that developers are facing daily: bloated code, lack of documentation, tension between the desire of improving the code and

In this paper we present the problems that the Squeak community has been facing and describe the improvements that have been introduced. Moreover we sketch future approaches we would like to put in place. Finally we analyze the open problems and propose these as future research topics that may be of interest to the research community on software evolution.

Some researchers analyzed software evolution and its challenges and proposed taxonomy of changes [6,16,17]. There has been other research into open source development and evolution [18]. In this paper we want to give a summary of our own experiences as developers and researchers maintaining a large and complex open-source environment.

To understand the Squeak development dynamics we have to consider its open- source nature and also to analyze not only its growth, but the actual changes taking place. Indeed some actions (addition and removal of functionality) may result in the numbers of methods and classes remaining constant. One good starting point when considering the evolution of Squeak is to consider the approximate number of patches that have been integrated between releases. These patches vary in size and complexity, so the number can only be taken as a hint of the change that is done:

The Squeak.org distribution is used by a wide range of diverse projects. Some of them have their own open-source communities, other are closed research or com- mercial projects. Here we list the most important projects that are based on the common distribution.

Squeakland. The main focus of this distribution is educators of primary schools. The main interface is the Etoy system [1]. Squeakland is widely distributed in Japan and US. The end user does not interact directly with Squeak but the Etoy layer. Code quality, ease of extension, untangling and tested code are not the main focus of development.

tribution on 80,000 PCs in schools in Spain. SmallLand has been completely localized in Spanish: one of the largest contributions of this work was the frame- work for translating Squeak to other european languages, a change that affected a large percentage of the code base. Lot of changes to the graphical user inter- face were made to support a better desktop. They are concerned with the code quality.

Seaside. It is a framework for developing sophisticated dynamic web applications. Seaside combines an object-oriented approach with a continuation-based one[8]. Seaside offers a unique way to have multiple control flows on a page, one for each component. This community is concerned with the robustness and scalability of the libraries and the tool support. The design and ease to extend the system is also one of their concerns. This community developed a package and version control system (Monticello), that is used in the latest version of Squeak. This enables the developer to write components that are highly reusable and that can be used to compose complex web applications. Seaside is used by a number of companies for commercial development.

Croquet. It is a 3D shared multi-user environment. Users on different machines can use Croquet to explore a three dimensional space together, collaborate and share. Croquet uses a new Peer-to-Peer model for synchronization, allowing the system to function without needing central servers.

Tweak. Tweak is a next generation implementation of a UI and scripting system based on the lessons learned with both Morphic and EToys. Tweakers are con- cerned with code quality but in general are building layers on top or besides the base system.

As with a number of open-source projects, the Squeak community is an open-source movement that lacks real financial support or a sponsoring organization. From its inception to the release 3.4, Squeak was mainly developed by SqueakCentral, a single group of researchers around Alan Kay. From 3.4 to 3.8, the development community grew and became geographically distributed with many developers and small teams.

In this section, we elaborate on some code level problems that face the Squeak community. We are aware that such problems are neither exceptional nor specific to Squeak. Our goal is to document them for researchers who focus on the area of software evolution. The following section shows the improvements that have been applied and an evaluation of the obtained results.

Tangled Code. Historically, and as with any original Smalltalk implementation, Squeak was developed as one single system. The fact that subsystem boundaries were not explicit (for example by means of a package system) leads to a system with a lot of unneeded (and often surprising) dependencies. For example, the compiler depends on the GUI. These dependencies hamper modularisation and evolution: there is a high risk of introducing bugs, as a change in one part of the system can break another unrelated part.

Dead Code and Prototype Code. Squeak was originally intended as an envi- ronment for prototyping new ideas. Very little effort was spent on refactoring [11] and it was never systematically cleaned. Often the experiments and their exten- sions have remained in the system resulting in dead code and often incomplete functionalities.

One way to address the problem of evolution is by using well-known software en- gineering techniques and object-oriented design heuristics. [2]. In this section, we give examples of how these techniques were advantageous for Squeak. A challenging problem with most software engineering improvements is that they imply refactor- ing the system towards a better, more evolvable architecture. Hence we need to change the system to facilitate future changes.

This method raises a warning in debug mode by calling the #deprecated: method, but allows the original method to execute when in production. In Squeak, depre- cated methods are retained for one major release: methods that were deprecated in the development of 3.8 will be removed in 3.9.

Next Steps. It is not possible to tag an entire class as deprecated. Another disadvantage is that the mechanism as a whole is very course grained: evolution is happening all the time and is not restricted to major releases. Deprecation does not scale towards short cycles of change.

A large effort is underway to modularize the system. The latest 3.9 beta version is composed of 49 packages excluding tests with an average of 40 classes per package. Next Steps. The modularization was not driven by advanced analysis[21]. Hav- ing additional tool support to analyze existing dependencies is a first important

A lot of small refactorings were carried out over the recent years, leading to iterative improvements. Some large refactorings were supported such as a complete rewrite of the network subsystem. Large refactorings were possible when the changes did not cross-cut a lot of packages but were localized in one package.

Next Steps. Having tests is a first step towards enabling changes and document- ing the system in a synchronized way. The next step is to assess the quality of tests using test coverage tools. We plan to use tests to support the development by having a test server providing continuous feedback on the state of the latest versions [4].

SqueakSource and Monticello have been proven to be very successful. Squeak- Source counts over 420 registered projects and 480 developers. Several sub com- munities started to have their own SqueakSource servers to manage their projects. Starting with the development cycle for 3.9, Squeak uses a dedicated SqueakSource installation and Monticello for managing the complete squeak code base.

Earlier releases of Squeak were developed without any provision for bug-tracking. Naturally the Squeak community were faced with the problem of managing bugs: users did discover bugs, developers offered fixes, some of which were included in the next release. But there was no control over how many bugs had been identified, or to monitor whether or not they had been fixed, or in fact what the general overall state of Squeak was. This situation has been improved with huge success: Over 2500 bugs have been reported using Mantis [15], a web-based bug tracking system.

Automatic Build tools. Currently, the task of merging changes is labor-intensive and time-consuming. A goal is to leverage an automatic build system to eliminate all the tedious work that currently face maintainers. Automatic build systems are a well known technique and will be a valuable addition to the set of tools for Squeak development. Integration with an automatic test server is another major aspect of the build system that will have to be tackled.

Better support for modularity. While Squeak now has a package mechanism, it does not have a real module system. Packages are only deployment time and code management artefacts. Squeak packages do not include any notion of visibility (contrary to Java packages) [5]. It would be interesting to evaluate how a module system, by providing a scoping mechanism, could help to better structure the system.

The evolution of Squeak with its diverse community of developers and open issues ( i.e., decentralized development, modularization need) is a challenging task. The Squeak community achieved lot of progress over the last years such as a first cut at modularizing the system and the increase of unit tests. However, apart from environment enhancements such as Monticello few tools have been built to analyze the code base of Squeak. We have identified the need for them to help improving the system.

In addition, over the last few years, we have experienced the problems of having to introduce changes while at the same time supporting stability for existing users. We highlight the fact that there is no language support for the notion of evolution in todays programming languages. Current languages are only capable of describing one version of the system. Scoping changes and allowing multiple versions while retaining a simple language is an open challenge that the research community is facing.

We gratefully acknowledge the financial support of the Swiss National Science Foundation for the project Recast: Evolution of Object-Oriented Applications (SNF 2000-061655.00/1) and french ANR for the Cook: rearchitecturing object-oriented applications. The authors would like to thank all the Squeak developers and Orla Greevy and Adrian Lienhard for the reviews on the early versions of this paper.

