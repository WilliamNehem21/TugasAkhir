Tools for graphical representation of problems in automated deduction or of proof searches are rare and mostly primitive. By contrast, there is a more substantial history of work in the constraint programming community on information visualisation techniques for helping programmers and end users to understand problems, searches and solutions. Here we consider the extent to which concepts and tools from a constraint programming platform can be adapted for use with automatic theorem provers.

but it is not the area in which CP visualisation ideas are most directly applica- ble. We also do not consider interactive theorem proving. Again, this is not to deny that visualisation is important to it: ITP is just not the focus of the present investigation.

Five sectors of railway track are connected linearly from S1 to S5. There are trains in sectors S1, S2 and S4. There is a siding accessible from sector S3 big enough to hold one train. At each timestep, each train may stay where it is or move into an empty adjacent sector. No two trains may be in a sector at the same time. Find a plan of 13 timesteps which moves the train in S1 to S5, returning the other two trains to their starting positions in S2 and S4.

Note that the constraint graph represents only the existence of constraints, not their content. This level of abstraction can reveal which parts of a problem are closely related and which are remote. It shows the pathways along which information can be passed by propagators associated with constraints, but does not show what information may be passed or in which direction. Importantly, it is completely independent of whether the problem is satisfiable or not.

During search, the constraint graph may be viewed in dynamic mode, showing at each step which variables have values assigned and which domains have been reduced and which have not. This animated picture can show the search concentrating on a particular part of the problem before leaping to another, or making scattered decisions all over it. For the constraint programmer, this helps to form a mental image of the search in progress which is part of understanding the effect of variable choice heuristics, channeling constraints and much else.

metaphor. Vertices are shown as circles or spheres, and edges as straight lines, sometimes with meaningful thickness. Some viewers allow curved lines and some allow rectangles or other shapes for the vertices, usually in order to allow text to be displayed inside them. The G12 constraint graph viewer, G12-CGV, uses simple circles and straight lines. Its layout is force-directed [7]: edges exert on the vertices they join an attraction directly proportional to their length, like springs with a rest length of zero. At the same time, all vertices repel each other with a force obeying an inverse-square law, as though they were similarly charged particles. This type of layout is good for revealing clustering and symmetry, but can result in cluttered graphs in some cases in comparison with layouts which, for instance, aim for regular spacing of vertices or try to minimise edge crossings. The layouts generated by G12- CGV are 2-dimensional, in order to reduce overlap and masking in static pictures on a screen or page. 3-dimensional pictures are sometimes useful (and undeniably pretty) but are less easy to work with in general.

Visualisation toolsets for constraint programming [3,1,4] invariably feature rep- resentations of search trees. G12 is no exception, providing a simple search tree viewer G12-STV. Trees may be viewed statically after the event or dynamically growing during the search. Viewing the entire tree gives an impression of the nature

Some modifications of the basic binary tree are easy to incorporate in the view: multi-way branching, for instance, poses no problem. More significant departures from the simple paradigm, however, pose challenges for visualisation. Modern SAT solvers, for instance, perform sophisticated backjumping, relying on learned clauses to ensure progress through a virtual tree which changes constantly; the problem of representing this process in a usable search tree viewer is largely open. Visualising more radically different methods such as local search, is another game: there is no obvious analogue of the search tree view presenting such a combination of global search shape and local reasoning detail.

Nonetheless, some notions carry over without too much strain. The theorem proving analogue of the set of decision variables is the set of primitive function symbols of the language in which the problem is expressed. Predicate (relation) symbols count as function symbols for this purpose: they correspond to functions with value type bool. Function symbols of arity greater than zero are analogous to arrays, generally of unknown and possibly infinite length.

The domains of decision variables are of course the domain or domains of quan- tification in the intended interpretation of the proof problem. If it has no intended interpretation, then the Herbrand universe will suffice, though since this is usually infinite, some homomorphic images of it are likely to be more useful. The domain of any boolean-valued functions (predicates) is obvious.

Other problems, however, look less like CSPs. In many cases, there are few, if any, individual constants, and no natural domain size as the Herbrand universe is infinite. Even in such cases, however, constraint graphs can be drawn, by in- terpreting the language over finite domains. Although the graphs are not always informative, as they are sometimes so dense as to be little more than large cliques, there are cases in which they reveal structure which domain-specific proof searches

The question of how best to display the graph of derived formulae is still open. Since there are so many of them, some abstraction is needed in order to make any sort of comprehensible picture. One suggestion is to display only the number of formulae at each successive proof depth, perhaps with a little more information like the distribution of their weights, and then to allow zooming on particular formulae, showing their proofs on demand. How this might work in detail is, however, not clear. The question of what information the user or programmer is to get from this view and what it might be for would seem to be in order. For the moment, we leave it as a challenge.

For such purposes as performance debugging of problem encodings and parameter settings, it is essential to understand both the static semantics of logical formulae and the process of search. Traditionally in bottom-up theorem proving, the presen- tation of relevant information has been either too coarse (statistics on numbers of clauses generated and the like) or too fine (staring at runtime clause dumps). Visual- isation tools offer the possibility of attaining better levels of abstraction. Moreover, pictures often make intuitive sense and allow important features to stand out.

