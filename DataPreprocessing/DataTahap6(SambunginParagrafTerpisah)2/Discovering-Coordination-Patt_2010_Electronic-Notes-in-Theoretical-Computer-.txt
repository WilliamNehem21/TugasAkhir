A large and growing amount of software systems rely on non-trivial coordination logic for making use of third party services or components. Therefore, it is of outmost importance to understand and capture rigorously this continuously growing layer of coordination as this will make easier not only the verification of such systems with respect to their original specifications, but also maintenance, further development, testing, deployment and integration. This paper introduces a method based on several program analysis techniques (namely, dependence graphs, program slicing, and graph pattern analysis) to extract coordination logic from legacy systems source code. This process is driven by a series of pre-defined coordination patterns and captured by a special purpose graph structure from which coordination specifications can be generated in a number of different formalisms.

A MSDG is an extension of a system dependence graph to cope with object- oriented features, as considered in [6,7,16]. Our own contribution was the intro- duction of new representations for a number of program constructs not addressed before, namely, partial classes and methods, delegates, events and lambda expres- sions. For a formal specification of a MSDG, as well as for a detailed description of the techniques used in its construction, the reader is referred to [13]. In this section, however, we provide a brief overview of the structure of a MSDG, as detailed as necessary to the presentation of the pattern discovery algorithm presented in section 4.

where + denotes set disjoint union. Nodes of type SNode contain just an identifier for the associated program entity. Other nodes, however, exhibit further structure. For example, a MSta node includes the statement code (or a pointer to it) and a label to discriminate among the possible types of statements in a method, i.e.,

where x is a program variable and notation definedIn(x, v) (respectively, usedIn(x, v)) stands for x is defined (respectively, used) in node v. Typical de- pendencies between statement nodes are of types control flow, cf, and control, ct, the latter connecting guarded statements (e.g. loops or conditionals) or method calls to their possible continuations and method signature nodes (which represent the entry-points on a method invocation) to each of the statement nodes within the method which is not under the control of another statement. Formally, these conditions add the following assertions to the invariant of type Edge 2 :

where vis stand for a visibility modifier in set {private, public, protected, internal}. Specific dependencies are also established between nodes representing formal and actual parameters. Moreover, all of the former are connected to the correspond- ing method signature node, whereas actual parameter nodes are connected to the method call node via control edges. Finally, any data dependence between formal parameters nodes is mirrored to the corresponding actual parameters. Summing up, these adds the following assertions to the MSDG invariant:

Note that the first condition ensures that the relevant procedure call nesting struc- ture is kept. This information will be useful to nest, in a similar way, the generated code on completion of the discovery process. The second condition keeps all the statements in the program that may potentially affect a previously labelled node. This includes, namely, MSta nodes whose statements contain predicates (e,g., loops or conditionals) which may affect the parameters for execution of the communica- tion primitives and, therefore, play a role in the coordination layer.

Except for cf labelled edges, every other edge from the original MSDG with a removed node as source or target, is also removed from the final graph. The same is done for any cf labelled edge containing a pruned node as a source or a sink. On the other hand, new ct edges are introduced to represent what were chains of such dependencies in the original MSDG, i.e. before the removal operation. This ensures that future traversals of this graph are performed with the correct control order of statements.

A matching condition is a mapping (i.e., a partial function) which associates to each pattern node (of type NodeId) a predicate over CDG nodes (of type GNode). In practice, a common definition such a predicate resorts to a regular expression intended to be tested for matching with the program information collected on CDG

The overall strategy used by the discovery algorithms 1 and 2 consists of travers- ing the graph pattern and incrementally constructing a list of candidate graphs with nodes of type Attribution. This type is used by the algorithm because it maintains a mapping between the graph pattern nodes and CDG nodes. If a pattern is found, during the traversal of the graph pattern, for which a candidate graph cannot be extend to conform with, then the graph in question is removed from the candidate graphs list. On the other hand, if the candidate graph can be extend with one of the several CDG candidate nodes, it originates a series of new candidate graphs (one for each CDG candidate node) and the original (incomplete) candidate is removed from the candidate list.

Due to space limitations we omit some code details, which are clearly identified by underlined comments. Two of this omissions are concerned with the construction of the parameters being passed to the server operations (lines 15 and 31), which amount to the gathering of the current weather conditions. The second omission (line 52) regards the code to setup the web service proxy class, which contains the code to control all the Simple Object Access Protocol (SOAP) communications as well as all object marshalling operations.

Using the graph pattern discovery algorithm presented in section 4.2 one clearly identifies two instances of the Asynchronous Query Pattern used in the code and highlighted by the two mappings f1, f2 between the vertex pattern identifiers and the example code line statements. In order to facilitate the identification of the statements involved in the coordination pattern instances, the example code in appendix A highlights these statement in red and italic font.

