Data refinement is useful in software development because it allows one to build more concrete specifications from abstract ones, as long as there is a mathematical relation between them. It has associated rules (proof obligations) that must be discharged; this is normally performed by interactive theorem proving systems. This work proposes an approach based on refinement checking to automatically check the Z data refinement rules. Our approach captures the relational semantics of these rules by using the functional support of CSPM (the machine-readable version of process algebra CSP) and uses the traceability feature of CSP to 1 We are thankful to CNPq, which supported us with Grant No. 485488/2006-0. We also thank Dr. Juliano Iyoda for suggestions in early drafts of this paper and Professor Jim Woodcock for substantial help on the final version of this paper.

The translation from Z to CSPM follows the strategy implemented in a support tool [5]. Some adjustments are necessary as we deal with refinement rules instead of the behaviour of Z specifications. Moreover, the translation has limitations because some Z constructs might not have a direct correspondent in CSPM . Nevertheless, all solutions in this direction present similar limitations [2,3,15].

The general contribution of this paper concerns the reduction of user interven- tion when employing data refinement in the development process. Currently, user intervention is necessary only to provide the relation (as a Z schema) between the ab- stract and the concrete specifications, and to translate all schemas into CSPM . Our specific contributions are: (i ) the usage of CSP to capture the relational semantics of the Z data refinement rules; (ii ) the automatic verification of Z data refinements given a retrieve relation, and; (iii ) the automatic calculation of a retrieve relation, if one exists, to justify data refinement.

Each rule in the above definition has an interpretation in the relational seman- tics. The initialisation (b-init ) must be checked once and establishes that for each concrete initial state there is a corresponding abstract initial state. The applicability (b-app) and the correctness (b-corr ) rules must be checked for all operations. The former says that whenever it is possible to perform the abstract operation AOpi , it must be possible to perform the concrete operation COpi on the corresponding concrete state and concrete input. The latter establishes that whenever it is pos- sible to perform the abstract operation, and the corresponding concrete operation

The abstract state space (StateA) is determined by the set containing all pairs involving the type Status; that is, {(busy,vend) | busy <- Status, vend <- Status}. This corresponds to the set {(no,no),(no,yes),(yes,no),(yes,yes)}. Another functional feature is local definition (the let ... within construct).

Note that the traces refinement here does not take into account the existence or inexistence of nondetermism nor undefinedness. They are dealt into the proof obligation rules which were fully translated into CSPM . Then, the BACKRULES process actually simulates the verification of the proof obligation rules. Thus, our approach does not verify a data refinement between Z specifications using their corresponding process representations [1,2,4]. Instead is performs the real validation of Z data refinement into a model checker, like a human being does to discharge the proof obligations.

The relation R is calculated by extension, following the principle behind model checking (exhaustive search). Thus, all possible sets of combinations between con- crete and abstract states are covered, without user intervention and with the guar- antee that a retrieve is found as long as there is a refinement. In order to validate the refinement, we only need to check if the set validretrieves(.) is not empty. To do that, we use the process EXISTRETRV and the refinement assertion as follows:

The approach presented in [2] shows the correspondence between data and process refinements using the CSP semantics of Z. Thus, a Z data refinement is valid, if and only if, the refinement between the corresponding CSP processes is valid. We see our work as complementary, as we follow the relational semantics of Z data refinements. We use processes only to establish a behaviour for each proof obligation instead of the behaviour of a Z specification. This is more useful to find out, via counterexamples, which rule invalidated a refinement. In principle, both approaches deal with the same class of problems and have the same limitation when domains are infinite.

In [1] the conversion from Z to Alloy enables the use of SAT solvers to verify Z data refinements. Like our approach the user does not need to provide a retrieve relation a priori; it can be computed automatically. As Alloy is very close to Z, the conversion used in [1] is, in principle, simpler than ours. Moreover, the way Alloy deals with finite domains is more efficient than FDR. Nevertheless, Alloy does not provide traceability features to capture rules and operations that invalidated a refinement. A common limitation of both approaches concerns infinite state space systems. The use of data abstraction [6,9] in both approaches would be helpful to limit the scope of data domains.

In this paper we proposed an approach for automatically checking Z data refine- ments. We consider the relational semantics of Z [16] and the functional support of CSPM to write the proof obligations as functions that basically check set inclusions. Then, we provided template processes whose refinement check is valid if and only if the proof obligations are satisfied. Although FDR is not the best tool to check our functions, it provides traceability features that allows one to find invalid rules and discards the use of theorem proving. Three immediate results emerge from this: (i ) automatic verification of a data refinement between two specifications; (ii ) automatic calculation of a retrieve relation that assures a data refinement; and (iii ) the use of counterexamples for adjusting the specification whenever the refinement between them is invalid. We used (iii ) to detect a subtlety in a common example of the literature.

cannot deal with the state space explosion directly. Nevertheless, by integrating our approach with data abstraction [6,9] we can limit the data domains (to finite but sufficient subsets of them) before applying our approach. This is a topic for future work. Furthermore, we performed the translation to CSPM by hand. However, we intend to add this feature in the tool presented in [10]. Currently, the tool is able to translate Z specifications into processes. This new feature will discharge the user of manipulating the CSPM code of the proof obligations.

