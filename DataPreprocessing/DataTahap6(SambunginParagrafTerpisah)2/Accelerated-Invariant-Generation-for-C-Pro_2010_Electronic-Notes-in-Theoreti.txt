The Aspic input language grammar can be found in the Research Report [11]. In particular, the Aspic language enables the use of a non deterministic operation xj :=?, whose semantics is the loss of any information concerning the variable x. The expressivity of the Fast language is thus improved (all affine relations can be encoded).

by a variant of the Tarjan algorithm [24]. Some precomputations are made at the beginning in order to apply the acceleration results. Some changes are also made on the topology of the automaton: for instance, some nodes are split. The iteration is a classical fixpoint iteration, except when some loops are accelerable: in this case, a (post) fixpoint is computed locally thanks to the acceleration results of [11].

During the first phase of the analysis the transition functions are preprocessed, an internal structure encodes the type of the action (identity, translation, translation reset, idempotent transition, . . . ), of the guard (always true, simple, complex, . . . ), whether the transition is accelerable, and other useful informations that can be precomputed (postconditions, rays to add, . . . ).

Back to the initial automaton At the end of the fixpoint iteration on the modified automaton, the final results are computed w.r.t. the initial control points, by taking the union (convex hull) of the invariants associated to the two control points obtained after spliting.

Aspic is implemented over a fixpoint generic analyzer called Analyseur 4 . This tool performs a fixpoint analysis, given an encoding of the control flow graph and an implementation of the abstract lattice of properties. We chose the polyhedral library NewPolka 5 , which has an Ocaml interface. These two librairies are now embedded in the Apron Interface ([17]. The cumulated number of lines of Ocaml code is 20000 (without NewPolka).

The Parser The parser for c2fsm has been written in Ocaml using the ocamlyacc implementation of Yacc and the C grammar in [23]. The result is an XML representation of the abstract syntax tree. Error detection is minimal, and diagnostics are rudimentary. The user is advised to use a standard C compiler as a filter before attempting to use c2fsm.

One difficulty comes from the fact that the C assignment symbol is an operator which return a value, thus allowing such conundrums as if((c = f(x = y+z)) > x). In this case, the tool applies a process of unwind- ing, which may generate more than one state per statement. The semantics of C does not specify in which order multiple assignments may be executed. c2fsm applies an innermost leftmost policy.

c2fsm then proceeds to the expansion of the control statements (while, for, if, do, goto) using the familiar definitions, and adding new states as needed. In the interest of simplicity, no attempt is made to minimize the automaton at this stage. For instance, if a test has a then but no else, the tool generates a blank transition for the else branch.

This construct is transformed into a conditional goto to an error state whose name is the string argument. If the condition is not met, a transition to the error state is executed. There are two ways of verifying (or not) the assertion. Firstly, when simplifying the automaton, it may happen that all paths to the error state have a false guard. In that case, the error state disappears. In the other case, Aspic eventually finds that the error state is unreachable.

In this section we present some experiments driven with the Aspic tool. These results show that the method we have proposed gives interesting results in terms of precision and effectiveness. All these examples (and other ones) can be found in the Aspic webpage.

Nbac 6 implements the classical LRA in combination to dynamic partitioning ([16]). Contrary to Aspic, the tool is dedicated to the verification of properties of Lustre programs. The method perfoms forward and backward analysis from a minimal control structure, and the CFG is partionned w.r.t. the analysis results (and the proof goal). Our technique can be used to improve the precision of invariants during each forward/backward analysis.

Lash 7 and FastER 8 use acceleration techniques to compute, when possible, the exact reachability sets of counter automata. Theoretical results concerning the acceleration of some subclasses of loop have been obtained this last ten years (for difference bound contraints [7], a subclass of affine guarded functions [4,9] and more recently for octagonal relations [6]). However, the tools based on these algorithms are not fully automatic (Lash), or are not guaranteed to terminate (FastER), in particular for nested loops.

StInG 9 , and InvGen 10 use a combination of LRA and Farkas lemma to discover numerical invariants. The main drawback of the method is the use of template invariants, which prevents the analysis to discover any invariant which is not of the right form. To improve the precision, InvGen perfoms an execution of the program to add some additional constraints, which increase the global analysis time.

[19] and Suif [25], and all of them could be used as a replacement for the c2fsm parser. However, none of them is able to extract an automaton from their interme- diate representation, let alone do the complex approximations and transformations that are necessary prior to static analysis. In fact, since these tools are geared toward compilation, they tend to represent their input program as faithfully as possible.

R Wilson, R French, C Wilson, S Amarasinghe, J Anderson, S Tjiang, S-W Liao, C-W Tseng, M Hall, M Lam, and J Henessy. The suif compiler system: a parallelizing and optimizing research compiler. Research Report CSL-TR-94-620, Stanford University, Computer Research Laboratory, 1994.

