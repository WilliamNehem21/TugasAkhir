More specifically, our abstraction mechanism uses affine constraints, i.e. polyhedra, to specify pre- and post- conditions as well as state transformers. We present an algorithm to compute the transitive closure of such a state transformer, and we illustrate its performance on various examples. Our algorithm is simple, based on discrete differentiation and integration: it is very different from the usual abstract interpretation fixed point computation based on widening. Experiments are carried out using previously published examples. We obtain the same results directly, without using any heuristic.

Each program command, elementary or compound statement or procedure call is approximated by an affine transformer. The underlying mechanism is similar to [8] but extended from the states to state transitions. The idea of transformers is quite general and is also used, for instance by Boigelot & al. [4].

The set of possible program states, before a command is executed, is defined by a precondition. The set of program states after the command execution is defined by a postcondition. The postcondition is the image of the precondition by the command transformer. A legal affine abstract postcondition contains the effective postcondition, i.e. it is an over-approximation.

Let us take the toy example described in [17] and recently reused by [23]. A robot car must follow autonomously a track painted on the floor. In case it loses the track, it should not crash against a wall; however it is not stopped right away since the track might be found again. The car should not accelerate too much when it is looking for the lost track. The safety controller must ensure that a limited amount of time is allowed to search the painted track at bounded speed. Since time and speed are bounded in the track search mode, the car is safe if the track is far enough from the walls.

Using polyhedra instead of Presburger arithmetic, we do not claim to obtain more accurate results than others. Our philosophy is to use real-life cases, avoiding artificial or contrived examples. We only claim our simple and direct algorithm gets the same results as iterative approaches like widening.

The concept of abstract acceleration introduced by Gonnord in [10] is very sim- ilar in its goal to our algorithm, but it is implemented by pattern matching for different specific cases (see chapters 5 to 7 in [10]), whereas we can deal with func- tion calls and any control construct as the loop body transformer is computed in a modular way. Also, the exploitation of the accelerated cycles is part of a heuristic and not a program transformation as in Section 3.5. And the final result is obtained iteratively. All examples found in [10] are successfully processed by our algorithm, including the swimming pool [9].

Kelly et al. [22] present an algorithm to compute the transitive closure of a relation encoded by a Presburger formulae. This heuristic includes the notion of d-form relation which leads to an explicit transitive closure. It is stated that any relation can be put in a d-form at the expense of accuracy. We show here that it is not necessary to put the relation into a d-form to obtain an explicit transitive closure. We explain how to transform any relation into constraints about the state evolution and finally we explain how to get precise results by postponing convex hull operations.

technique in a dual way to obtain predicates over arrays such as those found in [18]. Monotonicity analysis [29] has also been used to extend induction variable de- tection, the inverse transformation of strength reduction. Basically, assignment statements nested in loops are monotonic if the value assigned increases from one iteration to the next. The exact value of the difference is abstracted by its sign. This information does not lead to loop invariants but is useful for dependence testing [30] and for array bound checking. We could derive the same kind of information from T + by introducing the difference variables and by eliminating the program variables.

A simple algorithm to compute affine invariants over integer scalar variables in while loops is presented. Its development and refinements have been mostly application driven, targeting the automatic program analysis and transformation domain. Its low complexity is key to addressing large scientific codes of up to 100 KLOC. Our experience shows that it performs well on standard program test cases, but not on complex automata whose states and transitions cannot be rewritten with simple C encodings.

