A policy-based encryption scheme allows to encrypt a message according to a credential-based policy for- malized as monotone Boolean expression written in standard normal form. The encryption is so that only the users having access to a qualified set of credentials for the policy are able to decrypt the message. In this paper, we first revisit the formal definition of policy-based encryption and describe a policy-based en- cryption scheme from bilinear pairings. Our scheme improves the one proposed in [2] in terms of ciphertext size, while at the same time preserving the computational efficiency. Then, we describe an application of policy-based encryption in the context of ad-hoc networks. More precisely, we show how the policy-based encryption primitive can be used to achieve a privacy-enhanced secure establishment of ad-hoc communities.

decrypt the message. Basically, a policy consists of conjunctions (logical AND oper- ation) and disjunctions (logical OR operation) of conditions, where each condition is fulfilled by a digital credential representing the signature of a specific credential issuer on a certain assertion. A user is thus compliant with a policy if and only if he has been issued a qualified set of credentials for the policy i.e. a set of creden- tials fulfilling the combination of conditions defined by the policy. More generally, policy-based encryption belongs to an emerging family of cryptographic schemes sharing the ability to integrate encryption with credential-based access structures. This ability allows for several interesting applications in different contexts includ- ing but not restricted to oblivious access control [2,7,18], trust negotiation [6,11,17], and cryptographic workflow [1].

In the first part of this paper (Section 2), we provide a further refinement of the formalization of the policy-based encryption primitive given [2]. Then, we describe a policy-based encryption scheme from bilinear pairings. Our scheme improves the one proposed in [2] in terms of ciphertext size, while at the same time preserving the computational efficiency. Furthermore, in contrast with the heuristic, rather intuitive security analysis provided in [2], our scheme is supported by formal security arguments. Due to space limitation, the details of our security analysis are given in the appendix.

In [14], an ad-hoc network is perceived as a community of interconnected au- tonomous devices providing services and resources to each other. Such devices often belong to users from different security domains that do not have pre-existing trust relationships. A security framework is therefore needed to ensure trustworthy interactions within such kind of communities. A comprehensive policy-based secu- rity framework supporting the establishment, evolution and management of ad-hoc networks is proposed in [14]. In the second part of this paper (Section 3), we lever- age this framework, and show how the policy-based encryption primitive could be used to achieve a privacy-enhanced secure establishment of ad-hoc communities.

In this section, we first set the context for the policy-based encryption primitive including the terminology, the notation and the policy model. Then, we provide a precise definition for policy-based encryption schemes and describe our pairing- based scheme. In the appendix, we provide a formal definition for message confi- dentiality in the context of policy-based encryption. Then, we prove the security of our scheme in the random oracle model.

and concise policies. In the considered environments, the identity of users is rarely of interest to determining whether a user could be trusted or authorized to con- duct some sensitive transactions. Instead, statements about the user such as at- tributes, properties, capabilities and/or privileges are more relevant. The validity of such statements is checked and certified by trusted entities called credential issuers through a digital signature procedure.

We consider policies written in standard normal forms, i.e. written either in conjunc- tive normal form (CNF) or in disjunctive normal form (DNF). In order to address the two standard normal forms, we use the conjunctive-disjunctive normal form (CDNF) introduced in [18]. Thus, a policy denoted Pol is written as follows:

Note-3. The concept of policy-based cryptography might be compared with the con- cept of generalized threshold cryptosystems introduced in [16]. Generalized thresh- old cryptography is an extension of the original threshold cryptography to the case of general access structures. Our policy-based encryption scheme uses a technique similar but not exactly the same than the secret sharing method presented in [4]. In [9], it has been observed that using the previous general secret sharing method it is possible to construct an RSA-based generalized threshold decryption scheme. In contrast with the RSA-oriented approach, our policy-based encryption scheme supports the notion of cryptographic workflow discussed in [1]. In fact, using our approach, a message can be encrypted with respect to a specific access structure be- fore the decryption keys (the credentials) are generated and given to the authorized users. As future work, we are planning to conduct a detailed comparison between policy-based and generalized threshold cryptosystems.

In [14], Keoh et al. propose a comprehensive policy-based security framework sup- porting the establishment, evolution and management of ad-hoc networks. In this section, we first provide an overview of their approach. Then, we leverage their policy-based trust establishment model and show, through the description of an ap- plication scenario, how the policy-based encryption primitive can be used to achieve a secure establishment of ad-hoc communities, while adhering to the privacy princi- ple of data minimization (called the data quality principle in OECD guidelines [8]) according to which only strictly necessary information should be collected for a given purpose.

With regard to their definition of ah-hoc communities, Keoh et al. introduce a community specification, called doctrine. The latter specifies a set of roles that can be associated to the participants in the community, the characteristics that participants must exhibit in order to be eligible to play a specific role, as well as the authorization and obligation policies governing the behavior of the participants within the community depending on their roles. Based on the doctrine, a set of security protocols is proposed to bootstrap the community, manage the membership (joining and leaving the community), and govern the access to the services provided by the participants.

Note. First, note that the policy model in [14] is limited to policies written in the Disjunctive Normal Form (DNF) but can naturally be extended to support the Conjunctive Normal Form (CNF). Besides, the trust model relies on a security in- frastructure that consists of well-established trusted authorities in the Internet. We can extend this model to support any entity, including the participants themselves, that is trusted to check and certify the validity of specific credentials. Finally, note that it is assumed that the entity that defines the user-role policy have access to trusted values of the public keys of the different credential issuers referenced in the policy.

Scenario. Alice is on a business trip for the collaborative project P. On the train there might be other colleagues from different companies working on the same project. Alice has some documents she is willing to share and possibly discuss only with the members of the project that are either from company X or from company Y.

In the scenario described above, the main concern of Alice is to ensure that the participants that are not compliant with the user-role policy Polrp associated to role rp cannot have the privileges corresponding to rp i.e. they cannot read the documents proposed by Alice and cannot initiate a private discussion with her. In other words, Alice wants to be sure that her user-role policy is effectively enforced. Consider the two use cases described below:

In the first case, Bob is interested in reading the documents proposed by Alice. However, he is not willing to have further interactions with her. According to the privacy principle of data minimization, the policy enforcement mechanism should not allow Alice to know whether Bob is compliant with her policy.

In the two cases described above, the standard approach proposed in [14] for policy enforcement cannot respect the privacy principle of data minimization. In fact, be- cause Bob must provide the credentials proving his compliance with Polrp , Alice will know anyway whether his is compliant with her policy and from which company he comes from. More generally, as long as the policy enforcement mechanism involves the exchange of credentials, the privacy principle of data minimization cannot be satisfied.

Upon receiving the two ciphertexts, Bob uses his credentials to decrypt the pair (ks, nBob) using the policy-based decryption algorithm (PolDec) corresponding to the encryption scheme used by Alice. As Bob has access to a qualified set of credentials for policy Polrp , he is able to get the symmetric key ks which he uses to decrypt the different documents he wanted to read. In the case where there is no further interactions between Alice and Bob, there is no way for Alice to know that Bob fulfills her policy.

The concept of policy-based cryptography is a promising paradigm for trust estab- lishment and authorization in open environments. In this paper, we focused on the policy-based encryption primitive. We first described a provably secure policy- based encryption scheme from bilinear pairings that improves the existing schemes in terms of ciphertext size. Then, we leveraged the security framework proposed in [14] and showed how policy-based encryption can be used for a privacy-enhanced enforcement of the user-role policies specified by ad-hoc communities.

In the following, we provide the details of the security analysis of the policy-based encryption scheme described in Section 2. We first describe a formal model for message confidentiality adapted to the context of policy-based cryptography. Then, we state the results related to our scheme and give the details of our reductionist security proof.

Setup. On input of a security parameter k, the challenger first runs algorithm Setup to obtain the system public parameters P. Then, the challenger runs al- gorithm Issuer-Setup once or multiple times to obtain a set of credential issuers I = {I1,..., IN }. Finally, the challenger gives to the adversary the public param- eters P as well as the public keys of the different trusted authorities included in I.

