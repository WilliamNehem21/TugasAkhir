[7] and the calculus of Mobile Ambients [1] in a uniform semantic framework. The encodings are bisimulations. A tool for supporting distributed system design and analysis is presented. The tool, which adopts the slender SHR as intermediate language, integrates model checking techniques within the framework of (distributed) program development.

Synchronized hyperedge replacement, SHR [5], is a graph rewrite system for modelling process interaction in a network environment. In this framework, inspired by [4], hyperedges are to represent agents, or software components, while nodes are thought of as channels, synchronisation points or, more gen- erally, network communication infrastructure. In [5] SHR has been used to provide a labelled transition system semantics of the calculus of Mobile Am- bients [1].

In the present paper we propose a slender version of SHR based on a single, rather intuitive rule of parallel composition. While drammatically reducing mathematical complexity we do not loose in expressive power. Two case stud- ies are presented where the mobile ambients and DCCS, the distributed CCS of [7], are encoded in the proposed version of SHR. In particular, both models adopt a common recursive graph architecture whose components we call am- bient graphs. Interpretation maps DCCS terms to flat ambient graphs, while mobile ambients are trees. Both encodings are proven to be bisimulations (thus improving the result obtained for ambients in [5]).

In section 3 and section 4 we develop two case studies where SHR, in the version proposed above, is used to model DCCS, the distributed CCS of [7], and the calculus of Mobile Ambients. Both models adopt a common recursive graph architecture whose components we call ambient graphs. Interpretation maps DCCS terms to flat ambient graphs, while mobile ambients are trees.

Ambient graphs feature two kinds of edges: L(u, v, w, z), called location managers, and P (v, w) representing processes running at specific locations. We use the metavariables u, v, w and z = z1 ... zn consistently to denote nodes attached to specific hyperedge tentacles. Hence, u always denotes a node where the first tentacle of a location manager is attached, and so forth. Local processes and location managers are represented graphically by the following in DCCS it is possible to move to a dead location, or to kill one. Hence we must allow the edges representing such locations to respond to move and kill messages. Besides that, they must answer the question whether they are alive (the else action of rule 17). Note that a process is allowed to move to, as well as to kill, the same location where it resides (rules 13 and 9 respectively).

This transition is performed by the parent ambient. Node zi is shared with the entering ambient m , while node zj is the node shared with ambient n. Both nodes are labelled with the same fresh node y. When the actions on zi and zj are matched by their co-actions node y is unified with the nodes passed by m and n. Hence, these are unified as well. The node zi does not appear in z1, because m is no longer a child of this edge.

ated by the system may be saved and manipulated by the Visual SHR Editor or, in some cases, translated back into the original calculus. Within the editor it is possible to write productions or design system architectures graphically. The visual editor feeds back to the Murphi rule generator thus closing the cycle from implementation to testing and back.

