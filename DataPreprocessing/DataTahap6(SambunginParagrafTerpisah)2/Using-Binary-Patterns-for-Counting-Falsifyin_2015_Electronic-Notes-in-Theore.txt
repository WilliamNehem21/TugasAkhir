The representation of the set of falsifying assignments of clauses via binary patterns has been useful in the design of algorithms for solving #FAL (counting the number of falsifying assignments of conjunctive forms (CF)). Given as input a CF formula F expressed by m clauses defined over n variables, we present a deterministic algorithm for computing #FAL(F ). Principally, our algorithm computes non-intersecting subsets of falsifying assignments of F until the space of falsifying assignments defined by F is covered. Due to #SAT(F ) = 2n-#FAL(F ), results about #FAL can be established dually for #SAT. The time complexity of our proposals for computing #FAL(F ) is established according to the number of clauses and the number of variables of F .

The problem of counting models for a Boolean formula (#SAT problem) can be reduced to several problems in approximate reasoning. For example, estimating the degree of belief in propositional theories, generating explanations to propositional queries, repairing inconsistent databases, Bayesian inference and truth maintenance systems [4,12,13,14]. The above problems come from several AI applications such as planning, expert systems, approximate reasoning, etc.

The combinatorial problems that we address in this paper are the computation of the number of models and falsifying assignments for Boolean formulas in Con- junctive Forms (CF), denoted as #SAT and #FAL, respectively. Both problems (#SAT and #FAL ) are classical #P -complete problems even for the restricted cases of monotone and Horn formulas. We also show that string patterns can be used as a succinct representation of the set of falsifying assignments of conjunctive formulas.

The standard strategy used to solve #SAT comes from variants of the classical Davis and Putnam (D&P) method, especially designed to solve the SAT problem. In this case, the main variant arises from reviewing the entire tree of search on the set of assignments of the formula; for example, the backtracking process has to be applied not only when a partial assignment falsifies a sub-formula, but also for assignments satisfying it. However, now a days, each variant from D&P have an exponential-time complexity [4,14].

In [6], some cases are presented where #SAT(F ) is computed in polynomial time considering the graph-topological structure of the constrained graph of F . Additionally, in [5] a new way to measure the degree of difficulty for solving #SAT is presented. It is shown that there is a threshold, determined by the same number of models, where #SAT is computed in polynomial time.

In this paper, we present a method for computing #FAL(F ) in an incremental way with respect to the set of clauses in F . We order the clauses of the formula, taking advantages of the binary strings representing the falsifying assignments of a set of clauses. In order to accelerate the computation of #FAL(F ), we reduce the cardinality of the set of clauses to work with by applying some reductions among clauses; e.g. the application of the independent reduction rule combined with subsumed clause rule.

The paper is organized as follows. In Section 2 we give the basic notation as well as several definitions. In Section 3 we describe the binary pattern based approach for 2-CF cases, and we extend such approach for CF cases. Section 4 provides the algorithm associated with our proposal. In Section 5, we present the conclusions of the work.

So, the hard cases to answer whether #SAT(F ) = k are given when k > p(n). In [7], several hard cases for solving #SAT(F ) are identified. Such identification depends on the relation between its number of clauses (m) and the variables (n) of the instances F . For example, some of the proved cases were: the set of clauses of F . We use a short notation to represent the set of falsifying assignments of clauses using string patterns. And we show how to manipulate such strings to form the set of falsifying assignments of a conjunctive formula.

We begin computing excluded subsets of falsifying assignments of F until the whole space of falsifying assignments defined by F is covered. Due to #SAT(F )= 2n-#FAL(F ), results about #FAL can be established dually for #SAT. Some reduc- tions in our procedure are used, as subsumed clauses and the independent reduction involving dependent clauses, in order to accelerate the computation of #FAL(F ).

