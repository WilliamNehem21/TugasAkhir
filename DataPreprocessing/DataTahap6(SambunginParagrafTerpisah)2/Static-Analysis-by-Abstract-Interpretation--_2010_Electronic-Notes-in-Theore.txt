The programming language P is defined inductively below. Its arithmetic expres- sions involve constants in C (including the integers and included in the real num- bers), variables in V = {v1,..., vn}, multiplications of a constant by a variable, and additions of two variables. Programs in P and instructions in I are defined by (mu- tual) induction. There are only four basic instructions, namely an instruction that does nothing, the classic assignment, if-then-else branching, and the while loop.

We remark that P-programs are structurally finite objects. The language P is not convenient for actual, large-scale programming but it allows simulating other classical branching and looping, complex tests and so on. Furthermore, its simple definition keeps the proofs and explanations at a reasonable complexity level.

Program size. The notion of size will help define functions involving programs and instructions, e.g. semantics functions and corresponding MPs. The size of programs and instructions is defined below (definitions on the right). The size of a program corresponds to the number of control points that one may want to put in

Thus, the PI algorithm performs a local search on the e-space of (1), whereas the algorithms mentioned in Sect. 7 explore the entirety of the e-space, thereby always finding the guaranteed lfp. By comparison, a known sufficient condition for PI methods to find a guaranteed lfp is that the semantics function should be non-expansive in the sup norm [7].

variable values (this is akin to imposing that all boxes are in a large pre-determined box, similarly to what is done in widening), we are able to reformulate exactly ([20], p. 179) all products between decision variables occurring in the MP to a linear form, yielding a MILP which we solve using the BB based solver CPLEX 11 [17] on a 2.4GHz Intel Xeon CPU with 8GB RAM. Notice that for most practical cases, the large bound need not be arbitrary, as automatic range reduction techniques for MILP can help considerably [24].

