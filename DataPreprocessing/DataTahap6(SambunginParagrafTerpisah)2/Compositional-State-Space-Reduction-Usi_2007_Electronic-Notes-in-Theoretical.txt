Informally, an untangled action 2 is a special action in a discrete event system of causality and conflict [23]. At any state of the system the action, if enabled, shall not be entangled through any conflict with the rest of the system, and its only contribution to the system dynamics is by causality. Therefore, if an untangled action is not observed (due to hiding or other operations), its occurrence becomes time irrelevant 3 . This gives us the opportunity to reduce the search space by considering only one possibility of its occurrence time.

This work is motivated by our experience in using process algebra (e.g. CSP and FDR2 [6]) to verify asynchronous circuits [22], where high concurrency in gate-level circuits induces serious state explosion problems. A well-known example is the tree arbiter [5]. A tree arbiter consists of a tree of arbiter cells. Each arbiter cell behaves as a two-way arbiter for its sons while at the same time acting as one of the clients of its father node. In this way, a tree arbiter implements multi-way arbitration through a hierarchy of two-way arbitration cells.

The state space of tree arbiters blows up exponentially with the increase of tree size, and it is not readily amenable to reduction due to the conflicts inherent to arbitration. Previously, Petri net unfolding techniques [10] and partial-order reduction enhanced BDD methods [1] had been applied to it, with limited success. In this paper, we will propose untangled actions as a viable solution to verify this and similar systems.

Untangledness is a simple idea. We will defer the theoretical justification to later sections. For the arbiter cell example, it is not difficult to see that only two actions are entangled in conflicts, i.e. a1+ and a2+. These tangled actions coincide with so called output choice signal transitions [4]. With this information, it is straightforward to give a state-space reduction algorithm by prioritising untangled actions (similar to the chase reduction in FDR2) in the exploration of the state space. That is, in a depth-first search, given a state with a non-empty set of untangled outgoing transitions, we use some strategy to pick and prioritise one from the set to explore; all the other transitions from the same state, untangled or tangled, will be completely ignored in the exploration. In case a state has no

In this paper, we propose a compositional technique for concurrent systems such that untangledness analysis is done at a local level. A compositionality theorem au- tomatically calculates global untangledness information from the local information. Using thus obtained results, state space reduction can be applied on-the-fly on the global systems.

Structure of the paper. After the introduction of basic notations (Section 3) and concurrent systems (Section 4), two important (partial) determinacy notions on LTSs with lvgi actions, one stronger than the other, are proposed in Section 5. The former is compositional on the lvgi actions without synchronisation potential and induces a simple and efficient on-the-fly reduction procedure (Section 6). The latter removes the synchronisation restriction and becomes compositional on all lvgi actions, and thus enables compositional reductions (Section 7). Preliminary experiment results are given and the paper is summarised in Section 8.

This insight leads to the state space reduction algorithms in many process- algebraic frameworks [14,11,2,6]. The algorithm simply makes arbitrary decisions on invisible choices and ignores the other alternatives completely in the state space traversal. It also forms the basis of our reduction algorithm in Section 6. We call

With Ai = {e}, P and Q are both detachable, although P contains an auto- conflict in the sense that one branch needs two e actions to enable e' while the other needs just one. The parallel composition of the two, however, is not detachable since one branch will lead to the occurrence of e' while the other will not. Therefore, to make compositionality work fully, conflicts must be ruled out completely on Ai actions. This gives us the notion of untangled actions.

Like the previous one, the acceptor controls the order and the occurrence of Ai actions. Thus rule 3 and the parts of rule 2 and 4 not involving reject remain the same. Unlike the previous one, Ai actions become visible in the fed behaviours (rule 1 and 5) and the acceptor is more sensitive (the parts of rule 2 and 4 involving reject ). For instance, once the right type and number of actions have occurred (i.e. removed from the fed behaviours), a new action will be enabled on top of the current suffix (i.e. the pending e). e cannot be delayed by any other A action; if it is not simultaneously enabled on LTS , it may result in the immediate issue of reject (the

Untangled actions are compositional; global untangled actions can be calculated from local ones. The compositionality theorem will be given in Section 7, where a new compositional reduction technique enabled by it is also proposed. The new technique feeds the global untangledness information to a specially designed on- the-fly reduction procedure called chase+, which reduces state spaces by exploiting detachability (c.f. Theorem 5.9).

Therefore, we can adopt a scheme similar to that in [2] to implement chase+ as an on-the-fly procedure integrated in refinement or model checking. Note also that round robin strategies are local strategies. That is, the definition only depends on the pending action and the top elements of the history and the exit points can be calculated by simply following the strategy. Therefore, the exit function need not be explicitly constructed. It enables a simpler and more efficient implementation of the chase+ reduction procedure.

some extra lvgi actions. This will not result in any loss of expressiveness, e.g. w.r.t. SBDF models. Moreover, these lvgi choices need to remain so during the verification process, unless they are detachable, in which case they can be hidden and removed

We have checked the system using FDR2. The results are very encouraging compared to previous works [1,10]. The checking time is nearly linear in the size of the tree arbiter. More intriguingly the memory used is negligible (below 100MByte) and is sub-linear relative to the tree size. Thus, it is fair to say that the state explosion has been avoided.

It gives an accurate treatment of divergence despite the interference between divergence and compositionality. That is, a divergent process can delay other parallel processes indefinitely. Our solution is to keep lvgi actions visible and use fairness to guide the state space traversal out of unprogressing loops.

The output of the above procedure, say u', is in FT and its first element is the same as u. Continue to use the procedure on the second element and so on... It eventually leads to the output u' = ue. Therefore, contradiction.

order with any other action and can only be the last element in a trace. If Check (Ai , Av , DCT (LTS N )) is unsuccessful and deadlocking on e after a trace te on the generator and a trace u on the acceptor (deadlock on forcing e). Since d is not in t or u, (t, u) satisfies c0' when e = d , and (te, u) satisfies c0 when e /= d .

