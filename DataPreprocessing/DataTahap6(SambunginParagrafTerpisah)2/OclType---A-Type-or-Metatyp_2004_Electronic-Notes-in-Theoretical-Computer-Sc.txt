The OCL 2.0 proposal is currently neither consistent nor complete, e.g., the formal semantics of some newly introduced concepts such as OCL messages have not been considered sufficiently. But also concepts that were already present in OCL as part of UML 1.5 have still not been sufficiently defined, e.g., no semantics is provided for state-related operations, although the syntax allows to specify constraints over state activations.

Apart from those semantic issues, this article focuses on improved modeling of the predefined type OclType within the OCL Standard Library and correct specification of related operations. This work is therefore to be seen as a contribution to the finalization process of OCL for UML 2.0.

Naturally, it does not make sense to formulate constraints without a UML model to refer to. In the remainder, we will call this UML model the referred UML user model. Each Classifier 2 defined within the referred UML user model represents a distinct OCL type and is implicitly included in the OCL Standard Library as a subtype of OclAny.

Among the predefined OCL types of the Standard Library, OclType has a special role. That type captures all basic types that are known in the OCL type system. 3 The interesting point is that OclType on the one hand is inherently a sort of metaelement belonging to the metalevel M2, while on the other hand it has to be accessible on the user level M1 to formulate constraints that need to reason about object types (e.g., type conformance checks).

There are a number of problems already with the signatures of these op- erations. First, the signatures of operations = and <> are simply wrong for OclModelElement. Type OclModelElement is seen as an enumeration type in the OCL 2.0 proposal, where for each element in a given UML user model there is a corresponding enumeration literal. OclModelElement must there- fore comprise all user-defined Classifiers, but also all other model elements like Statechart states, transitions, events, operations, signals, etc. While it is questionable whether this type is necessary and makes sense at all, the cor- responding operation signatures must be corrected, i.e., the formal parameter types must be OclModelElement instead of OclType.

In the following sections, we will consider the definition and usage of type OclType within different approaches in the literature (Section 2) and the cur- rent OCL 2.0 proposal (Section 3). In Section 4, we then show how the powertype concept can be introduced to better integrate types defined at the user-level into the OCL Standard Library type system on level M1. Section 5 concludes this article.

In UML 1.5, there are even predefined operations provided for OclType to further access metalevel features, e.g., operations to get a list of attribute names, association end names, and direct as well as indirect supertype names (however, operations to extract subtypes are missing).

access for the modeler [1]. Operations as mentioned above do not need to be defined on OclType in their approach, as the UML core metamodel already provides such means, either directly or indirectly (by navigation along associa- tions in the UML core metamodel). It is also worth noting in this context that their metamodel does not allow nested collections which are now permitted in the OCL 2.0 proposal.

Operation oclIsNew() must return false when applied to datatype val- ues, as primitive values cannot dynamically be created or destroyed. This of course applies to the enumeration literals of OclType. (Or should this op- eration maybe return OclUndefined in these cases? The OCL 2.0 proposal does currently not specify the result.)

As another example, now assume a user-defined class Person and the OCL expression Person.allInstances(). Again, Person is identified as an enumeration literal of OclType, so what is the result of evaluating the corresponding OCL expression, i.e., what is the result of applying opera- tion allInstances() to an enumeration literal? This is clearly the wrong architectural level and not intended.

To conclude, there are several type-related difficulties introduced by the attempt to model OclType as an enumeration type in order to separate the predefined OCL types from the metalevel. On the other hand, it is not possible to properly formulate expressions with operations that reason about object types without (limited) access to the metalevel. It is also not possible to give a semantics of operations that reason about OCL types without accessing the metalevel.

Furthermore, it does simply not make sense to define allInstances() as an operation of the base type OclAny, as that operation should only be applied to types and not to objects. But with the currently proposed OCL type system, M1 types cannot be accessed, as user-defined classes (such as Person) and OCL types (such as OclVoid) are treated only as enumeration literals of the enumeration type OclType. It is simply not type conform to apply operation allInstances() to an enumeration literal, say Person, in order to obtain the set of objects of the class which the literal stands for.

Both return types are not quite correctly specified. On the one hand, an instance of OclType is an enumeration literal and can therefore not be the re-typed object as intended. On the other hand, the unnamed type T has no concrete meaning in the signature, as T appears together with parameterized types only, but there actually is no such type involved. The correct signature therefore is 2.0 proposal. Specifications for related operations such as oclIsTypeOf() and oclIsKindOf() can be formulated in a similar way. Unfortunately, two modeling levels have to be accessed, which is not desired in the OCL 2.0 proposal. Therefore, we are going to propose a different approach in the next section that finds a more elegant (and UML compliant) way to capture OCL types on modeling layer M1.

So far, none of the approaches for modeling OclType has considered the pow- ertype concept. Powertype is a UML core concept and denotes a dependency relationship among a generalization [5, Section 3.36]. A powertype is modeled as part of a class diagram residing on level M1. Basically, a powertype is a user-defined metaelement whose instances are classes of the user model. Thus, a powertype gives access to specialized types as instances.

The annotation complete means that all of the children of OclAny have been declared (whether they are shown or not shown) [5, Section 3.50]. Note that this does not contradict to the ellipsis used to represent the user- defined classes; we again argue that OCL expressions only make sense over a given UML model.

Furthermore, we propose to use the powertype concept to model the types accessible in OCL expressions on the modeling layer M1. In this context, a number of other open issues could be solved, e.g., we propose that operation allInstances() should no longer belong to OclAny, as it does not make sense to apply it to objects and datatype values. Instead, it naturally belongs to the powertype OclType.

standard that has obvious definiencies already in the fundamental definitions such as the discussed operations. We are aware that there are a lot of other open issues to discuss in the OCL 2.0 proposal, in particular w.r.t. the two semantics definitions that are currently neither consistent nor complete.

