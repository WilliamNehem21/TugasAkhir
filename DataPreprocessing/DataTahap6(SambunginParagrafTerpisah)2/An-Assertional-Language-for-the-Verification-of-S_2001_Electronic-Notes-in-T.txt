cation is to verify a property for any of its possible initial con gurations see (e.g. [2,6,10,8,14]). To illustrate the problem on a practical example, let us consider Petri Nets as abstract model of concurrent systems. Via the abstraction that maps processes to tokens, we can describe the behaviour of our system via places and transitions, and a possible initial con guration as an instance of a parametric initial marking (e.g., where K  1 tokens are in a given place). The goal here is to verify a given property for any value of the parameters in the initial marking (e.g. for any value of K). For safety properties, the previous problem can be

we propose an assertional language to symbolically represent in nite collections of states for systems parametric in several dimensions. For this purpose, we found technically convenient to combine notions coming from di erent elds like high level Petri Nets [16], constraints [23], multiset rewriting [19], and Constraint Logic Programming [15]. In particular, the notion of constraint is central to our construction. Following the terminology of [15], constraints can be viewed as formulas interpreted over a xed domain, and for which one uses specialized decision procedures, e.g., to test satis ability, and entailment. More in detail, our approach works as follows. To smoothly extend the ideas used in [1,2,8,14], we adopt Colored Petri Nets (CPNs) [16] as our general model of parameterized concurrent systems. Basically, CPNs are Petri Nets in which tokens can be colored with structured data. Di erently from [16] however, our presentation of CPNs is based on a combination of constraints with a restricted form of multiset rewriting. As shown in [19], multiset rewriting allows one to locally specify the behaviour of

veri cation and automated deduction. In fact, at least in principle, it is possible to express veri cation problems as the ones considered in the paper using AC Rewriting and specialized theories to represent and handle colors. As we will discuss at the end of the paper, it turns out, however, that the strategies used in existing automated deduction tools are not well-suited to solve problems like the one we are interested in (e.g. computing P re starting from and upward closed set of states). We believe that the application of automated theorem provers to solve parameterized veri cation problems, as well as nding decidable fragments and accelerations techniques are among the more interesting future direction of our research. In Section 2 and Section 3, we will brie y recall all concepts we need for our assertional language. The language is de ned in Section 4. In Section	5

we will discuss how to incorporate the language in the backward approach, and discuss the analysis of our case-study. In Section 6 we discuss related works and discuss a number of open problems we plan to address in our future work. Finally, in Section 7 we will draw some conclusions.

Colored Petri Nets (CPNs). Based on the previous de nition, a Colored Petri Net can be viewed as a tuple hP; Ri, where P is a set of predicates representing place names, and R is a set of multiset rewriting rules representing transitions. In the rest of the paper we will call con guration a multiset of ground atomic formulas. Con gurations are the `generalization' of Petri Net markings, where a token in er x (a nonnegative integer, chosen non-deterministically), moving to the state wait(x); (5) waiting processes can choose to go back thinking; (6) a resource x is assigned to a waiting process provided the semaphore of its monitor is not locked (i.e. the monitor is idle); (7) when a process releases the resource the monitor resets the lock. Note that in the previous speci cation we simply express the local interaction between one process and one monitor (the power of multiset rewrit- ing). The initial con guration of the protocol consists of the con guration start, that in turn generates a con gurations in which all processes are thinking, and all monitors are idle. For instance, a possible run from start is as follows (we will use )i to indicate the application of rule (i)):

I = ; (where P ost =P re  is the transitive closure of P ost=P re). When applied to parameterized veri cation, the backward approach has two advantages: (1) computing P re  can be done independently from the initial con guration; (2) bad con gurations often form upward-closed sets. Let us explain this intuition using our example. The safety property of the multiple test-and-lock protocol is that only one process per time can use a given resource; thus, Sbad is the set of con gurations containing the minimal violations: use(n) j use(n) for some resource-id n. To formalize the idea of `minimality' of a set, let us introduce the following ordering between con gurations:

In general the reverse implication does not hold. As a counter-example, simply take the rule p ! q1 j q2 and the singleton set S consisting of the multiset q1. Then, P re(S) = ;, whereas the multiset p belongs to P re(U p(S)). However, the following property holds.

This de nition can be extended to sets of constrained con gurations with disjoint variables (indicated as S; S0 ;:: :) in the natural way. For instance, if S  is the singleton containing use(x)juse(y) : x = y, then Inst(Sbad) is the set of con gurations having the form use(n)juse(n) for any n. Note that Inst(Sbad) does not model our intuition that constrained con gurations should generate all violations. Thus, instead of taking the set of instances as ` at' denotation of a set of constrained con guration S, we choose the rich denotation:

For instance, in our rst example we have that Sbad = [[Sbad]] as desired. In the rest of this section we will show how to formulate operations on sets of con gurations at the symbolic level of constrained con gurations w.r.t. the `rich' denotation [[ ]]. We anticipate here that all operations will be parametric on the constraint language used in the speci cation.

Intuitively, P re treats a con gurations as `representation' of its upward-closure. For instance, consider D = f0; 1g, and the rule p(x) ! q(x) : true. Then, P re(fq(1)g) returns p(1) as well as p(0) j q(1). In fact, p(0) rewtites into q(1), whereas p(0) j q(1) rewrites into q(0) j q(1) that belongs to the upward-closure of q(1). The new operator satis es the following property.

For instance, consider p(x; y) ! q(x; y) : x  0;y = 1. Given the singleton S with q(u; w) : u = 1;w  0, Pre(S) should contain p(x; y) : x = 1;y = 1 as well as p(x; y) j q(u; w) : x  0;y = 1;u = 1;w  0 (e.g., p(4; 1) j q(1; 5) rewrites into q(4; 1) j q(1; 5) 2 [[S]].) The latter constrained multiset can be obtained by setting M0 = B0 = (the empty multiset) when applying Pre to S. The new operator enjoys the following properties

In their seminal paper [2], Abdulla and Jonsson proposed an assertional language for Timed Petri Nets in which they use dedicated data structures to symbolically represent markings parametric in the number of tokens and in the age associated to tokens. In [3], Abdulla and Nyl en formulate a symbolic algorithm using di er- ence constraints to represent the state-space of Time Petri Nets. Our approach is an attempt to generalize the ideas of [2,3] to problems and constraint systems that do not depend strictly on time. In our opinion the combination of multiset rewriting and constraints is an elegant way to achieve the goal.

