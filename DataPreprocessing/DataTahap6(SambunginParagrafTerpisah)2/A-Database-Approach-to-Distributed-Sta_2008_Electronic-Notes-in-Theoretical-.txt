We study distributed state space generation on a cluster of workstations. It is explained why state space partitioning by a global hash function is problematic when states contain variables from unbounded domains, such as lists or other recursive datatypes. Our solution is to introduce a database which maintains a global numbering of state values. We also describe tree-compression, a technique of recursive state folding, and show that it is superior to manipulating plain state vectors.

We study distributed explicit state space generation on a cluster of workstations in the presence of recursive data types, like lists and trees. Recursive data types allow natural modeling of data needed in complicated protocols and distributed systems, e.g., the current knowledge of an intruder in security protocols. Such systems can be analyzed by finite state model checkers, when the scenario is limited to a fixed number of participants. However, an upper bound on the size of the data terms is not known a priori.

We show that the basic scheme for distributed state space generation based on a shared hash function is limited (Sec. 2.2). It breaks down in the presence of state space generators that produce recursive data types. Implementing them as acyclic pointer structures works well on one computer but sharing pointer structures over a number of workstations is non-trivial.

Our solution (Sec. 3) is to introduce a database (basically an indexed set) that maintains a global numbering of values that occur in state vectors. Instead of exchanging vectors of (serialized) pointer structures, the workers now exchange vectors of indices. In addition, workers must communicate with the database in order to agree on the semantics of these indices.

A further improvement (Sec. 3.3) is to recursively fold states using a tree of databases. Each node in this tree represents a set of subvectors. The leaf databases store sets of individual state components, while the root database represents a set of full state vectors by pairs of integers. This so-called tree-compression reduces the memory needed to store a set of states.

We implemented several versions (Sec. 5), in order to measure the effects of recursive state folding, and the effects of organizing the intermediate node databases globally or locally. We report an interesting trade-off for organizing the internal databases locally or globally, depending on the available bandwidth and latency of the underlying network.

In these algorithms, the state space is partitioned over the memory of W workers by a hash function. Each worker keeps its own part of the explored state space in Closed W. The states that still have to be explored are kept in the set Open W. The Explore-thread picks an open state, calculates the hash of all its successors in order to put them in the local Queue of the right owners. The Receive-thread picks states from the local Queue, checks if they are new by consulting Closed , and if so, adds the state to both the Closed set (to avoid duplicate exploration) and the Open set (to be explored by Explore).

The other problem is that in order to transmit a state across the network it has to be serialized into a flat binary form. Se- rializing an array of integers is very effi- cient. Serializing an array of ATerms, how- ever, is a serious problem: the printed ver- sion of a single ATerm often takes 40 bytes or more, because typically the sharing gets lost. That means that it is factor 10 larger than the pointer we started with. It be- comes infeasible, if we consider that a state

Furthermore, we can communicate the (compressed) index vectors to other work- ers W . This reduces bandwidth demands between workers, however we must keep in mind their additional communication to the database. We will return to this point in Sec. 3.2.

In the example and in our implementation, we chose to split the vector in half each time. This is a reasonable assumption if one does not have additional knowl- edge about the vector. But in some cases, we know in advance that one of the vector positions is going to have a lot of different elements. In that case it would be useful to split the vector in a short and a long part where the element with many different values is in the short part. Permuting the vector can also have large effects. We leave research in this direction for future work.

Ciardo et al. consider multi-valued decision diagrams (MDDs) for efficient stor- age of state sets [10]. A distributed version is described in [7]. MDDs branch according to the value of state variables, while our trees branch on the position of variables in the state vector.

Results for models of three different sizes: Lift5 is the model of an elevator system with multiple legs in order to lift large vehicles [14]. SWP is a model of the Sliding Window Protocol [1]. CCP33 models the cache coherence protocol Jackal for Java programs [16]. Columns are explained in Sec. 5.

We enhanced the basic scheme of distributed state space generation with a global database, in order to provide a globally unique representation of values from re- cursive data types. The round-trip costs are lowered by using database replication. Furthermore, we introduced tree compression as a means of compressing state spaces by means of recursive state folding. Local and global (but replicated) implemen- tations of index databases have been implemented and their effect on latency and throughput was measured. Speed

We see three lines of future research regarding tree compression. So far, we only experimented with exchanging long index vectors (no tree compression) or index vectors of length 2 (full tree compression). Intermediate solutions are possible too. It would be interesting to experimentally establish an optimal cut-off point for state vector compression, or even build an adaptive tool that dynamically finds the optimum w.r.t. a given model and cluster.

Finally, another interesting possibility is to adapt our scheme to heterogeneous systems, where several clusters of workstations are connected by a high-latency network to form a grid. In such settings, databases could be local to a cluster, providing indices that are unique within a cluster. This would allow to exchange compressed vectors within a cluster, while across clusters uncompressed vectors have to be exchanged in order to contain the effects of latency.

