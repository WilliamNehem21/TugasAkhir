After discussing the issues involved in higher-order session communication, this report also proposes a session typing system which allows a more liberal higher- order session communication, based on the work of Gay and Hole [12] and already used in [23]. The full proofs of the two theorems are firstly given in this report, which also clarifies some definitions absent in [13]. The motivation to why the present authors should redo the proofs nine years after is the discovery of a subtle counterexample to the results in some works on session types published after the work under consideration, although not to results of the original system [13]. We explain the problem in detail in Section 3.

A session is a series of reciprocal interactions between two parties, possibly with branching and recursion, and serves as a unit of abstraction for describing interac- tion. Communications belonging to a session are performed via a port, specific to that session, called a channel. A fresh channel is generated when initiating each session, for the use in safe communications.

Structured communication-based programming allows a clear description of com- plex interaction structures beyond conventional communication primitives. The more complex the interaction becomes, the more difficult it is to capture the whole interactive behaviour and to write correct programs. The session type discipline offers a simple static checking framework to guarantee the correctness of commu- nication patterns in such situations. It guarantees that well-typed programs are exempt from incompatibility in interaction patterns.

However there is one important addition with respect to the typing system in [13]: the [Bot]-rule. Without the [Bot]-rule, subject congruence (Lemma 2.9) does not hold. Take for example process throw k[k']; inact | inact structural congruent to throw k[k']; inact. We have does not allow the transmission of an arbitrary channel. In most situations a process catch k(k'') in P2 can be alpha-converted ahead of communication 3 so that the bound variable k'' syntactically matches the free variable k' in the throw process. The exception happens exactly when k' is free in P2: alpha-conversion becomes impossible (for it would capture free variable k'), and communication cannot occur. A more liberal rule would allow the transmission of an arbitrary channel, im-

A different alternative would be to type the contractum with a different typing. In the above case and for the catch process in the redex, we have k' : ![nat]; end, and k'' : ?[nat]; end. In the contractum, channels k' and k'' are aliased and it is not obvious how to build, from the premises, the correct type ?[nat]; ![nat]; end for k'.

which is not typable. The last step is then to consider, for Subject Reduction and Type Safety purposes, only typings where the two ends of a channel are of dual types. We call such typings balanced [12]. This restriction rules out the above typing (since ![bool]; end is not dual to ?[nat]; end), hence process (5) is not guaranteed to preserve typability under reduction or to be type safe.

