The spark of the K framework [14] is the observation that computation is expressed naturally with rewriting. The source of inspiration for K is the Rewriting Logic Semantics project [9,19,10] which has the declared purpose of unifying algebraic denotational semantics and operational semantics. This unification is achieved by considering the two semantics as different views over the same object. Namely, denotational semantics views the rewriting logic specification of a language as a designated model, while operational semantics focuses on the execution of the same specification.

In Section 2 we present an infrastructure for the K specification of analy- sis/verification methods for pushdown systems. In more detail, in Section 2.1 we present a discussion on the K representation of pushdown systems. We use the K specification of a pushdown system as support for deriving the analysis/verification infrastructure in Section 2.2. We also argue the opportunity to consider pushdown systems and their K specification in Section 2.3.

This is a research language introduced in [17,16] with several bisimilar semantics. In Section 3.1 we present the K specification of one of these semantics. In partic- ular, this semantics exhibits algorithmic details which emphasize the versatility of K in the area of algorithm formulation.

We present next a general technique for specifying pushdown systems in K, by means of abstraction. First we establish a frame for the K specification of finite pushdown systems. Then we describe how to transform an infinite pushdown system into a K specification of a finite pushdown system. This transformation is given as an abstraction.

Based on the results in [3], if there exists an infinite path in a finite pushdown system, then this is lasso shaped, i.e., there is a prefix of this path that ends in a loop. Namely, an infinite path presents a repetitive stack pattern as follows: where Bag is the predefined K sort. The cells traces and tracesj are meant to guide the rewriting in order to obtain a breadth-first exhaustive execution. As such, traces contains the current execution level, while in tracesj we construct the next level. The breadth-first strategy is tantamount to imposing fairness in the application of rewrite rules. As usual, we need some fairness condition to ensure the monotonicity of the fixpoint iteration.

Consider the K specification S for the semantics of a language and a program P in this programming language. According to the methodology provided in [20] for designing S , the k-cell behaves as the stack, while the control location is maintained by the cells containing the memory and the program. In this view, the semantics S is tantamount to the specification of pushdown systems produced by the syntactic part of S as stack language and all the cells, besides k, as control location. Note, however, that there are restrictions as, for example, the matching in the k cell has to be made always at the top.

The finiteness of the pushdown system produced for a program P with a spec- ification S is, nonetheless, worth discussing from the point of view of the analy- sis/verification methods. Infinite pushdown systems are usually handled by abstract interpretation via a sound finite projection which is expressive enough to render the desired result for the analysis/verification method of interest. Following the per- spective of abstract interpretation for state abstractions, the control locations of a pushdown system are coerced into a finite frame by means of a meta-operator.

