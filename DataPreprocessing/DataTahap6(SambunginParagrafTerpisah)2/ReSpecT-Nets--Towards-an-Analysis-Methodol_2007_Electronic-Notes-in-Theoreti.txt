In this paper we introduce ReSpecT nets, a formalism that can be used to describe reactive behaviours that can succeed and fail, and that allows for an encoding to Petri nets with inhibitor arcs. ReSpecT nets are introduced to give a core model to a fragment of the ReSpecT language, and to pave the way for devising an analysis methodology including formal verification of safety and liveness properties. In particular, we provide a semantics to ReSpecT specifications through a mapping to ReSpecT nets. The potential of this approach for the analysis of ReSpecT specifications is discussed, presenting initial results for the analysis of safety properties.

In the following, given a set X we let it be ranged over by meta-variable x and its decorations x', x0, and so on. Symbol X is used for the set of multisets over X, ranged over by x: its elements are of the kind x||x ||..||x  (possibly with repeti- tions), and  is used for the void multiset.

. Communication events can either be caused by external events (listening or speaking events), or be raised when a reaction primitive is executed. The execution of a reaction is to be considered atomic, in the sense that if any of its goals cannot be executed the whole reaction fails and does not affect the tuple space state in any way.

To make a ground ReSpecT specification flow-oriented, we proceed in the following steps: (i) translate c-RSTs, (ii) translate r-RSTs and their calls, (iii) resolve head clashing in different r-RSTs, and (iv) reorder the body of r-RSTs. These four steps are described in detail in the following. For shortness, we name here specification tuples re(head,body) instead of reaction(head,body).

Often, primitive no r(t) is used to check whether a transformation process over set of tuples is over, though the overall process is still a monotonic one preserving the well-structure. A simple example is the case where all the tuples t a occurring in the tuple space have to be substituted by tuples t b. This interaction pattern resembles broadcast protocols [10], which are shown to retain the well-structure property [12]. Such a tuple transformation can e.g. be realised by the flow-oriented ReSpecT specification:

The main limit of the approach presented in this paper is the lack of treatment for logic variables and unification. On the one hand, this a typical problem due to the intrinsic dichotomy between operational and declarative, logic-based formal frameworks. On the other hand, a possible solution to this problem is to exploit techniques of groundisation of general, non-ground ReSpecT specifications: under simple hypotheses like a finite alphabet and finite data structures (such as non- recursive functors), the number of possible ground versions of any general ReSpecT specification is finite, and the automatic translation techniques introduced in this paper become applicable again. Future work is likely to follow such research line soon.

