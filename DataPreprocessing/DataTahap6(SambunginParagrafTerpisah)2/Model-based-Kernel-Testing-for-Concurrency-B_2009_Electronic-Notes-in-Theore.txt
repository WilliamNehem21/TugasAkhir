Despite the growing need for customized operating system kernels for embedded devices, kernel development continues to suffer from high development and testing costs for several reasons, including the high complexity of the kernel code, the infeasibility of unit testing, exponential numbers of concurrent behaviors, and a lack of proper tool support. To alleviate these difficulties, this study proposes the MOdel-based KERnel Testing (MOKERT) framework, which supports detection of concurrency bugs in the kernel by combining both model checking techniques and testing methods. The MOKERT framework was applied to the file systems of the Linux 2.6 kernel and found a data race bug in the proc file system.

There are few tools that can support kernel testing, as the side effects caused by the testing tool/environment at the kernel space can halt the kernel or cause unexpected behaviors. In addition, testing tools often depend on libraries that cannot be used in the kernel environment. For these reasons, kernel developers continue to use printk() or a kernel log as a main debugging aid.

This study proposes a model-based testing framework for concurrency bugs in the kernel by using model extraction [3] and model checking techniques [4]. Con- sidering the difficulties of testing the kernel as mentioned earlier, model checking presents a viable alternative approach for analyzing kernels, since this technique can analyze each component of the complex kernel independently by modeling the component and the related portion of the environment in an abstract manner. In addition, model checking can explore numerous scenarios exhaustively, and gener- ate concrete counter examples, which can be a useful aid to debugging. However, a pure model checking approach alone is problematic in that a developer cannot know whether a counter example detected through model checking is an actual bug or a false alarm due to the gap between the abstract model and target code.

Promela (a modeling language of the Spin model checker) is similar to the C pro- gramming language in several aspects. First, Promela provides control statements such as if, goto, and do. In addition, Promela models complex data structures using typedef and arrays, although pointer variables are not directly supported. Also, Promela supports inline functions which can simulate C functions.

The MOdel-based KERnel Testing (MOKERT) framework applies the analysis re- sult (i.e., a counter example) from model checking to the original target program so as to alleviate the difficulties of debugging concurrency bugs in the kernel code. Most model checking frameworks do not suitably consider this issue, although it is crucial for the success of model checking techniques in the software industry.

MOKERT allows a user to replay one counter example repeatedly. Thus, a user can conveniently identify the genuine cause of the counter example in the kernel code, not merely in the corresponding abstract formal model. This can be a very useful aid for detecting concurrency bugs, as thread scheduling should be controlled manually otherwise.

Kernel bugs are often reported through manual code inspections, discussions, or artificial scenarios without actual testing, due to the difficulties involved with kernel testing (see Section 1). Thus, for example, the Linux Changelog contains dozens of bug patches that are not necessary or that do not fix a bug correctly. MOKERT can help users validate a bug patch by modifying the model according to the bug patch and model checking it to check whether the bug patch actually removes the bug. If the model checker generates a counter example, MOKERT can replay the counter example to check whether it is due to the incorrect bug patch or a false alarm.

At the run-time phase, the target threads execute with a controller thread and a monitor thread. The controller thread controls scheduling of the target threads via the inserted probes. The monitor thread monitors the target threads and the controller thread, and checks whether the counter example is replayed correctly or not.

The first case is what we expect from replaying the counter example. The second and the third cases indicate that replaying the counter example fails. If the last step of the counter example is not reached within a given amount of time, the monitor notifies a user of the replay failure with log information such as the status of each target thread and the function call stack. Replay failures can occur for the following reasons:

By analyzing vfs readdir() and do rmdir() where the execution stalled, it was found that ext2 readdir() was protected by the mutex in vfs readdir(), as indicated at lines 33 and 39 of vfs readdir(), and ext2 rmdir() was pro- tected by the same mutex at lines 2064 and 2072 in do rmdir(). Considering that ext2 readdir() and ext2 rmdir() could be invoked only from vfs readdir() and do rmdir(), the data race detected from our model for ext2 readdir() and ext2 rmdir() was a false alarm. After we refined the model to include vfs readdir() and do rmdir(), Spin did not generate a counter example.

This paper proposed the MOKERT framework to detect concurrency bugs in the kernel. The framework applies the analysis result of model checking (i.e., a counter example) to the actual kernel code. Thus, the framework increases the level of user confidence, as it confirms the exhaustive model checking result on the real kernel code. We have demonstrated the effectiveness of the framework through three case studies on the the file systems of the Linux 2.6 kernel and found a hidden data race bug in the proc file system.

