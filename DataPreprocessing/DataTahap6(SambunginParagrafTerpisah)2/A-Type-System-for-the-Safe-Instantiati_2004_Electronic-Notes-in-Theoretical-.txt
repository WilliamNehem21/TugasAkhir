Component composition can lead to multiple instances of the same component. Some components can have only one instance loaded at a time, for example, when a unique external resource is used. We give an abstract component language and a type system ensuring the safe instantiation of components. Language features are instantiation, composition and a simple scope mechanism for discharging instances.

The simple binding mechanism for components used here bears similarity to let binding in functional languages such as ML [11], and hence to lambda abstraction and application. However, the types used here are completely different. To some extent it turned out to be possible to develop our type theory along the lines of so-called Pure Type Systems (PTSs), see [3]. This increased our confidence in the abstractions chosen and can be viewed as a tribute to the generality of PTSs.

The intuition behind our types bears some similarity to so-called linear types [2,6]. Linear types usually express that a value will be used exactly once within its scope, as opposed to at most once in our case. This difference is reflected in our Weakening and Start rules (see below). Nevertheless, the

This paper is organized as follows. In the next section we develop the component language with its terms and operational semantics. We define types and typing relation in Section 3. Then we prove some properties of the type system in Section 4. We outline a polynomial time type inference algorithm in Section 5 before ending with some conclusions and indications of future research. Technical proofs are delegated to the appendix.

A component expression E may use several components. Among the latter there are instances that exist for the whole lifetime of E, whereas other in- stances live only for a while and are then discharged. Therefore we use two sets to represent the type of a component expression. The first set Xi col- lects all components instantiated during the lifetime of the expression and the second set Xo consists of those components that have instances surviving the execution of the expression.

Continuing the example in Section 2.1, we show the type derivation tree for {new b new d }new a . First, a typing for new b can be derived as follows: (The names of the typing rules are shortened to their first three letters.)

Definition 3.4 [Well-typed program] A well-formed program P = Decl; Exp is well-typed if Exp can be typed in a basis built from Decl. Here it is understood that the declarations may have to be reordered to form a legal basis.

In this section we will state some properties of our type system. The invariant theorem and its correctness corollary at the end of the section relate the type system to the operational semantics. In order to prove the invariant property some definitions and lemmas are needed. Some technical proofs of lemmas are delegated to Appendix A, to improve the readability of this section.

