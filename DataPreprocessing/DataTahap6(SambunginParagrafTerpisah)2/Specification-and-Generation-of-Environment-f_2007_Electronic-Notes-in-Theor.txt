Model checking of isolated software components is inherently not possible because a component does not form a complete program with an explicit starting point. To overcome this obstacle, it is typically necessary to create an environment of the component which is the intended subject to model checking. We present our approach to automated environment generation that is based on behavior protocols [9]; to our knowledge, this is the only environment generator designed for model checking of software components. We compare it with the approach taken in the Bandera Environment Generator tool [12], designed for model checking of sets of Java classes.

Model checking is one of the approaches to formal verification of software systems that gets a lot of attention at present. Still, there are some obstacles that have to be addressed, at least partially, before model checking of software can be widely used in practice. Probably the biggest problem is the size of state space typical for software systems. One solution to this problem (state explosion) is the decomposition of a software system into small and well-defined units, components.

The remainder of the paper is organized as follows. Sect. 2 provides an example to illustrate the problem of environment generation and Sect. 3 introduces the Bandera Environment Generator (BEG) [12]. Sect. 4 starts with an overview of behavior protocols [9] and then presents the key contribution - the description of our approach to specification and generation of environment based on behavior protocols. Sect. 5 provides comparison of the two approaches and briefly mentions our proof of concept implementation. The rest of the paper contains related work and a conclusion.

Obviously, creating an environment by hand is hard and tedious work even in simple cases. A straightforward solution to this problem is to automatically generate the environment from a higher-level abstraction than the code provides. In Sect. 3 and 4, we present two solutions based on this idea.

i.e. those featuring a main method. It is composed of several modules - model extractor, model translator, environment generator, and model checker, to name the key of them. The model extractor extracts a (finite) internal model from Java source code and the model translator translates the internal model into the input language of a target model checker. Here, the Bandera tool set supported the Spin and Java PathFinder model checkers originally, but currently it is intended mainly for a Bandera specific model checker (Bogor [11]).

The Bandera Environment Generator (BEG) [12] is a tool for automated generation of environment for Java classes. Given a complete Java program, the user of the BEG tool has to decompose the program into two parts - the tested unit, i.e. the classes to be tested, and its environment. Since the environment part is usually too complex for the purpose of model checking, it is necessary to create an abstract environment. This abstract environment can be generated from a model created

The BEG tool also allows to specify parameter values of method calls on the tested classes. If the value of a parameter is not specified, as in the thread T0 above, then it is non-deterministically selected from all the available values of a given type (e.g. from all allocated instances of a given class in the case of a reference type) during model checking. As a parameter to a method call, it is even possible to use a variable defined in the instantiations section (such as x above).

The example above presents also several operators. The ; character is the se- quence operator, * is the repetition operator and || is the or-parallel operator. Behavior protocols support also an alternative operator + and an and-parallel op- erator |. In fact, the or-parallel operator is only a shortcut; e.g. a || b stands for a + b + (a | b). The | operator denotes all the possible interleavings of traces that correspond to its operands.

Each component has a frame protocol associated with it, and a composite compo- nent can have also an architecture protocol [9]. The frame protocol of a component describes its external behavior, what means that it can contain only the events on external interfaces of the component. On the other hand, the architecture protocol describes the behavior of a component in terms of composition of its subcomponents at the first level of nesting.

When checking a component application specified via ADL with behavior proto- cols, it is necessary (i) for each composite component in the hierarchy to check compositional compliance of subcomponents at the first level of nesting and also compliance of a frame protocol with an architecture protocol (ii) and for each prim- itive component to verify that an implementation of the component obeys its frame protocol. For the purpose of checking compliance of protocols, we use the protocol checker [7] developed in our research group, and for checking that a primitive com- ponent obeys its frame protocol, we use a tool created via cooperation of JPF with our protocol checker [8]. The tool has to be applied to a program composed of a target component and its environment.

Our environment generator accepts all syntactically valid frame protocols with the exception of protocols of the form ?a + !b and !a* ; ?b. The reason for not supporting frame protocols of the form ?a + !b is that the environment driven by inversion of such a protocol cannot determine how long it should wait for the !b event to occur before it emits a call that corresponds to the ?a event and therefore disables the other alternative (i.e. !b). Protocols of the form !a* ; ?b are not supported for a similar reason - the environment is not able to determine when the repetition !a* is going to finish. It is recommended to use protocols of the form

Our solution to specification of the possible values of method parameters is based on the idea that the user defines the set of values which are to be considered as parameters. From the implementation point of view, these sets are to be put into a special Java class serving as a container for all the sets of values. The value of a method parameter of certain type is later non-deterministically selected from the set of values considered for that type and method. In addition to the sets of values common for the whole component, it is also possible to define sets that are specific to a particular method or interface.

There are also tools that solve the problem of automatic generation of environ- ment for fragments of procedural programs (e.g. drivers, libraries, etc). An example of such a tool is the SLAM [4] model checker, which is a part of the SDV tool for ver- ification of device drivers for the Windows operating system. Given a program, the checker creates a Boolean abstraction of the program (all value types approximated by Boolean) and then checks whether some desired temporal properties hold for the abstraction. It uses the principle of refinement to discard errors that are present in the abstraction but not in the original program (false negatives). The environment for device drivers is defined by the interfaces provided by the Windows kernel. The SLAM tool models the environment via training [3]. Here, the basic principle is that, for a certain procedure P that is to be modeled, it first takes several drivers that use the procedure P, then it runs the SDV tool on those drivers and therefore gets several Boolean abstractions of the procedure P, and finally merges all those abstractions and puts the resulting Boolean abstraction of the kernel procedure P into a library for future reuse.

Our tool for environment generation is partially based on [10]. The tool that is described in the thesis, designed for the Bandera tool set, also uses the inverted frame protocol idea; it is also focused on components compliant to the Fractal Component Model [5]. We decided not to use this tool mainly because it generates an environment that increases the state space size quite significantly, since it does not employ any of transformations described in Sect. 4.3 and also does not provide any means for specification of method parameter values - all that makes it almost unusable in practice.

