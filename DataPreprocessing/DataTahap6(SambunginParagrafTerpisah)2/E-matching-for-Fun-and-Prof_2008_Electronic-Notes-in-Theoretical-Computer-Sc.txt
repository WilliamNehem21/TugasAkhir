Efficient handling of quantifiers is crucial for solving software verification problems. E-matching algorithms are used in satisfiability modulo theories solvers that handle quantified formulas through instantiation. Two novel, efficient algorithms for solving the E-matching problem are presented and compared to a well-known algorithm described in the literature.

Because we do not treat boolean formulas as terms, it is sometimes not possible to designate a single trigger containing all the variables that are quan- tified. A classical example is the transitivity axiom. In such a case we use a multitrigger, which is a set of triggers, hopefully sharing variables, that are supposed to match simultaneously.

This section describes a novel matching algorithm, optimized for linear trig- gers. A linear trigger is a trigger in which each variable occurs at most once. Most triggers used in the program verification problems we have inspected are linear. The linearity means that matching problems for subterms of a trigger are independent, which allows for more efficient processing.

which yields {[x := a, y := f (c)], [x := a, y := f (d)], [x := c, y := c]}. The ordering of terms used in the example is a < b < c < d < f (a) < f (c) < f (d). We now define an analogous for s-trees of the operators H and H we defined earlier for sets of substitutions. Formally, the operators are defined so that

During performance testing, we found that most triggers shared the head sym- bol and matching them was taking a considerable amount of time. Moreover, the triggers had a very simple form: f (x, c) 11 . This form is a specific exam- ple of something we call flat triggers. A flat trigger is a trigger in which each variable occurs at most once and at a depth of one.

Flat triggers with a given head can be matched all at once by constructing a tree that indexes all the triggers with the given function symbol in the head. Such a tree can be viewed as a special kind of a discrimination tree [16], where we consider each child of the pattern as a constant term, instead of traversing it pre-order. Unlike in discrimination trees used for matching our index has non-ground terms and queries are ground.

We have implemented all three algorithms inside the Fx7 SMT solver 12 . Fx7 is implemented in the Nemerle [13] language and runs on the .NET platform. In each case the implementation is highly optimized and only unsatisfactory results with the simplify match algorithm led to designing and implementing the second and the third algorithm.

An important point to consider in the design of matching algorithms is incrementality. The prover will typically match, assert some facts, and then match again. The prover is then interested only in receiving the new results. The Simplify technical report [7] cites two optimizations to deal with incre- mentality. We have implemented one of them, the mod-time optimization, in all three algorithms. The effects are mixed, mainly because our usage patterns of the matching algorithm are different than those of Simplify: we generally change the E-graph more between matchings due to our proof search strategy. To achieve incrementality we memoize s-trees returned on a given proof path and then use the subtraction operation on s-trees to remove substitutions that had been returned previously. The subtraction on s-trees corresponds to

The tests were performed on a 1 GHz Pentium III box with 512 MiB of RAM running Linux and Nemerle r7446 on top of Mono 1.2.3. The memory used was always under 200 MiB. We ran the prover on a randomly selected set of verification queries generated by the ESC/Java [10] and Boogie [2] tools.

The E-matching problem was first described, along with a solution, in the Simplify technical report [7]. We know several SMT solvers, like Zap [1], CVC3 [4], Verifun [9], Yices [8] and Ergo [5] include matching algorithms, though there seem to be no publications describing their algorithms. Specif- ically, Zap uses a different algorithm that also relies on the fact of triggers being linear and uses a different kind of s-trees. Zap, however, does not do anything special about flat triggers.

triggers. We, on the other hand, exploit sharing in the bottom parts of triggers, and the flat matcher handles the case of simple triggers that share only the head symbol. The Z3 authors also propose an index on the ground terms that is used to speed up matching in an incremental usage pattern. Such an index could perhaps be used also with our approach. Of course, the usefulness of all these techniques largely depends on benchmarks and the particular search strategy employed in an SMT solver.

During the 2007 SMT competition [3] there were four solvers participating in the Arithmetic, Uninterpreted Functions, Linear Integer Arithmetic and Arrays (AUFLIA) division. The AUFLIA division includes software verifica- tion problems and is the only one involving heavy use of quantifier reasoning. Z3 was first and Fx7 was second, with the same number of solved benchmarks but much worse run time. Both solvers used improved matching algorithms, while other participants (CVC3 and Yices) did not, which is some indication of importance of E-matching in this kind of benchmarks.

Kiniry, J. R. and D. R. Cok, ESC/Java2: Uniting ESC/Java and JML: Progress and issues in building and using ESC/Java2 and a report on a case study involving the use of ESC/Java2 to verify portions of an Internet voting tally system, in: Construction and Analysis of Safe, Secure and Interoperable Smart Devices: International Workshop, CASSIS 2004, LNCS 3362, 2005.

