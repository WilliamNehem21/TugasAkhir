The high availability of a huge number of documents on the Web makes plagiarism very attractive and easy. This plagiarism concerns any kind of document, natural language texts as well as more structured information such as programs. In order to cope with this problem, many tools and algorithms have been proposed to find similarities. In this paper we present a new algorithm designed to detect similarities in source codes. Contrary to existing methods, this algorithm relies on the notion of function and focuses on obfuscation with inlining and outlining of functions. This method is also efficient against insertions, deletions and permutations of instruction blocks. It is based on code factorization and uses adapted pattern matching algorithms and structures such as suffix arrays.

This technique consists in splitting each original function into sub-functions, sharing as much sub-functions as possible between original functions. The whole source code is then represented by a call graph: the vertices are the functions and the edges are the function calls. Thus, similar functions should derive in an identical, or comparable, set of sub-functions, i.e., leaves of the call graph. Depending on the measurement used to evaluate (sub-)function similarities, this technique may not be sensible to insertion, deletion, inver- sion, inlining or outlining of source code which are the most common methods of obfuscation.

The rest of this paper is organized as follows. Section 2 gives an overview of the whole detection process. The main steps of the factorization algorithm and call graph analysis are detailed in section 3 and 4. Related work and benchmarks are discussed in sections 5 and 6. The paper then presents a conclusion and introduces some future work.

Our work is directed towards finding similarities in source code in procedural languages at the level of function. Our aim is to experiment a similarity de- tection technique based on function transformations. Indeed, to be insensitive to outlining, inlining and source block displacements, we manipulate abstrac- tions of the programs that are call graphs. Initially, the call graph is the one of the original program. Next, by using several algorithms, the call graph is enriched with new synthetic sub-functions that represent the granularity of similarities.

The process of factorization we apply is based on the algorithm previously de- scribed, which is iterated several times. Nevertheless, each iteration provides us with a call graph whose nodes are functions, with leaves being primitive functions (composed of only primitive tokens). This graph could be used to define and measure some metrics, or scores, relative to similarity between two functions. We will first define abstract metrics qualifying similarity between

Many research work has already focused on the detection of similarities. Among them, some look for similarities in free texts [7], in this section, however, we will focus on research work that search similarities in source code. These work may be divided into two main groups depending on their aim.

The first group of work focuses on software engineering. It attempts to find exact matching in order to factorize redundant cut-and-paste or to follow the evolutions between different versions of one project. Usually they do not address the problem of obfuscation. In this context exact methods of pattern matching [1,9,3] and complex algorithms on the abstract syntax trees [2] or the dependency graphs [10,15] may be applied. Several tools such as CCFinder [4] or CloneDR [6] are used to implement these approaches.

Our factorization method for finding similarities in source code shows modest but promising results on preliminary tests. Its main advantage relies on the resistance against obfuscatory methods such as inlining, outlining or shift of blocks of code. We discuss here the limits of our approach and future developments to be considered.

Extreme outlining over the set of functions of projects could result in few short leaf functions (especially when using abstract tokens). For example all of the instructions and assignments could be outlined in leaf functions. Since our method does not consider the order of called functions, the precision is reduced. Some false positives may appear. This is why an upper threshold for the lengths of the leaf functions must be set. Considering new metrics for the comparison of pair of functions that takes into account the order of function calls may be envisaged. Furthermore, some data-flow analysis could be performed on specific parts of the code to reduce false positives.

Currently, our method does not deal with function calls with one or more function calls as argument. This type of situation is not unusual in source code and raises interesting schemes for obfuscation. A preliminary approach could add temporary local variables to unfold the composed calls into intermediate assignments.

Presently, results of outlining processes are viewable as partial outlining graphs where leaf functions are selected according to their attainability from initial functions. Similarity between functions or clusters are used to locate similarities. A more human-friendly tool for the render of results remains to be studied.

