We present an approach for the veri cation of Erlang programs using abstract inter- pretation and model checking. In previous work we de ned a framework for abstract interpretations for Erlang. In this framework it is guaranteed, that the abstract op- erational semantics preserves all paths of the standard operational semantics. We consider properties that have to hold on all paths of a system, like properties in LTL. If these properties can be proven for the abstract operational semantics, then they also hold for the Erlang program. The proof can be automated with model checking if the abstract operational semantics is a  nite transition system.  But for nite domain abstract interpretations we get in nite state systems and model checking is undecidable. In this paper we de ne an abstraction of the control{ ow. It replaces recursive calls in non-tail positions by jumps to the last call of the same function. The corresponding returns are replace by jumps to the possible return points.

We propose an extension of model checking to programs written in real programming languages. However the model checking problem in general is undecidable for system implementations using programming languages and properties described in interesting logics. Hence we need abstraction [5,13,16]. In industry the programming language Erlang [1] is used for the implemen- tation of distributed systems. We have developed a framework for abstract interpretations for a core fragment of Erlang in [10] with the property that the transition system de ned by the abstract operational semantics (AOS) includes all paths of the standard operational semantics (SOS). Because the AOS can sometimes have more paths than the SOS, it is only possible to prove properties that have to be ful lled on all paths, like in linear time logic (LTL). If the abstraction ful lls a property expressed in LTL, then also the program ful lls it, but not vice versa.  If the AOS is a  nite transition system, then

The de ned abstraction does only yield a nite transition system for a subclass of Erlang programs, called hierarchical programs [10]. Recursion is only allowed in tail positions. However, in practice many Erlang programs do not ful ll this restriction. For example, already the standard de nitions of append or length are not hierarchical. Hence programs which use such func- tions cannot be abstracted to nite state transition system with the presented technique of abstract interpretation. The cause is the context-free structure of functional programs. In this paper we de ne an abstraction of this context- free structure, to a regular one. We obtain a nite state transition system. Properties of the system can automatically be proven with LTL model check- ing.

In Section 2 we de ne the syntax for a core fragment of Erlang. We sketch the operational semantics in Section 3. The framework for the abstract inter- pretation is shortly introduced in Section 4 and its restrictions are presented in Section 5. In Section 6 we present a graph semantics, on which our ab- straction is based. We motivate the idea of our abstraction in Section 7 and formalize it in Section 8. Section 9 presents its use in model checking and

All de ned functions of a program, extended with their arity, built the set FS(p). =n is an abbreviation for f =n 2 FS(p), F=n 2  and c=n 2 C. In every Core Erlang program a main function is de ned: main=0 2 FS(p).

The program creates a database process holding a state in which the database information is stored. The database is represented by a list of tu- ples, each consisting of a key and a corresponding value. The interface of the database is given by the messages {allocate,Key,P} and {lookup,Key,P}. Allocation is done in two steps. First the key is received and checked. If there is no con ict, then the corresponding value can be received and stored in the database. This exchange of messages in more than one step has to guarantee mutual exclusion on the database, because otherwise it could be possible that two client processes send keys and values to the database and they are stored in the wrong combination. A client can be de ned accordingly [10]. We will later prove that the database combined with two accessing clients ful lls this property.

Erlang is a strict functional programming language. It is extended with pro- cesses, that are concurrently executed. With spawn(f; [a1;::: ; an]) a new process can be created anywhere in the program. The process starts with the evaluation of f (a1;::: ; an). If the second argument of spawn is not ground, it is evaluated before the new process is created. The functional result of spawn is the process identi er (pid) of the newly created process.

With p!v arbitrary values (including pids) can be sent to other processes. The processes are addressed by their pids (p). A process can access its own pid with the Erlang function self/0. The messages sent to a process are stored in a mailbox and the process can access them conveniently with pattern matching in the receive-statement. Especially, it is possible to ignore some messages and fetch messages from further behind. For more details see [1].

In [10] we presented a formal semantics for Core Erlang. In the following we will refer to it as standard operational semantics (SOS). It is an interleaving semantics over a set of processes . Formally, a process consists of a pid ( 2 Pid := f@n j n 2 INg), a Core Erlang evaluation term (e 2 ET (TC(P id))) and a word over constructor terms, representing the mailbox (q 2 T (P id) ). For the de nition of the leftmost innermost evaluation strategy, we use the technique of evaluation contexts [7]:

Here v denotes an evaluated expression, E the subterm the redex is in and e and m the parts which cannot be evaluated. [] is called the hole and marks the point for the next evaluation. We shall then write E[e] for the context E with the hole replaced by e and the next step of the evaluation takes place here. Analogously to the Core Erlang Terms ET (S) over a set S, we name the Core Erlang contexts EC(S). The set S de nes, the set of values: v 2 TC(S). In the operational semantics de ned in [10] we had (S = TC(P id)). For the abstraction presented in this paper S will also contain variables.

The semantics is a non-con uent transition system. The evaluations of the processes are interleaved. Only communication and process creation have side e ects. For the modeling of these actions more than one process are involved. To give an impression of the semantics we present the rule for sending a value partial order v, describing which elements of A are more precise than other ones. We do not need a complete partial order, because we do not compute any xed point. We just evaluate the operational semantics with this abstract interpretation. An example for an abstraction of numbers with an ordering of the abstract representations is: IN v fv j v 10g v fv j v 5g. It is more precise to know, that a value is 5, than 10 than any number. The last component of A is the abstraction function:  : TC(P id) ! A maps every real value to an abstract representation. Usually this is the most precise rep- resentation. Finally, the abstract interpretation has to ful ll ve properties, which relate an abstract interpretation to the standard interpretation. They guarantee that all paths of the SOS are represented in the AOS, for example in branching. An example for these properties is the following

It postulates, that evaluating a prede ned function or a constructor on ab- stract values, which are representations of some concrete values yields abstrac- tions of the evaluation of the same function on the concrete values. The other properties postulate correlating properties for matching and pattern matching in case and receive, and the pids represented by an abstract value. More details and some example abstractions can be found in [10,11]. We do not de- which contains in nitely many di erent states. This abstract semantics is correct with respect to the operational semantics, in the sense, that all paths of the SOS are represented. But we cannot prove properties for this abstract semantics using simple model checking algorithms, because it has an in nite state space.

The source of the problem is the context-free structure of function calls. For special classes of context-free transition systems, it has been shown, that model checking is decidable [4,3] and it seems that these theoretical results could be used here. But we do not have just one context-free transition system. We have several of them in multiple processes which can communicate with each other. Hence we can simulate several stacks which can exchange data. It is possible to simulate a Turing machine with the use of a nite domain abstraction containing only ve values. In LTL it is possible to specify its termination. Therefore the veri cation of these systems is undecidable in general.

This technique could be applied to the Erlang semantics. But in the se- mantics of Core Erlang all processes act interleaved and the critical calls and returns of a process cannot be identi ed and modi ed so easily. Here we only represent the behaviour of one process. This makes an analysis easier. We de-

If we have no evaluation context anymore, in other words, the Core Erlang term is a constructor term over variables, then we have to return to the last context (11). We cannot simply, copy the value a into the hole, because a could contain variables, which also occur in E. In the SOS these variables are usually bound to di erent values. Hence we introduce a new variable Y , which does not occur in E and bind this variable to the result of the evaluation, which is a. on top of this graph representation an (abstract) semantics can easily be de ned. For Core Erlang programs which use recursion only in tail positions, the graph representation is a nite transition system.

Our approach is a kind of call-string approach [17] on program level. The main idea of the abstraction is to replace the calls and the returns by jumps. For Example 6.1 a good abstraction is, that rst n times an a is sent and after that m times a b. A property like "no a is sent after a b" could then be proven automatically.

But how can we perform the corresponding return step? We know the stack of the state we jumped to instead of calling f. Hence the evaluation of this call will be terminated, if the Core Erlang term is evaluated to a value with the same stack as the one we jumped to instead of the call. These are all states of the form (a j (f; [ ]; self!b)) with a 2 TC(Var). In our example this is only the state (b j (f; [ ]; self!b)). The destination of this returning jump

We do not pop the top-level context, as usually in a return step. The context stack is not modi ed. The result is a nite graph representation, in which n times an a is sent and then m times a b.

In the abstraction above we replace the communication by sending n times a and m times b. But what can we do here? In the abstract domain these values are represented by abstract values, which must not be an in nite set (especially in a nite domain abstraction). Jumping back instead of calling, we cannot know to which value X is bound. Hence we bind X to the value ?, which represents every value in the abstract domain A. We claim, that such a value exists in our abstract domain. Otherwise we can always add ? with stack, because in the AOS these stored contexts still have to be executed. But with the variable bindings in these contexts we have the same problem, as with variables in the Core Erlang term, the evaluation returns with. The solution is to add bindings for the variables of these contexts to ?.

We also have to note these changes of the call stack in the label, because in the AOS we stack the substitutions in the same manner as in the graph representation. Hence we annotate the number of stack elements, which are removed instead of pushing a new block, in an abstract call. Analogously we note the number of stack elements, which have to be added in the abstract return jump and add the substitutions to ? for these frames. For corresponding calls and returns these numbers coincide. In our example it is zero, because no functions were called in between ?. The variables which will later be bound by pattern matching need not to be replaced. Since Erlang has no scoping, we do not know if a variable occurring in a subterm is free or bound. We need an analysis, which marks the variables which are already bound to values. This analysis can be combined with the construction of the abstract graph representation. Building the graph representation we can detect, when a variable is instantiated. We mark it with a tag ( 0 ). When we simulate the return of an abstracted call, we can bind all tagged variables to ?. The others can be left unchanged in the return jump:

Recursion is abstracted by jumps back to the last call of the same function. It is detected in the call stack, if the same function was already called. The destination state of this jump has a smaller call stack, than the call would yield. To relate call stacks in the graph representation with their abstract representation, we de ne an abstraction function . This function yields the call stack, which grows by stepwise extension of the call stack and replacement of the occurring recursion by decreasing. This decreasing represents jumps back to previous calls.

From the de nition it is not directly clear that  is total. But with the following lemma, we see that always one of the two cases for ((f; E)W ) matches. Hence  is de ned for all call stacks.

If the function call is not abstracted by a jump we get n =  1. This means that we can add the actual context to the call stack, as we would do without abstraction. In this case we will just write c instead of c(-1). Otherwise we also add a jump back. This means, we detect recursion and j (W )jf = 1. For all a 2 TC(Var):

Note that still n = j (W )j   j ((f; E0)W )j and n   0 always holds, if j (W )jf = 1. In this case W1 ::: Wn are the blocks which have to be restored in this return jump. The instantiated variables in these blocks and in E cannot be known. We have to instantiate them with ? in the evaluation. The func- tion tagged yields all tagged variables. For these we can de ne substitutions, which instantiate them with ?. These are the substitutions [tagged(E)=?] and ( 1;::: ; n). We add them to the label.

We now return to Example 2.1 from the beginning of the paper. We want to prove that this database combined with two clients guarantees mutual exclu- sion for the writing access to the data. This means, when a process allocates a key no other process instantiates this key. This can be expressed with the following extended LTL formula:

Usually LTL is de ned on state propositions. For understandability, we use the label of an arc to a state as its proposition here. In the implemented prototype we can add state propositions to the program, which makes it easier to express properties. For shortness we omit the details here.

To prove this property we use a simple abstraction in which the depth of constructor terms is restricted to two [11]. This guarantees a nite transition system and the property can automatically be proven. Without the abstrac- tion presented in this paper we could not prove this property for the program, because the function insert contains a non-tail recursive call. The transi- tion system generated by any abstract interpretation is in nite. But with the presented abstraction of the context-free structure, we obtain a nite state transition system and can prove the formula automatically.

For the formal veri cation of concurrent and distributed systems, which are implemented in real programming languages, abstraction is needed. We have presented an abstraction of the context-free structure of Erlang programs. The result is a nite graph representation of the possible evaluations a process may perform. The graph includes all paths of the SOS. It can be used to verify properties of Erlang programs with model checking. The abstraction preserves enough structure to check interesting properties in practice. For tail recursion the abstraction does not even add any paths.

Besides enabling the abstraction of the context-free structure, the graph semantics has another important advantage for the implementation. It also yields a much more compact representation of the AOS, which allows us to verify larger systems with the same memory. We have implemented the ab- straction of the context-free structure as a prototype and are able to prove properties like the one above with model checking.

Another approach for the veri cation of Erlang programs is the Erlang Veri cation Tool [15], which uses theorem proving. For more convenience, the developers want to integrate model checking in their tool. At the moment they only consider pure model checking without any abstraction [2]. We think that for the veri cation of real systems abstractions is needed and the presented techniques should be considered for the integration of model checking.

It would also be interesting to implement our approach as a translation to Promela, the speci cation language of SPIN [9], as it was done for Java/Ada with Java PathFinder [8] and the Bandera Tool [6]. But we rst concentrated on the formal analysis to understand what happens in the abstraction of Core Erlang programs. A large problem in the translation to Promela will be the fact, that the languages Erlang (in contrast to Java) and Promela are com- pletely di erent. Additionally, this is relevant for the generation of counter examples, which have to be retranslated to Erlang.

[4] Olaf Burkart and Bernhard Ste en. Model checking for context-free processes. In W. R. Cleaveland, editor, CONCUR '92: Third International Conference on Concurrency Theory, volume 630 of Lecture Notes in Computer Science, pages 123{137, Stony Brook, New York, 24{27August 1992. Springer.

[14] Orna Lichtenstein and Amir Pnueli. Checking that nite state concurrent programs satisfy their linear speci cation. In Conference Record of the Twelfth Annual ACM Symposium on Principles of Programming Languages, pages 97{ 107, New Orleans, Louisiana, January 13{16, 1985. ACM SIGACT-SIGPLAN, ACM Press.

[15] Thomas Noll, Lars- ake Fredlund, and Dilian Gurov. The erlang veri cation tool. In Proceedings of the 7th International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS'01), volume 2031 of Lecture Notes in Computer Science, pages 582{585. Springer, 2001.

