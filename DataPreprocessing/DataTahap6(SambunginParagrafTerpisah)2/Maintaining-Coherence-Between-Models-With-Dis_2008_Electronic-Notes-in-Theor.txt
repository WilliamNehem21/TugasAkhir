Integrated Development Environments supporting software and model evolution have to deal with the problem of maintaining coherence between code and model despite changes which may occur on both sides. Rather than going through model reingeneering or code regeneration, it would be better to build a full correspondence between the starting models and keep it updated in an incremental way after each evolutionary step. In a series of previous papers, it was shown how distributed graph rewriting could support such updates. Here, we show how to construct a distributed graph from individual models, through the use of synchronized rules. In particular, we discuss the case of Java code and UML models, and propose an Eclipse implementation of the approach.

of distributed graph rewriting [3,4] for an integrated management of modifications in the code and in the global UML model underlying a software artifact. The approach is based on identifying mappings between software elements, represented by an Abstract Syntax Tree (AST) derivable from the code, and model elements, expressed in UML terms. Both AST and UML models are seen as instances of their respective metamodels, interpreted as graph types. In this context, the construction of the correspondence between them amounts to that of their (typed) interface graph. In such a graph, each node corresponds to some abstract concept common to the two models. At the instance level, morphisms between nodes in the interface graph and the corresponding nodes are constructed.

In this paper, we show how to construct the interface graph and the associated morphisms, based on the assumption that the two models (AST and UML) already exist and are coherent in the sense that elements with the same (qualified) name refer to the same concept. The approach can be easily extended to the case of two incoherent models, so that reasons for failure can be identified. On the other hand, by assuming one of the two models as correct, repair actions can performed on the other one.

The rest of the paper develops as follows. After a brief recall of Theory in Section 2, we present the general pattern of transformation some of its specific instantiations in Section 3. Section 4 presents the Eclipse implementation and conclusions are given in Section 5.

In this section, we illustrate the approach to the construction of the correspondence, by showing a general template for the used transformation units and illustrating it by an example. The complete construction is described in [12]. While the identi- fication of corresponding elements is based on type and name identities, the main problem lies in the identification of the context, i.e. the namespace, in which to check identities. A general search template has therefore been specifically devised to address this problem.

In general, we consider the Java AST as the basis for the construction process, so as to exploit the facilities for tree visit provided by Eclipse. For the sake of simplicity, a slightly abstract form of Java and UML model elements are used in the rules. Where necessary, adaptations of the rules to the real metamodels are discussed.

Eclipse is a platform centric IDE which offers tools to develop and maintain soft- ware taking into account various project aspects. The whole Eclipse architecture is extensible and open. Indeed, tools belonging to the platform are structured as plug-ins. Each plug-in can define one or more extension-points, places where an- other plug-in can attach itself to provide new capabilities and offer an interface to the existing ones.

Correspondence construction in C2MCM is started by a call to the method startEngine(ICompilationUnit icu), where the actual value for icu is an instance implementing the ICompilationUnit interface, specified by the user through the plug-in GUI. This is the root of an AST built from a .java file. Besides loading the AST, this method evaluates the URI of the UML2 model on which to construct the mapping and passes it to the loadModel(URI uri) method which actually loads it.

Actually, visiting the tree according to the node types allows the interleaving of rules from different transformation units. However, this does not alter the fi- nal result with respect to the normal execution of these transitions. Indeed, each transformation unit resulting from the instantiation of the template produces, as its net effect, the construction of a node in the interface graph and of the mappings to UML2 and AST models, without eliminating any existing node or edge. As a result, no derived rule for each such instantiation may disrupt the positive context for the application of another (i.e. to consume something in the left-hand side of a rule ). Hence, building a correspondence between some elements cannot prevent the construction of other correspondences between elements in their context. We can thus conclude that any interleaving of rules from different transformation units produces the same result, provided that any partial order between rules in the same transformation unit is respected.

loadModel() returns a Package model class instance with the same name as the Package Java class. To avoid namespace conflicts, we adopt the convention of always using the fully qualified name org.eclipse.uml2.Package. The model is loaded through a call to an EMF method, as the UML2 plug-in is an extension of the Eclipse Modelling Framework.

The first step to the Eclipse implementation of a transformation unit is to identify the nodes that should be visited in the AST. The visit is started on the nodes for which a transformation unit is defined. This results in the mappings prescribed by instantiations of mapChild, and possibly in those prescribed in the instantiations of mapParent, which are optionally applied. According to the AST Eclipse API, it is necessary to override the appropriate visit() method for each node type that has to be visited by the framework 2 The steps below analyze the template core notions and show the skeleton followed to build the Eclipse implementation:

Context Identification and Applicability: The identification of the context (schematised in the template as parent) for the node under examination is done by navigating the tree starting from the current node and looking for the pattern described in the mapParent() rule, also checking the applicability conditions. In most cases, this is simply done by navigating upwards until a node of a specific type is found. As node visits proceed from the root downwards, a mapping for the found parent may have been constructed in the visit of some other type with the same context (e.g. fields and methods in a class).

