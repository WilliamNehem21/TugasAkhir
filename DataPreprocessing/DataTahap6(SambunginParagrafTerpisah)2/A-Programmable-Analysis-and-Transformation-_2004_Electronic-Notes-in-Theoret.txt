Reverse Engineering refers to understanding an existing software system, and documenting the understanding in a desired format. Depending upon the purpose, which can be problem diagnosis, impact analysis, functional enhancements, or re-engineering to newer technologies or newer design, the reverse engineering artifacts vary in their definition, the abstraction level, and contents. Current state of practice relies on pre-cast tools, which extract a set of pre-defined information, with little or no inputs from the analyst. We propose a specification-based approach that allows analyst to specify and control the contents and abstraction level of the reverse engineering artifacts, while allowing user-interaction during extraction.

Few frameworks exist, that are based on the extract-abstract-view princi- ple. Many allow querying over program sources and their structural properties, but do not support querying of semantic properties. Some of these frameworks are exploratory, while others are built for specific modern languages like C, C++ and Java. Examples are Acacia [3], CppAnal [4], and DALI [5].

Our approach differs primarily in that it provides mechanisms to define ab- stractions, to query on semantic program properties, and enable displaying the results in different forms appropriate for the purpose. The subject programs are represented as models. This provides an inherent, first level of abstrac- tion, and makes the framework to be language independent. In addition, the framework is based on a proven, flow-analysis framework for procedural lan- guages, Darpan [6]. Though the origin of this approach lies in our experience of building re-structuring and reverse engineering tools for COBOL and RPG applications, few lessons are derived from the work of Programmable Reverse Engineering [7]. Our work comes closest to the work by Stan Jarzabek and Guosheng Wang [10]. However, we have imperative style of specifications as against their declarative style, we support program semantic properties and aim to provide code level transformations.

Display specifications enable mapping between abstraction definition and pre-defined display types. These enable the abstractions to be viewed using the specified displays. Alternately, user can view the abstractions in a manually programmed user-interface, or add new display types to the framework.

We view the source programs as mod- els, thereby raising the level of abstrac- tion of the input. Core program anal- ysis is viewed as a process of com- puting pre-defined program properties from program models. Program prop- erties, like control-flow graph, data- flow information can also be viewed as abstractions.

The framework makes program properties available as primitives. Program properties like call-graph, def-use chains, alias information, copy constants, and others are computed by a data-flow analyzer, which is generated using Darpan [6]. New properties can be computed by writing new specifications for Darpan or can be provided by the user. The idea is to apply these properties to the program elements of interest, and based on the property values, decide whether the program element can belong to the abstraction being constructed.

These specifications allow users to specify two kinds of information. One is how the user would see the results of transformation specifica- tions; this part consists of window specifications. Second is a mapping specification to map the abstraction types to pre-defined display types. They are specified as XML specifications. An example mapping specifi- cation to display error-handling statements is written as:

These specifications will allow analysts to specify transformation of the source programs to desired target programs. This will be based on analysis abstractions extracted earlier. One example is to separate the source programs into GUI layer and business layer. Code generation capability will need to generate concrete syntax of the target programs.At the moment, we are working on these specifications.

The analysis and transformation framework is designed to be inter- pretive. The sole purpose is that the analysts can build reverse en- gineering tools quickly, and ex- plore by changing the tool speci- fications and viewing the changed behaviour of the tool. Vari- ous engines are provided to sup- port the execution environment: search engine, abstraction engine, display engine and data-flow ana- lyzer.

Having reused existing parsers, model representation of programs and ana- lyzer generator, the framework is currently in a prototype stage. Using the prototype, we are defining ER (Entity-Relationship) model extraction from COBOL programs. We propose to use this framework for DFD (Data-Flow) model extraction, both of these geared towards system documentation initia- tive.

We describe below the steps involved in defining and implementing a reverse engineering tool using the framework. The steps mentioned here are indicative. The analyst identifies the abstractions that are to be delivered (e.g. Call graph report, Error handling statements, Entity-Relations model, etc.). For

Analyst starts execution of the framework, which has a pre-defined user- interface. In case of framework-based-tool, analyst builds the tool. This runs the specification processor, generates interpreter instructions, and adds the tool to the menus of the framework. In case of non-framework-based-tool, analyst uses the build menu to specify mapping between tool and the class that implements the tool. The build will add the tool to the menus of the framework.

Based on our experience of building restructuring tools, we have evolved a specification driven reverse engineering framework that is independent of the programming language. The prototype has enabled tool builders to rapidly experiment with program analysis based, reverse engineering tools, and change the tool behaviour quickly. We believe that support for model generation, a proper balance between number of primitives and flexibility of specifications, and ability to integrate existing viewing tools, will go a long way to prove utility of this framework.

