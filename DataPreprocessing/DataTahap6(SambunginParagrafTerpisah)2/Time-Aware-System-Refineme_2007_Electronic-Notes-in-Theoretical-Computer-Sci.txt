We propose a formal, time aware refinement of systems. The proposed timewise refinement method is a direct extension of the traditional refinement calculus of Action Systems. The adaptation provides a well- founded mathematical basis for the stepwise refinement of systems modelled with the time spiced Action Systems formalism. In the refinement of an abstract system into a more concrete one a designer must show that conditions of both functional and temporal properties are satisfied.

[4]. Conventional Action Systems is a state based formal description language ini- tially proposed by Back and Kurki-Suonio [1]. It is based on an extended version of a guarded command language introduced by Dijkstra [5]. It is used for specification and correctness preserving development of reactive systems. It was first tailored to a software system design but is then successfully applied also to hardware system design, both synchronous [9] and asynchronous [8].

The refinement based development method is introduced for several different spe- cification languages some of which does not guarantee the correctness of a concrete model after several refinement steps while the others allow a stepwise development method, a chain of refinements. We shortly discuss three different refinement ap- proaches that belongs to the latter group with our approach. In [13] is introduced an approach to refine high-level Timed MSC model into design specification. Their refinement approach resembles our trace refinement, as the environment should not distinguish between a given model and its refinement. In our approach, however, we do not consider the refinement of time constraints as in our target environment, VLSI systems, the system constraints are given by the specification, and thus are not allowed to be relaxed. However, the time constraints are allowed to be refined to meet the new, refined timed action system. In [7] is presented a refinement of action for real-time concurrent systems. They have taken the approach that the refined [6] for stepwise development of machine-independent real-time programs. The scope of this research is on software development. For our knowledge their approach is not applied in SoC/NoC system design, which is the interest of our research, nor it is possible to perform static timing analysis with their approach.

In the above system we can identify three main sections: interface, declarative and iteration. The interface part declares those variables, g, that are visible outside the action system boundaries, and thus accessible by other timed action systems. If a timed action system does not have any interface variables, it is a closed action sys- tem, otherwise it is an open action system. In the declarations part is introduced all the local variables l, action definitions that perform operations on local and global variables, where aAi is any kind of the defined atomic actions generated by the syntax given previously, Ai its label and dAi a predicate that determines its delay. The predicate is joined to a timed action between the delay brackets ). Further- more, constraints Cj that define conditions whose strict adherence is mandatory are introduced in the declarative part. Finally, before the iteration section, the do-od loop of a timed action system, is the initialisation of both the global and local vari- ables. The do-od loop defines a reactive behaviour of the system. It describes the composition of actions defined in the declarative part, that is, it defines the reactive behaviour, functionality of the system.

As stated above, a delay of a timed action, say A, is determined by the predic- ate dA given in the delay clause located in the declarative part. In this section we introduce the two most commonly used delay predicates: a deterministic dAn and non-deterministic dAnd delay predicates. For these two predicates we use the following abbreviations A d) and A dmin, dmax), respectively. They are defined by: where we can identify three operational segments diveded by the prioritised compot- ision: commence, end and time. The commence segment contains the start action As whose execution initiates the operation of the timed action, and the operation is terminated in the end segment which consists of the finish action Af and the kill action Ak. The one which will be executed depends on the enabledness of the timed action. That is, if a timed action is disabled by some other timed action when it is considered a scheduled timed action the kill action releases it for future computa- tion. It prevents a timed action being deadlocked. The time is advanced in the time segment after the execution of the start action by executing the time propagation action Pt. A timed action whose operation is performed, but its write variables are not yet updated, is called a scheduled timed action. The time period during which a timed action is considered a scheduled one is determined by the predicate dA.

Example 2.2 In Example 2.1 we introduced an action M . Let us place that action into a timed action system Mult below. The system Mult is operating in an environment E nv that updates the input variables and enables and disables the computation using a boolean variable en, and, finally, it reads the result of the computation. We have: where the non-deterministic delay defines the minimum dmin and maximum dmax operation times for the multiplication. The chosen delay type, in this example, is used to denote data-dependent delay, that is, a delay whose value depends on the values of the operands. The delay values without knowing, for example, a multi- plication algorithm or a production technology are conservative ones. In this paper, however, we do not enlarge upon the algorithms nor the production technology.

Conventional Action Systems are meant to be designed in a stepwise manner within the refinement calculus framework [4]. The refinement calculus preserves the cor- rectness of actions during refinement procedure. In this section we concentrate on applying the well-founded refinement calculus framework for timed actions. As presented in the previous section the timed notation is a clear extension of the un- timed model. Therefore, we adopt the refinement calculus of conventional actions, and extend it to the time domain.

The above presented data refinement rule will be used also for timed actions in the next section where a trace refinement of a timed action system is introduced. We will not introduce a data refinement rule for a timed action as there is no use for it due to the chosen modelling approach presented in Sect. 2.4, and that constraints,

In the trace refinement of a timed action system introduced above, we adopted the first five conditions (i)- (v) as such from the trace refinement of a conventional action system. This approach is justified by the fact that Timed Action Systems ex- tends conventional Action Systems by defining a delay that determines the time after which the result is written onto write variables. The operation part, functionality, of a conventional action is not altered.

Timing behaviour. The maximum allowed operation time for the timed action M is D: Q{M, D}. Although we decompose the action into two parts the scope of the deadline remains unchanged, that is, the observation point is the time point at when M1 commence its operation and the validation point is the time point at when M2 finish its operation. In calculating the delay for the composition we use the delay calculation rule (6), although the composition suggests rule (8). This is justified by the interaction of the refined timed actions:

The keep the constraints up-to-date they are changed to meet the new action definitions. In our example the deadline thus becomes Q{(M1; M2), D} due to the fact that the former timed action enables the latter. We do not see this as a refine- ment, because the constraint itself is not changed, that is, the scope of a constraint remains the same as pointed earlier.

