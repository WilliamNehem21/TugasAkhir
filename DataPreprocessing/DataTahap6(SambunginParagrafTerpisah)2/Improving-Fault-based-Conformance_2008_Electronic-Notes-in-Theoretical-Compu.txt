Fault-based conformance testing is a conformance testing strategy that relies on specific fault models. Previ- ously, this mutation testing technique has been applied to protocol specifications. Although a practical case study of web-server testing has been conducted, we observed several issues when applying this method in a large industrial project. In this paper, we discuss the foundations, techniques and tools to overcome these shortcomings. More specifically, we show a solution to the problem of state-space explosion in generating mutation tests for industrial scale applications. Furthermore, the previous approach used the counterex- amples of a bisimulation check (between the original and the mutant) as test purposes. With respect to

Nowadays software and software-enabled systems are becoming increasingly com- plex. Model-based testing techniques assist in systematic testing of such systems. By starting from a formal model test cases are derived automatically in order to test the conformance of implementations with respect to their specification.

However, given a formal specification there is a huge, possibly infinite, number of test cases that can be derived from that specification. There are different ways of selecting a finite set of test cases. One possibility is the use of coverage criteria on the level of the specification for test case selection. Another way, is the use of anticipated faults for the generation of test cases. This approach of test case selection, which is subject to this paper, is also known as mutation testing and was conform implementations. However, there are test cases for faults that can not be detected using the ioco-relation. Thus, using bisimulation results into more test cases than needed. Second, the original approach relies on the construction of the complete state spaces of both, the original specification and the mutated specifica- tion. For industrial specifications with huge state spaces this is often infeasible. In this paper we address these two problems.

This paper continues as follows. In Section 2 we review the underlying testing theory. In Section 3 we develop the foundations for a new ioco-based test case selection approach. Section 4 shows how to deal with large specifications and Sec- tion 5 outlines the overall approach. Section 6 shows our experimental results. In Section 7 we briefly review related work. Finally, we conclude in Section 8.

Basically, we use mutation operators at the specification level in order to generate faulty versions of a specification. The mutation of the specification affects the underlying formal model, which is an input-output labeled transition system in our case. Not all mutations represent faults. A fault can only be defined with respect to a conformance relation. In the following we show the meaning of faults in the context of ioco.

The theory highlights a further important clarification in fault-based testing: In presence of non-determinism, there is no guarantee that an actual fault will always be detected. The reason is that non-conformance only means that there is a wrong output after a trace of actions, but the implementation may still opt for the correct one. In that case we rely on the complete testing assumption [14], which says that an implementation exercises all possible execution paths of a test case t, when t is applied a finite number of times.

Note, that we rely on lotos [12] specifications for our discussion. Since lo- tos does not distinguish between input and output events, i.e. lotos has an LTS semantics, input-output information is added during test case generation. How- ever, our approach is applicable to any other specification language with (IO)LTS semantics.

Up to 77% of our 252 test purposes can be generated within reasonable time (i.e. 1000 seconds per test case). The other 23% test purposes are regarding complex scenarios of our specification (e.g., client registers and removes its registrations afterwards). These complex scenarios push the average up.

The incremental slicing technique, which has been evaluated in [4], failed on some complex mutants of our specification. More precisely, incremental slicing failed on approximately 14% of the evaluated mutants. In difference to that, using the CADP on-the-fly model-checker allows to generate sliced state spaces for all of our mutations.

thors of [8] present a modified model-checking algorithm that allows to transform properties, given in computational tree logic (CTL), to test purposes. Henniger et al. [11] automatically generate test purposes by identifying significant behavior of a system. Each signification behavior is converted to a test purpose. However, both articles do not consider testing for specific faults.

Petrenko and Yevtushenko [18] showed how to use partial, non-deterministic finite state machines (FSM) for mutation based test case generation. This work makes FSM based testing more amenable in industrial applications where specifi- cations are rarely deterministic and complete. The difference to our approach is the used model. FSMs assume that a system cannot accept a next input before producing an output as a reaction to a previous input.

In this paper, we have developed a new ioco-based test case generation technique focusing on faults. It has been shown that this represents an advancement to previ- ous approaches [1,3], from both a theoretical and an experimental point of view: (1) In contrast to the previous approach we generate ioco-relevant test cases only. In the case of our Session Initiation Protocol (SIP) Registrar experiments this means a reduction of 36% in the overall number of test cases. (2) Furthermore, we pushed the limits of this technique by developing an improved slicing technique. In the case of our SIP Registrar experiments the incremental slicing technique runs out of memory for complex scenarios which did not happen for the presented model- checker based slicing technique. We strongly believe, that these advancements make fault-based conformance testing more amenable to industrial-scale testing.

The research herein is partially conducted within the competence network Soft- net Austria (www.soft-net.at) and funded by the Austrian Federal Ministry of Economics (bm:wa), the province of Styria, the Steirische Wirtschaftsfrderungsge- sellschaft mbH. (SFG), and the city of Vienna in terms of the center for innovation and technology (ZIT). Additionally, this research is partially funded by the EU project, Framework 6: IST-33826 CREDO.

